{"id":161888,"title":"答疑：有关3个典型问题的讲解","content":"<p>你好，我是欧创新。</p><p>截至今天这一讲，我们的基础篇和进阶篇的内容就结束了。在这个过程中，我一直有关注大家提的问题。那在实战篇正式开始之前啊，我想针对3个比较典型的问题，做一个讲解，希望你也能同步思考，调动自己已学过的内容，这对我们后面实战篇的学习也是有一定帮助的。</p><p><strong>问题1：有关于领域可以划分为核心域、通用域和支撑域，以及子域和限界上下文关系的话题，还有是否有边界划分的量化标准？</strong></p><p>我在  <a href=\"https://time.geekbang.org/column/article/149945\">[第 02 讲]</a>  中讲到了，在领域不断划分的过程中，领域会被细分为不同的子域，这个过程实际上是将问题范围不断缩小的过程。</p><p>借用读者“密码123456”的总结，他认为：“对于领域问题来说，可以理解为，对一个问题不断地划分，直到划分为我们熟悉的、能够快速处理的小问题。然后再对小问题的处理排列一个优先级。”</p><p>这个理解是很到位的。在领域细分到一定的范围后，我们就可以对这个子域进行事件风暴，为这个子域划分限界上下文，建立领域模型，然后就可以基于领域模型进行微服务设计了。</p><p>虽然DDD没有明确说明子域和限界上下文的关系。我个人认为，子域的划分是一种比较粗的领域边界的划分，它不考虑子域内的领域对象、对象之间的关系和结构。子域的划分往往按照业务阶段或者功能模块边界进行粗分，其目的就是为了让你能够在一个相对较小的问题空间内，比较方便地用事件风暴来梳理业务场景。</p><!-- [[[read_end]]] --><p>而<span class=\"orange\">限界上下文本质上也是子域</span>，限界上下文是在明确的子域内，用事件风暴划分出来的。它体现的是一种详细的设计过程。这个过程设计出了领域模型，明确了领域对象以及领域对象的依赖等关系，有了领域模型，你就可以直接进行微服务设计了。</p><p>关于核心域、通用域和支撑域，划分这三个不同类型子域的主要目的是为了区分业务域的优先级，确定IT战略投入。我们会将重要的资源投入在核心域上，确保好钢用在刀刃上。每个企业由于商业模式或者战略方向不一样，核心域会有一些差异，不要用固定的眼光看待不同企业的核心域。</p><p>核心域、通用域和支撑域都是业务领域，只不过重要性和功能属性不一样。采用的DDD设计方法和过程，是没有差异的。</p><p>从目前来看，还没有可以量化的领域以及限界上下文的划分标准。它主要依赖领域专家经验，以及和项目团队在事件风暴过程中不断地权衡和分析。不要奢望一次迭代就能够给复杂的业务，建立一个完美的领域模型。领域模型很多时候也需要多次迭代才能成型，它也需要不断地演进。但如果是用DDD设计出来的领域模型的边界和微服务内聚合的边界非常清晰的话，这个演进过程相对来说会简单很多，所需的时间成本也会很低。</p><p><strong>问题2：关于聚合设计的问题？领域层与基础层为什么要依赖倒置（DIP）？</strong></p><p>聚合主要实现核心业务逻辑，里面有很多的领域对象，这些领域对象之间需要通过聚合根进行统一的管理，以确保数据的一致性。</p><p>在聚合设计时，我们会用到两个重要的设计模式：工厂（Factory）模式和仓储（Repository）模式。如果你有兴趣详细了解的话，推荐你阅读《实现领域驱动设计》一书的第11章和第12章。</p><p>那为什么要引入工厂模式呢？</p><p>这是因为有些聚合内可能含有非常多的实体和值对象，我们需要确保聚合根以及所有被依赖的对象实例同时被创建。如果都通过聚合根来构造，将会非常复杂。因此我们可以通过工厂模式来封装复杂对象的创建过程，但并不是所有对象的构造都需要用到工厂，如果构造过程不复杂，只是单一对象的构造，你用简单的构造方法就足够了。</p><p>又为什么要引入仓储模式？解答这个问题的同时，我也一起将依赖倒置的问题解答一下。</p><p>在传统的DDD四层架构中，所有层都是依赖基础层的。这样做有什么不好的地方呢？如果应用逻辑对基础层依赖太大的话，基础层中与资源有关的代码可能会渗透到应用逻辑中。而现在技术组件的更新频率是很快的，一旦出现基础组件的变更，且基础组件的代码被带入到了应用逻辑中，这样会对上层的应用逻辑产生致命的影响。</p><p>为了解耦应用逻辑和基础资源，在基础层和上层应用逻辑之间会增加一层，这一层就是仓储层。一个聚合对应一个仓储，仓储实现聚合内数据的持久化。聚合内的应用逻辑通过接口来访问基础资源，仓储实现在基础层实现。这样应用逻辑和基础资源的实现逻辑是分离的。如果变更基础资源组件，只需要替换仓储实现就可以了，不会对应用逻辑产生太大的影响，这样就实现了应用逻辑与基础资源的解耦，也就实现了依赖倒置。</p><p>关于聚合设计过程中的一些原则问题。大部分的业务场景我们都可以通过事件风暴，找到聚合根，建立聚合，划分限界上下文，建立领域模型。但也有部分场景，比如数据计算、统计以及批处理业务场景，所有的实体都是独立无关联的，找不到聚合根，也无法建立领域模型。但是它们之间的业务关系是非常紧密的，在业务上是高内聚的。我们也可以将这类场景作为一个聚合处理，除了不考虑聚合根的设计方法外，其它诸如DDD分层架构相关的设计方法都是可以采用的。</p><p>一些业务场景，如果复杂度并不高，而用DDD设计会带来不必要的麻烦的话，比如增加复杂度，有些原则也是可以突破的，不要为做DDD而做DDD。即使采用传统的方式也是没有关系的，最终以解决实际问题为最佳。但必须记住一点，如果采用传统的设计方式，一定要保证领域模型的边界以及微服务内聚合的逻辑边界清晰，这样的话，以后微服务的演进就不会太复杂。</p><p><strong>问题3：领域事件采用消息异步机制，发布方和订阅方数据如何保证一致性？微服务内聚合之间领域事件是否一定要用事件总线？</strong></p><p>在领域事件设计中，为了解耦微服务，微服务之间数据采用最终一致性原则。由于发布方是在消息总线发布消息以后，并不关心数据是否送达，或者送达后订阅方是否正常处理，因此有些技术人会担心发布方和订阅方数据一致性的问题。</p><p>那在对数据一致性要求比较高的业务场景，我们是有相关的设计考虑的。也就是发送方和订阅方的事件数据都必须落库，发送方除了保存业务数据以外，在往消息中间件发布消息之前，会先将要发布的消息写入本地库。而接收方在处理消息之前，需要先将收到的消息写入本地库。然后可以采用定期对发布方和订阅方的事件数据对账的操作，识别出不一致的数据。如果数据出现异常或不一致的情况，可以启动定时程序再次发送，必要时可以转人工操作处理。</p><p>关于事件总线的问题。由于微服务内的逻辑都在一个进程内，后端数据库也是一个，微服务内的事务相比微服务之间会好控制一些。在处理微服务内的领域事件时，如果引入事件总线，会增加开发的复杂度，那是否引入事件总线，就需要你来权衡。</p><p>个人感觉如果你的场景中，不会出现导致聚合之间数据不一致的情况，就可以不使用事件总线。另外，通过应用服务也可以实现聚合之间的服务和数据协调。</p><p>以上就是3个典型问题的答案了，不知你先前是否有同样的疑惑，这些答案又是否与你不谋而合呢？如果你还有其它问题，欢迎在留言区提出，我会一一解答。</p><p>今天的内容就到这了，如果有所收获，也可以分享给你的朋友，我们实战篇见！</p><p></p>","neighbors":{"left":{"article_title":"10 | DDD、中台和微服务：它们是如何协作的？","id":161004},"right":{"article_title":"11 | DDD实践：如何用DDD重构中台业务模型？","id":163032}},"comments":[{"had_liked":false,"id":148460,"user_name":"吃饭饭","can_delete":false,"product_type":"c1","uid":1231549,"ip_address":"","ucode":"95CFA07CDA2957","user_header":"https://static001.geekbang.org/account/avatar/00/12/ca/bd/a51ae4b2.jpg","comment_is_top":false,"comment_ctime":1573011748,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"169076736292","product_id":100037301,"comment_content":"事件风暴？为什么一有关键词总会出现这个，它不就是一个集中讨论定需求的动作？陌生词汇太多，如果夹杂一些白话最好了，感觉这一套字眼真的是越说越迷糊了，DDD 我感觉说白了就是一种划分手段，核心最终都会落在为服务上","like_count":40,"discussions":[{"author":{"id":1142025,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6d/09/ffeabc27.jpg","nickname":"任鑫","note":"","ucode":"9803EB15B634C3","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584589,"discussion_content":"业界流行的通用语言一般比较个性，因此望文生义反而难以理解，就像蓝牙，不就是移动设备间的无线通信技术之一种嘛，但是人们普遍知道蓝牙是什么，就是建立了通用语言","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1660957461,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1080050,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7a/f2/6770d0a9.jpg","nickname":"张驰","note":"","ucode":"0ED97C2FCE6599","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375333,"discussion_content":"这就是通用语言的重要性，叫它事件风暴也好、头脑风暴也好、集中讨论也罢只要团队内大家达成共识，使用同一语言就可以了。   另外对于“DDD 我感觉说白了就是一种划分手段，核心最终都会落在为服务上”这句话，我理解前半句是对的，但是后半句中的DDD核心应该是划分的依据和过程。至于说最后落到服务上这是肯定的，但这不应该是DDD的核心，应该算是战术设计的核心。   不知道我这么理解对不对。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1621581911,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008257,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/81/ad80f427.jpg","nickname":"Lane","note":"","ucode":"F70459D1BBD9F4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581395,"discussion_content":"看到现在感觉像没看一样。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1658753004,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1435845,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e8/c5/8bdb0bba.jpg","nickname":"DarKnight","note":"","ucode":"B04AFD03768827","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329429,"discussion_content":"事件风暴（Event Storming）属于 DDD 里面的专业术语，感觉去理解和深入 DDD 之前，也需要先接受他们的专业术语的定义吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1606382774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1055610,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1b/7a/390a8530.jpg","nickname":"小木匠","note":"","ucode":"222F861CF9129C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581501,"discussion_content":"事件风暴就是个很好的例子，这套理论就是把我们平时已经使用的东西抽象出来，然后赋予一些名词，什么聚合根什么限界上下文。其实有些故弄玄虚。如果一个人逻辑清晰，不看这些理论也可以拆的很清楚，如果逻辑不清晰，学了这套并不会有什么帮助。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658818764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2246686,"avatar":"https://static001.geekbang.org/account/avatar/00/22/48/1e/883fd1d5.jpg","nickname":"Jacob Chen","note":"","ucode":"329B92B53F12B8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320496,"discussion_content":"感觉这文章看着吃力的很，很抽象，可能是水平问题吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604383524,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1744195,"avatar":"","nickname":"summer","note":"","ucode":"A568BC55C8FB89","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50350,"discussion_content":"我理解事件风暴应该属于项目头脑风暴，找出通用语言，串联业务后应该就是事件风暴产物","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573709875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":149001,"user_name":"张迪","can_delete":false,"product_type":"c1","uid":1104835,"ip_address":"","ucode":"6A5D44999A0FEA","user_header":"https://static001.geekbang.org/account/avatar/00/10/db/c3/e11adfe8.jpg","comment_is_top":false,"comment_ctime":1573125745,"is_pvip":false,"replies":[{"id":"57314","content":"一个非常简单的例子，有Person聚合根，Person仓储接口和仓储实现。<br>&#47;**<br> * Person聚合根<br> *&#47;<br>public class Person{<br>  private String id;<br>  private String name;<br>  private int age;   <br>  private boolean gender；<br>}<br><br>&#47;**<br> * Person仓储接口<br> *&#47;<br>public interface  PersonRepositoryInterface {<br>  void save(Person person);  <br>  void delete(String id);  <br> }<br><br>&#47;**<br> *Person仓储实现<br> *&#47;<br>@Repository<br>public class PersonRepositoryImp implements PersonRepositoryInterface {<br>  private PersonMapper mapper;    <br>  public void save( Person person) {<br>      mapper.create(person);<br>  }<br>  public void delete((String  id) {<br>    mapper.delete(id);<br>  }<br> }<br>在应用逻辑中直接用仓储的接口就可以了，数据库相关的逻辑在PersonMapper里面实现。<br>PersonRepositoryInterface personRepos;<br>personRepos.save(person)","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573133110,"ip_address":"","comment_id":149001,"utype":1}],"discussion_count":9,"race_medal":0,"score":"78882537073","product_id":100037301,"comment_content":"基础层依赖领域层。能录个例子吗？如何反转依赖的，还是不明白","like_count":19,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473704,"discussion_content":"一个非常简单的例子，有Person聚合根，Person仓储接口和仓储实现。\n/**\n * Person聚合根\n */\npublic class Person{\n  private String id;\n  private String name;\n  private int age;   \n  private boolean gender；\n}\n\n/**\n * Person仓储接口\n */\npublic interface  PersonRepositoryInterface {\n  void save(Person person);  \n  void delete(String id);  \n }\n\n/**\n *Person仓储实现\n */\n@Repository\npublic class PersonRepositoryImp implements PersonRepositoryInterface {\n  private PersonMapper mapper;    \n  public void save( Person person) {\n      mapper.create(person);\n  }\n  public void delete((String  id) {\n    mapper.delete(id);\n  }\n }\n在应用逻辑中直接用仓储的接口就可以了，数据库相关的逻辑在PersonMapper里面实现。\nPersonRepositoryInterface personRepos;\npersonRepos.save(person)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573133110,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1448748,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1b/2c/6b3c0911.jpg","nickname":"Hour","note":"","ucode":"AA1045ACABC0BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347378,"discussion_content":"老师的这个例子，跟我们平常使用的SSM方式没有什么区别啊，应用层使用的是仓储层的接口。这里一直强调依赖倒置，反而是增加了理解的难度。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1612225448,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1193337,"avatar":"https://static001.geekbang.org/account/avatar/00/12/35/79/21647da2.jpg","nickname":"Keith","note":"","ucode":"B40774090714D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1448748,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1b/2c/6b3c0911.jpg","nickname":"Hour","note":"","ucode":"AA1045ACABC0BB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366321,"discussion_content":"依赖倒置指的是高层依赖抽象而不应该依赖具体实现, 比如上例, PersonRepositoryInterface就是存储层的抽象, 如果不适用该抽象, 那上层的Person就得自己去跟存储服务打交道, 实现数据库连接等功能, 如果后续换个数据库, 那Person的逻辑就也得变了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618029467,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":347378,"ip_address":""},"score":366321,"extra":""},{"author":{"id":1054108,"avatar":"https://static001.geekbang.org/account/avatar/00/10/15/9c/310c902c.jpg","nickname":"e^x","note":"","ucode":"29B56E0DF4EF48","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1448748,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1b/2c/6b3c0911.jpg","nickname":"Hour","note":"","ucode":"AA1045ACABC0BB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385370,"discussion_content":"本质上都是“面向接口编程”，这里强调“依赖倒置”，确实是因为基础层在架构分层中的位置发生了变化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627019046,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":347378,"ip_address":""},"score":385370,"extra":""}]},{"author":{"id":1837166,"avatar":"http://thirdwx.qlogo.cn/mmopen/h0KAdRFKjCOSLRjzictvlaLqB3twKWhUZqyEhqCNF7JXCAgr0icKhOche8yNX21jSaxV33TGy4bAsaxp1dteDwdOkOPBicn8Xu6/132","nickname":"余伟华","note":"","ucode":"3E6A8D740BB23A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590996,"discussion_content":"依赖倒置在哪里呢？感觉就是个适配器模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666228583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"安徽"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1481811,"avatar":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","nickname":"ub8","note":"","ucode":"0D937C3EAEB781","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581822,"discussion_content":"依赖导致指的是指的高层依赖抽象，在领域层抽象xxxRepositoryInterface, 在基础层完成实现xxxRepositoryInterfaceImpl。不知道理解是否正确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659008006,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1044432,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ef/d0/7b8a28b3.jpg","nickname":"yb.chen","note":"","ucode":"2B7D04B69E760E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":101031,"discussion_content":"看到有的介绍， 仓储层在应用服务层获取和调用。 服务层作为 bean 可以被 spring 管理， 被注入仓储层实现。 而不是业务逻辑直接访问仓储层接口？ 这怎么选择？ 另外， 假如业务逻辑层直接操作存储接口， 那么具体实现如何注入？  会不会导致业务逻辑层和具体技术耦合， 比如： spring？ 丧失了只有业务逻辑的纯洁性？ ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577282817,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1108505,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ea/19/14018371.jpg","nickname":"瓜瓜","note":"","ucode":"F90A5135A9BB4B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50295,"discussion_content":"谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573700147,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1104835,"avatar":"https://static001.geekbang.org/account/avatar/00/10/db/c3/e11adfe8.jpg","nickname":"张迪","note":"","ucode":"6A5D44999A0FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46230,"discussion_content":"谢谢老师👍🏻👍🏻👍🏻👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573133399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172102,"user_name":"C J J","can_delete":false,"product_type":"c1","uid":1002287,"ip_address":"","ucode":"603AA1417BD0DE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4b/2f/186918b4.jpg","comment_is_top":false,"comment_ctime":1579089627,"is_pvip":false,"replies":[{"id":"66941","content":"感谢，写的很好。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1579242428,"ip_address":"","comment_id":172102,"utype":1}],"discussion_count":8,"race_medal":0,"score":"57413664475","product_id":100037301,"comment_content":"对失血，贫血，充血解释得很不错的文档。https:&#47;&#47;www.infoq.cn&#47;article&#47;alibaba-freshhema-ddd-practice","like_count":14,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481619,"discussion_content":"感谢，写的很好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579242428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1338617,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6c/f9/508e3659.jpg","nickname":"Katahashi","note":"","ucode":"03375A11603DD7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588676,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663985159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1390768,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/u68h6ZVpGpUmtzspuQZUPOJQTlLT9mxbicmAKlnPRVeB4Os1gL9LRBgZb4FpbRNicZMRktqMdGKZTfRdtm0Tjg1g/132","nickname":"Geek_9cf7b5","note":"","ucode":"4353D7E26DF2C5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582519,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659484914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1811607,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/iaByN5IfYbE9QHJC3NK2I3brItBEgIL5YyR113a0NpciazPngW6Yx539Le1us3xY8pX4MRvjT0dRV9JaibTB8PGYQ/132","nickname":"Geek_550e2b","note":"","ucode":"84CFE0B9E72062","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577213,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655972829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1042653,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e8/dd/76cfdf63.jpg","nickname":"cornor","note":"","ucode":"C005105013D771","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571884,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652446076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1472580,"avatar":"https://static001.geekbang.org/account/avatar/00/16/78/44/2b032be9.jpg","nickname":"Geek","note":"","ucode":"3E82B3689CAB16","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557200,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647694919,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2015455,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/c0/df/dd1fd72f.jpg","nickname":"Yuanzhi.Tang","note":"","ucode":"9153DFA94C8F44","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":412641,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636239109,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1190037,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/95/c57f5955.jpg","nickname":"FantasyZsp","note":"","ucode":"522878C4AEB690","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294651,"discussion_content":"mark\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595950132,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222224,"user_name":"Che Kwas","can_delete":false,"product_type":"c1","uid":1048095,"ip_address":"","ucode":"4CDF9CA041859C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fe/1f/6a3f2abb.jpg","comment_is_top":false,"comment_ctime":1590720017,"is_pvip":false,"replies":[{"id":"81951","content":"是的。依赖倒置的定义就是面向接口编程，这样不同层之间的服务在实现逻辑发生变化的时候，就不会相互影响了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1590740520,"ip_address":"","comment_id":222224,"utype":1}],"discussion_count":3,"race_medal":0,"score":"44540392977","product_id":100037301,"comment_content":"“依赖倒置”不看定义我还一直因为是基础层依赖领域层。看了定义才知道，原来是基础层和领域层互相不依赖，而是共同依赖一组抽象接口。我觉得“面向接口编程”听起来更舒服。","like_count":11,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496720,"discussion_content":"是的。依赖倒置的定义就是面向接口编程，这样不同层之间的服务在实现逻辑发生变化的时候，就不会相互影响了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590740520,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1071921,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5b/31/b26b56bf.jpg","nickname":"Lever","note":"","ucode":"20C0D381677E1D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540856,"discussion_content":"基础层确实会依赖领域层吧？因为仓储提供的部分输入或者输出会是实体","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1640184416,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1448748,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1b/2c/6b3c0911.jpg","nickname":"Hour","note":"","ucode":"AA1045ACABC0BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347380,"discussion_content":"嗯，面向接口编程更容易理解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612225530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148549,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1573029322,"is_pvip":true,"replies":[{"id":"57191","content":"一般通过聚合根来做。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573034457,"ip_address":"","comment_id":148549,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31637800394","product_id":100037301,"comment_content":"老师，实体内可以调用他所在聚合的仓储吗？","like_count":8,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473529,"discussion_content":"一般通过聚合根来做。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573034457,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148987,"user_name":"Paul","can_delete":false,"product_type":"c1","uid":1022136,"ip_address":"","ucode":"4F0AA3B0BDDD68","user_header":"https://static001.geekbang.org/account/avatar/00/0f/98/b8/e4f01f2c.jpg","comment_is_top":false,"comment_ctime":1573122151,"is_pvip":false,"replies":[{"id":"57307","content":"其实查询类业务可以不必经过聚合根和仓储。传统方法也可以了。<br>如果聚合数据比较多，会有延迟加载影响性能。<br>聚合根的主要目的是为了保证数据的一致性，这些场景一般在CU的场景。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573123235,"ip_address":"","comment_id":148987,"utype":1}],"discussion_count":2,"race_medal":0,"score":"27342925927","product_id":100037301,"comment_content":"老师，您好！有一些设计实现上的疑问：<br>领域服务的CRUD是不是都是操作聚合根或整个实体对象，比如我只想根据ID判断记录是否存在，或者返回个别字段，需要返回整个实体对象吗？","like_count":7,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473697,"discussion_content":"其实查询类业务可以不必经过聚合根和仓储。传统方法也可以了。\n如果聚合数据比较多，会有延迟加载影响性能。\n聚合根的主要目的是为了保证数据的一致性，这些场景一般在CU的场景。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1573123235,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1472580,"avatar":"https://static001.geekbang.org/account/avatar/00/16/78/44/2b032be9.jpg","nickname":"Geek","note":"","ucode":"3E82B3689CAB16","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557201,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647694960,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203427,"user_name":"骆驼1089","can_delete":false,"product_type":"c1","uid":1046421,"ip_address":"","ucode":"6E2EA2955BF204","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/95/42e16e49.jpg","comment_is_top":false,"comment_ctime":1586188060,"is_pvip":false,"replies":[{"id":"76061","content":"先只从领域建模的角度来说优势吧。因为DDD是一种面向对象的编程方式，采用充血模型，每个实体就会有自己的业务行为，在领域模型设计时，每一个实体除了自己的属性外，还会有自己的业务行为，而不会将所有的业务逻辑放到业务逻辑层。这样就有利于实体、聚合的解耦。当你需要进行再次拆分的时候，就会很容易。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1586223756,"ip_address":"","comment_id":203427,"utype":1}],"discussion_count":3,"race_medal":0,"score":"23061024540","product_id":100037301,"comment_content":"老师，有个问题请教一下，充血模式的优势是什么，比现有的贫血模式的优势是什么？","like_count":6,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490859,"discussion_content":"先只从领域建模的角度来说优势吧。因为DDD是一种面向对象的编程方式，采用充血模型，每个实体就会有自己的业务行为，在领域模型设计时，每一个实体除了自己的属性外，还会有自己的业务行为，而不会将所有的业务逻辑放到业务逻辑层。这样就有利于实体、聚合的解耦。当你需要进行再次拆分的时候，就会很容易。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586223756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2571052,"avatar":"https://static001.geekbang.org/account/avatar/00/27/3b/2c/c82d7989.jpg","nickname":"夸虾滑专家","note":"","ucode":"33328A4B1D3D57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389213,"discussion_content":"做了几年的开发下来，一直在接收 充血模式更好  的概念，然而事实是，目前的开发大部分都是用贫血模式来做。。只有重构才会重新设计成充血","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629180838,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1046421,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f7/95/42e16e49.jpg","nickname":"骆驼1089","note":"","ucode":"6E2EA2955BF204","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":223441,"discussion_content":"谢谢老师的指导","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586224263,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148371,"user_name":"Jade","can_delete":false,"product_type":"c1","uid":1085638,"ip_address":"","ucode":"E07CCF10497AD3","user_header":"https://wx.qlogo.cn/mmopen/vi_32/icRpVCFkicVnBiatPIZy4uiaoiba8ZODxclF00R6Tphsn55kdMtBYJtialcokIu3f4qJzx7QQR98ibVH4ndZ48E2o9vRQ/132","comment_is_top":false,"comment_ctime":1572999713,"is_pvip":false,"replies":[{"id":"57125","content":"事件总线就是一个带发布和监听功能的jar包，直接跟你的微服务代码放一起就行了，它属于基础层的代码。提的比较多的是EventBus。你可以去网上找找资料。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573006774,"ip_address":"","comment_id":148371,"utype":1}],"discussion_count":6,"race_medal":0,"score":"18752868897","product_id":100037301,"comment_content":"事件总线 实现思路？用到什么技术或来源组件？还是说事件总线就是消息队列呢","like_count":4,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473473,"discussion_content":"事件总线就是一个带发布和监听功能的jar包，直接跟你的微服务代码放一起就行了，它属于基础层的代码。提的比较多的是EventBus。你可以去网上找找资料。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573006774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2043294,"avatar":"","nickname":"0084","note":"","ucode":"EC5085EEEB1E12","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327910,"discussion_content":"可以理解成单进程内的消息发布和订阅（一个Jar包），为了解决业务的耦合问题，再把问题放大一点就是跨进程之间的发布订阅（一般用MQ解决 ）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606016050,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1601037,"avatar":"https://static001.geekbang.org/account/avatar/00/18/6e/0d/f34b25f5.jpg","nickname":"小雨点儿上的小雨点儿","note":"","ucode":"8E42CA17B55841","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":313140,"discussion_content":"事件总线本身就是类似订阅发布的中间件，消息队列是其中一种","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602953675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1031559,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/bd/87/64dd6e98.jpg","nickname":"狒狒","note":"","ucode":"98D054437C5FB6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49940,"discussion_content":"不就是消息中间件吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573652258,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":45165,"discussion_content":"不是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573008511,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1108505,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ea/19/14018371.jpg","nickname":"瓜瓜","note":"","ucode":"F90A5135A9BB4B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":45142,"discussion_content":"是jms之类的吗？？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573006371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148361,"user_name":"密码123456","can_delete":false,"product_type":"c1","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1572998633,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14457900521","product_id":100037301,"comment_content":"感觉有点像，设计模式中核心的一句话。封装变化。变化是无穷的，但是我们尽可能的把，变化引起的改动降到最小。","like_count":4},{"had_liked":false,"id":148341,"user_name":"祥敏","can_delete":false,"product_type":"c1","uid":1205328,"ip_address":"","ucode":"466BFA980D9A37","user_header":"https://static001.geekbang.org/account/avatar/00/12/64/50/a54f0907.jpg","comment_is_top":false,"comment_ctime":1572992999,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"14457894887","product_id":100037301,"comment_content":"您好，领域层提供仓储接口，基础层实现仓储接口，依赖倒置的设计是非常好的，能够拆除领域层对基础层的依赖。<br>上层向下依赖领域层，领域层通过依赖倒置，让基础层也依赖领域层，这样就实现了领域层为核心的设计理念。<br>领域驱动设计提出了全新的设计思路，讲述偏抽象，重点在如何落地，期待实战篇。","like_count":3,"discussions":[{"author":{"id":1108505,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ea/19/14018371.jpg","nickname":"瓜瓜","note":"","ucode":"F90A5135A9BB4B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":45143,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573006465,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1112367,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f9/2f/01b32495.jpg","nickname":"小孩","note":"","ucode":"A7F587FC641E63","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":45084,"discussion_content":"之前提过这个问题，基础依赖领域的仓储接口，领域不还得依赖基础层的通用组件吗？这不循环依赖了吗。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573003173,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1205328,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/50/a54f0907.jpg","nickname":"祥敏","note":"","ucode":"466BFA980D9A37","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1112367,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f9/2f/01b32495.jpg","nickname":"小孩","note":"","ucode":"A7F587FC641E63","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":45460,"discussion_content":"能用具体实例说明吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573040731,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":45084,"ip_address":""},"score":45460,"extra":""}]}]},{"had_liked":false,"id":153734,"user_name":"夙梦流尘","can_delete":false,"product_type":"c1","uid":1477260,"ip_address":"","ucode":"D7E84D3B588BD6","user_header":"https://static001.geekbang.org/account/avatar/00/16/8a/8c/07dd8832.jpg","comment_is_top":false,"comment_ctime":1574301115,"is_pvip":false,"replies":[{"id":"59119","content":"A的主键是由数据库的序列号生成的吗？<br>如果是这样，在A的方法里面增加一个生成主键的方法呢。这样就可以在形成PO前，拿到所有实体的数据了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574315807,"ip_address":"","comment_id":153734,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5869268411","product_id":100037301,"comment_content":"有个问题想请教下。现在A聚合里面有B、C实体，是通过A的主键去关联的（我知道这样不好但是目前老项目就是这么搞的，重新定义实体标识风险有点大）。导致现在我用工厂创建A聚合的话，要先把A的数据落地，才能拿到A的主键，然后才能创建A聚合里的BC实体。这样的话只能 1.在工厂里就把A落地，然后填充BC实体返回完整聚合。2. 工厂只返回A聚合，然后在填充BC实体。这样工厂就没返回一个完整聚合。<br>这两种我觉得都不好，麻烦指导下","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475252,"discussion_content":"A的主键是由数据库的序列号生成的吗？\n如果是这样，在A的方法里面增加一个生成主键的方法呢。这样就可以在形成PO前，拿到所有实体的数据了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574315807,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188023,"avatar":"https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg","nickname":"Eternal","note":"","ucode":"EA6FE7CC98F740","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327913,"discussion_content":"在A的方法里面增加一个生成主键的方法m（）是指先保存A实体后，然后通过m()方法获取聚合根A的ID，然后再创建BC实体吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606016442,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":149048,"user_name":"瓜瓜","can_delete":false,"product_type":"c1","uid":1108505,"ip_address":"","ucode":"F90A5135A9BB4B","user_header":"https://static001.geekbang.org/account/avatar/00/10/ea/19/14018371.jpg","comment_is_top":false,"comment_ctime":1573130994,"is_pvip":false,"replies":[{"id":"57317","content":"你这种方式可能就不适合充血模型了。<br>DDD用充血模型的主要目的是为了在领域模型中体现实体的业务行为，而不是所有实体的行为混杂在一起。但是这只是一个建议的设计原则，贫血模型有时候也是不可避免的。<br><br>","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573134360,"ip_address":"","comment_id":149048,"utype":1}],"discussion_count":5,"race_medal":0,"score":"5868098290","product_id":100037301,"comment_content":"使用充血模型，比如RPC的接口包，接口包的实体为充血模型，该实体的很多功能需要引用很多第三方jar包，这样会不会导致接口包很沉重，比如说一个图片上传服务，客户端和服务端交互是通过图片实体来进行交互的，而图片的下载和上传是属于图片实体的内部功能，这样图片实体就会引用apahce.httpclient的很多jar包，该怎样解决这个问题呢","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473719,"discussion_content":"你这种方式可能就不适合充血模型了。\nDDD用充血模型的主要目的是为了在领域模型中体现实体的业务行为，而不是所有实体的行为混杂在一起。但是这只是一个建议的设计原则，贫血模型有时候也是不可避免的。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573134360,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1034451,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c8/d3/3020ae46.jpg","nickname":"fatme","note":"","ucode":"75A805D2BB2AD1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":81885,"discussion_content":"1. 感觉图片的上传下载，不算业务逻辑，更多属于通用域或支撑域，所以可以不放在图片实体。这是从设计上解藕。\n2. 另一种思路正如上面的朋友所说的，图片实体只依赖上传下载服务接口。服务的具体实现通过依赖注入，让图片实体使用。图片实体并不知道服务实现是访问数据库，还是访问 web。这也是老师所说的依赖倒置。这种方式，是从实现上解藕。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576291569,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1034451,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c8/d3/3020ae46.jpg","nickname":"fatme","note":"","ucode":"75A805D2BB2AD1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":81884,"discussion_content":"1. 感觉图片的上传下载，不算业务逻辑，更多属于通用域或支撑域，所以可以不放在图片实体。这是从设计上解藕。\n2. 另一种思路正如上面的朋友所说的，图片实体只依赖上传下载服务接口。服务的具体实现通过依赖注入，让图片实体使用。图片实体并不知道服务实现是访问数据库，还是访问 web。这也是老师所说的依赖倒置。这种方式，是从实现上解藕。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576291568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1108505,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ea/19/14018371.jpg","nickname":"瓜瓜","note":"","ucode":"F90A5135A9BB4B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1034451,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c8/d3/3020ae46.jpg","nickname":"fatme","note":"","ucode":"75A805D2BB2AD1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":81941,"discussion_content":"设计成通用域，并通过依赖反转提供接口实现，确实是更好的思路，感谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576298924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":81884,"ip_address":""},"score":81941,"extra":""}]},{"author":{"id":1690242,"avatar":"https://static001.geekbang.org/account/avatar/00/19/ca/82/85f6a1a2.jpg","nickname":"番茄炒西红柿","note":"","ucode":"13F47BABAB2110","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":67315,"discussion_content":"可以采用接口+组合+委托方式。图片传输功能建立个委托接口，图片类中要传图片的时候调用接口。而接口实现类注入可以在service（要用di去反转控制）。想了一想大概逻辑可以这样（实际上就是装饰者模式），不过具体看情况。业务不复杂的情况下直接用贫血模型来写就好了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575126972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148999,"user_name":"张迪","can_delete":false,"product_type":"c1","uid":1104835,"ip_address":"","ucode":"6A5D44999A0FEA","user_header":"https://static001.geekbang.org/account/avatar/00/10/db/c3/e11adfe8.jpg","comment_is_top":false,"comment_ctime":1573125645,"is_pvip":false,"replies":[{"id":"57310","content":"这个需要权衡，看看引入事件总线后，这个复杂度可不可以接受。通过应用服务加事务机制应该也可以解决，在同一个进程内的事务应该比跨微服务的事务相对来说还是好控制，对性能影响也会小一些吧。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573128162,"ip_address":"","comment_id":148999,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5868092941","product_id":100037301,"comment_content":"微服务内不使用事件总线，如何保证两个聚合操作的一致性？","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473703,"discussion_content":"这个需要权衡，看看引入事件总线后，这个复杂度可不可以接受。通过应用服务加事务机制应该也可以解决，在同一个进程内的事务应该比跨微服务的事务相对来说还是好控制，对性能影响也会小一些吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573128162,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":301812,"user_name":"Geek8815","can_delete":false,"product_type":"c1","uid":2028944,"ip_address":"","ucode":"D5102AFFA20E7E","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f5/90/2caa07d0.jpg","comment_is_top":false,"comment_ctime":1625894437,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625894437","product_id":100037301,"comment_content":"欧老师，倒数第三段的这句话”不会出现导致聚合之间数据不一致的情况，就可以不使用事件总线“能不能再解释下，我理解是“不会出现导致聚合之间数据不一致的情况，就可以使用事件总线“","like_count":0},{"had_liked":false,"id":237933,"user_name":"Hans","can_delete":false,"product_type":"c1","uid":1220004,"ip_address":"","ucode":"D4C7AF198238A1","user_header":"https://static001.geekbang.org/account/avatar/00/12/9d/a4/c8d7ce59.jpg","comment_is_top":false,"comment_ctime":1596009011,"is_pvip":false,"replies":[{"id":"88564","content":"不好意思啊，没明白您问的问题。<br>你是不是想说聚合之间通过聚合根ID来访问得返回对象。聚合之间的访问一般放在应用层，在应用服务中它们通过聚合根ID来访问，返回的值可以是一组属性组合出来的临时对象，也可以是聚合根或实体等DO对象。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1596674389,"ip_address":"","comment_id":237933,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1596009011","product_id":100037301,"comment_content":"聚合之间如果存在聚合根吗，如果业务交互只需要属性值，是否可以直接返回属性值。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502592,"discussion_content":"不好意思啊，没明白您问的问题。\n你是不是想说聚合之间通过聚合根ID来访问得返回对象。聚合之间的访问一般放在应用层，在应用服务中它们通过聚合根ID来访问，返回的值可以是一组属性组合出来的临时对象，也可以是聚合根或实体等DO对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596674389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":232566,"user_name":"","can_delete":false,"product_type":"c1","uid":1924055,"ip_address":"","ucode":"","user_header":"","comment_is_top":false,"comment_ctime":1594038599,"is_pvip":false,"replies":[{"id":"85895","content":"按照DDD的设计方法，在聚合和限界上下文之间已经做好了对象、服务和数据的解耦工作，所以基本不会出现多个微服务共用一个库的情况。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1594089286,"ip_address":"","comment_id":232566,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1594038599","product_id":100037301,"comment_content":"微服务能不能共用一个业务数据库。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500692,"discussion_content":"按照DDD的设计方法，在聚合和限界上下文之间已经做好了对象、服务和数据的解耦工作，所以基本不会出现多个微服务共用一个库的情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594089286,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223835,"user_name":"Tumayun","can_delete":false,"product_type":"c1","uid":1026661,"ip_address":"","ucode":"ADCD2715979364","user_header":"https://static001.geekbang.org/account/avatar/00/0f/aa/65/4cf4470f.jpg","comment_is_top":false,"comment_ctime":1591193375,"is_pvip":false,"replies":[{"id":"82444","content":"后面案例里面会有详细介绍。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1591241266,"ip_address":"","comment_id":223835,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591193375","product_id":100037301,"comment_content":"太过抽象了，可以多举例，举一些大家都容易理解的实例","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497256,"discussion_content":"后面案例里面会有详细介绍。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591241266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220729,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1590314899,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1590314899","product_id":100037301,"comment_content":"领域就是一个组织为了达到某个业务目的，而做的一系列业务活动的集合。<br>划分子域则是为了能够从组织架构上以及软件设计上能够更加的内骤与解耦。方便进行维护。<br>而子域中更细分的单位是聚合，一个聚合代表了若干能够协同工作的实体集合，一个聚合所做的事情是比较聚焦的。<br>在领域驱动设计中，对于一个未知领域往往是采用从下到上的设计方法，即先根据用例，场景分析得出实体，值对象然后划分聚合以及子域，再组合子域成为一个域。","like_count":0},{"had_liked":false,"id":195452,"user_name":"秋雨","can_delete":false,"product_type":"c1","uid":1111398,"ip_address":"","ucode":"2F7333B3E3602D","user_header":"","comment_is_top":false,"comment_ctime":1585188959,"is_pvip":false,"replies":[{"id":"74276","content":"领域太大的话，建议先划分子域。这是因为领域太大，不好开展事件风暴。在将领域划分成合适大小的子域后，进行事件风暴完成领域建模就比较容易了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1585193683,"ip_address":"","comment_id":195452,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1585188959","product_id":100037301,"comment_content":"老师你好，我有一个问题想问下：<br>现有事件风暴再有领域模型还是先划分好领域，再通过事件风暴建立领域模型？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489073,"discussion_content":"领域太大的话，建议先划分子域。这是因为领域太大，不好开展事件风暴。在将领域划分成合适大小的子域后，进行事件风暴完成领域建模就比较容易了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585193683,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111398,"avatar":"","nickname":"秋雨","note":"","ucode":"2F7333B3E3602D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214702,"discussion_content":"这是自上而下还是自下而上的问题。谢谢老师。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585227558,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188892,"user_name":"狮锅艺","can_delete":false,"product_type":"c1","uid":1187577,"ip_address":"","ucode":"1B4AD130F9D0CA","user_header":"https://static001.geekbang.org/account/avatar/00/12/1e/f9/bfb54326.jpg","comment_is_top":false,"comment_ctime":1584431265,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584431265","product_id":100037301,"comment_content":"学习打卡","like_count":0},{"had_liked":false,"id":178332,"user_name":"小谢同学","can_delete":false,"product_type":"c1","uid":1032544,"ip_address":"","ucode":"E809E6BC470631","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c1/60/fc3689d0.jpg","comment_is_top":false,"comment_ctime":1581662267,"is_pvip":false,"replies":[{"id":"69236","content":"是的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1581730582,"ip_address":"","comment_id":178332,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1581662267","product_id":100037301,"comment_content":"子域划分的过程更偏业务侧工作，然后基于每个子域进行事件风暴（讨论）的时候，就是在梳理领域对象的过程，且发掘领域对象之后就可以分清楚哪些是值对象，哪些是实体哪些是聚合根？是这样理解吗","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483760,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581730582,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163110,"user_name":"堵车","can_delete":false,"product_type":"c1","uid":1145404,"ip_address":"","ucode":"7BC1E50A4F8D3D","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/3c/87e015f8.jpg","comment_is_top":false,"comment_ctime":1576658144,"is_pvip":false,"replies":[{"id":"61980","content":"建议先把专栏看完，然后再刷几遍。结合项目实践后，再回过来刷几遍。DDD是一个比较复杂的体系，需要理解和回味。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1576672830,"ip_address":"","comment_id":163110,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1576658144","product_id":100037301,"comment_content":"基础篇草草看了一遍，有挺多词汇无法理解，需要重新看一遍，还是继续看实战篇，然后再二刷？对于事件总线这个东西不太理解。不知道大家是怎么阅读这个专栏的","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478247,"discussion_content":"建议先把专栏看完，然后再刷几遍。结合项目实践后，再回过来刷几遍。DDD是一个比较复杂的体系，需要理解和回味。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576672830,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188023,"avatar":"https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg","nickname":"Eternal","note":"","ucode":"EA6FE7CC98F740","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327917,"discussion_content":"我现在在刷第三遍，需要几遍才能不会因为概念和定义理解的不准确而迷惑？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606016891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156378,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1574863728,"is_pvip":false,"replies":[{"id":"60119","content":"工厂模式一般用于比较复杂的聚合的数据初始化。仓储一般是PO和DO之间的转换。<br>DTO和DO之间一般都是应用层与外部，比如前端或者其它微服务之间的转换，转换过程一般不会太复杂，直接转换就可以了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574924627,"ip_address":"","comment_id":156378,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1574863728","product_id":100037301,"comment_content":"提个问题，接口层是DTO，应用层是DO，那在接口层将DTO将DTO转换成DO是否会用到工厂模式来转换实体，工厂依赖仓储查询实体依赖数据。因为有些时候DTO要想转换成DO可能需要通过仓储来查询依赖属性的吧？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476086,"discussion_content":"工厂模式一般用于比较复杂的聚合的数据初始化。仓储一般是PO和DO之间的转换。\nDTO和DO之间一般都是应用层与外部，比如前端或者其它微服务之间的转换，转换过程一般不会太复杂，直接转换就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574924627,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188023,"avatar":"https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg","nickname":"Eternal","note":"","ucode":"EA6FE7CC98F740","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327918,"discussion_content":"将应用层的DO转换成DTO给外部\n将仓储的PO转换成DO给应用层\nBO 和VO在DDD设计里是不是没用？\n不知理解对不对？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606017151,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1100064,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","nickname":"zj","note":"","ucode":"E3329CCF694AC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":64023,"discussion_content":"老师说的是一般情况是这样的。但是难免会有这种复杂的情况存在吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574930851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153890,"user_name":"观弈道人","can_delete":false,"product_type":"c1","uid":1016905,"ip_address":"","ucode":"F3BB619A33C605","user_header":"https://static001.geekbang.org/account/avatar/00/0f/84/49/47d48fd0.jpg","comment_is_top":false,"comment_ctime":1574326299,"is_pvip":false,"replies":[{"id":"59181","content":"事件风暴是领域建模的手段，头脑风暴是事件风暴中梳理业务场景和旅程的一种交流方式。详细信息你可以了解一下实战篇的第12节。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574391654,"ip_address":"","comment_id":153890,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1574326299","product_id":100037301,"comment_content":"事件风暴与头脑风暴究竟啥区别？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475310,"discussion_content":"事件风暴是领域建模的手段，头脑风暴是事件风暴中梳理业务场景和旅程的一种交流方式。详细信息你可以了解一下实战篇的第12节。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574391654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188023,"avatar":"https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg","nickname":"Eternal","note":"","ucode":"EA6FE7CC98F740","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327921,"discussion_content":"头脑风暴我理解就是业务的穷举，天花乱坠的想，然后慢慢排除一些不合理的，不需要的\n\n然后按照事件风暴：分析业务用力、业务场景、用户旅程，通俗的说就是把头脑风暴排除掉不用的业务后剩下的业务拿来排列组合成几条经典的流程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606017364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2246686,"avatar":"https://static001.geekbang.org/account/avatar/00/22/48/1e/883fd1d5.jpg","nickname":"Jacob Chen","note":"","ucode":"329B92B53F12B8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320498,"discussion_content":"什么是事件风暴？？？？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604383604,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150075,"user_name":"宝宝太喜欢极客时间了","can_delete":false,"product_type":"c1","uid":1215152,"ip_address":"","ucode":"9CDB679C257612","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoOGZ6lbHiboIZMN9USbeutnmCWBahVLtSlKlIENKvrZQCUQzpzeZQOxTntIkBUeDk6qZUPdqmfKrQ/132","comment_is_top":false,"comment_ctime":1573458924,"is_pvip":false,"replies":[{"id":"57756","content":"仓储只是一种应用和数据库解耦的手段，它是一种手段和方法，传统架构也是可以用的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573463381,"ip_address":"","comment_id":150075,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1573458924","product_id":100037301,"comment_content":"仓储层跟传统的dao层感觉没啥区别？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474057,"discussion_content":"仓储只是一种应用和数据库解耦的手段，它是一种手段和方法，传统架构也是可以用的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573463381,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1670730,"avatar":"","nickname":"Geek_0a4616","note":"","ucode":"9C37ED61ECCAC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380235,"discussion_content":"仓储针对聚合根，一个聚合根一个仓储的整体操作，仓储出现后领域层不会感知到 dao.insert update这些数据库语义的操作，和数据库彻底解耦合。这样领域层不会被数据库固化。 举例 比如要增加缓存 ，dao方式可能要修改 增加删除更新的方法来维护缓存，而仓储因为没有被数据库的操作固化其实只要修改仓储接口就行了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624406110,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148550,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1573029489,"is_pvip":true,"replies":[{"id":"57190","content":"创建完后会初始化数据，变更后的数据会通过仓储持久化。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573034431,"ip_address":"","comment_id":148550,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573029489","product_id":100037301,"comment_content":"工厂创建出实体或者是聚合跟之后再加到仓储中吗(持久化)？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473530,"discussion_content":"创建完后会初始化数据，变更后的数据会通过仓储持久化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573034431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148401,"user_name":"小孩","can_delete":false,"product_type":"c1","uid":1112367,"ip_address":"","ucode":"A7F587FC641E63","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/2f/01b32495.jpg","comment_is_top":false,"comment_ctime":1573003310,"is_pvip":false,"replies":[{"id":"57167","content":"用仓储的目的是为了隔离相互影响。<br>你说的这种情况我理解是从哪里调仓储接口的问题吧，比如一个基础层组件A依赖领域层，另一个基础层组件B，依赖基础层组件A，然后B只能从领域层仓储接口调A的接口，不知道理解的对不对哈？<br>其实在微服务内只要你能够做好代码逻辑隔离，仓储接口放哪里都无所谓。<br>这样设计只是考虑大部分的情况，为了让代码更清晰一些，毕竟大部分的数据仓储的服务都是从领域层发起的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573018630,"ip_address":"","comment_id":148401,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573003310","product_id":100037301,"comment_content":"之前提过这个问题，基础依赖领域的仓储接口，领域不还得依赖基础层的通用组件吗？这不循环依赖了吗。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473482,"discussion_content":"用仓储的目的是为了隔离相互影响。\n你说的这种情况我理解是从哪里调仓储接口的问题吧，比如一个基础层组件A依赖领域层，另一个基础层组件B，依赖基础层组件A，然后B只能从领域层仓储接口调A的接口，不知道理解的对不对哈？\n其实在微服务内只要你能够做好代码逻辑隔离，仓储接口放哪里都无所谓。\n这样设计只是考虑大部分的情况，为了让代码更清晰一些，毕竟大部分的数据仓储的服务都是从领域层发起的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573018630,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148389,"user_name":"FIGNT","can_delete":false,"product_type":"c1","uid":1540988,"ip_address":"","ucode":"D9DB185AE9E67C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKZ16iaIia0029oI1Qh5NicibpbTiaBAaCOPYXoLplKHr6uQ2rSVxPZanBvpMcL2NuhwKQYCFnaHP5tedQ/132","comment_is_top":false,"comment_ctime":1573001355,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1573001355","product_id":100037301,"comment_content":"讲的很精简，把《实现领域驱动设计》的主要内容讲的很清楚了。但是还是很抽象的，关键还是要实战，加深理解","like_count":0,"discussions":[{"author":{"id":2246686,"avatar":"https://static001.geekbang.org/account/avatar/00/22/48/1e/883fd1d5.jpg","nickname":"Jacob Chen","note":"","ucode":"329B92B53F12B8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320499,"discussion_content":"太抽象了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604383623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}