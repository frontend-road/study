{"id":740820,"title":"第 17 章 字符串与文本(1)","content":"<blockquote>\n<p>字符串是一个光秃秃的数据结构，其途经之地会出现很多重复的处理。它简直是隐藏重要信息的“完美”手段。</p>\n<p style=\"text-align: right\">——Alan Perlis，警句 #34</p>\n</blockquote>\n<p>&nbsp;</p>\n<p>本书一直在使用 Rust 的主要文本类型 <code>String</code>、<code>str</code> 和 <code>char</code>。3.7 节曾讲解过字符和字符串字面量的语法，也展示过字符串在内存中的表示方式。在本章中，我们将更详细地介绍文本处理技术。</p>\n<p>本章包括如下内容。</p>\n<ul>\n<li>提供一些 Unicode 背景知识来帮助你理解标准库的设计。</li>\n<li>讲解表示单个 Unicode 码点的 <code>char</code> 类型。</li>\n<li>讲解 <code>String</code> 类型和 <code>str</code> 类型，二者是表示拥有和借用的 Unicode 字符序列。它们有各种各样的方法来构建、搜索、修改和迭代其内容。</li>\n<li>介绍 Rust 的字符串格式化工具，比如 <code>println!</code> 宏和 <code>format!</code> 宏。你可以编写自己的宏来处理格式化字符串，并扩展它们以支持自己的类型。</li>\n<li>概述 Rust 对正则表达式的支持。</li>\n<li>讨论为什么 Unicode 的规范化很重要，并展示如何在 Rust 中对其进行规范化。</li>\n</ul>\n<h2 id=\"nav_point_306\">17.1　一些 Unicode 背景知识</h2>\n<p>本书是关于 Rust 而不是 Unicode 的，后者已经有专门的书介绍它了。但是，Rust 的字符类型和字符串类型都是围绕 Unicode 设计的。此处介绍一些 Unicode 的背景知识有助于更好地理解 Rust。</p>\n<h3 id=\"nav_point_307\">17.1.1　ASCII、Latin-1 和 Unicode</h3>\n<p>Unicode 和 ASCII 对于从 <code>0</code> 到 <code>0x7f</code> 的所有 ASCII 码点是一一对应的，比如，它们都为字符 <code>*</code> 分配了码点 <code>42</code>。同样，Unicode 也将 <code>0</code> 到 <code>0xff</code> 分配给了与 ISO/IEC 8859-1 字符集相同的字符，这是 ASCII 字符集用于西欧语言的 8 位超集。Unicode 将此码点范围称为 <strong>Latin-1 码块</strong>，因此我们也将使用耳熟能详的名称 <strong>Latin-1</strong> 来指代 ISO/IEC 8859-1。</p>\n<p>由于 Unicode 是 Latin-1 的超集，因此将 Latin-1 转换为 Unicode 甚至不需要查表：</p><!-- [[[read_end]]] -->\n<pre class=\"code-rows\"><code>fn latin1_to_char(latin1: u8) -&gt; char {\n    latin1 as char\n}</code></pre>\n<p>反向转换也很简单，假设码点落在了 Latin-1 范围内。</p>\n<pre class=\"code-rows\"><code>fn char_to_latin1(c: char) -&gt; Option&lt;u8&gt; {\n    if c as u32 &lt;= 0xff {\n        Some(c as u8)\n    } else {\n        None\n    }\n}</code></pre>\n<h3 id=\"nav_point_308\">17.1.2　UTF-8 编码</h3>\n<p>Rust 的 <code>String</code> 类型和 <code>str</code> 类型表示使用了 UTF-8 编码形式的文本。UTF-8 会将字符编码为 1~4 字节的序列，如图 17-1 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00869.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 17-1：UTF-8 编码</strong></p>\n<p>格式良好的 UTF-8 序列有两个限制。首先，只有任何给定码点的最短编码才被认为是格式良好的，你不能花费 4 字节来编码原本只需要 3 字节的码点。此规则确保了每个码点只会有唯一一个 UTF-8 编码。其次，格式良好的 UTF-8 不得对从 <code>0xd800</code> 到 <code>0xdfff</code> 或超过 <code>0x10ffff</code> 的数值进行编码：这些数值要么保留用作非字符目的，要么完全超出了 Unicode 的范围。</p>\n<p>图 17-2 展示了一些示例。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00870.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 17-2：UTF-8 示例</strong></p>\n<p>请注意，虽然在螃蟹表情符号的编码中其前导字节对码点只贡献了一串 0，但是它仍然需要用 4 字节来编码：3 字节的 UTF-8 编码只能表达 16 位码点，而 <code>0x1f980</code> 有 17 位长。</p>\n<p>下面是一个包含具有不同编码长度字符的字符串的简单示例：</p>\n<pre class=\"code-rows\"><code>assert_eq!(\"うどん: udon\".as_bytes(),\n           &amp;[0xe3, 0x81, 0x86, // う\n             0xe3, 0x81, 0xa9, // ど\n             0xe3, 0x82, 0x93, // ん\n             0x3a, 0x20, 0x75, 0x64, 0x6f, 0x6e // : udon\n           ]);</code></pre>\n<p>图 17-2 还展示了 UTF-8 一些非常有用的属性。</p>\n<ul>\n<li><p>由于 UTF-8 会把码点 <code>0</code> ~ <code>0x7f</code> 编码为字节 <code>0</code> ~ <code>0x7f</code>，因此一段 ASCII 文本必然是有效的 UTF-8 字符串。反过来，如果 UTF-8 字符串中只包含 ASCII 字符，则它也必然是有效的 ASCII 字符串。</p>\n<p>对于 Latin-1 则不是这样的，比如，Latin-1 会将 <code>é</code> 编码为字节 <code>0xe9</code>，而 UTF-8 会将其解释为三字节编码中的第一字节。</p>\n<p>&nbsp;</p>\n</li>\n<li><p>通过查看任何字节的高位，就能立刻判断出它是某个字符的 UTF-8 编码的起始字节还是中间字节。</p>\n</li>\n<li>编码的第一字节会单独通过其前导位告诉你编码的全长。</li>\n<li>由于不会有任何编码超过 4 字节，因此 UTF-8 在处理时从不需要无限循环，这在处理不受信任的数据时非常有用。</li>\n<li>在格式良好的 UTF-8 中，即使从字节中间的任意点开始，你也始终可以明确地找出该字符编码的起始位置和结束位置。UTF-8 的第一字节和后面的字节一定不同，所以一段编码不可能从另一段编码的中间开始。第一字节会确定编码的总长度，因此任何一段编码都不可能是另一段编码的前缀。这很有用。例如，要在 UTF-8 字符串中搜索 ASCII 分隔符只需对分隔符的字节进行简单扫描即可。这个分隔符永远不会作为多字节编码的任何部分出现，因此根本不需要跟踪 UTF-8 的结构。类似地，在一个字节串中搜索另一个字节串的算法无须针对 UTF-8 字符串做修改即可正常工作，甚至连那些根本不会检查待搜文本中每字节的算法也没问题。</li>\n</ul>\n<p>尽管可变宽度编码比固定宽度编码更复杂，但以上特征让 UTF-8 比预想的更容易使用。标准库会帮你处理绝大部分问题。</p>\n<h3 id=\"nav_point_309\">17.1.3　文本方向性</h3>\n<p>拉丁文、西里尔文、泰文等文字是从左向右书写的，而希伯来文、阿拉伯文等文字则是从右向左书写的。Unicode 以写入或读取字符的常规顺序存储字符，因此在这种情况下字符串（如希伯来语文本）中保存的首字节是对写在最右端的字符的编码。</p>\n<pre class=\"code-rows\"><code>assert_eq!(\"ערב טוב\".chars().next(), Some('ע'));</code></pre>\n<h2 id=\"nav_point_310\">17.2　字符（char）</h2>\n<p>Rust 的 <code>char</code> 类型是一个包含 Unicode 码点的 32 位值。<code>char</code> 保证会落在 <code>0</code>~ <code>0xd7ff</code> 或 <code>0xe000</code>~ <code>0x10ffff</code> 范围内，所有用于创建和操作 <code>char</code> 值的方法都会确保此规则永远成立。<code>char</code> 类型实现了 <code>Copy</code> 和 <code>Clone</code>，以及用于比较、哈希和格式化的所有常用特型。</p>\n<p>字符串切片可以使用 <code>slice.chars()</code> 生成针对其字符的迭代器：</p>\n<pre class=\"code-rows\"><code>assert_eq!(\"カニ\".chars().next(), Some('カ'));</code></pre>\n<p>接下来的讲解中出现的变量 <code>ch</code> 全都是 <code>char</code> 类型的。</p>\n<h3 id=\"nav_point_311\">17.2.1　字符分类</h3>\n<p><code>char</code> 类型的一些方法可以将字符分入几个常见类别，如表 17-1 所示。这些都是从 Unicode 中提取的定义。</p>\n<p><strong>表 17-1：<code>char</code> 类型的分类方法</strong></p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00871.jpeg\" alt=\"{%}\" /></p>\n<p>一组仅限于 ASCII 的方法，对任何非 ASCII <code>char</code> 都会返回 <code>false</code>，如表 17-2 所示。</p>\n<p><strong>表 17-2：<code>char</code> 的 ASCII 分类方法</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>方法</p></th>\n<th><p>描述</p></th>\n<th><p>例子</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>ch.is_ascii()</code></p></td>\n<td><p>ASCII 字符：码点介于 <code>0</code> 和 <code>127</code> 之间的字符</p></td>\n<td><p><code>'n'.is_ascii()</code><br /><code>!'ñ'.is_ascii()</code></p></td>\n</tr>\n<tr>\n<td><p><code>ch.is_ascii_alphabetic()</code></p></td>\n<td><p>大写或小写 ASCII 字母，在 <code>'A'..='Z'</code> 或 <code>'a'..='z'</code> 范围内</p></td>\n<td><p><code>'n'.is_ascii_alphabetic()</code><br /><code>!'1'.is_ascii_alphabetic()</code><br /><code>!'ñ'.is_ascii_alphabetic()</code></p></td>\n</tr>\n<tr>\n<td><p><code>ch.is_ascii_digit()</code></p></td>\n<td><p>ASCII 数字，在 <code>'0'..='9'</code> 范围内</p></td>\n<td><p><code>'8'.is_ascii_digit()</code><br /><code>!'-'.is_ascii_digit()</code><br /><code>!'⑧'.is_ascii_digit()</code></p></td>\n</tr>\n<tr>\n<td><p><code>ch.is_ascii_hexdigit()</code></p></td>\n<td><p><code>'0'..='9'</code>、<code>'A'..='F'</code> 或 <code>'a'..='f'</code> 范围内的任何字符</p></td>\n<td><p>&nbsp;</p></td>\n</tr>\n<tr>\n<td><p><code>ch.is_ascii_alphanumeric()</code></p></td>\n<td><p>ASCII 数字或者大写字母或小写字母</p></td>\n<td><p><code>'q'.is_ascii_alphanumeric()</code><br /><code>'0'.is_ascii_alphanumeric()</code></p></td>\n</tr>\n<tr>\n<td><p><code>ch.is_ascii_control()</code></p></td>\n<td><p>ASCII 控制字符，包括 <code>DEL</code></p></td>\n<td><p><code>'\\n'.is_ascii_control()</code><br /><code>'\\x7f'.is_ascii_control()</code></p></td>\n</tr>\n<tr>\n<td><p><code>ch.is_ascii_graphic()</code></p></td>\n<td><p>会在页面上留下墨迹的任何 ASCII 字符：既不是空白字符也不是控制字符</p></td>\n<td><p><code>'Q'.is_ascii_graphic()</code><br /><code>'~'.is_ascii_graphic()</code><br /><code>!' '.is_ascii_graphic()</code></p></td>\n</tr>\n<tr>\n<td><p><code>ch.is_ascii_uppercase(), ch.is_ascii_lowercase()</code></p></td>\n<td><p>ASCII 大写字母和小写字母</p></td>\n<td><p><code>'z'.is_ascii_lowercase()</code><br /><code>'Z'.is_ascii_uppercase()</code></p></td>\n</tr>\n<tr>\n<td><p><code>ch.is_ascii_punctuation()</code></p></td>\n<td><p>既不是字母也不是数字的任何 ASCII 图形字符 <span class=\"comment-number\">1</span></p></td>\n<td><p>&nbsp;</p></td>\n</tr>\n<tr>\n<td><p><code>ch.is_ascii_whitespace()</code></p></td>\n<td><p>ASCII 空白字符：空格、水平制表符、换行符、换页符或回车符</p></td>\n<td><p><code>' '.is_ascii_whitespace()</code><br /><code>'\\n'.is_ascii_whitespace()</code><br /><code>!'\\u'.is_ascii_whitespace()</code></p></td>\n</tr>\n</tbody>\n</table>\n\n<p>所有 <code>is_ascii_...</code> 方法也可用于 <code>u8</code> 字节类型：</p>\n<pre class=\"code-rows\"><code>assert!(32u8.is_ascii_whitespace());\nassert!(b'9'.is_ascii_digit());</code></pre>\n<p>在使用这些函数来实现现有规范（如编程语言标准或文件格式）时一定要小心，因为这些分类可能存在某些令人吃惊的差异。例如，注意 <code>is_whitespace</code> 和 <code>is_ascii_whitespace</code> 对某些字符的处理不同：</p>\n<pre class=\"code-rows\"><code>let line_tab = '\\u'; //“行间制表符”，也叫“垂直制表符”\nassert_eq!(line_tab.is_whitespace(), true);\nassert_eq!(line_tab.is_ascii_whitespace(), false);</code></pre>\n<p>这是因为 <code>char::is_ascii_whitespace</code> 函数实现了许多 Web 标准中通用的空白字符定义，而 <code>char::is_whitespace</code> 遵循的是 Unicode 标准。</p>\n<h3 id=\"nav_point_312\">17.2.2　处理数字</h3>\n<p>对于数字的处理，可以使用以下方法。</p>\n<blockquote>\n<p><code>ch.to_digit(radix)</code>（转数字）</p>\n</blockquote>\n<p>判断 <code>ch</code> 是不是以 <code>radix</code> 为基数的数字。如果是，就返回 <code>Some(num)</code>，其中 <code>num</code> 是 <code>u32</code>；否则，返回 <code>None</code>。此方法只会识别 ASCII 数字，而不包括 <code>char::is_numeric</code> 涵盖的更广泛的字符类别。<code>radix</code> 参数的范围可以从 2 到 36。对于大于 10 的基数，会用 ASCII 字母（不分大小写）表示值为 10 到 35 的数字。</p>\n<blockquote>\n<p><code>std::char::from_digit(num, radix)</code>（来自数字）</p>\n</blockquote>\n<p>自由函数，只要有可能，就可以把 <code>u32</code> 数字值 <code>num</code> 转换为 <code>char</code>。如果 <code>num</code> 可以表示为 <code>radix</code> 中的单个数字，那么 <code>from_digit</code> 就会返回 <code>Some(ch)</code>，其中 <code>ch</code> 是数字。当 <code>radix</code> 大于 <code>10</code> 时，<code>ch</code> 可以是小写字母。否则，它会返回 <code>None</code>。</p>\n<p>这是 <code>to_digit</code> 的逆函数。如果 <code>std::char::from_digit(num, radix)</code> 等于 <code>Some(ch)</code>，则 <code>ch.to_digit(radix)</code> 等于 <code>Some(num)</code>。如果 <code>ch</code> 是 ASCII 数字或小写字母，则反之亦成立。</p>\n<blockquote>\n<p><code>ch.is_digit(radix)</code>（是数字？）</p>\n</blockquote>\n<p>如果 <code>ch</code> 可以表示以 <code>radix</code> 为基数的 ASCII 数字，就返回 <code>true</code>。此方法等效于 <code>ch.to_digit(radix) != None</code>。</p>\n<p>关于上述方法，举例如下。</p>\n<pre class=\"code-rows\"><code>assert_eq!('F'.to_digit(16), Some(15));\nassert_eq!(std::char::from_digit(15, 16), Some('f'));\nassert!(char::is_digit('f', 16));</code></pre>\n<h3 id=\"nav_point_313\">17.2.3　字符大小写转换</h3>\n<p>处理字符大小写的方法如下。</p>\n<blockquote>\n<p><code>ch.is_lowercase()</code>（是小写？）和 <code>ch.is_uppercase()</code>（是大写？）</p>\n</blockquote>\n<p>指出 <code>ch</code> 是小写字母字符还是大写字母字符。这两个方法遵循 Unicode 的派生属性 Lowercase（小写字母）和 Uppercase（大写字母），因此它们涵盖了非拉丁字母表（如希腊字母和西里尔字母），并给出了和 ASCII 一样的预期结果。</p>\n<blockquote>\n<p><code>ch.to_lowercase()</code>（转小写）和 <code>ch.to_uppercase()</code>（转大写）</p>\n</blockquote>\n<p>根据 Unicode 的默认大小写转换算法，返回生成 <code>ch</code> 的小写和大写对应字符的迭代器：</p>\n<pre class=\"code-rows\"><code>let mut upper = 's'.to_uppercase();\nassert_eq!(upper.next(), Some('S'));\nassert_eq!(upper.next(), None);</code></pre>\n<p>这两个方法会返回迭代器而不是单个字符，因为 Unicode 中的大小写转换并不总是一对一的过程：</p>\n<pre class=\"code-rows\"><code>// 德文字母\"ß\"的大写形式是\"SS\"：\nlet mut upper = 'ß'.to_uppercase();\nassert_eq!(upper.next(), Some('S'));\nassert_eq!(upper.next(), Some('S'));\nassert_eq!(upper.next(), None);\n\n// Unicode规定在将带点的土耳其大写字母'İ'变为小写时要转成'i'后跟一个\n// `'\\u'`，把点组合到字母上，以便在随后转换回大写字母时保留这个点\nlet ch = 'İ'; // `'\\u'`\nlet mut lower = ch.to_lowercase();\nassert_eq!(lower.next(), Some('i'));\nassert_eq!(lower.next(), Some('\\u'));\nassert_eq!(lower.next(), None);</code></pre>\n<p>为便于使用，这些迭代器都实现了 <code>std::fmt::Display</code> 特型，因此可以将它们直接传给 <code>println!</code> 或 <code>write!</code> 宏。</p>\n<h3 id=\"nav_point_314\">17.2.4　与整数之间的转换</h3>\n<p>Rust 的 <code>as</code> 运算符会将 <code>char</code> 转换为任何整数类型，并抹掉高位：</p>\n<pre class=\"code-rows\"><code>assert_eq!('B' as u32, 66);\nassert_eq!('饂' as u8, 66);   // 截断高位\nassert_eq!('二' as i8, -116); // 同上</code></pre>\n<p><code>as</code> 运算符会将任何 <code>u8</code> 值转换为 <code>char</code>，并且 <code>char</code> 也实现了 <code>From&lt;u8&gt;</code>。但是，更宽的整数类型可以表示无效码点，因此对于那部分整数，必须使用 <code>std::char::from_u32</code> 进行转换，它会返回 <code>Option&lt;char&gt;</code>。</p>\n<pre class=\"code-rows\"><code>assert_eq!(char::from(66), 'B');\nassert_eq!(std::char::from_u32(0x9942), Some('饂'));\nassert_eq!(std::char::from_u32(0xd800), None); // 为UTF-16保留的码点</code></pre>\n<h2 id=\"nav_point_315\">17.3　String 与 str</h2>\n<p>Rust 的 <code>String</code> 类型和 <code>str</code> 类型会保证自己只包含格式良好的 UTF-8。标准库通过限制你创建 <code>String</code> 值和 <code>str</code> 值的方式以及可以对它们执行的操作来确保这一点。这样，当引入这些值时一定是格式良好的，而且在使用中也是如此。它们所有的方法都会坚守这个保证：对它们的任何安全操作都不会引入格式错误的 UTF-8。这就简化了处理文本的代码。</p>\n<p>Rust 可以将文本处理方法关联到 <code>str</code> 或 <code>String</code> 上，具体关联到哪个取决于该方法是需要可调整大小的缓冲区还是仅满足于就地使用文本。由于 <code>String</code> 可以解引用成 <code>&amp;str</code>，因此在 <code>str</code> 上定义的每个方法都可以直接在 <code>String</code> 上使用。本节会介绍这两种类型的方法，并按其功能粗略分组。</p>\n<p>文本处理方法会按字节偏移量索引文本并以字节而不是字符为单位测量其长度。实际上，考虑到 Unicode 的性质，按字符索引并不像看起来那么有用，按字节偏移量索引反而更快且更简单。如果试图使用位于某个字符的 UTF-8 编码中间的字节偏移量，则该方法会发生 panic，因此不能通过这种方式引入格式错误的 UTF-8。</p>\n<p><code>String</code> 通过封装 <code>Vec&lt;u8&gt;</code> 实现，并可以确保向量中的内容永远是格式良好的 UTF-8。Rust 永远不会把 <code>String</code> 改成更复杂的表示形式，因此你可以假设 <code>String</code> 的性能表现始终会和 <code>Vec</code> 保持一致。</p>\n<p>在后面的讲解里，所有用到的变量都具有表 17-3 中给出的类型。</p>\n<p><strong>表 17-3：后面的讲解里要用到的变量类型</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>变量</p></th>\n<th><p>预设类型</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>string</code></p></td>\n<td><p><code>String</code></p></td>\n</tr>\n<tr>\n<td><p><code>slice</code></p></td>\n<td><p><code>&amp;str</code> 或对某值（如 <code>String</code> 或 <code>Rc&lt;String&gt;</code>）的解引用</p></td>\n</tr>\n<tr>\n<td><p><code>ch</code></p></td>\n<td><p><code>char</code></p></td>\n</tr>\n<tr>\n<td><p><code>n</code></p></td>\n<td><p><code>usize</code>，长度</p></td>\n</tr>\n<tr>\n<td><p><code>i</code>、<code>j</code></p></td>\n<td><p><code>usize</code>，字节偏移量</p></td>\n</tr>\n<tr>\n<td><p><code>range</code></p></td>\n<td><p>字节偏移量的 <code>usize</code> 范围，可以像 <code>i..j</code> 一样完全有界，也可以像 <code>i..</code>、<code>..j</code> 或 <code>..</code> 一样部分有界</p></td>\n</tr>\n<tr>\n<td><p><code>pattern</code></p></td>\n<td><p>任何模式类型：<code>char</code>、<code>String</code>、<code>&amp;str</code>、<code>&amp;[char]</code> 或 <code>FnMut(char) -&gt; bool</code></p></td>\n</tr>\n</tbody>\n</table>\n<p>17.3.6 节会讲解模式类型。</p>\n<h3 id=\"nav_point_316\">17.3.1　创建字符串值</h3>\n<p>创建 <code>String</code> 值的常见方法有以下几种。</p>\n<blockquote>\n<p><code>String::new()</code>（新建）</p>\n</blockquote>\n<p>返回一个新的空字符串。这时还没有在堆上分配缓冲区，但将来会按需分配。</p>\n<blockquote>\n<p><code>String::with_capacity(n)</code>（自带容量）</p>\n</blockquote>\n<p>返回一个新的空字符串，其中预先分配了一个足以容纳至少 <code>n</code> 字节的缓冲区。如果事先知道要构建的字符串的长度，则此构造函数可以让你从一开始就正确设置缓冲区大小，而不是等构建字符串时再进行调整。如果字符串的长度超过 <code>n</code> 字节，则该字符串仍会根据需要增加其缓冲区。与向量一样，字符串也有 <code>capacity</code> 方法、<code>reserve</code> 方法和 <code>shrink_to_fit</code> 方法，但一般来说默认的分配逻辑就很好。</p>\n<blockquote>\n<p><code>str_slice.to_string()</code>（转字符串）</p>\n</blockquote>\n<p>分配一个新的 <code>String</code>，其内容是 <code>str_slice</code> 的副本。本书一直在使用诸如 <code>\"literal text\".to_string()</code> 之类的表达式来从字符串字面量生成 <code>String</code>。</p>\n<blockquote>\n<p><code>iter.collect()</code>（收集）</p>\n</blockquote>\n<p>通过串联迭代器的各个条目构造出字符串，迭代器的条目可以是 <code>char</code> 值、<code>&amp;str</code> 值或 <code>String</code> 值。例如，要从字符串中移除所有空格，可以这样写：</p>\n<pre class=\"code-rows\"><code>let spacey = \"man hat tan\";\nlet spaceless: String =\n    spacey.chars().filter(|c| !c.is_whitespace()).collect();\nassert_eq!(spaceless, \"manhattan\");</code></pre>\n<p>以这种方式使用 <code>collect</code> 可以充分利用 <code>String</code> 对 <code>std::iter::FromIterator</code> 特型的实现。</p>\n<blockquote>\n<p><code>slice.to_owned()</code>（转自有）</p>\n</blockquote>\n<p>将 <code>slice</code> 的副本作为新分配的 <code>String</code> 返回。<code>str</code> 类型无法实现 <code>Clone</code>：该特型需要在 <code>&amp;str</code> 上进行 <code>clone</code> 以返回 <code>str</code> 值，但 <code>str</code> 是无固定大小类型。不过，<code>&amp;str</code> 实现了 <code>ToOwned</code>，这能让实现者指定其自有（<code>Owned</code>）版本的等效类型。</p>\n<h3 id=\"nav_point_317\">17.3.2　简单探查</h3>\n<p>下面这些方法可以从字符串切片中获取基本信息。</p>\n<blockquote>\n<p><code>slice.len()</code>（长度）</p>\n</blockquote>\n<p><code>slice</code> 的长度，以字节为单位。</p>\n<blockquote>\n<p><code>slice.is_empty()</code>（为空？）</p>\n</blockquote>\n<p>如果 <code>slice.len() == 0</code>，就返回 <code>True</code>。</p>\n<blockquote>\n<p><code>slice[range]</code>（范围内切片）</p>\n</blockquote>\n<p>返回借用了 <code>slice</code> 给定部分的切片。有界的范围、部分有界的范围和无界的范围都可以。</p>\n<p>例如：</p>\n<pre class=\"code-rows\"><code>let full = \"bookkeeping\";\nassert_eq!(&amp;full[..4], \"book\");\nassert_eq!(&amp;full[5..], \"eeping\");\nassert_eq!(&amp;full[2..4], \"ok\");\nassert_eq!(full[..].len(), 11);\nassert_eq!(full[5..].contains(\"boo\"), false);</code></pre>\n<p>请注意，不能索引具有单个位置的字符串切片，比如 <code>slice[i]</code>。要想在给定的字节偏移处获取单个字符有点儿笨拙：必须在切片上生成一个 <code>chars</code> 迭代器，并要求它解析成单个字符的 UTF-8：</p>\n<pre class=\"code-rows\"><code>let parenthesized = \"Rust (饂)\";\nassert_eq!(parenthesized[6..].chars().next(), Some('饂'));</code></pre>\n<p>不过，你很少需要这样做。Rust 有更好的方法来迭代切片，17.3.8 节会对此进行讲解。</p>\n<blockquote>\n<p><code>slice.split_at(i)</code>（拆分于）</p>\n</blockquote>\n<p>返回从 <code>slice</code> 借来的两个共享切片的元组：一个是字节偏移量 <code>i</code> 之前的部分，另一个是字节偏移量 <code>i</code> 之后的部分。换句话说，这会返回 <code>(slice[..i], slice[i..])</code>。</p>\n<blockquote>\n<p><code>slice.is_char_boundary(i)</code>（是字符边界？）</p>\n</blockquote>\n<p>如果字节偏移量 <code>i</code> 恰好落在字符边界之间并且适合作为 <code>slice</code> 的偏移量，就返回 <code>True</code>。</p>\n<p>自然，也可以对切片做相等性比较、排序和哈希。有序比较只是将字符串视为一系列 Unicode 码点，并按字典顺序进行比较。</p>\n<h3 id=\"nav_point_318\">17.3.3　追加文本与插入文本</h3>\n<p>以下方法会将文本添加到 <code>String</code> 中。</p>\n<blockquote>\n<p><code>string.push(ch)</code>（压入）</p>\n</blockquote>\n<p>将字符 <code>ch</code> 追加到 <code>string</code> 的末尾。</p>\n<blockquote>\n<p><code>string.push_str(slice)</code>（压入字符串）</p>\n</blockquote>\n<p>追加 <code>slice</code> 的全部内容。</p>\n<blockquote>\n<p><code>string.extend(iter)</code>（以 <code>iter</code> 扩展）</p>\n</blockquote>\n<p>将迭代器 <code>iter</code> 生成的条目追加到字符串中。迭代器可以生成 <code>char</code> 值、<code>str</code> 值或 <code>String</code> 值。这是 <code>String</code> 对 <code>std::iter::Extend</code> 特型的实现。</p>\n<pre class=\"code-rows\"><code>let mut also_spaceless = \"con\".to_string();\nalso_spaceless.extend(\"tri but ion\".split_whitespace());\nassert_eq!(also_spaceless, \"contribution\");</code></pre>\n<blockquote>\n<p><code>string.insert(i, ch)</code>（插入于）</p>\n</blockquote>\n<p>在 <code>string</code> 内的字节偏移量 <code>i</code> 处插入单个字符 <code>ch</code>。这需要平移 <code>i</code> 之后的所有字符以便为 <code>ch</code> 腾出空间，因此用这种方式构建字符串的时间复杂度是 <em>O</em>(<em>n</em>)<span class=\"comment-number\">2</span>。</p>\n\n<blockquote>\n<p><code>string.insert_str(i, slice)</code>（插入字符串于）</p>\n</blockquote>\n<p>这会在 <code>string</code> 内插入 <code>slice</code>，但同样需要注意性能问题。</p>\n<p><code>String</code> 实现了 <code>std::fmt::Write</code>，这意味着 <code>write!</code> 宏和 <code>writeln!</code> 宏可以将格式化后的文本追加到 <code>String</code> 上：</p>\n<pre class=\"code-rows\"><code>use std::fmt::Write;\n\nlet mut letter = String::new();\nwriteln!(letter, \"Whose {} these are I think I know\", \"rutabagas\")?;\nwriteln!(letter, \"His house is in the village though;\")?;\nassert_eq!(letter, \"Whose rutabagas these are I think I know\\n\\\n                    His house is in the village though;\\n\");</code></pre>\n<p>由于 <code>write!</code> 和 <code>writeln!</code> 是专为写入输出流而设计的，因此它们会返回一个 <code>Result</code>，如果你忽略 <code>Result</code>，则 Rust 会报错。上述代码使用了 <code>?</code> 运算符来处理错误，但实际上写入 <code>String</code> 是肯定不会出错的，因此这种情况下也可以调用 <code>.unwrap()</code>。</p>\n<p>因为 <code>String</code> 实现了 <code>Add&lt;&amp;str&gt;</code> 和 <code>AddAssign&lt;&amp;str&gt;</code>，所以你可以编写如下代码：</p>\n<pre class=\"code-rows\"><code>let left = \"partners\".to_string();\nlet mut right = \"crime\".to_string();\nassert_eq!(left + \" in \" + &amp;right, \"partners in crime\");\n\nright += \" doesn't pay\";\nassert_eq!(right, \"crime doesn't pay\");</code></pre>\n<p>当应用于字符串时，<code>+</code> 运算符会按值获取其左操作数，所以实际上它可以重用该 <code>String</code> 的缓冲区作为加法的结果。因此，如果左操作数的缓冲区足够容纳结果，那么就不需要分配内存。</p>\n<p>遗憾的是，此运算不是对称的，<code>+</code> 的左操作数不能是 <code>&amp;str</code>，所以不能写成：</p>\n<pre class=\"code-rows\"><code>let parenthetical = \"(\" + string + \")\";</code></pre>\n<p>只能改成：</p>\n<pre class=\"code-rows\"><code>let parenthetical = \"(\".to_string() + &amp;string + \")\";</code></pre>\n<p>不过，此限制确实妨碍了从末尾向开头反向构建字符串的方式。这种方式性能不佳，因为必须反复把文本平移到缓冲区的末尾。</p>\n<p>然而，通过向末尾追加小片段的方式从头到尾构建字符串是高效的。<code>String</code> 的行为方式与向量是一样的，当它需要更多容量时，总是至少将其缓冲区大小加倍。这就令再次复制的开销与字符串的最终大小成正比。不过，使用 <code>String::with_capacity</code> 创建具有正确缓冲区大小的字符串可以完全避免调整大小，并且可以减少对堆分配器的调用次数。</p>\n<h3 id=\"nav_point_319\">17.3.4　移除文本与替换文本</h3>\n<p><code>String</code> 有以下几个移除文本的方法。（这些方法不会影响字符串的容量，如果需要释放内存，请使用 <code>shrink_to_fit</code>。）</p>\n<blockquote>\n<p><code>string.clear()</code>（清空）</p>\n</blockquote>\n<p>将 <code>string</code> 重置为空字符串。</p>\n<blockquote>\n<p><code>string.truncate(n)</code>（截断为 <em>n</em> 个）</p>\n</blockquote>\n<p>丢弃字节偏移量 <code>n</code> 之后的所有字符，留下长度最多为 <code>n</code> 的 <code>string</code>。如果 <code>string</code> 短于 <code>n</code> 字节，则毫无效果。</p>\n<blockquote>\n<p><code>string.pop()</code>（弹出）</p>\n</blockquote>\n<p>从 <code>string</code> 中移除最后一个字符（如果有的话），并将其作为 <code>Option&lt;char&gt;</code> 返回。</p>\n<blockquote>\n<p><code>string.remove(i)</code>（移除）</p>\n</blockquote>\n<p>从 <code>string</code> 中移除字节偏移量 <code>i</code> 处的字符并返回该字符，将后面的所有字符平移到前面。这个操作所花费的时间与后续字符的数量呈线性关系。</p>\n<blockquote>\n<p><code>string.drain(range)</code>（抽取）</p>\n</blockquote>\n<p>返回给定字节索引范围内的迭代器，并在迭代器被丢弃后移除字符。范围之后的所有字符都会向前平移：</p>\n<pre class=\"code-rows\"><code>let mut choco = \"chocolate\".to_string();\nassert_eq!(choco.drain(3..6).collect::&lt;String&gt;(), \"col\");\nassert_eq!(choco, \"choate\");</code></pre>\n<p>如果只是想移除这个范围，则可以立即丢弃此迭代器，而不从中提取任何条目。</p>\n<pre class=\"code-rows\"><code>let mut winston = \"Churchill\".to_string();\nwinston.drain(2..6);\nassert_eq!(winston, \"Chill\");</code></pre>\n<blockquote>\n<p><code>string.replace_range(range, replacement)</code>（替换范围）</p>\n</blockquote>\n<p>用给定的替代字符串切片替换 <code>string</code> 中的给定范围。切片不必与要替换的范围长度相同，但除非要替换的范围已到达 <code>string</code> 的末尾，否则将需要移动范围末尾之后的所有字节。</p>\n<pre class=\"code-rows\"><code>let mut beverage = \"a piña colada\".to_string();\nbeverage.replace_range(2..7, \"kahlua\"); // 'ñ' 是两字节的！\nassert_eq!(beverage, \"a kahlua colada\");</code></pre>\n<h3 id=\"nav_point_320\">17.3.5　搜索与迭代的约定</h3>\n<p>Rust 用于搜索文本和迭代文本的标准库函数遵循了一些命名约定，以便于记忆。</p>\n<blockquote>\n<p><code>r</code></p>\n</blockquote>\n<p>大多数操作会从头到尾处理文本，但名称以 <strong><code>r</code></strong> 开头的操作会从尾到头处理。例如，<code>rsplit</code> 是 <code>split</code> 的从尾到头版本。在某些情况下，改变处理方向不仅会影响值生成的顺序，还会影响值本身。具体示例请参见图 17-3。</p>\n<blockquote>\n<p><code>n</code></p>\n</blockquote>\n<p>名称以 <strong><code>n</code></strong> 结尾的迭代器会将自己限定为只取给定数量的匹配项。</p>\n<blockquote>\n<p><code>_indices</code><span class=\"comment-number\">3</span></p>\n</blockquote>\n\n<p>名称以 <code>_indices</code> 结尾的迭代器会生成通常的迭代值和在此 <code>slice</code> 中的字节偏移量组成的值对。</p>\n<p>标准库并不会提供每个操作的所有组合。例如，许多操作并不需要 <code>n</code> 变体，因为很容易简单地提前结束迭代。</p>\n<h3 id=\"nav_point_321\">17.3.6　搜索文本的模式</h3>\n<p>当标准库函数需要搜索、匹配、拆分或修剪文本时，它能接受如下几种类型来表示要查找的内容：</p>\n<pre class=\"code-rows\"><code>let haystack = \"One fine day, in the middle of the night\";\n\nassert_eq!(haystack.find(','), Some(12));\nassert_eq!(haystack.find(\"night\"), Some(35));\nassert_eq!(haystack.find(char::is_whitespace), Some(3));</code></pre>\n<p>这些类型称为<strong>模式</strong>，大多数操作支持它们。</p>\n<pre class=\"code-rows\"><code>assert_eq!(\"## Elephants\"\n           .trim_start_matches(|ch: char| ch == '#' || ch.is_whitespace()),\n           \"Elephants\");</code></pre>\n<p>标准库支持 4 种主要的模式。</p>\n<ul>\n<li>以 <code>char</code> 作为模式意味着要匹配该字符。</li>\n<li>以 <code>String</code>、<code>&amp;str</code> 或 <code>&amp;&amp;str</code> 作为模式，意味着要匹配等于该模式的子串。</li>\n<li>以 <code>FnMut(char) -&gt; bool</code> 闭包作为模式，意味着要匹配该闭包返回 <code>true</code> 的单个字符。</li>\n<li><p>以 <code>&amp;[char]</code>（注意并不是 <code>&amp;str</code>，而是 <code>char</code> 的切片）作为模式，意味着要匹配该列表中出现的任何单个字符。请注意，如果将此列表写成数组字面量，那么可能要调用 <code>as_ref()</code> 来获得正确的类型。</p>\n<pre class=\"code-rows\"><code>let code = \"\\t    function noodle() { \";\nassert_eq!(code.trim_start_matches([' ', '\\t'].as_ref()),\n           \"function noodle() { \");\n// 更短的等效形式：&amp;[' ', '\\t'][..]4</code></pre>\n<blockquote>\n<p><sup><b>4</b></sup>从 Rust 1.51.0 开始，通常可以使用更简短的形式，即 <code>&amp;[' ', '\\t']</code>。——译者注</p>\n</blockquote>\n<p>如果不这么做，则 Rust 会误以为这是固定大小数组类型 <code>&amp;[char; 2]</code>。遗憾的是，<code>&amp;[char; 2]</code> 不是有效的模式类型。</p>\n</li>\n</ul>\n<p>在标准库本身的代码中，模式就是实现了 <code>std::str::Pattern</code> 特型的任意类型。<code>Pattern</code> 的细节还不稳定，所以你不能在稳定版的 Rust 中为自己的类型实现它。但是，将来要支持正则表达式和其他复杂模式也很容易。Rust 可以保证现在支持的模式类型将来仍会继续有效。</p>\n<h3 id=\"nav_point_322\">17.3.7　搜索与替换</h3>\n<p>Rust 提供了一些可以在切片中搜索某些模式并可能将其替换成新文本的方法。</p>\n<blockquote>\n<p><code>slice.contains(pattern)</code>（包含）</p>\n</blockquote>\n<p>如果 <code>slice</code> 包含 <code>pattern</code> 的匹配项，就返回 <code>true</code>。</p>\n<blockquote>\n<p><code>slice.starts_with(pattern)</code>（以 <code>pattern</code> 开头）和 <code>slice.ends_with(pattern)</code>（以 <code>pattern</code> 结尾）</p>\n</blockquote>\n<p>如果 <code>slice</code> 的起始文本或结尾文本与 <code>pattern</code> 相匹配，就返回 <code>true</code>。</p>\n<pre class=\"code-rows\"><code>assert!(\"2017\".starts_with(char::is_numeric));</code></pre>\n<blockquote>\n<p><code>slice.find(pattern)</code>（查找）和 <code>slice.rfind(pattern)</code>（右起查找）</p>\n</blockquote>\n<p>如果 <code>slice</code> 包含 <code>pattern</code> 的匹配项，就返回 <code>Some(i)</code>，其中的 <code>i</code> 是模式出现的字节偏移量。<code>find</code> 方法会返回第一个匹配项，<code>rfind</code> 方法则返回最后一个。</p>\n<pre class=\"code-rows\"><code>let quip = \"We also know there are known unknowns\";\nassert_eq!(quip.find(\"know\"), Some(8));\nassert_eq!(quip.rfind(\"know\"), Some(31));\nassert_eq!(quip.find(\"ya know\"), None);\nassert_eq!(quip.rfind(char::is_uppercase), Some(0));</code></pre>\n<blockquote>\n<p><code>slice.replace(pattern, replacement)</code>（替换）</p>\n</blockquote>\n<p>返回新的 <code>String</code>，它是通过用 <code>replacement</code> 急性<span class=\"comment-number\">5</span>替换 <code>pattern</code> 的所有匹配项而形成的：</p>\n\n<pre class=\"code-rows\"><code>assert_eq!(\"The only thing we have to fear is fear itself\"\n           .replace(\"fear\", \"spin\"),\n           \"The only thing we have to spin is spin itself\");\n\nassert_eq!(\"`Borrow` and `BorrowMut`\"\n           .replace(|ch:char| !ch.is_alphanumeric(), \"\"),\n           \"BorrowandBorrowMut\");</code></pre>\n<p>因为替换是急性完成的，所以 <code>.replace()</code> 在彼此重叠的几个匹配段上的行为可能令人惊讶。这里有 4 个匹配 <code>\"aba\"</code> 模式的实例，但在替换了第一个和第三个之后，第二个和第四个就不再匹配了。</p>\n<pre class=\"code-rows\"><code>assert_eq!(\"cabababababbage\"\n           .replace(\"aba\", \"***\"),\n           \"c***b***babbage\")</code></pre>\n<blockquote>\n<p><code>slice.replacen(pattern, replacement, n)</code>（替换 <em>n</em> 次）</p>\n</blockquote>\n<p>与上一个方法类似，但最多替换前 <code>n</code> 个匹配项。</p>\n<h3 id=\"nav_point_323\">17.3.8　遍历文本</h3>\n<p>标准库提供了几种对切片的文本进行迭代的方法。图 17-3 展示了一些示例。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00872.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 17-3：迭代切片的一些方法</strong></p>\n<p><code>split</code>（拆分）和 <code>match</code>（匹配）系列方法是互补的：拆分取的是匹配项之间的范围。</p>\n<p>这些方法中大多数会返回可逆的迭代器（也就是说，它们实现了 <code>DoubleEndedIterator</code>）：调用它们的 <code>.rev()</code> 适配器方法会为你提供一个迭代器，该迭代器会生成相同的条目，只是顺序相反。</p>\n<blockquote>\n<p><code>slice.chars()</code>（字符迭代器）</p>\n</blockquote>\n<p>返回访问 <code>slice</code> 中各个字符的迭代器。</p>\n<blockquote>\n<p><code>slice.char_indices()</code>（字符及其偏移量迭代器）</p>\n</blockquote>\n<p>返回访问 <code>slice</code> 中各个字符及其字节偏移量的迭代器：</p>\n<pre class=\"code-rows\"><code>assert_eq!(\"élan\".char_indices().collect::&lt;Vec&lt;_&gt;&gt;(),\n           vec![(0, 'é'), // 有一个双字节UTF-8编码\n                (2, 'l'),\n                (3, 'a'),\n                (4, 'n')]);</code></pre>\n<p>请注意，这并不等同于 <code>.chars().enumerate()</code>，因为本方法提供的是每个字符在切片中的字节偏移量，而不仅仅是字符的序号。</p>\n<blockquote>\n<p><code>slice.bytes()</code>（字节迭代器）</p>\n</blockquote>\n<p>返回访问 <code>slice</code> 中各字节的迭代器，对外暴露 UTF-8 编码细节。</p>\n<pre class=\"code-rows\"><code>assert_eq!(\"élan\".bytes().collect::&lt;Vec&lt;_&gt;&gt;(),\n           vec![195, 169, b'l', b'a', b'n']);</code></pre>\n<blockquote>\n<p><code>slice.lines()</code>（文本行迭代器）</p>\n</blockquote>\n<p>返回访问 <code>slice</code> 中各行的迭代器。各行以 <code>\"\\n\"</code> 或 <code>\"\\r\\n\"</code> 结尾。生成的每个条目都是从 <code>slice</code> 中借入的 <code>&amp;str</code>。这些条目不包括行的终止字符。</p>\n<blockquote>\n<p><code>slice.split(pattern)</code>（拆分）</p>\n</blockquote>\n<p>返回一个迭代器，该迭代器会迭代 <code>slice</code> 中由 <code>pattern</code> 匹配项分隔开的各个部分。这会在紧邻的两个匹配项之间、位于 <code>slice</code> 开头的匹配项与头部之间，以及结尾的匹配项与尾部之间生成空字符串。</p>\n<p>如果 <code>pattern</code> 是 <code>&amp;str</code>，则返回的迭代器不可逆，因为这类模式会根据不同的扫描方向生成不同的匹配序列，但可逆迭代器不允许这种行为。可以改用接下来要讲的 <code>rsplit</code> 方法。</p>\n<blockquote>\n<p><code>slice.rsplit(pattern)</code>（右起拆分）</p>\n</blockquote>\n<p>与上一个方法类似，但此方法会从尾到头扫描 <code>slice</code>，并按该顺序生成匹配项。</p>\n<blockquote>\n<p><code>slice.split_terminator(pattern)</code>（终结符拆分）和 <code>slice.rsplit_terminator(pattern)</code>（右起终结符拆分）</p>\n</blockquote>\n<p>与刚刚讲过的拆分方法类似，但这两个方法会把模式视为终结符，而不是分隔符：如果 <code>pattern</code> 在 <code>slice</code> 的末尾匹配上了，则迭代器不会像 <code>split</code> 和 <code>rsplit</code> 那样生成表示匹配项和切片末尾之间空字符串的空切片。例如：</p>\n<pre class=\"code-rows\"><code>// 这里把':'字符视为分隔符。注意结尾的\"\"（空串）\nassert_eq!(\"jimb:1000:Jim Blandy:\".split(':').collect::&lt;Vec&lt;_&gt;&gt;(),\n           vec![\"jimb\", \"1000\", \"Jim Blandy\", \"\"]);\n\n// 这里把'\\n'字符视为终结符\nassert_eq!(\"127.0.0.1  localhost\\n\\\n            127.0.0.1  www.reddit.com\\n\"\n           .split_terminator('\\n').collect::&lt;Vec&lt;_&gt;&gt;(),\n           vec![\"127.0.0.1  localhost\",\n                \"127.0.0.1  www.reddit.com\"]);\n                // 注意，没有结尾的\"\"！</code></pre>\n<blockquote>\n<p><code>slice.splitn(n, pattern)</code>（拆分为 <em>n</em> 片）和 <code>slice.rsplitn(n, pattern)</code>（右起拆分为 <em>n</em> 片）</p>\n</blockquote>\n<p>与 <code>split</code> 和 <code>rsplit</code> 类似，但这两个方法会把字符串分成最多 <code>n</code> 个切片，拆分位置位于 <code>pattern</code> 的第 <code>n-1</code> 个（<code>split</code>）或倒数第 <code>n-1</code> 个（<code>rsplit</code>）匹配项处。</p>\n<blockquote>\n<p><code>slice.split_whitespace()</code>（按空白字符拆分）和 <code>slice.split_ascii_whitespace()</code>（按 ASCII 空白字符拆分）</p>\n</blockquote>\n<p>返回访问 <code>slice</code> 中以空白字符分隔的各部分的迭代器。这两个方法会把连续多个空白字符视为单个分隔符。忽略尾部空白字符。</p>\n<p><code>split_whitespace</code> 方法会使用 Unicode 的空白字符定义，由 <code>char</code> 上的 <code>is_whitespace</code> 方法实现。<code>split_ascii_whitespace</code> 方法则会使用只识别 ASCII 空白字符的 <code>char::is_ascii_whitespace</code>。</p>\n<pre class=\"code-rows\"><code>let poem = \"This  is  just  to say\\n\\\n            I have eaten\\n\\\n            the plums\\n\\\n            again\\n\";\n\nassert_eq!(poem.split_whitespace().collect::&lt;Vec&lt;_&gt;&gt;(),\n           vec![\"This\", \"is\", \"just\", \"to\", \"say\",\n                \"I\", \"have\", \"eaten\", \"the\", \"plums\",\n                \"again\"]);</code></pre>\n<blockquote>\n<p><code>slice.matches(pattern)</code>（匹配项）</p>\n</blockquote>\n<p>返回访问 <code>slice</code> 中 <code>pattern</code> 匹配项的迭代器。<code>slice.rmatches(pattern)</code> 也一样，但会从尾到头迭代。</p>\n<blockquote>\n<p><code>slice.match_indices(pattern)</code>（匹配项及其偏移量）和 <code>slice.rmatch_indices(pattern)</code>（右起匹配项及其偏移量）</p>\n</blockquote>\n<p>和上一个方法很像，但这两个方法生成的条目是 <code>(offset, match)</code> 值对，其中 <code>offset</code> 是匹配的起始字节的偏移量，而 <code>match</code> 是匹配到的切片。</p>\n<h3 id=\"nav_point_324\">17.3.9　修剪</h3>\n<p><strong>修剪</strong>字符串就是从字符串的开头或结尾移除文本（通常是空白字符）。修剪常用于清理从文件中读取的输入，在此文件中，用户可能为了易读性而添加了文本缩进，或者不小心在一行中留下了尾随空白字符。</p>\n<blockquote>\n<p><code>slice.trim()</code>（修剪）</p>\n</blockquote>\n<p>返回略去了任何前导空白字符和尾随空白字符的 <code>slice</code> 的子切片。<code>slice.trim_start()</code> 只会略去前导空白字符，<code>slice.trim_end()</code> 只会略去尾随空白字符。</p>\n<pre class=\"code-rows\"><code>assert_eq!(\"\\t*.rs  \".trim(), \"*.rs\");\nassert_eq!(\"\\t*.rs  \".trim_start(), \"*.rs  \");\nassert_eq!(\"\\t*.rs  \".trim_end(), \"\\t*.rs\");</code></pre>\n<blockquote>\n<p><code>slice.trim_matches(pattern)</code>（按匹配修剪）</p>\n</blockquote>\n<p>返回 <code>slice</code> 的子切片，该子切片从开头和结尾略去了 <code>pattern</code> 的所有匹配项。<code>trim_start_matches</code> 方法和 <code>trim_end_matches</code> 方法只会对匹配的前导内容或尾随内容执行修剪操作。</p>\n<pre class=\"code-rows\"><code>assert_eq!(\"001990\".trim_start_matches('0'), \"1990\");</code></pre>\n<blockquote>\n<p><code>slice.strip_prefix(pattern)</code>（剥离前缀）和 <code>slice.strip_suffix(pattern)</code>（剥离后缀）</p>\n</blockquote>\n<p>如果 <code>slice</code> 以 <code>pattern</code> 开头，则 <code>strip_prefix</code> 会返回一个 <code>Some</code>，其中携带了移除匹配文本之后的切片。否则，它会返回 <code>None</code>。<code>strip_suffix</code> 方法与此类似，但会检查字符串末尾的匹配项。</p>\n<p>与 <code>trim_start_matches</code> 和 <code>trim_end_matches</code> 类似，但这里的两个方法会返回 <code>Option</code>，并且只会移除一个匹配 <code>pattern</code> 的副本。</p>\n<pre class=\"code-rows\"><code>let slice = \"banana\";\nassert_eq!(slice.strip_suffix(\"na\"),\n           Some(\"bana\"))</code></pre>\n<h3 id=\"nav_point_325\">17.3.10　字符串的大小写转换</h3>\n<p><code>slice.to_uppercase()</code> 方法和 <code>slice.to_lowercase()</code> 方法会返回一个新分配的字符串，其中包含已转为大写或小写的 <code>slice</code> 文本。结果的长度可能与 <code>slice</code> 不同，有关详细信息，请参阅 17.2.3 节。</p>\n<h3 id=\"nav_point_326\">17.3.11　从字符串中解析出其他类型</h3>\n<p>Rust 为“从字符串解析出值”和“生成值的文本表示”提供了一些标准特型。</p>\n<p>如果一个类型实现了 <code>std::str::FromStr</code> 特型，那它就提供了一种从字符串切片中解析出值的标准方法：</p>\n<pre class=\"code-rows\"><code>pub trait FromStr: Sized {\n    type Err;\n    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt;;\n}</code></pre>\n<p>所有常见的机器类型都实现了 <code>FromStr</code>：</p>\n<pre class=\"code-rows\"><code>use std::str::FromStr;\n\nassert_eq!(usize::from_str(\"3628800\"), Ok(3628800));\nassert_eq!(f64::from_str(\"128.5625\"), Ok(128.5625));\nassert_eq!(bool::from_str(\"true\"), Ok(true));\n\nassert!(f64::from_str(\"not a float at all\").is_err());\nassert!(bool::from_str(\"TRUE\").is_err());</code></pre>\n<p><code>char</code> 类型也实现了 <code>FromStr</code>，用于解析只有一个字符的字符串：</p>\n<pre class=\"code-rows\"><code>assert_eq!(char::from_str(\"é\"), Ok('é'));\nassert!(char::from_str(\"abcdefg\").is_err());</code></pre>\n<p><code>std::net::IpAddr</code> 类型，即包含 IPv4 或 IPv6 互联网地址的 <code>enum</code>，同样实现了 <code>FromStr</code>：</p>\n<pre class=\"code-rows\"><code>use std::net::IpAddr;\n\nlet address = IpAddr::from_str(\"fe80::0000:3ea9:f4ff:fe34:7a50\")?;\nassert_eq!(address,\n           IpAddr::from([0xfe80, 0, 0, 0, 0x3ea9, 0xf4ff, 0xfe34, 0x7a50]));</code></pre>\n<p>字符串切片有一个 <code>parse</code> 方法，该方法可以将切片解析为你想要的任何类型——只要它实现了 <code>FromStr</code>。与 <code>Iterator::collect</code> 一样，有时需要明确写出想要的类型，因此用 <code>parse</code> 不一定比直接调用 <code>from_str</code> 可读性强。</p>\n<pre class=\"code-rows\"><code>let address = \"fe80::0000:3ea9:f4ff:fe34:7a50\".parse::&lt;IpAddr&gt;()?;</code></pre>\n<h3 id=\"nav_point_327\">17.3.12　将其他类型转换为字符串</h3>\n<p>将非文本值转换为字符串的方法主要有以下 3 种。</p>\n<ul>\n<li><p>那些具有人类可读的自然打印形式的类型可以实现 <code>std::fmt::Display</code> 特型，该特型允许在 <code>format!</code> 宏的格式中使用 <code>{}</code> 格式说明符：</p>\n<pre class=\"code-rows\"><code>assert_eq!(format!(\"{}, wow\", \"doge\"), \"doge, wow\");\nassert_eq!(format!(\"{}\", true), \"true\");\nassert_eq!(format!(\"({:.3}, {:.3})\", 0.5, f64::sqrt(3.0)/2.0),\n           \"(0.500, 0.866)\");\n\n// 使用上一个例子中的`address`\nlet formatted_addr: String = format!(\"{}\", address);\nassert_eq!(formatted_addr, \"fe80::3ea9:f4ff:fe34:7a50\");</code></pre>\n<p>Rust 的所有机器数值类型都实现了 <code>Display</code>，字符、字符串和切片也是如此。智能指针类型 <code>Box&lt;T&gt;</code>、<code>Rc&lt;T&gt;</code> 和 <code>Arc&lt;T&gt;</code> 也实现了 <code>Display</code>（只要 <code>T</code> 本身实现了 <code>Display</code>）：它们的显示形式就只是其引用目标的显示形式而已。而像 <code>Vec</code> 和 <code>HashMap</code> 这样的容器则没有实现 <code>Display</code>，因为这些类型没有人类可读的单一自然形式。</p>\n<p>&nbsp;</p>\n</li>\n<li><p>如果一个类型实现了 <code>Display</code>，那么标准库就会自动为它实现 <code>std::str::ToString</code> 特型，当你不需要 <code>format!</code> 的灵活性时，使用此特型的唯一方法 <code>to_string</code> 会更方便：</p>\n<pre class=\"code-rows\"><code>// 接续前面的例子\nassert_eq!(address.to_string(), \"fe80::3ea9:f4ff:fe34:7a50\");</code></pre>\n<p>Rust 在引入 <code>Display</code> 之前就已经引入 <code>ToString</code> 特型了，但该特型不太灵活。对于自己的类型，你通常应该实现 <code>Display</code> 而非 <code>ToString</code>。</p>\n<p>&nbsp;</p>\n</li>\n<li><p>标准库中的每个公共类型都实现了 <code>std::fmt::Debug</code>，这个特型会接受一个值并将其格式化为对程序员有用的字符串。用 <code>Debug</code> 生成字符串的最简单方法是使用 <code>format!</code> 宏的 <code>{:?}</code> 格式说明符：</p>\n<pre class=\"code-rows\"><code>// 接续前面的例子\nlet addresses = vec![address,\n                     IpAddr::from_str(\"192.168.0.1\")?];\nassert_eq!(format!(\"{:?}\", addresses),\n           \"[fe80::3ea9:f4ff:fe34:7a50, 192.168.0.1]\");</code></pre>\n<p>对于本身实现了 <code>Debug</code> 的任何类型 <code>T</code>，这里利用了 <code>Vec&lt;T&gt;</code> 对 <code>Debug</code> 的通用实现。Rust 的所有集合类型都有这样的实现。</p>\n<p>你也应该为自己的类型实现 <code>Debug</code>。通常，最好让 Rust 派生一个实现，就像我们在第 12 章中对 <code>Complex</code> 类型所做的那样：</p>\n<pre class=\"code-rows\"><code>#[derive(Copy, Clone, Debug)]\nstruct Complex { re: f64, im: f64 }</code></pre>\n</li>\n</ul>\n<p><code>format!</code> 及其相关宏在把值格式化为文本时用到了很多格式化特型，<code>Display</code> 和 <code>Debug</code> 只是其中的两个。17.4 节会介绍其他特型，并解释如何实现它们。</p>\n<h3 id=\"nav_point_328\">17.3.13　借用其他类似文本的类型</h3>\n<p>可以通过以下两种方式借用切片的内容。</p>\n<ul>\n<li>切片和 <code>String</code> 都实现了 <code>AsRef&lt;str&gt;</code>、<code>AsRef&lt;[u8]&gt;</code>、<code>AsRef&lt;Path&gt;</code> 和 <code>AsRef&lt;OsStr&gt;</code>。许多标准库函数会使用这些特型作为参数类型的限界，因此可以直接将切片和字符串传给它们，即便它们真正想要的是其他类型。有关详细解释，请参阅 13.7 节。</li>\n<li>切片和字符串还实现了 <code>std::borrow::Borrow&lt;str&gt;</code> 特型。<code>HashMap</code> 和 <code>BTreeMap</code> 会借助 <code>Borrow</code> 令 <code>String</code> 很好地用作表中的键。有关详细信息，请参阅 13 .8 节。</li>\n</ul>\n<h3 id=\"nav_point_329\">17.3.14　以 UTF-8 格式访问文本</h3>\n<p>获取表示文本的那些字节有两个主要方法，具体取决于你是想获取字节的所有权还是只想借用它们。</p>\n<blockquote>\n<p><code>slice.as_bytes()</code>（用作字节切片）</p>\n</blockquote>\n<p>把 <code>slice</code> 的字节借入为 <code>&amp;[u8]</code>。由于这不是可变引用，因此 <code>slice</code> 可以假定其字节将保持为格式良好的 UTF-8。</p>\n<blockquote>\n<p><code>string.into_bytes()</code>（转为字节切片）</p>\n</blockquote>\n<p>获取 <code>string</code> 的所有权并按值返回字符串字节的 <code>Vec&lt;u8&gt;</code>。这是一个开销极低的转换，因为它只是移动了字符串一直用作缓冲区的 <code>Vec&lt;u8&gt;</code>。由于 <code>string</code> 已经不复存在，因此这些字节无须继续保持为格式良好的 UTF-8，而调用者可以随意修改 <code>Vec&lt;u8&gt;</code>。</p>\n<h3 id=\"nav_point_330\">17.3.15　从 UTF-8 数据生成文本</h3>\n<p>如果你有一个包含 UTF-8 数据的字节块，那么有几个方法可以将其转换为 <code>String</code> 或切片，但具体用哪个取决于你希望如何处理错误。</p>\n<blockquote>\n<p><code>str::from_utf8(byte_slice)</code>（来自 <code>utf8</code> 切片）</p>\n</blockquote>\n<p>接受 <code>&amp;[u8]</code> 字节切片并返回 <code>Result</code>：如果 <code>byte_slice</code> 包含格式良好的 UTF-8，就返回 <code>Ok(&amp;str)</code>，否则，返回错误。</p>\n<blockquote>\n<p><code>String::from_utf8(vec)</code>（来自 <code>utf8</code> 向量）</p>\n</blockquote>\n<p>尝试从按值传递的 <code>Vec&lt;u8&gt;</code> 中构造字符串。如果 <code>vec</code> 持有格式良好的 UTF-8，那么 <code>from_utf8</code> 就会返回 <code>Ok(string)</code>，其中 <code>string</code> 会取得 <code>vec</code> 的所有权并将其用作缓冲区。此过程不会发生堆分配或文本复制。</p>\n<p>如果这些字节不是有效的 UTF-8，则返回 <code>Err(e)</code>，其中 <code>e</code> 是 <code>FromUtf8Error</code> 型的错误值。调用 <code>e.into_bytes()</code> 会返回原始向量 <code>vec</code>，因此当转换失败时它并不会丢失：</p>\n<pre class=\"code-rows\"><code>let good_utf8: Vec&lt;u8&gt; = vec![0xe9, 0x8c, 0x86];\nassert_eq!(String::from_utf8(good_utf8).ok(), Some(\"錆\".to_string()));\n\nlet bad_utf8: Vec&lt;u8&gt; = vec![0x9f, 0xf0, 0xa6, 0x80];\nlet result = String::from_utf8(bad_utf8);\nassert!(result.is_err());\n// 由于String::from_utf8失败了，因此它不会消耗原始向量，\n// 而是通过错误值把原始向量原原本本地还给了我们\nassert_eq!(result.unwrap_err().into_bytes(),\n           vec![0x9f, 0xf0, 0xa6, 0x80]);</code></pre>\n<blockquote>\n<p><code>String::from_utf8_lossy(byte_slice)</code>（来自 <code>utf8</code>，宽松版）</p>\n</blockquote>\n<p>尝试从 <code>&amp;[u8]</code> 共享字节切片构造一个 <code>String</code> 或 <code>&amp;str</code>。此转换总会成功，任何格式错误的 UTF-8 都会被 Unicode 代用字符替换。返回值是一个 <code>Cow&lt;str&gt;</code>，如果它包含格式良好的 UTF-8，就会直接从 <code>byte_slice</code> 借用 <code>&amp;str</code>，否则会拥有一个新分配的 <code>String</code>，其中格式错误的字节会被代用字符替换。因此，当 <code>byte_slice</code> 是格式良好的 UTF-8 时，不会发生堆分配或复制。17.3.16 节会更详细地讨论 <code>Cow&lt;str&gt;</code>。</p>\n<blockquote>\n<p><code>String::from_utf8_unchecked(vec)</code>（来自 <code>utf8</code>，不检查版）</p>\n</blockquote>\n<p>如果你确信此 <code>Vec&lt;u8&gt;</code> 包含格式良好的 UTF-8，那就可以调用这个不安全的函数。此方法只是将 <code>vec</code> 包装为一个 <code>String</code> 并返回它，根本不检查字节。你有责任确保没有将格式错误的 UTF-8 引入系统，这就是此函数被标记为 <code>unsafe</code> 的原因。</p>\n<blockquote>\n<p><code>str::from_utf8_unchecked(byte_slice)</code>（来自 <code>utf8</code>，不检查版）</p>\n</blockquote>\n<p>与上一个方法类似，但此方法会接受 <code>&amp;[u8]</code> 并将其作为 <code>&amp;str</code> 返回，而不检查它是否包含格式良好的 UTF-8。与 <code>String::from_utf8_unchecked</code> 一样，你有责任确保 <code>byte_slice</code> 是安全的。</p>\n<h3 id=\"nav_point_331\">17.3.16　推迟分配</h3>\n<p>假设你想让程序向用户打招呼。在 Unix 上，可以这样写：</p>\n<pre class=\"code-rows\"><code>fn get_name() -&gt; String {\n    std::env::var(\"USER\") // 在Windows上要改成\"USERNAME\"\n        .unwrap_or(\"whoever you are\".to_string())\n}\n\nprintln!(\"Greetings, {}!\", get_name());</code></pre>\n<p>对于 Unix 用户，这个程序会根据用户名向他们问好。对于 Windows 用户和无名用户，它提供了备用文本。</p>\n<p><code>std::env::var</code> 函数会返回一个 <code>String</code>——并且有充分的理由这样做，所以我们不会在这里讨论。但这意味着备用文本也必须作为 <code>String</code> 返回。这不太理想：当 <code>get_name</code> 返回静态字符串时，根本没必要分配内存。</p>\n<p>问题的关键在于，<code>get_name</code> 的返回值有时应该是拥有型 <code>String</code>，有时则应该是 <code>&amp;'static str</code>，并且在运行程序之前我们无法知道会是哪一个。这种动态的特点预示着应该考虑使用 <code>std::borrow::Cow</code>，这个写入时克隆类型既可以持有拥有型数据也可以持有借入的数据。</p>\n<p>正如 13.12 节所述，<code>Cow&lt;'a, T&gt;</code> 是一个具有 <code>Owned</code> 和 <code>Borrowed</code> 两个变体的枚举。<code>Borrowed</code> 持有一个引用 <code>&amp;'a T</code>，而 <code>Owned</code> 持有 <code>&amp;T</code> 的拥有型版本：对于 <code>&amp;str</code> 是 <code>String</code>，对于 <code>&amp;[i32]</code> 是 <code>Vec&lt;i32&gt;</code>，等等。无论是 <code>Owned</code> 还是 <code>Borrowed</code>，<code>Cow&lt;'a, T&gt;</code> 总能生成一个 <code>&amp;T</code> 供你使用。事实上，<code>Cow&lt;'a, T&gt;</code> 可以解引用为 <code>&amp;T</code>，其行为类似于一种智能指针。</p>\n<p>更改 <code>get_name</code> 以返回 <code>Cow</code>，结果如下所示：</p>\n<pre class=\"code-rows\"><code>use std::borrow::Cow;\n\nfn get_name() -&gt; Cow&lt;'static, str&gt; {\n    std::env::var(\"USER\")\n        .map(|v| Cow::Owned(v))\n        .unwrap_or(Cow::Borrowed(\"whoever you are\"))\n}</code></pre>\n<p>如果读取 <code>\"USER\"</code> 环境变量成功，那么 <code>map</code> 就会将结果 <code>String</code> 作为 <code>Cow::Owned</code> 返回。如果失败，则 <code>unwrap_or</code> 会将其静态 <code>&amp;str</code> 作为 <code>Cow::Borrowed</code> 返回。调用者可以保持不变：</p>\n<pre class=\"code-rows\"><code>println!(\"Greetings, {}!\", get_name());</code></pre>\n<p>只要 <code>T</code> 实现了 <code>std::fmt::Display</code> 特型，显示 <code>Cow&lt;'a, T&gt;</code> 的结果就和显示 <code>T</code> 的结果是一样的。</p>\n<p>当你可能需要也可能不需要修改借用的某些文本时，<code>Cow</code> 也很有用。不需要修改时，可以继续借用。但是 <code>Cow</code> 名副其实的写入时克隆行为可以根据需要为你提供一个拥有型的、可变的值副本。<code>Cow</code> 的 <code>to_mut</code> 方法会确保 <code>Cow</code> 是 <code>Cow::Owned</code>，必要时会应用该值的 <code>ToOwned</code> 实现，然后返回对该值的可变引用。</p>\n<p>因此，如果你发现某些用户（但不是全部）拥有他们更想使用的头衔，就可以这样写：</p>\n<pre class=\"code-rows\"><code>fn get_title() -&gt; Option&lt;&amp;'static str&gt; { ... }\n\nlet mut name = get_name();\nif let Some(title) = get_title() {\n    name.to_mut().push_str(\", \");\n    name.to_mut().push_str(title);\n}\n\nprintln!(\"Greetings, {}!\", name);</code></pre>\n<p>这可能会生成如下输出：</p>\n<pre class=\"code-rows\"><code>$ cargo run\nGreetings, jimb, Esq.!\n$</code></pre>\n<p>这样做的好处是，如果 <code>get_name()</code> 返回一个静态字符串并且 <code>get_title</code> 返回 <code>None</code>，那么 <code>Cow</code> 只是将静态字符串透传到 <code>println!</code>。你已经设法把内存分配推迟到了确有必要的时候，并且代码仍然一目了然。</p>\n<p>由于 <code>Cow</code> 经常用于字符串，因此标准库对 <code>Cow&lt;'a, str&gt;</code> 有一些特殊支持。它提供了来自 <code>String</code> 和 <code>&amp;str</code> 的 <code>From</code> 和 <code>Into</code> 这两个转换特型，这样就可以更简洁地编写 <code>get_name</code> 了：</p>\n<pre class=\"code-rows\"><code>fn get_name() -&gt; Cow&lt;'static, str&gt; {\n    std::env::var(\"USER\")\n        .map(|v| v.into())\n        .unwrap_or(\"whoever you are\".into())\n}</code></pre>\n<p><code>Cow&lt;'a, str&gt;</code> 还实现了 <code>std::ops::Add</code> 和 <code>std::ops::AddAssign</code>，因此要将标题添加到名称中，可以这样写：</p>\n<pre class=\"code-rows\"><code>if let Some(title) = get_title() {\n    name += \", \";\n    name += title;\n}</code></pre>\n<p>或者，因为 <code>String</code> 可以作为 <code>write!</code> 宏的目标，所以也可以这样写：</p>\n<pre class=\"code-rows\"><code>use std::fmt::Write;\n\nif let Some(title) = get_title() {\n    write!(name.to_mut(), \", {}\", title).unwrap();\n}</code></pre>\n<p>和以前一样，在尝试修改 <code>Cow</code> 之前不会发生内存分配。</p>\n<p>请记住，并非每个 <code>Cow&lt;..., str&gt;</code> 都必须是 <code>'static</code>：可以使用 <code>Cow</code> 借用以前计算好的文本，直到需要复制为止。</p>\n<h3 id=\"nav_point_332\">17.3.17　把字符串当作泛型集合</h3>\n<p><code>String</code> 同时实现了 <code>std::default::Default</code> 和 <code>std::iter::Extend</code>：<code>default</code> 返回空字符串，而 <code>extend</code> 可以把字符、字符串切片、<code>Cow&lt;..., str&gt;</code> 或字符串追加到一个字符串尾部。这与 Rust 的其他集合类型（如 <code>Vec</code> 和 <code>HashMap</code>）为其泛型构造模式（如 <code>collect</code> 和 <code>partition</code>）实现的特型组合是一样的。</p>\n<p><code>&amp;str</code> 类型也实现了 <code>Default</code>，返回一个空切片。这在某些极端情况下很方便，比如，这样可以让包含字符串切片的结构派生于 <code>Default</code>（<code>#[derive(Default)</code>）。</p>\n","comments":[]}