{"id":14061,"title":"16 | 即时编译（上）","content":"<p>在专栏的第一篇中，我曾经简单地介绍过即时编译。这是一项用来提升应用程序运行效率的技术。通常而言，代码会先被Java虚拟机解释执行，之后反复执行的热点代码则会被即时编译成为机器码，直接运行在底层硬件之上。</p>\n<p>今天我们便来详细剖析一下Java虚拟机中的即时编译。</p>\n<h2>分层编译模式</h2>\n<p>HotSpot虚拟机包含多个即时编译器C1、C2和Graal。</p>\n<p>其中，Graal是一个实验性质的即时编译器，可以通过参数-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler启用，并且替换C2。</p>\n<p>在Java 7以前，我们需要根据程序的特性选择对应的即时编译器。对于执行时间较短的，或者对启动性能有要求的程序，我们采用编译效率较快的C1，对应参数-client。</p>\n<p>对于执行时间较长的，或者对峰值性能有要求的程序，我们采用生成代码执行效率较快的C2，对应参数-server。</p>\n<p>Java 7引入了分层编译（对应参数-XX:+TieredCompilation）的概念，综合了C1的启动性能优势和C2的峰值性能优势。</p>\n<p>分层编译将Java虚拟机的执行状态分为了五个层次。为了方便阐述，我用“C1代码”来指代由C1生成的机器码，“C2代码”来指代由C2生成的机器码。五个层级分别是：</p><!-- [[[read_end]]] -->\n<ol start=\"0\">\n<li>解释执行；</li>\n<li>执行不带profiling的C1代码；</li>\n<li>执行仅带方法调用次数以及循环回边执行次数profiling的C1代码；</li>\n<li>执行带所有profiling的C1代码；</li>\n<li>执行C2代码。</li>\n</ol>\n<p>通常情况下，C2代码的执行效率要比C1代码的高出30%以上。然而，对于C1代码的三种状态，按执行效率从高至低则是1层 &gt; 2层 &gt; 3层。</p>\n<p>其中1层的性能比2层的稍微高一些，而2层的性能又比3层高出30%。这是因为profiling越多，其额外的性能开销越大。</p>\n<p>这里解释一下，profiling是指在程序执行过程中，收集能够反映程序执行状态的数据。这里所收集的数据我们称之为程序的profile。</p>\n<p>你可能已经接触过许许多多的profiler，例如JDK附带的hprof。这些profiler大多通过注入（instrumentation）或者JVMTI事件来实现的。Java虚拟机也内置了profiling。我会在下一篇中具体介绍Java虚拟机的profiling都在做些什么。</p>\n<p>在5个层次的执行状态中，1层和4层为终止状态。当一个方法被终止状态编译过后，如果编译后的代码并没有失效，那么Java虚拟机是不会再次发出该方法的编译请求的。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/c5/e5/c503010c157b7db7596893633b624fe5.png?wh=1920*960\" alt=\"\" /><br />\n不同的编译路径，图片来源于我之前一篇<a href=\"https://zhengyudi.github.io/2018/03/20/graal-intro/\">介绍Graal的博客</a>。</p>\n<p>这里我列举了4个不同的编译路径（<a href=\"http://cr.openjdk.java.net/~iveresov/tiered/Tiered.pdf\">Igor的演讲</a>列举了更多的编译路径）。通常情况下，热点方法会被3层的C1编译，然后再被4层的C2编译。</p>\n<p>如果方法的字节码数目比较少（如getter/setter），而且3层的profiling没有可收集的数据。</p>\n<p>那么，Java虚拟机断定该方法对于C1代码和C2代码的执行效率相同。在这种情况下，Java虚拟机会在3层编译之后，直接选择用1层的C1编译。由于这是一个终止状态，因此Java虚拟机不会继续用4层的C2编译。</p>\n<p>在C1忙碌的情况下，Java虚拟机在解释执行过程中对程序进行profiling，而后直接由4层的C2编译。在C2忙碌的情况下，方法会被2层的C1编译，然后再被3层的C1编译，以减少方法在3层的执行时间。</p>\n<p>Java 8默认开启了分层编译。不管是开启还是关闭分层编译，原本用来选择即时编译器的参数-client和-server都是无效的。当关闭分层编译的情况下，Java虚拟机将直接采用C2。</p>\n<p>如果你希望只是用C1，那么你可以在打开分层编译的情况下使用参数-XX:TieredStopAtLevel=1。在这种情况下，Java虚拟机会在解释执行之后直接由1层的C1进行编译。</p>\n<h2>即时编译的触发</h2>\n<p>Java虚拟机是根据方法的调用次数以及循环回边的执行次数来触发即时编译的。前面提到，Java虚拟机在0层、2层和3层执行状态时进行profiling，其中就包含方法的调用次数和循环回边的执行次数。</p>\n<p>这里的循环回边是一个控制流图中的概念。在字节码中，我们可以简单理解为往回跳转的指令。（注意，这并不一定符合循环回边的定义。）</p>\n<pre><code>public static void foo(Object obj) {\n  int sum = 0;\n  for (int i = 0; i &lt; 200; i++) {\n    sum += i;\n  }\n}\n</code></pre>\n<p>举例来说，上面这段代码将被编译为下面的字节码。其中，偏移量为18的字节码将往回跳至偏移量为7的字节码中。在解释执行时，每当运行一次该指令，Java虚拟机便会将该方法的循环回边计数器加1。</p>\n<pre><code>public static void foo(java.lang.Object);\n  Code:\n     0: iconst_0\n     1: istore_1\n     2: iconst_0\n     3: istore_2\n     4: goto 14\n     7: iload_1\n     8: iload_2\n     9: iadd\n    10: istore_1\n    11: iinc 2, 1\n    14: iload_2\n    15: sipush 200\n    18: if_icmplt 7\n    21: return\n</code></pre>\n<p>在即时编译过程中，我们会识别循环的头部和尾部。在上面这段字节码中，循环的头部是偏移量为14的字节码，尾部为偏移量为11的字节码。</p>\n<p>循环尾部到循环头部的控制流边就是真正意义上的循环回边。也就是说，C1将在这个位置插入增加循环回边计数器的代码。</p>\n<p>解释执行和C1代码中增加循环回边计数器的位置并不相同，但这并不会对程序造成影响。</p>\n<p>实际上，Java虚拟机并不会对这些计数器进行同步操作，因此收集而来的执行次数也并非精确值。不管如何，即时编译的触发并不需要非常精确的数值。只要该数值足够大，就能说明对应的方法包含热点代码。</p>\n<p>具体来说，在不启用分层编译的情况下，当方法的调用次数和循环回边的次数的和，超过由参数-XX:CompileThreshold指定的阈值时（使用C1时，该值为1500；使用C2时，该值为10000），便会触发即时编译。</p>\n<p>当启用分层编译时，Java虚拟机将不再采用由参数-XX:CompileThreshold指定的阈值（该参数失效），而是使用另一套阈值系统。在这套系统中，阈值的大小是动态调整的。</p>\n<p>所谓的动态调整其实并不复杂：在比较阈值时，Java虚拟机会将阈值与某个系数s相乘。该系数与当前待编译的方法数目成正相关，与编译线程的数目成负相关。</p>\n<pre><code>系数的计算方法为：\ns = queue_size_X / (TierXLoadFeedback * compiler_count_X) + 1\n\n其中X是执行层次，可取3或者4；\nqueue_size_X是执行层次为X的待编译方法的数目；\nTierXLoadFeedback是预设好的参数，其中Tier3LoadFeedback为5，Tier4LoadFeedback为3；\ncompiler_count_X是层次X的编译线程数目。\n</code></pre>\n<p>在64位Java虚拟机中，默认情况下编译线程的总数目是根据处理器数量来调整的（对应参数-XX:+CICompilerCountPerCPU，默认为true；当通过参数-XX:+CICompilerCount=N强制设定总编译线程数目时，CICompilerCountPerCPU将被设置为false）。</p>\n<p>Java虚拟机会将这些编译线程按照1:2的比例分配给C1和C2（至少各为1个）。举个例子，对于一个四核机器来说，总的编译线程数目为3，其中包含一个C1编译线程和两个C2编译线程。</p>\n<pre><code>对于四核及以上的机器，总的编译线程的数目为：\nn = log2(N) * log2(log2(N)) * 3 / 2\n其中N为CPU核心数目。\n</code></pre>\n<p>当启用分层编译时，即时编译具体的触发条件如下。</p>\n<pre><code>当方法调用次数大于由参数-XX:TierXInvocationThreshold指定的阈值乘以系数，或者当方法调用次数大于由参数-XX:TierXMINInvocationThreshold指定的阈值乘以系数，并且方法调用次数和循环回边次数之和大于由参数-XX:TierXCompileThreshold指定的阈值乘以系数时，便会触发X层即时编译。\n\n触发条件为：\ni &gt; TierXInvocationThreshold * s || (i &gt; TierXMinInvocationThreshold * s  &amp;&amp; i + b &gt; TierXCompileThreshold * s)\n</code></pre>\n<p>其中i为调用次数，b为循环回边次数。</p>\n<h2>OSR编译</h2>\n<p>可以看到，决定一个方法是否为热点代码的因素有两个：方法的调用次数、循环回边的执行次数。即时编译便是根据这两个计数器的和来触发的。为什么Java虚拟机需要维护两个不同的计数器呢？</p>\n<p>实际上，除了以方法为单位的即时编译之外，Java虚拟机还存在着另一种以循环为单位的即时编译，叫做On-Stack-Replacement（OSR）编译。循环回边计数器便是用来触发这种类型的编译的。</p>\n<p>OSR实际上是一种技术，它指的是在程序执行过程中，动态地替换掉Java方法栈桢，从而使得程序能够在非方法入口处进行解释执行和编译后的代码之间的切换。事实上，去优化（deoptimization）采用的技术也可以称之为OSR。</p>\n<p>在不启用分层编译的情况下，触发OSR编译的阈值是由参数-XX:CompileThreshold指定的阈值的倍数。</p>\n<p>该倍数的计算方法为：</p>\n<pre><code>(OnStackReplacePercentage - InterpreterProfilePercentage)/100\n\n其中-XX:InterpreterProfilePercentage的默认值为33，当使用C1时-XX:OnStackReplacePercentage为933，当使用C2时为140。\n</code></pre>\n<p>也就是说，默认情况下，C1的OSR编译的阈值为13500，而C2的为10700。</p>\n<p>在启用分层编译的情况下，触发OSR编译的阈值则是由参数-XX:TierXBackEdgeThreshold指定的阈值乘以系数。</p>\n<p>OSR编译在正常的应用程序中并不多见。它只在基准测试时比较常见，因此并不需要过多了解。</p>\n<h2>总结与实践</h2>\n<p>今天我详细地介绍了Java虚拟机中的即时编译。</p>\n<p>从Java 8开始，Java虚拟机默认采用分层编译的方式。它将执行分为五个层次，分为为0层解释执行，1层执行没有profiling的C1代码，2层执行部分profiling的C1代码，3层执行全部profiling的C1代码，和4层执行C2代码。</p>\n<p>通常情况下，方法会首先被解释执行，然后被3层的C1编译，最后被4层的C2编译。</p>\n<p>即时编译是由方法调用计数器和循环回边计数器触发的。在使用分层编译的情况下，触发编译的阈值是根据当前待编译的方法数目动态调整的。</p>\n<p>OSR是一种能够在非方法入口处进行解释执行和编译后代码之间切换的技术。OSR编译可以用来解决单次调用方法包含热循环的性能优化问题。</p>\n<p>今天的实践环节，你可以使用参数-XX:+PrintCompilation来打印你项目中的即时编译情况。</p>\n<pre><code>     88   15       3       CompilationTest::foo (16 bytes)\n     88   16       3       java.lang.Integer::valueOf (32 bytes)\n     88   17       4       CompilationTest::foo (16 bytes)\n     88   18       4       java.lang.Integer::valueOf (32 bytes)\n     89   15       3       CompilationTest::foo (16 bytes)   made not entrant\n     89   16       3       java.lang.Integer::valueOf (32 bytes)   made not entrant\n     90   19 %     3       CompilationTest::main @ 5 (33 bytes)\n</code></pre>\n<p>简单解释一下该参数的输出：第一列是时间，第二列是Java虚拟机维护的编译ID。</p>\n<p>接下来是一系列标识，包括%（是否OSR编译），s（是否synchronized方法），！（是否包含异常处理器），b（是否阻塞了应用线程，可了解一下参数-Xbatch），n（是否为native方法）。再接下来则是编译层次，以及方法名。如果是OSR编译，那么方法名后面还会跟着@以及循环所在的字节码。</p>\n<p>当发生去优化时，你将看到之前出现过的编译，不过被标记了“made not entrant&quot;。它表示该方法不能再被进入。</p>\n<p>当Java虚拟机检测到所有的线程都退出该编译后的“made not entrant”时，会将该方法标记为“made zombie”，此时可以回收这块代码所占据的空间了。<br />\n</p>\n","comments":[{"had_liked":false,"id":22063,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1535468474,"is_pvip":false,"replies":[{"id":"8012","content":"2. 即时编译是以方法为单位的。动态编译比较耗时，如果花了大量CPU资源编译出来的机器码运行不了几次，就很浪费了。<br><br>3. 机器码越快，需要的编译时间就越长。分层编译是一种折衷的方式，既能够满足部分不那么热的代码能够在短时间内编译完成，也能满足很热的代码能够拥有最好的优化。","user_name":"作者回复","comment_id":22063,"uid":"1176688","ip_address":"","utype":1,"ctime":1535620687,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"203398931386","product_id":100010301,"comment_content":"有点费解，不过还好又明白了一些东西，小结如下：<br>1:即时编译-直接将Java字节码编译成机器码，运行在底层硬件之上，这么玩是为了提高代码的执行效率，通俗点就是能使代码跑的更快一些<br><br>2:即时编译的触发点是热点代码，即 即时编译仅针对热点代码来触发，热点代码是通过方法的调用次数或者回边循环的次数来标示的，这里也侧面反映出来即时编译是针对方法块的，有个疑问❓为什么不把所有代码都即时编译一下呢？这样程序的执行效率不是更快吗？为什么还分热点非热点呢？<br><br>3:分层编译的设计也有点奇怪，为什么要这样呢？使用最快的编译代码编译器编译的代码不是更好吗？<br><br>4:解释执行-将Java字节码一段一段的编译成机器码在底层硬件上运行，即时编译是一个相对解释执行而言的概念，它将热点代码先编译成机器码缓存起来，在解释执行字节码的时候判断出已经缓存起来了就不在编译直接获取执行就可以了","like_count":48,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422983,"discussion_content":"2. 即时编译是以方法为单位的。动态编译比较耗时，如果花了大量CPU资源编译出来的机器码运行不了几次，就很浪费了。\n\n3. 机器码越快，需要的编译时间就越长。分层编译是一种折衷的方式，既能够满足部分不那么热的代码能够在短时间内编译完成，也能满足很热的代码能够拥有最好的优化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535620687,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37291,"user_name":"槛外人","can_delete":false,"product_type":"c1","uid":1053058,"ip_address":"","ucode":"3F821FB998E63A","user_header":"https://static001.geekbang.org/account/avatar/00/10/11/82/ab3f0985.jpg","comment_is_top":false,"comment_ctime":1541519087,"is_pvip":false,"replies":[{"id":"14107","content":"其中一个原因是快速地收集profile，所以会用2 3层编译后的代码，既能够高效运行，也能够收集最终用来4层编译的profile","user_name":"作者回复","comment_id":37291,"uid":"1176688","ip_address":"","utype":1,"ctime":1542280080,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"31606290159","product_id":100010301,"comment_content":"为什么一块代码会被2层编译后还会被3、4层编译？不能某一层编译就完了吗？","like_count":7,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428281,"discussion_content":"其中一个原因是快速地收集profile，所以会用2 3层编译后的代码，既能够高效运行，也能够收集最终用来4层编译的profile","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542280080,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21783,"user_name":"泰格杨","can_delete":false,"product_type":"c1","uid":1182151,"ip_address":"","ucode":"DF23BD9D31B536","user_header":"https://static001.geekbang.org/account/avatar/00/12/09/c7/861b4a70.jpg","comment_is_top":false,"comment_ctime":1535333000,"is_pvip":false,"replies":[{"id":"7811","content":"就是从执行机器码切换回解释执行，下一篇会详细介绍。","user_name":"作者回复","comment_id":21783,"uid":"1176688","ip_address":"","utype":1,"ctime":1535357159,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"23010169480","product_id":100010301,"comment_content":"去优化是啥意思？","like_count":6,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422861,"discussion_content":"就是从执行机器码切换回解释执行，下一篇会详细介绍。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535357159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21903,"user_name":"杨春鹏","can_delete":false,"product_type":"c1","uid":1172056,"ip_address":"","ucode":"518F38232F97B5","user_header":"https://static001.geekbang.org/account/avatar/00/11/e2/58/8c8897c8.jpg","comment_is_top":false,"comment_ctime":1535411060,"is_pvip":false,"replies":[{"id":"7899","content":"确切地说，即时编译器将加载进VM中的类的某个方法所对应的byte数组编译为机器码。你也可以理解为从class文件到机器码。","user_name":"作者回复","comment_id":21903,"uid":"1176688","ip_address":"","utype":1,"ctime":1535465040,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"18715280244","product_id":100010301,"comment_content":"Java中的即时编译器，是不是重新将java代码编译成机器码，并没有使用class文件？","like_count":4,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422914,"discussion_content":"确切地说，即时编译器将加载进VM中的类的某个方法所对应的byte数组编译为机器码。你也可以理解为从class文件到机器码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535465040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21785,"user_name":"郑杰","can_delete":false,"product_type":"c1","uid":1014917,"ip_address":"","ucode":"789EAB2A08EBEF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7c/85/8b221758.jpg","comment_is_top":false,"comment_ctime":1535334539,"is_pvip":true,"replies":[{"id":"7812","content":"编译结果就是二进制码，下一篇有具体示例。解释执行遇到方法调用时，JVM会判断目标方法是否被编译。如果是，就跳转至编译好的二进制码中。","user_name":"作者回复","comment_id":21785,"uid":"1176688","ip_address":"","utype":1,"ctime":1535357323,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"18715203723","product_id":100010301,"comment_content":"能说下及时编译的结果是什么样的吗，然后他是怎么跟解释执行一起运行的","like_count":4,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422863,"discussion_content":"编译结果就是二进制码，下一篇有具体示例。解释执行遇到方法调用时，JVM会判断目标方法是否被编译。如果是，就跳转至编译好的二进制码中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535357323,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262664,"user_name":"LVM_23","can_delete":false,"product_type":"c1","uid":1039544,"ip_address":"","ucode":"5E54F9DB582E9F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/dc/b8/31c7e110.jpg","comment_is_top":false,"comment_ctime":1605797289,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14490699177","product_id":100010301,"comment_content":"有兴趣进来，懵逼出去","like_count":4},{"had_liked":false,"id":25176,"user_name":"Leon Wong","can_delete":false,"product_type":"c1","uid":1073650,"ip_address":"","ucode":"B49B327367CF9E","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/f2/ca989d6f.jpg","comment_is_top":false,"comment_ctime":1537262656,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14422164544","product_id":100010301,"comment_content":"小结一下：<br><br>分层编译的引入是为了让即时编译更具备灵性，使得虚拟机可以根据量化的实际情况以及相应的算法动态选择执行代码的编译路径。分层编译是否开启，决定了编译器的执行阈值是否动态化。<br><br>根据两种不同的计数器（方法调用计数器和循环回边的执行次数计数器），虚拟机有不同的考量，基于方法层面的优化，会使用方法调用计数器作为主要依据，而基于循环层面的，则使用循环回边计数器作为主要依据。<br><br>由此引入了OSR技术，即一种能够替换正在运行函数的栈帧的技术。其目的在于能让执行引擎能在不同的优化层次间来回切换，并以更细粒度（循环）的形式实现之。为了平衡启动性能与峰值性能，OSR可以实现低层次优化往高层次优化的迁移；为了去优化以及方便获取调试信息，OSR可以实现高层次优化往低层次迁移。","like_count":4},{"had_liked":false,"id":24619,"user_name":"Leon Wong","can_delete":false,"product_type":"c1","uid":1073650,"ip_address":"","ucode":"B49B327367CF9E","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/f2/ca989d6f.jpg","comment_is_top":false,"comment_ctime":1537168777,"is_pvip":false,"replies":[{"id":"9018","content":"对的，我原稿里是从0开始，可能MD语法给识别错了。","user_name":"作者回复","comment_id":24619,"uid":"1176688","ip_address":"","utype":1,"ctime":1537173882,"user_name_real":"郑雨迪"}],"discussion_count":4,"race_medal":0,"score":"14422070665","product_id":100010301,"comment_content":"有个小问题，1、4层是终止（接受）状态的前提是，您的五层应该从0开始，到4层结束，但是您现在1层开始，5层结束，那么终止状态应该是2层和5层。","like_count":3,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424062,"discussion_content":"对的，我原稿里是从0开始，可能MD语法给识别错了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537173882,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1137848,"avatar":"https://static001.geekbang.org/account/avatar/00/11/5c/b8/3ab6f76c.jpg","nickname":"yungyu16","note":"","ucode":"559E26EA491944","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":581826,"discussion_content":"错了不改吗？那里卡了我一晚上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659008643,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":424062,"ip_address":"北京"},"score":581826,"extra":""}]},{"author":{"id":1553046,"avatar":"https://static001.geekbang.org/account/avatar/00/17/b2/96/a524ebf6.jpg","nickname":"silas","note":"","ucode":"EEFF1E8ED00EE6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530636,"discussion_content":"真服了 前后不一致我还一直倒回去看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637114495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1023750,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9f/06/287d77dd.jpg","nickname":"承香墨影","note":"","ucode":"4D6A4D6E1ED29F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384766,"discussion_content":"错了你倒是改了啊，序号错了换层「第0层」「第1层」这种描述也好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626745410,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21831,"user_name":"大场镇车王","can_delete":false,"product_type":"c1","uid":1072876,"ip_address":"","ucode":"5113DC367D4291","user_header":"https://static001.geekbang.org/account/avatar/00/10/5e/ec/70c8d94d.jpg","comment_is_top":false,"comment_ctime":1535366409,"is_pvip":false,"replies":[{"id":"7900","content":"下篇会讲。主要有分支跳转指令的branch profile，和类型相关指令的type profile。","user_name":"作者回复","comment_id":21831,"uid":"1176688","ip_address":"","utype":1,"ctime":1535465091,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"14420268297","product_id":100010301,"comment_content":"请问带所有profiling是什么意思 所有是个什么概念","like_count":3,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422885,"discussion_content":"下篇会讲。主要有分支跳转指令的branch profile，和类型相关指令的type profile。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535465091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78978,"user_name":"未知","can_delete":false,"product_type":"c1","uid":1312918,"ip_address":"","ucode":"DB389CEBEEE9E1","user_header":"https://static001.geekbang.org/account/avatar/00/14/08/96/231fdd9e.jpg","comment_is_top":false,"comment_ctime":1553312628,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10143247220","product_id":100010301,"comment_content":"每次看都有收获。第三遍。","like_count":2},{"had_liked":false,"id":41775,"user_name":"逆流的鱼","can_delete":false,"product_type":"c1","uid":1258399,"ip_address":"","ucode":"AA3DDE44A83C40","user_header":"https://static001.geekbang.org/account/avatar/00/13/33/9f/8dbd9558.jpg","comment_is_top":false,"comment_ctime":1542850603,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10132785195","product_id":100010301,"comment_content":"疑问:即时编译之后的机器码和 native 方法是不是可以等同，这样是不是他俩都是占用jvm的内存和线程资源，而具体的Java程序只是持有机器码方法和native方法的引用，具体Java程序的线程调用时也是再委托给JVM 执行","like_count":2},{"had_liked":false,"id":21763,"user_name":"公号-技术夜未眠","can_delete":false,"product_type":"c1","uid":1013683,"ip_address":"","ucode":"83825B57CBD952","user_header":"https://static001.geekbang.org/account/avatar/00/0f/77/b3/991f3f9b.jpg","comment_is_top":false,"comment_ctime":1535328648,"is_pvip":true,"replies":[{"id":"7810","content":"一般都是方法级。<br><br>OSR编译会拿热循环作为编译对象。","user_name":"作者回复","comment_id":21763,"uid":"1176688","ip_address":"","utype":1,"ctime":1535357127,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"10125263240","product_id":100010301,"comment_content":"请问即时编译的对象是方法级还是语句块级？","like_count":2,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422849,"discussion_content":"一般都是方法级。\n\nOSR编译会拿热循环作为编译对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535357127,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":267576,"user_name":"Boomkeeper","can_delete":false,"product_type":"c1","uid":1437444,"ip_address":"","ucode":"129C4229D50EDD","user_header":"https://static001.geekbang.org/account/avatar/00/15/ef/04/f2942f14.jpg","comment_is_top":false,"comment_ctime":1607832480,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5902799776","product_id":100010301,"comment_content":"老师好，20年留言一个问题，请问在java中第二次执行方法返回比第一次快，原因是啥？和及时编译应该没关系吧？","like_count":1},{"had_liked":false,"id":34199,"user_name":"Geek_987169","can_delete":false,"product_type":"c1","uid":1180853,"ip_address":"","ucode":"4B2955A044805D","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/b5/8bc4790b.jpg","comment_is_top":false,"comment_ctime":1540040120,"is_pvip":false,"replies":[{"id":"12751","content":"这里的上下文是在讲编译层次吧？指的是到了1层或者4层之后，就不再就同一个方法触发新的编译请求，除非是OSR编译或者已被去优化","user_name":"作者回复","comment_id":34199,"uid":"1176688","ip_address":"","utype":1,"ctime":1540820106,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"5835007416","product_id":100010301,"comment_content":"老师，问下，中止状态是什么意思？","like_count":1,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427148,"discussion_content":"这里的上下文是在讲编译层次吧？指的是到了1层或者4层之后，就不再就同一个方法触发新的编译请求，除非是OSR编译或者已被去优化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540820106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":299164,"user_name":"慎独明强","can_delete":false,"product_type":"c1","uid":1965699,"ip_address":"","ucode":"DC2F7F2C0C8F60","user_header":"https://static001.geekbang.org/account/avatar/00/1d/fe/83/df562574.jpg","comment_is_top":false,"comment_ctime":1624498029,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624498029","product_id":100010301,"comment_content":"昨天线上出现了机器CPU飙高，通过dump文件查看有C2 相关的日志，组长问C2是什么知道吗？ 之前看过这一章节那时候看的不是很明白。再回过头看，明白了一些。jvm的静态编译和动态编译，静态编译即为解释执行，动态编译为将字节码文件翻译为机器码，以方法纬度，直接运行在底层硬件上，编译过程会比较耗CPU。结合线上问题，大量的接口调用，导致触发了C2编译","like_count":0},{"had_liked":false,"id":183217,"user_name":"小兵","can_delete":false,"product_type":"c1","uid":1261674,"ip_address":"","ucode":"AA3BA727C25179","user_header":"https://static001.geekbang.org/account/avatar/00/13/40/6a/ab1cf396.jpg","comment_is_top":false,"comment_ctime":1582975190,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582975190","product_id":100010301,"comment_content":"有点不理解的地方在于方法调用次数，这里是不是指的方法被调用的次数，回边次数指的应该时循环次数，可不可以认为方法每被调用一次回边次数就增加一倍。","like_count":0},{"had_liked":false,"id":152184,"user_name":"longslee","can_delete":false,"product_type":"c1","uid":1465986,"ip_address":"","ucode":"C24E32E5B1B6F5","user_header":"https://static001.geekbang.org/account/avatar/00/16/5e/82/438c8534.jpg","comment_is_top":false,"comment_ctime":1573904911,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573904911","product_id":100010301,"comment_content":"老师你好，请教个问题：有个同事写的程序本身占用JVM空间非常大，然后启动项 JAVA8 指定了 -server ，但是运行一段时间后，就会出现 “C2 编译器  什么空间不足，ReservedCodeCacheSize 什么什么”，按照提示调大以后还是会出现。","like_count":0},{"had_liked":false,"id":138180,"user_name":"leo","can_delete":false,"product_type":"c1","uid":1143202,"ip_address":"","ucode":"F89BB65F07277F","user_header":"https://static001.geekbang.org/account/avatar/00/11/71/a2/091d9619.jpg","comment_is_top":false,"comment_ctime":1570084910,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570084910","product_id":100010301,"comment_content":"解释执行后的机器码不会缓存吗，为什么之后还需要即时编译","like_count":0},{"had_liked":false,"id":128835,"user_name":"neohope","can_delete":false,"product_type":"c1","uid":1043475,"ip_address":"","ucode":"C0268F6E7E2B6E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","comment_is_top":false,"comment_ctime":1566971492,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566971492","product_id":100010301,"comment_content":"老师您好，在文章最后，我的理解是，从c1或c2到解释运行时，会有内存回收。<br>我想问下，当从c1升级到c2后，也会出现“made zombie”将c1代码回收的情况吗？<br>此外，是不是解释运行的代码，永远都不会被回收呢？<br>谢谢！","like_count":0},{"had_liked":false,"id":97975,"user_name":"Eric","can_delete":false,"product_type":"c1","uid":1140494,"ip_address":"","ucode":"8FFC6764ED327B","user_header":"https://static001.geekbang.org/account/avatar/00/11/67/0e/2a51a2df.jpg","comment_is_top":false,"comment_ctime":1558857636,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1558857636","product_id":100010301,"comment_content":"为什么执行效率1层大于2层，2层大于3层？？？","like_count":0,"discussions":[{"author":{"id":1182802,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0c/52/f25c3636.jpg","nickname":"长脖子树","note":"","ucode":"D9090EF67EEB1B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":276973,"discussion_content":"看文章不仔细呀, 一层没有 profile 的代码, 二层有部分 profile 代码, 三层带有全部 profile 的代码, 执行的越多当然越慢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590976675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84903,"user_name":"我已经设置了昵称","can_delete":false,"product_type":"c1","uid":1364034,"ip_address":"","ucode":"ED672C5EBDBDC4","user_header":"https://static001.geekbang.org/account/avatar/00/14/d0/42/6fd01fb9.jpg","comment_is_top":false,"comment_ctime":1554944250,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554944250","product_id":100010301,"comment_content":"还是有点不懂，即时编译是在程序运行的时候触发？解释编译是指我们普通的java文件被编译class文件的内容？","like_count":0},{"had_liked":false,"id":49836,"user_name":"哇！怎么这么大个","can_delete":false,"product_type":"c1","uid":1196856,"ip_address":"","ucode":"87106662D244C9","user_header":"https://static001.geekbang.org/account/avatar/00/12/43/38/72feb2e0.jpg","comment_is_top":false,"comment_ctime":1544777826,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544777826","product_id":100010301,"comment_content":"老师，-XX:+PrintCompilation看到的信息都是及时编译的结果吗，还是说包含了及时编译（C1 C2）和解释编译的结果，有没其他查看代码里即时编译的其他相关文档","like_count":0},{"had_liked":false,"id":29440,"user_name":"夜行观星","can_delete":false,"product_type":"c1","uid":1010389,"ip_address":"","ucode":"C880CB39033929","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6a/d5/73c75eb3.jpg","comment_is_top":false,"comment_ctime":1538374109,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538374109","product_id":100010301,"comment_content":"看了分层，还看封面，老师真的用心","like_count":0},{"had_liked":false,"id":27989,"user_name":"搬砖匠","can_delete":false,"product_type":"c1","uid":1214120,"ip_address":"","ucode":"3D2D7C1FD14DB6","user_header":"https://static001.geekbang.org/account/avatar/00/12/86/a8/427879a9.jpg","comment_is_top":false,"comment_ctime":1537973582,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1537973582","product_id":100010301,"comment_content":"请教两个问题：<br>1. 解释执行如果发现该方法还没有被编译，是否就是触发即时编译生成二进制码去执行？<br>2. 一个方法被即时编译成二进制码后，程序运行期间是否就可以无限循环利用之前编译的机器码去执行了，会有需要再重新编译的情况吗？","like_count":0},{"had_liked":false,"id":22269,"user_name":"Shine","can_delete":false,"product_type":"c1","uid":1022568,"ip_address":"","ucode":"C8C617B87C63C7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9a/68/92caeed6.jpg","comment_is_top":false,"comment_ctime":1535590069,"is_pvip":false,"replies":[{"id":"8003","content":"多谢指出！<br><br>解释执行是带profiling的。最开始列2 3层时明确标注带profiling，是为了区分1，2，3层。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1535618742,"ip_address":"","comment_id":22269,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1535590069","product_id":100010301,"comment_content":"”前面提到，Java 虚拟机在 0 层、2 层和 3 层执行状态时进行 profiling”<br>第0层是解释执行，前面没说带profiling啊？ 前面只列出第2，3层带profiling. 这里会不会笔误？","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423054,"discussion_content":"多谢指出！\n\n解释执行是带profiling的。最开始列2 3层时明确标注带profiling，是为了区分1，2，3层。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535618742,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":22016,"user_name":"Desire","can_delete":false,"product_type":"c1","uid":1138577,"ip_address":"","ucode":"7991CBB5EFD004","user_header":"https://static001.geekbang.org/account/avatar/00/11/5f/91/a9b51d4e.jpg","comment_is_top":false,"comment_ctime":1535444787,"is_pvip":false,"replies":[{"id":"7902","content":"是否包含异常处理器","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1535465316,"ip_address":"","comment_id":22016,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1535444787","product_id":100010301,"comment_content":"请问打印出！表示什么意思  n表示native","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422963,"discussion_content":"是否包含异常处理器","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535465316,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21940,"user_name":"魏春河","can_delete":false,"product_type":"c1","uid":1117048,"ip_address":"","ucode":"DDD2998C157639","user_header":"https://static001.geekbang.org/account/avatar/00/11/0b/78/22410c47.jpg","comment_is_top":false,"comment_ctime":1535417351,"is_pvip":false,"replies":[{"id":"7898","content":"15应该是反射调用从本地实现切换为动态实现吧。这里的1500是即时编译的。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1535464809,"ip_address":"","comment_id":21940,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1535417351","product_id":100010301,"comment_content":"我记得前面提到过CompileThreshold 默认是15，今天怎么成1500了？","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422930,"discussion_content":"15应该是反射调用从本地实现切换为动态实现吧。这里的1500是即时编译的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535464809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}