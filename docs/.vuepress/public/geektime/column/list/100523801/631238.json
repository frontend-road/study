{"id":631238,"title":"14｜Formatting：千呼万唤始出来的新format标准","content":"<p>你好，我是卢誉声。</p><p>在C++中，我们经常讨论一个看似简单的问题——<strong>如何实现格式化字符串和格式化输出？</strong></p><p>这个问题核心在于字符串格式化，考虑到C++向下兼容的问题，想做出一个能让大家满意的字符串格式化标准方案，其实并不容易。在过去的标准中，C++标准委员会一直通过各种修修补补，尝试提供一些格式化的辅助方案，但始终没有一个风格一致的标准化方案。</p><p>好在C++20及其后续演进中，终于出现了满足我们要求的格式化方案。因此，在这一讲中，我们就聚焦于讲解这个新的字符串格式化方案。</p><p>好，话不多说，就让我们开始今天的内容吧(课程配套代码可以从<a href=\"https://github.com/samblg/cpp20-plus-indepth\">这里</a>获取)。</p><h2>复杂的文本格式化方案</h2><p>首先，我们要弄明白什么是“文本格式化”。</p><p>下面一个常见的HTTP服务的日志输出，我们结合这个典型例子来讲解。</p><pre><code class=\"language-c++\">www&nbsp;&nbsp;&nbsp;&nbsp; | [2023-01-16T19:04:19] [INFO] 127.0.0.1 - \"GET /api/v1/info HTTP/1.0\" 200 6934 \"http://127.0.0.1/index.html\" \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:108.0) Gecko/20100101 Firefox/108.0\"\n</code></pre><!-- [[[read_end]]] --><p>可以看到，日志输出中包含了一些固定字符、需要根据实际情况替换的值。输出类似内容的这种需求就被称为“文本格式化”。</p><p>事实上，许多现代编程语言都提供了便利、安全的格式化方案。</p><p>但遗憾的是，在C++20以前虽然也有文本化格式方案，但都存在着这样那样的缺陷，而且不够现代化。</p><p>甚至就此出现了一些临时拼凑的方案，接下来，我们通过一个表格来回顾一下，在C++20以前的文本格式化方案。</p><p><img src=\"https://static001.geekbang.org/resource/image/1c/fb/1c811111c6bbf173673e8580c7b131fb.jpg?wh=3500x2460\" alt=\"\"></p><p>看完表格，你应该也发现了。在C++20出现以前，各种文本格式化方案都存在一些较为明显的缺点，无论是本身的安全性问题，还是编码层面的易用性方面。这导致了，C++开发者在选择文本格式化方案的时候难以抉择。</p><p>幸运的是，C++20终于提出了标准化的文本格式化方案——这就是Formatting库。</p><h2>Formatting</h2><p>Formatting库提供了类似于其他现代化编程语言的文本格式化接口，而且这些接口设计足够完美、便于使用。同时，它还提供了足够灵活的框架。因此，我们可以轻松地对其进行扩展，支持更多的数据类型与格式。</p><p>想要了解Formatting库，我们循序渐进。先从最基础的格式化函数format开始，其定义是后面这样。</p><pre><code class=\"language-c++\">template&lt;class... Args&gt;\nstd::string format(std::format_string&lt;Args...&gt; fmt, Args&amp;&amp;... args);\n</code></pre><p>该函数的第一个参数是格式化字符串，描述文本格式，后续参数就是需要被格式化的其他参数。</p><p>关于std::format_string&lt;Args…&gt;这个类型，我们在后面深入理解Formatting中再具体讨论，现在你只需要知道，这是用格式描述的字符串即可。</p><p>下面是使用format函数编写的日志输出代码。</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;format&gt;\n#include &lt;string&gt;\n#include &lt;cstdint&gt;\n#include &lt;chrono&gt;\n\n// 使用 std::chrono 来打印日志的时间\nusing TimePoint = std::chrono::time_point&lt;std::chrono::system_clock&gt;;\n\nstruct HttpLogParams {\n&nbsp;&nbsp;&nbsp; std::string user;\n&nbsp;&nbsp;&nbsp; TimePoint requestTime; // C++20 提供了chrono对format的支持\n&nbsp;&nbsp;&nbsp; std::string level;\n&nbsp;&nbsp;&nbsp; std::string ip;\n&nbsp;&nbsp;&nbsp; std::string method;\n&nbsp;&nbsp;&nbsp; std::string path;\n&nbsp;&nbsp;&nbsp; std::string httpVersion;\n&nbsp;&nbsp;&nbsp; int32_t statusCode;\n&nbsp;&nbsp;&nbsp; int32_t bodySize;\n&nbsp;&nbsp;&nbsp; std::string refer;\n&nbsp;&nbsp;&nbsp; std::string agent;\n};\n\nvoid formatOutputParams(const HttpLogParams&amp; params);\n\nint main() {\n&nbsp;&nbsp;&nbsp; HttpLogParams logParams = {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .user = \"www\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .requestTime = std::chrono::system_clock::now(),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .level = \"INFO\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .ip = \"127.0.0.1\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .method = \"GET\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .path = \"/api/v1/info\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .httpVersion = \"HTTP/1.0\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .statusCode = 200,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .bodySize = 6934,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .refer = \"http://127.0.0.1/index.hmtl\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .agent = \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:108.0) Gecko/20100101 Firefox/108.0\",\n&nbsp;&nbsp;&nbsp; };\n\n&nbsp;&nbsp;&nbsp; formatOutputParams(logParams);\n\n&nbsp;&nbsp;&nbsp; return 0;\n}\n\nvoid formatOutputParams(const HttpLogParams&amp; params) {\n&nbsp;&nbsp;&nbsp; std::string logLine = std::format(\"{0:&lt;16}|{1:%Y-%m-%d}T{1:%H:%M:%OS}Z {2} {3} - \\\"{4} {5} {6}\\\" {7} {8} \\\"{9}\\\" \\\"{10}\\\"\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; params.user,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; params.requestTime,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; params.level,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; params.ip,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; params.method,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; params.path,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; params.httpVersion,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; params.statusCode,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; params.bodySize,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; params.refer,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; params.agent\n&nbsp;&nbsp;&nbsp; );\n\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; logLine &lt;&lt; std::endl;\n}\n</code></pre><p>C++20在C++11的基础上，为chrono库提供了完善的format支持，我们再也不需要使用旧的C风格时间格式化函数了（见代码第12行）。</p><p>这里简单说明一下format的格式化字符串格式。格式化字符串由以下三类元素组成。</p><ul>\n<li>普通字符（除了 { 和 } 以外），这些字符会被直接拷贝到输出中，不会做任何更改。</li>\n<li>转义序列，包括 {{ 和 }}，在输出中分别会被替换成{和}。</li>\n<li>替换字段，由 { … } 构成，这些替换字段会替换成format后续参数中对应的参数，并根据格式控制描述生成输出。</li>\n</ul><p>对于替换字段的两种形式，你可以参考后面这张表格。</p><p><img src=\"https://static001.geekbang.org/resource/image/fb/bc/fbab4e74eaaeda085cf69b5d44yy85bc.jpg?wh=3500x1300\" alt=\"\"></p><p>如果你了解过Python，就会发现format函数的格式化字符串格式，其实类似于Python的格式化规范。不得不承认的是，C++20标准借鉴了相应的规范。</p><p>除了最简单的format参数，C++20还提供了三个有用的工具函数，作为扩展功能。</p><ol>\n<li>format_to</li>\n<li>format_to_n</li>\n<li>formatted_size</li>\n</ol><p>你可以参考下面的示例代码，来看看它们的具体用法。</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;format&gt;\n#include &lt;string&gt;\n\nint main() {\n    // format_to\n    // 将生成的文本输出到一个输出迭代器中，\n    // 其他与format一致，这样可以兼容标准STL算法函数的风格，\n    // 也便于将文本输出到其他的流中或者自建的字符串类中。\n&nbsp;&nbsp;&nbsp; std::string resultLine1;\n&nbsp;&nbsp;&nbsp; std::format_to(std::back_inserter(resultLine1), \"{} + {} = {}\", 1, 2, 1 + 2);\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; resultLine1 &lt;&lt; std::endl;\n\n    // format_to_n\n    // 将生成的文本输出到一个输出迭代器中，同时指定输出的最大字符数量。\n    // 其他与format一致，相当于format_to的扩展版本，\n    // 在输出目标有字符限制的时候非常有效。\n&nbsp;&nbsp;&nbsp; std::string resultLine2(5, ' ');\n&nbsp;&nbsp;&nbsp; std::format_to_n(resultLine2.begin(), 5, \"{} + {} = {}\", 1, 2, 1 + 2);\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; resultLine2 &lt;&lt; std::endl;\n\n    // formatted_sizes\n    // 获取生成文本的长度，参数与format完全一致。\n    // \n&nbsp;&nbsp;&nbsp; auto resultSize = std::formatted_size(\"{} + {} = {}\", 1, 2, 1 + 2);\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; resultSize &lt;&lt; std::endl;\n\n&nbsp;&nbsp;&nbsp; std::string resultLine3(resultSize, ' ');\n&nbsp;&nbsp;&nbsp; std::format_to(resultLine3.begin(), \"{} + {} = {}\", 1, 2, 1 + 2);\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; resultLine3 &lt;&lt; std::endl;\n}\n</code></pre><p>可以看出，这三个函数使用方法基本和format没有太大区别。</p><p>这里我们重点留意一下formatted_size。如果部分场景需要生成特定长度的输出缓冲区，那么我们就可以先通过formatted_size获取输出长度，然后分配特定长度缓冲区，最后再输出。除此以外，在只需要获取字符数量的场景中，也可以使用这个函数。</p><p>从上面案例可以看到，format函数的基本用法简单易懂。接下来，我们进一步讨论有关format的具体细节，先从格式化参数包开始。</p><h2>格式化参数包</h2><p>format函数，可以直接以函数参数形式进行传递。此外，C++20还提供了format_args相关接口，可以把“待格式化的参数”合并成一个集合，通过vformat函数进行文本格式化。</p><p>你可以结合后面的代码来理解。</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;format&gt;\n#include &lt;string&gt;\n#include &lt;cstdint&gt;\n\nint main() {\n&nbsp;&nbsp;&nbsp; std::string resultLine1 = std::vformat(\"{} * {} = {}\", std::make_format_args(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3, 4, 3 * 4\n&nbsp;&nbsp;&nbsp; ));\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; resultLine1 &lt;&lt; std::endl;\n\n&nbsp;&nbsp;&nbsp; std::format_args args = std::make_format_args(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3, 4, 3 * 4\n&nbsp;&nbsp;&nbsp; );\n\n&nbsp;&nbsp;&nbsp; std::string resultLine2;\n&nbsp;&nbsp;&nbsp; std::vformat_to(std::back_inserter(resultLine2), \"{} * {} = {}\", args);\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; resultLine2 &lt;&lt; std::endl;\n}\n</code></pre><p>针对上述代码中用到的类型和函数，我依次为你解释一下。</p><p><strong>第一，format_args类型</strong>，表示一个待格式化的参数集合，可以包装任意类型的待格式化参数。这里需要注意的是format_args中包装的参数是<strong>引用语义</strong>，也就是并不会拷贝或者扩展包装参数的生命周期，所以开发者需要确保被包装参数的生命周期。所以一般来说，format_args也就用于格式化函数的参数，不建议用于其他用途。</p><p><strong>第二，make_format_args函数</strong>，用于通过一系列参数构建一个format_args对象。类似地，需要注意返回的format_args的引用语义。</p><p><strong>第三，vformat函数</strong>。包含两个参数，分别是格式化字符串（具体规范与format函数完全一致）和format_args对象。该函数会根据格式化字符串定义去format_args对象中获取相关参数并进行格式化输出，其他与format函数没有差异。</p><p><strong>第四，vformat_to函数</strong>。该函数与format_to类似，都是通过一个输出迭代器进行输出的。差异在于，该函数接收的“待格式化参数”，需要通过format_args对象进行包装。因此，vformat可以在某些场景下替代format。至于具体使用哪个，你可以根据自己的喜好进行选择。</p><h2>深入理解Formatting</h2><p>在了解了Formatting的基本用法后，我们有必要深入Formatting的细节，了解如何基于Formatting库进行扩展，来满足我们的复杂业务需求。</p><p>首先，Formatting库的核心是formatter类，对于所有希望使用format进行格式化的参数类型来说，都需要按照约定实现formatter类的特化版本。</p><p>formatter类主要完成的工作就是：格式化字符串的解析、数据的实际格式化输出。C++20为基础类型与string类型定义了标准的formatter。此外，我们还可以通过特化的formatter来实现其他类型、自定义类型的格式化输出。</p><p>下面，我们先看一下标准formatter的格式化标准，然后在此基础上实现自定义formatter。</p><h3>标准格式化规范</h3><p>C++ Formatting的标准格式化规范，是以Python的格式化规范为基础的。基本语法是后面这样。</p><pre><code class=\"language-c++\">填充与对齐   符号   #   0   宽度   精度L   类型\n</code></pre><p>这里的每个参数<strong>都是可选参数</strong>，我们解释一下这些参数。</p><p>第一，填充与对齐，用于设置填充字符与对齐规则。</p><p>该参数包含两部分，第一部分为填充字符，如果没有设定，默认使用空格作为填充。第二部分为填充数量与对齐方式，填充数量就是指定输出的填充字符数量，对齐方式指的是待格式化参数输出时相对于填充字符的位置。</p><p>目前 C++ 支持三种对齐方式，你可以参考后面的表格。</p><p><img src=\"https://static001.geekbang.org/resource/image/ee/7e/ee887f2yy08a36b1fe2fe11a8b56a07e.jpg?wh=3176x1108\" alt=\"\"></p><h4></h4><p>第二，“符号” “#” 和“0”，用于设定数值类型的前缀显示方式。我们分别来看看。</p><p><strong>“符号”可以设置数字前缀的正负号显示规则。</strong>需要注意的是，“符号”也会影响inf和nan的显示方式。后面的表格包含了这三种情况。</p><p><img src=\"https://static001.geekbang.org/resource/image/d2/d6/d24728e02404f9bd2fafd91ac8cef7d6.jpg?wh=3184x1107\" alt=\"\"></p><p><strong>“#” 会对整数和浮点数有不同显示行为。</strong></p><p>如果被格式化参数为整数，并且将整数输出设定为二进制、八进制或十六进制时会在数字前添加进制前缀，也就是0b、0和0x。 如果被格式化参数为浮点数，那么即使浮点数没有小数位数，也会强制在数字后面追加一个小数点。</p><p><strong>“0” 用于为数值输出填充0，并支持设置填充位数。</strong>比如04就会填充4个0。</p><p>第三，宽度与精度。</p><p>宽度用于设置字段输出的最小宽度，可以使用一个十进制数，也可以通过 {} 引用一个参数。</p><p>精度是一个以 .符号开头的非负十进制数，也可以通过{}引用一个参数。对于浮点数，该字段可以设置小数点的显示位数。对于字符串，可以限制字符串的字符输出数量。</p><p>宽度与精度都支持通过 {} 引用参数，此时如果参数不是一个非负整数，在执行format时就会抛出异常。</p><p>第四，L与类型。</p><p>L用于指定参数以特定语言环境（locale）方式输出参数。如果感兴趣的话，你可以参考标准文档来查询有关语言环境的具体说明。参考标准文档足以涵盖语言环境的问题，因此不是我们讨论的重点。</p><p>类型选项用于设置参数的显示方式，我同样准备了表格，为你梳理了C++20支持的所有参数类型选项。</p><p><img src=\"https://static001.geekbang.org/resource/image/be/b7/be6eef92c193ac8339347fab8d2c16b7.jpg?wh=3435x4041\" alt=\"\"></p><h3>自定义formatter</h3><p>Formatting库中的formatter类型对各种类型的格式化输出毕竟是有限的——它不可能覆盖所有的场景，特别是我们的自定义类型。</p><p>因此，它也支持开发者对formatter进行特化，实现自定义的格式化输出。现在，让我们来看看如何自定义formatter。</p><p>我们先看一个最简单的自定义formatter案例。</p><p></p><pre><code class=\"language-c++\">#include &lt;format&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;cstdint&gt;\n&nbsp;\ntemplate&lt;class CharT&gt;\nstruct std::formatter&lt;std::vector&lt;int32_t&gt;, CharT&gt; : std::formatter&lt;int32_t, CharT&gt; {\n&nbsp;&nbsp;&nbsp; template&lt;class FormatContext&gt;\n&nbsp;&nbsp;&nbsp; auto format(std::vector&lt;int32_t&gt; t, FormatContext&amp; fc) const {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto it = std::formatter&lt;int32_t, CharT&gt;::format(t.size(), fc);\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int32_t v : t) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *it = ' ';\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; it++;\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; it = std::formatter&lt;int32_t, CharT&gt;::format(v, fc);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return it;\n&nbsp;&nbsp;&nbsp; }\n};\n&nbsp;\nint main() {\n&nbsp;&nbsp;&nbsp; std::vector&lt;int32_t&gt; v = { 1, 2, 3, 4 };\n&nbsp;\n    // 首先，调用format输出vector的长度，\n    // 然后遍历vector，每次输出一个空格后再调用format输出数字。\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::format(\"{:#x}\", v);\n}\n</code></pre><p>在这段代码中，实现了格式化显示vector&lt;int32_t&gt;类型的对象的功能。我们重点关注的是第7行实现的formatter特化——std::formatter&lt;std::vector&lt;int32_t&gt;, CharT&gt;。</p><p>其中，CharT表示字符类型，它可以根据用户的实际情况替换成char或者wchar_t等。</p><p>通过代码你会发现，我们重载了format成员函数，该函数用于控制格式化显示。该函数包含两个参数。</p><ol>\n<li>t: std::vector&lt;int32_t&gt;: 被传入的待格式化参数。</li>\n<li>fc: FormatContext&amp;: 描述格式化的上下文。</li>\n</ol><p>作为延伸阅读，你可以参考std::basic_format_context这个类型的定义，了解格式化的上下文中具体包含的信息。当然了，在编码过程中，IDE也会在使用它时给出提示。</p><p>format函数返回一个迭代器，表示下一个用于输出的位置，我们通过控制这个迭代器，就可以输出自己想要的格式化字符了。</p><p>示例没有实现parse来解析格式化字符串，如果你有兴趣的话，课后可以自行了解相关细节。</p><h2>总结</h2><p>传统的文本格式化方案包括基于C接口的格式化输出、C++字符串拼接或C++流这几种方式。它们各有优劣，但往往难以解决类型安全、缓冲区溢出、线程安全等问题。</p><p>C++20的推出改变了这一局面，我们可以利用Formatting库和formatter类型高度灵活地实现格式化文本输出。其中formatter支持特化，因此我们可以通过这个全新的方式，解决长久以来缺乏标准化的文本格式化的问题。</p><p>对于formatter的特化实现，我们记住两个重点即可。</p><ol>\n<li>重载format函数，实现输出自己想要的格式化文本。</li>\n<li>重载parse函数，实现自定义格式化文本解析。</li>\n</ol><h2>课后思考</h2><p>我们在这一讲中展示了如何通过重载formatter中的format函数，实现了自定义输出格式化文本。那么，你能否进一步拓展这一案例，通过重载parse来实现解析格式化字符串？</p><p>欢迎给出你的代码方案。我们一同交流。下一讲见！</p>","comments":[{"had_liked":false,"id":386667,"user_name":"李云龙","can_delete":false,"product_type":"c1","uid":3201926,"ip_address":"北京","ucode":"785924B16BE788","user_header":"https://static001.geekbang.org/account/avatar/00/30/db/86/51ec4c41.jpg","comment_is_top":false,"comment_ctime":1705307282,"is_pvip":false,"replies":[{"id":141127,"content":"可以在Visual Studio 2022中编译通过\n需要你提供一下具体的编译器类型和版本，我这里看一下相应的兼容性","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1706891113,"ip_address":"上海","comment_id":386667,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"请教老师一个问题，下面的代码编译不过，报错信息是无法推导 std::formatter的模版参数，这是什么原因呢？\n#include &lt;format&gt;\n#include &lt;iostream&gt;\n\n&#47;&#47; 非模板类\nstruct Box1 {\n\tbool bool_value;\n\tint int_value;\n\tconst char* str;\n};\ntemplate &lt;typename _CharT&gt;\nstruct std::formatter&lt;Box1, _CharT&gt; : std::formatter&lt;bool, _CharT&gt;\n{\t\n\ttemplate &lt;typename _FormatContext&gt;\n\ttypename _FormatContext::iterator format(const Box1&amp; v, _FormatContext&amp; format_context)\n\t{\t\n\t\ttypename _FormatContext::iterator Ite\n\t\t\t= std::formatter&lt;bool, _CharT&gt;::format(v.bool_value, format_context);\n\t\t\n\t\treturn Ite;\n\t}\n};\nint main()\n{\n\tBox1 box1{\n\t\t.bool_value = false,\n\t\t.int_value = 1,\n\t\t.str = &quot;box1&quot;\n\t};\n\tstd::cout &lt;&lt; std::format(&quot;box1 = {}&quot;, box1);\n\n\treturn 0;\n}","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636763,"discussion_content":"可以在Visual Studio 2022中编译通过\n需要你提供一下具体的编译器类型和版本，我这里看一下相应的兼容性","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1706891114,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":2,"child_discussions":[{"author":{"id":3201926,"avatar":"https://static001.geekbang.org/account/avatar/00/30/db/86/51ec4c41.jpg","nickname":"李云龙","note":"","ucode":"785924B16BE788","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":636925,"discussion_content":"老师您好，我的编译器是visual studio 2022 社区版：Microsoft Visual Studio Community 2022 (64 位) - Current\n版本 17.8.5\n操作系统是 Windows 11 家庭中文版 21H2 22000.2538\n处理器是 12th Gen Intel(R) Core(TM) i7-12700H   2.30 GHz","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1707270909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":636763,"ip_address":"北京","group_id":0},"score":636925,"extra":""},{"author":{"id":3201926,"avatar":"https://static001.geekbang.org/account/avatar/00/30/db/86/51ec4c41.jpg","nickname":"李云龙","note":"","ucode":"785924B16BE788","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":636926,"discussion_content":"在Visual Studio 2022编译时使用了 Debug x64。其他的Release 、x86的组合也不能编译通过，而且不同组合的编译报错信息也不一样。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1707271448,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":636763,"ip_address":"北京","group_id":0},"score":636926,"extra":""}]},{"author":{"id":3201926,"avatar":"https://static001.geekbang.org/account/avatar/00/30/db/86/51ec4c41.jpg","nickname":"李云龙","note":"","ucode":"785924B16BE788","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635856,"discussion_content":"详细的报错信息：\n错误\tC2338\tstatic_assert failed: &#39;Cannot format an argument. To make type T formattable, provide a formatter&lt;T&gt; specialization. See N4950 [format.arg.store]/2 and [formatter.requirements].&#39;\tForTest\tD:\\Program Files\\visual studio\\VC\\Tools\\MSVC\\14.38.33130\\include\\format\t3697\t\t\n错误\tC2672\t“std::_Format_arg_traits&lt;_Context&gt;::_Type_eraser”: 未找到匹配的重载函数\n        with\n        [\n            _Context=std::format_context\n        ]\tForTest\tD:\\Program Files\\visual studio\\VC\\Tools\\MSVC\\14.38.33130\\include\\format\t679\t\t\n错误\tC2993\t“unknown-type”: 不是非类型模板参数“_Test”的有效类型\tForTest\tD:\\Program Files\\visual studio\\VC\\Tools\\MSVC\\14.38.33130\\include\\format\t3490\t\t\n错误\tC2641\t无法推导“std::formatter”的模板参数\tForTest\tD:\\Program Files\\visual studio\\VC\\Tools\\MSVC\\14.38.33130\\include\\format\t3492\t\t\n错误\tC2783\t“std::formatter&lt;_Ty,_CharT&gt; std::formatter(void)”: 无法推导“_Ty”的 模板 参数\tForTest\tD:\\Program Files\\visual studio\\VC\\Tools\\MSVC\\14.38.33130\\include\\format\t3492\t\t\n错误\tC2780\t“std::formatter&lt;_Ty,_CharT&gt; std::formatter(std::formatter&lt;_Ty,_CharT&gt;)”: 应输入 1 个参数，却提供了 0 个\tForTest\tD:\\Program Files\\visual studio\\VC\\Tools\\MSVC\\14.38.33130\\include\\format\t3492\t\t\n错误\tC2039\t&#34;parse&#34;: 不是 &#34;std::formatter&#34; 的成员\tForTest\tD:\\Program Files\\visual studio\\VC\\Tools\\MSVC\\14.38.33130\\include\\format\t3493\t\t\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705307350,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":382782,"user_name":"常振华","can_delete":false,"product_type":"c1","uid":2062252,"ip_address":"广东","ucode":"D61B40E1CCEFD5","user_header":"","comment_is_top":false,"comment_ctime":1698048016,"is_pvip":false,"replies":[{"id":139476,"content":"C++在设计之初缺乏像现代编程语言那样的便捷工具，比如字符串格式化处理。这些工具在新标准下逐渐补完，也算是对现代潮流的一种跟进。同时，相较于使用各种第三方库或自己造轮子，使用标准下的工具更有利于跨平台兼容和系统移植。从这个角度上来说，补充这些工具是存在其意义的。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1698164800,"ip_address":"上海","comment_id":382782,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"说实话，越改约难用，C++越走越偏了。。。","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630215,"discussion_content":"C++在设计之初缺乏像现代编程语言那样的便捷工具，比如字符串格式化处理。这些工具在新标准下逐渐补完，也算是对现代潮流的一种跟进。同时，相较于使用各种第三方库或自己造轮子，使用标准下的工具更有利于跨平台兼容和系统移植。从这个角度上来说，补充这些工具是存在其意义的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698164800,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}