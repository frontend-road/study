[{"article_id":541281,"article_title":"开篇词｜练好基本功，优秀工程师成长第一步","article_content":"<p>你好，我是彭东，网名LMOS。很高兴在极客时间和你相遇，一起开启计算机基础的修炼之旅。</p><p>先来介绍一下我自己。我是 Intel 傲腾项目开发者之一，曾经为 Intel 做过内核层面的开发工作，也对 Linux、BSD、SunOS 等开源操作系统，还有 Windows 的 NT 内核很熟悉。</p><p>这十几年来，我一直专注于操作系统内核研发。先后开发了LMOS（基于x86_64的多进程支持SMP的操作系统）和LMOSEM（基于ARM32，支持软实时的嵌入式操作系统），还写过《深度探索嵌入式操作系统》一书。去年5月份，我在极客时间上更新了<a href=\"https://time.geekbang.org/column/intro/100078401\">《操作系统实战45讲》</a>这个专栏，和你分享了我多年来开发操作系统的方法和经验。</p><p>通过课程的互动交流，我发现很多同学因为基础知识并不扎实，所以学操作系统的时候非常吃力。而计算机的基础知识，不但对于深入理解操作系统有帮助，对我们工程师的技术提升也是一门长期收益的必修课。</p><h2>打牢计算机基础有什么用？</h2><p>就拿我的亲身经历来说，我既做过前端、后端的工作，也做过内核的开发。出现Bug和故障的时候，我总能快速理清排查思路，选用合适的工具、技术来分析问题，高效Debug；一个项目摆在我面前，迅速分析出项目的痛点、难点，整理出实现功能需要哪些技术框架也是驾轻就熟。</p><!-- [[[read_end]]] --><p>很多同事跟朋友对这样的能力心向往之，好奇我有什么“秘诀”。其实，能来回穿梭于底层与高层之间，不至于手忙脚乱，我最大的依仗就是深厚的计算机基础。</p><p>无论你是计算机初学者，还是已经工作了几年的老同学，对于“打牢基础很重要”、“基础不牢、地动山摇”这样的话，估计耳朵都要听得磨出茧子了。但到底计算机基础威力有多大呢？</p><p>举个例子，就像你编写你人生的第一个程序——Hello World。这个程序非常简单，同时也非常复杂，简单到你只要明白调用函数“printf(“Hello World\\n”);”，就能在屏幕上打印出Hello World的字符；难的是这个程序的背后细节，尽管这个程序不过数行代码，却需要芯片、编程语言、进程、内存、IO等多种基础设施的配合，才能完成看似简单的功能。</p><p>当然在写Hello World程序这个起步阶段，我们只要知道printf函数如何使用就行了，这是因为这程序简单到只是输出Hello World就结束了，不会给系统或者其它软件带来副作用。</p><p>但若是我们要开发大规模应用系统，如电商服务系统，问题就会变得复杂。比如：</p><p>1.这个服务应用要用什么语言来编写？<br>\n2.是采用单体进程，还是用多个进程来协同工作？<br>\n3.如何管理长期使用的内存空间？如何避免系统IO抖动？<br>\n4.如何处理网络带来的各种问题，比如通信拥堵、拒绝请求，甚至掉线？</p><p>这些问题，显然不是我们知道这些方面的几个接口函数就能解决的。发现没有？你可以用很短的时间跑起来一个Hello World，但想保障一个电商系统运转如常，感觉难度上是天壤之别。工程复杂度带来的差异，让我们不得不继续钻研，试着“理解”计算机。</p><p>我再说一个MySQL的例子：在往生产数据库中导入部分数据时，会造成客户端的访问超时。你可能怀疑这是MySQL自身问题，也可能怀疑是服务器系统的问题。其实两者都不是，此时即使你对MySQL的各种操作都了然于胸，还是对解决这类问题一头雾水。</p><p>如果你没能掌握文件系统、Cache、IO等基础的话，就很难想到用iotop、iostat等工具去查看IO操作，也就无从发现MySQL在导入数据时还会产生大量的日志，而这些日志也需要存盘引发大量IO操作，导致IO带宽爆满，造成访问超时。更不用说想到可以用MySQL的innodb_flush_log_at_trx_commit来控制MySQL的log行为了。</p><p>再比方说，如果你不知道操作系统与CPU、RAM等硬件的交互原理，就很难理解JVM为啥要抽象出堆、虚拟机栈和本地方法栈、程序计数器、方法区之类的概念来屏蔽硬件差异，更别说理解JVM、JUC中的内存管理、多线程安全的核心设计思想了。你看，写不出高并发、安全可靠程序的瓶颈，深究起来欠缺的竟然是底层基础知识。</p><p>除了复杂的软件工程问题，日新月异的前沿技术也离不开计算机基础的软硬件知识。</p><p>系统设计领域，只有研究过对CPU提供的SIMD指令集，才会联想到可以像ClickHouse一样基于向量化执行来提升计算速度；在云原生方面，只有熟知文件系统的系统调用和运作原理，才能设计出一款优质的分布式文件系统，或者设计出基于UnionFS的Docker 镜像机制，让容器真正发挥优势；AI领域同样如此，只有透彻理解了语言与指令、内存与应用，才有可能通过基础的软硬件技术配合优化存储层次，最终调优加速AI框架……</p><p>总之，<strong>想要成为优秀工程师，就需要你深入芯片、内存、语言、应用、IO与文件等这些基础组件学习研究</strong>，甚至还要钻研语言指令的运转，搞懂芯片尤其是CPU的机制原理。这些基础，不仅仅是对计算机本身很重要，对从事计算机的任何细分行业的每个人都很重要。</p><h2>计算机基础要怎么学？</h2><p>也许你跟我一样，不是计算机专业科班出身，所以起步时更加步履维艰。通常被后面这几类问题困扰：不确定学什么，不知道怎么学，硬记了概念不明白技术原理，更别说学以致用了。</p><p>这些问题让我们面对内容繁多的计算机知识时，不知如何下手，于是开始自我怀疑，总想打退堂鼓。从只会用C写个Hello World，到可以用C语言自研操作系统内核，我同样经历了漫长的修炼之旅。我也遇到过各种各样的问题，通过不断地学习和实践，才解决了诸多疑难杂症。</p><p>我希望把自己积累的大量计算机学习基础方法经验，通过这门课分享给你，帮你把计算机从底层到应用的关键知识点串联起来。除了学习原理概念、理顺知识点，动手实践的环节也不可或缺，配套的执行和调试代码，我之后都会放在<a href=\"https://gitee.com/lmos/Geek-time-computer-foundation\">Gitee</a>上方便你随堂练习。</p><p><img src=\"https://static001.geekbang.org/resource/image/59/38/59yyb4141c955dd13564a7ed03392538.jpg?wh=1920x1333\" alt=\"图片\"></p><p>这个专栏我是这样安排的：</p><p><strong>历史</strong></p><p>一个东西，从何而来，何至于此，这就是历史。学计算机基础，我们需要先学习它的历史，学习计算机是怎么一步步发展到今天这个样子的，再根据今天的状况推导出未来的发展方向。</p><p>我并不会长篇累牍地给你讲什么编年史，而是重点带你了解可编程架构是怎么创造出来的、CPU从何而来、CISC和RISC又各有什么优缺点。知道了这些，你就能理解为什么现在国家要提倡发展芯片产业，RISC-V为何会大行其道。</p><p><strong>芯片</strong></p><p>万丈高楼从地起，欲盖高楼先打地基。芯片是万世之基，这是所有软件基础的开始，执行软件程序的指令，运算并处理各种数据都离不开它。</p><p>因此，了解芯片的工作机制对写出优秀的应用软件非常重要。为了简单起见，我选择了最火热的RISCV芯片。这个模块里，我们将一起设计一个迷你RISCV处理器。哪怕未来你不从事芯片设计工作，了解芯片的工作机制，也对写出优秀的应用软件非常重要。</p><p><strong>环境</strong></p><p>学习讲究“眼到，手到，心到”，很多知识如果想牢牢掌握，就离不开动手实践。</p><p>而搭建好编译环境和执行环境就是实践的前提，方便后面的学习里我们去调试程序，验证理论。环境篇我们最终会跑出RISC-V平台的Hello World程序，作为这一关的阶段性成果。</p><p><strong>语言</strong></p><p>一个合格的程序员必须要掌握多种编程语言，这是开发应用软件的基础，所以我选择了最常用的C语言，以它为例让你理解高级语言是如何转换成低级的RISCV汇编语言的。</p><p>我不光会带你学习C语言各种类型的形成、语句与函数的关系，还会给你搭建一座理解C和汇编对应关系的桥梁。汇编语言方面，我会以RISC-V为例，介绍其算术指令、跳转指令、原子指令和访存指令，并带你学会调试这些指令，加深你对指令的理解。</p><p><strong>应用</strong></p><p>具备了编程语言的知识基础，我们就可以开发应用了。应用往往与内存分不开，我们一起来了解应用的舞台——内存地址空间，接着会引入物理内存、虚拟内存。理解了内存，理解进程也会手到擒来。</p><p>虚拟内存跟物理内存如何映射和转换？应用堆和栈内存有什么不同？应用内存是如何动态分配的？为什么操作系统中能并行运行多个不同或者相同的应用？多个应用之间如何通信？这些重难点问题，我们一个都不会漏掉。</p><p><strong>IO</strong></p><p>跟软件应用直接关联的，除了芯片和内存之外，就是IO即输入输出系统了。无论是交互式应用、还是数据密集型应用，都不得不接收各种数据的输入，然后执行相应计算和处理之后产生输出。</p><p>有的应用性能不佳，实时性不强，更有甚者丢失数据，面对这些令人头疼的问题，不懂IO就无法处理。我们想要开发高性能的应用程序，就不得不学习IO相关的基础知识了。因此，我们会重点学习IO的操作方式、IO调度、IO缓存Cache，以及Linux操作系统是如何管理IO设备的。我还会引入iotop和iostate工具，带你掌握怎么用它们来攻克应用的IO性能瓶颈。</p><p><strong>文件</strong></p><p>很少有应用不需要储存读写文件的，特别是各种网络应用和数据库应用，一个合格的开发者必须对文件了如指掌。</p><p>想要提升应用读写数据性能，做好数据加密（特别是优化网络数据库应用），深入了解文件和文件系统都是相当关键的。理清文件的基础知识点之后，我们还会研究一个Linux文件系统实例的内部细节，检验之前所学。</p><p><strong>综合应用</strong></p><p>经历了前面这些关卡，在综合应用篇里，我会带你了解如何从底层角度审视前端技术跟后端架构。优秀工程师通常具备超强的知识迁移能力，能够透过各种多变的技术表象，快速抓住技术的本质。这将是你未来拓展学习更多应用层技术，顺利解决日常业务里前后端性能问题的良好开端。</p><p><strong>技术雷达</strong></p><p>最后，我还设置了技术雷达的加餐内容，和你聊聊云计算、大数据跟智能制造。这些热门领域其实都是对基础技术的综合应用，有助于你开阔视野，给工作选择增加更多可能性。</p><p>这个加餐，我安排在正文结束之后的一个月和你见面（每周更新一节课，共五节课），这一个月留给你吸收消化前面所学内容的时间。</p><p>总之，在你学习更多应用层技术以前，通过这门课补充前置知识很有必要。这既是所有有志于成为高手的工程师绕不开的必修内容，同样也是我多年职业生涯里，通过技术修炼沉淀而来的“学习笔记”。</p><p>在我看来，<strong>一个人的自我学习能力和态度决定着技术成就，不然只会陷入CRUD Boy或者API Caller的圈子里，终日忙忙碌碌却依旧原地踏步。IT人就是要时刻保持学习，如果要给这个保持学习的习惯加个期限，那就是“终身”。</strong></p><p>期待你加入其中，我们一起进步，共同成长！<a href=\"https://time.geekbang.org/serv/v4/misc/jump?uri=https%3A%2F%2Ftime.geekbang.org%2Fhybrid%2Fmp%2Fjump%3Furl%3Dhttps%253A%252F%252Fstatic001.geekbang.org%252Fresource%252Fimage%252Fe2%252Fcb%252Fe2985bdfdfyy2ec96d024c33c2c666cb.png\">戳此加入课程交流群</a></p><p>可以自己立个 Flag，哪怕只是在留言区打卡你的学习天数、今日的问题或者收获，我相信都是会有效果的。3 个月后，我们再来一起验收。</p>","neighbors":{"left":[],"right":{"article_title":"01｜CISC & RISC：从何而来，何至于此","id":541289}}},{"article_id":541289,"article_title":"01｜CISC & RISC：从何而来，何至于此","article_content":"<p>你好，我是LMOS。</p><p>这个专栏我会带你学习计算机基础。什么是基础？</p><p>基础就是根，从哪里来，到哪里去。而学习计算机基础，首先就要把握它的历史，这样才能了解计算机是怎么一步步发展到今天这个样子的，再根据今天的状况推导出未来的发展方向。</p><p>正所谓读历史方知进退，明兴衰。人类比其它动物高级的原因，就是人类能使用和发现工具。<strong>从石器时代到青铜器时代，再到铁器时代，都是工具种类和材料的发展，推动了文明升级。</strong></p><p>让我们先从最古老的算盘开始聊起，接着了解一下机械计算机、图灵机和电子计算机。最后我会带你一起看看芯片的发展，尤其是它的两种设计结构——CISC与RISC。</p><h3>从算盘到机械计算机</h3><p>算盘就是一种辅助计算的工具，由中国古代劳动人民发明，迄今已有两千多年的历史，一直沿用至今。我准备了算盘的平面草图，你可以感受一下：</p><p><img src=\"https://static001.geekbang.org/resource/image/c7/d9/c7c942f024b13ce96e9443efa2c93bd9.jpg?wh=1920x795\" alt=\"图片\"></p><p>上图中周围一圈蓝色的是框架，一串一串的是算椽和算珠，一根算椽上有七颗算珠，可以上下拨动，从右至左有个、十、百……亿等计数位。有了算盘，计算的准确性和速度得到提高，我们从中可以感受到先辈的智慧。</p><p>与其说算盘是计算机，还不如说它是个数据寄存器。“程序”的执行需要人工实现，按口诀拨动算珠。过了两千多年，人们开始思考，能不能有一种机器，不需要人实时操作就能自动完成一些计算呢？</p><!-- [[[read_end]]] --><p>16世纪，苏格兰人John Napier发表了论文，提到他发明了一种精巧设备，可以进行四则运算和解决方根运算。之后到了18世纪，英国人Babbage设计了一台通用分析机。这期间还出现了计算尺等机械计算设备，主要是利用轴、杠杆、齿轮等机械部件来做计算。</p><p>尤其是Babbage设计的分析机，设计理论非常超前，既有保存1000个50位数的“齿轮式储存室”，用于运算的“运算室”，还有发送和读取数据的部件以及负责在“存储室”、“运算室”运算运输数据的部件。具体的构思细节，你有兴趣可以自行搜索资料探索。</p><p>一个多世纪之后，现代电脑的结构几乎是Babbage分析机的翻版，无非是主要部件替换成了大规模集成电路。仅此一点，Babbage作为计算机系统设计的“开山鼻祖”，就当之无愧。</p><p>值得一提的是，Babbage设计分析机的过程里，遇到了一位得力女助手——Ada。虽说两人的故事无从考证，但Ada的功劳值得铭记，她是为分析机编写程序（计算三角函数的程序、伯努利函数程序等）的第一人，也是公认的世界上第一位软件工程师。</p><p>又过了一个世纪，据说美国国防部花了十年光阴，才把开发军事产品所需的全部软件功能，都归纳整理到了一种计算机语言上，期待它成为军方千种计算机的标准。1981年，这种语言被正式命名为ADA语言。</p><p>可惜的是，这种分析机需要非常高的机械工程制造技术，后来政府停止了对他们的支持。尽管二人后来贫困潦倒，Ada也在36岁就英年早逝，但这两个人的思想和为计算机发展作出的贡献，足以彪炳史册，流芳百世。</p><h3>图灵机</h3><p>机械计算机有很多缺点，比如难于制造，难于维护，计算速度太慢，理论不成熟等。这些难题导致用机械计算机做通用计算的话，并不可取。</p><p>而真正奠定现代通用计算机理论的人，在20世纪初横空出世，他就是图灵，图灵奖就是用他名字命名的。</p><p>图灵在计算可行性和人工智能领域贡献卓越，最重要的就是提出了图灵机。</p><p>图灵机的概念是怎么来的呢？图灵在他的《论可计算数及其在判定问题中的应用》一文中，全面分析了人的计算过程。<strong>他把计算提炼成最简单、基本、确定的动作，然后提出了一种简单的方法，用来描述机械性的计算程序，让任何程序都能对应上这些动作。</strong></p><p>该方法以一个抽象自动机概念为基础，不但定义了什么“计算”，还首次将计算和自动机联系起来。这对后世影响巨大，而这种“自动机”后来就被我们称为“<strong>图灵机</strong>”。</p><p>图灵机是一个抽象的自动机数学模型，它是这样运转的：<strong>有一条无限长的纸带，纸带上有无限个小格子，小格子中写有相关的信息。纸带上有一个读头，读头能根据纸带小格子里的信息做相关的操作，并且能来回移动。</strong></p><p>如果你感觉文字叙述还不够形象，我再来画一幅示意图：</p><p><img src=\"https://static001.geekbang.org/resource/image/51/7b/51b1c0668bc479c53d7c382e27b5b27b.jpg?wh=1920x819\" alt=\"图片\"></p><p>我们不妨想象一下，把自己写的一条条代码，放入上图纸带的格子中，随着读头的读取代码做相应的动作。读头移动到哪一个，就会读取哪一格的代码，然后执行相应的顺序、跳转、循环动作，完成相应计算工作。</p><p>如果我们把读头及读头的运行规则理解为CPU，把纸带解释为内存，把纸带上信息理解为程序和数据，那这个模型就非常接近现代计算机了。在我看来，以最简单的方法抽象出统一的计算模型，这就是图灵的伟大之处。</p><h3>电子计算机</h3><p>图灵机这种美好的抽象模型，如果没有好的实施方案，是做不出实际产品的，这将是一个巨大的遗憾。为此，人类进行了多次探索，可惜都没有结果。最后还是要感谢弗莱明和福雷斯特，尽管他们一个是英国人，一个是美国人。</p><p>这两个人本来没什么交集，不过后来福雷斯特在弗莱明的真空二极管里，加上了一个电极（一种栅栏式的金属网，形成电子管的第三个极），就获得了可以放大电流的新器件，他把这个新器件命名为三极管，也叫真空三极管。这个三极管提高了弗莱明的真空二极管的检波灵敏度。</p><p>不过，一个三极管虽然做不了计算机，但是许多个三极管组合起来形成的数字电路，就能够实现布尔代数中的逻辑运算，电子计算机的大门自此打开。</p><p>1946年，ENIAC成功研制，它诞生于美国宾夕法尼亚大学，是世界上第一台真正意义上的电子计算机。</p><p>ENIAC占地面积约170平方米，估计你在城里的房子也放不下这台机器。它有多达30个操作台，重达30吨，耗电量150千瓦。</p><p>别说屋子里放不下，电费咱们也花不起。这台机器包含了17468根电子管和7200根晶体二极管，1500个继电器，6000多个开关等许多其它电子元件，计算速度是每秒5000次加法或者400次乘法，大约是人工计算速度的20万倍。</p><p>但是三极管也不是完美的，因为三极管的内部封装在一个抽成真空的玻璃管中，这种方案在当时是非常高级的，但是仍然不可靠，用不了多久就会坏掉了。电子计算机一般用一万多根三极管，坏了其中一根，查找和维护都极为困难。</p><p>直到1947年12月，美国贝尔实验室的肖克利、巴丁和布拉顿组成的研究小组，研制出了晶体管，问题才得以解决。现在我们常说的晶体管通常指的是晶体三极管。</p><p>晶体三极管跟真空三极管功能一样，不过制造材料是半导体。它的特点在于响应速度快，准确性高，稳定性好，不易损坏。关键它可以做得非常小，一块集成电路即可容纳十几亿到几十亿个晶体管。</p><p>这样的器件用来做计算机就是天生的好材料。可以说，晶体管是后来几十年电子计算机飞速发展的基础。没有晶体管，我们简直不敢想像，计算机能做成今天这个样子。具体是如何做的呢？我们接着往下看。</p><h3>芯片</h3><p>让我们加点速，迈入芯片时代。我们不要一提到芯片，就只想到CPU。</p><p>CPU确实也是芯片中的一种，但芯片是所有半导体元器件的统称，它是把一定数量的常用电子元件（如电阻、电容、晶体管等），以及这些元件之间的连线，通过半导体工艺集成在一起的、具有特定功能的电路。你也可以把芯片想成集成电路。</p><p>那芯片是如何实现集成功能的呢？</p><p>20世纪60年代，人们把硅提纯，切成硅片。想实现具备一定功能的电路，离不开晶体管、电阻、电容等元件及它们之间的连接导线，把这些集成到硅片上，再经过测试、封装，就成了最终的产品——芯片。相关的制造工艺（氧化、光刻、粒子注入等）极其复杂，是人类的制造极限。</p><p>正因为出现了集成电路，原先占地广、重量大的庞然大物才能集成于“方寸之间”。而且性能高出数万倍，功耗缩小数千倍。随着制造工艺的升级，现在指甲大小的晶片上集成数十亿个晶体管，甚至在一块晶片上集成了CPU、GPU、NPU和内部总线等，每秒钟可进行上10万亿次操作。在集成电路发展初期，这样的这样的性能是不可想像的。</p><p>下面我们看看芯片中的特例——CPU，它里面包括了控制部件和运算部件，即中央处理器。1971年，Intel将运算器和控制器集成在一个芯片上，称为4004微处理器，这标志着CPU的诞生。到了1978年，开发的8086处理器奠定了X86指令集架构。此后，8086系列处理器被广泛应用于个人计算机以及高性能服务器中。</p><p>那CPU是怎样运行的呢？<strong>CPU的工作流程分为以下 5 个阶段：取指令、指令译码、执行指令、访存读取数据和结果写回。</strong>指令和数据统一存储在内存中，数据与指令需要从统一的存储空间中存取，经由共同的总线传输，无法并行读取数据和指令。这就是大名鼎鼎的冯诺依曼体系结构。</p><p>CPU运行程序会循环执行上述五个阶段，它既是程序指令的执行者，又被程序中相关的指令所驱动，最后实现了相关的计算功能。这些功能再组合成相应算法，然后由多种算法共同实现功能强大的软件。</p><p>既然CPU的工作离不开指令，指令集架构就显得尤其重要了。</p><h3>CISC</h3><p>从前面的内容中，我们已经得知CPU就是不断地执行指令，来实现程序的执行，最后实现相应的功能。但是一颗CPU能实现多少条指令，每条指令完成多少功能，却是值得细细考量的问题。</p><p>显然，<strong>CPU的指令集越丰富、每个指令完成的功能越多，为该CPU编写程序就越容易，因为每一项简单或复杂的任务都有一条对应的指令，不需要软件开发人员写大量的指令。这就是复杂指令集计算机体系结构——CISC。</strong></p><p>CISC的典型代表就是x86体系架构，x86 CPU中包含大量复杂指令集，比如串操作指令、循环控制指令、进程任务切换指令等，还有一些数据传输指令和数据运算指令，它们包含了丰富的内存寻址操作。</p><p>有了这些指令，工程师们编写汇编程序的工作量大大降低。<strong>CISC的优势在于，用少量的指令就能实现非常多的功能，程序自身大小也会下降，减少内存空间的占用。但凡事有利就有弊，这些复杂指令集，包含的指令数量多而且功能复杂。</strong></p><p>而想实现这些复杂指令，离不开CPU运算单元和控制单元的电路，硬件工程师要想设计制造这样的电路，难度非常高。</p><p>到了20世纪80年代，各种高级编程语言的出现，大大简化了程序的开发难度。</p><p>高级语言编写的代码所对应的语言编译器，很容易就能编译生成对应的CPU指令，而且它们生成的多条简单指令，跟原先CISC里复杂指令完成的功能等价。因此，那些功能多样的复杂指令光环逐渐黯淡。</p><p>说到这里，你应该也发现了，在CPU发展初期，CISC体系设计是合理的，设计大量功能复杂的指令是为了降低程序员的开发难度。因为那个时代，开发软件只能用汇编或者机器语言，这等同于用硬件电路设计帮了软件工程师的忙。</p><p>随着软硬件技术的进步，CISC的局限越来越突出，因此开始出现了与CISC相反的设计。是什么设计呢？我们继续往下看。</p><h3>RISC</h3><p>每个时代都有每个时代的产物。</p><p><strong>20世纪80年代，编译器技术的发展，导致各种高级编程语言盛行。这些高级语言编译器生成的低级代码，比程序员手写的低级代码高效得多，使用的也是常用的几十条指令。</strong></p><p>前面我说过，文明的发展离不开工具的种类与材料升级。指令集的发展，我们也可以照这个思路推演。芯片生产工艺升级之后，人们在CPU上可以实现高速缓存、指令预取、分支预测、指令流水线等部件。</p><p>不过，这些部件的加入引发了新问题，那些一次完成多个功能的复杂指令，执行的时候就变得捉襟见肘，困难重重。</p><p>比如，一些串操作指令同时依赖多个寄存器和内存寻址，这导致分支预测和指令流水线无法工作。另外，当时在IBM工作的John Cocke也发现，计算机80%的工作由大约20%的CPU指令来完成，这代表CISC里剩下的80%的指令都没有发挥应有的作用。</p><p>这些最终导致人们开始向CISC的反方向思考，由此产生了RISC——精简指令集计算机体系结构。</p><p><strong>正如它的名字一样，RISC设计方案非常简约，通常有20多条指令的简化指令集。每条指令长度固定，由专用的加载和储存指令用于访问内存，减少了内存寻址方式，大多数运算指令只能访问操作寄存器。</strong></p><p><strong>而CPU中配有大量的寄存器，这些指令选取的都是工程中使用频率最高的指令。由于指令长度一致，功能单一，操作依赖于寄存器，这些特性使得CPU指令预取、分支预测、指令流水线等部件的效能大大发挥，几乎一个时钟周期能执行多条指令。</strong></p><p>这对CPU架构的设计和功能部件的实现也很友好。虽然完成某个功能要编写更多的指令，程序的大小也会适当增加，更占用内存。但是有了高级编程语言，再加上内存容量的扩充，这些已经不是问题。</p><p>RISC的代表产品是ARM和RISC-V。其实到了现在，RISC与CISC早已没有明显界限，开始互相融合了，比如ARM中加入越来越多的指令，x86 CPU通过译码器把一条指令翻译成多条内部微码，相当于精简指令。x86这种外CISC内RISC的选择，正好说明了这一点。</p><p>历史的车轮滚滚向前，留下的都是经典，历史也因此多彩而厚重，今天的课程就到这里了，我们要相信，即便自己不能改写历史，也能在历史上留下点什么。我们下一节课见，下次，我想继续跟你聊聊芯片行业的新贵RISC-V。</p><h3>重点回顾</h3><p>今天我们一起完成了一次“穿越之旅”，从最早的算盘、机械计算机，现代计算机雏形的图灵机，一路讲到芯片和CPU的两种指令架构集。</p><p>其实仅仅一节课的时间，很难把计算机的历史一一道来，所以我选择了那些对计算机产生和演进最关键的事件或者技术，讲给你听。我把今天的重点内容为你梳理了一张思维导图。</p><p><img src=\"https://static001.geekbang.org/resource/image/ac/66/ac779948df1c646cca16a2c1556fdf66.jpg?wh=2286x1572\" alt=\"\"><br>\n有了这些线索，你就能在脑海里大致勾勒出，计算机是如何一步步变成今天的样子。技术发展的“接力棒”现在传到了我们这代人手里，我对未来的发展充满了期待。</p><p>就拿CPU的发展来说，我觉得未来的CPU可能是多种不同指令集的整合，一个CPU指令能执行多类型的指令，分别完成不同的功能。不同类型的指令由不同的CPU功能组件来执行，有的功能组件执行数字信号分析指令，有的功能组件执行图形加速指令，有的功能组件执行神经网络推算指令……</p><h3>思考题</h3><p>为什么RISC的CPU能同时执行多条指令？</p><p>欢迎你在留言区跟我交流互动，如果觉得这节课讲得不错，也推荐你分享给身边的朋友。</p>","neighbors":{"left":{"article_title":"开篇词｜练好基本功，优秀工程师成长第一步","id":541281},"right":{"article_title":"02｜RISC特性与发展：RISC-V凭什么成为“半导体行业的Linux”？","id":541776}}},{"article_id":541776,"article_title":"02｜RISC特性与发展：RISC-V凭什么成为“半导体行业的Linux”？","article_content":"<p>你好，我是LMOS。</p><p>上节课，我带你见证了两种计算机指令集的设计结构——CISC与RISC。而今天我们的“主角”就是RISC中的一个代表性特例，它就是RISC-V。</p><p>作为未来芯片指令集的主流，RISC-V是今后芯片设计的最佳方案，甚至可以说它就是硬件行业里的Linux。</p><p>为什么这么说呢？这节课，我会从RISC-V发展历史、原理与技术特性几个方面入手，带你弄明白为什么RISC-V在半导体行业中发展得如此迅猛。</p><h3>RISC-V从何而来</h3><p>让我们“穿越时空”，把时间线拉回到2010年。在加州伯克利分校的校园中，Krste Asanovic教授正为了学生们学习计算机架构而发愁。由于现存芯片指令集冗余且专利许可费用昂贵，还有很多IP法律问题，没有一款合适的CPU用于学习。</p><p>于是他想要带领一个研究团队，来设计一款用于学生学习的CPU。研究团队在选择架构的时候，对比了传统已经存在的ARM、MIPS、SPARC以及x86架构等，发现这些架构指令集要么极其复杂，要么极其昂贵。所以，他们的研究团队最终决定设计一套全新的指令集。</p><p>这个研究团队最开始只有4个人，却在三个月之内完成了指令集原型开发，其能力可见一斑。后来，这个项目被计算机体系结构方面的泰斗 David Patterson 发现，并且得到了他的大力支持。</p><!-- [[[read_end]]] --><p>早在1981年，伯克利分校已经设计出了第一代RISC指令集，之后又陆续设计了四代RISC指令集的架构。有了这些设计经验，在设计RISC-V指令集架构时，研究团队就变得驾轻就熟。</p><p>用RISC-V来命名该指令集架构，有两层意思：RISC-V中的“V”，一方面代表第5代RISC；另一方面，“V”取“ Variation”之意，代表变化。</p><p>虽然RISC-V在2010年才开始研发，但在第二年（2011年）就进行了首次流片，流片就是按照芯片设计生产出可以工作的芯片成品。从这以后，基于RISC-V的CPU设计，或者在SOC中集成RISC-V架构，各种软件工具链的开发和各种基于RISC-V架构的操作系统移植，在不断涌现。这给CPU整个行业带来了不小轰动，当然，这也离不开泰斗 David Patterson 的号召作用。</p><p>一个产品的成功，技术当然是非常重要的原因，但也需要非常给力的运营。在2015年，由最初的25个成员一起成立了非盈利性组织RISC-V基金会（RISC-V Foundation）。</p><p>之后，有多达300个单位加入RISC-V基金会，其中包括阿里、谷歌、华为、英伟达、高通、麻省理工学院、普林斯顿大学、印度理工学院、中科院计算所、联发科等。这些学术机构、芯片开发公司、设计服务与系统厂商的加入，为RISC-V的发展建立了良好的生态环境。</p><h3>RISC-V是什么</h3><p>通过上节课，我们知道了RISC就是指精简指令集计算机体系结构。而前面也说了，RISC-V是伯克利分校设计出的第五代RISC指令集架构。但既然迅速走红的是RISC-V，相比其他的RISC，它必然有过人之处，这样才能立足于市场，不然很可能只沦为学生们的学习工具。</p><p>如果只是对RISC-V下一个定义，会相当简单：<strong>RISC-V是一套开放许可证书、免费的、由基金会维护的、一个整数运算指令集外加多个扩展指令集的CPU架构规范。</strong></p><p>任何硬件开发商或者相关组织都可以免费使用这套规范，构建CPU芯片产品。如果我们的目的只是想对RISC-V有个概念了解，前面这些信息就足够了。不过想知道RISC-V为什么流行这个秘密，显然我们还需要更详细的信息，才能深入了解。</p><h4>指令集命名方式</h4><p>现在假定我们是一家芯片公司的芯片工程师，公司有了新的业务，对CPU提出了更高的要求，让我们基于RISCV指令集架构实现一款全新的CPU。根据我们公司的业务场景，我们只需要选择RISC-V架构中的一部分指令，CPU的位宽也有特定的要求。</p><p>因此，现在需要一些命名方式，来对我们选择的RISCV架构进行命名。这样，用户在阅读该CPU文档时，马上就能了解这款CPU是多少位的、有哪些指令集，它们具体有什么功能。</p><p>其实这个命名方式在RISC-V规范中有相关定义说明，以RV为前缀，然后是位宽，最后是代表指令集的字母集合，具体形式如下：</p><pre><code class=\"language-plain\">RV[###][abc……xyz]\n</code></pre><p>我用表格为你说明一下这个格式，如下所示：<img src=\"https://static001.geekbang.org/resource/image/fe/3e/fedceecb22936111a74227f7b3dc273e.jpg?wh=1920x810\" alt=\"图片\"></p><p>举个例子，比如：RV64IMAC，就表示64位的RISC-V，支持整数指令、乘除法指令、原子指令和压缩指令。</p><h4>指令集模块</h4><p>接着我们一起来看看指令集模块。指令集是一款CPU架构的主要组成部分，是CPU和上层软件交互的核心，也是CPU主要功能的体现。</p><p>但RISC-V规范只定义了CPU需要包含基础整形操作指令，如整型的储存、加载、加减、逻辑、移位、分支等。其它的指令称为可选指令或者用户扩展指令，比如乘、除、取模、单精度浮点、双精度浮点、压缩、原子指令等，这些都是扩展指令。扩展指令需要芯片工程师结合功能需求自定义。</p><p>所以RISC-V采用的是模块化的指令集，易于扩展、组装。它适应于不同的应用场景，可以降低CPU的实现成本。</p><p>我给你列了一张图，图里展示的是RISC-V 指令集的各个组成部分。</p><p><img src=\"https://static001.geekbang.org/resource/image/32/05/325yy6b15697abae97c145f3135af005.jpg?wh=1920x1414\" alt=\"图片\"></p><p>RISC-V的基本指令集和扩展指令集你有个大致印象就可以，更详细的技术讲解，后面第五节课我再展开。下面我们去看看RISC-V的寄存器。</p><h4>RISC-V寄存器</h4><p>指令的操作数是来源于寄存器，精简指令集架构的CPU，都会提供大量的寄存器，RISC-V当然也不例外。RISC-V 的规范定义了32个通用寄存器以及一个 PC寄存器，这对于RV32I、RV64I、RV128I指令集都是一样的，只是寄存器位宽不一样。</p><p>如果实现支持 F/D 扩展指令集的CPU，则需要额外支持 32个浮点寄存器。而如果实现只支持RV32E指令集的嵌入式CPU，则可以将32个通用寄存器缩减为16个通用寄存器。  <img src=\"https://static001.geekbang.org/resource/image/29/6b/29b1fcdeeaecffb0b86499066c3d9b6b.jpg?wh=1920x1097\" alt=\"图片\"></p><p>为了帮助你聚焦要点，不常用的32个浮点寄存器并没有列在这张表里。表中的ABI名称，即应用程序二进制接口，你可以理解为寄存器别名，高级语言在生成汇编语言的时候会用到它们。</p><p>比如C语言处理函数调用时，用哪些寄存器传递参数、返回值，调用者应该保护哪些寄存器，用什么寄存器管理栈帧等等。</p><p>定义好ABI标准，我们就能在语言间互相调用函数了。比如C语言函数调用汇编语言函数，这里我先卖个关子，后面语言与指令的篇章再给你详细展开。</p><h4>RISC-V特权级</h4><p>研究完了RISC-V寄存器，我们再来看看RISC-V的特权级。不同的特权级能访问的系统资源不同，高特权级能访问低特权级的资源，反之则不行。RISC-V 的规范文档定义了四个特权级别（privilege level），特权等级由高到低排列，如下表所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/6c/6c/6cb32d65dddb4742ea1229c3d3a28a6c.jpg?wh=3432x1350\" alt=\"\"></p><p>一个RISC-V硬件线程（hart），相当于一个CPU内的独立的可执行核心，在任一时刻，只能运行在某一个特权级上，这个特权级由CSR（控制和状态寄存器）指定和配置。</p><p>具体分级如下：</p><p>1.机器特权级（M）：RISC-V中hart可以执行的最高权限模式。在M模式下运行的hart，对内存、I/O和一些必要的底层功能（启动和系统配置）有着完全的控制权。因此，它是唯一一个所有标准RISC-V CPU都必须实现的权限级。实际上，普通的RISC-V微控制器仅支持机器特权级。</p><p>2.虚拟机监视特权级（H）：为了支持虚拟机监视器而定义的特权级。</p><p>3.管理员特权级（S）：主要用于支持现代操作系统，如Linux、FreeBSD和Windows。</p><p>4.用户应用特权级（U）：用于运行应用程序，同样也适用于嵌入式系统。</p><p>好了，关于RISC-V的特权级，你了解这些，在现阶段已经足够了。需要把握的重点是，特权级起到了怎样的作用。</p><p><strong>有了特权级的存在，就给指令加上了权力，从而去控制用指令编写的程序。应用程序只能干应用程序该干的事情，不能越权操作。操作系统则拥有更高的权力，能对系统的资源进行管理。</strong></p><h3>RISC-V因何流行</h3><p>RISC-V指令集架构在2010年才开发出来，到今天不过10多年的时间。这个时间从CPU行业的发展看，是非常短的，也可以说是非常年轻的。相比x86的40多岁的年纪，还有ARM、MIPS、SPARC的30多的年纪，RISC-V简直是个孩子。</p><p>要知道ARM、MIPS、SPARC都是RISC系的，MIPS和SPARC甚至已经进入了死亡阶段。按道理讲，RISC-V不应该在这么短的时间内流行起来，成为芯片行业一颗耀眼的新星。</p><p>那么RISC-V流行起来，肯定有其优势：<strong>一是RISC-V完全开放，二是RISC-V指令简单，三是RISC-V实行模块化设计，易于扩展。</strong></p><p>我们先来看看为什么说RISC-V是开放的。之前硬件和软件一样，都是小心地保护自己的“源代码”，因为那是自己的命脉。</p><p>直到后来，软件界出现了开源的Linux，一经开源就迅速席卷了全球。在今天的互联网、云计算、手机等领域Linux已经无处不在。但是硬件依然保护着自己的“源代码”，Intel和AMD还是以售卖x86芯片为主，而ARM直接售卖ARM CPU的“源代码”，连生产芯片的步骤都省了。</p><p>这种模式下，无论厂商还是个人，要获得CPU都要付出昂贵的代价。这时RISC-V应运而生，它完全毫无保留地开放了CPU设计标准，任何人都可以使用该标准，自由地设计生产CPU，不需要支付任何费用，也没有任何法律问题。这相当于硬件界的“Linux”，推动了开放硬件的运动和发展。</p><p>然后，我们来看看为什么说RISC-V很简单？RISC-V提供了一个非常强大且开放的精简指令集架构，只有32个通用寄存器、40多条常用指令、4个特权级。如果需要其它功能，则要进行指令集的扩展，单核心的规范文档才不到300页，一个人在一周之内就能搞清楚。</p><p>相比ARM、x86动不动就有8000多页的规范文档，这实在是太简单了。其实，简单也意味着可靠和高效，同时可以让学生或者硬件开发者迅速入手，降低学习和开发成本。</p><p>最后，我们来说说RISC-V的模块化设计。RISC-V虽然简单，但这并不意味着功能的缺失。通过模块化的设计，就能实现对各种功能组件的剪裁和扩展。</p><p>事实上，现代IT架构已经发生了巨大的改变。举几个我们身边的例子吧。你正在使用的网卡，上面越来越多的网络处理任务和功能，都从主处理器上移到了网卡中，由网卡芯片自己来处理了。</p><p>数据处理器 (DPU) 也体现了这一点。由于通用处理器对大规模数据处理能力的限制，所以我们需要专用的数据处理器。而人工智能领域，现在也已经开始通过GPU运行相关算法。</p><p>这些例子都在告诉我们，专用处理器芯片的需求在大量激增，而这正是RISC-V的用武之地。RISC-V的标准开放，指令功能模块可以自由组合，所以用RISC-V就能定制一款满足特殊用途的处理器。芯片工程师会自由组合RISC-V现有的指令功能模块，按需对齐进行修改优化，或者实现一个新的指令功能模块，就像你根据需要修改和使用Linux内核一样。</p><p>正是因为RISC-V开放、简单和模块化这三大特点，硬件工程师和软件工程师才能站在巨人的肩膀上开发，自由地调用和组装功能模块，快速去实现特定业务场景下的芯片需求。因此，才有了RISC-V引爆芯片行业，迅速火热起来的现象，这是推动开放硬件的革命性壮举。</p><h3>重点回顾</h3><p>今天的课程又到了尾声，我们还是来看一下，在这节课中，我们都学习了什么。</p><p>首先，我们了解了RISC-V从何而来，明白了RISC-V发源于加州伯克利分校，是该校第五代RISC指令集，即第五代精简指令集。起初是为了学生有一套用来学习研究的指令集。后来因为有技术泰斗David Patterson的加入，又成立RISC-V基金会，RISC-V慢慢流行了起来。</p><p>之后我们研究了RISC-V是什么，我带你了解了RISC-V指令集的命名方式、组成模块、寄存器与特权级。这些部分共同组成了RISC-V指令集架构规范。任何硬件厂商都可以按照这个规范，实现自己的RISC-V处理器。</p><p>最后，我们讨论了RISC-V因何流行。RISC-V是开放的，没有任何法律和许可证问题，又极其简单，指令集是模块化的，易于剪裁和扩展。这种开放、简单、易于扩展的特点，使得硬件工程师非常容易上手和定制满足特定功能需要的处理器，这直接推动了开放硬件的革命。</p><p>课程里的重点内容，我整理成了导图，供你参考。</p><p><img src=\"https://static001.geekbang.org/resource/image/92/a2/92fa1a8227f77b74898ccab17386f1a2.jpg?wh=1920x1755\" alt=\"图片\"></p><h3>思考题</h3><p>为什么RISC-V要定义特权级？</p><p>欢迎你在留言区跟我交流互动，如果觉得内容还不错，也推荐你把这节课分享给更多朋友。下节课我们就进入手写miniCPU的部分，敬请期待！</p>","neighbors":{"left":{"article_title":"01｜CISC & RISC：从何而来，何至于此","id":541289},"right":{"article_title":"03｜硬件语言筑基（一）：从硬件语言开启手写CPU之旅","id":543867}}},{"article_id":543867,"article_title":"03｜硬件语言筑基（一）：从硬件语言开启手写CPU之旅","article_content":"<p>你好，我是LMOS。</p><p>我们都知道，自己国家的芯片行业被美国“吊打”这件事了吧？尤其是像高端CPU这样的芯片。看到相关的报道，真有一种恨铁不成钢的感觉。你是否也有过想亲自动手设计一个CPU的冲动呢？</p><p>万丈高楼从地起，欲盖高楼先打地基，芯片是万世之基，这是所有软件基础的开始，这个模块我会带你一起设计一个迷你RISC-V处理器（为了简单起见，我选择了最火热的RISCV芯片）。哪怕未来你不从事芯片设计工作，了解芯片的工作机制，也对写出优秀的应用软件非常重要。</p><p>这个处理器大致是什么样子呢？我们将使用Verilog硬件描述语言，基于RV32I指令集，设计一个32位五级流水线的处理器核。该处理器核包括指令提取单元、指令译码单元、整型执行单元、访问存储器和写回结果等单元模块，支持运行大多数RV32I的基础指令。最后，我们还会编写一些简单汇编代码，放在设计出来的处理器上运行。</p><p>我会通过两节课的篇幅，带你快速入门Verilog，为后续设计迷你CPU做好准备。这节课我们先来学习硬件描述语言基础，芯片内部的数字电路设计正是由硬件语言完成的。</p><h2>一个芯片的内部电路是怎么样的？</h2><p>作为开发，你日常最常用的编程语言是什么？也许是C语言、Java、Go、PHP……这些高级编译语言吧。而硬件设计领域里，也有专门的硬件描述语言。为什么会出现专门的硬件描述语言呢？这还要先从芯片的内部结构说起。</p><!-- [[[read_end]]] --><p>一般情况下，你所接触到的处理器芯片，已经不是传统意义上的CPU了，比如在业界很有名的国产手机芯片华为麒麟990芯片。我把麒麟990的功能模块图贴在了后面，对照图片会更直观。这样一款芯片，包含了CPU核、高速缓存、NPU、GPU、DDR、PMU等模块。</p><p><img src=\"https://static001.geekbang.org/resource/image/eb/8e/eb8c273e7020fb22cf6e337aae7da28e.png?wh=742x495\" alt=\"图片\"></p><p>而在芯片设计时，根据不同模块的功能特点，通常把它们分为数字电路模块和模拟电路模块。</p><p>模拟电路还是像早期的半导体电路那样，处理的是连续变化的模拟信号，所以只能用传统的电路设计方法。而数字电路处理的是已经量化的数字信号，往往用来实现特定的逻辑功能，更容易被抽象化，所以就产生了专门用于设计数字电路的硬件描述语言。</p><p>硬件描述语言从发明到现在，已经有20多年历史。硬件描述语言可以让你更直观地去理解数字电路的逻辑关系，从而更方便地去设计数字电路。</p><p>现在业界的 IEEE标准主要有VHDL和Verilog HDL 这两种硬件描述语言。在高层次数字系统设计领域，大部分公司都采用 Verilog HDL完成设计，我们后面的实现也会用到Verilog。</p><p>千里之行，始于足下。在Verilog学习之前，我们需要先完成思路转换，也就是帮你解决这个问题：写软件代码和写硬件代码的最大区别是什么？搞明白了这个问题，你才能更好地领会Verilog语言的设计思想。</p><p>Verilog代码和C语言、Java等这些计算机编程语言有本质的不同，<strong>在可综合（这里的“可综合”和代码“编译”的意思差不多）的Verilog代码里，基本所有写出来的东西都对应着实际的电路</strong>。</p><p>所以，我们用Verilog的时候，必须理解每条语句实质上对应着什么电路，并且要从<strong>电路的角度</strong>来思考它为何要这样设计。而高级编程语言通常只要功能实现就行。</p><p>我再举几个例子来说明：声明变量的时候，如果指定是一个reg，那么这个变量就有寄存数值的功能，可以综合出来一个实际的寄存器；如果指定是一段wire，那么它就只能传递数据，只是表示一条线。在Verilog里写一个判断语句，可能就对应了一个MUX（数据选择器），写一个for可能就是把一段电路重复好几遍。</p><p>最能体现电路设计思想的就是always块了，它可以指定某一个信号在某个值或某个跳变的时候，执行块里的代码。通过使用Verilog语言，我们就能完成芯片的数字电路设计工作了。没错，芯片前端设计工程师写Verilog代码的目的，就是<strong>把一份电路用代码的形式表示出来，然后由计算机把代码转换为所对应的逻辑电路</strong>。</p><h2>芯片如何设计？</h2><p>说到这里你可能还有疑惑，听起来芯片设计也没那么复杂啊？其实这事儿说起来简单，但实践起来却相当复杂。接下来，我就说说，一个工业级的芯片在设计阶段大致会怎么规划。</p><p>在开始一个大的芯片设计时，往往需要先从整个芯片系统做好规划，在写具体的Verilog代码之前，把系统划分成几个大的基本的功能模块。之后，每个功能模块再按一定的规则，划分出下一个层次的基本单元。</p><p>这和Verilog语言的module模块化设计思想是一致的，上一层模块对下一层子模块进行例化，就像其他编程语言的函数调用一样。根据包含的子功能模块一直例化下去，最终就能形成hierarchy结构。</p><p>这种自顶向下的设计方法，可以用后面的树状结构图来表示：</p><p><img src=\"https://static001.geekbang.org/resource/image/3c/3b/3c36d7832261f4cc35d4c142c17ddd3b.jpg?wh=1920x1026\" alt=\"图片\"></p><p>从上图我们也可以看出，Verilog都是基于模块进行编写的，一个模块实现一个基本功能，大部分的Verilog逻辑语句都放在模块内部。</p><h2>从一段代码入门Verilog</h2><p>说完语言思路和硬件的模块化设计，接下来，我带你学习一下Verilog的基本模块和逻辑语句是怎么写的。</p><p>很多Verilog初学者刚开始都是从一些基础知识慢慢去看，比如基本语法、数据类型、赋值语句、条件语句……总想着把Verilog的全部基础知识看完了，再开始动手写代码。</p><p>但是你有没有想过，这些详细的基础知识，一两天自然是看不完的。而当你坚持了一段时间把它看完，以为可以上手写代码的时候，又会发现前面的基本语句全都忘了。这样的学习方法并不可取，效果也不好，所以我换个方法带你入门。我们先不去罗列各种详细的基础知识，而是从学习一段代码开始。</p><p>我会以一个4位十进制计数器模块为例，让你对Verilog模块代码有更直观的认识，然后根据这段代码模块，给你讲讲Verilog语言基础。这里先把完整代码列出来，后面再详细拆解。</p><pre><code class=\"language-verilog\">module counter(\n&nbsp; //端口定义\n&nbsp; input&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;reset_n,&nbsp; //复位端，低有效\n&nbsp; input&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;clk,&nbsp; &nbsp;\t&nbsp; //输入时钟\n&nbsp; output [3:0]&nbsp; \t&nbsp; &nbsp; &nbsp; &nbsp; cnt,&nbsp; &nbsp; &nbsp; //计数输出\n&nbsp; output&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cout\t&nbsp; &nbsp;//溢出位\n);&nbsp;&nbsp;\n&nbsp;&nbsp;\nreg [3:0]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cnt_r ;&nbsp; &nbsp; &nbsp; //计数器寄存器\n&nbsp;&nbsp;\nalways@(posedge clk or negedge reset_n) begin\n&nbsp; if(!reset_n) begin&nbsp; &nbsp; &nbsp; &nbsp; \t\t&nbsp; \t\t//复位时，计时归0\n&nbsp; &nbsp; &nbsp; cnt_r&nbsp; &nbsp; &nbsp; &nbsp; &lt;= 4'b0000 ;\n&nbsp; &nbsp; end\n&nbsp; &nbsp; else if (cnt_r==4'd9) begin&nbsp; &nbsp; &nbsp; //计时10个cycle时，计时归0\n&nbsp; &nbsp; &nbsp; cnt_r&nbsp; &nbsp; &nbsp; &nbsp; &lt;=4'b0000;\n&nbsp; &nbsp; end\n&nbsp; else begin&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; cnt_r&nbsp; &nbsp; &nbsp; &nbsp; &lt;= cnt_r + 1'b1 ; //计时加1\n&nbsp; end\nend\n&nbsp;&nbsp;\n&nbsp; assign&nbsp; cout = (cnt_r==4'd9) ;&nbsp; &nbsp; &nbsp; &nbsp;//输出周期位\n&nbsp; assign&nbsp; cnt&nbsp; = cnt_r ;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//输出实时计时器\n&nbsp;&nbsp;\nendmodule\n</code></pre><p>看了这段代码，也许你云里雾里，或者之前没接触过硬件语言，心里有点打鼓。不过别担心，入门硬件语言并不难，我们按照代码顺序依次来看。</p><h3>模块结构</h3><p>首先，让我们看一看这段代码的第一行和最后一行。没错，一个模块的定义是以关键字module开始，以endmodule结束。module关键字后面跟的counter就是这个模块的名称。</p><p>看着有没有熟悉的感觉？你可能觉得，这个看着跟其他编程语言的函数定义也没多大区别吧？别急着下结论，再仔细看看接口部分，发现没有？这就和函数传入的参数很不一样了。</p><blockquote>\n<p>module counter(<br>\n//接口部分<br>\n&nbsp; input&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \treset_n,&nbsp;&nbsp;<br>\n&nbsp; input&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \tclk,&nbsp; &nbsp;<br>\n&nbsp; output [3:0]&nbsp; &nbsp; &nbsp; &nbsp;\tcnt,&nbsp;&nbsp;<br>\n&nbsp; output&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cout<br>\n);&nbsp;&nbsp;<br>\n……\t\t\t//逻辑功能部分<br>\nendmodule</p>\n</blockquote><p>Verilog模块的接口必须要指定它是输入信号还是输出信号。</p><p>输入信号用关键字input来声明，比如上面第4行代码的 input clk；输出信号用关键字output来声明，比如代码第5行的output [3:0]&nbsp; cnt；还有一种既可以输入，又可以输出的特殊端口信号，这种双向信号，我们用关键字inout来声明。</p><h3>数据类型</h3><p>前面我提到过，在可综合的Verilog代码里，基本所有写出来的东西都会对应实际的某个电路。而Verilog代码中定义的数据类型就能充分体现这一点。</p><blockquote>\n<p>parameter \tSIZE&nbsp; =&nbsp; 2’b01;<br>\nreg \t\t[3:0]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cnt_r;&nbsp; &nbsp;&nbsp;<br>\nwire\t[1:0]\t\tcout_w;</p>\n</blockquote><p>比如上面代码的第9行，表示定义了位宽为4 bit 的寄存器reg类型信号，信号名称为cnt_r。</p><p>寄存器reg类型表示抽象数据存储单元，它对应的就是一种寄存器电路。reg默认初始值为X（不确定值），换句话说就是，reg电路在上电之后，输出高电平还是低电平是不确定的，一般是在系统复位信号有效时，给它赋一个确定值。比如例子中的cnt_r，在复位信号reset_n等于低电平时，就会给cnt_r赋“0”值。</p><p>reg类型只能在always和inital语句中被赋值，如果描述语句是时序逻辑，即always语句中带有时钟信号，寄存器变量对应为触发器电路。比如上述定义的cnt_r，就是在带clk时钟信号的always块中被赋值，所以它对应的是触发器电路；如果描述语句是组合逻辑，即always语句不带有时钟信号，寄存器变量对应为锁存器电路。</p><p>我们常说的电子电路，也叫电子线路，所以电路中的互连线是必不可少的。Verilog代码用线网wire类型表示结构实体（例如各种逻辑门）之间的物理连线。wire类型不能存储数值，它的值是由驱动它的元件所决定的。驱动线网类型变量的有逻辑门、连续赋值语句、assign等。如果没有驱动元件连接到线网上，线网就默认为高阻态“Z”。</p><p>为了提高代码的可读性和可维护性，Verilog还定义了一种参数类型，通过parameter来声明一个标识符，用来代表一个常量参数，我们称之为<strong>符号常量</strong>，即标识符形式的常量。这个常量，实际上就是电路中一串由高低电平排列组成的一个固定数值。</p><h3>数值表达</h3><p>说到数值，我们再了解一下Verilog中的数值表达。还是以前面的4位十进制计数器代码为例，我们定位到第13行代码：</p><blockquote>\n<p>cnt_r&nbsp; &nbsp; &nbsp; &nbsp; &lt;= 4’b0000;</p>\n</blockquote><p>这行代码的意思是，给寄存器cnt_r赋以4’b0000的值。</p><p>这个值怎么来的呢？其中的逻辑“0”低电平，对应电路接地（GND）。同样的，逻辑“1”则表示高电平，对应电路接电源VCC。除此之外，还有特殊的“X”和“Z”值。逻辑“X”表示电平未知，输入端存在多种输入情况，可能是高电平，也可能是低电平；逻辑“Z”表示高阻态，外部没有激励信号，是一个悬空状态。</p><p>当然，为了代码的简洁明了，Verilog可以用不同的格式，表示同样的数值。比如要表示4位宽的数值“10”，二进制写法为4’b1010，十进制写法为4’d10，十六进制写法为4’ha。这里我需要特殊说明一下，数据在实际存储时还是用二进制，位宽表示储存时二进制占用宽度。</p><h3>运算符</h3><p>接下来我们看看Verilog的运算符，对于运算符，Verilog和大部分的编程语言的表示方法是一样的。</p><p>比如算术运算符&nbsp; + -&nbsp; *&nbsp; /&nbsp; % ，关系运算符 &gt;&nbsp; &nbsp;&lt;&nbsp; &nbsp;&lt;=&nbsp; &nbsp;&gt;=&nbsp; ==&nbsp; !=，逻辑运算符 &amp;&amp;&nbsp; ||&nbsp; ！（与或非），还有条件运算符&nbsp; ？ ，也就是C语言中的三目运算符。例如a?b:c，表示a为真时输出b，反之为c。</p><p>但在硬件语言里，位运算符可能和一些高级编程语言不一样。其中包括 ~&nbsp; &amp;&nbsp; |&nbsp; ^（按位取反、按位与，按位或，以及异或）；还有移位运算符，左移&nbsp; &lt;&lt;&nbsp;和右移&gt;&gt; ，在生成实际电路时，左移会增加位宽，右移位宽保存不变。</p><h3>条件、分支、循环语句</h3><p>还有就是条件语句if和分支语句case，由于它们的写法和其它高级编程语言几乎一样，基本上你掌握了某个语言都能理解。</p><p>这里我们重点来对比不同之处，也就是用Verilog实现条件、分支语句有什么不同。用if设计的语句所对应电路是有优先级的，也就是多级串联的MUX电路。而case语句对应的电路是没有优先级的，是一个多输入的MUX电路。设计时，只要我们合理使用这两个语句，就可以优化电路时序或者节省硬件电路资源。</p><p>此外，还有循环语句，一共有 4 种类型，分别是 while，for，repeat和 forever 循环。注意，循环语句只能在 always 块或 initial 块中使用。</p><h3>过程结构</h3><p>下面我们来说说过程结构，最能体现数字电路中时序逻辑的就是always语句了。always 语句块从 0 时刻开始执行其中的行为语句；每当满足设定的always块触发条件时，便再次执行语句块中的语句，如此循环反复。</p><p>因为always 语句块的这个特点，芯片设计师通常把always块的触发条件，设置为时钟信号的上升沿或者下降沿。这样，每次接收到一个时钟信号，always块内的逻辑电路都会执行一次。</p><p>前面代码例子第11行的always语句，就是典型的时序电路设计方法，有没有感觉到很巧妙？</p><blockquote>\n<p>always@(posedge clk or negedge rstn)&nbsp; begin<br>\n……&nbsp; &nbsp;\t\t\t\t //逻辑语句<br>\nend</p>\n</blockquote><p>还有一种过程结构就是initial 语句。它从 0 时刻开始执行，且内部逻辑语句只按顺序执行一次，多个 initial 块之间是相互独立的。理论上，initial 语句是不可以综合成实际电路的，多用于初始化、信号检测等，也就是在编写验证代码时使用。</p><p>到这里，在我看来比较重要的Verilog基础知识就讲完了，这门语言的知识脉络我也为你搭起了骨架。当然了，Verilog相关知识远远不止这些。如果你对深入学习它很感兴趣，推荐你翻阅《Verilog HDL高级数字设计》等相关资料拓展学习。</p><h2>总结回顾</h2><p>今天是芯片模块的第一节课，我们先了解了芯片的内部电路结构。一个芯片的内部电路往往分为数字电路模块和模拟电路模块。对于数字电路模块，可以使用Verilog硬件描述语句进行设计。</p><p>尽管Verilog这样的硬件语言你可能不大熟悉，但只要抓住本质，再结合代码例子建立知识脉络，学起来就能事半功倍。</p><p>要想熟悉硬件语言，我们最关键的就是做好思路转换。硬件语言跟高级编程语言本质的不同就是，使用Verilog的时候，必须理解每条语句实质上对应的什么电路，并且要从<strong>电路的角度</strong>来思考它为何要这样设计，而高级编程语言通常只要实现功能就行。</p><p>我再带你回顾一下，Verilog语言和高级编程语言具体有哪些不同：</p><p>1.<strong>模块结构</strong>：Verilog的模块结构和其他语言的函数定义不一样，它既可以有多个输入信号，也可以输出多个结果。而且，模块上的接口信号，必须要指定是输入信号和输出信号。<br>\n2.<strong>数据类型</strong>：跟我们在高级编程语言见到的变量类型相比，Verilog定义的数据类型也有很大不同。reg类型对应的是寄存器电路，wire类型对应的是电路上的互连线，标识符对应的是一串固定的高低电平信号。<br>\n3.<strong>数据表达</strong>：Verilog代码中的数据，本质上就是高低电平信号。“0”代表低电平，“1”代表高电平，不能确定高低电平的就用“X”来表示。<br>\n4.<strong>运算符</strong>：Verilog中的大部分运算符和其他语言是一样的，但是要注意位操作运算符，它们对应的是每一位电平按指定逻辑跳变，还有移位操作，一定要注意移位信号的数据位宽。<br>\n5.<strong>条件、分支、循环语句</strong>：Verilog中的条件if语句是有优先级的，而case语句则没有优先级，合理利用它们可以优化电路时序或节省硬件电路资源。循环语句则是把相同的电路重复好几遍。<br>\n6.<strong>过程结构</strong>：这是实现时序电路的关键。我们可以利用alway块语句设定一个时钟沿，用来触发相应逻辑电路的执行。这样，我们就可以依据时钟周期来分析电路中各个信号的逻辑跳变。而initial语句常在验证代码中使用，它可以从仿真的0时刻开始设置相关信号的值，并将这些值传输到待验证模块的端口上。<br>\n<img src=\"https://static001.geekbang.org/resource/image/13/bf/13ec949bd7c269421b2cae33381c49bf.jpg?wh=1920x1397\" alt=\"图片\"></p><p>下节课，我会带你设计一个简单的电路模块，既能帮你复习今天学到的知识，还能通过实践体会一下代码是怎样生成电路的，敬请期待。</p><h2>思考题</h2><p>为什么很多特定算法，用Verilog设计并且硬件化之后，要比用软件实现的运算速度快很多？</p><p>欢迎你在留言区跟我交流互动，也推荐你把这节课分享给更多朋友。</p>","neighbors":{"left":{"article_title":"02｜RISC特性与发展：RISC-V凭什么成为“半导体行业的Linux”？","id":541776},"right":{"article_title":"04｜硬件语言筑基（二）: 代码是怎么生成具体电路的？","id":543888}}},{"article_id":543888,"article_title":"04｜硬件语言筑基（二）: 代码是怎么生成具体电路的？","article_content":"<p>你好，我是LMOS。</p><p>上节课，我们学习了硬件描述语言Verilog的基础知识。今天我会带你一起用Verilog设计一个简单的电路模块。通过这节课，你不但能复习巩固上节课学到的硬件语言知识，还能在动手实践中体会代码是怎么生成具体电路的。</p><h2>Verilog代码编写</h2><p>如果你学过计算机组成原理的课程或图书，应该对ALU并不陌生。算术逻辑单元（Arithmetic&amp;logical Unit，ALU）是CPU的执行单元，是所有中央处理器的核心组成部分。</p><p>利用Verilog，我们可以设计一个包含加、减、与、或、非等功能的简单ALU模块，代码如下：</p><pre><code class=\"language-verilog\">module alu(a, b, cin, sel, y);\n&nbsp; input [7:0] a, b;\n&nbsp; input cin;\n&nbsp; input [3:0] sel;\n&nbsp; output [7:0] y;\n\n&nbsp; reg [7:0] y;\n&nbsp; reg [7:0] arithval;\n&nbsp; reg [7:0] logicval;\n\n&nbsp; // 算术执行单元\n&nbsp; always @(a or b or cin or sel) begin\n&nbsp; &nbsp; case (sel[2:0])\n&nbsp; &nbsp; &nbsp; 3'b000&nbsp; : arithval = a;\n&nbsp; &nbsp; &nbsp; 3'b001&nbsp; : arithval = a + 1;\n&nbsp; &nbsp; &nbsp; 3'b010&nbsp; : arithval = a - 1;\n&nbsp; &nbsp; &nbsp; 3'b011&nbsp; : arithval = b;\n&nbsp; &nbsp; &nbsp; 3'b100&nbsp; : arithval = b + 1;\n&nbsp; &nbsp; &nbsp; 3'b101&nbsp; : arithval = b - 1;\n&nbsp; &nbsp; &nbsp; 3'b110&nbsp; : arithval = a + b;\n&nbsp; &nbsp; &nbsp; default : arithval = a + b + cin;\n&nbsp; &nbsp; endcase\n&nbsp; end\n\n&nbsp; // 逻辑处理单元\n&nbsp; always @(a or b or sel) begin\n&nbsp; &nbsp; case (sel[2:0])\n&nbsp; &nbsp; &nbsp; 3'b000&nbsp; : logicval =&nbsp; ~a;\n&nbsp; &nbsp; &nbsp; 3'b001&nbsp; : logicval =&nbsp; ~b;\n&nbsp; &nbsp; &nbsp; 3'b010&nbsp; : logicval = a &amp; b;\n&nbsp; &nbsp; &nbsp; 3'b011&nbsp; : logicval = a | b;\n&nbsp; &nbsp; &nbsp; 3'b100&nbsp; : logicval =&nbsp; ~((a &amp; b));\n&nbsp; &nbsp; &nbsp; 3'b101&nbsp; : logicval =&nbsp; ~((a | b));\n&nbsp; &nbsp; &nbsp; 3'b110&nbsp; : logicval = a ^ b;\n&nbsp; &nbsp; &nbsp; default : logicval =&nbsp; ~(a ^ b);\n&nbsp; &nbsp; endcase\n&nbsp; end\n\n&nbsp; // 输出选择单元\n&nbsp; always @(arithval or logicval or sel) begin\n&nbsp; &nbsp; case (sel[3])\n&nbsp; &nbsp; &nbsp; 1'b0&nbsp; &nbsp; : y = arithval;\n&nbsp; &nbsp; &nbsp; default : y = logicval;\n&nbsp; &nbsp; endcase\n&nbsp; end\n\nendmodule\n</code></pre><!-- [[[read_end]]] --><p>通过上面的代码，我们实现了一个8位二进制的简单运算模块。其中，a和b是输入的两个8位二进制数，cin是a和b做加法运算时输入的进位值，4bit位宽的sel[3:0] 则是CPU中通常所说的指令操作码。</p><p>在这个ALU模块中，逻辑功能代码我们把它分成三个部分，分别是运算单元、逻辑处理单元和输出选择单元。运算单元是根据输入指令的低三位sel[2:0]，来选择执行加减等运算。同理，逻辑处理单元执行与或非门等操作。最后，根据指令的最高位sel[3]，来选择Y输出的是加减运算单元结果，还是逻辑处理的结果。</p><p>你还记得上节课的例子么？当时我们一起研究了一个4位10进制的计算器，里面用到了时钟设计。也就是说，这个计算器是通过时序逻辑实现的，所以always块中的赋值语言使用了非阻塞赋值“&lt;=”。</p><pre><code class=\"language-verilog\">always@(posedge clk or negedge reset_n) begin\n&nbsp; if(!reset_n) begin&nbsp; &nbsp; &nbsp; &nbsp; \t\t&nbsp; \t\t//复位时，计时归0\n&nbsp; &nbsp; &nbsp; cnt_r&nbsp; &nbsp; &nbsp; &nbsp; &lt;= 4'b0000 ;\n&nbsp; &nbsp; end\n</code></pre><p>而今天我们实现的ALU模块，用到的是组合逻辑，所以always块中使用阻塞赋值“=”。</p><p>怎么区分阻塞赋值和非阻塞赋值呢？阻塞赋值对应的电路结构往往与触发沿没有关系，只与输入电平的变化有关；而非阻塞赋值对应的电路结构往往与触发沿有关系，只有在触发沿时，才有可能发生赋值的情况。</p><p>另外，在前面8位二进制的代码里，算术执行单元和逻辑处理单元的两个always块是<strong>并行执行</strong>的。所以它们的运算结果几乎是同时出来，这里值得你好好理解一下。如果你没有发现两个块并行，可以暂停下来回顾一下。</p><h2>如何通过仿真验证代码</h2><p>就像我们开发软件，需要代码编译器和模拟器一样，Verilog这种硬件语言的代码，也需要运行验证。那怎么来运行验证呢？现在很多企业采用的是VCS—verilog仿真器或者是NC-verilog仿真器，这些工具都需要花重金去购买才能使用，普通人用起来成本太高了。</p><p>除了重金购买这些EDA工具之外，我们还有更节约成本、也更容易学习入门的选择。<strong>我给你推荐两个轻量级开源软件，分别是Iverilog和GTKWave。</strong>Iverilog是一个对Verilog进行编译和仿真的工具，而GTKWave是一个查看仿真数据波形的工具。</p><p>Iverilog运行于终端模式下，安装完成之后，我们就能通过Iverilog对verilog执行编译，再对生成的文件通过vvp命令执行仿真，配合GTKWave即可显示和查看图形化的波形。</p><p>在Linux系统下安装Iverilog和GTKWave非常简单。以Ubuntu为例，我们通过apt-get就可以直接安装。</p><blockquote>\n<p>安装Iverilog：sudo apt-get install iverilog<br>\n安装GTKWave：sudo apt-get install gtkwave</p>\n</blockquote><p>安装完成之后，我们需要使用which命令查看安装路径，确认是否安装成功。</p><blockquote>\n<p>which iverilog&nbsp;<br>\nwhich vvp&nbsp;<br>\nwhich gtkwave</p>\n</blockquote><p>有了软件和Verilog代码。在运行仿真前，我们还需要设计一个重要的文件，即仿真激励文件，也就是TestBench。在仿真时，要把TestBench放在所设计模块的顶层，以便对模块进行系统性的例化调用。</p><p>我们把TestBench放在设计模块的顶层，以便对模块进行系统性的例化，调用所设计的各个模块并对其进行仿真。</p><p>针对上面的ALU模块，设计了一个给ALU产生运算指令和数据的TestBench，并且把ALU的运算结果打印出来，TestBench的代码如下：</p><pre><code class=\"language-verilog\">`timescale 1 ns / 1 ns\n\nmodule alu_tb;\n&nbsp; reg[7:0] a, b;\n&nbsp; reg cin;\n&nbsp; reg[3:0] sel;\n&nbsp; wire[7:0] y;\n&nbsp; integer idx;\n\n  //对alu模块进行例化，类似于软件程序中的函数调用\n&nbsp; alu u_alu(.a(a), .b(b), .cin(cin), .sel(sel), .y(y));\n\n&nbsp; initial&nbsp;\n&nbsp; begin\n&nbsp; &nbsp; //给 a 和 b 赋初值\n&nbsp; &nbsp; a = 8'h93;\n&nbsp; &nbsp; b = 8'hA7;\n&nbsp; &nbsp; for (idx = 0;&nbsp; idx &lt;= 15;&nbsp; idx = idx + 1)&nbsp;\n&nbsp; &nbsp; begin\n&nbsp; &nbsp; &nbsp; // 循环产生运算指令 sel 的值\n&nbsp; &nbsp; &nbsp; sel = idx;\n&nbsp; &nbsp; &nbsp; // 当指令 sel = 7 时是加法操作，设定进位值cin=1\n&nbsp; &nbsp; &nbsp; if (idx == 7)\n&nbsp; &nbsp; &nbsp; &nbsp; cin = 1'b1;\n&nbsp; &nbsp; &nbsp; else\n&nbsp; &nbsp; &nbsp; &nbsp; cin = 1'b0;\n&nbsp; &nbsp; &nbsp; //每产生一个指令延时10ns\n&nbsp; &nbsp; &nbsp; #10\n&nbsp; &nbsp; &nbsp; // 延时之后打印出运算结果\n&nbsp; &nbsp; &nbsp; $display(\"%t: a=%h, b=%h, cin=%b, sel=%h, y=%h\", $time, a, b, cin, sel, y);\n&nbsp; &nbsp; end&nbsp;\n&nbsp; end\n&nbsp;&nbsp;\ninitial\nbegin\n&nbsp; $dumpfile(\"wave.vcd\");&nbsp; &nbsp; &nbsp; &nbsp; //生成波形文件vcd的名称\n&nbsp; $dumpvars(0, alu_tb);&nbsp; &nbsp;\t\t //tb模块名称\nend\n\nendmodule\n</code></pre><p>这里我要说明一下，TestBench是不可以综合成具体电路的，只用于仿真验证，但和上一节课介绍的可综合的Verilog代码语法类似。</p><p>设计工作告一段落。我们终于可以打开终端开始跑仿真了。你需要在Verilog代码所在的文件目录下执行以下指令：</p><blockquote>\n<p>iverilog -o wave -y ./&nbsp; alu_tb.v&nbsp; alu.v&nbsp;<br>\nvvp -n wave -lxt2</p>\n</blockquote><p>可以看到，运行结果输出如下：</p><blockquote>\n<p>LXT2 info: dumpfile wave.vcd opened for output.<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 10: a=93, b=a7, cin=0, sel=0, y=93\t\t//指令0：y = a;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 20: a=93, b=a7, cin=0, sel=1, y=94\t\t//指令1：y = a + 1;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 30: a=93, b=a7, cin=0, sel=2, y=92\t\t//指令2：y = a - 1;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 40: a=93, b=a7, cin=0, sel=3, y=a7\t\t//指令3：y = b;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 50: a=93, b=a7, cin=0, sel=4, y=a8\t\t//指令4：y = b + 1;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 60: a=93, b=a7, cin=0, sel=5, y=a6\t\t//指令5：y = b - 1;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 70: a=93, b=a7, cin=0, sel=6, y=3a\t\t//指令6：y = a + b;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 80: a=93, b=a7, cin=1, sel=7, y=3b\t\t//指令7：y = a + b + cin;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 90: a=93, b=a7, cin=0, sel=8, y=6c\t\t//指令8：y = ~a;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;100: a=93, b=a7, cin=0, sel=9, y=58\t\t//指令9：y = ~b;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;110: a=93, b=a7, cin=0, sel=a, y=83\t\t//指令10：y = a &amp; b;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;120: a=93, b=a7, cin=0, sel=b, y=b7\t\t//指令11：y = a | b;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;130: a=93, b=a7, cin=0, sel=c, y=7c\t\t//指令12：y = ~(a &amp; b);<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;140: a=93, b=a7, cin=0, sel=d, y=48\t\t//指令13：y = ~(a | b);<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;150: a=93, b=a7, cin=0, sel=e, y=34\t\t//指令14：y = a ^ b;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;160: a=93, b=a7, cin=0, sel=f, y=cb\t\t//指令15：y = ~(a ^ b);</p>\n</blockquote><p>有了运行结果，我们就可以打开GTKWave查看仿真波形了，这里需要在终端执行如下指令：</p><blockquote>\n<p>gtkwave wave.vcd</p>\n</blockquote><p><img src=\"https://static001.geekbang.org/resource/image/f6/71/f621c24fcd2295dd7637d7e4920c8c71.jpg?wh=2204x1005\" alt=\"\"></p><p>从打开的波形可以到，ALU模块输出的信号Y，这是根据输入指令sel和输入的数据a、b和cin的值，经过加减运算或者逻辑运算得到的。</p><h2>代码是如何生成具体电路的？</h2><p>经过上面的仿真，从打印的结果上已经看到了我们设计的模块功能。而通过查看仿真波形，我们同样也能知道各个信号的跳变关系。</p><p>但是，你可能还有个疑惑，不是说设计的Verilog语句，基本都会对应一份电路吗？怎样才能看到Verilog对应了哪些电路呢？</p><p>别急，这就是我马上要讲的逻辑综合。通过逻辑综合，我们就能完成从Verilog代码到门级电路的转换。而逻辑综合的结果，就是把设计的Verilog代码，翻译成门级网表Netlist。</p><p>逻辑综合需要基于特定的综合库，不同的库中，门电路基本标准单元（Standard Cell）的面积、时序参数是不一样的。所以，选用的综合库不一样，综合出来的电路在时序、面积上也不同。因此，哪怕采用同样的设计，选用台湾的台积电（TSMC）工艺和上海的中芯国际（SMIC）的工艺，最后生产出来的芯片性能也是有差异的。</p><p>通常，工业界使用的逻辑综合工具有Synopsys的Design Compiler（DC），Cadence的 RTL Compiler，Synplicity的Synplify等。然而，这些EDA工具都被国外垄断了，且需要收取高昂的授权费用。</p><p>为了降低学习门槛和费用，这里我们选择Yosys，它是一个轻量级开源综合工具。虽然功能上还达不到工业级的EDA工具，但是对于我们这门课的学习已经完全够用了。</p><p><img src=\"https://static001.geekbang.org/resource/image/9a/7b/9a5f496eb4d1afc872a64c7e28bcc97b.jpg?wh=3471x2905\" alt=\"\"><br>\n如上图所示，利用Yosys软件，可以帮助我们把RTL代码层次的设计转换为逻辑门级的电路。</p><p>好，我先大致带你了解下，这个软件怎么安装和使用。在Ubuntu中安装Yosys非常简单，在终端中依次执行以下命令即可：</p><blockquote>\n<p>sudo add-apt-repository ppa:saltmakrell/ppa<br>\nsudo apt-get update<br>\nsudo apt-get install yosys</p>\n</blockquote><p>完成了安装，我们就能使用Yosys，对上面设计的ALU模块做简单的综合了。</p><p>直接在终端输入“yosys”，启动Yosys软件。启动成功后，我们通过后面这五条指令，就能得到到ALU的逻辑电路图文件了。</p><p>第一步，在Yosys中读取Verilog文件。</p><blockquote>\n<p>read_verilog alu.v</p>\n</blockquote><p>第二步，使用后面的命令，检查模块例化结构。</p><blockquote>\n<p>hierarchy -check</p>\n</blockquote><p>接着是第三步，执行下一条命令，来完成高层次的逻辑综合。</p><blockquote>\n<p>proc; opt; opt; fsm; memory; opt</p>\n</blockquote><p>到了第四步，我们就可以用write_verilog生成网表文件。</p><blockquote>\n<p>write_verilog alu_synth.v</p>\n</blockquote><p>最后，我们再用下方的命令，输出综合后的逻辑图。</p><blockquote>\n<p>show -format dot -prefix ./alu</p>\n</blockquote><p>这一套动作完成后，我们终于迎来了收获成果的时刻。打开生成的alu.dot文件，我们就可以看到ALU模块的门级电路图了，如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/d0/8f/d06a02f93369fa342800cb593953248f.jpg?wh=1876x2043\" alt=\"\"></p><p>可以看到，这张图是由基本的and、or、not、add、sub、cmp、mux等电路单元组成。如果你还想进一步了解它们底层电路结构，可以自行查阅大学里学过的《数电》《模电》。</p><p>当然，Yosys功能还不只这些，这里我只是做个简易的演示。更多其它功能，如果你感兴趣的话可以到<a href=\"https://yosyshq.net/yosys\">官网</a>上学习。</p><p>到这里，类似于CPU里面的核心单元ALU电路，我们就设计完成了。</p><h2>总结回顾</h2><p>今天我们一起了解了怎么把Verilog代码变为具体的电路。为了实现代码编写、验证和仿真的“一站式”体验。我还向你推荐了几个开源软件。我们来回顾一下这节课的重点。</p><p>首先，我们用Verilog编写了一个类似CPU内部的ALU模块，该模块实现了加、减、与、或、非等基本运算功能。</p><p>针对上面的ALU模块，我们还设计了一个用于产生运算指令和数据的TestBench，并且把ALU的运算结果打印出来。利用这个TestBench，可以验证ALU模块的功能是否正确。</p><p>接下来，我们还用到了两个轻量级开源软件，分别是Iverilog和GTKWave。Iverilog是一个对Verilog进行编译和仿真的工具，GTKWave可以查看仿真数据波形的工具。利用这两个软件，我们完成了ALU模块的仿真和验证。</p><p>此外，我还推荐了一款轻量级开源综合工具Yosys。通过这个工具，我们把上面设计的ALU模块综合出了具体的门级电路。</p><p>感谢你耐心看到这里，我还给你准备了一张知识导图，总结今天所学的内容。</p><p><img src=\"https://static001.geekbang.org/resource/image/14/7b/1409db9d4ee9967ff2a5f1bf3d39697b.jpg?wh=1920x1517\" alt=\"图片\"></p><h2>扩展阅读</h2><p>仅仅一两节课的内容，就想要把所有Verilog的相关知识学完是不可能的。因此，在课程之外，需要你去多搜索，多阅读，多动手编写Verilg代码，才能更好地掌握Verilog的相关知识，这里我精心为你整理了一些参考资料，供你按需取用：</p><p>1.首先是硬件描述语言Verilog HDL的语言标准文件《IEEE Standard Verilog Hardware Description Language (1364-2001)》。<br>\n2.如果你对底层的基本电路还不熟悉，不妨复习一下大学所学的教材。这里我推荐由童诗白和华成英编写的《模拟电子技术基础》第四版，以及阎石编写的《数字电子技术基础》。<br>\n3.你要是想全面学习数字集成电路的设计、仿真验证、逻辑综合等相关知识，可以看看电子工业出版社出版的《Verilog HDL高级数字设计》。<br>\n4.最后，你要是真的想学芯片设计，从更深层次去理解数字电路设计，推荐阅读这本Mohit Arora撰写、李海东等人翻译的图书——《硬件架构的艺术——数字电路的设计方法与技术》。</p><h2>思考题</h2><p>既然用Verilog很容易就可以设计出芯片的数字电路，为什么我们国家还没有完全自主可控的高端CPU呢？</p><p>期待你在留言区记录自己的学习收获或者疑问。如果这节课对你有帮助，也推荐你分享给更多朋友，我们一起来手写迷你CPU。</p>","neighbors":{"left":{"article_title":"03｜硬件语言筑基（一）：从硬件语言开启手写CPU之旅","id":543867},"right":{"article_title":"05｜指令架构：RISC-V到底在CPU设计上有哪些优势？","id":546957}}},{"article_id":546957,"article_title":"05｜指令架构：RISC-V到底在CPU设计上有哪些优势？","article_content":"<p>你好，我是LMOS。</p><p>上节课，我们学习了设计一个CPU所需要的相关基础知识，并带你认识了一些后面将会用到的EDA软件工具。看完课程的讲解，还有上手运行的Demo，你是否对接下来要设计CPU已经蠢蠢欲动了？</p><p>哈哈，先别着急，我们在设计CPU之前，还有一些很关键的知识需要补充学习。没错，就是CPU的指令集架构。</p><p>指令集可以说是一个CPU的基石，要实现CPU的计算和控制功能，就必须要定义好一系列与硬件电路相匹配的指令系统。所以，在设计CPU之初，工程师就应该清楚CPU应该具有怎样的指令架构。</p><h2>什么是指令集？</h2><p>在第一节课我们讲历史的时候，曾经提到过，CPU既是程序指令的执行者，又被程序中相关的指令所驱动。不过，我并没有具体说明什么是指令。其实指令就是我们交代CPU要执行的操作。</p><p>那到底什么是指令集呢？</p><p>我给你打个比方：假如你有一条狗，经过一段时间的训练，它能“听懂”了你对它说一些话。当你对它说“坐下”，它就乖乖地坐在地上；当你对它说“汪汪叫”；它就汪汪汪地叫起来，当你对它说“躺下”，它马上就会躺下来……这里你说的“坐下”、“汪汪叫”、“躺下”这些命令，就相当于计算机世界里的指令。</p><p>当然，你还可以继续训练狗，让它识别更多指令，我们把所有的这些指令汇总在一起，就是一个指令集。如果指令集里面没有“上厕所”这个命令，那么即使你对狗下这个命令，它也不会去执行。CPU也一样，必须要有特定的指令集才能工作。</p><!-- [[[read_end]]] --><p>不同的CPU有不同的指令集，根据它们的繁简程度可以分为两种：复杂指令集CISC和精简指令集RISC。</p><p>指令集架构（英文叫 Instruction Set Architecture，缩写为ISA）是软件和硬件的接口，不同的应用需求，会有不同的指令架构。我们要想设计一款CPU，指令集体系就是设计的出发点。</p><h2>RISC-V指令集架构</h2><p>在开始设计一款处理器之前，我们需要选定它的指令集架构。学过前面的课程，我们知道RISC-V指令集具有明显的优势：一是RISC-V完全开放，二是RISC-V指令简单，三是RISC-V实行模块化设计，易于扩展。</p><p>我给你列了一个表，用于给你展示一下RISC-V基础指令集和扩展指令集，如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/a8/9d/a85e679d3b2a4810b6300df6f4c9ab9d.jpg?wh=3913x3401\" alt=\"\"></p><p>要满足现代操作系统和应用程序的基本运行，RV32G指令集或者RV64G指令集就够了，注意RV32G指令集或者RV64G指令集，只有寄存器位宽和寻址空间大小不同，这些指令按照功能可以分为如下几类。</p><p>1.整数运算指令：实现算术、逻辑、比较等运算操作。<br>\n2.分支转移指令：实现条件转移、无条件转移等操作。<br>\n3.加载存储指令：实现字节、半字、字、双字（RV64I）的加载、存储操作，采用的都是寄存器相对寻址方式。<br>\n4.控制与状态寄存器访问指令：实现对系统控制与系统状态寄存器的原子读-写、原子读-修改、原子读-清零等操作。<br>\n5.系统调用指令：实现系统调用功能。<br>\n6.原子指令：用于现在你能看到的各种同步锁。<br>\n7.单双浮点指令：用于实现浮点运算操作。</p><p>从上表我们也可以看到，RISC-V指令集具有模块化特点。这就允许我们根据自己的应用需求，选择一个基础指令集，加上若干个扩展指令集灵活搭配，就可以得到我们想要的指令集架构，进而根据这样的指令架构，设计出贴合我们应用需求的CPU。</p><p>作为一个初学者，我们先从RISC-V的核心开始。它最核心的部分是一个基础整数指令集，叫做RV32I。RV32I就表示32位的RISC-V。指令集的命名方式我在<a href=\"https://time.geekbang.org/column/article/541776\">第二节课</a>给你提到过，如果你印象不深了，可以去回顾一下。仅仅依靠RV32I，我们就可以运行一个完整的软件栈。</p><p>RV32I包含的指令是固定的，永远不会改变。这为编译器设计人员，操作系统开发人员和汇编语言程序员提供了稳定的基础知识框架。</p><p>接下来我们看一张图，这是 RV32I 基础指令集的名称表示。</p><p><img src=\"https://static001.geekbang.org/resource/image/e3/08/e3055b9ebb8e1459b1a9e007fde2b008.jpg?wh=2782x3171\" alt=\"\"></p><p>这些名称，你乍一看是不是有点眼花缭乱？先别慌，我讲一下命名规则，你就能明白了。</p><p>从图中我们可以看到，有些字母带有下划线。我们把带有下划线的字母从左到右连接起来，就可以组成一个 RV32I 的指令。对于每一个指令名称，集合标志{}内列举了指令的所有变体，变体用加下划线的字母或下划线字符_表示。如果大括号内只有下划线字符_，则表示对于此指令变体不需用字母表示。</p><p>我们再结合例子加深一下理解。下图表示了这四个 RV32I 指令：bge，blt，bgeu，bltu。</p><p><img src=\"https://static001.geekbang.org/resource/image/40/af/4063e22fc0ea23955c75e411e6585caf.jpg?wh=2900x777\" alt=\"\"></p><p>通过前面<a href=\"https://time.geekbang.org/column/article/543867\">第三节课</a>硬件描述语言基础的学习，我们知道了CPU的硬件逻辑里只有“0”和“1”，那么问题来了，怎么用“0”和“1”来表示出上述的指令呢？</p><p>要想回答这个问题，我们需要依次去了解指令格式，指令中要用到的寄存器以及指令集中各种功能的指令。</p><h2>指令格式</h2><p>我们先从RV32I的指令格式说起。从下图可以看到，RISCV总共也就只有6种指令格式。<br>\n<img src=\"https://static001.geekbang.org/resource/image/7b/c8/7b035797137a9e42cc1f6544d6d4dac8.jpg?wh=4005x2200\" alt=\"\"></p><p>六种指令各司其职，我把它们的作用整理成了表格，这样你看起来一目了然。</p><p><img src=\"https://static001.geekbang.org/resource/image/d8/0f/d8d87cc1093252d02a854fc9836c3d0f.jpg?wh=1920x675\" alt=\"图片\"></p><p>不要小看这些指令，我们来分析一下它们到底有哪些优势。这些指令格式规整有序，结构简单。因为指令只有六种格式，并且所有的指令都是 32 位长度的，所以这些指令解码起来就比较简单，可以简化解码电路，提高CPU的性能功耗比。</p><p>上图中的opcode代表指令操作码，imm代表立即数，funct3和funct7代表指令对应的功能，rs1、rs2和rd则分别代表源寄存器1、源寄存器2以及目标寄存器。RISC-V的一个指令中可以提供三个寄存器操作数，而不是像 x86一样，让源操作数和目的操作数共享一个字段，因此相比x86指令，RISC-V 减少了软件的程序操作。</p><p>而且，源寄存器（rs1和rs2）和目标寄存器（rd），都设计固定在所有RISC-V指令同样的位置上，指令译码相对简单。所以，指令在CPU流水线中执行时，可以先开始访问寄存器，然后再完成指令解码。</p><p>此外，这些指令格式的所有立即数的符号位总是在指令的最高位。这个设计有什么好处呢？它意味着，有可能成为关键路径的立即数符号扩展，可以在指令解码前进行。这样可以加速符号扩展电路，有利于CPU流水线的时序优化。</p><h2>RV32I 寄存器</h2><p>之前讲指令格式时，我们说到了源寄存器rs1、rs2和目标寄存器rd，那你知道指令中的寄存器都有哪些吗？</p><p>在RISC-V的规范里定义了32个通用寄存器。其中，有 31 个是常规寄存器，1 个恒为 0 值的 x0 寄存器。0值寄存器的设置，是为了满足汇编语言程序员和编译器编写者的使用需要，他们可以使用x0寄存器作为操作数，来完成功能相同的操作。</p><p>比如说，我们如果需要插入一个空操作，就可以使用汇编语句 “addi&nbsp; x0 , x0, 0 ”（相当于0+0=0）来代替其他指令集中的nop空指令。</p><p>由于访问寄存器中的数据要比访问存储器的速度快得多，一般每条 RISC-V 指令最多用一个时钟周期执行（忽略缓存未命中的情况），而ARM-32 或者x86-32 则需要多个时钟周期执行的指令。因为ARM-32只有16个寄存器，而X86-32仅仅只有8个寄存器。</p><p>因此，寄存器越多，编译器和汇编程序员的工作就会越轻松。</p><p>之前<a href=\"https://time.geekbang.org/column/article/541776\">第二节课</a>，我给你列过RV32I的32个通用寄存器，这里我再带你复习一下，温故知新。表中的ABI全称为Application Binary Interface，即应用程序二进制接口，也就是寄存器的别名，在汇编程序设计时会用到。</p><p><img src=\"https://static001.geekbang.org/resource/image/29/6b/29b1fcdeeaecffb0b86499066c3d9b6b.jpg?wh=1920x1097\" alt=\"图片\"></p><p>寄存器的内容我们就先讲这些，后面实现CPU的时候具体用到了，我再详细解释。</p><h2>RV32I的各类指令解读</h2><p>接下来我们研究一下RV32I的各种指令。如果你写过汇编程序应该知道，一般用得较多的就是算术和逻辑处理语句了，我们先从这类指令说起。</p><h3>算术与逻辑指令</h3><p>在RV32I的指令中，包括算术指令（add, sub）、数值比较指令（slt）、逻辑指令（and, or, xor）以及移位指令 （sll, srl, sra）这几种指令。</p><p>这些指令和其他指令集差不多，它们从寄存器读取两个 32 位的值，并将 32 位的运算结果再写回到目标寄存器。RV32I 还提供了这些指令的立即数版本，就是如下图所示的I型指令：</p><p><img src=\"https://static001.geekbang.org/resource/image/54/8a/54b02a5c4bbfb27d5893253b39c8808a.jpg?wh=1920x1173\" alt=\"图片\"></p><p>同样的，RV32I也提供了寄存器和寄存器操作的指令，包括加减运算、数值比较、逻辑操作和移位操作。这些指令的功能和前面的立即数指令相似，不同的是，这里把指令中的立即数对应位置替换成了源寄存器 rs2。</p><p>寄存器和寄存器操作的指令如下表所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/b9/d6/b93b1e301cefa6a2c2fa5cc469a21dd6.jpg?wh=1920x1216\" alt=\"图片\"></p><p>需要指出的是，在寄存器和寄存器操作的算术指令中，必须要有减法指令，这和立即数操作指令有所不同。</p><h3>RV32I 的Load和Store</h3><p>与CISC指令集具有众多的寻址方式不同，RV32I 省略了像 x86-32 指令集那样的复杂寻址模式。在 RISC-V 指令集中，对内存的读写只能通过 LOAD 指令和 STORE 指令实现。而其他的指令，都只能以寄存器为操作对象。</p><p>你可以看看后面的这张图，里面列出了Load 指令和Store指令格式：</p><p><img src=\"https://static001.geekbang.org/resource/image/fd/14/fdfa6ce0100bcb824c61314aaa1dea14.jpg?wh=1920x1261\" alt=\"图片\"></p><p>如上图所示，加载和存储的寻址模式只能是符号扩展12位的立即数，加上基地址寄存器得到访问的存储器地址。因为没有了复杂的内存寻址方式，这让CPU流水线可以对数据冲突提前做出判断，并通过流水线各级之间的转送加以处理，而不需要插入空操作（NOP），极大提高了代码的执行效率。</p><h3>分支跳转指令</h3><p>学习了前面的第二节课，相信你对RISC-V指令架构特点已经有所了解，RISC-V遵循的是大道至简的原则。它的指令数目非常简洁，基本指令只有40多条，其中只有6条有条件跳转指令，减少了跳转指令的条数，这样硬件设计上更为简单。</p><p>下面，我们分别来看看RV32I条件跳转指令和无条件跳转指令的运行原理。这些原理只要你耐心听我讲完就能理解，而且之后也会应用在我们的在MiniCPU实现中。</p><h4>有条件分支跳转</h4><p>RV32I 中的条件跳转指令是通过比较两个寄存器的值，并根据比较结果进行分支跳转。比较可以是：相等（beq），不相等 （bne），大于等于（bge），或小于（blt）。</p><p>如下图所示，大于等于（bge），和小于（blt）则跳转指令为有符号数比较，RV32I 也提供了相应的无符号数的比较指令，分别为bgeu和 bltu。剩下的两个比较关系（大于和小于等于），可以通过简单地交换两个操作数位置，来完成相同的比较。例如， x &lt; y 可以表示为y &gt; x ，同样的， x ≤ y也表示为 y ≥ x。<br>\n<img src=\"https://static001.geekbang.org/resource/image/70/37/70c2682fbbd1f9f3f4d14d7f5d5cd337.jpg?wh=3960x1710\" alt=\"\"></p><h4>无条件分支跳转</h4><p>除了有条件分支跳转，RV32I还提供了无条件跳转指令，无条件跳转指令还可以细分为直接跳转和间接跳转这两种指令。</p><p>直接跳转指令JAL如下图所示。RISC-V 为 JAL 指令专门定义了 J-TYPE 格式。</p><p><img src=\"https://static001.geekbang.org/resource/image/10/c4/1027ff24d1dc411c05670099e27fa8c4.jpg?wh=3905x710\" alt=\"\"><br>\nJAL指令的执行过程是这样的。首先，它会把 20 位立即数做符号位扩展，并左移一位，产生一个 32 位的符号数。然后，将该 32 位符号数和 PC 相加来产生目标地址（这样，JAL 可以作为短跳转指令，跳转至 PC±1 MB 的地址范围内）。</p><p>同时，JAL 也会把紧随其后的那条指令的地址，存入目标寄存器中。这样，如果目标寄存器是零，则 JAL 就等同于 GOTO 指令；如果目标寄存器不为零，JAL 可以实现函数调用的功能。</p><p><img src=\"https://static001.geekbang.org/resource/image/51/89/51733a156b421868f5765yy376caa089.jpg?wh=1920x325\" alt=\"图片\"></p><p>间接跳转指令JALR 如上图所示。JALR 指令会把 12 位立即数和源寄存器相加，并把相加的结果末位清零，作为新的跳转地址。同时，和 JAL 指令一样，JALR 也会把紧随其后的那条指令的地址，存入到目标寄存器中。</p><h2>RV32I的其他指令</h2><p>除了内存地址空间和通用寄存器地址空间外，RISC-V 中还定义了一个独立的控制与状态寄存器（Control Status Register，CSR）地址空间。</p><p>每个处理器实现的CSR会因设计目标不同而有差异，但这些CSR的访问方式却是一致的，访问这些 CSR 的指令定义在了用户指令集中（Zicsr 指令集扩展）。</p><p><img src=\"https://static001.geekbang.org/resource/image/77/8a/777a0494580fca3b981b1cb32b19068a.jpg?wh=1920x1118\" alt=\"图片\"></p><p>有了上图这些CSR指令，能够让我们轻松访问一些程序性能计数器。这些计数器包括系统时间、时间周期以及执行的指令数目。</p><p>在 RISC-V 指令集中，还有其他的一些指令，例如用于系统调用的ecall指令，在调试时用于将控制转移到调试环境的ebreak 指令等。对于这些扩展的指令，这里就不展开讲了。</p><p>好，到这里，我们就把RISC-V的基础整数指令集——RV32I大体梳理了一遍。你可能感慨，比起训练一条狗，训练“CPU”要复杂得多。不过，通过RV32I这个最核心的指令集，我们也看到了 RISC-V的很多设计优势。</p><p>相比CISC，RISCV确实更容易学习和使用。学习了这些基本指令的功能，我们就可以设计出简单的CPU了。</p><h2>重点回顾</h2><p>好了，今天的课程就到这里，让我们来回顾一下今天学到的内容。</p><p>首先，我们知道了什么是CPU的指令集，并选择 <strong>RISC-V最核心的基础整数指令集RV32I</strong> 重点学习。RV32I包含的指令是固定的，永远不会改变。我们学好RV32I，不但能为学习RISC-V的扩展指令集打下基础，也能为编译器设计、操作系统开发和汇编程序设计搭建好前置的基础知识框架。</p><p>RISC-V到底在CPU设计上有哪些优势？我们从指令格式、寄存器以及指令解读这几个方面入手，做了不少讨论。</p><p>RISC-V仅有6种指令格式，它们分别是：<strong>R类型指令、 I 型指令、 S 型指令、B 类型指令、 U 型指令和 J 型指令</strong>。这些指令格式规整有序，结构简单，所以指令解码起来比较简单，有利于简化解码电路，提高了CPU的性能功耗比。</p><p>此外，在RISC-V的规范里，<strong>定义了32个通用寄存器</strong>。其中有 31 个常规寄存器，一个恒 0 值的 x0 寄存器。由于<strong> RISV的寄存器有数量上的优势</strong>，使得基于RISC-V设计CPU不用那么频繁地去访问存储器，指令执行起来更快，也让编译器和汇编程序员的工作更加轻松。</p><p>之后我们了解到，RV32I的指令包括算术指令、数值比较指令、逻辑指令以及移位指令，这些指令和其他指令集差不多。但是，<strong> RISC-V与CISC指令集具有众多的寻址方式不同</strong>，RV32I 省略了如 x86-32 指令集的复杂寻址模式。在 RISC-V 指令集中，对内存的读写只能通过 LOAD 指令和 STORE 指令实现。</p><p>RISC-V遵循的是大道至简的原则，它的指令数目非常简洁，基本指令只有40多条，而<strong>分支跳转指令只有8条</strong>，其中6条是带条件跳转指令，2条是无条件跳转指令。这些指令条数的减少，使硬件设计更简单。</p><p>除了上面提到的指令，RISC-V还有其他的一些指令，比如，还定义了一个独立的控制与状态寄存器地址空间，其地址宽度是 12 位的。根据每个设计的目标不同，每个处理器实际实现的 CSR 可能会有所不同。对于剩余没有介绍的一些指令，如果你感兴趣的话，可以自己查阅相关资料（比如RISC-V的官方手册）来学习。</p><p>最后我为你梳理了这节课的知识导图，供你参考。</p><p><img src=\"https://static001.geekbang.org/resource/image/a4/05/a4a2649c9df2799a7ddf3be7c18ef305.jpg?wh=1920x1404\" alt=\"图片\"></p><h2>思考题</h2><p>今天我们讲到了RISC-V 中的分支跳转指令 JAL。想想看，为什么要通过调整立即数的某些位，从 U-TYPE指令得到J-TYPE指令格式呢？这样调整以后有什么好处？</p><p>期待你记录自己这节课学完的收获或者疑问，我在留言区等你。如果这节课对你有启发，也推荐你分享给更多朋友。下节课我们就要着手设计迷你CPU了，敬请期待。</p>","neighbors":{"left":{"article_title":"04｜硬件语言筑基（二）: 代码是怎么生成具体电路的？","id":543888},"right":{"article_title":"06｜手写CPU（一）：迷你CPU架构设计与取指令实现","id":547921}}},{"article_id":547921,"article_title":"06｜手写CPU（一）：迷你CPU架构设计与取指令实现","article_content":"<p>你好，我是LMOS。</p><p>经过上一节课的学习，我们已经知道了一个基于RISC-V指令集设计的CPU，必须要实现哪些指令。从这节课开始，我们就可以着手设计和实现MiniCPU了。</p><p>我会先跟你讲讲什么是流水线，在CPU中使用流水线的好处是什么？然后，我们再以经典的五级流水线为例，讲解CPU流水线的五个阶段。接着设计出我们MiniCPU的总体结构，并根据规划的五级流水线，完成流水线的第一步——取指模块的设计。课程的配套代码可以从<a href=\"https://gitee.com/lmos/Geek-time-computer-foundation.git\">这里</a>下载。</p><p>话不多说，让我们正式开始今天的学习吧。</p><h2>什么是CPU流水线？</h2><p>说到流水线，你是否会马上想到我们打工人的工厂流水线？没错，高大上的CPU流水线其实和我们打工人的流水线是一样的。</p><p>假如我们在冰墩墩工厂上班，生产流水线分为五个步骤，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/4e/e0/4e68e7b1f59cedb8723b32141ac12fe0.jpg?wh=1920x852\" alt=\"图片\"></p><p>在冰墩墩生产线上需要至少五个工人，各自负责模具制作、模具清洗、模具抛光、硅胶塑形和融入图案这五个环节中的一个。最简单的方法自然是：同一时刻只有一个冰墩墩在制作。但是冬奥会的热度让市场上的冰墩墩供应不足，为了早日实现“人手一墩”的目标，有什么提升生产效率的办法呢？</p><p>稍微想想就知道，生产线上一个人在制作冰墩墩的时候，另外四个工人都处于空闲状态，显然这是对人力资源的极大浪费。想要提高效率，我们不妨在第一个冰墩墩模具制作出来进入清洗阶段的时候，马上开始进行第二个冰墩墩模具的制作，而不是等到第一个冰墩墩全部步骤做完后，才开始制作下一个。</p><!-- [[[read_end]]] --><p>这样，后续生产中就能够保证五个工人一直处于工作状态，不会造成人员的闲置而产线的冰墩墩就好像流水一样源源不断地产出，因此我们称这种生产方式为流水线。</p><p>在CPU中也是使用类似的流水线作业。以经典的五级流水线为例，流水线中一条指令的生命周期分为五个阶段：</p><p><strong>取指阶段（Instruction Fetch）</strong>：取指阶段是指将指令从存储器中读取出来的过程。程序指针寄存器用来指定当前指令在存储器中的位置。读取一条指令后，程序指针寄存器会根据指令的长度自动递增，或者改写成指定的地址。</p><p><strong>译码阶段（Instruction Decode）</strong>：指令译码是指将存储器中取出的指令进行翻译的过程。指令译码器对指令进行拆分和解释，识别出指令类别以及所需的各种操作数。</p><p><strong>执行阶段（Instruction Execute）</strong>：指令执行是指对指令进行真正运算的过程。例如指令是一条加法运算指令，则对操作数进行相加操作；如果是一条乘法运算指令，则进行乘法运算。在“执行”阶段最关键的模块为算术逻辑单元（Arithmetic Logical Unit，ALU），它是实施具体运算的硬件功能单元。</p><p><strong>访存阶段（Memory Access）</strong>：访存是指存储器访问指令将数据从存储器中读出，或写入存储器的过程。</p><p><strong>写回阶段（Write-Back）</strong>：写回是指将指令执行的结果写回通用寄存器的过程。如果是普通运算指令，该结果值来自于“执行”阶段计算的结果；如果是存储器读指令，该结果来自于“访存”阶段从存储器中读取出来的数据。</p><p>和上述的冰墩墩生产线的流水作业一样，为了提高效率，CPU使用流水线也是为了提高处理器的性能。</p><p><img src=\"https://static001.geekbang.org/resource/image/c3/3a/c39053403fc1c3bf6e33392952d2c33a.jpg?wh=1920x906\" alt=\"图片\"></p><p>对照上图，CPU在第一个时钟周期T内完成取指操作。然后在第二个时钟周期2T内对上一条指令进行译码的同时，取下一条指令。接着在第三个时钟周期3T内就有取指、译码和执行3个操作同时进行……以此类推，五级流水线的CPU内就可以同时进行5个操作。这样平均下来，就相当于每条指令只需要五分之一的时钟周期时间来完成。</p><p>总体上看，流水线提高了指令的处理速度，缩短了程序执行的时间。</p><p>那我们能不能把流水线的思想，引入到我们的MiniCPU中呢？答案是肯定的。具体如何实现呢？我们接着往下看。</p><h2>MiniCPU的架构</h2><p>先明确一下我们想实现的目标：使用Verilog硬件描述语言，基于RV32I指令集，设计一个32位的经典五级流水线的处理器核。它将会支持运行大多数RV32I的基础指令。</p><p>那什么样的架构设计才能实现这个目标呢？参照CPU流水线的五个步骤，我们可以对处理器核的各个功能模块进行划分，主要模块包括指令提取单元、指令译码单元、整型执行单元、访问存储器和写回结果等单元模块。</p><p>根据上面的模块划分，我们可以设计出MiniCPU的整体框架，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/31/dd/31b586c344cd7d0127775e7ff63711dd.jpg?wh=1920x1289\" alt=\"图片\"></p><p>这张图片中一个方框就表示一个模块，方框里面的文字就是模块的名字，箭头则表示模块与模块之间的信号传输关系。</p><p>从图中可以看到，我们要设计的不仅仅是一个CPU内核了，它更像是一个SOC（System on Chip的缩写）。</p><p>因为我们要对它进行一些仿真验证，就必须要包含存放指令、数据的ROM和RAM，还有一些简单的外设。比如用于串口通信的UART以及一些通用输入、输出端口GPIO都属于外设。CPU通过系统总线（System Bus）和这些外设进行通信。</p><p>下面我们先快速了解一下，在我们这个CPU架构中，体现五级流水线的主要模块有哪些。</p><p>首先我们来看 <strong>pre_if模块</strong>，这里我把它叫作分支预测或者预读取模块，因为它主要是先对上一个指令进行预处理，判断是不是分支跳转指令。如果是跳转指令，则产生跳转后的PC值，并对下一条指令进行预读取。</p><p>然后是取指通路模块，即 <strong>if_id模块</strong>。它是取指到译码之间的模块，上面的指令预读取之后就会首先送入if_id模块，如果当前流水线没有发出指令清除信号，if_id模块就会把指令送到译码模块。</p><p>接下来是 <strong>id_ex模块</strong>，它是译码到执行之间的模块，用于将完成指令译码之后的寄存器索引值，以及指令执行的功能信息，根据流水线控制模块的控制信号，选择性地发送给执行模块去执行。</p><p>指令译码之后便可以进行指令执行，<strong>ex_mem模块</strong>负责指令执行之后将数据写入存储器中或者从存储器中读出数据的过程。</p><p>最后由 <strong>mem_wb模块</strong>将指令执行的运算结果或者从存储器读出的数据，写回到通用寄存器。到这里，处理器流水线的总体结构就设计好啦。</p><p>接下来我们先完成流水线第一步，即取指模块的设计与实现。</p><h2>流水线的第一步：指令预读取</h2><p>我们的MiniCPU流水线的第一步是指令预读取，也就是先把指令从存储器中读出。</p><p>由于我们的指令长度是32位的，也就是一条指令在存储器中占有4个字节的空间，所以一般情况下，CPU中的程序计数器（PC）是以4递增的。</p><p>但是，如果你熟悉计算机程序就应该知道，我们的程序通常不是从头到尾执行一次就完事了，往往还需要调用函数或者循环执行某一段程序的操作。</p><p>而这样的操作，在硬件底层的CPU里面就涉及分支跳转指令了。为了实现程序分支跳转功能，就需要我们的预读取模块来处理。</p><p>我先把这个模块的Verilog代码给你展示一下，再具体给你讲解：</p><pre><code class=\"language-verilog\">module pre_if (\n&nbsp; &nbsp; input [31:0] instr,\n&nbsp; &nbsp; input [31:0] pc,\n\n&nbsp; &nbsp; output [31:0] pre_pc\n);\n\n&nbsp; &nbsp; wire is_bxx = (instr[6:0] == `OPCODE_BRANCH);&nbsp; &nbsp;//条件跳转指令的操作码\n&nbsp; &nbsp; wire is_jal = (instr[6:0] == `OPCODE_JAL) ;&nbsp; &nbsp; &nbsp;//无条件跳转指令的操作码\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; //B型指令的立即数拼接\n&nbsp; &nbsp; wire [31:0] bimm&nbsp; = {{20{instr[31]}}, instr[7], instr[30:25], instr[11:8], 1'b0};\n&nbsp; &nbsp; //J型指令的立即数拼接\n&nbsp; &nbsp; wire [31:0] jimm&nbsp; = {{12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0};\n\n&nbsp; &nbsp; //指令地址的偏移量\n&nbsp;   wire [31:0] adder = is_jal ? jimm : (is_bxx &amp; bimm[31]) ? bimm : 4;\n&nbsp; &nbsp; assign pre_pc = pc + adder;\n\nendmodule\n</code></pre><p>我们来看看第八行和第九行代码，分别是根据指令的低7位操作码，判断是否是条件跳转指令或是无条件跳转指令。</p><p>其实上一节课的RISC-V指令架构中，我们讲过RISC-V指令集中有两类分支跳转指令，分别是<strong>条件跳转指令</strong>和<strong>无条件跳转指令</strong>。</p><p>条件跳转指令格式如下表所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/70/37/70c2682fbbd1f9f3f4d14d7f5d5cd337.jpg?wh=3960x1710\" alt=\"\"></p><p>从这张表格我们可以发现，条件跳转指令的操作码，也就是指令中的低7位数都是 7’b1100011。根据这一特点，我们就可以在指令解码之前，判断出接下来可能会发生跳转。</p><p>我们结合代码来看看。下面的Verilog语句就是跳转指令的判断，其中的`OPCODE_BRANCH 已经通过宏定义为 7’b1100011。</p><pre><code class=\"language-verilog\">&nbsp; &nbsp; wire is_bxx = (instr[6:0] == `OPCODE_BRANCH);&nbsp; &nbsp;//条件跳转指令的操作码\n</code></pre><p>条件跳转指令执行时是否发生跳转，要根据相关的数据来判断，这就需要指令执行之后才能知道是否需要跳转（具体如何判断，我们后面第十节课再展开）。</p><p><img src=\"https://static001.geekbang.org/resource/image/a0/09/a08a9d2a3e693e95bd035af3673bb009.jpg?wh=1920x812\" alt=\"图片\"></p><p>但是，我们的CPU是多级流水线架构，一条指令执行需要多个时钟周期。如果要等到跳转指令执行完成之后再去取下一条指令，就会降低我们的指令执行效率。</p><p>而指令预读取模块刚好可以解决这个问题。不管指令是否跳转，都提前把跳转之后的下一条指令从存储器中读取出来，以备流水线的下一阶段使用，这就提高了CPU的执行效率。</p><p>以下代码就是根据条件跳转指令的格式，对指令中的立即数进行拼接，为指令跳转时的PC提供偏移量。</p><pre><code class=\"language-verilog\">&nbsp;//B型指令的立即数拼接\nwire [31:0] bimm&nbsp; = {{20{instr[31]}}, instr[7], instr[30:25], instr[11:8], 1'b0};\n</code></pre><p>同样地，无条件跳转指令也用这种方式进行预处理。如下图的jal跳转指令的格式，它的操作码为7’b1101111。<br>\n<img src=\"https://static001.geekbang.org/resource/image/10/c4/1027ff24d1dc411c05670099e27fa8c4.jpg?wh=3905x710\" alt=\"\"></p><p>根据指令的操作码，预译码电路就可以判断出是否为无条件跳转指令。下面就是无条件跳转指令的判断的Verilog语句，其中的`OPCODE_BRANCH已经通过宏定义为 7’b1101111。</p><pre><code class=\"language-verilog\">&nbsp; &nbsp;wire is_jal = (instr[6:0] == `OPCODE_JAL) ;&nbsp; &nbsp; &nbsp;//无条件跳转指令的操作码\n</code></pre><p>顾名思义，无条件跳转指令就是不需要判断其他的任何条件，直接跳转。我们继续结合代码理解，这行代码的意思是，根据jal指令的格式对指令中的立即数进行拼接，为指令跳转时的PC提供偏移量。</p><pre><code class=\"language-verilog\">//J型指令的立即数拼接\nwire [31:0] jimm&nbsp; = {{12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0};\n</code></pre><p>最后，预读取电路会根据当前的PC值和指令的偏移量相加，得到预测的PC值，并用预测的PC值提前读出下一条指令。其Verilog代码如下：</p><pre><code class=\"language-verilog\">&nbsp; //指令地址的偏移量\n&nbsp; wire [31:0] adder = is_jal ? jimm : (is_bxx &amp; bimm[31]) ? bimm : 4;\n&nbsp; assign pre_pc = pc + adder;\n</code></pre><h2>取指数据通路模块</h2><p>由上述的指令预读取模块把指令从存储器中读取之后，需要把它发送给译码模块进行翻译。但是，预读取模块读出的指令，并不是全部都能发送后续模块去执行。</p><p>例如上面的条件分支指令，在指令完成之前就把后续的指令预读取出来了。如果指令执行之后发现跳转的条件不成立，这时预读取的指令就是无效的，需要对流水线进行冲刷（flush），把无效的指令都清除掉。</p><p>取指通路模块 <strong>if_id</strong> 主要产生3个信号。首先是给后面解码模块提供的指令信号 <strong>reg_instr。</strong>如果流水线没有发生冲突，也就是没有发出清除信号flush，则把预读取的指令保存，否则把指令清“0”。</p><pre><code class=\"language-verilog\">  //指令通路\n  always @(posedge clock) begin\n    if (reset) begin \n      reg_instr &lt;= 32'h0; \n    end else if (flush) begin \n      reg_instr &lt;= 32'h0; \n    end else if (valid) begin \n      reg_instr &lt;= in_instr; \n    end\n  end\n</code></pre><p>第二个是更新PC值，如果指令清除信号flush=“0”，则把当前指令对应的PC值保存为<strong>reg_pc</strong>，否则就把reg_pc清“0”。</p><pre><code class=\"language-verilog\">&nbsp; //PC值通路\n&nbsp; always @(posedge clock) begin\"\"\n&nbsp; &nbsp; if (reset) begin&nbsp;\n&nbsp; &nbsp; &nbsp; reg_pc &lt;= 32'h0;&nbsp;\n&nbsp; &nbsp; end else if (flush) begin&nbsp;\n&nbsp; &nbsp; &nbsp; reg_pc &lt;= 32'h0;&nbsp;\n&nbsp; &nbsp; end else if (valid) begin&nbsp;\n&nbsp; &nbsp; &nbsp; reg_pc &lt;= in_pc;&nbsp;\n&nbsp; &nbsp; end\n&nbsp; end\n</code></pre><p>最后一个是流水线冲刷的标志信号 <strong>reg_noflush</strong>。当需要进行流水线冲刷时，reg_noflush=“0”，否则reg_noflush=“1”。</p><pre><code class=\"language-verilog\">&nbsp; //流水线冲刷标志位\n&nbsp; always @(posedge clock) begin&nbsp;&nbsp;\n&nbsp; &nbsp; if (reset) begin&nbsp;\n&nbsp; &nbsp; &nbsp; reg_noflush &lt;= 1'h0;&nbsp;\n&nbsp; &nbsp; end else if (flush) begin&nbsp;\n&nbsp; &nbsp; &nbsp; reg_noflush &lt;= 1'h0;&nbsp;\n&nbsp; &nbsp; end else if (valid) begin&nbsp;\n&nbsp; &nbsp; &nbsp; reg_noflush &lt;= in_noflush;&nbsp;\n&nbsp; &nbsp; end\n&nbsp; end\n</code></pre><p>以下就是if_id模块的完整代码：</p><pre><code class=\"language-verilog\">  //  IF_ID\nmodule if_id(           \n  input         clk,\n  input         reset,\n  input  [31:0] in_instr,\n  input  [31:0] in_pc,\n  input         flush,\n  input         valid,\n  output [31:0] out_instr,\n  output [31:0] out_pc,\n  output        out_noflush\n);\n\n  reg [31:0] reg_instr; \n  reg [31:0] reg_pc; \n  reg [31:0] reg_pc_next; \n  reg        reg_noflush; \n\n  assign out_instr = reg_instr; \n  assign out_pc = reg_pc; \n  assign out_noflush = reg_noflush; \n\n  //指令传递\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin \n      reg_instr &lt;= 32'h0; \n    end else if (flush) begin \n      reg_instr &lt;= 32'h0; \n    end else if (valid) begin \n      reg_instr &lt;= in_instr; \n    end\n  end\n\n  //PC值转递\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin \n      reg_pc &lt;= 32'h0; \n    end else if (flush) begin \n      reg_pc &lt;= 32'h0; \n    end else if (valid) begin \n      reg_pc &lt;= in_pc; \n    end\n  end\n\n  //流水线冲刷标志位\n  always @(posedge clk or posedge reset) begin  \n    if (reset) begin \n      reg_noflush &lt;= 1'h0; \n    end else if (flush) begin \n      reg_noflush &lt;= 1'h0; \n    end else if (valid) begin \n      reg_noflush &lt;= 1'h1; \n    end\n  end\nendmodule\n</code></pre><p>好了，到这里CPU流水线的第一步——取指，我们就讲完了。在取指阶段就是把存储器里的指令读出，并传递给后续的译码模块进行处理。</p><h2>重点回顾</h2><p>今天我们终于开启了MiniCPU的设计与实现之旅，为此我们做了很多准备，恭喜你坚持到这里。</p><p>在开始设计之前，我先带你了解了流水线的设计思想。工厂里的流水线设计在CPU里也可以借鉴，通过这种方法就能提高CPU的性能。</p><p>真正的CPU流水线要根据应用需求来设计，应用场景不一样，设计的流水线也不一样。为了让你在弄懂原理的基础上能快速上手，我们的MiniCPU采用了经典的五级流水线设计。这个流水线里一条指令的五个阶段分别是取指、译码、执行、访存和写回。</p><p>从MiniCPU的架构设计上也能看到，我们的重心放在了最能体现五级流水线的模块。不过麻雀虽小，五脏俱全，这个架构里已经包含了CPU内核，用于存放指令、数据的ROM和RAM以及一些简单的外设。CPU会通过系统总线（System Bus）和这些外设进行通信。</p><p>CPU架构里的五个主要模块，你可以参考后面的导图，其中前两个模块我们这节课已经拿下了，其它模块之后的课程里我们再展开学习。<br>\n<img src=\"https://static001.geekbang.org/resource/image/82/eb/82b3fyy2fd5b465256fyy76da8a58eeb.jpg?wh=2149x1714\" alt=\"\"></p><p>明确了设计思想和架构以后，我带你迈出了流水线的第一步，也就是取指令。</p><p>我们现实通过指令预读取模块，在程序发生分支跳转的之前，对指令进行分析，预测指令跳转的方向，并提前读取跳转后的指令。这么做能提高指令在流水线中执行效率。</p><p>最后，在if_id模块中，会根据是否需要进行流水线冲刷，来判断预读取的指令能否传递给后面的译码模块。如果指令在流水线中发生冲突，需要进行流水线冲刷，就把预读取的指令清除，否则就把预读取的指令传递给后续的译码模块。</p><p>那之后指令是如何译码的呢？译码是流水线很关键的一步，让我们下节课一起解锁这部分内容吧。</p><h2>思考题</h2><p>为什么要对指令进行预读取？直接取指然后译码、执行不可以吗？</p><p>欢迎你在留言区提问或者记录今天的收获，如果感觉这节课还不错，也推荐你分享给身边的朋友，和他一起手写CPU。</p>","neighbors":{"left":{"article_title":"05｜指令架构：RISC-V到底在CPU设计上有哪些优势？","id":546957},"right":{"article_title":"07｜手写CPU（二）：如何实现指令译码模块？","id":548002}}},{"article_id":548002,"article_title":"07｜手写CPU（二）：如何实现指令译码模块？","article_content":"<p>你好，我是LMOS。</p><p>上节课，我们了解了什么是CPU的流水线，并决定采用经典的五级流水线来设计我们的MiniCPU，之后梳理了我们将要设计的MiniCPU架构长什么样，最后完成了流水线的第一步——取指。</p><p>取指阶段把存储器里的指令读出以后，就会传递给后续的译码模块进行处理。那之后指令是如何译码的呢？这就要说到流水线的第二步——译码（代码从<a href=\"https://gitee.com/lmos/Geek-time-computer-foundation\">这里</a>下载）。</p><h2>指令是如何翻译的？</h2><p><a href=\"https://time.geekbang.org/column/article/546957\">第五节课</a>我们已经讲过了RISC-V指令架构，明确了我们的MiniCPU选用的是RV32I指令集。其中每条指令都是32位，且分为6种指令格式，不同格式的指令中包含了不一样的指令信息。</p><p><img src=\"https://static001.geekbang.org/resource/image/7b/c8/7b035797137a9e42cc1f6544d6d4dac8.jpg?wh=4005x2200\" alt=\"\"></p><p>如上图所示的6种指令格式，其中R型指令包含了操作码opcode、目标寄存器索引rd、功能码funct3和funct7以及源寄存器索引rs1和rs2。而I型指令则是包含操作码opcode、目标寄存器索引rd、功能码funct3、源寄存器索引rs1以及立即数imm。</p><p>与此类似，后面的S型指令、B型指令、U型指令和J型指令也有特定的操作码、功能码、源寄存器索引、目标寄存器索引和立即数。</p><p>不过指令格式不同，指令译码模块翻译指令的工作机制却是统一的。首先译码电路会翻译出指令中携带的寄存器索引、立即数大小等执行信息。接着，在解决数据可能存在的数据冒险（这个概念后面第九节课会讲）之后，由译码数据通路负责把译码后的指令信息，发送给对应的执行单元去执行。</p><!-- [[[read_end]]] --><h2>译码模块的设计</h2><p>通过上面的分析，你是否对译码模块的设计已经有了头绪？是的，译码模块就是拆解从取指模块传过来的每一条指令。译码时，需要识别出指令的操作码，并根据对应的指令格式提取出指令中包含的信息。</p><p>译码模块具体的Verilog设计代码如下：</p><pre><code class=\"language-verilog\">module decode (\n  input  [31:0] instr,\t\t\t//指令源码\n\n  output  [4:0] rs1_addr,\t\t//源寄存器rs1索引\n  output  [4:0] rs2_addr,\t\t//源寄存器rs2索引\n  output  [4:0] rd_addr,\t\t//目标寄存器rd索引\n  output  [2:0] funct3,\t\t\t//功能码funct3\n  output  [6:0] funct7,\t\t\t//功能码funct7\n  output        branch,\n  output [1:0]  jump,\n  output        mem_read,\n  output        mem_write,\n  output        reg_write,\n  output        to_reg,\n  output [1:0]  result_sel,\n  output        alu_src,\n  output        pc_add,\n  output [6:0]  types,\n  output [1:0]  alu_ctrlop,\n  output        valid_inst,\n  output [31:0] imm\n);\n\nlocalparam DEC_INVALID = 21'b0;\n\nreg [20:0] dec_array;\n\n//---------- decode rs1、rs2 -----------------\nassign rs1_addr = instr[19:15]; \nassign rs2_addr = instr[24:20];\n\n//---------- decode rd -----------------------\nassign rd_addr = instr[11:7]; \n\n//---------- decode funct3、funct7 -----------\nassign funct7 = instr[31:25]; \nassign funct3 = instr[14:12]; \n\n// ----------------------------- decode signals ---------------------------------\n\n//                        20     19-18  17       16        15        14     13-12      11      10     9--------3  2---1      0\n//                        branch jump   memRead  memWrite  regWrite  toReg  resultSel  aluSrc  pcAdd     RISBUJZ  aluctrlop  validInst\nlocalparam DEC_LUI     = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b01,     1'b0,   1'b0,  7'b0000100, 2'b00,     1'b1};\nlocalparam DEC_AUIPC   = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b00,     1'b1,   1'b1,  7'b0000100, 2'b00,     1'b1};\nlocalparam DEC_JAL     = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b10,     1'b0,   1'b0,  7'b0000010, 2'b00,     1'b1};\nlocalparam DEC_JALR    = {1'b0,  2'b11, 1'b0,    1'b0,     1'b1,     1'b0,  2'b10,     1'b1,   1'b0,  7'b0100000, 2'b00,     1'b1};\nlocalparam DEC_BRANCH  = {1'b1,  2'b00, 1'b0,    1'b0,     1'b0,     1'b0,  2'b00,     1'b0,   1'b0,  7'b0001000, 2'b10,     1'b1};\nlocalparam DEC_LOAD    = {1'b0,  2'b00, 1'b1,    1'b0,     1'b1,     1'b1,  2'b00,     1'b1,   1'b0,  7'b0100000, 2'b00,     1'b1};\nlocalparam DEC_STORE   = {1'b0,  2'b00, 1'b0,    1'b1,     1'b0,     1'b0,  2'b00,     1'b1,   1'b0,  7'b0010000, 2'b00,     1'b1};\nlocalparam DEC_ALUI    = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b00,     1'b1,   1'b0,  7'b0100000, 2'b01,     1'b1};\nlocalparam DEC_ALUR    = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b00,     1'b0,   1'b0,  7'b1000000, 2'b01,     1'b1};\n\nassign  {branch, jump, mem_read, mem_write, reg_write, to_reg, result_sel, alu_src, pc_add, types, alu_ctrlop, valid_inst} = dec_array;\n\nalways @(*) begin\n  case(instr[6:0])\n    `OPCODE_LUI    :   dec_array &lt;= DEC_LUI;   \n    `OPCODE_AUIPC  :   dec_array &lt;= DEC_AUIPC; \n    `OPCODE_JAL    :   dec_array &lt;= DEC_JAL; \n    `OPCODE_JALR   :   dec_array &lt;= DEC_JALR;   \n    `OPCODE_BRANCH :   dec_array &lt;= DEC_BRANCH; \n    `OPCODE_LOAD   :   dec_array &lt;= DEC_LOAD;   \n    `OPCODE_STORE  :   dec_array &lt;= DEC_STORE;  \n    `OPCODE_ALUI   :   dec_array &lt;= DEC_ALUI;  \n    `OPCODE_ALUR   :   dec_array &lt;= DEC_ALUR;  \n    default        :  begin\n                 dec_array &lt;= DEC_INVALID;\n    end\n  endcase\nend\n\n// -------------------- IMM -------------------------\n\nwire [31:0] Iimm = {{21{instr[31]}}, instr[30:20]};\nwire [31:0] Simm = {{21{instr[31]}}, instr[30:25], instr[11:7]};\nwire [31:0] Bimm = {{20{instr[31]}}, instr[7], instr[30:25], instr[11:8], 1'b0};\nwire [31:0] Uimm = {instr[31:12], 12'b0};\nwire [31:0] Jimm = {{12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0};   \n\nassign imm = {32{types[5]}} &amp; Iimm\n           | {32{types[4]}} &amp; Simm\n           | {32{types[3]}} &amp; Bimm\n           | {32{types[2]}} &amp; Uimm\n           | {32{types[1]}} &amp; Jimm;\n\nendmodule\n</code></pre><p>这段代码看起来很长，其实整个代码可以分为三个部分：第28行到37行负责完成指令的源寄存器、目标寄存器、3位操作码和7位操作码的译码，第40行至73行负责完成指令格式类型的识别，第75行至87行负责完成立即数译码。</p><p>首先，我们来看指令中源寄存器、目标寄存器、3位操作码和7位操作码的译码。仔细观察上面提到的6种指令格式，我们可以发现一定的规律：全部的目标寄存器索引 <strong>rd</strong> 都位于指令的第7～11位，源寄存器索引 <strong>rs1</strong> 位于指令的第15～19位，源寄存器索引 <strong>rs2</strong> 位于指令的第20～24位，三位的操作码 <strong>funct3</strong> 位于指令的第12～14位，七位的操作码 <strong>funct7</strong> 位于指令的第25～31位。</p><p>它们的位置分布如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/c1/7a/c1d593a99ac6b08e50yy0c45a930857a.jpg?wh=1920x310\" alt=\"图片\"></p><p>上述这些信号在不同指令格式中的位置比较固定。因此我们就可以根据这些位置特点，直接从指令中截取，从而得到它们相应的信息，具体实现的Verilog代码如下（对应整体代码的27～37行）：</p><pre><code class=\"language-verilog\">//---------- decode rs1、rs2 -----------------\nassign rs1_addr = instr[19:15]; \nassign rs2_addr = instr[24:20];\n\n//---------- decode rd -----------------------\nassign rd_addr = instr[11:7]; \n\n//---------- decode funct3、funct7 -----------\nassign funct7 = instr[31:25]; \nassign funct3 = instr[14:12]; \n</code></pre><p>在所有的指令格式中，还有一段最为特殊的信息码。这段信息码是每条指令都有的，且位置和位宽保持不变。没错，它就是指令的操作码opcode。</p><p>对照RISC-V的官方手册，我为你整理出了RV32I指令集的操作码对照表，如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/2e/23/2ea867d9beff30ca1b60fa9e8003ec23.jpg?wh=1920x1286\" alt=\"图片\"></p><p>我们再来回顾一下RISC-V的指令格式，这次我们重点观察指令操作码的位置。</p><p><img src=\"https://static001.geekbang.org/resource/image/7b/c8/7b035797137a9e42cc1f6544d6d4dac8.jpg?wh=4005x2200\" alt=\"\"></p><p>不难发现，所有指令操作码都位于指令的第0～6位。根据这7位的操作码就可以判断出一条指令是什么类型，它对应的是什么指令格式。进而可以产生指令执行信号，为后续的指令执行单元的操作提供依据。</p><p>以下就是指令操作码的译码和产生相关指令控制信号的Verilog代码（对应整体代码的39～72行）：</p><pre><code class=\"language-verilog\">// ----------------------------- decode signals ---------------------------------\n\n//                        20     19-18  17       16        15        14     13-12      11      10     9--------3  2---1      0\n//                        branch jump   memRead  memWrite  regWrite  toReg  resultSel  aluSrc  pcAdd     RISBUJZ  aluctrlop  validInst\nlocalparam DEC_LUI     = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b01,     1'b0,   1'b0,  7'b0000100, 2'b00,     1'b1};\nlocalparam DEC_AUIPC   = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b00,     1'b1,   1'b1,  7'b0000100, 2'b00,     1'b1};\nlocalparam DEC_JAL     = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b10,     1'b0,   1'b0,  7'b0000010, 2'b00,     1'b1};\nlocalparam DEC_JALR    = {1'b0,  2'b11, 1'b0,    1'b0,     1'b1,     1'b0,  2'b10,     1'b1,   1'b0,  7'b0100000, 2'b00,     1'b1};\nlocalparam DEC_BRANCH  = {1'b1,  2'b00, 1'b0,    1'b0,     1'b0,     1'b0,  2'b00,     1'b0,   1'b0,  7'b0001000, 2'b10,     1'b1};\nlocalparam DEC_LOAD    = {1'b0,  2'b00, 1'b1,    1'b0,     1'b1,     1'b1,  2'b00,     1'b1,   1'b0,  7'b0100000, 2'b00,     1'b1};\nlocalparam DEC_STORE   = {1'b0,  2'b00, 1'b0,    1'b1,     1'b0,     1'b0,  2'b00,     1'b1,   1'b0,  7'b0010000, 2'b00,     1'b1};\nlocalparam DEC_ALUI    = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b00,     1'b1,   1'b0,  7'b0100000, 2'b01,     1'b1};\nlocalparam DEC_ALUR    = {1'b0,  2'b00, 1'b0,    1'b0,     1'b1,     1'b0,  2'b00,     1'b0,   1'b0,  7'b1000000, 2'b01,     1'b1};\n\nassign  {branch, jump, mem_read, mem_write, reg_write, to_reg, result_sel, alu_src, pc_add, types, alu_ctrlop, valid_inst} = dec_array;\n\nalways @(*) begin\n  case(instr[6:0])\n    `OPCODE_LUI    :   dec_array &lt;= DEC_LUI;   \n    `OPCODE_AUIPC  :   dec_array &lt;= DEC_AUIPC; \n    `OPCODE_JAL    :   dec_array &lt;= DEC_JAL; \n    `OPCODE_JALR   :   dec_array &lt;= DEC_JALR;   \n    `OPCODE_BRANCH :   dec_array &lt;= DEC_BRANCH; \n    `OPCODE_LOAD   :   dec_array &lt;= DEC_LOAD;   \n    `OPCODE_STORE  :   dec_array &lt;= DEC_STORE;  \n    `OPCODE_ALUI   :   dec_array &lt;= DEC_ALUI;  \n    `OPCODE_ALUR   :   dec_array &lt;= DEC_ALUR;  \n    default        :  begin\n                 dec_array &lt;= DEC_INVALID;\n    end\n  endcase\nend\n</code></pre><p>从上面的代码我们可以看到，译码的过程就是先识别指令的低7位操作码instr[6:0]，根据操作码对应的代码标识，产生分支信号branch、跳转信号jump、读存储器信号mem_read……这些译码之后的指令控制信息。然后，把译码得到的信息交到CPU流水线的下一级去执行。</p><p>此外，还有指令中的立即数需要提取。观察上述的6种指令格式你会发现，除了R型指令不包含立即数，其他5种指令类型都包含了立即数。</p><p>前面我已经讲过了怎么去识别指令的类型。那指令里的立即数怎么提取呢？其实这跟提取指令的索引、功能码差不多。</p><p>我们根据不同指令类型中立即数的分布位置，就能直接提取指令的立即数。最后也是根据指令的类型选择性输出I型、S型、B型、U型或者J型指令的立即数即可，具体的代码如下：</p><pre><code class=\"language-verilog\">// -------------------- IMM -------------------------\n\nwire [31:0] Iimm = {{21{instr[31]}}, instr[30:20]};\nwire [31:0] Simm = {{21{instr[31]}}, instr[30:25], instr[11:7]};\nwire [31:0] Bimm = {{20{instr[31]}}, instr[7], instr[30:25], instr[11:8], 1'b0};\nwire [31:0] Uimm = {instr[31:12], 12'b0};\nwire [31:0] Jimm = {{12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0};   \n\nassign imm = {32{types[5]}} &amp; Iimm\n           | {32{types[4]}} &amp; Simm\n           | {32{types[3]}} &amp; Bimm\n           | {32{types[2]}} &amp; Uimm\n           | {32{types[1]}} &amp; Jimm;\n</code></pre><h2>译码控制模块设计</h2><p>前面的译码模块得到的指令信号，可以分为两大类。一类是由指令的操作码经过译码后产生的<strong>指令执行控制信号</strong>，如跳转操作jump信号、存储器读取mem_read信号等；另一类是从指令源码中提取出来的<strong>数据信息</strong>，如立即数、寄存器索引、功能码等。</p><p>为了能对流水线更好地实施控制，这里我们需要把译码后的数据和控制信号分开处理。首先来看译码控制模块的实现：</p><pre><code class=\"language-verilog\">module id_ex_ctrl(\n  input        clk,\n  input        reset,\n  input        in_ex_ctrl_itype,\n  input  [1:0] in_ex_ctrl_alu_ctrlop,\n  input  [1:0] in_ex_ctrl_result_sel,\n  input        in_ex_ctrl_alu_src,\n  input        in_ex_ctrl_pc_add,\n  input        in_ex_ctrl_branch,\n  input  [1:0] in_ex_ctrl_jump,\n  input        in_mem_ctrl_mem_read,\n  input        in_mem_ctrl_mem_write,\n  input  [1:0] in_mem_ctrl_mask_mode,\n  input        in_mem_ctrl_sext,\n  input        in_wb_ctrl_to_reg,\n  input        in_wb_ctrl_reg_write,\n  input        in_noflush,\n  input        flush,\n  input        valid,\n  output       out_ex_ctrl_itype,\n  output [1:0] out_ex_ctrl_alu_ctrlop,\n  output [1:0] out_ex_ctrl_result_sel,\n  output       out_ex_ctrl_alu_src,\n  output       out_ex_ctrl_pc_add,\n  output       out_ex_ctrl_branch,\n  output [1:0] out_ex_ctrl_jump,\n  output       out_mem_ctrl_mem_read,\n  output       out_mem_ctrl_mem_write,\n  output [1:0] out_mem_ctrl_mask_mode,\n  output       out_mem_ctrl_sext,\n  output       out_wb_ctrl_to_reg,\n  output       out_wb_ctrl_reg_write,\n  output       out_noflush\n);\n\n  reg  reg_ex_ctrl_itype; \n  reg [1:0] reg_ex_ctrl_alu_ctrlop; \n  reg [1:0] reg_ex_ctrl_result_sel; \n  reg  reg_ex_ctrl_alu_src; \n  reg  reg_ex_ctrl_pc_add; \n  reg  reg_ex_ctrl_branch; \n  reg [1:0] reg_ex_ctrl_jump; \n  reg  reg_mem_ctrl_mem_read; \n  reg  reg_mem_ctrl_mem_write; \n  reg [1:0] reg_mem_ctrl_mask_mode; \n  reg  reg_mem_ctrl_sext; \n  reg  reg_wb_ctrl_to_reg; \n  reg  reg_wb_ctrl_reg_write; \n  reg  reg_noflush; \n\n  ………………    //由于这里的代码较长，结构相似，这里省略了一部分\n  \n  always @(posedge clk or posedge reset) begin\n    if (reset) begin \n      reg_noflush &lt;= 1'h0; \n    end else if (flush) begin \n      reg_noflush &lt;= 1'h0; \n    end else if (valid) begin \n      reg_noflush &lt;= in_noflush; \n    end\n  end\nendmodule\n</code></pre><p>上面就是译码控制模块的Verilog设计代码。</p><p>上一节课学习取指模块的时候我们说过，并不是所有从存储器中读取出来的指令，都能够给到执行单元去执行的。比如，当指令发生冲突时，需要对流水线进行冲刷，这时就需要清除流水线中的指令。同样的，译码阶段的指令信号也需要清除。</p><p>译码控制模块就是为了实现这一功能，当指令清除信号flush有效时，把译码模块产生的jump、branch、mem_read、mem_write、reg_write……这些控制信号全部清“0”。否则，就把这些控制信号发送给流水线的下一级进行处理。</p><h2>译码数据通路模块设计</h2><p>和译码模块类似，译码数据通路模块会根据CPU相关控制模块产生的流水线冲刷控制信号，决定要不要把这些数据发送给后续模块。</p><p>其中，译码得到的数据信息包括立即数imm、源寄存器索引rs1和rs2、目标寄存器索引rd以及功能码funct3和funct7。具体的设计代码如下所示：</p><pre><code class=\"language-verilog\">module id_ex(\n  input         clk,\n  input         reset,\n  input  [4:0]  in_rd_addr,\n  input  [6:0]  in_funct7,\n  input  [2:0]  in_funct3,\n  input  [31:0] in_imm,\n  input  [31:0] in_rs2_data,\n  input  [31:0] in_rs1_data,\n  input  [31:0] in_pc,\n  input  [4:0]  in_rs1_addr,\n  input  [4:0]  in_rs2_addr,\n  input         flush,\n  input         valid,\n  output [4:0]  out_rd_addr,\n  output [6:0]  out_funct7,\n  output [2:0]  out_funct3,\n  output [31:0] out_imm,\n  output [31:0] out_rs2_data,\n  output [31:0] out_rs1_data,\n  output [31:0] out_pc,\n  output [4:0]  out_rs1_addr,\n  output [4:0]  out_rs2_addr\n);\n  reg [4:0] reg_rd_addr; \n  reg [6:0] reg_funct7; \n  reg [2:0] reg_funct3; \n  reg [31:0] reg_imm; \n  reg [31:0] reg_rs2_data; \n  reg [31:0] reg_rs1_data; \n  reg [31:0] reg_pc; \n  reg [4:0] reg_rs1_addr; \n  reg [4:0] reg_rs2_addr; \n\n  …………  //由于代码较长，结构相似，这里省略了一部分，完整代码你可以从Gitee上获取\n\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin \n      reg_rs2_addr &lt;= 5'h0; \n    end else if (flush) begin \n      reg_rs2_addr &lt;= 5'h0; \n    end else if (valid) begin \n      reg_rs2_addr &lt;= in_rs2_addr; \n    end\n  end\n\nendmodule\n</code></pre><p>我们以目标寄存器的索引地址reg_rd_addr信号为例，分析一下它是怎么流通的。当流水线冲刷信号flush有效时，目标寄存器的索引地址reg_rd_addr直接清“0”，否则当信号有效标志valid为“1”时，把目标寄存器的索引地址传递给流水线的下一级。</p><pre><code class=\"language-verilog\">  always @(posedge clk or posedge reset) begin\n    if (reset) begin \n      reg_rd_addr &lt;= 5'h0; \n    end else if (flush) begin \n      reg_rd_addr &lt;= 5'h0; \n    end else if (valid) begin \n      reg_rd_addr &lt;= in_rd_addr; \n    end\n  end\n</code></pre><p>类似地，当流水线冲刷信号flush有效时，把译码模块得到的源操作数1、源操作数2、立即数、目标寄存器地址……等等这些数据全部清“0”。否则，就把这些数据发送给流水线的下一级进行处理。</p><h2>重点回顾</h2><p>指令译码是CPU流水线中比较重要的一步，在译码阶段一定不能出错，否则流水线后续的执行就全都乱了。今天我们设计出了指令译码的相关模块，我带你回顾一下这节课的要点。</p><p>首先，我们针对RV32I指令集的6种指令格式，分析了它们各自包含了哪些指令信号。根据这些信息的位置不同，指令译码模块就可以从不同类型的指令格式中，把每条指令包含的信息提取出来。</p><p>之后，根据上面分析的译码思路，我们就可以设计译码模块了。经过观察，<strong>我们发现指令中的操作码、目标寄存器索引、源寄存器索引和功能码，在不同指令格式中的位置比较固定，所以这些信息可以直接从指令中截取得到。</strong></p><p>由于指令的操作码有特殊的指令标识作用，我们可以根据操作码产生指令控制信息，给到CPU流水线的下一级去执行。此外，还可以根据不同指令类型中立即数的分布位置特点，通过截取得到指令的立即数。</p><p>译码得到的指令信号分为两大类：一类是由指令的操作码经过译码后产生的<strong>指令执行控制信号</strong>，另一类是从指令源码中提取出来的<strong>数据信息</strong>。为了让译码后的信息，能更好地分发给流水线后续模块去执行，这里我们把译码后的数据和控制信号分开处理，分别设计了数据通路模块和译码控制模块。</p><p><img src=\"https://static001.geekbang.org/resource/image/c9/6c/c9a820a96faa70f18a77155be538506c.jpg?wh=1920x1324\" alt=\"图片\"></p><h2>思考题</h2><p>在6种指令格式中，S型、J型和B型指令里的立即数是不连续的，这是为什么？</p><p>欢迎你在留言区跟我交流互动，也推荐你把这节课分享给更多朋友，组团一起来跟我折腾CPU!</p>","neighbors":{"left":{"article_title":"06｜手写CPU（一）：迷你CPU架构设计与取指令实现","id":547921},"right":{"article_title":"08｜手写CPU（三）：如何实现指令执行模块？","id":550393}}},{"article_id":550393,"article_title":"08｜手写CPU（三）：如何实现指令执行模块？","article_content":"<p>你好，我是LMOS。</p><p>上一节课，我们完成了CPU流水线的指令译码模块设计。我们一起探讨了RISC-V指令是如何翻译的，还学会了提取不同类型指令中的信息。最后根据流水线的需要，我们设计出了译码控制模块和数据通路模块。</p><p>接下来，我们利用译码后的这些信息继续设计流水线的下一级——执行单元。指令执行算是CPU流水线中最复杂的一个阶段了，不过别担心，经过前面课程的准备，我们一定可以搞定它。</p><h2>CPU的执行概述</h2><p>回顾前面我们已经设计完成的CPU流水线步骤：</p><p>1.取指模块根据程序计数器（PC）寻址到指令所在的存储单元，并从中取出指令。<br>\n2.译码模块对取出的指令进行翻译，得到功能码、立即数、寄存器索引等字段，然后根据某些字段读取一个或两个通用寄存器的值。</p><p>经过流水线的这两个步骤之后，下一步就需要把这些指令信息发送给执行单元去执行相关操作。根据译码之后的指令信息，我们可以把指令分为三类，分别是算术逻辑指令、分支跳转指令、存储器访问指令。</p><p><a href=\"https://time.geekbang.org/column/article/548002\">上节课</a>我们已经详细解读了RISC-V指令集的指令格式，正是因为格式上比较简单而且规整，所以不同类别的指令执行过程也是类似的。这样，RISC执行单元的电路结构相比CISC就得到了简化。</p><p>所以在指令执行阶段，上述的这三类指令都能通过ALU进行相关操作。比如，存储访问指令用ALU进行地址计算，条件分支跳转指令用ALU进行条件比较，算术逻辑指令用ALU进行逻辑运算。</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/e3/28/e3548857ab073bb598f1dff35a245f28.jpg?wh=1920x1242\" alt=\"图片\"></p><p>上图就是ALU模块的设计框图。<strong>在ALU模块中，指令可以分成三类来处理：第一类是普通的ALU指令，包括逻辑运算、移位操作等指令；第二类指令负责完成存储器访问指令Load和Store的地址生成工作；第三类是负责分支跳转指令的结果解析和执行。</strong>这就是流水线执行阶段的核心模块ALU的设计思路。</p><h2>执行控制模块的设计</h2><p>根据上节课设计的译码模块，我们已经得到了指令的功能码、立即数、寄存器索引等字段信息。</p><p>你是否还记得？我们在译码模块里根据指令的7位操作码opcode字段，还产生了一个ALU执行的指令控制字段aluCrtlOp。这正是上文提到的ALU模块把指令分成三类执行的控制信号。</p><p>具体的信号编码，你可以参考后面的表格：</p><p><img src=\"https://static001.geekbang.org/resource/image/43/be/43a64833c9d698e35697c7cb7c4d67be.jpg?wh=1920x710\" alt=\"图片\"></p><p>根据2位执行类型字段aluCrtlOp，以及指令译码得到的操作码funct7和funct3，就可以设计我们的执行控制模块了。</p><p>结合前面的表格，我们来看看执行控制模块如何根据aluCrtlOp信号做判断。</p><p>如果aluCrtlOp等于（00），对应的指令类型就是Load和Store指令，也就是通过加法运算来计算访存地址；如果aluCrtlOp等于（01），相应的指令类型就是ALUI/ALUR，同样也是根据输入的funct7和funct3字段决定执行哪些算术运算，比如加减运算、移位操作等；如果类型字段等于（10），就对应着分支跳转指令，流水线就会相应去完成条件分支的解析工作。</p><p>表格最后一列你先不用关注，扩展功能时才可能用到，这里先关注前三类情况即可。</p><p>具体设计的Verilog代码如下：</p><pre><code class=\"language-verilog\">module ALUCtrl (\n    input [2:0]  funct3,\n    input [6:0]  funct7,\n    input [1:0]  aluCtrlOp,\n    input        itype,\n    output reg [3:0] aluOp\n);\n    always @(*) begin\n      case(aluCtrlOp)\n        2'b00:  aluOp &lt;= `ALU_OP_ADD;           // Load/Store\n        2'b01:  begin\n          if(itype &amp; funct3[1:0] != 2'b01)\n            aluOp &lt;= {1'b0, funct3};\n          else\n            aluOp &lt;= {funct7[5], funct3};   // normal ALUI/ALUR\n        end\n        2'b10:  begin\n          case(funct3)                    // bxx\n            `BEQ_FUNCT3:  aluOp &lt;= `ALU_OP_EQ;\n            `BNE_FUNCT3:  aluOp &lt;= `ALU_OP_NEQ;\n            `BLT_FUNCT3:  aluOp &lt;= `ALU_OP_SLT;\n            `BGE_FUNCT3:  aluOp &lt;= `ALU_OP_GE;\n            `BLTU_FUNCT3: aluOp &lt;= `ALU_OP_SLTU;\n            `BGEU_FUNCT3: aluOp &lt;= `ALU_OP_GEU;\n            default:      aluOp &lt;= `ALU_OP_XXX;\n          endcase\n          end\n        default: aluOp &lt;= `ALU_OP_XXX;\n      endcase\n    end\nendmodule\n</code></pre><p>这里要注意的是，当aluCtrlOp等于（01）时，需要根据funct3和funct7产生ALU的操作码。在前面的译码模块中，已经为我们提供了I型指令类型的判断信号itype。如果是itype信号等于“1”，操作码直接由funct3和高位补“0”组成；如果不是I型指令，ALU操作码则要由funct3和funct7的第五位组成。</p><p>根据上述的三类指令，就会产生一个4位的ALU操作信号aluOp，为后面的ALU模块做相关逻辑运行提供操作码。</p><h2>通用寄存器</h2><p>在ALU模块开始执行运算之前，我们还需要提前完成一个操作——读取通用寄存器。在参与ALU逻辑运算的两个操作数中，至少有一个来自于通用寄存器，另一个可以来自于通用寄存器或者指令自带的立即数，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/12/d3/12b4de8b3f29f191fbd679439008acd3.jpg?wh=1920x1498\" alt=\"图片\"></p><p><img src=\"https://static001.geekbang.org/resource/image/2a/7d/2afc17e22ce4b29bb2c861ff33afb97d.jpg?wh=1920x330\" alt=\"图片\"></p><p>由于第七节课提到的6种指令中的R型指令有三个操作数，分别对应于两个源寄存器rs1和rs2，以及一个目标寄存器rd。一条R指令类似于有三个参数的函数，如add（rd，rs1，rs2），完成的功能就是先读取rs1、rs2两个参数，然后相加，最后把结果写入到rd参数中。</p><p>对应到每条指令，则需要从通用寄存器模块中读取其中两个寄存器中的数据，之后还要把运算结果写入另一个通用寄存器。每读取一个寄存器，就需要输入一个寄存器索引，并输出一个通用寄存器中的值。两个操作数对应的寄存器需要同时读取，所以<strong>通用寄存器模块需要两个读地址接口和两个读数据输出接口</strong>。</p><p>此外，处于流水线上的指令是并发执行的，在读取通用寄存器的同时，可能还需要写入数据到通用寄存器，所以需要<strong>一套写地址和写数据接口</strong>。因此，通用寄存器模块的设计框图如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/a6/57/a67a8bf89580a4418287026580a2a557.jpg?wh=1805x1305\" alt=\"图片\"></p><p>根据上述的设计思路，我们就可以设计和实现通用寄存器代码了。</p><pre><code class=\"language-verilog\">module gen_regs (\n    input  clk,\n    input  reset,\n    input  wen,\n    input  [4:0] regRAddr1, regRAddr2, regWAddr,\n    input  [31:0] regWData,\n    output [31:0] regRData1,\n    output [31:0] regRData2\n);\n    integer ii;\n    reg [31:0] regs[31:0];\n\n    // write registers\n    always @(posedge clk or posedge reset) begin\n        if(reset) begin\n            for(ii=0; ii&lt;32; ii=ii+1)\n                regs[ii] &lt;= 32'b0;\n        end\n        else if(wen &amp; (|regWAddr)) \n                regs[regWAddr] &lt;= regWData;\n    end\n\n    // read registers\n    assign regRData1 = wen &amp; (regWAddr == regRAddr1) ? regWData\n                    : ((regRAddr1 != 5'b0) ? regs[regRAddr1] : 32'b0);\n    assign regRData2 = wen &amp; (regWAddr == regRAddr2) ? regWData\n                    : ((regRAddr2 != 5'b0) ? regs[regRAddr2] : 32'b0);\nendmodule\n</code></pre><p>这里添加了一个写控制使能信号wen。因为写寄存器是边沿触发的，在一个时钟周期内写入的寄存器数据，需要在下一个时钟周期才能把写入的数据读取出来。为了提高读写效率，在对同一个寄存器进行读写时，如果写使能wen有效，就直接把写入寄存器的数据送给读数据接口，这样就可以在一个时钟周期内，读出当前要写入的寄存器数据了。<br>\n从前面的章节中我们知道，通用寄存器总共有32个，所以通用寄存器模块上的读写地址都是5位（$2^{5}$=32）。</p><p>其中，还有一个寄存器比较特殊，从代码中也可以看到它的特殊处理，即<strong>读地址regRAddr1 = 5’b0 时的寄存器</strong>。我们把第一个寄存器叫做0值寄存器，因为在RISC-V指令架构中就规定好了，第一个通用寄存器必须编码为0，也就是把写入该寄存器的数据忽略，而在读取时永远输出为0。</p><h2>ALU模块设计</h2><p>当操作码和操作数都准备好后，我们就可以开始ALU模块的实现了。</p><p>上述执行控制模块根据三类指令产生的ALU操作信号aluOp，在ALU模块就能以此为依据，执行相应的运算了。操作码对应的ALU操作如下表所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/22/38/22033f3e45836cce1a6c35a6def6e038.jpg?wh=1920x1457\" alt=\"图片\"></p><p>根据表格中的操作编码和对应的运行操作，很容易就可以设计出ALU模块，具体的设计代码如下：</p><pre><code class=\"language-verilog\">\nmodule alu (\n  input  [31:0] alu_data1_i,\n  input  [31:0] alu_data2_i,\n  input  [ 3:0] alu_op_i,\n  output [31:0] alu_result_o\n);\n\n  reg  [31:0] result;\n  \n  wire [31:0] sum    = alu_data1_i + ((alu_op_i[3] | alu_op_i[1]) ? -alu_data2_i : alu_data2_i);\n  wire        neq    = |sum;\n  wire        cmp    = (alu_data1_i[31] == alu_data2_i[31]) ? sum[31]\n                     : alu_op_i[0] ? alu_data2_i[31] : alu_data1_i[31];\n  wire [ 4:0] shamt  = alu_data2_i[4:0];\n  wire [31:0] shin   = alu_op_i[2] ? alu_data1_i : reverse(alu_data1_i);\n  wire [32:0] shift  = {alu_op_i[3] &amp; shin[31], shin};\n  wire [32:0] shiftt = ($signed(shift) &gt;&gt;&gt; shamt);\n  wire [31:0] shiftr = shiftt[31:0];\n  wire [31:0] shiftl = reverse(shiftr);\n\n  always @(*) begin\n    case(alu_op_i)\n      `ALU_OP_ADD:    result &lt;= sum;\n      `ALU_OP_SUB:    result &lt;= sum;\n      `ALU_OP_SLL:    result &lt;= shiftl;\n      `ALU_OP_SLT:    result &lt;= cmp;\n      `ALU_OP_SLTU:   result &lt;= cmp;\n      `ALU_OP_XOR:    result &lt;= (alu_data1_i ^ alu_data2_i);\n      `ALU_OP_SRL:    result &lt;= shiftr;\n      `ALU_OP_SRA:    result &lt;= shiftr;\n      `ALU_OP_OR:     result &lt;= (alu_data1_i | alu_data2_i);\n      `ALU_OP_AND:    result &lt;= (alu_data1_i &amp; alu_data2_i);\n\n      `ALU_OP_EQ:     result &lt;= {31'b0, ~neq};\n      `ALU_OP_NEQ:    result &lt;= {31'b0, neq};\n      `ALU_OP_GE:     result &lt;= {31'b0, ~cmp};\n      `ALU_OP_GEU:    result &lt;= {31'b0, ~cmp};\n      default:        begin \n                      result &lt;= 32'b0; \n        end\n    endcase\n  end\n\n  function [31:0] reverse;\n    input [31:0] in;\n    integer i;\n    for(i=0; i&lt;32; i=i+1) begin\n      reverse[i] = in[31-i];\n    end\n  endfunction  \n\n  assign alu_result_o = result;\n\nendmodule\n</code></pre><p>在上面的ALU模块代码中，输入信号aluIn1和aluIn2分别是源操作数1和源操作数2，信号aluOp是执行控制模块产生的ALU运算控制码。ALU的功能就是根据运算码aluOp来完成两个源操作数的逻辑运算，并把结果通过信号aluOut输出。</p><p>ALU模块的总体代码比较简单，但里面这段代码（第16行～第19行）不好理解，别担心，我这里专门拿出来给你讲一下。</p><pre><code class=\"language-verilog\">  wire [31:0] sum    = aluIn1 + ((aluOp[3] | aluOp[1]) ? -aluIn2 : aluIn2);\n  wire        neq    = |sum;\n  wire        cmp    = (aluIn1[31] == aluIn2[31]) ? sum[31]\n                       : aluOp[0] ? aluIn2[31] : aluIn1[31];\n</code></pre><p>首先，代码中的sum信号其实就是两个源操作数的和，不过当运算码aluOp的第3位和第1位为“1”时做的是相减运算，这是为减法指令或者后面的比较大小而准备的运算。你可以对照上面的ALU运算表格来理解。</p><p>neq信号表示的是比较两个操作数是否相等，这就是根据前面的两个操作相减的结果判断，如果它们的差不为“0”，也就是sum信号按位与之后不为“0”，则表示两个操作数不相等。</p><p>cmp信号表示两个操作数的大小比较，如果它们的最高位（也就是符号位）相等，则根据两个操作数相减的差值的符号位（也是数值的最高位）判断。如果是正数，表示源操作数1大于源操作数2，否则表示源操作数1小于源操作数2。</p><p>如果它们的最高位不相等，则根据ALU运算控制码aluOp的最低位判断。如果aluOp最低位为“1”，表示是无符号数比较，直接取操作数2的最高位作为比较结果。如果aluOp最低位为“0”，表示是有符号数比较，直接取操作数1的最高位作为比较结果。</p><p>下面我们再来看看<strong>移位操作相关的代码</strong>，其中的shamt信号是取自源操作数2的低五位，表示源操作数1需要移多少位（25=32）。shin信号是取出要移位的数值，根据aluOp判断是左移还是右移，如果是右移就直接等于源操作数1，如果是左移就先对源操作数的各位数做镜像处理。</p><p>shift信号是根据aluOp判断是算术右移还是逻辑右移，如果是算术右移，则在最高位补一个符号位。shiftt信号是右移之后的结果，这里用到了<span dollar=\"\">$</span>signed()函数对移位前的数据shift进行了修饰，$signed()的作用是决定如何对操作数扩位这个问题。</p><p>具体的过程是，在右移操作前，$signed()函数先把操作数的符号位，扩位成跟结果相同的位宽，然后再进行移位操作，而shiftr就是右移后的结果。</p><p>我们再专门看看ALU模块代码的第20行到第25行，这部分主要用来完成移位操作。</p><pre><code class=\"language-verilog\">  wire [ 4:0] shamt  = aluIn2[4:0];\n  wire [31:0] shin   = aluOp[2] ? aluIn1 : reverse(aluIn1);\n  wire [32:0] shift  = {aluOp[3] &amp; shin[31], shin};\n  wire [32:0] shiftt = ($signed(shift) &gt;&gt;&gt; shamt);\n  wire [31:0] shiftr = shiftt[31:0];\n  wire [31:0] shiftl = reverse(shiftr);\n</code></pre><p>请你注意，<strong>左移的结果shiftl，是由右移后的结果进行位置取反得到的</strong>。因为对于需要左移的操作数，在前面已经做了位置取反，所以移位操作时也是进行右移处理，最后把结果再一次做位置取反就可以了。<br>\n好了，恭喜你走到这里，CPU流水线中执行阶段的内容就告一段落了。下一节课我们继续完成流水线的访存模块的设计。</p><h2>重点回顾</h2><p>这节课告一段落，我来给你做个总结。</p><p>指令执行算是CPU流水线中最复杂的一个阶段了，需要我们慢慢推导，细细思考，才能理清楚里面的逻辑关系。这节课的内容和前面的第五节课到第七节课的知识关联比较多，不懂的地方你可以再回去看看。</p><p>下面我们一起来回顾一下今天的重点内容。为了实现CPU的指令执行模块，我们先梳理了设计思路。我们把指令分成逻辑运算、存储器访问、条件分支判断这三类指令进行处理。这三类指令经过ALU执行相关操作之后，统一由数据通路来输出结果。</p><p>接着我们设计了执行控制模块。根据译码模块里产生的指令控制字段aluCrtlOp，执行控制模块可以根据上述的三类指令，相应产生一个4位的ALU操作信号aluOp，为后面的ALU模块提供运算执行码。</p><p>根据指令在流水线中执行时对通用寄存器的读写特点，我们为32个通用寄存器组设计了<strong>由两个套读接口和一套写接口组成的通用寄存器模块，这三套接口可以支持其他模块对通用寄存器进行同时读写。</strong></p><p>最后，根据执行控制模块产生的ALU运算控制信号aluOp，我们设计出了ALU模块。在ALU模块中，可以完成加减法计算，两个操作数的大小比较，操作数的左移右移等操作。</p><p><img src=\"https://static001.geekbang.org/resource/image/65/f0/6538fa1bc1829f2f24cf1197fb579ef0.jpg?wh=1920x1466\" alt=\"图片\"></p><p>如果你有兴趣的话，可以参考前面RISC-V指令架构里列出的指令，自己试试实现更多的指令操作。下节课，我们继续探索访存相关模块如何设计和实现，敬请期待。</p><h2>思考题</h2><p>在ALU模块代码中，为什么要把左移操作转换为右移进行处理？</p><p>欢迎你在留言区跟我交流讨论，积极参与思考有助于你深化理解。如果觉得这节课还不错，别忘了分享给身边的朋友，邀他跟你一起手写CPU！</p>","neighbors":{"left":{"article_title":"07｜手写CPU（二）：如何实现指令译码模块？","id":548002},"right":{"article_title":"09｜手写CPU（四）：如何实现CPU流水线的访存阶段？","id":550940}}},{"article_id":550940,"article_title":"09｜手写CPU（四）：如何实现CPU流水线的访存阶段？","article_content":"<p>你好，我是LMOS。</p><p>先简单回顾一下上一节课，我们设计了MiniCPU流水线的执行相关模块。其中包括执行控制模块、通用寄存器模块，以及可以进行加减法运算、大小比较、移位操作的ALU模块。</p><p>指令执行之后就到了流水线的下一级——访存。这节课我们就重点聊聊怎么设计实现访存的相关模块。在你的设想里，访存模块必要的组成部分有哪些呢？</p><p>如果你的第一反应是访存控制模块，我只能说你只答对了一部分。访存控制模块虽然是流水线的主线，但你可能忽略了流水线中的数据相关性问题。因此，今天我们先想办法解决流水线的数据冒险问题，然后再完成流水线访存阶段相关模块的设计。</p><p>这节课的代码你可以从<a href=\"https://gitee.com/lmos/Geek-time-computer-foundation/tree/master/lesson06~11/mini_cpu\">这里</a>获取。</p><h2>流水线数据冒险</h2><p>在开始设计访存模块之前，我们得先解决一个问题，即流水线的数据冒险。</p><p>在CPU流水线里，执行不同的指令时会发生这样的情况：一条指令B，它依赖于前面还在流水线中的指令A的执行结果。当指令B到达执行阶段时，因为指令A还在访存阶段，所以这时候就无法提供指令B执行所需要的数据。这就导致指令B无法在预期的时钟周期内执行。</p><p><strong>当指令在流水线中重叠执行时，后面的指令需要用到前面的指令的执行结果，而前面的指令结果尚未写回，由此导致的冲突就叫数据冒险</strong>。</p><!-- [[[read_end]]] --><p>我再举个更具体些的例子。比如，有一条减法指令，它需要用到前面一条加法指令的运算结果作为被减数：</p><pre><code class=\"language-plain\">add\tx2,x0,x1\nsub x6,x2,x3\n</code></pre><p>结合下面的示意图，我们可以看到，在不做任何干预的情况下，sub依赖于add的执行结果，这导致sub指令要等到add指令走到流水线的第五个阶段，把结果写回之后才能执行，这就浪费了三个时钟周期。</p><p><img src=\"https://static001.geekbang.org/resource/image/72/5f/727431ce8a824f12541ea00a6863355f.jpg?wh=1920x624\" alt=\"图片\"></p><p>这种数据冒险将会严重地阻碍CPU的流水线，设置流水线目的就是为了提升效率，让某个时间点上有多条指令可以同时执行，这种让指令“干等”的状态显然不是最佳选项。那我们怎么解决这样的问题呢？方法其实不止一种，让我带你分析分析。</p><p>结合前的例子，我们最直接的处理办法就是通过编译器调整一些指令顺序。不过指令存在依赖关系的情况经常发生，用编译器调整的方式会导致延迟太长，处理的结果无法让我们满意。</p><p>别灰心，我们再另寻出路。把前面的加法指令add放到流水线中，通过观察整个运算过程，我们不难发现，其实add加法运算的结果，经过流水线的执行阶段（也就是第三个模块EX）之后就已经出来了，只是还没把结果写回到x2寄存器而已。</p><p><img src=\"https://static001.geekbang.org/resource/image/85/0d/856yy7f373d45a5de8e5881b46bc030d.jpg?wh=1920x624\" alt=\"图片\"></p><p>所以，另一种解决办法也就有了头绪，能不能通过向内部资源添加额外的硬件，来尽快找到缺少的运算项呢？</p><p>这当然可以。对于上述的指令序列，一旦ALU计算出加法指令的结果，就可以将其作为减法指令执行的数据输入，不需要等待指令完成，就可以解决数据冒险的问题。</p><p>如上图所示，将add指令执行阶段运算的结果x2中的值，直接传递给sub指令作为执行阶段的输入，替换sub指令在译码阶段读出的寄存器x2的值。这种硬件上解决数据冒险的方法称为前递（forwarding）。</p><p>好，思路既然理清楚了，我们就把它落地到实际设计里。</p><h2>数据前递模块的设计</h2><p>通过上节课执行模块的设计，我们知道了ALU的逻辑运算需要两个操作数，一个来自于通用寄存器，另一个来自于通用寄存器或者指令自带的立即数。</p><p>但是当需要读取的通用寄存器的值，依赖于前面第一条或者第二条指令的运算结果时，就出现了刚才我们提到的数据冒险问题。为了解决这个问题，就需要我们专门设计一个数据前递模块（forwarding），它在流水线中的位置如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/86/ab/867b43606a4e52777003f20cbcb61cab.jpg?wh=1920x624\" alt=\"图片\"></p><p><strong>所谓前递，顾名思义，就是把流水线中后面阶段产生的数据向前传递的过程。</strong></p><p>正如上图中的forwarding模块，可以看到它的数据来自于流水线中的执行模块EX、访存模块MEM、写回模块WB的输出，经过forwarding模块处理后，把数据传递到执行模块的输入。</p><p>然后，流水线根据当前指令的译码信号，选择读取通用寄存器的数据作为执行模块的操作数，或者选择来自前递模块的数据作为执行模块的操作数。</p><p>那么具体是如何选择前递数据作为执行模块的操作数呢？让我们结合下面forwarding模块的代码来寻找答案：</p><pre><code class=\"language-verilog\">module forwarding (\n  input [4:0] rs1,\n  input [4:0] rs2,\n  input [4:0] exMemRd,\n  input       exMemRw,\n  input [4:0] memWBRd,\n  input       memWBRw,\n  input        mem_wb_ctrl_data_toReg,\n  input [31:0] mem_wb_readData,\n  input [31:0] mem_wb_data_result,\n  input [31:0] id_ex_data_regRData1,\n  input [31:0] id_ex_data_regRData2,\n  input [31:0] ex_mem_data_result,\n\n  output [31:0] forward_rs1_data,\n  output [31:0] forward_rs2_data\n);\n  //检查是否发生数据冒险\n  wire [1:0] forward_rs1_sel = (exMemRw &amp; (rs1 == exMemRd) &amp; (exMemRd != 5'b0)) ? 2'b01\n                              :(memWBRw &amp; (rs1 == memWBRd) &amp; (memWBRd != 5'b0)) ? 2'b10\n                              : 2'b00;\n                  \n  wire [1:0] forward_rs2_sel = (exMemRw &amp; (rs2 == exMemRd) &amp; (exMemRd != 5'b0)) ? 2'b01\n                              :(memWBRw &amp; (rs2 == memWBRd) &amp; (memWBRd != 5'b0)) ? 2'b10\n                              : 2'b00;\n\n  wire [31:0] regWData = mem_wb_ctrl_data_toReg ? mem_wb_readData : mem_wb_data_result; \n\n  //根据数据冒险的类型选择前递的数据\n  assign forward_rs1_data = (forward_rs1_sel == 2'b00) ? id_ex_data_regRData1 :\n                            (forward_rs1_sel == 2'b01) ? ex_mem_data_result   :\n                            (forward_rs1_sel == 2'b10) ? regWData : 32'h0; \n\n  assign forward_rs2_data = (forward_rs2_sel == 2'b00) ? id_ex_data_regRData2 :\n                            (forward_rs2_sel == 2'b01) ? ex_mem_data_result   :\n                            (forward_rs2_sel == 2'b10) ? regWData : 32'h0; \nendmodule\n</code></pre><p>我们分别看看代码中的各种信号。前递模块输入的端口信号rs1和rs2，来自于指令译码后得到的两个通用寄存器索引。exMemRd信号是来自访存模块的对通用寄存器的访问地址。exMemRw是流水线访存阶段对通用寄存器的写使能控制信号。memWBRd 和 memWBRw分别是写回模块对通用寄存器的地址和写使能控制信号。</p><p>利用这些信号就可以判断是否发生数据冒险，我们结合下面这段代码继续分析分析：</p><pre><code class=\"language-verilog\">  //检查是否发生数据冒险\n  wire [1:0] forward_rs1_sel = (exMemRw &amp; (rs1 == exMemRd) &amp; (exMemRd != 5'b0)) ? 2'b01\n                              :(memWBRw &amp; (rs1 == memWBRd) &amp; (memWBRd != 5'b0)) ? 2'b10\n                              : 2'b00;\n                  \n  wire [1:0] forward_rs2_sel = (exMemRw &amp; (rs2 == exMemRd) &amp; (exMemRd != 5'b0)) ? 2'b01\n                              :(memWBRw &amp; (rs2 == memWBRd) &amp; (memWBRd != 5'b0)) ? 2'b10\n                              : 2'b00;\n</code></pre><p><strong>当需要读取的通用寄存器的地址等于访存，或者写回阶段要访问通用寄存器地址时（也就是rs1 == exMemRd和rs1 == memWBRd），就判断为将要发生数据冒险。</strong></p><p>当然，由于通用寄存器中的零寄存器的值永远为“0”，所以不会发生数据冒险，需要排除掉这种特殊情况（也就是exMemRd != 5’b0 和 memWBRd != 5’b0）。根据这样的判断结果，就会产生前递数据的两个选择信号forward_rs1_sel和forward_rs2_sel。</p><p>发生数据冒险的情况就是这样，那不发生数据冒险又是什么情况呢？下面是选择前递的数据对应的代码段，我们结合这段代码继续分析。</p><pre><code class=\"language-verilog\">  //根据数据冒险的类型选择前递的数据\n  assign forward_rs1_data = (forward_rs1_sel == 2'b00) ? id_ex_data_regRData1 :\n                            (forward_rs1_sel == 2'b01) ? ex_mem_data_result   :\n                            (forward_rs1_sel == 2'b10) ? regWData : 32'h0; \n\n  assign forward_rs2_data = (forward_rs2_sel == 2'b00) ? id_ex_data_regRData2 :\n                            (forward_rs2_sel == 2'b01) ? ex_mem_data_result   :\n                            (forward_rs2_sel == 2'b10) ? regWData : 32'h0; \n</code></pre><p>我们先把目光聚焦到id_ex_data_regRData1和id_ex_data_regRData2这两个信号上。它们来自于指令译码之后读出通用寄存器的两个操作数，这是流水线不发生数据冒险时，流水线正常选择的数据通路。</p><p>而ex_mem_data_result 信号是访存阶段需要写到通用寄存器的数据，regWData是回写阶段需要更新到通用寄存器的数据。这样，通过判断将要发生数据冒险的位置，前递模块选择性地把处于流水线中的数据前递，就可以巧妙地解决流水线中的数据冒险问题了。</p><h2>访存控制模块设计</h2><p>好了，解决了流水线的数据冒险问题，让我们回到流水线设计的主线来，继续完成流水线的第四级——访存相关模块的设计。</p><p>在<a href=\"https://time.geekbang.org/column/article/54792\">第六节课</a>讲CPU流水线的时候我们提到过，流水线中一条指令的生命周期分为五个阶段。流水线的访存阶段就是指，将数据从存储器中读出或写入存储器的过程。这个阶段会出现由 LOAD / STORE 指令产生的内存访问。</p><p>因为访存阶段的功能就是对存储器读写，所以访存控制信号中，最重要的两个信号就是<strong>存储器读控制信号memRead</strong> 和<strong>写控制信号memWrite</strong>。当然，访存的控制信号通路也会受流水线冲刷等流水线管理信号的控制，具体的代码如下：</p><pre><code class=\"language-verilog\">module ex_mem_ctrl(\n  input        clk,\n  input        reset,\n  input        in_mem_ctrl_memRead,   //memory读控制信号\n  input        in_mem_ctrl_memWrite,  //memory写控制信号\n  input  [1:0] in_mem_ctrl_maskMode,  //mask模式选择\n  input        in_mem_ctrl_sext,      //符合扩展\n  input        in_wb_ctrl_toReg,      //写回寄存器的数据选择，“1”时为mem读取的数据\n  input        in_wb_ctrl_regWrite,   //寄存器写控制信号\n  input        flush,                 //流水线数据冲刷信号\n  output       out_mem_ctrl_memRead,\n  output       out_mem_ctrl_memWrite,\n  output [1:0] out_mem_ctrl_maskMode,\n  output       out_mem_ctrl_sext,\n  output       out_wb_ctrl_toReg,\n  output       out_wb_ctrl_regWrite\n);\n\n  reg  reg_mem_ctrl_memRead; \n  reg  reg_mem_ctrl_memWrite; \n  reg [1:0] reg_mem_ctrl_maskMode; \n  reg  reg_mem_ctrl_sext; \n  reg  reg_wb_ctrl_toReg; \n  reg  reg_wb_ctrl_regWrite; \n\n  assign out_mem_ctrl_memRead = reg_mem_ctrl_memRead; \n  assign out_mem_ctrl_memWrite = reg_mem_ctrl_memWrite; \n  assign out_mem_ctrl_maskMode = reg_mem_ctrl_maskMode; \n  assign out_mem_ctrl_sext = reg_mem_ctrl_sext; \n  assign out_wb_ctrl_toReg = reg_wb_ctrl_toReg; \n  assign out_wb_ctrl_regWrite = reg_wb_ctrl_regWrite; \n  \n  always @(posedge clk or posedge reset) begin\n    if (reset) begin \n      reg_mem_ctrl_memRead &lt;= 1'h0; \n    end else if (flush) begin \n      reg_mem_ctrl_memRead &lt;= 1'h0; \n    end else begin \n      reg_mem_ctrl_memRead &lt;= in_mem_ctrl_memRead; \n    end\n  end\n\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin \n      reg_mem_ctrl_memWrite &lt;= 1'h0; \n    end else if (flush) begin \n      reg_mem_ctrl_memWrite &lt;= 1'h0; \n    end else begin \n      reg_mem_ctrl_memWrite &lt;= in_mem_ctrl_memWrite; \n    end\n  end\n  \n  …………  //由于代码较长，结构相似，这里省略了一部分，完整代码你可以从Gitee上获取\n  \nendmodule\n</code></pre><p>虽然代码有几十行，但过程还是很容易理解的。首先要根据流水线的冲刷控制信号flush，判断访存阶段的控制信号是否需要清零。</p><p>如果flush等于“0”，就把上一阶段送过来的控制信号（比如存储器读控制信号memRead、存储器写控制信号memWrite……等），通过寄存器保存下来，然后发送给存储器读写控制模块（dmem_rw.v）或者流水线的下一级使用。</p><h2>访存数据通路模块设计</h2><p>接下来，我们继续完成访存数据通路模块的设计。访存数据通路就是把访存阶段读取到的存储器数据，或者是指令执行产生的结果发送流水线的下一级处理。</p><p>由于下一级也就是流水线的最后一级——写回，所以访存的数据通路主要包括要写回的通用寄存器地址regWAddr、访问存储器读取的数据regRData2、指令运算的结果result等。</p><p>访存的数据通路也会受流水线冲刷等流水线管理信号的控制，具体代码如下：</p><pre><code class=\"language-verilog\">module ex_mem(\n  input         clk,\n  input         reset,\n  input  [4:0]  in_regWAddr,    //写回寄存器的地址\n  input  [31:0] in_regRData2,   //读存储器的数据\n  input  [1:0]  ex_result_sel,  //执行结果选择\n  input  [31:0] id_ex_data_imm, //指令立即数\n  input  [31:0] alu_result,     //ALU运算结果\n  input  [31:0] in_pc,          //当前PC值\n  input         flush,          //流水线数据冲刷控制信号\n  output [4:0]  data_regWAddr,\n  output [31:0] data_regRData2,\n  output [31:0] data_result,\n  output [31:0] data_pc\n);\n  reg [4:0] reg_regWAddr; \n  reg [31:0] reg_regRData2; \n  reg [31:0] reg_result; \n  reg [31:0] reg_pc; \n\n  wire [31:0] resulet_w = (ex_result_sel == 2'h0) ? alu_result :\n                          (ex_result_sel == 2'h1) ? id_ex_data_imm :\n                          (ex_result_sel == 2'h2) ? (in_pc +32'h4) : 32'h0;\n  assign data_regWAddr = reg_regWAddr; \n  assign data_regRData2 = reg_regRData2; \n  assign data_result = reg_result; \n  assign data_pc = reg_pc; \n\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin \n      reg_regWAddr &lt;= 5'h0; \n    end else if (flush) begin \n      reg_regWAddr &lt;= 5'h0; \n    end else begin \n      reg_regWAddr &lt;= in_regWAddr; \n    end\n  end\n\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin \n      reg_regRData2 &lt;= 32'h0; \n    end else if (flush) begin \n      reg_regRData2 &lt;= 32'h0; \n    end else begin \n      reg_regRData2 &lt;= in_regRData2; \n    end\n  end\n\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin \n      reg_result &lt;= 32'h0; \n    end else if (flush) begin \n      reg_result &lt;= 32'h0; \n    end else begin \n      reg_result &lt;= resulet_w; \n    end\n  end\n  \n  always @(posedge clk or posedge reset) begin\n    if (reset) begin \n      reg_pc &lt;= 32'h0; \n    end else if (flush) begin \n      reg_pc &lt;= 32'h0; \n    end else begin \n      reg_pc &lt;= in_pc; \n    end\n  end\nendmodule\n</code></pre><p>和上面的访存控制模块类似，访存数据通路模块也是根据流水线的冲刷控制信号flush，判断访存阶段的数据是否需要清零。如果不需要清零，就把上一阶段送过来的数据通过寄存器保存下来。</p><p>对于代码的第21到第23行代码，我为你单独解释一下。</p><p>ex_result_sel就是对流水线执行阶段的结果进行选择。当（ex_result_sel == 2’h0）时，就选择ALU的运算结果；当（ex_result_sel == 2’h1）时，就会选择指令解码得到的立即数（其实就是对应LUI指令）；当（ex_result_sel == 2’h1）时，选择PC加4的值，也就是下一个PC的值。</p><pre><code class=\"language-verilog\">  wire [31:0] resulet_w = (ex_result_sel == 2'h0) ? alu_result :\n                          (ex_result_sel == 2'h1) ? id_ex_data_imm :\n                          (ex_result_sel == 2'h1) ? (in_pc +32'h4) : 32'h0;\n</code></pre><h2>重点回顾</h2><p>这节课的内容到这里就告一段落了，我给你做个总结吧。</p><p>今天我们在设计访存模块之前，先探讨了流水线中的数据冒险问题。在执行指令时，如果发生了数据冒险，就可能使流水线停顿，等待前面的指令执行完成后才能继续执行后续的指令，严重影响了指令在CPU流水线中并行执行。因此，我们设计了<strong>数据前递模块</strong>来解决数据冒险的问题。</p><p>但是，添加前递模块并不能避免所有的流水线停顿。比如，当一条读存储器指令（LOAD）之后紧跟一条需要使用其结果的R型指令时，就算使用前递也需要流水线停顿。因为读存储器的数据必须要在访存之后才能用，但load指令正在访存时，后一条指令已经在执行。所以，在这种情况下，流水线必须停顿，通常的说法是<strong>在两条指令之间插入气泡</strong>。</p><p>最后，我们根据流水线的控制信号，完成了访存控制信号通路和访存数据通路的模块设计。这节课的要点你可以参考下面的导图。</p><p><img src=\"https://static001.geekbang.org/resource/image/94/53/9407395b0d8dc0eef24878c1a9978353.jpg?wh=1920x1763\" alt=\"图片\"></p><p>通过课程的讲解，CPU流水线中访存阶段的设计实现的思路，相信你已经心中有数了，别忘了课后结合配套代码再找找“手感”。下节课，我们将会介绍流水线的最后一级——写回模块的设计，敬请期待。</p><h2>思考题</h2><p>除了数据冒险，我们的CPU流水线是否还存在其它的冲突问题，你想到解决方法了么？</p><p>欢迎你在留言区和我交流，踊跃提问或者记录笔记对我们加深理解有很大的帮助。如果你觉得这节课还不错，别忘了分享给更多朋友，和他一起手写CPU。</p>","neighbors":{"left":{"article_title":"08｜手写CPU（三）：如何实现指令执行模块？","id":550393},"right":{"article_title":"10｜手写CPU（五）：CPU流水线的写回模块如何实现？","id":552136}}},{"article_id":552136,"article_title":"10｜手写CPU（五）：CPU流水线的写回模块如何实现？","article_content":"<p>你好，我是LMOS。</p><p>今天我们一起来完成迷你CPU的最后一个部分——写回相关模块的设计（课程代码在<a href=\"https://gitee.com/lmos/Geek-time-computer-foundation/tree/master/lesson06~11/mini_cpu\">这里</a>）。</p><p>简单回顾一下，上节课我们完成了CPU流水线的访存相关模块的设计。在设计访存模块之前，我们发现流水线中存在数据冒险的问题。为了解决这个问题，我们设计了数据前递模块。</p><p>但是我们采用的数据前递模块，只局限于解决算术操作和数据传输中的冒险问题。在CPU流水线中还可能存在结构冒险和控制冒险的问题，我们在进行流水线规划时，已经合理地避免了结构冒险。但是，控制冒险还可能出现，下面我们就来探讨一下流水线的控制冒险问题。</p><h2>流水线控制冒险</h2><p>还记得前面我们说过的条件分支指令吗？就是根据指令设置的数值比较结果，改变并控制跳转的方向，比如beq和bne指令。</p><p>假如在流水线取出分支指令后，紧跟着在下一个时钟周期就会取下一条指令。但是，流水线并不知道下一条指令应该从哪里取，因为它刚从存储器中取出分支指令，还不能确定上一条分支指令是否会发生跳转。</p><p>上面这种<strong>流水线需要根据上一条指令的执行结果决定下一步行为的情况，就是流水线中的控制冒险。</strong>这时候该怎么办呢？</p><p><img src=\"https://static001.geekbang.org/resource/image/62/32/622a15b75c71667b81b71a328bc98d32.jpg?wh=1920x704\" alt=\"图片\"></p><p>控制冒险可以使用流水线停顿的方法解决，就是在取出分支指令后，流水线马上停下来，等到分支指令的结果出来，确定下一条指令从哪个地址取之后，流水线再继续。</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/ed/ae/edb0932e626b436a923a30d7756c58ae.jpg?wh=1920x772\" alt=\"图片\"></p><p>如上图所示，每当遇到条件分支指令时，流水线就停顿以避免控制冒险。但是这种方法对性能的影响是很大的。因为条件分支指令要等到执行之后的访存阶段，才能决定分支跳转是否发生，这就相当于流水线停顿了2个时钟周期。我们MiniCPU只有五级流水线，就停顿了这么久，像intel 的酷睿 i7处理器流水线，它的深度有十几级，如果也用停顿的方法，那延时损失就更大了。</p><p>既然阻塞流水线直到分支指令执行完成的方法非常耗时，浪费了太多流水线的时钟周期。那么，有没有一种方法既能解决控制冒险问题，又不影响流水线的性能呢？</p><p>很遗憾，答案是否定的。到目前为止，我们还没有找到根本性的解决控制冒险问题的方法。</p><p><img src=\"https://static001.geekbang.org/resource/image/ea/cf/ea6ba162417462ae1797abc3e89b70cf.jpg?wh=1920x809\" alt=\"图片\"></p><p>但是，这并不代表我们没有办法去优化它，我们可以采用<strong>分支预测</strong>的方法提升分支阻塞的效率。</p><p>具体思路是这样的，当每次遇到条件分支指令时，预测分支会发生跳转，直接在分支指令的下一条取跳转后相应地址的指令。如果分支发生跳转的概率是50%，那么这种优化方式就可以减少一半由控制冒险带来的性能损失。</p><p>其实我们<a href=\"https://time.geekbang.org/column/article/547921\">第六节课</a>取指阶段设计的预读取模块（if_pre.v），实现的就是这个功能，相关代码如下：</p><pre><code class=\"language-verilog\">    wire is_bxx = (instr[6:0] == `OPCODE_BRANCH);   //条件挑转指令的操作码\n    wire is_jal = (instr[6:0] == `OPCODE_JAL) ;     //无条件跳转指令的操作码\n    \n    //B型指令的立即数拼接\n    wire [31:0] bimm  = {{20{instr[31]}}, instr[7], instr[30:25], instr[11:8], 1'b0};\n    //J型指令的立即数拼接\n    wire [31:0] jimm  = {{12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0};\n\n    //指令地址的偏移量\n    wire [31:0] adder = is_jal ? jimm : (is_bxx &amp; bimm[31]) ? bimm : 4;\n\n    assign pre_pc = pc + adder;\n</code></pre><p>看到这你可能还有疑问，如果条件分支不发生跳转的话又会怎么样呢？这种情况下，已经被读取和译码的指令就会被丢弃，流水线继续从不分支的地址取指令。</p><p>要想丢弃指令也不难，只需要把流水线中的控制信号和数据清“0”即可，也就是当预测失败的分支指令执行之后，到达访存阶段时，需要将流水线中处于取指、译码和执行阶段的指令清除。</p><p>我先展示一下控制冒险模块的整体代码，之后再详细解读。代码如下所示：</p><pre><code class=\"language-verilog\">module hazard (\n  input  [4:0]  rs1,\n  input  [4:0]  rs2,\n  input         alu_result_0,\n  input  [1:0]  id_ex_jump,\n  input         id_ex_branch,\n  input         id_ex_imm_31,\n  input         id_ex_memRead,\n  input         id_ex_memWrite,\n  input  [4:0]  id_ex_rd,\n  input  [1:0]  ex_mem_maskMode,\n  input         ex_mem_memWrite,\n\n  output reg    pcFromTaken,\n  output reg    pcStall,\n  output reg    IF_ID_stall,\n  output reg    ID_EX_stall,\n  output reg    ID_EX_flush,\n  output reg    EX_MEM_flush,\n  output reg    IF_ID_flush\n);\n\n  wire branch_do = ((alu_result_0 &amp; ~id_ex_imm_31) | (~alu_result_0 &amp; id_ex_imm_31));\n  wire ex_mem_taken = id_ex_jump[0] | (id_ex_branch &amp; branch_do);\n\n  wire id_ex_memAccess = id_ex_memRead | id_ex_memWrite; \n\n  wire ex_mem_need_stall = ex_mem_memWrite &amp; (ex_mem_maskMode == 2'h0 | ex_mem_maskMode == 2'h1); \n\n  always @(*) begin\n    if(id_ex_memAccess &amp;&amp; ex_mem_need_stall) begin\n      pcFromTaken  &lt;= 0;\n      pcStall      &lt;= 1;\n      IF_ID_stall  &lt;= 1;\n      IF_ID_flush  &lt;= 0;\n      ID_EX_stall  &lt;= 1;\n      ID_EX_flush  &lt;= 0;\n      EX_MEM_flush &lt;= 1;\n    end\n    else if(ex_mem_taken) begin \n      pcFromTaken  &lt;= 1;\n      pcStall      &lt;= 0; \n      IF_ID_flush  &lt;= 1;\n      ID_EX_flush  &lt;= 1;\n      EX_MEM_flush &lt;= 0;\n    end\n    else if(id_ex_memRead &amp; (id_ex_rd == rs1 || id_ex_rd == rs2)) begin\n      pcFromTaken &lt;= 0;\n      pcStall     &lt;= 1;\n      IF_ID_stall &lt;= 1;\n      ID_EX_flush &lt;= 1;\n    end\n    else begin\n      pcFromTaken    &lt;= 0;  \n      pcStall        &lt;= 0; \n      IF_ID_stall    &lt;= 0;\n      ID_EX_stall    &lt;= 0;\n      ID_EX_flush    &lt;= 0;\n      EX_MEM_flush   &lt;= 0;  \n      IF_ID_flush    &lt;= 0;\n    end\n  end\nendmodule\n</code></pre><p>首先我们来看看在控制冒险模块中，内部产生的几个信号都起到了怎样的作用。<br>\nbranch_do 信号就是条件分支指令的条件比较结果，由ALU运算结果和立即数的最高位（符合位）通过“与”操作得到；ex_mem_taken是确认分支指令跳转的信号，由无条件跳转（jump）“或”条件分支指令（branch）产生。</p><p>id_ex_memAccess是存储器的选通信号，当对存储器的“读”或者“写”控制信号有效时产生；ex_mem_need_stall信号表示流水线需要停顿，当执行sb或者sh指令时就会出现这样的情况。</p><p>然后，再来看看我们这个模块要输出的几个信号。</p><pre><code class=\"language-verilog\">  wire branch_do = ((alu_result_0 &amp; ~id_ex_imm_31) | (~alu_result_0 &amp; id_ex_imm_31));\n  wire ex_mem_taken = id_ex_jump[0] | (id_ex_branch &amp; branch_do);\n\n  wire id_ex_memAccess = id_ex_memRead | id_ex_memWrite; \n\n  wire ex_mem_need_stall = ex_mem_memWrite &amp; (ex_mem_maskMode == 2'h0 | ex_mem_maskMode == 2'h1); \n</code></pre><p>pcFromTaken是分支指令执行之后，判断和分支预测方向是否一致的信号。pcStall是控制程序计数器停止的信号，如果程序计数器停止，那么流水线将不会读取新的指令。IF_ID_stall是流水线中从取指到译码的阶段的停止信号。ID_EX_stall是流水线从译码到执行阶段的停止信号。</p><p>此外，当流水线需要冲刷时，就会产生取指、译码、执行、访存阶段的清零信号，分别对应着ID_EX_flush、EX_MEM_flush和IF_ID_flush信号。</p><pre><code class=\"language-verilog\">  output reg    pcFromTaken,  //分支指令执行结果，判断是否与预测方向一样\n  output reg    pcStall,\t  //程序计数器停止信号\n  output reg    IF_ID_stall,\t//流水线IF_ID段停止信号\n  output reg    ID_EX_stall,\t//流水线ID_EX段停止信号\n  output reg    ID_EX_flush,\t//流水线ID_EX段清零信号\n  output reg    EX_MEM_flush,   //流水线EX_MEM段清零信号\n  output reg    IF_ID_flush\t\t//流水线IF_ID段清零信号\n</code></pre><p>什么情况下才会产生上面的控制信号呢？一共有三种情况，我这就带你依次分析一下。<br>\n<strong>第一种情况是解决数据相关性问题。</strong>数据相关指的是指令之间存在的依赖关系。当两条指令之间存在相关关系时，它们就不能在流水线中重叠执行。</p><p>例如，前一条指令是访存指令Store，后一条也是Load或者Store指令，因为我们采用的是同步RAM，需要先读出再写入，占用两个时钟周期，所以这时要把之后的指令停一个时钟周期。</p><pre><code class=\"language-verilog\">    if(ID_EX_memAccess &amp;&amp; EX_MEM_need_stall) begin\n      pcFromTaken  &lt;= 0;\n      pcStall      &lt;= 1;\n      IF_ID_stall  &lt;= 1;\n      IF_ID_flush  &lt;= 0;\n      ID_EX_stall  &lt;= 1;\n      ID_EX_flush  &lt;= 0;\n      EX_MEM_flush &lt;= 1;\n    end\n</code></pre><p><strong>第二种情况是分支预测失败的问题，</strong>当分支指令执行之后，如果发现分支跳转的方向与预测方向不一致。这时就需要冲刷流水线，清除处于取指、译码阶段的指令数据，更新PC值。</p><pre><code class=\"language-verilog\"> // 分支预测失败，需要冲刷流水线，更新pc值\n    else if(EX_MEM_taken) begin \n      pcFromTaken  &lt;= 1; \n      pcStall      &lt;= 0; \n      IF_ID_flush  &lt;= 1;\n      ID_EX_flush  &lt;= 1;\n      EX_MEM_flush &lt;= 0; \n    end\n</code></pre><p>第三种情况就是解决<a href=\"https://time.geekbang.org/column/article/550940\">上一节课</a>提到的<strong>数据冒险问题</strong>。当前一条指令是 Load，后一条指令的源寄存器 rs1和rs2依赖于前一条从存储器中读出来的值，需要把 Load 指令之后的指令停顿一个时钟周期，而且还要冲刷ID _EX阶段的指令数据。</p><pre><code class=\"language-verilog\">    else if(ID_EX_memRead &amp; (ID_EX_rd == rs1 || ID_EX_rd == rs2)) begin\n      pcFromTaken &lt;= 0;\n      pcStall     &lt;= 1;\n      IF_ID_stall &lt;= 1;\n      ID_EX_flush &lt;= 1;\n    end\n</code></pre><p>解决了流水线的冒险问题，我们才能确保指令经过流水线执行后，得到的结果是正确的，这时候才能把执行结果写回到寄存器。接下来，让我们来继续完成写回阶段的模块设计。</p><h2>写回控制模块设计</h2><p>现在我们来到了流水线的最后一级——结果写回。先来看看写回控制模块，这个模块实现起来就非常简单了，它的作用就是选择存储器读取回来的数据作为写回的结果，还是选择流水线执行运算之后产生的数据作为写回结果。</p><p>具体代码如下：</p><pre><code class=\"language-verilog\">module mem_wb_ctrl(\n  input   clk,\n  input   reset,\n  input   in_wb_ctrl_toReg,\n  input   in_wb_ctrl_regWrite,\n  \n  output  data_wb_ctrl_toReg,\n  output  data_wb_ctrl_regWrite\n);\n\n  reg  reg_wb_ctrl_toReg; \n  reg  reg_wb_ctrl_regWrite; \n\n  assign data_wb_ctrl_toReg = reg_wb_ctrl_toReg; \n  assign data_wb_ctrl_regWrite = reg_wb_ctrl_regWrite; \n\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin \n      reg_wb_ctrl_toReg &lt;= 1'h0; \n    end else begin \n      reg_wb_ctrl_toReg &lt;= in_wb_ctrl_toReg; \n    end\n  end\n\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin \n      reg_wb_ctrl_regWrite &lt;= 1'h0; \n    end else begin \n      reg_wb_ctrl_regWrite &lt;= in_wb_ctrl_regWrite; \n    end\n  end\n\nendmodule\n</code></pre><p>代码里有两个重要的信号需要你留意。一个是写回寄存器的数据选择信号wb_ctrl_toReg，当这个信号为“1”时，选择从存储器读取的数值作为写回数据，否则把流水线的运算结果作为写回数据。另一个是寄存器的写控制信号wb_ctrl_regWrite，当这个信号为“1”时，开始往目标寄存器写回指令执行的结果。</p><h2>写回数据通路模块设计</h2><p>和写回的控制模块一样，流水线的最后一级的写回数据通路上的信号也变得比较少了。</p><p>写回数据通路模块产生的信号主要包括写回目标寄存器的地址reg_WAddr，流水线执行运算后的结果数据result，从存储器读取的数据readData。</p><p>写回数据通路的模块代码如下：</p><pre><code class=\"language-verilog\">module mem_wb(\n  input         clk,\n  input         reset,\n  input  [4:0]  in_regWAddr,\n  input  [31:0] in_result,\n  input  [31:0] in_readData,\n  input  [31:0] in_pc,\n\n  output [4:0]  data_regWAddr,\n  output [31:0] data_result,\n  output [31:0] data_readData,\n  output [31:0] data_pc\n);\n\n  reg [4:0]  reg_regWAddr; \n  reg [31:0] reg_result; \n  reg [31:0] reg_readData; \n  reg [31:0] reg_pc; \n\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin \n      reg_regWAddr &lt;= 5'h0; \n    end else  begin \n      reg_regWAddr &lt;= in_regWAddr; \n    end\n  end\n\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin \n      reg_result &lt;= 32'h0; \n    end else begin \n      reg_result &lt;= in_result; \n    end\n  end\n\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin \n      reg_readData &lt;= 32'h0; \n    end else begin \n      reg_readData &lt;= in_readData; \n    end\n  end\n\n  always @(posedge clk or posedge reset) begin    \n    if (reset) begin \n      reg_pc &lt;= 32'h0; \n    end else  begin \n      reg_pc &lt;= in_pc; \n    end\n  end\n\n  assign data_regWAddr = reg_regWAddr; \n  assign data_result = reg_result; \n  assign data_readData = reg_readData; \n  assign data_pc = reg_pc; \n  \nendmodule\n</code></pre><p>仔细观察代码，你是否发现和流水线的前面几级的数据通路模块相比，少了两个控制信号呢？<br>\n是的，写回阶段的模块没有了流水线的停止控制信号stall和流水线的冲刷控制信号flush。这是因为写回阶段的数据经过了数据冒险和控制冒险模块的处理，已经可以确保流水线产生的结果无误了，所以写回阶段的数据不受停止信号stall和清零信号flush的控制。</p><p>到这里，我们要设计的迷你CPU的五级流水线就基本完成啦。</p><h2>重点回顾</h2><p>最后我给你做个总结吧。</p><p>这节课我们先分析了流水线中存在的控制冒险问题，也就是当流水线中出现条件分支指令时，下一条指令还不确定从哪里取的问题。最容易想到的解决方案，就是在取出分支指令后，流水线马上停下来，等到分支指令的结果出来，确定下一条指令从哪个地址获取之后，流水线再继续。但是，这里流水线停顿的方式缺点很明显，它会带来很多CPU的性能损失。</p><p>于是，我们采用了分支预测的方法，预测每一条分支指令都会发生跳转，直接在分支指令的下一条取跳转后相应地址的指令。如果分支发生跳转的概率是50%，那么这种优化方式就可以减少一半由控制冒险带来的性能损失。</p><p>最后，根据整个流水线执行后的数据，我们完成了流水线的最后一级，也就是写回控制模块和数据通路模块的设计。写回控制模块要么选择存储器读取回来的数据作为写回结果，要么选择流水线执行运算之后产生的数据作为写回结果。数据通路模块则包含了写回目标寄存器的地址、ALU的运算结果以及访存阶段读存储器得到的数据。</p><p><img src=\"https://static001.geekbang.org/resource/image/1e/e6/1e593yy8c0627efb9b0809de38aeb7e6.jpg?wh=1920x1722\" alt=\"图片\"></p><p>到这里，我们终于把CPU的五级流水线的最后一级设计完成了，这代表基于指令集RV32I的迷你CPU核心代码设计已经完成。很快就可以让它跑程序了，你是不是很期待呢？下一节课我们就可以看到效果了！</p><h2>思考题</h2><p>除了流水线停顿和分支预测方法，是否还有其他解决控制冒险问题的办法？</p><h2></h2><p>欢迎你在留言区跟我交流互动，或者记录下你的思考与收获。如果觉得这节课还不错，别忘了分享给身边的朋友，我们一起来手写CPU！</p>","neighbors":{"left":{"article_title":"09｜手写CPU（四）：如何实现CPU流水线的访存阶段？","id":550940},"right":{"article_title":"11｜手写CPU（六）：如何让我们的CPU跑起来？","id":552924}}},{"article_id":552924,"article_title":"11｜手写CPU（六）：如何让我们的CPU跑起来？","article_content":"<p>你好，我是LMOS。</p><p>通过前面几节课的学习，我们已经完成了MiniCPU五级流水线的模块设计，现在距离实现一个完整的MiniCPU也就一步之遥。</p><p>还差哪些工作没完成呢？还记得我们在第六节课设计的MiniCPU架构图吗？回想一下，我们已经设计完成的五级流水线，都包含下图的哪些模块？</p><p><img src=\"https://static001.geekbang.org/resource/image/31/dd/31b586c344cd7d0127775e7ff63711dd.jpg?wh=1920x1289\" alt=\"图片\"></p><p>上图的CPU核心模块，也就是CPU Core包含的模块的设计，这些我们已经在前面几节课里完成了。除了五级流水线的模块，我们还设计了用于保存操作数和运算结果的通用寄存器组，设计了解决数据冒险问题的forwarding模块，以及解决控制冒险问题的hazard模块。</p><p>接下来，我们还需要搞定一些外围组件，也就是图里虚线框外的系统总线、ROM、RAM、输入输出端口GPIO（GPIO比较简单，课程里没专门讲）和UART模块。</p><p>学完这节课，我们就可以把这个CPU运行起来了，最终我还会带你在这个CPU上跑一个RISC-V版本的Hello World程序（课程代码从<a href=\"https://gitee.com/lmos/Geek-time-computer-foundation\">这里</a>下载），是不是很期待？话不多说，我们这就开始！</p><h2>系统总线设计</h2><p>首先，让我们看看CPU的系统总线。</p><p>总线是连接多个部件的信息传输线，它是各部件共享的传输介质。在某一时刻，只允许有一个部件向总线发送信息，而多个部件可以同时从总线上接收相同的信息。MiniCPU的系统总线用来连接CPU内核与外设，完成信息传输的功能。</p><!-- [[[read_end]]] --><p>系统总线在整个MiniCPU中是一个很关键的模块。你可以这样理解，总线就是CPU内核跟其他外设部件的“联络员”。举几个例子，总线可以从ROM中读取指令，再交给CPU去执行；CPU运行程序时的变量，也会交由总线保存到RAM中；用来实现芯片与外部通信的UART模块，也需要通过总线跟CPU进行信息交换……</p><p>那总线的代码具体要怎么设计呢？我先展示一下写好的整体代码，再带你具体分析。</p><pre><code class=\"language-verilog\">module sys_bus (\n    // cpu -&gt; imem\n    input  [31:0] cpu_imem_addr,\n    output [31:0] cpu_imem_data,\n    output [31:0] imem_addr,            \t\n    input  [31:0] imem_data, \n  \n    // cpu -&gt; bus\n    input  [31:0] cpu_dmem_addr,        \n    input  [31:0] cpu_dmem_data_in,     \n    input         cpu_dmem_wen,        \n    output reg [31:0] cpu_dmem_data_out,\n  \n    // bus -&gt; ram \n    input  [31:0] dmem_read_data,     \n    output [31:0] dmem_write_data,    \n    output [31:0] dmem_addr,           \n    output reg    dmem_wen,\n  \n    // bus -&gt; rom \n    input  [31:0] dmem_rom_read_data,\n    output [31:0] dmem_rom_addr, \n  \n    // bus -&gt; uart\n    input  [31:0] uart_read_data,   \n    output [31:0] uart_write_data,   \n    output [31:0] uart_addr,         \n    output reg    uart_wen\n);\n    assign imem_addr = cpu_imem_addr;\n    assign cpu_imem_data = imem_data;\n    assign dmem_addr = cpu_dmem_addr;\n    assign dmem_write_data = cpu_dmem_data_in;\n    assign dmem_rom_addr = cpu_dmem_addr;\n    assign uart_addr = cpu_dmem_addr;\n    assign uart_write_data = cpu_dmem_data_in;\n\n    always @(*) begin\n        case (cpu_dmem_addr[31:28])\n            4'h0: begin\t\t\t\t\t\t\t\t//ROM\n                cpu_dmem_data_out &lt;= dmem_rom_read_data;\n                dmem_wen &lt;= 0;\n                uart_wen &lt;= 0;\n            end\n            4'h1: begin     \t\t\t\t\t// RAM\n                dmem_wen &lt;= cpu_dmem_wen;\n                cpu_dmem_data_out &lt;= dmem_read_data;\n                uart_wen &lt;= 0;\n            end\n            4'h2: begin     \t\t\t\t\t// uart io\n                uart_wen &lt;= cpu_dmem_wen;\n                cpu_dmem_data_out &lt;= uart_read_data;\n                dmem_wen &lt;= 0;\n            end\n            default:   begin\n                dmem_wen &lt;= 0;\n                uart_wen &lt;= 0;\n                cpu_dmem_data_out &lt;= 0;\n            end\n        endcase\n    end\nendmodule\n</code></pre><p>这里我们设计的系统总线其实是一个<strong>“一对多”</strong>的结构，也可以说是“一主多从”结构，就是一个CPU内核作为主设备（Master），多个外设作为从设备（Slave）。<br>\n<img src=\"https://static001.geekbang.org/resource/image/ac/0e/ac1d4cf173d140225fff21f2c9fedb0e.jpg?wh=1920x1166\" alt=\"图片\"></p><p>CPU内核具有系统总线的控制权，它可以通过系统总线，发起对外设的访问，而外设只能响应从CPU内核发来的各种总线命令。因此，每个外设都需要有一个固定的地址，作为CPU访问特定外设的标识。</p><p>以下就是给从设备分配的地址空间：</p><blockquote>\n<p>// 设备地址空间<br>\n// 0x0000_0000 -ROM (word to byte )<br>\n// 0x1000_0000 -RAM (word to byte )<br>\n// 0x2000_0000 -uart   (word to byte )<br>\n// 0x3000_0000 -other(word to byte )</p>\n</blockquote><p>从代码的第39～60行也可以看到，总线根据地址的<strong>高4 bit的值</strong>，就可以判断出CPU访问的是哪个从设备。</p><p>当（cpu_dmem_addr[31:28] = 4’h0 ）时，CPU访问的是ROM，把从ROM返回的数据赋给总线；当（cpu_dmem_addr[31:28] = 4’h1 ）时，CPU访问的是RAM，把CPU的写使能cpu_dmem_wen赋给RAM的写使能信号dmem_wen，同时把从RAM返回的数据赋给总线；当（cpu_dmem_addr[31:28] = 4’h2 ）时，CPU访问的是串行通信模块UART，把CPU的写使能cpu_dmem_wen赋给uart的写使能信号uart_wen，同时把从UART返回的数据赋给总线。这就是MiniCPU总线的工作过程。</p><h2>只读存储器ROM的实现</h2><p>接下来，我们看看连接在总线上的存储器要如何实现。</p><p>ROM是个缩写，它表示只读存储器（Read Only Memory）。ROM具有非易失性的特点。什么是非易失性呢？说白了就是在系统断电的情况下，仍然可以保存数据。</p><p>正是因为这一特点，ROM很适合用来存放计算机的程序。由于历史原因，虽然现在使用的ROM中，有些类型不仅是可以读，还可以写，但我们还是习惯性地把它们称作只读存储器。比如，现在电子系统中常用的EEPROM、NOR flash 、Nand flash等，都可以归类为ROM。</p><p>在我们的MiniCPU中，目前没有真正使用上述的ROM作为指令存储器。让我们看看MiniCPU中实现ROM功能的代码，再相应分析我们的设计思路。</p><pre><code class=\"language-verilog\">module imem (\n    input  [11:0] addr1,\n    output [31:0] imem_o1,\n    input  [11:0] addr2,\n    output [31:0] imem_o2\n);\n    reg [31:0] imem_reg[0:4096];\n\n    assign imem_o1 = imem_reg[addr1];\n    assign imem_o2 = imem_reg[addr2];\n\nendmodule\n</code></pre><p>为了方便学习和仿真，我们使用了寄存器（reg）临时定义了一个指令存储器imem，并在仿真的顶层（tb_top.v）使用了$readmemh（）函数，把编译好的二进制指令读入到imem中，以便CPU内部读取并执行这些指令。这里我们设置的存储器在功能上是只读的。</p><p>以下就是仿真的顶层（tb_top.v）调用$readmemh（）函数的语句。</p><pre><code class=\"language-verilog\">$readmemh(`HEXFILE, MiniCPU.u_imem.imem_reg);\n</code></pre><p>函数里面有两个参数，一个是存放二进制指令的文件（HEXFILE），另一个就是实现ROM功能的寄存器（imem_reg）。这条语句可以在我们启动CPU仿真时，把二进制的指令一次性读入到imem中，这样CPU运行的过程中就可以取imem中的指令去执行了。</p><h2>随机访问存储器RAM</h2><p>除了存放指令的ROM，我们还需要一个存放变量和数据的RAM（Random Access Memory）。</p><p>RAM和特点跟ROM正好相反，它是易失性存储器，通常都是在掉电之后就会丢失数据。但是它具有读写速度快的优势，所以通常用作CPU的高速缓存。</p><p>RAM之所以叫做随机访问存储器，是因为不同的地址可以在相同的时间内随机读写。这是由RAM的结构决定的，RAM使用存储阵列来存储数据，只要给出行地址和列地址，就能确定目标数据，而且这一过程和目标数据所处的物理位置无关。</p><p>和ROM一样，为了方便对设计的MiniCPU进行仿真验证，我们还是用寄存器（reg）临时构建了一个数据存储器dmem，作为MiniCPU中的RAM使用。虽然临时构建的存储器和实际的ROM有点差别，但我们还在初期学习阶段，这已经足够了。</p><p>下面就是实现RAM功能的数据存储器dmem的代码：</p><pre><code class=\"language-verilog\">module dmem(\n    input [11:0] addr,\n    input we,\n    input [31:0] din,\n    input clk,\n\n    output reg [31:0] dout\n);\n    reg [31:0] dmem_reg[0:4095];\n    \n    always @(posedge clk) begin\n        if(we) begin\n            dmem_reg[addr] &lt;= din;\n        end\n            dout &lt;= dmem_reg[addr];\n    end\nendmodule\n</code></pre><p>代码的第11~16行可以看到，我们使用了时钟信号clk，说明这里的dmem实现的是一个时钟同步RAM。而且当写使能信号（we）为“1”时，才能往RAM里写数据，否则只能读取数据。</p><h2>外设UART设计</h2><p>为了让MiniCPU能和其他电子设备进行通信，我们还要设计UART模块。</p><p>同样地，设计代码之前我先带你快速了解一下UART是什么，它的工作原理是怎样的。</p><p>UART的全称叫通用异步收发传输器（Universal Asynchronous Receiver/Transmitter），它是一种串行、异步、全双工的通信协议，是电子设备间进行异步通信的常用模块。</p><p>UART负责对系统总线的并行数据和串行口上的串行数据进行转换，通信双方采用相同的波特率。在不使用时钟信号线的情况下，仅用一根数据发送信号线和一根数据接收信号线（Rx和Tx）就可以完成两个设备间的通信，因此我们也把UART称为异步串行通信。</p><p>串行通信是指，利用一条传输线将数据按顺序一位位传送的过程。UART的发送模块会把来自CPU总线的并行数据转换为串行数据，再以串行方式将其发送到另一个设备的UART接收端。然后由UART的接收模块把串行数据转换为并行数据，以便接收设备存储和使用这些数据。</p><p>UART的数据传输格式如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/e7/c2/e7308850a0d185b3ccdde6b7ef4806c2.jpg?wh=1920x872\" alt=\"图片\"></p><p>从图里我们可以看到，UART传输数据包括起始位、数据位、奇偶校验位、停止位和空闲位。UART数据传输线通常在不传输数据时保持在高电平。</p><p>这么多名词是不是有点应接不暇？我挨个解释一下，你就清楚了。</p><ul>\n<li><strong>起始位</strong>是在数据线上先发出一个逻辑低电平“0”信号，表示数据传输的开始。</li>\n<li><strong>数据位</strong>是由5~8位逻辑高低电平表示的“1”或“0”信号。</li>\n<li><strong>校验位</strong>在传输的数据位的后面加1bit，表示“1”的位数应为偶数（偶校验）或奇数（奇校验）。</li>\n<li><strong>停止位</strong>是一个数据位宽的1倍、1.5倍、或者2倍的高电平信号，它是一次数据传输的结束标志。</li>\n<li><strong>空闲位</strong>是数据传输线处于逻辑高电平状态，表示当前线路上处于空闲状态，没有数据传送。</li>\n</ul><p>跟数据发送信号线TX、数据接收信号线RX相对应，我们的UART也分别设计了发送模块（uart_tx）和接收模块（uart_rx）。如果你想了解具体的功能实现，可以课后查看我们的MiniCPU的<a href=\"https://gitee.com/lmos/Geek-time-computer-foundation/tree/master/lesson06~11/mini_cpu\">项目代码</a>。</p><p>这里只放出来发送模块的端口信号，如下所示：</p><pre><code class=\"language-verilog\">module uart_tx(\ninput           clk         , // Top level system clock input.\ninput           resetn      , // Asynchronous active low reset.\noutput          uart_txd    , // UART transmit pin.\noutput          uart_tx_busy, // Module busy sending previous item.\ninput           uart_tx_en  , // Send the data on uart_tx_data\ninput   [7:0]   uart_tx_data  // The data to be sent\n);\n</code></pre><p>UART接收模块的端口信号如下：</p><pre><code class=\"language-verilog\">module uart_rx(\ninput         clk          , // Top level system clock input.\ninput         resetn       , // Asynchronous active low reset.\ninput         uart_rxd     , // UART Recieve pin.\ninput         uart_rx_en   , // Recieve enable\noutput        uart_rx_break, // Did we get a BREAK message?\noutput        uart_rx_valid, // Valid data recieved and available.\noutput reg  [7:0] uart_rx_data   // The recieved data.\n);\n</code></pre><p>端口信号的代码你结合上面的注释很容易就能理解，后面CPU跑程序的时候就会用到这部分的功能。</p><h2>在CPU上跑个Hello World</h2><p>好，现在来到我们的最后一个环节，编写程序，并把它放到我们的MiniCPU上跑起来。</p><p>为了能更直观看到CPU的运行效果，这里我们使用RISC-V汇编指令，设计了一段用UART发送“Hello MiniCPU!”字符串的代码，然后让串口接收端把发送的字符串在电脑上打印出来。</p><p>具体的代码如下：</p><pre><code class=\"language-plain\">#\t\tAssembly&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Description\nmain:&nbsp; &nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; li&nbsp; &nbsp; &nbsp; x2, 0x20000000&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # uart address\n&nbsp; &nbsp; &nbsp; &nbsp; li&nbsp; &nbsp; &nbsp; x6,&nbsp; 0x1500&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#x6 &lt;== 0x1500, delay 1ms\n&nbsp; &nbsp; &nbsp; &nbsp; addi&nbsp; &nbsp; x7, x0, 0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#x7 &lt;== 0\n\n&nbsp; &nbsp; &nbsp; &nbsp; addi&nbsp; &nbsp; x5, x0, 0x48&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #x5 &lt;== \"H\"\n&nbsp; &nbsp; &nbsp; &nbsp; sw&nbsp; &nbsp; &nbsp; x5, 0(x2)&nbsp;&nbsp;\n\ndelay1: addi&nbsp; &nbsp; x7, x7, 1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#x7 &lt;== x7 + 1\n&nbsp; &nbsp; &nbsp; &nbsp; bne&nbsp; &nbsp; &nbsp;x7, x6, delay1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #x6 != x7&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; addi&nbsp; &nbsp; x7, x0, 0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#x7 &lt;== 0\n&nbsp; &nbsp; &nbsp; &nbsp; addi&nbsp; &nbsp; x5, x0, 0x65&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #x5 &lt;== \"e\"\n&nbsp; &nbsp; &nbsp; &nbsp; sw&nbsp; &nbsp; &nbsp; x5, 0(x2)&nbsp;&nbsp;\n\ndelay2: addi&nbsp; &nbsp; x7, x7, 1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#x7 &lt;== x7 + 1\n&nbsp; &nbsp; &nbsp; &nbsp; bne&nbsp; &nbsp; &nbsp;x7, x6, delay2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#x6 != x7\n&nbsp; &nbsp; &nbsp; &nbsp; addi&nbsp; &nbsp; x7, x0, 0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#x7 &lt;== 0\n&nbsp; &nbsp; &nbsp; &nbsp; addi&nbsp; &nbsp; x5, x0, 0x6c&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #x5 &lt;== \"l\"\n&nbsp; &nbsp; &nbsp; &nbsp; sw&nbsp; &nbsp; &nbsp; x5, 0(x2)&nbsp;\n\ndelay3: addi&nbsp; &nbsp; x7, x7, 1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#x7 &lt;== x7 + 1\n&nbsp; &nbsp; &nbsp; &nbsp; bne&nbsp; &nbsp; &nbsp;x7, x6, delay3&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#x6 != x7\n&nbsp; &nbsp; &nbsp; &nbsp; addi&nbsp; &nbsp; x7, x0, 0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#x7 &lt;== 0\n&nbsp; &nbsp; &nbsp; &nbsp; addi&nbsp; &nbsp; x5, x0, 0x6c&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #x5 &lt;== \"l\"\n&nbsp; &nbsp; &nbsp; &nbsp; sw&nbsp; &nbsp; &nbsp; x5, 0(x2)&nbsp;&nbsp;\n\n  …………  //由于代码较长，结构相似，这里省略了一部分，完整代码你可以从Gitee上获取\n\ndelay13: addi&nbsp; &nbsp; x7, x7, 1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#x7 &lt;== x7 + 1\n&nbsp; &nbsp; &nbsp; &nbsp; bne&nbsp; &nbsp; &nbsp;x7, x6, delay13&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#x6 != x7\n&nbsp; &nbsp; &nbsp; &nbsp; addi&nbsp; &nbsp; x7, x0, 0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#x7 &lt;== 0\n&nbsp; &nbsp; &nbsp; &nbsp; addi&nbsp; &nbsp; x5, x0, 0x21&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #x5 &lt;== \"!\"\n&nbsp; &nbsp; &nbsp; &nbsp; sw&nbsp; &nbsp; &nbsp; x5, 0(x2)&nbsp;\n\nend:&nbsp; &nbsp; j&nbsp; &nbsp; &nbsp; &nbsp;end\n\n&nbsp; &nbsp; &nbsp; &nbsp; ret\n</code></pre><p>有了代码，我们还需要把它编译成能在CPU上运行的机器码，才能把它放在CPU上跑。</p><p>下面的代码就是放在课程代码中的Makefile，作用是编译汇编代码，还有定义好CPU仿真需要用到的一些命名规则。</p><pre><code class=\"language-makefile\">SOURCE_TB := ./tb/tb_top.v\nTMP_DIR := ./tmp\nSOURCE := ./rtl.f\nTARGET := ${TMP_DIR}/tb_top.o\n\nTEST_HEX := ./sim/asm/build/test.dat\n\n# 编译汇编程序，输出二进制指令\nasm:\n\tmake -C ./sim/asm \n\tpython ./sim/asm/word2byte.py\n\n# 对CPU进行仿真\ncpu:\n\trm -f ${TMP_DIR}/*\n\tcp ${SOURCE_TB} ${TMP_DIR}\n\tsed -i 's#.hex#${TEST_HEX}#' ${TMP_DIR}/tb_top.v\n\tiverilog -f ${SOURCE} -o ${TARGET}\n\tvvp ${TARGET}\n\n# 查看波形\nwave:\n\tgtkwave ${TMP_DIR}/tb_top.vcd &amp;\n\n# 清除临时文件\nclean:\n\tmake -C ./sim/asm clean\n\trm ./tmp/* -rf\n</code></pre><p>从Makefile的代码中可以看到，我们一共定义了4个目标命令，它们的作用分别是完成汇编程序编译的（asm）命令、执行MiniCPU仿真的（cpu）命令、用软件GTKwave打开仿真后的波形（wave）命令，以及清除仿真过程中产生的临时文件的（clean）命令。</p><p>通过在终端上执行“make asm”命令，便可以把上面设计的汇编程序编译成二进制指令test.dat。然后我们再输入“make cpu”命令就启动MiniCPU的仿真了，运行结果如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/93/77/93a1c6c0c1e71cb4cc6f5bffbc86f577.jpg?wh=1920x1043\" alt=\"图片\"></p><p>到此，我们的MiniCPU就设计完成啦！祝贺你一路进行到这里。看到页面上输出Hello MiniCPU的时候，是不是感觉还挺好玩的？</p><p>如果你觉得意犹未尽，还可以在项目文件夹里的“./mini_cpu/sim/asm/src/miniCPU_sim.asm”这个文件中编写你自己的RISC-V汇编程序，然后就可以在我们的MiniCPU上玩出更多花样了。</p><h2>重点回顾</h2><p>这节课，我们把MiniCPU的几个外部模块设计完成，这几个模块是让CPU“跑起来”的必要组件。</p><p><img src=\"https://static001.geekbang.org/resource/image/31/dd/31b586c344cd7d0127775e7ff63711dd.jpg?wh=1920x1289\" alt=\"图片\"></p><p>我们首先设计了MiniCPU的系统总线。有了它，就能连接CPU内核与外设，完成信息传输的功能，相当于CPU内核与外部设备的一座桥梁。</p><p>接下来的模块就是ROM和RAM。ROM是存放CPU指令的只读存储器。为了方便学习和仿真，我们通过寄存器临时定义了一个指令存储器，然后在仿真的顶层使用了$readmemh函数，把编译好的二进制指令读入到指令存储器中，这样CPU运行时就可以读取和执行这些指令了。</p><p>RAM用来存放数据，它在掉电之后会丢失数据，但是读写速度快，通常用来作为CPU的高速缓存。跟ROM的实现思路一样，我们还是用寄存器临时构建了一个数据存储器dmem，作为MiniCPU中的RAM使用。</p><p>为了让MiniCPU能和其他设备通信，我们还设计了异步串行通信模块UART，它用一根数据发送信号线和一根数据接收信号线就可以完成两个设备间的通信。</p><p>MiniCPU设计好了之后，我们进入运行调试环节，用RISC-V指令编写了一段用UART发送“Hello MiniCPU!”字符串的汇编程序，然后让串口接收端把发送的字符串在电脑上打印出来。如果字符串显示正常，说明我们的miniCPU已经可以正常运行了。</p><p>到这里，我们RISC-V处理器的实现就全部完成了。这节课要点，你可以参考下面的导图。</p><p><img src=\"https://static001.geekbang.org/resource/image/54/83/54b5250d3992644cf27ebe953fb44283.jpg?wh=1920x2109\" alt=\"图片\"></p><p>你有兴趣的话，还可以课后做更多的探索，比如给它添加更多的RISCV指令功能，在CPU总线上挂载更多的外设……后面的课程里，我会带你学习更多的RISC-V指令，敬请期待！</p><h2>思考题</h2><p>计算机两大体系结构分别是冯诺依曼体系结构和哈弗体系结构，请问我们的MiniCPU属于哪一种体系结构呢？</p><p>期待你在留言区跟我交流互动，说说这个模块学习下来的感受，如果觉得手写CPU很酷，别忘了分享给身边更多的朋友。</p>","neighbors":{"left":{"article_title":"10｜手写CPU（五）：CPU流水线的写回模块如何实现？","id":552136},"right":{"article_title":"12｜QEMU：支持RISC-V的QEMU如何构建？","id":554509}}},{"article_id":554509,"article_title":"12｜QEMU：支持RISC-V的QEMU如何构建？","article_content":"<p>你好，我是LMOS。</p><p>工欲善其事，必先利其器。作为开发者，学习过程中我们尤其要重视动手实践，不断巩固和验证自己学到的知识点。而动手实践的前提，就是要建立一个开发环境，这个环境具体包括编译环境、执行环境，以及各种常用的工具软件。</p><p>我会用两节课带你动手搭好环境，今天这节课咱们先热个身，搞清楚什么是主环境，还有怎么基于它生成交叉编译工具。</p><p>代码你可以从<a href=\"https://gitee.com/lmos/Geek-time-computer-foundation/tree/master/lesson12~13\">这里</a>下载。</p><h2>主环境</h2><p>主环境，有时也叫作HOST环境，也就是我们使用的计算机环境，即使用什么样的操作系统、什么架构的计算机作为开发环境。</p><p>比方说我们经常用PC机作为开发机使用，它实际就是一个基于x86架构（或其他架构）的硬件平台，再加上Windows或者Linux等操作系统共同组成的开发环境。</p><p>普通用户的电脑上经常安装的操作系统是Windows，因为界面友好方便、操作简单且娱乐影音、游戏办公等应用软件也是不胜枚举。</p><p>Windows对普通用户来说的确非常友好。但是作为软件开发者，对于志存高远、想要精研技术的我们而言，更喜欢用的是Linux系统。</p><p>它虽然没有漂亮的GUI，却暴露了更多的计算机底层接口，也生产了更多的开发工具和各种各样的工具软件。比如大名鼎鼎的编译器GCC、声名远扬的编辑器EMACS、VIM，还有自动化的脚本工具shell、make等。这些工具对开发者非常友好，配合使用可以让我们的工作事半功倍，后面你会逐渐体会到这点。</p><!-- [[[read_end]]] --><p>当然Linux只是一个内核，我们不能直接使用，还需要各种工具、库和桌面GUI，把这些和Linux打包在一起发行，这就构成了我们常说的Linux发行版。</p><p>我最喜欢的Linux发行版是Deepin和Ubuntu。为了统一，我建议你使用Deepin最新版，你也可以使用Ubuntu，它们是差不多的。只是操作界面稍有不同。我先给你展示下我的Deepin，如下图，刚装上它的时候，我就觉得它颇为惊艳。</p><p><img src=\"https://static001.geekbang.org/resource/image/78/28/782c1d620430ba46b584b0cdbd86dc28.jpg?wh=1920x1089\" alt=\"图片\"></p><p>这里最基础的安装我就不讲了，因为安装Deepin十分简单，无论是虚拟机还是在物理机上安装，我相信你通过互联网都可以自行解决，搞不定也可以看看<a href=\"https://www.deepin.org/zh/installation/\">这里</a>。</p><p>这两种方式我也替你对比过，虚拟机中的Linux较物理机上的Linux性能稍差一点，但并不影响我们实验操作和结果。</p><h2>为什么需要交叉编译</h2><p>虽然主环境搞定了，但现在我们还不能直接跑代码。为什么呢？</p><p>先回想一下，平时我们正常开发软件需要什么？我猜，哪怕你不能抢答，也会知道个大概：需要电脑（PC）、特定的操作系统（比如Windows或Linux等），在这个操作系统上还能运行相应的编辑器和编译器。编辑器用来编写源代码，而编译器用来把源代码编译成可执行程序。</p><p>似乎不需要更多东西了，毕竟我们日常开发的软件，宿主平台和目标平台是相同的。如果我们把限制条件变一变，情况就不同了。如果我们想尝试在RISC-V平台上跑程序，要怎么办呢？</p><p>你或许会说，这简单，买一台RISC-V的机器不就行了。可是先不说购买硬件的经济成本，实际上，很多RISC-V平台硬件资源（如内存、SD卡容量）有限，不足以运行复杂的编译器软件，有的甚至没有操作系统，更别说在上面运行编译器或者编辑器软件了。</p><p>面对这样的困境，就要用到<strong>交叉编译</strong>了。什么是交叉编译呢？简单来说，就是在一个硬件平台上，生成另一个硬件平台的可执行程序。</p><p>举个例子，我们在x86平台上编译生成ARM平台的可执行程序；再比如说，之后的课里我们将在x86平台上，生成RISC-V的可执行程序。这些都属于交叉编译，在这个过程中编译生成可执行程序的平台，称为宿主机或者主机；执行特定程序的平台（如ARM或者RISC-V平台），称为目标机。</p><p>我特意准备了图解，为你展示在x86平台上，交叉编译生成RISC-V平台可执行程序的过程，你可以仔细看看：</p><p><img src=\"https://static001.geekbang.org/resource/image/a5/55/a5fb7d81fa49da02bfeee45c35aef255.jpg?wh=1920x1183\" alt=\"图片\"></p><h2>如何构建RISC-V交叉编译器</h2><p>前面说了交叉编译的本质就是生成其他平台体系上的可执行程序，这个体系又不同于我们宿主平台。我们的目的很简单，就是要<strong>在x86平台上编写源代码，然后编译出RISC-V平台的可执行程序，最后放在RISC-V平台上去运行</strong>。</p><p>因此，我们需要用宿主机编译器A，编译出一个编译器B，这个编译器B是本地平台上的可执行程序。</p><p>说得再具体点，你可以把编译器B看作是<strong> x86 Linux上的一个应用</strong>。但它的特殊之处就是，能根据源代码生成RISC-V平台上的可执行程序。补充一句，这里的编译器A和B都是C语言编译器。</p><p>下面我们开始构造编译器B。编译器B不仅仅是C语言编译器，还有很多额外的程序。比如RISC-V平台上使用的二进制文件分析（objcopy）、反汇编（objdump）、elf结构分析工具（readelf）、静态库归档（ar）、汇编器（as）、链接器（ld）、GDB、C语言库（Newlib、Glib、Multlib）等。</p><p>为了简单、便于区分，我们把这些对应于RISC-V平台的编译器相关的软件，统称为<strong> RISC-V工具链</strong>。</p><p>构建RISC-V工具链的主要步骤如下：</p><p>1.安装依赖工具：在宿主平台上安装编译器A，以及相应的工具和库。<br>\n2.下载RISC-V工具链的源代码；<br>\n3.配置RISC-V工具链；<br>\n4.编译RISC-V工具链，并安装在宿主平台上。</p><h3>第一步：安装依赖工具</h3><p>我们先从第一步开始，编译器A主要是宿主平台上的GCC，工具主要是Make、Git、Autoconf、Automake、CURL、Python3、Bison、Flex等。这里GCC主要在build-essential包中，我们只要在Linux终端中输入如下指令就可以了：</p><pre><code class=\"language-plain\">sudo apt-get install git autoconf automake autotools-dev curl python3 libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison flex texinfo gperf patchutils bc libexpat-dev libglib2.0-dev ninja-build zlib1g-dev pkg-config libboost-all-dev libtool libssl-dev libpixman-1-dev libpython-dev virtualenv libmount-dev libsdl2-dev\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/77/79/778c6aea3fa8c112c732fc3d7b653f79.jpg?wh=1910x1154\" alt=\"图片\"></p><p>如果不出意外，这些工具和库会通过网络由Linux的apt包管理器，全自动地给你安装完毕。</p><h3>第二步：下载工具链源代码</h3><p>接着进入第二步下载RISC-V工具链源代码。通常来说，我们只要用Git克隆一个riscv-gnu-toolchain仓库即可，其它的由riscv-gnu-toolchain仓库中的仓库子模块自动处理。</p><h4>手动配置环节</h4><p>由于众所周知的网络原因，你可能连riscv-gnu-toolchain仓库都下载不下来，更别说自动下载仓库子模块了。为了照顾卡壳的人，我把手动处理的情况也顺便讲一下，能够直接自动安装的同学可以跳过这部分，直接翻到7条指令之后的最终截图对一下结果就行。</p><p>子模块如下：</p><pre><code class=\"language-plain\">riscv-qemu（虚拟机）\nriscv-newlib (用嵌入式的轻量级C库)\nriscv-binutils(包含一些二进制工具集合，如objcopy等)\nriscv-gdb(用于调试代码的调试器)\nriscv-dejagnu(用于测试其它程序的框架)\nriscv-glibc(GNU的C库)\nriscv-gcc (C语言编译器)\n</code></pre><p>这些子模块我们需要手动从Gitee网站上下载。下载前，我们先在终端上输入后面的指令，建立一个目录，并切换到该目录中：</p><pre><code class=\"language-plain\">mkdir RISCV_TOOLS\ncd RISCV_TOOLS\n</code></pre><p>把RISC-V工具链的源代码手动下载好，步骤稍微多了一些，我在后面分步骤列出，方便你跟上节奏。</p><p>其实也就是7条指令的事儿，并不复杂。先统一说明下，<strong>后面这些命令都是切换到riscv-gnu-toolchain目录的终端下</strong>，输入我给你列出的指令即可。</p><p>1.开始下载riscv-gnu-toolchain，命令如下：</p><pre><code class=\"language-plain\">git clone https://gitee.com/mirrors/riscv-gnu-toolchain\ncd riscv-gnu-toolchain\n</code></pre><p>2.下载RISC-V平台的C语言编译器源代码仓库，输入如下指令：</p><pre><code class=\"language-plain\">git clone -b riscv-gcc-10.2.0 https://gitee.com/mirrors/riscv-gcc\n</code></pre><p>3.下载测试框架源代码仓库，即riscv-dejagnu。输入如下指令：</p><pre><code class=\"language-plain\">git clone https://gitee.com/mirrors/riscv-dejagnu\n</code></pre><p>4.下载GNU的C库源代码仓库，也就是riscv-glibc，输入如下指令：</p><pre><code class=\"language-plain\">git clone -b riscv-glibc-2.29 https://gitee.com/mirrors/riscv-glibc\n</code></pre><p>5.下载用于嵌入式的轻量级C库源代码仓库，即riscv-newlib。输入如下指令：</p><pre><code class=\"language-plain\">git clone https://gitee.com/mirrors/riscv-newlib\n</code></pre><p>6.下载二进制工具集合源代码仓库riscv-binutils，输入如下指令：</p><pre><code class=\"language-plain\">git clone -b riscv-binutils-2.35 https://gitee.com/mirrors/riscv-binutils-gdb riscv-binutils\n</code></pre><p>7.最后，下载GDB软件调试器源代码仓库riscv-gdb，输入如下指令：</p><pre><code class=\"language-plain\">git clone -b fsf-gdb-10.1-with-sim https://gitee.com/mirrors/riscv-binutils-gdb riscv-gdb\n</code></pre><p>好，现在所有的RISC-V工具链的源代码，我们已经下载完了。我们一起来同步一下，确保你我的riscv-gnu-toolchain目录下的目录和文件，完全一致。</p><p>在riscv-gnu-toolchain目录的终端下输入ls指令，你应该得到和后面这张图一样的结果。</p><p><img src=\"https://static001.geekbang.org/resource/image/e8/34/e8307c6cabf00a3fccc4a0e0a93b3034.jpg?wh=1910x1154\" alt=\"图片\"></p><h3>第三步：配置工具链</h3><p>在我们用宿主编译器编译所有的RISC-V工具链的源代码之前，还有最重要的一步，那就是配置RISC-V工具链的功能。</p><p>RISC-V工具链有很多配置选项，不同的配置操作会生成具有特定功能的RISC-V工具链。此外，配置操作还有一个功能，就是检查编译RISC-V工具链所依赖的工具和库。检查通过，就会生成相应的配置选项文件，还有用于编译操作的Makefile文件。</p><p>下面我们开始配置操作。为了不污染源代码目录，我们可以在riscv-gnu-toolchain目录下建立一个build目录，用于存放编译RISC-V工具链所产生的文件。还是在切换到riscv-gnu-toolchain目录的终端下，输入如下指令：</p><pre><code class=\"language-plain\">mkdir build  #建立build目录\n#配置操作，终端一定要切换到build目录下再执行如下指令\n../configure --prefix=/opt/riscv/gcc --enable-multilib --target=riscv64-multlib-elf\n</code></pre><p>我给你解释一下指令里的关键内容。</p><p>–prefix表示RISC-V的工具链的安装目录，我们一起约定为“/opt/riscv/gcc”这个目录。</p><p>–enable-multilib表示使用multlib库，使用该库编译出的RISC-V工具链，既可以生成RISCV32的可执行程序，也可以生成RISCV64的可执行程序，而默认的Newlib库则不行，它只能生成RISCV（32/64）其中之一的可执行程序。</p><p>–target表示生成的RISC-V工具链中，软件名称的前缀是riscv64-multlib-elf-xxxx。若配置操作执行成功了，build目录中会出现如下所示的文件：</p><p><img src=\"https://static001.geekbang.org/resource/image/86/5e/86a3b65f445394f1e8be61e3470e9f5e.jpg?wh=1920x1271\" alt=\"图片\"></p><h3>第四步：编译工具链</h3><p>最后我们来完成第四步，编译RISC-V工具链。只要配置操作成功了，就已经成功了90%。其实编译操作是简单且高度自动化的，我们只要在切换到build目录的终端下，输入如下指令即可：</p><pre><code class=\"language-plain\">sudo make -j8\n</code></pre><p>这个指令在编译完成后会自动安装到“/opt/riscv/gcc”目录，由于要操作“/opt/riscv/gcc”目录需要超级管理员权限，所以我们要记得加上sudo。</p><p>另外，如果你的宿主机的CPU有n个核心，就在make 后面加-j（n*2），这样才能使用多线程加速编译。</p><p>好了，一通操作猛如虎，现在最重要的事情是等待计算机“搬砖”了。你不妨播放音乐，泡上一杯新鲜的热茶，一边听歌，一边喝茶……估计要喝很多杯茶，才会编译完成。最最重要的是这期间不能断电，否则几个小时就白费了。</p><p>如果终端中不出现任何错误，就说明编译成功了。我们在终端中切换到“/opt/riscv/gcc/bin”目录下，执行如下指令：</p><pre><code class=\"language-plain\">riscv64-unknown-elf-gcc -v\n</code></pre><p>上述指令执行以后，会输出riscv64-unknown-elf-gcc的版本信息，这证明RISC-V工具链构建成功了。如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/d6/be/d62cf1b12d532aea1643118ea117febe.jpg?wh=1920x1271\" alt=\"图片\"></p><p>到这里，我们环境已经成功了一半，有了交叉编译器，并且这种交叉编译器能生成32位的RISC-V平台的可执行程序，也能生成64位的RISC-V平台的可执行程序。</p><p>你可能会好奇，成功了一半，那另一半呢？这需要我们接着干另一件事。什么事呢？容我先在这里卖个关子，下节课再揭秘。</p><h2>重点回顾</h2><p>通过这节课的学习，我们成功构建了RISC-V工具链，这样就能在X86平台上生成RISC-V平台的可执行程序了。下面让我们一起回顾一下，这节课中都做了些什么。</p><p>我们首先约定了宿主环境，需要用到Ubuntu或者Deepin的Linux发行版，无论你是将它们安装在物理PC上，还是安装在虚拟机上。</p><p>然后我们了解了什么是交叉编译。为了方便后面课程学习动手实践，我们要在x86平台的宿主机上编译生成RISC-V平台的可执行程序。</p><p>明确了目标，我们一起动手开始构建了一个RISC-V交叉编译器。你会发现其中不只是C/C++编译器，还有很多处理二进制可执行程序的工具，我们把这些统称为RISC-V工具链。</p><h2>思考题</h2><p>请你说一说交叉编译的过程？</p><p>期待你再留言区分享自己的实验笔记，或者与我交流讨论。也推荐你把这节课分享给更多朋友，我们一起玩转交叉编译。</p>","neighbors":{"left":{"article_title":"11｜手写CPU（六）：如何让我们的CPU跑起来？","id":552924},"right":{"article_title":"13｜小试牛刀：跑通RISC-V平台的Hello World程序","id":555771}}},{"article_id":555771,"article_title":"13｜小试牛刀：跑通RISC-V平台的Hello World程序","article_content":"<p>你好，我是LMOS。</p><p>在上一课中，我们一起约定了主环境，安装了编译工具和依赖库，构建了交叉编译RISC-V工具链。</p><p>今天我们继续构建RISC-V版的模拟器QEMU（代码你可以从<a href=\"https://gitee.com/lmos/Geek-time-computer-foundation/tree/master/lesson12~13\">这里</a>下载），让它成为“定制款”，更匹配我们的学习需要。为此，我们需要设置好主环境的环境变量，安装好VSCode及其插件，这样才能实现编辑、编译、运行、调试RISC-V程序的一体化、自动化。</p><p>话不多说，我们开始吧。</p><h2>RISC-V运行平台</h2><p>有了上节课成功构建好的交叉编译器，有很多同学可能按捺不住，急着想写一个简单的Hello World程序，来测试一下刚刚构建的交叉编译器。</p><p>恕我直言，这时你写出来的Hello World程序，虽然会无警告、无错误的编译成功，但是只要你一运行，铁定会出错。</p><p>这是为什么呢？因为你忘记了交叉编译器，生成的是RISC-V平台的可执行程序，这样的程序自然无法在你的宿主机x86平台上运行，它只能在RISC-V平台上运行。</p><p>摸着自己的荷包，你可能陷入了沉思：难道我还要买一台RISC-V平台的计算机？这样成本可太高了，不划算。</p><p>贫穷让人学会变通，为了节约成本，我们希望能用软件模拟RISC-V平台。嘿！这当然可以，而且前辈们，早已给我们写好了这样的软件，它就是QEMU。</p><!-- [[[read_end]]] --><h2>揭秘QEMU</h2><p>什么是QEMU？QEMU是一个仿真器或者说是模拟器软件，与市面上BOCHS类似，由软件来实现模拟。</p><p>QEMU就像计算机界的“孙悟空”，变化多端，能模拟出多种类型的CPU，比如IA32、AMD64、ARM、MIPS、PPC、SPARC、RISC-V等。QUEM通过动态二进制转换来模拟CPU。除了CPU，它还支持模拟各种IO设备，并提供一系列的硬件模型。这使得QEMU能模拟出完整的硬件平台，使得QEMU能运行各种操作系统，如Windows和Linux。</p><p>你可以把QEMU当做一个“双面间谍”，因为在它上面运行的操作系统，也许还认为自己在和硬件直接打交道，其实是同QEMU模拟出来的硬件打交道，QEMU再将这些指令翻译给真正硬件进行操作。通过这种模式，QEMU运行的操作系统就能和宿主机上的硬盘、网卡、CPU、CD-ROM、音频设备、USB设备等进行交互了。</p><p>由于QEMU的以上这些特点，导致QEMU在宿主平台上可以模拟出其它不同于宿主平台的硬件体系，这是QEMU的优点。</p><p>不过，由于是用了软件来实现的模拟，所以性能很差，这也是QEMU的缺点。正因为这个缺点，后来就出现了<strong> QEMU和KVM结合使用的解决方案</strong>。</p><p>KVM基于硬件辅助的虚拟化技术，主要负责比较繁琐的CPU和内存虚拟化，而QEMU则负责 I/O设备的模拟，两者合作各自发挥自身的优势，成就了强强联合的典范。</p><p>回归主题，关于QEMU，现阶段你最需要记住的就是，它有<strong>两种主要工作模式：系统模式和用户模式。</strong></p><p>在系统工作模式下，QEMU能模拟整个计算机系统，包括CPU及其他IO设备。它能运行和调试不同平台开发的操作系统，也能在宿主机上虚拟不同数量、不同平台的虚拟电脑。而在用户工作模式，QEMU能建立一个普通进程，运行那些由不同体系处理器编译的应用程序，比如后面我们要动手编写的RISC-V版的Hello World程序。</p><h2>构建我们的“定制款”QEMU</h2><p>说了这么多，其实是想让你更加了解QEMU。</p><p>下面我们来办正事儿——构建适合我们的QEMU，如果我们不是有特殊要求——模拟RISC-V平台且带调试功能的QEMU，用不着亲自动手去构建，只需要一条安装指令就完事了。</p><p>构建QEMU用四步就能搞定：首先下载QEMU源代码，接着配置QEMU功能选项，然后编译QEMU，最后安装QEMU。</p><p>我们需要从QEMU<a href=\"https://www.qemu.org/\">官网</a>上<a href=\"https://download.qemu.org/qemu-6.2.0.tar.xz\">下载稳定版本</a>的QEMU源代码。如果你和我一样，觉得在浏览器上点来点去非常麻烦，也可以在切换到RISCV_TOOLS目录的终端下，输入如下指令：</p><pre><code class=\"language-plain\">wget https://download.qemu.org/qemu-6.2.0.tar.xz #下载源码包\ntar xvJf qemu-6.2.0.tar.xz #解压源码包\n</code></pre><p>这里跑完第一条指令以后，下载下来的是压缩的QEMU源码包。所以，在下载完成后，你要用第二条指令来解压。</p><p>由于<a href=\"https://time.geekbang.org/column/article/554509\">上节课</a>我们构建RISC-V工具链时，已经统一安装了构建QEMU所需要的相关依赖库，所以这里就不用安装相关依赖库了。</p><p>解压成功后，我们就要开始配置QEMU的功能了。同样，为了不污染源代码目录，我们可以先在qemu-6.2.0目录下，建立一个build目录，然后切换到build目录下进行配置，输入如下指令：</p><pre><code class=\"language-plain\">mkdir build #建立build目录\ncd build #切换到build目录下\n../configure --prefix=/opt/riscv/qemu --enable-sdl --enable-tools --enable-debug --target-list=riscv32-softmmu,riscv64-softmmu,riscv32-linux-user,riscv64-linux-user #配置QEMU\n</code></pre><p>上述配置选项中，–prefix表示QEMU的安装目录，我们一起约定为“/opt/riscv/qemu”目录，–enable-sdl表示QEMU使用sdl图形库， --enable-tools表示生成QEMU工具集，–enable-debug表示打开QEMU调试功能。</p><p>最重要的是<strong> --target-list </strong>这个选项，它表示生成QEMU支持的模拟目标机器。不同选项所支持的平台不同，我们的选择如下表所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/18/7d/1893274bf776382cd139692e9aaf397d.jpg?wh=1920x804\" alt=\"图片\"></p><p>如果你什么都不选的话，它会默认生成QEMU支持的所有平台。按前面我们讲的操作配置，配置成功后，build目录下会生成后面截图里展示的文件和目录。</p><p><img src=\"https://static001.geekbang.org/resource/image/61/22/612cb5524109cc97a8ce1e4b2810d922.jpg?wh=1920x1527\" alt=\"图片\"></p><p>配置好功能选项之后，下一步就是编译QEMU了。只要配置成功了，编译这事儿就非常简单了，我们只要输入如下指令，然后交给计算机编译就好了。别忘了等待期间泡杯茶，不知道你会不会像我一样哼起那首歌：“世上有没有人，安静的等待你，一直不愿回神……”</p><pre><code class=\"language-plain\">sudo make -j8\n</code></pre><p>最后就是安装QEMU，经过漫长等待以后，我们终于迎来编译的成功。这时，你还需要输入如下指令进行安装。</p><pre><code class=\"language-plain\">sudo make install\n</code></pre><p>这里说明一下，QEMU不像RISC-V工具链那样，会在编译结束后自动安装，它需要手动安装。</p><p>我们在终端中切换到“/opt/riscv/qemu/bin”目录下，执行如下指令：</p><pre><code class=\"language-plain\">qemu-riscv32 -version &amp;&amp; qemu-riscv64 -version &amp;&amp; qemu-system-riscv32 -version &amp;&amp; qemu-system-riscv64 -version\n</code></pre><p>上述指令会输出qemu-riscv32、qemu-riscv64、qemu-system-riscv32、qemu-system-riscv64的版本信息，以证明能运行RISC-V平台可执行程序的QEMU构建成功。你可以对照一下后面的截图。</p><p><img src=\"https://static001.geekbang.org/resource/image/5f/a0/5f293367bb0821cyy49ee1d3a2c4bfa0.jpg?wh=1920x1162\" alt=\"图片\"></p><p>到这里，RISC-V平台的编译环境和执行环境已经构建完成，并且能生成和执行32位或者64位的RISC-V平台的可执行程序，无论是RISC-V平台的应用程序，还是RISC-V平台的操作系统。</p><h3>处理环境变量</h3><p>不知道你发现了没有？我们运行QEMU和RISC-V工具链相关的程序，都要切换到/opt/riscv/xxxx/bin目录中才可以运行，而不是像Linux中的其它程序，可以直接在终端中直接运行。</p><p>革命还未成功，我们还得努力。这是因为我们没有将QEMU和RISC-V工具链的安装目录，加入到Linux的环境变量中。</p><p>接下来我们就开始处理环境变量，修改环境的方法有好几种。这里我为你演示比较常用的一种，那就是在当前用户目录下的“.bashrc”文件中，加入相关的指令。</p><p>这里说的“当前用户的目录”就是在终端中执行\"cd ~\" 指令。怎么操作呢？我们切换到当前用户目录下，来执行这个指令。然后，在文件尾部加上两行信息就行了。具体指令如下所示：</p><pre><code class=\"language-plain\">cd ~ #切换到当前用户目录下\nvim ./.bashrc #打开.bashrc文件进行编辑\n\n#在.bashrc文件末尾加入如下信息\nexport PATH=/opt/riscv/gcc/bin:$PATH\nexport PATH=/opt/riscv/qemu/bin:$PATH\n</code></pre><p>上述操作完成以后，你会看到下图所示的结果：<br>\n<img src=\"https://static001.geekbang.org/resource/image/ef/3c/eff44c66b93b1aa531b46b47f2095d3c.jpg?wh=1920x1162\" alt=\"图片\"></p><p>随后，我们按下键盘上ESC键，接着输入\":wq\"以便保存并退出Vim。这样操作后，你会发现环境变量并没有生效。</p><p>这里还差最后一步，我们在终端中输入如下指令，让环境变量生效：</p><pre><code class=\"language-plain\">source ./.bashrc\n</code></pre><p>现在，你在任何目录之下输入QEMU和RISC-V工具链相关的程序命令，它们就都可以正常运行了。</p><h3>安装VSCode</h3><p>有了QEMU和RISC-V工具链相关的程序命令，我们虽然可以编译调试和执行RISC-V平台的程序了，但是必须在终端中输入多条指令，才能完成相关的工作。</p><p>这对于很多同学来说，肯定觉得很陌生，特别是在图形化盛行的今天，我们更期待能有个轻量级的IDE。</p><p>这里我们约定使用VSCode，它安装起来也很简单。在 <a href=\"https://code.visualstudio.com/Download\">VSCode官网</a>上下载deb包，下载后双击deb安装，或者切换到刚才下载VSCode目录的终端中，输入如下指令就行了。</p><pre><code class=\"language-plain\">sudo apt-get install -f *.deb\n</code></pre><p>安装好后，在你的桌面会出现VSCode图标，双击打开后的页面如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/e8/01/e80a0f46c534d870483fb74df77ecb01.jpg?wh=1920x1019\" alt=\"图片\"></p><p>不过，有了VSCode我们目前只能写代码，还不能编译和调试代码，所以需要给VSCode安装C/C++扩展。我们只需打开VSCode，按下ctrl+shift+x，就能打开VSCode的扩展页面，在搜索框中输入C/C++就可以安装了，如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/65/fc/65c609a360d33dfa7b1399c115yy49fc.jpg?wh=1920x1019\" alt=\"图片\"></p><p>至此，我们的VSCode及其需要的扩展组件就安装完成了。</p><p>下一步，我们还需要在你的代码目录下建立一个.vscode文件夹，并在文件里写上两个<a href=\"https://shimo.im/docs/7SK6Z1S7WEwgxM5U\">配置文件</a>。这两个配置文件我已经帮你写好了，如下所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/7f/f1/7fd7yycd59e982ec7b104b47cf5009f1.jpg?wh=1920x1019\" alt=\"图片\"></p><p>在.vscode文件夹中有个tasks.json文件，它主要负责完成用RISC-V编译器编译代码的功能，还有用QEMU运行可执行文件的功能。</p><p>我们先说说这里的编译工作是怎么完成的。具体就是通过调用make，读取代码目录中的Makefile脚本，在这个脚本中会调用riscv64-unknown-elf-gcc完成编译。等编译成功后，才会调用QEMU来接手，由它运行编译好的可执行程序。代码注释已经写得很清楚了，你可以停下来仔细看看。</p><p>不过，tasks.json文件虽然解决了编译与运行的问题，但是它也是被其它文件调用的。被谁调用呢？那就是我们的调试配置文件launch.json文件，它用于启动调试器GDB，只不过这里启动的不是宿主平台上的GDB，而RISC-V工具链中的GDB。其内容如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/80/5b/80870a7d1a7f35b11228f6e7810c145b.jpg?wh=1920x1019\" alt=\"图片\"></p><p>当我们写好代码后，按下F5键后，VSCode就会执行launch.json文件的调试操作了。这里调试器和要调试的可执行程序已经制定好了。不过由于preLaunchTask的指定，开始执行调试命令之前，VSCode会首先执行tasks.json文件中的操作，即编译和运行。</p><h3>运行Hello World</h3><p>下面我们一起来写下那个著名的程序——Hello World！写好后，在main函数所在的行前打上一个断点，按下F5键，就会看到如下界面。</p><p><img src=\"https://static001.geekbang.org/resource/image/9c/7b/9c14c4def94c7d719f732822b7fc807b.jpg?wh=1920x1019\" alt=\"图片\"></p><p>如果不出意外，哈哈，放心，按我提供给你的步骤，也出不了意外，你一定会看到以上界面。</p><p>我们重点来观察红色方框中的信息，可以查看代码变量值、CPU的寄存器值、函数的调用栈、断点信息、源代码以及程序执行后在VSCode内嵌终端中输出的信息。有了这些信息，我们就能清楚地看到一个程序运行过程的状态和结果。</p><p>走到这里，我们的定制款QEMU以及VSCode就搭好了，可以去图形化编辑、编译、运行和调试RISC-V平台的可执行程序了。</p><h2>重点回顾</h2><p>好了，我们的RISC-V平台的Hello World，也是我们在宿主机上开发的第一个非宿主机的程序，现在已经成功运行，这说明我们之前的工作完成得很完美，今天的课程不知不觉也接近了尾声。</p><p>下面来回顾一下，这节课我们都做了些什么。</p><p>首先，我们构建了能运行RISC-V可执行程序的QEMU模拟器，这使得我们不必购买RISC-V平台的机器，就能在宿主机上运行RISC-V可执行程序。这不但大大方便了我们的开发工作，而且节约了成本。</p><p>然后，我们处理了环境变量，方便我们在任何目录下，都可以随意使用RISC-V工具链中的命令和QEMU相关的命令。</p><p>最后，我们安装了VSCode，还在其中安装C/C++扩展并对其进行了相应的配置。以后我们在VSCode图形环境下编写代码、编译代码和调试代码，就能一气呵成了。</p><p>这节课的要点我整理了导图，供你参考。</p><p><img src=\"https://static001.geekbang.org/resource/image/ba/be/ba36676884beyy0be6ec1f267b6215be.jpg?wh=1920x1430\" alt=\"图片\"></p><p>恭喜你坚持到这里，通过两节课的内容，我们拿下了开发环境这一关，这对我们后续课程中的实验相当重要。下一模块讲解和调试RISC-V汇编指令的时候，你会进一步体会到环境搭建好的便利，先好好休息一下，咱们下节课见。</p><h2>思考题</h2><p>处理环境变量后为什么要执行source ./.bashrc，才会生效？</p><p>欢迎你在留言区提问或者晒晒你的实验记录。如果觉得有收获，也推荐你把这节课分享给你的朋友。</p>","neighbors":{"left":{"article_title":"12｜QEMU：支持RISC-V的QEMU如何构建？","id":554509},"right":{"article_title":"14｜走进C语言：高级语言怎样抽象执行逻辑？","id":557209}}},{"article_id":557209,"article_title":"14｜走进C语言：高级语言怎样抽象执行逻辑？","article_content":"<p>你好，我是LMOS。</p><p>前面我们设计了迷你CPU，相信你已经对CPU如何执行指令有了一定的了解。</p><p>而CPU执行的指令，正是由工程师敲出来的高级编程语言产生的。比如我们熟知的C、CPP、JAVA等。</p><p>平时我们做编程的时候，底层CPU如何执行指令已经被封装好了，因此你很少会想到把底层和语言编译联系在一起。但从我自己学习各种编程语言的经历看，从这样一个全新视角重新剖析C语言，有助于加深你对它的理解。</p><p>这节课我们首先要了解CPU执行指令的过程，然后再来分析C语言的编译过程，掌握C语言的重要组成，最后我们再重点学习C语言如何对程序以及程序中的指令和数据进行抽象，变成更易于人类理解的语言（代码从<a href=\"https://gitee.com/lmos/Geek-time-computer-foundation/tree/master/lesson14\"><strong>这里</strong></a>下载）。</p><h3>CPU执行指令的过程</h3><p>通过之前的学习，我们已经知道了CPU执行一条特定指令的详细过程，它们是取指、译码，执行、访存、回写。这是一个非常详细的硬件底层细节，我们现在再迈一个台阶，站高一点，<strong>从软件逻辑的角度看看CPU执行多条指令的过程</strong>。</p><p>这个过程描述起来很简单，就是一个循环。为了让你分清每个步骤，我分点列一下：</p><p>1.以PC寄存器中值为内存地址A，读取内存地址A中的数据。</p><p>2.CPU把内存地址A中的数据作为指令执行，具体执行过程为取指、译码，执行、访存、写回。</p><!-- [[[read_end]]] --><p>3.将PC寄存器中的值更新为内存地址A+（一条指令占用的字节数）。</p><p>4.回到第一步。</p><p>上述过程就是CPU执行指令的逻辑过程。下面我们动手来写几行代码，调试一下，观察一下内存的内容和CPU寄存器的变化，这样你就更加清楚了。代码如下：</p><pre><code class=\"language-plain\">.text\t\t\n\n.global\tmain\nmain:\t\t\t\t\t# main函数\n\tadd t1,zero,1\t\t# x6 = 1\n\tadd t2,zero,2\t\t# x7 = 2\n\tadd t0,t1,t2\t\t# x5 = x6 + x7\n\tadd a0,zero,zero \t# x10 = 0 相当于main函数中的return 0\n  ret\n</code></pre><p>这是一段RV32I指令集编写的汇编代码，现在你无法完全理解这段代码也没关系，能看懂注释就行了。</p><p>下面我们一起打开我为你们准备<a href=\"https://gitee.com/lmos/Geek-time-computer-foundation/tree/master/lesson14\">工程代码</a>，调试一下。如何用VSCode调试代码，我在环境那节课讲过了，记不清了可以回顾一下。</p><p>这里我们用VSCode打开本课的目录，设置好断点，按下“F5”键，就行了，如下所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/1c/01/1c036c9c63d1f9375297967183215501.jpg?wh=1920x1019\" alt=\"图片\"></p><p>我们看到t0、t1、t2寄存器中的数据和我们预期的一样。PC寄存器从0x10120，一直变化到0x1012c，每执行一条指令PC寄存器的值都要加4，这是因为每条RV32I指令都占用4字节的内存空间。</p><p>我们在调试控制台中执行：“-exec x/16xb 0x10120”命令，即可显示从0x10120开始的16字节内存数据，刚好4条指令的数据。我还在文稿里画了一幅图，它展示了内存中的情况，如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/b3/38/b3c8155114a94966cfyy30086fdf6438.jpg?wh=1920x1429\" alt=\"图片\"></p><p>对照示意图，我来为你解释一下，大致逻辑是这样的：最开始，由CPU控制单元通过控制总线发出要读取数据的控制信号。接着通过地址总线发送地址信号（当前情况下地址数据来源PC寄存器（0x10120）），然后通过数据总线传送指令数据(0x00100313)，最后执行单元拿到指令数据开始执行，并增加PC寄存器使之指向下一条指令。重复这个过程，内存中的指令就能一条一条地执行了。</p><h3>C语言编译过程</h3><p>了解了CPU执行逻辑过程之后，我们再来看看内存中的指令数据是如何产生的。</p><p>其实数据产生的方式有很多，我们可以用手写，也可以用电子编程器。只不过这样的方式，太古老了，也太低效了，更加容易出错。所以人们之后设计汇编语言时，实现了指令符号化，这看似高级了不少，但是依然是低效且难以理解的。</p><p>直到后来人们开发出了高级语言，进一步抽象，形成更容易让人们理解的形式。但是<strong>因为CPU始终只认识那些二进制数据，就需要把高级语言转化成为二进制数据，这个转化的过程叫编译过程，完成这个转化的工具软件就叫编译器。</strong></p><p>比如下面要讲的C语言编译器编译C语言的过程。我们先通过示意图来理解这一过程，建立一个整体印象，如下所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/65/ca/65d91c8c35430a97949de0a9fc2f59ca.jpg?wh=1920x1535\" alt=\"图片\"></p><p>现代的C预处理器、C编译器、汇编器、链接器是独立的程序，可以分开独立工作，并不是一个程序完成上图中所有的工作。</p><p>因为我们不开发编译器，这里你不需要理解词法、语法是如何分析的，中间代码是怎样优化的。我们要关注的焦点是，从C源代码到二进制机器指令数据的转化过程。</p><h3>C语言的重要组成</h3><p>想要弄清楚C如何跟二进制指令数据转化，首先要清楚C语言的重要组成部分。你可能会说，C语言的重要组成当然是C语言代码。这个说法当然没错，但代码只是一个统称。从不同层次抽象，里面的内容是不一样的：从高层次看代码中只有申明和定义，下一层看代码只有函数和变量，变量进一步分解还有不同的类型。</p><p>硬背这些分类只会让你晕头转向。接下来我们不妨分析一下，想要让一段C语言代码编译通过，需要哪些重要成分和逻辑结构。</p><p>我们在C语言中经常容易混淆声明和定义这两个概念，我们先来看看声明。</p><p>声明是给变量、函数、结构体等命名，表明在程序代码中有该变量、函数、结构体，我们来看看下图中的代码：</p><p><img src=\"https://static001.geekbang.org/resource/image/62/9b/6297287620499304320cedc4cbef7e9b.jpg?wh=1920x1019\" alt=\"图片\"></p><p>我们在declaration.c程序文件中，声明了一个整型变量，一个结构体变量，一个函数。然后我们编译它，确实能编译成功，这说明在C语言文法中仅仅需要有声明就可以，当然空文件也是可以的。声明不会分配内存空间。</p><p>这里需要注意的是，只有声明的代码确实能编译成功，但链接的时候就不一定了，我们这里之所以能链接成功。是因为在其它代码中没有对这些声明进行了引用。</p><p>下面我们来看看定义，定义是具体给变量分配内存空间。这个内存空间可以是初始化的，也可以是没有初始化的、给出具体函数的实现。</p><p>具体函数可以是空函数，函数中没有语句什么都不做也可以，唯一必需的就是指明结构体成员。结构体也是变量，只不过结构体是多个变量的组合，同样要分配内存空间，可以初始化也可以不做初始化。</p><p>我们写代码验证一下对不对，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/c6/cc/c6b423821b0d991bd47a7c8ee09c8ecc.jpg?wh=1920x1019\" alt=\"图片\"></p><p>我们还是在definition.c程序文件中，定义了一个整型变量，一个结构体变量，一个函数。我们同样能成功编译它。这说明C语言文法中没有声明，只有定义也可以成功编译的，其实C语言文法的原则是，<strong>声明可以出现很多次，定义有且只能出现一次</strong>。声明和定义也可以同时出现。</p><p>现在我来总结一下，其实编译的其中一个过程，就是用某种编程语言的文法来检查所写语言（代码）是否正确。你可以这么理解，语言的文法就是对这种语言的最高抽象，所以我们可以说 <strong>C语言最重要的组成部分就是声明或者定义。</strong></p><p>声明或者定义中又包含变量和函数，变量又有指针、数组、结构体，它们又包含各种类型，而函数中包含了各种表达式，各种表达式对变量进行操作。</p><p>编译器的语法分析过程，就是这样层层递归推导下去，最终构建出语法树，从而检查语言是否正确无误、是否符合该语言文法的规则定义，都符合编译才能通过。就像你学英文一样，你怎么判断一条英语句子是否正确呢？你会拿主谓宾等等约定俗成的语法去套，如果能套上去，就是正确的。</p><h3>C语言对程序的抽象</h3><p>前面我们已经从整体上了解了C语言的重要组成，可以看出，一段程序从语法角度来说就是声明加上定义。</p><p>现在我们继续深入了解C语言对程序的抽象，平时我们最多是使用设计好的C语言。而现在我们要站在C语言设计者的角度想一想，一门既能写程序，又更容易让人类理解的语言要怎么设计？其实这门语言的“设计过程”，就是C语言对机器语言的抽象，也就是C语言对程序的抽象。</p><p>我特意为你绘制了一幅图，我们从C语言的核心语言元素开始了解。这些元素就像英文里的各种固定词型，知道了这些元素在C语言中发挥的作用，你就找到了理解C语言的钥匙。</p><p><img src=\"https://static001.geekbang.org/resource/image/e5/a1/e57605892f5465d2bbc48960c3c700a1.jpg?wh=1920x2520\" alt=\"图片\" title=\"一图读懂C语言\"></p><p>我们看到C语言中，包含声明和定义，可以声明变量和函数，由图中绿色箭头指向。也可以定义变量和函数，由图中蓝色箭头指向，注意定义只能出现一次，声明可以出现多次。</p><p>我故意安排指针在最前端，是因为从C语言特性讲，指针能指向任一变量和函数，由图中红色箭头指向；从另一个角度看，指针就是内存，能自由寻址读写内存空间，但能否读写内存则要看操作系统给的权限，指针就是C语言中的“上帝之手”。同时，图中黑色线条还表示指针可以有相应的类型，并且能参与运算，这是我把指针放在比函数更高位置的原因。</p><p>需要注意的是，<strong>各种类型的变量是可以定义在函数以外的，这些定义在函数以外的变量是全局变量，而定义在函数内部的变量叫局部变量。</strong></p><p>如果我们要用C语言完成一个实际功能，一定要写一个函数。函数就是C语言中对一段功能代码的抽象。一个函数就是一个执行过程，有输入参数也有返回结果（根据需要可有可无），代码如下所示：</p><pre><code class=\"language-plain\">void func()\n{\n    return;\n}\n</code></pre><p>上面代码中的函数是空函数，C语言是允许的，当然这样的函数不会完成任何功能。</p><p>如果我们要完成点什么功能，就要在函数中写代码语句。代码语句又被抽象成表达式和流程控制。这也是为什么上图中函数下面包含了表达式和流程控制。</p><p>接下来，我们写个完成求两数之差、求两数之和的函数，代码如下所示：</p><pre><code class=\"language-plain\">int func(int op, int a, int b)\n{\n    if(op &lt; 1) //表达式：op &lt; 1 \n    {\n        return a - b;//表达式：a - b \n    }\n    return a + b;//表达式：a + b \n}\n</code></pre><p>上面代码中有三个表达式，注释中已经写明了，含有三种流程控制：if判断分支控制；return返回控制，还有默认的从上至下的代码顺序。你可以把上述代码拿到上图中去套，以证明C语言对代码语句的抽象，你会发现一套一个准。</p><p>下面我们继续研究一下表达式。从前面的图里，可以看到C语言表达式包含了变量和运算符。</p><p>变量又有各种类型，单个变量也是表达式，但是运算符不能单独存在变成表达式，所以C语言表达式要么是单个变量，要么是变量加运算符一起。根据运算符的类型不同，可以分成运算表达式、逻辑表达式、赋值表达式等。</p><p>下面我们使用代码实例来找找感觉，如下所示：</p><pre><code class=\"language-plain\">int sumdata = 0;//全局整型变量sumdata\nvoid func()\n{\n    int i = 1;//局部整型变量i\n    int *p; //局部整型指针变量p\n    p = &amp;sumdata;//把sumdata变量的地址赋值给p变量，从而指向sumdata变量\n    while(1)//循环流程控制\n    {\n        if(i &gt; 100)\n        {\n            break;//跳出循环，流程控制\n        }\n        (*p) += i;//相当于sumdata = sumdata + i\n        i = i + 1;\n    }\n    return;\n}\n</code></pre><p>上述代码所有的表达式中，涉及了一个全局变量，两个局部变量。其中局部变量中有一个是指针变量，指向全局的变量。包含了更多的流程控制语句，可以明显地看到表达式就是：变量和运算符组合在一起，完成了对变量的操作。而变量代表了数据，最终就能实现对数据的运算。但是变量有各种类型，这些类型只是规范了变量的位宽和大小，下一节我们会有更详细的介绍。</p><p>现在我们就可以总结一下，C语言是如何抽象程序的，如下表所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/87/83/87043296f491a61933346ebeaaae5b83.jpg?wh=1920x835\" alt=\"图片\"></p><p>这就是C语言对程序的抽象。到这里，今天的课程也到了尾声，你是否像我一样，想起了那个著名的公式：程序=算法+数据结构？</p><p>没错，C 语言就是函数 + 变量。函数表示算法操作，变量存放数据，即数据结构，合起来就是程序 = 算法 + 数据结构。</p><p>C语法的运算符和流程控制可以实现各种算法，而各种类型的变量组合起来，就能实现各种复杂的数据结构。理解了这些，你就抓住了C语言的本质，也为后续学习打下了良好的基础。</p><h3>重点回顾</h3><p>到这里今天的课程就告一段落了，我来总结一下这节课的重点。</p><p>首先我们研究了CPU执行指令过程和C语言编译过程。理解了这两个过程，后续的学习就有了良好基础。</p><p>接着我们进入到C语言内部，从宏观上理解了定义和声明这两个C语言的重要组成部分。声明只是一种说明性质的东西，不产生机器指令，而定义则是这实现，会产生对应的机器指令。</p><p>最后我们从C语言的核心语言元素入手，抽丝剥茧，层层解构。C语言由函数构成，函数中又包含多条语句，语句由流程控制和表达式构成，表达式由各种类型的变量和各种运算符构成。这些东西组合在一起，就把机器执行的程序抽象成了人类易于掌握和理解的概念——C语言。文稿里我总结的那张图，你不妨保存下来，作为你学习理解C语言的导航图。</p><p><img src=\"https://static001.geekbang.org/resource/image/48/2f/481f8bdcb349242b76d82a49508f032f.jpg?wh=1920x2681\" alt=\"图片\"></p><p>下节课我们继续研究C语言和汇编语言的对应关系，敬请期待。</p><h3>思考题</h3><p>为什么C语言中为什么要有流程控制？</p><p>期待你在留言区踊跃发言，积极思考有助于你更好地领会课程内容。也推荐你把这节课分享给身边的朋友，说不定就能让他进一步掌握C语言了。</p>","neighbors":{"left":{"article_title":"13｜小试牛刀：跑通RISC-V平台的Hello World程序","id":555771},"right":{"article_title":"15｜C与汇编：揭秘C语言编译器的“搬砖”日常","id":558338}}},{"article_id":558338,"article_title":"15｜C与汇编：揭秘C语言编译器的“搬砖”日常","article_content":"<p>你好，我是LMOS。</p><p>通过上一节课的学习，我们已经清楚了C语言可以把程序抽象成一个函数，这样的函数又抽象成表达式和流程控制，表达式又能进一步抽象成各种类型的变量和各种运算符。并且我们还搞懂了<strong>变量就是数据，运算符就是操作，而变量的运算结合起来就能对数据施加操作。</strong>这样拆分下来，是不是C语言就没那么神秘了？</p><p>今天，让我们就来继续揭秘C语言编译器的日常工作，搞清楚各种类型变量、各种运算符、流程控制以及由它们组成的函数，是如何对应到机器指令的（代码从<a href=\"https://gitee.com/lmos/Geek-time-computer-foundation/tree/master/lesson15\">这里</a>下载）。</p><p>此外，我还会带你了解函数间的调用规范，这能让我们在以后写代码时，清楚自己的每行代码都会被编译器转化为什么样的机器指令。</p><h3>C变量</h3><p>现在，我们从最基本的C语言的变量开始说起。</p><p>C语言是如何把各种类型的变量转换成对应的汇编语言呢？高级语言更容易被工程师理解，而汇编语言这样的低级语言，则更容易被机器解读。这是<strong>因为汇编语言里的大部分内容都跟机器语言一一对应，你可以这样理解，汇编语言就是把机器语言符号化。</strong></p><p>我举个例子让你加深理解，机器对应的加法指令是一段很长的二进制数据，在汇编语言中，这个指令就对应着“add”这个指令。无论是机器指令还是寄存器，经过汇编语言“翻译”出来都是符号。</p><!-- [[[read_end]]] --><p>汇编器会将汇编源代码生成二进制程序文件。在程序二进制文件里有很多段。其中text段和data段在文件里占用位置空间，text段存放了程序指令的二进制数据，data段放着各种已经初始化的数据。二进制文件里还有个<strong>更特殊的bss段</strong>，它不占用文件的位置空间，而是在文件头里记录bss段的大小。</p><p>一旦text、data段加载到内存中运行，就会占用内存空间，自然也就对应到实际的内存。至于bss段，操作台会根据文件头里记录的大小给它分配内存空间，并初始为0。</p><p>有了这些基础，我们就可以写代码来进行验证了，如下所示：</p><pre><code class=\"language-plain\">//定义整型变量\nint i = 5;\n//定义字符变量\nchar chars = 'a';\n//定义结构体\nstruct data\n{\n    int a;\n    char c;\n};\n//定义结构体变量并初始化\nstruct data d = {10, 'b'};\n</code></pre><p>我们在代码中定义了三个不同类型的变量。在GCC编译器后面加上-save-temps 选项，就能留下GCC编译器各个步骤生成的临时文件，方便我们查看GCC逐步处理的结果。</p><p>我已经为你写好了makefile文件，你用VSCode打开项目代码，按下F5就会生成相应的临时文件xxxx.i、xxxx.s、xxxx.bin。</p><p>其中，xxxx.i是gcc编译器生成的预处理文件，xxxx.s是gcc编译器生成的汇编文件，xxxx.o是gcc编译器生成的可链接的目标文件，xxxx.bin是去除了ELF文件格式数据的纯二进制文件，这是我用objcopy工具生成的，这个文件可以方便我们后续观察。</p><p>下面我们打开项目代码中的variable.s文件，如下所示：</p><pre><code class=\"language-plain\">\t.globl\ti\t\t\t\t #导出全局标号i\n\t.section\t.sdata,\"aw\"  #创建sdata段，属性动态分配可读写\n\t.size\ti, 4\t\t\t #占用4字节大小\ni:\t\t\t\t\t\t\t #标号i\n\t.word\t5\t\t\t     #定义一个字，初始化为5\n        \n\t.globl\tchars\t\t\t #导出全局标号chars\n\t.size\tchars, 1\t\t #占用1字节大小\nchars:\t\t\t\t\t\t #标号chars\n\t.byte\t97\t\t\t\t #定义一个字节，初始化为97，正是‘a’字符的ascii码\n        \n\t.globl\td\t\t\t\t #导出全局标号d\n\t.size\td, 8\t\t\t #占用8字节大小\nd:\t\t\t\t\t\t\t #标号d\n\t.word\t10\t\t\t\t #定义一个字，初始化为10\n\t.byte\t98\t\t\t\t #定义一个字节，初始化为98，正是‘b’字符的ascii码\n\t.zero\t3\t\t\t\t #填充3个字节，数据为0\n</code></pre><p>上面的汇编代码和注释已经写得很清楚了，C语言的变量名变成了汇编语言中的标号，根据每个变量的大小，用多个汇编代码中定义数据的操作符，比如.byte、.word，进行定义初始化。</p><p>C语言结构体中的字段则要用多个.byte、.word操作符的组合实现变量定义，汇编器会根据.byte、.word来分配变量的内存空间，标号就是对应的地址。这个变量的内存空间，当程序处于非运行状态时就反映在程序文件中；一旦程序加载到内存中运行，其中的变量就会加载到内存里，对应在相应的内存地址上。</p><p>上述代码仍然是可读的文本代码，下面我们看看汇编器生成的二进制文件variable.bin，如下所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/bb/0c/bbe780751034318ec3dbf7099109620c.jpg?wh=1920x1019\" alt=\"图片\"></p><p>从这张文件截图里，我们能清楚地看到，二进制文件variable.bin一共有16字节，第5到第7个字节和第13到第15个字节为填充字节，这是为了让地址可以按32位对齐。我们可以看到i变量占用4个字节空间，chars变量占用1个字节空间，d结构体变量占用8个字节，里面有两个成员变量a和c。</p><p>截图中反映的情况，相当于从0开始分配地址空间，当然后面链接器会重新分配地址空间的，这里i变量地址为0，chars变量地址为4，d变量地址为8。</p><p>现在我们总结一下，C语言转化成汇编语言时发生了什么样的变化：<strong>C语言的变量名成了汇编语言的标号，C语言的变量对应的空间变成了汇编语言.byte、.word之类的定义数据操作符。最终，汇编器会根据.byte、.word分配内存空间。</strong>这些对应关系，我们通过对二进制文件的分析已经再清楚不过了。</p><h3>C语言表达式</h3><p>下面，我们来看看C语言表达式，了解C语言是怎么把各种表达式转换成对应的汇编语言的。</p><p>我先说明一下，这里本来应该介绍运算符的，但是C语言的运算符不能独立存在，必须要与变量结合起来形成表达式，所以这里我把运算符归纳到表达式里一起给你讲解，你学起来也更清晰。</p><p>我们先来写一个表达式，如下所示：</p><pre><code class=\"language-plain\">int add()\n{\n    //定义三个局部整形变量\n    int a, b, c; \n    //赋值表达式\n    a = 125;\n    b = 100;\n    //运算表达式\n    c = a + b;\n    //返回表达式\n    return c;\n}\n</code></pre><p>代码注释我为你标注了表达式的类型，至于代码的含义任何一个C语言初学者都能明白，就不过多讲解了。</p><p>接下来，我们直接看GCC编译器生成的汇编代码。GCC在编译代码时我加了“-O0”，这表示让GCC不做代码优化，如下所示：</p><pre><code class=\"language-plain\">add:\n\taddi\tsp,sp,-32\n\tsw\ts0,28(sp)\n\taddi\ts0,sp,32\n\tli\ta5,125\n\tsw\ta5,-20(s0)\n\tli\ta5,100\n\tsw\ta5,-24(s0)\n\tlw\ta4,-20(s0)\n\tlw\ta5,-24(s0)\n\tadd\ta5,a4,a5\n\tsw\ta5,-28(s0)\n\tlw\ta5,-28(s0)\n\tmv\ta0,a5\n\tlw\ts0,28(sp)\n\taddi\tsp,sp,32\n\tjr\tra\n</code></pre><p>上述的汇编代码你看不懂也没关系，且听我分段给你拆解。它们分别是：在栈中分配变量的内存空间、给变量赋值、进行运算、处理返回值、回收栈中分配的空间、返回。</p><p>我们首先看看C语言中的“int a,b,c;”，这是三个局部变量。在C语言中局部变量是放在栈中的，栈在后面的课程里我再介绍。这里就是给a、b、c这三个变量在栈中分配变量的内存空间，对应的代码如下所示：</p><pre><code class=\"language-plain\">\t# int a,b,c;\n    addi\tsp,sp,-32  #把栈指针寄存器减去32，相当于在栈中分配了32字节的空间\n\tsw\ts0,28(sp)\t   #首先把s0寄存器存放在（sp+28）的内存空间中\n\taddi\ts0,sp,32   #然后把s0寄存器设为原来sp寄存器的值\n</code></pre><p>上述代码通过减去sp寄存器的值，在栈中分配了内存空间。因为栈是由高地址内存空间向低地址内存空间生长的，所以分配栈内存空间是减去一个值。</p><p>接着我们来看看C语言中的“a=125;b=100;”，这两行代码就是给变量赋值，也可以叫做赋值表达式，对应的汇编代码如下所示：</p><pre><code class=\"language-plain\">\t# a=125;b=100;\n    li\ta5,125\t\t\t#125加载到a5寄存器中\n\tsw\ta5,-20(s0)\t\t#把a5寄存器储存到（s0-20）的内存空间中，即栈中\n\tli\ta5,100\t\t\t#100加载到a5寄存器中\n\tsw\ta5,-24(s0)\t\t#把a5寄存器储存到（s0-24）的内存空间中，即栈中\n</code></pre><p>现在我们已经看到了“=”赋值运算，被转化为机器的数据传输指令，即储存、加载和寄存器之间的传输指令。从-20、-24这些地址偏移量，我们可以推导出a，b两个整型变量各占4字节大小的空间。</p><p>然后，我们来看看C语言里“c = a + b;”这一行代码，它就是运算表达式，同时也赋值表达式，但运算表达式的优先级更高，对应的汇编代码如下所示：</p><pre><code class=\"language-plain\">    #c=a+b; \n    lw\ta4,-20(s0)\t\t#把（s0-20）内存空间中的内容加载到a4寄存器中\n\tlw\ta5,-24(s0)\t\t#把（s0-24）内存空间中的内容加载到a5寄存器中\n\tadd\ta5,a4,a5\t\t#a4寄存器加上a5寄存器的结果送给a5寄存器\n\tsw\ta5,-28(s0)\t\t#把a5寄存器储存到（s0-28）的内存空间中，即栈中\n</code></pre><p>上述代码中，我们再一次看到，C语言中的加法运算符被转化成了机器的加法指令，运算表达式中的变量放在寄存器中，就成了加法指令的操作数。但是运算结果也被放在寄存器中，而后又被储存到内存中了。</p><p>最后，我们来看看C语言中“return c;”这一行代码，也就是返回表达式。对应的汇编代码如下所示：</p><pre><code class=\"language-plain\">\t#return c;\n    lw\ta5,-28(s0)\t\t#把（s0-28）内存空间中的内容加载到a5寄存器中\n\tmv\ta0,a5\t\t\t#a5寄存器送给a0寄存器，作为返回值\n\tlw\ts0,28(sp)\t\t#恢复s0寄存器\n\taddi\tsp,sp,32\t#把栈指针寄存器加上32，相当于在栈中回收了32字节的空间\n\tjr\tra\t\t\t\t#把ra寄存器送给pc寄存器实现返回\n</code></pre><p>从上述代码块可以看到，先把c变量加载到a5寄存器中，又把a5寄存器送给了a0寄存器。</p><p>在语言调用标准中，a0寄存器是作为返回值寄存器使用的，return语句是流程控制语句，它被转换为机器对应的跳转指令，即jr指令。jr指令会把操作数送给pc寄存器，这样就能实现程序的跳转。</p><p>到这里，C语言表达式是怎么变成汇编语言的，我们就弄明白了。</p><h3>C语言流程控制</h3><p>如果只存在表达式，代码只能从上到下顺序执行，很多算法都无法实现，毕竟顺序执行就是“一条道走到黑”，这显然还不够。如果我们要控制代码的执行顺序，就需要流程控制。</p><p><strong>通过流程控制，C语言就能把程序的分支、循环结构转换成汇编语言。</strong>下面我们以C语言中最常用的for循环为例来理解流程控制。for循环这个例子很有代表性，因为它包括了循环和分支，代码如下所示。</p><pre><code class=\"language-plain\">void flowcontrol()\n{\n    //定义了整型变量i\n    int i;\n    for(i = 0; i &lt; 5; i++)\n    {\n        ;//什么都不做\n    }\n    return;\n}\n</code></pre><p>可以看到上述代码中，for关键字后面的括号中有三个表达式。</p><p>开始第一步先执行的是第一个表达式：i = 0; 接着第二步，执行第二个表达式。如果表达式的运算结果为false，就跳出for循环；然后到了第三步，执行大括号“{}”中的语句，这里是空语句，什么都不做；最后的第四步执行第三个表达式：i++，再回到第二步开始下一次循环。</p><p>下面我们看看这四步对应的汇编程序，如下所示：</p><pre><code class=\"language-plain\">flowcontrol:\n\taddi\tsp,sp,-32\n\tsw\ts0,28(sp)\n\taddi\ts0,sp,32\t\t# int i 定义i变量\n\tsw\tzero,-20(s0)\t\t# i = 0 第一步 第一个表达式 \n\tj\t.L2\t\t\t\t\t# 无条件跳转到.L2标号处\n.L3:\n\tlw\ta5,-20(s0)\t\t\t# 加载i变量\n\taddi\ta5,a5,1\t\t\t# i++ 第四步 第三个表达式 \n\tsw\ta5,-20(s0)\t\t\t# 保存i变量\n.L2:\n\tlw\ta4,-20(s0)\t\t\t# 加载i变量\n\tli\ta5,4\t\t\t\t# 加载常量4\n\tble\ta4,a5,.L3   \t\t# i &lt; 5 第二步 第二个表达式 如果i &lt;= 4就跳转.L3标号，否则就执行后续指令，跳出循环\n\tlw\ts0,28(sp)\t\t\t# 恢复s0寄存器\n\taddi\tsp,sp,32\t\t# 回收栈空间\n\tjr\tra\t\t\t\t\t# 返回\n</code></pre><p>有了前面的基础，上面这段代码应该很容易理解。</p><p>你可能有点疑惑，为什么代码的注释中没有看到第三步的内容？这是因为我们写了空语句，编译器没有生成相应的指令。一般CPU会提供多种形式的跳转指令，来实现程序的流程控制，后面课程里我们在专门研究和调试跳转指令，这里你先有个印象就行。</p><p>你不妨试着想象一下，图灵机那个读头在纸带上来回移动的情景。上面的代码中j，jr都是无条件的跳转指令，ble是带比较的条件分支指令，比较的结果为真，则跳转到相应的地址上继续执行；否则就会执行后面的下一条指令。</p><p>现在已经很清楚了，C语言正是用了这些跳转、条件分支指令，才实现了如if、for、while、goto、return等程序流程控制逻辑。</p><h3>C语言函数</h3><p>我们再来看看C语言函数，了解一下C语言是怎么把函数转换成汇编语言的。</p><p>通过前一节课的学习，我们知道了函数是C语言中非常重要的组成部分。我们要用C语言完成一个实际的功能，就需要至少写一个函数，可见函数就是C语言中对一段功能代码的抽象。一个函数就是一个执行过程，有输入参数也有返回结果（根据需要可有可无），可以调用其它函数，也被其它函数调用。</p><p>让我们去写函数验证一下，如下所示：</p><pre><code class=\"language-plain\">//定义funcB\nvoid funcB()\n{\n    return;\n}\n//定义funcA\nvoid funcA()\n{\n    //调用funcB\n    funcB();\n    return;\n}\n</code></pre><p>上述代码中定义了funcA、funcB两个函数，函数funcA调用了函数funcB，而函数funcB是个空函数，什么也不做。</p><p>下面我们直接看它们的汇编代码，如下所示：</p><pre><code class=\"language-plain\">funcB:\n\taddi\tsp,sp,-16\n\tsw\ts0,12(sp)\t\t\t#储存s0寄存器到栈中\n\taddi\ts0,sp,16\n\tnop\n\tlw\ts0,12(sp)\t\t\t#从栈中加载s0寄存器\n\taddi\tsp,sp,16\n\tjr\tra\t\t\t\t\t#函数返回\n\nfuncA:\n\taddi\tsp,sp,-16\n\tsw\tra,12(sp)\n\tsw\ts0,8(sp)\t\t\t#储存ra，s0寄存器到栈中\n\taddi\ts0,sp,16\n\tcall\tfuncB\t\t\t#调用funcB函数\n\tnop\n\tlw\tra,12(sp)\t\t\t#从栈中加载ra，s0寄存器\n\tlw\ts0,8(sp)\n\taddi\tsp,sp,16\n\tjr\tra\t\t\t\t\t#函数返回\n</code></pre><p>从上面的汇编代码可以看出，函数就是从一个标号开始到返回指令的一段汇编程序，并且C语言中的函数名就是标号，对应到汇编程序中就是地址。</p><p>即使是什么也不做的空函数，C语言编译器也会把它翻译成相应的指令，分配栈空间，保存或者恢复相应的寄存器，回收栈空间，这相当于一个标准的代码模板。</p><p>其中的call其实完成了两个动作：一是把call下一条指令的地址保存到ra寄存器中；二是把后面标号地址赋值给pc寄存器，实现程序的跳转。由于被跳转的程序段最后会执行jr ra，即把ra寄存器赋值给pc寄存器，然后再跳转到call指令的下一条指令开始执行，这样就能实现函数的返回。</p><p>总结一下，<strong>C语言编译器把函数名转换成了标号，也就是汇编程序里的某个地址，并且把函数的功能翻译成各种指令。</strong></p><p>这样我们写下一个函数，经过C语言编译器加工，就变成了CPU能够“听懂”的各种运算指令、流程控制指令。之后，CPU就能定位到相应的汇编代码段，在这些代码段之间跳来跳去，实现函数之间的调用。</p><h3>C语言调用规范</h3><p>现在我们来探讨另一个问题，就是一个函数调用另一个函数的情况，而且这两个函数不是同一种语言所写。</p><p>比如说，在汇编语言中调用C语言，或者反过来在C语言里调用汇编语言。这些情况要怎么办呢？这时候就需要有一种调用约定或者规范。</p><p>这个规范有什么用呢？前面的课程我们说过，CPU中的一些寄存器有特定作用的，自然不能在函数中随便使用。即使用到了也要先在栈里保存起来，然后再恢复。</p><p>这就引发了三个问题：一是需要规定好寄存器的用途；二是明确哪些寄存器需要保存和恢复；第三则是规定函数如何传递参数和返回值，比如用哪些寄存器传递参数和返回值。关于CPU寄存器的规定，你可以回顾一下<a href=\"https://time.geekbang.org/column/article/541776\">第二节课</a>。</p><p>首先我们看一下，C语言下的数据类型在RISC-V平台下所占据内存的大小，这也是调用规范的一部分，如下表：</p><p><img src=\"https://static001.geekbang.org/resource/image/3c/0c/3c76d13f3d73d80a82b99c7c09b14c0c.jpg?wh=1920x896\" alt=\"图片\"></p><p>下面我们结合实例来理解。我们先来写一段汇编代码和C代码，用汇编代码调用C函数，它们属于不同的文件，这些文件我已经在工程里给你准备好了。</p><p>首先，汇编代码如下：</p><pre><code class=\"language-plain\">.text                   //表明下列代码放在text段中\n.globl\tmain            //导出main符号，链接器必须要找的到main符号\nmain:\n\taddi sp,sp,-16\n\tsw\t s0,12(sp)      //保存s0寄存器\n\taddi s0,sp,16\n\tcall C_function     //调用C语言编写的C_function函数\n    li\t a0,0           //设置main函数的返回值为0\n\tlw\t s0,12(sp)      //恢复s0寄存器\n\taddi sp,sp,16\n\tjr\t ra             //返回\n</code></pre><p>上述代码放在了main_asm.S文件中，这些代码我都替你手动写好了，你需要从main开始，代码的作用你可以参考一下注释说明。</p><p>这段代码主要处理了栈空间，保存了s0寄存器，然后调用了C语言编写的C_function函数，该函数我放在了main_c.c文件中，如下所示：</p><pre><code class=\"language-plain\">#include \"stdio.h\"\nvoid C_function()\n{\n    printf(\"This is C_function!\\n\");\n    return;\n}\n</code></pre><p>我们用VSCode打开工程文件夹，按下“F5”键，就会出现后面图里显示的结果。<br>\n<img src=\"https://static001.geekbang.org/resource/image/db/0e/dbfyy912fb28b6a6b8b553c574936b0e.jpg?wh=1920x1019\" alt=\"图片\"></p><p>我们看到代码运行了，打印出了This is C_function!，而且没有出现任何错误，这说明我们通过汇编代码调用C函数成功了。你可以想一想，这个过程还有什么疏漏么？</p><p>以上代码的功能很简单，很多寄存器没有用到，所以并没有保护和恢复相应的寄存器。在复杂的情况下，调用者函数应该保存和恢复临时寄存器：t0~t6（整数寄存器），ft0~ft11（浮点寄存器）。被调用者函数应该保存和恢复的寄存器：s0~s11（整数寄存器），fs0~fs11（浮点寄存器）。</p><p>现在只剩最后一个问题了，C语言函数有参数和返回值。如果没有相应规范，一个C语言函数就不知道如何给另一个C语言函数传递参数，或者接收它的返回值。</p><p>我们同样用代码来验证一下，如下所示：</p><pre><code class=\"language-plain\">int addtest(int a, int b, int c,int d, int e, int f, int g, int h, int i)\n{\n    return a + b + c + d+ e + f + g + h + i;\n}\nvoid C_function()\n{\n    int s = 0;\n    s = addtest(1,2,3,4,5,6,7,8,9);\n    printf(\"This is C_function! s = %d\\n\", s);\n    return;\n}\n</code></pre><p>这段代码很简单，为了验证参数的传递，我们给addtest函数定义了9个参数，在C_function函数中调用它，并打印出它的返回值。</p><p>我们直接看看它生成的汇编代码，如下所示：</p><pre><code class=\"language-plain\">addtest:\n\taddi\tsp,sp,-48\n\tsw\ts0,44(sp)\n\taddi\ts0,sp,48 #让s0变成原sp的值\n    #依次将a0~a7，8个寄存器放入栈中 \n\tsw\ta0,-20(s0)\n\tsw\ta1,-24(s0)\n\tsw\ta2,-28(s0)\n\tsw\ta3,-32(s0)\n\tsw\ta4,-36(s0)\n\tsw\ta5,-40(s0)\n\tsw\ta6,-44(s0)\n\tsw\ta7,-48(s0)\n    #从栈中加载8个整型数据相加\n\tlw\ta4,-20(s0)\n\tlw\ta5,-24(s0)\n\tadd\ta4,a4,a5\n\tlw\ta5,-28(s0)\n\tadd\ta4,a4,a5\n\tlw\ta5,-32(s0)\n\tadd\ta4,a4,a5\n\tlw\ta5,-36(s0)\n\tadd\ta4,a4,a5\n\tlw\ta5,-40(s0)\n\tadd\ta4,a4,a5\n\tlw\ta5,-44(s0)\n\tadd\ta4,a4,a5\n\tlw\ta5,-48(s0)\n\tadd\ta4,a4,a5\n    #从栈中加载第9个参数的数据，参考第4行代码 \n\tlw\ta5,0(s0)\n\tadd\ta5,a4,a5\n    #把累加的结果放入a0寄存器，作为返回值\n\tmv\ta0,a5\n\tlw\ts0,44(sp)\n\taddi\tsp,sp,48 #恢复栈空间\n\tjr\tra\t\t\t #返回\n\nC_function:\n\taddi\tsp,sp,-48\n\tsw\tra,44(sp)\n\tsw\ts0,40(sp)\n\taddi\ts0,sp,48\n\tsw\tzero,-20(s0)\n\tli\ta5,9\n\tsw\ta5,0(sp)     #将9保存到栈顶空间中\n\tli\ta7,8\n\tli\ta6,7\n\tli\ta5,6\n\tli\ta4,5\n\tli\ta3,4\n\tli\ta2,3\n\tli\ta1,2\n\tli\ta0,1\t\t #将1~8，加载到a0~a7，8个寄存器中，作为addtest函数的前8个参数\n\tcall\taddtest  #调用addtest函数\n\tsw\ta0,-20(s0)   #addtest函数返回值保存到s变量中\n\tlw\ta1,-20(s0)   #将s变量作为printf函数的第二个参数\n\tlui\ta5,%hi(.LC0)\n\taddi\ta0,a5,%lo(.LC0)\n\tcall\tprintf\n\tnop\n\tlw\tra,44(sp)\n\tlw\ts0,40(sp)\n\taddi\tsp,sp,48 #恢复栈空间\n\tjr\tra\t\t\t #返回\n</code></pre><p>根据上面的代码，我们来总结一下，C语言函数用a0~a7这个8个寄存器，传递了一个函数的前8个参数。<strong>注意如果是浮点类型的参数，则使用对应的浮点寄存器fa0~fa7，从第9个参数开始依次存放在栈中,而函数的返回值通常放在a0寄存器中。</strong></p><p>到这里，C语言调用规范我们就搞清楚了。</p><h3>重点回顾</h3><p>这节课，我们一起研究了C语言编译器的“搬砖日常”，讨论了C语言跟汇编语言的对应关系。现在我们来回顾一下这节课的重点。</p><p>C语言变量经过编译器的加工，其变量名变成了汇编语言中的标号，也就是地址。变量空间由汇编语言中.byte、.word等操作符分配空间，有的空间存在于二进制文件中，有的空间需要OS加载程序之后再进行分配。</p><p>接着是C语言表达式，C语言表达式由C语言变量和C语言运算符组成，C语言运算符被转换成了对应的CPU运算指令。变量由内存加载到寄存器，变成了指令的操作数，一起完成了运算功能。</p><p>之后我们借助for循环这个例子，发现C语言函数会被编译器“翻译”成一段带有标号的汇编代码，里面包含了流程控制指令（比如跳转指令）和各种运算指令。这些指令能修改PC寄存器，使之能跳转到相应的地址上运行，实现流程控制。</p><p>最后我们讨论了C语言的调用规范。“没有规矩不成方圆”，<strong>调用规范解决了函数之间的调用约束</strong>，比如哪些寄存器由调用者根据需要保存和恢复，哪些寄存器由被调用者根据需要保存和恢复，函数之间如何传递参数，又如何接收函数的返回值等等的问题。</p><p>为了奖励你看到这里，我还准备了一张知识导图，供你复习回顾要点。</p><p><img src=\"https://static001.geekbang.org/resource/image/b7/ae/b7f30fb590ceb3a882bca53301ec05ae.jpg?wh=1920x1607\" alt=\"图片\"></p><p>下节课起，我们将会开始汇编指令的深入学习，敬请期待。</p><h3>思考题</h3><p>请问C语言函数如何传递结构体类型的参数呢？</p><p>欢迎你在留言区跟我交流互动，积极参与思考有助于你更深入地学习。如果觉得这节课还不错，别忘了分享给身边的同事。</p>","neighbors":{"left":{"article_title":"14｜走进C语言：高级语言怎样抽象执行逻辑？","id":557209},"right":[]}}]