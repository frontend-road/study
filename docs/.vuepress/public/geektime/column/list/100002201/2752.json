{"id":2752,"title":"39 | 编程范式游记（10）- 逻辑编程范式","content":"<p>你好，我是陈皓，网名左耳朵耗子。</p><p>这节课重点介绍Prolog语言。Prolog（Programming in Logic）是一种逻辑编程语言，它创建在逻辑学的理论基础之上，最初被运用于自然语言等研究领域。现在它已被广泛地应用在人工智能的研究中，可以用来建造专家系统、自然语言理解、智能知识库等。</p><p>Prolog语言最早由艾克斯马赛大学（Aix-Marseille University）的Alain Colmerauer与Philippe Roussel等人于20世纪60年代末研究开发的。1972年被公认为是Prolog语言正式诞生的年份，自1972年以后，分支出多种Prolog的方言。</p><p>最主要的两种方言为Edinburgh和Aix-Marseille。最早的Prolog解释器由Roussel建造，而第一个Prolog编译器则是David Warren编写的。</p><p>Prolog一直在北美和欧洲被广泛使用。日本政府曾经为了建造智能计算机而用Prolog来开发ICOT第五代计算机系统。在早期的机器智能研究领域，Prolog曾经是主要的开发工具。</p><p>20世纪80年代Borland开发的Turbo Prolog，进一步普及了Prolog的使用。1995年确定了ISO Prolog标准。</p><!-- [[[read_end]]] --><p>有别于一般的函数式语言，Prolog的程序是基于谓词逻辑的理论。最基本的写法是定立对象与对象之间的关系，之后可以用询问目标的方式来查询各种对象之间的关系。系统会自动进行匹配及回溯，找出所询问的答案。</p><p>Prolog代码中以大写字母开头的元素是变量，字符串、数字或以小写字母开头的元素是常量，下划线（_）被称为匿名变量。</p><h1>Prolog的语言特征</h1><p>逻辑编程是靠推理，比如下面的示例：</p><pre><code>program mortal(X) :- philosopher(X).\n\nphilosopher(Socrates).\nphilosopher(Plato).\nphilosopher(Aristotle).\n\nmortal_report:-\nwrite('Known mortals are:'), nl, mortal(X),\nwrite(X),nl,\nfail.\n</code></pre><p>我们可以看到下面的几个步骤。</p><ol>\n<li>先定义一个规则：哲学家是人类。</li>\n<li>然后陈述事实：苏格拉底、亚里士多德、柏拉图都是哲学家。</li>\n<li>然后，我们问，谁是人类？于是就会输出苏格拉底、亚里士多德、柏拉图。</li>\n</ol><p>下面是逻辑编程范式的几个特征。</p><ul>\n<li>逻辑编程的要点是将正规的逻辑风格带入计算机程序设计之中。</li>\n<li>逻辑编程建立了描述一个问题里的世界的逻辑模型。</li>\n<li>逻辑编程的目标是对它的模型建立新的陈述。</li>\n<li>通过陈述事实——因果关系。</li>\n<li>程序自动推导出相关的逻辑。</li>\n</ul><h1>经典问题：地图着色问题</h1><p>我们再来看一个经典的四色地图问题。任何一个地图，相邻区域不能用相同颜色，只要用四种不同的颜色就够了。</p><p><img src=\"https://static001.geekbang.org/resource/image/db/cb/db670cfbe7497d71eba70d60d8aa0fcb.png?wh=935*484\" alt=\"\"></p><p>首先，定义四种颜色。</p><pre><code>color(red).\ncolor(green).\ncolor(blue).\ncolor(yellow).\n</code></pre><p>然后，定义一个规则：相邻的两个地区不能用相同的颜色。</p><pre><code>neighbor(StateAColor, StateBColor) :- color(StateAColor), color(StateBColor), \n    StateAColor \\= StateBColor. /* \\= is the not equal operator */\n</code></pre><p>最前面的两个条件：<code>color(StateAColor)</code> 和 <code>color(StateBColor)</code> 表明了两个变量 <code>StateAColor</code> 和 <code>StateBColor</code>。然后，第三个条件： <code>StateAColor \\= StateBColor</code> 表示颜色不能相同。</p><p>接下来的事就比较简单了。我们描述事实就好了，描述哪些区域是相邻的事实。</p><p>比如，下面描述了 BW 和 BY 是相邻的。</p><p><code>germany(BW, BY) :- neighbor(BW, BY).</code></p><p>下面则描述多个区 BW、 BY、 SL、 RP、 和 ND 的相邻关系：</p><p><code>germany(BW, BY, SL, RP, HE) :- neighbor(BW, BY), neighbor(BW, RP), neighbor(BW, HE).</code></p><p>于是，我们就可以描述整个德国地图的相邻关系了。</p><pre><code>germany(SH, MV, HH, HB, NI, ST, BE, BB, SN, NW, HE, TH, RP, SL, BW, BY) :- \nneighbor(SH, NI), neighbor(SH, HH), neighbor(SH, MV),\nneighbor(HH, NI),\nneighbor(MV, NI), neighbor(MV, BB),\nneighbor(NI, HB), neighbor(NI, BB), neighbor(NI, ST), neighbor(NI, TH),\nneighbor(NI, HE), neighbor(NI, NW),\nneighbor(ST, BB), neighbor(ST, SN), neighbor(ST, TH),\nneighbor(BB, BE), neighbor(BB, SN),\nneighbor(NW, HE), neighbor(NW, RP),\nneighbor(SN, TH), neighbor(SN, BY),\nneighbor(RP, SL), neighbor(RP, HE), neighbor(RP, BW),\nneighbor(HE, BW), neighbor(HE, TH), neighbor(HE, BY),\nneighbor(TH, BY),\nneighbor(BW, BY).\n</code></pre><p>最后，我们使用如下语句，就可以让Prolog推导到各个地区的颜色。</p><pre><code>?- germany(SH, MV, HH, HB, NI, ST, BE, BB, SN, NW, HE, TH, RP, SL, BW, BY).\n</code></pre><h1>小结</h1><p>Prolog这种逻辑编程，把业务逻辑或是说算法抽象成只关心规则、事实和问题的推导这样的标准方式，不需要关心程序控制，也不需要关心具体的实现算法。只需要给出可以用于推导的规则和相关的事实，问题就可以被通过逻辑推导来解决掉。是不是很有意思，也很好玩？</p><p>如果有兴趣，你可以学习一下，这里推荐两个学习资源：</p><ul>\n<li><a href=\"http://www.doc.gold.ac.uk/~mas02gw/prolog_tutorial/prologpages/\">Prolog Tutorial</a></li>\n<li><a href=\"http://www.learnprolognow.org\">Learn Prolog Now!</a></li>\n</ul><p>以下是《编程范式游记》系列文章的目录，方便你了解这一系列内容的全貌。</p><ul>\n<li><a href=\"https://time.geekbang.org/column/article/301\">01 | 编程范式游记：起源</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/303\">02 | 编程范式游记：泛型编程</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2017\">03 | 编程范式游记：类型系统和泛型的本质</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2711\">04 | 编程范式游记：函数式编程</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2723\">05 | 编程范式游记：修饰器模式</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2729\">06 | 编程范式游记：面向对象编程</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2741\">07 | 编程范式游记：基于原型的编程范式</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2748\">08 | 编程范式游记：Go 语言的委托模式</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2751\">09 | 编程范式游记：编程的本质</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2752\">10 | 编程范式游记：逻辑编程范式</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2754\">11 | 编程范式游记：程序世界里的编程范式</a></li>\n</ul>","comments":[{"had_liked":false,"id":13149,"user_name":"neohope","can_delete":false,"product_type":"c1","uid":1043475,"ip_address":"","ucode":"C0268F6E7E2B6E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","comment_is_top":false,"comment_ctime":1529406611,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"100313654419","product_id":100002201,"comment_content":"看《七周七语言》的时候，初步学习过Prolog，有个不错的入门英文教程：http:&#47;&#47;www.amzi.com&#47;，上面的例子还蛮有意思的。说实话Prolog对我来说，不像是在编程，而更像是在做线性规划：根据限制和初始条件，找到解。十分感兴趣这个推导过程Prolog是如何实现的。耗哥这方面有推荐的读物吗？感谢：）<br><br>个人感觉，在这个推导过程中，其实比起些现在这些通过统计学、神经网络及大数据喂出来的怪兽，比如NLP、google翻译、人工智能什么的，感觉这个逻辑简单，更适合入门一些。","like_count":24},{"had_liked":false,"id":3863,"user_name":"minghu6","can_delete":false,"product_type":"c1","uid":1050269,"ip_address":"","ucode":"F44058E21B14C9","user_header":"","comment_is_top":false,"comment_ctime":1520861221,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27290664997","product_id":100002201,"comment_content":"prolog确实在解决一些需要频繁回溯的问题上相当好用，是真正的描述规则，然后自动求解的人性化语言。","like_count":7},{"had_liked":false,"id":224598,"user_name":"一墨","can_delete":false,"product_type":"c1","uid":2009734,"ip_address":"","ucode":"2EFB72EEC69FE2","user_header":"","comment_is_top":false,"comment_ctime":1591456232,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18771325416","product_id":100002201,"comment_content":"难得看到这么短小的皓哥:) 也猜到回复肯定不会多, 因为理解到和用到的人少嘛:) 在此贡献一点点,作为皓粉的投名状. 之前做过一个项目, 里面用到基于C&#47;C++的iSAT库求解Boolean Satisfaction Problem. <br><br>iSAT的使用方法也是 (1) 先描述一些限制条件, 如文中所说到陈述事实; (2) 调用iSAT库进行求解, 该库内部使用BDD算法得到一个不违反限制条件的解或者没有解, (3) 根据iSAT返回的计算结果判断回到 (1)修改限制条件继续执行, 或是找到满意的计算结果停止计算. <br><br>除本文提到的着色问题以外,这一类问题其实有很多(参考NP问题), 我将其归纳为具有明确限制的启发式问题, 其最明显的特征是有规范的数学定义, 变量X离散且取值范围有限. 由于是离散的, 所以不能保证有最优解, 只有近似最优解. 至于实际应用嘛, 和算法的应用类似, 只要能把某一类问题简化为这一类问题的数学格式, 就可以套用这一类问题的通用解法, 也即是可以使用逻辑编程的范式, 不需要过多关注内部实现","like_count":4},{"had_liked":false,"id":106686,"user_name":"靠人品去赢","can_delete":false,"product_type":"c1","uid":1301286,"ip_address":"","ucode":"7A20F9EBE847E1","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/26/54f2c164.jpg","comment_is_top":false,"comment_ctime":1561372127,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18741241311","product_id":100002201,"comment_content":"你好，看完觉得Prolog这类语言，我只管业务，不管实现的。入门可能会简单，隐藏了许多技术细节，但实际上效率会不高，如果没有对应的活跃社区提供相关库的话。就害怕像“人人都是产品经理”，那样，弄了很多不知道技术边界的人导致各种各样的问题。","like_count":4},{"had_liked":false,"id":211523,"user_name":"Johnny","can_delete":false,"product_type":"c1","uid":1809156,"ip_address":"","ucode":"E3BD0D9ABF2710","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/p83UpvULG4E9MbCfmia1OcUEu67eTOdWjednKu3N2FuAqxUqtyI9JCxf2Wmic39vwrAx55iakEEzNhLWE28bOvHyw/132","comment_is_top":false,"comment_ctime":1587977830,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14472879718","product_id":100002201,"comment_content":"看完这节课，突然想重新学一下离散数学里的数理逻辑部分了。","like_count":3},{"had_liked":false,"id":107679,"user_name":"edisonhuang","can_delete":false,"product_type":"c1","uid":1530167,"ip_address":"","ucode":"BB2F639A779F96","user_header":"https://static001.geekbang.org/account/avatar/00/17/59/37/bd2de0a4.jpg","comment_is_top":false,"comment_ctime":1561596394,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14446498282","product_id":100002201,"comment_content":"逻辑编程很类似推理中的三段论，首先给出大前提，然后给出小前提，最后推导结论。<br>大前提哲学家都是人，小前提苏格拉底是哲学家，结论就是苏格拉底也是人<br>基于逻辑的编程让我们关注真正的事，忽略控制","like_count":3},{"had_liked":false,"id":183268,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1582984533,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10172919125","product_id":100002201,"comment_content":"还是这么好玩的语言，这是怎么玩到的？","like_count":2},{"had_liked":false,"id":355703,"user_name":"ZhengSJ","can_delete":false,"product_type":"c1","uid":1348924,"ip_address":"北京","ucode":"C5570B3960C68D","user_header":"https://static001.geekbang.org/account/avatar/00/14/95/3c/585e61cd.jpg","comment_is_top":false,"comment_ctime":1661670807,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661670807","product_id":100002201,"comment_content":"L. Suresh _et al._, “Building Scalable and Flexible Cluster Managers Using Declarative Programming,” 2020, pp. 827–844. Accessed: May 25, 2022. [Online]. Available: [https:&#47;&#47;www.usenix.org&#47;conference&#47;osdi20&#47;presentation&#47;suresh](https:&#47;&#47;www.usenix.org&#47;conference&#47;osdi20&#47;presentation&#47;suresh)<br><br>一篇文章，基于逻辑编程范式的调度系统设计，在思考这种方式是不是还可以应用到更多的领域。","like_count":0},{"had_liked":false,"id":345759,"user_name":"limix","can_delete":false,"product_type":"c1","uid":1166614,"ip_address":"","ucode":"76401FF54AE0D8","user_header":"https://static001.geekbang.org/account/avatar/00/11/cd/16/981cc4f8.jpg","comment_is_top":false,"comment_ctime":1652575145,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652575145","product_id":100002201,"comment_content":"这个很不错，之前看逻辑学，找到谓词逻辑的实用场景了，非常感谢","like_count":0},{"had_liked":false,"id":317159,"user_name":"seedjyh","can_delete":false,"product_type":"c1","uid":2309641,"ip_address":"","ucode":"D590E526A9A1D7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er4IPqj4H3jQHq4C1lgKh6ZroK3CVmGLiadic7S1rxbuy09JM9x8Aib6VkozPkO4lrUTHAhicX1z9Cg2w/132","comment_is_top":false,"comment_ctime":1634697719,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634697719","product_id":100002201,"comment_content":"这四色问题，prolog是打算用遍历穷举吗","like_count":0},{"had_liked":false,"id":251192,"user_name":"圆耳朵熊猫","can_delete":false,"product_type":"c1","uid":1186455,"ip_address":"","ucode":"CAD01CE7805894","user_header":"https://static001.geekbang.org/account/avatar/00/12/1a/97/a9399344.jpg","comment_is_top":false,"comment_ctime":1601396074,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601396074","product_id":100002201,"comment_content":"刷新认知了，居然还能这样玩","like_count":0}]}