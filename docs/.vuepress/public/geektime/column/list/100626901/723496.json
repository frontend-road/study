{"id":723496,"title":"09｜初识trait：协议约束与能力配置","content":"<p>你好，我是Mike。今天我们来一起学习trait。</p><p>trait 在Rust中非常重要。如果说所有权是Rust中的九阳神功（内功护体），那么类型系统（types + trait）就是Rust中的降龙十八掌，学好了便如摧枯拉朽般解决问题。另外一方面，如果把Rust比作一个AI人的话，那么所有权相当于Rust的心脏，类型 + trait相当于这个AI人的大脑。</p><p><img src=\"https://static001.geekbang.org/resource/image/c0/28/c05e31106c4f880f5ce29cdc8f1a8128.png?wh=1920x1349\" alt=\"图片\"></p><p>好了，我就不卖关子了。前面我们已经学习了所有权，现在我们来了解一下这个trait到底是什么。</p><p><span class=\"reference\">注：所有权是这门课程的主线，会一直贯穿到最后。</span></p><h2>trait是什么？</h2><p>trait用中文来讲就是特征，但是我倾向于不翻译。因为 trait 本身很简单，它就是一个标记（marker 或 tag）而已。比如 <code>trait TraitA {}</code> 就定义了一个trait，TraitA。</p><p>只不过这个标记被用在特定的地方，也就是类型参数的后面，用来限定（bound）这个类型参数可能的类型范围。所以trait往往是跟类型参数结合起来使用的。比如 <code>T: TraitA</code> 就是使用 TraitA 对类型参数T进行限制。</p><p>这么讲起来比较抽象，我们下面举例说明。</p><h3>trait是一种约束</h3><p>我们先回忆一下<a href=\"https://time.geekbang.org/column/article/722240\">第 7 讲</a>的一个例子。</p><pre><code class=\"language-plain\">struct Point&lt;T&gt; {\n&nbsp; &nbsp; x: T,\n&nbsp; &nbsp; y: T,\n}\n\nfn print&lt;T: std::fmt::Display&gt;(p: Point&lt;T&gt;) {\n&nbsp; &nbsp; println!(\"Point {}, {}\", p.x, p.y);\n}\n\nfn main() {\n&nbsp; &nbsp; let p = Point {x: 10, y: 20};\n&nbsp; &nbsp; print(p);\n\n&nbsp; &nbsp; let p = Point {x: 10.2, y: 20.4};\n&nbsp; &nbsp; print(p);\n}\n// 输出 \nPoint 10, 20\nPoint 10.2, 20.4\n</code></pre><!-- [[[read_end]]] --><p>注意代码里的第六行。</p><pre><code class=\"language-plain\">fn print&lt;T: std::fmt::Display&gt;(p: Point&lt;T&gt;) {\n</code></pre><p>这里的Display就是一个trait，用来对类型参数T进行约束。它表示<strong>必须要实现了Display的类型才能被代入类型参数 T</strong>，也就是限定了 T 可能的类型范围。<code>std::fmt::Display</code> 这个trait 主要是定义成配合格式化参数 <code>\"{}\"</code> 使用的，和它相对的还有 <code>std::fmt::Debug</code>，用来定义成配合格式化参数 <code>\"{:?}\"</code> 使用。而例子里的整数和浮点数，都默认实现了这个Display trait，因此整数和浮点数这两种类型能够代入函数 print() 的类型参数 T，从而执行打印的功能。</p><p>我们看一下如果一个类型没有实现Display，把它代入 print() 函数，会发生什么。</p><pre><code class=\"language-plain\">struct Point&lt;T&gt; {\n&nbsp; &nbsp; x: T,\n&nbsp; &nbsp; y: T,\n}\n\nstruct Foo;  // 新定义了一种类型\n\nfn print&lt;T: std::fmt::Display&gt;(p: Point&lt;T&gt;) {\n&nbsp; &nbsp; println!(\"Point {}, {}\", p.x, p.y);\n}\n\nfn main() {\n&nbsp; &nbsp; let p = Point {x: 10, y: 20};\n&nbsp; &nbsp; print(p);\n\n&nbsp; &nbsp; let p = Point {x: 10.2, y: 20.4};\n&nbsp; &nbsp; print(p);\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; let p = Point {x: Foo, y: Foo};  // 初始化一个Point&lt;T&gt; 实例\n&nbsp; &nbsp; print(p);\n}\n</code></pre><p>报编译错误：</p><pre><code class=\"language-plain\">error[E0277]: `Foo` doesn't implement `std::fmt::Display`\n&nbsp; --&gt; src/main.rs:20:11\n&nbsp; &nbsp;|\n20 |&nbsp; &nbsp; &nbsp;print(p);\n&nbsp; &nbsp;|&nbsp; &nbsp; &nbsp;----- ^ `Foo` cannot be formatted with the default formatter\n&nbsp; &nbsp;|&nbsp; &nbsp; &nbsp;|\n&nbsp; &nbsp;|&nbsp; &nbsp; &nbsp;required by a bound introduced by this call\n&nbsp; &nbsp;|\n&nbsp; &nbsp;= help: the trait `std::fmt::Display` is not implemented for `Foo`\n&nbsp; &nbsp;= note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n</code></pre><p>提示说，Foo 类型没有实现 Display，所以没办法编译通过。</p><p>回顾一下我们前面<a href=\"https://time.geekbang.org/column/article/722240\">第 7 讲</a>里说到的：类型是对变量值空间的约束。结合trait是对类型参数类型空间的约束。我们可以整理出一张图来表达它们之间的关系。</p><p><img src=\"https://static001.geekbang.org/resource/image/cc/5d/cc358e58c96f97bb7edf9c721cf3905d.jpg?wh=1920x1149\" alt=\"图片\"></p><p>首先，如果我们定义一个变量，这个时候还没有给它指定类型。那么这个时候这个变量的取值空间就是任意的。由于值空间太过宽泛，我们给它指定类型，比如u32或字符串，给这个变量的值空间添加了约束。并且指定了明确的类型后，<strong>这个变量的值空间就被限定为仅这一种类型的值空间</strong>。</p><p>对于简单的应用，到这一步也够了，但对抽象程度比较高的复杂应用，这种限定就显得太死了。所以又引入了类型参数（泛型）这个机制，用一个类型参数T就可以代表不同的类型。这样，以往为一些特定类型开发的函数等，就可以在不改变逻辑的情况下，扩展到支持多种类型，这样就灵活了很多。</p><p>但是，只有一个类型参数T，这个信息还不够，对同一个函数，可能只有少数一些类型适用，而符号 T 本身如果不加任何限制的话，它的内涵（类型空间）就太宽泛了，它可以取任意类型。所以光引入类型参数这个机制还不够，还得配套地引入一个对类型参数进行约束的机制。于是就出现了trait。结合图片，我们可以明白引入trait的原因和trait起的作用。</p><p>另一方面，从图片里其实也可以看出用Rust对问题建模的思维方式。当你在头脑中经过这样一个过程后，针对一个问题在Rust中就能建立起对应的模型来，整个过程非常自然。输入问题，输出模型！</p><p>语法上，<code>T: TraitA</code> 意思就是我们对类型参数T施加了TraitA这个约束标记。那么，我们怎么给某种具体的类型实现 TraitA，来让那个具体的类型可以代入T呢？具体来说，我们要对某个类型Atype实现某个trait的话，使用语法 <code>impl TraitA for Atype {}</code> 就可以做到。</p><p>只需要下面三行代码就可以。</p><pre><code class=\"language-plain\">trait TraitA {}\n\nstruct Atype;\n\nimpl TraitA for Atype {}\n</code></pre><p>这三行代码是可以通过编译的，是不是有点吃惊？</p><p>对于某个类型 T （这里指的是某种具体的类型）来说，如果它实现了这个TraitA，我们就说这个类型<strong>满足约束</strong>。</p><pre><code class=\"language-plain\">T: TraitA\n</code></pre><p>一个trait在一个类型上只能被实现一次。比如：</p><pre><code class=\"language-plain\">trait TraitA {}\n\nstruct Atype;\n\nimpl TraitA for Atype {}\nimpl TraitA for Atype {}\n// 输出，编译错误：\nerror[E0119]: conflicting implementations of trait `TraitA` for type `Atype`\n</code></pre><p>例子也很好理解，约束声明一次就够了，多次声明就冲突了，不知道哪一个生效。</p><h3>trait是一种能力配置</h3><p>如果trait仅仅是一个纯标记名称，而不包含内容的话，那它的作用是非常有限的。</p><pre><code class=\"language-plain\">trait TraitA {}\n</code></pre><p>下面我们会知道，这个{}里可以放入一些元素，这些元素属于这个trait。</p><p>我们先接着前面那个示例继续讲。</p><pre><code class=\"language-plain\">fn print&lt;T: std::fmt::Display&gt;(p: Point&lt;T&gt;) {\n</code></pre><p>Display对类型参数T作了约束，要求将来要代入的具体类型必须实现了Display这个trait。另一方面，也可以说成，Display给将来要代入到这个类型参数里的具体类型提供了一套“能力”，这套能力是在 Display 这个trait中定义和封装的。具体来说，就是能够打印的能力，因为确实有些值是没法打印出来的，比如原始二进制编码，打出来也是乱码。而Display就提供了打印的能力，同时还定义了具体的打印要求。</p><p><span class=\"reference\">注：Display是标准库提供的一种常用trait，我们会在第11讲专门讲解标准库里的各种常用trait。</span></p><p>也就是说，<strong>trait对类型参数实施约束的同时，也对具体的类型提供了能力</strong>。让我们看到类型参数后面的约束，就知道到时候代入这其中的类型会具有哪些能力。比如我们看到了 Display，就知道那些类型具有打印的能力。我们看到了 PartialEq，就知道那些类型具有比较大小的能力等等。</p><p>你也可以这样理解，在Rust中<strong>约束和能力就是一体两面，是同一个东西</strong>。这样下面的写法是不是就好理解多了？</p><pre><code class=\"language-plain\">T: TraitA + TraitB + TraitC + TraitD\n</code></pre><p>这个约束表达式，给某种类型T提供了从TraitA到TraitD这4套能力。我们后面还会看到，基于多trait组合的约束表达式，可以用这种方式提供优美的能力（权限）配置。</p><p>那么，一个trait里面具体可以有哪些东西呢？</p><h2>trait中包含什么？</h2><p>trait里面可以包含关联函数、关联类型和关联常量。</p><h3>关联函数</h3><p>在trait里可以定义关联函数。比如下面Sport这个trait就定义了四个关联函数。</p><pre><code class=\"language-plain\">trait Sport {\n  fn play(&amp;self);     // 注意这里直接以分号结尾，表示函数签名\n  fn play_mut(&amp;mut self);\n  fn play_own(self);\n  fn play_some() -&gt; Self;\n}\n</code></pre><p>例子里，前3个关联函数都带有Self参数（⚠️ 所有权三态又出现了），它们被实现到具体类型上的时候，就成为那个具体类型的方法。第4个方法，<code>play_some()</code> 函数里第一个参数不是Self类型，也就是说，它不是self、&amp;self、&amp;mut self中的一个，它被实现在具体类型上的时候，就是那个类型的关联函数。</p><p>可以看到，在trait中可以使用Rust语言里的标准类型Self，用来指代将要被实现这个trait的那个类型。使用 impl 语法将一个 trait 实现到目标类型上去。</p><p>你可以看一下示例。</p><pre><code class=\"language-plain\">struct Football;\n\nimpl Sport for Football {\n  fn play(&amp;self) {}    // 注意函数后面的花括号，表示实现\n  fn play_mut(&amp;mut self) {}\n  fn play_own(self) {}\n  fn play_some() -&gt; Self { Self }\n}\n</code></pre><p>这里这个Self，就指代 Football 这个类型。</p><p>trait中也可以定义关联函数的默认实现。</p><p>比如：</p><pre><code class=\"language-plain\">trait Sport {\n  fn play(&amp;self) {}    // 注意这里一对花括号，就是trait的关联函数的默认实现\n  fn play_mut(&amp;mut self) {}\n  fn play_own(self);   // 注意这里是以分号结尾，就表示没有默认实现\n  fn play_some() -&gt; Self;\n}\n</code></pre><p>在这个示例里，<code>play()</code> 和 <code>play_mut()</code> 后面定义了函数体，因此实际上提供了默认实现。</p><p>有了trait关联函数的默认实现后，具体类型在实现这个trait的时候，就可以“偷懒”，直接利用默认实现。比如：</p><pre><code class=\"language-plain\">struct Football;\n\nimpl Sport for Football {\n&nbsp; fn play_own(self) {}\n&nbsp; fn play_some() -&gt; Self { Self }\n}\n</code></pre><p>这个跟下面这个例子效果是一样的。</p><pre><code class=\"language-plain\">struct Football;\n\nimpl Sport for Football {\n  fn play(&amp;self) {}\n  fn play_mut(&amp;mut self) {}\n  fn play_own(self) {}\n  fn play_some() -&gt; Self { Self }\n}\n</code></pre><p>上面的代码相当于 Football 类型重新实现了一次 <code>play()</code> 和 <code>play_mut()</code> 函数，覆盖了trait的这两个函数的默认实现。</p><p>在类型上实现了trait后就可以使用这些方法了。</p><pre><code class=\"language-plain\">fn main () {\n&nbsp; let mut f = Football;\n&nbsp; f.play();      // 方法在实例上调用\n&nbsp; f.play_mut();\n  f.play_own();\n&nbsp; let _g = Football::play_some();    // 关联函数要在类型上调用\n  let _g = &lt;Football as Sport&gt;::play_some();  // 注意这样也是可以的\n}\n</code></pre><h3>关联类型</h3><p>在trait中，可以带一个或多个关联类型。关联类型起一种类型占位功能，定义trait时声明，在把trait实现到类型上的时候为其指定具体的类型。比如：</p><pre><code class=\"language-plain\">pub trait Sport {\n&nbsp; &nbsp; type SportType;\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; fn play(&amp;self,  st: Self::SportType);\n}\n\nstruct Football;\npub enum SportType {\n&nbsp; Land,\n&nbsp; Water,\n}\n\nimpl Sport for Football {\n&nbsp; type SportType = SportType;&nbsp; // 这里故意取相同的名字，不同的名字也是可以的\n&nbsp; fn play(&amp;self,  st: Self::SportType){}&nbsp; // 方法中用到了关联类型\n}\n\nfn main() {\n&nbsp; let f = Football;\n&nbsp; f.play(SportType::Land);\n}\n</code></pre><p>解释一下，我们在给Football类型实现Sport trait的时候，指明具体的关联类型SportType为一个枚举类型，用来区分陆地运动与水上运动。注意看trait中的play方法的第二个参数，它就是用的关联类型占位。</p><h4>在 T 上使用关联类型</h4><p>我们再来看一个示例，标准库中迭代器 Iterator trait的定义。</p><pre><code class=\"language-plain\">pub trait Iterator {\n    type Item;\n\n    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;\n}\n</code></pre><p>Iterator定义了一个关联类型Item。注意这里的 <code>Self::Item</code> 实际是 <code>&lt;Self as Iterator&gt;::Item</code> 的简写。一般来说，如果一个类型参数被TraitA约束，而TraitA里有关联类型 MyType，那么可以用 <code>T::Mytype</code> 这种形式来表示路由到这个关联类型。</p><p>比如：</p><pre><code class=\"language-plain\">trait TraitA {\n  type Mytype;\n}\n\nfn doit&lt;T: TraitA&gt;(a: T::Mytype) {}  // 这里在函数中使用了关联类型\n\nstruct TypeA;\nimpl TraitA for TypeA {\n  type Mytype = String;  // 具化关联类型为String\n}\n\nfn main() {\n  doit::&lt;TypeA&gt;(\"abc\".to_string());  // 给Rustc小助手喂信息：T具化为TypeA\n}\n</code></pre><p>上面示例在 <code>doit()</code> 函数中使用了TraitA中的关联类型，用的是 <code>T::Mytype</code> 这种路由/路径形式。在 <code>main()</code> 函数中调用 <code>doit()</code> 函数时，手动把类型参数T具化为TypeA。你可以多花一些时间熟悉一下这种表达形式。</p><h4>在约束中具化关联类型</h4><p>在指定约束的时候，可以把关联类型具化。你可以看一下我给出的示例。</p><pre><code class=\"language-plain\">trait TraitA {\n    type Item;\n}\nstruct Foo&lt;T: TraitA&lt;Item=String&gt;&gt; {  // 这里在约束表达式中对关联类型做了具化\n    x: T\n}\nstruct A;\nimpl TraitA for A {\n    type Item = String;\n}\n\nfn main() {\n    let a = Foo {\n        x: A,\n    };   \n}\n</code></pre><p>上面的代码在约束表达式中对关联类型做了具化，具化为 String 类型。</p><pre><code class=\"language-plain\">T: TraitA&lt;Item=String&gt;\n</code></pre><p>这样表达的意思就是限制必须实现了TraitA，而且它的关联类型必须是String才能代入这个T。假如我们稍微改一下，把类型A实现TraitA 时的关联类型Item具化为u32，就会编译报错，你可以试着编译一下看下提示。</p><pre><code class=\"language-plain\">trait TraitA {\n    type Item;\n}\nstruct Foo&lt;T: TraitA&lt;Item=String&gt;&gt; {\n    x: T\n}\nstruct A;\nimpl TraitA for A {\n    type Item = u32;  // 这里类型不匹配\n}\n\nfn main() {\n    let a = Foo {\n        x: A,  // 报错\n    };   \n}\n</code></pre><p>慢慢地我们给的示例有些烧脑了，现在你并不需要精通这些用法，<strong>第一步是要认识它们</strong>，当你看到别人写这种代码的时候，能基本看懂就可以了。</p><h4>对关联类型的约束</h4><p>在定义关联类型的时候，也可以给关联类型添加约束。意思是后面在具化这个类型的时候，那些类型必须要满足于这些约束，或者说实现过这些约束。你可以看我给出的这个例子。</p><pre><code class=\"language-plain\">use std::fmt::Debug;\n\ntrait TraitA {\n&nbsp; &nbsp; type Item: Debug;&nbsp; // 这里对关联类型添加了Debug约束\n}\n\n#[derive(Debug)]       // 这里在类型A上自动derive Debug约束\nstruct A;\n\nstruct B;\n\nimpl TraitA for B {\n&nbsp; type Item = A;&nbsp; // 这里这个类型A已满足Debug约束\n}\n</code></pre><p>在使用时甚至可以加强对关联类型的约束。比如：</p><pre><code class=\"language-plain\">use std::fmt::Debug;\n\ntrait TraitA {\n&nbsp; &nbsp; type Item: Debug;&nbsp; // 这里对关联类型添加了Debug约束\n}\n\n#[derive(Debug)]\nstruct A;\n\nstruct B;\n\nimpl TraitA for B {\n&nbsp; type Item = A;&nbsp; // 这里这个类型A已满足Debug约束\n}\n\nfn doit&lt;T&gt;()&nbsp;   // 定义类型参数T\nwhere\n&nbsp; &nbsp; T: TraitA,  // 使用where语句将T的约束表达放在后面来\n&nbsp; &nbsp; T::Item: Debug + PartialEq  // 注意这一句，直接对TraitA的关联类型Item添加了更多一个约束 PartialEq  \n{\n}\n</code></pre><p>请注意上面例子里的 <code>doit()</code> 函数。我们使用where语句把类型参数T的约束表达放在后面，同时使用 <code>T::Item: Debug + PartialEq</code> 来加强对 TraitA的关联类型Item 的约束，表示只有实现过 TraitA 且其关联类型 Item 的具化版必须满足 Debug 和 PartialEq 的约束。</p><p>这个例子稍微有点复杂，不过理解后，你会感觉到Rust trait的精髓。目前你可以把这个示例当作思维体操来练一练，没事了回来细品一下。另外，你可以自己修改这个例子，看看Rustc小助手会告诉你什么。</p><h3>关联常量</h3><p>同样的，trait里也可以携带一些常量信息，表示这个trait的一些内在信息（挂载在trait上的信息）。和关联类型不同的是，关联常量可以在trait定义的时候指定，也可以在给具体的类型实现的时候指定。</p><p>你可以看一下这个例子。</p><pre><code class=\"language-plain\">trait TraitA {\n    const LEN: u32 = 10;\n}\n\nstruct A;\nimpl TraitA for A {\n    const LEN: u32 = 12;\n}\n\nfn main() {\n    println!(\"{:?}\",A::LEN);\n    println!(\"{:?}\",&lt;A as TraitA&gt;::LEN);\n}\n//输出\n12\n12\n</code></pre><p>如果在impl的时候不指定，会有什么效果呢？你可以看看代码运行后的结果。</p><pre><code class=\"language-plain\">trait TraitA {\n    const LEN: u32 = 10;\n}\n\nstruct A;\nimpl TraitA for A {}\n\nfn main() {\n    println!(\"{:?}\",A::LEN);\n    println!(\"{:?}\",&lt;A as TraitA&gt;::LEN);\n}\n//输出\n10\n10\n</code></pre><h2>trait 作为一种协议</h2><p>我们已经看到，trait里有可选的关联函数、关联类型、关联常量这三项内容。一旦trait定义好，它就相当于一条法律或协议，在实现它的各个类型之间，在团队协作中不同的开发者之间，都必须按照它定义的规范实施。这是<strong>强制性</strong>的，而且这种强制性是由Rust编译器来执行的。也就是说，<strong>如果你不想按这套协议来实施，那么你注定无法编译通过。</strong></p><p>这个对于团队开发来说非常重要。它相当于在团队中协调的接口协议，强制不同成员之间达成一致。<strong>从这个意义上来讲，Rust非常适合团队开发</strong>。</p><h3>Where</h3><p>当类型参数后面有多个trait约束的时候，会显得“头重脚轻”，比较难看，所以Rust提供了Where语法来解决这个问题。Where关键字可用来把约束关系统一放在后面表示。</p><p>比如这个函数：</p><pre><code class=\"language-plain\">fn doit&lt;T: TraitA + TraitB + TraitC + TraitD + TraitE&gt;(t: T) -&gt; i32 {}\n</code></pre><p>这行代码可以写成下面这种形式。</p><pre><code class=\"language-plain\">fn doit&lt;T&gt;(t: T) -&gt; i32\nwhere \n    T: TraitA + TraitB + TraitC + TraitD + TraitE\n{}\n</code></pre><p>这样过多的trait约束就不至于太干扰函数签名的视觉完整性。</p><h3>约束依赖</h3><p>Rust还提供了一种语法表示约束间的依赖。</p><pre><code class=\"language-plain\">trait TraitA: TraitB {}\n</code></pre><p>初看起来，这跟C++等语言的类的继承有点像。实际不是，差异很大。<strong>这个语法的意思是如果某种类型要实现TraitA，那么它也要同时实现TraitB</strong>。反过来不成立。</p><p>例子：</p><pre><code class=\"language-plain\">trait Shape { fn area(&amp;self) -&gt; f64; }\ntrait Circle : Shape { fn radius(&amp;self) -&gt; f64; }\n</code></pre><p>上面这两行代码其实等价于下面这两行代码。</p><pre><code class=\"language-plain\">trait Shape { fn area(&amp;self) -&gt; f64; }\ntrait Circle where Self: Shape { fn radius(&amp;self) -&gt; f64; }\n</code></pre><p>你也可以看一下使用时的约束表示。</p><pre><code class=\"language-plain\">T: Circle \n实际上表示：\nT: Circle + Shape\n</code></pre><p>在这个约束依赖的限定下，如果你对一个类型实现了Circle trait，却没有实现Shape，那么Rust小助手会提示你这个类型不满足约束Shape。</p><p>比如下面代码：</p><pre><code class=\"language-plain\">trait Shape {}\ntrait Circle : Shape {}\nstruct A;\nstruct B;\nimpl Shape for A {}\nimpl Circle for A {}\nimpl Circle for B {}\n</code></pre><p>提示出错：</p><pre><code class=\"language-plain\">error[E0277]: the trait bound `B: Shape` is not satisfied\n --&gt; src/main.rs:7:17\n  |\n7 | impl Circle for B {}\n  |                 ^ the trait `Shape` is not implemented for `B`\n  |\n  = help: the trait `Shape` is implemented for `A`\nnote: required by a bound in `Circle`\n --&gt; src/main.rs:2:16\n  |\n2 | trait Circle : Shape {}\n  |                ^^^^^ required by this bound in `Circle`\n\n</code></pre><p>一个trait依赖多个trait也是可以的。</p><pre><code class=\"language-plain\">trait TraitA: TraitB + TraitC {}\n</code></pre><p>这个例子里面，<code>T: TraitA&nbsp;</code> 实际表 <code>T: TraitA + TraitB + TraitC</code>。因此可以少写不少代码。</p><p><strong>约束之间是完全平等的，理解这一点非常重要</strong>，通过刚刚的这些例子可以看到约束依赖是消除约束条件冗余的一种方式。</p><p>在约束依赖中，冒号后面的叫 supertrait，冒号前面的叫 subtrait。可以理解为subtrait在supertrait的约束之上，又多了一套新的约束。这些不同约束的地位是平等的。</p><h3>约束中同名方法的访问</h3><p>有的时候多个约束上会定义同名方法，像下面这样：</p><pre><code class=\"language-plain\">trait Shape {\n    fn play(&amp;self) {    // 定义了play()方法\n        println!(\"1\");\n    }\n}\ntrait Circle : Shape {\n    fn play(&amp;self) {    // 也定义了play()方法\n        println!(\"2\");\n    }\n}\nstruct A;\nimpl Shape for A {}\nimpl Circle for A {}\n\nimpl A {\n    fn play(&amp;self) {    // 又直接在A上实现了play()方法\n        println!(\"3\");\n    }\n}\n\nfn main() {\n  let a = A;\n  a.play();    // 调用类型A上实现的play()方法\n  &lt;A as Circle&gt;::play(&amp;a);  // 调用trait Circle上定义的play()方法\n  &lt;A as Shape&gt;::play(&amp;a);   // 调用trait Shape上定义的play()方法\n}\n//输出\n3\n2\n1\n</code></pre><p>上面示例展示了两个不同的trait定义同名方法，以及在类型自身上再定义同名方法，然后是如何精准地调用到不同的实现的。可以看到，在Rust中，同名方法没有被覆盖，能精准地路由过去。</p><p><code>&lt;A as Circle&gt;::play(&amp;a);</code> 这种语法，叫做<strong>完全限定语法</strong>，是调用类型上某一个方法的完整路径表达。如果impl和impl trait时有同名方法，用这个语法就可以明确区分出来。</p><h2>用trait实现能力配置</h2><h3>trait提供了寻找方法的范围</h3><p>Rust在一个实例上是怎么检查有没有某个方法的呢？</p><ol>\n<li>检查有没有直接在这个类型上实现这个方法。</li>\n<li>检查有没有在这个类型上实现某个trait，trait中有这个方法。</li>\n</ol><p>一个类型可能实现了多个trait，不同的trait中各有一套方法，这些不同的方法中可能还会出现同名方法。Rust在这里采用了一种惰性的机制，由开发者指定在当前的mod或scope中使用哪套或哪几套能力。因此，对应地需要开发者手动地将要用到的trait引入当前scope。</p><p>比如下面这个例子，我们定义两个隔离的模块，并在module_b里引入module_a中定义的类型A。</p><pre><code class=\"language-plain\">mod module_a {\n&nbsp; &nbsp; pub trait Shape {\n&nbsp; &nbsp; &nbsp; &nbsp; fn play(&amp;self) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; println!(\"1\");\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; pub struct A;\n&nbsp; &nbsp; impl Shape for A {}\n}\n\nmod module_b {\n&nbsp; &nbsp; use super::module_a::A;  // 这里只引入了另一个模块中的类型\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; fn doit() {\n&nbsp; &nbsp; &nbsp; &nbsp; let a = A;\n&nbsp; &nbsp; &nbsp; &nbsp; a.play();\n&nbsp; &nbsp; }\n}\n</code></pre><p>报错了，怎么办呢？</p><pre><code class=\"language-plain\">error[E0599]: no method named `play` found for struct `A` in the current scope\n  --&gt; src/lib.rs:17:11\n   |\n3  |         fn play(&amp;self) {\n   |            ---- the method is available for `A` here\n...\n8  |     pub struct A;\n   |     ------------ method `play` not found for this struct\n...\n17 |         a.play();\n   |           ^^^^ method not found in `A`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n13 +     use crate::module_a::Shape;\n</code></pre><p>引入trait就可以了。</p><pre><code class=\"language-plain\">mod module_a {\n&nbsp; &nbsp; pub trait Shape {\n&nbsp; &nbsp; &nbsp; &nbsp; fn play(&amp;self) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; println!(\"1\");\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; pub struct A;\n&nbsp; &nbsp; impl Shape for A {}\n}\n\nmod module_b {\n&nbsp; &nbsp; use super::module_a::Shape;  // 引入这个trait\n&nbsp; &nbsp; use super::module_a::A;\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; fn doit() {\n&nbsp; &nbsp; &nbsp; &nbsp; let a = A;\n&nbsp; &nbsp; &nbsp; &nbsp; a.play();\n&nbsp; &nbsp; }\n}\n</code></pre><p>也就是说，在当前mod不引入对应的trait，你就得不到相应的能力。因此 <strong>Rust 的trait需要引入当前scope才能使用的方式可以看作是能力配置（Capability Configuration）机制。</strong></p><h3>约束可按需配置</h3><p>有了trait这种能力配置机制，我们可以在需要的地方按需加载能力。需要什么能力就引入什么能力（提供对应的约束）。不需要一次性限制过死，比如下面的示例就演示了几种约束组合的可能性。</p><pre><code class=\"language-plain\">trait TraitA {}\ntrait TraitB {}\ntrait TraitC {}\n\nstruct A;\nstruct B;\nstruct C;\n\nimpl TraitA for A {}\nimpl TraitB for A {}\nimpl TraitC for A {}  // 对类型A实现了TraitA, TraitB, TraitC\nimpl TraitB for B {}\nimpl TraitC for B {}  // 对类型B实现了TraitB, TraitC\nimpl TraitC for C {}  // 对类型C实现了TraitC\n\n// 7个版本的doit() 函数\nfn doit1&lt;T: TraitA + TraitB + TraitC&gt;(t: T) {}\nfn doit2&lt;T: TraitA + TraitB&gt;(t: T) {}\nfn doit3&lt;T: TraitA + TraitC&gt;(t: T) {}\nfn doit4&lt;T: TraitB + TraitC&gt;(t: T) {}\nfn doit5&lt;T: TraitA&gt;(t: T) {}\nfn doit6&lt;T: TraitB&gt;(t: T) {}\nfn doit7&lt;T: TraitC&gt;(t: T) {}\n\nfn main() {\n    doit1(A);\n    doit2(A);\n    doit3(A);\n    doit4(A);\n    doit5(A);\n    doit6(A);\n    doit7(A);  // A的实例能用在所有7个函数版本中\n\n    doit4(B);\n    doit6(B);\n    doit7(B);  // B的实例只能用在3个函数版本中\n    \n    doit7(C);  // C的实例只能用在1个函数版本中\n}\n</code></pre><p>示例里，A的实例能用在全部的（7个）函数版本中，B的实例只能用在3个函数版本中，C的实例只能用在1个函数版本中。</p><p>我们再来看一个示例，这个示例演示了如何对带类型参数的结构体在实现方法的时候，按需求施加约束。</p><pre><code class=\"language-plain\">use std::fmt::Display;\n\nstruct Pair&lt;T&gt; {\n    x: T,\n    y: T,\n}\n\nimpl&lt;T&gt; Pair&lt;T&gt; {    // 第一次 impl \n    fn new(x: T, y: T) -&gt; Self {\n        Self { x, y }\n    }\n}\n\nimpl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {  // 第二次 impl \n    fn cmp_display(&amp;self) {\n        if self.x &gt;= self.y {\n            println!(\"The largest member is x = {}\", self.x);\n        } else {\n            println!(\"The largest member is y = {}\", self.y);\n        }\n    }\n}\n</code></pre><p>这个示例中，我们对类型 <code>Pair&lt;T&gt;</code> 做了两次impl。可以看到，第二次impl时，添加了约束 <code>T: Display + PartialOrd</code>。</p><p>因为我们cmd_display方法需要用到打印能力和元素比大小排序的能力，所以对类型参数T施加了 Display 和 PartialOrd两种约束（两种能力）。而对于new函数来说，它不需要这些能力，因此impl的时候就可以不施加这些约束。我们前面讲过，Rust中对类型是可以多次impl的。</p><h2>关于trait，你还要了解什么？</h2><h3>孤儿规则</h3><p>为了不导致混乱，Rust要求在一个模块中，如果要对一个类型实现某个trait，这个类型和这个trait其中必须有一个是在当前模块中定义的。比如下面这两种情况都是可以的。</p><p>情况1：</p><pre><code class=\"language-plain\">use std::fmt::Display;\n\nstruct A;\nimpl Display for A {}\n</code></pre><p>情况2：</p><pre><code class=\"language-plain\">trait TraitA {}\nimpl TraitA for u32 {}\n</code></pre><p>但是下面这样不可以，会编译报错。</p><pre><code class=\"language-plain\">use std::fmt::Display;\n\nimpl Display for u32 {}\n</code></pre><pre><code class=\"language-plain\">error[E0117]: only traits defined in the current crate can be implemented for primitive types\n --&gt; src/lib.rs:3:1\n  |\n3 | impl Display for u32 {}\n  | ^^^^^^^^^^^^^^^^^---\n  | |                |\n  | |                `u32` is not defined in the current crate\n  | impl doesn't use only types from inside the current crate\n  |\n  = note: define and implement a trait or new type instead\n</code></pre><p>因为我们想给一个外部类型实现一个外部trait，这是不允许的。Rustc小助手提示我们，如果实在想用的话，可以用Newtype模式。</p><p>比如像下面这样：</p><pre><code class=\"language-plain\">use std::fmt::Display;\n\nstruct MyU32(u32);    // 用 MyU32 代替 u32\n\nimpl Display for MyU32 {\n  // 请实现完整\n}\n\nimpl MyU32 {\n    fn get(&amp;self) -&gt; u32 {  // 需要定义一个获取真实数据的方法\n        self.0\n    }\n}\n</code></pre><h3>Blanket Implementation</h3><p>Blanket Implementation又叫做统一实现。</p><p>方式如下：</p><pre><code class=\"language-plain\">trait TraitA {}\ntrait TraitB {}\n\nimpl&lt;T: TraitB&gt; TraitA for T {}  // 这里直接对T进行实现TraitA\n</code></pre><p>统一实现后，就不要对某个具体的类型再实现一次了。因为同一个trait只能实现一次到某个类型上。这个不像是对类型做 impl，可以实现多次（函数名要不冲突）。</p><p>比如：</p><pre><code class=\"language-plain\">trait TraitA {}\ntrait TraitB {}\n\nimpl&lt;T: TraitB&gt; TraitA for T {}\n\nimpl TraitB for u32 {}\nimpl TraitA for u32 {}\n</code></pre><p>这样就会报错。</p><pre><code class=\"language-plain\">error[E0119]: conflicting implementations of trait `TraitA` for type `u32`\n  --&gt; src/lib.rs:10:1\n   |\n6  | impl&lt;T: TraitB&gt; TraitA for T {}\n   | ---------------------------- first implementation here\n...\n10 | impl TraitA for u32 {}\n   | ^^^^^^^^^^^^^^^^^^^ conflicting implementation for `u32`\n\n</code></pre><p>我们修改一下，这样就不会报错了。</p><pre><code class=\"language-plain\">trait TraitA {}\ntrait TraitB {}\n\nimpl&lt;T: TraitB&gt; TraitA for T {}\n\nimpl TraitA for u32 {}\n</code></pre><p>因为u32并没有被TraitB约束，所以它不满足第4行的blanket implementation。因此就不算重复实现。</p><h2>小结</h2><p>认真学完了这节课的内容之后，你有没有被震撼到？这完全就是一种全新的思维体系，和之前我们熟悉的OOP等方式完全不同了。Rust中trait的概念本身非常简单，但用法又极其灵活。</p><p>trait的引入是为了对泛型的类型空间进行约束，进入约束的同时也就提供了能力，约束与能力是一体两面。trait中可以包含关联函数、关联类型和关联常量。其中关联类型的理解难度较大，但是其模式也就那么固定的几种，多花点时间熟悉一般不会有问题。</p><p>trait定义好后，可以作为代码与代码之间、代码与开发者之间、开发者与开发者之间的强制性法律协议而存在，而这个法律的仲裁者就是Rustc编译器。</p><p>可以说，<strong>Rust是一门面向约束编程的语言</strong>。面向约束是Rust中非常独特的设计，也是Rust的灵魂。简单地把trait当作其他语言中的class或interface去理解使用，是非常有害的。</p><p><img src=\"https://static001.geekbang.org/resource/image/5f/94/5f57eb3a7ebaa3d1cc6196ee01137c94.jpg?wh=1961x1669\" alt=\"\"></p><h2>思考题</h2><p>如果你学习或者了解过Java、C++等面向对象语言的话，可以聊一聊trait的依赖和OOP继承的区别在哪里。</p><p>欢迎你把思考后的结果分享到评论区，也欢迎你把这节课的内容分享给对Rust感兴趣的朋友，我们下节课再见！</p>","neighbors":{"left":{"article_title":"08｜Option<T>与Result<T, E>、迭代器","id":722702},"right":{"article_title":"10｜再探trait：带类型参数的trait及trait object","id":724776}},"comments":[{"had_liked":false,"id":383712,"user_name":"Mike Tang","can_delete":false,"product_type":"c1","uid":2186062,"ip_address":"重庆","ucode":"55775BCEDB5937","user_header":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","comment_is_top":true,"comment_ctime":1699506705,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"神说，众生平等。Rust说，众trait平等。","like_count":10,"discussions":[{"author":{"id":1195144,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3c/88/6bef27d6.jpg","nickname":"大神博士","note":"","ucode":"8C4318095949F0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632485,"discussion_content":"同学你好 😁","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1700822671,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383682,"user_name":"下雨天","can_delete":false,"product_type":"c1","uid":1008315,"ip_address":"湖北","ucode":"816B3792ECC50A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/62/bb/323a3133.jpg","comment_is_top":false,"comment_ctime":1699443037,"is_pvip":false,"replies":[{"id":139935,"content":"太形象了，10000个赞","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1699505346,"ip_address":"重庆","comment_id":383682,"utype":1}],"discussion_count":5,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"trait 的依赖：小明要听从数学老师，语文老师，英语老师的话。老师之间是平等关系，多个依赖平等，最小依赖选择自己喜欢滴功能。\nOOP 继承：小明要听他爸，他爷爷，他曾祖父的话。继承之间存在父子关系，继承过来一堆破属性和方法，也许根本不是自己想要滴，还要负重前行。","like_count":30,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631402,"discussion_content":"太形象了，10000个赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699505346,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3791900,"avatar":"","nickname":"Geek_2bd44f","note":"","ucode":"6BD3312C2AAC69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632962,"discussion_content":"是的，写了6年java的我，深深的感受到继承很多时候不是最优解，组合才是大部分情况的最优解。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1701680274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2911084,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/6b/6c/3e80afaf.jpg","nickname":"HappyHasson","note":"","ucode":"B84CC43E349CFA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":648546,"discussion_content":"说的很形象。 点赞。\n个人觉得这里隐藏了一个问题，继承了一堆破烂熟悉，其实是父对象分离的不好，如果模块化的很好，做起来和rust的差不多舒服。但是，rust的优势是语言层面就把设计做完了，其他语言如java、c++的继承却很考验coder的设计能力。也给rust点赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1721785550,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1115149,"avatar":"https://static001.geekbang.org/account/avatar/00/11/04/0d/3dc5683a.jpg","nickname":"柯察金","note":"","ucode":"F722BF8FCD2C47","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645737,"discussion_content":"你生命中只有老师，没有亲人吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1716613963,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"美国","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1672482,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqrbHib1v0wPRVHxrFK2CPQQX8Wg3rRMPiaZ5teMKu5klT48yns6yo4krZsIqHskwdEsibVvQ3QB7CUQ/132","nickname":"Geek_6fjt20","note":"","ucode":"B7EB9B061E2C06","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631422,"discussion_content":"不想继承的可以扔掉，但有些东西是遗传，想扔都扔不掉。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699517009,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386110,"user_name":"weineel","can_delete":false,"product_type":"c1","uid":1049741,"ip_address":"江苏","ucode":"6DC6EF4F256A53","user_header":"https://static001.geekbang.org/account/avatar/00/10/04/8d/005c2ff3.jpg","comment_is_top":false,"comment_ctime":1704114809,"is_pvip":true,"replies":[{"id":140729,"content":"对的对的.","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1704170925,"ip_address":"重庆","comment_id":386110,"utype":1}],"discussion_count":1,"race_medal":1,"score":2,"product_id":100626901,"comment_content":"在语法层面实践了组合优于继承。","like_count":6,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634878,"discussion_content":"对的对的.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704170925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":389389,"user_name":"独钓寒江","can_delete":false,"product_type":"c1","uid":1203049,"ip_address":"广东","ucode":"2C81906FD88C8C","user_header":"https://static001.geekbang.org/account/avatar/00/12/5b/69/7ace1ddb.jpg","comment_is_top":false,"comment_ctime":1712390208,"is_pvip":false,"replies":[{"id":141738,"content":"对的。是这样的。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1713027612,"ip_address":"加拿大","comment_id":389389,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"看到supertrait 和 subtrait， Shape 和 Circle 的时候， 的确联想到继承了，不过作者强调平等，那就打消了这个念头","like_count":2,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":641817,"discussion_content":"对的。是这样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1713027612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"加拿大","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383665,"user_name":"cluski","can_delete":false,"product_type":"c1","uid":2760117,"ip_address":"江苏","ucode":"F161EAE54DC801","user_header":"https://static001.geekbang.org/account/avatar/00/2a/1d/b5/d843bef9.jpg","comment_is_top":false,"comment_ctime":1699425753,"is_pvip":false,"replies":[{"id":139939,"content":"对的。rust的trait将模型从oop的等级森严的牢房里面解救出来了","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1699505508,"ip_address":"重庆","comment_id":383665,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"个人理解，trait很像Java中的interface。Java的interface可以作为某种能力的抽象，并且在泛型的使用中，可以起到限制的作用。\nJava、C++等OOP语言中的继承个人感觉更多是在强调is-a这个概念。例如，男人是一个人，鸽子是一个鸟这类。与Rust的trait更加强调的一种能力和约束。","like_count":2,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631406,"discussion_content":"对的。rust的trait将模型从oop的等级森严的牢房里面解救出来了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699505508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385445,"user_name":"superggn","can_delete":false,"product_type":"c1","uid":3623568,"ip_address":"北京","ucode":"831CCD98B393FE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/7Q403U68Oy4lXG5sFBPVKLrfwaRzBqpBZibpEBXcPf9UOO3qrnh7RELoByTLzBZLkN9Nukfsj7DibynbZjKAKgag/132","comment_is_top":false,"comment_ctime":1702628693,"is_pvip":false,"replies":[{"id":140470,"content":"非常🎉棒","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1702701783,"ip_address":"重庆","comment_id":385445,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"笔记\n\n一般我们说关联类型 &#47; associated types 的时候， 说的是 trait 底下的 type\n\n关联类型就是跟着 trait 走的泛型\n\n至于啥时候关联类型要具化 &#47; 单态化 &#47; 具体写明白是啥？\n\n得在 impl trait for typeA 的时候写清楚\n\n\n\n一般说 A 有 trait bound， 意思就是这个 A 必须实现某个 trait\n\n我们不仅可以搞 trait bound, 有 trait bound 之后在 where clause 里还可以搞 trait type bound：\n\n`T: trait A, T::typeB: Debug + PartialEq`\n\n\n\n为啥调用 trait 方法还需要 use trait?\n\n因为 rust 不会大海捞针遍历所有 trait 找方法， 你得先指定在哪儿找\n\n","like_count":1,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633873,"discussion_content":"非常🎉棒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702701783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384065,"user_name":"$侯","can_delete":false,"product_type":"c1","uid":1019939,"ip_address":"浙江","ucode":"488B1BD3924E7E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/90/23/5c74e9b7.jpg","comment_is_top":false,"comment_ctime":1700208919,"is_pvip":false,"replies":[{"id":140111,"content":"他提示了，用 Self::SportType，完整路径。我发现我那个例子也漏了，我加上。","user_name":"作者回复","user_name_real":"作者","uid":2186062,"ctime":1700215918,"ip_address":"重庆","comment_id":384065,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"既然关联类型作为占位符，那为什么这样会报错呢，按我理解理占位符应该不需要事先声明\npub trait Sport {\n    type SportType;\n\n    fn play(&amp;self, st: SportType);\n}\n\nfn main() {}\n\n\nerror[E0412]: cannot find type `SportType` in this scope\n --&gt; src\\main.rs:4:24\n  |\n4 |     fn play(&amp;self, st: SportType);\n  |                        ^^^^^^^^^ help: you might have meant to use the associated type: `Self::SportType`\n","like_count":1,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631972,"discussion_content":"他提示了，用 Self::SportType，完整路径。我发现我那个例子也漏了，我加上。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700215918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383674,"user_name":"duwoodly","can_delete":false,"product_type":"c1","uid":2020398,"ip_address":"重庆","ucode":"12F7BFCB78DB0E","user_header":"https://static001.geekbang.org/account/avatar/00/1e/d4/2e/d478a412.jpg","comment_is_top":false,"comment_ctime":1699435634,"is_pvip":false,"replies":[{"id":139938,"content":"对的","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1699505437,"ip_address":"重庆","comment_id":383674,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"CPP的继承，子类会继承父类的属性和方法，子类可以重写父类的方法。 继承引起的耦合性很强。 所以新产生的语言都不再支持继承，像go和rust使用组合，降低了耦合性。\nRust 的trait 是一种约束，也是一种能力，避免了继承的强耦合，又提供了灵活性。","like_count":1,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631405,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699505437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":389131,"user_name":"王晓宇","can_delete":false,"product_type":"c1","uid":1479349,"ip_address":"上海","ucode":"BF57001A305A49","user_header":"https://static001.geekbang.org/account/avatar/00/16/92/b5/98062fbf.jpg","comment_is_top":false,"comment_ctime":1711637646,"is_pvip":false,"replies":[{"id":141742,"content":"我在playground里面试可以的。https:&#47;&#47;play.rust-lang.org&#47;?version=stable&amp;mode=debug&amp;edition=2021 。你是在哪里试的呀。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1713028212,"ip_address":"加拿大","comment_id":389131,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"老师，在T上使用关联类型那个示例编译不通过\ntrait TraitA {\n  type Mytype;\n}\n\nfn doit&lt;T: TraitA&gt;(a: T::Mytype) {}  &#47;&#47; 这里在函数中使用了关联类型\n\nstruct TypeA;\nimpl TraitA for TypeA {\n  type Mytype = String;  &#47;&#47; 具化关联类型为String\n}\n\nfn main() {\n  doit::&lt;TypeA&gt;(&quot;abc&quot;.to_string());  &#47;&#47; 给Rustc小助手喂信息：T具化为TypeA\n}","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":641823,"discussion_content":"我在playground里面试可以的。https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021 。你是在哪里试的呀。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1713028213,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"加拿大","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":388255,"user_name":"啊良梓是我","can_delete":false,"product_type":"c1","uid":1655117,"ip_address":"广东","ucode":"E42FC1A60D331C","user_header":"https://static001.geekbang.org/account/avatar/00/19/41/4d/f6d6d13a.jpg","comment_is_top":false,"comment_ctime":1709721893,"is_pvip":false,"replies":[{"id":141474,"content":"后面实战篇就是几个入门的项目","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1710434399,"ip_address":"加拿大","comment_id":388255,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"有没有入门项目来练练手，\n看完就忘了，不上手的话","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":639285,"discussion_content":"后面实战篇就是几个入门的项目","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1710434399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"加拿大","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386938,"user_name":"飞了的鸭子被煮了","can_delete":false,"product_type":"c1","uid":3813080,"ip_address":"湖南","ucode":"5781D69934D956","user_header":"https://static001.geekbang.org/account/avatar/00/3a/2e/d8/7beb49a4.jpg","comment_is_top":false,"comment_ctime":1705937869,"is_pvip":false,"replies":[{"id":141078,"content":"👍👍","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1705983348,"ip_address":"重庆","comment_id":386938,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"trait 不需要考虑层级关系，感觉类型的约束更加原子化了，被消费时不需要考虑那么多的耦合。","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636352,"discussion_content":"👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705983348,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385939,"user_name":"千回百转无劫山","can_delete":false,"product_type":"c1","uid":1456256,"ip_address":"北京","ucode":"2C249889C00929","user_header":"","comment_is_top":false,"comment_ctime":1703692099,"is_pvip":true,"replies":[{"id":140657,"content":"rust不给开发者设置天花板","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1703770631,"ip_address":"重庆","comment_id":385939,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"从python过来的，只能说打开了新世界的大门","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634657,"discussion_content":"rust不给开发者设置天花板","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1703770631,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385446,"user_name":"superggn","can_delete":false,"product_type":"c1","uid":3623568,"ip_address":"北京","ucode":"831CCD98B393FE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/7Q403U68Oy4lXG5sFBPVKLrfwaRzBqpBZibpEBXcPf9UOO3qrnh7RELoByTLzBZLkN9Nukfsj7DibynbZjKAKgag/132","comment_is_top":false,"comment_ctime":1702629307,"is_pvip":false,"replies":[{"id":140472,"content":"最好不要通过继承那个思维来理解，对的，先刷完一遍再回头来看。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1702702038,"ip_address":"重庆","comment_id":385446,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"思考题（我从 python 来的， cpp 和 java 没学过）\n\nOOP\n\nclass 里有各种方法， 搞个子类就可以对基类进行各种修改\n\n定义个 class, class 里有各种方法（包括 static method 啥的）\n\n大部分情况是一个树形结构\n\n\n\n面向 trait bound 编程\n\ntrait 类似于 OOP 里搞一个标准基类， 然后来回继承， 不同点在于更灵活\n\n或者类似于 python3 里的 mixin（这玩意我没怎么玩过， 不熟， 但看过同事写的代码）， 搞个 must implement 的 abstract method 感觉也差不多\n\n引用来引用去， 飞来飞去~\n\n\n\n这种思考题没啥感觉， 反正我也不会写， 随便叨叨， 等全都刷一遍之后可能会有别的感想","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633875,"discussion_content":"最好不要通过继承那个思维来理解，对的，先刷完一遍再回头来看。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1702702038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385438,"user_name":"superggn","can_delete":false,"product_type":"c1","uid":3623568,"ip_address":"北京","ucode":"831CCD98B393FE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/7Q403U68Oy4lXG5sFBPVKLrfwaRzBqpBZibpEBXcPf9UOO3qrnh7RELoByTLzBZLkN9Nukfsj7DibynbZjKAKgag/132","comment_is_top":false,"comment_ctime":1702624995,"is_pvip":false,"replies":[{"id":140473,"content":"我是根据rust reference的说法来的，其实意思都差不多，这个局部可以互换理解。两种说法都是对的","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1702702140,"ip_address":"重庆","comment_id":385438,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"我记得 trait 底下定义的函数里， 有 self 参数的叫方法（method, called on instance）， 没 self 参数的才叫 关联函数（associated function, called on type)?\n=================\n刚才查了下， duckduckgo 搜出来的 rust associated function 跟我记得一样， 区分 method 和 associated function， 但 Rust By Practice (RBP) 和 Rust By Example (RBE) 说的不一样...\n\nRBP\nhttps:&#47;&#47;practice.rs&#47;method.html\n=&gt; &quot;All functions defined within an impl block are called associated functions because they’re associated with the type named after the impl.&quot; 所有在 impl 底下的函数都能叫做 associated functions\n\nRBE\nhttps:&#47;&#47;doc.rust-lang.org&#47;rust-by-example&#47;fn&#47;methods.html\n=&gt; &quot;Some functions are connected to a particular type. These come in two forms: associated functions, and methods.&quot;\n","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633876,"discussion_content":"我是根据rust reference的说法来的，其实意思都差不多，这个局部可以互换理解。两种说法都是对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702702140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":1,"child_discussions":[{"author":{"id":3623568,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/7Q403U68Oy4lXG5sFBPVKLrfwaRzBqpBZibpEBXcPf9UOO3qrnh7RELoByTLzBZLkN9Nukfsj7DibynbZjKAKgag/132","nickname":"superggn","note":"","ucode":"831CCD98B393FE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":633879,"discussion_content":"感谢猛男","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702709532,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":633876,"ip_address":"北京","group_id":0},"score":633879,"extra":""}]}]},{"had_liked":false,"id":384643,"user_name":"plh","can_delete":false,"product_type":"c1","uid":1031828,"ip_address":"四川","ucode":"D79F2B87AC3AD2","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erEHTaQDkWqEYib9iabib8rACYpSFBHTPFmgicUKaib79MB6VIxNwiajHUS8kYFEKCGOjpibf0dibhIjqhfzg/132","comment_is_top":false,"comment_ctime":1701268169,"is_pvip":false,"replies":[{"id":140295,"content":"二三是对类型的引用类型进行实现，不是类型本身。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1701352230,"ip_address":"重庆","comment_id":384643,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"老师你好: 原文 [因为同一个 trait 只能实现一次到某个类型上。]  这个 &quot;某个类型&quot; 怎么理解? \n比如: 标准库上有 Option 上面 就有这么3个方法: 感觉这个有点迷惑?  \n\nimpl&lt;T&gt; IntoIterator for Option&lt;T&gt;\nimpl&lt;&#39;a, T&gt; IntoIterator for &amp;&#39;a Option&lt;T&gt;\nimpl&lt;&#39;a, T&gt; IntoIterator for &amp;&#39;a mut Option&lt;T&gt;\n\n\n\n\n","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632801,"discussion_content":"二三是对类型的引用类型进行实现，不是类型本身。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1701352230,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384422,"user_name":"javpower","can_delete":false,"product_type":"c1","uid":1362777,"ip_address":"江西","ucode":"92867F35D11590","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJ4reATXtqhQ26vWXhiaZUEF9W1E0ZEqibrxxzR7NrlGwjrCZeLvF2HnL8jFjGXaFtN1vBTSia6492g/132","comment_is_top":false,"comment_ctime":1700830220,"is_pvip":false,"replies":[{"id":140254,"content":"可以借助那个来理解，但是注意不能等同。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700888983,"ip_address":"重庆","comment_id":384422,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"trait 类似Java中的接口\n范型约束类似Java中的&lt;? extends 接口&gt;","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632505,"discussion_content":"可以借助那个来理解，但是注意不能等同。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700888983,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384411,"user_name":"unistart","can_delete":false,"product_type":"c1","uid":1524770,"ip_address":"湖南","ucode":"C51E5D242530D2","user_header":"https://static001.geekbang.org/account/avatar/00/17/44/22/403a340a.jpg","comment_is_top":false,"comment_ctime":1700818413,"is_pvip":false,"replies":[{"id":140248,"content":"1. 我检查了一下，没说错呀。修改后的代码，因为 u32 实现了 TraitA，而没有实现TraitB，因此u32没有被TraitB约束，是这个意思。\n\n2. 你注释掉 impl TraitA for u32 当然不会报错，因为逻辑跟上面那个 blanket implementation 无关了，你可以仔细体会一下。\n\n3. 对的，你的第三条的理解非常正确。👍","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700837335,"ip_address":"重庆","comment_id":384411,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"最后的Blanket Implementation那部分有点没看明白，有大佬能指点一下么\n\n问题一：文稿上修改后的代码和之后解释说明貌似对不上，文稿中说`因为 u32 并没有被 TraitB 约束，所以它不满足第 4 行的 blanket implementation。因此就不算重复实现`。但是修改后的代码中是保留的impl TraitA for u32 {}而不是impl TraitB for u32 {}。\n\n问题二：我将有问题的代码复制到rus playground中并尝试修改，发现注释掉问题代码中的impl TraitA for u32 {}或者impl TraitB for u32 {}貌似都不会报错，没明白这是什么意思。\n\n问题三：关于impl&lt;T: TraitB&gt; TraitA for T {}这句代码的理解，是不是为T类型实现TraitA，同时对T类型做了trait约束为TraitB，之后如果T类型实现了TraitB，那么自然就有了TraitA的能力\n\ntrait TraitA {\n    fn test(&amp;self) {\n        println!(&quot;TraitA::test&quot;)\n    }\n}\n\ntrait TraitB {\n    fn some(&amp;self) {\n        println!(&quot;TraitB::some&quot;)\n    }\n}\n\nimpl&lt;T: TraitB&gt; TraitA for T {}\n\nimpl TraitB for u32 {}\n&#47;&#47; impl TraitA for u32 {}\n\nimpl TraitB for f32 {}\n\nfn main() {\n    1u32.test(); &#47;&#47; 输出 TraitA::test\n    1u32.some(); &#47;&#47; 输出 TraitB::some\n    \n    1.0f32.test(); &#47;&#47; 输出：TraitA::test\n    1.0f32.some(); &#47;&#47; 输出：TraitB::some\n}\n\n\n","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632490,"discussion_content":"1. 我检查了一下，没说错呀。修改后的代码，因为 u32 实现了 TraitA，而没有实现TraitB，因此u32没有被TraitB约束，是这个意思。\n\n2. 你注释掉 impl TraitA for u32 当然不会报错，因为逻辑跟上面那个 blanket implementation 无关了，你可以仔细体会一下。\n\n3. 对的，你的第三条的理解非常正确。👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700837336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1524770,"avatar":"https://static001.geekbang.org/account/avatar/00/17/44/22/403a340a.jpg","nickname":"unistart","note":"","ucode":"C51E5D242530D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":632535,"discussion_content":"嗯嗯，谢谢老师解答。我之后仔细想了想问题一和问题二是我之前理解有点问题。\n\nimpl TraitB for u32 {}和impl TraitA for u32 {}之所以不能同时存在，是因为之前的Blanket  Implementation做了限制，一旦u32实现了TraitB就自动拥有了TraitA的能力，自然之后impl TraitA for u32 {}时会出现冲突的问题，这时可以注释掉impl TraitA for u32 {}；还有一种就是注释掉impl TraitB for u32 {}，这时u32类型不受之前的Blanket Implementation的限制，相当于没有实现过TraitA，因此之后还可以在u32类型上实现TraitA。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700957226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":632490,"ip_address":"湖南","group_id":0},"score":632535,"extra":""}]}]},{"had_liked":false,"id":384331,"user_name":"踩着太阳看日出","can_delete":false,"product_type":"c1","uid":1328082,"ip_address":"广东","ucode":"6837BC35E75A8A","user_header":"https://static001.geekbang.org/account/avatar/00/14/43/d2/71b06883.jpg","comment_is_top":false,"comment_ctime":1700705631,"is_pvip":false,"replies":[{"id":140232,"content":"你用的trait object，动态分派产生的现象。不知道调用哪一个","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700708737,"ip_address":"重庆","comment_id":384331,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"trait Shape {\n    fn play(&amp;self) {    &#47;&#47; 定义了play()方法\n        println!(&quot;1&quot;);\n    }\n}\ntrait Circle : Shape {\n    fn play(&amp;self) {    &#47;&#47; 也定义了play()方法\n        println!(&quot;2&quot;);\n    }\n}\nstruct A;\nimpl Shape for A {}\nimpl Circle for A {}\n\nimpl A {\n    fn play(&amp;self) {    &#47;&#47; 又直接在A上实现了play()方法\n        println!(&quot;3&quot;);\n    }\n}\n\nfn main() {\n    let a = A;\n    a.play();    &#47;&#47; 调用类型A上实现的play()方法\n    &lt;A as Circle&gt;::play(&amp;a);  &#47;&#47; 调用trait Circle上定义的play()方法\n    &lt;A as Shape&gt;::play(&amp;a);   &#47;&#47; 调用trait Shape上定义的play()方法\n\n    (&amp;a as &amp;dyn Shape).play();\n    Circle::play(&amp;a as &amp;dyn Circle);\n    Circle::play(&amp;a);\n\n    A::play(&amp;a);\n    (&amp;a as &amp;dyn Circle).play();\n}\n\nerror[E0034]: multiple applicable items in scope\n  --&gt; 07_ownership&#47;src&#47;mytest.rs:32:25\n   |\n32 |     (&amp;a as &amp;dyn Circle).play();\n   |                         ^^^^ multiple `play` found\n   |\nnote: candidate #1 is defined in the trait `Shape`\n  --&gt; 07_ownership&#47;src&#47;mytest.rs:2:5\n   |\n2  |     fn play(&amp;self) {    &#47;&#47; 定义了play()方法\n   |     ^^^^^^^^^^^^^^\nnote: candidate #2 is defined in the trait `Circle`\n  --&gt; 07_ownership&#47;src&#47;mytest.rs:7:5\n   |\n7  |     fn play(&amp;self) {    &#47;&#47; 也定义了play()方法\n   |     ^^^^^^^^^^^^^^\nhelp: disambiguate the method for candidate #1\n   |\n32 |     Shape::play(&amp;(&amp;a as &amp;dyn Circle));\n   |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nhelp: disambiguate the method for candidate #2\n   |\n32 |     Circle::play(&amp;(&amp;a as &amp;dyn Circle));\n   |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n提示多个方法，感觉还是有点像集成的意思，老师解释下","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632362,"discussion_content":"你用的trait object，动态分派产生的现象。不知道调用哪一个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700708737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384233,"user_name":"-Hedon🍭","can_delete":false,"product_type":"c1","uid":3176234,"ip_address":"湖北","ucode":"FAE541E7A2B88F","user_header":"https://static001.geekbang.org/account/avatar/00/30/77/2a/0cd4c373.jpg","comment_is_top":false,"comment_ctime":1700562467,"is_pvip":false,"replies":[{"id":140220,"content":"对的  👍","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700707255,"ip_address":"重庆","comment_id":384233,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"Rust 的 trait 更注重行为的抽象和方法的契约，而不涉及数据的继承。\nOOP 的继承涉及到类的层次结构，子类继承父类的属性和方法。","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632346,"discussion_content":"对的  👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700707255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383909,"user_name":"李志勇(Leo)","can_delete":false,"product_type":"c1","uid":1228080,"ip_address":"浙江","ucode":"5833C0831DD271","user_header":"https://static001.geekbang.org/account/avatar/00/12/bd/30/55488a4c.jpg","comment_is_top":false,"comment_ctime":1699928364,"is_pvip":false,"replies":[{"id":140079,"content":"对的，困在interface中，不足以认识trait的真实面目。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1699948935,"ip_address":"重庆","comment_id":383909,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"很不一样的视角【对泛型类型的约束】，\n一直以interface的概念的去理解，写代码的时候感觉很有压力。","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631772,"discussion_content":"对的，困在interface中，不足以认识trait的真实面目。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699948936,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383799,"user_name":"明天","can_delete":false,"product_type":"c1","uid":3738284,"ip_address":"上海","ucode":"5F7E4D0F35C802","user_header":"https://static001.geekbang.org/account/avatar/00/39/0a/ac/81053dda.jpg","comment_is_top":false,"comment_ctime":1699667297,"is_pvip":false,"replies":[{"id":139991,"content":"你做了这个实现     impl Sport for FootBall { ，当然是调用同一个函数 了。你可以 impl FootBall 实现一下同名函数试试。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1699846647,"ip_address":"重庆","comment_id":383799,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100626901,"comment_content":"```rust\npub fn trait_fn() {\n    trait Sport {\n        &#47;&#47; 实例方法\n        fn play(&amp;self) {\n            println!(&quot;this is a default method&quot;);\n        }\n        fn play_mut(&amp;mut self);\n        fn play_own(self);\n        &#47;&#47; 关联函数\n        fn play_some() -&gt; String {\n            &quot;this is a default method&quot;.to_string()\n        }\n    }\n\n    struct FootBall;\n\n    impl Sport for FootBall {\n        fn play(&amp;self) {\n            println!(&quot;this is a new method&quot;);\n        }\n\n        fn play_mut(&amp;mut self) {}\n\n        fn play_own(self) {}\n\n        fn play_some() -&gt; String {\n            &quot;this is a new method&quot;.to_string()\n        }\n    }\n\n    let s1 = FootBall::play_some();\n    let s2 = &lt;FootBall as Sport&gt;::play_some();\n\n    println!(&quot;s1 = {}&quot;, s1);\n    println!(&quot;s2 = {}&quot;, s2);\n}\n```\n请问老师， `let s2 = &lt;FootBall as Sport&gt;::play_some();`这里调用的是FootBall中的play_some()方法吗，我这边试了一下， 都是FootBall中的paly_some()触发的","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631619,"discussion_content":"你做了这个实现     impl Sport for FootBall { ，当然是调用同一个函数 了。你可以 impl FootBall 实现一下同名函数试试。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699846647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383701,"user_name":"A0.何文祥","can_delete":false,"product_type":"c1","uid":1052569,"ip_address":"广东","ucode":"2549126DAEA15D","user_header":"https://static001.geekbang.org/account/avatar/00/10/0f/99/0d72321f.jpg","comment_is_top":false,"comment_ctime":1699495657,"is_pvip":false,"replies":[{"id":139933,"content":"眼尖的你，多谢🙏","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1699505274,"ip_address":"重庆","comment_id":383701,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100626901,"comment_content":" typo：Dispaly -》 Display","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631400,"discussion_content":"眼尖的你，多谢🙏","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699505274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383677,"user_name":"-","can_delete":false,"product_type":"c1","uid":1546505,"ip_address":"北京","ucode":"7B34258D346793","user_header":"https://static001.geekbang.org/account/avatar/00/17/99/09/29c46a7b.jpg","comment_is_top":false,"comment_ctime":1699437275,"is_pvip":false,"replies":[{"id":139937,"content":"那肯定的呀，得动手。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1699505422,"ip_address":"重庆","comment_id":383677,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100626901,"comment_content":"听语音初学者完全跟不上，还是得细细看过文章才行","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631404,"discussion_content":"那肯定的呀，得动手。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699505422,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1012627,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/73/93/abb7bfe3.jpg","nickname":"Marco","note":"","ucode":"502149B57700FE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631259,"discussion_content":"确实啊，要仔细看文章内容\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699443812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383657,"user_name":"啊Ray","can_delete":false,"product_type":"c1","uid":1081676,"ip_address":"广东","ucode":"FE14A61A6F3C15","user_header":"https://static001.geekbang.org/account/avatar/00/10/81/4c/e42bc9b8.jpg","comment_is_top":false,"comment_ctime":1699416152,"is_pvip":false,"replies":[{"id":139940,"content":"放playground里面改改运行运行，有助于理解。光看是绝对会晕滴","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1699505562,"ip_address":"重庆","comment_id":383657,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100626901,"comment_content":"感觉关联类型那里看得一头雾水的。。能不能搞几个通俗易懂的例子讲解一下？","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631407,"discussion_content":"放playground里面改改运行运行，有助于理解。光看是绝对会晕滴","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699505562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383634,"user_name":"Geek_cbeb39","can_delete":false,"product_type":"c1","uid":2882773,"ip_address":"美国","ucode":"40B0CDA6B67BB6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep7w8XNyxrp9fmSds4F1CUnDqVRUSyicsf3icLOeK5S11WybjqUM86TDz0LwJibSECD6w22umsGiamWXA/132","comment_is_top":false,"comment_ctime":1699382923,"is_pvip":false,"replies":[{"id":139816,"content":"涉及一点点。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1699412192,"ip_address":"重庆","comment_id":383634,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100626901,"comment_content":"大佬这个课之后会涉及到Rust&amp;webassmbly的内容吗","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631228,"discussion_content":"涉及一点点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699412193,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386214,"user_name":"mihello","can_delete":false,"product_type":"c1","uid":1287406,"ip_address":"广东","ucode":"4B1E7B7A141606","user_header":"https://static001.geekbang.org/account/avatar/00/13/a4/ee/b960a322.jpg","comment_is_top":false,"comment_ctime":1704340274,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":4,"product_id":100626901,"comment_content":"我不是初学者了，已经用Rust写过千来行的小工具。不过始终还是没有一种通透感觉，看了这一章收获良多，有点醍醐灌顶。远远超越官方教程，官方教程真的太简陋了...\n其实自己写还好，最怕看开源项目源码，如果没学透真的看不懂。看了老师的教程相信会大有进步。","like_count":1,"discussions":[{"author":{"id":3736170,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/fLI3NSG6qScRzrMBQzuXHzAY0QyialcvoadMd662U7hxhJe7jlpAPgjtRPTicE91lWWSJx80TRrXXaVja59YJQ9g/132","nickname":"Geek_07ce33","note":"","ucode":"E4E4C89A024433","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636257,"discussion_content":"我就是看了官方免费教程，看了一点实在看不下去了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705912895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"山东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":396003,"user_name":"当初莫相识","can_delete":false,"product_type":"c1","uid":2768765,"ip_address":"北京","ucode":"313917BB360D48","user_header":"https://static001.geekbang.org/account/avatar/00/2a/3f/7d/f624fa69.jpg","comment_is_top":false,"comment_ctime":1732672000,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100626901,"comment_content":"这篇知识密度太高，学不懂了，学习rust太抽象了，很难用对比和知识迁移的方法进行学习","like_count":0},{"had_liked":false,"id":392788,"user_name":"HappyHasson","can_delete":false,"product_type":"c1","uid":2911084,"ip_address":"广东","ucode":"B84CC43E349CFA","user_header":"https://static001.geekbang.org/account/avatar/00/2c/6b/6c/3e80afaf.jpg","comment_is_top":false,"comment_ctime":1721783648,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100626901,"comment_content":"关联常量的一节里，`println!(&quot;{:?}&quot;,::LEN); ` \n\n这里为什么输出 12  ？  不是把 A 转为 TraitA 了吗？在C++的对象模型里 这里应该输出 10 。 这里的底层实现是什么 ","like_count":0},{"had_liked":false,"id":391070,"user_name":"独钓寒江","can_delete":false,"product_type":"c1","uid":1203049,"ip_address":"中国香港","ucode":"2C81906FD88C8C","user_header":"https://static001.geekbang.org/account/avatar/00/12/5b/69/7ace1ddb.jpg","comment_is_top":false,"comment_ctime":1717220208,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100626901,"comment_content":"trait TraitA {}\ntrait TraitB {}\n\nimpl&lt;T: TraitB&gt; TraitA for T {}\n\nimpl TraitA for u32 {}\n\n最后一句应该是 impl TraitB for u32 {} 才对吗？","like_count":0},{"had_liked":false,"id":390178,"user_name":"独钓寒江","can_delete":false,"product_type":"c1","uid":1203049,"ip_address":"广东","ucode":"2C81906FD88C8C","user_header":"https://static001.geekbang.org/account/avatar/00/12/5b/69/7ace1ddb.jpg","comment_is_top":false,"comment_ctime":1714562646,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100626901,"comment_content":"trait TraitA {}\ntrait TraitB {}\n\nimpl&lt;T: TraitB&gt; TraitA for T {}\n\nimpl TraitA for u32 {}\n\n没想明白为什么这里u32 {}T {}\n\nimpl TraitA for u32 {}\n\n没想明白为什么这里u32 {} 和 T {} 联系上了","like_count":0}]}