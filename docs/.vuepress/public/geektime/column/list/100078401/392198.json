{"id":392198,"title":"26 | 多个活动要安排（下）：如何实现进程的等待与唤醒机制？","content":"<p>你好，我是LMOS。</p><p>上节课，我带你一起设计了我们Cosmos的进程调度器，但有了进程调度器还不够，因为调度器它始终只是让一个进程让出CPU，切换到它选择的下一个进程上去运行。</p><p>结合前面我们对进程生命周期的讲解，估计你已经反应过来了。没错，多进程调度方面，我们还要实现进程的等待与唤醒机制，今天我们就来搞定它。</p><p>这节课的配套代码，你可以从<a href=\"https://gitee.com/lmos/cosmos/tree/master/lesson25~26/Cosmos\">这里</a>下载。</p><h2>进程的等待与唤醒</h2><p>我们已经知道，进程得不到所需的某个资源时就会进入等待状态，直到这种资源可用时，才会被唤醒。那么进程的等待与唤醒机制到底应该这样设计呢，请听我慢慢为你梳理。</p><h3>进程等待结构</h3><p>很显然，在实现进程的等待与唤醒的机制之前，我们需要设计一种数据结构，用于挂载等待的进程，在唤醒的时候才可以找到那些等待的进程 ，这段代码如下所示。</p><pre><code>typedef struct s_KWLST\n{   \n    spinlock_t wl_lock;  //自旋锁\n    uint_t   wl_tdnr;    //等待进程的个数\n    list_h_t wl_list;    //挂载等待进程的链表头\n}kwlst_t;\n</code></pre><p>其实，这个结构在前面讲<a href=\"https://time.geekbang.org/column/article/377913\">信号量</a>的时候，我们已经见过了。这是因为它经常被包含在信号量等上层数据结构中，而信号量结构，通常用于保护访问受限的共享资源。这个结构非常简单，我们不用多说。</p><h3>进程等待</h3><p>现在我们来实现让进程进入等待状态的机制，它也是一个函数。这个函数会设置进程状态为等待状态，让进程从调度系统数据结构中脱离，最后让进程加入到kwlst_t等待结构中，代码如下所示。</p><!-- [[[read_end]]] --><pre><code>void krlsched_wait(kwlst_t *wlst)\n{\n    cpuflg_t cufg, tcufg;\n    uint_t cpuid = hal_retn_cpuid();\n    schdata_t *schdap = &amp;osschedcls.scls_schda[cpuid];\n    //获取当前正在运行的进程\n    thread_t *tdp = krlsched_retn_currthread();\n    uint_t pity = tdp-&gt;td_priority;\n    krlspinlock_cli(&amp;schdap-&gt;sda_lock, &amp;cufg);\n    krlspinlock_cli(&amp;tdp-&gt;td_lock, &amp;tcufg);\n    tdp-&gt;td_stus = TDSTUS_WAIT;//设置进程状态为等待状态\n    list_del(&amp;tdp-&gt;td_list);//脱链\n    krlspinunlock_sti(&amp;tdp-&gt;td_lock, &amp;tcufg);\n    if (schdap-&gt;sda_thdlst[pity].tdl_curruntd == tdp)\n    {\n        schdap-&gt;sda_thdlst[pity].tdl_curruntd = NULL;\n    }\n    schdap-&gt;sda_thdlst[pity].tdl_nr--;\n    krlspinunlock_sti(&amp;schdap-&gt;sda_lock, &amp;cufg);\n    krlwlst_add_thread(wlst, tdp);//将进程加入等待结构中\n    return;\n}\n</code></pre><p>上述代码也不难，你结合注释就能理解。有一点需要注意，这个函数使进程进入等待状态，而这个<strong>进程是当前正在运行的进程，而当前正在运行的进程正是调用这个函数的进程</strong>，所以一个进程想要进入等待状态，只要调用这个函数就好了。</p><h3>进程唤醒</h3><p>进程的唤醒则是进程等待的反向操作行为，即从等待数据结构中获取进程，然后设置进程的状态为运行状态，最后将这个进程加入到进程调度系统数据结构中。这个函数的代码如下所示。</p><pre><code>void krlsched_up(kwlst_t *wlst)\n{\n    cpuflg_t cufg, tcufg;\n    uint_t cpuid = hal_retn_cpuid();\n    schdata_t *schdap = &amp;osschedcls.scls_schda[cpuid];\n    thread_t *tdp;\n    uint_t pity;\n    //取出等待数据结构第一个进程并从等待数据结构中删除\n    tdp = krlwlst_del_thread(wlst);\n    pity = tdp-&gt;td_priority;//获取进程的优先级\n    krlspinlock_cli(&amp;schdap-&gt;sda_lock, &amp;cufg);\n    krlspinlock_cli(&amp;tdp-&gt;td_lock, &amp;tcufg);\n    tdp-&gt;td_stus = TDSTUS_RUN;//设置进程的状态为运行状态\n    krlspinunlock_sti(&amp;tdp-&gt;td_lock, &amp;tcufg);\n    list_add_tail(&amp;tdp-&gt;td_list, &amp;(schdap-&gt;sda_thdlst[pity].tdl_lsth));//加入进程优先级链表\n    schdap-&gt;sda_thdlst[pity].tdl_nr++;\n    krlspinunlock_sti(&amp;schdap-&gt;sda_lock, &amp;cufg);\n    return;\n}\n</code></pre><p>上面的代码相对简单，我想以你的能力，还能写出比以上更好的代码。好了，到这里，我们进程的等待与唤醒的机制已经实现了。</p><h2>空转进程</h2><p>下面我们一起来建立空转进程 ，它也是我们系统下的第一个进程。空转进程是操作系统在没任何进程可以调度运行的时候，就选择调度空转进程来运行，可以说<strong>空转进程是进程调度器最后的选择。</strong></p><p>请注意，这个最后的选择一定要有，现在几乎所有的操作系统，都有一个或者几个空转进程（多CPU的情况下，每个CPU一个空转进程）。我们的Cosmos虽然是简单了些，但也必须要有空转进程，而且这是我们Cosmos上的第一个进程。</p><h3>建立空转进程</h3><p>我们Cosmos的空转进程是个内核进程，按照常理，我们只要调用上节课实现的建立进程的接口，创建一个内核进程就好了。</p><p>但是我们的空转进程有点特殊，它是内核进程没错，但它不加入调度系统，而是一个专用的指针指向它的。</p><p>下面我们来建立一个空转进程。由于空转进程是个独立的模块，我们建立一个新的C语言文件Cosmos/kernel/krlcpuidle.c，代码如下所示。</p><pre><code>thread_t *new_cpuidle_thread()\n{\n\n    thread_t *ret_td = NULL;\n    bool_t acs = FALSE;\n    adr_t krlstkadr = NULL;\n    uint_t cpuid = hal_retn_cpuid();\n    schdata_t *schdap = &amp;osschedcls.scls_schda[cpuid];\n    krlstkadr = krlnew(DAFT_TDKRLSTKSZ);//分配进程的内核栈\n    if (krlstkadr == NULL)\n    {\n        return NULL;\n    }\n    //分配thread_t结构体变量\n    ret_td = krlnew_thread_dsc();\n    if (ret_td == NULL)\n    {\n        acs = krldelete(krlstkadr, DAFT_TDKRLSTKSZ);\n        if (acs == FALSE)\n        {\n            return NULL;\n        }\n        return NULL;\n    }\n    //设置进程具有系统权限\n    ret_td-&gt;td_privilege = PRILG_SYS;\n    ret_td-&gt;td_priority = PRITY_MIN;\n    //设置进程的内核栈顶和内核栈开始地址\n    ret_td-&gt;td_krlstktop = krlstkadr + (adr_t)(DAFT_TDKRLSTKSZ - 1);\n    ret_td-&gt;td_krlstkstart = krlstkadr;\n    //初始化进程的内核栈\n    krlthread_kernstack_init(ret_td, (void *)krlcpuidle_main, KMOD_EFLAGS);\n    //设置调度系统数据结构的空转进程和当前进程为ret_td\n    schdap-&gt;sda_cpuidle = ret_td;\n    schdap-&gt;sda_currtd = ret_td;\n    return ret_td;\n}\n//新建空转进程\nvoid new_cpuidle()\n{\n    thread_t *thp = new_cpuidle_thread();//建立空转进程\n    if (thp == NULL)\n    {//失败则主动死机\n        hal_sysdie(&quot;newcpuilde err&quot;);\n    }\n    kprint(&quot;CPUIDLETASK: %x\\n&quot;, (uint_t)thp);\n    return;\n}\n</code></pre><p>上述代码中，建立空转进程由new_cpuidle函数调用new_cpuidle_thread函数完成，new_cpuidle_thread函数的操作和前面建立内核进程差不多，只不过在函数的最后，让调度系统数据结构的空转进程和当前进程的指针，指向了刚刚建立的进程。</p><p>但是你要注意，上述代码中调用初始内核栈函数时，将krlcpuidle_main函数传了进去，这就是空转进程的主函数，下面我们来写好。</p><pre><code>void krlcpuidle_main()\n{\n    uint_t i = 0;\n    for (;; i++)\n    {\n        kprint(&quot;空转进程运行:%x\\n&quot;, i);//打印\n        krlschedul();//调度进程\n    }\n    return;\n}\n</code></pre><p>我给你解释一下，空转进程的主函数本质就是个死循环，在死循环中打印一行信息，然后进行进程调度，这个函数就是永无休止地执行这两个步骤。</p><h3>空转进程运行</h3><p>我们已经建立了空转进程，下面就要去运行它了。</p><p>由于是第一进程，所以没法用调度器来调度它，我们得手动启动它，才可以运行。其实<a href=\"https://time.geekbang.org/column/article/391222\">上节课</a>我们已经写了启动一个新建进程运行的函数，我们现在只要调用它就好了，代码如下所示。</p><pre><code>void krlcpuidle_start()\n{\n    uint_t cpuid = hal_retn_cpuid();\n    schdata_t *schdap = &amp;osschedcls.scls_schda[cpuid];\n    //取得空转进程\n    thread_t *tdp = schdap-&gt;sda_cpuidle;\n    //设置空转进程的tss和R0特权级的栈\n    tdp-&gt;td_context.ctx_nexttss = &amp;x64tss[cpuid];\n    tdp-&gt;td_context.ctx_nexttss-&gt;rsp0 = tdp-&gt;td_krlstktop;\n    //设置空转进程的状态为运行状态\n    tdp-&gt;td_stus = TDSTUS_RUN;\n    //启动进程运行\n    retnfrom_first_sched(tdp);\n    return;\n}\n</code></pre><p>上述代码的逻辑也很容易理解，我为你梳理一下。首先就是取出空转进程，然后设置一下机器上下文结构和运行状态，最后调用retnfrom_first_sched函数，恢复进程内核栈中的内容，让进程启动运行。</p><p>不过这还没完，我们应该把建立空转进程和启动空转进程运行函数封装起来，放在一个初始化空转进程的函数中，并在内核层初始化init_krl函数的最后调用，代码如下所示。</p><pre><code>void init_krl()\n{\n    init_krlsched();//初始化进程调度器\n    init_krlcpuidle();//初始化空转进程\n    die(0);//防止init_krl函数返回\n    return;\n}\n//初始化空转进程\nvoid init_krlcpuidle()\n{\n    new_cpuidle();//建立空转进程\n    krlcpuidle_start();//启动空转进程运行\n    return;\n}\n</code></pre><p>好了，所有的代码都已备好，终于到我们检验学习成果的时候了，我切换到这节课程的cosmos目录下执行make vboxtest 命令，就会出现如下图的结果，如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/ef/24/efcf95c11732273ace5329152c782924.jpg?wh=1064x921\" alt=\"\" title=\"空转进程运行\"></p><p>可以看到，现在空转进程和调度器输出的信息在屏幕上交替滚动出现，这说明我们的空转进程和进程调度器都已经正常工作了。</p><h2>多进程运行</h2><p>虽然我们的空转进程和调度器已经正常工作了，但你可能心里会有疑问，我们系统中就一个空转进程，那怎么证明我们进程调度器是正常工作的呢？</p><p>其实我们在空转进程中调用了调度器函数，然后进程调度器会发现系统中没有进程，又不得不调度空转进程，所以最后结果就是：空转进程调用进程调度器，而调度器又选择了空转进程，导致形成了一个闭环。</p><p>但是我们现在想要看看多个进程会是什么情况，就需要建立多个进程。下面我们马上就来实现这个想法，代码如下。</p><pre><code>void thread_a_main()//进程A主函数\n{\n    uint_t i = 0;\n    for (;; i++) {\n        kprint(&quot;进程A运行:%x\\n&quot;, i);\n        krlschedul();\n    }\n    return;\n}\nvoid thread_b_main()//进程B主函数\n{\n    uint_t i = 0;\n    for (;; i++) {\n        kprint(&quot;进程B运行:%x\\n&quot;, i);\n        krlschedul();\n    }\n    return;\n}\nvoid init_ab_thread()\n{\n    krlnew_thread((void*)thread_a_main, KERNTHREAD_FLG, \n                PRILG_SYS, PRITY_MIN, DAFT_TDUSRSTKSZ, DAFT_TDKRLSTKSZ);//建立进程A\n    krlnew_thread((void*)thread_b_main, KERNTHREAD_FLG, \n                PRILG_SYS, PRITY_MIN, DAFT_TDUSRSTKSZ, DAFT_TDKRLSTKSZ);//建立进程B\n    return;\n}\nvoid init_krlcpuidle()\n{\n    new_cpuidle();//建立空转进程\n    init_ab_thread();//初始化建立A、B进程\n    krlcpuidle_start();//开始运行空转进程\n    return;\n}\n</code></pre><p>上述代码中，我们在init_ab_thread函数中建立两个内核进程，分别运行两个函数，这两个函数会打印信息，init_ab_thread函数由init_krlcpuidle函数调用。这样在初始化空转进程的时候，就建立了进程A和进程B。</p><p>好了，现在我们在Linux终端下进入cosmos目录，在目录下输入make vboxtest运行一下，结果如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/f9/b1/f986251428c419f5b2000308236466b1.jpg?wh=1064x921\" alt=\"\" title=\"两个进程结果截图\"></p><p>上图中，进程A和进程B在调度器的调度下交替运行，而空转进程不再运行，这表明我们的多进程机制完全正确。</p><h2>重点回顾</h2><p>这节课我们接着上一节课，实现了进程的等待与唤醒机制，然后建立了空转进程，最后对进程调度进行了测试。下面我来为你梳理一下要点。</p><p>1.<strong>等待和唤醒机制。</strong>为了让进程能进入等待状态随后又能在其它条件满足的情况下被唤醒，我们实现了进程等待和唤醒机制。</p><p>2.<strong>空转进程。</strong>是我们Cosmos系统下的第一个进程，它只干一件事情就是调用调度器函数调度进程，在系统中没有其它可以运行进程时，调度器又会调度空转进程，形成了一个闭环。</p><p>3.<strong>测试。</strong>为了验证我们的进程调度器是否是正常工作的，我们建立了两个进程，让它们运行，结果在屏幕上出现了它们交替输出的信息。这证明了我们的进程调度器是功能正常的。</p><p>你也许发现了，我们的进程中都调用了krlschedul函数，不调用它就是始终只有一个进程运行了，你在开发应用程序中，需要调用调度器主动让出CPU吗？</p><p>这是什么原因呢？这是因为我们的Cosmos没有定时器驱动，系统的TICK机制无法工作，一旦我们系统TICK机开始工作，就能控制进程运行了多长时间，然后强制调度进程。系统TICK设备我们等到驱动与设备相关的模块，再给你展开讲解。</p><h2>思考题</h2><p>请问，我们让进程进入等待状态后，这进程会立马停止运行吗？</p><p>欢迎你在留言区和我交流，相信通过积极参与，你将更好地理解这节课的内容。</p><p>好，我是LMOS，我们下节课见！</p>","neighbors":{"left":{"article_title":"25 | 多个活动要安排（上）：多进程如何调度？","id":391222},"right":{"article_title":"27 | 瞧一瞧Linux：Linux如何实现进程与进程调度?","id":393350}},"comments":[{"had_liked":false,"id":301261,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":true,"comment_ctime":1625612283,"is_pvip":false,"replies":[{"id":"109103","content":"66666  对的 ","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1625625506,"ip_address":"","comment_id":301261,"utype":1}],"discussion_count":2,"race_medal":0,"score":"9.2233720857249997e+18","product_id":100078401,"comment_content":"并不会，进程进入等待只是进程状态发生了改变，进程还未让出当前CPU的执行权，待调度后，即 krlschedul()，会寻找已经准备好的其它进程，切换CPU上下文，让出CPU，此时该进程才会真正的停止。<br><br>所以调度函数至关重要！","like_count":11,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522947,"discussion_content":"66666  对的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625625506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135528,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/a8/abc96f70.jpg","nickname":"return","note":"","ucode":"42B8A3380DF04B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390082,"discussion_content":"mark: \n进程进入等待只是进程状态发生了改变，进程还未让出当前CPU的执行权，待调度后，即 krlschedul()，会寻找已经准备好的其它进程，切换CPU上下文，让出CPU，此时该进程才会真正的停止","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629645196,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":301364,"user_name":"neohope","can_delete":false,"product_type":"c1","uid":1043475,"ip_address":"","ucode":"C0268F6E7E2B6E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","comment_is_top":true,"comment_ctime":1625647501,"is_pvip":false,"replies":[{"id":"109194","content":"不会有问题的 因 SMP下每个CPU会对应一个idle 进程  运行同一份代码  ","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1625803228,"ip_address":"","comment_id":301364,"utype":1}],"discussion_count":1,"race_medal":0,"score":"9.2233720642502001e+18","product_id":100078401,"comment_content":"一、数据结构<br>全局有一个osschedcls变量，其数据结构为schedclass_t，用于管理所有cpu的所有进程。<br><br>schedclass_t包括一个 schdata_t数组，每个cpu对应一个。<br>schedclass_t.schdata_t[i]，用于管理第i个cpu的全部进程。<br><br>schedclass_t.schdata_t[i]包括一个thrdlst_t数组，每个进程优先级对应一个。<br>schedclass_t.schdata_t[i].thrdlst_t[j]中，管理了第i个cpu的，优先级为j的全部进程。<br><br>二、idel进程<br>idel进程初始化及启动：<br>init_krl-&gt;init_krlcpuidle-&gt;new_cpuidle-&gt;new_cpuidle_thread-&gt;krlthread_kernstack_init【krlcpuidle_main传参】-&gt;krlschedul-&gt;krlcpuidle_start-&gt;retnfrom_first_sched启动idel进程<br><br>idel进程调度：<br>idel进程启动后，会不停的在krlcpuidle_main函数中循环调用krlschedul，只要有其他进程可以运行，就让渡CPU使用权给到其他进程；<br>其他进程调用krlschedul让渡CPU使用权时，如果找不到”下一进程“，会将CPU使用权给回到idel进程；<br><br>三、进程的等待与唤醒【信号量为例】<br>信号量sem_t，有一个等待进程列表kwlst_t，保存了等待获取信号量的全部进程列表<br><br>获取信号量：<br>进程调用krlsem_down-&gt;当信号量不足时krlwlst_wait-&gt;主动调用krlsched_wait让渡CPU使用权，让其他进程优先运行<br>即使其他进程把CPU使用权又还回来，也会继续循环，不断尝试获取信号量<br><br>释放信号量：<br>进程调用krlsem_up-&gt;krlwlst_allup-&gt;对kwlst_t中全部等待进程，依次调用krlsched_up-&gt;被给与CPU使用权的进程，会立即唤醒并尝试获取信号量<br><br>最后，有一个问题没想清楚，还请老师帮忙解答一下：<br>系统的idel进程只有一个，如果多个cpu同时空闲，会不会有问题啊？空闲进程不用per_cpu吗？","like_count":6,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522980,"discussion_content":"不会有问题的 因 SMP下每个CPU会对应一个idle 进程  运行同一份代码  ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625803228,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":302678,"user_name":"geek2020","can_delete":false,"product_type":"c1","uid":2045843,"ip_address":"","ucode":"3E7F7F8D419A75","user_header":"","comment_is_top":false,"comment_ctime":1626331468,"is_pvip":false,"replies":[{"id":"109569","content":"sleep 会设置定时器 然后 主动 调用调度器 ","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1626399150,"ip_address":"","comment_id":302678,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10216266060","product_id":100078401,"comment_content":"好奇很多资料说java执行了Thread.sleep()后，会主动让出CPU的使用权，是怎么做到的？","like_count":2,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523383,"discussion_content":"sleep 会设置定时器 然后 主动 调用调度器 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626399150,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2085640,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/d3/08/ffd93029.jpg","nickname":"太阳","note":"","ucode":"24B8E951956789","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390378,"discussion_content":"时钟中断","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629808715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135528,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/a8/abc96f70.jpg","nickname":"return","note":"","ucode":"42B8A3380DF04B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390085,"discussion_content":"然后进程进入了等待链表。\n时间到了 把进程在放到调度链表中？\n问题是 如何判断时间到了， 谁在判断？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629645354,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":302261,"user_name":"Feen","can_delete":false,"product_type":"c1","uid":2646145,"ip_address":"","ucode":"E6CDC442B7213F","user_header":"https://static001.geekbang.org/account/avatar/00/28/60/81/38b00111.jpg","comment_is_top":false,"comment_ctime":1626148694,"is_pvip":false,"replies":[{"id":"109359","content":"对的 ","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1626169967,"ip_address":"","comment_id":302261,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5921115990","product_id":100078401,"comment_content":" 进程进入等待状态后，进程本身处于等待状态，进程被剥夺CPU使用权是通过krlschedul()函数剥夺的，而进程本身并没有调用krlschedul()函数，所以不会立即停止运行，而剥夺CPU使用权是由krlschedul()函数控制的，当保存当前进程寄存器和栈，并且准备好下一个进程的运行函数后，才会让当前进程退出CPU而停止运行了。","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523245,"discussion_content":"对的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626169967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":301417,"user_name":"青玉白露","can_delete":false,"product_type":"c1","uid":2619436,"ip_address":"","ucode":"96FE2D4D2B94A0","user_header":"https://static001.geekbang.org/account/avatar/00/27/f8/2c/92969c48.jpg","comment_is_top":false,"comment_ctime":1625667657,"is_pvip":false,"replies":[{"id":"109190","content":"是的 正确","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1625802769,"ip_address":"","comment_id":301417,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5920634953","product_id":100078401,"comment_content":"进程不会马上停止运行，调用krlschedul()之后，会调度新的进程。","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522993,"discussion_content":"是的 正确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625802769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":355397,"user_name":"Ivan.Qi","can_delete":false,"product_type":"c1","uid":1099170,"ip_address":"湖北","ucode":"36F46A4D1F0EAA","user_header":"https://static001.geekbang.org/account/avatar/00/10/c5/a2/4ece341b.jpg","comment_is_top":false,"comment_ctime":1661332678,"is_pvip":false,"replies":[{"id":"129440","content":"你修改代码 了吗  ","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1661677565,"ip_address":"湖北","comment_id":355397,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1661332678","product_id":100078401,"comment_content":"遇到一个问题，暂时没什么头绪<br>1. 通过krlnew_thread 初始化一个进程<br>   krlnew_thread(&quot;kernelthread-a&quot;, (void*)thread_a_main, KERNTHREAD_FLG, PRILG_SYS, PRITY_MIN, DAFT_TDUSRSTKSZ, DAFT_TDKRLSTKSZ);<br><br>2. 进程自定义函数<br>  void thread_a_main(){ uint_t i = 0;  kprint(&quot;进程A运行:%x\\n&quot;, i); }<br><br>3. 然后程序执行<br>   1. new_cpuidle 2. init_a_thread 3. krlcpuidle_start -&gt; retnfrom_first_sched<br><br>4. 最后提示<br>   当前进程: kernelthread-a,犯了不该犯的错误:13, 所以要杀","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585560,"discussion_content":"你修改代码 了吗  ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661677565,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖北"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":1099170,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c5/a2/4ece341b.jpg","nickname":"Ivan.Qi","note":"","ucode":"36F46A4D1F0EAA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":585591,"discussion_content":"自己一点点搭建的工程。进程中回调函数的死循环加上就没问题了，不加就出现这个问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661692877,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":585560,"ip_address":"广东"},"score":585591,"extra":""},{"author":{"id":1099170,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c5/a2/4ece341b.jpg","nickname":"Ivan.Qi","note":"","ucode":"36F46A4D1F0EAA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":585592,"discussion_content":"但是通过krlthread_execvl 调用love.app就没有这个问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661692989,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":585560,"ip_address":"广东"},"score":585592,"extra":""}]}]},{"had_liked":false,"id":346625,"user_name":"我是新手ABC","can_delete":false,"product_type":"c1","uid":2700978,"ip_address":"","ucode":"9EA87A46FDC378","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/icD3j8Uhe4xML3HTdgd93YrenCZEuX4UwYZcYG9y3o4gRyWJCKS2vXBQmq0vnKhUIP8vPpg8F2Iicw68Tvg60elg/132","comment_is_top":false,"comment_ctime":1653297638,"is_pvip":false,"replies":[{"id":"126496","content":"是的 但系统中不只有空转进程","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1653617619,"ip_address":"","comment_id":346625,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1653297638","product_id":100078401,"comment_content":"有个疑问：如果空转函数一直运行的话，也就是CPU不是在运行用户代码就是在运行空转函数，那CPU的使用率会不会一直是100%呢？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573707,"discussion_content":"是的 但系统中不只有空转进程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653617619,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2700978,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/icD3j8Uhe4xML3HTdgd93YrenCZEuX4UwYZcYG9y3o4gRyWJCKS2vXBQmq0vnKhUIP8vPpg8F2Iicw68Tvg60elg/132","nickname":"我是新手ABC","note":"","ucode":"9EA87A46FDC378","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":574172,"discussion_content":"谢谢大佬解答，是不是可以这么理解：除去空转进程所占用的CPU使用率，才是系统统计的CPU的负载率？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653882402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":573707,"ip_address":""},"score":574172,"extra":""}]}]},{"had_liked":false,"id":344712,"user_name":"艾恩凝","can_delete":false,"product_type":"c1","uid":2950704,"ip_address":"","ucode":"F2B81BF4F0106A","user_header":"https://static001.geekbang.org/account/avatar/00/2d/06/30/c26ea06a.jpg","comment_is_top":false,"comment_ctime":1651734092,"is_pvip":false,"replies":[{"id":"125965","content":"是不是  地址 映射 的问题","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1652065668,"ip_address":"","comment_id":344712,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1651734092","product_id":100078401,"comment_content":"自己建的工程，怎么新建空转进程的时候 运行到krlthread_kernstack_init 函数中，就会报14号异常，这是怎么回事，就是初始化内核栈的时候，按道理说这都是物理地址，怎么还是会进入14 异常","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571071,"discussion_content":"是不是  地址 映射 的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652065668,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2950704,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/06/30/c26ea06a.jpg","nickname":"艾恩凝","note":"","ucode":"F2B81BF4F0106A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":571172,"discussion_content":"确实，物理地址没有换成虚拟地址，老师果然一语道出关键","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652099617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":571071,"ip_address":""},"score":571172,"extra":""}]},{"author":{"id":2950704,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/06/30/c26ea06a.jpg","nickname":"艾恩凝","note":"","ucode":"F2B81BF4F0106A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570331,"discussion_content":"太搞了，这个错误找了一个多小时，留完言，突然怀疑是内存池返回的是物理地址，果然对比代码还真的是，改成虚拟地址即可，完美运行，再复盘一遍，进程也算是即将结束","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651734800,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343684,"user_name":"胡涂涂","can_delete":false,"product_type":"c1","uid":2842428,"ip_address":"","ucode":"B89A6CFFA6BA54","user_header":"https://static001.geekbang.org/account/avatar/00/2b/5f/3c/a54e8838.jpg","comment_is_top":false,"comment_ctime":1650980842,"is_pvip":false,"replies":[{"id":"125971","content":"是的","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1652065919,"ip_address":"","comment_id":343684,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1650980842","product_id":100078401,"comment_content":"这个调度机制很像嵌入式中实时操作系统的多任务调度，空转进程对标空闲任务。空转任务中，可以做一些维护性的任务，不能让cpu闲下来，哈哈哈","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571077,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652065919,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":309489,"user_name":"阿顺","can_delete":false,"product_type":"c1","uid":2735751,"ip_address":"","ucode":"AC611EE07B0053","user_header":"https://static001.geekbang.org/account/avatar/00/29/be/87/fc7d259a.jpg","comment_is_top":false,"comment_ctime":1630161355,"is_pvip":false,"replies":[{"id":"112118","content":"当然是资源 不满足时","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1630286409,"ip_address":"","comment_id":309489,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1630161355","product_id":100078401,"comment_content":"想咨询下进程如何决策何时要等待，并让出cpu？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525896,"discussion_content":"当然是资源 不满足时","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630286409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":301278,"user_name":"blentle","can_delete":false,"product_type":"c1","uid":1064679,"ip_address":"","ucode":"AC092609A4942A","user_header":"https://static001.geekbang.org/account/avatar/00/10/3e/e7/261711a5.jpg","comment_is_top":false,"comment_ctime":1625619614,"is_pvip":false,"replies":[{"id":"109100","content":"这不一定，我们也不用fork","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1625625452,"ip_address":"","comment_id":301278,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1625619614","product_id":100078401,"comment_content":"好奇，这个空转进程是我们平时所说的0号进程吗，1号进程的创建是fork它吗","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522954,"discussion_content":"这不一定，我们也不用fork","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625625452,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":301272,"user_name":"罗 乾 林","can_delete":false,"product_type":"c1","uid":1188222,"ip_address":"","ucode":"D0406F95176ABA","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/7e/fb725950.jpg","comment_is_top":false,"comment_ctime":1625618091,"is_pvip":false,"replies":[{"id":"109102","content":"对的 ","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1625625485,"ip_address":"","comment_id":301272,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1625618091","product_id":100078401,"comment_content":"进程进入等待状态后，这进程不会立马停止运行，要等到调用krlschedul函数后","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522949,"discussion_content":"对的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625625485,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}