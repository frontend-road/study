{"id":64586,"title":"19 | 散列表（中）：如何打造一个工业级水平的散列表？","content":"<p>通过上一节的学习，我们知道，散列表的查询效率并不能笼统地说成是O(1)。它跟散列函数、装载因子、散列冲突等都有关系。如果散列函数设计得不好，或者装载因子过高，都可能导致散列冲突发生的概率升高，查询效率下降。</p><p>在极端情况下，有些恶意的攻击者，还有可能通过精心构造的数据，使得所有的数据经过散列函数之后，都散列到同一个槽里。如果我们使用的是基于链表的冲突解决方法，那这个时候，散列表就会退化为链表，查询的时间复杂度就从O(1)急剧退化为O(n)。</p><p>如果散列表中有10万个数据，退化后的散列表查询的效率就下降了10万倍。更直接点说，如果之前运行100次查询只需要0.1秒，那现在就需要1万秒。这样就有可能因为查询操作消耗大量CPU或者线程资源，导致系统无法响应其他请求，从而达到拒绝服务攻击（DoS）的目的。这也就是散列表碰撞攻击的基本原理。</p><p>今天，我们就来学习一下，<strong><span class=\"orange\">如何设计一个可以应对各种异常情况的工业级散列表，来避免在散列冲突的情况下，散列表性能的急剧下降，并且能抵抗散列碰撞攻击？</span></strong></p><h2>如何设计散列函数？</h2><p>散列函数设计的好坏，决定了散列表冲突的概率大小，也直接决定了散列表的性能。那什么才是好的散列函数呢？</p><p>首先，<strong>散列函数<strong><strong>的</strong></strong>设计不能太复杂</strong>。过于复杂的散列函数，势必会消耗很多计算时间，也就间接地影响到散列表的性能。其次，<strong>散列函数生成的值要尽可能随机并且均匀分布</strong>，这样才能避免或者最小化散列冲突，而且即便出现冲突，散列到每个槽里的数据也会比较平均，不会出现某个槽内数据特别多的情况。</p><!-- [[[read_end]]] --><p>实际工作中，我们还需要综合考虑各种因素。这些因素有关键字的长度、特点、分布、还有散列表的大小等。散列函数各式各样，我举几个常用的、简单的散列函数的设计方法，让你有个直观的感受。</p><p>第一个例子就是我们上一节的学生运动会的例子，我们通过分析参赛编号的特征，把编号中的后两位作为散列值。我们还可以用类似的散列函数处理手机号码，因为手机号码前几位重复的可能性很大，但是后面几位就比较随机，我们可以取手机号的后四位作为散列值。这种散列函数的设计方法，我们一般叫做“数据分析法”。</p><p>第二个例子就是上一节的开篇思考题，如何实现Word拼写检查功能。这里面的散列函数，我们就可以这样设计：将单词中每个字母的<a href=\"http://www.96yx.com/tool/ASC2.htm\">ASCll码</a><a href=\"http://www.96yx.com/tool/ASC2.htm\">值</a>“进位”相加，然后再跟散列表的大小求余、取模，作为散列值。比如，英文单词nice，我们转化出来的散列值就是下面这样：</p><pre><code>hash(&quot;nice&quot;)=((&quot;n&quot; - &quot;a&quot;) * 26*26*26 + (&quot;i&quot; - &quot;a&quot;)*26*26 + (&quot;c&quot; - &quot;a&quot;)*26+ (&quot;e&quot;-&quot;a&quot;)) / 78978\n</code></pre><p>实际上，散列函数的设计方法还有很多，比如直接寻址法、平方取中法、折叠法、随机数法等，这些你只要了解就行了，不需要全都掌握。</p><h2>装载因子过大了怎么办？</h2><p>我们上一节讲到散列表的装载因子的时候说过，装载因子越大，说明散列表中的元素越多，空闲位置越少，散列冲突的概率就越大。不仅插入数据的过程要多次寻址或者拉很长的链，查找的过程也会因此变得很慢。</p><p>对于没有频繁插入和删除的静态数据集合来说，我们很容易根据数据的特点、分布等，设计出完美的、极少冲突的散列函数，因为毕竟之前数据都是已知的。</p><p>对于动态散列表来说，数据集合是频繁变动的，我们事先无法预估将要加入的数据个数，所以我们也无法事先申请一个足够大的散列表。随着数据慢慢加入，装载因子就会慢慢变大。当装载因子大到一定程度之后，散列冲突就会变得不可接受。这个时候，我们该如何处理呢？</p><p>还记得我们前面多次讲的“动态扩容”吗？你可以回想一下，我们是如何做数组、栈、队列的动态扩容的。</p><p>针对散列表，当装载因子过大时，我们也可以进行动态扩容，重新申请一个更大的散列表，将数据搬移到这个新散列表中。假设每次扩容我们都申请一个原来散列表大小两倍的空间。如果原来散列表的装载因子是0.8，那经过扩容之后，新散列表的装载因子就下降为原来的一半，变成了0.4。</p><p>针对数组的扩容，数据搬移操作比较简单。但是，针对散列表的扩容，数据搬移操作要复杂很多。因为散列表的大小变了，数据的存储位置也变了，所以我们需要通过散列函数重新计算每个数据的存储位置。</p><p>你可以看我图里这个例子。在原来的散列表中，21这个元素原来存储在下标为0的位置，搬移到新的散列表中，存储在下标为7的位置。</p><p><img src=\"https://static001.geekbang.org/resource/image/67/43/67d12e07a7d673a9c1d14354ad029443.jpg?wh=1142*756\" alt=\"\"></p><p>对于支持动态扩容的散列表，插入操作的时间复杂度是多少呢？前面章节我已经多次分析过支持动态扩容的数组、栈等数据结构的时间复杂度了。所以，这里我就不啰嗦了，你要是还不清楚的话，可以回去复习一下。</p><p>插入一个数据，最好情况下，不需要扩容，最好时间复杂度是O(1)。最坏情况下，散列表装载因子过高，启动扩容，我们需要重新申请内存空间，重新计算哈希位置，并且搬移数据，所以时间复杂度是O(n)。用摊还分析法，均摊情况下，时间复杂度接近最好情况，就是O(1)。</p><p>实际上，对于动态散列表，随着数据的删除，散列表中的数据会越来越少，空闲空间会越来越多。如果我们对空间消耗非常敏感，我们可以在装载因子小于某个值之后，启动动态缩容。当然，如果我们更加在意执行效率，能够容忍多消耗一点内存空间，那就可以不用费劲来缩容了。</p><p>我们前面讲到，当散列表的装载因子超过某个阈值时，就需要进行扩容。装载因子阈值需要选择得当。如果太大，会导致冲突过多；如果太小，会导致内存浪费严重。</p><p>装载因子阈值的设置要权衡时间、空间复杂度。如果内存空间不紧张，对执行效率要求很高，可以降低负载因子的阈值；相反，如果内存空间紧张，对执行效率要求又不高，可以增加负载因子的值，甚至可以大于1。</p><h2>如何避免低效的扩容？</h2><p>我们刚刚分析得到，大部分情况下，动态扩容的散列表插入一个数据都很快，但是在特殊情况下，当装载因子已经到达阈值，需要先进行扩容，再插入数据。这个时候，插入数据就会变得很慢，甚至会无法接受。</p><p>我举一个极端的例子，如果散列表当前大小为1GB，要想扩容为原来的两倍大小，那就需要对1GB的数据重新计算哈希值，并且从原来的散列表搬移到新的散列表，听起来就很耗时，是不是？</p><p>如果我们的业务代码直接服务于用户，尽管大部分情况下，插入一个数据的操作都很快，但是，极个别非常慢的插入操作，也会让用户崩溃。这个时候，“一次性”扩容的机制就不合适了。</p><p>为了解决一次性扩容耗时过多的情况，我们可以将扩容操作穿插在插入操作的过程中，分批完成。当装载因子触达阈值之后，我们只申请新空间，但并不将老的数据搬移到新散列表中。</p><p>当有新数据要插入时，我们将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，我们都重复上面的过程。经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了。这样没有了集中的一次性数据搬移，插入操作就都变得很快了。</p><p><img src=\"https://static001.geekbang.org/resource/image/6d/cb/6d6736f986ec4b75dabc5472965fb9cb.jpg?wh=1142*769\" alt=\"\"></p><p>这期间的查询操作怎么来做呢？对于查询操作，为了兼容了新、老散列表中的数据，我们先从新散列表中查找，如果没有找到，再去老的散列表中查找。</p><p>通过这样均摊的方法，将一次性扩容的代价，均摊到多次插入操作中，就避免了一次性扩容耗时过多的情况。这种实现方式，任何情况下，插入一个数据的时间复杂度都是O(1)。</p><h2>如何选择冲突解决方法？</h2><p>上一节我们讲了两种主要的散列冲突的解决办法，开放寻址法和链表法。这两种冲突解决办法在实际的软件开发中都非常常用。比如，Java中LinkedHashMap就采用了链表法解决冲突，ThreadLocalMap是通过线性探测的开放寻址法来解决冲突。那你知道，这两种冲突解决方法各有什么优势和劣势，又各自适用哪些场景吗？</p><h3>1.开放寻址法</h3><p>我们先来看看，开放寻址法的优点有哪些。</p><p>开放寻址法不像链表法，需要拉很多链表。散列表中的数据都存储在数组中，可以有效地利用CPU缓存加快查询速度。而且，这种方法实现的散列表，序列化起来比较简单。链表法包含指针，序列化起来就没那么容易。你可不要小看序列化，很多场合都会用到的。我们后面就有一节会讲什么是数据结构序列化、如何序列化，以及为什么要序列化。</p><p>我们再来看下，开放寻址法有哪些缺点。</p><p>上一节我们讲到，用开放寻址法解决冲突的散列表，删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据。而且，在开放寻址法中，所有的数据都存储在一个数组中，比起链表法来说，冲突的代价更高。所以，使用开放寻址法解决冲突的散列表，装载因子的上限不能太大。这也导致这种方法比链表法更浪费内存空间。</p><p>所以，<strong>我总结一下，当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是Java中的<strong><strong>ThreadLocalMap</strong></strong>使用开放寻址法解决散列冲突的原因</strong>。</p><h3>2.链表法</h3><p>首先，链表法对内存的利用率比开放寻址法要高。因为链表结点可以在需要的时候再创建，并不需要像开放寻址法那样事先申请好。实际上，这一点也是我们前面讲过的链表优于数组的地方。</p><p>链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能适用装载因子小于1的情况。接近1时，就可能会有大量的散列冲突，导致大量的探测、再散列等，性能会下降很多。但是对于链表法来说，只要散列函数的值随机均匀，即便装载因子变成10，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多。</p><p>还记得我们之前在链表那一节讲的吗？链表因为要存储指针，所以对于比较小的对象的存储，是比较消耗内存的，还有可能会让内存的消耗翻倍。而且，因为链表中的结点是零散分布在内存中的，不是连续的，所以对CPU缓存是不友好的，这方面对于执行效率也有一定的影响。</p><p>当然，如果我们存储的是大对象，也就是说要存储的对象的大小远远大于一个指针的大小（4个字节或者8个字节），那链表中指针的内存消耗在大对象面前就可以忽略了。</p><p>实际上，我们对链表法稍加改造，可以实现一个更加高效的散列表。那就是，我们将链表法中的链表改造为其他高效的动态数据结构，比如跳表、红黑树。这样，即便出现散列冲突，极端情况下，所有的数据都散列到同一个桶内，那最终退化成的散列表的查找时间也只不过是O(logn)。这样也就有效避免了前面讲到的散列碰撞攻击。</p><p><img src=\"https://static001.geekbang.org/resource/image/10/29/103b84d7173277c5565607b413c40129.jpg?wh=1142*593\" alt=\"\"></p><p>所以，<strong>我总结一下，基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表</strong>。</p><h2>工业级散列表举例分析</h2><p>刚刚我讲了实现一个工业级散列表需要涉及的一些关键技术，现在，我就拿一个具体的例子，Java中的HashMap这样一个工业级的散列表，来具体看下，这些技术是怎么应用的。</p><h3>1.初始大小</h3><p>HashMap默认的初始大小是16，当然这个默认值是可以设置的，如果事先知道大概的数据量有多大，可以通过修改默认初始大小，减少动态扩容的次数，这样会大大提高HashMap的性能。</p><h3>2.装载因子和动态扩容</h3><p>最大装载因子默认是0.75，当HashMap中元素个数超过0.75*capacity（capacity表示散列表的容量）的时候，就会启动扩容，每次扩容都会扩容为原来的两倍大小。</p><h3>3.散列冲突解决方法</h3><p>HashMap底层采用链表法来解决冲突。即使负载因子和散列函数设计得再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。</p><p>于是，在JDK1.8版本中，为了对HashMap做进一步优化，我们引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树。我们可以利用红黑树快速增删改查的特点，提高HashMap的性能。当红黑树结点个数少于8个的时候，又会将红黑树转化为链表。因为在数据量较小的情况下，红黑树要维护平衡，比起链表来，性能上的优势并不明显。</p><h3>4.散列函数</h3><p>散列函数的设计并不复杂，追求的是简单高效、分布均匀。我把它摘抄出来，你可以看看。</p><pre><code>int hash(Object key) {\n    int h = key.hashCode()；\n    return (h ^ (h &gt;&gt;&gt; 16)) &amp; (capicity -1); //capicity表示散列表的大小\n}\n</code></pre><p>其中，hashCode()返回的是Java对象的hash code。比如String类型的对象的hashCode()就是下面这样：</p><pre><code>public int hashCode() {\n  int var1 = this.hash;\n  if(var1 == 0 &amp;&amp; this.value.length &gt; 0) {\n    char[] var2 = this.value;\n    for(int var3 = 0; var3 &lt; this.value.length; ++var3) {\n      var1 = 31 * var1 + var2[var3];\n    }\n    this.hash = var1;\n  }\n  return var1;\n}\n</code></pre><h2>解答开篇</h2><p>今天的内容就讲完了，我现在来分析一下开篇的问题：如何设计一个工业级的散列函数？如果这是一道面试题或者是摆在你面前的实际开发问题，你会从哪几个方面思考呢？</p><p>首先，我会思考，<strong>何为一个工业级的散列表？工业级的散列表<strong><strong>应该</strong></strong>具有哪些特性？</strong></p><p>结合已经学习过的散列知识，我觉得应该有这样几点要求：</p><ul>\n<li>\n<p>支持快速地查询、插入、删除操作；</p>\n</li>\n<li>\n<p>内存占用合理，不能浪费过多的内存空间；</p>\n</li>\n<li>\n<p>性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况。</p>\n</li>\n</ul><p><strong>如何实现这样一个散列表呢？</strong>根据前面讲到的知识，我会从这三个方面来考虑设计思路：</p><ul>\n<li>\n<p>设计一个合适的散列函数；</p>\n</li>\n<li>\n<p>定义装载因子阈值，并且设计动态扩容策略；</p>\n</li>\n<li>\n<p>选择合适的散列冲突解决方法。</p>\n</li>\n</ul><p>关于散列函数、装载因子、动态扩容策略，还有散列冲突的解决办法，我们前面都讲过了，具体如何选择，还要结合具体的业务场景、具体的业务数据来具体分析。不过只要我们朝这三个方向努力，就离设计出工业级的散列表不远了。</p><h2>内容小结</h2><p>上一节的内容比较偏理论，今天的内容侧重实战。我主要讲了如何设计一个工业级的散列表，以及如何应对各种异常情况，防止在极端情况下，散列表的性能退化过于严重。我分了三部分来讲解这些内容，分别是：如何设计散列函数，如何根据装载因子动态扩容，以及如何选择散列冲突解决方法。</p><p>关于散列函数的设计，我们要尽可能让散列后的值随机且均匀分布，这样会尽可能地减少散列冲突，即便冲突之后，分配到每个槽内的数据也比较均匀。除此之外，散列函数的设计也不能太复杂，太复杂就会太耗时间，也会影响散列表的性能。</p><p>关于散列冲突解决方法的选择，我对比了开放寻址法和链表法两种方法的优劣和适应的场景。大部分情况下，链表法更加普适。而且，我们还可以通过将链表法中的链表改造成其他动态查找数据结构，比如红黑树，来避免散列表时间复杂度退化成O(n)，抵御散列碰撞攻击。但是，对于小规模数据、装载因子不高的散列表，比较适合用开放寻址法。</p><p>对于动态散列表来说，不管我们如何设计散列函数，选择什么样的散列冲突解决方法。随着数据的不断增加，散列表总会出现装载因子过高的情况。这个时候，我们就需要启动动态扩容。</p><h2>课后思考</h2><p>在你熟悉的编程语言中，哪些数据类型底层是基于散列表实现的？散列函数是如何设计的？散列冲突是通过哪种方法解决的？是否支持动态扩容呢？</p><p>欢迎留言和我分享，我会第一时间给你反馈。</p>","neighbors":{"left":{"article_title":"18 | 散列表（上）：Word文档中的单词拼写检查功能是如何实现的？","id":64233},"right":{"article_title":"20 | 散列表（下）：为什么散列表和链表经常会一起使用？","id":64858}},"comments":[{"had_liked":true,"id":36731,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1541293647,"is_pvip":false,"replies":[{"id":"13097","content":"👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541383242,"ip_address":"","comment_id":36731,"utype":1}],"discussion_count":31,"race_medal":0,"score":"3166932190799","product_id":100017301,"comment_content":"int hash(Object key) {<br>    int h = key.hashCode()；<br>    return (h ^ (h &gt;&gt;&gt; 16)) &amp; (capitity -1); &#47;&#47;capicity 表示散列表的大小<br>}<br><br>先补充下老师使用的这段代码的一些问题：在JDK HashMap源码中，是分两步走的：<br>1. hash值的计算，源码如下：<br>static final int hash(Object key) {<br>        int hash;<br>        return key == null ? 0 : (hash = key.hashCode()) ^ hash &gt;&gt;&gt; 16;<br> }<br><br>2. 在插入或查找的时候，计算Key被映射到桶的位置：<br>int index = hash(key) &amp; (capacity - 1)<br><br>----------------------------<br>JDK HashMap中hash函数的设计，确实很巧妙：<br><br>首先hashcode本身是个32位整型值，在系统中，这个值对于不同的对象必须保证唯一（JAVA规范），这也是大家常说的，重写equals必须重写hashcode的重要原因。<br><br>获取对象的hashcode以后，先进行移位运算，然后再和自己做异或运算，即：hashcode ^ (hashcode &gt;&gt;&gt; 16)，这一步甚是巧妙，是将高16位移到低16位，这样计算出来的整型值将“具有”高位和低位的性质<br><br>最后，用hash表当前的容量减去一，再和刚刚计算出来的整型值做位与运算。进行位与运算，很好理解，是为了计算出数组中的位置。但这里有个问题：<br>为什么要用容量减去一？<br>因为  A % B = A &amp; (B - 1)，所以，(h ^ (h &gt;&gt;&gt; 16)) &amp; (capitity -1) = (h ^ (h &gt;&gt;&gt; 16)) % capitity，可以看出这里本质上是使用了「除留余数法」<br><br>综上，可以看出，hashcode的随机性，加上移位异或算法，得到一个非常随机的hash值，再通过「除留余数法」，得到index，整体的设计过程与老师所说的“散列函数”设计原则非常吻合！<br><br>---------<br>有分析不准确的地方，请指正！","like_count":737,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427985,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541383242,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1257210,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2e/fa/420c0932.jpg","nickname":"李杰","note":"","ucode":"4158EEAC790135","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324407,"discussion_content":"因为 A % B = A &amp; (B - 1) , 这个是需要条件的吧, B = 2^n, hashMap的size是2的n次方, 所以可以 A &amp; (B-1)","likes_number":37,"is_delete":false,"is_hidden":false,"ctime":1605100125,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1388799,"avatar":"https://static001.geekbang.org/account/avatar/00/15/30/ff/b3e54147.jpg","nickname":"雨幕下的稻田","note":"","ucode":"1FBFF3187AE9C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":395,"discussion_content":"A % B = A &amp; (B - 1)，这个公式只在B是2的n次方时才可以吧","likes_number":21,"is_delete":false,"is_hidden":false,"ctime":1561531417,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1136529,"avatar":"https://static001.geekbang.org/account/avatar/00/11/57/91/3a082914.jpg","nickname":"葡萄有点酸","note":"","ucode":"51C3CE1E685D8E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1388799,"avatar":"https://static001.geekbang.org/account/avatar/00/15/30/ff/b3e54147.jpg","nickname":"雨幕下的稻田","note":"","ucode":"1FBFF3187AE9C4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1139,"discussion_content":"是的，这个公式只有当B为2的幂次方时才有效，所以HashMap中的容量要求必须是2的幂次方。","likes_number":21,"is_delete":false,"is_hidden":false,"ctime":1562321276,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":395,"ip_address":""},"score":1139,"extra":""},{"author":{"id":1008404,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","nickname":"Jerry银银","note":"","ucode":"80DA1172A2360A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1388799,"avatar":"https://static001.geekbang.org/account/avatar/00/15/30/ff/b3e54147.jpg","nickname":"雨幕下的稻田","note":"","ucode":"1FBFF3187AE9C4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":29641,"discussion_content":"是的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1570777406,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":395,"ip_address":""},"score":29641,"extra":""}]},{"author":{"id":2184481,"avatar":"","nickname":"Geek_524379","note":"","ucode":"778358DA65A50A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310973,"discussion_content":"不同对象保持唯一不瞎扯吗，那还冲突啥呢","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1602162348,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1227107,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b9/63/a3b11794.jpg","nickname":"麦抠","note":"","ucode":"875DEA26F38BAB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2184481,"avatar":"","nickname":"Geek_524379","note":"","ucode":"778358DA65A50A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336043,"discussion_content":"整栋楼只有你一个说出了这个问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608462200,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":310973,"ip_address":""},"score":336043,"extra":""},{"author":{"id":1322362,"avatar":"https://static001.geekbang.org/account/avatar/00/14/2d/7a/3a37efe4.jpg","nickname":"金霖","note":"","ucode":"8CFE41BEEB5EF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2184481,"avatar":"","nickname":"Geek_524379","note":"","ucode":"778358DA65A50A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587323,"discussion_content":"上下文里的唯一，指的是对象的 hashCode 值，而不是指这个 hashTable 所使用的hash 算法的结果。\n这个hashTable所使用的 hash 算法值，实际上是 hashCode 值进行高低位混合后取低位%数组长度(数组下标)。\n也就是说不同对象的hashCode无冲突，得到的 hash 算法结果也可能是同一个值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662975958,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":310973,"ip_address":"北京"},"score":587323,"extra":""},{"author":{"id":1322362,"avatar":"https://static001.geekbang.org/account/avatar/00/14/2d/7a/3a37efe4.jpg","nickname":"金霖","note":"","ucode":"8CFE41BEEB5EF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2184481,"avatar":"","nickname":"Geek_524379","note":"","ucode":"778358DA65A50A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587325,"discussion_content":"我上边的表述也不对，这个回答里的唯一指的是object 默认的hashCode 值唯一。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662976231,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":310973,"ip_address":"北京"},"score":587325,"extra":""}]},{"author":{"id":1639787,"avatar":"https://static001.geekbang.org/account/avatar/00/19/05/6b/d9d6d68b.jpg","nickname":"Vettel","note":"","ucode":"FB3E71DD1E8E7C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55994,"discussion_content":"当时读源码就奇怪为啥要特地写个计算2的次幂的函数来限定HashMap的容量，读到下面就发现了hash&amp;(n-1)来代替取余操作的妙处","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1574421095,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1639787,"avatar":"https://static001.geekbang.org/account/avatar/00/19/05/6b/d9d6d68b.jpg","nickname":"Vettel","note":"","ucode":"FB3E71DD1E8E7C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72569,"discussion_content":"扩容的时候，还有和旧长度的与运算，那个更巧妙，扩大两倍，新长度与hash值是0就在旧的桶里，否则就在新的桶里。1.8版本的jdk","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1575505819,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":55994,"ip_address":""},"score":72569,"extra":""},{"author":{"id":1215892,"avatar":"https://static001.geekbang.org/account/avatar/00/12/8d/94/150dfe78.jpg","nickname":"GGL","note":"","ucode":"AED10B8248D1E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":276430,"discussion_content":"结合JDK1.8源码看了下，确实巧妙，用swift对照着实现了一下，大家可以看下源码：\nhttps://github.com/gl-lei/algorithm/blob/master/HashTable/HashTable.swift","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590871330,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":72569,"ip_address":""},"score":276430,"extra":""},{"author":{"id":1082000,"avatar":"https://static001.geekbang.org/account/avatar/00/10/82/90/e4a08b0e.jpg","nickname":"KangShan","note":"","ucode":"07497A7AC92238","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1639787,"avatar":"https://static001.geekbang.org/account/avatar/00/19/05/6b/d9d6d68b.jpg","nickname":"Vettel","note":"","ucode":"FB3E71DD1E8E7C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289197,"discussion_content":"是的，这是  A % B = A &amp; (B - 1) 等式成立的关键，上面评论主并没有说出来","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1594022963,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":55994,"ip_address":""},"score":289197,"extra":""}]},{"author":{"id":1690476,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKFRiaFrpOTVBuKicMficasBFuF2VY7EnUnLeFcvIn0R5OiaQsOcpJHNM5TusoPHMjIvSfia46c0EWH9mQ/132","nickname":"Geek_949cc1","note":"","ucode":"F8ACDBF2FA8CC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53480,"discussion_content":"虽然我看不怎么懂，但是我感觉A%B=A&amp;(B-1)有点不对呀，比如1%3=1，但是1&amp;2的话是不是等于0呀","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1574171426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1042753,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/p6kkT7nsViayxazIrxx7p0pklPRvet933nEGBupj1phL2zArLStC3MnHFFyBYZ9fDGbPWJxS6WOICkxCCLia7nhw/132","nickname":"Qfxl","note":"","ucode":"4554F28BB10F21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1690476,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKFRiaFrpOTVBuKicMficasBFuF2VY7EnUnLeFcvIn0R5OiaQsOcpJHNM5TusoPHMjIvSfia46c0EWH9mQ/132","nickname":"Geek_949cc1","note":"","ucode":"F8ACDBF2FA8CC2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":83587,"discussion_content":"2的幂次方","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1576447988,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53480,"ip_address":""},"score":83587,"extra":""},{"author":{"id":1605189,"avatar":"https://static001.geekbang.org/account/avatar/00/18/7e/45/6866b402.jpg","nickname":"Nothing Holdin＇ Me Back","note":"","ucode":"2D3A2B4E5CFB36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1690476,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKFRiaFrpOTVBuKicMficasBFuF2VY7EnUnLeFcvIn0R5OiaQsOcpJHNM5TusoPHMjIvSfia46c0EWH9mQ/132","nickname":"Geek_949cc1","note":"","ucode":"F8ACDBF2FA8CC2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308877,"discussion_content":"楼主这点没说出来   B必须位2的n次幂  这个等式才成立  这就是为什么HashMap的默认容量总会设置位2的n次幂（即使你自定义了默认容量也会帮你矫正）","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1601107114,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53480,"ip_address":""},"score":308877,"extra":""}]},{"author":{"id":2058415,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/68/af/585d1e3d.jpg","nickname":"醉枕代码","note":"","ucode":"F2801787026F2B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306187,"discussion_content":"高低位异或保证了在低位相同时，保留高位的特征！但如果高位相同，低位不同是不是能理解成异或让他失去特征，感觉还是想通过扰动函数避免等比数列这种有规则数据","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1600216197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1784663,"avatar":"","nickname":"123456","note":"","ucode":"355D6E9F4179BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296322,"discussion_content":"首先hashcode本身是个32位整型值，在系统中，这个值对于不同的对象必须保证唯一\n这句话感觉是有问题的，比如 String data=&#34;12&#34;;String data1=new String(&#34;12&#34;);这两个调用的hashCode()是一样的值（源码计算方式也很明显），但不是同一个对象","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1596510845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1048286,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fe/de/2019f370.jpg","nickname":"jony","note":"","ucode":"80765A6B9ABA0D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3227,"discussion_content":"是这么个情况，这也是hashmap数组大小必须是2的幂次方情况下设计者想出的非常巧妙的方法。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1564322277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1675882,"avatar":"https://static001.geekbang.org/account/avatar/00/19/92/6a/dd37a054.jpg","nickname":"张y .","note":"","ucode":"85918469492F4C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306319,"discussion_content":"借楼，想问个问题，hashmap的resize也没在插入的时候一步一步从旧的往新的搬啊，哪像文中提到的数据量大的时候触发扩容，旧数组往新数组迁移，后续的插入操作会变慢吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600246446,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1064752,"avatar":"","nickname":"码农翻身的小粉丝","note":"","ucode":"1FB018F749CE84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1675882,"avatar":"https://static001.geekbang.org/account/avatar/00/19/92/6a/dd37a054.jpg","nickname":"张y .","note":"","ucode":"85918469492F4C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308354,"discussion_content":"Redis扩容时这样做了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600927293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":306319,"ip_address":""},"score":308354,"extra":""}]},{"author":{"id":1207302,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6c/06/2ac17d5a.jpg","nickname":"yuan","note":"","ucode":"EA3D0573478EC7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":194148,"discussion_content":"首先hashcode本身是个32位整型值，在系统中，这个值对于不同的对象必须保证唯一（JAVA规范），这也是大家常说的，重写equals必须重写hashcode的重要原因。\n——————————————————————\n为什么hashcode必须保证唯一，所以重写euqals就必须重写hashcode方法？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583196015,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1008404,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","nickname":"Jerry银银","note":"","ucode":"80DA1172A2360A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1207302,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6c/06/2ac17d5a.jpg","nickname":"yuan","note":"","ucode":"EA3D0573478EC7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":198918,"discussion_content":"这两个问题，可以自己研究下哦！主要是无法一两句话阐述清楚。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583542897,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":194148,"ip_address":""},"score":198918,"extra":""},{"author":{"id":1809092,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9a/c4/7c49255a.jpg","nickname":"木对林三","note":"","ucode":"D31B48BB93D24B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1207302,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6c/06/2ac17d5a.jpg","nickname":"yuan","note":"","ucode":"EA3D0573478EC7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":216436,"discussion_content":"假设不唯一，那么相同（equals）对象就有2个hash值。在将元素插入到hash表时，先判断数组对应的hash值使用已经有了元素，结果因为不唯一导致一个对象被插入了两次，也就是认为2个对象不相同。这就与假设矛盾，所以同一对象（相同对象equals）必须具有相同的hash值，也就是重写equals方式必须重写hashcode方法。\n以上是我的思考。如果有问题还请多多批评。","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1585450669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":194148,"ip_address":""},"score":216436,"extra":""},{"author":{"id":1066928,"avatar":"https://static001.geekbang.org/account/avatar/00/10/47/b0/a9b77a1e.jpg","nickname":"冬风向左吹","note":"","ucode":"376C45C5134F93","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1008404,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","nickname":"Jerry银银","note":"","ucode":"80DA1172A2360A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318185,"discussion_content":"应该是重写hashcode的时候必须要重写equals吧，当hashcode冲突的时候，再通过equels比较对象是否相同。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1603673854,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":198918,"ip_address":""},"score":318185,"extra":""}]},{"author":{"id":1243570,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f9/b2/2ed800b4.jpg","nickname":"社会你强哥","note":"","ucode":"325B9005588D9B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":157976,"discussion_content":"厉害👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580538228,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1008404,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","nickname":"Jerry银银","note":"","ucode":"80DA1172A2360A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1243570,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f9/b2/2ed800b4.jpg","nickname":"社会你强哥","note":"","ucode":"325B9005588D9B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":162013,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580952724,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":157976,"ip_address":""},"score":162013,"extra":""}]},{"author":{"id":1557453,"avatar":"https://static001.geekbang.org/account/avatar/00/17/c3/cd/9a1397bd.jpg","nickname":"半壶浊酒","note":"","ucode":"28505DE98AA64A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87312,"discussion_content":"厉害了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576660723,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1448357,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIXC2byoG7GJOPSuPbYv5XPzcaFXGBN6ictvNEEXWalB40zW8YicageDTQUryQ6968276gsRl1A20zA/132","nickname":"lg2018","note":"","ucode":"F40F4975E15805","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42765,"discussion_content":"大佬，你贴的源码是jdk 的哪个版本？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572774828,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1260500,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3b/d4/e4bfb25f.jpg","nickname":"ITACHI","note":"","ucode":"4EE419128ED9E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":9465,"discussion_content":"受教了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568170789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57606,"user_name":"Flash","can_delete":false,"product_type":"c1","uid":1236163,"ip_address":"","ucode":"E285075C9E0B02","user_header":"https://static001.geekbang.org/account/avatar/00/12/dc/c3/e4ba51d5.jpg","comment_is_top":false,"comment_ctime":1546846861,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"1358756512397","product_id":100017301,"comment_content":"经过一番资料查阅理解之后，说说我的理解：<br>JDK hashMap源码，hash表中数组位置的计算分两步：<br>1.计算hash值：<br> hash(Object key) {<br>        int h;<br>        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);<br>}<br>这一步有一种说法，叫它扰动函数，为什么要右移16位再与本身异或呢？<br>1.1 首先hashCode()返回值int最高是32位，如果直接拿hashCode()返回值作为下标，大概40亿的映射空间，只要哈希函数映射得比较均匀松散，一般是很难出现碰撞的。<br>问题是一个40亿长度的数组，内存是放不下的。<br>1.2 所以，用自己的高半区和低半区做异或，混合原始哈希码的高位和低位，关键是以此来加大低位的随机性。为后续计算index截取低位，保证低位的随机性。<br>1.3 这样设计保证了对象的hashCode的32位值只要有一位发生改变，整个hash()返回值就会改变，高位的变化会反应到低位里，保证了hash值的随机性。<br><br>2.在插入或查找的时候，计算Key被映射到桶的位置：<br>int index = hash(key) &amp; (capacity - 1)<br>hash()扰动函数计算的值和hash表当前的容量减一，做按位与运算。<br>这一步，为什么要减一，又为什么要按位与运算？<br>因为A % B = A &amp; (B - 1)，当B是2的指数时，等式成立。<br>本质上是使用了「除留余数法」，保证了index的位置分布均匀。<br><br>为什么HashMap的数组长度必须是2的整次幂？<br>数组长度是2的整次幂时，（数组长度-1）正好相当于一个**“低位掩码”**，“与”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。<br><br>以初始长度16为例，16-1=15。2进制表示是00000000 00000000 00001111。“与”操作的结果就是截取了最低的四位值。也就相当于取模操作。","like_count":316,"discussions":[{"author":{"id":1260500,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3b/d4/e4bfb25f.jpg","nickname":"ITACHI","note":"","ucode":"4EE419128ED9E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":9467,"discussion_content":"受教了，和Jerry银银的评论一起看，基本就理解了","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1568170827,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181055,"avatar":"https://static001.geekbang.org/account/avatar/00/12/05/7f/d35ab9a1.jpg","nickname":"z.l","note":"","ucode":"805CC5784D3F76","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5405,"discussion_content":"\b长度必须是2的整次幂还有一个原因，(capacity - 1)一定全是1组成，hash(key) &amp; (capacity - 1)与操作之后，保证每一位都可能是0或者1，减小了hash冲突的概率","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1566229708,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318047,"discussion_content":"受教了。混合原始哈希码的高位和低位，关键是以此来加大低位的随机性。为后续计算index截取低位，保证低位的随机性。32位值只要有一位发生改变，整个hash()返回值就会改变，高位的变化会反应到低位里，保证了hash值的随机性。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1603632890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1246531,"avatar":"https://static001.geekbang.org/account/avatar/00/13/05/43/baac3bbb.jpg","nickname":"EyesOnMe","note":"","ucode":"981482EA89DC02","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573445,"discussion_content":"tql","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653437157,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1056955,"avatar":"https://static001.geekbang.org/account/avatar/00/10/20/bb/f8b40882.jpg","nickname":"Anthony","note":"","ucode":"B0BF17E3EE35E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284937,"discussion_content":"解惑了。🤓","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592673694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1972505,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/19/19/d82e24fb.jpg","nickname":"李润东","note":"","ucode":"65CFEA3C8B27C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":258881,"discussion_content":"这个异或的目的分析的很好，受教了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588736558,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121677,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/8d/9717e593.jpg","nickname":"一枝梅","note":"","ucode":"7DCE43B638EA6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4245,"discussion_content":"最后一句是不是应该是“也就相当于取余操作。”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565249937,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1236163,"avatar":"https://static001.geekbang.org/account/avatar/00/12/dc/c3/e4ba51d5.jpg","nickname":"Flash","note":"","ucode":"E285075C9E0B02","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1121677,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/8d/9717e593.jpg","nickname":"一枝梅","note":"","ucode":"7DCE43B638EA6A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":14263,"discussion_content":"是一个意思，说法不一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568733513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4245,"ip_address":""},"score":14263,"extra":""}]}]},{"had_liked":false,"id":39715,"user_name":"SCu","can_delete":false,"product_type":"c1","uid":1065702,"ip_address":"","ucode":"DB92BA038B72DC","user_header":"https://static001.geekbang.org/account/avatar/00/10/42/e6/0bce5aca.jpg","comment_is_top":false,"comment_ctime":1542340468,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"426744102772","product_id":100017301,"comment_content":"可能会有同学对那个mod （capacity-1）有疑问 这个很正常，因为缺少前置描述条件 即当且仅当 capacity是2的整数倍的时候该公式才成立 当capacity为2的整数倍时（无符号）仅有一位是1其余位为0 减1后 后续为为1当前位为0 做与运算等于取后面的所有位的值 比如capacity=8 即00001000 减1为00000111 如has code=5 即00000101 此时5%8=00000101&amp;00000111=00000101=5 其他大家举一反三即可","like_count":99,"discussions":[{"author":{"id":1260500,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3b/d4/e4bfb25f.jpg","nickname":"ITACHI","note":"","ucode":"4EE419128ED9E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":9458,"discussion_content":"是整数次幂吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568170484,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1472051,"avatar":"https://static001.geekbang.org/account/avatar/00/16/76/33/928ffd21.jpg","nickname":"AlexS","note":"","ucode":"3DA81A613CE645","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1260500,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3b/d4/e4bfb25f.jpg","nickname":"ITACHI","note":"","ucode":"4EE419128ED9E8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38238,"discussion_content":"你嗦得嘚","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571749302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":9458,"ip_address":""},"score":38238,"extra":""}]}]},{"had_liked":false,"id":36457,"user_name":"拉欧","can_delete":false,"product_type":"c1","uid":1206605,"ip_address":"","ucode":"40996A8093A95F","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/4d/81c44f45.jpg","comment_is_top":false,"comment_ctime":1541120593,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"379498242641","product_id":100017301,"comment_content":"比如Redis中的hash,set,hset,都是散列表实现，他们的动态扩容策略是同时维护两个散列表，然后一点点搬移数据","like_count":88,"discussions":[{"author":{"id":1236765,"avatar":"https://static001.geekbang.org/account/avatar/00/12/df/1d/038853e5.jpg","nickname":"Yong","note":"","ucode":"154CD23B5ACC67","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6902,"discussion_content":"惰性迁移。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1567166029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1629094,"avatar":"https://static001.geekbang.org/account/avatar/00/18/db/a6/60bf0220.jpg","nickname":"背道而驰","note":"","ucode":"953CFFE377E176","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":141529,"discussion_content":"渐进式迁移 \n","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1579429404,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2249227,"avatar":"https://static001.geekbang.org/account/avatar/00/22/52/0b/50bf0f05.jpg","nickname":"橙子橙","note":"","ucode":"CD51367A14D955","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":322483,"discussion_content":"自身的db key也是hash中存的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604753520,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1003590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/50/46/6d316dc8.jpg","nickname":"Mich","note":"","ucode":"FCCA355F5D2ACC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":264748,"discussion_content":"hset？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589346187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36446,"user_name":"天王","can_delete":false,"product_type":"c1","uid":1239337,"ip_address":"","ucode":"C074B2F9A5F007","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/29/629d9bb0.jpg","comment_is_top":false,"comment_ctime":1541119100,"is_pvip":false,"replies":[{"id":"12959","content":"是个好建议 我考虑下","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541124331,"ip_address":"","comment_id":36446,"utype":1}],"discussion_count":1,"race_medal":0,"score":"332253600892","product_id":100017301,"comment_content":"能否每节讲完都有个代码的demo?","like_count":77,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427866,"discussion_content":"是个好建议 我考虑下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541124331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36634,"user_name":"姜威","can_delete":false,"product_type":"c1","uid":1244051,"ip_address":"","ucode":"C58EB9A5AD634D","user_header":"https://static001.geekbang.org/account/avatar/00/12/fb/93/f19a5364.jpg","comment_is_top":false,"comment_ctime":1541210178,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"297893953602","product_id":100017301,"comment_content":"总结：散列表（中）<br>面试题目：如何设计一个工业级的散列函数？<br>思路：<br>何为一个工业级的散列表？工业级的散列表应该具有哪些特性？结合学过的知识，我觉的应该有这样的要求：<br>1.支持快速的查询、插入、删除操作；<br>2.内存占用合理，不能浪费过多空间；<br>3.性能稳定，在极端情况下，散列表的性能也不会退化到无法接受的情况。<br>方案：<br>如何设计这样一个散列表呢？根据前面讲到的知识，我会从3个方面来考虑设计思路：<br>1.设计一个合适的散列函数；<br>2.定义装载因子阈值，并且设计动态扩容策略；<br>3.选择合适的散列冲突解决方法。<br>知识总结：<br>一、如何设计散列函数？<br>1.要尽可能让散列后的值随机且均匀分布，这样会尽可能减少散列冲突，即便冲突之后，分配到每个槽内的数据也比较均匀。<br>2.除此之外，散列函数的设计也不能太复杂，太复杂就会太耗时间，也会影响到散列表的性能。<br>3.常见的散列函数设计方法：直接寻址法、平方取中法、折叠法、随机数法等。<br>二、如何根据装载因子动态扩容？<br>1.如何设置装载因子阈值？<br>①可以通过设置装载因子的阈值来控制是扩容还是缩容，支持动态扩容的散列表，插入数据的时间复杂度使用摊还分析法。<br>②装载因子的阈值设置需要权衡时间复杂度和空间复杂度。如何权衡？如果内存空间不紧张，对执行效率要求很高，可以降低装载因子的阈值；相反，如果内存空间紧张，对执行效率要求又不高，可以增加装载因子的阈值。<br>2.如何避免低效扩容？分批扩容<br>①分批扩容的插入操作：当有新数据要插入时，我们将数据插入新的散列表，并且从老的散列表中拿出一个数据放入新散列表。每次插入都重复上面的过程。这样插入操作就变得很快了。<br>②分批扩容的查询操作：先查新散列表，再查老散列表。<br>③通过分批扩容的方式，任何情况下，插入一个数据的时间复杂度都是O(1)。<br>三、如何选择散列冲突解决方法？<br>①常见的2中方法：开放寻址法和链表法。<br>②大部分情况下，链表法更加普适。而且，我们还可以通过将链表法中的链表改造成其他动态查找数据结构，比如红黑树、跳表，来避免散列表时间复杂度退化成O(n)，抵御散列冲突攻击。<br>③但是，对于小规模数据、装载因子不高的散列表，比较适合用开放寻址法。","like_count":70,"discussions":[{"author":{"id":1439568,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f7/50/cbfe1bc0.jpg","nickname":",","note":"","ucode":"191431A878D7B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296384,"discussion_content":"课代表好！","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1596529324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36423,"user_name":"","can_delete":false,"product_type":"c1","uid":1031328,"ip_address":"","ucode":"1B73BA45ACD06C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bc/a0/97c7679b.jpg","comment_is_top":false,"comment_ctime":1541116212,"is_pvip":false,"replies":[{"id":"12960","content":"我后面还打算把所有的课后题集中写一写答案 那个时候会具体分析题目对应的就解决思路","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541124452,"ip_address":"","comment_id":36423,"utype":1}],"discussion_count":1,"race_medal":0,"score":"169044840756","product_id":100017301,"comment_content":"老师能不能就具体的题，讲讲数据结构呀。这种高大上的，对我来说有点难😔","like_count":39,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427856,"discussion_content":"我后面还打算把所有的课后题集中写一写答案 那个时候会具体分析题目对应的就解决思路","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541124452,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36922,"user_name":"w1sl1y","can_delete":false,"product_type":"c1","uid":1270958,"ip_address":"","ucode":"915073A14B17AB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erBkHFLUBpftqQlK5brd3EDaQFaEfYLfc9iaQrDNJv4eHeSRnSgE5vKnSibJvjUb5hJx5r5nOwa2bRw/132","comment_is_top":false,"comment_ctime":1541389323,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"138980342795","product_id":100017301,"comment_content":"看了下，的确是TREEFY_THRESHOLD等于8<br>UNTREEFY_THRESHOLD等于6","like_count":32,"discussions":[{"author":{"id":1346215,"avatar":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","nickname":"William","note":"","ucode":"55F5D9DEE485B1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":85495,"discussion_content":"嗯 达到8个 红黑树 , 回退到6个,则转为链表","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576549920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305957,"discussion_content":"看源码即可，写的很清楚，链表合适的区间是6以内，可以思考下为啥是在8，链表赚到的红黑树，8这个有什么含义吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600137293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1796438,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/zlWt0lPDicdib5BTUbuwA3wLLUuejtZ5icGu3DHMBPd6PicXOdhZ3zYFts8VkXjjyQuxzUJas2w5OTmx3icWKiaZM1Vg/132","nickname":"youyou.L","note":"","ucode":"B3DB0D0700EEAC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308824,"discussion_content":"之所以回退链表不是7的原因，是为了减少节点在7和8之间变化时链表和红黑树频繁转换造成消耗","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1601090690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":305957,"ip_address":""},"score":308824,"extra":""}]},{"author":{"id":1704828,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/03/7c/87cc51c7.jpg","nickname":"HelloWorld","note":"","ucode":"5F01EAF21BA301","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302278,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598865569,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129288,"user_name":"angel😇txy🤓","can_delete":false,"product_type":"c1","uid":1133702,"ip_address":"","ucode":"C0AEE0D8BAF7ED","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/86/3be94807.jpg","comment_is_top":false,"comment_ctime":1567080373,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"117531197365","product_id":100017301,"comment_content":"我来谈谈为何hashmap每次扩容试都要扩两倍，resize()时为何每次要扩两倍？<br>计算桶位置，i = (n - 1) &amp; hash，n 为2的幂时，(n-1) &amp; hash = hash % n, 相当于对length求模，位运算效率更高。<br>rehash时需要重新计算桶位置，如果不是2的幂，n -1转为二进制后，最低位始终是0，导致最低位为0的桶被浪费，造成更多的hash碰撞。<br>如果length不为2的幂，比如15。那么length-1的2进制就会变成1110。在h为随机数的情况下，和1110做&amp;操作。尾数永远为0。那么0001、1001、1101等尾数为1的位置就永远不可能被entry占用。这样会造成浪费，不随机等问题。 length-1 二进制中为1的位数越多，那么分布就平均。<br>所以HashMap的初始容量是2的n次幂，扩容也是2倍的形式，元素均匀分布在HashMap中的数组上，减少hash碰撞，避免形成链表的结构，使得查询效率降低！","like_count":27,"discussions":[{"author":{"id":2459923,"avatar":"https://static001.geekbang.org/account/avatar/00/25/89/13/0d3c5008.jpg","nickname":"最好不过","note":"","ucode":"C7DBCD08402DF8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377889,"discussion_content":"这里表述有个小小的问题，“如果不是2的幂，n -1转为二进制后，最低位始终是0”，其实2的倍数不是2的幂比如10，10-1=9转为二进制之后最低位其实也能是1；只不过2的幂能保证位运算的结果和除留余数法的结果一致，而且每次2倍扩容能够一直保证是2的幂（2倍的扩容也相当于向左位运算移动一位）","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1622948163,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":39819,"user_name":"kakasi","can_delete":false,"product_type":"c1","uid":1237297,"ip_address":"","ucode":"64F357E6A08CA5","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/31/eb103bdc.jpg","comment_is_top":false,"comment_ctime":1542361108,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"117506478100","product_id":100017301,"comment_content":"对于回答点赞第一的 @Jerry银银 有疑问：首先hashcode本身是个32位整型值，在系统中，这个值对于不同的对象必须保证唯一（JAVA规范），这也是大家常说的，重写equals必须重写hashcode的重要原因。<br>hashcode不一定是唯一的，重写equals必须重写hashcode的原因是：java中有很多集合类是基于散列工作的，如果不重写hashcode， 两只值相等的对象就无法相等，因为object的hashcode是32位内存地址。","like_count":27,"discussions":[{"author":{"id":1638878,"avatar":"https://static001.geekbang.org/account/avatar/00/19/01/de/bf524817.jpg","nickname":"慌张而黑糖","note":"","ucode":"B4416885A301C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":203678,"discussion_content":"那反过来说重写hashcode也必须重写equals是不是也对","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1584064821,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1605189,"avatar":"https://static001.geekbang.org/account/avatar/00/18/7e/45/6866b402.jpg","nickname":"Nothing Holdin＇ Me Back","note":"","ucode":"2D3A2B4E5CFB36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1638878,"avatar":"https://static001.geekbang.org/account/avatar/00/19/01/de/bf524817.jpg","nickname":"慌张而黑糖","note":"","ucode":"B4416885A301C8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308875,"discussion_content":"是的   集合类中会使用equals判断两个Key对象是否“相等”   如果不重写equals  那么默认比较32位地址值   即只有原来的同一个对象才会认为是相等    而我们的需求是 值相等即认为是同一个Key","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1601106840,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":203678,"ip_address":""},"score":308875,"extra":""}]}]},{"had_liked":false,"id":52325,"user_name":"左胜利","can_delete":false,"product_type":"c1","uid":1327195,"ip_address":"","ucode":"E17B4F4285170D","user_header":"https://static001.geekbang.org/account/avatar/00/14/40/5b/3fe51d4a.jpg","comment_is_top":false,"comment_ctime":1545362957,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"96034643469","product_id":100017301,"comment_content":"JAVA中使用散列表的数据类型：<br>HashTable:<br>1、默认初始大小：11<br>2、装载因子：0.75<br>3、散列函数：int hash = key.hashCode();<br>                      int index = (hash &amp; 0x7FFFFFFF) % tab.length;<br>4、当装载因子大于0.75时，启动扩容机制<br>4、冲突解决方法：使用单链表解决hash冲突<br>HashMap:<br>1、默认初始大小：16<br>2、装载因子：0.75<br>3、散列函数：<br>        hash(Object key) {<br>            int h;<br>            return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);<br>        }<br>4、当装载因子大于0.75时，启动扩容机制<br>5、使用单链表解决hash冲突，当链表长度大于8，将单链表转换成红黑树<br>ThreadLocalMap<br>1、初始容量：16<br>2、装载因子：2&#47;3<br>3、散列函数：<br>    hash(Object key) {<br>        int HASH_INCREMENT = 0x61c88647;<br>        AtomicInteger nextHashCode = new AtomicInteger();<br>        nextHashCode.getAndAdd(HASH_INCREMENT)<br>        int threadLocalHashCode = nextHashCode()<br>        int i = threadLocalHashCode  &amp; (table.length - 1);<br>    }<br>4、当装载因子大于2&#47;3时，启动扩容机制<br>5、使用线性探测的开放地址法解决hash冲突","like_count":22},{"had_liked":false,"id":36993,"user_name":"辰陌","can_delete":false,"product_type":"c1","uid":1245043,"ip_address":"","ucode":"961C874D36C958","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/73/8c64ed7f.jpg","comment_is_top":false,"comment_ctime":1541415019,"is_pvip":false,"replies":[{"id":"13273","content":"嗯嗯","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541468913,"ip_address":"","comment_id":36993,"utype":1}],"discussion_count":3,"race_medal":0,"score":"91735728235","product_id":100017301,"comment_content":"python的字典就是封装好的散列吧","like_count":21,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428115,"discussion_content":"嗯嗯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541468913,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1234591,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d6/9f/0213e8a0.jpg","nickname":"🤪HappyJoo","note":"","ucode":"96E1858F06BABA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":237570,"discussion_content":"学习c的我甚是想念python的字典","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587171930,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2935759,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/cb/cf/fc97de76.jpg","nickname":"Geektimer","note":"","ucode":"13746813BA173A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559310,"discussion_content":"Python的字典太牛逼，操作简单功能强大，基本能解决数据处理百分之八十的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648698465,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36474,"user_name":"喜欢你的笑","can_delete":false,"product_type":"c1","uid":1076836,"ip_address":"","ucode":"DC9867EA2D4D97","user_header":"https://static001.geekbang.org/account/avatar/00/10/6e/64/9b000b4f.jpg","comment_is_top":false,"comment_ctime":1541122682,"is_pvip":false,"replies":[{"id":"12950","content":"不建议搞得这么详细 ：）你就看一眼 有个印象就好了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541123634,"ip_address":"","comment_id":36474,"utype":1}],"discussion_count":1,"race_medal":0,"score":"74555566714","product_id":100017301,"comment_content":"能分析一下HashMap的散列函数吗？","like_count":17,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427881,"discussion_content":"不建议搞得这么详细 ：）你就看一眼 有个印象就好了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541123634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":55203,"user_name":"ccx","can_delete":false,"product_type":"c1","uid":1042577,"ip_address":"","ucode":"FC0B6CC8A3D3A1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e8/91/e05a03a0.jpg","comment_is_top":false,"comment_ctime":1546064975,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"65970574415","product_id":100017301,"comment_content":"NOTE 这节课给我的启发太大了，以前去阅读go的源码，总是感觉异常吃力，看完这节课之后去读了go关于map这个内置类型的源码，发现思路一下就清晰起来了，阅读效率高了很多，做到了有的放矢。那么以后阅读代码之前，先了解相关知识的方法论是很有必要的，这样比拿到源码就开始读，实际从长远看是节省了时间的。","like_count":15,"discussions":[{"author":{"id":1245468,"avatar":"https://static001.geekbang.org/account/avatar/00/13/01/1c/d638d46e.jpg","nickname":"宋世通","note":"","ucode":"C7AA3F0E6930F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":414683,"discussion_content":"是这样的，对于不熟悉的领域，了解背景知识和相关理论是很重要的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1636857533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":49728,"user_name":"Yishem","can_delete":false,"product_type":"c1","uid":1248199,"ip_address":"","ucode":"B9284A06BAE053","user_header":"https://static001.geekbang.org/account/avatar/00/13/0b/c7/8e6a94c1.jpg","comment_is_top":false,"comment_ctime":1544758191,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"65969267631","product_id":100017301,"comment_content":"关于HashMap的loadFactor为什么是0.75？已经有网友整理好了(https:&#47;&#47;www.jianshu.com&#47;p&#47;64f6de3ffcc1)，可以看看，很详细","like_count":15},{"had_liked":false,"id":36448,"user_name":"Infinite_gao","can_delete":false,"product_type":"c1","uid":1235607,"ip_address":"","ucode":"9FBFEDED8790A8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLsexaVCEecIhpPsOqHJkZFEnyTfOZ1Ot3lmSMfyIVkR5SerJibatj6mIHackokoIO4ELiaObhQ60rw/132","comment_is_top":false,"comment_ctime":1541119636,"is_pvip":false,"replies":[{"id":"12958","content":"大牛 能否详细说说 ","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541124298,"ip_address":"","comment_id":36448,"utype":1}],"discussion_count":5,"race_medal":0,"score":"65965629076","product_id":100017301,"comment_content":"老师可以分享一下，你对hashmap的默认负载因子是0.75的理解吗？是与泊松分布有关吗？","like_count":15,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427867,"discussion_content":"大牛 能否详细说说 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541124298,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1250040,"avatar":"https://static001.geekbang.org/account/avatar/00/13/12/f8/888a9b9d.jpg","nickname":"随风","note":"","ucode":"2883C362D6C2B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288146,"discussion_content":"应该没关系，泊松分布应该是用于解释为什么链表长度为8转换为树的。按照里面的注释，树节点占用存储空间是普通节点两倍，应该尽量避免，当hash值随机时，节点分布符合泊松分布，一个槽位达到8个节点的概率0.00000006，所以节点长度为8才转为红黑树。也不知道理解得对不对。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593660807,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1196401,"avatar":"https://static001.geekbang.org/account/avatar/00/12/41/71/b8c99cf5.jpg","nickname":"Mr.Li","note":"","ucode":"6BBFE118103125","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287201,"discussion_content":"泊松分布，数学是真的牛逼，这个已经还回去了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593398904,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1686409,"avatar":"https://static001.geekbang.org/account/avatar/00/19/bb/89/c080540d.jpg","nickname":"红桃K-","note":"","ucode":"2B6B71EEF1F07F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":189427,"discussion_content":"这可能是个经验值 哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582880517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1304564,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e7/f4/482e3413.jpg","nickname":"土豆-gavin               ༽","note":"","ucode":"15D24B71468A2C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1686409,"avatar":"https://static001.geekbang.org/account/avatar/00/19/bb/89/c080540d.jpg","nickname":"红桃K-","note":"","ucode":"2B6B71EEF1F07F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309586,"discussion_content":"不是经验，是经过计算出来的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1601360172,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":189427,"ip_address":""},"score":309586,"extra":""}]}]},{"had_liked":false,"id":36650,"user_name":"w1sl1y","can_delete":false,"product_type":"c1","uid":1270958,"ip_address":"","ucode":"915073A14B17AB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erBkHFLUBpftqQlK5brd3EDaQFaEfYLfc9iaQrDNJv4eHeSRnSgE5vKnSibJvjUb5hJx5r5nOwa2bRw/132","comment_is_top":false,"comment_ctime":1541217069,"is_pvip":false,"replies":[{"id":"13108","content":"确认好留言给我啊","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541383515,"ip_address":"","comment_id":36650,"utype":1}],"discussion_count":2,"race_medal":0,"score":"61670759213","product_id":100017301,"comment_content":"我怎么hashmap记得红黑树树化的阈值是8，退化的阈值是6，回头看看源码确认下","like_count":14,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427954,"discussion_content":"确认好留言给我啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541383515,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1639787,"avatar":"https://static001.geekbang.org/account/avatar/00/19/05/6b/d9d6d68b.jpg","nickname":"Vettel","note":"","ucode":"FB3E71DD1E8E7C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55999,"discussion_content":"链表长度大于8，并且要求桶的数量大于64时才会树化\n/**\n     * The smallest table capacity for which bins may be treeified.\n     * (Otherwise the table is resized if too many nodes in a bin.)\n     * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts\n     * between resizing and treeification thresholds.\n     */\n    static final int MIN_TREEIFY_CAPACITY = 64;","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1574421285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":40421,"user_name":"Lee","can_delete":false,"product_type":"c1","uid":1253051,"ip_address":"","ucode":"47B0D1FB9162BA","user_header":"","comment_is_top":false,"comment_ctime":1542617533,"is_pvip":false,"replies":[{"id":"14666","content":"嗯嗯 多谢指正","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542678739,"ip_address":"","comment_id":40421,"utype":1}],"discussion_count":2,"race_medal":0,"score":"53082225085","product_id":100017301,"comment_content":"JDK1.8 红黑树退化成链表阈值好像是6","like_count":12,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429516,"discussion_content":"嗯嗯 多谢指正","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542678739,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1293907,"avatar":"https://static001.geekbang.org/account/avatar/00/13/be/53/eda4b622.jpg","nickname":"Smile @ Life","note":"","ucode":"320EDAD5A8BE56","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289760,"discussion_content":"阈值是不定的：The test triggers somewhere between 2 and 6 nodes, depending on tree structure","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594204118,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114607,"user_name":"Geek_Zu","can_delete":false,"product_type":"c1","uid":1485177,"ip_address":"","ucode":"A892647511772B","user_header":"https://static001.geekbang.org/account/avatar/00/16/a9/79/16c46704.jpg","comment_is_top":false,"comment_ctime":1563348688,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"48807988944","product_id":100017301,"comment_content":"补充一下文中的一个错误之处。<br>当hashMap中节点少于6时，会由红黑树转变成链表，当hashMap中节点数为6时，链表的平均查找6&#47;2=3。<br>当hashMap中节点多于8个时，会由链表转化成红黑树，红黑树的平均查找为log(8)=3。如果继续使用链表，平均查找长度为8&#47;2=4，这才有转换为树的必要。<br>还有一个问题就是6和8的选择？6和8之间有一个7可以有效防止链表和红黑树频繁转换。<br>假设一下如果设计成hashMap中数据超过8，由链表转换成红黑树。hashMap中数据少于8，有红黑树转换成链表。若一个hashMap不停的插入，删除。hashMap中的个数不停的在8左右徘徊，就会频繁发生链表转红黑树，红黑树转链表，效率会非常低。<br>王铮老师的专栏写的非常好，感谢！","like_count":11,"discussions":[{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577680,"discussion_content":"源码有写8 是概率论算的。。退化6 的情况是2~6","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656296429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73750,"user_name":"强哥","can_delete":false,"product_type":"c1","uid":1206726,"ip_address":"","ucode":"3B8DC780FE4EF9","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/c6/513df085.jpg","comment_is_top":false,"comment_ctime":1551969166,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"44501642126","product_id":100017301,"comment_content":"X % 2^n = X &amp; (2^n - 1)<br>2^n表示2的n次方，也就是说，一个数对2^n取模 == 一个数和(2^n - 1)做按位与运算 。<br>所以说评论第一个说A%B=A&amp;(B-1)，并不成立。","like_count":10},{"had_liked":false,"id":36488,"user_name":"猫头鹰爱拿铁","can_delete":false,"product_type":"c1","uid":1105958,"ip_address":"","ucode":"24266B58968428","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/26/4942a09e.jpg","comment_is_top":false,"comment_ctime":1541127636,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"35900866004","product_id":100017301,"comment_content":"集合类的带hash的，例如hashmap、hashset、hashtable等。hashmap中散列函数是key的hashcode与key的hashcode右移16位异或，这是为了把key的高位考虑进去，如果key是0，hash值为0。在put的时候，如果表没有初始化，需要初始化下，在计算key的位置的时候很巧妙，使用表的length-1和key的hash值与计算的，实际上就是对key的hash值对表长取模，基于hashmap是2的幂次方特性，这种位运算速度更快。如果put后hashmap的数据容量超过了表的容量*负载因子，就会自动扩容，默认是两倍，自动扩容方法是将key的hash与表长直接与判断是否有高位，有高位就把这个node放到新表里旧表对应位置加旧表长的地方。没有高位就直接是新表旧位置。这是hashmap1.8的处理方法。hashmap1.7还是对key的hash取模。如果是个非常大的数，赋值为integer.max。hashmap采用的是链地址法结合红黑树解决hash冲突，当桶中链表长度大于8就会将桶中数据结构转化为红黑树。hashtable默认的初使容量11，负载因子也是0.75，如果要指定初始化hashtable容量最好是给一个素数。这是因为放入table的时候需要对表长取模，尽量分散地映射。hashtable通过链地址法解决hash冲突，当数据容量大于数据容量*负载因子自动扩容，扩容原表长两倍+1。","like_count":8},{"had_liked":false,"id":190668,"user_name":"SteelHuaSheng","can_delete":false,"product_type":"c1","uid":1396126,"ip_address":"","ucode":"BC8127FC5207FC","user_header":"https://static001.geekbang.org/account/avatar/00/15/4d/9e/04ec08bf.jpg","comment_is_top":false,"comment_ctime":1584679773,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"31649450845","product_id":100017301,"comment_content":"有些知识你只是看了一遍，理解了，但是有些扩展阅读，代码实现你没有亲自动手，也就是说可能理解了80%，不是理解了100%<br>你没有过目不忘的能力，所以其实是没有100%完全记住的。<br>你没有练习，没有去实践，所以其实是没有掌握的。<br>后面知识一旦多起来，交叉运用，如果你又没有把知识结构化，所以运用的时候你根本跟不上趟。<br>而且就像vim操作一样，复杂度分析一样，我们更重要的是运用，而不是生硬的记忆，死记硬背是没有用的。我们要用，要让知识长在我们的脑子里，长在我们的手指尖，长在我们的肌肉里。<br>所以，用笔记作为大脑的外挂，可以反复的回来看，加深理解，方便自己运用和掌握。<br>如果你不去记笔记，你总是忘记，你是记不住的，你就无法获得可叠加式的进步，你就反反复复的陷入西西弗斯陷阱。<br>所以，一定要记笔记，要不然你看书、理解的努力全部都白费了<br>看书5分钟，笔记1小时是必须的，谁叫你不是霍金、不是冯诺依曼这样的脑子呢？谁叫你不是天才呢？","like_count":7},{"had_liked":false,"id":36627,"user_name":"Allen Zou","can_delete":false,"product_type":"c1","uid":1121996,"ip_address":"","ucode":"869093D74E5EF3","user_header":"https://static001.geekbang.org/account/avatar/00/11/1e/cc/ee358b34.jpg","comment_is_top":false,"comment_ctime":1541205321,"is_pvip":false,"replies":[{"id":"13111","content":"不存在真正的数据的说法 都是先来先占坑  ","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541383823,"ip_address":"","comment_id":36627,"utype":1}],"discussion_count":3,"race_medal":0,"score":"31605976393","product_id":100017301,"comment_content":"老师，开放寻址法如果冲突了，占用其它hash code对应的位置，那该位置真正的数据来的时候怎么办，接着往后放么？删除的时候是否要搬回来？","like_count":7,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427942,"discussion_content":"不存在真正的数据的说法 都是先来先占坑  ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541383823,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1448864,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1b/a0/7c7d1b4a.jpg","nickname":"徐帅","note":"","ucode":"BDF904280E2330","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41833,"discussion_content":"理解老师的意思了，后来的数据如过坑被占了，就往后放。删除只是加标记，我感觉删除到一定程度了，会重新整理hash值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572515958,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1448864,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1b/a0/7c7d1b4a.jpg","nickname":"徐帅","note":"","ucode":"BDF904280E2330","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41830,"discussion_content":"同问啊，如果后来的数据占用前边的坑，那么接着往后放么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572515771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141856,"user_name":"小喵喵","can_delete":false,"product_type":"c1","uid":1062444,"ip_address":"","ucode":"FDBBB2A59DB8B6","user_header":"https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg","comment_is_top":false,"comment_ctime":1571237643,"is_pvip":false,"replies":[{"id":"54900","content":"是的；）","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1571360075,"ip_address":"","comment_id":141856,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27341041419","product_id":100017301,"comment_content":"为什么是78978呢？是随便给的一个数字吗？","like_count":6,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470916,"discussion_content":"是的；）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571360075,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101411,"user_name":"bear2","can_delete":false,"product_type":"c1","uid":1035608,"ip_address":"","ucode":"8108420601A548","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cd/58/79fb821f.jpg","comment_is_top":false,"comment_ctime":1559803316,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23034639796","product_id":100017301,"comment_content":"  来晚了..最近刚好在研究hashmap源码，说一下我对jdk1.8进化阈值和退化阈值为什么一个是8一个是6，而不是两个都是8的理解。<br> <br>   如果这两个值都是8，若我在7的时候添加，他进化一次，然后我又删除，他马上又退化，如果极端一点，我全是这样的操作的话，则会一直造成这样的抖动，极大的影响性能。<br>  <br>    为了避免这样的抖动，故避免进化阈值和退化阈值相同。","like_count":5},{"had_liked":false,"id":36675,"user_name":"煦暖","can_delete":false,"product_type":"c1","uid":1245418,"ip_address":"","ucode":"96D0B236C4148A","user_header":"https://static001.geekbang.org/account/avatar/00/13/00/ea/6ad346c1.jpg","comment_is_top":false,"comment_ctime":1541229578,"is_pvip":false,"replies":[{"id":"13104","content":"我也没仔细研究 不建议研究这么深","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541383438,"ip_address":"","comment_id":36675,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23016066058","product_id":100017301,"comment_content":"老师，HashMap 的散列函数看不懂，可以讲解一下吗？","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427965,"discussion_content":"我也没仔细研究 不建议研究这么深","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541383438,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36412,"user_name":"Zhangwh","can_delete":false,"product_type":"c1","uid":1244001,"ip_address":"","ucode":"49CDE4BCFC2534","user_header":"https://static001.geekbang.org/account/avatar/00/12/fb/61/c84a45be.jpg","comment_is_top":false,"comment_ctime":1541092422,"is_pvip":false,"replies":[{"id":"12961","content":"下一节课就要讲了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541124489,"ip_address":"","comment_id":36412,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23015928902","product_id":100017301,"comment_content":"链表和哈希表结合成lru 缓存，老师能讲讲不，记得老师在链表那块说过","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427854,"discussion_content":"下一节课就要讲了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541124489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117478,"user_name":"雪浪","can_delete":false,"product_type":"c1","uid":1541538,"ip_address":"","ucode":"CB33F2F8418557","user_header":"https://static001.geekbang.org/account/avatar/00/17/85/a2/dbeeb6c4.jpg","comment_is_top":false,"comment_ctime":1564057301,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18743926485","product_id":100017301,"comment_content":"当链表长度大于8的时候，链表转化为红黑树。当红黑树节点小于6的时候（不是原文的8），红黑树转成链表。","like_count":4},{"had_liked":false,"id":36475,"user_name":"失火的夏天","can_delete":false,"product_type":"c1","uid":1241770,"ip_address":"","ucode":"10C6E66EB2A65F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","comment_is_top":false,"comment_ctime":1541122995,"is_pvip":false,"replies":[{"id":"12949","content":"是的 哈希算法是个很大的话题","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541123574,"ip_address":"","comment_id":36475,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18720992179","product_id":100017301,"comment_content":"JAVA中hash化的好像都是基于散列表的，比如hashmap,linkedhashmap,hashset,linkedhashset，还有hashtable，concurrenthashmap之类的。感觉hashcode的设计真的很巧妙，包括treemap都应用到hashcode方法。一个hashcode里面包含了很多的数学思想","like_count":4,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427882,"discussion_content":"是的 哈希算法是个很大的话题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541123574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36462,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1541120931,"is_pvip":true,"replies":[{"id":"12956","content":"深挖无止境 加油💪","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541124224,"ip_address":"","comment_id":36462,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18720990115","product_id":100017301,"comment_content":"对hashmap的认识有个新的高度，还是还是有很多细节需要研究，以前对数据结构的认知浮于表面，要认真去对接每个细节","like_count":4,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427875,"discussion_content":"深挖无止境 加油💪","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541124224,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36449,"user_name":"Infinite_gao","can_delete":false,"product_type":"c1","uid":1235607,"ip_address":"","ucode":"9FBFEDED8790A8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLsexaVCEecIhpPsOqHJkZFEnyTfOZ1Ot3lmSMfyIVkR5SerJibatj6mIHackokoIO4ELiaObhQ60rw/132","comment_is_top":false,"comment_ctime":1541119741,"is_pvip":false,"replies":[{"id":"12957","content":"😄 我也不是很清楚 不过应该是基于一些实验数据得来的吧","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541124267,"ip_address":"","comment_id":36449,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18720988925","product_id":100017301,"comment_content":"老师可以分享一下你对hashmap的默认负载因子是0.75的理解吗？","like_count":4,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427868,"discussion_content":"😄 我也不是很清楚 不过应该是基于一些实验数据得来的吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541124267,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1496889,"avatar":"https://static001.geekbang.org/account/avatar/00/16/d7/39/6698b6a9.jpg","nickname":"Hector","note":"","ucode":"110CAF87ADDC01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1807,"discussion_content":"golang的负载因子为0.65，作者在代码注释中列举了实验结果，取得0.65是一个折中的方案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562919915,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230283,"user_name":"狮锅艺","can_delete":false,"product_type":"c1","uid":1187577,"ip_address":"","ucode":"1B4AD130F9D0CA","user_header":"https://static001.geekbang.org/account/avatar/00/12/1e/f9/bfb54326.jpg","comment_is_top":false,"comment_ctime":1593336147,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14478238035","product_id":100017301,"comment_content":"1、 golang内置的map是使用hast table实现的，具体实现在runtime包中。<br><br>A map is just a hash table. The data is arranged into an array of buckets. Each bucket contains up to<br>8 key&#47;elem pairs. <br><br>2、哈希函数的设计，有点类似参赛选手的那个例子，每个哈希值的低位用于选择存储位置，剩余的哈希值的高位作为key值，用于比较区分。<br><br>The low-order bits of the hash are used to select a bucket. Each bucket contains a few high-order bits of each hash to distinguish the entries within a single bucket.<br><br><br>3、散列冲突也是使用链表法解决，不过这里的一个节点不是普通意义上的节点而是一个容量为8的桶，单桶数量超过容量时再创建新的桶，这样的设计可以有效避免链表的缺点，如存储指针，不能利用CPU缓存等<br><br>If more than 8 keys hash to a bucket, we chain on extra buckets.<br><br>4、支持动态扩容，容量不够时会申请一个原来两倍大小的容量<br><br>When the hashtable grows, we allocate a new array of buckets twice as big. Buckets are incrementally copied from the old bucket array to the new bucket array.<br><br>When growing the table, iterators remain iterating through the old table and must check the new table if the bucket they are iterating through has been moved (&quot;evacuated&quot;) to the new table.","like_count":3,"discussions":[{"author":{"id":1445504,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/gVfU7icdia3o5ZNaHjaWAdgkSYIpU1rdhIlVYiahYCvRlDZu2K6oPSvVobNjzwZbUaiayQcKjicZ44WjfWJCj5xdlPA/132","nickname":"红尘","note":"","ucode":"CCCD5736755DF5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384783,"discussion_content":"负载因子 6.5","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626750095,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204581,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1586424101,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"14471325989","product_id":100017301,"comment_content":"有深度！好文！工业级别的文章就应该是这样的。","like_count":3},{"had_liked":false,"id":153096,"user_name":"SapereAude","can_delete":false,"product_type":"c1","uid":1717549,"ip_address":"","ucode":"C5D61C535B7B10","user_header":"https://static001.geekbang.org/account/avatar/00/1a/35/2d/a2bde67e.jpg","comment_is_top":false,"comment_ctime":1574156697,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14459058585","product_id":100017301,"comment_content":"越看越上瘾。","like_count":3},{"had_liked":false,"id":133222,"user_name":"方晓斌","can_delete":false,"product_type":"c1","uid":1042367,"ip_address":"","ucode":"A26FA55F05FE9E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e7/bf/b6dd86f4.jpg","comment_is_top":false,"comment_ctime":1568450586,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14453352474","product_id":100017301,"comment_content":"我想说下，hashmap 中散列函数设计中融合高低位的特征那里。诸位都没说明白，那为什么需要融合高低位？因为在容量较小时，位运算就基本只有低几位参与了，这是为了保证容量小时依然能保持散列效果","like_count":3},{"had_liked":false,"id":230212,"user_name":"Mike Zheng","can_delete":false,"product_type":"c1","uid":2039829,"ip_address":"","ucode":"D7F062DDE2A93A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Ccdlzibsv0umJB4QeX0K6JBAas41F3Xobib8rudwic6vNgNYVa4WUdhU9vMKfKRuU3P0u3V0flrn2tlOrDdlCBFmQ/132","comment_is_top":false,"comment_ctime":1593312878,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10183247470","product_id":100017301,"comment_content":"    Python 的 Dict 是基于散列表实现的，以下内容来自于 https:&#47;&#47;stackoverflow.com&#47;a&#47;9022835&#47;6446341<br>    1. dict 的具体实现是一块连续的内存空间，所以访问的时间复杂度为 O(1)<br>    2. 每一个内存空间包含一个 entry，它的内容是 &lt;hash, key, value&gt;<br>    3. 初始化大小默认是 8 个 entry<br>    4. 装载因子是 2&#47;3<br>    5. 使用开放寻址法解决散列冲突，具体使用了伪随机函数来计算下一个地址","like_count":2,"discussions":[{"author":{"id":1085207,"avatar":"https://static001.geekbang.org/account/avatar/00/10/8f/17/aa66313a.jpg","nickname":"Shaw","note":"","ucode":"CE382F300EFF19","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294259,"discussion_content":"我看源码注释这样写的：\n\nthe table load factor is kept under 2/3, so the odds\nare solidly in our favor\n\n保持在 2/3 之下，为啥java是0.75，ptyhon是2/3。个人感觉是跟柏松分布有关，只有在0.69附近的值，差不多就行了。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595842269,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131050,"user_name":"热心网友","can_delete":false,"product_type":"c1","uid":1329547,"ip_address":"","ucode":"8779205D59C409","user_header":"https://static001.geekbang.org/account/avatar/00/14/49/8b/844e70df.jpg","comment_is_top":false,"comment_ctime":1567609199,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10157543791","product_id":100017301,"comment_content":"关于为什么要用高低位异或的原因，我来换个说法：因为key最终存储在hashMap中的数组中的哪个位置取决于当前这个数组是2的多少幂，更进一步说就是取决于hashCode的二进制低n位，这个n就是幂，那么当前期或者大部分实际情况hashMap容量很小的时候，假设是16，幂是4，我们假设要存入100个数据，他们所有key的hashCode的32个位的差异体现在高低16位上随机各站一半，那么也就是说大概有50条数据会冲突，因为他们的hashCode的低16位是一样的，更不用说低4位，通过上述hash算法得到的数组位置是同一个。","like_count":2},{"had_liked":false,"id":36754,"user_name":"sarahsnow","can_delete":false,"product_type":"c1","uid":1249446,"ip_address":"","ucode":"63D0832C4F75CA","user_header":"https://static001.geekbang.org/account/avatar/00/13/10/a6/564f9143.jpg","comment_is_top":false,"comment_ctime":1541307182,"is_pvip":false,"replies":[{"id":"13089","content":"可以是可以 但实话讲 对我来说工作量就太大了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541382932,"ip_address":"","comment_id":36754,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10131241774","product_id":100017301,"comment_content":"看到排序，插入、查找、删除这些算法，其实都和不同数据的特点、规模息息相关。<br>作为笨鸟一只，勉强跟上课程的进度和思想，实战还是懵圈。<br>自己练习这些算法时，需要先准备数据，和预处理数据，把数据存储装载到数据结构中是个难点。<br><br>请问老师能否提供一些现成的典型数据(不同规模、特点的），和数据预处理的代码呢？","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428000,"discussion_content":"可以是可以 但实话讲 对我来说工作量就太大了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541382932,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36733,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1541296537,"is_pvip":false,"replies":[{"id":"13096","content":"我也看你经常留言 你能不能研究这个问题 回复到留言区呢","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541383218,"ip_address":"","comment_id":36733,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10131231129","product_id":100017301,"comment_content":"每次都会看留言，从留言中能学到不少东西。比如之前还真不能理解为什么Java HashMap的负载因子要用0.75","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427987,"discussion_content":"我也看你经常留言 你能不能研究这个问题 回复到留言区呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541383218,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1584018,"avatar":"https://static001.geekbang.org/account/avatar/00/18/2b/92/3014b05b.jpg","nickname":"blue_diamond","note":"","ucode":"CD7A531530B858","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":141510,"discussion_content":"现在知道为啥是0.75了吗？大牛帮忙解答一下呗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579426891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1008404,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","nickname":"Jerry银银","note":"","ucode":"80DA1172A2360A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1584018,"avatar":"https://static001.geekbang.org/account/avatar/00/18/2b/92/3014b05b.jpg","nickname":"blue_diamond","note":"","ucode":"CD7A531530B858","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":142497,"discussion_content":"Java hashmap源码中有注释，可以参看：泊松分布","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1579478830,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":141510,"ip_address":""},"score":142497,"extra":""}]}]},{"had_liked":false,"id":36507,"user_name":"Kudo","can_delete":false,"product_type":"c1","uid":1036948,"ip_address":"","ucode":"21965914B72AEB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d2/94/8bd217f1.jpg","comment_is_top":false,"comment_ctime":1541135449,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10131070041","product_id":100017301,"comment_content":"以前只是用，现在终于了解其背后的设计思想了，讲得真不赖。","like_count":2},{"had_liked":false,"id":36439,"user_name":"醉比","can_delete":false,"product_type":"c1","uid":1248399,"ip_address":"","ucode":"79E65F62BE7809","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/8f/4ebd303a.jpg","comment_is_top":false,"comment_ctime":1541118678,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10131053270","product_id":100017301,"comment_content":"HashMap从入门到精通","like_count":2},{"had_liked":false,"id":224139,"user_name":"武兴业","can_delete":false,"product_type":"c1","uid":1092637,"ip_address":"","ucode":"9091C8B76AD2F0","user_header":"https://static001.geekbang.org/account/avatar/00/10/ac/1d/c695f03e.jpg","comment_is_top":false,"comment_ctime":1591283988,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5886251284","product_id":100017301,"comment_content":"&gt;=8个转为红黑树，&lt;=6个变为链表<br><br>&#47;**<br>     * The bin count threshold for untreeifying a (split) bin during a<br>     * resize operation. Should be less than TREEIFY_THRESHOLD, and at<br>     * most 6 to mesh with shrinkage detection under removal.<br>     *&#47;<br>    static final int UNTREEIFY_THRESHOLD = 6;<br><br>防止插入删除频繁的情况下，导致红黑树和链表之间来回转换","like_count":1},{"had_liked":false,"id":190771,"user_name":"SteelHuaSheng","can_delete":false,"product_type":"c1","uid":1396126,"ip_address":"","ucode":"BC8127FC5207FC","user_header":"https://static001.geekbang.org/account/avatar/00/15/4d/9e/04ec08bf.jpg","comment_is_top":false,"comment_ctime":1584691320,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5879658616","product_id":100017301,"comment_content":"有些知识你只是看了一遍，理解了，但是有些扩展阅读，代码实现你没有亲自动手，也就是说可能理解了80%，不是理解了100%<br>你没有过目不忘的能力，所以其实是没有100%完全记住的。<br>你没有练习，没有去实践，所以其实是没有掌握的。<br>后面知识一旦多起来，交叉运用，如果你又没有把知识结构化，所以运用的时候你根本跟不上趟。<br>而且就像vim操作一样，复杂度分析一样，我们更重要的是运用，而不是生硬的记忆，死记硬背是没有用的。我们要用，要让知识长在我们的脑子里，长在我们的手指尖，长在我们的肌肉里。<br>所以，用笔记作为大脑的外挂，可以反复的回来看，加深理解，方便自己运用和掌握。<br>如果你不去记笔记，你就总是忘记，你记不住的，你就无法获得可叠加式的进步，你就反反复复的陷入西西弗斯陷阱。<br>所以，一定要记笔记。不要反复的忘记，反复的把石头推倒山顶，掉下来，再推上去。<br>写作是把网状思考，以树状形态，做线性表达，记笔记的时候就要把树状形态展示出来，然后思考这知识在网络的什么位置。<br>实在不行，记笔记也是理解的一个辅助手段，决定了你第一遍理解的程度。你学习留存了多少。要不然这次你看书、理解的努力全部都白费了。<br>看书5分钟，笔记1小时是因为这是必须的，学习和吸收知识需要一个过程。谁叫你不是霍金、不是冯诺依曼这样的脑子呢？谁叫你不是天才呢？","like_count":1},{"had_liked":false,"id":164200,"user_name":"注定非凡","can_delete":false,"product_type":"c1","uid":1113597,"ip_address":"","ucode":"80673056E131B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","comment_is_top":false,"comment_ctime":1576909916,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5871877212","product_id":100017301,"comment_content":"①：散列表的查询效率并不能笼统的说成O(1)。它跟散列函数，装载因子，散列冲突等都有关系。<br>\t在极端情况下，可以通过精心构造的数据，使得所有的数据经过散列函数后，都散列到同一个槽里。若使用的是基于链表的冲突解决方法，那么散列表就会退化成为链表，查询的时间复杂度就从O(1)退化到O(n)。<br>②：如何设计一个：可以应对各种异常情况的工业级散列表，来避免在散列冲突的情况下，散列表性能的急剧下降，并且能抵抗散列碰撞攻击？<br>\t&gt;1：散列函数的设计不能太复杂<br>\t\t过于复杂的散列函数，会消耗很多的计算时间，间接影响性能。<br>\t&gt;2：散列函数生成的值要尽可能随机并且均匀分布<br>\t\t这样才能避免或者最小化散列冲突，而且即使冲突，散列到每个槽里的数据也会比较平均。<br>\t&gt;3：常用的，简单的散列函数设计方法：<br>\t\t数据分析法：如手机号采用手机号的后四位作为散列值，后几位的数字比较随机。<br>\t\t数据转换法：将单词的每个字母的ASCII值“进位”相加，然后在跟散列表的大小求余，取模，作为散列值。<br>\t\t其他方法：直接寻址法，平方取中法，折叠法，随机数法等<br>③：装载因子过大了怎么办？<br>\t&gt;1：装载因子很大时，不仅插入数据的过程要多次寻址或者拉很长的链，查找的过程也会因此变得很慢。<br>\t&gt;2：当装载因子过大时，可以进行动态扩容，重新申请一个更大的散列表。<br>\t\t针对散列表的扩容，数据搬迁操作要复杂很多，因为散列表的大小变了，数据的存储位置也变了，所以要通过散列函数重新计算每个数据的存储位置。\t<br>\t&gt;3：支持动态扩容的散列表，插入操作的<br>            ①：时间复杂度：插入一个数据，最好情况下，不需要扩容，最好的时间复杂度是O(1)。最坏情况下，散列表装载因子过高，启动扩容，需要重新申请内存空间，重新计数哈希位置，并且搬移数据，所以时间复杂度是O（n）。用摊还分析法，时间复杂度接近最好情况，就是O(1)。<br>            ②：动态散列表，随着数据删除，散列表中的数据会越来越少，空闲空间会越来越多。若对空间消耗非常敏感，可以在装载因子小于某个值之后，启动动态缩容<br>\t&gt;4：装载因子阀值设置要权衡时间，空间复杂度。如果内存空间不紧张，对执行效率要很高，可以降低负载因子的阀值；想发，如果内存空间紧张，对执行效率要求不高，可以增加负载因子的值，甚至可以大于1。<br><br>④：如何避免低效地扩容？<br>\t\t为了解决一次性扩容耗时过的的情况，可以将扩容操作穿插在插入操作的过程中，分批完成，当装载因子触达阈值之后，只申请新空间，但并不讲老的数据搬移到新散列表中。<br>\t\t当有新的数据插入时，将新的数据插入新的散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，都重复这个过程，经过多次插入操作之后，老的散列表中的数据就会被全部搬移到新散列表中。这样就没了集中一次性将数据搬移，插入操作就变得很快了。<br>\t\t在这个期间，查询操作为了兼容新老散列表，会先从新表中查，查不到时在去老表中查。<br>\t\t这种实现方式，任何情况下，插入一个数据的时间复杂度都是O(1)。<br>\t<br>⑤：如何选择冲突解决方法？<br>\t\t解决冲突的两种主要方法：开放寻址法和链表法。Java中的LinkedHashMap采用了链表法解决冲突，ThreadLocalMap是通过线性探测的开放寻址法来解决冲突。<br>\t<br>\t\t1，开放寻址法：<br>\t\t\t优点：<br>\t\t\t\t》1：开放寻址法不像链表法，需要拉很多链表。散列表中的数据都存储在数组中，可以有效地利用CPU缓存加快查询速度。<br>\t\t\t\t》2：这种方法实现的散列表，序列化起来比较简单。链表法包含指针，序列化起来没有那么容易。<br>\t\t\t缺点：<br>\t\t\t\t》1：用开放寻址法解决冲突的散列表，删除数据比较麻烦，需要特殊标记已经删除的数据。<br>\t\t\t\t》2：在开放寻址法中，所有数据都存储在一个数组中，比较链表法，冲突的代价更高。<br>\t\t\t\t》3：因此，使用开放寻址法解决冲突的散列表，装载因子的上限不能太大。这也导致这种方法更耗费内存空间。<br><br>\t\t2，链表法<br>\t\t\t优点：<br>》1：链表法对内存的利用率比开放寻址法要高。因为链表结点可以在需要的时候在创建，并不需要像开放寻址法那样事先申请好。<br>》2：链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能使用装载因子小于1的情况。<br>》3：对于链表法，只要散列函数的值随机均匀，即便装载因子变成10，也就是链表的长度变成了而已，虽然查询效率有所下降，但比起顺序查找还是快很多。\t\t<br>\t\t\t缺点：<br>》1：链表要存储指针，所以对于比较小的对象的存储，是比较消耗内存的，甚至会让内存消耗翻倍。<br>》2：因为链表中的结点是零散分布在内存中的，不是连续的，，所以对CPU缓存是不友好的，这对执行效率也有一定影响。<br>","like_count":1},{"had_liked":false,"id":154387,"user_name":"Vettel","can_delete":false,"product_type":"c1","uid":1639787,"ip_address":"","ucode":"FB3E71DD1E8E7C","user_header":"https://static001.geekbang.org/account/avatar/00/19/05/6b/d9d6d68b.jpg","comment_is_top":false,"comment_ctime":1574420972,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869388268","product_id":100017301,"comment_content":"粗略读过JDK1.8的HashMap和LinkedHashMap源码，其实HashMap就是链表法在jdk1.8新增了链表和红黑树转换的特性，LinkedHashMap是HashMap的子类，增加了双向链表来支持根据插入顺序和访问顺序的访问","like_count":1},{"had_liked":false,"id":142209,"user_name":"民工597","can_delete":false,"product_type":"c1","uid":1529858,"ip_address":"","ucode":"DB6857E21E9318","user_header":"https://static001.geekbang.org/account/avatar/00/17/58/02/2b7ccf09.jpg","comment_is_top":false,"comment_ctime":1571312086,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5866279382","product_id":100017301,"comment_content":"红黑树是小于6的情况下才退化成链表，要是都是8在特殊情况下会造成转化不断进行","like_count":1,"discussions":[{"author":{"id":1466121,"avatar":"https://static001.geekbang.org/account/avatar/00/16/5f/09/2ec44412.jpg","nickname":"Qfeng","note":"","ucode":"1248E70012BBA2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79756,"discussion_content":"想起来了，这属于一种回环设计，避免临界值附近的来回震荡","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576109735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141179,"user_name":"厚积薄发","can_delete":false,"product_type":"c1","uid":1657999,"ip_address":"","ucode":"6FE711F65C8C66","user_header":"https://static001.geekbang.org/account/avatar/00/19/4c/8f/83eefcff.jpg","comment_is_top":false,"comment_ctime":1571127917,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5866095213","product_id":100017301,"comment_content":"python字典应用了散列表，开放寻址法，二次探测","like_count":1},{"had_liked":false,"id":134730,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1568905373,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5863872669","product_id":100017301,"comment_content":"C++ STL中的hashmap底层采用哈希表实现，采用开链法解决散列冲突，拉链为简单的单链表。支持动态扩容，并且提前预存质数数组，扩容时从质数数组中取下一个质数作为哈希表长度，扩容过程是同步的，可能耗时会比较大","like_count":1},{"had_liked":false,"id":132856,"user_name":"GM","can_delete":false,"product_type":"c1","uid":1385370,"ip_address":"","ucode":"D186205180CA0F","user_header":"https://static001.geekbang.org/account/avatar/00/15/23/9a/213f6a69.jpg","comment_is_top":false,"comment_ctime":1568253703,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5863220999","product_id":100017301,"comment_content":"go的map是基于散列表实现的，解决冲突是用链表法，也是渐进式rehash","like_count":1},{"had_liked":false,"id":117510,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1564064438,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5859031734","product_id":100017301,"comment_content":"收获很大，多看几遍要。","like_count":1},{"had_liked":false,"id":113641,"user_name":"小白菜","can_delete":false,"product_type":"c1","uid":1568340,"ip_address":"","ucode":"ACD1267D329B96","user_header":"https://static001.geekbang.org/account/avatar/00/17/ee/54/dac0a6b6.jpg","comment_is_top":false,"comment_ctime":1563102273,"is_pvip":false,"replies":[{"id":"41571","content":"1、ascii码进位求和：目的一是讲字符转化为数字，目的二是尽量的随机<br>2. 取模求余：目的是讲hash值归一化到数组大小范围内","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1563233103,"ip_address":"","comment_id":113641,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5858069569","product_id":100017301,"comment_content":"老师您好，请问文章中：“将单词中每个字母的ASCll 码值“进位”相加，然后再跟散列表的大小求余、取模，作为散列值。为什么要这样设计啊？<br><br>","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458323,"discussion_content":"1、ascii码进位求和：目的一是讲字符转化为数字，目的二是尽量的随机\n2. 取模求余：目的是讲hash值归一化到数组大小范围内","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563233103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36762,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1541315121,"is_pvip":false,"replies":[{"id":"13085","content":"👍 这个问题很好","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541382773,"ip_address":"","comment_id":36762,"utype":1}],"discussion_count":4,"race_medal":0,"score":"5836282417","product_id":100017301,"comment_content":"分享自己猜测的一个有意思的点：专栏留言的排序规则应该是按照点赞数排序，再按照留言时间排序的！？<br><br>可以引申一个思考题，在实际应用中，你会怎么排序，又会使用什么排序算法呢？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428004,"discussion_content":"👍 这个问题很好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541382773,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1251917,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1a/4d/932e54e1.jpg","nickname":"天黑要睡觉","note":"","ucode":"A73FB0AFC690EE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":231920,"discussion_content":"这不就是，双重排序吗？先稳定排序时间，之后再稳定排序点赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586838773,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1542987,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","nickname":"行则将至","note":"","ucode":"DB972F2DF059C4","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":1251917,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1a/4d/932e54e1.jpg","nickname":"天黑要睡觉","note":"","ucode":"A73FB0AFC690EE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574871,"discussion_content":"我觉着先按照点赞数排，然后再按时间排。最后的效果是：点赞数高的在前，点赞数相同的，最新的时间在前。感觉这样设计是合理的设计","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654415285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":231920,"ip_address":""},"score":574871,"extra":""}]},{"author":{"id":1314724,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0f/a4/0b49469f.jpg","nickname":"木子00","note":"","ucode":"8F78CA722EB29B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":210384,"discussion_content":"我总感觉这样排序不好.又说不上来.嘿嘿!!!","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584718683,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36631,"user_name":"吴彪","can_delete":false,"product_type":"c1","uid":1238385,"ip_address":"","ucode":"04EF499564D438","user_header":"https://static001.geekbang.org/account/avatar/00/12/e5/71/cc94469a.jpg","comment_is_top":false,"comment_ctime":1541209871,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5836177167","product_id":100017301,"comment_content":"我看Fluent Python这本书p89，dict解决散列冲突的方法比较好玩。取部分哈希值来查找bucket、如果冲突了，再另取部分哈希值查找。按书上的说法，碰撞概率极其低。推测不是基于链表法实现，可能是优化过的开放寻址法，具体要看c的源码。。","like_count":1,"discussions":[{"author":{"id":1085207,"avatar":"https://static001.geekbang.org/account/avatar/00/10/8f/17/aa66313a.jpg","nickname":"Shaw","note":"","ucode":"CE382F300EFF19","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294261,"discussion_content":"好像是这个，也忘了：    j = ((5*j) + 1) mod 2**i","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595842464,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1308376,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er6NXib2NGaTAAEe2KCcibH2FiafOOD73kQdcuAMGrnRib5CDWXum0SWDOM9NnWicbUsDpghmxEmJtpk9w/132","nickname":"ajlidue","note":"","ucode":"D6B29E941958E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":102827,"discussion_content":"感觉是老师上一节讲的双重散列","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577365487,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36578,"user_name":"Allen Zou","can_delete":false,"product_type":"c1","uid":1121996,"ip_address":"","ucode":"869093D74E5EF3","user_header":"https://static001.geekbang.org/account/avatar/00/11/1e/cc/ee358b34.jpg","comment_is_top":false,"comment_ctime":1541160071,"is_pvip":false,"replies":[{"id":"13118","content":"对比原始数据 看是不是要删除的那个","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541384274,"ip_address":"","comment_id":36578,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5836127367","product_id":100017301,"comment_content":"老师，开放寻址法如果冲突后会顺序占用后面的空间，比如值x 的hash code 为 n, 冲突后占用 n + 1, n + 2, ..., n + k, 那这时候如果来了一个数 y 的 hash code 为 n + 1, 那它怎么存呢？如果放在 n + k + 1 位，那删除的时候如何判断呢？再计算一遍 hash code 么？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427920,"discussion_content":"对比原始数据 看是不是要删除的那个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541384274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36477,"user_name":"Demter","can_delete":false,"product_type":"c1","uid":1158439,"ip_address":"","ucode":"BE3B6F726916CE","user_header":"https://static001.geekbang.org/account/avatar/00/11/ad/27/5556ae50.jpg","comment_is_top":false,"comment_ctime":1541123996,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5836091292","product_id":100017301,"comment_content":"分析的很透彻。","like_count":1},{"had_liked":false,"id":36458,"user_name":"凡","can_delete":false,"product_type":"c1","uid":1041878,"ip_address":"","ucode":"BCF83BE1D434D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e5/d6/37a1be71.jpg","comment_is_top":false,"comment_ctime":1541120708,"is_pvip":false,"replies":[{"id":"12955","content":"快讲了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541124193,"ip_address":"","comment_id":36458,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5836088004","product_id":100017301,"comment_content":"看最近几篇文章多次提到红黑树！不知道什么时候会讲一下红黑树！然后这节课看的有点吃力呀，唯一一节看完没啥印象的","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427872,"discussion_content":"快讲了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541124193,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36413,"user_name":"朱月俊","can_delete":false,"product_type":"c1","uid":1017707,"ip_address":"","ucode":"4DA0728B862FBD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/6b/0b6cd39a.jpg","comment_is_top":false,"comment_ctime":1541095674,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5836062970","product_id":100017301,"comment_content":"C++中的atd::ordered_map就是基于散列表实现的，支持动态扩容，链表法。还不清楚(1)动态扩容是否也是新插入一个元素，迁移一个元素；还是一次性全部迁移完。(2)链表数量过大是否改变数据结构也不清楚。","like_count":1},{"had_liked":false,"id":358872,"user_name":"111","can_delete":false,"product_type":"c1","uid":3109487,"ip_address":"北京","ucode":"D6E8E83A118A3E","user_header":"https://static001.geekbang.org/account/avatar/00/2f/72/6f/44c10658.jpg","comment_is_top":false,"comment_ctime":1664955835,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664955835","product_id":100017301,"comment_content":"总结：<br>1. 散列表需要考虑的点，hash函数，装载因子，解决hash冲突的方法<br>2. 开放寻址适合固定的，小范围的内容，链表相反<br>3. 工业级的散列表需要注意hash函数和装载因子以及解决冲突的方法<br><br>散列函数通过数值自身特点，得到一个正整数值来对应数组下标，具体应用还没有见过。","like_count":0},{"had_liked":false,"id":355788,"user_name":"蒋慕平","can_delete":false,"product_type":"c1","uid":2302901,"ip_address":"重庆","ucode":"57B8FF7F00C042","user_header":"https://static001.geekbang.org/account/avatar/00/23/23/b5/639a12ec.jpg","comment_is_top":false,"comment_ctime":1661750003,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661750003","product_id":100017301,"comment_content":"1.设计一个合适散列函数<br>2.定义装载因子阀值，并且设计动态扩容策略。<br>3.选择合适的散列冲突解决方法。<br>- 开放寻址方法-数据量比较小、装载因子小的时候，适合开放寻址法<br>- 链表法","like_count":0},{"had_liked":false,"id":353678,"user_name":"Allan","can_delete":false,"product_type":"c1","uid":1310388,"ip_address":"北京","ucode":"8DA4DBECC2C45C","user_header":"https://static001.geekbang.org/account/avatar/00/13/fe/b4/295338e7.jpg","comment_is_top":false,"comment_ctime":1659670719,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1659670719","product_id":100017301,"comment_content":"看了评论去，然后去HashMap看了一下。关于初始化容量大小这一块，看了半天，自己用数在纸上画了画。不得不佩服这些大佬，脑子真是牛。在你给的容量大小下，按照最近的2的次幂来计算。<br>    static final int tableSizeFor(int cap) {<br>        int n = cap - 1;<br>        n |= n &gt;&gt;&gt; 1;<br>        n |= n &gt;&gt;&gt; 2;<br>        n |= n &gt;&gt;&gt; 4;<br>        n |= n &gt;&gt;&gt; 8;<br>        n |= n &gt;&gt;&gt; 16;<br>        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;<br>    }","like_count":0},{"had_liked":false,"id":346784,"user_name":"EyesOnMe","can_delete":false,"product_type":"c1","uid":1246531,"ip_address":"","ucode":"981482EA89DC02","user_header":"https://static001.geekbang.org/account/avatar/00/13/05/43/baac3bbb.jpg","comment_is_top":false,"comment_ctime":1653437116,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653437116","product_id":100017301,"comment_content":"自古评论出人才","like_count":0},{"had_liked":false,"id":338736,"user_name":"H.H","can_delete":false,"product_type":"c1","uid":2668479,"ip_address":"","ucode":"3C0BB1E2A3EC51","user_header":"https://static001.geekbang.org/account/avatar/00/28/b7/bf/815f0ec6.jpg","comment_is_top":false,"comment_ctime":1647696410,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1647696410","product_id":100017301,"comment_content":"python中的字典和集合使用的是散列表，它会至少预留1&#47;3的剩余空间，当剩余空间不足1&#47;3的话，就会动态扩容，增大一倍。使用双重探测解决哈希冲突","like_count":0},{"had_liked":false,"id":337006,"user_name":"Today","can_delete":false,"product_type":"c1","uid":1235000,"ip_address":"","ucode":"4FA397F0BD8C6E","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/38/41027bda.jpg","comment_is_top":false,"comment_ctime":1646547371,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646547371","product_id":100017301,"comment_content":"本节学习到了：<br>· 散列表的查找效率不能直接说是 O(1) 级别，它涉及到散列函数、装载因子、散列冲突<br><br>· 散列函数的设计要简单高效，值要尽可能的随机且均匀<br><br>· 装载因子要设计合适值，效率高就小点；空间要求高，效率低就大点<br><br>· 尽量避免一次性拓容<br><br>· 数据量小，装载因子较小时，散列冲突的解决可以使用开放寻址法<br><br>· 数据量大，或装载因子大时，散列冲突的解决可以使用链表法<br><br>思考题：<br>v8 的 hashmap 使用了开发寻址法来处理冲突，支持拓容处理，也是 2 倍的方式","like_count":0},{"had_liked":false,"id":322080,"user_name":"yx","can_delete":false,"product_type":"c1","uid":2828103,"ip_address":"","ucode":"F8B7ABCB832208","user_header":"","comment_is_top":false,"comment_ctime":1637159774,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637159774","product_id":100017301,"comment_content":"当红黑树结点个数少于 8 个的时候，又会将红黑树转化为链表。（红黑树转链表，HashMap中准确的是节点少于6，才会转链表，8虽然是个阈值，但是树转链表的过程也需要消耗性能。）","like_count":0},{"had_liked":false,"id":317666,"user_name":"项翼彪","can_delete":false,"product_type":"c1","uid":1948926,"ip_address":"","ucode":"694989CE57A0CE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL2dAokNdibVZqUwmfOwEBVNoTKwbfdFOx5yqNeUDNQO5QXIiaLWibWqbrdugyIsd54O1yELib3TTMaQA/132","comment_is_top":false,"comment_ctime":1634885554,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634885554","product_id":100017301,"comment_content":"Hash(nice)的方法，乘法，加法……这么多次运算效率不高吧","like_count":0},{"had_liked":false,"id":315170,"user_name":"201201676","can_delete":false,"product_type":"c1","uid":2372151,"ip_address":"","ucode":"8539CF0FF183A5","user_header":"","comment_is_top":false,"comment_ctime":1633740863,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633740863","product_id":100017301,"comment_content":"学习总结 — 工业级散列表设计要素<br>1. 合适的装载因子<br>2. 快速的查询方式<br>3. 合理的扩容方式","like_count":0},{"had_liked":false,"id":304571,"user_name":"Geek_842f07","can_delete":false,"product_type":"c1","uid":2698987,"ip_address":"","ucode":"ED772AF755FE7E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/WP4Ge8ABcINFkccKaNYKibicFnI0JAoojBBAUGrichNeRAgzm5RGbHG7GqYrFX3ELEzenuEbicQHJy2HZ72RxSOuMA/132","comment_is_top":false,"comment_ctime":1627480284,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627480284","product_id":100017301,"comment_content":"c++使用散列表的容器有unordered_map、unordered_set","like_count":0},{"had_liked":false,"id":304503,"user_name":"up","can_delete":false,"product_type":"c1","uid":2667806,"ip_address":"","ucode":"7D1C25BBBEBCDB","user_header":"https://static001.geekbang.org/account/avatar/00/28/b5/1e/0e42696c.jpg","comment_is_top":false,"comment_ctime":1627458141,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627458141","product_id":100017301,"comment_content":"golang语言的底层 map数据结构，散列冲突使用的开放寻址法，支持动态扩容","like_count":0},{"had_liked":false,"id":297691,"user_name":"海崖","can_delete":false,"product_type":"c1","uid":2552745,"ip_address":"","ucode":"9D42E0B0D30A56","user_header":"https://static001.geekbang.org/account/avatar/00/26/f3/a9/bb9d8450.jpg","comment_is_top":false,"comment_ctime":1623734173,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623734173","product_id":100017301,"comment_content":"叮~打卡","like_count":0},{"had_liked":false,"id":293015,"user_name":"颜桦","can_delete":false,"product_type":"c1","uid":1099576,"ip_address":"","ucode":"1CD7250E052B32","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/38/d1a50cd6.jpg","comment_is_top":false,"comment_ctime":1621156470,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621156470","product_id":100017301,"comment_content":"看完当时很懂，但是没有实际应用，很快就忘了怎么弄","like_count":0},{"had_liked":false,"id":291172,"user_name":"小菠萝🍍","can_delete":false,"product_type":"c1","uid":1686410,"ip_address":"","ucode":"DA814203C6C062","user_header":"https://static001.geekbang.org/account/avatar/00/19/bb/8a/d33d9d3f.jpg","comment_is_top":false,"comment_ctime":1620097394,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620097394","product_id":100017301,"comment_content":"在数据容量是2^n，扩容机制是原容量的2倍的前提下，数据的搬移操作可以有更高效的方式，对象经过散列函数计算得到的hash值是确定的，那么扩容后，只需要判断高hash值的高一位是否是1，就能够确定该元素是否有发生位置变化。<br>举例：原容量是16（10000），扩容后容量是32（100000）<br>假如hash值是31（11111），在原数组的下标位置是【31&amp;(16-1)=15】，扩容后，hash值的高一位是【31&amp;(32-1)=1】，所以该对象在扩容后的数组位置是【原数组位置下标（15）+原数组容量（16）=31】。<br>这样就不用再重新过一遍哈希值映射的整个过程了。<br>（个人理解，希望交流！）<br>","like_count":0},{"had_liked":false,"id":286259,"user_name":"李叶","can_delete":false,"product_type":"c1","uid":1470449,"ip_address":"","ucode":"41B33FA8526E48","user_header":"https://static001.geekbang.org/account/avatar/00/16/6f/f1/35f9f16f.jpg","comment_is_top":false,"comment_ctime":1617235479,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617235479","product_id":100017301,"comment_content":"散列表设计考虑因素：散列函数设计，装载因子动态扩容以及解决散列冲突<br>","like_count":0},{"had_liked":false,"id":283102,"user_name":"十一","can_delete":false,"product_type":"c1","uid":2337786,"ip_address":"","ucode":"69B763F6A7EFDB","user_header":"https://static001.geekbang.org/account/avatar/00/23/ab/fa/158f7b1a.jpg","comment_is_top":false,"comment_ctime":1615546761,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615546761","product_id":100017301,"comment_content":"copy on write","like_count":0},{"had_liked":false,"id":271041,"user_name":"叫我古竣歌","can_delete":false,"product_type":"c1","uid":1243290,"ip_address":"","ucode":"839C48EBA99E67","user_header":"https://static001.geekbang.org/account/avatar/00/12/f8/9a/2f474788.jpg","comment_is_top":false,"comment_ctime":1609379946,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1609379946","product_id":100017301,"comment_content":"文中提到：“序列化起来就没那么容易。你可不要小看序列化，很多场合都会用到的。我们后面就有一节会讲什么是数据结构序列化、如何序列化，以及为什么要序列化”。但是看了后面的章节，都没找到，是不是忘了？","like_count":0,"discussions":[{"author":{"id":1244845,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fe/ad/7fa85a7d.jpg","nickname":"放飞心情","note":"","ucode":"75A2192D91D86C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":395418,"discussion_content":"同样没找到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632302831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":251657,"user_name":"hailowell","can_delete":false,"product_type":"c1","uid":1195572,"ip_address":"","ucode":"557DCAB01710AB","user_header":"","comment_is_top":false,"comment_ctime":1601776752,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601776752","product_id":100017301,"comment_content":"数组的动态扩容，如果直接拼接呢？长度为a的数组扩容，不是开辟一块2a的数组然后将数据放过去，而是直接开辟一块长度为a的数组，存取数据时将下标除一下a就知道数据要在第几块数组中。如果是顺序存的数组 存满再扩容，可以直接标出第几块数组当前下标是几，这些封装为一个类。就是多的这一个除法运算的消耗和相比起来节省的扩容操作时间带来的平滑体验以及减少扩容操作空间的占用比起来不知道是否合适","like_count":0},{"had_liked":false,"id":244794,"user_name":"JerryZhu","can_delete":false,"product_type":"c1","uid":1591223,"ip_address":"","ucode":"76850CD45786C1","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","comment_is_top":false,"comment_ctime":1598680404,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598680404","product_id":100017301,"comment_content":"这个真心非常重要， 而且作为面试题中 最最最常见的 hashmap的各种源码分析， 其实理论都是建立在老师讲的这些，曾经很多理解不清楚， 现在听完课后  回过头再看看 hashmap源码， 又更加对里面的实现细节有更好的理解， 更加佩服jdk团队了。。 太强了！","like_count":0},{"had_liked":false,"id":242304,"user_name":"吴亮","can_delete":false,"product_type":"c1","uid":1670534,"ip_address":"","ucode":"8CD347A3351AB3","user_header":"https://static001.geekbang.org/account/avatar/00/19/7d/86/be31f744.jpg","comment_is_top":false,"comment_ctime":1597665679,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597665679","product_id":100017301,"comment_content":"厉害，学习到了，感谢分享","like_count":0},{"had_liked":false,"id":240919,"user_name":"ipofss","can_delete":false,"product_type":"c1","uid":1018620,"ip_address":"","ucode":"DE3061C9259F9E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/fc/d1dd57dd.jpg","comment_is_top":false,"comment_ctime":1597117234,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597117234","product_id":100017301,"comment_content":"以后在需要的时候，可以把这篇拿出来再来一遍","like_count":0},{"had_liked":false,"id":237625,"user_name":"Jenchih","can_delete":false,"product_type":"c1","uid":1426211,"ip_address":"","ucode":"0B363C30F1A83C","user_header":"https://static001.geekbang.org/account/avatar/00/15/c3/23/888ef9c5.jpg","comment_is_top":false,"comment_ctime":1595904878,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595904878","product_id":100017301,"comment_content":"链地址法，就是把相同key的value用链表串起来。那么，当用这些相同的key取值时，会得到这个链表，可是链表里有多个值，要返回哪一个值给用户？","like_count":0},{"had_liked":false,"id":235905,"user_name":"红豆成香","can_delete":false,"product_type":"c1","uid":1488601,"ip_address":"","ucode":"FB8FBB639B4BA6","user_header":"https://static001.geekbang.org/account/avatar/00/16/b6/d9/4d8a4d4c.jpg","comment_is_top":false,"comment_ctime":1595238971,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595238971","product_id":100017301,"comment_content":"面试遇到一个问题：HashMap的默认装载因子为什么是0.75","like_count":0},{"had_liked":false,"id":229326,"user_name":"just__","can_delete":false,"product_type":"c1","uid":1055900,"ip_address":"","ucode":"6F2E34657F34A4","user_header":"https://static001.geekbang.org/account/avatar/00/10/1c/9c/4562ec97.jpg","comment_is_top":false,"comment_ctime":1592965853,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592965853","product_id":100017301,"comment_content":"将单词中每个字母的ASCll 码值“进位”相加，然后再跟散列表的大小求余、取模，作为散列值，  请问这个是什么意思？ 那个代码没看懂","like_count":0},{"had_liked":false,"id":227092,"user_name":"Ivan.Qi","can_delete":false,"product_type":"c1","uid":1099170,"ip_address":"","ucode":"36F46A4D1F0EAA","user_header":"https://static001.geekbang.org/account/avatar/00/10/c5/a2/4ece341b.jpg","comment_is_top":false,"comment_ctime":1592281717,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592281717","product_id":100017301,"comment_content":"PHP内核Hash Table 学习笔记<br>https:&#47;&#47;github.com&#47;Ivanqi&#47;algorithm&#47;blob&#47;master&#47;hash_table&#47;php_hash.md","like_count":0},{"had_liked":false,"id":226340,"user_name":",","can_delete":false,"product_type":"c1","uid":1439568,"ip_address":"","ucode":"191431A878D7B6","user_header":"https://static001.geekbang.org/account/avatar/00/15/f7/50/cbfe1bc0.jpg","comment_is_top":false,"comment_ctime":1592041250,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592041250","product_id":100017301,"comment_content":"那散列表遍历的时候应该怎样遍历，如果检查每个槽效率确是不高，老师有没有什么好的想法呀","like_count":0},{"had_liked":false,"id":224736,"user_name":"Lessen","can_delete":false,"product_type":"c1","uid":1724750,"ip_address":"","ucode":"EB4D9CB70814A7","user_header":"https://static001.geekbang.org/account/avatar/00/1a/51/4e/d057fad7.jpg","comment_is_top":false,"comment_ctime":1591524575,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591524575","product_id":100017301,"comment_content":"开放定址法可以采用改造hash table来解决内存空间浪费的问题","like_count":0},{"had_liked":false,"id":214931,"user_name":"Geek_ac7784","can_delete":false,"product_type":"c1","uid":1981613,"ip_address":"","ucode":"62F0E5E6D6F4BA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/8Dj4ugujXwY24G8pcpgDFGiciarXetG3ItQ4M9mSQMLyRdRRXEXXJVfib48mGUQAu87QcvImwyJIVJlEFeEguV44w/132","comment_is_top":false,"comment_ctime":1588852748,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588852748","product_id":100017301,"comment_content":"学习笔记<br>1. 动态扩容的时间复杂度:摊还分析 平均应该是O(1)。这里提醒下摊还分析的利用。动态扩容可以维护新旧两个散列表。每次插入新表，就拿一个旧表的数据放入新表。防止一次性占用太多时间。<br>2. 哈希函数: <br>3. 装载因子与动态扩容：开放寻址法要小，链表法可适当大一些<br>4. 冲突解决:<br>    1. 开放寻址法:优:数组存储便于序列化、cpu缓存优化；缺:装载因子不能过高、冲突代价高<br>    2. 链表法:优:装在因子可高，且链表改用红黑树能优化性能。缺:占空间，适合大对象<br>5. 工业级哈希表的评价:<br>    1. 快速插入、删除、查找。应该的<br>    2. 内存占用合理，对应装载因子和动态扩容<br>    3. 性能稳定。对应冲突解决机制。<br>思考题:<br>c++中的unordered_map<br>1. 链表法解决冲突，每一个链表叫哈希桶<br>2. 装载因子大致为1，支持动态扩容","like_count":0},{"had_liked":false,"id":213489,"user_name":"Sunny","can_delete":false,"product_type":"c1","uid":1305257,"ip_address":"","ucode":"BB7B274CE0672E","user_header":"https://static001.geekbang.org/account/avatar/00/13/ea/a9/0a917f2c.jpg","comment_is_top":false,"comment_ctime":1588432124,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588432124","product_id":100017301,"comment_content":"将单词中每个字母的ASCll 码值“进位”相加，然后再跟散列表的大小求余、取模，作为散列值。进位相加是啥意思？没看懂","like_count":0},{"had_liked":false,"id":212279,"user_name":"Allan","can_delete":false,"product_type":"c1","uid":1310388,"ip_address":"","ucode":"8DA4DBECC2C45C","user_header":"https://static001.geekbang.org/account/avatar/00/13/fe/b4/295338e7.jpg","comment_is_top":false,"comment_ctime":1588083070,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588083070","product_id":100017301,"comment_content":"60天攻克算法打卡行动第16天<br><br>学习内容 :掌握散列表的设计方法和应用场景，我们就可以在保证散列表性能的前提下，设计出工业级水平的散列表。<br><br>1.如何设计散列函数？<br>设计不能太复杂；散列函数生成的值要尽可能随机并且均匀分布。<br>-&gt;数据分析法：取数据后几位作为散列值<br>-&gt;散列函数 求余、取模<br><br>2.装载因子过大了怎么办？<br>装载因子越大表示空闲位置越少，那么冲突概率就会越大。需要动态扩容。<br>3.如何避免低效地扩容？<br>扩容的时候不是一次性将老数据移动到新地址，而是每次插入时候伴随的迁移老数据。同时查询的时候也是为了兼容老的散列表，先从新的表中 查找，如果没有找到再从老得表中找，如果还没有找到则就是没有。<br>4.如何选择冲突解决方法？<br>-》上节讲了两个解决冲突问题，寻址法和链表法。<br>寻址法要求装载因子的上线不能太大，这也导致这种方法比链表法更浪费内从空间。ThreadLocalMap<br>基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，比起寻址法更加灵活，支持更多的优化策略，比如用 红黑树代替链表。<br><br>5.工业级散列表怎么应用？<br>Java 的HashMap 散列表 初始大小 16 装载因子默认0.75 超过 0.76 * capacity（散列表的容量）适合，就会启动扩容，每次为原来的两倍。<br><br>查询，插入，删除速度要快，不能给用户体验差。<br>占用内存尽量要少，因为内存很贵，而且要灵活扩容，性能要好。<br>如何设计：那么就是我们今天学到的，选择合适的散列函数，选择合适的解决冲突方法寻址法和链表法，装载因子要设计合理并且合设计动态扩容策略。","like_count":0},{"had_liked":false,"id":211210,"user_name":"亢（知行合一的路上）","can_delete":false,"product_type":"c1","uid":1347013,"ip_address":"","ucode":"958AF7C96EB9E8","user_header":"https://static001.geekbang.org/account/avatar/00/14/8d/c5/898b13b4.jpg","comment_is_top":false,"comment_ctime":1587915437,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587915437","product_id":100017301,"comment_content":"使用均摊的思想，将扩容操作穿插在插入操作的过程中，分批完成，真是妙啊！<br>我们平时是不是也可以使用均摊的思想呢？例如，有很多零碎的杂事，不要积攒到一起，连续花费很长时间完成，而是累了、休息时完成一件，这样慢慢就处理掉了，而且没感觉花大块时间，尝试一下哈","like_count":0},{"had_liked":false,"id":210451,"user_name":"Hubbert伟涛","can_delete":false,"product_type":"c1","uid":1303556,"ip_address":"","ucode":"000C6A0BD4A102","user_header":"https://static001.geekbang.org/account/avatar/00/13/e4/04/05677b68.jpg","comment_is_top":false,"comment_ctime":1587746240,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587746240","product_id":100017301,"comment_content":"网上查找的博客资料<br>C#的Dictionary（键值对，字典）采用链表法处理碰撞。<br>HashTable开放寻址法方法中的双重散列处理碰撞","like_count":0},{"had_liked":false,"id":205090,"user_name":"Steven.Tudou_yang","can_delete":false,"product_type":"c1","uid":1853517,"ip_address":"","ucode":"1B1C4418A0BFB2","user_header":"https://static001.geekbang.org/account/avatar/00/1c/48/4d/993204ff.jpg","comment_is_top":false,"comment_ctime":1586526238,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1586526238","product_id":100017301,"comment_content":"如果一个散列表的装载因子设置的不合理启动了动态扩容，会不会本次新旧散列刚刚迁移完之后又启动了下一次的动态扩容呢？","like_count":0,"discussions":[{"author":{"id":1251917,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1a/4d/932e54e1.jpg","nickname":"天黑要睡觉","note":"","ucode":"A73FB0AFC690EE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":231921,"discussion_content":"两倍没那么快占满啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586838799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":201073,"user_name":"蜗牛","can_delete":false,"product_type":"c1","uid":1086220,"ip_address":"","ucode":"01CC18F12E556D","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/0c/0a6a0d5e.jpg","comment_is_top":false,"comment_ctime":1585712164,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585712164","product_id":100017301,"comment_content":"Java中的hashMap，使用的就是散列表实现，散列函数设计师通过hashcode的高低位运算得出，<br>散列冲突是通过链表法，并且当链表数据过多的时候，会转换成红黑树。hashmap支持动态扩容。","like_count":0},{"had_liked":false,"id":198589,"user_name":"zhimin","can_delete":false,"product_type":"c1","uid":1312130,"ip_address":"","ucode":"DF6DFBEF6FA297","user_header":"https://static001.geekbang.org/account/avatar/00/14/05/82/51cd0a50.jpg","comment_is_top":false,"comment_ctime":1585458260,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585458260","product_id":100017301,"comment_content":"redis 也广泛应用用redis， redis中数据库和哈希键，数据类型是集合、哈希、有序集合当存储的数目大于某个特定值之后都采用hashtable存储， hash算法采用目前比较流行的 murmurhash算法，利用链式解决冲突，当空间不足时， 分配大于当前数目*2的，且是2的n次方的数目的空间，内部通过维护两个hashtable 来渐进式rehash。","like_count":0},{"had_liked":false,"id":198577,"user_name":"zhimin","can_delete":false,"product_type":"c1","uid":1312130,"ip_address":"","ucode":"DF6DFBEF6FA297","user_header":"https://static001.geekbang.org/account/avatar/00/14/05/82/51cd0a50.jpg","comment_is_top":false,"comment_ctime":1585457635,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585457635","product_id":100017301,"comment_content":"hashtable在php中也被广泛的应用， zend引擎中使用hashtable存储变量表，常量表，函数等， php的数组也是基于hashtable实现的。 数据结构的设计采用bucket桶和hashtable 两种结构构成完整的Hashtable， bucket桶存储的是hash的key的逻辑，同一hashkey的桶通过链地址法解决冲突， Hashtable 来管理bucket桶，存储整体hashtable的大小，如果空间不够的时， 通过分配大于当前大小的且是2的n次方的空间，来扩容。 ","like_count":0},{"had_liked":false,"id":196300,"user_name":"Geek_112e68","can_delete":false,"product_type":"c1","uid":1644011,"ip_address":"","ucode":"82843584C97F43","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/WhoLIb4HZtuwErPetUjHj9JVOYFibDXDAcIic3K0CSzJp4zibe1cemraIq1S8YSN5KSCJcUdicm9f4aKTwZHxFBwTw/132","comment_is_top":false,"comment_ctime":1585271009,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585271009","product_id":100017301,"comment_content":"还是要理解Java集合类的源码","like_count":0},{"had_liked":false,"id":190161,"user_name":"小谢","can_delete":false,"product_type":"c1","uid":1879476,"ip_address":"","ucode":"82D54A61D2FDB9","user_header":"https://static001.geekbang.org/account/avatar/00/1c/ad/b4/e4dcd4d7.jpg","comment_is_top":false,"comment_ctime":1584608496,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584608496","product_id":100017301,"comment_content":"1.散列函数的常用设计方法<br>             1.数据分析法<br>             2.与表长进行求模取余<br>2.装载因子<br>              选取合适的阈值<br>3.低效扩容<br>             不要到达阈值一步到位扩容，而是到达阈值之后插入新元素移动老元素，查找先查找新的hash表再查找老hash表<br>4.如何选择冲突的解决方法<br>             根据数据元素的特点:少字节小——&gt;开放寻址法，对cpu缓存友好<br>                                            数据量大字节大——&gt;链表法，链表转化为其他的数据结构","like_count":0},{"had_liked":false,"id":174771,"user_name":"一路向北","can_delete":false,"product_type":"c1","uid":1050287,"ip_address":"","ucode":"19322F21C0235B","user_header":"https://static001.geekbang.org/account/avatar/00/10/06/af/f7e562fb.jpg","comment_is_top":false,"comment_ctime":1580376431,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580376431","product_id":100017301,"comment_content":"ConcurrentHashMap  的 散列函数，基于链表解决散列 冲突的，同时使用了分段锁保证了数据线程安全。<br>    private static int hash(int h) {<br>        h += h &lt;&lt; 15 ^ -12931;<br>        h ^= h &gt;&gt;&gt; 10;<br>        h += h &lt;&lt; 3;<br>        h ^= h &gt;&gt;&gt; 6;<br>        h += (h &lt;&lt; 2) + (h &lt;&lt; 14);<br>        return h ^ h &gt;&gt;&gt; 16;<br>    }<br><br>  public V put(K key, V value) {<br>        if (value == null) {<br>            throw new NullPointerException();<br>        } else {<br>            int hash = hashOf(key);<br>            return this.segmentFor(hash).put(key, hash, value, false);<br>        }<br>    }<br><br>private static int hashOf(Object key) {<br>        return hash(key.hashCode());<br>    }<br><br><br> V put(K key, int hash, V value, boolean onlyIfAbsent) {<br>            this.lock();<br><br>            Object var11;<br>            try {<br>                int c = this.count;<br>                if (c++ &gt; this.threshold) {<br>                    int reduced = this.rehash();<br>                    if (reduced &gt; 0) {<br>                        this.count = (c -= reduced) - 1;<br>                    }<br>                }<br><br>                ConcurrentHashMap.HashEntry&lt;K, V&gt;[] tab = this.table;<br>                int index = hash &amp; tab.length - 1;<br>                ConcurrentHashMap.HashEntry&lt;K, V&gt; first = tab[index];<br><br>                ConcurrentHashMap.HashEntry e;<br>                for(e = first; e != null &amp;&amp; (e.hash != hash || !keyEq(key, e.key())); e = e.next) {<br>                    ;<br>                }<br><br>                Object oldValue;<br>                if (e != null) {<br>                    oldValue = e.value();<br>                    if (!onlyIfAbsent) {<br>                        e.setValue(value);<br>                    }<br>                } else {<br>                    oldValue = null;<br>                    ++this.modCount;<br>                    tab[index] = this.newHashEntry(key, hash, first, value);<br>                    this.count = c;<br>                }<br><br>                var11 = oldValue;<br>            } finally {<br>                this.unlock();<br>            }<br><br>            return var11;<br>        }","like_count":0},{"had_liked":false,"id":173432,"user_name":"pikachu122","can_delete":false,"product_type":"c1","uid":1689365,"ip_address":"","ucode":"43FE4DBC872FFA","user_header":"https://static001.geekbang.org/account/avatar/00/19/c7/15/24bf166a.jpg","comment_is_top":false,"comment_ctime":1579534429,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579534429","product_id":100017301,"comment_content":"1、散列表只有在理想情况下才能获得O(1)的时间复杂度。实际应用中，散列函数和装载因子阈值的选择对散列表性能有很大的影响。甚至攻击者会利用设计好的恶意数据使散列到同一个槽，使得散列表性能下降导致占用计算资源进行散列表碰撞攻击。<br>2、一个好的散列函数不能太复杂，否则计算需要消耗大量时间。而且散列函数的结果要尽可能随机并均匀分布，最小化散列冲突。常用的散列函数设计方法有数据分析法、直接寻址法、平方取中法、折叠法、随机数法等。<br>3、装载因子过大，插入可能需要多次寻址或遍历很长的链表而影响性能。对于动态散列表，常用的方法是动态扩容。为了均摊时间复杂度，当装载因子超过阈值时，申请一个2倍大小的新内存空间。然后每次插入数据时，在插入新数据后都从老散列表搬移一个数据到新散列表。查找时先在新散列表查找，如果找不到再去老散列表查找。此时的任何操作的时间复杂度均为O(1)。<br>4、开放寻址法和链表法是两种常用的冲突解决方法。开放寻址法可以利用CPU缓存加速，且容易序列化。缺点则是删除数据比较麻烦、冲突代价更高以及较为浪费内存空间。链表法内存利用率高、且对大装载因子的情况性能更好。而且链表法的优化策略更加灵活，将链表改造为跳表、红黑树等其他更高效的结构，查询效率即便退化也是O(logn)，可以抵御散列碰撞攻击。但缺点是对小的对象存储消耗内存（因为需要存储指针），且因为数据零散，对CPU缓存不友好。开放寻址法用于数据量小、装载因子小的情况。链表法适用于大对象、大数据量的情况。","like_count":0},{"had_liked":false,"id":168983,"user_name":"杰瑞的Jerry","can_delete":false,"product_type":"c1","uid":1690017,"ip_address":"","ucode":"5FBF22B528B721","user_header":"https://static001.geekbang.org/account/avatar/00/19/c9/a1/24c2e54e.jpg","comment_is_top":false,"comment_ctime":1578232489,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1578232489","product_id":100017301,"comment_content":"学完本节打卡：<br><br>散列表攻击基本原理：通过精心构造的数据，使得所有数据经过散列函数之后，都落到同一个槽里，散列表会退化为链表，查询的时间复杂度从O(1)急剧退化为O(n)。<br><br>一个好的散列函数，首先不能太复杂，其次散列函数生成的值要尽可能随机并且均匀分布，避免散列冲突。装载因子过大时，可以动态对散列表进行扩容。<br>插入一个数据，最好情况下，不需要扩容，最好时间复杂度为O(1)，最坏情况下，散列表装载因子过高，扩容重新申请内存，计算哈希值，搬移数据，时间复杂度O(n)。均摊情况下，时间复杂度O(1)。<br><br>避免低效扩容：一次性扩容太耗时，可以分批次扩容。有新数据时，将新数据插入新散列表中，同时从老的散列表中拿出一个数据放入到新散列表中。","like_count":0},{"had_liked":false,"id":167427,"user_name":"iamjohnnyzhuang","can_delete":false,"product_type":"c1","uid":1015327,"ip_address":"","ucode":"E694C1828907F6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/1f/b1d458a9.jpg","comment_is_top":false,"comment_ctime":1577792077,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577792077","product_id":100017301,"comment_content":"Java的HashMap中，如果有冲突，需要将数据插入到链表中。这里插入用的是头插法，即插入到链表的第一个元素。这样做就节省了遍历插入的耗时。虽然过程很简单但是感觉也挺巧妙的。😀","like_count":0},{"had_liked":false,"id":164250,"user_name":"第四单元","can_delete":false,"product_type":"c1","uid":1747184,"ip_address":"","ucode":"3ED9D553E1DE17","user_header":"https://static001.geekbang.org/account/avatar/00/1a/a8/f0/529f15e9.jpg","comment_is_top":false,"comment_ctime":1576916095,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576916095","product_id":100017301,"comment_content":"”而且，在开放寻址法中，所有的数据都存储在一个数组中，比起链表法来说，冲突的代价更高。“ 这里怎么理解？为什么冲突的代价更高呢？","like_count":0},{"had_liked":false,"id":164244,"user_name":"seven","can_delete":false,"product_type":"c1","uid":1180307,"ip_address":"","ucode":"55CE5F60051F89","user_header":"https://static001.geekbang.org/account/avatar/00/12/02/93/44672231.jpg","comment_is_top":false,"comment_ctime":1576915082,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576915082","product_id":100017301,"comment_content":"php中的array用的就是hashmap，当数组里面的可以是连续的，例如0,1,2,3...用的是开放寻址（被称为packed_array），数组中key不连续或者是字符串的时候用的是链式寻址,称为hash_array","like_count":0},{"had_liked":false,"id":161818,"user_name":"毛启圣","can_delete":false,"product_type":"c1","uid":1330056,"ip_address":"","ucode":"233DA95ED28C11","user_header":"https://static001.geekbang.org/account/avatar/00/14/4b/88/272b4562.jpg","comment_is_top":false,"comment_ctime":1576339204,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576339204","product_id":100017301,"comment_content":"java ，作者讲过 HashMap。<br>散列函数，hashcode 高16位和低16位 求异或，然后在求模<br>散列 + （链表&#47;红黑数）<br>","like_count":0},{"had_liked":false,"id":161211,"user_name":"immortaliii","can_delete":false,"product_type":"c1","uid":1309441,"ip_address":"","ucode":"ACF57BD721E1B8","user_header":"https://static001.geekbang.org/account/avatar/00/13/fb/01/313be8c8.jpg","comment_is_top":false,"comment_ctime":1576148965,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576148965","product_id":100017301,"comment_content":"PHP的数组是通过散列表实现的，散列冲突是通过链表法处理的，数组满了会自动扩容size加倍","like_count":0},{"had_liked":false,"id":161131,"user_name":"大海","can_delete":false,"product_type":"c1","uid":1001446,"ip_address":"","ucode":"20913D0265971B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/47/e6/67b0b711.jpg","comment_is_top":false,"comment_ctime":1576126079,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576126079","product_id":100017301,"comment_content":"js 里面的对象是基于散列表的","like_count":0},{"had_liked":false,"id":160616,"user_name":"Jie","can_delete":false,"product_type":"c1","uid":1045078,"ip_address":"","ucode":"AB94041E548FEB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f2/56/c39046c0.jpg","comment_is_top":false,"comment_ctime":1575986619,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575986619","product_id":100017301,"comment_content":"老师，我觉得动态扩容图解里的hash(key) = key % 扩容前长度 这个知识点很重要，可以显示在文本中。我是看的哈希函数一致性应用那里的评论里提醒，回头才发现这个知识点的。","like_count":0},{"had_liked":false,"id":160344,"user_name":"梦想的优惠券","can_delete":false,"product_type":"c1","uid":1257418,"ip_address":"","ucode":"D3B44F6C618CA7","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/ca/cbce6e94.jpg","comment_is_top":false,"comment_ctime":1575938938,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1575938938","product_id":100017301,"comment_content":"打卡<br>","like_count":0},{"had_liked":false,"id":160290,"user_name":"阿冰777","can_delete":false,"product_type":"c1","uid":1373893,"ip_address":"","ucode":"F365EB44F971F3","user_header":"https://static001.geekbang.org/account/avatar/00/14/f6/c5/6329ddcc.jpg","comment_is_top":false,"comment_ctime":1575905673,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1575905673","product_id":100017301,"comment_content":"在javascript的v8引擎里,hashcode函数是一个随机数,所以我们不能重新计算(因为是随机的,重新计算会变)所以我们采用一次计算,终身保存的方式来实现散列表.那么存在哪里呢?js对象有两个字(word,相当于不同的存储空间,可以理解为数据库表的不同字段)一个存储空间叫elements backing store用来存储所有的下标是整数或者可以转化成整数的元素,就是数组,比如obj[1] = &quot;a&quot;;或者obj[&quot;1&quot;]=&quot;a&quot;这个存储空间里没有多余的空间来存hash值,所以放弃, 另一个字用来存储字符串一样的属性(properties backing store)比如 obj[&quot;a&quot;]=&quot;b&quot;. 这个存储空间有三种情况,第一种情况,这个对象是空对象,或者是纯数组,那么我们就在直接在这里的偏移量上存储hash值.第二种情况,这是一个数组(另一种数组,FixedArray,他的存储方式是偶数存变量名,奇数存属性.前面elements里的数组是无限空间的,这里的长度是有限的,v8里是1022) 这个数组的length因为是有限的(为了性能考虑,超出自动变成字典),但是我们是用一个整型(31位)来存储这个数组的长度,其实我们用10位就可以表示最多1022长度的数组长度了,所以我们可以用21位来存储他的hashcode.(神了)<br>第三种情况,这个区域存的是字典,那么我们就把hashcode存在开头的第一个里,当作是他的额外属性.(为什么一开始不用这种方法,因为要省空间...)<br>","like_count":0},{"had_liked":false,"id":154701,"user_name":"Mr.差不多","can_delete":false,"product_type":"c1","uid":1437292,"ip_address":"","ucode":"946555FCAE710B","user_header":"https://static001.geekbang.org/account/avatar/00/15/ee/6c/246fa0d1.jpg","comment_is_top":false,"comment_ctime":1574514710,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574514710","product_id":100017301,"comment_content":"老师您好，为什么在HashMap中产生冲突后要用红黑树而不用B+树呢？","like_count":0},{"had_liked":false,"id":153878,"user_name":"Sun Fei","can_delete":false,"product_type":"c1","uid":1032631,"ip_address":"","ucode":"092EC0992050BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c1/b7/57f153f6.jpg","comment_is_top":false,"comment_ctime":1574324323,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574324323","product_id":100017301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":153799,"user_name":"三年过后","can_delete":false,"product_type":"c1","uid":1283157,"ip_address":"","ucode":"5E9106C5F11BED","user_header":"https://static001.geekbang.org/account/avatar/00/13/94/55/afc64956.jpg","comment_is_top":false,"comment_ctime":1574308664,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574308664","product_id":100017301,"comment_content":"mycat 分库分表","like_count":0},{"had_liked":false,"id":153162,"user_name":"Geek_949cc1","can_delete":false,"product_type":"c1","uid":1690476,"ip_address":"","ucode":"F8ACDBF2FA8CC2","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKFRiaFrpOTVBuKicMficasBFuF2VY7EnUnLeFcvIn0R5OiaQsOcpJHNM5TusoPHMjIvSfia46c0EWH9mQ/132","comment_is_top":false,"comment_ctime":1574171657,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574171657","product_id":100017301,"comment_content":"老师，我感觉在动态扩容时，对散列表的数据进行搬移时，没说散列函数该怎么设计，我感觉散列函数怎么变，在那边还是会出现冲突，只是感觉在使用线性探测的时候可能时间复杂度有一定的降低。下来再去看看扩容的散列表的散列函数设计吧！！！！","like_count":0},{"had_liked":false,"id":150227,"user_name":"王加武","can_delete":false,"product_type":"c1","uid":1665471,"ip_address":"","ucode":"DDCFE578C6C428","user_header":"https://static001.geekbang.org/account/avatar/00/19/69/bf/50a824a4.jpg","comment_is_top":false,"comment_ctime":1573481233,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573481233","product_id":100017301,"comment_content":"JAVA中的HashMap,HashSet,HashTable等等都是使用散列表来实现的，HashTable和HashSet其实都是基于HashMap来实现的，他们采用的均是数组 + 链表的形式，但是在使用这些工业级的函数的时候，最好先规定他们的大小，否则来来回回的扩容操作非常的消耗内存的，涉及到数据的搬移和内存的申请","like_count":0},{"had_liked":false,"id":149840,"user_name":"佳楠","can_delete":false,"product_type":"c1","uid":1008809,"ip_address":"","ucode":"A1698AE91992AA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/64/a9/27d63f2e.jpg","comment_is_top":false,"comment_ctime":1573399631,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573399631","product_id":100017301,"comment_content":"如何实现这样一个散列表呢？<br>设计一个合适的散列函数<br>定义装载因子阈值，并且设计动态扩容策略<br>选择合适的散列冲突解决方法<br>Hash 随机性<br>环境信息：JDK 1.8<br>以 Java HashMap 为例进行分析，示例中我们使用 key 为 String 为例进行分析<br>Hash 函数<br>1static final int hash(Object key) {<br>2    int h;<br>3    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);<br>4}<br>到这里，可以会有疑惑，hashCode 本身就有 41 亿空间的随机性，为什么还要做这一步呢？我们继续往下看。<br>1final V putVal(int hash, K key) {<br>2    ......<br>3    if ((p = tab[i = (n - 1) &amp; hash]) == null)<br>4        tab[i] = newNode(hash, key, value, null);<br>5    ......<br>6}<br>我们此处的本意是想：Hash % Capcity 得出截取后的下标值，但由于位与的运行效率远高于取模运算，这里用到了如下转换公式：<br>，所以数组的容量也是以  为单位扩容的。<br>1证明很好理解，比如 B = 8, B - 1 = 7，转换成二进制后做取模操作，保留除最高位的所有低位。<br>2在非负数部分，表现出来的行为和取模一致。<br>3&amp; 1000 =&gt; A = 8<br>4  0111 =&gt; B - 1 = 7<br>5-------<br>6  0000<br>现在我们再回去看 Hash 函数的移位并自身与或的操作，解决了 2 个问题<br>数组容量无法达到 40 多亿那么大。<br>由于数组容量限制，经过  Hash % Capcity 操作后，大多是情况下只能保留低位，位移 16 位能让高位的反应到低位上<br>为啥与或？因为最不稳定啊，增加随机性。<br>Java 内一切 Object 均有 hashCode 方法，String 的重写方法如下<br> 1&#47;&#47; int 取值范围：-21亿 ～ 21 亿<br> 2public int hashCode() {<br> 3    int h = hash; &#47;&#47; hash 默认初始化值为 0<br> 4    if (h == 0 &amp;&amp; value.length &gt; 0) {<br> 5        char val[] = value;<br> 6<br> 7        for (int i = 0; i &lt; value.length; i++) {<br> 8            h = 31 * h + val[i];<br> 9        }<br>10        hash = h;<br>11    }<br>12    return h;<br>13}<br>Hash 算法原理：s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]，其中 n 代表字符串长度，31 是什么寓意？<br>此处写法虽可读性略差，但面对超长字符串时，会有更好的性能。不然让计算机算个 31^1100，会直接得出 Infinity 的结果。<br>动态扩容能力<br>需要关注的问题：如果保证扩容操作，不会影响相关读取和写入的性能<br>容量上限为：static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;<br>面对极端情况，比如大量 Hash 碰撞，是否会出现线性退化<br>如果碰到 Hash 碰撞，会进行树存储，注意此处 Key 也会被传入，用于后续的精确取值<br>1else if (p instanceof TreeNode)<br>2    e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);","like_count":0},{"had_liked":false,"id":142890,"user_name":"小喵喵","can_delete":false,"product_type":"c1","uid":1062444,"ip_address":"","ucode":"FDBBB2A59DB8B6","user_header":"https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg","comment_is_top":false,"comment_ctime":1571576874,"is_pvip":false,"replies":[{"id":"55212","content":"我觉得没有直接关系呢。不过，字典你指的是什么呢？某种编程语言中的字典？还是某种业务概念上的字典呢？","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1571615031,"ip_address":"","comment_id":142890,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571576874","product_id":100017301,"comment_content":"散列表（hashtable）和字典有什么区别呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471313,"discussion_content":"我觉得没有直接关系呢。不过，字典你指的是什么呢？某种编程语言中的字典？还是某种业务概念上的字典呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571615031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141300,"user_name":"xuanyuan","can_delete":false,"product_type":"c1","uid":1113737,"ip_address":"","ucode":"1EC79B9372868F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2icbib62icXtibTkThtyRksbuJLoTLMts7zook2S30MiaBtbz0f5JskwYicwqXkhpYfvCpuYkcvPTibEaQ/132","comment_is_top":false,"comment_ctime":1571138219,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571138219","product_id":100017301,"comment_content":"31，0.75 这种魔数都是有讲究的。另外能对比不同语言的实现，就再好不过了，找时间自己整理下","like_count":0},{"had_liked":false,"id":133229,"user_name":"方晓斌","can_delete":false,"product_type":"c1","uid":1042367,"ip_address":"","ucode":"A26FA55F05FE9E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e7/bf/b6dd86f4.jpg","comment_is_top":false,"comment_ctime":1568453611,"is_pvip":false,"replies":[{"id":"51220","content":"应该是的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1568588388,"ip_address":"","comment_id":133229,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568453611","product_id":100017301,"comment_content":"老师我有个问题，hashmap 貌似没考虑避免低效扩容的情况。所以数据量很大时触发扩容将是灾难吧","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467306,"discussion_content":"应该是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568588388,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132978,"user_name":"Lincoln","can_delete":false,"product_type":"c1","uid":1365798,"ip_address":"","ucode":"9AA8A2F6263AE1","user_header":"https://static001.geekbang.org/account/avatar/00/14/d7/26/502f2f0a.jpg","comment_is_top":false,"comment_ctime":1568288074,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568288074","product_id":100017301,"comment_content":"lua的table，哈希部分的冲突解决是采用开放地址法","like_count":0},{"had_liked":false,"id":127522,"user_name":"chengmumu","can_delete":false,"product_type":"c1","uid":1285817,"ip_address":"","ucode":"505D1D60EF7052","user_header":"","comment_is_top":false,"comment_ctime":1566733372,"is_pvip":false,"replies":[{"id":"47232","content":"两者差不多，个人感觉纯粹是随机选的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1566773129,"ip_address":"","comment_id":127522,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566733372","product_id":100017301,"comment_content":"Java Hashmap 为什么要用红黑树而不是跳表，这是基于什么考虑。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464534,"discussion_content":"两者差不多，个人感觉纯粹是随机选的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566773129,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118643,"user_name":"王大锤DW3","can_delete":false,"product_type":"c1","uid":1127890,"ip_address":"","ucode":"EBDD13BDBEB70A","user_header":"https://static001.geekbang.org/account/avatar/00/11/35/d2/39689b0b.jpg","comment_is_top":false,"comment_ctime":1564404968,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564404968","product_id":100017301,"comment_content":"2019年7月15号买的这个课，第一次留言，看了半个月了真的非常有收获，曾经我也一样觉得数据结构算法不重要，直到真正去学习，才知道自己有多无知。对于今天这堂课，我比较在意的是HashMap中hash函数的计算，参考了下各位的解答，我的理解是，首先hashcode是32位整数，每个java对象都不一样，首先高16位与低16位异或，可以保证各位数的特征混合不丢失，只要其中1位有变化，可以立马反应出来，这个地方用&amp;或者|都是不合适的，然后得到的结果再对数组大小取模操作，当capacity 为2的幂次方的时候，A % B = A &amp; (B - 1)这个等式成立，高位都为0，目的就是取得数组的下标，得到对应的放在具体的哪个槽中。","like_count":0},{"had_liked":false,"id":115577,"user_name":"the geek","can_delete":false,"product_type":"c1","uid":1506723,"ip_address":"","ucode":"71DECBC814A539","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLz3icr3mGs5ib8FbSPQZ2ic3ib90mHkd1btQrmGacZjJxfYXrerIdaTxglKyCicFzLcEAb6deC2cWjE5Q/132","comment_is_top":false,"comment_ctime":1563634199,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563634199","product_id":100017301,"comment_content":"有一种融会贯通的感觉，以前看HashMap的源码，虽然明白了每一步是什么样子，但其实是在盲人摸象，知其然不知其所以然。现在知其全貌再去看源码能产生更多的理解","like_count":0},{"had_liked":false,"id":113514,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1563054184,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563054184","product_id":100017301,"comment_content":"哈希表总结<br>设计简单高效的散列函数，简单意味着计算量小，耗费CPU少。高效意味着分散度大，冲突少。<br>设计冲突处理，设计平衡负载，选择开放寻址法和间接寻址。开放寻找的优缺点和数组类似。优点是没有额外指针，充分利用CPU缓存，缺点是删除要额外标记，负载度高的时候退化为线性。间接寻址的优缺点类似于链表和树，需要耗费额外指针，不能利用CPU缓存，优点是更灵活，可以在链表和红黑树中切换，可以容忍更高的负载度，最差就退化为红黑树，效率还能接受。","like_count":0},{"had_liked":false,"id":112460,"user_name":"易水南风","can_delete":false,"product_type":"c1","uid":1123818,"ip_address":"","ucode":"A2A0F18228A5D0","user_header":"https://static001.geekbang.org/account/avatar/00/11/25/ea/ec869117.jpg","comment_is_top":false,"comment_ctime":1562739885,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562739885","product_id":100017301,"comment_content":"就是不知道h和h右移16位异或有什么目的？或者说对于散列函数有什么意义。","like_count":0},{"had_liked":false,"id":112384,"user_name":"易水南风","can_delete":false,"product_type":"c1","uid":1123818,"ip_address":"","ucode":"A2A0F18228A5D0","user_header":"https://static001.geekbang.org/account/avatar/00/11/25/ea/ec869117.jpg","comment_is_top":false,"comment_ctime":1562727416,"is_pvip":false,"replies":[{"id":"40904","content":"哪里看不懂呢 ","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1562739452,"ip_address":"","comment_id":112384,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562727416","product_id":100017301,"comment_content":"老师好。hashmap的散列函数为啥要先进行这一步呢 (h ^ (h &gt;&gt;&gt; 16)) ？看第一个评论还是不懂。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457711,"discussion_content":"哪里看不懂呢 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562739452,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107374,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1561521621,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561521621","product_id":100017301,"comment_content":"散列表的设计：散列函数的设计；装载因子的调优和扩容操作的设计；选择合适的冲突解决方法<br>散列函数设计：<br><br>1. 散列函数不应太复杂<br>2. 生成的值尽可能随机且均匀分布<br>常用散列函数：<br><br>1. 数据分析法<br>2. ASCII进位相加法<br>3. 直接寻址法<br>4. 平方取中法<br>5. 折叠法<br>6. 随机数法<br><br>装载因子的选择和动态扩容：<br><br>1. 权衡查找效率和空间消耗<br>2. 动态扩容时可以考虑将扩容复制操作均摊到之后的每次插入中<br><br>开放寻址法和链表法的比较：<br><br>1. 操作系统中CPU缓存机制上来看，开放寻址法更能利用好CPU缓存机制（类似于数组和链表）<br>2. 网络或持久化中涉及的序列化上看，开放寻址法序列化更为简单（也类似于数组和链表）<br>3. 从查找、删除等操作上来看，开放寻址法在装载因子小时内存浪费更大，装载因子大时解决冲突的代价更高<br>4. 链表法也更灵活，能支持更多的优化策略<br>5. 数据量小且装载因子小时适合开放寻址法，数据量大时适合链表法","like_count":0},{"had_liked":false,"id":105584,"user_name":"苦行僧","can_delete":false,"product_type":"c1","uid":1055334,"ip_address":"","ucode":"726024A9A9CF44","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/66/2d9db9ed.jpg","comment_is_top":false,"comment_ctime":1561036012,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561036012","product_id":100017301,"comment_content":"散列函数 简单高效 分布均匀 hashmap为什么这么设计hash函数 要好好看看","like_count":0},{"had_liked":false,"id":104911,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1560868262,"is_pvip":false,"replies":[{"id":"38005","content":"hashcode应该不是内存地址的。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1560900049,"ip_address":"","comment_id":104911,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560868262","product_id":100017301,"comment_content":"所以老师，我理解的对象的hashcode是内存地址，不同的是肯定不会相同的，所以重写equals方法必须要重写hascode（）方法的原因在于？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454478,"discussion_content":"hashcode应该不是内存地址的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560900049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103736,"user_name":"三个石头","can_delete":false,"product_type":"c1","uid":1110384,"ip_address":"","ucode":"A863A416D65217","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/70/a64d9498.jpg","comment_is_top":false,"comment_ctime":1560500060,"is_pvip":false,"replies":[{"id":"37646","content":"如果每次扩容都是扩容为之前的2倍或者更大，就不会存在你说的这种情况的。因为每次插入1个新数据，就搬移一个老数据。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1560641514,"ip_address":"","comment_id":103736,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560500060","product_id":100017301,"comment_content":"老师讲的避免低效扩容的方式，如果老的散列表的数据还没有完全搬移到新的散列表上，新的又需要扩容应该怎么处理","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453986,"discussion_content":"如果每次扩容都是扩容为之前的2倍或者更大，就不会存在你说的这种情况的。因为每次插入1个新数据，就搬移一个老数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560641514,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":102960,"user_name":"ILoveKindness","can_delete":false,"product_type":"c1","uid":1559444,"ip_address":"","ucode":"A6210B034AAC62","user_header":"https://static001.geekbang.org/account/avatar/00/17/cb/94/eedbace3.jpg","comment_is_top":false,"comment_ctime":1560336238,"is_pvip":false,"replies":[{"id":"37282","content":"负载因子=总数据个数&#47;槽（or桶）的个数。就相当于链表解决冲的散列表中平均链表的长度。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1560382812,"ip_address":"","comment_id":102960,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560336238","product_id":100017301,"comment_content":"老师您好，我不是很理解您所说的“必要时，负载因子可以大于1”的意思，负载因子不是指“散列表中节点的数目除以基本区域能容纳的节点数所得的商”嘛，为什么会比一大<br>请求老师解答","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453667,"discussion_content":"负载因子=总数据个数/槽（or桶）的个数。就相当于链表解决冲的散列表中平均链表的长度。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560382812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":102758,"user_name":"William","can_delete":false,"product_type":"c1","uid":1346215,"ip_address":"","ucode":"55F5D9DEE485B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","comment_is_top":false,"comment_ctime":1560302173,"is_pvip":true,"replies":[{"id":"37278","content":"意思是一样的😁","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1560382399,"ip_address":"","comment_id":102758,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560302173","product_id":100017301,"comment_content":"装载因子10什么意思？脑海中有map装载因子0.75的概念。 这个10如何理解？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453564,"discussion_content":"意思是一样的😁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560382399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101005,"user_name":"saber","can_delete":false,"product_type":"c1","uid":1193468,"ip_address":"","ucode":"D02F8D129DB41C","user_header":"https://static001.geekbang.org/account/avatar/00/12/35/fc/6d3e0035.jpg","comment_is_top":false,"comment_ctime":1559699987,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559699987","product_id":100017301,"comment_content":"https:&#47;&#47;github.com&#47;saber&#47;algorithm&#47;blob&#47;master&#47;src&#47;hash_table&#47;hash_table.hpp<br>哈希表算法的简单实现，目前还没有达到工业级哈希表，动态扩容规则仅仅用了一次性扩容。<br>代码包含注释，适合跟我一样的算法小白理解","like_count":0},{"had_liked":false,"id":100288,"user_name":"江龙","can_delete":false,"product_type":"c1","uid":1033442,"ip_address":"","ucode":"1865E545060CC9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c4/e2/3de4371d.jpg","comment_is_top":false,"comment_ctime":1559522811,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1559522811","product_id":100017301,"comment_content":"看留言想明白了。为啥右移16截取高位与原值异或，来让低位保留了高位与低位的特征。因为容量一般是很小的（默认16），如果直接&amp;，高位就直接舍掉了，两个低位相同高位不同的hash就会被映射成一个值","like_count":0},{"had_liked":false,"id":99902,"user_name":"Geek_289a38","can_delete":false,"product_type":"c1","uid":1461504,"ip_address":"","ucode":"C5BDC172C63E30","user_header":"","comment_is_top":false,"comment_ctime":1559355930,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559355930","product_id":100017301,"comment_content":"所以为了保证空间利用率，减少散列冲突，我们自己定义hashmap的容积的时候最好是2的次幂","like_count":0},{"had_liked":false,"id":99315,"user_name":"糖","can_delete":false,"product_type":"c1","uid":1542834,"ip_address":"","ucode":"784DDA19104392","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJzP9yB6eIRRyVNe3iab0gXB6yOeaNRHGx6raTQz2grfE5N2LWl6uIj1mrSU7nxiaEzeSLp6xAkE3iaQ/132","comment_is_top":false,"comment_ctime":1559191210,"is_pvip":true,"replies":[{"id":"35763","content":"就是为了尽量打散原始数据，尽量随机","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1559257715,"ip_address":"","comment_id":99315,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559191210","product_id":100017301,"comment_content":"c++中string类型的哈希函数：<br>_INLINE_VAR constexpr size_t _FNV_offset_basis = 2166136261U;<br>_INLINE_VAR constexpr size_t _FNV_prime = 16777619U;<br>_NODISCARD inline size_t _Fnv1a_append_bytes(size_t _Val,<br>\tconst unsigned char * const _First, const size_t _Count) noexcept<br>\t{\t&#47;&#47; accumulate range [_First, _First + _Count) into partial FNV-1a hash _Val<br>\tfor (size_t _Idx = 0; _Idx &lt; _Count; ++_Idx)<br>\t\t{<br>\t\t_Val ^= static_cast&lt;size_t&gt;(_First[_Idx]);<br>\t\t_Val *= _FNV_prime;<br>\t\t}<br><br>\treturn (_Val);<br>\t}<br>对字符串中每一个字符强制类型转换为无符号char，其中_Val 初始值为_FNV_offset_basis ，将_Val与每一个字符取异或然后*_FNV_prime，循环完所有的字符得到最终的 _Val 即为最终索引。<br>c++中是这么写的，但是具体为什么这么写，这么写的好处在哪？实在看不出其中道理所在，望大佬们帮忙分析！感谢","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452057,"discussion_content":"就是为了尽量打散原始数据，尽量随机","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559257715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97183,"user_name":"张伯毅","can_delete":false,"product_type":"c1","uid":1099929,"ip_address":"","ucode":"E9EAF5ECFE32C7","user_header":"https://static001.geekbang.org/account/avatar/00/10/c8/99/22d2a6a7.jpg","comment_is_top":false,"comment_ctime":1558603720,"is_pvip":false,"replies":[{"id":"34782","content":"是的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1558657342,"ip_address":"","comment_id":97183,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1558603720","product_id":100017301,"comment_content":"当红黑树结点个数少于 8 个的时候，又会将红黑树转化为链表。<br> 在 jdk 1.8 的时候 , 数值应该为 6 吧. <br><br><br>&#47;**<br>     * The bin count threshold for untreeifying a (split) bin during a<br>     * resize operation. Should be less than TREEIFY_THRESHOLD, and at<br>     * most 6 to mesh with shrinkage detection under removal.<br>     *&#47;<br>    static final int UNTREEIFY_THRESHOLD = 6;","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451169,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558657342,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95847,"user_name":"不一样的烟火","can_delete":false,"product_type":"c1","uid":1473251,"ip_address":"","ucode":"6E305F0EE90E8B","user_header":"https://static001.geekbang.org/account/avatar/00/16/7a/e3/145adba9.jpg","comment_is_top":false,"comment_ctime":1558227683,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558227683","product_id":100017301,"comment_content":"散列表是不是有点跳表的意思，都是针对链表进行处理，前者只不过利用了数据的信息，和数组随机访问的特性来加速查找","like_count":0},{"had_liked":false,"id":89790,"user_name":"actionMove","can_delete":false,"product_type":"c1","uid":1003119,"ip_address":"","ucode":"C302338A22E854","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/6f/f66fd6dd.jpg","comment_is_top":false,"comment_ctime":1556266028,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556266028","product_id":100017301,"comment_content":"如何设计一个工业级别的散列表：<br>1.设计一个合适的散列函数<br>\ta.不能太复杂，否则很耗时，影响性能<br>\tb.生成的散列值要尽可能的随机均匀分布，即使出现冲突，也不会出现极端情况<br>2.定义装载因子阈值，并且设计动态扩容策略<br>\t装载因子：过大会导致冲突严重，过小会浪费内存<br>\t动态扩容策略：扩容后，一次迁移所有数据or每次插入操作迁移数据<br>3.选择合适的散列冲突解决办法<br>\t开放地址法（ThreadLocalMap）\t<br>\t\t优势：完全基于数组，有效利用CPU缓存来加快查询速度<br>\t\t\t 序列化简单<br>\t    缺点：删除数据比较麻烦，需要特别标记，否则查询时断层<br>\t         所有数据存储于数组中，hash冲突时代价更高，<br>\t     数据量比较小、装载因子小的时候，适合采用开放寻址法<br><br>\t拉链法（HashMap）<br>\t\t优势：内存利用率高，对大装载因子容忍度高<br>\t    缺点：内存不连续，不利于CPU缓存<br>\t    基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，<br>\t    而且，比起开放寻址法，它更加灵活，支持更多的优化策略，<br>\t    比如用红黑树代替链表。<br><br>","like_count":0},{"had_liked":false,"id":83579,"user_name":"tokamak","can_delete":false,"product_type":"c1","uid":1047341,"ip_address":"","ucode":"1726B6FC06AC3C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/2d/e6548e48.jpg","comment_is_top":false,"comment_ctime":1554659059,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1554659059","product_id":100017301,"comment_content":"醍醐灌顶","like_count":0},{"had_liked":false,"id":76835,"user_name":"张珂","can_delete":false,"product_type":"c1","uid":1451555,"ip_address":"","ucode":"63D5760B253A59","user_header":"https://static001.geekbang.org/account/avatar/00/16/26/23/e99ff49f.jpg","comment_is_top":false,"comment_ctime":1552722647,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552722647","product_id":100017301,"comment_content":"解答自己的上一条留言，LinkedHashMap 确实也是散列表，网上说的“底层通过链表来实现”其实并不准确，只能说它比 HashMap 多维护了一个双向链表而已，本质上底层还是通过数组来存放元素的，装载因子阈值没有查到，但散列冲突解决方案也是链表法。<br>而它多维护的那一个双向链表，作用就是维护元素的插入顺序，使其能够按照插入顺序读取所有元素。而 HashMap 则是不支持这一特征的，插入之后再遍历元素的话，顺序就会被打乱","like_count":0},{"had_liked":false,"id":76827,"user_name":"张珂","can_delete":false,"product_type":"c1","uid":1451555,"ip_address":"","ucode":"63D5760B253A59","user_header":"https://static001.geekbang.org/account/avatar/00/16/26/23/e99ff49f.jpg","comment_is_top":false,"comment_ctime":1552721324,"is_pvip":false,"replies":[{"id":"28110","content":"你理解错了，linkedHashMap是基于链表法（双向链表）解决冲突的散列表。并不是说是单纯基于双向链表实现的。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1552874110,"ip_address":"","comment_id":76827,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552721324","product_id":100017301,"comment_content":"哈哈，Java中 HashMap 是典型的散列表了，底层用数组实现，装载因子阈值约为0.75左右，散列冲突的解决方法为链表法。<br>LinkedHashMap 底层则是通过双向链表来实现，那这样的话，LinkedHashMap 是如何实现按键取值的呢？它还算是散列表吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443459,"discussion_content":"你理解错了，linkedHashMap是基于链表法（双向链表）解决冲突的散列表。并不是说是单纯基于双向链表实现的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552874110,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72442,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1551626623,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551626623","product_id":100017301,"comment_content":"对hashmap又巩固了","like_count":0},{"had_liked":false,"id":64615,"user_name":"金龟","can_delete":false,"product_type":"c1","uid":1228500,"ip_address":"","ucode":"1C7D35C8AE8D9D","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/d4/ff1c1319.jpg","comment_is_top":false,"comment_ctime":1548835600,"is_pvip":false,"replies":[{"id":"24281","content":"这个。。。估计是经验值。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1550541660,"ip_address":"","comment_id":64615,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1548835600","product_id":100017301,"comment_content":"为什么hashMap的装载因子是0.75啊，还有默认是16，这些精确的值是怎么得出来的","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438102,"discussion_content":"这个。。。估计是经验值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550541660,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":62473,"user_name":"泉","can_delete":false,"product_type":"c1","uid":1099760,"ip_address":"","ucode":"914709BE802A8D","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/f0/aa2e0749.jpg","comment_is_top":false,"comment_ctime":1548065442,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1548065442","product_id":100017301,"comment_content":"散列表性能相关:散列函数，散列因子，散列冲突。hashmap源码分析: jdk1.8以前链表实现，以后用红黑树实现。","like_count":0},{"had_liked":false,"id":61113,"user_name":"dw靖","can_delete":false,"product_type":"c1","uid":1185977,"ip_address":"","ucode":"F6C60B1E3777FC","user_header":"https://static001.geekbang.org/account/avatar/00/12/18/b9/de606b05.jpg","comment_is_top":false,"comment_ctime":1547621762,"is_pvip":false,"replies":[{"id":"21766","content":"有的呀 看专栏简介页面","user_name":"编辑回复","user_name_real":"王锦","uid":"1058895","ctime":1547624201,"ip_address":"","comment_id":61113,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1547621762","product_id":100017301,"comment_content":"希望有个github地址 存放 每章节demo代码","like_count":0,"discussions":[{"author":{"id":1058895,"avatar":"https://static001.geekbang.org/account/avatar/00/10/28/4f/48e48553.jpg","nickname":"@阿锦啊","note":"","ucode":"3C5F00333D7174","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436747,"discussion_content":"有的呀 看专栏简介页面","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547624201,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":58411,"user_name":"Edison","can_delete":false,"product_type":"c1","uid":1135701,"ip_address":"","ucode":"734A561F363720","user_header":"https://static001.geekbang.org/account/avatar/00/11/54/55/613ddc42.jpg","comment_is_top":false,"comment_ctime":1547077646,"is_pvip":false,"replies":[{"id":"21055","content":"散列表大小就是元素个数","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1547085475,"ip_address":"","comment_id":58411,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1547077646","product_id":100017301,"comment_content":"  老师在这一讲中，有关于计算每个英文单词的hash值时，最后要除以散列表的大小，散列表的大小是散列表中元素的个数乘以每个元素的大小再加上链表中所有指针的大小吗？我试着用程序实现的时候，如果散列表过大，会出现散列冲突，好多单词的hash值都是0","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436051,"discussion_content":"散列表大小就是元素个数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547085475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57147,"user_name":"邵峰","can_delete":false,"product_type":"c1","uid":1240036,"ip_address":"","ucode":"1017E31C6255F7","user_header":"https://static001.geekbang.org/account/avatar/00/12/eb/e4/dabff318.jpg","comment_is_top":false,"comment_ctime":1546660023,"is_pvip":false,"replies":[{"id":"21846","content":"散列函数肯定会跟长度有关的：）","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1547708457,"ip_address":"","comment_id":57147,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546660023","product_id":100017301,"comment_content":"这里有个疑问，当装载因子过大的时候要动态扩容散列表，把原散列表中的数据搬移到新散列表中，可是为什么需要通过散列函数重新就算在新表中的位置呢，难道对于同一个key值来说，散列函数在新表中和旧表中计算的位置不一样吗？还是说散列函数的计算和散列表的长度有关系？大佬回答一波噻","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435430,"discussion_content":"散列函数肯定会跟长度有关的：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547708457,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":56536,"user_name":"鹏飞天下","can_delete":false,"product_type":"c1","uid":1101792,"ip_address":"","ucode":"EB9FFD9FE64A4C","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/e0/f6819d03.jpg","comment_is_top":false,"comment_ctime":1546483927,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546483927","product_id":100017301,"comment_content":"一、<br>    开放寻址法<br>\t优势：1、散列表中的数据都存储在数组中，可以有效的利用cpu<br>\t\t  2、序列化标胶简单，链表含有指针徐辽话不容易<br>\t缺点：1、删除数据比较麻烦，需要标记删除<br>\t\t  2、比起链表来，冲突代价更大，所以装在因子上线不能太大，<br>\t\t\t ，这也表明开放寻址方法比链表法更浪费内存空间<br>\t总结： 当数据量比较少、装载因子小的时候，才采用开放寻址法。<br>\t       ThreadLocalMap使用的开放寻址法<br>    链表法：1、内存利用率比较高<br>\t\t\t2、能够容忍装载因子比较大","like_count":0},{"had_liked":false,"id":53902,"user_name":"田地","can_delete":false,"product_type":"c1","uid":1348301,"ip_address":"","ucode":"8A6019B5C0B712","user_header":"https://static001.geekbang.org/account/avatar/00/14/92/cd/7a9ad7fc.jpg","comment_is_top":false,"comment_ctime":1545750685,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1545750685","product_id":100017301,"comment_content":"算法书上一般都讲哈希表的大小用质数，这样哈希后的值比较平均。但为什么java表的大小用2的n次方了？","like_count":0,"discussions":[{"author":{"id":1250807,"avatar":"https://static001.geekbang.org/account/avatar/00/13/15/f7/744720a2.jpg","nickname":"DriveMan_邱佳源","note":"","ucode":"A4C83BF07DEE7A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6839,"discussion_content":"HashMap中用2的n次幂这样才能够满足 k%length == k&amp;(length-1)    【k代表的是存储数据的个数，length代表的是数组的长度】","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567135898,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":52342,"user_name":"左胜利","can_delete":false,"product_type":"c1","uid":1327195,"ip_address":"","ucode":"E17B4F4285170D","user_header":"https://static001.geekbang.org/account/avatar/00/14/40/5b/3fe51d4a.jpg","comment_is_top":false,"comment_ctime":1545364459,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545364459","product_id":100017301,"comment_content":"hashmap在红黑树的节点数太少（2-6）时，会退化成单链表","like_count":0},{"had_liked":false,"id":51644,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1545215427,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545215427","product_id":100017301,"comment_content":"老师看了其他资料，关于如何设计散列函数，通常是除留余数法。而p是取接近散列表的长度的最大质数是吧？","like_count":0},{"had_liked":false,"id":51609,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1545207506,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545207506","product_id":100017301,"comment_content":"老师，散列表的上篇与中篇里面，采用链表法来解决散列冲突的散列表是无需关心：装载因子与动态扩容这些概念的吧？","like_count":0},{"had_liked":false,"id":50804,"user_name":"匆匆","can_delete":false,"product_type":"c1","uid":1333414,"ip_address":"","ucode":"4DB39C6CD5743B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/H8NxrljQXliccaT5fjdXJQYS3ou3Z9ykAuKw6EgicicEA9L4jQLz3h85P0odgDSaK0cA9oTyUKibbiagdNvnHuuV5mQ/132","comment_is_top":false,"comment_ctime":1545048897,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545048897","product_id":100017301,"comment_content":"当所有数据都散列到一个槽里时，查询的时间复杂度就从O(1)急剧退化成了O(n)。应避免这种情况。<br>设计散列函数：1、设计不能太复杂（影响散列表性能）2、生成的值尽可能随机且分布均匀。<br><br>装载因子过大：动态扩容（为了避免低效扩容，即一次扩容可能卡死，可分批扩容，每次插入数据时搬迁一次旧的数据）<br><br>解决冲突的方法：1、开放寻址法（序列化简单但是由于数据都存储在一个数组中，冲突的代价更高，适合数据量小、装载因子小的情况）2、链表法（由于链表需要存储指针，所以对缓存不友好，当数据远远大于指针时就划算，当吧链表替换成高级的数据结构比如跳表或者红黑树就回效率大大增加。适合大数据量，存储大对象的情况）<br><br>总结：如何设计一个工业级别的散列表呢？1、合适的散列函数（简单、均匀、随机）。2、合适的装载因子阈值，具备动态扩容策略。3、合适的解决冲突方法。","like_count":0},{"had_liked":false,"id":49486,"user_name":"彻夜繁星","can_delete":false,"product_type":"c1","uid":1243179,"ip_address":"","ucode":"E74446F3B70961","user_header":"https://static001.geekbang.org/account/avatar/00/12/f8/2b/f404c4a4.jpg","comment_is_top":false,"comment_ctime":1544696715,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544696715","product_id":100017301,"comment_content":"请问老师，按照开放寻址的方式，如果出现散列冲突，会依次向后找空闲位置插入，那当取数据的时候是不是就取不到正确的数据了呢？\r<br>比如：现在要存key为a的对象A，本来按照散列函数计算，应该把对象A放在数组下标为x的位置，但现在x的位置已经有了对象B，所以会把A放在x后面，如果下标x+1位置恰好空闲，就会把A放在x+1位置；\r<br>但是当按照某个key为a去散列表中取元素的时候，散列函数同样会计算出a对应的数据下标为x，此时返回的对象会是B，而不是A。这不就乱了吗？","like_count":0},{"had_liked":false,"id":49066,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1544597474,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544597474","product_id":100017301,"comment_content":"一来就是一个DoS（拒绝服务攻击，散列表碰撞攻击）<br>重点，散列函数（简单高效、分布均匀）：<br>1、不能太复杂 2、散列值尽可能随机均匀的分布 <br><br>散列表动态扩容：老配方，使用均摊的方式<br><br>开放寻址使用更多的内存<br>当数据少，装载因子小适合使用开放寻址发，<br>链表法，可以做到装载因子是10也不影响当前数组的情况<br>将其改为动态链表结构中的红黑树，跳表也能够确保在极度坏的情况下O(logn) ---散列碰撞攻击<br><br>链表法： 大数据对象更合适，更加灵活，支持更多的优化策略<br>在数据量小的情况下，红黑树要维护平衡，性能上的优势对比普通单链表，没有明显的优势<br><br>合适的散列函数，定义装载因子阈值，动态扩容策略，合适的散列冲突解决方法","like_count":0},{"had_liked":false,"id":47528,"user_name":"吴小智","can_delete":false,"product_type":"c1","uid":1310798,"ip_address":"","ucode":"C7C9F58B5C9F7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","comment_is_top":false,"comment_ctime":1544151188,"is_pvip":false,"replies":[{"id":"17206","content":"就是这么设计的 也可以是1.5倍 都可以的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1544408318,"ip_address":"","comment_id":47528,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1544151188","product_id":100017301,"comment_content":"Java的hashmap扩容，为什么每次都扩为原来的两倍？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431796,"discussion_content":"就是这么设计的 也可以是1.5倍 都可以的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544408318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":43025,"user_name":"qinggeouye","can_delete":false,"product_type":"c1","uid":1251536,"ip_address":"","ucode":"5B53EEDD7BEC9C","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/d0/49b06424.jpg","comment_is_top":false,"comment_ctime":1543142585,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543142585","product_id":100017301,"comment_content":"mark 资瓷。看完老师的关于工业级散列表HashMap的举例（散列函数这里是一脸懵），评论区又长见识了。","like_count":0},{"had_liked":false,"id":40611,"user_name":"王荣慧","can_delete":false,"product_type":"c1","uid":1255948,"ip_address":"","ucode":"54566879CEB0C5","user_header":"https://static001.geekbang.org/account/avatar/00/13/2a/0c/b9eafe83.jpg","comment_is_top":false,"comment_ctime":1542636140,"is_pvip":false,"replies":[{"id":"14661","content":"再比较key 看下是不是真的是你要找的key","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542678535,"ip_address":"","comment_id":40611,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542636140","product_id":100017301,"comment_content":"有个疑问，如果使用开放定址存储冲突数据，对数据的查询，根据key哈希计算后，我如何知道这个位置是冲突还是没冲突过。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429569,"discussion_content":"再比较key 看下是不是真的是你要找的key","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542678535,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":40272,"user_name":"他在她城断了弦","can_delete":false,"product_type":"c1","uid":1242521,"ip_address":"","ucode":"3D91CA87B64C8B","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/99/454b17c1.jpg","comment_is_top":false,"comment_ctime":1542588716,"is_pvip":false,"replies":[{"id":"14681","content":"起码java 语言是的。其他语言应该也是的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542679693,"ip_address":"","comment_id":40272,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542588716","product_id":100017301,"comment_content":"请问老师，如果定义map的时候类型不同，系统会选择调用不同的hash函数来初始化map吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429452,"discussion_content":"起码java 语言是的。其他语言应该也是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542679693,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":39812,"user_name":"kakasi","can_delete":false,"product_type":"c1","uid":1237297,"ip_address":"","ucode":"64F357E6A08CA5","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/31/eb103bdc.jpg","comment_is_top":false,"comment_ctime":1542360531,"is_pvip":false,"replies":[{"id":"14694","content":"理论上可以 因为hashcode设计的比较随机","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542680554,"ip_address":"","comment_id":39812,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542360531","product_id":100017301,"comment_content":"有个困扰很久的问题：<br>(h ^ (h &gt;&gt;&gt; 16)) &amp; (capitity - 1)  一个key的hashCode与其高16位进行异或运算，然后对散列表长度取余，这个结果会分布均匀呢？<br>请老师解答下","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429237,"discussion_content":"理论上可以 因为hashcode设计的比较随机","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542680554,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":38525,"user_name":"cricket1981","can_delete":false,"product_type":"c1","uid":1001715,"ip_address":"","ucode":"758262F5958DA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/f3/f1034ffd.jpg","comment_is_top":false,"comment_ctime":1542071292,"is_pvip":false,"replies":[{"id":"13802","content":"这个课程不涉及多线程 不好意思啊","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542073342,"ip_address":"","comment_id":38525,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542071292","product_id":100017301,"comment_content":"散列表在并发环境下扩容导致环链死锁的情况能否细讲一下？谢谢！","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428736,"discussion_content":"这个课程不涉及多线程 不好意思啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542073342,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37963,"user_name":"yooh","can_delete":false,"product_type":"c1","uid":1246419,"ip_address":"","ucode":"7CE1AC224F4BF9","user_header":"https://static001.geekbang.org/account/avatar/00/13/04/d3/cca450d5.jpg","comment_is_top":false,"comment_ctime":1541827354,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541827354","product_id":100017301,"comment_content":"hashmap退化链的数是6,升级红黑树8","like_count":0},{"had_liked":false,"id":37272,"user_name":"Light Lin","can_delete":false,"product_type":"c1","uid":1234625,"ip_address":"","ucode":"C0AA9AA608F395","user_header":"https://static001.geekbang.org/account/avatar/00/12/d6/c1/aa9cde77.jpg","comment_is_top":false,"comment_ctime":1541513770,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541513770","product_id":100017301,"comment_content":"最近有点掉队，很多不懂的，接下来要努力克服。","like_count":0},{"had_liked":false,"id":36929,"user_name":"Ricky","can_delete":false,"product_type":"c1","uid":1238256,"ip_address":"","ucode":"0B29C730CAD29C","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/f0/82281239.jpg","comment_is_top":false,"comment_ctime":1541391155,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541391155","product_id":100017301,"comment_content":"散列表是通过key查找数据的，其存储方式是采用散列函数规则散列到每个槽，在每个槽建立跳表的时候，应该是按照key大小进行插入的吧，因为要实现O1的查找操作。跳表实现了元素有序，但是实际上散列表元素应该无序才对吧","like_count":0},{"had_liked":false,"id":36785,"user_name":"在路上","can_delete":false,"product_type":"c1","uid":1234574,"ip_address":"","ucode":"B696886D2D0BC6","user_header":"https://static001.geekbang.org/account/avatar/00/12/d6/8e/887727c1.jpg","comment_is_top":false,"comment_ctime":1541327407,"is_pvip":false,"replies":[{"id":"13082","content":"这个跟数据和哈希函数还有散列表大小有关。比如散列函数是key%n。n是散列表大小7。那key是5和12的时候就冲突了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541382569,"ip_address":"","comment_id":36785,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1541327407","product_id":100017301,"comment_content":"老师，请问下，如何用代码去模拟这种hash冲突呢？我试过，但还是不会。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428015,"discussion_content":"这个跟数据和哈希函数还有散列表大小有关。比如散列函数是key%n。n是散列表大小7。那key是5和12的时候就冲突了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541382569,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36778,"user_name":"ALAN","can_delete":false,"product_type":"c1","uid":1240164,"ip_address":"","ucode":"70E3B1C730E63F","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/64/7403c694.jpg","comment_is_top":false,"comment_ctime":1541323275,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541323275","product_id":100017301,"comment_content":"老师，有个问题请教下。开放寻址法查询的时候，碰到散列表为空的位置后，就不继续往后找了吗？这样设计不合理吧，因为存储的时候，存数据的散列表的位置是随机的，空的位置后面也许存了数据呢？如果是继续找的话，那为什么删除数据后，要进行特殊标记，这样标记也没意义啊，反正碰到空的位置，还是会继续找，这样标不标记都无所谓啊？","like_count":0},{"had_liked":false,"id":36764,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1541315406,"is_pvip":false,"replies":[{"id":"13083","content":"工业级应该也没有一个标准吧 更多的是指代码健壮 在任何情况下都能正确 高效运行","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541382745,"ip_address":"","comment_id":36764,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1541315406","product_id":100017301,"comment_content":"老师，有一个疑问点：“工业级水平”，这个词该怎么定义和衡量，像Python的Dictionary，JAVA的hashmap，以及c++中的unorder_map，这些散列表应该就是属于工业级水平了吧。那我们自己在设计数据结构和算法时，如何评估自己做的东西离工业级水平差多远呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428006,"discussion_content":"工业级应该也没有一个标准吧 更多的是指代码健壮 在任何情况下都能正确 高效运行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541382745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36752,"user_name":"sarahsnow","can_delete":false,"product_type":"c1","uid":1249446,"ip_address":"","ucode":"63D0832C4F75CA","user_header":"https://static001.geekbang.org/account/avatar/00/13/10/a6/564f9143.jpg","comment_is_top":false,"comment_ctime":1541306767,"is_pvip":false,"replies":[{"id":"13088","content":"文章不是说了嘛 ThreadLocalMap","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541382845,"ip_address":"","comment_id":36752,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1541306767","product_id":100017301,"comment_content":"Java中有用开放寻址法的Hash类吗？Java底层是用C开发的吗？谢谢","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427999,"discussion_content":"文章不是说了嘛 ThreadLocalMap","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541382845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1542987,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","nickname":"行则将至","note":"","ucode":"DB972F2DF059C4","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574875,"discussion_content":"ThreadLocalMap中的set方法，在set值时，会找一下是否已经存在相同的key，如果存在就覆盖value。如果不存在会创建新的节点。可以参考ThreadLocalMap的set(ThreadLocal&lt;?&gt; key, Object value)方法中的下面一段代码：\nfor (Entry e = tab[i];\n                 e != null;\n                 //开放寻址法寻找可用的槽位\n                 e = tab[i = nextIndex(i, len)]) {\n                ThreadLocal&lt;?&gt; k = e.get();\n\n                if (k == key) {\n                    e.value = value;\n                    return;\n                }\n\n                if (k == null) {\n                    replaceStaleEntry(key, value, i);\n                    return;\n                }\n            }","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654416360,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36654,"user_name":"許敲敲","can_delete":false,"product_type":"c1","uid":1046681,"ip_address":"","ucode":"6486466820E7BF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/99/8e760987.jpg","comment_is_top":false,"comment_ctime":1541219823,"is_pvip":false,"replies":[{"id":"13110","content":"你去看看dict","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541383571,"ip_address":"","comment_id":36654,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1541219823","product_id":100017301,"comment_content":"有没有基于python语言的的实例呢","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427957,"discussion_content":"你去看看dict","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541383571,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36648,"user_name":"asdf100","can_delete":false,"product_type":"c1","uid":1043738,"ip_address":"","ucode":"39D8D71453E575","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/1a/ce7f7d54.jpg","comment_is_top":false,"comment_ctime":1541214201,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541214201","product_id":100017301,"comment_content":"散列表存储方式分两种：<br>一种是以类似数组一样的存储方式，存储的数据量小，维护的话使用开放寻址方式。<br>另一种是单向链表的存储形式，适合数据量大的情况。<br>两者都可能根据情况进行扩容和缩容。<br>这样理解对么？","like_count":0},{"had_liked":false,"id":36561,"user_name":"Ricky","can_delete":false,"product_type":"c1","uid":1238256,"ip_address":"","ucode":"0B29C730CAD29C","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/f0/82281239.jpg","comment_is_top":false,"comment_ctime":1541150353,"is_pvip":false,"replies":[{"id":"13117","content":"没太看懂你说的呢 ","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541384200,"ip_address":"","comment_id":36561,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1541150353","product_id":100017301,"comment_content":"我想问一下老师，hashmap 用跳表实现的时候，数值应该按顺序存储，方便查找，但是字典型数据难道不应该是无序的吗","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427912,"discussion_content":"没太看懂你说的呢 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541384200,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066251,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/0Qp9pxHBvgdZAveKzsvUFFUicCJfe7ONzhC7jSNFQDNFvg0jRMXuqqZOdxG1qKosylUYrpIHUR2Q76w5m4HtVkg/132","nickname":"Aaron","note":"","ucode":"B0C504A76297C7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":244421,"discussion_content":"他的意思是，跳表的索引节点应该是数值类型，并且是有序的，那如果map的key值是非数字的字符串，要怎么构造这个跳表的索引树呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587603140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36539,"user_name":"有铭","can_delete":false,"product_type":"c1","uid":1046302,"ip_address":"","ucode":"2C7CB36CA5C04C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/3XbCueYYVWTiclv8T5tFpwiblOxLphvSZxL4ujMdqVMibZnOiaFK2C5nKRGv407iaAsrI0CDICYVQJtiaITzkjfjbvrQ/132","comment_is_top":false,"comment_ctime":1541144672,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541144672","product_id":100017301,"comment_content":"之前看专栏的Java高级特性的时候就提到Java的HashMap设计的非常巧妙，如果能把Java的那堆容器设计的算法都搞的很明白的话绝对是高手","like_count":0},{"had_liked":false,"id":36533,"user_name":"柠檬C","can_delete":false,"product_type":"c1","uid":1181505,"ip_address":"","ucode":"BC0EE704D952A4","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/41/2d477385.jpg","comment_is_top":false,"comment_ctime":1541143623,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541143623","product_id":100017301,"comment_content":"这节干活满满，2节下来对hashmap底层更熟悉了","like_count":0},{"had_liked":false,"id":36512,"user_name":"王小李","can_delete":false,"product_type":"c1","uid":1108833,"ip_address":"","ucode":"64B703781E0A0E","user_header":"https://static001.geekbang.org/account/avatar/00/10/eb/61/45c3a047.jpg","comment_is_top":false,"comment_ctime":1541136307,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541136307","product_id":100017301,"comment_content":"请问老师这边讲数据结构，会涉及线程是否安全的例子吗？比如上面的哈希表，怎么样改进才能达到线程安全提高效率。还有之前看了跳跃表的思想，我觉得是否对于大的哈希表的每个 bucket 里再嵌套一个哈希表。这样做是否也可以达到优化的效果？","like_count":0},{"had_liked":false,"id":36490,"user_name":"菜菜","can_delete":false,"product_type":"c1","uid":1243536,"ip_address":"","ucode":"888AC33663B774","user_header":"https://static001.geekbang.org/account/avatar/00/12/f9/90/f90903e5.jpg","comment_is_top":false,"comment_ctime":1541127909,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541127909","product_id":100017301,"comment_content":"老师讲的太好啦！","like_count":0},{"had_liked":false,"id":36487,"user_name":"白了少年头","can_delete":false,"product_type":"c1","uid":1053084,"ip_address":"","ucode":"A65E00E05B23BA","user_header":"https://static001.geekbang.org/account/avatar/00/10/11/9c/4fd6ebe0.jpg","comment_is_top":false,"comment_ctime":1541126958,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541126958","product_id":100017301,"comment_content":"老师的讲解十分透彻，听了这节课再去看相应散列表源码的时候，就会有一种恍然大悟的感觉，非常棒！","like_count":0},{"had_liked":false,"id":36471,"user_name":"NeverMore","can_delete":false,"product_type":"c1","uid":1228498,"ip_address":"","ucode":"582698D772810D","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/d2/3d88cb8e.jpg","comment_is_top":false,"comment_ctime":1541122397,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541122397","product_id":100017301,"comment_content":"学习啦。由浅入深。","like_count":0},{"had_liked":false,"id":36454,"user_name":"alex44jzy","can_delete":false,"product_type":"c1","uid":1237077,"ip_address":"","ucode":"4930779A3A4F3E","user_header":"","comment_is_top":false,"comment_ctime":1541120369,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541120369","product_id":100017301,"comment_content":"醍醐灌顶 很详细了","like_count":0},{"had_liked":false,"id":36418,"user_name":"Jimbol","can_delete":false,"product_type":"c1","uid":1178008,"ip_address":"","ucode":"8D9190B3B3E08B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f9/98/95b13446.jpg","comment_is_top":false,"comment_ctime":1541114309,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541114309","product_id":100017301,"comment_content":"之前看java8 hashmap扩容的时候没看明白，今天老师的讲解真是让我茅塞顿开！谢谢老师！","like_count":0}]}