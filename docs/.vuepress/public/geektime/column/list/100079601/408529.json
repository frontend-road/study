{"id":408529,"title":"36 | 代码测试（上）：如何编写 Go 语言单元测试和性能测试用例？","content":"<p>你好，我是孔令飞。</p><p>从今天开始，我们就进入了服务测试模块，这一模块主要介绍如何测试我们的Go项目。</p><p>在Go项目开发中，我们不仅要开发功能，更重要的是确保这些功能稳定可靠，并且拥有一个不错的性能。要确保这些，就要对代码进行测试。开发人员通常会进行单元测试和性能测试，分别用来测试代码的功能是否正常和代码的性能是否满足需求。</p><p>每种语言通常都有自己的测试包/模块，Go语言也不例外。在Go中，我们可以通过<code>testing</code>包对代码进行单元测试和性能测试。这一讲，我会用一些示例来讲解如何编写单元测试和性能测试用例，下一讲则会介绍如何编写其他的测试类型，并介绍 IAM 项目的测试用例。</p><h2>如何测试 Go 代码？</h2><p>Go语言有自带的测试框架<code>testing</code>，可以用来实现单元测试（T类型）和性能测试（B类型），通过<code>go test</code>命令来执行单元测试和性能测试。</p><p>go test 执行测试用例时，是以go包为单位进行测试的。执行时需要指定包名，比如<code>go test 包名</code>，如果没有指定包名，默认会选择执行命令时所在的包。go test在执行时，会遍历以<code>_test.go</code>结尾的源码文件，执行其中以<code>Test</code>、<code>Benchmark</code>、<code>Example</code>开头的测试函数。</p><p>为了演示如何编写测试用例，我预先编写了4个函数。假设这些函数保存在test目录下的<code>math.go</code>文件中，包名为<code>test</code>，math.go代码如下：</p><!-- [[[read_end]]] --><pre><code class=\"language-go\">package test\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"math/rand\"\n)\n\n// Abs returns the absolute value of x.\nfunc Abs(x float64) float64 {\n\treturn math.Abs(x)\n}\n\n// Max returns the larger of x or y.\nfunc Max(x, y float64) float64 {\n\treturn math.Max(x, y)\n}\n\n// Min returns the smaller of x or y.\nfunc Min(x, y float64) float64 {\n\treturn math.Min(x, y)\n}\n\n// RandInt returns a non-negative pseudo-random int from the default Source.\nfunc RandInt() int {\n\treturn rand.Int()\n}\n</code></pre><p>在这一讲后面的内容中，我会演示如何编写测试用例，来对这些函数进行单元测试和性能测试。下面让我们先来看下测试命名规范。</p><h2>测试命名规范</h2><p>在我们对Go代码进行测试时，需要编写测试文件、测试函数、测试变量，它们都需要遵循一定的规范。这些规范有些来自于官方，有些则来自于社区。这里，我分别来介绍下测试文件、包、测试函数和测试变量的命名规范。</p><h3>测试文件的命名规范</h3><p>Go的测试文件名必须以<code>_test.go</code>结尾。例如，如果我们有一个名为<code>person.go</code>的文件，那它的测试文件必须命名为<code>person_test.go</code>。这样做是因为，Go需要区分哪些文件是测试文件。这些测试文件可以被go test命令行工具加载，用来测试我们编写的代码，但会被Go的构建程序忽略掉，因为Go程序的运行不需要这些测试代码。</p><h3>包的命名规范</h3><p>Go的测试可以分为白盒测试和黑盒测试。</p><ul>\n<li><strong>白盒测试：</strong>将测试和生产代码放在同一个Go包中，这使我们可以同时测试Go包中可导出和不可导出的标识符。当我们编写的单元测试需要访问Go包中不可导出的变量、函数和方法时，就需要编写白盒测试用例。</li>\n<li><strong>黑盒测试：</strong>将测试和生产代码放在不同的Go包中。这时，我们仅可以测试Go包的可导出标识符。这意味着我们的测试包将无法访问生产代码中的任何内部函数、变量或常量。</li>\n</ul><p>在白盒测试中，Go的测试包名称需要跟被测试的包名保持一致，例如：<code>person.go</code>定义了一个<code>person</code>包，则<code>person_test.go</code>的包名也要为<code>person</code>，这也意味着<code>person.go</code>和<code>person_test.go</code>都要在同一个目录中。</p><p>在黑盒测试中，Go的测试包名称需要跟被测试的包名不同，但仍然可以存放在同一个目录下。比如，<code>person.go</code>定义了一个<code>person</code>包，则<code>person_test.go</code>的包名需要跟<code>person</code>不同，通常我们命名为<code>person_test</code>。</p><p>如果不是需要使用黑盒测试，我们在做单元测试时要尽量使用白盒测试。一方面，这是go test工具的默认行为；另一方面，使用白盒测试，我们可以测试和使用不可导出的标识符。</p><p>测试文件和包的命名规范，由Go语言及go test工具来强制约束。</p><h3>函数的命名规范</h3><p>测试用例函数必须以<code>Test</code>、<code>Benchmark</code>、<code>Example</code>开头，例如<code>TestXxx</code>、<code>BenchmarkXxx</code>、<code>ExampleXxx</code>，<code>Xxx</code>部分为任意字母数字的组合，首字母大写。这是由Go语言和go test工具来进行约束的，<code>Xxx</code>一般是需要测试的函数名。</p><p>除此之外，还有一些社区的约束，这些约束不是强制的，但是遵循这些约束会让我们的测试函数名更加易懂。例如，我们有以下函数：</p><pre><code class=\"language-go\">package main\n\ntype Person struct {\n\tage  int64\n}\n\nfunc (p *Person) older(other *Person) bool {\n\treturn p.age &gt; other.age\n}\n</code></pre><p>很显然，我们可以把测试函数命名为<code>TestOlder</code>，这个名称可以很清晰地说明它是<code>Older</code>函数的测试用例。但是，如果我们想用多个测试用例来测试<code>TestOlder</code>函数，这些测试用例该如何命名呢？也许你会说，我们命名为<code>TestOlder1</code>、<code>TestOlder2</code>不就行了？</p><p>其实，还有其他更好的命名方法。比如，这种情况下，我们可以将函数命名为<code>TestOlderXxx</code>，其中<code>Xxx</code>代表<code>Older</code>函数的某个场景描述。例如，<code>strings.Compare</code>函数有如下测试函数：<code>TestCompare</code>、<code>TestCompareIdenticalString</code>、<code>TestCompareStrings</code>。</p><h3>变量的命名规范</h3><p>Go语言和go test没有对变量的命名做任何约束。但是，在编写单元测试用例时，还是有一些规范值得我们去遵守。</p><p>单元测试用例通常会有一个实际的输出，在单元测试中，我们会将预期的输出跟实际的输出进行对比，来判断单元测试是否通过。为了清晰地表达函数的实际输出和预期输出，可以将这两类输出命名为<code>expected/actual</code>，或者<code>got/want</code>。例如：</p><pre><code class=\"language-go\">if c.expected != actual {\n  t.Fatalf(\"Expected User-Agent '%s' does not match '%s'\", c.expected, actual)\n}\n</code></pre><p>或者：</p><pre><code class=\"language-go\">if got, want := diags[3].Description().Summary, undeclPlural; got != want {\n  t.Errorf(\"wrong summary for diagnostic 3\\ngot:  %s\\nwant: %s\", got, want)\n}\n</code></pre><p>其他的变量命名，我们可以遵循Go语言推荐的变量命名方法，例如：</p><ul>\n<li>Go中的变量名应该短而不是长，对于范围有限的局部变量来说尤其如此。</li>\n<li>变量离声明越远，对名称的描述性要求越高。</li>\n<li>像循环、索引之类的变量，名称可以是单个字母（i）。如果是不常见的变量和全局变量，变量名就需要具有更多的描述性。</li>\n</ul><p>上面，我介绍了Go测试的一些基础知识。接下来，我们来看看如何编写单元测试用例和性能测试用例。</p><h2>单元测试</h2><p>单元测试用例函数以 <code>Test</code> 开头，例如 <code>TestXxx</code> 或 <code>Test_xxx</code> （ <code>Xxx</code> 部分为任意字母数字组合，首字母大写）。函数参数必须是 <code>*testing.T</code>，可以使用该类型来记录错误或测试状态。</p><p>我们可以调用 <code>testing.T</code> 的 <code>Error</code> 、<code>Errorf</code> 、<code>FailNow</code> 、<code>Fatal</code> 、<code>FatalIf</code> 方法，来说明测试不通过；调用 <code>Log</code> 、<code>Logf</code> 方法来记录测试信息。函数列表和相关描述如下表所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/b3/ab/b374d392abfe62459d2c22e6ff76c0ab.jpg?wh=1920x1570\" alt=\"图片\"></p><p>下面的代码是两个简单的单元测试函数（函数位于文件<a href=\"https://github.com/marmotedu/gopractise-demo\">math_test.go</a>中）：</p><pre><code class=\"language-go\">func TestAbs(t *testing.T) {\n    got := Abs(-1)\n    if got != 1 {\n        t.Errorf(\"Abs(-1) = %f; want 1\", got)\n    }\n}\n\nfunc TestMax(t *testing.T) {\n    got := Max(1, 2)\n    if got != 2 {\n        t.Errorf(\"Max(1, 2) = %f; want 2\", got)\n    }\n}\n</code></pre><p>执行<code>go test</code>命令来执行如上单元测试用例：</p><pre><code class=\"language-go\">$ go test\nPASS\nok      github.com/marmotedu/gopractise-demo/31/test    0.002s\n</code></pre><p><code>go test</code>命令自动搜集所有的测试文件，也就是格式为<code>*_test.go</code>的文件，从中提取全部测试函数并执行。<br>\ngo test还支持下面三个参数。</p><ul>\n<li>-v，显示所有测试函数的运行细节：</li>\n</ul><pre><code class=\"language-go\">$ go test -v\n=== RUN   TestAbs\n--- PASS: TestAbs (0.00s)\n=== RUN   TestMax\n--- PASS: TestMax (0.00s)\nPASS\nok      github.com/marmotedu/gopractise-demo/31/test    0.002s\n</code></pre><ul>\n<li>-run &lt; regexp&gt;，指定要执行的测试函数：</li>\n</ul><pre><code class=\"language-go\">$ go test -v -run='TestA.*'\n=== RUN   TestAbs\n--- PASS: TestAbs (0.00s)\nPASS\nok      github.com/marmotedu/gopractise-demo/31/test    0.001s\n</code></pre><p>上面的例子中，我们只运行了以<code>TestA</code>开头的测试函数。</p><ul>\n<li>-count N，指定执行测试函数的次数：</li>\n</ul><pre><code class=\"language-go\">$ go test -v -run='TestA.*' -count=2\n=== RUN   TestAbs\n--- PASS: TestAbs (0.00s)\n=== RUN   TestAbs\n--- PASS: TestAbs (0.00s)\nPASS\nok      github.com/marmotedu/gopractise-demo/31/test    0.002s\n</code></pre><h3>多个输入的测试用例</h3><p>前面介绍的单元测试用例只有一个输入，但是很多时候，我们需要测试一个函数在多种不同输入下是否能正常返回。这时候，我们可以编写一个稍微复杂点的测试用例，用来支持多输入下的用例测试。例如，我们可以将<code>TestAbs</code>改造成如下函数：</p><pre><code class=\"language-go\">func TestAbs_2(t *testing.T) {\n    tests := []struct {\n        x    float64\n        want float64\n    }{\n        {-0.3, 0.3},\n        {-2, 2},\n        {-3.1, 3.1},\n        {5, 5},\n    }\n\n    for _, tt := range tests {\n        if got := Abs(tt.x); got != tt.want {\n            t.Errorf(\"Abs() = %f, want %v\", got, tt.want)\n        }\n    }\n}\n</code></pre><p>上述测试用例函数中，我们定义了一个结构体数组，数组中的每一个元素代表一次测试用例。数组元素的的值包含输入和预期的返回值：</p><pre><code class=\"language-go\">tests := []struct {\n    x    float64\n    want float64\n}{\n    {-0.3, 0.3},\n    {-2, 2},\n    {-3.1, 3.1},\n    {5, 5},\n}\n</code></pre><p>上述测试用例，将被测函数放在for循环中执行：</p><pre><code class=\"language-go\">   for _, tt := range tests {\n        if got := Abs(tt.x); got != tt.want {\n            t.Errorf(\"Abs() = %f, want %v\", got, tt.want)\n        }\n    }\n</code></pre><p>上面的代码将输入传递给被测函数，并将被测函数的返回值跟预期的返回值进行比较。如果相等，则说明此次测试通过，如果不相等则说明此次测试不通过。通过这种方式，我们就可以在一个测试用例中，测试不同的输入和输出，也就是不同的测试用例。如果要新增一个测试用例，根据需要添加输入和预期的返回值就可以了，这些测试用例都共享其余的测试代码。</p><p>上面的测试用例中，我们通过<code>got != tt.want</code>来对比实际返回结果和预期返回结果。我们也可以使用<code>github.com/stretchr/testify/assert</code>包中提供的函数来做结果对比，例如：</p><pre><code class=\"language-go\">func TestAbs_3(t *testing.T) {\n    tests := []struct {\n        x    float64\n        want float64\n    }{\n        {-0.3, 0.3},\n        {-2, 2},\n        {-3.1, 3.1},\n        {5, 5},\n    }\n\n    for _, tt := range tests {\n        got := Abs(tt.x)\n        assert.Equal(t, got, tt.want)\n    }\n}\n</code></pre><p>使用<code>assert</code>来对比结果，有下面这些好处：</p><ul>\n<li>友好的输出结果，易于阅读。</li>\n<li>因为少了<code>if got := Xxx(); got != tt.wang {}</code>的判断，代码变得更加简洁。</li>\n<li>可以针对每次断言，添加额外的消息说明，例如<code>assert.Equal(t, got, tt.want, \"Abs test\")</code>。</li>\n</ul><p>assert包还提供了很多其他函数，供开发者进行结果对比，例如<code>Zero</code>、<code>NotZero</code>、<code>Equal</code>、<code>NotEqual</code>、<code>Less</code>、<code>True</code>、<code>Nil</code>、<code>NotNil</code>等。如果想了解更多函数，你可以参考<code>go doc github.com/stretchr/testify/assert</code>。</p><h3>自动生成单元测试用例</h3><p>通过上面的学习，你也许可以发现，测试用例其实可以抽象成下面的模型：</p><p><img src=\"https://static001.geekbang.org/resource/image/8f/fa/8f06e0a1bf2638a9255467a29e6dfcfa.jpg?wh=1920x688\" alt=\"图片\"></p><p>用代码可表示为：</p><pre><code class=\"language-go\">func TestXxx(t *testing.T) {\n    type args struct {\n        // TODO: Add function input parameter definition.\n    }\n\n    type want struct {\n         // TODO: Add function return parameter definition.\n    }\n    tests := []struct {\n        name string\n        args args\n        want want\n    }{\n        // TODO: Add test cases.\n    }\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            if got := Xxx(tt.args); got != tt.want {\n                t.Errorf(\"Xxx() = %v, want %v\", got, tt.want)\n            }\n        })\n    }\n}\n</code></pre><p>既然测试用例可以抽象成一些模型，那么我们就可以基于这些模型来自动生成测试代码。Go社区中有一些优秀的工具可以自动生成测试代码，我推荐你使用<a href=\"https://github.com/cweill/gotests\">gotests</a>工具。</p><p>下面，我来讲讲gotests工具的使用方法，可以分成三个步骤。</p><p>第一步，安装gotests工具：</p><pre><code class=\"language-bash\">$ go get -u github.com/cweill/gotests/...\n</code></pre><p>gotests命令执行格式为：<code>gotests [options] [PATH] [FILE] ...</code>。gotests可以为<code>PATH</code>下的所有Go源码文件中的函数生成测试代码，也可以只为某个<code>FILE</code>中的函数生成测试代码。</p><p>第二步，进入测试代码目录，执行gotests生成测试用例：</p><pre><code class=\"language-bash\">$ gotests -all -w .\n</code></pre><p>上面的命令会为当前目录下所有Go源码文件中的函数生成测试代码。</p><p>第三步，添加测试用例：</p><p>生成完测试用例，你只需要添加需要测试的输入和预期的输出就可以了。下面的测试用例是通过gotests生成的：</p><pre><code class=\"language-go\">func TestUnpointer(t *testing.T) {\n    type args struct {\n        offset *int64\n        limit  *int64\n    }\n    tests := []struct {\n        name string\n        args args\n        want *LimitAndOffset\n    }{\n        // TODO: Add test cases.\n    }\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            if got := Unpointer(tt.args.offset, tt.args.limit); !reflect.DeepEqual(got, tt.want) {\n                t.Errorf(\"Unpointer() = %v, want %v\", got, tt.want)\n            }\n        })\n    }\n}\n</code></pre><p>我们只需要补全<code>TODO</code>位置的测试数据即可，补全后的测试用例见<a href=\"https://github.com/marmotedu/iam/blob/v1.0.8/internal/pkg/util/gormutil/gorm_test.go\">gorm_test.go</a>文件。</p><h2>性能测试</h2><p>上面，我讲了用来测试代码的功能是否正常的单元测试，接下来我们来看下性能测试，它是用来测试代码的性能是否满足需求的。</p><p>性能测试的用例函数必须以<code>Benchmark</code>开头，例如<code>BenchmarkXxx</code>或<code>Benchmark_Xxx</code>（ <code>Xxx</code> 部分为任意字母数字组合，首字母大写）。</p><p>函数参数必须是<code>*testing.B</code>，函数内以<code>b.N</code>作为循环次数，其中<code>N</code>会在运行时动态调整，直到性能测试函数可以持续足够长的时间，以便能够可靠地计时。下面的代码是一个简单的性能测试函数（函数位于文件<a href=\"https://github.com/marmotedu/gopractise-demo/blob/master/test/math_test.go\">math_test.go</a>中）：</p><pre><code class=\"language-go\">func BenchmarkRandInt(b *testing.B) {\n    for i := 0; i &lt; b.N; i++ {\n        RandInt()\n    }\n}\n</code></pre><p><code>go test</code>命令默认不会执行性能测试函数，需要通过指定参数<code>-bench &lt;pattern&gt;</code>来运行性能测试函数。<code>-bench</code>后可以跟正则表达式，选择需要执行的性能测试函数，例如<code>go test -bench=\".*\"</code>表示执行所有的压力测试函数。执行<code>go test -bench=\".*\"</code>后输出如下：</p><pre><code class=\"language-bash\">$ go test -bench=\".*\"\ngoos: linux\ngoarch: amd64\npkg: github.com/marmotedu/gopractise-demo/31/test\nBenchmarkRandInt-4      97384827                12.4 ns/op\nPASS\nok      github.com/marmotedu/gopractise-demo/31/test    1.223s\n</code></pre><p>上面的结果只显示了性能测试函数的执行结果。<code>BenchmarkRandInt</code>性能测试函数的执行结果如下：</p><pre><code class=\"language-bash\">BenchmarkRandInt-4   \t90848414\t        12.8 ns/op\n</code></pre><p>每个函数的性能执行结果一共有3列，分别代表不同的意思，这里用上面的函数举例子：</p><ul>\n<li><code>BenchmarkRandInt-4</code>，<code>BenchmarkRandInt</code>表示所测试的测试函数名，4表示有4个CPU线程参与了此次测试，默认是<code>GOMAXPROCS</code>的值。</li>\n<li><code>90848414</code> ，说明函数中的循环执行了<code>90848414</code>次。</li>\n<li><code>12.8 ns/op</code>，说明每次循环的执行平均耗时是 <code>12.8</code> 纳秒，该值越小，说明代码性能越高。</li>\n</ul><p>如果我们的性能测试函数在执行循环前，需要做一些耗时的准备工作，我们就需要重置性能测试时间计数，例如：</p><pre><code class=\"language-go\">func BenchmarkBigLen(b *testing.B) {\n    big := NewBig()\n    b.ResetTimer()\n    for i := 0; i &lt; b.N; i++ {\n        big.Len()\n    }\n}\n</code></pre><p>当然，我们也可以先停止性能测试的时间计数，然后再开始时间计数，例如：</p><pre><code class=\"language-go\">func BenchmarkBigLen(b *testing.B) {\n\tb.StopTimer() // 调用该函数停止压力测试的时间计数\n\tbig := NewBig()\n\tb.StartTimer() // 重新开始时间\n\tfor i := 0; i &lt; b.N; i++ {\n\t\tbig.Len()\n\t}\n}\n</code></pre><p>B类型的性能测试还支持下面 4 个参数。</p><ul>\n<li>benchmem，输出内存分配统计：</li>\n</ul><pre><code class=\"language-bash\">$ go test -bench=\".*\" -benchmem\ngoos: linux\ngoarch: amd64\npkg: github.com/marmotedu/gopractise-demo/31/test\nBenchmarkRandInt-4      96776823                12.8 ns/op             0 B/op          0 allocs/op\nPASS\nok      github.com/marmotedu/gopractise-demo/31/test    1.255s\n</code></pre><p>指定了<code>-benchmem</code>参数后，执行结果中又多了两列： 0 B/op，表示每次执行分配了多少内存（字节），该值越小，说明代码内存占用越小；0 allocs/op，表示每次执行分配了多少次内存，该值越小，说明分配内存次数越少，意味着代码性能越高。</p><ul>\n<li>benchtime，指定测试时间和循环执行次数（格式需要为Nx，例如100x）：</li>\n</ul><pre><code class=\"language-bash\">$ go test -bench=\".*\" -benchtime=10s # 指定测试时间\ngoos: linux\ngoarch: amd64\npkg: github.com/marmotedu/gopractise-demo/31/test\nBenchmarkRandInt-4&nbsp; &nbsp; &nbsp; 910328618&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;13.1 ns/op\nPASS\nok&nbsp; &nbsp; &nbsp; github.com/marmotedu/gopractise-demo/31/test&nbsp; &nbsp; 13.260s\n$ go test -bench=\".*\" -benchtime=100x # 指定循环执行次数\ngoos: linux\ngoarch: amd64\npkg: github.com/marmotedu/gopractise-demo/31/test\nBenchmarkRandInt-4&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;100&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 16.9 ns/op\nPASS\nok&nbsp; &nbsp; &nbsp; github.com/marmotedu/gopractise-demo/31/test&nbsp; &nbsp; 0.003s\n</code></pre><ul>\n<li>cpu，指定GOMAXPROCS。</li>\n<li>timeout，指定测试函数执行的超时时间：</li>\n</ul><pre><code class=\"language-bash\">$ go test -bench=\".*\" -timeout=10s\ngoos: linux\ngoarch: amd64\npkg: github.com/marmotedu/gopractise-demo/31/test\nBenchmarkRandInt-4      97375881                12.4 ns/op\nPASS\nok      github.com/marmotedu/gopractise-demo/31/test    1.224s\n</code></pre><h2>总结</h2><p>代码开发完成之后，我们需要为代码编写单元测试用例，并根据需要，给一些函数编写性能测试用例。Go语言提供了 <code>testing</code> 包，供我们编写测试用例，并通过 <code>go test</code> 命令来执行这些测试用例。</p><p>go test在执行测试用例时，会查找具有固定格式的Go源码文件名，并执行其中具有固定格式的函数，这些函数就是测试用例。这就要求我们的测试文件名、函数名要符合 <code>go test</code> 工具的要求：Go的测试文件名必须以 <code>_test.go</code> 结尾；测试用例函数必须以 <code>Test</code> 、 <code>Benchmark</code> 、 <code>Example</code> 开头。此外，我们在编写测试用例时，还要注意包和变量的命名规范。</p><p>Go项目开发中，编写得最多的是单元测试用例。单元测试用例函数以 <code>Test</code> 开头，例如 <code>TestXxx</code> 或 <code>Test_xxx</code> （<code>Xxx</code> 部分为任意字母数字组合，首字母大写）。函数参数必须是 <code>*testing.T</code> ，可以使用该类型来记录错误或测试状态。我们可以调用 <code>testing.T</code> 的 <code>Error</code> 、<code>Errorf</code> 、<code>FailNow</code> 、<code>Fatal</code> 、<code>FatalIf</code> 方法，来说明测试不通过；调用 <code>Log</code> 、<code>Logf</code> 方法来记录测试信息。</p><p>下面是一个简单的单元测试函数：</p><pre><code class=\"language-go\">func TestAbs(t *testing.T) {\n&nbsp; &nbsp; got := Abs(-1)\n&nbsp; &nbsp; if got != 1 {\n&nbsp; &nbsp; &nbsp; &nbsp; t.Errorf(\"Abs(-1) = %f; want 1\", got)\n&nbsp; &nbsp; }\n}\n</code></pre><p>编写完测试用例之后，可以使用 <code>go test</code> 命令行工具来执行这些测试用例。<br>\n此外，我们还可以使用<a href=\"https://github.com/cweill/gotests\">gotests</a>工具，来自动地生成单元测试用例，从而减少编写测试用例的工作量。</p><p>我们在Go项目开发中，还经常需要编写性能测试用例。性能测试用例函数必须以<code>Benchmark</code>开头，以<code>*testing.B</code> 作为函数入参，通过 <code>go test -bench &lt;pattern&gt;</code> 运行。</p><h2>课后练习</h2><ol>\n<li>编写一个 <code>PrintHello</code> 函数，该函数会返回 <code>Hello World</code> 字符串，并编写单元测试用例，对 <code>PrintHello</code> 函数进行测试。</li>\n<li>思考一下，哪些场景下采用白盒测试，哪些场景下采用黑盒测试？</li>\n</ol><p>欢迎你在留言区与我交流讨论，我们下一讲见。</p>","neighbors":{"left":{"article_title":"35 | 效率神器：如何设计和实现一个命令行客户端工具？","id":407922},"right":{"article_title":"37 | 代码测试（下）：Go 语言其他测试类型及 IAM 测试介绍","id":409307}},"comments":[{"had_liked":false,"id":307911,"user_name":"Sch0ng","can_delete":false,"product_type":"c1","uid":1145554,"ip_address":"","ucode":"73F6113931B1AC","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/d2/4ba67c0c.jpg","comment_is_top":false,"comment_ctime":1629302553,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23104139033","product_id":100079601,"comment_content":"go自带测试框架testing。<br>使用gotests工具自动生成测试代码。<br>单元测试的价值是提高代码的可靠性，重构的时候多一层保障。<br>遇到单元测试不知道怎么写的情况，首先考虑函数的粒度是不是太粗，能不能拆成更小的函数。","like_count":6},{"had_liked":false,"id":343072,"user_name":"fcl","can_delete":false,"product_type":"c1","uid":2774638,"ip_address":"","ucode":"9FC74C4B1DD0B3","user_header":"https://static001.geekbang.org/account/avatar/00/2a/56/6e/de7da340.jpg","comment_is_top":false,"comment_ctime":1650617539,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18830486723","product_id":100079601,"comment_content":"自己写的代码 知道哪个函数经常改 好控制  用白盒测试 <br>别人写的复杂代码  自己只是调用接口  函数太多不知道测哪个 用黑盒测试<br>面试官：我没问题了，你还有什么想问的吗？","like_count":5},{"had_liked":false,"id":307546,"user_name":"lianyz","can_delete":false,"product_type":"c1","uid":1330879,"ip_address":"","ucode":"A2536B49AEC4DD","user_header":"https://static001.geekbang.org/account/avatar/00/14/4e/bf/0f0754aa.jpg","comment_is_top":false,"comment_ctime":1629156726,"is_pvip":true,"replies":[{"id":"111378","content":"有fmt.Println&#47;fmt.Printf这类输出的时候","user_name":"作者回复","comment_id":307546,"uid":"1167883","ip_address":"","utype":1,"ctime":1629242420,"user_name_real":"CK1.0"}],"discussion_count":1,"race_medal":0,"score":"18809025910","product_id":100079601,"comment_content":"老师，什么时候使用ExampleXxx呢？","like_count":4,"discussions":[{"author":{"id":1167883,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d2/0b/cdd0787a.jpg","nickname":"孔令飞","note":"","ucode":"8363EA4BD0AAF0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525194,"discussion_content":"有fmt.Println/fmt.Printf这类输出的时候","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629242420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307552,"user_name":"daz2yy","can_delete":false,"product_type":"c1","uid":1008723,"ip_address":"","ucode":"639A67961EC893","user_header":"https://static001.geekbang.org/account/avatar/00/0f/64/53/c93b8110.jpg","comment_is_top":false,"comment_ctime":1629158185,"is_pvip":false,"replies":[{"id":"111377","content":"放在跟被测代码相同的目录下，便于维护","user_name":"作者回复","comment_id":307552,"uid":"1167883","ip_address":"","utype":1,"ctime":1629242399,"user_name_real":"CK1.0"}],"discussion_count":1,"race_medal":0,"score":"14514060073","product_id":100079601,"comment_content":"老师，问下，测试的代码建议放在代码相同目录包下还是放在项目根目录下的 test 目录呢？","like_count":4,"discussions":[{"author":{"id":1167883,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d2/0b/cdd0787a.jpg","nickname":"孔令飞","note":"","ucode":"8363EA4BD0AAF0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525196,"discussion_content":"放在跟被测代码相同的目录下，便于维护","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629242399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308967,"user_name":"陈麒文","can_delete":false,"product_type":"c1","uid":2187256,"ip_address":"","ucode":"41475885FA5AD5","user_header":"https://static001.geekbang.org/account/avatar/00/21/5f/f8/1d16434b.jpg","comment_is_top":false,"comment_ctime":1629875171,"is_pvip":false,"replies":[{"id":"112018","content":"暂时没发现有自动生成Benchmark的工具。<br><br>使用Mock来测试","user_name":"作者回复","comment_id":308967,"uid":"1167883","ip_address":"","utype":1,"ctime":1630113053,"user_name_real":"CK1.0"}],"discussion_count":1,"race_medal":0,"score":"5924842467","product_id":100079601,"comment_content":"那有没有自动生成Benchmark的性能工具呢？还有TestXxx一般是针对函数么，如果是接口的话，参数值该怎么定义？","like_count":1,"discussions":[{"author":{"id":1167883,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d2/0b/cdd0787a.jpg","nickname":"孔令飞","note":"","ucode":"8363EA4BD0AAF0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525696,"discussion_content":"暂时没发现有自动生成Benchmark的工具。\n\n使用Mock来测试","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630113053,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343221,"user_name":"jxs1211","can_delete":false,"product_type":"c1","uid":1101006,"ip_address":"","ucode":"B7F1F2D84389E7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKELX1Rd1vmLRWibHib8P95NA87F4zcj8GrHKYQL2RcLDVnxNy1ia2geTWgW6L2pWn2kazrPNZMRVrIg/132","comment_is_top":false,"comment_ctime":1650716775,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650716775","product_id":100079601,"comment_content":"白盒测试：<br>要测试内部标识符，常规测试<br>黑盒测试：<br>解决循环引用，主要测试外部接口","like_count":0},{"had_liked":false,"id":333284,"user_name":"coyang","can_delete":false,"product_type":"c1","uid":1024805,"ip_address":"","ucode":"563687E0F6A441","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a3/25/5da16c25.jpg","comment_is_top":false,"comment_ctime":1644245371,"is_pvip":true,"replies":[{"id":"123446","content":"代码测试（下）：Go 语言其他测试类型及 IAM 测试介绍 这一讲有介绍","user_name":"作者回复","comment_id":333284,"uid":"1167883","ip_address":"","utype":1,"ctime":1647039507,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1644245371","product_id":100079601,"comment_content":"老师好，请问go常用&#47;好用的mock框架有什么推荐的？","like_count":0,"discussions":[{"author":{"id":1167883,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d2/0b/cdd0787a.jpg","nickname":"孔令飞","note":"","ucode":"8363EA4BD0AAF0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555706,"discussion_content":"代码测试（下）：Go 语言其他测试类型及 IAM 测试介绍 这一讲有介绍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647039508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331972,"user_name":"Struggle~honor","can_delete":false,"product_type":"c1","uid":1975831,"ip_address":"","ucode":"EBC6DFC6CF0973","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/rSzzqGwHcvhwPejiaPsCY9XBX7ib7zTxJ6cUDORdhGIakX8dTPVsz6ibud5ec1FeWQGTseF2TPRECCjky5JMlHvDg/132","comment_is_top":false,"comment_ctime":1642929591,"is_pvip":false,"replies":[{"id":"121552","content":"666","user_name":"作者回复","comment_id":331972,"uid":"1167883","ip_address":"","utype":1,"ctime":1643454707,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1642929591","product_id":100079601,"comment_content":"vscode可以生成测试代码","like_count":1,"discussions":[{"author":{"id":1167883,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d2/0b/cdd0787a.jpg","nickname":"孔令飞","note":"","ucode":"8363EA4BD0AAF0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548945,"discussion_content":"666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643454707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324759,"user_name":"yandongxiao","can_delete":false,"product_type":"c1","uid":1017700,"ip_address":"","ucode":"D397F4DB0109C8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/64/3882d90d.jpg","comment_is_top":false,"comment_ctime":1638605189,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638605189","product_id":100079601,"comment_content":"总结：<br>介绍了单元测试规范和性能测试规范<br>使用 github.com&#47;stretchr&#47;testify&#47;assert 做结果对比<br>使用 gotests 自动生成 table driven test<br>性能测试默认不会被执行，重要参数有 benchmem, benchtime, cpu, timeout","like_count":0},{"had_liked":false,"id":323850,"user_name":"Allen","can_delete":false,"product_type":"c1","uid":2851087,"ip_address":"","ucode":"63E53446007D1F","user_header":"https://static001.geekbang.org/account/avatar/00/2b/81/0f/f8ced7d9.jpg","comment_is_top":false,"comment_ctime":1638180925,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638180925","product_id":100079601,"comment_content":"go test真的太粗糙了","like_count":1},{"had_liked":false,"id":311159,"user_name":"随风而过","can_delete":false,"product_type":"c1","uid":2654999,"ip_address":"","ucode":"FFD17BAA3B2312","user_header":"https://static001.geekbang.org/account/avatar/00/28/83/17/df99b53d.jpg","comment_is_top":false,"comment_ctime":1631090841,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631090841","product_id":100079601,"comment_content":"金融项目需要大量的白盒测试，app项目就是常见的黑盒测试","like_count":1},{"had_liked":false,"id":308916,"user_name":"授人以🐟，不如授人以渔","can_delete":false,"product_type":"c1","uid":1193874,"ip_address":"","ucode":"BD53829E924B66","user_header":"https://static001.geekbang.org/account/avatar/00/12/37/92/961ba560.jpg","comment_is_top":false,"comment_ctime":1629859733,"is_pvip":true,"replies":[{"id":"112019","content":"前面的更准确","user_name":"作者回复","comment_id":308916,"uid":"1167883","ip_address":"","utype":1,"ctime":1630113083,"user_name_real":"CK1.0"}],"discussion_count":1,"race_medal":0,"score":"1629859733","product_id":100079601,"comment_content":"在“如何测试Go代码？”这节的开头，“默认会选择执行命令时所在的包”，修改为“默认会选择执行命名时所在的目录”可能会容易理解。","like_count":0,"discussions":[{"author":{"id":1167883,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d2/0b/cdd0787a.jpg","nickname":"孔令飞","note":"","ucode":"8363EA4BD0AAF0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525681,"discussion_content":"前面的更准确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630113083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}