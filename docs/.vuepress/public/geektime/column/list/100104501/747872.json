{"id":747872,"title":"22｜技术解析：如何使用Go开发eBPF程序？","content":"<p>你好，我是倪朋飞。</p><p>在上一讲中，我带你学习了 eBPF for Windows 的主要原理以及如何在 Windows 系统上开发 eBPF 程序。eBPF for Windows 把开源社区的 eBPF 工具链带到了 Linux，让 Windows 开发者也可以利用 eBPF 技术来解决网络、观测、性能优化等各类问题。由于复用了相同的工具链，Windows eBPF 程序的开发流程同 Linux 非常相似，主要也是利用 libbpf 开发 eBPF 内核程序、利用 LLVM 编译 eBPF 程序为字节码、最后再到用户态程序中加载和挂载 eBPF 字节码，并通过 BPF 映射同内核态 eBPF 程序进行交互。</p><p>今天这一讲我将带你换一种编程语言，也就是通过在容器和云原生应用中最流行的 Go 语言来开发 eBPF 程序。</p><h2>eBPF Go 语言开发库</h2><p>在<a href=\"https://time.geekbang.org/column/article/487227\">阶段总结｜实用eBPF工具及最新开源项目总结</a>中我曾经讲到，BCC、libbpf 以及内核源码，都主要使用 C 语言开发 eBPF 程序，而实际的应用程序可能会以多种多样的编程语言进行开发。所以，开源社区开发和维护了很多不同语言的接口，方便这些高级语言跟 eBPF 系统进行交互。比如，我们课程多次使用的 BCC 就提供了 Python、C++ 等多种语言的接口，而使用 BCC 的 Python 接口去加载 eBPF 程序，要比 libbpf 和内核源码的方法简单得多。</p><!-- [[[read_end]]] --><p>对于 Go 语言来说，跟 Python 接口也是类似的，目的也是方便熟悉 Go 语言的开发者更容易地把 eBPF 集成到现有的项目中去。下面的表格列出了常见的 Go 语言开发库，以及它们的使用场景。</p><p><img src=\"https://static001.geekbang.org/resource/image/eb/a8/eb3e2b02c352498f9a4yy93d86fa82a8.jpg?wh=1772x1284\" alt=\"\"></p><p>在使用这些 Go 语言开发库时需要注意，<strong>Go 开发库只适用于用户态程序中</strong>，可以完成 eBPF 程序编译、加载、事件挂载，以及 BPF 映射交互等用户态的功能，而内核态的 eBPF 程序还是需要使用 C 语言来开发的。</p><p>了解了这些 Go 语言的 eBPF 开发库之后，你肯定在想该如何使用 Go 语言来开发 eBPF 程序了。接下来，我就通过一个具体的例子带你一起看一下。</p><blockquote>\n<p>注意：以下课程内容需要你在 Linux 机器中安装 Go 语言。如果你还没有安装，可以点击<a href=\"https://go.dev/dl/\">这里</a>下载并安装。或者，你也可以执行下面的命令，安装最新版本的 Go 并配置 Go 环境。<br>\n&nbsp;<br>\nGOVERSION=$(curl -sL ‘<a href=\"https://golang.org/VERSION?m=text\">https://golang.org/VERSION?m=text</a>’ | head -n 1)<br>\ncurl -sL “<a href=\"https://go.dev/dl/$GOVERSION.linux-amd64.tar.gz\">https://go.dev/dl/$GOVERSION.linux-amd64.tar.gz</a>” | sudo tar -C /usr/local -zxf -<br>\nmkdir /go<br>\nexport GOPATH=/go<br>\nexport PATH=$PATH:/usr/local/go/bin/:$GOPATH/bin</p>\n</blockquote><h2>如何用 Go 开发 eBPF 程序</h2><p>在正式开始我们的例子之前，我先带你简单看一下 <a href=\"https://github.com/cilium/ebpf\">cilium/ebpf</a> 这个库的主要组件，方便你以后在使用时查阅。</p><p>根据 cilium/ebpf 的 <a href=\"https://github.com/cilium/ebpf\">GitHub</a>  页面，你可以发现，它主要由 asm、cmd/bpf2go、link、perf、ringbuf、features、rlimit 以及 btf 等 8 个子包组成，这些子包的功能分别是：</p><ul>\n<li><a href=\"https://pkg.go.dev/github.com/cilium/ebpf/asm\">asm</a> 包含一个基本的汇编器，允许你直接在 Go 代码中编写 eBPF 汇编指令（如果你更喜欢用 C 语言编写 eBPF 程序的话，则不需要使用这个功能）。</li>\n<li><a href=\"https://pkg.go.dev/github.com/cilium/ebpf/cmd/bpf2go\">cmd/bpf2go</a> 用于把 C 语言编写的 eBPF 程序进行编译并嵌入到 Go 代码中。除了代码编译外，它还自动生成加载和操作 eBPF 程序和映射对象的 Go 语言脚手架代码。</li>\n<li><a href=\"https://pkg.go.dev/github.com/cilium/ebpf/link\">link</a> 用于将 eBPF 程序挂载到各种钩子上。</li>\n<li><a href=\"https://pkg.go.dev/github.com/cilium/ebpf/perf\">perf</a> 用于从 <code>PERF_EVENT_ARRAY</code> 映射中读取数据。</li>\n<li><a href=\"https://pkg.go.dev/github.com/cilium/ebpf/ringbuf\">ringbuf</a> 用于从 <code>BPF_MAP_TYPE_RINGBUF</code> 映射中读取数据。</li>\n<li><a href=\"https://pkg.go.dev/github.com/cilium/ebpf/features\">features</a> 使用原生 Go 实现了类似于 <code>bpftool feature probe</code> 的功能，用于发现与 BPF 相关的内核特性。</li>\n<li><a href=\"https://pkg.go.dev/github.com/cilium/ebpf/rlimit\">rlimit</a> 提供了一个方便的 API 来解除 5.11 版本之前内核上对 <code>RLIMIT_MEMLOCK</code> 的限制。</li>\n<li><a href=\"https://pkg.go.dev/github.com/cilium/ebpf/btf\">btf</a> 允许读取 BTF（BPF 类型格式）。<br>\n其中，<code>cmd/bpf2go</code> 是一个可执行文件，其功能类似于 <code>bpftool gen skeleton</code>，用于编译 eBPF 代码并生成 Go 语言的脚手架代码；而其他的子包则是类似于 libbpf，用于 Go 代码同 eBPF 程序进行交互。</li>\n</ul><p>还记得<a href=\"https://time.geekbang.org/column/article/484372?utm_campaign=geektime_search&utm_content=geektime_search&utm_medium=geektime_search&utm_source=geektime_search&utm_term=geektime_search\">第 8 讲</a>讲到的使用 libbpf 开发 eBPF 程序的步骤吗？如果你不记得，可以点击 <a href=\"https://time.geekbang.org/column/article/484372\">libbpf 方法</a>再去回顾一下。其实，使用 cilium/ebpf  开发 eBPF 程序的步骤也是类似的，可以通过以下三个步骤完成：</p><ol>\n<li>第一步，使用 C 语言开发内核态 eBPF 程序，这一步跟 libbpf 方法是完全相同的。</li>\n<li>第二步，借助 <code>go generate</code> 命令，使用 <a href=\"https://pkg.go.dev/github.com/cilium/ebpf/cmd/bpf2go\">cmd/bpf2go</a> 编译 eBPF 程序，并生成 Go 语言脚手架代码。</li>\n<li>第三步，使用 cilium/ebpf 库配合上一步生成的脚手架代码开发用户态程序，包括 eBPF 程序加载、挂载到内核函数和跟踪点，以及通过 BPF 映射获取和打印执行结果等。</li>\n</ol><p>接下来，我就用一个最简单的 XDP 网络包计数程序来带你一起详细看看这几个步骤。</p><p><strong>第一步，使用 C 语言开发内核态 eBPF 程序。</strong></p><p>第一步跟我们之前学习的 libbpf 方法是一样的，新建一个 hello.bpf.c 文件，然后写入内核态 eBPF 程序即可。主要的代码如下所示，关键的地方我都加了注释方便你理解。</p><pre><code class=\"language-go\">/* 由于我们并不需要cgo，这儿需要通过Go构建标签来排除C源文件，否则Go编译会报错 */\n//go:build ignore\n\n#include &lt;linux/bpf.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n\n/* 定义BPF映射，用于存储网络包计数*/\nstruct {\n    __uint(type, BPF_MAP_TYPE_ARRAY);\n    __type(key, __u32);\n    __type(value, __u64);\n    __uint(max_entries, 1);\n} pkt_count SEC(\".maps\");\n\n/* XDP程序入口，统计网络包数量并存入BPF映射 */\nSEC(\"xdp\")\nint count_packets() {\n    __u32 key    = 0;\n    __u64 *count = bpf_map_lookup_elem(&amp;pkt_count, &amp;key);\n    if (count) {\n        __sync_fetch_and_add(count, 1);\n    }\n\n    return XDP_PASS;\n}\n\nchar __license[] SEC(\"license\") = \"Dual MIT/GPL\";\n</code></pre><p>这其中，</p><ul>\n<li><code>//go:build ignore</code> 表示 Go 编译时忽略 C 文件；</li>\n<li><code>pkt_count</code> 定义了一个用于存储网络包计数的 BPF 映射；</li>\n<li><code>SEC(\"xdp\")</code> 定义了 XDP 程序的入口函数 <code>count_packets</code>。</li>\n</ul><p>从这段代码你可以发现，这儿的代码跟 libbpf 方法是一样的。只有一点需要注意的是 <code>// go:build ignore</code> 这一行是必不可少的，它的意思是让 Go 编译时忽略 C 源码文件。由于我们只是用 C 语言开发 eBPF 程序，并不需要通过 cgo 去直接调用内核态 eBPF 程序代码，所以在编译 Go 代码时应该忽略 C 源码文件。</p><p><strong>第二步，编译并生成 Go 语言脚手架代码。</strong></p><p>有了 eBPF 程序代码之后，接下来就是利用 <code>cmd/bpf2go</code> 来编译并生成 Go 脚手架代码了。创建一个 main.go 文件，并写入如下的代码。</p><pre><code class=\"language-go\">package main\n\n//go:generate go run github.com/cilium/ebpf/cmd/bpf2go hello hello.bpf.c\n</code></pre><p>这段代码最关键的是第二句 <code>go:generate</code> 注解，用于在执行 <code>go generate</code> 时自动执行 <code>cmd/bpf2go</code> 命令。<code>cmd/bpf2go</code> 命令需要两个参数，第一个 <code>hello</code> 是生成文件名的前缀，而第二个参数 <code>hello.bpf.c</code> 就是我们第一步开发的 eBPF 程序。</p><p>在执行 <code>go generate</code> 命令之前，你还需要执行下面的命令，初始化一个 Go 模块，并添加对 <code>github.com/cilium/ebpf/cmd/bpf2go</code> 的依赖（如果你对 Go 模块不熟悉，可以点击<a href=\"https://go.dev/ref/mod\">这里</a>，查看官方文档）。</p><pre><code class=\"language-shell\">go mod init hello\ngo mod tidy\ngo get github.com/cilium/ebpf/cmd/bpf2go\n</code></pre><p>接下来，你就可以执行 <code>go generate</code> 命令，编译并生成 Go 语言脚手架代码。如果一切顺利，你将看到如下输出：</p><pre><code class=\"language-shell\">$ go generate\nCompiled /ebpf-apps/go/hello/hello_bpfel.o\nStripped /ebpf-apps/go/hello/hello_bpfel.o\nWrote /ebpf-apps/go/hello/hello_bpfel.go\nCompiled /ebpf-apps/go/hello/hello_bpfeb.o\nStripped /ebpf-apps/go/hello/hello_bpfeb.o\nWrote /ebpf-apps/go/hello/hello_bpfeb.go\n</code></pre><p>这其中，<code>.o</code> 文件就是编译目标文件， <code>.go</code> 文件就是对应的脚手架代码，而后缀 <code>bpfel</code> 和 <code>bpfeb</code> 则分别表示该文件用于小端系统和大端系统。</p><p><strong>第三步，开发用户态程序。</strong></p><p>有了脚手架代码之后，接下来的最后一步就是开发用户态程序了。你可以在 main.go 里面继续添加 <code>main()</code> 函数，添加 eBPF 程序加载、挂载到XDP，以及通过 BPF 映射获取和打印执行结果等执行逻辑。完整的代码如下所示，关键的步骤我加了注释方便你理解。</p><pre><code class=\"language-go\">// 1. 引入必要的依赖库\nimport (\n \"log\"\n \"net\"\n \"os\"\n \"os/signal\"\n \"time\"\n\n \"github.com/cilium/ebpf/link\"\n \"github.com/cilium/ebpf/rlimit\"\n)\n\nfunc main() {\n // 2. 移除内核&lt;5.11的资源限制\n if err := rlimit.RemoveMemlock(); err != nil {\n  log.Fatal(\"Removing memlock:\", err)\n }\n\n // 3. 调用脚手架函数，加载编译后的 eBPF 字节码\n var objs helloObjects\n if err := loadHelloObjects(&amp;objs, nil); err != nil {\n  log.Fatal(\"Loading eBPF objects failure:\", err)\n }\n defer objs.Close()\n\n  // 4. 挂载 XDP 程序到网卡上\n ifname := \"eth0\"\n iface, err := net.InterfaceByName(ifname)\n if err != nil {\n  log.Fatalf(\"Getting interface %s failure: %s\", ifname, err)\n }\n link, err := link.AttachXDP(link.XDPOptions{\n  Program:   objs.CountPackets,\n  Interface: iface.Index,\n })\n if err != nil {\n  log.Fatal(\"Attaching XDP failure:\", err)\n }\n defer link.Close()\n\n log.Printf(\"Counting incoming packets on %s..\", ifname)\n\n // 5. 定期查询并打印数据包计数（Ctrl+C退出）\n tick := time.Tick(time.Second)\n stop := make(chan os.Signal, 5)\n signal.Notify(stop, os.Interrupt)\n for {\n  select {\n  case &lt;-tick:\n   var count uint64\n   err := objs.PktCount.Lookup(uint32(0), &amp;count)\n   if err != nil {\n    log.Fatal(\"Map lookup failure:\", err)\n   }\n   log.Printf(\"Received %d packets\", count)\n  case &lt;-stop:\n   log.Print(\"Received stop signal, exiting..\")\n   return\n  }\n }\n}\n</code></pre><p>你可以发现，这段代码的主要逻辑跟 libbpf 方法也是类似的，所不同的只是编程语言和库函数的不同。另外，这段 Go 代码里面的 eBPF 程序名 <code>CountPackets</code> 和 BPF 映射名 <code>PktCount</code> 分别对应第一步 eBPF C 代码里面的 <code>count_packets</code> 和 <code>pkt_count</code>，这是 <code>cmd/bpf2go</code> 自动将 C 命名格式转换为 Go 的驼峰命名法导致的（即不使用下划线且单词首字母大写）。</p><p>代码开发完成后，你就可以编译并执行用户态的程序了。执行 <code>go build</code> 命令编译 Go 程序后并执行 <code>./hello</code> 运行它，如果一切正常，你将看到如下的输出：</p><pre><code class=\"language-shell\">$ go build\n$ ./hello\n2023/12/30 14:19:49 Counting incoming packets on eth0..\n2023/12/30 14:19:50 Received 9 packets\n2023/12/30 14:19:51 Received 16 packets\n2023/12/30 14:19:52 Received 20 packets\n</code></pre><p>恭喜你，你已经使用 Go 语言成功开发并运行了第一个 eBPF 程序。</p><h2>eBPF 程序分发</h2><p>同 libbpf 一样，你除了可以在本地运行刚刚开发的 eBPF 程序之外，你还可以直接把编译生成的二进制文件复制到其他相同体系结构的机器上运行。如果目标机器的体系结构不同，你还可以借助 Go 的交叉编译，生成对应体系结构的二进制文件。比如，你可以执行下面的命令为 ARM 机器编译。</p><pre><code class=\"language-shell\"># CGO_ENABLED=0 指定不依赖libc\n# GOARCH=arm64 指定编译目标为64位ARM\nCGO_ENABLED=0 GOARCH=arm64 go build\n</code></pre><p>那么，cilium/ebpf 是怎么实现同一份代码可以跨平台编译，并且只通过一个二进制文件就可以分发的呢？其实秘密就藏在 <code>cmd/bpf2go</code> 生成的脚手架文件中。</p><p>对于第一个跨平台的问题，由于大小端系统的不同，<code>cmd/bpf2go</code> 分别为小端系统和大端系统生成了后缀为 <code>bpfel</code> 和 <code>bpfeb</code> 的脚手架文件。执行下面的命令，查看这两个文件的开头你可以发现，它们通过 <code>go:build</code> 指定了只在特定平台才会执行编译。</p><pre><code class=\"language-shell\">$ head -n3 hello_bpfel.go\n// Code generated by bpf2go; DO NOT EDIT.\n//go:build 386 || amd64 || amd64p32 || arm || arm64 || loong64 || mips64le || mips64p32le || mipsle || ppc64le || riscv64\n\n$ head -n3 hello_bpfeb.go\n// Code generated by bpf2go; DO NOT EDIT.\n//go:build arm64be || armbe || mips || mips64 || mips64p32 || ppc64 || s390 || s390x || sparc || sparc64\n</code></pre><p>再仔细查看 hello_bpfel.go 和 hello_bpfeb.go 的区别，你可以进一步发现，除了刚才的 <code>go:build</code> 标签不同之外，这两个文件的主要区别在于 <code>go:embed</code> 对应的 ELF 文件不同。执行下面的命令，你可以发现它们分别嵌入了小端和大端系统对应的 <code>.o</code> 文件，并放到了 Go 变量 <code>_HelloBytes</code> 中。</p><pre><code class=\"language-shell\">$ tail -n5 hello_bpfeb.go\n\n// Do not access this directly.\n//\n//go:embed hello_bpfeb.o\nvar _HelloBytes []byte\n\n$ tail -n5 hello_bpfel.go\n\n// Do not access this directly.\n//\n//go:embed hello_bpfel.o\nvar _HelloBytes []byte\n</code></pre><p>而这也回答了刚才的第二个问题，即通过 Go 嵌入 <code>.o</code> 的方法，让编译生成的二进制文件可以独立分发，而不需要在目标机器上安装开发编译工具。</p><p>当然了，在分发 eBPF 程序到异构环境时，不同内核版本导致的 eBPF 兼容性问题还是需要你自己去解决的。比如，你可以通过 <code>features</code> 包来检查目标机器的内核版本是否支持某个 eBPF 特性，然后再决定是否加载 eBPF 程序；也可以通过 BTF 来解决不同内核版本中数据结构不同的问题，从而实现一次编译到处执行。</p><h2><strong>小结</strong></h2><p>今天，我带你一起学习了如何使用 Go 语言开发 eBPF 程序。通过一个最简单的 XDP 网络包计数程序，我带你一起学习了使用 Go 语言开发 eBPF 程序的三个步骤，即使用 C 语言开发内核态 eBPF 程序，使用 <code>cmd/bpf2go</code> 编译 eBPF 程序并生成 Go 语言脚手架代码，以及使用 cilium/ebpf 库开发用户态程序。得益于 Go 语言的高效和简洁，使用 Go 语言开发的 eBPF 程序可以在交叉编译后直接分发到其他平台上运行，而不需要在目标机器上再去安装开发工具。</p><p>在这一讲的最后，我想提醒你，尽管 Go 语言已经提供了完善的交叉编译机制，但是在分发 eBPF 程序时你还需注意目标机器的内核版本是否支持你所使用的特性。如果有必要的话，你还需要使用 <code>features</code> 包和 BTF 来确保 eBPF 程序能够正常运行在目标机器上。</p><h2><strong>思考题</strong></h2><p>最后，我想邀请你来聊一聊：</p><ol>\n<li>今天的主要内容是如何使用 Go 开发 eBPF 程序，那么为什么要使用 Go 语言开发 eBPF 程序呢？你觉得 Go 语言开发 eBPF 程序有什么优势和劣势？</li>\n<li>除了 Go 语言，你还知道有哪些语言可以用来开发 eBPF 程序吗？它们各自有什么优势和劣势？</li>\n</ol><p>期待你在留言区和我讨论，也欢迎把这节课分享给你的同事、朋友。让我们一起在实战中演练，在交流中进步。</p>","comments":[{"had_liked":false,"id":395456,"user_name":"0mfg","can_delete":false,"product_type":"c1","uid":1393948,"ip_address":"北京","ucode":"D83530DB25D25A","user_header":"","comment_is_top":false,"comment_ctime":1730869876,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100104501,"comment_content":"老师，今年的更新可以来个rust开发ebpf程序吗","like_count":0},{"had_liked":false,"id":388835,"user_name":"疯狂的小企鹅","can_delete":false,"product_type":"c1","uid":1029578,"ip_address":"浙江","ucode":"3BB71C53382BAD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b5/ca/c3949f49.jpg","comment_is_top":false,"comment_ctime":1710983477,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100104501,"comment_content":"&gt; 也可以通过 BTF 来解决不同内核版本中数据结构不同的问题，从而实现一次编译到处执行。\n\n请教一下哦，要想通过BTF来解决不同内核版本数据结构不同的问题，应该还需要用户态程序能够通过类似libbpf的方式来完成eBPF程序的重定位工作吧？请问cilium&#47;ebpf库是怎么解决这个问题的？我看官方文档写着也比较浅https:&#47;&#47;ebpf-go.dev&#47;guides&#47;portable-ebpf&#47;#compile-once-run-everywhere 。目前我们采用的办法是根据不同kernel版本生成多份.o文件，然后用户态程序再判断下kernel版本来决定加载哪一份.o。但我感觉这不是最佳实践，求老师赐教。","like_count":0,"discussions":[{"author":{"id":2596001,"avatar":"","nickname":"Geek_4bc69c","note":"","ucode":"712353B40BFB32","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":652658,"discussion_content":"ebpf-go自己实现了根据btf重定位。https://github.com/cilium/ebpf/blob/main/btf/core.go","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1729396229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}