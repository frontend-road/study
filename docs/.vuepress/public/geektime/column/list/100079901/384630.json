{"id":384630,"title":"09｜异步处理：如何向服务器端发送请求？","content":"<p>你好，我是王沛。这节课我们来学习如何在 React Hooks 中处理 Rest API 请求。</p><p>我遇到很多 React 的初学者，刚把Hello World跑起来，问的第一个问题就是：我该怎么发请求拿数据呢？</p><p>可见，这是最为常见也是最为重要的一个需求。毕竟90%以上的前端 App 都是和服务器端打交道，然后通过各种 API 完成各种功能。</p><p><strong>虽然发请求拿数据有很多<strong><strong>种</strong></strong>做法，但基本上都会遵循一定的规律</strong>，而这正是咱们这节课要介绍的内容。</p><p>其实在第一讲，我们就已经看到了异步请求的一个实例，当时我们在一个组件内直接发起了一个请求，并处理了返回结果。但这个简单的例子只是演示了组件中发请求的基本流程，在实际的项目中我们很少会直接这么写，因为<strong>还需要考虑更多的逻辑</strong>。</p><p>比如说，如何给所有请求都带上一个 Token 供服务器端验证？如何发起并发请求？等等。此外，咱们整个课程都是从 Hooks 角度去思考问题，那么 Hooks 又能给异步逻辑处理带来怎样的优化？这些都是接下来要具体介绍的内容。</p><h1>实现自己的 API Client</h1><p>无论大小项目，在开始实现第一个请求的时候，通常我们要做的第一件事应该都是<strong>创建一个自己的 API Client，之后所有的请求都<strong><strong>会</strong></strong>通过这个</strong> <strong>Client 发出去</strong>。而不是上来就用 fetch 或者是 <a href=\"https://github.com/axios/axios\">axios</a> 去直接发起请求，因为那会造成大量的重复代码。</p><!-- [[[read_end]]] --><p>实现这样一个 Client 之后，你就有了一个统一的地方，去对你需要连接的服务端做一些通用的配置和处理，比如 Token、URL、错误处理等等。</p><p>这个步骤呢，虽然跟 React 和 Hooks 没有直接的关系，但是我经常看到很多同学是在多个组件内分别实现了异步请求处理，写了很多重复代码之后，才开始考虑把这个功能提取出来，增加了额外工作量。所以这里我就先简单介绍下，实现这样一个 API Client 需要考虑哪些因素。</p><p>通常来说，会包括以下几个方面：</p><ol>\n<li>一些通用的 Header。比如 Authorization Token。</li>\n<li>服务器地址的配置。前端在开发和运行时可能会连接不同的服务器，比如本地服务器或者测试服务器，此时这个 API Client 内部可以根据当前环境判断该连接哪个 URL。</li>\n<li>请求未认证的处理。比如如果 Token 过期了，需要有一个统一的地方进行处理，这时就会弹出对话框提示用户重新登录。</li>\n</ol><p>从我的经验来看，我更推荐把 axios 作为基础来实现这个功能。原因就在于，axios 比起 fetch，提供了更为方便，也更加语义化的 API，比如请求拦截。此外，还很容易创建多个实例，让代码逻辑更简洁。所以我就以 axios 为例，提供一个示例实现：</p><pre><code>import axios from &quot;axios&quot;;\n\n// 定义相关的 endpoint\nconst endPoints = {\n  test: &quot;https://60b2643d62ab150017ae21de.mockapi.io/&quot;,\n  prod: &quot;https://prod.myapi.io/&quot;,\n  staging: &quot;https://staging.myapi.io/&quot;\n};\n\n// 创建 axios 的实例\nconst instance = axios.create({\n  // 实际项目中根据当前环境设置 baseURL\n  baseURL: endPoints.test,\n  timeout: 30000,\n  // 为所有请求设置通用的 header\n  headers: { Authorization: &quot;Bear mytoken&quot; }\n});\n\n// 听过 axios 定义拦截器预处理所有请求\ninstance.interceptors.response.use(\n  (res) =&gt; {\n    // 可以假如请求成功的逻辑，比如 log\n    return res;\n  },\n  (err) =&gt; {\n    if (err.response.status === 403) {\n      // 统一处理未授权请求，跳转到登录界面\n      document.location = '/login';\n    }\n    return Promise.reject(err);\n  }\n);\n\nexport default instance;\n</code></pre><p>这样我们就定义了一个简单的 API Client，之后所有的请求都可以通过 Client 连接到指定的服务器，从而不再需要单独设置 Header，或者处理未授权的请求了。当然，虽然例子中用的是 axios，但如果你更倾向于原生的 fetch API，那么使用 fetch 也是完全可以的。这两种方式没有绝对的优劣，你可以按照自己的喜好进行选择。</p><p>有了这个 Client，那接下来的例子中，我们都会使用这个 Client ，来连接指定的 server。</p><h1>使用 Hooks 思考异步请求：封装远程资源</h1><p>在第2讲我曾经介绍过 Hooks 的一个本质特性，那就是万物皆可钩，意思是说我们可以把任何一个数据源变成 React 组件中可以绑定的一个数据源。</p><p>这个特性对于远程的 Get 类型的请求非常有用。因为 Get 请求，通常就是用来获取数据的。所以从 Hooks 角度来说，我们可以认为一个 Get 请求就是一个远程数据源。那么把这个数据源封装成 Hooks 后，使用远程 API 将会非常方便。</p><p>下面这张图可以比较直观地描述这种模式。对于一个 Get 类型的 API，我们完全可以将它看成一个远程的资源。只是和本地数据不同的地方在于，它有三个状态，分别是：</p><ol>\n<li>Data: 指的是请求成功后服务器返回的数据；</li>\n<li>Error: 请求失败的话，错误信息将放到 Error 状态里；</li>\n<li>Pending: 请求发出去，在返回之前会处于 Pending 状态。</li>\n</ol><p><img src=\"https://static001.geekbang.org/resource/image/22/28/225476cd373efff40fe11d796a1da228.png?wh=800x450\" alt=\"\"></p><p>有了这三个状态，我们就能够在 UI 上去显示 loading，error 或者获取成功的数据了。使用起来会非常方便。</p><p>要实现这样一个 Hook 其实也并不难，比起在组件内部直接发请求，我们只是把代码换了个地方，也就是写到了 Hook 里面。下面是代码的实现：</p><pre><code>import { useState, useEffect } from &quot;react&quot;;\nimport apiClient from &quot;./apiClient&quot;;\n\n// 将获取文章的 API 封装成一个远程资源 Hook\nconst useArticle = (id) =&gt; {\n  // 设置三个状态分别存储 data, error, loading\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  useEffect(() =&gt; {\n    // 重新获取数据时重置三个状态\n    setLoading(true);\n    setData(null);\n    setError(null);\n    apiClient\n      .get(`/posts/${id}`)\n      .then((res) =&gt; {\n        // 请求成功时设置返回数据到状态\n        setLoading(false);\n        setData(res.data);\n      })\n      .catch((err) =&gt; {\n        // 请求失败时设置错误状态\n        setLoading(false);\n        setError(err);\n      });\n  }, [id]); // 当 id 变化时重新获取数据\n\n  // 将三个状态作为 Hook 的返回值\n  return {\n    loading,\n    error,\n    data\n  };\n};\n</code></pre><p>那么要显示一篇文章的时候，你的脑子里就不再是一个具体的 API 调用，而可以把它看作一个数据，只不过是个远程数据，于是很自然就有加载状态或者错误状态这些数据了。使用的时候，我们就可以把组件的表现层逻辑写得非常简洁：</p><pre><code>import useArticle from &quot;./useArticle&quot;;\n\nconst ArticleView = ({ id }) =&gt; {\n  // 将 article 看成一个远程资源，有 data, loading, error 三个状态\n  const { data, loading, error } = useArticle(id);\n  if (error) return &quot;Failed.&quot;;\n  if (!data || loading) return &quot;Loading...&quot;;\n  return (\n    &lt;div className=&quot;exp-09-article-view&quot;&gt;\n      &lt;h1&gt;\n        {id}. {data.title}\n      &lt;/h1&gt;\n      &lt;p&gt;{data.content}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n};\n</code></pre><p>可以看到，有了这样一个 Hook，React 的函数组件几乎不需要有任何业务的逻辑，而只是<strong>把数据映射到 JSX并显示出来</strong>就可以了，在使用的时候非常方便。</p><p>事实上，在我们的项目中，可以把每一个 Get 请求都做成这样一个 Hook。数据请求和处理逻辑都放到 Hooks 中，从而实现 Model 和 View 的隔离，不仅代码更加模块化，而且更易于测试和维护。</p><p>这里有同学可能会问，为什么要给每个请求都定义一个 Hook 呢？我们直接提供一个通用的 Hook，比如 useRemoteData，然后把 API 地址传进去，难道不可以吗？</p><p>不是完全不可以，但这其实是<strong>为了保证每个 Hook 自身足够简单</strong>。一般来说，为了让服务器的返回数据满足 UI 上的展现要求，通常需要进一步处理。而这个对于每个请求的处理逻辑可能都不一样，通过一定的代码重复，能够避免产生太复杂的逻辑。</p><p>同时呢，某个远程资源有可能是由多个请求组成的，那么 Hooks 中的逻辑就会不一样，因为要同时发出去多个请求，组成 UI 展现所需要的数据。所以，将每个 Get 请求都封装成一个 Hook ，也是为了让逻辑更清楚。</p><p>当然，这个模式<strong>仅适用于Get 请求的逻辑</strong>，对于其它类型，我在第6讲中有提到过。当时举的例子是 useAsync 这样一个自定义的 Hook，同样也是用 Hook 的思想，把请求的不同状态封装成了一个数据源供组件使用。</p><h1>多个 API 调用：如何处理并发或串行请求？</h1><p>在刚才讲的文章显示的例子中，我们只是简单显示了文章的内容，要知道，实际场景肯定比这个更复杂。比如，还需要显示作者、作者头像，以及文章的评论列表。那么，作为一个完整的页面，就需要<strong>发送三个请求</strong>：</p><ol>\n<li>获取文章内容；</li>\n<li>获取作者信息，包括名字和头像的地址；</li>\n<li>获取文章的评论列表；</li>\n</ol><p>这三个请求<strong>同时包含了并发和串行的场景</strong>：文章内容和评论列表是两个可以并发的请求，它们都通过 Article ID 来获取；用户的信息需要等文章内容返回，这样才能知道作者的 ID，从而根据用户的 ID 获取用户信息，这是一个串行的场景。</p><p>如果用传统的思路去实现，可能会写下这样一段代码，或者类似的代码：</p><pre><code>// 并发获取文章和评论列表\nconst [article, comments] = await Promise.all([\n  fetchArticle(articleId),\n  fetchComments(articleId)\n]);\n// 得到文章信息后，通过 userId 获取用户信息\nconst user = await fetchUser(article.userId);\n</code></pre><p>但是我们知道，<strong>React 函数组件是一个同步的函数</strong>，没有办法直接使用 await 这样的同步方法，而是<strong>要把请求通过副作用去触发</strong>。因此如果按照上面这种传统的思维，是很难把逻辑理顺的。</p><p>这时候我们就要回到 React 的本质，那就是状态驱动 UI。这意味着我们可以<strong>从状态变化的角度去组织异步调用</strong>。</p><p>函数组件的每一次 render，其实都提供了我们根据状态变化执行不同操作的机会，我们思考的路径，就是<strong>利用这个机制，通过不同的状态组合，来实现异步请求的逻辑</strong>。</p><p>那么刚才这个显示作者和评论列表的业务需求，主要的实现思路就包括下面这么四点：</p><ol>\n<li>组件首次渲染，只有文章 ID 这个信息，产生两个副作用去获取文章内容和评论列表；</li>\n<li>组件首次渲染，作者 ID 还不存在，因此不发送任何请求；</li>\n<li>文章内容请求返回后，获得了作者 ID，然后发送请求获取用户信息；</li>\n<li>展示用户信息。</li>\n</ol><p>可以看到，这里的任何一个副作用，也就是<strong>异步请求，都是基于数据的状态去进行的</strong>。只有当文章的数据返回之后，我们才能得到作者 ID，从而再发送另外一个请求来获取作者信息。这样基于一个数据状态的变化，我们就实现了串行发送请求这个功能。</p><p>所以，在代码层面，我们首先需要对 useUser 这个 Hook 做一个改造，使得它在没有传入ID的情况下，就不发送请求。对比上面的 useArticle 这个 Hook，唯一的变化就是<strong>在 useEffect 里加入了<strong><strong>ID是</strong></strong>否存在的判断</strong>：</p><pre><code>import { useState, useEffect } from &quot;react&quot;;\nimport apiClient from &quot;./apiClient&quot;;\n\nexport default (id) =&gt; {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  useEffect(() =&gt; {\n    // 当 id 不存在，直接返回，不发送请求\n    if (!id) return;\n    setLoading(true);\n    setData(null);\n    setError(null);\n    apiClient\n      .get(`/users/${id}`)\n      .then((res) =&gt; {\n        setLoading(false);\n        setData(res.data);\n      })\n      .catch((err) =&gt; {\n        setLoading(false);\n        setError(err);\n      });\n  }, [id]);\n  return {\n    loading,\n    error,\n    data\n  };\n};\n\n</code></pre><p>那么，在文章的展示页面，我们就可以使用下面的代码来实现：</p><pre><code>import { useState } from &quot;react&quot;;\nimport CommentList from &quot;./CommentList&quot;;\nimport useArticle from &quot;./useArticle&quot;;\nimport useUser from &quot;./useUser&quot;;\nimport useComments from &quot;./useComments&quot;;\n\nconst ArticleView = ({ id }) =&gt; {\n  const { data: article, loading, error } = useArticle(id);\n  const { data: comments } = useComments(id);\n  const { data: user } = useUser(article?.userId);\n  if (error) return &quot;Failed.&quot;;\n  if (!article || loading) return &quot;Loading...&quot;;\n  return (\n    &lt;div className=&quot;exp-09-article-view&quot;&gt;\n      &lt;h1&gt;\n        {id}. {article.title}\n      &lt;/h1&gt;\n      {user &amp;&amp; (\n        &lt;div className=&quot;user-info&quot;&gt;\n          &lt;img src={user.avatar} height=&quot;40px&quot; alt=&quot;user&quot; /&gt;\n          &lt;div&gt;{user.name}&lt;/div&gt;\n          &lt;div&gt;{article.createdAt}&lt;/div&gt;\n        &lt;/div&gt;\n      )}\n      &lt;p&gt;{article.content}&lt;/p&gt;\n      &lt;CommentList data={comments || []} /&gt;\n    &lt;/div&gt;\n  );\n};\n</code></pre><p>这里，结合代码我们<strong>再理一下其中并发和串行请求的思</strong>路。</p><p>因为文章的 ID 已经传进来了，因此 useArticle 和 useComments 这两个 Hooks 会发出两个并发的请求，来分别获取信息。而 userUser 这个 Hook 则需要等 article 内容返回后，才能获得 userId 信息，所以这是一个串行的请求：需要等文章内容的请求完成之后才能发起。</p><p>那么，最终完整的页面显示的效果如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/c4/f5/c41951df887f8ef7b08066fcfde880f5.png?wh=1268x1164\" alt=\"\"></p><p>实际的运行效果你也可以通过文末的代码链接来查看。</p><h1>小结</h1><p>在这一讲，我们看到了怎么从 Hooks 的角度去组织异步请求。</p><p>首先，我们<strong>要定义一个自己的 API Client</strong>，封装整个应用中异步请求的一些通过设置，以及统一处理，方便在 Hooks 中使用。</p><p>然后，我们需要充分利用 Hooks 能让数据源变得可绑定的能力，<strong>让一个远程 API 对应的数据成为一个语义化的数据源</strong>，既可以把业务逻辑和UI 展现很好地分开，也有利于测试和维护。</p><p>最后呢，我们学习了针对多请求的处理，怎么<strong>利用状态的组合变化来实现并发和串行请求</strong>。</p><p>学到这里，你会发现，这节课的内容可能和传统的思考方式有较大区别，所以你一定要结合课程代码，仔细思考和体会，才能将这种思考方式熟记于心，并熟练运用到实际的开发当中。</p><p>课程中的例子地址是：<a href=\"https://codesandbox.io/s/react-hooks-course-20vzg\">https://codesandbox.io/s/react-hooks-course-20vzg</a>。你可以在线查看代码和运行效果。</p><h1>思考题</h1><ol>\n<li>在课程的例子中，每次调用 useArticle 这个 Hook 的时候都会触发副作用去获取数据。但是有时候，我们希望在有些组件自动获取，但有的组件中需要点击某个按钮才去获取数据，那么你会如何设计这个 Hook？（可能这道题有一点难度。）</li>\n<li>课程中的 Hook 都是使用的 useState 保存了状态数据，也就意味着状态的范围限定在组件内部，组件销毁后，数据就没了。那么如果希望数据直接缓存到全局状态，应该如何做呢？</li>\n</ol><p>欢迎把你的思考和想法分享在留言区，我会把其中不错的回答进行置顶，供同学们交流讨论。期待你的分享！</p>","neighbors":{"left":{"article_title":"答疑解惑01｜如何转换应用React Hooks 的思路？","id":384252},"right":{"article_title":"10｜函数组件设计模式：如何应对复杂条件渲染场景？","id":385358}},"comments":[{"had_liked":false,"id":299639,"user_name":"知行方","can_delete":false,"product_type":"c1","uid":1000353,"ip_address":"","ucode":"5828A930327E28","user_header":"https://static001.geekbang.org/account/avatar/00/0f/43/a1/abb7bfe3.jpg","comment_is_top":true,"comment_ctime":1624775592,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"9.2233720814292009e+18","product_id":100079901,"comment_content":"const useClick = (id) =&gt; {<br>    const [data, setData] = useState(null);<br>    const [loading, setLoading] = useState(null);<br>    const [error, setError] = useState(null);<br><br>    const exeFun = useCallback(() =&gt; {<br>        setLoading(true);<br>        setData(null);<br>        setError(null);<br>        apiClient<br>            .get(`&#47;posts&#47;${id}`)<br>            .then((res) =&gt; {<br>                setLoading(false)<br>                setData(res.data)<br>            })<br>            .catch((err) =&gt; {<br>                setLoading(false)<br>                setError(err);<br>            })<br>    }, []);<br><br>    return { exeFun, data, loading, error }<br>}<br><br>    const { exeFun, data:comm } = useClick(1);<br><br>&lt;button onClick={()=&gt;{exeFun(&quot;1&quot;)}}&gt;点击发送请求&lt;&#47;button&gt;<br>按照老师之前写的逻辑，用这种方式也可以点击按钮后去发送请求获取数据","like_count":10},{"had_liked":false,"id":297674,"user_name":"Isaac","can_delete":false,"product_type":"c1","uid":1110607,"ip_address":"","ucode":"038C349AB508AB","user_header":"https://static001.geekbang.org/account/avatar/00/10/f2/4f/59bd4141.jpg","comment_is_top":true,"comment_ctime":1623725478,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"9.2233720728381993e+18","product_id":100079901,"comment_content":"思考题：<br>1. useArticle Hook 可以提供一个参数，用来标记本地调用是否默认触发副作用去获取数据；对于点击按钮才触发请求的功能，可以在 Hook 中将获取数据的方法 retrn 出去，供外部自由调用。<br>2. 可以借助 redux，配合 useContext 等 api ，将状态数据存储至全局中。","like_count":8},{"had_liked":false,"id":298558,"user_name":"江谢木","can_delete":false,"product_type":"c1","uid":1563403,"ip_address":"","ucode":"E1B1B0F0F03D41","user_header":"https://static001.geekbang.org/account/avatar/00/17/db/0b/f0ded153.jpg","comment_is_top":false,"comment_ctime":1624194324,"is_pvip":false,"replies":[{"id":"108331","content":"这是新的 js 的标准 叫做 optional chaining：https:&#47;&#47;github.com&#47;tc39&#47;proposal-optional-chaining ，目前已经到 stage 4 完成状态。<br>在处理 article 可能是 undefine的 的情况时，两者是等价的。但如果 article 还可能是 0，false，null 这样的 falsy 的值时，两者的返回值会不一样。article &amp;&amp; article.userId 返回 0, false 或者 null，而 article?.userId 返回 undefined。<br><br>所以一般情况下，我们都可以用 ?. 来简化一些条件判断。","user_name":"作者回复","comment_id":298558,"uid":"1018676","ip_address":"","utype":1,"ctime":1624246606,"user_name_real":"Nate"}],"discussion_count":4,"race_medal":0,"score":"23099030804","product_id":100079901,"comment_content":"老师，article?.userId和article&amp;&amp;article.userId的作用是一样的？第一次见这种写法，感觉好简洁","like_count":5,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522172,"discussion_content":"这是新的 js 的标准 叫做 optional chaining：https://github.com/tc39/proposal-optional-chaining ，目前已经到 stage 4 完成状态。\n在处理 article 可能是 undefine的 的情况时，两者是等价的。但如果 article 还可能是 0，false，null 这样的 falsy 的值时，两者的返回值会不一样。article &amp;amp;&amp;amp; article.userId 返回 0, false 或者 null，而 article?.userId 返回 undefined。\n\n所以一般情况下，我们都可以用 ?. 来简化一些条件判断。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624246606,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1380860,"avatar":"https://static001.geekbang.org/account/avatar/00/15/11/fc/80256cc8.jpg","nickname":"心若水，则长安","note":"","ucode":"4D7AE6552A65A4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386627,"discussion_content":"可选链，还有??，let a = a?.b ?? &#39;123&#39;，用起来贼爽，当a或b为null或者undefined的时候，会返回??后面的值，少写许多判断","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1627698996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2632198,"avatar":"https://static001.geekbang.org/account/avatar/00/28/2a/06/da417908.jpg","nickname":"清风月明","note":"","ucode":"54C98300A9F4DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391331,"discussion_content":"看来js也把ts的好的东西给吸收进来了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630402648,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1563968,"avatar":"https://static001.geekbang.org/account/avatar/00/17/dd/40/7eca8b3d.jpg","nickname":"123231","note":"","ucode":"261F4048195F61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379907,"discussion_content":"一样的写法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624239621,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":297733,"user_name":"L","can_delete":false,"product_type":"c1","uid":1228268,"ip_address":"","ucode":"26BB686671F7D4","user_header":"https://static001.geekbang.org/account/avatar/00/12/bd/ec/cc7abf0b.jpg","comment_is_top":false,"comment_ctime":1623749600,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"18803618784","product_id":100079901,"comment_content":"1. hooks提供一个函数出来用来主动调用<br>2. redux或者context等内容，对接口调用进行一次改造，先判断是否有缓存，再来决定是否调用接口","like_count":4},{"had_liked":false,"id":297989,"user_name":"🌵小畅叙","can_delete":false,"product_type":"c1","uid":1921829,"ip_address":"","ucode":"049BA8404ADE96","user_header":"https://static001.geekbang.org/account/avatar/00/1d/53/25/30e025da.jpg","comment_is_top":false,"comment_ctime":1623861772,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14508763660","product_id":100079901,"comment_content":"老师，对于 loading 和错误处理，我们项目是在全局处理的，且 loading 是通过 redux 管理的，想咨询一下，跟您的方法相比，应该用哪种方法呢？","like_count":3},{"had_liked":false,"id":306030,"user_name":"花儿与少年","can_delete":false,"product_type":"c1","uid":1046304,"ip_address":"","ucode":"E2D685737E4F1B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/20/e2dfa9c2.jpg","comment_is_top":false,"comment_ctime":1628307619,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10218242211","product_id":100079901,"comment_content":"老师能讲解下思考题吗","like_count":2},{"had_liked":false,"id":297759,"user_name":"Free fall","can_delete":false,"product_type":"c1","uid":2637054,"ip_address":"","ucode":"8DBF73CD0F423F","user_header":"","comment_is_top":false,"comment_ctime":1623764053,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10213698645","product_id":100079901,"comment_content":"const defaultResult = {<br>  error: null,<br>  data: null,<br>  loading: false,<br>}<br>const useArticle = ({ id, isAutoFetch = true }) =&gt; {<br>  const [result, setResult] = useState(defaultResult)<br><br>  const fetch = (id) =&gt; {<br>    apiClient<br>      .get(`&#47;posts&#47;${id}`)<br>      .then((res) =&gt; {<br>        setResult({ ...defaultResult, loading: false, data: res.data })<br>      })<br>      .catch((err) =&gt; {<br>        setResult({ ...defaultResult, loading: false, error: err })<br>      })<br>  }<br><br>  useEffect(() =&gt; {<br>    if (!id) return<br>    if (!isAutoFetch) return<br><br>    setResult({ ...defaultResult, loading: true })<br><br>    fetch(id)<br>  }, [id, isAutoFetch])<br><br>  return isAutoFetch ? result : { ...result, fetch }<br>}","like_count":2},{"had_liked":false,"id":298094,"user_name":"琪琪","can_delete":false,"product_type":"c1","uid":2462877,"ip_address":"","ucode":"FBD4EBA6ADB80C","user_header":"https://static001.geekbang.org/account/avatar/00/25/94/9d/0d8103ad.jpg","comment_is_top":false,"comment_ctime":1623909871,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5918877167","product_id":100079901,"comment_content":"老师，请问需要封装一个需要发送post请求的自定义hooks应该如何封装呢？","like_count":1},{"had_liked":false,"id":357366,"user_name":"tron","can_delete":false,"product_type":"c1","uid":1624821,"ip_address":"浙江","ucode":"F94DB2BE804998","user_header":"https://static001.geekbang.org/account/avatar/00/18/ca/f5/3f95bf91.jpg","comment_is_top":false,"comment_ctime":1663205580,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663205580","product_id":100079901,"comment_content":"看完这个异步串联的多请求 只想说：react Hooks真清爽 老师讲的真棒~","like_count":0},{"had_liked":false,"id":354935,"user_name":"Jeffrey Ma","can_delete":false,"product_type":"c1","uid":1374957,"ip_address":"四川","ucode":"0C5E2AB51E6A83","user_header":"https://static001.geekbang.org/account/avatar/00/14/fa/ed/0742b854.jpg","comment_is_top":false,"comment_ctime":1660894484,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660894484","product_id":100079901,"comment_content":"1、因为 {excute, lodaing,error} = useAsync(()=&gt;promise),   这里的excute 就是用来提供给外部触发的， 所以，在封装业务hook 的时候，可以使用副作用 useeffect (()=&gt; excute(),[])调用一次。 <br>如果不需要， 就直接把excute 透传出去。<br>2、redux","like_count":0},{"had_liked":false,"id":337354,"user_name":"不想说什么","can_delete":false,"product_type":"c1","uid":1178833,"ip_address":"","ucode":"D6EC4588E8FC4A","user_header":"https://static001.geekbang.org/account/avatar/00/11/fc/d1/3aeba287.jpg","comment_is_top":false,"comment_ctime":1646788844,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646788844","product_id":100079901,"comment_content":"使用多个hook请求会造成组件多次渲染吧，和在useEffect的<br>  useEffect(() =&gt; {<br>    const getData = async () =&gt; {<br>       &#47;&#47;获取api数据<br>       &#47;&#47; 并发获取文章和评论列表const [article, comments] = await Promise.all([ f <br>            etchArticle(articleId), fetchComments(articleId)]);&#47;&#47; 得到文章信息后，通过 userId 获取用户信息<br>            const user = await fetchUser(article.userId);<br>           setUser(user);<br>           setComments(comments)<br>    }<br><br>    getData();<br>  }, [])<br><br>这两种方式的那个更适合一点","like_count":0},{"had_liked":false,"id":337137,"user_name":"嘿吼","can_delete":false,"product_type":"c1","uid":2257919,"ip_address":"","ucode":"7E4C69C4CE99D0","user_header":"https://static001.geekbang.org/account/avatar/00/22/73/ff/3e30f1c6.jpg","comment_is_top":false,"comment_ctime":1646643008,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646643008","product_id":100079901,"comment_content":"1111","like_count":0},{"had_liked":false,"id":337136,"user_name":"嘿吼","can_delete":false,"product_type":"c1","uid":2257919,"ip_address":"","ucode":"7E4C69C4CE99D0","user_header":"https://static001.geekbang.org/account/avatar/00/22/73/ff/3e30f1c6.jpg","comment_is_top":false,"comment_ctime":1646642981,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646642981","product_id":100079901,"comment_content":"&lt;button&gt;ceshi&lt;&#47;button&gt;","like_count":0},{"had_liked":false,"id":337134,"user_name":"嘿吼","can_delete":false,"product_type":"c1","uid":2257919,"ip_address":"","ucode":"7E4C69C4CE99D0","user_header":"https://static001.geekbang.org/account/avatar/00/22/73/ff/3e30f1c6.jpg","comment_is_top":false,"comment_ctime":1646642828,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646642828","product_id":100079901,"comment_content":"&lt;button&gt;ceshi&lt;&#47;button&gt;","like_count":0},{"had_liked":false,"id":323182,"user_name":"李","can_delete":false,"product_type":"c1","uid":1018884,"ip_address":"","ucode":"1EBACEC0C03F93","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/04/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1637754007,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637754007","product_id":100079901,"comment_content":"老师，这种逻辑上连续的查询请求放到好几个hooks里去，由于每个hooks都有自己的loading state状态变化，所以最终会导致页面函数多重复执行几次渲染， 这算负优化吗","like_count":0},{"had_liked":false,"id":321273,"user_name":"🐎","can_delete":false,"product_type":"c1","uid":1054094,"ip_address":"","ucode":"DD325A4DD40153","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/8e/8fc00a53.jpg","comment_is_top":false,"comment_ctime":1636731071,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1636731071","product_id":100079901,"comment_content":"老师，我发现这种使用方式会触发组件多次渲染，会打印好几次article，如果是展示那没有问题，可如果是取到数据弹窗展示的话就会弹很多次，这怎么解决呢？","like_count":0},{"had_liked":false,"id":311290,"user_name":"陈毫杰","can_delete":false,"product_type":"c1","uid":2753360,"ip_address":"","ucode":"6D7804E60AB20E","user_header":"","comment_is_top":false,"comment_ctime":1631156785,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631156785","product_id":100079901,"comment_content":"我觉得可以为useArticle多添加一个依赖，当需要自动获取时，就初始化给该依赖设置特定值。当需要事件调用时，通过useState的控制器设置该依赖为特定值，再去调用。","like_count":0},{"had_liked":false,"id":304612,"user_name":"1830","can_delete":false,"product_type":"c1","uid":1374337,"ip_address":"","ucode":"246FEF7C97F39C","user_header":"https://static001.geekbang.org/account/avatar/00/14/f8/81/bff52f91.jpg","comment_is_top":false,"comment_ctime":1627522622,"is_pvip":false,"replies":[{"id":"110258","content":"这里倒没有“强行”，例子中的 article 和 user 是两个不同的数据源，所以根据状态分别获取应该比较容易理解。如果两个请求总是在一起使用，那么其实可以封装成一个方法去获取两个请求，这样在使用的时候就等价于一个异步请求了。","user_name":"作者回复","comment_id":304612,"uid":"1018676","ip_address":"","utype":1,"ctime":1627634351,"user_name_real":"Nate"}],"discussion_count":1,"race_medal":0,"score":"1627522622","product_id":100079901,"comment_content":"老师，关于串行请求我有些想法，对于多个串行请求它们在逻辑上本身具有连续性，而我们强行把它们分散到单个的hook中是不是加大了代码复杂程度和日后逻辑的理解难度。就是感觉有点重hook的语法形式而忽律了原本的关联性","like_count":0},{"had_liked":false,"id":298912,"user_name":"༺程༻","can_delete":false,"product_type":"c1","uid":1442199,"ip_address":"","ucode":"05B0370E629E60","user_header":"https://static001.geekbang.org/account/avatar/00/16/01/97/16badf02.jpg","comment_is_top":false,"comment_ctime":1624368283,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1624368283","product_id":100079901,"comment_content":"apiClient<br>.get(`&#47;posts&#47;${id}`)<br>.then((res) =&gt; { <br> &#47;&#47; 请求成功时设置返回数据到状态<br>setLoading(false);<br>setData(res.data);<br> })<br><br>返回数据之后，先setLoading，再setData这是一种不安全的写法。<br>由于hook机制，一个hook会产生一次更新，在setLoading之后，setData之前，这个间隔中会产生一个loading  === false  data为null的状态，此时UI层会认为data有数据（因为loading=false，error=null），就容易报错。所以应该先setData再setLoading，但是最好用一个对象，包含data，loading，error，这样一次setData解决问题。","like_count":0,"discussions":[{"author":{"id":1345253,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/e5/b391125d.jpg","nickname":"简单","note":"","ucode":"A087B6617F9CBE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551544,"discussion_content":"在 react 的 event handler 内部同步的多次 setState 会被 batch 为一次更新","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645061364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1404748,"avatar":"","nickname":"肖龙","note":"","ucode":"872D4C91B3DA69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383510,"discussion_content":"回头打个console看一下，可能这里的set是同步的，那可能的确不安全，不过浏览器有可能在这之间触发渲染吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626139018,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":297775,"user_name":"闲闲","can_delete":false,"product_type":"c1","uid":1637571,"ip_address":"","ucode":"B2099BDCFF6191","user_header":"https://static001.geekbang.org/account/avatar/00/18/fc/c3/0991edfc.jpg","comment_is_top":false,"comment_ctime":1623771074,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623771074","product_id":100079901,"comment_content":"问题1. 是否可以例如class组件reveiverProps的思想，在apiHook里面接受一个值假设是id，外层调用的时候控制这个id的变化，如果btn点击想要触发，可以将id设置为时间戳每次点击传的id不一样就驱动副作用了<br>问题2. 可以使用useRef这个hook","like_count":0},{"had_liked":false,"id":297756,"user_name":"Free fall","can_delete":false,"product_type":"c1","uid":2637054,"ip_address":"","ucode":"8DBF73CD0F423F","user_header":"","comment_is_top":false,"comment_ctime":1623762963,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623762963","product_id":100079901,"comment_content":"useEffect(() =&gt; {<br>    if (!id) return<br>    if (!isAutoFetch) return<br><br>    setLoading(true)<br>    setError(null)<br>    setData(null)<br><br>    apiClient<br>      .get(`&#47;posts&#47;${id}`)<br>      .then((res) =&gt; {<br>        setLoading(false)<br>        setData(res.data)<br>      })<br>      .catch((err) =&gt; {<br>        setLoading(false)<br>        setError(err)<br>      })<br>  }, [id, isAutoFetch])<br><br>  return {<br>    loading,<br>    error,<br>    data,<br>    setIsAutoFetch,<br>  }<br>}","like_count":0},{"had_liked":false,"id":297748,"user_name":"Geek_71adef","can_delete":false,"product_type":"c1","uid":2643315,"ip_address":"","ucode":"E3CC6F6FBB1468","user_header":"","comment_is_top":false,"comment_ctime":1623758676,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623758676","product_id":100079901,"comment_content":"1,点击事件可以考虑到中间件，返回一个函数<br>2 全局可以用redux或者usecontext 成为全局变量<br> 请问老师 userReducer是同步吧","like_count":0}]}