{"id":210337,"title":"03 | 线程池：业务代码最常用也最容易犯错的组件","content":"<p>你好，我是朱晔。今天，我来讲讲使用线程池需要注意的一些问题。</p><p>在程序中，我们会用各种池化技术来缓存创建昂贵的对象，比如线程池、连接池、内存池。一般是预先创建一些对象放入池中，使用的时候直接取出使用，用完归还以便复用，还会通过一定的策略调整池中缓存对象的数量，实现池的动态伸缩。</p><p>由于线程的创建比较昂贵，随意、没有控制地创建大量线程会造成性能问题，因此短平快的任务一般考虑使用线程池来处理，而不是直接创建线程。</p><p>今天，我们就针对线程池这个话题展开讨论，通过三个生产事故，来看看使用线程池应该注意些什么。</p><h2>线程池的声明需要手动进行</h2><p>Java中的Executors类定义了一些快捷的工具方法，来帮助我们快速创建线程池。《阿里巴巴Java开发手册》中提到，禁止使用这些方法来创建线程池，而应该手动new ThreadPoolExecutor来创建线程池。这一条规则的背后，是大量血淋淋的生产事故，最典型的就是newFixedThreadPool和newCachedThreadPool，可能因为资源耗尽导致OOM问题。</p><p>首先，我们来看一下newFixedThreadPool为什么可能会出现OOM的问题。</p><p>我们写一段测试代码，来初始化一个单线程的FixedThreadPool，循环1亿次向线程池提交任务，每个任务都会创建一个比较大的字符串然后休眠一小时：</p><!-- [[[read_end]]] --><pre><code>@GetMapping(&quot;oom1&quot;)\npublic void oom1() throws InterruptedException {\n\n    ThreadPoolExecutor threadPool = (ThreadPoolExecutor) Executors.newFixedThreadPool(1);\n    //打印线程池的信息，稍后我会解释这段代码\n    printStats(threadPool); \n    for (int i = 0; i &lt; 100000000; i++) {\n        threadPool.execute(() -&gt; {\n            String payload = IntStream.rangeClosed(1, 1000000)\n                    .mapToObj(__ -&gt; &quot;a&quot;)\n                    .collect(Collectors.joining(&quot;&quot;)) + UUID.randomUUID().toString();\n            try {\n                TimeUnit.HOURS.sleep(1);\n            } catch (InterruptedException e) {\n            }\n            log.info(payload);\n        });\n    }\n\n    threadPool.shutdown();\n    threadPool.awaitTermination(1, TimeUnit.HOURS);\n}\n</code></pre><p>执行程序后不久，日志中就出现了如下OOM：</p><pre><code>Exception in thread &quot;http-nio-45678-ClientPoller&quot; java.lang.OutOfMemoryError: GC overhead limit exceeded\n</code></pre><p>翻看newFixedThreadPool方法的源码不难发现，线程池的工作队列直接new了一个LinkedBlockingQueue，<strong>而默认构造方法的LinkedBlockingQueue是一个Integer.MAX_VALUE长度的队列，可以认为是无界的</strong>：</p><pre><code>public static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads,\n                                  0L, TimeUnit.MILLISECONDS,\n                                  new LinkedBlockingQueue&lt;Runnable&gt;());\n}\n\npublic class LinkedBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;\n        implements BlockingQueue&lt;E&gt;, java.io.Serializable {\n    ...\n\n\n    /**\n     * Creates a {@code LinkedBlockingQueue} with a capacity of\n     * {@link Integer#MAX_VALUE}.\n     */\n    public LinkedBlockingQueue() {\n        this(Integer.MAX_VALUE);\n    }\n...\n}\n</code></pre><p>虽然使用newFixedThreadPool可以把工作线程控制在固定的数量上，但任务队列是无界的。如果任务较多并且执行较慢的话，队列可能会快速积压，撑爆内存导致OOM。</p><p>我们再把刚才的例子稍微改一下，改为使用newCachedThreadPool方法来获得线程池。程序运行不久后，同样看到了如下OOM异常：</p><pre><code>[11:30:30.487] [http-nio-45678-exec-1] [ERROR] [.a.c.c.C.[.[.[/].[dispatcherServlet]:175 ] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Handler dispatch failed; nested exception is java.lang.OutOfMemoryError: unable to create new native thread] with root cause\njava.lang.OutOfMemoryError: unable to create new native thread \n</code></pre><p>从日志中可以看到，这次OOM的原因是无法创建线程，翻看newCachedThreadPool的源码可以看到，<strong>这种线程池的最大线程数是Integer.MAX_VALUE，可以认为是没有上限的，而其工作队列SynchronousQueue是一个没有存储空间的阻塞队列</strong>。这意味着，只要有请求到来，就必须找到一条工作线程来处理，如果当前没有空闲的线程就再创建一条新的。</p><p>由于我们的任务需要1小时才能执行完成，大量的任务进来后会创建大量的线程。我们知道线程是需要分配一定的内存空间作为线程栈的，比如1MB，因此无限制创建线程必然会导致OOM：</p><pre><code>public static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                  60L, TimeUnit.SECONDS,\n                                  new SynchronousQueue&lt;Runnable&gt;());\n</code></pre><p>其实，大部分Java开发同学知道这两种线程池的特性，只是抱有侥幸心理，觉得只是使用线程池做一些轻量级的任务，不可能造成队列积压或开启大量线程。</p><p>但，现实往往是残酷的。我之前就遇到过这么一个事故：用户注册后，我们调用一个外部服务去发送短信，发送短信接口正常时可以在100毫秒内响应，TPS 100的注册量，CachedThreadPool能稳定在占用10个左右线程的情况下满足需求。在某个时间点，外部短信服务不可用了，我们调用这个服务的超时又特别长，比如1分钟，1分钟可能就进来了6000用户，产生6000个发送短信的任务，需要6000个线程，没多久就因为无法创建线程导致了OOM，整个应用程序崩溃。</p><p>因此，<strong>我同样不建议使用Executors提供的两种快捷的线程池，原因如下</strong>：</p><ul>\n<li>我们需要根据自己的场景、并发情况来评估线程池的几个核心参数，包括核心线程数、最大线程数、线程回收策略、工作队列的类型，以及拒绝策略，确保线程池的工作行为符合需求，一般都需要设置有界的工作队列和可控的线程数。</li>\n<li>任何时候，都应该为自定义线程池指定有意义的名称，以方便排查问题。当出现线程数量暴增、线程死锁、线程占用大量CPU、线程执行出现异常等问题时，我们往往会抓取线程栈。此时，有意义的线程名称，就可以方便我们定位问题。</li>\n</ul><p>除了建议手动声明线程池以外，我还建议<strong>用一些监控手段来观察线程池的状态</strong>。线程池这个组件往往会表现得任劳任怨、默默无闻，除非是出现了拒绝策略，否则压力再大都不会抛出一个异常。如果我们能提前观察到线程池队列的积压，或者线程数量的快速膨胀，往往可以提早发现并解决问题。</p><h2>线程池线程管理策略详解</h2><p>在之前的Demo中，我们用一个printStats方法实现了最简陋的监控，每秒输出一次线程池的基本内部信息，包括线程数、活跃线程数、完成了多少任务，以及队列中还有多少积压任务等信息：</p><pre><code>private void printStats(ThreadPoolExecutor threadPool) {\n   Executors.newSingleThreadScheduledExecutor().scheduleAtFixedRate(() -&gt; {\n        log.info(&quot;=========================&quot;);\n        log.info(&quot;Pool Size: {}&quot;, threadPool.getPoolSize());\n        log.info(&quot;Active Threads: {}&quot;, threadPool.getActiveCount());\n        log.info(&quot;Number of Tasks Completed: {}&quot;, threadPool.getCompletedTaskCount());\n        log.info(&quot;Number of Tasks in Queue: {}&quot;, threadPool.getQueue().size());\n\n        log.info(&quot;=========================&quot;);\n    }, 0, 1, TimeUnit.SECONDS);\n}\n</code></pre><p>接下来，我们就利用这个方法来观察一下线程池的基本特性吧。</p><p>首先，自定义一个线程池。这个线程池具有2个核心线程、5个最大线程、使用容量为10的ArrayBlockingQueue阻塞队列作为工作队列，使用默认的AbortPolicy拒绝策略，也就是任务添加到线程池失败会抛出RejectedExecutionException。此外，我们借助了Jodd类库的ThreadFactoryBuilder方法来构造一个线程工厂，实现线程池线程的自定义命名。</p><p>然后，我们写一段测试代码来观察线程池管理线程的策略。测试代码的逻辑为，每次间隔1秒向线程池提交任务，循环20次，每个任务需要10秒才能执行完成，代码如下：</p><pre><code>@GetMapping(&quot;right&quot;)\npublic int right() throws InterruptedException {\n    //使用一个计数器跟踪完成的任务数\n    AtomicInteger atomicInteger = new AtomicInteger();\n    //创建一个具有2个核心线程、5个最大线程，使用容量为10的ArrayBlockingQueue阻塞队列作为工作队列的线程池，使用默认的AbortPolicy拒绝策略\n    ThreadPoolExecutor threadPool = new ThreadPoolExecutor(\n            2, 5,\n            5, TimeUnit.SECONDS,\n            new ArrayBlockingQueue&lt;&gt;(10),\n            new ThreadFactoryBuilder().setNameFormat(&quot;demo-threadpool-%d&quot;).get(),\n            new ThreadPoolExecutor.AbortPolicy());\n\n    printStats(threadPool);\n    //每隔1秒提交一次，一共提交20次任务\n    IntStream.rangeClosed(1, 20).forEach(i -&gt; {\n        try {\n            TimeUnit.SECONDS.sleep(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        int id = atomicInteger.incrementAndGet();\n        try {\n            threadPool.submit(() -&gt; {\n                log.info(&quot;{} started&quot;, id);\n                //每个任务耗时10秒\n                try {\n                    TimeUnit.SECONDS.sleep(10);\n                } catch (InterruptedException e) {\n                }\n                log.info(&quot;{} finished&quot;, id);\n            });\n        } catch (Exception ex) {\n            //提交出现异常的话，打印出错信息并为计数器减一\n            log.error(&quot;error submitting task {}&quot;, id, ex);\n            atomicInteger.decrementAndGet();\n        }\n    });\n\n    TimeUnit.SECONDS.sleep(60);\n    return atomicInteger.intValue();\n}\n</code></pre><p>60秒后页面输出了17，有3次提交失败了：</p><p><img src=\"https://static001.geekbang.org/resource/image/4b/2c/4b820e0b24ce0deefbf2dd7af295c32c.png?wh=970*204\" alt=\"\"></p><p>并且日志中也出现了3次类似的错误信息：</p><pre><code>[14:24:52.879] [http-nio-45678-exec-1] [ERROR] [.t.c.t.demo1.ThreadPoolOOMController:103 ] - error submitting task 18\njava.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@163a2dec rejected from java.util.concurrent.ThreadPoolExecutor@18061ad2[Running, pool size = 5, active threads = 5, queued tasks = 10, completed tasks = 2]\n</code></pre><p>我们把printStats方法打印出的日志绘制成图表，得出如下曲线：</p><p><img src=\"https://static001.geekbang.org/resource/image/d8/1e/d819035f60bf1c0022a98051d50e031e.png?wh=1738*684\" alt=\"\"></p><p><strong>至此，我们可以总结出线程池默认的工作行为</strong>：</p><ul>\n<li>不会初始化corePoolSize个线程，有任务来了才创建工作线程；</li>\n<li>当核心线程满了之后不会立即扩容线程池，而是把任务堆积到工作队列中；</li>\n<li>当工作队列满了后扩容线程池，一直到线程个数达到maximumPoolSize为止；</li>\n<li>如果队列已满且达到了最大线程后还有任务进来，按照拒绝策略处理；</li>\n<li>当线程数大于核心线程数时，线程等待keepAliveTime后还是没有任务需要处理的话，收缩线程到核心线程数。</li>\n</ul><p>了解这个策略，有助于我们根据实际的容量规划需求，为线程池设置合适的初始化参数。当然，我们也可以通过一些手段来改变这些默认工作行为，比如：</p><ul>\n<li>声明线程池后立即调用prestartAllCoreThreads方法，来启动所有核心线程；</li>\n<li>传入true给allowCoreThreadTimeOut方法，来让线程池在空闲的时候同样回收核心线程。</li>\n</ul><p>不知道你有没有想过：Java线程池是先用工作队列来存放来不及处理的任务，满了之后再扩容线程池。当我们的工作队列设置得很大时，最大线程数这个参数显得没有意义，因为队列很难满，或者到满的时候再去扩容线程池已经于事无补了。</p><p>那么，<strong>我们有没有办法让线程池</strong><strong>更激进一点，优先开启更多的线程，而把队列当成一个后备方案呢？</strong>比如我们这个例子，任务执行得很慢，需要10秒，如果线程池可以优先扩容到5个最大线程，那么这些任务最终都可以完成，而不会因为线程池扩容过晚导致慢任务来不及处理。</p><p>限于篇幅，这里我只给你一个大致思路：</p><ol>\n<li>由于线程池在工作队列满了无法入队的情况下会扩容线程池，那么我们是否可以重写队列的offer方法，造成这个队列已满的假象呢？</li>\n<li>由于我们Hack了队列，在达到了最大线程后势必会触发拒绝策略，那么能否实现一个自定义的拒绝策略处理程序，这个时候再把任务真正插入队列呢？</li>\n</ol><p>接下来，就请你动手试试看如何实现这样一个“弹性”线程池吧。Tomcat线程池也实现了类似的效果，可供你借鉴。</p><h2>务必确认清楚线程池本身是不是复用的</h2><p>不久之前我遇到了这样一个事故：某项目生产环境时不时有报警提示线程数过多，超过2000个，收到报警后查看监控发现，瞬时线程数比较多但过一会儿又会降下来，线程数抖动很厉害，而应用的访问量变化不大。</p><p>为了定位问题，我们在线程数比较高的时候进行线程栈抓取，抓取后发现内存中有1000多个自定义线程池。一般而言，线程池肯定是复用的，有5个以内的线程池都可以认为正常，而1000多个线程池肯定不正常。</p><p>在项目代码里，我们没有搜到声明线程池的地方，搜索execute关键字后定位到，原来是业务代码调用了一个类库来获得线程池，类似如下的业务代码：调用ThreadPoolHelper的getThreadPool方法来获得线程池，然后提交数个任务到线程池处理，看不出什么异常。</p><pre><code>@GetMapping(&quot;wrong&quot;)\npublic String wrong() throws InterruptedException {\n    ThreadPoolExecutor threadPool = ThreadPoolHelper.getThreadPool();\n    IntStream.rangeClosed(1, 10).forEach(i -&gt; {\n        threadPool.execute(() -&gt; {\n            ...\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n            }\n        });\n    });\n    return &quot;OK&quot;;\n}\n</code></pre><p>但是，来到ThreadPoolHelper的实现让人大跌眼镜，<strong>getThreadPool方法居然是每次都使用Executors.newCachedThreadPool来创建一个线程池</strong>。</p><pre><code>class ThreadPoolHelper {\n    public static ThreadPoolExecutor getThreadPool() {\n        //线程池没有复用\n        return (ThreadPoolExecutor) Executors.newCachedThreadPool();\n    }\n}\n</code></pre><p>通过上一小节的学习，我们可以想到newCachedThreadPool会在需要时创建必要多的线程，业务代码的一次业务操作会向线程池提交多个慢任务，这样执行一次业务操作就会开启多个线程。如果业务操作并发量较大的话，的确有可能一下子开启几千个线程。</p><p>那，为什么我们能在监控中看到线程数量会下降，而不会撑爆内存呢？</p><p>回到newCachedThreadPool的定义就会发现，它的核心线程数是0，而keepAliveTime是60秒，也就是在60秒之后所有的线程都是可以回收的。好吧，就因为这个特性，我们的业务程序死得没太难看。</p><p>要修复这个Bug也很简单，使用一个静态字段来存放线程池的引用，返回线程池的代码直接返回这个静态字段即可。这里一定要记得我们的最佳实践，手动创建线程池。修复后的ThreadPoolHelper类如下：</p><pre><code>class ThreadPoolHelper {\n\tprivate static ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(\n\t\t10, 50,\n\t\t2, TimeUnit.SECONDS,\n\t\tnew ArrayBlockingQueue&lt;&gt;(1000),\n\t\tnew ThreadFactoryBuilder().setNameFormat(&quot;demo-threadpool-%d&quot;).get());\n\tpublic static ThreadPoolExecutor getRightThreadPool() {\n\t\treturn threadPoolExecutor;\n\t}\n}\n</code></pre><h2>需要仔细斟酌线程池的混用策略</h2><p>线程池的意义在于复用，那这是不是意味着程序应该始终使用一个线程池呢？</p><p>当然不是。通过第一小节的学习我们知道，<strong>要根据任务的“轻重缓急”来指定线程池的核心参数，包括线程数、回收策略和任务队列</strong>：</p><ul>\n<li>对于执行比较慢、数量不大的IO任务，或许要考虑更多的线程数，而不需要太大的队列。</li>\n<li>而对于吞吐量较大的计算型任务，线程数量不宜过多，可以是CPU核数或核数*2（理由是，线程一定调度到某个CPU进行执行，如果任务本身是CPU绑定的任务，那么过多的线程只会增加线程切换的开销，并不能提升吞吐量），但可能需要较长的队列来做缓冲。</li>\n</ul><p>之前我也遇到过这么一个问题，业务代码使用了线程池异步处理一些内存中的数据，但通过监控发现处理得非常慢，整个处理过程都是内存中的计算不涉及IO操作，也需要数秒的处理时间，应用程序CPU占用也不是特别高，有点不可思议。</p><p>经排查发现，业务代码使用的线程池，还被一个后台的文件批处理任务用到了。</p><p>或许是够用就好的原则，这个线程池只有2个核心线程，最大线程也是2，使用了容量为100的ArrayBlockingQueue作为工作队列，使用了CallerRunsPolicy拒绝策略：</p><pre><code>private static ThreadPoolExecutor threadPool = new ThreadPoolExecutor(\n        2, 2,\n        1, TimeUnit.HOURS,\n        new ArrayBlockingQueue&lt;&gt;(100),\n        new ThreadFactoryBuilder().setNameFormat(&quot;batchfileprocess-threadpool-%d&quot;).get(),\n        new ThreadPoolExecutor.CallerRunsPolicy());\n</code></pre><p>这里，我们模拟一下文件批处理的代码，在程序启动后通过一个线程开启死循环逻辑，不断向线程池提交任务，任务的逻辑是向一个文件中写入大量的数据：</p><pre><code>@PostConstruct\npublic void init() {\n    printStats(threadPool);\n\n    new Thread(() -&gt; {\n        //模拟需要写入的大量数据\n        String payload = IntStream.rangeClosed(1, 1_000_000)\n                .mapToObj(__ -&gt; &quot;a&quot;)\n                .collect(Collectors.joining(&quot;&quot;));\n        while (true) {\n            threadPool.execute(() -&gt; {\n                try {\n                    //每次都是创建并写入相同的数据到相同的文件\n                    Files.write(Paths.get(&quot;demo.txt&quot;), Collections.singletonList(LocalTime.now().toString() + &quot;:&quot; + payload), UTF_8, CREATE, TRUNCATE_EXISTING);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                log.info(&quot;batch file processing done&quot;);\n            });\n        }\n    }).start();\n}\n</code></pre><p>可以想象到，这个线程池中的2个线程任务是相当重的。通过printStats方法打印出的日志，我们观察下线程池的负担：</p><p><img src=\"https://static001.geekbang.org/resource/image/49/55/49c132595db60f109530e0dec55ccd55.png?wh=2732*508\" alt=\"\"></p><p>可以看到，<strong>线程池的2个线程始终处于活跃状态，队列也基本处于打满状态。</strong>因为开启了CallerRunsPolicy拒绝处理策略，所以当线程满载队列也满的情况下，任务会在提交任务的线程，或者说调用execute方法的线程执行，也就是说不能认为提交到线程池的任务就一定是异步处理的。如果使用了CallerRunsPolicy策略，那么有可能异步任务变为同步执行。从日志的第四行也可以看到这点。这也是这个拒绝策略比较特别的原因。</p><p>不知道写代码的同学为什么设置这个策略，或许是测试时发现线程池因为任务处理不过来出现了异常，而又不希望线程池丢弃任务，所以最终选择了这样的拒绝策略。不管怎样，这些日志足以说明线程池是饱和状态。</p><p>可以想象到，业务代码复用这样的线程池来做内存计算，命运一定是悲惨的。我们写一段代码测试下，向线程池提交一个简单的任务，这个任务只是休眠10毫秒没有其他逻辑：</p><pre><code>private Callable&lt;Integer&gt; calcTask() {\n    return () -&gt; {\n        TimeUnit.MILLISECONDS.sleep(10);\n        return 1;\n    };\n}\n\n@GetMapping(&quot;wrong&quot;)\npublic int wrong() throws ExecutionException, InterruptedException {\n    return threadPool.submit(calcTask()).get();\n}\n</code></pre><p>我们使用wrk工具对这个接口进行一个简单的压测，可以看到TPS为75，性能的确非常差。</p><p><img src=\"https://static001.geekbang.org/resource/image/98/07/989f7ab383e59e21751adb77a9b53507.png?wh=1188*344\" alt=\"\"></p><p>细想一下，问题其实没有这么简单。因为原来执行IO任务的线程池使用的是CallerRunsPolicy策略，所以直接使用这个线程池进行异步计算的话，<strong>当线程池饱和的时候，计算任务会在执行Web请求的Tomcat线程执行，这时就会进一步影响到其他同步处理的线程，甚至造成整个应用程序崩溃</strong>。</p><p>解决方案很简单，使用独立的线程池来做这样的“计算任务”即可。计算任务打了双引号，是因为我们的模拟代码执行的是休眠操作，并不属于CPU绑定的操作，更类似IO绑定的操作，如果线程池线程数设置太小会限制吞吐能力：</p><pre><code>private static ThreadPoolExecutor asyncCalcThreadPool = new ThreadPoolExecutor(\n\t200, 200,\n\t1, TimeUnit.HOURS,\n\tnew ArrayBlockingQueue&lt;&gt;(1000),\n\tnew ThreadFactoryBuilder().setNameFormat(&quot;asynccalc-threadpool-%d&quot;).get());\n\n\n@GetMapping(&quot;right&quot;)\npublic int right() throws ExecutionException, InterruptedException {\n\treturn asyncCalcThreadPool.submit(calcTask()).get();\n}\n</code></pre><p>使用单独的线程池改造代码后再来测试一下性能，TPS提高到了1727：</p><p><img src=\"https://static001.geekbang.org/resource/image/c2/06/c21eed38ccd18758d38745dd09496a06.png?wh=1214*346\" alt=\"\"></p><p>可以看到，盲目复用线程池混用线程的问题在于，别人定义的线程池属性不一定适合你的任务，而且混用会相互干扰。这就好比，我们往往会用虚拟化技术来实现资源的隔离，而不是让所有应用程序都直接使用物理机。</p><p>就线程池混用问题，我想再和你补充一个坑：<strong>Java 8的parallel stream功能，可以让我们很方便地并行处理集合中的元素，其背后是共享同一个ForkJoinPool，默认并行度是CPU核数-1</strong>。对于CPU绑定的任务来说，使用这样的配置比较合适，但如果集合操作涉及同步IO操作的话（比如数据库操作、外部服务调用等），建议自定义一个ForkJoinPool（或普通线程池）。你可以参考<a href=\"https://time.geekbang.org/column/article/209494\">第一讲</a>的相关Demo。</p><h2>重点回顾</h2><p>线程池管理着线程，线程又属于宝贵的资源，有许多应用程序的性能问题都来自线程池的配置和使用不当。在今天的学习中，我通过三个和线程池相关的生产事故，和你分享了使用线程池的几个最佳实践。</p><p>第一，Executors类提供的一些快捷声明线程池的方法虽然简单，但隐藏了线程池的参数细节。因此，使用线程池时，我们一定要根据场景和需求配置合理的线程数、任务队列、拒绝策略、线程回收策略，并对线程进行明确的命名方便排查问题。</p><p>第二，既然使用了线程池就需要确保线程池是在复用的，每次new一个线程池出来可能比不用线程池还糟糕。如果你没有直接声明线程池而是使用其他同学提供的类库来获得一个线程池，请务必查看源码，以确认线程池的实例化方式和配置是符合预期的。</p><p>第三，复用线程池不代表应用程序始终使用同一个线程池，我们应该根据任务的性质来选用不同的线程池。特别注意IO绑定的任务和CPU绑定的任务对于线程池属性的偏好，如果希望减少任务间的相互干扰，考虑按需使用隔离的线程池。</p><p>最后我想强调的是，<strong>线程池作为应用程序内部的核心组件往往缺乏监控</strong>（如果你使用类似RabbitMQ这样的MQ中间件，运维同学一般会帮我们做好中间件监控），往往到程序崩溃后才发现线程池的问题，很被动。在设计篇中我们会重新谈及这个问题及其解决方案。</p><p>今天用到的代码，我都放在了GitHub上，你可以点击<a href=\"https://github.com/JosephZhu1983/java-common-mistakes\">这个链接</a>查看。</p><h2>思考与讨论</h2><ol>\n<li>在第一节中我们提到，或许一个激进创建线程的弹性线程池更符合我们的需求，你能给出相关的实现吗？实现后再测试一下，是否所有的任务都可以正常处理完成呢？</li>\n<li>在第二节中，我们改进了ThreadPoolHelper使其能够返回复用的线程池。如果我们不小心每次都创建了这样一个自定义的线程池（10核心线程，50最大线程，2秒回收的），反复执行测试接口线程，最终可以被回收吗？会出现OOM问题吗？</li>\n</ol><p>你还遇到过线程池相关的其他坑吗？我是朱晔，欢迎在评论区与我留言分享你的想法，也欢迎你把这篇文章分享给你的朋友或同事，一起交流。</p>","neighbors":{"left":{"article_title":"02 | 代码加锁：不要让“锁”事成为烦心事","id":209520},"right":{"article_title":"04 | 连接池：别让连接池帮了倒忙","id":211388}},"comments":[{"had_liked":false,"id":186988,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":true,"comment_ctime":1583984097,"is_pvip":true,"replies":[{"id":"72131","content":"直接用put即可，可以参考这里的回复：<br>https:&#47;&#47;stackoverflow.com&#47;questions&#47;19528304&#47;how-to-get-the-threadpoolexecutor-to-increase-threads-to-max-before-queueing<br>不过要考虑选择丢数据还是阻塞<br><br>其实，实现自己的RejectedExecutionHandler耦合自己的Queue也无可厚非。Tomcat也是这样的，其实现参考这里：https:&#47;&#47;github.com&#47;apache&#47;tomcat&#47;blob&#47;a801409b37294c3f3dd5590453fb9580d7e33af2&#47;java&#47;org&#47;apache&#47;tomcat&#47;util&#47;threads&#47;ThreadPoolExecutor.java","user_name":"作者回复","comment_id":186988,"uid":"1001470","ip_address":"","utype":1,"ctime":1583988941,"user_name_real":"朱晔"}],"discussion_count":6,"race_medal":0,"score":"9.2233721458128998e+18","product_id":100047701,"comment_content":"第一个问题的来了，请老师指点：<br>https:&#47;&#47;github.com&#47;y645194203&#47;geektime-java-100&#47;blob&#47;master&#47;ExtremeThreadPoolExecutor.java<br><br>里面自定义了一个extremeOffer方法，因为不是BlockQUeue接口的方法，所以在执行拒绝策略后，真正加入阻塞队列的时候强转了一些，感觉不是很好，有没有更好的处理方法，请老师指点下。<br><br><br>加上之前回答的第二个问题答案：<br>不会被回收，会OOM，即使是自定义线程池，核心线程是不会回收的，每次需要10个线程，刚好是核心线程数，因此每次请求都会创建10个核心线程数的线程池，请求次数多了后，很快就回OOM。<br>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create new native thread","like_count":26,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486945,"discussion_content":"直接用put即可，可以参考这里的回复：\nhttps://stackoverflow.com/questions/19528304/how-to-get-the-threadpoolexecutor-to-increase-threads-to-max-before-queueing\n不过要考虑选择丢数据还是阻塞\n\n其实，实现自己的RejectedExecutionHandler耦合自己的Queue也无可厚非。Tomcat也是这样的，其实现参考这里：https://github.com/apache/tomcat/blob/a801409b37294c3f3dd5590453fb9580d7e33af2/java/org/apache/tomcat/util/threads/ThreadPoolExecutor.java","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583988941,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1254968,"avatar":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","nickname":"Darren","note":"","ucode":"CCD2B2C492BE9A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":203070,"discussion_content":"其实老师给的stackoverflow我不是很赞成，但是怎么回复老师才能看见，目前还不知道。。。。\n不赞成的原因是put是一个阻塞方法，当队列满了后，put方法会一直被阻塞着，就不会真正的触发拒绝策略了，且按照我的理解put阻塞的应该就是主线程，这么做肯定是不太好的。\n","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1583991691,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1254968,"avatar":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","nickname":"Darren","note":"","ucode":"CCD2B2C492BE9A","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":203167,"discussion_content":"你说的一点没错，所以这是实现上的选择，tomcat还是使用了offer。如果offer那个重载被占用了，或许可以用executor.getQueue().offer(r, 0, TimeUnit.SECONDS) 这个？","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1584006507,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":203070,"ip_address":""},"score":203167,"extra":""},{"author":{"id":1254968,"avatar":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","nickname":"Darren","note":"","ucode":"CCD2B2C492BE9A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":203210,"discussion_content":"明白了，谢谢老师，明白了，其实没有好不好的问题，只有合不合适的问题，不管是强转，还是重载offer或者put，都是要根据具体的业务来决定","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1584010412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":203167,"ip_address":""},"score":203210,"extra":""}]},{"author":{"id":1200704,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","nickname":"pedro","note":"","ucode":"F40C839DDFD599","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":203061,"discussion_content":"兄弟，看了一下你的代码，按照老师的两个点改的，一看就懂😄","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1583989068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381324,"discussion_content":"第一个问题 思考下tomcat设计线程池 肯定不是jdk这个玩法，web服务嘛，偏弹性的。所以直接查看tomcat源码即可，按照tomcat的统一设计 直接打StandardThreadExecutor就出来了。  其实就是execute方法不变，然后重载了阻塞队列的offer方法即可，很是巧妙","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625015407,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187603,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":true,"comment_ctime":1584170683,"is_pvip":false,"replies":[{"id":"72416","content":"ThreadPoolExecutor回收不了，可以看看其源码，工作线程Worker是内部类，只要它活着，换句话说线程在跑，就会阻止ThreadPoolExecutor回收，所以其实ThreadPoolExecutor是无法回收的，并不能认为ThreadPoolExecutor没有引用就能回收","user_name":"作者回复","comment_id":187603,"uid":"1001470","ip_address":"","utype":1,"ctime":1584186595,"user_name_real":"朱晔"}],"discussion_count":6,"race_medal":0,"score":"9.2233721372232008e+18","product_id":100047701,"comment_content":"第二个问题大家都说核心线程数不会被回收，但是方法执行完线程池的引用已经引用不到了吧，线程池对象会被垃圾回收吧，垃圾回收时核心线程怎么办呢","like_count":24,"discussions":[{"author":{"id":1203293,"avatar":"https://static001.geekbang.org/account/avatar/00/12/5c/5d/974b033f.jpg","nickname":"陆老师","note":"","ucode":"0EA27C4755FF4A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":245906,"discussion_content":"内部的Worker执行完firstTask，会循环从队列里取任务。详见ThreadPoolExecutor#runWorker","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1587710285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487163,"discussion_content":"ThreadPoolExecutor回收不了，可以看看其源码，工作线程Worker是内部类，只要它活着，换句话说线程在跑，就会阻止ThreadPoolExecutor回收，所以其实ThreadPoolExecutor是无法回收的，并不能认为ThreadPoolExecutor没有引用就能回收","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584186595,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1441783,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ff/f7/fbab42ce.jpg","nickname":"co","note":"","ucode":"99E1237D7F1907","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584442,"discussion_content":"线程是gc root，然后线程又是引用了外部的线程池，只要线程不被回收（核心线程在线程池实例的一个属性allowCoreThreadTimeOut默认为false的情况下不会被回收），那么线程池也不会被回收。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660820524,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1509790,"avatar":"https://static001.geekbang.org/account/avatar/00/17/09/9e/24b58986.jpg","nickname":"黑瞳","note":"","ucode":"0A48B19BAE5337","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332243,"discussion_content":"那如果线程池是个局部变量，并且在核心线程已经return的情况下，这个线程池对象是不是也会像普通对象一样被回收","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607128805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2015438,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/c0/ce/eb1b4ae1.jpg","nickname":"可圈可丶","note":"","ucode":"EB527E176EDE91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1509790,"avatar":"https://static001.geekbang.org/account/avatar/00/17/09/9e/24b58986.jpg","nickname":"黑瞳","note":"","ucode":"0A48B19BAE5337","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582577,"discussion_content":"并不会，如果allowCoreThreadTimeOut没有设置为true，就算线程池是一个局部变量，方法也已经调用结束了线程池也不会被回收","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659514157,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":332243,"ip_address":"广东"},"score":582577,"extra":""}]},{"author":{"id":1549364,"avatar":"","nickname":"Geek_3b1096","note":"","ucode":"A6BD92B79B3632","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":216355,"discussion_content":"也有同样疑惑谢谢同学","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585441478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":189224,"user_name":"观弈道人","can_delete":false,"product_type":"c1","uid":1016905,"ip_address":"","ucode":"F3BB619A33C605","user_header":"https://static001.geekbang.org/account/avatar/00/0f/84/49/47d48fd0.jpg","comment_is_top":false,"comment_ctime":1584490740,"is_pvip":false,"replies":[{"id":"72993","content":"Excel...","user_name":"作者回复","comment_id":189224,"uid":"1001470","ip_address":"","utype":1,"ctime":1584495452,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"216332855540","product_id":100047701,"comment_content":"&quot;我们把 printStats 方法打印出的日志绘制成图表&quot;，想问下老师，这个图表咋绘制的，想学习下","like_count":51,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487638,"discussion_content":"Excel...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584495452,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187531,"user_name":"汝林外史","can_delete":false,"product_type":"c1","uid":1188906,"ip_address":"","ucode":"3C66C0F0537A99","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/2a/33441e2b.jpg","comment_is_top":false,"comment_ctime":1584153451,"is_pvip":false,"replies":[{"id":"72359","content":"1. 你说的这种策略，此文也有提到： https:&#47;&#47;stackoverflow.com&#47;questions&#47;19528304&#47;how-to-get-the-threadpoolexecutor-to-increase-threads-to-max-before-queueing <br>其实，我们希望的是尽量确保有足够多的线程能处理任务，但是又不闲置过多线程，或临时创建过多线程，换句话说让线程的创建和回收不要太频繁。选择哪个策略要根据任务的性质和压力的流量形态来决定。<br><br>2. 这里我说的复用线程池是指不每次都创建线程池，线程池必须复用而不是按需创建，但是不推荐一味混用一个线程池。对于选择是否混用线程池，至少对于频+快的任务和少+慢的任务应该分开，还是要根据实际任务的性质来选择。","user_name":"作者回复","comment_id":187531,"uid":"1001470","ip_address":"","utype":1,"ctime":1584154572,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"70303630187","product_id":100047701,"comment_content":"1. 既然选择先扩容线程池再加入队列，那为什么不干脆把核心线程数设置大一些，然后核心线程数可回收这种策略呢？<br>2. 复用线程池，任务很慢，主线程get结果的时候不会导致主线程卡死的状态吗？不是也提倡不同的任务用不同的线程池，那复用与不复用的边界在哪里呢？是要根据也无需求自己评估吗？","like_count":16,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487134,"discussion_content":"1. 你说的这种策略，此文也有提到： https://stackoverflow.com/questions/19528304/how-to-get-the-threadpoolexecutor-to-increase-threads-to-max-before-queueing \n其实，我们希望的是尽量确保有足够多的线程能处理任务，但是又不闲置过多线程，或临时创建过多线程，换句话说让线程的创建和回收不要太频繁。选择哪个策略要根据任务的性质和压力的流量形态来决定。\n\n2. 这里我说的复用线程池是指不每次都创建线程池，线程池必须复用而不是按需创建，但是不推荐一味混用一个线程池。对于选择是否混用线程池，至少对于频+快的任务和少+慢的任务应该分开，还是要根据实际任务的性质来选择。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584154572,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186968,"user_name":"陈天柱","can_delete":false,"product_type":"c1","uid":1696225,"ip_address":"","ucode":"917BFDC845760D","user_header":"https://static001.geekbang.org/account/avatar/00/19/e1/e1/441df85d.jpg","comment_is_top":false,"comment_ctime":1583980311,"is_pvip":false,"replies":[{"id":"72124","content":"👍🏻","user_name":"作者回复","comment_id":186968,"uid":"1001470","ip_address":"","utype":1,"ctime":1583983604,"user_name_real":"朱晔"}],"discussion_count":4,"race_medal":0,"score":"40238685975","product_id":100047701,"comment_content":"首先赞一下老师的排查问题的思路！！！然后针对第二个问题，我觉得不会被回收且很快就会OOM了，因为每次请求都新建线程池，每个线程池的核心数都是10, 虽然自定义线程池设置2秒回收，但是没超过线程池核心数10是不会被回收的, 不间断的请求过来导致创建大量线程，最终OOM","like_count":9,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486940,"discussion_content":"👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583983604,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1274787,"avatar":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","nickname":"Michael","note":"","ucode":"C233DF1D224EC1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295760,"discussion_content":"我们同事就搞出来个事情，线程池是在接口被调用的方法中new的，交易量上来，把这个系统都搞挂了，而且这个交易是资产负债相关的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596335489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1274787,"avatar":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","nickname":"Michael","note":"","ucode":"C233DF1D224EC1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295759,"discussion_content":"我们同事就搞出来个事情，线程池是在接口被调用的方法中new的，交易量上来，把这个系统都搞挂了，而且这个交易是资产负债相关的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596335488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1104576,"avatar":"https://static001.geekbang.org/account/avatar/00/10/da/c0/9fc31f2d.jpg","nickname":"初心","note":"","ucode":"C090A1723E3474","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":208001,"discussion_content":"池中核心线程大于请求任务时，会被回收吧，是这样吗？老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584531262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":189676,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1584540192,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"35944278560","product_id":100047701,"comment_content":"分享一下：<br>老师的demo想要不安装资源类直接运行，可以修改两个地方。<br>1.pom文件：删除spring-boot-starter-actuator 依赖；redisson-spring-boot-starter 里exclude redisson-spring-boot-starter 依赖。<br>2.对应的@SpringBootApplication 注解上添加exclude = { DataSourceAutoConfiguration.class, RedissonAutoConfiguration.class }<br><br>","like_count":8,"discussions":[{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287794,"discussion_content":"pom文件不用删除依赖，删了有些类会编译报错，启动类排除他们不装配mysql和redis的bean就好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593541781,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1640343,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIibDIDT8fER3rKSjuPvVoUwFbrxftdVRr2g6NwD6eHnibof93eUngsTaf7EE8dYT4AaNBWXGcicEvZA/132","nickname":"小鱼","note":"","ucode":"C5AF04616748D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":248829,"discussion_content":"请教下，为啥要exclude里面的类？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587899790,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1095857,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","nickname":"梦倚栏杆","note":"","ucode":"BDEB97F2822445","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1640343,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIibDIDT8fER3rKSjuPvVoUwFbrxftdVRr2g6NwD6eHnibof93eUngsTaf7EE8dYT4AaNBWXGcicEvZA/132","nickname":"小鱼","note":"","ucode":"C5AF04616748D0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":248941,"discussion_content":"这些类会在启动的时候注册相关的connection，也就是会连接数据库，redis","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587903492,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":248829,"ip_address":""},"score":248941,"extra":""}]}]},{"had_liked":false,"id":186885,"user_name":"G小调","can_delete":false,"product_type":"c1","uid":1145529,"ip_address":"","ucode":"8F3D50E2C1A559","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/b9/c3d3a92f.jpg","comment_is_top":false,"comment_ctime":1583944511,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"35943682879","product_id":100047701,"comment_content":"文章非常棒 通过真实案例讲解 透过现象看本质","like_count":8},{"had_liked":false,"id":207711,"user_name":"CDz","can_delete":false,"product_type":"c1","uid":1114779,"ip_address":"","ucode":"A23BEE1C4A5922","user_header":"https://static001.geekbang.org/account/avatar/00/11/02/9b/b1a3c60d.jpg","comment_is_top":false,"comment_ctime":1587145780,"is_pvip":false,"replies":[{"id":"77567","content":"总结不错","user_name":"作者回复","comment_id":207711,"uid":"1001470","ip_address":"","utype":1,"ctime":1587167444,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"31651916852","product_id":100047701,"comment_content":"1. 线程池过多造成OOM 因为活跃线程过多和线程池不会被回收<br>2. Java Stream Api异步分流 公用一个默认forkjion线程池，使用时要注意<br>3. 线程池创建时要分析执行任务是IO资源型还是CPU资源型<br>4. IO资源型或者说执行较长时间任务，并且拒绝策略为Call时，会在线程池满状态后交给**调用者**线程执行，如果是Web服务跑在tomcat⬆️的话，就导致整体吞吐量下降","like_count":8,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492220,"discussion_content":"总结不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587167444,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200887,"user_name":"miniluo","can_delete":false,"product_type":"c1","uid":1397339,"ip_address":"","ucode":"5735B6DEE7902B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/FheCgo4Ovibo0L1vAGgMdZkzQMm1GUMHMMqQ8aglufXaD2hW9z96DjQicAam723jOCZwXVmiaNiaaq4PLsf4COibZ5A/132","comment_is_top":false,"comment_ctime":1585667915,"is_pvip":false,"replies":[{"id":"75190","content":"提供方便的api这个事情本身没错  使用者自己需要使用api之前详细阅读说明","user_name":"作者回复","comment_id":200887,"uid":"1001470","ip_address":"","utype":1,"ctime":1585702722,"user_name_real":"朱晔"}],"discussion_count":2,"race_medal":0,"score":"23060504395","product_id":100047701,"comment_content":"那JDK提供的四种快捷创建线程池的方式时候没有想到这些坑吗？如果想到了为何还提供这些方便的方式呢？还要麻烦老师解答，谢谢~","like_count":5,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490165,"discussion_content":"提供方便的api这个事情本身没错  使用者自己需要使用api之前详细阅读说明","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585702722,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1974876,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJUCiacuh59wMZAeeNRwLiaGaRMZHibF05IibXeiaZfjcFfkmTwJTmPszibXLAQkk2mMdx8chPjTs2yvpZg/132","nickname":"Sky1225","note":"","ucode":"6F428AF396D99D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385649,"discussion_content":"我理解不建议使用这些api就是考虑到实践的时候大家对api理解不透彻，出现了很多坑，所以才不推荐使用。api本身没问题，而且还提供了一些场景使用线程池的思路","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627196216,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188936,"user_name":"程序员小跃","can_delete":false,"product_type":"c1","uid":1015483,"ip_address":"","ucode":"25BB96E0791A60","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","comment_is_top":false,"comment_ctime":1584435691,"is_pvip":true,"replies":[{"id":"72887","content":"的确是享受","user_name":"作者回复","comment_id":188936,"uid":"1001470","ip_address":"","utype":1,"ctime":1584438498,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"18764304875","product_id":100047701,"comment_content":"看大家的思考题也是一种享受。<br><br>线程池这个，记得刚学会编程的时候，面试就问线程池的创建，然后回来看书知道了如何创建各种各样的线程池；但是项目中还是没遇到更多的坑，看了老师的解析，让我以后对线程池的使用更加谨慎了。","like_count":5,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487570,"discussion_content":"的确是享受","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584438498,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187011,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1583989386,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14468891274","product_id":100047701,"comment_content":"总结一下今天学到的；1、线程池的OOM问题，可能是队列满造成的，也可能是线程太多造成的，至于后面的那个2000个线程池太多，大概是这辈子都不会遇到这种错误吧😂。2、线程池的策略问题，优先根据场景来选择合适的参数来新建线程池，若还是无法满足，可自定义线程池，总之一切以实际为准。","like_count":3},{"had_liked":false,"id":186935,"user_name":"JavaGuide","can_delete":false,"product_type":"c1","uid":1184210,"ip_address":"","ucode":"246D2EAEA0ACEC","user_header":"https://static001.geekbang.org/account/avatar/00/12/11/d2/fb38b86f.jpg","comment_is_top":false,"comment_ctime":1583975629,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14468877517","product_id":100047701,"comment_content":"很棒！","like_count":3},{"had_liked":false,"id":186884,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":false,"comment_ctime":1583944254,"is_pvip":true,"replies":[{"id":"72125","content":"👍🏻","user_name":"作者回复","comment_id":186884,"uid":"1001470","ip_address":"","utype":1,"ctime":1583983663,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"14468846142","product_id":100047701,"comment_content":"先回答第二个问题吧，第一个等天亮了，试一试<br>不会被回收，会OOM，即使是自定义线程池，核心线程是不会回收的，每次需要10个线程，刚好是核心线程数，因此每次请求都会创建10个核心线程数的线程池，请求次数多了后，很快就回OOM。<br>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create new native thread","like_count":3,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486903,"discussion_content":"👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583983663,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":243466,"user_name":"maybe","can_delete":false,"product_type":"c1","uid":1475528,"ip_address":"","ucode":"93D160F617E750","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/c8/5ce842f6.jpg","comment_is_top":false,"comment_ctime":1598146476,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"10188081068","product_id":100047701,"comment_content":"1、线程池一定要通过new方式创建，根据具体情况设置合适的参数<br>2、公共线程池签一定要注意线程池的参数设置、创建策略、拒绝策略等。不同类型的任务、cpu密集型、io密集型不同，cpu密集型需要更长的任务队列，io密集型需要更多的线程<br>3、线程池不复用导致oom，每次创建线程池，因为核心线程还在运行，即使没有引用指向线程池，也不会被回收","like_count":3},{"had_liked":false,"id":195057,"user_name":"Joker","can_delete":false,"product_type":"c1","uid":1156592,"ip_address":"","ucode":"126AF848001A1E","user_header":"https://static001.geekbang.org/account/avatar/00/11/a5/f0/8648c464.jpg","comment_is_top":false,"comment_ctime":1585131887,"is_pvip":false,"replies":[{"id":"74178","content":"不会，没必要单独汇总一篇，我的答案也不一定是标准答案，看看大家的讨论不是挺好？","user_name":"作者回复","comment_id":195057,"uid":"1001470","ip_address":"","utype":1,"ctime":1585138254,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"10175066479","product_id":100047701,"comment_content":"老师会装门写一篇 课后回答的解答来回答这些问题吗？","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488960,"discussion_content":"不会，没必要单独汇总一篇，我的答案也不一定是标准答案，看看大家的讨论不是挺好？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585138254,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":192968,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1274787,"ip_address":"","ucode":"C233DF1D224EC1","user_header":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","comment_is_top":false,"comment_ctime":1584880698,"is_pvip":true,"replies":[{"id":"73650","content":"消息列表聚合接口？如果并行调用，那么最短板的任务决定了整个接口的性能，尝试优化一下短板，不断是外部接口还是数据库。也可以考虑一下为什么这些提醒会涉及到多个地方甚至其他接口，为何不能所有通知直接进入一个表，而且通知是最容易按照用户纬度分表的。","user_name":"作者回复","comment_id":192968,"uid":"1001470","ip_address":"","utype":1,"ctime":1584886570,"user_name_real":"朱晔"}],"discussion_count":5,"race_medal":0,"score":"10174815290","product_id":100047701,"comment_content":"老师请教个问题：我们系统有个业务接口，一个人会收到若干种业务消息提醒，每个提醒至少涉及一张表，有的提醒还会涉及到调用外系统后台接口，虽然现在用多线程的方式，异步并行调用，但是接口耗时仍然达到了2s左右，后面随着业务需求的不断增加，耗时可能会加剧，老师有什么更好的方案嘛？","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488486,"discussion_content":"消息列表聚合接口？如果并行调用，那么最短板的任务决定了整个接口的性能，尝试优化一下短板，不断是外部接口还是数据库。也可以考虑一下为什么这些提醒会涉及到多个地方甚至其他接口，为何不能所有通知直接进入一个表，而且通知是最容易按照用户纬度分表的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584886570,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212081,"discussion_content":"写入时汇总的麻烦和读取时汇总的慢，还是要选择","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1584932156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1274787,"avatar":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","nickname":"Michael","note":"","ucode":"C233DF1D224EC1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211852,"discussion_content":"主要是数据库表的增加，业务表基本都是ctrm定时作业每日跑批导入到我们系统，而且基本不同的业务表都来自于不同的系统，所有的消息表数据基本不是同时到达，都是凌晨以后，若是加工到同一张表里，业务数据的加工在定时shell脚本中处理会显得相当复杂，基本没法搞到一张表，用Java定时任务去处理还是特别麻烦，消息提醒又要实时提醒，所以缓存也用不了，真是头疼","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584890411,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2071309,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/9b/0d/4752c20a.jpg","nickname":"暮江佳人远","note":"","ucode":"9CBAFC314F2876","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1274787,"avatar":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","nickname":"Michael","note":"","ucode":"C233DF1D224EC1","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":302913,"discussion_content":"请问最后你是怎么解决的？是不是可以用流式计算框架去做聚合","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599061870,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":211852,"ip_address":""},"score":302913,"extra":""}]},{"author":{"id":1225974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b4/f6/e39d5af1.jpg","nickname":"钱米","note":"","ucode":"07AA44C6A40D34","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388456,"discussion_content":"消息提醒一般是异步做。看看微信、订餐、点餐消息通知都是异步的，可以优化设计方案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628770637,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190287,"user_name":"丫琴 （朋友）","can_delete":false,"product_type":"c1","uid":1903763,"ip_address":"","ucode":"821909D7D88E62","user_header":"https://static001.geekbang.org/account/avatar/00/1d/0c/93/30bbdf6f.jpg","comment_is_top":false,"comment_ctime":1584626934,"is_pvip":false,"replies":[{"id":"73196","content":"线程过多肯定会有影响，分还是合需要仔细考虑","user_name":"作者回复","comment_id":190287,"uid":"1001470","ip_address":"","utype":1,"ctime":1584628667,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"10174561526","product_id":100047701,"comment_content":"我们一个项目里面如果有10个场景不一样，是不是得创建10个线程池，这样子会对服务器有影响吗？","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487939,"discussion_content":"线程过多肯定会有影响，分还是合需要仔细考虑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584628667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187438,"user_name":"张少华","can_delete":false,"product_type":"c1","uid":1855708,"ip_address":"","ucode":"09DA0D3E7E0331","user_header":"","comment_is_top":false,"comment_ctime":1584109611,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10174044203","product_id":100047701,"comment_content":"挺厉害","like_count":2},{"had_liked":false,"id":230354,"user_name":"肖少华","can_delete":false,"product_type":"c1","uid":1285654,"ip_address":"","ucode":"C4AC98BE89929B","user_header":"https://static001.geekbang.org/account/avatar/00/13/9e/16/7d64001d.jpg","comment_is_top":false,"comment_ctime":1593354348,"is_pvip":false,"replies":[{"id":"85047","content":"其实我的问题是 如果我们不小心每次都创建了这样一个自定义的线程池，也就是没有复用线程池的情况","user_name":"作者回复","comment_id":230354,"uid":"1001470","ip_address":"","utype":1,"ctime":1593396968,"user_name_real":"朱晔"}],"discussion_count":3,"race_medal":0,"score":"5888321644","product_id":100047701,"comment_content":"老师你好，关于文中的 改造后的ThreadPoolHelper，留言的同学都说会OOM，是频繁创建线程池导致的，我有点小疑惑，这个静态的不是不会重复创建的吗","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499848,"discussion_content":"其实我的问题是 如果我们不小心每次都创建了这样一个自定义的线程池，也就是没有复用线程池的情况","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593396968,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1153455,"avatar":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","nickname":"饭粒","note":"","ucode":"4C3220B0D43997","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":398566,"discussion_content":"也有这个疑惑，找到解答了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632813794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1048329,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ff/09/e0c39733.jpg","nickname":"Jayliud","note":"","ucode":"0274FC2607B1BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336845,"discussion_content":"但如果复用的话，线程池如只开启了10个，但是请求可能是1000，那是都得排队等么?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608715090,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":191783,"user_name":"丫琴 （朋友）","can_delete":false,"product_type":"c1","uid":1903763,"ip_address":"","ucode":"821909D7D88E62","user_header":"https://static001.geekbang.org/account/avatar/00/1d/0c/93/30bbdf6f.jpg","comment_is_top":false,"comment_ctime":1584796497,"is_pvip":false,"replies":[{"id":"73466","content":"我们实际用到这种情况多吗<br>其中这种情况是指什么？","user_name":"作者回复","comment_id":191783,"uid":"1001470","ip_address":"","utype":1,"ctime":1584798065,"user_name_real":"朱晔"}],"discussion_count":3,"race_medal":0,"score":"5879763793","product_id":100047701,"comment_content":"想咨询下，比如您在饿了么或者现在的公司，我们实际用到这种情况多吗？因为感觉学了，但是实际应用还是挺困难，因为我们没办法保证实际并发的量有多大","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488257,"discussion_content":"我们实际用到这种情况多吗\n其中这种情况是指什么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584798065,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1903763,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/0c/93/30bbdf6f.jpg","nickname":"丫琴 （朋友）","note":"","ucode":"821909D7D88E62","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211348,"discussion_content":"就是实际用到这种手动线程池的业务场景多吗？或者说在一个项目里面正常会有多少个线程池工具类？因为肯定是要复用的，只是应该是要按实际需求去创建不同的场景的工具类吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584842847,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1301304,"avatar":"https://static001.geekbang.org/account/avatar/00/13/db/38/7ab139a3.jpg","nickname":"z小俊、Arno","note":"","ucode":"312B3DDCF15102","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1903763,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/0c/93/30bbdf6f.jpg","nickname":"丫琴 （朋友）","note":"","ucode":"821909D7D88E62","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217509,"discussion_content":"在工作时，考虑到这些问题就好了，就我工作四年的技术来讲，知识面也是代码质量的保证，正常来说，这种通用的代码模块都已经被架构师写好了，架构师以公司规模或者所选框架决定的。新手直接操作线程的情况不过，但是绝对有必要熟悉，毕竟线程是面试热点，和钱挂钩","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585566370,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":211348,"ip_address":""},"score":217509,"extra":""}]}]},{"had_liked":false,"id":189929,"user_name":"飞飞","can_delete":false,"product_type":"c1","uid":1118395,"ip_address":"","ucode":"31BEBE1325DE19","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/bb/1616a0aa.jpg","comment_is_top":false,"comment_ctime":1584582861,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879550157","product_id":100047701,"comment_content":"老师，能分享下线程池关闭相关的经验吗","like_count":1},{"had_liked":false,"id":189535,"user_name":"何岸康","can_delete":false,"product_type":"c1","uid":1444317,"ip_address":"","ucode":"F24898244A170D","user_header":"https://static001.geekbang.org/account/avatar/00/16/09/dd/02c73bd3.jpg","comment_is_top":false,"comment_ctime":1584526592,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5879493888","product_id":100047701,"comment_content":"问题一：<br>感觉使用组合要比继承更适合。<br>public class OfferToQueuePolicy implements RejectedExecutionHandler {<br><br>    public OfferToQueuePolicy() {<br>    }<br><br>    public OfferToQueuePolicy(RejectedExecutionHandler rejectedExecutionHandler) {<br>        this.rejectedExecutionHandler = rejectedExecutionHandler;<br>    }<br><br>    private RejectedExecutionHandler rejectedExecutionHandler;<br><br>    @Override<br>    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {<br><br>        BlockingQueue&lt;Runnable&gt; workQueue = e.getQueue();<br>        try {<br>            if (e.isShutdown()) {<br>                if (!workQueue.offer(r, 0, TimeUnit.MILLISECONDS)) {<br>                    rejectedExecutionHandler.rejectedExecution(r, e);<br>                }<br>                if (e.isShutdown()) {<br>                    e.remove(r);<br>                }<br>            }<br>        } catch (InterruptedException ex) {<br>            rejectedExecutionHandler.rejectedExecution(r, e);<br>        }<br>    }<br><br>}<br><br>public class AggressiveBlockingQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, java.io.Serializable{<br><br>    private BlockingQueue&lt;E&gt; blockingQueue;<br><br><br>    @Override<br>    public Iterator&lt;E&gt; iterator() {<br>        return blockingQueue.iterator();<br>    }<br><br>    @Override<br>    public boolean offer(E e) {<br>        return false;<br>    }<br>    <br>    @Override<br>    public E take() throws InterruptedException {<br>        return blockingQueue.take();<br>    }<br>    <br>    .......<br>}","like_count":1,"discussions":[{"author":{"id":1974876,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJUCiacuh59wMZAeeNRwLiaGaRMZHibF05IibXeiaZfjcFfkmTwJTmPszibXLAQkk2mMdx8chPjTs2yvpZg/132","nickname":"Sky1225","note":"","ucode":"6F428AF396D99D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385650,"discussion_content":"理由呢？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627196350,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187541,"user_name":"mgs2002","can_delete":false,"product_type":"c1","uid":1812970,"ip_address":"","ucode":"F5931108BD509B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/ea/5bfce6c5.jpg","comment_is_top":false,"comment_ctime":1584154713,"is_pvip":false,"replies":[{"id":"72362","content":"这段代码不是很能理解意思，testCompletableFutureDefaultExecutor是什么？最好给出源码链接","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1584156760,"ip_address":"","comment_id":187541,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5879122009","product_id":100047701,"comment_content":" 老师，我还有个问题， 我在本机做了一下默认线程池（CompletableFuture）和自定义线程池的调用时间对比，测试了好多次每次都是默认线程池的时间快，任务越多自定义线程池的时间就越慢，默认的相对稳定，不懂怎么回事了。。<br>这是我的测试结果，default是默认的，custom是自定义的<br> When 1 tasks =&gt; future default: 11,future custom: 4<br> When 3 tasks =&gt; future default: 1,future custom: 2<br> When 4 tasks =&gt; future default: 1,future custom: 2<br> When 5 tasks =&gt; future default: 1,future custom: 6<br> When 6 tasks =&gt; future default: 1,future custom: 7<br> When 8 tasks =&gt; future default: 1,future custom: 5<br> When 9 tasks =&gt; future default: 0,future custom: 5<br> When 14 tasks =&gt; future default: 1,future custom: 5<br> When 20 tasks =&gt; future default: 2,future custom: 9<br> When 21 tasks =&gt; future default: 1,future custom: 7<br> When 34 tasks =&gt; future default: 2,future custom: 4<br> When 54 tasks =&gt; future default: 1,future custom: 2<br> When 104 tasks =&gt; future default: 2,future custom: 2<br> When 154 tasks =&gt; future default: 3,future custom: 3<br> When 204 tasks =&gt; future default: 4,future custom: 47<br> When 304 tasks =&gt; future default: 5,future custom: 481<br> When 604 tasks =&gt; future default: 9,future custom: 488<br> When 1004 tasks =&gt; future default: 18,future custom: 783<br> When 2004 tasks =&gt; future default: 41,future custom: 1573<br> When 3004 tasks =&gt; future default: 64,future custom: 2628<br>自定义连接池设定参数： <br>    corePoolSize：200 maximumPoolSize：200 keepAliveTime：1 unit：HOUR workQueue：200 <br>    默认拒绝策略<br>测试代码：<br> @PostMapping(&quot;&#47;testPool&quot;)<br>    public Result list(@Valid @RequestBody SchoolRequest schoolRequest){<br>        Arrays.asList(-3, -1, 0, 1, 2, 4, 5, 10, 16, 17, 30, 50, 100, 150, 200, 300,600,1000,2000,3000).forEach(offset -&gt; {<br>            int jobNum = 4 + offset;<br>            log.info(String.format(&quot;When %s tasks =&gt; future default: %s,future custom: %s&quot;,jobNum,  testCompletableFutureDefaultExecutor(jobNum,schoolRequest),testCompletableFutureCustomExecutor(jobNum,schoolRequest)));<br>        });<br>        return Result.successInstance();<br>    }","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487140,"discussion_content":"这段代码不是很能理解意思，testCompletableFutureDefaultExecutor是什么？最好给出源码链接","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584156760,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187325,"user_name":"mgs2002","can_delete":false,"product_type":"c1","uid":1812970,"ip_address":"","ucode":"F5931108BD509B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/ea/5bfce6c5.jpg","comment_is_top":false,"comment_ctime":1584083695,"is_pvip":false,"replies":[{"id":"72287","content":"通过数据库来查询统计就是IO操作，既然项目都不同了，那么就不是一个进程了，我们说的线程池隔离是针对一个进程的","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1584084556,"ip_address":"","comment_id":187325,"utype":1}],"discussion_count":4,"race_medal":0,"score":"5879050991","product_id":100047701,"comment_content":"学到了，我现在代码还是用的CompletableFuture默认线程池。。。有个问题请教老师，我有两个项目，里面有很多数据统计的地方使用到了线程池，这种是属于CPU绑定类型的吧（通过数据库来查询统计），还有我想分别给两个项目设置不同的线程池可行吗","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487074,"discussion_content":"通过数据库来查询统计就是IO操作，既然项目都不同了，那么就不是一个进程了，我们说的线程池隔离是针对一个进程的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584084556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1461075,"avatar":"https://static001.geekbang.org/account/avatar/00/16/4b/53/f797f031.jpg","nickname":"无道win","note":"","ucode":"0C026BB03A53EA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302719,"discussion_content":"CompletableFuture跟parallel stream 一样，背后是共享同一个 ForkJoinPool，不过CompletableFuture构造函数支持传入自定义线程池","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599014167,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1812970,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a9/ea/5bfce6c5.jpg","nickname":"mgs2002","note":"","ucode":"F5931108BD509B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":203813,"discussion_content":"哦，了解了，那一个进程里不同的统计任务有必要创建不同的线程池来隔离吗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584085766,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1461075,"avatar":"https://static001.geekbang.org/account/avatar/00/16/4b/53/f797f031.jpg","nickname":"无道win","note":"","ucode":"0C026BB03A53EA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1812970,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a9/ea/5bfce6c5.jpg","nickname":"mgs2002","note":"","ucode":"F5931108BD509B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302717,"discussion_content":"如果任务之间有依赖关系的话，最好还是进行隔离，不要提交到同一线程池里面。不然有可能造成死锁的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599014029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":203813,"ip_address":""},"score":302717,"extra":""}]}]},{"had_liked":false,"id":187168,"user_name":"13W3H","can_delete":false,"product_type":"c1","uid":1046497,"ip_address":"","ucode":"83189FD92DC082","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/e1/36676a49.jpg","comment_is_top":false,"comment_ctime":1584030996,"is_pvip":false,"replies":[{"id":"72228","content":"你是什么os呢？我是macos没有遇到过这个问题，尝试先重启docker service，或OS。docker-compose是方便大家快速启动依赖，不是必须的，实在不行你可以自己手动安装mysql，都是一样的","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1584059460,"ip_address":"","comment_id":187168,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5878998292","product_id":100047701,"comment_content":"mysqld: Table &#39;mysql.plugin&#39; doesn&#39;t exist<br>[Warning] Insecure configuration for --pid-file: Location &#39;&#47;var&#47;run&#47;mysqld&#39; in the path is accessible to all OS users. Consider choos<br>[Warning] Failed to open optimizer cost constant tables<br>[ERROR] Fatal error: Can&#39;t open and lock privilege tables: Table &#39;mysql.user&#39; doesn&#39;t exist<br>[ERROR] Fatal error: Failed to initialize ACL&#47;grant&#47;time zones structures or failed to remove temporary table files.<br>[ERROR] Aborting<br>mysqld: Shutdown complete<br><br>---<br>老师您好，docker-compose up 在启动mysql时遇到了这个异常，看网上是说没有初始化mysql，麻烦请问下，是需要进到docker容器里面去进行初始化或配置吗？（刚刚接触docker，还望指点一下，谢谢）","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487012,"discussion_content":"你是什么os呢？我是macos没有遇到过这个问题，尝试先重启docker service，或OS。docker-compose是方便大家快速启动依赖，不是必须的，实在不行你可以自己手动安装mysql，都是一样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584059460,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":203764,"discussion_content":"ok","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584078718,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1046497,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f7/e1/36676a49.jpg","nickname":"13W3H","note":"","ucode":"83189FD92DC082","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":203645,"discussion_content":"已解决，谢谢老师。是win10系统安装的docker。刚想到是不是用户权限的问题，果真是这个问题。用管理员权限启动Windows PowerShell 后执行docker-compose up 命令就可以正常启动了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584062523,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187015,"user_name":"汝林外史","can_delete":false,"product_type":"c1","uid":1188906,"ip_address":"","ucode":"3C66C0F0537A99","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/2a/33441e2b.jpg","comment_is_top":false,"comment_ctime":1583990748,"is_pvip":false,"replies":[{"id":"72136","content":"1、可以想想tomcat为什么觉得这样激进的线程更适合。其实.NET的线程池就是这样的弹性线程池，只不过创建新的线程还会有一定的思考时间，延迟新线程的创建，更智能。<br>2、其实和任务慢不慢没有太大关系，即使任务不慢，不复用也是有问题的。","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1583996581,"ip_address":"","comment_id":187015,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5878958044","product_id":100047701,"comment_content":"老师的文章真的是看得很爽。问题如下：<br>1.激进的都适应什么场合呢？先扩容线程池再加入任务队列，也可能队列满了还来任务，还是要再拒绝。<br>2.因为核心线程不会回收，所以会OOM。可以设置allowCoreThreadTimeOut参数让核心线程也可以回收。 另外文中的ThreadPoolHelper是用来复用线程池的，但是提交的都是慢任务，很多地方都提交的话不会导致线程池始终处于满的状态，导致后来的任务始终得不到执行吗？","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486960,"discussion_content":"1、可以想想tomcat为什么觉得这样激进的线程更适合。其实.NET的线程池就是这样的弹性线程池，只不过创建新的线程还会有一定的思考时间，延迟新线程的创建，更智能。\n2、其实和任务慢不慢没有太大关系，即使任务不慢，不复用也是有问题的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583996581,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186980,"user_name":"🐾","can_delete":false,"product_type":"c1","uid":1087256,"ip_address":"","ucode":"D0AD0260351C31","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/18/a5218104.jpg","comment_is_top":false,"comment_ctime":1583982322,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5878949618","product_id":100047701,"comment_content":"OOM，全称“Out Of Memory”，中文意思是“内存用尽”。当 JVM 因为没有足够的内存来为对象分配空间，并且垃圾回收器也没有空间可回收时，就会抛出这个 Error。","like_count":1,"discussions":[{"author":{"id":1488356,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b5/e4/e6faf686.jpg","nickname":"握了个大蚂蚱","note":"","ucode":"AD34AD4FA37371","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339948,"discussion_content":"这你都知道","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609847374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":356495,"user_name":"在雨中","can_delete":false,"product_type":"c1","uid":1188220,"ip_address":"江西","ucode":"C4A0B725C8A009","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/7c/940627a7.jpg","comment_is_top":false,"comment_ctime":1662366846,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1662366846","product_id":100047701,"comment_content":"请问下老师，ThreadPoolHelper创建的线程池并没有设置        &#47;&#47; 预热一个核心线程<br>        &#47;&#47; threadPoolExecutor.prestartCoreThread();<br>        &#47;&#47; 预热所有核心线程<br>        &#47;&#47; threadPoolExecutor.prestartAllCoreThreads();","like_count":0},{"had_liked":false,"id":352027,"user_name":"dudu-benny","can_delete":false,"product_type":"c1","uid":1683951,"ip_address":"","ucode":"026ECAC9AFDE0D","user_header":"https://static001.geekbang.org/account/avatar/00/19/b1/ef/2356b51e.jpg","comment_is_top":false,"comment_ctime":1658334966,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1658334966","product_id":100047701,"comment_content":"&quot;传入 true 给 allowCoreThreadTimeOut 方法，来让线程池在空闲的时候同样回收核心线程&quot;  和 &quot;由于线程池在工作队列满了无法入队的情况下会扩容线程池，那么我们是否可以重写队列的 offer 方法，造成这个队列已满的假象呢&quot;  不能同时使用，发现实现offer 返回false 后 线程池会认为队里已经放不下了，则开始创建新线程直到最大线程数，当线程池空闲的时候，会回收最大线程数直到核心线程数，offer返回false还是成立 所以allowCoreThreadTimeOut 传入true 无效，具体要了解一下源代码  ","like_count":0},{"had_liked":false,"id":348689,"user_name":"浮石沉木","can_delete":false,"product_type":"c1","uid":2223167,"ip_address":"","ucode":"D585768321B84A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/mQddXC7nRiaKHTwdficicTB3bH0q5ic5UoSab51Omic7eyLBz0SNcvbLpQnNib7zP1yJFm7xxx4ia81iahfibRVnbTwHmhw/132","comment_is_top":false,"comment_ctime":1655303348,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655303348","product_id":100047701,"comment_content":"老师，现在有个场景，我们之前嫌单线程查询一个长时间序列的数据太耗时了，为了加快响应速度，改成每次来个请求就new一个线程池，每个子线程查询一段数据，最后汇总返回。每次新建一个线程池是不是没有必要，能不能在springboot中维持一个单例的线程池？当请求数量过多的时候，这些线程一时半会捞不到数据，CPU使用率飙升的可能性，如果存在这种可能性，应该从哪方面着手优化呢？","like_count":0},{"had_liked":false,"id":348687,"user_name":"浮石沉木","can_delete":false,"product_type":"c1","uid":2223167,"ip_address":"","ucode":"D585768321B84A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/mQddXC7nRiaKHTwdficicTB3bH0q5ic5UoSab51Omic7eyLBz0SNcvbLpQnNib7zP1yJFm7xxx4ia81iahfibRVnbTwHmhw/132","comment_is_top":false,"comment_ctime":1655302996,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655302996","product_id":100047701,"comment_content":"老师，我们现在有个场景，因为之前单线程去查一个很长时间序列的数据库数据，响应太慢，后边代码改成每来一次请求，我们就new一个线程池，每个子线程分批查询一小段时间序列的数据，最后汇总。这样会不会导致：","like_count":0},{"had_liked":false,"id":345500,"user_name":"18168789972","can_delete":false,"product_type":"c1","uid":2270110,"ip_address":"","ucode":"FA57A540D6BC35","user_header":"","comment_is_top":false,"comment_ctime":1652336662,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652336662","product_id":100047701,"comment_content":"您好 老师!<br>在使用多线程的时候，好像出现了同步的问题，让我有点不知所措 ，麻烦老师给指点一下！<br>从printStats(threadPool)打印的数据看 完成的任务数在+1操作，某一时间点会+30<br>30w的数据花费的时间巨大，1w单线程的话14s<br>ThreadPoolExecutor threadPool = new ThreadPoolExecutor(<br>                60,<br>                60,<br>                60,<br>                TimeUnit.SECONDS,<br>                new ArrayBlockingQueue&lt;&gt;(10),<br>                new ThreadFactoryBuilder().setNameFormat(&quot;demo-threadpool-%d&quot;).build(),<br>                new ThreadPoolExecutor.AbortPolicy());<br>printStats(threadPool);<br>&#47;&#47;计数器<br>CountDownLatch downLatch = new CountDownLatch(60);<br>AtomicInteger incr = new AtomicInteger(0);<br>for (int i = 0; i &lt; 60; i++) {<br>    int offset=i*5000;<br>    threadPool.execute(()-&gt;{<br>       &#47;&#47; 查询数据库 每次查5k条，limit限制位移量<br>       select * from [表] limit 5000 offset #{offset};<br>       &#47;&#47; IO 写操作<br>       ...<br>       fileOutputStream.write(out.toByteArray());<br>       ...<br>       fileOutputStream.close();<br>    });<br>}<br>downLatch.await();","like_count":0},{"had_liked":false,"id":344087,"user_name":"防腐基","can_delete":false,"product_type":"c1","uid":2696605,"ip_address":"","ucode":"0FF3BF30631995","user_header":"https://static001.geekbang.org/account/avatar/00/29/25/9d/d612cbf8.jpg","comment_is_top":false,"comment_ctime":1651227676,"is_pvip":true,"replies":[{"id":"125700","content":"走MQ比较好","user_name":"作者回复","user_name_real":"编辑","uid":"1001470","ctime":1651492327,"ip_address":"","comment_id":344087,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1651227676","product_id":100047701,"comment_content":"老师你好，我们工作中有个场景是付款成功后，给用户发订阅消息或短信通知，发通知的部分我们想用线程池，老师可以给个合适的参数配置吗，我这边可以适当参考。硬件是CPU8核内存16G。","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569592,"discussion_content":"走MQ比较好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651492327,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342632,"user_name":"csdev_sch","can_delete":false,"product_type":"c1","uid":2940733,"ip_address":"","ucode":"BE8013E72F9BAE","user_header":"https://static001.geekbang.org/account/avatar/00/2c/df/3d/7df2b086.jpg","comment_is_top":false,"comment_ctime":1650373836,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650373836","product_id":100047701,"comment_content":"new 出来的ForkJoinPool没有显式调用shutdown方法，最后能被jvm能回收吗？","like_count":0},{"had_liked":false,"id":341990,"user_name":"花花大脸猫","can_delete":false,"product_type":"c1","uid":1117318,"ip_address":"","ucode":"8ABDB3F7F4FB0F","user_header":"https://static001.geekbang.org/account/avatar/00/11/0c/86/8e52afb8.jpg","comment_is_top":false,"comment_ctime":1649943082,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1649943082","product_id":100047701,"comment_content":"这个问题最近刚在生产环境看到过。。确实对于代码的书写习惯而言要有敬畏之心，尤其是牵涉到多线程执行，threadlocal对象，共享资源锁竞争等，必须要明确了解使用场景与原理","like_count":0},{"had_liked":false,"id":341499,"user_name":"对对对，是我，是我","can_delete":false,"product_type":"c1","uid":1182133,"ip_address":"","ucode":"4DBD73850A9B41","user_header":"https://static001.geekbang.org/account/avatar/00/12/09/b5/bbb93647.jpg","comment_is_top":false,"comment_ctime":1649664237,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649664237","product_id":100047701,"comment_content":"我的电脑第一个例子没有报OOM，队列到了99999999之后一直是这个值<br>2022-04-11 16:02:18.932  INFO 5822 --- [pool-4-thread-1] c.e.b.c.z.c.c.t.FixedThreadPoolError     : Pool Size: 1<br>2022-04-11 16:02:18.932  INFO 5822 --- [pool-4-thread-1] c.e.b.c.z.c.c.t.FixedThreadPoolError     : Active Threads: 1<br>2022-04-11 16:02:18.932  INFO 5822 --- [pool-4-thread-1] c.e.b.c.z.c.c.t.FixedThreadPoolError     : Number of Tasks Completed: 0<br>2022-04-11 16:02:18.932  INFO 5822 --- [pool-4-thread-1] c.e.b.c.z.c.c.t.FixedThreadPoolError     : Number of Tasks in Queue: 99999999<br>2022-04-11 16:02:18.932  INFO 5822 --- [pool-4-thread-1] c.e.b.c.z.c.c.t.FixedThreadPoolError     : =========================<br>2022-04-11 16:02:19.932  INFO 5822 --- [pool-4-thread-1] c.e.b.c.z.c.c.t.FixedThreadPoolError     : =========================<br>2022-04-11 16:02:19.933  INFO 5822 --- [pool-4-thread-1] c.e.b.c.z.c.c.t.FixedThreadPoolError     : Pool Size: 1<br>2022-04-11 16:02:19.933  INFO 5822 --- [pool-4-thread-1] c.e.b.c.z.c.c.t.FixedThreadPoolError     : Active Threads: 1<br>2022-04-11 16:02:19.934  INFO 5822 --- [pool-4-thread-1] c.e.b.c.z.c.c.t.FixedThreadPoolError     : Number of Tasks Completed: 0<br>2022-04-11 16:02:19.934  INFO 5822 --- [pool-4-thread-1] c.e.b.c.z.c.c.t.FixedThreadPoolError     : Number of Tasks in Queue: 99999999<br>","like_count":0},{"had_liked":false,"id":333636,"user_name":"李泽彬","can_delete":false,"product_type":"c1","uid":1047442,"ip_address":"","ucode":"F540DADF3AAD87","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/92/4de0c05c.jpg","comment_is_top":false,"comment_ctime":1644457174,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1644457174","product_id":100047701,"comment_content":"用了线程池，还能实现优雅关闭，响应中断","like_count":0},{"had_liked":false,"id":333053,"user_name":"JoJi","can_delete":false,"product_type":"c1","uid":2066986,"ip_address":"","ucode":"B88997A80E76AC","user_header":"https://static001.geekbang.org/account/avatar/00/1f/8a/2a/f94db4dc.jpg","comment_is_top":false,"comment_ctime":1644031168,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644031168","product_id":100047701,"comment_content":"老师，我看Eureka的DiscoveryClient 也在使用Executors.newScheduledThreadPool,线程数是INTEGER.MAX,为啥就没没听人说过有问题呢？","like_count":0},{"had_liked":false,"id":331995,"user_name":"王小","can_delete":false,"product_type":"c1","uid":1382006,"ip_address":"","ucode":"03DDDB3FD20D5F","user_header":"https://static001.geekbang.org/account/avatar/00/15/16/76/f2422695.jpg","comment_is_top":false,"comment_ctime":1642951655,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1642951655","product_id":100047701,"comment_content":"老师 一般我们了解到线程的5种状态都是跟cpu获取有关系，那对于正在调用io的线程是不是没获取到cpu，也正在执行？","like_count":0},{"had_liked":false,"id":318165,"user_name":"武林三","can_delete":false,"product_type":"c1","uid":2823633,"ip_address":"","ucode":"A597E89627D26C","user_header":"","comment_is_top":false,"comment_ctime":1635168657,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635168657","product_id":100047701,"comment_content":"老师的分享很棒，但我有个疑惑，该如何将这些宝贵的经验掌握应用到工作中呢？CURD很多年了","like_count":0},{"had_liked":false,"id":299774,"user_name":"BabyQ","can_delete":false,"product_type":"c1","uid":2670182,"ip_address":"","ucode":"23F4667010613F","user_header":"https://static001.geekbang.org/account/avatar/00/28/be/66/bdfe3784.jpg","comment_is_top":false,"comment_ctime":1624855113,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624855113","product_id":100047701,"comment_content":"<br>@GetMapping(&quot;wrong&quot;)<br>public String wrong() throws InterruptedException {<br>    ThreadPoolExecutor threadPool = ThreadPoolHelper.getThreadPool();<br>    IntStream.rangeClosed(1, 10).forEach(i -&gt; {<br>        threadPool.execute(() -&gt; {<br>            ...<br>            try {<br>                TimeUnit.SECONDS.sleep(1);<br>            } catch (InterruptedException e) {<br>            }<br>        });<br>    });<br>    return &quot;OK&quot;;<br>}<br>对于上述的每次请求创建一个线程池修复后，我有个问题，每次请求 线程池处理完任务后，假如要停止整个程序的话，这个线程池是怎么关闭呢","like_count":0},{"had_liked":false,"id":298842,"user_name":"Geek6530","can_delete":false,"product_type":"c1","uid":2328982,"ip_address":"","ucode":"8A5E02A73BEF25","user_header":"","comment_is_top":false,"comment_ctime":1624343966,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1624343966","product_id":100047701,"comment_content":"老师，您好，我用您第一个例子的代码（固定为1的线程池），我这边是没有报OOM异常的。我理解的是这段代码在短时间内只创建了一个大的String对象，然后创建了1亿个Runable对象的引用，所以是不会报OOM的，不知道我理解的是否正确？","like_count":0,"discussions":[{"author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/e24e181e.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":403680,"discussion_content":"你把堆内存弄小点，可以很快到达临界点从而 OOM，比如：-Xms512m -Xmx512m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634130489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294235,"user_name":"李文希","can_delete":false,"product_type":"c1","uid":2361093,"ip_address":"","ucode":"F2E359B099C667","user_header":"https://static001.geekbang.org/account/avatar/00/24/07/05/cac1e09e.jpg","comment_is_top":false,"comment_ctime":1621843690,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621843690","product_id":100047701,"comment_content":"为什么60秒后输出17的流程解析:<br>1 创建一个任务, 使用了第1个核心线程,还有1个核心线程空闲,工作队列长度为0<br>2 创建一个任务, 使用了第2个核心线程,没有核心线程空闲,工作队列长度为0<br>3 创建一个任务, 没有核心线程可以使用,将任务放入到工作队列中,长度为1<br>4 创建一个任务, 没有核心线程可以使用,将任务放入到工作队列中,长度为2<br>5 创建一个任务, 没有核心线程可以使用,将任务放入到工作队列中,长度为3<br>6 创建一个任务, 没有核心线程可以使用,将任务放入到工作队列中,长度为4<br>7 创建一个任务, 没有核心线程可以使用,将任务放入到工作队列中,长度为5<br>8 创建一个任务, 没有核心线程可以使用,将任务放入到工作队列中,长度为6<br>9 创建一个任务, 没有核心线程可以使用,将任务放入到工作队列中,长度为7<br>10 创建一个任务, 没有核心线程可以使用,将任务放入到工作队列中,长度为8<br>11 创建一个任务, 第1个核心线程执行完毕,从工作队列中取一个任务来执行,刚创建的任务无核心线程可用,将任务放入到工作队列中,长度为8<br>12 创建一个任务, 第2个核心线程执行完毕,从工作队列中取一个任务来执行,刚创建的任务无核心线程可用,将任务放入到工作队列中,长度为8<br>13 创建一个任务, 没有核心线程可以使用,将任务放入到工作队列中,长度为9<br>14 创建一个任务, 没有核心线程可以使用,将任务放入到工作队列中,长度为10<br>15 创建一个任务, 没有核心线程可以使用,工作队列长度达到最大值,线程池线程数加1,第3个线程从工作队列中取一个任务执行,同时将该创建的任务放入工作队列中,当前长度为10<br>16 创建一个任务, 没有核心线程可以使用,工作队列长度达到最大值,线程池线程数加1,第4个线程从工作队列中取一个任务执行,同时将该创建的任务放入工作队列中,当前长度为10<br>17 创建一个任务, 没有核心线程可以使用,工作队列长度达到最大值,线程池线程数加1,第5个线程从工作队列中取一个任务执行,同时将该创建的任务放入工作队列中,当前长度为10<br>18 创建一个任务, 没有核心线程可以使用,工作队列长度达到最大值,线程池线程数达到最大值,按照拒绝策略,第一次抛出异常<br>19 创建一个任务, 没有核心线程可以使用,工作队列长度达到最大值,线程池线程数达到最大值,按照拒绝策略,第二次抛出异常<br>20 创建一个任务, 没有核心线程可以使用,工作队列长度达到最大值,线程池线程数达到最大值,按照拒绝策略,第三次抛出异常","like_count":1},{"had_liked":false,"id":291452,"user_name":"Tom","can_delete":false,"product_type":"c1","uid":1908926,"ip_address":"","ucode":"0BA98E780BB34C","user_header":"https://static001.geekbang.org/account/avatar/00/1d/20/be/bf6a570f.jpg","comment_is_top":false,"comment_ctime":1620292138,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620292138","product_id":100047701,"comment_content":"老师，您好，请问线程池中的corePoolSize，maxPoolSiz，以及队列长度参数，有什么通用的设置策略吗？","like_count":0},{"had_liked":false,"id":285380,"user_name":"JoJi","can_delete":false,"product_type":"c1","uid":2066986,"ip_address":"","ucode":"B88997A80E76AC","user_header":"https://static001.geekbang.org/account/avatar/00/1f/8a/2a/f94db4dc.jpg","comment_is_top":false,"comment_ctime":1616763814,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616763814","product_id":100047701,"comment_content":"老师，第一个例子每次创建一个线程池，用完过后关闭这种怕是控制不住线程数吧(我们项目有这种..)。 以单例的模式使用线程池，是不是更好一些？<br>","like_count":0},{"had_liked":false,"id":258562,"user_name":"JoJi","can_delete":false,"product_type":"c1","uid":2066986,"ip_address":"","ucode":"B88997A80E76AC","user_header":"https://static001.geekbang.org/account/avatar/00/1f/8a/2a/f94db4dc.jpg","comment_is_top":false,"comment_ctime":1604483798,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604483798","product_id":100047701,"comment_content":"老师，线程池是不是没有针对线程的终止方法呀?想实现线程池执行一批任务，这批任务超时后强制关闭还在执行的线程。","like_count":0},{"had_liked":false,"id":255061,"user_name":"guanine🍀","can_delete":false,"product_type":"c1","uid":2251446,"ip_address":"","ucode":"8AFDD724F77C99","user_header":"https://static001.geekbang.org/account/avatar/00/22/5a/b6/abf52ebe.jpg","comment_is_top":false,"comment_ctime":1603261527,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603261527","product_id":100047701,"comment_content":"可以设置属性，allowCoreThreadTimeOut为true","like_count":0},{"had_liked":false,"id":250774,"user_name":"土土土”","can_delete":false,"product_type":"c1","uid":1120794,"ip_address":"","ucode":"31D42CD027E108","user_header":"https://static001.geekbang.org/account/avatar/00/11/1a/1a/3afd1b46.jpg","comment_is_top":false,"comment_ctime":1601215457,"is_pvip":false,"replies":[{"id":"91769","content":"n+1的意思是限制过多的线程，多了没意义","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1601258747,"ip_address":"","comment_id":250774,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1601215457","product_id":100047701,"comment_content":"有一点没明白，cpu计算型任务核心线程建议n+1。cpu只有4核，那么我项目线程池有好多个n+1的。并且同时执行，那么4核cpu需要不断切换，这样效率不高吧。还是说我项目只能有一个m+1的线程池？","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506280,"discussion_content":"n+1的意思是限制过多的线程，多了没意义","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601258747,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":246091,"user_name":"行则将至","can_delete":false,"product_type":"c1","uid":1542987,"ip_address":"","ucode":"DB972F2DF059C4","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","comment_is_top":false,"comment_ctime":1599177211,"is_pvip":false,"replies":[{"id":"90457","content":"太小弹性不够，太大丢失数据损失就大，看数据类型、并发等","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1599196314,"ip_address":"","comment_id":246091,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1599177211","product_id":100047701,"comment_content":"老师，线程池的队列大小如何确定？","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505059,"discussion_content":"太小弹性不够，太大丢失数据损失就大，看数据类型、并发等","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599196314,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244816,"user_name":"大王","can_delete":false,"product_type":"c1","uid":2104710,"ip_address":"","ucode":"866B3A9913237D","user_header":"https://static001.geekbang.org/account/avatar/00/20/1d/86/ce0c9c17.jpg","comment_is_top":false,"comment_ctime":1598689616,"is_pvip":false,"replies":[{"id":"90088","content":"压测的还是单次测试","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1598705537,"ip_address":"","comment_id":244816,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1598689616","product_id":100047701,"comment_content":"    老师，最近遇到一个坑，Spring boot项目，JPA访问Oracle。查询唯一键，<br>    第二种比第一种速度快10倍，上面是24ms，下面那个只要2ms，不知道什么回事，<br>   测试环境在没有别的访问情况下，也复现了这个问题，<br>    一个使用tomcat 池的线程，一个是使用jdk线程而已，老师能知道这个诡异问题的原因吗？<br>    @PostMapping(&quot;&#47;cal_account2&quot;)<br>    public String calAccount2() {<br>        StopWatch stopWatch = new StopWatch();<br>        stopWatch.start();<br>        AccountInfo accountInfo = new AccountInfo();<br>        accountInfo.setAccountId(&quot;351819670792110080&quot;);<br>        accountService.getAccountInfo(accountInfo);<br>        stopWatch.stop();<br>        log.info(&quot;http&quot;, stopWatch.prettyPrint());<br>        return &quot;操作成功&quot;;<br>    }<br><br>    @PostMapping(&quot;&#47;cal_account3&quot;)<br>    public String calAccount3() {<br>        asyncCallThreadPool.execute(() -&gt; {<br>            StopWatch stopWatch = new StopWatch();<br>            stopWatch.start();<br>            AccountInfo accountInfo = new AccountInfo();<br>            accountInfo.setAccountId(&quot;351819670792110080&quot;);<br>            accountService.getAccountInfo(accountInfo);<br>            stopWatch.stop();<br>            log.info(&quot;async&quot;, stopWatch.prettyPrint());<br>        });<br>        return &quot;操作成功&quot;;<br>    }","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504708,"discussion_content":"压测的还是单次测试","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598705537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2104710,"avatar":"https://static001.geekbang.org/account/avatar/00/20/1d/86/ce0c9c17.jpg","nickname":"大王","note":"","ucode":"866B3A9913237D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301907,"discussion_content":"日志是同步的，这个时间是stopwatch,以及打印sql顺序时间分析都一样的，网络流量的明显http-nio线程的流量小一些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598706515,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2104710,"avatar":"https://static001.geekbang.org/account/avatar/00/20/1d/86/ce0c9c17.jpg","nickname":"大王","note":"","ucode":"866B3A9913237D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301905,"discussion_content":"单次测试，每次测试都是这样，问题起源于生产环境以前是定时跑试算任务，后面因为上下游系统升级，需要某一个时刻手动发起，就内部curl方式调定时任务代码，代码一样，单线程的，只是一个tomcat线程，很慢执行起来，但都在执行，只是读取数据库操作io都很慢，以前quarze的定时任务就很快，所以很奇怪，都是线程不存在有快慢之分，没有啥思路了，而且是别的上游停服操作，没有任何流量，所以很奇怪，找不到啥思路了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598706220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":243448,"user_name":"阿彬","can_delete":false,"product_type":"c1","uid":2019590,"ip_address":"","ucode":"A5A341C625000A","user_header":"https://static001.geekbang.org/account/avatar/00/1e/d1/06/2ebe1586.jpg","comment_is_top":false,"comment_ctime":1598111916,"is_pvip":false,"replies":[{"id":"89716","content":"这和什么类型的线程池没关系 如果你无限申请newsinglethreadexecutor总是有问题的 就看是不是正确使用资源","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1598164669,"ip_address":"","comment_id":243448,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1598111916","product_id":100047701,"comment_content":"大佬，newsinglethreadexecutor 会oom吗","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504289,"discussion_content":"这和什么类型的线程池没关系 如果你无限申请newsinglethreadexecutor总是有问题的 就看是不是正确使用资源","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598164669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239774,"user_name":"Geek_b70da7","can_delete":false,"product_type":"c1","uid":2062505,"ip_address":"","ucode":"BA81153E36FEA1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/06icm3r7fRGSjdEYGIWIx4VV5ibkKibzvlaJ08ibBXyzRoricX93YmvJvvsurahgCNics6Rt5cGqxMSh24KxMJ3RjNmA/132","comment_is_top":false,"comment_ctime":1596638985,"is_pvip":false,"replies":[{"id":"88561","content":"四核200有点多了","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1596673784,"ip_address":"","comment_id":239774,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1596638985","product_id":100047701,"comment_content":"Tps75升到1727那个案例，生产环境任务能设置核心线程200么，线上环境cpu4核，任务是io密集型","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503215,"discussion_content":"四核200有点多了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596673784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":238827,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1274787,"ip_address":"","ucode":"C233DF1D224EC1","user_header":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","comment_is_top":false,"comment_ctime":1596335247,"is_pvip":true,"replies":[{"id":"88206","content":"实现自定义的Runnable类，RejectedExecutionHandler里面强制转换一下Runnable参数","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1596346359,"ip_address":"","comment_id":238827,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1596335247","product_id":100047701,"comment_content":"老师，你好！<br>我有一个问题：<br>一个用户发生交易，给用户下粉丝用户发提醒，使用多线程循环该粉丝列表，调用异步接口发送消息盒子。<br>目前线程池拒绝策略使用丢弃，队列大小是512，发现现在交易量上来了，用户列表由原来的几十不等到了近万，若干个用户同时进来交易，粉丝量可能一下子会达到30000+，就出现了超出队列大小而丢弃发送任务的情况。 活动火爆，粉丝数现在不好评估，队列大小设置多少合适不知。<br>想自定义拒绝策略，拒绝时拿到失败情况的业务参数缓存下来，补发消息，如何在自定义的拒绝策略里面拿到业务参数？实现自定义策略方法中拿到的参数是runnable和Executor，这两个参数如何拿到业务参数？","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502866,"discussion_content":"实现自定义的Runnable类，RejectedExecutionHandler里面强制转换一下Runnable参数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596346359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2251446,"avatar":"https://static001.geekbang.org/account/avatar/00/22/5a/b6/abf52ebe.jpg","nickname":"guanine🍀","note":"","ucode":"8AFDD724F77C99","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":315307,"discussion_content":"如果不需要很实时的消息通知，是不是可以考虑使用消息队列削峰的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603262158,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":238750,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1274787,"ip_address":"","ucode":"C233DF1D224EC1","user_header":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","comment_is_top":false,"comment_ctime":1596281041,"is_pvip":true,"replies":[{"id":"88197","content":"构造方法还是setter方法初始化都可以","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1596334197,"ip_address":"","comment_id":238750,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1596281041","product_id":100047701,"comment_content":"老师，你好！<br>线程池的开辟到底使用构造方法开启还是配置类开启<br>private static ThreadPoolExecutor asyncCalcThreadPool = new ThreadPoolExecutor( 200, 200, 1, TimeUnit.HOURS, new ArrayBlockingQueue&lt;&gt;(1000), new ThreadFactoryBuilder().setNameFormat(&quot;asynccalc-threadpool-%d&quot;).get());<br><br>    @Bean(&quot;feedExecutor&quot;)<br>    public Executor feedExecutor() {<br>        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();<br>        executor.setCorePoolSize(8);<br>        executor.setMaxPoolSize(20);<br>        executor.setQueueCapacity(1000);<br>        executor.setKeepAliveSeconds(100);<br>        executor.setThreadNamePrefix(&quot;feed-executor-&quot;);<br>        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());<br>        return executor;<br>    }","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502843,"discussion_content":"构造方法还是setter方法初始化都可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596334197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236147,"user_name":"tongmin_tsai","can_delete":false,"product_type":"c1","uid":1045090,"ip_address":"","ucode":"D9423E770D5846","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f2/62/f873cd8f.jpg","comment_is_top":false,"comment_ctime":1595328543,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595328543","product_id":100047701,"comment_content":"老师，能分享一下最佳实战吗？比如线程，线程池的优雅关闭","like_count":0},{"had_liked":false,"id":235468,"user_name":"Better me","can_delete":false,"product_type":"c1","uid":1261959,"ip_address":"","ucode":"CADF08D357489A","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","comment_is_top":false,"comment_ctime":1595048896,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"1595048896","product_id":100047701,"comment_content":"声明线程池后立即调用 prestartAllCoreThreads 方法，来启动所有核心线程；<br>传入 true 给 allowCoreThreadTimeOut 方法，来让线程池在空闲的时候同样回收核心线程。<br><br>老师在文中说的这两点一起使用会不会有冲突，比如刚开始初始化好的核心线程又被回收了","like_count":0,"discussions":[{"author":{"id":1488356,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b5/e4/e6faf686.jpg","nickname":"握了个大蚂蚱","note":"","ucode":"AD34AD4FA37371","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339952,"discussion_content":"蛤蛤，你很有才","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609847775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1261959,"avatar":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","nickname":"Better me","note":"","ucode":"CADF08D357489A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1488356,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b5/e4/e6faf686.jpg","nickname":"握了个大蚂蚱","note":"","ucode":"AD34AD4FA37371","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339964,"discussion_content":"哈哈可以一起交流😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609850343,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":339952,"ip_address":""},"score":339964,"extra":""}]}]},{"had_liked":false,"id":230080,"user_name":"Xcode","can_delete":false,"product_type":"c1","uid":1983768,"ip_address":"","ucode":"1CFE859EEA4928","user_header":"https://static001.geekbang.org/account/avatar/00/1e/45/18/a29b1fa3.jpg","comment_is_top":false,"comment_ctime":1593253149,"is_pvip":false,"replies":[{"id":"84914","content":"肯定的","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1593262900,"ip_address":"","comment_id":230080,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1593253149","product_id":100047701,"comment_content":"如果每个请求都在service里 new一个线程池，并发情况下线程池是不是创建太多了？","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499755,"discussion_content":"肯定的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593262900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":226037,"user_name":"The One","can_delete":false,"product_type":"c1","uid":1319368,"ip_address":"","ucode":"D3438E31543332","user_header":"https://static001.geekbang.org/account/avatar/00/14/21/c8/33828cfc.jpg","comment_is_top":false,"comment_ctime":1591933431,"is_pvip":true,"replies":[{"id":"83279","content":"1. 如果你处理任务的时候响应了InterruptedException那么这个线程就废了重新起一个线程<br>2. 普通的业务逻辑不太建议通过future.cancel(true) +  线程的中断机制来做这些处理，建议还是每个任务自己在任务处理的间隙（比如循环中）通过外部状态位判断任务是否需要继续执行，不需要的话就提前结束<br>3. 只返回一个Future可以使用 CompletableFuture.anyOf()来完成，结合我第二点说的任务里自己判断状态决定是否要继续执行其它任务来实现<br>4. 如果你的任务不分阶段，也不涉及InterruptedException，那么执行了确实就无法中断","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1591946090,"ip_address":"","comment_id":226037,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591933431","product_id":100047701,"comment_content":"老师您好，请教一个问题，线程池 执行任务，通过持有的Future cancel任务之后，线程池里面执行该任务的线程状态如何？还能被复用 吗？感谢<br>需求是这样，A.B.C三个任务交给线程池执行，只要有一个返回我就知道结果返给前端，这时候需要中止其余的任务，调用cancel之后，线程池中的线程状态会如何？针对这个需求还有更好的实现方式吗？感谢","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498087,"discussion_content":"1. 如果你处理任务的时候响应了InterruptedException那么这个线程就废了重新起一个线程\n2. 普通的业务逻辑不太建议通过future.cancel(true) +  线程的中断机制来做这些处理，建议还是每个任务自己在任务处理的间隙（比如循环中）通过外部状态位判断任务是否需要继续执行，不需要的话就提前结束\n3. 只返回一个Future可以使用 CompletableFuture.anyOf()来完成，结合我第二点说的任务里自己判断状态决定是否要继续执行其它任务来实现\n4. 如果你的任务不分阶段，也不涉及InterruptedException，那么执行了确实就无法中断","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591946090,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225577,"user_name":"Tokiomi","can_delete":false,"product_type":"c1","uid":1632052,"ip_address":"","ucode":"E2C0A59D1B1D4F","user_header":"https://static001.geekbang.org/account/avatar/00/18/e7/34/66289bd6.jpg","comment_is_top":false,"comment_ctime":1591793209,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591793209","product_id":100047701,"comment_content":"学到了好多工具类。。","like_count":0},{"had_liked":false,"id":224888,"user_name":"VIC","can_delete":false,"product_type":"c1","uid":1114064,"ip_address":"","ucode":"3B3E6D344488B2","user_header":"https://static001.geekbang.org/account/avatar/00/10/ff/d0/402be1e9.jpg","comment_is_top":false,"comment_ctime":1591583461,"is_pvip":false,"replies":[{"id":"82782","content":"判断可以使用isDone()，报错说明任务可能中断、出错或取消了","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1591607298,"ip_address":"","comment_id":224888,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591583461","product_id":100047701,"comment_content":"怎么判断任务执行完成？future.get报错","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497646,"discussion_content":"判断可以使用isDone()，报错说明任务可能中断、出错或取消了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591607298,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224858,"user_name":"VIC","can_delete":false,"product_type":"c1","uid":1114064,"ip_address":"","ucode":"3B3E6D344488B2","user_header":"https://static001.geekbang.org/account/avatar/00/10/ff/d0/402be1e9.jpg","comment_is_top":false,"comment_ctime":1591577744,"is_pvip":false,"replies":[{"id":"82762","content":"通过Future拿任务结果（自己保存Future的List），不需要通过线程池来区分","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1591580725,"ip_address":"","comment_id":224858,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1591577744","product_id":100047701,"comment_content":"我们的代码没有复用线程池。提交的任务，要等待处理结束拿到结果。上次提的任务和下次提交的任务，怎么分出来","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497633,"discussion_content":"通过Future拿任务结果（自己保存Future的List），不需要通过线程池来区分","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591580725,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1114064,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ff/d0/402be1e9.jpg","nickname":"VIC","note":"","ucode":"3B3E6D344488B2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293007,"discussion_content":"老师，能加微信吗？nyzfl123","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595410761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1114064,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ff/d0/402be1e9.jpg","nickname":"VIC","note":"","ucode":"3B3E6D344488B2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293004,"discussion_content":"复用线程池，一直不关闭吗？\n遇到的问题是线程跑的越来越慢，怎么整。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595410113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1114064,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ff/d0/402be1e9.jpg","nickname":"VIC","note":"","ucode":"3B3E6D344488B2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":280635,"discussion_content":"那需要判断线程池结束吗？用阻塞的get吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591581627,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224802,"user_name":"捞鱼的搬砖奇","can_delete":false,"product_type":"c1","uid":1021539,"ip_address":"","ucode":"2FD194C4DA26E5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/96/63/7eb32c9b.jpg","comment_is_top":false,"comment_ctime":1591543207,"is_pvip":false,"replies":[{"id":"82761","content":"org.redisson:redisson:jar:3.11.5","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1591580690,"ip_address":"","comment_id":224802,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591543207","product_id":100047701,"comment_content":"请问jodd 的的 jar 是哪个依赖引入的呢","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497611,"discussion_content":"org.redisson:redisson:jar:3.11.5","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591580690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219139,"user_name":"gogogo","can_delete":false,"product_type":"c1","uid":1016860,"ip_address":"","ucode":"EB19D75BB7100E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/84/1c/7997352e.jpg","comment_is_top":false,"comment_ctime":1589954401,"is_pvip":false,"replies":[{"id":"80965","content":"那就是收到一个请求判断是否合适处理，不合适的话扔到MQ？我不知道具体你的需求是啥，为什么不直接由网关来根据头进行转发请求到合适的服务处理呢？","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1589964295,"ip_address":"","comment_id":219139,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589954401","product_id":100047701,"comment_content":"从tomcat拿出一个任务，提取header字段，判断是否可以执行，不执行的话把它重新放回任务队列，有什么方案参考吗？","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495695,"discussion_content":"那就是收到一个请求判断是否合适处理，不合适的话扔到MQ？我不知道具体你的需求是啥，为什么不直接由网关来根据头进行转发请求到合适的服务处理呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589964295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216536,"user_name":"Geek_f4f0d4","can_delete":false,"product_type":"c1","uid":1149509,"ip_address":"","ucode":"DBC7614E0A7070","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL1BLgfPicBbSuXUK5uaEdQ76j2icNaPvicJcRrsxpLOjyuiczpD8efxoKrLEiaHs4At4loauOTLWOHQmg/132","comment_is_top":false,"comment_ctime":1589278859,"is_pvip":false,"replies":[{"id":"80117","content":"不行 文中有提到 有的时候需要多个线程池  ","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1589282183,"ip_address":"","comment_id":216536,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589278859","product_id":100047701,"comment_content":"老师，你好，“既然使用了线程池就需要确保线程池是在复用的，每次 new 一个线程池出来可能比不用线程池还糟糕。”，那么将线程池设计成单例模型是不是可以规避这个问题？","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494853,"discussion_content":"不行 文中有提到 有的时候需要多个线程池  ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589282183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214640,"user_name":"Richie","can_delete":false,"product_type":"c1","uid":1019588,"ip_address":"","ucode":"12314EF0347693","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/c4/8d1150f3.jpg","comment_is_top":false,"comment_ctime":1588776264,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588776264","product_id":100047701,"comment_content":"“不知道你有没有想过：Java 线程池是先用工作队列来存放来不及处理的任务，满了之后再扩容线程池。当我们的工作队列设置得很大时，最大线程数这个参数显得没有意义，因为队列很难满，或者到满的时候再去扩容线程池已经于事无补了。”<br>--------------------<br>第一次了解到这块逻辑的时候也在好奇，为什么要设计成这样呢？为什么不先扩容线程，达到最大线程数时再放到工作队列里呢？<br>","like_count":1},{"had_liked":false,"id":214290,"user_name":"aiwen","can_delete":false,"product_type":"c1","uid":1104346,"ip_address":"","ucode":"504F06CCC7B4FB","user_header":"https://static001.geekbang.org/account/avatar/00/10/d9/da/23a4a0c4.jpg","comment_is_top":false,"comment_ctime":1588695398,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1588695398","product_id":100047701,"comment_content":"不说说线程数量配置多大合适？","like_count":0,"discussions":[{"author":{"id":1488356,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b5/e4/e6faf686.jpg","nickname":"握了个大蚂蚱","note":"","ucode":"AD34AD4FA37371","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339953,"discussion_content":"不是说了核数+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609847888,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":210647,"user_name":"龙猫","can_delete":false,"product_type":"c1","uid":1112490,"ip_address":"","ucode":"FD726CC969EF9C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/aa/3e80212e.jpg","comment_is_top":false,"comment_ctime":1587802386,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587802386","product_id":100047701,"comment_content":"线程池要注意处理并发问题，以及线程协作(执行顺序)问题","like_count":0},{"had_liked":false,"id":207022,"user_name":"lyuzh","can_delete":false,"product_type":"c1","uid":1263250,"ip_address":"","ucode":"E2203D92C70DA0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKibhEIEcmUmz20DNlwHfS8DuqzYTnrqicicicCmHzzxQeHnMEfq4lBY6fytIuVDPQOB9MoZpBl2UuOEQ/132","comment_is_top":false,"comment_ctime":1586997927,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586997927","product_id":100047701,"comment_content":"朱老师 您好！朱老师是否可以再介绍一些线程池关闭时的坑点呀(shutdown and shutdown Now)","like_count":0},{"had_liked":false,"id":205576,"user_name":"吃饭","can_delete":false,"product_type":"c1","uid":1692756,"ip_address":"","ucode":"AF0D7165D5F049","user_header":"https://static001.geekbang.org/account/avatar/00/19/d4/54/7263deb2.jpg","comment_is_top":false,"comment_ctime":1586677354,"is_pvip":false,"replies":[{"id":"76806","content":"在设计篇的生产就绪一文我会有一些分享。最简单的方式是自己写代码打点实现一些监控。我们公司内部会通过Java Agent方式来实现无代码的监控。","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1586681694,"ip_address":"","comment_id":205576,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1586677354","product_id":100047701,"comment_content":"线程池的监控有没有什么生产级别的好的方式","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491519,"discussion_content":"在设计篇的生产就绪一文我会有一些分享。最简单的方式是自己写代码打点实现一些监控。我们公司内部会通过Java Agent方式来实现无代码的监控。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586681694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200515,"user_name":"潇洒的毅小峰","can_delete":false,"product_type":"c1","uid":1118141,"ip_address":"","ucode":"24638DAED92F08","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/bd/7a9b2a0c.jpg","comment_is_top":false,"comment_ctime":1585614895,"is_pvip":false,"replies":[{"id":"74992","content":"不管是文中还是源码中都是有的","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1585615075,"ip_address":"","comment_id":200515,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585614895","product_id":100047701,"comment_content":"找不到printStats这个方法呀能告知一下吗老师","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490054,"discussion_content":"不管是文中还是源码中都是有的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585615075,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":195056,"user_name":"Joker","can_delete":false,"product_type":"c1","uid":1156592,"ip_address":"","ucode":"126AF848001A1E","user_header":"https://static001.geekbang.org/account/avatar/00/11/a5/f0/8648c464.jpg","comment_is_top":false,"comment_ctime":1585131838,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585131838","product_id":100047701,"comment_content":"ThreadPoolExecutor 这个需要shutdown吧，会一直存在的，我有的时候测试的时候，没有手动shutdown的话，程序就不会结束。<br>为了防止创建过多的线程池的问题，还是要开发好监控，有监控的话，出现了线程数为0的线程池就 shutdown就行了。","like_count":0}]}