{"id":380210,"title":"04｜内置 Hooks（2）：为什么要避免重复定义回调函数？","content":"<p>你好，我是王沛。这节课我们来继续学习内置 Hooks 的用法。</p><p>在上节课你已经看到了 useState 和 useEffect 这两个最为核心的 Hooks 的用法。理解了它们，你基本上就掌握了 React 函数组件的开发思路。</p><p>但是还有一些细节问题，例如事件处理函数会被重复定义、数据计算过程没有缓存等，还都需要一些机制来处理。所以在这节课，你会看到其它四个最为常用的内置 Hooks （包括useCallback、useMemo、useRef和useContext）的作用和用法，以及如何利用这些 Hooks 进行功能开发。</p><h1>useCallback：缓存回调函数</h1><p>在 React 函数组件中，每一次 UI 的变化，都是通过重新执行整个函数来完成的，这和传统的 Class 组件有很大区别：函数组件中并没有一个直接的方式在多次渲染之间维持一个状态。</p><p>比如下面的代码中，我们在加号按钮上定义了一个事件处理函数，用来让计数器加1。但是因为定义是在函数组件内部，因此在多次渲染之间，是无法重用 handleIncrement 这个函数的，而是每次都需要创建一个新的：</p><pre><code>function Counter() {\n  const [count, setCount] = useState(0);\n  const handleIncrement = () =&gt; setCount(count + 1);\n  // ...\n  return &lt;button onClick={handleIncrement}&gt;+&lt;/button&gt;\n}\n</code></pre><p>你不妨思考下这个过程。每次组件状态发生变化的时候，函数组件实际上都会重新执行一遍。在每次执行的时候，实际上都会创建一个新的事件处理函数 handleIncrement。这个事件处理函数中呢，包含了 count 这个变量的闭包，以确保每次能够得到正确的结果。</p><!-- [[[read_end]]] --><p>这也意味着，即使 count 没有发生变化，但是函数组件因为其它状态发生变化而重新渲染时，这种写法也会每次创建一个新的函数。创建一个新的事件处理函数，虽然不影响结果的正确性，但其实是没必要的。因为这样做不仅增加了系统的开销，更重要的是：<strong>每次创建新函数的方式会让接收事件处理函数的组件，需要重新渲染</strong>。</p><p>比如这个例子中的 button 组件，接收了 <code>handleIncrement</code> ，并作为一个属性。如果每次都是一个新的，那么这个 React 就会认为这个组件的 props 发生了变化，从而必须重新渲染。因此，我们需要做到的是：<strong>只有当 count 发生变化时，我们才需要重新定一个回调函数。而</strong>这正是 useCallback 这个 Hook 的作用。</p><p>它的 API 签名如下：</p><pre><code>useCallback(fn, deps)\n</code></pre><p>这里fn是定义的回调函数，deps是依赖的变量数组。只有当某个依赖变量发生变化时，才会重新声明 fn这个回调函数。那么对于上面的例子，我们可以把 handleIncrement这个事件处理函数通过 useCallback 来进行性能的优化：</p><pre><code>import React, { useState, useCallback } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  const handleIncrement = useCallback(\n    () =&gt; setCount(count + 1),\n    [count], // 只有当 count 发生变化时，才会重新创建回调函数\n  );\n  // ...\n  return &lt;button onClick={handleIncrement}&gt;+&lt;/button&gt;\n}\n\n</code></pre><p>在这里，我们把 count 这个 state ，作为一个依赖传递给 useCallback。这样，只有 count 发生变化的时候，才需要重新创建一个回调函数，这样就保证了组件不会创建重复的回调函数。而接收这个回调函数作为属性的组件，也不会频繁地需要重新渲染。</p><p>除了useCallback，useMemo也是为了缓存而设计的。只不过，useCallback缓存的是一个函数，而useMemo缓存的是计算的结果。那么接下来，我们就一起学习下useMemo的用法吧。</p><h1>useMemo：缓存计算的结果</h1><p>useMemo 的 API 签名如下：</p><pre><code>useMemo(fn, deps);\n</code></pre><p>这里的fn是产生所需数据的一个计算函数。通常来说，fn会使用  deps 中声明的一些变量来生成一个结果，用来渲染出最终的 UI。</p><p>这个场景应该很容易理解：<strong>如果某个数据是通过其它数据计算得到的，那么只有当用到的数据，也就是依赖的数据发生变化的时候，才应该需要重新计算</strong>。</p><p>举个例子，对于一个显示用户信息的列表，现在需要对用户名进行搜索，且 UI 上需要根据搜索关键字显示过滤后的用户，那么这样一个功能需要有两个状态：</p><ol>\n<li>用户列表数据本身：来自某个请求。</li>\n<li>搜索关键字：用户在搜索框输入的数据。</li>\n</ol><p>无论是两个数据中的哪一个发生变化，都需要过滤用户列表以获得需要展示的数据。那么如果不使用 useMemo 的话，就需要用这样的代码实现：</p><pre><code>import React, { useState, useEffect } from &quot;react&quot;;\n\nexport default function SearchUserList() {\n  const [users, setUsers] = useState(null);\n  const [searchKey, setSearchKey] = useState(&quot;&quot;);\n\n  useEffect(() =&gt; {\n    const doFetch = async () =&gt; {\n      // 组件首次加载时发请求获取用户数据\n      const res = await fetch(&quot;https://reqres.in/api/users/&quot;);\n      setUsers(await res.json());\n    };\n    doFetch();\n  }, []);\n  let usersToShow = null;\n\n  if (users) {\n    // 无论组件为何刷新，这里一定会对数组做一次过滤的操作\n    usersToShow = users.data.filter((user) =&gt;\n      user.first_name.includes(searchKey),\n    );\n  }\n\n  return (\n    &lt;div&gt;\n      &lt;input\n        type=&quot;text&quot;\n        value={searchKey}\n        onChange={(evt) =&gt; setSearchKey(evt.target.value)}\n      /&gt;\n      &lt;ul&gt;\n        {usersToShow &amp;&amp;\n          usersToShow.length &gt; 0 &amp;&amp;\n          usersToShow.map((user) =&gt; {\n            return &lt;li key={user.id}&gt;{user.first_name}&lt;/li&gt;;\n          })}\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre><p>在这个例子中，无论组件为何要进行一次重新渲染，实际上都需要进行一次过滤的操作。但其实你只需要在 users 或者 searchKey 这两个状态中的某一个发生变化时，重新计算获得需要展示的数据就行了。那么，这个时候，我们就可以用 useMemo 这个 Hook 来实现这个逻辑，缓存计算的结果：</p><pre><code>//...\n// 使用 userMemo 缓存计算的结果\nconst usersToShow = useMemo(() =&gt; {\n    if (!users) return null;\n    return users.data.filter((user) =&gt; {\n      return user.first_name.includes(searchKey));\n    }\n  }, [users, searchKey]);\n//...\n</code></pre><p>可以看到，通过 useMemo 这个 Hook，可以避免在用到的数据没发生变化时进行的重复计算。虽然例子展示的是一个很简单的场景，但如果是一个复杂的计算，那么对于提升性能会有很大的帮助。这也是userMemo的一大好处：避免重复计算。</p><p>除了避免重复计算之外，useMemo 还有一个很重要的好处：<strong>避免子组件的重复渲染</strong>。比如在例子中的 usersToShow 这个变量，如果每次都需要重新计算来得到，那么对于 UserList 这个组件而言，就会每次都需要刷新，因为它将 usersToShow 作为了一个属性。而一旦能够缓存上次的结果，就和 useCallback 的场景一样，可以避免很多不必要的组件刷新。</p><p>这个时候，如果我们结合 useMemo 和 useCallback 这两个 Hooks 一起看，会发现一个有趣的特性，那就是 <strong>useCallback 的功能其实是可以用 useMemo 来实现的。</strong>比如下面的代码就是利用 useMemo 实现了 useCallback 的功能：</p><pre><code> const myEventHandler = useMemo(() =&gt; {\n   // 返回一个函数作为缓存结果\n   return () =&gt; {\n     // 在这里进行事件处理\n   }\n }, [dep1, dep2]);\n</code></pre><p>理解了这一点，相信你一下子会对这两个 Hooks 的机制有更进一步的认识，也就不用死记硬背两个 API 都是干嘛的了，因为从本质上来说，它们只是做了同一件事情：<strong>建立了一个绑定某个结果到依赖数据的关系。只有当依赖变了，这个结果才需要被重新得到</strong>。</p><h1>useRef：在多次渲染之间共享数据</h1><p>函数组件虽然非常直观，简化了思考 UI 实现的逻辑，但是比起 Class 组件，还缺少了一个很重要的能力：<strong>在多次渲染之间共享数据。</strong></p><p>在类组件中，我们可以定义类的成员变量，以便能在对象上通过成员属性去保存一些数据。但是在函数组件中，是没有这样一个空间去保存数据的。因此，React 让useRef 这样一个 Hook 来提供这样的功能。</p><p>useRef 的API签名如下：</p><pre><code>const myRefContainer = useRef(initialValue);\n</code></pre><p>我们可以把useRef看作是在函数组件之外创建的一个容器空间。在这个容器上，我们可以通过唯一的 current 属设置一个值，从而在函数组件的多次渲染之间共享这个值。</p><p>你可能会有疑问，useRef 的这个功能具体有什么用呢？我们可以看一个例子。</p><p>假设你要去做一个计时器组件，这个组件有开始和暂停两个功能。很显然，你需要用 window.setInterval 来提供计时功能；而为了能够暂停，你就需要在某个地方保存这个 window.setInterval 返回的计数器的引用，确保在点击暂停按钮的同时，也能用 window.clearInterval 停止计时器。那么，这个保存计数器引用的最合适的地方，就是 useRef，因为它可以存储跨渲染的数据。代码如下：</p><pre><code>import React, { useState, useCallback, useRef } from &quot;react&quot;;\n\nexport default function Timer() {\n  // 定义 time state 用于保存计时的累积时间\n  const [time, setTime] = useState(0);\n\n  // 定义 timer 这样一个容器用于在跨组件渲染之间保存一个变量\n  const timer = useRef(null);\n\n  // 开始计时的事件处理函数\n  const handleStart = useCallback(() =&gt; {\n    // 使用 current 属性设置 ref 的值\n    timer.current = window.setInterval(() =&gt; {\n      setTime((time) =&gt; time + 1);\n    }, 100);\n  }, []);\n\n  // 暂停计时的事件处理函数\n  const handlePause = useCallback(() =&gt; {\n    // 使用 clearInterval 来停止计时\n    window.clearInterval(timer.current);\n    timer.current = null;\n  }, []);\n\n  return (\n    &lt;div&gt;\n      {time / 10} seconds.\n      &lt;br /&gt;\n      &lt;button onClick={handleStart}&gt;Start&lt;/button&gt;\n      &lt;button onClick={handlePause}&gt;Pause&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre><p>这里可以看到，我们使用了 useRef 来创建了一个保存 window.setInterval 返回句柄的空间，从而能够在用户点击暂停按钮时清除定时器，达到暂停计时的目的。</p><p>同时你也可以看到，使用 useRef 保存的数据一般是和 UI 的渲染无关的，因此当 ref 的值发生变化时，是不会触发组件的重新渲染的，这也是 useRef 区别于 useState 的地方。</p><p>除了存储跨渲染的数据之外，useRef还有一个重要的功能，就是<strong>保存某个 DOM 节点的引用</strong>。我们知道，在React 中，几乎不需要关心真实的 DOM 节点是如何渲染和修改的。但是在某些场景中，我们必须要获得真实 DOM 节点的引用，所以结合 React 的 ref属性和 useRef 这个 Hook，我们就可以获得真实的 DOM 节点，并对这个节点进行操作。</p><p>比如说，你需要在点击某个按钮时让某个输入框获得焦点，可以通过下面的代码来实现：</p><pre><code>function TextInputWithFocusButton() {\n  const inputEl = useRef(null);\n  const onButtonClick = () =&gt; {\n    // current 属性指向了真实的 input 这个 DOM 节点，从而可以调用 focus 方法\n    inputEl.current.focus();\n  };\n  return (\n    &lt;&gt;\n      &lt;input ref={inputEl} type=&quot;text&quot; /&gt;\n      &lt;button onClick={onButtonClick}&gt;Focus the input&lt;/button&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre><p>这段代码是 React 官方文档提供的一个例子，可以看到ref 这个属性提供了获得 DOM 节点的能力，并利用 useRef 保存了这个节点的应用。这样的话，一旦 input 节点被渲染到界面上，那我们通过 inputEl.current 就能访问到真实的 DOM 节点的实例了。</p><h1>useContext：定义全局状态</h1><p>在第2节课中你已经知道了，React 组件之间的状态传递只有一种方式，那就是通过 props。这就意味着这种传递关系只能在父子组件之间进行。</p><p>看到这里你肯定会问，如果要跨层次，或者同层的组件之间要进行数据的共享，那应该如何去实现呢？这其实就涉及到一个新的命题：<strong>全局状态管理</strong>。</p><p>为此，React 提供了 Context 这样一个机制，能够让所有在某个组件开始的组件树上创建一个 Context。这样这个组件树上的所有组件，就都能访问和修改这个 Context了。那么在函数组件里，我们就可以使用 useContext 这样一个 Hook 来管理 Context。</p><p>useContext 的API 签名如下：</p><pre><code>const value = useContext(MyContext);\n</code></pre><p>正如刚才提到的，一个 Context 是从某个组件为根组件的组件树上可用的，所以我们需要有 API 能够创建一个 Context，这就是 <strong>React.createContext API，</strong>如下：</p><pre><code>const MyContext = React.createContext(initialValue);\n</code></pre><p>这里的 MyContext 具有一个 Provider 的属性，一般是作为组件树的根组件。这里我仍然以 React 官方文档的例子来讲解，即：一个主题的切换机制。代码如下：</p><pre><code>const themes = {\n  light: {\n    foreground: &quot;#000000&quot;,\n    background: &quot;#eeeeee&quot;\n  },\n  dark: {\n    foreground: &quot;#ffffff&quot;,\n    background: &quot;#222222&quot;\n  }\n};\n// 创建一个 Theme 的 Context\n\nconst ThemeContext = React.createContext(themes.light);\nfunction App() {\n  // 整个应用使用 ThemeContext.Provider 作为根组件\n  return (\n    // 使用 themes.dark 作为当前 Context \n    &lt;ThemeContext.Provider value={themes.dark}&gt;\n      &lt;Toolbar /&gt;\n    &lt;/ThemeContext.Provider&gt;\n  );\n}\n\n// 在 Toolbar 组件中使用一个会使用 Theme 的 Button\nfunction Toolbar(props) {\n  return (\n    &lt;div&gt;\n      &lt;ThemedButton /&gt;\n    &lt;/div&gt;\n  );\n}\n\n// 在 Theme Button 中使用 useContext 来获取当前的主题\nfunction ThemedButton() {\n  const theme = useContext(ThemeContext);\n  return (\n    &lt;button style={{\n      background: theme.background,\n      color: theme.foreground\n    }}&gt;\n      I am styled by theme context!\n    &lt;/button&gt;\n  );\n}\n</code></pre><p>看到这里你也许会有点好奇，Context 看上去就是一个全局的数据，为什么要设计这样一个复杂的机制，而不是直接用一个全局的变量去保存数据呢？</p><p>答案其实很简单，就是<strong>为了能够进行数据的绑定</strong>。当这个 Context 的数据发生变化时，使用这个数据的组件就能够自动刷新。但如果没有 Context，而是使用一个简单的全局变量，就很难去实现了。</p><p>不过刚才我们看到的其实是一个静态的使用 Context 的例子，直接用了 thems.dark 作为 Context 的值。那么如何让它变得动态呢？</p><p>比如说常见的切换黑暗或者明亮模式的按钮，用来切换整个页面的主题。事实上，动态 Context 并不需要我们学习任何新的 API，而是利用 React 本身的机制，通过这么一行代码就可以实现：</p><pre><code>&lt;ThemeContext.Provider value={themes.dark}&gt;\n</code></pre><p>可以看到，themes.dark 是作为一个属性值传给 Provider 这个组件的，如果要让它变得动态，其实只要用一个 state 来保存，通过修改 state，就能实现动态的切换Context 的值了。而且这么做，所有用到这个Context 的地方都会自动刷新。比如这样的代码：</p><pre><code>// ...\n\nfunction App() {\n  // 使用 state 来保存 theme 从而可以动态修改\n  const [theme, setTheme] = useState(&quot;light&quot;);\n\n  // 切换 theme 的回调函数\n  const toggleTheme = useCallback(() =&gt; {\n    setTheme((theme) =&gt; (theme === &quot;light&quot; ? &quot;dark&quot; : &quot;light&quot;));\n  }, []);\n\n  return (\n    // 使用 theme state 作为当前 Context\n    &lt;ThemeContext.Provider value={themes[theme]}&gt;\n      &lt;button onClick={toggleTheme}&gt;Toggle Theme&lt;/button&gt;\n      &lt;Toolbar /&gt;\n    &lt;/ThemeContext.Provider&gt;\n  );\n}\n</code></pre><p>在这段代码中，我们使用 state 来保存 theme，从而达到可以动态调整的目的。</p><p>可以看到，Context 提供了一个方便在多个组件之间共享数据的机制。不过需要注意的是，它的灵活性也是一柄双刃剑。你或许已经发现，Context 相当于提供了一个定义 React 世界中全局变量的机制，而全局变量则意味着两点：</p><ol>\n<li>会让调试变得困难，因为你很难跟踪某个 Context 的变化究竟是如何产生的。</li>\n<li>让组件的复用变得困难，因为一个组件如果使用了某个 Context，它就必须确保被用到的地方一定有这个 Context 的 Provider 在其父组件的路径上。</li>\n</ol><p>所以在 React 的开发中，除了像 Theme、Language 等一目了然的需要全局设置的变量外，我们很少会使用 Context 来做太多数据的共享。需要再三强调的是，Context 更多的是<strong>提供了一个强大的机制，让 React 应用具备定义全局的响应式数据的能力</strong>。</p><p>此外，很多状态管理框架，比如 Redux，正是利用了 Context 的机制来提供一种更加可控的组件之间的状态管理机制。因此，理解 Context 的机制，也可以让我们更好地去理解 Redux 这样的框架实现的原理。</p><h1>小结</h1><p>最后来总结一下今天的所学。在这节课，你看到了4个常用的 React内置 Hooks 的用法，包括：useCallback、useMemo、useRef 和 useContext。事实上，每一个 Hook 都是<strong>为了解决函数组件中遇到的特定问题</strong>。</p><p>因为函数组件首先定义了一个简单的模式来创建组件，但与此同时也暴露出了一定的问题。所以这些问题就要通过 Hooks 这样一个统一的机制去解决，可以称得上是一个非常完美的设计了。</p><p>有了这节课介绍的 4 个 Hooks，加上上节课我们学习的 useState 和 useEffect 这两个 核心Hooks，你几乎就能完成所有 React 功能的开发了。</p><p>当然，可能仍然会有一些边缘且复杂的特别场景，我们在这两节课中学习的 Hooks 并不能完全覆盖，那么我建议你可以去参考官方的 <a href=\"https://reactjs.org/docs/hooks-reference.html\">API 文档</a>，先知道 React Hooks 还有哪些能力，以便在需要的时候能够查阅文档并使用。</p><h1>思考题</h1><p>useState 其实也是能够在组件的多次渲染之间共享数据的，那么在 useRef 的计时器例子中，我们能否用 state 去保存 window.setInterval() 返回的 timer 呢？</p><p>欢迎把你的想法和思考分享在留言区，我们一起交流讨论。下节课再见！</p>","comments":[{"had_liked":false,"id":297061,"user_name":"何以解忧","can_delete":false,"product_type":"c1","uid":1915533,"ip_address":"","ucode":"4DFE2BDBAF4919","user_header":"https://static001.geekbang.org/account/avatar/00/1d/3a/8d/f5e7a20d.jpg","comment_is_top":true,"comment_ctime":1623295959,"is_pvip":true,"replies":[{"id":"107972","content":"好问题，之前在 Class 组件中可以把组件继承自 React.PureComponent，从而 props 没变就不重新 render。现在函数组件没有 PureComponent的概念，但是提供了 React.memo (https:&#47;&#47;reactjs.org&#47;docs&#47;react-api.html#reactmemo) 这样一个高阶组件，可以让任何 React 组件都能在 props 不变时就不重新渲染。所以，在开发过程中，即使现在没有使用 React.memo，但是使用 useCallback 或者 useMemo 至少可以为性能优化提供一个基础。","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1623470207,"ip_address":"","comment_id":297061,"utype":1}],"discussion_count":7,"race_medal":0,"score":"9.2233721029025997e+18","product_id":100079901,"comment_content":"关于子组件props 不变，可以减少不必要的渲染问题，不是特别理解。似乎只要父组件重新渲染子组件必然重新渲染，是内部有什么别的地方优化么？","like_count":15,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521703,"discussion_content":"好问题，之前在 Class 组件中可以把组件继承自 React.PureComponent，从而 props 没变就不重新 render。现在函数组件没有 PureComponent的概念，但是提供了 React.memo (https://reactjs.org/docs/react-api.html#reactmemo) 这样一个高阶组件，可以让任何 React 组件都能在 props 不变时就不重新渲染。所以，在开发过程中，即使现在没有使用 React.memo，但是使用 useCallback 或者 useMemo 至少可以为性能优化提供一个基础。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623470207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1397140,"avatar":"https://static001.geekbang.org/account/avatar/00/15/51/94/d667294c.jpg","nickname":"渡","note":"","ucode":"55C09E9A495BAC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383432,"discussion_content":"要说清楚这个的话，先简单说明一下React的渲染流程（以函数组件为例）：“useState()中的setXXX被调用->React遍历整个Virtual Dom并依次生成新的虚拟结点来替换旧的（新结点上会有一个指向旧结点的引用）->再次遍历Virtual Dom并找出每一个有对应原生Dom的结点，依次对比新旧结点的同名属性，若有变则修改对应原生Dom的同名属性->原生Dom重新渲染”useCallback/useMemo的优化正是作用在新旧结点的对比上，从而阻止对应原生Dom的重新渲染","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1626093716,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1555007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/3f/c2b31724.jpg","nickname":"ninja","note":"","ucode":"F15E479A5FC352","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379062,"discussion_content":"写了个demo试了下，需要同时在子组件上使用React.memo, 父组件上使用useCallback，才能优化子组件的重新渲染问题","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1623656604,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1672018,"avatar":"https://static001.geekbang.org/account/avatar/00/19/83/52/47dc4d5c.jpg","nickname":"Claus Wong","note":"","ucode":"E07685C4E7B07F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1555007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/3f/c2b31724.jpg","nickname":"ninja","note":"","ucode":"F15E479A5FC352","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380169,"discussion_content":"+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624365145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":379062,"ip_address":""},"score":380169,"extra":""},{"author":{"id":1906089,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/15/a9/001872c5.jpg","nickname":"Jason","note":"","ucode":"34FDC5D24BC8DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1555007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/3f/c2b31724.jpg","nickname":"ninja","note":"","ucode":"F15E479A5FC352","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380830,"discussion_content":"我这也写了一个demo，父组件不使用useCallback也可以。只要子组件使用React.memo就可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624718117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":379062,"ip_address":""},"score":380830,"extra":""}]},{"author":{"id":1374121,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f7/a9/c646b3d9.jpg","nickname":"幺果爸","note":"","ucode":"3A7BA87777560A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380807,"discussion_content":"为什么不默认使用memo呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1624707519,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2664142,"avatar":"","nickname":"QL","note":"","ucode":"B2EA2101793B56","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1374121,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f7/a9/c646b3d9.jpg","nickname":"幺果爸","note":"","ucode":"3A7BA87777560A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556297,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647304585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":380807,"ip_address":""},"score":556297,"extra":""}]}]},{"had_liked":false,"id":295617,"user_name":"满月","can_delete":false,"product_type":"c1","uid":1380258,"ip_address":"","ucode":"5D4F8B769E79F6","user_header":"https://static001.geekbang.org/account/avatar/00/15/0f/a2/2bb7df25.jpg","comment_is_top":false,"comment_ctime":1622515763,"is_pvip":false,"replies":[{"id":"107375","content":"100分~","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1622558815,"ip_address":"","comment_id":295617,"utype":1}],"discussion_count":3,"race_medal":0,"score":"255025586227","product_id":100079901,"comment_content":"我们能否用 state 去保存 window.setInterval() 返回的 timer 呢？<br>我理解的是可以，只是没有 useRef 更优，因为在更新 state 值后会导致重新渲染，而 ref 值发生变化时，是不会触发组件的重新渲染的，这也是 useRef 区别于 useState 的地方。","like_count":60,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521150,"discussion_content":"100分~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622558815,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1678805,"avatar":"https://static001.geekbang.org/account/avatar/00/19/9d/d5/1f3bcb2e.jpg","nickname":"微笑","note":"","ucode":"5B204327DA1CE5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382759,"discussion_content":"经过测试，ref的值是不会发生变化的，变化的是ref.current的值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625714340,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1764429,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/ec/4d/1551ed5f.jpg","nickname":"前端小猪","note":"","ucode":"DDC0F702986274","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377260,"discussion_content":"let [state,setState]=useState()\n我理解的这里通过setState改变state才会触发重新渲染，所以useRef只是语义更优","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622562158,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295632,"user_name":"桃翁","can_delete":false,"product_type":"c1","uid":1044036,"ip_address":"","ucode":"CB438AF450DC00","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/44/26ac883e.jpg","comment_is_top":false,"comment_ctime":1622522144,"is_pvip":false,"replies":[{"id":"107366","content":"useRef 可以保证这个变量只在当前组件的实例中使用。也就是说，如果一个组件页面上有多个实例，比如：<br>&lt;div&gt;&lt;Timer &#47;&gt;&lt;Timer &#47;&gt;&lt;&#47;div&gt;<br>那么组件外的普通变量是被 Timer 共享的，就会产生问题。","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1622541131,"ip_address":"","comment_id":295632,"utype":1}],"discussion_count":4,"race_medal":0,"score":"100406769952","product_id":100079901,"comment_content":"useRef 如果只是用来 在多次渲染之间共享数据，是不是直接可以把变量定义到组件外面，这样也可以达到目的，感觉还更方便一点呢。","like_count":24,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521160,"discussion_content":"useRef 可以保证这个变量只在当前组件的实例中使用。也就是说，如果一个组件页面上有多个实例，比如：\n&amp;lt;div&amp;gt;&amp;lt;Timer /&amp;gt;&amp;lt;Timer /&amp;gt;&amp;lt;/div&amp;gt;\n那么组件外的普通变量是被 Timer 共享的，就会产生问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622541131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1518638,"avatar":"https://static001.geekbang.org/account/avatar/00/17/2c/2e/9f37aaab.jpg","nickname":"一棵菜菜","note":"","ucode":"34916562728398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379316,"discussion_content":"老师，但是react是模块化开发，每个jsx就是一个模块，那么这里两个Timer相当于是两个独立空间的模块，那组件外的普通变量为什么还会共享呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623827389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1397140,"avatar":"https://static001.geekbang.org/account/avatar/00/15/51/94/d667294c.jpg","nickname":"渡","note":"","ucode":"55C09E9A495BAC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1518638,"avatar":"https://static001.geekbang.org/account/avatar/00/17/2c/2e/9f37aaab.jpg","nickname":"一棵菜菜","note":"","ucode":"34916562728398","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383427,"discussion_content":"这属于JS的范畴了。简单的说是因为这个变量没被定义在这个组件里，专业的说这就是作用域链的机制了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626091731,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":379316,"ip_address":""},"score":383427,"extra":""}]},{"author":{"id":1044036,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ee/44/26ac883e.jpg","nickname":"桃翁","note":"","ucode":"CB438AF450DC00","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378032,"discussion_content":"懂了，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623026197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":true,"id":295618,"user_name":"cyh41","can_delete":false,"product_type":"c1","uid":1387620,"ip_address":"","ucode":"8B342968050F93","user_header":"https://static001.geekbang.org/account/avatar/00/15/2c/64/2a185538.jpg","comment_is_top":false,"comment_ctime":1622515924,"is_pvip":false,"replies":[{"id":"107376","content":"确实不是，useCallback 可以减少不必要的渲染，主要体现在将回调函数作为属性传给某个组件。如果每次都不一样就会造成组件的重新渲染。但是如果你确定子组件多次渲染也没有太大问题，特别是原生的组件，比如 button，那么不用 useCallback 也问题不大。所以这和子组件的实现相关，和函数是否轻量无关。但是比较好的实践是都 useCallback。","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1622558934,"ip_address":"","comment_id":295618,"utype":1}],"discussion_count":2,"race_medal":0,"score":"61752058068","product_id":100079901,"comment_content":"是任何场景 函数都用useCallback 包裹吗？那种轻量的函数是不是不需要？","like_count":15,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521151,"discussion_content":"确实不是，useCallback 可以减少不必要的渲染，主要体现在将回调函数作为属性传给某个组件。如果每次都不一样就会造成组件的重新渲染。但是如果你确定子组件多次渲染也没有太大问题，特别是原生的组件，比如 button，那么不用 useCallback 也问题不大。所以这和子组件的实现相关，和函数是否轻量无关。但是比较好的实践是都 useCallback。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622558934,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1387826,"avatar":"https://static001.geekbang.org/account/avatar/00/15/2d/32/43595745.jpg","nickname":"鲁滨逊","note":"","ucode":"AD58F1115DF311","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576381,"discussion_content":"所以即便依赖项是空数组的时候，为了避免重复渲染还是要用 useCallback 包裹回调函数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655489474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296035,"user_name":"七月有风","can_delete":false,"product_type":"c1","uid":1439990,"ip_address":"","ucode":"B3F82397347C5B","user_header":"https://static001.geekbang.org/account/avatar/00/15/f8/f6/3e2db176.jpg","comment_is_top":false,"comment_ctime":1622712322,"is_pvip":false,"replies":[{"id":"107466","content":"是的，所以依赖比较都是浅比较","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1622728125,"ip_address":"","comment_id":296035,"utype":1}],"discussion_count":2,"race_medal":0,"score":"27392516098","product_id":100079901,"comment_content":"问下老师，useCallback、useMemo 和 useEffect的依赖机制一样吗？都是浅比较吗？","like_count":6,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521300,"discussion_content":"是的，所以依赖比较都是浅比较","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622728125,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1590682,"avatar":"https://static001.geekbang.org/account/avatar/00/18/45/9a/ba331433.jpg","nickname":"Kqiu","note":"","ucode":"A0279D0049C4C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559879,"discussion_content":"那深比较怎么做缓存呢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1649037086,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":true,"id":301242,"user_name":"陈东","can_delete":false,"product_type":"c1","uid":1140347,"ip_address":"","ucode":"6F5971D1C5376F","user_header":"https://static001.geekbang.org/account/avatar/00/11/66/7b/535144e8.jpg","comment_is_top":false,"comment_ctime":1625587252,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23100423732","product_id":100079901,"comment_content":"感觉useMemo和useCallback的demo，子组件还是需要重新渲染。除非父组件使用useMemo&#47;useCallback，同时子组件使用React.memo&#47;shouldComponentUpdate，才能避免子组件重新渲染。","like_count":6},{"had_liked":false,"id":301120,"user_name":"litchi2333333","can_delete":false,"product_type":"c1","uid":1627269,"ip_address":"","ucode":"F40FF1BBDE3DD7","user_header":"https://static001.geekbang.org/account/avatar/00/18/d4/85/f35e0422.jpg","comment_is_top":false,"comment_ctime":1625543425,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23100379905","product_id":100079901,"comment_content":"计时器的例子, 使用useCallback缓存了函数定义, 但是依旧会导致重新渲染整个render里面的子组件, 即使子组件的props等没有变化, 如果不使之渲染的话只能采用React.memo来定义缓存子组件吧? ","like_count":5},{"had_liked":false,"id":296627,"user_name":"小个子外星人：）","can_delete":false,"product_type":"c1","uid":2642842,"ip_address":"","ucode":"AC8925E536DD58","user_header":"https://static001.geekbang.org/account/avatar/00/28/53/9a/2eddfce2.jpg","comment_is_top":false,"comment_ctime":1623072191,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23097908671","product_id":100079901,"comment_content":"请问有什么react优秀项目&#47;案例，推荐学习吗？在工作中遇到关于一些业务逻辑的问题，不知道怎么实现会比较好。想看看react优秀项目学习学习，求推荐。谢谢","like_count":5},{"had_liked":false,"id":295603,"user_name":"Geek_71adef","can_delete":false,"product_type":"c1","uid":2643315,"ip_address":"","ucode":"E3CC6F6FBB1468","user_header":"","comment_is_top":false,"comment_ctime":1622509727,"is_pvip":false,"replies":[{"id":"107373","content":"只有需要触发 UI 更新的状态才需要放到 state 里。这里的 timer 其实只是临时存放一个变量，无需用 state 保存。否则会造成不必要的渲染。","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1622558744,"ip_address":"","comment_id":295603,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23097346207","product_id":100079901,"comment_content":"1 useState 实现组件共享，考虑到组件之间的通信<br>2 state 去保存的话 会造成异步渲染 造成无限循环","like_count":6,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521144,"discussion_content":"只有需要触发 UI 更新的状态才需要放到 state 里。这里的 timer 其实只是临时存放一个变量，无需用 state 保存。否则会造成不必要的渲染。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622558744,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":297276,"user_name":"院长。","can_delete":false,"product_type":"c1","uid":1153546,"ip_address":"","ucode":"DF56871F42A868","user_header":"https://static001.geekbang.org/account/avatar/00/11/9a/0a/da55228e.jpg","comment_is_top":false,"comment_ctime":1623402363,"is_pvip":false,"replies":[{"id":"107971","content":"依赖项比较大的性能开销可以忽略。useMemo 其实除了解决自身计算的性能问题之外，还有就是可以避免 接收这个数据的组件过多的重新渲染，以及依赖这个数据的其它 hooks 多余的计算。所以即使简单的计算，最好也是用 useMemo。","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1623469523,"ip_address":"","comment_id":297276,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18803271547","product_id":100079901,"comment_content":"有个问题想问下，关于useMemo，文档说的是性能优化的保证，也就是涉及到大量计算的时候可以使用，因为依赖项的比较本身也是有开销的。<br><br>那如果我就只是很简单的计算，或者就只是返回一个固定的对象，有必要使用吗","like_count":4,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521785,"discussion_content":"依赖项比较大的性能开销可以忽略。useMemo 其实除了解决自身计算的性能问题之外，还有就是可以避免 接收这个数据的组件过多的重新渲染，以及依赖这个数据的其它 hooks 多余的计算。所以即使简单的计算，最好也是用 useMemo。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623469523,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295730,"user_name":"闲闲","can_delete":false,"product_type":"c1","uid":1637571,"ip_address":"","ucode":"B2099BDCFF6191","user_header":"https://static001.geekbang.org/account/avatar/00/18/fc/c3/0991edfc.jpg","comment_is_top":false,"comment_ctime":1622562606,"is_pvip":false,"replies":[{"id":"107454","content":"没有意义，相当于每次都创建一个新的函数","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1622727384,"ip_address":"","comment_id":295730,"utype":1}],"discussion_count":6,"race_medal":0,"score":"18802431790","product_id":100079901,"comment_content":"useCallBack依赖是空数组表示什么？","like_count":4,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521197,"discussion_content":"没有意义，相当于每次都创建一个新的函数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622727384,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2178133,"avatar":"https://static001.geekbang.org/account/avatar/00/21/3c/55/74844d08.jpg","nickname":"大大小小","note":"","ucode":"8A21DC629A24F5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377623,"discussion_content":"老师的回答是不是错了？useEffect的依赖是空数组就只会执行一次，useCallBack应该也是这个效果吧，为什么说没有意义呢？我的理解是依赖空数组相当于只创建一次，再也不创建了，而不是每次都创建。","likes_number":13,"is_delete":false,"is_hidden":false,"ctime":1622732599,"is_liked":true,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1672018,"avatar":"https://static001.geekbang.org/account/avatar/00/19/83/52/47dc4d5c.jpg","nickname":"Claus Wong","note":"","ucode":"E07685C4E7B07F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380171,"discussion_content":"是在组件初始化时创建一次，后期不会再创建，老师回答的有问题","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1624365366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2876591,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/e4/af/f8cf4bc2.jpg","nickname":"Light 胖虎","note":"","ucode":"D5FCFE14172D31","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541653,"discussion_content":"老师应该是看错问题了，回答错误了，如果是空数据就在第一次渲染的时候执行一次，如果没有第二个参数的话，那么就是老师回答的问题，每次都会重新渲染","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640502705,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2030343,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/KRaFF1vD8IlFg8uD8mGRbq7c7PKWDlm1Xyicrv7BfSOSDITTHUQvmf1bGoDlDuu74yHdoacZMj7z5KxZqj5dU6Q/132","nickname":"周文硕","note":"","ucode":"2676F46BC4D52F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408464,"discussion_content":"可能老师看错问题了，以为说依赖是空吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635251104,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1282777,"avatar":"https://static001.geekbang.org/account/avatar/00/13/92/d9/84c1de45.jpg","nickname":"傻子来了快跑丶","note":"","ucode":"662624121A1DFA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377420,"discussion_content":"render后代码逻辑只执行一次，相当于componentDidmount","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622638604,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320212,"user_name":"豆浆油条","can_delete":false,"product_type":"c1","uid":1378413,"ip_address":"","ucode":"466635EE57AA6E","user_header":"","comment_is_top":false,"comment_ctime":1636128517,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10226063109","product_id":100079901,"comment_content":"我在网上看到说useCallBack最好不要频繁使用，因为每次要执行对比，比重新创建一个函数消耗要高，老师这是不是和你说的函数都用useCallBack缓存冲突了。","like_count":3,"discussions":[{"author":{"id":1001556,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/54/710626c2.jpg","nickname":"Jinjing Wu","note":"","ucode":"0848B436C64D87","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577964,"discussion_content":"重新创建函数，即是重新分配内在空间，不可能做到比现有内存空间内数据的比较还快的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656433413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2542956,"avatar":"https://static001.geekbang.org/account/avatar/00/26/cd/6c/ee607d3a.jpg","nickname":"Andy","note":"","ucode":"51060AA941D229","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575494,"discussion_content":"同问\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654883559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":334921,"user_name":"Zeal","can_delete":false,"product_type":"c1","uid":2872628,"ip_address":"","ucode":"5322FAF88C7DFD","user_header":"https://static001.geekbang.org/account/avatar/00/2b/d5/34/10df391a.jpg","comment_is_top":false,"comment_ctime":1645183574,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5940150870","product_id":100079901,"comment_content":"useCallback的用处应该在于利用memoize减少不必要的子组件的重新渲染问题，而不是函数组件过多内部函数的问题。","like_count":1},{"had_liked":false,"id":317970,"user_name":"天天","can_delete":false,"product_type":"c1","uid":2000254,"ip_address":"","ucode":"2B9414A72EB338","user_header":"https://static001.geekbang.org/account/avatar/00/1e/85/7e/dc5ee66c.jpg","comment_is_top":false,"comment_ctime":1635079556,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5930046852","product_id":100079901,"comment_content":"“比如 Redux，正是利用了 Context 的机制来提供一种更加可控的组件之间的状态管理机制。因此，理解 Context 的机制，也可以让我们更好地去理解 Redux 这样的框架实现的原理。”<br><br>老师上面这段话，我觉得不太对，redux 是通过connect来做的，connect 是一个高级函数，内部有一个 setState的来改变被包装组件的props来刷新子组件的，不是context的做法。<br><br>只是他们的思想比较像","like_count":1},{"had_liked":false,"id":305930,"user_name":"半夏","can_delete":false,"product_type":"c1","uid":1232197,"ip_address":"","ucode":"2E06D5323096C8","user_header":"https://static001.geekbang.org/account/avatar/00/12/cd/45/15d2f59e.jpg","comment_is_top":false,"comment_ctime":1628234872,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5923202168","product_id":100079901,"comment_content":"想问一下老师，对于作为html节点属性的函数或者对象是否应该去缓存<br>```<br>function Test(props) {<br>\tconst [count, setCount] = useState(0);<br><br>\t&#47;&#47; 第一种方式，直接创建handleClick1<br>\tconst handleClick1 = () =&gt;{<br>\t\tconsole.log(&quot;方式一&quot;);<br>\t}<br><br>\t&#47;&#47; 第二种方式，创建用useCallback包裹的handleClick1<br>\t&#47;&#47; const handleClick1 = useCallback(()=&gt;{<br>\t&#47;&#47;\tconsole.log(&quot;方式二&quot;)<br>\t&#47;&#47; },[]);<br><br>return &lt;div&gt;<br>\t\t\t\t\t&lt;div onClick={handleClick1}&gt;1111&lt;&#47;div&gt;<br>\t\t\t\t\t&lt;span&gt;{count}&lt;&#47;span&gt;<br>\t\t\t\t\t&lt;button onClick={()=&gt;setCount(count + 1)}&gt;add count&lt;&#47;button&gt;<br>\t\t\t &lt;&#47;div&gt;<br>}<br>```<br>个人认为在setCount的时候，组件触发重绘，handleClick1也会重新被创建；<br>1. 如果直接创建handleClick1的话，react在对比的时候就会认为它和之前绑定的函数不一致了，需要更新，这里会有性能损耗；<br>2. 如果用useCallback去缓存的话，虽然useCallback缓存时也会有性能损失，但是在后面渲染阶段react对比的时候每次用的handleClick1就都是旧的，这里就可以省掉后面的更新处理，节省性能；<br>不知道在这种情况下是应该直接定义，还是去创建一个依赖项为空的缓存值更好","like_count":1},{"had_liked":true,"id":296410,"user_name":"开开之之","can_delete":false,"product_type":"c1","uid":1152069,"ip_address":"","ucode":"2B7FC13D6F32C4","user_header":"https://static001.geekbang.org/account/avatar/00/11/94/45/7ea3dd47.jpg","comment_is_top":false,"comment_ctime":1622964643,"is_pvip":false,"replies":[{"id":"107947","content":"你这个写法，看上去能够 work 是因为 handleStop 没有将 timer2 设为依赖项，eslint 会报错。其实在你第二次 start 后就无法 stop 了。因为 timer 一直是第一次的值。","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1623388496,"ip_address":"","comment_id":296410,"utype":1}],"discussion_count":5,"race_medal":0,"score":"5917931939","product_id":100079901,"comment_content":"老师，我也有同样的疑问，定时器的例子，不能用一个常量去保存吗？<br>import React, { useState, useCallback, useRef } from &#39;react&#39;<br><br>export default function Timer() {<br>  const [time, setTime] = useState(0)<br>  const timer = useRef(null)<br><br>  let timer2 = null<br><br>  const handleStart = useCallback(() =&gt; {<br>    timer2 = window.setInterval(() =&gt; {<br>      &#47;&#47; 这里是个闭包，每次拿到的time值是0，所以要这样写手动去更新time的值<br>      setTime((time) =&gt; time + 1)<br>    }, 1000)<br>  }, [time])<br><br>  const handleStop = useCallback(() =&gt; {<br>    window.clearInterval(timer2)<br>    timer2 = null<br>  }, [])<br><br>  return (<br>    &lt;div&gt;<br>      {time &#47; 10} seconds.<br>      &lt;br&#47;&gt;<br>      &lt;button onClick={handleStart}&gt;start&lt;&#47;button&gt;<br>      &lt;button onClick={handleStop}&gt;stop&lt;&#47;button&gt;<br>    &lt;&#47;div&gt;<br>  )<br>}","like_count":2,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521431,"discussion_content":"你这个写法，看上去能够 work 是因为 handleStop 没有将 timer2 设为依赖项，eslint 会报错。其实在你第二次 start 后就无法 stop 了。因为 timer 一直是第一次的值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623388496,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1110607,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f2/4f/59bd4141.jpg","nickname":"Isaac","note":"","ucode":"038C349AB508AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378109,"discussion_content":"1. 首先，可以用常量去保存，但是需要注意不推荐，因为这样做局限性非常大。\n2. 你这个例子有问题，  let timer2 = null 不应该写在组件内(function) ，因此每次 React 更新都会调用这个组件，也就是会重新调用这个 function，导致 timer2 每次都会被赋值为 null，所以如果非要使用这种方式，需要将 let timer2 = null 写在函数体外。\n3. 回到第一点，为什么会有局限性，因为如果该自定义 hook 在多个组件实例中使用，就会导致多个实例引用的 timer 都是同一个，而不是独立的。具体可以参考这个 DEMO：https://codesandbox.io/s/zhijieshiyongchangliangtidai-useref-dejuxianxing-kyptw?file=/src/App.tsx","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1623057235,"is_liked":true,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1152069,"avatar":"https://static001.geekbang.org/account/avatar/00/11/94/45/7ea3dd47.jpg","nickname":"开开之之","note":"","ucode":"2B7FC13D6F32C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1110607,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f2/4f/59bd4141.jpg","nickname":"Isaac","note":"","ucode":"038C349AB508AB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378174,"discussion_content":"谢谢你的解答~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623078494,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":378109,"ip_address":""},"score":378174,"extra":""},{"author":{"id":1676455,"avatar":"https://static001.geekbang.org/account/avatar/00/19/94/a7/43c1efaa.jpg","nickname":"笨重的企鹅","note":"","ucode":"416803E12D5829","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1110607,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f2/4f/59bd4141.jpg","nickname":"Isaac","note":"","ucode":"038C349AB508AB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383834,"discussion_content":"这个回复让我茅塞顿开！谢谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626250603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":378109,"ip_address":""},"score":383834,"extra":""},{"author":{"id":1387826,"avatar":"https://static001.geekbang.org/account/avatar/00/15/2d/32/43595745.jpg","nickname":"鲁滨逊","note":"","ucode":"AD58F1115DF311","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1110607,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f2/4f/59bd4141.jpg","nickname":"Isaac","note":"","ucode":"038C349AB508AB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576382,"discussion_content":"写在外面也有问题，每次 time 变化执行 effect，新开一个 interval, timer2 每次都能拿到最新的 intarval，但是 stop 的时候 timer 还是闭包里面第一次的值啊。 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655489984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":378109,"ip_address":""},"score":576382,"extra":""}]}]},{"had_liked":false,"id":296069,"user_name":"琼斯基亚","can_delete":false,"product_type":"c1","uid":2311402,"ip_address":"","ucode":"24892258DF0CC2","user_header":"https://static001.geekbang.org/account/avatar/00/23/44/ea/8a9b868d.jpg","comment_is_top":false,"comment_ctime":1622729810,"is_pvip":false,"replies":[{"id":"107737","content":"严格来说，后者确实优于前者，因为后者在 count 变化时不会创建新的 handleIncrement 这样的 callback，这样接收这个属性的组件就不需要重新刷新。但是对于简单的场景，可以忽略这种差异。","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1623081143,"ip_address":"","comment_id":296069,"utype":1}],"discussion_count":4,"race_medal":0,"score":"5917697106","product_id":100079901,"comment_content":"老师，请问：<br>const handleIncrement = useCallback(() =&gt; setCount(count + 1), [count]);<br>const handleIncrement = useCallback(() =&gt; setCount(q =&gt; q + 1), []);<br>在性能方面是否后者优于前者？我的理解：<br>后者只创建了一次函数，但是又调用了多次在setCount的回调函数<br>前者只会在count变化的时候创建新的回调函数<br>这样分析下来我又觉得两者没什么差异<br>我不是太清楚这两者的优缺点，希望得到老师的解答。","like_count":1,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521310,"discussion_content":"严格来说，后者确实优于前者，因为后者在 count 变化时不会创建新的 handleIncrement 这样的 callback，这样接收这个属性的组件就不需要重新刷新。但是对于简单的场景，可以忽略这种差异。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623081143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1200119,"avatar":"https://static001.geekbang.org/account/avatar/00/12/4f/f7/0c4c107b.jpg","nickname":"黄明星","note":"","ucode":"E031900C8A281E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384067,"discussion_content":"第二种写法的问题是：因为闭包的原因，q的值永远都是最初的那个值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626349137,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1672018,"avatar":"https://static001.geekbang.org/account/avatar/00/19/83/52/47dc4d5c.jpg","nickname":"Claus Wong","note":"","ucode":"E07685C4E7B07F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380177,"discussion_content":"count值从后端获取后，单独走setCount(apiCount)啊？而且因为[]空依赖，也不会重新创建handleIncrement函数，有什么bug呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624366298,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1152069,"avatar":"https://static001.geekbang.org/account/avatar/00/11/94/45/7ea3dd47.jpg","nickname":"开开之之","note":"","ucode":"2B7FC13D6F32C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377852,"discussion_content":"分享一下我的看法。在这个计数器例子里，可能感受不到区别，因为点击的时候会触发handleIncrement。但是如果有其他的外部机制去改变count，比如count的值从后端获取，那么这个时候，第二种写法就不会触发组件的重新render，有bug啦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622908002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296006,"user_name":"Isaac","can_delete":false,"product_type":"c1","uid":1110607,"ip_address":"","ucode":"038C349AB508AB","user_header":"https://static001.geekbang.org/account/avatar/00/10/f2/4f/59bd4141.jpg","comment_is_top":false,"comment_ctime":1622701221,"is_pvip":false,"replies":[{"id":"107464","content":"是的，这种问题不大，因为 button 没有子节点，性能问题可以忽略。要避免的话就是用 useCallback。参数的话是可以在 useCallback 里处理的。","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1622728062,"ip_address":"","comment_id":296006,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5917668517","product_id":100079901,"comment_content":"&lt;button onClick={() =&gt; handleClick(&#39;hi&#39;)}&gt;&lt;&#47;button&gt;<br><br>老师，上面这种写法，直接将箭头函数作为 props 传递给 button，是不是每次 render 的时候，也会生成一个新的箭头函数？<br><br>如果是的话，怎么避免呢？","like_count":1,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521293,"discussion_content":"是的，这种问题不大，因为 button 没有子节点，性能问题可以忽略。要避免的话就是用 useCallback。参数的话是可以在 useCallback 里处理的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622728062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1036154,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cf/7a/3c37260a.jpg","nickname":"竹杖","note":"","ucode":"F9BF97BDC1252A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377539,"discussion_content":"我也有类似的疑问，不知道是不是应该使用useCallback包裹下 handleClick，再把 &#39;hi&#39;放进 state hi 内， const handler = useCallback(()=>handleClick,[hi])。希望老师或同学给个解法或者说明下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622703814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1110607,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f2/4f/59bd4141.jpg","nickname":"Isaac","note":"","ucode":"038C349AB508AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1036154,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cf/7a/3c37260a.jpg","nickname":"竹杖","note":"","ucode":"F9BF97BDC1252A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377699,"discussion_content":"嗯嗯，根据老师的回答，我理解的是如果要避免这种情况，需要使用 useCallback。不过你这里举的例子可能有些问题。\n在 for 循环的场景下，有些参数是需要从 每次循环去取的，所以不能直接将 useCallback 赋值给一个变量，必须要写成如下形式：\nlist.map(item => {\n  return <button\n    onClick={useCallback(() => handleClick(item), [])}\n  >\n    click\n  </button>\n}\n也就是说，需要将 useCallback 写在标签上。\n\n但是总感觉这种方式并不优雅。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622780331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":377539,"ip_address":""},"score":377699,"extra":""}]}]},{"had_liked":false,"id":295625,"user_name":"Sunny","can_delete":false,"product_type":"c1","uid":1122308,"ip_address":"","ucode":"90CA0ABBB683FA","user_header":"https://static001.geekbang.org/account/avatar/00/11/20/04/72cc2057.jpg","comment_is_top":false,"comment_ctime":1622519145,"is_pvip":false,"replies":[{"id":"107378","content":"因为点击 start 的时候，window.setInterval 用的 setIntervalCallback 这个函数已经是确定的了。之后 state 的变化并不会导致 setInterval 接收的函数换一个。所以一直是当时闭包里的 state.time = 0 ","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1622559285,"ip_address":"","comment_id":295625,"utype":1}],"discussion_count":4,"race_medal":0,"score":"5917486441","product_id":100079901,"comment_content":"import React, {<br>  useCallback,<br>  useRef,<br>  useReducer,<br>} from &#39;react&#39;;<br><br>const initialState = {time: 0};<br>function reducer(state, action) {<br>  switch (action.type) {<br>    case &#39;increment&#39;:<br>      return {time: state.time + 1};<br>    default:<br>      throw new Error();<br>  }<br>}<br><br>export default function Timer() {<br>  console.log(&#39;--render--&#39;)<br><br>  const [state, dispatch] = useReducer(reducer, initialState);<br>  <br>  const timer = useRef(null);<br><br>  const setIntervalCallback = useCallback( () =&gt; {<br>    dispatch({type: &#39;increment&#39;});<br>    console.log(&#39;setinterval time:&#39;, state.time)  &#47;&#47;为什么这里的state.time不变？<br>  }, [state.time]);&#47;&#47;这里的state.time变化被监听到了<br><br>  const handleStart = useCallback(() =&gt; {<br>    console.log(&#39;handlestart&#39;)<br>    timer.current = window.setInterval(setIntervalCallback, 1000);<br>  }, [timer, setIntervalCallback]);<br>  <br>  const handlePause = useCallback(() =&gt; {<br>    console.log(&#39;handlePause&#39;)<br>    window.clearInterval(timer.current);<br>    timer.current = null;    <br>  }, [timer]);<br>  <br>  return(<br>    &lt;div&gt;<br>      {state.time} seconds.<br>      &lt;MyStartBtn handleStart={handleStart}&#47;&gt;<br>      &lt;MyPauseBtn handlePause={handlePause}&#47;&gt;<br>    &lt;&#47;div&gt;<br>  );<br>}<br><br>function StartButton({handleStart}){<br>  console.log(&#39;startButton render --&#39;)<br>  return &lt;button onClick={handleStart}&gt;Start&lt;&#47;button&gt;;<br>}<br>const MyStartBtn = React.memo(StartButton, (prevProps, nextProps) =&gt; {<br>  return prevProps.handleStart === nextProps.handleStart;<br>});<br><br>function PauseButton({handlePause}){<br>  console.log(&#39;pauseButton render --&#39;)<br>  return &lt;button onClick={handlePause}&gt;Pause&lt;&#47;button&gt;;<br>}<br>const MyPauseBtn = React.memo( PauseButton, (prev, next) =&gt; {<br>  return prev.handlePause === next.handlePause;<br>})<br><br>&#47;*<br>console.log打印结果：<br>--render--<br>startButton render --<br>setinterval time: 0<br>每秒循环打印上面3行...<br><br><br>疑问：<br>const setIntervalCallback = useCallback( () =&gt; {<br>    dispatch({type: &#39;increment&#39;});<br>    console.log(&#39;setinterval time:&#39;, state.time)  &#47;&#47;为什么这里的state.time不变？<br>  }, [state.time]);&#47;&#47;这里的state.time变化被监听到了<br>*&#47;","like_count":1,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521156,"discussion_content":"因为点击 start 的时候，window.setInterval 用的 setIntervalCallback 这个函数已经是确定的了。之后 state 的变化并不会导致 setInterval 接收的函数换一个。所以一直是当时闭包里的 state.time = 0 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622559285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2819061,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/03/f5/ed243c62.jpg","nickname":"搁浅","note":"","ucode":"351D5C13345B5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583047,"discussion_content":"依赖是变了，然后 setIntervalCallback 也会返回新的函数，只不过对于已经执行的 setInterval 来说，执行的是第一次的 setIntervalCallback，而对于后面新生成的 setIntervalCallback，只有重新点击 start 按钮，才会获取。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659883194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"福建"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1518638,"avatar":"https://static001.geekbang.org/account/avatar/00/17/2c/2e/9f37aaab.jpg","nickname":"一棵菜菜","note":"","ucode":"34916562728398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379416,"discussion_content":"你好，我还是不太理解，当dispatch 修改了state.time后，setIntervalCallback 函数不是会检测到依赖有更新然后创建新函数吗（其内的state.time不也应该是最新的了吗）？然后 handleStart 函数也检测到依赖更新也创建新函数，那么这时候setInterval都是新的，它的回调函数也应该是最新的呀？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623893653,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1122308,"avatar":"https://static001.geekbang.org/account/avatar/00/11/20/04/72cc2057.jpg","nickname":"Sunny","note":"","ucode":"90CA0ABBB683FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377314,"discussion_content":"我还是对js闭包原理的理解不够清晰，谢谢老师的细致答疑！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622600808,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":349722,"user_name":"栓拴","can_delete":false,"product_type":"c1","uid":3035493,"ip_address":"","ucode":"8DC31F43D125E6","user_header":"https://static001.geekbang.org/account/avatar/00/2e/51/65/609b1215.jpg","comment_is_top":false,"comment_ctime":1656266347,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1656266347","product_id":100079901,"comment_content":"使用state保存下来的timer貌似是被包装过的，并不能直接通过window.clearInterval()来清楚计时器。","like_count":0},{"had_liked":false,"id":348762,"user_name":"Iggy_TheFool","can_delete":false,"product_type":"c1","uid":2152160,"ip_address":"","ucode":"BD44301B621563","user_header":"https://static001.geekbang.org/account/avatar/00/20/d6/e0/ea7f89f6.jpg","comment_is_top":false,"comment_ctime":1655372688,"is_pvip":false,"discussion_count":0,"race_medal":2,"score":"1655372688","product_id":100079901,"comment_content":"我不同意 redux 比原生 context 更适合做数据共享这个观点。<br>context 固然可以放在全局，但是它也可以应用于局部。传统开发模式会使用 redux 为局部组件甚至全局作状态管理，而现在随着 hook 的兴起，我们完全可以使用自定义 hook 和原生 hook 作状态管理。<br>这样做的优势在于在完成原有功能时整个运行流程全都依赖 react 本身的实现，不必引入第三方库增加认知成本和项目成本。<br>文中提到的“引入变量不明确”也是可以规避的，hook 使用 context 会依赖 useContext，传入的 Context 没有指明数据来源吗？","like_count":0},{"had_liked":false,"id":346763,"user_name":"01","can_delete":false,"product_type":"c1","uid":1120612,"ip_address":"","ucode":"3229D8F060AFEC","user_header":"https://static001.geekbang.org/account/avatar/00/11/19/64/6f2b7b86.jpg","comment_is_top":false,"comment_ctime":1653405274,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1653405274","product_id":100079901,"comment_content":"usecb 是配合PureComponent、memo 等使用的。 单纯使用usecb 论性能优化是不对的","like_count":0},{"had_liked":false,"id":346530,"user_name":"Ran","can_delete":false,"product_type":"c1","uid":1337147,"ip_address":"","ucode":"9DC94DACBA0765","user_header":"https://static001.geekbang.org/account/avatar/00/14/67/3b/d567e79a.jpg","comment_is_top":false,"comment_ctime":1653216467,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1653216467","product_id":100079901,"comment_content":"老师，我有个疑问：比如我有一个 callback, 依赖里有一些引用对象（比如类实力等），在回调内部有setState的操作，同时调用这个回调的方式是放在 useEffect 内部，依赖是这个callback本身。<br>我对比了下，如果移除callback内部的 setState 语句，貌似会减少re-render，反之，会增加重新渲染。<br>请问这个情况有什么比较好的办法减少重复渲染呢？","like_count":0},{"had_liked":false,"id":339784,"user_name":"Ran","can_delete":false,"product_type":"c1","uid":1337147,"ip_address":"","ucode":"9DC94DACBA0765","user_header":"https://static001.geekbang.org/account/avatar/00/14/67/3b/d567e79a.jpg","comment_is_top":false,"comment_ctime":1648378852,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1648378852","product_id":100079901,"comment_content":"useRef 和 useState 貌似都不能跨组件共享数据，useContext 可以，但是貌似只能用在函数组件中（因为要从父组件以上）继承（共享）属性。<br>那么如果我需要有个地方保存全局的登录状态，并且需要在useLogin 的自定义hooks中查询这个登陆状态的话，是不是只能用 redux （useSelect) 这种方案了呢？","like_count":0},{"had_liked":false,"id":336281,"user_name":"pencilCool","can_delete":false,"product_type":"c1","uid":1461770,"ip_address":"","ucode":"49A9FE2DEE2911","user_header":"https://static001.geekbang.org/account/avatar/00/16/4e/0a/0ff15eaa.jpg","comment_is_top":false,"comment_ctime":1646049502,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646049502","product_id":100079901,"comment_content":"useCallback 的功能示例<br>import React, { useState,useCallback } from &#39;react&#39;;<br><br>function MyCacheBtn(props) {<br>  console.log(&quot;my button render&quot;)<br>  return  &lt;button onClick={props.onClick}&gt;<br>              +<br>        &lt;&#47;button&gt;<br>}<br>export default function App() {<br>  const [count, setCount] = useState(0);<br>  const handleIncrement = () =&gt; setCount(count+1);<br>  <br>  &#47;&#47; const handleIncrement2 = () =&gt; {<br>  &#47;&#47;   console.log(&quot;hello &quot;)<br>  &#47;&#47; } <br><br>  const handleIncrement2 = useCallback(<br>    console.log(&quot;hello&quot;)<br>  );<br><br><br>  return (<br>    &lt;div&gt;<br>      &lt;p&gt;{count}&lt;&#47;p&gt;<br>      &lt;MyCacheBtn onClick={handleIncrement}&gt;<br>        &lt;&#47;MyCacheBtn&gt;<br>      &lt;MyCacheBtn onClick={handleIncrement2}&gt;<br>      &lt;&#47;MyCacheBtn&gt;<br>    &lt;&#47;div&gt;<br>  );<br>}","like_count":0},{"had_liked":false,"id":328049,"user_name":"Light 胖虎","can_delete":false,"product_type":"c1","uid":2876591,"ip_address":"","ucode":"D5FCFE14172D31","user_header":"https://static001.geekbang.org/account/avatar/00/2b/e4/af/f8cf4bc2.jpg","comment_is_top":false,"comment_ctime":1640502412,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640502412","product_id":100079901,"comment_content":"老师好，我认为用state是可以保存计数器返回的timer的，但是不建议这么使用， 因为如果每次变化都要setState（）的话那么页面都会重新渲染一遍，随意不建议这样使用","like_count":0},{"had_liked":false,"id":327827,"user_name":"myy5796","can_delete":false,"product_type":"c1","uid":1930884,"ip_address":"","ucode":"753DE88F008457","user_header":"","comment_is_top":false,"comment_ctime":1640318138,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1640318138","product_id":100079901,"comment_content":"测试了一下，useCallback即使设置了依赖项，引用callback作为属性的子组件依然会重新渲染。","like_count":0},{"had_liked":false,"id":324256,"user_name":"王冰(891805)","can_delete":false,"product_type":"c1","uid":2842128,"ip_address":"","ucode":"31CCE736E964C9","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/ajNVdqHZLLDMEbB8lPTwXrw1GOKia2Ru6bhNzZUelMdtQZgzXfMH5ZwRu2UIYOgsmTvz1RUFiaH5vTwDfVMKQa4A/132","comment_is_top":false,"comment_ctime":1638349899,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638349899","product_id":100079901,"comment_content":"可以，但是性能会差","like_count":0},{"had_liked":false,"id":316579,"user_name":"郭纯","can_delete":false,"product_type":"c1","uid":1314521,"ip_address":"","ucode":"2613860B4642C4","user_header":"https://static001.geekbang.org/account/avatar/00/14/0e/d9/e61ce097.jpg","comment_is_top":false,"comment_ctime":1634399895,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634399895","product_id":100079901,"comment_content":"const foo = useRef() 如果组件重新渲染每一回的 foo 都是同一个值吗","like_count":0},{"had_liked":false,"id":312034,"user_name":"李克勤","can_delete":false,"product_type":"c1","uid":2660079,"ip_address":"","ucode":"78917017E984FB","user_header":"","comment_is_top":false,"comment_ctime":1631599809,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631599809","product_id":100079901,"comment_content":"可以是可以，但是只会白白增加无用的渲染","like_count":0},{"had_liked":false,"id":311621,"user_name":"严凯治","can_delete":false,"product_type":"c1","uid":2581989,"ip_address":"","ucode":"4834ECD65D8CBA","user_header":"","comment_is_top":false,"comment_ctime":1631346835,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631346835","product_id":100079901,"comment_content":"老师，我有一个问题，我的理解是 useCallback 本身并不能避免在组件每次渲染的时候重新创建回调函数，useCallback 只是会在比较依赖项决定后返回新创建的函数还是旧函数","like_count":0},{"had_liked":false,"id":305720,"user_name":"快扶我起来学习","can_delete":false,"product_type":"c1","uid":2644202,"ip_address":"","ucode":"204C1D70D79D4B","user_header":"","comment_is_top":false,"comment_ctime":1628132750,"is_pvip":false,"replies":[{"id":"110624","content":"这个是初始值，如果你之后赋值了那么也是能work 的。","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1628154524,"ip_address":"","comment_id":305720,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1628132750","product_id":100079901,"comment_content":"const ThemeContext = React.createContext(themes.light);  这里的themes. Light参数有什么作用呢？我传null也正常work了<br>","like_count":0,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524493,"discussion_content":"这个是初始值，如果你之后赋值了那么也是能work 的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628154524,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":305048,"user_name":"花儿与少年","can_delete":false,"product_type":"c1","uid":1046304,"ip_address":"","ucode":"E2D685737E4F1B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/20/e2dfa9c2.jpg","comment_is_top":false,"comment_ctime":1627789969,"is_pvip":false,"replies":[{"id":"110354","content":"是的，用到的地方都需要引入这个 ThemeContext。","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1627820380,"ip_address":"","comment_id":305048,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1627789969","product_id":100079901,"comment_content":"useContext的官方例子中，子组件中 const theme = useContext(ThemeContext);  那是需要子组件 引用ThemeContext 这个变量吗， 实际开发中这个子组件可能是单独的一个jsx文件，需要每个用到的子组件 import 这个变量？","like_count":0,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524258,"discussion_content":"是的，用到的地方都需要引入这个 ThemeContext。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627820380,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1046304,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f7/20/e2dfa9c2.jpg","nickname":"花儿与少年","note":"","ucode":"E2D685737E4F1B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386822,"discussion_content":"好的，多谢回答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627820438,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":304861,"user_name":"rookielink","can_delete":false,"product_type":"c1","uid":2704810,"ip_address":"","ucode":"23B6E9F2D1D34D","user_header":"","comment_is_top":false,"comment_ctime":1627644734,"is_pvip":true,"replies":[{"id":"110285","content":"useRef 可以在一个组件实例的多次函数执行之间保存状态。","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1627698782,"ip_address":"","comment_id":304861,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1627644734","product_id":100079901,"comment_content":"useRef示例中替换这个有什么区别呢？ <br>const timer = useRef(null);  =&gt;  const timer = {}; ","like_count":0,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524189,"discussion_content":"useRef 可以在一个组件实例的多次函数执行之间保存状态。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627698782,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":299665,"user_name":"zzz","can_delete":false,"product_type":"c1","uid":2672273,"ip_address":"","ucode":"7CE7975DF49558","user_header":"","comment_is_top":false,"comment_ctime":1624786799,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624786799","product_id":100079901,"comment_content":"可以的，state保存timer,会重新render,而此时我们只需要数据发生变化时render，所以此时用useRef只有数据发生变化时，才会render","like_count":0},{"had_liked":false,"id":299560,"user_name":"幺果爸","can_delete":false,"product_type":"c1","uid":1374121,"ip_address":"","ucode":"3A7BA87777560A","user_header":"https://static001.geekbang.org/account/avatar/00/14/f7/a9/c646b3d9.jpg","comment_is_top":false,"comment_ctime":1624708121,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1624708121","product_id":100079901,"comment_content":"老师好，我在使用自定义hooks时碰到一个问题，我想实现一个全局loading的管理，key:value形式，使用useState保持状态，其他hooks里都调用这个hooks保存loading状态，在页面的useEffect中使用时，只有一个异步调用时没问题，如果同时有两个调用，只会响应后一个。这可能跟useState是异步响应有关吧？怎么能解决呢？尝试用useRef但是页面不刷新，同样不能传递最后状态给页面。","like_count":0,"discussions":[{"author":{"id":1374121,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f7/a9/c646b3d9.jpg","nickname":"幺果爸","note":"","ucode":"3A7BA87777560A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380875,"discussion_content":"用useReducer解决了这个问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624769399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":298517,"user_name":"H","can_delete":false,"product_type":"c1","uid":2036145,"ip_address":"","ucode":"99558A1CF3DF4F","user_header":"https://static001.geekbang.org/account/avatar/00/1f/11/b1/4379e143.jpg","comment_is_top":false,"comment_ctime":1624168479,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1624168479","product_id":100079901,"comment_content":"老师，这篇文章又读了一遍，产生了一些疑问：<br>1：既然useRef()可以被看成是在函数之外开创一个额外的空间来达到缓存，是不是其它的hook也具有缓存功能且可以看成是在函数之外开辟新的空间。<br><br>2：缓存的功能是怎么实现的，如果是通过在函数外开辟新的空间，那还有没有其它方法可以达到缓存效果。<br><br>3：请问老师什么时候开一门关于react源码解读的课程啊，很期待呢。","like_count":0,"discussions":[{"author":{"id":1672018,"avatar":"https://static001.geekbang.org/account/avatar/00/19/83/52/47dc4d5c.jpg","nickname":"Claus Wong","note":"","ucode":"E07685C4E7B07F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380178,"discussion_content":"也就是当前一个作用域下指针或内存，你可以把useRef看作class类组件的this变种，因为function组件没有this的概念，所以用useRef代替","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1624366442,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":298180,"user_name":"重生","can_delete":false,"product_type":"c1","uid":1173049,"ip_address":"","ucode":"8ABFEAD785184A","user_header":"https://static001.geekbang.org/account/avatar/00/11/e6/39/16208644.jpg","comment_is_top":false,"comment_ctime":1623936215,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1623936215","product_id":100079901,"comment_content":"只有当 count 发生变化时，才会重新创建回调函数?那回调执行被执行后count肯定会发生变化，回调函数还不是被重新创建了么","like_count":0,"discussions":[{"author":{"id":1672018,"avatar":"https://static001.geekbang.org/account/avatar/00/19/83/52/47dc4d5c.jpg","nickname":"Claus Wong","note":"","ucode":"E07685C4E7B07F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380231,"discussion_content":"老师举的例子没有针对特别合适的业务场景，只是按技术说技术，就像下面同学说的，多个state时，我只对这个state有依赖，那其它state改变就不会重新创建实例了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1624402645,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1385324,"avatar":"https://static001.geekbang.org/account/avatar/00/15/23/6c/e5a88f14.jpg","nickname":"胡哥有话说","note":"","ucode":"5046D968D448E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380082,"discussion_content":"你可以考虑这样的情况：在这个组件中有很多个state，其他state变化时，count并没有发生变化，此时这个useCallback就没有重新创建，这就是优化了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1624332805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":298027,"user_name":"一棵菜菜","can_delete":false,"product_type":"c1","uid":1518638,"ip_address":"","ucode":"34916562728398","user_header":"https://static001.geekbang.org/account/avatar/00/17/2c/2e/9f37aaab.jpg","comment_is_top":false,"comment_ctime":1623893456,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1623893456","product_id":100079901,"comment_content":"老师，如果切换主题的按钮嵌套在很深的子组件中，那么 toggleTheme 这个函数只能通过props的方式一层层往下传递，然后在那个子组建中调用，对吗？","like_count":0,"discussions":[{"author":{"id":1672018,"avatar":"https://static001.geekbang.org/account/avatar/00/19/83/52/47dc4d5c.jpg","nickname":"Claus Wong","note":"","ucode":"E07685C4E7B07F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380232,"discussion_content":"直接导出 export const xxx = createContext(&#39;xxx&#39;)，在你所要应用的子组件import {xxx} from &#39;./xxx&#39;","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1624402773,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1359476,"avatar":"https://static001.geekbang.org/account/avatar/00/14/be/74/0d900ed9.jpg","nickname":"Tristan","note":"","ucode":"DC454E16AAA66A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1672018,"avatar":"https://static001.geekbang.org/account/avatar/00/19/83/52/47dc4d5c.jpg","nickname":"Claus Wong","note":"","ucode":"E07685C4E7B07F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386268,"discussion_content":"你要不出个课程，我见你的回答都挺好的，大佬，出个react+hooks+ts课程啥的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627486909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":380232,"ip_address":""},"score":386268,"extra":""}]}]},{"had_liked":false,"id":297543,"user_name":"健牌哥.","can_delete":false,"product_type":"c1","uid":1374132,"ip_address":"","ucode":"671B0247FFF223","user_header":"https://static001.geekbang.org/account/avatar/00/14/f7/b4/d0a6c7d2.jpg","comment_is_top":false,"comment_ctime":1623608533,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623608533","product_id":100079901,"comment_content":"如果一个组件内有大量的useCallback回调函数，对组件性能是否会有反效果呢？","like_count":0},{"had_liked":false,"id":297440,"user_name":"123231","can_delete":false,"product_type":"c1","uid":1563968,"ip_address":"","ucode":"261F4048195F61","user_header":"https://static001.geekbang.org/account/avatar/00/17/dd/40/7eca8b3d.jpg","comment_is_top":false,"comment_ctime":1623552163,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1623552163","product_id":100079901,"comment_content":"老师，你好，请教一个问题，如果一个函数中很多子函数需要通过proops中传入的一个常量。<br><br>我之前的做法，避免每次在子函数中解构取一次常量，就会在主函数里做一个整体的取值。<br>这样的好处是：写法上轻便了很多，只需一次申明就行；坏处是：函数每次执行，都会创建常量，猜测会影响性能？<br><br>const componentA = (props) =&gt; {<br>  const {a={}} = props;<br>  const {b,c} = a;<br>  <br>  const fnA = () =&gt; {<br>    &#47;&#47; 引用b 和 c常量<br>  }<br>  <br>  const fnB = () =&gt; {<br>    &#47;&#47; 引用b常量<br>  }<br>  <br>  const fnC = () =&gt; {<br>    &#47;&#47; 引用c常量<br>  }        <br>  <br>}<br><br>请问，有什么好的解决方法吗","like_count":0,"discussions":[{"author":{"id":1518638,"avatar":"https://static001.geekbang.org/account/avatar/00/17/2c/2e/9f37aaab.jpg","nickname":"一棵菜菜","note":"","ucode":"34916562728398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379328,"discussion_content":"我觉得你这样写挺好的呢。性能上的话，函数执行的时候每次都会创建执行上下文，执行完后又会被销毁，里面的变量也就没了，也释放了内存，所以感觉没有太大影响吧？个人看法，还是请老师来定论吧哈哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623830684,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296813,"user_name":"不瘦到160不改头像","can_delete":false,"product_type":"c1","uid":2428367,"ip_address":"","ucode":"2F7ED040F88AB6","user_header":"https://static001.geekbang.org/account/avatar/00/25/0d/cf/22b9c975.jpg","comment_is_top":false,"comment_ctime":1623167093,"is_pvip":false,"replies":[{"id":"107980","content":"是的，这个在体验上可以更加完善。这里主要演示核心逻辑，所以没有加入细节上的处理。比如实际上，需要判断 timer 是否已经存在了，如果存在就disable start 按钮。","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1623470814,"ip_address":"","comment_id":296813,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1623167093","product_id":100079901,"comment_content":"Start点了两次以后Pause的功能就用不了了。代码里这边的逻辑有点没有读明白。。。。<br>","like_count":0,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521592,"discussion_content":"是的，这个在体验上可以更加完善。这里主要演示核心逻辑，所以没有加入细节上的处理。比如实际上，需要判断 timer 是否已经存在了，如果存在就disable start 按钮。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623470814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296056,"user_name":"笨重的企鹅","can_delete":false,"product_type":"c1","uid":1676455,"ip_address":"","ucode":"416803E12D5829","user_header":"https://static001.geekbang.org/account/avatar/00/19/94/a7/43c1efaa.jpg","comment_is_top":false,"comment_ctime":1622721348,"is_pvip":false,"replies":[{"id":"107465","content":"能贴下完整的代码吗，理论上肯定要用 useRef 的~","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1622728110,"ip_address":"","comment_id":296056,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1622721348","product_id":100079901,"comment_content":"useRef那个计时器的例子，不用useRef，直接声明一个普调变量：let timer = null（注意不能是const）也是OK的，所以多次渲染之间共享数据这个貌似不怎么实用","like_count":0,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521306,"discussion_content":"能贴下完整的代码吗，理论上肯定要用 useRef 的~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622728110,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1110607,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f2/4f/59bd4141.jpg","nickname":"Isaac","note":"","ucode":"038C349AB508AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378110,"discussion_content":"可以参考这里 DEMO，就会发现利用变量的局限性了。\nhttps://codesandbox.io/s/zhijieshiyongchangliangtidai-useref-dejuxianxing-kyptw?file=/src/App.tsx","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1623057296,"is_liked":true,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1509998,"avatar":"https://static001.geekbang.org/account/avatar/00/17/0a/6e/6fe3847e.jpg","nickname":"lxzchina","note":"","ucode":"E61E38F5B90969","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378075,"discussion_content":"直接声明变量是不行的，如果其它地方set state了，函数组件会重新跑一遍,这个timer又会置为初始时候的null","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1623050645,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295913,"user_name":"傻子来了快跑丶","can_delete":false,"product_type":"c1","uid":1282777,"ip_address":"","ucode":"662624121A1DFA","user_header":"https://static001.geekbang.org/account/avatar/00/13/92/d9/84c1de45.jpg","comment_is_top":false,"comment_ctime":1622638677,"is_pvip":false,"replies":[{"id":"107459","content":"谢谢！","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1622727548,"ip_address":"","comment_id":295913,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1622638677","product_id":100079901,"comment_content":"老师讲的很棒，希望后面的课程质量更棒","like_count":0,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521262,"discussion_content":"谢谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622727548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295748,"user_name":"D.W","can_delete":false,"product_type":"c1","uid":1705682,"ip_address":"","ucode":"4951CAB3C82541","user_header":"https://static001.geekbang.org/account/avatar/00/1a/06/d2/e6efc3db.jpg","comment_is_top":false,"comment_ctime":1622590615,"is_pvip":false,"replies":[{"id":"107455","content":"1. 正确~<br>2. 没错，没有必要。","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1622727418,"ip_address":"","comment_id":295748,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1622590615","product_id":100079901,"comment_content":"老师，你好。<br>1，如果用state保存timer，在清空times贵引起不必要的渲染吧<br><br>2，请问像一些事件监听的函数，比如监听下拉框的变化，按钮的点击回调，应该没有必要用useCallback包裹吧？就像文中说的，使用useCallback主要是为了避免函数重新生成，接受函数作为参数的组件也重新渲染","like_count":0,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521205,"discussion_content":"1. 正确~\n2. 没错，没有必要。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622727418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295631,"user_name":"aloha66","can_delete":false,"product_type":"c1","uid":1469820,"ip_address":"","ucode":"60AF4685BF38A2","user_header":"https://static001.geekbang.org/account/avatar/00/16/6d/7c/e91866cf.jpg","comment_is_top":false,"comment_ctime":1622521515,"is_pvip":true,"replies":[{"id":"107377","content":"没有必要，因为虚拟 DOM 会帮你做这个优化。这种写法，其实虚拟 DOM 还是需要去整体进行 diff 计算的。","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1622559054,"ip_address":"","comment_id":295631,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1622521515","product_id":100079901,"comment_content":"如果通过useMemo，依赖数组是容器组件的state,来优化展示组件的渲染，这个方案可行吗？<br> const ItemRender = useMemo(() =&gt;&lt;ComA {...props}&#47;&gt;},[state])<br>...<br>{ItemRender}","like_count":0,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521159,"discussion_content":"没有必要，因为虚拟 DOM 会帮你做这个优化。这种写法，其实虚拟 DOM 还是需要去整体进行 diff 计算的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622559054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1107001,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLg1BhBeNfibU9lW9fWWIhwRdqjmZzAJ6tW850qGibdFPmRia2CDIEAsYciaiag43ElaHRtBcHLggM9zuw/132","nickname":"测试昵称","note":"","ucode":"8FC9D76F9E6584","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377740,"discussion_content":"感觉之前为了想减少UI组件渲染，都这么写。。。害，不用优化的地方优化 😖","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1622799551,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}