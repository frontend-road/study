{"id":18037,"title":"14 | 接口类型的合理运用","content":"<p>你好，我是郝林，今天我们来聊聊接口的相关内容。</p><h2>前导内容：正确使用接口的基础知识</h2><p>在Go语言的语境中，当我们在谈论“接口”的时候，一定指的是接口类型。因为接口类型与其他数据类型不同，它是没法被实例化的。</p><p>更具体地说，我们既不能通过调用<code>new</code>函数或<code>make</code>函数创建出一个接口类型的值，也无法用字面量来表示一个接口类型的值。</p><p>对于某一个接口类型来说，如果没有任何数据类型可以作为它的实现，那么该接口的值就不可能存在。</p><p>我已经在前面展示过，通过关键字<code>type</code>和<code>interface</code>，我们可以声明出接口类型。</p><p>接口类型的类型字面量与结构体类型的看起来有些相似，它们都用花括号包裹一些核心信息。只不过，结构体类型包裹的是它的字段声明，而接口类型包裹的是它的方法定义。</p><p>这里你要注意的是：接口类型声明中的这些方法所代表的就是该接口的方法集合。一个接口的方法集合就是它的全部特征。</p><p>对于任何数据类型，只要它的方法集合中完全包含了一个接口的全部特征（即全部的方法），那么它就一定是这个接口的实现类型。比如下面这样：</p><pre><code>type Pet interface {\n\tSetName(name string)\n\tName() string\n\tCategory() string\n}\n</code></pre><p>我声明了一个接口类型<code>Pet</code>，它包含了3个方法定义，方法名称分别为<code>SetName</code>、<code>Name</code>和<code>Category</code>。这3个方法共同组成了接口类型<code>Pet</code>的方法集合。</p><!-- [[[read_end]]] --><p>只要一个数据类型的方法集合中有这3个方法，那么它就一定是<code>Pet</code>接口的实现类型。这是一种无侵入式的接口实现方式。这种方式还有一个专有名词，叫“Duck typing”，中文常译作“鸭子类型”。你可以到百度的<a href=\"https://baike.baidu.com/item/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B\">百科页面</a>上去了解一下详情。</p><p>顺便说一句，<strong>怎样判定一个数据类型的某一个方法实现的就是某个接口类型中的某个方法呢？</strong></p><p>这有两个充分必要条件，一个是“两个方法的签名需要完全一致”，另一个是“两个方法的名称要一模一样”。显然，这比判断一个函数是否实现了某个函数类型要更加严格一些。</p><p>如果你查阅了上篇文章附带的最后一个示例的话，那么就一定会知道，虽然结构体类型<code>Cat</code>不是<code>Pet</code>接口的实现类型，但它的指针类型<code>*Cat</code>却是这个的实现类型。</p><p>如果你还不知道原因，那么请跟着我一起来看。我已经把<code>Cat</code>类型的声明搬到了demo31.go文件中，并进行了一些简化，以便你看得更清楚。对了，由于<code>Cat</code>和<code>Pet</code>的发音过于相似，我还把<code>Cat</code>重命名为了<code>Dog</code>。</p><p>我声明的类型<code>Dog</code>附带了3个方法。其中有2个值方法，分别是<code>Name</code>和<code>Category</code>，另外还有一个指针方法<code>SetName</code>。</p><p>这就意味着，<code>Dog</code>类型本身的方法集合中只包含了2个方法，也就是所有的值方法。而它的指针类型<code>*Dog</code>方法集合却包含了3个方法，</p><p>也就是说，它拥有<code>Dog</code>类型附带的所有值方法和指针方法。又由于这3个方法恰恰分别是<code>Pet</code>接口中某个方法的实现，所以<code>*Dog</code>类型就成为了<code>Pet</code>接口的实现类型。</p><pre><code>dog := Dog{&quot;little pig&quot;}\nvar pet Pet = &amp;dog\n</code></pre><p>正因为如此，我可以声明并初始化一个<code>Dog</code>类型的变量<code>dog</code>，然后把它的指针值赋给类型为<code>Pet</code>的变量<code>pet</code>。</p><p>这里有几个名词需要你先记住。对于一个接口类型的变量来说，例如上面的变量<code>pet</code>，我们赋给它的值可以被叫做它的实际值（也称<strong>动态值</strong>），而该值的类型可以被叫做这个变量的实际类型（也称<strong>动态类型</strong>）。</p><p>比如，我们把取址表达式<code>&amp;dog</code>的结果值赋给了变量<code>pet</code>，这时这个结果值就是变量<code>pet</code>的动态值，而此结果值的类型<code>*Dog</code>就是该变量的动态类型。</p><p>动态类型这个叫法是相对于<strong>静态类型</strong>而言的。对于变量<code>pet</code>来讲，它的<strong>静态类型</strong>就是<code>Pet</code>，并且永远是<code>Pet</code>，但是它的动态类型却会随着我们赋给它的动态值而变化。</p><p>比如，只有我把一个<code>*Dog</code>类型的值赋给变量<code>pet</code>之后，该变量的动态类型才会是<code>*Dog</code>。如果还有一个<code>Pet</code>接口的实现类型<code>*Fish</code>，并且我又把一个此类型的值赋给了<code>pet</code>，那么它的动态类型就会变为<code>*Fish</code>。</p><p>还有，在我们给一个接口类型的变量赋予实际的值之前，它的动态类型是不存在的。</p><p>你需要想办法搞清楚接口类型的变量（以下简称接口变量）的动态值、动态类型和静态类型都是什么意思。因为我会在后面基于这些概念讲解更深层次的知识。</p><p>好了，我下面会就“怎样用好Go语言的接口”这个话题提出一系列问题，也请你跟着我一起思考这些问题。</p><p><strong>那么今天的问题是：当我们为一个接口变量赋值时会发生什么？</strong></p><p>为了突出问题，我把<code>Pet</code>接口的声明简化了一下。</p><pre><code>type Pet interface {\n\tName() string\n\tCategory() string\n}\n</code></pre><p>我从中去掉了<code>Pet</code>接口的那个名为<code>SetName</code>的方法。这样一来，<code>Dog</code>类型也就变成<code>Pet</code>接口的实现类型了。你可以在demo32.go文件中找到本问题的代码。</p><p>现在，我先声明并初始化了一个<code>Dog</code>类型的变量<code>dog</code>，这时它的<code>name</code>字段的值是<code>\"little pig\"</code>。然后，我把该变量赋给了一个<code>Pet</code>类型的变量<code>pet</code>。最后我通过调用<code>dog</code>的方法<code>SetName</code>把它的<code>name</code>字段的值改成了<code>\"monster\"</code>。</p><pre><code>dog := Dog{&quot;little pig&quot;}\nvar pet Pet = dog\ndog.SetName(&quot;monster&quot;)\n</code></pre><p>所以，我要问的具体问题是：在以上代码执行后，<code>pet</code>变量的字段<code>name</code>的值会是什么？</p><p><strong>这个题目的典型回答是</strong>：<code>pet</code>变量的字段<code>name</code>的值依然是<code>\"little pig\"</code>。</p><h2>问题解析</h2><p>首先，由于<code>dog</code>的<code>SetName</code>方法是指针方法，所以该方法持有的接收者就是指向<code>dog</code>的指针值的副本，因而其中对接收者的<code>name</code>字段的设置就是对变量<code>dog</code>的改动。那么当<code>dog.SetName(\"monster\")</code>执行之后，<code>dog</code>的<code>name</code>字段的值就一定是<code>\"monster\"</code>。如果你理解到了这一层，那么请小心前方的陷阱。</p><p>为什么<code>dog</code>的<code>name</code>字段值变了，而<code>pet</code>的却没有呢？这里有一条通用的规则需要你知晓：如果我们使用一个变量给另外一个变量赋值，那么真正赋给后者的，并不是前者持有的那个值，而是该值的一个副本。</p><p>例如，我声明并初始化了一个<code>Dog</code>类型的变量<code>dog1</code>，这时它的<code>name</code>是<code>\"little pig\"</code>。然后，我在把<code>dog1</code>赋给变量<code>dog2</code>之后，修改了<code>dog1</code>的<code>name</code>字段的值。这时，<code>dog2</code>的<code>name</code>字段的值是什么？</p><pre><code>dog1 := Dog{&quot;little pig&quot;}\ndog2 := dog1\ndog1.name = &quot;monster&quot;\n</code></pre><p>这个问题与前面那道题几乎一样，只不过这里没有涉及接口类型。这时的<code>dog2</code>的<code>name</code>仍然会是<code>\"little pig\"</code>。这就是我刚刚告诉你的那条通用规则的又一个体现。</p><p>当你知道了这条通用规则之后，确实可以把前面那道题做对。不过，如果当我问你为什么的时候你只说出了这一个原因，那么，我只能说你仅仅答对了一半。</p><p>那么另一半是什么？这就需要从接口类型值的存储方式和结构说起了。我在前面说过，接口类型本身是无法被值化的。在我们赋予它实际的值之前，它的值一定会是<code>nil</code>，这也是它的零值。</p><p>反过来讲，一旦它被赋予了某个实现类型的值，它的值就不再是<code>nil</code>了。不过要注意，即使我们像前面那样把<code>dog</code>的值赋给了<code>pet</code>，<code>pet</code>的值与<code>dog</code>的值也是不同的。这不仅仅是副本与原值的那种不同。</p><p>当我们给一个接口变量赋值的时候，该变量的动态类型会与它的动态值一起被存储在一个专用的数据结构中。</p><p>严格来讲，这样一个变量的值其实是这个专用数据结构的一个实例，而不是我们赋给该变量的那个实际的值。所以我才说，<code>pet</code>的值与<code>dog</code>的值肯定是不同的，无论是从它们存储的内容，还是存储的结构上来看都是如此。不过，我们可以认为，这时<code>pet</code>的值中包含了<code>dog</code>值的副本。</p><p>我们就把这个专用的数据结构叫做<code>iface</code>吧，在Go语言的<code>runtime</code>包中它其实就叫这个名字。</p><p><code>iface</code>的实例会包含两个指针，一个是指向类型信息的指针，另一个是指向动态值的指针。这里的类型信息是由另一个专用数据结构的实例承载的，其中包含了动态值的类型，以及使它实现了接口的方法和调用它们的途径，等等。</p><p>总之，接口变量被赋予动态值的时候，存储的是包含了这个动态值的副本的一个结构更加复杂的值。你明白了吗？</p><h2>知识扩展</h2><p><strong>问题 1：接口变量的值在什么情况下才真正为<code>nil</code>？</strong></p><p>这个问题初看起来就不是个问题。对于一个引用类型的变量，它的值是否为<code>nil</code>完全取决于我们赋给它了什么，是这样吗？我们先来看一段代码：</p><pre><code>var dog1 *Dog\nfmt.Println(&quot;The first dog is nil. [wrap1]&quot;)\ndog2 := dog1\nfmt.Println(&quot;The second dog is nil. [wrap1]&quot;)\nvar pet Pet = dog2\nif pet == nil {\n\tfmt.Println(&quot;The pet is nil. [wrap1]&quot;)\n} else {\n\tfmt.Println(&quot;The pet is not nil. [wrap1]&quot;)\n}\n</code></pre><p>在demo33.go文件的这段代码中，我先声明了一个<code>*Dog</code>类型的变量<code>dog1</code>，并且没有对它进行初始化。这时该变量的值是什么？显然是<code>nil</code>。然后我把该变量赋给了<code>dog2</code>，后者的值此时也必定是<code>nil</code>，对吗？</p><p>现在问题来了：当我把<code>dog2</code>赋给<code>Pet</code>类型的变量<code>pet</code>之后，变量<code>pet</code>的值会是什么？答案是<code>nil</code>吗？</p><p>如果你真正理解了我在上一个问题的解析中讲到的知识，尤其是接口变量赋值及其值的数据结构那部分，那么这道题就不难回答。你可以先思考一下，然后再接着往下看。</p><p>当我们把<code>dog2</code>的值赋给变量<code>pet</code>的时候，<code>dog2</code>的值会先被复制，不过由于在这里它的值是<code>nil</code>，所以就没必要复制了。</p><p>然后，Go语言会用我上面提到的那个专用数据结构<code>iface</code>的实例包装这个<code>dog2</code>的值的副本，这里是<code>nil</code>。</p><p>虽然被包装的动态值是<code>nil</code>，但是<code>pet</code>的值却不会是<code>nil</code>，因为这个动态值只是<code>pet</code>值的一部分而已。</p><p>顺便说一句，这时的<code>pet</code>的动态类型就存在了，是<code>*Dog</code>。我们可以通过<code>fmt.Printf</code>函数和占位符<code>%T</code>来验证这一点，另外<code>reflect</code>包的<code>TypeOf</code>函数也可以起到类似的作用。</p><p>换个角度来看。我们把<code>nil</code>赋给了<code>pet</code>，但是<code>pet</code>的值却不是<code>nil</code>。</p><p>这很奇怪对吗？其实不然。在Go语言中，我们把由字面量<code>nil</code>表示的值叫做无类型的<code>nil</code>。这是真正的<code>nil</code>，因为它的类型也是<code>nil</code>的。虽然<code>dog2</code>的值是真正的<code>nil</code>，但是当我们把这个变量赋给<code>pet</code>的时候，Go语言会把它的类型和值放在一起考虑。</p><p>也就是说，这时Go语言会识别出赋予<code>pet</code>的值是一个<code>*Dog</code>类型的<code>nil</code>。然后，Go语言就会用一个<code>iface</code>的实例包装它，包装后的产物肯定就不是<code>nil</code>了。</p><p>只要我们把一个有类型的<code>nil</code>赋给接口变量，那么这个变量的值就一定不会是那个真正的<code>nil</code>。因此，当我们使用判等符号<code>==</code>判断<code>pet</code>是否与字面量<code>nil</code>相等的时候，答案一定会是<code>false</code>。</p><p>那么，怎样才能让一个接口变量的值真正为<code>nil</code>呢？要么只声明它但不做初始化，要么直接把字面量<code>nil</code>赋给它。</p><p><strong>问题 2：怎样实现接口之间的组合？</strong></p><p>接口类型间的嵌入也被称为接口的组合。我在前面讲过结构体类型的嵌入字段，这其实就是在说结构体类型间的嵌入。</p><p>接口类型间的嵌入要更简单一些，因为它不会涉及方法间的“屏蔽”。只要组合的接口之间有同名的方法就会产生冲突，从而无法通过编译，即使同名方法的签名彼此不同也会是如此。因此，接口的组合根本不可能导致“屏蔽”现象的出现。</p><p>与结构体类型间的嵌入很相似，我们只要把一个接口类型的名称直接写到另一个接口类型的成员列表中就可以了。比如：</p><pre><code>type Animal interface {\n\tScientificName() string\n\tCategory() string\n}\n\ntype Pet interface {\n\tAnimal\n\tName() string\n}\n</code></pre><p>接口类型<code>Pet</code>包含了两个成员，一个是代表了另一个接口类型的<code>Animal</code>，一个是方法<code>Name</code>的定义。它们都被包含在<code>Pet</code>的类型声明的花括号中，并且都各自独占一行。此时，<code>Animal</code>接口包含的所有方法也就成为了<code>Pet</code>接口的方法。</p><p>Go语言团队鼓励我们声明体量较小的接口，并建议我们通过这种接口间的组合来扩展程序、增加程序的灵活性。</p><p>这是因为相比于包含很多方法的大接口而言，小接口可以更加专注地表达某一种能力或某一类特征，同时也更容易被组合在一起。</p><p>Go语言标准库代码包<code>io</code>中的<code>ReadWriteCloser</code>接口和<code>ReadWriter</code>接口就是这样的例子，它们都是由若干个小接口组合而成的。以<code>io.ReadWriteCloser</code>接口为例，它是由<code>io.Reader</code>、<code>io.Writer</code>和<code>io.Closer</code>这三个接口组成的。</p><p>这三个接口都只包含了一个方法，是典型的小接口。它们中的每一个都只代表了一种能力，分别是读出、写入和关闭。我们编写这几个小接口的实现类型通常都会很容易。并且，一旦我们同时实现了它们，就等于实现了它们的组合接口<code>io.ReadWriteCloser</code>。</p><p>即使我们只实现了<code>io.Reader</code>和<code>io.Writer</code>，那么也等同于实现了<code>io.ReadWriter</code>接口，因为后者就是前两个接口组成的。可以看到，这几个<code>io</code>包中的接口共同组成了一个接口矩阵。它们既相互关联又独立存在。</p><p>我在demo34.go文件中写了一个能够体现接口组合优势的小例子，你可以去参看一下。总之，善用接口组合和小接口可以让你的程序框架更加稳定和灵活。</p><p><strong>总结</strong></p><p>好了，我们来简要总结一下。</p><p>Go语言的接口常用于代表某种能力或某类特征。首先，我们要弄清楚的是，接口变量的动态值、动态类型和静态类型都代表了什么。这些都是正确使用接口变量的基础。当我们给接口变量赋值时，接口变量会持有被赋予值的副本，而不是它本身。</p><p>更重要的是，接口变量的值并不等同于这个可被称为动态值的副本。它会包含两个指针，一个指针指向动态值，一个指针指向类型信息。</p><p>基于此，即使我们把一个值为<code>nil</code>的某个实现类型的变量赋给了接口变量，后者的值也不可能是真正的<code>nil</code>。虽然这时它的动态值会为<code>nil</code>，但它的动态类型确是存在的。</p><p>请记住，除非我们只声明而不初始化，或者显式地赋给它<code>nil</code>，否则接口变量的值就不会为<code>nil</code>。</p><p>后面的一个问题相对轻松一些，它是关于程序设计方面的。用好小接口和接口组合总是有益的，我们可以以此形成接口矩阵，进而搭起灵活的程序框架。如果在实现接口时再配合运用结构体类型间的嵌入手法，那么接口组合就可以发挥更大的效用。</p><p><strong>思考题</strong></p><p>如果我们把一个值为<code>nil</code>的某个实现类型的变量赋给了接口变量，那么在这个接口变量上仍然可以调用该接口的方法吗？如果可以，有哪些注意事项？如果不可以，原因是什么？</p><p><a href=\"https://github.com/hyper0x/Golang_Puzzlers\">戳此查看Go语言专栏文章配套详细代码。</a></p><p></p>","comments":[{"had_liked":false,"id":51726,"user_name":"hiyanxu","can_delete":false,"product_type":"c1","uid":1221750,"ip_address":"","ucode":"FA46A318154812","user_header":"https://static001.geekbang.org/account/avatar/00/12/a4/76/585dc6b3.jpg","comment_is_top":true,"comment_ctime":1545229612,"is_pvip":false,"replies":[{"id":"19219","content":"没错，虽然是副本，但却是指针的副本，SetName又是指针方法。所以综合起来这种修改就生效了。<br><br>另外这类副本都是浅表复制。也没错。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1545576289,"ip_address":"","comment_id":51726,"utype":1}],"discussion_count":2,"race_medal":0,"score":"9.2233721672490004e+18","product_id":100013101,"comment_content":"老师，您好：<br>我在这篇文章中看到您说，给接口类型变量赋值时传递的都是副本，我测试了，确实是不会改变被赋值后的接口类型变量。<br>后面，我重新给Pet接口加上了SetName()方法，然后让*Dog类型实现了该Pet接口，然后声明并初始化了一个d，将d的地址&amp;d赋值给Pet类型的接口变量：<br>d := Dog{name: &quot;little dog&quot;}<br>var pet Pet = &amp;d<br>此时，我去修改了d的name字段：<br>d.SetName(&quot;big dog&quot;)<br>运行后发现输出不仅d的name字段变为了“big dog”，同样pet接口变量也变成了“big dog”。<br>在此时我是不是可以说，传递给pet变量的同样是&amp;d的一个指针副本，因为传递的是副本，所以无论是指针还是值，都可以说是浅复制；且由于传递的是指针（虽然是副本），但还是会对指向的底层变量做修改。<br>请问老师，我上面的推断是正确的吗？<br>另外我想说真的每篇文章都需要好好研读啊，看一篇得两个小时，里面好多干货，谢谢老师！","like_count":30,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433599,"discussion_content":"没错，虽然是副本，但却是指针的副本，SetName又是指针方法。所以综合起来这种修改就生效了。\n\n另外这类副本都是浅表复制。也没错。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545576289,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1017297,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKYfcUOVhf3vhEBUNGHgtIcw8ujMZnkabicLzzjn3xwdeeic2PJSe7ibJgMx2UjF0d7L4B4gsRpaqe2A/132","nickname":"郭小菜","note":"","ucode":"C4044C80BB331B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298079,"discussion_content":"嗨呀，我感觉有C/C++的基础的这些就太好理解了~  都是值传递呗","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1597162552,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":24185,"user_name":"xlh","can_delete":false,"product_type":"c1","uid":1203940,"ip_address":"","ucode":"A7D86084999D41","user_header":"","comment_is_top":false,"comment_ctime":1536837014,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"388083893654","product_id":100013101,"comment_content":"大神，每篇文章前能先解答上次留的问题吗?思考过后有个答案，有错思之，无错加勉","like_count":90},{"had_liked":false,"id":24486,"user_name":"extraterrestrial！！","can_delete":false,"product_type":"c1","uid":1017987,"ip_address":"","ucode":"74AE07CA68F6B6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/GDYkD2X7pXSKUSaUFC8u3TBPaakaibnOBV2NYDc2TNfb8Su9icFMwSod6iaQX5iaGU2gT6xkPuhXeWvY8KaVEZAYzg/132","comment_is_top":false,"comment_ctime":1537075155,"is_pvip":true,"discussion_count":6,"race_medal":0,"score":"151860930515","product_id":100013101,"comment_content":"有个疑问，go里面一个类型实现了接口所有的方法，才算该接口类型，但并没有语法显式说明这个类型实现了哪个接口(例如java中有implements), 这样看别人代码的时候，碰到一个类型，无法知道这个类型是不是实现了一个接口，除非类型和接口写在一个文件，然后还要自己一个一个方法去对比。有比较快的方法可以知道当前类型实现了哪些接口么？","like_count":35,"discussions":[{"author":{"id":1019568,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8e/b0/ef201991.jpg","nickname":"CcczzZ","note":"","ucode":"5F46DA5053D2BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":114093,"discussion_content":"在IDE里，使用变量名+&#34;.&#34; 可以看到能调用的方法和变量，跟进去找找看大概就能定位了","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1577956965,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1071974,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5b/66/ad35bc68.jpg","nickname":"党","note":"","ucode":"EE531DB3EA124D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2969,"discussion_content":"ide工具可以实现这些功能 比如goland","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1564074352,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1351076,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","nickname":"lesserror","note":"","ucode":"25A54D1165FCF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1071974,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5b/66/ad35bc68.jpg","nickname":"党","note":"","ucode":"EE531DB3EA124D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386743,"discussion_content":"请问一下怎么查看呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1627777045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2969,"ip_address":""},"score":386743,"extra":""}]},{"author":{"id":1117933,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0e/ed/1c662e93.jpg","nickname":"莫珣","note":"","ucode":"CAFE6F2AC5C177","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575104,"discussion_content":"我也觉得这是interface最恶心的一点，因为很难确定某个类型到底实现了哪些接口","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654595532,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1593521,"avatar":"https://static001.geekbang.org/account/avatar/00/18/50/b1/7b701518.jpg","nickname":"黄仲辉","note":"","ucode":"D7EB3C3ADD99DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547616,"discussion_content":"那修改接口时的隐患就好大啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642769866,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1071316,"avatar":"https://static001.geekbang.org/account/avatar/00/10/58/d4/c52f9f6d.jpg","nickname":"芝士老爹","note":"","ucode":"5F2935967574D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3730,"discussion_content":"具体实现了哪个接口虽然是隐式的，但是一个类型实现了哪些方法是可以在源代码里面看到的呀！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564736730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93548,"user_name":"志鑫","can_delete":false,"product_type":"c1","uid":1095392,"ip_address":"","ucode":"408869664EEA13","user_header":"https://static001.geekbang.org/account/avatar/00/10/b6/e0/52a07898.jpg","comment_is_top":false,"comment_ctime":1557492585,"is_pvip":false,"replies":[{"id":"33423","content":"这主要是因为 Dog 和 *Dog 的零值是完全不同的，前者是 Dog{} ，而后者是 nil 。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1557497866,"ip_address":"","comment_id":93548,"utype":1}],"discussion_count":1,"race_medal":0,"score":"130406511465","product_id":100013101,"comment_content":"思考题，要看实现类型是值类型还是指针类型；<br>\tvar d2 Dog<br>\tvar p2 Pet = d2<br>\tif p2 != nil {<br>\t\tfmt.Println(&quot;p2.Name()&quot;, p2.Name())<br>\t}<br><br>\tvar d3 *Dog<br>\tvar p3 Pet = d3<br>\tif p3 != nil {<br>\t\tfmt.Println(&quot;p3.Name()&quot;, p3.Name()) &#47;&#47;运行是报错，panic: value method main.Dog.Name called using nil *Dog pointer<br><br>\t}","like_count":30,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449675,"discussion_content":"这主要是因为 Dog 和 *Dog 的零值是完全不同的，前者是 Dog{} ，而后者是 nil 。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557497866,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":24674,"user_name":"追梦","can_delete":false,"product_type":"c1","uid":1197685,"ip_address":"","ucode":"634A19055525B3","user_header":"https://static001.geekbang.org/account/avatar/00/12/46/75/9f80409f.jpg","comment_is_top":false,"comment_ctime":1537183553,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"121796267841","product_id":100013101,"comment_content":"关于思考题，如果我们把一个值为nil的某个实现类型的变量赋给了接口变量，在这个接口变量上仍然可以访问其方法，但无法访问其属性。使用时需要注意：如果涉及到变量属性，这些属性值均为默认值。","like_count":28},{"had_liked":false,"id":25791,"user_name":"Aaron","can_delete":false,"product_type":"c1","uid":1198001,"ip_address":"","ucode":"261C1321DB7DC7","user_header":"https://static001.geekbang.org/account/avatar/00/12/47/b1/290cd99d.jpg","comment_is_top":false,"comment_ctime":1537440400,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"87436786320","product_id":100013101,"comment_content":"文章中demo32.go demo31.go可不可以直接贴出来","like_count":20,"discussions":[{"author":{"id":1221013,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a1/95/3234523a.jpg","nickname":"XXX","note":"","ucode":"2D66768DC4E35D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380134,"discussion_content":"建议去github查看，代码贴出来就会导致文章篇幅很长，不适合学习","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624353490,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78003,"user_name":"俊杰","can_delete":false,"product_type":"c1","uid":1020008,"ip_address":"","ucode":"197C1CB1D48CB5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/90/68/511fc1e5.jpg","comment_is_top":false,"comment_ctime":1553052618,"is_pvip":false,"replies":[{"id":"28874","content":"你可以参照Go语言规范中的说明：https:&#47;&#47;golang.google.cn&#47;ref&#47;spec#Comparison_operators，请注意下面这句：<br><br>A value x of non-interface type X and a value t of interface type T are comparable when values of type X are comparable and X implements T. They are equal if t&#39;s dynamic type is identical to X and t&#39;s dynamic value is equal to x.","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1553398574,"ip_address":"","comment_id":78003,"utype":1}],"discussion_count":4,"race_medal":0,"score":"53092660170","product_id":100013101,"comment_content":"老师您好，有个地方不理解，对象赋值给接口后，为什么判等操作返回的是true呢？比如上面的例子：pet = dog之后紧接着判断pet == dog，返回的是true，按上面的说法，赋值后不是应该被包装成了一个iface吗？这里的判等操作到底是依据什么来判断的呢？麻烦老师解释一下，谢谢~","like_count":12,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443933,"discussion_content":"你可以参照Go语言规范中的说明：https://golang.google.cn/ref/spec#Comparison_operators，请注意下面这句：\n\nA value x of non-interface type X and a value t of interface type T are comparable when values of type X are comparable and X implements T. They are equal if t&amp;#39;s dynamic type is identical to X and t&amp;#39;s dynamic value is equal to x.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553398574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1080706,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7d/82/5ed8a955.jpg","nickname":"晒太阳","note":"","ucode":"99CFF3D5A4FE72","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5807,"discussion_content":"是不是可以理解成，不管是结构体还是接口，虽然接口类型在数据结构上被封装成iface，只要动态类型和动态值相同，就认为这两个对象相等。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1566467644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1740409,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/8e/79/f9d5dd3a.jpg","nickname":"吕超","note":"","ucode":"B36883984BE16B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":187282,"discussion_content":"我觉得这部分应该补充到课文中去。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582729085,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1657948,"avatar":"https://static001.geekbang.org/account/avatar/00/19/4c/5c/9ea0f752.jpg","nickname":"程序猿不圆","note":"","ucode":"BC8926A84A07C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370368,"discussion_content":"所以，只要动态类型和动态值一致，接口变量的值与它的实现类型的值判等操作就会返回true？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619393696,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":23983,"user_name":"asdf100","can_delete":false,"product_type":"c1","uid":1043738,"ip_address":"","ucode":"39D8D71453E575","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/1a/ce7f7d54.jpg","comment_is_top":false,"comment_ctime":1536741522,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"48781381778","product_id":100013101,"comment_content":"golang中，结构体类型struct包裹的是它的字段声明，而接口类型interface包裹的是它的方法定义。","like_count":11},{"had_liked":false,"id":97795,"user_name":"吉他","can_delete":false,"product_type":"c1","uid":1046180,"ip_address":"","ucode":"1B8584F439294F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f6/a4/25235411.jpg","comment_is_top":false,"comment_ctime":1558777844,"is_pvip":false,"replies":[{"id":"34977","content":"对的，对于指针方法来说是这样。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1558794052,"ip_address":"","comment_id":97795,"utype":1}],"discussion_count":3,"race_medal":0,"score":"44508450804","product_id":100013101,"comment_content":"关于思考题，如果我们把一个值为nil的某个实现类型的变量赋给了接口变量，那么在这个接口变量上仍然可以调用该接口的方法吗？<br>可以的，不过方法内不能使用实现类型内的变量，并且方法接收者必须是指针类型","like_count":10,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451425,"discussion_content":"对的，对于指针方法来说是这样。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558794052,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2059184,"avatar":"","nickname":"huang","note":"","ucode":"CE7007FE0905BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324140,"discussion_content":"不过方法内不能使用实现类型内的变量，并且方法接收者必须是指针类型 --- 能举个例子吗？ 不好理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605060991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1283989,"avatar":"https://static001.geekbang.org/account/avatar/00/13/97/95/aad51e9b.jpg","nickname":"waterjiao","note":"","ucode":"74F2F75BF0CA6F","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":2059184,"avatar":"","nickname":"huang","note":"","ucode":"CE7007FE0905BA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350967,"discussion_content":"func(s *Dog) Name() {\n    fmt.Print(s.name)\n}","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1614085777,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":324140,"ip_address":""},"score":350967,"extra":""}]}]},{"had_liked":false,"id":24044,"user_name":"colben","can_delete":false,"product_type":"c1","uid":1200769,"ip_address":"","ucode":"5E5DBA48578E96","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/81/745475e9.jpg","comment_is_top":false,"comment_ctime":1536770839,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"44486443799","product_id":100013101,"comment_content":"package main<br><br>import (<br>    &quot;fmt&quot;<br>)<br><br>type Person struct {<br>    name string<br>    age  uint8<br>}<br><br>&#47;&#47; use computer<br>type ComputerOper interface {<br>    TurnOnComputer()<br>    TurnOffComputer()<br>}<br><br>&#47;&#47; use chrome<br>type ChromeOper interface {<br>    ComputerOper<br>    TurnOnChrome()<br>    TurnOffChrome()<br>}<br><br>&#47;&#47; turn on computer<br>func (p *Person) TurnOnComputer() {<br>    fmt.Println(&quot;Power on computer and boot OS.&quot;)<br>}<br><br>&#47;&#47; turn off computer<br>func (p Person) TurnOffComputer() {<br>    fmt.Println(&quot;Shutdown OS and power off computer.&quot;)<br>}<br><br>&#47;&#47; start chrome<br>func (p *Person) TurnOnChrome() {<br>    fmt.Println(&quot;Start web browser chrome.&quot;)<br>}<br><br>&#47;&#47; stop chrome<br>func (p Person) TurnOffChrome() {<br>    fmt.Println(&quot;Stop web browser chrome.&quot;)<br>}<br><br>&#47;&#47; someone use chrome<br>func UseChrome(user ChromeOper) {<br>    user.TurnOnComputer()<br>    user.TurnOnChrome()<br>&#47;&#47; 下面两个是&quot;值方法&quot;, 空指针panic<br>&#47;&#47;    user.TurnOffChrome()<br>&#47;&#47;    user.TurnOffComputer()<br>}<br><br>func main() {<br>    var user *Person<br>    UseChrome(user)<br>}<br><br>&#47;&#47; 变量本身肯定读写不了，值方法在调用时要复制一个副本，所以也用不了，就剩下指针方法了。","like_count":10,"discussions":[{"author":{"id":2059184,"avatar":"","nickname":"huang","note":"","ucode":"CE7007FE0905BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324143,"discussion_content":"牛啊，大神","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605061374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168243,"user_name":"CcczzZ","can_delete":false,"product_type":"c1","uid":1019568,"ip_address":"","ucode":"5F46DA5053D2BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/b0/ef201991.jpg","comment_is_top":false,"comment_ctime":1578036591,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31642807663","product_id":100013101,"comment_content":"重点<br>* 接口的基础知识，什么是接口？<br>* 怎么判断一个数据类型是一个接口的实现？<br>* 接口变量的动态值、动态类型、静态类型都是什么？<br>* 当为一个接口变量赋值会发生什么？赋值为一个变量，变量值是 nil 时，接口变量的值是 nil 么？<br>* 接口变量的值在什么情况下才真正为nil ？<br>* 怎样实现接口之间的组合？<br>* 进阶：接口变量的数据结构 iface ？<br><br>知识点：<br>1. 在 Go 语言中，说到接口一般都指的是 接口类型。接口类型是无法被实例化的（new、make 函数等），且如果没有数据类型作为接口的实现，那么接口的值就是不存在的<br>2. 那怎么判断一个数据类型是否就是接口的实现呢？对于一个数据类型，只要它的方法集实现了所有接口中的所有方法（方法签名和名称要完全一致）， 就可以认为该数据类型是接口的实现类型。<br>3. 对于接口变量来说，赋值给接口变量的值可称为它的动态值（实际值），该值的类型可叫做这个类型的动态类型（实际类型），静态类型就是接口变量的原始类型。<br>4. 基础：当使用一个变量给两外一个变量赋值，那么真正赋值给后者的，是前者值的一个副本，并不是原来的那个值；接口变量实例是一个特殊数据结构iface，包含一个指向类型信息的指针和一个指向动态值的指针。赋值给接口变量的值为另一个变量的 nil 值时，这个接口变量其实不是个nil值<br>5. 怎样才能让一个接口变量的值真正为nil呢？要么只声明它但不做初始化，要么直接把字面量nil赋给它<br>6. 接口类型的嵌入可实现接口的组合<br>7. 数据结构iface，包含一个指向类型信息的指针和一个指向动态值的指针","like_count":7},{"had_liked":false,"id":23900,"user_name":"undifined","can_delete":false,"product_type":"c1","uid":1068920,"ip_address":"","ucode":"449CB4CD2DC089","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/78/c3d8ecb0.jpg","comment_is_top":false,"comment_ctime":1536715733,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"31601486805","product_id":100013101,"comment_content":"因为将 nil 实际类型的变量赋值给接口变量，会包装为 iface 实例，这个实例不为空，所以依然可以调用接口的方法，但是通过方法访问变量的属性，则会返回空","like_count":7,"discussions":[{"author":{"id":1008348,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/dc/8876c73b.jpg","nickname":"moooofly","note":"","ucode":"4A20795C281B6F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":128431,"discussion_content":"“但是通过方法访问变量的属性，则会返回空”-- 应该是返回变量的默认值吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578638653,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1272825,"avatar":"https://static001.geekbang.org/account/avatar/00/13/6b/f9/da3ee7a8.jpg","nickname":"Onyanga","note":"","ucode":"DF4D22F0D51881","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1008348,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/dc/8876c73b.jpg","nickname":"moooofly","note":"","ucode":"4A20795C281B6F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293564,"discussion_content":"如果是指针类型，则不能访问变量属性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595582618,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":128431,"ip_address":""},"score":293564,"extra":""}]}]},{"had_liked":false,"id":305005,"user_name":"lesserror","can_delete":false,"product_type":"c1","uid":1351076,"ip_address":"","ucode":"25A54D1165FCF6","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","comment_is_top":false,"comment_ctime":1627745471,"is_pvip":false,"replies":[{"id":"110407","content":"很高兴，谢谢关注哈：）<br><br>我还是依然在当“坐家”，依然没有全职工作。<br><br>（下面也算是我给自己的记录吧）<br><br>2019年，我出了一本新书《Julia编程基础》。Julia语言也是一门通用编程语言，不过更倾向于科学计算和数据科学。它的官方文档对初学者不友好，所以我就填补了一下空白，写了一本给小白看的Julia编程书。<br><br>2010年，我换了住址，也一直在找方向，做了一些尝试。但由于自身的执行力受限，这些尝试都没怎么出成果。年底的时候，我帮某个技术培训机构制定了一整套Go语言培训体系。<br><br>2021年，春节过后的一段时间，我为某大厂审核了Go语言编程规范。在这之后，我一直在规划和撰写一个新的教程，关于软件概要设计的。要是你有兴趣的话，可以关注我的微信公众号“迭代码”。我觉得如果能够写一本跟编程语言无关的软件设计书的话，应该可以帮助更多的人。：）<br><br>说到编程语言，我现在除了Go语言，还在重点关注Julia语言和Rust语言。我把Julia作为个人的数据挖掘语言，把Rust作为一种理解新编程技术和底层系统的帮手。<br><br>最后，其实我也挺想全职工作的，可惜条件还暂时不允许。不过，持续做一些我认为有意义的事，也算是一种积极的生活吧。<br>","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1627880945,"ip_address":"","comment_id":305005,"utype":1}],"discussion_count":4,"race_medal":0,"score":"27397549247","product_id":100013101,"comment_content":"郝林老师，这个专栏过去快三年了，里面的很多内容都对我受益很大。<br><br>但是好像没了老师的动态了，不知道郝林老师这几年都在从事什么类型的工作呢？","like_count":6,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524246,"discussion_content":"很高兴，谢谢关注哈：）\n\n我还是依然在当“坐家”，依然没有全职工作。\n\n（下面也算是我给自己的记录吧）\n\n2019年，我出了一本新书《Julia编程基础》。Julia语言也是一门通用编程语言，不过更倾向于科学计算和数据科学。它的官方文档对初学者不友好，所以我就填补了一下空白，写了一本给小白看的Julia编程书。\n\n2010年，我换了住址，也一直在找方向，做了一些尝试。但由于自身的执行力受限，这些尝试都没怎么出成果。年底的时候，我帮某个技术培训机构制定了一整套Go语言培训体系。\n\n2021年，春节过后的一段时间，我为某大厂审核了Go语言编程规范。在这之后，我一直在规划和撰写一个新的教程，关于软件概要设计的。要是你有兴趣的话，可以关注我的微信公众号“迭代码”。我觉得如果能够写一本跟编程语言无关的软件设计书的话，应该可以帮助更多的人。：）\n\n说到编程语言，我现在除了Go语言，还在重点关注Julia语言和Rust语言。我把Julia作为个人的数据挖掘语言，把Rust作为一种理解新编程技术和底层系统的帮手。\n\n最后，其实我也挺想全职工作的，可惜条件还暂时不允许。不过，持续做一些我认为有意义的事，也算是一种积极的生活吧。\n","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1627880945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2621412,"avatar":"https://static001.geekbang.org/account/avatar/00/27/ff/e4/927547a9.jpg","nickname":"无名无姓","note":"","ucode":"487BD5AA2CD305","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534329,"discussion_content":"老师看起来很忙的样子","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638165429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1432755,"avatar":"https://static001.geekbang.org/account/avatar/00/15/dc/b3/1e09c2d5.jpg","nickname":"Homto","note":"","ucode":"EBA8CDB9FC4AFD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532385,"discussion_content":"老师加油","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637590955,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1351076,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","nickname":"lesserror","note":"","ucode":"25A54D1165FCF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386993,"discussion_content":"谢谢老师百忙之中的回复。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627920439,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200746,"user_name":"张硕","can_delete":false,"product_type":"c1","uid":1302078,"ip_address":"","ucode":"1339E962F9365F","user_header":"https://static001.geekbang.org/account/avatar/00/13/de/3e/02b79982.jpg","comment_is_top":false,"comment_ctime":1585645771,"is_pvip":false,"replies":[{"id":"75211","content":"判断 dog 变量的值是不是 Pet 类型的，判断结果存于 ok 变量。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1585717431,"ip_address":"","comment_id":200746,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18765514955","product_id":100013101,"comment_content":"_, ok := interface{}(dog).(Pet) 这个表达式是什么意思啊？","like_count":4,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490124,"discussion_content":"判断 dog 变量的值是不是 Pet 类型的，判断结果存于 ok 变量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585717431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1435733,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e8/55/92f82281.jpg","nickname":"MClink","note":"","ucode":"F479190923355C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":356898,"discussion_content":"类型断言，前面的文章有讲过","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1615702753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":48656,"user_name":"Garry","can_delete":false,"product_type":"c1","uid":1216548,"ip_address":"","ucode":"FB48A333342B91","user_header":"https://static001.geekbang.org/account/avatar/00/12/90/24/aa5146e4.jpg","comment_is_top":false,"comment_ctime":1544508477,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18724377661","product_id":100013101,"comment_content":"思考题：<br>可以通过接口变量调用，但需要注意实现的方法中不能出现访问类型属性的操作，会报空指针解引用错误。","like_count":4},{"had_liked":false,"id":23934,"user_name":"兔子高","can_delete":false,"product_type":"c1","uid":1213534,"ip_address":"","ucode":"4F710AD87D3B21","user_header":"https://static001.geekbang.org/account/avatar/00/12/84/5e/79568644.jpg","comment_is_top":false,"comment_ctime":1536724407,"is_pvip":false,"replies":[{"id":"8935","content":"需要改动值内部数据的时候必须使用指针方法。其他时候就要看接口实现、被嵌入要求等方面了。我觉得一般情况下用指针方法就好了。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1536976050,"ip_address":"","comment_id":23934,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18716593591","product_id":100013101,"comment_content":"你好，请问分别在什么情况下使用值方法和什么情况下使用引用方法呢","like_count":4,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423785,"discussion_content":"需要改动值内部数据的时候必须使用指针方法。其他时候就要看接口实现、被嵌入要求等方面了。我觉得一般情况下用指针方法就好了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1536976050,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":171717,"user_name":"Crush","can_delete":false,"product_type":"c1","uid":1586771,"ip_address":"","ucode":"5E6D4EE02525D8","user_header":"https://static001.geekbang.org/account/avatar/00/18/36/53/1e797289.jpg","comment_is_top":false,"comment_ctime":1578996744,"is_pvip":false,"replies":[{"id":"66655","content":"更精确的说法是：除了接口类型以外的所有引用类型的值，只要它的实际值为nil，自然就等于nil。<br><br>多解释两句：对于这些类型，它们的值就是实际值。而接口类型的值与它们不同，会在实际值之外再包一层，正如文中所述。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1579053253,"ip_address":"","comment_id":171717,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14463898632","product_id":100013101,"comment_content":"所有值为nil的变量a只要不是接口变量，a == nil是不是就成立？","like_count":3,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481480,"discussion_content":"更精确的说法是：除了接口类型以外的所有引用类型的值，只要它的实际值为nil，自然就等于nil。\n\n多解释两句：对于这些类型，它们的值就是实际值。而接口类型的值与它们不同，会在实际值之外再包一层，正如文中所述。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579053253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170355,"user_name":"Chaos","can_delete":false,"product_type":"c1","uid":1051644,"ip_address":"","ucode":"0151F89F182D4C","user_header":"https://static001.geekbang.org/account/avatar/00/10/0b/fc/e1cbc260.jpg","comment_is_top":false,"comment_ctime":1578578228,"is_pvip":false,"replies":[{"id":"66087","content":"这是在示范“在原来的基本值上调用指针方法并修改其内部字段值”，然后展示“这样并不会改变接口值”。这是一个反例。需要大家运行之后思考的。<br><br>你有这样的思考，很好：）","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1578624513,"ip_address":"","comment_id":170355,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14463480116","product_id":100013101,"comment_content":"demo32.go   line:32<br>var pet Pet = dog   是不是应该  var pet Pet = &amp;dog <br><br>附：https:&#47;&#47;github.com&#47;hyper0x&#47;Golang_Puzzlers&#47;blob&#47;master&#47;src&#47;puzzlers&#47;article14&#47;q1&#47;demo32.go<br>","like_count":3,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480952,"discussion_content":"这是在示范“在原来的基本值上调用指针方法并修改其内部字段值”，然后展示“这样并不会改变接口值”。这是一个反例。需要大家运行之后思考的。\n\n你有这样的思考，很好：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578624513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120124,"user_name":"兴小狸","can_delete":false,"product_type":"c1","uid":1140825,"ip_address":"","ucode":"8A1CDD3F0A59C0","user_header":"","comment_is_top":false,"comment_ctime":1564796132,"is_pvip":false,"replies":[{"id":"44115","content":"这与方法有没有返回值没有关系啊。值方法还是指针方法应该是类型定义者考虑的事情。作为使用者，你可以先假定方法的定义是正确的（可以使程序正常工作）。<br><br>回到你最后的问题。你可以看源码，也可以用 reflect 包里的 API 进行探查（不过比较麻烦）。不过我觉得通常没必要这么做。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1564807065,"ip_address":"","comment_id":120124,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14449698020","product_id":100013101,"comment_content":"接口中声明多个方法，有的方法有返回值，有的是没有的。当一个类实现这些接口时，要怎么知道是传值接收者，还是指针接收者呢？","like_count":3,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461207,"discussion_content":"这与方法有没有返回值没有关系啊。值方法还是指针方法应该是类型定义者考虑的事情。作为使用者，你可以先假定方法的定义是正确的（可以使程序正常工作）。\n\n回到你最后的问题。你可以看源码，也可以用 reflect 包里的 API 进行探查（不过比较麻烦）。不过我觉得通常没必要这么做。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564807065,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":26211,"user_name":"Arthur.Li","can_delete":false,"product_type":"c1","uid":1005824,"ip_address":"","ucode":"EC2436A5136C13","user_header":"https://static001.geekbang.org/account/avatar/00/0f/59/00/6d14972a.jpg","comment_is_top":false,"comment_ctime":1537519120,"is_pvip":false,"replies":[{"id":"9668","content":"方法签名严格来说不包含方法名。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1537690584,"ip_address":"","comment_id":26211,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14422421008","product_id":100013101,"comment_content":"方法签名在这里是指什么呀？我看定义说是方法名称和一个参数列表（方法的参数的顺序和类型）组成。<br>文章里面写的两个条件是方法签名一致和方法名一致，所以有些疑惑了","like_count":3,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424567,"discussion_content":"方法签名严格来说不包含方法名。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537690584,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1019568,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8e/b0/ef201991.jpg","nickname":"CcczzZ","note":"","ucode":"5F46DA5053D2BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":112965,"discussion_content":"讲函数的那篇文章有说过。\n函数的签名：就是函数的参数列表和结果列表的统称，定义了可用来前别不同类型函数的特征和与函数的交互方式。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1577887900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":232197,"user_name":"saltedfish","can_delete":false,"product_type":"c1","uid":1946257,"ip_address":"","ucode":"936571E1AC4139","user_header":"https://static001.geekbang.org/account/avatar/00/1d/b2/91/cf0de36e.jpg","comment_is_top":false,"comment_ctime":1593916549,"is_pvip":false,"replies":[{"id":"85793","content":"1. 方法签名除了名字还有参数列表和结果列表啊。<br>2. 下面这行代码是在定义一个函数类型：<br><br>type Check func(s string) bool<br><br>而下面这行代码是在定义一个函数（实现）：<br><br>func CheckLen(content string) bool {<br>\tif len(content) &gt;= 3 {<br>\t\treturn true<br>\t}<br>\treturn false<br>}<br><br>现在，我们可以说“函数 CheckLen 是函数类型 Check 的一个实例”。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1594004612,"ip_address":"","comment_id":232197,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10183851141","product_id":100013101,"comment_content":"这有两个充分必要条件，一个是“两个方法的签名需要完全一致”，另一个是“两个方法的名称要一模一样”。显然，这比判断一个函数是否实现了某个函数类型要更加严格一些。<br><br>对于这里我有两个疑问：<br>1. 方法签名不就包括方法的名字吗？<br>2. 函数实现某个函数类型是什么意思？","like_count":2,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500556,"discussion_content":"1. 方法签名除了名字还有参数列表和结果列表啊。\n2. 下面这行代码是在定义一个函数类型：\n\ntype Check func(s string) bool\n\n而下面这行代码是在定义一个函数（实现）：\n\nfunc CheckLen(content string) bool {\n\tif len(content) &amp;gt;= 3 {\n\t\treturn true\n\t}\n\treturn false\n}\n\n现在，我们可以说“函数 CheckLen 是函数类型 Check 的一个实例”。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594004612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216623,"user_name":"开发二组","can_delete":false,"product_type":"c1","uid":1985031,"ip_address":"","ucode":"F8B6F98C6F13E1","user_header":"https://static001.geekbang.org/account/avatar/00/1e/4a/07/bb3e0e79.jpg","comment_is_top":false,"comment_ctime":1589297320,"is_pvip":false,"replies":[{"id":"80191","content":"我说的是接口（interface）间的组合不存在方法“屏蔽”的现象。你这个是结构体（struct）间的组合嵌套。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1589337332,"ip_address":"","comment_id":216623,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10179231912","product_id":100013101,"comment_content":"老师您好：您说组合的接口不涉及到屏蔽现象，那下面这种算是屏蔽吗？<br>func (pt PetTag) Name() string {<br>\treturn pt.name<br>}<br><br>func (pt PetTag) Owner() string {<br>\treturn pt.owner<br>}<br><br>type Dog struct {<br>\tPetTag<br>\tscientificName string<br>}<br><br>func (dog Dog) Name() string {<br>\treturn &quot;dog&quot;<br>}","like_count":2,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494886,"discussion_content":"我说的是接口（interface）间的组合不存在方法“屏蔽”的现象。你这个是结构体（struct）间的组合嵌套。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589337332,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":195295,"user_name":"starj","can_delete":false,"product_type":"c1","uid":1108791,"ip_address":"","ucode":"3546E42F1340B2","user_header":"https://static001.geekbang.org/account/avatar/00/10/eb/37/a2f4c9f8.jpg","comment_is_top":false,"comment_ctime":1585154953,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10175089545","product_id":100013101,"comment_content":"一般不需要值方法，都定义成指针方法","like_count":2},{"had_liked":false,"id":188898,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1584431845,"is_pvip":false,"replies":[{"id":"73006","content":"这就涉及到 iface 的实现细节了。<br><br>1. 是的，iface 中只会包含接口中声明的方法。这部分会有专门的结构承载。<br>2. 这里的途径主要是指实际类型的信息以及相应代码的位置计算方法。Go运行时系统通过这些东西，再基于动态值的指针，就可以找到并调用相应的方法了。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1584504966,"ip_address":"","comment_id":188898,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10174366437","product_id":100013101,"comment_content":"它实现了接口的方法和调用他们的途径<br>1. 意思是只包含接口当中的方法吗？<br>2. 调用他们的途径是什么意思？<br>希望老师解答一下 不明白这两点 感觉就会有欠缺","like_count":2,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487560,"discussion_content":"这就涉及到 iface 的实现细节了。\n\n1. 是的，iface 中只会包含接口中声明的方法。这部分会有专门的结构承载。\n2. 这里的途径主要是指实际类型的信息以及相应代码的位置计算方法。Go运行时系统通过这些东西，再基于动态值的指针，就可以找到并调用相应的方法了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584504966,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117557,"user_name":"党","can_delete":false,"product_type":"c1","uid":1071974,"ip_address":"","ucode":"EE531DB3EA124D","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/66/ad35bc68.jpg","comment_is_top":false,"comment_ctime":1564076808,"is_pvip":false,"replies":[{"id":"43107","content":"指针方法集合中包含所有值方法。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1564109504,"ip_address":"","comment_id":117557,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10154011400","product_id":100013101,"comment_content":"“而它的指针类型*Dog方法集合却包含了 3 个方法” 为什么啊 Dog中实现的方法明明时一个指针类型方法 两个数据值类型方法 为什么说指针类型实现了三个啊","like_count":2,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460022,"discussion_content":"指针方法集合中包含所有值方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564109504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1071974,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5b/66/ad35bc68.jpg","nickname":"党","note":"","ucode":"EE531DB3EA124D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":586516,"discussion_content":"老师我碰上过两次指针类型无法调用非指针方法 看你这篇文章做测试时候又发现了一个 代码如下\ntype Dog struct {\n\tName string\n}\n\nfunc (this Dog) GetName() string {\n\treturn “this is a dog”\n}\n\ntype Name interface {\n\tGetName() string\n}\n\nfunc main() {\n\tvar a *Dog\n\tb := interface{}(a).(Name)\n\tfmt.Println(b.GetName()) \n}\na是指针类型，应该可以调用非指针方法 GetName，但是不能调用，只有改成func(this *Dog)GetName()string 才会正常，隐隐感觉指针方法集合前提是不能是空指针才能调用到非指针方法，这里边有啥规律呢\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662294949,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":460022,"ip_address":"河北"},"score":586516,"extra":""}]}]},{"had_liked":false,"id":80899,"user_name":"枫林火山","can_delete":false,"product_type":"c1","uid":1199855,"ip_address":"","ucode":"66099C9D1AD36C","user_header":"https://static001.geekbang.org/account/avatar/00/12/4e/ef/2ad3effd.jpg","comment_is_top":false,"comment_ctime":1553752510,"is_pvip":true,"replies":[{"id":"29507","content":"郝林回复：首先，你要明白在Dog里内嵌Animal意味着什么。这意味着Dog类型中包含了一个Animal类型的匿名字段。正是由于这个匿名字段，Dog类型就包含了实现Animal接口所需的所有方法，只不过你并没有为这个匿名字段赋值而已。但是这个字段就摆在那儿了，匿名字段Animal的方法照样会融入Dog的方法集合。这是一个不争的事实，所以类型判断的时候照样会返回true。实际上，单从方法集合融入的这个方面讲，这与Dog内嵌PetTag是一样的。<br><br>这样的嵌入方式是可以的。当你要做部件动态装配的时候可以这么做，不论是嵌入接口类型还是嵌入非接口类型。当然了，内嵌接口类型会更加灵活一些，因为你可以为这个匿名字段赋予不同的实现值。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1553921253,"ip_address":"","comment_id":80899,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10143687102","product_id":100013101,"comment_content":"老师，您好，在demo34.go 中我本意是想尝试用interface做内嵌字段来显式表明一个struct的接口能力的。 但是这过程中发现，如果我在Dog中内嵌了Animal接口，然后注释掉Dog的ScientificName实现，line37 - 45 如下<br>type Dog struct {<br>\tAnimal<br>\tPetTag<br>\tscientificName string<br>}<br><br>&#47;&#47; func (dog Dog) ScientificName() string {<br>&#47;&#47; \treturn dog.scientificName<br>&#47;&#47; }<br>运行代码结果依然是<br>PetTag implements interface Named: true<br>Dog implements interface Animal: true<br>Dog implements interface Named: true<br>Dog implements interface Pet: true<br>老师能否讲解下这是Go语言的静态检查不完善还是别有深意，我这样使用接口内嵌来表明一个Struct的能力，这样是不是有问题，正确的声明方式是什么？","like_count":2,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445012,"discussion_content":"郝林回复：首先，你要明白在Dog里内嵌Animal意味着什么。这意味着Dog类型中包含了一个Animal类型的匿名字段。正是由于这个匿名字段，Dog类型就包含了实现Animal接口所需的所有方法，只不过你并没有为这个匿名字段赋值而已。但是这个字段就摆在那儿了，匿名字段Animal的方法照样会融入Dog的方法集合。这是一个不争的事实，所以类型判断的时候照样会返回true。实际上，单从方法集合融入的这个方面讲，这与Dog内嵌PetTag是一样的。\n\n这样的嵌入方式是可以的。当你要做部件动态装配的时候可以这么做，不论是嵌入接口类型还是嵌入非接口类型。当然了，内嵌接口类型会更加灵活一些，因为你可以为这个匿名字段赋予不同的实现值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553921176,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76265,"user_name":"海盗船长","can_delete":false,"product_type":"c1","uid":1363634,"ip_address":"","ucode":"ECB28BA21A4113","user_header":"https://static001.geekbang.org/account/avatar/00/14/ce/b2/1f914527.jpg","comment_is_top":false,"comment_ctime":1552561829,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10142496421","product_id":100013101,"comment_content":"这一课收获很多，里面包括了go语言的规则：类型 *T 的可调用方法集包含接受者为 *T 或 T 的所有方法集 <br>这条规则说的是如果我们用来调用特定接口方法的接口变量是一个指针类型，那么方法的接受者可以是值类型也可以是指针类型.<br><br>类型 T 的可调用方法集包含接受者为 T 的所有方法","like_count":2},{"had_liked":false,"id":24537,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1118976,"ip_address":"","ucode":"35F4FFAC4A4B15","user_header":"https://static001.geekbang.org/account/avatar/00/11/13/00/a4a2065f.jpg","comment_is_top":false,"comment_ctime":1537113855,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10127048447","product_id":100013101,"comment_content":"这结课终于让我明白了 reflect 包中，reflect.Type 和 reflect.Value 存在的意义，茅塞顿开啊！<br><br>接口变量的值并不等同于这个可被称为动态值的副本。它会包含两个指针，一个指向动态值，一个指向动态类型。<br><br>关于思考题，我试验之后是不可以的，因为在调用的时候没有接收者，还请老师指正","like_count":2},{"had_liked":false,"id":310594,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1630763093,"is_pvip":false,"replies":[{"id":"112587","content":"谢谢你的建议。不过我非常建议你去看一下Go语言源码，然后自己画出来，这样很有助于学习和巩固。<br><br>我在专栏里一再建议大家看完文章后去看看源码，甚至我会在很多回复中催着大家去源码。这非常非常重要。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1630900130,"ip_address":"","comment_id":310594,"utype":1}],"discussion_count":2,"race_medal":1,"score":"5925730389","product_id":100013101,"comment_content":"建议作者多补充一些原型图片，这样内容理解起来会更直观。比如iface的结构模型。","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526287,"discussion_content":"谢谢你的建议。不过我非常建议你去看一下Go语言源码，然后自己画出来，这样很有助于学习和巩固。\n\n我在专栏里一再建议大家看完文章后去看看源码，甚至我会在很多回复中催着大家去源码。这非常非常重要。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630900130,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1324863,"avatar":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","nickname":"KK","note":"","ucode":"FFC31A3FE3A285","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393611,"discussion_content":"好的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631517251,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":302512,"user_name":"Gin","can_delete":false,"product_type":"c1","uid":1024844,"ip_address":"","ucode":"4BE570597DB661","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a3/4c/192de155.jpg","comment_is_top":false,"comment_ctime":1626245539,"is_pvip":false,"replies":[{"id":"109532","content":"在这种情况下，如果方法名称一致，方法签名就必须一致。因为Go语言没有方法重载，只有方法遮蔽。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1626329443,"ip_address":"","comment_id":302512,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5921212835","product_id":100013101,"comment_content":"老师，您好：<br>我测试的时候，如果接口包含的接口声明的方法有重名，但是签名一致的时候是可以正常运行的。但是如果签名不一致才会编译报错。<br><br>type T11 interface {<br>\tName(string2 string)<br>}<br>type T12 interface {<br>\tName(string2 string)<br>}<br>type T1 interface {<br>\tT11<br>\tT12<br>}","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523333,"discussion_content":"在这种情况下，如果方法名称一致，方法签名就必须一致。因为Go语言没有方法重载，只有方法遮蔽。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626329443,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":292872,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1621046599,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5916013895","product_id":100013101,"comment_content":"var pet Pet = dog *Dog &#47;&#47;保存一个nil对象值，可以调用指针类型的方法，调用值类型方法的时候需要复制，无值可复制，会panic<br>var pet Pet = dog Dog &#47;&#47;保存 Dog{}，可以调用值类型的方法","like_count":1,"discussions":[{"author":{"id":1351076,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","nickname":"lesserror","note":"","ucode":"25A54D1165FCF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386753,"discussion_content":"不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627782630,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":289005,"user_name":"moonfox","can_delete":false,"product_type":"c1","uid":1526355,"ip_address":"","ucode":"902BFF40EFA9FA","user_header":"https://static001.geekbang.org/account/avatar/00/17/4a/53/063f9d17.jpg","comment_is_top":false,"comment_ctime":1618817565,"is_pvip":false,"replies":[{"id":"104914","content":"不错，你的答案中包含了正确答案。但是关于 1. 的内容，我的问题压根就没问啊。注意避免过度设计：）","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1618898905,"ip_address":"","comment_id":289005,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5913784861","product_id":100013101,"comment_content":"思考题<br><br>问：把一个值为nil的某个实现类型的变量赋给了接口变量，是否可以在这个接口变量上调用该接口的方法<br><br>答：<br>1. 值类型(T)的方法不能被调用，无论这个方法中是否涉及了对类型属性的调用<br>2. 指针类型(*T)的方法可以被调用，但方法中不能涉及类型属性的调用","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518791,"discussion_content":"不错，你的答案中包含了正确答案。但是关于 1. 的内容，我的问题压根就没问啊。注意避免过度设计：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618898905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1526355,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4a/53/063f9d17.jpg","nickname":"moonfox","note":"","ucode":"902BFF40EFA9FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369046,"discussion_content":"天呀，居然现在还能得到作者回复，开心呀 ：p","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618911795,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":285584,"user_name":"吴笛","can_delete":false,"product_type":"c1","uid":2300180,"ip_address":"","ucode":"5C1262FCC3814B","user_header":"https://static001.geekbang.org/account/avatar/00/23/19/14/4fe2f992.jpg","comment_is_top":false,"comment_ctime":1616908177,"is_pvip":false,"replies":[{"id":"103677","content":"这就是一个语言的特点。底层逻辑是：“判断一个接口值的实际类型”。相对应的，Go语言也有“判断一个值的类型是否实现了某个接口”的语法。<br><br>Go语言的语法风格是规整的、严谨的，语法糖很少。这也跟它的编程哲学有关，即：针对一项功能只给出一个最佳实践（越少的实践选择 =&gt; 越高的开发效率）。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1616993871,"ip_address":"","comment_id":285584,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5911875473","product_id":100013101,"comment_content":"为啥类型断言表达式 x必须是接口类型? 如果没有实际用途完全可以封装到编译逻辑里吧, 每次还要转个空接口, 感觉多此一举","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517717,"discussion_content":"这就是一个语言的特点。底层逻辑是：“判断一个接口值的实际类型”。相对应的，Go语言也有“判断一个值的类型是否实现了某个接口”的语法。\n\nGo语言的语法风格是规整的、严谨的，语法糖很少。这也跟它的编程哲学有关，即：针对一项功能只给出一个最佳实践（越少的实践选择 =&amp;gt; 越高的开发效率）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616993871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":283316,"user_name":"MClink","can_delete":false,"product_type":"c1","uid":1435733,"ip_address":"","ucode":"F479190923355C","user_header":"https://static001.geekbang.org/account/avatar/00/15/e8/55/92f82281.jpg","comment_is_top":false,"comment_ctime":1615703037,"is_pvip":true,"replies":[{"id":"102817","content":"就是字面的意思，反过来说：如果不存在任何实现了接口A的类型，那么肯定就不存在接口A类型的值，或者说，没有任何一个值可以被赋给类型为接口A的变量。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1615787660,"ip_address":"","comment_id":283316,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5910670333","product_id":100013101,"comment_content":"对于某一个接口类型来说，如果没有任何数据类型可以作为它的实现，那么该接口的值就不可能存在。<br><br>没看懂啥意思","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516990,"discussion_content":"就是字面的意思，反过来说：如果不存在任何实现了接口A的类型，那么肯定就不存在接口A类型的值，或者说，没有任何一个值可以被赋给类型为接口A的变量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615787660,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":273073,"user_name":"hunterlodge","can_delete":false,"product_type":"c1","uid":1069755,"ip_address":"","ucode":"5B83A79E784161","user_header":"https://static001.geekbang.org/account/avatar/00/10/52/bb/225e70a6.jpg","comment_is_top":false,"comment_ctime":1610431741,"is_pvip":false,"replies":[{"id":"99017","content":"首先，只有实现了Pet接口的值才能被赋给变量pet。其次，&amp;dog是指针类型，而dog就不一定了（如果按文中示例的话，它是结构体类型），所以这两个的动态值肯定不同，动态类型也肯定不同。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1610515747,"ip_address":"","comment_id":273073,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5905399037","product_id":100013101,"comment_content":"请问老师，var pet Pet = &amp;dog和var pet Pet = dog，两种写法有何不同呢？两种情况下pet的动态值和动态类型应该都不相同，对吗？谢谢","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513483,"discussion_content":"首先，只有实现了Pet接口的值才能被赋给变量pet。其次，&amp;amp;dog是指针类型，而dog就不一定了（如果按文中示例的话，它是结构体类型），所以这两个的动态值肯定不同，动态类型也肯定不同。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610515747,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":260440,"user_name":"甜质粥","can_delete":false,"product_type":"c1","uid":2153136,"ip_address":"","ucode":"696E929660A124","user_header":"https://static001.geekbang.org/account/avatar/00/20/da/b0/a2425eca.jpg","comment_is_top":false,"comment_ctime":1605007087,"is_pvip":false,"replies":[{"id":"94614","content":"首先说一个问题，你这样的错误处理方式是非常危险的：<br><br>defer func() { recover() }()<br><br>再来说你问的事情。首先，你为什么要判断一个空接口为nil？？<br><br>空接口是一个可以包罗万象的东西，而我们使用强类型语言编程、使用类型来约束变量就是为了类型安全，为的就是具体情况具体分析。<br><br>所以为 interface{} 类型的值判空一般是没有应用场景的。这其实是需要避免的事情，即：不要传递类型为 interface{} 的变量或者值。当然了一些极特殊情况除外<br><br>至于 interface{} 类型的值什么时候真为nil，我在文章里已经说清楚了。所以，在你不知道这个参数值的具体类型的时候，是无法查看空接口中的“值”是否为nil的。另外，不要在这么简单的操作上用反射，太慢，而且这里的 IsNil() 也不是通用的。<br><br>我觉得你可能是在用“动态类型语言”的思想编“静态类型”语言的程。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1605064621,"ip_address":"","comment_id":260440,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5899974383","product_id":100013101,"comment_content":"为啥没有人问这个问题：<br>如果将空指针对象赋值给接口变量，那么如何对这个接口变量判nil？<br>看到有很别扭的答案：<br>func isNil(a interface{}) bool {<br>  defer func() { recover() }()<br>  return a == nil || reflect.ValueOf(a).IsNil()<br>}<br>google邮件列表中也没有提及更好的方法（这里https:&#47;&#47;groups.google.com&#47;g&#47;golang-nuts&#47;c&#47;wnH302gBa4I&#47;discussion）<br>老师，您有更好的方法判断吗","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509194,"discussion_content":"首先说一个问题，你这样的错误处理方式是非常危险的：\n\ndefer func() { recover() }()\n\n再来说你问的事情。首先，你为什么要判断一个空接口为nil？？\n\n空接口是一个可以包罗万象的东西，而我们使用强类型语言编程、使用类型来约束变量就是为了类型安全，为的就是具体情况具体分析。\n\n所以为 interface{} 类型的值判空一般是没有应用场景的。这其实是需要避免的事情，即：不要传递类型为 interface{} 的变量或者值。当然了一些极特殊情况除外\n\n至于 interface{} 类型的值什么时候真为nil，我在文章里已经说清楚了。所以，在你不知道这个参数值的具体类型的时候，是无法查看空接口中的“值”是否为nil的。另外，不要在这么简单的操作上用反射，太慢，而且这里的 IsNil() 也不是通用的。\n\n我觉得你可能是在用“动态类型语言”的思想编“静态类型”语言的程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605064621,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188917,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1584434001,"is_pvip":false,"replies":[{"id":"73001","content":"你可以试试看：）","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1584502570,"ip_address":"","comment_id":188917,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5879401297","product_id":100013101,"comment_content":"关于思考题 我觉得可以调用只要不修改调用者的内容就不会出错 就像C++的指针","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487564,"discussion_content":"你可以试试看：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584502570,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188915,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1584433755,"is_pvip":false,"replies":[{"id":"73002","content":"理所应当，强类型的语言一般都是这样的。声明是什么类型的很重要。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1584502917,"ip_address":"","comment_id":188915,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5879401051","product_id":100013101,"comment_content":"刚刚我又去测试了demon31.go 我让接口声明里面没有Category方法<br>然后用dog赋值给pet 用pet去调用Category编译不通过 说pet没有Categroy方法说明 用接口类型去调用方法时 只能调用接口声明的方法,虽然他的动态类型是dog","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487563,"discussion_content":"理所应当，强类型的语言一般都是这样的。声明是什么类型的很重要。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584502917,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181570,"user_name":"oscarwin","can_delete":false,"product_type":"c1","uid":1131956,"ip_address":"","ucode":"492430BA342593","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/b4/ec66d499.jpg","comment_is_top":false,"comment_ctime":1582561067,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5877528363","product_id":100013101,"comment_content":"package main<br><br>import &quot;fmt&quot;<br><br>type animal interface {<br>\tSetName(name string)<br>\tAge() uint8<br>\tCall()<br>\tJump()<br>}<br><br>type cat struct {<br>\tname string<br>\tage  uint8<br>}<br><br>func (c cat) SetName(name string) {<br>\tc.name = name<br>}<br><br>func (c *cat) Age() uint8 {<br>\treturn c.age<br>}<br><br>func (c *cat) Call() {<br>\tfmt.Println(&quot;mie........&quot;)<br>}<br><br>func (c cat) Jump() {<br>\tfmt.Println(&quot;jump.......&quot;)<br>}<br><br>func main() {<br>\tvar c *cat<br>\tvar a animal = c<br>\tif c == nil {<br>\t\tfmt.Println(&quot;c is nil&quot;)<br>\t}<br>\tif a == nil {<br>\t\tfmt.Println(&quot;a is nil&quot;)<br>\t} else {<br>\t\ta.Call()<br>\t\ta.Jump() &#47;&#47; panic<br>\t\tfmt.Println(a.Age()) &#47;&#47; panic<br>\t}<br>}<br>回答一下思考题：<br>值为 nil 的时候也可以调用该接口的方法，前提有两个。<br>1.  对象方法的是用指针类型实现的<br>2. 调用的方法不能依赖该对象<br><br>为什么需要前提1？<br>因为是方法是为指针实现，指针可以指向 nil，但是如果是一个接口体是不能指向 nil 的，结构体的空值是 {}<br><br>为什么需要前提2？<br>这一点应该很好理解，不依赖这个对象就不需要访问与这对象实例相关的内存。通过接口赋值的动态类型，找该类型的注册的函数的地址，然后进行调用即可。","like_count":1},{"had_liked":false,"id":61395,"user_name":"先听","can_delete":false,"product_type":"c1","uid":1151409,"ip_address":"","ucode":"82D8DA7A2FEB4B","user_header":"https://static001.geekbang.org/account/avatar/00/11/91/b1/fb117c21.jpg","comment_is_top":false,"comment_ctime":1547689661,"is_pvip":false,"replies":[{"id":"25238","content":"这种设计实际上依从的是基本值和指针值的设计思路。在设计灵活性上会有一些好处。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1551180717,"ip_address":"","comment_id":61395,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5842656957","product_id":100013101,"comment_content":"go语言里面有值方法和指针方法，请问这样设计的目的和好处有哪些呢？","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436862,"discussion_content":"这种设计实际上依从的是基本值和指针值的设计思路。在设计灵活性上会有一些好处。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551180717,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":58612,"user_name":"lyy","can_delete":false,"product_type":"c1","uid":1353968,"ip_address":"","ucode":"62A3647DE66EBB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/vDQCL1bnecibWJbvA7iaZiaejFAAGXefPTrjeh26AKfN9HczKCEgGoqIUmicG4xatQicQB3BOuEZcicqp7EczOkticgeQ/132","comment_is_top":false,"comment_ctime":1547135960,"is_pvip":false,"replies":[{"id":"21289","content":"往后看啊，要不我剧透一下吧，接口算是。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1547205670,"ip_address":"","comment_id":58612,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5842103256","product_id":100013101,"comment_content":"今天在网上搜go的引用类型，有些人有提到接口，有些人没有提到。老师的第7节里讲到切片的时候，说起引用类型，也是没把接口提及在内。<br>请问 接口也是引用类型吗？","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436138,"discussion_content":"往后看啊，要不我剧透一下吧，接口算是。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547205670,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34917,"user_name":"到不了的塔","can_delete":false,"product_type":"c1","uid":1258362,"ip_address":"","ucode":"0F5BE3CB58DE31","user_header":"https://static001.geekbang.org/account/avatar/00/13/33/7a/ac307bfc.jpg","comment_is_top":false,"comment_ctime":1540353360,"is_pvip":false,"replies":[{"id":"13316","content":"runtime包中有个叫slice的结构体类型。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1541482481,"ip_address":"","comment_id":34917,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5835320656","product_id":100013101,"comment_content":"接口变量使用的数据结构是iface，那引用类型使用的数据结构又是什么呢，比如slice","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427387,"discussion_content":"runtime包中有个叫slice的结构体类型。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541482481,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":24918,"user_name":"Geek_1b0d68","can_delete":false,"product_type":"c1","uid":1204567,"ip_address":"","ucode":"219153A88F0CAC","user_header":"https://static001.geekbang.org/account/avatar/00/12/61/57/c5ce7c71.jpg","comment_is_top":false,"comment_ctime":1537230570,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5832197866","product_id":100013101,"comment_content":"由于把值为nil的变量赋值给了接口变量，接口变量在调用时只能调用该实现类型的指针方法，而无法调用值方法。为什么值方法只能实现了该类型的对象或者对象指针才能够调用？","like_count":1},{"had_liked":false,"id":24096,"user_name":"忘怀","can_delete":false,"product_type":"c1","uid":1024839,"ip_address":"","ucode":"1DF55045285958","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a3/47/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1536802003,"is_pvip":false,"replies":[{"id":"8930","content":"不是，浅拷贝。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1536975565,"ip_address":"","comment_id":24096,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5831769299","product_id":100013101,"comment_content":"老师，副本是深拷贝出来的吧？","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423839,"discussion_content":"不是，浅拷贝。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1536975565,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":357755,"user_name":"朱元彬🗿","can_delete":false,"product_type":"c1","uid":2725689,"ip_address":"北京","ucode":"9CBD43225EE65B","user_header":"https://static001.geekbang.org/account/avatar/00/29/97/39/1f5c6350.jpg","comment_is_top":false,"comment_ctime":1663601467,"is_pvip":false,"replies":[{"id":"130349","content":"说实话， demo34中的类型层次结构算是很简单的了。<br><br>在Go语言中，类型层次有两大层——接口和结构体。再往细了说，一个接口可以嵌入到其他接口里，一个结构体也可以嵌入到其他结构体当中去。<br><br>不过，只有在人工判断一个结构体实现了哪些接口的时候，可能才需要逐一比对它们二者的方法集合。现代的代码编辑器（如：vscode）或IDE（如：goland）都有“一键查看”的方法，还是很方便的。<br><br>要是用代码自动判断的话，直接用类型转换的方式就可以，如demo34中的： _, ok := interface{}(petTag).(Named)  。<br><br>要说规范的话，作为一个团队的开发规范其实有不少东西的。比如“在结构体类型注释中注明它实现的接口”（注释规范），又比如，”在同一模块中的接口类型声明需要分门别类并集中地写在一起”（代码组织规范），等等。","user_name":"作者回复","user_name_real":"作者","uid":"1026643","ctime":1664017686,"ip_address":"北京","comment_id":357755,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1663601467","product_id":100013101,"comment_content":"接口组合确实很灵活，但是看demo34的时候，光靠阅读代码向高清他们的组合关系 真的是看的头皮发麻。我很想知道，现实开发时对于组合有什么规范，不至于搞得太复杂导致代码难以阅读？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588723,"discussion_content":"说实话， demo34中的类型层次结构算是很简单的了。\n\n在Go语言中，类型层次有两大层——接口和结构体。再往细了说，一个接口可以嵌入到其他接口里，一个结构体也可以嵌入到其他结构体当中去。\n\n不过，只有在人工判断一个结构体实现了哪些接口的时候，可能才需要逐一比对它们二者的方法集合。现代的代码编辑器（如：vscode）或IDE（如：goland）都有“一键查看”的方法，还是很方便的。\n\n要是用代码自动判断的话，直接用类型转换的方式就可以，如demo34中的： _, ok := interface{}(petTag).(Named)  。\n\n要说规范的话，作为一个团队的开发规范其实有不少东西的。比如“在结构体类型注释中注明它实现的接口”（注释规范），又比如，”在同一模块中的接口类型声明需要分门别类并集中地写在一起”（代码组织规范），等等。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1664017686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":356666,"user_name":"党","can_delete":false,"product_type":"c1","uid":1071974,"ip_address":"北京","ucode":"EE531DB3EA124D","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/66/ad35bc68.jpg","comment_is_top":false,"comment_ctime":1662478642,"is_pvip":false,"replies":[{"id":"129829","content":"这里的“类型信息”不只包含动态类型信息。文中有这么一句话，你可以再看一看：<br><br>iface的实例会包含两个指针，一个是指向类型信息的指针，另一个是指向动态值的指针。这里的类型信息是由另一个专用数据结构的实例承载的，其中包含了动态值的类型，以及使它实现了接口的方法和调用它们的途径，等等。<br><br>更具体的东西你可以去看源代码：runtime2.go -&gt; type itab struct {...}","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1662524775,"ip_address":"北京","comment_id":356666,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1662478642","product_id":100013101,"comment_content":"“iface的实例会包含两个指针，一个是指向类型信息的指针”这句话里为啥叫类型信息而不是动态类型信息？是不是这里的类型信息包括指针类型和动态类型信息啊","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586811,"discussion_content":"这里的“类型信息”不只包含动态类型信息。文中有这么一句话，你可以再看一看：\n\niface的实例会包含两个指针，一个是指向类型信息的指针，另一个是指向动态值的指针。这里的类型信息是由另一个专用数据结构的实例承载的，其中包含了动态值的类型，以及使它实现了接口的方法和调用它们的途径，等等。\n\n更具体的东西你可以去看源代码：runtime2.go -&gt; type itab struct {...}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662524775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":356424,"user_name":"党","can_delete":false,"product_type":"c1","uid":1071974,"ip_address":"北京","ucode":"EE531DB3EA124D","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/66/ad35bc68.jpg","comment_is_top":false,"comment_ctime":1662294019,"is_pvip":false,"replies":[{"id":"129767","content":"是的","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1662346058,"ip_address":"北京","comment_id":356424,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1662294019","product_id":100013101,"comment_content":"第二遍刷了<br>我来回答一下问题 关键点在interface结构包括动态值指针和类型指针 动态值为nil 但是有类型 所以可以调用该接口方法 注意项就是方法中千万不要引用任何值相关的变量 不然就会报错 <br>","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586565,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662346059,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":354003,"user_name":"Geek_superkai","can_delete":false,"product_type":"c1","uid":2997610,"ip_address":"北京","ucode":"11BD59E867CEF8","user_header":"","comment_is_top":false,"comment_ctime":1660008352,"is_pvip":true,"replies":[{"id":"128783","content":"意思是，判断 dog 的类型是否实现了 Pet 接口。具体可参看 Go 语言的语法规范。<br><br>我记得我在这一课中也回答过别的同学，你有时间的话可以找找看。<br><br>还有什么不明白的地方可以接着问我。我几乎每天都会找个时间上来答疑的：）","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1660051710,"ip_address":"北京","comment_id":354003,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1660008352","product_id":100013101,"comment_content":"老师，您好：<br>interface{}(dog).(Pet) 这样写语法是什么意思的?感觉有些写法可以解释一下比较好","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583354,"discussion_content":"意思是，判断 dog 的类型是否实现了 Pet 接口。具体可参看 Go 语言的语法规范。\n\n我记得我在这一课中也回答过别的同学，你有时间的话可以找找看。\n\n还有什么不明白的地方可以接着问我。我几乎每天都会找个时间上来答疑的：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660051710,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":353188,"user_name":"JDY","can_delete":false,"product_type":"c1","uid":1848474,"ip_address":"北京","ucode":"4B6F55332BE6DC","user_header":"https://static001.geekbang.org/account/avatar/00/1c/34/9a/1587bc6f.jpg","comment_is_top":false,"comment_ctime":1659245957,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1659245957","product_id":100013101,"comment_content":"不知道是我道行太浅还是咋了，这节总感觉很浅。","like_count":0},{"had_liked":false,"id":346161,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1217554,"ip_address":"","ucode":"C5A540BC5A60B9","user_header":"https://static001.geekbang.org/account/avatar/00/12/94/12/15558f28.jpg","comment_is_top":false,"comment_ctime":1652862331,"is_pvip":false,"replies":[{"id":"126635","content":"Dog 的方法集合 与 *Dog的方法集合 完全是两码事啊。结构体的方法集合涉及到接口的实现，是一个很严谨的概念。Go语言的语法糖是很少的，只有在“不增加认知成本 且 确实可以极大的方便开发者”的时候才会添加语法糖。","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1653894100,"ip_address":"","comment_id":346161,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1652862331","product_id":100013101,"comment_content":"老师，针对interface在receiver的这种场景下，为什么go不能自动将p也通过语法糖变成*Dog<br>type property interface {<br>\tName() string<br>\tSetName(string)<br>}<br><br>type Dog struct {<br>\tDName string<br>}<br><br>func (d Dog) Name() string {<br>\treturn d.DName<br>}<br><br>func (d *Dog) SetName(name string) {<br>\td.DName = name<br>}<br><br>func TestInterface(t *testing.T) {<br>\tvar p property = Dog{DName: &quot;sss&quot;}<br>}","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574193,"discussion_content":"Dog 的方法集合 与 *Dog的方法集合 完全是两码事啊。结构体的方法集合涉及到接口的实现，是一个很严谨的概念。Go语言的语法糖是很少的，只有在“不增加认知成本 且 确实可以极大的方便开发者”的时候才会添加语法糖。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653894100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346157,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1217554,"ip_address":"","ucode":"C5A540BC5A60B9","user_header":"https://static001.geekbang.org/account/avatar/00/12/94/12/15558f28.jpg","comment_is_top":false,"comment_ctime":1652861795,"is_pvip":false,"replies":[{"id":"126634","content":"不好意思，没太看懂。接口有自己的方法集合，自定义结构体也有自己的方法集合（针对结构体本身的方法集合 和 针对其指针的方法集合）。只有后者是前者（即某接口的方法集合）的超集的时候，才能说那个结构体的原值或者结构体的指针值实现了那个接口。<br><br>接口与结构体不同的。接口本身就一种行为定义，它的内部结构也是一种指针（确切的说，是多个指针的组合），所以也就不存在接口的原值和指针值。Go语言中没有这种概念。而结构体类型是一种值类型，所以才存在“结构体类型的指针值”这种说法。","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1653893917,"ip_address":"","comment_id":346157,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1652861795","product_id":100013101,"comment_content":"老师，针对interface和receiver这一块，我有个疑问。既然针对自定义结构自己的方法，go允许是用语法糖将源对象类型转出receiver类型。那为什么go不能将赋值给interface的对象也赋予这种能力呢？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574192,"discussion_content":"不好意思，没太看懂。接口有自己的方法集合，自定义结构体也有自己的方法集合（针对结构体本身的方法集合 和 针对其指针的方法集合）。只有后者是前者（即某接口的方法集合）的超集的时候，才能说那个结构体的原值或者结构体的指针值实现了那个接口。\n\n接口与结构体不同的。接口本身就一种行为定义，它的内部结构也是一种指针（确切的说，是多个指针的组合），所以也就不存在接口的原值和指针值。Go语言中没有这种概念。而结构体类型是一种值类型，所以才存在“结构体类型的指针值”这种说法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653893917,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344169,"user_name":"cake","can_delete":false,"product_type":"c1","uid":1966533,"ip_address":"","ucode":"55A7FC6CC1204C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/01/c5/b48d25da.jpg","comment_is_top":false,"comment_ctime":1651320602,"is_pvip":false,"replies":[{"id":"126115","content":"以及 使它实现了接口的方法 和 调用它们的途径","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1652409947,"ip_address":"","comment_id":344169,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1651320602","product_id":100013101,"comment_content":"以及使它实现了接口的方法和调用它们的途径，等等。  这句话读的通吗？ 怎么断句？？？？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571789,"discussion_content":"以及 使它实现了接口的方法 和 调用它们的途径","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652409947,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342445,"user_name":"Geek_as","can_delete":false,"product_type":"c1","uid":1534500,"ip_address":"","ucode":"AB7B70DBC2B5F8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/qhonwcQle1RBufvLdTm4MgSNl554GBXUZtNNH65oYajbbRLxKsZX4hM9vFtrLLpDM0H93ZNWRFAZSrIZC7yAsQ/132","comment_is_top":false,"comment_ctime":1650266705,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650266705","product_id":100013101,"comment_content":"假如将某个类型的空值赋给接口后，接口依旧可以调用类型的方法，但无法访问空值的属性，假如访问了就会报错，因为空值无法访问属性，感觉这个接口调用类型方法，有点像java调用类的静态方法，不管你的值是否Null，都可以调用","like_count":0},{"had_liked":false,"id":338648,"user_name":"喬","can_delete":false,"product_type":"c1","uid":2915857,"ip_address":"","ucode":"945CA9205ED16B","user_header":"https://static001.geekbang.org/account/avatar/00/2c/7e/11/8dc0723a.jpg","comment_is_top":false,"comment_ctime":1647619849,"is_pvip":true,"replies":[{"id":"123891","content":"很好，是这么回事。","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1647840205,"ip_address":"","comment_id":338648,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1647619849","product_id":100013101,"comment_content":"思考题：<br><br>我的理解是这样的，不知道思路合适不合适。<br>例如下面代码：<br>type cat struct {<br>\tname string<br>}<br><br>func (c cat) getName() string {<br>\treturn c.name<br>}<br><br>func (c *cat) setName(name string) {<br>\tc.name = name<br>}<br><br>type catI interface {<br>\tgetName() string<br>\tsetName(name string)<br>}<br><br>func main() {<br>\tvar c *cat<br>\tvar cI catI = c<br>\tcI.setName(&quot;name&quot;)<br>\tfmt.Println(cI.getName())<br>}<br><br>cI.setName(name string)  等同于  setName(c *cat, name string)<br>cI.getName() string      等同于  getName(c cat)<br><br>当变量值为nil时，c 为空指针，没有分配内存空间 值为 0x0<br>指针类型方法：在执行setName时，函数签名条件满足，所以可以被调用。但是由于 c 还未分配内存空间，在操作类型属性时会出现 panic<br>值类型方法：在执行getName时，虽golang提供 (*c).getName 语法糖 (将指针转化为值类型并调用方法)，但是由于指针为nil，因此在转化为值类型时会出现 panic<br><br>结论：<br>对于值为nil的实现类型，只能操作其指针类型方法，且方法内不能出现类型属性值的操作<br>","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557506,"discussion_content":"很好，是这么回事。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647840205,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331800,"user_name":"黄仲辉","can_delete":false,"product_type":"c1","uid":1593521,"ip_address":"","ucode":"D7EB3C3ADD99DA","user_header":"https://static001.geekbang.org/account/avatar/00/18/50/b1/7b701518.jpg","comment_is_top":false,"comment_ctime":1642770184,"is_pvip":false,"replies":[{"id":"121292","content":"这与松不松耦合其实没什么关系。松耦合是程序开发者需要遵循的原则，与这里说的是两码事。这种接口实现方式是一种编程语言的设计范式，其他一些语言也是如此设计的。作为这样的程序，如果接口的变化没有循序向后兼容的原则，编译器一定会在必要时编译不通过并报错。如果实现接口的类型有变化，导致未实现原先的接口，那么编译器会在程序中相应的类型判断处（如果有的话）报错。所以放心吧。","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1642945282,"ip_address":"","comment_id":331800,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1642770184","product_id":100013101,"comment_content":"这种松耦合，接口修改时，怎么分析关联影响呢？是否会存在编译时无法发现的问题？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547934,"discussion_content":"这与松不松耦合其实没什么关系。松耦合是程序开发者需要遵循的原则，与这里说的是两码事。这种接口实现方式是一种编程语言的设计范式，其他一些语言也是如此设计的。作为这样的程序，如果接口的变化没有循序向后兼容的原则，编译器一定会在必要时编译不通过并报错。如果实现接口的类型有变化，导致未实现原先的接口，那么编译器会在程序中相应的类型判断处（如果有的话）报错。所以放心吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642945282,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329514,"user_name":"无名无姓","can_delete":false,"product_type":"c1","uid":2621412,"ip_address":"","ucode":"487BD5AA2CD305","user_header":"https://static001.geekbang.org/account/avatar/00/27/ff/e4/927547a9.jpg","comment_is_top":false,"comment_ctime":1641382420,"is_pvip":true,"replies":[{"id":"120041","content":"这个判断的意思是，这个值的类型是否实现了那个接口。<br><br>至于业务场景。比如，一旦鉴定这个值的类型实现了某个接口，就说明它具有某种特性（比如特殊的方法、行为之类的）。<br><br>另外，接口的功用不只是定义一套行为规范，还可以作为一种“标记”（标明实现它的类型拥有某一种特殊的“才能”或“特质”）。这样的接口类型甚至可以只包含一个非常简单但名称非常独特的方法声明。实现了这个方法的类型就等于被打上了对应的“标记”。<br><br>不论这里的接口是做什么用的，我们都可以根据这种类型判断进行下一步的操作。比如，一旦发现这只 dog 属于 Pet，我们就把它放到宠物店，否则这只 dog 就是“野狗”，我们就把它放到救助站。","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1641436795,"ip_address":"","comment_id":329514,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1641382420","product_id":100013101,"comment_content":"_, ok := interface{}(dog).(Pet)，老师在问下，这个应用什么业务场景，为什么这样判断呢","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544189,"discussion_content":"这个判断的意思是，这个值的类型是否实现了那个接口。\n\n至于业务场景。比如，一旦鉴定这个值的类型实现了某个接口，就说明它具有某种特性（比如特殊的方法、行为之类的）。\n\n另外，接口的功用不只是定义一套行为规范，还可以作为一种“标记”（标明实现它的类型拥有某一种特殊的“才能”或“特质”）。这样的接口类型甚至可以只包含一个非常简单但名称非常独特的方法声明。实现了这个方法的类型就等于被打上了对应的“标记”。\n\n不论这里的接口是做什么用的，我们都可以根据这种类型判断进行下一步的操作。比如，一旦发现这只 dog 属于 Pet，我们就把它放到宠物店，否则这只 dog 就是“野狗”，我们就把它放到救助站。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641436795,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319900,"user_name":"小树苗","can_delete":false,"product_type":"c1","uid":1644500,"ip_address":"","ucode":"71288176D058E2","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqtnoXPFibFwKdrUibJQWYSCmAlc7FeEH5MbjiawszNgwEXAkuWKGYQMTQbnQbjlR8n9lpDgN4GQHoXQ/132","comment_is_top":false,"comment_ctime":1636003781,"is_pvip":false,"replies":[{"id":"116033","content":"你仔细看一下 panic 后输出的信息，定位一下是哪一行代码出的问题，然后再猜测一下问题所在。如果之后还不明白再来问我。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1636091417,"ip_address":"","comment_id":319900,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1636003781","product_id":100013101,"comment_content":"老师，你好：<br>思考题：<br>我这边实验好像不能调用该接口的方法，不知道是我理解的问题还是版本问题（1.19），代码：<br>package main<br><br>import (<br>\t&quot;fmt&quot;<br>\t&quot;reflect&quot;<br>)<br><br>type Pet interface {<br>\tName() string<br>\tCategory() string<br>}<br><br>type Dog struct {<br>\tname string &#47;&#47; 名字。<br>}<br><br>func (dog *Dog) SetName(name string) {<br>\tdog.name = name<br>}<br><br>func (dog *Dog) Name() string {<br>\treturn dog.name<br>}<br><br>func (dog Dog) Category() string {<br>\treturn &quot;dog&quot;<br>}<br><br>func main() {<br>\t&#47;&#47; 示例1。<br>\tvar dog1 *Dog<br>\tfmt.Println(&quot;The first dog is nil.&quot;)<br>\tdog2 := dog1<br>\tfmt.Println(&quot;The second dog is nil.&quot;)<br>\tvar pet Pet = dog2<br>\tif pet == nil {<br>\t\tfmt.Println(&quot;The pet is nil.&quot;)<br>\t} else {<br>\t\tfmt.Println(&quot;The pet is not nil.&quot;)<br>\t}<br>\tfmt.Printf(&quot;The type of pet is %T.\\n&quot;, pet)<br>\tfmt.Printf(&quot;The type of pet is %s.\\n&quot;, reflect.TypeOf(pet).String())<br>\tfmt.Printf(&quot;The type of second dog is %T.\\n&quot;, dog2)<br>\tfmt.Println()<br><br>\t&#47;&#47; 思考题<br>\tfmt.Print(pet.Name())<br><br>\tfmt.Println()<br><br>}<br><br>","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529807,"discussion_content":"你仔细看一下 panic 后输出的信息，定位一下是哪一行代码出的问题，然后再猜测一下问题所在。如果之后还不明白再来问我。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636091417,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1644500,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqtnoXPFibFwKdrUibJQWYSCmAlc7FeEH5MbjiawszNgwEXAkuWKGYQMTQbnQbjlR8n9lpDgN4GQHoXQ/132","nickname":"小树苗","note":"","ucode":"71288176D058E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":412176,"discussion_content":"明白了，报错证明了不能访问属性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636095203,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":310992,"user_name":"盘胧","can_delete":false,"product_type":"c1","uid":1650748,"ip_address":"","ucode":"5386CC4C92ECC2","user_header":"https://static001.geekbang.org/account/avatar/00/19/30/3c/0668d6ae.jpg","comment_is_top":false,"comment_ctime":1631010304,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631010304","product_id":100013101,"comment_content":" 讲真，太干了，一篇文章嚼两小时，还要自己测试","like_count":0},{"had_liked":false,"id":310593,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1630763048,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1630763048","product_id":100013101,"comment_content":"关于思考题：如果我们把一个值为nil的某个实现类型的变量赋给了接口变量，那么在这个接口变量上仍然可以调用该接口的方法吗？如果可以，有哪些注意事项？如果不可以，原因是什么？<br><br>答：不可以，nil调用方法会panic。","like_count":0},{"had_liked":false,"id":303388,"user_name":"Geek_3b0597","can_delete":false,"product_type":"c1","uid":2706243,"ip_address":"","ucode":"CBB5A846EC1CDF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/JBrBred9LVFSiawHSiblxbq2UrlpczDcmCyqrj8QfeeK4bQJEwO2az5FRE8fO5GC8yrcAKD7oS9UxlNdBLupJMxQ/132","comment_is_top":false,"comment_ctime":1626765427,"is_pvip":false,"replies":[{"id":"109860","content":"你想问什么啊？文中说的就是 iface 。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1626851458,"ip_address":"","comment_id":303388,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1626765427","product_id":100013101,"comment_content":"是runtime.iface还是runtime.eface","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523656,"discussion_content":"你想问什么啊？文中说的就是 iface 。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626851458,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":276926,"user_name":"BugBean","can_delete":false,"product_type":"c1","uid":1834181,"ip_address":"","ucode":"B51232281AD9BC","user_header":"https://static001.geekbang.org/account/avatar/00/1b/fc/c5/ff8b770e.jpg","comment_is_top":false,"comment_ctime":1612180331,"is_pvip":false,"replies":[{"id":"100515","content":"需要先判断动态类型，然后转换后进行判断。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1612242877,"ip_address":"","comment_id":276926,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1612180331","product_id":100013101,"comment_content":"请问老师，要判断一个接口类型的动态值是不是nil应该怎么判断","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514869,"discussion_content":"需要先判断动态类型，然后转换后进行判断。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612242877,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203744,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1217554,"ip_address":"","ucode":"C5A540BC5A60B9","user_header":"https://static001.geekbang.org/account/avatar/00/12/94/12/15558f28.jpg","comment_is_top":false,"comment_ctime":1586261939,"is_pvip":false,"replies":[{"id":"76919","content":"我不知道你说的 My 是指什么，你最好把代码贴出来给我看。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1586747764,"ip_address":"","comment_id":203744,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1586261939","product_id":100013101,"comment_content":"老师，关于思考题，如果使用var a My的方式赋给接口，能正常调用只是接口打印的是默认值。如果是var a *My，则运行报panic。是因为前者使用的是默认初始化，动态值非nil。而后者的动态值是nil，出错时因为空指针调用方法出错呢？还是访问结构中的成员出错呢？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490948,"discussion_content":"我不知道你说的 My 是指什么，你最好把代码贴出来给我看。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586747764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188909,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1584433117,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584433117","product_id":100013101,"comment_content":"今日课程总结:<br>Go 语言的接口常用于代表某种能力或某类特征(通过面向对象的方式去理解的话 就是一种隔离)<br>接口变量的基础<br>接口的静态类型 就是接口本身的类型<br>接口的动态值 就是赋值对象的值<br>接口的动态类型 就是赋值对象的类型<br>接口类型是一种专用的存储数据结构 包含两部分 一部分指向动态类型的实际类型(包含了方法和调用他们的地方)， 另一部分 指向动态类型的值的副本 所以 就算把一个值为nil的类型赋值给接口类型那么接口都不会为nil 只有未被赋值过的接口类型才为真正的nil<br>最好使用粒度比较小功能比较单一的接口，再通过把这些小的接口组合起来形成更大更灵活的框架","like_count":0},{"had_liked":false,"id":164941,"user_name":"lixiaofeng","can_delete":false,"product_type":"c1","uid":1100200,"ip_address":"","ucode":"0D6710D95B6FFB","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/a8/98507423.jpg","comment_is_top":false,"comment_ctime":1577114256,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577114256","product_id":100013101,"comment_content":"总结：<br>结构，表示实实在在的数据结构。<br>方法，它必须属于某一个类型，方法所属的类型通过其声明中的接受者体现出来。<br>一个字段的声明只有类型而没有名称，那么它就是一个嵌入字段或者叫做匿名字段。<br>针对匿名字段，我们可以使用匿名字段的字段类型引用到该字段。<br>Go语言中没有继承的概念，它所做的是通过嵌入字段实现了类型之间的组合。<br>一个数据类型，它的方法集合完全包含了一个接口的全部方法，那么他就是这个接口的实现类型。<br>Dog类型实现了pet 接口的全部方法。Dog类型的变量dog， 可以赋值给pet指针类型的pet变量。<br>接口类型的静态类型是它自己的名称字面量， 动态类型可能是变化的。<br>当我们给一个接口变量赋值时，该接口变量的动态类型和动态值被存储在一个专用的数据结构中。这个专门的数据结构叫做iface。iface中包括两个指针，一个指向类型信息的指针，一个指向动态值的指针。<br>当把一个变量赋值给一个接口变量时，该变量的值和接口变量的值肯定是不一样的，可以认为接口变量值包含了该变量的副本。<br>通过指针值，无缝的访问基本值包含的任何字段，以及调用与之关联的任何方法。","like_count":0},{"had_liked":false,"id":156758,"user_name":"疯琴","can_delete":false,"product_type":"c1","uid":1099379,"ip_address":"","ucode":"82ACAA4A27753D","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/73/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1574948554,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574948554","product_id":100013101,"comment_content":"讲得太精彩了，如饮醍醐。","like_count":0},{"had_liked":false,"id":133841,"user_name":"redrain","can_delete":false,"product_type":"c1","uid":1292965,"ip_address":"","ucode":"1013F15FA1A423","user_header":"https://static001.geekbang.org/account/avatar/00/13/ba/a5/9f5ab366.jpg","comment_is_top":false,"comment_ctime":1568682815,"is_pvip":false,"replies":[{"id":"51356","content":"当然，在这里：https:&#47;&#47;github.com&#47;hyper0x&#47;Golang_Puzzlers","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1568688750,"ip_address":"","comment_id":133841,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568682815","product_id":100013101,"comment_content":"代码都在github上吗，手机看文章的时候最好还是把代码直接贴出来","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467527,"discussion_content":"当然，在这里：https://github.com/hyper0x/Golang_Puzzlers","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568688750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118158,"user_name":"吴小智","can_delete":false,"product_type":"c1","uid":1310798,"ip_address":"","ucode":"C7C9F58B5C9F7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","comment_is_top":false,"comment_ctime":1564280921,"is_pvip":false,"replies":[{"id":"43297","content":"不是。slice 的底层数组没有被复制过去。你对 dog.names 的修改没影响 pet，是因为你对 dog.names 重新赋值了。这时候，与 dog.names 绑定的是一个新的 slice，而这个新的 slice 的底层数组也不是原 slice 的底层数组了，因为原先那个容纳不下 3 个元素值。<br><br>另外，你的输入内容明显与你的代码逻辑对不上啊。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1564284596,"ip_address":"","comment_id":118158,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1564280921","product_id":100013101,"comment_content":"package main<br><br>import (<br>\t&quot;fmt&quot;<br>)<br><br>type Pet interface {<br>\tCategory() string<br>\tNames() []string<br>}<br><br>type Dog struct {<br>\tnames []string<br>}<br><br>func (dog *Dog) SetNames(names []string) {<br>\tdog.names = names<br>}<br><br>func (dog Dog) Category() string {<br>\treturn &quot;dog&quot;<br>}<br><br>func(dog Dog) Names() []string {<br>\treturn dog.names<br>}<br><br>func main() {<br>\t&#47;&#47; 示例1。<br>\tdog := Dog{[]string{&quot;one&quot;,&quot;twice&quot;}}<br>\tfmt.Printf(&quot;The dog&#39;s names is %v.\\n&quot;, dog.Names())<br>\tvar pet Pet = dog<br>\tdog.names = append(dog.names,&quot;three&quot;)<br>\tfmt.Printf(&quot;The dog&#39;s name is %v.\\n&quot;, dog.Names())<br>\tfmt.Printf(&quot;This pet is a %s, the name is %q.\\n&quot;,<br>\t\tpet.Category(), pet.Names())<br>\tfmt.Println()<br><br>}<br><br>上述代码输出：<br><br>The dog&#39;s names is [one twice].<br>The dog&#39;s name is [other].<br>This pet is a dog, the name is [&quot;one&quot; &quot;twice&quot;].<br><br>这样是不是就是说明 Pet 里的  Dog 副本，是完完全全的一个副本，slice 这样的引用类型也会完全复制过去？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460283,"discussion_content":"不是。slice 的底层数组没有被复制过去。你对 dog.names 的修改没影响 pet，是因为你对 dog.names 重新赋值了。这时候，与 dog.names 绑定的是一个新的 slice，而这个新的 slice 的底层数组也不是原 slice 的底层数组了，因为原先那个容纳不下 3 个元素值。\n\n另外，你的输入内容明显与你的代码逻辑对不上啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564284596,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109102,"user_name":"Geek_a8be59","can_delete":false,"product_type":"c1","uid":1563985,"ip_address":"","ucode":"BEC0F57B51DC44","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKdiaUiaCYQe9tibemaNU5ya7RrU3MYcSGEIG7zF27u0ZDnZs5lYxPb7KPrAsj3bibM79QIOnPXAatfIw/132","comment_is_top":false,"comment_ctime":1561962629,"is_pvip":false,"replies":[{"id":"39849","content":"ModifyName 需要是一个指针方法才可以。接收者变量的值会是当前值的一个拷贝。我记得在讲结构体的时候说过了。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1562156086,"ip_address":"","comment_id":109102,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561962629","product_id":100013101,"comment_content":"老实，您好：<br>根据您说的我试了一下下面这种<br>package main<br><br>import (<br>\t&quot;fmt&quot;<br><br>)<br><br>type Pet interface {<br>\tName() string<br>\tCategory() string<br>\tSetName(name string)<br>\tModifyName(name string)<br>}<br><br>type Dog struct {<br>\tname string &#47;&#47; 名字。<br>}<br><br>func (dog *Dog) SetName(name string) {<br>\tdog.name = name<br>}<br><br>func (dog Dog) Name() string {<br>\treturn dog.name<br>}<br><br>func (dog Dog) ModifyName(name string)  {<br>\tdog.name = name<br>}<br><br>func (dog Dog) Category() string {<br>\treturn &quot;dog&quot;<br>}<br><br>func main() {<br>\t&#47;&#47; 示例1。<br>\tvar dog  = new(Dog)<br>\tvar pet Pet = dog<br>\tpet.ModifyName(&quot;This is test name&quot;)<br>\tfmt.Println(dog.name)<br>\tfmt.Println(dog.Name())<br>\tfmt.Println(pet.Name())<br>}<br>结果都为空。我能理解接口的动态类型值为Dog的地址的副本，那我照这样修改到底是修改的哪部分的值呢，pet拷贝的副本值没有改变，dog的值也没有改变，难道是iface还拷贝了一份非Dog地址的副本么？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456243,"discussion_content":"ModifyName 需要是一个指针方法才可以。接收者变量的值会是当前值的一个拷贝。我记得在讲结构体的时候说过了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562156086,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87597,"user_name":"张sir","can_delete":false,"product_type":"c1","uid":1209431,"ip_address":"","ucode":"52958DF6705208","user_header":"https://static001.geekbang.org/account/avatar/00/12/74/57/7b828263.jpg","comment_is_top":false,"comment_ctime":1555639637,"is_pvip":false,"replies":[{"id":"31514","content":"像 &amp;dog 这种式子要先分开来看，“dog”是一个变量并代表了一个 Dog 类型的值，“&amp;”是一个操作符并代表了取址操作。合在一起就是一个表达式，含义是获取一个指针值，这个指针值指向了变量 dog 代表的那个值。<br><br>又因为 *Dog 类型实现了 Pet 接口，所以才能把这样一个指针值赋给变量 pet 。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1555651826,"ip_address":"","comment_id":87597,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555639637","product_id":100013101,"comment_content":"var pet Pet = &amp;dog<br><br>Pet是个指针类型，不是不能通过字面量来表示一个值吗，这种赋值操作代表什么","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447524,"discussion_content":"像 &amp;amp;dog 这种式子要先分开来看，“dog”是一个变量并代表了一个 Dog 类型的值，“&amp;amp;”是一个操作符并代表了取址操作。合在一起就是一个表达式，含义是获取一个指针值，这个指针值指向了变量 dog 代表的那个值。\n\n又因为 *Dog 类型实现了 Pet 接口，所以才能把这样一个指针值赋给变量 pet 。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555651826,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81480,"user_name":"枫林火山","can_delete":false,"product_type":"c1","uid":1199855,"ip_address":"","ucode":"66099C9D1AD36C","user_header":"https://static001.geekbang.org/account/avatar/00/12/4e/ef/2ad3effd.jpg","comment_is_top":false,"comment_ctime":1553923101,"is_pvip":true,"replies":[{"id":"29541","content":"嗯，确切地说：这个内嵌的匿名字段还没有被赋予具体的值。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1553949155,"ip_address":"","comment_id":81480,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553923101","product_id":100013101,"comment_content":"谢谢老师，有点理解了。内嵌接口不是声明了该类型实现了接口描述的能力，而是声明該类型有一个实现该接口的内嵌类型。<br>如果取消注释部分，直接打印dog.Animal.ScientificName()还是会报错，因为这个内嵌接口表示的类型一直没初始化😆。 <br>之前的理解还是下意识的往继承靠拢了","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445221,"discussion_content":"嗯，确切地说：这个内嵌的匿名字段还没有被赋予具体的值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553949155,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79739,"user_name":"小豆角","can_delete":false,"product_type":"c1","uid":1187321,"ip_address":"","ucode":"93FBADEB249C46","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLwSoTjHPX5tuvQ44WvwibibVoAdUSia3EdXP4fR3nyJUhLWUmVxl3jibMuVb8uZViaRsy5nAyzicBN06VA/132","comment_is_top":false,"comment_ctime":1553529109,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553529109","product_id":100013101,"comment_content":"讲的非常棒","like_count":0},{"had_liked":false,"id":69085,"user_name":"zhaopan","can_delete":false,"product_type":"c1","uid":1151132,"ip_address":"","ucode":"2AD77203285F6E","user_header":"https://static001.geekbang.org/account/avatar/00/11/90/9c/532446e4.jpg","comment_is_top":false,"comment_ctime":1550658356,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550658356","product_id":100013101,"comment_content":"var dog1 *Dog<br>fmt.Println(&quot;The first dog is nil.&quot;)<br>dog2 := dog1<br>fmt.Println(&quot;The second dog is nil.&quot;)<br>var pet Pet = dog2<br>if pet == nil {<br>    fmt.Println(&quot;The pet is nil.&quot;)<br>} else {<br>    fmt.Println(&quot;The pet category: %s&quot;, pet.Category())<br>    fmt.Println(&quot;The pet is not nil.&quot;)<br>}<br><br>运行结果:<br>The first dog is nil.<br>The second dog is nil.<br>panic: value method main.Dog.Category called using nil *Dog pointer<br><br>goroutine 1 [running]:<br>main.(*Dog).Category(0x0, 0x1, 0x1)<br>        &lt;autogenerated&gt;:1 +0x68<br><br>结论: 不可以调用该接口的方法. 因为接口变量pet的内部结构iface 在调用接口方法时主体为nil<br>","like_count":0},{"had_liked":false,"id":54407,"user_name":"虢國技醬","can_delete":false,"product_type":"c1","uid":1056807,"ip_address":"","ucode":"5A192262AA037E","user_header":"https://static001.geekbang.org/account/avatar/00/10/20/27/a6932fbe.jpg","comment_is_top":false,"comment_ctime":1545846134,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545846134","product_id":100013101,"comment_content":"打卡👊<br>仔细思考，明早去公司了验证一下","like_count":0},{"had_liked":false,"id":33961,"user_name":"0.0","can_delete":false,"product_type":"c1","uid":1001485,"ip_address":"","ucode":"6D0DAEE338C9A8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/0d/c9c21ad5.jpg","comment_is_top":false,"comment_ctime":1539930860,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539930860","product_id":100013101,"comment_content":"受益匪浅 感谢 ！","like_count":0},{"had_liked":false,"id":28968,"user_name":"小珂","can_delete":false,"product_type":"c1","uid":1068804,"ip_address":"","ucode":"983B917F0FFACD","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/04/613c2611.jpg","comment_is_top":false,"comment_ctime":1538210659,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1538210659","product_id":100013101,"comment_content":"java的类型信息是通过classloader加载到方法区, jvm方法区这块内存包含程序要使用的类的类型信息, 老师文中说go语言中当一个实现类值赋值给接口类型变量时, 实际上这个变量是包装了 实现类值的一个副本和实现类的类型信息, 我的疑问是: 这个运行时的赋值操时(包装副本和实现类类型信息), go语言又是如何得到实现类的类型信息的, 如果类型信息没预先存于内存某处, 这个类型信息难道是动态计算得到的吗？总不能凭空产生呀, 如果是, 它依据什么信息计算得到?  一个非接口类型变量本身是不包含其类型信息的呀. 期待老师解答","like_count":0},{"had_liked":false,"id":24842,"user_name":"Yayu","can_delete":false,"product_type":"c1","uid":1058015,"ip_address":"","ucode":"5E7842458D8229","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/df/645f8087.jpg","comment_is_top":false,"comment_ctime":1537198212,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1537198212","product_id":100013101,"comment_content":"第一次学习本节课程时听到各种概念——动态类型，动态值，静态类型，真实的nil 等等，会特别懵。静下心来，学习第二遍时觉得通透了许多。感谢老师的严谨表述。这里有一个疑问，我们是否可以理解成，被赋予实际值的接口变量是一个类似于 slice 之于 array 这样的的一个视图式的数据结构的实例？","like_count":0},{"had_liked":false,"id":24517,"user_name":"乔良qiaoliang","can_delete":false,"product_type":"c1","uid":1075315,"ip_address":"","ucode":"DDE301B3DF57A8","user_header":"https://static001.geekbang.org/account/avatar/00/10/68/73/3cda533e.jpg","comment_is_top":false,"comment_ctime":1537102377,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1537102377","product_id":100013101,"comment_content":"可以调用的，但是要注意实现类方法里面有没有deref 的地方（*a.xx()）可能引起panic ","like_count":0},{"had_liked":false,"id":24499,"user_name":"云学","can_delete":false,"product_type":"c1","uid":1027233,"ip_address":"","ucode":"366AE90BA06356","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ac/a1/43d83698.jpg","comment_is_top":false,"comment_ctime":1537087405,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1537087405","product_id":100013101,"comment_content":"凭借c++的功底，这篇是真的读懂了，指针是各种数据结构的灵魂","like_count":0},{"had_liked":false,"id":23985,"user_name":"vericlongmore","can_delete":false,"product_type":"c1","uid":1204070,"ip_address":"","ucode":"7294271CA3CDAC","user_header":"","comment_is_top":false,"comment_ctime":1536741714,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1536741714","product_id":100013101,"comment_content":"demo32.go github里没有啊","like_count":0},{"had_liked":false,"id":23915,"user_name":"pines","can_delete":false,"product_type":"c1","uid":1200708,"ip_address":"","ucode":"7B925605B36B4E","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/44/de7f2b98.jpg","comment_is_top":false,"comment_ctime":1536717684,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1536717684","product_id":100013101,"comment_content":"Dog的setName方法接受者是*Dog，然后用pet接收Dog类型怕是编译不过的，应该用*Dog类型","like_count":0}]}