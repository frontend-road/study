{"id":181952,"title":"18 | a + b：动态类型是灾难之源还是最好的特性？（上）","content":"<p>你好，我是周爱民，欢迎回到我的专栏。今天我们讲的主题是JavaScript的动态类型系统。</p><p><strong>动态类型</strong>是JavaScript的动态语言特性中最有代表性的一种。</p><p>动态执行与动态类型是天生根植于JavaScript语言核心设计中的基础组件，它们相辅相成，导致了JavaScript在学习上是易学难精，在使用中是易用易错。成兹败兹，难以得失论。</p><h2>类型系统的简化</h2><p>从根底上来说，JavaScript有着两套类型系统，如果仅以此论，那么还算不上复杂。</p><p>但是ECMAScript对语言类型的约定，又与JavaScript原生的、最初的语言设计不同，这导致了各种解释纷至沓来，很难统一成一个说法。而且，ECMAScript又为规范书写而订立了一套类型系统，并不停地演进它。这就如同雪上加霜，导致JavaScript的类型系统越发地说不清楚了。</p><p>在讨论动态类型的时候，可以将JavaScript类型系统做一些简化，从根底里来说，JavaScript也就是typeof()所支持的7种类型，其中的“<strong>对象</strong>（object）”与“<strong>函数</strong>（function）”算一大类，合称为<strong>引用类型</strong>，而其他类型作为<strong>值类型</strong>。</p><p>无论如何，我们就先以这种简单的类型划分为基础，来讨论JavaScript中的动态类型。因为这样一来，JavaScript中的类型转换变得很简单、很干净，也很易懂，可以用两条规则概括如下：</p><!-- [[[read_end]]] --><ol>\n<li>从值x到引用，调用Object(x)函数。</li>\n<li>从引用x到值，调用x.valueOf()方法；或调用4种值类型的包装类函数，例如Number(x)，或者String(x)等等。</li>\n</ol><p>简单吧？当然不会这么简单。</p><h2>先搞定一半</h2><p>在<strong>类型转换</strong>这件事中，有“半件”是比较容易搞定的。</p><p>这个一半，就是“<strong>从值x到引用</strong>”。因为主要的值类型都有对应的引用类型，因此JavaScript可以用简单方法一一对应地将它们转换过去。</p><p>使用<code>Object(x)</code>来转换是很安全的方法，在用户代码中不需要特别关心其中的<code>x</code>是什么样的数据——它们可以是特殊值（例如null、undefined等），或是一般的值类型数据，又或者也可以是一个对象。所有使用<code>Object(x)</code>的转换结果，都将是一个尽可能接近你的预期的<strong>对象</strong>。例如，将数字值转换成数字对象：</p><pre><code>&gt; x = 1234;\n\n&gt; Object(x);\n[Number: 1234]\n</code></pre><p>类似的还包括字符串、布尔值、符号等。而null、undefined将被转换为一个一般的、空白的对象，与<code>new Object</code>或一个空白字面量对象（也就是<code>{ }</code>）的效果一样。这个运算非常好用的地方在于，如果x已经是一个对象，那么它只会返回原对象，而不会做任何操作。也就是说，它没有任何的副作用，对任何数据的预期效果也都是“返回一个对象”。而且在语法上，<code>Object(x)</code>也类似于一个类型转换运算，表达的是将<code>任意x</code>转换成<code>对象x</code>。</p><p>简单的这“半件事”说完后，我们反过来，接着讨论将<strong>对象转换成值</strong>的情况。</p><h2>值VS原始值（Primitive values）</h2><p>任何对象都会有继承自原型的两个方法，称为<code>toString()</code>和<code>valueOf()</code>，这是JavaScript中“对象转换为值”的关键。</p><p>一般而言，你可以认为“任何东西都是可以转换为<code>字符串</code>的”，这个很容易理解，比如<code>JSON.stringify()</code>就利用了这一个简单的假设，它“几乎”可以将JavaScript中的任何对象或数据，转换成JSON格式的文本。</p><p>所以，我的意思是说，在JavaScript中将任何东西都转换成字符串这一点，在核心的原理上，以及具体的处理技术上都并不存在什么障碍。</p><p>但是如何理解“<strong>将函数转换成字符串</strong>”呢？</p><p>从最基础的来说，函数有两个层面的含义，一个是它的可执行代码，也就是文本形式的源代码；另一个则是函数作为对象，也有自己的属性。</p><p>所以，“理论上来说”，函数也可以被作为一个对象来转换成字符串，或者说，序列化成文本形式。</p><p>又或者再举一个例子，我们需要如何来理解将一个“符号对象”转换成“符号”呢？是的，我想你一定会说，没有“符号对象”这个东西，因为符号是值，不是对象。其实这样讲只是对了一半，因为现实中确实可以将一个“符号值”转换为一个“符号对象”，只需要调用一下我们上面说过的<code>Object()</code>这个函数就好了。</p><pre><code>&gt; x = Object(Symbol())\n[Symbol: Symbol()]\n</code></pre><p>那么在这种情况下，这个“符号对象x”又怎么能转换为字符串呢？</p><p>所以，“一切都能转换成字符串”只是理论上行得通，而实际上很多情况下是做不到的。</p><p>在这些“无法完成转换”的情况下，JavaScript仍然会尝试给出一个有效的字符串值。基本上，这种转换只能保证“不抛出异常”，而无法完成任何有效的计算。例如，你在通常情况下将对象转换为字符串，就只会得到一个“简单的描述”，仅能表示“这是一个对象”而没有任何其它实际意义。</p><pre><code>&gt; (new Object).toString()\n'[object Object]'\n</code></pre><p>为了将这个问题“一致化”——也就是将问题收纳成更小的问题，JavaScript约定，所有“对象 -&gt; 值”的转换结果要尽量地趋近于string、number和boolean三者之一。不过这从来都不是“书面的约定”，而是因为JavaScript在早期的作用，就是用于浏览器上的开发，而：</p><ul>\n<li>浏览器可以显示的东西，是string；</li>\n<li>可以计算的东西，是number；</li>\n<li>可以表达逻辑的东西，是boolean。</li>\n</ul><p>因此，在一个“最小的、可以被普通人理解的、可计算的程序系统中”，支持的“值类型数据”的最小集合，就应该是这三种。</p><p>这个问题不仅仅是浏览器，就算是一台放在云端的主机，你想要去操作它，那么通过控制台登录之后的shell脚本，也必须支持它。更远一点地说，你远程操作一台计算机，与浏览器用户要使用gmail，这二者在计算的抽象上是一样的，只是程序实现的复杂性不一样而已。</p><p>所以，对于（ECMAScript 5以及之前的）JavaScript来说，当它支持值转换向“对应的”对象时，或者反过来从这些对象转换回值的时候，所需要处理的也无非是这三种类型而已。而处理的具体方法也很简单，就是在使用<code>Object(x)</code>来转换得到的对象实例中添加一个内部槽，存放这个<code>x</code>的值。更确切地说，下面两行代码在语义上的效果是一致的（它是在一个称为<code>PrimitiveValue</code>的内部槽中置入这个值的）：</p><pre><code>obj = Object(x);\n\n// 等效于（如果能操作内部槽的话）\nobj.[[PrimitiveValue]] = x;\n</code></pre><p>于是，当需要从对象中转换回来到值类型时，也就是把这个<code>PrimitiveValue</code>值取出来就可以了。而“<strong>取出这个值，并返回给用户代码</strong>”的方法，就称为<code>valueOf()</code>。</p><p>到了ECMAScript 6中，这个过程就稍稍有些不同，这个内部槽是区别值类型的，因此为每种值类型设计了一个独立的私有槽名字。加上ES8中出现的大整数类型（BigInt），一共就有了5个对应的私有槽：<code>[[BooleanData] [[NumberData]]</code>、<code>[[StringData] [[SymbolData]]</code>和<code>[[BigIntData]]</code>。其中除了<code>Symbol</code>类型之外，都是满足在上面所说的：</p><ul>\n<li>一个“最小的、可以被普通人理解的、可计算的程序系统中”，支持的“值类型数据”的最小集合</li>\n</ul><p>这样一个设定的。</p><p>那么“符号”这个东西出现的必要性何在呢？</p><p>这个问题我就不解释了，算作本讲的课后习题之一，希望你可以踊跃参与讨论。不过就问题的方向来说，仍然是出于<strong>计算系统的完备性</strong>。如果你非要说这个是因为张三李四喜欢，某个tc39提案者的心头好，这样的答案就算是当事人承认，我也是不认可的。：）</p><p>好。回到正题。那么在ECMAScript 6之后，除<code>[[PrimitiveValue]]</code>这个私有槽变成了5种值类型对应的、独立的私有槽之外，还有什么不同呢？</p><p>是的，这个你可能也已经注意到了。ECMAScript 6之后还出现了<code>Symbol.toPrimitive</code>这个符号。而它，正是将原本的<code>[[PrimitiveValue]]</code>这个私有槽以及其访问过程标准化，然后暴露给JavaScript用户编程的一个界面。</p><p>说到这里，就必须明确<strong>一般的值</strong>（Values）与<strong>原始值</strong>（Primitive values）之间的关系了。</p><p>不过，在下一步的讨论之前，我要先帮你总结一下前面的内容：</p><p>也就是说，从<code>typeof(x)</code>的7种结果类型来看，其中string、boolean、number、bigint和symbol的值类型与对象类型转换，就是将该值存入私有槽，或者从私有槽中把相应的值取出来就好了。</p><p>在语言中，这些对应的对象类型被称为“包装类”，与此相关的还有“装箱”与“拆箱”等等行为，这也是后续会涉及到的内容。</p><blockquote>\n<p>NOTE: 在ECMAScript 6之前，由于<code>[PrimitiveValue]</code>来存放对应的封装类。也就是说，只有当<code>obj.[Class]</code>存放着<code>false</code>值时，它才是<code>false</code>值所对应的对象实例。</p>\n</blockquote><blockquote>\n<p>而ECMAScript 6将上述的依赖项变成了一个，也就是说只要有一个对象有内部槽<code>[[BooleanData]]</code>，那么它就是某个boolean值对应的对象。这样处理起来就简便了，不必每次做两项判断。</p>\n</blockquote><p>所以，一种关于“原始值”的简单解释是：所有5种能放入私有槽（亦即是说它们有相应的包装类）的值（Values），都是原始值；并且，再加上两个特殊值undefined和null，那么就是所谓原始值（Primitive values）的完整集合了。</p><p>接下来，如果转换过程发生在“值与值”之间呢？</p><h2>干掉那两个碍事儿的</h2><p>bigint这个类型最好说，它跟number在语言特性上是一回事儿，所以它的转换没什么特殊性，下面我会在讲到number的时候，一并讲解。</p><p>除此之外，还有两个类型在与其他类型的转换中是简单而特殊的。</p><p>例如，<strong>symbol</strong>这个值类型，它其实既没有办法转换成别的类型，也没有办法从别的类型转换过来。无论是哪种方式转换，它在语义上都是丢失了的、是没有意义的。当然，现实中你也可以这么用，比如用<code>console.log()</code>来将一个符号显示出来，这在控制台里面，是有显示信息输出的。</p><pre><code>&gt; console.log(Symbol())\nSymbol()\n</code></pre><p>这里的确发生了一个“symbol -&gt; string”的转换。但它的结果只能表示这是一个符号，至于是哪个符号，符号a还是符号b，全都分不出来。类似于此，所有“符号 -&gt; 其他值类型”的转换不需要太特别的讨论，由于所有能发生的转换都是定值，所以你可以做一张表格出来对照参考即可。当然，如果是“其他值类型 -&gt; symbol”的这种转换，实际结果就是创建一个新符号，而没有“转换”的语义了。</p><p>另外一个碍事儿的也特别简单，就是<strong>boolean</strong>。</p><p>ECMAScript为了兼容旧版本的JavaScript，直接将这个转换定义成了一张表格，这个表格在ECMAScript规范或者我们常用的<a href=\"https://developer.mozilla.org/\">MDN</a>（Mozilla Developer Network）上可以直接查到。简单地说，就是除了undefined、null、0、NaN、\"\"（empty string）以及BigInt中的0n返回false之外，其他的值转换为boolean时，都将是true值。</p><p>当然，不管怎么说，要想记住这些类型转换并不容易（当然也不难），简单的做法，就是直接把它们的包装类当作函数来调用，转换一下就好了。在你的代码中也可以这么写，例如，使用“String(x)”就是将x转换成string类型，又或者“Boolean(x)”就是将x转换为true/false值。</p><pre><code>&gt; x = 100n;  // `bigint` value\n&gt; String(x)  // to `string` value\n'100n'\n\n&gt; Boolean(x); // to `boolean` value\ntrue\n</code></pre><p>这些操作简单易行，也不容易出错，用在代码中还不影响效率，一切都很好。</p><blockquote>\n<p>NOTE: 这些可以直接作为函数调用的包装类，一共有四个，包括String()、Number()、Boolean()和BigInt()。此外，Symbol()在形式上与此相同，但执行语义是略有区别的。</p>\n</blockquote><p>但并不那么简单。因为我还没有跟你讨论过字符串和数字值的转换。</p><p>以及，还有特别要命的“隐式转换”。</p><h2>隐式转换</h2><p>由于函数的参数没有类型声明，所以用户代码可以传入任何类型的值。对于JavaScript核心库中的一些方法或操作来说，这表明它们需要一种统一、一致的方法来处理这种类型差异。例如说，要么拒绝“类型不太正确的参数”，抛出异常；要么用一种方式来使这些参数“变得正确”。</p><p>后一种方法就是“隐式转换”。但是就这两种方法的选择来说，JavaScript并没有编码风格层面上的约定。基本上，早期JavaScript以既有实现为核心的时候，倾向于让引擎吞掉类型异常（TypeError），尽量采用隐式转换来让程序在无异常的情况下运行；而后期，以ECMAScript规范为主导的时候，则倾向于抛出这些异常，让用户代码有机会处理类型问题。</p><p>隐式转换最主要的问题就是会带来大量的“潜规则”。</p><p>例如经典的<code>String.prototype.search(r)</code>方法，其中的参数从最初设计时就支持在<code>r</code>参数中传入一个字符串，并且将隐式地调用<code>r = new RegExp(r)</code>来产生最终被用来搜索的正则表达式。而<code>new RegExp(r)</code>这个运算中，由于<code>RegExp()</code>构造器又会隐式地将<code>r</code>从任何类型转换为字符串类型，因而在这整个过程中，向原始的<code>r</code>参数传入任何值都不会产生任何的异常。</p><p>例如，其实你写出下面这样的代码也是可以运行的：</p><pre><code>&gt; &quot;aa1aa&quot;.search(1)\n2\n\n&gt; &quot;000false111&quot;.search(0 &gt; 5)\n3\n</code></pre><p>隐式转换导致的“潜规则”很大程度上增加了理解用户代码的难度，也不利于引擎实现。因此，ECMAScript在后期就倾向于抛弃这种做法，多数的“新方法”在发现类型不匹配的时候，都设计为显式地抛出类型错误。一个典型的结果就是，在ECMAScript 3的时代，TypeError这个词在规范中出现的次数是24次；到了ECMAScript 5，是114次；而ECMAScript 6开始就暴增到419次。</p><p>因此，越是早期的特性，越是更多地采用了带有“潜规则”的隐式转换规则。然而很不幸的是，几乎所有的“运算符”，以及大多数常用的原型方法，都是“早期的特性”。</p><p>所以在类型转换方面，JavaScript成了“潜规则”最多的语言之一。</p><h2>好玩的</h2><p>@graybernhardt 曾在2012年发布过一个<a href=\"https://www.destroyallsoftware.com/talks/wat\">讲演</a>（A lightning talk by Gary Bernhardt from CodeMash 2012），提到一个非常非常著名的案例，来说明这个隐式转换，以及它所带来的“潜规则”有多么的不可预测。这个经典的示例是：</p><ul>\n<li>将<code>[]</code>和<code>{}</code>相加，会发生什么？</li>\n</ul><p>尝试一下这个case，你会看到：</p><pre><code>&gt; [] + {}\n'[object Object]'\n\n&gt; {} + []\n0\n\n&gt; {} + {}\nNaN\n\n&gt; [] + []\n''\n</code></pre><p>嗯！四种情况居然没有一个是相同的！</p><p>不过有一点需要注意到的，就是输出的结果，总是会“收敛”到两种类型：字符串，或者数值。嗯，“隐式转换”其实只是表面现象，核心的问题是，这种转换的结果总是倾向于“string/number”两种值类型。</p><p>这个，才是我们这一讲要讲“大问题”。</p><h2>且听下回分解</h2><p>到现在为止，这一节课其实才开了个头，也就是对“a + b”这个标题做了一个题解而已。这主要是因为在JavaScript中有关类型处理的背景信息太多、太复杂，而且还处在不停的变化之中。许多稍早的信息，与现在的应用环境中的现状，或者你手边可备查的资料之间都存在着不可调和的矛盾冲突，因此对这些东西加以梳理还原，实在是大有必要的。这也就是为什么这一讲会说到现在，仍然没有切入正题的原因。</p><p>当然，一部分原因也在于：这些絮絮叨叨的东西，也原本就是“正题”的一部分。比如说，你至少应该知道的内容包括：</p><ul>\n<li>语言中的引用类型和值类型，以及ECMAScript中的原始值类型（Primitive values）之间存在区别；</li>\n<li>语言中的所谓“引用类型”，与ECMAScript中的“引用（规范类型）”是完全不同的概念；</li>\n<li>所有值通过包装类转换成对象时，这个对象会具有一个内部槽，早期它统一称为<code>[[PrimitiveValue]]</code>，而后来JavaScript为每种包装类创建了一个专属的；</li>\n<li>使用typeof(x)来检查x的数据类型，在JavaScript代码中是常用而有效方法；</li>\n<li>原则上来说，系统只处理boolean/string/number三种值类型（bigint可以理解为number的特殊实现），其中boolean与其他值类型的转换是按对照表来处理的。</li>\n</ul><p>总的来说，类型在JavaScript中的显式转换是比较容易处理的，而标题“a + b”其实包含了太多隐式转换的可能性，因此尤其复杂。关于这些细节，且听下回分解。</p><p>这一讲没有复习题。不过如果你愿意，可以把上面讲到的@graybernhardt 的四个示例尝试一下，解释一下它们为什么是这个结果。</p><p>而下一讲，我再来为你公布答案，并且做详细解说。</p>","neighbors":{"left":{"article_title":"17 | Object.setPrototypeOf(x, null)：连Brendan Eich都认错，但null值还活着","id":181429},"right":{"article_title":"19 | a + b：动态类型是灾难之源还是最好的特性？（下）","id":182300}},"comments":[{"had_liked":false,"id":165450,"user_name":"Y","can_delete":false,"product_type":"c1","uid":1555967,"ip_address":"","ucode":"4AA6170E230C0C","user_header":"https://static001.geekbang.org/account/avatar/00/17/bd/ff/f4f2ae6a.jpg","comment_is_top":false,"comment_ctime":1577239466,"is_pvip":false,"replies":[{"id":"63295","content":"赞的。^^.<br><br>今天的课程可以对答案哟。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1577376243,"ip_address":"","comment_id":165450,"utype":1}],"discussion_count":3,"race_medal":0,"score":"104656454570","product_id":100039701,"comment_content":"这应该是由于对象类型转换为值类型时的拆箱操作导致的。<br>[]拆箱的话会先执行[].valueOf(),得到的是[],并不是原始值，就执行[].toString()，得到的结果是&#39;&#39;。<br>{}拆箱会先执行{}.valueOf()，得到的是{}，并不是原始值，于是执行toString(),得到的结果是[object Object]。<br>[]+{}就相当于&quot;&quot;+&quot;[object Object]&quot;，结果就是[object Object]。<br>{}+[]的话，js会把开头的{}理解成代码块，所以这句话就相当于+[],也就是等于+&quot;&quot;,将空字符串转换为数字类型，结果就是0。<br>{}+{}的话，也是和上面一样的道理,相当于+&quot;[object Object]&quot;，将字符串转化为数字类型，结果是NaN。<br>[]+[]就相当于&quot;&quot;+&quot;&quot;，所以结果还是&quot;&quot;。<br>","like_count":25,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479163,"discussion_content":"赞的。^^.\n\n今天的课程可以对答案哟。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577376243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2712653,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/kBKTRyV4wnhV4YN9iaFgKYIJ4451n0zIiazFumcSpCXdEDhdexgc8PQdrDEmy4BCOUgsUlibicEwQlGo6K5Nibv7SEg/132","nickname":"托马斯赵四","note":"","ucode":"F9FA980A9F8A1C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":406465,"discussion_content":"不好意思忘了+操作符了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634778345,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2712653,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/kBKTRyV4wnhV4YN9iaFgKYIJ4451n0zIiazFumcSpCXdEDhdexgc8PQdrDEmy4BCOUgsUlibicEwQlGo6K5Nibv7SEg/132","nickname":"托马斯赵四","note":"","ucode":"F9FA980A9F8A1C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":406462,"discussion_content":"为什么+[]最后会转成0能，上面说到引擎最后会把结果转换倾向于string /number，我理解空字符串也是可以接受的呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634778277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165983,"user_name":"王大可","can_delete":false,"product_type":"c1","uid":1003033,"ip_address":"","ucode":"9DBCA811C21C9B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/19/69f6e2ec.jpg","comment_is_top":false,"comment_ctime":1577356856,"is_pvip":false,"replies":[{"id":"63294","content":"确实。<br><br>不过在浏览器的控制台上，和在引擎的层面上执行也是会有区别的。都是使用 v8，NodeJS在Shell中与chrome也一样。但是你写在.js文件中，或者直接从node的命令行上执行，效果就不一样了，例如：<br><br>```<br>&gt; node -p -e &#39;{} + {}&#39;<br>NaN<br>```","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1577376215,"ip_address":"","comment_id":165983,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14462258744","product_id":100039701,"comment_content":"在chrome浏览器（版本 79.0.3945.88（正式版本） （64 位））计算 {} + {} 结果是&quot;[object Object][object Object]&quot;  <br>edge 下是计算 {} + {} 结果是 NaN","like_count":3,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479340,"discussion_content":"确实。\n\n不过在浏览器的控制台上，和在引擎的层面上执行也是会有区别的。都是使用 v8，NodeJS在Shell中与chrome也一样。但是你写在.js文件中，或者直接从node的命令行上执行，效果就不一样了，例如：\n\n```\n&amp;gt; node -p -e &amp;#39;{} + {}&amp;#39;\nNaN\n```","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577376215,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1194643,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3a/93/d7be8a1a.jpg","nickname":"晓小东","note":"","ucode":"93F9462EAAA63C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":104377,"discussion_content":"node 和chrome {};+ {} // NaN 我觉得应该跟前面的大括号的解析有关，是代码块还是对象字面量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577429229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165699,"user_name":"潇潇雨歇","can_delete":false,"product_type":"c1","uid":1251429,"ip_address":"","ucode":"4BD52BF0F0A084","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/65/35361f02.jpg","comment_is_top":false,"comment_ctime":1577284539,"is_pvip":false,"replies":[{"id":"63296","content":"赞的，+1票。^^.<br><br>今天的课程就分析这个了。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1577376276,"ip_address":"","comment_id":165699,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14462186427","product_id":100039701,"comment_content":"[]和{}在转换为值类型时会先调用valueOf然后调用toString。<br>1、[]+{}，前者转换&#39;&#39;,后者转换为[object Object]，这里为字符串连接操作，所以结果为&#39;[object Object]&#39;<br>2、{}+[]，前者为代码块，后者+操作符将&#39;&#39;转换为0，所以结果为0<br>3、{}+{}，前者为代码块，后者+操作符将&#39;[object Object]&#39;转换为NaN，因为它不能转换为一个正常的数值<br>4、[]+[]，前者为&#39;&#39;,后者也为&#39;&#39;，这里是正常的字符串连接，所以结果为&#39;&#39;","like_count":3,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479262,"discussion_content":"赞的，+1票。^^.\n\n今天的课程就分析这个了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577376276,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165503,"user_name":"晓小东","can_delete":false,"product_type":"c1","uid":1194643,"ip_address":"","ucode":"93F9462EAAA63C","user_header":"https://static001.geekbang.org/account/avatar/00/12/3a/93/d7be8a1a.jpg","comment_is_top":false,"comment_ctime":1577246271,"is_pvip":true,"replies":[{"id":"63183","content":"弱引用是向weakSet&#47;weakMap中添加一个目标对象的引用，但添加是目标对象的引用计数不增加。比较来说：<br><br>```<br>var x = {}; &#47;&#47; &lt;-右边的对象字面量的引用计数加1<br>var y = x; &#47;&#47; &lt;- 再加1<br>weakSet.add(x); &#47;&#47; &lt;-不加1<br>weakSet.add(y); &#47;&#47; &lt;-也不加1<br>delete x; &#47;&#47; 减1<br>delete y; &#47;&#47; 再减1<br>...<br>```<br>到这里，由于对象的引用计数为0了，所以weakSet中的那个被add()进去的x、y就自动被回收了。——weakSet&#47;weakMap具备这种机制。<br><br>所以weakSet&#47;weakMap没有size这个属性，它不安全。——你刚读了它的值，它自己自动回收了一下，就又变掉了。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1577295813,"ip_address":"","comment_id":165503,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14462148159","product_id":100039701,"comment_content":"老师有个问题， 既然您讲了数据的值类型与引用类型概念， 像weakSet与weakMap 对对象的弱引用该如何理解， 这个弱引用到底是个啥。","like_count":3,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479187,"discussion_content":"弱引用是向weakSet/weakMap中添加一个目标对象的引用，但添加是目标对象的引用计数不增加。比较来说：\n\n```\nvar x = {}; // &amp;lt;-右边的对象字面量的引用计数加1\nvar y = x; // &amp;lt;- 再加1\nweakSet.add(x); // &amp;lt;-不加1\nweakSet.add(y); // &amp;lt;-也不加1\ndelete x; // 减1\ndelete y; // 再减1\n...\n```\n到这里，由于对象的引用计数为0了，所以weakSet中的那个被add()进去的x、y就自动被回收了。——weakSet/weakMap具备这种机制。\n\n所以weakSet/weakMap没有size这个属性，它不安全。——你刚读了它的值，它自己自动回收了一下，就又变掉了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577295813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":234301,"user_name":"FG佳","can_delete":false,"product_type":"c1","uid":1743998,"ip_address":"","ucode":"CBDE48AFB8C656","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9c/7e/afd87677.jpg","comment_is_top":false,"comment_ctime":1594636395,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10184570987","product_id":100039701,"comment_content":"周老师 的《程序原本》棒棒的，里面刻舟求剑的印象非常深","like_count":2},{"had_liked":false,"id":166271,"user_name":"晓小东","can_delete":false,"product_type":"c1","uid":1194643,"ip_address":"","ucode":"93F9462EAAA63C","user_header":"https://static001.geekbang.org/account/avatar/00/12/3a/93/d7be8a1a.jpg","comment_is_top":false,"comment_ctime":1577429417,"is_pvip":true,"replies":[{"id":"63447","content":"ES6之前，是需要判断两次的。<br>* 有[[PrimitiveValue]]内部槽，说明是一个用包装类得到的值。然后，<br>* 查看[[Class]]内部槽，找到对应的包装类，从而知道类型。<br><br>在ES6之后，由于每种包装类有独立的一个槽，所以如果对象obj有[[BooleanData]]，那就说明了包装类是Boolean()，且被包装的数据在[[BooleanData]]槽中。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1577459757,"ip_address":"","comment_id":166271,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10167364009","product_id":100039701,"comment_content":"老师对于下面两段话，我理解的不是很清楚 （没看出来，判断两次还是判断一次逻辑???）<br><br>NOTE: 在 ECMAScript 6 之前，由于[PrimitiveValue]来存放对应的封装类。也就是说，只有当obj.[Class]存放着false值时，它才是false值所对应的对象实例。而 ECMAScript 6 将上述的依赖项变成了一个，也就是说只要有一个对象有内部槽[[BooleanData]]，那么它就是某个 boolean 值对应的对象。这样处理起来就简便了，不必每次做两项判断。","like_count":2,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479469,"discussion_content":"ES6之前，是需要判断两次的。\n* 有[[PrimitiveValue]]内部槽，说明是一个用包装类得到的值。然后，\n* 查看[[Class]]内部槽，找到对应的包装类，从而知道类型。\n\n在ES6之后，由于每种包装类有独立的一个槽，所以如果对象obj有[[BooleanData]]，那就说明了包装类是Boolean()，且被包装的数据在[[BooleanData]]槽中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577459757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":290092,"user_name":"undefined","can_delete":false,"product_type":"c1","uid":1100750,"ip_address":"","ucode":"768098DBDBE333","user_header":"https://static001.geekbang.org/account/avatar/00/10/cb/ce/d9e00eb5.jpg","comment_is_top":false,"comment_ctime":1619358233,"is_pvip":false,"replies":[{"id":"105317","content":"在之前的回复中说过这个问题。如下执行测试：<br><br>```<br>&gt; node -p -e &#39;{} + {}&#39;<br>NaN<br>```<br><br>`-e`参数用于直接执行，而不是作为模块执行。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1619665932,"ip_address":"","comment_id":290092,"utype":1}],"discussion_count":4,"race_medal":0,"score":"5914325529","product_id":100039701,"comment_content":"Chrome 90.0.4430.85 中（非 DevTools）<br><br>创建 index.html 和 app.js<br><br>app.js -&gt; console.log({} + {}) 的值竟然也是 &quot;[object Object][object Object]&quot;","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519110,"discussion_content":"在之前的回复中说过这个问题。如下执行测试：\n\n```\n&amp;gt; node -p -e &amp;#39;{} + {}&amp;#39;\nNaN\n```\n\n`-e`参数用于直接执行，而不是作为模块执行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619665932,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1100750,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cb/ce/d9e00eb5.jpg","nickname":"undefined","note":"","ucode":"768098DBDBE333","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370322,"discussion_content":"字节码 和 ast 的对比\n\nhttp://gk.link/a/10qjb","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619361649,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1100750,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cb/ce/d9e00eb5.jpg","nickname":"undefined","note":"","ucode":"768098DBDBE333","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370309,"discussion_content":"如果评论区可以 at 某个人就好了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619359658,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1100750,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cb/ce/d9e00eb5.jpg","nickname":"undefined","note":"","ucode":"768098DBDBE333","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370308,"discussion_content":"我在 d8（V8 version 9.0.257.17） 中尝试了一下\n\n{} + {} 的确是 NaN\n\n但 console.log({} + {}) 则是 [object Object][object Object]\n\n截图见这里 ↓\n\nhttps://horde.geekbang.org/message/detail/3KSpf08ieOli3MVmOxlwW3-ioXTX037V65SzePupHbA?tab=0","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619359581,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":290072,"user_name":"undefined","can_delete":false,"product_type":"c1","uid":1100750,"ip_address":"","ucode":"768098DBDBE333","user_header":"https://static001.geekbang.org/account/avatar/00/10/cb/ce/d9e00eb5.jpg","comment_is_top":false,"comment_ctime":1619346978,"is_pvip":false,"replies":[{"id":"105319","content":"多谢多谢。^^.<br><br>刚才我查了一下md原稿，原文是没错的。不过这个改起来有点困难。内容网页是用markdown自动生成的，估计极客时间用的也是第三方的生成组件，然后自动吞掉了……<br><br>","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1619666922,"ip_address":"","comment_id":290072,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5914314274","product_id":100039701,"comment_content":"#提个小问题#<br><br>原文中 「一共就有了 5 个对应的私有槽：[[BooleanData] [[NumberData]]、[[StringData] [[SymbolData]]和[[BigIntData]]」<br><br>修改为<br><br>一共就有了 5 个对应的私有槽：[[BooleanData]]、[[NumberData]]、[[StringData]]、[[SymbolData]] 和 [[BigIntData]]<br><br>要好一些。<br><br>原文少了顿号，缺少了两个 ] 符号，中文和英文之间加上一个空格要美观些（个人感受）。","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519101,"discussion_content":"多谢多谢。^^.\n\n刚才我查了一下md原稿，原文是没错的。不过这个改起来有点困难。内容网页是用markdown自动生成的，估计极客时间用的也是第三方的生成组件，然后自动吞掉了……\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619666922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221089,"user_name":"HoSalt","can_delete":false,"product_type":"c1","uid":1156074,"ip_address":"","ucode":"610B03E2A002D1","user_header":"https://static001.geekbang.org/account/avatar/00/11/a3/ea/53333dd5.jpg","comment_is_top":false,"comment_ctime":1590402584,"is_pvip":false,"replies":[{"id":"81606","content":"ES6之前是两个私有域<br>[[Class]]<br>[[PrimitiveValue]]<br>而ES6之后是一个。以String(5)为例，那么就是：<br>[[StringData]]<br><br>但是由于传入参数是数字5，所以<br>[[StringData]]里存放的是转换后的字符串值&quot;5&quot;，同样的原因，如果是ES5那么[[PrimitiveValue]]也存放的是字符串值&quot;5&quot;，而[[Class]]将存放String这个类的引用。<br><br>在ES5里面，Boolean&#47;String&#47;Number只使用了一种结构，三种对象的内部结构是一样的；在ES6里面，是三种不同的变体对象（结构&#47;内部槽是不一样的）。这是两种不同的设计思路。至于为什么要放转换后的值，是因为创建这个对象是一次性的，而使用是多次的，所以预先转换的效率高。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1590461203,"ip_address":"","comment_id":221089,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5885369880","product_id":100039701,"comment_content":"「由于[PrimitiveValue]来存放对应的封装类。也就是说，只有当obj.[Class]存放着false值时」<br>ES6之前PrimitiveValue里面放的对象（封装类），ES6后 [[xxxData]]里面放的是值还是封装类，若放的封装类，那值依旧放在obj.[Class]？<br>不太明白PrimitiveValue为什么要放封装类，直接放基本类型不就行了吗？","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496326,"discussion_content":"ES6之前是两个私有域\n[[Class]]\n[[PrimitiveValue]]\n而ES6之后是一个。以String(5)为例，那么就是：\n[[StringData]]\n\n但是由于传入参数是数字5，所以\n[[StringData]]里存放的是转换后的字符串值&amp;quot;5&amp;quot;，同样的原因，如果是ES5那么[[PrimitiveValue]]也存放的是字符串值&amp;quot;5&amp;quot;，而[[Class]]将存放String这个类的引用。\n\n在ES5里面，Boolean/String/Number只使用了一种结构，三种对象的内部结构是一样的；在ES6里面，是三种不同的变体对象（结构/内部槽是不一样的）。这是两种不同的设计思路。至于为什么要放转换后的值，是因为创建这个对象是一次性的，而使用是多次的，所以预先转换的效率高。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590461203,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220264,"user_name":"授人以摸鱼","can_delete":false,"product_type":"c1","uid":1390561,"ip_address":"","ucode":"69417D324C1473","user_header":"https://static001.geekbang.org/account/avatar/00/15/37/e1/0953c506.jpg","comment_is_top":false,"comment_ctime":1590217580,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5885184876","product_id":100039701,"comment_content":"Symbol这个类型，可能还是因为需要一些可以保证独一无二的东西吧<br>比如说两个库都给对象添加一些功能，需要通过给字段添加一些特定属性来实现<br>但结果偏偏两个库作者的思路很类似，起名撞车了，会造成的结果就完全不可控了<br>Symbol不仅可以保证独一无二，还可以不做转换直接用作字段名，这个其实是让js像其他对象类型不可变的语言一样，保证了字段的唯一性，即使可能两个字段的描述相同，它们也不会相互覆盖","like_count":1},{"had_liked":false,"id":165666,"user_name":"weineel","can_delete":false,"product_type":"c1","uid":1049741,"ip_address":"","ucode":"6DC6EF4F256A53","user_header":"https://static001.geekbang.org/account/avatar/00/10/04/8d/005c2ff3.jpg","comment_is_top":false,"comment_ctime":1577280610,"is_pvip":true,"replies":[{"id":"63181","content":"是的。同义。<br><br>只是我一直的工作是架构，所以架构中通用它的直译，也就是“界面”，而不是“接口&#47;编程接口”，因为有些架构中的界面，并不是用编程来实现的。在这种情况下，界面更多的是一种规约。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1577295220,"ip_address":"","comment_id":165666,"utype":1}],"discussion_count":1,"race_medal":2,"score":"5872247906","product_id":100039701,"comment_content":"在您的文章里，经常出现 &quot;界面&quot; 这个词，怎么理解呢？<br><br>我简单的当做 &quot;编程接口&quot; 的近义词。","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479251,"discussion_content":"是的。同义。\n\n只是我一直的工作是架构，所以架构中通用它的直译，也就是“界面”，而不是“接口/编程接口”，因为有些架构中的界面，并不是用编程来实现的。在这种情况下，界面更多的是一种规约。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577295220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165727,"user_name":"鲜于.css","can_delete":false,"product_type":"c1","uid":1324963,"ip_address":"","ucode":"918367197C844A","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/a3/91fe4700.jpg","comment_is_top":false,"comment_ctime":1577290103,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1577290103","product_id":100039701,"comment_content":"js就是学不明白闭包和原型原型链","like_count":0,"discussions":[{"author":{"id":1390561,"avatar":"https://static001.geekbang.org/account/avatar/00/15/37/e1/0953c506.jpg","nickname":"授人以摸鱼","note":"","ucode":"69417D324C1473","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271910,"discussion_content":"这些都是前面讲的内容，如果不明白的话，不要跳到第18讲来哦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590217244,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}