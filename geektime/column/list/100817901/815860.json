{"id":815860,"title":"18｜动手实战：改造实战案例1","content":"<p>你好，我是叶伟民。</p><p>学习了模糊检索知识最基本的概念之后，这节课我们开始动手实战，改造前面的实战案例1。目前实战案例1不支持模糊检索，也就是说用户只有输入公司全名，才能检索到该公司的相关数据。</p><p>等我们完成改造之后，用户在提问时即使没有输入公司全名，系统也能够模糊检索到相关数据。例如用户输入“广州神机妙算的款项到账了多少？”，系统将会检索到“广州神机妙算有限公司”的数据。</p><h2>搭建向量编码服务</h2><p>在改造之前，我们需要先打造一个基础设施，就是搭建向量编码服务。</p><p>看到这你可能有个疑问，为什么需要搭建向量编码服务，而不是直接在MIS系统里面进行向量编码呢？因为加载向量模型很耗时间和内存资源，将这部分代码单独拆分出一个服务更容易扩展和维护。</p><h3>安装依赖</h3><p>我们新建一个 <code>Anaconda Prompt Powershell</code> 激活实战案例1的虚拟环境。然后输入以下命令安装相关依赖。</p><pre><code class=\"language-powershell\">pip install sentence_transformers\npip install langchain==0.0.306\npip install fastapi\npip install uvicorn\n</code></pre><p>需要注意的是，以上命令的第二行需要指定LangChain的版本，不然会导致配套代码跑不通。LangChain改得太频繁了，这不是重点，重点是不向前兼容。这也是我诟病LangChain，不选择LangChain作为这门课基础框架的原因。</p><!-- [[[read_end]]] --><h3>下载向量模型</h3><p>然后我们新增一个目录，命名为<code>嵌入模型服务</code>。在目录下新建 <code>download.py</code> 文件，输入以下代码。</p><pre><code class=\"language-python\">from langchain.embeddings import HuggingFaceBgeEmbeddings\n\n向量编码模型本地存放路径 = \"F:\\LLAMA_INDEX_CACHE_DIR\\models\\embeddings\"\n向量编码本地所使用的device = \"cpu\" # \"cuda\"\n\nmodel_name = \"BAAI/bge-large-zh-v1.5\"\ncache_folder=向量编码模型本地存放路径\nmodel_kwargs = {'device': 向量编码本地所使用的device} #{'device': 'cuda'} # {'device': 'cpu'}\nencode_kwargs = {'normalize_embeddings': True} # set True to compute cosine similarity\nHuggingFaceBgeEmbeddings(model_name=model_name,cache_folder=cache_folder,model_kwargs=model_kwargs,encode_kwargs=encode_kwargs)\n</code></pre><p>注意，你需要把第3行代码的本地存放路径改为你的实际路径。</p><p>这个 <code>download.py</code> 文件的目的是将向量模型下载到本地。</p><p>接下来我们在 <code>Anaconda Prompt Powershell</code> 运行以下命令将向量模型下载到本地。</p><pre><code class=\"language-powershell\">python download.py\n</code></pre><p>如果一切顺利，将会出现以下结果。<br>\n<img src=\"https://static001.geekbang.org/resource/image/82/62/823215588ac955528b979a0084dd8e62.jpg?wh=3292x658\" alt=\"\"></p><h3>对外公开向量编码服务</h3><p>之后我们新增一个文件，命名为 <code>main.py</code>，输入以下代码。</p><pre><code class=\"language-python\">from fastapi import FastAPI, Request\nimport uvicorn\nfrom 向量编码器 import 向量编码器\n\napp = FastAPI()\n\n@app.get(\"/\")\nasync def read_root():\n&nbsp; &nbsp; return {\"hello word\":\"这里是向量编码服务\"}\n\napp.向量编码器instance = None\n\n@app.on_event('startup')\ndef init_data():\n&nbsp; &nbsp; app.向量编码器instance = 向量编码器()\n\n@app.post(\"/api/embedding/encode\")\nasync def 向量编码(request: Request):\n&nbsp; &nbsp; data = await request.json()\n&nbsp; &nbsp; print(data)\n&nbsp; &nbsp; input_str= data[\"input\"]\n&nbsp; &nbsp; return_result = app.向量编码器instance.向量编码(input_str)\n&nbsp; &nbsp; return return_result\n\nif __name__ == \"__main__\":\n&nbsp; &nbsp; uvicorn.run(\"main:app\", host=\"0.0.0.0\", port=8902)\n</code></pre><p>其中第13行到16行代码是服务初始化代码。接下来的第17到23行是向量编码函数。其中第19行和21行代码的作用是接收输入字符串，第22行代码负责对输入字符串进行向量编码，然后通过第23行代码返回编码结果。</p><p>从第3行代码可以看到，我们导入了一个<code>向量编码器</code>类，因此我们需要新增一个文件，命名为<code>向量编码器.py</code>，输入以下代码。</p><pre><code class=\"language-python\"># coding=utf-8\nfrom langchain.embeddings import HuggingFaceBgeEmbeddings\n\nclass 向量编码器:\n&nbsp; &nbsp; def __init__(self):\n&nbsp; &nbsp; &nbsp; &nbsp; 向量编码模型本地存放路径 = \"F:\\LLAMA_INDEX_CACHE_DIR\\models\\embeddings\"\n&nbsp; &nbsp; &nbsp; &nbsp; 向量编码本地所使用的device = \"cpu\"\n&nbsp; &nbsp; &nbsp; &nbsp; \n&nbsp; &nbsp; &nbsp; &nbsp; model_name = \"BAAI/bge-large-zh-v1.5\"\n&nbsp; &nbsp; &nbsp; &nbsp; cache_folder=向量编码模型本地存放路径\n&nbsp; &nbsp; &nbsp; &nbsp; model_kwargs = {'device': 向量编码本地所使用的device} #{'device': 'cuda'} # {'device': 'cpu'}\n&nbsp; &nbsp; &nbsp; &nbsp; encode_kwargs = {'normalize_embeddings': True} # set True to compute cosine similarity\n&nbsp; &nbsp; &nbsp; &nbsp; self.embed_model = HuggingFaceBgeEmbeddings(model_name=model_name,cache_folder=cache_folder,model_kwargs=model_kwargs,encode_kwargs=encode_kwargs)\n\n&nbsp; &nbsp; def 向量编码(self,query: str):\n&nbsp; &nbsp; &nbsp; &nbsp; embed_result = &nbsp;self.embed_model.embed_query(query)\n&nbsp; &nbsp; &nbsp; &nbsp; return {'向量编码':embed_result}\n</code></pre><p>注意，你需要把第6行代码的本地存放路径改为你的实际路径。</p><h3>测试向量编码服务</h3><p>这时候我们可以测试一下向量编码服务是否运作正常。</p><p>我们先在 <code>Anaconda Prompt Powershell</code> 输入以下命令把向量编码服务运行起来。</p><pre><code class=\"language-plain\">python main.py\n</code></pre><p>然后打开postman，以POST方式调用http://127.0.0.1:8902/api/embedding/encode。</p><p>其中在body处以json格式输入以下内容。</p><pre><code class=\"language-json\">{\n&nbsp; &nbsp; \"input\":\"test\"\n}\n</code></pre><p>然后将返回后面的json结果。</p><p><img src=\"https://static001.geekbang.org/resource/image/7a/9f/7a3b5aa1444472966fede19672f56e9f.jpg?wh=2092x1014\" alt=\"\"></p><h2>搭建向量数据库</h2><p>搭建完向量服务之后，我们还需要搭建向量数据库。我们同样需要先安装依赖。</p><h3>安装依赖</h3><p>我们新开一个 <code>Anaconda Prompt Powershell</code> 激活实战案例1的虚拟环境。然后输入以下命令安装相关依赖。</p><pre><code class=\"language-powershell\">pip install psycopg2\npip install pgvector\n</code></pre><p>第1行的psycopg2是Python操作pgsql的库，第2行的pgvector是Django专门用于操作向量列的库。</p><h3>将数据库从sqlite改为pgsql</h3><p>安装完依赖之后，我们需要将Django从默认使用的sqlite数据库改为使用pgsql数据库。</p><p>我们打开实战案例1 <code>mysite</code> 目录下的 <code>setting.py</code> 文件，找到以下代码。</p><pre><code class=\"language-python\"># Database\n# https://docs.djangoproject.com/en/4.2/ref/settings/#databases\n\nDATABASES = {\n&nbsp; &nbsp; 'default': {\n&nbsp; &nbsp; &nbsp; &nbsp; 'ENGINE': 'django.db.backends.sqlite3',\n&nbsp; &nbsp; &nbsp; &nbsp; 'NAME': BASE_DIR / 'db.sqlite3',\n&nbsp; &nbsp; }\n}\n</code></pre><p>我们需要把这段代码做个修改，改成以下代码。</p><pre><code class=\"language-python\"># Database\n# https://docs.djangoproject.com/en/4.2/ref/settings/#databases\n\nDATABASES = {\n&nbsp; &nbsp; 'default': {\n&nbsp; &nbsp; &nbsp; &nbsp; 'ENGINE': 'django.db.backends.postgresql_psycopg2',\n&nbsp; &nbsp; &nbsp; &nbsp; 'NAME': 'geekrag-1',\n&nbsp; &nbsp; &nbsp; &nbsp; 'USER': 'postgres',\n&nbsp; &nbsp; &nbsp; &nbsp; 'PASSWORD': '1234567Abc',\n&nbsp; &nbsp; &nbsp; &nbsp; 'HOST': 'localhost',\n&nbsp; &nbsp; &nbsp; &nbsp; 'PORT': '5432',\n&nbsp; &nbsp; }\n}\n</code></pre><p>其中第6行是指定使用pgsql数据库，第7行是数据库名字，第8行是pgsql的用户名，第9行是pgsql的密码，第10行是pgsql的端口。</p><h3>将id字段改为pgsql支持的格式</h3><p>目前我们ORM的id字段是pgsql不支持的，因此我们需要改为pgsql支持的格式，我们打开 <code>home</code>目录下的 <code>models.py</code> 文件，找到id字段，改为以下形式。</p><pre><code class=\"language-python\">id = models.AutoField(primary_key=True)\n</code></pre><p>做好前面这些准备，现在我们可以改造实战案例1了。</p><p>整个改造过程包括以下步骤：</p><ol>\n<li>添加向量编码列和嵌入模型列。</li>\n<li>对知识进行向量编码并将编码结果保存进数据库。</li>\n<li>对查询参数进行向量编码。</li>\n<li>根据查询参数的向量编码按相似度进行检索。</li>\n</ol><h2>添加向量编码和嵌入模型列</h2><p>我们首先开始第一步，在数据表中添加向量编码列。</p><p>关于这一步，我们可以通过数据库管理工具 <code>pgadmin</code> 的UI进行操作，这是我们<a href=\"https://time.geekbang.org/column/article/814486\">第16节课</a>学过的内容。但是比较幸运的是，我们的MIS系统在ORM层面就支持添加向量编码列，因此操作起来比前面所讲的还要方便。</p><p>这里需要注意，在你的现实工作中，如果你的系统在ORM层面不支持添加向量编码列，那么你仍然可以通过 <code>pgadmin</code> 的UI添加向量编码列。</p><h3>在ORM层面添加列</h3><p>我们打开 <code>home</code> 文件夹下面的 <code>models.py</code> 文件。在文件的顶部加入以下代码。</p><pre><code class=\"language-python\">from pgvector.django import VectorField\n</code></pre><p>然后在<code>客户</code>这一行代码下面加入以下两行代码。</p><pre><code class=\"language-python\">客户向量编码 = VectorField(dimensions=1024,null=True,blank=True)\n客户向量编码模型 = models.TextField(default=\"bge-large-zh-v1.5\")\n</code></pre><p>其中第2行代码用于设置我们希望使用的向量编码模型，这里我们设置为智谱向量编码模型的大型中文版本。</p><p>第1行代码的 <code>VectorField</code> 表示向量编码字段。与其他字段相比，它具有维度概念（如果印象不深可以回顾第15、16节课），这里设置为我们所使用的向量编码模型的维度，也就是1024维。</p><p>现在整个<code>销售入账记录</code> ORM模型类代码就会变成后面这样。</p><pre><code class=\"language-python\">class 销售入账记录(models.Model):\n    id = models.AutoField(primary_key=True)\n\n    客户 = models.CharField(max_length=255)\n    客户向量编码 = VectorField(dimensions=1024,null=True,blank=True)\n    客户向量编码模型 = models.TextField(default=\"bge-large-zh-v1.5\")\n    入账日期 = models.DateTimeField()\n    入账金额 = models.TextField(null=True)\n    已到账款项 = models.IntegerField(null=True)\n    剩余到账款项 = models.IntegerField(null=True)\n</code></pre><h3>执行命令更新数据库</h3><p>然后我们切换到 <code>Anaconda Powershell Prompt</code>，输入以下命令更新数据库。</p><pre><code class=\"language-powershell\">python manage.py makemigrations\npython manage.py migrate\n</code></pre><p>这时候如果一切顺利的话，应该提示数据库更新成功。然后我们需要打开数据库确认操作无误。</p><h3>打开数据库确认操作无误</h3><p>现在我们需要通过UI打开数据库验证操作无误，这是我们第16节课学过的内容。</p><p>我们使用 <code>pgadmin</code>，打开<code>销售入账记录</code>表。这时我们应该看到已经成功添加了<code>客户向量编码</code>和<code>客户向量编码模型</code>这两列。其中<code>客户向量编码</code>的数据类型就是 <code>vector</code> 类型（pgadmin和vector你同样可以回顾第16节课）。</p><p><img src=\"https://static001.geekbang.org/resource/image/2d/d7/2da391f288731a5c531a9e1cdc8c76d7.jpg?wh=2920x2108\" alt=\"\"><img src=\"https://static001.geekbang.org/resource/image/b8/72/b84360fe25c8c8c76aedd97c13657072.jpg?wh=2900x2279\" alt=\"\"></p><h2>对知识批量编码并存进数据库</h2><p>我们在 <code>api.py</code> 文件尾部加入以下代码。</p><pre><code class=\"language-python\">def 对知识批量进行向量编码(request):\n&nbsp; &nbsp; 未编码的知识list = 销售入账记录.objects.filter(客户向量编码__isnull=True)\n&nbsp; &nbsp; for current in 未编码的知识list:\n&nbsp; &nbsp; &nbsp; &nbsp; current.客户向量编码= 调用向量编码服务(current.客户)\n&nbsp; &nbsp; &nbsp; &nbsp; current.save()\n&nbsp; &nbsp; \n&nbsp; &nbsp; result = {'code':200}\n&nbsp; &nbsp; return JsonResponse(result)\n</code></pre><p>这段代码也很好理解，首先获取尚未编码的知识列表（对应代码第2行）。然后遍历这个列表（对应代码第3行）。接着知识进行向量编码（代码第4行）。最后将向量保存进数据库（代码第5行）。</p><p>然后我们在 <code>home/urls.py</code> 文件尾部加入以下代码。</p><pre><code class=\"language-python\">path(\"api/knowledge-embedding-batch\", api.对知识批量进行向量编码, name=\"knowledge-embedding-batch\"),\n</code></pre><p>接着我们在postman调用http://127.0.0.1:8902/api/knowledge-embedding-batch即可批量编码并将其保存进数据库。</p><p>除此之外，我们还可以在数据入库的时候就调用以上函数进行向量编码。由于目前实战案例1还没有数据新增时的代码，因此我们跳过这一块。同学们可以在自己的MIS系统里面自行添加这一块代码。</p><h2>对查询参数进行向量编码</h2><p>对查询参数进行向量编码的代码和对知识进行向量编码的代码类似，因为过程是一样的，都是调用向量编码服务输入字符串返回向量编码，只不过输入字符串从知识变成了查询参数而已。</p><p>我们打开 <code>search.py</code> 文件，找到<code>查询</code>函数，然后添加以下第8行代码。</p><pre><code class=\"language-python\">from .models import 销售入账记录\nfrom .api import 调用向量编码服务\n\ndef 查询(查询参数):\n&nbsp; &nbsp; if '模块' in 查询参数:\n&nbsp; &nbsp; &nbsp; &nbsp; if 查询参数['模块'] == 1: #'销售对账'\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if '客户名称' in 查询参数:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 客户 = 查询参数['客户名称'].strip()\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 精确搜索结果 = 销售入账记录.objects.filter(客户=客户).values('客户', '入账日期', '入账金额', '已到账款项', '剩余到账款项')\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if 精确搜索结果 is not None and len(精确搜索结果) &gt; 0:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 精确搜索结果\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 查询字符串向量编码 = 调用向量编码服务(客户)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 模糊搜索结果\n</code></pre><p>这里要注意的是，我们并没有对用户提问进行向量编码，而是<strong>对用户提问解析之后的查询参数里面的客户名称</strong>进行向量编码。为什么这么做呢？</p><p>因为无论是精确检索还是模糊检索，实际上都是基于查询参数进行的，而不是基于最原始的提问进行的。</p><p>现在我们获得了查询参数的向量编码，我们通过这个向量编码，就可以根据相似度检索出最相似的数据了。</p><h2>根据查询参数的向量编码按相似度进行检索</h2><p>接下来，我们继续往 <code>search.py</code> 文件的<code>查询</code>函数添加代码。</p><pre><code class=\"language-python\">from .models import 销售入账记录\nfrom .api import 调用向量编码服务\n\ndef 查询(查询参数):\n&nbsp; &nbsp; if '模块' in 查询参数:\n&nbsp; &nbsp; &nbsp; &nbsp; if 查询参数['模块'] == 1: #'销售对账'\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if '客户名称' in 查询参数:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 客户 = 查询参数['客户名称'].strip()\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 精确搜索结果 = 销售入账记录.objects.filter(客户=客户).values('客户', '入账日期', '入账金额', '已到账款项', '剩余到账款项')\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if 精确搜索结果 is not None and len(精确搜索结果) &gt; 0:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 精确搜索结果\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 查询字符串向量编码 = 调用向量编码服务(客户)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 模糊搜索结果RawQuerySet = 销售入账记录.objects.raw('SELECT *, 1 - (客户向量编码 &lt;=&gt; %s) AS 余弦相似度,客户 FROM public.\"home_销售入账记录\" order by 余弦相似度 desc;',[str(查询字符串向量编码),])\n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 模糊搜索结果 = []\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for item in 模糊搜索结果RawQuerySet:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 模糊搜索结果.append({\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; '客户': item.客户,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; '入账日期': str(item.入账日期),\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; '入账金额': item.入账金额,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; '已到账款项': item.已到账款项,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; '剩余到账款项': item.剩余到账款项\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; })\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 模糊搜索结果\n</code></pre><p>其中第13到14行是我们新增的代码，就是相似度检索代码。我们可以看到，我们用到了第17节课所讲的余弦距离来计算相似度。</p><p>现在我们找到了与查询参数最相似的客户了，那么就可以将检索出来的结果整合进大模型了。</p><p>这一块我们甚至不需要修改任何代码，是不是觉得有点吃惊？</p><p>仔细想想，其实很合理，因为模糊检索知识与精确检索知识相比，我们只是增强了检索知识的部分，至于将检索出来的结果喂给大模型这块，其实是没有做任何改变的。</p><p>除此之外，细心的同学们还会发现，我们修改了很多代码文件，就是没有修改 <code>rag.py</code> 文件。粗看一下，好像也有些不合理，但是仔细想想同样也是合理的。因为模糊检索知识与精确检索知识相比，我们只是增强了检索知识的部分，至于整个RAG流程，其实是没有做任何改变的。</p><h2>小结</h2><p>好了，今天这一讲到这里就结束了，最后我们来回顾一下。这一讲我们学会了五件事情，还了解了一个本质。</p><p>第一件事情是搭建向量编码服务。因为加载向量模型很耗时间和内存资源，将这部分代码单独拆分出一个服务更容易扩展和维护。</p><p>第二件事情是添加向量编码列和嵌入模型列。我们将在ORM层面添加向量编码列和嵌入模型列。如果你的系统在ORM层面不支持，则可以使用第16节课的方法通过UI添加。</p><p>第三件事情是对知识批量编码并将结果存进数据库。我们首先获取尚未编码的知识，然后遍历进行编码，并将结果存进数据库。</p><p>第四件事情是对查询参数进行向量编码。对查询参数进行向量编码的代码和对知识进行向量编码的代码类似，因为过程是一样的。</p><p>第五件事情是根据查询参数的向量编码按相似度进行检索。我们修改了<code>查询</code>函数。</p><p>我们可以看到，模糊检索知识与精确检索知识相比，<strong>本质上只是增强了检索知识的部分。</strong>至于整个RAG流程，其实是没有做任何改变的。</p><p>既然整个RAG流程其实是没有做任何改变的，这里也建议同学们回顾和巩固一下整个RAG流程。下节课，我们将基于类似的概念和代码实现实战案例3：工单辅助系统，敬请期待。</p><h2>思考题</h2><p>今天这节课里，我们并没有将查询参数的向量编码保存进数据库。那么是否有必要将查询参数的向量编码保存进数据库呢？如果有必要，这么做的意义是什么呢？</p><p>欢迎你在留言区和我交流互动，如果这节课对你有启发，也推荐分享给身边更多朋友。</p>","comments":[{"had_liked":false,"id":395555,"user_name":"kevin","can_delete":false,"product_type":"c1","uid":3920101,"ip_address":"广东","ucode":"19E83C631DF25E","user_header":"https://static001.geekbang.org/account/avatar/00/3b/d0/e5/0a3ee17c.jpg","comment_is_top":false,"comment_ctime":1731227160,"is_pvip":false,"replies":[{"id":143595,"content":"很赞！","user_name":"作者回复","user_name_real":"编辑","uid":1337319,"ctime":1731378655,"ip_address":"江苏","comment_id":395555,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100817901,"comment_content":"我们并没有将查询参数的向量编码保存进数据库。那么是否有必要将查询参数的向量编码保存进数据库呢？如果有必要，这么做的意义是什么呢？\n如果要把查询参数的向量编码保存下来，是否可以帮助下次的查询更精确匹配。下次的搜索可能和本次搜索语义很相近，就容易配备了。","like_count":0,"discussions":[{"author":{"id":1337319,"avatar":"https://static001.geekbang.org/account/avatar/00/14/67/e7/0d92745d.jpg","nickname":"Billy火炎焱燚(不羁的风)","note":"","ucode":"63DED1EB2CF6AE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":653639,"discussion_content":"很赞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1731378655,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":395370,"user_name":"悟远","can_delete":false,"product_type":"c1","uid":1912923,"ip_address":"北京","ucode":"3BD9C748698888","user_header":"https://static001.geekbang.org/account/avatar/00/1d/30/5b/4f4b0a40.jpg","comment_is_top":false,"comment_ctime":1730451594,"is_pvip":false,"replies":[{"id":143601,"content":"这个问题不方便回答，你懂的，你找到了如何访问google的方法就知道如何下载了","user_name":"作者回复","user_name_real":"编辑","uid":1337319,"ctime":1731378971,"ip_address":"江苏","comment_id":395370,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100817901,"comment_content":"OSError: We couldn&#39;t connect to &#39;https:&#47;&#47;huggingface.co&#39; to load this file 模型下载不下来，一般怎么配置代理或镜像？","like_count":0,"discussions":[{"author":{"id":1337319,"avatar":"https://static001.geekbang.org/account/avatar/00/14/67/e7/0d92745d.jpg","nickname":"Billy火炎焱燚(不羁的风)","note":"","ucode":"63DED1EB2CF6AE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":653646,"discussion_content":"这个问题不方便回答，你懂的，你找到了如何访问google的方法就知道如何下载了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1731378971,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":395190,"user_name":"kevin","can_delete":false,"product_type":"c1","uid":3920101,"ip_address":"广东","ucode":"19E83C631DF25E","user_header":"https://static001.geekbang.org/account/avatar/00/3b/d0/e5/0a3ee17c.jpg","comment_is_top":false,"comment_ctime":1729677815,"is_pvip":false,"replies":[{"id":143619,"content":"您把向量编码服务跑起来了吗？","user_name":"作者回复","user_name_real":"编辑","uid":1337319,"ctime":1731380247,"ip_address":"江苏","comment_id":395190,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100817901,"comment_content":"我运行api&#47;knowledge-embedding-batch建立客户向量编码时总是报如下错误\nMax retries exceeded with url: &#47;api&#47;embedding&#47;encode (Caused by NewConnectionError(&#39;&lt;urllib3.connection.HTTPConnection object at 0x000001FE31D3CC10&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。&#39;))","like_count":0,"discussions":[{"author":{"id":1337319,"avatar":"https://static001.geekbang.org/account/avatar/00/14/67/e7/0d92745d.jpg","nickname":"Billy火炎焱燚(不羁的风)","note":"","ucode":"63DED1EB2CF6AE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":653665,"discussion_content":"您把向量编码服务跑起来了吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1731380247,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3920101,"avatar":"https://static001.geekbang.org/account/avatar/00/3b/d0/e5/0a3ee17c.jpg","nickname":"kevin","note":"","ucode":"19E83C631DF25E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":652825,"discussion_content":"调试可以用VSCODE,使用 Python 调试程序:使用 launchjson 进行调试，输入runserver参数，然后打断点就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1729685907,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3920101,"avatar":"https://static001.geekbang.org/account/avatar/00/3b/d0/e5/0a3ee17c.jpg","nickname":"kevin","note":"","ucode":"19E83C631DF25E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":652824,"discussion_content":"已解决，要先启动D:\\E_AI\\RAG\\time-geekbang-org-rag-main\\实战案例3\\嵌入模型服务下的main.py,然后再启动python manage.py runserver.再用postman 进行测试。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1729685762,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":394968,"user_name":"Geek_0a887e","can_delete":false,"product_type":"c1","uid":3690020,"ip_address":"浙江","ucode":"17EBC4E533B600","user_header":"","comment_is_top":false,"comment_ctime":1728959699,"is_pvip":false,"replies":[{"id":143612,"content":"因为用1去减了，所以用desc，如果不用1去减，那可以用asc","user_name":"作者回复","user_name_real":"编辑","uid":1337319,"ctime":1731379648,"ip_address":"江苏","comment_id":394968,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100817901,"comment_content":"老师有个疑问：按照前一章节的内容话，1 - （字段&lt;=&gt;向量） 得到的是余弦距离，距离越小越相似，为什么还需要desc，不是应该asc吗，","like_count":0,"discussions":[{"author":{"id":1337319,"avatar":"https://static001.geekbang.org/account/avatar/00/14/67/e7/0d92745d.jpg","nickname":"Billy火炎焱燚(不羁的风)","note":"","ucode":"63DED1EB2CF6AE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":653658,"discussion_content":"因为用1去减了，所以用desc，如果不用1去减，那可以用asc","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1731379648,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3690020,"avatar":"","nickname":"Geek_0a887e","note":"","ucode":"17EBC4E533B600","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":652448,"discussion_content":"原文的内容：具体来说分两步，首先计算两个向量的余弦相似度，然后使用 1 减去余弦相似度。余弦距离的值越小，就表示两个向量越相似。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1728960067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":4046088,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/0eVrZvOOzJ822yHplW7IcViaSrRS4FZBLI2LM7z7PUpgGb3lH1bw0J7Zh3fBEhWb0DYSfGtBE4kZAYJcaxJfgBujOMAOaYc7JuTyQXK2Lj4E/132","nickname":"Geek_5df8e7","note":"","ucode":"59D8BD001AF262","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":654711,"discussion_content":"1 - （字段&lt;=&gt;向量）   这个得到的是相似度还是距离？如果这就是距离了那不是越小越接近吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1733295460,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":394965,"user_name":"公号-技术夜未眠","can_delete":false,"product_type":"c1","uid":1013683,"ip_address":"四川","ucode":"83825B57CBD952","user_header":"https://static001.geekbang.org/account/avatar/00/0f/77/b3/991f3f9b.jpg","comment_is_top":false,"comment_ctime":1728952776,"is_pvip":true,"replies":null,"discussion_count":1,"race_medal":1,"score":2,"product_id":100817901,"comment_content":"老师好，想请教一个问题，目前正在做一个知识问答智能AI助手，虽然这个助手是长在自己的产品系统中，但是现在要集成客户环境内部署的各类其它异构系统，和系统数据，包括各类非结构化与结构化数据，用于满足企业知识问答需求。\n请问该需求有实现的可能性吗？请教具体的实现思路以及所需要重要注意的事项，谢谢","like_count":0,"discussions":[{"author":{"id":1157533,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a9/9d/bdfd9e58.jpg","nickname":"无处不在","note":"","ucode":"BB535BC6F448F4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":653049,"discussion_content":"我觉得你用fastgpt能解决一大部分问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1730159231,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}