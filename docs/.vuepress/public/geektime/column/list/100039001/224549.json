{"id":224549,"title":"71 | 命令模式：如何利用命令模式实现一个手游后端架构？","content":"<p>设计模式模块已经接近尾声了，现在我们只剩下3个模式还没有学习，它们分别是：命令模式、解释器模式、中介模式。这3个模式使用频率低、理解难度大，只在非常特定的应用场景下才会用到，所以，不是我们学习的重点，你只需要稍微了解，见了能认识就可以了。</p><p>今天呢，我们来学习其中的命令模式。在学习这个模式的过程中，你可能会遇到的最大的疑惑是，感觉命令模式没啥用，是一种过度设计，有更加简单的设计思路可以替代。所以，我今天讲解的重点是这个模式的设计意图，带你搞清楚到底什么情况下才真正需要使用它。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>命令模式的原理解读</h2><p>命令模式的英文翻译是Command Design Pattern。在GoF的《设计模式》一书中，它是这么定义的：</p><blockquote>\n<p>The command pattern encapsulates a request as an object, thereby letting us parameterize other objects with different requests, queue or log requests, and support undoable operations.</p>\n</blockquote><p>翻译成中文就是下面这样。为了帮助你理解，我对这个翻译稍微做了补充和解释，也一起放在了下面的括号中。</p><!-- [[[read_end]]] --><p>命令模式将请求（命令）封装为一个对象，这样可以使用不同的请求参数化其他对象（将不同请求依赖注入到其他对象），并且能够支持请求（命令）的排队执行、记录日志、撤销等（附加控制）功能。</p><p>对于GoF给出的定义，我这里再进一步解读一下。</p><p>落实到编码实现，命令模式用的最核心的实现手段，是将函数封装成对象。我们知道，C语言支持函数指针，我们可以把函数当作变量传递来传递去。但是，在大部分编程语言中，函数没法儿作为参数传递给其他函数，也没法儿赋值给变量。借助命令模式，我们可以将函数封装成对象。具体来说就是，设计一个包含这个函数的类，实例化一个对象传来传去，这样就可以实现把函数像对象一样使用。从实现的角度来说，它类似我们之前讲过的回调。</p><p>当我们把函数封装成对象之后，对象就可以存储下来，方便控制执行。所以，命令模式的主要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等等，这才是命令模式能发挥独一无二作用的地方。</p><h2>命令模式的实战讲解</h2><p>上面的讲解比较偏理论，比较不好理解，我这里再结合一个具体的例子来解释一下。</p><p>假设我们正在开发一个类似《天天酷跑》或者《QQ卡丁车》这样的手游。这种游戏本身的复杂度集中在客户端。后端基本上只负责数据（比如积分、生命值、装备）的更新和查询，所以，后端逻辑相对于客户端来说，要简单很多。</p><p>考虑到你可能对游戏开发不熟悉，我这里稍微交代一些背景知识。</p><p>为了提高性能，我们会把游戏中玩家的信息保存在内存中。在游戏进行的过程中，只更新内存中的数据，游戏结束之后，再将内存中的数据存档，也就是持久化到数据库中。为了降低实现的难度，一般来说，同一个游戏场景里的玩家，会被分配到同一台服务上。这样，一个玩家拉取同一个游戏场景中的其他玩家的信息，就不需要跨服务器去查找了，实现起来就简单了很多。</p><p>一般来说，游戏客户端和服务器之间的数据交互是比较频繁的，所以，为了节省网络连接建立的开销，客户端和服务器之间一般采用长连接的方式来通信。通信的格式有多种，比如Protocol Buffer、JSON、XML，甚至可以自定义格式。不管是什么格式，客户端发送给服务器的请求，一般都包括两部分内容：指令和数据。其中，指令我们也可以叫作事件，数据是执行这个指令所需的数据。</p><p>服务器在接收到客户端的请求之后，会解析出指令和数据，并且根据指令的不同，执行不同的处理逻辑。对于这样的一个业务场景，一般有两种架构实现思路。</p><p>常用的一种实现思路是利用多线程。一个线程接收请求，接收到请求之后，启动一个新的线程来处理请求。具体点讲，一般是通过一个主线程来接收客户端发来的请求。每当接收到一个请求之后，就从一个专门用来处理请求的线程池中，捞出一个空闲线程来处理。</p><p>另一种实现思路是在一个线程内轮询接收请求和处理请求。这种处理方式不太常见。尽管它无法利用多线程多核处理的优势，但是对于IO密集型的业务来说，它避免了多线程不停切换对性能的损耗，并且克服了多线程编程Bug比较难调试的缺点，也算是手游后端服务器开发中比较常见的架构模式了。</p><p>我们接下来就重点讲一下第二种实现方式。</p><p>整个手游后端服务器轮询获取客户端发来的请求，获取到请求之后，借助命令模式，把请求包含的数据和处理逻辑封装为命令对象，并存储在内存队列中。然后，再从队列中取出一定数量的命令来执行。执行完成之后，再重新开始新的一轮轮询。具体的示例代码如下所示，你可以结合着一块看下。</p><pre><code>public interface Command {\n  void execute();\n}\n\npublic class GotDiamondCommand implements Command {\n  // 省略成员变量\n\n  public GotDiamondCommand(/*数据*/) {\n    //...\n  }\n\n  @Override\n  public void execute() {\n    // 执行相应的逻辑\n  }\n}\n//GotStartCommand/HitObstacleCommand/ArchiveCommand类省略\n\npublic class GameApplication {\n  private static final int MAX_HANDLED_REQ_COUNT_PER_LOOP = 100;\n  private Queue&lt;Command&gt; queue = new LinkedList&lt;&gt;();\n\n  public void mainloop() {\n    while (true) {\n      List&lt;Request&gt; requests = new ArrayList&lt;&gt;();\n      \n      //省略从epoll或者select中获取数据，并封装成Request的逻辑，\n      //注意设置超时时间，如果很长时间没有接收到请求，就继续下面的逻辑处理。\n      \n      for (Request request : requests) {\n        Event event = request.getEvent();\n        Command command = null;\n        if (event.equals(Event.GOT_DIAMOND)) {\n          command = new GotDiamondCommand(/*数据*/);\n        } else if (event.equals(Event.GOT_STAR)) {\n          command = new GotStartCommand(/*数据*/);\n        } else if (event.equals(Event.HIT_OBSTACLE)) {\n          command = new HitObstacleCommand(/*数据*/);\n        } else if (event.equals(Event.ARCHIVE)) {\n          command = new ArchiveCommand(/*数据*/);\n        } // ...一堆else if...\n\n        queue.add(command);\n      }\n\n      int handledCount = 0;\n      while (handledCount &lt; MAX_HANDLED_REQ_COUNT_PER_LOOP) {\n        if (queue.isEmpty()) {\n          break;\n        }\n        Command command = queue.poll();\n        command.execute();\n      }\n    }\n  }\n}\n</code></pre><h2>命令模式 VS 策略模式</h2><p>看了刚才的讲解，你可能会觉得，命令模式跟策略模式、工厂模式非常相似啊，那它们的区别在哪里呢？不仅如此，在留言区中我还看到有不止一个同学反映，感觉学过的很多模式都很相似。不知道你有没有类似的感觉呢？</p><p>实际上，这个问题我之前简单提到过，可能没有作为重点来说，有些同学印象不是很深刻，这里我就再跟你讲一讲。</p><p>实际上，每个设计模式都应该由两部分组成：第一部分是应用场景，即这个模式可以解决哪类问题；第二部分是解决方案，即这个模式的设计思路和具体的代码实现。不过，代码实现并不是模式必须包含的。如果你单纯地只关注解决方案这一部分，甚至只关注代码实现，就会产生大部分模式看起来都很相似的错觉。</p><p>实际上，设计模式之间的主要区别还是在于设计意图，也就是应用场景。单纯地看设计思路或者代码实现，有些模式确实很相似，比如策略模式和工厂模式。</p><p>之前讲策略模式的时候，我们有讲到，策略模式包含策略的定义、创建和使用三部分，从代码结构上来，它非常像工厂模式。它们的区别在于，策略模式侧重“策略”或“算法”这个特定的应用场景，用来解决根据运行时状态从一组策略中选择不同策略的问题，而工厂模式侧重封装对象的创建过程，这里的对象没有任何业务场景的限定，可以是策略，但也可以是其他东西。从设计意图上来，这两个模式完全是两回事儿。</p><p>有了刚刚的铺垫，接下来，我们再来看命令模式跟策略模式的区别。你可能会觉得，命令的执行逻辑也可以看作策略，那它是不是就是策略模式了呢？实际上，这两者有一点细微的区别。</p><p>在策略模式中，不同的策略具有相同的目的、不同的实现、互相之间可以替换。比如，BubbleSort、SelectionSort都是为了实现排序的，只不过一个是用冒泡排序算法来实现的，另一个是用选择排序算法来实现的。而在命令模式中，不同的命令具有不同的目的，对应不同的处理逻辑，并且互相之间不可替换。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>命令模式在平时工作中并不常用，你稍微了解一下就可以。今天，我重点讲解了它的设计意图，也就是能解决什么问题。</p><p>落实到编码实现，命令模式用到最核心的实现手段，就是将函数封装成对象。我们知道，在大部分编程语言中，函数是没法作为参数传递给其他函数的，也没法赋值给变量。借助命令模式，我们将函数封装成对象，这样就可以实现把函数像对象一样使用。</p><p>命令模式的主要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等等，这才是命令模式能发挥独一无二作用的地方。</p><h2>课堂讨论</h2><p>从我们已经学过的这些设计模式中，找两个代码实现或者设计思路很相似的模式，说一说它们的不同点。</p><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>","neighbors":{"left":{"article_title":"70 | 备忘录模式：对于大对象的备份和恢复，如何优化内存和时间的消耗？","id":223947},"right":{"article_title":"72 | 解释器模式：如何设计实现一个自定义接口告警规则功能？","id":225904}},"comments":[{"had_liked":false,"id":206701,"user_name":"，","can_delete":false,"product_type":"c1","uid":1701867,"ip_address":"","ucode":"A5543C8DFEB198","user_header":"https://static001.geekbang.org/account/avatar/00/19/f7/eb/e7127bb8.jpg","comment_is_top":false,"comment_ctime":1586918571,"is_pvip":true,"discussion_count":14,"race_medal":0,"score":"920709919915","product_id":100039001,"comment_content":"单例模式和享元模式,缓存,静态工厂方法:<br>他们的共同点是:对象的复用<br>不同点:<br>应用享元模式是为了对象&quot;共享使用&quot;，节省内存<br>而应用单例&#47;多例模式是为了限制对象的个数<br>应用缓存是为了提高访问效率<br>应用对象池(数据库连接池,线程池)是为了对象的&quot;重复使用&quot;和管理,主要是为了节省时间<br>有一种方法叫 静态工厂方法,例如 Boolean.valueof(),不会在每次调用时返回一个新对象,而是复用已有的,这一点有点像享元模式<br><br>适配器,代理,装饰器,桥接,:<br>他们的共同点是:对方法的增强<br>不同点:<br>适配器模式的作用是&quot;适配&quot;,通常用于适配不同的组件,新旧系统<br>桥接模式将接口部分和实现部分分离,使两者可以分别扩展<br>装饰者模式是对原始类功能进行增强，并且可以支持多次,多种增强<br>代理模式实现了代理类和原始类的解耦,使代理类可以用于增强不同的功能<br><br>策略模式与简单工厂模式,命令模式:<br>共同点:都有对if&#47;else进行下沉<br>不同点:<br>策略模式根据运行时状态返回一个&quot;策略&quot;&#47;&quot;算法&quot;,这些&quot;策略&quot;具有相同目的,比如BubbleSort、SelectionSort 都是为了实现排序<br>命令模式中不同的命令具有不同的目的，对应不同的处理逻辑，并且互相之间不可替换<br>而简单工厂更侧重返回一个创建的对象<br><br><br>桥接模式与服务提供者框架,静态工厂的辨析(来自effective java):<br>服务提供者框架是这样一个系统:<br>多个服务提供者实现一个服务,系统为服务提供者的客户端提供多个实现,并把它们从多个实现中解耦出来<br>它分为四部分:  <br>服务接口:系统抽象出一个接口,交给服务提供者实现(JDBC中的connection即为服务接口)<br>提供者注册API:交给服务提供者注册自己的API (Class.forName(),将自己的Driver类加载到JVM中,JDBC会查找该类并注册他的api)<br>服务访问API:是一个静态方法,供客户端获取服务实例(DriverManager.gtConnection()便是此处的静态工厂,它拿到的connection实例,其实是mysql包里的connection实现)<br>服务提供者接口:是服务接口实例的工厂对象(在此为mysql包内的Driver类)<br><br>在此处,桥接模式和静态工厂方法的使用,共同构成了服务提供者框架","like_count":215},{"had_liked":false,"id":206584,"user_name":"qinsi","can_delete":false,"product_type":"c1","uid":1667175,"ip_address":"","ucode":"090D9C4068FF12","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","comment_is_top":false,"comment_ctime":1586902639,"is_pvip":true,"discussion_count":3,"race_medal":0,"score":"310824547951","product_id":100039001,"comment_content":"GoF的设计模式脱胎于开发smalltalk的经验，而smalltalk的一大特点是自带图形界面，所以很多设计模式都是脱胎于解决图形界面的开发问题。命令模式在早期图形界面的编辑器中用于解决编辑历史的问题，比如在实现操作的同时还要实现一个反操作用来undo，而重放操作就可以redo。由于现代计算机的存储成本比设计模式刚出现那会低太多了，于是通过快照方式来实现编辑历史也变得可行了","like_count":73,"discussions":[{"author":{"id":1080985,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7e/99/c4302030.jpg","nickname":"Khirye","note":"","ucode":"6C54C126FA54B8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":279364,"discussion_content":"高手！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591332097,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1337598,"avatar":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","nickname":"岁月","note":"","ucode":"29A2A2BC3C4FE4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":264972,"discussion_content":"你这么一说我好像有印象了. 确实存在反向命令这个东西, 用来把状态恢复到上一个状态","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589363463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2096683,"avatar":"","nickname":"Geek_151295","note":"","ucode":"970A611ECFB457","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575014,"discussion_content":"追根溯源。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654523124,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206599,"user_name":"eason2017","can_delete":false,"product_type":"c1","uid":1009422,"ip_address":"","ucode":"E070BA624FA490","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/0e/c77ad9b1.jpg","comment_is_top":false,"comment_ctime":1586908263,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"147615796327","product_id":100039001,"comment_content":"Hystix熔断框架就用到了命令模式。","like_count":34},{"had_liked":false,"id":206583,"user_name":"大头","can_delete":false,"product_type":"c1","uid":1315367,"ip_address":"","ucode":"C1FB2C8A0FB0C0","user_header":"https://static001.geekbang.org/account/avatar/00/14/12/27/32746bbf.jpg","comment_is_top":false,"comment_ctime":1586901310,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"61716443454","product_id":100039001,"comment_content":"观察者模式和用接口实现的职责链模式，从设计意图来看，观察者重在状态变化时通知所有的观察者，观察者之间是并列关系。职责链模式侧重顺序处理，处理类之间是串行关系","like_count":14},{"had_liked":false,"id":206652,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1586913761,"is_pvip":false,"discussion_count":2,"race_medal":1,"score":"57421488609","product_id":100039001,"comment_content":"再比较下命令模式和策略模式，策略模式的意图是封装算法，它认为“行为”是一个完整的、不可拆分的业务，即其意图是让这些行为独立，并且可以相互替换，让行为的变化独立于拥有行为的客户；而命令模式则是对动作的解耦，把一个动作的执行分为执行对象，执行行为，让两者相互独立而不相互影响。二者的关注点不同：策略模式提供多种行为由调用者自己选用，算法的自由选用是其关注点。命令模式关注解耦，将请求的内容封装成命令由接受者执行。二者使用场景不同，策略模式适用于有多种行为可以相互替换的场景；而命令模式适用于解耦两个紧耦合关系的对象或多命令对撤销的场景。","like_count":14,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478207,"discussion_content":"这个要根据团队具体来看 还要根据新技术的渗透情况来决定 一个新技术开始可能是奇技淫巧 等过两年都接受了 可能就算不上了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576797884,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206610,"user_name":"shniu","can_delete":false,"product_type":"c1","uid":1019555,"ip_address":"","ucode":"E64CD8BED96D8D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/a3/d7e5fe8a.jpg","comment_is_top":false,"comment_ctime":1586909838,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"57421484686","product_id":100039001,"comment_content":"感觉redis就是使用了命令模式来处理指令的","like_count":14,"discussions":[{"author":{"id":1179252,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fe/74/c2a2d3d6.jpg","nickname":"YuCe","note":"","ucode":"690D9D40D125EF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275434,"discussion_content":"netty是第一种，redis是第二种","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1590715317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2068684,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eotIianb3beTzsGIte6BZxlIhEwc2ryrNBGxZy8ibKbfibVJyUS8d3ZxybAdfJwHPm13ydPC4VJP7Lbw/132","nickname":"taku","note":"","ucode":"B22DA9A4A9DC91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383091,"discussion_content":"redis客户端可以一次接受多个请求，然后再将请求集中一次发送给处理服务器，服务器处理完之后一次返回多个命令的结果。同老师将的list=》queue=》back 差不多","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625900608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2086960,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/d8/30/840b64fa.jpg","nickname":"Frank木风","note":"","ucode":"8DAA325F19E00E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299065,"discussion_content":"有可能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597552758,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206857,"user_name":"饭","can_delete":false,"product_type":"c1","uid":1610573,"ip_address":"","ucode":"B3F1702D4DE604","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJKj3GbvevFibxwJibTqm16NaE8MXibwDUlnt5tt73KF9WS2uypha2m1Myxic6Q47Zaj2DZOwia3AgicO7Q/132","comment_is_top":false,"comment_ctime":1586945583,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"44536618543","product_id":100039001,"comment_content":"老师，我看不少讲策略模式的文章，喜欢用电商促销打折作为例子，但是我看每种打折方案是不能相互替换的，反倒适合命令模式或工厂","like_count":10,"discussions":[{"author":{"id":1023009,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9c/21/5ff86ce4.jpg","nickname":"furuhata","note":"","ucode":"2FFFE226900893","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":236654,"discussion_content":"打折方案肯定是可以替换的吧，打8折和打6折，逻辑都能走的通。没毛病。获取钻石和获取金币两个命令簇，就真没办法相互替换了。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1587113146,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2733574,"avatar":"https://static001.geekbang.org/account/avatar/00/29/b6/06/cd1eaa49.jpg","nickname":"小王在努力","note":"","ucode":"A324EF87198905","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1023009,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9c/21/5ff86ce4.jpg","nickname":"furuhata","note":"","ucode":"2FFFE226900893","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531788,"discussion_content":"正解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637417586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":236654,"ip_address":""},"score":531788,"extra":"{\"user_type\":1}"}]},{"author":{"id":1513884,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL9WsnLTufa45PFXtAdze3cRDD2mjywEj0Ra6OI6NarJZFS4x0FBUuCjcfBPhiaHQ3UK1Fib9yEAEYA/132","nickname":"john2019","note":"","ucode":"82F4BEFFB68FDF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":242109,"discussion_content":"感觉电商打折可以理解成是相同目的，封装了不同的算法","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1587466736,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206617,"user_name":"黄林晴","can_delete":false,"product_type":"c1","uid":1362631,"ip_address":"","ucode":"B15C38AECDA88F","user_header":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","comment_is_top":false,"comment_ctime":1586910802,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"44536583762","product_id":100039001,"comment_content":"打卡 结束后 开启重刷 <br>第一遍 了解定义<br>第二遍代码实现<br>第三遍 实际应用","like_count":10},{"had_liked":false,"id":253680,"user_name":"阿骨打","can_delete":false,"product_type":"c1","uid":2122539,"ip_address":"","ucode":"35EADA5550162A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","comment_is_top":false,"comment_ctime":1602829547,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"27372633323","product_id":100039001,"comment_content":"争哥，这两节我感觉就已经不懂你在说啥了。。。<br>不过这个命令模式，我觉得就是java8中提供的 函数式编程，<br>&lt;将函数作为参数传递，甚至可以保存在内存中&gt; ---这句话不就是java8提供的概念吗？<br>一个 函数式接口(只有一个方法)@FunctionInterface， 一个实现类，实现类中的F() 写入具体的函数，<br>传递时 借助java8的新特性，好像在传递方法一样。。。 实际传递的是匿名内部类。","like_count":6,"discussions":[{"author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385420,"discussion_content":"同感","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1627032676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2563714,"avatar":"","nickname":"Geek_10fd43","note":"","ucode":"DE35DE0864E70C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404872,"discussion_content":"讲得越来越潦草了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634442689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":209536,"user_name":"不惑ing","can_delete":false,"product_type":"c1","uid":1207079,"ip_address":"","ucode":"AF04E417D38027","user_header":"https://static001.geekbang.org/account/avatar/00/12/6b/27/8c964e52.jpg","comment_is_top":false,"comment_ctime":1587565031,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"23062401511","product_id":100039001,"comment_content":"‘对于 IO 密集型的业务来说，它避免了多线程不停切换对性能的损耗’，<br>------------------------------------------------------------------------<br>线程切换不是对cpu密集型影响更大么<br>","like_count":5,"discussions":[{"author":{"id":2682006,"avatar":"https://static001.geekbang.org/account/avatar/00/28/ec/96/822631d5.jpg","nickname":"求你少吃点ya","note":"","ucode":"ECCC8DE6374ED4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588048,"discussion_content":"我感觉文章要表达的观点是，IO处理次数密集，也就是说瓶颈不是在CPU计算而是在IO上，线程的切换不会提高IO处理速度，反而因为线程上下文的切换增加了开销。Redis就是这种处理方式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663496660,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302606,"discussion_content":"偏激了，老师讨论的是IO密集型","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598968887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206569,"user_name":"马以","can_delete":false,"product_type":"c1","uid":1344431,"ip_address":"","ucode":"3FEA06CA14DE28","user_header":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","comment_is_top":false,"comment_ctime":1586882966,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23061719446","product_id":100039001,"comment_content":"设计模式接近尾声，坐等顶级互联网编程经验","like_count":5},{"had_liked":false,"id":206614,"user_name":"Ken张云忠","can_delete":false,"product_type":"c1","uid":1134288,"ip_address":"","ucode":"D0BAC9FC17DE2B","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","comment_is_top":false,"comment_ctime":1586910374,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18766779558","product_id":100039001,"comment_content":"代理模式与装饰器模式代码差不多，代理模式是业务非功能性的增强，装饰器模式是对业务功能性的增强。","like_count":4},{"had_liked":false,"id":247968,"user_name":"dreamzz","can_delete":false,"product_type":"c1","uid":2150488,"ip_address":"","ucode":"DD9126F479F614","user_header":"https://static001.geekbang.org/account/avatar/00/20/d0/58/be9e8f67.jpg","comment_is_top":false,"comment_ctime":1599960958,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14484862846","product_id":100039001,"comment_content":"尽管它无法利用多线程多核处理的优势，但是对于 IO 密集型的业务来说，它避免了多线程不停切换对性能的损耗。这句话是不是有问题？IO密集型不是需要多线程来提高cpu利用率吗？CPU密集型要减少使用多线程来避免的线程切换带来的开销。","like_count":3,"discussions":[{"author":{"id":1394822,"avatar":"https://static001.geekbang.org/account/avatar/00/15/48/86/54c68afe.jpg","nickname":"铁男神sama","note":"","ucode":"0A3E3E61D36EDE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378052,"discussion_content":"io业务不需要cpu的参与 所以在内存允许的情况下 使用多线程可以并行执行io任务 cpu可以去干其它事","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623032863,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207452,"user_name":"吴小智","can_delete":false,"product_type":"c1","uid":1310798,"ip_address":"","ucode":"C7C9F58B5C9F7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","comment_is_top":false,"comment_ctime":1587088280,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14471990168","product_id":100039001,"comment_content":"敲黑板：设计模式之间的主要区别还是在于设计意图，也就是应用场景。是的，在代码层面，无非就是继承、组合、多态；但每一种模式最初的目的是不一样的，想要解决的问题也是不一样的。","like_count":3},{"had_liked":false,"id":206713,"user_name":"88591","can_delete":false,"product_type":"c1","uid":1254656,"ip_address":"","ucode":"04CE3E46455185","user_header":"https://static001.geekbang.org/account/avatar/00/13/25/00/3afbab43.jpg","comment_is_top":false,"comment_ctime":1586919774,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14471821662","product_id":100039001,"comment_content":"类与类之间通信：使用命令对象（包含数据与行为）。解耦：请求转换成命命令，命令调度，命令执行","like_count":3},{"had_liked":false,"id":213183,"user_name":"learning","can_delete":false,"product_type":"c1","uid":1236953,"ip_address":"","ucode":"14CE94C24F9C87","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/d9/a90b2488.jpg","comment_is_top":false,"comment_ctime":1588323921,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10178258513","product_id":100039001,"comment_content":"while（handleCount &lt; MAX…）那个循环有问题，handleCount没变化，只能等队列为空才能退出","like_count":2,"discussions":[{"author":{"id":2152306,"avatar":"https://static001.geekbang.org/account/avatar/00/20/d7/72/cbef720d.jpg","nickname":"鲁鸣","note":"","ucode":"974BA3C3E64630","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306547,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600314883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207650,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1587128498,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10177063090","product_id":100039001,"comment_content":"代理模式和装饰器模式：区别代理模式可以控制对象访问，装饰器模式给对象增加功能，二者的使用场景不同。","like_count":2},{"had_liked":false,"id":276285,"user_name":"老庄道人","can_delete":false,"product_type":"c1","uid":1182146,"ip_address":"","ucode":"C102EA323A69B4","user_header":"https://static001.geekbang.org/account/avatar/00/12/09/c2/8c5442bf.jpg","comment_is_top":false,"comment_ctime":1611877496,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5906844792","product_id":100039001,"comment_content":"没有看出来策略模式和命令模式有什么相似的地方了。<br><br>个人理解可能看到上面的代码中的一堆 if 的地方，策略模式和工厂模式也有这种一堆 if，都是根据传入的参数做出新建对象的操作。所以说这三个模式相似。<br><br>但是我觉得上面的代码实现的并不好，真正的命令模式应该体现“命令的封装”！<br>也就是说，真正的命令模式实现中，应该先有命令，然后通过 Command 对象来具体封装这些命令。<br>但是上面的实现没有这种已经存在的命令，直接在 Command 中实现了。<br>这也不能说错，毕竟实际实现的时候要具体问题具体分析，但感觉一部分命令模式的精髓没有体现出来，导致觉得命令模式和策略模式是类似的。","like_count":1},{"had_liked":false,"id":252563,"user_name":"Spring","can_delete":false,"product_type":"c1","uid":1222211,"ip_address":"","ucode":"8175463FB4705B","user_header":"https://static001.geekbang.org/account/avatar/00/12/a6/43/cb6ab349.jpg","comment_is_top":false,"comment_ctime":1602385483,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5897352779","product_id":100039001,"comment_content":"我觉得策略模式就是采用不同的方式解决同一个问题，更偏向于可扩展。而命令模式更偏向于命令创建与执行的解耦","like_count":1,"discussions":[{"author":{"id":2122539,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","nickname":"阿骨打","note":"","ucode":"35EADA5550162A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312839,"discussion_content":"我实在是不懂这个命令模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602830145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2122539,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","nickname":"阿骨打","note":"","ucode":"35EADA5550162A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312838,"discussion_content":"命令创建与执行的解耦 -- 这个结构型中的 桥接模式 是这个意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602830130,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":213740,"user_name":"一个慢慢爬行的普通人","can_delete":false,"product_type":"c1","uid":1193589,"ip_address":"","ucode":"D38C25E119BCD7","user_header":"https://static001.geekbang.org/account/avatar/00/12/36/75/e346e04e.jpg","comment_is_top":false,"comment_ctime":1588542187,"is_pvip":false,"replies":[{"id":"86451","content":"有的，后面有一篇讲函数式编程。","user_name":"作者回复","comment_id":213740,"uid":"1190123","ip_address":"","utype":1,"ctime":1594632983,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"5883509483","product_id":100039001,"comment_content":"不知道老师会不会后面专栏进行functional programming和object oriented programming区别。尽管核心的编程思想和设计原理可能相近，但是还是希望老师能出一篇这样的专栏","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493857,"discussion_content":"有的，后面有一篇讲函数式编程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594632983,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":210572,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1587788625,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5882755921","product_id":100039001,"comment_content":"设计模式_71: 命令模式<br># 作业:<br>某种程度上，观察者模式(有消息队列那种)可以说是一种特殊的命令模式，它的“命令”类型要少一些，触发“命令”对应方法的逻辑也相对简单一些。<br># 感想:<br>今天的命令模式，让我想到了生命周期类的模型，强调对行为更精准的控制。","like_count":1},{"had_liked":false,"id":207792,"user_name":"Panmax","can_delete":false,"product_type":"c1","uid":1004871,"ip_address":"","ucode":"9D65E3B84C5519","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/47/d217c45f.jpg","comment_is_top":false,"comment_ctime":1587180807,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5882148103","product_id":100039001,"comment_content":"文中示例代码：<br>  int handledCount = 0;<br>  while (handledCount &lt; MAX_HANDLED_REQ_COUNT_PER_LOOP) {<br>    if (queue.isEmpty()) {<br>      break;<br>    }<br>    Command command = queue.poll();<br>    command.execute();<br>  }<br><br>while 最后是不是漏掉了 handledCount++？","like_count":1},{"had_liked":false,"id":206961,"user_name":"Hubbert伟涛","can_delete":false,"product_type":"c1","uid":1303556,"ip_address":"","ucode":"000C6A0BD4A102","user_header":"https://static001.geekbang.org/account/avatar/00/13/e4/04/05677b68.jpg","comment_is_top":false,"comment_ctime":1586964130,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"5881931426","product_id":100039001,"comment_content":"代理模式跟模板模式。虽然一个是结构型，一个是行为型，但是感觉他们有点相同之处。<br>代理模式是在不改变原有类的基础上，对原有类进行功能的扩展，可以使附加功能与非业务逻辑解耦，更加关注业务逻辑。<br>模板模式也是有两大作用，那就是复用和扩展。跟代理模式一样有个扩展功能。但却不是代码的扩展性，是指框架的扩展性。就例如测试框架，让框架用户可以在这些扩展点上扩展功能。<br>它们的相同之处是可扩展，不相同之处是一个方便代码的扩展，一个方便框架的扩展。","like_count":1,"discussions":[{"author":{"id":1315968,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqZIqY4cs6YKNx0OqeMrbjLIicqiafLNtLYJTN2zTtVPlwXZ7qlJ7xrGQictk1xCq5pEsIyqnkiaCib4zQ/132","nickname":"全炸攻城狮","note":"","ucode":"DB437F9190575C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":240353,"discussion_content":"我觉得他们的区别还是挺大的。结构性和行为型本身就表明了他们两个的区别，模版模式可以理解为一个编程范式，是对代码结构的规范；而代理模式，是对于被代理对象功能的增强。我觉得你理解的扩展，在这两个模式里面，所指代的意思是不同的，不适合拿来对比","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587354902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1303556,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e4/04/05677b68.jpg","nickname":"Hubbert伟涛","note":"","ucode":"000C6A0BD4A102","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1315968,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqZIqY4cs6YKNx0OqeMrbjLIicqiafLNtLYJTN2zTtVPlwXZ7qlJ7xrGQictk1xCq5pEsIyqnkiaCib4zQ/132","nickname":"全炸攻城狮","note":"","ucode":"DB437F9190575C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":246645,"discussion_content":"谢谢，受教了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587744372,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":240353,"ip_address":""},"score":246645,"extra":""}]},{"author":{"id":2122539,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","nickname":"阿骨打","note":"","ucode":"35EADA5550162A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312831,"discussion_content":"其实你说 这俩一样也行，我们从客户端的角度来看：\n1、代理，我新增了B，通过代理 织入A，最后我感觉我获得了A\n2、模板，我新增了B，通过重写植入了A，最后我感觉我获得了A","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602828990,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2122539,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","nickname":"阿骨打","note":"","ucode":"35EADA5550162A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312830,"discussion_content":"你说的是 继承形式的代理 vs  模板模式\n代理目的是 为了对业务增加非业务的功能。\n模板则是 业务需要客户端自己实现一部分功能。\n其实我觉得 结构型 里包含了行为型，\n 结构型只是提出了怎么组装类和对象\n行为型则是拿着结构型的概念 付出行动。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602828818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206673,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1586915721,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5881883017","product_id":100039001,"comment_content":"课堂讨论:<br>观察者模式(Observer Pattern)与职责链模式(Chain Of Responsibility Pattern)的实现方式是类似的:<br><br>在Observer Pattern中, Observable注册多个Observer, Observable发送事件时遍历所有Observer执行操作.<br><br>在COR Pattern中, Chain添加多个Responsibility Object, 事件触发时Chain遍历所有Responsibility Ojbect执行操作.<br><br>虽然UML类图和代码实现上两者十分相似, 不同之处在于Observer Pattern专注Observable与Observer的解耦, COR Pattern关注当事件触发时, 事件沿着链条传递, 链条上的对象顺序处理事件, 或拦截事件.<br><br>","like_count":1},{"had_liked":false,"id":206637,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1586912520,"is_pvip":false,"replies":[{"id":"86792","content":"不，我这里是单线程处理的。你再仔细品品。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1594904230,"ip_address":"","comment_id":206637,"utype":1}],"discussion_count":6,"race_medal":0,"score":"5881879816","product_id":100039001,"comment_content":"“整个手游后端服务器轮询获取客户端发来的请求，获取到请求之后，借助命令模式，把请求包含的数据和处理逻辑封装为命令对象，并存储在内存队列中。然后，再从队列中取出一定数量的命令来执行。”<br>————————————————————<br>感觉不需要放入队列呢，直接执行命令对象呢？取出一定数量，指的是线程池里批处理吗？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491846,"discussion_content":"不，我这里是单线程处理的。你再仔细品品。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594904230,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1001893,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","nickname":"小文同学","note":"","ucode":"48F2AEB989C12A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":234713,"discussion_content":"hi 我简单说一下，在计算密集型的游戏服务中，一般会为了减少线程切换而而限制执行线程数，甚至为了避免可见性问题，用单线程去运算，消费者比生产者少很多。设置中间队列是可以缓存执行任务，同时客户端也可以快速地返回。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1586996700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1336475,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","nickname":"J.Smile","note":"","ucode":"C4D98DFDBF7584","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1001893,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","nickname":"小文同学","note":"","ucode":"48F2AEB989C12A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":234838,"discussion_content":"哦，那其实就是为了减轻客户端的压力了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587001049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":234713,"ip_address":""},"score":234838,"extra":""},{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1001893,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","nickname":"小文同学","note":"","ucode":"48F2AEB989C12A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":236859,"discussion_content":"学习啦！\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587127462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":234713,"ip_address":""},"score":236859,"extra":""}]},{"author":{"id":1370125,"avatar":"https://static001.geekbang.org/account/avatar/00/14/e8/0d/6d303d18.jpg","nickname":"无双BaOY_WHA","note":"","ucode":"41F282C31D256C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289204,"discussion_content":"一般会有一个快速队列和一个慢速队列。紧急的命令放到快速队列。在一个游戏帧（可以理解为循环中的一次）里，快速队列的命令全部执行，慢速队列里的命令只执行一个或几个。这样做是为了兼顾游戏帧率和紧迫命令的执行速度。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594024668,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1549364,"avatar":"","nickname":"Geek_3b1096","note":"","ucode":"A6BD92B79B3632","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":249474,"discussion_content":"谢谢小文同学热心的讲解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587941253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344741,"user_name":"woJA1wCgAADPn-mAUDOmrWvgvB0cj-Pw","can_delete":false,"product_type":"c1","uid":2919021,"ip_address":"","ucode":"5F4376EB542CA9","user_header":"","comment_is_top":false,"comment_ctime":1651744326,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651744326","product_id":100039001,"comment_content":"这次的命令行模式举的例子，并没有体现撤销重做，反而更侧重策略","like_count":0},{"had_liked":false,"id":342856,"user_name":"Already°初晴","can_delete":false,"product_type":"c1","uid":2189259,"ip_address":"","ucode":"4600E0F445C0C2","user_header":"https://static001.geekbang.org/account/avatar/00/21/67/cb/0811c67e.jpg","comment_is_top":false,"comment_ctime":1650509024,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650509024","product_id":100039001,"comment_content":"mybatis框架也用到了命令模式","like_count":0},{"had_liked":false,"id":318040,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1635129994,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635129994","product_id":100039001,"comment_content":"代理模式和装饰器模式，代码结构非常类似，主要就是设计意图和增强的目的不同","like_count":0},{"had_liked":false,"id":299691,"user_name":"Amon Tin","can_delete":false,"product_type":"c1","uid":2618193,"ip_address":"","ucode":"25391BEEB6A719","user_header":"https://static001.geekbang.org/account/avatar/00/27/f3/51/c8eb2d0c.jpg","comment_is_top":false,"comment_ctime":1624802270,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1624802270","product_id":100039001,"comment_content":"IM系统是典型的IO密集型应用，IM连接层要把各种类型的消息转发到不同的长连接上，大量的操作都是在进行网络转发，如果为每个消息起一个线程处理转发逻辑，在消息高峰期，CPU切换线程压力会非常大，而用Epoll+单线程循环+异步IO转发，再为每个CPU核心起一个进程，多进程+单线程则能把CPU的效率最大化。<br>今天看到命令模式才发现，IM系统中，每种消息其实就是命令模式中的命令。","like_count":0},{"had_liked":false,"id":276905,"user_name":"程序员老王","can_delete":false,"product_type":"c1","uid":1025340,"ip_address":"","ucode":"28577A15F064CF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a5/3c/7c0d2e57.jpg","comment_is_top":false,"comment_ctime":1612172024,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612172024","product_id":100039001,"comment_content":"把请求的数据和命令封装到对象是啥意思？rcp请求 都是命令和数据都在接口中，不需要封装呀？","like_count":0},{"had_liked":false,"id":273944,"user_name":"Song╮承諾","can_delete":false,"product_type":"c1","uid":1590793,"ip_address":"","ucode":"50FDBFE5BDDD12","user_header":"https://static001.geekbang.org/account/avatar/00/18/46/09/c61257f6.jpg","comment_is_top":false,"comment_ctime":1610760468,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1610760468","product_id":100039001,"comment_content":"工厂、适配器、策略都很相似，不过也好区分，创建对象就是工厂-创建型，查询组合数据输出给外部就是适配器-结构性，接收处理外部传入的数据就是策略-行为性，也就是小争哥说的不同场景吧","like_count":0},{"had_liked":false,"id":272413,"user_name":"大力水手Jerry","can_delete":false,"product_type":"c1","uid":1227840,"ip_address":"","ucode":"E4A6C71E275DB5","user_header":"https://static001.geekbang.org/account/avatar/00/12/bc/40/2279cfb5.jpg","comment_is_top":false,"comment_ctime":1610084491,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610084491","product_id":100039001,"comment_content":"“命令模式用到最核心的实现手段，就是将函数封装成对象。我们知道，在大部分编程语言中，函数是没法作为参数传递给其他函数的，也没法赋值给变量。借助命令模式，我们将函数封装成对象，这样就可以实现把函数像对象一样使用。”将函数封装成对象并不是因为函数无法作为变量或参数，类似C和golang，都是First-class functions的，但某些情况下依然要用命令模式，因为我们要构建一个通用的事件响应结构，利用接口解耦invoker和command，如果单靠函数就无法做到这一点。","like_count":0},{"had_liked":false,"id":265180,"user_name":"Geek_喝开水不烫嘴","can_delete":false,"product_type":"c1","uid":1660842,"ip_address":"","ucode":"B1A931C1224223","user_header":"https://static001.geekbang.org/account/avatar/00/19/57/aa/aad61182.jpg","comment_is_top":false,"comment_ctime":1606806833,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606806833","product_id":100039001,"comment_content":"线程池ThreadPoolExecutor是用到了命令模式吗, 接口是runnable, 实现是自定义的run方法, 然后execute方法把run方法(即文中的函数)放到works中去执行, 或者队列去排队等等","like_count":0},{"had_liked":false,"id":260898,"user_name":"zhengyu.nie","can_delete":false,"product_type":"c1","uid":1541669,"ip_address":"","ucode":"FFE0377D323E46","user_header":"https://static001.geekbang.org/account/avatar/00/17/86/25/25ded6c3.jpg","comment_is_top":false,"comment_ctime":1605149310,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1605149310","product_id":100039001,"comment_content":"策略模式是同一个目的的不同实现方式，可以动态切换。命令模式是不同目的不可互相替换。工厂模式是没有目的，只是封装创建行为。","like_count":0},{"had_liked":false,"id":257162,"user_name":"cv0cv0","can_delete":false,"product_type":"c1","uid":1360093,"ip_address":"","ucode":"93FF9277F03FD0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLEIsgI4ub1VOKWtVOfouAzSqx8Yt8ibQEsAnwNJsJHmuJzzpQqG79HullvYwpic8hgiclgON2GwXSjw/132","comment_is_top":false,"comment_ctime":1603868640,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603868640","product_id":100039001,"comment_content":"Kotlin 的实现方式好像就是这个。","like_count":0},{"had_liked":false,"id":253708,"user_name":"大方方","can_delete":false,"product_type":"c1","uid":1354013,"ip_address":"","ucode":"621AD8F1485753","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/6cyOoRd2dROgiblAJkW6RLhUyH1wwU0NNibIIuV930eQ9TiaNT41K61kBSVkvYoDYg7mJtuEoCQY1awBmV0WW6BFg/132","comment_is_top":false,"comment_ctime":1602839353,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602839353","product_id":100039001,"comment_content":"实例中的request类定义在哪里？","like_count":0},{"had_liked":false,"id":247970,"user_name":"dreamzz","can_delete":false,"product_type":"c1","uid":2150488,"ip_address":"","ucode":"DD9126F479F614","user_header":"https://static001.geekbang.org/account/avatar/00/20/d0/58/be9e8f67.jpg","comment_is_top":false,"comment_ctime":1599961766,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599961766","product_id":100039001,"comment_content":"命令模式将请求（命令）封装为一个对象，这样可以使用不同的请求参数化其他对象（将不同请求依赖注入到其他对象），并且能够支持请求（命令）的排队执行、记录日志、撤销等（附加控制）功能。<br>这句翻译，排队，记录日志是否应该放在参数化其他对象的前面","like_count":0},{"had_liked":false,"id":245530,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1598968761,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598968761","product_id":100039001,"comment_content":"看了今天的文章才知道策略模式和命令模式的区别。之前写的代码是命令模式，一直以为是策略模式。","like_count":0},{"had_liked":false,"id":240693,"user_name":"静心","can_delete":false,"product_type":"c1","uid":1335457,"ip_address":"","ucode":"EB264FA6519FDA","user_header":"https://static001.geekbang.org/account/avatar/00/14/60/a1/8f003697.jpg","comment_is_top":false,"comment_ctime":1597035566,"is_pvip":true,"replies":[{"id":"89259","content":"可以的。跟其他对象的序列化无差别，可以使用语言相关的，比如java本身自带的序列化方式，也可以使用语言无关的，比如protobuf，也可以自定义序列化方式","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1597452519,"ip_address":"","comment_id":240693,"utype":1}],"discussion_count":1,"race_medal":5,"score":"1597035566","product_id":100039001,"comment_content":"请教命令模式可以在进程间实现吗？按照本文的command定义，如果想要在进程间使用该模式，command对象的序列化怎么办？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503530,"discussion_content":"可以的。跟其他对象的序列化无差别，可以使用语言相关的，比如java本身自带的序列化方式，也可以使用语言无关的，比如protobuf，也可以自定义序列化方式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597452519,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240186,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1596782063,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596782063","product_id":100039001,"comment_content":"代理模式，桥接模式和装饰者模式，三者代码实现都很类似，采用组合的方式。不同点在于应用场景：<br>代理模式是在不改变原有业务处理逻辑的前提下，安全的添加非业务的附加功能，例如验票，限流等。<br>装饰者模式的代码实现非常类似代理模式，但装饰者模式强调功能增强，即对已有业务功能进行增强处理，例如加缓存等。<br>桥接模式是将业务中存在独立变化方向的逻辑拆分成不同的类，类之间通过组合方式联结。<br>个人觉得在实际开发中应该不拘泥于具体的设计模式，而是应该把握设计模式的初衷，即应对复杂场景，通过拆分解耦的方式保证类的单一职责，基于接口而非实现保证扩展性","like_count":0},{"had_liked":false,"id":232540,"user_name":"无双BaOY_WHA","can_delete":false,"product_type":"c1","uid":1370125,"ip_address":"","ucode":"41F282C31D256C","user_header":"https://static001.geekbang.org/account/avatar/00/14/e8/0d/6d303d18.jpg","comment_is_top":false,"comment_ctime":1594031155,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594031155","product_id":100039001,"comment_content":"C&#47;C++虽然有函数指针，但通常也是用类来封装命令的。原因是C&#47;C++对于头等函数的支持非常有限——函数指针是无状态的。<br>此外，闭包是实现命令模式的利器（可以传递状态）。C++11中的闭包因为要手动管理内存，所以使用起来比较棘手。而JavaScript就可以使用闭包把命令映射到某个或多个函数，例如下面的代码：<br>function makeMoveUnitCommand(unit, x, y) {<br>    var xBefore, yBefore;<br>    return {<br>        exeute: function() {<br>            xBefore = unit.x();<br>            yBefore = unit.y();<br>            unit.moveTo(x, y);<br>        },<br>        undo: function() {<br>            unit.moveTo(xBefore, yBefore);<br>        }<br>    };<br>}","like_count":0},{"had_liked":false,"id":232306,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1593951330,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1593951330","product_id":100039001,"comment_content":"命令模式，即客户端与服务器的约定协议。客户端需要什么告诉服务端，服务端制定一系列的command指令。然后客户端可以发送这些指令，服务端接收到后进行执行。执行可以缓存在一个队列，或者每接收到一个command就执行。","like_count":0},{"had_liked":false,"id":230429,"user_name":"乾坤瞬间","can_delete":false,"product_type":"c1","uid":1683130,"ip_address":"","ucode":"15BDCF29CBF8EB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","comment_is_top":false,"comment_ctime":1593388889,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593388889","product_id":100039001,"comment_content":"全是对策略模式和命令模式有了一个彻底的认识了，策略是对达到同样目的的不同实现，而之前一直理解为结果可能不同的策略，其实这样的理解本身不符合策略这两个字。既然是策略，必然是为了达到最终结果的一致，而过程可能是五花八门的","like_count":0},{"had_liked":false,"id":226703,"user_name":"大叶子","can_delete":false,"product_type":"c1","uid":1135900,"ip_address":"","ucode":"31CCDE9E88C023","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/1c/c76abe73.jpg","comment_is_top":false,"comment_ctime":1592187559,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592187559","product_id":100039001,"comment_content":"享元模式和原型模式，<br>享元模式：结构型模式，是为了节省内存，把相同或类型的字段设计成享元，达到复用的目的；<br>原型模式：创建型模式，一些对象的创建成本很高，利用已有的对象把数据拷贝过来，场景是创建大对象的时候。其实从使用目的来说，他们的区别就很大了。还是得看设计的目的！","like_count":0},{"had_liked":false,"id":211247,"user_name":"一区","can_delete":false,"product_type":"c1","uid":1793770,"ip_address":"","ucode":"B5142A6276E490","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/a2mRI7BYncHCL6QWfibe7g7MWc70fSsqQibu7o9PcHjicYwo5dSnAoUN75HDDRz4GXWJdpWw59yJsMwFv3t7zSiaJQ/132","comment_is_top":false,"comment_ctime":1587920460,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587920460","product_id":100039001,"comment_content":"老师好，请问IO密集型，不应该是用多线程或者协程来开发吗，如果单线程阻塞模型，遇到IO阻塞不是后续请求要等待","like_count":0},{"had_liked":false,"id":210293,"user_name":"嘉一","can_delete":false,"product_type":"c1","uid":1196864,"ip_address":"","ucode":"8D16BD0B75B019","user_header":"https://static001.geekbang.org/account/avatar/00/12/43/40/e7ef18de.jpg","comment_is_top":false,"comment_ctime":1587714979,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587714979","product_id":100039001,"comment_content":"命令模式在游戏客户端还是很常用的，有很多这种本身是不同行为但是需要按照一定的规则来处理的情况，此时就很有必要把这些不同种类的行为抽象出来一个对象，这样就方便统一的对这些要执行的行为的管理了","like_count":0},{"had_liked":false,"id":206683,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1586917023,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586917023","product_id":100039001,"comment_content":"装饰器模式和适配器模式在组合的实现时候就很相似,但是装饰器模式是为了增强原有类的功能而适配器模式虽然也是修改原有类,但是是为了补救原有的缺陷的","like_count":0}]}