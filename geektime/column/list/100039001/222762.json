{"id":222762,"title":"69 | 访问者模式（下）：为什么支持双分派的语言不需要访问者模式？","content":"<p>上一节课中，我们学习了访问者模式的原理和实现，并且还原了访问者模式诞生的思维过程。总体上来讲，这个模式的代码实现比较难，所以应用场景并不多。从应用开发的角度来说，它的确不是我们学习的重点。</p><p>不过，我们前面反复说过，学习我的专栏，并不只是让你掌握知识，更重要的是锻炼你分析、解决问题的能力，锻炼你的逻辑思维能力，所以，今天我们继续把访问者模式作为引子，一块讨论一下这样两个问题，希望能激发你的深度思考：</p><ul>\n<li>为什么支持双分派的语言不需要访问者模式呢？</li>\n<li>除了访问者模式，上一节课中的例子还有其他实现方案吗？</li>\n</ul><p>话不多说，让我们正式开始今天的学习吧！</p><h2>为什么支持双分派的语言不需要访问者模式？</h2><p>实际上，讲到访问者模式，大部分书籍或者资料都会讲到Double Dispatch，中文翻译为双分派。虽然学习访问者模式，并不用非得理解这个概念，我们前面的讲解就没有提到它，但是，为了让你在查看其它书籍或者资料的时候，不会卡在这个概念上，我觉得有必要在这里讲一下。</p><p>除此之外，我觉得，学习Double Dispatch还能加深你对访问者模式的理解，而且能一并帮你搞清楚今天文章标题中的这个问题：为什么支持双分派的语言就不需要访问者模式？这个问题在面试中可是会被问到的哦！</p><!-- [[[read_end]]] --><p>既然有Double Dispatch，对应的就有Single Dispatch。所谓<strong>Single Dispatch</strong>，指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的编译时类型来决定。所谓<strong>Double Dispatch</strong>，指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的运行时类型来决定。</p><p><strong>如何理解“Dispatch”这个单词呢？</strong> 在面向对象编程语言中，我们可以把方法调用理解为一种消息传递，也就是“Dispatch”。一个对象调用另一个对象的方法，就相当于给它发送一条消息。这条消息起码要包含对象名、方法名、方法参数。</p><p><strong>如何理解“Single”“Double”这两个单词呢？</strong>“Single”“Double”指的是执行哪个对象的哪个方法，跟几个因素的运行时类型有关。我们进一步解释一下。Single Dispatch之所以称为“Single”，是因为执行哪个对象的哪个方法，只跟“对象”的运行时类型有关。Double Dispatch之所以称为“Double”，是因为执行哪个对象的哪个方法，跟“对象”和“方法参数”两者的运行时类型有关。</p><p>具体到编程语言的语法机制，Single Dispatch和Double Dispatch跟多态和函数重载直接相关。当前主流的面向对象编程语言（比如，Java、C++、C#）都只支持Single Dispatch，不支持Double Dispatch。</p><p>接下来，我们拿Java语言来举例说明一下。</p><p>Java支持多态特性，代码可以在运行时获得对象的实际类型（也就是前面提到的运行时类型），然后根据实际类型决定调用哪个方法。尽管Java支持函数重载，但Java设计的函数重载的语法规则是，并不是在运行时，根据传递进函数的参数的实际类型，来决定调用哪个重载函数，而是在编译时，根据传递进函数的参数的声明类型（也就是前面提到的编译时类型），来决定调用哪个重载函数。也就是说，具体执行哪个对象的哪个方法，只跟对象的运行时类型有关，跟参数的运行时类型无关。所以，Java语言只支持Single Dispatch。</p><p>这么说比较抽象，我举个例子来具体说明一下，代码如下所示：</p><pre><code>public class ParentClass {\n  public void f() {\n    System.out.println(&quot;I am ParentClass's f().&quot;);\n  }\n}\n\npublic class ChildClass extends ParentClass {\n  public void f() {\n    System.out.println(&quot;I am ChildClass's f().&quot;);\n  }\n}\n\npublic class SingleDispatchClass {\n  public void polymorphismFunction(ParentClass p) {\n    p.f();\n  }\n\n  public void overloadFunction(ParentClass p) {\n    System.out.println(&quot;I am overloadFunction(ParentClass p).&quot;);\n  }\n\n  public void overloadFunction(ChildClass c) {\n    System.out.println(&quot;I am overloadFunction(ChildClass c).&quot;);\n  }\n}\n\npublic class DemoMain {\n  public static void main(String[] args) {\n    SingleDispatchClass demo = new SingleDispatchClass();\n    ParentClass p = new ChildClass();\n    demo.polymorphismFunction(p);//执行哪个对象的方法，由对象的实际类型决定\n    demo.overloadFunction(p);//执行对象的哪个方法，由参数对象的声明类型决定\n  }\n}\n\n//代码执行结果:\nI am ChildClass's f().\nI am overloadFunction(ParentClass p).\n</code></pre><p>在上面的代码中，第31行代码的polymorphismFunction()函数，执行p的实际类型的f()函数，也就是ChildClass的f()函数。第32行代码的overloadFunction()函数，匹配的是重载函数中的overloadFunction(ParentClass p)，也就是根据p的声明类型来决定匹配哪个重载函数。</p><p>假设Java语言支持Double Dispatch，那下面的代码（摘抄自上节课中第二段代码，建议结合上节课的讲解一块理解）中的第37行就不会报错。代码会在运行时，根据参数（resourceFile）的实际类型（PdfFile、PPTFile、WordFile），来决定使用extract2txt的三个重载函数中的哪一个。那下面的代码实现就能正常运行了，也就不需要访问者模式了。这也回答了为什么支持Double Dispatch的语言不需要访问者模式。</p><pre><code>public abstract class ResourceFile {\n  protected String filePath;\n  public ResourceFile(String filePath) {\n    this.filePath = filePath;\n  }\n}\n\npublic class PdfFile extends ResourceFile {\n  public PdfFile(String filePath) {\n    super(filePath);\n  }\n  //...\n}\n//...PPTFile、WordFile代码省略...\npublic class Extractor {\n  public void extract2txt(PPTFile pptFile) {\n    //...\n    System.out.println(&quot;Extract PPT.&quot;);\n  }\n\n  public void extract2txt(PdfFile pdfFile) {\n    //...\n    System.out.println(&quot;Extract PDF.&quot;);\n  }\n\n  public void extract2txt(WordFile wordFile) {\n    //...\n    System.out.println(&quot;Extract WORD.&quot;);\n  }\n}\n\npublic class ToolApplication {\n  public static void main(String[] args) {\n    Extractor extractor = new Extractor();\n    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[0]);\n    for (ResourceFile resourceFile : resourceFiles) {\n      extractor.extract2txt(resourceFile);\n    }\n  }\n\n  private static List&lt;ResourceFile&gt; listAllResourceFiles(String resourceDirectory) {\n    List&lt;ResourceFile&gt; resourceFiles = new ArrayList&lt;&gt;();\n    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)\n    resourceFiles.add(new PdfFile(&quot;a.pdf&quot;));\n    resourceFiles.add(new WordFile(&quot;b.word&quot;));\n    resourceFiles.add(new PPTFile(&quot;c.ppt&quot;));\n    return resourceFiles;\n  }\n}\n</code></pre><h2>除了访问者模式，上一节的例子还有其他实现方案吗？</h2><p>上节课，我通过一个例子来给你展示了，访问者模式是如何一步一步设计出来的。我们这里再一块回顾一下那个例子。我们从网站上爬取了很多资源文件，它们的格式有三种：PDF、PPT、Word。我们要开发一个工具来处理这批资源文件，这其中就包含抽取文本内容、压缩资源文件、提取文件元信息等。</p><p>实际上，开发这个工具有很多种代码设计和实现思路。为了讲解访问者模式，上节课我们选择了用访问者模式来实现。实际上，我们还有其他的实现方法，比如，我们还可以利用工厂模式来实现，定义一个包含extract2txt()接口函数的Extractor接口。PdfExtractor、PPTExtractor、WordExtractor类实现Extractor接口，并且在各自的extract2txt()函数中，分别实现Pdf、PPT、Word格式文件的文本内容抽取。ExtractorFactory工厂类根据不同的文件类型，返回不同的Extractor。</p><p>这个实现思路其实更加简单，我们直接看代码。</p><pre><code>public abstract class ResourceFile {\n  protected String filePath;\n  public ResourceFile(String filePath) {\n    this.filePath = filePath;\n  }\n  public abstract ResourceFileType getType();\n}\n\npublic class PdfFile extends ResourceFile {\n  public PdfFile(String filePath) {\n    super(filePath);\n  }\n\n  @Override\n  public ResourceFileType getType() {\n    return ResourceFileType.PDF;\n  }\n\n  //...\n}\n\n//...PPTFile/WordFile跟PdfFile代码结构类似，此处省略...\n\npublic interface Extractor {\n  void extract2txt(ResourceFile resourceFile);\n}\n\npublic class PdfExtractor implements Extractor {\n  @Override\n  public void extract2txt(ResourceFile resourceFile) {\n    //...\n  }\n}\n\n//...PPTExtractor/WordExtractor跟PdfExtractor代码结构类似，此处省略...\n\npublic class ExtractorFactory {\n  private static final Map&lt;ResourceFileType, Extractor&gt; extractors = new HashMap&lt;&gt;();\n  static {\n    extractors.put(ResourceFileType.PDF, new PdfExtractor());\n    extractors.put(ResourceFileType.PPT, new PPTExtractor());\n    extractors.put(ResourceFileType.WORD, new WordExtractor());\n  }\n\n  public static Extractor getExtractor(ResourceFileType type) {\n    return extractors.get(type);\n  }\n}\n\npublic class ToolApplication {\n  public static void main(String[] args) {\n    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[0]);\n    for (ResourceFile resourceFile : resourceFiles) {\n      Extractor extractor = ExtractorFactory.getExtractor(resourceFile.getType());\n      extractor.extract2txt(resourceFile);\n    }\n  }\n\n  private static List&lt;ResourceFile&gt; listAllResourceFiles(String resourceDirectory) {\n    List&lt;ResourceFile&gt; resourceFiles = new ArrayList&lt;&gt;();\n    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)\n    resourceFiles.add(new PdfFile(&quot;a.pdf&quot;));\n    resourceFiles.add(new WordFile(&quot;b.word&quot;));\n    resourceFiles.add(new PPTFile(&quot;c.ppt&quot;));\n    return resourceFiles;\n  }\n}\n</code></pre><p>当需要添加新的功能的时候，比如压缩资源文件，类似抽取文本内容功能的代码实现，我们只需要添加一个Compressor接口，PdfCompressor、PPTCompressor、WordCompressor三个实现类，以及创建它们的CompressorFactory工厂类即可。唯一需要修改的只有最上层的ToolApplication类。基本上符合“对扩展开放、对修改关闭”的设计原则。</p><p>对于资源文件处理工具这个例子，如果工具提供的功能并不是非常多，只有几个而已，那我更推荐使用工厂模式的实现方式，毕竟代码更加清晰、易懂。相反，如果工具提供非常多的功能，比如有十几个，那我更推荐使用访问者模式，因为访问者模式需要定义的类要比工厂模式的实现方式少很多，类太多也会影响到代码的可维护性。</p><h2>重点回顾</h2><p>好了，今天内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>总体上来讲，访问者模式难以理解，应用场景有限，不是特别必需，我不建议在项目中使用它。所以，对于上节课中的处理资源文件的例子，我更推荐使用工厂模式来设计和实现。</p><p>除此之外，我们今天重点讲解了Double Dispatch。在面向对象编程语言中，方法调用可以理解为一种消息传递（Dispatch）。一个对象调用另一个对象的方法，就相当于给它发送一条消息，这条消息起码要包含对象名、方法名和方法参数。</p><p>所谓Single Dispatch，指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的编译时类型来决定。所谓Double Dispatch，指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的运行时类型来决定。</p><p>具体到编程语言的语法机制，Single Dispatch和Double Dispatch跟多态和函数重载直接相关。当前主流的面向对象编程语言（比如，Java、C++、C#）都只支持Single Dispatch，不支持Double Dispatch。</p><h2>课堂讨论</h2><ol>\n<li>访问者模式将操作与对象分离，是否违背面向对象设计原则？你怎么看待这个问题呢？</li>\n<li>在解释Single Dispatch的代码示例中，如果我们把SingleDispatchClass的代码改成下面这样，其他代码不变，那DemoMain的输出结果会是什么呢？为什么会是这样的结果呢？</li>\n</ol><pre><code>public class SingleDispatchClass {\n  public void polymorphismFunction(ParentClass p) {\n    p.f();\n  }\n\n  public void overloadFunction(ParentClass p) {\n    p.f();\n  }\n\n  public void overloadFunction(ChildClass c) {\n    c.f();\n  }\n}\n</code></pre><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>","comments":[{"had_liked":false,"id":204871,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1586485055,"is_pvip":false,"discussion_count":2,"race_medal":1,"score":"426788247359","product_id":100039001,"comment_content":"课后思考：<br>1. 看要怎么理解这个问题了，简单来看将操作与对象分离是违背了面向对象的设计原则，但从另外的角度看，将操作也看做对象，然后将不同的对象进行组合，那么并不违背面向对象的设计，而且在访问者模式中，操作可能不断增加，是属于是变化比较多的，将不变的部分和可变的部分开，然后使用组合的方式使用是符合面向对象设计的。<br>2. 会输出：<br>I am ChildClass&#39;s f().<br>I am ChildClass&#39;s f().<br>调用demo.overloadFunction(p);时，会根据重载特性调用函数<br>public void overloadFunction(ParentClass p) <br>{ <br>    p.f(); <br>}<br>运行时，因为p是ChildClass对象，所以会根据多态特性使用ChildClass的f函数。","like_count":100,"discussions":[{"author":{"id":1297630,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","nickname":"剑八","note":"","ucode":"0A09F41DB8A4E7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288965,"discussion_content":"DDD里面，如果是一个业务实体对象，这个就违反了\n访问者模式其实扩展性也不好，因为vistor每增加一个特定类型的资源类，就要修改增加方法。\n可以将对于资源文件的处理抽象一个接口，底层有不同的处理实现：提取文本，压缩\n如果本身都需要做提取文本，压缩，则可以使用职责链模式\n如果后面还有解密，提取文本等操作组合，而这些组合是调用方动态指定的，则这部分可以考虑做成职责链，然后具体是否需要执行这个链结点由入参决定。而这些是否需要解密的配置可以是spring properties等配置。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593945782,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1887603,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/cd/73/f6889c2f.jpg","nickname":"Wind","note":"","ucode":"AD108636DE44C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1297630,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","nickname":"剑八","note":"","ucode":"0A09F41DB8A4E7","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":298917,"discussion_content":"访问者强调的是所有访问者访问资源的方式，并不强调访问者之间的关系，例如作者例子中的提取文字，可以是用来分词供搜索的，压缩可以是保留源文件归档的，两者并没有管道流那种处理关系，这个和职责链还是有很大差别的","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1597477455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":288965,"ip_address":""},"score":298917,"extra":""}]}]},{"had_liked":false,"id":204940,"user_name":"，","can_delete":false,"product_type":"c1","uid":1701867,"ip_address":"","ucode":"A5543C8DFEB198","user_header":"https://static001.geekbang.org/account/avatar/00/19/f7/eb/e7127bb8.jpg","comment_is_top":false,"comment_ctime":1586496787,"is_pvip":true,"discussion_count":5,"race_medal":0,"score":"113255646483","product_id":100039001,"comment_content":"关于访问者模式的替代方式,我的看法:<br>先放总结:   行为不可抽象+水平扩展较多--&gt;工厂模式更合适<br>                   行为可抽象+垂直扩展较多--&gt;模板方法模式更合适<br>      我认为模板方法模式和工厂模式都可以,具体使用哪种,应该根据扩展的方向来确认:<br>当前的场景是对不同文件格式的文本进行处理,目前有word,ppt与pdf三种格式,他们的行为都不一致,比如word的抽取,分析与pdf的抽取,分析行为不一致,而且扩展的方向是添加不同的文件格式,比如txt格式,excel等格式,那么最好的方式就是采用工厂模式,每次添加新格式需要添加新的工厂,实现相应的方法<br>     如果扩展的方向是给不同文件格式添加更多的功能,同时这些行为可以抽象出来,比如当前有抽取,分析,压缩等功能,他们有很大一部分可以抽象到父类,那么我要给所有的文件格式添加敏感词替换,格式化文本等功能,就可以将它们添加到父类,而不用每个工厂都加一遍,这种情况模板方法模式更合适","like_count":27,"discussions":[{"author":{"id":1225827,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKkkZBpiaOo4dGUuOXnRusBwcYCcwPTU8Pn41zbKh9py4Nwcf1rtc8A6yH5AtVVbkv8iaoS6hFgKevg/132","nickname":"谷雨","note":"","ucode":"E8566AD0E2A521","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":234346,"discussion_content":"我刚也在思考这个问题。多种设计模式都可以用的时候，我们要用哪一种？我的答案是：先满足基本的设计原则“对拓展开放、对修改关闭”，然后分析具体的场景中的拓展，会怎么拓展，哪种模式用这种拓展带来的改动量最小，就用哪一种。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1586963097,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1064546,"avatar":"https://static001.geekbang.org/account/avatar/00/10/3e/62/752ee55e.jpg","nickname":"多格","note":"","ucode":"2E78C45F15B2F1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558718,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648437477,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1311125,"avatar":"https://static001.geekbang.org/account/avatar/00/14/01/95/fd09e8a8.jpg","nickname":"布拉姆","note":"","ucode":"479FF27D73BCAD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":399242,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632925695,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1250922,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIzGGthScz54sECZJKX3lgyjCATkgrvSt5N3eOsYB34jibCr3SkAX88QaZ5IVmME9Ec7VdkQGwRSPw/132","nickname":"哈哈哈","note":"","ucode":"8AC20A1C9C7DF8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306917,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600418324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1092169,"avatar":"https://static001.geekbang.org/account/avatar/00/10/aa/49/51790edb.jpg","nickname":"落尘kira","note":"","ucode":"D203B519E43F85","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263947,"discussion_content":"赞成，所以现在遇到比较麻烦的场景是 水平和垂直都要拓展，实践中就是 策略+工厂+模板+观察者 结合混用，必要时 装饰器、适配器、代理 也要用上，其他模式的话功能使用上会更单一，比如门面、职责链、建造、单例，状态机，剩下的几乎用不到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589270116,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204852,"user_name":"迷羊","can_delete":false,"product_type":"c1","uid":1286251,"ip_address":"","ucode":"85AF8CED3436C8","user_header":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","comment_is_top":false,"comment_ctime":1586482630,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"91780795846","product_id":100039001,"comment_content":"1.争哥在前面讲面向对象的设计原则时就已经解答了这个问题，不要太死板的遵守各种设置原则，定义，只要写出来的代码是可扩展、可读性、可复用的代码就是好代码。<br>2.代码执行结果<br>I am ChildClass&#39;s f().<br>I am ChildClass&#39;s f().<br>虽然执行重载方法时是根据参数的编译时类型，但是调用哪个对象的方法是根据对象的运行时类型来决定的，所以最终调用的还是实际类型的f()方法。","like_count":22},{"had_liked":false,"id":206024,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1586775171,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"18766644355","product_id":100039001,"comment_content":"实际上操作与对象并没有分开吧，访问者accpect方法其实就是操作了，只不过将操作部分抽象出来了，组合到对象里而已","like_count":4,"discussions":[{"author":{"id":1683130,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","nickname":"乾坤瞬间","note":"","ucode":"15BDCF29CBF8EB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":233951,"discussion_content":"通过接口可以进行分开解耦，定义操作的接口，并组合进对象中，本身就是一种解耦行为，为了让操作能够独立变化，对象也能独立变化，这应该是分开的正真含义","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586952904,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2357566,"avatar":"https://static001.geekbang.org/account/avatar/00/23/f9/3e/0d5f27c4.jpg","nickname":"肥猫不开心","note":"","ucode":"FA9204B84913C0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1683130,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","nickname":"乾坤瞬间","note":"","ucode":"15BDCF29CBF8EB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569296,"discussion_content":"感觉这样和桥接感觉没啥区别了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651397147,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":233951,"ip_address":""},"score":569296,"extra":""}]}]},{"had_liked":false,"id":206301,"user_name":"88591","can_delete":false,"product_type":"c1","uid":1254656,"ip_address":"","ucode":"04CE3E46455185","user_header":"https://static001.geekbang.org/account/avatar/00/13/25/00/3afbab43.jpg","comment_is_top":false,"comment_ctime":1586837150,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14471739038","product_id":100039001,"comment_content":"访问者模式将操作与对象分离，是否违背面向对象设计原则 ？我理解是没有违背，面向对象里面的封装应该是针对 属性与操作都是比较明确的情况下。访问者模式模式中的操作实际是不确定，不稳定的。所以将这部分与对象分离出来了。也就是分离了对象中稳定的（抽象出共性）与非稳定性的部分。因为我们不确定这个对象后续还要添加什么操作，那么我们就定义一个操作，可以操作对象的数据（面向对象中的抽象）。","like_count":3},{"had_liked":false,"id":205261,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1586578737,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"14471480625","product_id":100039001,"comment_content":"设计模式_69: 访问者模式(下)<br># 作业：<br>1. 抛开业务，单向依赖变成双向依赖，确实增加了依赖上的耦合程度。但从业务上讲，它这么做解耦了行为和对象的依赖，符合了开闭原则等另外一些原则，算是一种取舍吧。<br>2. 结果：输出`&quot;I am ChildClass&#39;s f().&quot;`,原因: 多态 ==&gt; 单分派 ==&gt; 运行哪个对象的方法取决于对象的运行时类型。<br># 感想<br>从上节内容看来，感觉访问者模式就是一种因不支持 `Double Dispatch` 特性而诞生的模式，那么Java为什么不支持`Single Dispatch`呢?看到一些答案说是性能，感觉不是很有说服力。","like_count":3},{"had_liked":false,"id":205246,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1018370,"ip_address":"","ucode":"7A488CC6FE15E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","comment_is_top":false,"comment_ctime":1586575863,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14471477751","product_id":100039001,"comment_content":"打卡 今日学习访问者模式下，收获如下：<br>访问者模式实现比较难于理解，主要要理解静态分派和动态分派。通过本专栏的内容学习到了双分派和单分派。自己使用的主要语言Java是单分派。单分派就是指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的编译时类型来决定。<br>理解分派之前需要理解变量是有静态类型和实际类型的，如 A a = new B(), 变量a的静态类型（声明类型）是A，实际类型是B。如果是 A a = new A()，那么变量a的静态类型和实际类型都是A。方法调用过程中判断是用父类对象还是子类对象其实就是多态，运行时根据变量的实际类型来决定是使用子类对象中的方法还是父类对象中的方法。其中涉及到invokevirtaul字节码多态查找流程，简单的理解就是先在已确定对象中寻找方法（如子类），如果找不到往父类中找，如果一直找不到就抛出异常。在确定调用对象后（如确定是子类对象）在调用方法时可能存在方法的重载，这时候就涉及到静态分派（静态绑定），根据变量的静态类型（声明类型）来判断方法的调用版本。<br>课后思考：<br>1. 访问者模式将操作与对象分离，是否违背面向对象设计原则？你怎么看待这个问题呢？对于这个问题，我觉得不能死套设计原则，对于业务场景，要有所取舍。就像专栏中的这个例子，如果所有的功能都写在了相关类中，随着需求不断的迭代，类会变膨胀，可维护性、可读性、可测试性都会变差，后期维护成本会变高。如果一开始就能确定需求不会变化，就只有这么两类操作，那么可以不用访问者这么模式，直接写在相关类中。<br>2. DemoMain 的输出结果会是什么呢? ChildClass 类中的f()方法会被调用两次。首先根据方法重载是静态绑定，会调用形参是ParentClass的overloadFunction方法，在该方法中“p.f();” 变量“p”的静态类型是<br>ParentClass，而实际类型却是ChildClass。根据多态的动态绑定，在ChildClass类中复写了父类中的f()方法，因此，这里会调用ChildClass中的f();","like_count":3},{"had_liked":false,"id":213503,"user_name":"xk_","can_delete":false,"product_type":"c1","uid":1514305,"ip_address":"","ucode":"DFE1AC38EA78A7","user_header":"https://static001.geekbang.org/account/avatar/00/17/1b/41/dbb7d785.jpg","comment_is_top":false,"comment_ctime":1588435039,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10178369631","product_id":100039001,"comment_content":"回答一下课后题第一题，<br>完全不违背面向对象的设计原则，反而更加细粒度的将对象和操作解耦出来了。<br><br>“访问者模式在实际的软件开发中很少被用到，在没有特别必要的情况下，建议你不要使用访问者模式。”<br>简单的说，对于我们目前的开发，访问者模式属于过度设计了。","like_count":2},{"had_liked":false,"id":204897,"user_name":"中年男子","can_delete":false,"product_type":"c1","uid":1039204,"ip_address":"","ucode":"027C86B3370150","user_header":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","comment_is_top":false,"comment_ctime":1586488144,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10176422736","product_id":100039001,"comment_content":"两次结果 都是 I am ChildClass&#39;s f().<br>demo.polymorphismFunction(p) &#47;&#47; 执行哪个对象的方法，由对象的实际类型决定, p的实际类型是 ChildClass， <br>demo.overloadFunction(p) ， &#47;&#47; 执行对象的哪个方法，由声明类型决定，p的声明类型是ParentClass，因此 匹配重载版本overloadFunction(ParentClass p)， \t\t\t\t\t 但此函数内部调用的p.f(),符合执行哪个对象的方法，由实际类型决定，也就是多态，因此调用的是ClidClass.f()<br>","like_count":2},{"had_liked":false,"id":277825,"user_name":"zh","can_delete":false,"product_type":"c1","uid":1982711,"ip_address":"","ucode":"98772B1B6C6E06","user_header":"https://static001.geekbang.org/account/avatar/00/1e/40/f7/e62bbc62.jpg","comment_is_top":false,"comment_ctime":1612607552,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5907574848","product_id":100039001,"comment_content":"我觉得访问者模式基本没有违反SOLID设计原则，但是它确实有点绕，新人初看这个代码（加上业务代码）不好理解。不过我发现自己好像写过类似的代码，只是当时不知道这个模式，当时还为这个巧妙的转换得意了半天2333...","like_count":1},{"had_liked":false,"id":264213,"user_name":"Laughing","can_delete":false,"product_type":"c1","uid":1002134,"ip_address":"","ucode":"F68F1E000CA800","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/96/99466a06.jpg","comment_is_top":false,"comment_ctime":1606381046,"is_pvip":false,"replies":[{"id":"96079","content":"嗯嗯 ������","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606700653,"ip_address":"","comment_id":264213,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5901348342","product_id":100039001,"comment_content":"1. 个人认为并不违反面向对象的设计原则，基于单分派语言的特性，访问者模式本质上是解决了没有指定对象实际类型时函数重载的问题，这是语言特性导致的，开闭原则指的是”对修改关闭，对扩展开放“，理论上该模式并没有实质上的修改操作，更多的是通过另一种形式完成了功能扩展。<br>2. I am ChildClass&#39;s f() 输出两次，因为运行时对象的实际类型是child，所以会执行child的f函数","like_count":1,"discussions":[{"author":{"id":2559640,"avatar":"","nickname":"学员203","note":"","ucode":"63E4B7E3A7E140","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370334,"discussion_content":"懂的人说好，没接触过的不理解，比如前端","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619364927,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204840,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1586481829,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"5881449125","product_id":100039001,"comment_content":"1. 对象（pdf，word，txt）本身应该没有压缩、提取内容等能力，所以这些能力不能算在这个对象身上<br>2. 我理解输出都是：I am ChildClass&#39;s f().<br>   虽然第二个调的是public void overloadFunction(ParentClass p) ，但p.f()，实际上是由p的实际对象决定的。","like_count":1},{"had_liked":false,"id":204825,"user_name":"漫游者","can_delete":false,"product_type":"c1","uid":1058856,"ip_address":"","ucode":"7402D9068413D5","user_header":"https://static001.geekbang.org/account/avatar/00/10/28/28/5ffdd123.jpg","comment_is_top":false,"comment_ctime":1586479923,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5881447219","product_id":100039001,"comment_content":"我觉得应该不违背面相对象设计原则。原因是对象包含的属性和方法应该以对象履行的职责为界限。访问者模式里的操作应该算是一个项新的职能，而不是对象里的一个方法。","like_count":1},{"had_liked":false,"id":348014,"user_name":"寒光","can_delete":false,"product_type":"c1","uid":1206187,"ip_address":"","ucode":"061BE413595F21","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/ab/fcf0cec4.jpg","comment_is_top":false,"comment_ctime":1654665443,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654665443","product_id":100039001,"comment_content":"老师举的例子不太好，访问者模式更多是用来在一组对象中收集信息，然后汇总。<br><br>由于不同对象提供的信息不一样，所以才会有多分派，因而访问者会提供不同的访问方法，这些方法应该有更可读的名字，而不应该是统一的visit重载方法。","like_count":1},{"had_liked":false,"id":345662,"user_name":"菜头","can_delete":false,"product_type":"c1","uid":1456964,"ip_address":"","ucode":"C5E95519F9EA21","user_header":"https://static001.geekbang.org/account/avatar/00/16/3b/44/dd534c9b.jpg","comment_is_top":false,"comment_ctime":1652495624,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652495624","product_id":100039001,"comment_content":"Objective-C 根本不支持函数重载","like_count":0},{"had_liked":false,"id":345660,"user_name":"菜头","can_delete":false,"product_type":"c1","uid":1456964,"ip_address":"","ucode":"C5E95519F9EA21","user_header":"https://static001.geekbang.org/account/avatar/00/16/3b/44/dd534c9b.jpg","comment_is_top":false,"comment_ctime":1652495426,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652495426","product_id":100039001,"comment_content":"Swift 也是单分派语音","like_count":0},{"had_liked":false,"id":342274,"user_name":"李全忠","can_delete":false,"product_type":"c1","uid":1435838,"ip_address":"","ucode":"D971C89265BAF7","user_header":"https://static001.geekbang.org/account/avatar/00/15/e8/be/55fbec8b.jpg","comment_is_top":false,"comment_ctime":1650166197,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650166197","product_id":100039001,"comment_content":"有支持Double Dispatch的语言吗？","like_count":1},{"had_liked":false,"id":334572,"user_name":"山鬼谣","can_delete":false,"product_type":"c1","uid":1543162,"ip_address":"","ucode":"E25F498B85A01B","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/fa/103e6900.jpg","comment_is_top":false,"comment_ctime":1645003374,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645003374","product_id":100039001,"comment_content":"用个比喻：写代码就像装修房子，怎么漂亮，舒适，怎么来；回到代码：只要有利于代码可维护、可扩展、可测试。什么招式(设计模式)都能用。所以应该回到设计原则和设计思想上来，去思考模式的使用问题","like_count":0},{"had_liked":false,"id":334569,"user_name":"山鬼谣","can_delete":false,"product_type":"c1","uid":1543162,"ip_address":"","ucode":"E25F498B85A01B","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/fa/103e6900.jpg","comment_is_top":false,"comment_ctime":1645003054,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645003054","product_id":100039001,"comment_content":"工厂模型？我咋感觉是工厂+策略模式。。。其他人没有这样的疑问吗？<br>","like_count":1},{"had_liked":false,"id":324661,"user_name":"Z宇锤锤","can_delete":false,"product_type":"c1","uid":2188142,"ip_address":"","ucode":"7DB36E986A7A51","user_header":"https://static001.geekbang.org/account/avatar/00/21/63/6e/6b971571.jpg","comment_is_top":false,"comment_ctime":1638530387,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1638530387","product_id":100039001,"comment_content":"操作与对象分离，这样子解耦更充分，更能自由定义对象的行为。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480335,"discussion_content":"上层模块的抽象你是指什么呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578380725,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1023762,"avatar":"","nickname":"开心小毛","note":"","ucode":"9D57A2773759F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":123422,"discussion_content":"上层模块的抽象指的是调用者的接口。例如，被调用者的实现类和接口分别定义在两个不同的DLL中，被调用者的实现类和接口也分别定义在各自的DLL中，此时被调用者实现类的DLL引用调用者接口的DLL, 这样是否提倡。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578402683,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1023762,"avatar":"","nickname":"开心小毛","note":"","ucode":"9D57A2773759F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":123400,"discussion_content":"上层模块的抽象指的是调用者的接口。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578402293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322320,"user_name":"小王在努力","can_delete":false,"product_type":"c1","uid":2733574,"ip_address":"","ucode":"A324EF87198905","user_header":"https://static001.geekbang.org/account/avatar/00/29/b6/06/cd1eaa49.jpg","comment_is_top":false,"comment_ctime":1637303319,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637303319","product_id":100039001,"comment_content":"例子中最后这个应该是策略模式+工厂模式，工厂模式管对象的创建，是创建型；策略模式管行为，是行为型。<br>访问者模式没有违背面向对象设计原则，行为被抽象出去但是也被以类似组合的形式（方法参数）组合进去，数据和操作整体还是符合面向对象设计原则的。","like_count":0},{"had_liked":false,"id":317689,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1634890820,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634890820","product_id":100039001,"comment_content":"思考：<br>1.面向对象的思想之一就是封装性，但设计模式主要是解耦，如果一个对象过于庞大，影响到可读性，扩展性，那将对象和操作分离解耦就是合理的。这其中的尺度就要结合具体项目的复杂程度，功能的复杂程度来决定，不同的人编码水平不一样，也可能写出不一样的代码。<br>2.第二个思考题，实际上要熟悉java如何定位一个方法。先说结果：<br> Child class ,Parent class,Child class <br>具体原因如下：<br>首先Java是一个解释性语言（不考虑即时编译的话），所以不同于那些编译时需要连接的语言,Java里类型的加载、连接和初始化需要到运行期才能确定。所以方法调用（即调用哪个方法）在Class文件里存储的只是符号引用，而非调用时实际的内存地址，因此需要一个机制来定位方法。这里就是我们常说的分派：分派分两种<br>静态分派和动态分派。比如ParentClass c = new ChildClass();<br>这里ParentClass是静态类型，ChildClass是实际类型。而java中的重载是根据静态分派来决定执行哪个方法，即根据参数的静态类型而不是传入的实际类型确定。<br>而重写则是根据动态分派，即我们常说的多态，如果父类引用指向子类，子类重写了父类的方法，如果传入的实际类型是子类，则会调用子类方法。<br><br>小结：JAVA是一门静态多分派，动态单分派的语言。这里的多分派是指，静态分派需要多个宗量来确定调用哪个方法，比如重载方法，要先确定在哪个类，然后在确定参数类型。而动态分派，则只需要确定方法在哪个类，而不关心参数是Parent还是Child","like_count":0},{"had_liked":false,"id":314501,"user_name":"李胖","can_delete":false,"product_type":"c1","uid":1173293,"ip_address":"","ucode":"1D0C0F10E240F3","user_header":"https://static001.geekbang.org/account/avatar/00/11/e7/2d/c21fd3e3.jpg","comment_is_top":false,"comment_ctime":1633155269,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633155269","product_id":100039001,"comment_content":"認真覺得爭哥的設計模式 根本是無敵大寶藏","like_count":0},{"had_liked":false,"id":296984,"user_name":"Dunk","can_delete":false,"product_type":"c1","uid":1691447,"ip_address":"","ucode":"A8F5AB98382719","user_header":"https://static001.geekbang.org/account/avatar/00/19/cf/37/6ed137b9.jpg","comment_is_top":false,"comment_ctime":1623249516,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623249516","product_id":100039001,"comment_content":"执行结果： I am ChildClass&#39;s f(). I am ChildClass&#39;s f(). 为什么会是这个结果？ 1. 多态特性决定了第一个结果的产生，实际执行哪个对象的方法由运行时对象类型决定。 2. 不支持双分派机制的语言决定了第二个结果的产生，重载方法的执行由编译时参数对象的类型决定，而多态方法的执行是由运行时对象的类型决定的。","like_count":0},{"had_liked":false,"id":288223,"user_name":"郑大钱","can_delete":false,"product_type":"c1","uid":1503067,"ip_address":"","ucode":"114CF48056880E","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/5b/ff28088f.jpg","comment_is_top":false,"comment_ctime":1618370380,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618370380","product_id":100039001,"comment_content":"是否违背了面向对象的设计原则？<br>我压根儿就没有意识到这个问题，这一问，看起来确实违背了面向对象的设计原则，但是！肯定后面有但是。这但是我又想不到，有点失落，好在评论区有大神，@小晏子 讲得很明白，羡慕愿意思考，同时思维清晰的人。<br>这一讲的Single Dispatch 和 Double Dispatch对我来说有点陌生，从工作接触到的编程语言来看，oc，swift，dart都不支持方法的重载，所以压根儿就谈不上单分和双分。","like_count":0},{"had_liked":false,"id":288174,"user_name":"caison","can_delete":false,"product_type":"c1","uid":1120108,"ip_address":"","ucode":"963D860AC38E02","user_header":"https://static001.geekbang.org/account/avatar/00/11/17/6c/c62ae8ef.jpg","comment_is_top":false,"comment_ctime":1618329577,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618329577","product_id":100039001,"comment_content":"ExtractorFactory的行为，看起来挺像策略模式，如果用策略模式来实现，有什么区别吗","like_count":0},{"had_liked":false,"id":284638,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1616399786,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616399786","product_id":100039001,"comment_content":"2:I am ChildClass&#39;s f().<br>I am ChildClass&#39;s f().<br>因为方法重载调用的哪个方法是参数声明时类型决定的，又因为运行时发现p是childClass对象，最终输出childClass的f()","like_count":0},{"had_liked":false,"id":282324,"user_name":"当你的世界里有风吹过","can_delete":false,"product_type":"c1","uid":2051946,"ip_address":"","ucode":"42712891366309","user_header":"https://static001.geekbang.org/account/avatar/00/1f/4f/6a/0a6b437e.jpg","comment_is_top":false,"comment_ctime":1615197498,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615197498","product_id":100039001,"comment_content":"看如何看待操作和对象，再某种意义上说，操作也是对象","like_count":0},{"had_liked":false,"id":272244,"user_name":"大力水手Jerry","can_delete":false,"product_type":"c1","uid":1227840,"ip_address":"","ucode":"E4A6C71E275DB5","user_header":"https://static001.geekbang.org/account/avatar/00/12/bc/40/2279cfb5.jpg","comment_is_top":false,"comment_ctime":1610004037,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610004037","product_id":100039001,"comment_content":"我们的大脑的思考能力有限，对于一个复杂的系统，在同一时间我们只能在一个层面或针对其一部分进行思考设计，这就需要适当的抽象和解耦。然后我们再针对相关抽象逐步细化。比如要新建一个巨型的复杂软件系统，我们不可能只定义一个单一的数据结构，然后围绕这个单一的数据结构定义其所有行为，而是将其拆分成多个概念层，然后针对每层分解为更小的模块形成单元，再逐个单元实现，最后再将这些单元组装成目标系统。对于最小的单元而言，将操作与对象封装在一起，作为一个原子单元看待，可以简化模块的思考和构建。另一方面，为了降低这些单元之间的耦合，提高系统迭代的灵活性，我们可以采用各种模式（结构或行为）。<br>问题中提到的对象和操作，本身都是对象，只不过一类是数据对象，一类是行为对象，往往因为过于复杂，我们才将它们拆分到不同的对象中，再通过模式组装在一起，避免单个类膨胀，达到解耦灵活迭代的目的。","like_count":0},{"had_liked":false,"id":263171,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1606031611,"is_pvip":true,"replies":[{"id":"96106","content":"嗯嗯 ������","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606700819,"ip_address":"","comment_id":263171,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1606031611","product_id":100039001,"comment_content":"在面向对象的世界里，万物都可以作为对象，操作如果不需要扩展，那么应该聚合在对象之中，但是如果操作需要扩展，那么这个就可以单独拿出来，代码设计中的面向对象不是一定需要和现实世界的理解的对象一致的，程序未来的演进方向在何处，面向对象就该如何抽象；至于问题，被调用对象的这一个多态在Single Dispatch中也是支持的","like_count":0},{"had_liked":false,"id":260083,"user_name":"Geek_17f1e0","can_delete":false,"product_type":"c1","uid":2164290,"ip_address":"","ucode":"00FFA3B0AAE2FE","user_header":"","comment_is_top":false,"comment_ctime":1604921608,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604921608","product_id":100039001,"comment_content":"一个适合的场景是工作流引擎的开发。","like_count":0},{"had_liked":false,"id":259975,"user_name":"王大喵","can_delete":false,"product_type":"c1","uid":1109528,"ip_address":"","ucode":"C14AAE3ED964DE","user_header":"https://static001.geekbang.org/account/avatar/00/10/ee/18/65e89d9c.jpg","comment_is_top":false,"comment_ctime":1604901840,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604901840","product_id":100039001,"comment_content":"访问者模式，利用函数重载将操作和对象分开，从而解决操作不断增加的场景。保证开闭原则。","like_count":0},{"had_liked":false,"id":257383,"user_name":"RedDevil","can_delete":false,"product_type":"c1","uid":1131128,"ip_address":"","ucode":"F8F5DC209BB3B9","user_header":"https://static001.geekbang.org/account/avatar/00/11/42/78/7ba89c75.jpg","comment_is_top":false,"comment_ctime":1603952309,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603952309","product_id":100039001,"comment_content":"今天直到争哥把单分派和双分派讲出来，我才算真正认识了多态","like_count":0},{"had_liked":false,"id":257336,"user_name":"RedDevil","can_delete":false,"product_type":"c1","uid":1131128,"ip_address":"","ucode":"F8F5DC209BB3B9","user_header":"https://static001.geekbang.org/account/avatar/00/11/42/78/7ba89c75.jpg","comment_is_top":false,"comment_ctime":1603940712,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603940712","product_id":100039001,"comment_content":"争哥一定是一个集大成者，总是可以跳出当前问题，从高度上来看问题","like_count":0},{"had_liked":false,"id":252050,"user_name":"小乙哥","can_delete":false,"product_type":"c1","uid":1063308,"ip_address":"","ucode":"C77E79BEA0C325","user_header":"https://static001.geekbang.org/account/avatar/00/10/39/8c/089525aa.jpg","comment_is_top":false,"comment_ctime":1602078836,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602078836","product_id":100039001,"comment_content":"一般情况，对象中的数据和操纵最好是放到一起比较好，因为操作往往是强关联数据的。从这个角度看的话，visitor模式就是在处理这种一种特殊情况，当操作独立于数据在不可知的变化，比如GoF提到的visitor初衷解决的遍历VST的时候，不同node的操作是有很大差异的。所以，本质上看还是处理的解耦、可扩展的问题","like_count":0},{"had_liked":false,"id":245042,"user_name":"大悟","can_delete":false,"product_type":"c1","uid":1123493,"ip_address":"","ucode":"5ADEE4A4AA6345","user_header":"https://static001.geekbang.org/account/avatar/00/11/24/a5/9d20bc4b.jpg","comment_is_top":false,"comment_ctime":1598793915,"is_pvip":false,"replies":[{"id":"90131","content":"所有的行为模式都是将行为分离，这点不是访问者模式独有的。如果支持double dispatch，完全没必要有访问者模式。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1598833605,"ip_address":"","comment_id":245042,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1598793915","product_id":100039001,"comment_content":"感觉访问者模式的核心不在于双重分派，而是在于将数据对象和操作分离的思想。双重分派只是由于 Java 只支持单分派而采取的手段，不是目的。上文中说理解双重分派是理解访问者模式的核心，实在不太认同，感觉有点舍本逐末了。","like_count":0,"discussions":[{"author":{"id":2559640,"avatar":"","nickname":"学员203","note":"","ucode":"63E4B7E3A7E140","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370335,"discussion_content":"感觉是不是理解偏了，文章重点说的是依赖反转原则，和依赖注入不同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619365073,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229788,"user_name":"蹦哒","can_delete":false,"product_type":"c1","uid":1458931,"ip_address":"","ucode":"56591A657DE7C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epcs6PibsP9vEXv4EibUw3bhQPUK04zRTOvfrvF08TwM67xPb1LBh2uRENHQwo2VqYfC5GhJmM7icxHA/132","comment_is_top":false,"comment_ctime":1593145271,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593145271","product_id":100039001,"comment_content":"学习老师的课，觉得设计模式考察时不应该问某种设计模式是怎么实现的，而是应该给出具体的需求去做设计，然后再通过需求的扩展对设计做重构<br>之前都一直注重各种设计模式如何实现，其实这不是重点，重要的是根据设计原则做解耦的这个主思路，各种设计模式只是一个个的case而已<br>这就有点逐步开窍的感觉了。<br>最好的设计模式教程~","like_count":0},{"had_liked":false,"id":221113,"user_name":"Wings","can_delete":false,"product_type":"c1","uid":1215464,"ip_address":"","ucode":"047167807048EC","user_header":"https://static001.geekbang.org/account/avatar/00/12/8b/e8/7f09a744.jpg","comment_is_top":false,"comment_ctime":1590408461,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590408461","product_id":100039001,"comment_content":"主流语言不支持Double Dispatch，那什么语言支持？","like_count":0},{"had_liked":false,"id":218367,"user_name":"Edward Lee","can_delete":false,"product_type":"c1","uid":1228518,"ip_address":"","ucode":"156223F1D7E94A","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/e6/7808520d.jpg","comment_is_top":false,"comment_ctime":1589789955,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589789955","product_id":100039001,"comment_content":"观察者模式（Visitor）为了解决 Single Dispatch 语言方法重载时的类型匹配问题，但该模式完全可以使用“策略模式”配合“静态工厂模式”代替，且应该优先使用代替方案。如果不想要静态工厂类因为后继的操作类增加而增加，则可以将其放到抽象枚举类中，如 ResourceFileType.PDF.getExtractor()，也能减少因为增加文件类型而缺少为了设置相应的操作类的误操作，譬如增加 ResourceFileType.Excel 类型，则相应的需要实现 ResourceFileType.Excel.getExtractor() &#47; ResourceFileType.Excel.getCompressor() 等方法。<br><br>课后问题<br>1. 个人认为并没违背 OOP 设计原则，反倒是符合“依赖反转”和“单一职责”的设计原则<br>1.1. 依赖反转：将 ResourceFile 中的文件操作倒置到 Visitor 中处理<br>1.2. 单一职责：将操作类 (Visitor) 与资源类 (ResourceFile) 分离，各尽其责<br><br>2. 输出结果（多态）<br>&quot;I am ChildClass&#39;s f().&quot;<br>&quot;I am ChildClass&#39;s f().&quot;","like_count":0},{"had_liked":false,"id":213859,"user_name":"小小代码","can_delete":false,"product_type":"c1","uid":1290642,"ip_address":"","ucode":"F3D4E2C23FC9BD","user_header":"https://static001.geekbang.org/account/avatar/00/13/b1/92/f3dabcb1.jpg","comment_is_top":false,"comment_ctime":1588578584,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588578584","product_id":100039001,"comment_content":"问题1：<br>此处面向对象的设计原则应该是指封装，封装的是对象的属性和方法，它们是关系紧密的，而访问者模式拆分的对象和操作，是没紧密联系的，可以独立开来，所以我认为不违背。","like_count":0},{"had_liked":false,"id":208940,"user_name":"全炸攻城狮","can_delete":false,"product_type":"c1","uid":1315968,"ip_address":"","ucode":"DB437F9190575C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqZIqY4cs6YKNx0OqeMrbjLIicqiafLNtLYJTN2zTtVPlwXZ7qlJ7xrGQictk1xCq5pEsIyqnkiaCib4zQ/132","comment_is_top":false,"comment_ctime":1587468216,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587468216","product_id":100039001,"comment_content":"在编译器里，只有参数是parent的方法是亮的。其实可以理解成，调用方法只看方法的形参，只匹配声明类型和它一样的；然而具体到形参自己的方法调用时，就要看它到底是谁，也就是实际定义类型","like_count":0},{"had_liked":false,"id":206895,"user_name":"乾坤瞬间","can_delete":false,"product_type":"c1","uid":1683130,"ip_address":"","ucode":"15BDCF29CBF8EB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","comment_is_top":false,"comment_ctime":1586954059,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586954059","product_id":100039001,"comment_content":"参数的运行时和对象的运行时没法正确理解😇","like_count":0},{"had_liked":false,"id":205142,"user_name":"Hubbert伟涛","can_delete":false,"product_type":"c1","uid":1303556,"ip_address":"","ucode":"000C6A0BD4A102","user_header":"https://static001.geekbang.org/account/avatar/00/13/e4/04/05677b68.jpg","comment_is_top":false,"comment_ctime":1586537537,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586537537","product_id":100039001,"comment_content":"为啥用C#写完课后题两次输出的都是ParentClass","like_count":0},{"had_liked":false,"id":205021,"user_name":"liu_liu","can_delete":false,"product_type":"c1","uid":1019138,"ip_address":"","ucode":"24283806A07759","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/02/6a16058a.jpg","comment_is_top":false,"comment_ctime":1586509270,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586509270","product_id":100039001,"comment_content":"在该场景中，对对象的操作属于外部对其的处理行为，不应该放在对象内部，否则对象会爆炸。导致职责过多不清晰，很可能成为上帝类。","like_count":0},{"had_liked":false,"id":204933,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1586494089,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586494089","product_id":100039001,"comment_content":"1.其实没有什么违背,我们这样做,其实操作和对象本身还是挂着勾的,只是将两者操作简单的剥离了出去,就好比Service层的service类和Domain类一样,而且提高了代码的可维护,可扩展性<br>2.皆为C,而非P,改为上面的方法后,虽然找到了overloadFunction(P p),但是又变为了执行哪个对象的方法的问题了,所以还是C","like_count":0},{"had_liked":false,"id":204928,"user_name":"Rayjun","can_delete":false,"product_type":"c1","uid":1002514,"ip_address":"","ucode":"61A3D1A3D03569","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4c/12/f0c145d4.jpg","comment_is_top":false,"comment_ctime":1586493362,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1586493362","product_id":100039001,"comment_content":"两个都是输出 ChildClass，重载传参时，会转成对象的真实类型","like_count":0},{"had_liked":false,"id":204923,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1586491184,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586491184","product_id":100039001,"comment_content":"课堂讨论: <br><br>2. 会调用child#f() <br>因为单分派语言执行对象的哪个方法由运行时确定.","like_count":0},{"had_liked":false,"id":204882,"user_name":"cricket1981","can_delete":false,"product_type":"c1","uid":1001715,"ip_address":"","ucode":"758262F5958DA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/f3/f1034ffd.jpg","comment_is_top":false,"comment_ctime":1586486500,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586486500","product_id":100039001,"comment_content":"&quot;执行哪个对象的方法，由对象的实际类型决定; 执行对象的哪个方法，由参数对象的声明类型决定&quot; 这两句话得仔细琢磨","like_count":0},{"had_liked":false,"id":204851,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1586482550,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1586482550","product_id":100039001,"comment_content":"1.确实是违反了面向对象，迪米特原则；<br>2.两个都输出childclasa。","like_count":0,"discussions":[{"author":{"id":1134288,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","nickname":"Ken张云忠","note":"","ucode":"D0BAC9FC17DE2B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84467,"discussion_content":"你的重点该是要弄清楚规范这个词的理解,至于哪种规范不需要具体懂得","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576497965,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}