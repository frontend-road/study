{"id":740949,"title":"4.4 最短路径","content":"\n<p>也许最直观的图处理问题就是你常常需要使用某种地图软件或者导航系统来获取从一个地方到达另一个地方的路径。我们立即可以得到与之对应的图模型：顶点对应交叉路口，边对应公路，边的权重对应经过该路段的成本，可以是时间或者距离。如果有单行线，那就意味着还需要考虑加权有向图。在这个模型中，问题很容易就可以被归纳为：</p>\n<blockquote>\n<p>找到从一个顶点到达另一个顶点的成本最小的路径。</p>\n</blockquote>\n<p>除了这类问题的直接应用，最短路径模型还适用于一系列其他问题（请见表 4.4.1），其中有一些看起来似乎和图的处理毫无关系。举个例子，我们会在本节的最后考虑金融学领域的<strong>套汇</strong>问题。</p>\n<p><strong>表 4.4.1　最短路径的典型应用</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>应用</p></th>\n<th><p>顶点</p></th>\n<th><p>边</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>地图</p></td>\n<td><p>交叉路口</p></td>\n<td><p>公路</p></td>\n</tr>\n<tr>\n<td><p>网络</p></td>\n<td><p>路由器</p></td>\n<td><p>网络连接</p></td>\n</tr>\n<tr>\n<td><p>任务调度</p></td>\n<td><p>任务</p></td>\n<td><p>优先级限制</p></td>\n</tr>\n<tr>\n<td><p>套汇</p></td>\n<td><p>货币</p></td>\n<td><p>汇率</p></td>\n</tr>\n</tbody>\n</table>\n<p>我们采用了一个一般性的模型，即<strong>加权有向图</strong>（它是 4.2 节和 4.3 节的模型的结合）。在 4.2 节中我们希望知道从一个顶点<strong>是否</strong>可以到达另一个顶点。在本节中，我们会把权重考虑进来，就像在 4.3 节中研究的加权无向图那样。在加权有向图中，每条有向路径都有一个与之关联的<strong>路径权重</strong>，它是路径中的所有边的权重之和。这种重要的度量方式使得我们能够将这个问题归纳为“找到从一个顶点到达另一个顶点的权重最小的有向路径”，也就是本节的主题。图 4.4.1 就是一个示例。</p><!-- [[[read_end]]] -->\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01579.gif\" alt=\"\" width=\"60%\" style=\"width: 60%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.4.1　一幅加权有向图和其中的一条最短路径</strong></p>\n<blockquote>\n<p><strong>定义</strong>。在一幅加权有向图中，从顶点 <code>s</code> 到顶点 <code>t</code> 的<strong>最短路径</strong>是所有从 <code>s</code> 到 <code>t</code> 的路径中的权重最小者。</p>\n</blockquote>\n<p>本节中，我们将会学习解决下面这个问题的经典算法。</p>\n<p><strong>单点最短路径</strong>。给定一幅加权有向图和一个起点 <code>s</code>，回答“<strong>从 <code>s</code> 到给定的目的顶点 <code>v</code> 是否存在一条有向路径？</strong>如果有，找出<strong>最短</strong>（总权重最小）的那条路径。”等类似问题。</p>\n<p>我们计划在本节中讨论下列问题：</p>\n<ul>\n<li>加权有向图的 API 和实现以及单点最短路径的 API；</li>\n<li>解决边的权重非负的最短路径问题的经典 Dijkstra 算法；</li>\n<li>在无环加权有向图中解决该问题的一种快速算法，边的权重甚至可以是负值；</li>\n<li>适用于一般情况的经典 Bellman-Ford 算法，其中图可以含有环，边的权重也可以是负值。我们还需要算法来找出负权重的环，以及不含有这种环的加权有向图中的最短路径。</li>\n</ul>\n<p>在学习了这些算法之后，我们还会考虑它们的应用。</p>\n<h3 id=\"nav_point_205\">4.4.1　最短路径的性质</h3>\n<p>最短路径问题的基本定义是很简单的，但这种简洁也隐藏了一些在学习相关的算法和数据结构之前需要解决的问题。</p>\n<ul>\n<li><strong>路径是有向的</strong>。最短路径需要考虑到各条边的方向。</li>\n<li><strong>权重不一定等价于距离</strong>。几何上的直觉可以帮助你理解算法，因此示例中的顶点都在平面上且权重为顶点之间的欧几里得距离，例如图 4.4.1 所示的那幅有向图。但权重也可以表示时间、花费或是某种完全无关的东西，也不一定会和距离的远近成正比。我们使用了双关性的术语来强调这一点，指的是<strong>权重</strong>或是<strong>成本最短</strong>的路径。</li>\n<li><strong>并不是所有顶点都是可达的</strong>。如果 <code>t</code> 并不是从 <code>s</code> 可达的，那么就不存在任何路径，也就不存在 <code>s</code> 到 <code>t</code> 的最短路径。为了简化问题，我们的样图都是强连通的（每个顶点从另外任意一个顶点都是可达的）。</li>\n<li><strong>负权重会使问题更复杂</strong>。我们暂时假设边的权重都是正的（或零）。负权重所带来的意外效应是本节最后部分的重点。</li>\n<li><strong>最短路径一般都是简单的</strong>。我们的算法会忽略构成环的零权重边，因此找到的最短路径都不会含有环。</li>\n<li><strong>最短路径不一定是唯一的</strong>。从一个顶点到达另一个顶点的权重最小的路径可能有多条，我们只要找到其中一条即可。</li>\n<li><strong>可能存在平行边和自环</strong>：平行边中的权重最小者才会被选中，最短路径也不可能包含自环（除非自环的权重为零，但我们会忽略它）。在正文中，为了避免歧义我们隐式地假设平行边不存在，用 <code>v</code> → <code>w</code> 来表示从 <code>v</code> 到 <code>w</code> 的边，本节的代码处理它们并没有困难。</li>\n</ul>\n<p><strong>最短路径树</strong></p>\n<p>我们的重点是<strong>单点最短路径问题</strong>，其中给出了起点 <code>s</code>，计算的结果是一棵<strong>最短路径树</strong> (SPT)，它包含了顶点 <code>s</code> 到所有可达的顶点的最短路径。如图 4.4.2 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01580.jpeg\" alt=\"\" width=\"50%\" style=\"width: 50%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.4.2　最短路径树</strong></p>\n<blockquote>\n<p><strong>定义</strong>。给定一幅加权有向图和一个顶点 <code>s</code>，以 <code>s</code> 为起点的一棵<strong>最短路径树</strong>是图的一幅子图，它包含 <code>s</code> 和从 <code>s</code> 可达的所有顶点。这棵有向树的根结点为 s，树的每条路径都是有向图中的一条最短路径。</p>\n</blockquote>\n<p>这样一棵树是一定存在的：一般来说，从 <code>s</code> 到一个顶点有可能存在两条长度相等的路径。如果出现这种情况，可以删除其中一条路径的最后一条边。如此这般，直到从起点到每个顶点都只有一条路径相连（即一棵树，请见图 4.4.3）。通过构造这棵最短路径树，可以为用例提供从 <code>s</code> 到图中任何顶点的最短路径，表示方法为一组指向父结点的链接，和 4.1 节中表示路径的方法完全一样。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01581.gif\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.4.3　一棵含有 250 个顶点的最短路径树</strong></p>\n<h3 id=\"nav_point_206\">4.4.2　加权有向图的数据结构</h3>\n<p>有向边的数据结构比无向边更加简单，因为有向边只有一个方向。与 <code>Edge</code> 类中的 <code>either()</code> 和 <code>other()</code> 方法不同，这里定义了 <code>from()</code> 和 <code>to()</code> 方法，请见表 4.4.2。</p>\n<p><strong>表 4.4.2　加权有向边的 API</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><td colspan=\"2\"><code>public class&nbsp;&nbsp;<b>DirectedEdge</b></code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DirectedEdge(int v, int w, double weight)</code></td><td></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;&nbsp;weight()</code></td><td>边的权重</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;from()</code></td><td>指出这条边的顶点</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;to()</code></td><td>这条边指向的顶点</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;&nbsp;toString()</code></td><td>对象的字符串表示</td></tr>\n</table>\n\n<p>从 4.1 节到 4.3 节，从 <code>Graph</code> 类过渡到了 <code>EdgeWeightedGraph</code> 类。与以前一样，我们在这里添加了 <code>edges()</code> 方法并使用 <code>DirectedEdge</code> 类代替了整型变量，请见表 4.4.3。</p>\n<p><strong>表 4.4.3　加权有向图的 API</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><td colspan=\"2\"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public class&nbsp;&nbsp;<b>EdgeWeightedDigraph</b></code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeWeightedDigraph(int V)</code></td><td>含有 <code>V</code> 个顶点的空有向图</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeWeightedDigraph(In in)</code></td><td>从输入流中读取图的构造函数</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;V()</code></td><td>顶点总数</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;E()</code></td><td>边的总数</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;addEdge(DirectedEdge e)</code></td><td>将 <code>e</code> 添加到该有向图中</td></tr>\n<tr><td><code>Iterable&lt;DirectedEdge&gt;&nbsp;&nbsp;adj(int v)</code></td><td>从 <code>v</code> 指出的边</td></tr>\n<tr><td><code>Iterable&lt;DirectedEdge&gt;&nbsp;&nbsp;edges()</code></td><td>该有向图中的所有边</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;&nbsp;toString()</code></td><td>对象的字符串表示</td></tr>\n</table>\n\n<p>这两份 API 的实现请见后面的框注“加权有向边的数据类型”和“加权有向图的数据类型”。它们很自然地扩展了 4.2 节和 4.3 节中相应的类的实现。<code>Digraph</code> 类中的邻接表使用的是整数，在 <code>EdgeWeightedDigraph</code> 的邻接表中使用的是 <code>DirectedEdge</code> 对象。与从 4.1 节到 4.2 节中 <code>Graph</code> 类到 <code>Digraph</code> 类的转换一样，从 4.3 节的 <code>EdgeWeightedGraph</code> 类到本节中的 <code>EdgeWeightedDigraph</code> 类的转换代码也变得简单了，因为在数据结构中每条边只会出现一次。</p>\n<blockquote>\n<p><strong>加权有向边的数据类型</strong></p>\n<pre class=\"code-rows\"><code>public class DirectedEdge\n{\n   private final int v;                       // 边的起点\n   private final int w;                       // 边的终点\n   private final double weight;               // 边的权重\n\n   public DirectedEdge(int v, int w, double weight)\n   {\n      this.v = v;\n      this.w = w;\n      this.weight = weight;\n   }\n\n   public double weight()\n   {  return weight;  }\n\n   public int from()\n\n   {  return v;  }\n\n   public int to()\n   {  return w;  }\n\n   public String toString()\n   {  return String.format(\"%d-&gt;%d %.2f\", v, w, weight);  }\n}</code></pre>\n<p><code>DirectedEdge</code> 类的实现比 4.3 节中无向边的数据类型 <code>Edge</code> 类（请见 4.3.2 节框注“带权重的边的数据类型”）更简单，因为边的两个端点是有区别的。用例可以使用惯用代码 <code>int v=e.from(), w=e.to();</code> 来访问 <code>DirectedEdge</code> 的两个端点。</p>\n</blockquote>\n<p>　</p>\n<blockquote>\n<p><strong>加权有向图的数据类型</strong></p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01582.gif\" alt=\"\" width=\"66%\" style=\"width: 66%\" /></p>\n<p><code>EdgeWeightedDigraph</code> 类的实现混合了 <code>EdgeWeightedGraph</code> 类和 <code>Digraph</code> 类。它维护了一个由顶点索引的 <code>Bag</code> 对象的数组，<code>Bag</code> 对象的内容为 <code>DirectedEdge</code> 对象。与 <code>Digraph</code> 类一样，每条边在邻接表中只会出现一次：如果一条边从 <code>v</code> 指向 <code>w</code>，那么它只会出现在 <code>v</code> 的邻接链表中。这个类可以处理自环和平行边。<code>toString()</code> 方法的实现留作练习 4.4.2。</p>\n</blockquote>\n<p>图 4.4.4 所示的是用 <code>EdgeWeightedDigraph</code> 表示左侧的加权有向图时所构造的数据结构，在构造的过程中边被按照顺序一条一条地加入图中。与以前一样，我们使用了 Bag 类来表示邻接表并在图中按照标准方式将它们表示为链表。与 4.2 节中普通的有向图一样，每条边在数据结构中都只出现了一次。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01583.gif\" alt=\"\" width=\"85%\" style=\"width: 85%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.4.4　加权有向图的表示</strong></p>\n<h4>4.4.2.1　最短路径的 API</h4>\n<p>对于最短路径的 API，我们的设计思路与 4.1 节中的 <code>DepthFirstPaths</code> 和 <code>BreadthFirstPaths</code> 的 API 是一样的。算法将会实现表 4.4.4 所示的 API 来为用例提供图中的最短路径和其长度。</p>\n<p><strong>表 4.4.4　最短路径的 API</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><td colspan=\"2\"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public class <b>SP</b></code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SP(EdgeWeightedDigraph G, int s)</code></td><td>构造函数</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double distTo(int v)</code></td><td>从顶点 <code>s</code> 到 <code>v</code> 的距离，如果不存在则路径为无穷大</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean hasPathTo(int v)</code></td><td>是否存在从顶点 <code>s</code> 到 <code>v</code> 的路径</td></tr>\n<tr><td><code>Iterable&lt;DirectedEdge&gt; pathTo(int v)</code></td><td>从顶点 <code>s</code> 到 <code>v</code> 的路径，如果不存在则为 <code>null</code></td></tr>\n</table>\n\n<p>构造函数会创建最短路径树并计算最短路径的长度，其他查询方法则会使用这些数据结构为用例提供路径的长度以及路径的 <code>Iterable</code> 对象。</p>\n<h4>4.4.2.2　测试用例</h4>\n<p>右侧框注是一个简单测试用例。它接受一个输入流和一个起点作为命令行参数，从输入流中读取加权有向图，根据起点来计算有向图的最短路径树并打印从起点到其他所有顶点的最短路径。我们约定，所有的最短路径实现都使用该测试用例进行测试。图 4.4.4 中的 tinyEWD.txt 文件定义了一幅较小的示例有向图中所有的边和权重，会用来显示最短路径算法的详细轨迹。它的文件格式与最小生成树算法中使用的样图相同：首先是顶点总数 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" inline-img=\"true\" /> 和边的总数 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01481.gif\" alt=\"E\" inline-img=\"true\" />，随后是 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01481.gif\" alt=\"E\" inline-img=\"true\" /> 行数据，每一行为两个顶点的索引和一个权重。在本书的网站上，你可以找到一些定义了更大的加权有向图的文件，包括 mediumEWG.txt。它定义了一幅含有 250 个顶点的加权有向图，如图 4.4.3 所示。在这幅图的图像中，每一行数据都表示方向相反的两条边，因此这个文件所含有的边数是在学习最小生成树时所使用的 mediumEWG.txt 的 2 倍。在最短路径树的图像中，每一行都表示一条从顶点指出的有向边。</p>\n<pre class=\"code-rows\"><code>  public static void main(String[] args)\n  {\n     EdgeWeightedDigraph G;\n     G = new EdgeWeightedDigraph(new In(args[0]));\n     int s = Integer.parseInt(args[1]);\n     SP sp = new SP(G, s);\n\n     for (int t = 0; t &lt; G.V(); t++)\n     {\n        StdOut.print(s + \" to \" + t);\n        StdOut.printf(\" (%4.2f): \", sp.distTo(t));\n        if (sp.hasPathTo(t))\n           for (DirectedEdge e : sp.pathTo(t))\n              StdOut.print(e + \"   \");\n        StdOut.println();\n     }\n  }\n\n% java SP tinyEWD.txt 0\n0 to 0 (0.00):\n0 to 1 (1.05): 0-&gt;4 0.38  4-&gt;5 0.35  5-&gt;1 0.32\n0 to 2 (0.26): 0-&gt;2 0.26\n0 to 3 (0.99): 0-&gt;2 0.26  2-&gt;7 0.34  7-&gt;3 0.39\n0 to 4 (0.38): 0-&gt;4 0.38\n0 to 5 (0.73): 0-&gt;4 0.38  4-&gt;5 0.35\n0 to 6 (1.51): 0-&gt;2 0.26  2-&gt;7 0.34  7-&gt;3 0.39  3-&gt;6  0.52\n0 to 7 (0.60): 0-&gt;2 0.26  2-&gt;7 0.34</code></pre>\n<p style=\"text-align: center\">最短路径的测试用例</p>\n<h4>4.4.2.3　最短路径的数据结构</h4>\n<p>表示最短路径所需的数据结构很简单，如图 4.4.5 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01584.gif\" alt=\"\" width=\"75%\" style=\"width: 75%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.4.5　最短路径的数据结构</strong></p>\n<ul>\n<li><strong>最短路径树中的边</strong>。和深度优先搜索、广度优先搜索和 Prim 算法一样，使用一个由顶点索引的 <code>DirectedEdge</code> 对象的父链接数组 <code>edgeTo[]</code>，其中 <code>edgeTo[v]</code> 的值为树中连接 <code>v</code> 和它的父结点的边（也是从 <code>s</code> 到 <code>v</code> 的最短路径上的最后一条边）。</li>\n<li><strong>到达起点的距离</strong>。我们需要一个由顶点索引的数组 <code>distTo[]</code>，其中 <code>distTo[v]</code> 为从 <code>s</code> 到 <code>v</code> 的已知最短路径的长度。</li>\n</ul>\n<p>我们约定，<code>edgeTo[s]</code> 的值为 <code>null</code>，<code>distTo[s]</code> 的值为 <code>0</code>。同时还约定，从起点到不可达的顶点的距离均为 <code>Double.POSITIVE_INFINITY</code>。和以前一样，我们会实现使用这些数据结构的数据类型并支持用例调用方法来查询最短路径和它们的长度。</p>\n<h4>4.4.2.4　边的松弛</h4>\n<p>我们的最短路径 API 的实现都基于一个被称为<strong>松弛</strong>（relaxation）的简单操作。一开始我们只知道图的边和它们的权重，<code>distTo[]</code> 中只有起点所对应的元素的值为 <code>0</code>，其余元素的值均被初始化为 <code>Double.POSITIVE_INFINITY</code>。随着算法的执行，它将起点到其他顶点的最短路径信息存入了 <code>edgeTo[]</code> 和 <code>distTo[]</code> 数组中。在遇到新的边时，通过更新这些信息就可以得到新的最短路径。特别是，我们在其中会用到<strong>边的松弛</strong>技术，定义如下：<strong>放松</strong>边 <code>v</code> → <code>w</code> 意味着检查从 <code>s</code> 到 <code>w</code> 的最短路径是否是先从 <code>s</code> 到 <code>v</code>，然后再由 <code>v</code> 到 <code>w</code>。如果是，则根据这个情况更新数据结构的内容。上边框注中的代码实现了这个操作。由 <code>v</code> 到达 <code>w</code> 的最短路径是 <code>distTo[v]</code> 与 <code>e.weight()</code> 之和——如果这个值不小于 <code>distTo[w]</code>，称这条边<strong>失效</strong>了并将它忽略；如果这个值更小，就更新数据。</p>\n<pre class=\"code-rows\"><code>private void relax(DirectedEdge e)\n{\n   int v = e.from(), w = e.to();\n   if (distTo[w] &gt; distTo[v] + e.weight())\n   {\n       distTo[w] = distTo[v] + e.weight();\n       edgeTo[w] = e;\n   }\n}</code></pre>\n<p style=\"text-align: center\">\n</p><p>图 4.4.6 显示的是边的放松操作之后可能出现的两种情况。一种情况是边失效（左边的例子），不更新任何数据；另一种情况是 <code>v</code> → <code>w</code> 就是到达 <code>w</code> 的最短路径（右边的例子），这将会更新 <code>edgeTo[w]</code> 和 <code>distTo[w]</code>（这可能会使另一些边失效，但也可能产生一些新的有效边）。<strong>松弛</strong>这个术语来自于用一根橡皮筋沿着连接两个顶点的路径紧紧展开的比喻：放松一条边就类似于将橡皮筋转移到一条更短的路径上，从而缓解了橡皮筋的压力。如果 <code>relax()</code> 改变了和边 <code>e</code> 相关的顶点的 <code>distTo[e.to()]</code> 和 <code>edgeTo[e.to()]</code> 的值，就称 <code>e</code> 的<strong>放松是成功的</strong>。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01585.jpeg\" alt=\"\" width=\"90%\" style=\"width: 90%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.4.6　边的松弛的两种情况</strong></p>\n<h4>4.4.2.5　顶点的松弛</h4>\n<p>实际上，实现会放松从一个给定顶点指出的所有边，如下页框注中（被重载的）<code>relax()</code> 的实现所示。注意，从任意 <code>distTo[v]</code> 为有限值的顶点 <code>v</code> 指向任意 <code>distT[]</code> 为无穷的顶点的边都是有效的。如果 <code>v</code> 被放松，那么这些有效边都会被添加到 <code>edgeTo[]</code> 中。某条从起点指出的边将会是第一条被加入 <code>edgeTo[]</code> 中的边。算法会谨慎选择顶点，使得每次顶点松弛操作都能得出到达某个顶点的更短的路径，最后逐渐找出到达每个顶点的最短路径。如图 4.4.7 所示。</p>\n<pre class=\"code-rows\"><code>private void relax(EdgeWeightedDigraph G, int v)\n{\n   for (DirectedEdge e : G.adj(v))\n   {\n      int w = e.to();\n      if (distTo[w] &gt; distTo[v] + e.weight())\n      {\n         distTo[w] = distTo[v] + e.weight();\n         edgeTo[w] = e;\n     }\n   }\n}</code></pre>\n<p style=\"text-align: center\">顶点的松弛</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01586.gif\" alt=\"\" width=\"55%\" style=\"width: 55%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.4.7　顶点的松弛</strong></p>\n<h4>4.4.2.6　为用例准备的查询方法</h4>\n<p>与 4.1 节（以及练习 4.1.13）中实现路径查找的 API 相似，<code>edgeTo[]</code> 和 <code>distTo[]</code> 数组直接支持 <code>pathTo()</code>、<code>hasPathTo()</code> 和 <code>distTo()</code> 查询方法，如下方框注所示。默认所有最短路径的实现都包含这段代码。前面已经提到过，只有在 <code>v</code> 是从 <code>s</code> 可达的情况下，<code>distTo[v]</code> 才是有意义的，还已经约定，对于从 <code>s</code> 不可达的顶点，<code>distTo()</code> 方法都应该返回无穷大。在实现这个约定时，将 <code>distTo[]</code> 中的所有元素都初始化为 <code>Double.POSITIVE_INFINITY</code>，<code>distTo[s]</code> 则为 <code>0</code>。最短路径算法会将从起点可达的顶点 <code>v</code> 的 <code>distTo[v]</code> 设为一个有限值，这样就不必再用 <code>marked[]</code> 数组来在图的搜索中标记可达的顶点，而是通过检测 <code>distTo[v]</code> 是否为 <code>Double.POSITIVE_INFINITY</code> 来实现 <code>hasPathTo(v)</code>。对于 <code>pathTo()</code> 方法，我们约定如果 <code>v</code> 不是从起点可达的则返回 <code>null</code>，如果 <code>v</code> 等于起点则返回一条不含任何边的路径。对于可达的顶点，我们会遍历最短路径树并返回栈上的所有边，这和 <code>DepthFirstPaths</code> 以及 <code>BreadthFirstPaths</code> 的做法完全一样。图 4.4.8 显示了在示例中路径 <code>0</code> → <code>2</code> → <code>7</code> → <code>3</code> → <code>6</code> 是如何被找到的。</p>\n<pre class=\"code-rows\"><code>public double distTo(int v)\n{   return distTo[v];   }\n\npublic boolean hasPathTo(int v)\n{   return distTo[v] &lt; Double.POSITIVE_INFINITY;  }\n\npublic Iterable&lt;DirectedEdge&gt; pathTo(int v)\n{\n   if (!hasPathTo(v)) return null;\n   Stack&lt;DirectedEdge&gt; path = new Stack&lt;DirectedEdge&gt;();\n   for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()])\n      path.push(e);\n   return path;\n}</code></pre>\n<p style=\"text-align: center\">最短路径 API 中的查询方法</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01587.gif\" alt=\"\" width=\"60%\" style=\"width: 60%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.4.8　<code>pathTo()</code> 方法的计算轨迹</strong></p>\n<h3 id=\"nav_point_207\">4.4.3　最短路径算法的理论基础</h3>\n<p>边的放松操作是一项非常容易实现的重要操作，它是实现最短路径算法的基础。同时，它也是理解这个算法的理论基础并使我们能够完整地证明算法的正确性。</p>\n<h4>4.4.3.1　最优性条件</h4>\n<p>以下命题证明了判断路径是否为最短路径的<strong>全局</strong>条件与在放松一条边时所检测的<strong>局部</strong>条件是等价的。</p>\n<blockquote>\n<p><strong>命题 P（最短路径的最优性条件）</strong>。令 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01475.gif\" alt=\"G\" inline-img=\"true\" /> 为一幅加权有向图，顶点 <code>s</code> 是 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01475.gif\" alt=\"G\" inline-img=\"true\" /> 中的起点，<code>distTo[]</code> 是一个由顶点索引的数组，保存的是 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01475.gif\" alt=\"G\" inline-img=\"true\" /> 中路径的长度。对于从 <code>s</code> 可达的所有顶点 <code>v</code>，<code>distTo[v]</code> 的值是从 <code>s</code> 到 <code>v</code> 的<strong>某条</strong>路径的长度，对于从 <code>s</code> 不可达的所有顶点 <code>v</code>，该值为无穷大。当且仅当对于从 <code>v</code> 到 <code>w</code> 的任意一条边 <code>e</code>，这些值都满足 <code>distTo[w]&lt;=distTo[v]+e.weight()</code> 时（换句话说，不存在有效边时），它们是<strong>最短</strong>路径的长度。</p>\n<p><strong>证明</strong>。假设 <code>distTo[w]</code> 是从 <code>s</code> 到 <code>w</code> 的最短路径。如果对于某条从 <code>v</code> 到 <code>w</code> 的边 <code>e</code> 有 <code>distTo[w]&gt;distTo[v]+e.weight()</code>，那么从 <code>s</code> 到 <code>w</code>（经过 <code>v</code>）且经过 <code>e</code> 的路径的长度必然小于 <code>distTo[w]</code>，矛盾。因此最优性条件是必要的。</p>\n<p>要证明最优性条件是充分的，假设 <code>w</code> 是从 <code>s</code> 可达的且 <code>s=v<sub>0</sub></code> → <code>v<sub>1</sub></code> → <code>v<sub>2</sub></code>... → <code>v<i><sub>k</sub></i></code>=<code>w</code> 是从 <code>s</code> 到 <code>w</code> 的最短路径，其权重为 <code>OPT<sub>sw</sub></code>。对于 <code>1</code> 到 <em><code>k</code></em> 之间的 <em><code>i</code></em>，令 <code>e<sub><i>i</i></sub></code> 表示 <code>v<sub><i>i</i>-1</sub></code> 到 <code>v<sub><i>i</i></sub></code> 的边。根据最优性条件，可以得到以下不等式：</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01588.gif\" alt=\"\" width=\"85%\" style=\"width: 85%\" /></p>\n<p>综合这些不等式并去掉 <code>distTo[s]=0.0</code>，得到：</p>\n<p style=\"text-align: center\"><code>distTo[w] &lt;= e<sub>1</sub>.weight() + ... + e<sub><i>k</i></sub>.weight() = OPT<sub>SW</sub></code>.</p>\n<p>现在，<code>distTo[w]</code> 为从 <code>s</code> 到 <code>w</code> 的<strong>某条</strong>边的长度，因此它不可能比<strong>最短</strong>路径更短。所以我们有以下不等式：</p>\n<p style=\"text-align: center\"><code>OPT<sub>SW</sub> &lt;= distTo[w] &lt;= OPT<sub>SW</sub></code></p>\n<p>且等号必然成立。</p>\n</blockquote>\n<h4>4.4.3.2　验证</h4>\n<p>命题 P 的一个重要的实际应用是最短路径的验证。无论一种算法会如何计算 <code>distTo[]</code>，都只需要遍历图中的所有边一遍并检查最优性条件是否满足就能够知道该数组中的值是否是最短路径的长度。最短路径的算法可能会很复杂，因此能够快速验证计算的结果就变得很重要。为此，我们在本书的网站上的实现中包含了一个 <code>check()</code> 方法。该方法还会检查 <code>edgeTo[]</code> 指明的路径并验证它与 <code>distTo[]</code> 是否一致。</p>\n<h4>4.4.3.3　通用算法</h4>\n<p>由最优性条件马上可以得到一个能够涵盖已经学习过的所有最短路径算法的通用算法。现在，我们暂时只研究非负权重的情况。</p>\n<blockquote>\n<p><strong>命题 Q（通用最短路径算法）</strong>。将 <code>distTo[s]</code> 初始化为 0，其他 <code>distTo[]</code> 元素初始化为无穷大，继续如下操作：</p>\n<p style=\"text-align: center\"><strong>放松 <code>G</code> 中的任意边，直到不存在有效边为止。</strong></p>\n<p>对于任意从 <code>s</code> 可达的顶点 <code>w</code>，在进行这些操作之后，<code>distTo[w]</code> 的值即为从 <code>s</code> 到 <code>w</code> 的最短路径的长度（且 <code>edgeTo[w]</code> 的值即为该路径上的最后一条边）。</p>\n<p><strong>证明</strong>。放松边 <code>v</code> → <code>w</code> 必然会将 <code>distTo[w]</code> 的值设为从 <code>s</code> 到 <code>w</code> 的某条路径的长度（且将 <code>edgeTo[w]</code> 设为该路径上的最后一条边）。对于从 <code>s</code> 可达的任意顶点 <code>w</code>，只要 <code>distTo[w]</code> 仍然是无穷大，到达 <code>w</code> 的最短路径上的某条边肯定仍然是有效的，因此算法的操作会不断继续，直到由 <code>s</code> 可达的每个顶点的 <code>distTo[]</code> 值均变为到达该顶点的某条路径的长度。对于已经找到最短路径的任意顶点 <code>v</code>，在算法的计算过程中 <code>distTo[v]</code> 的值都是从 <code>s</code> 到 <code>v</code> 的某条（简单）路径的长度且必然是单调递减的。因此，它递减的次数必然是有限的（每切换一条 <code>s</code> 到 <code>v</code> 简单路径就递减一次）。当不存在有效边的时候，命题 P 就成立了。</p>\n</blockquote>\n<p>将最优性条件和通用算法放在一起学习的关键原因是，<strong>通用算法并没有指定边的放松顺序</strong>。因此，要证明这些算法都能通过计算得到最短路径，只需证明它们都会放松所有的边直到所有边都失效即可。</p>\n<h3 id=\"nav_point_208\">4.4.4　Dijkstra 算法</h3>\n<p>在 4.3 节中，我们讨论了寻找加权无向图中的最小生成树的 Prim 算法：构造最小生成树的每一步都向这棵树中添加一条新的边。<strong>Dijkstra 算法</strong>采用了类似的方法来计算最短路径树。首先将 <code>distTo[s]</code> 初始化为 0，<code>distTo[]</code> 中的其他元素初始化为正无穷。然后将 <code>distTo[]</code> <strong>最小的非树顶点放松并加入树中，如此这般，直到所有的顶点都在树中或者所有的非树顶点的 <code>distTo[]</code> 值均为无穷大</strong>。</p>\n<blockquote>\n<p><strong>命题 R</strong>。Dijkstra算法能够解决边权重非负的加权有向图的单起点最短路径问题。</p>\n<p><strong>证明</strong>。如果 <code>v</code> 是从起点可达的，那么所有 <code>v</code> → <code>w</code> 的边都只会被放松一次。当 <code>v</code> 被放松时，必有 <code>distTo[w]&lt;=distTo[v]+e.weight()</code>。该不等式在算法结束前都会成立，因此 <code>distTo[w]</code> 只会变小（放松操作只会减小 <code>distTo[]</code> 的值）而 <code>distTo[v]</code> 则不会改变（因为边的权重非负且在每一步中算法都会选择 <code>distTo[]</code> 最小的顶点，之后的放松操作不可能使任何 <code>distTo[]</code> 的值小于 <code>distTo[v]</code>）。因此，在所有从 <code>s</code> 可达的顶点均被添加到树中之后，最短路径的最优性条件成立，即命题 P 成立。</p>\n</blockquote>\n<h4>4.4.4.1　数据结构</h4>\n<p>要实现 Dijkstra 算法，除了 <code>distTo[]</code> 和 <code>edgeTo[]</code> 数组之外还需要一条索引优先队列 <code>pq</code>，以保存需要被放松的顶点并确认下一个被放松的顶点。我们知道 <code>IndexMinPQ</code> 可以将索引和键（优先级）关联起来并且可以删除并返回优先级最低的索引。在这里，只要将顶点 <code>v</code> 和 <code>distTo[v]</code> 关联起来就立即可以得到 Dijkstra 算法的实现。另外，稍加推导也可以知道，<code>edgeTo[]</code> 中的元素所对应的可达顶点构成了一棵最短路径树。</p>\n<h4>4.4.4.2　换一个角度看问题</h4>\n<p>根据算法的证明，我们可以从另一个角度来理解它，如图 4.4.9 所示，已知树结点所对应的 <code>distTo[]</code> 值均为最短路径的长度。对于优先队列中的任意顶点 <code>w</code>，<code>distTo[w]</code> 是从 <code>s</code> 到 <code>w</code> 的最短路径的长度，该路径上的中间顶点在树中且路径结束于横切边 <code>edgeTo[w]</code>。优先级<strong>最小</strong>的顶点的 <code>distTo[]</code> 值就是最短路径的权重，它不会小于已经被放松过的任意顶点的最短路径的权重，也不会大于还未被放松过的任意顶点的最短路径的权重。这个顶点就是下一个要被放松的顶点。所有从 <code>s</code> 可达的顶点都会按照最短路径的权重顺序被放松。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01589.jpeg\" alt=\"\" width=\"70%\" style=\"width: 70%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.4.9　Dijkstra 的最短路径算法</strong></p>\n<p>图 4.4.10 是算法处理样图 tinyEWD.txt 时的轨迹。在这个例子中，算法构造最短路径树的过程如下所述。</p>\n<ul>\n<li>将顶点 <code>0</code> 添加到树中，将顶点 <code>2</code> 和 <code>4</code> 加入优先队列。</li>\n<li>从优先队列中删除顶点 <code>2</code>，将 <code>0</code> → <code>2</code> 添加到树中，将顶点 <code>7</code> 加入优先队列。</li>\n<li>从优先队列中删除顶点 <code>4</code>，将 <code>0</code> → <code>4</code> 添加到树中，将顶点 <code>5</code> 加入优先队列，边 <code>4</code> → <code>7</code> 失效。</li>\n<li>从优先队列中删除顶点 <code>7</code>，将 <code>2</code> → <code>7</code> 添加到树中，将顶点 <code>3</code> 加入优先队列，边 <code>7</code> → <code>5</code> 失效。</li>\n<li>从优先队列中删除顶点 <code>5</code>，将 <code>4</code> → <code>5</code> 添加到树中，将顶点 <code>1</code> 加入优先队列，边 <code>5</code> → <code>7</code> 失效。</li>\n<li>从优先队列中删除顶点 <code>3</code>，将 <code>7</code> → <code>3</code> 添加到树中，将顶点 <code>6</code> 加入优先队列。</li>\n<li>从优先队列中删除顶点 <code>1</code>，将 <code>5</code> → <code>1</code> 添加到树中，边 <code>1</code> → <code>3</code> 失效。</li>\n<li>从优先队列中删除顶点 <code>6</code>，将 <code>3</code> → <code>6</code> 添加到树中。</li>\n</ul>\n<p>算法按照顶点到起点的最短路径的长度的增序将它们添加到最短路径树中，如图 4.4.10 右侧的红色箭头所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01590.jpeg\" alt=\"\" width=\"65%\" style=\"width: 65%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.4.10　Dijkstra 算法的轨迹</strong></p>\n<p>Dijkstra 算法的实现 <code>DijkstraSP</code>（算法 4.9）只是用代码复述了算法的描述，还在 <code>relax()</code> 方法中添加了一行语句来处理以下两种情况：要么边的 <code>to()</code> 得到的顶点还不在优先队列中，此时需要使用 <code>insert()</code> 方法将它加入到优先队列中；要么它已经在优先队列中且优先级需要被降低，此时可以用 <code>change()</code> 方法实现。</p>\n<blockquote>\n<p><strong>命题 R（续）</strong>。在一幅含有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" inline-img=\"true\" /> 个顶点和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01481.gif\" alt=\"E\" inline-img=\"true\" /> 条边的加权有向图中，使用 Dijkstra 算法计算根结点为给定起点的最短路径树所需的空间与 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" inline-img=\"true\" /> 成正比，时间与 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01591.gif\" alt=\"V \\log V\" inline-img=\"true\" /> 成正比（最坏情况下）。</p>\n<p><strong>证明</strong>。同 Prim 算法的证明（请见命题 N）</p>\n</blockquote>\n<p>如前所述，思考 Dijkstra 算法的另一种方式就是将它和 4.3 节的 Prim 算法（算法 4.7）相比较。两种算法都会用添加边的方式构造一棵树：Prim 算法每次添加的都是离<strong>树</strong>最近的非树顶点，Dijkstra 算法每次添加的都是离<strong>起点</strong>最近的非树顶点。它们都不需要 <code>marked[]</code> 数组，因为条件 <code>!marked[w]</code> 等价于条件 <code>distTo[w]</code> 为无穷大。换句话说，将算法 4.9 中的有向图换成无向图并忽略 <code>relax()</code> 方法中 <code>distTo[v]</code> 部分的代码，就会得到算法 4.7，也就是 Prim 算法的即时版本（！）。同样，根据 LazyPrimMST（4.3.4 节框注“最小生成树的 Prim 算法的延时实现”）实现 Dijkstra 算法的延时版本也并不困难。</p>\n<h4>4.4.4.3　变种</h4>\n<p>我们只需对 Dijkstra 算法的实现稍作适当的修改就能够解决这个问题的其他版本，例如，加权无向图中的单点最短路径。给定一幅加权<strong>无向图</strong>和一个起点 <code>s</code>，回答“<strong>是否存在一条从 <code>s</code> 到给定的顶点 <code>v</code> 的路径？</strong>如果有，<strong>找出最短（总权重最小）的那条路径。</strong>”等类似问题。</p>\n<p>如果将无向图看作有向图，这个问题的答案就很简单了。也就是说，对于给定的加权无向图，创建一幅由相同顶点构成的加权有向图，且对于无向图中的每条边，相应地创建两条（方向不同）有向边。有向图中的路径和无向图中的路径存在着一一对应的关系，路径的权重也是相同的——最短路径的问题是等价的。</p>\n<blockquote>\n<p><strong>算法 4.9　最短路径的 Dijkstra 算法</strong></p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01592.gif\" alt=\"\" width=\"80%\" style=\"width: 80%\" /></p>\n<p>Dijkstra 算法的实现每次都会为最短路径树添加一条边，该边由一个树中的顶点指向一个非树顶点 <code>w</code> 且它是到 <code>s</code> 最近的顶点。</p>\n</blockquote>\n<p><strong>给定两点的最短路径</strong>。给定一幅加权有向图以及一个起点 <code>s</code> 和一个终点 <code>t</code>，找到从 <code>s</code> 到 <code>t</code> 的最短路径。</p>\n<p>要解决这个问题，你可以使用 Dijkstra 算法并在从优先队列中取到 <code>t</code> 之后终止搜索。</p>\n<p><strong>任意顶点对之间的最短路径</strong>。给定一幅加权有向图，回答“<strong>给定一个起点 <code>s</code> 和一个终点 <code>t</code>，是否存在一条从 <code>s</code> 到 <code>t</code> 的路径</strong>？如果有，找出<strong>最短</strong>（总权重最小）的那条路径。”等类似问题。</p>\n<p>右边框注中短小精悍的代码解决了任意顶点对之间的最短路径问题，所需的时间与 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01593.gif\" alt=\"EV\\log V\" inline-img=\"true\" /> 成正比，空间与<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01483.gif\" alt=\"V^2\" inline-img=\"true\" />成正比。它构造了 <code>DijkstraSP</code> 对象的数组，每个元素都将相应的顶点作为起点。在用例进行查询时，代码会访问起点所对应的单点最短路径对象并将目的顶点作为参数进行查询。</p>\n<pre class=\"code-rows\"><code>public class DijkstraAllPairsSP\n{\n   private DijkstraSP[] all;\n\n   DijkstraAllPairsSP(EdgeWeightedDigraph G)\n   {\n      all = new DijkstraSP[G.V()]\n      for (int v = 0; v &lt; G.V(); v++)\n         all[v] = new DijkstraSP(G, v);\n   }\n\n   Iterable&lt;DirectedEdge&gt; path(int s, int t)\n   {  return all[s].pathTo(t);  }\n\n   double dist(int s, int t)\n   {  return all[s].distTo(t);  }\n\n}</code></pre>\n<p style=\"text-align: center\">任意顶点对之间的最短路径</p>\n<p><strong>欧几里得图中的最短路径</strong>。在顶点为平面上的点且边的权重与顶点欧几里得间距成正比的图中，解决单点、给定两点和任意顶点对之间的最短路径问题。</p>\n<p>在这种情况下，有一个小小的改动可以大幅提高 Dijkstra 算法的运行速度（请见练习 4.4.27）。</p>\n<p>图 4.4.11 显示的是 Dijkstra 算法在处理测试文件 mediumEWD.txt（请见 4.4.2.2 节）所定义的欧几里得图时用若干不同的起点产生最短路径树的过程。和之前一样，这幅图中的线段都表示双向的有向边。这些图片展示了一段引人入胜的动态过程。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01594.jpeg\" alt=\"\" width=\"75%\" style=\"width: 75%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.4.11　Dijkstra 算法（250 个顶点，不同的起点）</strong></p>\n<p>下面，我们将会考虑加权无环图中的最短路径算法并且将在线性时间内解决该问题（比 Dijkstra 算法要快）。然后是负权重的加权有向图中的最短路径问题，Dijkstra 算法不适用于这种情况。</p>\n<h3 id=\"nav_point_209\">4.4.5　无环加权有向图中的最短路径算法</h3>\n<p>许多应用中的加权有向图都是不含有有向环的。我们现在来学习一种比 Dijkstra 算法更快、更简单的在无环加权有向图中找出最短路径的算法，如图 4.4.12 所示。它的特点是：</p>\n<ul>\n<li>能够在线性时间内解决单点最短路径问题；</li>\n<li>能够处理负权重的边；</li>\n<li>能够解决相关的问题，例如找出<strong>最长</strong>的路径。</li>\n</ul>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01595.jpeg\" alt=\"\" width=\"70%\" style=\"width: 70%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.4.12　一幅无环加权有向图和它的一棵最短路径树</strong></p>\n<p>这些算法都是在 4.2 节中学过的无环有向图的拓扑排序算法的简单扩展。</p>\n<p>特别的是，只要将顶点的放松和拓扑排序结合起来，马上就能够得到一种解决无环加权有向图中的最短路径问题的算法。首先，将 <code>distTo[s]</code> 初始化为 0，其他 <code>distTo[]</code> 元素初始化为无穷大，然后一个一个地按照<strong>拓扑顺序</strong>放松所有顶点。我们可以用与 Dijkstra 算法的证明（命题 R）类似的方法证明这个方法的正确性。</p>\n<blockquote>\n<p><strong>命题 S</strong>。按照拓扑顺序放松顶点，就能在和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01488.gif\" alt=\"E+V\" inline-img=\"true\" /> 成正比的时间内解决无环加权有向图的单点最短路径问题。</p>\n<p><strong>证明</strong>。每条边 <code>v</code> → <code>w</code> 都只会被放松一次。当 <code>v</code> 被放松时，得到：<code>distTo[w]&lt;= distTo[v]+e.weight()</code>。在算法结束前该不等式都成立，因为 <code>distTo[v]</code> 是不会变化的（因为是按照拓扑顺序放松顶点，在 <code>v</code> 被放松之后算法不会再处理任何指向 <code>v</code> 的边）而 <code>distTo[w]</code> 只会变小（任何放松操作都只会减小 <code>distTo[]</code> 中的元素的值）。因此，在所有从 <code>s</code> 可达的顶点都被加入到树中后，最短路径的最优性条件成立，命题 Q 也就成立了。时间上限很容易得到：命题 G 告诉我们拓扑排序所需的时间与 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01488.gif\" alt=\"E+V\" inline-img=\"true\" /> 成正比，而在第二次遍历中每条边都只会被放松一次，因此算法总耗时与 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01488.gif\" alt=\"E+V\" inline-img=\"true\" /> 成正比。</p>\n</blockquote>\n<p>图 4.4.13 是算法处理无环加权有向样图 tinyEWDAG.txt 的轨迹。在这个例子中，算法由顶点 <code>5</code> 开始按照以下步骤构建了一棵最短路径树：</p>\n<ul>\n<li>用深度优先搜索得到图的顶点的拓扑排序 <code>5 1 3 6 4 7 0 2</code>；</li>\n<li>将顶点 <code>5</code> 和从它指出的所有边添加到树中；</li>\n<li>将顶点 <code>1</code> 和边 <code>1</code> → <code>3</code> 添加到树中；</li>\n<li>将顶点 <code>3</code> 和边 <code>3</code> → <code>6</code> 添加到树中，边 <code>3</code> → <code>7</code> 已经失效；</li>\n<li>将顶点 <code>6</code> 和边 <code>6</code> → <code>2</code>、<code>6</code> → <code>0</code> 添加到树中，边 <code>6</code> → <code>4</code> 已经失效；</li>\n<li>将顶点 <code>4</code> 和边 <code>4</code> → <code>0</code> 添加到树中，边 <code>4</code> → <code>7</code> 和 <code>6</code> → <code>0</code> 已经失效；</li>\n<li>将顶点 <code>7</code> 和边 <code>7</code> → <code>2</code> 添加到树中，边 <code>6</code> → <code>2</code> 已经失效；</li>\n<li>将顶点 <code>0</code> 添加到树中，边 <code>0</code> → <code>2</code> 已经失效；</li>\n<li>将顶点 <code>2</code> 添加到树中。</li>\n</ul>\n<p>图中没有画出将 <code>2</code> 添加到树中的一步，拓扑序列中的最后一个顶点没有指出的边。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01596.jpeg\" alt=\"\" width=\"55%\" style=\"width: 55%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.4.13　寻找无环加权有向图中的最短路径的算法轨迹</strong></p>\n<p>算法 4.10 在实现中直接使用了已学习过的许多代码。它假设 <code>Topological</code> 类使用本节中介绍的 <code>EdgeWeightedDigraph</code> 类和 <code>DirectedEdge</code> 类的 API（请见练习 4.4.12）重载了拓扑排序的方法。注意，该实现中不需要布尔数组 <code>marked[]</code>：因为是按照拓扑顺序处理无环有向图中的顶点，所以不可能再次遇到已经被放松过的顶点。算法 4.10 的效率几乎已经没有提高的空间了：在拓扑排序后，构造函数会扫描整幅图并将每条边放松一次。在已知加权图是无环的情况下，它是找出最短路径的最好方法。</p>\n<blockquote>\n<p><strong>算法 4.10　无环加权有向图的最短路径算法</strong></p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01597.gif\" alt=\"\" width=\"85%\" style=\"width: 85%\" /></p>\n<p>无环加权有向图的最短路径算法使用了拓扑排序（算法 4.5，重载了 <code>EdgeWeightedDigraph</code> 类和 <code>DirectedEdge</code> 类）来按照拓扑顺序放松所有顶点，这对于计算出图中的最短路径已经足够了。</p>\n<pre class=\"code-rows\"><code>% java AcyclicSP tinyEWDAG.txt 5\n5 to 0 (0.73): 5-&gt;4 0.35  4-&gt;0 0.38\n5 to 1 (0.32): 5-&gt;1 0.32\n5 to 2 (0.62): 5-&gt;7 0.28  7-&gt;2 0.34\n5 to 3 (0.61): 5-&gt;1 0.32  1-&gt;3 0.29\n5 to 4 (0.35): 5-&gt;4 0.35\n5 to 5 (0.00):\n5 to 6 (1.13): 5-&gt;1 0.32  1-&gt;3 0.29  3-&gt;6 0.52\n5 to 7 (0.28): 5-&gt;7 0.28</code></pre>\n</blockquote>\n<p>命题 S 很重要，因为它的“无环”能够极大地简化问题的论断。对于最短路径问题，基于拓扑排序的方法比 Dijkstra 算法快的倍数与 Dijkstra 算法中所有优先队列操作的总成本成正比。另外，命题 S 的证明和边的权重是否非负无关，因此无环加权有向图不会受到任何限制。下面用这个特点解决边的负权重问题。我们会考虑使用这个最短路径模型来解决另外两个问题，其中之一乍一看甚至和图的处理似乎没有任何关系。</p>\n<h4>4.4.5.1　最长路径</h4>\n<p>考虑在无环加权有向图中寻找最长路径的问题，边的权重可正可负。</p>\n<p><strong>无环加权有向图中的单点最长路径</strong>。给定一幅无环加权有向图（边的权重可能为负）和一个起点 <code>s</code>，回答“<strong>是否存在一条从 <code>s</code> 到给定的顶点 <code>v</code> 的路径</strong>？如果有，找出<strong>最长</strong>（总权重最大）的那条路径。”等类似问题。</p>\n<p>我们刚刚学习过的算法能够快速地解决这个问题。</p>\n<blockquote>\n<p><strong>命题 T</strong>。解决无环加权有向图中的最长路径问题所需的时间与 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01488.gif\" alt=\"E+V\" inline-img=\"true\" /> 成正比。</p>\n<p><strong>证明</strong>。给定一个最长路径问题，复制原始无环加权有向图得到一个副本并将副本中的所有边的权重取相反数。这样，副本中的<strong>最短</strong>路径即为原图中的<strong>最长</strong>路径。要将最短路径问题的答案转换为最长路径问题的答案，只需将方案中的权重变为正值即可。根据命题 S 立即可以得到算法所需的时间。</p>\n</blockquote>\n<p>根据这种转换实现 <code>AcyclicLP</code> 类来寻找一幅无环加权有向图中的最长路径就十分简单了。实现该类的一个更简单的方法是修改 <code>AcyclicSP</code>，将 <code>distTo[]</code> 的初始值变为 <code>Double.NEGATIVE_INFINITY</code> 并改变 <code>relax()</code> 方法中的不等式的方向。无论使用哪种方法，都能得到无环加权有向图中的最长路径问题的一种高效的解决方案。和它形成鲜明对比的是，在一般的加权有向图（边的权重可能为负）中寻找最长简单路径的已知最好算法在最坏情况下所需的时间是<strong>指数级别</strong>的（请见第 6 章）！出现环的可能性似乎使这个问题的难度以指数级别增长。</p>\n<p>图 4.4.14 是算法在无环加权有向样图 tinyEWDAG.txt 中寻找最长路径的轨迹，你可以将它与图 4.4.13 相比较。在这个例子中，算法由顶点 <code>5</code> 按照以下步骤构建了一棵最长路径树：</p>\n<ul>\n<li>用深度优先搜索得到图的顶点的拓扑排序 <code>5 1 3 6 4 7 0 2</code>；</li>\n<li>将顶点 <code>5</code> 和从它指出的所有边添加到树中；</li>\n<li>将顶点 <code>1</code> 和边 <code>1</code> → <code>3</code> 添加到树中 <code>;</code></li>\n<li>将顶点 <code>3</code> 和边 <code>3</code> → <code>6</code>、<code>3</code> → <code>7</code> 添加到树中，边 <code>5</code> → <code>7</code> 已经失效；</li>\n<li>将顶点 <code>6</code> 和边 <code>6</code> → <code>2</code>、<code>6</code> → <code>4</code> 和 <code>6</code> → <code>0</code> 添加到树中，边 <code>5</code> → <code>4</code> 已经失效；</li>\n<li>将顶点 <code>4</code> 和边 <code>4</code> → <code>0</code>、<code>4</code> → <code>7</code> 添加到树中，边 <code>6</code> → <code>0</code> 和 <code>3</code> → <code>7</code> 已经失效；</li>\n<li>将顶点 <code>7</code> 和边 <code>7</code> → <code>2</code> 添加到树中，边 <code>6</code> → <code>2</code> 已经失效；</li>\n<li>将顶点 <code>0</code> 添加到树中，边 <code>0</code> → <code>2</code> 已经失效；</li>\n<li>将顶点 <code>2</code> 添加到树中（未画出）。</li>\n</ul>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01598.jpeg\" alt=\"\" width=\"55%\" style=\"width: 55%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.4.14　无环图中的最长路径算法</strong></p>\n<p>最长路径算法处理顶点的顺序和最短路径算法一样，但产生的结果却完全不同。</p>\n<h4>4.4.5.2　并行任务调度</h4>\n<p>作为算法应用的示例，我们再次考虑在 4.2 节中出现过的任务调度类的问题。这次需要解决以下调度问题（楷体部分为与 4.2.4.1 节的问题描述的不同之处）。</p>\n<p><strong>优先级限制下的并行任务调度</strong>。给定一组需要完成的任务和每个任务<strong>所需的时间</strong>，以及一组关于任务完成的先后次序的优先级限制。在满足限制条件的前提下应该如何在<strong>若干相同的处理器上（数量不限）</strong>安排任务并在<strong>最短的时间内</strong>完成所有任务？</p>\n<p>4.2 节的模型默认只有单个处理器：将任务按照拓扑顺序排序，完成任务的总耗时就是所有任务所需要的总时间。现在假设有足够多的处理器并能够同时处理任意多的任务，受到的只有优先级的限制。和以前一样，需要处理的任务可能上百万甚至上亿，因此需要一个高效的算法。令人兴奋的是，正好存在一种线性时间的算法——一种叫做“关键路径“的方法能够证明这个问题与无环加权有向图中的最长路径问题是等价的。这个方法已成功应用于无数的工业软件之中。</p>\n<p>假设任意可用的处理器都能在任务所需的时间内完成它，那么我们的重点就是尽早安排每一个任务。例如，表 4.4.5 给出了一个任务调度问题，图 4.4.15 给出的解决方案显示了这个问题所需的最短时间为 173.0。这份调度方案满足了所有限制条件，没有其他调度方案能比它耗时更少，因为任务必须按照 <code>0</code> → <code>9</code> → <code>6</code> → <code>8</code> → <code>2</code> 的顺序完成。这个顺序就是这个问题的<strong>关键路径</strong>。由优先级限制指定的每一列任务都代表了调度方案的一种可能的时间下限。如果将一系列任务的长度定义为完成所有任务的最早可能时间，那么最长的任务序列就是问题的关键路径，因为在这份任务序列中任何任务的启动延迟都会影响到整个项目的完成时间。</p>\n<p><strong>表 4.4.5　一个任务调度问题</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>任务</p></th>\n<th><p>时耗</p></th>\n<th><p>必须在以下任务之前完成</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>0</code></p></td>\n<td><p><code>41.0</code></p></td>\n<td><p><code>1</code>　<code>7</code>　<code>9</code></p></td>\n</tr>\n<tr>\n<td><p><code>1</code></p></td>\n<td><p><code>51.0</code></p></td>\n<td><p><code>2</code></p></td>\n</tr>\n<tr>\n<td><p><code>2</code></p></td>\n<td><p><code>50.0</code></p></td>\n<td><p>&nbsp;</p></td>\n</tr>\n<tr>\n<td><p><code>3</code></p></td>\n<td><p><code>36.0</code></p></td>\n<td><p>&nbsp;</p></td>\n</tr>\n<tr>\n<td><p><code>4</code></p></td>\n<td><p><code>38.0</code></p></td>\n<td><p>&nbsp;</p></td>\n</tr>\n<tr>\n<td><p><code>5</code></p></td>\n<td><p><code>45.0</code></p></td>\n<td><p>&nbsp;</p></td>\n</tr>\n<tr>\n<td><p><code>6</code></p></td>\n<td><p><code>21.0</code></p></td>\n<td><p><code>3</code>　<code>8</code></p></td>\n</tr>\n<tr>\n<td><p><code>7</code></p></td>\n<td><p><code>32.0</code></p></td>\n<td><p><code>3</code>　<code>8</code></p></td>\n</tr>\n<tr>\n<td><p><code>8</code></p></td>\n<td><p><code>32.0</code></p></td>\n<td><p><code>2</code></p></td>\n</tr>\n<tr>\n<td><p><code>9</code></p></td>\n<td><p><code>29.0</code></p></td>\n<td><p><code>4</code>　<code>6</code></p></td>\n</tr>\n</tbody>\n</table>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01599.gif\" alt=\"\" width=\"90%\" style=\"width: 90%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.4.15　并行任务调度问题的解决方案</strong></p>\n<blockquote>\n<p><strong>定义</strong>。解决并行任务调度问题的关键路径方法的步骤如下：创建一幅无环加权有向图，其中包含一个起点 <code>s</code> 和一个终点 <code>t</code> 且每个任务都对应着两个顶点（一个<strong>起始</strong>顶点和一个<strong>结束</strong>顶点）。对于每个任务都有一条从它的起始顶点指向结束顶点的边，边的权重为任务所需的时间。对于每条优先级限制 <code>v</code> → <code>w</code>，添加一条从 <code>v</code> 的结束顶点指向 <code>w</code> 的起始顶点的权重为零的边。我们还需要为每个任务添加一条从起点指向该任务的起始顶点的权重为零的边以及一条从该任务的结束顶点到终点的权重为零的边。这样，每个任务预计的开始时间即为从起点到它的起始顶点的最长距离。</p>\n</blockquote>\n<p>图 4.4.16 显示的是示例任务所对应的图，图 4.4.17 则显示的是最长路径的答案。如定义所述，在图中每个任务都对应着三条边（从起点到起始顶点、从结束顶点到终点的权重为零的边，以及一条从起始顶点到结束顶点的边），每个优先级限制条件都对应着一条边。后面框注“优先级限制下的并行任务调度问题的关键路径方法”中的 <code>CPM</code> 类简洁明了地实现了关键路径方法。它能够将任意任务调度问题转化为无环加权有向图中的一个最长路径问题，用 <code>AcyclicLP</code> 解决它并打印出每个任务的开始时间以及调度方案的结束时间。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01600.jpeg\" alt=\"\" width=\"95%\" style=\"width: 95%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.4.16　任务调度问题的无环加权有向图表示</strong></p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01601.jpeg\" alt=\"\" width=\"95%\" style=\"width: 95%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.4.17　任务调度示例问题的最长路径解决方案</strong></p>\n<blockquote>\n<p><strong>优先级限制下的并行任务调度问题的关键路径方法</strong></p>\n<pre class=\"code-rows\"><code>public class CPM\n{\n   public static void main(String[] args)\n   {\n      int N = StdIn.readInt(); StdIn.readLine();\n      EdgeWeightedDigraph G;\n      G = new EdgeWeightedDigraph(2*N+2);\n      int s = 2*N, t = 2*N+1;\n      for (int i = 0; i &lt; N; i++)\n      {\n         String[] a = StdIn.readLine().split(\"\\\\s+\");\n         double duration = Double.parseDouble(a[0]);\n         G.addEdge(new DirectedEdge(i, i+N, duration));\n         G.addEdge(new DirectedEdge(s, i, 0.0));\n         G.addEdge(new DirectedEdge(i+N, t, 0.0));\n         for (int j = 1; j &lt; a.length; j++)\n         {\n            int successor = Integer.parseInt(a[j]);\n            G.addEdge(new DirectedEdge(i+N, successor, 0.0));\n         }\n      }\n      AcyclicLP lp = new AcyclicLP(G, s);\n\n      StdOut.println(\"Start times:\");\n      for (int i = 0; i &lt; N; i++)\n         StdOut.printf(\"%4d: %5.1f\\n\", i, lp.distTo(i));\n      StdOut.printf(\"Finish time: %5.1f\\n\", lp.distTo(t));\n  }\n\n}</code></pre>\n<p>　</p>\n<pre class=\"code-rows\"><code>% more jobsPC.txt\n10\n41.0  1 7 9\n51.0  2\n50.0\n36.0\n38.0\n45.0\n21.0  3 8\n32.0  3 8\n32.0  2\n29.0  4 6</code></pre>\n<p>　</p>\n<pre class=\"code-rows\"><code>% java CPM &lt; jobsPC.txt\nStart times:\n   0:   0.0\n   1:  41.0\n   2: 123.0\n   3:  91.0\n   4:  70.0\n   5:   0.0\n   6:  70.0\n   7:  41.0\n   8:  91.0\n   9:  41.0\nFinish time: 173.0</code></pre>\n<p>这里实现的任务调度问题的关键路径方法将问题归约为寻找无环加权有向图的最长路径问题。它会根据任务调度问题的描述用关键路径的方法构造一幅加权有向图（且必然是无环的），然后使用 <code>AcyclicLP</code>（请见命题 T）找到图中的最长路径树，最后打印出各条最长路径的长度，也就正好是每个任务的开始时间。</p>\n</blockquote>\n<p>　</p>\n<blockquote>\n<p><strong>命题 U</strong>。解决优先级限制下的并行任务调度问题的关键路径法所需的时间为线性级别。</p>\n<p><strong>证明</strong>。为什么 <code>CPM</code> 类能够解决问题？算法的正确性依赖于两个因素。首先，在相应的有向无环图中，每条路径都是由任务的起始顶点和结束顶点组成的并由权重为零的优先级限制条件的边分隔——从起点 <code>s</code> 到任意顶点 <code>v</code> 的任意路径的长度都是任务 <code>v</code> 的开始/结束时间的下限，因为这已经是在同一台处理器上顺序完成这些任务的最优的排列顺序了。因此，从起点 <code>s</code> 到终点 <code>t</code> 的最长路径就是所有任务的完成时间的<strong>下限</strong>。第二，由最长路径得到的所有开始和结束时间都是<strong>可行的</strong>——每个任务都只能在优先级限制指定的先导任务完成之后开始，因为它的开始时间就是顶点到它的起始顶点的最长路径的长度。因此，从起点 <code>s</code> 到终点 <code>t</code> 的<strong>最长</strong>路径长度就是所有任务完成时间的<strong>上限</strong>。由命题T很容易得到算法所需的时间是线性的。</p>\n</blockquote>\n<h4>4.4.5.3　相对最后期限限制下的并行任务调度</h4>\n<p>一般的最后期限（deadline）都是相对于第一个任务的开始时间而言的。假设在任务调度问题中加入一种新类型的限制，需要某个任务必须在指定的时间点之前开始，即指定和另一个任务的开始时间的相对时间。这种类型的限制条件在争分夺秒的生产线上以及许多其他应用中都很常见，但它也会使得任务调度问题更难解决。例如，如表 4.4.6 所示，假设要在前面的示例中加入一个限制条件，使 2 号任务必须在 4 号任务启动后的 12 个时间单位之内开始。实际上，在这里最后期限限制的是 4 号任务的开始时间：它的开始时间不能早于 2 号任务开始 12 个时间单位。在示例中，调度表中有足够的空档来满足这个最后期限限制：我们可以令 4 号任务开始于 111 时间，即 2 号任务计划开始时间前的 12 个时间单位处。需要注意的是，如果 4 号任务耗时很长，这个修改可能会延长整个调度计划的完成时间。同理，如果再添加一个最后期限的限制条件，令 2 号任务必须在 7 号任务启动后的 70 个时间单位内开始，还可以将 7 号任务的开始时间调整到 53，这样就不用修改 3 号任务和 8 号任务的计划开始时间。但是如果继续限制 4 号任务必须在零号任务启动后的 80 个时间单位内开始，那么就<strong>不存在可行</strong>的调度计划了：限制条件 4 号任务必须在 0 号任务启动后的 80 个时间单位内开始以及 2 号任务必须在 4 号任务启动后的 12 个时间单位之内开始，意味着 2 号任务必须在 0 号任务启动后的 93 个时间单位之内开始，但因为存在任务链 0（41 个时间单位）→ 9（29 个时间单位）→ 6（21 个时间单位）→ 8（32 个时间单位）→ 2，2 号任务最早也只能在 0 号任务启动后的 123 个时间单位之内开始。前面添加的限制如表 4.4.7 所示。最后期限的限制越多，调度的可能性也就越多，简单的问题也会变得越困难。</p>\n<p><strong>表 4.4.6　相对最后期限限制下的任务调度</strong></p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01602.gif\" alt=\"\" width=\"48%\" style=\"width: 48%\" /></p>\n<p><strong>表 4.4.7　向任务调度问题中添加的最后期限限制</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>任务</p></th>\n<th><p>相对最后期限</p></th>\n<th><p>相对于任务</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>2</code></p></td>\n<td><p><code>12.0</code></p></td>\n<td><p><code>4</code></p></td>\n</tr>\n<tr>\n<td><p><code>2</code></p></td>\n<td><p><code>70.0</code></p></td>\n<td><p><code>7</code></p></td>\n</tr>\n<tr>\n<td><p><code>4</code></p></td>\n<td><p><code>80.0</code></p></td>\n<td><p><code>0</code></p></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p><strong>命题 V</strong>。相对最后期限限制下的并行任务调度问题是一个加权有向图中的最短路径问题（可能存在环和负权重边）。</p>\n<p><strong>证明</strong>。与命题 U 一样根据任务调度的描述构造相同的加权有向图，为每条最后期限限制添加一条边：如果任务 <code>v</code> 必须在任务 <code>w</code> 启动后的 <code>d</code> 个时间单位内开始，则添加一条从 <code>v</code> 指向 <code>w</code> 的<strong>负</strong>权重为 <code>d</code> 的边。将所有边的权重取反即可将该问题转化为一个最短路径问题。如果<strong>存在可行的调度方案</strong>，证明也就完成了。你将会看到，判断一个调度方案是否可行也是计算的一部分。</p>\n</blockquote>\n<p>这个示例说明了负权重的边在实际应用的模型中也能起到重要的作用。它说明，如果能够有效解决负权重边的最短路径问题，那就能够找到相对最后期限限制下的并行任务调度问题的解决方案。我们已经学习过的算法都无法完成这个任务： Dijkstra 算法只适用于正（或零）权重的边，算法 4.10 要求有向图是无环的。下面我们来看看如何解决含有负权重且不一定是无环的有向图中的最短路径问题（请见图 4.4.18）。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01603.jpeg\" alt=\"\" width=\"90%\" style=\"width: 90%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.4.18　相对最后期限限制和优先级限制下的并行任务调度问题的加权有向图表示</strong></p>\n<h3 id=\"nav_point_210\">4.4.6　一般加权有向图中的最短路径问题</h3>\n<p>刚才讨论过的最后期限限制下的任务调度问题告诉我们负权重的边并不仅仅是一个数学问题。相反，它能够极大地扩展解决最短路径问题的模型的应用范围。接下来，考虑既可能含有环也可能含有负权重的边的加权有向图中的最短路径算法。在开始之前，先来学习一下这种有向图的基本性质以更新我们对最短路径的认识。图 4.4.19 是一个小小的示例，展示的是负权重的边对有向图中的最短路径的影响。也许最明显的改变就是当存在负权重的边时，权重较小的路径含有的边可能会比权重较大的路径更多。在只存在正权重的边时，我们的重点在于寻找近路；但当存在负权重的边时，我们可能会为了经过负权重的边而<strong>绕弯</strong>。这种效应使得我们要将查找“最短”路径的感觉转变为对算法本质的理解。因此需要抛弃直觉并在一个简单、抽象的层面上考虑这个问题。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01604.gif\" alt=\"\" width=\"70%\" style=\"width: 70%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.4.19　含有负权重的边的加权有向图</strong></p>\n<h4>4.4.6.1　尝试Ⅰ</h4>\n<p>第一个想法是先找到权重最小（最小的负值）的边，然后将所有边的权重加上这个负值的绝对值，这样原有向图就转变称为了一幅不含有负权重边的有向图。这种天真的做法不会解决任何问题，因为新图中的最短路径和原图中的最短路径毫无关系。路径中的边越多，这种变换产生的危害越大（请见练习 4.4.14）。</p>\n<h4>4.4.6.2　尝试Ⅱ</h4>\n<p>第二个想法是尝试改造 Dijkstra 算法。这种方法最根本的缺陷在于原算法的基础在于根据距离起点的远近依次检查路径。命题 R 对算法正确性的证明是基于添加一条边会使的路径变得更长的假设。但添加任意负权重的边只会使得路径更短，因此这个假设是不成立的（请见练习 4.4.14）。</p>\n<h4>4.4.6.3　负权重的环</h4>\n<p>当我们在研究含有负权重边的有向图时，如果该图中含有一个权重为负的环，那么最短路径的概念就失去意义了。例如图 4.4.20，除了边 <code>5</code> → <code>4</code> 的权重为 -0.66 外，它和第一个示例完全相同。这里，环 <code>4</code> → <code>7</code> → <code>5</code> → <code>4</code> 的权重为：</p>\n<p style=\"text-align: center\"><code>0.37+0.28-0.66=-0.01</code></p>\n<p>我们只要围着这个环兜圈子就能得到权重任意短的路径！注意，有向环的所有边的权重并不一定都必须是负的，只要权重之和是负的即可。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01605.gif\" alt=\"\" width=\"60%\" style=\"width: 60%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.4.20　含有负权重环的加权有向图</strong></p>\n<blockquote>\n<p><strong>定义</strong>。加权有向图中的<strong>负权重环</strong>是一个总权重（环上的所有边的权重之和）为负的有向环。</p>\n</blockquote>\n<p>现在，假设从 <code>s</code> 到可达的某个顶点 <code>v</code> 的路径上的某个顶点在一个负权重环上。在这种情况下，从 <code>s</code> 到 <code>v</code> 的最短路径是不可能存在的，因为可以用这个负权重环构造权重任意小的路径。换句话说，在负权重环存在的情况下，最短路径问题是没有意义的，如图 4.4.21 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01606.jpeg\" alt=\"\" width=\"60%\" style=\"width: 60%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.4.21　最短路径问题的各种可能性</strong></p>\n<blockquote>\n<p><strong>命题 W</strong>。当且仅当加权有向图中至少存在一条从 <code>s</code> 到 <code>v</code> 的有向路径<strong>且</strong>所有从 <code>s</code> 到 <code>v</code> 的有向路径上的任意顶点都不存在于任何负权重环中时，<code>s</code> 到 <code>v</code> 的最短路径才是存在的。</p>\n<p><strong>证明</strong>。请见以上讨论以及练习 4.4.29。</p>\n</blockquote>\n<p>注意，要求最短路径上的任意顶点都不存在于负权重环中意味着最短路径是简单的，而且与正权重边的图一样都能够得到此类顶点的最短路径树。</p>\n<h4>4.4.6.4　尝试Ⅲ</h4>\n<p>无论是否存在负权重环，从 <code>s</code> 到可达的其他顶点的一条最短的<strong>简单</strong>路径都是存在的。为什么不定义最短路径以方便寻找呢？不幸的是，已知解决这个问题的最好算法在最坏情况下所需的时间是指数级别的（请见第 6 章）。一般来说，我们认为这种问题“太难了”，只会研究它的简单版本。</p>\n<p>因此，一个定义明确且可以解决加权有向图最短路径问题的算法要能够：</p>\n<ul>\n<li>对于从起点不可达的顶点，最短路径为正无穷（+∞）；</li>\n<li>对于从起点可达但路径上的某个顶点属于一个负权重环的顶点，最短路径为负无穷（-∞）；</li>\n<li>对于其他所有顶点，计算最短路径的权重（以及最短路径树）。</li>\n</ul>\n<p>从本节的开始到现在，我们为最短路径问题加上各种限制，使得我们能够找到解决相应问题的办法。首先，我们不允许负权重边的存在；其次不接受有向环。现在我们放宽所有这些条件并重点解决一般有向图中的以下问题。</p>\n<p><strong>负权重环的检测</strong>。给定的加权有向图中含有负权重环吗？如果有，找到它。</p>\n<p><strong>负权重环不可达时的单点最短路径</strong>。给定一幅加权有向图和一个起点 <code>s</code> 且从 <code>s</code> 无法到达任何负权重环，回答“<strong>是否存在一条从 <code>s</code> 到给定的顶点 <code>v</code> 的有向路径</strong>？如果有，找出<strong>最短</strong>（总权重最小）的那条路径。”等类似问题。</p>\n<p><strong>总结</strong>。尽管在含有环的有向图中最短路径是一个没有意义的问题，而且也<strong>无法</strong>有效解决在这种有向图中高效找出最短简单路径的问题，在实际应用中仍然需要<strong>能够</strong>识别其中的负权重环。例如，在最后期限限制下的任务调度问题中，负权重环的出现可能相对较少：限制条件和最后期限都是从现实世界中的实际限制得来的，因此负权重环大多可能来自于问题陈述中的错误。找出负权重环，改正相应的错误，找到没有负权重环问题的调度方案才是解决问题的正确方式。在其他情况下，找到负权重环就是计算的目标。下面这个由 R.Bellman 和 L.Ford 在 20 世纪 50 年代末期发明的算法能够简明、有效地解决这些问题并且同样适用于正权重边的有向图。</p>\n<blockquote>\n<p><strong>命题 X（Bellman-Ford 算法）</strong>。在任意含有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" inline-img=\"true\" /> 个顶点的加权有向图中给定起点 <code>s</code>，从 <code>s</code> 无法到达任何负权重环，以下算法能够解决其中的单点最短路径问题：将 <code>distTo[s]</code> 初始化为 0，其他 <code>distTo[]</code> 元素初始化为无穷大。以任意顺序放松有向图的所有边，重复 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" inline-img=\"true\" /> 轮。</p>\n<p><strong>证明</strong>。对于从 <code>s</code> 可达的任意顶点 <code>t</code>，考虑从 <code>s</code> 到 <code>t</code> 的一条最短路径：<code>v<sub>0</sub></code> → <code>v<sub>1</sub></code>→ ... → <code>v<sub><i>k</i></sub></code>，其中 <code>v<sub>0</sub></code> 等于 <code>s</code>，<code>v<sub><i>k</i></sub></code> 等于 <code>t</code>。因为负权重环是不可达的，这样的路径是存在的且 <code>v<i>k</i></code> 不会大于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01468.gif\" alt=\"V-1\" inline-img=\"true\" />。我们会通过归纳法证明算法在第 <code><i>i</i></code> 轮之后能够得到 <code>s</code> 到 <code>v<sub><i>i</i></sub></code> 的最短路径。最简单的情况（<code><i>i</i>=0</code>）很容易。假设对于 <code><i>i</i></code> 命题成立，那么 <code>s</code> 到 <code>v<sub><i>i</i></sub></code> 的最短路径即为 <code>v<sub>0</sub></code> → <code>v<sub>1</sub></code>→ ... → <code>v<sub><i>i</i></sub></code>，<code>distTo[v<sub><i>i</i></sub>]</code> 就是这条路径的长度。现在，我们在第 <code><i>i</i></code> 轮中放松所有的顶点，包括 <code>v<sub><i>i</i></sub></code>，因此 <code>distTo[v<sub><i>i</i>+1</sub>]</code> 不会大于 <code>distTo[v<sub><i>i</i></sub>]</code> 与边 <code>v<sub><i>i</i></sub></code> → <code>v<sub><i>i</i>+1</sub></code> 的权重之和。在第 <code><i>i</i></code> 轮放松之后，<code>distTo[v<sub><i>i</i>+1</sub>]</code> 必然等于 <code>distTo[v<sub><i>i</i></sub>]</code> 与边 <code>v<sub><i>i</i></sub></code> → <code>v<sub><i>i</i>+1</sub></code> 的权重之和。它不可能更大，因为在第 <code><i>i</i></code> 轮中放松了所有顶点，包括 <code>v<sub><i>i</i></sub></code>；它也不可能更小，因为它就是路径 <code>v<sub>0</sub></code> → <code>v<sub>1</sub></code>→ ... → <code>v<sub><i>i</i>+1</sub></code> 的长度，也就是最短路径了。因此，在 <code><i>i</i>+1</code> 轮之后算法能够得到从 <code>s</code> 到 <code>v<sub><i>i</i>+1</sub></code> 的最短路径。</p>\n</blockquote>\n<p>　</p>\n<blockquote>\n<p><strong>命题 W（续）</strong>。Bellman-Ford算法所需的时间和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01607.gif\" alt=\"E\" inline-img=\"true\" /> 成正比，空间和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" inline-img=\"true\" /> 成正比。</p>\n<p><strong>证明</strong>。在每一轮中算法都会放松 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01481.gif\" alt=\"E\" inline-img=\"true\" /> 条边，共重复 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" inline-img=\"true\" /> 轮。</p>\n</blockquote>\n<p>这个方法非常通用，因为它没有指定边的放松顺序。下面将注意力集中在一个通用性稍逊的方法上，其中只放松从任意顶点指出的所有边（顺序任意），以下代码说明了这种方法的简洁性：</p>\n<pre class=\"code-rows\"><code>for (int pass = 0; pass &lt; G.V(); pass++)\n   for (v = 0; v &lt; G.V(); v++)\n      for (DirectedEdge e : G.adj(v))\n         relax(e);</code></pre>\n<p>我们不会仔细研究这个版本，因为它<strong>总是</strong>会放松 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01608.gif\" alt=\"VE\" inline-img=\"true\" /> 条边且只需稍作修改即可使算法在一般的应用场景中更加高效。</p>\n<h4>4.4.6.5　基于队列的 Bellman-Ford 算法</h4>\n<p>其实，根据经验我们很容易知道在任意一轮中许多边的放松都不会成功：只有上一轮中的 <code>distTo[]</code> 值发生变化的顶点指出的边才能够改变其他 <code>distTo[]</code> 元素的值。为了记录这样的顶点，我们使用了一条 FIFO 队列。算法在处理正权重标准样图中进行的操作如图 4.4.22 所示。在示意图 4.4.22 左侧是每一轮中队列中的有效顶点（红色），紧接着是下一轮中的有效顶点（黑色）。首先将起点加入队列，然后按照以下步骤计算最短路径树。</p>\n<ul>\n<li>放松边 <code>1</code> → <code>3</code> 并将顶点 <code>3</code> 加入队列。</li>\n<li>放松边 <code>3</code> → <code>6</code> 并将顶点 <code>6</code> 加入队列。</li>\n<li>放松边 <code>6</code> → <code>4</code>、<code>6</code> → <code>0</code> 和 <code>6</code> → <code>2</code> 并将顶点 <code>4</code>、<code>0</code> 和 <code>2</code> 加入队列。</li>\n<li>放松边 <code>4</code> → <code>7</code>、<code>4</code> → <code>5</code> 并将顶点 <code>7</code> 和 <code>5</code> 加入队列。放松已经失效的边 <code>0</code> → <code>4</code> 和 <code>0</code> → <code>2</code>。然后再放松边 <code>2</code> → <code>7</code>（并重新为 <code>4</code> → <code>7</code> 着色）。</li>\n<li>放松边 <code>7</code> → <code>5</code>（并重新为 <code>4</code> → <code>5</code> 着色）但不将顶点 <code>5</code> 加入队列（它已经在队列之中了）。放松已经失效的边 <code>7</code> → <code>3</code>。然后放松已经失效的边 <code>5</code> → <code>1</code>、<code>5</code> → <code>4</code> 和 <code>5</code> → <code>7</code>。此时队列为空。</li>\n</ul>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01609.jpeg\" alt=\"\" width=\"55%\" style=\"width: 55%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.4.22　Bellman-Ford 算法的轨迹</strong></p>\n<h4>4.4.6.6　实现</h4>\n<p>根据这些描述实现 Bellman-Ford 算法所需的代码非常少，如算法 4.11 所示。它基于以下两种其他的数据结构：</p>\n<ul>\n<li>一条用来保存即将被放松的顶点的队列 <code>queue</code>；</li>\n<li>一个由顶点索引的 <code>boolean</code> 数组 <code>onQ[]</code>，用来指示顶点是否已经存在于队列中，以防止将顶点重复插入队列。</li>\n</ul>\n<p>首先，将起点 <code>s</code> 加入队列中，然后进入一个循环，其中每次都从队列中取出一个顶点并将其放松。要将一个顶点插入队列，需要修改 4.4.2.5 节框注“边的松驰”中 <code>relax()</code> 方法的实现，以便将被成功放松的边所指向的顶点加入队列中，如右边框注“Bellman-Ford 算法中的放松操作”所示。这些数据结构能够保证：</p>\n<ul>\n<li>队列中不出现重复的顶点；</li>\n<li>在某一轮中，改变了 <code>edgeTo[]</code> 和 <code>distTo[]</code> 的值的所有顶点都会在下一轮中处理。</li>\n</ul>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01610.gif\" alt=\"\" width=\"72%\" style=\"width: 72%\" /></p>\n<p style=\"text-align: center\">Bellman-Ford 算法中的放松操作</p>\n<p>要完整地实现该算法，我们就需要保证在 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" inline-img=\"true\" /> 轮后算法能够终止。实现它的一种方法是显式记录放松的轮数。我们的实现 <code>BellmanFordSP</code>（算法 4.11）使用了另一种方法，将会在 4.4.6.8 节详述：它会在有向图的 <code>edgeTo[]</code> 中检测是否存在负权重环，如果找到则结束运行。</p>\n<blockquote>\n<p><strong>命题 Y</strong>。对于任意含有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" inline-img=\"true\" /> 个顶点的加权有向图和给定的起点 <code>s</code>，在最坏情况下基于队列的 Bellman-Ford 算法解决最短路径问题（或者找到从 <code>s</code> 可达的负权重环）所需的时间与 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01607.gif\" alt=\"E\" inline-img=\"true\" /> 成正比，空间和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" inline-img=\"true\" /> 成正比。</p>\n<p><strong>证明</strong>。如果不存在从 <code>s</code> 可达的负权重环，算法会根据命题 X 在进行 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01468.gif\" alt=\"V-1\" inline-img=\"true\" /> 轮放松操作后结束（因为所有最短路径含有的边数都不大于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01468.gif\" alt=\"V-1\" inline-img=\"true\" />）。如果的确存在一个从 <code>s</code> 可达的负权重环，那么队列永远不可能为空。根据命题 X，在第 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" inline-img=\"true\" /> 轮放松之后，<code>edgeTo[]</code> 数组必然会包含一条含有一个环的路径（从某个顶点 <code>w</code> 回到它自己）且该环的权重必然是负的。因为 <code>w</code> 会在路径上出现两次且 <code>s</code> 到 <code>w</code> 的第二次出现处的路径长度小于 <code>s</code> 到 <code>w</code> 的第一次出现的路径长度。在最坏情况下，该算法的行为和通用算法相似并会将所有的 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01481.gif\" alt=\"E\" inline-img=\"true\" /> 条边全部放松 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" inline-img=\"true\" /> 轮。</p>\n</blockquote>\n<p>　</p>\n<blockquote>\n<p><strong>算法 4.11　基于队列的 Bellman-Ford 算法</strong></p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01611.gif\" alt=\"\" width=\"80%\" style=\"width: 80%\" /></p>\n<p>Bellman-Ford 算法的实现修改了 <code>relax()</code> 方法，将被成功放松的边指向的所有顶点加入到一条 FIFO 队列中（队列中不出现重复的顶点）并周期性地检查 <code>edgeTo[]</code> 表示的子图中是否存在负权重环（请见正文）。</p>\n</blockquote>\n<p>基于队列的 Bellman-Ford 算法能够准确有效地解决最短路径问题并且在实际中被广泛应用，甚至包括正权重的情况。例如，如图 4.4.23 所示，在含有 250 个顶点的样图中，算法进行了 14 轮操作且对于相同的问题比较路径长度的次数少于 Dijkstra 算法。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01612.jpeg\" alt=\"\" width=\"45%\" style=\"width: 45%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.4.23　Bellman-Ford 算法（250 个顶点）</strong></p>\n<h4>4.4.6.7　负权重的边</h4>\n<p>图 4.4.24 显示了 Bellman-Ford 算法在处理含有负权重边的有向图的轨迹。首先将起点加入队列 <code>queue</code>，然后按照以下步骤计算最短路径树。</p>\n<ul>\n<li>放松边 <code>0</code> → <code>2</code> 和 <code>0</code> → <code>4</code> 并将顶点 <code>2</code>、<code>4</code> 加入队列。</li>\n<li>放松边 <code>2</code> → <code>7</code>并将顶点 <code>7</code> 加入队列。放松边 <code>4</code> → <code>5</code> 并将顶点 <code>5</code> 加入队列。然后放松失效的边 <code>4</code> → <code>7</code>。</li>\n<li>放松失效的边 <code>7</code> → <code>5</code>、<code>5</code> → <code>4</code> 和 <code>5</code> → <code>7</code>。</li>\n<li>放松边 <code>7</code> → <code>3</code> 和 <code>5</code> → <code>1</code> 并将顶点 <code>3</code> 和 <code>1</code> 加入队列。放松失效的边 <code>5</code> → <code>4</code> 和 <code>5</code> → <code>7</code>。</li>\n<li>放松边 <code>3</code> → <code>6</code> 并将顶点 <code>6</code> 加入队列。放松失效的边 <code>1</code> → <code>3</code>。</li>\n<li>放松失效的边 <code>6</code> → <code>0</code> 和 <code>6</code> → <code>2</code>。</li>\n<li>放松边 <code>6</code> → <code>4</code> 并将顶点 <code>4</code> 加入队列。这条负权重边使得到顶点 <code>4</code> 的路径变短，因此它的边需要被再次放松（它们在第二轮中已经被放松过）。从起点到顶点 <code>5</code> 和 <code>1</code> 的距离已经失效并会在下一轮中修正。</li>\n<li>放松边 <code>4</code> → <code>5</code> 并将顶点 <code>5</code> 加入队列。放松失效的边 <code>4</code> → <code>7</code>。</li>\n<li>放松边 <code>5</code> → <code>1</code> 并将顶点 <code>1</code> 加入队列。放松失效的边 <code>5</code> → <code>4</code> 和 <code>5</code> → <code>7</code>。</li>\n<li>放松失效的边 <code>1</code> → <code>3</code>。队列为空。</li>\n</ul>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01613.jpeg\" alt=\"\" width=\"85%\" style=\"width: 85%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.4.24　Bellman-Ford 算法的轨迹（图中含有负权重边）</strong></p>\n<p>在这个例子中，最短路径树就是一条从顶点 <code>0</code> 到顶点 <code>1</code> 的路径。从顶点 <code>4</code>、<code>5</code> 和 <code>1</code> 指出的所有边都被放松了两次。对照这个例子重读命题 X 的证明能够帮助你更好的理解这个算法。</p>\n<h4>4.4.6.8　负权重环的检测</h4>\n<p>实现 <code>BellmanFordSP</code> 会检测负权重环来避免陷入无限的循环中。我们也可以将这段检测代码独立出来使得用例可以检查并得到负权重环。因此我们为表 4.4.4 中的 API 添加以下方法请见表 4.4.8。</p>\n<p><strong>表 4.4.8　为处理负权重环扩展最短路径的 API</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean hasNegativeCycle()</code></td><td>是否含有负权重环</td></tr>\n<tr><td><code>Iterable&lt;DirectedEdge&gt; negativeCycle()</code></td><td>得到负权重环（如果没有则返回 <code>null</code>）</td></tr>\n</table>\n\n<p>实现这些方法并不困难，如 442 页的代码所示。在 <code>BellmanFordSP</code> 的构造函数运行之后，命题 Y 说明在将所有边放松 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" inline-img=\"true\" /> 轮之后当且仅当队列非空时有向图中才存在从起点可达的负权重环。如果是这样，<code>edgeTo[]</code> 数组所表示的子图中必然含有这个负权重环。因此，要实现 <code>negativeCycle()</code>，会根据 <code>edgeTo[]</code> 中的边构造一幅加权有向图并在该图中检测环。我们会使用并修改 4.2 节中的 <code>DirectedCycle</code> 类来在加权有向图中寻找环（请见练习 4.4.12）。这种检查的成本分为以下几个部分。</p>\n<ul>\n<li>添加一个变量 <code>cycle</code> 和一个私有函数 <code>findNegativeCycle()</code>。如果找到负权重环，该方法会将 <code>cycle</code> 的值设为含有环中所有边的一个迭代器（如果没有找到则设为 <code>null</code>）。</li>\n<li>每调用 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" /> 次 <code>relax()</code> 方法后即调用 <code>findNegativeCycle()</code> 方法。</li>\n</ul>\n<p>这种方法能够保证构造函数中的循环必然会终止。另外，用例可以调用 <code>hasNegativeCycle()</code> 来判断是否存在从起点可达的负权重环（并用 <code>negativeCycle()</code> 来获取这个环）。要在任意有向图中检测负权重环的存在只需稍作扩展即可（请见练习 4.4.43）。</p>\n<p>图 4.4.25 是 Bellman-Ford 算法在一幅含有负权重环的有向图中的运行轨迹。头两轮放松操作与处理 tinyEWDn. txt 时是一样的。在第三轮中，算法在放松了边 <code>7</code> → <code>3</code> 和 <code>5</code> → <code>1</code> 并将顶点 <code>3</code> 和 <code>1</code> 加入队列后开始放松负权重边 <code>5</code> → <code>4</code>。在这次放松操作中算法发现了一个负权重环 <code>4</code> → <code>5</code> → <code>4</code>。它将 <code>5</code> → <code>4</code> 加入最短路径树中并在 <code>edgeTo[]</code> 中将环和起点隔离开来。从这时开始，算法沿着环继续运行并会减少到达所遇到的所有顶点的距离，直至检测到环的存在，此时队列非空。环被保存在 <code>edgeTo[]</code> 中，<code>findNegativeCycle()</code> 会在其中找到它。</p>\n<pre class=\"code-rows\"><code>private void findNegativeCycle()\n{\n   int V = edgeTo.length;\n   EdgeWeightedDigraph spt;\n   spt = new EdgeWeightedDigraph(V);\n   for (int v = 0; v &lt; V; v++)\n      if (edgeTo[v] != null)\n         spt.addEdge(edgeTo[v]);\n\n   EdgeWeightedCycleFinder cf;\n   cf = new EdgeWeightedDirectedCycle(spt);\n\n   cycle = cf.cycle();\n}\n\npublic boolean hasNegativeCycle()\n{  return cycle != null;  }\n\npublic Iterable&lt;DirectedEdge&gt; negativeCycle()\n{  return cycle;  }</code></pre>\n<p style=\"text-align: center\">Bellman-Ford 算法的负权重环检测方法</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01614.jpeg\" alt=\"\" width=\"93%\" style=\"width: 93%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.4.25　Bellman-Ford 算法的轨迹（含有负权重环的图）</strong></p>\n<h4>4.4.6.9　套汇</h4>\n<p>假设有一个基于商品贸易的金融交易市场。以下框注显示的是示例文件 rates.txt 的内容，你可以在任意货币兑换比例的表格中找到类似的内容。文件的第一行是货币的种类数 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" inline-img=\"true\" />，接下来的每一行都对应一种货币，开头是该货币的名称，紧接着是它和其他货币兑换的汇率。简单起见，这个例子中只包含了能够在现代市场中进行交易的数百种货币中的五种：美元（USD）、欧元（EUR）、英镑（GBP）、瑞士法郎（CHF）和加元（CAD）。第 <code>s</code> 行的第 <code>t</code> 个数字表示一个汇率，即购买一个单位的第 <code>s</code> 行的货币需要多少个单位的第 <code>t</code> 行的货币。例如，这张表告诉我们，1000 美元能够购买 741 欧元。这张表格等价于一幅<strong>完全的加权有向图</strong>，顶点对应着货币，边则对应着汇率。权重为 <code>x</code> 的边 <code>s</code> → <code>t</code> 表示从货币 <code>s</code> 到货币 <code>t</code> 的汇率为 <code>x</code>。这张图中的路径则表示多次兑换。例如，将权重为 <code>y</code> 的边 <code>t</code> → <code>u</code> 和刚才的边结合起来就得到了一条路径 <code>s</code> → <code>t</code> → <code>u</code>，即一个单位的货币 <code>s</code> 可以兑换为 <code>xy</code> 个单位的货币 <code>u</code>。比如，欧元可以兑换得到 1012.206=741*1.366 加元。注意，这比直接用美元兑换的汇率更高。你可能会以为 <code>xy</code> 总是应该等于边 <code>s</code> → <code>u</code> 的权重，但这张表格所表示的金融系统非常复杂，并不总是能够保证这种一致性。因此，找到所有从 <code>s</code> 到 <code>u</code> 的路径中所有边的权重之积最大者就是我们最感兴趣的问题。一种更有趣的情况是，所有边的权重之积<strong>小于</strong>从终点指向起点的边的权重。在这个示例中，假设边 <code>u</code> → <code>s</code> 的权重为 <code>z</code> 且 <code>xyz&gt;1</code>。那么环 <code>s</code> → <code>t</code> → <code>u</code> → <code>s</code> 就能够用一个单位的货币 <code>s</code> 得到多于一个单位 <code>(xyz)</code> 的货币 <code>s</code>。换句话说，将货币 <code>s</code> 兑换为 <code>t</code>、<code>u</code> 并最后再兑换为 <code>s</code> 就可以得到 <code>100(xyz-1)</code> 的利润。例如，如果将 1012.206 加元重新兑换为美元，可以得到 1012.206*0.995=1007.14497 美元，也就是得到了 7.14497 美元的利润。这看起来似乎不多，但一个外汇交易商可能会用一百万美元并在每分钟都进行一遍这样的交易，也就是说他每分钟的利润将超过 7000 美元，或者说每小时的利润超过 420 000 美元！这就是套汇交易的一个例子，请见图 4.4.26。如果没有外力的限制，比如手续费或是交易金额上限，交易商可以从其中获取无限的利润。即使是在现实世界中的这些限制下，套汇的利润仍然是非常高的。这个问题和最短路径问题有什么关系呢？要回答这个问题非常简单。</p>\n<pre class=\"code-rows\"><code>% more rates.txt\n5\nUSD  1      0.741  0.657  1.061  1.005\nEUR  1.349  1      0.888  1.433  1.366\nGBP  1.521  1.126  1      1.614  1.538\nCHF  0.942  0.698  0.619  1      0.953\nCAD  0.995  0.732  0.650  1.049  1</code></pre>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01615.gif\" alt=\"\" width=\"60%\" style=\"width: 60%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.4.26　一次套汇机会</strong></p>\n<blockquote>\n<p><strong>命题 Z</strong>。套汇问题等价于加权有向图中的负权重环的检测问题。</p>\n<p><strong>证明</strong>。取每条边权重的自然对数并取反，这样在原始问题中所有边的权重之积的计算就转化为了新图中所有边的权重之和的计算。任意权重之积 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01616.gif\" alt=\"w_1w_2\\cdots w_k\" inline-img=\"true\" /> 即对应 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01617.gif\" alt=\"-\\ln(w_1)-\\ln(w_2)-\\cdots-\\ln(w_k)\" inline-img=\"true\" /> 之和。转换后边的权重可能为正也可能为负。一条从 <code>v</code> 到 <code>w</code> 的路径表示将货币 <code>v</code> 兑换为货币 <code>w</code>，图中的任意负权重环都是一次套汇的好机会（请见图 4.4.27）。</p>\n</blockquote>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01618.gif\" alt=\"\" width=\"65%\" style=\"width: 65%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 4.4.27　一个负权重环就表示了一次套汇的机会</strong></p>\n<p>在这个示例中，货币可以任意兑换，因此有向图是完全的，任意负权重环都是从任意顶点可达的。在一般的商品交易中，有些边可能并不存在，因此需要练习 4.4.43 所述的只有一个参数的构造函数。目前没有已知的寻找<strong>最佳</strong>套汇机会（图中负权重最小的环）的高效算法（图的规模不需要很大就能使所需的计算量超过计算机的承受能力），但找出<strong>任意</strong>套汇机会的最快算法仍然是很重要的——在第二快的算法找到任何套汇机会之前，使用这种算法的商人很可能已经可以系统地排除许多不佳的套汇机会了。</p>\n<blockquote>\n<p><strong>货币兑换中的套汇</strong></p>\n<pre class=\"code-rows\"><code>public class Arbitrage\n{\n   public static void main(String[] args)\n   {\n      int V = StdIn.readInt();\n      String[] name = new String[V];\n      EdgeWeightedDigraph G = new EdgeWeightedDigraph(V);\n      for (int v = 0; v &lt; V; v++)\n      {\n         name[v] = StdIn.readString();\n         for (int w = 0; w &lt; V; w++)\n         {\n            double rate = StdIn.readDouble();\n            DirectedEdge e = new DirectedEdge(v, w, -Math.log(rate));\n            G.addEdge(e);\n         }\n      }\n\n      BellmanFordSP spt = new BellmanFordSP(G, 0);\n      if (spt.hasNegativeCycle())\n      {\n         double stake = 1000.0;\n         for (DirectedEdge e : spt.negativeCycle())\n         {\n            StdOut.printf(\"%10.5f %s\", stake, name[e.from()]);\n\n            stake *= Math.exp(-e.weight());\n            StdOut.printf(\"= %10.5f %s\\n\", stake, name[e.to()]);\n         }\n      }\n      else StdOut.println(\"No arbitrage opportunity\");\n   }\n}</code></pre>\n<p>这段代码调用了 <code>BellmanFordSP</code> 类来寻找汇率表中的套汇机会。它首先使用完全有向图表示汇率表，然后用 Bellman-Ford 算法来寻找图中的负权重环。</p>\n<pre class=\"code-rows\"><code>% java Arbitrage &lt; rates.txt\n1000.00000 USD =  741.00000 EUR\n 741.00000 EUR = 1012.20600 CAD\n1012.20600 CAD = 1007.14497 USD</code></pre>\n</blockquote>\n<p>命题 Z 的证明即使在没有套汇机会的情况下仍然有用，因为它将货币兑换问题转化为了一个最短路径问题。因为对数函数是单调的（且会对计算的结果取反），当边的权重之和最小时汇率之积正好最大。尽管边的权重可正可负，从 <code>v</code> 到 <code>w</code> 的最短路径仍然是将货币 <code>v</code> 兑换为货币 <code>w</code> 的最好方法。</p>\n<h3 id=\"nav_point_211\">4.4.7　展望</h3>\n<p>表 4.4.9 总结了本节中我们所学习到的各种最短路径算法的重要性质。在这些算法中进行选择的第一个条件是问题所涉及的有向图的基本性质。它含有负权重的边吗？它含有环吗？它含有负权重的环吗？除了这些基本性质之外，加权有向图的特性多种多样，因此在有多个合适的选择时就需要通过实验找出最佳的算法。</p>\n<p><strong>表 4.4.9　最短路径算法的性能特点</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><th rowspan=\"2\">算法</th><th rowspan=\"2\">局限</th><th colspan=\"2\">路径长度的比较次数（增长的数量级）</th><th rowspan=\"2\">所需空间</th><th rowspan=\"2\">优势</th></tr>\n<tr><th>一般情况</th><th>最坏情况</th></tr>\n<tr><td>Dijkstra 算法（即时版本）</td><td>边的权重必须为正</td><td><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01568.gif\" /></td><td><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01568.gif\" /></td><td><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" /></td><td>最坏情况下仍有较好的性能</td></tr>\n<tr><td>拓扑排序</td><td>只适用于无环加权有向图</td><td><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01488.gif\" /></td><td><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01488.gif\" /></td><td><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" /></td><td>是无环图中的最优算法</td></tr>\n<tr><td>Bellman-Ford 算法（基于队列）</td><td>不能存在负权重环</td><td><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01488.gif\" /></td><td><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01608.gif\" /></td><td><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" /></td><td>适用领域广泛</td></tr>\n</table>\n\n<p><strong>历史资料</strong></p>\n<p>自 20 世纪 50 年代以来，最短路径算法就已经被深入地研究并被广泛应用了。计算最短路径的 Dijkstra 算法的历史和计算最小生成树的 Prim 算法的历史背景相似（并且也相关）。<strong>Dijkstra 算法</strong>既指的是按照顶点距离起点的远近顺序构造最短路径树的算法，也指的是该算法的实现，（它也是最适合用邻接矩阵表示的算法。），因为 Dijkstra 在 1959 年的一篇论文中发表了上述观点（并且证明了这种方法同样也可以用来计算最小生成树）。稀疏图算法的性能改进来自于之后对优先队列实现的改进，不仅仅针对最短路径问题。这其中最重要的是 Dijkstra 算法性能的改进。（例如，使用<strong>斐波那契堆</strong>后最坏情况下的复杂度可以减少到 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01576.gif\" alt=\"E+V \\log V\" inline-img=\"true\" />）。实践证明 Bellman-Ford 算法十分有效并且应用领域广泛，特别是处理一般性的加权有向图。Bellman-Ford 算法计算普通应用的运行时间常常是线性的，在最坏情况下它的运行时间是 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01608.gif\" alt=\"VE\" inline-img=\"true\" />。最坏情况下的运行时间为线性级别的稀疏图的最短路径算法是一个仍在研究之中的问题。Bellman-Ford 算法最早由 L.Ford 和 R.Bellman 发表于 20 世纪 50 年代。尽管我们已经看到许多其他的图算法性能得到了大幅改进，但是处理含有负权重边（但不含负权重环）的且在最坏情况下性能更好的有向图算法还没有出现。</p>\n<h3 id=\"nav_point_212\">答疑</h3>\n<p><strong>问</strong>　为什么要分别为无向图、有向图、加权无向图、加权有向图定义不同的数据类型？</p>\n<p><strong>答</strong>　这么做是为了使用例代码更清晰，同时也是为了更加简洁和高效地实现没有权重的图。在需要处理各种图的应用或系统中，软件工程中的标准做法就是先定义一种抽象数据结构并根据它衍生出其他抽象数据结构，也就是 4.1 节中学习的无向图 <code>Graph</code>，4.2 节中学习的有向图 <code>Digraph</code>，4.3 节中学习的加权无向图 <code>EdgeWeightedGraph</code>，或是在本节中学习的加权有向图 <code>EdgeWeightedDigraph</code>。</p>\n<p><strong>问</strong>　如何在（加权）无向图中找到最短路径？</p>\n<p><strong>答</strong>　对于边的权重均为正的图，Dijkstra 算法可以解决这个问题。只需根据给定的 <code>EdgeWeightedGraph</code> 构造一幅 <code>EdgeWeightedDigraph</code>（无向图中的每条边都对应着有向图中的两条方向不同的边）并执行 Dijkstra 算法即可。如果边的权重可能为负，高效的算法也是存在的，但它们比 Bellman-Ford 算法更复杂。</p>\n<h3 id=\"nav_point_213\">练习</h3>\n<p><strong>4.4.1</strong>　真假判断：将每条边的权重都加上一个常数不会改变单点最短路径问题的答案。</p>\n<p><strong>4.4.2</strong>　为 <code>EdgeWeightedDigraph</code> 类实现 <code>toString()</code> 方法。</p>\n<p><strong>4.4.3</strong>　为稠密图实现一种使用邻接矩阵表示法（用二维数组保存边的权重，请参考练习 4.3.10）的 <code>EdgeWeightedDigraph</code> 类。忽略平行边。</p>\n<p><strong>4.4.4</strong>　在 tinyEWD.txt 中（请见图 4.4.4）删去顶点 <code>7</code>。画出加权有向图中以顶点 <code>0</code> 为起点的最短路径树，并使用父链接数组表示这棵树。将图中所有边的方向反转并回答相同的问题。</p>\n<p><strong>4.4.5</strong>　在 tinyEWD.txt 中（请见图 4.4.4）改变边 <code>0</code> → <code>2</code> 的方向。画出该加权有向图中以顶点 2 为起点的两棵不同的最短路径树。</p>\n<p><strong>4.4.6</strong>　给出用即时版本的 Dijkstra 算法计算练习 4.4.5 所定义的图的最短路径树的轨迹。</p>\n<p><strong>4.4.7</strong>　实现 <code>DijkstraSP</code> 的另一个版本，支持一个方法来返回一幅加权有向图中从 <code>s</code> 到 <code>t</code> 的<strong>另一条</strong>最短路径。（如果从 <code>s</code> 到 <code>t</code> 的最短路径只有一条则返回 <code>null</code>。）</p>\n<p><strong>4.4.8</strong>　一幅有向图的<strong>直径</strong>指的是连接任意两个顶点的所有最短路径中的最大长度。编写一个 <code>DijkstraSP</code> 的用例，找出边的权重非负的给定 <code>EdgeWeightedDigraph</code> 图的直径。</p>\n<p><strong>4.4.9</strong>　表 4.4.10 来自于一张很早以前出版的公路地图，它显示的是城市之间的最短路径的长度。这张表中有一个错误。改正这个错误并新建一张表来说明最短路径是哪条。</p>\n<p><strong>4.4.10</strong>　将练习 4.4.4 中定义的有向图中的边看作无向边，即每条边对应加权有向图中的两条方向不同但权重相同的边。为对应的加权有向图回答练习 4.4.6 中的问题。</p>\n<p><strong>4.4.11</strong>　使用 1.4 节中的内存使用模型评估用 <code>EdgeWeightedDigraph</code> 表示一幅含有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" inline-img=\"true\" /> 个顶点和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01481.gif\" alt=\"E\" inline-img=\"true\" /> 条边的图所需的内存。</p>\n<p><strong>4.4.12</strong>　修改 4.2 节中的 <code>DirectedCycle</code> 类和 <code>Topological</code> 类，使之使用本节中的 <code>EdgeWeightedDigraph</code> 类和<code>DirectedEdge</code> 类的API并实现<code>EdgeWeightedCycleFinder</code> 类和<code>EdgeWeightedTopological</code> 类。</p>\n<p><strong>4.4.13</strong>　从 tinyEWD.txt 中（请见图 4.4.4）删去边 <code>5</code> → <code>7</code>，用 Dijkstra 算法计算所得的有向图的最短路径树并按照正文中的样式给出算法的轨迹。</p>\n<p><strong>表　4.4.10</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>&nbsp;</p></th>\n<th><p>普罗维登斯</p></th>\n<th><p>威斯特里</p></th>\n<th><p>新伦敦</p></th>\n<th><p>诺威治</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>普罗维登斯</p></td>\n<td><p>—</p></td>\n<td><p>53</p></td>\n<td><p>54</p></td>\n<td><p>48</p></td>\n</tr>\n<tr>\n<td><p>威斯特里</p></td>\n<td><p>53</p></td>\n<td><p>—</p></td>\n<td><p>18</p></td>\n<td><p>101</p></td>\n</tr>\n<tr>\n<td><p>新伦敦</p></td>\n<td><p>54</p></td>\n<td><p>18</p></td>\n<td><p>—</p></td>\n<td><p>12</p></td>\n</tr>\n<tr>\n<td><p>诺威治</p></td>\n<td><p>48</p></td>\n<td><p>101</p></td>\n<td><p>12</p></td>\n<td><p>—</p></td>\n</tr>\n</tbody>\n</table>\n<p><strong>4.4.14</strong>　给出使用 4.4.6.1 节和 4.4.6.2 节的两种尝试处理图 4.4.19 的 tinyEWDn.txt 所得到的路径。</p>\n<p><strong>4.4.15</strong>　如果从顶点 <code>s</code> 到 <code>v</code> 的路径上存在一个负权重环，调用 Bellman-Ford 算法的 <code>pathTo(v)</code> 方法会发生什么？</p>\n<p><strong>4.4.16</strong>　假设用 <code>EdgeWeightedGraph</code> 中的每条边 <code>Edge</code> 都替换为两条（两个方向各一条）<code>DirectedEdge</code> 的方式将 <code>EdgeWeightedGraph</code> 类转化为 <code>EdgeWeightedDigraph</code> 类（如答疑中关于 Dijkstra 算法的部分所述）然后再使用 Bellman-Ford 算法处理它。说明为什么这种方法大错特错。</p>\n<p><strong>4.4.17</strong>　在 Bellman-Ford 算法中如果一个顶点在同一轮中被两次加入队列会发生什么？</p>\n<p>　<strong>解答</strong>：算法所需的运行时间将会达到指数级。例如，描述一幅边的权重全部为 -1 的加权有向完全图中 Bellman-Ford 算法的执行情况。</p>\n<p><strong>4.4.18</strong>　编写一个 CPM 的用例来打印出所有的关键路径。</p>\n<p><strong>4.4.19</strong>　找出正文中的例子里权重最低的环（即最佳套汇机会）。</p>\n<p><strong>4.4.20</strong>　从网上或者报纸上找到一张汇率表并用它构造一张套汇表。<strong>注意</strong>：不要使用根据若干数据计算得出的汇率表，它们的精度有限。<strong>附加题</strong>：从汇率市场上赚点外快！</p>\n<p><strong>4.4.21</strong>　用 Bellman-Ford 算法计算练习 4.4.5 中的加权有向图的最短路径树并按照正文中的样式给出算法的轨迹。</p>\n<h3 id=\"nav_point_214\">提高题</h3>\n<p><strong>4.4.22</strong>　<strong>顶点的权重</strong>。证明，要得到顶点也有非负权重的加权有向图中的最短路径（路径的权重为路径上的顶点权重之和），可以通过构造一幅只有边含有权重的加权有向图解决。</p>\n<p><strong>4.4.23</strong>　<strong>给定两点的最短路径</strong>。设计并实现一份 API，使用 Dijkstra 算法的改进版本解决加权有向图中<strong>给定两点</strong>的最短路径问题。</p>\n<p><strong>4.4.24</strong>　<strong>多起点最短路径</strong>。设计并实现一份 API，使用 Dijkstra 算法解决加权有向图中的<strong>多起点</strong>最短路径问题，其中边的权重均为正：给定一组起点，找到相应的最短路径森林并实现一个方法为用例返回从任意起点到达每个顶点的最短路径。<strong>提示</strong>：添加一个伪顶点和从该顶点指向每个起点的一条权重为零的边，或者在初始化时将所有起点加入优先队列并将它们在 <code>distTo[]</code> 中对应的值均设为 0。</p>\n<p><strong>4.4.25</strong>　<strong>两个顶点集合之间的最短路径</strong>。给定一幅边的权重均为正的有向图和两个没有交集的顶点集 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01304.gif\" alt=\"S\" inline-img=\"true\" /> 和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00850.gif\" alt=\"T\" inline-img=\"true\" />，找到从 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01304.gif\" alt=\"S\" inline-img=\"true\" /> 中的任意顶点到达 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00850.gif\" alt=\"T\" inline-img=\"true\" /> 中的任意顶点的最短路径。你的算法在最坏情况下所需的时间应该与 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01568.gif\" alt=\"E \\log V\" inline-img=\"true\" /> 成正比。</p>\n<p><strong>4.4.26</strong>　<strong>稠密图中的单点最短路径</strong>。实现另一个版本的 Dijkstra 算法，使之能够在与 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01483.gif\" alt=\"V^2\" inline-img=\"true\" /> 成正比的时间内在一幅稠密的加权有向图中计算出给定顶点的最短路径树。请使用邻接矩阵法表示稠密图（请参考练习 4.4.3 和练习 4.3.29）。</p>\n<p><strong>4.4.27</strong>　<strong>欧几里得图中的最短路径</strong>。已知图中的顶点均在平面上，修改 API 以提高 Dijkstra 算法的性能。</p>\n<p><strong>4.4.28</strong>　<strong>有向无环图中的最长路径</strong>。重新实现 <code>AcyclicLP</code> 类，根据命题 T 解决加权有向无环图中的最长路径问题。</p>\n<p><strong>4.4.29</strong>　<strong>一般最优性</strong>。完成命题 W 的证明，说明如果存在从 <code>s</code> 到 <code>v</code> 的有向路径且从 <code>s</code> 到 <code>v</code> 的任意路径上的所有顶点都不在任意负权重环上，那么必然存在一条从 <code>s</code> 到 <code>v</code> 的最短路径（<strong>提示</strong>：参考命题 P）。</p>\n<p><strong>4.4.30</strong>　<strong>含有负权重环的图中的任意顶点对之间的最短路径</strong>。参考 4.4.4.3 节框注“任意顶点对之间的最短路径”所实现的不含负权重环的图中任意顶点对之间的最短路径问题并设计一份 API。使用 Bellman-Ford 算法的一个变种来确定权重数组 <code>pi[]</code>，使得对于任意边 <code>v</code> → <code>w</code>，边的权重加上 <code>pi[v]</code> 和 <code>pi[w]</code> 之差的和非负。然后更新所有边的权重，使得 Dijkstra 算法可以在新图中找出所有的最短路径。</p>\n<p><strong>4.4.31</strong>　<strong>线图中任意顶点对之间的最短路径</strong>。给定一幅加权线图（无向连通图，除了两个端点度数为 1 之外所有顶点的度数为 2），给出一个算法在线性时间内对图进行预处理并在常数时间内返回任意两个顶点之间的最短路径。</p>\n<p><strong>4.4.32</strong>　<strong>启发式的父结点检查</strong>。修改 Bellman-Ford 算法，仅当顶点 <code>v</code> 在最短路径树中的父结点 <code>edgeTo[v]</code> 目前不在队列中时才访问 <code>v</code>。Cherkassky、Goldberg 和 Radzik 在实践中发现这种启发式的做法十分有帮助。证明这种方法能够正确的计算出最短路径且在最坏情况下的运行时间和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01607.gif\" alt=\"E\" inline-img=\"true\" /> 成正比。</p>\n<p><strong>4.4.33</strong>　<strong>网格图中的最短路径</strong>。给定一个 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00839.gif\" alt=\"N\\times N\" inline-img=\"true\" /> 的正整数矩阵，找到从 <code>(0,0)</code> 到 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01619.gif\" alt=\"(N-1,N-1)\" inline-img=\"true\" /> 的最短路径，路径的长度即为路径中所有正整数之和。在只能向右和向下移动的限制下重新解答这个问题。</p>\n<p><strong>4.4.34</strong>　<strong>单调最短路径</strong>。给定一幅加权有向图，找出从 <code>s</code> 到其他每个顶点的单调最短路径。如果一条路径上的所有边的权重是严格<strong>单调</strong>递增或递减的，那么这条路径就是单调的。这样的路径应该是简单的（不包含重复顶点）。<strong>提示</strong>：按照权重的升序放松所有边并找到一条最佳路径；然后按照权重的降序放松所有边再找到另一条最佳路径。</p>\n<p><strong>4.4.35</strong>　<strong>双调最短路径</strong>。给定一幅有向图，找到从 <code>s</code> 到其他每个顶点的<strong>双调</strong>最短路径（如果存在）。如果从 <code>s</code> 到 <code>t</code> 的路径上存在一个中间顶点 <code>v</code> 使得从 <code>s</code> 到 <code>v</code> 中的所有边的权重均严格单调递增且从 <code>v</code> 到 <code>t</code> 中的所有边的权重均严格单调递减，那么这就是一条双调路径。这样的路径应该是简单的（不包含重复顶点）。</p>\n<p><strong>4.4.36</strong>　<strong>邻居顶点</strong>。编写一个 <code>SP</code> 的用例，找出一幅给定加权有向图中和一个给定顶点的距离在 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01229.gif\" alt=\"d\" inline-img=\"true\" /> 之内的所有顶点。你的算法所需的运行时间应该与由这些顶点和依附于它们的边组成的子图的大小以及 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" inline-img=\"true\" />（用于初始化数据结构）中的较大者成正比。</p>\n<p><strong>4.4.37</strong>　<strong>关键边</strong>。给出一个算法来找到给定的加权有向图中的一条边，删去这条边使得给定的两个顶点之间的最短距离的增加值最大。</p>\n<p><strong>4.4.38</strong>　<strong>敏感度</strong>。给定一幅加权有向图和一对顶点 <code>s</code> 和 <code>t</code>，编写一个 <code>SP</code> 的用例对该图中的所有边进行敏感度分析：计算一个 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01620.gif\" alt=\"V\\times V\" inline-img=\"true\" /> 的布尔矩阵，对于任意的 <code>v</code> 和 <code>w</code>，当 <code>v</code> → <code>w</code> 为加权有向图中的一条边且增加 <code>v</code> → <code>w</code> 的权重不会增加从 <code>s</code> 到 <code>t</code> 的最短路径的权重时，<code>v</code> 行 <code>w</code> 列的值为 <code>true</code>，否则为 <code>false</code>。</p>\n<p><strong>4.4.39</strong>　<strong>延时 Dijkstra 算法的实现</strong>。根据正文实现 Dijkstra 算法的延时版本。</p>\n<p><strong>4.4.40</strong>　<strong>瓶颈最短路径树</strong>。请证明一幅无向图中的一棵最小生成树等价于该图中的一棵瓶颈最短路径树：对于任意一对顶点 <code>v</code> 和 <code>w</code>，该树都含有一条连接它们的路径且其中的最长边是所有连接两点的路径中最短的。</p>\n<p><strong>4.4.41</strong>　<strong>双向搜索</strong>。基于算法 4.9 的代码为给定两点的最短路径问题实现一个类，但在初始化时将起点和终点都加入优先队列。这么做会使最短路径树从两个顶点同时开始生长，你的主要任务是决定两棵树相遇时应该怎么办。</p>\n<p><strong>4.4.42</strong>　<strong>最坏情况（Dijkstra 算法）</strong>。找出含有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" inline-img=\"true\" /> 个顶点和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01481.gif\" alt=\"E\" inline-img=\"true\" /> 条边的一组图，使得 Dijkstra 算法处理它们所需的运行时间为最坏情况。</p>\n<p><strong>4.4.43</strong>　<strong>负权重环的检测</strong>。假设为算法 4.11 加入了一个构造函数，它和已有的构造函数的区别仅在于不需要第二个参数并将 <code>distTo[]</code> 中的所有元素初始化为 0。证明，如果用例调用的是这个构造函数，那么当且仅当图中含有一个负权重环时，<code>hasNegativeCycle()</code> 才会返回 <code>true</code>。（<code>negativeCycle()</code> 会返回那个负权重环。）</p>\n<p>　<strong>解答</strong>：向原图添加一个新的起点以及从该起点指向所有其他顶点的权重为 0 的边。在一轮放松之后，<code>distTo[]</code> 中的所有元素的值均会变为 0，从新起点开始寻找一个负权重环和在原图中寻找负权重环是等价的。</p>\n<p><strong>4.4.44</strong>　<strong>最坏情况（Bellman-Ford 算法）</strong>。找出一组图，使得算法 4.11 的运行时间与 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01608.gif\" alt=\"VE\" inline-img=\"true\" /> 成正比。</p>\n<p><strong>4.4.45</strong>　<strong>快速 Bellman-Ford 算法</strong>。对于边的权重为整数且绝对值不大于某个常数的特殊情况，给出一个解决一般的加权有向图中的单点最短路径问题的算法，其所需的运行时间低于线性对数级别。</p>\n<p><strong>4.4.46</strong>　<strong>动画</strong>。编写一段程序将 Dijkstra 算法用动画表现出来。</p>\n<h3 id=\"nav_point_215\">实验题</h3>\n<p><strong>4.4.47</strong>　<strong>随机加权有向稀疏图</strong>。修改你为练习 4.3.34 给出的解答，随机指定每条边的方向。</p>\n<p><strong>4.4.48</strong>　<strong>随机加权有向欧几里得图</strong>。修改你为练习 4.3.35 给出的解答，随机指定每条边的方向。</p>\n<p><strong>4.4.49</strong>　<strong>随机加权有向网格图</strong>。修改你为练习 4.3.36 给出的解答，随机指定每条边的方向。</p>\n<p><strong>4.4.50</strong>　<strong>负权重边 I</strong>。修改你的随机加权有向图生成器，通过调整比例将边的权重控制在在 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00818.gif\" alt=\"x\" inline-img=\"true\" /> 和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00820.gif\" alt=\"y\" inline-img=\"true\" /> 之间（<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00818.gif\" alt=\"x\" inline-img=\"true\" /> 和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00820.gif\" alt=\"y\" inline-img=\"true\" /> 都在 -1 和 1 之间）。</p>\n<p><strong>4.4.51</strong>　<strong>负权重边 II</strong>。修改你的随机加权有向图生成器，将固定比例（此值由用例指定）的边的权重取反来生成负权重的边。</p>\n<p><strong>4.4.52</strong>　<strong>负权重边 III</strong>。编写一段程序，调用你的加权有向图生成器，尽可能为大范围的 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01469.gif\" alt=\"V\" inline-img=\"true\" /> 和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01481.gif\" alt=\"E\" inline-img=\"true\" /> 值生成多幅加权有向图，保证图中大部分边的权重为负且只有若干个负权重环。</p>\n<blockquote>\n<p>测试所有的算法并研究所有图的模型的所有参数是不现实的。请为下面的每一道题都编写一段程序来处理从输入得到的任意图。这段程序可以调用上面的任意生成器并对相应的图模型进行实验。你可以根据上次实验的结果自己作出判断来选择不同实验。陈述结果以及由此得出的任何结论。</p>\n</blockquote>\n<p><strong>4.4.53</strong>　<strong>预测</strong>。请估计你的计算机和程序系统使用 Dijkstra 算法在 10 秒钟之内能够计算出图中所有的最短路径的图的最大规模，其中 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01621.gif\" alt=\"E=10V\" inline-img=\"true\" />，误差在 10 倍以内。</p>\n<p><strong>4.4.54</strong>　<strong>延时的代价</strong>。对于各种图的模型，运行实验并根据经验比较 Dijkstra 算法的延时版本和即时版本的性能差异。</p>\n<p><strong>4.4.55</strong>　<strong>Johnson 算法</strong>。使用一个 <code>d</code> 向堆实现优先队列。对于各种加权有向图的模型，找到 <code>d</code> 的最优值。</p>\n<p><strong>4.4.56</strong>　<strong>套汇模型</strong>。实现一个模型来生成随机的套汇问题。目标是尽量生成与练习 4.4.20 中相似表格。</p>\n<p><strong>4.4.57</strong>　<strong>最后期限限制下的并行任务调度模型</strong>。实现一个模型来生成随机的最后期限限制下的并行任务调度问题。目标是尽量生成复杂但可以解决的问题。</p>\n\n<br style=\"page-break-after:always\" /><div style=\"page-break-after:always\"></div><h1 id=\"nav_point_216\">第 5 章　字符串</h1>\n<p>我们通过交流成串的字符进行沟通，所以无数的重要而熟悉的应用软件都是基于字符串处理的。本章中，我们会考察一些经典算法，解决以下应用领域背后的计算问题。</p>\n<p><strong>信息处理</strong>。当你根据一个给定的关键字搜索网页时，就是在使用一个字符串处理应用程序。在现代世界中，可以说<strong>所有的</strong>信息都是用一系列字符串表示的，而对它们进行处理的都是非常重要的字符串处理应用程序。</p>\n<p><strong>基因组学</strong>。计算生物学家的一项工作就是根据<strong>密码子</strong>将 DNA 转换为由 4 个碱基（<code>A</code>、<code>C</code>、<code>T</code> 和 <code>G</code>）组成的（非常长的）字符串。近些年来人类构建起来的庞大的基因数据库已经能够描述各种活体器官，因此字符串处理已经成为了现在计算生物学研究的基石。</p>\n<p><strong>通信系统</strong>。无论你是在发送短信、电子邮件或是下载电子书，都是在将字符串从一个地方传送到另一个地方。以此为目标的字符串处理应用程序是字符串处理算法开发的源动力。</p>\n<p><strong>编程系统</strong>。程序是由字符串组成的。编译器、解释器等其他能够将程序转换为机器指令的软件都是使用复杂的字符串处理技术的重要应用软件。事实上，所有的书面语言都是由字符串表达的。另外，开发字符串处理算法的另一个动力来源在于形式语言理论，它研究的是对不同类型的字符串集合的描述。</p>\n<p>这几个非常有意义的示例说明了字符串处理算法的重要性和应用领域的多样性。</p>\n<p>本章的结构如下：在介绍了字符串的基本性质以后，我们会在 5.1 节和 5.2 节中再次遇到第 2 章和第 3 章学过的排序和查找 API。当使用字符串作为键时，能够利用键的特殊性质的算法将比之前学习过的算法更快更灵活。在 5.3 节中，我们会学习<strong>子字符串查找</strong>算法，包括由 Knuth、Morris 和 Pratt 发明的一个著名的算法。在 5.4 节中会介绍<strong>正则表达式</strong>，它是<strong>模式匹配</strong>问题的基础，是一个一般化了的子字符串查找问题，也是搜索工具 grep 的核心。这些经典的算法的基础是两个基本概念，分别叫做<strong>形式语言</strong>和<strong>确定有限状态自动机</strong>。5.5 节主要介绍了一个重要应用：<strong>数据压缩</strong>，即尝试将一个字符串的长度缩短到最小程度。</p>\n","neighbors":{"left":{"article_title":"4.3 最小生成树","id":740948},"right":{"article_title":"5.0.1 游戏规则","id":740950}},"comments":[]}