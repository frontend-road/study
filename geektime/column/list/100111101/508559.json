{"id":508559,"title":"04 | 如何降低认知负载：活的文档能救命","content":"<p>你好，我是姚琪琳。</p><p>在第三节课，我带你了解了认知心理学中的一个概念——认知负载。这个看似与软件开发毫无瓜葛的知识，实际上却决定了软件系统的成败。因此在遗留系统现代化中，我们把“以降低认知负载为前提”作为首要原则。</p><p>有些同学这时就会问了，你总说认知负载如何如何，降低认知负载又是多么重要，那怎么才能真正降低认知负载呢？别着急，我们今天就来看看有哪些方法能降低认知负载。其中最重要的工具，就是活文档。</p><h2>什么是活文档</h2><p>活文档（living document），顾名思义，就是指活着的文档，也就是<strong>在持续编辑和更新的文档，有时候也叫长青文档或动态文档。</strong>比如维基百科中的一个词条，随时都有人更新和维护，这就是一个活文档。与之相对的是静态文档，也就是一旦产生就不会更新的文档，比如大英百科全书中的一个条目。</p><p>你可以想象一下，在软件开发过程中，无论是瀑布模式还是敏捷，我们拿到的需求文档或故事卡是“维基百科”还是“大英百科”呢？我想大多数情况可能是，在最终需求还没有敲定时还是“维基百科”，也就是还会随时更新，而一旦敲定开始开发后，就变成了“大英百科”，再也不会更新了吧。</p><p>然而随着需求的不断叠加，“大英百科”作为当时系统的一个“快照”，早就已经失去了时效性。只有将不同时段、不同模块的文档片段合并在一起，才能得到当前系统的快照。但这个合并放在现实中是很难操作的。</p><!-- [[[read_end]]] --><p>正是因为发现了这样的问题，《实例化需求》一书的作者Gojko Adzic将活文档的概念引入到了软件开发当中；而去年出版的《活文档——与代码共同演进》一书，又在此基础上对活文档如何落地做了系统指导。我强烈建议你读一下这两本书，虽然它们的出版相隔近10年，但讲述的内容却一样非常有帮助。</p><p><img src=\"https://static001.geekbang.org/resource/image/bf/3f/bff365a6ea8e9f2207acdb03cd25123f.jpg?wh=1920x1168\" alt=\"图片\"></p><h2>如何用活文档挖掘业务知识</h2><p>了解了活文档的概念，我们来看一下它是如何降低遗留系统的认知负载的。</p><h3>为遗留代码添加注解</h3><p>先来看看下面这段虚构的遗留代码（抱歉我实在编不出更糟糕的代码了……），在没有任何文档的情况下，我们如何理解这段代码的意思呢？</p><pre><code class=\"language-java\">public class EmployeeService {\n  public void createEmployee(long employeeId) { /*...*/ }\n  public void updateEmployee(long employeeId) { /*...*/ }\n  public void deleteEmployee(long employeeId) { /*...*/ }\n  public EmployeeDto queryEmployee(long employeeId) { /*...*/ }\n  public void assignWork(long employeeId, long ticketId) {\n    // 获取员工\n    EmployeeDao employeeDao = new EmployeeDao();\n    EmployeeModel employee = employeeDao.getEmployeeById(employeeId);\n    if (employee == null) {\n      throw new RuntimeException(\"员工不存在\");\n    }\n    // 获取工单\n    WorkTicketDao workTicketDao = new EmployeeDao();\n    WorkTicketModel workTicket = workTicketDao.getWorkTicketById(ticketId);\n    if (workTicket == null) {\n      throw new RuntimeException(\"工单不存在\");\n    }\n\n    // 校验是否可以将员工分配到工单上\n    if ((employee.getEmployeeType() != 6 &amp;&amp; employee.getEmployeeStatus() == 3)\n          || (employee.getEmployeeType() == 5 &amp;&amp; workTicket.getTicketType() == \"2\")) {\n      throw new RuntimeException(\"员工类型与工单不匹配，不能将员工分配到工单上\");\n    }\n\n    if (!isWorkTicketLocked(workTicket)) {\n      if (!isWorkTicketInitialized(workTicket)) {\n        throw new RuntimeException(\"工单尚未初始化\");\n      }\n    }\n    \n    // ...\n  }\n\n  public void cancelWork(long employeeId, long ticketId) { /*...*/ }\n}\n</code></pre><p>如果每个方法都很长，这样一个类就会愈发不可读，从中理解业务知识的难度也越来越大，这就是我们上节课提到的认知负载过高。</p><p>如果把这种代码转化为下面的脑图，是不是一下子就清晰许多了呢？</p><p><img src=\"https://static001.geekbang.org/resource/image/7f/c0/7f5908e2cef28e5063d855207648f4c0.jpg?wh=1920x1371\" alt=\"图片\"></p><p>阅读代码时，我们是以线性的方式逐行阅读的，这样的信息进入大脑后，就会处理成上面这样的树状信息，方便理解和记忆。但当代码过于复杂的时候，这个处理过程就会需要更多的脑力劳动，导致过高的认知负载。</p><p>我们可以通过在代码中加入活文档的方式，来降低认知负载。其实要得到上面的脑图，只需要在代码中加入一些简单的注解：</p><pre><code class=\"language-java\">@Chapter(\"员工服务\")\npublic class EmployeeService {\n  @Doc(\"员工创建\")\n  public void createEmployee(long employeeId) { /*...*/ }\n  @Doc(\"员工修改\")\n  public void updateEmployee(long employeeId) { /*...*/ }\n  @Doc(\"员工删除\")\n  public void deleteEmployee(long employeeId) { /*...*/ }\n  @Doc(\"获取员工信息\")\n  public EmployeeDto queryEmployee(long employeeId) { /*...*/ }\n  @Doc(\"给员工分配工单\")\n  public void assignWork(long employeeId, long ticketId) { /*...*/}\n  @Doc(\"撤销工单分配\")\n  public void cancelWork(long employeeId, long ticketId) { /*...*/ }\n}\n</code></pre><p>然后，我们编写一个工具，它可以基于这些注解来生成根节点和二级节点，并将方法中抛出的异常作为叶子节点。</p><p>这么做的原因是，虽然遗留系统中的很多文档和代码注释已经不是最新的了，但这些异常信息往往会直接抛出去展示给用户看，是为数不多的、可以从代码中直接提取的有效信息。</p><p>当然这样做也有一定局限性，因为异常信息中可能包含一些运行时数据。比如“ID为12345的员工不存在”这样的异常信息，是由“ID为 + employeeId + 的员工不存在”这样的字符串拼接而成，静态扫描字节码，是无法得出这些运行时数据的。但即使只在叶子节点中显示“ID为 %s 的员工不存在”这样的信息，也已经非常有用了。</p><p>通过这样的工具，我们可以把一个非常复杂的业务代码，转化为下面这样的脑图（为了过滤掉敏感信息，我故意将图片做了模糊处理）。</p><p><img src=\"https://static001.geekbang.org/resource/image/3f/28/3fa116f8091ed99234edc4f2ef21bb28.jpg?wh=574x506\" alt=\"图片\"></p><p>这段业务代码总共有5000多行，一行一行地去阅读代码会让人抓狂，但有了这样的脑图，认知负载简直降低了一个数量级。</p><p>看到这里，你一定对这个工具十分感兴趣了。但是很遗憾，这个自研的工具目前还没有开源。一旦开源，我将在专栏写一篇加餐，详细介绍这个可以解救你于水火的工具。</p><p>不过它的原理其实十分简单，想必你也已经猜到了，就是扫描Java字节码，获取到用注解标记的代码，然后再进一步分析得到异常信息，组织成树形结构，再生成一些中间文档，并通过一些绘图引擎绘制出来。</p><p>在实际操作过程中，只需要有一个人通读一次代码，哪怕花上几个礼拜的时间，但只要能理出一个业务模块的基本逻辑，添加上注解，就可以通过图形化的方式来展示代码结构。其他人不需要再次这么痛苦地阅读代码了，可谓一劳永逸，效率会大大提升。</p><p>这么做还有一个好处是，当新的需求来临时，开发人员可以迅速定位到要修改的地方，不需要再去扒一遍代码了。传统的代码和文档最大的问题是，代码是代码，文档是文档，彼此分离。</p><p>代码和文档的关联关系储存在开发人员脑子里，这样认知负载比较高。当开发人员看到一份新的需求文档时，需要搜索一下脑子里的记忆，才能想起来这部分内容是在代码的什么位置。</p><p>然而人脑不是电脑，这种记忆是十分不靠谱的，搜索定位的过程也十分低效。而上面这样的脑图就和代码很好地结合了起来，可以说找到文档，就找到了代码，非常有效地降低了认知负载。</p><p>这么做的第三个好处是有利于团队协作。业务分析师、开发人员、测试人员都可以围绕这样一份文档来讨论需求、设计测试用例。</p><h3>实例化需求最好的工件就是活文档</h3><p>除了在代码中添加注解，并分析代码生成各种可视化的图表之外，用实例化需求的方式编写的测试也是一种活文档。所谓实例化需求，实际上指的是<strong>以现实中的例子来描述需求，而不是抽象的描述</strong>。</p><p>怎么理解呢？在生活中我们会遇到很多文字描述，比如产品说明书、合同文本、法律法规等。这些描述大多数时候都是抽象的，普通人读起来很难理解，甚至引起歧义。如果抽象的说明能够配几个具体的示例，认知负载就会大大降低。软件开发中的需求描述也是如此。</p><p>让我印象非常深刻的是，在刚加入Thoughtworks没几天的时候，曾经跟着BA和其他开发人员找客户对一个关于用户权限的需求，大概是不同的用户在不同的场景下，能看到一个页面中的哪些字段。</p><p>那位BA没有像我之前见过的BA那样，写一大篇文档，而是简单地把界面打印了出来了好几张，每张纸上注明场景，用马克笔把不能看到的字段打个大叉划掉。</p><p>就这样，他用最简单的方式，在5分钟内就快速确认了所有的需求，客户也对这种直观的方式非常满意。这些纸随后就给了我们开发人员，我们根本没必要再去看需求文档了，因为需求已经以如此实例化的方式展示给我们了。</p><p>这就是典型的实例化需求。我们在开发时，可以将这种需求转换为测试，这种以实例化方式描述的测试，也是一种活文档。它们不但很好地展示了业务知识，而且是随代码更新的。</p><p>比如上面的给员工分配工单的例子，按实例化需求的方式，可以写出一系列组织良好的测试，如下所示：</p><pre><code class=\"language-java\">@Test\npublic void should_be_able_to_assign_work_to_an_employee() {}\n@Test\npublic void should_not_assign_work_to_when_employee_not_exist() {}\n@Test\npublic void should_not_assign_work_when_ticket_not_exist() {}\n@Test\npublic void should_not_assign_work_when_employee_type_and_ticket_type_not_match() {}\n@Test\npublic void should_not_assign_work_when_ticket_is_not_initialized() {}\n</code></pre><p>怎么样？是不是一目了然？其实我们就是将需求文档的描述转换成了测试的方法名。</p><p>读到测试，就相当于读到了需求文档；测试通过，就相当于需求完成了。以后如果需求有了变更，只需要同步修改测试的名称即可。这时候，测试是和代码共同演进的，也就是活文档。</p><p>在某些框架下运行上面的测试，还能帮我们去掉中间的下划线，这就更像是文档了。如果愿意，你还可以用中文去写方法名，阅读起来会更友好，尽管我强烈建议不要这样做。我们在后面讲到代码现代化的时候，再来详细讨论单元测试如何编写和组织。</p><p>如果一个遗留系统的每个功能都具有这样的测试，那么业务知识也就不再难以获得了，整个系统的认知负载也没有那么高了。</p><h2>用依赖分析工具展示系统知识</h2><p>工具除了能挖掘业务知识，还能揭示系统知识。我们在<a href=\"https://time.geekbang.org/column/article/507513\">上一节课</a>讲过，遗留系统的两大认知负载，是无处可寻的业务知识和难以获取的系统知识。经过多年的腐化，类与类之间、包与包之间、模块与模块之间、服务与服务之间分别是什么样的依赖关系呢？</p><p>这就好像我们来到一个陌生的城市时，对这个城市的行政区域、大街小巷都不了解。如果我们想从一个地方到另一个地方，应该怎么办呢？最好的办法就是搞一张当地的地图（当然你也可以用地图App），有了地图的指引，就不会迷路了。</p><p>同样，我们可以通过<strong>依赖分析工具</strong>，建立一张遗留系统的地图，这样就可以快速知道一个业务是由哪些模块组成的。市面上存在很多做系统依赖分析的工具，如Backstage、Aplas、Honeycom、Systems、Coca等等。感兴趣的同学可以去了解一下。</p><p><img src=\"https://static001.geekbang.org/resource/image/f3/19/f3dc7f21a847c81fd95dc335751dbc19.jpg?wh=1920x1263\" alt=\"图片\" title=\"图片来自Aplas官网\"></p><p>但我们也会发现，有时这些工具并不能解决我们的全部问题。比如在做系统的数据拆分时，我希望知道一个API调用都访问了哪些表，从而评估工作量。这种定制化的需求很多工具都无法满足，不过不要灰心，发挥我们开发人员优势的时候又到了。没有轮子，我们就造一个出来。</p><p>其实这种根据入口点获取表名的逻辑并不复杂，只需要遍历语法树，把所有执行SQL语句的点都找出来，然后分析它的语句中包含哪些表就可以了。</p><p>对于<strong>存储过程或函数</strong>，我们也可以找到执行它们的点，获得存储过程或函数的名称，然后再根据名称找到对应的SQL文件，再做类似的分析。当然，这要求我们首先要治理好编写在数据库中的存储过程和函数治理，将DDL（Data Definition Language）迁移到代码库中，进行版本化。这样分析工具定位起来才方便。</p><p>对于<strong>复杂的入口方法</strong>，你可能会得到一幅相当大的列表或脑图，它虽然能列出全部内容，但读起来仍然很费劲。这时候我们有两个办法。一是重构复杂的入口方法，抽取出若干小的方法，再以小方法为入口点做分析。二是修改分析工具，直接分析存储过程或函数。如果存储过程或函数过大，也可以进一步拆分。</p><p>除此之外，我们还可以提出很多有用的需求，继续改进分析工具。比如分析不同模块之间所依赖的对方的表有哪些，这对于数据拆分也是非常有帮助的。</p><h2>总结</h2><p>今天我们学习了降低认知负载的一种非常有用的方法：活文档。很多同学可能是第一次听说这个概念，但如果你的项目里用实例化需求的方式去组织单元测试，你其实已经在使用活文档了。</p><p>虽然遗留系统中可能没有太多的测试，但我们仍然可以通过向代码中添加注解的方式来编写活文档，并通过工具来实现图形化展示，将遗留系统中无处可寻的业务知识暴露在你面前。</p><p>除此之外，我们还可以使用依赖分析工具来挖掘系统知识，同样也可以用图形化的方式来帮助我们理清系统内的依赖关系。这对我们开发新需求或推动代码和架构的现代化都非常有帮助。</p><p>能够降低认知负载的方法、工具和实践还有很多，我们后面的课再慢慢介绍吧。</p><p>《活文档》这本书在介绍遗留系统的“文档破产”时，是这样描述遗留系统的，我也想把这段话分享给你：</p><blockquote>\n<p>遗留系统里充满了知识，但通常是加密的，而且我们已经丢失了秘钥。没有测试，我们就无法对遗留系统的预期行为做出清晰的定义。没有一致的结构，我们就必须猜测它是如何设计的、为什么这么设计以及应该如何演进。没有谨慎的命名，我们就必须猜测和推断变量、方法和类的含义，以及每段代码负责的任务。</p>\n</blockquote><p>虽然遗留系统是“文档破产”的，是“加密”的，但是只要我们掌握了活文档这个“破译工具”，就可以一步一步破解出那些隐匿在系统深处的知识。</p><h2>思考题</h2><p>感谢你学完了这节课的内容。我想此刻的你，一定会对课程中提到的活文档工具十分感兴趣。今天的思考题就请你来分享一下，如果是你，会如何设计和开发这样的一个工具呢？</p><p>欢迎你在评论区留下你的观点，我会尽量回复你们的问题。也欢迎你把文章分享你的朋友和同事，让我们一起来降低认知负载。</p>","comments":[{"had_liked":false,"id":345029,"user_name":"Kent","can_delete":false,"product_type":"c1","uid":1222763,"ip_address":"","ucode":"5FC9357F24380D","user_header":"https://static001.geekbang.org/account/avatar/00/12/a8/6b/633cee14.jpg","comment_is_top":false,"comment_ctime":1651948249,"is_pvip":false,"replies":[{"id":125924,"content":"感谢分享","user_name":"作者回复","user_name_real":"编辑","uid":1009237,"ctime":1651997098,"ip_address":"","comment_id":345029,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100111101,"comment_content":"活文档是个好东西\n- 产品文档、技术文档常常是项目在某一个时刻的快照，不一定准确\n- 代码里留下归纳性的注释表明代码意图(函数、控制流)\n- 修改功能、重构结构时，也应当及时更新对应的注释文档\n- 单元测试代码也能表明代码的用途和边界\n- 代码和文档(注释)放在一起，比分开在wiki中要轻松方便\n- 用好代码分析工具能事倍功半（虽然往往没有这种现成的工具[doge]）","like_count":3,"discussions":[{"author":{"id":1009237,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/55/098b3396.jpg","nickname":"姚琪琳","note":"","ucode":"68EB7FFC9B8A6F","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570932,"discussion_content":"感谢分享","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651997098,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342837,"user_name":"killer","can_delete":false,"product_type":"c1","uid":1141036,"ip_address":"","ucode":"22BF63C05CFACE","user_header":"https://static001.geekbang.org/account/avatar/00/11/69/2c/7fcca7d1.jpg","comment_is_top":false,"comment_ctime":1650502923,"is_pvip":false,"replies":[{"id":125238,"content":"Flyway","user_name":"作者回复","user_name_real":"编辑","uid":1009237,"ctime":1650525641,"ip_address":"","comment_id":342837,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100111101,"comment_content":"DDL（Data Definition Language）迁移到代码库中，进行版本化，楼主你们用的什么工具？","like_count":1,"discussions":[{"author":{"id":1009237,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/55/098b3396.jpg","nickname":"姚琪琳","note":"","ucode":"68EB7FFC9B8A6F","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":565707,"discussion_content":"Flyway","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650525641,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343217,"user_name":"Jack_1024","can_delete":false,"product_type":"c1","uid":2690027,"ip_address":"","ucode":"D6B1B5B24F2BEF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/icHMBoxO5zDicEgIOkFsZCsbicMAeaW3zd7e6YjJJKfvwu7Q8E3wtpXojfdClOeCGrPicJ16FBpEMicfpuDiariajibDSg/132","comment_is_top":false,"comment_ctime":1650711487,"is_pvip":false,"replies":[{"id":125354,"content":"目前还没有哦，可以自己开发一个","user_name":"作者回复","user_name_real":"编辑","uid":1009237,"ctime":1650770895,"ip_address":"","comment_id":343217,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100111101,"comment_content":"有木有开源的轮子呀","like_count":0,"discussions":[{"author":{"id":1009237,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/55/098b3396.jpg","nickname":"姚琪琳","note":"","ucode":"68EB7FFC9B8A6F","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":566832,"discussion_content":"目前还没有哦，可以自己开发一个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650770895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342845,"user_name":"西米","can_delete":false,"product_type":"c1","uid":1008363,"ip_address":"","ucode":"17AEDCA32E4986","user_header":"https://static001.geekbang.org/account/avatar/00/0f/62/eb/3e319cad.jpg","comment_is_top":false,"comment_ctime":1650504703,"is_pvip":false,"replies":[{"id":125239,"content":"应该没有线程的，Java的工具其实就是扫描字节码，.NET就扫描IL就可以了，自己可以开发一个","user_name":"作者回复","user_name_real":"编辑","uid":1009237,"ctime":1650525676,"ip_address":"","comment_id":342845,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100111101,"comment_content":"活文档工具 通过注解扫描，.NET 有类似的工具吗？","like_count":0,"discussions":[{"author":{"id":1009237,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/55/098b3396.jpg","nickname":"姚琪琳","note":"","ucode":"68EB7FFC9B8A6F","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":565708,"discussion_content":"应该没有线程的，Java的工具其实就是扫描字节码，.NET就扫描IL就可以了，自己可以开发一个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650525676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342841,"user_name":"killer","can_delete":false,"product_type":"c1","uid":1141036,"ip_address":"","ucode":"22BF63C05CFACE","user_header":"https://static001.geekbang.org/account/avatar/00/11/69/2c/7fcca7d1.jpg","comment_is_top":false,"comment_ctime":1650503516,"is_pvip":false,"replies":[{"id":125240,"content":"感谢分享👍","user_name":"作者回复","user_name_real":"编辑","uid":1009237,"ctime":1650525718,"ip_address":"","comment_id":342841,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100111101,"comment_content":"工具分为两种一种是动态的，一种是静态的\n1、动态的可以利用SKyWalking 全链路追踪等\n2、静态的需要在api，mq，enum加上注解，依赖编译预处理javax.annotation.processing， 提取项目的源信息","like_count":0,"discussions":[{"author":{"id":1009237,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/55/098b3396.jpg","nickname":"姚琪琳","note":"","ucode":"68EB7FFC9B8A6F","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":565709,"discussion_content":"感谢分享👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650525718,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1256026,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2a/5a/da723ac4.jpg","nickname":"小菜鸟","note":"","ucode":"3210C8528E1912","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575937,"discussion_content":"想问下怎么提取方法中有抛异常的信息啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655196961,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342429,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1650259044,"is_pvip":false,"replies":[{"id":125103,"content":"确实对于调用链复杂的遗留系统来说，用工具可视化出来的图表也是相当吓人的，并不能显著降低认知负载，还是要先进行一些局部优化。","user_name":"作者回复","user_name_real":"编辑","uid":1009237,"ctime":1650293301,"ip_address":"","comment_id":342429,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100111101,"comment_content":"之前只知道测试可以作为文档，今天看了老师生成的知识图谱，感觉效果更好。\n\n关于发布&#47;订阅模式（尤其是发出一个消息，多个消费者订阅的场景）有如下问题：\n1、有没有适合这个场景的插件？\n2、SkyWalking 可以看到完整的调用链路（本地方法调用、RPC调用、Redis、MySQL、消息中间件），但是调用链路总体太长（一个Http请求几百个），虽然有图展示出来，但看到后依然惊人崩溃！（我觉得这样的代码还是优先调整代码结构，使其向单一原则、不要和陌生人说话方向发展比较好）\n\n补充：很多链路追踪工具也可以查看调用链路（例如:ZipKin）","like_count":0,"discussions":[{"author":{"id":1009237,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/55/098b3396.jpg","nickname":"姚琪琳","note":"","ucode":"68EB7FFC9B8A6F","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":564655,"discussion_content":"确实对于调用链复杂的遗留系统来说，用工具可视化出来的图表也是相当吓人的，并不能显著降低认知负载，还是要先进行一些局部优化。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1650293301,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351631,"user_name":"静✨","can_delete":false,"product_type":"c1","uid":1658413,"ip_address":"","ucode":"1B33229C206339","user_header":"https://static001.geekbang.org/account/avatar/00/19/4e/2d/06d3f9f5.jpg","comment_is_top":false,"comment_ctime":1658027923,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100111101,"comment_content":"唉…不管是代码还是数据库 老师都做了我想做的事情(感叹自己技术不足\n伟大！期待开源的那天到来","like_count":2},{"had_liked":false,"id":394307,"user_name":"Jaising","can_delete":false,"product_type":"c1","uid":1037630,"ip_address":"安徽","ucode":"F68830B7B90F96","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d5/3e/7f3a9c2b.jpg","comment_is_top":false,"comment_ctime":1726415730,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100111101,"comment_content":"在架构组织与代码组织之上，还有一个业务模型是很难用自动化分析工具生成的，它的稳定与变化才是理解整个系统的关键，可惜的是过去业内很少有人会基于模型开发，基于架构开发，更多的都是基于功能性需求开发甚至是界面开发，这就导致了大量需求与实现不一致的问题。","like_count":0},{"had_liked":false,"id":391420,"user_name":"Geek_6a1185","can_delete":false,"product_type":"c1","uid":2222619,"ip_address":"中国台湾","ucode":"65BD8F49E0F0AB","user_header":"","comment_is_top":false,"comment_ctime":1718211625,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100111101,"comment_content":"请问遗留系统的方法内是依不同的处理情境回传status 或type ..等的数值，在脑图上需要或如何被呈现出来？","like_count":0},{"had_liked":false,"id":382092,"user_name":"_立斌","can_delete":false,"product_type":"c1","uid":1562851,"ip_address":"广东","ucode":"D081ED845C25C2","user_header":"https://static001.geekbang.org/account/avatar/00/17/d8/e3/99f330b8.jpg","comment_is_top":false,"comment_ctime":1696683568,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100111101,"comment_content":"老师你好，针对遗留系统动辄三五千行的方法，估计得重构过后才能变成注解活文档了？因为大量逻辑都写在同一个方法里，并且大部分逻辑并没有抽取方法出来，这种老大难方法应该如何构建活文档呢","like_count":0},{"had_liked":false,"id":343601,"user_name":"子夜枯灯","can_delete":false,"product_type":"c1","uid":1359678,"ip_address":"","ucode":"5D84BFE7832038","user_header":"https://static001.geekbang.org/account/avatar/00/14/bf/3e/cdc36608.jpg","comment_is_top":false,"comment_ctime":1650949066,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100111101,"comment_content":"期待有开源的工具分享","like_count":0}]}