{"id":73503,"title":"38 | 分治算法：谈一谈大规模计算框架MapReduce中的分治思想","content":"<p>MapReduce是Google大数据处理的三驾马车之一，另外两个是GFS和Bigtable。它在倒排索引、PageRank计算、网页分析等搜索引擎相关的技术中都有大量的应用。</p><p>尽管开发一个MapReduce看起来很高深，感觉跟我们遥不可及。实际上，万变不离其宗，它的本质就是我们今天要学的这种算法思想，分治算法。</p><h2>如何理解分治算法？</h2><p>为什么说MapRedue的本质就是分治算法呢？我们先来看，什么是分治算法？</p><p>分治算法（divide and conquer）的核心思想其实就是四个字，分而治之 ，也就是将原问题划分成n个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。</p><p>这个定义看起来有点类似递归的定义。关于分治和递归的区别，我们在排序（下）的时候讲过，<strong>分治算法是一种处理问题的思想，递归是一种编程技巧</strong>。实际上，分治算法一般都比较适合用递归来实现。分治算法的递归实现中，每一层递归都会涉及这样三个操作：</p><ul>\n<li>\n<p>分解：将原问题分解成一系列子问题；</p>\n</li>\n<li>\n<p>解决：递归地求解各个子问题，若子问题足够小，则直接求解；</p>\n</li>\n<li>\n<p>合并：将子问题的结果合并成原问题。</p>\n</li>\n</ul><p>分治算法能解决的问题，一般需要满足下面这几个条件：</p><!-- [[[read_end]]] --><ul>\n<li>\n<p>原问题与分解成的小问题具有相同的模式；</p>\n</li>\n<li>\n<p>原问题分解成的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法跟动态规划的明显区别，等我们讲到动态规划的时候，会详细对比这两种算法；</p>\n</li>\n<li>\n<p>具有分解终止条件，也就是说，当问题足够小时，可以直接求解；</p>\n</li>\n<li>\n<p>可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了。</p>\n</li>\n</ul><h2>分治算法应用举例分析</h2><p>理解分治算法的原理并不难，但是要想灵活应用并不容易。所以，接下来，我会带你用分治算法解决我们在讲排序的时候涉及的一个问题，加深你对分治算法的理解。</p><p>还记得我们在排序算法里讲的数据的有序度、逆序度的概念吗？我当时讲到，我们用有序度来表示一组数据的有序程度，用逆序度表示一组数据的无序程度。</p><p>假设我们有n个数据，我们期望数据从小到大排列，那完全有序的数据的有序度就是n(n-1)/2，逆序度等于0；相反，倒序排列的数据的有序度就是0，逆序度是n(n-1)/2。除了这两种极端情况外，我们通过计算有序对或者逆序对的个数，来表示数据的有序度或逆序度。</p><p><img src=\"https://static001.geekbang.org/resource/image/f4/20/f41fd0a83bc5c5b059f7d02658179120.jpg?wh=1142*318\" alt=\"\"></p><p>我现在的问题是，<strong>如何编程求出一组数据的有序对个数或者逆序对个数呢</strong>？因为有序对个数和逆序对个数的求解方式是类似的，所以你可以只思考逆序对个数的求解方法。</p><p>最笨的方法是，拿每个数字跟它后面的数字比较，看有几个比它小的。我们把比它小的数字个数记作k，通过这样的方式，把每个数字都考察一遍之后，然后对每个数字对应的k值求和，最后得到的总和就是逆序对个数。不过，这样操作的时间复杂度是O(n^2)。那有没有更加高效的处理方法呢？</p><p>我们用分治算法来试试。我们套用分治的思想来求数组A的逆序对个数。我们可以将数组分成前后两半A1和A2，分别计算A1和A2的逆序对个数K1和K2，然后再计算A1与A2之间的逆序对个数K3。那数组A的逆序对个数就等于K1+K2+K3。</p><p>我们前面讲过，使用分治算法其中一个要求是，子问题合并的代价不能太大，否则就起不了降低时间复杂度的效果了。那回到这个问题，如何快速计算出两个子问题A1与A2之间的逆序对个数呢？</p><p>这里就要借助归并排序算法了。你可以先试着想想，如何借助归并排序算法来解决呢？</p><p>归并排序中有一个非常关键的操作，就是将两个有序的小数组，合并成一个有序的数组。实际上，在这个合并的过程中，我们就可以计算这两个小数组的逆序对个数了。每次合并操作，我们都计算逆序对个数，把这些计算出来的逆序对个数求和，就是这个数组的逆序对个数了。</p><p><img src=\"https://static001.geekbang.org/resource/image/e8/32/e835cab502bec3ebebab92381c667532.jpg?wh=1142*816\" alt=\"\"></p><p>尽管我画了张图来解释，但是我个人觉得，对于工程师来说，看代码肯定更好理解一些，所以我们把这个过程翻译成了代码，你可以结合着图和文字描述一起看下。</p><pre><code>private int num = 0; // 全局变量或者成员变量\n\npublic int count(int[] a, int n) {\n  num = 0;\n  mergeSortCounting(a, 0, n-1);\n  return num;\n}\n\nprivate void mergeSortCounting(int[] a, int p, int r) {\n  if (p &gt;= r) return;\n  int q = (p+r)/2;\n  mergeSortCounting(a, p, q);\n  mergeSortCounting(a, q+1, r);\n  merge(a, p, q, r);\n}\n\nprivate void merge(int[] a, int p, int q, int r) {\n  int i = p, j = q+1, k = 0;\n  int[] tmp = new int[r-p+1];\n  while (i&lt;=q &amp;&amp; j&lt;=r) {\n    if (a[i] &lt;= a[j]) {\n      tmp[k++] = a[i++];\n    } else {\n      num += (q-i+1); // 统计p-q之间，比a[j]大的元素个数\n      tmp[k++] = a[j++];\n    }\n  }\n  while (i &lt;= q) { // 处理剩下的\n    tmp[k++] = a[i++];\n  }\n  while (j &lt;= r) { // 处理剩下的\n    tmp[k++] = a[j++];\n  }\n  for (i = 0; i &lt;= r-p; ++i) { // 从tmp拷贝回a\n    a[p+i] = tmp[i];\n  }\n}\n</code></pre><p>有很多同学经常说，某某算法思想如此巧妙，我是怎么也想不到的。实际上，确实是的。有些算法确实非常巧妙，并不是每个人短时间都能想到的。比如这个问题，并不是每个人都能想到可以借助归并排序算法来解决，不夸张地说，如果之前没接触过，绝大部分人都想不到。但是，如果我告诉你可以借助归并排序算法来解决，那你就应该要想到如何改造归并排序，来求解这个问题了，只要你能做到这一点，我觉得就很棒了。</p><p>关于分治算法，我这还有两道比较经典的问题，你可以自己练习一下。</p><ul>\n<li>\n<p>二维平面上有n个点，如何快速计算出两个距离最近的点对？</p>\n</li>\n<li>\n<p>有两个n*n的矩阵A，B，如何快速求解两个矩阵的乘积C=A*B？</p>\n</li>\n</ul><h2>分治思想在海量数据处理中的应用</h2><p>分治算法思想的应用是非常广泛的，并不仅限于指导编程和算法设计。它还经常用在海量数据处理的场景中。我们前面讲的数据结构和算法，大部分都是基于内存存储和单机处理。但是，如果要处理的数据量非常大，没法一次性放到内存中，这个时候，这些数据结构和算法就无法工作了。</p><p>比如，给10GB的订单文件按照金额排序这样一个需求，看似是一个简单的排序问题，但是因为数据量大，有10GB，而我们的机器的内存可能只有2、3GB这样子，无法一次性加载到内存，也就无法通过单纯地使用快排、归并等基础算法来解决了。</p><p>要解决这种数据量大到内存装不下的问题，我们就可以利用分治的思想。我们可以将海量的数据集合根据某种方法，划分为几个小的数据集合，每个小的数据集合单独加载到内存来解决，然后再将小数据集合合并成大数据集合。实际上，利用这种分治的处理思路，不仅仅能克服内存的限制，还能利用多线程或者多机处理，加快处理的速度。</p><p>比如刚刚举的那个例子，给10GB的订单排序，我们就可以先扫描一遍订单，根据订单的金额，将10GB的文件划分为几个金额区间。比如订单金额为1到100元的放到一个小文件，101到200之间的放到另一个文件，以此类推。这样每个小文件都可以单独加载到内存排序，最后将这些有序的小文件合并，就是最终有序的10GB订单数据了。</p><p>如果订单数据存储在类似GFS这样的分布式系统上，当10GB的订单被划分成多个小文件的时候，每个文件可以并行加载到多台机器上处理，最后再将结果合并在一起，这样并行处理的速度也加快了很多。不过，这里有一个点要注意，就是数据的存储与计算所在的机器是同一个或者在网络中靠的很近（比如一个局域网内，数据存取速度很快），否则就会因为数据访问的速度，导致整个处理过程不但不会变快，反而有可能变慢。</p><p>你可能还有印象，这个就是我在讲线性排序的时候举的例子。实际上，在前面已经学习的课程中，我还讲了很多利用分治思想来解决的问题。</p><h2>解答开篇</h2><p>分治算法到此就讲完了，我们现在来看下开篇的问题，为什么说MapReduce的本质就是分治思想？</p><p>我们刚刚举的订单的例子，数据有10GB大小，可能给你的感受还不强烈。那如果我们要处理的数据是1T、10T、100T这样子的，那一台机器处理的效率肯定是非常低的。而对于谷歌搜索引擎来说，网页爬取、清洗、分析、分词、计算权重、倒排索引等等各个环节中，都会面对如此海量的数据（比如网页）。所以，利用集群并行处理显然是大势所趋。</p><p>一台机器过于低效，那我们就把任务拆分到多台机器上来处理。如果拆分之后的小任务之间互不干扰，独立计算，最后再将结果合并。这不就是分治思想吗？</p><p>实际上，MapReduce框架只是一个任务调度器，底层依赖GFS来存储数据，依赖Borg管理机器。它从GFS中拿数据，交给Borg中的机器执行，并且时刻监控机器执行的进度，一旦出现机器宕机、进度卡壳等，就重新从Borg中调度一台机器执行。</p><p>尽管MapReduce的模型非常简单，但是在Google内部应用非常广泛。它除了可以用来处理这种数据与数据之间存在关系的任务，比如MapReduce的经典例子，统计文件中单词出现的频率。除此之外，它还可以用来处理数据与数据之间没有关系的任务，比如对网页分析、分词等，每个网页可以独立的分析、分词，而这两个网页之间并没有关系。网页几十亿、上百亿，如果单机处理，效率低下，我们就可以利用MapReduce提供的高可靠、高性能、高容错的并行计算框架，并行地处理这几十亿、上百亿的网页。</p><h2>内容小结</h2><p>今天我们讲了一种应用非常广泛的算法思想，分治算法。</p><p>分治算法用四个字概括就是“分而治之”，将原问题划分成n个规模较小而结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。这个思想非常简单、好理解。</p><p>今天我们讲了两种分治算法的典型的应用场景，一个是用来指导编码，降低问题求解的时间复杂度，另一个是解决海量数据处理问题。比如MapReduce本质上就是利用了分治思想。</p><p>我们也时常感叹Google的创新能力如此之强，总是在引领技术的发展。实际上，<span class=\"orange\">创新并非离我们很远，创新的源泉来自对事物本质的认识。无数优秀架构设计的思想来源都是基础的数据结构和算法，这本身就是算法的一个魅力所在。</span></p><h2>课后思考</h2><p>我们前面讲过的数据结构、算法、解决思路，以及举的例子中，有哪些采用了分治算法的思想呢？除此之外，生活、工作中，还有没有其他用到分治算法的地方呢？你可以自己回忆、总结一下，这对你将零散的知识提炼成体系非常有帮助。</p><p>欢迎留言和我分享，也欢迎点击“<span class=\"orange\">请朋友读</span>”，把今天的内容分享给你的好友，和他一起讨论、学习。</p>","neighbors":{"left":{"article_title":"37 | 贪心算法：如何用贪心算法实现Huffman压缩编码？","id":73188},"right":{"article_title":"39 | 回溯算法：从电影《蝴蝶效应》中学习回溯算法的核心思想","id":74287}},"comments":[{"had_liked":false,"id":51872,"user_name":"Williamzhang","can_delete":false,"product_type":"c1","uid":1148759,"ip_address":"","ucode":"C016AE5DE39F4E","user_header":"https://static001.geekbang.org/account/avatar/00/11/87/57/e28ba87b.jpg","comment_is_top":true,"comment_ctime":1545272531,"is_pvip":false,"replies":[{"id":"18991","content":"哈哈 终于有人看懂了 我的跟留言那位同学的思路不一样而已 他的更简洁些","user_name":"作者回复","comment_id":51872,"uid":"1190123","ip_address":"","utype":1,"ctime":1545358074,"user_name_real":"gg"}],"discussion_count":1,"race_medal":0,"score":"9.2233722316736e+18","product_id":100017301,"comment_content":"第一个留言有问题可以再理解一下，不要误导后边人，作者的num+=语句位置正确","like_count":45,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433657,"discussion_content":"哈哈 终于有人看懂了 我的跟留言那位同学的思路不一样而已 他的更简洁些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545358074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":51727,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1545229622,"is_pvip":true,"replies":[{"id":"18786","content":"👍","user_name":"作者回复","comment_id":51727,"uid":"1190123","ip_address":"","utype":1,"ctime":1545271280,"user_name_real":"gg"}],"discussion_count":1,"race_medal":0,"score":"589955749174","product_id":100017301,"comment_content":"在统计方面比较多，比如统计我国人口，要知道我国人口就要先知道每个省人口，要知道省人口就要知道每个市人口，要知道市人口就要知道每个区县人口，直到村社区，然后汇总求的总人数。","like_count":137,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433600,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545271280,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":54627,"user_name":"MIAN-勉","can_delete":false,"product_type":"c1","uid":1123554,"ip_address":"","ucode":"AE938038C2E7D1","user_header":"https://static001.geekbang.org/account/avatar/00/11/24/e2/e5110db5.jpg","comment_is_top":false,"comment_ctime":1545917803,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"366618137963","product_id":100017301,"comment_content":"把归并排序merge方法的参数列表 由merge(int[] a, int p, int q, int r) 改为 merge(int[] a, int low, int middle, int high) 更容易理解😂，小细节，哈哈","like_count":85,"discussions":[{"author":{"id":2051737,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/4e/99/3e095dd0.jpg","nickname":"Geek_Mason","note":"","ucode":"466AEC19B30AF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289590,"discussion_content":"教材上很多就用的pqr","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594139369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1004953,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/55/99/4bdadfd3.jpg","nickname":"Chloe","note":"","ucode":"C4848ED5B35752","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":257316,"discussion_content":"发现老师用的变量名和《算法导论》上的pseudocode一样，可能这里面有什么原因","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588558207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1758731,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d6/0b/7afd26c5.jpg","nickname":"Small Wave","note":"","ucode":"48490CC348250C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":182643,"discussion_content":"这个是Java的语法，与C/C++不一样，但能看懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582444201,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":51396,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1545180439,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"246358316311","product_id":100017301,"comment_content":"「创新并非离我们很远，创新的源泉来自对事物本质的认识。无数优秀架构设计的思想来源都是基础的数据结构和算法，这本身就是算法的一个魅力所在。」 <br><br>这句话讲的太好啦。各种前端框架层出不穷，本质的东西，也是基本都没有变。<br><br>与其最新，不如求本。","like_count":57,"discussions":[{"author":{"id":1357311,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b5/ff/d1f205b0.jpg","nickname":"L","note":"","ucode":"5B847B2378854E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302443,"discussion_content":"与其追新，不如求本","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1598925705,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1202325,"avatar":"https://static001.geekbang.org/account/avatar/00/12/58/95/640b6465.jpg","nickname":"fmouse","note":"","ucode":"9A8858CFFAB858","race_medal":2,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":273620,"discussion_content":"与其最新，不如求本。加油","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590477766,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159774,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1575785171,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"203439248083","product_id":100017301,"comment_content":"采用分治思想的算法包括：<br>1.快速排序算法<br>2.合并排序算法<br>3.桶排序算法<br>4.基数排序算法<br>5.二分查找算法<br>6.利用递归树求解算法复杂度的思想<br>7.分布式数据库利用分片技术做数据处理<br>8.MapReduce模型处理思想","like_count":47,"discussions":[{"author":{"id":1438860,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f4/8c/0866b228.jpg","nickname":"子房","note":"","ucode":"CB05938C248BB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358559,"discussion_content":"卧槽，这就是学习带来的差距么","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1615993633,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2391649,"avatar":"https://static001.geekbang.org/account/avatar/00/24/7e/61/486b1e9d.jpg","nickname":"我叫爱学习","note":"","ucode":"75271AE7A2BC3A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350850,"discussion_content":"MApReduce处理思想是Map进行split分割时候","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1614051386,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":51859,"user_name":"刘远通","can_delete":false,"product_type":"c1","uid":1253307,"ip_address":"","ucode":"4D3EE819E4B235","user_header":"https://static001.geekbang.org/account/avatar/00/13/1f/bb/c488d5db.jpg","comment_is_top":false,"comment_ctime":1545271418,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"186228865146","product_id":100017301,"comment_content":"第一个求最近的点对<br>分成两块 单独求其中一块点对最小距离 <br>然后求这两块之间点对的最小距离 通过一些排序和删除 可以减少到6个点之间比较 很神奇<br><br>第二个矩阵计算<br>v.斯特拉森提出了2*2分块矩阵的计算公式 从原来的8次乘法 缩减到了7次<br>当n规模很大的时候 缩减效果就很明显 （7&#47;8）^(logn)","like_count":43,"discussions":[{"author":{"id":1528737,"avatar":"https://static001.geekbang.org/account/avatar/00/17/53/a1/1a7bd68a.jpg","nickname":"吴同学","note":"","ucode":"9103EB5FD43ECD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":264250,"discussion_content":"1. 取中间点即可，使分出的两半尽量大小相同，然后分别计算左右两半最短距离，求出min值d，然后关键是计算两半之间交界处的最短距离；\n2. 根据min值d在中间的划分线两边画两条带子，宽度左右各为d，只有在这个交界区域的点对才可能有更短距离；\n3. 这个区域的点对也不必全部遍历，比如左侧某点p，右侧的q需在一个高2d*宽d的矩形内才可能使两者距离小于d，而这个矩形内至多只可能放入6个点（极端情况即为四个角加上两长边中点）\n4. 最后递归求解，时间复杂度为O(nlogn)","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1589295974,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2145095,"avatar":"https://static001.geekbang.org/account/avatar/00/20/bb/47/b60ae3eb.jpg","nickname":"你好，阳光","note":"","ucode":"1A2F487C57F7D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1528737,"avatar":"https://static001.geekbang.org/account/avatar/00/17/53/a1/1a7bd68a.jpg","nickname":"吴同学","note":"","ucode":"9103EB5FD43ECD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544767,"discussion_content":"不理解为什么是6个点，我在https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/closepoints.pdf这个资料里看到的是8个点","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1641702236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":264250,"ip_address":""},"score":544767,"extra":""}]},{"author":{"id":1512642,"avatar":"https://static001.geekbang.org/account/avatar/00/17/14/c2/46ebe3a0.jpg","nickname":"侧耳倾听","note":"","ucode":"5BF2A2440B54F0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":227563,"discussion_content":"最近点对的算法你说的不太准确，不是简单的随意分成两块，如果两个点很近，但是分到了两个不同的快，你的算法就错过了最优解。当然你也没细说如何分块，只是考虑到了这点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586501290,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":51515,"user_name":"Yves","can_delete":false,"product_type":"c1","uid":1197267,"ip_address":"","ucode":"66F28B12810CCA","user_header":"https://static001.geekbang.org/account/avatar/00/12/44/d3/6dfe017c.jpg","comment_is_top":false,"comment_ctime":1545192610,"is_pvip":false,"replies":[{"id":"18686","content":"是的 大家代码直接看这位同学的 我晚点改正下。写的时候匆忙 不好意思","user_name":"作者回复","comment_id":51515,"uid":"1190123","ip_address":"","utype":1,"ctime":1545219648,"user_name_real":"gg"}],"discussion_count":1,"race_medal":0,"score":"169048917154","product_id":100017301,"comment_content":"代码略有问题：1，num += (q - i + 1)，应该是在 a[i] &lt;= a[j] 这个条件分支里面；2，while (i &lt;= q) 里面不应该有 num += (q - i + 1)，3，最后的修改原数组迭代条件应该是  i &lt; r - p + 1 而不是  i &lt; r - p 。<br><br>private void merge(int[] a, int p, int q, int r) {<br>        int i = p, j = q + 1, k = 0;<br>        int[] tmp = new int[r - p + 1];<br>        while (i &lt;= q &amp;&amp; j &lt;= r) {<br>            if (a[i] &lt;= a[j]) {<br>                tmp[k++] = a[i++];<br>            } else {<br>                num += (q - i + 1);<br>                tmp[k++] = a[j++];<br>            }<br>        }<br>        while (i &lt;= q) {<br>            tmp[k++] = a[i++];<br>        }<br>        while (j &lt;= r) {<br>            tmp[k++] = a[j++];<br>        }<br>        for (i = 0; i &lt; r - p + 1; ++i) {<br>            a[p + i] = tmp[i];<br>        }<br>    }","like_count":39,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433491,"discussion_content":"是的 大家代码直接看这位同学的 我晚点改正下。写的时候匆忙 不好意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545219648,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":52072,"user_name":"h…","can_delete":false,"product_type":"c1","uid":1052539,"ip_address":"","ucode":"E713F11CBA6AB0","user_header":"https://static001.geekbang.org/account/avatar/00/10/0f/7b/7c043069.jpg","comment_is_top":false,"comment_ctime":1545305392,"is_pvip":false,"replies":[{"id":"18987","content":"算法现在很火啊 供不应求 如果年轻的话 并且愿意学习的话 转起来也不难 建议找几本书看看 多代码练习一下 入了门之后 先找个一般的公司干干 积累些项目经验 以此再去好点公司","user_name":"作者回复","comment_id":52072,"uid":"1190123","ip_address":"","utype":1,"ctime":1545357324,"user_name_real":"gg"}],"discussion_count":7,"race_medal":0,"score":"151869160752","product_id":100017301,"comment_content":"王争老师，我是后台开发，想换算法类工作，能不能给我点建议","like_count":35,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433731,"discussion_content":"算法现在很火啊 供不应求 如果年轻的话 并且愿意学习的话 转起来也不难 建议找几本书看看 多代码练习一下 入了门之后 先找个一般的公司干干 积累些项目经验 以此再去好点公司","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545357324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307858,"discussion_content":"快2年后看这条留言，很有感慨，从19年秋招开始算法就严重饱和了。。不知道今年算法同学普遍如何来。。。不要一窝蜂，看自己的兴趣，如果对哪个行当感兴趣，只要这个行当不极度萎缩，正常情况，每天哪怕每个工作日都拿出1 2个小时学习，几年下来都够跑到头部的，无论 后台开发、大数据 、算法","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1600774939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1543652,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8d/e4/1137270e.jpg","nickname":"Aaron","note":"","ucode":"7679D1B911FC3D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350350,"discussion_content":"干了几年了，现在社招岗都不多了。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613819011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":307858,"ip_address":""},"score":350350,"extra":""}]},{"author":{"id":1209336,"avatar":"https://static001.geekbang.org/account/avatar/00/12/73/f8/dbd2fa50.jpg","nickname":"晓杉","note":"","ucode":"19E634BB61A165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41486,"discussion_content":"年轻就是资本，哭...","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1572439529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1061402,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/y5NFbibdKCFCg0lHKK5ERGOQWXYYK7jhnqm2BxQ6r7tWvXx8uDmibglweejDWU39BTmDSAtBJGj1ibOZK2uIHQyqg/132","nickname":"Mr_freezing37","note":"","ucode":"BB605A6FEDCEB6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287938,"discussion_content":"如果不年轻了呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593596054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1036606,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d1/3e/d790c6d3.jpg","nickname":"牛顿的苹果啦","note":"","ucode":"B31657FA24CB03","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1061402,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/y5NFbibdKCFCg0lHKK5ERGOQWXYYK7jhnqm2BxQ6r7tWvXx8uDmibglweejDWU39BTmDSAtBJGj1ibOZK2uIHQyqg/132","nickname":"Mr_freezing37","note":"","ucode":"BB605A6FEDCEB6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301216,"discussion_content":"学习一门技术的最好的时间是十年前，其次就是现在，老哥","likes_number":18,"is_delete":false,"is_hidden":false,"ctime":1598442026,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":287938,"ip_address":""},"score":301216,"extra":""},{"author":{"id":1939316,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/97/74/a933d664.jpg","nickname":"莜戏","note":"","ucode":"C3488A2BB44359","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1061402,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/y5NFbibdKCFCg0lHKK5ERGOQWXYYK7jhnqm2BxQ6r7tWvXx8uDmibglweejDWU39BTmDSAtBJGj1ibOZK2uIHQyqg/132","nickname":"Mr_freezing37","note":"","ucode":"BB605A6FEDCEB6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345036,"discussion_content":"年轻点就去支配算法，不年轻就被算法支配嘛","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1611644380,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":287938,"ip_address":""},"score":345036,"extra":""}]}]},{"had_liked":false,"id":58699,"user_name":"Jiemr","can_delete":false,"product_type":"c1","uid":1243092,"ip_address":"","ucode":"AB1FDD61E9151F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f7/d4/b71779ff.jpg","comment_is_top":false,"comment_ctime":1547177988,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"113216327684","product_id":100017301,"comment_content":"老师，我有两个疑问：<br>给 10GB 的订单排序，我们就可以先扫描一遍订单<br>-------------------------------------<br>1.场景中描述的机器内存只有2、3GB，我理解的是直接加载文件内存应该不够用来扫描一次10GB订单文件，对吗？如果不能，那应该怎么扫描呢？<br>2.如果用buffer来缓存扫描结果的话，即使能扫描完成，又该怎么对文件根据金额区间进行分割呢？","like_count":26,"discussions":[{"author":{"id":1238585,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e6/39/1dad4153.jpg","nickname":"niexia","note":"","ucode":"FB95E807E0B1BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46572,"discussion_content":"这个在桶排序里边有介绍过\n1. 先遍历一遍，找到最大值、最小值，这样就可以确定每个区间的范围，比如第一个文件 1~1000，第二个文件 1000~2000\n2. 再遍历一遍，把不同的订单金额数据分到对应的文件\n3. 依次将文件加载到内存中进行排序\n4. 最后依次读取每个小文件的订单数据，并将其写到一个文件中。\n\n第 1，第 2 步的遍历，应该不需要全部加载的内存中的，可以分块","likes_number":15,"is_delete":false,"is_hidden":false,"ctime":1573183435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1272047,"avatar":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","nickname":"Magic","note":"","ucode":"FD9CEDAA419EB0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":19071,"discussion_content":"这里扫描是为了获取到金额的范围，因此可以分块读取，比如一次读取2G，然后遍历这2G数据找到最小值和最大值，然后再去读取2G数据，重复这个过程，最后得到10G数据的金额范围，为后面的分区间分桶做准备","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1569132357,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1234221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d5/2d/bd28a5bc.jpg","nickname":"葵花老师傅","note":"","ucode":"367FDEA57C675B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3331,"discussion_content":"我觉得题意可能是10G的订单数据分布在多个文件当中，然后如果全部加载到内存是不大行的。我这边的理解是从每个订单文件中抽取一定的数据在进行排序（比如订单金额为 1 到 100 元的抽取出来）再放到一个小文件里面这种的方式，不知道理解的对不对","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1564399433,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1990300,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/5e/9c/0efcc194.jpg","nickname":"小苏","note":"","ucode":"CC2ADE51598AF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377997,"discussion_content":"可以一部分一部分加载到内存中，每部分都分金额区间写入文件中","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1622991037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1268797,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5c/3d/e8325811.jpg","nickname":"对白","note":"","ucode":"3183E5ADBC794B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297758,"discussion_content":"散列算法进行数据分片，就是分治算法的思想","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597048699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1755477,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/c9/55/0e627a31.jpg","nickname":"菽绣","note":"","ucode":"60955E14C39C6B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":175074,"discussion_content":"大文件按行读取不耗内存吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581949744,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1755477,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/c9/55/0e627a31.jpg","nickname":"菽绣","note":"","ucode":"60955E14C39C6B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307857,"discussion_content":"。。。耗得不多，不代表一点都不消耗，一般为了加快速度，一般都是bufferread  你自己决定一次读取多少大小的数据","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600774817,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":175074,"ip_address":""},"score":307857,"extra":""}]}]},{"had_liked":false,"id":65174,"user_name":"刘文坛","can_delete":false,"product_type":"c1","uid":1141060,"ip_address":"","ucode":"327D908175EDD0","user_header":"https://static001.geekbang.org/account/avatar/00/11/69/44/1588e8b6.jpg","comment_is_top":false,"comment_ctime":1549089063,"is_pvip":false,"replies":[{"id":"24293","content":"不。单核也可以利用多线程并行。毕竟一般的算法代码都包括：内存访问、CPU计算两部分，并不只是CPU计算。","user_name":"作者回复","comment_id":65174,"uid":"1190123","ip_address":"","utype":1,"ctime":1550542610,"user_name_real":"gg"}],"discussion_count":4,"race_medal":0,"score":"108923271463","product_id":100017301,"comment_content":"分治算法本质上就是利用多核cpu并行计算能力，如果只是单核cpu，分治算法是不是就不可行了？","like_count":25,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438346,"discussion_content":"不。单核也可以利用多线程并行。毕竟一般的算法代码都包括：内存访问、CPU计算两部分，并不只是CPU计算。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550542610,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4323,"discussion_content":"单核CPU应该叫多线程并发吧，毕竟单核上同一时刻只有一个线程可以得到CPU时间片，多线程并发可以通过调度让CPU时间片在线程间被利用的更充分，如线程A在I/O返回前可通过调度执行线程B的计算，让CPU等待时间减少。","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1565314838,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2962599,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/34/a7/52c4ea60.jpg","nickname":"年少挽滑稽世无双","note":"","ucode":"793DCBDE25A07B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575908,"discussion_content":"666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655179791,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4323,"ip_address":""},"score":575908,"extra":""}]},{"author":{"id":1591223,"avatar":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","nickname":"JerryZhu","note":"","ucode":"76850CD45786C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305823,"discussion_content":"单核就利用CPU时间片来进行并发操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600091792,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":80369,"user_name":"涂","can_delete":false,"product_type":"c1","uid":1247775,"ip_address":"","ucode":"DC9F3B99A0B4E5","user_header":"https://static001.geekbang.org/account/avatar/00/13/0a/1f/cfeb036d.jpg","comment_is_top":false,"comment_ctime":1553652313,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"100337900121","product_id":100017301,"comment_content":"leetcode 315","like_count":23,"discussions":[{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559265,"discussion_content":"leetcode 51","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1648669816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":56029,"user_name":"苏雅拉","can_delete":false,"product_type":"c1","uid":1037519,"ip_address":"","ucode":"1738D96BF76113","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d4/cf/4aee8109.jpg","comment_is_top":false,"comment_ctime":1546388195,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"100330636003","product_id":100017301,"comment_content":"微积分是分治思想鼻祖","like_count":23,"discussions":[{"author":{"id":1438860,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f4/8c/0866b228.jpg","nickname":"子房","note":"","ucode":"CB05938C248BB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358560,"discussion_content":"这个更厉害","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615993648,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203558,"user_name":"大毛","can_delete":false,"product_type":"c1","uid":1899599,"ip_address":"","ucode":"93B18287F06706","user_header":"https://static001.geekbang.org/account/avatar/00/1c/fc/4f/0a452c94.jpg","comment_is_top":false,"comment_ctime":1586232976,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"83190611600","product_id":100017301,"comment_content":"其实不仅仅是算法，在工程上也是采取这样的思路，不仅仅是在工程上，任何一个庞大的体系都是使用“分而治之”的思想完成的。<br>一个个体的能力是有限的，我们需要一套机制把每个个体的力量集合起来办大事。这种思想，在计算机中叫分治，在人类社会中叫合作。这样一套卓有成效的机制，在计算机中是集群分布式架构，在社会中就是一个公司、一个政 府。<br>在这种合作下会产生很多问题，其中最突出的问题就是个体（公司部门）之间的通信问题。在计算机中，这种问题表现为任务分配和资源冲突，在公司中，这种问题表现为各个部门之间的竞争、自扫门前雪。处理这样的问题，需要考验我们的智慧。<br>认识事物的本质，触类旁通了解世界，真是一件有趣的事。<br>","like_count":19,"discussions":[{"author":{"id":2159460,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/dsZ5CFV7mCIKEn7YcVFJXksO201eeqsJXoT4EYNvcibAKNSWSQVZPbbRgPKraWqg6YnaaRlVoywic9MEsflicRDibQ/132","nickname":"潜龙勿用","note":"","ucode":"EEB8A6F3E4A1B8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319196,"discussion_content":"分工与分治是不一样的","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1603961311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121352,"user_name":"CathyLin","can_delete":false,"product_type":"c1","uid":1240546,"ip_address":"","ucode":"F7CDFF5E1A235F","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/e2/0e1c6c5a.jpg","comment_is_top":false,"comment_ctime":1565105115,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"61694647259","product_id":100017301,"comment_content":"本来已经刷完了，但感觉没想明白怎样合并平面中两个距离最近的点对于是又网上查资料嗑了 2 个晚上。<br>发现通过数学公式的计算，对于左区间中的一个点，我们最多只需要比较右区间中 7 个点就可以了，所以也是相当于是 linear time。<br>然后通过 T(n) = 2*T(n&#47;2) + O(n) 得到最后的时间复杂度是 O(NlogN)。<br>Ref: https:&#47;&#47;en.wikipedia.org&#47;wiki&#47;Closest_pair_of_points_problem<br><br>课后思考：深刻的理解到了递归就是实现分治的最好方法，例如我们在构建树的问题时，首先构建左子树，然后再构建右子树，最后把两个子树合并起来形成当前节点。<br>生活中：就像评论区所留言的那样，美国大选，先从镇开始，然后到州，最后在合并起来。<br><br>","like_count":13,"discussions":[{"author":{"id":1542012,"avatar":"https://static001.geekbang.org/account/avatar/00/17/87/7c/a89bde1c.jpg","nickname":"nopainnogain","note":"","ucode":"FBAB3C005494E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293324,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595504248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1020492,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/4c/40783447.jpg","nickname":"何骧","note":"","ucode":"11DCC74CE2F300","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293298,"discussion_content":"6个点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595500714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":51677,"user_name":"ALAN","can_delete":false,"product_type":"c1","uid":1240164,"ip_address":"","ucode":"70E3B1C730E63F","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/64/7403c694.jpg","comment_is_top":false,"comment_ctime":1545222140,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"44494895100","product_id":100017301,"comment_content":"老师，你好，有一个建议，就是对于代码每一行里不是很显然易懂的地方，能否注释下此行代码的作用，不然有时看了代码也不知为啥这样写。","like_count":10,"discussions":[{"author":{"id":1661704,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5b/08/b0b0db05.jpg","nickname":"丁丁历险记","note":"","ucode":"A43829E454C067","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":36284,"discussion_content":"都看到这里来了，一些基础实现的代码，反应还那么慢。  你确定你前面认真看过，有动过手？？？\n至少本章而言，代码不秒懂说明基础出了问题，还墨迹啥，力扣刷一轮再来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571359019,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":246599,"user_name":"小时候可鲜啦","can_delete":false,"product_type":"c1","uid":1050777,"ip_address":"","ucode":"C88B3EDF758230","user_header":"https://static001.geekbang.org/account/avatar/00/10/08/99/6ab45a2f.jpg","comment_is_top":false,"comment_ctime":1599435781,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"40254141445","product_id":100017301,"comment_content":"按照代码算法的意思，计算逆序对的图里边应该是0+2+2+2=6才对吧？","like_count":10},{"had_liked":false,"id":57319,"user_name":"Geek_41d472","can_delete":false,"product_type":"c1","uid":1247965,"ip_address":"","ucode":"DEC2B6329460CF","user_header":"https://static001.geekbang.org/account/avatar/00/13/0a/dd/88fa7b52.jpg","comment_is_top":false,"comment_ctime":1546746127,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35906484495","product_id":100017301,"comment_content":"归并排序忘记了，又跑头前面看一下，不然看不懂了……忘的好快……","like_count":8},{"had_liked":false,"id":123508,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1565689283,"is_pvip":false,"replies":[{"id":"45688","content":"把比较基础的算法看懂就可以了，我后面有一篇文章分享关于新手如何循序渐进学习的，你可以看下。","user_name":"作者回复","comment_id":123508,"uid":"1190123","ip_address":"","utype":1,"ctime":1565908776,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"31630460355","product_id":100017301,"comment_content":"老师，请问我做java但是不从事算法岗位，这门课需要学习到什么程度呢？总觉得心里有目标会更好点。","like_count":7,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462703,"discussion_content":"把比较基础的算法看懂就可以了，我后面有一篇文章分享关于新手如何循序渐进学习的，你可以看下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565908776,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2045997,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/38/2d/f3c6493e.jpg","nickname":"罗樱罂","note":"","ucode":"9072E79E625ED1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310179,"discussion_content":"请问一下，算法岗是什么岗？不都是sde吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601666377,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109436,"user_name":"康斯坦丁","can_delete":false,"product_type":"c1","uid":1368096,"ip_address":"","ucode":"C130E800E8D5C9","user_header":"https://static001.geekbang.org/account/avatar/00/14/e0/20/003190c1.jpg","comment_is_top":false,"comment_ctime":1562032588,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31626803660","product_id":100017301,"comment_content":"前面的数据结构与算法中： 归并排序、桶排序、快速排序使用了分治算法. <br>工作&#47;生活中: 美国大选统计选票.","like_count":7},{"had_liked":false,"id":102101,"user_name":"寻路人","can_delete":false,"product_type":"c1","uid":1195917,"ip_address":"","ucode":"1711F740D4D60A","user_header":"https://static001.geekbang.org/account/avatar/00/12/3f/8d/a89be8f9.jpg","comment_is_top":false,"comment_ctime":1560136245,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"27329940021","product_id":100017301,"comment_content":"团队目标达成也是采用分治思想。<br>leader:设置一个团队的整体目标。<br>module owner: 分取整体目标的一个模块。<br>developer: 分取模块里面一个任务。<br>整体目标 = 模块任务A + 模块任务B<br>模块任务A = 个人任务A + 个人任务B + 个人任务C<br>最后达到整个任务","like_count":6,"discussions":[{"author":{"id":1592062,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4a/fe/c2d61155.jpg","nickname":"杨柳","note":"","ucode":"C99EABEC53825E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363003,"discussion_content":"这个不算吧，任务分解，但 不是递归式的子问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617090439,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119847,"user_name":"未来的胡先森","can_delete":false,"product_type":"c1","uid":1234682,"ip_address":"","ucode":"AFF193AC0E2E6C","user_header":"https://static001.geekbang.org/account/avatar/00/12/d6/fa/1f5bf642.jpg","comment_is_top":false,"comment_ctime":1564712354,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23039548834","product_id":100017301,"comment_content":"公司的管理也是分治吧，先把大的任务分到各大部门，部门再划分任务到团队，团队划分到个人（达到能够独立求解），个人完成任务，到团体完成任务，到大任务完成即合并。","like_count":5},{"had_liked":false,"id":251515,"user_name":"Geek_684984","can_delete":false,"product_type":"c1","uid":2149833,"ip_address":"","ucode":"BAE0E43AA80892","user_header":"","comment_is_top":false,"comment_ctime":1601636393,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18781505577","product_id":100017301,"comment_content":"我来加点注释~.~<br>```<br>   &#47;**<br>     * 子问题合并逻辑<br>     * 1. 将两个子数组进行合并<br>     * 2. 计算当前数组的逆序值<br>     * 3. 将数组进行顺序排列<br>     * merge操作计算num的复杂度小于原数组递归计算num的复杂度((n^2+n)&#47;2)<br>     * @param processArray 需要计算逆序值得数组段,最终该段数组会按照顺序排列<br>     * @param startPoint 需要被计算逆序值的数据段的初始位置<br>     * @param middlePoint 需要被计算逆序值的数据段的中间位置<br>     * @param endPoint 需要被计算逆序值的数据段的结束位置<br>     *&#47;<br>    private void merge(int[] processArray, int startPoint, int middlePoint, int endPoint) {<br>        int i = startPoint, j = middlePoint + 1, k = 0;<br>        int[] tmp = new int[endPoint - startPoint + 1];<br>        &#47;&#47;执行计算逻辑前的已知条件<br>        &#47;&#47; 1. 从起点到中间的数组A已经顺序排列.<br>        &#47;&#47; 2. 从中点到终点的数组B已经顺序排列<br>        &#47;&#47; 3. A中的元素可能比B中的元素大,也有可能比B中元素小<br>        while (i &lt;= middlePoint &amp;&amp; j &lt;= endPoint) {<br>            if (processArray[i] &lt;= processArray[j]) { &#47;&#47;前半段的某元素若是小于等于后半段某元素,那么前半段数据直接往后迭代<br>                tmp[k++] = processArray[i++];<br>            } else {<br>                num += (middlePoint - i + 1); &#47;&#47;前半段的某元素若是大于后半段某元素,那么前半段该元素后的所有元素都大于后半段的钙元素,后半段的元素往后迭代<br>                tmp[k++] = processArray[j++];<br>            }<br>        }<br>        while (i &lt;= middlePoint) { &#47;&#47; 前半段某元素大于所有后半段元素的情况下,前半段该元素后的所有元素在上个迭代中未迭代完,直接依序放倒temp中<br>            tmp[k++] = processArray[i++];<br>        }<br>        while (j &lt;= endPoint) { &#47;&#47; 前半段所有元素都小于后半段的某元素,后半段该元素后的所有元素未迭代完,依序放倒temp中.<br>            tmp[k++] = processArray[j++];<br>        }<br>        for (i = 0; i &lt;= endPoint - startPoint; ++i) { &#47;&#47; 将有序的temp数组替换processArray的指定段<br>            processArray[startPoint + i] = tmp[i];<br>        }<br>    }<br>```","like_count":4},{"had_liked":false,"id":252979,"user_name":"LQS  KF","can_delete":false,"product_type":"c1","uid":1364737,"ip_address":"","ucode":"3C0A07A8220094","user_header":"https://static001.geekbang.org/account/avatar/00/14/d3/01/716d45b6.jpg","comment_is_top":false,"comment_ctime":1602552649,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14487454537","product_id":100017301,"comment_content":"Java中ForkJoin Framework 和Java8中的Spliterator都使用了分治思想","like_count":3,"discussions":[{"author":{"id":2962599,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/34/a7/52c4ea60.jpg","nickname":"年少挽滑稽世无双","note":"","ucode":"793DCBDE25A07B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575909,"discussion_content":"666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655180141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":51363,"user_name":"不上进的码农","can_delete":false,"product_type":"c1","uid":1248890,"ip_address":"","ucode":"D0594DDDD1C5AE","user_header":"https://static001.geekbang.org/account/avatar/00/13/0e/7a/31328704.jpg","comment_is_top":false,"comment_ctime":1545178796,"is_pvip":false,"replies":[{"id":"18541","content":"逆序对","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545183517,"ip_address":"","comment_id":51363,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14430080684","product_id":100017301,"comment_content":"if (a[i] &lt;= a[j]) {<br>      num += (j - q - 1);<br>      tmp[k++] = a[i++];<br>    } else {<br>      tmp[k++] = a[j++];<br>    }<br>我想了想，这段代码应该求的是有序对而不是逆序对吧","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433425,"discussion_content":"逆序对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545183517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216397,"user_name":"russellyue","can_delete":false,"product_type":"c1","uid":1541894,"ip_address":"","ucode":"0758ACF772F9C1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epIMwPE6FwsicZ6bjhu7ZpWLnoib8G76sA1XL8y5W8GxqfQEjBub6g57E60mzjWzrA6icMRw1QT5CpyA/132","comment_is_top":false,"comment_ctime":1589251501,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10179186093","product_id":100017301,"comment_content":"总结：分治算法是一种处理问题的思想，递归是一种编程技巧；分治算法一般用递归来实现。分治算法的递归实现中，每一层递归都会涉及这三个操作：1.将原问题分解为一系列的子问题2.递归地求解各个子问题，如果子问题足够小，那么直接求得结果3.合并：将子问题的结果合并成原问题的结果。分治算法能够解决的问题一般满足以下几个条件：1.原问题与分解成的小问题拥有相同的模式2.每个小问题之间没有关联性，这点是分治算法与动态规划的区别3.具有分解终止条件，也就是不能无限地分解下去4.可以将子问题的结果合并成原问题的结果，并且这个合并的操作复杂度不能太高","like_count":2},{"had_liked":false,"id":171537,"user_name":"注定非凡","can_delete":false,"product_type":"c1","uid":1113597,"ip_address":"","ucode":"80673056E131B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","comment_is_top":false,"comment_ctime":1578963626,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10168898218","product_id":100017301,"comment_content":"MapReduce本质就是分治算法，是Google大数据处理的三驾马车之一，另外两个是GFS和Bigtable。它在倒排索引，PageRank计算，网页分析等搜索引擎相关的技术中都有大量的应用。<br><br>一：如何理解分治算法<br>\t1，分治算法的核心思想其实就是四个字，分而治之，将原问题划分成n个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后在合并其结果，就得到原问题的解。<br><br>\t2，分治算法的定义类似于递归，但区别在于：分治算法是一种处理问题的思想，递归是一种编程技巧。<br><br>\t3，分治算法一般都比较适合递归来实现，分治算法的递归实现中，每一层递归都会涉及这样的三个操作：<br>\t分解：将原问题分解成一系列子问题；<br>\t解决：递归地求解各个子问题，若子问题足够小，则直接求解；<br>\t合并：将子问题的结果合并成原问题；<br>\t<br>\t4，分治算法能解决的问题，一般需要满足下面这几个条件：<br>\t原问题与分解成的小问题具有相同的模式；<br>\t原问题分解成的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法跟动态规划的明显区别，<br>\t具有分解终止条件，即当问题足够小时，可以直接求解。<br>\t可以将子问题合并成原问题，而这个操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果。<br><br>二：分治算法应用举例分析<br>\t1，假设有n个数据，期望数据从小到大排序，那完全有序的数据的有序度就是n(n-1)&#47;2。逆序度等于0；相反，倒序排序的数据的有序度就是0，逆序度是n(n-1)&#47;2。除了这两中极端情况外，我们通过计算有序对或逆序对的个数，来表示数据的有序度或逆序度。<br> <br>\t2，现在问：如何编程求出数组中的数据有序对个数或逆序对个数？<br>\t3，最简单的办法：拿每个数字和他后面的数字比较，看有几个比它小。将比它小的数字个数记作k，通过这样的方式，把每个数字都考察一遍后，对每个数字对应的k值求和，最后得到的总和就是逆序对个数。但时间复杂度是O(n^2)。<br>\t4，用分治算法，套用分治的思想，将书中分成前后两半A1和A2，分别两者中的逆序对数，然后在计算A1和A2之间的逆序对个数k3。那整个数组的逆序对个数就是k1+k2+k3。<br>\t5，要快速计算出两个子问题A1和A2之间的逆序对个数需要借助归并排序算法。<br>归并排序算法有个非常关键的操作，即将两个有序的小数组，合并成一个有序的数组。实际上，在合并的过程中，就可以计算这两个小数组的逆序对个数。每次合并操作，都计算逆序对个数，把这些计算出来的逆序对个数求和，就是这个数组的逆序对个数。 <br><br>三：分治思想在海量数据处理中的应用<br>\t1，假设，给10GB的订单文件按照金额排序这样一个需求，看似是一个简单的排序问题，但是因为数据量大，有10GB，而我们的机器的内存可能只有2,3GB这样子，无法一次性加载到内存，也就无法通过单纯地使用快排，归并等基础算法来解决。<br>\t<br>\t2，要解决这种数据量大到内装不下的问题，我们就可以利用分治的思想，将海量的数据集合根据某种方法，划分为几个小的数据集合，每个小的数据集合单独加载到内存来解决，然后在将小数据集合合并成大数据集合，实际上利用这种分治的处理思路，不仅能克服内存的限制，还能利用多线程或者多机处理，加快处理的速度。<br>","like_count":2},{"had_liked":false,"id":51927,"user_name":"Sharry","can_delete":false,"product_type":"c1","uid":1239293,"ip_address":"","ucode":"045DDB864659F6","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/fd/035f4c94.jpg","comment_is_top":false,"comment_ctime":1545277115,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10135211707","product_id":100017301,"comment_content":"使用归并排序求逆序度, 实在是太妙了! 老师的代码一点儿问题都没有, (j-q-1) 记录的是比子序列 A 中当前即将添加到 tmp 数组中的元素的逆序对的个数, 看到留言里小伙伴说应该放在下面的 else 里, 可能需要再斟酌斟酌","like_count":2},{"had_liked":false,"id":301890,"user_name":"ty","can_delete":false,"product_type":"c1","uid":2596473,"ip_address":"","ucode":"37852330CB17EB","user_header":"https://static001.geekbang.org/account/avatar/00/27/9e/79/8f9a8bef.jpg","comment_is_top":false,"comment_ctime":1625953422,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5920920718","product_id":100017301,"comment_content":"&quot;二维平面上有 n 个点，如何快速计算出两个距离最近的点对？&quot;这个好像还是不知道要怎么做，可以请简单讲讲思路么？","like_count":1},{"had_liked":false,"id":236955,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1595602141,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5890569437","product_id":100017301,"comment_content":"本篇不知道听了多少遍，看了多少遍。直到今天才领悟到归并排序求逆序对个数的奥秘。另外我发现归并排序也可以是原地排序啊（合并两个有序数组时，使用插入排序的思维）。","like_count":1,"discussions":[{"author":{"id":1100439,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ca/97/5042c207.jpg","nickname":"king","note":"","ucode":"FFC090D0EF1F80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348950,"discussion_content":"原地排序你复杂度就高了，合并的时候就不是O（n）了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612792386,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230600,"user_name":"Bob","can_delete":false,"product_type":"c1","uid":1972686,"ip_address":"","ucode":"5925994FAB4BD6","user_header":"https://static001.geekbang.org/account/avatar/00/1e/19/ce/5d3e639c.jpg","comment_is_top":false,"comment_ctime":1593426266,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5888393562","product_id":100017301,"comment_content":"普通求解逆序对的个数，平均时间复杂度是O(n^2),<br>通过归并排序, 分治思想求解，平均时间复杂度是O(n*logn)。<br>js的完整代码：<br>&#47;**<br> * 获取任意数组的逆序对个数<br> * 时间复杂度 O(nlogn)<br> * @param {Array} nums<br> * @returns {Number}<br> *&#47;<br>function getOrderCount(nums) {<br>  let count = 0<br>  mergeSort(nums)<br>  return count<br><br>  &#47;&#47; 归并排序--分治思想<br>  function mergeSort(arr, start = 0, end = arr.length - 1) {<br>    &#47;&#47; 终止条件，start &gt;= end<br>    if (start &gt;= end) return<br>    <br>    &#47;&#47; 分解，0, end&#47;2; end&#47;2+1, end<br>    let center = Math.floor((start + end)&#47;2)<br>    mergeSort(arr, start, center)<br>    mergeSort(arr, center+1, end)<br>    <br>    &#47;&#47; 合并两个有序数组，重新排序<br>    let arr1 = arr.slice(start, center+1)<br>    let arr2 = arr.slice(center+1, end+1)<br>    merge(arr, arr1, arr2, start)<br>  }<br><br>  &#47;&#47; 合并两个有序数组<br>  function merge(arr, arr1, arr2, start) {<br>    let temp = []<br>    let m = arr1.length<br>    let n = arr.length<br>    while (arr1.length &amp;&amp; arr2.length) {<br>      if (arr1[0] &lt; arr2[0]) {<br>        temp.push(arr1.shift())<br>      } else {<br>        temp.push(arr2.shift())<br>        &#47;&#47; 统计逆序对个数<br>        count += arr1.length<br>      }<br>    }<br>    if (arr1.length) {<br>      temp.push(...arr1)<br>    }<br>    if (arr2.length) {<br>      temp.push(...arr2)<br>    }<br>    &#47;&#47; console.log(&#39;temp&#39;, temp)<br>    for (let i = 0, n = temp.length; i &lt; n; i++) {<br>      arr[start+i] = temp[i]<br>    }<br>  }<br>}<br><br>let nums = [1,5,6,2,3,7]<br>let count = getOrderCount(nums)<br>&#47;&#47; console.log(&#39;count&#39;, count)","like_count":1},{"had_liked":false,"id":176303,"user_name":"发霉的宅大人","can_delete":false,"product_type":"c1","uid":1738243,"ip_address":"","ucode":"6757E30FE5E48D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/03/95004954.jpg","comment_is_top":false,"comment_ctime":1581009526,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"5875976822","product_id":100017301,"comment_content":"说一下我对于文中题目的思路<br>第一题：二维平面上有 n 个点，如何快速计算出两个距离最近的点对？<br>n个点一分为二，左右两对象再各自一分为二，直至对象里只有一个元素，然后遍历左右子对象的元素，记录距离。<br>举例：<br>1，2，6，9.四个点<br>分为1，2   6，9<br>再分为1   2   6  9<br>1和2测距离为1，6和9测距离为3；然后合并<br>合并为1，2   6，9.遍历左边的与右边的每一个元素测距离<br>1和6距离为5，1和9距离为8，2和6距离为4，2和9距离为7。<br>再次合并返回上一层1，2，6，9。<br>距离结果就是，1，3，5，8，4，7。最短距离为1<br><br>第二题：有两个 n*n 的矩阵 A，B，如何快速求解两个矩阵的乘积 C=A*B？<br>看矩阵相乘公式，就知道新的矩阵结果是行列一一对应相乘的结果。<br><br>第三题：我们前面讲过的数据结构、算法、解决思路，以及举的例子中，有哪些采用了分治算法的思想呢？除此之外，生活、工作中，还有没有其他用到分治算法的地方呢？<br>世界卫生组织的环境治理，分到各个国家治理自己的环境......<br>","like_count":1,"discussions":[{"author":{"id":1982733,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/41/0d/51565a01.jpg","nickname":"Suman","note":"","ucode":"F0823E5FC0836C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389579,"discussion_content":"第一题为什么一分为二的时候是1，26，9而不是12，69呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629345945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1914230,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/35/76/951b0daf.jpg","nickname":"K. D.","note":"","ucode":"7A1EC6B64D1EAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":272244,"discussion_content":"平面上n个点找最近距离的问题，感觉在合并的时候，还是n方的算法，和直接n方暴力解时间复杂度上感觉没有太多区别？我理解的merge sort他快是因为基于两个子类都素sort好的，在合并的时候只需要n的时间。楼主怎么看？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590270874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1738243,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/86/03/95004954.jpg","nickname":"发霉的宅大人","note":"","ucode":"6757E30FE5E48D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1914230,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/35/76/951b0daf.jpg","nickname":"K. D.","note":"","ucode":"7A1EC6B64D1EAF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":273553,"discussion_content":"合并两个已经有序的子类，听起来像是归并排序。\n在子类有序的情况下merge确实会快很多（时间久远，我已经忘了这条评论是在哪一篇文章下的了。）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590469979,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":272244,"ip_address":""},"score":273553,"extra":""}]},{"author":{"id":1571460,"avatar":"https://static001.geekbang.org/account/avatar/00/17/fa/84/f01d203a.jpg","nickname":"Simple life","note":"","ucode":"1902D7F72FB43F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219852,"discussion_content":"第一题你的解答算一维吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585817381,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1738243,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/86/03/95004954.jpg","nickname":"发霉的宅大人","note":"","ucode":"6757E30FE5E48D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1571460,"avatar":"https://static001.geekbang.org/account/avatar/00/17/fa/84/f01d203a.jpg","nickname":"Simple life","note":"","ucode":"1902D7F72FB43F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":228970,"discussion_content":"是的，举例只是一纬上的。\n二维上的同理可算坐标距离，因为写的太麻烦了……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586596585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":219852,"ip_address":""},"score":228970,"extra":""}]}]},{"had_liked":false,"id":172608,"user_name":"何雷","can_delete":false,"product_type":"c1","uid":1737805,"ip_address":"","ucode":"FA9BCE7DD9C8C4","user_header":"https://static001.geekbang.org/account/avatar/00/1a/84/4d/84371716.jpg","comment_is_top":false,"comment_ctime":1579233569,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5874200865","product_id":100017301,"comment_content":"说一下我对num+=(q-i+1)的理解：对两个有序列进行归并时，q是前一个有序列的最后一个元素的下标，i是前一有序列的当前元素，所以，在当前元素都已经大于后一个有序列的当前元素(j所指向的元素)时，后面的元素一定都大于j所指向的元素，所以，就是q-i+1个元素。","like_count":1},{"had_liked":false,"id":172276,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1015754,"ip_address":"","ucode":"00DF2FEC58D2E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","comment_is_top":false,"comment_ctime":1579143825,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5874111121","product_id":100017301,"comment_content":"看了将近2个小时终于看懂了！不过，让我亲自从头到尾写出来，感觉底气不足！还是需要多看，多学","like_count":1},{"had_liked":false,"id":148972,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1573120044,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"5868087340","product_id":100017301,"comment_content":"二维平面的最近点对比较难理解。我们先从一维的入手吧。也是使用分治思想来求解。<br>代码实现如下：<br>public static void find(int[] a) {<br>    int mindist = mindist(a, 0, a.length - 1);<br>    System.out.println(mindist);<br>  }<br><br>  public static int mindist(int[] a, int lo, int hi) {<br>    if (lo &gt;= hi) {<br>      return Integer.MAX_VALUE;<br>    } else if (lo == hi - 1) {<br>      return a[hi] - a[lo];<br>    } else {<br>      int m = lo + (hi - lo) &#47; 2;<br>      int delta_1 = mindist(a, lo, m); &#47;&#47; left points set<br>      int delta_2 = mindist(a, m + 1, hi); &#47;&#47; right points set<br>      int delta_3 = a[m + 1] - a[m]; &#47;&#47; strip points min distance<br>      return _Math.min(delta_1, delta_2, delta_3);<br>    }<br>  }<br><br>  public static void main(String[] args) {<br>    int[] a = {1, 3, 4, 10, 20, 100};<br>    find(a);&#47;&#47;1<br>  }","like_count":1,"discussions":[{"author":{"id":1047733,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fc/b5/ac717737.jpg","nickname":"肖臧","note":"","ucode":"4FAC9FF54DD6A0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283183,"discussion_content":"差值是不是得取个绝对值啊，输入的数组不用保证有序吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592205598,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97165,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1558600268,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5853567564","product_id":100017301,"comment_content":"用快排也可以算逆序度，只要记录数据交换的次数就可以了","like_count":1,"discussions":[{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":81474,"discussion_content":"不行，快排是不稳定的算法，交换次数和逆序度没啥关系","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1576247245,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89769,"user_name":"wahaha","can_delete":false,"product_type":"c1","uid":1051402,"ip_address":"","ucode":"E60166599CF31D","user_header":"https://static001.geekbang.org/account/avatar/00/10/0b/0a/fa152399.jpg","comment_is_top":false,"comment_ctime":1556260350,"is_pvip":false,"replies":[{"id":"32197","content":"怎么搞定的呢？貌似不行吧","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1556327390,"ip_address":"","comment_id":89769,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5851227646","product_id":100017301,"comment_content":"老师，求有(逆)序对只需一遍扫描即可，O(n)就能解决，所以用归并排序求解的这个例子并不太合适。","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448255,"discussion_content":"怎么搞定的呢？貌似不行吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556327390,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359171,"user_name":"古智鹏","can_delete":false,"product_type":"c1","uid":1267168,"ip_address":"广东","ucode":"B4448453A45ED5","user_header":"https://static001.geekbang.org/account/avatar/00/13/55/e0/f9d5c13c.jpg","comment_is_top":false,"comment_ctime":1665303505,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665303505","product_id":100017301,"comment_content":"逆序统计的 数字交换的次数，冒泡之类的算法也能解决","like_count":0},{"had_liked":false,"id":348537,"user_name":"年少挽滑稽世无双","can_delete":false,"product_type":"c1","uid":2962599,"ip_address":"","ucode":"793DCBDE25A07B","user_header":"https://static001.geekbang.org/account/avatar/00/2d/34/a7/52c4ea60.jpg","comment_is_top":false,"comment_ctime":1655180333,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655180333","product_id":100017301,"comment_content":"剑指 Offer 51. 数组中的逆序对<br>https:&#47;&#47;leetcode.cn&#47;problems&#47;shu-zu-zhong-de-ni-xu-dui-lcof&#47;","like_count":0},{"had_liked":false,"id":348419,"user_name":"何妨","can_delete":false,"product_type":"c1","uid":1206530,"ip_address":"","ucode":"DA2F639E9B8E44","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/02/643efae7.jpg","comment_is_top":false,"comment_ctime":1655094683,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655094683","product_id":100017301,"comment_content":"分支的思路不难理解，但是分治的难点在于“拆分规模更小结构类似无依赖关系子问题”，具体如何拆分？这个始终没有具体的指导思想，请问老师和各位同学这要怎么做？","like_count":0},{"had_liked":false,"id":345046,"user_name":"起风了","can_delete":false,"product_type":"c1","uid":1160219,"ip_address":"","ucode":"4356EDCECC612A","user_header":"https://static001.geekbang.org/account/avatar/00/11/b4/1b/5a8c0c11.jpg","comment_is_top":false,"comment_ctime":1651980731,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651980731","product_id":100017301,"comment_content":"拼图🧩：<br>1：先按照拼图背面颜色进行分类<br>2：再按拼图形状进行分类：区分边拼图和内部拼图<br>3：再看着指示图按颜色或特征进行分类<br>4：2、3步的结果就是分治算法中的小问题，可以很容易的解决<br>5：合并每个分类，就能完成整个拼图<br>","like_count":0},{"had_liked":false,"id":334578,"user_name":"申","can_delete":false,"product_type":"c1","uid":2033634,"ip_address":"","ucode":"CE7BFCF552B4F1","user_header":"https://static001.geekbang.org/account/avatar/00/1f/07/e2/32c9a634.jpg","comment_is_top":false,"comment_ctime":1645004249,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645004249","product_id":100017301,"comment_content":"归并前面看了两次，还手写了代码，今天看到又忘了，得回去重新看，这种怎么破(┬＿┬)？","like_count":0},{"had_liked":false,"id":332336,"user_name":"逗你玩😄","can_delete":false,"product_type":"c1","uid":1030242,"ip_address":"","ucode":"2E6309586B0363","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b8/62/60937bbd.jpg","comment_is_top":false,"comment_ctime":1643182109,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643182109","product_id":100017301,"comment_content":"java 8 的并行流用了fork join框架底层是分治思想","like_count":0},{"had_liked":false,"id":331979,"user_name":"恬毅","can_delete":false,"product_type":"c1","uid":1015240,"ip_address":"","ucode":"914ED16F3BE714","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/c8/e4727683.jpg","comment_is_top":false,"comment_ctime":1642938548,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642938548","product_id":100017301,"comment_content":"关于订单金额排序这块，可以做个大跟堆，计算好内存能支持的最大的数量，然后开始顺序加入大跟堆，大跟堆的size达到最大的数量以后，后续再加入数字，就需要和堆顶进行比较，如果小于堆顶，就讲堆顶pop，同时加入新的数据。这样遍历一遍，就可以保存最小的部分。然后第二部分就开始收集大于第一个大跟堆最大值的数字，这样再收集第二部分。","like_count":0},{"had_liked":false,"id":306504,"user_name":"Geek_842f07","can_delete":false,"product_type":"c1","uid":2698987,"ip_address":"","ucode":"ED772AF755FE7E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/WP4Ge8ABcINFkccKaNYKibicFnI0JAoojBBAUGrichNeRAgzm5RGbHG7GqYrFX3ELEzenuEbicQHJy2HZ72RxSOuMA/132","comment_is_top":false,"comment_ctime":1628586838,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628586838","product_id":100017301,"comment_content":"像快排等可以使用递归来解决的本质思想上都是利用了分治思想","like_count":0},{"had_liked":false,"id":305918,"user_name":"易飞","can_delete":false,"product_type":"c1","uid":2630424,"ip_address":"","ucode":"32AC28754237F7","user_header":"https://static001.geekbang.org/account/avatar/00/28/23/18/4284361f.jpg","comment_is_top":false,"comment_ctime":1628230908,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628230908","product_id":100017301,"comment_content":"文章里的2个问题不会。。","like_count":0},{"had_liked":false,"id":302893,"user_name":"小Y","can_delete":false,"product_type":"c1","uid":1739621,"ip_address":"","ucode":"24A43BB71805F8","user_header":"https://static001.geekbang.org/account/avatar/00/1a/8b/65/0f1f9a10.jpg","comment_is_top":false,"comment_ctime":1626425027,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626425027","product_id":100017301,"comment_content":"感觉目前章节为止利用分治思想的有很多：<br>1.归并排序<br>2.桶排序 # 桶之间<br>3.递归编程技巧<br>4.二分查找<br><br>emmm 剩下的 没记住。","like_count":0},{"had_liked":false,"id":298062,"user_name":"海崖","can_delete":false,"product_type":"c1","uid":2552745,"ip_address":"","ucode":"9D42E0B0D30A56","user_header":"https://static001.geekbang.org/account/avatar/00/26/f3/a9/bb9d8450.jpg","comment_is_top":false,"comment_ctime":1623899026,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623899026","product_id":100017301,"comment_content":"叮~打卡","like_count":0},{"had_liked":false,"id":296364,"user_name":"颜桦","can_delete":false,"product_type":"c1","uid":1099576,"ip_address":"","ucode":"1CD7250E052B32","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/38/d1a50cd6.jpg","comment_is_top":false,"comment_ctime":1622941432,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622941432","product_id":100017301,"comment_content":"全国人口普查，各省查各自的，然后分配到各个地级市，各区等等，最后逐层汇报，得到全国的人口数据","like_count":0},{"had_liked":false,"id":288643,"user_name":"退而结网","can_delete":false,"product_type":"c1","uid":1055867,"ip_address":"","ucode":"CA4375BADE311A","user_header":"https://static001.geekbang.org/account/avatar/00/10/1c/7b/d89ba212.jpg","comment_is_top":false,"comment_ctime":1618575695,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618575695","product_id":100017301,"comment_content":"比如说团队管理，下面小团队负责人负责本团队，上报工作给上层领导，一层一层往上到老板","like_count":0},{"had_liked":false,"id":281734,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1614864735,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1614864735","product_id":100017301,"comment_content":"重新阅读了一遍文章，发现分治思想是关键，难点在合并数据上，最后才是划分数据。因为可以分治在程序中，基本只需要满足子问题之间互不影响就OK了，否则怕是得考虑动态规划了","like_count":0},{"had_liked":false,"id":281067,"user_name":"罗耀龙@坐忘","can_delete":false,"product_type":"c1","uid":1917663,"ip_address":"","ucode":"3CEA258DE7F3C7","user_header":"https://static001.geekbang.org/account/avatar/00/1d/42/df/a034455d.jpg","comment_is_top":false,"comment_ctime":1614571313,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1614571313","product_id":100017301,"comment_content":"茶艺师学编程<br><br>思考题<br>在我现在的工作中，盘点仓库，是按分区一个一个区把物料给点完，再把结果给汇总，才反应过来这已经是分治了。<br>","like_count":0},{"had_liked":false,"id":274156,"user_name":"impossible","can_delete":false,"product_type":"c1","uid":1401467,"ip_address":"","ucode":"199D0066E2783E","user_header":"https://static001.geekbang.org/account/avatar/00/15/62/7b/01c7c4aa.jpg","comment_is_top":false,"comment_ctime":1610875932,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610875932","product_id":100017301,"comment_content":"汉武帝的推恩令政策也是分而治之的思想，通过不断的将诸侯王的土地分给他们的后代来达到中央集权的目的","like_count":0},{"had_liked":false,"id":273766,"user_name":"石小","can_delete":false,"product_type":"c1","uid":1781893,"ip_address":"","ucode":"4258C686F289A6","user_header":"https://static001.geekbang.org/account/avatar/00/1b/30/85/14c2f16c.jpg","comment_is_top":false,"comment_ctime":1610674137,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610674137","product_id":100017301,"comment_content":"怎么分析n个点找最近两个点的时间复杂度？","like_count":0},{"had_liked":false,"id":266603,"user_name":"Grocker","can_delete":false,"product_type":"c1","uid":2204462,"ip_address":"","ucode":"DF2E19A65DEAD6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/IY4fLqdVwCPlW7xJicz3nZm4OePT0o20tDZj1Hiauk2b0iaHMQcSOGpamLt9b72hYVG72sgRWic1BHY3uCvibWcfickw/132","comment_is_top":false,"comment_ctime":1607412290,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607412290","product_id":100017301,"comment_content":"看了这节课后，感觉目前在做的项目也用到了分治思想。<br>有个销售报表，分别需要按不同日期维度(天，周，月，季度，半年，年)查看销售额，销量...字段。由于订单量数据过大，无法实时从业务表查询出来。所以将这些每个维度销售报表归档起来单独放一张表，比如<br>day_sales,week_sales,month_sales...,按最小粒度的天维度归档，其他更大日期维度从小的日期维度归档。<br>周月-&gt;天，季度-&gt;月，半年-&gt;季度，年-&gt;半年。","like_count":0},{"had_liked":false,"id":251972,"user_name":"Yasha","can_delete":false,"product_type":"c1","uid":1803481,"ip_address":"","ucode":"CE9FC0773DD846","user_header":"https://static001.geekbang.org/account/avatar/00/1b/84/d9/55b3eb37.jpg","comment_is_top":false,"comment_ctime":1602028147,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602028147","product_id":100017301,"comment_content":"找到 L = min（left_min,right_min），拿到（mid-L,mid+L）的数据点，计算该数据点集内的距离，最短者为最优，否则为L。","like_count":0},{"had_liked":false,"id":247778,"user_name":"Dennis Lee","can_delete":false,"product_type":"c1","uid":1756691,"ip_address":"","ucode":"FDCF0CA72842AB","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ce/13/d6968545.jpg","comment_is_top":false,"comment_ctime":1599833997,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599833997","product_id":100017301,"comment_content":"大大有没有外部排序的代码实现可以分享呢，了解过外部排序的思想，但是没有看过实际的Java实现的排序代码","like_count":0},{"had_liked":false,"id":244650,"user_name":"鲨鱼爱喝茶","can_delete":false,"product_type":"c1","uid":1339018,"ip_address":"","ucode":"DA9D0BAB9EF16A","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8a/957137fc.jpg","comment_is_top":false,"comment_ctime":1598604547,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598604547","product_id":100017301,"comment_content":"关于求平面中的n个点中距离最近的点对，<br>我的想法是将平面看作坐标系，将n个点转成图，然后从最左上角的点开始按层遍历<br>遍历过程中计算相邻节点的距离，记录下每层中距离最短的点对<br>用分治思想来解的话没有思路","like_count":0},{"had_liked":false,"id":239415,"user_name":"天天向上卡索","can_delete":false,"product_type":"c1","uid":1009850,"ip_address":"","ucode":"E3724C3B39BD3F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/68/ba/c0cf8bf3.jpg","comment_is_top":false,"comment_ctime":1596527454,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596527454","product_id":100017301,"comment_content":"数据库查询的UNION查询属于分治思想吗？","like_count":0},{"had_liked":false,"id":228713,"user_name":"o0oi1i","can_delete":false,"product_type":"c1","uid":1132312,"ip_address":"","ucode":"D1F6AD4AAEAFBE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/18/293cd24d.jpg","comment_is_top":false,"comment_ctime":1592792474,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592792474","product_id":100017301,"comment_content":"打卡38","like_count":0},{"had_liked":false,"id":226725,"user_name":"Geek_69cfd7","can_delete":false,"product_type":"c1","uid":2007777,"ip_address":"","ucode":"BFC4B586FA65F7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/orTaVwTib3ribTl5wibBQPniclzNVJMXCDw4ic4P2Q3A6MBEyuqg5AY46o4SPmIKm8vgIqnUzzqbEhIfQRQBtY7q6JQ/132","comment_is_top":false,"comment_ctime":1592190296,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1592190296","product_id":100017301,"comment_content":"老师为啥不注明C是排序后的数组呢，有一点点让人误解","like_count":0},{"had_liked":false,"id":221141,"user_name":"刘易之","can_delete":false,"product_type":"c1","uid":1909024,"ip_address":"","ucode":"1CDC3E98B92CE3","user_header":"https://static001.geekbang.org/account/avatar/00/1d/21/20/d7f5bb18.jpg","comment_is_top":false,"comment_ctime":1590416276,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590416276","product_id":100017301,"comment_content":"公司组织架构就是典型的分治思想","like_count":0},{"had_liked":false,"id":219412,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1590024000,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1590024000","product_id":100017301,"comment_content":"抄了一遍文中的逆序对个数的题目，然后就去看 LeetCode 493. Reverse Pair，结果逆序的条件是大于 2 倍，感觉整个人都不对了。<br><br>按照归并排序的思路，参考其他人的答案，拼凑了一个，虽然能够通过，但是时间复杂度很差。<br><br>与之类似的还有 LeetCode 315. Count of Smaller Numbers After Self。<br><br>两道 LeetCode 的题目都是可以借用归并排序和 BST 的思路去做，比较巧妙和烧脑的地方就是在 merge 的时候如何得到想要的结果。<br><br>一开始没注意，后来看留言才发现了专栏中的金句“创新的源泉来自对事物本质的认识，无数优秀架构设计的思想来源都是基础的数据结构和算法”，希望我自己通读了专栏之后，境界也能提高一点。<br><br>文中的两个练习题，在有提示的情况下，想出解题思路并不难，但是写出代码就不那么容易了。<br><br>学习了 @建强 的留言，梳理了采用分治思想的算法：快排、合并排序、桶排、基数排序、二分查找、递归树、数据库分片、MapReduce","like_count":0},{"had_liked":false,"id":216469,"user_name":"宁悦","can_delete":false,"product_type":"c1","uid":1901403,"ip_address":"","ucode":"68844C314FEEF8","user_header":"https://static001.geekbang.org/account/avatar/00/1d/03/5b/3cdbc9fa.jpg","comment_is_top":false,"comment_ctime":1589266461,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589266461","product_id":100017301,"comment_content":"上学的时候，搞学校的卫生，班主任领完任务，分给班里的同学。就干完了","like_count":0},{"had_liked":false,"id":216445,"user_name":"前端男孩","can_delete":false,"product_type":"c1","uid":1541708,"ip_address":"","ucode":"58668020D2D5BD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/hkBfzo6cRvbBmFZKPxlzRnKyria9gzID4WQ9mI1NdBBox5lRox7eMuhicXPB7eU1ecOa0lD9fhNTG3H6yJlII50A/132","comment_is_top":false,"comment_ctime":1589261156,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589261156","product_id":100017301,"comment_content":"二分查找，归并排序，桶排序都是吸取了分治算法的思想吗？","like_count":0},{"had_liked":false,"id":216410,"user_name":"Allan","can_delete":false,"product_type":"c1","uid":1310388,"ip_address":"","ucode":"8DA4DBECC2C45C","user_header":"https://static001.geekbang.org/account/avatar/00/13/fe/b4/295338e7.jpg","comment_is_top":false,"comment_ctime":1589253522,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589253522","product_id":100017301,"comment_content":"60天攻克算法打卡行动第30天<br><br>学习内容 ：分治算法：谈一谈大规模计算框架MapReduce中的分治思想<br><br>分治算法是MapReduce的核心思想。掌握了分治算法的基础概念和应用场景，就能指导编码来降低问题求解的时间复杂度，以及解决海量数据处理问题。<br><br>1.如何理解分治算法？<br>大事化小分而治之原则<br>2.分治算法应用举例分析<br>求解逆序对个数，远古方式对比但是时间复杂度O(n^2);那么我们用分治算法来求解看看把A分成A1和A2，分别对A1和A2求逆序对，然后再计算A1与A2之间的逆序对。那么我举个例子：A = 7 5 6 8 2 4 12，分成A1 = 7 5 6 8 ，A2 = 2 4 12，我们分别求出k1=2，k2=0，那么我们再求A1与A2之间的逆序对，实际就是将A2的每一位与A1对比就可以了，省掉的部分是自己的A2因为k2已经是对比过的。所以得k3=8，最后A的逆序对就是k1+k2+k3=10。通过归并排序更加能够提高速度效率。<br>经典问题练习：<br>1、二维平面上有 n 个点，如何快速计算出两个距离最近的点对？<br>2、有两个 n*n 的矩阵 A，B，如何快速求解两个矩阵的乘积 C=A*B？<br><br>3.分治思想在海量数据处理中的应用<br>文中提到根据某种方法将大文件划成几个小文件，其实这个方法才是关键我个人觉得。很多时候面试会问你怎么做到这一步，只要做到了后面的就好处理了。<br><br>课后思考：<br>1、现在程序应用都是分布式的模式，告别了单机。微服务也可以了解一种分治算法。","like_count":0},{"had_liked":false,"id":213099,"user_name":"LiuJY","can_delete":false,"product_type":"c1","uid":1237786,"ip_address":"","ucode":"EE5176AD2C23BB","user_header":"https://static001.geekbang.org/account/avatar/00/12/e3/1a/7d571c39.jpg","comment_is_top":false,"comment_ctime":1588301255,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588301255","product_id":100017301,"comment_content":"上学分班、工作分组，好管理，效率高！","like_count":0},{"had_liked":false,"id":212886,"user_name":"社会你强哥","can_delete":false,"product_type":"c1","uid":1243570,"ip_address":"","ucode":"325B9005588D9B","user_header":"https://static001.geekbang.org/account/avatar/00/12/f9/b2/2ed800b4.jpg","comment_is_top":false,"comment_ctime":1588232627,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588232627","product_id":100017301,"comment_content":"老师能讲得细致一点么？当将一个字符串分解为2段，A，B，计算出A的逆序度和计算出B的逆序度，再将A和B分别进行排序，是不影响A和B之间的逆序度。针对K1 + K2 + K3，具有分解终止条件，也就是说，当问题足够小时，可以直接求解；归并排序，当只有一个元素的时候K1 = 0， K2 = 0， K3=0或者等于1，然后返回。我能够理解你的代码，但是感觉你的铺垫还不够，希望你对照着分治思想的条件来讲。","like_count":0},{"had_liked":false,"id":207503,"user_name":"喻茂","can_delete":false,"product_type":"c1","uid":1318661,"ip_address":"","ucode":"C8BD8086A17365","user_header":"https://static001.geekbang.org/account/avatar/00/14/1f/05/8a06692e.jpg","comment_is_top":false,"comment_ctime":1587095137,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587095137","product_id":100017301,"comment_content":"&lt;?php<br>&#47;&#47; 获取逆序度<br>function nixuduCount(&amp;$arr) {<br>\t$n = count($arr);<br>\treturn mergeSortCounting($arr,0,$n-1);<br>}<br><br>function mergeSortCounting(&amp;$arr,$p,$r) {<br>\tif ($p &gt;= $r) { &#47;&#47; 已经是最小粒度，递归结束<br>\t\treturn 0;<br>\t}<br><br>\t&#47;&#47; 取$p到$r之间的中间位置$q<br>\t$q = intval(($p + $r) &#47; 2);<br>\t$num1 = mergeSortCounting($arr,$p,$q);<br>\t$num2 = mergeSortCounting($arr,$p,$q);<br>\t$num3 = merge($arr,$p,$q,$q+1,$r);<br>\treturn $num1+$num2+$num3;<br>}<br><br>function merge(&amp;$arr,$leftS,$leftE,$rightS,$rightE) {<br>\t$tmpArr = [];<br>\t$i = $leftS;<br>\t$j = $rightS;<br>\t$num = 0;<br>\twhile($i&lt;=$leftE &amp;&amp; $j&lt;=$rightE) {<br>\t\tif ($arr[$i] &lt;= $arr[$j]) {<br>\t\t\t$tmpArr[] = $arr[$i];<br>\t\t\t$i++;<br>\t\t} else {<br>\t\t\t$num += ($leftE-$i+1);<br>\t\t\t$tmpArr[] = $arr[$j];<br>\t\t\t$j++;<br>\t\t\t<br>\t\t}<br>\t}<br>\t<br>\t&#47;&#47; 哪个子数组中有数据剩余直接追加到最后<br>\tfor(;$i&lt;=$leftE;$i++) {<br>\t\t$tmpArr[] = $arr[$i];<br>\t}<br>\t<br>\tfor(;$j&lt;=$rightE;$j++) {<br>\t\t$tmpArr[] = $arr[$j];<br>\t}<br><br>\t&#47;&#47; 临时表中数据写回到原数组<br>\tforeach($tmpArr as $key =&gt; $val) {<br>\t\t$arr[$leftS+$key] = $val;<br>\t}<br>\t<br>\treturn $num;<br>}<br><br>$testArr = [1,5,6,2,3,4];<br>var_dump(nixuduCount($testArr));","like_count":0},{"had_liked":false,"id":204968,"user_name":"侧耳倾听","can_delete":false,"product_type":"c1","uid":1512642,"ip_address":"","ucode":"5BF2A2440B54F0","user_header":"https://static001.geekbang.org/account/avatar/00/17/14/c2/46ebe3a0.jpg","comment_is_top":false,"comment_ctime":1586502115,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1586502115","product_id":100017301,"comment_content":"关于二维平面最近点对的思考题，恕我愚钝，请老师指点。<br>分治算法的规则之一是要求两部分子集没有关联关系。但是如果简单的点分割的话，a和b之间存在着关系，分割线附近的点有可能是最近点，那么你说的分治算法思路能否指点一下，谢谢","like_count":0},{"had_liked":false,"id":201600,"user_name":"蜗牛","can_delete":false,"product_type":"c1","uid":1086220,"ip_address":"","ucode":"01CC18F12E556D","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/0c/0a6a0d5e.jpg","comment_is_top":false,"comment_ctime":1585810125,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585810125","product_id":100017301,"comment_content":"递归排序，快速排序。生活中的做<br>计划：大目标-&gt;中目标-&gt;小目标-&gt;可执行的目标。<br>做任务拆分：年度任务-&gt;月度任务-&gt;周任务-&gt;日任务。<br><br>","like_count":0},{"had_liked":false,"id":195884,"user_name":"邢世宝","can_delete":false,"product_type":"c1","uid":1113854,"ip_address":"","ucode":"7A58863FC89052","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/fe/12638c5b.jpg","comment_is_top":false,"comment_ctime":1585221065,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585221065","product_id":100017301,"comment_content":"快排就是分支的思想<br><br>生活中我们要达成一个目标，都要做任务拆解，任务够小，才好着手完成，这个就是分而治之的思想，不过没有merge的过程","like_count":0},{"had_liked":false,"id":192895,"user_name":"你曾是少年","can_delete":false,"product_type":"c1","uid":1326701,"ip_address":"","ucode":"83BBA0754EA1C9","user_header":"https://static001.geekbang.org/account/avatar/00/14/3e/6d/323995f4.jpg","comment_is_top":false,"comment_ctime":1584877839,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584877839","product_id":100017301,"comment_content":"再看一遍","like_count":0},{"had_liked":false,"id":184742,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1583395170,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583395170","product_id":100017301,"comment_content":"今天学习的是分治算法<br>总结如下：<br>分治算法产生的原因或者叫主要目的就是为了解决大量数据问题，采用的核心思想是分而治之，就是将一个大的问题分解成n个小的问题 最后合并分解结果<br>从核心思想分析得出分治算法的使用条件:<br>1. 子问题必须要和原问题有相同的处理模式<br>2. 子问题的结果不能影响另外的子问题的结果<br>3. 子问题进行合并成的耗时不能太长，不然会影响算法的效率<br>4. 具有分解的终止条件，也就是当问题足够小时能直接返回结果(不然会一直递归下去)<br>分治算法的应用如下<br>1. 排序算法中的 快排 归并排序 二分<br>2.  还有提到的mapreduce<br>3. 生活中最明显的情况就是工作 分配","like_count":0},{"had_liked":false,"id":176300,"user_name":"发霉的宅大人","can_delete":false,"product_type":"c1","uid":1738243,"ip_address":"","ucode":"6757E30FE5E48D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/03/95004954.jpg","comment_is_top":false,"comment_ctime":1581008672,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581008672","product_id":100017301,"comment_content":"分治思想——分而治之，我自己的理解就是大事化小。<br>亿级数据处理困难，百个数据总还是会的。<br>把一亿个数据分成10000个一万个，100万个100个数据和处理，再合并；","like_count":0},{"had_liked":false,"id":173122,"user_name":"夜空咏叹调","can_delete":false,"product_type":"c1","uid":1189074,"ip_address":"","ucode":"CC9350BCF218CD","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/d2/a5e272ce.jpg","comment_is_top":false,"comment_ctime":1579427935,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579427935","product_id":100017301,"comment_content":"分治算法的思路就是把一个任务分解成多个模式一样的子任务，然后当子任务拆的足够小就开始求解。<br>分治一般分三步，分离，求解，合并。<br>总的来说就是一个将大化小的思路，当一个任务已经大到机器没法承受求解的地步，我们就先将其拆解成我们能接受（以前见过的）任务，而对于见过的东西，一般都知道怎么求解，然后在把得到的东西组合，以达到最终答案。这个其实和我们实际生活中解决复杂问题是一样的思路。","like_count":0},{"had_liked":false,"id":172266,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1015754,"ip_address":"","ucode":"00DF2FEC58D2E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","comment_is_top":false,"comment_ctime":1579142821,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1579142821","product_id":100017301,"comment_content":"老师，大家好，我有个疑问：本节课程中的实例代码程序，是不是省略了对每个小数组进行排序的逻辑？","like_count":0,"discussions":[{"author":{"id":1516010,"avatar":"https://static001.geekbang.org/account/avatar/00/17/21/ea/2cfb9144.jpg","nickname":"auko","note":"","ucode":"7E3AA25B2D250F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":166205,"discussion_content":"你可以当做这就是在归并排序 , 顺便统计了逆序数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581353038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1665239,"avatar":"https://static001.geekbang.org/account/avatar/00/19/68/d7/499f23ec.jpg","nickname":"MXQ","note":"","ucode":"7104D0B5D025AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":162327,"discussion_content":"排序和逆序对统计都是在merge函数中完成的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580985390,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170823,"user_name":"艾尔欧唯伊","can_delete":false,"product_type":"c1","uid":1139716,"ip_address":"","ucode":"5BD50691342461","user_header":"https://static001.geekbang.org/account/avatar/00/11/64/04/18875529.jpg","comment_is_top":false,"comment_ctime":1578731766,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578731766","product_id":100017301,"comment_content":"请问一下，合并的时候使用排序的话，是不是就修改了原来的数据的顺序...但原需求只是求逆序对","like_count":0},{"had_liked":false,"id":169478,"user_name":"SteveYang","can_delete":false,"product_type":"c1","uid":1754829,"ip_address":"","ucode":"C42BCA4F40A9EF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKCbnOvEatUN4ysE2cl6zJNoAJVXXuQVhicQ1jxh6Z2Towrmmc1I6PndaicuQQ0RyyJPyJQicv4tSib9Q/132","comment_is_top":false,"comment_ctime":1578362403,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578362403","product_id":100017301,"comment_content":"前面讲过的算法用到分治算法的有：快速排序，归并排序，桶排序，二分查找等。","like_count":0},{"had_liked":false,"id":167035,"user_name":"港","can_delete":false,"product_type":"c1","uid":1122464,"ip_address":"","ucode":"35931FC6198180","user_header":"https://static001.geekbang.org/account/avatar/00/11/20/a0/1fca96c0.jpg","comment_is_top":false,"comment_ctime":1577675638,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577675638","product_id":100017301,"comment_content":"以前所讲的内容中，分治思想的应用有哈希算法中所讲的数据分片、分布式存储以及文件分块进行数据校验。工作中我们经常需要将大目标分解成小目标，公司的目标会逐层分解到个人成为个人的目标，这也是一种分治","like_count":0},{"had_liked":false,"id":166311,"user_name":"元","can_delete":false,"product_type":"c1","uid":1717444,"ip_address":"","ucode":"4576E15018EEA3","user_header":"https://static001.geekbang.org/account/avatar/00/1a/34/c4/08d9f349.jpg","comment_is_top":false,"comment_ctime":1577437038,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577437038","product_id":100017301,"comment_content":"static _findNearestPoints2(points: any[], left, right): Line {<br>\t\t&#47;&#47; &lt;= 2 个点<br>\t\tif (left == right)<br>\t\t\treturn null;<br>\t\tif (left + 1 &gt;= right)<br>\t\t\treturn new Line(points[left], points[right]);<br><br>\t\tlet mid = left + Math.floor((right - left) &gt;&gt; 2);<br>\t\tlet l1 = this._findNearestPoints2(points, left, mid);<br>\t\tlet l2 = this._findNearestPoints2(points, mid + 1, right);<br><br>\t\tlet dis1 = Number.MAX_VALUE, dis2 = Number.MAX_VALUE;<br>\t\tif (l1) dis1 = l1.dis; &#47;&#47; PS:未开平方的dis<br>\t\tif (l2) dis2 = l2.dis;<br><br>\t\tlet minDis = Math.min(dis1, dis2);<br>\t\t<br>\t\tlet minL = minDis == dis1 ? l1 : l2;<br>\t\tfor (let i = left; i &lt;= mid; i++) {<br>\t\t\tfor (let j = mid + 1; j &lt;= right; j++) {<br>\t\t\t\tlet dx = points[i].x - points[j].x;<br>\t\t\t\tlet dy = points[i].y - points[j].y;<br>\t\t\t\tlet dis = dx * dx + dy * dy;<br>\t\t\t\tif (dis &lt;= minDis) {<br>\t\t\t\t\tminDis = dis;<br>\t\t\t\t\tminL = new Line(points[i], points[j]);<br>\t\t\t\t}<br>\t\t\t}<br>\t\t}<br><br>\t\treturn minL;<br>\t}<br><br>思考题，求平面最近点对，求教，错在哪？为什么分治算法比暴力法耗时多，意义何在呢？","like_count":0},{"had_liked":false,"id":165017,"user_name":"梦想的优惠券","can_delete":false,"product_type":"c1","uid":1257418,"ip_address":"","ucode":"D3B44F6C618CA7","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/ca/cbce6e94.jpg","comment_is_top":false,"comment_ctime":1577148234,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1577148234","product_id":100017301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":164655,"user_name":"阿冰777","can_delete":false,"product_type":"c1","uid":1373893,"ip_address":"","ucode":"F365EB44F971F3","user_header":"https://static001.geekbang.org/account/avatar/00/14/f6/c5/6329ddcc.jpg","comment_is_top":false,"comment_ctime":1577066887,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1577066887","product_id":100017301,"comment_content":"上学的时候，每组小组长收作业，再合并，就是分治。<br>现在工作，将不同的任务分发给不同的开发，最后再merge，也是分治。","like_count":0},{"had_liked":false,"id":163365,"user_name":"千锤百炼的大器","can_delete":false,"product_type":"c1","uid":1528160,"ip_address":"","ucode":"4DE6083592C80D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/vopk2JZ3QqRytUbiaiacj1yIytM4VTvE9xxaLnv5ozYug77KcC2gDzgEcd0Gu9L871ibfErFGC725Ria14xXqUdYibg/132","comment_is_top":false,"comment_ctime":1576713664,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576713664","product_id":100017301,"comment_content":"二维和一维不同在于，一维通过大小就可以分成2组，然后排序，二维需要2个点进行划分，找到组的中心点再分成4组，合并时如何排序呢？","like_count":0},{"had_liked":false,"id":160292,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1575906338,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575906338","product_id":100017301,"comment_content":"今日学习内容：分治算法的思想<br><br>分制的关键是：<br>1.求解的问题可以分解为更小的问题。<br>2.分解后的问题可以独立求解<br>3.分解有边界，而不是无限分下去<br>4.小问题的解可以合并为最终的解<br><br>练习题：<br>1.二维平面有n个点，求举例最近的点。<br>暴力解法：<br>拿每个点和其他点的距离对比<br>找到最短的那个。<br>依次比较的次数是：<br>n-1,n-2....1  <br>相加时间复杂度是O（n^2）<br><br>代码实现关键：<br>每个点用一个二维坐标表示：（x,y）<br>可以用一个hash表，key是该点的序号,值是<br>横坐标和纵坐标组成的数组[x,y].<br>距离计算公式：A(x,y) B(x1,y1)<br>distance[A-B] = (x-x1)^2+(y-y1)^2<br><br>复杂度更低的解法：还未想到，待思考<br><br>2.矩阵的运算：暂未找到解法<br><br>-<br>思考：<br>服务架构从单体，演化到SOA，再细分<br>到微服务架构，本质就是分治的思想。<br>再比如开发中前后端分离，前端开发中<br>MVC、MVVM模式以及Android开发中<br>MVP视图控制器的分层都是该思想。","like_count":0},{"had_liked":false,"id":159467,"user_name":"百里","can_delete":false,"product_type":"c1","uid":1212873,"ip_address":"","ucode":"2CE96129AA7F78","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/c9/9194612b.jpg","comment_is_top":false,"comment_ctime":1575630985,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575630985","product_id":100017301,"comment_content":"2000年前始皇帝就使用了分治思想一统华夏. 从中央下派地方官,这是分解过程, 然后地方官治理九州大地, 然后再向上汇报地方情况,如赋税,民情都需要一级一级向上汇报,直到皇帝那里.这是合的操作.","like_count":0},{"had_liked":false,"id":156636,"user_name":"水手","can_delete":false,"product_type":"c1","uid":1336430,"ip_address":"","ucode":"536BB54E1E3617","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/6e/e5ecc1d2.jpg","comment_is_top":false,"comment_ctime":1574927619,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574927619","product_id":100017301,"comment_content":"拼图的过程类似分治算法吧，每次先拼出某一部分，然后逐渐合并完整的图，不知道这样理解有问题不","like_count":0},{"had_liked":false,"id":154247,"user_name":"乾坤瞬间","can_delete":false,"product_type":"c1","uid":1683130,"ip_address":"","ucode":"15BDCF29CBF8EB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","comment_is_top":false,"comment_ctime":1574396564,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574396564","product_id":100017301,"comment_content":"在进行归并排序，二分搜索的时候利用了分而治之的思想<br><br>分而治之，我觉得在工作中要完成一个大项目，我们都会把这个大项目拆分成几个相互独立的模块，然后让各个负责模块的部门取完成。。起床的时候边刷牙边上厕所。。","like_count":0},{"had_liked":false,"id":154241,"user_name":"Ethan","can_delete":false,"product_type":"c1","uid":1246139,"ip_address":"","ucode":"ED197A378EE91B","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/bb/c5f139cc.jpg","comment_is_top":false,"comment_ctime":1574395108,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574395108","product_id":100017301,"comment_content":"学习笔记：<br>什么是分治算法？<br>分治算法（divide and conquer）的核心思想其实就是四个字，分而治之 ，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。<br>分治算法应用<br>如何编程求出一组数据的有序对个数或者逆序对个数呢？<br>什么是逆序对？<br>假如一组数据：2,5,3,7,1<br>我们定义从小到大排序是有序的，那么逆序对就是无序对的个数<br>遍历每一个元素，与后面的元素对比，看有几个比它小的，无序对为 (2,1)（5,3）(5,1) (3,1) (7,1)，所以这组数据的逆序对有5个。<br>遍历的方法可以求出逆序对，但是这样操作的时间复杂度是 O(n^2)。<br><br>套用分治的思想来求数组 A 的逆序对个数。我们可以将数组分成前后两半 A1 和 A2，分别计算 A1 和 A2 的逆序对个数 K1 和 K2，然后再计算 A1 与 A2 之间的逆序对个数 K3。那数组 A 的逆序对个数就等于 K1+K2+K3。<br><br>借助归并排序算法实现：归并排序中有一个非常关键的操作，就是将两个有序的小数组，合并成一个有序的数组。假设归并：1,5,6,2,3,4<br><br>private int num = 0; &#47;&#47; 全局变量或者成员变量，记录逆序对<br><br>public int count(int[] a, int n) {<br>  num = 0;<br>  mergeSortCounting(a, 0, n-1);&#47;&#47;合并有序数组<br>  return num;<br>}<br><br>private void mergeSortCounting(int[] a, int p, int r) {<br>  if (p &gt;= r) return;<br>  int q = (p+r)&#47;2;<br>  mergeSortCounting(a, p, q);<br>  mergeSortCounting(a, q+1, r);<br>  merge(a, p, q, r);<br>}<br><br>private void merge(int[] a, int p, int q, int r) {<br>  int i = p, j = q+1, k = 0;<br>  int[] tmp = new int[r-p+1];<br>  while (i&lt;=q &amp;&amp; j&lt;=r) {<br>    if (a[i] &lt;= a[j]) {<br>      tmp[k++] = a[i++];<br>    } else {<br>      num += (q-i+1); &#47;&#47; 统计p-q之间，比a[j]大的元素个数，即a[i]到a[q]的的数量<br>      tmp[k++] = a[j++];<br>    }<br>  }<br>  while (i &lt;= q) { &#47;&#47; 处理剩下的<br>    tmp[k++] = a[i++];<br>  }<br>  while (j &lt;= r) { &#47;&#47; 处理剩下的<br>    tmp[k++] = a[j++];<br>  }<br>  for (i = 0; i &lt;= r-p; ++i) { &#47;&#47; 从tmp拷贝回a<br>    a[p+i] = tmp[i];<br>  }<br>}<br>二维平面上有 n 个点，如何快速计算出两个距离最近的点对？<br>有两个 n*n 的矩阵 A，B，如何快速求解两个矩阵的乘积 C=A*B？<br>思考题有点难度，课后查阅<br>应用：桶排序，递归排序，归并排序<br>    tmp[k++] = a[i++];<br>  }<br>  while (j &lt;= r) { &#47;&#47; 处理剩下的<br>    tmp[k++] = a[j++];<br>  }<br>  for (i = 0; i &lt;= r-p; ++i) { &#47;&#47; 从tmp拷贝回a<br>    a[p+i] = tmp[i];<br>  }<br>}<br>应用：桶排序，递归排序，归并排序","like_count":0},{"had_liked":false,"id":149312,"user_name":"Hwan","can_delete":false,"product_type":"c1","uid":1205627,"ip_address":"","ucode":"A728C6790511BD","user_header":"https://static001.geekbang.org/account/avatar/00/12/65/7b/66b9befd.jpg","comment_is_top":false,"comment_ctime":1573189682,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573189682","product_id":100017301,"comment_content":"二分查找，还有刚才的那个人口统计超级典型，哈哈","like_count":0},{"had_liked":false,"id":146144,"user_name":"晓杉","can_delete":false,"product_type":"c1","uid":1209336,"ip_address":"","ucode":"19E634BB61A165","user_header":"https://static001.geekbang.org/account/avatar/00/12/73/f8/dbd2fa50.jpg","comment_is_top":false,"comment_ctime":1572439711,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1572439711","product_id":100017301,"comment_content":"写这篇文章也是分治算法，将文章按内容分为不同的小节，一个小节一个小节完成，组合到一起成为完整的文章。","like_count":0,"discussions":[{"author":{"id":1683130,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","nickname":"乾坤瞬间","note":"","ucode":"15BDCF29CBF8EB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55783,"discussion_content":"我觉得这个你的说法是有问题，如果写文章把每个内容分割成小节的话，现在分治思想的角度，每个小节直接内容是不会互相影响的，然而老师的每篇文章都或多或少地与其他小节有关联，所以这并不是分治思想的体现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574398289,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146139,"user_name":"晓杉","can_delete":false,"product_type":"c1","uid":1209336,"ip_address":"","ucode":"19E634BB61A165","user_header":"https://static001.geekbang.org/account/avatar/00/12/73/f8/dbd2fa50.jpg","comment_is_top":false,"comment_ctime":1572439297,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572439297","product_id":100017301,"comment_content":"坚信，只有从事物的本质出发，才能够融会贯通。<br>否则只能被新技术牵着鼻子走。","like_count":0},{"had_liked":false,"id":144719,"user_name":"Elza Wong","can_delete":false,"product_type":"c1","uid":1243487,"ip_address":"","ucode":"F84D58E873E0D0","user_header":"https://static001.geekbang.org/account/avatar/00/12/f9/5f/60689bb3.jpg","comment_is_top":false,"comment_ctime":1572008274,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572008274","product_id":100017301,"comment_content":"派发邮件；快递这些都是分治思想；","like_count":0},{"had_liked":false,"id":142729,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1571481790,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1571481790","product_id":100017301,"comment_content":"package geekbang.u38;<br><br>import tools.ArrayGenerator;<br>import tools.PrintUtil;<br><br>&#47;**<br> * Created by HuGuodong on 2019-10-19.<br> *&#47;<br>public class InversionNumber {<br><br>  private static int[] aux;<br>  private static int cnt = 0;<br><br><br>  public static void sort(int[] a) {<br>    aux = new int[a.length];<br>    sort(a, 0, a.length - 1);<br>  }<br><br>  public static void sort(int[] a, int lo, int hi) {<br>    if (hi &lt;= lo) {<br>      return;<br>    }<br>    int mid = lo + (hi - lo) &#47;2;<br>    sort(a, lo, mid);<br>    sort(a, mid + 1, hi);<br>    mergeCount(a, lo, mid, hi);<br>  }<br><br>  public static void mergeCount(int[] a, int lo, int mid, int hi) {<br>    int i = lo, j = mid + 1;<br>    for (int k = lo; k &lt;= hi; k++) {<br>      aux[k] = a[k];<br>    }<br>    int num = 0;<br>    for (int k = lo; k &lt;= hi; k++) {<br>      if (i &gt; mid)<br>        a[k] = aux[j++];<br>      else if (j &gt; hi){<br>        a[k] = aux[i++];<br>      }<br>      else if (aux[i] &lt;= aux[j]){<br>        a[k] = aux[i++];&#47;&#47; aux!!!<br>      }else{<br>        a[k] = aux[j++];<br>        cnt += mid -i + 1; &#47;&#47; mid 与 i之间 大于 a[j]的个数<br>      }<br>    }<br>  }<br><br>  public static void main(String[] args) {<br>&#47;&#47;    int[] a = ArrayGenerator.randomIntsArray(10);<br>&#47;&#47;    int[] a = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1};<br>&#47;&#47;    int[] a = {3,2,1,4};<br>    int[] a= {4,5,6,1,2,3};<br>    PrintUtil.show(a);<br>    sort(a);<br>    PrintUtil.show(a);<br>    System.out.println(cnt);<br>  }<br>}<br>","like_count":0},{"had_liked":false,"id":142728,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1571481739,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1571481739","product_id":100017301,"comment_content":"package geekbang.u38;<br><br>import tools.ArrayGenerator;<br>import tools.PrintUtil;<br><br>&#47;**<br> * Created by HuGuodong on 2019-10-19.<br> *&#47;<br>public class InversionNumber {<br><br>  private static int[] aux;<br>  private static int cnt = 0;<br><br><br>  public static void sort(int[] a) {<br>    aux = new int[a.length];<br>    sort(a, 0, a.length - 1);<br>  }<br><br>  public static void sort(int[] a, int lo, int hi) {<br>    if (hi &lt;= lo) {<br>      return;<br>    }<br>    int mid = lo + (hi - lo) &#47;2;<br>    sort(a, lo, mid);<br>    sort(a, mid + 1, hi);<br>    mergeCount(a, lo, mid, hi);<br>  }<br><br>  public static void mergeCount(int[] a, int lo, int mid, int hi) {<br>    int i = lo, j = mid + 1;<br>    for (int k = lo; k &lt;= hi; k++) {<br>      aux[k] = a[k];<br>    }<br>    int num = 0;<br>    for (int k = lo; k &lt;= hi; k++) {<br>      if (i &gt; mid)<br>        a[k] = aux[j++];<br>      else if (j &gt; hi){<br>        a[k] = aux[i++];<br>      }<br>      else if (aux[i] &lt;= aux[j]){<br>        a[k] = aux[i++];&#47;&#47; aux!!!<br>      }else{<br>        a[k] = aux[j++];<br>        cnt += mid -i + 1; &#47;&#47; mid 与 i之间 大于 a[j]的个数<br>      }<br>    }<br>  }<br><br>  public static void main(String[] args) {<br>&#47;&#47;    int[] a = ArrayGenerator.randomIntsArray(10);<br>&#47;&#47;    int[] a = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1};<br>&#47;&#47;    int[] a = {3,2,1,4};<br>    int[] a= {4,5,6,1,2,3};<br>    PrintUtil.show(a);<br>    sort(a);<br>    PrintUtil.show(a);<br>    System.out.println(cnt);<br>  }<br>}<br>","like_count":0},{"had_liked":false,"id":138374,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1570182421,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570182421","product_id":100017301,"comment_content":"创新并非离我们很远，创新的源泉来自对事物本质的认识。","like_count":0},{"had_liked":false,"id":136207,"user_name":"junjun","can_delete":false,"product_type":"c1","uid":1547322,"ip_address":"","ucode":"1F7EE146B9BE04","user_header":"https://static001.geekbang.org/account/avatar/00/17/9c/3a/bfd73920.jpg","comment_is_top":false,"comment_ctime":1569382289,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569382289","product_id":100017301,"comment_content":"大而化小，分而治之","like_count":0},{"had_liked":false,"id":133627,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1568624186,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568624186","product_id":100017301,"comment_content":"说起来容易，问中间的两个思考题好难啊，","like_count":0},{"had_liked":false,"id":133319,"user_name":"saber","can_delete":false,"product_type":"c1","uid":1193468,"ip_address":"","ucode":"D02F8D129DB41C","user_header":"https://static001.geekbang.org/account/avatar/00/12/35/fc/6d3e0035.jpg","comment_is_top":false,"comment_ctime":1568515782,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568515782","product_id":100017301,"comment_content":"花了 3 个小时，终于用 c++ 实现了求解一组数据的有序对和逆序对数<br>https:&#47;&#47;github.com&#47;saber&#47;algorithm&#47;blob&#47;master&#47;src&#47;divide_and_conquer&#47;divide_and_conquer.hpp","like_count":0},{"had_liked":false,"id":131292,"user_name":"行者","can_delete":false,"product_type":"c1","uid":1321657,"ip_address":"","ucode":"DEC93AEA7D280A","user_header":"https://static001.geekbang.org/account/avatar/00/14/2a/b9/00b35168.jpg","comment_is_top":false,"comment_ctime":1567696498,"is_pvip":false,"replies":[{"id":"49801","content":"可以去算法导论，dp那一节课里有讲到矩阵乘法","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1567724329,"ip_address":"","comment_id":131292,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567696498","product_id":100017301,"comment_content":"老师，我前两个留言想说的是您文中说到的两个经典的分治算法的例子，不是思考题。一方面想问一下在您的github上有没有代码实现（这个您在回复我上一条留言中已经给了github地址了），另一方面是想问一下3×3阶矩阵相乘的话，可不可以用分治的思想去做呢？您的例子是n×n，n不必是2的倍数吗？如果可以的话，您能不能详细讲一讲3×3阶矩阵相乘怎么做。<br>我同学面试的时候面试官问到了这个问题，但他当时除了3个for循环，也没想出什么比较好的方法。我们讨论的时候，也没想出来","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466374,"discussion_content":"可以去算法导论，dp那一节课里有讲到矩阵乘法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567724329,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128470,"user_name":"行者","can_delete":false,"product_type":"c1","uid":1321657,"ip_address":"","ucode":"DEC93AEA7D280A","user_header":"https://static001.geekbang.org/account/avatar/00/14/2a/b9/00b35168.jpg","comment_is_top":false,"comment_ctime":1566885071,"is_pvip":false,"replies":[{"id":"48493","content":"不要求必须是2的倍数，3*3的可以分解为一个1*1，一个2*2的吧。不过，亲，这篇文章没有说到什么矩阵分治呀？能具体点吗？","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1567378878,"ip_address":"","comment_id":128470,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566885071","product_id":100017301,"comment_content":"3x3阶矩阵怎么用分治做呢？nxn阶，是要求n必须为2的整数倍吗<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464960,"discussion_content":"不要求必须是2的倍数，3*3的可以分解为一个1*1，一个2*2的吧。不过，亲，这篇文章没有说到什么矩阵分治呀？能具体点吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567378878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128454,"user_name":"行者","can_delete":false,"product_type":"c1","uid":1321657,"ip_address":"","ucode":"DEC93AEA7D280A","user_header":"https://static001.geekbang.org/account/avatar/00/14/2a/b9/00b35168.jpg","comment_is_top":false,"comment_ctime":1566882386,"is_pvip":false,"replies":[{"id":"48478","content":"github：https:&#47;&#47;github.com&#47;wangzheng0822&#47;algo<br><br>不过这节课的思考题是一个开放性问题呀，你是不是看错了呢","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1567377644,"ip_address":"","comment_id":128454,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566882386","product_id":100017301,"comment_content":"老师，这节课的思考题很有价值，但是想了半天没有好的思路啊，你的GitHub上有代码实现吗？有时间的话，还请老师亲自做一下这两个题目","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464950,"discussion_content":"github：https://github.com/wangzheng0822/algo\n\n不过这节课的思考题是一个开放性问题呀，你是不是看错了呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567377644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118805,"user_name":"龙须子","can_delete":false,"product_type":"c1","uid":1485466,"ip_address":"","ucode":"EADE91691B4A40","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIahDan9ibN8uCqDo8WY1Nb9vJd9yrUtmC9XHibSO1PichUaPWR8sIjfdNvSpOqN28Cw1ibYztoZF10ibg/132","comment_is_top":false,"comment_ctime":1564448816,"is_pvip":false,"replies":[{"id":"43668","content":"不要一次性加载到内存中处理。边读文件边统计。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1564530014,"ip_address":"","comment_id":118805,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1564448816","product_id":100017301,"comment_content":"很好奇，10G的文件，内存只有2G或者3G，怎样做到提前扫描一遍订单金额区间？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460588,"discussion_content":"不要一次性加载到内存中处理。边读文件边统计。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564530014,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93795,"user_name":"刘冬","can_delete":false,"product_type":"c1","uid":1401797,"ip_address":"","ucode":"982676C96C0EB4","user_header":"https://static001.geekbang.org/account/avatar/00/15/63/c5/a85ade71.jpg","comment_is_top":false,"comment_ctime":1557615101,"is_pvip":false,"replies":[{"id":"33863","content":"你理解的有点问题，你可以自己举几个例子，debug一下看下。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1557882260,"ip_address":"","comment_id":93795,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557615101","product_id":100017301,"comment_content":"王老师，我觉得利用merge sort找逆序对个数的代码，最后3行，就是讲tmp[]拷贝回a[]这个操作，应该是不需要的。在排序过程中，tmp[]是有序的，a[]是不变的。那么partition之后，应该使用原始的数组一份而二的2个子数组来分别找各自的逆序对。应该用原始的数据。tmp[]拷贝之后，对有序的做判断，值为0。实际上，我觉得根本就不需要tmp[]这个辅助数组。<br>不知道我的理解是否正确，还请王老师看一下。谢谢！","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449774,"discussion_content":"你理解的有点问题，你可以自己举几个例子，debug一下看下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557882260,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90235,"user_name":"哈哈","can_delete":false,"product_type":"c1","uid":1240120,"ip_address":"","ucode":"8B6D697CE6C83D","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/38/c7819759.jpg","comment_is_top":false,"comment_ctime":1556455584,"is_pvip":false,"replies":[{"id":"32368","content":"算的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1556502475,"ip_address":"","comment_id":90235,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1556455584","product_id":100017301,"comment_content":"快排算不算分治呢? 好像只有分, 没有合","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448433,"discussion_content":"算的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556502475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1205036,"avatar":"","nickname":"Dym","note":"","ucode":"7E521F01A4D823","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":36339,"discussion_content":"分到最后就是最开始问题的解，所以不需再将子问题的解结果合起来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571364735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":80827,"user_name":"LEO","can_delete":false,"product_type":"c1","uid":1396809,"ip_address":"","ucode":"4268DB35C3F3E9","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/49/898cb635.jpg","comment_is_top":false,"comment_ctime":1553739087,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553739087","product_id":100017301,"comment_content":"老师，请问计算机是怎么扫描文件的？能大概跟我讲一下流程吗？我的理解是计算机先加载10g的大文件到内存，再进行扫描和按区分成一个个小文件，是不是不对呀？","like_count":0},{"had_liked":false,"id":80776,"user_name":"LEO","can_delete":false,"product_type":"c1","uid":1396809,"ip_address":"","ucode":"4268DB35C3F3E9","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/49/898cb635.jpg","comment_is_top":false,"comment_ctime":1553733295,"is_pvip":false,"replies":[{"id":"29374","content":"单机，订单在文件中存储，处理的过程也是边扫描文件边生成小文件","user_name":"作者回复","user_name_real":"王争-公众号小争哥","uid":"1190123","ctime":1553736472,"ip_address":"","comment_id":80776,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553733295","product_id":100017301,"comment_content":"老师，10g订单那个例子我有一个疑问，就是文中提到先扫描10g订单并按区间将订单分在不同的小文件中，我想请问这个过程怎么在内存只有2-3g的机器上进行的呢？还是说您指得不是在单机上，而是在集群上进行的？麻烦老师解答一下","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444969,"discussion_content":"单机，订单在文件中存储，处理的过程也是边扫描文件边生成小文件","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553736472,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79374,"user_name":"搬砖的孟达","can_delete":false,"product_type":"c1","uid":1201067,"ip_address":"","ucode":"8F280479C2C83D","user_header":"https://static001.geekbang.org/account/avatar/00/12/53/ab/20f1f4e8.jpg","comment_is_top":false,"comment_ctime":1553470292,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553470292","product_id":100017301,"comment_content":"打卡学习","like_count":0},{"had_liked":false,"id":78311,"user_name":"foolchild","can_delete":false,"product_type":"c1","uid":1031772,"ip_address":"","ucode":"09D2956B152B0C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/be/5c/03239967.jpg","comment_is_top":false,"comment_ctime":1553129617,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553129617","product_id":100017301,"comment_content":"创新的源泉来自对事物本质的认识","like_count":0},{"had_liked":false,"id":73994,"user_name":"朋朋","can_delete":false,"product_type":"c1","uid":1133890,"ip_address":"","ucode":"3070498E7282C5","user_header":"https://static001.geekbang.org/account/avatar/00/11/4d/42/8fd7c2e2.jpg","comment_is_top":false,"comment_ctime":1552055797,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552055797","product_id":100017301,"comment_content":"逆序对 我参考楼主 用c 实现了一个<br>  1 #include &lt;stdio.h&gt;<br>  2<br>  3 int merge(int a[], int s, int mid, int d)<br>  4 {<br>  5     int i = s;<br>  6     int m = mid;<br>  7     int count = 0;<br>  8     while(s &lt;= mid){<br>  9         int rt = a[s];<br> 10         int j = m + 1;<br> 11         while(j &lt;= d){<br> 12             int lt = a[j];<br> 13             if(rt &gt; lt) count++;<br> 14             j++;<br> 15         }<br> 16         s++;<br> 17     }<br> 18     return count;<br> 19 }<br> 20<br> 21<br> 22 int merge_sort_count(int a[], int s, int d)<br> 23 {<br> 24     if(s &gt;= d) return 0;<br> 25     int mid = (s + d) &#47;2;<br> 26     int rc = merge_sort_count(a, s, mid);<br> 27     int lc = merge_sort_count(a, mid + 1, d);<br> 28     int mc = merge(a, s, mid, d);<br> 29     return rc + lc + mc;<br> 30 }<br> 31<br> 32<br> 33 int get_count(int a[], int n)<br> 34 {<br> 35     return merge_sort_count(a, 0, n - 1);<br> 36 }<br> 37<br> 38 int main()<br> 39 {<br> 40     int a[] = {2, 4, 3, 1, 5, 6};<br> 41     int s[] = {9, 8, 7, 6, 2, 4};<br> 42     int r = get_count(a, 6);<br> 43     printf(&quot;reversed_pair:%d\\n&quot;, r);<br> 44     r = get_count(s, 6);<br> 45     printf(&quot;reversed_pair:%d\\n&quot;, r);<br> 46     return 0;<br> 47 }<br>","like_count":0},{"had_liked":false,"id":72531,"user_name":"泉","can_delete":false,"product_type":"c1","uid":1099760,"ip_address":"","ucode":"914709BE802A8D","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/f0/aa2e0749.jpg","comment_is_top":false,"comment_ctime":1551664984,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1551664984","product_id":100017301,"comment_content":"研究分治算法与递归的异同点。","like_count":0},{"had_liked":false,"id":69638,"user_name":"Flash","can_delete":false,"product_type":"c1","uid":1236163,"ip_address":"","ucode":"E285075C9E0B02","user_header":"https://static001.geekbang.org/account/avatar/00/12/dc/c3/e4ba51d5.jpg","comment_is_top":false,"comment_ctime":1550800689,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550800689","product_id":100017301,"comment_content":"归并排序算法<br>古代皇帝分封制","like_count":0},{"had_liked":false,"id":69243,"user_name":"kevin","can_delete":false,"product_type":"c1","uid":1237471,"ip_address":"","ucode":"5F6D82F118C6F6","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/df/6e6a4c6b.jpg","comment_is_top":false,"comment_ctime":1550699152,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550699152","product_id":100017301,"comment_content":"num += (q-i+1); &#47;&#47; 统计 p-q 之间，统计 p-q 之间，比 a[j] 大的元素个数<br>这里的注释我觉得不对，<br>应该是只要a[i]比a[j]大，a[i],a[j]之间元素的逆序等于元素个数，因为这些数字要么 &lt; a[i] ，要么 &gt; a[j]，每个数相对开头或结尾的数都是逆序； <br>比如 a[] = 1, *7*, 0, 9, 4,    *5*, 8, 2, 3, 6<br>p=0, q=4,j=5, I=1, a[I] &gt; a[j], 这时a[p]，a[q]之间，比a[j]大的元素有2个，注释不成立，而是 0,9,4相对7或5都是逆序，加再 7&gt;5本身，总共有4个逆序<br><br>","like_count":0},{"had_liked":false,"id":69239,"user_name":"kevin","can_delete":false,"product_type":"c1","uid":1237471,"ip_address":"","ucode":"5F6D82F118C6F6","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/df/6e6a4c6b.jpg","comment_is_top":false,"comment_ctime":1550691229,"is_pvip":false,"replies":[{"id":"24626","content":"修改过了的。排序了。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1550719953,"ip_address":"","comment_id":69239,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1550691229","product_id":100017301,"comment_content":"为什么需要创建tmp数组来存储原数据，并在后面复制回去； 其实原数组数据并没有被修改过","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440019,"discussion_content":"修改过了的。排序了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550719953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":65177,"user_name":"刘文坛","can_delete":false,"product_type":"c1","uid":1141060,"ip_address":"","ucode":"327D908175EDD0","user_header":"https://static001.geekbang.org/account/avatar/00/11/69/44/1588e8b6.jpg","comment_is_top":false,"comment_ctime":1549089826,"is_pvip":false,"replies":[{"id":"24294","content":"并不是把两个5GB的有序文件放到内存中啊，你可以看看归并排序中的merge函数的思路。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1550542678,"ip_address":"","comment_id":65177,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1549089826","product_id":100017301,"comment_content":"对10G大文件拆分成若干小文件分别排序，在合并有序文件时，如何对两个5G有序文件进行内存排序？内存放不下啊","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438347,"discussion_content":"并不是把两个5GB的有序文件放到内存中啊，你可以看看归并排序中的merge函数的思路。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550542678,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":62916,"user_name":"睡痴儿😑","can_delete":false,"product_type":"c1","uid":1187204,"ip_address":"","ucode":"750EF858EF2042","user_header":"https://static001.geekbang.org/account/avatar/00/12/1d/84/d0ec0064.jpg","comment_is_top":false,"comment_ctime":1548206953,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548206953","product_id":100017301,"comment_content":"树的基本思想其实就是分治。我觉得时间复杂度度为logn的，或多或少都会与分治有关。","like_count":0},{"had_liked":false,"id":61407,"user_name":"luo","can_delete":false,"product_type":"c1","uid":1148742,"ip_address":"","ucode":"00FBDC12101419","user_header":"https://static001.geekbang.org/account/avatar/00/11/87/46/2850b4a9.jpg","comment_is_top":false,"comment_ctime":1547692090,"is_pvip":false,"replies":[{"id":"22484","content":"😄 这个看个人心态吧，多大都不晚。不过我个人觉得工作5年内吧。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1548405992,"ip_address":"","comment_id":61407,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1547692090","product_id":100017301,"comment_content":"老师 你说的转算法，岁数不大愿意学习的岁数不大应该是小于多少岁为好","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436865,"discussion_content":"😄 这个看个人心态吧，多大都不晚。不过我个人觉得工作5年内吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548405992,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":60527,"user_name":"qinggeouye","can_delete":false,"product_type":"c1","uid":1251536,"ip_address":"","ucode":"5B53EEDD7BEC9C","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/d0/49b06424.jpg","comment_is_top":false,"comment_ctime":1547486347,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547486347","product_id":100017301,"comment_content":"第 12 讲 归并排序和快速排序都用到了分治思想，以及思考题<br>https:&#47;&#47;time.geekbang.org&#47;column&#47;article&#47;41913","like_count":0},{"had_liked":false,"id":59557,"user_name":"cw","can_delete":false,"product_type":"c1","uid":1264296,"ip_address":"","ucode":"82A6B50462F9F9","user_header":"https://static001.geekbang.org/account/avatar/00/13/4a/a8/b7e36dd2.jpg","comment_is_top":false,"comment_ctime":1547385199,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547385199","product_id":100017301,"comment_content":"冲鸭","like_count":0},{"had_liked":false,"id":57824,"user_name":"Geek_fbe6fe","can_delete":false,"product_type":"c1","uid":1250069,"ip_address":"","ucode":"E69AD55364C93E","user_header":"https://static001.geekbang.org/account/avatar/00/13/13/15/5dabb390.jpg","comment_is_top":false,"comment_ctime":1546918195,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546918195","product_id":100017301,"comment_content":"还是写代码理解的快<br>package baseMind<br><br>import (<br>\t&quot;fmt&quot;<br>)<br><br>var totalNum int<br><br>func CountReversed() {<br>\tlist := []int{1, 2, 43, 344, 3, 46, 75}<br>\t&#47;&#47;list := []int{5, 2, 43, 344, 3, 46, 75}<br>\tmergeSortCount(list, 0, len(list)-1)<br>\tfmt.Println(totalNum)<br>}<br>func mergeSortCount(a []int, start int, end int) {<br>\t&#47;&#47;return<br>\tif start &gt;= end {<br>\t\treturn<br>\t}<br>\tlow := start<br>\tmin := (start + end) &#47; 2<br>\tmergeSortCount(a, low, min)<br>\tmergeSortCount(a, min+1, end)<br>\tmergeCount(a, low, min, end)<br>}<br>func mergeCount(a []int, low int, min int, end int) {<br>\ttmp := make([]int, end-low+1)<br>\ti := low<br>\tk := 0<br>\tj := min + 1<br>\t&#47;&#47;获取左半边和右半边的逆序度<br>\tfor i &lt;= min &amp;&amp; j &lt;= end {<br>\t\tif a[i] &lt; a[j] {<br>\t\t\ttmp[k] = a[i]<br>\t\t\tk++<br>\t\t\ti++<br>\t\t} else {<br>\t\t\ttotalNum += min - i + 1<br>\t\t\ttmp[k] = a[j]<br>\t\t\tk++<br>\t\t\tj++<br>\t\t}<br>\t}<br>\t&#47;&#47;处理左边剩下<br>\t&#47;&#47;fmt.Println(i, min)<br>\tfor i &lt;= min {<br>\t\ttmp[k] = a[i]<br>\t\tk++<br>\t\ti++<br>\t}<br>\t&#47;&#47;处理右边剩下<br>\t&#47;&#47;fmt.Println(j, end)<br>\tfor j &lt;= end {<br>\t\ttmp[k] = a[j]<br>\t\tk++<br>\t\tj++<br>\t}<br>\tfmt.Println(tmp, low, min, end)<br>\t&#47;&#47;将数据拷贝回a<br>\tfor n := 0; n &lt; end-low+1; n++ {<br>\t\t&#47;&#47;fmt.Println(n)<br>\t\ta[low+n] = tmp[n]<br>\t}<br>\tfmt.Println(a)<br>\tfmt.Println(&quot;num:&quot;, totalNum)<br>}<br>其实，分析递归应该从最小最 底层的递归进行分析，要不然很容易产生误解，归并的最底层只有两个元素所以可以用这种方式做逆序计算，合并的时候两个小数组已经是有序的所以也可以用合并的方式做合并，真的挺神奇的，换一个方式角度思考问题就解决了。","like_count":0},{"had_liked":false,"id":56531,"user_name":"Geek_fbe6fe","can_delete":false,"product_type":"c1","uid":1250069,"ip_address":"","ucode":"E69AD55364C93E","user_header":"https://static001.geekbang.org/account/avatar/00/13/13/15/5dabb390.jpg","comment_is_top":false,"comment_ctime":1546483328,"is_pvip":false,"replies":[{"id":"20492","content":"不 你有点误解了 你最好还是回过头去再看下归并排序那一节课","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1546566765,"ip_address":"","comment_id":56531,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546483328","product_id":100017301,"comment_content":"老师，使用归并排序算有序度，分成两个小数组必须是有序的，是吗？好疑惑这样子应用场景不是很小？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435097,"discussion_content":"不 你有点误解了 你最好还是回过头去再看下归并排序那一节课","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546566765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":55046,"user_name":"唯她命","can_delete":false,"product_type":"c1","uid":1240398,"ip_address":"","ucode":"8F687E8D306840","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/4e/ef406442.jpg","comment_is_top":false,"comment_ctime":1546009583,"is_pvip":false,"replies":[{"id":"20250","content":"不是同一个例子 你再仔细看看😄","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1546418219,"ip_address":"","comment_id":55046,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546009583","product_id":100017301,"comment_content":"老师 一开始逆序度不是4吗，最后怎么成了6了","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434658,"discussion_content":"不是同一个例子 你再仔细看看😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546418219,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":53913,"user_name":"猫头鹰爱拿铁","can_delete":false,"product_type":"c1","uid":1105958,"ip_address":"","ucode":"24266B58968428","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/26/4942a09e.jpg","comment_is_top":false,"comment_ctime":1545753662,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1545753662","product_id":100017301,"comment_content":"打下卡 还有两节 就赶上进度了 前面字符串算法那耽误了好一会 好再多看几遍多写几遍也基本理解了 难度越来越大了 希望自己能坚持下去 不要掉队 ","like_count":0},{"had_liked":false,"id":53159,"user_name":"杨槐","can_delete":false,"product_type":"c1","uid":1178889,"ip_address":"","ucode":"A07D7FA4569F5F","user_header":"https://static001.geekbang.org/account/avatar/00/11/fd/09/13f8a4ab.jpg","comment_is_top":false,"comment_ctime":1545612789,"is_pvip":false,"replies":[{"id":"19666","content":"不需要了 直接刷吧","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545826925,"ip_address":"","comment_id":53159,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545612789","product_id":100017301,"comment_content":"老师，普通本科生学这个算法，数据结构可以拓展自己的思维，有较大的机会以后能转算法或者大数据呢？看完你的专栏，刷刷leetcode，还需要哪些书看呢","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434051,"discussion_content":"不需要了 直接刷吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545826925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":52700,"user_name":"李盏","can_delete":false,"product_type":"c1","uid":1019609,"ip_address":"","ucode":"C012ED1F119048","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIcMfFBhXflsHhW5HV9EGFLJe21f5MP5qGzdHAgSficFP04WrnGwcmg1Ix4j74VImJphH17kehuibjg/132","comment_is_top":false,"comment_ctime":1545480419,"is_pvip":false,"replies":[{"id":"19168","content":"专栏简介有写","user_name":"编辑回复","user_name_real":"王锦","uid":"1058895","ctime":1545488672,"ip_address":"","comment_id":52700,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1545480419","product_id":100017301,"comment_content":"老师，是不是每课都有代码放git上了，地址是啥","like_count":0,"discussions":[{"author":{"id":1058895,"avatar":"https://static001.geekbang.org/account/avatar/00/10/28/4f/48e48553.jpg","nickname":"@阿锦啊","note":"","ucode":"3C5F00333D7174","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433951,"discussion_content":"专栏简介有写","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545488672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":52226,"user_name":"feifei","can_delete":false,"product_type":"c1","uid":1105431,"ip_address":"","ucode":"B1F8AE3AD82C51","user_header":"https://static001.geekbang.org/account/avatar/00/10/de/17/75e2b624.jpg","comment_is_top":false,"comment_ctime":1545353153,"is_pvip":false,"replies":[{"id":"18983","content":"主要思想就代码中的你说的那一行 每次统计有几个比他大的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545356757,"ip_address":"","comment_id":52226,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545353153","product_id":100017301,"comment_content":"老师这个分治算法我理解了，但在加入统计逆序对个数的代码的后，我有一点没有理解，就是逆序对的个数的加法，为什么是当前中间值下标减开始下标加1，这是为什么？我本来的想法是当左边大于右边就加1，但这样是不对的，所以请老师帮我解释下，谢谢！","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433793,"discussion_content":"主要思想就代码中的你说的那一行 每次统计有几个比他大的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545356757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":52195,"user_name":"大可可","can_delete":false,"product_type":"c1","uid":1186458,"ip_address":"","ucode":"BC635013E7B87E","user_header":"https://static001.geekbang.org/account/avatar/00/12/1a/9a/7b246eb1.jpg","comment_is_top":false,"comment_ctime":1545349415,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545349415","product_id":100017301,"comment_content":"求逆对数实现的很巧妙","like_count":0},{"had_liked":false,"id":52050,"user_name":"追风者","can_delete":false,"product_type":"c1","uid":1055092,"ip_address":"","ucode":"879BC372A6B605","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIjUDIRQ0gRiciax3Wo78c5rVjuWDiaw4ibcCiby8xiaMXJh5ibjU5242vfCGOK4ehibe1IKyxex2A4IX4XSA/132","comment_is_top":false,"comment_ctime":1545300523,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545300523","product_id":100017301,"comment_content":"“不过，这里有一个点要注意，就是数据的存储与计算所在的机器是同一个或者在网络中靠的很近（比如一个局域网内，数据存取速度很快），否则就会因为数据访问的速度，导致整个处理过程不但不会变快，反而有可能变慢。“<br>这个说的是HDFS的机架感知吗？","like_count":0},{"had_liked":false,"id":51478,"user_name":"luxinfeng","can_delete":false,"product_type":"c1","uid":1259853,"ip_address":"","ucode":"51D0046C4D31AD","user_header":"https://static001.geekbang.org/account/avatar/00/13/39/4d/9ce28826.jpg","comment_is_top":false,"comment_ctime":1545187660,"is_pvip":false,"replies":[{"id":"18623","content":"这个就是归并排序算法的时间复杂度 你可以看下归并排序的时间复杂度推导","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545191922,"ip_address":"","comment_id":51478,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545187660","product_id":100017301,"comment_content":"老师，分治算法求逆序度比时间复杂度是O（n^2）的算法高效在什么地方啊？为什么我推算的分治算法的时间复杂度并不比O（n^2）高效呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433474,"discussion_content":"这个就是归并排序算法的时间复杂度 你可以看下归并排序的时间复杂度推导","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545191922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":51354,"user_name":"醉比","can_delete":false,"product_type":"c1","uid":1248399,"ip_address":"","ucode":"79E65F62BE7809","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/8f/4ebd303a.jpg","comment_is_top":false,"comment_ctime":1545177678,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545177678","product_id":100017301,"comment_content":"创新并非离我们很远。","like_count":0},{"had_liked":false,"id":51312,"user_name":"浩","can_delete":false,"product_type":"c1","uid":1108212,"ip_address":"","ucode":"F84D7EC3B3B4D7","user_header":"https://static001.geekbang.org/account/avatar/00/10/e8/f4/6cca0aac.jpg","comment_is_top":false,"comment_ctime":1545151921,"is_pvip":false,"replies":[{"id":"18547","content":"你是说的代码里吗 你可以自己debug一下","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545184523,"ip_address":"","comment_id":51312,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545151921","product_id":100017301,"comment_content":"为什么那个逆序对的个数要减1呀？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433403,"discussion_content":"你是说的代码里吗 你可以自己debug一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545184523,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}