{"id":310060,"title":"03｜理解进程（2）：为什么我的容器里有这么多僵尸进程？","content":"<p>你好，我是程远。今天我们来聊一聊容器里僵尸进程这个问题。</p><p>说起僵尸进程，相信你并不陌生。很多面试官经常会问到这个知识点，用来考察候选人的操作系统背景。通过这个问题，可以了解候选人对Linux进程管理和信号处理这些基础知识的理解程度，他的基本功扎不扎实。</p><p>所以，今天我们就一起来看看容器里为什么会产生僵尸进程，然后去分析如何怎么解决。</p><p>通过这一讲，你就会对僵尸进程的产生原理有一个清晰的认识，也会更深入地理解容器init进程的特性。</p><h2>问题再现</h2><p>我们平时用容器的时候，有的同学会发现，自己的容器运行久了之后，运行ps命令会看到一些进程，进程名后面加了&lt;defunct&gt;标识。那么你自然会有这样的疑问，这些是什么进程呢？</p><p>你可以自己做个容器镜像来模拟一下，我们先下载这个<a href=\"https://github.com/chengyli/training/tree/master/init_proc/zombie_proc\">例子</a>，运行 <code>make image</code> 之后，再启动容器。</p><p>在容器里我们可以看到，1号进程fork出1000个子进程。当这些子进程运行结束后，它们的进程名字后面都加了<defunct>标识。</defunct></p><p>从它们的Z stat（进程状态）中我们可以知道，这些都是僵尸进程（Zombie Process）。运行top命令，我们也可以看到输出的内容显示有 <code>1000 zombie</code> 进程。</p><pre><code># docker run --name zombie-proc -d registry/zombie-proc:v1\n02dec161a9e8b18922bd3599b922dbd087a2ad60c9b34afccde7c91a463bde8a\n# docker exec -it zombie-proc bash\n# ps aux\nUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\nroot         1  0.0  0.0   4324  1436 ?        Ss   01:23   0:00 /app-test 1000\nroot         6  0.0  0.0      0     0 ?        Z    01:23   0:00 [app-test] &lt;defunct&gt;\nroot         7  0.0  0.0      0     0 ?        Z    01:23   0:00 [app-test] &lt;defunct&gt;\nroot         8  0.0  0.0      0     0 ?        Z    01:23   0:00 [app-test] &lt;defunct&gt;\nroot         9  0.0  0.0      0     0 ?        Z    01:23   0:00 [app-test] &lt;defunct&gt;\nroot        10  0.0  0.0      0     0 ?        Z    01:23   0:00 [app-test] &lt;defunct&gt;\n\n…\n\nroot       999  0.0  0.0      0     0 ?        Z    01:23   0:00 [app-test] &lt;defunct&gt;\nroot      1000  0.0  0.0      0     0 ?        Z    01:23   0:00 [app-test] &lt;defunct&gt;\nroot      1001  0.0  0.0      0     0 ?        Z    01:23   0:00 [app-test] &lt;defunct&gt;\nroot      1002  0.0  0.0      0     0 ?        Z    01:23   0:00 [app-test] &lt;defunct&gt;\nroot      1003  0.0  0.0      0     0 ?        Z    01:23   0:00 [app-test] &lt;defunct&gt;\nroot      1004  0.0  0.0      0     0 ?        Z    01:23   0:00 [app-test] &lt;defunct&gt;\nroot      1005  0.0  0.0      0     0 ?        Z    01:23   0:00 [app-test] &lt;defunct&gt;\nroot      1023  0.0  0.0  12020  3392 pts/0    Ss   01:39   0:00 bash\n\n# top\ntop - 02:18:57 up 31 days, 15:17,  0 users,  load average: 0.00, 0.01, 0.00\nTasks: 1003 total,   1 running,   2 sleeping,   0 stopped, 1000 zombie\n…\n</code></pre><!-- [[[read_end]]] --><p>那么问题来了，什么是僵尸进程？它们是怎么产生的？僵尸进程太多会导致什么问题？想要回答这些问题，我们就要从进程状态的源头学习，看看僵尸进程到底处于进程整个生命周期里的哪一环。</p><h2>知识详解</h2><h3>Linux的进程状态</h3><p>无论进程还是线程，在Linux内核里其实都是用 <strong>task_struct{}这个结构</strong>来表示的。它其实就是任务（task），也就是Linux里基本的调度单位。为了方便讲解，我们在这里暂且称它为进程。</p><p>那一个进程从创建（fork）到退出（exit），这个过程中的状态转化还是很简单的。</p><p>下面这个图是 《Linux Kernel Development》这本书里的Linux进程状态转化图。</p><p>我们从这张图中可以看出来，在进程“活着”的时候就只有两个状态：运行态（TASK_RUNNING）和睡眠态（TASK_INTERRUPTIBLE，TASK_UNINTERRUPTIBLE）。</p><p><img src=\"https://static001.geekbang.org/resource/image/dd/70/ddbd530325e12ec8b4ec1ab7e3fc8170.jpeg?wh=2199*1654\" alt=\"\"></p><p>那运行态和睡眠态这两种状态分别是什么意思呢？</p><p>运行态的意思是，无论进程是正在运行中（也就是获得了CPU资源），还是进程在run queue队列里随时可以运行，都处于这个状态。</p><p>我们想要查看进程是不是处于运行态，其实也很简单，比如使用ps命令，可以看到处于这个状态的进程显示的是R stat。</p><p>睡眠态是指，进程需要等待某个资源而进入的状态，要等待的资源可以是一个信号量（Semaphore）, 或者是磁盘I/O，这个状态的进程会被放入到wait queue队列里。</p><p>这个睡眠态具体还包括两个子状态：一个是可以被打断的（TASK_INTERRUPTIBLE），我们用ps查看到的进程，显示为S stat。还有一个是不可被打断的（TASK_UNINTERRUPTIBLE），用ps查看进程，就显示为D stat。</p><p>这两个子状态，我们在后面的课程里碰到新的问题时，会再做详细介绍，这里你只要知道这些就行了。</p><p>除了上面进程在活的时候的两个状态，进程在调用do_exit()退出的时候，还有两个状态。</p><p>一个是 EXIT_DEAD，也就是进程在真正结束退出的那一瞬间的状态；第二个是 <strong>EXIT_ZOMBIE状态，这是进程在EXIT_DEAD前的一个状态，而我们今天讨论的僵尸进程，也就是处于这个状态中。</strong></p><h3>限制容器中进程数目</h3><p>理解了Linux进程状态之后，我们还需要知道，在Linux系统中怎么限制进程数目。因为弄清楚这个问题，我们才能更深入地去理解僵尸进程的危害。</p><p>一台Linux机器上的进程总数目是有限制的。如果超过这个最大值，那么系统就无法创建出新的进程了，比如你想SSH登录到这台机器上就不行了。</p><p>这个最大值可以我们在 /proc/sys/kernel/pid_max这个参数中看到。</p><p>Linux内核在初始化系统的时候，会根据机器CPU的数目来设置pid_max的值。</p><p>比如说，如果机器中CPU数目小于等于32，那么pid_max就会被设置为32768（32K）；如果机器中的CPU数目大于32，那么pid_max就被设置为 N*1024 （N就是CPU数目）。</p><p>对于Linux系统而言，容器就是一组进程的集合。如果容器中的应用创建过多的进程或者出现bug，就会产生类似fork bomb的行为。</p><p>这个fork bomb就是指在计算机中，通过不断建立新进程来消耗系统中的进程资源，它是一种黑客攻击方式。这样，容器中的进程数就会把整个节点的可用进程总数给消耗完。</p><p>这样，不但会使同一个节点上的其他容器无法工作，还会让宿主机本身也无法工作。所以对于每个容器来说，我们都需要限制它的最大进程数目，而这个功能由pids Cgroup这个子系统来完成。</p><p>而这个功能的实现方法是这样的：pids Cgroup通过Cgroup文件系统的方式向用户提供操作接口，一般它的Cgroup文件系统挂载点在 /sys/fs/cgroup/pids。</p><p>在一个容器建立之后，创建容器的服务会在/sys/fs/cgroup/pids下建立一个子目录，就是一个控制组，控制组里<strong>最关键的一个文件就是pids.max</strong>。我们可以向这个文件写入数值，而这个值就是这个容器中允许的最大进程数目。</p><p>我们对这个值做好限制，容器就不会因为创建出过多进程而影响到其他容器和宿主机了。思路讲完了，接下来我们就实际上手试一试。</p><p>下面是对一个Docker容器的pids Cgroup的操作，你可以跟着操作一下。</p><pre><code class=\"language-shell\"># pwd\n/sys/fs/cgroup/pids\n# df ./\nFilesystem     1K-blocks  Used Available Use% Mounted on\ncgroup                 0     0         0    - /sys/fs/cgroup/pids\n# docker ps\nCONTAINER ID        IMAGE                      COMMAND                  CREATED             STATUS              PORTS               NAMES\n7ecd3aa7fdc1        registry/zombie-proc:v1   \"/app-test 1000\"         37 hours ago        Up 37 hours                             frosty_yalow\n\n# pwd\n/sys/fs/cgroup/pids/system.slice/docker-7ecd3aa7fdc15a1e183813b1899d5d939beafb11833ad6c8b0432536e5b9871c.scope\n\n# ls\ncgroup.clone_children  cgroup.procs  notify_on_release  pids.current  pids.events  pids.max  tasks\n# echo 1002 &gt; pids.max\n# cat pids.max\n1002\n</code></pre><h2>解决问题</h2><p>刚才我给你解释了两个基本概念，进程状态和进程数目限制，那我们现在就可以解决容器中的僵尸进程问题了。</p><p>在前面Linux进程状态的介绍里，我们知道了，僵尸进程是Linux进程退出状态的一种。</p><p>从内核进程的do_exit()函数我们也可以看到，这时候进程task_struct里的mm/shm/sem/files等文件资源都已经释放了，只留下了一个stask_struct instance空壳。</p><p>就像下面这段代码显示的一样，从进程对应的/proc/&lt;pid&gt; 文件目录下，我们也可以看出来，对应的资源都已经没有了。</p><pre><code class=\"language-shell\"># cat /proc/6/cmdline\n# cat /proc/6/smaps\n# cat /proc/6/maps\n# ls /proc/6/fd\n</code></pre><p>并且，这个进程也已经不响应任何的信号了，无论SIGTERM(15)还是SIGKILL(9)。例如上面pid 6的僵尸进程，这两个信号都已经被响应了。</p><pre><code class=\"language-shell\"># kill -15 6\n# kill -9 6\n# ps -ef | grep 6\nroot         6     1  0 13:59 ?        00:00:00 [app-test] &lt;defunct&gt;\n</code></pre><p>当多个容器运行在同一个宿主机上的时候，为了避免一个容器消耗完我们整个宿主机进程号资源，我们会配置pids Cgroup来限制每个容器的最大进程数目。也就是说，进程数目在每个容器中也是有限的，是一种很宝贵的资源。</p><p>既然进程号资源在宿主机上是有限的，显然残留的僵尸进程多了以后，给系统带来最大问题就是它占用了进程号。<strong>这就意味着，残留的僵尸进程，在容器里仍然占据着进程号资源，很有可能会导致新的进程不能运转。</strong></p><p>这里我再次借用开头的那个例子，也就是一个产生了1000个僵尸进程的容器，带你理解一下这个例子中进程数的上限。我们可以看一下，1个init进程+1000个僵尸进程+1个bash进程 ，总共就是1002个进程。</p><p>如果pids Cgroup也限制了这个容器的最大进程号的数量，限制为1002的话，我们在pids Cgroup里可以看到，pids.current == pids.max，也就是已经达到了容器进程号数的上限。</p><p>这时候，如果我们在容器里想再启动一个进程，例如运行一下ls命令，就会看到 <code>Resource temporarily unavailable</code> 的错误消息。已经退出的无用进程，却阻碍了有用进程的启动，显然这样是不合理的。</p><p>具体代码如下：</p><pre><code class=\"language-shell\">### On host\n# docker ps\nCONTAINER ID        IMAGE                      COMMAND             CREATED             STATUS              PORTS               NAMES\n09e6e8e16346        registry/zombie-proc:v1   \"/app-test 1000\"    29 minutes ago      Up 29 minutes                           peaceful_ritchie\n\n# pwd\n/sys/fs/cgroup/pids/system.slice/docker-09e6e8e1634612580a03dd3496d2efed2cf2a510b9688160b414ce1d1ea3e4ae.scope\n\n# cat pids.max\n1002\n# cat pids.current\n1002\n\n### On Container\n[root@09e6e8e16346 /]# ls\nbash: fork: retry: Resource temporarily unavailable\nbash: fork: retry: Resource temporarily unavailable\n</code></pre><p>所以，接下来我们还要看看这些僵尸进程到底是怎么产生的。因为只有理解它的产生机制，我们才能想明白怎么避免僵尸进程的出现。</p><p>我们先看一下刚才模拟僵尸进程的那段小程序。这段程序里，<strong>父进程在创建完子进程之后就不管了，这就是造成子进程变成僵尸进程的原因。</strong></p><pre><code class=\"language-shell\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;sys/wait.h&gt;\n#include &lt;unistd.h&gt;\n\n \n\nint main(int argc, char *argv[])\n{\n       int i;\n       int total;\n\n       if (argc &lt; 2) {\n              total = 1;\n       } else {\n              total = atoi(argv[1]);\n       }\n\n       printf(\"To create %d processes\\n\", total);\n\n       for (i = 0; i &lt; total; i++) {\n              pid_t pid = fork();\n \n              if (pid == 0) {\n                      printf(\"Child =&gt; PPID: %d PID: %d\\n\", getppid(),\n                             getpid());\n                      sleep(60);\n                      printf(\"Child process exits\\n\");\n                      exit(EXIT_SUCCESS);\n              } else if (pid &gt; 0) {\n                      printf(\"Parent created child %d\\n\", i);\n              } else {\n                      printf(\"Unable to create child process. %d\\n\", i);\n                      break;\n              }\n       }\n\n       printf(\"Paraent is sleeping\\n\");\n       while (1) {\n              sleep(100);\n       }\n\n       return EXIT_SUCCESS;\n}\n</code></pre><p>前面我们通过分析，发现子进程变成僵尸进程的原因在于父进程“不负责”，那找到原因后，我们再想想，如何来解决。</p><p>其实解决思路很好理解，就好像熊孩子犯了事儿，你要去找他家长来管教，那子进程在容器里“赖着不走”，我们就需要让父进程出面处理了。</p><p>所以，在Linux中的进程退出之后，如果进入僵尸状态，我们就需要父进程调用wait()这个系统调用，去回收僵尸进程的最后的那些系统资源，比如进程号资源。</p><p>那么，我们在刚才那段代码里，主进程进入sleep(100)之前，加上一段wait()函数调用，就不会出现僵尸进程的残留了。</p><pre><code class=\"language-shell\">      for (i = 0; i &lt; total; i++) {\n            int status;\n            wait(&amp;status);\n      }\n</code></pre><p>而容器中所有进程的最终父进程，就是我们所说的init进程，由它负责生成容器中的所有其他进程。因此，容器的init进程有责任回收容器中的所有僵尸进程。</p><p>前面我们知道了wait()系统调用可以回收僵尸进程，但是wait()系统调用有一个问题，需要你注意。</p><p>wait()系统调用是一个阻塞的调用，也就是说，如果没有子进程是僵尸进程的话，这个调用就一直不会返回，那么整个进程就会被阻塞住，而不能去做别的事了。</p><p>不过这也没有关系，我们还有另一个方法处理。Linux还提供了一个类似的系统调用waitpid()，这个调用的参数更多。</p><p>其中就有一个参数WNOHANG，它的含义就是，如果在调用的时候没有僵尸进程，那么函数就马上返回了，而不会像wait()调用那样一直等待在那里。</p><p>比如社区的一个<a href=\"https://github.com/krallin/tini\">容器init项目tini</a>。在这个例子中，它的主进程里，就是不断在调用带WNOHANG参数的waitpid()，通过这个方式清理容器中所有的僵尸进程。</p><pre><code class=\"language-shell\">int reap_zombies(const pid_t child_pid, int* const child_exitcode_ptr) {\n        pid_t current_pid;\n        int current_status;\n\n        while (1) {\n                current_pid = waitpid(-1, &amp;current_status, WNOHANG);\n\n                switch (current_pid) {\n                        case -1:\n                                if (errno == ECHILD) {\n                                        PRINT_TRACE(\"No child to wait\");\n                                        break;\n                                }\n\n…\n</code></pre><h2>重点总结</h2><p>今天我们讨论的问题是容器中的僵尸进程。</p><p>首先，我们先用代码来模拟了这个情况，还原了在一个容器中大量的僵尸进程是如何产生的。为了理解它的产生原理和危害，我们先要掌握两个知识点：</p><ul>\n<li>Linux进程状态中，僵尸进程处于EXIT_ZOMBIE这个状态；</li>\n<li>容器需要对最大进程数做限制。具体方法是这样的，我们可以向Cgroup中 <strong>pids.max</strong>这个文件写入数值（这个值就是这个容器中允许的最大进程数目）。</li>\n</ul><p>掌握了基本概念之后，我们找到了僵尸进程的产生原因。父进程在创建完子进程之后就不管了。</p><p>所以，我们需要父进程调用wait()或者waitpid()系统调用来避免僵尸进程产生。</p><p>关于本节内容，你只要记住下面三个主要的知识点就可以了：</p><ol>\n<li>每一个Linux进程在退出的时候都会进入一个僵尸状态（EXIT_ZOMBIE）；</li>\n<li>僵尸进程如果不清理，就会消耗系统中的进程数资源，最坏的情况是导致新的进程无法启动；</li>\n<li>僵尸进程一定需要父进程调用wait()或者waitpid()系统调用来清理，这也是容器中init进程必须具备的一个功能。</li>\n</ol><h2>思考题</h2><p>如果容器的init进程创建了子进程B，B又创建了自己的子进程C。如果C运行完之后，退出成了僵尸进程，B进程还在运行，而容器的init进程还在不断地调用waitpid()，那C这个僵尸进程可以被回收吗？</p><p>欢迎留言和我分享你的想法。如果你的朋友也被僵尸进程占用资源而困扰，欢迎你把这篇文章分享给他，也许就能帮他解决一个问题。</p>","comments":[{"had_liked":false,"id":262718,"user_name":"莫名","can_delete":false,"product_type":"c1","uid":1007254,"ip_address":"","ucode":"E28F2602BA25DD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/96/a03175bc.jpg","comment_is_top":false,"comment_ctime":1605832566,"is_pvip":false,"replies":[{"id":"95351","content":"谢谢 @莫名！ 很好的解释！","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1605847201,"ip_address":"","comment_id":262718,"utype":1}],"discussion_count":4,"race_medal":0,"score":"310843477878","product_id":100063801,"comment_content":"C 应该不会被回收，waitpid 仅等待直接 children 的状态变化。<br><br>为什么先进入僵尸状态而不是直接消失？觉得是留给父进程一次机会，查看子进程的 PID、终止状态（退出码、终止原因，比如是信号终止还是正常退出等）、资源使用信息。如果子进程直接消失，那么父进程没有机会掌握子进程的具体终止情况。一般情况下，程序逻辑可能会依据子进程的终止情况做出进一步处理：比如 Nginx Master 进程获知 Worker 进程异常退出，则重新拉起来一个 Worker 进程。","like_count":73,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509939,"discussion_content":"谢谢 @莫名！ 很好的解释！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605847201,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1009622,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/d6/2f5cb85c.jpg","nickname":"xmr","note":"","ucode":"1BBF165F91F10B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552215,"discussion_content":"点赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645349536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2057406,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/64/be/546665e3.jpg","nickname":"心随缘","note":"","ucode":"F7F5C49EA80E03","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":354284,"discussion_content":"有原理，有比如，赞一个！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615268073,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1156557,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a5/cd/3aff5d57.jpg","nickname":"Alery","note":"","ucode":"08F3F49181E67B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330821,"discussion_content":"优秀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606716237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":264635,"user_name":"JianXu","can_delete":false,"product_type":"c1","uid":1033219,"ip_address":"","ucode":"2A61BDBB573BDC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c4/03/f753fda7.jpg","comment_is_top":false,"comment_ctime":1606554626,"is_pvip":false,"replies":[{"id":"96006","content":"&gt; 问题一<br>在kuberenetes下，kubelet还是调用 containerd&#47;runc去启动容器的，每个容器的父进程是containerd-shim, 最终shim可以回收僵尸进程。<br><br>&gt; 问题二<br>docker倒是也做了这件事。 用docker启动容器的时候 加--init参数，起来的容器就强制使用tini作为init进程了。<br><br>&gt; 问题三<br>Linux进程要响应SIGKILL并且执行signal handler，只有在被进程调度到的时候才可以做。对于zombie进程，它已经是不可被调度的进程了。","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1606639695,"ip_address":"","comment_id":264635,"utype":1}],"discussion_count":3,"race_medal":0,"score":"151930409986","product_id":100063801,"comment_content":"问题一：在Kubernetes 的情况下，是不是该节点上所有的容器都是kubelet 的子进程？不然kubelet 怎么来清理这些容器产生的僵尸进程呢？ <br><br>问题二：在Docker 的场景下，容器第一个进程是用户自己写的进程，而该进程是不能保证在回收子进程资源上的质量的，所以才有Tinit 等工具，那为什么docker runtime 不默认把这样的回收功能做了呢？<br><br>问题三：Linux 为什么不设计成可以kill -9 杀死僵尸进程呢？现在把希望都寄托在父亲进程的代码质量上，而要init 回收，就得把init 到 僵尸进程之间的血缘进程全部杀死。为什么要做这样的设计呢？","like_count":36,"discussions":[{"author":{"id":1005549,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/ed/d50de13c.jpg","nickname":"mj4ever","note":"","ucode":"73028E537099CC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581426,"discussion_content":"僵尸进程有其存在的意义——父进程不丢失子进程结束时的状态信息，但由于父进程运行、子进程的结束是一个异步的过程，父进程无法得知子进程什么时候会结束，所以，才有了这样一个机制，子进程在退出时，内核释放该进程所有资源，但保留一定的信息，直到父进程通过 wait/waitpid 来获取；但是如果父进程一直不获取，就成为了僵尸进程。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1658788405,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510631,"discussion_content":"&amp;gt; 问题一\n在kuberenetes下，kubelet还是调用 containerd/runc去启动容器的，每个容器的父进程是containerd-shim, 最终shim可以回收僵尸进程。\n\n&amp;gt; 问题二\ndocker倒是也做了这件事。 用docker启动容器的时候 加--init参数，起来的容器就强制使用tini作为init进程了。\n\n&amp;gt; 问题三\nLinux进程要响应SIGKILL并且执行signal handler，只有在被进程调度到的时候才可以做。对于zombie进程，它已经是不可被调度的进程了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1606639695,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1225728,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b4/00/bfc101ee.jpg","nickname":"Tendrun","note":"","ucode":"86AB3C3A7D8381","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337625,"discussion_content":"这里提到的shim可以回收僵尸进程怎么理解？看了这一小节不是都建议1号进程调用waitpid()回收，或使用dumb-init之类的小工具来处理么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608993375,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263228,"user_name":"上邪忘川","can_delete":false,"product_type":"c1","uid":1276588,"ip_address":"","ucode":"1C4459917B038D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIz9dKN1C8rKQoaVtmEGdzObhlia6zAfTsPYOm4ibz39VjTbu7Aia1LyeedHR26b6nxUtcCufpichcYgw/132","comment_is_top":false,"comment_ctime":1606053990,"is_pvip":false,"replies":[{"id":"95541","content":"@上邪忘川, 谢谢你的总结","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1606103220,"ip_address":"","comment_id":263228,"utype":1}],"discussion_count":1,"race_medal":0,"score":"83210432614","product_id":100063801,"comment_content":"总结一下这节课相关的东西<br>1.，父进程在创建完子进程之后就不管了，而每一个 Linux 进程在退出的时候都会进入一个僵尸状态，这时这些进入僵尸状态的进程就因为无法回收变成僵尸进程。<br>2.僵尸进程是无法直接被kill掉的，需要父进程调用wait()或watipid()回收。<br>3.清理僵尸进程的两个思路<br>（1）kill掉僵尸进程的父进程，此时僵尸进程会归附到init(1)进程下，而init进程一般都有正常的wait()或watipid()回收机制。<br>（2）利用dumb-init&#47;tini之类的小型init服务来解决僵尸进程","like_count":20,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510128,"discussion_content":"@上邪忘川, 谢谢你的总结","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606103220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262924,"user_name":"Helios","can_delete":false,"product_type":"c1","uid":1380758,"ip_address":"","ucode":"BE6B98EE8F0D09","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKJrOl63enWXCRxN0SoucliclBme0qrRb19ATrWIOIvibKIz8UAuVgicBMibIVUznerHnjotI4dm6ibODA/132","comment_is_top":false,"comment_ctime":1605886393,"is_pvip":false,"replies":[{"id":"95385","content":"@Helios,<br>对于容器或者说pod, 我们加了pids cgroup的限制，pids.max 对于每个容器一般就是以千为单位了，这个值还是很容易达到上限的。<br><br>我们在线上看到的大量Z进程，实际的情况要复杂一些，一个进程有多个线程，主进程处于Z状态，而还有一个线程处于D状态，但是从表象查看进程状态的时候，看到都是&lt;defunct&gt;进程了(Z）。由于有了D的线程在里面，这时候waitpid(), 任何信号对这些进程都无效了。<br>这一讲，我是把Z进程的概念单独说了一下，对于D进程，它会引起其他的一些现象，我会在后面讲到。","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1605922083,"ip_address":"","comment_id":262924,"utype":1}],"discussion_count":3,"race_medal":0,"score":"27375690169","product_id":100063801,"comment_content":"僵尸进程也是进程，就是资源没有被回收，父进程还活着就不会被init回收。<br>补充一点<br>子进程推出的时候会给父进程发送个信号，如果父进程不处理这个信号就会变味僵尸进程。现在一般只会出现在c这种需要手动垃圾回收得语言了。<br><br>老师是踩过坑呢，感觉这个坑不好踩，一是因为高级语言会处理信号，就像上一节说的。还有就是啥业务场景能搞三万多进程","like_count":7,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510034,"discussion_content":"@Helios,\n对于容器或者说pod, 我们加了pids cgroup的限制，pids.max 对于每个容器一般就是以千为单位了，这个值还是很容易达到上限的。\n\n我们在线上看到的大量Z进程，实际的情况要复杂一些，一个进程有多个线程，主进程处于Z状态，而还有一个线程处于D状态，但是从表象查看进程状态的时候，看到都是&amp;lt;defunct&amp;gt;进程了(Z）。由于有了D的线程在里面，这时候waitpid(), 任何信号对这些进程都无效了。\n这一讲，我是把Z进程的概念单独说了一下，对于D进程，它会引起其他的一些现象，我会在后面讲到。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605922083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":1042479,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIbQJvvPGOykalPwlibjmsFrJibib0Tm8v6kl5ricE44ic7wcdfMng5G23n932nC0QttXnLqWib0G8zXWFw/132","nickname":"shameless","note":"","ucode":"72331313BC7C1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":588635,"discussion_content":"在哪里有提到呀，能指出来一下吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663920598,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":510034,"ip_address":"湖南"},"score":588635,"extra":""},{"author":{"id":1042479,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIbQJvvPGOykalPwlibjmsFrJibib0Tm8v6kl5ricE44ic7wcdfMng5G23n932nC0QttXnLqWib0G8zXWFw/132","nickname":"shameless","note":"","ucode":"72331313BC7C1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":588643,"discussion_content":"对于您提到的这种还有线程是D状态的有啥排查思路不，大佬","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663922444,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":510034,"ip_address":"湖南"},"score":588643,"extra":""}]}]},{"had_liked":false,"id":263796,"user_name":"Delia","can_delete":false,"product_type":"c1","uid":1442969,"ip_address":"","ucode":"C8AB6171FBC3B5","user_header":"https://static001.geekbang.org/account/avatar/00/16/04/99/2d804b8d.jpg","comment_is_top":false,"comment_ctime":1606269115,"is_pvip":false,"replies":[{"id":"95709","content":"docker 自己没有自动清理的功能。如果是kubernetes&#47;kubelet是会做清理。","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1606288023,"ip_address":"","comment_id":263796,"utype":1}],"discussion_count":3,"race_medal":0,"score":"23081105595","product_id":100063801,"comment_content":"我是一个Docker新手，请教一下老师，经常看到一些容器僵尸，状态栏显示：Exited (2) 10 days ago，Exited (1) 10 days ago，Exited (100) 10 days ago等等，这些容器为啥不能被回收呢？目前只能docker rm清理掉。","like_count":5,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510308,"discussion_content":"docker 自己没有自动清理的功能。如果是kubernetes/kubelet是会做清理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606288023,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1160951,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b6/f7/3c3b1385.jpg","nickname":"海胆阶段","note":"","ucode":"7A8C4BB4D0CDB8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543230,"discussion_content":"they are not called zombie container, they are just stopped, intentionally or not. Run docker start will bring them back to running status","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1641010863,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1160951,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b6/f7/3c3b1385.jpg","nickname":"海胆阶段","note":"","ucode":"7A8C4BB4D0CDB8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543229,"discussion_content":"you can run docker with &#34;--rm&#34; flag","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641010685,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263126,"user_name":"水蒸蛋","can_delete":false,"product_type":"c1","uid":1809160,"ip_address":"","ucode":"6F7F853A4BF901","user_header":"https://static001.geekbang.org/account/avatar/00/1b/9b/08/27ac7ecd.jpg","comment_is_top":false,"comment_ctime":1606015207,"is_pvip":false,"replies":[{"id":"95497","content":"对的","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1606025593,"ip_address":"","comment_id":263126,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23080851687","product_id":100063801,"comment_content":"老师您的意思是僵尸线程默认都不会自动关闭的，全靠父进程回收，如果产生大量僵尸进程说明父进程相关回收策略有问题是吗","like_count":6,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510104,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606025593,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263223,"user_name":"朱雯","can_delete":false,"product_type":"c1","uid":1035744,"ip_address":"","ucode":"064C45FBF6B51F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cd/e0/c85bb948.jpg","comment_is_top":false,"comment_ctime":1606050543,"is_pvip":true,"replies":[{"id":"95542","content":"我觉得刚才 @上邪忘川的回复挺好的<br><br>3.清理僵尸进程的两个思路<br>（1）kill掉僵尸进程的父进程，此时僵尸进程会归附到init(1)进程下，而init进程一般都有正常的wait()或watipid()回收机制。<br>（2）利用dumb-init&#47;tini之类的小型init服务来解决僵尸进程","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1606103681,"ip_address":"","comment_id":263223,"utype":1}],"discussion_count":7,"race_medal":0,"score":"14490952431","product_id":100063801,"comment_content":"最后我作为一个运维工程师，我还是不知道怎么处理僵死进程，第一我可能不能直接杀死他们的父进程，因为可能有用，第二，我无法kill掉他们，第三我无法修改代码，代码本身对我是黑盒子。","like_count":4,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510125,"discussion_content":"我觉得刚才 @上邪忘川的回复挺好的\n\n3.清理僵尸进程的两个思路\n（1）kill掉僵尸进程的父进程，此时僵尸进程会归附到init(1)进程下，而init进程一般都有正常的wait()或watipid()回收机制。\n（2）利用dumb-init/tini之类的小型init服务来解决僵尸进程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606103681,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1707934,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/0f/9e/1a35fb04.jpg","nickname":"login","note":"","ucode":"49297B42014B63","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553001,"discussion_content":"对于本章示例，加上init启动，docker run  --init --name zombie-proc -d registry/zombie-proc:v1 \ninit进程是docker-init。但是他并不会回收子进程得子进程。这个怎么处理？\n[root@67f7ae1f7653 pids]# ps -ef\nUID        PID  PPID  C STIME TTY          TIME CMD\nroot         1     0  0 06:25 ?        00:00:00 /sbin/docker-init -- /app-test 1000\nroot         8     1  0 06:25 ?        00:00:00 /app-test 1000\nroot         9     8  0 06:25 ?        00:00:00 [app-test] &lt;defunct&gt;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645684341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1160951,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b6/f7/3c3b1385.jpg","nickname":"海胆阶段","note":"","ucode":"7A8C4BB4D0CDB8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543231,"discussion_content":"短期存在的僵尸进程是可以的，关键是看最后是否被回收。如果僵尸进程长期存在，你需要给开发反应了，不是你的锅","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641011360,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1035744,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cd/e0/c85bb948.jpg","nickname":"朱雯","note":"","ucode":"064C45FBF6B51F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328347,"discussion_content":"可我本来容器使用的就是init进程，那我还要重新制作镜像，然后重新启动容器吗，我所知道的，当我关闭重启容器以后，僵死进程已经没了。我在网上找到了一个方法，就是kill  -SIGCHLD 父进程pid，这个是不是等价于父进程执行waitpid操作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606125191,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"一步","note":"","ucode":"73CEA468CE70C3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1035744,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cd/e0/c85bb948.jpg","nickname":"朱雯","note":"","ucode":"064C45FBF6B51F","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":330408,"discussion_content":"对于  C 语言， SIGCHLD 该信号默认处理动作是忽略，所以父进程接收该信号啥也不干，没办法清楚清除僵尸进程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606617814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":328347,"ip_address":""},"score":330408,"extra":""},{"author":{"id":1035744,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cd/e0/c85bb948.jpg","nickname":"朱雯","note":"","ucode":"064C45FBF6B51F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"一步","note":"","ucode":"73CEA468CE70C3","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":330498,"discussion_content":"信号并非c语言机制 而是unix机制   所以liunx对sigchld默认是忽略吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606636110,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":330408,"ip_address":""},"score":330498,"extra":""},{"author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"一步","note":"","ucode":"73CEA468CE70C3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1035744,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cd/e0/c85bb948.jpg","nickname":"朱雯","note":"","ucode":"064C45FBF6B51F","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":330524,"discussion_content":"不是，看语言的实现有没有捕获该信号的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606640437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":330498,"ip_address":""},"score":330524,"extra":""}]}]},{"had_liked":false,"id":262786,"user_name":"1900","can_delete":false,"product_type":"c1","uid":1449081,"ip_address":"","ucode":"1C031D7B7AD884","user_header":"https://static001.geekbang.org/account/avatar/00/16/1c/79/5ec77bcd.jpg","comment_is_top":false,"comment_ctime":1605842252,"is_pvip":false,"replies":[{"id":"95349","content":"对容器设置pids Cgroup限制，一般需要容器云平台来做，在启动容器的时候就自动的设置好，类似cpu&#47;memory Cgroup的设置。<br><br>像Kubernetes的类似这么做，<br>https:&#47;&#47;github.com&#47;kubernetes&#47;kubernetes&#47;commit&#47;ecd6361ff0e8421332a50e55fcba17b823d5d338","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1605846983,"ip_address":"","comment_id":262786,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14490744140","product_id":100063801,"comment_content":"老师你好 关于设置容器的Cgroup 中 pids.max配置 ，是跟业务进程一起运行在容器中然后修改当前的容器配置，是否还有其他优雅的方式呢 ？","like_count":3,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509971,"discussion_content":"对容器设置pids Cgroup限制，一般需要容器云平台来做，在启动容器的时候就自动的设置好，类似cpu/memory Cgroup的设置。\n\n像Kubernetes的类似这么做，\nhttps://github.com/kubernetes/kubernetes/commit/ecd6361ff0e8421332a50e55fcba17b823d5d338","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605846983,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":273043,"user_name":"nuczzz","can_delete":false,"product_type":"c1","uid":1231168,"ip_address":"","ucode":"D85DCC67AFF922","user_header":"https://static001.geekbang.org/account/avatar/00/12/c9/40/b2e33f00.jpg","comment_is_top":false,"comment_ctime":1610419881,"is_pvip":false,"replies":[{"id":"99538","content":"kata是基于VM的，它里面的僵尸进程不会影响到宿主机。","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1610930567,"ip_address":"","comment_id":273043,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10200354473","product_id":100063801,"comment_content":"k8s+kata集群会有这个问题吗？感觉kata做了内核隔离，容器里的僵尸进程应该影响不到宿主机了","like_count":3,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513471,"discussion_content":"kata是基于VM的，它里面的僵尸进程不会影响到宿主机。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610930567,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296031,"user_name":"疯琴","can_delete":false,"product_type":"c1","uid":1099379,"ip_address":"","ucode":"82ACAA4A27753D","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/73/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1622710276,"is_pvip":false,"replies":[{"id":"111210","content":"可以看一下tini的代码","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1628865201,"ip_address":"","comment_id":296031,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5917677572","product_id":100063801,"comment_content":"老师，用 docker run --init 启动 registry&#47;sig-proc:v1 以后的确可以在容器内通过 kill 1 退出，但是我看SigCgt 仍然是 0000000000000000 并没有注册 sigterm 的 handler，请问这是为什么？","like_count":1,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521299,"discussion_content":"可以看一下tini的代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628865201,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1311299,"avatar":"https://static001.geekbang.org/account/avatar/00/14/02/43/1c2fb7b3.jpg","nickname":"Bourne","note":"","ucode":"1286279F70B13F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384220,"discussion_content":"可以看下第二节有位同学的留言，老师有讲。tini虽然没有捕获SIGTERM信号，但是它会把所有的信号都传给它的子进程，tini自己有循环检测的逻辑，当tini发现所有的子进程都推出了，tini自身也退出，所以导致容器退出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626430460,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2058258,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/68/12/031a05c3.jpg","nickname":"A免帅叫哥","note":"","ucode":"76D2522E602AEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1311299,"avatar":"https://static001.geekbang.org/account/avatar/00/14/02/43/1c2fb7b3.jpg","nickname":"Bourne","note":"","ucode":"1286279F70B13F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541475,"discussion_content":"不捕获，如何拦截信号呢？哪个系统调用可以做到那个事情呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640398477,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":384220,"ip_address":""},"score":541475,"extra":""}]}]},{"had_liked":false,"id":283814,"user_name":"争光 Alan","can_delete":false,"product_type":"c1","uid":1336328,"ip_address":"","ucode":"338534F909AF03","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/08/0287f41f.jpg","comment_is_top":false,"comment_ctime":1615945838,"is_pvip":false,"replies":[{"id":"103148","content":"ulimit对于shell session中的总进程数量做限制，pids cgroup对于控制块中的cgroup.procs&#47;tasks 中的进程数目做限制。都会起效，看哪个先达到限制值。","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1616247898,"ip_address":"","comment_id":283814,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5910913134","product_id":100063801,"comment_content":"老师，我最近发现ulimit也会限制进程数量，这两个有什么区别吗？在容器内具体是哪个在生效？","like_count":2,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517154,"discussion_content":"ulimit对于shell session中的总进程数量做限制，pids cgroup对于控制块中的cgroup.procs/tasks 中的进程数目做限制。都会起效，看哪个先达到限制值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616247898,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2608728,"avatar":"https://static001.geekbang.org/account/avatar/00/27/ce/58/71ed845f.jpg","nickname":"Dexter","note":"","ucode":"909CABC4AC4AC9","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404431,"discussion_content":"pids cgroup对于控制块中的cgroup.procs/tasks 中的进程数目做限制 --没明白什么意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634306305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":282835,"user_name":"北眸","can_delete":false,"product_type":"c1","uid":2069901,"ip_address":"","ucode":"5D18C8BC76DF4F","user_header":"https://static001.geekbang.org/account/avatar/00/1f/95/8d/c324a7de.jpg","comment_is_top":false,"comment_ctime":1615432860,"is_pvip":false,"replies":[{"id":"102732","content":"会的","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1615638153,"ip_address":"","comment_id":282835,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5910400156","product_id":100063801,"comment_content":"线程id会消耗&#47;proc&#47;sys&#47;kernel&#47;pid_max吗？","like_count":1,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516852,"discussion_content":"会的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615638153,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":282517,"user_name":"心随缘","can_delete":false,"product_type":"c1","uid":2057406,"ip_address":"","ucode":"F7F5C49EA80E03","user_header":"https://static001.geekbang.org/account/avatar/00/1f/64/be/546665e3.jpg","comment_is_top":false,"comment_ctime":1615288698,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5910255994","product_id":100063801,"comment_content":"子进程在结束前不一定都需要经过一个僵尸状 EXIT_ZOMBIE过程，主要在于其父进程是否显示忽略它的退出信号，如果不显示忽略，那么在父进程处理其退出信号或者父进程结束前，子进程都是处于 EXIT_ZOMBIE状态。当父进程退出时，子进程都会过继给 init进程，僵尸子进程也一样， init进程会负责清理这些僵尸进程。","like_count":1},{"had_liked":false,"id":276766,"user_name":"佳伦","can_delete":false,"product_type":"c1","uid":1064508,"ip_address":"","ucode":"3AE8098B5BE716","user_header":"https://static001.geekbang.org/account/avatar/00/10/3e/3c/fc3ad983.jpg","comment_is_top":false,"comment_ctime":1612103577,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5907070873","product_id":100063801,"comment_content":"我一般喜欢用&#47;bin&#47;bash启动容器，貌似没啥好的办法","like_count":1},{"had_liked":false,"id":272734,"user_name":"Shone","can_delete":false,"product_type":"c1","uid":1246271,"ip_address":"","ucode":"D4D8E9B66B428F","user_header":"https://static001.geekbang.org/account/avatar/00/13/04/3f/f28d76c5.jpg","comment_is_top":false,"comment_ctime":1610256964,"is_pvip":false,"replies":[{"id":"99042","content":"@Shone<br>&gt;1 <br>你说的个别pod里出现僵尸进程，这个还要看一下pilot-agent下的那写进程的行为，是不是只是个别pod中的子进程在某些条件下退出了，而其他pod里并没有进程退出的状况。<br><br>&gt;2<br>kubelet的Health check应该和僵尸进程没有关系。回收僵尸进程更多的是父进程的责任。kubelet 让containerd去创建容器，它不在容器进程树结构上。Kubelet可以负责回收残留的容器，但是在容器活着的时候，它不用负责容器namespace中的残留进程。","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1610551181,"ip_address":"","comment_id":272734,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5905224260","product_id":100063801,"comment_content":"老师，请教一下。之前我们在istio-proxy sidecar上通过exec去做readinessprobe就遇到了这个问题，是因为istio sidecar的1号进程是pilot-agent，它不能回收僵尸进程，后来的改动是用shell脚本包了一下pilot-agent，而 bash是可以回收僵尸进程的。我有两个问题：<br>1，是什么样的情况会导致僵尸进程？这个问题之前没有普遍出现，只有个别的pod出现了。<br>2，这个看起来也和kubelet通过exec做健康检查有关系，它隐含了一个条件是要容器自己负责回收僵尸进程，有没有可能改进kubelet来解决这个问题？","like_count":1,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513368,"discussion_content":"@Shone\n&amp;gt;1 \n你说的个别pod里出现僵尸进程，这个还要看一下pilot-agent下的那写进程的行为，是不是只是个别pod中的子进程在某些条件下退出了，而其他pod里并没有进程退出的状况。\n\n&amp;gt;2\nkubelet的Health check应该和僵尸进程没有关系。回收僵尸进程更多的是父进程的责任。kubelet 让containerd去创建容器，它不在容器进程树结构上。Kubelet可以负责回收残留的容器，但是在容器活着的时候，它不用负责容器namespace中的残留进程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610551181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":272030,"user_name":"Action","can_delete":false,"product_type":"c1","uid":1239234,"ip_address":"","ucode":"FFFD1537C6BB3C","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/c2/77a413a7.jpg","comment_is_top":false,"comment_ctime":1609914295,"is_pvip":false,"replies":[{"id":"98652","content":"task_struct 是内核中描述进程的结构，每个进程申请的内存，打开的文件等信息都记录在这个结构里。当进程退出的时候，需要先把进程里的这些资源释放，最后再释放task_struct结构。","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1609945300,"ip_address":"","comment_id":272030,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5904881591","product_id":100063801,"comment_content":"老师 这个没太懂什么意思：“从内核进程的 do_exit() 函数我们也可以看到，这时候进程 task_struct 里的 mm&#47;shm&#47;sem&#47;files 等文件资源都已经释放了，只留下了一个 stask_struct instance 空壳“","like_count":1,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513127,"discussion_content":"task_struct 是内核中描述进程的结构，每个进程申请的内存，打开的文件等信息都记录在这个结构里。当进程退出的时候，需要先把进程里的这些资源释放，最后再释放task_struct结构。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609945300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263219,"user_name":"朱雯","can_delete":false,"product_type":"c1","uid":1035744,"ip_address":"","ucode":"064C45FBF6B51F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cd/e0/c85bb948.jpg","comment_is_top":false,"comment_ctime":1606050235,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5901017531","product_id":100063801,"comment_content":"关于思考题：那肯定是不行的，因为进程的父进程还在，必须好似父进程调用waitpid来操作，其他人是无权的，子进程的子进程不是我的子进程，除非父进程死去，死去后应该是由于init进程直接收养，也不会被父进程的父进程收养。","like_count":1},{"had_liked":false,"id":262873,"user_name":"水蒸蛋","can_delete":false,"product_type":"c1","uid":1809160,"ip_address":"","ucode":"6F7F853A4BF901","user_header":"https://static001.geekbang.org/account/avatar/00/1b/9b/08/27ac7ecd.jpg","comment_is_top":false,"comment_ctime":1605865184,"is_pvip":false,"replies":[{"id":"95368","content":"僵尸进程是进程的一个状态， 只要进程退出就会有这状态。清理的僵尸进程的是它的父进程。<br>这个和服务进程运行时间长了之后，通过重启进程去清理泄漏的资源，比如内存或者文件fd， 是两个概念。<br>","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1605877028,"ip_address":"","comment_id":262873,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5900832480","product_id":100063801,"comment_content":"老师，我还是没看明白僵尸线程的产生，它就是卡在exit zomble状态的进程，那这个产生是必然的吗，就和垃圾一样运行时间长了肯定会有一些垃圾产生，需要做的就是用主线程清理，我平时碰到这个都是重启对应的服务","like_count":1,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510010,"discussion_content":"僵尸进程是进程的一个状态， 只要进程退出就会有这状态。清理的僵尸进程的是它的父进程。\n这个和服务进程运行时间长了之后，通过重启进程去清理泄漏的资源，比如内存或者文件fd， 是两个概念。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605877028,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1809160,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9b/08/27ac7ecd.jpg","nickname":"水蒸蛋","note":"","ucode":"6F7F853A4BF901","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327735,"discussion_content":"老师你的意思是这个状态就是要靠他的父进程回收，如果有大量堆积，就说明父进程的回收策略有问题是不是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605928522,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262842,"user_name":"kimoti","can_delete":false,"product_type":"c1","uid":1897671,"ip_address":"","ucode":"0A78077408C2B1","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f4/c7/037235c9.jpg","comment_is_top":false,"comment_ctime":1605857420,"is_pvip":false,"replies":[{"id":"95369","content":"@kimoti, 这个和启动容器的工具无关，而是容器中运行的程序来决定的。","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1605877296,"ip_address":"","comment_id":262842,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5900824716","product_id":100063801,"comment_content":"想请教老师一个问题,我们现在用的容器技术比如Docker或者Kubernetes创建的容器会产生僵尸进程吗？","like_count":1,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509994,"discussion_content":"@kimoti, 这个和启动容器的工具无关，而是容器中运行的程序来决定的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605877296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1809160,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9b/08/27ac7ecd.jpg","nickname":"水蒸蛋","note":"","ucode":"6F7F853A4BF901","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327908,"discussion_content":"这个会的，容器经常会产生僵尸线程，我也不是很懂这个是init的问题还是系统的问题导致","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606015343,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262756,"user_name":"Geek2014","can_delete":false,"product_type":"c1","uid":2028957,"ip_address":"","ucode":"9EB356D8DF287E","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f5/9d/104bb8ea.jpg","comment_is_top":false,"comment_ctime":1605837989,"is_pvip":false,"replies":[{"id":"95353","content":"@Geek2014<br>谢谢你的分析。","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1605847358,"ip_address":"","comment_id":262756,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5900805285","product_id":100063801,"comment_content":"如果容器的 init 进程创建了子进程 B，B 又创建了自己的子进程 C。如果 C 运行完之后，退出成了僵尸进程，B 进程还在运行，而容器的 init 进程还在不断地调用 waitpid()，那 C 这个僵尸进程可以被回收吗？<br><br>个人理解，C是不会被回收的，只有等到B也被杀死，C这个僵尸进程也会变成孤儿进程，被init进程收养，进而被init的wait机制清理掉。","like_count":1,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509959,"discussion_content":"@Geek2014\n谢谢你的分析。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605847358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262714,"user_name":"骑马户兜风","can_delete":false,"product_type":"c1","uid":2328491,"ip_address":"","ucode":"B455807DC83495","user_header":"https://static001.geekbang.org/account/avatar/00/23/87/ab/d8b392ee.jpg","comment_is_top":false,"comment_ctime":1605832039,"is_pvip":false,"replies":[{"id":"95352","content":"@骑马户兜风<br>&gt; 问一下，如果这时候我们将B杀死，C的僵尸就会变成孤儿僵尸，就会被init（1）托管，这种情况会被清理吗？<br><br>对的，这种情况C的父进程就会变为1 (init)。如果init里在waitpid()，那么就可以清理它了。","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1605847327,"ip_address":"","comment_id":262714,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5900799335","product_id":100063801,"comment_content":"如果容器的 init 进程创建了子进程 B，B 又创建了自己的子进程 C。如果 C 运行完之后，退出成了僵尸进程，B 进程还在运行，而容器的 init 进程还在不断地调用 waitpid()，那 C 这个僵尸进程可以被回收吗？<br>不会，因为init的waitpid只会清理他的子进程，而B进程正常运行，没有僵尸。我理解的对吗？<br>老师，问一下，如果这时候我们将B杀死，C的僵尸就会变成孤儿僵尸，就会被init（1）托管，这种情况会被清理吗？","like_count":1,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509937,"discussion_content":"@骑马户兜风\n&amp;gt; 问一下，如果这时候我们将B杀死，C的僵尸就会变成孤儿僵尸，就会被init（1）托管，这种情况会被清理吗？\n\n对的，这种情况C的父进程就会变为1 (init)。如果init里在waitpid()，那么就可以清理它了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605847327,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343579,"user_name":"Yoge","can_delete":false,"product_type":"c1","uid":1870501,"ip_address":"","ucode":"44100445F2A775","user_header":"https://static001.geekbang.org/account/avatar/00/1c/8a/a5/6367def9.jpg","comment_is_top":false,"comment_ctime":1650939587,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650939587","product_id":100063801,"comment_content":"我还是没想明白，tini的引入也不能解决原本逻辑有缺陷的父进程回收僵尸子进程的问题啊？","like_count":0},{"had_liked":false,"id":325206,"user_name":"MiracleWong","can_delete":false,"product_type":"c1","uid":1012816,"ip_address":"","ucode":"05233774710AFE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/74/50/59d429c9.jpg","comment_is_top":false,"comment_ctime":1638863455,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1638863455","product_id":100063801,"comment_content":"记录一下：<br>OS：Ubuntu 20.04 LTS<br>Docker： 20.10.11<br><br>pids.max 的地址路径为：&#47;sys&#47;fs&#47;cgroup&#47;pids&#47;docker&#47;docker的id号  <br>举例：我的为：&#47;sys&#47;fs&#47;cgroup&#47;pids&#47;docker&#47;3a60099ad574e6fc4e72a0d3e8b292150f5e540af1eb09546de8bd757db81c6e<br><br>大家可以在&#47;sys&#47;fs&#47;cgroup&#47;下，通过命令：find . -name *你的实际Docker Id*<br>如：find . -name *3a60099* 查找即可。<br><br>通过命令： echo 1002 &gt; pids.max <br>可以复现现象：<br>bash: fork: retry: Resource temporarily unavailable<br><br>更改回去：echo max &gt; pids.max  ，再执行命令回归正常。<br><br>在 &#47;sys&#47;fs&#47;cgroup&#47;pids&#47;docker&#47; 下（非docker id路径下），也有一个pids.max 和 pids.currrent。尝试了下，此处 echo 1002 &gt; pids.max  也可以复现 “Resource temporarily unavailable”现象。<br><br>这里应该是docker 路径下pids.max 的总控，docker id 路径下（如3a60099ad574e6fc4e72a0d3e8b292150f5e540af1eb09546de8bd757db81c6e）的pids.max 则是单独容器的控制<br>","like_count":0},{"had_liked":false,"id":307937,"user_name":"罗峰","can_delete":false,"product_type":"c1","uid":1218501,"ip_address":"","ucode":"5F3D6AF8F28322","user_header":"https://static001.geekbang.org/account/avatar/00/12/97/c5/84491beb.jpg","comment_is_top":false,"comment_ctime":1629333887,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629333887","product_id":100063801,"comment_content":"注册sigchldhandler也可以处理僵尸进程，感觉更方便","like_count":0},{"had_liked":false,"id":305198,"user_name":"Tendrun","can_delete":false,"product_type":"c1","uid":1225728,"ip_address":"","ucode":"86AB3C3A7D8381","user_header":"https://static001.geekbang.org/account/avatar/00/12/b4/00/bfc101ee.jpg","comment_is_top":false,"comment_ctime":1627874047,"is_pvip":true,"replies":[{"id":"110971","content":"在整个容器退出的时候shim可以，但是如果容器没有退出，shim不会回收容器内的僵尸进程。","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1628600530,"ip_address":"","comment_id":305198,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1627874047","product_id":100063801,"comment_content":"containerd-shim进程不能来解决僵尸进程的回收问题么？","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524313,"discussion_content":"在整个容器退出的时候shim可以，但是如果容器没有退出，shim不会回收容器内的僵尸进程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628600530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":298197,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1623942227,"is_pvip":false,"replies":[{"id":"111192","content":"对于ubuntu 20.04, 新的systemd里会把pid_max 设置成4194304<br><br>https:&#47;&#47;github.com&#47;systemd&#47;systemd&#47;blob&#47;main&#47;sysctl.d&#47;50-pid-max.conf<br><br># cat &#47;usr&#47;lib&#47;sysctl.d&#47;50-pid-max.conf  | grep pid_max<br>kernel.pid_max = 4194304","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1628847487,"ip_address":"","comment_id":298197,"utype":1}],"discussion_count":2,"race_medal":1,"score":"1623942227","product_id":100063801,"comment_content":"Ubuntu 20.04.2 LTS  <br>Linux 5.8.0-55-generic  <br>机器只有4核CPU，但&#47;proc&#47;sys&#47;kernel&#47;pid_max里的值为4194304，即上限：2的22次方。<br>查了一下，也没找到为啥设置这么大，有小伙伴知道么<br><br>","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522052,"discussion_content":"对于ubuntu 20.04, 新的systemd里会把pid_max 设置成4194304\n\nhttps://github.com/systemd/systemd/blob/main/sysctl.d/50-pid-max.conf\n\n# cat /usr/lib/sysctl.d/50-pid-max.conf  | grep pid_max\nkernel.pid_max = 4194304","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628847487,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2061524,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/74/d4/38d813f0.jpg","nickname":"Kerry","note":"","ucode":"92F809EC998FC6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390429,"discussion_content":"Ubuntu 20.04.3 LTS on 5.4.72-microsoft-standard-WSL2  x86_64，实测是32768","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629822140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":281939,"user_name":"孟小呆","can_delete":false,"product_type":"c1","uid":1478819,"ip_address":"","ucode":"A2B46F1E6BC5E7","user_header":"https://static001.geekbang.org/account/avatar/00/16/90/a3/0dc975fe.jpg","comment_is_top":false,"comment_ctime":1614957742,"is_pvip":false,"replies":[{"id":"102395","content":"@孟小呆, 我没有使用过rancher. 如果它没有类似docker的 --init参数， 是否可以考虑在你的jenkins容器中自己加一个init process.","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1615032255,"ip_address":"","comment_id":281939,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1614957742","product_id":100063801,"comment_content":"老师, 我搭建了rancher集群, 在集群中运行Jenkins agent容器. 因为Jenkins agent容器镜像不会处理僵死进程, 但是我也没在rancher中找到给容器添加--init启动参数的入口","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516557,"discussion_content":"@孟小呆, 我没有使用过rancher. 如果它没有类似docker的 --init参数， 是否可以考虑在你的jenkins容器中自己加一个init process.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615032255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":277447,"user_name":"cyz","can_delete":false,"product_type":"c1","uid":1498145,"ip_address":"","ucode":"233B1FC28A45F1","user_header":"https://static001.geekbang.org/account/avatar/00/16/dc/21/34c72e67.jpg","comment_is_top":false,"comment_ctime":1612416911,"is_pvip":false,"replies":[{"id":"100831","content":"这就是说明 max pids被限制之后，在容器中已经不能再建新的进程了。","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1612624577,"ip_address":"","comment_id":277447,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1612416911","product_id":100063801,"comment_content":"老师，执行完echo 1002 &gt; pids.max后docker exec 7fc05d6ac923295 ps，报下面的错，请问是什么原因，怎么验证下更改生效了，应该是Z进程没有了么。<br>OCI runtime exec failed: exec failed: container_linux.go:349: starting container process caused &quot;read init-p: connection reset by peer&quot;: unknown","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515054,"discussion_content":"这就是说明 max pids被限制之后，在容器中已经不能再建新的进程了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612624577,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":272896,"user_name":"徐少文","can_delete":false,"product_type":"c1","uid":1670331,"ip_address":"","ucode":"8E35B10DA44EE3","user_header":"https://static001.geekbang.org/account/avatar/00/19/7c/bb/635a2710.jpg","comment_is_top":false,"comment_ctime":1610349706,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610349706","product_id":100063801,"comment_content":"老师好，我想问一个有关于wait系统调用的问题。既然wait系统调用的作用是等待子进程运行结束。可我在使用ptrace时，ptrace总是和wait成对出现，但是并没有涉及到子进程退出的问题，请问老师，使用ptrace时的wait要怎么理解？","like_count":0},{"had_liked":false,"id":266502,"user_name":"维c","can_delete":false,"product_type":"c1","uid":2048787,"ip_address":"","ucode":"FAD5EE298D5F2D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/43/13/9b24c185.jpg","comment_is_top":false,"comment_ctime":1607355677,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607355677","product_id":100063801,"comment_content":"看了下资料，貌似sigaction函数可以设置SA_NOCLDWAIT flag来忽略子进程的状态，使得退出的时候直接终止进程。不过这也会导致父进程拿不到子进程的状态。<br>那么这个是要配合注册的信号处理函数通过信号携带的信息来保证父进程能做到正确的处理子进程的状态还是说这种处理方式就没有办法处理子进程的状态呢？<br>看 man里面的介绍，感觉有点没看懂。<br>SA_NOCLDWAIT (since Linux 2.6)<br>                  If  signum  is SIGCHLD, do not transform children into zom‐<br>                  bies when they terminate.  See also waitpid(2).  This  flag<br>                  is meaningful only when establishing a handler for SIGCHLD,<br>                  or when setting that signal&#39;s disposition to SIG_DFL.<br><br>                  If the SA_NOCLDWAIT flag is set when establishing a handler<br>                  for  SIGCHLD,  POSIX.1  leaves  it  unspecified  whether  a<br>                  SIGCHLD signal is generated when  a  child  process  termi‐<br>                  nates.   On  Linux,  a  SIGCHLD signal is generated in this<br>                  case; on some other implementations, it is not.","like_count":0},{"had_liked":false,"id":265144,"user_name":"夜空中最亮的星","can_delete":false,"product_type":"c1","uid":1267566,"ip_address":"","ucode":"ADC3E7B6789955","user_header":"https://static001.geekbang.org/account/avatar/00/13/57/6e/b6795c44.jpg","comment_is_top":false,"comment_ctime":1606792520,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606792520","product_id":100063801,"comment_content":"c应该不会被回收，因为c的父亲还在，收拾c的责任在b。","like_count":0},{"had_liked":false,"id":264724,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1606616832,"is_pvip":true,"replies":[{"id":"96012","content":"进程sleep状态是这个例子代码里就是调用了sleep, 然后就退出了进程，进入zombie。<br><br>例子代码在这里：<br>https:&#47;&#47;github.com&#47;chengyli&#47;training&#47;blob&#47;main&#47;init_proc&#47;zombie_proc&#47;app-test-nowait.c#L26","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1606641887,"ip_address":"","comment_id":264724,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1606616832","product_id":100063801,"comment_content":"在使用文中示例创建进程的时候，那1000个进程 会先进入 S （sleeping） 状态，等待一会后才会进入  Z （zombie） 状态？ 这是为什么的？ 这是在等待什么信号的吗？","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510664,"discussion_content":"进程sleep状态是这个例子代码里就是调用了sleep, 然后就退出了进程，进入zombie。\n\n例子代码在这里：\nhttps://github.com/chengyli/training/blob/main/init_proc/zombie_proc/app-test-nowait.c#L26","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606641887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":264568,"user_name":"姜姜","can_delete":false,"product_type":"c1","uid":1120332,"ip_address":"","ucode":"1DAD620C8E9F31","user_header":"https://static001.geekbang.org/account/avatar/00/11/18/4c/e12f3b41.jpg","comment_is_top":false,"comment_ctime":1606528212,"is_pvip":false,"replies":[{"id":"96509","content":"父进程只是ignore SIGCHLD, 子进程可以被init进程接管吗？","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1606918726,"ip_address":"","comment_id":264568,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1606528212","product_id":100063801,"comment_content":"处理僵尸进程，除了显式调用wait()和waitpid()之外，还可以在父进程里显式调用signal(SIGCHLD, SIG_IGN)来忽略子进程退出的信号，这样内核将把僵尸子进程交由init进程去处理。","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510601,"discussion_content":"父进程只是ignore SIGCHLD, 子进程可以被init进程接管吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606918726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1120332,"avatar":"https://static001.geekbang.org/account/avatar/00/11/18/4c/e12f3b41.jpg","nickname":"姜姜","note":"","ucode":"1DAD620C8E9F31","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331677,"discussion_content":"哦，不好意思，这里有误，查阅了一下，只有System V版本的系统可以ignore SIGCHLD不产生僵尸进程。但Posix不支持，还是需要捕获信号用wait或waitpid。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606927464,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263516,"user_name":"胖胖虎","can_delete":false,"product_type":"c1","uid":1139121,"ip_address":"","ucode":"9CA8F99CC82944","user_header":"https://static001.geekbang.org/account/avatar/00/11/61/b1/1261c177.jpg","comment_is_top":false,"comment_ctime":1606146691,"is_pvip":false,"replies":[{"id":"95629","content":"在容器里的1号进程是用户自定义的，那么容器的1号进程是否会用wait&#47;waitpid去回收僵尸进程就不是一定的了。","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1606190998,"ip_address":"","comment_id":263516,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1606146691","product_id":100063801,"comment_content":"所以，为什么容器里面会有很多僵尸进程呢。一开始以为容器的pid 1 进程不会做进程回收导致，但是整篇文章看下来，又似乎容器的pid 1进程会waitpid。文章给的示例，是一个编程问题，但不是容器独有的，即使在容器外面跑也是会有同样的现象发生。那么本章提出的问题的答案到底是什么呢？希望老师能够帮忙解答。","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510222,"discussion_content":"在容器里的1号进程是用户自定义的，那么容器的1号进程是否会用wait/waitpid去回收僵尸进程就不是一定的了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606190998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1139121,"avatar":"https://static001.geekbang.org/account/avatar/00/11/61/b1/1261c177.jpg","nickname":"胖胖虎","note":"","ucode":"9CA8F99CC82944","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328650,"discussion_content":"谢谢回复，今天又学习了一下，容器内部的进程，一般情况下都是要运行的应用本身，因此不一定会具有wait和waitpid调用来回收僵尸进程。因此，确实会出现僵尸进程很多的情况。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1606203222,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263316,"user_name":"争光 Alan","can_delete":false,"product_type":"c1","uid":1336328,"ip_address":"","ucode":"338534F909AF03","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/08/0287f41f.jpg","comment_is_top":false,"comment_ctime":1606099947,"is_pvip":false,"replies":[{"id":"95590","content":"&gt; 僵尸进程就是子进程退出时父进程没处理导致？还是有很多情况？<br><br>对于一个进程只有一个线程的时候，如果在ps里看到的是Z进程，那么它就是Z进程，就是由于父进程没有回收导致的。<br>不过如果一个进程中有多个线程的情况下，你在ps里看到整个进程是Z状态，但是这时候，有可能的问题是进程中有一个线程是D状态的(uninterruptible)。不过这种情况，其实是D状态的问题了。<br><br>&gt; 他是等待进程退出并且清理进程？<br>对的，就是等待并清理退出的子进程。","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1606143867,"ip_address":"","comment_id":263316,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1606099947","product_id":100063801,"comment_content":"另外感觉还是有点模糊，<br>僵尸进程就是子进程退出时父进程没处理导致？还是有很多情况？<br>另外wait()具体是操作了什么能解释一下吗？他是等待进程退出并且清理进程？","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510146,"discussion_content":"&amp;gt; 僵尸进程就是子进程退出时父进程没处理导致？还是有很多情况？\n\n对于一个进程只有一个线程的时候，如果在ps里看到的是Z进程，那么它就是Z进程，就是由于父进程没有回收导致的。\n不过如果一个进程中有多个线程的情况下，你在ps里看到整个进程是Z状态，但是这时候，有可能的问题是进程中有一个线程是D状态的(uninterruptible)。不过这种情况，其实是D状态的问题了。\n\n&amp;gt; 他是等待进程退出并且清理进程？\n对的，就是等待并清理退出的子进程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606143867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2608728,"avatar":"https://static001.geekbang.org/account/avatar/00/27/ce/58/71ed845f.jpg","nickname":"Dexter","note":"","ucode":"909CABC4AC4AC9","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404432,"discussion_content":"wait()等待并清理退出的子进程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634306547,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1035744,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cd/e0/c85bb948.jpg","nickname":"朱雯","note":"","ucode":"064C45FBF6B51F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328341,"discussion_content":"目前我的感觉是，wait应该是随机回收一个pid的僵死进程。。。具体我也只是猜测","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606124837,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263314,"user_name":"争光 Alan","can_delete":false,"product_type":"c1","uid":1336328,"ip_address":"","ucode":"338534F909AF03","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/08/0287f41f.jpg","comment_is_top":false,"comment_ctime":1606099656,"is_pvip":false,"replies":[{"id":"95588","content":"如果已经产生僵尸进程，的确没有太好的清理办法。尽量从init进程去回收僵尸进程。","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1606143405,"ip_address":"","comment_id":263314,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1606099656","product_id":100063801,"comment_content":"想问下，除了父进程修复清理逻辑外，作为运维有哪些手段清理僵尸进程呢？我目前测试只找到了重启一个方法，还有别的方法吗？","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510144,"discussion_content":"如果已经产生僵尸进程，的确没有太好的清理办法。尽量从init进程去回收僵尸进程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606143405,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1035744,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cd/e0/c85bb948.jpg","nickname":"朱雯","note":"","ucode":"064C45FBF6B51F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328340,"discussion_content":"刚才找到一个方法，给僵死进程的父进程发送SIGCHLD信号，可以系统将这个僵死进程回收。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1606124799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263218,"user_name":"朱雯","can_delete":false,"product_type":"c1","uid":1035744,"ip_address":"","ucode":"064C45FBF6B51F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cd/e0/c85bb948.jpg","comment_is_top":false,"comment_ctime":1606050135,"is_pvip":true,"replies":[{"id":"95545","content":"@朱雯<br>&gt; 问题1<br>你可以到 &#47;sys&#47;fs&#47;cgroup&#47;pids 目录下试试搜索一下container id, 或者带docker关键字的目录。<br><br># pwd<br>&#47;sys&#47;fs&#47;cgroup&#47;pids<br># find . -name *7bab7f79d70c*<br>.&#47;system.slice&#47;docker-7bab7f79d70cbf7a59344856eecfb52c1e1d4706d3fbe3e4b74c5172ea7af541.scope<br># find . -name docker*<br>.&#47;system.slice&#47;docker.service<br>.&#47;system.slice&#47;docker-7bab7f79d70cbf7a59344856eecfb52c1e1d4706d3fbe3e4b74c5172ea7af541.scope<br>.&#47;system.slice&#47;docker.socket<br><br>&gt; 问题2<br>wait()是不指定要回收哪个pid的，只要是它的子进程退出就可以回收。waitpid()是有参数pid的，可以指定要回收的进程。<br><br>&gt; 问题3<br>把pid.maxs改成无限大，那么如果真的有海量进程在系统中，那么从内核内存，进程的调度，都会出现更多的问题或者系统直接就死了。<br><br>&gt; 最后，这居然是一门操作系统的课程，我之前挺害怕os的，现在感觉找到一切切入点了<br>的确是这样的，很多容器的问题就是归结到OS的问题。学习容器也是一个很好的学习OS的切入点！<br><br>&gt; ","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1606109553,"ip_address":"","comment_id":263218,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1606050135","product_id":100063801,"comment_content":"老师好，<br>问题1:修改容器的pid.max怎么修改，我看到您直接修改宿主机的一个目录，但是我并没有类似的目录名称。<br>问题2: for (i = 0; i &lt; total; i++) { int status; wait(&amp;status); } status这个int类型的值都没有被赋值，wait又是如何知道他要回收哪个呢，同样的问题，也在于waitpid。<br>问题3:既然知道了pid.maxs这个文件，那我有个想法，那就是把宿主机的这个文件无限的改大，那岂不是无限进程启动了，虽然我在宿主机上没找到这个文件。<br>最后，这居然是一门操作系统的课程，我之前挺害怕os的，现在感觉找到一切切入点了，可以尝试一下学一些原理了，谢谢老师。","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510123,"discussion_content":"@朱雯\n&amp;gt; 问题1\n你可以到 /sys/fs/cgroup/pids 目录下试试搜索一下container id, 或者带docker关键字的目录。\n\n# pwd\n/sys/fs/cgroup/pids\n# find . -name *7bab7f79d70c*\n./system.slice/docker-7bab7f79d70cbf7a59344856eecfb52c1e1d4706d3fbe3e4b74c5172ea7af541.scope\n# find . -name docker*\n./system.slice/docker.service\n./system.slice/docker-7bab7f79d70cbf7a59344856eecfb52c1e1d4706d3fbe3e4b74c5172ea7af541.scope\n./system.slice/docker.socket\n\n&amp;gt; 问题2\nwait()是不指定要回收哪个pid的，只要是它的子进程退出就可以回收。waitpid()是有参数pid的，可以指定要回收的进程。\n\n&amp;gt; 问题3\n把pid.maxs改成无限大，那么如果真的有海量进程在系统中，那么从内核内存，进程的调度，都会出现更多的问题或者系统直接就死了。\n\n&amp;gt; 最后，这居然是一门操作系统的课程，我之前挺害怕os的，现在感觉找到一切切入点了\n的确是这样的，很多容器的问题就是归结到OS的问题。学习容器也是一个很好的学习OS的切入点！\n\n&amp;gt; ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606109553,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263031,"user_name":"谢哈哈","can_delete":false,"product_type":"c1","uid":2326880,"ip_address":"","ucode":"5AADE70B5AFE27","user_header":"https://static001.geekbang.org/account/avatar/00/23/81/60/71ed6ac7.jpg","comment_is_top":false,"comment_ctime":1605952806,"is_pvip":false,"replies":[{"id":"95483","content":"嗯，<br>&gt; A进程也退出不了<br>你这里是指C吧？","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1606016168,"ip_address":"","comment_id":263031,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1605952806","product_id":100063801,"comment_content":"A进程也退出不了，因为B没退出，A的waitpid捕捉不到僵尸进程状态","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510077,"discussion_content":"嗯，\n&amp;gt; A进程也退出不了\n你这里是指C吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606016168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2326880,"avatar":"https://static001.geekbang.org/account/avatar/00/23/81/60/71ed6ac7.jpg","nickname":"谢哈哈","note":"","ucode":"5AADE70B5AFE27","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327927,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606018955,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262915,"user_name":"po","can_delete":false,"product_type":"c1","uid":1023905,"ip_address":"","ucode":"7DB36C278F34D7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9f/a1/d75219ee.jpg","comment_is_top":false,"comment_ctime":1605882730,"is_pvip":true,"replies":[{"id":"95469","content":"SIGTERM&#47;SIGKILL这时候是不能够杀死僵尸进程了。只能依靠父进程的wait&#47;waitpid去回收。","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1606014705,"ip_address":"","comment_id":262915,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1605882730","product_id":100063801,"comment_content":"老师，还有个问题，如果在发生操作系统或者容器中有很多僵尸进程，现场快速的解决办法是通过sigterm或者sigkill暂时杀掉僵尸进程解决问题吗？","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510030,"discussion_content":"SIGTERM/SIGKILL这时候是不能够杀死僵尸进程了。只能依靠父进程的wait/waitpid去回收。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606014705,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1217712,"avatar":"https://static001.geekbang.org/account/avatar/00/12/94/b0/b073fe8b.jpg","nickname":"aMaMiMoU","note":"","ucode":"AF1E6CA541E482","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333430,"discussion_content":"有一种办法不知道是否可行：nsenter启动一个包含waitpid逻辑的应用进程，同时nsenter指定进入与僵尸进程的父进程PID的namespace里","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607519451,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1023905,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9f/a1/d75219ee.jpg","nickname":"po","note":"","ucode":"7DB36C278F34D7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327975,"discussion_content":"这个时候就是因为父进程没法处理这些僵尸进程，所以得找个办法解决，那需要怎么办呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606033522,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1139121,"avatar":"https://static001.geekbang.org/account/avatar/00/11/61/b1/1261c177.jpg","nickname":"胖胖虎","note":"","ucode":"9CA8F99CC82944","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327932,"discussion_content":"可以杀掉父进程来解决问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606020836,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262908,"user_name":"po","can_delete":false,"product_type":"c1","uid":1023905,"ip_address":"","ucode":"7DB36C278F34D7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9f/a1/d75219ee.jpg","comment_is_top":false,"comment_ctime":1605879299,"is_pvip":true,"replies":[{"id":"95468","content":"@po, <br>&gt; 问题A: 如果init没有waitpid()或者wait()功能，那么僵尸进程是不是就不能回收了？<br>对的，如果父进程没有waitpid&#47;wait, 那么僵尸进程就不能回收了。<br><br>&gt; 问题B: 像在容器中，产生僵尸进程是应用的问题吧？容器平台并不能解决僵尸进程的问题，需要开发介入吧？<br>是的。<br><br>&gt; 问题C<br>对的，可以在容器里启动dumb-init&#47;tini之类的小型init服务来解决容器里init进程相关的问题。 <br><br>","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1606014636,"ip_address":"","comment_id":262908,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605879299","product_id":100063801,"comment_content":"老师的这个问题，我的理解是每个人只对自己的孩子负责，爷爷只管爸爸，爸爸只管孙子，爷爷不管孙子，如果爸爸挂了，爷爷就会代管孙子，所以init不会去回收C。<br><br>我还有几个问题：<br>问题A: 如果init没有waitpid()或者wait()功能，那么僵尸进程是不是就不能回收了？<br><br>问题B: 像在容器中，产生僵尸进程是应用的问题吧？容器平台并不能解决僵尸进程的问题，需要开发介入吧？<br><br>问题C：我在一个博客上看到一句话：如果父进程在子进程之前退出，子进程会变成孤儿进程, 它的父进程会变成 PID 1。因此，init 进程就要对这些进程负责，并在适当的时候调用 wait() 方法。但是，通常情况下，大部分进程不会处理偶然依附在自己进程上的随机子进程，所以在容器中，会出现许多僵尸进程。让所有的应用能正确的处理以上的情况，不太现实。好在现在有很多解决方案，例如dumb-init [0] 。他像是一个小型 init 服务，他启动一个子进程并转发所有接收到的信号量给子进程。而且不需要修改应用代码。此时你的应用进程已经不是 pid 1 了，所以已经没有上面提到的问题。而且 dumb-init<br>也会转发所有的信号给子进程，应用的形为和在没有 dumb-init 时是一样的。如果应用进程死掉了，dumb-init 进程也会死掉，并会清理所有其它的子进程。<br>=====================<br>请问老师，这样是解决僵尸和孤儿进程的最佳方式吗？","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510026,"discussion_content":"@po, \n&amp;gt; 问题A: 如果init没有waitpid()或者wait()功能，那么僵尸进程是不是就不能回收了？\n对的，如果父进程没有waitpid/wait, 那么僵尸进程就不能回收了。\n\n&amp;gt; 问题B: 像在容器中，产生僵尸进程是应用的问题吧？容器平台并不能解决僵尸进程的问题，需要开发介入吧？\n是的。\n\n&amp;gt; 问题C\n对的，可以在容器里启动dumb-init/tini之类的小型init服务来解决容器里init进程相关的问题。 \n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606014636,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262838,"user_name":"kimoti","can_delete":false,"product_type":"c1","uid":1897671,"ip_address":"","ucode":"0A78077408C2B1","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f4/c7/037235c9.jpg","comment_is_top":false,"comment_ctime":1605857290,"is_pvip":false,"replies":[{"id":"95370","content":"@kimoti, 可以写个程序试试。","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1605877341,"ip_address":"","comment_id":262838,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605857290","product_id":100063801,"comment_content":"因为init进程是所有进程的父进程,所以进程C也是可以被回收的。","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509993,"discussion_content":"@kimoti, 可以写个程序试试。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605877341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}