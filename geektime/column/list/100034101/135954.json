{"id":135954,"title":"14 | 前端技术应用（一）：如何透明地支持数据库分库分表？","content":"<p>从今天开始，我们正式进入了应用篇，我会用两节课的时间，带你应用编译器的前端技术。这样，你会把学到的编译技术和应用领域更好地结合起来，学以致用，让技术发挥应有的价值。还能通过实践加深对原理的理解，形成一个良好的循环。</p><p>这节课，我们主要讨论，一个分布式数据库领域的需求。我会带你设计一个中间层，让应用逻辑不必关心数据库的物理分布。这样，无论把数据库拆成多少个分库，编程时都会像面对一个物理库似的没什么区别。</p><p>接下来，我们先了解一下分布式数据库的需求和带来的挑战。</p><h2>分布式数据库解决了什么问题，又带来了哪些挑战</h2><p>随着技术的进步，我们编写的应用所采集、处理的数据越来越多，处理的访问请求也越来越多。而单一数据库服务器的处理能力是有限的，当数据量和访问量超过一定级别以后，就要开始做分库分表的操作。比如，把一个数据库的大表拆成几张表，把一个库拆成几个库，把读和写的操作分离开等等。<strong>我们把这类技术统称为分布式数据库技术。</strong></p><p>分库分表（Sharding）有时也翻译成“数据库分片”。分片可以依据各种不同的策略，比如我开发过一个与社区有关的应用系统，这个系统的很多业务逻辑都是围绕小区展开的。对于这样的系统，按照<strong>地理分布的维度</strong>来分片就很合适，因为每次对数据库的操作基本上只会涉及其中一个分库。</p><!-- [[[read_end]]] --><p>假设我们有一个订单表，那么就可以依据一定的规则对订单或客户进行编号，编号中就包含地理编码。比如SDYT代表山东烟台，BJHD代表北京海淀，不同区域的数据放在不同的分库中：</p><p><img src=\"https://static001.geekbang.org/resource/image/37/85/376bf6f25970caf6250e9a4cd768de85.jpg?wh=1142*674\" alt=\"\"></p><p>通过数据库分片，我们可以提高数据库服务的性能和可伸缩性。当数据量和访问量增加时，增加数据库节点的数量就行了。不过，虽然数据库的分片带来了性能和伸缩性的好处，但它也带来了一些挑战。</p><p><strong>最明显的一个挑战，是数据库分片逻辑侵入到业务逻辑中。</strong>过去，应用逻辑只访问一个数据库，现在需要根据分片的规则，判断要去访问哪个数据库，再去跟这个数据库服务器连接。如果增加数据库分片，或者对分片策略进行调整，访问数据库的所有应用模块都要修改。这会让软件的维护变得更复杂，显然也不太符合软件工程中模块低耦合、把变化隔离的理念。</p><p>所以如果有一种技术，能让我们访问很多数据库分片时，像访问一个数据库那样就好了。<strong>数据库的物理分布，对应用是透明的。</strong></p><p>可是，“理想很吸引人，现实很骨感”。要实现这个技术，需要解决很多问题：</p><p><strong>首先是跨库查询的难题。</strong>如果SQL操作都针对一个库还好，但如果某个业务需求恰好要跨多个库，比如上面的例子中，如果要查询多个小区的住户信息，那么就要在多个库中都执行查询，然后把查询结果合并，一般还要排序。</p><p>如果我们前端显示的时候需要分页，每页显示一百行，那就更麻烦了。我们不可能从10个分库中各查出10行，合并成100行，这100行不一定排在前面，最差的情况，可能这100行恰好都在其中一个分库里。所以，你可能要从每个分库查出100行来，合并、排序后，再取出前100行。如果涉及数据库表跨库做连接，你想象一下，那就更麻烦了。</p><p><strong>其次就是跨库做写入的难题。</strong>如果对数据库写入时遇到了跨库的情况，那么就必须实现分布式事务。所以，虽然分布式数据库的愿景很吸引人，但我们必须解决一系列技术问题。</p><p>这一讲，我们先解决最简单的问题，<strong>也就是当每次数据操作仅针对一个分库的时候，能否自动确定是哪个分库的问题。</strong>解决这个问题我们不需要依据别的信息，只需要提供SQL就行了。这就涉及对SQL语句的解析了，自然要用到编译技术。</p><h2>解析SQL语句，判断访问哪个数据库</h2><p>我画了一张简化版的示意图：假设有两张表，分别是订单表和客户表，它们的主键是order_id和cust_id：</p><p><img src=\"https://static001.geekbang.org/resource/image/9b/e0/9bb05d9ccff18746b275a765567c4de0.jpg?wh=1142*582\" alt=\"\"></p><p>我们采用的分片策略，是依据这两个主键的前4位的编码来确定数据库分片的逻辑，比如：前四位是SDYT，那就使用山东烟台的分片，如果是BJHD，就使用北京海淀的分片，等等。</p><p>在我们的应用中，会对订单表进行一些增删改查的操作，比如会执行下面的SQL语句：</p><pre><code>//查询\nselect * from orders where order_id = 'SDYT20190805XXXX'\nselect * from orders where cust_id = 'SDYT987645'\n\n\n//插入\ninsert into orders (order_id，...其他字段) values( &quot;BJHD20190805XXXX&quot;,...)\n\n//修改\nupdate orders set price=298.00 where order_id='FJXM20190805XXXX'\n\n//删除\ndelete from orders where order_id='SZLG20190805XXXX'\n</code></pre><p>我们要能够解析这样的SQL语句，根据主键字段的值，决定去访问哪个分库或者分表。这就需要用到编译器前端技术，包括<strong>词法分析、语法分析和语义分析。</strong></p><p>听到这儿，你可能会质疑：“解析SQL语句？是在开玩笑吗？”你可能觉得这个任务太棘手，犹豫着是否要忍受业务逻辑和技术逻辑混杂的缺陷，把判断分片的逻辑写到应用代码里，或者想解决这个问题，又或者想自己写一个开源项目，帮到更多的人。</p><p>无论你的内心活动如何，应用编译技术，能让你有更强的信心解决这个问题。那么如何去做呢？要想完成解析SQL的任务，在词法分析和语法分析这两个阶段，我建议你采用工具快速落地，比如Antlr。你要找一个现成的SQL语句的语法规则文件。</p><p>GitHub中，那个收集了很多示例Antlr规则文件的<a href=\"https://github.com/antlr/grammars-v4\">项目</a>里，<a href=\"https://github.com/antlr/grammars-v4\">有两个可以参考的规则</a>：一个是<a href=\"https://github.com/antlr/grammars-v4/tree/master/plsql\">PLSQL</a>的（它是Oracle数据库的SQL语法）；一个是<a href=\"https://github.com/antlr/grammars-v4/tree/master/sqlite\">SQLite</a>的（这是一个嵌入式数据库）。</p><p>实际上，我还找到MySQL workbench所使用的一个产品级的<a href=\"https://github.com/mysql/mysql-workbench/tree/8.0/library/parsers/grammars\">规则文件</a>。MySQL workbench是一个图形化工具，用于管理和访问MySQL。这个规则文件还是很靠谱的，不过它里面嵌了很多属性计算规则，而且是C++语言写的，我嫌处理起来麻烦，就先弃之不用，<strong>暂且采用SQLite的规则文件来做示范。</strong></p><p>先来看一下这个文件里的一些规则，例如select语句相关的语法：</p><pre><code>factored_select_stmt\n : ( K_WITH K_RECURSIVE? common_table_expression ( ',' common_table_expression )* )?\n   select_core ( compound_operator select_core )*\n   ( K_ORDER K_BY ordering_term ( ',' ordering_term )* )?\n   ( K_LIMIT expr ( ( K_OFFSET | ',' ) expr )? )?\n ;\n\ncommon_table_expression\n : table_name ( '(' column_name ( ',' column_name )* ')' )? K_AS '(' select_stmt ')'\n ;\n\nselect_core\n : K_SELECT ( K_DISTINCT | K_ALL )? result_column ( ',' result_column )*\n   ( K_FROM ( table_or_subquery ( ',' table_or_subquery )* | join_clause ) )?\n   ( K_WHERE expr )?\n   ( K_GROUP K_BY expr ( ',' expr )* ( K_HAVING expr )? )?\n | K_VALUES '(' expr ( ',' expr )* ')' ( ',' '(' expr ( ',' expr )* ')' )*\n ;\n\nresult_column\n : '*'\n | table_name '.' '*'\n | expr ( K_AS? column_alias )?\n ;\n</code></pre><p>我们可以一边看这个语法规则，一边想几个select语句做一做验证。你可以思考一下，这个规则是怎么把select语句拆成不同的部分的。</p><p>SQL里面也有表达式，我们研究一下它的表达式的规则：</p><pre><code>expr\n : literal_value\n | BIND_PARAMETER\n | ( ( database_name '.' )? table_name '.' )? column_name\n | unary_operator expr\n | expr '||' expr\n | expr ( '*' | '/' | '%' ) expr\n | expr ( '+' | '-' ) expr\n | expr ( '&lt;&lt;' | '&gt;&gt;' | '&amp;' | '|' ) expr\n | expr ( '&lt;' | '&lt;=' | '&gt;' | '&gt;=' ) expr\n | expr ( '=' | '==' | '!=' | '&lt;&gt;' | K_IS | K_IS K_NOT | K_IN | K_LIKE | K_GLOB | K_MATCH | K_REGEXP ) expr\n | expr K_AND expr\n | expr K_OR expr\n | function_name '(' ( K_DISTINCT? expr ( ',' expr )* | '*' )? ')'\n | '(' expr ')'\n | K_CAST '(' expr K_AS type_name ')'\n | expr K_COLLATE collation_name\n | expr K_NOT? ( K_LIKE | K_GLOB | K_REGEXP | K_MATCH ) expr ( K_ESCAPE expr )?\n | expr ( K_ISNULL | K_NOTNULL | K_NOT K_NULL )\n | expr K_IS K_NOT? expr\n | expr K_NOT? K_BETWEEN expr K_AND expr\n | expr K_NOT? K_IN ( '(' ( select_stmt\n                          | expr ( ',' expr )*\n                          )? \n                      ')'\n                    | ( database_name '.' )? table_name )\n | ( ( K_NOT )? K_EXISTS )? '(' select_stmt ')'\n | K_CASE expr? ( K_WHEN expr K_THEN expr )+ ( K_ELSE expr )? K_END\n | raise_function\n ;\n</code></pre><p>你可能会觉得SQL的表达式的规则跟其他语言的表达式规则很像。比如都支持加减乘除、关系比较、逻辑运算等等。而且从这个规则文件里，你一下子就能看出各种运算的优先级，比如你会注意到，字符串连接操作“||”比乘法和除法的优先级更高。<strong>所以，研究一门语言时积累的经验，在研究下一门语言时仍然有用。</strong></p><p>有了规则文件之后，接下来，我们用Antlr生成词法分析器和语法分析器：</p><pre><code>antlr -visitor -package dsql.parser SQLite.g4\n</code></pre><p>在这个命令里，我用-package参数指定了生成的Java代码的包是dsql.parser。dsql是分布式SQL的意思。接着，我们可以写一点儿程序测试一下所生成的词法分析器和语法分析器：</p><pre><code>String sql = &quot;select order_id from orders where cust_id = 'SDYT987645'&quot;;\n\n//词法分析\nSQLiteLexer lexer = new SQLiteLexer(CharStreams.fromString(sql));\nCommonTokenStream tokens = new CommonTokenStream(lexer);\n\n//语法分析\nSQLiteParser parser = new SQLiteParser(tokens);\nParseTree tree = parser.sql_stmt();\n\n//输出lisp格式的AST\nSystem.out.println(tree.toStringTree(parser));\n</code></pre><p>这段程序的输出是LISP格式的AST，我调整了一下缩进，让它显得更像一棵树：</p><pre><code>(sql_stmt \n  (factored_select_stmt \n    (select_core select \n      (result_column \n        (expr \n          (column_name \n            (any_name order_id)))) \n      from (table_or_subquery \n              (table_name \n                (any_name orders)))\n      where (expr \n              (expr \n                (column_name \n                  (any_name cust_id))) \n              = \n                (expr \n                  (literal_value \n                    ('SDYT987645'))))))\n</code></pre><p>从AST中，我们可以清晰地看出这个select语句是如何被解析成结构化数据的，再继续写点儿代码，就能获得想要的信息了。</p><p>接下来的任务是：对于访问订单表的select语句，要在where子句里找出cust_id=\"客户编号\"或order_id=\"订单编号\"这样的条件，从而能够根据客户编号或订单编号确定采用哪个分库。</p><p>怎么实现呢？很简单，我们用visitor模式遍历一下AST就可以了：</p><pre><code>public String getDBName(String sql) {\n    //词法解析\n    SQLiteLexer lexer = new SQLiteLexer(CharStreams.fromString(sql));\n    CommonTokenStream tokens = new CommonTokenStream(lexer);\n    \n    //语法解析\n    SQLiteParser parser = new SQLiteParser(tokens);\n    ParseTree tree = parser.sql_stmt();\n\n    //以lisp格式打印AST\n    System.out.println(tree.toStringTree(parser));\n\n    //获得select语句的要素,包括表名和where条件\n    SQLVisitor visitor = new SQLVisitor();\n    SelectStmt select = (SelectStmt) visitor.visit(tree);\n\n    String dbName = null;\n    if (select.tableName.equals(&quot;orders&quot;)) {\n        if (select.whereExprs != null) {\n            for (WhereExpr expr : select.whereExprs) {\n                //根据cust_id或order_id来确定库的名称\n                if (expr.columnName.equals(&quot;cust_id&quot;) || expr.columnName.equals(&quot;order_id&quot;)) {\n                    //取编号的前4位，即区域编码\n                    String region = expr.value.substring(1, 5);\n                    //根据区域编码，获取库名称\n                    dbName = region2DB.get(region);\n                    break;\n                }\n            }\n        }\n    }\n    return dbName;\n}\n</code></pre><p>获取表名和where子句条件的代码在SQLVisitor.java中。因为已经有了AST，抽取这些信息是不难的。你可以点开我在文稿中提供的链接，查看示例代码。</p><h2>我们的示例离实用还有多大差距？</h2><p>目前，我们已经初步解决了数据库访问透明化的问题。当然，这只是一个示例，如果要做得严密、实用，我们还要补充一些工作。</p><p><strong>我们需要做一些语义分析工作，确保SQL语句的合法性。</strong>语法分析并不能保证程序代码完全合法，我们必须进行很多语义的检查才行。</p><p>我给订单表起的名字，是orders。如果你把表名称改为order，那么必须用引号引起来，写成’order’，不带引号的order会被认为是一个关键字。因为在SQL中我们可以使用order by这样的子句，这时候，order这个表名就会被混淆，进而被解析错误。这个语法解析程序会在表名的地方出现一个order节点，这在语义上是不合法的，需要被检查出来并报错。</p><p><strong>如果要检查语义的正确性，我们还必须了解数据库的元数据。</strong>否则，就没有办法判断在\bSQL语句中是否使用了正确的字段，以及正确的数据类型。除此之外，我们还需要扩展到能够识别跨库操作，比如下面这样一个where条件：</p><pre><code>order_id = 'FJXM20190805XXXX' or order_id = 'SZLG20190805XXXX'\n</code></pre><p>分析这个查询条件，可以知道数据是存在两个不同的数据库中的。但是我们要让解析程序分析出这个结果，甚至让它针对更加复杂的条件，也能分析出来。这就需要更加深入的语义分析功能了。</p><p><strong>最后，解析器的速度也是一个需要考虑的因素。</strong>因为执行每个SQL都需要做一次解析，而这个时间就加在了每一次数据库访问上。所以，SQL解析的时间越少越好。因此，有的项目就会尽量提升解析效率。<strong>阿里有一个开源项目Druid，是一个数据库连接池。</strong>这个项目强调性能，因此他们纯手写了一个SQL解析器，尽可能地提升性能。</p><p>总之，要实现一个完善的工具，让工具达到产品级的质量，有不少工作要做。如果要支持更强的分布式数据库功能，还要做更多的工作。不过，你应该不会觉得这事儿有多么难办了吧？至少在编译技术这部分你是有信心的。</p><p>在这里，我还想讲一讲SQL防注入这个问题。SQL注入攻击是一种常见的攻击手段。你向服务器请求一个url的时候，可以把恶意的SQL嵌入到参数里面，这样形成的SQL就是不安全的。</p><p>以前面的SQL语句为例，这个select语句本来只是查询一个订单，订单编号“SDYT20190805XXXX”作为参数传递给服务端的一个接口，服务端收到参数以后，用单引号把这个参数引起来，并加上其他部分，就组装成下面的SQL并执行：</p><pre><code>//原来的SQL\nselect * from orders where order_id = 'SDYT20190805XXXX'\n</code></pre><p>如果我们遇到了一个恶意攻击者，他可能把参数写成“SDYT20190805XXXX’；drop table customers; --”。服务器接到这个参数以后，仍然把它拿单引号引起来，并组装成SQL，组装完毕以后就是下面的语句：</p><pre><code>//被注入恶意SQL后\nselect * from orders where order_id = 'SDYT20190805XXXX'; drop table customers; --'\n</code></pre><p>如果你看不清楚，我分行写一下，这样你就知道它是怎么把你宝贵的客户信息全都删掉的：</p><pre><code>//被注入恶意SQL后\nselect * from orders where order_id = 'SDYT20190805XXXX'; \ndrop table customers;  // 把顾客表给删了\n--'                    //把你加的单引号变成了注释，这样SQL不会出错\n</code></pre><p><strong>所以SQL注入有很大的危害。</strong>而我们一般用检查客户端传过来的参数的方法，看看有没有SQL语句中的关键字，来防止SQL注入。不过这是比较浅的防御，有时还会漏过一些非法参数，所以要在SQL执行之前，做最后一遍检查。而这个时候，就要运用编译器前端技术来做SQL的解析了。借此，我们能检查出来异常：<strong>明明这个功能是做查询的，为什么形成的SQL会有删除表的操作？</strong></p><p>通过这个例子，我们又分析了一种场景：开发一个安全可靠的系统，用编译技术做SQL分析是必须做的一件事情。</p><h2>课程小结</h2><p>今天，我带你利用学到的编译器前端技术，解析了SQL语句，并针对分布式数据库透明查询的功能做了一次概念证明。</p><p>SQL是程序员经常打交道的语言。有时，我们会遇到需要解析SQL语言的需求，除了分布式数据库场景的需求以外，Hibernate对HQL的解析，也跟解析SQL差不多。而且，最近有一种技术，能够通过RESTful这样的接口做通用的查询，其实也是一种类SQL的子语言。</p><p>当然了，今天我们只是基于工具做解析。一方面，有时候我们就是需要做个原型系统或者最小的能用的系统，有时间有资源了，再追求完美也不为过，比如追求编译速度的提升。另一方面，你能看到MySQL workbench也是用Antlr来作帮手的，在很多情况下，Antlr这样的工具生成的解析器足够用，甚至比你手写的还要好，所以，我们大可以节省时间，用工具做解析。</p><p>可能你会觉得，实际应用的难度似乎要低于学习原理的难度。如果你有这个感觉，那就对了，这说明你已经掌握了原理篇的内容，所以日常的一些应用根本不是问题，你可以找出更多的应用场景来练练手。</p><h2>一课一思</h2><p>你在工作中，是否遇到过其他需要解析SQL的场景？另外，当你阅读了SQL的规则文件之后，是否发现了它跟Java这样的语言规则的不同之处？是更加简单还是更复杂？欢迎在留言区写下你的发现。</p><p>最后，感谢你的阅读，如果这篇文章让你有所收获，也欢迎你将它分享给更多的朋友。</p><p></p>","comments":[{"had_liked":false,"id":151186,"user_name":"xiaoma2008","can_delete":false,"product_type":"c1","uid":1307110,"ip_address":"","ucode":"EA59E52B15F5C0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKq0aBhhSXg7qiaWQH81zmjAYPXwoiaJEoMOxwXZF7d2iazMyQCeYpT7DJmxy2Iny7qq3RRr0UjOnO5A/132","comment_is_top":false,"comment_ctime":1573662509,"is_pvip":false,"replies":[{"id":"59602","content":"我最近其实在构思写一个分布式数据访问的工具。跟MyCat的定位会不大相同，是想整体上把数据访问这件事情，对应用透明化。野心有点大。<br>因为现在很多用到数据库的应用，其水平扩展能力都困在了数据库这个点上。这个问题不解决，所谓云原生就是在忽视房间里的大象。<br>我看资料，已经有一些分布式数据库的商业产品。但要像使用一个单一的数据库一样的使用它，还是有点困难。<br>我整理一下这方面的思路，会跟大家分享的。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1574680387,"ip_address":"","comment_id":151186,"utype":1}],"discussion_count":2,"race_medal":0,"score":"57408237357","product_id":100034101,"comment_content":"如果老师对分布式数据库比较熟的话，希望老师能出个分布式查询的课程！","like_count":13,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474394,"discussion_content":"我最近其实在构思写一个分布式数据访问的工具。跟MyCat的定位会不大相同，是想整体上把数据访问这件事情，对应用透明化。野心有点大。\n因为现在很多用到数据库的应用，其水平扩展能力都困在了数据库这个点上。这个问题不解决，所谓云原生就是在忽视房间里的大象。\n我看资料，已经有一些分布式数据库的商业产品。但要像使用一个单一的数据库一样的使用它，还是有点困难。\n我整理一下这方面的思路，会跟大家分享的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574680387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1162242,"avatar":"https://static001.geekbang.org/account/avatar/00/11/bc/02/3f7a7197.jpg","nickname":"跨江大桥","note":"","ucode":"4629B23F1BB9F0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544659,"discussion_content":"两年过去了，不知道作者这个产品落地了吗","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1641621501,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137897,"user_name":"David","can_delete":false,"product_type":"c1","uid":1586094,"ip_address":"","ucode":"2AF5A315AB03C9","user_header":"https://static001.geekbang.org/account/avatar/00/18/33/ae/436e3a56.jpg","comment_is_top":false,"comment_ctime":1569909952,"is_pvip":false,"replies":[{"id":"53877","content":"每个领域都会有这样的场景。<br>无论是上层的应用软件（如工资表软件），还是下层的基础软件（如数据库软件）。只要想让软件的功能有一定灵活性的、通用性的，都需要编译技术。<br>曾经在Lisp圈里（参见《黑客与画家》），有人说，每个软件做到极致的时候，里面都会包含一个拙劣的Lisp实现。他的意思是，每个软件做到极致，都要有灵活定制的能力，也就是需要编译技术的支持。<br>具体来说，每个领域不一样，所以举例子也只能举自己熟悉领域的例子。<br>我熟悉的领域：<br>1.企业软件：比如ERP软件等。定制能力是否强大，就是优秀的企业软件和平庸的企业软件的区别。现在的企业软件在实施的时候，成本往往很高，就是这方面比较差。我目前手头在做的一门语言，就是在解决这个领域的问题。<br>2.中间件&#47;基础软件：这里肯定需要。例子太多了。<br>3.GIS，也算一种基础软件吧，也有编程能力。<br>其他同学，有的熟悉游戏领域，有的在AI领域，各自都有不同的场景。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1570703701,"ip_address":"","comment_id":137897,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27339713728","product_id":100034101,"comment_content":"关于编译技术还有什么经典的应用场景吗？老师帮我们拓展一下想象力。","like_count":6,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469298,"discussion_content":"每个领域都会有这样的场景。\n无论是上层的应用软件（如工资表软件），还是下层的基础软件（如数据库软件）。只要想让软件的功能有一定灵活性的、通用性的，都需要编译技术。\n曾经在Lisp圈里（参见《黑客与画家》），有人说，每个软件做到极致的时候，里面都会包含一个拙劣的Lisp实现。他的意思是，每个软件做到极致，都要有灵活定制的能力，也就是需要编译技术的支持。\n具体来说，每个领域不一样，所以举例子也只能举自己熟悉领域的例子。\n我熟悉的领域：\n1.企业软件：比如ERP软件等。定制能力是否强大，就是优秀的企业软件和平庸的企业软件的区别。现在的企业软件在实施的时候，成本往往很高，就是这方面比较差。我目前手头在做的一门语言，就是在解决这个领域的问题。\n2.中间件/基础软件：这里肯定需要。例子太多了。\n3.GIS，也算一种基础软件吧，也有编程能力。\n其他同学，有的熟悉游戏领域，有的在AI领域，各自都有不同的场景。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570703701,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207559,"user_name":"sugar","can_delete":false,"product_type":"c1","uid":1167046,"ip_address":"","ucode":"454538FF253B5F","user_header":"https://static001.geekbang.org/account/avatar/00/11/ce/c6/958212b5.jpg","comment_is_top":false,"comment_ctime":1587107879,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23061944359","product_id":100034101,"comment_content":"我来说说工作中sql解析的场景吧：一般后端同学都有自己雪藏的一大坨复杂的sql祖传代码，作为写新sql参考也好、拿来给带的实习生做演示也好，读起来肯定是带换行带缩进才比较舒服；而到了执行的时候，linux各种终端 ssh隧道之间复制粘贴，肯定最希望的还是去掉一切非必要的空格、换行符以及缩进制表符这样的1-line-sql，这个诉求我个人是长期存在的，目前为止在大多数ide里我没发现100%解决这个需求场景的sql formatter，况且绝大多数ide中sql格式化的插件都有各种小毛病，用起来让人不爽，自己写一个 想怎么hack怎么hack。这算是个不错的自己写sql parser的场景吧～","like_count":5},{"had_liked":false,"id":133837,"user_name":"janey","can_delete":false,"product_type":"c1","uid":1619748,"ip_address":"","ucode":"B2160B363F23EB","user_header":"https://static001.geekbang.org/account/avatar/00/18/b7/24/17f6c240.jpg","comment_is_top":false,"comment_ctime":1568681911,"is_pvip":false,"replies":[{"id":"51361","content":"你说的多表，是指同一个表在不同服务器上的分片吗？<br>如果一个SQL是涉及多个分片的，解析了SQL以后，是可以针对每个分片重新生成SQL的。但这个需要对语义更深的理解，要把SQL语句变成关系代数的运算（选择、投影、笛卡尔积、Union等），这样就知道如何正确的重组成多个SQL了。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1568692105,"ip_address":"","comment_id":133837,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14453583799","product_id":100034101,"comment_content":"在编译器层面实现分布式数据查询，可以理解为把多表查询提前了吗？只是看起来就一个select语句","like_count":3,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467524,"discussion_content":"你说的多表，是指同一个表在不同服务器上的分片吗？\n如果一个SQL是涉及多个分片的，解析了SQL以后，是可以针对每个分片重新生成SQL的。但这个需要对语义更深的理解，要把SQL语句变成关系代数的运算（选择、投影、笛卡尔积、Union等），这样就知道如何正确的重组成多个SQL了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568692105,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":272279,"user_name":"coconut","can_delete":false,"product_type":"c1","uid":2344081,"ip_address":"","ucode":"07B95C7A6AC2F7","user_header":"https://static001.geekbang.org/account/avatar/00/23/c4/91/a017bf72.jpg","comment_is_top":false,"comment_ctime":1610014224,"is_pvip":true,"replies":[{"id":"98898","content":"你能动手测量实际的性能，非常好！在有些应用场景中，SQL解析的性能确实很重要，因为它会叠加到每次服务请求的时间上，影响到系统响应的速度。<br><br>在《编译原理实战课》中，专门有讲MySQL的编译器的内容。你可以参考MySQL编译器的实现方法，简单概括一下它的特点：<br>1.词法分析器是手写的，这样会提供一定的灵活性。<br>2.语法分析器是用bison(yacc)实现的，你可以参考它的语法定义文件，看看跟自己做的定义文件的区别。mysql的例子证明，哪怕是生产级的产品，用工具来做语法分析仍然是可行的。<br><br>另外，在分析V8等编译器的时候，也提到了一些解析速度优化的方法，因为javascript需要解析后才能执行，解析速度慢就影响页面体验，所以采用了词法解析查字典等技术，把性能压榨到极致。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1610332603,"ip_address":"","comment_id":272279,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10199948816","product_id":100034101,"comment_content":"老师，想要满足 高性能地解析SQL到语法树 这个需求，我尝试用antlr和yacc golang写了demo测试，antlr差不多性能降了300+倍，goyacc下降了10倍左右。<br><br>如果还想提高性能，还有什么方式么？我想到的<br>1.调研sql parser，如druid<br>2.尝试其他语言 （估计不会有啥提升）<br>","like_count":2,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513224,"discussion_content":"你能动手测量实际的性能，非常好！在有些应用场景中，SQL解析的性能确实很重要，因为它会叠加到每次服务请求的时间上，影响到系统响应的速度。\n\n在《编译原理实战课》中，专门有讲MySQL的编译器的内容。你可以参考MySQL编译器的实现方法，简单概括一下它的特点：\n1.词法分析器是手写的，这样会提供一定的灵活性。\n2.语法分析器是用bison(yacc)实现的，你可以参考它的语法定义文件，看看跟自己做的定义文件的区别。mysql的例子证明，哪怕是生产级的产品，用工具来做语法分析仍然是可行的。\n\n另外，在分析V8等编译器的时候，也提到了一些解析速度优化的方法，因为javascript需要解析后才能执行，解析速度慢就影响页面体验，所以采用了词法解析查字典等技术，把性能压榨到极致。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610332603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135393,"user_name":"Richie","can_delete":false,"product_type":"c1","uid":1503120,"ip_address":"","ucode":"3590756BC7DDD9","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/90/53c6bfde.jpg","comment_is_top":false,"comment_ctime":1569144809,"is_pvip":false,"replies":[{"id":"52076","content":"SQL的部分展开确实挺多的。<br>要不然跟极客时间合作一本书，收集大家的需求，把一些细节更多的展开？<br>或者后面做课程升级的时候，考虑扩展一下这部分。<br>","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1569296005,"ip_address":"","comment_id":135393,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10159079401","product_id":100034101,"comment_content":"老师能不能多讲点，关于SQL解析的内容，更深，更细","like_count":2,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468171,"discussion_content":"SQL的部分展开确实挺多的。\n要不然跟极客时间合作一本书，收集大家的需求，把一些细节更多的展开？\n或者后面做课程升级的时候，考虑扩展一下这部分。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569296005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235469,"user_name":"书忆江南","can_delete":false,"product_type":"c1","uid":1339820,"ip_address":"","ucode":"90776A7CE06D66","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/ac/8295e3e7.jpg","comment_is_top":false,"comment_ctime":1595049590,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5890016886","product_id":100034101,"comment_content":"SparkSQL也是用Antlr4来进行SQL语法的解析的","like_count":1},{"had_liked":false,"id":196177,"user_name":"reverse","can_delete":false,"product_type":"c1","uid":1240138,"ip_address":"","ucode":"0B546E540DF096","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/4a/40a2ba79.jpg","comment_is_top":false,"comment_ctime":1585242934,"is_pvip":false,"replies":[{"id":"74390","content":"感谢分享！","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1585266246,"ip_address":"","comment_id":196177,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5880210230","product_id":100034101,"comment_content":"注意；SQLite 的地址是 ：https:&#47;&#47;github.com&#47;antlr&#47;grammars-v4&#47;blob&#47;master&#47;sql&#47;sqlite&#47;SQLite.g4","like_count":1,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489240,"discussion_content":"感谢分享！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585266246,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":352298,"user_name":"dll","can_delete":false,"product_type":"c1","uid":1264401,"ip_address":"","ucode":"5773CBC8BFB91F","user_header":"https://static001.geekbang.org/account/avatar/00/13/4b/11/d7e08b5b.jpg","comment_is_top":false,"comment_ctime":1658515129,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1658515129","product_id":100034101,"comment_content":"对于防sql注入安全检查的具体code老师有没有资料能告知一下，谢谢","like_count":0},{"had_liked":false,"id":352297,"user_name":"dll","can_delete":false,"product_type":"c1","uid":1264401,"ip_address":"","ucode":"5773CBC8BFB91F","user_header":"https://static001.geekbang.org/account/avatar/00/13/4b/11/d7e08b5b.jpg","comment_is_top":false,"comment_ctime":1658515070,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1658515070","product_id":100034101,"comment_content":"老师这节课的内容是掌握了本章节讲到的生成代码解析sql，增加防注入功能，模拟一个根据主键前四个字母定位数据库位置，调用对应数据的sql查询就可以吗","like_count":0},{"had_liked":false,"id":316332,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1634273353,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1634273353","product_id":100034101,"comment_content":"规则文件，看起来感觉陌生，不知道啥意思，只知道是一条条规则","like_count":0},{"had_liked":false,"id":285208,"user_name":"Nick","can_delete":false,"product_type":"c1","uid":1477439,"ip_address":"","ucode":"E034AC5534AF62","user_header":"https://static001.geekbang.org/account/avatar/00/16/8b/3f/094cf966.jpg","comment_is_top":false,"comment_ctime":1616666402,"is_pvip":true,"replies":[{"id":"105383","content":"奥？我还挖过这样一个坑呀:-(  <br>好吧，我确实关心这个方向，那我一定整理出一篇加餐来！<br>总体来说，数据库这个瓶颈，还有围绕数据库的计算模式，有点让人失望。我希望能见到革命性的创新出现，而不是现在的修修补补。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1619790200,"ip_address":"","comment_id":285208,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1616666402","product_id":100034101,"comment_content":"“作者回复: 我最近其实在构思写一个分布式数据访问的工具。跟MyCat的定位会不大相同，是想整体上把数据访问这件事情，对应用透明化。野心有点大。<br>因为现在很多用到数据库的应用，其水平扩展能力都困在了数据库这个点上。这个问题不解决，所谓云原生就是在忽视房间里的大象。<br>我看资料，已经有一些分布式数据库的商业产品。但要像使用一个单一的数据库一样的使用它，还是有点困难。<br>我整理一下这方面的思路，会跟大家分享的”<br>宫老师，我们很想听 您 关于 分布式数据访问工具  的分享。","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517614,"discussion_content":"奥？我还挖过这样一个坑呀:-(  \n好吧，我确实关心这个方向，那我一定整理出一篇加餐来！\n总体来说，数据库这个瓶颈，还有围绕数据库的计算模式，有点让人失望。我希望能见到革命性的创新出现，而不是现在的修修补补。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619790200,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":260292,"user_name":"超越杨超越","can_delete":false,"product_type":"c1","uid":1028887,"ip_address":"","ucode":"BB390B4B7E19D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b3/17/9f6d67dc.jpg","comment_is_top":false,"comment_ctime":1604977672,"is_pvip":false,"replies":[{"id":"94525","content":"我再帮你理一下思路：<br>首先，你要理解本节课所提到的场景。在构建大型的系统的时候，经常需要把数据分片，也就是把逻辑上是同一个表的数据，物理上存放到不同的数据库服务器上。但是在编程的时候呢，又不想关心底层数据物理存储的细节，从而让业务逻辑与数据存储策略解耦。于是，就有一些中间件来完成这个任务。它们要能够读懂SQL语句，并把不同的SQL语句导向到不同的数据库服务器。<br><br>那怎么读懂SQL语句呢？这就需要编译技术的帮助了。首先，通过语法分析，把一个SQL语句变成结构化的AST，这样你就知道select子句、from子句、where子句等分别是什么，等等。接着，你再根据DSL中定义的规则，判断出该SQL应该发往哪个数据库服务器。<br><br>你说的正则匹配，也是可以的，不过正则文法的描述能力差一些。对于比较复杂的语句，正则文法是无能为力的。即使是用正则文法的方式，其实也一样是经历了一个解析过程，也就是编译过程。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1604999193,"ip_address":"","comment_id":260292,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1604977672","product_id":100034101,"comment_content":"对老师讲的这部分还是没有太理解。<br>采用编译技术对SQL进行解析之后呢，结果是什么呢？遇到合法的SQL就执行，非法的SQL语句就直接报错么？<br>请问采用类似于正则匹配之类的方式，可以做到么？","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509159,"discussion_content":"我再帮你理一下思路：\n首先，你要理解本节课所提到的场景。在构建大型的系统的时候，经常需要把数据分片，也就是把逻辑上是同一个表的数据，物理上存放到不同的数据库服务器上。但是在编程的时候呢，又不想关心底层数据物理存储的细节，从而让业务逻辑与数据存储策略解耦。于是，就有一些中间件来完成这个任务。它们要能够读懂SQL语句，并把不同的SQL语句导向到不同的数据库服务器。\n\n那怎么读懂SQL语句呢？这就需要编译技术的帮助了。首先，通过语法分析，把一个SQL语句变成结构化的AST，这样你就知道select子句、from子句、where子句等分别是什么，等等。接着，你再根据DSL中定义的规则，判断出该SQL应该发往哪个数据库服务器。\n\n你说的正则匹配，也是可以的，不过正则文法的描述能力差一些。对于比较复杂的语句，正则文法是无能为力的。即使是用正则文法的方式，其实也一样是经历了一个解析过程，也就是编译过程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604999193,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173936,"user_name":"冯选刚","can_delete":false,"product_type":"c1","uid":1018444,"ip_address":"","ucode":"A186F31A730F04","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/4c/d976b42c.jpg","comment_is_top":false,"comment_ctime":1579791820,"is_pvip":false,"replies":[{"id":"74217","content":"Great！<br>希望应用篇能够帮大家把编译原理跟实际应用更好地结合起来！","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1585147465,"ip_address":"","comment_id":173936,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1579791820","product_id":100034101,"comment_content":"学到了。","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482246,"discussion_content":"Great！\n希望应用篇能够帮大家把编译原理跟实际应用更好地结合起来！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585147465,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148104,"user_name":"zhj","can_delete":false,"product_type":"c1","uid":1311772,"ip_address":"","ucode":"65B9E222D6E075","user_header":"https://static001.geekbang.org/account/avatar/00/14/04/1c/b0c6c009.jpg","comment_is_top":false,"comment_ctime":1572941573,"is_pvip":false,"replies":[{"id":"57518","content":"https:&#47;&#47;github.com&#47;RichardGong&#47;PlayWithCompiler&#47;blob&#47;master&#47;lab&#47;db&#47;src&#47;main&#47;playdb&#47;SQLVisitor.java<br><br>我在文稿中加一下链接...","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1573298126,"ip_address":"","comment_id":148104,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572941573","product_id":100034101,"comment_content":"SQLVisitor代码在哪里了","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473397,"discussion_content":"https://github.com/RichardGong/PlayWithCompiler/blob/master/lab/db/src/main/playdb/SQLVisitor.java\n\n我在文稿中加一下链接...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573298126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138247,"user_name":"52rock","can_delete":false,"product_type":"c1","uid":1025632,"ip_address":"","ucode":"3C4376A8EAAEF6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a6/60/0eac2751.jpg","comment_is_top":false,"comment_ctime":1570114047,"is_pvip":true,"replies":[{"id":"53819","content":"嗯。这种delete语句肯定比较危险。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1570677383,"ip_address":"","comment_id":138247,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1570114047","product_id":100034101,"comment_content":"查找delete没有where的SQL","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469453,"discussion_content":"嗯。这种delete语句肯定比较危险。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570677383,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}