{"id":129333,"title":"17 | 如何正确使用锁保护共享数据，协调异步线程？","content":"<p>你好，我是李玥。</p><p>在前几天的加餐文章中我讲到，JMQ为了提升整个流程的处理性能，使用了一个“近乎无锁”的设计，这里面其实隐含着两个信息点。第一个是，在消息队列中，“锁”是一个必须要使用的技术。第二个是，使用锁其实会降低系统的性能。</p><p>那么，如何正确使用锁，又需要注意哪些事项呢？今天我们就来聊一聊这个问题。</p><p>我们知道，使用异步和并发的设计可以大幅提升程序的性能，但我们为此付出的代价是，程序比原来更加复杂了，多线程在并行执行的时候，带来了很多不确定性。特别是对于一些需要多个线程并发读写的共享数据，如果处理不好，很可能会产出不可预期的结果，这肯定不是我们想要的。</p><p>我给你举个例子来说明一下，大家应该都参与过微信群投票吧？比如，群主说：“今晚儿咱们聚餐，能来的都回消息报一下名，顺便统计一下人数。都按我这个格式来报名。”然后，群主发了一条消息：“群主，1人”。</p><p>这时候小六和无双都要报名，过一会儿，他俩几乎同时各发了一条消息，“小六，2人”“无双，2人”，每个人发的消息都只统计了群主和他们自己，一共2人，而这时候，其实已经有3个人报名了，并且，在最后发消息的无双的名单中，小六的报名被覆盖了。</p><p><img src=\"https://static001.geekbang.org/resource/image/87/e7/87ac82860fe52434dee843c8e710b2e7.jpg?wh=3383*1690\" alt=\"\"></p><p>这就是一个非常典型的由于并发读写导致的数据错误。使用锁可以非常有效地解决这个问题。锁的原理是这样的：<strong>任何时间都只能有一个线程持有锁，只有持有锁的线程才能访问被锁保护的资源。</strong></p><!-- [[[read_end]]] --><p>在上面微信群报名的例子中，如果说我们的微信群中有一把锁，想要报名的人必须先拿到锁，然后才能更新报名名单。这样，就避免了多个人同时更新消息，报名名单也就不会出错了。</p><h2>避免滥用锁</h2><p>那是不是遇到这种情况都要用锁解决呢？我分享一下我个人使用锁的第一条原则：<strong>如果能不用锁，就不用锁；如果你不确定是不是应该用锁，那也不要用锁。</strong>为什么这么说呢？因为，虽然说使用锁可以保护共享资源，但是代价还是不小的。</p><p>第一，加锁和解锁过程都是需要CPU时间的，这是一个性能的损失。另外，使用锁就有可能导致线程等待锁，等待锁过程中线程是阻塞的状态，过多的锁等待会显著降低程序的性能。</p><p>第二，如果对锁使用不当，很容易造成死锁，导致整个程序“卡死”，这是非常严重的问题。本来多线程的程序就非常难于调试，如果再加上锁，出现并发问题或者死锁问题，你的程序将更加难调试。</p><p>所以，你在使用锁以前，一定要非常清楚明确地知道，这个问题必须要用一把锁来解决。切忌看到一个共享数据，也搞不清它在并发环境中会不会出现争用问题，就“为了保险，给它加个锁吧。”<strong>千万不能有这种不负责任的想法，否则你将会付出惨痛的代价！</strong>我曾经遇到过的严重线上事故，其中有几次就是由于不当地使用锁导致的。</p><p><strong>只有在并发环境中，共享资源不支持并发访问，或者说并发访问共享资源会导致系统错误的情况下，才需要使用锁。</strong></p><h2>锁的用法</h2><p>锁的用法一般是这样的：</p><ol>\n<li>在访问共享资源之前，先获取锁。</li>\n<li>如果获取锁成功，就可以访问共享资源了。</li>\n<li>最后，需要释放锁，以便其他线程继续访问共享资源。</li>\n</ol><p>在Java语言中，使用锁的例子：</p><pre><code>private Lock lock = new ReentrantLock();\n\npublic void visitShareResWithLock() {\n  lock.lock();\n  try {\n    // 在这里安全的访问共享资源\n  } finally {\n    lock.unlock();\n  }\n}\n</code></pre><p>也可以使用synchronized关键字，它的效果和锁是一样的：</p><pre><code>private Object lock = new Object();\n\npublic void visitShareResWithLock() {\n  synchronized (lock) {\n    // 在这里安全的访问共享资源\n  }\n}\n</code></pre><p>使用锁的时候，你需要注意几个问题：</p><p>第一个，也是最重要的问题就是，<strong>使用完锁，一定要释放它</strong>。比较容易出现状况的地方是，很多语言都有异常机制，当抛出异常的时候，不再执行后面的代码。如果在访问共享资源时抛出异常，那后面释放锁的代码就不会被执行，这样，锁就一直无法释放，形成死锁。所以，你要考虑到代码可能走到的所有正常和异常的分支，确保所有情况下，锁都能被释放。</p><p>有些语言提供了try-with的机制，不需要显式地获取和释放锁，可以简化编程，有效避免这种问题，推荐你使用。</p><p>比如在Python中：</p><pre><code>lock = threading.RLock()\n\ndef visitShareResWithLock():\n  with lock:\n    # 注意缩进\n    # 在这里安全的访问共享资源\n  \n  # 锁会在with代码段执行完成后自动释放\n</code></pre><p>接下来我们说一下，使用锁的时候，遇到的最常见的问题：死锁。</p><h2>如何避免死锁？</h2><p>死锁是指，由于某种原因，锁一直没有释放，后续需要获取锁的线程都将处于等待锁的状态，这样程序就卡死了。</p><p>导致死锁的原因并不多，第一种原因就是我在刚刚讲的，获取了锁之后没有释放，有经验的程序员很少会犯这种错误，即使出现这种错误，也很容易通过查看代码找到Bug。</p><p>还有一种是锁的重入问题，我们来看下面这段代码：</p><pre><code>public void visitShareResWithLock() {\n  lock.lock(); // 获取锁\n  try {\n    lock.lock(); // 再次获取锁，会导致死锁吗？\n  } finally {\n    lock.unlock();\n  }\n</code></pre><p>在这段代码中，当前的线程获取到了锁lock，然后在持有这把锁的情况下，再次去尝试获取这把锁，这样会导致死锁吗？</p><p>答案是，不一定。<strong>会不会死锁取决于，你获取的这把锁它是不是可重入锁。</strong>如果是可重入锁，那就没有问题，否则就会死锁。</p><p>大部分编程语言都提供了可重入锁，如果没有特别的要求，你要尽量使用可重入锁。有的同学可能会问，“既然已经获取到锁了，我干嘛还要再次获取同一把锁呢？”</p><p>其实，如果你的程序足够复杂，调用栈很深，很多情况下，当你需要获取一把锁的时候，你是不太好判断在n层调用之外的某个地方，是不是已经获取过这把锁了，这个时候，获取可重入锁就有意义了。</p><p>最后一种死锁的情况是最复杂的，也是最难解决的。如果你的程序中存在多把锁，就有可能出现这些锁互相锁住的情况。我们一起来看下面这段Python代码：</p><pre><code>import threading\n\ndef func1(lockA, lockB):\n  while True:\n    print(&quot;Thread1: Try to accquire lockA...&quot;)\n    with lockA:\n      print(&quot;Thread1: lockA accquired. Try to accquire lockB...&quot;)\n      with lockB:\n        print(&quot;Thread1: Both lockA and LockB accrquired.&quot;)\n\n\ndef func2(lockA, lockB):\n  while True:\n    print(&quot;Thread2: Try to accquire lockB...&quot;)\n    with lockB:\n      print(&quot;Thread2: lockB accquired. Try to accquire lockA...&quot;)\n      with lockA:\n        print(&quot;Thread2: Both lockA and LockB accrquired.&quot;)\n\n\nif __name__ == '__main__':\n  lockA = threading.RLock();\n  lockB = threading.RLock()\n  t1 = threading.Thread(target=func1, args=(lockA, lockB,))\n  t2 = threading.Thread(target=func2, args=(lockA, lockB,))\n  t1.start()\n  t2.start()\n</code></pre><p>这个代码模拟了一个最简单最典型的死锁情况。在这个程序里面，我们有两把锁：lockA和lockB，然后我们定义了两个线程，这两个线程反复地去获取这两把锁，然后释放。我们执行以下这段代码，看看会出现什么情况：</p><pre><code>$ python3 DeadLock.py\nThread1: Try to accquire lockA...\nThread1: lockA accquired. Try to accquire lockB...\nThread1: Both lockA and LockB accrquired.\nThread1: Try to accquire lockA...\n... ...\nThread1: Try to accquire lockA...\nThread2: Try to accquire lockB...\nThread1: lockA accquired. Try to accquire lockB...\nThread2: lockB accquired. Try to accquire lockA...\n</code></pre><p>可以看到，程序执行一会儿就卡住了，发生了死锁。那死锁的原因是什么呢？请注意看代码，这两个线程，他们获取锁的顺序是不一样的。第一个线程，先获取lockA，再获取lockB，而第二个线程正好相反，先获取lockB，再获取lockA。</p><p>然后，你再看一下死锁前的最后两行日志，线程1持有了lockA，现在尝试获取lockB，而线程2持有了lockB，尝试获取lockA。你可以想一下这个场景，两个线程，各持有一把锁，都等着对方手里的另外一把锁，这样就僵持住了。</p><p>这是最简单的两把锁两个线程死锁的情况，我们还可以分析清楚，你想想如果你的程序中有十几把锁，几十处加锁解锁，几百的线程，如果出现死锁你还能分析清楚是什么情况吗？</p><p>关于避免死锁，我在这里给你几点建议。</p><ol>\n<li>再次强调一下，避免滥用锁，程序里用的锁少，写出死锁Bug的几率自然就低。</li>\n<li>对于同一把锁，加锁和解锁必须要放在同一个方法中，这样一次加锁对应一次解锁，代码清晰简单，便于分析问题。</li>\n<li>尽量避免在持有一把锁的情况下，去获取另外一把锁，就是要尽量避免同时持有多把锁。</li>\n<li>如果需要持有多把锁，一定要注意加解锁的顺序，解锁的顺序要和加锁顺序相反。比如，获取三把锁的顺序是A、B、C，释放锁的顺序必须是C、B、A。</li>\n<li>给你程序中所有的锁排一个顺序，在所有需要加锁的地方，按照同样的顺序加解锁。比如我刚刚举的那个例子，如果两个线程都按照先获取lockA再获取lockB的顺序加锁，就不会产生死锁。</li>\n</ol><p>最后，你需要知道，即使你完全遵从我这些建议，我也无法完全保证你写出的程序就没有死锁，只能说，会降低一些犯错误的概率。</p><h2>使用读写锁要兼顾性能和安全性</h2><p>对于共享数据来说，如果说某个方法在访问它的时候，只是去读取，并不更新数据，那是不是就不需要加锁呢？还是需要的，因为如果一个线程读数据的同时，另外一个线程同时在更新数据，那么你读到的数据有可能是更新到一半的数据，这肯定是不符合预期的。所以，无论是只读访问，还是读写访问，都是需要加锁的。</p><p>如果给数据简单地加一把锁，虽然解决了安全性的问题，但是牺牲了性能，因为，那无论读还是写，都无法并发了，跟单线程的程序性能是一样。</p><p>实际上，如果没有线程在更新数据，那即使多个线程都在并发读，也是没有问题的。我在上节课跟你讲过，大部分情况下，数据的读写比是不均衡的，读要远远多于写，所以，我们希望的是：</p><ul>\n<li>读访问可以并发执行。</li>\n<li>写的同时不能并发读，也不能并发写。</li>\n</ul><p>这样就兼顾了性能和安全性。读写锁就是为这一需求设计的。我们来看一下Java中提供的读写锁：</p><pre><code>ReadWriteLock rwlock = new ReentrantReadWriteLock();\n\npublic void read() {\n  rwlock.readLock().lock();\n  try {\n    // 在这儿读取共享数据\n  } finally {\n    rwlock.readLock().unlock();\n  }\n}\npublic void write() {\n  rwlock.writeLock().lock();\n  try {\n    // 在这儿更新共享数据\n  } finally {\n    rwlock.writeLock().unlock();\n  }\n}\n</code></pre><p>在这段代码中，需要读数据的时候，我们获取读锁，获取到的读锁不是一个互斥锁，也就是说read()方法是可以多个线程并行执行的，这样使得读数据的性能依然很好。写数据的时候，我们获取写锁，当一个线程持有写锁的时候，其他线程既无法获取读锁，也不能获取写锁，达到保护共享数据的目的。</p><p>这样，使用读写锁就兼顾了性能和安全。</p><h2>小结</h2><p>锁可以保护共享资源，避免并发更新造成的数据错误。只有持有锁的线程才能访问被保护资源。线程在访问资源之前必须获取锁，访问完成后一定要记得释放锁。</p><p>一定不要滥用锁，否则容易导致死锁。死锁的原因，主要由于多个线程中多把锁相互争用导致的。一般来说，如果程序中使用的锁比较多，很难分析死锁的原因，所以需要尽量少的使用锁，并且保持程序的结构尽量简单、清晰。</p><p>最后，我们介绍了读写锁，在某些场景下，使用读写锁可以兼顾性能和安全性，是非常好的选择。</p><h2>思考题</h2><p>我刚刚讲到，Python中提供了try-with-lock，不需要显式地获取和释放锁，非常方便。遗憾的是，在Java中并没有这样的机制，那你能不能自己在Java中实现一个try-with-lock呢？</p><p>欢迎你把代码上传到GitHub上，然后在评论区给出访问链接。如果你有任何问题，也可以在评论区留言与我交流。</p><p>感谢阅读，如果你觉得这篇文章对你有一些启发，也欢迎把它分享给你的朋友。</p><p></p>","neighbors":{"left":{"article_title":"16 | 缓存策略：如何使用缓存来减少磁盘IO？","id":128038},"right":{"article_title":"18 | 如何用硬件同步原语（CAS）替代锁？","id":130743}},"comments":[{"had_liked":false,"id":129932,"user_name":"糖醋🏀","can_delete":false,"product_type":"c1","uid":1118333,"ip_address":"","ucode":"E6FD12D630B439","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/7d/a9b5d5f0.jpg","comment_is_top":false,"comment_ctime":1567329109,"is_pvip":false,"replies":[{"id":48562,"content":"👍👍👍","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567404371,"ip_address":"","comment_id":129932,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"java7开始io就有try-with-resource。\n可以利用这一个特性，来说实现，自动释放。\n代码如下：\n\npublic class AutoUnlockProxy implements Closeable {\n\n    private Lock lock;\n\n    public AutoUnlockProxy(Lock lock) {\n        this.lock = lock;\n    }\n\n    @Override\n    public void close() throws IOException {\n        lock.unlock();\n        System.out.println(&quot;释放锁&quot;);\n    }\n\n    public void lock() {\n        lock.lock();\n    }\n\n    public void tryLock(long time, TimeUnit unit) throws InterruptedException {\n        lock.tryLock(time, unit);\n    }\n\n    public static void main(String[] args) {\n\n        try (AutoUnlockProxy autoUnlockProxy = new AutoUnlockProxy(new ReentrantLock())) {\n            autoUnlockProxy.lock();\n            System.out.println(&quot;加锁了&quot;);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n}","like_count":74},{"had_liked":false,"id":129900,"user_name":"humor","can_delete":false,"product_type":"c1","uid":1181867,"ip_address":"","ucode":"9B48C4C7BEC92C","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/ab/caec7bca.jpg","comment_is_top":false,"comment_ctime":1567321459,"is_pvip":false,"replies":[{"id":48724,"content":"👍👍👍\n","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567491924,"ip_address":"","comment_id":129900,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"&#47;**\n*业务调用接口\n**&#47;\npublic interface Invoker{\n\tvoid invoke();\n}\n\n&#47;**\n*try-with-lock\n**&#47;\npublic class RLock{\n\tprivate Lock lock = new ReentrantLock();\n\n\tpublic void run(Invoker invoker) {\n\t\tlock.lock();\n\t\ttry{\n\t\t\tinvoker.invoke();\n\t\t} finally{\n\t\t\tlock.unlock();\n\t\t}\n\t}\n}\n\npublic BizInvoker implements Inoker{\n\tprivate RLock rLock = new RLock();\n\tpublic void invoke() {\n\t\t&#47;&#47;需要加锁的业务逻辑\n\t}\n\n\tpublic static void main(String[] args) {\n\t\trLock.run(new BizInvoker());\n\t}\n}","like_count":15,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465724,"discussion_content":"👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567404371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1532404,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIvUlicgrWtibbDzwhLw5cQrDSy2JuE1mVvmXq11KQIwpLicgDuWfpp9asE0VCN6HhibPDWn7wBc2lfmA/132","nickname":"a、","note":"","ucode":"590FE8DB111492","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7110,"discussion_content":"你这个方法有点问题，每次new ReentrantlLock，根本锁不住吧，应该把new动作提出来","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1567388274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1365147,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d4/9b/5d69d4d3.jpg","nickname":"binary","note":"","ucode":"084B71B8695727","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1532404,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIvUlicgrWtibbDzwhLw5cQrDSy2JuE1mVvmXq11KQIwpLicgDuWfpp9asE0VCN6HhibPDWn7wBc2lfmA/132","nickname":"a、","note":"","ucode":"590FE8DB111492","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7179,"discussion_content":"赞同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567416721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7110,"ip_address":"","group_id":0},"score":7179,"extra":""},{"author":{"id":1118333,"avatar":"https://static001.geekbang.org/account/avatar/00/11/10/7d/a9b5d5f0.jpg","nickname":"糖醋🏀","note":"","ucode":"E6FD12D630B439","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1532404,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIvUlicgrWtibbDzwhLw5cQrDSy2JuE1mVvmXq11KQIwpLicgDuWfpp9asE0VCN6HhibPDWn7wBc2lfmA/132","nickname":"a、","note":"","ucode":"590FE8DB111492","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7245,"discussion_content":"嗯，顺手写了下。\n优化点还有好几个。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567427513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7110,"ip_address":"","group_id":0},"score":7245,"extra":""}]}]},{"had_liked":false,"id":129996,"user_name":"Cast","can_delete":false,"product_type":"c1","uid":1315515,"ip_address":"","ucode":"226B483C60F797","user_header":"","comment_is_top":false,"comment_ctime":1567348638,"is_pvip":false,"replies":[{"id":48725,"content":"如果释放几把锁的过程中，不再有其它加锁的代码，正序释放也是没问题的。\n\n逆序释放只是一种习惯，让代码的结构更清晰。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567492392,"ip_address":"","comment_id":129996,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师，请问为什么要按逆序去释放锁呢？按照获取的顺序去释放好像也没什么毛病吧？","like_count":10,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465705,"discussion_content":"👍👍👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567491924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207556,"user_name":"喜欢地球的阿培同学","can_delete":false,"product_type":"c1","uid":1361746,"ip_address":"","ucode":"5F97037585F857","user_header":"https://static001.geekbang.org/account/avatar/00/14/c7/52/c5adf218.jpg","comment_is_top":false,"comment_ctime":1587107224,"is_pvip":false,"replies":[{"id":77841,"content":"不会。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1587352172,"ip_address":"","comment_id":207556,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师突然想到一个问题，假设现在100个线程，一个线程正在运行，99个线程正在阻塞(等待锁释放)，那么会导致CPU上下文频繁切换吗？","like_count":7,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492165,"discussion_content":"不会。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587352172,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175511,"user_name":"道","can_delete":false,"product_type":"c1","uid":1100869,"ip_address":"","ucode":"B17CA7372C21C1","user_header":"https://static001.geekbang.org/account/avatar/00/10/cc/45/73a0f7f8.jpg","comment_is_top":false,"comment_ctime":1580736786,"is_pvip":false,"replies":[{"id":68336,"content":"还是要看具体的使用场景。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1580864036,"ip_address":"","comment_id":175511,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"阻塞队列能够解决大部分并发访问的问题，Golang对他就提供了语言层面的支持，为何现实中用的不多哩？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482768,"discussion_content":"还是要看具体的使用场景。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580864036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139073,"user_name":"长期规划","can_delete":false,"product_type":"c1","uid":1019332,"ip_address":"","ucode":"5EF65E9115834B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","comment_is_top":false,"comment_ctime":1570541101,"is_pvip":false,"replies":[{"id":53645,"content":"是的，只有读锁之间是共享的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1570583483,"ip_address":"","comment_id":139073,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"那个读写锁，读锁和写锁之间应该也是互斥的吧","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469777,"discussion_content":"是的，只有读锁之间是共享的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570583483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139074,"user_name":"长期规划","can_delete":false,"product_type":"c1","uid":1019332,"ip_address":"","ucode":"5EF65E9115834B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","comment_is_top":false,"comment_ctime":1570541544,"is_pvip":false,"replies":[{"id":53644,"content":"即使是这样也不能完全保证没有死锁。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1570583460,"ip_address":"","comment_id":139074,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师，只要保证所有使用锁的地方都按相同的顺序获取，而且按获取的顺序的反序解锁，应该就不会发生死锁了吧。","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469778,"discussion_content":"即使是这样也不能完全保证没有死锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570583460,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1019332,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","nickname":"长期规划","note":"","ucode":"5EF65E9115834B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":25995,"discussion_content":"老师，能举个例子说明一下吗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1570583785,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1747803,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/ab/5b/eb3983f0.jpg","nickname":"liuchao90h","note":"","ucode":"30A89E766EED2B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1019332,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","nickname":"长期规划","note":"","ucode":"5EF65E9115834B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577048,"discussion_content":"mysql间隙锁算吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655901628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":25995,"ip_address":"","group_id":0},"score":577048,"extra":""}]}]},{"had_liked":false,"id":130667,"user_name":"明日","can_delete":false,"product_type":"c1","uid":1003917,"ip_address":"","ucode":"348899EC65AE8D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/51/8d/09f28606.jpg","comment_is_top":false,"comment_ctime":1567504751,"is_pvip":false,"replies":[{"id":48978,"content":"这样做应该是可以的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567564483,"ip_address":"","comment_id":130667,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"请问老师这种在new 对象过程中锁定共享锁的方式是否可行 \n 代码: https:&#47;&#47;gist.github.com&#47;imgaoxin&#47;91234a9edbf083b10244221493ce7fb5","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465882,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567490525,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130268,"user_name":"刘天鹏","can_delete":false,"product_type":"c1","uid":1632015,"ip_address":"","ucode":"FB146250578911","user_header":"https://static001.geekbang.org/account/avatar/00/18/e7/0f/fa840c1b.jpg","comment_is_top":false,"comment_ctime":1567415720,"is_pvip":false,"replies":[{"id":48721,"content":"是的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567490525,"ip_address":"","comment_id":130268,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"对于golang应该就是这样吧\nfunc foo(){\n  lock.Lock()\n  defer lock.Unlock()\n  &#47;&#47;do something...\n}","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465882,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567490525,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130239,"user_name":"你说的灰","can_delete":false,"product_type":"c1","uid":1158981,"ip_address":"","ucode":"650FA935A7741F","user_header":"https://static001.geekbang.org/account/avatar/00/11/af/45/8bacada2.jpg","comment_is_top":false,"comment_ctime":1567410860,"is_pvip":false,"replies":[{"id":48730,"content":"放到try之后的第一句也是可以的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567492898,"ip_address":"","comment_id":130239,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"\npublic void visitShareResWithLock() {\n  lock.lock();\n  try {\n    &#47;&#47; 在这里安全的访问共享资源\n  } finally {\n    lock.unlock();\n  }\n}\n\n lock.lock(); 加锁语句放在 try catch 里面是否可以。为什么很多示例代码都放在外面。","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465871,"discussion_content":"放到try之后的第一句也是可以的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567492898,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1365147,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d4/9b/5d69d4d3.jpg","nickname":"binary","note":"","ucode":"084B71B8695727","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7180,"discussion_content":" lock.lock(); 加锁语句放在 try里面的话，是不安全的。\n\n因为lock.lock(); 加锁可能成功，也可能会失败。如果在try里面的话，在加锁失败的情况下，仍然会在finally里面执行lock.unlock();，将导致未加锁成功，但是却去释放锁的结果。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567417174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129932,"user_name":"糖醋🏀","can_delete":false,"product_type":"c1","uid":1118333,"ip_address":"","ucode":"E6FD12D630B439","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/7d/a9b5d5f0.jpg","comment_is_top":false,"comment_ctime":1567329109,"is_pvip":false,"replies":[{"id":48562,"content":"👍👍👍","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567404371,"ip_address":"","comment_id":129932,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"java7开始io就有try-with-resource。\n可以利用这一个特性，来说实现，自动释放。\n代码如下：\n\npublic class AutoUnlockProxy implements Closeable {\n\n    private Lock lock;\n\n    public AutoUnlockProxy(Lock lock) {\n        this.lock = lock;\n    }\n\n    @Override\n    public void close() throws IOException {\n        lock.unlock();\n        System.out.println(&quot;释放锁&quot;);\n    }\n\n    public void lock() {\n        lock.lock();\n    }\n\n    public void tryLock(long time, TimeUnit unit) throws InterruptedException {\n        lock.tryLock(time, unit);\n    }\n\n    public static void main(String[] args) {\n\n        try (AutoUnlockProxy autoUnlockProxy = new AutoUnlockProxy(new ReentrantLock())) {\n            autoUnlockProxy.lock();\n            System.out.println(&quot;加锁了&quot;);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n}","like_count":74,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465724,"discussion_content":"👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567404371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1532404,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIvUlicgrWtibbDzwhLw5cQrDSy2JuE1mVvmXq11KQIwpLicgDuWfpp9asE0VCN6HhibPDWn7wBc2lfmA/132","nickname":"a、","note":"","ucode":"590FE8DB111492","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7110,"discussion_content":"你这个方法有点问题，每次new ReentrantlLock，根本锁不住吧，应该把new动作提出来","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1567388274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1365147,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d4/9b/5d69d4d3.jpg","nickname":"binary","note":"","ucode":"084B71B8695727","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1532404,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIvUlicgrWtibbDzwhLw5cQrDSy2JuE1mVvmXq11KQIwpLicgDuWfpp9asE0VCN6HhibPDWn7wBc2lfmA/132","nickname":"a、","note":"","ucode":"590FE8DB111492","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7179,"discussion_content":"赞同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567416721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7110,"ip_address":"","group_id":0},"score":7179,"extra":""},{"author":{"id":1118333,"avatar":"https://static001.geekbang.org/account/avatar/00/11/10/7d/a9b5d5f0.jpg","nickname":"糖醋🏀","note":"","ucode":"E6FD12D630B439","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1532404,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIvUlicgrWtibbDzwhLw5cQrDSy2JuE1mVvmXq11KQIwpLicgDuWfpp9asE0VCN6HhibPDWn7wBc2lfmA/132","nickname":"a、","note":"","ucode":"590FE8DB111492","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7245,"discussion_content":"嗯，顺手写了下。\n优化点还有好几个。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567427513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7110,"ip_address":"","group_id":0},"score":7245,"extra":""}]}]},{"had_liked":false,"id":129900,"user_name":"humor","can_delete":false,"product_type":"c1","uid":1181867,"ip_address":"","ucode":"9B48C4C7BEC92C","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/ab/caec7bca.jpg","comment_is_top":false,"comment_ctime":1567321459,"is_pvip":false,"replies":[{"id":48724,"content":"👍👍👍\n","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567491924,"ip_address":"","comment_id":129900,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"&#47;**\n*业务调用接口\n**&#47;\npublic interface Invoker{\n\tvoid invoke();\n}\n\n&#47;**\n*try-with-lock\n**&#47;\npublic class RLock{\n\tprivate Lock lock = new ReentrantLock();\n\n\tpublic void run(Invoker invoker) {\n\t\tlock.lock();\n\t\ttry{\n\t\t\tinvoker.invoke();\n\t\t} finally{\n\t\t\tlock.unlock();\n\t\t}\n\t}\n}\n\npublic BizInvoker implements Inoker{\n\tprivate RLock rLock = new RLock();\n\tpublic void invoke() {\n\t\t&#47;&#47;需要加锁的业务逻辑\n\t}\n\n\tpublic static void main(String[] args) {\n\t\trLock.run(new BizInvoker());\n\t}\n}","like_count":15,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465705,"discussion_content":"👍👍👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567491924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129996,"user_name":"Cast","can_delete":false,"product_type":"c1","uid":1315515,"ip_address":"","ucode":"226B483C60F797","user_header":"","comment_is_top":false,"comment_ctime":1567348638,"is_pvip":false,"replies":[{"id":48725,"content":"如果释放几把锁的过程中，不再有其它加锁的代码，正序释放也是没问题的。\n\n逆序释放只是一种习惯，让代码的结构更清晰。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567492392,"ip_address":"","comment_id":129996,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师，请问为什么要按逆序去释放锁呢？按照获取的顺序去释放好像也没什么毛病吧？","like_count":10,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465754,"discussion_content":"如果释放几把锁的过程中，不再有其它加锁的代码，正序释放也是没问题的。\n\n逆序释放只是一种习惯，让代码的结构更清晰。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567492392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2257630,"avatar":"https://static001.geekbang.org/account/avatar/00/22/72/de/7f5d9468.jpg","nickname":"X。","note":"","ucode":"1B4CB1A21F280A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590164,"discussion_content":"万一索嵌套，不就得逆序了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665561262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江西","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1481811,"avatar":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","nickname":"ub8","note":"","ucode":"0D937C3EAEB781","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":82796,"discussion_content":"看完后其实我也没明白为啥要按逆序去释放锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576380998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207556,"user_name":"喜欢地球的阿培同学","can_delete":false,"product_type":"c1","uid":1361746,"ip_address":"","ucode":"5F97037585F857","user_header":"https://static001.geekbang.org/account/avatar/00/14/c7/52/c5adf218.jpg","comment_is_top":false,"comment_ctime":1587107224,"is_pvip":false,"replies":[{"id":77841,"content":"不会。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1587352172,"ip_address":"","comment_id":207556,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师突然想到一个问题，假设现在100个线程，一个线程正在运行，99个线程正在阻塞(等待锁释放)，那么会导致CPU上下文频繁切换吗？","like_count":7,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465754,"discussion_content":"如果释放几把锁的过程中，不再有其它加锁的代码，正序释放也是没问题的。\n\n逆序释放只是一种习惯，让代码的结构更清晰。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567492392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2257630,"avatar":"https://static001.geekbang.org/account/avatar/00/22/72/de/7f5d9468.jpg","nickname":"X。","note":"","ucode":"1B4CB1A21F280A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590164,"discussion_content":"万一索嵌套，不就得逆序了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665561262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江西","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1481811,"avatar":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","nickname":"ub8","note":"","ucode":"0D937C3EAEB781","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":82796,"discussion_content":"看完后其实我也没明白为啥要按逆序去释放锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576380998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175511,"user_name":"道","can_delete":false,"product_type":"c1","uid":1100869,"ip_address":"","ucode":"B17CA7372C21C1","user_header":"https://static001.geekbang.org/account/avatar/00/10/cc/45/73a0f7f8.jpg","comment_is_top":false,"comment_ctime":1580736786,"is_pvip":false,"replies":[{"id":68336,"content":"还是要看具体的使用场景。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1580864036,"ip_address":"","comment_id":175511,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"阻塞队列能够解决大部分并发访问的问题，Golang对他就提供了语言层面的支持，为何现实中用的不多哩？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492165,"discussion_content":"不会。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587352172,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139073,"user_name":"长期规划","can_delete":false,"product_type":"c1","uid":1019332,"ip_address":"","ucode":"5EF65E9115834B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","comment_is_top":false,"comment_ctime":1570541101,"is_pvip":false,"replies":[{"id":53645,"content":"是的，只有读锁之间是共享的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1570583483,"ip_address":"","comment_id":139073,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"那个读写锁，读锁和写锁之间应该也是互斥的吧","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482768,"discussion_content":"还是要看具体的使用场景。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580864036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139074,"user_name":"长期规划","can_delete":false,"product_type":"c1","uid":1019332,"ip_address":"","ucode":"5EF65E9115834B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","comment_is_top":false,"comment_ctime":1570541544,"is_pvip":false,"replies":[{"id":53644,"content":"即使是这样也不能完全保证没有死锁。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1570583460,"ip_address":"","comment_id":139074,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师，只要保证所有使用锁的地方都按相同的顺序获取，而且按获取的顺序的反序解锁，应该就不会发生死锁了吧。","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469777,"discussion_content":"是的，只有读锁之间是共享的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570583483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130667,"user_name":"明日","can_delete":false,"product_type":"c1","uid":1003917,"ip_address":"","ucode":"348899EC65AE8D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/51/8d/09f28606.jpg","comment_is_top":false,"comment_ctime":1567504751,"is_pvip":false,"replies":[{"id":48978,"content":"这样做应该是可以的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567564483,"ip_address":"","comment_id":130667,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"请问老师这种在new 对象过程中锁定共享锁的方式是否可行 \n 代码: https:&#47;&#47;gist.github.com&#47;imgaoxin&#47;91234a9edbf083b10244221493ce7fb5","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466058,"discussion_content":"这样做应该是可以的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567564483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130268,"user_name":"刘天鹏","can_delete":false,"product_type":"c1","uid":1632015,"ip_address":"","ucode":"FB146250578911","user_header":"https://static001.geekbang.org/account/avatar/00/18/e7/0f/fa840c1b.jpg","comment_is_top":false,"comment_ctime":1567415720,"is_pvip":false,"replies":[{"id":48721,"content":"是的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567490525,"ip_address":"","comment_id":130268,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"对于golang应该就是这样吧\nfunc foo(){\n  lock.Lock()\n  defer lock.Unlock()\n  &#47;&#47;do something...\n}","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469778,"discussion_content":"即使是这样也不能完全保证没有死锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570583460,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1019332,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","nickname":"长期规划","note":"","ucode":"5EF65E9115834B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":25995,"discussion_content":"老师，能举个例子说明一下吗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1570583785,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1747803,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/ab/5b/eb3983f0.jpg","nickname":"liuchao90h","note":"","ucode":"30A89E766EED2B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1019332,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","nickname":"长期规划","note":"","ucode":"5EF65E9115834B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577048,"discussion_content":"mysql间隙锁算吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655901628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":25995,"ip_address":"","group_id":0},"score":577048,"extra":""}]}]},{"had_liked":false,"id":130239,"user_name":"你说的灰","can_delete":false,"product_type":"c1","uid":1158981,"ip_address":"","ucode":"650FA935A7741F","user_header":"https://static001.geekbang.org/account/avatar/00/11/af/45/8bacada2.jpg","comment_is_top":false,"comment_ctime":1567410860,"is_pvip":false,"replies":[{"id":48730,"content":"放到try之后的第一句也是可以的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567492898,"ip_address":"","comment_id":130239,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"\npublic void visitShareResWithLock() {\n  lock.lock();\n  try {\n    &#47;&#47; 在这里安全的访问共享资源\n  } finally {\n    lock.unlock();\n  }\n}\n\n lock.lock(); 加锁语句放在 try catch 里面是否可以。为什么很多示例代码都放在外面。","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466058,"discussion_content":"这样做应该是可以的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567564483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129800,"user_name":"Geek_q29f6t","can_delete":false,"product_type":"c1","uid":1299521,"ip_address":"","ucode":"1FDEC87C133E28","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJbh5FQajwKhNlMrkoSklPpOXBtEYXCLvuWibhfWIS9QxHWDqzhEHJzEdmtUiaiaqFjfpsr2LwgNGpbQ/132","comment_is_top":false,"comment_ctime":1567258365,"is_pvip":false,"replies":[{"id":48722,"content":"可以这样解决，每个计算任务都需要一个存储来存放，这个存储可以MySQL、Redis或者ZooKeeper，后端执行计算任务的服务负责更新任务的状态（比如计算中，计算完成，计算失败等），在计算过程中，计算服务定时去更新这个任务的时间戳，如果任务状态是计算中，但时间戳长时间未更新，可以认为是计算服务宕机了。类似于一个心跳机制。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567491641,"ip_address":"","comment_id":129800,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"老师，请教一个问题：假设有一个方法在计算报表，但这个计算的线程在执行过程中被意外释放了（并不是抛异常）， 此时try catch捕获是捕获不到这种情况的。而从客户端看来，这个计算过程就永远停在那里了，而后台又没能力告诉客户端：“你别等了”。 这种情况应该如果处理呢？","like_count":0},{"had_liked":false,"id":129787,"user_name":"树梢的果实","can_delete":false,"product_type":"c1","uid":1645124,"ip_address":"","ucode":"6A3CE5CE957EDA","user_header":"https://static001.geekbang.org/account/avatar/00/19/1a/44/331b3f41.jpg","comment_is_top":false,"comment_ctime":1567250688,"is_pvip":false,"replies":[{"id":48561,"content":"这样做是可以的，其实你用的这个阻塞队列它就是用锁来实现的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567404349,"ip_address":"","comment_id":129787,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"C语言下，通过宏很容易实现try-with-lock。\n如果两个线程中获取mutex的顺序不一致，可以通过增加第三个mutex来避免死锁。\n既然我们做异步、并行，磁盘读写也可以这么做啊，加一个queue，所有读写操作请求都放到queue中，在单独的线程中完成IO操作并通过callback或另一个queue返回结果。不知服务器上这么做有什么不妥？\n","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465658,"discussion_content":"可以这样解决，每个计算任务都需要一个存储来存放，这个存储可以MySQL、Redis或者ZooKeeper，后端执行计算任务的服务负责更新任务的状态（比如计算中，计算完成，计算失败等），在计算过程中，计算服务定时去更新这个任务的时间戳，如果任务状态是计算中，但时间戳长时间未更新，可以认为是计算服务宕机了。类似于一个心跳机制。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567491641,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1208637,"avatar":"https://static001.geekbang.org/account/avatar/00/12/71/3d/da8dc880.jpg","nickname":"游弋云端","note":"","ucode":"A960E8F5AA25B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7061,"discussion_content":"可以使用超时机制，或者定期轮询进展。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1567329527,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131893,"user_name":"菜鸟和谐号","can_delete":false,"product_type":"c1","uid":1632108,"ip_address":"","ucode":"649BD61DC406C2","user_header":"https://static001.geekbang.org/account/avatar/00/18/e7/6c/aa73b7a7.jpg","comment_is_top":false,"comment_ctime":1567952165,"is_pvip":false,"replies":null,"discussion_count":10,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"既然是消息队列自然要多讲讲消息队列的知识，一下io，一下缓存，一下多线程，讲的很杂，也不深入。","like_count":46,"discussions":[{"author":{"id":1295609,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJRFRX8kNzNet7FibNvtavbVpAwK09AhIhrib9k762qWtH6mre8ickP7hM5mgZC4ytr8NnmIfmAhxMSQ/132","nickname":"老大不小","note":"","ucode":"35BCDD3CB13467","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337353,"discussion_content":"你他喵的是想阻止我的进步，你不想看可以跳过去，没人求着你看","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1608882358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1736048,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/MItiagXxZFfAQsF9T2OSJTyzQgs65fAcDU4PmxwzBJaasu3icUbxEDaZwu1DoB6zJ8ez9mfe9tzHtelbSgrOSjTg/132","nickname":"Geek_49e5c2","note":"","ucode":"A2DA9A279EB6B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":143410,"discussion_content":"连起来看，你就知道老师在讲什么了","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1579505326,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1179298,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fe/a2/5252a278.jpg","nickname":"对方正在输入。。。","note":"","ucode":"7B0DEB4D9B43D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1736048,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/MItiagXxZFfAQsF9T2OSJTyzQgs65fAcDU4PmxwzBJaasu3icUbxEDaZwu1DoB6zJ8ez9mfe9tzHtelbSgrOSjTg/132","nickname":"Geek_49e5c2","note":"","ucode":"A2DA9A279EB6B1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539918,"discussion_content":"他估计看不懂…才这么说的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639879331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":143410,"ip_address":"","group_id":0},"score":539918,"extra":""}]},{"author":{"id":1434423,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e3/37/c132802f.jpg","nickname":"WESTWALL","note":"","ucode":"295A030F9D3BF4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544217,"discussion_content":"MQ的使用方法，就是基础篇里的那些内容。不管是RabbitMQ、还是Kafka、还是RocketMQ，都大同小异。如果是手把手读API的话，找本书看就好了，不需要花钱来学的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641441741,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2163653,"avatar":"https://static001.geekbang.org/account/avatar/00/21/03/c5/600fd645.jpg","nickname":"tianbingJ","note":"","ucode":"666141CAD8260F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1434423,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e3/37/c132802f.jpg","nickname":"WESTWALL","note":"","ucode":"295A030F9D3BF4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553716,"discussion_content":"你这真是杠，如果都是这种内容，你也可以找本操作系统的书看，不用来着花钱看。","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1646038837,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":544217,"ip_address":"","group_id":0},"score":553716,"extra":""}]},{"author":{"id":1488038,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b4/a6/b6fa2562.jpg","nickname":"渠梁","note":"","ucode":"DC86BDEC63C9BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299740,"discussion_content":"up++","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597804010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1230242,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c5/a2/4bef8cb6.jpg","nickname":"鹏","note":"","ucode":"AAA01498C85FCE","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":153046,"discussion_content":"这个课不是架构之路吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580018788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1001970,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/49/f2/25cfa472.jpg","nickname":"寒溪","note":"","ucode":"67B9F1A1C15A20","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":143468,"discussion_content":"up!","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579509102,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1603271,"avatar":"","nickname":"Geek_f3a3d1","note":"","ucode":"E15FA1C3AB3174","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":104831,"discussion_content":"up","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577452486,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1115761,"avatar":"https://static001.geekbang.org/account/avatar/00/11/06/71/1d98ad80.jpg","nickname":"oO蜗牛君🐌、、","note":"","ucode":"9178C612393FD5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":96825,"discussion_content":"up！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577095480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129646,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1567181713,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"幸亏学过极客时间的并发编程专栏，看懂了。我觉得并发容器的选择比较复杂。","like_count":7,"discussions":[{"author":{"id":1164531,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c4/f3/92f654f1.jpg","nickname":"Bug? Feature!","note":"","ucode":"F8FA8A0094FBA0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301591,"discussion_content":"我也是，看着没有鸭梨~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598583337,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":285018,"user_name":"long","can_delete":false,"product_type":"c1","uid":2461108,"ip_address":"","ucode":"952E1B5338C92B","user_header":"https://static001.geekbang.org/account/avatar/00/25/8d/b4/4a8b4b0a.jpg","comment_is_top":false,"comment_ctime":1616580016,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"要是能讲一下, 设计消息队列, 哪里需要用到锁, 就完美了.","like_count":3},{"had_liked":false,"id":139078,"user_name":"长期规划","can_delete":false,"product_type":"c1","uid":1019332,"ip_address":"","ucode":"5EF65E9115834B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","comment_is_top":false,"comment_ctime":1570542153,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"避免死锁\n1。锁最好不要嵌套，如果实在需要嵌套，要按2的顺序\n2。所有锁的地方都按相同的顺序加锁。比如有A，B，C，D四把锁，所有加锁的地方的顺序都是A→B→C→D，或者是其切片，比如线程1使用B→C，线程2使用A→B，线程3使用C→D\n3。解锁顺序最好和加锁顺序相反，这样逻辑清晰，锁不用后一定要释放\n","like_count":3},{"had_liked":false,"id":129696,"user_name":"L!en6o","can_delete":false,"product_type":"c1","uid":1054472,"ip_address":"","ucode":"E0931CB8998260","user_header":"https://static001.geekbang.org/account/avatar/00/10/17/08/566fb246.jpg","comment_is_top":false,"comment_ctime":1567221975,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"加一个锁回调 封装起来 实现 try-with-lock\n","like_count":3},{"had_liked":false,"id":341083,"user_name":"再见理想","can_delete":false,"product_type":"c1","uid":1245999,"ip_address":"","ucode":"FAC88B3F6F6DFD","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/2f/0a5e0751.jpg","comment_is_top":false,"comment_ctime":1649335237,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"关于锁的注意事项：\n1，如无必要，尽量不要用锁，加&#47;解锁会占用cpu时间，对系统性能影响很大。\n2，加锁后一定要记得释放锁，否则会导致其他需要用锁的程序阻塞。\n3，必要的场景，锁要设计可重入或超时时间，防止程序死锁。\n4，使用多个锁的情况，释放锁的顺序要和加锁的顺序相反。\n5，使用多个锁的情况，需要将锁进行排序，用到用锁的地方都按照锁顺序加锁，防止锁循环等待。\n6，可以用读写锁提升性能，支持并发读，不支持并发读写。\n7，尽量避免使用多个锁。\n8，加锁，释放锁尽量放在同一个方法内。","like_count":2},{"had_liked":false,"id":181105,"user_name":"凡","can_delete":false,"product_type":"c1","uid":1721168,"ip_address":"","ucode":"80C2A6452AB9EA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/43/50/abb4ca1e.jpg","comment_is_top":false,"comment_ctime":1582476143,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"类似 MySql 中的 排它锁（X）和共享锁(S)， 共享锁之间不互斥，排它锁和共享锁互斥，排它锁和排它锁互斥","like_count":2},{"had_liked":false,"id":129800,"user_name":"Geek_q29f6t","can_delete":false,"product_type":"c1","uid":1299521,"ip_address":"","ucode":"1FDEC87C133E28","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJbh5FQajwKhNlMrkoSklPpOXBtEYXCLvuWibhfWIS9QxHWDqzhEHJzEdmtUiaiaqFjfpsr2LwgNGpbQ/132","comment_is_top":false,"comment_ctime":1567258365,"is_pvip":false,"replies":[{"id":48722,"content":"可以这样解决，每个计算任务都需要一个存储来存放，这个存储可以MySQL、Redis或者ZooKeeper，后端执行计算任务的服务负责更新任务的状态（比如计算中，计算完成，计算失败等），在计算过程中，计算服务定时去更新这个任务的时间戳，如果任务状态是计算中，但时间戳长时间未更新，可以认为是计算服务宕机了。类似于一个心跳机制。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567491641,"ip_address":"","comment_id":129800,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"老师，请教一个问题：假设有一个方法在计算报表，但这个计算的线程在执行过程中被意外释放了（并不是抛异常）， 此时try catch捕获是捕获不到这种情况的。而从客户端看来，这个计算过程就永远停在那里了，而后台又没能力告诉客户端：“你别等了”。 这种情况应该如果处理呢？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465658,"discussion_content":"可以这样解决，每个计算任务都需要一个存储来存放，这个存储可以MySQL、Redis或者ZooKeeper，后端执行计算任务的服务负责更新任务的状态（比如计算中，计算完成，计算失败等），在计算过程中，计算服务定时去更新这个任务的时间戳，如果任务状态是计算中，但时间戳长时间未更新，可以认为是计算服务宕机了。类似于一个心跳机制。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567491641,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1208637,"avatar":"https://static001.geekbang.org/account/avatar/00/12/71/3d/da8dc880.jpg","nickname":"游弋云端","note":"","ucode":"A960E8F5AA25B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7061,"discussion_content":"可以使用超时机制，或者定期轮询进展。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1567329527,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129787,"user_name":"树梢的果实","can_delete":false,"product_type":"c1","uid":1645124,"ip_address":"","ucode":"6A3CE5CE957EDA","user_header":"https://static001.geekbang.org/account/avatar/00/19/1a/44/331b3f41.jpg","comment_is_top":false,"comment_ctime":1567250688,"is_pvip":false,"replies":[{"id":48561,"content":"这样做是可以的，其实你用的这个阻塞队列它就是用锁来实现的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1567404349,"ip_address":"","comment_id":129787,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"C语言下，通过宏很容易实现try-with-lock。\n如果两个线程中获取mutex的顺序不一致，可以通过增加第三个mutex来避免死锁。\n既然我们做异步、并行，磁盘读写也可以这么做啊，加一个queue，所有读写操作请求都放到queue中，在单独的线程中完成IO操作并通过callback或另一个queue返回结果。不知服务器上这么做有什么不妥？\n","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465649,"discussion_content":"这样做是可以的，其实你用的这个阻塞队列它就是用锁来实现的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567404349,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131893,"user_name":"菜鸟和谐号","can_delete":false,"product_type":"c1","uid":1632108,"ip_address":"","ucode":"649BD61DC406C2","user_header":"https://static001.geekbang.org/account/avatar/00/18/e7/6c/aa73b7a7.jpg","comment_is_top":false,"comment_ctime":1567952165,"is_pvip":false,"replies":null,"discussion_count":10,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"既然是消息队列自然要多讲讲消息队列的知识，一下io，一下缓存，一下多线程，讲的很杂，也不深入。","like_count":46,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465649,"discussion_content":"这样做是可以的，其实你用的这个阻塞队列它就是用锁来实现的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567404349,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129646,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1567181713,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"幸亏学过极客时间的并发编程专栏，看懂了。我觉得并发容器的选择比较复杂。","like_count":7,"discussions":[{"author":{"id":1295609,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJRFRX8kNzNet7FibNvtavbVpAwK09AhIhrib9k762qWtH6mre8ickP7hM5mgZC4ytr8NnmIfmAhxMSQ/132","nickname":"老大不小","note":"","ucode":"35BCDD3CB13467","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337353,"discussion_content":"你他喵的是想阻止我的进步，你不想看可以跳过去，没人求着你看","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1608882358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1736048,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/MItiagXxZFfAQsF9T2OSJTyzQgs65fAcDU4PmxwzBJaasu3icUbxEDaZwu1DoB6zJ8ez9mfe9tzHtelbSgrOSjTg/132","nickname":"Geek_49e5c2","note":"","ucode":"A2DA9A279EB6B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":143410,"discussion_content":"连起来看，你就知道老师在讲什么了","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1579505326,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1179298,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fe/a2/5252a278.jpg","nickname":"对方正在输入。。。","note":"","ucode":"7B0DEB4D9B43D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1736048,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/MItiagXxZFfAQsF9T2OSJTyzQgs65fAcDU4PmxwzBJaasu3icUbxEDaZwu1DoB6zJ8ez9mfe9tzHtelbSgrOSjTg/132","nickname":"Geek_49e5c2","note":"","ucode":"A2DA9A279EB6B1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539918,"discussion_content":"他估计看不懂…才这么说的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639879331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":143410,"ip_address":"","group_id":0},"score":539918,"extra":""}]},{"author":{"id":1434423,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e3/37/c132802f.jpg","nickname":"WESTWALL","note":"","ucode":"295A030F9D3BF4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544217,"discussion_content":"MQ的使用方法，就是基础篇里的那些内容。不管是RabbitMQ、还是Kafka、还是RocketMQ，都大同小异。如果是手把手读API的话，找本书看就好了，不需要花钱来学的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641441741,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2163653,"avatar":"https://static001.geekbang.org/account/avatar/00/21/03/c5/600fd645.jpg","nickname":"tianbingJ","note":"","ucode":"666141CAD8260F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1434423,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e3/37/c132802f.jpg","nickname":"WESTWALL","note":"","ucode":"295A030F9D3BF4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553716,"discussion_content":"你这真是杠，如果都是这种内容，你也可以找本操作系统的书看，不用来着花钱看。","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1646038837,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":544217,"ip_address":"","group_id":0},"score":553716,"extra":""}]},{"author":{"id":1488038,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b4/a6/b6fa2562.jpg","nickname":"渠梁","note":"","ucode":"DC86BDEC63C9BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299740,"discussion_content":"up++","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597804010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1230242,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c5/a2/4bef8cb6.jpg","nickname":"鹏","note":"","ucode":"AAA01498C85FCE","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":153046,"discussion_content":"这个课不是架构之路吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580018788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1001970,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/49/f2/25cfa472.jpg","nickname":"寒溪","note":"","ucode":"67B9F1A1C15A20","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":143468,"discussion_content":"up!","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579509102,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1603271,"avatar":"","nickname":"Geek_f3a3d1","note":"","ucode":"E15FA1C3AB3174","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":104831,"discussion_content":"up","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577452486,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1115761,"avatar":"https://static001.geekbang.org/account/avatar/00/11/06/71/1d98ad80.jpg","nickname":"oO蜗牛君🐌、、","note":"","ucode":"9178C612393FD5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":96825,"discussion_content":"up！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577095480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":285018,"user_name":"long","can_delete":false,"product_type":"c1","uid":2461108,"ip_address":"","ucode":"952E1B5338C92B","user_header":"https://static001.geekbang.org/account/avatar/00/25/8d/b4/4a8b4b0a.jpg","comment_is_top":false,"comment_ctime":1616580016,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"要是能讲一下, 设计消息队列, 哪里需要用到锁, 就完美了.","like_count":3},{"had_liked":false,"id":139078,"user_name":"长期规划","can_delete":false,"product_type":"c1","uid":1019332,"ip_address":"","ucode":"5EF65E9115834B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","comment_is_top":false,"comment_ctime":1570542153,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"避免死锁\n1。锁最好不要嵌套，如果实在需要嵌套，要按2的顺序\n2。所有锁的地方都按相同的顺序加锁。比如有A，B，C，D四把锁，所有加锁的地方的顺序都是A→B→C→D，或者是其切片，比如线程1使用B→C，线程2使用A→B，线程3使用C→D\n3。解锁顺序最好和加锁顺序相反，这样逻辑清晰，锁不用后一定要释放\n","like_count":3},{"had_liked":false,"id":129696,"user_name":"L!en6o","can_delete":false,"product_type":"c1","uid":1054472,"ip_address":"","ucode":"E0931CB8998260","user_header":"https://static001.geekbang.org/account/avatar/00/10/17/08/566fb246.jpg","comment_is_top":false,"comment_ctime":1567221975,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"加一个锁回调 封装起来 实现 try-with-lock\n","like_count":3},{"had_liked":false,"id":341083,"user_name":"再见理想","can_delete":false,"product_type":"c1","uid":1245999,"ip_address":"","ucode":"FAC88B3F6F6DFD","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/2f/0a5e0751.jpg","comment_is_top":false,"comment_ctime":1649335237,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"关于锁的注意事项：\n1，如无必要，尽量不要用锁，加&#47;解锁会占用cpu时间，对系统性能影响很大。\n2，加锁后一定要记得释放锁，否则会导致其他需要用锁的程序阻塞。\n3，必要的场景，锁要设计可重入或超时时间，防止程序死锁。\n4，使用多个锁的情况，释放锁的顺序要和加锁的顺序相反。\n5，使用多个锁的情况，需要将锁进行排序，用到用锁的地方都按照锁顺序加锁，防止锁循环等待。\n6，可以用读写锁提升性能，支持并发读，不支持并发读写。\n7，尽量避免使用多个锁。\n8，加锁，释放锁尽量放在同一个方法内。","like_count":2},{"had_liked":false,"id":181105,"user_name":"凡","can_delete":false,"product_type":"c1","uid":1721168,"ip_address":"","ucode":"80C2A6452AB9EA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/43/50/abb4ca1e.jpg","comment_is_top":false,"comment_ctime":1582476143,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"类似 MySql 中的 排它锁（X）和共享锁(S)， 共享锁之间不互斥，排它锁和共享锁互斥，排它锁和排它锁互斥","like_count":2,"discussions":[{"author":{"id":1164531,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c4/f3/92f654f1.jpg","nickname":"Bug? Feature!","note":"","ucode":"F8FA8A0094FBA0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301591,"discussion_content":"我也是，看着没有鸭梨~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598583337,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338743,"user_name":"i_chase","can_delete":false,"product_type":"c1","uid":1795511,"ip_address":"","ucode":"09C41C863F4EA3","user_header":"https://static001.geekbang.org/account/avatar/00/1b/65/b7/058276dc.jpg","comment_is_top":false,"comment_ctime":1647697986,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"变成java大讲堂了。。","like_count":1},{"had_liked":false,"id":176411,"user_name":"往事随风，顺其自然","can_delete":false,"product_type":"c1","uid":1235692,"ip_address":"","ucode":"F266EC6B143E38","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/ec/779c1a78.jpg","comment_is_top":false,"comment_ctime":1581053485,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"十八般武器全用上，队列还是多讲些深入的知识","like_count":1},{"had_liked":false,"id":144417,"user_name":"Switch","can_delete":false,"product_type":"c1","uid":1049360,"ip_address":"","ucode":"D8A7F7F6A0BEA9","user_header":"https://static001.geekbang.org/account/avatar/00/10/03/10/26f9f762.jpg","comment_is_top":false,"comment_ctime":1571918255,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"try with resource实现\n传入参数实现\n\nhttps:&#47;&#47;github.com&#47;Switch-vov&#47;mq-learing&#47;tree&#47;master&#47;src&#47;main&#47;java&#47;com&#47;switchvov&#47;lock","like_count":1},{"had_liked":false,"id":367465,"user_name":"千锤百炼领悟之极限","can_delete":false,"product_type":"c1","uid":1744257,"ip_address":"广东","ucode":"224B5CF2101716","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9d/81/d748b7eb.jpg","comment_is_top":false,"comment_ctime":1675249651,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"关于锁使用的建议：\n\n1.能不使用锁就不要使用锁，或者不清楚是否需要锁的情况下也不要使用锁。\n2.加锁与解锁都必须在同一个方法内，避免加锁后忘记解锁。\n3.尽量不要在已经持有一把锁的情况下，再去持有多把锁。\n4.如果必须持有多把锁，加锁与解锁的顺序要相反，例如加锁顺序是A-&gt;B-&gt;C，那么解锁的顺序就是C-&gt;B-&gt;A。\n5.给你系统中的锁定一个顺序，在任何情况都按这个顺序加锁。","like_count":0},{"had_liked":false,"id":351431,"user_name":"syz","can_delete":false,"product_type":"c1","uid":1174704,"ip_address":"","ucode":"54AF17ACD72645","user_header":"https://static001.geekbang.org/account/avatar/00/11/ec/b0/4e22819f.jpg","comment_is_top":false,"comment_ctime":1657784378,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"死锁：忘记释放、锁重入问题、多个锁多处调用相互竞争\nfun lockAndUnlock(doSth :()-&gt;Unit,onError:(e:Exception)-&gt;Unit){\n        try {\n            lock.lock()\n            doSth()\n        }catch (e:Exception){\n            onError(e)\n        }finally {\n            lock.unlock()\n        }\n    }\n\n}","like_count":0},{"had_liked":false,"id":342819,"user_name":"陈斌","can_delete":false,"product_type":"c1","uid":1367048,"ip_address":"","ucode":"B639AB5F6AA03D","user_header":"https://static001.geekbang.org/account/avatar/00/14/dc/08/64f5ab52.jpg","comment_is_top":false,"comment_ctime":1650477012,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"读写锁，在其他线程持有读锁时，另一个线程可以过去到写锁吗？","like_count":0},{"had_liked":false,"id":308746,"user_name":"菜鸟","can_delete":false,"product_type":"c1","uid":2451215,"ip_address":"","ucode":"214A61B6B3410F","user_header":"https://static001.geekbang.org/account/avatar/00/25/67/0f/3cb10900.jpg","comment_is_top":false,"comment_ctime":1629780345,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"线程的切换的代价有多大？以及线程切换会引起缓存失效吗？","like_count":0},{"had_liked":false,"id":277899,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1612665027,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"Java7 提供了对应的try-with-resource,我们可以实现一个实现了Closeable接口,利用装饰器模式包裹了对应的Reentrantlock的实体类来达成我们的目标","like_count":0},{"had_liked":false,"id":218780,"user_name":"贺宇","can_delete":false,"product_type":"c1","uid":1445040,"ip_address":"","ucode":"55854825CC4AD2","user_header":"https://static001.geekbang.org/account/avatar/00/16/0c/b0/26c0e53f.jpg","comment_is_top":false,"comment_ctime":1589874747,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"遇到过数据库死锁的情况，加锁顺序还是很重要的","like_count":0},{"had_liked":false,"id":173771,"user_name":"小伟","can_delete":false,"product_type":"c1","uid":1359701,"ip_address":"","ucode":"124953423491E2","user_header":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","comment_is_top":false,"comment_ctime":1579682290,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"课后作业：https:&#47;&#47;github.com&#47;ToddSAP&#47;Geektime&#47;tree&#47;master&#47;src&#47;mqmaster&#47;course17\n两种方法：\n1. 接口代理：代码有入侵\n2. AOP：可做到代码无入侵","like_count":0,"discussions":[{"author":{"id":1111821,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f7/0d/355a9658.jpg","nickname":"poxiao1234","note":"","ucode":"DBAA45E47DAA7A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":210815,"discussion_content":"买了李玥老师两个专栏，有较相同的感悟，很希望老师给点深入的干货呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584778550,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338743,"user_name":"i_chase","can_delete":false,"product_type":"c1","uid":1795511,"ip_address":"","ucode":"09C41C863F4EA3","user_header":"https://static001.geekbang.org/account/avatar/00/1b/65/b7/058276dc.jpg","comment_is_top":false,"comment_ctime":1647697986,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"变成java大讲堂了。。","like_count":1},{"had_liked":false,"id":176411,"user_name":"往事随风，顺其自然","can_delete":false,"product_type":"c1","uid":1235692,"ip_address":"","ucode":"F266EC6B143E38","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/ec/779c1a78.jpg","comment_is_top":false,"comment_ctime":1581053485,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"十八般武器全用上，队列还是多讲些深入的知识","like_count":1,"discussions":[{"author":{"id":1111821,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f7/0d/355a9658.jpg","nickname":"poxiao1234","note":"","ucode":"DBAA45E47DAA7A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":210815,"discussion_content":"买了李玥老师两个专栏，有较相同的感悟，很希望老师给点深入的干货呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584778550,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144417,"user_name":"Switch","can_delete":false,"product_type":"c1","uid":1049360,"ip_address":"","ucode":"D8A7F7F6A0BEA9","user_header":"https://static001.geekbang.org/account/avatar/00/10/03/10/26f9f762.jpg","comment_is_top":false,"comment_ctime":1571918255,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"try with resource实现\n传入参数实现\n\nhttps:&#47;&#47;github.com&#47;Switch-vov&#47;mq-learing&#47;tree&#47;master&#47;src&#47;main&#47;java&#47;com&#47;switchvov&#47;lock","like_count":1},{"had_liked":false,"id":367465,"user_name":"千锤百炼领悟之极限","can_delete":false,"product_type":"c1","uid":1744257,"ip_address":"广东","ucode":"224B5CF2101716","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9d/81/d748b7eb.jpg","comment_is_top":false,"comment_ctime":1675249651,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"关于锁使用的建议：\n\n1.能不使用锁就不要使用锁，或者不清楚是否需要锁的情况下也不要使用锁。\n2.加锁与解锁都必须在同一个方法内，避免加锁后忘记解锁。\n3.尽量不要在已经持有一把锁的情况下，再去持有多把锁。\n4.如果必须持有多把锁，加锁与解锁的顺序要相反，例如加锁顺序是A-&gt;B-&gt;C，那么解锁的顺序就是C-&gt;B-&gt;A。\n5.给你系统中的锁定一个顺序，在任何情况都按这个顺序加锁。","like_count":0},{"had_liked":false,"id":351431,"user_name":"syz","can_delete":false,"product_type":"c1","uid":1174704,"ip_address":"","ucode":"54AF17ACD72645","user_header":"https://static001.geekbang.org/account/avatar/00/11/ec/b0/4e22819f.jpg","comment_is_top":false,"comment_ctime":1657784378,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"死锁：忘记释放、锁重入问题、多个锁多处调用相互竞争\nfun lockAndUnlock(doSth :()-&gt;Unit,onError:(e:Exception)-&gt;Unit){\n        try {\n            lock.lock()\n            doSth()\n        }catch (e:Exception){\n            onError(e)\n        }finally {\n            lock.unlock()\n        }\n    }\n\n}","like_count":0},{"had_liked":false,"id":342819,"user_name":"陈斌","can_delete":false,"product_type":"c1","uid":1367048,"ip_address":"","ucode":"B639AB5F6AA03D","user_header":"https://static001.geekbang.org/account/avatar/00/14/dc/08/64f5ab52.jpg","comment_is_top":false,"comment_ctime":1650477012,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"读写锁，在其他线程持有读锁时，另一个线程可以过去到写锁吗？","like_count":0},{"had_liked":false,"id":308746,"user_name":"菜鸟","can_delete":false,"product_type":"c1","uid":2451215,"ip_address":"","ucode":"214A61B6B3410F","user_header":"https://static001.geekbang.org/account/avatar/00/25/67/0f/3cb10900.jpg","comment_is_top":false,"comment_ctime":1629780345,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"线程的切换的代价有多大？以及线程切换会引起缓存失效吗？","like_count":0},{"had_liked":false,"id":277899,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1612665027,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"Java7 提供了对应的try-with-resource,我们可以实现一个实现了Closeable接口,利用装饰器模式包裹了对应的Reentrantlock的实体类来达成我们的目标","like_count":0},{"had_liked":false,"id":218780,"user_name":"贺宇","can_delete":false,"product_type":"c1","uid":1445040,"ip_address":"","ucode":"55854825CC4AD2","user_header":"https://static001.geekbang.org/account/avatar/00/16/0c/b0/26c0e53f.jpg","comment_is_top":false,"comment_ctime":1589874747,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"遇到过数据库死锁的情况，加锁顺序还是很重要的","like_count":0},{"had_liked":false,"id":173771,"user_name":"小伟","can_delete":false,"product_type":"c1","uid":1359701,"ip_address":"","ucode":"124953423491E2","user_header":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","comment_is_top":false,"comment_ctime":1579682290,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"课后作业：https:&#47;&#47;github.com&#47;ToddSAP&#47;Geektime&#47;tree&#47;master&#47;src&#47;mqmaster&#47;course17\n两种方法：\n1. 接口代理：代码有入侵\n2. AOP：可做到代码无入侵","like_count":0},{"had_liked":false,"id":152343,"user_name":"Leododo","can_delete":false,"product_type":"c1","uid":1103745,"ip_address":"","ucode":"755DDB8A00B7A4","user_header":"https://static001.geekbang.org/account/avatar/00/10/d7/81/2727b475.jpg","comment_is_top":false,"comment_ctime":1573979228,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"一般情况下，如果业务场景需要调用多个锁，应该将这几把锁归放到一个盒子里面。加锁解锁的条件，在定义锁的时候就规定好。比如，拿到B锁的条件是必须已经拿到A锁。这样可以有效的避免人为的失误。","like_count":0},{"had_liked":false,"id":138857,"user_name":"陈凯","can_delete":false,"product_type":"c1","uid":1453035,"ip_address":"","ucode":"69A979A5DC91D6","user_header":"","comment_is_top":false,"comment_ctime":1570493974,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"干货满满👍","like_count":0},{"had_liked":false,"id":135990,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1569321400,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"学过宝令老师的并发编程，再看老师这个感觉很轻松，不过毕竟专栏主题所限，宝令老师整个专栏都在讲并发编程更加系统和专业。\nJAVA中实现一个try-with-lock，思路有两个：\n1：注解\n2：代理，静态或动态","like_count":0},{"had_liked":false,"id":129936,"user_name":"游弋云端","can_delete":false,"product_type":"c1","uid":1208637,"ip_address":"","ucode":"A960E8F5AA25B9","user_header":"https://static001.geekbang.org/account/avatar/00/12/71/3d/da8dc880.jpg","comment_is_top":false,"comment_ctime":1567329745,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"ABBA锁最容易出问题，老师的经验很重要，尽可能避免锁中锁。","like_count":0},{"had_liked":false,"id":129721,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1567231548,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"老师这篇文章的分享对我这样的非后端程序员很友好，感谢老师的分享。","like_count":0},{"had_liked":false,"id":129663,"user_name":"ヾ(◍°∇°◍)ﾉﾞ","can_delete":false,"product_type":"c1","uid":1044175,"ip_address":"","ucode":"89545632BDA56E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJOBwR7MCVqwZbPA5RQ2mjUjd571jUXUcBCE7lY5vSMibWn8D5S4PzDZMaAhRPdnRBqYbVOBTJibhJg/132","comment_is_top":false,"comment_ctime":1567211415,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"锁是为了并发时的共享而创建，如果没有共享的真正需求不应该使用锁。锁带来的最大问题就是复杂度和心智负担上升，所以很多框架把最复杂的实现隐藏在内部，留给使用者使用准则","like_count":0},{"had_liked":false,"id":152343,"user_name":"Leododo","can_delete":false,"product_type":"c1","uid":1103745,"ip_address":"","ucode":"755DDB8A00B7A4","user_header":"https://static001.geekbang.org/account/avatar/00/10/d7/81/2727b475.jpg","comment_is_top":false,"comment_ctime":1573979228,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"一般情况下，如果业务场景需要调用多个锁，应该将这几把锁归放到一个盒子里面。加锁解锁的条件，在定义锁的时候就规定好。比如，拿到B锁的条件是必须已经拿到A锁。这样可以有效的避免人为的失误。","like_count":0},{"had_liked":false,"id":138857,"user_name":"陈凯","can_delete":false,"product_type":"c1","uid":1453035,"ip_address":"","ucode":"69A979A5DC91D6","user_header":"","comment_is_top":false,"comment_ctime":1570493974,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"干货满满👍","like_count":0},{"had_liked":false,"id":135990,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1569321400,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"学过宝令老师的并发编程，再看老师这个感觉很轻松，不过毕竟专栏主题所限，宝令老师整个专栏都在讲并发编程更加系统和专业。\nJAVA中实现一个try-with-lock，思路有两个：\n1：注解\n2：代理，静态或动态","like_count":0},{"had_liked":false,"id":129936,"user_name":"游弋云端","can_delete":false,"product_type":"c1","uid":1208637,"ip_address":"","ucode":"A960E8F5AA25B9","user_header":"https://static001.geekbang.org/account/avatar/00/12/71/3d/da8dc880.jpg","comment_is_top":false,"comment_ctime":1567329745,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"ABBA锁最容易出问题，老师的经验很重要，尽可能避免锁中锁。","like_count":0},{"had_liked":false,"id":129721,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1567231548,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"老师这篇文章的分享对我这样的非后端程序员很友好，感谢老师的分享。","like_count":0},{"had_liked":false,"id":129663,"user_name":"ヾ(◍°∇°◍)ﾉﾞ","can_delete":false,"product_type":"c1","uid":1044175,"ip_address":"","ucode":"89545632BDA56E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJOBwR7MCVqwZbPA5RQ2mjUjd571jUXUcBCE7lY5vSMibWn8D5S4PzDZMaAhRPdnRBqYbVOBTJibhJg/132","comment_is_top":false,"comment_ctime":1567211415,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100032301,"comment_content":"锁是为了并发时的共享而创建，如果没有共享的真正需求不应该使用锁。锁带来的最大问题就是复杂度和心智负担上升，所以很多框架把最复杂的实现隐藏在内部，留给使用者使用准则","like_count":0}]}