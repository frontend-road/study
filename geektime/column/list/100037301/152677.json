{"id":152677,"title":"04 | 实体和值对象：从领域模型的基础单元看系统设计","content":"<p>你好，我是欧创新。今天我们来学习DDD战术设计中的两个重要概念：实体和值对象。</p><p>这两个概念都是领域模型中的领域对象。它们在领域模型中起什么作用，战术设计时如何将它们映射到代码和数据模型中去？就是我们这一讲重点要关注的问题。</p><p>另外，在战略设计向战术设计过渡的这个过程中，理解和区分实体和值对象在不同阶段的形态是很重要的，毕竟阶段不同，它们的形态也会发生变化，这与我们的设计和代码实现密切相关。</p><p>接下来，我们就分别看看实体和值对象的这些问题，从中找找答案。</p><h2>实体</h2><p>我们先来看一下实体是什么东西？</p><p>在DDD中有这样一类对象，它们拥有唯一标识符，且标识符在历经各种状态变更后仍能保持一致。对这些对象而言，重要的不是其属性，而是其延续性和标识，对象的延续性和标识会跨越甚至超出软件的生命周期。我们把这样的对象称为实体。没理解？没关系！请继续阅读。</p><h3>1. 实体的业务形态</h3><p>在DDD不同的设计过程中，实体的形态是不同的。在战略设计时，实体是领域模型的一个重要对象。领域模型中的实体是多个属性、操作或行为的载体。在事件风暴中，我们可以根据命令、操作或者事件，找出产生这些行为的业务实体对象，进而按照一定的业务规则将依存度高和业务关联紧密的多个实体对象和值对象进行聚类，形成聚合。你可以这么理解，<span class=\"orange\">实体和值对象是组成领域模型的基础单元。</span></p><!-- [[[read_end]]] --><h3>2. 实体的代码形态</h3><p>在代码模型中，实体的表现形式是实体类，这个类包含了实体的属性和方法，通过这些方法实现实体自身的业务逻辑。在DDD里，<span class=\"orange\">这些实体类通常采用充血模型，</span>与这个实体相关的所有业务逻辑都在实体类的方法中实现，跨多个实体的领域逻辑则在领域服务中实现。</p><h3>3. 实体的运行形态</h3><p>实体以DO（领域对象）的形式存在，每个实体对象都有唯一的ID。我们可以对一个实体对象进行多次修改，修改后的数据和原来的数据可能会大不相同。但是，由于它们拥有相同的ID，它们依然是同一个实体。比如商品是商品上下文的一个实体，通过唯一的商品ID来标识，不管这个商品的数据如何变化，商品的ID一直保持不变，它始终是同一个商品。</p><h3>4. 实体的数据库形态</h3><p>与传统数据模型设计优先不同，DDD是先构建领域模型，针对实际业务场景构建实体对象和行为，再将实体对象映射到数据持久化对象。</p><p>在领域模型映射到数据模型时，一个实体可能对应0个、1个或者多个数据库持久化对象。大多数情况下实体与持久化对象是一对一。在某些场景中，有些实体只是暂驻静态内存的一个运行态实体，它不需要持久化。比如，基于多个价格配置数据计算后生成的折扣实体。</p><p>而在有些复杂场景下，实体与持久化对象则可能是一对多或者多对一的关系。比如，用户user与角色role两个持久化对象可生成权限实体，一个实体对应两个持久化对象，这是一对多的场景。再比如，有些场景为了避免数据库的联表查询，提升系统性能，会将客户信息customer和账户信息account两类数据保存到同一张数据库表中，客户和账户两个实体可根据需要从一个持久化对象中生成，这就是多对一的场景。</p><h2>值对象</h2><p>值对象相对实体来说，会更加抽象一些，概念上我们会结合例子来讲。</p><p>我们先看一下《实现领域驱动设计》一书中对值对象的定义：<span class=\"orange\">通过对象属性值来识别的对象，它将多个相关属性组合为一个概念整体。</span>在DDD中用来描述领域的特定方面，并且是一个没有标识符的对象，叫作值对象。</p><p>也就说，值对象描述了领域中的一件东西，这个东西是不可变的，它将不同的相关属性组合成了一个概念整体。当度量和描述改变时，可以用另外一个值对象予以替换。它可以和其它值对象进行相等性比较，且不会对协作对象造成副作用。这部分在后面讲“值对象的运行形态”时还会有例子。</p><p>上面这两段对于定义的阐述，如果你还是觉得有些晦涩，我们不妨“翻译”一下，用更通俗的语言把定义讲清楚。</p><p><span class=\"orange\">简单来说，值对象本质上就是一个集合。</span>那这个集合里面有什么呢？若干个用于描述目的、具有整体概念和不可修改的属性。那这个集合存在的意义又是什么？在领域建模的过程中，值对象可以保证属性归类的清晰和概念的完整性，避免属性零碎。</p><p>这里我举个简单的例子，请看下面这张图：</p><p><img src=\"https://static001.geekbang.org/resource/image/13/f6/136512ac4c65b3f2ed4b2898b40965f6.jpg?wh=1402*891?wh=1402*891\" alt=\"\"></p><p>人员实体原本包括：姓名、年龄、性别以及人员所在的省、市、县和街道等属性。这样显示地址相关的属性就很零碎了对不对？现在，我们可以将“省、市、县和街道等属性”拿出来构成一个“地址属性集合”，这个集合就是值对象了。</p><h3>1. 值对象的业务形态</h3><p>值对象是DDD领域模型中的一个基础对象，它跟实体一样都来源于事件风暴所构建的领域模型，都包含了若干个属性，它与实体一起构成聚合。</p><p>我们不妨对照实体，来看值对象的业务形态，这样更好理解。本质上，实体是看得到、摸得着的实实在在的业务对象，实体具有业务属性、业务行为和业务逻辑。而值对象只是若干个属性的集合，只有数据初始化操作和有限的不涉及修改数据的行为，基本不包含业务逻辑。值对象的属性集虽然在物理上独立出来了，但在逻辑上它仍然是实体属性的一部分，用于描述实体的特征。</p><p>在值对象中也有部分共享的标准类型的值对象，它们有自己的限界上下文，有自己的持久化对象，可以建立共享的数据类微服务，比如数据字典。</p><h3>2. 值对象的代码形态</h3><p>值对象在代码中有这样两种形态。如果值对象是单一属性，则直接定义为实体类的属性；如果值对象是属性集合，则把它设计为Class类，Class将具有整体概念的多个属性归集到属性集合，这样的值对象没有ID，会被实体整体引用。</p><p>我们看一下下面这段代码，person这个实体有若干个单一属性的值对象，比如Id、name等属性；同时它也包含多个属性的值对象，比如地址address。</p><p><img src=\"https://static001.geekbang.org/resource/image/c5/1b/c597d53a1a1aeca274d355e8ac79cc1b.jpg?wh=1154*638\" alt=\"\"></p><h3>3. 值对象的运行形态</h3><p>实体实例化后的DO对象的业务属性和业务行为非常丰富，但值对象实例化的对象则相对简单和乏味。除了值对象数据初始化和整体替换的行为外，其它业务行为就很少了。</p><p>值对象嵌入到实体的话，有这样两种不同的数据格式，也可以说是两种方式，分别是属性嵌入的方式和序列化大对象的方式。</p><p>引用单一属性的值对象或只有一条记录的多属性值对象的实体，可以采用属性嵌入的方式嵌入。引用一条或多条记录的多属性值对象的实体，可以采用序列化大对象的方式嵌入。比如，人员实体可以有多个通讯地址，多个地址序列化后可以嵌入人员的地址属性。值对象创建后就不允许修改了，只能用另外一个值对象来整体替换。</p><p><strong>如果你对这两种方式不够了解，可以看看下面的例子。</strong></p><p>案例1：以属性嵌入的方式形成的人员实体对象，地址值对象直接以属性值嵌入人员实体中。</p><p><img src=\"https://static001.geekbang.org/resource/image/32/fa/323c8aca1271cc043558dfd1f95f57fa.jpg?wh=1190*286\" alt=\"\"></p><p>案例2：以序列化大对象的方式形成的人员实体对象，地址值对象被序列化成大对象Json串后，嵌入人员实体中。</p><p><img src=\"https://static001.geekbang.org/resource/image/96/23/96253ac8bd1d93a2786b59d7b9c2c423.jpg?wh=1018*334\" alt=\"\"></p><h3>4. 值对象的数据库形态</h3><p>DDD引入值对象是希望实现从“数据建模为中心”向“领域建模为中心”转变，减少数据库表的数量和表与表之间复杂的依赖关系，尽可能地简化数据库设计，提升数据库性能。</p><p>如何理解用值对象来简化数据库设计呢？</p><p>传统的数据建模大多是根据数据库范式设计的，每一个数据库表对应一个实体，每一个实体的属性值用单独的一列来存储，一个实体主表会对应N个实体从表。而值对象在数据库持久化方面简化了设计，它的数据库设计大多采用非数据库范式，值对象的属性值和实体对象的属性值保存在同一个数据库实体表中。</p><p>举个例子，还是基于上述人员和地址那个场景，实体和数据模型设计通常有两种解决方案：第一是把地址值对象的所有属性都放到人员实体表中，创建人员实体，创建人员数据表；第二是创建人员和地址两个实体，同时创建人员和地址两张表。</p><p>第一个方案会破坏地址的业务涵义和概念完整性，第二个方案增加了不必要的实体和表，需要处理多个实体和表的关系，从而增加了数据库设计的复杂性。</p><p><strong>那到底应该怎样设计，才能让业务含义清楚，同时又不让数据库变得复杂呢？</strong></p><p>我们可以综合这两个方案的优势，扬长避短。在领域建模时，我们可以把地址作为值对象，人员作为实体，这样就可以保留地址的业务涵义和概念完整性。而在数据建模时，我们可以将地址的属性值嵌入人员实体数据库表中，只创建人员数据库表。这样既可以兼顾业务含义和表达，又不增加数据库的复杂度。</p><p>值对象就是通过这种方式，简化了数据库设计，总结一下就是：<span class=\"orange\">在领域建模时，我们可以将部分对象设计为值对象，保留对象的业务涵义，同时又减少了实体的数量；在数据建模时，我们可以将值对象嵌入实体，减少实体表的数量，简化数据库设计。</span></p><p>另外，也有DDD专家认为，要想发挥对象的威力，就需要优先做领域建模，弱化数据库的作用，只把数据库作为一个保存数据的仓库即可。即使违反数据库设计原则，也不用大惊小怪，只要业务能够顺利运行，就没什么关系。</p><h3>5. 值对象的优势和局限</h3><p>值对象是一把双刃剑，它的优势是可以简化数据库设计，提升数据库性能。但如果值对象使用不当，它的优势就会很快变成劣势。“知彼知己，方能百战不殆”，你需要理解值对象真正适合的场景。</p><p>值对象采用序列化大对象的方法简化了数据库设计，减少了实体表的数量，可以简单、清晰地表达业务概念。这种设计方式虽然降低了数据库设计的复杂度，但却无法满足基于值对象的快速查询，会导致搜索值对象属性值变得异常困难。</p><p>值对象采用属性嵌入的方法提升了数据库的性能，但如果实体引用的值对象过多，则会导致实体堆积一堆缺乏概念完整性的属性，这样值对象就会失去业务涵义，操作起来也不方便。</p><p>所以，你可以对照着以上这些优劣势，结合你的业务场景，好好想一想了。那如果在你的业务场景中，值对象的这些劣势都可以避免掉，那就请放心大胆地使用值对象吧。</p><h2>实体和值对象的关系</h2><p>实体和值对象是微服务底层的最基础的对象，一起实现实体最基本的核心领域逻辑。</p><p>值对象和实体在某些场景下可以互换，很多DDD专家在这些场景下，其实也很难判断到底将领域对象设计成实体还是值对象？可以说，值对象在某些场景下有很好的价值，但是并不是所有的场景都适合值对象。你需要根据团队的设计和开发习惯，以及上面的优势和局限分析，选择最适合的方法。</p><p>关于值对象，我还要多说几句。其实，DDD引入值对象还有一个重要的原因，就是到底领域建模优先还是数据建模优先？</p><p><span class=\"orange\">DDD提倡从领域模型设计出发，而不是先设计数据模型。</span>前面讲过了，传统的数据模型设计通常是一个表对应一个实体，一个主表关联多个从表，当实体表太多的时候就很容易陷入无穷无尽的复杂的数据库设计，领域模型就很容易被数据模型绑架。可以说，值对象的诞生，在一定程度上，和实体是互补的。</p><p>我们还是以前面的图示为例：</p><p><img src=\"https://static001.geekbang.org/resource/image/13/f6/136512ac4c65b3f2ed4b2898b40965f6.jpg?wh=1402*891?wh=1402*891\" alt=\"\"></p><p>在领域模型中人员是实体，地址是值对象，地址值对象被人员实体引用。在数据模型设计时，地址值对象可以作为一个属性集整体嵌入人员实体中，组合形成上图这样的数据模型；也可以以序列化大对象的形式加入到人员的地址属性中，前面表格有展示。</p><p>从这个例子中，我们可以看出，同样的对象在不同的场景下，可能会设计出不同的结果。有些场景中，地址会被某一实体引用，它只承担描述实体的作用，并且它的值只能整体替换，这时候你就可以将地址设计为值对象，比如收货地址。而在某些业务场景中，地址会被经常修改，地址是作为一个独立对象存在的，这时候它应该设计为实体，比如行政区划中的地址信息维护。</p><h2>总结</h2><p>今天我们主要学习了实体和值对象在DDD不同设计阶段的形态，以及它们从战略设计向战术设计演进过程中的设计方法。</p><p>这个过程是从业务模型向系统模型落地的过程，比较复杂，很考验你的设计能力，很多时候我们都要结合自己的业务场景，选择合适的方法来进行微服务设计。强调一点，我们不避讳传统的设计方法，毕竟适合自己的才是最好的。希望你能充分理解实体和值对象的概念和应用，将学到的知识复用，最终将适合自己业务的DDD设计方法纳入到架构体系，实现落地。</p><h2>思考题</h2><p>请用自己的话总结下，实体和值对象的主要区别是什么？</p><p>欢迎留言和我分享你的思考和疑惑，你也可以把今天所学分享给身边的朋友，邀请他加入探讨，共同进步。</p><p><img src=\"https://static001.geekbang.org/resource/image/7b/33/7b1a917aff0ec923b78a54e81ed90733.jpg\" alt=\"unpreview\"></p>","comments":[{"had_liked":false,"id":142994,"user_name":"DZ","can_delete":false,"product_type":"c1","uid":1132240,"ip_address":"","ucode":"452555FA0F9E0F","user_header":"https://static001.geekbang.org/account/avatar/00/11/46/d0/6bafd7d4.jpg","comment_is_top":false,"comment_ctime":1571617865,"is_pvip":false,"replies":[{"id":"55245","content":"你太有才了。理解的很透彻。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571620221,"ip_address":"","comment_id":142994,"utype":1}],"discussion_count":26,"race_medal":0,"score":"1749623307337","product_id":100037301,"comment_content":"陈述一下我的学习心得：实体和值对象的目的都是抽象聚合若干属性以简化设计和沟通，有了这一层抽象，我们在使用人员实体时，不会产生歧义，在引用地址值对象时，不用列举其全部属性，在同一个限界上下文中，大幅降低误解、缩小偏差，两者的区别如下：<br>①两者都经过属性聚类形成，实体有唯一性，值对象没有。在本文案例的限界上下文中，人员有唯一性，一旦某个人员被系统纳入管理，它就被赋予了在事件、流程和操作中被唯一识别的能力，而值对象没有也不必具备唯一性。<br>②实体着重唯一性和延续性，不在意属性的变化，属性全变了，它还是原来那个它；值对象着重描述性，对属性的变化很敏感，属性变了，它就不是那个它了。<br>③战略上的思考框架稳定不变，战术上的模型设计却灵活多变，实体和值对象也有可能随着系统业务关注点的不同而更换位置。比如，如果换一个特殊的限界上下文，这个上下文更关注地址，而不那么关注与这个地址产生联系的人员，那么就应该把地址设计成实体，而把人员设计成值对象。","like_count":408,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471346,"discussion_content":"你太有才了。理解的很透彻。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571620221,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1107661,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e6/cd/a3c8f298.jpg","nickname":"晓白.M","note":"","ucode":"F7245D3723C5BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41647,"discussion_content":"说得很好，补充一句：从城市规划管理的上下文角度，地址可能就是实体，而居民或许可以只是个值对象","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1572483997,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1124889,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2a/19/6be7f66f.jpg","nickname":"Coca","note":"","ucode":"44AEF20DB59433","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335038,"discussion_content":"比作者牛逼多了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1608078430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1297630,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","nickname":"剑八","note":"","ucode":"0A09F41DB8A4E7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579737,"discussion_content":"实体和值对象我理解除了唯一标识的差异，比较重要的是业务视角上是不是需要有完整的业务流程从而维护一个状态机，这个体现的是一个业务侧重。业务侧重关注流程，就可以设计成实体。如价格规则，价格域关注，那就设计成实体。反之如果是一个交易域，对它来讲最终是交易快照上关联一个值对象价格规则id就好。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1657640173,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1534018,"avatar":"https://static001.geekbang.org/account/avatar/00/17/68/42/ce464c17.jpg","nickname":"xuef","note":"","ucode":"D00275A90E97F9","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546251,"discussion_content":"自古评论出人才。mark","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1642254603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1790355,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/51/93/1d067bed.jpg","nickname":"sugar椰子皮尤","note":"","ucode":"DCD580401F1BE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537632,"discussion_content":"中国人因缘聚合，缘起性空；\n实体和值对象都是面对当前问题域而聚合属性存在；\n实体关注的是延续性，是客观存在标识操作，是个人；\n缘起性空，在一个聚合里是实体，另外的却是值对象。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1639125313,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2324017,"avatar":"","nickname":"Geek_92a994","note":"","ucode":"D573E3260C0446","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373674,"discussion_content":"所以mongo  db这样的非关系型数据库更符合ddd，反序列化更方便。传统数据库的框架如mybatis反序列化不那么方便。可以这样理解吗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1620822775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1376233,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ff/e9/daebe1ea.jpg","nickname":"赵云","note":"","ucode":"FBECC7A2F4F70F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2324017,"avatar":"","nickname":"Geek_92a994","note":"","ucode":"D573E3260C0446","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377929,"discussion_content":"ddd正常都是适合复杂大型点的系统吧，采用mongo db的话，数据非常难去分析吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622968345,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":373674,"ip_address":""},"score":377929,"extra":""},{"author":{"id":1023729,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9e/f1/abb7bfe3.jpg","nickname":"szs","note":"","ucode":"1EA8129BC61EFB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1376233,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ff/e9/daebe1ea.jpg","nickname":"赵云","note":"","ucode":"FBECC7A2F4F70F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390952,"discussion_content":"为啥mongodb难分析数据呢，能举个例子吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630191177,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":377929,"ip_address":""},"score":390952,"extra":""}]},{"author":{"id":1638995,"avatar":"https://static001.geekbang.org/account/avatar/00/19/02/53/21cda64a.jpg","nickname":"道不远人","note":"","ucode":"E2A9825568C3AF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350250,"discussion_content":"从公安系统角度理解，一户地址下面，可以挂多个人，有且仅有一个户主","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1613786368,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1588880,"avatar":"https://static001.geekbang.org/account/avatar/00/18/3e/90/39f9c90b.jpg","nickname":"北极光","note":"","ucode":"CFB4A262ED9202","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":65284,"discussion_content":"一针见血，让我茅塞顿开！感谢！也不得不感叹，差距啊！向你学习。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574993346,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2357566,"avatar":"https://static001.geekbang.org/account/avatar/00/23/f9/3e/0d5f27c4.jpg","nickname":"肥猫不开心","note":"","ucode":"FA9204B84913C0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589277,"discussion_content":"好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664615483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"重庆"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1091684,"avatar":"https://static001.geekbang.org/account/avatar/00/10/a8/64/965e0d9b.jpg","nickname":"王维","note":"","ucode":"836E6CDB1A56BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585439,"discussion_content":"太有才了，简直不敢直视！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661571865,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"湖南"},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1293551,"avatar":"https://static001.geekbang.org/account/avatar/00/13/bc/ef/98550b85.jpg","nickname":"云彩＆草原","note":"","ucode":"6AEA686202F1CC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579589,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657539659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1627053,"avatar":"","nickname":"Geek_deb7fc","note":"","ucode":"6C4B8542C6BF3E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579294,"discussion_content":"在货运港口业务中，码头等地址就是实体对象，需要维护这个信息","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657324814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1795357,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/65/1d/34ac9c2b.jpg","nickname":"王东","note":"","ucode":"EF149E179D568E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575833,"discussion_content":"实体和值对象概念上的区别","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655130554,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2599635,"avatar":"https://static001.geekbang.org/account/avatar/00/27/aa/d3/5621af2f.jpg","nickname":"逆风飞扬","note":"","ucode":"DA34F015C7E9EB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557472,"discussion_content":"厉害","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647830353,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1213325,"avatar":"https://static001.geekbang.org/account/avatar/00/12/83/8d/03cac826.jpg","nickname":"徐李","note":"","ucode":"41550F6CA1E112","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537267,"discussion_content":"这个总结确实精辟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639016710,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1266634,"avatar":"https://static001.geekbang.org/account/avatar/00/13/53/ca/44088dd0.jpg","nickname":"花生","note":"","ucode":"5397C08BD51DD4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390044,"discussion_content":"太有才了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629622065,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181147,"avatar":"https://static001.geekbang.org/account/avatar/00/12/05/db/1bd78419.jpg","nickname":"有时也，命也，运也，如之奈何？","note":"","ucode":"792624AA1B2D9C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348492,"discussion_content":"优秀，醍醐灌顶","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612600794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1283461,"avatar":"https://static001.geekbang.org/account/avatar/00/13/95/85/15cd21c2.jpg","nickname":"杨锋","note":"","ucode":"85A7828A538FB0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301863,"discussion_content":"大佬，牛逼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598689077,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2016768,"avatar":"","nickname":"Geek_59491d","note":"","ucode":"DD61F86DA212A1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":273704,"discussion_content":"刚才还在思考是不是在不同领域能互换，你在第三点总结的很清楚了，而且老师也给了明确答复","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590491236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1127763,"avatar":"https://static001.geekbang.org/account/avatar/00/11/35/53/24b8c826.jpg","nickname":"iam593","note":"","ucode":"D787F695AF4056","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46477,"discussion_content":"很多人的单位地址是一样的，怎么处理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573174270,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1132240,"avatar":"https://static001.geekbang.org/account/avatar/00/11/46/d0/6bafd7d4.jpg","nickname":"DZ","note":"","ucode":"452555FA0F9E0F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1127763,"avatar":"https://static001.geekbang.org/account/avatar/00/11/35/53/24b8c826.jpg","nickname":"iam593","note":"","ucode":"D787F695AF4056","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46500,"discussion_content":"我是这样理解的：一方面，许多人可能属于同一个地址，另一方面，许多地址也可能属于同一个人，人和地址既可以分别作为实体而把对方作为值对象，也可以共同作为实体来描述业务，这正是业务设计存在的价值，也是我们赖以生存的生态位，如果业务设计可以非黑即白一板一眼，反倒不需要什么业务架构师了。😄","likes_number":19,"is_delete":false,"is_hidden":false,"ctime":1573176218,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":46477,"ip_address":""},"score":46500,"extra":""}]},{"author":{"id":1205328,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/50/a54f0907.jpg","nickname":"祥敏","note":"","ucode":"466BFA980D9A37","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41485,"discussion_content":"感谢这么精彩的总结。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572439416,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1306703,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/hfiatPIQkm18DdAGphc5onlAIbdXbpt3uRBG8SBwU5QicLIkTI3Z8nReAwjyNbnjOQqCc5M38fWcHpmma8dyk8lQ/132","nickname":"Benjamn","note":"","ucode":"5DCD2D90F5D3AC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38361,"discussion_content":"十分清楚的总结。非常感谢！又让我对实体和值，增加了进一步的理解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571761533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145472,"user_name":"stg609","can_delete":false,"product_type":"c1","uid":1073025,"ip_address":"","ucode":"FB70A75A891BB8","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/81/1c614f4a.jpg","comment_is_top":false,"comment_ctime":1572279370,"is_pvip":false,"replies":[{"id":"56152","content":"专业，非常同意你的观点。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572311599,"ip_address":"","comment_id":145472,"utype":1}],"discussion_count":13,"race_medal":0,"score":"491198551114","product_id":100037301,"comment_content":"我对于实体的看法和老师基本一致，但是值对象有补充，愿讨教。<br><br>首先，值对象没有id的概念，由其所拥有的所有属性来识别，属性值是不可变的。换句话说就是只要两个对象的所有属性都一样那就认为是同一个对象，可以互相替换, 但改变任何一个属性，就是两个不同的对象。<br><br>举个例子，你手里有一张毛爷爷，你不会在意这张毛爷爷是不是之前的那张，你在意的只是它的价值。<br><br>但是一个东西是被建模成值对象还是实体，不是一成不变的。<br>举个例子，汽车是一个实体，那车上的引擎可以认为是值对象，对于汽车而言，引擎坏了，换一个一样的就好了。但是对于引擎厂商来说，引擎就是个实体，厂商需要跟踪每个引擎的一些数据变化，不可能这个引擎丢了，随便拿一个新的引擎就可以替代的。<br><br>值对象的好处<br>既然是DDD, 从基础设施层，如数据库角度去考虑它的好处感觉有些牵强。我认为还是从如何降低业务复杂性角度出发会更合适。<br><br>·很容易判断两个对象是否相等<br>·不可变也确保了值对象永远都是正确的，尤其是在并发环境中不会被意外修改，是线程安全的。比如调用 String.ToUpper 会创建一个新的字符串而非修改原来的字符串，这可以避免其他使用了同一字符串的代码出现错误。<br>·值对象既然是不可变的，这使得它天然适合被重用，可以提高性能，就好像很多编程语言中的 String 是不可变的，同样的字符串只占用一份空间。<br><br>所以，鉴于值对象比实体更轻量级，高性能且线程安全，一般建议总是优先建模值对象，而非实体。<br><br>另外，值对象本身虽然是没有id的，但是并不妨碍它的属性是一个实体。","like_count":114,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472416,"discussion_content":"专业，非常同意你的观点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572311599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1694334,"avatar":"https://static001.geekbang.org/account/avatar/00/19/da/7e/a268583e.jpg","nickname":"王平","note":"","ucode":"6FFDD881FEF295","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":44764,"discussion_content":"毛爷爷这个例子很容易形成共鸣。在老百姓眼里就是值对象，不关注编号，只关注面值。但是对于银行，造币厂就变成实体了，编号，面值都要关注","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1572964607,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1207327,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6c/1f/d94be03b.jpg","nickname":"qrhu12","note":"","ucode":"C0029E60D6DA21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275055,"discussion_content":"“值对象本身虽然是没有id的，但是并不妨碍它的属性是一个实体” 这句话不理解","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1590655095,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1401837,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIG3L8ToibAiaHqWmMP9uuHpAhMJcScSwibpUW0IichAr2vsgymwsMWvVnwo8IH2OYdq62eMVpSM374iaQ/132","nickname":"极客","note":"","ucode":"478628BE35AEE3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1207327,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6c/1f/d94be03b.jpg","nickname":"qrhu12","note":"","ucode":"C0029E60D6DA21","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286718,"discussion_content":"同问，难道是说值对象属性里面，还有实体字段？实体嵌套值对象，值对象嵌套实体？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593267796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":275055,"ip_address":""},"score":286718,"extra":""},{"author":{"id":1132630,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/56/99369df2.jpg","nickname":"猛男还是萌男","note":"","ucode":"BD334667FCCBFF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1401837,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIG3L8ToibAiaHqWmMP9uuHpAhMJcScSwibpUW0IichAr2vsgymwsMWvVnwo8IH2OYdq62eMVpSM374iaQ/132","nickname":"极客","note":"","ucode":"478628BE35AEE3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373581,"discussion_content":"同文","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620789950,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":286718,"ip_address":""},"score":373581,"extra":""},{"author":{"id":2329181,"avatar":"https://static001.geekbang.org/account/avatar/00/23/8a/5d/9f146e48.jpg","nickname":"Monday","note":"","ucode":"33C597731B7AFA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1207327,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6c/1f/d94be03b.jpg","nickname":"qrhu12","note":"","ucode":"C0029E60D6DA21","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408383,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635238701,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":275055,"ip_address":""},"score":408383,"extra":""}]},{"author":{"id":1102919,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d4/47/6fa53fe6.jpg","nickname":"Orson Ju","note":"","ucode":"97239D05C64FD1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290291,"discussion_content":"我理解是一个对象是在一个上下文中是实体，可能在其他上下文中就是值对象，毕竟每个系统关注的点不一样，建模也会不一样。引擎公司当然关注每个引擎，但是汽车维修公司就不太关注每个引擎，只要是同一款就可以了。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1594397234,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1142025,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6d/09/ffeabc27.jpg","nickname":"任鑫","note":"","ucode":"9803EB15B634C3","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580389,"discussion_content":"在实践中发现，实体的hashcode equals 只取id属性，值对象取所有属性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658137637,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3009726,"avatar":"","nickname":"凌晨写Bug","note":"","ucode":"7345C0A982B6BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573354,"discussion_content":"    评论中的最后一句“值对象本身虽然是没有id的，但是并不妨碍它的属性是一个实体” ，这句话有点不理解这个。\n    既然值对象是不可变的，那么嵌套在内部的属性也应该是不可变的。而实体确是可变的，如果值对象中的一个属性是实体对象，那么这个属性就会可能发生变化，导致整个值对象发生变化。这样一来就有矛盾了。\n    难道是说，值对象中的属性是实体，其中的实体产生了变化就变成另一个值对象了？ 如果是这样，又会产生无穷无尽的值对象。不知道这样理解对不对，望指导。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653377788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1047266,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fa/e2/178bc954.jpg","nickname":"赵小通","note":"","ucode":"C19D395C2E8BA4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":167761,"discussion_content":"给个赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581519162,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1048799,"avatar":"https://static001.geekbang.org/account/avatar/00/10/00/df/58fe37df.jpg","nickname":"左","note":"","ucode":"FE02803AE2C0F0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78998,"discussion_content":"上代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576043974,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248742,"user_name":"nagedb","can_delete":false,"product_type":"c1","uid":1030088,"ip_address":"","ucode":"D2A7FB22880605","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b7/c8/d6765e27.jpg","comment_is_top":false,"comment_ctime":1600293584,"is_pvip":false,"replies":[{"id":"91634","content":"值对象的价值还是挺大的，尤其是在单体完成微服务拆分后，可以实现数据在不同领域模型中的流转。<br>很多值对象的数据可能来源于其他聚合，它们以数据冗余的方式完成不同领域中数据的流转和共享。在这些聚合中的值对象以实体或聚合根的形式存在，完成数据的集中维护和管理。而在自己的聚合中它则以值对象的形式存在，被聚合内的某一个实体引用。例如：在订单聚合中，订单实体有收货地址这个值对象。在生成订单实体时，会从个人中心的客户聚合中，获取地址实体数据组合成订单聚合的地址值对象。订单实体可以整体引用和修改地址值对象的数据，但不允许单独修改地址值对象的某一个属性数据，如 street。所有地址数据的新增和修改等维护操作，都只能在客户聚合中完成，这样就可以实现业务职责的高内聚，也就是说，如果你要修改某个业务行为，只需要修改一处就可以了。<br>由于不同聚合中实体和值对象的这种关系，值对象还有一个重要的使用场景，那就是记录和生成业务的数据快照。值对象以数据冗余的方式记录业务发生那一刻前后序聚合之间的业务数据，还原业务发生那一时刻的数据场景。比如订单聚合在下单时会记录订单生成那一刻的商品和收货地址等概要基础数据信息，我们称之为跟单数据。这时订单聚合的商品和收货地址是以包含多个属性的属性集值对象的形式存在的，它们被订单聚合根引用。属性集值对象的设计方式与通过商品 ID 或地址 ID 单一属性值对象关联的方式不同，当商品或地址的源端聚合的商品实体或地址实体数据变更后，不会影响订单聚合中商品和收货地址值对象的快照数据，这样就可以记录业务发生那一刻的业务快照数据了。即使源端商品或地址所在聚合出现服务不可用的情况，也不会影响订单聚合中商品或地址相关的业务逻辑，很好地实现了应用的解耦和故障隔离。<br>","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1600934897,"ip_address":"","comment_id":248742,"utype":1}],"discussion_count":7,"race_medal":0,"score":"126154345168","product_id":100037301,"comment_content":"值对象的设计和使用这样看起来有很大的局限性。","like_count":29,"discussions":[{"author":{"id":1188023,"avatar":"https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg","nickname":"Eternal","note":"","ucode":"EA6FE7CC98F740","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352255,"discussion_content":"关键这两点：\n1、很多值对象的数据可能来源于其他聚合，它们以数据冗余的方式完成不同领域中数据的流转和共享。在这些聚合中的值对象以实体或聚合根的形式存在，完成数据的集中维护和管理。而在自己的聚合中它则以值对象的形式存在，被聚合内的某一个实体引用\n2、值对象还有一个重要的使用场景，那就是记录和生成业务的数据快照","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1614666071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505731,"discussion_content":"值对象的价值还是挺大的，尤其是在单体完成微服务拆分后，可以实现数据在不同领域模型中的流转。\n很多值对象的数据可能来源于其他聚合，它们以数据冗余的方式完成不同领域中数据的流转和共享。在这些聚合中的值对象以实体或聚合根的形式存在，完成数据的集中维护和管理。而在自己的聚合中它则以值对象的形式存在，被聚合内的某一个实体引用。例如：在订单聚合中，订单实体有收货地址这个值对象。在生成订单实体时，会从个人中心的客户聚合中，获取地址实体数据组合成订单聚合的地址值对象。订单实体可以整体引用和修改地址值对象的数据，但不允许单独修改地址值对象的某一个属性数据，如 street。所有地址数据的新增和修改等维护操作，都只能在客户聚合中完成，这样就可以实现业务职责的高内聚，也就是说，如果你要修改某个业务行为，只需要修改一处就可以了。\n由于不同聚合中实体和值对象的这种关系，值对象还有一个重要的使用场景，那就是记录和生成业务的数据快照。值对象以数据冗余的方式记录业务发生那一刻前后序聚合之间的业务数据，还原业务发生那一时刻的数据场景。比如订单聚合在下单时会记录订单生成那一刻的商品和收货地址等概要基础数据信息，我们称之为跟单数据。这时订单聚合的商品和收货地址是以包含多个属性的属性集值对象的形式存在的，它们被订单聚合根引用。属性集值对象的设计方式与通过商品 ID 或地址 ID 单一属性值对象关联的方式不同，当商品或地址的源端聚合的商品实体或地址实体数据变更后，不会影响订单聚合中商品和收货地址值对象的快照数据，这样就可以记录业务发生那一刻的业务快照数据了。即使源端商品或地址所在聚合出现服务不可用的情况，也不会影响订单聚合中商品或地址相关的业务逻辑，很好地实现了应用的解耦和故障隔离。\n","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1600934897,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188023,"avatar":"https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg","nickname":"Eternal","note":"","ucode":"EA6FE7CC98F740","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352258,"discussion_content":"值对象只能整体替换不能修改","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1614666452,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2411361,"avatar":"","nickname":"齐斌","note":"","ucode":"1BFCD51E2F27BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341305,"discussion_content":"如果以保险项目为例，被保人、投保人信息作为值对象存储的话，那么当根据被保人姓名或证件号进行搜索时不是会存在性能问题么","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1610371983,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1299377,"avatar":"https://static001.geekbang.org/account/avatar/00/13/d3/b1/2350afbd.jpg","nickname":"IT高危人群","note":"","ucode":"A32B1581B3248C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2411361,"avatar":"","nickname":"齐斌","note":"","ucode":"1BFCD51E2F27BF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550852,"discussion_content":"同问这个问题！这个是很基本的需求场景。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1644759257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":341305,"ip_address":""},"score":550852,"extra":""}]},{"author":{"id":1790355,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/51/93/1d067bed.jpg","nickname":"sugar椰子皮尤","note":"","ucode":"DCD580401F1BE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537634,"discussion_content":"人（本身是个人，拥有生理、心理等各种成为人的属性）在接收外部信息，大脑作用下身体行动做出响应，改变世界；所有的东西都是已经发生过去的事情，要回忆时再慢慢回想，事件溯源。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639125791,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2095026,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/f7/b2/b9d2d7d8.jpg","nickname":"","note":"","ucode":"79DB151C0BFC63","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344091,"discussion_content":"那一个订单内的值对象快照什么时候替换呢，快照一直存活到这笔订单的声明周期结束？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611287263,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163619,"user_name":"james.d","can_delete":false,"product_type":"c1","uid":1087225,"ip_address":"","ucode":"CEE241856AF3B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/96/f9/3f976c91.jpg","comment_is_top":false,"comment_ctime":1576756314,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"87476102234","product_id":100037301,"comment_content":"<br>   在实践中我发现值对象是最容易被误解和忽视的DO，缺乏值对象的建模往往导致模型的不完整，最终系统有缺陷。值对象与实体具有相同的领域规则，是聚合中的重要组成部分，而且也是要参与业务构建的。<br>   值对象在领域内不具备生命周期，领域也不会修改值对象的属性，所以一个值对象在领域内具有不可变性。在该领域中业务不关心该对象的历史和将来，只关心值对象当前的属性对业务的影响。即便值对象的属性包含Id，领域也不会根据该Id去跟踪值对象的变化。<br>一个领域内的实体在其他领域中可能建模为值对象更合理，值对象一个重要的使用场景是生成快照，用于还原业务现场。比如订单中的商品，地址等等。","like_count":20},{"had_liked":false,"id":143301,"user_name":"FIGNT","can_delete":false,"product_type":"c1","uid":1540988,"ip_address":"","ucode":"D9DB185AE9E67C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKZ16iaIia0029oI1Qh5NicibpbTiaBAaCOPYXoLplKHr6uQ2rSVxPZanBvpMcL2NuhwKQYCFnaHP5tedQ/132","comment_is_top":false,"comment_ctime":1571664840,"is_pvip":false,"replies":[{"id":"55342","content":"理解很透彻。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571668257,"ip_address":"","comment_id":143301,"utype":1}],"discussion_count":5,"race_medal":0,"score":"70291141576","product_id":100037301,"comment_content":"实体和值对象都是领域模型的成员，实体是业务唯一性的载体，是个富对象，包含业务逻辑和唯一标识。值对象是属性的集合，没有唯一标识，只是数据的容器，没有业务逻辑。值对象是实体的一部分，为了简化设计，将部分相关属性抽离成值对象。如果值对象变动，原来的值对象可以直接丢弃。也可以理解为值对象是当时数据的快照，只是当时的状态。值对象过多会导致业务的缺失，影响查询性能。具体哪些属性可以作为值对象存在要具体问题具体分析。","like_count":16,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471475,"discussion_content":"理解很透彻。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571668257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1540988,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKZ16iaIia0029oI1Qh5NicibpbTiaBAaCOPYXoLplKHr6uQ2rSVxPZanBvpMcL2NuhwKQYCFnaHP5tedQ/132","nickname":"FIGNT","note":"","ucode":"D9DB185AE9E67C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":258352,"discussion_content":"这些逻辑应该写在实体中，而不是值对象中。比如，person是实体，body是值对象，记录这些身高体重，表示是否健康，应该是person.isHealthy(),数据是来之body，而不是person.body.isHealthy()。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588680814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1123011,"avatar":"https://static001.geekbang.org/account/avatar/00/11/22/c3/5c69ab81.jpg","nickname":"Lucky Dog","note":"","ucode":"C71C5D24200CCF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1540988,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKZ16iaIia0029oI1Qh5NicibpbTiaBAaCOPYXoLplKHr6uQ2rSVxPZanBvpMcL2NuhwKQYCFnaHP5tedQ/132","nickname":"FIGNT","note":"","ucode":"D9DB185AE9E67C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":317036,"discussion_content":"赞同","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603500261,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":258352,"ip_address":""},"score":317036,"extra":""}]},{"author":{"id":1929644,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/71/ac/c87546f5.jpg","nickname":"成章","note":"","ucode":"82D6E87A79A7B0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212853,"discussion_content":"我认为值对象不是简单的数据集合，它是有逻辑的，它的几个属性是有相关关系的，只是没有生命周期而已。就好比一个人人高体重的数据集合，根据这个集合你可以知道这个数值的拥有者是否健康，这个判断里就有业务逻辑。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585023357,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1537865,"avatar":"https://static001.geekbang.org/account/avatar/00/17/77/49/445eea2d.jpg","nickname":"SochiLee","note":"","ucode":"47596594EDF4D7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1929644,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/71/ac/c87546f5.jpg","nickname":"成章","note":"","ucode":"82D6E87A79A7B0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381525,"discussion_content":"我也赞同。值对象应该是有业务逻辑的不仅仅有属性，比如价格值对象，价格的变化是有规则的比如不能为负数等，而这些逻辑应该在这个价格值对象中。极客时间的《软件设计之美》的29讲中就举了价格值对象的例子说明值对象也有行为。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1625110627,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":212853,"ip_address":""},"score":381525,"extra":""}]}]},{"had_liked":false,"id":244163,"user_name":"alpha","can_delete":false,"product_type":"c1","uid":2140730,"ip_address":"","ucode":"6F67A0AB60EDC0","user_header":"","comment_is_top":false,"comment_ctime":1598414298,"is_pvip":false,"replies":[{"id":"89888","content":"幸会！幸会！<br>在聚合的模型中包含聚合根、实体和值对象。聚合根在数据中相当于主表的概念，实体是一般的表，而值对象可以设计成一般表，但是大多数情况下可以依托引用的实体表设计成嵌入属性集或者以Json串的形式存储。<br>实体就是我们一般理解上的业务对象，我们关注他们的生命周期，所以他们会有全局ID，通过ID来管理追踪它的生命周期。而值对象主要是用于描述的属性集，我们不关注他们的生命周期，更关注它的属性值。比如对于人民币100元，作为发行方央行在判断他是否是假币时，会关注它的ID，通过ID来追踪它的流通轨迹和生命周期。而在流通领域，我们只关注它的价值，不同ID的人民币价值都是100。<br>为什么会这样设计？我个人感觉主要还是为了实现聚合的解耦。在管理这个实体的聚合中，我们需要通过ID来管理这个实体的生命周期，而当这个实体数据流转到其它聚合时，这个实体的数据值就不允许修改了。这样可以保证一份数据只在一个地方修改，而可以在多个不同的业务领域使用，保证业务的“高内聚和低耦合”。<br>很多值对象的数据可能来源于其他聚合，它们以数据冗余的方式完成不同领域中数据的流转和共享。在这些聚合中的值对象以实体或聚合根的形式存在，完成数据的集中维护和管理。而在自己的聚合中它则以值对象的形式存在，被聚合内的某一个实体引用。例如：在订单聚合中，订单实体有收货地址这个值对象。在生成订单实体时，会从个人中心的客户聚合中，获取地址实体数据组合成订单聚合的地址值对象。订单实体可以整体引用和修改地址值对象的数据，但不允许单独修改地址值对象的某一个属性数据。所有地址数据的新增和修改等维护，都只能在客户聚合中完成，这样就可以实现业务职责的高内聚，也就是说“如果你要修改某个业务行为，只需要修改一处就可以了。”<br>    由于不同聚合中实体和值对象的这种关系，值对象还有一个重要的使用场景，那就是记录和生成业务的数据快照。值对象以数据冗余的方式记录业务发生那一刻前后序聚合之间的业务数据，还原业务发生那一时刻的数据场景。比如订单聚合在下单时会记录订单生成那一刻的商品和收货地址等概要基础数据信息，我们称之为跟单数据。这时订单聚合的商品和收货地址是以包含多个属性的属性集值对象的形式存在的，它们被订单聚合根引用。属性集值对象的设计方式与通过商品ID或地址ID单一属性值对象关联的方式不同，当商品或地址的源端聚合的商品实体或地址实体数据变更后，不会影响订单聚合中商品和收货地址值对象的快照数据，这样就可以记录业务发生那一刻的业务快照数据了。即使源端商品或地址所在聚合出现服务不可用的情况，也不会影响订单聚合中商品或地址相关的业务逻辑，很好地实现了应用的解耦和故障隔离。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1598425458,"ip_address":"","comment_id":244163,"utype":1}],"discussion_count":1,"race_medal":0,"score":"66022923738","product_id":100037301,"comment_content":"欧老师，你好，我也从事保险行业，在阳光保险工作，这里的值对象指的是什么？值对象是不是意味着数据库里没有对应的表了？","like_count":16,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504505,"discussion_content":"幸会！幸会！\n在聚合的模型中包含聚合根、实体和值对象。聚合根在数据中相当于主表的概念，实体是一般的表，而值对象可以设计成一般表，但是大多数情况下可以依托引用的实体表设计成嵌入属性集或者以Json串的形式存储。\n实体就是我们一般理解上的业务对象，我们关注他们的生命周期，所以他们会有全局ID，通过ID来管理追踪它的生命周期。而值对象主要是用于描述的属性集，我们不关注他们的生命周期，更关注它的属性值。比如对于人民币100元，作为发行方央行在判断他是否是假币时，会关注它的ID，通过ID来追踪它的流通轨迹和生命周期。而在流通领域，我们只关注它的价值，不同ID的人民币价值都是100。\n为什么会这样设计？我个人感觉主要还是为了实现聚合的解耦。在管理这个实体的聚合中，我们需要通过ID来管理这个实体的生命周期，而当这个实体数据流转到其它聚合时，这个实体的数据值就不允许修改了。这样可以保证一份数据只在一个地方修改，而可以在多个不同的业务领域使用，保证业务的“高内聚和低耦合”。\n很多值对象的数据可能来源于其他聚合，它们以数据冗余的方式完成不同领域中数据的流转和共享。在这些聚合中的值对象以实体或聚合根的形式存在，完成数据的集中维护和管理。而在自己的聚合中它则以值对象的形式存在，被聚合内的某一个实体引用。例如：在订单聚合中，订单实体有收货地址这个值对象。在生成订单实体时，会从个人中心的客户聚合中，获取地址实体数据组合成订单聚合的地址值对象。订单实体可以整体引用和修改地址值对象的数据，但不允许单独修改地址值对象的某一个属性数据。所有地址数据的新增和修改等维护，都只能在客户聚合中完成，这样就可以实现业务职责的高内聚，也就是说“如果你要修改某个业务行为，只需要修改一处就可以了。”\n    由于不同聚合中实体和值对象的这种关系，值对象还有一个重要的使用场景，那就是记录和生成业务的数据快照。值对象以数据冗余的方式记录业务发生那一刻前后序聚合之间的业务数据，还原业务发生那一时刻的数据场景。比如订单聚合在下单时会记录订单生成那一刻的商品和收货地址等概要基础数据信息，我们称之为跟单数据。这时订单聚合的商品和收货地址是以包含多个属性的属性集值对象的形式存在的，它们被订单聚合根引用。属性集值对象的设计方式与通过商品ID或地址ID单一属性值对象关联的方式不同，当商品或地址的源端聚合的商品实体或地址实体数据变更后，不会影响订单聚合中商品和收货地址值对象的快照数据，这样就可以记录业务发生那一刻的业务快照数据了。即使源端商品或地址所在聚合出现服务不可用的情况，也不会影响订单聚合中商品或地址相关的业务逻辑，很好地实现了应用的解耦和故障隔离。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598425458,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185208,"user_name":"唐高为","can_delete":false,"product_type":"c1","uid":1757658,"ip_address":"","ucode":"15655BE4928C9D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d1/da/7faf18a0.jpg","comment_is_top":false,"comment_ctime":1583516460,"is_pvip":false,"replies":[{"id":"71818","content":"是的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1583721226,"ip_address":"","comment_id":185208,"utype":1}],"discussion_count":1,"race_medal":0,"score":"44533189420","product_id":100037301,"comment_content":"有身份的是实体，没身份的是值对象。值对象的本质上是“值”。“值”即是一段数据，能存起来就行，无所谓怎么存。值对象的数据变了就不是原来的值对象了；实体的数据变了还是那个实体。","like_count":10,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486290,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583721226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160427,"user_name":"Alvin","can_delete":false,"product_type":"c1","uid":1061976,"ip_address":"","ucode":"ECA64F2913024A","user_header":"https://static001.geekbang.org/account/avatar/00/10/34/58/957ca791.jpg","comment_is_top":false,"comment_ctime":1575949137,"is_pvip":false,"replies":[{"id":"61240","content":"没错，理解正确。<br>但是实体在不同的层有不同的形态，如PO，DO，DTO等。实体不一定与数据库表一一对应。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1575957669,"ip_address":"","comment_id":160427,"utype":1}],"discussion_count":1,"race_medal":0,"score":"40230654801","product_id":100037301,"comment_content":"用项目结构来通俗的讲，实体就是我们平时项目中entity包中的类，与数据库表直接映射，值对象文章开头处一直误以为是view层的VO对象，后面才了解它其实就是实体中的属性对象。不知我这么粗浅的领悟对不对","like_count":9,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477372,"discussion_content":"没错，理解正确。\n但是实体在不同的层有不同的形态，如PO，DO，DTO等。实体不一定与数据库表一一对应。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575957669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143554,"user_name":"密码123456","can_delete":false,"product_type":"c1","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1571730058,"is_pvip":false,"replies":[{"id":"55427","content":"抓住几个关键点就不那么难了。比如：实体可修改，值对象不可修改，只可以整体替换。实体是实实在在的业务对象，值对象只是对对象的描述。值对象依附以实体，实体没了值对象也就没了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571734954,"ip_address":"","comment_id":143554,"utype":1}],"discussion_count":2,"race_medal":0,"score":"35931468426","product_id":100037301,"comment_content":"实体和值对象，就是把业务拆分，拆分再拆分。直到能够通过“对象”表达某一时刻的业务。实体就是业务中，不可再分割的对象。值对象是对实体的补充。举例：比如网购。商品最重要。商品就是实体，商品的状态比如下单，物流中。只是商品的状态，没那么重要的就是值对象。看到后面才发现，值对象和实体的定义是那么的难！","like_count":8,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471591,"discussion_content":"抓住几个关键点就不那么难了。比如：实体可修改，值对象不可修改，只可以整体替换。实体是实实在在的业务对象，值对象只是对对象的描述。值对象依附以实体，实体没了值对象也就没了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571734954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2693038,"avatar":"https://static001.geekbang.org/account/avatar/00/29/17/ae/f365efb0.jpg","nickname":"Quentin J.","note":"","ucode":"50B980CBE6EBA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384286,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626486947,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145652,"user_name":"寻","can_delete":false,"product_type":"c1","uid":1147468,"ip_address":"","ucode":"4A79D34088BD10","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/4c/0134a7bd.jpg","comment_is_top":false,"comment_ctime":1572336993,"is_pvip":false,"replies":[{"id":"56230","content":"一看就是过来人哈。<br>DDD首先你需要理解它，然后结合自己现状，不断优化并总结出适合自己的DDD设计方法和过程。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572339325,"ip_address":"","comment_id":145652,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31637108065","product_id":100037301,"comment_content":"这一章值得深挖的内容很多。<br>首先，传统的系统设计阶段，更多的是受采用MIS(管理信息系统)学科的影响，在系统设计阶段完成逻辑模型(E-R图)-&gt;物理模型(建表)的设计，在系统开发阶段完成具体的编码工作，这个阶段需要完成一个&quot;数据库模型&quot;-&gt;&quot;面向对象&quot;模型的转换，这是一个不小的成本。而在实践中，很多项目甚至弱化了面下对象设计，通过各类开发框架又走回了&quot;结构化的编程&quot;的老路，丧失了面向对象设计思想带来的优秀特性，代码再次变得冗余和高耦合。<br>反过来，我们看DDD方法，系统设计阶段的产出物-领域模型可以近乎无缝的过渡到系统开发阶段(编码阶段)，再配合上时下流行的Spring-Data-JPA，给研发效率带来了可观的提升。<br>以上是我司在DDD实践当中的一些感悟，当然DDD的实践还有很多路要走，也有很多坑要踩...","like_count":7,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472510,"discussion_content":"一看就是过来人哈。\nDDD首先你需要理解它，然后结合自己现状，不断优化并总结出适合自己的DDD设计方法和过程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572339325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143477,"user_name":"。","can_delete":false,"product_type":"c1","uid":1222200,"ip_address":"","ucode":"75B163F01F20F3","user_header":"https://static001.geekbang.org/account/avatar/00/12/a6/38/55483b8c.jpg","comment_is_top":false,"comment_ctime":1571714808,"is_pvip":false,"replies":[{"id":"55401","content":"哈哈，出发点不一样，所以观点会有差异。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571722296,"ip_address":"","comment_id":143477,"utype":1}],"discussion_count":2,"race_medal":0,"score":"31636485880","product_id":100037301,"comment_content":"学到了和以前设计不一样的地方。DDD弱化了数据库设计，减少了表之间的关联关系，将不用来查询的静态值设计为值对象，作为一个字段存储到实体对应的表中。减少了数据库设计的复杂度，避免了复杂的关联。<br>教数据库的老师估计想打人了😂","like_count":7,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471556,"discussion_content":"哈哈，出发点不一样，所以观点会有差异。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571722296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2033476,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/07/44/1df0e4cd.jpg","nickname":"平平淡淡财是真","note":"","ucode":"BC23C8A194DDA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307993,"discussion_content":"我认为都是从业务角度出发的，如果需要频繁查询或修改，就需要设计为实体对象，否则可以考虑设计为值对象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600823596,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214907,"user_name":"Geek_ed5fc0","can_delete":false,"product_type":"c1","uid":1748839,"ip_address":"","ucode":"95F9951F311498","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/yw1NVAA4vAB1sichmJwLFfEGvGW1vv0XrdFOEx9I7f9xibicHgqb64TiapRdq3lYz16hMTUJ8lrKnEWKyqqPaib7lWw/132","comment_is_top":false,"comment_ctime":1588846170,"is_pvip":false,"replies":[{"id":"80281","content":"是的。<br>当实体引用单一属性值对象或单条记录多属性值对象时，可以采用属性嵌入方式嵌入实体表。当实体引用单条或多条记录的多属性值对象时，可以采用序列化大对象方式嵌入实体表。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1589425010,"ip_address":"","comment_id":214907,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27358649946","product_id":100037301,"comment_content":"请教老师，属性嵌入设计表是什么意思，就是把address实体序列化成一个json串，作为user表的一个单独字符串（比如varchar）属性吗","like_count":6,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494240,"discussion_content":"是的。\n当实体引用单一属性值对象或单条记录多属性值对象时，可以采用属性嵌入方式嵌入实体表。当实体引用单条或多条记录的多属性值对象时，可以采用序列化大对象方式嵌入实体表。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589425010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142958,"user_name":"huaweichen","can_delete":false,"product_type":"c1","uid":1249907,"ip_address":"","ucode":"974917DE2AE92E","user_header":"https://static001.geekbang.org/account/avatar/00/13/12/73/2183839d.jpg","comment_is_top":false,"comment_ctime":1571612200,"is_pvip":false,"replies":[{"id":"55247","content":"会有的，包括事件风暴、从中台的领域建模、到微服务设计都会有案例的，最后会有一个典型案例把这些知识串起来。不过这些案例主要是设计为主，会设计出不同分层的类、服务等，不到具体的代码实现。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571620488,"ip_address":"","comment_id":142958,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27341415976","product_id":100037301,"comment_content":"请问老师，本课程的后面章节，会有关于如何落实DDD的开发实战案例吗？","like_count":6,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471339,"discussion_content":"会有的，包括事件风暴、从中台的领域建模、到微服务设计都会有案例的，最后会有一个典型案例把这些知识串起来。不过这些案例主要是设计为主，会设计出不同分层的类、服务等，不到具体的代码实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571620488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":303774,"user_name":"春宇","can_delete":false,"product_type":"c1","uid":1056589,"ip_address":"","ucode":"F2035A5DC9302E","user_header":"https://static001.geekbang.org/account/avatar/00/10/1f/4d/c240e114.jpg","comment_is_top":false,"comment_ctime":1626998231,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23101834711","product_id":100037301,"comment_content":"地址是可以深度利用的信息，这种方式的设计虽然为了一点点复杂性降低，完全用户感知不到，就把地址挪到用户里面去设计。。。。说实话，非常的。。。蠢","like_count":5},{"had_liked":false,"id":284955,"user_name":"Romber","can_delete":false,"product_type":"c1","uid":1205508,"ip_address":"","ucode":"3FB24B736FF7E3","user_header":"https://static001.geekbang.org/account/avatar/00/12/65/04/fea2dcf9.jpg","comment_is_top":false,"comment_ctime":1616559859,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"23091396339","product_id":100037301,"comment_content":"想重点说下值对象的缺点:<br>1. 值对象作为整体嵌入到数据库表中的某一个字段后, 当里面的信息发生变化时(比如人员值对象的人名信息发生变化), 需要修改所有用到人员信息的实体的数据, 哪怕用了领域事件, 负责维护人员实体的聚合发送了领域事件, 其他聚合拿到了变化的消息, 那又怎么样? 假设表中数据上亿, 如何修改? 都不知道该修改哪一条, 用正则表达式吗? 且不说会不会改错, 光那性能问题就够喝一壶的了<br>2. 如果采用平铺模式, 则可能会让表变的很宽, 几十个字段的宽表, 冗余了很多信息, 经常要做DDL, 大表的DDL真的很烦...<br>3. 冗余了那么多信息, OLTP数据库通常为行存数据库, 每次查询要查那么多数据, 而且还不一定有用, 浪费IO, 带宽...<br>4. 业务一直在变, 昨天还是不变的内容, 今天就要能改了, 比如收货地址, 现在像JD这样平台在下完单后是可以修改收货地址的, 序列化一堆值到一个字段以后, 现在要修改, 怎么办? 到时候再独立成一个实体, 就要搬数据, 搬数据那真是风险最高的事情之一了...<br>5. 值对象是看起来很美, 实际上很难一直维持其定义的一个东西, 他只是要求不能修改, 但他不管现实生活中其实没什么是不能改的, 能不能改还不是产品经理一句话的事, 嵌入到一个表里, 其实是在埋坑, 哪天产品改主意了, 那就哭去吧<br>6. 值对象在属性数量较少, 确定不会变的属性集合上才有意义, 但这真的很局限<br>7. 考虑到值对象的各种现存以及潜在风险, 是不是可以考虑把值对象单独建表, 分配主键, 在实体表里保存对应主键值, 通过关联来查询和修改数据, 在DO里也保存值对象的主键值, 不过不暴露值对象的主键值, 开放值对象属性查询接口, 实现按需查询数据库的目的, 同时不开放值对象表的修改接口, 维护值对象的不变性, 等到业务需求发生了变化, 到时把值对象单独建模为一个实体也是很方便的, 因为数据在那, 怎么改都方便, 只是这么做的话感觉不够DDD, 但是更灵活<br>8. 最后说句题外话, 说是要关注领域建模, 不那么关注数据建模, 说起来容易做起来难, 这不是思维无法转变的问题, 而是现实情况的问题, 数据最终要落地到数据库里, 怎么可能不考虑? 以大型业务来讲, 应用服务作为无状态服务, 扩容起来很简单, K8S多部署几个POD就可以了, 这套技术很成熟, 但是数据库是很难扩展的, 代价比较大, 所以一定要考虑数据库设计的, 不仅要考虑, 还要非常重视, 否则一个不小心把数据库搞挂了, 今年的C你背一下吧...<br><br>不知是否可行?","like_count":5,"discussions":[{"author":{"id":1945739,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/b0/8b/fa22d45c.jpg","nickname":"daxin","note":"","ucode":"70D3DE3720DC9A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587791,"discussion_content":"交易级别的值对象和其他实体级别的值对象并不一定一致 也不一定要同步 这时设计冗余就是快照 是必要的 当然也还是要看业务场景 比如值对象上存在大数据量的频繁查询 这要分别来看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663295301,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"新加坡"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1966534,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/01/c6/b131de98.jpg","nickname":"Newball","note":"","ucode":"933FE3FD50BD1E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394720,"discussion_content":"你应该没理解透彻，就拿第4点来说：对于订单，地址是它的值对象，可以，那就直接修改，像京东和淘宝都支持，但这个临时操作不会影响到本身保存的地址，当然如果要影响到也可以，用事物保证同时更改。因为对于信息部门来说，地址本身也是一个实体。所以实体和值对象是基于领域而言的，没有通用的绝对。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632017188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2693038,"avatar":"https://static001.geekbang.org/account/avatar/00/29/17/ae/f365efb0.jpg","nickname":"Quentin J.","note":"","ucode":"50B980CBE6EBA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384326,"discussion_content":"关注","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626496993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176898,"user_name":"水如天","can_delete":false,"product_type":"c1","uid":1069822,"ip_address":"","ucode":"50AE29168947CD","user_header":"https://static001.geekbang.org/account/avatar/00/10/52/fe/1241bc83.jpg","comment_is_top":false,"comment_ctime":1581218419,"is_pvip":false,"replies":[{"id":"68991","content":"这样的操作需要在引用值对象的实体建立版本记录，每次修改需要留下这个实体的版本信息。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1581493743,"ip_address":"","comment_id":176898,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23056054899","product_id":100037301,"comment_content":"老师好，请教下，如果我们需要记录每次值对象的修改记录，并且进行比较。比如，Address这个属性，修改了三次，比较三次地址是如何修改的，这时候adress如何设计呢？","like_count":5,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483241,"discussion_content":"这样的操作需要在引用值对象的实体建立版本记录，每次修改需要留下这个实体的版本信息。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581493743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":264926,"user_name":"🌙 飙","can_delete":false,"product_type":"c1","uid":2139137,"ip_address":"","ucode":"169C32DB7AA62C","user_header":"https://static001.geekbang.org/account/avatar/00/20/a4/01/8c3602fb.jpg","comment_is_top":false,"comment_ctime":1606708491,"is_pvip":false,"replies":[{"id":"96163","content":"收货地址不会有三个的情况吧，快递员到底送到哪个地址？如果有一定要有三个地址，那也应该设计三个地址字段，每个字段分别存储不同的地址数据，每个地址的修改，采用整体替换的方式。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1606718615,"ip_address":"","comment_id":264926,"utype":1}],"discussion_count":9,"race_medal":0,"score":"18786577675","product_id":100037301,"comment_content":"有个问题想请教一下，如果把用户的收货地址设计成值对象，以json的格式保存于用户的实体中，假如这个用户有三个收货地址，我要修改其中的地址A，那是要怎么实现呢，（我想到的是，三个都拿出来 ，修改完其中的一个，再整体存回去），这个设计是否不太适用我这个业务场景呢","like_count":4,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510741,"discussion_content":"收货地址不会有三个的情况吧，快递员到底送到哪个地址？如果有一定要有三个地址，那也应该设计三个地址字段，每个字段分别存储不同的地址数据，每个地址的修改，采用整体替换的方式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606718615,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":8,"child_discussions":[{"author":{"id":1253652,"avatar":"https://static001.geekbang.org/account/avatar/00/13/21/14/423a821f.jpg","nickname":"Steven","note":"","ucode":"3FE64459842015","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":536118,"discussion_content":"这里没理解，三个地址字段的话，如果要修改成四个地址，那不是要再加一个字段了？\n是否直接存JSON数组呢？ 或者真的要添加一个表了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638695335,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":510741,"ip_address":""},"score":536118,"extra":""},{"author":{"id":1512642,"avatar":"https://static001.geekbang.org/account/avatar/00/17/14/c2/46ebe3a0.jpg","nickname":"侧耳倾听","note":"","ucode":"5BF2A2440B54F0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1253652,"avatar":"https://static001.geekbang.org/account/avatar/00/13/21/14/423a821f.jpg","nickname":"Steven","note":"","ucode":"3FE64459842015","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555519,"discussion_content":"你可以通过别的方法规避这个问题，收货地址列表你可以用缓存保存，而默认收货地址可以嵌入到实体中，以后修改默认地址就更新实体，增删改地址列表就更新缓存数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646957691,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":536118,"ip_address":""},"score":555519,"extra":""},{"author":{"id":1656848,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/fy2rpUzbSEeIAQHfbt0EkYkMIIuEPhWO6GFkjJNmLy5gbRp2UnNlrLh1fAAU52bQKfiahl17ZTOjhbYiatmrNibDg/132","nickname":"杨小曹","note":"","ucode":"D266D0A11BC573","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1512642,"avatar":"https://static001.geekbang.org/account/avatar/00/17/14/c2/46ebe3a0.jpg","nickname":"侧耳倾听","note":"","ucode":"5BF2A2440B54F0","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":561407,"discussion_content":"这里假设真的存在一个实体下，值对象是个列表的情况，并且会对其中一行数据进行修改，且得持久化，这种情况怎么实现呢？因为我看值对象都是整体替换，那是不是就不能修改单行记录？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649636675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":555519,"ip_address":""},"score":561407,"extra":""}]}]},{"had_liked":false,"id":169741,"user_name":"陈四丰","can_delete":false,"product_type":"c1","uid":1610789,"ip_address":"","ucode":"A4463BFD52FB4F","user_header":"https://static001.geekbang.org/account/avatar/00/18/94/25/3bf277e5.jpg","comment_is_top":false,"comment_ctime":1578434158,"is_pvip":true,"replies":[{"id":"65860","content":"不同聚合的就分开建吧。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1578435823,"ip_address":"","comment_id":169741,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18758303342","product_id":100037301,"comment_content":"请教欧老师：<br><br>如果不同聚合(A1, A2)内的实体(E1, E2)都包含一个值对象(Value Object)，该如何处理这个值对象呢？<br>1， 分别放入E1，E2的各自实体中，会造成代码重复。<br>2，如果共用，就会增加耦合度。<br><br>比如：人(实体)和动物(实体)，都有四肢(值对象)。<br><br>多谢指点！！！","like_count":4,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480702,"discussion_content":"不同聚合的就分开建吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578435823,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1750703,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/b6/af/9347b9ac.jpg","nickname":"Liam","note":"","ucode":"EC9DAD04D8B6CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":323098,"discussion_content":"分开比较好，因为同样的四肢，人会用前肢写字，用下肢弹跳。而大部分动物都不会是用前肢！这里值对象的使用会相差很大！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604886017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":279759,"user_name":"CHEN川","can_delete":false,"product_type":"c1","uid":1001694,"ip_address":"","ucode":"4B4D11141A68B9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/de/d9a88304.jpg","comment_is_top":false,"comment_ctime":1613958220,"is_pvip":false,"replies":[{"id":"101648","content":"是的，在领域建模时主要考虑领域模型，基本不考虑技术实现方案层级的设计。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1613983727,"ip_address":"","comment_id":279759,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14498860108","product_id":100037301,"comment_content":"实体和值对象最主要的目的是简化设计和沟通，而如果在前期的设计过程中，脑袋中一直想的是实体和值对象的数据库形态的话，未免有点本末倒置了，特别是如果因为数据库表的问题而影响到前期设计的话，更是得不偿失了。<br><br>在考虑持久化的问题时，不要把自己的思维仅局限在MySQL等关系型数据库，如果业务不需要保证强事务的话，MongoDB等NoSQL数据库可能更能满足你的需求。","like_count":3,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515861,"discussion_content":"是的，在领域建模时主要考虑领域模型，基本不考虑技术实现方案层级的设计。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613983727,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":210703,"user_name":"峰","can_delete":false,"product_type":"c1","uid":1390326,"ip_address":"","ucode":"527BB65559F0B0","user_header":"https://static001.geekbang.org/account/avatar/00/15/36/f6/d65b7302.jpg","comment_is_top":false,"comment_ctime":1587811771,"is_pvip":false,"replies":[{"id":"78772","content":"多个list也是可以打成json串存储在实体PO对象的值对象的属性里面的。如果不涉及复杂查询的话，这种方法也不失为一种好的方法，可以简化数据库的设计。<br>如果实在太多或需要对它进行统计或者查询，设计成实体也是可以的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1588044610,"ip_address":"","comment_id":210703,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14472713659","product_id":100037301,"comment_content":"请问老师，我在多个地方看到，尽量避免LIST&lt;值对象&gt; 这样的方式存在，但有时一个实体的某个属性就是多个值对象LIST的时候咋整呢？","like_count":3,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493089,"discussion_content":"多个list也是可以打成json串存储在实体PO对象的值对象的属性里面的。如果不涉及复杂查询的话，这种方法也不失为一种好的方法，可以简化数据库的设计。\n如果实在太多或需要对它进行统计或者查询，设计成实体也是可以的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588044610,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163621,"user_name":"james.d","can_delete":false,"product_type":"c1","uid":1087225,"ip_address":"","ucode":"CEE241856AF3B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/96/f9/3f976c91.jpg","comment_is_top":false,"comment_ctime":1576756582,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14461658470","product_id":100037301,"comment_content":"要正确理解值对象，需要抛开数据库建模思维，很少有人能把这块讲清楚。","like_count":3,"discussions":[{"author":{"id":1790355,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/51/93/1d067bed.jpg","nickname":"sugar椰子皮尤","note":"","ucode":"DCD580401F1BE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537652,"discussion_content":"值对象是领域概念\n仓储存储时同数据库打交道，数据库怎么合理存储怎样来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639129361,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325528,"user_name":"徐李","can_delete":false,"product_type":"c1","uid":1213325,"ip_address":"","ucode":"41550F6CA1E112","user_header":"https://static001.geekbang.org/account/avatar/00/12/83/8d/03cac826.jpg","comment_is_top":false,"comment_ctime":1639016596,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10228951188","product_id":100037301,"comment_content":"我们目前的设计主要是数据库表设计，就是对一个实体，现实中有对应关系，物理上的，不是逻辑上的关系，从数据库设计角度出发，就是一对多，或多对多，多对一，简单明了。这个DDD所倡导的像是，反其道而行之，是从领域角度，或是业务角度，区分出实体和 值对象，实体还是以前的那个实体，但是值对象的设计主要是一些属性的集合，也是考虑到之前一对多的情况，会出现关联表爆炸而引入的。我的理解是：这样后者就是实体对应一张表，所有值对象，就通过一个json，或者字段形式都展示在 这个实体这一张表中。看上去是表减少了，但是他的不足也显而易见，易读性不好，过滤筛查也不好，也是看应用场景。就我个人而言，总是感觉，这种场景应该很少吧，还是说我遇到的这种业务场景不多。","like_count":2},{"had_liked":false,"id":315233,"user_name":"俯瞰风景.","can_delete":false,"product_type":"c1","uid":1044166,"ip_address":"","ucode":"A6DB68B7B84AEE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/c6/bebcbcf0.jpg","comment_is_top":false,"comment_ctime":1633760669,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10223695261","product_id":100037301,"comment_content":"把领域拆分为子域，每个子域在界限上下文内有自己的通用语言，根据业务类型可以把子域划分为核心域、通用域、支撑域。每个子域可以抽象为一个实体，而在值对象可以做为实体的一个属性。实体是经常变动的业务抽象，而值对象一般用于存储不经常变的，整存整取的一组数据。","like_count":2},{"had_liked":false,"id":301626,"user_name":"e^x","can_delete":false,"product_type":"c1","uid":1054108,"ip_address":"","ucode":"29B56E0DF4EF48","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/9c/310c902c.jpg","comment_is_top":false,"comment_ctime":1625791850,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10215726442","product_id":100037301,"comment_content":"领域建模，是用来解决问题的，而问题空间本质上是对业务的一个关注点。所以，对业务的关注点不同，问题就不同，领域建模也会不同。<br>类似的，实体和值对象的区别，本质上也是因为关注点不同。实体和值对象在数据模型上可能都有id，都可以有行为能力和业务逻辑。因为关注点不同，我们关心实体的唯一性，关注它的行为和业务逻辑。而对于值对象，我们只关注它的属性描述，也因此忽略了它的唯一性、行为和业务逻辑。所以，划分实体和值对象，应该从关注点入手，而不是从它本身的语义上去划分。也正因为如此，实体和值对象才是会因为场景不同可以变换的。<br>关于数据表设计绑架领域模型的问题。我觉得数据模型和领域模型应该解耦。领域模型有自己的设计原则，数据表有自己的范式，理论上两者可能差别很大，也许我们可以尊重两者自己的个性，不必强求两者保持一致。比如：领域模型的实体我们用DO表示，数据表对应的对象我们用EO表示，DO可以按照DDD的实体设计包含任意他需要的属性、行为和业务逻辑，EO可以遵循标准的数据表设计范式，只是DO和EO之间有个映射和转换关系。","like_count":2},{"had_liked":false,"id":298355,"user_name":"静静聆听","can_delete":false,"product_type":"c1","uid":1263932,"ip_address":"","ucode":"0A8600CB928EFE","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/3c/5d54c510.jpg","comment_is_top":false,"comment_ctime":1624036458,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10213971050","product_id":100037301,"comment_content":"其实数据库设计，要怎么做，与领域无关，优先设计成值对象也不是最优选，数据库原来怎么做，现在还怎么做最好，领域还是不该管数据库怎么设计","like_count":2,"discussions":[{"author":{"id":1945739,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/b0/8b/fa22d45c.jpg","nickname":"daxin","note":"","ucode":"70D3DE3720DC9A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587792,"discussion_content":"如果不管 怎么提高领域模型的可演进和可维护？复杂系统和快速迭代的需求造成越来越多的非结构化数据 按部就班的数据模型设计才是不作不死","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663295781,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"新加坡"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":278242,"user_name":"ssssss","can_delete":false,"product_type":"c1","uid":2269158,"ip_address":"","ucode":"15EA94C3FBFC21","user_header":"https://static001.geekbang.org/account/avatar/00/22/9f/e6/6efc45cb.jpg","comment_is_top":false,"comment_ctime":1612841813,"is_pvip":false,"replies":[{"id":"101141","content":"需要根据业务场景来分析，有的场景设计为值对象，可以通过数据冗余的方式，简化数据库设计，降低领域模型和微服务之间的耦合。一般都建议优先设计为值对象，值对象主要关注数值，读的场景相对比较多。而实体，尤其是聚合根，会重点关注它的CRUD等生命周期管理，生命周期管理一般都在一个聚合中完成，这样可以保证单一职责。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1612958306,"ip_address":"","comment_id":278242,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10202776405","product_id":100037301,"comment_content":"不同的地方，实体也可能成为值对象。那直接数据库都设计为实体对象，在业务层不同的业务场景，赋予不同的概念行不？","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515323,"discussion_content":"需要根据业务场景来分析，有的场景设计为值对象，可以通过数据冗余的方式，简化数据库设计，降低领域模型和微服务之间的耦合。一般都建议优先设计为值对象，值对象主要关注数值，读的场景相对比较多。而实体，尤其是聚合根，会重点关注它的CRUD等生命周期管理，生命周期管理一般都在一个聚合中完成，这样可以保证单一职责。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612958306,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":275430,"user_name":"宙斯","can_delete":false,"product_type":"c1","uid":2041396,"ip_address":"","ucode":"80DF36BAD298AD","user_header":"https://static001.geekbang.org/account/avatar/00/1f/26/34/891dd45b.jpg","comment_is_top":false,"comment_ctime":1611538468,"is_pvip":true,"replies":[{"id":"101043","content":"是的，如果这些数据需要大量查询的话就会有性能问题。不过，我们可以通过CQRS读写分离的模式来设计。读写分别在不同的微服务中，通过事件将写的数据同步到读模型中。这样，在写数据模型中可以设计一个地址字段，以简化数据库表设计，而在读领域模型中，地址属性会展开设计成多个字段的表，对外提供查询服务。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1612853182,"ip_address":"","comment_id":275430,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10201473060","product_id":100037301,"comment_content":"领域地址序列化放在用户某个属性里都没什么，但数据表也这样设计不是一个好方式，数据库设计还要考虑性能问题。","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514339,"discussion_content":"是的，如果这些数据需要大量查询的话就会有性能问题。不过，我们可以通过CQRS读写分离的模式来设计。读写分别在不同的微服务中，通过事件将写的数据同步到读模型中。这样，在写数据模型中可以设计一个地址字段，以简化数据库表设计，而在读领域模型中，地址属性会展开设计成多个字段的表，对外提供查询服务。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612853182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":272451,"user_name":"翠堂","can_delete":false,"product_type":"c1","uid":2401024,"ip_address":"","ucode":"B6C388FACE26DF","user_header":"https://static001.geekbang.org/account/avatar/00/24/a3/00/e0dff4c2.jpg","comment_is_top":false,"comment_ctime":1610092948,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10200027540","product_id":100037301,"comment_content":"对表设计来说，一行记录是实体，一个字段是值对象","like_count":2},{"had_liked":false,"id":250059,"user_name":"天信","can_delete":false,"product_type":"c1","uid":1232463,"ip_address":"","ucode":"4961959C9F19E9","user_header":"https://static001.geekbang.org/account/avatar/00/12/ce/4f/6afbb99a.jpg","comment_is_top":false,"comment_ctime":1600916712,"is_pvip":false,"replies":[{"id":"91626","content":"同一个聚合内当然可以有多个实体，在DO对象之间通过对象引用，在PO对象之间通过ID建立数据之间的关联。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1600933388,"ip_address":"","comment_id":250059,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10190851304","product_id":100037301,"comment_content":"老师，你好。我提一个问题：同一个聚合下面，是否可以有多个实体，如果有多个实体，他们之间的引用是通过 ID 还是 Object ","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506121,"discussion_content":"同一个聚合内当然可以有多个实体，在DO对象之间通过对象引用，在PO对象之间通过ID建立数据之间的关联。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600933388,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188023,"avatar":"https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg","nickname":"Eternal","note":"","ucode":"EA6FE7CC98F740","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352262,"discussion_content":"在PO对象之间通过ID建立数据之间的关联？这个怎么理解呢？能否举个例子，谢谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614666799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218107,"user_name":"日月星辰","can_delete":false,"product_type":"c1","uid":1796332,"ip_address":"","ucode":"4E9F48153B2D8B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/68/ec/eb0ebbb6.jpg","comment_is_top":false,"comment_ctime":1589716307,"is_pvip":false,"replies":[{"id":"80699","content":"以下是值对象的优势和局限性。<br>值对象的不可变性，从而确保了值对象永远都是正确的，在并发环境下不会被意外修改。所以在它同时可以被多个实体引用时，实现重用和共享，从而提高系统性能。<br>值对象采用序列化大对象的方法简化了数据库设计，减少了实体表的数量，可以简单、清晰地表达业务概念。这种设计方式虽然降低了数据库设计的复杂度，但却无法满足基于值对象的快速查询和统计分析，会导致搜索值对象属性值时变得异常困难。<br>值对象采用属性嵌入的方法虽然提升了数据库的性能，但如果实体引用的值对象过多，则会在实体堆积一堆缺乏概念完整性的属性，这样值对象就会失去业务涵义，操作起来也不方便。<br>值对象其实还有一个重要的使用场景，就是生成数据快照，还原业务发生那一时刻的数据场景，以冗余的方式记录业务前后序聚合的数据。比如订单在下单时会记录生成订单那一刻的商品和收货地址等信息，我们称之为跟单数据。这时商品和收货地址是以值对象的形式存在的，它们被订单实体引用。这种值对象的设计方式与通过商品ID或地址ID关联的方式不同，当商品和地址的源端数据聚合的商品实体或地址实体数据被修改后，也不会影响订单实体中商品和收货地址值对象的快照数据。<br>鉴于值对象比实体更轻量级，高性能且线程安全，所以一般建议将领域对象优先设计为值对象，而非实体。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1589763883,"ip_address":"","comment_id":218107,"utype":1}],"discussion_count":6,"race_medal":0,"score":"10179650899","product_id":100037301,"comment_content":"感觉就是实体有主键ID，值对象没有。引入值对象的概念就只是方便沟通吗？","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495354,"discussion_content":"以下是值对象的优势和局限性。\n值对象的不可变性，从而确保了值对象永远都是正确的，在并发环境下不会被意外修改。所以在它同时可以被多个实体引用时，实现重用和共享，从而提高系统性能。\n值对象采用序列化大对象的方法简化了数据库设计，减少了实体表的数量，可以简单、清晰地表达业务概念。这种设计方式虽然降低了数据库设计的复杂度，但却无法满足基于值对象的快速查询和统计分析，会导致搜索值对象属性值时变得异常困难。\n值对象采用属性嵌入的方法虽然提升了数据库的性能，但如果实体引用的值对象过多，则会在实体堆积一堆缺乏概念完整性的属性，这样值对象就会失去业务涵义，操作起来也不方便。\n值对象其实还有一个重要的使用场景，就是生成数据快照，还原业务发生那一时刻的数据场景，以冗余的方式记录业务前后序聚合的数据。比如订单在下单时会记录生成订单那一刻的商品和收货地址等信息，我们称之为跟单数据。这时商品和收货地址是以值对象的形式存在的，它们被订单实体引用。这种值对象的设计方式与通过商品ID或地址ID关联的方式不同，当商品和地址的源端数据聚合的商品实体或地址实体数据被修改后，也不会影响订单实体中商品和收货地址值对象的快照数据。\n鉴于值对象比实体更轻量级，高性能且线程安全，所以一般建议将领域对象优先设计为值对象，而非实体。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589763883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301151,"discussion_content":"现在有些数据库也支持json串的属性了，不知道性能怎么样。如果你采用读写分离的方式，将大量的查询从领域模型中剥离，将值对象从数据模型中独立成单独的属性，然后进行查询，也可以避免值对象的劣势。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598425924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1731178,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/6a/6a/951f6a7b.jpg","nickname":"李婷婷","note":"","ucode":"813CF14454C9C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":305014,"discussion_content":"对您说的值对象具有不可变性不理解。我的理解是，当人员的地址发生改变了，那么这个值对象不就也发生改变了吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599739344,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301151,"ip_address":""},"score":305014,"extra":""},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1731178,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/6a/6a/951f6a7b.jpg","nickname":"李婷婷","note":"","ucode":"813CF14454C9C8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305185,"discussion_content":"这个不可变是指的不可局部变，比如地址如果作为值对象，它包括省地市若干子属性，我们可以对地址的数据整体替换，但不可以单独修改地址里面的属性，比如单独修改省。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599810942,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":305014,"ip_address":""},"score":305185,"extra":""}]},{"author":{"id":1790355,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/51/93/1d067bed.jpg","nickname":"sugar椰子皮尤","note":"","ucode":"DCD580401F1BE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537650,"discussion_content":"个人觉得领域和数据可以分开；\n领域思考业务语义；\n数据思考存储、查询、性能\n（所以不一定要使用嵌入的方式；少量的配置可以使用嵌入，视场景而决定存储方案）\n\n另外尽量使用cqrs架构，event source当前还是比较难的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639129229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1796332,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/68/ec/eb0ebbb6.jpg","nickname":"日月星辰","note":"","ucode":"4E9F48153B2D8B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":268879,"discussion_content":"值对象的劣势有解决办法吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589847436,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217492,"user_name":"发条橙子 。","can_delete":false,"product_type":"c1","uid":1259218,"ip_address":"","ucode":"ED076F4534FFED","user_header":"https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg","comment_is_top":false,"comment_ctime":1589514212,"is_pvip":false,"replies":[{"id":"80664","content":"你说的这些DTO应该不在实体类里面吧。它们应该在用户接口层或者应用层（出现微服务之间调用的时候）。<br>用户接口层会有这些对象。<br>Assembler：实现DTO与DO领域对象之间的相互转换和数据交换。一般来说Assembler与DTO总是同时出现。<br>DTO：它是前端应用数据传输的载体，不实现任何业务逻辑。我们可以面向前端应用将DO对象转换为DTO，从而隐藏内部领域对象DO。也可以将DTO对象转换为应用服务所需要的DO对象。<br>Facade：封装应用服务，提供较粗粒度的调用接口。或者将用户请求委派给一个或多个应用服务进行处理。<br>","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1589724721,"ip_address":"","comment_id":217492,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10179448804","product_id":100037301,"comment_content":"老师 对于一个实体 譬如商品，他在代码模型中对应一个实体类， 但是实体类Item会存在 ItemDTO 、ItemTO 等 ，这些是属于一个实体 还是多个实体 ， 那DTO 和TO的转换 应该属于跨实体还是同个实体，是在领域服务中实现还是？ ","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495166,"discussion_content":"你说的这些DTO应该不在实体类里面吧。它们应该在用户接口层或者应用层（出现微服务之间调用的时候）。\n用户接口层会有这些对象。\nAssembler：实现DTO与DO领域对象之间的相互转换和数据交换。一般来说Assembler与DTO总是同时出现。\nDTO：它是前端应用数据传输的载体，不实现任何业务逻辑。我们可以面向前端应用将DO对象转换为DTO，从而隐藏内部领域对象DO。也可以将DTO对象转换为应用服务所需要的DO对象。\nFacade：封装应用服务，提供较粗粒度的调用接口。或者将用户请求委派给一个或多个应用服务进行处理。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589724721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143052,"user_name":"川杰","can_delete":false,"product_type":"c1","uid":1099750,"ip_address":"","ucode":"815211E1D698E6","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/e6/11f21cb4.jpg","comment_is_top":false,"comment_ctime":1571624458,"is_pvip":false,"replies":[{"id":"55278","content":"是否要设计成值对象，你要看这个对象是否后续还会来回修改，会不会有生命周期。如果不可修改，并且以后也不会专门针对它进行查询或者统计，你就可以把它设计成值对象，如果不行，那就设计成实体吧。<br>DDD强调领域模型而不是数据模型，所以在设计的时候不建议把数据模型放在很优先的位置，但是如果你的数据需要经常修改，还是把它设计为实体吧。很多值对象来源于上一个业务流程或者外部第三方的数据，它在上游或者第三方是一个关键实体，甚至是聚合根。但在下游或者其他微服务内它是不可以修改的，要修改也只能从上游或者第三方修改后做整体替换，它只是一个值，这类领域对象你是可以设计为值对象的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571628441,"ip_address":"","comment_id":143052,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10161559050","product_id":100037301,"comment_content":"老师，关于值对象的数据库形态，我有个疑问：以“Person”实体为例，假设这个实体包含多个值对象，地址，教育经历，工作经历等；那么在设计数据表的时候，难道把那么多值对象的属性全部都设计在一个表里么？如果是这样的话，一个Person表岂不是字段过长了？<br>我能想到的解决办法就是，根据界限上下文；不同界限上下文是很有可能关注同一个实体的，但是他们关注的这个实体的角度往往是不一样的；例如，HR部门关心的是员工的个人情况和工作情况，而薪酬部门则关注员工的薪资情况；所以，如果设计数据表的话，是否应当是：Person_HR，Person_Salary，但这又带来一个问题，即两张表又包含了同样的Person数据；<br>所以，最终比较合适的表设计结果我认为是：Person，HR，Salary，其中，HR和Salary根据PersonID关联；<br>综上，我的问题是，对于比较复杂的业务实体（如上面的例子），数据表设计，是否还是按照数据库范式去设计比较合适？","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471361,"discussion_content":"是否要设计成值对象，你要看这个对象是否后续还会来回修改，会不会有生命周期。如果不可修改，并且以后也不会专门针对它进行查询或者统计，你就可以把它设计成值对象，如果不行，那就设计成实体吧。\nDDD强调领域模型而不是数据模型，所以在设计的时候不建议把数据模型放在很优先的位置，但是如果你的数据需要经常修改，还是把它设计为实体吧。很多值对象来源于上一个业务流程或者外部第三方的数据，它在上游或者第三方是一个关键实体，甚至是聚合根。但在下游或者其他微服务内它是不可以修改的，要修改也只能从上游或者第三方修改后做整体替换，它只是一个值，这类领域对象你是可以设计为值对象的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571628441,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":318587,"user_name":"杨赛","can_delete":false,"product_type":"c1","uid":1029376,"ip_address":"","ucode":"E26AF8930F78E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b5/00/4093f39a.jpg","comment_is_top":false,"comment_ctime":1635341157,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5930308453","product_id":100037301,"comment_content":"只有谁相对谁是值对象，没有谁天生就是值对象。","like_count":1},{"had_liked":false,"id":306167,"user_name":"Geek_d3928c","can_delete":false,"product_type":"c1","uid":2450893,"ip_address":"","ucode":"7CB09FD1F7CB23","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/L8EpqHoAnmvkzCIsdOkv5QvhIzu5tMaF2FDusXShqukv5ZBkS8DbicWaErjnYydibiaqBrs70wQ8P6axvC2FbWpbQ/132","comment_is_top":false,"comment_ctime":1628414028,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5923381324","product_id":100037301,"comment_content":"我们团队的资金表中就有很多值对象，数据库表中大量的保留字段","like_count":1},{"had_liked":false,"id":286745,"user_name":"Keith","can_delete":false,"product_type":"c1","uid":1193337,"ip_address":"","ucode":"B40774090714D1","user_header":"https://static001.geekbang.org/account/avatar/00/12/35/79/21647da2.jpg","comment_is_top":false,"comment_ctime":1617546819,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5912514115","product_id":100037301,"comment_content":"&quot;1. 实体的业务形态&quot;中的&quot;操作和行为&quot;有什么区别?","like_count":1},{"had_liked":false,"id":256693,"user_name":"archerwong","can_delete":false,"product_type":"c1","uid":2223755,"ip_address":"","ucode":"B603E194520386","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKv92yhBU4EpUIeo4UgAQvsMGnu2S1XNxq2TyVWgw8n2ByDSm7JcqiaVibOTyr9sq2awZHq1dSYb2Vg/132","comment_is_top":false,"comment_ctime":1603709221,"is_pvip":false,"replies":[{"id":"93494","content":"如果将值对象存成另外的数据表，个人感觉也是可以的，这是它的数据存储形态，这时值对象的数据表必然要通过ID 与引用它的实体表进行关联。不过要注意，在进行聚合中领域对象数据初始化时，我们需要通过实体表获取值对象表所在的数据，然后将它初始化成值对象，并被DO实体引用，这时值对象在JVM运行环境中以值对象的形态存在，它只可整体替换。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1603780082,"ip_address":"","comment_id":256693,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5898676517","product_id":100037301,"comment_content":"老师好，我有个问题，值对象在数据库持久化方面简化了设计，它的数据库设计大多采用非数据库范式，值对象的属性值和实体对象的属性值保存在同一个数据库实体表中。值对象在数据库中可以单独有一张表，并且通过主键id关联的吗，比如冷热数据分别存储到主表和从表，并且从表数据是不更改的，符合值对象的特征","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508083,"discussion_content":"如果将值对象存成另外的数据表，个人感觉也是可以的，这是它的数据存储形态，这时值对象的数据表必然要通过ID 与引用它的实体表进行关联。不过要注意，在进行聚合中领域对象数据初始化时，我们需要通过实体表获取值对象表所在的数据，然后将它初始化成值对象，并被DO实体引用，这时值对象在JVM运行环境中以值对象的形态存在，它只可整体替换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603780082,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219606,"user_name":"vincentjia","can_delete":false,"product_type":"c1","uid":1005699,"ip_address":"","ucode":"EC26D23594600D","user_header":"","comment_is_top":false,"comment_ctime":1590050305,"is_pvip":false,"replies":[{"id":"81146","content":"继续哈，后面还有很多内容😄。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1590099246,"ip_address":"","comment_id":219606,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5885017601","product_id":100037301,"comment_content":"一直不甚理解的领域划分、微服务拆分的问题， 这个课程的前两课解释了我的疑惑。","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495872,"discussion_content":"继续哈，后面还有很多内容😄。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590099246,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208258,"user_name":"Kevin","can_delete":false,"product_type":"c1","uid":1886504,"ip_address":"","ucode":"05DB9F590A62B4","user_header":"https://static001.geekbang.org/account/avatar/00/1c/c9/28/54afaf0f.jpg","comment_is_top":false,"comment_ctime":1587309403,"is_pvip":false,"replies":[{"id":"78039","content":"要考虑的。比如如果采用json串嵌入方式，未来是否有大量查询或统计之类的操作等。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1587439091,"ip_address":"","comment_id":208258,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5882276699","product_id":100037301,"comment_content":"老师 请问领域建模是否考虑值对象的可扩展性呢？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492390,"discussion_content":"要考虑的。比如如果采用json串嵌入方式，未来是否有大量查询或统计之类的操作等。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587439091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187002,"user_name":"甲小蛙","can_delete":false,"product_type":"c1","uid":1475627,"ip_address":"","ucode":"B611FDDE514C9F","user_header":"https://static001.geekbang.org/account/avatar/00/16/84/2b/ba495eea.jpg","comment_is_top":false,"comment_ctime":1583986724,"is_pvip":false,"replies":[{"id":"72171","content":"其实放聚合根和领域服务里都可以的。我建议聚合根里只保留聚合根的逻辑，跨实体的放在领域服务内。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1584012794,"ip_address":"","comment_id":187002,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5878954020","product_id":100037301,"comment_content":"老师，有个问题，跨实体的逻辑通过领域服务来实现，那聚合内的多个实体逻辑是不是可以在聚合内实现？还是说也要放到领域服务中？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486953,"discussion_content":"其实放聚合根和领域服务里都可以的。我建议聚合根里只保留聚合根的逻辑，跨实体的放在领域服务内。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584012794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184753,"user_name":"探索无止境","can_delete":false,"product_type":"c1","uid":1044178,"ip_address":"","ucode":"91D2A9907DFA79","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/d2/7024431c.jpg","comment_is_top":false,"comment_ctime":1583396291,"is_pvip":false,"replies":[{"id":"71472","content":"确实有这个问题，DDD的名词挺多的，会导致理解起来比较麻烦。谢谢提醒。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1583461467,"ip_address":"","comment_id":184753,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5878363587","product_id":100037301,"comment_content":"其实整体讲解还是清晰的，就是文中各个部分的开头总是各种晦涩难懂的专业词汇，用专业词汇解释专业词汇，会让初学者望而却步，其实直接采用易理解的文字直接解读，学习成本更低一些","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486119,"discussion_content":"确实有这个问题，DDD的名词挺多的，会导致理解起来比较麻烦。谢谢提醒。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583461467,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170361,"user_name":"Geek_68f3a7","can_delete":false,"product_type":"c1","uid":1800978,"ip_address":"","ucode":"8B58B0B17CA482","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/ibL38XmkYED6ApNMfyXhCv7gHsPugET0XddYF7zZcGgL6ZicsDqGJCPbPPvsOtLmJd6y9b5xxE2PHgib2ZT2rGd8Q/132","comment_is_top":false,"comment_ctime":1578579386,"is_pvip":false,"replies":[{"id":"66070","content":"枚举类就是一个值对象。它一次只有一个值，而且是整体修改。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1578617503,"ip_address":"","comment_id":170361,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5873546682","product_id":100037301,"comment_content":"如果是记录状态的枚举类呢？他没有唯一标识不能做为实体，但是又不具备值对象的要求，因为他有可能会更改，这样的话应该如何设计？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480954,"discussion_content":"枚举类就是一个值对象。它一次只有一个值，而且是整体修改。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578617503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152128,"user_name":"Todd  BD","can_delete":false,"product_type":"c1","uid":1015267,"ip_address":"","ucode":"21F27169916949","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/e3/ad6a4758.jpg","comment_is_top":false,"comment_ctime":1573886993,"is_pvip":false,"replies":[{"id":"58503","content":"值对象的不可变是指的整体不可变，也就是说不能改值对象里的某一个属性，它要被整体对待。地址在订单里是可以修改的，但是它只能整体替换。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573906484,"ip_address":"","comment_id":152128,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5868854289","product_id":100037301,"comment_content":"关于用用户的Address举例值对象我不是很明白， 因为值对象是不可变的，但是事实上用户也需要修改Address， 这个不变性如何理解？ 是说从对象的角度， 只能以Address为粒度进行修改吗？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474722,"discussion_content":"值对象的不可变是指的整体不可变，也就是说不能改值对象里的某一个属性，它要被整体对待。地址在订单里是可以修改的，但是它只能整体替换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573906484,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1092620,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/FlZhhCvYy2mIkuQkXnbicniaNNDSibfFiaxdVf2U1q3H0pnVlfs9rKBfOoia62UWxS3I9QGyrzUgsfBDe1TkbWQPdmg/132","nickname":"isNewJavaPm","note":"","ucode":"DF6A8E23057CFF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299761,"discussion_content":"首先对于老师认真有态度的回复大部分问题点赞和敬佩。看了老师的前面的举例和一些问题的回复，都有提到：如订单的收货地址，在订单中是作为值对像存储。但是在用户中心，个人的收货地址是作为实体存在。有这么一个场景咨询老师的解惑：\n某订单在支付后，未发货前，用户通过客服希望修改该订单的收货地址，由A城市收货，改为B城市收货。这个场景下，订单的收货地址发生了变化。我理解是由订单的聚合服务来完成收货地址的变更。这个场景下：1、还是调用个人中心地址服务完成收货地址的新增，然后再引用到订单里。（也就是你说的整体替换）。2、还是直接在订单实体里面直接修改收货地址。如果直接修改。那这个收货地址，怎么理解为值对像？谢谢解惑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597809705,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152026,"user_name":"Todd  BD","can_delete":false,"product_type":"c1","uid":1015267,"ip_address":"","ucode":"21F27169916949","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/e3/ad6a4758.jpg","comment_is_top":false,"comment_ctime":1573840096,"is_pvip":false,"replies":[{"id":"58504","content":"实体有不同的形态，有数据库对象PO形态，有DO领域实体对象的形态，这个ID是你领域实体对象的ID。但是DO的这个ID可能会对应到数据库对象PO的ID。DO的这个ID在你定义实体的属性时候就确定了。<br>你比较的时候应该是比较的DO的ID，但是这个DO的ID可能是在PO转换成DO的时候，来源于PO的ID。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573906717,"ip_address":"","comment_id":152026,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5868807392","product_id":100037301,"comment_content":"“实体以 DO（领域对象）的形式存在，每个实体对象都有唯一的 ID”<br>想请教一下， 这个ID是指Entity的Identifier吗？ 还是数据库中的主键ID？<br>举个例子， 支付用的Payment Entity， 有业务上的Identifier， 就是Payment Number, 类似 XX-YY-ABC000001， 而Payment在数据库中对应的表中有id这个主键， 所以在Payment的这个DO中， 我用数据库的id来充当引用你那段话中的ID是否可以， 还是说需要使用Payment Number？<br>再比如我要对Entity定义equals方法， 我是比较数据库主键， 还是比较这个Payment Number？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474690,"discussion_content":"实体有不同的形态，有数据库对象PO形态，有DO领域实体对象的形态，这个ID是你领域实体对象的ID。但是DO的这个ID可能会对应到数据库对象PO的ID。DO的这个ID在你定义实体的属性时候就确定了。\n你比较的时候应该是比较的DO的ID，但是这个DO的ID可能是在PO转换成DO的时候，来源于PO的ID。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573906717,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1808666,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/99/1a/196ff5f8.jpg","nickname":"长空","note":"","ucode":"EFE7E08491849C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":145672,"discussion_content":"是数据库的ID还是其它的ID不重要，只要能标示DO的唯一性即可","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579574802,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145979,"user_name":"DullBird","can_delete":false,"product_type":"c1","uid":1110494,"ip_address":"","ucode":"80E2FD5F9687CB","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/de/3ebcbb3f.jpg","comment_is_top":false,"comment_ctime":1572411684,"is_pvip":false,"replies":[{"id":"56347","content":"按照你的描述，我理解是有人员和组织两个聚合。<br>人员和组织信息各自维护。但组织实体中会有一个字段保存部门主管信息，对吧？<br>在人员和组织聚合中，人员是实体，组织也是实体。<br>组织实体的部门主管信息来源于人员聚合，对吧?<br>这样的话，组织聚合中的组织实体的部门主管字段应该被设计为值对象。它可以被人员聚合中的其它人员整体替换。<br>不知道理解的对不对？<br>","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572419400,"ip_address":"","comment_id":145979,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5867378980","product_id":100037301,"comment_content":"有个问题想问一下:<br>一个组织管理的系统，一个人是部门的主管。<br>这个业务中，人是人员实体，部门是组织实体，那么人是部门的主管，<br>这个关系设计成实体还是值对象。<br>我认为修改这个关系，实质上是替换了关系，我认为是作为值对象，<br>但这个点一直没想太明白。<br>","like_count":1,"discussions":[{"author":{"id":2329181,"avatar":"https://static001.geekbang.org/account/avatar/00/23/8a/5d/9f146e48.jpg","nickname":"Monday","note":"","ucode":"33C597731B7AFA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408693,"discussion_content":"这样设计保证了聚合的高内聚啊，人员信息的修改只能再人员聚合中进行","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1635304257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1398824,"avatar":"https://static001.geekbang.org/account/avatar/00/15/58/28/c86340ca.jpg","nickname":"达文西","note":"","ucode":"01C1063F23D634","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":88337,"discussion_content":"按照老师的说法，如果人员聚合中的信息发生变化，是不是要通过事件通知组织服务进行值对象数据的修改呢？如果要，是不是引入了新的复杂度？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576696194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472652,"discussion_content":"按照你的描述，我理解是有人员和组织两个聚合。\n人员和组织信息各自维护。但组织实体中会有一个字段保存部门主管信息，对吧？\n在人员和组织聚合中，人员是实体，组织也是实体。\n组织实体的部门主管信息来源于人员聚合，对吧?\n这样的话，组织聚合中的组织实体的部门主管字段应该被设计为值对象。它可以被人员聚合中的其它人员整体替换。\n不知道理解的对不对？\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1572419400,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143360,"user_name":"夙梦流尘","can_delete":false,"product_type":"c1","uid":1477260,"ip_address":"","ucode":"D7E84D3B588BD6","user_header":"https://static001.geekbang.org/account/avatar/00/16/8a/8c/07dd8832.jpg","comment_is_top":false,"comment_ctime":1571676404,"is_pvip":false,"replies":[{"id":"55374","content":"聚合根与实体之间不一定是一致的，聚合根有数据后，但是引用的实体不一定会有数据。<br>但是值对象与实体之间生命周期是一致的，如果引用值对象的实体没有了，那这个值对象的生命周期也就结束了。<br>一个聚合里面只有一个聚合根。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571706443,"ip_address":"","comment_id":143360,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5866643700","product_id":100037301,"comment_content":"麻烦问个问题。聚合根和聚合根里面的实体的生命周期必须一致吗。可不可以 聚合根已经执行了一些业务动作后。聚合根里面的实体才初始化。如果不可以的话，是要把那个实体拿出来另外做一个聚合根吗","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471503,"discussion_content":"聚合根与实体之间不一定是一致的，聚合根有数据后，但是引用的实体不一定会有数据。\n但是值对象与实体之间生命周期是一致的，如果引用值对象的实体没有了，那这个值对象的生命周期也就结束了。\n一个聚合里面只有一个聚合根。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571706443,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2329181,"avatar":"https://static001.geekbang.org/account/avatar/00/23/8a/5d/9f146e48.jpg","nickname":"Monday","note":"","ucode":"33C597731B7AFA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408694,"discussion_content":"值对象不是没有生命周期的说法么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635304428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143082,"user_name":"心浮天空","can_delete":false,"product_type":"c1","uid":1051609,"ip_address":"","ucode":"3B2D0E6CC51EE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/0b/d9/3328dd12.jpg","comment_is_top":false,"comment_ctime":1571627731,"is_pvip":true,"replies":[{"id":"55290","content":"值对象是依附于实体的，是实体属性的一部分。它是实体的若干个属性的集合，为了概念完整性因此将具有一定业务含义的多个属性，组成一个属性集。<br>实体的业务功能非常丰富，是业务对象的基本单元，值对象生命周期依赖于实体的，实体没有了，值对象也就没有了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571637096,"ip_address":"","comment_id":143082,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5866595027","product_id":100037301,"comment_content":"值对象对实体而言的作用是什么？值对象的缺失是否会破坏实体的完整性？<br>实体对象一般会对应着单独的功能对其信息维护, 而值对象没有单独的维护功能, 其生命周期与实体的生命周期一致？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471380,"discussion_content":"值对象是依附于实体的，是实体属性的一部分。它是实体的若干个属性的集合，为了概念完整性因此将具有一定业务含义的多个属性，组成一个属性集。\n实体的业务功能非常丰富，是业务对象的基本单元，值对象生命周期依赖于实体的，实体没有了，值对象也就没有了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571637096,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359629,"user_name":"lanco","can_delete":false,"product_type":"c1","uid":1188352,"ip_address":"北京","ucode":"C24A0A8716C78C","user_header":"https://static001.geekbang.org/account/avatar/00/12/22/00/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1665715859,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1665715859","product_id":100037301,"comment_content":"值对象不可变指的是它当前的值不能变化还是它的属性描述不可变，例如那个地址值对象，是他地址信息不可变，还是说它的其中一个属性（省份）不可变呢","like_count":0},{"had_liked":false,"id":359591,"user_name":"🚦注意有车              ༽","can_delete":false,"product_type":"c1","uid":2113645,"ip_address":"江苏","ucode":"F638673227ECB1","user_header":"https://static001.geekbang.org/account/avatar/00/20/40/6d/61caf56b.jpg","comment_is_top":false,"comment_ctime":1665663457,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1665663457","product_id":100037301,"comment_content":"实体是一个有唯一标识的，而且是有业务逻辑处理的，满足实现领域业务的部分；值对象从属于实体，可以说是实体对象里面的一个属性，值对象本身是没有业务逻辑的，只有维护领域内各种属性值的定义；多个值对象可以组合成一个实体","like_count":0},{"had_liked":false,"id":354689,"user_name":"Geek_96e02d","can_delete":false,"product_type":"c1","uid":2891652,"ip_address":"四川","ucode":"0D403FF1798DFB","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIYOwDjibQ2uflhn2vicNeMI6TsC64nUseEJv2D2tiaDC7MgZNkqg16v1zHHJIR86iceMiaexXiaCxhV75w/132","comment_is_top":false,"comment_ctime":1660697815,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660697815","product_id":100037301,"comment_content":"没有听明白值对象建表时嵌入到主表中什么意思？  除了以JSON方式嵌入还有其他什么办法？","like_count":0},{"had_liked":false,"id":354618,"user_name":"Geek_783504","can_delete":false,"product_type":"c1","uid":2743789,"ip_address":"四川","ucode":"549D3F0549743C","user_header":"https://static001.geekbang.org/account/avatar/00/29/dd/ed/f6c5432b.jpg","comment_is_top":false,"comment_ctime":1660616673,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1660616673","product_id":100037301,"comment_content":"通用符（比如：实体类ID），值对象会依附实体","like_count":0},{"had_liked":false,"id":351692,"user_name":"Geek_bdf27e","can_delete":false,"product_type":"c1","uid":1883022,"ip_address":"","ucode":"09837D6BD4DD35","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eosE8ic8Ky1HrTaD5mq0tq4DZH4er7zmAUwLd9yy2cUO9n0bddb3bqiat9ea3XzAicHqdp781ibtbAtlw/132","comment_is_top":false,"comment_ctime":1658107942,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658107942","product_id":100037301,"comment_content":"老师，值对象是不是会造成贫血失意证","like_count":0},{"had_liked":false,"id":351256,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1657639663,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1657639663","product_id":100037301,"comment_content":"实体是一个有唯一标识且有独立状态的业务对象，这个业务对象是我们业务所关心的。<br>值对象不涉及完整状态，通常附属于实体。值对象通常没有完整状态，可修改，不涉及逻辑上的全局唯一。<br>例子：<br>交易单是实体，交易快照日志是值对象。<br>商户是实体，商户手机号是值对象。","like_count":0},{"had_liked":false,"id":348270,"user_name":"他们都叫我雷哥","can_delete":false,"product_type":"c1","uid":1683548,"ip_address":"","ucode":"C24F920C28A93D","user_header":"https://static001.geekbang.org/account/avatar/00/19/b0/5c/b85b0748.jpg","comment_is_top":false,"comment_ctime":1654918765,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654918765","product_id":100037301,"comment_content":"实体是存在唯一Id的对象，具有业务含义和生命周期。值对象是实体中部分属性归纳聚合在一起形成的对象，一是可以避免实体内属性爆炸，而且同过归纳让这些属性更容易理解","like_count":0},{"had_liked":false,"id":346846,"user_name":"葫芦娃","can_delete":false,"product_type":"c1","uid":1969599,"ip_address":"","ucode":"3B33204BC77D04","user_header":"https://static001.geekbang.org/account/avatar/00/1e/0d/bf/aa2d6ba8.jpg","comment_is_top":false,"comment_ctime":1653470336,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1653470336","product_id":100037301,"comment_content":"我现在有一个场景，我不明白我是不是应该看作是一个实体，请老师指导一下<br><br>背景是我们在基于DDD搭建一个单证域<br><br>我们的设计是，单证是一个单独的领域边界<br>单证具体分为：A单证、B单证、C单证<br>每个单证都是单独的实体，也是单独的聚合根，单独对外开放服务<br><br>我们现在为了记录每一个单证的所有操作，都会记录操作日志，所以就有一张操作记录表，操作日志中会记录对于何种单证做了什么操作<br>这个场景中，我理解操作记录就是一个功能，为了支持A、B、C这些具体单证的一个功能。<br>对于这种场景：<br>（1）这个操作日志，按照DDD的思想，能算是一个实体或者聚合吗？<br>（2）在实际落地时，在做这种操作日志的埋点时，我们应该放在领域层还是应用层？<br><br>对于（1）这个问题，我的思考是，每个操作日志是一次性记录，没有延续性和生命周期的这些特性，所以我感觉不是，看出一个支持性功能更加合适<br>对于（2）这个问题，我按照领域服务的概念（领域服务是在做同一个聚合内的逻辑）去想，如果不放在领域服务层，操作日志又是必须伴随着A单证领域服务、B单证领域服务、C单证领域服务的操作才会存在，操作日志并不会单独，所以在这点上是矛盾的；如果埋点如果放在各类单证的领域层，那我们会在A领域服务、B领域服务、C领域服务、D领域服务同时做操作日志的埋点，则代表操作日志同时属于A聚合、B聚合、C聚合、D聚合，操作日志同时属于这些不同的聚合，这种理解我又在相关资料上没有见过。","like_count":0,"discussions":[{"author":{"id":1945739,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/b0/8b/fa22d45c.jpg","nickname":"daxin","note":"","ucode":"70D3DE3720DC9A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587793,"discussion_content":"操作日志算通用领域吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663296248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"新加坡"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342316,"user_name":"公号-生活点亮技术","can_delete":false,"product_type":"c1","uid":1009329,"ip_address":"","ucode":"F807829A146624","user_header":"https://static001.geekbang.org/account/avatar/00/0f/66/b1/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1650187846,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650187846","product_id":100037301,"comment_content":"通过对象属性值来识别的对象，它将多个相关属性组合为一个概念整体。<br>简单来说，值对象本质上就是一个集合。那这个集合里面有什么呢？若干个用于描述目的、具有整体概念和不可修改的属性。那这个集合存在的意义又是什么？在领域建模的过程中，值对象可以保证属性归类的清晰和概念的完整性，避免属性零碎。<br><br>DDD 提倡从领域模型设计出发，而不是先设计数据模型。前面讲过了，传统的数据模型设计通常是一个表对应一个实体，一个主表关联多个从表，当实体表太多的时候就很容易陷入无穷无尽的复杂的数据库设计，领域模型就很容易被数据模型绑架。可以说，值对象的诞生，在一定程度上，和实体是互补的。<br><br>值对象采用序列化大对象的方法简化了数据库设计，减少了实体表的数量，可以简单、清晰地表达业务概念。这种设计方式虽然降低了数据库设计的复杂度，但却无法满足基于值对象的快速查询，会导致搜索值对象属性值变得异常困难。<br>","like_count":0},{"had_liked":false,"id":342312,"user_name":"陶乐乐","can_delete":false,"product_type":"c1","uid":1943501,"ip_address":"","ucode":"2D4355A7498948","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epb9WYgYQJCMF3XrBbYxnzoXchW2DHfrXHeI2iasiasFdHzJ1XEMjKIN1WdqCgqIQqWU2ibQmYbCic6Gg/132","comment_is_top":false,"comment_ctime":1650186128,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650186128","product_id":100037301,"comment_content":"实体对象是DDD建模工程实实在在存在的实体，而值对象只是某个建模过程使用，进行信息聚合固定的对象","like_count":0},{"had_liked":false,"id":336927,"user_name":"oyhk","can_delete":false,"product_type":"c1","uid":1263917,"ip_address":"","ucode":"B64A75FBC120FC","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/2d/0914ee90.jpg","comment_is_top":false,"comment_ctime":1646474050,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1646474050","product_id":100037301,"comment_content":"看了很多回复，基本覆盖了我的疑问。<br>请问一下欧老师，如果值对象用于条件搜索该怎么处理呢？","like_count":0},{"had_liked":false,"id":334849,"user_name":"jenix","can_delete":false,"product_type":"c1","uid":2914487,"ip_address":"","ucode":"BBC46634FA93BC","user_header":"https://static001.geekbang.org/account/avatar/00/2c/78/b7/55a18e2f.jpg","comment_is_top":false,"comment_ctime":1645154697,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645154697","product_id":100037301,"comment_content":"发表一下个人理解，实体是从我们实际业务逻辑中抽象出来的对象，和我们业务逻辑中的业务载体是一一对应的。值对象是对我们对实体中同类属性的再归类封装，类似于对属性进行再分类操作。从代码结构上来讲，实体是含有唯一标识的，同时具有属性和行为的类，而值对象仅含有属性。","like_count":0},{"had_liked":false,"id":334312,"user_name":"Geek_2e92d2","can_delete":false,"product_type":"c1","uid":1626311,"ip_address":"","ucode":"6419E5FFF1666F","user_header":"","comment_is_top":false,"comment_ctime":1644885610,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644885610","product_id":100037301,"comment_content":"老师，值对象可以修改吗，入户address作为一个值对象，用户想要修改发货地址。","like_count":0},{"had_liked":false,"id":334084,"user_name":"高级按摩师 👁 ^ 👁⃢*","can_delete":false,"product_type":"c1","uid":1435006,"ip_address":"","ucode":"31518306EF81B6","user_header":"https://static001.geekbang.org/account/avatar/00/15/e5/7e/5190f9b2.jpg","comment_is_top":false,"comment_ctime":1644735573,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1644735573","product_id":100037301,"comment_content":"为什么要先建立领域对象模型，然后在映射到数据库持久化","like_count":0},{"had_liked":false,"id":329381,"user_name":"先听","can_delete":false,"product_type":"c1","uid":1151409,"ip_address":"","ucode":"82D8DA7A2FEB4B","user_header":"https://static001.geekbang.org/account/avatar/00/11/91/b1/fb117c21.jpg","comment_is_top":false,"comment_ctime":1641308146,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641308146","product_id":100037301,"comment_content":"在这一讲中频繁出现class这个词。而对于没有class的开发语言，该如何适配我们文章里的内容呢？或者，没有class的语言 是不是不太适合采用ddd来开发呢？","like_count":0},{"had_liked":false,"id":329379,"user_name":"先听","can_delete":false,"product_type":"c1","uid":1151409,"ip_address":"","ucode":"82D8DA7A2FEB4B","user_header":"https://static001.geekbang.org/account/avatar/00/11/91/b1/fb117c21.jpg","comment_is_top":false,"comment_ctime":1641307478,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641307478","product_id":100037301,"comment_content":"三节课听完了，就感觉老师一直在讲“避免歧义的重要性”。能把话说得清清楚楚明明白白，才能把事情做得干干净净利利索索。 隐约感觉到这可能是一门哲学课。","like_count":0},{"had_liked":false,"id":324748,"user_name":"Geek_800685","can_delete":false,"product_type":"c1","uid":2857157,"ip_address":"","ucode":"9F37BB8EA1703F","user_header":"","comment_is_top":false,"comment_ctime":1638602514,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638602514","product_id":100037301,"comment_content":"老师，在商品管理系统，“价格”被设计成“商品”实体的一个值对象。如果在以价格为主的价格管控系统中，“价格”能被设计成实体吗？但价格好像没有实体所说的唯一性？","like_count":0},{"had_liked":false,"id":324089,"user_name":"公号-生活点亮技术","can_delete":false,"product_type":"c1","uid":1009329,"ip_address":"","ucode":"F807829A146624","user_header":"https://static001.geekbang.org/account/avatar/00/0f/66/b1/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1638284850,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1638284850","product_id":100037301,"comment_content":"“值对象不可变”，第一次听到这个的同学肯定会懵，不可变是不是就不能改了。<br>但数据库中的字段，除了id好像没有不能改的吧。就是id，测试同学为了造数据，也会改来改去的。<br><br>“你去上班对象不可变”是需要一个上下文的。<br>特意就这个问题写了个短文，剖析了下，看看讲的合理不合理呢<br>https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;KCs8CaMjMFza2hNX1UCrWg","like_count":0},{"had_liked":false,"id":307805,"user_name":"Farley","can_delete":false,"product_type":"c1","uid":1694401,"ip_address":"","ucode":"2BFB6D443D2ED3","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/XAYaRPlOEpF1CIby8iaSdkWf4j6Xia9ibADGdP7hTPEZunW3nLyzdwHmKwoichOz1UDawrZZd0RIsBWX1sNwfZqWNA/132","comment_is_top":false,"comment_ctime":1629262730,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629262730","product_id":100037301,"comment_content":"充血模型和贫血模型各有利弊，听了几堂课，老师对充血模型更偏好。而实际在工作中，贫血模型貌似更容易实现。<br><br>两者的区别点在哪里呢？","like_count":0},{"had_liked":false,"id":304004,"user_name":"xxx","can_delete":false,"product_type":"c1","uid":1096652,"ip_address":"","ucode":"E79CEA70430449","user_header":"https://static001.geekbang.org/account/avatar/00/10/bb/cc/fac12364.jpg","comment_is_top":false,"comment_ctime":1627181158,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1627181158","product_id":100037301,"comment_content":"实体和值对象确实是DDD提出来的；在此之前人们只知道对象，也就是实体，设计失之精确和灵活。有了实体和值对象的区别，我们更能够深刻地理解模型，并且对象被分成了两种，有更灵活的处理方式。","like_count":0},{"had_liked":false,"id":299345,"user_name":"张驰","can_delete":false,"product_type":"c1","uid":1080050,"ip_address":"","ucode":"0ED97C2FCE6599","user_header":"https://static001.geekbang.org/account/avatar/00/10/7a/f2/6770d0a9.jpg","comment_is_top":false,"comment_ctime":1624589637,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624589637","product_id":100037301,"comment_content":"实体对象具备业务含义和行为，通常要复核充血模型的设计原则，且实体对象具有唯一标识符，具有全局唯一性，同时丰富的业务行为又体现了实体对象具有较高的可变性。而值对象不具备唯一性和可变性，更多的时候是对一些不具有业务行为的概念进行汇总，形成了一个概念集合。文中案例二中，通过序列化大对象嵌入的方式，如果配合上MySQL的json格式存储，应该很好实现。<br>在设计的时候应该用实体对象还是值对象，我觉得本着一个是否具有业务行为的原则就够了，有业务行为的就用实体对象，没有业务行为的就设计成值对象。","like_count":0},{"had_liked":false,"id":297769,"user_name":"寂静之海","can_delete":false,"product_type":"c1","uid":2049328,"ip_address":"","ucode":"B39315DF82A9A5","user_header":"https://static001.geekbang.org/account/avatar/00/1f/45/30/e54b1230.jpg","comment_is_top":false,"comment_ctime":1623767180,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623767180","product_id":100037301,"comment_content":"值对象的使用是不是和享元模式类似呢，感觉挺相近的设计","like_count":0},{"had_liked":false,"id":292087,"user_name":"江厚宏","can_delete":false,"product_type":"c1","uid":1061214,"ip_address":"","ucode":"00A5A0995C6D75","user_header":"https://static001.geekbang.org/account/avatar/00/10/31/5e/d7cdc1d6.jpg","comment_is_top":false,"comment_ctime":1620669770,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1620669770","product_id":100037301,"comment_content":"所以用mongodb就很舒服了！！","like_count":0},{"had_liked":false,"id":281257,"user_name":"Eternal","can_delete":false,"product_type":"c1","uid":1188023,"ip_address":"","ucode":"EA6FE7CC98F740","user_header":"https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg","comment_is_top":false,"comment_ctime":1614667316,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614667316","product_id":100037301,"comment_content":"老师我们现在有一个问题，求指点：当前聚合中如果有A、B、C三个实体，A是聚合根，D是值对象，我怎么创建他们呢？聚合根A需要引用Ｂ、C、D三个对象，一种想法是我在领域服务中先创建好B、C、D三个对象，然后作为参数传递给聚合根A，A拿到三个对象再创建出聚合根；另一种方法是我将创建B、C、D三个对象的逻辑封装到A实体中的构造方法中，这样只有聚合根A创建的时候才创建其它实体。应该采用哪种方法呢？","like_count":0},{"had_liked":false,"id":274677,"user_name":"dongdong5820","can_delete":false,"product_type":"c1","uid":1438157,"ip_address":"","ucode":"272431574E123E","user_header":"https://static001.geekbang.org/account/avatar/00/15/f1/cd/210d3c74.jpg","comment_is_top":false,"comment_ctime":1611122083,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611122083","product_id":100037301,"comment_content":"1.实体有唯一标识，不管其属性如何变化，它还是原来的那个它。<br>2.值对象没有唯一标识，是一类属性的聚合，当属性发生变化时，就不是原来的那个值对象了。<br>3.在不同的限界上下文，实体和值对象可以相互转化。主要看在特定的上下文环境，业务关注的重点是什么。","like_count":0},{"had_liked":false,"id":272972,"user_name":"齐斌","can_delete":false,"product_type":"c1","uid":2411361,"ip_address":"","ucode":"1BFCD51E2F27BF","user_header":"","comment_is_top":false,"comment_ctime":1610373290,"is_pvip":false,"replies":[{"id":"99165","content":"是的，如果要进行复杂查询的话，就会存在问题。但是，如果我们将这些复杂查询采用CQRS模式设计，将这些需要查询的复杂数据采用领域事件的异步方式，放在读库和读模型中，就可以解决查询的问题。在写模型中确实可以简化数据库的设计。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1610693480,"ip_address":"","comment_id":272972,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1610373290","product_id":100037301,"comment_content":"如果按照这么理解，那么投保人，被保人，保费，佣金，标的都可以作为值对象存储在投保单或保单表了么，那么这么设计的话，在订单列表根据被保人姓名搜索还是存在性能问题","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513442,"discussion_content":"是的，如果要进行复杂查询的话，就会存在问题。但是，如果我们将这些复杂查询采用CQRS模式设计，将这些需要查询的复杂数据采用领域事件的异步方式，放在读库和读模型中，就可以解决查询的问题。在写模型中确实可以简化数据库的设计。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610693480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2693038,"avatar":"https://static001.geekbang.org/account/avatar/00/29/17/ae/f365efb0.jpg","nickname":"Quentin J.","note":"","ucode":"50B980CBE6EBA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384328,"discussion_content":"关注","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626497813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":272800,"user_name":"Geek_9c3134","can_delete":false,"product_type":"c1","uid":1141689,"ip_address":"","ucode":"479BC6B4CF22FA","user_header":"https://static001.geekbang.org/account/avatar/00/11/6b/b9/9b0630b1.jpg","comment_is_top":false,"comment_ctime":1610288116,"is_pvip":false,"replies":[{"id":"99167","content":"是的。地址的多个字段信息会打包成一个Address字段。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1610693719,"ip_address":"","comment_id":272800,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1610288116","product_id":100037301,"comment_content":"在领域建模时，我们可以把地址作为值对象，人员作为实体，这样就可以保留地址的业务涵义和概念完整性。而在数据建模时，我们可以将地址的属性值嵌入人员实体数据库表中，只创建人员数据库表。这样既可以兼顾业务含义和表达，又不增加数据库的复杂度。    老师   这个存在数据库中  地址是人员数据库表中一个json类型的字段吗","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513392,"discussion_content":"是的。地址的多个字段信息会打包成一个Address字段。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610693719,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":272105,"user_name":"benxiong","can_delete":false,"product_type":"c1","uid":1624574,"ip_address":"","ucode":"F6498059D439D9","user_header":"https://static001.geekbang.org/account/avatar/00/18/c9/fe/874b172b.jpg","comment_is_top":false,"comment_ctime":1609934140,"is_pvip":false,"replies":[{"id":"98669","content":"如果地址多个，而且数据量非常多的话，不太建议采用json串的模式。举个例子，对于订单而言，收货地址一般只会有一个，这种地址值对象以json串保存是没有问题。<br>您说的这种复杂的场景，可以根据业务复杂度来决定设计成json串还是子表的方式。如果在数据库中只存储数据，不做关联数据操作和值对象查询操作，而且领域层不做复杂业务处理逻辑，Json串的方式是可以简化数据库设计的。所以在值对象数据模型设计时需要具体情况具体分析。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1609980987,"ip_address":"","comment_id":272105,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1609934140","product_id":100037301,"comment_content":"看到给@ Geek_ed5fc0 的回复，感觉很怪。如果作者是这么做的话，那数据库存地址的 json 字符串会很长很丑陋吧，尤其一般地址都是多个的，真实项目有人这么做吗，希望能解答一下。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513155,"discussion_content":"如果地址多个，而且数据量非常多的话，不太建议采用json串的模式。举个例子，对于订单而言，收货地址一般只会有一个，这种地址值对象以json串保存是没有问题。\n您说的这种复杂的场景，可以根据业务复杂度来决定设计成json串还是子表的方式。如果在数据库中只存储数据，不做关联数据操作和值对象查询操作，而且领域层不做复杂业务处理逻辑，Json串的方式是可以简化数据库设计的。所以在值对象数据模型设计时需要具体情况具体分析。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609980987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1069142,"avatar":"https://static001.geekbang.org/account/avatar/00/10/50/56/da95fa6d.jpg","nickname":"唐某某","note":"","ucode":"0DBD6338E11173","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366151,"discussion_content":"如果是多个地址，需要有一个“配置-地址”的 支撑领域了。。但在订单领域，是可以确定一个地址的，JSON 字段保存没啥问题。 这里有一个小技巧，就是在@entity 里增加一个 @transient 字段，序列化/反序列化 JSON 字段，可简化业务代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617970565,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":266542,"user_name":"香","can_delete":false,"product_type":"c1","uid":1220273,"ip_address":"","ucode":"121D6CECECEEC3","user_header":"https://static001.geekbang.org/account/avatar/00/12/9e/b1/758f2fe7.jpg","comment_is_top":false,"comment_ctime":1607389795,"is_pvip":false,"replies":[{"id":"97307","content":"如果多个Address的话，可以是一个list对象。如果只有一个值的话，用一个string类型的地址属性Address就可以了，地址内多个属性，如省、地和市等可以打包成一个JSON串保存在一个Address的字段中。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1608020859,"ip_address":"","comment_id":266542,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1607389795","product_id":100037301,"comment_content":"老师有个疑问，值对象以序列化大对象作为实体对象的一部分时，那在代码形态上，这里举的例子，Address是不是应该就是一个List&lt;Address&gt;？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511305,"discussion_content":"如果多个Address的话，可以是一个list对象。如果只有一个值的话，用一个string类型的地址属性Address就可以了，地址内多个属性，如省、地和市等可以打包成一个JSON串保存在一个Address的字段中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608020859,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":260400,"user_name":"于途","can_delete":false,"product_type":"c1","uid":1669343,"ip_address":"","ucode":"70300C6CCCEAF1","user_header":"https://static001.geekbang.org/account/avatar/00/19/78/df/424bdc4a.jpg","comment_is_top":false,"comment_ctime":1604998362,"is_pvip":true,"replies":[{"id":"94609","content":"是的，地址在领域模型中以值对象的形式被实体引用。但是在存储的时候，我们不需要单独给地址建一张地址表，而是改用嵌入人员实体表的方式。如果地址含有多个属性，我们可以将它们打成一个地址的JSON串，存在人员实体表的地址属性中。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1605063388,"ip_address":"","comment_id":260400,"utype":1}],"discussion_count":2,"race_medal":1,"score":"1604998362","product_id":100037301,"comment_content":"我们可以综合这两个方案的优势，扬长避短。在领域建模时，我们可以把地址作为值对象，人员作为实体，这样就可以保留地址的业务涵义和概念完整性。而在数据建模时，我们可以将地址的属性值嵌入人员实体数据库表中，只创建人员数据库表。这样既可以兼顾业务含义和表达，又不增加数据库的复杂度。<br><br>老师，请问下：以上描述，指的是值对象属性迁入的方式吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509184,"discussion_content":"是的，地址在领域模型中以值对象的形式被实体引用。但是在存储的时候，我们不需要单独给地址建一张地址表，而是改用嵌入人员实体表的方式。如果地址含有多个属性，我们可以将它们打成一个地址的JSON串，存在人员实体表的地址属性中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605063388,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1698015,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJsOFUdib57ORVyia33dibSGRgwZZ9L2hQ90Xh5WsDUHfpHoCW2AMibnawMLBS6upGH3Qic57kl4PE6v2w/132","nickname":"mbc","note":"","ucode":"D5F52BA5047152","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374942,"discussion_content":"但是 如果值对象有检索场景的话 怎么办 json不是特别友好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621416264,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":259194,"user_name":"ZzC🍖","can_delete":false,"product_type":"c1","uid":2078752,"ip_address":"","ucode":"9EF8785409E77D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/b8/20/832e01dc.jpg","comment_is_top":false,"comment_ctime":1604649320,"is_pvip":false,"replies":[{"id":"94263","content":"这里的修改是对地址内部属性的修改，这种修改往往会完成对地址的生命周期管理，包括如增删改查等操作，所以可以设计为实体。而不是像收货地址一样，这种是对地址的整体替换，所以收货地址设计为值对象。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1604661872,"ip_address":"","comment_id":259194,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1604649320","product_id":100037301,"comment_content":"【而在某些业务场景中，地址会被经常修改，地址是作为一个独立对象存在的，这时候它应该设计为实体，比如行政区划中的地址信息维护。】 没太懂这里为什么经常修改就应该作为一个实体，反而我觉得作为值对象嵌入到实体整个修改覆盖就行了。<br>","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508875,"discussion_content":"这里的修改是对地址内部属性的修改，这种修改往往会完成对地址的生命周期管理，包括如增删改查等操作，所以可以设计为实体。而不是像收货地址一样，这种是对地址的整体替换，所以收货地址设计为值对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604661872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":258397,"user_name":"途","can_delete":false,"product_type":"c1","uid":1178240,"ip_address":"","ucode":"7715FE183557FF","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/80/f8be387d.jpg","comment_is_top":false,"comment_ctime":1604409312,"is_pvip":false,"replies":[{"id":"94116","content":"在领域模型中有很多的实体，有实体的话就会有生命周期管理，这时体现的实体的含义。而当这个实体的数据在不同的业务领域中流转，我们并不关心它的生命周期，而只关心它的另一种形态-不可更改的数据，这时体现的是值对象的含义。<br>举个例子：钱币会随着支付而在不同的地域或者行业流通，但是钱币有它的生命周期，比如生产，流通、回收和销毁等环节。钱币发行单位会根据它的ID而跟踪它的制造过程，流通了哪些领域，回收或者销毁时会知道是哪个ID的钱币，这就是它的生命周期管理。一张纸币不管流通到哪个环节，只要它的ID不变，不管它是坏了，还是污损了，这个钱币还是原来的那个纸币，管理单位根据ID就知道它经历了哪些过程，这就是实体的形态。而在流通环节中，钱币会在不同的领域流通，普通老百姓并不关心钱币的生命周期，而主要关注他的币值这个数据，而并不是ID，这时的钱币体现的是值对象的含义。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1604458322,"ip_address":"","comment_id":258397,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1604409312","product_id":100037301,"comment_content":"请问一下在叙述实体是什么的时候，提到的对象的延续性到底该如何理解呢？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508641,"discussion_content":"在领域模型中有很多的实体，有实体的话就会有生命周期管理，这时体现的实体的含义。而当这个实体的数据在不同的业务领域中流转，我们并不关心它的生命周期，而只关心它的另一种形态-不可更改的数据，这时体现的是值对象的含义。\n举个例子：钱币会随着支付而在不同的地域或者行业流通，但是钱币有它的生命周期，比如生产，流通、回收和销毁等环节。钱币发行单位会根据它的ID而跟踪它的制造过程，流通了哪些领域，回收或者销毁时会知道是哪个ID的钱币，这就是它的生命周期管理。一张纸币不管流通到哪个环节，只要它的ID不变，不管它是坏了，还是污损了，这个钱币还是原来的那个纸币，管理单位根据ID就知道它经历了哪些过程，这就是实体的形态。而在流通环节中，钱币会在不同的领域流通，普通老百姓并不关心钱币的生命周期，而主要关注他的币值这个数据，而并不是ID，这时的钱币体现的是值对象的含义。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604458322,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1178240,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fa/80/f8be387d.jpg","nickname":"途","note":"","ucode":"7715FE183557FF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":321996,"discussion_content":"多谢老师回复。那我理解对象的延续性是不是说的就是对象的生命周期及生命周期管理。还有对象的延续性超出软件的生命周期是不是只有对象持久化这一种情况？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604660018,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":256941,"user_name":"Sun Fei","can_delete":false,"product_type":"c1","uid":1032631,"ip_address":"","ucode":"092EC0992050BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c1/b7/57f153f6.jpg","comment_is_top":false,"comment_ctime":1603789974,"is_pvip":false,"replies":[{"id":"93548","content":"可以根据你的需要来决定，序列化大对象只是一种实现方式。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1603837197,"ip_address":"","comment_id":256941,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1603789974","product_id":100037301,"comment_content":"您好，老师。<br><br>实体中是不能使用 IList&lt;值对象&gt; ？ 必须要把多个值对象序列化成 String 吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508170,"discussion_content":"可以根据你的需要来决定，序列化大对象只是一种实现方式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603837197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":256465,"user_name":"爱码士","can_delete":false,"product_type":"c1","uid":1516495,"ip_address":"","ucode":"8E31D7E69F2C26","user_header":"https://static001.geekbang.org/account/avatar/00/17/23/cf/7429d6e8.jpg","comment_is_top":false,"comment_ctime":1603630306,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603630306","product_id":100037301,"comment_content":"实体对象能产生事件，但是值对象不能","like_count":0},{"had_liked":false,"id":255766,"user_name":"安静","can_delete":false,"product_type":"c1","uid":2081704,"ip_address":"","ucode":"F9E42BBC3F3BF0","user_header":"https://static001.geekbang.org/account/avatar/00/1f/c3/a8/5ed1a0fd.jpg","comment_is_top":false,"comment_ctime":1603423940,"is_pvip":false,"replies":[{"id":"93176","content":"需要看业务场景，如果是个人中心的地址，一个人可以维护多个地址，这时候设计为单独的表比较合适。如果是作为个人的收货地址的话，这时候只会有一个地址，而且这个地址只能从个人中心拿到新的地址后整体替换，这时候订单中的地址可以设计为一个属性。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1603434254,"ip_address":"","comment_id":255766,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1603423940","product_id":100037301,"comment_content":"如果你在实际中，address会在person表中一个属性，还是拆分成单独的表","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507832,"discussion_content":"需要看业务场景，如果是个人中心的地址，一个人可以维护多个地址，这时候设计为单独的表比较合适。如果是作为个人的收货地址的话，这时候只会有一个地址，而且这个地址只能从个人中心拿到新的地址后整体替换，这时候订单中的地址可以设计为一个属性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603434254,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250783,"user_name":"LU_BUG","can_delete":false,"product_type":"c1","uid":1942012,"ip_address":"","ucode":"75609836C6634B","user_header":"https://static001.geekbang.org/account/avatar/00/1d/a1/fc/bb503881.jpg","comment_is_top":false,"comment_ctime":1601219074,"is_pvip":false,"replies":[{"id":"91776","content":"如果把值对象找出来了，设计起来就会相对容易一些。我们先来看看值对象有哪些特征。<br>1、如果值对象的原始数据是在别的聚合进行生命周期管理，在当前聚合我们只关心它的值，你并不关心它的生命周期管理，那这个对象就可以设计为值对象，比如你这里提到的归属机构，它是在数据字典中进行机构代码管理（如增删改查），而在人员聚合中，它的数据来源于数据字典，不可以在人员聚合中修改，所以可以将它设计为值对象。<br>2、大多数的枚举类型的属性都可以设计为值对象，比如学历学位，政治面貌等。<br>3、还有一些主要用于描述的属性或者数值型的属性，比如特长技能，ID都是值对象。<br>其它的包含多个属性多条记录的对象，可以根据业务场景设计为实体，比如家庭成员，工作经历等等。<br>找出这些对象后，人员就可以作为聚合根，引用这些实体和值对象，形成人员聚合模型。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1601261858,"ip_address":"","comment_id":250783,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1601219074","product_id":100037301,"comment_content":"老师您好，有个疑惑问题帮忙解答，一个人员实体对象，有归属机构、学历学位、家庭成员、工作经历，特长技能、政治面貌等这么多子对象，该如何归类划分实体和值对象以及涉及领域模型呢？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506283,"discussion_content":"如果把值对象找出来了，设计起来就会相对容易一些。我们先来看看值对象有哪些特征。\n1、如果值对象的原始数据是在别的聚合进行生命周期管理，在当前聚合我们只关心它的值，你并不关心它的生命周期管理，那这个对象就可以设计为值对象，比如你这里提到的归属机构，它是在数据字典中进行机构代码管理（如增删改查），而在人员聚合中，它的数据来源于数据字典，不可以在人员聚合中修改，所以可以将它设计为值对象。\n2、大多数的枚举类型的属性都可以设计为值对象，比如学历学位，政治面貌等。\n3、还有一些主要用于描述的属性或者数值型的属性，比如特长技能，ID都是值对象。\n其它的包含多个属性多条记录的对象，可以根据业务场景设计为实体，比如家庭成员，工作经历等等。\n找出这些对象后，人员就可以作为聚合根，引用这些实体和值对象，形成人员聚合模型。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601261858,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":249092,"user_name":"九","can_delete":false,"product_type":"c1","uid":1375699,"ip_address":"","ucode":"DE98E4E0444C7D","user_header":"","comment_is_top":false,"comment_ctime":1600426988,"is_pvip":false,"replies":[{"id":"91633","content":"序列化大对象的方式是将包括多个属性（比如country、province、street等）的值对象，作为被它引用的对象的一个属性Address，然后将值对象的多个属性值序列化成一个大对象串，比如json串或xml对象，然后将这个对象串作为一个整体存在Address属性字段中。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1600934707,"ip_address":"","comment_id":249092,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1600426988","product_id":100037301,"comment_content":"老师好，还是没明白值对象怎么存储，是只存address字段吗，值是系列化的字符串吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505826,"discussion_content":"序列化大对象的方式是将包括多个属性（比如country、province、street等）的值对象，作为被它引用的对象的一个属性Address，然后将值对象的多个属性值序列化成一个大对象串，比如json串或xml对象，然后将这个对象串作为一个整体存在Address属性字段中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600934707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1736491,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/7f/2b/a83e767a.jpg","nickname":"吕志轩","note":"","ucode":"E3F99CD67E19D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327406,"discussion_content":"老师，我这里补充问一下，地址通过序列化的方式存储了，但是另外的微服务管理地址实体，把地址变了，在前面序列化的地址怎么保持同步呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605832044,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":243725,"user_name":"0094","can_delete":false,"product_type":"c1","uid":2043304,"ip_address":"","ucode":"3BFBC4916FD3DC","user_header":"","comment_is_top":false,"comment_ctime":1598257026,"is_pvip":false,"replies":[{"id":"89843","content":"实体就是我们一般意义上的对象的概念了。值对象可以解决不同对象数据在不同聚合的流转的问题，通过数据冗余实现不同聚合数据对象的解耦。<br>对于值对象，值对象是一把双刃剑，它的优势是可以简化数据库设计，提升性能。但如果值对象使用不当，它的优势就会很快变成劣势。<br>值对象采用序列化大对象的方法简化了数据库设计，减少了实体表的数量，可以简单、清晰地表达业务概念。这种设计方式虽然降低了数据库设计的复杂度，但却无法满足基于值对象的快速查询和统计分析，会导致搜索值对象属性值时变得异常困难。不过随着越来越多的数据库新版本推出，不少数据库已经开始支持基于Json串的查询方式了。<br>值对象的不可变性，从而确保了值对象永远都是正确的，在并发环境下不会被意外修改。所以在它同时被多个实体引用时，可以实现重用和共享，从而提高系统性能。<br>鉴于值对象比实体更轻量级，高性能且线程安全，所以一般建议将领域对象优先设计为值对象，而非实体。<br>其实，很多DDD专家在某些场景下，也很难判断到底应该将领域对象设计成实体还是值对象。你需要根据团队的设计和开发习惯，以及上面的优势和局限分析，选择最适合的实现方式。<br>另外，很多值对象的数据可能来源于其他聚合，它们以数据冗余的方式完成不同领域中数据的流转和共享。在这些聚合中的值对象以实体或聚合根的形式存在，完成数据的集中维护和管理。而在自己的聚合中它则以值对象的形式存在，被聚合内的某一个实体引用。例如：在订单聚合中，订单实体有收货地址这个值对象。在生成订单实体时，会从个人中心的客户聚合中，获取地址实体数据组合成订单聚合的地址值对象。订单实体可以整体引用和修改地址值对象的数据，但不允许单独修改地址值对象的某一个属性数据，如street。所有地址数据的新增和修改等维护，都只能在客户聚合中完成，这样就可以实现业务职责的高内聚，也就是说“如果你要修改某个业务行为，只需要修改一处就可以了。”客户聚合中地址实体的数据是其他地址值对象数据的源头。<br>由于不同聚合中实体和值对象的这种关系，值对象还有一个重要的使用场景，那就是记录和生成业务的数据快照。值对象以数据冗余的方式记录业务发生那一刻前后序聚合之间的业务数据，还原业务发生那一时刻的数据场景。比如订单聚合在下单时会记录订单生成那一刻的商品和收货地址等概要基础数据信息，我们称之为跟单数据。这时订单聚合的商品和收货地址是以包含多个属性的属性集值对象的形式存在的，它们被订单聚合根引用。属性集值对象的设计方式与通过商品ID或地址ID单一属性值对象关联的方式不同，当商品或地址的源端聚合的商品实体或地址实体数据变更后，不会影响订单聚合中商品和收货地址值对象的快照数据，这样就可以记录业务发生那一刻的业务快照数据了。即使源端商品或地址所在聚合出现服务不可用的情况，也不会影响订单聚合中商品或地址相关的业务逻辑，很好地实现了应用的解耦和故障隔离。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1598324241,"ip_address":"","comment_id":243725,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1598257026","product_id":100037301,"comment_content":"老师，基于什么问题，我们要引入实体、值对象？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504373,"discussion_content":"实体就是我们一般意义上的对象的概念了。值对象可以解决不同对象数据在不同聚合的流转的问题，通过数据冗余实现不同聚合数据对象的解耦。\n对于值对象，值对象是一把双刃剑，它的优势是可以简化数据库设计，提升性能。但如果值对象使用不当，它的优势就会很快变成劣势。\n值对象采用序列化大对象的方法简化了数据库设计，减少了实体表的数量，可以简单、清晰地表达业务概念。这种设计方式虽然降低了数据库设计的复杂度，但却无法满足基于值对象的快速查询和统计分析，会导致搜索值对象属性值时变得异常困难。不过随着越来越多的数据库新版本推出，不少数据库已经开始支持基于Json串的查询方式了。\n值对象的不可变性，从而确保了值对象永远都是正确的，在并发环境下不会被意外修改。所以在它同时被多个实体引用时，可以实现重用和共享，从而提高系统性能。\n鉴于值对象比实体更轻量级，高性能且线程安全，所以一般建议将领域对象优先设计为值对象，而非实体。\n其实，很多DDD专家在某些场景下，也很难判断到底应该将领域对象设计成实体还是值对象。你需要根据团队的设计和开发习惯，以及上面的优势和局限分析，选择最适合的实现方式。\n另外，很多值对象的数据可能来源于其他聚合，它们以数据冗余的方式完成不同领域中数据的流转和共享。在这些聚合中的值对象以实体或聚合根的形式存在，完成数据的集中维护和管理。而在自己的聚合中它则以值对象的形式存在，被聚合内的某一个实体引用。例如：在订单聚合中，订单实体有收货地址这个值对象。在生成订单实体时，会从个人中心的客户聚合中，获取地址实体数据组合成订单聚合的地址值对象。订单实体可以整体引用和修改地址值对象的数据，但不允许单独修改地址值对象的某一个属性数据，如street。所有地址数据的新增和修改等维护，都只能在客户聚合中完成，这样就可以实现业务职责的高内聚，也就是说“如果你要修改某个业务行为，只需要修改一处就可以了。”客户聚合中地址实体的数据是其他地址值对象数据的源头。\n由于不同聚合中实体和值对象的这种关系，值对象还有一个重要的使用场景，那就是记录和生成业务的数据快照。值对象以数据冗余的方式记录业务发生那一刻前后序聚合之间的业务数据，还原业务发生那一时刻的数据场景。比如订单聚合在下单时会记录订单生成那一刻的商品和收货地址等概要基础数据信息，我们称之为跟单数据。这时订单聚合的商品和收货地址是以包含多个属性的属性集值对象的形式存在的，它们被订单聚合根引用。属性集值对象的设计方式与通过商品ID或地址ID单一属性值对象关联的方式不同，当商品或地址的源端聚合的商品实体或地址实体数据变更后，不会影响订单聚合中商品和收货地址值对象的快照数据，这样就可以记录业务发生那一刻的业务快照数据了。即使源端商品或地址所在聚合出现服务不可用的情况，也不会影响订单聚合中商品或地址相关的业务逻辑，很好地实现了应用的解耦和故障隔离。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598324241,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240889,"user_name":"而立斋","can_delete":false,"product_type":"c1","uid":1087258,"ip_address":"","ucode":"5FED6E9E148195","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/1a/389eab84.jpg","comment_is_top":false,"comment_ctime":1597110520,"is_pvip":false,"replies":[{"id":"89385","content":"它们可以是SPU也可以是SKU，需要根据商品所在的业务场景来确定，在商品库存相关的聚合内，商品应该是SKU。在商品作为聚合根的聚合内部，SPU和SKU商品都会有唯一的ID，可以用于维护和管理各自的信息。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1597634787,"ip_address":"","comment_id":240889,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1597110520","product_id":100037301,"comment_content":"【实体以 DO（领域对象）的形式存在，每个实体对象都有唯一的 ID。我们可以对一个实体对象进行多次修改，修改后的数据和原来的数据可能会大不相同。但是，由于它们拥有相同的 ID，它们依然是同一个实体。比如商品是商品上下文的一个实体，通过唯一的商品 ID 来标识，不管这个商品的数据如何变化，商品的 ID 一直保持不变，它始终是同一个商品。】<br>怎么理解？<br>本质不变，不管商品包装的再华丽，它的本质 还是同一件商品。<br>一旦创建，id就不会变了。<br>那个这商品的粒度？是经过SKU组合而成的单品种商品，还是一个粒度比较粗的分类呢？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503586,"discussion_content":"它们可以是SPU也可以是SKU，需要根据商品所在的业务场景来确定，在商品库存相关的聚合内，商品应该是SKU。在商品作为聚合根的聚合内部，SPU和SKU商品都会有唯一的ID，可以用于维护和管理各自的信息。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597634787,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":238658,"user_name":"昌南一枝花","can_delete":false,"product_type":"c1","uid":2089155,"ip_address":"","ucode":"66118BEFFDC9BF","user_header":"","comment_is_top":false,"comment_ctime":1596251226,"is_pvip":false,"replies":[{"id":"88557","content":"是这样的。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1596673203,"ip_address":"","comment_id":238658,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1596251226","product_id":100037301,"comment_content":"1）我觉的值对象并非是DDD的专利，传统设计中也会在Dto中使用值对象来映射PO的的多属性或大json，只是没有值对象这个定义而已。DDD的特点还是领域设计优先于数据库设计，避免被数据库设计绑死。<br>2）数据库使用宽表来同时存储人员和地址，我理解好处是较少了数据库的join(主要还是分布式数据库对join很不友好，单体的数据库倒还好)，弊端是同时修改人员属性和地址属性时会访问人员表的同一条记录，存在行锁的竞争","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502818,"discussion_content":"是这样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596673203,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":237159,"user_name":"Eric","can_delete":false,"product_type":"c1","uid":1025684,"ip_address":"","ucode":"4555B9A888409D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a6/94/bfec9fc9.jpg","comment_is_top":false,"comment_ctime":1595694113,"is_pvip":false,"replies":[{"id":"88574","content":"如果软件版本，规格，工具版本需要单独维护和管理，并且需要单独的增删改查，它们本身就有聚合的特征，建议你采用第二种方案。然后这些聚合的聚合根ID作为测试环境聚合的聚合根的值对象。<br>《实现领域驱动设计》聚合的设计原则里面有一条：设计小聚合。它的出发点是“如果聚合设计得过大，聚合会因为包含过多的实体和值对象，导致实体之间的管理过于复杂，领域逻辑实现复杂，高频操作时会出现并发冲突或者数据库锁，最终导致系统可用性变差。小聚合设计也可以降低由于业务过大，在业务变化时导致聚合重构的可能性。这样领域模型就更能适应业务的变化”。当然你这个场景比较简单，业务也比较固定，聚合太多，感觉有点过度设计的感觉。<br>而如果你采用第一种方案的话，每次修改版本实体的数据时还要通过测试环境聚合根来操作，从实现逻辑上看也是比较奇怪。但是软件版本，规格，工具版本这些数据本身应该也是基础配置数据吧，如果是这样的话，我感觉还是第二种要好一些，这样配置数据就可以在不同的测试环境聚合根实体之间复用了，聚合之间的关系也比较清晰。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1596676003,"ip_address":"","comment_id":237159,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1595694113","product_id":100037301,"comment_content":"老师，您好，请教一个问题：我在做的一个功能，是自动化部署一个研发部门需要的开发联调测试环境，会有不同的软件版本，不同的规格，不同的工具版本。其中软件版本，规格，工具版本需要单独的增删改查，这些都是作为环境部署的选项，但是也只有这一类测试环境能用，也就是离开这类测试环境单独存在就没有业务含义了。我现在想了两种方案，<br>第一种：把测试环境作为实体聚合根，版本、规格和工具版本作为实体，在测试环境这个聚合根中整体依赖，各自对应一个数据库表，但是这个就感觉测试环境这个聚合根中依赖的实体属性太多（比如版本的属性比较多，但是在测试环境这个聚合中只关注版本号），如果设计成值对象又不能单独去维护版本，规格这些数据。<br>第二种：测试环境，版本，规格，工具版本都设计为聚合根，而版本，规格，工具版本在测试环境聚合中单独设计一个值对象（版本仅有版本号，规格就仅有规格的参数定义），但是呢我又感觉聚合太多，而且正如第一种说的版本，规格等离开测试环境这个聚合业务存在是没有意义的、没有其他场景还回去使用它。<br>请教下老师，这种问题该如何设计呢，谢谢，","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502319,"discussion_content":"如果软件版本，规格，工具版本需要单独维护和管理，并且需要单独的增删改查，它们本身就有聚合的特征，建议你采用第二种方案。然后这些聚合的聚合根ID作为测试环境聚合的聚合根的值对象。\n《实现领域驱动设计》聚合的设计原则里面有一条：设计小聚合。它的出发点是“如果聚合设计得过大，聚合会因为包含过多的实体和值对象，导致实体之间的管理过于复杂，领域逻辑实现复杂，高频操作时会出现并发冲突或者数据库锁，最终导致系统可用性变差。小聚合设计也可以降低由于业务过大，在业务变化时导致聚合重构的可能性。这样领域模型就更能适应业务的变化”。当然你这个场景比较简单，业务也比较固定，聚合太多，感觉有点过度设计的感觉。\n而如果你采用第一种方案的话，每次修改版本实体的数据时还要通过测试环境聚合根来操作，从实现逻辑上看也是比较奇怪。但是软件版本，规格，工具版本这些数据本身应该也是基础配置数据吧，如果是这样的话，我感觉还是第二种要好一些，这样配置数据就可以在不同的测试环境聚合根实体之间复用了，聚合之间的关系也比较清晰。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596676003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222299,"user_name":"加勒比海带","can_delete":false,"product_type":"c1","uid":1180186,"ip_address":"","ucode":"129E060503085A","user_header":"https://static001.geekbang.org/account/avatar/00/12/02/1a/f7d899f2.jpg","comment_is_top":false,"comment_ctime":1590741032,"is_pvip":false,"replies":[{"id":"82000","content":"是的。<br>","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1590754059,"ip_address":"","comment_id":222299,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590741032","product_id":100037301,"comment_content":"实体具有唯一标识ID，值对象不具有。实体注重唯一性和连续性，值对象注重描述性。实体和值对象在不同的限界上下文中可互相替换。比如在电商系统中，地址就是个值对象。在管理后台的地理信息维护中，地址就是个实体。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496741,"discussion_content":"是的。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590754059,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222101,"user_name":"Geek_70b64a","can_delete":false,"product_type":"c1","uid":2019505,"ip_address":"","ucode":"0256C364699CF0","user_header":"","comment_is_top":false,"comment_ctime":1590677503,"is_pvip":false,"replies":[{"id":"81960","content":"实体和值对象的目的都是抽象聚合若干属性以简化设计和沟通，两者都是经过属性聚类形成，实体着重唯一性和延续性，不在意属性的变化，即使属性全变了，它还是原来的那个它。值对象着重描述性，对属性的变化很敏感，属性变了，它就不是原来那个它了。<br>实体的特点：实体有ID标识，通过ID判断相等性，ID在聚合内唯一即可。实体的状态可变，它依附于聚合根，其生命周期由聚合根管理。实体一般会持久化，但与数据库持久化对象不一定是一对一的关系。实体可以引用聚合内的聚合根、实体和值对象。<br>值对象的特点：值对象无ID，值对象的数据不可变，它没有生命周期，用完即扔。值对象通过属性值判断相等性。它的核心本质是值，是一组概念完整的属性组成的集合，用于描述实体的状态和特征，值对象尽量只引用值对象。<br>","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1590742733,"ip_address":"","comment_id":222101,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590677503","product_id":100037301,"comment_content":"实体和值对象的区别？<br>实体：在我看来实体是一个有标志性属性和方法的集合，这个标志在整个软件生命周期中是不可变更的，如有个人在银行开户，这个人的身份证id是个标志性的属性，这个人还可以有的一些行为如存款，取款等，这些属性和方法集合构成集合体现出现实生活中一些可见实体形态。<br>值对象：值对象是一些有整体含义的属性集合，但这种对象是没有标志性属性的，如地址；<br>实体与值对象之间关系：感觉实体可以包含值对象，也可能有一对多等等关系；<br>但值对象中是否可以包含实体呢？<br>还是有点模糊，老师可以就他们之间的关系详细描述一下吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496667,"discussion_content":"实体和值对象的目的都是抽象聚合若干属性以简化设计和沟通，两者都是经过属性聚类形成，实体着重唯一性和延续性，不在意属性的变化，即使属性全变了，它还是原来的那个它。值对象着重描述性，对属性的变化很敏感，属性变了，它就不是原来那个它了。\n实体的特点：实体有ID标识，通过ID判断相等性，ID在聚合内唯一即可。实体的状态可变，它依附于聚合根，其生命周期由聚合根管理。实体一般会持久化，但与数据库持久化对象不一定是一对一的关系。实体可以引用聚合内的聚合根、实体和值对象。\n值对象的特点：值对象无ID，值对象的数据不可变，它没有生命周期，用完即扔。值对象通过属性值判断相等性。它的核心本质是值，是一组概念完整的属性组成的集合，用于描述实体的状态和特征，值对象尽量只引用值对象。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590742733,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220398,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1590234515,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1590234515","product_id":100037301,"comment_content":"实体对象我理解是一个有唯一标识，且有生命周期的业务对象<br>而值对象不是一个业务对象，只是做为实体对象的属性，用以描述实体<br>另外到底值对象要不要冗余在实体对象中其实是一个解决方案设计，看具体场景：<br>以上面的会员例子，地址值对象，如果这个是一个会员的收货地址，存在一对多的场景，这时唯护一个单独的地址表会更合适。大对象存储会有sql数据库上限限制。","like_count":0},{"had_liked":false,"id":219616,"user_name":"jun","can_delete":false,"product_type":"c1","uid":1899314,"ip_address":"","ucode":"3A9633CA1FE72E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/LalJD9ruYQI5zVM1GOCe4PjunIbbeeMiacFHC4TAj0DBVeialKt3vRCLs9dxn1vYXvfp8pgcyaeEQkh1nde1JoBQ/132","comment_is_top":false,"comment_ctime":1590051339,"is_pvip":false,"replies":[{"id":"81145","content":"是的","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1590099146,"ip_address":"","comment_id":219616,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590051339","product_id":100037301,"comment_content":"实体中可以引入其他实体值存储，不影响业务的关联实体可使用值来写入，比如订单中的收货地址，如果使用地址主外键ID的方式，则会导致业务的关联性太强，实际并不需要强关联","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495875,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590099146,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216715,"user_name":"elfkingw","can_delete":false,"product_type":"c1","uid":1049763,"ip_address":"","ucode":"898CC27CB25EAC","user_header":"https://static001.geekbang.org/account/avatar/00/10/04/a3/2d26cd1f.jpg","comment_is_top":false,"comment_ctime":1589331456,"is_pvip":false,"replies":[{"id":"80274","content":"是的，部门值对象和部门实体有很多属性一样。部门的实体在部门聚合维护，值对象只会依附于用户的属性集，它只可以整体替换，这里是有一部分数据冗余的。<br>跨实体或者不同聚合对应多张表联合查询，这种情况很难避免，你可以采用读写分离策略，或者直接通过应用服务来处理，不用走领域层，这样会导致聚合之间的耦合。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1589423914,"ip_address":"","comment_id":216715,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589331456","product_id":100037301,"comment_content":"用户是一个实体，部门是一个实体，用户实体下的用户所属部门设置为值对象？那部门值对象和部门实体岂不是有很多属性一样，出现代码重复问题？领域建模从代码层面做到了高内聚低耦合，到时很多统计可能跨实体或者不同聚合对应多张表联合查询，在数据层还是有耦合的情况","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494922,"discussion_content":"是的，部门值对象和部门实体有很多属性一样。部门的实体在部门聚合维护，值对象只会依附于用户的属性集，它只可以整体替换，这里是有一部分数据冗余的。\n跨实体或者不同聚合对应多张表联合查询，这种情况很难避免，你可以采用读写分离策略，或者直接通过应用服务来处理，不用走领域层，这样会导致聚合之间的耦合。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589423914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203927,"user_name":"曾轼麟","can_delete":false,"product_type":"c1","uid":1451391,"ip_address":"","ucode":"D418371AC11270","user_header":"https://static001.geekbang.org/account/avatar/00/16/25/7f/473d5a77.jpg","comment_is_top":false,"comment_ctime":1586308169,"is_pvip":false,"replies":[{"id":"76281","content":"不一定吧。按照架构演进能力来说DDD的演进能力会更强，因为按照DDD方法设计出来的领域模型和微服务是高内聚低耦合的。微服务内部聚合之间的边界是非常清晰的，如果业务发生了变化，我们很容易的可以以聚合为单位进行业务和微服务的重组，来适应新的业务。反之基于数据建模的应用，数据之间的关联性和业务逻辑之间的耦合度都会比较高，如果未来业务或应用需要演进，这个拆分的过程是非常麻烦的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1586329770,"ip_address":"","comment_id":203927,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1586308169","product_id":100037301,"comment_content":"老师有个问题，ddd不适合公司发生重大战略变更的情况，比如公司从自营转撮合业务的时候，数据建模的优势会高于领域建模","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491003,"discussion_content":"不一定吧。按照架构演进能力来说DDD的演进能力会更强，因为按照DDD方法设计出来的领域模型和微服务是高内聚低耦合的。微服务内部聚合之间的边界是非常清晰的，如果业务发生了变化，我们很容易的可以以聚合为单位进行业务和微服务的重组，来适应新的业务。反之基于数据建模的应用，数据之间的关联性和业务逻辑之间的耦合度都会比较高，如果未来业务或应用需要演进，这个拆分的过程是非常麻烦的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586329770,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200771,"user_name":"刘小龙","can_delete":false,"product_type":"c1","uid":1063124,"ip_address":"","ucode":"E2887ADCAD1F2E","user_header":"https://static001.geekbang.org/account/avatar/00/10/38/d4/f15ab4a3.jpg","comment_is_top":false,"comment_ctime":1585649076,"is_pvip":false,"replies":[{"id":"75263","content":"是的，没错。<br>值对象可以理解为不同聚合之间的数据冗余，在某一个聚合内它可能是聚合根，这个聚合负责管理这些数据的新增和修改。而在其它聚合它是值对象，它们的数据来源于其它聚合的聚合根，只能从另外的聚合获取数据后整体替换。<br>数据建模的时候要考虑具体的场景和技术组件，比如1：n的话，有些数据库，如PostgreSQL，它可以在某些字段存成JSON串，可以提供基于JSON串的查询功能。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1585749001,"ip_address":"","comment_id":200771,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585649076","product_id":100037301,"comment_content":"值对象，可以理解为实体的冗余数据，例如有效地址，直接存在实体中；但是地址管理中，又成了实体。一般业务更多的是1：n，n：n，数据建模能明显的简化么？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490133,"discussion_content":"是的，没错。\n值对象可以理解为不同聚合之间的数据冗余，在某一个聚合内它可能是聚合根，这个聚合负责管理这些数据的新增和修改。而在其它聚合它是值对象，它们的数据来源于其它聚合的聚合根，只能从另外的聚合获取数据后整体替换。\n数据建模的时候要考虑具体的场景和技术组件，比如1：n的话，有些数据库，如PostgreSQL，它可以在某些字段存成JSON串，可以提供基于JSON串的查询功能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585749001,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":196892,"user_name":"小罗希冀","can_delete":false,"product_type":"c1","uid":1311995,"ip_address":"","ucode":"88416458FF0041","user_header":"https://static001.geekbang.org/account/avatar/00/14/04/fb/40f298bb.jpg","comment_is_top":false,"comment_ctime":1585321734,"is_pvip":false,"replies":[{"id":"74483","content":"这是数据持久化对象PO的方式，但是在领域模型的DO对象，它们是分开，以引用的方式存在的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1585323232,"ip_address":"","comment_id":196892,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585321734","product_id":100037301,"comment_content":"&quot;在数据建模时，我们可以将地址的属性值嵌入人员实体数据库表中，只创建人员数据库表。这样既可以兼顾业务含义和表达，又不增加数据库的复杂度。&quot;<br><br>请问一下，按照这句话的意思，不还是在User表里面嵌入省市区镇四级地址信息吗？<br>跟前面的第一个方案有啥不一样？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489412,"discussion_content":"这是数据持久化对象PO的方式，但是在领域模型的DO对象，它们是分开，以引用的方式存在的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585323232,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":196779,"user_name":"秦伟","can_delete":false,"product_type":"c1","uid":1931692,"ip_address":"","ucode":"D47C1F57500FE1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/VjomKNzfFiaIttqYMxbjAWTG7NL7P2UqC5fbSvg0JW80SLnoR2oH1G4U2eibmxbR4wPpoqZdDnjC8GqgShDOBRzA/132","comment_is_top":false,"comment_ctime":1585312415,"is_pvip":false,"replies":[{"id":"74475","content":"领域建模是DDD战略设计中最重要的工作。通过用户旅程以及场景分析，找出有哪些领域对象，领域对象有哪些行为，这些行为可能是对象的方法，或者领域服务，然后哪些领域对象应该聚合在一起，形成一个高内聚低耦合的聚合业务逻辑小单元。这些个实体以及行为要素就构成了这个业务的领域模型。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1585320709,"ip_address":"","comment_id":196779,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585312415","product_id":100037301,"comment_content":"欧老师我对领域模型的概念不是很清楚，可以看看什么是领域模型吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489384,"discussion_content":"领域建模是DDD战略设计中最重要的工作。通过用户旅程以及场景分析，找出有哪些领域对象，领域对象有哪些行为，这些行为可能是对象的方法，或者领域服务，然后哪些领域对象应该聚合在一起，形成一个高内聚低耦合的聚合业务逻辑小单元。这些个实体以及行为要素就构成了这个业务的领域模型。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585320709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":195583,"user_name":"deem","can_delete":false,"product_type":"c1","uid":1936901,"ip_address":"","ucode":"3DBAAB685E0014","user_header":"","comment_is_top":false,"comment_ctime":1585199618,"is_pvip":false,"replies":[{"id":"74327","content":"在数据库里是要存实体的ID的，如果采用属性嵌入或者json串的方式就不需要了，因为它们在一张表里面。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1585222317,"ip_address":"","comment_id":195583,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585199618","product_id":100037301,"comment_content":"有一点不是很明白，如果这个当一个实体对象里面有值对象时，对应值对象在设计表的时候，需要存一下实体对象的id么，实体对象和值对象之间是通过哪个id关联 的","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489119,"discussion_content":"在数据库里是要存实体的ID的，如果采用属性嵌入或者json串的方式就不需要了，因为它们在一张表里面。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585222317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":189539,"user_name":"龚如曦","can_delete":false,"product_type":"c1","uid":1809868,"ip_address":"","ucode":"07EEB18F7921E2","user_header":"","comment_is_top":false,"comment_ctime":1584527441,"is_pvip":false,"replies":[{"id":"73064","content":"所有值对象的设计要考虑成本和收益。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1584579483,"ip_address":"","comment_id":189539,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1584527441","product_id":100037301,"comment_content":"坦白讲，我不赞同值对象与数据库范式冲突的观念。我理解，值对象是值的集合，可以有唯一ID，但对外不暴露或忽略，或者可以存在多个版本各自有自己的ID，至于值对象如何存储，可以在数据库里存储JSON，可以存贮关联表，也可以不使用数据库而使用其他的NoSQL存储。或者说，值对象是DDD的概念，是领域模型一部分，但如何存储值对象，这个是有存储层的具体选择，或者说是具体的实现。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487727,"discussion_content":"所有值对象的设计要考虑成本和收益。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584579483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188572,"user_name":"迎波扬帆","can_delete":false,"product_type":"c1","uid":1795341,"ip_address":"","ucode":"D015FBAE853ABC","user_header":"https://static001.geekbang.org/account/avatar/00/1b/65/0d/eab13441.jpg","comment_is_top":false,"comment_ctime":1584369685,"is_pvip":false,"replies":[{"id":"72765","content":"是的，现在很多数据库都支持了，包括PG。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1584406377,"ip_address":"","comment_id":188572,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1584369685","product_id":100037301,"comment_content":"mysql 8.0 json 提供的丰富函数一定程度上弥补了值对象不方便检索的缺点","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487454,"discussion_content":"是的，现在很多数据库都支持了，包括PG。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584406377,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187219,"user_name":"千城","can_delete":false,"product_type":"c1","uid":1850369,"ip_address":"","ucode":"346A133059977D","user_header":"https://static001.geekbang.org/account/avatar/00/1c/3c/01/29008d6a.jpg","comment_is_top":false,"comment_ctime":1584063810,"is_pvip":false,"replies":[{"id":"72547","content":"在人员的聚合，地址肯定是实体。一对多是可以的。在其他的聚合比如订单聚合，他可以存储人员聚合的地址信息，这时候这个地址是值对象。<br>如果需要对这个值对象查询，不建议存成json串。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1584284372,"ip_address":"","comment_id":187219,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1584063810","product_id":100037301,"comment_content":"老师，现实中，人员和地址往往是一对多的关系，这个时候在数据库建模层面，将地址放入人员表是不是就有问题了呢？  而且地址值对象用json串存储，在查询解析上不是也会有问题么？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487034,"discussion_content":"在人员的聚合，地址肯定是实体。一对多是可以的。在其他的聚合比如订单聚合，他可以存储人员聚合的地址信息，这时候这个地址是值对象。\n如果需要对这个值对象查询，不建议存成json串。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584284372,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1232463,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ce/4f/6afbb99a.jpg","nickname":"天信","note":"","ucode":"4961959C9F19E9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308324,"discussion_content":"人员的聚合下，人员对地址的引用，是在 class 封装地址 ID 还是 list<Address> 对象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600916858,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187007,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1583988478,"is_pvip":false,"replies":[{"id":"72170","content":"也可以这么理解。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1584012695,"ip_address":"","comment_id":187007,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1583988478","product_id":100037301,"comment_content":"实体和值对象的区别，我觉得前者是充血的，后者是贫血的。两者的结合就是在关系型数据库中嵌入对象存储NOSQL的语义。<br><br>值对象非常适合于存储多变的、扩展的属性。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486956,"discussion_content":"也可以这么理解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584012695,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184761,"user_name":"Dunbreak","can_delete":false,"product_type":"c1","uid":1155210,"ip_address":"","ucode":"A64010733754BF","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/8a/69f4023c.jpg","comment_is_top":false,"comment_ctime":1583397146,"is_pvip":false,"replies":[{"id":"71823","content":"值对象在设计的时候要尽量提请考虑好是否有查询的需求。对于复杂的值对象，如果后面确实出现了查询的需求，如果是在线系统就需要拆成实体引用的模式，如果是统计分析的查询，可以将这部分实体和值对象的数据，在到统计分析系统时，完成实体和值对象的拆分。另外有部分数据库如PG数据库，有支持JSON串字段的查询功能。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1583722515,"ip_address":"","comment_id":184761,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1583397146","product_id":100037301,"comment_content":"如果将地址作为值对象在数据建模中嵌入到实体信息中，那么如果业务需求有查询一个城市下的实体信息，比如需要查询城市是北京的人员，这种需求下是不是值对象这样嵌入就是不合理的？但是也有可能项目设计初期，需求方并没有这样的查询需求，当时如果合并嵌入做了，之后又需要怎么修改呢？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486123,"discussion_content":"值对象在设计的时候要尽量提请考虑好是否有查询的需求。对于复杂的值对象，如果后面确实出现了查询的需求，如果是在线系统就需要拆成实体引用的模式，如果是统计分析的查询，可以将这部分实体和值对象的数据，在到统计分析系统时，完成实体和值对象的拆分。另外有部分数据库如PG数据库，有支持JSON串字段的查询功能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583722515,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184001,"user_name":"这菜真香呀","can_delete":false,"product_type":"c1","uid":1046661,"ip_address":"","ucode":"13692E295A6A47","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/85/3c072e6f.jpg","comment_is_top":false,"comment_ctime":1583202246,"is_pvip":false,"replies":[{"id":"71227","content":"在DDD中采用面向对象的设计方法，这样有利于创建领域模型，更好的实现业务逻辑和代码的解耦。相关的好处建议看一下DDD分层架构那一节。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1583203127,"ip_address":"","comment_id":184001,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1583202246","product_id":100037301,"comment_content":"充血模型，与这个实体相关的所有业务逻辑都在实体类的方法中实现，扩多个实体的领域路基则在领域服务中实现。请问老师，这样做有什么好处呢？我们目前一般都是将领域的逻辑在Service层实现的。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485848,"discussion_content":"在DDD中采用面向对象的设计方法，这样有利于创建领域模型，更好的实现业务逻辑和代码的解耦。相关的好处建议看一下DDD分层架构那一节。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583203127,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180593,"user_name":"谭方敏","can_delete":false,"product_type":"c1","uid":1710960,"ip_address":"","ucode":"728DC7ECB7C902","user_header":"https://static001.geekbang.org/account/avatar/00/1a/1b/70/547042ee.jpg","comment_is_top":false,"comment_ctime":1582344602,"is_pvip":false,"replies":[{"id":"70422","content":"领域模型建好后，实体就归好类了，所以数据模型的边界基本也是很清晰得了。就不会出现两个微服务共享一个数据库的这类情况。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1582642736,"ip_address":"","comment_id":180593,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1582344602","product_id":100037301,"comment_content":"实体对象有以下特点：1）带业务逻辑，有唯一ID，2）可以修改，3）类似一个业务处理实体<br><br>值对象有以下特点：1）属性集合，不带行为，2）不能修改单一属性，只能整体置换，3）类似一个不带方法的实体对象<br><br>关于数据库，用值对象或者实体对象的原则依赖于二者的特点，如果不会做修改，那么直接上值对象，否则就上实体对象。<br><br>DDD设计方法可能认为数据是业务处理后的产物，所以主张从领域建模开始，然后再到数据建模，完全忠于业务，这个是跟传统方法不一样的地方，传统观念上，会是以数据驱动的思维为中心，因而会先从数据库表设计开始。<br>不过从以往的经验来看，数据库表的设计往往强依赖于业务逻辑，这样反而陷入了谁先谁后的问题，之前解决这个问题的方法是，数据库先设计一回，业务梳理清楚了，再优化调整一回。这样就显得有一些笨拙了。<br><br>","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484725,"discussion_content":"领域模型建好后，实体就归好类了，所以数据模型的边界基本也是很清晰得了。就不会出现两个微服务共享一个数据库的这类情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582642736,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176162,"user_name":"孤帆","can_delete":false,"product_type":"c1","uid":1053914,"ip_address":"","ucode":"8CC9AAF28944EB","user_header":"https://static001.geekbang.org/account/avatar/00/10/14/da/0a012c26.jpg","comment_is_top":false,"comment_ctime":1580975651,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1580975651","product_id":100037301,"comment_content":"还有文中的 xx形态，这是自创的术语吗？<br>前面文章还强调“通用语言”，这里自创这些”xx形态“的术语做什么？<br><br>谁来确定你的这些术语是计算机工程师的通用语言？","like_count":0},{"had_liked":false,"id":176159,"user_name":"孤帆","can_delete":false,"product_type":"c1","uid":1053914,"ip_address":"","ucode":"8CC9AAF28944EB","user_header":"https://static001.geekbang.org/account/avatar/00/10/14/da/0a012c26.jpg","comment_is_top":false,"comment_ctime":1580975462,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1580975462","product_id":100037301,"comment_content":"在代码模型中，实体的表现形式是实体类，这个类包含了实体的属性和方法，通过这些方法实现实体自身的业务逻辑。在 DDD 里，这些实体类通常采用充血模型，与这个实体相关的所有业务逻辑都在实体类的方法中实现，跨多个实体的领域逻辑则在领域服务中实现。<br><br>举个例子，平时的 FooServiceImpl 没有了，直接使用 Foo 来实现。<br>看起来有点搞笑，有点像PHP开发。","like_count":0},{"had_liked":false,"id":176033,"user_name":"发飙的蜗牛","can_delete":false,"product_type":"c1","uid":1800868,"ip_address":"","ucode":"B2D96A2D0B6BA4","user_header":"https://static001.geekbang.org/account/avatar/00/1b/7a/a4/79ffe77c.jpg","comment_is_top":false,"comment_ctime":1580915434,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580915434","product_id":100037301,"comment_content":"实体和值对象是DDD领域建模中最基础的领域对象，体现了领域业务模型设计。实体具有唯一标识，并且在整个系统业务生命周期中这个标识保持不变，是富对象，具有业务行为和业务逻辑。值对象依附于实体而存在，是若干属性的集合，用于描述实体的某些特征，没有唯一标识。抽离值对象主要是为了体现业务含义和概念完整性，能够简化数据库设计提高数据库性能。在DDD领域建模过程中，需要关注实体及其值对象之前的关系，一个聚合中的实体在另一个聚合中可能是值对象。","like_count":0},{"had_liked":false,"id":174865,"user_name":"莫离","can_delete":false,"product_type":"c1","uid":1099426,"ip_address":"","ucode":"DB820A7284CC36","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/a2/11c99f7f.jpg","comment_is_top":false,"comment_ctime":1580441926,"is_pvip":false,"replies":[{"id":"68001","content":"实体和值对象本质上都是属性的集合，是否设计为值对象要根据具体场景，如果这个属性集合的数据来源于其它的聚合，在本聚合只让整体修改，就可以设计为值对象。比如送货地址来源于客户中心，在订单中的送货地址只能整体从客户中心中获取并修改。那送货地址就是值对象。<br>关于实体的理解，建议把他们放在不同的层去理解，领域层的实体是运行的概念，而存储的实体是持久化对象的概念，它们有关联，但并不一定是一对一的关系。多个领域实体可以跟一个持久化实体对象映射。所以在领域层和基础层之间会有DO和PO的转换。<br><br>","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1580547526,"ip_address":"","comment_id":174865,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1580441926","product_id":100037301,"comment_content":"实体是领域中处理业务的最小单元，值对象是实体的属性，这样理解对吗？有个疑问是值对象可以是实体吗？就像传统数据库设计那样，还是说只能是嵌入式设计。还有就是比如说数据库存储的多个实体，但是为了某些业务搜索方便又在es做了多个实体聚合的文档，这样又相当于生成了一个新实体，对于这种设计又应该怎么来理解呢","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482551,"discussion_content":"实体和值对象本质上都是属性的集合，是否设计为值对象要根据具体场景，如果这个属性集合的数据来源于其它的聚合，在本聚合只让整体修改，就可以设计为值对象。比如送货地址来源于客户中心，在订单中的送货地址只能整体从客户中心中获取并修改。那送货地址就是值对象。\n关于实体的理解，建议把他们放在不同的层去理解，领域层的实体是运行的概念，而存储的实体是持久化对象的概念，它们有关联，但并不一定是一对一的关系。多个领域实体可以跟一个持久化实体对象映射。所以在领域层和基础层之间会有DO和PO的转换。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580547526,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172947,"user_name":"Geek_d38f30","can_delete":false,"product_type":"c1","uid":1512147,"ip_address":"","ucode":"955D6480731336","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ib1aca6ibMC3bcTZeVdTFalyyhdvy4DLQ7s4WBTWaw95k8IJNTUkZ5VwfB9rYwxVz3PAz4chBJhWcyMHib9KdEEnQ/132","comment_is_top":false,"comment_ctime":1579369569,"is_pvip":false,"replies":[{"id":"67073","content":"谈不上谁重要谁不重要哈。他们属于领域模型的不同角色。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1579397661,"ip_address":"","comment_id":172947,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1579369569","product_id":100037301,"comment_content":"对业务重要的就用实体，方便标记查询修改（通过唯一ID）。对业务不重要的就使用值对象，简单的存储数据。.值对象可以简化数据设计，但是有代价的。（前提你真的要确定这个对象真的不重要）","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481910,"discussion_content":"谈不上谁重要谁不重要哈。他们属于领域模型的不同角色。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579397661,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":171631,"user_name":"Iqexception","can_delete":false,"product_type":"c1","uid":1109901,"ip_address":"","ucode":"597A335EAC50A1","user_header":"https://static001.geekbang.org/account/avatar/00/10/ef/8d/5c0d2e9c.jpg","comment_is_top":false,"comment_ctime":1578982747,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1578982747","product_id":100037301,"comment_content":"读写的权衡，如果某些属性集合很少修改，但是经常查询，为了提高性能冗余一些字段也是可以接收的。<br>值对象与实体的区别有点像Java中值和对象的关系，值是不可变的，对象以引用地址为id经常变化","like_count":0},{"had_liked":false,"id":171289,"user_name":"飞肥","can_delete":false,"product_type":"c1","uid":1803022,"ip_address":"","ucode":"07408CD946D1F3","user_header":"","comment_is_top":false,"comment_ctime":1578895198,"is_pvip":false,"replies":[{"id":"66969","content":"如果这个值对象不对外提供统计和复杂查询的话，可以将它设计为Json串的方式，这样就具有较高的灵活性。<br>其实很多值对象很多时候体现了数据的冗余，它在其他聚合有对应的实体，可以新增和修改，这些数据会被其它聚合使用，但是在这些聚合不可修改，只能被实体整体引用。在领域建模的时候需要关注这类对象或值对象的设计。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1579249462,"ip_address":"","comment_id":171289,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578895198","product_id":100037301,"comment_content":"架构一般是演进式的。以上述人员和地址为例，假设前期业务场景不需要修改地址，一个人员也不需维护多个地址，那么把地址作为值对象就是合理的。数据模型可以将人员和地址放在同一表中维护。假设后续场景变化，一个人需要多个地址，且每个地址有可能变更。就需要把地址作为实体，表也需要变更。<br>请问老师，如何通过实体和值对象，更优雅的应对这个变化呢？谢谢","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481291,"discussion_content":"如果这个值对象不对外提供统计和复杂查询的话，可以将它设计为Json串的方式，这样就具有较高的灵活性。\n其实很多值对象很多时候体现了数据的冗余，它在其他聚合有对应的实体，可以新增和修改，这些数据会被其它聚合使用，但是在这些聚合不可修改，只能被实体整体引用。在领域建模的时候需要关注这类对象或值对象的设计。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579249462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170166,"user_name":"小谢同学","can_delete":false,"product_type":"c1","uid":1032544,"ip_address":"","ucode":"E809E6BC470631","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c1/60/fc3689d0.jpg","comment_is_top":false,"comment_ctime":1578541986,"is_pvip":false,"replies":[{"id":"66022","content":"有点类似。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1578554745,"ip_address":"","comment_id":170166,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578541986","product_id":100037301,"comment_content":"我理解值对象好比描述实体对metadata？但是在业务视角下谁做实体，谁做metadata可能各有各对看法？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480866,"discussion_content":"有点类似。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578554745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167530,"user_name":"ちよくん","can_delete":false,"product_type":"c1","uid":1398577,"ip_address":"","ucode":"B71E9B16E4408F","user_header":"https://static001.geekbang.org/account/avatar/00/15/57/31/6772744d.jpg","comment_is_top":false,"comment_ctime":1577849116,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577849116","product_id":100037301,"comment_content":"实体对象是有业务含义的对象，可以理解为业务中的一种具体的对象，例如人员，订单，商品等;而值对象是实体对象的附属信息或者说是属性，但是它自身又有一个完整的存在，但是又不能脱离实体对象单独存在，单独存在没有业务含义或者用途。如果要使用值对象，那么必须从领域建模开始。传统的设计从数据库开始，那么在不知道业务领域的情况下是符合设计规范的，扩展性也不错。","like_count":0},{"had_liked":false,"id":167265,"user_name":"Geek_kevin","can_delete":false,"product_type":"c1","uid":1301274,"ip_address":"","ucode":"03B0253CA59582","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/1a/30201f1a.jpg","comment_is_top":false,"comment_ctime":1577753990,"is_pvip":false,"replies":[{"id":"64946","content":"第一你可以将它的PO设计为属性嵌入的方式。第二数据抽取过程数据建模的时候可以将json串摊开。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1577755202,"ip_address":"","comment_id":167265,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1577753990","product_id":100037301,"comment_content":"老师,值对象这样设计,后面基于人员的省市做报表怎么弄?","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479799,"discussion_content":"第一你可以将它的PO设计为属性嵌入的方式。第二数据抽取过程数据建模的时候可以将json串摊开。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577755202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1438475,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f3/0b/4560079e.jpg","nickname":"王宇","note":"","ucode":"0E9BC3AD99C8E5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":187445,"discussion_content":"好多数据库都有json字段功能了，mysql8也方便json处理了，中型千万亿级数据的查询统计也不是问题，把值对象操作能力提升了一个档次，随着系统的复杂，值对象很容易演变成实体或者字典，演变成字典还好，说明有一定的公用型，升级也不算麻烦，升级成实体说明业务架构在扩大，也是好事，而且领域肯定是先大范围再细分，先细分老板指派几个程序员也干不了，小上线再迭代，细分领域后系统对应升级也是必须走的一步，系统按小型设计跑起来有钱了重构成中型再有钱了重构成大型，中间没钱了就不是花时间重构系统说不定业务已经不稳了。现在技术成熟，随便一套框架就能抗个千万级别业务。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582731467,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166615,"user_name":"shitao","can_delete":false,"product_type":"c1","uid":1067270,"ip_address":"","ucode":"9F4D71D4F34B61","user_header":"https://static001.geekbang.org/account/avatar/00/10/49/06/b90049f4.jpg","comment_is_top":false,"comment_ctime":1577520078,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1577520078","product_id":100037301,"comment_content":"实体由于有唯一id，是可以无限增长的。值对象的数量一定是有限的，而且不经常变动","like_count":0,"discussions":[{"author":{"id":1808666,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/99/1a/196ff5f8.jpg","nickname":"长空","note":"","ucode":"EFE7E08491849C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":145636,"discussion_content":"这个太绝对了，我觉得不能这么理解。实体更多与业务相关，是属于当前业务的概念聚合，并且是最小单元的，这样的我认为才是实体。值对象仅仅是一些信息的聚合，他是实体描述的补充。\n\n实体是充血模型，是信息+行为的聚合。而值对象仅仅是信息的聚合，或者帮实体把信息聚合。 文中的地址信息，就是对原实体中的地址信息打包聚合的\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579573685,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164132,"user_name":"wx","can_delete":false,"product_type":"c1","uid":1254784,"ip_address":"","ucode":"DD0B86A2059150","user_header":"https://static001.geekbang.org/account/avatar/00/13/25/80/26b85375.jpg","comment_is_top":false,"comment_ctime":1576893083,"is_pvip":false,"replies":[{"id":"62522","content":"可以拆出来的，其实人员信息表在这里就是一个共享数据。当人员信息数据发生变化时，你可以采用领域事件的方式，异步修改所有订阅的冗余数据。<br>如果业务逻辑不复杂的话，不建议做过多的拆分，你可以按照业务边界设计不同的聚合，他们在同一个微服务内。复杂的联表查询用读写分离方式来做就可以了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1577058318,"ip_address":"","comment_id":164132,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1576893083","product_id":100037301,"comment_content":"老师，有个问题想请教下：有一个人员表、人员表中有组织信息、还有一些薪资表、考勤表、档案表、优秀员工奖励记录表等等，查询这些业务表时会根据组织信息筛选业务数据，比如根据组织筛选人员的档案信息，这种场景下可以把人员信息单独拆出来一个微服务吗。如果拆出来需要需要把组织信息冗余到业务表中，但是当人员组织变化后需要修改所有业务表中的组织信息。这种情况老师有什么建议吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478650,"discussion_content":"可以拆出来的，其实人员信息表在这里就是一个共享数据。当人员信息数据发生变化时，你可以采用领域事件的方式，异步修改所有订阅的冗余数据。\n如果业务逻辑不复杂的话，不建议做过多的拆分，你可以按照业务边界设计不同的聚合，他们在同一个微服务内。复杂的联表查询用读写分离方式来做就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577058318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1113354,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fd/0a/14948043.jpg","nickname":"新新","note":"","ucode":"9308705EA0F014","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":224456,"discussion_content":"这个建模方向是反的，DDD提倡从业务出发进行拆分，从数据表出发已经缘木求鱼了，建议换个思路，先考虑业务","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586308619,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1254784,"avatar":"https://static001.geekbang.org/account/avatar/00/13/25/80/26b85375.jpg","nickname":"wx","note":"","ucode":"DD0B86A2059150","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":92906,"discussion_content":"老师像这种场景适合拆吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576893518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164034,"user_name":"Geek_aa8017","can_delete":false,"product_type":"c1","uid":1748911,"ip_address":"","ucode":"286195887103C2","user_header":"","comment_is_top":false,"comment_ctime":1576848506,"is_pvip":false,"replies":[{"id":"62525","content":"DDD数据的初始化是以聚合为单位整体来操作的，可以通过仓储和工厂模式两者结合来完成。仓储获取聚合的持久化数据，工厂完成聚合所有实体的数据初始化。<br>实体采用充血模型，负责实现实体对象自身的业务逻辑，也就是自己的方法，面向对象的设计方法。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1577058614,"ip_address":"","comment_id":164034,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1576848506","product_id":100037301,"comment_content":"老师，第一个问题，传统mvc架构的模式可以加入实体去写业务逻辑吗？这样做好不好？第二个问题，实体应该负责哪些业务逻辑，对于实体初始化需要先去数据库查询的逻辑应该放在哪里？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478622,"discussion_content":"DDD数据的初始化是以聚合为单位整体来操作的，可以通过仓储和工厂模式两者结合来完成。仓储获取聚合的持久化数据，工厂完成聚合所有实体的数据初始化。\n实体采用充血模型，负责实现实体对象自身的业务逻辑，也就是自己的方法，面向对象的设计方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577058614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1808666,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/99/1a/196ff5f8.jpg","nickname":"长空","note":"","ucode":"EFE7E08491849C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":145647,"discussion_content":"我现在也是在传统结构中开发也有使用充血模型。我建议你可以这样：如果你想要做的事仅利用当前对象的属性+少数传递的信息，那么可以将方法写到实体中。\n\n比如订单实体中，获取当前订单状态这样的方法。这个方法只需要利用订单实体内的一些属性就可以计算出状态。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579573954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163501,"user_name":"Geek_aa8017","can_delete":false,"product_type":"c1","uid":1748911,"ip_address":"","ucode":"286195887103C2","user_header":"","comment_is_top":false,"comment_ctime":1576732120,"is_pvip":false,"replies":[{"id":"62137","content":"持久化逻辑在仓储实现里面，实体DO会作为参数传给仓储实现，在仓储实现里面DO会转换为PO，再完成持久化操作。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1576735237,"ip_address":"","comment_id":163501,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1576732120","product_id":100037301,"comment_content":"数据持久化的逻辑放在哪里比较好，实体会和仓库有关联吗","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478418,"discussion_content":"持久化逻辑在仓储实现里面，实体DO会作为参数传给仓储实现，在仓储实现里面DO会转换为PO，再完成持久化操作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576735237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160903,"user_name":"给心来块冰块","can_delete":false,"product_type":"c1","uid":1063689,"ip_address":"","ucode":"7AFB56581782A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/09/2cf074a7.jpg","comment_is_top":false,"comment_ctime":1576058423,"is_pvip":true,"replies":[{"id":"61387","content":"是的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1576107906,"ip_address":"","comment_id":160903,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1576058423","product_id":100037301,"comment_content":"实体对领域信息的具体化，值对象只是对实体的补充，而且这种补充具有整体的的意义","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477524,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576107906,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160845,"user_name":"静静聆听","can_delete":false,"product_type":"c1","uid":1263932,"ip_address":"","ucode":"0A8600CB928EFE","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/3c/5d54c510.jpg","comment_is_top":false,"comment_ctime":1576045868,"is_pvip":false,"replies":[{"id":"61385","content":"要根据自己的业务具体场景具体分析。值对象还是有它的价值所在的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1576107832,"ip_address":"","comment_id":160845,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1576045868","product_id":100037301,"comment_content":"老师，其实我的想法里面，还是不建议将值对象的聚合做成一个序列化的数据放到同一张表里面，因为业务是会变更的，一期一些数据不需要修改，你作为json放在了数据库一列中，二期业务，这些数据可能就变成了可修改的，这样的业务场景很常见，所以我的建议是，只要是值对象的集合，就单独创建实体","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477499,"discussion_content":"要根据自己的业务具体场景具体分析。值对象还是有它的价值所在的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576107832,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1326455,"avatar":"https://static001.geekbang.org/account/avatar/00/14/3d/77/45e5e06d.jpg","nickname":"胡鹏","note":"","ucode":"52644EC57FA4DB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":110811,"discussion_content":"能大大降低成本, 有做过一定的尝试, 主要节省的成本是实体到仓促过程 设计mongodb存储的时候, 和关系数据库最大的区别就是, 设计多层次数据的时候, 要考虑数据更新带来的更新成本,  经常更新需要独立成集合, 不经常更新设计成一个子属性即可,  非常方便","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577758112,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1808666,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/99/1a/196ff5f8.jpg","nickname":"长空","note":"","ucode":"EFE7E08491849C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":145661,"discussion_content":"除了楼上说的，我认为序列化为json只是一种方式。文中值对象我理解的，主要是其不可变性还有其它对设计上的意义。\n\n如果某项属性对当前业务领域是不可变的，并且有2 3个数据值，那么用json也是可以的。如果你只有一个值，那就是普通的int bool 这种值类型\n\n如果在当前限界上下文内，你关注的只是要有这个东西，可以将其它领域的某个实体当做值对象放到你的实体中。，如前面提到的对汽车厂来说，引擎就是值对象。引擎有没有编号，有没有扩展性，对汽车实体来说是不关心的。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579574440,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158595,"user_name":"Kennedy","can_delete":false,"product_type":"c1","uid":1049022,"ip_address":"","ucode":"C50627007E5ED0","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/be/be358cab.jpg","comment_is_top":false,"comment_ctime":1575421323,"is_pvip":true,"replies":[{"id":"60771","content":"如果领域非常大的话，子域划分还需要一定的经验。当子域划分到适合进行事件风暴时，你就可以根据领域模型的语义来划分限界上下文了，限界上下文也是一种特殊的子域。限界上下文边界基本上就是微服务的边界了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1575466340,"ip_address":"","comment_id":158595,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1575421323","product_id":100037301,"comment_content":"老师，划分子域的依据是限界上下文，确定限界上下文的方式是根据业务语言的适用范围。我这个理解是否正确？如果一个业务语言属于子域，又属于该子域的子子域，那如何划分微服务呢？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476777,"discussion_content":"如果领域非常大的话，子域划分还需要一定的经验。当子域划分到适合进行事件风暴时，你就可以根据领域模型的语义来划分限界上下文了，限界上下文也是一种特殊的子域。限界上下文边界基本上就是微服务的边界了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575466340,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158172,"user_name":"冷たい風","can_delete":false,"product_type":"c1","uid":1218363,"ip_address":"","ucode":"4D73962B51DD2F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJGKX8kPDkrL7oPeBAv4WpqOmEg3KtsLs1vmundm9huEXMuIP3Ql0DZ0c2ZXMr0tVSiaQ7gV2T5GXA/132","comment_is_top":false,"comment_ctime":1575341931,"is_pvip":false,"replies":[{"id":"60591","content":"两种方式都是一个人员表。第一种是地址铺开放，第二种是打包放。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1575343617,"ip_address":"","comment_id":158172,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1575341931","product_id":100037301,"comment_content":"有点疑惑：将地址的属性值嵌入人员实体数据库表中，只创建人员数据库表？<br>有如下二种方式：<br>方式一：地址的每个属性平铺开，在人员数据表中分别创建对应的属性字段；<br>方式二：人员数据表只新增一个字段，保存地址所有属性的json数据；<br>这里指的是以上哪种方式呢，没说清楚呢","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476652,"discussion_content":"两种方式都是一个人员表。第一种是地址铺开放，第二种是打包放。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575343617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1218363,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJGKX8kPDkrL7oPeBAv4WpqOmEg3KtsLs1vmundm9huEXMuIP3Ql0DZ0c2ZXMr0tVSiaQ7gV2T5GXA/132","nickname":"冷たい風","note":"","ucode":"4D73962B51DD2F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70392,"discussion_content":"那请问下老师推荐使用哪种方式呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575352284,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1398824,"avatar":"https://static001.geekbang.org/account/avatar/00/15/58/28/c86340ca.jpg","nickname":"达文西","note":"","ucode":"01C1063F23D634","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1218363,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJGKX8kPDkrL7oPeBAv4WpqOmEg3KtsLs1vmundm9huEXMuIP3Ql0DZ0c2ZXMr0tVSiaQ7gV2T5GXA/132","nickname":"冷たい風","note":"","ucode":"4D73962B51DD2F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":88335,"discussion_content":"这个应该考虑业务场景吧，如果需要对平铺的字段做查询，那应该就要平铺了。如果不需要查询，只是做简单的记录回显，用整体值对象能简化数据库设计。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576694448,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":70392,"ip_address":""},"score":88335,"extra":""}]}]},{"had_liked":false,"id":157663,"user_name":"江厚宏","can_delete":false,"product_type":"c1","uid":1061214,"ip_address":"","ucode":"00A5A0995C6D75","user_header":"https://static001.geekbang.org/account/avatar/00/10/31/5e/d7cdc1d6.jpg","comment_is_top":false,"comment_ctime":1575244584,"is_pvip":true,"replies":[{"id":"60461","content":"没尝试过MongoDB哈，应该还是要分场景吧。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1575251676,"ip_address":"","comment_id":157663,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1575244584","product_id":100037301,"comment_content":"对于DDD，采用如MongoDB等非关系型数据库，是否能有效降低工程的开发成本呢？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476493,"discussion_content":"没尝试过MongoDB哈，应该还是要分场景吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575251676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1326455,"avatar":"https://static001.geekbang.org/account/avatar/00/14/3d/77/45e5e06d.jpg","nickname":"胡鹏","note":"","ucode":"52644EC57FA4DB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":110814,"discussion_content":"能大大降低成本, 有做过一定的尝试, 主要节省的成本是实体到仓促过程 设计mongodb存储的时候, 和关系数据库最大的区别就是, 设计多层次数据的时候, 要考虑数据更新带来的更新成本, 经常更新需要独立成集合, 不经常更新设计成一个子属性即可, 非常方便","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577758236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153391,"user_name":"Geek_aa8017","can_delete":false,"product_type":"c1","uid":1748911,"ip_address":"","ucode":"286195887103C2","user_header":"","comment_is_top":false,"comment_ctime":1574229574,"is_pvip":false,"replies":[{"id":"58973","content":"你需要有对应的功能，对订单管理的收货地址做整体替换。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574234740,"ip_address":"","comment_id":153391,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574229574","product_id":100037301,"comment_content":"老师你好，地址管理被设计成实体，订单中的地址被设计成值对象，如果地址管理的地址属性变了，怎么同步到订单管理的地址值对象呢？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475147,"discussion_content":"你需要有对应的功能，对订单管理的收货地址做整体替换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574234740,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151562,"user_name":"大鹏","can_delete":false,"product_type":"c1","uid":1105483,"ip_address":"","ucode":"024C1EE45DD415","user_header":"https://static001.geekbang.org/account/avatar/00/10/de/4b/af467d66.jpg","comment_is_top":false,"comment_ctime":1573740474,"is_pvip":false,"replies":[{"id":"58283","content":"其实你把单一值对象理解成一个属性也没关系。一般很多人都认为值对象是属性的集合。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573774054,"ip_address":"","comment_id":151562,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573740474","product_id":100037301,"comment_content":"老师您好，有一点不是很理解，为什么DDD中唯一标识采用值对象方式，和传统的Long类型ID有什么优势，意义在哪，我理解当唯一标识未来需要扩展可以不改变对象索引，但唯一标识通常其实也不会改变哦，望解惑","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474535,"discussion_content":"其实你把单一值对象理解成一个属性也没关系。一般很多人都认为值对象是属性的集合。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573774054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151000,"user_name":"等待......","can_delete":false,"product_type":"c1","uid":1124761,"ip_address":"","ucode":"7B89B2D50FD306","user_header":"https://static001.geekbang.org/account/avatar/00/11/29/99/11162659.jpg","comment_is_top":false,"comment_ctime":1573640459,"is_pvip":false,"replies":[{"id":"58102","content":"实体只管自己的业务行为实现，也就是方法。领域服务可以管一到多个实体的业务逻辑，面向应用服务。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573646414,"ip_address":"","comment_id":151000,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573640459","product_id":100037301,"comment_content":"老师，请问下实体与领域服务边界是啥","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474336,"discussion_content":"实体只管自己的业务行为实现，也就是方法。领域服务可以管一到多个实体的业务逻辑，面向应用服务。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573646414,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150391,"user_name":"💢 星星💢","can_delete":false,"product_type":"c1","uid":1254392,"ip_address":"","ucode":"A402B765222C35","user_header":"https://static001.geekbang.org/account/avatar/00/13/23/f8/24fcccea.jpg","comment_is_top":false,"comment_ctime":1573526189,"is_pvip":false,"replies":[{"id":"57834","content":"是的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573535237,"ip_address":"","comment_id":150391,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573526189","product_id":100037301,"comment_content":"这篇文章，刷新了我的眼界，一直都在传统行业工作，而且都是基于数据库出发做的设计，然后在设计实体，脑袋里根本也没有啥值对象，实体的概念，做开发时，基本上都是一个实体对应一张表，老师说的值对象可以嵌入到实体中，其实在设计中并没有这样多想。有了这些概念，然后跟着老师的课程学习，希望以后自己的知识更加体系化。下面是我对思考题的一些不成熟的见解。<br>思考题：实体是业务组成的最小元素，并且也是表示业务形态的唯一标识，实体包含于值对象，值对象是对实体的补充，让实体更加充血丰富，通过值对象和实体的关系，建立的领域模型，可以使得架构面对将来复杂的业务更加灵活多变，我觉得在数据库设计中会有冗余字段信息，一些冗余信息的聚合也可以对应领域的值对象上。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474144,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573535237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150001,"user_name":"huaweichen","can_delete":false,"product_type":"c1","uid":1249907,"ip_address":"","ucode":"974917DE2AE92E","user_header":"https://static001.geekbang.org/account/avatar/00/13/12/73/2183839d.jpg","comment_is_top":false,"comment_ctime":1573443090,"is_pvip":false,"replies":[{"id":"57706","content":"要做DO和PO转换。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573448630,"ip_address":"","comment_id":150001,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1573443090","product_id":100037301,"comment_content":"学了这一课以后，简单的理解就是：<br>在代码里面，人员和地址是两个类，<br>数据库里面，人员和地址是一个表。<br><br>但是请问老师，现在很多地方都会用到ORM，比如Doctrine。如果代码和数据不能很好的map","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474035,"discussion_content":"要做DO和PO转换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573448630,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1249907,"avatar":"https://static001.geekbang.org/account/avatar/00/13/12/73/2183839d.jpg","nickname":"huaweichen","note":"","ucode":"974917DE2AE92E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":48174,"discussion_content":"请问PO是什么啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573457247,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1398824,"avatar":"https://static001.geekbang.org/account/avatar/00/15/58/28/c86340ca.jpg","nickname":"达文西","note":"","ucode":"01C1063F23D634","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1249907,"avatar":"https://static001.geekbang.org/account/avatar/00/13/12/73/2183839d.jpg","nickname":"huaweichen","note":"","ucode":"974917DE2AE92E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":88336,"discussion_content":"\n\n说下我的理解。\n\nDo是领域对象，领域对象对应领域建模中的实体，实体包括了实体属性，值对象，实体方法。\n\n\nPo是持久化对象，一个Po对应数据库里的一张表。\n\n\n领域对象Do是为了实现特定领域功能构建的，它可能包含了1个到多个Po的属性，做好从Do到Po的转换实现，ORM映射的时候只需要做PO的映射就可以了。\n\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576695694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":48174,"ip_address":""},"score":88336,"extra":""}]}]},{"had_liked":false,"id":149379,"user_name":"lw","can_delete":false,"product_type":"c1","uid":1162641,"ip_address":"","ucode":"F7DBFA6A01C911","user_header":"https://static001.geekbang.org/account/avatar/00/11/bd/91/29c2a7fd.jpg","comment_is_top":false,"comment_ctime":1573204865,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573204865","product_id":100037301,"comment_content":"DDD 提倡从领域模型设计出发，而不是先设计数据模型。另一个角度看问题，确实又有不同的收获。","like_count":0},{"had_liked":false,"id":149213,"user_name":"JRich","can_delete":false,"product_type":"c1","uid":1114901,"ip_address":"","ucode":"66AE9D61533960","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/15/293a185d.jpg","comment_is_top":false,"comment_ctime":1573175640,"is_pvip":false,"replies":[{"id":"57353","content":"值对象多条就不适合用属性嵌入的方式了。可以采用json串的方式，不过如果要查询就不能用json串了。如果都不满足，那你还是用实体吧。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573178778,"ip_address":"","comment_id":149213,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573175640","product_id":100037301,"comment_content":"值对象以属性嵌入方式嵌入实体，如果值对象有多条，那实体是不是也要多条才行","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473778,"discussion_content":"值对象多条就不适合用属性嵌入的方式了。可以采用json串的方式，不过如果要查询就不能用json串了。如果都不满足，那你还是用实体吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573178778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147756,"user_name":"Jesen","can_delete":false,"product_type":"c1","uid":1344792,"ip_address":"","ucode":"1CD9A1D525410D","user_header":"https://static001.geekbang.org/account/avatar/00/14/85/18/9f613f78.jpg","comment_is_top":false,"comment_ctime":1572883824,"is_pvip":false,"replies":[{"id":"56938","content":"你说的地址分为两种情况。第一种地址的后台维护，是不是类似个人中心的地址管理，这种情况它应该被设计为实体，数据库中有实体表跟它对应。如果作为订单中的收货地址，这时候它可以设计为值对象。这个值对象以订单中的一个字段的形式存储。地址的数据被存在订单表中。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572915217,"ip_address":"","comment_id":147756,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1572883824","product_id":100037301,"comment_content":"老师你好，有个问题请教一下，在实际开发中碰到地址需要在后台进行维护以提供前端的地址选择使用，如果按照值对象来设计地址，该如何设计使其持久化到数据库呢？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473300,"discussion_content":"你说的地址分为两种情况。第一种地址的后台维护，是不是类似个人中心的地址管理，这种情况它应该被设计为实体，数据库中有实体表跟它对应。如果作为订单中的收货地址，这时候它可以设计为值对象。这个值对象以订单中的一个字段的形式存储。地址的数据被存在订单表中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572915217,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1748911,"avatar":"","nickname":"Geek_aa8017","note":"","ucode":"286195887103C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53887,"discussion_content":"老师你好，引用Jesen的问题，如果实体地址改变了，值对象地址怎么同步呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574229312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146441,"user_name":"孫やさん","can_delete":false,"product_type":"c1","uid":1134895,"ip_address":"","ucode":"C60877C1C71685","user_header":"https://static001.geekbang.org/account/avatar/00/11/51/2f/7b04140c.jpg","comment_is_top":false,"comment_ctime":1572524688,"is_pvip":true,"replies":[{"id":"56552","content":"能帮到你很开心哈<br>","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572532442,"ip_address":"","comment_id":146441,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572524688","product_id":100037301,"comment_content":"有点理解了，对照目前公司现有模型，既有将值对象设计成实体的地方，也有嵌入到实体的地方，感谢老师","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472864,"discussion_content":"能帮到你很开心哈\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572532442,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145848,"user_name":"Mr.Strive.Z.H.L","can_delete":false,"product_type":"c1","uid":1030198,"ip_address":"","ucode":"6D97E159E2EECD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b8/36/542c96bf.jpg","comment_is_top":false,"comment_ctime":1572394719,"is_pvip":false,"replies":[{"id":"56310","content":"1、同一个聚合中的实体是可以相互引用的。<br>2、DDD采用富领域模型，实体有属性和行为，行为对应到系统就是实体的方法。所有与实体相关的实体属性和行为，都在实体类内实现，跨多个实体的数据由领域服务实现。从这个角度来讲，可以保证领域模型的清晰。<br>","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572399395,"ip_address":"","comment_id":145848,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1572394719","product_id":100037301,"comment_content":"老师有两个问题：<br>1. 同一个上下文中，可能存在多个实体，实体与实体之间是不是也存在联系？一个实体包含另一个实体？<br><br>2.现在实践中，往往实体并不是充血模型，内部没有业务逻辑，实际还是一个贫血模型。而是领域服务中来使用实体，构成业务逻辑。不是很明白为什么实体要是充血模型，内部有业务逻辑？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472597,"discussion_content":"1、同一个聚合中的实体是可以相互引用的。\n2、DDD采用富领域模型，实体有属性和行为，行为对应到系统就是实体的方法。所有与实体相关的实体属性和行为，都在实体类内实现，跨多个实体的数据由领域服务实现。从这个角度来讲，可以保证领域模型的清晰。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572399395,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1100064,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","nickname":"zj","note":"","ucode":"E3329CCF694AC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60837,"discussion_content":"跨多个实体的数据由领域服务来实现，，这句话是指的是同一个聚合的多个实体吗？ 还是说跨多个聚合的聚合根（实体）也可以用单独的领域服务来实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574759271,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145788,"user_name":"王麒","can_delete":false,"product_type":"c1","uid":1265260,"ip_address":"","ucode":"330017C5A911B6","user_header":"https://static001.geekbang.org/account/avatar/00/13/4e/6c/71020c59.jpg","comment_is_top":false,"comment_ctime":1572365776,"is_pvip":false,"replies":[{"id":"56306","content":"如果属性嵌入的值对象，查询统计是没有问题的。<br>如果做成了序列化的值对象。不知道你们有没有专门用于统计的系统，如果有，可以将这个表的数据定期迁移到统计分析的系统中去，迁移后改成实体或者属性嵌入的值对象，应该也可以。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572398571,"ip_address":"","comment_id":145788,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572365776","product_id":100037301,"comment_content":"请问老师，如果初期将订单中的地址设计成了VO。但是后期又出现根据地址中的属性进行统计的需求，这种情况如何处理会代价小一些。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472580,"discussion_content":"如果属性嵌入的值对象，查询统计是没有问题的。\n如果做成了序列化的值对象。不知道你们有没有专门用于统计的系统，如果有，可以将这个表的数据定期迁移到统计分析的系统中去，迁移后改成实体或者属性嵌入的值对象，应该也可以。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572398571,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145438,"user_name":"天天向上","can_delete":false,"product_type":"c1","uid":1031113,"ip_address":"","ucode":"5948D359734193","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bb/c9/37924ad4.jpg","comment_is_top":false,"comment_ctime":1572273334,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572273334","product_id":100037301,"comment_content":"实体关注唯一标注和时空延续<br>值对象关注概念分离与完整性，便于交流，和持久存储没关注","like_count":0},{"had_liked":false,"id":145405,"user_name":"张迪","can_delete":false,"product_type":"c1","uid":1104835,"ip_address":"","ucode":"6A5D44999A0FEA","user_header":"https://static001.geekbang.org/account/avatar/00/10/db/c3/e11adfe8.jpg","comment_is_top":false,"comment_ctime":1572267342,"is_pvip":false,"replies":[{"id":"56086","content":"对的，值对象作为整体比较。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572268764,"ip_address":"","comment_id":145405,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572267342","product_id":100037301,"comment_content":"一句话，实体拥有唯一ID，两个实体比较ID相同则两个实体对象是一个实体。值对象比较所有的属性值","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472379,"discussion_content":"对的，值对象作为整体比较。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572268764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145403,"user_name":"张迪","can_delete":false,"product_type":"c1","uid":1104835,"ip_address":"","ucode":"6A5D44999A0FEA","user_header":"https://static001.geekbang.org/account/avatar/00/10/db/c3/e11adfe8.jpg","comment_is_top":false,"comment_ctime":1572267219,"is_pvip":false,"replies":[{"id":"56087","content":"一个订单上的收货地址只可能有一个，这个地址是值对象，它可以被个人中心的其它地址整体替换。<br>而这个收货地址来源于个人中心的地址信息管理，这个收货地址可以是多个，并且是可以修改的，也可以增加和作为筛选条件。在这个环境下个人中心的地址是实体。<br>不同的对象在不同的环境下它的形态是不一样的。不知道你是否理解了？","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572269040,"ip_address":"","comment_id":145403,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1572267219","product_id":100037301,"comment_content":"人员和地址的例子。人员可以有很多收货地址，又需要将收货地址作为筛选条件。这个值对象如何设计？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472377,"discussion_content":"一个订单上的收货地址只可能有一个，这个地址是值对象，它可以被个人中心的其它地址整体替换。\n而这个收货地址来源于个人中心的地址信息管理，这个收货地址可以是多个，并且是可以修改的，也可以增加和作为筛选条件。在这个环境下个人中心的地址是实体。\n不同的对象在不同的环境下它的形态是不一样的。不知道你是否理解了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572269040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1104835,"avatar":"https://static001.geekbang.org/account/avatar/00/10/db/c3/e11adfe8.jpg","nickname":"张迪","note":"","ucode":"6A5D44999A0FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40951,"discussion_content":"理解了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572310999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145402,"user_name":"张迪","can_delete":false,"product_type":"c1","uid":1104835,"ip_address":"","ucode":"6A5D44999A0FEA","user_header":"https://static001.geekbang.org/account/avatar/00/10/db/c3/e11adfe8.jpg","comment_is_top":false,"comment_ctime":1572267115,"is_pvip":false,"replies":[{"id":"56088","content":"DDD先建立领域模型，再根据领域模型来进行微服务的代码设计，设计完代码的实体等领域对象后，才进行DB的设计。这样才能保证系统与领域模型的一致性。也就是领域模型设计优先，而不是数据库设计优先。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572269158,"ip_address":"","comment_id":145402,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572267115","product_id":100037301,"comment_content":"使用DDD 是不是必须使用Code first方式编码，而不能使用DB first编码","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472376,"discussion_content":"DDD先建立领域模型，再根据领域模型来进行微服务的代码设计，设计完代码的实体等领域对象后，才进行DB的设计。这样才能保证系统与领域模型的一致性。也就是领域模型设计优先，而不是数据库设计优先。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572269158,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144982,"user_name":"飞扬","can_delete":false,"product_type":"c1","uid":1161142,"ip_address":"","ucode":"F2E6C39A4E63E7","user_header":"https://static001.geekbang.org/account/avatar/00/11/b7/b6/c324a7de.jpg","comment_is_top":false,"comment_ctime":1572148205,"is_pvip":false,"replies":[{"id":"55963","content":"两者都是一种设计方法和思想。DDD面可能会更广泛一些，它包括战略设计和战术设计，战略设计主要是面向领域建模，战术设计是系统落地。它更面向对象设计一致的地方是在战术设计这个过程，DDD实际的系统落地也是面向对象的方法。在系统设计和建设过程中两者的实体基本是一致的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572226805,"ip_address":"","comment_id":144982,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572148205","product_id":100037301,"comment_content":"领域驱动设计和面向对象设计什么关系和区别，领域驱动设计实体和面向对象涉及实体是一个概念吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472198,"discussion_content":"两者都是一种设计方法和思想。DDD面可能会更广泛一些，它包括战略设计和战术设计，战略设计主要是面向领域建模，战术设计是系统落地。它更面向对象设计一致的地方是在战术设计这个过程，DDD实际的系统落地也是面向对象的方法。在系统设计和建设过程中两者的实体基本是一致的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572226805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144850,"user_name":"liuchangit","can_delete":false,"product_type":"c1","uid":1209215,"ip_address":"","ucode":"340AC5EE9522D0","user_header":"https://static001.geekbang.org/account/avatar/00/12/73/7f/5cc5ac12.jpg","comment_is_top":false,"comment_ctime":1572074558,"is_pvip":false,"replies":[{"id":"55871","content":"收货地址是嵌入订单中，不是用户中。<br>在个人中心维护的多个收货地址是以实体的形式存在的，在维护地址的时候，地址信息可以修改，所以是实体。<br>而订单的收货地址只可能有一个，这个地址来源于个人中心的某一个收货地址。一旦这个收货地址被嵌入到订单，它就不能修改了，如果修改的话，也只能被个人中心的另外一个地址来整体替换。所以它以值对象的形式存在。<br>而地址以属性嵌入的方式嵌入订单时，就不需要做联表关联查询，所以它能提高性能。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572088462,"ip_address":"","comment_id":144850,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572074558","product_id":100037301,"comment_content":"老师讲，值对象能&quot;简化数据库的设计、提升数据库性能&quot;，简化设计我没有疑问，关于提升性能，我有些疑惑，比如电商业务，收货地址作为值对象，以属性嵌入或序列化大对象方式嵌入用户实体，由于电商的个人信息页面一般只展示姓名、性别等基本信息，收货地址只在下订单或单独的地址管理页才会用到，那么在个人信息页加载实体时会不必要地读取地址数据，同样在地址管理页也会读取到其它不需要的用户属性，这会增加数据库的IO和网络流量，降低性能（假如重复地址很多的话，还会占用大量数据库磁盘空间）。如果采用延迟加载、按需读取地址数据，又会造成实体内部实现复杂，若实体的值对象属性过多，更是如此。希望老师解答下，这个有什么好的解决方案吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472135,"discussion_content":"收货地址是嵌入订单中，不是用户中。\n在个人中心维护的多个收货地址是以实体的形式存在的，在维护地址的时候，地址信息可以修改，所以是实体。\n而订单的收货地址只可能有一个，这个地址来源于个人中心的某一个收货地址。一旦这个收货地址被嵌入到订单，它就不能修改了，如果修改的话，也只能被个人中心的另外一个地址来整体替换。所以它以值对象的形式存在。\n而地址以属性嵌入的方式嵌入订单时，就不需要做联表关联查询，所以它能提高性能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572088462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144606,"user_name":"李伟","can_delete":false,"product_type":"c1","uid":1678806,"ip_address":"","ucode":"C93562CE6A1A83","user_header":"https://static001.geekbang.org/account/avatar/00/19/9d/d6/47fb2517.jpg","comment_is_top":false,"comment_ctime":1571978367,"is_pvip":false,"replies":[{"id":"55740","content":"是这样的。<br>如果不是大型企业级应用的话，传统数据驱动设计成本和投入可能更低。但没必要用微服务架构，微服务需要配套很多的自动化的开发和运维工具，以及如容器之类的云计算环境，才能发挥微服务的最大效能。如果不具备这些条件，采用集中式架构可能投入更低，运维也不那么复杂。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571983589,"ip_address":"","comment_id":144606,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571978367","product_id":100037301,"comment_content":"微服务在做设计的时候一般有两个方法论之说，一个是通过ddd领域驱动去做设计，这种是大型软件的方案，还有一种也有说是通过数据驱动去做设计，这是一般可能前期效果和投入都比较小的情况下去做的。请问作者怎么看？谢谢！","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472028,"discussion_content":"是这样的。\n如果不是大型企业级应用的话，传统数据驱动设计成本和投入可能更低。但没必要用微服务架构，微服务需要配套很多的自动化的开发和运维工具，以及如容器之类的云计算环境，才能发挥微服务的最大效能。如果不具备这些条件，采用集中式架构可能投入更低，运维也不那么复杂。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571983589,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143983,"user_name":"y3","can_delete":false,"product_type":"c1","uid":1128084,"ip_address":"","ucode":"C93F8EC2AAACF6","user_header":"https://static001.geekbang.org/account/avatar/00/11/36/94/5aecb0ef.jpg","comment_is_top":false,"comment_ctime":1571820128,"is_pvip":false,"replies":[{"id":"55557","content":"第一个问题：单一值对象你可以理解为属性集值对象的特殊形式，它是可以整体替换的，或者它就是实体的一个属性，修改的时候是整体替换。<br>第二个问题：如果属性多，但是字段长度不大，也是可以设计成值对象的。不过你要避免值对象面对查询统计时的问题，出现这种情况时，就不要设计成值对象了。<br>","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571821885,"ip_address":"","comment_id":143983,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1571820128","product_id":100037301,"comment_content":"老师和学员们都总结的很不错，我在这里就不继续做总结了。但是我提出2个问题：<br>1. 既然值对象是不可修改的，那么我在用java定义值对象单一属性的时候，是否需要用final关键字来限定？例如值对象属性 private fianl String name<br>2.值对象中的属性是否不宜定义的过多？假如属性过多，会变成大对象，进而引发fullGC。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471768,"discussion_content":"第一个问题：单一值对象你可以理解为属性集值对象的特殊形式，它是可以整体替换的，或者它就是实体的一个属性，修改的时候是整体替换。\n第二个问题：如果属性多，但是字段长度不大，也是可以设计成值对象的。不过你要避免值对象面对查询统计时的问题，出现这种情况时，就不要设计成值对象了。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571821885,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1128084,"avatar":"https://static001.geekbang.org/account/avatar/00/11/36/94/5aecb0ef.jpg","nickname":"y3","note":"","ucode":"C93F8EC2AAACF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38714,"discussion_content":"好的，谢谢欧老师。😊😊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571822365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143801,"user_name":"煜","can_delete":false,"product_type":"c1","uid":1650785,"ip_address":"","ucode":"3C5A9A55A65FC9","user_header":"https://static001.geekbang.org/account/avatar/00/19/30/61/50e24e09.jpg","comment_is_top":false,"comment_ctime":1571793811,"is_pvip":false,"replies":[{"id":"55516","content":"如果DO和PO不是一一对应的话，还需要进行数据的重新组装。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571797589,"ip_address":"","comment_id":143801,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571793811","product_id":100037301,"comment_content":"老师，如果这样的话那使用传统的ORM框架或者半ORM框架还能直接映射成实体和值对象吗","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471695,"discussion_content":"如果DO和PO不是一一对应的话，还需要进行数据的重新组装。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571797589,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143754,"user_name":"shawn","can_delete":false,"product_type":"c1","uid":1053716,"ip_address":"","ucode":"8F7CE170AE1F57","user_header":"","comment_is_top":false,"comment_ctime":1571788903,"is_pvip":false,"replies":[{"id":"55506","content":"值对象有优势和劣势，需要根据你的业务场景来设计。所以设计时你要权衡，如果不能规避值对象的劣势，那就设计成实体。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571793651,"ip_address":"","comment_id":143754,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571788903","product_id":100037301,"comment_content":"地址作为实体合适，作为值来存储估计会影响扩展性，例如一个人有若干地址，还有默认地址，还要在业务上统计每个地区多少发货量，作成值维护，肯定死人","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471670,"discussion_content":"值对象有优势和劣势，需要根据你的业务场景来设计。所以设计时你要权衡，如果不能规避值对象的劣势，那就设计成实体。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571793651,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143588,"user_name":"杨杰","can_delete":false,"product_type":"c1","uid":1131823,"ip_address":"","ucode":"74817EA9499843","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/2f/b0b0dd74.jpg","comment_is_top":false,"comment_ctime":1571737999,"is_pvip":false,"replies":[{"id":"55510","content":"你可以把数据字典某一个代码的ID和名称作为一个值对象整体存储下来。当然你还需要考虑这个代码是否还要做查询和统计，如果有的话就不合适。<br>值对象的设计需要结合你的业务场景，不合适的话就用实体，所以我多次强调要选择自己最合适的哈。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571795237,"ip_address":"","comment_id":143588,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571737999","product_id":100037301,"comment_content":"“在值对象中也有部分共享的标准类型的值对象，它们有自己的限界上下文，有自己的持久化对象，可以建立共享的数据类微服务，比如数据字典”。<br>对于值对象一直是似懂非懂，有的时候甚至感觉值对象有点儿多余。比如上面提到的数据字典。在业务处理的过程中，往往不是只存一个数据字典的名称，而有可能需要数据字典做一下判断。在业务系统系统里面存的时候往往数据字典的ID和名称都需要存储下来。感觉用值对象不太合适。<br>唯一觉得用值对象比较合适的就是系统里面定死了类似于状态为之类的内码。<br>","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471609,"discussion_content":"你可以把数据字典某一个代码的ID和名称作为一个值对象整体存储下来。当然你还需要考虑这个代码是否还要做查询和统计，如果有的话就不合适。\n值对象的设计需要结合你的业务场景，不合适的话就用实体，所以我多次强调要选择自己最合适的哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571795237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143581,"user_name":"杨杰","can_delete":false,"product_type":"c1","uid":1131823,"ip_address":"","ucode":"74817EA9499843","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/2f/b0b0dd74.jpg","comment_is_top":false,"comment_ctime":1571736699,"is_pvip":false,"replies":[{"id":"55433","content":"这种情况就不适合做值对象了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571743535,"ip_address":"","comment_id":143581,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571736699","product_id":100037301,"comment_content":"关于person和address的例子里面，如果这些地址是数据字典表（有地址ID和地址名称），需要频繁的统计分析。那么作为值对象是不是就不太合适了？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471604,"discussion_content":"这种情况就不适合做值对象了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571743535,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143534,"user_name":"白开水有三种味道","can_delete":false,"product_type":"c1","uid":1678696,"ip_address":"","ucode":"5706E8C4D284D6","user_header":"https://static001.geekbang.org/account/avatar/00/19/9d/68/75e6f912.jpg","comment_is_top":false,"comment_ctime":1571726746,"is_pvip":false,"replies":[{"id":"55426","content":"产品设计的时候能到大致的实体就可以了。领域模型向微服务设计时，需要明确到聚合根、实体、值对象，领域服务和应用服务等对象，还要明确他们的组合和依赖关系等很细致的内容，建立领域对象与代码对象的映射关系。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571734812,"ip_address":"","comment_id":143534,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571726746","product_id":100037301,"comment_content":"老师你好，产品经理在产品设计时，是否需要将微服务拆到&quot;实体、值对象&quot;那么细？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471582,"discussion_content":"产品设计的时候能到大致的实体就可以了。领域模型向微服务设计时，需要明确到聚合根、实体、值对象，领域服务和应用服务等对象，还要明确他们的组合和依赖关系等很细致的内容，建立领域对象与代码对象的映射关系。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571734812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143499,"user_name":"每一朵云都下落不明","can_delete":false,"product_type":"c1","uid":1495494,"ip_address":"","ucode":"8DB497A890C370","user_header":"https://static001.geekbang.org/account/avatar/00/16/d1/c6/3cbbe7f8.jpg","comment_is_top":false,"comment_ctime":1571718104,"is_pvip":false,"replies":[{"id":"55399","content":"值对象依附于实体，它是不可修改的，只能整体替换。有时候值对象的数据的值来源于第三方应用或者上游业务的微服务。在其他地方可能是实体，但形成数据后会以值对象的形式依附于下游的某个实体对象。实体对象消失，那这个值对象也就消失了。所以值对象不会产生污染的问题。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571721712,"ip_address":"","comment_id":143499,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571718104","product_id":100037301,"comment_content":"如果值对象发生改变，所有共享该值的对象都受到影响，不希望发生改变的其他对象不就被污染了吗?<br>值对象的作用域划分也需要注意吗?","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471564,"discussion_content":"值对象依附于实体，它是不可修改的，只能整体替换。有时候值对象的数据的值来源于第三方应用或者上游业务的微服务。在其他地方可能是实体，但形成数据后会以值对象的形式依附于下游的某个实体对象。实体对象消失，那这个值对象也就消失了。所以值对象不会产生污染的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571721712,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143440,"user_name":"赵立","can_delete":false,"product_type":"c1","uid":1326826,"ip_address":"","ucode":"3EFBB14465C20F","user_header":"https://static001.geekbang.org/account/avatar/00/14/3e/ea/43502ec7.jpg","comment_is_top":false,"comment_ctime":1571709010,"is_pvip":false,"replies":[{"id":"55388","content":"你理解的没错，属性的变与不变是实体和值对象很重要的一个区别。<br>从领域模型来看，实体相对来说是一个实实在在的领域对象，值对象主要用于描述的，用于对实体的属性的描述。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571711723,"ip_address":"","comment_id":143440,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571709010","product_id":100037301,"comment_content":"对于对象而言，我们关注的都是其中代表业务含义的属性。对象中属性变了，它还代表同一个对象，那就是实体，要给它个不会变化的标志。对象中属性变了代表不同的对象，那就是值对象。根本就是对象属性变与不变","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471538,"discussion_content":"你理解的没错，属性的变与不变是实体和值对象很重要的一个区别。\n从领域模型来看，实体相对来说是一个实实在在的领域对象，值对象主要用于描述的，用于对实体的属性的描述。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571711723,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143328,"user_name":"肖大保健","can_delete":false,"product_type":"c1","uid":1306868,"ip_address":"","ucode":"E3209A00C1B954","user_header":"https://static001.geekbang.org/account/avatar/00/13/f0/f4/22dbe2d9.jpg","comment_is_top":false,"comment_ctime":1571669616,"is_pvip":false,"replies":[{"id":"55381","content":"值对象是依附于实体的，在数据库存储的时候，有两种方式：第一种方式是作为实体的完整属性嵌入实体中，值对象的属性作为实体的属性存在，这种方式属性比较零散，没有完整的业务概念。第二种方式是在实体表中建一个值对象的字段，这个字段保存值对象的所有属性的值，数据格式可以是JSON，也可以是其他格式。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571707383,"ip_address":"","comment_id":143328,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571669616","product_id":100037301,"comment_content":"理论上实体和对象，两个都是实际项目种的DTO，根据业务的需求不同，一个业务实体被定义成dto简称实体，另外一个对外另外一个dto的引用（相当于一个字段属性）就相当于对象，但是在另外一个场景，也有可能现在的实体被其他dto进行引用那就是对象了，主要还是针对业务场景来说。<br>主要与传统模式数据库区别在于，A表跟B表进行关联，不必要在A表中加各种与B表有关系的字段，直接加一个存B表数据的字段，譬如一张用户地址表，那么表中有用户信息就行了，地址相关的省市区名称code另开一张表静态表就行了，用户地址表加一个地址字段存地址Json数据就行了<br>我这么理解不知道对不对！","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471490,"discussion_content":"值对象是依附于实体的，在数据库存储的时候，有两种方式：第一种方式是作为实体的完整属性嵌入实体中，值对象的属性作为实体的属性存在，这种方式属性比较零散，没有完整的业务概念。第二种方式是在实体表中建一个值对象的字段，这个字段保存值对象的所有属性的值，数据格式可以是JSON，也可以是其他格式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571707383,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143134,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1571636141,"is_pvip":false,"replies":[{"id":"55293","content":"是这样的。如果是序列化的话，在数据库的实体表会有一个字段来存储值对象的Json串，这个字段就叫地址，地址保存的这个串包含若干个属性的数据。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571640159,"ip_address":"","comment_id":143134,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1571636141","product_id":100037301,"comment_content":"先回答问题<br>1.值对象和实体对象的区别，见名知意。两者都是对象，都是一系列属性的集合。前者重心在值后者重心在实体。在一个限界上下文中，划分为实体的属性集中需要具备唯一性，还需要伴随一些行为的实现，也就是满足充血模型的构建。而值对象则只要承接一些属性的传输，属性集中不一定要具备唯一性，属性不需要伴随行为，可以认定为贫血模型。在不同的限界上下文中，值对象和实体对象这两类属性集的立场还会相互转变。比如一个订单，在财务系统，其金额相关的字段就属于实体对象的属性集，地址相关的字段就属于值对象属性集。而在物流系统，地址相关字段会属于实体对象的属性集，而金额相关字段，就可能属于值对象的属性集（不排除物流拆单会根据金额做拆分，毕竟有报关的业务）。<br><br>提问题<br>1.值对象在当前限界上下文的微服务中，如果存储，以什么形式存储？做为一个字段放在实体对应的表中，然后存取时做序列化？如此的话，是不是还得冗余一个字段做序列化中间产物存表时用？望老师解惑。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471395,"discussion_content":"是这样的。如果是序列化的话，在数据库的实体表会有一个字段来存储值对象的Json串，这个字段就叫地址，地址保存的这个串包含若干个属性的数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571640159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":37612,"discussion_content":"值对象的设计要结合你的业务场景，选择最合适的方式。Json格式只是一种方式，你可以选择适合自己的存储格式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571646025,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":37583,"discussion_content":"1.这样存就放弃了垂直拆分。如果是大数据量的数据，数据存储将会受限，该怎么去缓解这个性能问题？\n2.存储的话压缩是否比json好点，毕竟json存还是比较占空间的。对于数据存储和网络io传输都不大好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571640489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143118,"user_name":"K战神","can_delete":false,"product_type":"c1","uid":1139367,"ip_address":"","ucode":"527E6BB26BB766","user_header":"https://static001.geekbang.org/account/avatar/00/11/62/a7/3e6fee86.jpg","comment_is_top":false,"comment_ctime":1571633972,"is_pvip":false,"replies":[{"id":"55286","content":"主要还是从领域模型出发，减少数据库的表。同时又能保证概念的完整性。实体和值对象都可以实现你的业务逻辑，具体实现方式要根据场景来分析。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571636194,"ip_address":"","comment_id":143118,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1571633972","product_id":100037301,"comment_content":"关注点不同，实体和值对象根据关注点不同可以进行互换。<br><br>","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471391,"discussion_content":"主要还是从领域模型出发，减少数据库的表。同时又能保证概念的完整性。实体和值对象都可以实现你的业务逻辑，具体实现方式要根据场景来分析。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571636194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1139367,"avatar":"https://static001.geekbang.org/account/avatar/00/11/62/a7/3e6fee86.jpg","nickname":"K战神","note":"","ucode":"527E6BB26BB766","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":37654,"discussion_content":"我还得多实践，相信会从这里得到更多经验","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571653628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143095,"user_name":"吃饭饭","can_delete":false,"product_type":"c1","uid":1231549,"ip_address":"","ucode":"95CFA07CDA2957","user_header":"https://static001.geekbang.org/account/avatar/00/12/ca/bd/a51ae4b2.jpg","comment_is_top":false,"comment_ctime":1571628931,"is_pvip":false,"replies":[{"id":"55287","content":"实体大多数情况下跟数据库持久化对象是一一对应的，也有不一一对应的时候。<br>值对象是一些不会修改，只能完整替换的属性值的集合，你更关注他的属性和值，它没有太多的业务行为，用于描述实体的一些属性集，被实体引用，依附于实体的值对象基本没有自己的数据库表。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571636557,"ip_address":"","comment_id":143095,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571628931","product_id":100037301,"comment_content":"几个问题：<br>1）实体以 DO（领域对象）的形式存在，每个实体对象都有唯一的 ID； 这里怎么理解：是指表数据中的某一条吗？<br>2）值对象类似于 Java 对象里的对象关联吧？区别只是是否有对应的表数据，看描述这也不是绝对的，有点分不清","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471384,"discussion_content":"实体大多数情况下跟数据库持久化对象是一一对应的，也有不一一对应的时候。\n值对象是一些不会修改，只能完整替换的属性值的集合，你更关注他的属性和值，它没有太多的业务行为，用于描述实体的一些属性集，被实体引用，依附于实体的值对象基本没有自己的数据库表。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571636557,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143087,"user_name":"江河顺水","can_delete":false,"product_type":"c1","uid":1240807,"ip_address":"","ucode":"8FE80FB71DD63E","user_header":"https://static001.geekbang.org/account/avatar/00/12/ee/e7/450fe9eb.jpg","comment_is_top":false,"comment_ctime":1571628209,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571628209","product_id":100037301,"comment_content":"实体有唯一标识符，包含了属性和业务逻辑处理的内容。值对象一般只包含描述信息，当然不同场景下内容是有区别的，不能一概而论。","like_count":0},{"had_liked":false,"id":143079,"user_name":"心浮天空","can_delete":false,"product_type":"c1","uid":1051609,"ip_address":"","ucode":"3B2D0E6CC51EE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/0b/d9/3328dd12.jpg","comment_is_top":false,"comment_ctime":1571627557,"is_pvip":true,"replies":[{"id":"55291","content":"理解到位。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571637182,"ip_address":"","comment_id":143079,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571627557","product_id":100037301,"comment_content":"不知道对于实体和值对象的区别理解的是否正确:<br>1.  实体具有唯一性, 表现为具有唯一标识, 在实体对象的整个生命周期内不变，即使除了唯一标识外的其它所有属性信息都发生了变化, 这个对象始终代表着同一对象。 而值对象不独立存在, 一般依附于实体而存在, 没有唯一标识, 或者说值对象的全部属性合在一起作为唯一标识, 所以当任何属性发生变化时, 都意味着新的值对象产生, 实践中当值对象信息发生变化时一般直接使用新的值对象来替换原来的值对象.<br>2. 实体可以具有业务行为和逻辑, 而值对象没有, 值对象仅作为信息的载体出现.<br>3. 值对象可能是实体的副本.  例如: 在电商系统中, 收货人地址管理就是一个实体(可以单独修改收货人的具体信息，例如: 名称、手机号、地址等), 而订单中的收货人就是一个值对象,  订单中的收货人是收货人地址的副本, 在订单创建后其信息就不能修改, 而是通过替换新的收货人地址的方式来整体替换. 这种整体替换的方式修改值对象, 是一种约定, 而非技术原因。<br>4. 实体对应到数据库中, 会以具体表的形式体现, 而值对象不一定有具体的表对应, 可能直接存储在实体表中。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471378,"discussion_content":"理解到位。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571637182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143066,"user_name":"mgxian","can_delete":false,"product_type":"c1","uid":1014806,"ip_address":"","ucode":"7B7E77E6A83B87","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7c/16/4d1e5cc1.jpg","comment_is_top":false,"comment_ctime":1571625585,"is_pvip":false,"replies":[{"id":"55271","content":"是的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571626981,"ip_address":"","comment_id":143066,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571625585","product_id":100037301,"comment_content":"实体有唯一ID，实体是通过ID来区分不同实体的，值对象是通过属性来区分不同值对象的，即时实体的属性都发生了改变，只要它的ID还是原来的ID，实体还是那个实体。值对象只要改变了属性值，就已经不是原来的值对象了。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471371,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571626981,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143062,"user_name":"TH","can_delete":false,"product_type":"c1","uid":1053413,"ip_address":"","ucode":"C5EA20546DC09C","user_header":"https://static001.geekbang.org/account/avatar/00/10/12/e5/592d9324.jpg","comment_is_top":false,"comment_ctime":1571625289,"is_pvip":true,"replies":[{"id":"55273","content":"你把单一值对象理解成实体的属性就可以了。一般大家说得比较多的是具有完整概念的集合，这可能也是大家一直习惯的值对象。我刚开始也是一直这么认为的，哈哈。<br>属性嵌入在数据库是一种储存格式，数据实体中他们保存在一个表里面，在运行会有实体和值对象两个对象，实体引用值对象。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571627378,"ip_address":"","comment_id":143062,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571625289","product_id":100037301,"comment_content":"在“值对象的代码形态”部分给出的代码片段中，为什么把person类的属性也称为是单一值对象呢？它们不应该是属于实体属性吗？难道说任意一个实体的非可变属性都可以看作是值对象？那么在什么情况下需要为值对象独立建模呢？<br><br>另外，如果采用属性嵌入的方式，那么获取人员所在的省应该是person.province还是person.address.province呢？<br><br>关于数据库设计，我的理解是以前面向数据模型的设计大家会普遍把数据关系用关系型数据库本身来实现，而现在很多系统的设计理念是数据库只用作数据存储，而数据的关系和逻辑都在上层由业务代码来拼合。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471367,"discussion_content":"你把单一值对象理解成实体的属性就可以了。一般大家说得比较多的是具有完整概念的集合，这可能也是大家一直习惯的值对象。我刚开始也是一直这么认为的，哈哈。\n属性嵌入在数据库是一种储存格式，数据实体中他们保存在一个表里面，在运行会有实体和值对象两个对象，实体引用值对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571627378,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143040,"user_name":"切糕","can_delete":false,"product_type":"c1","uid":1185409,"ip_address":"","ucode":"DCD3C14CAC4ED3","user_header":"https://static001.geekbang.org/account/avatar/00/12/16/81/77f84354.jpg","comment_is_top":false,"comment_ctime":1571623461,"is_pvip":false,"replies":[{"id":"55276","content":"是这样的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571627883,"ip_address":"","comment_id":143040,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571623461","product_id":100037301,"comment_content":"虽然我们项目不是按照DDD设计的，但我还是结合自己所在的团队的项目中的一部分来分析下“实体和值对象”，我们的项目主要是为业务方提供账单服务。首先，介绍下业务，业务方会同步订单过来，同时附带一些第三方的接口参数，收付款方的信息。<br>对于我们来讲“订单”就是一个实体对象，而第三方参数是仅保存不提供修改的对象，所以可以设计为一个“值对象”。而对于收付款方的信息，为了更利于查询，我们将其设计成一个实体。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471357,"discussion_content":"是这样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571627883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142955,"user_name":"北天魔狼","can_delete":false,"product_type":"c1","uid":1188144,"ip_address":"","ucode":"C22623ECEB8DBA","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/30/8ecce1e1.jpg","comment_is_top":false,"comment_ctime":1571611231,"is_pvip":true,"replies":[{"id":"55250","content":"你对值对象的理解是对的。值对象一般都是作为一个整体看待。<br>实体实例化后的 DO ‘’对象‘’，DO（Domain Object）这里是领域对象，所以这里我就加了对象两个字。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571620658,"ip_address":"","comment_id":142955,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571611231","product_id":100037301,"comment_content":"我认为数据集被整体创建，整体读取，修改需求少时可以设计成值对象<br><br>3. 值对象的运行形态<br><br>实体实例化后的 DO ‘’对象‘’的业务属性和业务行为非常丰富<br>“对象”是否应改为“对映”<br>","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471338,"discussion_content":"你对值对象的理解是对的。值对象一般都是作为一个整体看待。\n实体实例化后的 DO ‘’对象‘’，DO（Domain Object）这里是领域对象，所以这里我就加了对象两个字。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571620658,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}