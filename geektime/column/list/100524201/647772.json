{"id":647772,"title":"26｜图：深度优先遍历（DFS）与广度优先遍历（BFS）","content":"<p>你好，我是王健伟。</p><p>上节课我们讲述了邻接矩阵、邻接表、十字链表、邻接多重表、边集数组共5种数据结构，解决了对图进行存储的问题。接下来的问题， 就是对图进行遍历了。</p><p>所谓图的遍历，就是指从图中任意一个顶点出发访遍图中其余<strong>顶点</strong>，且使每个顶点<strong>都被访问</strong>且<strong>只被访问一次</strong>。</p><p>图的遍历比树的遍历复杂很多，因为图中可能存在回路<span class=\"reference\">（环）</span>，因此遍历过程中需要标记每个已访问过的顶点以避免同一个顶点被访问多次。不过不用有什么负担，我会对照着代码给你讲透，这样既能理解，又方便你之后自己编写代码。</p><p>图的遍历通常分为两种：深度优先遍历、广度优先遍历。本节我们以<strong>邻接表</strong>作为图的存储结构来讲解这两种遍历。</p><h2>深度优先遍历</h2><p>深度优先遍历也称为深度优先搜索，英文名是Depth First Search<span class=\"reference\">（DFS）</span>。这种遍历其实是一个递归的过程，沿着每一个分支路径进行深入访问，很像一棵树的前序遍历。</p><p>你可以想象成进入到一个迷宫中，迷宫中有很多岔路，选择任意一条路走进去，一直到发现走不通的时候退回到上一个岔路口并重新选择一条路走进去，直到走遍所有关键节点。</p><p>针对前面用邻接表这种存储方式实现的图，我们可以在其中继续增加代码来实现对图的深度优先遍历。你可以看下相关的代码。</p><!-- [[[read_end]]] --><pre><code class=\"language-plain\">//深度优先遍历\nvoid DepthFirstSearch(const T&amp; tmpv) //tmpv代表从该顶点出发开始遍历，即tmpv是开始遍历的起始顶点\n{\n\tbool vVArray[MaxVertices_size];&nbsp; //顶点是否被访问过的标记，false没有被访问过，true被访问过\n\tfor (int i = 0; i &lt; MaxVertices_size; ++i) //开始时所有顶点都没有被访问过\n\t{\n\t\tvVArray[i] = false;&nbsp;\n\t} //end for\n\t\n\tint idx = GetVertexIdx(tmpv);\n\tDepthFirstSearch(idx, vVArray);\n}\nvoid DepthFirstSearch(int idx, bool vVArray[])\n{\n\tcout &lt;&lt; m_VertexArray[idx].data &lt;&lt;\"--&gt;\"; //输出顶点数据（顶点值）\n\tvVArray[idx] = true; //标记该顶点已经被访问过\n\t\n\tint idx2 = GetFirstNeighbor(idx); //获取第一个邻接顶点的下标，B的第一个邻接顶点是F\t\n\twhile (idx2 != -1)\n\t{\n\t\t//(1)继续沿着深度访问节点\n\t\tif (vVArray[idx2] == false)\n\t\t{\n\t\t\t//没访问过，则进行递归访问\n\t\t\tDepthFirstSearch(idx2, vVArray);\n\t\t}\n\t\t\n\t\t//(2)找其他的邻接顶点（广度方向走）\n\t\tidx2 = GetNextNeightbor(idx, idx2);&nbsp; //获取某个顶点（下标为idx）的邻接顶点（下标为idx2）的下一个邻接顶点的下标\n\t} //end while\t\t\n\treturn;\n}\n</code></pre><p>之后，修改main主函数中的代码，将一些删除图中顶点、边的代码注释掉并增加如下代码以测试图的深度优先遍历。</p><pre><code class=\"language-plain\">gm2.DepthFirstSearch('B');\ncout &lt;&lt;\"nullptr\"&lt;&lt; endl;\n</code></pre><p>上面的代码表示从顶点B开始进行图的深度优先遍历，整个代码的执行就会是这样的。</p><p><img src=\"https://static001.geekbang.org/resource/image/cd/b5/cd9b8a7fa34456de370eed4d258c7bb5.jpg?wh=2252x728\" alt=\"\"></p><p>结果中，最后一行就是深度优先遍历的结果。从结果中不难看到深度优先遍历的顺序，我们尝试把它梳理出来。</p><ul>\n<li>顶点B<span class=\"reference\">（下标1）</span>作为遍历的开始顶点，肯定会最先被访问。</li>\n<li>取得顶点B的第一个邻接顶点F<span class=\"reference\">（下标5）</span>，因该顶点没被访问过所以进行访问。</li>\n<li>取得顶点F的第一个邻接顶点D<span class=\"reference\">（下标3）</span>，因该顶点没被访问过所以进行访问。</li>\n<li>取得顶点D的第一个邻接顶点F<span class=\"reference\">（下标5）</span>，因为该顶点已被访问过，所以取得顶点D的下一个<span class=\"reference\">（第二个）</span>邻接顶点A<span class=\"reference\">（下标0）</span>，因该顶点没被访问过所以进行访问。</li>\n<li>取得顶点A的第一个邻接顶点D<span class=\"reference\">（下标3）</span>，因为该顶点已被访问过，所以取得顶点A的下一个<span class=\"reference\">（第二个）</span>邻接顶点C<span class=\"reference\">（下标2）</span>，因该顶点没被访问过所以进行访问。</li>\n<li>取得顶点C的第一个邻接顶点F<span class=\"reference\">（下标5）</span>，因为该顶点已被访问过，所以取得顶点C的下一个<span class=\"reference\">（第二个）</span>邻接顶点A<span class=\"reference\">（下标0）</span>，因为该顶点已被访问过，所以取得顶点C的下一个<span class=\"reference\">（第三个）</span>邻接顶点，但此时顶点C已经没有下一个邻接顶点了，因此返回到顶点A的处理流程。</li>\n<li>取得顶点A的下一个<span class=\"reference\">（第三个）</span>邻接顶点B<span class=\"reference\">（下标1）</span>，因为该顶点已被访问过，所以取得顶点A的下一个<span class=\"reference\">（第四个）</span>邻接顶点，但此时顶点A已经没有下一个邻接顶点了，因此返回到顶点D的处理流程。</li>\n<li>取得顶点D的下一个<span class=\"reference\">（第三个）</span>邻接顶点，但此时顶点D已经没有下一个邻接顶点，因此返回到顶点F的处理流程。</li>\n<li>取得顶点F的下一个<span class=\"reference\">（第二个）</span>邻接顶点C<span class=\"reference\">（下标2）</span>，因为该顶点已经被访问过，所以取得顶点F的下一个<span class=\"reference\">（第三个）</span>邻接顶点B<span class=\"reference\">（下标1）</span>，因为该顶点已经被访问过，所以取得顶点F的下一个<span class=\"reference\">（第四个）</span>邻接顶点，但此时顶点F已经没有下一个邻接顶点了，因此返回到顶点B的处理流程。</li>\n<li>取得顶点B的下一个邻接顶点<span class=\"reference\">（第二个）</span>邻接点E<span class=\"reference\">（下标4）</span>，因为该顶点没被访问过所以进行访问。</li>\n<li>取得顶点E的第一个邻接顶点B<span class=\"reference\">（下标1）</span>，但因为该顶点已被访问过，所以取得顶点E的下一个邻接顶点，但此时顶点E已经没有下一个邻接顶点了，因此返回到顶点B的处理流程。</li>\n<li>取得顶点B的下一个邻接顶点<span class=\"reference\">（第三个）</span>邻接顶点A<span class=\"reference\">（下标0）</span>，但因为该顶点已被访问过，所以取得顶点B的下一个邻接顶点，但此时顶点B已经没有下一个邻接顶点了，因此整个遍历过程结束。</li>\n</ul><p>整个深度优先遍历的顺序示意图如图1所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/37/44/37bd33909b2539627625947b159c7a44.jpg?wh=1011x449\" alt=\"\" title=\"图1 一个图采用邻接表存储时以顶点B作为起点进行深度优先遍历的顶点遍历顺序示意图\"></p><p>在图1中，一共有6个顶点，并且通过5<span class=\"reference\">（顶点数-1，即6-1）</span>条边<span class=\"reference\">（图中标记了数字的边）</span>遍历了所有这6个顶点，如果仅保留图中这5条边，则得到了一棵树<span class=\"reference\">（没有回路存在）</span>，如图2所示，这个树就叫做该图所对应的深度优先生成树：</p><p><img src=\"https://static001.geekbang.org/resource/image/b7/29/b7a0e32aed2c93a07a9d04af54fa0b29.jpg?wh=1109x719\" alt=\"\" title=\"图2 一个图采用邻接表存储时对应的深度优先生成树（两幅图画的是同一棵树）\"></p><p>图2这棵深度优先生成树是对原图进行深度优先遍历的过程得到的。显然，遍历的顺序决定了深度优先生成树的样子。而在以邻接表作为图的存储结构时，由于边节点结构的插入方式可以采用头插或者尾插方式<span class=\"reference\">（前面范例采用的是头插方式）</span>，所以同一个图的邻接表存储方式并不唯一。也就是说，用邻接表存储图所得到的深度优先生成树并不唯一。另外，若用邻接矩阵存储图，那么因为得到的邻接矩阵是唯一的，所以得到的深度优先生成树应该也是唯一的，你可以自行尝试。</p><p>不难看到，只要图是连通的，就可以以任意顶点为起始点进行遍历。</p><p>如果是非连通图，就需要对它的连通分量分别进行深度优先遍历，直至图中所有顶点都被访问到为止。</p><p>最简单的判断是否是连通图的方法是进行一次深度优先遍历后再扫描一次代码中的vVArray数组<span class=\"reference\">（标记图中顶点是否被访问过的数组）</span>，如果在该数组中发现其对应位置的顶点真实存在但却没被访问过，则可以从这个顶点出发再次调用DepthFirstSearch成员函数。如此反复，最终即可对非连通图的所有连通分量实现完整遍历。要做到这些，只需要修改DepthFirstSearch成员函数即可。</p><p>我们看下修改后的完整代码。</p><pre><code class=\"language-plain\">//深度优先遍历\nvoid DepthFirstSearch(const T&amp; tmpv) //tmpv代表从该顶点出发开始遍历，即tmpv是开始遍历的起始顶点\n{\n\tbool vVArray[MaxVertices_size];&nbsp; //顶点是否被访问过的标记，false没有被访问过，true被访问过\n\tfor (int i = 0; i &lt; MaxVertices_size; ++i) //开始时所有顶点都没有被访问过\n\t{\n\t\tvVArray[i] = false;&nbsp;\n\t} //end for\n\t\n\tint idx = GetVertexIdx(tmpv);\n\tDepthFirstSearch(idx, vVArray);\n\t\n\t//如果是非连通图，则继续遍历其他子图\n\tbool iffindnovisited; //是否找到了没被访问的顶点\n\tint&nbsp; idxnovisited;&nbsp; //没被访问的顶点的下标\nlblloop:\n\tiffindnovisited = false;\n\tidxnovisited = -1;\t\t\t\n\tfor (int i = 0; i &lt; m_numVertices; ++i)\n\t{\n\t\tif (vVArray[i] == false)\n\t\t{\n\t\t\tiffindnovisited = true; //标记找到了没被访问的顶点\n\t\t\tidxnovisited = i; //记录没被访问的顶点的下标\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (iffindnovisited == true) //找到了没被访问的顶点\n\t{\n\t\tDepthFirstSearch(idxnovisited, vVArray);\n\t\tgoto lblloop;\n\t}\n}\n</code></pre><p>如果一个图是非连通的，那么对他的连通分量分别进行深度优先遍历就会得到多棵深度优先生成树，合在一起组成深度优先生成森林。</p><h2>广度优先遍历</h2><p>广度优先遍历也称为广度优先搜索，英文名为Breadth First Search<span class=\"reference\">（BFS）</span>。这种遍历很像一棵二叉树的层序遍历或者说树的广度优先遍历。</p><p>二叉树的层序遍历是从树的根节点开始，按照从上到下从左到右的顺序对节点逐个遍历。图的层序遍历也类似。在图1中，从顶点B 出发进行广度优先遍历的步骤应该是这样的。</p><ul>\n<li>访问顶点B。</li>\n<li>通过顶点B可以找到与之相邻且未曾访问过的顶点E、F、A，即访问顶点E、F、A。</li>\n<li>从顶点E、F、A出发，再找到与这些顶点相邻且未曾访问过的顶点C、D。</li>\n</ul><p>不难看到，图的广度优先遍历是一种从近到远的搜索策略——先查找离起始顶点最近的顶点，依次向外搜索。</p><p>在实现二叉树的层序遍历代码时，借助了链式队列来完成，在实现图的广度优先遍历时也类似。把以往讲解的链式队列相关的代码复制到本项目当前的MyProject.cpp文件中来。针对前面用邻接表这种存储方式实现的图，我们可以在其中继续增加代码，实现对图的广度优先遍历。</p><pre><code class=\"language-plain\">//广度优先遍历\nvoid BreadthFirstSearch(const T&amp; tmpv) //tmpv代表从该顶点出发开始遍历，即tmpv是开始遍历的起始顶点\n{\n\tbool vVArray[MaxVertices_size];&nbsp; //顶点是否被访问过的标记，false没有被访问过，true被访问过\n\tfor (int i = 0; i &lt; MaxVertices_size; ++i) //开始时所有顶点都没有被访问过\n\t{\n\t\tvVArray[i] = false;\n\t} //end for\t\t\t\n\t\n\tint idx = GetVertexIdx(tmpv);\n\tcout &lt;&lt; m_VertexArray[idx].data &lt;&lt;\"--&gt;\";\n\tvVArray[idx] = true; //标记该顶点已经被访问过\n\t\n\tLinkQueue&lt;int&gt; lnobj;&nbsp; //借助队列实现遍历\n\tlnobj.EnQueue(idx); //先把起始顶点下标入队\n\twhile (!lnobj.IsEmpty()) //循环判断队列是否为空\n\t{\n\t\tlnobj.DeQueue(idx); //出队列\n\t\t\n\t\tint idx2 = GetFirstNeighbor(idx);\n\t\twhile (idx2 != -1)\n\t\t{\n\t\t\tif (vVArray[idx2] == false)\n\t\t\t{\n\t\t\t\t//没访问过\n\t\t\t\tcout &lt;&lt; m_VertexArray[idx2].data &lt;&lt;\"--&gt;\";\n\t\t\t\tvVArray[idx2] = true; //标记该顶点已经被访问过\n\t\t\t\tlnobj.EnQueue(idx2); //入队\n\t\t\t}\n\t\t\tidx2 = GetNextNeightbor(idx, idx2);&nbsp; //获取某个顶点（下标为idx）的邻接顶点（下标为idx2）的下一个邻接顶点的下标\n\t\t} //end while\n\t} //end while\n}\n</code></pre><p>在main主函数中，再加入代码测试广度优先遍历。</p><pre><code class=\"language-plain\">gm2.BreadthFirstSearch('B');\ncout &lt;&lt;\"nullptr\"&lt;&lt; endl;\n</code></pre><p>新增代码的执行结果如下：<br>\n<img src=\"https://static001.geekbang.org/resource/image/fc/b4/fcb2a69633cc51b5991a99056c2968b4.jpg?wh=2140x104\" alt=\"\"></p><p>从结果中不难看到，广度优先遍历的顺序是这样的。</p><ol>\n<li>顶点B<span class=\"reference\">（下标1）</span>作遍历的开始顶点，肯定会最先被访问。然后把顶点B入队。</li>\n<li>从队列中取出队头元素顶点B，针对顶点B，有这样一系列的操作。</li>\n</ol><ul>\n<li>取得顶点B的第一个邻接顶点F<span class=\"reference\">（下标5）</span>，因为该顶点没被访问过所以进行访问。然后把顶点F入队。</li>\n<li>取得顶点B的邻接顶点F的下一个邻接顶点E<span class=\"reference\">（下标4）</span>，因为该顶点没被访问过所以进行访问。然后把顶点E入队。</li>\n<li>取得顶点B的邻接顶点E的下一个邻接顶点A<span class=\"reference\">（下标0）</span>，因为该顶点没被访问过所以进行访问。然后把顶点A入队。</li>\n<li>取得顶点B的邻接顶点A的下一个邻接顶点，但此时顶点B已经没有下一个邻接顶点，因此重新到队列中取队头元素。</li>\n</ul><ol start=\"3\">\n<li>从队列中取出队头元素F，针对顶点F，会有什么样的操作呢？</li>\n</ol><ul>\n<li>取得顶点F的第一个邻接顶点D<span class=\"reference\">（下标3）</span>，因为该顶点没被访问过所以进行访问。然后把顶点D入队。</li>\n<li>取得顶点F的邻接顶点D的下一个邻接顶点C<span class=\"reference\">（下标2）</span>，因为该顶点没被访问过所以进行访问。然后把顶点C入队。</li>\n<li>取得顶点F的邻接顶点C的下一个邻接顶点B<span class=\"reference\">（下标1）</span>，因为该顶点已被访问过，所以取得顶点F的邻接顶点B的下一个邻接顶点，但此时顶点F已经没有下一个邻接顶点，因此重新到队列中取队头元素。</li>\n</ul><ol start=\"4\">\n<li>之后，从队列中取出队头元素E，针对顶点E，取得顶点E的第一个邻接顶点B<span class=\"reference\">（下标1）</span>，因为该顶点已被访问过，所以取得顶点E的邻接顶点B的下一个邻接顶点，但此时顶点E已经没有下一个邻接顶点，因此重新到队列中取队头元素。</li>\n<li>从队列中取出队头元素A，针对顶点A，取得顶点A的第一个邻接顶点D<span class=\"reference\">（下标3）</span>，因为该顶点已被访问过，所以取得顶点A的邻接顶点D的下一个邻接顶点C<span class=\"reference\">（下标2）</span>，因为该顶点已被访问过，所以取得顶点A的邻接顶点C的下一个邻接顶点B<span class=\"reference\">（下标1）</span>，因为该顶点已被访问过，所以取得顶点A的邻接顶点B的下一个邻接顶点，但此时顶点A已经没有下一个邻接顶点，因此重新到队列中取队头元素。</li>\n<li>从队列中取出队头元素D，针对顶点D，取得顶点D的第一个邻接顶点F<span class=\"reference\">（下标5）</span>，因为该顶点已被访问过，所以取得顶点D的邻接顶点F的下一个邻接顶点A<span class=\"reference\">（下标0）</span>，因为该顶点已被访问过，所以取得顶点D的邻接顶点A的下一个邻接顶点，但此时顶点D已经没有下一个邻接顶点，因此重新到队列中取队头元素。</li>\n<li>从队列中取出队头元素C，针对顶点C，取得顶点C的第一个邻接顶点F<span class=\"reference\">（下标5）</span>，因为该顶点已被访问过，所以取得顶点C的邻接顶点F的下一个邻接顶点A<span class=\"reference\">（下标0）</span>，因为该顶点已被访问过，所以取得顶点C的邻接顶点A的下一个邻接顶点，但此时顶点C已经没有下一个邻接顶点，因此重新到队列中取队头元素。</li>\n<li>从队列中取出队头元素，但因为此时队列已经为空，因此整个遍历过程结束。</li>\n</ol><p>整个广度优先遍历的顺序示意图如图3所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/6b/c2/6bf188314a2c607c8d1ffec1e4c49dc2.jpg?wh=938x475\" alt=\"\" title=\"图3 一个图采用邻接表存储时以顶点B作为起点进行广度优先遍历的顶点遍历顺序示意图\"></p><p>在图3中，一共有6个顶点，并且通过5<span class=\"reference\">（顶点数-1，即6-1）</span>条边<span class=\"reference\">（图中标记了数字的边）</span>遍历了所有这6个顶点，如果仅保留图中这5条边，则得到了一棵树<span class=\"reference\">（没有回路存在）</span>，如图4所示，这个树就叫做该图所对应的<strong>广度优先生成树。</strong></p><p><img src=\"https://static001.geekbang.org/resource/image/af/8c/aff9ab9d95c5d8f716839694ff6aca8c.jpg?wh=1174x497\" alt=\"\" title=\"图4 一个图采用邻接表存储时对应的广度优先生成树（两幅图画的是同一棵树）\"></p><p>图4这棵广度优先生成树是对原图进行广度优先遍历的过程而得到的。显然，遍历顺序决定了广度优先生成树的样子。而在以邻接表作为图的存储结构时，由于边节点结构的插入方式可以采用头插或者尾插方式<span class=\"reference\">（前面范例采用的是头插方式）</span>，所以同一个图的邻接表存储方式不唯一。也就是说，用邻接表存储图所得到的广度优先生成树并不唯一。另外，如果用邻接矩阵存储图，那么因为得到的邻接矩阵是唯一的，所以得到的广度优先生成树应该也是唯一的，你可以自行尝试。</p><p>如果一个图是非连通的，那么对它的连通分量分别进行广度优先遍历就会得到多棵广度优先生成树，合在一起组成广度优先生成森林。</p><h2>深度与广度优先遍历的空间与时间复杂度</h2><p>最后，还记得我们在最开始学习过的复杂度分析吗？我们在这里复习一下。</p><p>对于深度优先遍历，所需要的空间是vVArray数组和递归调用栈的最大深度，而递归调用栈的最大深度也不会超过图的顶点个数，因此对于深度优先遍历空间复杂度是O(|V|)。</p><p>对于广度优先遍历，所需要的空间是vVArray数组、LinkQueue队列，而这些存储空间的大小都不会超过顶点个数，因此对于广度优先遍历的空间复杂度是O(|V|)。</p><p>而无论是深度优先遍历还是广度优先遍历，采用邻接表作为图的存储结构所需要的时间复杂度就是访问各个顶点以及邻接顶点所需要的时间之和，也就是O(|V|+|E|)。</p><p>那么，如果采用邻接矩阵作为图的存储结构，那么深度优先遍历和广度优先遍历所需要的时间复杂度又是多少呢？因为查找每个顶点的邻接点都需要O(|V|)的时间，所以|V|个顶点的时间复杂度就是O($|V|^{2}$)。</p><h2>小结</h2><p>本节首先讲解并实现了图的深度优先遍历，也就是选择任意一条路走进去，一直到发现走不通的时候退回到上一个岔路口并重新选择一条路走进去，直到走遍所有关键节点。后面我也详细解说了深度优先遍历的顺序。</p><p>接着讲解并实现了图的广度优先遍历，也就是从近到远进行搜索，先查找离起始顶点最近的顶点，依次向外搜索，直到走遍所有关键节点。同样，我也详细解说了广度优先遍历的顺序。</p><p>最后，我们给出了深度和广度优先遍历的空间与时间复杂度。</p><ul>\n<li>空间复杂度：深度优先遍历和广度优先遍历的空间复杂度都是O(|V|。</li>\n<li>时间复杂度：采用<strong>邻接表</strong>作为图的存储结构时深度优先遍历和广度优先遍历的时间复杂度都是O(|V|+|E|)。而采用<strong>邻接矩阵</strong>作为图的存储结构时深度优先遍历和广度优先遍历的时间复杂度都是O($|V|^{2}$)。</li>\n</ul><p>图的深度优先遍历和广度优先遍历在算法面试题中经常出现，希望你对本节内容好好理解和掌握以从容地应对面试。</p><h2>课后思考</h2><p>请参照深度优先遍历的写法，书写广度优先遍历针对非连通图的遍历。</p><p>欢迎你在留言区分享自己的成果。如果觉得有所收获，也可以把课程分享给更多的朋友一起学习。我们下节课见！</p>","comments":[]}