{"id":169263,"title":"02 | 自己动手，实现C++的智能指针","content":"<p>你好，我是吴咏炜。</p><p>上一讲，我们描述了一个某种程度上可以当成智能指针用的类 <code>shape_wrapper</code>。使用那个智能指针，可以简化资源的管理，从根本上消除资源（包括内存）泄漏的可能性。这一讲我们就来进一步讲解，如何将 <code>shape_wrapper</code> 改造成一个完整的智能指针。你会看到，智能指针本质上并不神秘，其实就是 RAII 资源管理功能的自然展现而已。</p><p>在学完这一讲之后，你应该会对 C++ 的 <code>unique_ptr</code> 和 <code>shared_ptr</code> 的功能非常熟悉了。同时，如果你今后要创建类似的资源管理类，也不会是一件难事。</p><h2>回顾</h2><p>我们上一讲给出了下面这个类：</p><pre><code class=\"language-c++\">class shape_wrapper {\npublic:\n  explicit shape_wrapper(\n    shape* ptr = nullptr)\n    : ptr_(ptr) {}\n  ~shape_wrapper()\n  {\n    delete ptr_;\n  }\n  shape* get() const { return ptr_; }\n\nprivate:\n  shape* ptr_;\n};\n</code></pre><p>这个类可以完成智能指针的最基本的功能：对超出作用域的对象进行释放。<strong>但它缺了点东西：</strong></p><ol>\n<li>这个类只适用于 <code>shape</code> 类</li>\n<li>该类对象的行为不够像指针</li>\n<li>拷贝该类对象会引发程序行为异常</li>\n</ol><!-- [[[read_end]]] --><p>下面我们来逐一看一下怎么弥补这些问题。</p><h2>模板化和易用性</h2><p>要让这个类能够包装任意类型的指针，我们需要把它变成一个类模板。这实际上相当容易：</p><pre><code class=\"language-c++\">template &lt;typename T&gt;\nclass smart_ptr {\npublic:\n  explicit smart_ptr(T* ptr = nullptr)\n    : ptr_(ptr) {}\n  ~smart_ptr()\n  {\n    delete ptr_;\n  }\n  T* get() const { return ptr_; }\nprivate:\n  T* ptr_;\n};\n</code></pre><p>和 <code>shape_wrapper</code> 比较一下，我们就是在开头增加模板声明 <code>template &lt;typename T&gt;</code>，然后把代码中的 <code>shape</code> 替换成模板参数 <code>T</code> 而已。这些修改非常简单自然吧？模板本质上并不是一个很复杂的概念。这个模板使用也很简单，把原来的 <code>shape_wrapper</code> 改成 <code>smart_ptr&lt;shape&gt;</code> 就行。</p><p>目前这个 <code>smart_ptr</code> 的行为还是和指针有点差异的：</p><ul>\n<li>它不能用 <code>*</code> 运算符解引用</li>\n<li>它不能用 <code>-&gt;</code> 运算符指向对象成员</li>\n<li>它不能像指针一样用在布尔表达式里</li>\n</ul><p>不过，这些问题也相当容易解决，加几个成员函数就可以：</p><pre><code class=\"language-c++\">template &lt;typename T&gt;\nclass smart_ptr {\npublic:\n  …\n  T&amp; operator*() const { return *ptr_; }\n  T* operator-&gt;() const { return ptr_; }\n  operator bool() const { return ptr_; }\n}\n</code></pre><h2>拷贝构造和赋值</h2><p>拷贝构造和赋值，我们暂且简称为拷贝，这是个比较复杂的问题了。关键还不是实现问题，而是我们该如何定义其行为。假设有下面的代码：</p><pre><code class=\"language-c++\">smart_ptr&lt;shape&gt; ptr1{create_shape(shape_type::circle)};\nsmart_ptr&lt;shape&gt; ptr2{ptr1};\n</code></pre><p>对于第二行，究竟应当让编译时发生错误，还是可以有一个更合理的行为？我们来逐一检查一下各种可能性。</p><p>最简单的情况显然是禁止拷贝。我们可以使用下面的代码：</p><pre><code class=\"language-c++\">template &lt;typename T&gt;\nclass smart_ptr {\n  …\n  smart_ptr(const smart_ptr&amp;)\n    = delete;\n  smart_ptr&amp; operator=(const smart_ptr&amp;)\n    = delete;\n  …\n};\n</code></pre><p>禁用这两个函数非常简单，但却解决了一种可能出错的情况。否则，<code>smart_ptr&lt;shape&gt; ptr2{ptr1};</code> 在编译时不会出错，但在运行时却会有未定义行为——由于会对同一内存释放两次，通常情况下会导致程序崩溃。</p><p>我们是不是可以考虑在拷贝智能指针时把对象拷贝一份？不行，通常人们不会这么用，因为使用智能指针的目的就是要减少对象的拷贝啊。何况，虽然我们的指针类型是 <code>shape</code>，但实际指向的却应该是 <code>circle</code> 或 <code>triangle</code> 之类的对象。在 C++ 里没有像 Java 的 <code>clone</code> 方法这样的约定；一般而言，并没有通用的方法可以通过基类的指针来构造出一个子类的对象来。</p><p>我们要么试试在拷贝时转移指针的所有权？大致实现如下：</p><pre><code class=\"language-c++\">template &lt;typename T&gt;\nclass smart_ptr {\n  …\n  smart_ptr(smart_ptr&amp; other)\n  {\n    ptr_ = other.release();\n  }\n  smart_ptr&amp; operator=(smart_ptr&amp; rhs)\n  {\n    smart_ptr(rhs).swap(*this);\n    return *this;\n  }\n  …\n  T* release()\n  {\n    T* ptr = ptr_;\n    ptr_ = nullptr;\n    return ptr;\n  }\n  void swap(smart_ptr&amp; rhs)\n  {\n    using std::swap;\n    swap(ptr_, rhs.ptr_);\n  }\n  …\n};\n</code></pre><p>在拷贝构造函数中，通过调用 <code>other</code> 的 <code>release</code> 方法来释放它对指针的所有权。在赋值函数中，则通过拷贝构造产生一个临时对象并调用 <code>swap</code> 来交换对指针的所有权。实现上是不复杂的。</p><p>如果你学到的赋值函数还有一个类似于 <code>if (this != &amp;rhs)</code> 的判断的话，那种用法更啰嗦，而且异常安全性不够好——如果在赋值过程中发生异常的话，this 对象的内容可能已经被部分破坏了，对象不再处于一个完整的状态。</p><p><strong>上面代码里的这种惯用法（见参考资料 <span class=\"orange\">[1]</span>）则保证了强异常安全性：</strong>赋值分为拷贝构造和交换两步，异常只可能在第一步发生；而第一步如果发生异常的话，this 对象完全不受任何影响。无论拷贝构造成功与否，结果只有赋值成功和赋值没有效果两种状态，而不会发生因为赋值破坏了当前对象这种场景。</p><p>如果你觉得这个实现还不错的话，那恭喜你，你达到了 C++ 委员会在 1998 年时的水平：上面给出的语义本质上就是 C++98 的 <code>auto_ptr</code> 的定义。如果你觉得这个实现很别扭的话，也恭喜你，因为 C++ 委员会也是这么觉得的：<code>auto_ptr</code> 在 C++17 时已经被正式从 C++ 标准里删除了。</p><p>上面实现的最大问题是，它的行为会让程序员非常容易犯错。一不小心把它传递给另外一个 <code>smart_ptr</code>，你就不再拥有这个对象了……</p><h2>“移动”指针？</h2><p>在下一讲我们将完整介绍一下移动语义。这一讲，我们先简单看一下 <code>smart_ptr</code> 可以如何使用“移动”来改善其行为。</p><p>我们需要对代码做两处小修改：</p><pre><code class=\"language-c++\">template &lt;typename T&gt;\nclass smart_ptr {\n  …\n  smart_ptr(smart_ptr&amp;&amp; other)\n  {\n    ptr_ = other.release();\n  }\n  smart_ptr&amp; operator=(smart_ptr rhs)\n  {\n    rhs.swap(*this);\n    return *this;\n  }\n  …\n};\n</code></pre><p>看到修改的地方了吗？我改了两个地方：</p><ul>\n<li>把拷贝构造函数中的参数类型 <code>smart_ptr&amp;</code> 改成了 <code>smart_ptr&amp;&amp;</code>；现在它成了移动构造函数。</li>\n<li>把赋值函数中的参数类型 <code>smart_ptr&amp;</code> 改成了 <code>smart_ptr</code>，在构造参数时直接生成新的智能指针，从而不再需要在函数体中构造临时对象。现在赋值函数的行为是移动还是拷贝，完全依赖于构造参数时走的是移动构造还是拷贝构造。</li>\n</ul><p>根据 C++ 的规则，如果我提供了移动构造函数而没有手动提供拷贝构造函数，那后者自动被禁用（记住，C++ 里那些复杂的规则也是为方便编程而设立的）。于是，我们自然地得到了以下结果：</p><pre><code class=\"language-c++\">smart_ptr&lt;shape&gt; ptr1{create_shape(shape_type::circle)};\nsmart_ptr&lt;shape&gt; ptr2{ptr1};             // 编译出错\nsmart_ptr&lt;shape&gt; ptr3;\nptr3 = ptr1;                             // 编译出错\nptr3 = std::move(ptr1);                  // OK，可以\nsmart_ptr&lt;shape&gt; ptr4{std::move(ptr3)};  // OK，可以\n</code></pre><p>这个就自然多了。</p><p>这也是 C++11 的 <code>unique_ptr</code> 的基本行为。</p><h2>子类指针向基类指针的转换</h2><p>哦，我撒了一个小谎。不知道你注意到没有，一个 <code>circle*</code> 是可以隐式转换成 <code>shape*</code> 的，但上面的 <code>smart_ptr&lt;circle&gt;</code> 却无法自动转换成 <code>smart_ptr&lt;shape&gt;</code>。这个行为显然还是不够“自然”。</p><p>不过，只需要额外加一点模板代码，就能实现这一行为。在我们目前给出的实现里，只需要增加一个构造函数即可——这也算是我们让赋值函数利用构造函数的好处了。</p><pre><code class=\"language-c++\">  template &lt;typename U&gt;\n  smart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other)\n  {\n    ptr_ = other.release();\n  }\n</code></pre><p>这样，我们自然而然利用了指针的转换特性：现在 <code>smart_ptr&lt;circle&gt;</code> 可以移动给 <code>smart_ptr&lt;shape&gt;</code>，但不能移动给 <code>smart_ptr&lt;triangle&gt;</code>。不正确的转换会在代码编译时直接报错。</p><p>需要注意，上面这个构造函数不被编译器看作移动构造函数，因而不能自动触发删除拷贝构造函数的行为。如果我们想消除代码重复、删除移动构造函数的话，就需要把拷贝构造函数标记成 <code>= delete</code> 了（见“拷贝构造和赋值”一节）。不过，更通用的方式仍然是同时定义标准的拷贝/移动构造函数和所需的模板构造函数。下面的引用计数智能指针里我们就需要这么做。</p><p>至于非隐式的转换，因为本来就是要写特殊的转换函数的，我们留到这一讲的最后再讨论。</p><h2>引用计数</h2><p><code>unique_ptr</code> 算是一种较为安全的智能指针了。但是，一个对象只能被单个 <code>unique_ptr</code> 所拥有，这显然不能满足所有使用场合的需求。一种常见的情况是，多个智能指针同时拥有一个对象；当它们全部都失效时，这个对象也同时会被删除。这也就是 <code>shared_ptr</code> 了。</p><p><code>unique_ptr</code> 和 <code>shared_ptr</code> 的主要区别如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/07/c8/072fc41e503d22c3ab2bf6a3801903c8.png?wh=1200*500\" alt=\"\"></p><p>多个不同的 <code>shared_ptr</code> 不仅可以共享一个对象，在共享同一对象时也需要同时共享同一个计数。当最后一个指向对象（和共享计数）的 <code>shared_ptr</code> 析构时，它需要删除对象和共享计数。我们下面就来实现一下。</p><p>我们先来写出共享计数的接口：</p><pre><code class=\"language-c++\">class shared_count {\npublic:\n  shared_count();\n  void add_count();\n  long reduce_count();\n  long get_count() const;\n};\n</code></pre><p>这个 <code>shared_count</code> 类除构造函数之外有三个方法：一个增加计数，一个减少计数，一个获取计数。注意上面的接口增加计数不需要返回计数值；但减少计数时需要返回计数值，以供调用者判断是否它已经是最后一个指向共享计数的 <code>shared_ptr</code> 了。由于真正多线程安全的版本需要用到我们目前还没学到的知识，我们目前先实现一个简单化的版本：</p><pre><code class=\"language-c++\">class shared_count {\npublic:\n  shared_count() : count_(1) {}\n  void add_count()\n  {\n    ++count_;\n  }\n  long reduce_count()\n  {\n    return --count_;\n  }\n  long get_count() const\n  {\n    return count_;\n  }\n\nprivate:\n  long count_;\n};\n</code></pre><p>现在我们可以实现我们的引用计数智能指针了。首先是构造函数、析构函数和私有成员变量：</p><pre><code class=\"language-c++\">template &lt;typename T&gt;\nclass smart_ptr {\npublic:\n  explicit smart_ptr(T* ptr = nullptr)\n    : ptr_(ptr)\n  {\n    if (ptr) {\n      shared_count_ =\n        new shared_count();\n    }\n  }\n  ~smart_ptr()\n  {\n    if (ptr_ &amp;&amp;\n      !shared_count_\n         -&gt;reduce_count()) {\n      delete ptr_;\n      delete shared_count_;\n    }\n  }\n\nprivate:\n  T* ptr_;\n  shared_count* shared_count_;\n};\n</code></pre><p>构造函数跟之前的主要不同点是会构造一个 <code>shared_count</code> 出来。析构函数在看到 <code>ptr_</code> 非空时（此时根据代码逻辑，<code>shared_count</code> 也必然非空），需要对引用数减一，并在引用数降到零时彻底删除对象和共享计数。原理就是这样，不复杂。</p><p>当然，我们还有些细节要处理。为了方便实现赋值（及其他一些惯用法），我们需要一个新的 <code>swap</code> 成员函数：</p><pre><code class=\"language-c++\">  void swap(smart_ptr&amp; rhs)\n  {\n    using std::swap;\n    swap(ptr_, rhs.ptr_);\n    swap(shared_count_,\n         rhs.shared_count_);\n  }\n</code></pre><p>赋值函数可以跟前面一样，保持不变，但拷贝构造和移动构造函数是需要更新一下的：</p><pre><code class=\"language-c++\">  smart_ptr(const smart_ptr&amp; other)\n  {\n    ptr_ = other.ptr_;\n    if (ptr_) {\n      other.shared_count_\n        -&gt;add_count();\n      shared_count_ =\n        other.shared_count_;\n    }\n  }\n  template &lt;typename U&gt;\n  smart_ptr(const smart_ptr&lt;U&gt;&amp; other)\n  {\n    ptr_ = other.ptr_;\n    if (ptr_) {\n      other.shared_count_\n        -&gt;add_count();\n      shared_count_ =\n        other.shared_count_;\n    }\n  }\n  template &lt;typename U&gt;\n  smart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other)\n  {\n    ptr_ = other.ptr_;\n    if (ptr_) {\n      shared_count_ =\n        other.shared_count_;\n      other.ptr_ = nullptr;\n    }\n  }\n</code></pre><p>除复制指针之外，对于拷贝构造的情况，我们需要在指针非空时把引用数加一，并复制共享计数的指针。对于移动构造的情况，我们不需要调整引用数，直接把 <code>other.ptr_</code> 置为空，认为 <code>other</code> 不再指向该共享对象即可。</p><p>不过，上面的代码有个问题：它不能正确编译。编译器会报错，像：</p><blockquote>\n<p>fatal error: ‘ptr_’ is a private member of ‘smart_ptr&lt;circle&gt;’</p>\n</blockquote><p>错误原因是模板的各个实例间并不天然就有 friend 关系，因而不能互访私有成员 <code>ptr_</code> 和 <code>shared_count_</code>。我们需要在 <code>smart_ptr</code> 的定义中显式声明：</p><pre><code class=\"language-c++\">  template &lt;typename U&gt;\n  friend class smart_ptr;\n</code></pre><p>此外，我们之前的实现（类似于单一所有权的 <code>unique_ptr</code> ）中用 <code>release</code> 来手工释放所有权。在目前的引用计数实现中，它就不太合适了，应当删除。但我们要加一个对调试非常有用的函数，返回引用计数值。定义如下：</p><pre><code class=\"language-c++\">  long use_count() const\n  {\n    if (ptr_) {\n      return shared_count_\n        -&gt;get_count();\n    } else {\n      return 0;\n    }\n  }\n</code></pre><p>这就差不多是一个比较完整的引用计数智能指针的实现了。我们可以用下面的代码来验证一下它的功能正常：</p><pre><code class=\"language-c++\">class shape {\npublic:\n  virtual ~shape() {}\n};\n\nclass circle : public shape {\npublic:\n  ~circle() { puts(\"~circle()\"); }\n};\n\nint main()\n{\n  smart_ptr&lt;circle&gt; ptr1(new circle());\n  printf(\"use count of ptr1 is %ld\\n\",\n         ptr1.use_count());\n  smart_ptr&lt;shape&gt; ptr2;\n  printf(\"use count of ptr2 was %ld\\n\",\n         ptr2.use_count());\n  ptr2 = ptr1;\n  printf(\"use count of ptr2 is now %ld\\n\",\n         ptr2.use_count());\n  if (ptr1) {\n    puts(\"ptr1 is not empty\");\n  }\n}\n</code></pre><p>这段代码的运行结果是：</p><blockquote>\n<p><code>use count of ptr1 is 1</code><br>\n<code>use count of ptr2 was 0</code><br>\n<code>use count of ptr2 is now 2</code><br>\n<code>ptr1 is not empty</code><br>\n<code>~circle()</code></p>\n</blockquote><p>上面我们可以看到引用计数的变化，以及最后对象被成功删除。</p><h2>指针类型转换</h2><p>对应于 C++ 里的不同的类型强制转换：</p><ul>\n<li>static_cast</li>\n<li>reinterpret_cast</li>\n<li>const_cast</li>\n<li>dynamic_cast</li>\n</ul><p>智能指针需要实现类似的函数模板。实现本身并不复杂，但为了实现这些转换，我们需要添加构造函数，允许在对智能指针内部的指针对象赋值时，使用一个现有的智能指针的共享计数。如下所示：</p><pre><code class=\"language-c++\">  template &lt;typename U&gt;\n  smart_ptr(const smart_ptr&lt;U&gt;&amp; other,\n            T* ptr)\n  {\n    ptr_ = ptr;\n    if (ptr_) {\n      other.shared_count_\n        -&gt;add_count();\n      shared_count_ =\n        other.shared_count_;\n    }\n  }\n</code></pre><p>这样我们就可以实现转换所需的函数模板了。下面实现一个 <code>dynamic_pointer_cast</code> 来示例一下：</p><pre><code class=\"language-c++\">template &lt;typename T, typename U&gt;\nsmart_ptr&lt;T&gt; dynamic_pointer_cast(\n  const smart_ptr&lt;U&gt;&amp; other)\n{\n  T* ptr =\n    dynamic_cast&lt;T*&gt;(other.get());\n  return smart_ptr&lt;T&gt;(other, ptr);\n}\n</code></pre><p>在前面的验证代码后面我们可以加上：</p><pre><code class=\"language-c++\">  smart_ptr&lt;circle&gt; ptr3 =\n    dynamic_pointer_cast&lt;circle&gt;(ptr2);\n  printf(\"use count of ptr3 is %ld\\n\",\n         ptr3.use_count());\n</code></pre><p>编译会正常通过，同时能在输出里看到下面的结果：</p><blockquote>\n<p>use count of ptr3 is 3</p>\n</blockquote><p>最后，对象仍然能够被正确删除。这说明我们的实现是正确的。</p><h2>代码列表</h2><p>为了方便你参考，下面我给出了一个完整的 <code>smart_ptr</code> 代码列表：</p><pre><code class=\"language-c++\">#include &lt;utility&gt;  // std::swap\n\nclass shared_count {\npublic:\n  shared_count() noexcept\n    : count_(1) {}\n  void add_count() noexcept\n  {\n    ++count_;\n  }\n  long reduce_count() noexcept\n  {\n    return --count_;\n  }\n  long get_count() const noexcept\n  {\n    return count_;\n  }\n\nprivate:\n  long count_;\n};\n\ntemplate &lt;typename T&gt;\nclass smart_ptr {\npublic:\n  template &lt;typename U&gt;\n  friend class smart_ptr;\n\n  explicit smart_ptr(T* ptr = nullptr)\n    : ptr_(ptr)\n  {\n    if (ptr) {\n      shared_count_ =\n        new shared_count();\n    }\n  }\n  ~smart_ptr()\n  {\n    if (ptr_ &amp;&amp;\n      !shared_count_\n         -&gt;reduce_count()) {\n      delete ptr_;\n      delete shared_count_;\n    }\n  }\n\n  smart_ptr(const smart_ptr&amp; other)\n  {\n    ptr_ = other.ptr_;\n    if (ptr_) {\n      other.shared_count_\n        -&gt;add_count();\n      shared_count_ =\n        other.shared_count_;\n    }\n  }\n  template &lt;typename U&gt;\n  smart_ptr(const smart_ptr&lt;U&gt;&amp; other) noexcept\n  {\n    ptr_ = other.ptr_;\n    if (ptr_) {\n      other.shared_count_-&gt;add_count();\n      shared_count_ = other.shared_count_;\n    }\n  }\n  template &lt;typename U&gt;\n  smart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other) noexcept\n  {\n    ptr_ = other.ptr_;\n    if (ptr_) {\n      shared_count_ =\n        other.shared_count_;\n      other.ptr_ = nullptr;\n    }\n  }\n  template &lt;typename U&gt;\n  smart_ptr(const smart_ptr&lt;U&gt;&amp; other,\n            T* ptr) noexcept\n  {\n    ptr_ = ptr;\n    if (ptr_) {\n      other.shared_count_\n        -&gt;add_count();\n      shared_count_ =\n        other.shared_count_;\n    }\n  }\n  smart_ptr&amp;\n  operator=(smart_ptr rhs) noexcept\n  {\n    rhs.swap(*this);\n    return *this;\n  }\n\n  T* get() const noexcept\n  {\n    return ptr_;\n  }\n  long use_count() const noexcept\n  {\n    if (ptr_) {\n      return shared_count_\n        -&gt;get_count();\n    } else {\n      return 0;\n    }\n  }\n  void swap(smart_ptr&amp; rhs) noexcept\n  {\n    using std::swap;\n    swap(ptr_, rhs.ptr_);\n    swap(shared_count_,\n         rhs.shared_count_);\n  }\n\n  T&amp; operator*() const noexcept\n  {\n    return *ptr_;\n  }\n  T* operator-&gt;() const noexcept\n  {\n    return ptr_;\n  }\n  operator bool() const noexcept\n  {\n    return ptr_;\n  }\n\nprivate:\n  T* ptr_;\n  shared_count* shared_count_;\n};\n\ntemplate &lt;typename T&gt;\nvoid swap(smart_ptr&lt;T&gt;&amp; lhs,\n          smart_ptr&lt;T&gt;&amp; rhs) noexcept\n{\n  lhs.swap(rhs);\n}\n\ntemplate &lt;typename T, typename U&gt;\nsmart_ptr&lt;T&gt; static_pointer_cast(\n  const smart_ptr&lt;U&gt;&amp; other) noexcept\n{\n  T* ptr = static_cast&lt;T*&gt;(other.get());\n  return smart_ptr&lt;T&gt;(other, ptr);\n}\n\ntemplate &lt;typename T, typename U&gt;\nsmart_ptr&lt;T&gt; reinterpret_pointer_cast(\n  const smart_ptr&lt;U&gt;&amp; other) noexcept\n{\n  T* ptr = reinterpret_cast&lt;T*&gt;(other.get());\n  return smart_ptr&lt;T&gt;(other, ptr);\n}\n\ntemplate &lt;typename T, typename U&gt;\nsmart_ptr&lt;T&gt; const_pointer_cast(\n  const smart_ptr&lt;U&gt;&amp; other) noexcept\n{\n  T* ptr = const_cast&lt;T*&gt;(other.get());\n  return smart_ptr&lt;T&gt;(other, ptr);\n}\n\ntemplate &lt;typename T, typename U&gt;\nsmart_ptr&lt;T&gt; dynamic_pointer_cast(\n  const smart_ptr&lt;U&gt;&amp; other) noexcept\n{\n  T* ptr = dynamic_cast&lt;T*&gt;(other.get());\n  return smart_ptr&lt;T&gt;(other, ptr);\n}\n</code></pre><p>如果你足够细心的话，你会发现我在代码里加了不少 <code>noexcept</code>。这对这个智能指针在它的目标场景能正确使用是十分必要的。我们会在下面的几讲里回到这个话题。</p><h2>内容小结</h2><p>这一讲我们从 <code>shape_wrapper</code> 出发，实现了一个基本完整的带引用计数的智能指针。这个智能指针跟标准的 <code>shared_ptr</code> 比，还缺了一些东西（见参考资料 <span class=\"orange\">[2]</span>），但日常用到的智能指针功能已经包含在内。现在，你应当已经对智能指针有一个较为深入的理解了。</p><h2>课后思考</h2><p>这里留几个问题，你可以思考一下：</p><ol>\n<li>不查阅 <code>shared_ptr</code> 的文档，你觉得目前 <code>smart_ptr</code> 应当添加什么功能吗？</li>\n<li>你想到的功能在标准的 <code>shared_ptr</code> 里吗？</li>\n<li>你觉得智能指针应该满足什么样的线程安全性？</li>\n</ol><p>欢迎留言和我交流你的看法。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Stack Overflow, GManNickG’s answer to “What is the copy-and-swap idiom?”. <a href=\"https://stackoverflow.com/a/3279550/816999\">https://stackoverflow.com/a/3279550/816999</a> </span></p><p><span class=\"reference\">[2] cppreference.com, “std::shared_ptr”. <a href=\"https://en.cppreference.com/w/cpp/memory/shared_ptr\">https://en.cppreference.com/w/cpp/memory/shared_ptr</a> </span></p>","comments":[{"had_liked":false,"id":155795,"user_name":"frazer","can_delete":false,"product_type":"c1","uid":1194427,"ip_address":"","ucode":"36869573D98495","user_header":"https://static001.geekbang.org/account/avatar/00/12/39/bb/3dd9ef18.jpg","comment_is_top":false,"comment_ctime":1574757933,"is_pvip":false,"replies":[{"id":59877,"content":"没关系。我打赌你看的时间肯定没我写稿的时间长。😁","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574765427,"ip_address":"","comment_id":155795,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"有点吃力了，得反复看几遍","like_count":115},{"had_liked":false,"id":155906,"user_name":"yuchen","can_delete":false,"product_type":"c1","uid":1605025,"ip_address":"","ucode":"D4B55B57D218CB","user_header":"https://static001.geekbang.org/account/avatar/00/18/7d/a1/46c5293c.jpg","comment_is_top":false,"comment_ctime":1574777231,"is_pvip":false,"replies":[{"id":59924,"content":"谢谢。\n\n《Professional C++》之前没看过，扫了两眼，觉得内容不错，推荐。内容还挺多挺深的，适合决心在 C++ 上深入的同学。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574813297,"ip_address":"","comment_id":155906,"utype":1}],"discussion_count":5,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"有深度的专栏，不错。市面上讲解C++的课程一般太基础了。这一章推荐读者可以看看《Professional C＋＋ 4th edition》第九章。","like_count":37,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475875,"discussion_content":"没关系。我打赌你看的时间肯定没我写稿的时间长。😁","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1574765427,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1346028,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKSCRYv3q4f08a3JZjZd4Dpf2IL0g4mkQ9WtcAM3zcCZsA8r9GMpcUmsXGueVMibtJBxXDNGKx75rA/132","nickname":"dasheyuan","note":"","ucode":"AD61112AB070DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62481,"discussion_content":"已经第3遍了。催更....","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574846673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1132347,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/3b/15e4490f.jpg","nickname":"盛艳明","note":"","ucode":"E4C1C699572C44","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":68171,"discussion_content":"再一点点的啃","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575205061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1151971,"avatar":"https://static001.geekbang.org/account/avatar/00/11/93/e3/da819340.jpg","nickname":"马仔","note":"","ucode":"75760150602EA5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1132347,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/3b/15e4490f.jpg","nickname":"盛艳明","note":"","ucode":"E4C1C699572C44","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":100513,"discussion_content":"是的呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577265883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":68171,"ip_address":"","group_id":0},"score":100513,"extra":""}]}]},{"had_liked":false,"id":157236,"user_name":"皓首不倦","can_delete":false,"product_type":"c1","uid":1144626,"ip_address":"","ucode":"FA7D282DD40D83","user_header":"https://static001.geekbang.org/account/avatar/00/11/77/32/02416d97.jpg","comment_is_top":false,"comment_ctime":1575094017,"is_pvip":false,"replies":[{"id":60316,"content":"这是一个很特殊的、甚至有点恼人的情况。如果没有非泛型版本，编译器看到没有拷贝构造函数，会生成一个缺省的拷贝构造函数。这样，同样类型的smart_ptr的拷贝构造会是错误的。“子类指针向基类指针的转换”这一节里我也提到了这点。这不是我讲智能指针想讲的内容，所以就淡化了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575108945,"ip_address":"","comment_id":157236,"utype":1}],"discussion_count":5,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"请问下老师smart ptr 的拷贝构造函数为什么有一个泛型版本 还有一个非泛型版本 但是函数体内容又一模一样 不是代码冗余的吗 是有什么特殊设计意图吗 请老师指教下","like_count":35,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475920,"discussion_content":"谢谢。\n\n《Professional C++》之前没看过，扫了两眼，觉得内容不错，推荐。内容还挺多挺深的，适合决心在 C++ 上深入的同学。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574813297,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1949454,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/bf/0e/0e6419a9.jpg","nickname":"薛瑞","note":"","ucode":"FE634CB0C1BAEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":257474,"discussion_content":"这本书墙裂推荐啊，有中文版，C++高级编程，相当给力","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588574962,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2557701,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Wjsc175urqxxBcCsxSDG5iaWcEq4hIg4SCCVJCIC108Ul5l7US4iaE3iaaMWodSJeybGemicEnfetHFCj9P6QI17xw/132","nickname":"Geek_15f2c9","note":"","ucode":"3AA686B1D31AB1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365823,"discussion_content":"有电子版吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617888262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1760853,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/de/55/d690fe48.jpg","nickname":"西域黑鸦","note":"","ucode":"D1B8BE1AF4699E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":104406,"discussion_content":"哪里可以买到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577431633,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1055296,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1a/40/f10493ef.jpg","nickname":"中山浪子","note":"","ucode":"25D0F8462473D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1760853,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/de/55/d690fe48.jpg","nickname":"西域黑鸦","note":"","ucode":"D1B8BE1AF4699E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":606194,"discussion_content":"现在有第五版","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1677027229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":104406,"ip_address":"上海","group_id":0},"score":606194,"extra":""}]}]},{"had_liked":false,"id":155667,"user_name":"流浪地球","can_delete":false,"product_type":"c1","uid":1498137,"ip_address":"","ucode":"25210DCD353F97","user_header":"https://static001.geekbang.org/account/avatar/00/16/dc/19/c058bcbf.jpg","comment_is_top":false,"comment_ctime":1574734740,"is_pvip":false,"replies":[{"id":59858,"content":"嘻嘻，我在偷偷地塞进C++11的语法。对象初始化可以统一用大括号。（小括号这儿也行。）","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574762471,"ip_address":"","comment_id":155667,"utype":1}],"discussion_count":5,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师您好，问一个比较基础的问题，我理解这个语句\nsmart_ptr&lt;shape&gt;  ptr1{create_shape(shape_type::circle)};  是调用ptr1的拷贝构造函数。\n为什么{create_shape(shape_type::circle)}是使用大括号，不应该是小括号吗？\n谢谢\n","like_count":32,"discussions":[{"author":{"id":1422582,"avatar":"https://static001.geekbang.org/account/avatar/00/15/b4/f6/735673f7.jpg","nickname":"W.jyao","note":"","ucode":"C57B3A78B6A795","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60732,"discussion_content":"调用构造函数。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1574749842,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475823,"discussion_content":"嘻嘻，我在偷偷地塞进C++11的语法。对象初始化可以统一用大括号。（小括号这儿也行。）","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574762471,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1911448,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/ajNVdqHZLLCBR2aB7H8ic3FalKn9x1lXg83KmgYqTznCByz3nZjd9CXLTiaFo22piafibJd04p7jKiblyUic6Eo22esA/132","nickname":"谌鹏飞","note":"","ucode":"AC8D00E3E18D49","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219630,"discussion_content":"这个也是反应了一会儿才知道是c11的语法的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585790324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1547048,"avatar":"https://static001.geekbang.org/account/avatar/00/17/9b/28/9d89de4d.jpg","nickname":"暒","note":"","ucode":"9C956F418C66BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":85653,"discussion_content":"是呀，看了半天我才想起来11 的用大括号进行对象初始化","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576563112,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1609948,"avatar":"https://static001.geekbang.org/account/avatar/00/18/90/dc/44ce2f23.jpg","nickname":"氕氘氚","note":"","ucode":"6B5477BF23AA4A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577821,"discussion_content":"初始化列表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656372605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156428,"user_name":"NEVER SETTLE","can_delete":false,"product_type":"c1","uid":1101894,"ip_address":"","ucode":"9C86BDAFDBF768","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/46/1a9229b3.jpg","comment_is_top":false,"comment_ctime":1574869941,"is_pvip":false,"replies":[{"id":60072,"content":"3. 赋值需要一个对象（不是引用），因而在进入执行前就要引发一个构造。没有合适的构造函数可用。\n\n4. 同样，要先构造。这回可以用右值引用的构造函数了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574899310,"ip_address":"","comment_id":156428,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师这块没想明白\n&#47;&#47; 1、调用构造函数\nsmart_ptr ptr1{create_shape(shape_type::circle)};\n\n&#47;&#47; 2、因为拷贝构造被禁用，随意编译出错\nsmart_ptr ptr2{ptr1}; &#47;&#47; 编译出错\n\nsmart_ptr ptr3;\n\n&#47;&#47; 3、没明白为啥会出错\nptr3 = ptr1;        &#47;&#47; 编译出错\n\n&#47;&#47; 4、没明白为啥OK，=重载函数的参数不是右值引用呀\nptr3 = std::move(ptr1); &#47;&#47; OK，\n\n请老师指定 3 与 4","like_count":27,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476103,"discussion_content":"3. 赋值需要一个对象（不是引用），因而在进入执行前就要引发一个构造。没有合适的构造函数可用。\n\n4. 同样，要先构造。这回可以用右值引用的构造函数了。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574899310,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1007115,"avatar":"","nickname":"Geek_xu324o","note":"","ucode":"F46A5582578A31","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350752,"discussion_content":"这里虽然是= operator，其实调用的是拷贝构造函数","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1613998741,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1331396,"avatar":"https://static001.geekbang.org/account/avatar/00/14/50/c4/71d9745f.jpg","nickname":"飏","note":"","ucode":"48701F74729E5E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78978,"discussion_content":"我也有一个相关的疑问，这里的复制操作符声明的参数是值类型，而不是引用。看了std::shared_ptr的声明是值类型。但是在函数内部确实创建了临时对象然后swap之。这里通过swap实现赋值和move是一个特定的技巧吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576041761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1055296,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1a/40/f10493ef.jpg","nickname":"中山浪子","note":"","ucode":"25D0F8462473D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1331396,"avatar":"https://static001.geekbang.org/account/avatar/00/14/50/c4/71d9745f.jpg","nickname":"飏","note":"","ucode":"48701F74729E5E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609790,"discussion_content":"避免了罗嗦的if (this != &amp;rhs) 的判断，swap通过临时对象和成员内容的互换，解决了异常安全的潜在问题。move 是为了调用右值引用的构造函数\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1679215497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":78978,"ip_address":"上海","group_id":0},"score":609790,"extra":""}]}]},{"had_liked":false,"id":156435,"user_name":"yyfx","can_delete":false,"product_type":"c1","uid":1757872,"ip_address":"","ucode":"230A98762BD678","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/vJD2lw7TUwAl0myKy0PiahuEA75EzPER98wLDcxIvtQQaUiasCpIla7TN3dicMiaAkPxtOdsJh3MicpicD7hV1G5ico4A/132","comment_is_top":false,"comment_ctime":1574870963,"is_pvip":false,"replies":[{"id":60108,"content":"多谢抓虫。正文已更新。\n\n这也证明了，修改代码、没有完整测试，是极易招虫的啊……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574913802,"ip_address":"","comment_id":156435,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"&quot;移动&quot;指针部分有个问题。在使用模板泛化拷贝构造时，p2=p1编译通过，程序异常。测试发现，由于拷贝构造并没有被自动禁用导致。查了下资料，effective45条提到，member templates不影响语言规则，声明member templates用于泛化copy构造时，还需要声明正常的copy构造。","like_count":24,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476107,"discussion_content":"多谢抓虫。正文已更新。\n\n这也证明了，修改代码、没有完整测试，是极易招虫的啊……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574913802,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161612,"user_name":"贵子","can_delete":false,"product_type":"c1","uid":1690431,"ip_address":"","ucode":"A94801C05CB07E","user_header":"https://static001.geekbang.org/account/avatar/00/19/cb/3f/3d044d18.jpg","comment_is_top":false,"comment_ctime":1576247919,"is_pvip":false,"replies":[{"id":61594,"content":"移进去的话，smart_ptr&lt;circle&gt;::shared_count 和 smart_ptr&lt;shape&gt;::shared_count 成了两个完全不相关的类型，它们的指针（在不做强制类型转换时）也不能互相赋值，不好。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576313097,"ip_address":"","comment_id":161612,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"为什么shared_count类作为smart_ptr的内部类编译不过，而必须作为外部类呢？老师能解释一下吗？谢谢！","like_count":18,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476107,"discussion_content":"多谢抓虫。正文已更新。\n\n这也证明了，修改代码、没有完整测试，是极易招虫的啊……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574913802,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161149,"user_name":"总统老唐","can_delete":false,"product_type":"c1","uid":1490070,"ip_address":"","ucode":"F2CC66E5BB4871","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/96/c679bb3d.jpg","comment_is_top":false,"comment_ctime":1576132943,"is_pvip":false,"replies":[{"id":61458,"content":"对。\n\n另外额外加一点，调用移动不一定靠 move。如果函数返回一个 unique_ptr 一样是自然的移动。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576140982,"ip_address":"","comment_id":161149,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"吴老师，关于如何使用移动改善了 auto_ptr 的行为，实现了与 unique_ptr 相近的语义，这里的“改善”是否应该这样理解：\n1， 在没有引入右值引用和移动构造的情况下，构造的 auto_ptr 也能工作，但是会令用户困惑，当用户执行了语句 other_ptr = some_ptr 后，some_ptr 就为空了\n2， 引入右值引用和移动构造后，用户要想用重载的 operator=，必须采用 other_ptr = std::move(some_ptr) 的方式，通过显示调用 std::move，让用户aware到 some_ptr 的内容已经被移动到 other_ptr 了，并且同时默认禁用了参数为左值引用的拷贝构造，导致 other_ptr = some_ptr 无法通过编译，就不会在使用时产生歧义了，这就是 unique_ptr 期望的语义","like_count":18,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477783,"discussion_content":"移进去的话，smart_ptr&amp;lt;circle&amp;gt;::shared_count 和 smart_ptr&amp;lt;shape&amp;gt;::shared_count 成了两个完全不相关的类型，它们的指针（在不做强制类型转换时）也不能互相赋值，不好。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576313097,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1690431,"avatar":"https://static001.geekbang.org/account/avatar/00/19/cb/3f/3d044d18.jpg","nickname":"贵子","note":"","ucode":"A94801C05CB07E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":82119,"discussion_content":"我明白了，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576321872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155988,"user_name":"hdongdong123","can_delete":false,"product_type":"c1","uid":1724769,"ip_address":"","ucode":"D74589952987D9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLICDTy3Aglb3VvyYjSiaR0tkh6jjojiaa8qiccpRHjXGmnJD72iccU36ic29piaenZrREkR1GoPJK1zU9g/132","comment_is_top":false,"comment_ctime":1574790521,"is_pvip":false,"replies":[{"id":59934,"content":"一遍看不懂，就再看一遍。所有的代码自己试验一下。😀\n\n学习无捷径。掌握 C++ 不是 30 个课时能解决的事情。一万小时理论对于任何复杂领域都是基本适用的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574814374,"ip_address":"","comment_id":155988,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"真的好难啊，呜呜呜","like_count":17,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475947,"discussion_content":"一遍看不懂，就再看一遍。所有的代码自己试验一下。😀\n\n学习无捷径。掌握 C++ 不是 30 个课时能解决的事情。一万小时理论对于任何复杂领域都是基本适用的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574814374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159696,"user_name":"nullptr","can_delete":false,"product_type":"c1","uid":1759752,"ip_address":"","ucode":"1A26EA0D1A2C10","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqtvuo1wE3XU1mBmtIDfrAQZ2NofBQM5sZhBWicMXicdsrfJ6t87yrlXwqFj0PB6Kx8QU3AVCR4TIHw/132","comment_is_top":false,"comment_ctime":1575730223,"is_pvip":false,"replies":[{"id":61019,"content":"是这样的。所以第3讲我把这个单独作为问题提出来了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575778837,"ip_address":"","comment_id":159696,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"我一直在纠结那个拷贝赋值参数不是引用的问题，不是引用的话，会产生一次拷贝构造函数，所以已经增加了引用计数，接着进行简单的swap操作就ok了，读者需要思考这个问题，很多人会忽略","like_count":11,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475947,"discussion_content":"一遍看不懂，就再看一遍。所有的代码自己试验一下。😀\n\n学习无捷径。掌握 C++ 不是 30 个课时能解决的事情。一万小时理论对于任何复杂领域都是基本适用的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574814374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155795,"user_name":"frazer","can_delete":false,"product_type":"c1","uid":1194427,"ip_address":"","ucode":"36869573D98495","user_header":"https://static001.geekbang.org/account/avatar/00/12/39/bb/3dd9ef18.jpg","comment_is_top":false,"comment_ctime":1574757933,"is_pvip":false,"replies":[{"id":59877,"content":"没关系。我打赌你看的时间肯定没我写稿的时间长。😁","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574765427,"ip_address":"","comment_id":155795,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"有点吃力了，得反复看几遍","like_count":115,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475875,"discussion_content":"没关系。我打赌你看的时间肯定没我写稿的时间长。😁","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1574765427,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1346028,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKSCRYv3q4f08a3JZjZd4Dpf2IL0g4mkQ9WtcAM3zcCZsA8r9GMpcUmsXGueVMibtJBxXDNGKx75rA/132","nickname":"dasheyuan","note":"","ucode":"AD61112AB070DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62481,"discussion_content":"已经第3遍了。催更....","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574846673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1132347,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/3b/15e4490f.jpg","nickname":"盛艳明","note":"","ucode":"E4C1C699572C44","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":68171,"discussion_content":"再一点点的啃","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575205061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1151971,"avatar":"https://static001.geekbang.org/account/avatar/00/11/93/e3/da819340.jpg","nickname":"马仔","note":"","ucode":"75760150602EA5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1132347,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/3b/15e4490f.jpg","nickname":"盛艳明","note":"","ucode":"E4C1C699572C44","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":100513,"discussion_content":"是的呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577265883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":68171,"ip_address":"","group_id":0},"score":100513,"extra":""}]}]},{"had_liked":false,"id":155906,"user_name":"yuchen","can_delete":false,"product_type":"c1","uid":1605025,"ip_address":"","ucode":"D4B55B57D218CB","user_header":"https://static001.geekbang.org/account/avatar/00/18/7d/a1/46c5293c.jpg","comment_is_top":false,"comment_ctime":1574777231,"is_pvip":false,"replies":[{"id":59924,"content":"谢谢。\n\n《Professional C++》之前没看过，扫了两眼，觉得内容不错，推荐。内容还挺多挺深的，适合决心在 C++ 上深入的同学。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574813297,"ip_address":"","comment_id":155906,"utype":1}],"discussion_count":5,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"有深度的专栏，不错。市面上讲解C++的课程一般太基础了。这一章推荐读者可以看看《Professional C＋＋ 4th edition》第九章。","like_count":37,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475920,"discussion_content":"谢谢。\n\n《Professional C++》之前没看过，扫了两眼，觉得内容不错，推荐。内容还挺多挺深的，适合决心在 C++ 上深入的同学。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574813297,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1949454,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/bf/0e/0e6419a9.jpg","nickname":"薛瑞","note":"","ucode":"FE634CB0C1BAEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":257474,"discussion_content":"这本书墙裂推荐啊，有中文版，C++高级编程，相当给力","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588574962,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2557701,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Wjsc175urqxxBcCsxSDG5iaWcEq4hIg4SCCVJCIC108Ul5l7US4iaE3iaaMWodSJeybGemicEnfetHFCj9P6QI17xw/132","nickname":"Geek_15f2c9","note":"","ucode":"3AA686B1D31AB1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365823,"discussion_content":"有电子版吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617888262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1760853,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/de/55/d690fe48.jpg","nickname":"西域黑鸦","note":"","ucode":"D1B8BE1AF4699E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":104406,"discussion_content":"哪里可以买到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577431633,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1055296,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1a/40/f10493ef.jpg","nickname":"中山浪子","note":"","ucode":"25D0F8462473D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1760853,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/de/55/d690fe48.jpg","nickname":"西域黑鸦","note":"","ucode":"D1B8BE1AF4699E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":606194,"discussion_content":"现在有第五版","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1677027229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":104406,"ip_address":"上海","group_id":0},"score":606194,"extra":""}]}]},{"had_liked":false,"id":157236,"user_name":"皓首不倦","can_delete":false,"product_type":"c1","uid":1144626,"ip_address":"","ucode":"FA7D282DD40D83","user_header":"https://static001.geekbang.org/account/avatar/00/11/77/32/02416d97.jpg","comment_is_top":false,"comment_ctime":1575094017,"is_pvip":false,"replies":[{"id":60316,"content":"这是一个很特殊的、甚至有点恼人的情况。如果没有非泛型版本，编译器看到没有拷贝构造函数，会生成一个缺省的拷贝构造函数。这样，同样类型的smart_ptr的拷贝构造会是错误的。“子类指针向基类指针的转换”这一节里我也提到了这点。这不是我讲智能指针想讲的内容，所以就淡化了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575108945,"ip_address":"","comment_id":157236,"utype":1}],"discussion_count":5,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"请问下老师smart ptr 的拷贝构造函数为什么有一个泛型版本 还有一个非泛型版本 但是函数体内容又一模一样 不是代码冗余的吗 是有什么特殊设计意图吗 请老师指教下","like_count":35,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476371,"discussion_content":"这是一个很特殊的、甚至有点恼人的情况。如果没有非泛型版本，编译器看到没有拷贝构造函数，会生成一个缺省的拷贝构造函数。这样，同样类型的smart_ptr的拷贝构造会是错误的。“子类指针向基类指针的转换”这一节里我也提到了这点。这不是我讲智能指针想讲的内容，所以就淡化了。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1575108945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1743064,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/98/d8/db4cef94.jpg","nickname":"Alan","note":"","ucode":"C656A2B4FF8C50","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":646213,"discussion_content":"这点好坑啊！感觉文中可以提一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1717575284,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1799719,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/76/27/aa2743e7.jpg","nickname":"小南风","note":"","ucode":"249B070497C815","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":625072,"discussion_content":"下面是chatgpt4.0的回答， 请问它的回答正确吗？\n------------------------------------------------------------------------------------------------- \n\n当设计一个智能指针类时，为了提供更灵活的拷贝构造函数支持，可以使用泛型版本和非泛型版本的拷贝构造函数。\n\n首先，让我们回顾一下泛型和模板的概念。泛型是指能够处理多种不同类型的代码或函数。模板是一种在编译时生成代码的机制，它可以用于创建泛型代码。在C++中，模板使用关键字template来定义。\n\n在smart_ptr类中，有两个拷贝构造函数：一个是泛型版本，一个是非泛型版本。它们的函数体内容相同，但参数类型不同。\n\n泛型版本的拷贝构造函数smart_ptr(const smart_ptr&amp; other) noexcept接受一个smart_ptr类型的参数other。这个版本的拷贝构造函数可以用于拷贝相同类型的智能指针对象。例如，如果有一个smart_ptr&lt;int&gt;对象，可以使用这个拷贝构造函数来拷贝另一个smart_ptr&lt;int&gt;对象。\n\n非泛型版本的拷贝构造函数template &lt;typename U&gt; smart_ptr(const smart_ptr&lt;U&gt;&amp; other) noexcept使用模板参数U，它接受一个不同类型的smart_ptr类型的参数other。这个非泛型版本的拷贝构造函数可以用于进行类型转换。例如，如果有一个smart_ptr&lt;Base&gt;对象，可以使用这个拷贝构造函数将其拷贝为smart_ptr&lt;Derived&gt;对象。\n\n虽然两个版本的拷贝构造函数的函数体内容相同，但是通过提供不同的参数类型，使得编译器可以根据参数类型进行函数匹配，从而选择合适的拷贝构造函数版本。\n\n这种设计的好处是，它提供了更灵活和通用的拷贝构造函数支持，可以适应不同的使用场景。通过使用泛型和模板，可以避免手动进行类型转换，提供更方便的使用方式。虽然在这个特定的代码中，函数体内容相同可能看起来有些冗余，但这种设计可以支持更多的类型转换需求，并提供更灵活的接口。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1691285301,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3044278,"avatar":"https://static001.geekbang.org/account/avatar/00/2e/73/b6/73f85077.jpg","nickname":"DDRH","note":"","ucode":"047BF2A1D1A27A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590316,"discussion_content":"不看这条真的没注意～respect","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665651570,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1144626,"avatar":"https://static001.geekbang.org/account/avatar/00/11/77/32/02416d97.jpg","nickname":"皓首不倦","note":"","ucode":"FA7D282DD40D83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":66864,"discussion_content":"刚刚实际写代码测试了一下 还真的是您解释的这样 以前都没注意到这个点 这个点已加入个人编码踩坑备忘录 万幸在工程实际踩坑前看到您的专题 感谢您的指点 老师的专题写得很棒 期待后面专题内容","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575112865,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155667,"user_name":"流浪地球","can_delete":false,"product_type":"c1","uid":1498137,"ip_address":"","ucode":"25210DCD353F97","user_header":"https://static001.geekbang.org/account/avatar/00/16/dc/19/c058bcbf.jpg","comment_is_top":false,"comment_ctime":1574734740,"is_pvip":false,"replies":[{"id":59858,"content":"嘻嘻，我在偷偷地塞进C++11的语法。对象初始化可以统一用大括号。（小括号这儿也行。）","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574762471,"ip_address":"","comment_id":155667,"utype":1}],"discussion_count":5,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师您好，问一个比较基础的问题，我理解这个语句\nsmart_ptr&lt;shape&gt;  ptr1{create_shape(shape_type::circle)};  是调用ptr1的拷贝构造函数。\n为什么{create_shape(shape_type::circle)}是使用大括号，不应该是小括号吗？\n谢谢\n","like_count":32,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476371,"discussion_content":"这是一个很特殊的、甚至有点恼人的情况。如果没有非泛型版本，编译器看到没有拷贝构造函数，会生成一个缺省的拷贝构造函数。这样，同样类型的smart_ptr的拷贝构造会是错误的。“子类指针向基类指针的转换”这一节里我也提到了这点。这不是我讲智能指针想讲的内容，所以就淡化了。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1575108945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1743064,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/98/d8/db4cef94.jpg","nickname":"Alan","note":"","ucode":"C656A2B4FF8C50","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":646213,"discussion_content":"这点好坑啊！感觉文中可以提一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1717575284,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1799719,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/76/27/aa2743e7.jpg","nickname":"小南风","note":"","ucode":"249B070497C815","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":625072,"discussion_content":"下面是chatgpt4.0的回答， 请问它的回答正确吗？\n------------------------------------------------------------------------------------------------- \n\n当设计一个智能指针类时，为了提供更灵活的拷贝构造函数支持，可以使用泛型版本和非泛型版本的拷贝构造函数。\n\n首先，让我们回顾一下泛型和模板的概念。泛型是指能够处理多种不同类型的代码或函数。模板是一种在编译时生成代码的机制，它可以用于创建泛型代码。在C++中，模板使用关键字template来定义。\n\n在smart_ptr类中，有两个拷贝构造函数：一个是泛型版本，一个是非泛型版本。它们的函数体内容相同，但参数类型不同。\n\n泛型版本的拷贝构造函数smart_ptr(const smart_ptr&amp; other) noexcept接受一个smart_ptr类型的参数other。这个版本的拷贝构造函数可以用于拷贝相同类型的智能指针对象。例如，如果有一个smart_ptr&lt;int&gt;对象，可以使用这个拷贝构造函数来拷贝另一个smart_ptr&lt;int&gt;对象。\n\n非泛型版本的拷贝构造函数template &lt;typename U&gt; smart_ptr(const smart_ptr&lt;U&gt;&amp; other) noexcept使用模板参数U，它接受一个不同类型的smart_ptr类型的参数other。这个非泛型版本的拷贝构造函数可以用于进行类型转换。例如，如果有一个smart_ptr&lt;Base&gt;对象，可以使用这个拷贝构造函数将其拷贝为smart_ptr&lt;Derived&gt;对象。\n\n虽然两个版本的拷贝构造函数的函数体内容相同，但是通过提供不同的参数类型，使得编译器可以根据参数类型进行函数匹配，从而选择合适的拷贝构造函数版本。\n\n这种设计的好处是，它提供了更灵活和通用的拷贝构造函数支持，可以适应不同的使用场景。通过使用泛型和模板，可以避免手动进行类型转换，提供更方便的使用方式。虽然在这个特定的代码中，函数体内容相同可能看起来有些冗余，但这种设计可以支持更多的类型转换需求，并提供更灵活的接口。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1691285301,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3044278,"avatar":"https://static001.geekbang.org/account/avatar/00/2e/73/b6/73f85077.jpg","nickname":"DDRH","note":"","ucode":"047BF2A1D1A27A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590316,"discussion_content":"不看这条真的没注意～respect","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665651570,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1144626,"avatar":"https://static001.geekbang.org/account/avatar/00/11/77/32/02416d97.jpg","nickname":"皓首不倦","note":"","ucode":"FA7D282DD40D83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":66864,"discussion_content":"刚刚实际写代码测试了一下 还真的是您解释的这样 以前都没注意到这个点 这个点已加入个人编码踩坑备忘录 万幸在工程实际踩坑前看到您的专题 感谢您的指点 老师的专题写得很棒 期待后面专题内容","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575112865,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156428,"user_name":"NEVER SETTLE","can_delete":false,"product_type":"c1","uid":1101894,"ip_address":"","ucode":"9C86BDAFDBF768","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/46/1a9229b3.jpg","comment_is_top":false,"comment_ctime":1574869941,"is_pvip":false,"replies":[{"id":60072,"content":"3. 赋值需要一个对象（不是引用），因而在进入执行前就要引发一个构造。没有合适的构造函数可用。\n\n4. 同样，要先构造。这回可以用右值引用的构造函数了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574899310,"ip_address":"","comment_id":156428,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师这块没想明白\n&#47;&#47; 1、调用构造函数\nsmart_ptr ptr1{create_shape(shape_type::circle)};\n\n&#47;&#47; 2、因为拷贝构造被禁用，随意编译出错\nsmart_ptr ptr2{ptr1}; &#47;&#47; 编译出错\n\nsmart_ptr ptr3;\n\n&#47;&#47; 3、没明白为啥会出错\nptr3 = ptr1;        &#47;&#47; 编译出错\n\n&#47;&#47; 4、没明白为啥OK，=重载函数的参数不是右值引用呀\nptr3 = std::move(ptr1); &#47;&#47; OK，\n\n请老师指定 3 与 4","like_count":27,"discussions":[{"author":{"id":1422582,"avatar":"https://static001.geekbang.org/account/avatar/00/15/b4/f6/735673f7.jpg","nickname":"W.jyao","note":"","ucode":"C57B3A78B6A795","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60732,"discussion_content":"调用构造函数。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1574749842,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475823,"discussion_content":"嘻嘻，我在偷偷地塞进C++11的语法。对象初始化可以统一用大括号。（小括号这儿也行。）","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574762471,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1911448,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/ajNVdqHZLLCBR2aB7H8ic3FalKn9x1lXg83KmgYqTznCByz3nZjd9CXLTiaFo22piafibJd04p7jKiblyUic6Eo22esA/132","nickname":"谌鹏飞","note":"","ucode":"AC8D00E3E18D49","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219630,"discussion_content":"这个也是反应了一会儿才知道是c11的语法的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585790324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1547048,"avatar":"https://static001.geekbang.org/account/avatar/00/17/9b/28/9d89de4d.jpg","nickname":"暒","note":"","ucode":"9C956F418C66BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":85653,"discussion_content":"是呀，看了半天我才想起来11 的用大括号进行对象初始化","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576563112,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1609948,"avatar":"https://static001.geekbang.org/account/avatar/00/18/90/dc/44ce2f23.jpg","nickname":"氕氘氚","note":"","ucode":"6B5477BF23AA4A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577821,"discussion_content":"初始化列表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656372605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156435,"user_name":"yyfx","can_delete":false,"product_type":"c1","uid":1757872,"ip_address":"","ucode":"230A98762BD678","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/vJD2lw7TUwAl0myKy0PiahuEA75EzPER98wLDcxIvtQQaUiasCpIla7TN3dicMiaAkPxtOdsJh3MicpicD7hV1G5ico4A/132","comment_is_top":false,"comment_ctime":1574870963,"is_pvip":false,"replies":[{"id":60108,"content":"多谢抓虫。正文已更新。\n\n这也证明了，修改代码、没有完整测试，是极易招虫的啊……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574913802,"ip_address":"","comment_id":156435,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"&quot;移动&quot;指针部分有个问题。在使用模板泛化拷贝构造时，p2=p1编译通过，程序异常。测试发现，由于拷贝构造并没有被自动禁用导致。查了下资料，effective45条提到，member templates不影响语言规则，声明member templates用于泛化copy构造时，还需要声明正常的copy构造。","like_count":24,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476103,"discussion_content":"3. 赋值需要一个对象（不是引用），因而在进入执行前就要引发一个构造。没有合适的构造函数可用。\n\n4. 同样，要先构造。这回可以用右值引用的构造函数了。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574899310,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1007115,"avatar":"","nickname":"Geek_xu324o","note":"","ucode":"F46A5582578A31","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350752,"discussion_content":"这里虽然是= operator，其实调用的是拷贝构造函数","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1613998741,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1331396,"avatar":"https://static001.geekbang.org/account/avatar/00/14/50/c4/71d9745f.jpg","nickname":"飏","note":"","ucode":"48701F74729E5E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78978,"discussion_content":"我也有一个相关的疑问，这里的复制操作符声明的参数是值类型，而不是引用。看了std::shared_ptr的声明是值类型。但是在函数内部确实创建了临时对象然后swap之。这里通过swap实现赋值和move是一个特定的技巧吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576041761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1055296,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1a/40/f10493ef.jpg","nickname":"中山浪子","note":"","ucode":"25D0F8462473D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1331396,"avatar":"https://static001.geekbang.org/account/avatar/00/14/50/c4/71d9745f.jpg","nickname":"飏","note":"","ucode":"48701F74729E5E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609790,"discussion_content":"避免了罗嗦的if (this != &amp;rhs) 的判断，swap通过临时对象和成员内容的互换，解决了异常安全的潜在问题。move 是为了调用右值引用的构造函数\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1679215497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":78978,"ip_address":"上海","group_id":0},"score":609790,"extra":""}]}]},{"had_liked":false,"id":161612,"user_name":"贵子","can_delete":false,"product_type":"c1","uid":1690431,"ip_address":"","ucode":"A94801C05CB07E","user_header":"https://static001.geekbang.org/account/avatar/00/19/cb/3f/3d044d18.jpg","comment_is_top":false,"comment_ctime":1576247919,"is_pvip":false,"replies":[{"id":61594,"content":"移进去的话，smart_ptr&lt;circle&gt;::shared_count 和 smart_ptr&lt;shape&gt;::shared_count 成了两个完全不相关的类型，它们的指针（在不做强制类型转换时）也不能互相赋值，不好。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576313097,"ip_address":"","comment_id":161612,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"为什么shared_count类作为smart_ptr的内部类编译不过，而必须作为外部类呢？老师能解释一下吗？谢谢！","like_count":18,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477783,"discussion_content":"移进去的话，smart_ptr&amp;lt;circle&amp;gt;::shared_count 和 smart_ptr&amp;lt;shape&amp;gt;::shared_count 成了两个完全不相关的类型，它们的指针（在不做强制类型转换时）也不能互相赋值，不好。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576313097,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1690431,"avatar":"https://static001.geekbang.org/account/avatar/00/19/cb/3f/3d044d18.jpg","nickname":"贵子","note":"","ucode":"A94801C05CB07E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":82119,"discussion_content":"我明白了，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576321872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161149,"user_name":"总统老唐","can_delete":false,"product_type":"c1","uid":1490070,"ip_address":"","ucode":"F2CC66E5BB4871","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/96/c679bb3d.jpg","comment_is_top":false,"comment_ctime":1576132943,"is_pvip":false,"replies":[{"id":61458,"content":"对。\n\n另外额外加一点，调用移动不一定靠 move。如果函数返回一个 unique_ptr 一样是自然的移动。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576140982,"ip_address":"","comment_id":161149,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"吴老师，关于如何使用移动改善了 auto_ptr 的行为，实现了与 unique_ptr 相近的语义，这里的“改善”是否应该这样理解：\n1， 在没有引入右值引用和移动构造的情况下，构造的 auto_ptr 也能工作，但是会令用户困惑，当用户执行了语句 other_ptr = some_ptr 后，some_ptr 就为空了\n2， 引入右值引用和移动构造后，用户要想用重载的 operator=，必须采用 other_ptr = std::move(some_ptr) 的方式，通过显示调用 std::move，让用户aware到 some_ptr 的内容已经被移动到 other_ptr 了，并且同时默认禁用了参数为左值引用的拷贝构造，导致 other_ptr = some_ptr 无法通过编译，就不会在使用时产生歧义了，这就是 unique_ptr 期望的语义","like_count":18,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477616,"discussion_content":"对。\n\n另外额外加一点，调用移动不一定靠 move。如果函数返回一个 unique_ptr 一样是自然的移动。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576140982,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2662996,"avatar":"https://static001.geekbang.org/account/avatar/00/28/a2/54/49dfb810.jpg","nickname":"宵练2233","note":"","ucode":"3EBDF8195040DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380839,"discussion_content":"根本不用管auto_ptr，这一句不推荐使用了，被淘汰了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624720927,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155988,"user_name":"hdongdong123","can_delete":false,"product_type":"c1","uid":1724769,"ip_address":"","ucode":"D74589952987D9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLICDTy3Aglb3VvyYjSiaR0tkh6jjojiaa8qiccpRHjXGmnJD72iccU36ic29piaenZrREkR1GoPJK1zU9g/132","comment_is_top":false,"comment_ctime":1574790521,"is_pvip":false,"replies":[{"id":59934,"content":"一遍看不懂，就再看一遍。所有的代码自己试验一下。😀\n\n学习无捷径。掌握 C++ 不是 30 个课时能解决的事情。一万小时理论对于任何复杂领域都是基本适用的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574814374,"ip_address":"","comment_id":155988,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"真的好难啊，呜呜呜","like_count":17,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477616,"discussion_content":"对。\n\n另外额外加一点，调用移动不一定靠 move。如果函数返回一个 unique_ptr 一样是自然的移动。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576140982,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2662996,"avatar":"https://static001.geekbang.org/account/avatar/00/28/a2/54/49dfb810.jpg","nickname":"宵练2233","note":"","ucode":"3EBDF8195040DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380839,"discussion_content":"根本不用管auto_ptr，这一句不推荐使用了，被淘汰了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624720927,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159696,"user_name":"nullptr","can_delete":false,"product_type":"c1","uid":1759752,"ip_address":"","ucode":"1A26EA0D1A2C10","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqtvuo1wE3XU1mBmtIDfrAQZ2NofBQM5sZhBWicMXicdsrfJ6t87yrlXwqFj0PB6Kx8QU3AVCR4TIHw/132","comment_is_top":false,"comment_ctime":1575730223,"is_pvip":false,"replies":[{"id":61019,"content":"是这样的。所以第3讲我把这个单独作为问题提出来了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575778837,"ip_address":"","comment_id":159696,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"我一直在纠结那个拷贝赋值参数不是引用的问题，不是引用的话，会产生一次拷贝构造函数，所以已经增加了引用计数，接着进行简单的swap操作就ok了，读者需要思考这个问题，很多人会忽略","like_count":11,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477145,"discussion_content":"是这样的。所以第3讲我把这个单独作为问题提出来了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575778837,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155625,"user_name":"Lilin","can_delete":false,"product_type":"c1","uid":1246721,"ip_address":"","ucode":"3FF845710CF6ED","user_header":"https://static001.geekbang.org/account/avatar/00/13/06/01/64c4b809.jpg","comment_is_top":false,"comment_ctime":1574730192,"is_pvip":false,"replies":[{"id":59863,"content":"希望是难，但还能看得下去。哈哈。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574762970,"ip_address":"","comment_id":155625,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"才第二节，就有点吃力了。这篇专栏真是满满的干货","like_count":11,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475811,"discussion_content":"希望是难，但还能看得下去。哈哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574762970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205640,"user_name":"西钾钾","can_delete":false,"product_type":"c1","uid":1097722,"ip_address":"","ucode":"0EE77083636ED9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJV27QOK57cdpdh3E4hbArCOlccdtjCyWooF9fhjeSKAMo9SN1v9RODkrZUZD4RejjbdsqU2FIeMA/132","comment_is_top":false,"comment_ctime":1586693674,"is_pvip":false,"replies":[{"id":76956,"content":"注意一下我写的是：\n\noperator=(smart_ptr rhs)\n\n在进入函数体时，已经新拷贝构造了一个 smart_ptr 出来了。活全在拷贝构造里干了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1586782659,"ip_address":"","comment_id":205640,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"smart_ptr&amp;  operator=(smart_ptr rhs) noexcept  {    rhs.swap(*this);    return *this;  }\n老师您好，我有个疑问等号运算符，为什么不增加引用计数呢？","like_count":9},{"had_liked":false,"id":162239,"user_name":"lyfei","can_delete":false,"product_type":"c1","uid":1757471,"ip_address":"","ucode":"31ACC702BE6FEA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","comment_is_top":false,"comment_ctime":1576484948,"is_pvip":false,"replies":[{"id":61751,"content":"是，一般情况下是。但没人阻挡你写 new shared_ptr…。\n\n被管理的对象不会在栈上。只能是堆或者你的内存管理器使用的特殊区域。\n\n目前的推荐是不要使用裸指针。使用值，或者智能指针。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576500578,"ip_address":"","comment_id":162239,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师您好，就是我们使用智能指针创建一个对象以后， 包括这个私有成员T* ptr_以及其他都是放在栈空间上的吧？这样就可以对象不在作用域以后，自动调用析构函数，然后delete开辟的相关空间了吧？\n智能指针实质上就是使用一个&quot;栈&quot;上的对象来管理一块内存地址(可能是堆可能是栈)，用&quot;栈&quot;就可以保证析构函数的进行，也就保证了delete的进行，也就避免了内存泄露的问题。\n是不是可以这样理解?\n那我们应该什么时候使用new delete来管理内存，什么时候该使用智能指针呢？\n这些方面有些疑惑，谢谢老师您的讲解与回复。","like_count":8,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475811,"discussion_content":"希望是难，但还能看得下去。哈哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574762970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156842,"user_name":"robonix","can_delete":false,"product_type":"c1","uid":1212323,"ip_address":"","ucode":"866EC82EDA455B","user_header":"https://static001.geekbang.org/account/avatar/00/12/7f/a3/23540579.jpg","comment_is_top":false,"comment_ctime":1574987772,"is_pvip":false,"replies":[{"id":60276,"content":"比如，你的对象有两个成员，管理着两个对象，如果你在拷贝赋值时逐个地复制另外一个对象的相应的两个成员对象，在复制第二个时发生了异常，那 this 对象就处于一个奇怪的状态：既没成功完成复制，也没有了原先的对象。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575032182,"ip_address":"","comment_id":156842,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，文中提到的发生异常，this对象被破坏，具体是指的对象里的什么成员被破坏呢，这个没看的太明白。","like_count":8,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477986,"discussion_content":"是，一般情况下是。但没人阻挡你写 new shared_ptr…。\n\n被管理的对象不会在栈上。只能是堆或者你的内存管理器使用的特殊区域。\n\n目前的推荐是不要使用裸指针。使用值，或者智能指针。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576500578,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84868,"discussion_content":"嗯嗯，谢谢老师的指点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576507599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156393,"user_name":"NEVER SETTLE","can_delete":false,"product_type":"c1","uid":1101894,"ip_address":"","ucode":"9C86BDAFDBF768","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/46/1a9229b3.jpg","comment_is_top":false,"comment_ctime":1574866138,"is_pvip":false,"replies":[{"id":60068,"content":"如果你搞不清，那多半就是不该返回引用的情况。下面会讲到这个话题。简单来说，大部分情况下，应该直接返回对象值。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574898970,"ip_address":"","comment_id":156393,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，问个比较基础的问题，就是运算符重载的时候，我老师搞不清 该返回值 还是 返回引用，这取决于什么？","like_count":8,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476251,"discussion_content":"比如，你的对象有两个成员，管理着两个对象，如果你在拷贝赋值时逐个地复制另外一个对象的相应的两个成员对象，在复制第二个时发生了异常，那 this 对象就处于一个奇怪的状态：既没成功完成复制，也没有了原先的对象。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575032182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155755,"user_name":"W.jyao","can_delete":false,"product_type":"c1","uid":1422582,"ip_address":"","ucode":"C57B3A78B6A795","user_header":"https://static001.geekbang.org/account/avatar/00/15/b4/f6/735673f7.jpg","comment_is_top":false,"comment_ctime":1574749624,"is_pvip":false,"replies":[{"id":59873,"content":"特别有困难的点可以提出。大部分概念的引入我应该都是有解释的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574764356,"ip_address":"","comment_id":155755,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"对不熟悉C++ 11的程序员来看，有的地方不是很懂","like_count":8,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475860,"discussion_content":"特别有困难的点可以提出。大部分概念的引入我应该都是有解释的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574764356,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157147,"user_name":"净莲妖火","can_delete":false,"product_type":"c1","uid":1089372,"ip_address":"","ucode":"2AFE1021696E53","user_header":"https://static001.geekbang.org/account/avatar/00/10/9f/5c/372201cf.jpg","comment_is_top":false,"comment_ctime":1575042043,"is_pvip":false,"replies":[{"id":60294,"content":"嗯，是的。你是最早想起指针还有这些操作的。😁","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575078360,"ip_address":"","comment_id":157147,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"完整的还缺++,- -,+=,-=,&lt;,&gt;等普通指针支持的操作","like_count":7,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475860,"discussion_content":"特别有困难的点可以提出。大部分概念的引入我应该都是有解释的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574764356,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174860,"user_name":"王旧业","can_delete":false,"product_type":"c1","uid":1013076,"ip_address":"","ucode":"A8DEC38430D007","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/54/73cc7f73.jpg","comment_is_top":false,"comment_ctime":1580440576,"is_pvip":false,"replies":[{"id":67968,"content":"是，这部份的规则有点搞，我在第 9 讲才进行了部分描述。跟你说的相关的是这两条：\n\n用户如果没有自己提供一个拷贝构造函数（必须形如 Obj(Obj&amp;) 或 Obj(const Obj&amp;)；不是模板），编译器会隐式声明一个。\n\n用户如果没有自己声明拷贝构造函数、拷贝赋值函数、移动赋值函数和析构函数，编译器会隐式声明一个移动构造函数。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1580447575,"ip_address":"","comment_id":174860,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"这一节确实比较难，有个问题请问下老师，最终版本的smart_ptr中，拷贝构造有两个实现，一个是基于模板用于类型转化场景下使用的A，一个就是普通的拷贝构造B；但是移动构造只有一个，基于模板的C。这种差异的原因是A这种拷贝构造再编译器看来并不是拷贝构造，如果我不写B这个构造，编译器会自动生成一个拷贝构造吗？ 但是移动构造又不会有这种行为吗？","like_count":6,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482549,"discussion_content":"是，这部份的规则有点搞，我在第 9 讲才进行了部分描述。跟你说的相关的是这两条：\n\n用户如果没有自己提供一个拷贝构造函数（必须形如 Obj(Obj&amp;amp;) 或 Obj(const Obj&amp;amp;)；不是模板），编译器会隐式声明一个。\n\n用户如果没有自己声明拷贝构造函数、拷贝赋值函数、移动赋值函数和析构函数，编译器会隐式声明一个移动构造函数。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1580447575,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182307,"user_name":"文若","can_delete":false,"product_type":"c1","uid":1017387,"ip_address":"","ucode":"3D3045975ED2DB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/86/2b/f82a7d5a.jpg","comment_is_top":false,"comment_ctime":1582766667,"is_pvip":false,"replies":[{"id":70608,"content":"23 到 27 讲的内容可以看一下。\n\n专注后端开发的，可以看 Boost.Asio。专栏讨论了 C++ REST SDK（其中用到了 Boost.Asio）。\n\n其他可以考虑的（没有用过，没有明确推荐）：\n\nhttps:&#47;&#47;www.treefrogframework.org&#47;\nhttps:&#47;&#47;www.webtoolkit.eu&#47;wt\nhttp:&#47;&#47;pistache.io&#47;\nhttps:&#47;&#47;github.com&#47;ipkn&#47;crow\nhttps:&#47;&#47;github.com&#47;qicosmos&#47;cinatra","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1582778538,"ip_address":"","comment_id":182307,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，能否推荐一些比较经典的C++开源项目，特别是关于后端开发的。","like_count":5,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485298,"discussion_content":"23 到 27 讲的内容可以看一下。\n\n专注后端开发的，可以看 Boost.Asio。专栏讨论了 C++ REST SDK（其中用到了 Boost.Asio）。\n\n其他可以考虑的（没有用过，没有明确推荐）：\n\nhttps://www.treefrogframework.org/\nhttps://www.webtoolkit.eu/wt\nhttp://pistache.io/\nhttps://github.com/ipkn/crow\nhttps://github.com/qicosmos/cinatra","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582778538,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158685,"user_name":"lyfei","can_delete":false,"product_type":"c1","uid":1757471,"ip_address":"","ucode":"31ACC702BE6FEA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","comment_is_top":false,"comment_ctime":1575433650,"is_pvip":false,"replies":[{"id":60759,"content":"比如，如果你把这个指针传给另外一个函数，参数类型是smart_ptr，等函数返回，这个对象就消失了……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575464338,"ip_address":"","comment_id":158685,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师你好：\n【上面实现的最大问题是，它的行为会让程序员非常容易犯错。一不小心把它传递给另外一个 smart_ptr，你就不再拥有这个对象了……】\nsmart_ptr&lt;int&gt; ptr2(ptr1)\n就是老师讲的这句话中，意思是在使用拷贝构造或者赋值运算符的时候，由于ptr_ = nullptr;的存在所以导致对象ptr1失效了？","like_count":5,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485298,"discussion_content":"23 到 27 讲的内容可以看一下。\n\n专注后端开发的，可以看 Boost.Asio。专栏讨论了 C++ REST SDK（其中用到了 Boost.Asio）。\n\n其他可以考虑的（没有用过，没有明确推荐）：\n\nhttps://www.treefrogframework.org/\nhttps://www.webtoolkit.eu/wt\nhttp://pistache.io/\nhttps://github.com/ipkn/crow\nhttps://github.com/qicosmos/cinatra","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582778538,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155625,"user_name":"Lilin","can_delete":false,"product_type":"c1","uid":1246721,"ip_address":"","ucode":"3FF845710CF6ED","user_header":"https://static001.geekbang.org/account/avatar/00/13/06/01/64c4b809.jpg","comment_is_top":false,"comment_ctime":1574730192,"is_pvip":false,"replies":[{"id":59863,"content":"希望是难，但还能看得下去。哈哈。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574762970,"ip_address":"","comment_id":155625,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"才第二节，就有点吃力了。这篇专栏真是满满的干货","like_count":11,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491537,"discussion_content":"注意一下我写的是：\n\noperator=(smart_ptr rhs)\n\n在进入函数体时，已经新拷贝构造了一个 smart_ptr 出来了。活全在拷贝构造里干了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586782659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205640,"user_name":"西钾钾","can_delete":false,"product_type":"c1","uid":1097722,"ip_address":"","ucode":"0EE77083636ED9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJV27QOK57cdpdh3E4hbArCOlccdtjCyWooF9fhjeSKAMo9SN1v9RODkrZUZD4RejjbdsqU2FIeMA/132","comment_is_top":false,"comment_ctime":1586693674,"is_pvip":false,"replies":[{"id":76956,"content":"注意一下我写的是：\n\noperator=(smart_ptr rhs)\n\n在进入函数体时，已经新拷贝构造了一个 smart_ptr 出来了。活全在拷贝构造里干了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1586782659,"ip_address":"","comment_id":205640,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"smart_ptr&amp;  operator=(smart_ptr rhs) noexcept  {    rhs.swap(*this);    return *this;  }\n老师您好，我有个疑问等号运算符，为什么不增加引用计数呢？","like_count":9,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491537,"discussion_content":"注意一下我写的是：\n\noperator=(smart_ptr rhs)\n\n在进入函数体时，已经新拷贝构造了一个 smart_ptr 出来了。活全在拷贝构造里干了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586782659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162239,"user_name":"lyfei","can_delete":false,"product_type":"c1","uid":1757471,"ip_address":"","ucode":"31ACC702BE6FEA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","comment_is_top":false,"comment_ctime":1576484948,"is_pvip":false,"replies":[{"id":61751,"content":"是，一般情况下是。但没人阻挡你写 new shared_ptr…。\n\n被管理的对象不会在栈上。只能是堆或者你的内存管理器使用的特殊区域。\n\n目前的推荐是不要使用裸指针。使用值，或者智能指针。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576500578,"ip_address":"","comment_id":162239,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师您好，就是我们使用智能指针创建一个对象以后， 包括这个私有成员T* ptr_以及其他都是放在栈空间上的吧？这样就可以对象不在作用域以后，自动调用析构函数，然后delete开辟的相关空间了吧？\n智能指针实质上就是使用一个&quot;栈&quot;上的对象来管理一块内存地址(可能是堆可能是栈)，用&quot;栈&quot;就可以保证析构函数的进行，也就保证了delete的进行，也就避免了内存泄露的问题。\n是不是可以这样理解?\n那我们应该什么时候使用new delete来管理内存，什么时候该使用智能指针呢？\n这些方面有些疑惑，谢谢老师您的讲解与回复。","like_count":8,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477986,"discussion_content":"是，一般情况下是。但没人阻挡你写 new shared_ptr…。\n\n被管理的对象不会在栈上。只能是堆或者你的内存管理器使用的特殊区域。\n\n目前的推荐是不要使用裸指针。使用值，或者智能指针。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576500578,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84868,"discussion_content":"嗯嗯，谢谢老师的指点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576507599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156842,"user_name":"robonix","can_delete":false,"product_type":"c1","uid":1212323,"ip_address":"","ucode":"866EC82EDA455B","user_header":"https://static001.geekbang.org/account/avatar/00/12/7f/a3/23540579.jpg","comment_is_top":false,"comment_ctime":1574987772,"is_pvip":false,"replies":[{"id":60276,"content":"比如，你的对象有两个成员，管理着两个对象，如果你在拷贝赋值时逐个地复制另外一个对象的相应的两个成员对象，在复制第二个时发生了异常，那 this 对象就处于一个奇怪的状态：既没成功完成复制，也没有了原先的对象。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575032182,"ip_address":"","comment_id":156842,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，文中提到的发生异常，this对象被破坏，具体是指的对象里的什么成员被破坏呢，这个没看的太明白。","like_count":8,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476251,"discussion_content":"比如，你的对象有两个成员，管理着两个对象，如果你在拷贝赋值时逐个地复制另外一个对象的相应的两个成员对象，在复制第二个时发生了异常，那 this 对象就处于一个奇怪的状态：既没成功完成复制，也没有了原先的对象。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575032182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156393,"user_name":"NEVER SETTLE","can_delete":false,"product_type":"c1","uid":1101894,"ip_address":"","ucode":"9C86BDAFDBF768","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/46/1a9229b3.jpg","comment_is_top":false,"comment_ctime":1574866138,"is_pvip":false,"replies":[{"id":60068,"content":"如果你搞不清，那多半就是不该返回引用的情况。下面会讲到这个话题。简单来说，大部分情况下，应该直接返回对象值。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574898970,"ip_address":"","comment_id":156393,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，问个比较基础的问题，就是运算符重载的时候，我老师搞不清 该返回值 还是 返回引用，这取决于什么？","like_count":8,"discussions":[{"author":{"id":1141324,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/dDk3WicuUbhvcb4R8PD0YiaFteqQvC4UpXHw4chKLDKB0qaOGeCxBJ3nfiaNZAyVQmAgesyE2MvABydxg6gic29j5w/132","nickname":"二杠一","note":"","ucode":"040C9A30E7ADF4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79030,"discussion_content":"赋值操作符返回引用是为了连续赋值","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1576048214,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476094,"discussion_content":"如果你搞不清，那多半就是不该返回引用的情况。下面会讲到这个话题。简单来说，大部分情况下，应该直接返回对象值。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574898970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155755,"user_name":"W.jyao","can_delete":false,"product_type":"c1","uid":1422582,"ip_address":"","ucode":"C57B3A78B6A795","user_header":"https://static001.geekbang.org/account/avatar/00/15/b4/f6/735673f7.jpg","comment_is_top":false,"comment_ctime":1574749624,"is_pvip":false,"replies":[{"id":59873,"content":"特别有困难的点可以提出。大部分概念的引入我应该都是有解释的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574764356,"ip_address":"","comment_id":155755,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"对不熟悉C++ 11的程序员来看，有的地方不是很懂","like_count":8,"discussions":[{"author":{"id":1141324,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/dDk3WicuUbhvcb4R8PD0YiaFteqQvC4UpXHw4chKLDKB0qaOGeCxBJ3nfiaNZAyVQmAgesyE2MvABydxg6gic29j5w/132","nickname":"二杠一","note":"","ucode":"040C9A30E7ADF4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79030,"discussion_content":"赋值操作符返回引用是为了连续赋值","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1576048214,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476094,"discussion_content":"如果你搞不清，那多半就是不该返回引用的情况。下面会讲到这个话题。简单来说，大部分情况下，应该直接返回对象值。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574898970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157147,"user_name":"净莲妖火","can_delete":false,"product_type":"c1","uid":1089372,"ip_address":"","ucode":"2AFE1021696E53","user_header":"https://static001.geekbang.org/account/avatar/00/10/9f/5c/372201cf.jpg","comment_is_top":false,"comment_ctime":1575042043,"is_pvip":false,"replies":[{"id":60294,"content":"嗯，是的。你是最早想起指针还有这些操作的。😁","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575078360,"ip_address":"","comment_id":157147,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"完整的还缺++,- -,+=,-=,&lt;,&gt;等普通指针支持的操作","like_count":7,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476340,"discussion_content":"嗯，是的。你是最早想起指针还有这些操作的。😁","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575078360,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2557701,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Wjsc175urqxxBcCsxSDG5iaWcEq4hIg4SCCVJCIC108Ul5l7US4iaE3iaaMWodSJeybGemicEnfetHFCj9P6QI17xw/132","nickname":"Geek_15f2c9","note":"","ucode":"3AA686B1D31AB1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366052,"discussion_content":"标准库不支持++，--这些操作的，某些迭代器才支持","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1617949523,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1784280,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/39/d8/b656bc67.jpg","nickname":"Utopian","note":"","ucode":"E203B7425D8382","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303466,"discussion_content":"-- ++ += -= 是不支持的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599275494,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174860,"user_name":"王旧业","can_delete":false,"product_type":"c1","uid":1013076,"ip_address":"","ucode":"A8DEC38430D007","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/54/73cc7f73.jpg","comment_is_top":false,"comment_ctime":1580440576,"is_pvip":false,"replies":[{"id":67968,"content":"是，这部份的规则有点搞，我在第 9 讲才进行了部分描述。跟你说的相关的是这两条：\n\n用户如果没有自己提供一个拷贝构造函数（必须形如 Obj(Obj&amp;) 或 Obj(const Obj&amp;)；不是模板），编译器会隐式声明一个。\n\n用户如果没有自己声明拷贝构造函数、拷贝赋值函数、移动赋值函数和析构函数，编译器会隐式声明一个移动构造函数。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1580447575,"ip_address":"","comment_id":174860,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"这一节确实比较难，有个问题请问下老师，最终版本的smart_ptr中，拷贝构造有两个实现，一个是基于模板用于类型转化场景下使用的A，一个就是普通的拷贝构造B；但是移动构造只有一个，基于模板的C。这种差异的原因是A这种拷贝构造再编译器看来并不是拷贝构造，如果我不写B这个构造，编译器会自动生成一个拷贝构造吗？ 但是移动构造又不会有这种行为吗？","like_count":6,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476340,"discussion_content":"嗯，是的。你是最早想起指针还有这些操作的。😁","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575078360,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2557701,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Wjsc175urqxxBcCsxSDG5iaWcEq4hIg4SCCVJCIC108Ul5l7US4iaE3iaaMWodSJeybGemicEnfetHFCj9P6QI17xw/132","nickname":"Geek_15f2c9","note":"","ucode":"3AA686B1D31AB1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366052,"discussion_content":"标准库不支持++，--这些操作的，某些迭代器才支持","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1617949523,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1784280,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/39/d8/b656bc67.jpg","nickname":"Utopian","note":"","ucode":"E203B7425D8382","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303466,"discussion_content":"-- ++ += -= 是不支持的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599275494,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182307,"user_name":"文若","can_delete":false,"product_type":"c1","uid":1017387,"ip_address":"","ucode":"3D3045975ED2DB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/86/2b/f82a7d5a.jpg","comment_is_top":false,"comment_ctime":1582766667,"is_pvip":false,"replies":[{"id":70608,"content":"23 到 27 讲的内容可以看一下。\n\n专注后端开发的，可以看 Boost.Asio。专栏讨论了 C++ REST SDK（其中用到了 Boost.Asio）。\n\n其他可以考虑的（没有用过，没有明确推荐）：\n\nhttps:&#47;&#47;www.treefrogframework.org&#47;\nhttps:&#47;&#47;www.webtoolkit.eu&#47;wt\nhttp:&#47;&#47;pistache.io&#47;\nhttps:&#47;&#47;github.com&#47;ipkn&#47;crow\nhttps:&#47;&#47;github.com&#47;qicosmos&#47;cinatra","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1582778538,"ip_address":"","comment_id":182307,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，能否推荐一些比较经典的C++开源项目，特别是关于后端开发的。","like_count":5,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482549,"discussion_content":"是，这部份的规则有点搞，我在第 9 讲才进行了部分描述。跟你说的相关的是这两条：\n\n用户如果没有自己提供一个拷贝构造函数（必须形如 Obj(Obj&amp;amp;) 或 Obj(const Obj&amp;amp;)；不是模板），编译器会隐式声明一个。\n\n用户如果没有自己声明拷贝构造函数、拷贝赋值函数、移动赋值函数和析构函数，编译器会隐式声明一个移动构造函数。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1580447575,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158685,"user_name":"lyfei","can_delete":false,"product_type":"c1","uid":1757471,"ip_address":"","ucode":"31ACC702BE6FEA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","comment_is_top":false,"comment_ctime":1575433650,"is_pvip":false,"replies":[{"id":60759,"content":"比如，如果你把这个指针传给另外一个函数，参数类型是smart_ptr，等函数返回，这个对象就消失了……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575464338,"ip_address":"","comment_id":158685,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师你好：\n【上面实现的最大问题是，它的行为会让程序员非常容易犯错。一不小心把它传递给另外一个 smart_ptr，你就不再拥有这个对象了……】\nsmart_ptr&lt;int&gt; ptr2(ptr1)\n就是老师讲的这句话中，意思是在使用拷贝构造或者赋值运算符的时候，由于ptr_ = nullptr;的存在所以导致对象ptr1失效了？","like_count":5,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476808,"discussion_content":"比如，如果你把这个指针传给另外一个函数，参数类型是smart_ptr，等函数返回，这个对象就消失了……","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575464338,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157471,"user_name":"metalmac.kyle","can_delete":false,"product_type":"c1","uid":1001832,"ip_address":"","ucode":"74795A8825FCAA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/68/bef5f7d3.jpg","comment_is_top":false,"comment_ctime":1575170740,"is_pvip":false,"replies":[{"id":60366,"content":"没错，相关的知识点很多，一定要多实践才行。\n\n不过，回过头来看，我觉得我拿智能指针开头，难度可能是有点设高了。哈哈。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575183383,"ip_address":"","comment_id":157471,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"通过老师的例子来学习深入学习智能指针，感觉这种案例式都谢谢代入感很强，再难的知识点也不枯燥还能直接学以致用，醍醐灌顶，有种重读csapp的感觉！Cpp一大特性就是各种复杂的语法以及符号设计，这让她被爱的人奉上神坛，恨的人也恨之入骨，指针作为双刃剑充满了恶魔般的魔力，虽然会让人望而却步但也是吸引我一直学习cpp的动力所在，对底层的操作和理解实在让人着魔哈哈。\n言归正传，小小的构造智能指针课蕴含了对Cpp一系列知识的复习巩固，构造函数，运算符重载，指针引用特性，模板等各类知识点的设计与实现，想真正掌握还需要反复上机实践呢，还是应了古话，纸上得来终觉欲知此事须躬行浅！🧐","like_count":5},{"had_liked":false,"id":155888,"user_name":"姜姜","can_delete":false,"product_type":"c1","uid":1120332,"ip_address":"","ucode":"1DAD620C8E9F31","user_header":"https://static001.geekbang.org/account/avatar/00/11/18/4c/e12f3b41.jpg","comment_is_top":false,"comment_ctime":1574774548,"is_pvip":false,"replies":[{"id":59914,"content":"很全。有几个小问题哈（像reset有几个重载不算😄）：\n\n获取原始指针的 get 方法我提供了；\n* 和 -&gt; 代码里是提供的；\n引用计数器值也是有的。\n\n实践层面，最大的区别，除了不支持弱引用外，可能是不支持自定义删除器了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574812032,"ip_address":"","comment_id":155888,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"这个smart_ptr目前已经实现了:获取所有权，共享所有权，拷贝赋值语意，计数器，自动增减等功能。\n还缺少: 转移所有权reset的操作(我记得reset有三种重载方式);  获取原始指针方法，重写解引用*，重写指向操作符-&gt;，重写比较操作符，获取引用计数器值的方法，判断当前引用是否为1的方法，以及线程安全的设计。\n最后，shared_ptr本身还需要解决“循环引用”，“自引用”的问题，一般需要搭配弱指针weak_ptr使用。\n老师，不知我回答的是否全面，有无差错？","like_count":5,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475912,"discussion_content":"很全。有几个小问题哈（像reset有几个重载不算😄）：\n\n获取原始指针的 get 方法我提供了；\n* 和 -&amp;gt; 代码里是提供的；\n引用计数器值也是有的。\n\n实践层面，最大的区别，除了不支持弱引用外，可能是不支持自定义删除器了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574812032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1120332,"avatar":"https://static001.geekbang.org/account/avatar/00/11/18/4c/e12f3b41.jpg","nickname":"姜姜","note":"","ucode":"1DAD620C8E9F31","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62055,"discussion_content":"不好意思啊，没看仔细，get()，use_count() ，  operator*()，  operator->()，  operator bool() ，这几个方法老师都已经提供了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574815415,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158472,"user_name":"lyfei","can_delete":false,"product_type":"c1","uid":1757471,"ip_address":"","ucode":"31ACC702BE6FEA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","comment_is_top":false,"comment_ctime":1575379232,"is_pvip":false,"replies":[{"id":60660,"content":"这个实现不支持。需要写更多的代码。\n\nC++17 的 shared_ptr 可以支持这样的写法，但也得明确告诉编译器是数组：\n\nstd::shared_ptr&lt;int[]&gt; ptr1{new int[5]};\nauto ptr2 = std::shared_ptr&lt;int[]&gt;{new int[5]};\n\nC++20 进一步支持：\n\nauto ptr3 = std::make_shared&lt;int[]&gt;(5);\n\n另外，new int[5] 之后用 delete 是不对（好）的。这儿一般还不会出问题，如果是带析构的对象就一定会出问题的。new …[] 之后一定用 delete[] …。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575383517,"ip_address":"","comment_id":158472,"utype":1}],"discussion_count":3,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"老师你好，那我如果想实现类似的:\nint* xxx = new int[5]; delete xxx;\n使用智能指针怎么做?\nsmart_ptr&lt;int&gt; test_ptr(new int[5]);","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475912,"discussion_content":"很全。有几个小问题哈（像reset有几个重载不算😄）：\n\n获取原始指针的 get 方法我提供了；\n* 和 -&amp;gt; 代码里是提供的；\n引用计数器值也是有的。\n\n实践层面，最大的区别，除了不支持弱引用外，可能是不支持自定义删除器了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574812032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1120332,"avatar":"https://static001.geekbang.org/account/avatar/00/11/18/4c/e12f3b41.jpg","nickname":"姜姜","note":"","ucode":"1DAD620C8E9F31","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62055,"discussion_content":"不好意思啊，没看仔细，get()，use_count() ，  operator*()，  operator->()，  operator bool() ，这几个方法老师都已经提供了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574815415,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157207,"user_name":"贾陆华","can_delete":false,"product_type":"c1","uid":1321408,"ip_address":"","ucode":"2722C422077EE0","user_header":"https://static001.geekbang.org/account/avatar/00/14/29/c0/86fa3e92.jpg","comment_is_top":false,"comment_ctime":1575082599,"is_pvip":false,"replies":[{"id":60314,"content":"事实上，大部分C++的标准类都是这么设计的。不必要的加锁，会降低性能。如果你需要对shared_ptr或vector加锁，你可以在外面加，或者自己实现一个自己需要的线程安全的版本。有些场景下，也能找到第三方库这么做。\n\n以shared_ptr为例，我个人真还没觉得有多少场景需要并发访问一个智能指针。你更可能在创建新的线程时，给它拷贝一个新的智能指针。这样，大家只需要对被访问的对象同步，而不是对智能指针同步。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575107995,"ip_address":"","comment_id":157207,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"多年不学习C++新知识，对move 移动构造函数  完美转发这些理解不是很清晰，希望看完这个专栏能理解更深入，其他的感觉还行，shared_ptr不是线程安全的，只是共享计数使用了原子计数，为什么要这么设计？","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476740,"discussion_content":"这个实现不支持。需要写更多的代码。\n\nC++17 的 shared_ptr 可以支持这样的写法，但也得明确告诉编译器是数组：\n\nstd::shared_ptr&amp;lt;int[]&amp;gt; ptr1{new int[5]};\nauto ptr2 = std::shared_ptr&amp;lt;int[]&amp;gt;{new int[5]};\n\nC++20 进一步支持：\n\nauto ptr3 = std::make_shared&amp;lt;int[]&amp;gt;(5);\n\n另外，new int[5] 之后用 delete 是不对（好）的。这儿一般还不会出问题，如果是带析构的对象就一定会出问题的。new …[] 之后一定用 delete[] …。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575383517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":71327,"discussion_content":"嗯嗯，谢谢老师耐心且详细的解答，学习到了很多。\n谢谢老师，明白","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575392956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70849,"discussion_content":"传统的数据类型是可以的，自定义的就不行了。\n比如:\nsmart_ptr<circle> test_ptr(new circle[5]);","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575382126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157128,"user_name":"Zephyr","can_delete":false,"product_type":"c1","uid":1635120,"ip_address":"","ucode":"1DF3525146BFE7","user_header":"https://static001.geekbang.org/account/avatar/00/18/f3/30/8a8b2155.jpg","comment_is_top":false,"comment_ctime":1575037774,"is_pvip":false,"replies":[{"id":60295,"content":"第一周一次性放三讲。后面每周更新三次，一次一讲。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575078418,"ip_address":"","comment_id":157128,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"老师，是一直没有更新吗，还是我看不到，我记得是买过这个课程了","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476362,"discussion_content":"事实上，大部分C++的标准类都是这么设计的。不必要的加锁，会降低性能。如果你需要对shared_ptr或vector加锁，你可以在外面加，或者自己实现一个自己需要的线程安全的版本。有些场景下，也能找到第三方库这么做。\n\n以shared_ptr为例，我个人真还没觉得有多少场景需要并发访问一个智能指针。你更可能在创建新的线程时，给它拷贝一个新的智能指针。这样，大家只需要对被访问的对象同步，而不是对智能指针同步。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575107995,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1321408,"avatar":"https://static001.geekbang.org/account/avatar/00/14/29/c0/86fa3e92.jpg","nickname":"贾陆华","note":"","ucode":"2722C422077EE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70755,"discussion_content":"明白了，就是说对被访问的对象，外部再进行同步，谢谢吴老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575379400,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156849,"user_name":"中山浪子","can_delete":false,"product_type":"c1","uid":1055296,"ip_address":"","ucode":"25D0F8462473D3","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/40/f10493ef.jpg","comment_is_top":false,"comment_ctime":1574988250,"is_pvip":false,"replies":[{"id":60266,"content":"我知道、能想得起的参考资料肯定会贴出来。毕竟，三十讲的时间肯定是不够的。大家一定要阅读更多的资料才行。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575027201,"ip_address":"","comment_id":156849,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"吴老师讲的还是很好的，听着音频看代码感觉跟不上节奏，需要多看几遍才行。同时，文末放上链接也很不错。希望老师能多放些相关的学习推荐资源，授人以鱼不如授人以渔😀","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476336,"discussion_content":"第一周一次性放三讲。后面每周更新三次，一次一讲。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575078418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155662,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1574734127,"is_pvip":false,"replies":[{"id":59861,"content":"应该的。但我们还没学到通用的C++并发编程呢。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574762878,"ip_address":"","comment_id":155662,"utype":1}],"discussion_count":3,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"计数器线程安全是不是更好点","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476254,"discussion_content":"我知道、能想得起的参考资料肯定会贴出来。毕竟，三十讲的时间肯定是不够的。大家一定要阅读更多的资料才行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575027201,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":275544,"user_name":"蓦然回首","can_delete":false,"product_type":"c1","uid":1172090,"ip_address":"","ucode":"B17658DCFE6402","user_header":"https://static001.geekbang.org/account/avatar/00/11/e2/7a/38a27e47.jpg","comment_is_top":false,"comment_ctime":1611579174,"is_pvip":true,"replies":[{"id":100031,"content":"swap 的约定是不发生异常，它当然不能保证不发生异常。用户需要保证不让 swap 抛出异常。这是用户需要做到的，否则程序在发生异常时会崩溃。\n\n对于你的具体例子，对指针的交换自然不会发生异常，所以对 smart_ptr 的 swap 操作不会有异常。自增对内置类型和 atomic 类型不会发生异常。而对于你自己的定义的类，就看你自己的类的行为了。异常是否会发生，是程序员自己定义的，所以程序员要负责对不会发生异常的函数手工标明 noexcept。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1611638312,"ip_address":"","comment_id":275544,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"老师，请教个问题，为什么std::swap本身不会发生异常，我看STL源码里面，也只是在函数头部后面加了个noexcept,而这个只是个不可靠的保证，这里更一般的问题是，到底程序代码什么情况下是一定不会发生异常的，而什么情况下是可能发生异常的，有没有什么规律？比如上面的简单的赋值，为什么就一定不会发生异常，\nusing std::swap;    swap(ptr_, rhs.ptr_);    swap(shared_count_,         rhs.shared_count_);\n再一般的情况，比如 void add_count() noexcept  {    ++count_;  }这种就是个自增运算，那是不是这种就一定不会发生异常呢？异常是否发生，怎么界定？","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475821,"discussion_content":"应该的。但我们还没学到通用的C++并发编程呢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574762878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1212323,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7f/a3/23540579.jpg","nickname":"robonix","note":"","ucode":"866EC82EDA455B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":66709,"discussion_content":"老师，在实时系统中怎么保证线程安全呢，因为实时线程不可以被阻塞呀？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575100030,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1212323,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7f/a3/23540579.jpg","nickname":"robonix","note":"","ucode":"866EC82EDA455B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":99228,"discussion_content":"原子操作，第 19 讲。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577197533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":66709,"ip_address":"","group_id":0},"score":99228,"extra":""}]}]},{"had_liked":false,"id":224253,"user_name":"可爱的小奶狗","can_delete":false,"product_type":"c1","uid":1178236,"ip_address":"","ucode":"DC810503571DD2","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/7c/f8f38ad0.jpg","comment_is_top":false,"comment_ctime":1591324586,"is_pvip":false,"replies":[{"id":82635,"content":"这个代码用了比较安全的拷贝构造加交换的赋值方式。注意你的赋值函数原型是：\n\nA &amp;operator=(A other);\n\n参数是值而不是引用。这意味着，在执行进入这个赋值函数体之前，A other 已经导致拷贝构造被执行了一次。\n\n这是异常安全的惯用法。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1591431825,"ip_address":"","comment_id":224253,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;algorithm&gt;\n\nclass A {\npublic:\n    int n;\n    std::string s1;\n    &#47;&#47;在加了copy constructor时，必须显式加入constructor,编译器不会再隐式提供constructor\n    A(){}\n    &#47;&#47;copy constructor\n    A(const A&amp; a){\n        std::cout &lt;&lt; &quot;copy constructor of A\\n&quot;;\n    }\n\n    &#47;&#47; user-defined copy assignment, copy-and-swap form\n    A &amp;operator=(A other) {\n        std::cout &lt;&lt; &quot;copy assignment of A\\n&quot;;\n        std::swap(n, other.n);\n        std::swap(s1, other.s1);\n        return *this;\n    }\n};\n\n\nint main() {\n    A a1, a2;\n    std::cout &lt;&lt; &quot;a1 = a2 calls &quot;;\n    a1 = a2; \n\n\n}\n老师，以上代码为什么最终会A的copy assignment和copy constructor都会被调用？我觉得拷贝构造和赋值应该是选其中一个才对啊。\ncppreference对copy assignment的调用时的描述：\nThe copy assignment operator is called whenever selected by overload resolution, e.g. when an object appears on the left side of an assignment expression。\n我理解的是copy assignment只会在重载解析才会发生，比如上述代码，如果调用了copy assignment,那么可以推断出发生了重载，那么copy constructor就不会被调用。为什么事实不是这样的呢？","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514390,"discussion_content":"swap 的约定是不发生异常，它当然不能保证不发生异常。用户需要保证不让 swap 抛出异常。这是用户需要做到的，否则程序在发生异常时会崩溃。\n\n对于你的具体例子，对指针的交换自然不会发生异常，所以对 smart_ptr 的 swap 操作不会有异常。自增对内置类型和 atomic 类型不会发生异常。而对于你自己的定义的类，就看你自己的类的行为了。异常是否会发生，是程序员自己定义的，所以程序员要负责对不会发生异常的函数手工标明 noexcept。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1611638312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160366,"user_name":"总统老唐","can_delete":false,"product_type":"c1","uid":1490070,"ip_address":"","ucode":"F2CC66E5BB4871","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/96/c679bb3d.jpg","comment_is_top":false,"comment_ctime":1575941527,"is_pvip":false,"replies":[{"id":61214,"content":"1. 一般而言，拷贝构造函数抛出异常算正常，完全可以用普通的异常安全的做法来避免内存泄漏。基本点就是不要使用裸指针。一定要用，就得小心注意了。\n\n2. 移动的拷贝构造是很危险的，所以现在的智能指针不会这么实现的。拷贝是拷贝，移动是移动，拷贝就不要影响右边。反过来讲，如果纯粹是移动，也不应该发生异常的。但如果你硬要混合移动和拷贝，那就是找罪受了……\n\n3. 我不认为会发生你说的情况。类的复杂性是需要人努力去降低的，其中就包括遵守基本的规范，包括swap不允许发生异常。\n\n在特殊情况下，你开车可以开到停车带甚至逆行。但还是多想想正常的情况为好。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575951682,"ip_address":"","comment_id":160366,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"吴老师，关于拷贝构造和赋值部分的smart_ptr，还有几个疑问：\n1，一般来讲，若拷贝构造函数抛出异常，是不是有可能导致内存泄漏，应该如何避免？\n2，这里的拷贝构造，从语义上来讲，实际上也是实现的移动的操作，那如果拷贝构造异常，作为入参的 other是否也有可能处于部分被破坏的状态？\n3，如果类结构更复杂一些，即使成功构造了临时对象，仍然有其他可能导致异常的操作，而不仅仅只有swap，那你在回复其他同学时提到的准则，“一律使用拷贝构造函数来构造新对象，然后使用无异常的 swap 来获得新对象”，是否就不适用了？","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497414,"discussion_content":"这个代码用了比较安全的拷贝构造加交换的赋值方式。注意你的赋值函数原型是：\n\nA &amp;amp;operator=(A other);\n\n参数是值而不是引用。这意味着，在执行进入这个赋值函数体之前，A other 已经导致拷贝构造被执行了一次。\n\n这是异常安全的惯用法。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591431825,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157471,"user_name":"metalmac.kyle","can_delete":false,"product_type":"c1","uid":1001832,"ip_address":"","ucode":"74795A8825FCAA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/68/bef5f7d3.jpg","comment_is_top":false,"comment_ctime":1575170740,"is_pvip":false,"replies":[{"id":60366,"content":"没错，相关的知识点很多，一定要多实践才行。\n\n不过，回过头来看，我觉得我拿智能指针开头，难度可能是有点设高了。哈哈。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575183383,"ip_address":"","comment_id":157471,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"通过老师的例子来学习深入学习智能指针，感觉这种案例式都谢谢代入感很强，再难的知识点也不枯燥还能直接学以致用，醍醐灌顶，有种重读csapp的感觉！Cpp一大特性就是各种复杂的语法以及符号设计，这让她被爱的人奉上神坛，恨的人也恨之入骨，指针作为双刃剑充满了恶魔般的魔力，虽然会让人望而却步但也是吸引我一直学习cpp的动力所在，对底层的操作和理解实在让人着魔哈哈。\n言归正传，小小的构造智能指针课蕴含了对Cpp一系列知识的复习巩固，构造函数，运算符重载，指针引用特性，模板等各类知识点的设计与实现，想真正掌握还需要反复上机实践呢，还是应了古话，纸上得来终觉欲知此事须躬行浅！🧐","like_count":5,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476436,"discussion_content":"没错，相关的知识点很多，一定要多实践才行。\n\n不过，回过头来看，我觉得我拿智能指针开头，难度可能是有点设高了。哈哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575183383,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155888,"user_name":"姜姜","can_delete":false,"product_type":"c1","uid":1120332,"ip_address":"","ucode":"1DAD620C8E9F31","user_header":"https://static001.geekbang.org/account/avatar/00/11/18/4c/e12f3b41.jpg","comment_is_top":false,"comment_ctime":1574774548,"is_pvip":false,"replies":[{"id":59914,"content":"很全。有几个小问题哈（像reset有几个重载不算😄）：\n\n获取原始指针的 get 方法我提供了；\n* 和 -&gt; 代码里是提供的；\n引用计数器值也是有的。\n\n实践层面，最大的区别，除了不支持弱引用外，可能是不支持自定义删除器了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574812032,"ip_address":"","comment_id":155888,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"这个smart_ptr目前已经实现了:获取所有权，共享所有权，拷贝赋值语意，计数器，自动增减等功能。\n还缺少: 转移所有权reset的操作(我记得reset有三种重载方式);  获取原始指针方法，重写解引用*，重写指向操作符-&gt;，重写比较操作符，获取引用计数器值的方法，判断当前引用是否为1的方法，以及线程安全的设计。\n最后，shared_ptr本身还需要解决“循环引用”，“自引用”的问题，一般需要搭配弱指针weak_ptr使用。\n老师，不知我回答的是否全面，有无差错？","like_count":5,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476436,"discussion_content":"没错，相关的知识点很多，一定要多实践才行。\n\n不过，回过头来看，我觉得我拿智能指针开头，难度可能是有点设高了。哈哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575183383,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158472,"user_name":"lyfei","can_delete":false,"product_type":"c1","uid":1757471,"ip_address":"","ucode":"31ACC702BE6FEA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","comment_is_top":false,"comment_ctime":1575379232,"is_pvip":false,"replies":[{"id":60660,"content":"这个实现不支持。需要写更多的代码。\n\nC++17 的 shared_ptr 可以支持这样的写法，但也得明确告诉编译器是数组：\n\nstd::shared_ptr&lt;int[]&gt; ptr1{new int[5]};\nauto ptr2 = std::shared_ptr&lt;int[]&gt;{new int[5]};\n\nC++20 进一步支持：\n\nauto ptr3 = std::make_shared&lt;int[]&gt;(5);\n\n另外，new int[5] 之后用 delete 是不对（好）的。这儿一般还不会出问题，如果是带析构的对象就一定会出问题的。new …[] 之后一定用 delete[] …。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575383517,"ip_address":"","comment_id":158472,"utype":1}],"discussion_count":3,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"老师你好，那我如果想实现类似的:\nint* xxx = new int[5]; delete xxx;\n使用智能指针怎么做?\nsmart_ptr&lt;int&gt; test_ptr(new int[5]);","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476740,"discussion_content":"这个实现不支持。需要写更多的代码。\n\nC++17 的 shared_ptr 可以支持这样的写法，但也得明确告诉编译器是数组：\n\nstd::shared_ptr&amp;lt;int[]&amp;gt; ptr1{new int[5]};\nauto ptr2 = std::shared_ptr&amp;lt;int[]&amp;gt;{new int[5]};\n\nC++20 进一步支持：\n\nauto ptr3 = std::make_shared&amp;lt;int[]&amp;gt;(5);\n\n另外，new int[5] 之后用 delete 是不对（好）的。这儿一般还不会出问题，如果是带析构的对象就一定会出问题的。new …[] 之后一定用 delete[] …。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575383517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":71327,"discussion_content":"嗯嗯，谢谢老师耐心且详细的解答，学习到了很多。\n谢谢老师，明白","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575392956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70849,"discussion_content":"传统的数据类型是可以的，自定义的就不行了。\n比如:\nsmart_ptr<circle> test_ptr(new circle[5]);","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575382126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157207,"user_name":"贾陆华","can_delete":false,"product_type":"c1","uid":1321408,"ip_address":"","ucode":"2722C422077EE0","user_header":"https://static001.geekbang.org/account/avatar/00/14/29/c0/86fa3e92.jpg","comment_is_top":false,"comment_ctime":1575082599,"is_pvip":false,"replies":[{"id":60314,"content":"事实上，大部分C++的标准类都是这么设计的。不必要的加锁，会降低性能。如果你需要对shared_ptr或vector加锁，你可以在外面加，或者自己实现一个自己需要的线程安全的版本。有些场景下，也能找到第三方库这么做。\n\n以shared_ptr为例，我个人真还没觉得有多少场景需要并发访问一个智能指针。你更可能在创建新的线程时，给它拷贝一个新的智能指针。这样，大家只需要对被访问的对象同步，而不是对智能指针同步。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575107995,"ip_address":"","comment_id":157207,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"多年不学习C++新知识，对move 移动构造函数  完美转发这些理解不是很清晰，希望看完这个专栏能理解更深入，其他的感觉还行，shared_ptr不是线程安全的，只是共享计数使用了原子计数，为什么要这么设计？","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476362,"discussion_content":"事实上，大部分C++的标准类都是这么设计的。不必要的加锁，会降低性能。如果你需要对shared_ptr或vector加锁，你可以在外面加，或者自己实现一个自己需要的线程安全的版本。有些场景下，也能找到第三方库这么做。\n\n以shared_ptr为例，我个人真还没觉得有多少场景需要并发访问一个智能指针。你更可能在创建新的线程时，给它拷贝一个新的智能指针。这样，大家只需要对被访问的对象同步，而不是对智能指针同步。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575107995,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1321408,"avatar":"https://static001.geekbang.org/account/avatar/00/14/29/c0/86fa3e92.jpg","nickname":"贾陆华","note":"","ucode":"2722C422077EE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70755,"discussion_content":"明白了，就是说对被访问的对象，外部再进行同步，谢谢吴老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575379400,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157128,"user_name":"Zephyr","can_delete":false,"product_type":"c1","uid":1635120,"ip_address":"","ucode":"1DF3525146BFE7","user_header":"https://static001.geekbang.org/account/avatar/00/18/f3/30/8a8b2155.jpg","comment_is_top":false,"comment_ctime":1575037774,"is_pvip":false,"replies":[{"id":60295,"content":"第一周一次性放三讲。后面每周更新三次，一次一讲。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575078418,"ip_address":"","comment_id":157128,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"老师，是一直没有更新吗，还是我看不到，我记得是买过这个课程了","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476336,"discussion_content":"第一周一次性放三讲。后面每周更新三次，一次一讲。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575078418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156849,"user_name":"中山浪子","can_delete":false,"product_type":"c1","uid":1055296,"ip_address":"","ucode":"25D0F8462473D3","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/40/f10493ef.jpg","comment_is_top":false,"comment_ctime":1574988250,"is_pvip":false,"replies":[{"id":60266,"content":"我知道、能想得起的参考资料肯定会贴出来。毕竟，三十讲的时间肯定是不够的。大家一定要阅读更多的资料才行。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575027201,"ip_address":"","comment_id":156849,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"吴老师讲的还是很好的，听着音频看代码感觉跟不上节奏，需要多看几遍才行。同时，文末放上链接也很不错。希望老师能多放些相关的学习推荐资源，授人以鱼不如授人以渔😀","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476254,"discussion_content":"我知道、能想得起的参考资料肯定会贴出来。毕竟，三十讲的时间肯定是不够的。大家一定要阅读更多的资料才行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575027201,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155662,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1574734127,"is_pvip":false,"replies":[{"id":59861,"content":"应该的。但我们还没学到通用的C++并发编程呢。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574762878,"ip_address":"","comment_id":155662,"utype":1}],"discussion_count":3,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"计数器线程安全是不是更好点","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475821,"discussion_content":"应该的。但我们还没学到通用的C++并发编程呢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574762878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1212323,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7f/a3/23540579.jpg","nickname":"robonix","note":"","ucode":"866EC82EDA455B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":66709,"discussion_content":"老师，在实时系统中怎么保证线程安全呢，因为实时线程不可以被阻塞呀？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575100030,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1212323,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7f/a3/23540579.jpg","nickname":"robonix","note":"","ucode":"866EC82EDA455B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":99228,"discussion_content":"原子操作，第 19 讲。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577197533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":66709,"ip_address":"","group_id":0},"score":99228,"extra":""}]}]},{"had_liked":false,"id":275544,"user_name":"蓦然回首","can_delete":false,"product_type":"c1","uid":1172090,"ip_address":"","ucode":"B17658DCFE6402","user_header":"https://static001.geekbang.org/account/avatar/00/11/e2/7a/38a27e47.jpg","comment_is_top":false,"comment_ctime":1611579174,"is_pvip":true,"replies":[{"id":100031,"content":"swap 的约定是不发生异常，它当然不能保证不发生异常。用户需要保证不让 swap 抛出异常。这是用户需要做到的，否则程序在发生异常时会崩溃。\n\n对于你的具体例子，对指针的交换自然不会发生异常，所以对 smart_ptr 的 swap 操作不会有异常。自增对内置类型和 atomic 类型不会发生异常。而对于你自己的定义的类，就看你自己的类的行为了。异常是否会发生，是程序员自己定义的，所以程序员要负责对不会发生异常的函数手工标明 noexcept。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1611638312,"ip_address":"","comment_id":275544,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"老师，请教个问题，为什么std::swap本身不会发生异常，我看STL源码里面，也只是在函数头部后面加了个noexcept,而这个只是个不可靠的保证，这里更一般的问题是，到底程序代码什么情况下是一定不会发生异常的，而什么情况下是可能发生异常的，有没有什么规律？比如上面的简单的赋值，为什么就一定不会发生异常，\nusing std::swap;    swap(ptr_, rhs.ptr_);    swap(shared_count_,         rhs.shared_count_);\n再一般的情况，比如 void add_count() noexcept  {    ++count_;  }这种就是个自增运算，那是不是这种就一定不会发生异常呢？异常是否发生，怎么界定？","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514390,"discussion_content":"swap 的约定是不发生异常，它当然不能保证不发生异常。用户需要保证不让 swap 抛出异常。这是用户需要做到的，否则程序在发生异常时会崩溃。\n\n对于你的具体例子，对指针的交换自然不会发生异常，所以对 smart_ptr 的 swap 操作不会有异常。自增对内置类型和 atomic 类型不会发生异常。而对于你自己的定义的类，就看你自己的类的行为了。异常是否会发生，是程序员自己定义的，所以程序员要负责对不会发生异常的函数手工标明 noexcept。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1611638312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224253,"user_name":"可爱的小奶狗","can_delete":false,"product_type":"c1","uid":1178236,"ip_address":"","ucode":"DC810503571DD2","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/7c/f8f38ad0.jpg","comment_is_top":false,"comment_ctime":1591324586,"is_pvip":false,"replies":[{"id":82635,"content":"这个代码用了比较安全的拷贝构造加交换的赋值方式。注意你的赋值函数原型是：\n\nA &amp;operator=(A other);\n\n参数是值而不是引用。这意味着，在执行进入这个赋值函数体之前，A other 已经导致拷贝构造被执行了一次。\n\n这是异常安全的惯用法。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1591431825,"ip_address":"","comment_id":224253,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;algorithm&gt;\n\nclass A {\npublic:\n    int n;\n    std::string s1;\n    &#47;&#47;在加了copy constructor时，必须显式加入constructor,编译器不会再隐式提供constructor\n    A(){}\n    &#47;&#47;copy constructor\n    A(const A&amp; a){\n        std::cout &lt;&lt; &quot;copy constructor of A\\n&quot;;\n    }\n\n    &#47;&#47; user-defined copy assignment, copy-and-swap form\n    A &amp;operator=(A other) {\n        std::cout &lt;&lt; &quot;copy assignment of A\\n&quot;;\n        std::swap(n, other.n);\n        std::swap(s1, other.s1);\n        return *this;\n    }\n};\n\n\nint main() {\n    A a1, a2;\n    std::cout &lt;&lt; &quot;a1 = a2 calls &quot;;\n    a1 = a2; \n\n\n}\n老师，以上代码为什么最终会A的copy assignment和copy constructor都会被调用？我觉得拷贝构造和赋值应该是选其中一个才对啊。\ncppreference对copy assignment的调用时的描述：\nThe copy assignment operator is called whenever selected by overload resolution, e.g. when an object appears on the left side of an assignment expression。\n我理解的是copy assignment只会在重载解析才会发生，比如上述代码，如果调用了copy assignment,那么可以推断出发生了重载，那么copy constructor就不会被调用。为什么事实不是这样的呢？","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497414,"discussion_content":"这个代码用了比较安全的拷贝构造加交换的赋值方式。注意你的赋值函数原型是：\n\nA &amp;amp;operator=(A other);\n\n参数是值而不是引用。这意味着，在执行进入这个赋值函数体之前，A other 已经导致拷贝构造被执行了一次。\n\n这是异常安全的惯用法。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591431825,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160366,"user_name":"总统老唐","can_delete":false,"product_type":"c1","uid":1490070,"ip_address":"","ucode":"F2CC66E5BB4871","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/96/c679bb3d.jpg","comment_is_top":false,"comment_ctime":1575941527,"is_pvip":false,"replies":[{"id":61214,"content":"1. 一般而言，拷贝构造函数抛出异常算正常，完全可以用普通的异常安全的做法来避免内存泄漏。基本点就是不要使用裸指针。一定要用，就得小心注意了。\n\n2. 移动的拷贝构造是很危险的，所以现在的智能指针不会这么实现的。拷贝是拷贝，移动是移动，拷贝就不要影响右边。反过来讲，如果纯粹是移动，也不应该发生异常的。但如果你硬要混合移动和拷贝，那就是找罪受了……\n\n3. 我不认为会发生你说的情况。类的复杂性是需要人努力去降低的，其中就包括遵守基本的规范，包括swap不允许发生异常。\n\n在特殊情况下，你开车可以开到停车带甚至逆行。但还是多想想正常的情况为好。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575951682,"ip_address":"","comment_id":160366,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"吴老师，关于拷贝构造和赋值部分的smart_ptr，还有几个疑问：\n1，一般来讲，若拷贝构造函数抛出异常，是不是有可能导致内存泄漏，应该如何避免？\n2，这里的拷贝构造，从语义上来讲，实际上也是实现的移动的操作，那如果拷贝构造异常，作为入参的 other是否也有可能处于部分被破坏的状态？\n3，如果类结构更复杂一些，即使成功构造了临时对象，仍然有其他可能导致异常的操作，而不仅仅只有swap，那你在回复其他同学时提到的准则，“一律使用拷贝构造函数来构造新对象，然后使用无异常的 swap 来获得新对象”，是否就不适用了？","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477355,"discussion_content":"1. 一般而言，拷贝构造函数抛出异常算正常，完全可以用普通的异常安全的做法来避免内存泄漏。基本点就是不要使用裸指针。一定要用，就得小心注意了。\n\n2. 移动的拷贝构造是很危险的，所以现在的智能指针不会这么实现的。拷贝是拷贝，移动是移动，拷贝就不要影响右边。反过来讲，如果纯粹是移动，也不应该发生异常的。但如果你硬要混合移动和拷贝，那就是找罪受了……\n\n3. 我不认为会发生你说的情况。类的复杂性是需要人努力去降低的，其中就包括遵守基本的规范，包括swap不允许发生异常。\n\n在特殊情况下，你开车可以开到停车带甚至逆行。但还是多想想正常的情况为好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575951682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156773,"user_name":"浑浑噩噩cium","can_delete":false,"product_type":"c1","uid":1617939,"ip_address":"","ucode":"358C0BCFF62B40","user_header":"https://static001.geekbang.org/account/avatar/00/18/b0/13/5cb3459c.jpg","comment_is_top":false,"comment_ctime":1574953072,"is_pvip":false,"replies":[{"id":60172,"content":"现在一般说拷贝赋值和移动赋值了。跟构造的不同方式对应。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574983557,"ip_address":"","comment_id":156773,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"类:\n4种构造函数:默认构造，带参数构造，拷贝构造，移动构造\n2种赋值函数:普通赋值函数和移动赋值函数","like_count":3},{"had_liked":false,"id":155873,"user_name":"小林coding","can_delete":false,"product_type":"c1","uid":1303210,"ip_address":"","ucode":"D57D7DBF260216","user_header":"https://static001.geekbang.org/account/avatar/00/13/e2/aa/9ddc6469.jpg","comment_is_top":false,"comment_ctime":1574771057,"is_pvip":false,"replies":[{"id":59893,"content":"后面会讲到。简单来说，atomic变量的读取、写入、增、减都会翻译成目标系统上的原子操作指令。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574773418,"ip_address":"","comment_id":155873,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"见一些多线程使用计数器的时候，会用std::atomic&lt;int&gt;  num的方式来定义计数器，但是没有理解到为啥std::atomic是如何保证线程安全的？","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476228,"discussion_content":"现在一般说拷贝赋值和移动赋值了。跟构造的不同方式对应。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574983557,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":349241,"user_name":"Roblaboy","can_delete":false,"product_type":"c1","uid":2979544,"ip_address":"","ucode":"801AB12DBE521B","user_header":"","comment_is_top":false,"comment_ctime":1655824184,"is_pvip":false,"replies":[{"id":127226,"content":"实际它是：\n\nptr2.operator=(smart_ptr(ptr1));\n\noperator= 要求一个值而非引用作为参数，因此编译器会隐式产生 smart_ptr(ptr1) 这样的构造代码。在构造过程中，给的参数是个左值，就会走拷贝构造，引用计数加一。\n\n注意文中这段话：\n\n“把赋值函数中的参数类型 smart_ptr&amp; 改成了 smart_ptr，在构造参数时直接生成新的智能指针，从而不再需要在函数体中构造临时对象。现在赋值函数的行为是移动还是拷贝，完全依赖于构造参数时走的是移动构造还是拷贝构造。”","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1656120293,"ip_address":"","comment_id":349241,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"请问 ptr2 = ptr1; 这一句哪里调用了add_count()?","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475905,"discussion_content":"后面会讲到。简单来说，atomic变量的读取、写入、增、减都会翻译成目标系统上的原子操作指令。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574773418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341240,"user_name":"hunter7z","can_delete":false,"product_type":"c1","uid":1263960,"ip_address":"","ucode":"879F63FA4C22D6","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/58/ad35a72f.jpg","comment_is_top":false,"comment_ctime":1649468326,"is_pvip":false,"replies":[{"id":124819,"content":"因为 C++ 的规则就是这样，让重载 -&gt; 之后的结果能够方便、直观地被使用。\n\n纯技术的描述可以参考 C++ 标准。在 C++20 里是 §12.6.5 Class member access：\n\nFor an expression of the form\n\npostfix-expression -&gt; template_opt id-expression\n\nthe operator function is selected by overload resolution (12.4.1.2), and the expression is interpreted as\n\n( postfix-expression . operator -&gt; () ) -&gt; template_opt id-expression\n\n换句话说，在 obj 重载了 operator-&gt; 时，obj-&gt; 确确实实会被解释成：\n\n(obj.operator-&gt;())-&gt;","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1649751085,"ip_address":"","comment_id":341240,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"我有一个关于重载-&gt;运算符的问题，您在文章是这么实现的：\nT* operator-&gt;() const { return ptr_; }\n我看STL里的unique_ptr也是类似的实现方法。但是我不理解的是，-&gt;返回了一个T类指针，如果想要调用T类方法的话，应该需要再使用-&gt;调用方法才对吧？类似下面这样：\n(smart_ptr-&gt;())-&gt;method()\n为什么可以直接使用：smart_ptr-&gt;method()来调用呢？\n","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561941,"discussion_content":"因为 C++ 的规则就是这样，让重载 -&gt; 之后的结果能够方便、直观地被使用。\n\n纯技术的描述可以参考 C++ 标准。在 C++20 里是 §12.6.5 Class member access：\n\nFor an expression of the form\n\npostfix-expression -&gt; template_opt id-expression\n\nthe operator function is selected by overload resolution (12.4.1.2), and the expression is interpreted as\n\n( postfix-expression . operator -&gt; () ) -&gt; template_opt id-expression\n\n换句话说，在 obj 重载了 operator-&gt; 时，obj-&gt; 确确实实会被解释成：\n\n(obj.operator-&gt;())-&gt;","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1649751085,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308399,"user_name":"Mari","can_delete":false,"product_type":"c1","uid":2271867,"ip_address":"","ucode":"5260C80C8B6AD6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/E73UicmpgFiaZW4SOTGaxoIk9PWue54neNcfsicz7HOxJUucep4jSMyeMMruLNcIlxsE330qOFMacaEQ9Vz4zXJyg/132","comment_is_top":false,"comment_ctime":1629600164,"is_pvip":false,"replies":[{"id":111776,"content":"没有实现 operator=，那赋值就是按成员复制，把两个指针复制过去，引用计数没有增加……当然是错误的结果了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1629809793,"ip_address":"","comment_id":308399,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"关于示例代码。有个疑问问下，望大佬赐教：\nsmart_ptr 没有实现 operator= 时，结果又问题，ptr2的 use_count() 返回1\n```\nuse count of ptr1 is 1\nuse count of ptr2 was 0\ncopy construct smart_ptr&lt;U&gt; &amp;other\nuse count of ptr2 is now 1\nptr1 is not empty\n~circle()\n```\n\noperator= 代码：\n    smart_ptr &amp;operator=(smart_ptr rhs) {\n        puts(&quot;operator= is call.&quot;);\n        rhs.swap(*this);\n        return *this;\n    }\n\n加上这个函数，ptr2 use_count 结果就正常返回2了，请问是为什么？\n\nuse count of ptr1 is 1\nuse count of ptr2 was 0\ncopy construct smart_ptr&lt;U&gt; &amp;other\noperator= is call.\nuse count of ptr2 is now 2\nptr1 is not empty\n~circle()","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525480,"discussion_content":"没有实现 operator=，那赋值就是按成员复制，把两个指针复制过去，引用计数没有增加……当然是错误的结果了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1629809793,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":242281,"user_name":"乔旭","can_delete":false,"product_type":"c1","uid":2116731,"ip_address":"","ucode":"D129F9E036833C","user_header":"https://static001.geekbang.org/account/avatar/00/20/4c/7b/648a5ca8.jpg","comment_is_top":false,"comment_ctime":1597657393,"is_pvip":false,"replies":[{"id":89429,"content":"异常安全性，这儿是指当复制某个对象的数据成员时，如果发生了异常，能不能保证 this 对象的状态不变。网上你应该很容易搜到关于异常安全性的资料。\n\n使用 == 这种判断方法的代码，大概率会，如果复制一半时发生异常，this 对象将处于苍蝇人这样混合态。我们希望的是，对象赋值的结果要么完全成功，要么保持原样不变，不应该处于中间态。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1597661522,"ip_address":"","comment_id":242281,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"“如果你学到的赋值函数还有一个类似于 if (this != &amp;rhs) 的判断的话，那种用法更啰嗦，而且异常安全性不够好——如果在赋值过程中发生异常的话，this 对象的内容可能已经被部分破坏了，对象不再处于一个完整的状态。“”\n\n请问，这个地方怎么理解呢？这个只是做了判断，和赋值过程有什么关系呢？每天理解您说的异常安全性是指的什么。谢谢！","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503969,"discussion_content":"异常安全性，这儿是指当复制某个对象的数据成员时，如果发生了异常，能不能保证 this 对象的状态不变。网上你应该很容易搜到关于异常安全性的资料。\n\n使用 == 这种判断方法的代码，大概率会，如果复制一半时发生异常，this 对象将处于苍蝇人这样混合态。我们希望的是，对象赋值的结果要么完全成功，要么保持原样不变，不应该处于中间态。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1597661522,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169214,"user_name":"Geek_9e42eb","can_delete":false,"product_type":"c1","uid":1593979,"ip_address":"","ucode":"289E65C28F6C2A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTItEbXDEnXQ7QjqQ8mfa67aylfHvT3FvUXaUPlZ9QjMar417oBU8GYPvibWDmxDnMsEqibtia7DHuFGw/132","comment_is_top":false,"comment_ctime":1578294360,"is_pvip":false,"replies":[{"id":65664,"content":"传统教赋值的都会有这个比较。这样写一般不能保证异常安全。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578308694,"ip_address":"","comment_id":169214,"utype":1}],"discussion_count":2,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"这段话有点没看懂：\n如果你学到的赋值函数还有一个类似于 if (this != &amp;rhs) 的判断的话，那种用法更啰嗦，而且异常安全性不够好——如果在赋值过程中发生异常的话，this 对象的内容可能已经被部分破坏了，对象不再处于一个完整的状态。\n\n请问老师，“你学到的赋值函数还有一个类似于 if (this != &amp;rhs) 的判断的话”这个表述没怎么看懂，您是指什么地方有这个判断？为什么有这个判断更啰嗦，安全性不好？\n","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480459,"discussion_content":"传统教赋值的都会有这个比较。这样写一般不能保证异常安全。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578308694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":3948439,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI0icYqvY68m60U2qJn7iabqSD4OUvYx2OeiaXA4IqhDia1VNMm3bTGCUaU5J3jbIU1clqCRiap1BubL7g/132","nickname":"Mattrach","note":"","ucode":"D530826D02FA1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":649902,"discussion_content":"之前看侯捷的课程中是这样写的，确实没提到异常安全的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1724125404,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":480459,"ip_address":"福建","group_id":0},"score":649902,"extra":""}]}]},{"had_liked":false,"id":162050,"user_name":"贵子","can_delete":false,"product_type":"c1","uid":1690431,"ip_address":"","ucode":"A94801C05CB07E","user_header":"https://static001.geekbang.org/account/avatar/00/19/cb/3f/3d044d18.jpg","comment_is_top":false,"comment_ctime":1576456656,"is_pvip":false,"replies":[{"id":61672,"content":"每个对象有独立的计数，不可能是静态数据成员。不同指针可能共享引用计数，因而引用计数也必须独立存储。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576459197,"ip_address":"","comment_id":162050,"utype":1}],"discussion_count":2,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"如果shared_count类作为静态成员变量，没有了指针的操作，代码会不会更简洁些？","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477945,"discussion_content":"每个对象有独立的计数，不可能是静态数据成员。不同指针可能共享引用计数，因而引用计数也必须独立存储。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576459197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1690431,"avatar":"https://static001.geekbang.org/account/avatar/00/19/cb/3f/3d044d18.jpg","nickname":"贵子","note":"","ucode":"A94801C05CB07E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84161,"discussion_content":"谢谢老师指导，是我考虑不周。每个资源都应该有自己的独立计数器","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576492607,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157260,"user_name":"robonix","can_delete":false,"product_type":"c1","uid":1212323,"ip_address":"","ucode":"866EC82EDA455B","user_header":"https://static001.geekbang.org/account/avatar/00/12/7f/a3/23540579.jpg","comment_is_top":false,"comment_ctime":1575099868,"is_pvip":false,"replies":[{"id":60329,"content":"可以，此处没区别。我是从 smart_ptr(rhs).swap(*this) 改过来的，形式就没有动。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575120342,"ip_address":"","comment_id":157260,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"老师，operator=重载里面的rhs.swap(*this)可以直接写swap(rhs)吧","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476376,"discussion_content":"可以，此处没区别。我是从 smart_ptr(rhs).swap(*this) 改过来的，形式就没有动。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575120342,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156434,"user_name":"NEVER SETTLE","can_delete":false,"product_type":"c1","uid":1101894,"ip_address":"","ucode":"9C86BDAFDBF768","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/46/1a9229b3.jpg","comment_is_top":false,"comment_ctime":1574870889,"is_pvip":false,"replies":[{"id":60073,"content":"哈哈，对。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574899352,"ip_address":"","comment_id":156434,"utype":1}],"discussion_count":2,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"老师，我想明白了，刚才猛一下懵了\n\nsmart_ptr ptr1{create_shape(shape_type::circle)};\nsmart_ptr ptr3;\n&#47;*\nsmart_ptr&amp; operator=(smart_ptr rhs) { \n    rhs.swap(*this); \n    return *this; \n}\n*&#47;\n&#47;&#47; smart_ptr rhs{ptr1} 发生拷贝构造，所以编译出错\nptr3 = ptr1;   &#47;&#47; 编译出错\n\n&#47;&#47; smart_ptr rhs{std::move(ptr1)} 移动构造，所以OK\nptr3 = std::move(ptr1); &#47;&#47; OK，可以","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476106,"discussion_content":"哈哈，对。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574899352,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1101894,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d0/46/1a9229b3.jpg","nickname":"NEVER SETTLE","note":"","ucode":"9C86BDAFDBF768","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":63616,"discussion_content":"C++真是博大精深","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574899855,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156773,"user_name":"浑浑噩噩cium","can_delete":false,"product_type":"c1","uid":1617939,"ip_address":"","ucode":"358C0BCFF62B40","user_header":"https://static001.geekbang.org/account/avatar/00/18/b0/13/5cb3459c.jpg","comment_is_top":false,"comment_ctime":1574953072,"is_pvip":false,"replies":[{"id":60172,"content":"现在一般说拷贝赋值和移动赋值了。跟构造的不同方式对应。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574983557,"ip_address":"","comment_id":156773,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"类:\n4种构造函数:默认构造，带参数构造，拷贝构造，移动构造\n2种赋值函数:普通赋值函数和移动赋值函数","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476228,"discussion_content":"现在一般说拷贝赋值和移动赋值了。跟构造的不同方式对应。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574983557,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155873,"user_name":"小林coding","can_delete":false,"product_type":"c1","uid":1303210,"ip_address":"","ucode":"D57D7DBF260216","user_header":"https://static001.geekbang.org/account/avatar/00/13/e2/aa/9ddc6469.jpg","comment_is_top":false,"comment_ctime":1574771057,"is_pvip":false,"replies":[{"id":59893,"content":"后面会讲到。简单来说，atomic变量的读取、写入、增、减都会翻译成目标系统上的原子操作指令。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574773418,"ip_address":"","comment_id":155873,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"见一些多线程使用计数器的时候，会用std::atomic&lt;int&gt;  num的方式来定义计数器，但是没有理解到为啥std::atomic是如何保证线程安全的？","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475905,"discussion_content":"后面会讲到。简单来说，atomic变量的读取、写入、增、减都会翻译成目标系统上的原子操作指令。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574773418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":349241,"user_name":"Roblaboy","can_delete":false,"product_type":"c1","uid":2979544,"ip_address":"","ucode":"801AB12DBE521B","user_header":"","comment_is_top":false,"comment_ctime":1655824184,"is_pvip":false,"replies":[{"id":127226,"content":"实际它是：\n\nptr2.operator=(smart_ptr(ptr1));\n\noperator= 要求一个值而非引用作为参数，因此编译器会隐式产生 smart_ptr(ptr1) 这样的构造代码。在构造过程中，给的参数是个左值，就会走拷贝构造，引用计数加一。\n\n注意文中这段话：\n\n“把赋值函数中的参数类型 smart_ptr&amp; 改成了 smart_ptr，在构造参数时直接生成新的智能指针，从而不再需要在函数体中构造临时对象。现在赋值函数的行为是移动还是拷贝，完全依赖于构造参数时走的是移动构造还是拷贝构造。”","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1656120293,"ip_address":"","comment_id":349241,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"请问 ptr2 = ptr1; 这一句哪里调用了add_count()?","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577441,"discussion_content":"实际它是：\n\nptr2.operator=(smart_ptr(ptr1));\n\noperator= 要求一个值而非引用作为参数，因此编译器会隐式产生 smart_ptr(ptr1) 这样的构造代码。在构造过程中，给的参数是个左值，就会走拷贝构造，引用计数加一。\n\n注意文中这段话：\n\n“把赋值函数中的参数类型 smart_ptr&amp; 改成了 smart_ptr，在构造参数时直接生成新的智能指针，从而不再需要在函数体中构造临时对象。现在赋值函数的行为是移动还是拷贝，完全依赖于构造参数时走的是移动构造还是拷贝构造。”","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1656120293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341240,"user_name":"hunter7z","can_delete":false,"product_type":"c1","uid":1263960,"ip_address":"","ucode":"879F63FA4C22D6","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/58/ad35a72f.jpg","comment_is_top":false,"comment_ctime":1649468326,"is_pvip":false,"replies":[{"id":124819,"content":"因为 C++ 的规则就是这样，让重载 -&gt; 之后的结果能够方便、直观地被使用。\n\n纯技术的描述可以参考 C++ 标准。在 C++20 里是 §12.6.5 Class member access：\n\nFor an expression of the form\n\npostfix-expression -&gt; template_opt id-expression\n\nthe operator function is selected by overload resolution (12.4.1.2), and the expression is interpreted as\n\n( postfix-expression . operator -&gt; () ) -&gt; template_opt id-expression\n\n换句话说，在 obj 重载了 operator-&gt; 时，obj-&gt; 确确实实会被解释成：\n\n(obj.operator-&gt;())-&gt;","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1649751085,"ip_address":"","comment_id":341240,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"我有一个关于重载-&gt;运算符的问题，您在文章是这么实现的：\nT* operator-&gt;() const { return ptr_; }\n我看STL里的unique_ptr也是类似的实现方法。但是我不理解的是，-&gt;返回了一个T类指针，如果想要调用T类方法的话，应该需要再使用-&gt;调用方法才对吧？类似下面这样：\n(smart_ptr-&gt;())-&gt;method()\n为什么可以直接使用：smart_ptr-&gt;method()来调用呢？\n","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577441,"discussion_content":"实际它是：\n\nptr2.operator=(smart_ptr(ptr1));\n\noperator= 要求一个值而非引用作为参数，因此编译器会隐式产生 smart_ptr(ptr1) 这样的构造代码。在构造过程中，给的参数是个左值，就会走拷贝构造，引用计数加一。\n\n注意文中这段话：\n\n“把赋值函数中的参数类型 smart_ptr&amp; 改成了 smart_ptr，在构造参数时直接生成新的智能指针，从而不再需要在函数体中构造临时对象。现在赋值函数的行为是移动还是拷贝，完全依赖于构造参数时走的是移动构造还是拷贝构造。”","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1656120293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308399,"user_name":"Mari","can_delete":false,"product_type":"c1","uid":2271867,"ip_address":"","ucode":"5260C80C8B6AD6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/E73UicmpgFiaZW4SOTGaxoIk9PWue54neNcfsicz7HOxJUucep4jSMyeMMruLNcIlxsE330qOFMacaEQ9Vz4zXJyg/132","comment_is_top":false,"comment_ctime":1629600164,"is_pvip":false,"replies":[{"id":111776,"content":"没有实现 operator=，那赋值就是按成员复制，把两个指针复制过去，引用计数没有增加……当然是错误的结果了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1629809793,"ip_address":"","comment_id":308399,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"关于示例代码。有个疑问问下，望大佬赐教：\nsmart_ptr 没有实现 operator= 时，结果又问题，ptr2的 use_count() 返回1\n```\nuse count of ptr1 is 1\nuse count of ptr2 was 0\ncopy construct smart_ptr&lt;U&gt; &amp;other\nuse count of ptr2 is now 1\nptr1 is not empty\n~circle()\n```\n\noperator= 代码：\n    smart_ptr &amp;operator=(smart_ptr rhs) {\n        puts(&quot;operator= is call.&quot;);\n        rhs.swap(*this);\n        return *this;\n    }\n\n加上这个函数，ptr2 use_count 结果就正常返回2了，请问是为什么？\n\nuse count of ptr1 is 1\nuse count of ptr2 was 0\ncopy construct smart_ptr&lt;U&gt; &amp;other\noperator= is call.\nuse count of ptr2 is now 2\nptr1 is not empty\n~circle()","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561941,"discussion_content":"因为 C++ 的规则就是这样，让重载 -&gt; 之后的结果能够方便、直观地被使用。\n\n纯技术的描述可以参考 C++ 标准。在 C++20 里是 §12.6.5 Class member access：\n\nFor an expression of the form\n\npostfix-expression -&gt; template_opt id-expression\n\nthe operator function is selected by overload resolution (12.4.1.2), and the expression is interpreted as\n\n( postfix-expression . operator -&gt; () ) -&gt; template_opt id-expression\n\n换句话说，在 obj 重载了 operator-&gt; 时，obj-&gt; 确确实实会被解释成：\n\n(obj.operator-&gt;())-&gt;","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1649751085,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":242281,"user_name":"乔旭","can_delete":false,"product_type":"c1","uid":2116731,"ip_address":"","ucode":"D129F9E036833C","user_header":"https://static001.geekbang.org/account/avatar/00/20/4c/7b/648a5ca8.jpg","comment_is_top":false,"comment_ctime":1597657393,"is_pvip":false,"replies":[{"id":89429,"content":"异常安全性，这儿是指当复制某个对象的数据成员时，如果发生了异常，能不能保证 this 对象的状态不变。网上你应该很容易搜到关于异常安全性的资料。\n\n使用 == 这种判断方法的代码，大概率会，如果复制一半时发生异常，this 对象将处于苍蝇人这样混合态。我们希望的是，对象赋值的结果要么完全成功，要么保持原样不变，不应该处于中间态。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1597661522,"ip_address":"","comment_id":242281,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"“如果你学到的赋值函数还有一个类似于 if (this != &amp;rhs) 的判断的话，那种用法更啰嗦，而且异常安全性不够好——如果在赋值过程中发生异常的话，this 对象的内容可能已经被部分破坏了，对象不再处于一个完整的状态。“”\n\n请问，这个地方怎么理解呢？这个只是做了判断，和赋值过程有什么关系呢？每天理解您说的异常安全性是指的什么。谢谢！","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525480,"discussion_content":"没有实现 operator=，那赋值就是按成员复制，把两个指针复制过去，引用计数没有增加……当然是错误的结果了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1629809793,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169214,"user_name":"Geek_9e42eb","can_delete":false,"product_type":"c1","uid":1593979,"ip_address":"","ucode":"289E65C28F6C2A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTItEbXDEnXQ7QjqQ8mfa67aylfHvT3FvUXaUPlZ9QjMar417oBU8GYPvibWDmxDnMsEqibtia7DHuFGw/132","comment_is_top":false,"comment_ctime":1578294360,"is_pvip":false,"replies":[{"id":65664,"content":"传统教赋值的都会有这个比较。这样写一般不能保证异常安全。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578308694,"ip_address":"","comment_id":169214,"utype":1}],"discussion_count":2,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"这段话有点没看懂：\n如果你学到的赋值函数还有一个类似于 if (this != &amp;rhs) 的判断的话，那种用法更啰嗦，而且异常安全性不够好——如果在赋值过程中发生异常的话，this 对象的内容可能已经被部分破坏了，对象不再处于一个完整的状态。\n\n请问老师，“你学到的赋值函数还有一个类似于 if (this != &amp;rhs) 的判断的话”这个表述没怎么看懂，您是指什么地方有这个判断？为什么有这个判断更啰嗦，安全性不好？\n","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503969,"discussion_content":"异常安全性，这儿是指当复制某个对象的数据成员时，如果发生了异常，能不能保证 this 对象的状态不变。网上你应该很容易搜到关于异常安全性的资料。\n\n使用 == 这种判断方法的代码，大概率会，如果复制一半时发生异常，this 对象将处于苍蝇人这样混合态。我们希望的是，对象赋值的结果要么完全成功，要么保持原样不变，不应该处于中间态。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1597661522,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162050,"user_name":"贵子","can_delete":false,"product_type":"c1","uid":1690431,"ip_address":"","ucode":"A94801C05CB07E","user_header":"https://static001.geekbang.org/account/avatar/00/19/cb/3f/3d044d18.jpg","comment_is_top":false,"comment_ctime":1576456656,"is_pvip":false,"replies":[{"id":61672,"content":"每个对象有独立的计数，不可能是静态数据成员。不同指针可能共享引用计数，因而引用计数也必须独立存储。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576459197,"ip_address":"","comment_id":162050,"utype":1}],"discussion_count":2,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"如果shared_count类作为静态成员变量，没有了指针的操作，代码会不会更简洁些？","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480459,"discussion_content":"传统教赋值的都会有这个比较。这样写一般不能保证异常安全。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578308694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":3948439,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI0icYqvY68m60U2qJn7iabqSD4OUvYx2OeiaXA4IqhDia1VNMm3bTGCUaU5J3jbIU1clqCRiap1BubL7g/132","nickname":"Mattrach","note":"","ucode":"D530826D02FA1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":649902,"discussion_content":"之前看侯捷的课程中是这样写的，确实没提到异常安全的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1724125404,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":480459,"ip_address":"福建","group_id":0},"score":649902,"extra":""}]}]},{"had_liked":false,"id":157260,"user_name":"robonix","can_delete":false,"product_type":"c1","uid":1212323,"ip_address":"","ucode":"866EC82EDA455B","user_header":"https://static001.geekbang.org/account/avatar/00/12/7f/a3/23540579.jpg","comment_is_top":false,"comment_ctime":1575099868,"is_pvip":false,"replies":[{"id":60329,"content":"可以，此处没区别。我是从 smart_ptr(rhs).swap(*this) 改过来的，形式就没有动。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575120342,"ip_address":"","comment_id":157260,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"老师，operator=重载里面的rhs.swap(*this)可以直接写swap(rhs)吧","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477945,"discussion_content":"每个对象有独立的计数，不可能是静态数据成员。不同指针可能共享引用计数，因而引用计数也必须独立存储。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576459197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1690431,"avatar":"https://static001.geekbang.org/account/avatar/00/19/cb/3f/3d044d18.jpg","nickname":"贵子","note":"","ucode":"A94801C05CB07E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84161,"discussion_content":"谢谢老师指导，是我考虑不周。每个资源都应该有自己的独立计数器","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576492607,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156434,"user_name":"NEVER SETTLE","can_delete":false,"product_type":"c1","uid":1101894,"ip_address":"","ucode":"9C86BDAFDBF768","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/46/1a9229b3.jpg","comment_is_top":false,"comment_ctime":1574870889,"is_pvip":false,"replies":[{"id":60073,"content":"哈哈，对。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574899352,"ip_address":"","comment_id":156434,"utype":1}],"discussion_count":2,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"老师，我想明白了，刚才猛一下懵了\n\nsmart_ptr ptr1{create_shape(shape_type::circle)};\nsmart_ptr ptr3;\n&#47;*\nsmart_ptr&amp; operator=(smart_ptr rhs) { \n    rhs.swap(*this); \n    return *this; \n}\n*&#47;\n&#47;&#47; smart_ptr rhs{ptr1} 发生拷贝构造，所以编译出错\nptr3 = ptr1;   &#47;&#47; 编译出错\n\n&#47;&#47; smart_ptr rhs{std::move(ptr1)} 移动构造，所以OK\nptr3 = std::move(ptr1); &#47;&#47; OK，可以","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476376,"discussion_content":"可以，此处没区别。我是从 smart_ptr(rhs).swap(*this) 改过来的，形式就没有动。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575120342,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384146,"user_name":"Geek_a2e565","can_delete":false,"product_type":"c1","uid":3739479,"ip_address":"辽宁","ucode":"5211118EEE7039","user_header":"","comment_is_top":false,"comment_ctime":1700403794,"is_pvip":false,"replies":[{"id":140141,"content":"1. 在一个类模板的定义内部，使用类名称就是代表当前的自己。这在语法上更加简洁。\n\n2. 当smart_ptr&lt;circle&gt; 赋值给smart_ptr&lt;shape&gt;的时候，smart_ptr&lt;shape&gt; 的赋值运算符需要一个 smart_ptr&lt;shape&gt;，编译器会看到有 template &lt;typename U&gt; smart_ptr(const smart_ptr&lt;U&gt;&amp; other) 可以用，因此就可以先构造出 smart_ptr&lt;shape&gt;，然后用它去调用赋值运算符。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1700476477,"ip_address":"上海","comment_id":384146,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"老师 您好，看完您的专栏收益匪浅，这里有几处疑问希望老师能指教一下：\n1、模板类template&lt;typename T&gt; smart_ptr中的拷贝构造以及赋值函数的声明是smart_ptr(const smart_ptr&amp; other) 和smart_ptr&amp; operator=(smart_ptr rhs) noexcept, 这里参数列表中的smart_ptr是不是可以理解为就是smart_ptr&lt;T&gt;，如果是的话，为什么不写成smart_ptr&lt;T&gt;呢？\n2、赋值函数smart_ptr&amp; operator=(smart_ptr rhs) noexcept,在构造形参的时候会调用拷贝构造（不用std::move），那么当smart_ptr&lt;circle&gt; 赋值给smart_ptr&lt;shape&gt;的时候，调用的应该是模板拷贝构造，构造出来的临时对象也应该是smart_ptr&lt;circle&gt; ，那么为什么赋值函数不用定义成模板函数呢？\n\n十分感谢老师","like_count":1},{"had_liked":false,"id":341416,"user_name":"余淮","can_delete":false,"product_type":"c1","uid":2923989,"ip_address":"","ucode":"2B7DA1475DC0BF","user_header":"https://static001.geekbang.org/account/avatar/00/2c/9d/d5/4dcf8986.jpg","comment_is_top":false,"comment_ctime":1649591367,"is_pvip":false,"replies":[{"id":124820,"content":"简单理解，就是一个接受右值，一个接受左值。下一讲就会具体描述。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1649751504,"ip_address":"","comment_id":341416,"utype":1}],"discussion_count":2,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"老师，请问下smart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other)跟smart_ptr(smart_ptr&lt;U&gt;&amp; other)这两个引用符号不同传递参数有什么不同？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632107,"discussion_content":"1. 在一个类模板的定义内部，使用类名称就是代表当前的自己。这在语法上更加简洁。\n\n2. 当smart_ptr&lt;circle&gt; 赋值给smart_ptr&lt;shape&gt;的时候，smart_ptr&lt;shape&gt; 的赋值运算符需要一个 smart_ptr&lt;shape&gt;，编译器会看到有 template &lt;typename U&gt; smart_ptr(const smart_ptr&lt;U&gt;&amp; other) 可以用，因此就可以先构造出 smart_ptr&lt;shape&gt;，然后用它去调用赋值运算符。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1700476477,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339670,"user_name":"zg","can_delete":false,"product_type":"c1","uid":1055025,"ip_address":"","ucode":"809277A5F204BD","user_header":"https://static001.geekbang.org/account/avatar/00/10/19/31/b438b9cf.jpg","comment_is_top":false,"comment_ctime":1648285121,"is_pvip":false,"replies":[{"id":124388,"content":"智能指针的格式不对，del 也没有改。应该是：\n\nvoid del(void (*)(int)) {}\nvoid fun(int x) {}\nint main()\n{\n    std::shared_ptr&lt;void(int)&gt; ee(fun, del);\n    (*ee)(42);\n}","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1648638780,"ip_address":"","comment_id":339670,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"老师好，https:&#47;&#47;en.cppreference.com&#47;w&#47;cpp&#47;memory&#47;shared_ptr 中  shared_ptr的模板参数是一个函数类型。示例代码如下：\n\nvoid del(void(*)()) {}\nvoid fun() {}\nint main(){\n  std::shared_ptr&lt;void()&gt; ee(fun, del);\n  (*ee)();\n}\n\n如果我要把无参函数fun（），改为void fun（int x），代码改为：\n  shared_ptr&lt;void()(int)&gt; ee(fun,del);\n(*ee)(5);\n编译通不过，报错信息看不太明白，麻烦讲一下应该怎么改？\n","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559179,"discussion_content":"智能指针的格式不对，del 也没有改。应该是：\n\nvoid del(void (*)(int)) {}\nvoid fun(int x) {}\nint main()\n{\n    std::shared_ptr&lt;void(int)&gt; ee(fun, del);\n    (*ee)(42);\n}","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1648638781,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314855,"user_name":"wine99","can_delete":false,"product_type":"c1","uid":1682531,"ip_address":"","ucode":"F22F3E23E6F851","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/h6unp47tSLwwUZgnd3tuSSSEEOvXrC8aTI38ESYzsVZU8zZLMxvLDv8Zw2fmhr9M8CM46HCvQvicoutzwTjwNaA/132","comment_is_top":false,"comment_ctime":1633506520,"is_pvip":false,"replies":[{"id":114151,"content":"嗯嗯，rhs不是我发明的，应该是惯用写法了吧。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1633787274,"ip_address":"","comment_id":314855,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"太妙了！老师的文稿设计得真好，循序渐进。请问老师代码里常用的参数名rhs，是什么缩写？right hand side？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527813,"discussion_content":"嗯嗯，rhs不是我发明的，应该是惯用写法了吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633787274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313257,"user_name":"weing","can_delete":false,"product_type":"c1","uid":1984655,"ip_address":"","ucode":"95701BDA31F6F6","user_header":"","comment_is_top":false,"comment_ctime":1632355232,"is_pvip":false,"replies":[{"id":113757,"content":"对。这是一种惯用法，适合大部分场景。\n\n对于性能有极致追求的，可能需要考虑根据使用场景需不需要更快的执行路径。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1632810056,"ip_address":"","comment_id":313257,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"现在赋值函数的行为是移动还是拷贝，完全依赖于构造参数时走的是移动构造还是拷贝构造。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527813,"discussion_content":"嗯嗯，rhs不是我发明的，应该是惯用写法了吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633787274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296632,"user_name":"怪兽","can_delete":false,"product_type":"c1","uid":1324007,"ip_address":"","ucode":"3342C55CB83B08","user_header":"https://static001.geekbang.org/account/avatar/00/14/33/e7/145be2f9.jpg","comment_is_top":false,"comment_ctime":1623074852,"is_pvip":false,"replies":[{"id":107758,"content":"如果你定义了移动构造函数，编译器就不会生成拷贝构造函数。我们此处确实不希望自动的（错误）拷贝构造行为。解决方法是要么写一个跟模板形式一样的非模板移动构造函数（代码重复），要么显式把拷贝构造函数delete掉。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1623115371,"ip_address":"","comment_id":296632,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"老师好，请问一下原文中：“如果我们想消除代码重复、删除移动构造函数的话，就需要把拷贝构造函数标记成 = delete 了”。我结合上下文语境始终不明白什么意思，消除什么代码重复?要删除移动构造函数，就需要把拷贝构造函数标记成 = delete？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527296,"discussion_content":"对。这是一种惯用法，适合大部分场景。\n\n对于性能有极致追求的，可能需要考虑根据使用场景需不需要更快的执行路径。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632810056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":290694,"user_name":"Jm can","can_delete":false,"product_type":"c1","uid":2603149,"ip_address":"","ucode":"90BBF81BFCFDD1","user_header":"https://static001.geekbang.org/account/avatar/00/27/b8/8d/34140285.jpg","comment_is_top":false,"comment_ctime":1619689841,"is_pvip":false,"replies":[{"id":105389,"content":"注意到我偷偷塞进的C++11语法了？🤓\n\n详见第8讲，里面有具体说明。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1619792180,"ip_address":"","comment_id":290694,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"老师想问下“拷贝构造赋值”标题下第一个代码块里的两行构造是不是有typo，把括号打成了花括号。（还是说有默认对于initializer_list的支持？）","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521530,"discussion_content":"如果你定义了移动构造函数，编译器就不会生成拷贝构造函数。我们此处确实不希望自动的（错误）拷贝构造行为。解决方法是要么写一个跟模板形式一样的非模板移动构造函数（代码重复），要么显式把拷贝构造函数delete掉。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623115371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":278991,"user_name":"geek","can_delete":false,"product_type":"c1","uid":2401422,"ip_address":"","ucode":"FF0845140D72A9","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/NyFOEueITjaGLpakMEuWAqVQjo1uDIXlpDdpCxXGfaWiaXzibLQ3WgOFCe8D9FvCmyjsGT7jDsLUbkt8jt2aVs9g/132","comment_is_top":false,"comment_ctime":1613528233,"is_pvip":false,"replies":[{"id":101424,"content":"这个就更复杂了。这个专栏来没有讲。目前的知识掌握后，可以去看 weak_ptr 的实现。目前给出的这个实现（及标准的 shared_ptr）都不可以形成环，否则就释放不了了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1613630063,"ip_address":"","comment_id":278991,"utype":1}],"discussion_count":2,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"基于目前给出的shared_ptr的实现，能不能再说说如何解决 多个shared_ptr形成环的情况啊？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515588,"discussion_content":"这个就更复杂了。这个专栏来没有讲。目前的知识掌握后，可以去看 weak_ptr 的实现。目前给出的这个实现（及标准的 shared_ptr）都不可以形成环，否则就释放不了了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1613630063,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2401422,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/NyFOEueITjaGLpakMEuWAqVQjo1uDIXlpDdpCxXGfaWiaXzibLQ3WgOFCe8D9FvCmyjsGT7jDsLUbkt8jt2aVs9g/132","nickname":"geek","note":"","ucode":"FF0845140D72A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349990,"discussion_content":"好的，谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613655051,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253401,"user_name":"Lloyd Liu","can_delete":false,"product_type":"c1","uid":1619354,"ip_address":"","ucode":"82DF4CE95ECB74","user_header":"https://static001.geekbang.org/account/avatar/00/18/b5/9a/0161f563.jpg","comment_is_top":false,"comment_ctime":1602727140,"is_pvip":false,"replies":[{"id":92590,"content":"这句话还不够清楚吗？\n\n“现在 smart_ptr&lt;circle&gt; 可以移动给 smart_ptr&lt;shape&gt;，但不能移动给 smart_ptr&lt;triangle&gt;。”\n\n","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1602779857,"ip_address":"","comment_id":253401,"utype":1}],"discussion_count":3,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"“哦，我撒了一个小谎。不知道你注意到没有，一个 circle* 是可以隐式转换成 shape* 的，但上面的 smart_ptr&lt;circle&gt; 却无法自动转换成 smart_ptr&lt;shape&gt;。这个行为显然还是不够“自然”。\n\n不过，只需要额外加一点模板代码，就能实现这一行为。在我们目前给出的实现里，只需要增加一个构造函数即可——这也算是我们让赋值函数利用构造函数的好处了。”\n\n下面除了代码之外，可以增加一个使用的例子","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507064,"discussion_content":"这句话还不够清楚吗？\n\n“现在 smart_ptr&amp;lt;circle&amp;gt; 可以移动给 smart_ptr&amp;lt;shape&amp;gt;，但不能移动给 smart_ptr&amp;lt;triangle&amp;gt;。”\n\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602779857,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1619354,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b5/9a/0161f563.jpg","nickname":"Lloyd Liu","note":"","ucode":"82DF4CE95ECB74","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312772,"discussion_content":"在智能指针中的模板构造函数，开始有点没太懂怎么使用\n后来查了下模板构造函数，是如下的使用方法吧\n\nsmart_ptr<circle> ptr1;\nsmart_ptr<shape> ptr2{std::move (ptr1)};","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602812610,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1619354,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b5/9a/0161f563.jpg","nickname":"Lloyd Liu","note":"","ucode":"82DF4CE95ECB74","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312948,"discussion_content":"嗯，这是一种典型用法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602865318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":312772,"ip_address":"","group_id":0},"score":312948,"extra":""}]}]},{"had_liked":false,"id":246376,"user_name":"lyfei","can_delete":false,"product_type":"c1","uid":1757471,"ip_address":"","ucode":"31ACC702BE6FEA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","comment_is_top":false,"comment_ctime":1599301703,"is_pvip":false,"replies":[{"id":90689,"content":"智能指针有到 bool 的自动转换，你看到的 1 就是 true，代表指针不为空。\n\nstd::shared_ptr 可以用 &lt;&lt; 输出的原因是标准库提供了 operator&lt;&lt; 的重载（我没有）。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1599487326,"ip_address":"","comment_id":246376,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"吴老师你好，就是第一个cout出来的结果是1呀？不应该是heap上的一个地址吗：\n    smart_ptr&lt;int&gt; smt_tmp(new int);\n    std::cout &lt;&lt; &quot;smt_tmp is: &quot; &lt;&lt; smt_tmp &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;&amp;smt_tmp is: &quot; &lt;&lt; &amp;smt_tmp &lt;&lt; std::endl;\n\n    std::shared_ptr&lt;int&gt; sha_tmp(new int);\n    std::cout &lt;&lt; &quot;sha_tmp is: &quot; &lt;&lt; sha_tmp &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;&amp;sha_tmp is: &quot; &lt;&lt; &amp;sha_tmp &lt;&lt; std::endl;\nstd内部的智能指针输出是heap上的地址。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507064,"discussion_content":"这句话还不够清楚吗？\n\n“现在 smart_ptr&amp;lt;circle&amp;gt; 可以移动给 smart_ptr&amp;lt;shape&amp;gt;，但不能移动给 smart_ptr&amp;lt;triangle&amp;gt;。”\n\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602779857,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1619354,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b5/9a/0161f563.jpg","nickname":"Lloyd Liu","note":"","ucode":"82DF4CE95ECB74","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312772,"discussion_content":"在智能指针中的模板构造函数，开始有点没太懂怎么使用\n后来查了下模板构造函数，是如下的使用方法吧\n\nsmart_ptr<circle> ptr1;\nsmart_ptr<shape> ptr2{std::move (ptr1)};","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602812610,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1619354,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b5/9a/0161f563.jpg","nickname":"Lloyd Liu","note":"","ucode":"82DF4CE95ECB74","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312948,"discussion_content":"嗯，这是一种典型用法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602865318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":312772,"ip_address":"","group_id":0},"score":312948,"extra":""}]}]},{"had_liked":false,"id":384146,"user_name":"Geek_a2e565","can_delete":false,"product_type":"c1","uid":3739479,"ip_address":"辽宁","ucode":"5211118EEE7039","user_header":"","comment_is_top":false,"comment_ctime":1700403794,"is_pvip":false,"replies":[{"id":140141,"content":"1. 在一个类模板的定义内部，使用类名称就是代表当前的自己。这在语法上更加简洁。\n\n2. 当smart_ptr&lt;circle&gt; 赋值给smart_ptr&lt;shape&gt;的时候，smart_ptr&lt;shape&gt; 的赋值运算符需要一个 smart_ptr&lt;shape&gt;，编译器会看到有 template &lt;typename U&gt; smart_ptr(const smart_ptr&lt;U&gt;&amp; other) 可以用，因此就可以先构造出 smart_ptr&lt;shape&gt;，然后用它去调用赋值运算符。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1700476477,"ip_address":"上海","comment_id":384146,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"老师 您好，看完您的专栏收益匪浅，这里有几处疑问希望老师能指教一下：\n1、模板类template&lt;typename T&gt; smart_ptr中的拷贝构造以及赋值函数的声明是smart_ptr(const smart_ptr&amp; other) 和smart_ptr&amp; operator=(smart_ptr rhs) noexcept, 这里参数列表中的smart_ptr是不是可以理解为就是smart_ptr&lt;T&gt;，如果是的话，为什么不写成smart_ptr&lt;T&gt;呢？\n2、赋值函数smart_ptr&amp; operator=(smart_ptr rhs) noexcept,在构造形参的时候会调用拷贝构造（不用std::move），那么当smart_ptr&lt;circle&gt; 赋值给smart_ptr&lt;shape&gt;的时候，调用的应该是模板拷贝构造，构造出来的临时对象也应该是smart_ptr&lt;circle&gt; ，那么为什么赋值函数不用定义成模板函数呢？\n\n十分感谢老师","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632107,"discussion_content":"1. 在一个类模板的定义内部，使用类名称就是代表当前的自己。这在语法上更加简洁。\n\n2. 当smart_ptr&lt;circle&gt; 赋值给smart_ptr&lt;shape&gt;的时候，smart_ptr&lt;shape&gt; 的赋值运算符需要一个 smart_ptr&lt;shape&gt;，编译器会看到有 template &lt;typename U&gt; smart_ptr(const smart_ptr&lt;U&gt;&amp; other) 可以用，因此就可以先构造出 smart_ptr&lt;shape&gt;，然后用它去调用赋值运算符。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1700476477,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341416,"user_name":"余淮","can_delete":false,"product_type":"c1","uid":2923989,"ip_address":"","ucode":"2B7DA1475DC0BF","user_header":"https://static001.geekbang.org/account/avatar/00/2c/9d/d5/4dcf8986.jpg","comment_is_top":false,"comment_ctime":1649591367,"is_pvip":false,"replies":[{"id":124820,"content":"简单理解，就是一个接受右值，一个接受左值。下一讲就会具体描述。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1649751504,"ip_address":"","comment_id":341416,"utype":1}],"discussion_count":2,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"老师，请问下smart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other)跟smart_ptr(smart_ptr&lt;U&gt;&amp; other)这两个引用符号不同传递参数有什么不同？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561944,"discussion_content":"简单理解，就是一个接受右值，一个接受左值。下一讲就会具体描述。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1649751504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2923989,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/9d/d5/4dcf8986.jpg","nickname":"余淮","note":"","ucode":"2B7DA1475DC0BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":561973,"discussion_content":"好的，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649756243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":561944,"ip_address":"","group_id":0},"score":561973,"extra":""}]}]},{"had_liked":false,"id":339670,"user_name":"zg","can_delete":false,"product_type":"c1","uid":1055025,"ip_address":"","ucode":"809277A5F204BD","user_header":"https://static001.geekbang.org/account/avatar/00/10/19/31/b438b9cf.jpg","comment_is_top":false,"comment_ctime":1648285121,"is_pvip":false,"replies":[{"id":124388,"content":"智能指针的格式不对，del 也没有改。应该是：\n\nvoid del(void (*)(int)) {}\nvoid fun(int x) {}\nint main()\n{\n    std::shared_ptr&lt;void(int)&gt; ee(fun, del);\n    (*ee)(42);\n}","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1648638780,"ip_address":"","comment_id":339670,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"老师好，https:&#47;&#47;en.cppreference.com&#47;w&#47;cpp&#47;memory&#47;shared_ptr 中  shared_ptr的模板参数是一个函数类型。示例代码如下：\n\nvoid del(void(*)()) {}\nvoid fun() {}\nint main(){\n  std::shared_ptr&lt;void()&gt; ee(fun, del);\n  (*ee)();\n}\n\n如果我要把无参函数fun（），改为void fun（int x），代码改为：\n  shared_ptr&lt;void()(int)&gt; ee(fun,del);\n(*ee)(5);\n编译通不过，报错信息看不太明白，麻烦讲一下应该怎么改？\n","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561944,"discussion_content":"简单理解，就是一个接受右值，一个接受左值。下一讲就会具体描述。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1649751504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2923989,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/9d/d5/4dcf8986.jpg","nickname":"余淮","note":"","ucode":"2B7DA1475DC0BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":561973,"discussion_content":"好的，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649756243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":561944,"ip_address":"","group_id":0},"score":561973,"extra":""}]}]},{"had_liked":false,"id":314855,"user_name":"wine99","can_delete":false,"product_type":"c1","uid":1682531,"ip_address":"","ucode":"F22F3E23E6F851","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/h6unp47tSLwwUZgnd3tuSSSEEOvXrC8aTI38ESYzsVZU8zZLMxvLDv8Zw2fmhr9M8CM46HCvQvicoutzwTjwNaA/132","comment_is_top":false,"comment_ctime":1633506520,"is_pvip":false,"replies":[{"id":114151,"content":"嗯嗯，rhs不是我发明的，应该是惯用写法了吧。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1633787274,"ip_address":"","comment_id":314855,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"太妙了！老师的文稿设计得真好，循序渐进。请问老师代码里常用的参数名rhs，是什么缩写？right hand side？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559179,"discussion_content":"智能指针的格式不对，del 也没有改。应该是：\n\nvoid del(void (*)(int)) {}\nvoid fun(int x) {}\nint main()\n{\n    std::shared_ptr&lt;void(int)&gt; ee(fun, del);\n    (*ee)(42);\n}","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1648638781,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313257,"user_name":"weing","can_delete":false,"product_type":"c1","uid":1984655,"ip_address":"","ucode":"95701BDA31F6F6","user_header":"","comment_is_top":false,"comment_ctime":1632355232,"is_pvip":false,"replies":[{"id":113757,"content":"对。这是一种惯用法，适合大部分场景。\n\n对于性能有极致追求的，可能需要考虑根据使用场景需不需要更快的执行路径。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1632810056,"ip_address":"","comment_id":313257,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"现在赋值函数的行为是移动还是拷贝，完全依赖于构造参数时走的是移动构造还是拷贝构造。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527296,"discussion_content":"对。这是一种惯用法，适合大部分场景。\n\n对于性能有极致追求的，可能需要考虑根据使用场景需不需要更快的执行路径。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632810056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296632,"user_name":"怪兽","can_delete":false,"product_type":"c1","uid":1324007,"ip_address":"","ucode":"3342C55CB83B08","user_header":"https://static001.geekbang.org/account/avatar/00/14/33/e7/145be2f9.jpg","comment_is_top":false,"comment_ctime":1623074852,"is_pvip":false,"replies":[{"id":107758,"content":"如果你定义了移动构造函数，编译器就不会生成拷贝构造函数。我们此处确实不希望自动的（错误）拷贝构造行为。解决方法是要么写一个跟模板形式一样的非模板移动构造函数（代码重复），要么显式把拷贝构造函数delete掉。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1623115371,"ip_address":"","comment_id":296632,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"老师好，请问一下原文中：“如果我们想消除代码重复、删除移动构造函数的话，就需要把拷贝构造函数标记成 = delete 了”。我结合上下文语境始终不明白什么意思，消除什么代码重复?要删除移动构造函数，就需要把拷贝构造函数标记成 = delete？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521530,"discussion_content":"如果你定义了移动构造函数，编译器就不会生成拷贝构造函数。我们此处确实不希望自动的（错误）拷贝构造行为。解决方法是要么写一个跟模板形式一样的非模板移动构造函数（代码重复），要么显式把拷贝构造函数delete掉。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623115371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":290694,"user_name":"Jm can","can_delete":false,"product_type":"c1","uid":2603149,"ip_address":"","ucode":"90BBF81BFCFDD1","user_header":"https://static001.geekbang.org/account/avatar/00/27/b8/8d/34140285.jpg","comment_is_top":false,"comment_ctime":1619689841,"is_pvip":false,"replies":[{"id":105389,"content":"注意到我偷偷塞进的C++11语法了？🤓\n\n详见第8讲，里面有具体说明。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1619792180,"ip_address":"","comment_id":290694,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"老师想问下“拷贝构造赋值”标题下第一个代码块里的两行构造是不是有typo，把括号打成了花括号。（还是说有默认对于initializer_list的支持？）","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519265,"discussion_content":"注意到我偷偷塞进的C++11语法了？🤓\n\n详见第8讲，里面有具体说明。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619792180,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":278991,"user_name":"geek","can_delete":false,"product_type":"c1","uid":2401422,"ip_address":"","ucode":"FF0845140D72A9","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/NyFOEueITjaGLpakMEuWAqVQjo1uDIXlpDdpCxXGfaWiaXzibLQ3WgOFCe8D9FvCmyjsGT7jDsLUbkt8jt2aVs9g/132","comment_is_top":false,"comment_ctime":1613528233,"is_pvip":false,"replies":[{"id":101424,"content":"这个就更复杂了。这个专栏来没有讲。目前的知识掌握后，可以去看 weak_ptr 的实现。目前给出的这个实现（及标准的 shared_ptr）都不可以形成环，否则就释放不了了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1613630063,"ip_address":"","comment_id":278991,"utype":1}],"discussion_count":2,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"基于目前给出的shared_ptr的实现，能不能再说说如何解决 多个shared_ptr形成环的情况啊？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519265,"discussion_content":"注意到我偷偷塞进的C++11语法了？🤓\n\n详见第8讲，里面有具体说明。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619792180,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253401,"user_name":"Lloyd Liu","can_delete":false,"product_type":"c1","uid":1619354,"ip_address":"","ucode":"82DF4CE95ECB74","user_header":"https://static001.geekbang.org/account/avatar/00/18/b5/9a/0161f563.jpg","comment_is_top":false,"comment_ctime":1602727140,"is_pvip":false,"replies":[{"id":92590,"content":"这句话还不够清楚吗？\n\n“现在 smart_ptr&lt;circle&gt; 可以移动给 smart_ptr&lt;shape&gt;，但不能移动给 smart_ptr&lt;triangle&gt;。”\n\n","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1602779857,"ip_address":"","comment_id":253401,"utype":1}],"discussion_count":3,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"“哦，我撒了一个小谎。不知道你注意到没有，一个 circle* 是可以隐式转换成 shape* 的，但上面的 smart_ptr&lt;circle&gt; 却无法自动转换成 smart_ptr&lt;shape&gt;。这个行为显然还是不够“自然”。\n\n不过，只需要额外加一点模板代码，就能实现这一行为。在我们目前给出的实现里，只需要增加一个构造函数即可——这也算是我们让赋值函数利用构造函数的好处了。”\n\n下面除了代码之外，可以增加一个使用的例子","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515588,"discussion_content":"这个就更复杂了。这个专栏来没有讲。目前的知识掌握后，可以去看 weak_ptr 的实现。目前给出的这个实现（及标准的 shared_ptr）都不可以形成环，否则就释放不了了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1613630063,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2401422,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/NyFOEueITjaGLpakMEuWAqVQjo1uDIXlpDdpCxXGfaWiaXzibLQ3WgOFCe8D9FvCmyjsGT7jDsLUbkt8jt2aVs9g/132","nickname":"geek","note":"","ucode":"FF0845140D72A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349990,"discussion_content":"好的，谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613655051,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":246376,"user_name":"lyfei","can_delete":false,"product_type":"c1","uid":1757471,"ip_address":"","ucode":"31ACC702BE6FEA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","comment_is_top":false,"comment_ctime":1599301703,"is_pvip":false,"replies":[{"id":90689,"content":"智能指针有到 bool 的自动转换，你看到的 1 就是 true，代表指针不为空。\n\nstd::shared_ptr 可以用 &lt;&lt; 输出的原因是标准库提供了 operator&lt;&lt; 的重载（我没有）。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1599487326,"ip_address":"","comment_id":246376,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100040501,"comment_content":"吴老师你好，就是第一个cout出来的结果是1呀？不应该是heap上的一个地址吗：\n    smart_ptr&lt;int&gt; smt_tmp(new int);\n    std::cout &lt;&lt; &quot;smt_tmp is: &quot; &lt;&lt; smt_tmp &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;&amp;smt_tmp is: &quot; &lt;&lt; &amp;smt_tmp &lt;&lt; std::endl;\n\n    std::shared_ptr&lt;int&gt; sha_tmp(new int);\n    std::cout &lt;&lt; &quot;sha_tmp is: &quot; &lt;&lt; sha_tmp &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;&amp;sha_tmp is: &quot; &lt;&lt; &amp;sha_tmp &lt;&lt; std::endl;\nstd内部的智能指针输出是heap上的地址。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505125,"discussion_content":"智能指针有到 bool 的自动转换，你看到的 1 就是 true，代表指针不为空。\n\nstd::shared_ptr 可以用 &amp;lt;&amp;lt; 输出的原因是标准库提供了 operator&amp;lt;&amp;lt; 的重载（我没有）。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599487326,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236097,"user_name":"ADC不能C","can_delete":false,"product_type":"c1","uid":1656719,"ip_address":"","ucode":"BD64C5DBC24AF6","user_header":"https://static001.geekbang.org/account/avatar/00/19/47/8f/85f73373.jpg","comment_is_top":false,"comment_ctime":1595315345,"is_pvip":false,"replies":[{"id":87222,"content":"进程内应该是行不通的。想办法走RPC吧。COM的东西我也不熟。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1595335857,"ip_address":"","comment_id":236097,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"老师问你个问题就是64位程序如果通过com.exe调用com.dll来使用32位生成的dll。com就是微软提供的一个组件","like_count":1},{"had_liked":false,"id":183336,"user_name":"tr","can_delete":false,"product_type":"c1","uid":1758903,"ip_address":"","ucode":"020AB6A704CD43","user_header":"","comment_is_top":false,"comment_ctime":1583006615,"is_pvip":false,"replies":[{"id":70956,"content":"你似乎没有用C++17的新语法。下面（前半部分的）代码在 C++17 里是可以通过的：\n\n#include &lt;memory&gt;\n\nint main()\n{\n    auto p1 = std::shared_ptr&lt;char[]&gt;(new char[20]);\n    p1[0] = &#39;h&#39;;\n    p1[19] = &#39;\\0&#39;;\n\n    &#47;&#47; C++20\n    auto p2 = std::make_shared&lt;char[]&gt;(20);\n    p2[0] = &#39;h&#39;;\n    p2[19] = &#39;\\0&#39;;\n}\n\nC++20 部分的代码目前测下来只有 GCC 已经支持。\n\n注意，operator[] 只对数组类型的 shared_ptr 有效：只能用于 shared_ptr&lt;char[]&gt;，不能用于 shared_ptr&lt;char&gt;。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1583029587,"ip_address":"","comment_id":183336,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"老师，shared_ptr sp(new int[10]，default_delete&lt;int[]&gt;())时，访问数组中的元素只能先get到裸指针之后再访问么？能不能类似于sp[2]这样直接访问元素（sp[2]肯定是不行的，也没试出来哪种形式可行）","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501941,"discussion_content":"进程内应该是行不通的。想办法走RPC吧。COM的东西我也不熟。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595335857,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168782,"user_name":"刘德聪","can_delete":false,"product_type":"c1","uid":1316662,"ip_address":"","ucode":"2968605D077072","user_header":"https://static001.geekbang.org/account/avatar/00/14/17/36/3d8e86e6.jpg","comment_is_top":false,"comment_ctime":1578158165,"is_pvip":false,"replies":[{"id":65505,"content":"就靠\n\nptr_ = other.ptr_;\n\n这句。int* 是不能直接赋值给一个 double* 的变量的。\n\n这儿自动转换正好帮忙，因为 circle* 是可以赋值给 shape* 的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578225723,"ip_address":"","comment_id":168782,"utype":1}],"discussion_count":2,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"有个问题，基于上面给出的模板中的构造函数如下：\ntemplate &lt;typename U&gt;  smart_ptr(const smart_ptr&lt;U&gt;&amp; other) noexcept  {    ptr_ = other.ptr_;    if (ptr_) {      other.shared_count_-&gt;add_count();      shared_count_ = other.shared_count_;    }  }\n当类型U和模板类型T不一致的时候， 构造函数的实现并没有检测这一点？ 程序是如何保证类型U和T一致呢？\n比如下面代码，程序会报错。但是从smart_ptr构造函数，我不知道是如何保证了这点？\nstd::shared_ptr&lt;int&gt; pi(new int(10)); \nstd::shared_ptr&lt;double&gt; pd(pi);\n\nnote:  评论粘贴代码有点混乱，辛苦了。\n","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480334,"discussion_content":"就靠\n\nptr_ = other.ptr_;\n\n这句。int* 是不能直接赋值给一个 double* 的变量的。\n\n这儿自动转换正好帮忙，因为 circle* 是可以赋值给 shape* 的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578225723,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316662,"avatar":"https://static001.geekbang.org/account/avatar/00/14/17/36/3d8e86e6.jpg","nickname":"刘德聪","note":"","ucode":"2968605D077072","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":119736,"discussion_content":"明白了。谢谢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578236056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167289,"user_name":"talor","can_delete":false,"product_type":"c1","uid":1350638,"ip_address":"","ucode":"245EE908DA39EC","user_header":"https://static001.geekbang.org/account/avatar/00/14/9b/ee/211e86cd.jpg","comment_is_top":false,"comment_ctime":1577756901,"is_pvip":false,"replies":[{"id":64994,"content":"这个方法正常来说是安全的，因为拷贝构造不该碰 other 的内容的。碰到 auto_ptr 这样的奇怪类就不行了。这也是 auto_ptr 被干掉的原因。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577801830,"ip_address":"","comment_id":167289,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"您好，我这里有一个疑问，在上面的实现operator=时使用了拷贝和交换，当拷贝构造发生异常的时候，this对象没有被破坏，但是other对象可能已经被改变了，这样是否也不是异常安全的。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479815,"discussion_content":"这个方法正常来说是安全的，因为拷贝构造不该碰 other 的内容的。碰到 auto_ptr 这样的奇怪类就不行了。这也是 auto_ptr 被干掉的原因。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577801830,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165230,"user_name":"lyfei","can_delete":false,"product_type":"c1","uid":1757471,"ip_address":"","ucode":"31ACC702BE6FEA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","comment_is_top":false,"comment_ctime":1577183929,"is_pvip":false,"replies":[{"id":62990,"content":"你不能拿着 goto 的编程思维来看待结构化编程。要找出更高层的抽象。\n\n你的第一个例子，我完全看不出指针变量的必要性。我看到的是两个潜在函数的可能性：do_work(int&amp;) 和 do_something_else(int&amp;)。\n\n你的第二个例子有生命期管理的混乱：如果你赋给shared_ptr，你有其他的 delete 语句吗？你能手工跟踪得清每个对象的生命期吗？shared_ptr 不允许这样的赋值，也是为了防止意外导致的错误。\n\n要用好智能指针，最基本的用法就是代码里不要出现裸指针，也不要出现 new 和 delete，除非你对它们的用法和副作用完全熟稔于心。拿你的例子（虽然我不确定你为什么要在堆上分配对象），应该写成：\n\nauto test_a = make_shared&lt;int&gt;();\n&#47;&#47; 或糟点的写法 auto test_a = shared_ptr&lt;int&gt;(new int);\nauto test_b = make_shared&lt;int&gt;();\nauto int_ptr = test_a;\nint_ptr = test_b;","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577190472,"ip_address":"","comment_id":165230,"utype":1}],"discussion_count":6,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"老师您好，我还是对智能指针一对多的情况有些疑惑：\n1. 普通指针\n    int a = 1, b = 1;\n    int *base;\n    base = &amp;a;\n    {\n&#47;&#47;        Do some work...\n    }\n    base = &amp;b;\n    {\n&#47;&#47;        Do some work...\n    }\n2. 智能指针\n    int *test_a = new int;\n    int *test_b = new int;\n\n    shared_ptr&lt;int&gt; int_ptr(test_a);\n    int_ptr = test_b;\n问题：第1种情况，使用普通指针，我们可以让base指针指向不同的地址，但是我在第2种情况中使用智能指针指向另一个动态内存的时候，却报错：“error: no match for ‘operator=’ (operand types are ‘std::shared_ptr&lt;int&gt;’ and ‘int*’)”","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479815,"discussion_content":"这个方法正常来说是安全的，因为拷贝构造不该碰 other 的内容的。碰到 auto_ptr 这样的奇怪类就不行了。这也是 auto_ptr 被干掉的原因。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577801830,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162378,"user_name":"Geek_b68b74","can_delete":false,"product_type":"c1","uid":1780585,"ip_address":"","ucode":"7CB026A020D513","user_header":"","comment_is_top":false,"comment_ctime":1576506681,"is_pvip":false,"replies":[{"id":61794,"content":"如果学C++还不很久，可以先读些其他书温习基础知识（比如C++之父的《C++语言导学》）。我对你了解什么有一定预设的，可能判断不那么准。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576544875,"ip_address":"","comment_id":162378,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"第一讲看了几遍才明白，第二讲直接懵逼了。。。非常有深度的专栏，我再多看几遍","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479084,"discussion_content":"你不能拿着 goto 的编程思维来看待结构化编程。要找出更高层的抽象。\n\n你的第一个例子，我完全看不出指针变量的必要性。我看到的是两个潜在函数的可能性：do_work(int&amp;amp;) 和 do_something_else(int&amp;amp;)。\n\n你的第二个例子有生命期管理的混乱：如果你赋给shared_ptr，你有其他的 delete 语句吗？你能手工跟踪得清每个对象的生命期吗？shared_ptr 不允许这样的赋值，也是为了防止意外导致的错误。\n\n要用好智能指针，最基本的用法就是代码里不要出现裸指针，也不要出现 new 和 delete，除非你对它们的用法和副作用完全熟稔于心。拿你的例子（虽然我不确定你为什么要在堆上分配对象），应该写成：\n\nauto test_a = make_shared&amp;lt;int&amp;gt;();\n// 或糟点的写法 auto test_a = shared_ptr&amp;lt;int&amp;gt;(new int);\nauto test_b = make_shared&amp;lt;int&amp;gt;();\nauto int_ptr = test_a;\nint_ptr = test_b;","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577190472,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":98992,"discussion_content":"搜嘎，明白了。\n谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577193246,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":98982,"discussion_content":"嗯嗯，谢谢老师的回复，我只是举个例子。没有考虑其他","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577193076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":98743,"discussion_content":"智能指针拷贝构造函数或者赋值函数以及移动语义中都仍然需要shared_ptr类的对象，我这里直接是动态内存地址，所以会导致编译出错，那么如果我想实现类似的意思怎么办到呀？\n谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577184498,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":99242,"discussion_content":"已经说了不要裸指针了呀。要么使用引用，表示不处理生命周期，要么使用 unique_ptr 或 shared_ptr。就是要迫使你想明白生命周期。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577197738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":98743,"ip_address":"","group_id":0},"score":99242,"extra":""},{"author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":100261,"discussion_content":"嗯嗯，谢谢吴老师耐心讲解😃","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577245312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":99242,"ip_address":"","group_id":0},"score":100261,"extra":""}]}]},{"had_liked":false,"id":158446,"user_name":"总统老唐","can_delete":false,"product_type":"c1","uid":1490070,"ip_address":"","ucode":"F2CC66E5BB4871","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/96/c679bb3d.jpg","comment_is_top":false,"comment_ctime":1575372233,"is_pvip":false,"replies":[{"id":60646,"content":"拷贝构造时，老的对象都还没生成呢，哪有新老的比较？","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575378293,"ip_address":"","comment_id":158446,"utype":1}],"discussion_count":3,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"吴老师，有个疑惑，看也有同学问到这里，讲smart_ptr的时候，感觉赋值操作有特别考虑this ＝＝&amp;rhs 的情况，但是拷贝构造好像没有特别考虑，这是基于什么原因","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478034,"discussion_content":"如果学C++还不很久，可以先读些其他书温习基础知识（比如C++之父的《C++语言导学》）。我对你了解什么有一定预设的，可能判断不那么准。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576544875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157589,"user_name":"花晨少年","can_delete":false,"product_type":"c1","uid":1098987,"ip_address":"","ucode":"6AA3537A6BA10E","user_header":"https://static001.geekbang.org/account/avatar/00/10/c4/eb/2285a345.jpg","comment_is_top":false,"comment_ctime":1575205416,"is_pvip":false,"replies":[{"id":60430,"content":"swap不判断的。目前的写法保证了this == &amp;rhs不会有问题。\n\n当你的对象有多个成员，赋值到第二个成员时发生了异常。想想这种情况下的结果。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575210518,"ip_address":"","comment_id":157589,"utype":1}],"discussion_count":6,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"如果你学到的赋值函数还有一个类似于 if (this != &amp;rhs) 的判断的话，那种用法更啰嗦，而且异常安全性不够好——如果在赋值过程中发生异常的话，this 对象的内容可能已经被部分破坏了，对象不再处于一个完整的状态。\n——————-—————\n文中这句话不太理解，如果不做这个判断，swap内部应该有判断。\n但是并没有想明白异常安全性怎么不好了，感觉和不加这个判断没有任何区别，赋值过程应该是在这句判断代码的下方做，所以这句代码执行时，对象也没有不完整。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476727,"discussion_content":"拷贝构造时，老的对象都还没生成呢，哪有新老的比较？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575378293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":99469,"discussion_content":"没找到那个问题和答复。泛泛而言，自检查是怕赋值时要把原有的内容清除，再把新的内容放进来，这样不检查自赋值就会出问题。我总体上采用异常安全的做法，总是先赋值，成功后再释放需要释放的资源，这样就不需要检查自赋值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577200144,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1490070,"avatar":"https://static001.geekbang.org/account/avatar/00/16/bc/96/c679bb3d.jpg","nickname":"总统老唐","note":"","ucode":"F2CC66E5BB4871","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":71390,"discussion_content":"嗯，确实是这样。不过，有同学指出，赋值操作应该也不用考虑两者相等的情况，你的答复是“若只考虑unique_ptr，确实是没有问题的”，但是你采用的先构造一个临时变量的方式，实际上实现的也是unique_ptr的行为，和采用release的方式好像比并没有区别，不知道为什么要在这里引入这种方式？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575418688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157222,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1575087122,"is_pvip":false,"replies":[{"id":60315,"content":"不是。再想想。按你的写法，this指向的对象就被传到rhs来拥有了。这不是=希望做的事情。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575108262,"ip_address":"","comment_id":157222,"utype":1}],"discussion_count":4,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"smart_ptr&amp; operator=(smart_ptr&amp; rhs) \n {    smart_ptr(rhs).swap(*this);    return *this;  }\n\nrhs 本身就是smart_ptr的左值引用了，\n在函数题里smart_ptr(rhs), \n貌似应该是rhs.swap(*this）？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70821,"discussion_content":"不是说这个例子会出先问题，而是通用而言，这种方式可能出问题。\n\n如：\n\nclass A {\npublic:\n  A&amp; operator=(const A&amp;);\nprivate:\n  B b_;\n  C* c_;\n};\n\nA&amp; A::operator(const A&amp; rhs)\n{\n  if (this == &amp;rhs) {\n    return;\n  }\n  b_ = rhs.b_;\n  c_ = new C(*rhs.c_);\n}\n\n如果在上面最后一行有效代码处出现异常，那 this 的状态就很奇怪，头换成了别人（rhs）的，身体还是自己的。\n\n我说的方法就是一律使用拷贝构造函数来构造新对象，然后使用无异常的 swap 来获得新对象。这样，this 要么不变，要么成为全新的。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1575381516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1098987,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/eb/2285a345.jpg","nickname":"花晨少年","note":"","ucode":"6AA3537A6BA10E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":70914,"discussion_content":"谢谢老师，了解了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575383154,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":70821,"ip_address":"","group_id":0},"score":70914,"extra":""},{"author":{"id":2181930,"avatar":"https://static001.geekbang.org/account/avatar/00/21/4b/2a/4602363c.jpg","nickname":"高小高","note":"","ucode":"6F7D31403EE67A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":321479,"discussion_content":"老师，请问swap是怎么保证无异常的呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604585523,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":70821,"ip_address":"","group_id":0},"score":321479,"extra":""},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":2181930,"avatar":"https://static001.geekbang.org/account/avatar/00/21/4b/2a/4602363c.jpg","nickname":"高小高","note":"","ucode":"6F7D31403EE67A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":321855,"discussion_content":"先拷贝构造一个新对象，在这个过程中如果出现异常则当前对象完全不变。如果没问题，则进行一个无异常的交换操作。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1604640362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":321479,"ip_address":"","group_id":0},"score":321855,"extra":""}]},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476476,"discussion_content":"swap不判断的。目前的写法保证了this == &amp;amp;rhs不会有问题。\n\n当你的对象有多个成员，赋值到第二个成员时发生了异常。想想这种情况下的结果。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575210518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1098987,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/eb/2285a345.jpg","nickname":"花晨少年","note":"","ucode":"6AA3537A6BA10E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":69252,"discussion_content":"哈，还是不太懂，老师见谅.\nsmart_ptr&amp; operator=(smart_ptr rhs) noexcept {\nif (this != &amp;rhs) { //后加上的判断 //@1\n rhs.swap(*this); \n}\n return *this; \n}\n\nvoid swap(smart_ptr&amp; rhs) noexcept { \n\tusing std::swap;\n\tswap(ptr_, rhs.ptr_);\n\tswap(shared_count_, rhs.shared_count_);//@2\n }\n\n@1加上判断之后，除了代码繁琐之外，为什么会影响异常的完整性。\n如果在@2处出现异常，对象不也是不完整的吗，感觉加不加判断，并没有任何影响。\n另外如果不加判断，是怎么确保&#34;this == &amp;rhs&#34;不会有问题的呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575275885,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156614,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1574923611,"is_pvip":false,"replies":[{"id":60160,"content":"看来我的难度把控还不够好。可以有点不求甚解。先体会一下。等专栏结束了，回过来再看一遍，也许就非常清楚了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574949140,"ip_address":"","comment_id":156614,"utype":1}],"discussion_count":2,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"看到评论圈 好多人都说看不懂  我的心肌梗塞算是缓解了 我也好吃力啊 不过在这一节了我倒是想到了如下知识点\n1. 拷贝构造 赋值构造 还有从未接触过的移动构造\n2. 各种类型转换\n3. 操作符的重载","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476366,"discussion_content":"不是。再想想。按你的写法，this指向的对象就被传到rhs来拥有了。这不是=希望做的事情。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1575108262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1212323,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7f/a3/23540579.jpg","nickname":"robonix","note":"","ucode":"866EC82EDA455B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":67172,"discussion_content":"赋值操作希望做的事情之一是要将rhs掏空，对吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575124312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1212323,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7f/a3/23540579.jpg","nickname":"robonix","note":"","ucode":"866EC82EDA455B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":67627,"discussion_content":"对，掏空rhs。this原本持有的内容立即释放。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1575162449,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":67172,"ip_address":"","group_id":0},"score":67627,"extra":""},{"author":{"id":1477855,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","nickname":"禾桃","note":"","ucode":"9FE85C34A9E9E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":67642,"discussion_content":"非常感谢！\n\n之前没有正确的消化这句话\n“ 在赋值函数中，则通过拷贝构造产生一个临时对象并调用 swap 来交换对指针的所有权。”\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575163389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":67627,"ip_address":"","group_id":0},"score":67642,"extra":""}]}]},{"had_liked":false,"id":236097,"user_name":"ADC不能C","can_delete":false,"product_type":"c1","uid":1656719,"ip_address":"","ucode":"BD64C5DBC24AF6","user_header":"https://static001.geekbang.org/account/avatar/00/19/47/8f/85f73373.jpg","comment_is_top":false,"comment_ctime":1595315345,"is_pvip":false,"replies":[{"id":87222,"content":"进程内应该是行不通的。想办法走RPC吧。COM的东西我也不熟。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1595335857,"ip_address":"","comment_id":236097,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"老师问你个问题就是64位程序如果通过com.exe调用com.dll来使用32位生成的dll。com就是微软提供的一个组件","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501941,"discussion_content":"进程内应该是行不通的。想办法走RPC吧。COM的东西我也不熟。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595335857,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183336,"user_name":"tr","can_delete":false,"product_type":"c1","uid":1758903,"ip_address":"","ucode":"020AB6A704CD43","user_header":"","comment_is_top":false,"comment_ctime":1583006615,"is_pvip":false,"replies":[{"id":70956,"content":"你似乎没有用C++17的新语法。下面（前半部分的）代码在 C++17 里是可以通过的：\n\n#include &lt;memory&gt;\n\nint main()\n{\n    auto p1 = std::shared_ptr&lt;char[]&gt;(new char[20]);\n    p1[0] = &#39;h&#39;;\n    p1[19] = &#39;\\0&#39;;\n\n    &#47;&#47; C++20\n    auto p2 = std::make_shared&lt;char[]&gt;(20);\n    p2[0] = &#39;h&#39;;\n    p2[19] = &#39;\\0&#39;;\n}\n\nC++20 部分的代码目前测下来只有 GCC 已经支持。\n\n注意，operator[] 只对数组类型的 shared_ptr 有效：只能用于 shared_ptr&lt;char[]&gt;，不能用于 shared_ptr&lt;char&gt;。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1583029587,"ip_address":"","comment_id":183336,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"老师，shared_ptr sp(new int[10]，default_delete&lt;int[]&gt;())时，访问数组中的元素只能先get到裸指针之后再访问么？能不能类似于sp[2]这样直接访问元素（sp[2]肯定是不行的，也没试出来哪种形式可行）","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485655,"discussion_content":"你似乎没有用C++17的新语法。下面（前半部分的）代码在 C++17 里是可以通过的：\n\n#include &amp;lt;memory&amp;gt;\n\nint main()\n{\n    auto p1 = std::shared_ptr&amp;lt;char[]&amp;gt;(new char[20]);\n    p1[0] = &amp;#39;h&amp;#39;;\n    p1[19] = &amp;#39;\\0&amp;#39;;\n\n    // C++20\n    auto p2 = std::make_shared&amp;lt;char[]&amp;gt;(20);\n    p2[0] = &amp;#39;h&amp;#39;;\n    p2[19] = &amp;#39;\\0&amp;#39;;\n}\n\nC++20 部分的代码目前测下来只有 GCC 已经支持。\n\n注意，operator[] 只对数组类型的 shared_ptr 有效：只能用于 shared_ptr&amp;lt;char[]&amp;gt;，不能用于 shared_ptr&amp;lt;char&amp;gt;。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583029587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168782,"user_name":"刘德聪","can_delete":false,"product_type":"c1","uid":1316662,"ip_address":"","ucode":"2968605D077072","user_header":"https://static001.geekbang.org/account/avatar/00/14/17/36/3d8e86e6.jpg","comment_is_top":false,"comment_ctime":1578158165,"is_pvip":false,"replies":[{"id":65505,"content":"就靠\n\nptr_ = other.ptr_;\n\n这句。int* 是不能直接赋值给一个 double* 的变量的。\n\n这儿自动转换正好帮忙，因为 circle* 是可以赋值给 shape* 的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578225723,"ip_address":"","comment_id":168782,"utype":1}],"discussion_count":2,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"有个问题，基于上面给出的模板中的构造函数如下：\ntemplate &lt;typename U&gt;  smart_ptr(const smart_ptr&lt;U&gt;&amp; other) noexcept  {    ptr_ = other.ptr_;    if (ptr_) {      other.shared_count_-&gt;add_count();      shared_count_ = other.shared_count_;    }  }\n当类型U和模板类型T不一致的时候， 构造函数的实现并没有检测这一点？ 程序是如何保证类型U和T一致呢？\n比如下面代码，程序会报错。但是从smart_ptr构造函数，我不知道是如何保证了这点？\nstd::shared_ptr&lt;int&gt; pi(new int(10)); \nstd::shared_ptr&lt;double&gt; pd(pi);\n\nnote:  评论粘贴代码有点混乱，辛苦了。\n","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485655,"discussion_content":"你似乎没有用C++17的新语法。下面（前半部分的）代码在 C++17 里是可以通过的：\n\n#include &amp;lt;memory&amp;gt;\n\nint main()\n{\n    auto p1 = std::shared_ptr&amp;lt;char[]&amp;gt;(new char[20]);\n    p1[0] = &amp;#39;h&amp;#39;;\n    p1[19] = &amp;#39;\\0&amp;#39;;\n\n    // C++20\n    auto p2 = std::make_shared&amp;lt;char[]&amp;gt;(20);\n    p2[0] = &amp;#39;h&amp;#39;;\n    p2[19] = &amp;#39;\\0&amp;#39;;\n}\n\nC++20 部分的代码目前测下来只有 GCC 已经支持。\n\n注意，operator[] 只对数组类型的 shared_ptr 有效：只能用于 shared_ptr&amp;lt;char[]&amp;gt;，不能用于 shared_ptr&amp;lt;char&amp;gt;。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583029587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167289,"user_name":"talor","can_delete":false,"product_type":"c1","uid":1350638,"ip_address":"","ucode":"245EE908DA39EC","user_header":"https://static001.geekbang.org/account/avatar/00/14/9b/ee/211e86cd.jpg","comment_is_top":false,"comment_ctime":1577756901,"is_pvip":false,"replies":[{"id":64994,"content":"这个方法正常来说是安全的，因为拷贝构造不该碰 other 的内容的。碰到 auto_ptr 这样的奇怪类就不行了。这也是 auto_ptr 被干掉的原因。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577801830,"ip_address":"","comment_id":167289,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"您好，我这里有一个疑问，在上面的实现operator=时使用了拷贝和交换，当拷贝构造发生异常的时候，this对象没有被破坏，但是other对象可能已经被改变了，这样是否也不是异常安全的。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480334,"discussion_content":"就靠\n\nptr_ = other.ptr_;\n\n这句。int* 是不能直接赋值给一个 double* 的变量的。\n\n这儿自动转换正好帮忙，因为 circle* 是可以赋值给 shape* 的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578225723,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316662,"avatar":"https://static001.geekbang.org/account/avatar/00/14/17/36/3d8e86e6.jpg","nickname":"刘德聪","note":"","ucode":"2968605D077072","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":119736,"discussion_content":"明白了。谢谢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578236056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165230,"user_name":"lyfei","can_delete":false,"product_type":"c1","uid":1757471,"ip_address":"","ucode":"31ACC702BE6FEA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","comment_is_top":false,"comment_ctime":1577183929,"is_pvip":false,"replies":[{"id":62990,"content":"你不能拿着 goto 的编程思维来看待结构化编程。要找出更高层的抽象。\n\n你的第一个例子，我完全看不出指针变量的必要性。我看到的是两个潜在函数的可能性：do_work(int&amp;) 和 do_something_else(int&amp;)。\n\n你的第二个例子有生命期管理的混乱：如果你赋给shared_ptr，你有其他的 delete 语句吗？你能手工跟踪得清每个对象的生命期吗？shared_ptr 不允许这样的赋值，也是为了防止意外导致的错误。\n\n要用好智能指针，最基本的用法就是代码里不要出现裸指针，也不要出现 new 和 delete，除非你对它们的用法和副作用完全熟稔于心。拿你的例子（虽然我不确定你为什么要在堆上分配对象），应该写成：\n\nauto test_a = make_shared&lt;int&gt;();\n&#47;&#47; 或糟点的写法 auto test_a = shared_ptr&lt;int&gt;(new int);\nauto test_b = make_shared&lt;int&gt;();\nauto int_ptr = test_a;\nint_ptr = test_b;","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577190472,"ip_address":"","comment_id":165230,"utype":1}],"discussion_count":6,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"老师您好，我还是对智能指针一对多的情况有些疑惑：\n1. 普通指针\n    int a = 1, b = 1;\n    int *base;\n    base = &amp;a;\n    {\n&#47;&#47;        Do some work...\n    }\n    base = &amp;b;\n    {\n&#47;&#47;        Do some work...\n    }\n2. 智能指针\n    int *test_a = new int;\n    int *test_b = new int;\n\n    shared_ptr&lt;int&gt; int_ptr(test_a);\n    int_ptr = test_b;\n问题：第1种情况，使用普通指针，我们可以让base指针指向不同的地址，但是我在第2种情况中使用智能指针指向另一个动态内存的时候，却报错：“error: no match for ‘operator=’ (operand types are ‘std::shared_ptr&lt;int&gt;’ and ‘int*’)”","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479084,"discussion_content":"你不能拿着 goto 的编程思维来看待结构化编程。要找出更高层的抽象。\n\n你的第一个例子，我完全看不出指针变量的必要性。我看到的是两个潜在函数的可能性：do_work(int&amp;amp;) 和 do_something_else(int&amp;amp;)。\n\n你的第二个例子有生命期管理的混乱：如果你赋给shared_ptr，你有其他的 delete 语句吗？你能手工跟踪得清每个对象的生命期吗？shared_ptr 不允许这样的赋值，也是为了防止意外导致的错误。\n\n要用好智能指针，最基本的用法就是代码里不要出现裸指针，也不要出现 new 和 delete，除非你对它们的用法和副作用完全熟稔于心。拿你的例子（虽然我不确定你为什么要在堆上分配对象），应该写成：\n\nauto test_a = make_shared&amp;lt;int&amp;gt;();\n// 或糟点的写法 auto test_a = shared_ptr&amp;lt;int&amp;gt;(new int);\nauto test_b = make_shared&amp;lt;int&amp;gt;();\nauto int_ptr = test_a;\nint_ptr = test_b;","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577190472,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":98992,"discussion_content":"搜嘎，明白了。\n谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577193246,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":98982,"discussion_content":"嗯嗯，谢谢老师的回复，我只是举个例子。没有考虑其他","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577193076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":98743,"discussion_content":"智能指针拷贝构造函数或者赋值函数以及移动语义中都仍然需要shared_ptr类的对象，我这里直接是动态内存地址，所以会导致编译出错，那么如果我想实现类似的意思怎么办到呀？\n谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577184498,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":99242,"discussion_content":"已经说了不要裸指针了呀。要么使用引用，表示不处理生命周期，要么使用 unique_ptr 或 shared_ptr。就是要迫使你想明白生命周期。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577197738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":98743,"ip_address":"","group_id":0},"score":99242,"extra":""},{"author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":100261,"discussion_content":"嗯嗯，谢谢吴老师耐心讲解😃","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577245312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":99242,"ip_address":"","group_id":0},"score":100261,"extra":""}]}]},{"had_liked":false,"id":162378,"user_name":"Geek_b68b74","can_delete":false,"product_type":"c1","uid":1780585,"ip_address":"","ucode":"7CB026A020D513","user_header":"","comment_is_top":false,"comment_ctime":1576506681,"is_pvip":false,"replies":[{"id":61794,"content":"如果学C++还不很久，可以先读些其他书温习基础知识（比如C++之父的《C++语言导学》）。我对你了解什么有一定预设的，可能判断不那么准。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576544875,"ip_address":"","comment_id":162378,"utype":1}],"discussion_count":1,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"第一讲看了几遍才明白，第二讲直接懵逼了。。。非常有深度的专栏，我再多看几遍","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478034,"discussion_content":"如果学C++还不很久，可以先读些其他书温习基础知识（比如C++之父的《C++语言导学》）。我对你了解什么有一定预设的，可能判断不那么准。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576544875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158446,"user_name":"总统老唐","can_delete":false,"product_type":"c1","uid":1490070,"ip_address":"","ucode":"F2CC66E5BB4871","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/96/c679bb3d.jpg","comment_is_top":false,"comment_ctime":1575372233,"is_pvip":false,"replies":[{"id":60646,"content":"拷贝构造时，老的对象都还没生成呢，哪有新老的比较？","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575378293,"ip_address":"","comment_id":158446,"utype":1}],"discussion_count":3,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"吴老师，有个疑惑，看也有同学问到这里，讲smart_ptr的时候，感觉赋值操作有特别考虑this ＝＝&amp;rhs 的情况，但是拷贝构造好像没有特别考虑，这是基于什么原因","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476727,"discussion_content":"拷贝构造时，老的对象都还没生成呢，哪有新老的比较？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575378293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":99469,"discussion_content":"没找到那个问题和答复。泛泛而言，自检查是怕赋值时要把原有的内容清除，再把新的内容放进来，这样不检查自赋值就会出问题。我总体上采用异常安全的做法，总是先赋值，成功后再释放需要释放的资源，这样就不需要检查自赋值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577200144,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1490070,"avatar":"https://static001.geekbang.org/account/avatar/00/16/bc/96/c679bb3d.jpg","nickname":"总统老唐","note":"","ucode":"F2CC66E5BB4871","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":71390,"discussion_content":"嗯，确实是这样。不过，有同学指出，赋值操作应该也不用考虑两者相等的情况，你的答复是“若只考虑unique_ptr，确实是没有问题的”，但是你采用的先构造一个临时变量的方式，实际上实现的也是unique_ptr的行为，和采用release的方式好像比并没有区别，不知道为什么要在这里引入这种方式？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575418688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157589,"user_name":"花晨少年","can_delete":false,"product_type":"c1","uid":1098987,"ip_address":"","ucode":"6AA3537A6BA10E","user_header":"https://static001.geekbang.org/account/avatar/00/10/c4/eb/2285a345.jpg","comment_is_top":false,"comment_ctime":1575205416,"is_pvip":false,"replies":[{"id":60430,"content":"swap不判断的。目前的写法保证了this == &amp;rhs不会有问题。\n\n当你的对象有多个成员，赋值到第二个成员时发生了异常。想想这种情况下的结果。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575210518,"ip_address":"","comment_id":157589,"utype":1}],"discussion_count":6,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"如果你学到的赋值函数还有一个类似于 if (this != &amp;rhs) 的判断的话，那种用法更啰嗦，而且异常安全性不够好——如果在赋值过程中发生异常的话，this 对象的内容可能已经被部分破坏了，对象不再处于一个完整的状态。\n——————-—————\n文中这句话不太理解，如果不做这个判断，swap内部应该有判断。\n但是并没有想明白异常安全性怎么不好了，感觉和不加这个判断没有任何区别，赋值过程应该是在这句判断代码的下方做，所以这句代码执行时，对象也没有不完整。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70821,"discussion_content":"不是说这个例子会出先问题，而是通用而言，这种方式可能出问题。\n\n如：\n\nclass A {\npublic:\n  A&amp; operator=(const A&amp;);\nprivate:\n  B b_;\n  C* c_;\n};\n\nA&amp; A::operator(const A&amp; rhs)\n{\n  if (this == &amp;rhs) {\n    return;\n  }\n  b_ = rhs.b_;\n  c_ = new C(*rhs.c_);\n}\n\n如果在上面最后一行有效代码处出现异常，那 this 的状态就很奇怪，头换成了别人（rhs）的，身体还是自己的。\n\n我说的方法就是一律使用拷贝构造函数来构造新对象，然后使用无异常的 swap 来获得新对象。这样，this 要么不变，要么成为全新的。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1575381516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1098987,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/eb/2285a345.jpg","nickname":"花晨少年","note":"","ucode":"6AA3537A6BA10E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":70914,"discussion_content":"谢谢老师，了解了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575383154,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":70821,"ip_address":"","group_id":0},"score":70914,"extra":""},{"author":{"id":2181930,"avatar":"https://static001.geekbang.org/account/avatar/00/21/4b/2a/4602363c.jpg","nickname":"高小高","note":"","ucode":"6F7D31403EE67A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":321479,"discussion_content":"老师，请问swap是怎么保证无异常的呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604585523,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":70821,"ip_address":"","group_id":0},"score":321479,"extra":""},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":2181930,"avatar":"https://static001.geekbang.org/account/avatar/00/21/4b/2a/4602363c.jpg","nickname":"高小高","note":"","ucode":"6F7D31403EE67A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":321855,"discussion_content":"先拷贝构造一个新对象，在这个过程中如果出现异常则当前对象完全不变。如果没问题，则进行一个无异常的交换操作。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1604640362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":321479,"ip_address":"","group_id":0},"score":321855,"extra":""}]},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476476,"discussion_content":"swap不判断的。目前的写法保证了this == &amp;amp;rhs不会有问题。\n\n当你的对象有多个成员，赋值到第二个成员时发生了异常。想想这种情况下的结果。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575210518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1098987,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/eb/2285a345.jpg","nickname":"花晨少年","note":"","ucode":"6AA3537A6BA10E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":69252,"discussion_content":"哈，还是不太懂，老师见谅.\nsmart_ptr&amp; operator=(smart_ptr rhs) noexcept {\nif (this != &amp;rhs) { //后加上的判断 //@1\n rhs.swap(*this); \n}\n return *this; \n}\n\nvoid swap(smart_ptr&amp; rhs) noexcept { \n\tusing std::swap;\n\tswap(ptr_, rhs.ptr_);\n\tswap(shared_count_, rhs.shared_count_);//@2\n }\n\n@1加上判断之后，除了代码繁琐之外，为什么会影响异常的完整性。\n如果在@2处出现异常，对象不也是不完整的吗，感觉加不加判断，并没有任何影响。\n另外如果不加判断，是怎么确保&#34;this == &amp;rhs&#34;不会有问题的呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575275885,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157222,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1575087122,"is_pvip":false,"replies":[{"id":60315,"content":"不是。再想想。按你的写法，this指向的对象就被传到rhs来拥有了。这不是=希望做的事情。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575108262,"ip_address":"","comment_id":157222,"utype":1}],"discussion_count":4,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"smart_ptr&amp; operator=(smart_ptr&amp; rhs) \n {    smart_ptr(rhs).swap(*this);    return *this;  }\n\nrhs 本身就是smart_ptr的左值引用了，\n在函数题里smart_ptr(rhs), \n貌似应该是rhs.swap(*this）？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476366,"discussion_content":"不是。再想想。按你的写法，this指向的对象就被传到rhs来拥有了。这不是=希望做的事情。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1575108262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1212323,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7f/a3/23540579.jpg","nickname":"robonix","note":"","ucode":"866EC82EDA455B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":67172,"discussion_content":"赋值操作希望做的事情之一是要将rhs掏空，对吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575124312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1212323,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7f/a3/23540579.jpg","nickname":"robonix","note":"","ucode":"866EC82EDA455B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":67627,"discussion_content":"对，掏空rhs。this原本持有的内容立即释放。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1575162449,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":67172,"ip_address":"","group_id":0},"score":67627,"extra":""},{"author":{"id":1477855,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","nickname":"禾桃","note":"","ucode":"9FE85C34A9E9E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":67642,"discussion_content":"非常感谢！\n\n之前没有正确的消化这句话\n“ 在赋值函数中，则通过拷贝构造产生一个临时对象并调用 swap 来交换对指针的所有权。”\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575163389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":67627,"ip_address":"","group_id":0},"score":67642,"extra":""}]}]},{"had_liked":false,"id":156614,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1574923611,"is_pvip":false,"replies":[{"id":60160,"content":"看来我的难度把控还不够好。可以有点不求甚解。先体会一下。等专栏结束了，回过来再看一遍，也许就非常清楚了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574949140,"ip_address":"","comment_id":156614,"utype":1}],"discussion_count":2,"race_medal":0,"score":7,"product_id":100040501,"comment_content":"看到评论圈 好多人都说看不懂  我的心肌梗塞算是缓解了 我也好吃力啊 不过在这一节了我倒是想到了如下知识点\n1. 拷贝构造 赋值构造 还有从未接触过的移动构造\n2. 各种类型转换\n3. 操作符的重载","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476169,"discussion_content":"看来我的难度把控还不够好。可以有点不求甚解。先体会一下。等专栏结束了，回过来再看一遍，也许就非常清楚了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574949140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1236766,"avatar":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","nickname":"传说中的成大大","note":"","ucode":"103543D6E706BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":64512,"discussion_content":"好的，谢谢老师，这也是让我查漏补缺的好机会","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574949867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":393523,"user_name":"Mattrach","can_delete":false,"product_type":"c1","uid":3948439,"ip_address":"福建","ucode":"D530826D02FA1E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI0icYqvY68m60U2qJn7iabqSD4OUvYx2OeiaXA4IqhDia1VNMm3bTGCUaU5J3jbIU1clqCRiap1BubL7g/132","comment_is_top":false,"comment_ctime":1724123363,"is_pvip":false,"replies":[{"id":142931,"content":"1. 第一种形式是一般说的拷贝构造函数；模板形式的构造函数不被看作拷贝构造函数，因此不能替代拷贝构造函数——不提供的话，编译器将会默认提供一个（错误的）版本。其余问题的回答都是是的。\n\n2. 用了 14 标准？如果用 17 标准的话，应该只有拷贝构造而没有移动构造。C++17 有“拷贝消除”，可以优化掉不必要的拷贝或移动。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1724335731,"ip_address":"上海","comment_id":393523,"utype":1}],"discussion_count":4,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"老师你好，有几点疑问想请教一下：\n1、两种拷贝构造smart_ptr(const smart_ptr&amp; other)和smart_ptr(const smart_ptr&lt;U&gt;&amp; other)只是为了解决不同类型模板参数之间的转化吗？比如smart_ptr&lt;circle&gt;到smart_ptr&lt;shape&gt;？这个类型转换的成功与否是在于底层的指针能够相互转换吗？比如smart_ptr&lt;circle&gt;和smart_ptr&lt;triangle&gt;之间无法相互转换是因为circle和triangle本身就无法相互转换？\n2、我在“引用计数”一节测试代码的构造函数中，添加了打印，当执行到ptr2 = ptr1;语句时，执行结果如下：\n```\nuse cout of ptr2 was 0\n模板拷贝构造\n模板移动构造\n拷贝赋值\nuse count of ptr2 is now 2\n```\n请问这个过程中为什么会调用模板移动构造？\n感谢老师解答！","like_count":0},{"had_liked":false,"id":392845,"user_name":"Tiger","can_delete":false,"product_type":"c1","uid":1903781,"ip_address":"重庆","ucode":"BFD74BFE539A8A","user_header":"https://static001.geekbang.org/account/avatar/00/1d/0c/a5/0bbfd5e7.jpg","comment_is_top":false,"comment_ctime":1721921713,"is_pvip":false,"replies":[{"id":142828,"content":"你写错了吧……我只有 smart_ptr(smart_ptr&lt;U&gt;&amp;&amp;) 这样的函数，可没有 smart_ptr(const smart_ptr&lt;U&gt;&amp;&amp;)。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1723345351,"ip_address":"上海","comment_id":392845,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"我在测试文章中给出的代码时出现了这样的错误，请问老师是怎么回事\nn file included from 2.cpp:1:\n2.h: In instantiation of ‘smart_ptr&lt;T&gt;::smart_ptr(const smart_ptr&lt;U&gt;&amp;&amp;) [with U = shape; T = shape]’:\n2.cpp:27:12:   required from here\n2.h:80:24: error: assignment of member ‘smart_ptr&lt;shape&gt;::ptr_’ in read-only object\n   80 |             other.ptr_ = nullptr;\n      |             ~~~~~~~~~~~^~~~~~~~~\n2.h: In instantiation of ‘smart_ptr&lt;T&gt;::smart_ptr(const smart_ptr&lt;U&gt;&amp;&amp;) [with U = circle; T = circle]’:\n2.cpp:35:63:   required from here\n2.h:80:24: error: assignment of member ‘smart_ptr&lt;circle&gt;::ptr_’ in read-only object","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":649416,"discussion_content":"你写错了吧……我只有 smart_ptr(smart_ptr&lt;U&gt;&amp;&amp;) 这样的函数，可没有 smart_ptr(const smart_ptr&lt;U&gt;&amp;&amp;)。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1723345352,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":391095,"user_name":"复数","can_delete":false,"product_type":"c1","uid":1235194,"ip_address":"山西","ucode":"459FAA2E9D348F","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/fa/7e47dc06.jpg","comment_is_top":false,"comment_ctime":1717316509,"is_pvip":false,"replies":[{"id":142273,"content":"(1) 一家之言。swap 成员函数自己调起来很方便。也没有什么明显的缺点。\n\n(2) 对于面向对象的继承树的非叶子结点，通常拷贝构造函数应该声明为 protected，赋值函数甚至可以直接删除，防止别人用基类的引用来执行可能发生切片的动作。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1717648574,"ip_address":"上海","comment_id":391095,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"老师你好。\n我有两个问题\n（1）我看您的代码里给的swap函数是smartptr的单参数的成员函数。但是我看参考资料[1]里给的是双参数的friend void swap(dumb_array&amp; first, dumb_array&amp; second); 这里有什么讲究吗？我看这篇参考资料里还提到另一篇回答https:&#47;&#47;stackoverflow.com&#47;questions&#47;5695548&#47;public-friend-swap-member-function \n这篇回答里不建议使用单参数的swap成员。\n（2）我看参考资料[1]里还提到了可以复用默认构造函数再swap来实现移动构造函数。\n    &#47;&#47; move constructor\n    dumb_array(dumb_array&amp;&amp; other) noexcept ††\n        : dumb_array() &#47;&#47; initialize via default constructor, C++11 only\n    {\n        swap(*this, other);\n    }\n这种情况好像没法很好的兼容子类指针向基类指针的转换，有什么好方法吗？毕竟这种复用默认构造再swap的方式感觉挺优雅的。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":646260,"discussion_content":"(1) 一家之言。swap 成员函数自己调起来很方便。也没有什么明显的缺点。\n\n(2) 对于面向对象的继承树的非叶子结点，通常拷贝构造函数应该声明为 protected，赋值函数甚至可以直接删除，防止别人用基类的引用来执行可能发生切片的动作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1717648574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":389948,"user_name":"一念逍遥、","can_delete":false,"product_type":"c1","uid":1136890,"ip_address":"山东","ucode":"827A4447D70798","user_header":"https://static001.geekbang.org/account/avatar/00/11/58/fa/6f221fbc.jpg","comment_is_top":false,"comment_ctime":1713953651,"is_pvip":false,"replies":[{"id":141912,"content":"不会。smart_ptr(rhs) 会拷贝构造出一个新对象，然后才执行交换，不需要自检查。临时对象被释放时，delete 的资源是原先 this 的，而 this 得到了 rhs 的一个复本。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1714432548,"ip_address":"上海","comment_id":389948,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"老师您好。\nsmart_ptr(rhs).swap(*this);这句代码在this=&amp;rhs这种情况下，会出现内存泄露问题吧？因为临时对象在函数调用结束时，指向的内存区域就被释放了，但同时该区域的地址又赋给了另一个对象。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":643572,"discussion_content":"不会。smart_ptr(rhs) 会拷贝构造出一个新对象，然后才执行交换，不需要自检查。临时对象被释放时，delete 的资源是原先 this 的，而 this 得到了 rhs 的一个复本。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1714432548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":388843,"user_name":"Geek_7f372d","can_delete":false,"product_type":"c1","uid":3715138,"ip_address":"湖南","ucode":"57580354854328","user_header":"","comment_is_top":false,"comment_ctime":1711001982,"is_pvip":false,"replies":[{"id":141562,"content":"没有问题。rhs 在析构时自动释放了原先的引用计数（如果非空的话）。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1711419293,"ip_address":"上海","comment_id":388843,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"smart_ptr&amp; operator=(smart_ptr rhs) noexcept，这个赋值拷贝运算符重载函数虽然函数参数设置为值类型，当实参专为形参时回拷贝一次rhs增加rhs的饮用计数，但是函数实现里并没有减少此时this指针所指对象的引用计数，只是做了swap操作。这是否存在问题？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":640332,"discussion_content":"没有问题。rhs 在析构时自动释放了原先的引用计数（如果非空的话）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1711419293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":364520,"user_name":"Cafba","can_delete":false,"product_type":"c1","uid":3018755,"ip_address":"上海","ucode":"29BD3BD7143D41","user_header":"","comment_is_top":false,"comment_ctime":1671074252,"is_pvip":false,"replies":[{"id":132535,"content":"你说的根本没有发生……怎么可能又调用移动构造又调用拷贝构造？请仔细描述你观察到的现象和期待的结果。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1671193158,"ip_address":"上海","comment_id":364520,"utype":1}],"discussion_count":7,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"老师您好，为什么p2=p1调用了拷贝构造后还会调用移动构造？是因为p1左值调用拷贝构造生成临时变量，临时变量右值调用移动构造，之后才赋值吗？这样会不会效率低，调用了两次","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":596694,"discussion_content":"你说的根本没有发生……怎么可能又调用移动构造又调用拷贝构造？请仔细描述你观察到的现象和期待的结果。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1671193158,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":6,"child_discussions":[{"author":{"id":3018755,"avatar":"","nickname":"Cafba","note":"","ucode":"29BD3BD7143D41","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":596766,"discussion_content":"我自己试是这样的\n在这讲的测试用例里在p2=p1处打断点调试，先调用泛型的拷贝构造之后调用泛型的移动构造\n但如果再加上非泛型的移动构造，就只会调用泛型的拷贝构造","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1671205961,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":596694,"ip_address":"甘肃","group_id":0},"score":596766,"extra":""},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":3018755,"avatar":"","nickname":"Cafba","note":"","ucode":"29BD3BD7143D41","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":597022,"discussion_content":"哈，这个意思啊。\n\n第一个“拷贝构造”不是真正的拷贝构造函数，最好看成普通的构造函数，通过 circle 智能指针构造出 shape 的智能指针，两者类型不同。然后拿这个右值智能指针去调用 smart_ptr::operator=(smart_ptr)，自然就可以调用移动构造函数了。\n\nsmart_ptr&lt;shape&gt;::operator(smart_ptr) 要求参数是 smart_ptr&lt;shape&gt;，因此编译器会寻找一个可行的转换。那个泛型的“拷贝”构造函数实际是一个转换构造函数。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1671364978,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":596766,"ip_address":"上海","group_id":0},"score":597022,"extra":""},{"author":{"id":3018755,"avatar":"","nickname":"Cafba","note":"","ucode":"29BD3BD7143D41","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":597032,"discussion_content":"谢谢老师的解答，就是类型不同之间肯定会调用拷贝构造并调用移动构造，那提不提供非泛型的移动构造是不是没有好坏之分？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1671374823,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":597022,"ip_address":"甘肃","group_id":0},"score":597032,"extra":""}]}]},{"had_liked":false,"id":360395,"user_name":"zero","can_delete":false,"product_type":"c1","uid":1619178,"ip_address":"上海","ucode":"ACF20F9BE5B69C","user_header":"https://static001.geekbang.org/account/avatar/00/18/b4/ea/98e4b16b.jpg","comment_is_top":false,"comment_ctime":1666536968,"is_pvip":false,"replies":[{"id":131316,"content":"确实没有提供严格的特殊非静态成员函数形式的移动构造函数。模板形式的 smart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other) 就足够了。跟拷贝构造函数不同，移动构造函数不会默认提供，因此编译器在没有找到特殊形式的移动构造函数时，会在需要移动构造时使用上面的这个函数模板。\n\n但要注意上面这个不是万能引用（转发引用），而是右值引用。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1667056483,"ip_address":"上海","comment_id":360395,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"怎么shared_ptr感觉没有提供移动构造函数？ 因为“模板参数smart_ptr&lt;U&lt;&amp;&amp;是万能引用，既可以引用左值，又可以引用右值”","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":596694,"discussion_content":"你说的根本没有发生……怎么可能又调用移动构造又调用拷贝构造？请仔细描述你观察到的现象和期待的结果。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1671193158,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":6,"child_discussions":[{"author":{"id":3018755,"avatar":"","nickname":"Cafba","note":"","ucode":"29BD3BD7143D41","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":596766,"discussion_content":"我自己试是这样的\n在这讲的测试用例里在p2=p1处打断点调试，先调用泛型的拷贝构造之后调用泛型的移动构造\n但如果再加上非泛型的移动构造，就只会调用泛型的拷贝构造","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1671205961,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":596694,"ip_address":"甘肃","group_id":0},"score":596766,"extra":""},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":3018755,"avatar":"","nickname":"Cafba","note":"","ucode":"29BD3BD7143D41","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":597022,"discussion_content":"哈，这个意思啊。\n\n第一个“拷贝构造”不是真正的拷贝构造函数，最好看成普通的构造函数，通过 circle 智能指针构造出 shape 的智能指针，两者类型不同。然后拿这个右值智能指针去调用 smart_ptr::operator=(smart_ptr)，自然就可以调用移动构造函数了。\n\nsmart_ptr&lt;shape&gt;::operator(smart_ptr) 要求参数是 smart_ptr&lt;shape&gt;，因此编译器会寻找一个可行的转换。那个泛型的“拷贝”构造函数实际是一个转换构造函数。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1671364978,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":596766,"ip_address":"上海","group_id":0},"score":597022,"extra":""},{"author":{"id":3018755,"avatar":"","nickname":"Cafba","note":"","ucode":"29BD3BD7143D41","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":597032,"discussion_content":"谢谢老师的解答，就是类型不同之间肯定会调用拷贝构造并调用移动构造，那提不提供非泛型的移动构造是不是没有好坏之分？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1671374823,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":597022,"ip_address":"甘肃","group_id":0},"score":597032,"extra":""}]}]},{"had_liked":false,"id":357996,"user_name":"赵丽小人儿","can_delete":false,"product_type":"c1","uid":1326753,"ip_address":"上海","ucode":"467C89A1181DF5","user_header":"https://static001.geekbang.org/account/avatar/00/14/3e/a1/b58baa6d.jpg","comment_is_top":false,"comment_ctime":1663823853,"is_pvip":false,"replies":[{"id":130354,"content":"搞通了后面就轻松了。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1664032159,"ip_address":"上海","comment_id":357996,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"看的挺吃力的，感觉自己不会c++了","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592069,"discussion_content":"确实没有提供严格的特殊非静态成员函数形式的移动构造函数。模板形式的 smart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other) 就足够了。跟拷贝构造函数不同，移动构造函数不会默认提供，因此编译器在没有找到特殊形式的移动构造函数时，会在需要移动构造时使用上面的这个函数模板。\n\n但要注意上面这个不是万能引用（转发引用），而是右值引用。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1667056483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":357444,"user_name":"wd_8277","can_delete":false,"product_type":"c1","uid":2496848,"ip_address":"上海","ucode":"0824A12B5C8BCA","user_header":"","comment_is_top":false,"comment_ctime":1663256477,"is_pvip":false,"replies":[{"id":130161,"content":"不是。\n\n拿 https:&#47;&#47;github.com&#47;adah1972&#47;geek_time_cpp&#47;tree&#47;master&#47;common 下的版本进行测试，我没发现有这个问题。测试代码如下：\n\n#include &lt;iostream&gt;\n#include &quot;shape.h&quot;\n#include &quot;smart_ptr.h&quot;\n\nint main()\n{\n    smart_ptr&lt;circle&gt; ptr1(new circle());\n    smart_ptr&lt;circle&gt; ptr2;\n    ptr2 = ptr1;\n    std::cout &lt;&lt; ptr2.use_count() &lt;&lt; std::endl;\n}\n\n如果代码是你手敲的，像是漏了非模板形式的拷贝构造函数。少了就会出现你描述的结果。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1663477850,"ip_address":"上海","comment_id":357444,"utype":1}],"discussion_count":2,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"老师好，我发现因为\tsmart_ptr&lt;circle&gt; ptr1(new circle());\n\tsmart_ptr&lt;circle&gt; ptr2;  \n\tptr2 = ptr1;  和 smart_ptr&lt;circle&gt; ptr1(new circle());\n\tsmart_ptr&lt;shape&gt; ptr2;  \n\tptr2 = ptr1;结果是不一样的，前者会进入拷贝构造，计数不会加1，后者会强转，计数加1，STL的行为是两者都会加1。这是有意而为之吗？\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588735,"discussion_content":"搞通了后面就轻松了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664032159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347686,"user_name":"Cafba","can_delete":false,"product_type":"c1","uid":3018755,"ip_address":"","ucode":"29BD3BD7143D41","user_header":"","comment_is_top":false,"comment_ctime":1654312690,"is_pvip":false,"replies":[{"id":126776,"content":"传统的做法是手工检查、删除旧对象和移入新内容。我用的是拷贝加交换的惯用法。文中已经明确写了：\n\n“上面代码里的这种惯用法（见参考资料 [1]）则保证了强异常安全性：赋值分为拷贝构造和交换两步，异常只可能在第一步发生；而第一步如果发生异常的话，this 对象完全不受任何影响。无论拷贝构造成功与否，结果只有赋值成功和赋值没有效果两种状态，而不会发生因为赋值破坏了当前对象这种场景。”\n\n这是一种实现赋值运算符的简单方法，用一个函数来同时实现拷贝赋值和移动赋值，还不用自己去写具体的逻辑。当然，从性能上来讲，它可能不是最优的。如果你需要赋值的性能很高，可能要额外进行优化。但这种写法至少是种很好的默认做法：简单。应该很少程序瓶颈会出现在赋值操作上。\n\n当然，对于实现底层基础库的人来说，经常还是需要斤斤计较的。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1654425735,"ip_address":"","comment_id":347686,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"老师，请教一下，我在More effective看到的实现里有赋值前删除当前指针的操作，而你写的的是不是只是交换了当前指针，这样做的目的是什么呢\n\ntemplate&lt;class T&gt;&#47;&#47; assignment operator \nauto_ptr&lt;T&gt;&amp; auto_ptr&lt;T&gt;::operator=(auto_ptr&lt;T&gt;&amp; rhs) {\n\tif(this == &amp;rhs) return *this;&#47;&#47;如果自己赋值给自己，不做任何事情\n\tdelete pointee;&#47;&#47;删除目前拥有之物。 \n\tpointee = rhs.pointee;&#47;&#47;将＊pointee 的拥有权移转给＊this。 \n\trhs.pointee = 0;&#47;&#47;rhs 不再拥有任何东西。 \n\treturn * this;\n}","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588031,"discussion_content":"不是。\n\n拿 https://github.com/adah1972/geek_time_cpp/tree/master/common 下的版本进行测试，我没发现有这个问题。测试代码如下：\n\n#include &lt;iostream&gt;\n#include &#34;shape.h&#34;\n#include &#34;smart_ptr.h&#34;\n\nint main()\n{\n    smart_ptr&lt;circle&gt; ptr1(new circle());\n    smart_ptr&lt;circle&gt; ptr2;\n    ptr2 = ptr1;\n    std::cout &lt;&lt; ptr2.use_count() &lt;&lt; std::endl;\n}\n\n如果代码是你手敲的，像是漏了非模板形式的拷贝构造函数。少了就会出现你描述的结果。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1663477850,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2496848,"avatar":"","nickname":"wd_8277","note":"","ucode":"0824A12B5C8BCA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588035,"discussion_content":"确实是漏了非模板形式的拷贝构造🤣谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663482211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":393523,"user_name":"Mattrach","can_delete":false,"product_type":"c1","uid":3948439,"ip_address":"福建","ucode":"D530826D02FA1E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI0icYqvY68m60U2qJn7iabqSD4OUvYx2OeiaXA4IqhDia1VNMm3bTGCUaU5J3jbIU1clqCRiap1BubL7g/132","comment_is_top":false,"comment_ctime":1724123363,"is_pvip":false,"replies":[{"id":142931,"content":"1. 第一种形式是一般说的拷贝构造函数；模板形式的构造函数不被看作拷贝构造函数，因此不能替代拷贝构造函数——不提供的话，编译器将会默认提供一个（错误的）版本。其余问题的回答都是是的。\n\n2. 用了 14 标准？如果用 17 标准的话，应该只有拷贝构造而没有移动构造。C++17 有“拷贝消除”，可以优化掉不必要的拷贝或移动。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1724335731,"ip_address":"上海","comment_id":393523,"utype":1}],"discussion_count":4,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"老师你好，有几点疑问想请教一下：\n1、两种拷贝构造smart_ptr(const smart_ptr&amp; other)和smart_ptr(const smart_ptr&lt;U&gt;&amp; other)只是为了解决不同类型模板参数之间的转化吗？比如smart_ptr&lt;circle&gt;到smart_ptr&lt;shape&gt;？这个类型转换的成功与否是在于底层的指针能够相互转换吗？比如smart_ptr&lt;circle&gt;和smart_ptr&lt;triangle&gt;之间无法相互转换是因为circle和triangle本身就无法相互转换？\n2、我在“引用计数”一节测试代码的构造函数中，添加了打印，当执行到ptr2 = ptr1;语句时，执行结果如下：\n```\nuse cout of ptr2 was 0\n模板拷贝构造\n模板移动构造\n拷贝赋值\nuse count of ptr2 is now 2\n```\n请问这个过程中为什么会调用模板移动构造？\n感谢老师解答！","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":650080,"discussion_content":"1. 第一种形式是一般说的拷贝构造函数；模板形式的构造函数不被看作拷贝构造函数，因此不能替代拷贝构造函数——不提供的话，编译器将会默认提供一个（错误的）版本。其余问题的回答都是是的。\n\n2. 用了 14 标准？如果用 17 标准的话，应该只有拷贝构造而没有移动构造。C++17 有“拷贝消除”，可以优化掉不必要的拷贝或移动。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1724335732,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":1,"child_discussions":[{"author":{"id":3948439,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI0icYqvY68m60U2qJn7iabqSD4OUvYx2OeiaXA4IqhDia1VNMm3bTGCUaU5J3jbIU1clqCRiap1BubL7g/132","nickname":"Mattrach","note":"","ucode":"D530826D02FA1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":650174,"discussion_content":"明白了，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1724501140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":650080,"ip_address":"福建","group_id":0},"score":650174,"extra":""}]},{"author":{"id":3948439,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI0icYqvY68m60U2qJn7iabqSD4OUvYx2OeiaXA4IqhDia1VNMm3bTGCUaU5J3jbIU1clqCRiap1BubL7g/132","nickname":"Mattrach","note":"","ucode":"D530826D02FA1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":649916,"discussion_content":"编译器使用g++，指定--std=c++11时出现“模板移动构造”，但指定--std=c++17时，不会出现“模板移动构造”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1724141574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"福建","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":3948439,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI0icYqvY68m60U2qJn7iabqSD4OUvYx2OeiaXA4IqhDia1VNMm3bTGCUaU5J3jbIU1clqCRiap1BubL7g/132","nickname":"Mattrach","note":"","ucode":"D530826D02FA1E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":650114,"discussion_content":"嗯，符合预期。搜索“拷贝消除”“copy elision”。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1724381371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":649916,"ip_address":"上海","group_id":0},"score":650114,"extra":""}]}]},{"had_liked":false,"id":392845,"user_name":"Tiger","can_delete":false,"product_type":"c1","uid":1903781,"ip_address":"重庆","ucode":"BFD74BFE539A8A","user_header":"https://static001.geekbang.org/account/avatar/00/1d/0c/a5/0bbfd5e7.jpg","comment_is_top":false,"comment_ctime":1721921713,"is_pvip":false,"replies":[{"id":142828,"content":"你写错了吧……我只有 smart_ptr(smart_ptr&lt;U&gt;&amp;&amp;) 这样的函数，可没有 smart_ptr(const smart_ptr&lt;U&gt;&amp;&amp;)。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1723345351,"ip_address":"上海","comment_id":392845,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"我在测试文章中给出的代码时出现了这样的错误，请问老师是怎么回事\nn file included from 2.cpp:1:\n2.h: In instantiation of ‘smart_ptr&lt;T&gt;::smart_ptr(const smart_ptr&lt;U&gt;&amp;&amp;) [with U = shape; T = shape]’:\n2.cpp:27:12:   required from here\n2.h:80:24: error: assignment of member ‘smart_ptr&lt;shape&gt;::ptr_’ in read-only object\n   80 |             other.ptr_ = nullptr;\n      |             ~~~~~~~~~~~^~~~~~~~~\n2.h: In instantiation of ‘smart_ptr&lt;T&gt;::smart_ptr(const smart_ptr&lt;U&gt;&amp;&amp;) [with U = circle; T = circle]’:\n2.cpp:35:63:   required from here\n2.h:80:24: error: assignment of member ‘smart_ptr&lt;circle&gt;::ptr_’ in read-only object","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":650080,"discussion_content":"1. 第一种形式是一般说的拷贝构造函数；模板形式的构造函数不被看作拷贝构造函数，因此不能替代拷贝构造函数——不提供的话，编译器将会默认提供一个（错误的）版本。其余问题的回答都是是的。\n\n2. 用了 14 标准？如果用 17 标准的话，应该只有拷贝构造而没有移动构造。C++17 有“拷贝消除”，可以优化掉不必要的拷贝或移动。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1724335732,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":1,"child_discussions":[{"author":{"id":3948439,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI0icYqvY68m60U2qJn7iabqSD4OUvYx2OeiaXA4IqhDia1VNMm3bTGCUaU5J3jbIU1clqCRiap1BubL7g/132","nickname":"Mattrach","note":"","ucode":"D530826D02FA1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":650174,"discussion_content":"明白了，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1724501140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":650080,"ip_address":"福建","group_id":0},"score":650174,"extra":""}]},{"author":{"id":3948439,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI0icYqvY68m60U2qJn7iabqSD4OUvYx2OeiaXA4IqhDia1VNMm3bTGCUaU5J3jbIU1clqCRiap1BubL7g/132","nickname":"Mattrach","note":"","ucode":"D530826D02FA1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":649916,"discussion_content":"编译器使用g++，指定--std=c++11时出现“模板移动构造”，但指定--std=c++17时，不会出现“模板移动构造”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1724141574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"福建","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":3948439,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI0icYqvY68m60U2qJn7iabqSD4OUvYx2OeiaXA4IqhDia1VNMm3bTGCUaU5J3jbIU1clqCRiap1BubL7g/132","nickname":"Mattrach","note":"","ucode":"D530826D02FA1E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":650114,"discussion_content":"嗯，符合预期。搜索“拷贝消除”“copy elision”。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1724381371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":649916,"ip_address":"上海","group_id":0},"score":650114,"extra":""}]}]},{"had_liked":false,"id":391095,"user_name":"复数","can_delete":false,"product_type":"c1","uid":1235194,"ip_address":"山西","ucode":"459FAA2E9D348F","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/fa/7e47dc06.jpg","comment_is_top":false,"comment_ctime":1717316509,"is_pvip":false,"replies":[{"id":142273,"content":"(1) 一家之言。swap 成员函数自己调起来很方便。也没有什么明显的缺点。\n\n(2) 对于面向对象的继承树的非叶子结点，通常拷贝构造函数应该声明为 protected，赋值函数甚至可以直接删除，防止别人用基类的引用来执行可能发生切片的动作。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1717648574,"ip_address":"上海","comment_id":391095,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"老师你好。\n我有两个问题\n（1）我看您的代码里给的swap函数是smartptr的单参数的成员函数。但是我看参考资料[1]里给的是双参数的friend void swap(dumb_array&amp; first, dumb_array&amp; second); 这里有什么讲究吗？我看这篇参考资料里还提到另一篇回答https:&#47;&#47;stackoverflow.com&#47;questions&#47;5695548&#47;public-friend-swap-member-function \n这篇回答里不建议使用单参数的swap成员。\n（2）我看参考资料[1]里还提到了可以复用默认构造函数再swap来实现移动构造函数。\n    &#47;&#47; move constructor\n    dumb_array(dumb_array&amp;&amp; other) noexcept ††\n        : dumb_array() &#47;&#47; initialize via default constructor, C++11 only\n    {\n        swap(*this, other);\n    }\n这种情况好像没法很好的兼容子类指针向基类指针的转换，有什么好方法吗？毕竟这种复用默认构造再swap的方式感觉挺优雅的。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":649416,"discussion_content":"你写错了吧……我只有 smart_ptr(smart_ptr&lt;U&gt;&amp;&amp;) 这样的函数，可没有 smart_ptr(const smart_ptr&lt;U&gt;&amp;&amp;)。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1723345352,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":389948,"user_name":"一念逍遥、","can_delete":false,"product_type":"c1","uid":1136890,"ip_address":"山东","ucode":"827A4447D70798","user_header":"https://static001.geekbang.org/account/avatar/00/11/58/fa/6f221fbc.jpg","comment_is_top":false,"comment_ctime":1713953651,"is_pvip":false,"replies":[{"id":141912,"content":"不会。smart_ptr(rhs) 会拷贝构造出一个新对象，然后才执行交换，不需要自检查。临时对象被释放时，delete 的资源是原先 this 的，而 this 得到了 rhs 的一个复本。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1714432548,"ip_address":"上海","comment_id":389948,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"老师您好。\nsmart_ptr(rhs).swap(*this);这句代码在this=&amp;rhs这种情况下，会出现内存泄露问题吧？因为临时对象在函数调用结束时，指向的内存区域就被释放了，但同时该区域的地址又赋给了另一个对象。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":646260,"discussion_content":"(1) 一家之言。swap 成员函数自己调起来很方便。也没有什么明显的缺点。\n\n(2) 对于面向对象的继承树的非叶子结点，通常拷贝构造函数应该声明为 protected，赋值函数甚至可以直接删除，防止别人用基类的引用来执行可能发生切片的动作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1717648574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":388843,"user_name":"Geek_7f372d","can_delete":false,"product_type":"c1","uid":3715138,"ip_address":"湖南","ucode":"57580354854328","user_header":"","comment_is_top":false,"comment_ctime":1711001982,"is_pvip":false,"replies":[{"id":141562,"content":"没有问题。rhs 在析构时自动释放了原先的引用计数（如果非空的话）。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1711419293,"ip_address":"上海","comment_id":388843,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"smart_ptr&amp; operator=(smart_ptr rhs) noexcept，这个赋值拷贝运算符重载函数虽然函数参数设置为值类型，当实参专为形参时回拷贝一次rhs增加rhs的饮用计数，但是函数实现里并没有减少此时this指针所指对象的引用计数，只是做了swap操作。这是否存在问题？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":643572,"discussion_content":"不会。smart_ptr(rhs) 会拷贝构造出一个新对象，然后才执行交换，不需要自检查。临时对象被释放时，delete 的资源是原先 this 的，而 this 得到了 rhs 的一个复本。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1714432548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":364520,"user_name":"Cafba","can_delete":false,"product_type":"c1","uid":3018755,"ip_address":"上海","ucode":"29BD3BD7143D41","user_header":"","comment_is_top":false,"comment_ctime":1671074252,"is_pvip":false,"replies":[{"id":132535,"content":"你说的根本没有发生……怎么可能又调用移动构造又调用拷贝构造？请仔细描述你观察到的现象和期待的结果。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1671193158,"ip_address":"上海","comment_id":364520,"utype":1}],"discussion_count":7,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"老师您好，为什么p2=p1调用了拷贝构造后还会调用移动构造？是因为p1左值调用拷贝构造生成临时变量，临时变量右值调用移动构造，之后才赋值吗？这样会不会效率低，调用了两次","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":640332,"discussion_content":"没有问题。rhs 在析构时自动释放了原先的引用计数（如果非空的话）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1711419293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360395,"user_name":"zero","can_delete":false,"product_type":"c1","uid":1619178,"ip_address":"上海","ucode":"ACF20F9BE5B69C","user_header":"https://static001.geekbang.org/account/avatar/00/18/b4/ea/98e4b16b.jpg","comment_is_top":false,"comment_ctime":1666536968,"is_pvip":false,"replies":[{"id":131316,"content":"确实没有提供严格的特殊非静态成员函数形式的移动构造函数。模板形式的 smart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other) 就足够了。跟拷贝构造函数不同，移动构造函数不会默认提供，因此编译器在没有找到特殊形式的移动构造函数时，会在需要移动构造时使用上面的这个函数模板。\n\n但要注意上面这个不是万能引用（转发引用），而是右值引用。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1667056483,"ip_address":"上海","comment_id":360395,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"怎么shared_ptr感觉没有提供移动构造函数？ 因为“模板参数smart_ptr&lt;U&lt;&amp;&amp;是万能引用，既可以引用左值，又可以引用右值”","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592069,"discussion_content":"确实没有提供严格的特殊非静态成员函数形式的移动构造函数。模板形式的 smart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other) 就足够了。跟拷贝构造函数不同，移动构造函数不会默认提供，因此编译器在没有找到特殊形式的移动构造函数时，会在需要移动构造时使用上面的这个函数模板。\n\n但要注意上面这个不是万能引用（转发引用），而是右值引用。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1667056483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":357996,"user_name":"赵丽小人儿","can_delete":false,"product_type":"c1","uid":1326753,"ip_address":"上海","ucode":"467C89A1181DF5","user_header":"https://static001.geekbang.org/account/avatar/00/14/3e/a1/b58baa6d.jpg","comment_is_top":false,"comment_ctime":1663823853,"is_pvip":false,"replies":[{"id":130354,"content":"搞通了后面就轻松了。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1664032159,"ip_address":"上海","comment_id":357996,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"看的挺吃力的，感觉自己不会c++了","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588735,"discussion_content":"搞通了后面就轻松了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664032159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":357444,"user_name":"wd_8277","can_delete":false,"product_type":"c1","uid":2496848,"ip_address":"上海","ucode":"0824A12B5C8BCA","user_header":"","comment_is_top":false,"comment_ctime":1663256477,"is_pvip":false,"replies":[{"id":130161,"content":"不是。\n\n拿 https:&#47;&#47;github.com&#47;adah1972&#47;geek_time_cpp&#47;tree&#47;master&#47;common 下的版本进行测试，我没发现有这个问题。测试代码如下：\n\n#include &lt;iostream&gt;\n#include &quot;shape.h&quot;\n#include &quot;smart_ptr.h&quot;\n\nint main()\n{\n    smart_ptr&lt;circle&gt; ptr1(new circle());\n    smart_ptr&lt;circle&gt; ptr2;\n    ptr2 = ptr1;\n    std::cout &lt;&lt; ptr2.use_count() &lt;&lt; std::endl;\n}\n\n如果代码是你手敲的，像是漏了非模板形式的拷贝构造函数。少了就会出现你描述的结果。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1663477850,"ip_address":"上海","comment_id":357444,"utype":1}],"discussion_count":2,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"老师好，我发现因为\tsmart_ptr&lt;circle&gt; ptr1(new circle());\n\tsmart_ptr&lt;circle&gt; ptr2;  \n\tptr2 = ptr1;  和 smart_ptr&lt;circle&gt; ptr1(new circle());\n\tsmart_ptr&lt;shape&gt; ptr2;  \n\tptr2 = ptr1;结果是不一样的，前者会进入拷贝构造，计数不会加1，后者会强转，计数加1，STL的行为是两者都会加1。这是有意而为之吗？\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588031,"discussion_content":"不是。\n\n拿 https://github.com/adah1972/geek_time_cpp/tree/master/common 下的版本进行测试，我没发现有这个问题。测试代码如下：\n\n#include &lt;iostream&gt;\n#include &#34;shape.h&#34;\n#include &#34;smart_ptr.h&#34;\n\nint main()\n{\n    smart_ptr&lt;circle&gt; ptr1(new circle());\n    smart_ptr&lt;circle&gt; ptr2;\n    ptr2 = ptr1;\n    std::cout &lt;&lt; ptr2.use_count() &lt;&lt; std::endl;\n}\n\n如果代码是你手敲的，像是漏了非模板形式的拷贝构造函数。少了就会出现你描述的结果。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1663477850,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2496848,"avatar":"","nickname":"wd_8277","note":"","ucode":"0824A12B5C8BCA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588035,"discussion_content":"确实是漏了非模板形式的拷贝构造🤣谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663482211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347686,"user_name":"Cafba","can_delete":false,"product_type":"c1","uid":3018755,"ip_address":"","ucode":"29BD3BD7143D41","user_header":"","comment_is_top":false,"comment_ctime":1654312690,"is_pvip":false,"replies":[{"id":126776,"content":"传统的做法是手工检查、删除旧对象和移入新内容。我用的是拷贝加交换的惯用法。文中已经明确写了：\n\n“上面代码里的这种惯用法（见参考资料 [1]）则保证了强异常安全性：赋值分为拷贝构造和交换两步，异常只可能在第一步发生；而第一步如果发生异常的话，this 对象完全不受任何影响。无论拷贝构造成功与否，结果只有赋值成功和赋值没有效果两种状态，而不会发生因为赋值破坏了当前对象这种场景。”\n\n这是一种实现赋值运算符的简单方法，用一个函数来同时实现拷贝赋值和移动赋值，还不用自己去写具体的逻辑。当然，从性能上来讲，它可能不是最优的。如果你需要赋值的性能很高，可能要额外进行优化。但这种写法至少是种很好的默认做法：简单。应该很少程序瓶颈会出现在赋值操作上。\n\n当然，对于实现底层基础库的人来说，经常还是需要斤斤计较的。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1654425735,"ip_address":"","comment_id":347686,"utype":1}],"discussion_count":1,"race_medal":0,"score":8,"product_id":100040501,"comment_content":"老师，请教一下，我在More effective看到的实现里有赋值前删除当前指针的操作，而你写的的是不是只是交换了当前指针，这样做的目的是什么呢\n\ntemplate&lt;class T&gt;&#47;&#47; assignment operator \nauto_ptr&lt;T&gt;&amp; auto_ptr&lt;T&gt;::operator=(auto_ptr&lt;T&gt;&amp; rhs) {\n\tif(this == &amp;rhs) return *this;&#47;&#47;如果自己赋值给自己，不做任何事情\n\tdelete pointee;&#47;&#47;删除目前拥有之物。 \n\tpointee = rhs.pointee;&#47;&#47;将＊pointee 的拥有权移转给＊this。 \n\trhs.pointee = 0;&#47;&#47;rhs 不再拥有任何东西。 \n\treturn * this;\n}","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574897,"discussion_content":"传统的做法是手工检查、删除旧对象和移入新内容。我用的是拷贝加交换的惯用法。文中已经明确写了：\n\n“上面代码里的这种惯用法（见参考资料 [1]）则保证了强异常安全性：赋值分为拷贝构造和交换两步，异常只可能在第一步发生；而第一步如果发生异常的话，this 对象完全不受任何影响。无论拷贝构造成功与否，结果只有赋值成功和赋值没有效果两种状态，而不会发生因为赋值破坏了当前对象这种场景。”\n\n这是一种实现赋值运算符的简单方法，用一个函数来同时实现拷贝赋值和移动赋值，还不用自己去写具体的逻辑。当然，从性能上来讲，它可能不是最优的。如果你需要赋值的性能很高，可能要额外进行优化。但这种写法至少是种很好的默认做法：简单。应该很少程序瓶颈会出现在赋值操作上。\n\n当然，对于实现底层基础库的人来说，经常还是需要斤斤计较的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1654425735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345113,"user_name":"Max(Deguang)","can_delete":false,"product_type":"c1","uid":2348999,"ip_address":"","ucode":"17198F2824D2CB","user_header":"https://static001.geekbang.org/account/avatar/00/23/d7/c7/f3e783e8.jpg","comment_is_top":false,"comment_ctime":1652057529,"is_pvip":false,"replies":[{"id":126076,"content":"你说的语句我没看到走移动构造函数。不过，它也确实不该走赋值运算符。你需要去复习一下这方面的知识。Obj obj = … 是一个构造；obj = … 才是赋值。\n\n简单打印当前函数的展开形式可以用编译器的宏：GCC&#47;Clang 下用 __PRETTY_FUNCTION__，MSVC 下用 __FUNCSIG__。就是想打印某个类型的话，参考第 24 讲的 Boost.TypeIndex。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1652246548,"ip_address":"","comment_id":345113,"utype":1}],"discussion_count":1,"race_medal":1,"score":9,"product_id":100040501,"comment_content":"感觉好难呀，花了三天时间，还有部分没有明白。老师，请问一下\n执行下面的语句的时候，我发现 执行了两次move constructor。这点不是很明白，不应该执行operator=（）吗？ \nsmart_ptr&lt;circle&gt; ptr3 = dynamic_pointer_cast&lt;circle&gt;(ptr2);\n\n另外，有什么好的办法打印出执行时的template name（T／U）吗？","like_count":0},{"had_liked":false,"id":344370,"user_name":"Im me","can_delete":false,"product_type":"c1","uid":1792714,"ip_address":"","ucode":"FF7DEED4BB4C37","user_header":"https://static001.geekbang.org/account/avatar/00/1b/5a/ca/4d5d23d1.jpg","comment_is_top":false,"comment_ctime":1651494842,"is_pvip":false,"replies":[{"id":125849,"content":"l = r;\n\n如果直接交换，r 就得到 l 之前的值了。这可不是我们想要的。我们希望的是 l 得到 r 的值，但 r 不动。\n\n在赋值运算符里的 swap 语句执行结束后，这个临时对象将会被析构。由于它已经跟 *this 交换，析构的只是 *this 的旧值而已。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1651812834,"ip_address":"","comment_id":344370,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100040501,"comment_content":"哪位同学能帮忙解释下文中 拷贝转移所有权代码\nsmart_ptr&amp; operator=(smart_ptr&amp; rhs) \n {    \n    smart_ptr(rhs).swap(*this); \n   return *this;\n  }\n到底为什么非要用一个临时对象啊，为什么不能直接rhs.swap(*this)；我看大家都没有提到这里，应该是就我自己犯迷糊了，求解答","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571500,"discussion_content":"你说的语句我没看到走移动构造函数。不过，它也确实不该走赋值运算符。你需要去复习一下这方面的知识。Obj obj = … 是一个构造；obj = … 才是赋值。\n\n简单打印当前函数的展开形式可以用编译器的宏：GCC/Clang 下用 __PRETTY_FUNCTION__，MSVC 下用 __FUNCSIG__。就是想打印某个类型的话，参考第 24 讲的 Boost.TypeIndex。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652246548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344369,"user_name":"Im me","can_delete":false,"product_type":"c1","uid":1792714,"ip_address":"","ucode":"FF7DEED4BB4C37","user_header":"https://static001.geekbang.org/account/avatar/00/1b/5a/ca/4d5d23d1.jpg","comment_is_top":false,"comment_ctime":1651494274,"is_pvip":false,"replies":[{"id":125848,"content":"可以先往后看。看不懂的回过头再看一遍。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1651812587,"ip_address":"","comment_id":344369,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100040501,"comment_content":"这一节看了3个小时还没看懂，基础有点差","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570549,"discussion_content":"l = r;\n\n如果直接交换，r 就得到 l 之前的值了。这可不是我们想要的。我们希望的是 l 得到 r 的值，但 r 不动。\n\n在赋值运算符里的 swap 语句执行结束后，这个临时对象将会被析构。由于它已经跟 *this 交换，析构的只是 *this 的旧值而已。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1651812834,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343763,"user_name":"Kiddy","can_delete":false,"product_type":"c1","uid":2055993,"ip_address":"","ucode":"D07AAEE69BE504","user_header":"https://static001.geekbang.org/account/avatar/00/1f/5f/39/8d2c61d3.jpg","comment_is_top":false,"comment_ctime":1651043841,"is_pvip":false,"replies":[{"id":125592,"content":"我仔细测了一下，完全没有看到移动构造函数的调用。\n\n你如果确定有的话，把完整的测试程序贴出来看看。可以贴到 godbolt.org 上，然后生成短链接发我。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1651150257,"ip_address":"","comment_id":343763,"utype":1}],"discussion_count":8,"race_medal":0,"score":9,"product_id":100040501,"comment_content":"老师，我用gdb跟了下，发现执行ptr1 = ptr2这行代码时，会先执行拷贝构造函数，然后执行移动构造函数，最后执行operator=。  我有个疑问，为啥会执行移动构造函数呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570548,"discussion_content":"可以先往后看。看不懂的回过头再看一遍。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651812587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342758,"user_name":"弘","can_delete":false,"product_type":"c1","uid":2754894,"ip_address":"","ucode":"6B91D47FDCCACA","user_header":"https://static001.geekbang.org/account/avatar/00/2a/09/4e/f5993c4e.jpg","comment_is_top":false,"comment_ctime":1650448334,"is_pvip":false,"replies":[{"id":125258,"content":"不太明白你的意思，不过，这些代码都是可运行的：\n\nhttps:&#47;&#47;github.com&#47;adah1972&#47;geek_time_cpp&#47;","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1650547504,"ip_address":"","comment_id":342758,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100040501,"comment_content":"move constructor的时候，shared_count_=nullptr, 这个析构函数会发生异常把\n\n\t","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":565825,"discussion_content":"不太明白你的意思，不过，这些代码都是可运行的：\n\nhttps://github.com/adah1972/geek_time_cpp/","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650547504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342125,"user_name":"硕","can_delete":false,"product_type":"c1","uid":2540708,"ip_address":"","ucode":"1F68B408F4BBED","user_header":"https://static001.geekbang.org/account/avatar/00/26/c4/a4/20f44910.jpg","comment_is_top":false,"comment_ctime":1650022903,"is_pvip":false,"replies":[{"id":125053,"content":"不需要。细节后面会讲（第9讲）：\n\n用户如果没有自己声明拷贝构造函数、拷贝赋值函数、移动赋值函数和析构函数，编译器会隐式声明一个移动构造函数。\n\n我们定义了拷贝构造函数，编译器就不会自动生成移动构造函数了。需要移动构造时，我们的模板移动构造函数就会被使用了。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1650173956,"ip_address":"","comment_id":342125,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100040501,"comment_content":"代码列表中，是不是少了一个普通版本的移动构造函数？\n\nsmart_ptr(smart_ptr &amp;&amp;other) noexcept\n{\n    ptr_ = other.ptr_;\n    if (ptr_) {\n        shared_count_ = other.shared_count_;\n        other.ptr_ = nullptr;\n    }\n}","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":564164,"discussion_content":"不需要。细节后面会讲（第9讲）：\n\n用户如果没有自己声明拷贝构造函数、拷贝赋值函数、移动赋值函数和析构函数，编译器会隐式声明一个移动构造函数。\n\n我们定义了拷贝构造函数，编译器就不会自动生成移动构造函数了。需要移动构造时，我们的模板移动构造函数就会被使用了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1650173956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339671,"user_name":"硕","can_delete":false,"product_type":"c1","uid":2540708,"ip_address":"","ucode":"1F68B408F4BBED","user_header":"https://static001.geekbang.org/account/avatar/00/26/c4/a4/20f44910.jpg","comment_is_top":false,"comment_ctime":1648285162,"is_pvip":false,"replies":[{"id":124387,"content":"普通的指针有四种强制类型转换，static_cast、reinterpret_cast 等（不熟悉的话，请自行搜索）。这些操作不能直接作用于智能指针上。要让智能指针也支持类似的操作，我们就得自己来实现一下，这四个函数模板就是做这个用途的。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1648638513,"ip_address":"","comment_id":339671,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100040501,"comment_content":"老师您好，\n对于最后一个小节 “指针类型转换”，我没明白，为什么实现了 4 个转换（包括 static_pointer_cast, reinterpret_pointer_cast, const_pointer_cast, dynamic_pointer_cast），这四个函数有什么用途？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559178,"discussion_content":"普通的指针有四种强制类型转换，static_cast、reinterpret_cast 等（不熟悉的话，请自行搜索）。这些操作不能直接作用于智能指针上。要让智能指针也支持类似的操作，我们就得自己来实现一下，这四个函数模板就是做这个用途的。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1648638514,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339028,"user_name":"Geek_0aec2d","can_delete":false,"product_type":"c1","uid":2948973,"ip_address":"","ucode":"5FBD0447A87211","user_header":"","comment_is_top":false,"comment_ctime":1647865189,"is_pvip":false,"replies":[{"id":124037,"content":"可以这么说。\n\n但一般不这么说，这儿只是拷贝指针而已。我们说深拷贝和浅拷贝，只在包含子对象的大对象上才有意义。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1648040103,"ip_address":"","comment_id":339028,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100040501,"comment_content":"老师请问一个简单的问题\nsmart_ptr(const smart_ptr&amp; other) {\n   ptr_ = other.ptr_; \n   if (ptr_) {\n       other.shared_count_ -&gt;add_count();\n       shared_count_ = other.shared_count_; \n   }\n}\n这个里面的都是浅拷贝吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559178,"discussion_content":"普通的指针有四种强制类型转换，static_cast、reinterpret_cast 等（不熟悉的话，请自行搜索）。这些操作不能直接作用于智能指针上。要让智能指针也支持类似的操作，我们就得自己来实现一下，这四个函数模板就是做这个用途的。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1648638514,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333391,"user_name":"mzhua","can_delete":false,"product_type":"c1","uid":1023919,"ip_address":"","ucode":"F2CA0968A37051","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9f/af/d4cdfd68.jpg","comment_is_top":false,"comment_ctime":1644323006,"is_pvip":false,"replies":[{"id":121860,"content":"必须的，就是要在练习中学习、成长。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1644383196,"ip_address":"","comment_id":333391,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100040501,"comment_content":"确实只是看是看不懂的了，还是要动手😄","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550093,"discussion_content":"必须的，就是要在练习中学习、成长。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644383196,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332066,"user_name":"Marc Chan","can_delete":false,"product_type":"c1","uid":2353732,"ip_address":"","ucode":"D365D6793F304B","user_header":"https://static001.geekbang.org/account/avatar/00/23/ea/44/cf0b2541.jpg","comment_is_top":false,"comment_ctime":1643005299,"is_pvip":false,"replies":[{"id":121365,"content":"学习 + 练习 😇","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1643077737,"ip_address":"","comment_id":332066,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100040501,"comment_content":"看的确实有点吃力，自己功力还是差很多，需要不断学习专栏+看书补齐。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548199,"discussion_content":"学习 + 练习 😇","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643077737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345113,"user_name":"Max(Deguang)","can_delete":false,"product_type":"c1","uid":2348999,"ip_address":"","ucode":"17198F2824D2CB","user_header":"https://static001.geekbang.org/account/avatar/00/23/d7/c7/f3e783e8.jpg","comment_is_top":false,"comment_ctime":1652057529,"is_pvip":false,"replies":[{"id":126076,"content":"你说的语句我没看到走移动构造函数。不过，它也确实不该走赋值运算符。你需要去复习一下这方面的知识。Obj obj = … 是一个构造；obj = … 才是赋值。\n\n简单打印当前函数的展开形式可以用编译器的宏：GCC&#47;Clang 下用 __PRETTY_FUNCTION__，MSVC 下用 __FUNCSIG__。就是想打印某个类型的话，参考第 24 讲的 Boost.TypeIndex。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1652246548,"ip_address":"","comment_id":345113,"utype":1}],"discussion_count":1,"race_medal":1,"score":9,"product_id":100040501,"comment_content":"感觉好难呀，花了三天时间，还有部分没有明白。老师，请问一下\n执行下面的语句的时候，我发现 执行了两次move constructor。这点不是很明白，不应该执行operator=（）吗？ \nsmart_ptr&lt;circle&gt; ptr3 = dynamic_pointer_cast&lt;circle&gt;(ptr2);\n\n另外，有什么好的办法打印出执行时的template name（T／U）吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571500,"discussion_content":"你说的语句我没看到走移动构造函数。不过，它也确实不该走赋值运算符。你需要去复习一下这方面的知识。Obj obj = … 是一个构造；obj = … 才是赋值。\n\n简单打印当前函数的展开形式可以用编译器的宏：GCC/Clang 下用 __PRETTY_FUNCTION__，MSVC 下用 __FUNCSIG__。就是想打印某个类型的话，参考第 24 讲的 Boost.TypeIndex。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652246548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344370,"user_name":"Im me","can_delete":false,"product_type":"c1","uid":1792714,"ip_address":"","ucode":"FF7DEED4BB4C37","user_header":"https://static001.geekbang.org/account/avatar/00/1b/5a/ca/4d5d23d1.jpg","comment_is_top":false,"comment_ctime":1651494842,"is_pvip":false,"replies":[{"id":125849,"content":"l = r;\n\n如果直接交换，r 就得到 l 之前的值了。这可不是我们想要的。我们希望的是 l 得到 r 的值，但 r 不动。\n\n在赋值运算符里的 swap 语句执行结束后，这个临时对象将会被析构。由于它已经跟 *this 交换，析构的只是 *this 的旧值而已。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1651812834,"ip_address":"","comment_id":344370,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100040501,"comment_content":"哪位同学能帮忙解释下文中 拷贝转移所有权代码\nsmart_ptr&amp; operator=(smart_ptr&amp; rhs) \n {    \n    smart_ptr(rhs).swap(*this); \n   return *this;\n  }\n到底为什么非要用一个临时对象啊，为什么不能直接rhs.swap(*this)；我看大家都没有提到这里，应该是就我自己犯迷糊了，求解答","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570549,"discussion_content":"l = r;\n\n如果直接交换，r 就得到 l 之前的值了。这可不是我们想要的。我们希望的是 l 得到 r 的值，但 r 不动。\n\n在赋值运算符里的 swap 语句执行结束后，这个临时对象将会被析构。由于它已经跟 *this 交换，析构的只是 *this 的旧值而已。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1651812834,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344369,"user_name":"Im me","can_delete":false,"product_type":"c1","uid":1792714,"ip_address":"","ucode":"FF7DEED4BB4C37","user_header":"https://static001.geekbang.org/account/avatar/00/1b/5a/ca/4d5d23d1.jpg","comment_is_top":false,"comment_ctime":1651494274,"is_pvip":false,"replies":[{"id":125848,"content":"可以先往后看。看不懂的回过头再看一遍。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1651812587,"ip_address":"","comment_id":344369,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100040501,"comment_content":"这一节看了3个小时还没看懂，基础有点差","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570548,"discussion_content":"可以先往后看。看不懂的回过头再看一遍。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651812587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343763,"user_name":"Kiddy","can_delete":false,"product_type":"c1","uid":2055993,"ip_address":"","ucode":"D07AAEE69BE504","user_header":"https://static001.geekbang.org/account/avatar/00/1f/5f/39/8d2c61d3.jpg","comment_is_top":false,"comment_ctime":1651043841,"is_pvip":false,"replies":[{"id":125592,"content":"我仔细测了一下，完全没有看到移动构造函数的调用。\n\n你如果确定有的话，把完整的测试程序贴出来看看。可以贴到 godbolt.org 上，然后生成短链接发我。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1651150257,"ip_address":"","comment_id":343763,"utype":1}],"discussion_count":8,"race_medal":0,"score":9,"product_id":100040501,"comment_content":"老师，我用gdb跟了下，发现执行ptr1 = ptr2这行代码时，会先执行拷贝构造函数，然后执行移动构造函数，最后执行operator=。  我有个疑问，为啥会执行移动构造函数呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568487,"discussion_content":"我仔细测了一下，完全没有看到移动构造函数的调用。\n\n你如果确定有的话，把完整的测试程序贴出来看看。可以贴到 godbolt.org 上，然后生成短链接发我。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651150257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":7,"child_discussions":[{"author":{"id":2055993,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/5f/39/8d2c61d3.jpg","nickname":"Kiddy","note":"","ucode":"D07AAEE69BE504","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":570239,"discussion_content":"\nclass shape {\npublic:\n  virtual ~shape() {}\n};\n\nclass circle : public shape {\npublic:\n  ~circle() { puts(&#34;~circle()&#34;); }\n};\n\nint main()\n{\n  smart_ptr&lt;circle&gt; ptr1(new circle());\n  printf(&#34;use count of ptr1 is %ld\\n&#34;,\n         ptr1.use_count());\n  smart_ptr&lt;shape&gt; ptr2;\n  printf(&#34;use count of ptr2 was %ld\\n&#34;,\n         ptr2.use_count());\n  ptr2 = ptr1;\n  printf(&#34;use count of ptr2 is now %ld\\n&#34;,\n         ptr2.use_count());\n  if (ptr1) {\n    puts(&#34;ptr1 is not empty&#34;);\n  }\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651714550,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":568487,"ip_address":"","group_id":0},"score":570239,"extra":""},{"author":{"id":2055993,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/5f/39/8d2c61d3.jpg","nickname":"Kiddy","note":"","ucode":"D07AAEE69BE504","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":570241,"discussion_content":"在执行ptr2=ptr1这行代码的时候，我再次跟了下，gdb的确先执行了拷贝构造，接着执行移动构造，最后执行赋值重载（两个构造都是模板的）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651714689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":568487,"ip_address":"","group_id":0},"score":570241,"extra":""},{"author":{"id":2055993,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/5f/39/8d2c61d3.jpg","nickname":"Kiddy","note":"","ucode":"D07AAEE69BE504","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":570242,"discussion_content":"https://godbolt.org/z/fj5bKEMn7","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651714991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":568487,"ip_address":"","group_id":0},"score":570242,"extra":""}]}]},{"had_liked":false,"id":342758,"user_name":"弘","can_delete":false,"product_type":"c1","uid":2754894,"ip_address":"","ucode":"6B91D47FDCCACA","user_header":"https://static001.geekbang.org/account/avatar/00/2a/09/4e/f5993c4e.jpg","comment_is_top":false,"comment_ctime":1650448334,"is_pvip":false,"replies":[{"id":125258,"content":"不太明白你的意思，不过，这些代码都是可运行的：\n\nhttps:&#47;&#47;github.com&#47;adah1972&#47;geek_time_cpp&#47;","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1650547504,"ip_address":"","comment_id":342758,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100040501,"comment_content":"move constructor的时候，shared_count_=nullptr, 这个析构函数会发生异常把\n\n\t","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568487,"discussion_content":"我仔细测了一下，完全没有看到移动构造函数的调用。\n\n你如果确定有的话，把完整的测试程序贴出来看看。可以贴到 godbolt.org 上，然后生成短链接发我。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651150257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":7,"child_discussions":[{"author":{"id":2055993,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/5f/39/8d2c61d3.jpg","nickname":"Kiddy","note":"","ucode":"D07AAEE69BE504","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":570239,"discussion_content":"\nclass shape {\npublic:\n  virtual ~shape() {}\n};\n\nclass circle : public shape {\npublic:\n  ~circle() { puts(&#34;~circle()&#34;); }\n};\n\nint main()\n{\n  smart_ptr&lt;circle&gt; ptr1(new circle());\n  printf(&#34;use count of ptr1 is %ld\\n&#34;,\n         ptr1.use_count());\n  smart_ptr&lt;shape&gt; ptr2;\n  printf(&#34;use count of ptr2 was %ld\\n&#34;,\n         ptr2.use_count());\n  ptr2 = ptr1;\n  printf(&#34;use count of ptr2 is now %ld\\n&#34;,\n         ptr2.use_count());\n  if (ptr1) {\n    puts(&#34;ptr1 is not empty&#34;);\n  }\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651714550,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":568487,"ip_address":"","group_id":0},"score":570239,"extra":""},{"author":{"id":2055993,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/5f/39/8d2c61d3.jpg","nickname":"Kiddy","note":"","ucode":"D07AAEE69BE504","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":570241,"discussion_content":"在执行ptr2=ptr1这行代码的时候，我再次跟了下，gdb的确先执行了拷贝构造，接着执行移动构造，最后执行赋值重载（两个构造都是模板的）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651714689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":568487,"ip_address":"","group_id":0},"score":570241,"extra":""},{"author":{"id":2055993,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/5f/39/8d2c61d3.jpg","nickname":"Kiddy","note":"","ucode":"D07AAEE69BE504","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":570242,"discussion_content":"https://godbolt.org/z/fj5bKEMn7","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651714991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":568487,"ip_address":"","group_id":0},"score":570242,"extra":""}]}]},{"had_liked":false,"id":342125,"user_name":"硕","can_delete":false,"product_type":"c1","uid":2540708,"ip_address":"","ucode":"1F68B408F4BBED","user_header":"https://static001.geekbang.org/account/avatar/00/26/c4/a4/20f44910.jpg","comment_is_top":false,"comment_ctime":1650022903,"is_pvip":false,"replies":[{"id":125053,"content":"不需要。细节后面会讲（第9讲）：\n\n用户如果没有自己声明拷贝构造函数、拷贝赋值函数、移动赋值函数和析构函数，编译器会隐式声明一个移动构造函数。\n\n我们定义了拷贝构造函数，编译器就不会自动生成移动构造函数了。需要移动构造时，我们的模板移动构造函数就会被使用了。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1650173956,"ip_address":"","comment_id":342125,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100040501,"comment_content":"代码列表中，是不是少了一个普通版本的移动构造函数？\n\nsmart_ptr(smart_ptr &amp;&amp;other) noexcept\n{\n    ptr_ = other.ptr_;\n    if (ptr_) {\n        shared_count_ = other.shared_count_;\n        other.ptr_ = nullptr;\n    }\n}","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":565825,"discussion_content":"不太明白你的意思，不过，这些代码都是可运行的：\n\nhttps://github.com/adah1972/geek_time_cpp/","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650547504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339671,"user_name":"硕","can_delete":false,"product_type":"c1","uid":2540708,"ip_address":"","ucode":"1F68B408F4BBED","user_header":"https://static001.geekbang.org/account/avatar/00/26/c4/a4/20f44910.jpg","comment_is_top":false,"comment_ctime":1648285162,"is_pvip":false,"replies":[{"id":124387,"content":"普通的指针有四种强制类型转换，static_cast、reinterpret_cast 等（不熟悉的话，请自行搜索）。这些操作不能直接作用于智能指针上。要让智能指针也支持类似的操作，我们就得自己来实现一下，这四个函数模板就是做这个用途的。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1648638513,"ip_address":"","comment_id":339671,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100040501,"comment_content":"老师您好，\n对于最后一个小节 “指针类型转换”，我没明白，为什么实现了 4 个转换（包括 static_pointer_cast, reinterpret_pointer_cast, const_pointer_cast, dynamic_pointer_cast），这四个函数有什么用途？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":564164,"discussion_content":"不需要。细节后面会讲（第9讲）：\n\n用户如果没有自己声明拷贝构造函数、拷贝赋值函数、移动赋值函数和析构函数，编译器会隐式声明一个移动构造函数。\n\n我们定义了拷贝构造函数，编译器就不会自动生成移动构造函数了。需要移动构造时，我们的模板移动构造函数就会被使用了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1650173956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339028,"user_name":"Geek_0aec2d","can_delete":false,"product_type":"c1","uid":2948973,"ip_address":"","ucode":"5FBD0447A87211","user_header":"","comment_is_top":false,"comment_ctime":1647865189,"is_pvip":false,"replies":[{"id":124037,"content":"可以这么说。\n\n但一般不这么说，这儿只是拷贝指针而已。我们说深拷贝和浅拷贝，只在包含子对象的大对象上才有意义。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1648040103,"ip_address":"","comment_id":339028,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100040501,"comment_content":"老师请问一个简单的问题\nsmart_ptr(const smart_ptr&amp; other) {\n   ptr_ = other.ptr_; \n   if (ptr_) {\n       other.shared_count_ -&gt;add_count();\n       shared_count_ = other.shared_count_; \n   }\n}\n这个里面的都是浅拷贝吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557997,"discussion_content":"可以这么说。\n\n但一般不这么说，这儿只是拷贝指针而已。我们说深拷贝和浅拷贝，只在包含子对象的大对象上才有意义。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648040104,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333391,"user_name":"mzhua","can_delete":false,"product_type":"c1","uid":1023919,"ip_address":"","ucode":"F2CA0968A37051","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9f/af/d4cdfd68.jpg","comment_is_top":false,"comment_ctime":1644323006,"is_pvip":false,"replies":[{"id":121860,"content":"必须的，就是要在练习中学习、成长。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1644383196,"ip_address":"","comment_id":333391,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100040501,"comment_content":"确实只是看是看不懂的了，还是要动手😄","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557997,"discussion_content":"可以这么说。\n\n但一般不这么说，这儿只是拷贝指针而已。我们说深拷贝和浅拷贝，只在包含子对象的大对象上才有意义。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648040104,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332066,"user_name":"Marc Chan","can_delete":false,"product_type":"c1","uid":2353732,"ip_address":"","ucode":"D365D6793F304B","user_header":"https://static001.geekbang.org/account/avatar/00/23/ea/44/cf0b2541.jpg","comment_is_top":false,"comment_ctime":1643005299,"is_pvip":false,"replies":[{"id":121365,"content":"学习 + 练习 😇","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1643077737,"ip_address":"","comment_id":332066,"utype":1}],"discussion_count":1,"race_medal":0,"score":9,"product_id":100040501,"comment_content":"看的确实有点吃力，自己功力还是差很多，需要不断学习专栏+看书补齐。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550093,"discussion_content":"必须的，就是要在练习中学习、成长。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644383196,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325910,"user_name":"ue5","can_delete":false,"product_type":"c1","uid":2754983,"ip_address":"","ucode":"6CA310ACE02ED4","user_header":"https://static001.geekbang.org/account/avatar/00/2a/09/a7/541e33bc.jpg","comment_is_top":false,"comment_ctime":1639227168,"is_pvip":false,"replies":[{"id":118287,"content":"没看懂你的意思。我现在不就是在赋值函数里调用构造函数吗？","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1639372000,"ip_address":"","comment_id":325910,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100040501,"comment_content":"operator =() 调用复制构造好像更方便\n","like_count":0},{"had_liked":false,"id":319634,"user_name":"严海波","can_delete":false,"product_type":"c1","uid":1264573,"ip_address":"","ucode":"8D4E230FD95383","user_header":"https://static001.geekbang.org/account/avatar/00/13/4b/bd/fe8c68b3.jpg","comment_is_top":false,"comment_ctime":1635897234,"is_pvip":false,"replies":[{"id":115903,"content":"赋值运算符？文内已经写了：\n\n「把赋值函数中的参数类型 smart_ptr&amp; 改成了 smart_ptr，在构造参数时直接生成新的智能指针，从而不再需要在函数体中构造临时对象。现在赋值函数的行为是移动还是拷贝，完全依赖于构造参数时走的是移动构造还是拷贝构造。」","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1635935807,"ip_address":"","comment_id":319634,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100040501,"comment_content":"还有一个问题为什么赋值构造函数不使用引用，有特别原因么？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538218,"discussion_content":"没看懂你的意思。我现在不就是在赋值函数里调用构造函数吗？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1639372001,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319632,"user_name":"严海波","can_delete":false,"product_type":"c1","uid":1264573,"ip_address":"","ucode":"8D4E230FD95383","user_header":"https://static001.geekbang.org/account/avatar/00/13/4b/bd/fe8c68b3.jpg","comment_is_top":false,"comment_ctime":1635896698,"is_pvip":false,"replies":[{"id":115902,"content":"没有成本的，编译器可以完全优化掉。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1635935648,"ip_address":"","comment_id":319632,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100040501,"comment_content":"对于shared_ptr,是不是直接用一个unsigned int就好了，我明白你想把++，--归类化，可是另外的类是有成本的，鉴于C++的精神是性能至上。引入另外的类有点得不偿失。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529698,"discussion_content":"赋值运算符？文内已经写了：\n\n「把赋值函数中的参数类型 smart_ptr&amp;amp; 改成了 smart_ptr，在构造参数时直接生成新的智能指针，从而不再需要在函数体中构造临时对象。现在赋值函数的行为是移动还是拷贝，完全依赖于构造参数时走的是移动构造还是拷贝构造。」","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1635935807,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":316583,"user_name":"NEVER SETTLE","can_delete":false,"product_type":"c1","uid":1101894,"ip_address":"","ucode":"9C86BDAFDBF768","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/46/1a9229b3.jpg","comment_is_top":false,"comment_ctime":1634432380,"is_pvip":false,"replies":[{"id":114637,"content":"很仔细的观察。不过，实践上应该是没有问题的。\n\n如果你对“other”重新赋值的话，会走到 operator=(smart_ptr rhs) 里面去，对原先的老对象就是析构掉了（swap 到 rhs 里，在函数结束时析构）。析构时先看 ptr_ 不为空才会去减计数值的。\n\n确实需要比较小心，这里是比较追求性能的做法。一般情况下编程，清零会更清晰些。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1634448807,"ip_address":"","comment_id":316583,"utype":1}],"discussion_count":3,"race_medal":0,"score":10,"product_id":100040501,"comment_content":"老师，我自己在实现的时候发现个问题，出现了引用计数与实际不一样的情况。\n具体场景是：\nSharedPtr&lt;Base&gt; sp2 = std::move(sp1) &#47;&#47; 调用移动构造\nsp1 = sp3 &#47;&#47; 调用赋值拷贝，对sp1重新赋值\n\n我觉得下面这块是不是得加上 other.shared_count_ = nullptr;\n\ntemplate smart_ptr(smart_ptr&amp;&amp; other) noexcept {\n ptr_ = other.ptr_; \n if (ptr_) { \n   shared_count_ = other.shared_count_; \n   other.ptr_ = nullptr; \n   other.shared_count_ = nullptr; &#47;&#47; other对应的实参对应的引用计数器置为nullptr，不然得话重新赋值的，还会对原来的引用计数器减一。\n  } \n}\n\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529697,"discussion_content":"没有成本的，编译器可以完全优化掉。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635935648,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":309223,"user_name":"极客","can_delete":false,"product_type":"c1","uid":2625292,"ip_address":"","ucode":"DFB3B48045EA56","user_header":"https://static001.geekbang.org/account/avatar/00/28/0f/0c/5583558f.jpg","comment_is_top":false,"comment_ctime":1629989369,"is_pvip":false,"replies":[{"id":112006,"content":"这跟多少年关系不算太大。建议从头开始试读一下，如果头几讲能理解，后面问题也不大。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1630109627,"ip_address":"","comment_id":309223,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100040501,"comment_content":"我想请问下，一般情况下多少年经验的c++可以流畅的看完，没有压力？我来看下我的层次……","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525793,"discussion_content":"这跟多少年关系不算太大。建议从头开始试读一下，如果头几讲能理解，后面问题也不大。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630109627,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":306416,"user_name":"荷兰小猪8813","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/66bf4bc4.jpg","comment_is_top":false,"comment_ctime":1628555489,"is_pvip":false,"replies":[{"id":110946,"content":"交换只是实现了异常安全的赋值而已。实际的逻辑仍然主要在那个“拷贝”构造里，会清空那个被“拷贝”的对象。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1628565205,"ip_address":"","comment_id":306416,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100040501,"comment_content":"上面实现的最大问题是，它的行为会让程序员非常容易犯错。一不小心把它传递给另外一个 smart_ptr，你就不再拥有这个对象了……\n\n这是为什么？？？赋值 = 不有交换指针么，对象不会丢呀。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525793,"discussion_content":"这跟多少年关系不算太大。建议从头开始试读一下，如果头几讲能理解，后面问题也不大。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630109627,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":304919,"user_name":"少年","can_delete":false,"product_type":"c1","uid":2714125,"ip_address":"","ucode":"0403897F55879C","user_header":"https://static001.geekbang.org/account/avatar/00/29/6a/0d/38607302.jpg","comment_is_top":false,"comment_ctime":1627701318,"is_pvip":false,"replies":[{"id":110322,"content":"你在 A 类里声明 friend class B;，你说谁是谁的友元？☺️——道理是一样的。\n\n这只有一个方向，因为 A 才有资格宣告它允许谁跑到它家里乱动。显然，方向反掉的话，就乱套了，访问控制就没有意义了。\n\n当然，对于 T、U 的我们的例子，实际上是对称的，不那么重要。但理论上来讲，推理方式是一模一样的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1627735187,"ip_address":"","comment_id":304919,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100040501,"comment_content":"老师，想问一下\n  template &lt;typename U&gt;\n  friend class smart_ptr;\n这句话是smart_ptr&lt;U&gt;是smart_ptr&lt;T&gt;的友元\n还是smart_ptr&lt;T&gt;是smart_ptr&lt;U&gt;的友元？\n请问是怎么看的？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524211,"discussion_content":"你在 A 类里声明 friend class B;，你说谁是谁的友元？☺️——道理是一样的。\n\n这只有一个方向，因为 A 才有资格宣告它允许谁跑到它家里乱动。显然，方向反掉的话，就乱套了，访问控制就没有意义了。\n\n当然，对于 T、U 的我们的例子，实际上是对称的，不那么重要。但理论上来讲，推理方式是一模一样的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1627735187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":303552,"user_name":"JC","can_delete":false,"product_type":"c1","uid":2466389,"ip_address":"","ucode":"0FB3C53427DF98","user_header":"https://static001.geekbang.org/account/avatar/00/25/a2/55/ec6b990a.jpg","comment_is_top":false,"comment_ctime":1626853114,"is_pvip":false,"replies":[{"id":109933,"content":"“否则，smart_ptr ptr2{ptr1}; 在编译时不会出错，但在运行时却会有未定义行为”——是指这句话吗？\n\n“否则”指的是不 delete 拷贝构造函数和拷贝赋值运算符的话……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1626961945,"ip_address":"","comment_id":303552,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100040501,"comment_content":"环境 + 编译器版本\nvscode + gcc version 9.3.0 (Ubuntu 9.3.0-17ubuntu1~20.04):\n\n其中你提到 通过delete来删除 赋值与拷贝两个函数\n\nsmart_ptr&lt;shape&gt; ptr1{create_shape(shape_type::circle)};\nsmart_ptr&lt;shape&gt; ptr2{ptr1}; &#47;&#47; 1\n\n先然1 在编译时就会报错，应该编译器找不到拷贝构造函数，但是你说不会报错呢\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523734,"discussion_content":"“否则，smart_ptr ptr2{ptr1}; 在编译时不会出错，但在运行时却会有未定义行为”——是指这句话吗？\n\n“否则”指的是不 delete 拷贝构造函数和拷贝赋值运算符的话……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626961945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":299850,"user_name":"Wei Zhou","can_delete":false,"product_type":"c1","uid":2670319,"ip_address":"","ucode":"91B72493A8765D","user_header":"https://static001.geekbang.org/account/avatar/00/28/be/ef/a1bb0528.jpg","comment_is_top":false,"comment_ctime":1624884030,"is_pvip":false,"replies":[{"id":108845,"content":"代码要调用 operator=，需要构造一个 smart_ptr。我们只提供了右值的移动构造函数，左值的拷贝构造函数被自动禁用。ptr1 不是右值，编译器找不到合适的构造函数，失败。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1625098497,"ip_address":"","comment_id":299850,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100040501,"comment_content":"smart_ptr&lt;shape&gt; ptr1{create_shape(shape_type::circle)};\nsmart_ptr&lt;shape&gt; ptr3;\nptr3 = ptr1;                             &#47;&#47; 编译出错\n再解释一下这一行为什么会编译出错吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523734,"discussion_content":"“否则，smart_ptr ptr2{ptr1}; 在编译时不会出错，但在运行时却会有未定义行为”——是指这句话吗？\n\n“否则”指的是不 delete 拷贝构造函数和拷贝赋值运算符的话……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626961945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":299848,"user_name":"Wei Zhou","can_delete":false,"product_type":"c1","uid":2670319,"ip_address":"","ucode":"91B72493A8765D","user_header":"https://static001.geekbang.org/account/avatar/00/28/be/ef/a1bb0528.jpg","comment_is_top":false,"comment_ctime":1624883366,"is_pvip":false,"replies":[{"id":108843,"content":"ptr1、ptr2、ptr3 三个指针都指向这个对象，引用计数就是 3 了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1625098223,"ip_address":"","comment_id":299848,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100040501,"comment_content":"use count of ptr3 为什么是 3? 不是2吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522562,"discussion_content":"ptr1、ptr2、ptr3 三个指针都指向这个对象，引用计数就是 3 了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625098223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325910,"user_name":"ue5","can_delete":false,"product_type":"c1","uid":2754983,"ip_address":"","ucode":"6CA310ACE02ED4","user_header":"https://static001.geekbang.org/account/avatar/00/2a/09/a7/541e33bc.jpg","comment_is_top":false,"comment_ctime":1639227168,"is_pvip":false,"replies":[{"id":118287,"content":"没看懂你的意思。我现在不就是在赋值函数里调用构造函数吗？","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1639372000,"ip_address":"","comment_id":325910,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100040501,"comment_content":"operator =() 调用复制构造好像更方便\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538218,"discussion_content":"没看懂你的意思。我现在不就是在赋值函数里调用构造函数吗？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1639372001,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319634,"user_name":"严海波","can_delete":false,"product_type":"c1","uid":1264573,"ip_address":"","ucode":"8D4E230FD95383","user_header":"https://static001.geekbang.org/account/avatar/00/13/4b/bd/fe8c68b3.jpg","comment_is_top":false,"comment_ctime":1635897234,"is_pvip":false,"replies":[{"id":115903,"content":"赋值运算符？文内已经写了：\n\n「把赋值函数中的参数类型 smart_ptr&amp; 改成了 smart_ptr，在构造参数时直接生成新的智能指针，从而不再需要在函数体中构造临时对象。现在赋值函数的行为是移动还是拷贝，完全依赖于构造参数时走的是移动构造还是拷贝构造。」","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1635935807,"ip_address":"","comment_id":319634,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100040501,"comment_content":"还有一个问题为什么赋值构造函数不使用引用，有特别原因么？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529698,"discussion_content":"赋值运算符？文内已经写了：\n\n「把赋值函数中的参数类型 smart_ptr&amp;amp; 改成了 smart_ptr，在构造参数时直接生成新的智能指针，从而不再需要在函数体中构造临时对象。现在赋值函数的行为是移动还是拷贝，完全依赖于构造参数时走的是移动构造还是拷贝构造。」","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1635935807,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319632,"user_name":"严海波","can_delete":false,"product_type":"c1","uid":1264573,"ip_address":"","ucode":"8D4E230FD95383","user_header":"https://static001.geekbang.org/account/avatar/00/13/4b/bd/fe8c68b3.jpg","comment_is_top":false,"comment_ctime":1635896698,"is_pvip":false,"replies":[{"id":115902,"content":"没有成本的，编译器可以完全优化掉。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1635935648,"ip_address":"","comment_id":319632,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100040501,"comment_content":"对于shared_ptr,是不是直接用一个unsigned int就好了，我明白你想把++，--归类化，可是另外的类是有成本的，鉴于C++的精神是性能至上。引入另外的类有点得不偿失。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529697,"discussion_content":"没有成本的，编译器可以完全优化掉。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635935648,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":316583,"user_name":"NEVER SETTLE","can_delete":false,"product_type":"c1","uid":1101894,"ip_address":"","ucode":"9C86BDAFDBF768","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/46/1a9229b3.jpg","comment_is_top":false,"comment_ctime":1634432380,"is_pvip":false,"replies":[{"id":114637,"content":"很仔细的观察。不过，实践上应该是没有问题的。\n\n如果你对“other”重新赋值的话，会走到 operator=(smart_ptr rhs) 里面去，对原先的老对象就是析构掉了（swap 到 rhs 里，在函数结束时析构）。析构时先看 ptr_ 不为空才会去减计数值的。\n\n确实需要比较小心，这里是比较追求性能的做法。一般情况下编程，清零会更清晰些。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1634448807,"ip_address":"","comment_id":316583,"utype":1}],"discussion_count":3,"race_medal":0,"score":10,"product_id":100040501,"comment_content":"老师，我自己在实现的时候发现个问题，出现了引用计数与实际不一样的情况。\n具体场景是：\nSharedPtr&lt;Base&gt; sp2 = std::move(sp1) &#47;&#47; 调用移动构造\nsp1 = sp3 &#47;&#47; 调用赋值拷贝，对sp1重新赋值\n\n我觉得下面这块是不是得加上 other.shared_count_ = nullptr;\n\ntemplate smart_ptr(smart_ptr&amp;&amp; other) noexcept {\n ptr_ = other.ptr_; \n if (ptr_) { \n   shared_count_ = other.shared_count_; \n   other.ptr_ = nullptr; \n   other.shared_count_ = nullptr; &#47;&#47; other对应的实参对应的引用计数器置为nullptr，不然得话重新赋值的，还会对原来的引用计数器减一。\n  } \n}\n\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528420,"discussion_content":"很仔细的观察。不过，实践上应该是没有问题的。\n\n如果你对“other”重新赋值的话，会走到 operator=(smart_ptr rhs) 里面去，对原先的老对象就是析构掉了（swap 到 rhs 里，在函数结束时析构）。析构时先看 ptr_ 不为空才会去减计数值的。\n\n确实需要比较小心，这里是比较追求性能的做法。一般情况下编程，清零会更清晰些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634448807,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1101894,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d0/46/1a9229b3.jpg","nickname":"NEVER SETTLE","note":"","ucode":"9C86BDAFDBF768","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":405255,"discussion_content":"实现析构时候","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634541710,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1101894,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d0/46/1a9229b3.jpg","nickname":"NEVER SETTLE","note":"","ucode":"9C86BDAFDBF768","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":405254,"discussion_content":"是的，我自己实现时候，先判断计数器减1，再判断ptr是否为空，这块写的有问题，触发了上面的case。我看您是并列判断，不会出现这个问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634541634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":309223,"user_name":"极客","can_delete":false,"product_type":"c1","uid":2625292,"ip_address":"","ucode":"DFB3B48045EA56","user_header":"https://static001.geekbang.org/account/avatar/00/28/0f/0c/5583558f.jpg","comment_is_top":false,"comment_ctime":1629989369,"is_pvip":false,"replies":[{"id":112006,"content":"这跟多少年关系不算太大。建议从头开始试读一下，如果头几讲能理解，后面问题也不大。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1630109627,"ip_address":"","comment_id":309223,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100040501,"comment_content":"我想请问下，一般情况下多少年经验的c++可以流畅的看完，没有压力？我来看下我的层次……","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528420,"discussion_content":"很仔细的观察。不过，实践上应该是没有问题的。\n\n如果你对“other”重新赋值的话，会走到 operator=(smart_ptr rhs) 里面去，对原先的老对象就是析构掉了（swap 到 rhs 里，在函数结束时析构）。析构时先看 ptr_ 不为空才会去减计数值的。\n\n确实需要比较小心，这里是比较追求性能的做法。一般情况下编程，清零会更清晰些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634448807,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1101894,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d0/46/1a9229b3.jpg","nickname":"NEVER SETTLE","note":"","ucode":"9C86BDAFDBF768","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":405255,"discussion_content":"实现析构时候","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634541710,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1101894,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d0/46/1a9229b3.jpg","nickname":"NEVER SETTLE","note":"","ucode":"9C86BDAFDBF768","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":405254,"discussion_content":"是的，我自己实现时候，先判断计数器减1，再判断ptr是否为空，这块写的有问题，触发了上面的case。我看您是并列判断，不会出现这个问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634541634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":306416,"user_name":"荷兰小猪8813","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/66bf4bc4.jpg","comment_is_top":false,"comment_ctime":1628555489,"is_pvip":false,"replies":[{"id":110946,"content":"交换只是实现了异常安全的赋值而已。实际的逻辑仍然主要在那个“拷贝”构造里，会清空那个被“拷贝”的对象。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1628565205,"ip_address":"","comment_id":306416,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100040501,"comment_content":"上面实现的最大问题是，它的行为会让程序员非常容易犯错。一不小心把它传递给另外一个 smart_ptr，你就不再拥有这个对象了……\n\n这是为什么？？？赋值 = 不有交换指针么，对象不会丢呀。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524755,"discussion_content":"交换只是实现了异常安全的赋值而已。实际的逻辑仍然主要在那个“拷贝”构造里，会清空那个被“拷贝”的对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628565205,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":304919,"user_name":"少年","can_delete":false,"product_type":"c1","uid":2714125,"ip_address":"","ucode":"0403897F55879C","user_header":"https://static001.geekbang.org/account/avatar/00/29/6a/0d/38607302.jpg","comment_is_top":false,"comment_ctime":1627701318,"is_pvip":false,"replies":[{"id":110322,"content":"你在 A 类里声明 friend class B;，你说谁是谁的友元？☺️——道理是一样的。\n\n这只有一个方向，因为 A 才有资格宣告它允许谁跑到它家里乱动。显然，方向反掉的话，就乱套了，访问控制就没有意义了。\n\n当然，对于 T、U 的我们的例子，实际上是对称的，不那么重要。但理论上来讲，推理方式是一模一样的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1627735187,"ip_address":"","comment_id":304919,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100040501,"comment_content":"老师，想问一下\n  template &lt;typename U&gt;\n  friend class smart_ptr;\n这句话是smart_ptr&lt;U&gt;是smart_ptr&lt;T&gt;的友元\n还是smart_ptr&lt;T&gt;是smart_ptr&lt;U&gt;的友元？\n请问是怎么看的？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524755,"discussion_content":"交换只是实现了异常安全的赋值而已。实际的逻辑仍然主要在那个“拷贝”构造里，会清空那个被“拷贝”的对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628565205,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":303552,"user_name":"JC","can_delete":false,"product_type":"c1","uid":2466389,"ip_address":"","ucode":"0FB3C53427DF98","user_header":"https://static001.geekbang.org/account/avatar/00/25/a2/55/ec6b990a.jpg","comment_is_top":false,"comment_ctime":1626853114,"is_pvip":false,"replies":[{"id":109933,"content":"“否则，smart_ptr ptr2{ptr1}; 在编译时不会出错，但在运行时却会有未定义行为”——是指这句话吗？\n\n“否则”指的是不 delete 拷贝构造函数和拷贝赋值运算符的话……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1626961945,"ip_address":"","comment_id":303552,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100040501,"comment_content":"环境 + 编译器版本\nvscode + gcc version 9.3.0 (Ubuntu 9.3.0-17ubuntu1~20.04):\n\n其中你提到 通过delete来删除 赋值与拷贝两个函数\n\nsmart_ptr&lt;shape&gt; ptr1{create_shape(shape_type::circle)};\nsmart_ptr&lt;shape&gt; ptr2{ptr1}; &#47;&#47; 1\n\n先然1 在编译时就会报错，应该编译器找不到拷贝构造函数，但是你说不会报错呢\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524211,"discussion_content":"你在 A 类里声明 friend class B;，你说谁是谁的友元？☺️——道理是一样的。\n\n这只有一个方向，因为 A 才有资格宣告它允许谁跑到它家里乱动。显然，方向反掉的话，就乱套了，访问控制就没有意义了。\n\n当然，对于 T、U 的我们的例子，实际上是对称的，不那么重要。但理论上来讲，推理方式是一模一样的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1627735187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":299850,"user_name":"Wei Zhou","can_delete":false,"product_type":"c1","uid":2670319,"ip_address":"","ucode":"91B72493A8765D","user_header":"https://static001.geekbang.org/account/avatar/00/28/be/ef/a1bb0528.jpg","comment_is_top":false,"comment_ctime":1624884030,"is_pvip":false,"replies":[{"id":108845,"content":"代码要调用 operator=，需要构造一个 smart_ptr。我们只提供了右值的移动构造函数，左值的拷贝构造函数被自动禁用。ptr1 不是右值，编译器找不到合适的构造函数，失败。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1625098497,"ip_address":"","comment_id":299850,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100040501,"comment_content":"smart_ptr&lt;shape&gt; ptr1{create_shape(shape_type::circle)};\nsmart_ptr&lt;shape&gt; ptr3;\nptr3 = ptr1;                             &#47;&#47; 编译出错\n再解释一下这一行为什么会编译出错吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522563,"discussion_content":"代码要调用 operator=，需要构造一个 smart_ptr。我们只提供了右值的移动构造函数，左值的拷贝构造函数被自动禁用。ptr1 不是右值，编译器找不到合适的构造函数，失败。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1625098497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":299848,"user_name":"Wei Zhou","can_delete":false,"product_type":"c1","uid":2670319,"ip_address":"","ucode":"91B72493A8765D","user_header":"https://static001.geekbang.org/account/avatar/00/28/be/ef/a1bb0528.jpg","comment_is_top":false,"comment_ctime":1624883366,"is_pvip":false,"replies":[{"id":108843,"content":"ptr1、ptr2、ptr3 三个指针都指向这个对象，引用计数就是 3 了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1625098223,"ip_address":"","comment_id":299848,"utype":1}],"discussion_count":1,"race_medal":0,"score":10,"product_id":100040501,"comment_content":"use count of ptr3 为什么是 3? 不是2吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522563,"discussion_content":"代码要调用 operator=，需要构造一个 smart_ptr。我们只提供了右值的移动构造函数，左值的拷贝构造函数被自动禁用。ptr1 不是右值，编译器找不到合适的构造函数，失败。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1625098497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":298087,"user_name":"Queenie","can_delete":false,"product_type":"c1","uid":2303115,"ip_address":"","ucode":"BC3F5615537FA0","user_header":"https://static001.geekbang.org/account/avatar/00/23/24/8b/10e78e95.jpg","comment_is_top":false,"comment_ctime":1623908642,"is_pvip":false,"replies":[{"id":108279,"content":"头两个是运算符重载，第三个是类的类型转换运算符。这些你搜索一下就可以找到大量的资料。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1624110524,"ip_address":"","comment_id":298087,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100040501,"comment_content":"吴老师您好，C++基础较弱，听了几遍，有些地方还是没太明白。\n目前这个 smart_ptr 的行为还是和指针有点差异的：\n它不能用 * 运算符解引用\n它不能用 -&gt; 运算符指向对象成员\n它不能像指针一样用在布尔表达式里，\n解决这几个问题，增加了几个成员函数，这个解决具体方法是运算符重载吗？可以详细讲解下吗\n","like_count":0},{"had_liked":false,"id":296373,"user_name":"无涯","can_delete":false,"product_type":"c1","uid":2206226,"ip_address":"","ucode":"9A3B2774BC6E5F","user_header":"https://static001.geekbang.org/account/avatar/00/21/aa/12/7ac87dd6.jpg","comment_is_top":false,"comment_ctime":1622944504,"is_pvip":false,"replies":[{"id":107754,"content":"首先，只有2这种形式可能返回值优化。1是赋值，不能。我们仔细看看1。\n\n事实上，目前看起来这里面的复杂性应该是因为你的 ptr1 和 ptr3 的类型不同（而我网上贴的代码这两个变量的类型恰好相同）。我们下面分析一下。\n\n赋值运算符的参数是按值传递，它需要构造一个跟左侧一样类型的对象出来。在你提供一个左值的情况下，为了得到左边的类型，编译器会找到带模板的那个“拷贝”构造函数，构造出跟左边一样的类型。\n\n对于赋值运算符的值参数，你传一个左值参数就会发生拷贝构造，传一个右值参数会发生移动构造。现在的参数是前面临时构造出来的，是右值，所以进入赋值运算符之前先会发生一次移动构造。\n\n进入赋值之后，下面就是交换动作，交换完，参数得到了 this 对象的旧值，随即被析构。之前拷贝构造出来的临时对象，也在当前语句执行完时被析构。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1623114378,"ip_address":"","comment_id":296373,"utype":1}],"discussion_count":2,"race_medal":0,"score":11,"product_id":100040501,"comment_content":"多谢老师解答，我看了第十节也还是有点乱这块没想明白\n&#47;&#47; 1、运行\nptr3 = ptr1;\n先调用copy构造，为啥还要再调用移动构造？ 之后析构，析构\n&#47;&#47;2、而运行\nsmart_ptr&lt;circle&gt; ptr3 = dynamic_pointer_cast&lt;circle&gt;(ptr2);\n先调用移动构造，析构，又调用一次移动构造，析构？\n\n就是g++ -std=c++11  -W -Wall -Wfatal-errors smart_ptr.cpp之后是：\ncall explicit smart_ptr(T* ptr = nullptr)\nuse count of ptr1 is 1\ncall explicit smart_ptr(T* ptr = nullptr)\nuse count of ptr2 was 0\ncall smart_ptr(const smart_ptr&lt;U&gt;&amp; other) noexcept\ncall smart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other) noexcept\ncall smart_ptr&amp;  operator=(smart_ptr rhs) noexcept\ncall ~smart_ptr()\ncall ~smart_ptr()\nuse count of ptr2 is now 2\nptr1 is not empty\ncall smart_ptr&lt;T&gt; dynamic_pointer_cast(const smart_ptr&lt;U&gt;&amp; other) noexcept\ncall smart_ptr(const smart_ptr&lt;U&gt;&amp; other, T* ptr) noexcept\ncall smart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other) noexcept\ncall ~smart_ptr()\ncall smart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other) noexcept\ncall ~smart_ptr()\nuse count of ptr3 is 3\ncall ~smart_ptr()\ncall ~smart_ptr()\n~circle()\ncall ~smart_ptr()\n而 g++ -std=c++17 -W -Wall -Wfatal-errors smart_ptr.cpp之后是\ncall explicit smart_ptr(T* ptr = nullptr)\nuse count of ptr1 is 1\ncall explicit smart_ptr(T* ptr = nullptr)\nuse count of ptr2 was 0\ncall smart_ptr(const smart_ptr&lt;U&gt;&amp; other) noexcept\ncall smart_ptr&amp;  operator=(smart_ptr rhs) noexcept\ncall ~smart_ptr()\nuse count of ptr2 is now 2\nptr1 is not empty\ncall smart_ptr&lt;T&gt; dynamic_pointer_cast(const smart_ptr&lt;U&gt;&amp; other) noexcept\ncall smart_ptr(const smart_ptr&lt;U&gt;&amp; other, T* ptr) noexcept\nuse count of ptr3 is 3\ncall ~smart_ptr()\ncall ~smart_ptr()\n~circle()\ncall ~smart_ptr()\n上面那个明显多了很多次移动构造，我还是不是很懂他们之间RVO的区别，希望老师是能解答，多谢老师了","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521417,"discussion_content":"首先，只有2这种形式可能返回值优化。1是赋值，不能。我们仔细看看1。\n\n事实上，目前看起来这里面的复杂性应该是因为你的 ptr1 和 ptr3 的类型不同（而我网上贴的代码这两个变量的类型恰好相同）。我们下面分析一下。\n\n赋值运算符的参数是按值传递，它需要构造一个跟左侧一样类型的对象出来。在你提供一个左值的情况下，为了得到左边的类型，编译器会找到带模板的那个“拷贝”构造函数，构造出跟左边一样的类型。\n\n对于赋值运算符的值参数，你传一个左值参数就会发生拷贝构造，传一个右值参数会发生移动构造。现在的参数是前面临时构造出来的，是右值，所以进入赋值运算符之前先会发生一次移动构造。\n\n进入赋值之后，下面就是交换动作，交换完，参数得到了 this 对象的旧值，随即被析构。之前拷贝构造出来的临时对象，也在当前语句执行完时被析构。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1623114378,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2055993,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/5f/39/8d2c61d3.jpg","nickname":"Kiddy","note":"","ucode":"D07AAEE69BE504","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":569141,"discussion_content":"老师，按照你这样的说法，ptr1跟ptr3哪怕是相同类型，不都得执行一次拷贝构造跟移动构造吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651331277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":521417,"ip_address":"","group_id":0},"score":569141,"extra":""}]}]},{"had_liked":false,"id":296097,"user_name":"无涯","can_delete":false,"product_type":"c1","uid":2206226,"ip_address":"","ucode":"9A3B2774BC6E5F","user_header":"https://static001.geekbang.org/account/avatar/00/21/aa/12/7ac87dd6.jpg","comment_is_top":false,"comment_ctime":1622760901,"is_pvip":false,"replies":[{"id":107534,"content":"结合你的上一个问题，应该是跟返回值优化有关吧。可以看一下第10讲。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1622942697,"ip_address":"","comment_id":296097,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100040501,"comment_content":"老师我想问一下，为什莫在c++ 11 的时候回是ptr2.operator=(smart_ptr&lt;shape&gt;(smart_ptr&lt;shape&gt;(ptr1)));和 smart_ptr&lt;circle&gt; ptr3 = smart_ptr&lt;circle&gt;(dynamic_pointer_cast&lt;circle&gt;(ptr2));与c++ 17的 smart_ptr&lt;circle&gt; ptr3 = dynamic_pointer_cast&lt;circle&gt;(ptr2);和ptr2.operator=(smart_ptr&lt;shape&gt;(ptr1));多一次构造？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521325,"discussion_content":"结合你的上一个问题，应该是跟返回值优化有关吧。可以看一下第10讲。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622942697,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296096,"user_name":"无涯","can_delete":false,"product_type":"c1","uid":2206226,"ip_address":"","ucode":"9A3B2774BC6E5F","user_header":"https://static001.geekbang.org/account/avatar/00/21/aa/12/7ac87dd6.jpg","comment_is_top":false,"comment_ctime":1622749984,"is_pvip":false,"replies":[{"id":107533,"content":"1. 没怎么明白你的意思。对于最终版本，应该是一次拷贝构造（构造赋值里面的值参数），然后进入赋值运算符，进行一次交换，完成。\n\n2. 我这边测试是会进到 smart_ptr(const smart_ptr&lt;U&gt;&amp; other, T* ptr) 这个构造函数，然后因为返回值优化，连移动都没有发生。如果没有返回值优化，则会发生一次移动构造。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1622942583,"ip_address":"","comment_id":296096,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100040501,"comment_content":"老师这块没想明白\n\n&#47;&#47; 1、运行\nptr3 = ptr1;\n先调用copy构造，为啥还要再调用移动构造？ 之后析构，析构\n\n&#47;&#47;2、而运行\nsmart_ptr&lt;circle&gt; ptr3 =   dynamic_pointer_cast&lt;circle&gt;(ptr2);\n先调用移动构造，析构，又调用一次移动构造，析构？\n\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521324,"discussion_content":"1. 没怎么明白你的意思。对于最终版本，应该是一次拷贝构造（构造赋值里面的值参数），然后进入赋值运算符，进行一次交换，完成。\n\n2. 我这边测试是会进到 smart_ptr(const smart_ptr&amp;lt;U&amp;gt;&amp;amp; other, T* ptr) 这个构造函数，然后因为返回值优化，连移动都没有发生。如果没有返回值优化，则会发生一次移动构造。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1622942583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":286087,"user_name":"Geek_43a2d5","can_delete":false,"product_type":"c1","uid":2423526,"ip_address":"","ucode":"33C5B1DB0A5DC4","user_header":"","comment_is_top":false,"comment_ctime":1617154138,"is_pvip":false,"replies":[{"id":103891,"content":"减一引用数就不对了，当然不能减一。两个指针是使用同一个共享计数的。\n\n你再想想？","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1617237750,"ip_address":"","comment_id":286087,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100040501,"comment_content":"有个问题，共享指针 p1 p2\np1 = p2 \n右边指针的共享计数加一 左边计数减一才对啊，从代码中没找到这个减一的操作","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521324,"discussion_content":"1. 没怎么明白你的意思。对于最终版本，应该是一次拷贝构造（构造赋值里面的值参数），然后进入赋值运算符，进行一次交换，完成。\n\n2. 我这边测试是会进到 smart_ptr(const smart_ptr&amp;lt;U&amp;gt;&amp;amp; other, T* ptr) 这个构造函数，然后因为返回值优化，连移动都没有发生。如果没有返回值优化，则会发生一次移动构造。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1622942583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284725,"user_name":"大风封","can_delete":false,"product_type":"c1","uid":1071070,"ip_address":"","ucode":"9F4A87C549B115","user_header":"https://static001.geekbang.org/account/avatar/00/10/57/de/4ea51085.jpg","comment_is_top":false,"comment_ctime":1616428842,"is_pvip":false,"replies":[{"id":103458,"content":"抱歉，没有。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1616657677,"ip_address":"","comment_id":284725,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100040501,"comment_content":"老师有星球么","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517445,"discussion_content":"抱歉，没有。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616657677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":283303,"user_name":"码匠许师傅","can_delete":false,"product_type":"c1","uid":1260213,"ip_address":"","ucode":"3A470CAC0ADAC4","user_header":"https://static001.geekbang.org/account/avatar/00/13/3a/b5/22d74b60.jpg","comment_is_top":false,"comment_ctime":1615698719,"is_pvip":false,"replies":[{"id":102794,"content":"比较运算符是有意义的，但下标则是有问题的。目前只能放一个元素，要下标干嘛？:-)","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1615735987,"ip_address":"","comment_id":283303,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100040501,"comment_content":"还需要添加比较运算符重载函数、下标运算符","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516985,"discussion_content":"比较运算符是有意义的，但下标则是有问题的。目前只能放一个元素，要下标干嘛？:-)","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1615735987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":279878,"user_name":"Geek_227a72","can_delete":false,"product_type":"c1","uid":2417911,"ip_address":"","ucode":"385B764D9AEAE8","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKsI6VdljHFtMx4cgEPpqhXiaIYQicqGcal8sIoBYQZn7tYQyPLH1FuOVP8SaYPghPIsqSa1DWjRT2A/132","comment_is_top":false,"comment_ctime":1613989817,"is_pvip":false,"replies":[{"id":101696,"content":"返回的是新构造的类型转换之后的 smart_ptr。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1614039759,"ip_address":"","comment_id":279878,"utype":1}],"discussion_count":2,"race_medal":0,"score":11,"product_id":100040501,"comment_content":"template &lt;typename T, typename U&gt;\nsmart_ptr&lt;T&gt; dynamic_pointer_cast(\n  const smart_ptr&lt;U&gt;&amp; other)\n{\n  T* ptr =\n    dynamic_cast&lt;T*&gt;(other.get());\n  return smart_ptr&lt;T&gt;(other, ptr);\n}\n老师能解释一下return返回的是什么吗，看不懂","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515904,"discussion_content":"返回的是新构造的类型转换之后的 smart_ptr。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1614039759,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2417911,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKsI6VdljHFtMx4cgEPpqhXiaIYQicqGcal8sIoBYQZn7tYQyPLH1FuOVP8SaYPghPIsqSa1DWjRT2A/132","nickname":"Geek_227a72","note":"","ucode":"385B764D9AEAE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350726,"discussion_content":"看懂了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613991042,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":279691,"user_name":"Geek_227a72","can_delete":false,"product_type":"c1","uid":2417911,"ip_address":"","ucode":"385B764D9AEAE8","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKsI6VdljHFtMx4cgEPpqhXiaIYQicqGcal8sIoBYQZn7tYQyPLH1FuOVP8SaYPghPIsqSa1DWjRT2A/132","comment_is_top":false,"comment_ctime":1613908195,"is_pvip":false,"replies":[{"id":101602,"content":"对照一下\n\nhttps:&#47;&#47;github.com&#47;adah1972&#47;geek_time_cpp&#47;blob&#47;master&#47;02&#47;test02_shared_ptr.cpp\nhttps:&#47;&#47;github.com&#47;adah1972&#47;geek_time_cpp&#47;tree&#47;master&#47;common\n\n应该就是哪儿代码有个小问题吧。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1613957277,"ip_address":"","comment_id":279691,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100040501,"comment_content":"use count of ptr1 is 1\nuse count of ptr2 was 0\nuse count of ptr2 is now 2\nptr1 is not empty\n~circle()\n\n\n为啥我的没输出“～circle（）”呢？前面的输出都可以","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515835,"discussion_content":"对照一下\n\nhttps://github.com/adah1972/geek_time_cpp/blob/master/02/test02_shared_ptr.cpp\nhttps://github.com/adah1972/geek_time_cpp/tree/master/common\n\n应该就是哪儿代码有个小问题吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613957277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":277279,"user_name":"鸽足轻轻","can_delete":false,"product_type":"c1","uid":1251879,"ip_address":"","ucode":"03C0D150D73273","user_header":"https://static001.geekbang.org/account/avatar/00/13/1a/27/373003d3.jpg","comment_is_top":false,"comment_ctime":1612342830,"is_pvip":false,"replies":[{"id":100646,"content":"你可能需要给出明确的例子才行。\n\n我这儿给一个示范：\n\nhttps:&#47;&#47;godbolt.org&#47;z&#47;h81b47\n\n可以看到，我禁用了 circle 和 shape 的拷贝和移动操作，在智能指针的实现中添加了 Copy 和 Move 的输出字样。在 ptr2 = ptr1; 这一操作中，发生了一次智能指针的拷贝构造。这一拷贝构造的原因，点击“CppInsights”按钮可以看得很清楚：编译器根据类型要求，最后生成的是\n\nptr2.operator=(smart_ptr&lt;shape&gt;(ptr1));","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1612411777,"ip_address":"","comment_id":277279,"utype":1}],"discussion_count":2,"race_medal":0,"score":11,"product_id":100040501,"comment_content":"老师您好，根据您的代码我写了一个测试case，发现当子类的智能指针转换为父类的智能指针时，还发生了移动构造函数的调用，百思不得其解，请老师解惑","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515835,"discussion_content":"对照一下\n\nhttps://github.com/adah1972/geek_time_cpp/blob/master/02/test02_shared_ptr.cpp\nhttps://github.com/adah1972/geek_time_cpp/tree/master/common\n\n应该就是哪儿代码有个小问题吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613957277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":298087,"user_name":"Queenie","can_delete":false,"product_type":"c1","uid":2303115,"ip_address":"","ucode":"BC3F5615537FA0","user_header":"https://static001.geekbang.org/account/avatar/00/23/24/8b/10e78e95.jpg","comment_is_top":false,"comment_ctime":1623908642,"is_pvip":false,"replies":[{"id":108279,"content":"头两个是运算符重载，第三个是类的类型转换运算符。这些你搜索一下就可以找到大量的资料。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1624110524,"ip_address":"","comment_id":298087,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100040501,"comment_content":"吴老师您好，C++基础较弱，听了几遍，有些地方还是没太明白。\n目前这个 smart_ptr 的行为还是和指针有点差异的：\n它不能用 * 运算符解引用\n它不能用 -&gt; 运算符指向对象成员\n它不能像指针一样用在布尔表达式里，\n解决这几个问题，增加了几个成员函数，这个解决具体方法是运算符重载吗？可以详细讲解下吗\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522009,"discussion_content":"头两个是运算符重载，第三个是类的类型转换运算符。这些你搜索一下就可以找到大量的资料。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1624110524,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296373,"user_name":"无涯","can_delete":false,"product_type":"c1","uid":2206226,"ip_address":"","ucode":"9A3B2774BC6E5F","user_header":"https://static001.geekbang.org/account/avatar/00/21/aa/12/7ac87dd6.jpg","comment_is_top":false,"comment_ctime":1622944504,"is_pvip":false,"replies":[{"id":107754,"content":"首先，只有2这种形式可能返回值优化。1是赋值，不能。我们仔细看看1。\n\n事实上，目前看起来这里面的复杂性应该是因为你的 ptr1 和 ptr3 的类型不同（而我网上贴的代码这两个变量的类型恰好相同）。我们下面分析一下。\n\n赋值运算符的参数是按值传递，它需要构造一个跟左侧一样类型的对象出来。在你提供一个左值的情况下，为了得到左边的类型，编译器会找到带模板的那个“拷贝”构造函数，构造出跟左边一样的类型。\n\n对于赋值运算符的值参数，你传一个左值参数就会发生拷贝构造，传一个右值参数会发生移动构造。现在的参数是前面临时构造出来的，是右值，所以进入赋值运算符之前先会发生一次移动构造。\n\n进入赋值之后，下面就是交换动作，交换完，参数得到了 this 对象的旧值，随即被析构。之前拷贝构造出来的临时对象，也在当前语句执行完时被析构。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1623114378,"ip_address":"","comment_id":296373,"utype":1}],"discussion_count":2,"race_medal":0,"score":11,"product_id":100040501,"comment_content":"多谢老师解答，我看了第十节也还是有点乱这块没想明白\n&#47;&#47; 1、运行\nptr3 = ptr1;\n先调用copy构造，为啥还要再调用移动构造？ 之后析构，析构\n&#47;&#47;2、而运行\nsmart_ptr&lt;circle&gt; ptr3 = dynamic_pointer_cast&lt;circle&gt;(ptr2);\n先调用移动构造，析构，又调用一次移动构造，析构？\n\n就是g++ -std=c++11  -W -Wall -Wfatal-errors smart_ptr.cpp之后是：\ncall explicit smart_ptr(T* ptr = nullptr)\nuse count of ptr1 is 1\ncall explicit smart_ptr(T* ptr = nullptr)\nuse count of ptr2 was 0\ncall smart_ptr(const smart_ptr&lt;U&gt;&amp; other) noexcept\ncall smart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other) noexcept\ncall smart_ptr&amp;  operator=(smart_ptr rhs) noexcept\ncall ~smart_ptr()\ncall ~smart_ptr()\nuse count of ptr2 is now 2\nptr1 is not empty\ncall smart_ptr&lt;T&gt; dynamic_pointer_cast(const smart_ptr&lt;U&gt;&amp; other) noexcept\ncall smart_ptr(const smart_ptr&lt;U&gt;&amp; other, T* ptr) noexcept\ncall smart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other) noexcept\ncall ~smart_ptr()\ncall smart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other) noexcept\ncall ~smart_ptr()\nuse count of ptr3 is 3\ncall ~smart_ptr()\ncall ~smart_ptr()\n~circle()\ncall ~smart_ptr()\n而 g++ -std=c++17 -W -Wall -Wfatal-errors smart_ptr.cpp之后是\ncall explicit smart_ptr(T* ptr = nullptr)\nuse count of ptr1 is 1\ncall explicit smart_ptr(T* ptr = nullptr)\nuse count of ptr2 was 0\ncall smart_ptr(const smart_ptr&lt;U&gt;&amp; other) noexcept\ncall smart_ptr&amp;  operator=(smart_ptr rhs) noexcept\ncall ~smart_ptr()\nuse count of ptr2 is now 2\nptr1 is not empty\ncall smart_ptr&lt;T&gt; dynamic_pointer_cast(const smart_ptr&lt;U&gt;&amp; other) noexcept\ncall smart_ptr(const smart_ptr&lt;U&gt;&amp; other, T* ptr) noexcept\nuse count of ptr3 is 3\ncall ~smart_ptr()\ncall ~smart_ptr()\n~circle()\ncall ~smart_ptr()\n上面那个明显多了很多次移动构造，我还是不是很懂他们之间RVO的区别，希望老师是能解答，多谢老师了","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522009,"discussion_content":"头两个是运算符重载，第三个是类的类型转换运算符。这些你搜索一下就可以找到大量的资料。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1624110524,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296097,"user_name":"无涯","can_delete":false,"product_type":"c1","uid":2206226,"ip_address":"","ucode":"9A3B2774BC6E5F","user_header":"https://static001.geekbang.org/account/avatar/00/21/aa/12/7ac87dd6.jpg","comment_is_top":false,"comment_ctime":1622760901,"is_pvip":false,"replies":[{"id":107534,"content":"结合你的上一个问题，应该是跟返回值优化有关吧。可以看一下第10讲。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1622942697,"ip_address":"","comment_id":296097,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100040501,"comment_content":"老师我想问一下，为什莫在c++ 11 的时候回是ptr2.operator=(smart_ptr&lt;shape&gt;(smart_ptr&lt;shape&gt;(ptr1)));和 smart_ptr&lt;circle&gt; ptr3 = smart_ptr&lt;circle&gt;(dynamic_pointer_cast&lt;circle&gt;(ptr2));与c++ 17的 smart_ptr&lt;circle&gt; ptr3 = dynamic_pointer_cast&lt;circle&gt;(ptr2);和ptr2.operator=(smart_ptr&lt;shape&gt;(ptr1));多一次构造？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521417,"discussion_content":"首先，只有2这种形式可能返回值优化。1是赋值，不能。我们仔细看看1。\n\n事实上，目前看起来这里面的复杂性应该是因为你的 ptr1 和 ptr3 的类型不同（而我网上贴的代码这两个变量的类型恰好相同）。我们下面分析一下。\n\n赋值运算符的参数是按值传递，它需要构造一个跟左侧一样类型的对象出来。在你提供一个左值的情况下，为了得到左边的类型，编译器会找到带模板的那个“拷贝”构造函数，构造出跟左边一样的类型。\n\n对于赋值运算符的值参数，你传一个左值参数就会发生拷贝构造，传一个右值参数会发生移动构造。现在的参数是前面临时构造出来的，是右值，所以进入赋值运算符之前先会发生一次移动构造。\n\n进入赋值之后，下面就是交换动作，交换完，参数得到了 this 对象的旧值，随即被析构。之前拷贝构造出来的临时对象，也在当前语句执行完时被析构。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1623114378,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2055993,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/5f/39/8d2c61d3.jpg","nickname":"Kiddy","note":"","ucode":"D07AAEE69BE504","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":569141,"discussion_content":"老师，按照你这样的说法，ptr1跟ptr3哪怕是相同类型，不都得执行一次拷贝构造跟移动构造吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651331277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":521417,"ip_address":"","group_id":0},"score":569141,"extra":""}]}]},{"had_liked":false,"id":296096,"user_name":"无涯","can_delete":false,"product_type":"c1","uid":2206226,"ip_address":"","ucode":"9A3B2774BC6E5F","user_header":"https://static001.geekbang.org/account/avatar/00/21/aa/12/7ac87dd6.jpg","comment_is_top":false,"comment_ctime":1622749984,"is_pvip":false,"replies":[{"id":107533,"content":"1. 没怎么明白你的意思。对于最终版本，应该是一次拷贝构造（构造赋值里面的值参数），然后进入赋值运算符，进行一次交换，完成。\n\n2. 我这边测试是会进到 smart_ptr(const smart_ptr&lt;U&gt;&amp; other, T* ptr) 这个构造函数，然后因为返回值优化，连移动都没有发生。如果没有返回值优化，则会发生一次移动构造。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1622942583,"ip_address":"","comment_id":296096,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100040501,"comment_content":"老师这块没想明白\n\n&#47;&#47; 1、运行\nptr3 = ptr1;\n先调用copy构造，为啥还要再调用移动构造？ 之后析构，析构\n\n&#47;&#47;2、而运行\nsmart_ptr&lt;circle&gt; ptr3 =   dynamic_pointer_cast&lt;circle&gt;(ptr2);\n先调用移动构造，析构，又调用一次移动构造，析构？\n\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521325,"discussion_content":"结合你的上一个问题，应该是跟返回值优化有关吧。可以看一下第10讲。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622942697,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":286087,"user_name":"Geek_43a2d5","can_delete":false,"product_type":"c1","uid":2423526,"ip_address":"","ucode":"33C5B1DB0A5DC4","user_header":"","comment_is_top":false,"comment_ctime":1617154138,"is_pvip":false,"replies":[{"id":103891,"content":"减一引用数就不对了，当然不能减一。两个指针是使用同一个共享计数的。\n\n你再想想？","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1617237750,"ip_address":"","comment_id":286087,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100040501,"comment_content":"有个问题，共享指针 p1 p2\np1 = p2 \n右边指针的共享计数加一 左边计数减一才对啊，从代码中没找到这个减一的操作","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517865,"discussion_content":"减一引用数就不对了，当然不能减一。两个指针是使用同一个共享计数的。\n\n你再想想？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1617237750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284725,"user_name":"大风封","can_delete":false,"product_type":"c1","uid":1071070,"ip_address":"","ucode":"9F4A87C549B115","user_header":"https://static001.geekbang.org/account/avatar/00/10/57/de/4ea51085.jpg","comment_is_top":false,"comment_ctime":1616428842,"is_pvip":false,"replies":[{"id":103458,"content":"抱歉，没有。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1616657677,"ip_address":"","comment_id":284725,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100040501,"comment_content":"老师有星球么","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517865,"discussion_content":"减一引用数就不对了，当然不能减一。两个指针是使用同一个共享计数的。\n\n你再想想？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1617237750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":283303,"user_name":"码匠许师傅","can_delete":false,"product_type":"c1","uid":1260213,"ip_address":"","ucode":"3A470CAC0ADAC4","user_header":"https://static001.geekbang.org/account/avatar/00/13/3a/b5/22d74b60.jpg","comment_is_top":false,"comment_ctime":1615698719,"is_pvip":false,"replies":[{"id":102794,"content":"比较运算符是有意义的，但下标则是有问题的。目前只能放一个元素，要下标干嘛？:-)","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1615735987,"ip_address":"","comment_id":283303,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100040501,"comment_content":"还需要添加比较运算符重载函数、下标运算符","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517445,"discussion_content":"抱歉，没有。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616657677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":279878,"user_name":"Geek_227a72","can_delete":false,"product_type":"c1","uid":2417911,"ip_address":"","ucode":"385B764D9AEAE8","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKsI6VdljHFtMx4cgEPpqhXiaIYQicqGcal8sIoBYQZn7tYQyPLH1FuOVP8SaYPghPIsqSa1DWjRT2A/132","comment_is_top":false,"comment_ctime":1613989817,"is_pvip":false,"replies":[{"id":101696,"content":"返回的是新构造的类型转换之后的 smart_ptr。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1614039759,"ip_address":"","comment_id":279878,"utype":1}],"discussion_count":2,"race_medal":0,"score":11,"product_id":100040501,"comment_content":"template &lt;typename T, typename U&gt;\nsmart_ptr&lt;T&gt; dynamic_pointer_cast(\n  const smart_ptr&lt;U&gt;&amp; other)\n{\n  T* ptr =\n    dynamic_cast&lt;T*&gt;(other.get());\n  return smart_ptr&lt;T&gt;(other, ptr);\n}\n老师能解释一下return返回的是什么吗，看不懂","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516985,"discussion_content":"比较运算符是有意义的，但下标则是有问题的。目前只能放一个元素，要下标干嘛？:-)","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1615735987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":279691,"user_name":"Geek_227a72","can_delete":false,"product_type":"c1","uid":2417911,"ip_address":"","ucode":"385B764D9AEAE8","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKsI6VdljHFtMx4cgEPpqhXiaIYQicqGcal8sIoBYQZn7tYQyPLH1FuOVP8SaYPghPIsqSa1DWjRT2A/132","comment_is_top":false,"comment_ctime":1613908195,"is_pvip":false,"replies":[{"id":101602,"content":"对照一下\n\nhttps:&#47;&#47;github.com&#47;adah1972&#47;geek_time_cpp&#47;blob&#47;master&#47;02&#47;test02_shared_ptr.cpp\nhttps:&#47;&#47;github.com&#47;adah1972&#47;geek_time_cpp&#47;tree&#47;master&#47;common\n\n应该就是哪儿代码有个小问题吧。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1613957277,"ip_address":"","comment_id":279691,"utype":1}],"discussion_count":1,"race_medal":0,"score":11,"product_id":100040501,"comment_content":"use count of ptr1 is 1\nuse count of ptr2 was 0\nuse count of ptr2 is now 2\nptr1 is not empty\n~circle()\n\n\n为啥我的没输出“～circle（）”呢？前面的输出都可以","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515904,"discussion_content":"返回的是新构造的类型转换之后的 smart_ptr。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1614039759,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2417911,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKsI6VdljHFtMx4cgEPpqhXiaIYQicqGcal8sIoBYQZn7tYQyPLH1FuOVP8SaYPghPIsqSa1DWjRT2A/132","nickname":"Geek_227a72","note":"","ucode":"385B764D9AEAE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350726,"discussion_content":"看懂了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613991042,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":277279,"user_name":"鸽足轻轻","can_delete":false,"product_type":"c1","uid":1251879,"ip_address":"","ucode":"03C0D150D73273","user_header":"https://static001.geekbang.org/account/avatar/00/13/1a/27/373003d3.jpg","comment_is_top":false,"comment_ctime":1612342830,"is_pvip":false,"replies":[{"id":100646,"content":"你可能需要给出明确的例子才行。\n\n我这儿给一个示范：\n\nhttps:&#47;&#47;godbolt.org&#47;z&#47;h81b47\n\n可以看到，我禁用了 circle 和 shape 的拷贝和移动操作，在智能指针的实现中添加了 Copy 和 Move 的输出字样。在 ptr2 = ptr1; 这一操作中，发生了一次智能指针的拷贝构造。这一拷贝构造的原因，点击“CppInsights”按钮可以看得很清楚：编译器根据类型要求，最后生成的是\n\nptr2.operator=(smart_ptr&lt;shape&gt;(ptr1));","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1612411777,"ip_address":"","comment_id":277279,"utype":1}],"discussion_count":2,"race_medal":0,"score":11,"product_id":100040501,"comment_content":"老师您好，根据您的代码我写了一个测试case，发现当子类的智能指针转换为父类的智能指针时，还发生了移动构造函数的调用，百思不得其解，请老师解惑","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514982,"discussion_content":"你可能需要给出明确的例子才行。\n\n我这儿给一个示范：\n\nhttps://godbolt.org/z/h81b47\n\n可以看到，我禁用了 circle 和 shape 的拷贝和移动操作，在智能指针的实现中添加了 Copy 和 Move 的输出字样。在 ptr2 = ptr1; 这一操作中，发生了一次智能指针的拷贝构造。这一拷贝构造的原因，点击“CppInsights”按钮可以看得很清楚：编译器根据类型要求，最后生成的是\n\nptr2.operator=(smart_ptr&amp;lt;shape&amp;gt;(ptr1));","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612411777,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2206226,"avatar":"https://static001.geekbang.org/account/avatar/00/21/aa/12/7ac87dd6.jpg","nickname":"无涯","note":"","ucode":"9A3B2774BC6E5F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377647,"discussion_content":"老师您好，我运行您的这段代码也发生了Move移动构造，我想请教一下原因\ncircle()\nuse count of ptr1 is 1\nuse count of ptr2 was 0\nCopy\nMove\nuse count of ptr2 is now 2\n~circle()","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622752422,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":275545,"user_name":"蓦然回首","can_delete":false,"product_type":"c1","uid":1172090,"ip_address":"","ucode":"B17658DCFE6402","user_header":"https://static001.geekbang.org/account/avatar/00/11/e2/7a/38a27e47.jpg","comment_is_top":false,"comment_ctime":1611579290,"is_pvip":true,"replies":[{"id":100034,"content":"标准C++里的东西，什么情况下会抛异常，是有明确规定的。比如，内存分配是可能抛 std::bad_alloc 的。\n\n析构函数 C++ 里约定不应该抛异常（会抛异常的析构函数非常特别，通常不该写；我也从来没写过）。整数的赋值和指针的比较，则是从来不会发生异常的——你指望它们可能发生什么样的异常呢？","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1611638509,"ip_address":"","comment_id":275545,"utype":1}],"discussion_count":2,"race_medal":0,"score":12,"product_id":100040501,"comment_content":"老师，看到上面给的stackoverflow的这个链接，上面也出现类似的情况：\ndumb_array&amp; operator=(const dumb_array&amp; other)\n{\n    if (this != &amp;other) &#47;&#47; (1)\n    {\n        &#47;&#47; get the new data ready before we replace the old\n        std::size_t newSize = other.mSize;\n        int* newArray = newSize ? new int[newSize]() : nullptr; &#47;&#47; (3)\n        std::copy(other.mArray, other.mArray + newSize, newArray); &#47;&#47; (3)\n\n        &#47;&#47; replace the old data (all are non-throwing)\n        delete [] mArray;\n        mSize = newSize;\n        mArray = newArray;\n    }\n\n    return *this;\n}\n\n为啥作者肯定下面这几句一定就不会抛出异常？","like_count":0},{"had_liked":false,"id":270879,"user_name":"薛犇","can_delete":false,"product_type":"c1","uid":2398251,"ip_address":"","ucode":"535E3A30592E05","user_header":"https://static001.geekbang.org/account/avatar/00/24/98/2b/eb097cda.jpg","comment_is_top":false,"comment_ctime":1609310786,"is_pvip":false,"replies":[{"id":98376,"content":"这里面似乎有个问题：当编译器调用你的operator new时，对象还没有进行构造，因此所需的额外内存大小也还不知道。你是怎么解决这个问题的？\n\n按我的理解，这意味着你肯定不能使用标准的 make_shared 了，因为你需要构造之前计算实际需要分配的大小。因此，你不得不写个类似于 make_shared_A 的东西。既然这么写了，那你也可以把它声明成 friend 了。当然，你需要自己需要去实现，可以考虑在我的 smart_ptr 基础上加入统一分配内存的功能。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1609595916,"ip_address":"","comment_id":270879,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100040501,"comment_content":"我有一个特别的classA，包含一个指针指向一片编译时不确定(但构造时根据参数的不同可以确定)大小的内存，为了提高效率重载了new将class本身内容和指向的这片内存一次性分配(也重载了对应的delete)，类似make_shared玩法；同时将构造函数设置为protected使得用户不能直接构造它。用户代码需要使用std::shared_ptr&lt;A&gt;，但因为A不能直接构造导致无法使用make_shared&lt;A&gt;，如果使用shared_ptr&lt;A&gt;(new A)的话计数与内容块又分开变成两次分配了。请教一下这种奇葩状况下有无可能通过外部包装(和&#47;或 较少内部改动)，使得make_shared&lt;A&gt;仅有一次内存分配提高效率？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512778,"discussion_content":"这里面似乎有个问题：当编译器调用你的operator new时，对象还没有进行构造，因此所需的额外内存大小也还不知道。你是怎么解决这个问题的？\n\n按我的理解，这意味着你肯定不能使用标准的 make_shared 了，因为你需要构造之前计算实际需要分配的大小。因此，你不得不写个类似于 make_shared_A 的东西。既然这么写了，那你也可以把它声明成 friend 了。当然，你需要自己需要去实现，可以考虑在我的 smart_ptr 基础上加入统一分配内存的功能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609595916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":265734,"user_name":"ck","can_delete":false,"product_type":"c1","uid":1051146,"ip_address":"","ucode":"2873489EF6E661","user_header":"https://static001.geekbang.org/account/avatar/00/10/0a/0a/92a663ae.jpg","comment_is_top":false,"comment_ctime":1606996851,"is_pvip":false,"replies":[{"id":96758,"content":"我放了我的可工作代码到 Godbolt 上，你可以跟你的对照看看：\n\nhttps:&#47;&#47;godbolt.org&#47;z&#47;oGofeh","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1607347302,"ip_address":"","comment_id":265734,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100040501,"comment_content":"构造和赋值使用以下原型：\nsmart_ptr(smart_ptr&amp;&amp; other)\nsmart_ptr&amp; operator=(smart_ptr rhs)\n实际验证和下面的结果不符。\nsmart_ptr&lt;shape&gt; ptr1{create_shape(shape_type::circle)};\nsmart_ptr&lt;shape&gt; ptr2{ptr1};             &#47;&#47; 编译出错 （拷贝构造delete, 验证ok）\nsmart_ptr&lt;shape&gt; ptr3;\nptr3 = ptr1;                             &#47;&#47; 编译出错 （入参匹配为引用，验证ok）\nptr3 = std::move(ptr1);                  &#47;&#47; OK，可以 (实际编译出错）\n\nsmart_ptr&lt;shape&gt; ptr4{std::move(ptr3)};  &#47;&#47; OK，可以\n\ntest.cpp:68:26: error: ambiguous overload for ‘operator=’ (operand types are ‘smart_ptr&lt;shape&gt;’ and ‘std::remove_reference&lt;smart_ptr&lt;shape&gt;&amp;&gt;::type {aka smart_ptr&lt;shape&gt;}’)\n     ptr3 = std::move(ptr1);                  &#47;&#47; OK，可以\n                          ^\ntest.cpp:10:16: note: candidate: smart_ptr&lt;T&gt;&amp; smart_ptr&lt;T&gt;::operator=(const smart_ptr&lt;T&gt;&amp;) [with T = shape] &lt;deleted&gt;\n     smart_ptr&amp; operator=(const smart_ptr&amp;) = delete;\n                ^~~~~~~~\ntest.cpp:35:16: note: candidate: smart_ptr&lt;T&gt;&amp; smart_ptr&lt;T&gt;::operator=(smart_ptr&lt;T&gt;) [with T = shape]\n     smart_ptr&amp; operator=(smart_ptr rhs)\n\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512778,"discussion_content":"这里面似乎有个问题：当编译器调用你的operator new时，对象还没有进行构造，因此所需的额外内存大小也还不知道。你是怎么解决这个问题的？\n\n按我的理解，这意味着你肯定不能使用标准的 make_shared 了，因为你需要构造之前计算实际需要分配的大小。因此，你不得不写个类似于 make_shared_A 的东西。既然这么写了，那你也可以把它声明成 friend 了。当然，你需要自己需要去实现，可以考虑在我的 smart_ptr 基础上加入统一分配内存的功能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609595916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":264744,"user_name":"浩浩","can_delete":false,"product_type":"c1","uid":1580841,"ip_address":"","ucode":"47558B9C9B7368","user_header":"https://static001.geekbang.org/account/avatar/00/18/1f/29/c7a69190.jpg","comment_is_top":false,"comment_ctime":1606626006,"is_pvip":false,"replies":[{"id":96255,"content":"没有。就是你说的2了。1是一种错误，不算作资源泄露。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1606788611,"ip_address":"","comment_id":264744,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100040501,"comment_content":"老师，文章第二句介绍‘智能指针能从根本上解决资源泄露的可能性’。\n从上一篇文章得知这些‘根本可能性’有两个：1. 对象切片；2.忘记写释放delete代码。\n不知道我的理解是否遗漏了其他‘根本可能性’？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510675,"discussion_content":"没有。就是你说的2了。1是一种错误，不算作资源泄露。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606788611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":246372,"user_name":"lyfei","can_delete":false,"product_type":"c1","uid":1757471,"ip_address":"","ucode":"31ACC702BE6FEA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","comment_is_top":false,"comment_ctime":1599300500,"is_pvip":false,"replies":[{"id":90611,"content":"智能指针本身一般也是存储在栈上的。跟你的例子一样，只有它指向的对象在堆上。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1599437737,"ip_address":"","comment_id":246372,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100040501,"comment_content":"吴老师你好，就是指针本身也是一个变量，它也有一个地址，比如下面的代码：，说明d_tmp指向的是堆内存，它自身存储的位置是栈上。\n    int *d_tmp = new int;\n    std::cout &lt;&lt;  d_tmp &lt;&lt; std::endl; &#47;&#47; 输出：0x10c8050\n    std::cout &lt;&lt; &amp;d_tmp &lt;&lt; std::endl;&#47;&#47; 输出：0x7ffcaac08f10\n问题：那为什么这一讲使用智能指针创建的指针对象，它自身的存储位置就不是栈上了呢？\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510675,"discussion_content":"没有。就是你说的2了。1是一种错误，不算作资源泄露。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606788611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245876,"user_name":"可爱的小奶狗","can_delete":false,"product_type":"c1","uid":1178236,"ip_address":"","ucode":"DC810503571DD2","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/7c/f8f38ad0.jpg","comment_is_top":false,"comment_ctime":1599099823,"is_pvip":false,"replies":[{"id":90415,"content":"1. 你遇上了被称为 the most vexing parse 的问题。直接参看第 8 讲下的“统一初始化”。\n\n2. Shared( Shared&amp; s){} 也算拷贝构造函数。有什么特别问题？","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1599112909,"ip_address":"","comment_id":245876,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100040501,"comment_content":"代码如下（有两个疑惑）：\t\t\nclass Shared{\npublic:\n    int a;\n    Shared(){\n        a = 0;\n        cout &lt;&lt; &quot;constructor is called&quot; &lt;&lt; endl;\n    }\n    Shared(const Shared&amp; s){\n        cout &lt;&lt; &quot;copy constructor is called&quot; &lt;&lt; endl;\n    }\n    Shared(Shared&amp; s){\n        cout &lt;&lt; &quot;copy constructorxx is called&quot; &lt;&lt; endl;\n    }\n\n    ~Shared(){\n        cout &lt;&lt; &quot;dtr is called&quot; &lt;&lt; endl;\n    }\n\n\n\n};\n\n&#47;&#47;test shared ptr\n\nint main(){\n       \n&#47;&#47;疑惑1：\n        Shared s3(Shared());&#47;&#47;老师，这个不是调用copy constructor嘛，为什么被g++识别为这种形式即s3为一个函数定义：Share s3(Shared（*）（Shared）) ?\n        int s5(int());&#47;&#47;这个是仿照上面这个写的，结果s5还是被识别为函数。\n\n\n\n    static semaphore sem;\n    signal(SIGINT, [](int) { sem.post(); });&#47;&#47; 设置退出信号\n    sem.wait();\n\n    return 0;\n\n}\n&#47;&#47;疑惑2：\n&#47;&#47;另外：cppreference上说的copy constructor的形式为\tShared(const Shared&amp; s){}，那Shared( Shared&amp; s){} 也算copy constructor哦？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505000,"discussion_content":"1. 你遇上了被称为 the most vexing parse 的问题。直接参看第 8 讲下的“统一初始化”。\n\n2. Shared( Shared&amp;amp; s){} 也算拷贝构造函数。有什么特别问题？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599112909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245287,"user_name":"wjh_all_in","can_delete":false,"product_type":"c1","uid":1501209,"ip_address":"","ucode":"0480A53AD46C97","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIC2Ww3swYiaMalnpA1f87xgzV8Hs1Y27M2CbNQqgR27Il72hibXn5FvhU7mbr3XKsxYDZdjY4GMDbg/132","comment_is_top":false,"comment_ctime":1598884511,"is_pvip":false,"replies":[{"id":90239,"content":"文中这句话试图解释这个问题：\n\n“上面这个构造函数【模板形式】不被编译器看作移动构造函数，因而不能自动触发删除拷贝构造函数的行为。如果我们想消除代码重复、删除移动构造函数的话，就需要把拷贝构造函数标记成 = delete 了（见“拷贝构造和赋值”一节）。不过，更通用的方式仍然是同时定义标准的拷贝 &#47; 移动构造函数和所需的模板构造函数。下面的引用计数智能指针里我们就需要这么做。”\n\n编译器认为够格称得上拷贝构造函数、移动构造函数的，都是非模板形式。然后又有一些规则决定了是否生成默认的拷贝构造和移动构造函数。如果两者都不生成，那我提供模板就够了。但 C++ 的规则是，拷贝构造一般总会自动生成，除非有用户定义的拷贝构造函数或者生成自动的拷贝构造函数失败；而用户定义的拷贝构造函数，会让编译器**不会**自动生成移动构造函数……\n\n是有点绕，所以这一讲我没有仔细解释。第 9 讲会稍微展开一些，但完整的规则还是要到 cppreference.com 上去查看。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1598932365,"ip_address":"","comment_id":245287,"utype":1}],"discussion_count":3,"race_medal":0,"score":12,"product_id":100040501,"comment_content":"请问一下，smart_ptr\n移动拷贝构造函数没有特例化定义：\ntemplate &lt;typename U&gt;  \nsmart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other) noexcept\n但是拷贝构造函数，需要显式的定义：\nsmart_ptr(const smart_ptr&amp; other)\ntemplate &lt;typename U&gt;  \nsmart_ptr(const smart_ptr&lt;U&gt;&amp; other) noexcept\n\n上面这个区别，是什么原因？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504832,"discussion_content":"文中这句话试图解释这个问题：\n\n“上面这个构造函数【模板形式】不被编译器看作移动构造函数，因而不能自动触发删除拷贝构造函数的行为。如果我们想消除代码重复、删除移动构造函数的话，就需要把拷贝构造函数标记成 = delete 了（见“拷贝构造和赋值”一节）。不过，更通用的方式仍然是同时定义标准的拷贝 / 移动构造函数和所需的模板构造函数。下面的引用计数智能指针里我们就需要这么做。”\n\n编译器认为够格称得上拷贝构造函数、移动构造函数的，都是非模板形式。然后又有一些规则决定了是否生成默认的拷贝构造和移动构造函数。如果两者都不生成，那我提供模板就够了。但 C++ 的规则是，拷贝构造一般总会自动生成，除非有用户定义的拷贝构造函数或者生成自动的拷贝构造函数失败；而用户定义的拷贝构造函数，会让编译器**不会**自动生成移动构造函数……\n\n是有点绕，所以这一讲我没有仔细解释。第 9 讲会稍微展开一些，但完整的规则还是要到 cppreference.com 上去查看。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598932365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1501209,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIC2Ww3swYiaMalnpA1f87xgzV8Hs1Y27M2CbNQqgR27Il72hibXn5FvhU7mbr3XKsxYDZdjY4GMDbg/132","nickname":"wjh_all_in","note":"","ucode":"0480A53AD46C97","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302704,"discussion_content":"是有点绕，我自己也代码实验了，移动语意的场景，会按照模板定义生成代码\n但是拷贝构造场景，不支持按照模板生成","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599012536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1501209,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIC2Ww3swYiaMalnpA1f87xgzV8Hs1Y27M2CbNQqgR27Il72hibXn5FvhU7mbr3XKsxYDZdjY4GMDbg/132","nickname":"wjh_all_in","note":"","ucode":"0480A53AD46C97","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303012,"discussion_content":"拷贝构造场景，编译器认为模板不是拷贝构造函数。如果我不提供的话，编译器会默认生成一个（错误的）。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599113499,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":302704,"ip_address":"","group_id":0},"score":303012,"extra":""}]}]},{"had_liked":false,"id":243207,"user_name":"群","can_delete":false,"product_type":"c1","uid":1843313,"ip_address":"","ucode":"F8A363F19DAB9B","user_header":"https://static001.geekbang.org/account/avatar/00/1c/20/71/ad3465c0.jpg","comment_is_top":false,"comment_ctime":1597993325,"is_pvip":false,"replies":[{"id":89664,"content":"是最后放GitHub版本的代码还是什么版本的？什么平台下的什么编译器？最终版都应该是正常运行不出错的。我在三个平台的三种编译器上测过。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1598007208,"ip_address":"","comment_id":243207,"utype":1}],"discussion_count":2,"race_medal":0,"score":12,"product_id":100040501,"comment_content":"老师,在智能指针测试代码时,其中第19行, \nptr2 = ptr1; &#47;&#47; 这一句 会报错 Segmentation fault,其他的测试都可通过,均可以输出其 use_count()值.\n搞不清什么原因,ptr1指向的是smart_ptr&lt;circle&gt; , 而 ptr2指向的是smart_ptr&lt;shape&gt;,这里,ptr1可以直接赋给ptr2吗??","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504221,"discussion_content":"是最后放GitHub版本的代码还是什么版本的？什么平台下的什么编译器？最终版都应该是正常运行不出错的。我在三个平台的三种编译器上测过。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598007208,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1843313,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/20/71/ad3465c0.jpg","nickname":"群","note":"","ucode":"F8A363F19DAB9B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300281,"discussion_content":"嗯嗯，我找到老师您的代码看了，是我自己写的问题，谢谢老师及时解答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598009876,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225571,"user_name":"彭越","can_delete":false,"product_type":"c1","uid":1052602,"ip_address":"","ucode":"38155338D292A5","user_header":"https://static001.geekbang.org/account/avatar/00/10/0f/ba/a2531cf0.jpg","comment_is_top":false,"comment_ctime":1591791624,"is_pvip":false,"replies":[{"id":83136,"content":"跟C++98这方面没区别，我这个实现里shared_count_一直可能有野指针的（不止这一处有这种情况）。不过，我从来不直接用shared_count_，永远是先看ptr_的值再操作，所以应该没有问题。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1591834887,"ip_address":"","comment_id":225571,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100040501,"comment_content":"template &lt;typename U&gt;\n smart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other) noexcept  {    \n     ptr_ = other.ptr_;   \n     if (ptr_) {\n           shared_count_ =        other.shared_count_;\n           other.ptr_ = nullptr;   \n      }  \n}\n\n老师我对C++11以后的特性不是非常熟悉，这个移动构造函数的other.shared_count不用也设置为nullptr吗？会不会成为野指针？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504221,"discussion_content":"是最后放GitHub版本的代码还是什么版本的？什么平台下的什么编译器？最终版都应该是正常运行不出错的。我在三个平台的三种编译器上测过。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598007208,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1843313,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/20/71/ad3465c0.jpg","nickname":"群","note":"","ucode":"F8A363F19DAB9B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300281,"discussion_content":"嗯嗯，我找到老师您的代码看了，是我自己写的问题，谢谢老师及时解答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598009876,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224594,"user_name":"可爱的小奶狗","can_delete":false,"product_type":"c1","uid":1178236,"ip_address":"","ucode":"DC810503571DD2","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/7c/f8f38ad0.jpg","comment_is_top":false,"comment_ctime":1591455106,"is_pvip":false,"replies":[{"id":82729,"content":"对没有调用拷贝构造和拷贝赋值的理解正确。\n\n但是，目前的拷贝赋值实现是不对的。加上引用之后，现在你执行 a = b 时，实际上是交换了 a 和 b 的内容。这显然不是 a = b 该做的事情。原先的使用值而不是引用的实现是对的。如果你想改用引用，就不应该继续使用交换这种方式了：\n\n    A&amp; operator=(const A&amp; other)\n    {\n        if (this != &amp;other) {\n            s1 = other.s1;\n            n = other.n;\n        }\n        return *this;\n    }\n\n注意两行的赋值顺序如果交换一下的话，异常安全性就不能得到保证了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1591539148,"ip_address":"","comment_id":224594,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100040501,"comment_content":"#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;algorithm&gt;\n\nclass A {\npublic:\n    int n;\n    std::string s1;\n\n    &#47;&#47;在加了copy constructor时，必须显式加入constructor,编译器不会再隐式提供constructor\n    A() {}\n\n    &#47;&#47;copy constructor\n    A(const A &amp;a) {\n        std::cout &lt;&lt; &quot;copy constructor of A\\n&quot;;\n    }\n\n    &#47;&#47; user-defined copy assignment, copy-and-swap form\n    A &amp;operator=(A&amp; other) {\n        std::cout &lt;&lt; &quot;copy assignment of A\\n&quot;;\n        std::swap(n, other.n);\n        std::swap(s1, other.s1);\n        return *this;\n    }\n};\nint main() {\n\n    A  a2;\n\n    A &amp;a1 = a2;&#47;&#47;a1是引用，a2是值，所以不会调用copy assignment，也不会调用 copy constructor\n    A &amp;a3 = a1;&#47;&#47;a1在这里不是引用，而a3是引用，所以不会调用copy assignment，也不会调用 copy constructor\n}\n老师，这样理解（代码后的关于没有调用copy assginment,copy constructor的理解）对不？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497901,"discussion_content":"跟C++98这方面没区别，我这个实现里shared_count_一直可能有野指针的（不止这一处有这种情况）。不过，我从来不直接用shared_count_，永远是先看ptr_的值再操作，所以应该没有问题。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591834887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":275545,"user_name":"蓦然回首","can_delete":false,"product_type":"c1","uid":1172090,"ip_address":"","ucode":"B17658DCFE6402","user_header":"https://static001.geekbang.org/account/avatar/00/11/e2/7a/38a27e47.jpg","comment_is_top":false,"comment_ctime":1611579290,"is_pvip":true,"replies":[{"id":100034,"content":"标准C++里的东西，什么情况下会抛异常，是有明确规定的。比如，内存分配是可能抛 std::bad_alloc 的。\n\n析构函数 C++ 里约定不应该抛异常（会抛异常的析构函数非常特别，通常不该写；我也从来没写过）。整数的赋值和指针的比较，则是从来不会发生异常的——你指望它们可能发生什么样的异常呢？","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1611638509,"ip_address":"","comment_id":275545,"utype":1}],"discussion_count":2,"race_medal":0,"score":12,"product_id":100040501,"comment_content":"老师，看到上面给的stackoverflow的这个链接，上面也出现类似的情况：\ndumb_array&amp; operator=(const dumb_array&amp; other)\n{\n    if (this != &amp;other) &#47;&#47; (1)\n    {\n        &#47;&#47; get the new data ready before we replace the old\n        std::size_t newSize = other.mSize;\n        int* newArray = newSize ? new int[newSize]() : nullptr; &#47;&#47; (3)\n        std::copy(other.mArray, other.mArray + newSize, newArray); &#47;&#47; (3)\n\n        &#47;&#47; replace the old data (all are non-throwing)\n        delete [] mArray;\n        mSize = newSize;\n        mArray = newArray;\n    }\n\n    return *this;\n}\n\n为啥作者肯定下面这几句一定就不会抛出异常？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514391,"discussion_content":"标准C++里的东西，什么情况下会抛异常，是有明确规定的。比如，内存分配是可能抛 std::bad_alloc 的。\n\n析构函数 C++ 里约定不应该抛异常（会抛异常的析构函数非常特别，通常不该写；我也从来没写过）。整数的赋值和指针的比较，则是从来不会发生异常的——你指望它们可能发生什么样的异常呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1611638509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1172090,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e2/7a/38a27e47.jpg","nickname":"蓦然回首","note":"","ucode":"B17658DCFE6402","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345044,"discussion_content":"这里，我可能把异常和一切皆有可能发生混在一起了，C++里面的异常应该是应对不正常德情况，而那些一定可能会出现异于正常的情况呢，一般来讲，对于内置类型的基本运算，编译器和CPU已经能够处理的很好了，可以认为绝大多数情况都不可能出问题，基本可以认为不会出异常情况，我们程序员需要关注的是，那些有可能引发异常的情况，就是情况不是这么直接和明确的情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611646224,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":270879,"user_name":"薛犇","can_delete":false,"product_type":"c1","uid":2398251,"ip_address":"","ucode":"535E3A30592E05","user_header":"https://static001.geekbang.org/account/avatar/00/24/98/2b/eb097cda.jpg","comment_is_top":false,"comment_ctime":1609310786,"is_pvip":false,"replies":[{"id":98376,"content":"这里面似乎有个问题：当编译器调用你的operator new时，对象还没有进行构造，因此所需的额外内存大小也还不知道。你是怎么解决这个问题的？\n\n按我的理解，这意味着你肯定不能使用标准的 make_shared 了，因为你需要构造之前计算实际需要分配的大小。因此，你不得不写个类似于 make_shared_A 的东西。既然这么写了，那你也可以把它声明成 friend 了。当然，你需要自己需要去实现，可以考虑在我的 smart_ptr 基础上加入统一分配内存的功能。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1609595916,"ip_address":"","comment_id":270879,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100040501,"comment_content":"我有一个特别的classA，包含一个指针指向一片编译时不确定(但构造时根据参数的不同可以确定)大小的内存，为了提高效率重载了new将class本身内容和指向的这片内存一次性分配(也重载了对应的delete)，类似make_shared玩法；同时将构造函数设置为protected使得用户不能直接构造它。用户代码需要使用std::shared_ptr&lt;A&gt;，但因为A不能直接构造导致无法使用make_shared&lt;A&gt;，如果使用shared_ptr&lt;A&gt;(new A)的话计数与内容块又分开变成两次分配了。请教一下这种奇葩状况下有无可能通过外部包装(和&#47;或 较少内部改动)，使得make_shared&lt;A&gt;仅有一次内存分配提高效率？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514391,"discussion_content":"标准C++里的东西，什么情况下会抛异常，是有明确规定的。比如，内存分配是可能抛 std::bad_alloc 的。\n\n析构函数 C++ 里约定不应该抛异常（会抛异常的析构函数非常特别，通常不该写；我也从来没写过）。整数的赋值和指针的比较，则是从来不会发生异常的——你指望它们可能发生什么样的异常呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1611638509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1172090,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e2/7a/38a27e47.jpg","nickname":"蓦然回首","note":"","ucode":"B17658DCFE6402","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345044,"discussion_content":"这里，我可能把异常和一切皆有可能发生混在一起了，C++里面的异常应该是应对不正常德情况，而那些一定可能会出现异于正常的情况呢，一般来讲，对于内置类型的基本运算，编译器和CPU已经能够处理的很好了，可以认为绝大多数情况都不可能出问题，基本可以认为不会出异常情况，我们程序员需要关注的是，那些有可能引发异常的情况，就是情况不是这么直接和明确的情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611646224,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":265734,"user_name":"ck","can_delete":false,"product_type":"c1","uid":1051146,"ip_address":"","ucode":"2873489EF6E661","user_header":"https://static001.geekbang.org/account/avatar/00/10/0a/0a/92a663ae.jpg","comment_is_top":false,"comment_ctime":1606996851,"is_pvip":false,"replies":[{"id":96758,"content":"我放了我的可工作代码到 Godbolt 上，你可以跟你的对照看看：\n\nhttps:&#47;&#47;godbolt.org&#47;z&#47;oGofeh","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1607347302,"ip_address":"","comment_id":265734,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100040501,"comment_content":"构造和赋值使用以下原型：\nsmart_ptr(smart_ptr&amp;&amp; other)\nsmart_ptr&amp; operator=(smart_ptr rhs)\n实际验证和下面的结果不符。\nsmart_ptr&lt;shape&gt; ptr1{create_shape(shape_type::circle)};\nsmart_ptr&lt;shape&gt; ptr2{ptr1};             &#47;&#47; 编译出错 （拷贝构造delete, 验证ok）\nsmart_ptr&lt;shape&gt; ptr3;\nptr3 = ptr1;                             &#47;&#47; 编译出错 （入参匹配为引用，验证ok）\nptr3 = std::move(ptr1);                  &#47;&#47; OK，可以 (实际编译出错）\n\nsmart_ptr&lt;shape&gt; ptr4{std::move(ptr3)};  &#47;&#47; OK，可以\n\ntest.cpp:68:26: error: ambiguous overload for ‘operator=’ (operand types are ‘smart_ptr&lt;shape&gt;’ and ‘std::remove_reference&lt;smart_ptr&lt;shape&gt;&amp;&gt;::type {aka smart_ptr&lt;shape&gt;}’)\n     ptr3 = std::move(ptr1);                  &#47;&#47; OK，可以\n                          ^\ntest.cpp:10:16: note: candidate: smart_ptr&lt;T&gt;&amp; smart_ptr&lt;T&gt;::operator=(const smart_ptr&lt;T&gt;&amp;) [with T = shape] &lt;deleted&gt;\n     smart_ptr&amp; operator=(const smart_ptr&amp;) = delete;\n                ^~~~~~~~\ntest.cpp:35:16: note: candidate: smart_ptr&lt;T&gt;&amp; smart_ptr&lt;T&gt;::operator=(smart_ptr&lt;T&gt;) [with T = shape]\n     smart_ptr&amp; operator=(smart_ptr rhs)\n\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511026,"discussion_content":"我放了我的可工作代码到 Godbolt 上，你可以跟你的对照看看：\n\nhttps://godbolt.org/z/oGofeh","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607347302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":264744,"user_name":"浩浩","can_delete":false,"product_type":"c1","uid":1580841,"ip_address":"","ucode":"47558B9C9B7368","user_header":"https://static001.geekbang.org/account/avatar/00/18/1f/29/c7a69190.jpg","comment_is_top":false,"comment_ctime":1606626006,"is_pvip":false,"replies":[{"id":96255,"content":"没有。就是你说的2了。1是一种错误，不算作资源泄露。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1606788611,"ip_address":"","comment_id":264744,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100040501,"comment_content":"老师，文章第二句介绍‘智能指针能从根本上解决资源泄露的可能性’。\n从上一篇文章得知这些‘根本可能性’有两个：1. 对象切片；2.忘记写释放delete代码。\n不知道我的理解是否遗漏了其他‘根本可能性’？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511026,"discussion_content":"我放了我的可工作代码到 Godbolt 上，你可以跟你的对照看看：\n\nhttps://godbolt.org/z/oGofeh","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607347302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":246372,"user_name":"lyfei","can_delete":false,"product_type":"c1","uid":1757471,"ip_address":"","ucode":"31ACC702BE6FEA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","comment_is_top":false,"comment_ctime":1599300500,"is_pvip":false,"replies":[{"id":90611,"content":"智能指针本身一般也是存储在栈上的。跟你的例子一样，只有它指向的对象在堆上。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1599437737,"ip_address":"","comment_id":246372,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100040501,"comment_content":"吴老师你好，就是指针本身也是一个变量，它也有一个地址，比如下面的代码：，说明d_tmp指向的是堆内存，它自身存储的位置是栈上。\n    int *d_tmp = new int;\n    std::cout &lt;&lt;  d_tmp &lt;&lt; std::endl; &#47;&#47; 输出：0x10c8050\n    std::cout &lt;&lt; &amp;d_tmp &lt;&lt; std::endl;&#47;&#47; 输出：0x7ffcaac08f10\n问题：那为什么这一讲使用智能指针创建的指针对象，它自身的存储位置就不是栈上了呢？\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505123,"discussion_content":"智能指针本身一般也是存储在栈上的。跟你的例子一样，只有它指向的对象在堆上。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599437737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245876,"user_name":"可爱的小奶狗","can_delete":false,"product_type":"c1","uid":1178236,"ip_address":"","ucode":"DC810503571DD2","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/7c/f8f38ad0.jpg","comment_is_top":false,"comment_ctime":1599099823,"is_pvip":false,"replies":[{"id":90415,"content":"1. 你遇上了被称为 the most vexing parse 的问题。直接参看第 8 讲下的“统一初始化”。\n\n2. Shared( Shared&amp; s){} 也算拷贝构造函数。有什么特别问题？","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1599112909,"ip_address":"","comment_id":245876,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100040501,"comment_content":"代码如下（有两个疑惑）：\t\t\nclass Shared{\npublic:\n    int a;\n    Shared(){\n        a = 0;\n        cout &lt;&lt; &quot;constructor is called&quot; &lt;&lt; endl;\n    }\n    Shared(const Shared&amp; s){\n        cout &lt;&lt; &quot;copy constructor is called&quot; &lt;&lt; endl;\n    }\n    Shared(Shared&amp; s){\n        cout &lt;&lt; &quot;copy constructorxx is called&quot; &lt;&lt; endl;\n    }\n\n    ~Shared(){\n        cout &lt;&lt; &quot;dtr is called&quot; &lt;&lt; endl;\n    }\n\n\n\n};\n\n&#47;&#47;test shared ptr\n\nint main(){\n       \n&#47;&#47;疑惑1：\n        Shared s3(Shared());&#47;&#47;老师，这个不是调用copy constructor嘛，为什么被g++识别为这种形式即s3为一个函数定义：Share s3(Shared（*）（Shared）) ?\n        int s5(int());&#47;&#47;这个是仿照上面这个写的，结果s5还是被识别为函数。\n\n\n\n    static semaphore sem;\n    signal(SIGINT, [](int) { sem.post(); });&#47;&#47; 设置退出信号\n    sem.wait();\n\n    return 0;\n\n}\n&#47;&#47;疑惑2：\n&#47;&#47;另外：cppreference上说的copy constructor的形式为\tShared(const Shared&amp; s){}，那Shared( Shared&amp; s){} 也算copy constructor哦？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505123,"discussion_content":"智能指针本身一般也是存储在栈上的。跟你的例子一样，只有它指向的对象在堆上。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599437737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245287,"user_name":"wjh_all_in","can_delete":false,"product_type":"c1","uid":1501209,"ip_address":"","ucode":"0480A53AD46C97","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIC2Ww3swYiaMalnpA1f87xgzV8Hs1Y27M2CbNQqgR27Il72hibXn5FvhU7mbr3XKsxYDZdjY4GMDbg/132","comment_is_top":false,"comment_ctime":1598884511,"is_pvip":false,"replies":[{"id":90239,"content":"文中这句话试图解释这个问题：\n\n“上面这个构造函数【模板形式】不被编译器看作移动构造函数，因而不能自动触发删除拷贝构造函数的行为。如果我们想消除代码重复、删除移动构造函数的话，就需要把拷贝构造函数标记成 = delete 了（见“拷贝构造和赋值”一节）。不过，更通用的方式仍然是同时定义标准的拷贝 &#47; 移动构造函数和所需的模板构造函数。下面的引用计数智能指针里我们就需要这么做。”\n\n编译器认为够格称得上拷贝构造函数、移动构造函数的，都是非模板形式。然后又有一些规则决定了是否生成默认的拷贝构造和移动构造函数。如果两者都不生成，那我提供模板就够了。但 C++ 的规则是，拷贝构造一般总会自动生成，除非有用户定义的拷贝构造函数或者生成自动的拷贝构造函数失败；而用户定义的拷贝构造函数，会让编译器**不会**自动生成移动构造函数……\n\n是有点绕，所以这一讲我没有仔细解释。第 9 讲会稍微展开一些，但完整的规则还是要到 cppreference.com 上去查看。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1598932365,"ip_address":"","comment_id":245287,"utype":1}],"discussion_count":3,"race_medal":0,"score":12,"product_id":100040501,"comment_content":"请问一下，smart_ptr\n移动拷贝构造函数没有特例化定义：\ntemplate &lt;typename U&gt;  \nsmart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other) noexcept\n但是拷贝构造函数，需要显式的定义：\nsmart_ptr(const smart_ptr&amp; other)\ntemplate &lt;typename U&gt;  \nsmart_ptr(const smart_ptr&lt;U&gt;&amp; other) noexcept\n\n上面这个区别，是什么原因？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505000,"discussion_content":"1. 你遇上了被称为 the most vexing parse 的问题。直接参看第 8 讲下的“统一初始化”。\n\n2. Shared( Shared&amp;amp; s){} 也算拷贝构造函数。有什么特别问题？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599112909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":243207,"user_name":"群","can_delete":false,"product_type":"c1","uid":1843313,"ip_address":"","ucode":"F8A363F19DAB9B","user_header":"https://static001.geekbang.org/account/avatar/00/1c/20/71/ad3465c0.jpg","comment_is_top":false,"comment_ctime":1597993325,"is_pvip":false,"replies":[{"id":89664,"content":"是最后放GitHub版本的代码还是什么版本的？什么平台下的什么编译器？最终版都应该是正常运行不出错的。我在三个平台的三种编译器上测过。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1598007208,"ip_address":"","comment_id":243207,"utype":1}],"discussion_count":2,"race_medal":0,"score":12,"product_id":100040501,"comment_content":"老师,在智能指针测试代码时,其中第19行, \nptr2 = ptr1; &#47;&#47; 这一句 会报错 Segmentation fault,其他的测试都可通过,均可以输出其 use_count()值.\n搞不清什么原因,ptr1指向的是smart_ptr&lt;circle&gt; , 而 ptr2指向的是smart_ptr&lt;shape&gt;,这里,ptr1可以直接赋给ptr2吗??","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504832,"discussion_content":"文中这句话试图解释这个问题：\n\n“上面这个构造函数【模板形式】不被编译器看作移动构造函数，因而不能自动触发删除拷贝构造函数的行为。如果我们想消除代码重复、删除移动构造函数的话，就需要把拷贝构造函数标记成 = delete 了（见“拷贝构造和赋值”一节）。不过，更通用的方式仍然是同时定义标准的拷贝 / 移动构造函数和所需的模板构造函数。下面的引用计数智能指针里我们就需要这么做。”\n\n编译器认为够格称得上拷贝构造函数、移动构造函数的，都是非模板形式。然后又有一些规则决定了是否生成默认的拷贝构造和移动构造函数。如果两者都不生成，那我提供模板就够了。但 C++ 的规则是，拷贝构造一般总会自动生成，除非有用户定义的拷贝构造函数或者生成自动的拷贝构造函数失败；而用户定义的拷贝构造函数，会让编译器**不会**自动生成移动构造函数……\n\n是有点绕，所以这一讲我没有仔细解释。第 9 讲会稍微展开一些，但完整的规则还是要到 cppreference.com 上去查看。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598932365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1501209,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIC2Ww3swYiaMalnpA1f87xgzV8Hs1Y27M2CbNQqgR27Il72hibXn5FvhU7mbr3XKsxYDZdjY4GMDbg/132","nickname":"wjh_all_in","note":"","ucode":"0480A53AD46C97","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302704,"discussion_content":"是有点绕，我自己也代码实验了，移动语意的场景，会按照模板定义生成代码\n但是拷贝构造场景，不支持按照模板生成","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599012536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1501209,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIC2Ww3swYiaMalnpA1f87xgzV8Hs1Y27M2CbNQqgR27Il72hibXn5FvhU7mbr3XKsxYDZdjY4GMDbg/132","nickname":"wjh_all_in","note":"","ucode":"0480A53AD46C97","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303012,"discussion_content":"拷贝构造场景，编译器认为模板不是拷贝构造函数。如果我不提供的话，编译器会默认生成一个（错误的）。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599113499,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":302704,"ip_address":"","group_id":0},"score":303012,"extra":""}]}]},{"had_liked":false,"id":225571,"user_name":"彭越","can_delete":false,"product_type":"c1","uid":1052602,"ip_address":"","ucode":"38155338D292A5","user_header":"https://static001.geekbang.org/account/avatar/00/10/0f/ba/a2531cf0.jpg","comment_is_top":false,"comment_ctime":1591791624,"is_pvip":false,"replies":[{"id":83136,"content":"跟C++98这方面没区别，我这个实现里shared_count_一直可能有野指针的（不止这一处有这种情况）。不过，我从来不直接用shared_count_，永远是先看ptr_的值再操作，所以应该没有问题。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1591834887,"ip_address":"","comment_id":225571,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100040501,"comment_content":"template &lt;typename U&gt;\n smart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other) noexcept  {    \n     ptr_ = other.ptr_;   \n     if (ptr_) {\n           shared_count_ =        other.shared_count_;\n           other.ptr_ = nullptr;   \n      }  \n}\n\n老师我对C++11以后的特性不是非常熟悉，这个移动构造函数的other.shared_count不用也设置为nullptr吗？会不会成为野指针？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497901,"discussion_content":"跟C++98这方面没区别，我这个实现里shared_count_一直可能有野指针的（不止这一处有这种情况）。不过，我从来不直接用shared_count_，永远是先看ptr_的值再操作，所以应该没有问题。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591834887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224594,"user_name":"可爱的小奶狗","can_delete":false,"product_type":"c1","uid":1178236,"ip_address":"","ucode":"DC810503571DD2","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/7c/f8f38ad0.jpg","comment_is_top":false,"comment_ctime":1591455106,"is_pvip":false,"replies":[{"id":82729,"content":"对没有调用拷贝构造和拷贝赋值的理解正确。\n\n但是，目前的拷贝赋值实现是不对的。加上引用之后，现在你执行 a = b 时，实际上是交换了 a 和 b 的内容。这显然不是 a = b 该做的事情。原先的使用值而不是引用的实现是对的。如果你想改用引用，就不应该继续使用交换这种方式了：\n\n    A&amp; operator=(const A&amp; other)\n    {\n        if (this != &amp;other) {\n            s1 = other.s1;\n            n = other.n;\n        }\n        return *this;\n    }\n\n注意两行的赋值顺序如果交换一下的话，异常安全性就不能得到保证了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1591539148,"ip_address":"","comment_id":224594,"utype":1}],"discussion_count":1,"race_medal":0,"score":12,"product_id":100040501,"comment_content":"#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;algorithm&gt;\n\nclass A {\npublic:\n    int n;\n    std::string s1;\n\n    &#47;&#47;在加了copy constructor时，必须显式加入constructor,编译器不会再隐式提供constructor\n    A() {}\n\n    &#47;&#47;copy constructor\n    A(const A &amp;a) {\n        std::cout &lt;&lt; &quot;copy constructor of A\\n&quot;;\n    }\n\n    &#47;&#47; user-defined copy assignment, copy-and-swap form\n    A &amp;operator=(A&amp; other) {\n        std::cout &lt;&lt; &quot;copy assignment of A\\n&quot;;\n        std::swap(n, other.n);\n        std::swap(s1, other.s1);\n        return *this;\n    }\n};\nint main() {\n\n    A  a2;\n\n    A &amp;a1 = a2;&#47;&#47;a1是引用，a2是值，所以不会调用copy assignment，也不会调用 copy constructor\n    A &amp;a3 = a1;&#47;&#47;a1在这里不是引用，而a3是引用，所以不会调用copy assignment，也不会调用 copy constructor\n}\n老师，这样理解（代码后的关于没有调用copy assginment,copy constructor的理解）对不？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497535,"discussion_content":"对没有调用拷贝构造和拷贝赋值的理解正确。\n\n但是，目前的拷贝赋值实现是不对的。加上引用之后，现在你执行 a = b 时，实际上是交换了 a 和 b 的内容。这显然不是 a = b 该做的事情。原先的使用值而不是引用的实现是对的。如果你想改用引用，就不应该继续使用交换这种方式了：\n\n    A&amp;amp; operator=(const A&amp;amp; other)\n    {\n        if (this != &amp;amp;other) {\n            s1 = other.s1;\n            n = other.n;\n        }\n        return *this;\n    }\n\n注意两行的赋值顺序如果交换一下的话，异常安全性就不能得到保证了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591539148,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223018,"user_name":"吃鱼","can_delete":false,"product_type":"c1","uid":2005742,"ip_address":"","ucode":"CB7AC741E0E4B7","user_header":"https://static001.geekbang.org/account/avatar/00/1e/9a/ee/f996f864.jpg","comment_is_top":false,"comment_ctime":1590982342,"is_pvip":false,"replies":[{"id":82205,"content":"同一个对象上的所有智能指针使用的是同一个引用计数，这个计数也是共享的。所以不会有问题。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1590990879,"ip_address":"","comment_id":223018,"utype":1}],"discussion_count":2,"race_medal":0,"score":13,"product_id":100040501,"comment_content":"跟着老师思路走感觉收获很多，特别学到了很正规的编码方式。\n这里还有一个疑问，我们在增加引用计数时只是跟作为拷贝构造函数参数的智能指针同时增加，如果在使用的时候，构造一个源头智能指针，然后通过这个源头智能指针创建一个第二个智能指针，这样使用没有问题，那如果再通过源头智能指针创建更多的智能指针，源头智能指针和最新创建的智能指针引用计数固然增加，可是已创建的智能指针并没有参与到之后智能指针的创建，那么其引用计数就不会增加？或者使用者直接不使用源头智能指针创建之后的智能指针，那么对应同一块内存区域的各个智能指针的引用计数就不统一，这样的情况是否会出问题？","like_count":0},{"had_liked":false,"id":220195,"user_name":"可爱的小奶狗","can_delete":false,"product_type":"c1","uid":1178236,"ip_address":"","ucode":"DC810503571DD2","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/7c/f8f38ad0.jpg","comment_is_top":false,"comment_ctime":1590202251,"is_pvip":false,"replies":[{"id":81351,"content":"smart_ptr&lt;shape&gt; &amp;ptr2{ptr1};&#47;&#47;这是调用了已被删除的拷贝构造函数？为啥能编译通过？\n\n你是把 ptr1 的引用赋给了 ptr2（不是对象，是对象的引用）。没问题啊。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1590247066,"ip_address":"","comment_id":220195,"utype":1}],"discussion_count":1,"race_medal":0,"score":13,"product_id":100040501,"comment_content":"先上一段代码：\nint main(){\n smart_ptr&lt;shape&gt; ptr1{create_shape(shape_type::circle)};\n    smart_ptr&lt;shape&gt; &amp;ptr2{ptr1};&#47;&#47;这是调用了已被删除的拷贝构造函数？为啥能编译通过？\n\n    smart_ptr&lt;shape&gt; ptr3 = ptr1;&#47;&#47;这个是尝试调用了已被删除的拷贝构造函数，报错。\n    ptr3 = smart_ptr&lt;shape&gt;(create_shape(shape_type::circle));\n    ptr3 = std::move(ptr1);                  &#47;&#47; OK，可以\n    smart_ptr&lt;shape&gt; ptr4{std::move(ptr3)};  &#47;&#47; OK，可以\n}\n老师，为啥  smart_ptr&lt;shape&gt; &amp;ptr2{ptr1} 能编译通过？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496079,"discussion_content":"smart_ptr&amp;lt;shape&amp;gt; &amp;amp;ptr2{ptr1};//这是调用了已被删除的拷贝构造函数？为啥能编译通过？\n\n你是把 ptr1 的引用赋给了 ptr2（不是对象，是对象的引用）。没问题啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590247066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219964,"user_name":"Geek_24c4df","can_delete":false,"product_type":"c1","uid":2010573,"ip_address":"","ucode":"BD66D0854804A7","user_header":"","comment_is_top":false,"comment_ctime":1590126832,"is_pvip":false,"replies":[{"id":81302,"content":"再仔细看看。现在是 smart_ptr&lt;T&gt; 要访问另一个 smart_ptr&lt;U&gt; 的成员，跟 shared_count 有啥关系？","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1590214708,"ip_address":"","comment_id":219964,"utype":1}],"discussion_count":1,"race_medal":0,"score":13,"product_id":100040501,"comment_content":"template &lt;typename U&gt;  \nfriend class smart_ptr;\n\n为什么不是在shared_count类中把 smart_ptr定义为友元类呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496079,"discussion_content":"smart_ptr&amp;lt;shape&amp;gt; &amp;amp;ptr2{ptr1};//这是调用了已被删除的拷贝构造函数？为啥能编译通过？\n\n你是把 ptr1 的引用赋给了 ptr2（不是对象，是对象的引用）。没问题啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590247066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219221,"user_name":"可爱的小奶狗","can_delete":false,"product_type":"c1","uid":1178236,"ip_address":"","ucode":"DC810503571DD2","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/7c/f8f38ad0.jpg","comment_is_top":false,"comment_ctime":1589968489,"is_pvip":false,"replies":[{"id":81005,"content":"没看懂你的意思。请给出更明确的代码。\n\n按照 C++ 标准，只有符合下面的条件的成员函数才被认为是移动构造函数：\n\n类 T 的移动构造函数是非模板构造函数，其首个形参是 T&amp;&amp;、const T&amp;&amp;、volatile T&amp;&amp; 或 const volatile T&amp;&amp;，且无其他形参，或剩余形参均有默认值。\n\n见 https:&#47;&#47;zh.cppreference.com&#47;w&#47;cpp&#47;language&#47;move_constructor\n\n我给出的是个模板构造函数 template &lt;typename U&gt; smart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other)。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1589989832,"ip_address":"","comment_id":219221,"utype":1}],"discussion_count":1,"race_medal":0,"score":13,"product_id":100040501,"comment_content":"“上面这个构造函数不被编译器看作移动构造函数，因而不能自动触发删除拷贝构造函数的行为”，这句话是不是有问题？\n我测试了下：在原来的移动构造函数加了&lt;T&gt;,其他什么也没改，smart_ptr&lt;shape&gt; ptr2{ptr1}报的错为：不能调用已删除的拷贝函数(call to impilicitly-deleted construtor of &quot;smart_ptr&lt;shape&gt;&quot;)，是不是说明触发了删除拷贝构造函数？\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495724,"discussion_content":"没看懂你的意思。请给出更明确的代码。\n\n按照 C++ 标准，只有符合下面的条件的成员函数才被认为是移动构造函数：\n\n类 T 的移动构造函数是非模板构造函数，其首个形参是 T&amp;amp;&amp;amp;、const T&amp;amp;&amp;amp;、volatile T&amp;amp;&amp;amp; 或 const volatile T&amp;amp;&amp;amp;，且无其他形参，或剩余形参均有默认值。\n\n见 https://zh.cppreference.com/w/cpp/language/move_constructor\n\n我给出的是个模板构造函数 template &amp;lt;typename U&amp;gt; smart_ptr(smart_ptr&amp;lt;U&amp;gt;&amp;amp;&amp;amp; other)。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589989832,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218193,"user_name":"The Answer........","can_delete":false,"product_type":"c1","uid":2003313,"ip_address":"","ucode":"896638729520A6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/dQQR8nfd3k8zO9Z7TjOxSneFmiarGct9o6JORPrzMyyic8ZnPB97SuvYp544UKCQ24dj2LOvsbUQE3zb1uAGWG7Q/132","comment_is_top":false,"comment_ctime":1589734136,"is_pvip":false,"replies":[{"id":80757,"content":"没有继承关系的话，编译直接就在指针赋值那行上失败了。编译器会帮你检查的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1589802073,"ip_address":"","comment_id":218193,"utype":1}],"discussion_count":2,"race_medal":0,"score":13,"product_id":100040501,"comment_content":"吴老师, 关于智能指针这里实现的隐式转换我有个地方不解.\ntemplate &lt;typename U&gt;  \nsmart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other) noexcept;\n我们不需要判断一下smart_ptr&lt;U&gt;&amp;&amp; other的类型吗. 智能指针other应该是得满足子类和基类的关系才能转换成功吧. 两个完全没有继承关系的类的智能指针也可以转换吗","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495377,"discussion_content":"没有继承关系的话，编译直接就在指针赋值那行上失败了。编译器会帮你检查的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589802073,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2003313,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/dQQR8nfd3k8zO9Z7TjOxSneFmiarGct9o6JORPrzMyyic8ZnPB97SuvYp544UKCQ24dj2LOvsbUQE3zb1uAGWG7Q/132","nickname":"The Answer........","note":"","ucode":"896638729520A6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":268420,"discussion_content":"自己应该找到答案了，参数传递进来不用管类型，因为我们最终还是raw pointer的隐式转换的，raw pointer的隐式转换会有编译器自动判断，所以能转换会成功，不能就会报错，好像是这样.","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589772379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215816,"user_name":"不动声色满心澎湃","can_delete":false,"product_type":"c1","uid":1621658,"ip_address":"","ucode":"80D8F9E49AF7C2","user_header":"https://static001.geekbang.org/account/avatar/00/18/be/9a/b0b89be3.jpg","comment_is_top":false,"comment_ctime":1589109404,"is_pvip":false,"replies":[{"id":80079,"content":"谢谢。😇","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1589257159,"ip_address":"","comment_id":215816,"utype":1}],"discussion_count":1,"race_medal":0,"score":13,"product_id":100040501,"comment_content":"很赞","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494569,"discussion_content":"谢谢。😇","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589257159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215261,"user_name":"河山","can_delete":false,"product_type":"c1","uid":1128970,"ip_address":"","ucode":"244F0F35FF4112","user_header":"https://static001.geekbang.org/account/avatar/00/11/3a/0a/91f0d27a.jpg","comment_is_top":false,"comment_ctime":1588943159,"is_pvip":false,"replies":[{"id":79746,"content":"「由于真正多线程安全的版本需要用到我们目前还没学到的知识，我们目前先实现一个简单化的版本」：原子操作的版本见第 20 讲。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1589003614,"ip_address":"","comment_id":215261,"utype":1}],"discussion_count":1,"race_medal":0,"score":13,"product_id":100040501,"comment_content":"好像没做到线程安全？要加原子操作吧","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494375,"discussion_content":"「由于真正多线程安全的版本需要用到我们目前还没学到的知识，我们目前先实现一个简单化的版本」：原子操作的版本见第 20 讲。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589003614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207133,"user_name":"dietcoke","can_delete":false,"product_type":"c1","uid":1217826,"ip_address":"","ucode":"6522B3E23F59DD","user_header":"","comment_is_top":false,"comment_ctime":1587012404,"is_pvip":false,"replies":[{"id":77590,"content":"实际上从形式上讲，2、3 就够了，但由于 2 不被编译器看作是拷贝构造函数，编译器会生成一个缺省的拷贝构造函数，那就会出问题了。而有了 1 之后，编译器就不会生成缺省的移动构造函数了，所以你说的就不必提供了，重载解析能用 3 来代替。\n\n进一步了解可以看第 9 讲，和里面的参考资料。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1587217828,"ip_address":"","comment_id":207133,"utype":1}],"discussion_count":1,"race_medal":0,"score":13,"product_id":100040501,"comment_content":"老师，我想问下最终版本的代码有这三个函数：\n1. smart_ptr(const smart_ptr&amp; other)\n2. template&lt;typename U&gt;\n    smart_ptr(const smart_ptr&lt;U&gt;&amp; other)\n3. template&lt;typename U&gt;\n    smart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other)\n那么为什么没有这个函数呢 smart_ptr(smart_ptr&amp;&amp; other) ？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492018,"discussion_content":"实际上从形式上讲，2、3 就够了，但由于 2 不被编译器看作是拷贝构造函数，编译器会生成一个缺省的拷贝构造函数，那就会出问题了。而有了 1 之后，编译器就不会生成缺省的移动构造函数了，所以你说的就不必提供了，重载解析能用 3 来代替。\n\n进一步了解可以看第 9 讲，和里面的参考资料。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587217828,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203658,"user_name":"zg","can_delete":false,"product_type":"c1","uid":1055025,"ip_address":"","ucode":"809277A5F204BD","user_header":"https://static001.geekbang.org/account/avatar/00/10/19/31/b438b9cf.jpg","comment_is_top":false,"comment_ctime":1586248836,"is_pvip":false,"replies":[{"id":76293,"content":"2,3,4？事实上，我试了 GCC、Clang 和 MSVC，没有一个结果是 2,3,4 呢。我看到的计数更大。其中有一种情况是 6,4,2。\n\n6,4,2 的情况还是很容易解释的。每个线程各有一个参数 p，这就是 3 了。每个线程还各有个 lp，所以最多会到 6。每个线程退出的时候，释放两个智能指针，引用计数减 2。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1586345165,"ip_address":"","comment_id":203658,"utype":1}],"discussion_count":1,"race_medal":0,"score":13,"product_id":100040501,"comment_content":"吴老师：\n这一节的内容中的参考资料【2】中的示例代码：\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;thread&gt;\n#include &lt;chrono&gt;\n#include &lt;mutex&gt;\n \nstruct Base\n{\n    Base() { std::cout &lt;&lt; &quot;  Base::Base()\\n&quot;; }\n    &#47;&#47; Note: non-virtual destructor is OK here\n    ~Base() { std::cout &lt;&lt; &quot;  Base::~Base()\\n&quot;; }\n};\n \nstruct Derived: public Base\n{\n    Derived() { std::cout &lt;&lt; &quot;  Derived::Derived()\\n&quot;; }\n    ~Derived() { std::cout &lt;&lt; &quot;  Derived::~Derived()\\n&quot;; }\n};\n \nvoid thr(std::shared_ptr&lt;Base&gt; p)\n{\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    std::shared_ptr&lt;Base&gt; lp = p; &#47;&#47; thread-safe, even though the\n                                  &#47;&#47; shared use_count is incremented\n    {\n        static std::mutex io_mutex;\n        std::lock_guard&lt;std::mutex&gt; lk(io_mutex);\n        std::cout &lt;&lt; &quot;local pointer in a thread:\\n&quot;\n                  &lt;&lt; &quot;  lp.get() = &quot; &lt;&lt; lp.get()\n                  &lt;&lt; &quot;, lp.use_count() = &quot; &lt;&lt; lp.use_count() &lt;&lt; &#39;\\n&#39;;\n    }\n}\n \nint main()\n{\n    std::shared_ptr&lt;Base&gt; p = std::make_shared&lt;Derived&gt;();\n \n    std::cout &lt;&lt; &quot;Created a shared Derived (as a pointer to Base)\\n&quot;\n              &lt;&lt; &quot;  p.get() = &quot; &lt;&lt; p.get()\n              &lt;&lt; &quot;, p.use_count() = &quot; &lt;&lt; p.use_count() &lt;&lt; &#39;\\n&#39;;\n    std::thread t1(thr, p), t2(thr, p), t3(thr, p);\n    p.reset(); &#47;&#47; release ownership from main\n    std::cout &lt;&lt; &quot;Shared ownership between 3 threads and released\\n&quot;\n              &lt;&lt; &quot;ownership from main:\\n&quot;\n              &lt;&lt; &quot;  p.get() = &quot; &lt;&lt; p.get()\n              &lt;&lt; &quot;, p.use_count() = &quot; &lt;&lt; p.use_count() &lt;&lt; &#39;\\n&#39;;\n    t1.join(); t2.join(); t3.join();\n    std::cout &lt;&lt; &quot;All threads completed, the last one deleted Derived\\n&quot;;\n}\n在p.reset()函数后，计数为零了，为什么三个线程中的lp.use_count()的值不是1,2和3，而是2,3和4？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490923,"discussion_content":"2,3,4？事实上，我试了 GCC、Clang 和 MSVC，没有一个结果是 2,3,4 呢。我看到的计数更大。其中有一种情况是 6,4,2。\n\n6,4,2 的情况还是很容易解释的。每个线程各有一个参数 p，这就是 3 了。每个线程还各有个 lp，所以最多会到 6。每个线程退出的时候，释放两个智能指针，引用计数减 2。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586345165,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":195914,"user_name":"hello","can_delete":false,"product_type":"c1","uid":1510495,"ip_address":"","ucode":"C6FC61A90F202B","user_header":"https://static001.geekbang.org/account/avatar/00/17/0c/5f/4cbcbfb9.jpg","comment_is_top":false,"comment_ctime":1585224155,"is_pvip":false,"replies":[{"id":74461,"content":"atomic 要到第 20 讲才讲呢。急的话就先看一下第 20 讲吧。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1585315906,"ip_address":"","comment_id":195914,"utype":1}],"discussion_count":1,"race_medal":0,"score":13,"product_id":100040501,"comment_content":"引用计数为什么可以不使用atomic&lt;long&gt;，而用了long。多线程操作不会出问题吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489191,"discussion_content":"atomic 要到第 20 讲才讲呢。急的话就先看一下第 20 讲吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585315906,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223018,"user_name":"吃鱼","can_delete":false,"product_type":"c1","uid":2005742,"ip_address":"","ucode":"CB7AC741E0E4B7","user_header":"https://static001.geekbang.org/account/avatar/00/1e/9a/ee/f996f864.jpg","comment_is_top":false,"comment_ctime":1590982342,"is_pvip":false,"replies":[{"id":82205,"content":"同一个对象上的所有智能指针使用的是同一个引用计数，这个计数也是共享的。所以不会有问题。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1590990879,"ip_address":"","comment_id":223018,"utype":1}],"discussion_count":2,"race_medal":0,"score":13,"product_id":100040501,"comment_content":"跟着老师思路走感觉收获很多，特别学到了很正规的编码方式。\n这里还有一个疑问，我们在增加引用计数时只是跟作为拷贝构造函数参数的智能指针同时增加，如果在使用的时候，构造一个源头智能指针，然后通过这个源头智能指针创建一个第二个智能指针，这样使用没有问题，那如果再通过源头智能指针创建更多的智能指针，源头智能指针和最新创建的智能指针引用计数固然增加，可是已创建的智能指针并没有参与到之后智能指针的创建，那么其引用计数就不会增加？或者使用者直接不使用源头智能指针创建之后的智能指针，那么对应同一块内存区域的各个智能指针的引用计数就不统一，这样的情况是否会出问题？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496989,"discussion_content":"同一个对象上的所有智能指针使用的是同一个引用计数，这个计数也是共享的。所以不会有问题。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590990879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2005742,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/9a/ee/f996f864.jpg","nickname":"吃鱼","note":"","ucode":"CB7AC741E0E4B7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":277020,"discussion_content":"老师我明白了，共享的 share_count指针，所以没问题，没认真看代码，见笑了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590983407,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220195,"user_name":"可爱的小奶狗","can_delete":false,"product_type":"c1","uid":1178236,"ip_address":"","ucode":"DC810503571DD2","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/7c/f8f38ad0.jpg","comment_is_top":false,"comment_ctime":1590202251,"is_pvip":false,"replies":[{"id":81351,"content":"smart_ptr&lt;shape&gt; &amp;ptr2{ptr1};&#47;&#47;这是调用了已被删除的拷贝构造函数？为啥能编译通过？\n\n你是把 ptr1 的引用赋给了 ptr2（不是对象，是对象的引用）。没问题啊。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1590247066,"ip_address":"","comment_id":220195,"utype":1}],"discussion_count":1,"race_medal":0,"score":13,"product_id":100040501,"comment_content":"先上一段代码：\nint main(){\n smart_ptr&lt;shape&gt; ptr1{create_shape(shape_type::circle)};\n    smart_ptr&lt;shape&gt; &amp;ptr2{ptr1};&#47;&#47;这是调用了已被删除的拷贝构造函数？为啥能编译通过？\n\n    smart_ptr&lt;shape&gt; ptr3 = ptr1;&#47;&#47;这个是尝试调用了已被删除的拷贝构造函数，报错。\n    ptr3 = smart_ptr&lt;shape&gt;(create_shape(shape_type::circle));\n    ptr3 = std::move(ptr1);                  &#47;&#47; OK，可以\n    smart_ptr&lt;shape&gt; ptr4{std::move(ptr3)};  &#47;&#47; OK，可以\n}\n老师，为啥  smart_ptr&lt;shape&gt; &amp;ptr2{ptr1} 能编译通过？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496989,"discussion_content":"同一个对象上的所有智能指针使用的是同一个引用计数，这个计数也是共享的。所以不会有问题。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590990879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2005742,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/9a/ee/f996f864.jpg","nickname":"吃鱼","note":"","ucode":"CB7AC741E0E4B7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":277020,"discussion_content":"老师我明白了，共享的 share_count指针，所以没问题，没认真看代码，见笑了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590983407,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219964,"user_name":"Geek_24c4df","can_delete":false,"product_type":"c1","uid":2010573,"ip_address":"","ucode":"BD66D0854804A7","user_header":"","comment_is_top":false,"comment_ctime":1590126832,"is_pvip":false,"replies":[{"id":81302,"content":"再仔细看看。现在是 smart_ptr&lt;T&gt; 要访问另一个 smart_ptr&lt;U&gt; 的成员，跟 shared_count 有啥关系？","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1590214708,"ip_address":"","comment_id":219964,"utype":1}],"discussion_count":1,"race_medal":0,"score":13,"product_id":100040501,"comment_content":"template &lt;typename U&gt;  \nfriend class smart_ptr;\n\n为什么不是在shared_count类中把 smart_ptr定义为友元类呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496008,"discussion_content":"再仔细看看。现在是 smart_ptr&amp;lt;T&amp;gt; 要访问另一个 smart_ptr&amp;lt;U&amp;gt; 的成员，跟 shared_count 有啥关系？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590214708,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219221,"user_name":"可爱的小奶狗","can_delete":false,"product_type":"c1","uid":1178236,"ip_address":"","ucode":"DC810503571DD2","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/7c/f8f38ad0.jpg","comment_is_top":false,"comment_ctime":1589968489,"is_pvip":false,"replies":[{"id":81005,"content":"没看懂你的意思。请给出更明确的代码。\n\n按照 C++ 标准，只有符合下面的条件的成员函数才被认为是移动构造函数：\n\n类 T 的移动构造函数是非模板构造函数，其首个形参是 T&amp;&amp;、const T&amp;&amp;、volatile T&amp;&amp; 或 const volatile T&amp;&amp;，且无其他形参，或剩余形参均有默认值。\n\n见 https:&#47;&#47;zh.cppreference.com&#47;w&#47;cpp&#47;language&#47;move_constructor\n\n我给出的是个模板构造函数 template &lt;typename U&gt; smart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other)。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1589989832,"ip_address":"","comment_id":219221,"utype":1}],"discussion_count":1,"race_medal":0,"score":13,"product_id":100040501,"comment_content":"“上面这个构造函数不被编译器看作移动构造函数，因而不能自动触发删除拷贝构造函数的行为”，这句话是不是有问题？\n我测试了下：在原来的移动构造函数加了&lt;T&gt;,其他什么也没改，smart_ptr&lt;shape&gt; ptr2{ptr1}报的错为：不能调用已删除的拷贝函数(call to impilicitly-deleted construtor of &quot;smart_ptr&lt;shape&gt;&quot;)，是不是说明触发了删除拷贝构造函数？\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496008,"discussion_content":"再仔细看看。现在是 smart_ptr&amp;lt;T&amp;gt; 要访问另一个 smart_ptr&amp;lt;U&amp;gt; 的成员，跟 shared_count 有啥关系？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590214708,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218193,"user_name":"The Answer........","can_delete":false,"product_type":"c1","uid":2003313,"ip_address":"","ucode":"896638729520A6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/dQQR8nfd3k8zO9Z7TjOxSneFmiarGct9o6JORPrzMyyic8ZnPB97SuvYp544UKCQ24dj2LOvsbUQE3zb1uAGWG7Q/132","comment_is_top":false,"comment_ctime":1589734136,"is_pvip":false,"replies":[{"id":80757,"content":"没有继承关系的话，编译直接就在指针赋值那行上失败了。编译器会帮你检查的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1589802073,"ip_address":"","comment_id":218193,"utype":1}],"discussion_count":2,"race_medal":0,"score":13,"product_id":100040501,"comment_content":"吴老师, 关于智能指针这里实现的隐式转换我有个地方不解.\ntemplate &lt;typename U&gt;  \nsmart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other) noexcept;\n我们不需要判断一下smart_ptr&lt;U&gt;&amp;&amp; other的类型吗. 智能指针other应该是得满足子类和基类的关系才能转换成功吧. 两个完全没有继承关系的类的智能指针也可以转换吗","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495724,"discussion_content":"没看懂你的意思。请给出更明确的代码。\n\n按照 C++ 标准，只有符合下面的条件的成员函数才被认为是移动构造函数：\n\n类 T 的移动构造函数是非模板构造函数，其首个形参是 T&amp;amp;&amp;amp;、const T&amp;amp;&amp;amp;、volatile T&amp;amp;&amp;amp; 或 const volatile T&amp;amp;&amp;amp;，且无其他形参，或剩余形参均有默认值。\n\n见 https://zh.cppreference.com/w/cpp/language/move_constructor\n\n我给出的是个模板构造函数 template &amp;lt;typename U&amp;gt; smart_ptr(smart_ptr&amp;lt;U&amp;gt;&amp;amp;&amp;amp; other)。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589989832,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215816,"user_name":"不动声色满心澎湃","can_delete":false,"product_type":"c1","uid":1621658,"ip_address":"","ucode":"80D8F9E49AF7C2","user_header":"https://static001.geekbang.org/account/avatar/00/18/be/9a/b0b89be3.jpg","comment_is_top":false,"comment_ctime":1589109404,"is_pvip":false,"replies":[{"id":80079,"content":"谢谢。😇","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1589257159,"ip_address":"","comment_id":215816,"utype":1}],"discussion_count":1,"race_medal":0,"score":13,"product_id":100040501,"comment_content":"很赞","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495377,"discussion_content":"没有继承关系的话，编译直接就在指针赋值那行上失败了。编译器会帮你检查的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589802073,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2003313,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/dQQR8nfd3k8zO9Z7TjOxSneFmiarGct9o6JORPrzMyyic8ZnPB97SuvYp544UKCQ24dj2LOvsbUQE3zb1uAGWG7Q/132","nickname":"The Answer........","note":"","ucode":"896638729520A6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":268420,"discussion_content":"自己应该找到答案了，参数传递进来不用管类型，因为我们最终还是raw pointer的隐式转换的，raw pointer的隐式转换会有编译器自动判断，所以能转换会成功，不能就会报错，好像是这样.","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589772379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215261,"user_name":"河山","can_delete":false,"product_type":"c1","uid":1128970,"ip_address":"","ucode":"244F0F35FF4112","user_header":"https://static001.geekbang.org/account/avatar/00/11/3a/0a/91f0d27a.jpg","comment_is_top":false,"comment_ctime":1588943159,"is_pvip":false,"replies":[{"id":79746,"content":"「由于真正多线程安全的版本需要用到我们目前还没学到的知识，我们目前先实现一个简单化的版本」：原子操作的版本见第 20 讲。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1589003614,"ip_address":"","comment_id":215261,"utype":1}],"discussion_count":1,"race_medal":0,"score":13,"product_id":100040501,"comment_content":"好像没做到线程安全？要加原子操作吧","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494569,"discussion_content":"谢谢。😇","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589257159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207133,"user_name":"dietcoke","can_delete":false,"product_type":"c1","uid":1217826,"ip_address":"","ucode":"6522B3E23F59DD","user_header":"","comment_is_top":false,"comment_ctime":1587012404,"is_pvip":false,"replies":[{"id":77590,"content":"实际上从形式上讲，2、3 就够了，但由于 2 不被编译器看作是拷贝构造函数，编译器会生成一个缺省的拷贝构造函数，那就会出问题了。而有了 1 之后，编译器就不会生成缺省的移动构造函数了，所以你说的就不必提供了，重载解析能用 3 来代替。\n\n进一步了解可以看第 9 讲，和里面的参考资料。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1587217828,"ip_address":"","comment_id":207133,"utype":1}],"discussion_count":1,"race_medal":0,"score":13,"product_id":100040501,"comment_content":"老师，我想问下最终版本的代码有这三个函数：\n1. smart_ptr(const smart_ptr&amp; other)\n2. template&lt;typename U&gt;\n    smart_ptr(const smart_ptr&lt;U&gt;&amp; other)\n3. template&lt;typename U&gt;\n    smart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other)\n那么为什么没有这个函数呢 smart_ptr(smart_ptr&amp;&amp; other) ？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494375,"discussion_content":"「由于真正多线程安全的版本需要用到我们目前还没学到的知识，我们目前先实现一个简单化的版本」：原子操作的版本见第 20 讲。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589003614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203658,"user_name":"zg","can_delete":false,"product_type":"c1","uid":1055025,"ip_address":"","ucode":"809277A5F204BD","user_header":"https://static001.geekbang.org/account/avatar/00/10/19/31/b438b9cf.jpg","comment_is_top":false,"comment_ctime":1586248836,"is_pvip":false,"replies":[{"id":76293,"content":"2,3,4？事实上，我试了 GCC、Clang 和 MSVC，没有一个结果是 2,3,4 呢。我看到的计数更大。其中有一种情况是 6,4,2。\n\n6,4,2 的情况还是很容易解释的。每个线程各有一个参数 p，这就是 3 了。每个线程还各有个 lp，所以最多会到 6。每个线程退出的时候，释放两个智能指针，引用计数减 2。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1586345165,"ip_address":"","comment_id":203658,"utype":1}],"discussion_count":1,"race_medal":0,"score":13,"product_id":100040501,"comment_content":"吴老师：\n这一节的内容中的参考资料【2】中的示例代码：\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;thread&gt;\n#include &lt;chrono&gt;\n#include &lt;mutex&gt;\n \nstruct Base\n{\n    Base() { std::cout &lt;&lt; &quot;  Base::Base()\\n&quot;; }\n    &#47;&#47; Note: non-virtual destructor is OK here\n    ~Base() { std::cout &lt;&lt; &quot;  Base::~Base()\\n&quot;; }\n};\n \nstruct Derived: public Base\n{\n    Derived() { std::cout &lt;&lt; &quot;  Derived::Derived()\\n&quot;; }\n    ~Derived() { std::cout &lt;&lt; &quot;  Derived::~Derived()\\n&quot;; }\n};\n \nvoid thr(std::shared_ptr&lt;Base&gt; p)\n{\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    std::shared_ptr&lt;Base&gt; lp = p; &#47;&#47; thread-safe, even though the\n                                  &#47;&#47; shared use_count is incremented\n    {\n        static std::mutex io_mutex;\n        std::lock_guard&lt;std::mutex&gt; lk(io_mutex);\n        std::cout &lt;&lt; &quot;local pointer in a thread:\\n&quot;\n                  &lt;&lt; &quot;  lp.get() = &quot; &lt;&lt; lp.get()\n                  &lt;&lt; &quot;, lp.use_count() = &quot; &lt;&lt; lp.use_count() &lt;&lt; &#39;\\n&#39;;\n    }\n}\n \nint main()\n{\n    std::shared_ptr&lt;Base&gt; p = std::make_shared&lt;Derived&gt;();\n \n    std::cout &lt;&lt; &quot;Created a shared Derived (as a pointer to Base)\\n&quot;\n              &lt;&lt; &quot;  p.get() = &quot; &lt;&lt; p.get()\n              &lt;&lt; &quot;, p.use_count() = &quot; &lt;&lt; p.use_count() &lt;&lt; &#39;\\n&#39;;\n    std::thread t1(thr, p), t2(thr, p), t3(thr, p);\n    p.reset(); &#47;&#47; release ownership from main\n    std::cout &lt;&lt; &quot;Shared ownership between 3 threads and released\\n&quot;\n              &lt;&lt; &quot;ownership from main:\\n&quot;\n              &lt;&lt; &quot;  p.get() = &quot; &lt;&lt; p.get()\n              &lt;&lt; &quot;, p.use_count() = &quot; &lt;&lt; p.use_count() &lt;&lt; &#39;\\n&#39;;\n    t1.join(); t2.join(); t3.join();\n    std::cout &lt;&lt; &quot;All threads completed, the last one deleted Derived\\n&quot;;\n}\n在p.reset()函数后，计数为零了，为什么三个线程中的lp.use_count()的值不是1,2和3，而是2,3和4？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492018,"discussion_content":"实际上从形式上讲，2、3 就够了，但由于 2 不被编译器看作是拷贝构造函数，编译器会生成一个缺省的拷贝构造函数，那就会出问题了。而有了 1 之后，编译器就不会生成缺省的移动构造函数了，所以你说的就不必提供了，重载解析能用 3 来代替。\n\n进一步了解可以看第 9 讲，和里面的参考资料。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587217828,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":195914,"user_name":"hello","can_delete":false,"product_type":"c1","uid":1510495,"ip_address":"","ucode":"C6FC61A90F202B","user_header":"https://static001.geekbang.org/account/avatar/00/17/0c/5f/4cbcbfb9.jpg","comment_is_top":false,"comment_ctime":1585224155,"is_pvip":false,"replies":[{"id":74461,"content":"atomic 要到第 20 讲才讲呢。急的话就先看一下第 20 讲吧。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1585315906,"ip_address":"","comment_id":195914,"utype":1}],"discussion_count":1,"race_medal":0,"score":13,"product_id":100040501,"comment_content":"引用计数为什么可以不使用atomic&lt;long&gt;，而用了long。多线程操作不会出问题吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490923,"discussion_content":"2,3,4？事实上，我试了 GCC、Clang 和 MSVC，没有一个结果是 2,3,4 呢。我看到的计数更大。其中有一种情况是 6,4,2。\n\n6,4,2 的情况还是很容易解释的。每个线程各有一个参数 p，这就是 3 了。每个线程还各有个 lp，所以最多会到 6。每个线程退出的时候，释放两个智能指针，引用计数减 2。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586345165,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187039,"user_name":"宋强","can_delete":false,"product_type":"c1","uid":1564605,"ip_address":"","ucode":"119A0B00ABDA7B","user_header":"","comment_is_top":false,"comment_ctime":1583997621,"is_pvip":false,"replies":[{"id":72220,"content":"删除前面那个会是个错误（我也犯过）。\n\n看文中这段：「需要注意，上面这个构造函数不被编译器看作移动构造函数，因而不能自动触发删除拷贝构造函数的行为。」这种情况下，编译器会默认提供一个（错误的版本）。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1584021542,"ip_address":"","comment_id":187039,"utype":1}],"discussion_count":1,"race_medal":0,"score":14,"product_id":100040501,"comment_content":"请问老师：\nsmart_ptr(const smart_ptr&amp; other) noexcept { ... } \n和\ntemplate &lt;typename U&gt;\nsmart_ptr(const smart_ptr&lt;U&gt;&amp; other) noexcept { ... }\n是不是重复了，保留后面这种泛型就直接可以了","like_count":0},{"had_liked":false,"id":184558,"user_name":"englefly","can_delete":false,"product_type":"c1","uid":1145907,"ip_address":"","ucode":"E3FCF19E618718","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep2gRIticwS6CiatsCiaU4QRjAODKibQevrhSciatrmd90lNIZFxywE9yyZgAxKTmWiaBSH4zZUcRIV46qQ/132","comment_is_top":false,"comment_ctime":1583337379,"is_pvip":false,"replies":[{"id":71419,"content":"没有改s2。改的是s2的一个拷贝。进入函数体时，s2已经被拷贝构造了（smart_ptr rhs）。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1583387211,"ip_address":"","comment_id":184558,"utype":1}],"discussion_count":1,"race_medal":0,"score":14,"product_id":100040501,"comment_content":"老师，关于赋值 =  的实现有一个疑问：\nsmart_ptr&amp; \noperator=(smart_ptr rhs) noexcept { \n        rhs.swap(*this); \n        return *this; \n}\n\n关于这一句：rhs.swap(*this); \n如果执行 s1=s2， 我理解这应该改变s1，但为什么要把s2 的内部指针替换成原来s1的内部指针呢？为什么不是让s1.ptr_ 为空？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486970,"discussion_content":"删除前面那个会是个错误（我也犯过）。\n\n看文中这段：「需要注意，上面这个构造函数不被编译器看作移动构造函数，因而不能自动触发删除拷贝构造函数的行为。」这种情况下，编译器会默认提供一个（错误的版本）。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584021542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177180,"user_name":"凉人。","can_delete":false,"product_type":"c1","uid":1659177,"ip_address":"","ucode":"4DB16004A62015","user_header":"https://static001.geekbang.org/account/avatar/00/19/51/29/24739c58.jpg","comment_is_top":false,"comment_ctime":1581315586,"is_pvip":false,"replies":[{"id":68817,"content":"😇","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1581330689,"ip_address":"","comment_id":177180,"utype":1}],"discussion_count":1,"race_medal":0,"score":14,"product_id":100040501,"comment_content":"很好理解 谢谢老师","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486054,"discussion_content":"没有改s2。改的是s2的一个拷贝。进入函数体时，s2已经被拷贝构造了（smart_ptr rhs）。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583387211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176235,"user_name":"风清扬","can_delete":false,"product_type":"c1","uid":1047043,"ip_address":"","ucode":"651F1390B64953","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fa/03/eba78e43.jpg","comment_is_top":false,"comment_ctime":1580996822,"is_pvip":false,"replies":[{"id":68469,"content":"分行是因为手机屏幕的宽度限制。其他你问的是同一件事，在另外一个评论下回答了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1581033894,"ip_address":"","comment_id":176235,"utype":1}],"discussion_count":1,"race_medal":0,"score":14,"product_id":100040501,"comment_content":" 有编译错误，加了这两行，但是我去掉，编译运行同样是好的。\n  template &lt;typename U&gt;\n  friend class smart_ptr;\n\n  另外还有一个代码风格的问题\n  ~smart_ptr()\n  {\n    if (ptr_ &amp;&amp;\n      !shared_count_\n         -&gt;reduce_count()) {\n      delete ptr_;\n      delete shared_count_;\n    }\n  }\n  \n判断reduce_count()的返回值是不是0，指针和函数调用分开了两行，是不是有点怪怪的。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483332,"discussion_content":"😇","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581330689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176228,"user_name":"风清扬","can_delete":false,"product_type":"c1","uid":1047043,"ip_address":"","ucode":"651F1390B64953","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fa/03/eba78e43.jpg","comment_is_top":false,"comment_ctime":1580995714,"is_pvip":false,"replies":[{"id":68468,"content":"见正文：\n\n错误原因是模板的各个实例间并不天然就有 friend 关系，因而不能互访私有成员 ptr_ 和 shared_count_。我们需要在 smart_ptr 的定义中显式声明：\n  template &lt;typename U&gt;\n  friend class smart_ptr;","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1581033788,"ip_address":"","comment_id":176228,"utype":1}],"discussion_count":1,"race_medal":0,"score":14,"product_id":100040501,"comment_content":"代码列表里27行，这里的  template &lt;typename U&gt;是多余的吧","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483058,"discussion_content":"分行是因为手机屏幕的宽度限制。其他你问的是同一件事，在另外一个评论下回答了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581033894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174050,"user_name":"super-ck","can_delete":false,"product_type":"c1","uid":1307067,"ip_address":"","ucode":"02F036E53E1130","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/ncicjtgbOgxk2V3VWYJQAia7oCycVFr5Zncudb5EYWhQsMte0asAauBDh6ELrJbTwrSnboBpESBibslrcNc5icrAkw/132","comment_is_top":false,"comment_ctime":1579928737,"is_pvip":false,"replies":[{"id":67681,"content":"模板的实例化（instantiation）结果相当于类。不同的实例跟不同的类一样，不能互相访问私有成员。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1579933727,"ip_address":"","comment_id":174050,"utype":1}],"discussion_count":1,"race_medal":0,"score":14,"product_id":100040501,"comment_content":"老师你好，在完整代码27,28行，有一点不懂，在类smart_ptr中用的友元为何还是smart_ptr","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482282,"discussion_content":"模板的实例化（instantiation）结果相当于类。不同的实例跟不同的类一样，不能互相访问私有成员。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1579933727,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":171925,"user_name":"憎爱不关心","can_delete":false,"product_type":"c1","uid":1133580,"ip_address":"","ucode":"A868ACB200C798","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/0c/ada45f25.jpg","comment_is_top":false,"comment_ctime":1579054271,"is_pvip":false,"replies":[{"id":66700,"content":"我们的 swap 是成员函数啊，当然可以访问 private 数据成员。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1579081500,"ip_address":"","comment_id":171925,"utype":1}],"discussion_count":1,"race_medal":0,"score":14,"product_id":100040501,"comment_content":"老师好，在【拷贝构造和赋值】这一章节，第三段代码里的第23行，也就是全篇第一次出现swap函数的地方，swap(ptr_, rhs.ptr_);这个是不是要用 swap(ptr_, rhs.get()),不知道是不是哪里的语法我不清楚，因为ptr_是private，所以有此疑问，谢谢解答。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481549,"discussion_content":"我们的 swap 是成员函数啊，当然可以访问 private 数据成员。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579081500,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168766,"user_name":"布拉姆","can_delete":false,"product_type":"c1","uid":1311125,"ip_address":"","ucode":"479FF27D73BCAD","user_header":"https://static001.geekbang.org/account/avatar/00/14/01/95/fd09e8a8.jpg","comment_is_top":false,"comment_ctime":1578152490,"is_pvip":false,"replies":[{"id":65502,"content":"这个不是什么特殊语法，就按一般的推导规则了。如果等号右边不是 smart_ptr，又有一个适用的单参数非explicit构造函数的话，确实会先构造再交换的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578223587,"ip_address":"","comment_id":168766,"utype":1}],"discussion_count":1,"race_medal":0,"score":14,"product_id":100040501,"comment_content":"  smart_ptr&amp; operator=(smart_ptr rhs)  \n{   \n rhs.swap(*this);   \n return *this;  \n}\nptr3 = ptr1;\n老师，这个参数按值传递。问题：\n当“按值传递”的时候，是一定调用smart_ptr的拷贝构造函数嘛？有没有可能调smart_ptr的构造函数（非copy非赋值）？当然我了解，smart_ptr的构造函数是explicit，只能显式传原始指针，所以找不到构造函数。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480327,"discussion_content":"这个不是什么特殊语法，就按一般的推导规则了。如果等号右边不是 smart_ptr，又有一个适用的单参数非explicit构造函数的话，确实会先构造再交换的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578223587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166100,"user_name":"王旧业","can_delete":false,"product_type":"c1","uid":1013076,"ip_address":"","ucode":"A8DEC38430D007","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/54/73cc7f73.jpg","comment_is_top":false,"comment_ctime":1577403364,"is_pvip":false,"replies":[{"id":63320,"content":"就是字面意思啊😅。要对着代码看。对于参数rhs，如果你赋值时传递的是右值引用，那就引发移动构造，结果就是移动赋值。否则（传递的不是右值，一般情况就是左值引用了），就会引发拷贝构造，结果就是拷贝赋值。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577407689,"ip_address":"","comment_id":166100,"utype":1}],"discussion_count":2,"race_medal":0,"score":14,"product_id":100040501,"comment_content":"&quot;现在赋值函数的行为是移动还是拷贝，完全依赖于构造参数时走的是移动构造还是拷贝构造。&quot;这句话有点绕，老师能再解释下吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479396,"discussion_content":"就是字面意思啊😅。要对着代码看。对于参数rhs，如果你赋值时传递的是右值引用，那就引发移动构造，结果就是移动赋值。否则（传递的不是右值，一般情况就是左值引用了），就会引发拷贝构造，结果就是拷贝赋值。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577407689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1013076,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/75/54/73cc7f73.jpg","nickname":"王旧业","note":"","ucode":"A8DEC38430D007","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":103861,"discussion_content":"是不是说取决于参数类型，如果是一个右值引用，走移动构造;如果不是，走拷贝构造。当然，因为没有提供拷贝构造，拷贝构造被禁用，编译阶段也会报错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577403759,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165880,"user_name":"张珂","can_delete":false,"product_type":"c1","uid":1249512,"ip_address":"","ucode":"E0AFA940BEAC1C","user_header":"https://static001.geekbang.org/account/avatar/00/13/10/e8/172b5915.jpg","comment_is_top":false,"comment_ctime":1577338226,"is_pvip":false,"replies":[{"id":63270,"content":"首先，感谢你的关注和建议。具体问题的回答如下。\n\n1. 这有点是个人风格了。我并不喜欢列举一二三四。学习的关键也是要理解，而不是枚举各种可能性。就跟学外语不应该去背语法规则差不多是一个道理。\n\n2. 好建议，确实有点歧义了。回头我跟编辑讨论一下怎么改。\n\n3. 行长太短，代码中不适合放大段注释，否则看代码本身需要上下翻动了。另外，我期望读者先去看一下代码，试图自己去理解一下，而不是一下子看到我的讲解。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577356774,"ip_address":"","comment_id":165880,"utype":1}],"discussion_count":1,"race_medal":0,"score":14,"product_id":100040501,"comment_content":"想给老师提点建议：\n1，文章中关于拷贝实现那部分标书，老师给出了四个处理的可能性，有点像swich-case的结构，所以我建议突出一下这个“列举”，提升文章逻辑层次。\n比如加上词语“第一、第二、第三、第四”。\n举个例子：“第一种方法：显然是禁止拷贝”。。。。\n“第四种方法，试试在拷贝时转移指针的所有权？”。。。。。\n这样在读的时候，让读者能知道自己仍然处于“可能性遍历中”。\n\n2，加黑加粗的“目前这种惯用法则保证了强异常安全性”里的“这种”很容易被读者误以为指的是前一段包含if (this != &amp;rhs)判断的赋值函数，而老师是指的应该是前前段里的代码+实现描述（也就是第四种拷贝实现）。建议把“如果你学到的赋值函数还有一个类似于。。。”这一段标注成注解段落，改成另一个字体，浅色的，字体小一号；或者是把“目前这种惯用法”改成“而上述代码中的实现”（或者把代码段落都加个序号来引用）。\n\n3，针对代码的解释，尽量放在代码中成为注释，这样读者可以一边看代码一边看解释，更重要的是不用上下来回翻着看了。（代码行数引用方式还是看着不爽快）。另外代码中如果有跟旧代码的比较，尽量也把旧代码也贴出来并注释掉，这样同样也避免来回翻着看。\n\n我是刚买的老师的专栏，看着有些问题就提了出来，望老师见谅~","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479303,"discussion_content":"首先，感谢你的关注和建议。具体问题的回答如下。\n\n1. 这有点是个人风格了。我并不喜欢列举一二三四。学习的关键也是要理解，而不是枚举各种可能性。就跟学外语不应该去背语法规则差不多是一个道理。\n\n2. 好建议，确实有点歧义了。回头我跟编辑讨论一下怎么改。\n\n3. 行长太短，代码中不适合放大段注释，否则看代码本身需要上下翻动了。另外，我期望读者先去看一下代码，试图自己去理解一下，而不是一下子看到我的讲解。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577356774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187039,"user_name":"宋强","can_delete":false,"product_type":"c1","uid":1564605,"ip_address":"","ucode":"119A0B00ABDA7B","user_header":"","comment_is_top":false,"comment_ctime":1583997621,"is_pvip":false,"replies":[{"id":72220,"content":"删除前面那个会是个错误（我也犯过）。\n\n看文中这段：「需要注意，上面这个构造函数不被编译器看作移动构造函数，因而不能自动触发删除拷贝构造函数的行为。」这种情况下，编译器会默认提供一个（错误的版本）。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1584021542,"ip_address":"","comment_id":187039,"utype":1}],"discussion_count":1,"race_medal":0,"score":14,"product_id":100040501,"comment_content":"请问老师：\nsmart_ptr(const smart_ptr&amp; other) noexcept { ... } \n和\ntemplate &lt;typename U&gt;\nsmart_ptr(const smart_ptr&lt;U&gt;&amp; other) noexcept { ... }\n是不是重复了，保留后面这种泛型就直接可以了","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486970,"discussion_content":"删除前面那个会是个错误（我也犯过）。\n\n看文中这段：「需要注意，上面这个构造函数不被编译器看作移动构造函数，因而不能自动触发删除拷贝构造函数的行为。」这种情况下，编译器会默认提供一个（错误的版本）。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584021542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184558,"user_name":"englefly","can_delete":false,"product_type":"c1","uid":1145907,"ip_address":"","ucode":"E3FCF19E618718","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep2gRIticwS6CiatsCiaU4QRjAODKibQevrhSciatrmd90lNIZFxywE9yyZgAxKTmWiaBSH4zZUcRIV46qQ/132","comment_is_top":false,"comment_ctime":1583337379,"is_pvip":false,"replies":[{"id":71419,"content":"没有改s2。改的是s2的一个拷贝。进入函数体时，s2已经被拷贝构造了（smart_ptr rhs）。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1583387211,"ip_address":"","comment_id":184558,"utype":1}],"discussion_count":1,"race_medal":0,"score":14,"product_id":100040501,"comment_content":"老师，关于赋值 =  的实现有一个疑问：\nsmart_ptr&amp; \noperator=(smart_ptr rhs) noexcept { \n        rhs.swap(*this); \n        return *this; \n}\n\n关于这一句：rhs.swap(*this); \n如果执行 s1=s2， 我理解这应该改变s1，但为什么要把s2 的内部指针替换成原来s1的内部指针呢？为什么不是让s1.ptr_ 为空？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486054,"discussion_content":"没有改s2。改的是s2的一个拷贝。进入函数体时，s2已经被拷贝构造了（smart_ptr rhs）。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583387211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177180,"user_name":"凉人。","can_delete":false,"product_type":"c1","uid":1659177,"ip_address":"","ucode":"4DB16004A62015","user_header":"https://static001.geekbang.org/account/avatar/00/19/51/29/24739c58.jpg","comment_is_top":false,"comment_ctime":1581315586,"is_pvip":false,"replies":[{"id":68817,"content":"😇","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1581330689,"ip_address":"","comment_id":177180,"utype":1}],"discussion_count":1,"race_medal":0,"score":14,"product_id":100040501,"comment_content":"很好理解 谢谢老师","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483332,"discussion_content":"😇","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581330689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176235,"user_name":"风清扬","can_delete":false,"product_type":"c1","uid":1047043,"ip_address":"","ucode":"651F1390B64953","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fa/03/eba78e43.jpg","comment_is_top":false,"comment_ctime":1580996822,"is_pvip":false,"replies":[{"id":68469,"content":"分行是因为手机屏幕的宽度限制。其他你问的是同一件事，在另外一个评论下回答了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1581033894,"ip_address":"","comment_id":176235,"utype":1}],"discussion_count":1,"race_medal":0,"score":14,"product_id":100040501,"comment_content":" 有编译错误，加了这两行，但是我去掉，编译运行同样是好的。\n  template &lt;typename U&gt;\n  friend class smart_ptr;\n\n  另外还有一个代码风格的问题\n  ~smart_ptr()\n  {\n    if (ptr_ &amp;&amp;\n      !shared_count_\n         -&gt;reduce_count()) {\n      delete ptr_;\n      delete shared_count_;\n    }\n  }\n  \n判断reduce_count()的返回值是不是0，指针和函数调用分开了两行，是不是有点怪怪的。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483058,"discussion_content":"分行是因为手机屏幕的宽度限制。其他你问的是同一件事，在另外一个评论下回答了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581033894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176228,"user_name":"风清扬","can_delete":false,"product_type":"c1","uid":1047043,"ip_address":"","ucode":"651F1390B64953","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fa/03/eba78e43.jpg","comment_is_top":false,"comment_ctime":1580995714,"is_pvip":false,"replies":[{"id":68468,"content":"见正文：\n\n错误原因是模板的各个实例间并不天然就有 friend 关系，因而不能互访私有成员 ptr_ 和 shared_count_。我们需要在 smart_ptr 的定义中显式声明：\n  template &lt;typename U&gt;\n  friend class smart_ptr;","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1581033788,"ip_address":"","comment_id":176228,"utype":1}],"discussion_count":1,"race_medal":0,"score":14,"product_id":100040501,"comment_content":"代码列表里27行，这里的  template &lt;typename U&gt;是多余的吧","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483056,"discussion_content":"见正文：\n\n错误原因是模板的各个实例间并不天然就有 friend 关系，因而不能互访私有成员 ptr_ 和 shared_count_。我们需要在 smart_ptr 的定义中显式声明：\n  template &amp;lt;typename U&amp;gt;\n  friend class smart_ptr;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581033788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174050,"user_name":"super-ck","can_delete":false,"product_type":"c1","uid":1307067,"ip_address":"","ucode":"02F036E53E1130","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/ncicjtgbOgxk2V3VWYJQAia7oCycVFr5Zncudb5EYWhQsMte0asAauBDh6ELrJbTwrSnboBpESBibslrcNc5icrAkw/132","comment_is_top":false,"comment_ctime":1579928737,"is_pvip":false,"replies":[{"id":67681,"content":"模板的实例化（instantiation）结果相当于类。不同的实例跟不同的类一样，不能互相访问私有成员。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1579933727,"ip_address":"","comment_id":174050,"utype":1}],"discussion_count":1,"race_medal":0,"score":14,"product_id":100040501,"comment_content":"老师你好，在完整代码27,28行，有一点不懂，在类smart_ptr中用的友元为何还是smart_ptr","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483056,"discussion_content":"见正文：\n\n错误原因是模板的各个实例间并不天然就有 friend 关系，因而不能互访私有成员 ptr_ 和 shared_count_。我们需要在 smart_ptr 的定义中显式声明：\n  template &amp;lt;typename U&amp;gt;\n  friend class smart_ptr;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581033788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":171925,"user_name":"憎爱不关心","can_delete":false,"product_type":"c1","uid":1133580,"ip_address":"","ucode":"A868ACB200C798","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/0c/ada45f25.jpg","comment_is_top":false,"comment_ctime":1579054271,"is_pvip":false,"replies":[{"id":66700,"content":"我们的 swap 是成员函数啊，当然可以访问 private 数据成员。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1579081500,"ip_address":"","comment_id":171925,"utype":1}],"discussion_count":1,"race_medal":0,"score":14,"product_id":100040501,"comment_content":"老师好，在【拷贝构造和赋值】这一章节，第三段代码里的第23行，也就是全篇第一次出现swap函数的地方，swap(ptr_, rhs.ptr_);这个是不是要用 swap(ptr_, rhs.get()),不知道是不是哪里的语法我不清楚，因为ptr_是private，所以有此疑问，谢谢解答。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482282,"discussion_content":"模板的实例化（instantiation）结果相当于类。不同的实例跟不同的类一样，不能互相访问私有成员。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1579933727,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168766,"user_name":"布拉姆","can_delete":false,"product_type":"c1","uid":1311125,"ip_address":"","ucode":"479FF27D73BCAD","user_header":"https://static001.geekbang.org/account/avatar/00/14/01/95/fd09e8a8.jpg","comment_is_top":false,"comment_ctime":1578152490,"is_pvip":false,"replies":[{"id":65502,"content":"这个不是什么特殊语法，就按一般的推导规则了。如果等号右边不是 smart_ptr，又有一个适用的单参数非explicit构造函数的话，确实会先构造再交换的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578223587,"ip_address":"","comment_id":168766,"utype":1}],"discussion_count":1,"race_medal":0,"score":14,"product_id":100040501,"comment_content":"  smart_ptr&amp; operator=(smart_ptr rhs)  \n{   \n rhs.swap(*this);   \n return *this;  \n}\nptr3 = ptr1;\n老师，这个参数按值传递。问题：\n当“按值传递”的时候，是一定调用smart_ptr的拷贝构造函数嘛？有没有可能调smart_ptr的构造函数（非copy非赋值）？当然我了解，smart_ptr的构造函数是explicit，只能显式传原始指针，所以找不到构造函数。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481549,"discussion_content":"我们的 swap 是成员函数啊，当然可以访问 private 数据成员。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579081500,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166100,"user_name":"王旧业","can_delete":false,"product_type":"c1","uid":1013076,"ip_address":"","ucode":"A8DEC38430D007","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/54/73cc7f73.jpg","comment_is_top":false,"comment_ctime":1577403364,"is_pvip":false,"replies":[{"id":63320,"content":"就是字面意思啊😅。要对着代码看。对于参数rhs，如果你赋值时传递的是右值引用，那就引发移动构造，结果就是移动赋值。否则（传递的不是右值，一般情况就是左值引用了），就会引发拷贝构造，结果就是拷贝赋值。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577407689,"ip_address":"","comment_id":166100,"utype":1}],"discussion_count":2,"race_medal":0,"score":14,"product_id":100040501,"comment_content":"&quot;现在赋值函数的行为是移动还是拷贝，完全依赖于构造参数时走的是移动构造还是拷贝构造。&quot;这句话有点绕，老师能再解释下吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480327,"discussion_content":"这个不是什么特殊语法，就按一般的推导规则了。如果等号右边不是 smart_ptr，又有一个适用的单参数非explicit构造函数的话，确实会先构造再交换的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578223587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165880,"user_name":"张珂","can_delete":false,"product_type":"c1","uid":1249512,"ip_address":"","ucode":"E0AFA940BEAC1C","user_header":"https://static001.geekbang.org/account/avatar/00/13/10/e8/172b5915.jpg","comment_is_top":false,"comment_ctime":1577338226,"is_pvip":false,"replies":[{"id":63270,"content":"首先，感谢你的关注和建议。具体问题的回答如下。\n\n1. 这有点是个人风格了。我并不喜欢列举一二三四。学习的关键也是要理解，而不是枚举各种可能性。就跟学外语不应该去背语法规则差不多是一个道理。\n\n2. 好建议，确实有点歧义了。回头我跟编辑讨论一下怎么改。\n\n3. 行长太短，代码中不适合放大段注释，否则看代码本身需要上下翻动了。另外，我期望读者先去看一下代码，试图自己去理解一下，而不是一下子看到我的讲解。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577356774,"ip_address":"","comment_id":165880,"utype":1}],"discussion_count":1,"race_medal":0,"score":14,"product_id":100040501,"comment_content":"想给老师提点建议：\n1，文章中关于拷贝实现那部分标书，老师给出了四个处理的可能性，有点像swich-case的结构，所以我建议突出一下这个“列举”，提升文章逻辑层次。\n比如加上词语“第一、第二、第三、第四”。\n举个例子：“第一种方法：显然是禁止拷贝”。。。。\n“第四种方法，试试在拷贝时转移指针的所有权？”。。。。。\n这样在读的时候，让读者能知道自己仍然处于“可能性遍历中”。\n\n2，加黑加粗的“目前这种惯用法则保证了强异常安全性”里的“这种”很容易被读者误以为指的是前一段包含if (this != &amp;rhs)判断的赋值函数，而老师是指的应该是前前段里的代码+实现描述（也就是第四种拷贝实现）。建议把“如果你学到的赋值函数还有一个类似于。。。”这一段标注成注解段落，改成另一个字体，浅色的，字体小一号；或者是把“目前这种惯用法”改成“而上述代码中的实现”（或者把代码段落都加个序号来引用）。\n\n3，针对代码的解释，尽量放在代码中成为注释，这样读者可以一边看代码一边看解释，更重要的是不用上下来回翻着看了。（代码行数引用方式还是看着不爽快）。另外代码中如果有跟旧代码的比较，尽量也把旧代码也贴出来并注释掉，这样同样也避免来回翻着看。\n\n我是刚买的老师的专栏，看着有些问题就提了出来，望老师见谅~","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479396,"discussion_content":"就是字面意思啊😅。要对着代码看。对于参数rhs，如果你赋值时传递的是右值引用，那就引发移动构造，结果就是移动赋值。否则（传递的不是右值，一般情况就是左值引用了），就会引发拷贝构造，结果就是拷贝赋值。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577407689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1013076,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/75/54/73cc7f73.jpg","nickname":"王旧业","note":"","ucode":"A8DEC38430D007","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":103861,"discussion_content":"是不是说取决于参数类型，如果是一个右值引用，走移动构造;如果不是，走拷贝构造。当然，因为没有提供拷贝构造，拷贝构造被禁用，编译阶段也会报错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577403759,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164965,"user_name":"lyfei","can_delete":false,"product_type":"c1","uid":1757471,"ip_address":"","ucode":"31ACC702BE6FEA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","comment_is_top":false,"comment_ctime":1577117296,"is_pvip":false,"replies":[{"id":62941,"content":"赋值就可以了。当然，如果之前的对象引用计数变零的话，就会被自动释放了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577181646,"ip_address":"","comment_id":164965,"utype":1}],"discussion_count":2,"race_medal":0,"score":15,"product_id":100040501,"comment_content":"老师您好，就是如果我们现在使用智能指针指向了一块动态内存。\n比如:smart_ptr&lt;int&gt; test_ptr(new int);\n问题:那我如何再次让test_ptr指向另一块int型动态内存呀？\n也就是定义了一个智能指针，我们是否可以一对多?(A时刻指向一块内存，B时刻指向另一块内存)\n谢谢老师的解答","like_count":0},{"had_liked":false,"id":164962,"user_name":"lyfei","can_delete":false,"product_type":"c1","uid":1757471,"ip_address":"","ucode":"31ACC702BE6FEA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","comment_is_top":false,"comment_ctime":1577116819,"is_pvip":false,"replies":[{"id":62940,"content":"就是普通指针，相对智能指针而言。一般的代码应当只使用 unique_ptr、shared_ptr 之类。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577181561,"ip_address":"","comment_id":164962,"utype":1}],"discussion_count":2,"race_medal":0,"score":15,"product_id":100040501,"comment_content":"老师您好，什么是&quot;裸指针&quot;的定义呀？\n查了下网，我没有找到太明确的定义😂","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478971,"discussion_content":"就是普通指针，相对智能指针而言。一般的代码应当只使用 unique_ptr、shared_ptr 之类。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577181561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":98682,"discussion_content":"嗯嗯，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577181722,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163827,"user_name":"暒","can_delete":false,"product_type":"c1","uid":1547048,"ip_address":"","ucode":"9C956F418C66BB","user_header":"https://static001.geekbang.org/account/avatar/00/17/9b/28/9d89de4d.jpg","comment_is_top":false,"comment_ctime":1576808637,"is_pvip":false,"replies":[{"id":62311,"content":"你试验一下就能看到的。\n\n本质上，对一个内存区域生成一个指针，然后指针被复制，两个对象析构都对这个指针执行 delete，所以 delete 了两次。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576819049,"ip_address":"","comment_id":163827,"utype":1}],"discussion_count":1,"race_medal":0,"score":15,"product_id":100040501,"comment_content":"作者大大，smart_ptr&lt;shape&gt; ptr2{ptr1}; 在编译时不会出错，但在运行时却会有未定义行为——由于会对同一内存释放两次。这句话我看了好多遍都没有懂","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478971,"discussion_content":"就是普通指针，相对智能指针而言。一般的代码应当只使用 unique_ptr、shared_ptr 之类。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577181561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":98682,"discussion_content":"嗯嗯，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577181722,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161771,"user_name":"光城~兴","can_delete":false,"product_type":"c1","uid":1188173,"ip_address":"","ucode":"55A0D25BFCDD47","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/4d/90ea92f8.jpg","comment_is_top":false,"comment_ctime":1576322256,"is_pvip":false,"replies":[{"id":61639,"content":"不需要。C++里面特殊成员函数的默认提供有些复杂的规则，在第 9 讲里有提到。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576389488,"ip_address":"","comment_id":161771,"utype":1}],"discussion_count":1,"race_medal":0,"score":15,"product_id":100040501,"comment_content":"您好，老师，看到您多添加一个不带模板的拷贝构造，目的是防止编译器默认给的拷贝构造，我们是不是也可以给定一个不带参数的移动构造，这样也可以禁止编译器的行为，不知道说得对不，望老师指点。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477851,"discussion_content":"不需要。C++里面特殊成员函数的默认提供有些复杂的规则，在第 9 讲里有提到。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576389488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161619,"user_name":"总统老唐","can_delete":false,"product_type":"c1","uid":1490070,"ip_address":"","ucode":"F2CC66E5BB4871","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/96/c679bb3d.jpg","comment_is_top":false,"comment_ctime":1576250610,"is_pvip":false,"replies":[{"id":61595,"content":"我当然尝试过禁用系统的拷贝构造函数的，发现不可行才用现在的方法的。\n\n对于你的 2 的情况，会出现如果只有左值引用，就没法进行拷贝构造的情况。一般而言，我不写用非 const 左值引用的拷贝构造函数——那意味着就是像 auto_ptr 一样的野蛮，或者 const 不正确了……\n\n真实的代码里，我的拷贝构造永远是用 const 左值引用的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576313889,"ip_address":"","comment_id":161619,"utype":1}],"discussion_count":1,"race_medal":0,"score":15,"product_id":100040501,"comment_content":"吴老师，关于为什么定义了泛型拷贝构造函数，还有定义非泛型构造函数的问题，看到你的回答很收益。另外，又想到，如果是为了避免调用编译器生成的非泛型拷贝构造函数，那可不可以直接显式地把这个函数 delete 掉，所以做了几个试验，对结果有点疑惑：\n有如下两行代码\nsmart_ptr&lt;shape&gt; p1(new shape());\nsmart_ptr&lt;shape&gt; p2(p1);\n1，直接 smart_ptr(const smart_ptr&amp; other) = delete，编译报错，use of deleted function\n2，smart_ptr(const smart_ptr&amp; other) = delete 的同时，定义 smart_ptr(smart_ptr&amp; other) 编译通过，结果正确\n3，smart_ptr(smart_ptr&amp; other) = delete 的同时，定义smart_ptr(const smart_ptr&amp; other)，编译报错，use of deleted function\n\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477786,"discussion_content":"我当然尝试过禁用系统的拷贝构造函数的，发现不可行才用现在的方法的。\n\n对于你的 2 的情况，会出现如果只有左值引用，就没法进行拷贝构造的情况。一般而言，我不写用非 const 左值引用的拷贝构造函数——那意味着就是像 auto_ptr 一样的野蛮，或者 const 不正确了……\n\n真实的代码里，我的拷贝构造永远是用 const 左值引用的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576313889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161233,"user_name":"Alice","can_delete":false,"product_type":"c1","uid":1725046,"ip_address":"","ucode":"F0EDC16AC27088","user_header":"https://static001.geekbang.org/account/avatar/00/1a/52/76/7fb4a7a9.jpg","comment_is_top":false,"comment_ctime":1576152800,"is_pvip":false,"replies":[{"id":61480,"content":"这些是基本技巧，写自己的类的时候基本上都用得到吧……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576168489,"ip_address":"","comment_id":161233,"utype":1}],"discussion_count":1,"race_medal":0,"score":15,"product_id":100040501,"comment_content":"吴老师您好 ，这一节内容写的很有意思呢！让人忍不住一口气读完哈哈😄。大体意思是理解了，不过一些细节还要反复多体会琢磨。想问老师一个问题就是我们这节课讲的这几个点的应用场景都有哪些呢？麻烦老师举几个例子吧，我觉得有场景例子理解起来代入感会强一点，或者说以后遇到类似场景会想起来用这些点。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477650,"discussion_content":"这些是基本技巧，写自己的类的时候基本上都用得到吧……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576168489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159895,"user_name":"凌云","can_delete":false,"product_type":"c1","uid":1326161,"ip_address":"","ucode":"C5D3665C4FED40","user_header":"https://static001.geekbang.org/account/avatar/00/14/3c/51/c324a7de.jpg","comment_is_top":false,"comment_ctime":1575819903,"is_pvip":false,"replies":[{"id":61064,"content":"引用计数的比较复杂，所以单列一下。其他的把少数几段代码一拼就行啦。\n\n另外，从实用的角度，不要用我的代码。这是为课程编写的，没有经过高强度的测试。用你的编译器自带的更健壮。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575855341,"ip_address":"","comment_id":159895,"utype":1}],"discussion_count":1,"race_medal":0,"score":15,"product_id":100040501,"comment_content":"很好,建议auto_ptr, unique_ptr的实现也能像最后的shared_ptr那样整理下,这样就更完美了.","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477202,"discussion_content":"引用计数的比较复杂，所以单列一下。其他的把少数几段代码一拼就行啦。\n\n另外，从实用的角度，不要用我的代码。这是为课程编写的，没有经过高强度的测试。用你的编译器自带的更健壮。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575855341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159430,"user_name":"赖跑跑","can_delete":false,"product_type":"c1","uid":1257805,"ip_address":"","ucode":"FF60F24C0ADD49","user_header":"https://static001.geekbang.org/account/avatar/00/13/31/4d/61a9792b.jpg","comment_is_top":false,"comment_ctime":1575621899,"is_pvip":false,"replies":[{"id":60949,"content":"一个普通指针可没有右值引用的重载啊。必须是对对象（非POD）、有右值引用的重载，移动才有意义。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575632225,"ip_address":"","comment_id":159430,"utype":1}],"discussion_count":1,"race_medal":0,"score":15,"product_id":100040501,"comment_content":"template &lt;typename U&gt;\nsmart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other) noexcept\n{\nptr_ = other.ptr_;   &#47;&#47;这一行为什么不是 ptr_ = std::move(other.ptr_);\n\n}","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477055,"discussion_content":"一个普通指针可没有右值引用的重载啊。必须是对对象（非POD）、有右值引用的重载，移动才有意义。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575632225,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159107,"user_name":"总统老唐","can_delete":false,"product_type":"c1","uid":1490070,"ip_address":"","ucode":"F2CC66E5BB4871","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/96/c679bb3d.jpg","comment_is_top":false,"comment_ctime":1575538846,"is_pvip":false,"replies":[{"id":60871,"content":"排除 this 不能作为变量名的问题，你这么写的话，确实只能先生成一个临时对象（一般不说生成右值），然后调用赋值函数。由于我目前实现的赋值函数并不使用右值引用，所以这个右值会被用来调用模板移动构造函数，然后进入赋值函数，使用交换来得到结果。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575551579,"ip_address":"","comment_id":159107,"utype":1}],"discussion_count":1,"race_medal":0,"score":15,"product_id":100040501,"comment_content":"吴老师，再问一下，最后这4个指针类型转换函数**_pointer_cast, 返回的都是值，那是不是代表如果按照如下方式调用这个函数:\nsmart_ptr&lt;T&gt; this;\nsmart_ptr&lt;U&gt; other(ptr);\nthis = dynamic_pointer_cast&lt;T&gt;(other)\n先要生成一个右值，再调用参数为右值引用的赋值函数？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476952,"discussion_content":"排除 this 不能作为变量名的问题，你这么写的话，确实只能先生成一个临时对象（一般不说生成右值），然后调用赋值函数。由于我目前实现的赋值函数并不使用右值引用，所以这个右值会被用来调用模板移动构造函数，然后进入赋值函数，使用交换来得到结果。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575551579,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158903,"user_name":"我不生产bug，我只是bug的搬运工","can_delete":false,"product_type":"c1","uid":1757474,"ip_address":"","ucode":"C70AEAF23665C8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJKEyibia4u3kq3bia4ZiaARfvj7fRqyAN9DIqaQytdy5IsPsfpl9UCdgiaF88tTyia5w1dBynyzkatDt2A/132","comment_is_top":false,"comment_ctime":1575474922,"is_pvip":false,"replies":[{"id":60824,"content":"可以加。不加没有任何问题。判断全是基于 ptr_ 的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575510316,"ip_address":"","comment_id":158903,"utype":1}],"discussion_count":1,"race_medal":0,"score":15,"product_id":100040501,"comment_content":"smart_ptr 的移动构造是不是少了other.shared_count = nullptr ","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476888,"discussion_content":"可以加。不加没有任何问题。判断全是基于 ptr_ 的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575510316,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164965,"user_name":"lyfei","can_delete":false,"product_type":"c1","uid":1757471,"ip_address":"","ucode":"31ACC702BE6FEA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","comment_is_top":false,"comment_ctime":1577117296,"is_pvip":false,"replies":[{"id":62941,"content":"赋值就可以了。当然，如果之前的对象引用计数变零的话，就会被自动释放了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577181646,"ip_address":"","comment_id":164965,"utype":1}],"discussion_count":2,"race_medal":0,"score":15,"product_id":100040501,"comment_content":"老师您好，就是如果我们现在使用智能指针指向了一块动态内存。\n比如:smart_ptr&lt;int&gt; test_ptr(new int);\n问题:那我如何再次让test_ptr指向另一块int型动态内存呀？\n也就是定义了一个智能指针，我们是否可以一对多?(A时刻指向一块内存，B时刻指向另一块内存)\n谢谢老师的解答","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478972,"discussion_content":"赋值就可以了。当然，如果之前的对象引用计数变零的话，就会被自动释放了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577181646,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":98724,"discussion_content":"嗯嗯，谢谢老师，我再想想","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577183465,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164962,"user_name":"lyfei","can_delete":false,"product_type":"c1","uid":1757471,"ip_address":"","ucode":"31ACC702BE6FEA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","comment_is_top":false,"comment_ctime":1577116819,"is_pvip":false,"replies":[{"id":62940,"content":"就是普通指针，相对智能指针而言。一般的代码应当只使用 unique_ptr、shared_ptr 之类。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577181561,"ip_address":"","comment_id":164962,"utype":1}],"discussion_count":2,"race_medal":0,"score":15,"product_id":100040501,"comment_content":"老师您好，什么是&quot;裸指针&quot;的定义呀？\n查了下网，我没有找到太明确的定义😂","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478972,"discussion_content":"赋值就可以了。当然，如果之前的对象引用计数变零的话，就会被自动释放了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577181646,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":98724,"discussion_content":"嗯嗯，谢谢老师，我再想想","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577183465,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163827,"user_name":"暒","can_delete":false,"product_type":"c1","uid":1547048,"ip_address":"","ucode":"9C956F418C66BB","user_header":"https://static001.geekbang.org/account/avatar/00/17/9b/28/9d89de4d.jpg","comment_is_top":false,"comment_ctime":1576808637,"is_pvip":false,"replies":[{"id":62311,"content":"你试验一下就能看到的。\n\n本质上，对一个内存区域生成一个指针，然后指针被复制，两个对象析构都对这个指针执行 delete，所以 delete 了两次。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576819049,"ip_address":"","comment_id":163827,"utype":1}],"discussion_count":1,"race_medal":0,"score":15,"product_id":100040501,"comment_content":"作者大大，smart_ptr&lt;shape&gt; ptr2{ptr1}; 在编译时不会出错，但在运行时却会有未定义行为——由于会对同一内存释放两次。这句话我看了好多遍都没有懂","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478545,"discussion_content":"你试验一下就能看到的。\n\n本质上，对一个内存区域生成一个指针，然后指针被复制，两个对象析构都对这个指针执行 delete，所以 delete 了两次。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576819049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161771,"user_name":"光城~兴","can_delete":false,"product_type":"c1","uid":1188173,"ip_address":"","ucode":"55A0D25BFCDD47","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/4d/90ea92f8.jpg","comment_is_top":false,"comment_ctime":1576322256,"is_pvip":false,"replies":[{"id":61639,"content":"不需要。C++里面特殊成员函数的默认提供有些复杂的规则，在第 9 讲里有提到。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576389488,"ip_address":"","comment_id":161771,"utype":1}],"discussion_count":1,"race_medal":0,"score":15,"product_id":100040501,"comment_content":"您好，老师，看到您多添加一个不带模板的拷贝构造，目的是防止编译器默认给的拷贝构造，我们是不是也可以给定一个不带参数的移动构造，这样也可以禁止编译器的行为，不知道说得对不，望老师指点。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478545,"discussion_content":"你试验一下就能看到的。\n\n本质上，对一个内存区域生成一个指针，然后指针被复制，两个对象析构都对这个指针执行 delete，所以 delete 了两次。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576819049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161619,"user_name":"总统老唐","can_delete":false,"product_type":"c1","uid":1490070,"ip_address":"","ucode":"F2CC66E5BB4871","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/96/c679bb3d.jpg","comment_is_top":false,"comment_ctime":1576250610,"is_pvip":false,"replies":[{"id":61595,"content":"我当然尝试过禁用系统的拷贝构造函数的，发现不可行才用现在的方法的。\n\n对于你的 2 的情况，会出现如果只有左值引用，就没法进行拷贝构造的情况。一般而言，我不写用非 const 左值引用的拷贝构造函数——那意味着就是像 auto_ptr 一样的野蛮，或者 const 不正确了……\n\n真实的代码里，我的拷贝构造永远是用 const 左值引用的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576313889,"ip_address":"","comment_id":161619,"utype":1}],"discussion_count":1,"race_medal":0,"score":15,"product_id":100040501,"comment_content":"吴老师，关于为什么定义了泛型拷贝构造函数，还有定义非泛型构造函数的问题，看到你的回答很收益。另外，又想到，如果是为了避免调用编译器生成的非泛型拷贝构造函数，那可不可以直接显式地把这个函数 delete 掉，所以做了几个试验，对结果有点疑惑：\n有如下两行代码\nsmart_ptr&lt;shape&gt; p1(new shape());\nsmart_ptr&lt;shape&gt; p2(p1);\n1，直接 smart_ptr(const smart_ptr&amp; other) = delete，编译报错，use of deleted function\n2，smart_ptr(const smart_ptr&amp; other) = delete 的同时，定义 smart_ptr(smart_ptr&amp; other) 编译通过，结果正确\n3，smart_ptr(smart_ptr&amp; other) = delete 的同时，定义smart_ptr(const smart_ptr&amp; other)，编译报错，use of deleted function\n\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477851,"discussion_content":"不需要。C++里面特殊成员函数的默认提供有些复杂的规则，在第 9 讲里有提到。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576389488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161233,"user_name":"Alice","can_delete":false,"product_type":"c1","uid":1725046,"ip_address":"","ucode":"F0EDC16AC27088","user_header":"https://static001.geekbang.org/account/avatar/00/1a/52/76/7fb4a7a9.jpg","comment_is_top":false,"comment_ctime":1576152800,"is_pvip":false,"replies":[{"id":61480,"content":"这些是基本技巧，写自己的类的时候基本上都用得到吧……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576168489,"ip_address":"","comment_id":161233,"utype":1}],"discussion_count":1,"race_medal":0,"score":15,"product_id":100040501,"comment_content":"吴老师您好 ，这一节内容写的很有意思呢！让人忍不住一口气读完哈哈😄。大体意思是理解了，不过一些细节还要反复多体会琢磨。想问老师一个问题就是我们这节课讲的这几个点的应用场景都有哪些呢？麻烦老师举几个例子吧，我觉得有场景例子理解起来代入感会强一点，或者说以后遇到类似场景会想起来用这些点。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477786,"discussion_content":"我当然尝试过禁用系统的拷贝构造函数的，发现不可行才用现在的方法的。\n\n对于你的 2 的情况，会出现如果只有左值引用，就没法进行拷贝构造的情况。一般而言，我不写用非 const 左值引用的拷贝构造函数——那意味着就是像 auto_ptr 一样的野蛮，或者 const 不正确了……\n\n真实的代码里，我的拷贝构造永远是用 const 左值引用的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576313889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159895,"user_name":"凌云","can_delete":false,"product_type":"c1","uid":1326161,"ip_address":"","ucode":"C5D3665C4FED40","user_header":"https://static001.geekbang.org/account/avatar/00/14/3c/51/c324a7de.jpg","comment_is_top":false,"comment_ctime":1575819903,"is_pvip":false,"replies":[{"id":61064,"content":"引用计数的比较复杂，所以单列一下。其他的把少数几段代码一拼就行啦。\n\n另外，从实用的角度，不要用我的代码。这是为课程编写的，没有经过高强度的测试。用你的编译器自带的更健壮。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575855341,"ip_address":"","comment_id":159895,"utype":1}],"discussion_count":1,"race_medal":0,"score":15,"product_id":100040501,"comment_content":"很好,建议auto_ptr, unique_ptr的实现也能像最后的shared_ptr那样整理下,这样就更完美了.","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477650,"discussion_content":"这些是基本技巧，写自己的类的时候基本上都用得到吧……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576168489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159430,"user_name":"赖跑跑","can_delete":false,"product_type":"c1","uid":1257805,"ip_address":"","ucode":"FF60F24C0ADD49","user_header":"https://static001.geekbang.org/account/avatar/00/13/31/4d/61a9792b.jpg","comment_is_top":false,"comment_ctime":1575621899,"is_pvip":false,"replies":[{"id":60949,"content":"一个普通指针可没有右值引用的重载啊。必须是对对象（非POD）、有右值引用的重载，移动才有意义。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575632225,"ip_address":"","comment_id":159430,"utype":1}],"discussion_count":1,"race_medal":0,"score":15,"product_id":100040501,"comment_content":"template &lt;typename U&gt;\nsmart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other) noexcept\n{\nptr_ = other.ptr_;   &#47;&#47;这一行为什么不是 ptr_ = std::move(other.ptr_);\n\n}","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477202,"discussion_content":"引用计数的比较复杂，所以单列一下。其他的把少数几段代码一拼就行啦。\n\n另外，从实用的角度，不要用我的代码。这是为课程编写的，没有经过高强度的测试。用你的编译器自带的更健壮。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575855341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159107,"user_name":"总统老唐","can_delete":false,"product_type":"c1","uid":1490070,"ip_address":"","ucode":"F2CC66E5BB4871","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/96/c679bb3d.jpg","comment_is_top":false,"comment_ctime":1575538846,"is_pvip":false,"replies":[{"id":60871,"content":"排除 this 不能作为变量名的问题，你这么写的话，确实只能先生成一个临时对象（一般不说生成右值），然后调用赋值函数。由于我目前实现的赋值函数并不使用右值引用，所以这个右值会被用来调用模板移动构造函数，然后进入赋值函数，使用交换来得到结果。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575551579,"ip_address":"","comment_id":159107,"utype":1}],"discussion_count":1,"race_medal":0,"score":15,"product_id":100040501,"comment_content":"吴老师，再问一下，最后这4个指针类型转换函数**_pointer_cast, 返回的都是值，那是不是代表如果按照如下方式调用这个函数:\nsmart_ptr&lt;T&gt; this;\nsmart_ptr&lt;U&gt; other(ptr);\nthis = dynamic_pointer_cast&lt;T&gt;(other)\n先要生成一个右值，再调用参数为右值引用的赋值函数？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477055,"discussion_content":"一个普通指针可没有右值引用的重载啊。必须是对对象（非POD）、有右值引用的重载，移动才有意义。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575632225,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158903,"user_name":"我不生产bug，我只是bug的搬运工","can_delete":false,"product_type":"c1","uid":1757474,"ip_address":"","ucode":"C70AEAF23665C8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJKEyibia4u3kq3bia4ZiaARfvj7fRqyAN9DIqaQytdy5IsPsfpl9UCdgiaF88tTyia5w1dBynyzkatDt2A/132","comment_is_top":false,"comment_ctime":1575474922,"is_pvip":false,"replies":[{"id":60824,"content":"可以加。不加没有任何问题。判断全是基于 ptr_ 的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575510316,"ip_address":"","comment_id":158903,"utype":1}],"discussion_count":1,"race_medal":0,"score":15,"product_id":100040501,"comment_content":"smart_ptr 的移动构造是不是少了other.shared_count = nullptr ","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476952,"discussion_content":"排除 this 不能作为变量名的问题，你这么写的话，确实只能先生成一个临时对象（一般不说生成右值），然后调用赋值函数。由于我目前实现的赋值函数并不使用右值引用，所以这个右值会被用来调用模板移动构造函数，然后进入赋值函数，使用交换来得到结果。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575551579,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158844,"user_name":"what are you up","can_delete":false,"product_type":"c1","uid":1196480,"ip_address":"","ucode":"AEEE63C5BB00C2","user_header":"https://static001.geekbang.org/account/avatar/00/12/41/c0/910c4834.jpg","comment_is_top":false,"comment_ctime":1575463711,"is_pvip":false,"replies":[{"id":60822,"content":"定义一下你的拷贝复制的含义。\n\n如果包含 a = b 的形式的话，答案为否。拷贝赋值函数不一定需要调用拷贝构造函数的，虽然我一般这么做。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575510145,"ip_address":"","comment_id":158844,"utype":1}],"discussion_count":1,"race_medal":0,"score":16,"product_id":100040501,"comment_content":"是不是所有的拷贝复制 都会调用拷贝构造函数？","like_count":0},{"had_liked":false,"id":158803,"user_name":"SMTCode","can_delete":false,"product_type":"c1","uid":1109038,"ip_address":"","ucode":"0D837A753E4FAB","user_header":"https://static001.geekbang.org/account/avatar/00/10/ec/2e/49d13bd2.jpg","comment_is_top":false,"comment_ctime":1575455084,"is_pvip":false,"replies":[{"id":60754,"content":"南没事，不难就行。🤣","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575464005,"ip_address":"","comment_id":158803,"utype":1}],"discussion_count":1,"race_medal":0,"score":16,"product_id":100040501,"comment_content":"我太南了～","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476870,"discussion_content":"定义一下你的拷贝复制的含义。\n\n如果包含 a = b 的形式的话，答案为否。拷贝赋值函数不一定需要调用拷贝构造函数的，虽然我一般这么做。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575510145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158777,"user_name":"忆民","can_delete":false,"product_type":"c1","uid":1497815,"ip_address":"","ucode":"E66CEAD1E910C5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJBHLqk9ofIib9pgboMKZhVCia28M3FTf45C1bPrvH5ctCDhfAqS6ia13fQtBWGafADFIQsttJ7rgXwg/132","comment_is_top":false,"comment_ctime":1575449451,"is_pvip":false,"replies":[{"id":60756,"content":"参数类型是没有引用符号的哦。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575464094,"ip_address":"","comment_id":158777,"utype":1}],"discussion_count":1,"race_medal":0,"score":16,"product_id":100040501,"comment_content":"老师这个不理解\nsmart_ptr&amp;  operator=(smart_ptr rhs) noexcept  {    rhs.swap(*this);    return *this;  }\n这个实现，好像时rhs和this交换，彼此指向对方拥有的对象了？是不是又问题？\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476842,"discussion_content":"参数类型是没有引用符号的哦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575464094,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158468,"user_name":"在水一方","can_delete":false,"product_type":"c1","uid":1414215,"ip_address":"","ucode":"D8371EFEBED2C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiboeh23vhCNruZ7odUjROiac6N9fx0VWAE6zBNRxJIJFZspSUTQdgu9ajg4F0fAZgdk1vBsicnib3QQ/132","comment_is_top":false,"comment_ctime":1575378527,"is_pvip":false,"replies":[{"id":60649,"content":"😇","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575380730,"ip_address":"","comment_id":158468,"utype":1}],"discussion_count":1,"race_medal":0,"score":16,"product_id":100040501,"comment_content":"讲解的很好，很深，本来还犹豫，看了这一课，果断入手。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476739,"discussion_content":"😇","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575380730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158346,"user_name":"lyfei","can_delete":false,"product_type":"c1","uid":1757471,"ip_address":"","ucode":"31ACC702BE6FEA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","comment_is_top":false,"comment_ctime":1575360498,"is_pvip":false,"replies":[{"id":60645,"content":"不是。智能指针的构造函数只能接受 new 单个对象的结果指针。你这儿既不是 new 的，又是数组，双重问题。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575378194,"ip_address":"","comment_id":158346,"utype":1}],"discussion_count":4,"race_medal":0,"score":16,"product_id":100040501,"comment_content":"老师你好，我进行下面赋值的时候，为什么出现了double free的问题：\n    int test[10];\n    smart_ptr&lt;int&gt; test_ptr(test);\n这个是浅拷贝出现的问题吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476691,"discussion_content":"不是。智能指针的构造函数只能接受 new 单个对象的结果指针。你这儿既不是 new 的，又是数组，双重问题。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575378194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70733,"discussion_content":"嗯嗯，明白了，谢谢老师的热情回答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575378833,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70678,"discussion_content":"低级错误，低级错误😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575375998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70675,"discussion_content":"嗯嗯，我明白了。\ntest在栈中是自动管理的，系统会释放一次，而smart_ptr的时候又会释放一次，所以就出现了double free的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575375981,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158217,"user_name":"Liang Xu","can_delete":false,"product_type":"c1","uid":1476654,"ip_address":"","ucode":"5EA7072BF69B1A","user_header":"https://static001.geekbang.org/account/avatar/00/16/88/2e/7efef4f0.jpg","comment_is_top":false,"comment_ctime":1575351360,"is_pvip":false,"replies":[{"id":60641,"content":"这就像写一个声明 f(int n); 一样，n 是个形参，不写也可以的。这个 friend 声明也是如此，只是表明这个形式的模板都是朋友，U 可以不写。我只是跟下面的写法保持一致而已。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575377615,"ip_address":"","comment_id":158217,"utype":1}],"discussion_count":1,"race_medal":0,"score":16,"product_id":100040501,"comment_content":"template &lt;typename T&gt;\nclass smart_ptr {\n       public: \n       template &lt;typename U&gt;\n       friend class smart_ptr;\n老师，在这个地方， U 是怎么获取的？ ","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476678,"discussion_content":"这就像写一个声明 f(int n); 一样，n 是个形参，不写也可以的。这个 friend 声明也是如此，只是表明这个形式的模板都是朋友，U 可以不写。我只是跟下面的写法保持一致而已。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575377615,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158213,"user_name":"三味","can_delete":false,"product_type":"c1","uid":1362403,"ip_address":"","ucode":"A580F715D1CC96","user_header":"https://static001.geekbang.org/account/avatar/00/14/c9/e3/28c16afa.jpg","comment_is_top":false,"comment_ctime":1575350662,"is_pvip":false,"replies":[{"id":60626,"content":"讲代码组合，就是要拿过来完全不改就可以用。这点C++已经算是不强的了。你倒好，拿一个别人的类过来就要往里塞个计数？如果没有源码呢？🤪","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575368074,"ip_address":"","comment_id":158213,"utype":1}],"discussion_count":1,"race_medal":0,"score":16,"product_id":100040501,"comment_content":"更喜欢侵入式的智能指针, 引用计数包含在继承的基类中. \n感觉share_ptr中每针对一个新的对象都要new一个引用计数, 这种方法好邪道...\n也可能我一开始接触智能指针, 就是从侵入式的开始的缘故吧...","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476675,"discussion_content":"讲代码组合，就是要拿过来完全不改就可以用。这点C++已经算是不强的了。你倒好，拿一个别人的类过来就要往里塞个计数？如果没有源码呢？🤪","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575368074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158044,"user_name":"熊出没","can_delete":false,"product_type":"c1","uid":1145377,"ip_address":"","ucode":"6E39230CC87808","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/21/a33cc944.jpg","comment_is_top":false,"comment_ctime":1575302220,"is_pvip":false,"replies":[{"id":60582,"content":"没有手误，代码都测试过的。\n\n是因为我偷偷塞了点 C++11的语法？先熟悉起来，后面还会讲到。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575337332,"ip_address":"","comment_id":158044,"utype":1}],"discussion_count":2,"race_medal":0,"score":16,"product_id":100040501,"comment_content":"smart_ptr&lt;shape&gt; ptr1{create_shape(shape_type::circle)};\nsmart_ptr&lt;shape&gt; ptr2{ptr1};\n\n老师 课题开始那里讲解拷贝时 这两行代码是否手误 括号好像不对","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476612,"discussion_content":"没有手误，代码都测试过的。\n\n是因为我偷偷塞了点 C++11的语法？先熟悉起来，后面还会讲到。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575337332,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1145377,"avatar":"https://static001.geekbang.org/account/avatar/00/11/7a/21/a33cc944.jpg","nickname":"熊出没","note":"","ucode":"6E39230CC87808","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70242,"discussion_content":"好的 确实还是有难度 以及 新的语法和概念 以手动验证 对自己要格式化了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575337964,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157576,"user_name":"一天到晚游泳的鱼","can_delete":false,"product_type":"c1","uid":1433982,"ip_address":"","ucode":"1F40AF478D85B9","user_header":"","comment_is_top":false,"comment_ctime":1575200232,"is_pvip":false,"replies":[{"id":60431,"content":"这个智能指针目前不支持数组。C++标准里的智能指针对数组的支持也是到C++17才提供的。作为简化版本，目前也不支持删除器。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575210676,"ip_address":"","comment_id":157576,"utype":1}],"discussion_count":1,"race_medal":0,"score":16,"product_id":100040501,"comment_content":"如果传入的是动态数组的指针 则会造成内存泄漏 所以我觉得还应该增加一个 可以传入删除器以删除动态数组","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476471,"discussion_content":"这个智能指针目前不支持数组。C++标准里的智能指针对数组的支持也是到C++17才提供的。作为简化版本，目前也不支持删除器。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575210676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157563,"user_name":"徐凯","can_delete":false,"product_type":"c1","uid":1244991,"ip_address":"","ucode":"12F82BA3649CD5","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/3f/bbb8a88c.jpg","comment_is_top":false,"comment_ctime":1575194618,"is_pvip":false,"replies":[{"id":60432,"content":"你测试了吗？🧐\n\n我试了你这样的代码是可以工作的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575210955,"ip_address":"","comment_id":157563,"utype":1}],"discussion_count":2,"race_medal":0,"score":16,"product_id":100040501,"comment_content":"老师你的智能指针代码  应该还缺乏了const类型的赋值\n     base* b=new base;\n     const CD* pConst=b;\n上述赋值是合法的而来到智能指针由于SmartPtr&lt;base&gt;、 SmartPtr&lt;const base&gt; 在编译器看来是完全不同的类型下面的操作将会无法编译\n     SmartPtr&lt;base&gt; p1(new base);\n     SmartPtr&lt;const base&gt; p2=p1;","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476471,"discussion_content":"这个智能指针目前不支持数组。C++标准里的智能指针对数组的支持也是到C++17才提供的。作为简化版本，目前也不支持删除器。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575210676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158844,"user_name":"what are you up","can_delete":false,"product_type":"c1","uid":1196480,"ip_address":"","ucode":"AEEE63C5BB00C2","user_header":"https://static001.geekbang.org/account/avatar/00/12/41/c0/910c4834.jpg","comment_is_top":false,"comment_ctime":1575463711,"is_pvip":false,"replies":[{"id":60822,"content":"定义一下你的拷贝复制的含义。\n\n如果包含 a = b 的形式的话，答案为否。拷贝赋值函数不一定需要调用拷贝构造函数的，虽然我一般这么做。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575510145,"ip_address":"","comment_id":158844,"utype":1}],"discussion_count":1,"race_medal":0,"score":16,"product_id":100040501,"comment_content":"是不是所有的拷贝复制 都会调用拷贝构造函数？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476870,"discussion_content":"定义一下你的拷贝复制的含义。\n\n如果包含 a = b 的形式的话，答案为否。拷贝赋值函数不一定需要调用拷贝构造函数的，虽然我一般这么做。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575510145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158803,"user_name":"SMTCode","can_delete":false,"product_type":"c1","uid":1109038,"ip_address":"","ucode":"0D837A753E4FAB","user_header":"https://static001.geekbang.org/account/avatar/00/10/ec/2e/49d13bd2.jpg","comment_is_top":false,"comment_ctime":1575455084,"is_pvip":false,"replies":[{"id":60754,"content":"南没事，不难就行。🤣","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575464005,"ip_address":"","comment_id":158803,"utype":1}],"discussion_count":1,"race_medal":0,"score":16,"product_id":100040501,"comment_content":"我太南了～","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476853,"discussion_content":"南没事，不难就行。🤣","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575464005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158777,"user_name":"忆民","can_delete":false,"product_type":"c1","uid":1497815,"ip_address":"","ucode":"E66CEAD1E910C5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJBHLqk9ofIib9pgboMKZhVCia28M3FTf45C1bPrvH5ctCDhfAqS6ia13fQtBWGafADFIQsttJ7rgXwg/132","comment_is_top":false,"comment_ctime":1575449451,"is_pvip":false,"replies":[{"id":60756,"content":"参数类型是没有引用符号的哦。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575464094,"ip_address":"","comment_id":158777,"utype":1}],"discussion_count":1,"race_medal":0,"score":16,"product_id":100040501,"comment_content":"老师这个不理解\nsmart_ptr&amp;  operator=(smart_ptr rhs) noexcept  {    rhs.swap(*this);    return *this;  }\n这个实现，好像时rhs和this交换，彼此指向对方拥有的对象了？是不是又问题？\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476853,"discussion_content":"南没事，不难就行。🤣","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575464005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158468,"user_name":"在水一方","can_delete":false,"product_type":"c1","uid":1414215,"ip_address":"","ucode":"D8371EFEBED2C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiboeh23vhCNruZ7odUjROiac6N9fx0VWAE6zBNRxJIJFZspSUTQdgu9ajg4F0fAZgdk1vBsicnib3QQ/132","comment_is_top":false,"comment_ctime":1575378527,"is_pvip":false,"replies":[{"id":60649,"content":"😇","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575380730,"ip_address":"","comment_id":158468,"utype":1}],"discussion_count":1,"race_medal":0,"score":16,"product_id":100040501,"comment_content":"讲解的很好，很深，本来还犹豫，看了这一课，果断入手。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476842,"discussion_content":"参数类型是没有引用符号的哦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575464094,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158346,"user_name":"lyfei","can_delete":false,"product_type":"c1","uid":1757471,"ip_address":"","ucode":"31ACC702BE6FEA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","comment_is_top":false,"comment_ctime":1575360498,"is_pvip":false,"replies":[{"id":60645,"content":"不是。智能指针的构造函数只能接受 new 单个对象的结果指针。你这儿既不是 new 的，又是数组，双重问题。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575378194,"ip_address":"","comment_id":158346,"utype":1}],"discussion_count":4,"race_medal":0,"score":16,"product_id":100040501,"comment_content":"老师你好，我进行下面赋值的时候，为什么出现了double free的问题：\n    int test[10];\n    smart_ptr&lt;int&gt; test_ptr(test);\n这个是浅拷贝出现的问题吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476739,"discussion_content":"😇","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575380730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158217,"user_name":"Liang Xu","can_delete":false,"product_type":"c1","uid":1476654,"ip_address":"","ucode":"5EA7072BF69B1A","user_header":"https://static001.geekbang.org/account/avatar/00/16/88/2e/7efef4f0.jpg","comment_is_top":false,"comment_ctime":1575351360,"is_pvip":false,"replies":[{"id":60641,"content":"这就像写一个声明 f(int n); 一样，n 是个形参，不写也可以的。这个 friend 声明也是如此，只是表明这个形式的模板都是朋友，U 可以不写。我只是跟下面的写法保持一致而已。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575377615,"ip_address":"","comment_id":158217,"utype":1}],"discussion_count":1,"race_medal":0,"score":16,"product_id":100040501,"comment_content":"template &lt;typename T&gt;\nclass smart_ptr {\n       public: \n       template &lt;typename U&gt;\n       friend class smart_ptr;\n老师，在这个地方， U 是怎么获取的？ ","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476691,"discussion_content":"不是。智能指针的构造函数只能接受 new 单个对象的结果指针。你这儿既不是 new 的，又是数组，双重问题。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575378194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70733,"discussion_content":"嗯嗯，明白了，谢谢老师的热情回答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575378833,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70678,"discussion_content":"低级错误，低级错误😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575375998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70675,"discussion_content":"嗯嗯，我明白了。\ntest在栈中是自动管理的，系统会释放一次，而smart_ptr的时候又会释放一次，所以就出现了double free的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575375981,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158213,"user_name":"三味","can_delete":false,"product_type":"c1","uid":1362403,"ip_address":"","ucode":"A580F715D1CC96","user_header":"https://static001.geekbang.org/account/avatar/00/14/c9/e3/28c16afa.jpg","comment_is_top":false,"comment_ctime":1575350662,"is_pvip":false,"replies":[{"id":60626,"content":"讲代码组合，就是要拿过来完全不改就可以用。这点C++已经算是不强的了。你倒好，拿一个别人的类过来就要往里塞个计数？如果没有源码呢？🤪","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575368074,"ip_address":"","comment_id":158213,"utype":1}],"discussion_count":1,"race_medal":0,"score":16,"product_id":100040501,"comment_content":"更喜欢侵入式的智能指针, 引用计数包含在继承的基类中. \n感觉share_ptr中每针对一个新的对象都要new一个引用计数, 这种方法好邪道...\n也可能我一开始接触智能指针, 就是从侵入式的开始的缘故吧...","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476678,"discussion_content":"这就像写一个声明 f(int n); 一样，n 是个形参，不写也可以的。这个 friend 声明也是如此，只是表明这个形式的模板都是朋友，U 可以不写。我只是跟下面的写法保持一致而已。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575377615,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158044,"user_name":"熊出没","can_delete":false,"product_type":"c1","uid":1145377,"ip_address":"","ucode":"6E39230CC87808","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/21/a33cc944.jpg","comment_is_top":false,"comment_ctime":1575302220,"is_pvip":false,"replies":[{"id":60582,"content":"没有手误，代码都测试过的。\n\n是因为我偷偷塞了点 C++11的语法？先熟悉起来，后面还会讲到。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575337332,"ip_address":"","comment_id":158044,"utype":1}],"discussion_count":2,"race_medal":0,"score":16,"product_id":100040501,"comment_content":"smart_ptr&lt;shape&gt; ptr1{create_shape(shape_type::circle)};\nsmart_ptr&lt;shape&gt; ptr2{ptr1};\n\n老师 课题开始那里讲解拷贝时 这两行代码是否手误 括号好像不对","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476675,"discussion_content":"讲代码组合，就是要拿过来完全不改就可以用。这点C++已经算是不强的了。你倒好，拿一个别人的类过来就要往里塞个计数？如果没有源码呢？🤪","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575368074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157576,"user_name":"一天到晚游泳的鱼","can_delete":false,"product_type":"c1","uid":1433982,"ip_address":"","ucode":"1F40AF478D85B9","user_header":"","comment_is_top":false,"comment_ctime":1575200232,"is_pvip":false,"replies":[{"id":60431,"content":"这个智能指针目前不支持数组。C++标准里的智能指针对数组的支持也是到C++17才提供的。作为简化版本，目前也不支持删除器。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575210676,"ip_address":"","comment_id":157576,"utype":1}],"discussion_count":1,"race_medal":0,"score":16,"product_id":100040501,"comment_content":"如果传入的是动态数组的指针 则会造成内存泄漏 所以我觉得还应该增加一个 可以传入删除器以删除动态数组","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476612,"discussion_content":"没有手误，代码都测试过的。\n\n是因为我偷偷塞了点 C++11的语法？先熟悉起来，后面还会讲到。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575337332,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1145377,"avatar":"https://static001.geekbang.org/account/avatar/00/11/7a/21/a33cc944.jpg","nickname":"熊出没","note":"","ucode":"6E39230CC87808","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70242,"discussion_content":"好的 确实还是有难度 以及 新的语法和概念 以手动验证 对自己要格式化了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575337964,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157563,"user_name":"徐凯","can_delete":false,"product_type":"c1","uid":1244991,"ip_address":"","ucode":"12F82BA3649CD5","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/3f/bbb8a88c.jpg","comment_is_top":false,"comment_ctime":1575194618,"is_pvip":false,"replies":[{"id":60432,"content":"你测试了吗？🧐\n\n我试了你这样的代码是可以工作的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575210955,"ip_address":"","comment_id":157563,"utype":1}],"discussion_count":2,"race_medal":0,"score":16,"product_id":100040501,"comment_content":"老师你的智能指针代码  应该还缺乏了const类型的赋值\n     base* b=new base;\n     const CD* pConst=b;\n上述赋值是合法的而来到智能指针由于SmartPtr&lt;base&gt;、 SmartPtr&lt;const base&gt; 在编译器看来是完全不同的类型下面的操作将会无法编译\n     SmartPtr&lt;base&gt; p1(new base);\n     SmartPtr&lt;const base&gt; p2=p1;","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476468,"discussion_content":"你测试了吗？🧐\n\n我试了你这样的代码是可以工作的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575210955,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1244991,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ff/3f/bbb8a88c.jpg","nickname":"徐凯","note":"","ucode":"12F82BA3649CD5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":68269,"discussion_content":"抱歉 上面打错了 CD应该是base","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575207643,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157547,"user_name":"robonix","can_delete":false,"product_type":"c1","uid":1212323,"ip_address":"","ucode":"866EC82EDA455B","user_header":"https://static001.geekbang.org/account/avatar/00/12/7f/a3/23540579.jpg","comment_is_top":false,"comment_ctime":1575191393,"is_pvip":false,"replies":[{"id":60427,"content":"所有代码全都编译过的……一、参照代码列表，直接拷贝粘贴。二、还有问题的话，是不是你的编译器太老？参照环境说明那篇。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575203571,"ip_address":"","comment_id":157547,"utype":1}],"discussion_count":2,"race_medal":0,"score":17,"product_id":100040501,"comment_content":"老师的代码有编译过嘛，我在拷贝构造函数定义上方添加\n  template &lt;typename U&gt;\n  friend class smart_ptr;\n编译时报错了，提示undeclared identifier U, 不知道是为啥？","like_count":0},{"had_liked":false,"id":157490,"user_name":"robonix","can_delete":false,"product_type":"c1","uid":1212323,"ip_address":"","ucode":"866EC82EDA455B","user_header":"https://static001.geekbang.org/account/avatar/00/12/7f/a3/23540579.jpg","comment_is_top":false,"comment_ctime":1575175489,"is_pvip":false,"replies":[{"id":60384,"content":"不是。你写的那种形式不合法。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575189137,"ip_address":"","comment_id":157490,"utype":1}],"discussion_count":1,"race_medal":0,"score":17,"product_id":100040501,"comment_content":"有个小疑惑，friend class smart_ptr; 是不是friend class smart_ptr&lt;T&gt;; 的简写呀？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476446,"discussion_content":"不是。你写的那种形式不合法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575189137,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157327,"user_name":"nelson","can_delete":false,"product_type":"c1","uid":1271183,"ip_address":"","ucode":"773BE75A23C1C9","user_header":"","comment_is_top":false,"comment_ctime":1575110202,"is_pvip":false,"replies":[{"id":60331,"content":"主要是习惯问题吧。我个人不喜欢用 friend，能不用就不用。另外，作为成员函数，直接写 swap(rhs) 也更快捷。但为了方便别人，在类外面定义 swap 也是需要的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575120569,"ip_address":"","comment_id":157327,"utype":1}],"discussion_count":1,"race_medal":0,"score":17,"product_id":100040501,"comment_content":"代码实现中使用了两个swap，一个成员函数，一个模板函数。这个方法和使用一个友元函数\nfriend void swap(smart_ptr &amp;lhs,\n                     smart_ptr &amp;rhs) noexcept\n{\n    using std::swap;\n    swap(lhs.ptr_, rhs.ptr_);\n    swap(lhs.shared_count_,  rhs.shared_count_);\n}\n这两种方法哪个更合适？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476397,"discussion_content":"主要是习惯问题吧。我个人不喜欢用 friend，能不用就不用。另外，作为成员函数，直接写 swap(rhs) 也更快捷。但为了方便别人，在类外面定义 swap 也是需要的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575120569,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156973,"user_name":"千鲤湖","can_delete":false,"product_type":"c1","uid":1076506,"ip_address":"","ucode":"C626F15967C219","user_header":"https://static001.geekbang.org/account/avatar/00/10/6d/1a/d1d44258.jpg","comment_is_top":false,"comment_ctime":1575006394,"is_pvip":false,"replies":[{"id":60268,"content":"有区别的，看到了吗？原因在文中“子类指针向基类指针的转换”那节讲到过。现在不熟悉也没关系。这些琐细的规则不需要在现在掌握。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575027605,"ip_address":"","comment_id":156973,"utype":1}],"discussion_count":1,"race_medal":0,"score":17,"product_id":100040501,"comment_content":"\n最后代码里面的 L48 L59，这两个构造是不是重复了啊．","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476291,"discussion_content":"有区别的，看到了吗？原因在文中“子类指针向基类指针的转换”那节讲到过。现在不熟悉也没关系。这些琐细的规则不需要在现在掌握。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575027605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156787,"user_name":"李公子胜治","can_delete":false,"product_type":"c1","uid":1455420,"ip_address":"","ucode":"7D48D78D289935","user_header":"https://static001.geekbang.org/account/avatar/00/16/35/3c/9800b0ba.jpg","comment_is_top":false,"comment_ctime":1574955928,"is_pvip":false,"replies":[{"id":60173,"content":"模板我觉得应该学。但模板一般用在通用的库函数中，你应该在给你们项目写通用类库的时候写模板，而一般不需要在写应用时写模板代码。写应用时使用模板就完全正常了，就像使用STL那些一样。\n\n至于ACE，只在很久以前看过一点，觉得旧包袱太重，而且目前使用真似乎不怎么听到了。如果工作中不用，找一些更新的框架也许更好。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574983865,"ip_address":"","comment_id":156787,"utype":1}],"discussion_count":1,"race_medal":0,"score":17,"product_id":100040501,"comment_content":"老师，您好，我是一名C++程序员和爱好者，我有三年C++编程经验，对于C++很多知识也是很模糊，最近在学习模板和泛型技术，可是我的项目几乎不用模板，您觉得普通应用程序员有必要深入学习模板技术吗？这个可能花很长的时间（这个时间学习别的很实用的东西可以学很多了）。另外，我学习设计模式主要是剖析ACE源码，观摩别人的设计方法，可是ACE复杂无比，无疑要花很多时间。另外ACE已经用的很少了，您觉得有必要坚持下去学习这些东西吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476229,"discussion_content":"编译器只把特定形式的构造函数当作拷贝/移动构造函数，并依据此来决定启用、禁用一些默认的行为。这些现在还用不着记。以后我们还会回到这个话题。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574983314,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156775,"user_name":"NEVER SETTLE","can_delete":false,"product_type":"c1","uid":1101894,"ip_address":"","ucode":"9C86BDAFDBF768","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/46/1a9229b3.jpg","comment_is_top":false,"comment_ctime":1574953305,"is_pvip":false,"replies":[{"id":60170,"content":"编译器只把特定形式的构造函数当作拷贝&#47;移动构造函数，并依据此来决定启用、禁用一些默认的行为。这些现在还用不着记。以后我们还会回到这个话题。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574983314,"ip_address":"","comment_id":156775,"utype":1}],"discussion_count":1,"race_medal":0,"score":17,"product_id":100040501,"comment_content":"template &lt;typename U&gt;\nsmart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other) { \n\tptr_ = other.release(); \n}\n\n老师，不太明白“上面这个构造函数不被编译器看作移动构造函数，因而不能自动触发删除拷贝构造函数的行为。”","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476220,"discussion_content":"可做可不做。这种情况下我倾向不做，但做也没啥大区别。我这儿所有的判断都是 ptr_ 为空就不看 shared_count_ 的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574951840,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1485304,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/qrLibiczMaSJfmMuvA1ZqILyhNsuphAcQG8wX1iajTibXU26kmQoGejRGXh8RNK1q3zaaibcfpujrVIYkRlMy5XF6Vw/132","nickname":"李蔚韬","note":"","ucode":"B5367CD3569C34","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":64694,"discussion_content":"没事了老师，是我自己理解不到位，两个指针的释放是在最后一个variable出作用域时destructor触发的，在这之前的出作用域的variable就是很简单的删掉指针而已，不会释放heap上的内存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574952736,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1485304,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/qrLibiczMaSJfmMuvA1ZqILyhNsuphAcQG8wX1iajTibXU26kmQoGejRGXh8RNK1q3zaaibcfpujrVIYkRlMy5XF6Vw/132","nickname":"李蔚韬","note":"","ucode":"B5367CD3569C34","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":64658,"discussion_content":"嗯嗯，但是other的内容已经move给了当前smart_ptr，我们要负责把other释放掉吧，我看smart_ptr的destructor里如果ptr为空就不会delete 这个reference count的指针，正好对应这里的情况。还是说我对于shared ptr的moved语义理解有问题呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574952389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156744,"user_name":"李蔚韬","can_delete":false,"product_type":"c1","uid":1485304,"ip_address":"","ucode":"B5367CD3569C34","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/qrLibiczMaSJfmMuvA1ZqILyhNsuphAcQG8wX1iajTibXU26kmQoGejRGXh8RNK1q3zaaibcfpujrVIYkRlMy5XF6Vw/132","comment_is_top":false,"comment_ctime":1574946312,"is_pvip":false,"replies":[{"id":60163,"content":"可做可不做。这种情况下我倾向不做，但做也没啥大区别。我这儿所有的判断都是 ptr_ 为空就不看 shared_count_ 的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574951840,"ip_address":"","comment_id":156744,"utype":1}],"discussion_count":3,"race_medal":0,"score":17,"product_id":100040501,"comment_content":"\n  template &lt;typename U&gt;\n  smart_ptr(const smart_ptr&lt;U&gt;&amp; other)\n  {\n    ptr_ = other.ptr_;\n    if (ptr_) {\n      other.shared_count_\n        -&gt;add_count();\n      shared_count_ =\n        other.shared_count_;\n    }\n  }\n  template &lt;typename U&gt;\n  smart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other)\n  {\n    ptr_ = other.ptr_;\n    if (ptr_) {\n      shared_count_ =\n        other.shared_count_;\n      other.ptr_ = nullptr;\n    }\n  }\n\n老师你好，这里move constructor的最后是不是还要other.shared_count = nullptr一下？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476191,"discussion_content":"在“指针类型转换”一节上面，有较完整的测试代码的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574947670,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156667,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1574933153,"is_pvip":false,"replies":[{"id":60158,"content":"在“指针类型转换”一节上面，有较完整的测试代码的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574947670,"ip_address":"","comment_id":156667,"utype":1}],"discussion_count":1,"race_medal":0,"score":17,"product_id":100040501,"comment_content":"老师我提个建议啊 针对上面的smart_ptr实例代码最好能够个测试代码  比如写个main函数里面实例化几个智能指针 然后进行测试 我觉得这样可能更好一点儿","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476188,"discussion_content":"这个在正文里写了。搜“friend”。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574938077,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156652,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1574930718,"is_pvip":false,"replies":[{"id":60137,"content":"这个在正文里写了。搜“friend”。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574938077,"ip_address":"","comment_id":156652,"utype":1}],"discussion_count":1,"race_medal":0,"score":17,"product_id":100040501,"comment_content":"老师你好 为什么要在smart_ptr类当中 设置smart_ptr为友元不是很明白\ntemplate &lt;typename T&gt;\nclass smart_ptr {\n       public:  \n       template &lt;typename U&gt;\n       friend class smart_ptr; 为什么要设置自己为友元呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476188,"discussion_content":"这个在正文里写了。搜“friend”。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574938077,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156642,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1574929261,"is_pvip":false,"replies":[{"id":60133,"content":"分两层开看。模板代码确实很难写好，容易出错。但一旦写好，让别人只是调用还是很方便的。一般应用项目中，应当尽量只使用模板，而不是写模板。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574935779,"ip_address":"","comment_id":156642,"utype":1}],"discussion_count":1,"race_medal":0,"score":17,"product_id":100040501,"comment_content":"复习到构造和指针的引用 总结得出虽然cpp性能高 但是用得好就是牛逼 用得不好就是灾难!","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476184,"discussion_content":"分两层开看。模板代码确实很难写好，容易出错。但一旦写好，让别人只是调用还是很方便的。一般应用项目中，应当尽量只使用模板，而不是写模板。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574935779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157547,"user_name":"robonix","can_delete":false,"product_type":"c1","uid":1212323,"ip_address":"","ucode":"866EC82EDA455B","user_header":"https://static001.geekbang.org/account/avatar/00/12/7f/a3/23540579.jpg","comment_is_top":false,"comment_ctime":1575191393,"is_pvip":false,"replies":[{"id":60427,"content":"所有代码全都编译过的……一、参照代码列表，直接拷贝粘贴。二、还有问题的话，是不是你的编译器太老？参照环境说明那篇。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575203571,"ip_address":"","comment_id":157547,"utype":1}],"discussion_count":2,"race_medal":0,"score":17,"product_id":100040501,"comment_content":"老师的代码有编译过嘛，我在拷贝构造函数定义上方添加\n  template &lt;typename U&gt;\n  friend class smart_ptr;\n编译时报错了，提示undeclared identifier U, 不知道是为啥？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476462,"discussion_content":"所有代码全都编译过的……一、参照代码列表，直接拷贝粘贴。二、还有问题的话，是不是你的编译器太老？参照环境说明那篇。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575203571,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1212323,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7f/a3/23540579.jpg","nickname":"robonix","note":"","ucode":"866EC82EDA455B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":68003,"discussion_content":"sorry, 看到后面完整代码了，这两行应该紧跟在public 后面，我刚开始写到函数声明定义处了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575194889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157490,"user_name":"robonix","can_delete":false,"product_type":"c1","uid":1212323,"ip_address":"","ucode":"866EC82EDA455B","user_header":"https://static001.geekbang.org/account/avatar/00/12/7f/a3/23540579.jpg","comment_is_top":false,"comment_ctime":1575175489,"is_pvip":false,"replies":[{"id":60384,"content":"不是。你写的那种形式不合法。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575189137,"ip_address":"","comment_id":157490,"utype":1}],"discussion_count":1,"race_medal":0,"score":17,"product_id":100040501,"comment_content":"有个小疑惑，friend class smart_ptr; 是不是friend class smart_ptr&lt;T&gt;; 的简写呀？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476462,"discussion_content":"所有代码全都编译过的……一、参照代码列表，直接拷贝粘贴。二、还有问题的话，是不是你的编译器太老？参照环境说明那篇。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575203571,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1212323,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7f/a3/23540579.jpg","nickname":"robonix","note":"","ucode":"866EC82EDA455B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":68003,"discussion_content":"sorry, 看到后面完整代码了，这两行应该紧跟在public 后面，我刚开始写到函数声明定义处了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575194889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157327,"user_name":"nelson","can_delete":false,"product_type":"c1","uid":1271183,"ip_address":"","ucode":"773BE75A23C1C9","user_header":"","comment_is_top":false,"comment_ctime":1575110202,"is_pvip":false,"replies":[{"id":60331,"content":"主要是习惯问题吧。我个人不喜欢用 friend，能不用就不用。另外，作为成员函数，直接写 swap(rhs) 也更快捷。但为了方便别人，在类外面定义 swap 也是需要的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575120569,"ip_address":"","comment_id":157327,"utype":1}],"discussion_count":1,"race_medal":0,"score":17,"product_id":100040501,"comment_content":"代码实现中使用了两个swap，一个成员函数，一个模板函数。这个方法和使用一个友元函数\nfriend void swap(smart_ptr &amp;lhs,\n                     smart_ptr &amp;rhs) noexcept\n{\n    using std::swap;\n    swap(lhs.ptr_, rhs.ptr_);\n    swap(lhs.shared_count_,  rhs.shared_count_);\n}\n这两种方法哪个更合适？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476446,"discussion_content":"不是。你写的那种形式不合法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575189137,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156973,"user_name":"千鲤湖","can_delete":false,"product_type":"c1","uid":1076506,"ip_address":"","ucode":"C626F15967C219","user_header":"https://static001.geekbang.org/account/avatar/00/10/6d/1a/d1d44258.jpg","comment_is_top":false,"comment_ctime":1575006394,"is_pvip":false,"replies":[{"id":60268,"content":"有区别的，看到了吗？原因在文中“子类指针向基类指针的转换”那节讲到过。现在不熟悉也没关系。这些琐细的规则不需要在现在掌握。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575027605,"ip_address":"","comment_id":156973,"utype":1}],"discussion_count":1,"race_medal":0,"score":17,"product_id":100040501,"comment_content":"\n最后代码里面的 L48 L59，这两个构造是不是重复了啊．","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476397,"discussion_content":"主要是习惯问题吧。我个人不喜欢用 friend，能不用就不用。另外，作为成员函数，直接写 swap(rhs) 也更快捷。但为了方便别人，在类外面定义 swap 也是需要的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575120569,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156787,"user_name":"李公子胜治","can_delete":false,"product_type":"c1","uid":1455420,"ip_address":"","ucode":"7D48D78D289935","user_header":"https://static001.geekbang.org/account/avatar/00/16/35/3c/9800b0ba.jpg","comment_is_top":false,"comment_ctime":1574955928,"is_pvip":false,"replies":[{"id":60173,"content":"模板我觉得应该学。但模板一般用在通用的库函数中，你应该在给你们项目写通用类库的时候写模板，而一般不需要在写应用时写模板代码。写应用时使用模板就完全正常了，就像使用STL那些一样。\n\n至于ACE，只在很久以前看过一点，觉得旧包袱太重，而且目前使用真似乎不怎么听到了。如果工作中不用，找一些更新的框架也许更好。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574983865,"ip_address":"","comment_id":156787,"utype":1}],"discussion_count":1,"race_medal":0,"score":17,"product_id":100040501,"comment_content":"老师，您好，我是一名C++程序员和爱好者，我有三年C++编程经验，对于C++很多知识也是很模糊，最近在学习模板和泛型技术，可是我的项目几乎不用模板，您觉得普通应用程序员有必要深入学习模板技术吗？这个可能花很长的时间（这个时间学习别的很实用的东西可以学很多了）。另外，我学习设计模式主要是剖析ACE源码，观摩别人的设计方法，可是ACE复杂无比，无疑要花很多时间。另外ACE已经用的很少了，您觉得有必要坚持下去学习这些东西吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476232,"discussion_content":"模板我觉得应该学。但模板一般用在通用的库函数中，你应该在给你们项目写通用类库的时候写模板，而一般不需要在写应用时写模板代码。写应用时使用模板就完全正常了，就像使用STL那些一样。\n\n至于ACE，只在很久以前看过一点，觉得旧包袱太重，而且目前使用真似乎不怎么听到了。如果工作中不用，找一些更新的框架也许更好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574983865,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156775,"user_name":"NEVER SETTLE","can_delete":false,"product_type":"c1","uid":1101894,"ip_address":"","ucode":"9C86BDAFDBF768","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/46/1a9229b3.jpg","comment_is_top":false,"comment_ctime":1574953305,"is_pvip":false,"replies":[{"id":60170,"content":"编译器只把特定形式的构造函数当作拷贝&#47;移动构造函数，并依据此来决定启用、禁用一些默认的行为。这些现在还用不着记。以后我们还会回到这个话题。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574983314,"ip_address":"","comment_id":156775,"utype":1}],"discussion_count":1,"race_medal":0,"score":17,"product_id":100040501,"comment_content":"template &lt;typename U&gt;\nsmart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other) { \n\tptr_ = other.release(); \n}\n\n老师，不太明白“上面这个构造函数不被编译器看作移动构造函数，因而不能自动触发删除拷贝构造函数的行为。”","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476291,"discussion_content":"有区别的，看到了吗？原因在文中“子类指针向基类指针的转换”那节讲到过。现在不熟悉也没关系。这些琐细的规则不需要在现在掌握。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575027605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156744,"user_name":"李蔚韬","can_delete":false,"product_type":"c1","uid":1485304,"ip_address":"","ucode":"B5367CD3569C34","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/qrLibiczMaSJfmMuvA1ZqILyhNsuphAcQG8wX1iajTibXU26kmQoGejRGXh8RNK1q3zaaibcfpujrVIYkRlMy5XF6Vw/132","comment_is_top":false,"comment_ctime":1574946312,"is_pvip":false,"replies":[{"id":60163,"content":"可做可不做。这种情况下我倾向不做，但做也没啥大区别。我这儿所有的判断都是 ptr_ 为空就不看 shared_count_ 的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574951840,"ip_address":"","comment_id":156744,"utype":1}],"discussion_count":3,"race_medal":0,"score":17,"product_id":100040501,"comment_content":"\n  template &lt;typename U&gt;\n  smart_ptr(const smart_ptr&lt;U&gt;&amp; other)\n  {\n    ptr_ = other.ptr_;\n    if (ptr_) {\n      other.shared_count_\n        -&gt;add_count();\n      shared_count_ =\n        other.shared_count_;\n    }\n  }\n  template &lt;typename U&gt;\n  smart_ptr(smart_ptr&lt;U&gt;&amp;&amp; other)\n  {\n    ptr_ = other.ptr_;\n    if (ptr_) {\n      shared_count_ =\n        other.shared_count_;\n      other.ptr_ = nullptr;\n    }\n  }\n\n老师你好，这里move constructor的最后是不是还要other.shared_count = nullptr一下？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476232,"discussion_content":"模板我觉得应该学。但模板一般用在通用的库函数中，你应该在给你们项目写通用类库的时候写模板，而一般不需要在写应用时写模板代码。写应用时使用模板就完全正常了，就像使用STL那些一样。\n\n至于ACE，只在很久以前看过一点，觉得旧包袱太重，而且目前使用真似乎不怎么听到了。如果工作中不用，找一些更新的框架也许更好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574983865,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156667,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1574933153,"is_pvip":false,"replies":[{"id":60158,"content":"在“指针类型转换”一节上面，有较完整的测试代码的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574947670,"ip_address":"","comment_id":156667,"utype":1}],"discussion_count":1,"race_medal":0,"score":17,"product_id":100040501,"comment_content":"老师我提个建议啊 针对上面的smart_ptr实例代码最好能够个测试代码  比如写个main函数里面实例化几个智能指针 然后进行测试 我觉得这样可能更好一点儿","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476229,"discussion_content":"编译器只把特定形式的构造函数当作拷贝/移动构造函数，并依据此来决定启用、禁用一些默认的行为。这些现在还用不着记。以后我们还会回到这个话题。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574983314,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156652,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1574930718,"is_pvip":false,"replies":[{"id":60137,"content":"这个在正文里写了。搜“friend”。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574938077,"ip_address":"","comment_id":156652,"utype":1}],"discussion_count":1,"race_medal":0,"score":17,"product_id":100040501,"comment_content":"老师你好 为什么要在smart_ptr类当中 设置smart_ptr为友元不是很明白\ntemplate &lt;typename T&gt;\nclass smart_ptr {\n       public:  \n       template &lt;typename U&gt;\n       friend class smart_ptr; 为什么要设置自己为友元呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476220,"discussion_content":"可做可不做。这种情况下我倾向不做，但做也没啥大区别。我这儿所有的判断都是 ptr_ 为空就不看 shared_count_ 的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574951840,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1485304,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/qrLibiczMaSJfmMuvA1ZqILyhNsuphAcQG8wX1iajTibXU26kmQoGejRGXh8RNK1q3zaaibcfpujrVIYkRlMy5XF6Vw/132","nickname":"李蔚韬","note":"","ucode":"B5367CD3569C34","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":64694,"discussion_content":"没事了老师，是我自己理解不到位，两个指针的释放是在最后一个variable出作用域时destructor触发的，在这之前的出作用域的variable就是很简单的删掉指针而已，不会释放heap上的内存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574952736,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1485304,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/qrLibiczMaSJfmMuvA1ZqILyhNsuphAcQG8wX1iajTibXU26kmQoGejRGXh8RNK1q3zaaibcfpujrVIYkRlMy5XF6Vw/132","nickname":"李蔚韬","note":"","ucode":"B5367CD3569C34","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":64658,"discussion_content":"嗯嗯，但是other的内容已经move给了当前smart_ptr，我们要负责把other释放掉吧，我看smart_ptr的destructor里如果ptr为空就不会delete 这个reference count的指针，正好对应这里的情况。还是说我对于shared ptr的moved语义理解有问题呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574952389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156642,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1574929261,"is_pvip":false,"replies":[{"id":60133,"content":"分两层开看。模板代码确实很难写好，容易出错。但一旦写好，让别人只是调用还是很方便的。一般应用项目中，应当尽量只使用模板，而不是写模板。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574935779,"ip_address":"","comment_id":156642,"utype":1}],"discussion_count":1,"race_medal":0,"score":17,"product_id":100040501,"comment_content":"复习到构造和指针的引用 总结得出虽然cpp性能高 但是用得好就是牛逼 用得不好就是灾难!","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476191,"discussion_content":"在“指针类型转换”一节上面，有较完整的测试代码的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574947670,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156630,"user_name":"Geek_4uglyb","can_delete":false,"product_type":"c1","uid":1203822,"ip_address":"","ucode":"3D443DA7DBCC6C","user_header":"https://static001.geekbang.org/account/avatar/00/12/5e/6e/1a032e01.jpg","comment_is_top":false,"comment_ctime":1574926664,"is_pvip":false,"replies":[{"id":60162,"content":"没有笔误。不过，我现在在正文中换了种说法，也许可以减少点误解：\n\n“如果我们想消除代码重复、删除移动构造函数的话，就需要把拷贝构造函数标记成 = delete 了”","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574950836,"ip_address":"","comment_id":156630,"utype":1}],"discussion_count":2,"race_medal":0,"score":18,"product_id":100040501,"comment_content":"“需要注意，上面这个构造函数不被编译器看作移动构造函数，因而不能自动触发删除拷贝构造函数的行为。如果我们想使代码更简洁、删除移动构造函数的话，就需要把拷贝构造函数标记成 = delete 了（见“拷贝构造和赋值”一节）。  ”。  笔误了吧 “如果我们想使代码更简洁、删除移动构造函数的话” 应该是 删除拷贝构造函数 吧","like_count":0},{"had_liked":false,"id":156628,"user_name":"孟宪轲","can_delete":false,"product_type":"c1","uid":1487040,"ip_address":"","ucode":"753879DAAEFB2B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLZUA1byglmJVwPuT2BA8ic2iaNFfIfZJicenWiaxdz9nod0KIlxyNTra4qxO7jPDgC1FFCq5CJGgLX5g/132","comment_is_top":false,"comment_ctime":1574926532,"is_pvip":false,"replies":[{"id":60159,"content":"因为一般情况下，你希望可以用const smart_ptr&amp;来构造出一个新的smart_ptr。至于断点问题，那就可能跟具体的编译器和编译选项有关了，我这边没啥好的答案。（我设断点都没有问题的。）\n\nconst只保证不改other的成员，不保证不改成员指向的内容。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574948165,"ip_address":"","comment_id":156628,"utype":1}],"discussion_count":1,"race_medal":0,"score":18,"product_id":100040501,"comment_content":"完整smart_ptr代码列表中，形参other要增加引用计数，为什么前面加const？我调试代码加const的构造函数不进断点，去掉const能正常进入断点。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476180,"discussion_content":"没有笔误。不过，我现在在正文中换了种说法，也许可以减少点误解：\n\n“如果我们想消除代码重复、删除移动构造函数的话，就需要把拷贝构造函数标记成 = delete 了”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574950836,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1203822,"avatar":"https://static001.geekbang.org/account/avatar/00/12/5e/6e/1a032e01.jpg","nickname":"Geek_4uglyb","note":"","ucode":"3D443DA7DBCC6C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":65356,"discussion_content":"看了下effective modern c++的条款17，发现之前的回复是我理解错了。😂 也就是说 1、成员函数模版不会阻止特殊成员函数的生成；2、移动操作只在没有显示声明拷贝/析构函数的类中生成；","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574997622,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156540,"user_name":"朱熙","can_delete":false,"product_type":"c1","uid":1039029,"ip_address":"","ucode":"2B9E2B8645A844","user_header":"https://static001.geekbang.org/account/avatar/00/0f/da/b5/9d1f2f55.jpg","comment_is_top":false,"comment_ctime":1574907239,"is_pvip":false,"replies":[{"id":60110,"content":"嗯，加油。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574913886,"ip_address":"","comment_id":156540,"utype":1}],"discussion_count":1,"race_medal":0,"score":18,"product_id":100040501,"comment_content":"看了不少课程，但是由于母语是c++，因此一直也没有留言。第一次留言，虽然看起来略微吃力，但是基本还算能看懂，而且对于以前一些模糊的东西的确有了更清晰的认识，很期待后面的课程~","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476147,"discussion_content":"嗯，加油。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574913886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156291,"user_name":"nullptr","can_delete":false,"product_type":"c1","uid":1759752,"ip_address":"","ucode":"1A26EA0D1A2C10","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqtvuo1wE3XU1mBmtIDfrAQZ2NofBQM5sZhBWicMXicdsrfJ6t87yrlXwqFj0PB6Kx8QU3AVCR4TIHw/132","comment_is_top":false,"comment_ctime":1574851004,"is_pvip":false,"replies":[{"id":60052,"content":"不太明白你的评论。不过呢，如果谁读过Meyers的四本Effective系列，这个专栏能让他学习的新知识可能就不太多了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574858221,"ip_address":"","comment_id":156291,"utype":1}],"discussion_count":1,"race_medal":0,"score":18,"product_id":100040501,"comment_content":"我觉得effective c++也有相关说明","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476178,"discussion_content":"因为一般情况下，你希望可以用const smart_ptr&amp;amp;来构造出一个新的smart_ptr。至于断点问题，那就可能跟具体的编译器和编译选项有关了，我这边没啥好的答案。（我设断点都没有问题的。）\n\nconst只保证不改other的成员，不保证不改成员指向的内容。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574948165,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156248,"user_name":"虫 二","can_delete":false,"product_type":"c1","uid":1434808,"ip_address":"","ucode":"4416C9BFD62F8C","user_header":"https://static001.geekbang.org/account/avatar/00/15/e4/b8/e7fd5b9c.jpg","comment_is_top":false,"comment_ctime":1574842715,"is_pvip":false,"replies":[{"id":60049,"content":"下标？现在只管理一个对象，下标有什么用？","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574857957,"ip_address":"","comment_id":156248,"utype":1}],"discussion_count":5,"race_medal":0,"score":18,"product_id":100040501,"comment_content":"应该还要添加下标访问，比较的重载，看得有些吃力，还是得坚持下","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476147,"discussion_content":"嗯，加油。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574913886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156151,"user_name":"糖","can_delete":false,"product_type":"c1","uid":1542834,"ip_address":"","ucode":"784DDA19104392","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJzP9yB6eIRRyVNe3iab0gXB6yOeaNRHGx6raTQz2grfE5N2LWl6uIj1mrSU7nxiaEzeSLp6xAkE3iaQ/132","comment_is_top":false,"comment_ctime":1574824999,"is_pvip":false,"replies":[{"id":60045,"content":"不正确，this == &amp;other 时会自我销毁。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574857512,"ip_address":"","comment_id":156151,"utype":1}],"discussion_count":6,"race_medal":0,"score":18,"product_id":100040501,"comment_content":"吴老师好，smart_ptr的拷贝构造函数和赋值运算符是否可以同种方法解决，比如，上面赋值运算符中swap部分的代码改成release：\n\tsmart_ptr&amp; operator=(smart_ptr&amp; other) {\n\t\tdata = other.release();\n\t\treturn *this;\n\t}\n这段代码是正确的吗？对于单纯实现smart_ptr有缺陷的地方吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476048,"discussion_content":"下标？现在只管理一个对象，下标有什么用？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574857957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1434808,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e4/b8/e7fd5b9c.jpg","nickname":"虫 二","note":"","ucode":"4416C9BFD62F8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62946,"discussion_content":"对哦，谢谢老师，可是我之前在cppreferenc参考手册中有看到shared_ptr重载了〔〕C++17特性，有点不太理解了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574864521,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1434808,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e4/b8/e7fd5b9c.jpg","nickname":"虫 二","note":"","ucode":"4416C9BFD62F8C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":63532,"discussion_content":"C++17 可以用 shared_ptr 来管理数组的。我这个 smart_ptr 目前还没有管理数组的能力。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574873898,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":62946,"ip_address":"","group_id":0},"score":63532,"extra":""},{"author":{"id":1434808,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e4/b8/e7fd5b9c.jpg","nickname":"虫 二","note":"","ucode":"4416C9BFD62F8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":63625,"discussion_content":"好的，谢谢老师，明白了，当前版本的智能指针只适用于管理一个对象，如果要在这个版本的基础之上实现管理动态数组的智能指针重载[]之外还需要重载该类其它的成员函数对吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574900210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":63532,"ip_address":"","group_id":0},"score":63625,"extra":""},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1434808,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e4/b8/e7fd5b9c.jpg","nickname":"虫 二","note":"","ucode":"4416C9BFD62F8C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":63714,"discussion_content":"当然，要改不少的。可以去看看标准实现的源代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574904530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":63625,"ip_address":"","group_id":0},"score":63714,"extra":""}]}]},{"had_liked":false,"id":155962,"user_name":"中年男子","can_delete":false,"product_type":"c1","uid":1039204,"ip_address":"","ucode":"027C86B3370150","user_header":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","comment_is_top":false,"comment_ctime":1574783706,"is_pvip":false,"replies":[{"id":59932,"content":"一般实现中，只考虑对引用计数的原子操作，那是必须的。并发修改智能指针不是主流用法，需要自行实现或外部加锁。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574814070,"ip_address":"","comment_id":155962,"utype":1}],"discussion_count":1,"race_medal":0,"score":18,"product_id":100040501,"comment_content":"智能指针目前看有两个成员，一个是指向对象的指针，一个是引用计数，多线程读的话只需考虑引用计数的同步即可，可以加锁或者atomic原子操作，涉及写话还要给指针加锁","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476009,"discussion_content":"不正确，this == &amp;amp;other 时会自我销毁。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574857512,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1542834,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJzP9yB6eIRRyVNe3iab0gXB6yOeaNRHGx6raTQz2grfE5N2LWl6uIj1mrSU7nxiaEzeSLp6xAkE3iaQ/132","nickname":"糖","note":"","ucode":"784DDA19104392","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62699,"discussion_content":"老师，我试验了一下，是可行的，我的release函数实现方式是：\nT* release() {\n\t\tT* res = data;\n\t\tdata = nullptr;\n\t\treturn res;\n\t}\n如果this==&amp;other，那么data首先赋为nullptr，后边data=other.release()又将原先的data值返还给data，所以看起来不会被销毁，我这么分析有什么问题吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574858682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1542834,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJzP9yB6eIRRyVNe3iab0gXB6yOeaNRHGx6raTQz2grfE5N2LWl6uIj1mrSU7nxiaEzeSLp6xAkE3iaQ/132","nickname":"糖","note":"","ucode":"784DDA19104392","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":63534,"discussion_content":"如果是unique_ptr方式的，你这样可行。如果是我最终的shared_ptr方式，是没有释放方式的，引用数到零就会导致对象被析构。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574874123,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":62699,"ip_address":"","group_id":0},"score":63534,"extra":""},{"author":{"id":1542834,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJzP9yB6eIRRyVNe3iab0gXB6yOeaNRHGx6raTQz2grfE5N2LWl6uIj1mrSU7nxiaEzeSLp6xAkE3iaQ/132","nickname":"糖","note":"","ucode":"784DDA19104392","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":64009,"discussion_content":"好的，谢谢老师的回复！然后还存在一点点疑问，在最终版的shared_ptr中由于为了满足隐式转换只定义了模板拷贝构造函数，没有定义拷贝构造函数，我在测试时发现如果只定义模板拷贝构造函数，编译器会生成默认的拷贝构造函数，这就导致当我们使用拷贝构造函数的时候优先调用了默认自动生成的拷贝构造函数。要不想在定义模板拷贝构造函数的同时重新定义拷贝构造函数，是否存在合理的方式避免呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574930305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":63534,"ip_address":"","group_id":0},"score":64009,"extra":""},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1542834,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJzP9yB6eIRRyVNe3iab0gXB6yOeaNRHGx6raTQz2grfE5N2LWl6uIj1mrSU7nxiaEzeSLp6xAkE3iaQ/132","nickname":"糖","note":"","ucode":"784DDA19104392","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":65860,"discussion_content":"似乎没有……我也是不该漏的，已经补上了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575032427,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":64009,"ip_address":"","group_id":0},"score":65860,"extra":""}]}]},{"had_liked":false,"id":155911,"user_name":"qinsi","can_delete":false,"product_type":"c1","uid":1667175,"ip_address":"","ucode":"090D9C4068FF12","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","comment_is_top":false,"comment_ctime":1574777699,"is_pvip":true,"replies":[{"id":59925,"content":"抱歉，Rust不熟……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574813327,"ip_address":"","comment_id":155911,"utype":1}],"discussion_count":2,"race_medal":0,"score":18,"product_id":100040501,"comment_content":"不知道是不是因为Rust刚出的时候C++11还没出，所以Rust里默认赋个值就要move ownership","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475941,"discussion_content":"一般实现中，只考虑对引用计数的原子操作，那是必须的。并发修改智能指针不是主流用法，需要自行实现或外部加锁。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574814070,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155894,"user_name":"夜空中最亮的星","can_delete":false,"product_type":"c1","uid":1267566,"ip_address":"","ucode":"ADC3E7B6789955","user_header":"https://static001.geekbang.org/account/avatar/00/13/57/6e/b6795c44.jpg","comment_is_top":false,"comment_ctime":1574775519,"is_pvip":false,"replies":[{"id":59915,"content":"哈哈，照骗嘛。谢谢。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574812072,"ip_address":"","comment_id":155894,"utype":1}],"discussion_count":1,"race_medal":0,"score":18,"product_id":100040501,"comment_content":"老师您真有近30年的编程经验吗？我咋看你就二十几岁的样子啊？😄","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475923,"discussion_content":"抱歉，Rust不熟……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574813327,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1321408,"avatar":"https://static001.geekbang.org/account/avatar/00/14/29/c0/86fa3e92.jpg","nickname":"贾陆华","note":"","ucode":"2722C422077EE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":66545,"discussion_content":"Rust中所有权转移的重要特点是，它是所有类型的默认语义。这是许多读者一开始不习惯的地方。这里再重复一遍，请大家牢牢记住，Rust中的变量绑定操作，默认是move语义，执行了新的变量绑定后，原来的变量就不能再被使用！一定要记住！\nRust的这一规定非常有利于编译器静态检查。  ———引用自  深入浅出Rust，两个语言设计目标不一样，Rust更注重编译时就能消除大部分的内存和并发安全问题，所以有些是不得不做的设计。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575083622,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155800,"user_name":"微秒","can_delete":false,"product_type":"c1","uid":1249195,"ip_address":"","ucode":"65A2E8B565B191","user_header":"https://static001.geekbang.org/account/avatar/00/13/0f/ab/9748f40b.jpg","comment_is_top":false,"comment_ctime":1574758478,"is_pvip":false,"replies":[{"id":59876,"content":"缺省值语义和只有引用语义，区别确实是很大的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574764995,"ip_address":"","comment_id":155800,"utype":1}],"discussion_count":1,"race_medal":0,"score":18,"product_id":100040501,"comment_content":"看了这两章，对C++的智能指针和内存管理有了较清晰的认识了，完全不同于java和python啊","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475915,"discussion_content":"哈哈，照骗嘛。谢谢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574812072,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156630,"user_name":"Geek_4uglyb","can_delete":false,"product_type":"c1","uid":1203822,"ip_address":"","ucode":"3D443DA7DBCC6C","user_header":"https://static001.geekbang.org/account/avatar/00/12/5e/6e/1a032e01.jpg","comment_is_top":false,"comment_ctime":1574926664,"is_pvip":false,"replies":[{"id":60162,"content":"没有笔误。不过，我现在在正文中换了种说法，也许可以减少点误解：\n\n“如果我们想消除代码重复、删除移动构造函数的话，就需要把拷贝构造函数标记成 = delete 了”","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574950836,"ip_address":"","comment_id":156630,"utype":1}],"discussion_count":2,"race_medal":0,"score":18,"product_id":100040501,"comment_content":"“需要注意，上面这个构造函数不被编译器看作移动构造函数，因而不能自动触发删除拷贝构造函数的行为。如果我们想使代码更简洁、删除移动构造函数的话，就需要把拷贝构造函数标记成 = delete 了（见“拷贝构造和赋值”一节）。  ”。  笔误了吧 “如果我们想使代码更简洁、删除移动构造函数的话” 应该是 删除拷贝构造函数 吧","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476180,"discussion_content":"没有笔误。不过，我现在在正文中换了种说法，也许可以减少点误解：\n\n“如果我们想消除代码重复、删除移动构造函数的话，就需要把拷贝构造函数标记成 = delete 了”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574950836,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1203822,"avatar":"https://static001.geekbang.org/account/avatar/00/12/5e/6e/1a032e01.jpg","nickname":"Geek_4uglyb","note":"","ucode":"3D443DA7DBCC6C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":65356,"discussion_content":"看了下effective modern c++的条款17，发现之前的回复是我理解错了。😂 也就是说 1、成员函数模版不会阻止特殊成员函数的生成；2、移动操作只在没有显示声明拷贝/析构函数的类中生成；","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574997622,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156628,"user_name":"孟宪轲","can_delete":false,"product_type":"c1","uid":1487040,"ip_address":"","ucode":"753879DAAEFB2B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLZUA1byglmJVwPuT2BA8ic2iaNFfIfZJicenWiaxdz9nod0KIlxyNTra4qxO7jPDgC1FFCq5CJGgLX5g/132","comment_is_top":false,"comment_ctime":1574926532,"is_pvip":false,"replies":[{"id":60159,"content":"因为一般情况下，你希望可以用const smart_ptr&amp;来构造出一个新的smart_ptr。至于断点问题，那就可能跟具体的编译器和编译选项有关了，我这边没啥好的答案。（我设断点都没有问题的。）\n\nconst只保证不改other的成员，不保证不改成员指向的内容。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574948165,"ip_address":"","comment_id":156628,"utype":1}],"discussion_count":1,"race_medal":0,"score":18,"product_id":100040501,"comment_content":"完整smart_ptr代码列表中，形参other要增加引用计数，为什么前面加const？我调试代码加const的构造函数不进断点，去掉const能正常进入断点。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476178,"discussion_content":"因为一般情况下，你希望可以用const smart_ptr&amp;amp;来构造出一个新的smart_ptr。至于断点问题，那就可能跟具体的编译器和编译选项有关了，我这边没啥好的答案。（我设断点都没有问题的。）\n\nconst只保证不改other的成员，不保证不改成员指向的内容。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574948165,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156540,"user_name":"朱熙","can_delete":false,"product_type":"c1","uid":1039029,"ip_address":"","ucode":"2B9E2B8645A844","user_header":"https://static001.geekbang.org/account/avatar/00/0f/da/b5/9d1f2f55.jpg","comment_is_top":false,"comment_ctime":1574907239,"is_pvip":false,"replies":[{"id":60110,"content":"嗯，加油。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574913886,"ip_address":"","comment_id":156540,"utype":1}],"discussion_count":1,"race_medal":0,"score":18,"product_id":100040501,"comment_content":"看了不少课程，但是由于母语是c++，因此一直也没有留言。第一次留言，虽然看起来略微吃力，但是基本还算能看懂，而且对于以前一些模糊的东西的确有了更清晰的认识，很期待后面的课程~","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476058,"discussion_content":"不太明白你的评论。不过呢，如果谁读过Meyers的四本Effective系列，这个专栏能让他学习的新知识可能就不太多了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574858221,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156291,"user_name":"nullptr","can_delete":false,"product_type":"c1","uid":1759752,"ip_address":"","ucode":"1A26EA0D1A2C10","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqtvuo1wE3XU1mBmtIDfrAQZ2NofBQM5sZhBWicMXicdsrfJ6t87yrlXwqFj0PB6Kx8QU3AVCR4TIHw/132","comment_is_top":false,"comment_ctime":1574851004,"is_pvip":false,"replies":[{"id":60052,"content":"不太明白你的评论。不过呢，如果谁读过Meyers的四本Effective系列，这个专栏能让他学习的新知识可能就不太多了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574858221,"ip_address":"","comment_id":156291,"utype":1}],"discussion_count":1,"race_medal":0,"score":18,"product_id":100040501,"comment_content":"我觉得effective c++也有相关说明","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476058,"discussion_content":"不太明白你的评论。不过呢，如果谁读过Meyers的四本Effective系列，这个专栏能让他学习的新知识可能就不太多了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574858221,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156248,"user_name":"虫 二","can_delete":false,"product_type":"c1","uid":1434808,"ip_address":"","ucode":"4416C9BFD62F8C","user_header":"https://static001.geekbang.org/account/avatar/00/15/e4/b8/e7fd5b9c.jpg","comment_is_top":false,"comment_ctime":1574842715,"is_pvip":false,"replies":[{"id":60049,"content":"下标？现在只管理一个对象，下标有什么用？","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574857957,"ip_address":"","comment_id":156248,"utype":1}],"discussion_count":5,"race_medal":0,"score":18,"product_id":100040501,"comment_content":"应该还要添加下标访问，比较的重载，看得有些吃力，还是得坚持下","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476048,"discussion_content":"下标？现在只管理一个对象，下标有什么用？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574857957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1434808,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e4/b8/e7fd5b9c.jpg","nickname":"虫 二","note":"","ucode":"4416C9BFD62F8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62946,"discussion_content":"对哦，谢谢老师，可是我之前在cppreferenc参考手册中有看到shared_ptr重载了〔〕C++17特性，有点不太理解了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574864521,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1434808,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e4/b8/e7fd5b9c.jpg","nickname":"虫 二","note":"","ucode":"4416C9BFD62F8C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":63532,"discussion_content":"C++17 可以用 shared_ptr 来管理数组的。我这个 smart_ptr 目前还没有管理数组的能力。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574873898,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":62946,"ip_address":"","group_id":0},"score":63532,"extra":""},{"author":{"id":1434808,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e4/b8/e7fd5b9c.jpg","nickname":"虫 二","note":"","ucode":"4416C9BFD62F8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":63625,"discussion_content":"好的，谢谢老师，明白了，当前版本的智能指针只适用于管理一个对象，如果要在这个版本的基础之上实现管理动态数组的智能指针重载[]之外还需要重载该类其它的成员函数对吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574900210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":63532,"ip_address":"","group_id":0},"score":63625,"extra":""},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1434808,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e4/b8/e7fd5b9c.jpg","nickname":"虫 二","note":"","ucode":"4416C9BFD62F8C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":63714,"discussion_content":"当然，要改不少的。可以去看看标准实现的源代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574904530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":63625,"ip_address":"","group_id":0},"score":63714,"extra":""}]}]},{"had_liked":false,"id":156151,"user_name":"糖","can_delete":false,"product_type":"c1","uid":1542834,"ip_address":"","ucode":"784DDA19104392","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJzP9yB6eIRRyVNe3iab0gXB6yOeaNRHGx6raTQz2grfE5N2LWl6uIj1mrSU7nxiaEzeSLp6xAkE3iaQ/132","comment_is_top":false,"comment_ctime":1574824999,"is_pvip":false,"replies":[{"id":60045,"content":"不正确，this == &amp;other 时会自我销毁。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574857512,"ip_address":"","comment_id":156151,"utype":1}],"discussion_count":6,"race_medal":0,"score":18,"product_id":100040501,"comment_content":"吴老师好，smart_ptr的拷贝构造函数和赋值运算符是否可以同种方法解决，比如，上面赋值运算符中swap部分的代码改成release：\n\tsmart_ptr&amp; operator=(smart_ptr&amp; other) {\n\t\tdata = other.release();\n\t\treturn *this;\n\t}\n这段代码是正确的吗？对于单纯实现smart_ptr有缺陷的地方吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476009,"discussion_content":"不正确，this == &amp;amp;other 时会自我销毁。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574857512,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1542834,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJzP9yB6eIRRyVNe3iab0gXB6yOeaNRHGx6raTQz2grfE5N2LWl6uIj1mrSU7nxiaEzeSLp6xAkE3iaQ/132","nickname":"糖","note":"","ucode":"784DDA19104392","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62699,"discussion_content":"老师，我试验了一下，是可行的，我的release函数实现方式是：\nT* release() {\n\t\tT* res = data;\n\t\tdata = nullptr;\n\t\treturn res;\n\t}\n如果this==&amp;other，那么data首先赋为nullptr，后边data=other.release()又将原先的data值返还给data，所以看起来不会被销毁，我这么分析有什么问题吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574858682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1542834,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJzP9yB6eIRRyVNe3iab0gXB6yOeaNRHGx6raTQz2grfE5N2LWl6uIj1mrSU7nxiaEzeSLp6xAkE3iaQ/132","nickname":"糖","note":"","ucode":"784DDA19104392","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":63534,"discussion_content":"如果是unique_ptr方式的，你这样可行。如果是我最终的shared_ptr方式，是没有释放方式的，引用数到零就会导致对象被析构。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574874123,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":62699,"ip_address":"","group_id":0},"score":63534,"extra":""},{"author":{"id":1542834,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJzP9yB6eIRRyVNe3iab0gXB6yOeaNRHGx6raTQz2grfE5N2LWl6uIj1mrSU7nxiaEzeSLp6xAkE3iaQ/132","nickname":"糖","note":"","ucode":"784DDA19104392","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":64009,"discussion_content":"好的，谢谢老师的回复！然后还存在一点点疑问，在最终版的shared_ptr中由于为了满足隐式转换只定义了模板拷贝构造函数，没有定义拷贝构造函数，我在测试时发现如果只定义模板拷贝构造函数，编译器会生成默认的拷贝构造函数，这就导致当我们使用拷贝构造函数的时候优先调用了默认自动生成的拷贝构造函数。要不想在定义模板拷贝构造函数的同时重新定义拷贝构造函数，是否存在合理的方式避免呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574930305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":63534,"ip_address":"","group_id":0},"score":64009,"extra":""},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1542834,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJzP9yB6eIRRyVNe3iab0gXB6yOeaNRHGx6raTQz2grfE5N2LWl6uIj1mrSU7nxiaEzeSLp6xAkE3iaQ/132","nickname":"糖","note":"","ucode":"784DDA19104392","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":65860,"discussion_content":"似乎没有……我也是不该漏的，已经补上了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575032427,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":64009,"ip_address":"","group_id":0},"score":65860,"extra":""}]}]},{"had_liked":false,"id":155962,"user_name":"中年男子","can_delete":false,"product_type":"c1","uid":1039204,"ip_address":"","ucode":"027C86B3370150","user_header":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","comment_is_top":false,"comment_ctime":1574783706,"is_pvip":false,"replies":[{"id":59932,"content":"一般实现中，只考虑对引用计数的原子操作，那是必须的。并发修改智能指针不是主流用法，需要自行实现或外部加锁。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574814070,"ip_address":"","comment_id":155962,"utype":1}],"discussion_count":1,"race_medal":0,"score":18,"product_id":100040501,"comment_content":"智能指针目前看有两个成员，一个是指向对象的指针，一个是引用计数，多线程读的话只需考虑引用计数的同步即可，可以加锁或者atomic原子操作，涉及写话还要给指针加锁","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475941,"discussion_content":"一般实现中，只考虑对引用计数的原子操作，那是必须的。并发修改智能指针不是主流用法，需要自行实现或外部加锁。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574814070,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155911,"user_name":"qinsi","can_delete":false,"product_type":"c1","uid":1667175,"ip_address":"","ucode":"090D9C4068FF12","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","comment_is_top":false,"comment_ctime":1574777699,"is_pvip":true,"replies":[{"id":59925,"content":"抱歉，Rust不熟……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574813327,"ip_address":"","comment_id":155911,"utype":1}],"discussion_count":2,"race_medal":0,"score":18,"product_id":100040501,"comment_content":"不知道是不是因为Rust刚出的时候C++11还没出，所以Rust里默认赋个值就要move ownership","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475923,"discussion_content":"抱歉，Rust不熟……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574813327,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1321408,"avatar":"https://static001.geekbang.org/account/avatar/00/14/29/c0/86fa3e92.jpg","nickname":"贾陆华","note":"","ucode":"2722C422077EE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":66545,"discussion_content":"Rust中所有权转移的重要特点是，它是所有类型的默认语义。这是许多读者一开始不习惯的地方。这里再重复一遍，请大家牢牢记住，Rust中的变量绑定操作，默认是move语义，执行了新的变量绑定后，原来的变量就不能再被使用！一定要记住！\nRust的这一规定非常有利于编译器静态检查。  ———引用自  深入浅出Rust，两个语言设计目标不一样，Rust更注重编译时就能消除大部分的内存和并发安全问题，所以有些是不得不做的设计。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575083622,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155894,"user_name":"夜空中最亮的星","can_delete":false,"product_type":"c1","uid":1267566,"ip_address":"","ucode":"ADC3E7B6789955","user_header":"https://static001.geekbang.org/account/avatar/00/13/57/6e/b6795c44.jpg","comment_is_top":false,"comment_ctime":1574775519,"is_pvip":false,"replies":[{"id":59915,"content":"哈哈，照骗嘛。谢谢。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574812072,"ip_address":"","comment_id":155894,"utype":1}],"discussion_count":1,"race_medal":0,"score":18,"product_id":100040501,"comment_content":"老师您真有近30年的编程经验吗？我咋看你就二十几岁的样子啊？😄","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475915,"discussion_content":"哈哈，照骗嘛。谢谢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574812072,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155800,"user_name":"微秒","can_delete":false,"product_type":"c1","uid":1249195,"ip_address":"","ucode":"65A2E8B565B191","user_header":"https://static001.geekbang.org/account/avatar/00/13/0f/ab/9748f40b.jpg","comment_is_top":false,"comment_ctime":1574758478,"is_pvip":false,"replies":[{"id":59876,"content":"缺省值语义和只有引用语义，区别确实是很大的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574764995,"ip_address":"","comment_id":155800,"utype":1}],"discussion_count":1,"race_medal":0,"score":18,"product_id":100040501,"comment_content":"看了这两章，对C++的智能指针和内存管理有了较清晰的认识了，完全不同于java和python啊","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475877,"discussion_content":"缺省值语义和只有引用语义，区别确实是很大的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574764995,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155751,"user_name":"bearlu","can_delete":false,"product_type":"c1","uid":1030862,"ip_address":"","ucode":"14F260C8B24E27","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/ce/fd45714f.jpg","comment_is_top":false,"comment_ctime":1574748048,"is_pvip":true,"replies":[{"id":59872,"content":"完整代码在结尾处啊。拷贝粘贴大法就可以了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574764299,"ip_address":"","comment_id":155751,"utype":1}],"discussion_count":1,"race_medal":0,"score":19,"product_id":100040501,"comment_content":"老师，这边有源码？可以拿来调试一下。","like_count":0},{"had_liked":false,"id":155518,"user_name":"Txz","can_delete":false,"product_type":"c1","uid":1441211,"ip_address":"","ucode":"42841DC8522D42","user_header":"https://static001.geekbang.org/account/avatar/00/15/fd/bb/068a7228.jpg","comment_is_top":false,"comment_ctime":1574694862,"is_pvip":false,"replies":[{"id":59701,"content":"没关系的。学习就是要多读多写多练。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574732602,"ip_address":"","comment_id":155518,"utype":1}],"discussion_count":1,"race_medal":0,"score":19,"product_id":100040501,"comment_content":"一遍下来，还是觉得理解的不够，只能反复阅读。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475857,"discussion_content":"完整代码在结尾处啊。拷贝粘贴大法就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574764299,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155473,"user_name":"灯盖","can_delete":false,"product_type":"c1","uid":1482839,"ip_address":"","ucode":"0F8455A593D60C","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/57/3a729755.jpg","comment_is_top":false,"comment_ctime":1574691285,"is_pvip":false,"replies":[{"id":59666,"content":"😄","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574693341,"ip_address":"","comment_id":155473,"utype":1}],"discussion_count":1,"race_medal":0,"score":19,"product_id":100040501,"comment_content":"面试高频题目","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475782,"discussion_content":"没关系的。学习就是要多读多写多练。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574732602,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174880,"user_name":"czh","can_delete":false,"product_type":"c1","uid":1159078,"ip_address":"","ucode":"649FE5C9269D69","user_header":"https://static001.geekbang.org/account/avatar/00/11/af/a6/3f15ba2f.jpg","comment_is_top":false,"comment_ctime":1580445231,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":19,"product_id":100040501,"comment_content":"这种优质文章，对于像我一样的初学者，还是要换气读，要不容易呛水，哈哈哈哈哈","like_count":7},{"had_liked":false,"id":156641,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1574929131,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":19,"product_id":100040501,"comment_content":"当我艰难的看完第一遍过后我又去复习了一下拷贝构造,并且了解了移动构造,又有新的感悟如下\n1. 在例子 方案一 尝试在拷贝构造转移指针的所有权 通过拷贝构造 获得一个临时指针该指针用来接替将亡对象的指针所指的地址 然后将将亡对象的指针置为空 释放将亡对象对目标的控制 同时将临时指针返回然后拷贝构造的对象接管目标\n2. 赋值函数也是同样的操作  将目标转交给对象 然后将亡对象释放对目标的控制\n移动构造的缺陷确实是在交出了控制权后就不再拥有这个对象了\n3. smart_ptr&lt;circle&gt; 转换成smart_ptr&lt;shape&gt; 增加了一个构造函数 不能将smart_ptr&lt;circle&gt;转换成smart_ptr&lt;triangle&gt;的原因就因为triangle不是circle类的父类吧 所以转换是不安全的,而且应该是不会成功的\n4. fatal error: ‘ptr_’ is a private member of ‘smart_ptr&lt;circle&gt;’针对这个错误其实还可以提供一个设置和获取的接口 如果用友元类的话 还会破坏代码的封装性哦嘿嘿\n第二遍看的时候感觉轻松了很多 基本上了解了 unique_ptr 和shared_ptr的原理  但是更多的确实复习了一遍各种构造函数和学习了 移动构造....\n直接回答第3问 \n一定要避免 多线程的异步操作 比如shared_ptr在引用为1的时候 一个线程在引用 如果一个线程在释放就会出大问题哒 所以应该保证同步性\n\n","like_count":3},{"had_liked":false,"id":363647,"user_name":"Geek_7c0961","can_delete":false,"product_type":"c1","uid":2277181,"ip_address":"美国","ucode":"B1482E64FF9E4E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ8aLz0tWdsZuMiaNUAd0dicSD9M6A77seMGFdHgvsQwOzN8ztYPiaJSo53DcbjQWUQpw4pf4rI2f7vg/132","comment_is_top":false,"comment_ctime":1669914963,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":19,"product_id":100040501,"comment_content":"讲得真好,有深度.","like_count":1},{"had_liked":false,"id":299580,"user_name":"宵练2233","can_delete":false,"product_type":"c1","uid":2662996,"ip_address":"","ucode":"3EBDF8195040DA","user_header":"https://static001.geekbang.org/account/avatar/00/28/a2/54/49dfb810.jpg","comment_is_top":false,"comment_ctime":1624721441,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":19,"product_id":100040501,"comment_content":"在调用smart_ptr时，需要显性地先去调用new然后构造智能指针，智能指针的构造函数内部又调用了一个\nnew去构造count，两个new这可能会影响性能。shared_ptr有一个make_shared函数直接构造智能指针和它指向的对象，只调用一次new，一次将对象和count的内存分配出来。","like_count":1},{"had_liked":false,"id":279509,"user_name":"doge","can_delete":false,"product_type":"c1","uid":1593251,"ip_address":"","ucode":"9E2D4C8F9B4CBC","user_header":"https://static001.geekbang.org/account/avatar/00/18/4f/a3/0e56b4e5.jpg","comment_is_top":false,"comment_ctime":1613810036,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":19,"product_id":100040501,"comment_content":"本章看了1天，照着码代码码了一天，结合老师给的文章链接，终于明白了赋值运算里的smart_ptr other值定义的妙处，复用了 拷贝&#47;移动构造函数，且将异常的检查交给了编译器，同事让赋值的函数及其简单，真是妙啊，学到了！","like_count":1},{"had_liked":false,"id":274802,"user_name":"Geek_f8fcc0","can_delete":false,"product_type":"c1","uid":2376292,"ip_address":"","ucode":"B87BCD9D63CB60","user_header":"","comment_is_top":false,"comment_ctime":1611162728,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":19,"product_id":100040501,"comment_content":"我觉得老师好强！","like_count":1},{"had_liked":false,"id":157578,"user_name":"楚小奕","can_delete":false,"product_type":"c1","uid":1011022,"ip_address":"","ucode":"AB808A42C2535E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6d/4e/347c3e8f.jpg","comment_is_top":false,"comment_ctime":1575201229,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":19,"product_id":100040501,"comment_content":"写的很好～～ 等更新","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475763,"discussion_content":"😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574693341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155751,"user_name":"bearlu","can_delete":false,"product_type":"c1","uid":1030862,"ip_address":"","ucode":"14F260C8B24E27","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/ce/fd45714f.jpg","comment_is_top":false,"comment_ctime":1574748048,"is_pvip":true,"replies":[{"id":59872,"content":"完整代码在结尾处啊。拷贝粘贴大法就可以了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574764299,"ip_address":"","comment_id":155751,"utype":1}],"discussion_count":1,"race_medal":0,"score":19,"product_id":100040501,"comment_content":"老师，这边有源码？可以拿来调试一下。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475857,"discussion_content":"完整代码在结尾处啊。拷贝粘贴大法就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574764299,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155518,"user_name":"Txz","can_delete":false,"product_type":"c1","uid":1441211,"ip_address":"","ucode":"42841DC8522D42","user_header":"https://static001.geekbang.org/account/avatar/00/15/fd/bb/068a7228.jpg","comment_is_top":false,"comment_ctime":1574694862,"is_pvip":false,"replies":[{"id":59701,"content":"没关系的。学习就是要多读多写多练。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574732602,"ip_address":"","comment_id":155518,"utype":1}],"discussion_count":1,"race_medal":0,"score":19,"product_id":100040501,"comment_content":"一遍下来，还是觉得理解的不够，只能反复阅读。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475782,"discussion_content":"没关系的。学习就是要多读多写多练。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574732602,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155473,"user_name":"灯盖","can_delete":false,"product_type":"c1","uid":1482839,"ip_address":"","ucode":"0F8455A593D60C","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/57/3a729755.jpg","comment_is_top":false,"comment_ctime":1574691285,"is_pvip":false,"replies":[{"id":59666,"content":"😄","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1574693341,"ip_address":"","comment_id":155473,"utype":1}],"discussion_count":1,"race_medal":0,"score":19,"product_id":100040501,"comment_content":"面试高频题目","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475763,"discussion_content":"😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574693341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174880,"user_name":"czh","can_delete":false,"product_type":"c1","uid":1159078,"ip_address":"","ucode":"649FE5C9269D69","user_header":"https://static001.geekbang.org/account/avatar/00/11/af/a6/3f15ba2f.jpg","comment_is_top":false,"comment_ctime":1580445231,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":19,"product_id":100040501,"comment_content":"这种优质文章，对于像我一样的初学者，还是要换气读，要不容易呛水，哈哈哈哈哈","like_count":7},{"had_liked":false,"id":156641,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1574929131,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":19,"product_id":100040501,"comment_content":"当我艰难的看完第一遍过后我又去复习了一下拷贝构造,并且了解了移动构造,又有新的感悟如下\n1. 在例子 方案一 尝试在拷贝构造转移指针的所有权 通过拷贝构造 获得一个临时指针该指针用来接替将亡对象的指针所指的地址 然后将将亡对象的指针置为空 释放将亡对象对目标的控制 同时将临时指针返回然后拷贝构造的对象接管目标\n2. 赋值函数也是同样的操作  将目标转交给对象 然后将亡对象释放对目标的控制\n移动构造的缺陷确实是在交出了控制权后就不再拥有这个对象了\n3. smart_ptr&lt;circle&gt; 转换成smart_ptr&lt;shape&gt; 增加了一个构造函数 不能将smart_ptr&lt;circle&gt;转换成smart_ptr&lt;triangle&gt;的原因就因为triangle不是circle类的父类吧 所以转换是不安全的,而且应该是不会成功的\n4. fatal error: ‘ptr_’ is a private member of ‘smart_ptr&lt;circle&gt;’针对这个错误其实还可以提供一个设置和获取的接口 如果用友元类的话 还会破坏代码的封装性哦嘿嘿\n第二遍看的时候感觉轻松了很多 基本上了解了 unique_ptr 和shared_ptr的原理  但是更多的确实复习了一遍各种构造函数和学习了 移动构造....\n直接回答第3问 \n一定要避免 多线程的异步操作 比如shared_ptr在引用为1的时候 一个线程在引用 如果一个线程在释放就会出大问题哒 所以应该保证同步性\n\n","like_count":3},{"had_liked":false,"id":363647,"user_name":"Geek_7c0961","can_delete":false,"product_type":"c1","uid":2277181,"ip_address":"美国","ucode":"B1482E64FF9E4E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ8aLz0tWdsZuMiaNUAd0dicSD9M6A77seMGFdHgvsQwOzN8ztYPiaJSo53DcbjQWUQpw4pf4rI2f7vg/132","comment_is_top":false,"comment_ctime":1669914963,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":19,"product_id":100040501,"comment_content":"讲得真好,有深度.","like_count":1},{"had_liked":false,"id":299580,"user_name":"宵练2233","can_delete":false,"product_type":"c1","uid":2662996,"ip_address":"","ucode":"3EBDF8195040DA","user_header":"https://static001.geekbang.org/account/avatar/00/28/a2/54/49dfb810.jpg","comment_is_top":false,"comment_ctime":1624721441,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":19,"product_id":100040501,"comment_content":"在调用smart_ptr时，需要显性地先去调用new然后构造智能指针，智能指针的构造函数内部又调用了一个\nnew去构造count，两个new这可能会影响性能。shared_ptr有一个make_shared函数直接构造智能指针和它指向的对象，只调用一次new，一次将对象和count的内存分配出来。","like_count":1},{"had_liked":false,"id":279509,"user_name":"doge","can_delete":false,"product_type":"c1","uid":1593251,"ip_address":"","ucode":"9E2D4C8F9B4CBC","user_header":"https://static001.geekbang.org/account/avatar/00/18/4f/a3/0e56b4e5.jpg","comment_is_top":false,"comment_ctime":1613810036,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":19,"product_id":100040501,"comment_content":"本章看了1天，照着码代码码了一天，结合老师给的文章链接，终于明白了赋值运算里的smart_ptr other值定义的妙处，复用了 拷贝&#47;移动构造函数，且将异常的检查交给了编译器，同事让赋值的函数及其简单，真是妙啊，学到了！","like_count":1},{"had_liked":false,"id":274802,"user_name":"Geek_f8fcc0","can_delete":false,"product_type":"c1","uid":2376292,"ip_address":"","ucode":"B87BCD9D63CB60","user_header":"","comment_is_top":false,"comment_ctime":1611162728,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":19,"product_id":100040501,"comment_content":"我觉得老师好强！","like_count":1},{"had_liked":false,"id":157578,"user_name":"楚小奕","can_delete":false,"product_type":"c1","uid":1011022,"ip_address":"","ucode":"AB808A42C2535E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6d/4e/347c3e8f.jpg","comment_is_top":false,"comment_ctime":1575201229,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":19,"product_id":100040501,"comment_content":"写的很好～～ 等更新","like_count":1},{"had_liked":false,"id":347381,"user_name":"大象佩奇","can_delete":false,"product_type":"c1","uid":1070165,"ip_address":"","ucode":"EAFB4FA3B9CFEF","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/55/f686c2ed.jpg","comment_is_top":false,"comment_ctime":1653981311,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":20,"product_id":100040501,"comment_content":"大脑缺氧了...","like_count":0},{"had_liked":false,"id":325911,"user_name":"ue5","can_delete":false,"product_type":"c1","uid":2754983,"ip_address":"","ucode":"6CA310ACE02ED4","user_header":"https://static001.geekbang.org/account/avatar/00/2a/09/a7/541e33bc.jpg","comment_is_top":false,"comment_ctime":1639227261,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":20,"product_id":100040501,"comment_content":"原来如此    多个共享指针共同维护一个Count对象   ","like_count":0},{"had_liked":false,"id":279645,"user_name":"Geek_227a72","can_delete":false,"product_type":"c1","uid":2417911,"ip_address":"","ucode":"385B764D9AEAE8","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKsI6VdljHFtMx4cgEPpqhXiaIYQicqGcal8sIoBYQZn7tYQyPLH1FuOVP8SaYPghPIsqSa1DWjRT2A/132","comment_is_top":false,"comment_ctime":1613888802,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":20,"product_id":100040501,"comment_content":"smart_ptr&lt;shape&gt; ptr1{create_shape(shape_type::circle)};\nsmart_ptr&lt;shape&gt; ptr2{ptr1};             &#47;&#47; 编译出错\nsmart_ptr&lt;shape&gt; ptr3;\nptr3 = ptr1;                             &#47;&#47; 编译出错\nptr3 = std::move(ptr1);                  &#47;&#47; OK，可以\nsmart_ptr&lt;shape&gt; ptr4{std::move(ptr3)};  &#47;&#47; OK，\n\n这段代码只能移动赋值，而不能拷贝赋值，所以编译出错","like_count":0},{"had_liked":false,"id":277316,"user_name":"胡梦龙","can_delete":false,"product_type":"c1","uid":2419779,"ip_address":"","ucode":"E8AE0B96043D5F","user_header":"https://static001.geekbang.org/account/avatar/00/24/ec/43/0d38ddb3.jpg","comment_is_top":false,"comment_ctime":1612355795,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":20,"product_id":100040501,"comment_content":"感谢老师，四个小时才跟着敲了一遍，还需要多理解理解，c++果然博大精深啊。老师超棒！","like_count":0},{"had_liked":false,"id":176230,"user_name":"风清扬","can_delete":false,"product_type":"c1","uid":1047043,"ip_address":"","ucode":"651F1390B64953","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fa/03/eba78e43.jpg","comment_is_top":false,"comment_ctime":1580995925,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":20,"product_id":100040501,"comment_content":"28行的friend class smart_ptr;，这个作用是啥？自己是自己的友元?这个去掉也能正确运行。","like_count":0},{"had_liked":false,"id":174434,"user_name":"一只小船","can_delete":false,"product_type":"c1","uid":1813421,"ip_address":"","ucode":"A8BDA47C77052E","user_header":"https://static001.geekbang.org/account/avatar/00/1b/ab/ad/244647e1.jpg","comment_is_top":false,"comment_ctime":1580207120,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":20,"product_id":100040501,"comment_content":"讲的太好了，对于智能指针的剖析真的太棒了，受益匪浅，谢谢讲师。","like_count":0},{"had_liked":false,"id":168780,"user_name":"刘德聪","can_delete":false,"product_type":"c1","uid":1316662,"ip_address":"","ucode":"2968605D077072","user_header":"https://static001.geekbang.org/account/avatar/00/14/17/36/3d8e86e6.jpg","comment_is_top":false,"comment_ctime":1578157322,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":20,"product_id":100040501,"comment_content":"跟着老师思路，讲的真好。","like_count":0},{"had_liked":false,"id":157234,"user_name":"皓首不倦","can_delete":false,"product_type":"c1","uid":1144626,"ip_address":"","ucode":"FA7D282DD40D83","user_header":"https://static001.geekbang.org/account/avatar/00/11/77/32/02416d97.jpg","comment_is_top":false,"comment_ctime":1575093502,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":20,"product_id":100040501,"comment_content":"请问下老师为什么 smart ptr 的左值引用版本构造函数有两个版本 一个泛型版本 一个非泛型版本 但是函数体内容是一模一样的 这样设计的意图是什么呢？","like_count":0},{"had_liked":false,"id":347381,"user_name":"大象佩奇","can_delete":false,"product_type":"c1","uid":1070165,"ip_address":"","ucode":"EAFB4FA3B9CFEF","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/55/f686c2ed.jpg","comment_is_top":false,"comment_ctime":1653981311,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":20,"product_id":100040501,"comment_content":"大脑缺氧了...","like_count":0},{"had_liked":false,"id":325911,"user_name":"ue5","can_delete":false,"product_type":"c1","uid":2754983,"ip_address":"","ucode":"6CA310ACE02ED4","user_header":"https://static001.geekbang.org/account/avatar/00/2a/09/a7/541e33bc.jpg","comment_is_top":false,"comment_ctime":1639227261,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":20,"product_id":100040501,"comment_content":"原来如此    多个共享指针共同维护一个Count对象   ","like_count":0},{"had_liked":false,"id":279645,"user_name":"Geek_227a72","can_delete":false,"product_type":"c1","uid":2417911,"ip_address":"","ucode":"385B764D9AEAE8","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKsI6VdljHFtMx4cgEPpqhXiaIYQicqGcal8sIoBYQZn7tYQyPLH1FuOVP8SaYPghPIsqSa1DWjRT2A/132","comment_is_top":false,"comment_ctime":1613888802,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":20,"product_id":100040501,"comment_content":"smart_ptr&lt;shape&gt; ptr1{create_shape(shape_type::circle)};\nsmart_ptr&lt;shape&gt; ptr2{ptr1};             &#47;&#47; 编译出错\nsmart_ptr&lt;shape&gt; ptr3;\nptr3 = ptr1;                             &#47;&#47; 编译出错\nptr3 = std::move(ptr1);                  &#47;&#47; OK，可以\nsmart_ptr&lt;shape&gt; ptr4{std::move(ptr3)};  &#47;&#47; OK，\n\n这段代码只能移动赋值，而不能拷贝赋值，所以编译出错","like_count":0},{"had_liked":false,"id":277316,"user_name":"胡梦龙","can_delete":false,"product_type":"c1","uid":2419779,"ip_address":"","ucode":"E8AE0B96043D5F","user_header":"https://static001.geekbang.org/account/avatar/00/24/ec/43/0d38ddb3.jpg","comment_is_top":false,"comment_ctime":1612355795,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":20,"product_id":100040501,"comment_content":"感谢老师，四个小时才跟着敲了一遍，还需要多理解理解，c++果然博大精深啊。老师超棒！","like_count":0},{"had_liked":false,"id":176230,"user_name":"风清扬","can_delete":false,"product_type":"c1","uid":1047043,"ip_address":"","ucode":"651F1390B64953","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fa/03/eba78e43.jpg","comment_is_top":false,"comment_ctime":1580995925,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":20,"product_id":100040501,"comment_content":"28行的friend class smart_ptr;，这个作用是啥？自己是自己的友元?这个去掉也能正确运行。","like_count":0},{"had_liked":false,"id":174434,"user_name":"一只小船","can_delete":false,"product_type":"c1","uid":1813421,"ip_address":"","ucode":"A8BDA47C77052E","user_header":"https://static001.geekbang.org/account/avatar/00/1b/ab/ad/244647e1.jpg","comment_is_top":false,"comment_ctime":1580207120,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":20,"product_id":100040501,"comment_content":"讲的太好了，对于智能指针的剖析真的太棒了，受益匪浅，谢谢讲师。","like_count":0},{"had_liked":false,"id":168780,"user_name":"刘德聪","can_delete":false,"product_type":"c1","uid":1316662,"ip_address":"","ucode":"2968605D077072","user_header":"https://static001.geekbang.org/account/avatar/00/14/17/36/3d8e86e6.jpg","comment_is_top":false,"comment_ctime":1578157322,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":20,"product_id":100040501,"comment_content":"跟着老师思路，讲的真好。","like_count":0},{"had_liked":false,"id":157234,"user_name":"皓首不倦","can_delete":false,"product_type":"c1","uid":1144626,"ip_address":"","ucode":"FA7D282DD40D83","user_header":"https://static001.geekbang.org/account/avatar/00/11/77/32/02416d97.jpg","comment_is_top":false,"comment_ctime":1575093502,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":20,"product_id":100040501,"comment_content":"请问下老师为什么 smart ptr 的左值引用版本构造函数有两个版本 一个泛型版本 一个非泛型版本 但是函数体内容是一模一样的 这样设计的意图是什么呢？","like_count":0}]}