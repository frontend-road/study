{"id":64858,"title":"20 | 散列表（下）：为什么散列表和链表经常会一起使用？","content":"<p>我们已经学习了20节内容，你有没有发现，有两种数据结构，散列表和链表，经常会被放在一起使用。你还记得，前面的章节中都有哪些地方讲到散列表和链表的组合使用吗？我带你一起回忆一下。</p><p>在链表那一节，我讲到如何用链表来实现LRU缓存淘汰算法，但是链表实现的LRU缓存淘汰算法的时间复杂度是O(n)，当时我也提到了，通过散列表可以将这个时间复杂度降低到O(1)。</p><p>在跳表那一节，我提到Redis的有序集合是使用跳表来实现的，跳表可以看作一种改进版的链表。当时我们也提到，Redis有序集合不仅使用了跳表，还用到了散列表。</p><p>除此之外，如果你熟悉Java编程语言，你会发现LinkedHashMap这样一个常用的容器，也用到了散列表和链表两种数据结构。</p><p>今天，我们就来看看，在这几个问题中，散列表和链表都是如何组合起来使用的，以及为什么散列表和链表会经常放到一块使用。</p><h2>LRU缓存淘汰算法</h2><p>在链表那一节中，我提到，借助散列表，我们可以把LRU缓存淘汰算法的时间复杂度降低为O(1)。现在，我们就来看看它是如何做到的。</p><p>首先，我们来回顾一下当时我们是如何通过链表实现LRU缓存淘汰算法的。</p><p>我们需要维护一个按照访问时间从大到小有序排列的链表结构。因为缓存大小有限，当缓存空间不够，需要淘汰一个数据的时候，我们就直接将链表头部的结点删除。</p><!-- [[[read_end]]] --><p>当要缓存某个数据的时候，先在链表中查找这个数据。如果没有找到，则直接将数据放到链表的尾部；如果找到了，我们就把它移动到链表的尾部。因为查找数据需要遍历链表，所以单纯用链表实现的LRU缓存淘汰算法的时间复杂很高，是O(n)。</p><p>实际上，我总结一下，一个缓存（cache）系统主要包含下面这几个操作：</p><ul>\n<li>\n<p>往缓存中添加一个数据；</p>\n</li>\n<li>\n<p>从缓存中删除一个数据；</p>\n</li>\n<li>\n<p>在缓存中查找一个数据。</p>\n</li>\n</ul><p>这三个操作都要涉及“查找”操作，如果单纯地采用链表的话，时间复杂度只能是O(n)。如果我们将散列表和链表两种数据结构组合使用，可以将这三个操作的时间复杂度都降低到O(1)。具体的结构就是下面这个样子：</p><p><img src=\"https://static001.geekbang.org/resource/image/ea/6e/eaefd5f4028cc7d4cfbb56b24ce8ae6e.jpg?wh=1142*726\" alt=\"\"></p><p>我们使用双向链表存储数据，链表中的每个结点处理存储数据（data）、前驱指针（prev）、后继指针（next）之外，还新增了一个特殊的字段hnext。这个hnext有什么作用呢？</p><p>因为我们的散列表是通过链表法解决散列冲突的，所以每个结点会在两条链中。一个链是刚刚我们提到的<strong>双向链表</strong>，另一个链是散列表中的<strong>拉链</strong>。<strong>前驱和后继指针是为了将结点串在双向链表中，hnext指针是为了将结点串在散列表的拉链中</strong>。</p><p>了解了这个散列表和双向链表的组合存储结构之后，我们再来看，前面讲到的缓存的三个操作，是如何做到时间复杂度是O(1)的？</p><p>首先，我们来看<strong>如何查找一个数据</strong>。我们前面讲过，散列表中查找数据的时间复杂度接近O(1)，所以通过散列表，我们可以很快地在缓存中找到一个数据。当找到数据之后，我们还需要将它移动到双向链表的尾部。</p><p>其次，我们来看<strong>如何删除一个数据</strong>。我们需要找到数据所在的结点，然后将结点删除。借助散列表，我们可以在O(1)时间复杂度里找到要删除的结点。因为我们的链表是双向链表，双向链表可以通过前驱指针O(1)时间复杂度获取前驱结点，所以在双向链表中，删除结点只需要O(1)的时间复杂度。</p><p>最后，我们来看<strong>如何添加一个数据</strong>。添加数据到缓存稍微有点麻烦，我们需要先看这个数据是否已经在缓存中。如果已经在其中，需要将其移动到双向链表的尾部；如果不在其中，还要看缓存有没有满。如果满了，则将双向链表头部的结点删除，然后再将数据放到链表的尾部；如果没有满，就直接将数据放到链表的尾部。</p><p>这整个过程涉及的查找操作都可以通过散列表来完成。其他的操作，比如删除头结点、链表尾部插入数据等，都可以在O(1)的时间复杂度内完成。所以，这三个操作的时间复杂度都是O(1)。至此，我们就通过散列表和双向链表的组合使用，实现了一个高效的、支持LRU缓存淘汰算法的缓存系统原型。</p><h2>Redis有序集合</h2><p>在跳表那一节，讲到有序集合的操作时，我稍微做了些简化。实际上，在有序集合中，每个成员对象有两个重要的属性，<strong>key</strong>（键值）和<strong>score</strong>（分值）。我们不仅会通过score来查找数据，还会通过key来查找数据。</p><p>举个例子，比如用户积分排行榜有这样一个功能：我们可以通过用户的ID来查找积分信息，也可以通过积分区间来查找用户ID或者姓名信息。这里包含ID、姓名和积分的用户信息，就是成员对象，用户ID就是key，积分就是score。</p><p>所以，如果我们细化一下Redis有序集合的操作，那就是下面这样：</p><ul>\n<li>\n<p>添加一个成员对象；</p>\n</li>\n<li>\n<p>按照键值来删除一个成员对象；</p>\n</li>\n<li>\n<p>按照键值来查找一个成员对象；</p>\n</li>\n<li>\n<p>按照分值区间查找数据，比如查找积分在[100, 356]之间的成员对象；</p>\n</li>\n<li>\n<p>按照分值从小到大排序成员变量；</p>\n</li>\n</ul><p>如果我们仅仅按照分值将成员对象组织成跳表的结构，那按照键值来删除、查询成员对象就会很慢，解决方法与LRU缓存淘汰算法的解决方法类似。我们可以再按照键值构建一个散列表，这样按照key来删除、查找一个成员对象的时间复杂度就变成了O(1)。同时，借助跳表结构，其他操作也非常高效。</p><p>实际上，Redis有序集合的操作还有另外一类，也就是查找成员对象的排名（Rank）或者根据排名区间查找成员对象。这个功能单纯用刚刚讲的这种组合结构就无法高效实现了。这块内容我后面的章节再讲。</p><h2>Java LinkedHashMap</h2><p>前面我们讲了两个散列表和链表结合的例子，现在我们再来看另外一个，Java中的LinkedHashMap这种容器。</p><p>如果你熟悉Java，那你几乎天天会用到这个容器。我们之前讲过，HashMap底层是通过散列表这种数据结构实现的。而LinkedHashMap前面比HashMap多了一个“Linked”，这里的“Linked”是不是说，LinkedHashMap是一个通过链表法解决散列冲突的散列表呢？</p><p>实际上，LinkedHashMap并没有这么简单，其中的“Linked”也并不仅仅代表它是通过链表法解决散列冲突的。关于这一点，在我是初学者的时候，也误解了很久。</p><p>我们先来看一段代码。你觉得这段代码会以什么样的顺序打印3，1，5，2这几个key呢？原因又是什么呢？</p><pre><code>HashMap&lt;Integer, Integer&gt; m = new LinkedHashMap&lt;&gt;();\nm.put(3, 11);\nm.put(1, 12);\nm.put(5, 23);\nm.put(2, 22);\n\nfor (Map.Entry e : m.entrySet()) {\n  System.out.println(e.getKey());\n}\n</code></pre><p>我先告诉你答案，上面的代码会按照数据插入的顺序依次来打印，也就是说，打印的顺序就是3，1，5，2。你有没有觉得奇怪？散列表中数据是经过散列函数打乱之后无规律存储的，这里是如何实现按照数据的插入顺序来遍历打印的呢？</p><p>你可能已经猜到了，LinkedHashMap也是通过散列表和链表组合在一起实现的。实际上，它不仅支持按照插入顺序遍历数据，还支持按照访问顺序来遍历数据。你可以看下面这段代码：</p><pre><code>// 10是初始大小，0.75是装载因子，true是表示按照访问时间排序\nHashMap&lt;Integer, Integer&gt; m = new LinkedHashMap&lt;&gt;(10, 0.75f, true);\nm.put(3, 11);\nm.put(1, 12);\nm.put(5, 23);\nm.put(2, 22);\n\nm.put(3, 26);\nm.get(5);\n\nfor (Map.Entry e : m.entrySet()) {\n  System.out.println(e.getKey());\n}\n</code></pre><p>这段代码打印的结果是1，2，3，5。我来具体分析一下，为什么这段代码会按照这样顺序来打印。</p><p>每次调用put()函数，往LinkedHashMap中添加数据的时候，都会将数据添加到链表的尾部，所以，在前四个操作完成之后，链表中的数据是下面这样：</p><p><img src=\"https://static001.geekbang.org/resource/image/17/98/17ac41d9dac454e454dcb289100bf198.jpg?wh=1142*313\" alt=\"\"></p><p>在第8行代码中，再次将键值为3的数据放入到LinkedHashMap的时候，会先查找这个键值是否已经有了，然后，再将已经存在的(3,11)删除，并且将新的(3,26)放到链表的尾部。所以，这个时候链表中的数据就是下面这样：</p><p><img src=\"https://static001.geekbang.org/resource/image/fe/8c/fe313ed327bcf234c73ba738d975b18c.jpg?wh=1142*311\" alt=\"\"></p><p>当第9行代码访问到key为5的数据的时候，我们将被访问到的数据移动到链表的尾部。所以，第9行代码之后，链表中的数据是下面这样：</p><p><img src=\"https://static001.geekbang.org/resource/image/b5/11/b5e07bb34d532d46d127f4fcc4b78f11.jpg?wh=1142*346\" alt=\"\"></p><p>所以，最后打印出来的数据是1，2，3，5。从上面的分析，你有没有发现，按照访问时间排序的LinkedHashMap本身就是一个支持LRU缓存淘汰策略的缓存系统？实际上，它们两个的实现原理也是一模一样的。我也就不再啰嗦了。</p><p>我现在来总结一下，实际上，<strong>LinkedHashMap是通过双向链表和散列表这两种数据结构组合实现的。LinkedHashMap中的“Linked”实际上是指的是双向链表，并非指用链表法解决散列冲突</strong>。</p><h2>解答开篇&amp;内容小结</h2><p>弄懂刚刚我讲的这三个例子，开篇的问题也就不言而喻了。我这里总结一下，为什么散列表和链表经常一块使用？</p><p>散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律存储的。也就说，它无法支持按照某种顺序快速地遍历数据。如果希望按照顺序遍历散列表中的数据，那我们需要将散列表中的数据拷贝到数组中，然后排序，再遍历。</p><p>因为散列表是动态数据结构，不停地有数据的插入、删除，所以每当我们希望按顺序遍历散列表中的数据的时候，都需要先排序，那效率势必会很低。为了解决这个问题，我们将散列表和链表（或者跳表）结合在一起使用。</p><h2>课后思考</h2><ol>\n<li>\n<p>今天讲的几个散列表和链表结合使用的例子里，我们用的都是双向链表。如果把双向链表改成单链表，还能否正常工作呢？为什么呢？</p>\n</li>\n<li>\n<p>假设猎聘网有10万名猎头，每个猎头都可以通过做任务（比如发布职位）来积累积分，然后通过积分来下载简历。假设你是猎聘网的一名工程师，如何在内存中存储这10万个猎头ID和积分信息，让它能够支持这样几个操作：</p>\n</li>\n</ol><ul>\n<li>\n<p>根据猎头的ID快速查找、删除、更新这个猎头的积分信息；</p>\n</li>\n<li>\n<p>查找积分在某个区间的猎头ID列表；</p>\n</li>\n<li>\n<p>查找按照积分从小到大排名在第x位到第y位之间的猎头ID列表。</p>\n</li>\n</ul><p>欢迎留言和我分享，我会第一时间给你反馈。</p>","neighbors":{"left":{"article_title":"19 | 散列表（中）：如何打造一个工业级水平的散列表？","id":64586},"right":{"article_title":"21 | 哈希算法（上）：如何防止数据库中的用户信息被脱库？","id":65312}},"comments":[{"had_liked":true,"id":36924,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1541390175,"is_pvip":false,"replies":[{"id":"13260","content":"👍 大牛","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541468303,"ip_address":"","comment_id":36924,"utype":1}],"discussion_count":25,"race_medal":0,"score":"4214904307551","product_id":100017301,"comment_content":"通过这 20 节课学习下来，个人感觉其实就两种数据结构，链表和数组。<br><br>数组占据随机访问的优势，却有需要连续内存的缺点。<br><br>链表具有可不连续存储的优势，但访问查找是线性的。<br><br>散列表和链表、跳表的混合使用，是为了结合数组和链表的优势，规避它们的不足。<br><br>我们可以得出数据结构和算法的重要性排行榜：连续空间 &gt; 时间 &gt; 碎片空间。<br><br>PS：跟专业的书籍相比，老师讲的真的是通俗易懂不废话，篇篇是干货。如果这个课程学不下去，学其它的会更加困难。暂时不懂的话反复阅读复习，外加查阅，一定可以的！","like_count":982,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428087,"discussion_content":"👍 大牛","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541468303,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":168936,"discussion_content":"我们可以得出数据结构和算法的重要性排行榜：连续空间 > 时间 > 碎片空间。　\n这句话没有必然的道理吧。\n连续空间注定偏移量访问友好，但随机插入、删除不友好。\n碎片空间注定头尾插入、删除友好，但偏移量访问不友好。\n翻来覆去，都是为了操作所用时间最小化和空间使用最小化之间做权衡、取舍，以达到特定场景最优之目的。","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1581599010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1013841,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","nickname":"Smallfly","note":"","ucode":"D388D5E0249A69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":169619,"discussion_content":"这里说的是内存空间，和具体得数据结构没关系。连续内存也能用来存链表，但不连续内存不能用来存数组。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1581636670,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":168936,"ip_address":""},"score":169619,"extra":""},{"author":{"id":2045997,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/38/2d/f3c6493e.jpg","nickname":"罗樱罂","note":"","ucode":"9072E79E625ED1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1013841,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","nickname":"Smallfly","note":"","ucode":"D388D5E0249A69","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290490,"discussion_content":"我之前也有相同的问题。多谢你的讲解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594504285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":169619,"ip_address":""},"score":290490,"extra":""}]},{"author":{"id":1008809,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/64/a9/27d63f2e.jpg","nickname":"佳楠","note":"","ucode":"A1698AE91992AA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50565,"discussion_content":"算法是计算机底层结构的上层映射。","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1573734641,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1500544,"avatar":"","nickname":"A2","note":"","ucode":"33B07C2B0E2D3F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8814,"discussion_content":"第一次看觉得懵懵懂懂，第二次再看就已经清晰很多了，老师也是功底深厚，不然怎么可能把复杂的数据结构和算法讲解的这么通俗易懂！","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1568074924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1294911,"avatar":"https://static001.geekbang.org/account/avatar/00/13/c2/3f/4f802365.jpg","nickname":"GX_Alanxx","note":"","ucode":"C5EB08AAE77E49","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":253128,"discussion_content":"总结的太到位了，去年买的课程，今年才沉下心来学习，内容真的是足，自己也跟着进步，写代码的时候思考的也多了","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1588217890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1897816,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/f5/58/5c9ba9aa.jpg","nickname":"卢克糖","note":"","ucode":"8F3B1D8C2A1423","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1294911,"avatar":"https://static001.geekbang.org/account/avatar/00/13/c2/3f/4f802365.jpg","nickname":"GX_Alanxx","note":"","ucode":"C5EB08AAE77E49","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373160,"discussion_content":"我是不知道什么时候买的，最近随意翻看，还真是好多干货","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620635988,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":253128,"ip_address":""},"score":373160,"extra":""}]},{"author":{"id":1426802,"avatar":"https://static001.geekbang.org/account/avatar/00/15/c5/72/1f4386f2.jpg","nickname":"赵健棋","note":"","ucode":"F71D062D8D76C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338169,"discussion_content":"我现在就是学不下去，但是我依旧坚持往下看。而且做了看第二遍的准备。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1609207082,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72483,"discussion_content":"我们可以得出数据结构和算法的重要性排行榜：连续空间 > 时间 > 碎片空间。　\n\n\n如何理解呢？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1575476638,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1481811,"avatar":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","nickname":"ub8","note":"","ucode":"0D937C3EAEB781","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78042,"discussion_content":"这段话写的真不错 手动点👍","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575970969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1311279,"avatar":"https://static001.geekbang.org/account/avatar/00/14/02/2f/b3cd68f0.jpg","nickname":"蜗壳酱","note":"","ucode":"CC0E579068CC62","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42802,"discussion_content":"再往下一层，是因为物理内存的连续性导致的。上一层的抽象特性取决于更低一层的性质。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1572784547,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1321770,"avatar":"https://static001.geekbang.org/account/avatar/00/14/2b/2a/63af9b35.jpg","nickname":"贾飞雨","note":"","ucode":"CBD8FD331B4173","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":414959,"discussion_content":"大佬,可以加你一个微信不","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636946202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379824,"discussion_content":"赞 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624176878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645443,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/6cwO6T7e7ib1LxrwjBCSVBz1AwxbbXicFghQD47uBdz6ZFWRCFy8TI3XbkFOibtmlmUxFoO3BcVHOAqsVoVBOZVZg/132","nickname":"陈家二少","note":"","ucode":"7CD06FE56B8EE4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352692,"discussion_content":"真要说底层存储结构，那就只有数组。链表都是在数组的基础上抽象而来的。其他所有的数据结构，也都是在此基础之上逐层抽象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614820737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2019799,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Rccaya3zw31Pxu1fRSiakKxjn7gBcXTyy7YE4BHVsGczceABMnKBRicrnxUlcptrOArQdj4hOP8AjRekrDvBx7KQ/132","nickname":"万政","note":"","ucode":"E59C2C660D6582","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645443,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/6cwO6T7e7ib1LxrwjBCSVBz1AwxbbXicFghQD47uBdz6ZFWRCFy8TI3XbkFOibtmlmUxFoO3BcVHOAqsVoVBOZVZg/132","nickname":"陈家二少","note":"","ucode":"7CD06FE56B8EE4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364760,"discussion_content":"离散式存储和连续存储，物理存储结构这差距很大了。你说的抽象，应该指的是链表是线性表（逻辑结构）的抽象。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1617594726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":352692,"ip_address":""},"score":364760,"extra":""}]},{"author":{"id":1120164,"avatar":"https://static001.geekbang.org/account/avatar/00/11/17/a4/fa0c13f1.jpg","nickname":"阿怪","note":"","ucode":"183D8204708429","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333673,"discussion_content":"大牛","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607590351,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1591223,"avatar":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","nickname":"JerryZhu","note":"","ucode":"76850CD45786C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301846,"discussion_content":"一定可以的！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598682113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1603858,"avatar":"https://static001.geekbang.org/account/avatar/00/18/79/12/ac2af040.jpg","nickname":"lxiongchang","note":"","ucode":"94F322CF8C996E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":277103,"discussion_content":"总结很赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591000572,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1129309,"avatar":"https://static001.geekbang.org/account/avatar/00/11/3b/5d/15c4817a.jpg","nickname":"xxxxL","note":"","ucode":"F84BB5ACD1241E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":98586,"discussion_content":"所以python里只有list和dict","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577175144,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1013841,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","nickname":"Smallfly","note":"","ucode":"D388D5E0249A69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1129309,"avatar":"https://static001.geekbang.org/account/avatar/00/11/3b/5d/15c4817a.jpg","nickname":"xxxxL","note":"","ucode":"F84BB5ACD1241E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":101794,"discussion_content":"dict 和链表没有关系哈。dict 其实是数组的抽象，又名关联数组。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577290463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":98586,"ip_address":""},"score":101794,"extra":""},{"author":{"id":1129309,"avatar":"https://static001.geekbang.org/account/avatar/00/11/3b/5d/15c4817a.jpg","nickname":"xxxxL","note":"","ucode":"F84BB5ACD1241E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1013841,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","nickname":"Smallfly","note":"","ucode":"D388D5E0249A69","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":102466,"discussion_content":"我想说的是list对应链表，dict对应散列表。您说dict是zip(list1，list2)的抽象？我理解dict还是更注重hash的思想","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577348628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":101794,"ip_address":""},"score":102466,"extra":""},{"author":{"id":2108347,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJNpx0kOlv2XJf9lytPvvEyu6dTQKQ750X5BonHpo4DiaEicz8q3mD6XBIwpEzoSu7JOghpric9e0trg/132","nickname":"Geek_5c55e9","note":"","ucode":"B3746DEB50C56C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1129309,"avatar":"https://static001.geekbang.org/account/avatar/00/11/3b/5d/15c4817a.jpg","nickname":"xxxxL","note":"","ucode":"F84BB5ACD1241E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301721,"discussion_content":"Python里面的list算是链表和数组的结合吧，因为它既支持按照下标随机索引，又能存储不同类型的数据","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598620165,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":102466,"ip_address":""},"score":301721,"extra":""}]},{"author":{"id":1516817,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/phbepZr2wVz17ickozgN54dHs8zfrk2exLzgYbnAGEcLia9TJVaAEedCTiboXGW55ueAldSFjGWMr6SDHIX6jEYAQ/132","nickname":"Geek_1b5f12","note":"","ucode":"7A6DAF1474F664","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":10899,"discussion_content":"是滴，一定可以的~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568336618,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1236765,"avatar":"https://static001.geekbang.org/account/avatar/00/12/df/1d/038853e5.jpg","nickname":"Yong","note":"","ucode":"154CD23B5ACC67","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7035,"discussion_content":"很棒。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567302646,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":true,"id":36938,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1541397838,"is_pvip":false,"replies":[{"id":"13258","content":"👍 其他同学可以看看这条留言","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541468252,"ip_address":"","comment_id":36938,"utype":1}],"discussion_count":44,"race_medal":0,"score":"1826902498638","product_id":100017301,"comment_content":"1.<br><br>在删除一个元素时，虽然能 O(1) 的找到目标结点，但是要删除该结点需要拿到前一个结点的指针，遍历到前一个结点复杂度会变为 O(N），所以用双链表实现比较合适。<br><br>（但其实硬要操作的话，单链表也是可以实现 O(1) 时间复杂度删除结点的）。<br><br>iOS 的同学可能知道，YYMemoryCache 就是结合散列表和双向链表来实现的。<br><br>2.<br><br>以积分排序构建一个跳表，再以猎头 ID 构建一个散列表。<br><br>1）ID 在散列表中所以可以 O(1) 查找到这个猎头；<br>2）积分以跳表存储，跳表支持区间查询；<br>3）这点根据目前学习的知识暂时无法实现，老师文中也提到了。<br>","like_count":425,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428091,"discussion_content":"👍 其他同学可以看看这条留言","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541468252,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72493,"discussion_content":"额，感觉大家把数据结构这门课里边的节点存储的数据类型固化了，不一定只是存int这种基本数据类型，可以存 封装了相关信息的bean ，\n可能 面向对象语言开发者（java、c# 等） 更容易理解这句话。。。\n\n另外，根据老师的意思：\n对于一些数据结构的设计实现问题\n不一定 非要强行附和到 现有、已学的数据结构，\n可以另辟蹊径，将现有的数据结构 用 并列组合 等方式 自行创建。\n\n比如 第二题 猎头这个题，很明显；\n第一问 ：\n根据id 查找 猎头积分，可以用散列表将查找的效率 做到极致的 O(1)，只不过散列表的数组实现中 存的是 猎头信息集合 bean就好了\n第二问：\n查找某个积分区间的猎头信息，散列表这种 根据id散列后 无序的存放形式 肯定就不行了，需要找 高效的有序的 数据结构来实现，比如 跳表\n第三问：\n查找 积分第x到第y位的，直接在第二问的基础上 顺序遍历就好了\n\n所以，可以设计实现中，可以同时并行组合使用 散列表+跳表，\n\n不一定非得是 散列表和跳表 强行关联耦合成一个数据结构","likes_number":24,"is_delete":false,"is_hidden":false,"ctime":1575477842,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1055819,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1c/4b/2e5df06f.jpg","nickname":"三件事","note":"","ucode":"BCC867C8961A24","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":86029,"discussion_content":"感谢，讲的很清楚！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576587638,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":72493,"ip_address":""},"score":86029,"extra":""},{"author":{"id":1236079,"avatar":"https://static001.geekbang.org/account/avatar/00/12/dc/6f/5d86dbe9.jpg","nickname":"短迪大魔王","note":"","ucode":"37E8117E0495B8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":148772,"discussion_content":"找到子区间拿出来，做排序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579706583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":72493,"ip_address":""},"score":148772,"extra":""},{"author":{"id":1798068,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/6f/b4/d465acef.jpg","nickname":"啊噗！","note":"","ucode":"C911E772E1E800","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1236079,"avatar":"https://static001.geekbang.org/account/avatar/00/12/dc/6f/5d86dbe9.jpg","nickname":"短迪大魔王","note":"","ucode":"37E8117E0495B8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":162278,"discussion_content":"跳表已经是排好序的了 为什么还有排序呢 现在要找的是排在第多少位的 所以目前来看 单用跳表 就是顺序遍历计数 找到位置","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1580980846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":148772,"ip_address":""},"score":162278,"extra":""}]},{"author":{"id":1318394,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1d/fa/b81c89c3.jpg","nickname":"isobelar","note":"","ucode":"58CE4061984B43","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":251977,"discussion_content":"以猎头 ID 构建一个散列表[{ID ：积分}]；再用积分先构建一个跳表，再用积分跳表和猎头 ID 数组构建一个复合散列表[{积分 : [ID数组]}]。\n1）在散列表中可以 O(1) 时间复杂度查找、删除、更新猎头ID 对应的积分数据；\n2）积分以跳表存储，跳表支持按区间查询；\n3）使用快速排序法在 O(N) 时间复杂度内分别求出跳表中排名在第 x 位和第 y 位的积分大小，再通过复合散列表得到排名在第 x 位的积分到第 y 位的积分之间所有积分对应所有猎头 ID 数组中的 ID。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1588131447,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":7,"child_discussions":[{"author":{"id":1353762,"avatar":"","nickname":"周蒙","note":"","ucode":"4D7CC539A5B6B0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1318394,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1d/fa/b81c89c3.jpg","nickname":"isobelar","note":"","ucode":"58CE4061984B43","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":253586,"discussion_content":"第三个问题既然已经可以通过快排求出跳表中排名在第x位和第y位的积分大小了，直接通过跳表查询这个积分范围的ID不就可以了","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1588245927,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":251977,"ip_address":""},"score":253586,"extra":""},{"author":{"id":1610573,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJKj3GbvevFibxwJibTqm16NaE8MXibwDUlnt5tt73KF9WS2uypha2m1Myxic6Q47Zaj2DZOwia3AgicO7Q/132","nickname":"饭","note":"","ucode":"B3F1702D4DE604","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1318394,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1d/fa/b81c89c3.jpg","nickname":"isobelar","note":"","ucode":"58CE4061984B43","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285547,"discussion_content":"第三个问题，跳表本身是支持范围2分查找的，参考二分查找那一节的思路可以解决","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592876456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":251977,"ip_address":""},"score":285547,"extra":""},{"author":{"id":2065943,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/86/17/0afc84df.jpg","nickname":"jackfan","note":"","ucode":"B61A63A2215A49","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1318394,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1d/fa/b81c89c3.jpg","nickname":"isobelar","note":"","ucode":"58CE4061984B43","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300811,"discussion_content":"积分相同就会出现故障","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598270105,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":251977,"ip_address":""},"score":300811,"extra":""}]},{"author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5219,"discussion_content":"第三个是可以的吧，积分都排名了，我遍历不就行了吗？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1566059155,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1438102,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f1/96/9571fa3d.jpg","nickname":"青青子衿","note":"","ucode":"4A388A3BA70C29","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":20953,"discussion_content":"我的理解：作者说的不是无法实现，而是无法高效实现，遍历是可以，但是时间复杂度就高了，个人理解，不一定正确，仅交流而已，欢迎斧正","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1569404854,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":5219,"ip_address":""},"score":20953,"extra":""}]},{"author":{"id":2028811,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f5/0b/73628618.jpg","nickname":"兔嘟嘟","note":"","ucode":"5A9042B4C7670C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382751,"discussion_content":"请问Redis 有序集合删除怎么做到O(1)，即使定位到了，从跳表中删去依旧要O(log n)吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1625712047,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1702997,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fc/55/e03bb6db.jpg","nickname":"i-neojos","note":"","ucode":"1808C25269948A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2028811,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f5/0b/73628618.jpg","nickname":"兔嘟嘟","note":"","ucode":"5A9042B4C7670C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385909,"discussion_content":"难道它没有真实删除，只是标记删除？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627347625,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":382751,"ip_address":""},"score":385909,"extra":""},{"author":{"id":1702997,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fc/55/e03bb6db.jpg","nickname":"i-neojos","note":"","ucode":"1808C25269948A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2028811,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f5/0b/73628618.jpg","nickname":"兔嘟嘟","note":"","ucode":"5A9042B4C7670C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385930,"discussion_content":"刚看了ZREM操作的时间复杂度，确实是O（log n）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627353293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":382751,"ip_address":""},"score":385930,"extra":""},{"author":{"id":2028811,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f5/0b/73628618.jpg","nickname":"兔嘟嘟","note":"","ucode":"5A9042B4C7670C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1702997,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fc/55/e03bb6db.jpg","nickname":"i-neojos","note":"","ucode":"1808C25269948A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386042,"discussion_content":"是的，文中顺带提过去，其实也没说是O(1)的，是我误解了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627386821,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":385930,"ip_address":""},"score":386042,"extra":""}]},{"author":{"id":1812840,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a9/68/ec442a70.jpg","nickname":"王jojo","note":"","ucode":"1ABE7FA2614F86","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":230694,"discussion_content":"第一题里，说的删除方法是说使用快慢指针实现O（1）么","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586763548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1926508,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/65/6c/be97a3ae.jpg","nickname":"Geek_bb2310","note":"","ucode":"022885B257DEB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1812840,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a9/68/ec442a70.jpg","nickname":"王jojo","note":"","ucode":"1ABE7FA2614F86","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":270753,"discussion_content":"no","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590048091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":230694,"ip_address":""},"score":270753,"extra":""}]},{"author":{"id":1236079,"avatar":"https://static001.geekbang.org/account/avatar/00/12/dc/6f/5d86dbe9.jpg","nickname":"短迪大魔王","note":"","ucode":"37E8117E0495B8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":148757,"discussion_content":"先感谢你把这个问题说清楚了，类似构建了一个dataframe，支持了两个维度的快速查找","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1579706409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1485820,"avatar":"https://static001.geekbang.org/account/avatar/00/16/ab/fc/38ccd186.jpg","nickname":"123456","note":"","ucode":"9F7C4F3E4416BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":129526,"discussion_content":"积分范围查找不是没法实现，是没有较好的方式，可以从头到尾查找,O(n) 时间","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578711064,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1031734,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/be/36/abb7bfe3.jpg","nickname":"xenoblade3","note":"","ucode":"620DD0491EEFF3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":21881,"discussion_content":"请问单链表如何实现O(1)时间复杂度下的删除操作？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1569550304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":6,"child_discussions":[{"author":{"id":1433568,"avatar":"https://static001.geekbang.org/account/avatar/00/15/df/e0/ce671992.jpg","nickname":"北顾-岛城","note":"","ucode":"54ECB3E5E4073A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1031734,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/be/36/abb7bfe3.jpg","nickname":"xenoblade3","note":"","ucode":"620DD0491EEFF3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":39620,"discussion_content":"用两个指针呗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1571967961,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":21881,"ip_address":""},"score":39620,"extra":""},{"author":{"id":1115041,"avatar":"https://static001.geekbang.org/account/avatar/00/11/03/a1/e6a0f60b.jpg","nickname":"Sid","note":"","ucode":"0461B574B2736B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1031734,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/be/36/abb7bfe3.jpg","nickname":"xenoblade3","note":"","ucode":"620DD0491EEFF3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":142629,"discussion_content":"其实还是把前继节点存下来了，比如用map维护一个(key,preNode)这样子的结构，否则要找到前继节点还是遍历，复杂度就是O(N)","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1579480959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":21881,"ip_address":""},"score":142629,"extra":""},{"author":{"id":1058638,"avatar":"https://static001.geekbang.org/account/avatar/00/10/27/4e/080cb3a0.jpg","nickname":"CodingWith","note":"","ucode":"F9E463F5823332","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1031734,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/be/36/abb7bfe3.jpg","nickname":"xenoblade3","note":"","ucode":"620DD0491EEFF3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":149824,"discussion_content":"假如删除的节点为node， node.val = node.next.val  node.next = node.next.next","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1579781198,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":21881,"ip_address":""},"score":149824,"extra":""}]},{"author":{"id":2162521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/MaX06SRk19zM2lAaymYylpXD6LMtIPFlDyxZKgRhmZCjhNE4nIdDGBmh08razhebVCgAv54xialYBBIIwmleBew/132","nickname":"Geek_6d1382","note":"","ucode":"B61E65CFEB684F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":406367,"discussion_content":"用跳表的，是不是插入一次，就要对跳表排序，还要更新跳表索引？这样插入是不是有点慢了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634742249,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2682648,"avatar":"https://static001.geekbang.org/account/avatar/00/28/ef/18/65518519.jpg","nickname":"momo","note":"","ucode":"BAA3380E7E6584","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388210,"discussion_content":"第一题只是删除会受到影响么？感觉如果只要需要知道链表末尾（单链表）也需要遍历链表才能知道啊？所以插入和读取也受到影响了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628655708,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1196401,"avatar":"https://static001.geekbang.org/account/avatar/00/12/41/71/b8c99cf5.jpg","nickname":"Mr.Li","note":"","ucode":"6BBFE118103125","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287207,"discussion_content":"确实，不知道怎么实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593400315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1610573,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJKj3GbvevFibxwJibTqm16NaE8MXibwDUlnt5tt73KF9WS2uypha2m1Myxic6Q47Zaj2DZOwia3AgicO7Q/132","nickname":"饭","note":"","ucode":"B3F1702D4DE604","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285548,"discussion_content":"第三个问题，跳表本身是支持范围2分查找的，参考二分查找那一节的思路可以解决","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592876505,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1433178,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJMzj0MHiaXBdDFp4E16qhu6PZlu6xkJRWgaoJXOeqMDDLqM4vcvUbnVLiactTypZkYibOg7okwm2TAQ/132","nickname":"Geek_921929","note":"","ucode":"26BF6978F040BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":218427,"discussion_content":"通过积分查猎头信息，跳表中的积分信息如何对应到猎头ID？是在跳表结点存储额外类似于bean的data字段吗？因为同样分数的可能有多个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585658362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645446,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTItyLuAmkkvltVX0q8k00urtZkianJ2Vibc8yNgZB6G8IgTwaV5IYS0ftEt8rs7kG2MlXEsW7jOcwkQ/132","nickname":"Geek_57ee8f","note":"","ucode":"91BD49939874F5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1433178,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJMzj0MHiaXBdDFp4E16qhu6PZlu6xkJRWgaoJXOeqMDDLqM4vcvUbnVLiactTypZkYibOg7okwm2TAQ/132","nickname":"Geek_921929","note":"","ucode":"26BF6978F040BF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329443,"discussion_content":"不是的，根据积分查询复合的那个跳表就能查到猎头的集合","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606385690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":218427,"ip_address":""},"score":329443,"extra":""}]},{"author":{"id":1232156,"avatar":"https://static001.geekbang.org/account/avatar/00/12/cd/1c/98b32e26.jpg","nickname":"雷大鸡","note":"","ucode":"54B3525C199749","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7212,"discussion_content":"思考题 2.2 中，哈希值是无法倒推 key 的，我们在跳表中找到目标区间的话，并不知道对应的猎头ID吧，是不是应该在跳表的每个节点维护额外的ID指针？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567419585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1031734,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/be/36/abb7bfe3.jpg","nickname":"xenoblade3","note":"","ucode":"620DD0491EEFF3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1232156,"avatar":"https://static001.geekbang.org/account/avatar/00/12/cd/1c/98b32e26.jpg","nickname":"雷大鸡","note":"","ucode":"54B3525C199749","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":21874,"discussion_content":"应该说不叫维护额外的ID指针，因为链表节点的数据域就是猎头信息了。跳表满足使用积分作为索引信息就可以了，跳表节点的内容可以是指向猎头成员对象的指针之类的，这样是可以直接读取成员对象信息的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1569549856,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7212,"ip_address":""},"score":21874,"extra":""}]},{"author":{"id":1042685,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e8/fd/abb7bfe3.jpg","nickname":"Langzi233","note":"","ucode":"5A21AC08FC089B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4256,"discussion_content":"有点复杂啊，以ID为key值建立hashtable并采用拉链法解决冲突，然后还要用链表来实现以积分为索性的有序的跳表，不知道这么说可以么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565255579,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1322427,"avatar":"https://static001.geekbang.org/account/avatar/00/14/2d/bb/3da9ebd2.jpg","nickname":"xuqnqn","note":"","ucode":"5A6D8472CD3AE4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3056,"discussion_content":"是跳表按照积分来建立索引么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564137246,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1205627,"avatar":"https://static001.geekbang.org/account/avatar/00/12/65/7b/66b9befd.jpg","nickname":"Hwan","note":"","ucode":"A728C6790511BD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1322427,"avatar":"https://static001.geekbang.org/account/avatar/00/14/2d/bb/3da9ebd2.jpg","nickname":"xuqnqn","note":"","ucode":"5A6D8472CD3AE4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":13113,"discussion_content":"跳表本质是个排序了的单链表，只是为了增加查询速度，所以增加了多个层次索引，这个例子里面是按照积分排序然后建立多级索引的","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1568641466,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3056,"ip_address":""},"score":13113,"extra":""}]}]},{"had_liked":false,"id":39888,"user_name":"姜威","can_delete":false,"product_type":"c1","uid":1244051,"ip_address":"","ucode":"C58EB9A5AD634D","user_header":"https://static001.geekbang.org/account/avatar/00/12/fb/93/f19a5364.jpg","comment_is_top":false,"comment_ctime":1542375755,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"409564268875","product_id":100017301,"comment_content":"带着问题去学习：<br>1.为什么散列表和链表经常放在一起使用？<br>2.散列表和链表如何组合起来使用？<br>一、为什么散列表和链表经常放在一起使用？<br>1.散列表的优点：支持高效的数据插入、删除和查找操作<br>2.散列表的缺点：不支持快速顺序遍历散列表中的数据<br>3.如何按照顺序快速遍历散列表的数据？只能将数据转移到数组，然后排序，最后再遍历数据。<br>4.我们知道散列表是动态的数据结构，需要频繁的插入和删除数据，那么每次顺序遍历之前都需要先排序，这势必会造成效率非常低下。<br>5.如何解决上面的问题呢？就是将散列表和链表（或跳表）结合起来使用。<br>二、散列表和链表如何组合起来使用？<br>1.LRU（Least Recently Used）缓存淘汰算法<br>1.1.LRU缓存淘汰算法主要操作有哪些？主要包含3个操作：<br>①往缓存中添加一个数据；<br>②从缓存中删除一个数据；<br>③在缓存中查找一个数据；<br>④总结：上面3个都涉及到查找。<br>1.2.如何用链表实现LRU缓存淘汰算法？<br>①需要维护一个按照访问时间从大到小的有序排列的链表结构。<br>②缓冲空间有限，当空间不足需要淘汰一个数据时直接删除链表头部的节点。<br>③当要缓存某个数据时，先在链表中查找这个数据。若未找到，则直接将数据放到链表的尾部。若找到，就把它移动到链表尾部。<br>④前面说了，LRU缓存的3个主要操作都涉及到查找，若单纯由链表实现，查找的时间复杂度很高为O(n)。若将链表和散列表结合使用，查找的时间复杂度会降低到O(1)。<br>1.3.如何使用散列表和链表实现LRU缓存淘汰算法？<br>①使用双向链表存储数据，链表中每个节点存储数据（data）、前驱指针（prev）、后继指针（next）和hnext指针（解决散列冲突的链表指针）。<br>②散列表通过链表法解决散列冲突，所以每个节点都会在两条链中。一条链是双向链表，另一条链是散列表中的拉链。前驱和后继指针是为了将节点串在双向链表中，hnext指针是为了将节点串在散列表的拉链中。<br>③LRU缓存淘汰算法的3个主要操作如何做到时间复杂度为O(1)呢？<br>首先，我们明确一点就是链表本身插入和删除一个节点的时间复杂度为O(1)，因为只需更改几个指针指向即可。<br>接着，来分析查找操作的时间复杂度。当要查找一个数据时，通过散列表可实现在O(1)时间复杂度找到该数据，再加上前面说的插入或删除的时间复杂度是O(1)，所以我们总操作的时间复杂度就是O(1)。<br>2.Redis有序集合<br>2.1.什么是有序集合？<br>①在有序集合中，每个成员对象有2个重要的属性，即key（键值）和score（分值）。<br>②不仅会通过score来查找数据，还会通过key来查找数据。<br>2.2.有序集合的操作有哪些？<br>举个例子，比如用户积分排行榜有这样一个功能：可以通过用户ID来查找积分信息，也可以通过积分区间来查找用户ID。这里用户ID就是key，积分就是score。所以，有序集合的操作如下：<br>①添加一个对象；<br>②根据键值删除一个对象；<br>③根据键值查找一个成员对象；<br>④根据分值区间查找数据，比如查找积分在[100.356]之间的成员对象；<br>⑤按照分值从小到大排序成员变量。<br>这时可以按照分值将成员对象组织成跳表结构，按照键值构建一个散列表。那么上面的所有操作都非常高效。<br>3.Java LinkedHashMap<br>和LRU缓存淘汰策略实现一模一样。支持按照插入顺序遍历数据，也支持按照访问顺序遍历数据。<br>三、课后思考<br>1.上面所讲的几个散列表和链表组合的例子里，我们都是使用双向链表。如果把双向链表改成单链表，还能否正常工作？为什么呢？<br>2.假设猎聘网有10万名猎头，每个猎头可以通过做任务（比如发布职位）来积累积分，然后通过积分来下载简历。假设你是猎聘网的一名工程师，如何在内存中存储这10万个猎头的ID和积分信息，让它能够支持这样几个操作：<br>1）根据猎头ID查收查找、删除、更新这个猎头的积分信息；<br>2）查找积分在某个区间的猎头ID列表；<br>3）查找按照积分从小到大排名在第x位到第y位之间的猎头ID列表。","like_count":95,"discussions":[{"author":{"id":1049017,"avatar":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","nickname":"学习学个屁","note":"","ucode":"DF2D61E6FB2FCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302082,"discussion_content":"课代表","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1598781647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1317847,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1b/d7/868d26ce.jpg","nickname":"songhyunmin","note":"","ucode":"D5A98668CD8532","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358390,"discussion_content":"看完你的总结，相当于又复习了一遍。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1615975545,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1243570,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f9/b2/2ed800b4.jpg","nickname":"社会你强哥","note":"","ucode":"325B9005588D9B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158782,"discussion_content":"大兄弟，写得挺好的，不说废话，给力！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1580625134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1207038,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6a/fe/7566542f.jpg","nickname":"布衣","note":"","ucode":"BFAD9049508330","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1049,"discussion_content":"兄弟 后面咋不总结了啊  需要呢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1562294984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1358804,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bb/d4/5e970f07.jpg","nickname":"千夜","note":"","ucode":"EF7EEF2B988A36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":409665,"discussion_content":"第一个错了吧，链表的优缺点 应该是？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635486959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379826,"discussion_content":"你的总结，比我的好多了。我的要么太废话，要么太精简。赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624177362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2318781,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/fKD3fHiaJajYHkBNnLBYb40ggEqA5lykW4jrqHvXtiap2rPmq8Cj7pj4nTU7BdqHTIzIRKRt5mylnucgwibOZ2Z9g/132","nickname":"cyan-mountain","note":"","ucode":"2797C0D846130C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337580,"discussion_content":"兄弟，贵在坚持，牛逼格拉斯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608982735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156483,"user_name":"Uncle.席","can_delete":false,"product_type":"c1","uid":1635218,"ip_address":"","ucode":"2A23428FBBAFF0","user_header":"https://static001.geekbang.org/account/avatar/00/18/f3/92/96fe653f.jpg","comment_is_top":false,"comment_ctime":1574901528,"is_pvip":false,"discussion_count":14,"race_medal":0,"score":"323697448728","product_id":100017301,"comment_content":"10万个猎头，走眼看成了猪头，也许是猪肉太贵了吧！","like_count":75,"discussions":[{"author":{"id":1317847,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1b/d7/868d26ce.jpg","nickname":"songhyunmin","note":"","ucode":"D5A98668CD8532","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358391,"discussion_content":"LRU不会看成URL了吧？","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1615975688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1218404,"avatar":"https://static001.geekbang.org/account/avatar/00/12/97/64/c4d9ce92.jpg","nickname":"漩涡鸣人","note":"","ucode":"FFF6596A9F90C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568268,"discussion_content":"上海封城，猪肉太贵了","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1651085033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1897788,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/f5/3c/0a0247d9.jpg","nickname":"ShawnZ","note":"","ucode":"1A37744CCE0DD6","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557358,"discussion_content":"现在猪肉可便宜了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1647771978,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2121852,"avatar":"https://static001.geekbang.org/account/avatar/00/20/60/7c/67fccaa2.jpg","nickname":"＆","note":"","ucode":"4D75C942C2E45C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318862,"discussion_content":"哈哈哈,本来挺严肃的看着评论,被你这评论笑喷了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1603869248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1731082,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/6a/0a/45562844.jpg","nickname":"小玉家的猫","note":"","ucode":"ACA36922F22B69","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379527,"discussion_content":"笑喷了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623939786,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2557346,"avatar":"https://static001.geekbang.org/account/avatar/00/27/05/a2/24d5e88e.jpg","nickname":"king🐳","note":"","ucode":"88DA7981062AB5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1731082,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/6a/0a/45562844.jpg","nickname":"小玉家的猫","note":"","ucode":"ACA36922F22B69","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":379965,"discussion_content":"加一","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624264439,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":379527,"ip_address":""},"score":379965,"extra":""},{"author":{"id":2557346,"avatar":"https://static001.geekbang.org/account/avatar/00/27/05/a2/24d5e88e.jpg","nickname":"king🐳","note":"","ucode":"88DA7981062AB5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1731082,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/6a/0a/45562844.jpg","nickname":"小玉家的猫","note":"","ucode":"ACA36922F22B69","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":379966,"discussion_content":"看着评论突然看到这个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624264451,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":379527,"ip_address":""},"score":379966,"extra":""}]},{"author":{"id":2202824,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/S639aUGm4e85bAzp6ThOKrbXGcNjhLqSBUgjxb7lI8KBveDXMLVSPhJkeUUqlYN3pNL5zaQEb2YW7icMFo3D9uA/132","nickname":"曾彬","note":"","ucode":"E5E546CC6FB320","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":356451,"discussion_content":"给爷整笑了！哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615600927,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1265707,"avatar":"https://static001.geekbang.org/account/avatar/00/13/50/2b/2344cdaa.jpg","nickname":"第一装甲集群司令克莱斯特","note":"","ucode":"4E8FBB23AD860B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299614,"discussion_content":"就你皮!嘎嘎！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597751371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1085207,"avatar":"https://static001.geekbang.org/account/avatar/00/10/8f/17/aa66313a.jpg","nickname":"Shaw","note":"","ucode":"CE382F300EFF19","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294308,"discussion_content":"猪头工程师是干嘛的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595852514,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1242736,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f6/70/fb54fe20.jpg","nickname":"神话","note":"","ucode":"CFC55CEBB69AB2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278888,"discussion_content":"兄弟建议你去买两斤猪头肉吃一吃","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591251834,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1109041,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ec/31/644fc4cd.jpg","nickname":"有课学","note":"","ucode":"9A8D5E9B9FDA62","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275664,"discussion_content":"兄弟，我一口水喷到屏幕上，你还我吃饭的家伙什","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590750921,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1380312,"avatar":"https://static001.geekbang.org/account/avatar/00/15/0f/d8/9286b272.jpg","nickname":"leetcode","note":"","ucode":"3B8C3668A0DE74","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269981,"discussion_content":"兄die  我差点一口开水喷到屏幕上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589970545,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188793,"avatar":"https://static001.geekbang.org/account/avatar/00/12/23/b9/8d182f13.jpg","nickname":"起风了","note":"","ucode":"9A8A2E51E198EE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260239,"discussion_content":"兄弟，我差点一口水喷到屏幕上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588856663,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":86271,"user_name":"HunterYuan","can_delete":false,"product_type":"c1","uid":1015256,"ip_address":"","ucode":"F8900C33D29AA7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/d8/d7c77764.jpg","comment_is_top":false,"comment_ctime":1555336099,"is_pvip":false,"replies":[{"id":"30975","content":"对的 👍","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1555372244,"ip_address":"","comment_id":86271,"utype":1}],"discussion_count":16,"race_medal":0,"score":"276433243043","product_id":100017301,"comment_content":"看好些人询问LRU中设计的到pre，next和hnext的具体含义，将自己的理解说下，pre和next组成双向链表，这个链表是按照缓存的时间由大到小，组成的一个缓存队列；对于hnext作用是，在最新时间插入缓存数据时，通过哈希函数得出的冲突，用其连接。<br>总结：在双向链表中，时间是从大到小；在hnext组成的拉链中，时间从左到右依次变小。<br>核心：数据结构的设计，一定是建立应用场景之上，根据最新时间加入缓存。<br>这是自己的见解，若是有错误，希望争哥不吝赐教，thanks","like_count":64,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446950,"discussion_content":"对的 👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555372244,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1180979,"avatar":"https://static001.geekbang.org/account/avatar/00/12/05/33/c33c0e8a.jpg","nickname":"exception","note":"","ucode":"F35ACB5B921353","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293944,"discussion_content":"在hnext组成的拉链中，时间从左到右依次变小。这句话是不对的，会误导人。 \n在hnext组成的拉链中时间顺序是无法保证的，时间顺序只通过双向链表进行维护。","likes_number":14,"is_delete":false,"is_hidden":false,"ctime":1595735704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005947,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/7b/ebe8451e.jpg","nickname":"德先生","note":"","ucode":"659061785DCF4C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":533840,"discussion_content":"YYMemoryCache里面哪个起到hnext的作用？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637988809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2813766,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erX65FTLyn3JMbqLKdFkkv9okdx7qmVIibl1zKB7pnCIbtElSgibULma5cTsSMyS5KGMBy5MRdXtN8g/132","nickname":"小竹子","note":"","ucode":"D20F56114426EA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531336,"discussion_content":"也就是说，维持最新的结点在链表的尾部？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637288622,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1048525,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ff/cd/9c44f2d5.jpg","nickname":"Mong狗","note":"","ucode":"9DF0D65D75984E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367251,"discussion_content":"在hnext组成的拉链中，时间从左到右依次变小, 应该是依次变大吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618305879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1557544,"avatar":"https://static001.geekbang.org/account/avatar/00/17/c4/28/ba6bde1f.jpg","nickname":"林假假","note":"","ucode":"C1FD64BD939412","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1048525,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ff/cd/9c44f2d5.jpg","nickname":"Mong狗","note":"","ucode":"9DF0D65D75984E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392141,"discussion_content":"我也觉得是依次变大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630854366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":367251,"ip_address":""},"score":392141,"extra":""}]},{"author":{"id":1526355,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4a/53/063f9d17.jpg","nickname":"moonfox","note":"","ucode":"902BFF40EFA9FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292105,"discussion_content":"hnext组成的拉链，从左到右不是是乱序的么，所以才需要双向链表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595082581,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1248326,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0c/46/dfe32cf4.jpg","nickname":"多选参数","note":"","ucode":"B2294D80AB075F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271729,"discussion_content":"为什么是从大到小？这个从大到小是指头到尾的顺序？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590168019,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":148147,"discussion_content":"感谢，被你说明白了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579692946,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1234584,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d6/98/e2d8f2a9.jpg","nickname":"zzq","note":"","ucode":"03FE20B812D15D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41344,"discussion_content":"感谢，你这么一说我明白了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572402895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1110887,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f3/67/68425e7c.jpg","nickname":"赵勇","note":"","ucode":"D492ECCEFB90A8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":36285,"discussion_content":"图中第一行左边第一个是双向链表的头节点，水平第二个是尾节点，尾节点应该是大于头节点的吧，这样从左到右不是由大到小啊，而是由小到大啊，不知道我描述清楚了没，是我理解错了吗，希望大神能指点一下迷津","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571359119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1661456,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epYAmnyHBCVY7YicTF3IXa39mvVTuyum9yicPyFG5amXuo6R2QOTicX0iaXLicH8CTktC7XHruv81ichgkg/132","nickname":"Geek_b25f99","note":"","ucode":"6F7BEAB2C31528","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1110887,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f3/67/68425e7c.jpg","nickname":"赵勇","note":"","ucode":"D492ECCEFB90A8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51176,"discussion_content":"时间大小指的是现在大于之前，理解成时间戳","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573820346,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":36285,"ip_address":""},"score":51176,"extra":""},{"author":{"id":1127750,"avatar":"https://static001.geekbang.org/account/avatar/00/11/35/46/1bb24db1.jpg","nickname":"skylar","note":"","ucode":"56C2BF63C470A4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1110887,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f3/67/68425e7c.jpg","nickname":"赵勇","note":"","ucode":"D492ECCEFB90A8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":76829,"discussion_content":"通常尾比头大叫做从小到大， 但这里相当于从链表尾部入队，头部出队，出队的肯定是时间最早最小了，所以按入队出队来说是访问时间从大到小排序。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575857266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":36285,"ip_address":""},"score":76829,"extra":""},{"author":{"id":1248326,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0c/46/dfe32cf4.jpg","nickname":"多选参数","note":"","ucode":"B2294D80AB075F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1127750,"avatar":"https://static001.geekbang.org/account/avatar/00/11/35/46/1bb24db1.jpg","nickname":"skylar","note":"","ucode":"56C2BF63C470A4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271730,"discussion_content":"从入队出队的顺序来看是从大到小，但是这跟尾比头大叫做从小到大怎么联系上？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590168155,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":76829,"ip_address":""},"score":271730,"extra":""}]},{"author":{"id":1439529,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f7/29/60e01017.jpg","nickname":"wai","note":"","ucode":"29CE3BE148FB79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282,"discussion_content":"感谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561426080,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36889,"user_name":"Keep-Moving","can_delete":false,"product_type":"c1","uid":1182631,"ip_address":"","ucode":"76F33C06E07A27","user_header":"https://static001.geekbang.org/account/avatar/00/12/0b/a7/6ef32187.jpg","comment_is_top":false,"comment_ctime":1541381220,"is_pvip":false,"replies":[{"id":"13073","content":"两种方式都可以的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541381502,"ip_address":"","comment_id":36889,"utype":1}],"discussion_count":8,"race_medal":0,"score":"181930007652","product_id":100017301,"comment_content":"LRU查找数据，查找到之后，不是应该把数据放到链表的头部吗？为什么这里说是尾部？","like_count":42,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428076,"discussion_content":"两种方式都可以的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541381502,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2249227,"avatar":"https://static001.geekbang.org/account/avatar/00/22/52/0b/50bf0f05.jpg","nickname":"橙子橙","note":"","ucode":"CD51367A14D955","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":322498,"discussion_content":"双向链表 头尾都可以","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1604755127,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1104217,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d9/59/54692189.jpg","nickname":"柳晓峰","note":"","ucode":"F148C6C0957CF5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":208272,"discussion_content":"双向链表那么只有插入到头节点的复杂度是O(1)，如果要尾部并且复杂度为O(1)，要么是双向循环链表，要么维护尾指针。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584541010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1732780,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","nickname":"面向百度编程","note":"","ucode":"8FE04A019D71D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":205763,"discussion_content":"思想是一样的，玩弄思想就对了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584340150,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1739621,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/8b/65/0f1f9a10.jpg","nickname":"小Y","note":"","ucode":"24A43BB71805F8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380965,"discussion_content":"我也想问这个来着，还好你问了，我能看到。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624844616,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305979,"discussion_content":"查找头部这个玩法吧。。比如 抗高并发不够友好，可以用 concurrentHashMap然后重写字方法，  方头部 更容易提出数据，尤其是 跨多个数组或者segment 踢出的时候","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600141157,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1303327,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e3/1f/bfea2679.jpg","nickname":"宋超","note":"","ucode":"ECA6126F076AB0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294140,"discussion_content":"放在头部或者尾部主要看时间的排序顺序吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595808234,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1988075,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJX4ZU53F8hBHicctluqK6Ef3U0ib40bq1vFyAvqV0wu3GaPuWbj967OdMT7k0gl3OMxsfopvbk9veQ/132","nickname":"Geek_dd8b2b","note":"","ucode":"CBEF7C39075A96","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289389,"discussion_content":"其他地方看到也是放到头部。维护一个烧饼节点感觉就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594087210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36900,"user_name":"莫问流年","can_delete":false,"product_type":"c1","uid":1249663,"ip_address":"","ucode":"23140E031AED4B","user_header":"https://static001.geekbang.org/account/avatar/00/13/11/7f/80d56c1c.jpg","comment_is_top":false,"comment_ctime":1541382918,"is_pvip":false,"replies":[{"id":"13269","content":"是的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541468552,"ip_address":"","comment_id":36900,"utype":1}],"discussion_count":1,"race_medal":0,"score":"147570270982","product_id":100017301,"comment_content":"怎么判断缓存已满，是要维护一个计数变量吗","like_count":35,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428081,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541468552,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37406,"user_name":"P@tricK","can_delete":false,"product_type":"c1","uid":1233716,"ip_address":"","ucode":"293B2B3261A793","user_header":"https://static001.geekbang.org/account/avatar/00/12/d3/34/5dee4f70.jpg","comment_is_top":false,"comment_ctime":1541576613,"is_pvip":false,"replies":[{"id":"13452","content":"需要维护一个尾指针的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541641669,"ip_address":"","comment_id":37406,"utype":1}],"discussion_count":10,"race_medal":0,"score":"117505693605","product_id":100017301,"comment_content":"老师我想问下，散列表和双向链表结构中的散列值，是用链表中的data哈希的吗？因为这样才能用O(1)查找… <br>那问题来了，那我要在链表尾部插入数据时，根据什么方法用O(1)定位到尾部呢？","like_count":27,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428328,"discussion_content":"需要维护一个尾指针的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541641669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1815185,"avatar":"","nickname":"松鼠鱼","note":"","ucode":"C0E87CCF71DB44","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":258649,"discussion_content":"其实这一点应该在课程里说明白的，不然移动操作肯定是O(n)","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1588699727,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1275407,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/0f/c7c8021d.jpg","nickname":"豆豆","note":"","ucode":"97788B134C3212","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1815185,"avatar":"","nickname":"松鼠鱼","note":"","ucode":"C0E87CCF71DB44","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":284572,"discussion_content":"是啊，我很多时间都是被这种问题烧脑了，以为自己比别人笨，想哭","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1592559888,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":258649,"ip_address":""},"score":284572,"extra":""}]},{"author":{"id":1136890,"avatar":"https://static001.geekbang.org/account/avatar/00/11/58/fa/6f221fbc.jpg","nickname":"一念逍遥、","note":"","ucode":"827A4447D70798","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5108,"discussion_content":"还要维护一个头指针吧？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1565949485,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1014550,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/16/ca250e8c.jpg","nickname":"王木公","note":"","ucode":"F049AEBFA0338D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1136890,"avatar":"https://static001.geekbang.org/account/avatar/00/11/58/fa/6f221fbc.jpg","nickname":"一念逍遥、","note":"","ucode":"827A4447D70798","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":48381,"discussion_content":"头指针应该是必须的，否则怎么开始链表的遍历呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573477138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":5108,"ip_address":""},"score":48381,"extra":""},{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1136890,"avatar":"https://static001.geekbang.org/account/avatar/00/11/58/fa/6f221fbc.jpg","nickname":"一念逍遥、","note":"","ucode":"827A4447D70798","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":195621,"discussion_content":"我感觉也应该维护一个双向链表的头指针","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583291899,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":5108,"ip_address":""},"score":195621,"extra":""}]},{"author":{"id":1295609,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJRFRX8kNzNet7FibNvtavbVpAwK09AhIhrib9k762qWtH6mre8ickP7hM5mgZC4ytr8NnmIfmAhxMSQ/132","nickname":"老大不小","note":"","ucode":"35BCDD3CB13467","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581675,"discussion_content":"学习最大的困难，就是作者以为我们都明白，所以忽略了一些东西，结果学的稀里糊涂，怀疑自己。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658914173,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2056488,"avatar":"","nickname":"alask.lu","note":"","ucode":"872F0D9193513B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293041,"discussion_content":"说白了，用散列表只是为了方便定位元素，其他功能和双向链表是一样的实现，都需要头指针和尾指针，也都要维护size","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595420363,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":195620,"discussion_content":"我感觉也应该维护一个双向链表的头指针","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583291897,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1275407,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/0f/c7c8021d.jpg","nickname":"豆豆","note":"","ucode":"97788B134C3212","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284573,"discussion_content":"这个我觉得也是，不然，怎么删头指针？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592559943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":195620,"ip_address":""},"score":284573,"extra":""}]}]},{"had_liked":false,"id":138875,"user_name":"邸志惠","can_delete":false,"product_type":"c1","uid":1017136,"ip_address":"","ucode":"5CE6D6B19CBA7B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/85/30/a59e76dd.jpg","comment_is_top":false,"comment_ctime":1570497087,"is_pvip":false,"replies":[{"id":"53591","content":"多谢赞美啊😁","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1570579855,"ip_address":"","comment_id":138875,"utype":1}],"discussion_count":2,"race_medal":0,"score":"87469843007","product_id":100017301,"comment_content":"我不是科班出身，三年前准备学数据结构，却从没坚持下来，一度怀疑自己的智商有问题，但是看了老师的课程，篇篇都不由自主点赞啊，真是通俗易懂，鞭辟入里啊！感恩老师！","like_count":20,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469681,"discussion_content":"多谢赞美啊😁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570579855,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1073947,"avatar":"https://static001.geekbang.org/account/avatar/00/10/63/1b/83ac7733.jpg","nickname":"忧天小鸡","note":"","ucode":"A1412BDC108FD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373856,"discussion_content":"国内一般都是老师有问题，自己理解的不够深刻，讲解就不会到位","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620895319,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64841,"user_name":"千锤百炼锅","can_delete":false,"product_type":"c1","uid":1283933,"ip_address":"","ucode":"62C62B573C75A7","user_header":"https://static001.geekbang.org/account/avatar/00/13/97/5d/1dce0b78.jpg","comment_is_top":false,"comment_ctime":1548922807,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"83153301431","product_id":100017301,"comment_content":"看到很多人都在问，为什么老师说的，一条链是双向链表的链，一条链是拉链没看明白。<br>其实就是散列表为了解决散列冲突，所以得到同一个hash值的时候，将同一个hash值的用一个链表来存放了，而在图上面就是双链表中的hnext所串连起来的链表。个人是这么理解的。","like_count":19,"discussions":[{"author":{"id":1165817,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/f9/39492855.jpg","nickname":"阿阳","note":"","ucode":"20A35FB86B1C5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394298,"discussion_content":"这么一说，真是豁然开朗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631834207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1291966,"avatar":"https://static001.geekbang.org/account/avatar/00/13/b6/be/b45611ef.jpg","nickname":"切～","note":"","ucode":"E571D1A9565D82","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213107,"discussion_content":"我觉得散列表中存储的应该是拉链的链头吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585052153,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1526355,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4a/53/063f9d17.jpg","nickname":"moonfox","note":"","ucode":"902BFF40EFA9FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1291966,"avatar":"https://static001.geekbang.org/account/avatar/00/13/b6/be/b45611ef.jpg","nickname":"切～","note":"","ucode":"E571D1A9565D82","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292110,"discussion_content":"是节点对象的指针，不是节点对象本身","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595083442,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":213107,"ip_address":""},"score":292110,"extra":""}]},{"author":{"id":1314724,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0f/a4/0b49469f.jpg","nickname":"木子00","note":"","ucode":"8F78CA722EB29B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":187856,"discussion_content":"我理解也是这样的.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582773356,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1522386,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/VarHGCe9OqeIexfD3cFPeMeicm1WwyDicSwfIUzhOPeQ9AcfFIzVec7TPNGREmjxGDLSH6oC8nz1k9AkvzClfOvQ/132","nickname":"Lengend","note":"","ucode":"0BD86B750E1CF3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79748,"discussion_content":"那散列表中存储的值就是hnext吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576109504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37159,"user_name":"微秒","can_delete":false,"product_type":"c1","uid":1249195,"ip_address":"","ucode":"65A2E8B565B191","user_header":"https://static001.geekbang.org/account/avatar/00/13/0f/ab/9748f40b.jpg","comment_is_top":false,"comment_ctime":1541469726,"is_pvip":false,"replies":[{"id":"13463","content":"是的 理论上散列表查找数据的时间复杂度是O（1）","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541642760,"ip_address":"","comment_id":37159,"utype":1}],"discussion_count":4,"race_medal":0,"score":"83145848350","product_id":100017301,"comment_content":"通过散列表遍历后不用在遍历双向链表了，那怎么以o(1)的时间查找定位链表中的节点？？？除非，散列表的尺寸很大，使得散列表的节点中只有少量数据的链表？？？？","like_count":19,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428208,"discussion_content":"是的 理论上散列表查找数据的时间复杂度是O（1）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541642760,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2449060,"avatar":"https://static001.geekbang.org/account/avatar/00/25/5e/a4/d48b8298.jpg","nickname":"Geek_sz","note":"","ucode":"72E86D7D6554CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":590582,"discussion_content":"通过散列表找到的结点怎么对应到双向链表中？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665903687,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":428208,"ip_address":"广东"},"score":590582,"extra":""}]},{"author":{"id":1268797,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5c/3d/e8325811.jpg","nickname":"对白","note":"","ucode":"3183E5ADBC794B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295139,"discussion_content":"链表法解决冲突的散列表查找/删除的时间复杂度是o(k)，k是链表长度，散列表遍历自己用于解决冲突的链表，而这个链表的长度是有限的，所以散列表查找数据的时间复杂度近似于O(1)，双向链表是不需要遍历的，结点已经通过散列表找到了，如果要遍历双向链表，则查找的时间复杂度就是o(n)，n是双向链表的长度。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596101379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":195624,"discussion_content":"感觉老师应该把这些前提条件应该交代清楚，否则对新手来说根本想不明白的。个人建议哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583291957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37153,"user_name":"Zeng Shine","can_delete":false,"product_type":"c1","uid":1245334,"ip_address":"","ucode":"15D2618C92D662","user_header":"https://static001.geekbang.org/account/avatar/00/13/00/96/6df95326.jpg","comment_is_top":false,"comment_ctime":1541468763,"is_pvip":false,"replies":[{"id":"13319","content":"图能不能看懂呢 你结合图看下","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541490565,"ip_address":"","comment_id":37153,"utype":1}],"discussion_count":17,"race_medal":0,"score":"65965978203","product_id":100017301,"comment_content":"“一个节点会存在两条拉链中，一条是双向链表，另一条是散列表中的拉链”，这句话描述的结构，怎么都想不明白。。","like_count":15,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428202,"discussion_content":"图能不能看懂呢 你结合图看下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541490565,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5218,"discussion_content":"散列表不是数组加链表吗？那个 hhnext 就是这个链表的；然后所有的元素都穿成一个双向链表；","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1566058796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":148162,"discussion_content":"散列表不是数组加链表，散列表的意思是根据某个key，调用散列函数获得一个散列值，把散列值当作下标，然后将value存到对应得下标中。数组加链表只是散列表用来处理散列冲突的一种方式，你不能说用开放寻址法解决散列冲突的散列表不是散列表。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1579693263,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":5218,"ip_address":""},"score":148162,"extra":""},{"author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":148167,"discussion_content":"这个是争哥在18节中对散列表的定义“散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。”","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1579693379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":5218,"ip_address":""},"score":148167,"extra":""},{"author":{"id":1268797,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5c/3d/e8325811.jpg","nickname":"对白","note":"","ucode":"3183E5ADBC794B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295141,"discussion_content":"散列表是散列函数加数组，可以用链表解决冲突问题","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596101503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":148167,"ip_address":""},"score":295141,"extra":""}]},{"author":{"id":1174794,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ed/0a/18201290.jpg","nickname":"Juniper","note":"","ucode":"1BC24554034BD3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389576,"discussion_content":"我的观点是，散列表里的横向拉链只会存两个值，节点的指针（所以该节点的pre，next,data，还是通过指针地址到内存里读取）和hext（维持横向的链表关系），不知道这个理解对不对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629345472,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1592279,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","nickname":"William Ning","note":"","ucode":"4DB8D05E69E5F3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388129,"discussion_content":"个人观点：仔细看，应该还是能看明白的。\n记住一点，图中画出来的双向链表只有一条，就能看明白了。\n另外，解决哈希冲突的链表上的节点，除了删除操作，其他时候都是不会移动该节点在哈希表上的原来链表上的位置的，有的只是在双向链表的指针变化～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628604576,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2328620,"avatar":"","nickname":"不知jdk","note":"","ucode":"F167FA99431C8E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337840,"discussion_content":"hnext是横向的，next是立体的，哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609085174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1978264,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eptJDcK30IlNf6GuRuq8eA9WiaUpRVMEicodr5eoONBCuoonKxjPibllRdZQqNmH4vjmbx05lP004UIQ/132","nickname":"Geek_7b8125","note":"","ucode":"D9C64ADE616072","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2328620,"avatar":"","nickname":"不知jdk","note":"","ucode":"F167FA99431C8E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384657,"discussion_content":"一开始我也没想明白，哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626691548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":337840,"ip_address":""},"score":384657,"extra":""}]},{"author":{"id":1647304,"avatar":"https://static001.geekbang.org/account/avatar/00/19/22/c8/f2892022.jpg","nickname":"科科","note":"","ucode":"7DAE6FE781172E","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24409,"discussion_content":"之前我们做的lru的缓存淘汰的时候，因为每次都需要遍历一遍链表，但是由于链表在遍历的时候真的不怎么友好，所以希望使用哈希表结合在一起。hhnext就是映射到同一个hash值的链表节点链接在一起了，方便查找。就好像给所有的链表节点简历了索引，我个人是这样理解的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570110884,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1522386,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/VarHGCe9OqeIexfD3cFPeMeicm1WwyDicSwfIUzhOPeQ9AcfFIzVec7TPNGREmjxGDLSH6oC8nz1k9AkvzClfOvQ/132","nickname":"Lengend","note":"","ucode":"0BD86B750E1CF3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1647304,"avatar":"https://static001.geekbang.org/account/avatar/00/19/22/c8/f2892022.jpg","nickname":"科科","note":"","ucode":"7DAE6FE781172E","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":79752,"discussion_content":"那是不是可以理解为：散列表中存储的数据值就是hnext","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576109623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":24409,"ip_address":""},"score":79752,"extra":""},{"author":{"id":1798068,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/6f/b4/d465acef.jpg","nickname":"啊噗！","note":"","ucode":"C911E772E1E800","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1522386,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/VarHGCe9OqeIexfD3cFPeMeicm1WwyDicSwfIUzhOPeQ9AcfFIzVec7TPNGREmjxGDLSH6oC8nz1k9AkvzClfOvQ/132","nickname":"Lengend","note":"","ucode":"0BD86B750E1CF3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":162093,"discussion_content":"不是啊 hnext就是存一个地址而已 指向和当前节点相同散列值的节点","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1580958884,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":79752,"ip_address":""},"score":162093,"extra":""},{"author":{"id":1172090,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e2/7a/38a27e47.jpg","nickname":"蓦然回首","note":"","ucode":"B17658DCFE6402","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1647304,"avatar":"https://static001.geekbang.org/account/avatar/00/19/22/c8/f2892022.jpg","nickname":"科科","note":"","ucode":"7DAE6FE781172E","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":334545,"discussion_content":"你这样说我就明白了，这个hhnext是干嘛的，文章当中的拉链，不知为何物，哈哈😃！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607876375,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":24409,"ip_address":""},"score":334545,"extra":""}]},{"author":{"id":1121677,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/8d/9717e593.jpg","nickname":"一枝梅","note":"","ucode":"7DCE43B638EA6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4258,"discussion_content":"我理解的意思是，仅按其中一种方式就可以遍历到每一个节点，无论是仅按照散列表方式，还是按照双向链表方式。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1565256355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36920,"user_name":"牧民牛仔","can_delete":false,"product_type":"c1","uid":1247561,"ip_address":"","ucode":"1CC29B7129B207","user_header":"https://static001.geekbang.org/account/avatar/00/13/09/49/8bc5e315.jpg","comment_is_top":false,"comment_ctime":1541388887,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"65965898327","product_id":100017301,"comment_content":"1.双联表改成单链表，依然可以工作。可以用一个变量存储遍历到的节点的前驱指针。<br>2.可以把猎聘网的猎头的信息存储在 散列表和链表（跳表）组合使用的容器中，其中按照猎头id建立散列表，按照猎头的积分建立一个跳表。这样，无论是按照id查用户，还是按照积分进行排序和区间查找都会很高效。<br>","like_count":15,"discussions":[{"author":{"id":1645430,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiauonyMORA2s43W7mogGDH4WYjW0gBJtYmUa9icTB6aMPGqibicEKlLoQmLKLWEctwHzthbTZkKR20w/132","nickname":"Spring4J","note":"","ucode":"06F056085A2564","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338865,"discussion_content":"改成单链表是没法做到O(1)插入和删除的；比如说你通过哈希表找到了插入或者删除的位置，如果是双向链表的话，直接插入跟删除就行了，因为当前节点本身就保存了前驱节点的指针；但如果是单链表，你还得遍历一遍，才晓得前驱节点指针","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1609405672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1014665,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/89/34f2cbcc.jpg","nickname":"杨宇","note":"","ucode":"EB74DF6E269F03","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557765,"discussion_content":"他的意思是：额外声明一个变量，在遍历的过程中随着当前节点改变而改变，但总是指向当前节点的前驱。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647958399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132865,"user_name":"ITACHI","can_delete":false,"product_type":"c1","uid":1260500,"ip_address":"","ucode":"4EE419128ED9E8","user_header":"https://static001.geekbang.org/account/avatar/00/13/3b/d4/e4bfb25f.jpg","comment_is_top":false,"comment_ctime":1568254972,"is_pvip":false,"replies":[{"id":"51240","content":"你理解的完全正确哈。你可以看下这篇文章：<br>https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;PdvdZoa-SGk_Ojkv2pC2tQ","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1568591850,"ip_address":"","comment_id":132865,"utype":1}],"discussion_count":6,"race_medal":0,"score":"61697797116","product_id":100017301,"comment_content":"第一个图我是这样理解的，不知道对不对：<br>通俗地将，浅色的线（对应pre、next指针）维系的是链表中用于存储缓存数据的节点位置关系。<br>而黑色的线（对应hnext指针）维系的是添加节点时发生冲突后，在某个桶的节点位置关系。<br>比如第一个桶的最后一个节点，应该是在添加时，发现有冲突，且应属于第一个桶，所以用hnext指针和第一个桶的最后一个节点连起来了。<br>而它又是链表的最后一个节点，所以同时也是和第五个桶的最后一个节点通过pre、next连在一起的。<br>也就是说实际上只有一个双向链表，灰色线（pre、next指针）维系节点在链表中的位置，新指针hnext维系的是发生冲突的节点在某个桶中的位置。<br>（这个理解比较笨，而且可能不准确，不过感觉这么想能说通这个图，请问大佬们，这样对么。。。）","like_count":14,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467151,"discussion_content":"你理解的完全正确哈。你可以看下这篇文章：\nhttps://mp.weixin.qq.com/s/PdvdZoa-SGk_Ojkv2pC2tQ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568591850,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1172090,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e2/7a/38a27e47.jpg","nickname":"蓦然回首","note":"","ucode":"B17658DCFE6402","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334554,"discussion_content":"你的理解让我大致明白了，这和前面看到的散列表和单链表的结合是不同的，这里面要保证两种关系:一种是散列冲突时同一个桶的关系用hnext来维持，同时，整个缓存队列本身就是一个双向链表，它也有一个位置关系需要维持，这就通过每个节点的pre和next来维持，一开始没看明白，总是以为是散列冲突，本身就是通过双向链表来解决了，应该是多个双向链表才对，其实，这里的散列表对应的数据结构本身有个前提，是基于缓存队列也就是双向链表的基础上来构建的散列表，所以，首先是一个双向链表，然后添加节点的时候，基于散列表做哈希映射来添加数据，可能存在哈希冲突，又要保证同一散列值得在一个桶里面，所以还需要一个hnext来维持每个桶里面的哈希冲突的节点的关系。理清这两种关系，就能明白为啥只有一个双向链表，而还有一个hnext。\n这完全是两个维度的东西，不能混在一起，一个是针对缓存队列的双向链表，一个是用于解决哈希冲突的，对于散列表，这里链式寻址解决哈希冲突只用到了单链表，没用双向链表！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1607878564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295920,"discussion_content":"老师的这种讲法让很多人把LRU链表（linkedlist+hashmap）和linkedhashmap搞混了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596381837,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1651618,"avatar":"https://static001.geekbang.org/account/avatar/00/19/33/a2/585be249.jpg","nickname":"草原上的骆驼🐫","note":"","ucode":"F0B12CB1FEED84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275363,"discussion_content":"一直对老师文中的hnext指针理解不了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590708736,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2221397,"avatar":"https://static001.geekbang.org/account/avatar/00/21/e5/55/ae64df9d.jpg","nickname":"cloudy","note":"","ucode":"8D3AA12C499F1B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1651618,"avatar":"https://static001.geekbang.org/account/avatar/00/19/33/a2/585be249.jpg","nickname":"草原上的骆驼🐫","note":"","ucode":"F0B12CB1FEED84","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325791,"discussion_content":"散列表上这个下标对应的&#34;桶&#34;空间所对应的单链表的头节点地址值，后续的每个节点指针就是hNext","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605434001,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":275363,"ip_address":""},"score":325791,"extra":""},{"author":{"id":1048525,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ff/cd/9c44f2d5.jpg","nickname":"Mong狗","note":"","ucode":"9DF0D65D75984E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1651618,"avatar":"https://static001.geekbang.org/account/avatar/00/19/33/a2/585be249.jpg","nickname":"草原上的骆驼🐫","note":"","ucode":"F0B12CB1FEED84","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367256,"discussion_content":"其实就是hashmap中冲突的key后面链表节点之间的关系","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618306040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":275363,"ip_address":""},"score":367256,"extra":""}]}]},{"had_liked":false,"id":86521,"user_name":"chenlong321","can_delete":false,"product_type":"c1","uid":1488389,"ip_address":"","ucode":"6A9F25AEA898F9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI6e8qr96vMm8IGPz0cticBibUsibeRcQcMC8oOWLUGVaPDic2EfLo46FLmFVK6sJiaYH5gRiaXJGgzQe1Q/132","comment_is_top":false,"comment_ctime":1555390364,"is_pvip":false,"replies":[{"id":"31224","content":"双向链表，跟散列表没有任何关系。这里的双向链表不是散列表中的链表。<br><br>不管是双向链表还是散列表，你都可以把它当做一种索引结构。里面存储的都是指向真实缓存对象的内存地址。<br><br>改变双向链表的结点结构，并不会影响散列表。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1555469233,"ip_address":"","comment_id":86521,"utype":1}],"discussion_count":10,"race_medal":0,"score":"57389965212","product_id":100017301,"comment_content":"lru算法，缓存中，如果能查找到节点a，那么需要先删除a，再将a移动到双向链表的尾端，那这不就改变了节点a的hash bucket，下次怎么还能通过hash快速查找到节点a，请老师指教，谢谢","like_count":13,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447052,"discussion_content":"双向链表，跟散列表没有任何关系。这里的双向链表不是散列表中的链表。\n\n不管是双向链表还是散列表，你都可以把它当做一种索引结构。里面存储的都是指向真实缓存对象的内存地址。\n\n改变双向链表的结点结构，并不会影响散列表。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555469233,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1397631,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKVUskibDnhMt5MCIJ8227HWkeg2wEEyewps8GuWhWaY5fy7Ya56bu2ktMlxdla3K29Wqia9efCkWaQ/132","nickname":"衬衫的价格是19美元","note":"","ucode":"655F925451F772","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310655,"discussion_content":"从双向链表中剔除该节点，该节点依然存在于内存中，只是不会再有双向链表中的pre和next点指向该节点，该节点的pre和next也不再指向双向链表的任何节点，但是hnext还是不变，因此依然存在于拉链链表。链表是个逻辑概念，并不是物理概念","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1601974407,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":148261,"discussion_content":"本身节点的位置不变呀，直接将之前双向链表的尾节点next指向a节点，然后a->next = null，a节点不就成了双向链表的最后一个节点吗","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1579696230,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1218810,"avatar":"https://static001.geekbang.org/account/avatar/00/12/98/fa/6b80ed33.jpg","nickname":"Zoker","note":"","ucode":"CD7F9642C61DD4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382039,"discussion_content":"图把思维固化了，你可以想象一下，移动访问数据到尾部的时候，变动的是prev next，而指向它的hnext还是指向它，并不会变，你把图想象成多维的就好理解了 😄","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1625381834,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1953062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/cd/26/bebf18de.jpg","nickname":"每天学习半小时","note":"","ucode":"FF5042709ABF5E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285279,"discussion_content":"我和提问的同学有相同的疑惑 我没听明白老师的解释 难道不是对双向链表中节点的值进行hash吗 又不是对结点值所在的内存地址进行hash 有懂得同学解释一下吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592795023,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1299347,"avatar":"https://static001.geekbang.org/account/avatar/00/13/d3/93/c3fb8566.jpg","nickname":"ProcessIsTheKey","note":"","ucode":"BE02EFD75F7D98","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1953062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/cd/26/bebf18de.jpg","nickname":"每天学习半小时","note":"","ucode":"FF5042709ABF5E","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":553266,"discussion_content":"开始装入散列表时是对双向链表中节点的值进行hash，但是这个hash计算在装入散列表的时候已经hash过了（也就是说这个节点在散列表中的位置是确定了，散列表不发生变化的时候），因为移动到双向链表尾部节点的时候，值没有变化，hash当然也没有变化，产生变化的是这个节点的pre指针和nex指针，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645797545,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":285279,"ip_address":""},"score":553266,"extra":""}]},{"author":{"id":1275407,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/0f/c7c8021d.jpg","nickname":"豆豆","note":"","ucode":"97788B134C3212","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284574,"discussion_content":"删除时，hash表中存储的对象地址是不是也要改变成插入链尾结点的地址？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592560229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645430,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiauonyMORA2s43W7mogGDH4WYjW0gBJtYmUa9icTB6aMPGqibicEKlLoQmLKLWEctwHzthbTZkKR20w/132","nickname":"Spring4J","note":"","ucode":"06F056085A2564","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53959,"discussion_content":"改变的是该节点在双向链表的位置，而不是该节点在散列表的位置","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574241538,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1275407,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/0f/c7c8021d.jpg","nickname":"豆豆","note":"","ucode":"97788B134C3212","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645430,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiauonyMORA2s43W7mogGDH4WYjW0gBJtYmUa9icTB6aMPGqibicEKlLoQmLKLWEctwHzthbTZkKR20w/132","nickname":"Spring4J","note":"","ucode":"06F056085A2564","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284575,"discussion_content":"人家想问的是散列表中该位置存储的节点地址也需要变更吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592560325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53959,"ip_address":""},"score":284575,"extra":""}]},{"author":{"id":1455958,"avatar":"https://static001.geekbang.org/account/avatar/00/16/37/56/11068390.jpg","nickname":"倡印","note":"","ucode":"4F53AA5D017D89","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7090,"discussion_content":"你可以理解成一次创建一个hash表和一个链表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567349597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147901,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1572918050,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"48817558306","product_id":100017301,"comment_content":"看了好几遍LRU那段，大概理解了，总体的数据结构是采用双向链表存储。为了快速查找，利用散列表结构又将不同的节点落到不同的槽中，利用一个hnext串联。散列表的作用是快速定位，双向链表可以快速插入和删除，两者数据结构上相互独立，作用上相互配合。","like_count":12},{"had_liked":false,"id":65616,"user_name":"前端西瓜哥","can_delete":false,"product_type":"c1","uid":1248576,"ip_address":"","ucode":"150130C34CD1C1","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/40/f70e5653.jpg","comment_is_top":false,"comment_ctime":1549509808,"is_pvip":false,"replies":[{"id":"24282","content":"你说的没错。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1550541792,"ip_address":"","comment_id":65616,"utype":1}],"discussion_count":1,"race_medal":0,"score":"40204215472","product_id":100017301,"comment_content":"老师，你那个 LRU 的删除和添加操作，貌似没有说要更新拉链的链表呢？我觉得删除操作时，还要保存匹配节点在拉链中的上一个节点，通过hnext移除匹配节点；添加操作时，也要记录匹配拉链的最后一个节点k，且只有在发现数据不存在时，并将其添加到双链表末尾时，再让这个k指向这个新建的元素，不知道这样对不对？","like_count":9,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438523,"discussion_content":"你说的没错。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550541792,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":38711,"user_name":"hot","can_delete":false,"product_type":"c1","uid":1237803,"ip_address":"","ucode":"567921754BE860","user_header":"https://static001.geekbang.org/account/avatar/00/12/e3/2b/c6de8f27.jpg","comment_is_top":false,"comment_ctime":1542112809,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"40196818473","product_id":100017301,"comment_content":"一个链是刚刚我们提到的双向链表，另一个链是散列表中的拉链<br>就是结合你的图也看不懂啊 ，老铁","like_count":9,"discussions":[{"author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":148257,"discussion_content":"其实只有一个双向链表，那个hnext指针只是用来维护散列冲突的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1579696110,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1215892,"avatar":"https://static001.geekbang.org/account/avatar/00/12/8d/94/150dfe78.jpg","nickname":"GGL","note":"","ucode":"AED10B8248D1E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":277191,"discussion_content":"基于链表实现的散列表结构中，数组中的每一个元素都是一条单链表结构，结点与结点之间通过hnext指针来连接；在双向链表结构中，一个结点存在一个前驱指针和后继指针，也就是这里的pre指针和next指针；将两种数据结构结合在一起就形成了LRU缓存数据结构；","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591015548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1270490,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIVvbClKAic99IbDyQVXnkPDhjmWH0TVibybvrw7E9Ogrf8yo2icDffZUeLibqvIHgmmQqDQPibSu4tDuQ/132","nickname":"Geek_664e71","note":"","ucode":"13F330E68C58FF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2877,"discussion_content":"这里确实还没理解，还没想明白","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564015984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1127890,"avatar":"https://static001.geekbang.org/account/avatar/00/11/35/d2/39689b0b.jpg","nickname":"王大锤DW3","note":"","ucode":"EBDD13BDBEB70A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1270490,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIVvbClKAic99IbDyQVXnkPDhjmWH0TVibybvrw7E9Ogrf8yo2icDffZUeLibqvIHgmmQqDQPibSu4tDuQ/132","nickname":"Geek_664e71","note":"","ucode":"13F330E68C58FF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3397,"discussion_content":"双向链表是方便能够按顺序快速遍历后面的元素，hnext指针的作用是，解决hash冲突，当hash冲突的时候，在每一个桶后面使用链表添加元素，好好研究下图，应该可以看懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564457119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2877,"ip_address":""},"score":3397,"extra":""},{"author":{"id":1098987,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/eb/2285a345.jpg","nickname":"花晨少年","note":"","ucode":"6AA3537A6BA10E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1127890,"avatar":"https://static001.geekbang.org/account/avatar/00/11/35/d2/39689b0b.jpg","nickname":"王大锤DW3","note":"","ucode":"EBDD13BDBEB70A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":140221,"discussion_content":"冲突是hash表内部解决的，这里左边的不应该是hash表，而应该是数组太对。如果做左边是hash表，不需要这个hnext结构","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579352057,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3397,"ip_address":""},"score":140221,"extra":""}]}]},{"had_liked":false,"id":36918,"user_name":"猫头鹰爱拿铁","can_delete":false,"product_type":"c1","uid":1105958,"ip_address":"","ucode":"24266B58968428","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/26/4942a09e.jpg","comment_is_top":false,"comment_ctime":1541387695,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"40196093359","product_id":100017301,"comment_content":"1.可以通过单链表和散列表实现，但是删除和添加的时间复杂度就变成了O(n)，因为需要遍历一次链表将前驱节点找到，再进行删除。<br>2.猎头问题：每个猎头对象由node构成（pre，next，hnext，data）将id作为键值建立类似hashmap的结构来存放猎头的对象，同时再将每个节点使用双向链表按照积分大小（快排排序）链接起来。根据id查找、删除、添加时间复杂度为O(1)，查找排名的时间复杂度为O(n),如果想提高查找排名的时间复杂度，可以再和跳表结合一块，根据积分建立索引，查找排名的时间复杂度将提升为O(logn)","like_count":9,"discussions":[{"author":{"id":1268797,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5c/3d/e8325811.jpg","nickname":"对白","note":"","ucode":"3183E5ADBC794B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295142,"discussion_content":"删除的时间复杂度是O(n)，而插入的时间复杂度依然是O(1)。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596101862,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1076768,"avatar":"https://static001.geekbang.org/account/avatar/00/10/6e/20/a0740b7d.jpg","nickname":"刘智敏","note":"","ucode":"83D3DE25192DD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1268797,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5c/3d/e8325811.jpg","nickname":"对白","note":"","ucode":"3183E5ADBC794B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574711,"discussion_content":"如果修改删除逻辑，记录前驱结点变量，删除的时间也可以是o(1)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654273713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":295142,"ip_address":""},"score":574711,"extra":""}]}]},{"had_liked":false,"id":83694,"user_name":"Lucus","can_delete":false,"product_type":"c1","uid":1198800,"ip_address":"","ucode":"CE8EB70CB9D9F1","user_header":"https://static001.geekbang.org/account/avatar/00/12/4a/d0/d319c44a.jpg","comment_is_top":false,"comment_ctime":1554704467,"is_pvip":false,"replies":[{"id":"31022","content":"链表头、尾指针是已经记录好的了。移动到尾部，就是先删除，再添加的过程。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1555381713,"ip_address":"","comment_id":83694,"utype":1}],"discussion_count":5,"race_medal":0,"score":"35914442835","product_id":100017301,"comment_content":"老师我有一点不明白，双向链表中节点要移动到尾部还有找到链表头节点应该都需要遍历链表吧，平均时间复杂度应该是O（n）啊？","like_count":8,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446127,"discussion_content":"链表头、尾指针是已经记录好的了。移动到尾部，就是先删除，再添加的过程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555381713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":195627,"discussion_content":"这应该是使时间复杂度达到O（1）的一个前提条件","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583292055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":148195,"discussion_content":"获取节点的时候可以通过散列表来获取，时间复杂度是O(1)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579694178,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1240727,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ee/97/aec1d845.jpg","nickname":"","note":"","ucode":"FB0CE2F0055452","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":239788,"discussion_content":"他的意思是散列表获取到后，遍历双向链表然后进行删除插入操作的时间复杂度O(n)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587308253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":148195,"ip_address":""},"score":239788,"extra":""},{"author":{"id":2032840,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/04/c8/3c7af100.jpg","nickname":"Javatar","note":"","ucode":"E216645CDF632C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1240727,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ee/97/aec1d845.jpg","nickname":"","note":"","ucode":"FB0CE2F0055452","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288616,"discussion_content":"遍历双向链表进行插入删除也是O（1），因为理想情况下没有hash碰撞，即便有hash碰撞，也不是O（n）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593825667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":239788,"ip_address":""},"score":288616,"extra":""}]}]},{"had_liked":false,"id":65115,"user_name":"james","can_delete":false,"product_type":"c1","uid":1049208,"ip_address":"","ucode":"5701899403917C","user_header":"https://static001.geekbang.org/account/avatar/00/10/02/78/23c56bce.jpg","comment_is_top":false,"comment_ctime":1549067278,"is_pvip":false,"replies":[{"id":"24299","content":"没错！👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1550542848,"ip_address":"","comment_id":65115,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27318871054","product_id":100017301,"comment_content":"我认为老师提供LRU的思路, 不是让你直接使用HashMap以及LinkedList开发, 而是重新开发一个类, 比如按照HashMap为模板改一改,  jdk8为例, 人家不是已经有hash冲突的拉链了吗? 就是Node已经有了这几个属性: hash, key, value, next, 其中next就是老师说的hnext, 你就往Node里面再加俩属性: linkedPrev和LinkedNext不就ok了? 然后修改下put, get方法, 其中包含对链表的维护, 以及LRU方面的操作, 不知道我理解的对不对??","like_count":6,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438325,"discussion_content":"没错！👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550542848,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132680,"user_name":"申凯","can_delete":false,"product_type":"c1","uid":1233568,"ip_address":"","ucode":"9D4F48545D3942","user_header":"https://static001.geekbang.org/account/avatar/00/12/d2/a0/bb67dd75.jpg","comment_is_top":false,"comment_ctime":1568190704,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23043027184","product_id":100017301,"comment_content":"每篇至少要看四遍<br>","like_count":5},{"had_liked":false,"id":52373,"user_name":"MrVito","can_delete":false,"product_type":"c1","uid":1252169,"ip_address":"","ucode":"716FF6F8871706","user_header":"https://static001.geekbang.org/account/avatar/00/13/1b/49/ddefc656.jpg","comment_is_top":false,"comment_ctime":1545371546,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23020208026","product_id":100017301,"comment_content":"老师，hnext是解决散列冲突的链表，而双向链表是维护插入元素顺序的表。两条链是不一样的，一个hnext是维护散列冲突的，一个双向链表是维护插入元素的顺序的。那么查找，删除，添加就要维护这两个链表。老师这样理解是不是很对。","like_count":5},{"had_liked":false,"id":88043,"user_name":"小邓","can_delete":false,"product_type":"c1","uid":1474505,"ip_address":"","ucode":"1E903D5622D39F","user_header":"https://static001.geekbang.org/account/avatar/00/16/7f/c9/40c609ee.jpg","comment_is_top":false,"comment_ctime":1555823210,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18735692394","product_id":100017301,"comment_content":"我来理一理第一张图的意思：针对缓存数据，用两种数据结构来组织，一种是左边的散列表，另一种是右边的双向链表。双向链表负责的是先前讲过的LRU算法，不过从原来的单链表升级成了双向链表，并且有记录头节点，尾节点等常用变量。而散列表负责查找。<br>当我们去执行LRU的查找操作时，过程是先从散列表里查找数据，知道了这个数据在双向链表的位置，然后将这个节点放到双向链表前面。","like_count":4},{"had_liked":false,"id":47617,"user_name":"吴小智","can_delete":false,"product_type":"c1","uid":1310798,"ip_address":"","ucode":"C7C9F58B5C9F7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","comment_is_top":false,"comment_ctime":1544165964,"is_pvip":false,"replies":[{"id":"17195","content":"就是把散列表中的链表换成跳表 其他不变","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1544408076,"ip_address":"","comment_id":47617,"utype":1}],"discussion_count":3,"race_medal":0,"score":"18724035148","product_id":100017301,"comment_content":"想请问一下，如何使用跳表来解决哈希冲突呢？没想通","like_count":4,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431834,"discussion_content":"就是把散列表中的链表换成跳表 其他不变","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544408076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1324863,"avatar":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","nickname":"KK","note":"","ucode":"FFC31A3FE3A285","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":258549,"discussion_content":"跳表就是链表的一种。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588691935,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1397631,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKVUskibDnhMt5MCIJ8227HWkeg2wEEyewps8GuWhWaY5fy7Ya56bu2ktMlxdla3K29Wqia9efCkWaQ/132","nickname":"衬衫的价格是19美元","note":"","ucode":"655F925451F772","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310656,"discussion_content":"就是“槽”里面放的不是一个链表，而是一个改进的链表：跳表，当然也可以是红黑树。至于如何解决哈希冲突，本来槽里面只能放一个元素，现在槽里面放的是一个元素集合，这个集合可以有各种形式，链表、跳表、红黑树都可以，当然了， 这个集合需要有较好的增删改查性能，这就是所谓的解决哈希冲突了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601974854,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":38089,"user_name":"Tensor","can_delete":false,"product_type":"c1","uid":1249504,"ip_address":"","ucode":"DA4395DF66DF72","user_header":"https://static001.geekbang.org/account/avatar/00/13/10/e0/a1b10acb.jpg","comment_is_top":false,"comment_ctime":1541930329,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"18721799513","product_id":100017301,"comment_content":"老师，您好，你讲的那个LRU算法中的，散列表加上双向链表的图没有看懂，能不能再讲详细点儿啊（不好意思，基础太差了）？还有不理解的是为什么查找哈希表中双向链表某一节点的时间复杂度是o(1)？？？首先在哈希表中遍历为1，但确定了哈希表的位置后，还要遍及节点，这个跟链表的规模有关吧？？？","like_count":4,"discussions":[{"author":{"id":1689788,"avatar":"https://static001.geekbang.org/account/avatar/00/19/c8/bc/51761b48.jpg","nickname":"Berry","note":"","ucode":"0AE7C0819FEA67","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":32346,"discussion_content":"确实和链表规模有关，但是复杂度也只是常数级别。你可以思考特殊情况，每个哈希表对应链表只有一个元素和某个对应链表有所有元素（n），前者遍历复杂度为O（1），后者复杂度为O(n)，但后者实际上是退化成了链表的查找，在这中间的情况都可以看作O（1）（或者可以理解为平均时间复杂度）","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1571026726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1215892,"avatar":"https://static001.geekbang.org/account/avatar/00/12/8d/94/150dfe78.jpg","nickname":"GGL","note":"","ucode":"AED10B8248D1E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":277196,"discussion_content":"前面讲散列表的时候已经说过了，主要看装载因子的大小。理想情况下可以认为每个槽的拉链长度为1。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591016088,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":213396,"user_name":"亢（知行合一的路上）","can_delete":false,"product_type":"c1","uid":1347013,"ip_address":"","ucode":"958AF7C96EB9E8","user_header":"https://static001.geekbang.org/account/avatar/00/14/8d/c5/898b13b4.jpg","comment_is_top":false,"comment_ctime":1588401730,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14473303618","product_id":100017301,"comment_content":"散列表和链表结合，相当于强强联合，链表维护顺序，散列表实现快速查找。","like_count":3},{"had_liked":false,"id":153474,"user_name":"Spring4J","can_delete":false,"product_type":"c1","uid":1645430,"ip_address":"","ucode":"06F056085A2564","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiauonyMORA2s43W7mogGDH4WYjW0gBJtYmUa9icTB6aMPGqibicEKlLoQmLKLWEctwHzthbTZkKR20w/132","comment_is_top":false,"comment_ctime":1574241277,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14459143165","product_id":100017301,"comment_content":"个人理解：数据就是存储在双向链表中；只是在操作双向链表的时候，我们并不直接通过双向链表找到节点，而是通过哈希表；哈希表在这里起到的作用就跟之前讲的跳表的索引差不多，用于提升查找效率；找到节点之后要插入或者删除就很快了，因为是双向链表；","like_count":3},{"had_liked":false,"id":79519,"user_name":"Geek_68a3d8","can_delete":false,"product_type":"c1","uid":1244905,"ip_address":"","ucode":"A8D4DF5460F50B","user_header":"https://static001.geekbang.org/account/avatar/00/12/fe/e9/8fc7a875.jpg","comment_is_top":false,"comment_ctime":1553504231,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14438406119","product_id":100017301,"comment_content":"LRU 缓存淘汰算法<br>那张图，我郁闷了两三天没看懂。<br>刚豁然开朗了。hash表中存的是双向链表的节点对象，为了复用节点，所以加一个hnext字段，data + hnext算是一个新的单向链表","like_count":3,"discussions":[{"author":{"id":1347740,"avatar":"https://static001.geekbang.org/account/avatar/00/14/90/9c/53d0f906.jpg","nickname":"黄豆豆","note":"","ucode":"5D47A4E3BAD3D6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":567903,"discussion_content":"你这理解的还是不对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651025185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37854,"user_name":"我能走多远","can_delete":false,"product_type":"c1","uid":1240465,"ip_address":"","ucode":"07DF5D5DADFA3C","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/91/1d332031.jpg","comment_is_top":false,"comment_ctime":1541753138,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14426655026","product_id":100017301,"comment_content":"https:&#47;&#47;github.com&#47;jin13417&#47;algo&#47;tree&#47;master&#47;c-cpp&#47;19_Dlisthash C语言 哈希表+双向循环链表 实现LRU功能，请指正。","like_count":3},{"had_liked":false,"id":37137,"user_name":"守着云开","can_delete":false,"product_type":"c1","uid":1183885,"ip_address":"","ucode":"22220485396D0D","user_header":"https://static001.geekbang.org/account/avatar/00/12/10/8d/43edb2dd.jpg","comment_is_top":false,"comment_ctime":1541466148,"is_pvip":false,"replies":[{"id":"13238","content":"基于链表法解决冲突的散列表中链表的next指针","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541467505,"ip_address":"","comment_id":37137,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14426368036","product_id":100017301,"comment_content":"hnext里面存储什么 不是太懂 老师","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428191,"discussion_content":"基于链表法解决冲突的散列表中链表的next指针","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541467505,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36966,"user_name":"雨天","can_delete":false,"product_type":"c1","uid":1056406,"ip_address":"","ucode":"FD9FB404ECA463","user_header":"https://static001.geekbang.org/account/avatar/00/10/1e/96/3162d51f.jpg","comment_is_top":false,"comment_ctime":1541408699,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14426310587","product_id":100017301,"comment_content":"1.改成单链表,删除&#47;插入的时候需要O(n)去找前驱节点;<br>2.如文中第一个列子,按ID顺序存储双向链表;在双向链表按积分hash和按ID跳表;","like_count":3},{"had_liked":false,"id":221830,"user_name":"Alpha","can_delete":false,"product_type":"c1","uid":1001861,"ip_address":"","ucode":"60CA15A25EC796","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/85/3f161d95.jpg","comment_is_top":false,"comment_ctime":1590598397,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10180532989","product_id":100017301,"comment_content":"Redis 有序集合的操作还有另外一类，也就是查找成员对象的排名（Rank）或者根据排名区间查找成员对象。这个功能单纯用刚刚讲的这种组合结构就无法高效实现了。这块内容我后面的章节再讲。<br>---- 请问这块内容是在后续哪一个章节讲的？","like_count":2,"discussions":[{"author":{"id":1645430,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiauonyMORA2s43W7mogGDH4WYjW0gBJtYmUa9icTB6aMPGqibicEKlLoQmLKLWEctwHzthbTZkKR20w/132","nickname":"Spring4J","note":"","ucode":"06F056085A2564","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336595,"discussion_content":"我也想问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608631070,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126092,"user_name":"z.l","can_delete":false,"product_type":"c1","uid":1181055,"ip_address":"","ucode":"805CC5784D3F76","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/7f/d35ab9a1.jpg","comment_is_top":false,"comment_ctime":1566311685,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10156246277","product_id":100017301,"comment_content":"查找按照积分从小到大排名在第 x 位到第 y 位之间的猎头ID列表<br>可以参考redis zset的实现：<br>typedef struct zskiplistNode {<br>    robj *obj;<br>    double score;<br>    struct zskiplistNode *backward;<br>    struct zskiplistLevel {<br>        struct zskiplistNode *forward;<br>        unsigned int span;<br>    } level[];<br>} zskiplistNode;<br><br>在level数组的每个元素中维护一个span字段，用来表示当前的指针跨越了多少个节点，这样得到一个node时就能算出它的排名，也可以根据排名范围找出相应node","like_count":2,"discussions":[{"author":{"id":1645430,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiauonyMORA2s43W7mogGDH4WYjW0gBJtYmUa9icTB6aMPGqibicEKlLoQmLKLWEctwHzthbTZkKR20w/132","nickname":"Spring4J","note":"","ucode":"06F056085A2564","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338868,"discussion_content":"如果添加或者删除某个节点，那不是要修改后面所有节点的span字段吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609406467,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57169,"user_name":"crazyone","can_delete":false,"product_type":"c1","uid":1115042,"ip_address":"","ucode":"705E34642E41F5","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/a2/ceb37046.jpg","comment_is_top":false,"comment_ctime":1546671101,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10136605693","product_id":100017301,"comment_content":"散列表以链表方式实现为前提，查找数据的时间复杂度为什么是O(1)？个人感觉应该是O(n),因为首先定位hash的拉链为O(1),然后遍历链表，假设链表平均长度为m,那查找速度就是O(n&#47;m),算是O(n),不应该是O(1)。这点不是很明白。。。","like_count":2,"discussions":[{"author":{"id":1268797,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5c/3d/e8325811.jpg","nickname":"对白","note":"","ucode":"3183E5ADBC794B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295143,"discussion_content":"时间复杂度是o(k)，k是链表长度，而散列表使用的链表不会很长，所以时间复杂度近似于O(1)。之前的文章讲过散列表的查找、插入和删除的时间复杂度，你可以去看看。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596101994,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1687158,"avatar":"https://static001.geekbang.org/account/avatar/00/19/be/76/8154a69a.jpg","nickname":"Its my life","note":"","ucode":"11FB761AE275D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40965,"discussion_content":"平均长度m，查找速度就是m，不是n/m，散列函数够好，m趋近于1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572313158,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37879,"user_name":"feifei","can_delete":false,"product_type":"c1","uid":1105431,"ip_address":"","ucode":"B1F8AE3AD82C51","user_header":"https://static001.geekbang.org/account/avatar/00/10/de/17/75e2b624.jpg","comment_is_top":false,"comment_ctime":1541764487,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10131699079","product_id":100017301,"comment_content":"老师，这是我根据你提供的思路，自己实现的一个散列表+双向链表实现的一个LRU缓存的代码，<br>我用java实现了一版<br>希望得到您的指正：<br><br>这个留言区限制了字数，我代码贴不完整，只能放一个git的地址<br><br>git地址:https:&#47;&#47;github.com&#47;kkzfl22&#47;datastruct&#47;blob&#47;master&#47;src&#47;main&#47;java&#47;com&#47;liujun&#47;datastruct&#47;hash&#47;cache&#47;lru&#47;CacheLRU.java<br><br>测试代码的github地址:<br>https:&#47;&#47;github.com&#47;kkzfl22&#47;datastruct&#47;blob&#47;master&#47;src&#47;test&#47;java&#47;com&#47;liujun&#47;datastruct&#47;hash&#47;cache&#47;lru&#47;TestCacheLRU.java<br><br>谢谢<br><br>","like_count":2},{"had_liked":false,"id":37132,"user_name":"守着云开","can_delete":false,"product_type":"c1","uid":1183885,"ip_address":"","ucode":"22220485396D0D","user_header":"https://static001.geekbang.org/account/avatar/00/12/10/8d/43edb2dd.jpg","comment_is_top":false,"comment_ctime":1541465521,"is_pvip":false,"replies":[{"id":"13239","content":"是要维护一个尾指针","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541467535,"ip_address":"","comment_id":37132,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10131400113","product_id":100017301,"comment_content":"LRU算法中，查找的一个数据是O(1)，然后将他移动到尾部为什么还是O(1)呢。<br>除非也维护了一个指向尾部的指针？不然找到尾部的复杂度是O(n)呀。","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428188,"discussion_content":"是要维护一个尾指针","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541467535,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1133055,"avatar":"https://static001.geekbang.org/account/avatar/00/11/49/ff/34a47dca.jpg","nickname":"4567890","note":"","ucode":"23BC97FD1DADF0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217469,"discussion_content":"头指针、尾指针应该都要维护的，那些是太多细节，为了让我们关注更主要的结构，所以忽略掉那些了~~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585562943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":243677,"user_name":"余巍","can_delete":false,"product_type":"c1","uid":1995082,"ip_address":"","ucode":"B0819C42A82371","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI0eGJygV4lh6PJuotKrz1jsZcOdNiaHnUC3y5A2O3yudUQLkzOE8758icDoXlvgpytQ50ibSIc9nJmg/132","comment_is_top":false,"comment_ctime":1598246300,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5893213596","product_id":100017301,"comment_content":"关于redis的LRU的实现：我们需要能从纷杂信息中focus到我们关注的点，暂时屏蔽不需要关注。也是一种思想方法：分离关注点。","like_count":1},{"had_liked":false,"id":215223,"user_name":"红豆成香","can_delete":false,"product_type":"c1","uid":1488601,"ip_address":"","ucode":"FB8FBB639B4BA6","user_header":"https://static001.geekbang.org/account/avatar/00/16/b6/d9/4d8a4d4c.jpg","comment_is_top":false,"comment_ctime":1588932913,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5883900209","product_id":100017301,"comment_content":"有个问题思考了很久，散列表本身是基于数组存储数据，那么数组存储的内容是将双向链表节点的引用吗？","like_count":1,"discussions":[{"author":{"id":1645430,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiauonyMORA2s43W7mogGDH4WYjW0gBJtYmUa9icTB6aMPGqibicEKlLoQmLKLWEctwHzthbTZkKR20w/132","nickname":"Spring4J","note":"","ucode":"06F056085A2564","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338867,"discussion_content":"数组中存储的是拉链的头结点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609406166,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212778,"user_name":"70","can_delete":false,"product_type":"c1","uid":1081899,"ip_address":"","ucode":"A5884B2BDDAB70","user_header":"https://static001.geekbang.org/account/avatar/00/10/82/2b/cf93c499.jpg","comment_is_top":false,"comment_ctime":1588209725,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5883177021","product_id":100017301,"comment_content":"数组：连续空间，支持随机访问，查询快动态扩容成本高，增删慢。<br>链表：空间不连续，不支持随机访问，查询慢支持动态扩容，增删快。<br>跳表：基于链表，建立索引，优化查询速度。使用空间换时间，数据插入和修改，链表索引动态更新<br>Hash表：数组思想，支持快速访问，存在hash冲突需要解决，无序，也需要注意扩容。<br>Hash表+跳表：有序，支持快速查找，解决hash冲突，充分发挥了数组和链表的优势","like_count":2},{"had_liked":false,"id":196432,"user_name":"zapup","can_delete":false,"product_type":"c1","uid":1397351,"ip_address":"","ucode":"388D6BB5D7B137","user_header":"https://static001.geekbang.org/account/avatar/00/15/52/67/fcba0967.jpg","comment_is_top":false,"comment_ctime":1585280690,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880247986","product_id":100017301,"comment_content":"10 万名猎头思考题思路：<br>1. 构建猎头积分散列表 idScoreMap: Map&lt;Integer, Integer&gt;<br>2. 构建积分猎头集散列表 scoreIdsMap: Map&lt;Integer, Set&lt;Integer&gt;&gt;<br>3. 构建积分跳表 scoreSkipList: SkipList&lt;Integer&gt;","like_count":1},{"had_liked":false,"id":175672,"user_name":"思辰","can_delete":false,"product_type":"c1","uid":1178337,"ip_address":"","ucode":"7867D6486C4A52","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/e1/78008221.jpg","comment_is_top":false,"comment_ctime":1580796621,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5875763917","product_id":100017301,"comment_content":"双向链表是把所有的业务数据按照顺序串起来，有前驱、后继指针，同一条拉链是把散列值相同的业务数据串起来，双向链表只有一个，拉链是每个数组下标对应一条，每条拉链只有后继指针hnext，所以是单链表，这样理解对不？","like_count":1},{"had_liked":false,"id":142023,"user_name":"小喵喵","can_delete":false,"product_type":"c1","uid":1062444,"ip_address":"","ucode":"FDBBB2A59DB8B6","user_header":"https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg","comment_is_top":false,"comment_ctime":1571279806,"is_pvip":false,"replies":[{"id":"55223","content":"这个跟你的业务需求有关 数据需要依赖数据库来存取 有些场景 比如内存索引 并不需要每次都讲数据落盘到数据库的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1571618561,"ip_address":"","comment_id":142023,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5866247102","product_id":100017301,"comment_content":"老师，关于课后思考的第二题有一个疑问：<br>我们是可以用今天学到的散列表和链表结合来使用，当时这个数据最后是存放在数据库的呀，增加、删除、查找数据最后还是通过sql语句来完成的，我想只能从数据库读取数据，然后自己写代码来构建一个散列表和链表来存数据，但是以后做增加、删除、查询都需要先操作数据库，然后再来维护自己构建的散列表和链表。这样岂不是直接操作数据库来的更加方便？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470958,"discussion_content":"这个跟你的业务需求有关 数据需要依赖数据库来存取 有些场景 比如内存索引 并不需要每次都讲数据落盘到数据库的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571618561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98610,"user_name":"just do it","can_delete":false,"product_type":"c1","uid":1396588,"ip_address":"","ucode":"5B710BFA0019C2","user_header":"https://static001.geekbang.org/account/avatar/00/15/4f/6c/2ee6d808.jpg","comment_is_top":false,"comment_ctime":1559040151,"is_pvip":false,"replies":[{"id":"36276","content":"理解的没错。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1559613041,"ip_address":"","comment_id":98610,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5854007447","product_id":100017301,"comment_content":"”因为我们的散列表是通过链表法解决散列冲突的，所以每个结点会在两条链中。一个链是刚刚我们提到的双向链表，另一个链是散列表中的拉链。前驱和后继指针是为了将结点串在双向链表中，hnext 指针是为了将结点串在散列表的拉链中。“ 老师结合图看了好几遍。不太确定理解的对不对。<br>是不是刚开始所有数据就形成一个双向链表，根据双向链表可以实现LUR（但是查询慢），然后为了提升”查找“效率，用散列表形式（同时形成一条拉链，解决了链表线性访问的问题），顺着拉链找到元素之后，将找到的元素删除（双向链表删除效率高），再到链表头重新插入访问的元素信息（更新双向链表的数据顺序）","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451754,"discussion_content":"理解的没错。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559613041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92038,"user_name":"云起","can_delete":false,"product_type":"c1","uid":1097790,"ip_address":"","ucode":"1642C543B47B87","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/3e/ff3ed621.jpg","comment_is_top":false,"comment_ctime":1557159436,"is_pvip":false,"replies":[{"id":"33068","content":"首先，你要明确：散列表和跳表是两个索引结构，独立不相关的。你可以参考下这篇文章的解释：<br>https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;PdvdZoa-SGk_Ojkv2pC2tQ<br><br>另一方面，按照分数区间查找数据，只需要在跳表索引中查找即可，不需要使用散列表。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1557279850,"ip_address":"","comment_id":92038,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5852126732","product_id":100017301,"comment_content":"这个课程的第一个问题  请教老师 关于散列表组合跳表  是怎么根据分数区间查找一批的id的  假如散列表有10个槽 有100个猎头 其中有一个槽保存(10,69)的单节点跳表10是id 69是分数  另一个槽保存(11,30)(50,73)的跳表","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449126,"discussion_content":"首先，你要明确：散列表和跳表是两个索引结构，独立不相关的。你可以参考下这篇文章的解释：\nhttps://mp.weixin.qq.com/s/PdvdZoa-SGk_Ojkv2pC2tQ\n\n另一方面，按照分数区间查找数据，只需要在跳表索引中查找即可，不需要使用散列表。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557279850,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81488,"user_name":"朱坤","can_delete":false,"product_type":"c1","uid":1098637,"ip_address":"","ucode":"65224DA2456EAB","user_header":"https://static001.geekbang.org/account/avatar/00/10/c3/8d/214ad614.jpg","comment_is_top":false,"comment_ctime":1553924446,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5848891742","product_id":100017301,"comment_content":"## WHY<br>- 链表的优势是保留了元素的顺序<br>- 哈希表的优势是O(1)查找<br><br>## HOW<br>- LinkedHashMap <br>- Lru缓存实现O(1)操作：双向链表 + 哈希表<br>- Redis有序集合: 跳表 + 哈希表","like_count":1},{"had_liked":false,"id":48364,"user_name":"Geek_987169","can_delete":false,"product_type":"c1","uid":1180853,"ip_address":"","ucode":"4B2955A044805D","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/b5/8bc4790b.jpg","comment_is_top":false,"comment_ctime":1544428883,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5839396179","product_id":100017301,"comment_content":"老师，redis命令如下：<br>ZADD key score member [[score member] [score member] ...]<br>您说的&quot;用户id就是key&quot;,这里的key应该说的是命令中的member吧？","like_count":1},{"had_liked":false,"id":46951,"user_name":"SIYI","can_delete":false,"product_type":"c1","uid":1238567,"ip_address":"","ucode":"FB3C629FF6A2C7","user_header":"https://static001.geekbang.org/account/avatar/00/12/e6/27/1c43bd65.jpg","comment_is_top":false,"comment_ctime":1544007567,"is_pvip":false,"replies":[{"id":"16933","content":"如果没有散列表 我们需要遍历整个链表 我的意思是有了就不需要遍历整个链表了 ","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1544149101,"ip_address":"","comment_id":46951,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5838974863","product_id":100017301,"comment_content":"老师，为什么不用遍历节点了啊？通过哈希表定位出来后不是应该沿着hnext遍历节点吗？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431616,"discussion_content":"如果没有散列表 我们需要遍历整个链表 我的意思是有了就不需要遍历整个链表了 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544149101,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37059,"user_name":"微秒","can_delete":false,"product_type":"c1","uid":1249195,"ip_address":"","ucode":"65A2E8B565B191","user_header":"https://static001.geekbang.org/account/avatar/00/13/0f/ab/9748f40b.jpg","comment_is_top":false,"comment_ctime":1541435268,"is_pvip":false,"replies":[{"id":"13243","content":"不用再遍历节点了啊","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541467773,"ip_address":"","comment_id":37059,"utype":1}],"discussion_count":4,"race_medal":0,"score":"5836402564","product_id":100017301,"comment_content":"有一点不理解，为什么查找哈希表中双向链表某一节点的时间复杂度是o(1)？？？首先在哈希表中遍历为1，但确定了哈希表的位置后，还要遍及节点，这个跟链表的规模有关吧？？？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428149,"discussion_content":"不用再遍历节点了啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541467773,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1050508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","nickname":"蚂蚁内推+v","note":"","ucode":"24B10AEE54B3FD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":141,"discussion_content":"老师，这里为什么不要遍历节点了啊，假设通过散列函数计算出在bucket0的位置，但是查找具体的节点还是需要遍历bucket0位置上的链表吧，只是说通过散列表的方式无需遍历整个链表，但是具体的bucket位置的上的链表还是需要遍历的吧。麻烦老师解答下，谢谢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1561172079,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1133055,"avatar":"https://static001.geekbang.org/account/avatar/00/11/49/ff/34a47dca.jpg","nickname":"4567890","note":"","ucode":"23BC97FD1DADF0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1050508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","nickname":"蚂蚁内推+v","note":"","ucode":"24B10AEE54B3FD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217470,"discussion_content":"对的，那个应该是要遍历的，但是，时间复杂度上来说，就不是O(n)了，就是O(1)了，老师说的“不用遍历节点”，应该是指的，“不用从头到尾遍历双向链表的所有节点”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585563086,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":141,"ip_address":""},"score":217470,"extra":""}]},{"author":{"id":1440185,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f9/b9/21b0553f.jpg","nickname":"叶少波","note":"","ucode":"CDF3DEEC7DFEA0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":169898,"discussion_content":"我也没理解这一点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581653138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37034,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1541427873,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5836395169","product_id":100017301,"comment_content":"Redis有序集合使用散列表与双向链表（跳表）的组合：<br>1、将ID做为key，存储在散列表中<br>2、每次插入数据时，保证双向链表是按积分从小到大进行排序。<br><br>分析下时间复杂度<br>1、添加成员对象-O(logn)<br>2、按照键值来删除一个成员对象-O(1)<br>3、按照键值来查找一个成员对象-O(1)<br>4、按照分值区间查找数据-O(logn)<br>5、按照分值从小到大排序成员变量-O(1)。<br>第5点双向链表本来就是按照分值排序的。<br><br>思考题1：能正常工作，只是删除和添加操作（重复添加）需要找到前趋结点导致时间复杂度退化为O(n）<br>思考题2：<br>使用散列表与双向链表（跳表）的组合：<br>1、将猎头ID做为key，存储在散列表中<br>2、将猎头积分做为跳表排列顺序。<br>3、查询排名的，静待以后学习的数据结构","like_count":1},{"had_liked":false,"id":36925,"user_name":"小动物很困","can_delete":false,"product_type":"c1","uid":1133936,"ip_address":"","ucode":"49A727277A37E1","user_header":"https://static001.geekbang.org/account/avatar/00/11/4d/70/7d736d5f.jpg","comment_is_top":false,"comment_ctime":1541390315,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5836357611","product_id":100017301,"comment_content":"对于第一个问题:<br>单向链表可以实现,但是对于数据找到后的对于链表的操作时间复杂度高.<br>第二个问题:<br>可以使用hash表+链表实现,认为id基本上唯一,不存在hash冲突<br>hash表 key=id value=指向 {id,分数}对象链表节点的引用<br>但是有一个问题:<br>是获取范围数据的时候对链表排序,还是在插入的时候使对象链表按照分数有序化.<br>欢迎大佬指正","like_count":1},{"had_liked":false,"id":36905,"user_name":"灰飞灰猪不会灰飞.烟灭","can_delete":false,"product_type":"c1","uid":1127314,"ip_address":"","ucode":"FF9FB4C902D1F5","user_header":"https://static001.geekbang.org/account/avatar/00/11/33/92/99530cee.jpg","comment_is_top":false,"comment_ctime":1541384237,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5836351533","product_id":100017301,"comment_content":"red is中key是按照什么方式（算法）hash的？<br>一般key是个字符串，是不是按照什么方式方式进行hash散列存储？","like_count":1},{"had_liked":false,"id":358874,"user_name":"111","can_delete":false,"product_type":"c1","uid":3109487,"ip_address":"北京","ucode":"D6E8E83A118A3E","user_header":"https://static001.geekbang.org/account/avatar/00/2f/72/6f/44c10658.jpg","comment_is_top":false,"comment_ctime":1664956449,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664956449","product_id":100017301,"comment_content":"总结<br>1. 散列表提供查找，链表提供删除和插入，排序<br><br>1. 不能，这样要得到前一个值就需要遍历了<br>2. ID作为key，积分作为value。key存在散列表中，积分再构建跳表","like_count":0},{"had_liked":false,"id":354623,"user_name":"李晨","can_delete":false,"product_type":"c1","uid":2716735,"ip_address":"北京","ucode":"D734DE3B9A5A2D","user_header":"https://static001.geekbang.org/account/avatar/00/29/74/3f/5c9fd08f.jpg","comment_is_top":false,"comment_ctime":1660620607,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1660620607","product_id":100017301,"comment_content":"1、改成单向链表后，delete()、get（）操作会比较麻烦：<br>delete（）元素后，将链表上该元素前后的两个元素连接在一起；<br>get（）元素后，该元素会移动到链表的尾部，还要就是需要将链表上该元素前后的两个元素连接在一起。<br>2、使用散列表+跳表：<br>积分排序（升序）构建一个跳表，猎头 ID 构建一个散列表；<br>根据猎头的 ID 快速查找、删除、更新这个猎头的积分信息------直接使用散列表；<br>查找积分在某个区间的猎头 ID 列表------使用跳表+散列表；<br>查找按照积分从小到大排名在第 x 位到第 y 位之间的猎头 ID 列表------使用跳表+散列表；<br>","like_count":0},{"had_liked":false,"id":352755,"user_name":"陈斌","can_delete":false,"product_type":"c1","uid":1149402,"ip_address":"","ucode":"AD6933D125C930","user_header":"https://static001.geekbang.org/account/avatar/00/11/89/da/136cdca6.jpg","comment_is_top":false,"comment_ctime":1658913623,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658913623","product_id":100017301,"comment_content":"学习下来也有跟smallfly同样的感觉，两种核心数据结构数组和链表，其功能都是为了存取集合的数据。最大区别就是连续内存和非连续内存。<br><br>数组是通过连续内存存取数据，更节省空间，可以随机访问。但在迁移数据就没有链表那么方便。<br><br>链表可以有不连续内存的特点，但需要维护指针相关信息。同时也没有随机访问的优势，但可以通过跳表等进行优化将查找性能提升。<br><br>怎样选择数据结构和算法，首先要了解数据的特点和需要的操作。再根据需求选择合适的算法以及需要支持的数据结构。","like_count":0},{"had_liked":false,"id":352754,"user_name":"老大不小","can_delete":false,"product_type":"c1","uid":1295609,"ip_address":"","ucode":"35BCDD3CB13467","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJRFRX8kNzNet7FibNvtavbVpAwK09AhIhrib9k762qWtH6mre8ickP7hM5mgZC4ytr8NnmIfmAhxMSQ/132","comment_is_top":false,"comment_ctime":1658913017,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658913017","product_id":100017301,"comment_content":"感觉好奇怪，LinkedHashMap的图中，key:1，2，3，5，是因为hash冲突了，所以才放到链表上的吗？<br>你说LinkedHashMap是散列表+链表，但是完全没看到数组，是不是我理解错了？","like_count":0},{"had_liked":false,"id":348319,"user_name":"MClink","can_delete":false,"product_type":"c1","uid":1435733,"ip_address":"","ucode":"F479190923355C","user_header":"https://static001.geekbang.org/account/avatar/00/15/e8/55/92f82281.jpg","comment_is_top":false,"comment_ctime":1654957565,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1654957565","product_id":100017301,"comment_content":"一开始一直没看懂第一个图，研究了一会。才理解了。首先这个图是为了更好的实现LRU而衍生的结构，从普通的数组+单链表实现的散列表，变成了数组+双向链表+指向下个冲突节点的指针，如果不看虚线箭头，就是一个普通的用拉链法解决冲突的散列表，然后因为LRU也需要维护一个链表。就用pre , next 来维护这个LRU链表。也就是虚线所连起来的双向链表实际上就是LRU链表。通过哈希表可以实现O(1)的查询。再通过双向链表又能很方便的获取前驱节点。从而提升了效率。个人是这么理解的。","like_count":0},{"had_liked":false,"id":347872,"user_name":"行则将至","can_delete":false,"product_type":"c1","uid":1542987,"ip_address":"","ucode":"DB972F2DF059C4","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","comment_is_top":false,"comment_ctime":1654525764,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1654525764","product_id":100017301,"comment_content":"我用双向链表+散列表实现了一个LRU缓存。我发现，如果我把散列表的size设置的很小，制造hash冲突的话，遍历冲突的这条线花的时间挺大的，不知道用什么办法解决一下","like_count":0},{"had_liked":false,"id":345895,"user_name":"Geek_b39876","can_delete":false,"product_type":"c1","uid":2762961,"ip_address":"","ucode":"D9B5F30CA3B3CF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/GSp0Ph1nIwz6ibRSper4jvIiaaLv6tJMtsI3qjnp1XLtWUCYicxlTsuVQ1UNZ404zY2Aenmf6AJjkPF2cpZ2zUm7Q/132","comment_is_top":false,"comment_ctime":1652683866,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652683866","product_id":100017301,"comment_content":"这里lru算法看了好几遍才看懂，我个人感觉是因为老师把所有概念放在一起讲了导致瞬间懵逼了（不排除是我太菜了QAQ），从老师讲课逻辑上来理解:最开始所有数据其实只有一个双向链表，但是双向链表查找是o（n），为了提升效率就把双向链表中所有节点按hash把每个节点放入了散列表也就是数组中，hnext为了解决哈希冲突而引入了新的链表。PS:（下面可以不看）从实际结构上来看其实是相反的，lru算法真实的数据结构其实是数组+链表，而为了实现lru时间排序而加了根据时间排序的双向链表这个逻辑结构，也就是维护了prev和next两个指针","like_count":0},{"had_liked":false,"id":344314,"user_name":"ue5","can_delete":false,"product_type":"c1","uid":2754983,"ip_address":"","ucode":"6CA310ACE02ED4","user_header":"https://static001.geekbang.org/account/avatar/00/2a/09/a7/541e33bc.jpg","comment_is_top":false,"comment_ctime":1651465004,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651465004","product_id":100017301,"comment_content":"hnext是维护散列表的链表，和双联表完全区分开了。","like_count":0},{"had_liked":false,"id":337032,"user_name":"Today","can_delete":false,"product_type":"c1","uid":1235000,"ip_address":"","ucode":"4FA397F0BD8C6E","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/38/41027bda.jpg","comment_is_top":false,"comment_ctime":1646559728,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646559728","product_id":100017301,"comment_content":"本节又学习到了<br>1. 散列表实现的关键 “散列函数” 会把数据打乱存储，如果需要按照数据的特性进行有序输出，需要结合链表或数组这样的线性表结合使用。两种数据结构之间通过引用建立了一个“多态”数据结构。<br>2. 原来 java 中 LinkedHashMap 的设计结构和 LRU 缓存策略的一样<br>3. Redis 中的跳表结构配合哈希表，可以实现按键，按值操作的复杂度同时降低到可观值，就很厉害","like_count":0},{"had_liked":false,"id":336395,"user_name":"其实特仑苏就是一瓶牛奶","can_delete":false,"product_type":"c1","uid":2333829,"ip_address":"","ucode":"B2F6E8E96BA62A","user_header":"https://static001.geekbang.org/account/avatar/00/23/9c/85/0e9f445a.jpg","comment_is_top":false,"comment_ctime":1646127287,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646127287","product_id":100017301,"comment_content":"2. 分别将猎头 ID 和积分信息作为哈希表的 Key, Value<br>（1）根据猎头 ID 快速查找、删除、更新的时间复杂度都为：O(1)<br>（2）查找积分在某个区间的猎头 ID 列表：<br>         方法1：遍历哈希表，如果某猎头的积分在此区间内，那么就将该猎头的 ID 加入到结果列表中。这个方法的时间复杂度为：O(n)<br>         方法2：对哈希表进行排序，再对其进行两次二分查找，第一次二分查找先找出大于等于左端点的数据，第二次再查找出小于等于右端点的数据，再进行分片操作，由于排序的时间复杂度为O(nlogn)，两次查找的时间复杂度为O(logn)，切片的时间复杂度为O(1)，所以总的时间复杂度为O(nlogn)<br>（3）对已排好序的哈希表进行切片操作，时间复杂度为O(1)","like_count":0},{"had_liked":false,"id":335533,"user_name":"Geek_279849","can_delete":false,"product_type":"c1","uid":2699218,"ip_address":"","ucode":"FC6A3514FC955C","user_header":"","comment_is_top":false,"comment_ctime":1645577978,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645577978","product_id":100017301,"comment_content":"散列表和双向链表组合使用<br>前提是散列表是通过链表法解决散列冲突的。","like_count":0},{"had_liked":false,"id":327865,"user_name":"Bison","can_delete":false,"product_type":"c1","uid":1213014,"ip_address":"","ucode":"31D42D98643010","user_header":"https://static001.geekbang.org/account/avatar/00/12/82/56/b3fc9a64.jpg","comment_is_top":false,"comment_ctime":1640333695,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640333695","product_id":100017301,"comment_content":"首先整个数据结构由以下几个部分构成，左侧的散列表，右侧的每一个散列表槽位后面的拉链，即一个一个的单链表，然后所有节点构成的一个双向链表（Only one）<br>每个节点都有prev指针、data、next指针、hnext指针构成<br>prev和next指针就是常规双向链表里面的固定构成，这个很好理解。<br>多出来的hnext指针，就是每个单链表的next指针，此时你可以将它前面的prev、data、next看成一个整体，这样就符合我们常规印象里面的单链表的构成了。<br><br>不知道这样理解有没有什么问题，不知道过去了这么久有没有可能得到老师或者其他优秀学员的肯定或者指正哈哈","like_count":0},{"had_liked":false,"id":318753,"user_name":"悟空","can_delete":false,"product_type":"c1","uid":1074613,"ip_address":"","ucode":"8981363B9D0A4F","user_header":"https://static001.geekbang.org/account/avatar/00/10/65/b5/8dd8ed2c.jpg","comment_is_top":false,"comment_ctime":1635412267,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635412267","product_id":100017301,"comment_content":"为什么 LRU 中 一条链是双向链表的链，一条链是拉链；<br>首先： 我们使用 双向链表来 维护 LRU 中 先后 顺序 （ 新数据在队头， 老数据在队尾）<br>其次： 由于 在链表中的查找 是 o(n) 的；  所以 我们使用 散列表 来 帮助查找数据；<br>在存在 哈希冲突时候 ， 通过 单链表 （拉链） hnext 指针 来 解决哈希冲突；<br> ","like_count":0},{"had_liked":false,"id":313335,"user_name":"放飞心情","can_delete":false,"product_type":"c1","uid":1244845,"ip_address":"","ucode":"75A2192D91D86C","user_header":"https://static001.geekbang.org/account/avatar/00/12/fe/ad/7fa85a7d.jpg","comment_is_top":false,"comment_ctime":1632382152,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632382152","product_id":100017301,"comment_content":"仅仅回答第二题：查找按照积分从小到大排名在第 x 位到第 y 位之间的猎头 ID 列表？<br>跳表通过索引实现，王争老师提供的跳表实现中Node代码如下：<br>public class Node {<br>    &#47;&#47; 节点数据值<br>    private int data = -1;<br>    &#47;&#47; 当前节点在各层索引中下一个Node的值<br>    private Node forwards[] = new Node[MAX_LEVEL];<br>    &#47;&#47; 用于记录当前节点到索引下一批节点的距离<br>    private int[] range = new int[MAX_LEVEL];<br>    &#47;&#47; 当前节点最大索引层数<br>    private int maxLevel = 0;<br>……<br>新增range数组","like_count":0},{"had_liked":false,"id":313334,"user_name":"放飞心情","can_delete":false,"product_type":"c1","uid":1244845,"ip_address":"","ucode":"75A2192D91D86C","user_header":"https://static001.geekbang.org/account/avatar/00/12/fe/ad/7fa85a7d.jpg","comment_is_top":false,"comment_ctime":1632381205,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632381205","product_id":100017301,"comment_content":"仅仅回答第二个问题中：查找按照积分从小到大排名在第 x 位到第 y 位之间的猎头 ID 列表。","like_count":0},{"had_liked":false,"id":310108,"user_name":"Erica🏸👑","can_delete":false,"product_type":"c1","uid":2623400,"ip_address":"","ucode":"65A97A04626DD2","user_header":"https://static001.geekbang.org/account/avatar/00/28/07/a8/45a51ec5.jpg","comment_is_top":false,"comment_ctime":1630487575,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630487575","product_id":100017301,"comment_content":"使用链表实现LRU，使用散列表进行优化，在增加，查询，删除的时候，还需要考虑到，维护散列表，例如，散列表中的如果冲突，后面的链表，如果删除了一个，需要维护原来的散列，将该节点后面的一个节点放到当前节点","like_count":0},{"had_liked":false,"id":307395,"user_name":"Geek_962f6d","can_delete":false,"product_type":"c1","uid":2705451,"ip_address":"","ucode":"5C9D1499BF10EA","user_header":"","comment_is_top":false,"comment_ctime":1629081640,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629081640","product_id":100017301,"comment_content":"散列表实现了查找、删除、插入的时间复杂度为O(1)，双向链表实现了按序存储。比如按访问时间排序（LRU），按积分信息排序。<br>那么有多个需要排序的属性，是不是需要多个双向链表呢？","like_count":0},{"had_liked":false,"id":305944,"user_name":"大祭司","can_delete":false,"product_type":"c1","uid":1831099,"ip_address":"","ucode":"06479A180B8DED","user_header":"https://static001.geekbang.org/account/avatar/00/1b/f0/bb/f7025f42.jpg","comment_is_top":false,"comment_ctime":1628240293,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628240293","product_id":100017301,"comment_content":"lru缓存可以理解为给双向链表每个节点计算散列值，然后把散列值的对应节点放在散列表中，有散列冲突的节点，使用链表法解决，规则是：通过节点的hnext属性形成的链表。","like_count":0},{"had_liked":false,"id":305942,"user_name":"大祭司","can_delete":false,"product_type":"c1","uid":1831099,"ip_address":"","ucode":"06479A180B8DED","user_header":"https://static001.geekbang.org/account/avatar/00/1b/f0/bb/f7025f42.jpg","comment_is_top":false,"comment_ctime":1628239940,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628239940","product_id":100017301,"comment_content":"我发现留言区都是人才，说话有好听，带着疑问看了看被解决了<br>我想说：在座的各位，都是大佬!!!","like_count":0},{"had_liked":false,"id":303724,"user_name":"叶致习","can_delete":false,"product_type":"c1","uid":1510429,"ip_address":"","ucode":"38E399769699D9","user_header":"https://static001.geekbang.org/account/avatar/00/17/0c/1d/f21977c8.jpg","comment_is_top":false,"comment_ctime":1626945454,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626945454","product_id":100017301,"comment_content":"举例分析图一中双向链表的理解。<br>这里散列表是通过链表法解决散列冲突的，所以从逻辑上讲每个结点会在两条链中（**但实际物理上还是只有一个双向链表**）。<br>第一个槽位(`slot`)的最后一个节点应该是在添加时发现有散列冲突，且属于第一个槽位，所以用 `hnext` 指针和第一个槽位的第一个节点相连，然后又因为时间上是最后一个插入的节点，所以和第五个槽位的最后一个节点通过 `pre`、`next` 相连在一起。综上，通过图中的 `pre`、`next` 指针连接顺序（浅色线），我们可以明显得出节点的时间顺序，通过 `hnext` 指针（黑色线）可以知道节点在哪个槽中。","like_count":0},{"had_liked":false,"id":302385,"user_name":"静✨","can_delete":false,"product_type":"c1","uid":1658413,"ip_address":"","ucode":"1B33229C206339","user_header":"https://static001.geekbang.org/account/avatar/00/19/4e/2d/06d3f9f5.jpg","comment_is_top":false,"comment_ctime":1626185896,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626185896","product_id":100017301,"comment_content":"看开头还以为要学三样东西，结果读完了发现这仨都是一个东西","like_count":0},{"had_liked":false,"id":297690,"user_name":"海崖","can_delete":false,"product_type":"c1","uid":2552745,"ip_address":"","ucode":"9D42E0B0D30A56","user_header":"https://static001.geekbang.org/account/avatar/00/26/f3/a9/bb9d8450.jpg","comment_is_top":false,"comment_ctime":1623734155,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623734155","product_id":100017301,"comment_content":"叮~打卡","like_count":0},{"had_liked":false,"id":291715,"user_name":"oops","can_delete":false,"product_type":"c1","uid":1102831,"ip_address":"","ucode":"1DEC23A503F8A3","user_header":"https://static001.geekbang.org/account/avatar/00/10/d3/ef/9c5e695b.jpg","comment_is_top":false,"comment_ctime":1620445279,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620445279","product_id":100017301,"comment_content":"双向链表 节点的前驱，后继指针；因为引入了hash表，hash冲突用链表法解决，这条链路里后继节点是hnext","like_count":0},{"had_liked":false,"id":291111,"user_name":"双木公子","can_delete":false,"product_type":"c1","uid":1116567,"ip_address":"","ucode":"751885864D3AB7","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/97/4314e2d8.jpg","comment_is_top":false,"comment_ctime":1620032367,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620032367","product_id":100017301,"comment_content":"老师的课程真是买得太值了，少走好多弯路，少看好多源码啊","like_count":0},{"had_liked":false,"id":290513,"user_name":"Laughing","can_delete":false,"product_type":"c1","uid":1002134,"ip_address":"","ucode":"F68F1E000CA800","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/96/99466a06.jpg","comment_is_top":false,"comment_ctime":1619598426,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619598426","product_id":100017301,"comment_content":"1. 使用单向链表可以正常工作，只不过因为单向链表的原因，每次做操作都需要遍历链表，所以时间复杂度为O(n);<br>2. <br>a) 猎头ID使用散列表，可实现快速CURD<br>b) 使用积分为散列条件构建散列或跳表，每一个表元素对应一个链表<br>c) 基于b)的结构，对散列表排序，然后顺序读取散列表对应的链表并计数<br><br>不过我认为使用链表+散列表解决b、c的问题没有必要，感觉按积分建立桶排序完全能够胜任范围查找和积分大小排序。<br><br>不知道我想的又没有错。请老师指正。<br>","like_count":0},{"had_liked":false,"id":287294,"user_name":"帝江","can_delete":false,"product_type":"c1","uid":1590610,"ip_address":"","ucode":"93CBA4E4D05DA5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/B9vSOjMc2a86kYA8R5yDkVdFiaj2JeBZ1PuI9oUKhbnvuZwuibdUam6FTcGzDaiaFdk2GWJveUGhfCVpv4KaOdicoQ/132","comment_is_top":false,"comment_ctime":1617870771,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617870771","product_id":100017301,"comment_content":"好像有种在学mysql的索引的感觉...","like_count":0},{"had_liked":false,"id":279487,"user_name":"sowhat1412","can_delete":false,"product_type":"c1","uid":2418486,"ip_address":"","ucode":"B43EF280922F50","user_header":"https://static001.geekbang.org/account/avatar/00/24/e7/36/924bbcae.jpg","comment_is_top":false,"comment_ctime":1613802548,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613802548","product_id":100017301,"comment_content":"个人感觉其实就两种数据结构，链表和数组。<br><br>数组占据随机访问的优势，却有需要连续内存的缺点。<br><br>链表具有可不连续存储的优势，但访问查找是线性的。<br><br>散列表和链表、跳表的混合使用，是为了结合数组和链表的优势，规避它们的不足。<br><br>我们可以得出数据结构和算法的重要性排行榜：连续空间 &gt; 时间 &gt; 碎片空间。","like_count":0},{"had_liked":false,"id":276664,"user_name":"king","can_delete":false,"product_type":"c1","uid":1100439,"ip_address":"","ucode":"FFC090D0EF1F80","user_header":"https://static001.geekbang.org/account/avatar/00/10/ca/97/5042c207.jpg","comment_is_top":false,"comment_ctime":1612071420,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612071420","product_id":100017301,"comment_content":"看了评论很多人对hnext理解有点不是很清楚，我也不是很清楚，我通过对比了redis源码上面的实现，觉这个hnext有点像redis的dict，zset里面也是有个指针指到dict。dict本身就是个散列表，内部自己解决哈希冲突（也是拉链方式），并不是用hnext来解决哈希冲突。所以hnext我觉得就是个指向他所对应的散列表节点而已","like_count":0},{"had_liked":false,"id":274808,"user_name":"Geek_3247e1","can_delete":false,"product_type":"c1","uid":2407135,"ip_address":"","ucode":"30D8AF5F4CEA47","user_header":"","comment_is_top":false,"comment_ctime":1611175559,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611175559","product_id":100017301,"comment_content":"JavaScript的对象也是散列表和链表的结合吧","like_count":0},{"had_liked":false,"id":272510,"user_name":"Allan","can_delete":false,"product_type":"c1","uid":1310388,"ip_address":"","ucode":"8DA4DBECC2C45C","user_header":"https://static001.geekbang.org/account/avatar/00/13/fe/b4/295338e7.jpg","comment_is_top":false,"comment_ctime":1610103389,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610103389","product_id":100017301,"comment_content":"1、双向链表 改为单链表同样能工作，只是效率的问题。<br>2、<br>根据id操作，所以对id进行散列函数设置，可以O(1)操作。<br>积分为范围，就需要我们进行跳表设计，范围分数，存储为id。<br>第三个问题，我想着用以后学习到的小顶堆来做","like_count":0},{"had_liked":false,"id":272243,"user_name":"慕高迪","can_delete":false,"product_type":"c1","uid":1448126,"ip_address":"","ucode":"EB1CB5EA4E3A90","user_header":"https://static001.geekbang.org/account/avatar/00/16/18/be/ad3127e0.jpg","comment_is_top":false,"comment_ctime":1610003357,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610003357","product_id":100017301,"comment_content":"总结<br><br>为什么散列表通常会和链表组合在一起使用？<br><br>数据通过散列函数之后是随机存储在散列表中的，无法按照某种顺序遍历散列表中的元素。而与链表的结合，就可以做到这一点。而链表与散列表的集合，由于在链表中进行查找的时间复杂度为O(N)，但与散列表结合后，可以将查找的时间复杂度降为O(1)。<br><br>以下三种典型的应用场景，就是他们之间的组合来实现：<br><br>1、LRU缓存机制的实现<br>2、LinkedHashMap底层存储结构<br>3、Redis有序集合更是结合了跳表和散列表，实现既可以根据Key进行查找，也可以根据范围进行查找。","like_count":0},{"had_liked":false,"id":271126,"user_name":"Spring4J","can_delete":false,"product_type":"c1","uid":1645430,"ip_address":"","ucode":"06F056085A2564","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiauonyMORA2s43W7mogGDH4WYjW0gBJtYmUa9icTB6aMPGqibicEKlLoQmLKLWEctwHzthbTZkKR20w/132","comment_is_top":false,"comment_ctime":1609405367,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609405367","product_id":100017301,"comment_content":"之前看的时候写了个乞丐版的LinkedHashMap，这次再看打算写一个sorted set<br>","like_count":0},{"had_liked":false,"id":270076,"user_name":"刘智敏","can_delete":false,"product_type":"c1","uid":1076768,"ip_address":"","ucode":"83D3DE25192DD6","user_header":"https://static001.geekbang.org/account/avatar/00/10/6e/20/a0740b7d.jpg","comment_is_top":false,"comment_ctime":1608893904,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608893904","product_id":100017301,"comment_content":"思考题二，用哈希表加跳表，id作为哈希的key，值存储id和score组成的对象，跳表用score排序。这样就可以实现1、2、3的操作了。我这解决方案是不是可行呢？","like_count":0},{"had_liked":false,"id":269094,"user_name":"Jahng","can_delete":false,"product_type":"c1","uid":1325514,"ip_address":"","ucode":"5D5789EAAC4739","user_header":"https://static001.geekbang.org/account/avatar/00/14/39/ca/4a07bfd8.jpg","comment_is_top":false,"comment_ctime":1608521609,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608521609","product_id":100017301,"comment_content":"redis内部实现的LRU其实是个近似LRU","like_count":0},{"had_liked":false,"id":265723,"user_name":"Adam","can_delete":false,"product_type":"c1","uid":1517838,"ip_address":"","ucode":"965DCD693E752B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK36t2flfxhzKygfLfdIHbK99M9D9w3v3bwAHUibJSFAs1ibswf7hbhkqL321k5SUjfiaWkkHeRBlibNA/132","comment_is_top":false,"comment_ctime":1606993967,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606993967","product_id":100017301,"comment_content":"跳表支持区间范围查找。这种思考题二需要有范围操作的需求应该先考虑跳表。根据用户搜索对应的积分完全就是散列表 和 链表 或者 散列表跟跳表的组合都能是实现。综上这这里选择散列表+跳表组合","like_count":0},{"had_liked":false,"id":262683,"user_name":"Qiubh","can_delete":false,"product_type":"c1","uid":1072658,"ip_address":"","ucode":"3BC33EC44F2FDE","user_header":"https://static001.geekbang.org/account/avatar/00/10/5e/12/c0c4d6f2.jpg","comment_is_top":false,"comment_ctime":1605801215,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1605801215","product_id":100017301,"comment_content":"首先，我们来看如何查找一个数据。我们前面讲过，散列表中查找数据的时间复杂度接近 O(1)，所以通过散列表，我们可以很快地在缓存中找到一个数据。当找到数据之后，我们还需要将它移动到双向链表的尾部。<br>      这里移动到双向链表的尾部，时间复杂度是O(n)。因此 LRU 缓存淘汰算法，光查找这一项时间复杂度都不是O(1) 了吧。","like_count":0,"discussions":[{"author":{"id":1645430,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiauonyMORA2s43W7mogGDH4WYjW0gBJtYmUa9icTB6aMPGqibicEKlLoQmLKLWEctwHzthbTZkKR20w/132","nickname":"Spring4J","note":"","ucode":"06F056085A2564","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376161,"discussion_content":"你都已经通过通过哈希表找到节点了，直接移动不就完了吗。前后指针都有，尾指针也有，不是O(1)是多少，又不是单链表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621998059,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":260966,"user_name":"于途","can_delete":false,"product_type":"c1","uid":1669343,"ip_address":"","ucode":"70300C6CCCEAF1","user_header":"https://static001.geekbang.org/account/avatar/00/19/78/df/424bdc4a.jpg","comment_is_top":false,"comment_ctime":1605162999,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1605162999","product_id":100017301,"comment_content":"1.Java中的 LinkedHashMap 是通过双向链表和散列表这两种数据结构组合实现的。LinkedHashMap 中的“Linked”实际指的是双向链表，并非指用链表法解决散列冲突。<br><br>2.按照访问时间排序的 LinkedHashMap 本身就是一个支持 LRU 缓存淘汰策略的缓存系统。按照访问时间排序，指的是构造方法传入的true,如下：<br><br>&#47;&#47; 10是初始大小，0.75是装载因子，true是表示按照访问时间排序<br>HashMap&lt;Integer, Integer&gt; m = new LinkedHashMap&lt;&gt;(10, 0.75f, true);","like_count":0},{"had_liked":false,"id":260949,"user_name":"于途","can_delete":false,"product_type":"c1","uid":1669343,"ip_address":"","ucode":"70300C6CCCEAF1","user_header":"https://static001.geekbang.org/account/avatar/00/19/78/df/424bdc4a.jpg","comment_is_top":false,"comment_ctime":1605160106,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1605160106","product_id":100017301,"comment_content":"关于 散列表+双向列表 实现的LRU缓存淘汰算法：<br><br>添加数据到缓存，我们需要先看这个数据是否已经在缓存中。如果已经在其中，需要将其移动到双向链表的尾部；如果不在其中，还要看缓存有没有满。如果满了，则将双向链表头部的结点删除，然后再将数据放到链表的尾部；如果没有满，就直接将数据放到链表的尾部。<br><br>那么为什么是将数据放到链表的尾部呢？因为删除数据是从链表头部移除元素，时间复杂度是O(1)。且符合最近最少使用的特点。","like_count":0},{"had_liked":false,"id":260727,"user_name":"crtd","can_delete":false,"product_type":"c1","uid":1303657,"ip_address":"","ucode":"7B256506885938","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/mj6VltwzDPicvYWopTsicno8axxOFQlc4ibHazjdobicrbSQT5IFXCdcSodxSsY0JYYDWt7mXryfabPlbibiaR4lv0pg/132","comment_is_top":false,"comment_ctime":1605089337,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605089337","product_id":100017301,"comment_content":"买了这个课程，但是加微信的工作人员不拉我进群，不回我的消息，请问如何举报这个人，不负责任啊","like_count":0},{"had_liked":false,"id":257343,"user_name":"杨","can_delete":false,"product_type":"c1","uid":1971269,"ip_address":"","ucode":"7EFEFE285975C6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/oltLEqTrmHm2aJP99BK6tHu5h7hp4aj08wR5Wt6H31iadFduDAVvjYKmhQ2nvGbLV3lkVdiat2GRasgWXoJeTibUg/132","comment_is_top":false,"comment_ctime":1603942186,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603942186","product_id":100017301,"comment_content":"LRU 缓存淘汰策略：将当前操作的数据总是放在最新的位置  设置数据(先查找数据是否存在,存在删除，然后将数据放在末尾,不存在直接插入末尾)。查询数据(先查找数据删除，然后将数据放在末尾)<br>LFU 缓存淘汰策略:Redis4.0后出现的，当A的使用频率要比B频繁，所以应该是淘汰B。","like_count":0},{"had_liked":false,"id":256585,"user_name":"拉布拉多","can_delete":false,"product_type":"c1","uid":1204353,"ip_address":"","ucode":"637A88D9F29F57","user_header":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","comment_is_top":false,"comment_ctime":1603684152,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603684152","product_id":100017301,"comment_content":"redis有序集合，没有去看源码：解决思路：看到分值区间查找就想到跳表。但是无法根据id查找用户信息。那hash表和跳表结合。且跳表第一层原始节点采用双向循环链表，另增加一个头节点(哨兵元素)指向这个双向循环链表的头节点。hash表和链表的指针结构和上面LRU算法思路一样。","like_count":0},{"had_liked":false,"id":256548,"user_name":"拉布拉多","can_delete":false,"product_type":"c1","uid":1204353,"ip_address":"","ucode":"637A88D9F29F57","user_header":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","comment_is_top":false,"comment_ctime":1603676111,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603676111","product_id":100017301,"comment_content":"改成每一个槽位的拉链为双向循环链表。这样是否比老师的要简单？缺点是：散列表中需要加入2个指针，就直接指向自己的双向循环链表？","like_count":0},{"had_liked":false,"id":251919,"user_name":"衬衫的价格是19美元","can_delete":false,"product_type":"c1","uid":1397631,"ip_address":"","ucode":"655F925451F772","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKVUskibDnhMt5MCIJ8227HWkeg2wEEyewps8GuWhWaY5fy7Ya56bu2ktMlxdla3K29Wqia9efCkWaQ/132","comment_is_top":false,"comment_ctime":1601973743,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601973743","product_id":100017301,"comment_content":"这么多的结构其实都可以用c语言里面的三个基本的元素只组成：数组、指针、结构体。<br>数组+结构体：队列、栈；<br>指针+结构体：链表；<br>链表改进：跳表、各种树；<br>链表+数组：散列表（哈希表);<br>链表+数组：lru策略","like_count":0},{"had_liked":false,"id":251661,"user_name":"hailowell","can_delete":false,"product_type":"c1","uid":1195572,"ip_address":"","ucode":"557DCAB01710AB","user_header":"","comment_is_top":false,"comment_ctime":1601778529,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601778529","product_id":100017301,"comment_content":"猎聘的这个问题，可以参考linkedHashmap，将猎头的信息存放到链表中，在Hash中使用猎头id存储链表中的node，这样可以根据id查找信息。然后存放链表时做一个归类，积分相同的放在一块并且按照积分从小到大放，然后将每一个积分区间的头节点拿出来记录和积分的关联关系。比如积分5有200个猎头，将这二百个猎头在链表中最前面的节点拿出来。这样就可以按照积分或者积分区间打印猎头列表了。而快速更新积分信息就是将找到更新后积分对应的节点，将猎头的节点放到这个节点之后，如果变动的就是积分节点本身，那么还需要处理一下对应关系","like_count":0},{"had_liked":false,"id":250897,"user_name":"youyou.L","can_delete":false,"product_type":"c1","uid":1796438,"ip_address":"","ucode":"B3DB0D0700EEAC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/zlWt0lPDicdib5BTUbuwA3wLLUuejtZ5icGu3DHMBPd6PicXOdhZ3zYFts8VkXjjyQuxzUJas2w5OTmx3icWKiaZM1Vg/132","comment_is_top":false,"comment_ctime":1601275174,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601275174","product_id":100017301,"comment_content":"思考题<br>1、按正常操作单链表来说，插入，删除时间复杂度都退化为O(n)，因为需要找前驱节点<br>2、以积分来排序构建跳表，实现积分区域查询；以ID为key，value为猎头对象构建散列表，实现O(1)的用ID插入，查询和删除操作<br>","like_count":0},{"had_liked":false,"id":246090,"user_name":"蚝不鱿鱼","can_delete":false,"product_type":"c1","uid":1428043,"ip_address":"","ucode":"5DB98E406F1D3E","user_header":"https://static001.geekbang.org/account/avatar/00/15/ca/4b/c1ace3aa.jpg","comment_is_top":false,"comment_ctime":1599176577,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599176577","product_id":100017301,"comment_content":"这课程看似通俗易懂，但想要吃透还是得每隔十天半个月再来温故一遍，必有新的收获，争大牛逼","like_count":0},{"had_liked":false,"id":244798,"user_name":"JerryZhu","can_delete":false,"product_type":"c1","uid":1591223,"ip_address":"","ucode":"76850CD45786C1","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","comment_is_top":false,"comment_ctime":1598682893,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598682893","product_id":100017301,"comment_content":"请问一下 github上面那个 LRU的实现， 是不是和老师讲的实现反过来的。  进来一个节点先加到 哨兵head的后面 也就是说作为首节点， 当长度超过设定最大容量 认为最久未使用是最后一个节点然后 移除tail的节点","like_count":0},{"had_liked":false,"id":242952,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1597901447,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597901447","product_id":100017301,"comment_content":"1 双向链表主要是方便找到前驱节点，实现快速删除。如果数据支持拷贝，单链表也是可以的，可以把其后继节点的数据拷贝到待删除节点，然后删除后继节点即可<br>2 按key散列，同时按score组织跳表","like_count":0},{"had_liked":false,"id":238247,"user_name":"对白","can_delete":false,"product_type":"c1","uid":1268797,"ip_address":"","ucode":"3183E5ADBC794B","user_header":"https://static001.geekbang.org/account/avatar/00/13/5c/3d/e8325811.jpg","comment_is_top":false,"comment_ctime":1596102218,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596102218","product_id":100017301,"comment_content":"课后思考的第一题：若改成散列表+单链表，则查找、插入的时间复杂度依然和散列表+双向链表一致，为O(1)，因为散列表在其中的作用就是实现O(1)量级的快速查找，而删除的时间复杂度变为了O(n)，因为散列表只能找到要删除的结点，前驱结点是不知道的，所以需要遍历一遍链表，因此为O(n)，而双向链表的前驱指针指向了前驱结点，所以不用遍历为O(1)，如果不对还请赐教。","like_count":0},{"had_liked":false,"id":236010,"user_name":"仅此而已","can_delete":false,"product_type":"c1","uid":1433801,"ip_address":"","ucode":"DF21DC1B3EE2FF","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/c9/46543f21.jpg","comment_is_top":false,"comment_ctime":1595290596,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595290596","product_id":100017301,"comment_content":"我想知道 ， 那个LRU 缓存淘汰算法 的图中的灰色箭头表示啥意思。","like_count":0},{"had_liked":false,"id":232678,"user_name":"Geek_dd8b2b","can_delete":false,"product_type":"c1","uid":1988075,"ip_address":"","ucode":"CBEF7C39075A96","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJX4ZU53F8hBHicctluqK6Ef3U0ib40bq1vFyAvqV0wu3GaPuWbj967OdMT7k0gl3OMxsfopvbk9veQ/132","comment_is_top":false,"comment_ctime":1594087112,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594087112","product_id":100017301,"comment_content":"<br>lru的实现，在其他地方看到过，感觉比老师这个简单。起码理解起来比较简单。<br><br>lru由一个双向链表，一个hashmap，hashmap存储缓存的数据key和其对应的链表节点索引。链表中存储的是数据和前后指针。<br>双向链表是按照访问时间和次数排序的链表。<br>查找和新增<br><br>如果访问a，查找a是否在hashmap这是O（1），不在就将其放到链表头部，并新增到hashmap，值为链表头部节点索引。在的话，就需要更新其链表的位置到头部，即取出其链表节点索引，然后取出链表头部哨兵节点，将原来的前后节点连接起来完成，将该节点作为新的头部。仍然是o（1）。查找和新增都是o（1）。要借助哨兵节点完成快速的插入头部节点。<br><br>删除呢，先查看map是否存在，不存在直接返回。存储的话，删除map里的该元素，并获取该元素对应的链表索引，获取其对应的前后索引，然后执行链表删除操作，也是o（1）。<br><br><br>","like_count":0},{"had_liked":false,"id":229865,"user_name":"wang.yu","can_delete":false,"product_type":"c1","uid":1516753,"ip_address":"","ucode":"871A0D7B4AECA2","user_header":"https://static001.geekbang.org/account/avatar/00/17/24/d1/a3933e71.jpg","comment_is_top":false,"comment_ctime":1593168947,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1593168947","product_id":100017301,"comment_content":"请问老师双向链表中的每个节点是否需要维护一个头节点和一个尾部节点呢","like_count":0,"discussions":[{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295942,"discussion_content":"双向链表的每个节点不需要维护，而是整个链表维护一个head和tail，每个节点维护的是before和next","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596386598,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225532,"user_name":"着迷","can_delete":false,"product_type":"c1","uid":1716801,"ip_address":"","ucode":"429F1D4015A195","user_header":"https://static001.geekbang.org/account/avatar/00/1a/32/41/c1a7840b.jpg","comment_is_top":false,"comment_ctime":1591779679,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591779679","product_id":100017301,"comment_content":"看懂了，牛逼、神奇、还是牛逼 。。。。","like_count":0},{"had_liked":false,"id":223823,"user_name":"3.141516","can_delete":false,"product_type":"c1","uid":1013309,"ip_address":"","ucode":"34AF71B02692F3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/76/3d/8120438b.jpg","comment_is_top":false,"comment_ctime":1591191630,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1591191630","product_id":100017301,"comment_content":"结合使用散列表（使用数组实现）和链表其实是结合了数组和链表的优势。","like_count":0},{"had_liked":false,"id":223183,"user_name":"GGL","can_delete":false,"product_type":"c1","uid":1215892,"ip_address":"","ucode":"AED10B8248D1E7","user_header":"https://static001.geekbang.org/account/avatar/00/12/8d/94/150dfe78.jpg","comment_is_top":false,"comment_ctime":1591016819,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591016819","product_id":100017301,"comment_content":"LRU缓存结构是借鉴散列表和双向链表数据结构形成的一套结构，不是简单的组合在一起，有些功能其实是可以优化，例如扩容操作；使用Swift实现的LRU缓存结构，有相应的测试代码以及结构打印，希望对大家有帮助。https:&#47;&#47;github.com&#47;gl-lei&#47;algorithm&#47;blob&#47;master&#47;HashTable&#47;LRUBaseHashTable.swift","like_count":0},{"had_liked":false,"id":222156,"user_name":"草原上的骆驼🐫","can_delete":false,"product_type":"c1","uid":1651618,"ip_address":"","ucode":"F0B12CB1FEED84","user_header":"https://static001.geekbang.org/account/avatar/00/19/33/a2/585be249.jpg","comment_is_top":false,"comment_ctime":1590708907,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590708907","product_id":100017301,"comment_content":"一直对老师文中含有hnext指针的哪个图理解不了","like_count":0},{"had_liked":false,"id":221004,"user_name":"韩小非","can_delete":false,"product_type":"c1","uid":1793722,"ip_address":"","ucode":"356FB7706A140E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJ9phBar24eEib1pXPtl6gYusmzBN7MI97cjsgJhiay5cU9IeX4gp8CoiaW7ql760BPOMYcPP1doK8QA/132","comment_is_top":false,"comment_ctime":1590377285,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590377285","product_id":100017301,"comment_content":"对双链表插入、删除或将一个节点移至最后不会影响散列表结构吗？<br><br>不会，这就相当于先将所有数据放入散列表之后，再使用一条双链表串起来。<br><br>无论是插入数据、删除数据、还是移动数据，只是修改串起来的顺序，不会影响散列表的结构。<br>","like_count":0},{"had_liked":false,"id":215442,"user_name":"艺比天高","can_delete":false,"product_type":"c1","uid":1282162,"ip_address":"","ucode":"F52AC257F834A2","user_header":"https://static001.geekbang.org/account/avatar/00/13/90/72/e17e7c61.jpg","comment_is_top":false,"comment_ctime":1588993076,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588993076","product_id":100017301,"comment_content":"第一题，换成单向链表中工作难度大大提高，这时删除节点的时候要从头遍历链表寻找上一个节点，时间复杂度无疑大大提高，但是其中最难的地方不在于这，因为一个散列表中有几个链表，我们这时我们该遍历哪个链表呢，所以寻找链表头节点难度系数太大","like_count":0},{"had_liked":false,"id":215151,"user_name":"Geek_ac7784","can_delete":false,"product_type":"c1","uid":1981613,"ip_address":"","ucode":"62F0E5E6D6F4BA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/8Dj4ugujXwY24G8pcpgDFGiciarXetG3ItQ4M9mSQMLyRdRRXEXXJVfib48mGUQAu87QcvImwyJIVJlEFeEguV44w/132","comment_is_top":false,"comment_ctime":1588916485,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588916485","product_id":100017301,"comment_content":"哈希表下:<br><br>1. 哈希表的链表法的数据结构，其实分为两部分，一部分是哈希表(数组)，另一部分是链表。<br>2. 链表杂乱无章，但是被哈希表中的指针指着。<br><br>LRU:<br><br>1. 先有双向链表，能完成LRU策略，但是查找太慢。<br>2. 再来一个哈希表，指向特定的链表节点。这样，链表节点要加一个指针指向同哈希值的下一个节点<br>3. 双向链表关系仍然完整存在，只是加了一个哈希表<br><br>Redis: key-score<br><br>1. 插入删除按分数查找（很快，分数有序，跳表实现），按分数排序<br>2. 按分数查找方便，按键值查找就不方便了。<br>3. 同样道理，通过键值，将节点放入哈希表，节点加一个hashnext指针<br>4. 所以Redis是跳表+哈希表<br><br>plus. 还有按排名查找(排名不是分数，当然可以按分数排序然后数数),随后再讲。<br><br>Java: 有hashmap，还有linkedhashmap，关系如何？<br><br>1. linkedhashmap可以设置按照时间排序，就是LRU缓存淘汰机制<br>2. linked指的是双向链表<br><br>哈希表与链表的关联主要是结合了顺序读取和快速定位(按值查询、删除、插入)的两个特性。这样，将节点先按顺序插到链表中，再将该节点放入哈希表中，或者反过来，就能做到顺序遍历+快速定位。<br><br>思考题:<br><br>1. 双链表插入、删除更方便，单链表也不是不行，综合考虑吧<br>2. 问题一:散列表；问题二:跳表索引。问题三:(排序后数数,我的想法，本文中提到后续会将)该问题就是Redis数据库吧","like_count":0},{"had_liked":false,"id":214396,"user_name":"李润东","can_delete":false,"product_type":"c1","uid":1972505,"ip_address":"","ucode":"65CFEA3C8B27C4","user_header":"https://static001.geekbang.org/account/avatar/00/1e/19/19/d82e24fb.jpg","comment_is_top":false,"comment_ctime":1588738917,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588738917","product_id":100017301,"comment_content":"“按照访问时间从大到小有序排列的链表结构“<br>这里感觉说反了吧，按照后面删头结点的做法，应该是按照访问时间从小到大（或者说从先到后）有序排列吧？","like_count":0},{"had_liked":false,"id":213960,"user_name":"陈小狮","can_delete":false,"product_type":"c1","uid":1458026,"ip_address":"","ucode":"7679BA5775DC9C","user_header":"https://static001.geekbang.org/account/avatar/00/16/3f/6a/e68b9f23.jpg","comment_is_top":false,"comment_ctime":1588600645,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588600645","product_id":100017301,"comment_content":"第一次看图的时候也没明白hnext指针，第二次看明白了。其实hnext是黑色箭头的线，双向链表的p指针和n指针是浅灰色箭头的线，一开始看太快看错了，因为平常看到的链表图就是水平的节点＋箭头，误把黑色箭头的线看成双向链表的前后指针了。当不同的key映射到同一个hash值时，就可以根据这个hnext指针找到所有相同hash(key)值的数据。","like_count":0},{"had_liked":false,"id":213419,"user_name":"你在不远的未来","can_delete":false,"product_type":"c1","uid":1318404,"ip_address":"","ucode":"5B34C8BD03B71A","user_header":"https://static001.geekbang.org/account/avatar/00/14/1e/04/f902047e.jpg","comment_is_top":false,"comment_ctime":1588409782,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588409782","product_id":100017301,"comment_content":"1.  双向单向都能实现，只是在对删除&#47;修改时双向更优，时间复杂度O（1）。单向删除&#47;修改必须重新获取前驱，以便完成操作。<br>2. 实现10w个猎头示例（object）<br>针对id，进行id构建跳表索引<br>针对积分，按照积分构建散列链表，积分分区规则对应桶分区规则，桶分区记录桶内链表数、桶积分上下限（便于排名），桶内链表按照桶积分为value桶内排序。<br><br>感觉还差了点，不知道行不行，老师。","like_count":0},{"had_liked":false,"id":212546,"user_name":"Jialin","can_delete":false,"product_type":"c1","uid":1112955,"ip_address":"","ucode":"12583269732A75","user_header":"https://static001.geekbang.org/account/avatar/00/10/fb/7b/2d4b38fb.jpg","comment_is_top":false,"comment_ctime":1588145547,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588145547","product_id":100017301,"comment_content":"为什么散列表和链表经常会一起使用？是考虑到散列表定位数据的时间复杂度为O(1)，但是数据无法保持某种顺序（插入顺序或访问顺序），而链表能够维持顺序性，但是它定位数据的时间复杂度为O(n)，所以将两者结合起来，可以实现快速定位和维持数据顺序","like_count":0},{"had_liked":false,"id":212477,"user_name":"isobelar","can_delete":false,"product_type":"c1","uid":1318394,"ip_address":"","ucode":"58CE4061984B43","user_header":"https://static001.geekbang.org/account/avatar/00/14/1d/fa/b81c89c3.jpg","comment_is_top":false,"comment_ctime":1588130659,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588130659","product_id":100017301,"comment_content":"课后思考<br>1.<br>单链表在删除一个元素时，虽然能 O(1) 的找到目标结点，但是要找到前一个结点的指针，则需要 O(N）时间复杂度。所以用双链表实现比较合适。<br><br>2.<br>以猎头 ID 构建一个散列表[{ID ：积分}]；再用积分先构建一个跳表，再用积分跳表和猎头 ID 数组构建一个复合散列表[{积分 : [ID数组]}]。<br>1）在散列表中可以 O(1) 时间复杂度查找、删除、更新猎头ID 对应的积分数据；<br>2）积分以跳表存储，跳表支持按区间查询；<br>3）使用快速排序法在 O(N) 时间复杂度内分别求出跳表中排名在第 x 位和第 y 位的积分大小，再通过复合散列表得到排名在第 x 位的积分到第 y 位的积分之间所有积分对应所有猎头 ID 数组中的 ID。","like_count":0},{"had_liked":false,"id":212454,"user_name":"Allan","can_delete":false,"product_type":"c1","uid":1310388,"ip_address":"","ucode":"8DA4DBECC2C45C","user_header":"https://static001.geekbang.org/account/avatar/00/13/fe/b4/295338e7.jpg","comment_is_top":false,"comment_ctime":1588126268,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588126268","product_id":100017301,"comment_content":"60天攻克算法打卡行动第17天<br><br>学习内容 : 散列表（下）：为什么散列表和链表经常会一起使用？<br><br>弄懂这三个例子，你就能掌握散列表和链表的结合方式，实现快速顺序遍历散列表中的数据，提高工作效率。<br><br>1.案例一：LRU 缓存淘汰算法<br>需要维护一个访问时间从大到小有序排列的链表结构，缓存不够时候直接将链表头部的结点删除。实现：散列表 + 双向链表 ，hnext指针是为了将结点串在散列表的拉链中。<br><br>2.案例二：Redis 有序集合<br>按照分值嫁给你成员对象组织成跳表的结构，再按照键值构建一个散列表。<br>3.案例三：Java LinkedHashMap<br>每次插入数据都会放到链表的尾部。通过双向链表和散列表这两种数据结构组合实现的。LinkedHashMap中的“linked”实际上是指的双向链表，并非指用链表法解决散列冲突。<br><br>双向表改成单链表只有后继显然不行查找数据复杂度就高了。<br>猎头存放，散列表存放分数，再加双向链表存放对应的猎头id。","like_count":0},{"had_liked":false,"id":212333,"user_name":"拉普达","can_delete":false,"product_type":"c1","uid":1930686,"ip_address":"","ucode":"0E524C0D99B2A0","user_header":"https://static001.geekbang.org/account/avatar/00/1d/75/be/6f3ab95e.jpg","comment_is_top":false,"comment_ctime":1588087116,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588087116","product_id":100017301,"comment_content":"使用散列表和有序双向跳表链表结合，双向跳表链表以积分大小排序，有数据更新操作，需要维护链表使其有序。也可用哈希表和二叉树实现","like_count":0},{"had_liked":false,"id":212009,"user_name":"默默","can_delete":false,"product_type":"c1","uid":1006635,"ip_address":"","ucode":"AF798B9D327F24","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/2b/8b771383.jpg","comment_is_top":false,"comment_ctime":1588045608,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588045608","product_id":100017301,"comment_content":"问题一：用单链表+单链表组合的方式。在查找、插入时，时间复杂度不变。在删除时，由于删除操作需要定位删除结点的上一个结点，单链表只能从头开始遍历才能获得上一节点信息，所以时间复杂度为退为O(n)。<br>问题二：通过散列表+跳表的组合可以解决1和2操作。以用户ID为key散列到散列表中，以用户的积分排序形成一个跳表，按ID查询、删除、插入是通过散列表直接查询，时间复杂度为O(1)。插入积分在某个区间段ID列表时，通过散列表找到区间开始位置对应的积分结点，顺序往后取，直到积分大于区间，时间复杂度为O(logn)。按排名区间查找，还不清楚怎么解决。","like_count":0},{"had_liked":false,"id":210700,"user_name":"鱼丸粗面","can_delete":false,"product_type":"c1","uid":1785016,"ip_address":"","ucode":"B2F3F75B0D1422","user_header":"https://static001.geekbang.org/account/avatar/00/1b/3c/b8/9489387c.jpg","comment_is_top":false,"comment_ctime":1587810245,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587810245","product_id":100017301,"comment_content":"需要自己模仿redis实现一个hset，就可以完美解决猎头问题","like_count":0},{"had_liked":false,"id":210405,"user_name":"soulful","can_delete":false,"product_type":"c1","uid":1240490,"ip_address":"","ucode":"93105631E8106A","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/aa/67fbccda.jpg","comment_is_top":false,"comment_ctime":1587738684,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587738684","product_id":100017301,"comment_content":"不理解为什么使用散列表+双向链表之后，插入、删除、查找的时间复杂度都变为O(1)<br><br>以删除为例，通过散列表只能查到对应的槽位，并没有找到要删除的节点啊，要想找到对应的节点，还是得遍历与槽位对应的双向链表，一遍历就O(n)了呀<br><br>谁能解答一下呢？","like_count":0},{"had_liked":false,"id":208782,"user_name":"Chloe","can_delete":false,"product_type":"c1","uid":1004953,"ip_address":"","ucode":"C4848ED5B35752","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/99/4bdadfd3.jpg","comment_is_top":false,"comment_ctime":1587437776,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587437776","product_id":100017301,"comment_content":"请问LRU的Java实现是这里吗： https:&#47;&#47;github.com&#47;wangzheng0822&#47;algo&#47;blob&#47;master&#47;java&#47;20_hashtable&#47;LRUBaseHashTable.java？ 为什么没有看到hnext的定义？谢谢！","like_count":0},{"had_liked":false,"id":207685,"user_name":"简单猫","can_delete":false,"product_type":"c1","uid":1866485,"ip_address":"","ucode":"EA027D4C344E25","user_header":"https://static001.geekbang.org/account/avatar/00/1c/7a/f5/54a5084b.jpg","comment_is_top":false,"comment_ctime":1587136733,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587136733","product_id":100017301,"comment_content":"一：改成单链 只有next指针  ，散列表中 hnext指向巢中结点 该结点丢失上一结点指针，造成插入和删除操作无法正常使用。单链表插入操作 实际复杂度=找到该结点的复杂度O(n&#47;2)＋插入操作复杂度O(1) ，O(n)。散列插入时间复杂度=常熟级O(1) ＋双链表插入时间复杂度O(1)，总复杂度O(1)。<br>二：10万猎头 散列表存键值O(1)，积分用桶算法来，桶内二分法。时间复杂度O(1)","like_count":0},{"had_liked":false,"id":206658,"user_name":"梅端","can_delete":false,"product_type":"c1","uid":1525335,"ip_address":"","ucode":"FEC08731457770","user_header":"https://static001.geekbang.org/account/avatar/00/17/46/57/fe38a6db.jpg","comment_is_top":false,"comment_ctime":1586914402,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586914402","product_id":100017301,"comment_content":"重复是学习之父，是时候回过头看看各种类型的链表和其特点了。","like_count":0},{"had_liked":false,"id":205991,"user_name":"王jojo","can_delete":false,"product_type":"c1","uid":1812840,"ip_address":"","ucode":"1ABE7FA2614F86","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/68/ec442a70.jpg","comment_is_top":false,"comment_ctime":1586769861,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586769861","product_id":100017301,"comment_content":"老师,我看了评论还是不明白hnext的作用, 因为一般来说使用链表的散列表不是已经解决了冲突了么?查了一些其他散列表+双向链表的实现也没有这个hnext. 这个属性是用在哪里了呀,属于优化的么?","like_count":0},{"had_liked":false,"id":205963,"user_name":"王jojo","can_delete":false,"product_type":"c1","uid":1812840,"ip_address":"","ucode":"1ABE7FA2614F86","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/68/ec442a70.jpg","comment_is_top":false,"comment_ctime":1586764441,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586764441","product_id":100017301,"comment_content":"问一下,看下来感觉这个hnext没有体现作用,请指教啦","like_count":0},{"had_liked":false,"id":202487,"user_name":"zack","can_delete":false,"product_type":"c1","uid":1061161,"ip_address":"","ucode":"DC5E2354E0EC78","user_header":"https://static001.geekbang.org/account/avatar/00/10/31/29/44b9e36a.jpg","comment_is_top":false,"comment_ctime":1585995471,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585995471","product_id":100017301,"comment_content":"请问下 散列表后面怎么接跳表~","like_count":0},{"had_liked":false,"id":202229,"user_name":"Geek_9d40b1","can_delete":false,"product_type":"c1","uid":1936806,"ip_address":"","ucode":"4AAD469A956F61","user_header":"","comment_is_top":false,"comment_ctime":1585927520,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585927520","product_id":100017301,"comment_content":"对于Lru那里，说一下我的理解，这里是针对使用链表设计的Lru算法来说，之前是单链表来设计的，可以实现，不过，查找这个操作就很慢，怎么解决呢，我们就对单链表里面的这些数据进行散列，这些数据，既保持了原有的链表结构，我们又给他分配了散列结构，这样就实现了各种操作都是O(1)的性能。","like_count":0},{"had_liked":false,"id":202188,"user_name":"青山不改绿水长流","can_delete":false,"product_type":"c1","uid":1800406,"ip_address":"","ucode":"A2F094618F569A","user_header":"https://static001.geekbang.org/account/avatar/00/1b/78/d6/c920f2a8.jpg","comment_is_top":false,"comment_ctime":1585918621,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585918621","product_id":100017301,"comment_content":"双向链表，删除为何是O（1）时间复杂度","like_count":0},{"had_liked":false,"id":201434,"user_name":"曾轼麟","can_delete":false,"product_type":"c1","uid":1451391,"ip_address":"","ucode":"D418371AC11270","user_header":"https://static001.geekbang.org/account/avatar/00/16/25/7f/473d5a77.jpg","comment_is_top":false,"comment_ctime":1585788688,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585788688","product_id":100017301,"comment_content":"老师能否讲一下LFU O(1)时间复杂度的实现，空间没有限制，这道题在leetCode上面困扰了我很久","like_count":0},{"had_liked":false,"id":200248,"user_name":"4567890","can_delete":false,"product_type":"c1","uid":1133055,"ip_address":"","ucode":"23BC97FD1DADF0","user_header":"https://static001.geekbang.org/account/avatar/00/11/49/ff/34a47dca.jpg","comment_is_top":false,"comment_ctime":1585562740,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585562740","product_id":100017301,"comment_content":"是不是可以概括为：这个设计，是在单纯用链表实现LRU缓存的基础上，给缓存的查找进行了加速~~~<br>也有点类似于Java中的多态了~~集合了多种数据结构的优点~~~<br>那，有没有多个跳表同时使用的时候呢？比如，要也按单科的分数区间段取，也要按排名区间段取，然后两者都用跳表来实现连续获取的加速？<br>","like_count":0},{"had_liked":false,"id":198617,"user_name":"zhimin","can_delete":false,"product_type":"c1","uid":1312130,"ip_address":"","ucode":"DF6DFBEF6FA297","user_header":"https://static001.geekbang.org/account/avatar/00/14/05/82/51cd0a50.jpg","comment_is_top":false,"comment_ctime":1585460056,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585460056","product_id":100017301,"comment_content":"单链表应该是可以的，就是每次存储一下上一个节点，判断下一个是否是要存储的数据。 空间复杂度o(1), 通过散列表找到对应的元素，只是冲突部分o(n). <br>2 直接用redis的 有序集合来实现即 hashtable + 跳表的模式。<br>","like_count":0},{"had_liked":false,"id":190814,"user_name":"小谢","can_delete":false,"product_type":"c1","uid":1879476,"ip_address":"","ucode":"82D54A61D2FDB9","user_header":"https://static001.geekbang.org/account/avatar/00/1c/ad/b4/e4dcd4d7.jpg","comment_is_top":false,"comment_ctime":1584695324,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1584695324","product_id":100017301,"comment_content":"经过这一章的学习深感数据结构之间的互相关联耦合真的是一个很考验基础的事情","like_count":0,"discussions":[{"author":{"id":1133055,"avatar":"https://static001.geekbang.org/account/avatar/00/11/49/ff/34a47dca.jpg","nickname":"4567890","note":"","ucode":"23BC97FD1DADF0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217471,"discussion_content":"对的呀~~\n就得前提是很多基础的东西都滚瓜烂熟了~~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585563142,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190716,"user_name":"SteelHuaSheng","can_delete":false,"product_type":"c1","uid":1396126,"ip_address":"","ucode":"BC8127FC5207FC","user_header":"https://static001.geekbang.org/account/avatar/00/15/4d/9e/04ec08bf.jpg","comment_is_top":false,"comment_ctime":1584686647,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584686647","product_id":100017301,"comment_content":"感觉这节看的有点吃力了。我要复习下前面的内容，把这几课的内容再多看几遍","like_count":0},{"had_liked":false,"id":186042,"user_name":"Simple life","can_delete":false,"product_type":"c1","uid":1571460,"ip_address":"","ucode":"1902D7F72FB43F","user_header":"https://static001.geekbang.org/account/avatar/00/17/fa/84/f01d203a.jpg","comment_is_top":false,"comment_ctime":1583745776,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1583745776","product_id":100017301,"comment_content":"我感觉你说反了，hnext是双向链表，用来维护数据的顺序的，另一个链表是map里面解决冲突的链地址法的链表，你上面的意思反了","like_count":0,"discussions":[{"author":{"id":1133055,"avatar":"https://static001.geekbang.org/account/avatar/00/11/49/ff/34a47dca.jpg","nickname":"4567890","note":"","ucode":"23BC97FD1DADF0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217473,"discussion_content":"应该没有说反~~双向链表的双向肯定是用在LRU cache的 要求上的，因为这个是一个全部长度的链儿，删除的时候需要获取要删除的节点的前驱节点和后继节点，然后将二者拼接上，如果不是双向链表的话，那么这个的操作的时间复杂度会比较高~~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585563277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185155,"user_name":"俺能学个啥","can_delete":false,"product_type":"c1","uid":1026742,"ip_address":"","ucode":"30740C5B58774C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/aa/b6/46a5bbf3.jpg","comment_is_top":false,"comment_ctime":1583499942,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583499942","product_id":100017301,"comment_content":"1、单链表因为只有后继指针，导致在执行删除操作遍历时需要保存一下前驱结点，所以也可以工作<br>2、通过猎头ID构建散列表，通过积分信息构建跳表。通过猎头ID可以以O(1)时间复杂度快速查找、更新、删除；可以通过跳表的特性查到某个区间信息","like_count":0},{"had_liked":false,"id":184625,"user_name":"起而行","can_delete":false,"product_type":"c1","uid":1131399,"ip_address":"","ucode":"4F116B0B740776","user_header":"https://static001.geekbang.org/account/avatar/00/11/43/87/7604d7a4.jpg","comment_is_top":false,"comment_ctime":1583373896,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1583373896","product_id":100017301,"comment_content":"第一个问题是可以的，只是LRU的删除操作需要重头遍历链表，时间复杂度涨为On。<br>第二个问题，链表加散列表。插入删除更新，时间复杂度为o1,按积分范围查找ID,首先通过链表定位到范围的上界，遍历到下界，通过散列函数反推key，输出。从小到大输出ID的话，只需记住链表要顺序打印","like_count":0},{"had_liked":false,"id":184372,"user_name":"lpf32","can_delete":false,"product_type":"c1","uid":1039717,"ip_address":"","ucode":"E1B127FDFF74BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/dd/65/3b4a2930.jpg","comment_is_top":false,"comment_ctime":1583301400,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583301400","product_id":100017301,"comment_content":"以积分做skip list，用猎头ID做hash，实现 LinkedHashMap","like_count":0},{"had_liked":false,"id":184337,"user_name":"发霉的宅大人","can_delete":false,"product_type":"c1","uid":1738243,"ip_address":"","ucode":"6757E30FE5E48D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/03/95004954.jpg","comment_is_top":false,"comment_ctime":1583292802,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583292802","product_id":100017301,"comment_content":"第二遍复习总结：<br>1、散列表：快速查找，插入，删除（需要连续的空间支持下标访问）<br>2、链表：利用碎片空间，线性查找，<br>链表延伸下去<br>跳表——范围查找插入删除查找。<br>红黑树——快速插入删除查找。<br>散列表和链表结合就是将1、数组的随机访问和2、链表的线性查找访问排序，节省空间结合在一起。","like_count":0},{"had_liked":false,"id":173629,"user_name":"pikachu122","can_delete":false,"product_type":"c1","uid":1689365,"ip_address":"","ucode":"43FE4DBC872FFA","user_header":"https://static001.geekbang.org/account/avatar/00/19/c7/15/24bf166a.jpg","comment_is_top":false,"comment_ctime":1579622176,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579622176","product_id":100017301,"comment_content":"1、散列表与链表经常结合在一起使用。例如链表实现的LRU缓存淘汰算法通过散列表将时间复杂度由O(n)降低到O(1)。Redis中的有序集合也结合了跳表和散列表，还有Java中的LinkedHashMap等等。<br>2、对于LRU缓存淘汰算法，它是一个散列表和一个双向链表的组合。双向链表中每个节点除了数据、前驱指针、后继指针外，还有一个指向散列表拉链中后一个节点的指针。这样，利用散列表可以在O(1)时间复杂度内查找到数据，而删除、插入数据的其他操作都可以在O(1)时间复杂度内完成，因此这三个操作都可以保证时间复杂度为O(1)。<br>3、Java中的LinkedHashMap支持按照数据插入和访问的顺序进行遍历。每次操作后，被 操作的元素都被放置到链表的尾部。Linked指的是双向链表，并不是指用链表法解决散列冲突。<br>4、散列表的缺点是无序存储，如果需要按一定顺序遍历必须先排序，如果引入链表或者跳表结合到散列表中，就可以按照一定的顺序遍历所有元素。","like_count":0},{"had_liked":false,"id":173218,"user_name":"搬铁少年ai","can_delete":false,"product_type":"c1","uid":1031045,"ip_address":"","ucode":"01D4A830A088D7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bb/85/191eea69.jpg","comment_is_top":false,"comment_ctime":1579480747,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579480747","product_id":100017301,"comment_content":"如果是一个单独的哈希表配合一个单独的链表呢？哈西表里面存放链表节点的指针","like_count":0},{"had_liked":false,"id":172900,"user_name":"花晨少年","can_delete":false,"product_type":"c1","uid":1098987,"ip_address":"","ucode":"6AA3537A6BA10E","user_header":"https://static001.geekbang.org/account/avatar/00/10/c4/eb/2285a345.jpg","comment_is_top":false,"comment_ctime":1579354330,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579354330","product_id":100017301,"comment_content":"第一张图中说的散列表值得是一个完整的hashmap，还是只是一个数组？如果只是一个数组，肯定需要hnext指针。但是图中写的是散列表，那冲突问题内部就已经解决了，根本不需要程序员关心。","like_count":0},{"had_liked":false,"id":172894,"user_name":"花晨少年","can_delete":false,"product_type":"c1","uid":1098987,"ip_address":"","ucode":"6AA3537A6BA10E","user_header":"https://static001.geekbang.org/account/avatar/00/10/c4/eb/2285a345.jpg","comment_is_top":false,"comment_ctime":1579353795,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1579353795","product_id":100017301,"comment_content":"为什么需要hnext指针？根本就不需要啊。<br>散列表内部已经解决冲突了，根部不需要外部关注，hash的value直接存双向链表节点的地址就行了","like_count":0,"discussions":[{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296096,"discussion_content":"hnext指得是散列表中的链表指针","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596451061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169302,"user_name":"杰瑞的Jerry","can_delete":false,"product_type":"c1","uid":1690017,"ip_address":"","ucode":"5FBF22B528B721","user_header":"https://static001.geekbang.org/account/avatar/00/19/c9/a1/24c2e54e.jpg","comment_is_top":false,"comment_ctime":1578310501,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1578310501","product_id":100017301,"comment_content":"学完本节打卡：<br><br>散列表和链表经常一起使用。<br>LRU缓存淘汰算法：采用散列表加上双向链表完成。散列表用来查找，双向链表用来记录数据的访问频繁程度。通过两者结合，可以把缓存的插入、删除、查找三种操作的时间复杂度都降为O(1)。<br>Redis有序集合：按照键值构造一个散列表，将删除和查找的时间复杂度变成O(1)，然后借助跳表，把其他操作也变得高效。<br>Java LinkedHashMap：通过散列表和链表组合在一起，不仅支持按照插入顺序遍历数据，还支持按照访问顺序来遍历数据。","like_count":0},{"had_liked":false,"id":169238,"user_name":"Richie","can_delete":false,"product_type":"c1","uid":1019588,"ip_address":"","ucode":"12314EF0347693","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/c4/8d1150f3.jpg","comment_is_top":false,"comment_ctime":1578299368,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578299368","product_id":100017301,"comment_content":"要设计高效的数据结构，首先分析下需要支持哪些操作，然后再根据具体的操作去选择高效的底层数据结构做支持，将那些经典的数据结构组合起来灵活配合使用，就能实现我们业务系统中所需的高效的数据结构和算法。<br>很多时候我们都需要组合多种数据结构，才能实现符合业务系统需求的数据结构，这其实也是一种以空间换时间的思想。","like_count":0},{"had_liked":false,"id":168824,"user_name":"马哲富","can_delete":false,"product_type":"c1","uid":1107917,"ip_address":"","ucode":"D6BDDFE3CC07ED","user_header":"https://static001.geekbang.org/account/avatar/00/10/e7/cd/08088f14.jpg","comment_is_top":false,"comment_ctime":1578193501,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578193501","product_id":100017301,"comment_content":"老师好，这些数据结构是底层操作系统提供的吗？比如数组，单项链表，双向链表，循环链表，还有今天讲的这种散列表加上双向链表，有点儿疑惑，望解答，谢谢！","like_count":0},{"had_liked":false,"id":167314,"user_name":"青山","can_delete":false,"product_type":"c1","uid":1131070,"ip_address":"","ucode":"749BAD1834AC0F","user_header":"https://static001.geekbang.org/account/avatar/00/11/42/3e/c1f76202.jpg","comment_is_top":false,"comment_ctime":1577761274,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1577761274","product_id":100017301,"comment_content":"我想问一下:&quot;当找到数据之后，我们还需要将它移动到双向链表的尾部。&quot;,为什么要移动到双向链表的尾部?我思想没拐过这个弯","like_count":0},{"had_liked":false,"id":165921,"user_name":"梦幻的星空","can_delete":false,"product_type":"c1","uid":1526058,"ip_address":"","ucode":"FACC1AE8994DEA","user_header":"https://static001.geekbang.org/account/avatar/00/17/49/2a/e1c914c9.jpg","comment_is_top":false,"comment_ctime":1577345504,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577345504","product_id":100017301,"comment_content":"LRU这个一开始看图片误以为是使用一个【散列表+双向链表】的复合结构(即使用双向链表来解决冲突)来存储缓存数据，然后一直纠结为什么是双向链表而不是单向链表，毕竟删除数据时，从数据到对应节点都是【数据--》散列函数获取散列表相应位置--》遍历由hnext组成的单向链表获取到节点然后删除】。<br>后面看了很多留言突然意识到其实散列表和双向链表是两个独立的结构或者说对象，缓存数据存储在双向链表，而散列表相当于是对双向链表查找数据做了进一步的优化，因此删除数据的步骤应该是【数据--》散列函数获取散列表相应位置--》遍历由hnext组成的单向链表获取到节点--》在双向链表中将数据删除】。<br>而且我一开始理解为缓存数据保存在散列表中还有一个本质上的错误，就是散列表没法清楚表达所有数据的时间大小关系。因此缓存数据最好保存在可以直观表达顺序的数据结构中，以便于维护缓存数据之间的时间关系，而为了保持这个结构的完整性，缓存数据的增删也需要在这个结构上进行。","like_count":0},{"had_liked":false,"id":164632,"user_name":"注定非凡","can_delete":false,"product_type":"c1","uid":1113597,"ip_address":"","ucode":"80673056E131B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","comment_is_top":false,"comment_ctime":1577063348,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1577063348","product_id":100017301,"comment_content":"（1）常见使用场景：<br>》1：LRU缓存淘汰算法，可以用链表来实现，但时间复杂度是O(n)，可以通过散列表将时间复杂度降低到O(1)。<br>》2：Redis的有序集合不仅使用到了跳表，还用到了散列表。<br>》3：LinkedHashMap也是用散列表和链表两种数据结构<br>\t\t<br>\t（2）LRU缓存淘汰算法<br>\t\t①：链表实现LRU缓存淘汰算法方式：<br>1）：维护一个按照访问时间从大到小有序排列的链表结构。当缓存空间不够时，就直接将链表头部的结点删除。<br>2）：当要缓存某个数据时，先在链表中查找这个数据，若没有找到，则直接将数据放到链表的尾部；如果找到了，就把它移动到链表的尾部。<br>3）：因为查找数据需要遍历链表，所以单纯用链表实现的LRU缓存淘汰算法的时间复杂度很高,是O(n)。<br>\t\t<br>\t\t②：缓存系统主要的操作：<br>\t\t\t1）：往缓存中添加一个数据<br>\t\t\t2）：从缓存中删除一个数据<br>\t\t\t3)：在缓存中查找一个数据<br>这三个操作都要涉及“查找”操作，如果单纯的采用链表，时间复杂度只能是O(n)。如果将散列表和链表两种数据结构组合使用，可以将这三个操作的时间复杂度都降低到O(1)。<br>\t\t<br>\t\t③：数据结构分析：<br> <br><br>1）：使用双向链表存储数据，链表中的每个结点处理存储数据（data）,前驱指针（prev），后继指针（next）之外，还新增了一个特殊的字段hnext。<br>2）：散列表是通过链表法解决散列冲突的，所以每个结点会在两条链中。一个链是存储数据的双向链表，另一个散列表中的拉链。前驱和后继指针是为了将结点串在双向链表中，hnext指针是为了将结点串在散列表的拉链中。<br>\t<br>\t\t④：操作：<br>查找一个数据：散列表中查找数据的时间复杂度接近O(1)，通过散列表可以很快找到一个数据。<br>删除一个数据：因为双向链表可以通过前驱指针O(1)时间复杂度获取前驱节点，所以双向链表中，删除结点只需要O(1)的时间复杂度。<br>添加一个数据：首先确认缓存中是否有这个数据，如果有就将其移动至链表尾部，如果没有，要先看缓存是否已满，如果满了，则将双向链表头部的结点删除，然后在将数据放到链表的尾部；如果没满，就直接将数据放到链表的尾部。<br><br>\t（3）Redis有序集合<br>\t\t①：有序集合常用操作：<br>\t\t\t1）：添加一个成员对象<br>\t\t\t2）：按照键值来删除一个成员对象<br>\t\t\t3）：按照键值查找一个成员对象<br>\t\t\t4）：按照分值区间查找数据，<br>\t\t\t5）：按照分值从大到小排序成员变量<br>\t\t<br>②：若仅按照分值将成员对象组织成跳表结构，则按照键值来删除，查询成员对象就会很慢，解决方法于LRU缓存淘汰算法的解法方法类似。可以在按照键值构建一个散列表，这样按照key来删除，查找一个成员对象的时间复杂度就变成了O(1)。同时，借助跳表结构，其他操作也非常高效。<br><br>\t（4）Java LinkedHashMap<br>①：HashMap的底层是通过散列表这种数据结构实现的。而LinkedHashMap前面比HashMap多了一个“Linked”,但这并不能说LinkedHashMap是一个通过链表法解决冲突的散列表。<br>②：LinkedHashMap也是通过散列表和链表组合在一起实现的，他不仅支持按照插入顺序遍历数据，还支持按照访问顺序来遍历数据。<br>③：按照访问时间排序的LinkedHashMap本身就是一个支持LRU缓存淘汰策略的缓存系统。<br>④：LinkedHashMap是通过双向链表和散列表这两种数据结构组合实现的。LinkedHashMap中的“Linded”实际是指双向链表，而非指用链表解决散列冲突。<br><br>\t（5）总结：<br>\t\t散列表虽然支持高效的数据插入，删除，查找，但其中的数据都是通过散列函数打乱后无规律存储的。无法按照某种顺序快速遍历数据。<br>\t\t如果希望按照顺序遍历散列表中的数据，需要将散列表中的数据拷贝到数组中，在排序，遍历。<br>\t\t散列表的动态变化，使得每当希望按照顺序遍历散列表中数据都需要先排序，效率很低，所以，将散列表和链表（或跳表）结合在一起使用，提高效率。<br><br>","like_count":0},{"had_liked":false,"id":162648,"user_name":"William","can_delete":false,"product_type":"c1","uid":1346215,"ip_address":"","ucode":"55F5D9DEE485B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","comment_is_top":false,"comment_ctime":1576572930,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576572930","product_id":100017301,"comment_content":"“前驱和后继指针是为了将结点串在双向链表中，hnext 指针是为了将结点串在散列表的拉链中。”<br><br>我的理解是:  hash冲突了, 那么使用hnext来指向同一个hash下的链表串联关系.  <br><br>然后: 整体的节点的顺序关系是用(pre、next 前后指针)双向链表来保证的串联起来. <br><br>按照图中的就是 :<br>     第2个链表的第1个节点<br>        -&gt;指向第2行的第1个节点<br>        -&gt;指向第2行的第二个节点<br>        -&gt;指向第3行的第一个节点 <br>        -&gt;指向第4行的第1个节点<br>        -&gt; 指向第2行的第三个节点 <br>        -&gt;指向 第1行的第二个节点,  <br>整个双向链表的情况如上描述. ","like_count":0},{"had_liked":false,"id":162600,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1576563233,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576563233","product_id":100017301,"comment_content":"散列表提供了一个高效查询的服务，但是其包含的元素是无序的，如果应用场景既要求高速查询，又要以某些顺序添加，删除，遍历，链表就是提供顺序的载体。如果还需要其他特殊的顺序，栈，队列和堆也能提供各自的顺序。","like_count":0},{"had_liked":false,"id":162055,"user_name":"大海","can_delete":false,"product_type":"c1","uid":1001446,"ip_address":"","ucode":"20913D0265971B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/47/e6/67b0b711.jpg","comment_is_top":false,"comment_ctime":1576457013,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576457013","product_id":100017301,"comment_content":"思考题这里换成单向链表是不行的","like_count":0},{"had_liked":false,"id":161764,"user_name":"胡家鹏","can_delete":false,"product_type":"c1","uid":1109940,"ip_address":"","ucode":"1636F84062948B","user_header":"https://static001.geekbang.org/account/avatar/00/10/ef/b4/61fb4dba.jpg","comment_is_top":false,"comment_ctime":1576319550,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576319550","product_id":100017301,"comment_content":"LRU缓存中使用散列表和双向链表组合，删除双向链表一个头结点时，是不是还要删除散列表拉链中的对应节点？也就是要找到拉链中当前结点前一个结点，让前一个结点hnext指针指向下一个结点？","like_count":0},{"had_liked":false,"id":161641,"user_name":"Jun","can_delete":false,"product_type":"c1","uid":1120678,"ip_address":"","ucode":"0FAB76D99153ED","user_header":"https://static001.geekbang.org/account/avatar/00/11/19/a6/7ae63d7e.jpg","comment_is_top":false,"comment_ctime":1576283808,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576283808","product_id":100017301,"comment_content":"Lru实现还需要维护双向链表的头尾指针，尽管也是o(1)操作。有空手撸一下","like_count":0},{"had_liked":false,"id":161431,"user_name":"Panda🐟","can_delete":false,"product_type":"c1","uid":1002401,"ip_address":"","ucode":"C6007A3192516A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4b/a1/c2719a5a.jpg","comment_is_top":false,"comment_ctime":1576204977,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576204977","product_id":100017301,"comment_content":"1. 不能，通过hash找到元素后，删除和移动都需要获取其前驱节点，单链表获取前驱节点需要遍历链表复杂度为O(n)<br>2. 哈希表+跳表","like_count":0},{"had_liked":false,"id":161402,"user_name":"SteveYang","can_delete":false,"product_type":"c1","uid":1754829,"ip_address":"","ucode":"C42BCA4F40A9EF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKCbnOvEatUN4ysE2cl6zJNoAJVXXuQVhicQ1jxh6Z2Towrmmc1I6PndaicuQQ0RyyJPyJQicv4tSib9Q/132","comment_is_top":false,"comment_ctime":1576201716,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576201716","product_id":100017301,"comment_content":"1.改成单链表可以实现不过在删除的时候需要找到前继结点就比较麻烦。<br>2.id用散列表，按id查询就比较快，积分用跳表，可以进行区间查询。","like_count":0},{"had_liked":false,"id":161220,"user_name":"weineel","can_delete":false,"product_type":"c1","uid":1049741,"ip_address":"","ucode":"6DC6EF4F256A53","user_header":"https://static001.geekbang.org/account/avatar/00/10/04/8d/005c2ff3.jpg","comment_is_top":false,"comment_ctime":1576150231,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1576150231","product_id":100017301,"comment_content":"链表中的 data段可以只存引用，可以有多个链表分别存储不同字段的排序序列（构成了索引）。链表和散列变的组合，可以同时具备数组和链表的优点。","like_count":0},{"had_liked":false,"id":161092,"user_name":"港","can_delete":false,"product_type":"c1","uid":1122464,"ip_address":"","ucode":"35931FC6198180","user_header":"https://static001.geekbang.org/account/avatar/00/11/20/a0/1fca96c0.jpg","comment_is_top":false,"comment_ctime":1576117361,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576117361","product_id":100017301,"comment_content":"1. 改成单链表之后用散列表找到该节点之后，可以找到后继节点，但是无法找到前驱节点，删除操作将无法进行或者时间复杂度变为O(n)<br>2. 按照积分排序构建跳表，按照ID构建散列表。此时按照ID查找删除更新的时间复杂度为O(1)，按照查找积分区间为O(logn)，查找x到y位为O(n)<br>","like_count":0},{"had_liked":false,"id":160766,"user_name":"梦想的优惠券","can_delete":false,"product_type":"c1","uid":1257418,"ip_address":"","ucode":"D3B44F6C618CA7","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/ca/cbce6e94.jpg","comment_is_top":false,"comment_ctime":1576030456,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1576030456","product_id":100017301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":160542,"user_name":"ub8","can_delete":false,"product_type":"c1","uid":1481811,"ip_address":"","ucode":"0D937C3EAEB781","user_header":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","comment_is_top":false,"comment_ctime":1575971715,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575971715","product_id":100017301,"comment_content":"linkedHashMap 本来就是一种LRU的实现","like_count":0},{"had_liked":false,"id":160192,"user_name":"梨子苹果","can_delete":false,"product_type":"c1","uid":1716067,"ip_address":"","ucode":"3666813FEE31D3","user_header":"https://static001.geekbang.org/account/avatar/00/1a/2f/63/7a048d46.jpg","comment_is_top":false,"comment_ctime":1575888882,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575888882","product_id":100017301,"comment_content":"zset那个是单链表吧","like_count":0},{"had_liked":false,"id":159148,"user_name":"洲","can_delete":false,"product_type":"c1","uid":1712154,"ip_address":"","ucode":"64D9334933C987","user_header":"https://static001.geekbang.org/account/avatar/00/1a/20/1a/9aaf5638.jpg","comment_is_top":false,"comment_ctime":1575548337,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575548337","product_id":100017301,"comment_content":"看了sqlite数据库的源代码，其页缓存就是利用HASH表+双向链表实现的LRU实现的。<br>struct PgHdr1 {<br>  sqlite3_pcache_page page;      &#47;* Base class. Must be first. pBuf &amp; pExtra *&#47;<br>  unsigned int iKey;             &#47;* Key value (page number) *&#47;<br>  u16 isBulkLocal;               &#47;* This page from bulk local storage *&#47;<br>  u16 isAnchor;                  &#47;* This is the PGroup.lru element *&#47;<br>  PgHdr1 *pNext;                 &#47;* Next in hash table chain *&#47;<br>  PCache1 *pCache;               &#47;* Cache that currently owns this page *&#47;<br>  PgHdr1 *pLruNext;              &#47;* Next in LRU list of unpinned pages *&#47;<br>  PgHdr1 *pLruPrev;              &#47;* Previous in LRU list of unpinned pages *&#47;<br>                                 &#47;* NB: pLruPrev is only valid if pLruNext!=0 *&#47;<br>};","like_count":0},{"had_liked":false,"id":158891,"user_name":"百里","can_delete":false,"product_type":"c1","uid":1212873,"ip_address":"","ucode":"2CE96129AA7F78","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/c9/9194612b.jpg","comment_is_top":false,"comment_ctime":1575471362,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575471362","product_id":100017301,"comment_content":"第一题: 如果双向链表改为单链表<br>1. 对于查询来说, 不受影响.<br>2. 对于删除结点时,单链表只能获取下一个结点,需要获取前驱结点,则需要遍历整个链表, 时间复杂度退化为O(n)<br>3. 更新操作与删除操作一样.<br>4. 对于增加结点,如果是头部或尾部不受影响.如果是中间位置增加结点,则跟删除一样,退化为O(n)<br><br>第二题: 使用hash存储10万名猎头信息,key是猎头ID, 然后再使用链表, 创建一个跳表的猎头ID双链表.<br>1. 对于查询, 删除, 更新都是O(1)<br>2. 对于查找某个区间猎头ID,先使用HAST,获取头与尾的结点.然后遍历链表即可<br>3. 这个问题能不能再维护一个红黑树, 实现积分从小到大排名,保证大小关系,快速查询,实现积分统计 ","like_count":0},{"had_liked":false,"id":153894,"user_name":"Sun Fei","can_delete":false,"product_type":"c1","uid":1032631,"ip_address":"","ucode":"092EC0992050BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c1/b7/57f153f6.jpg","comment_is_top":false,"comment_ctime":1574327066,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574327066","product_id":100017301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":153614,"user_name":"常文龙","can_delete":false,"product_type":"c1","uid":1204525,"ip_address":"","ucode":"4A126159D24766","user_header":"https://static001.geekbang.org/account/avatar/00/12/61/2d/5ca0a3da.jpg","comment_is_top":false,"comment_ctime":1574269761,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574269761","product_id":100017301,"comment_content":"思考题使用关系型数据库（如mysql）能已完成所有功能。建立一个表 id作为主键，score字段建立索引。查询按分数排序的指定排名区间的数据可以使用 limit。select * from table a join (select id from table order by score limit m,n) b on a.id=b. id。","like_count":0},{"had_liked":false,"id":150389,"user_name":"晃晃","can_delete":false,"product_type":"c1","uid":1724129,"ip_address":"","ucode":"088FF5171F90C7","user_header":"","comment_is_top":false,"comment_ctime":1573525999,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573525999","product_id":100017301,"comment_content":"前面学排序的时候比较有乐趣，这几章节都很枯燥。","like_count":0},{"had_liked":false,"id":149471,"user_name":"乾坤瞬间","can_delete":false,"product_type":"c1","uid":1683130,"ip_address":"","ucode":"15BDCF29CBF8EB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","comment_is_top":false,"comment_ctime":1573227307,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573227307","product_id":100017301,"comment_content":"对于思考题1，由双向链表改成单向链表，并不会影响正常功能的使用，只是在需要查找上一个节点的操作上并不是最优的，尤其在维护lrc缓存淘汰机制的删除操作上比较麻烦，要重头开始遍历<br>思考题2，使用散列表方式以id为key，其他信息为value存储在节点上来满足第一个需求，同时以score分值大小作为跳表的分组依据，来满足第二个用区间查找用户信息，最后在建立的这个跳表基础结构之上，遍历链表对每个节点遍历计数找到符合条件的用户","like_count":0},{"had_liked":false,"id":144329,"user_name":"深山何处钟","can_delete":false,"product_type":"c1","uid":1100117,"ip_address":"","ucode":"5D42024E40D751","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/55/3b2526ce.jpg","comment_is_top":false,"comment_ctime":1571898607,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571898607","product_id":100017301,"comment_content":"老师您好。课后思考2，意思是说按ID建立散列表之后，另外按积分建立跳表么？<br>还是说，在散列表冲突时用跳表解决冲突？<br><br>如果是后者，怎么查询积分呢？","like_count":0},{"had_liked":false,"id":143985,"user_name":"AlexS","can_delete":false,"product_type":"c1","uid":1472051,"ip_address":"","ucode":"3DA81A613CE645","user_header":"https://static001.geekbang.org/account/avatar/00/16/76/33/928ffd21.jpg","comment_is_top":false,"comment_ctime":1571820319,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571820319","product_id":100017301,"comment_content":"LRU例子中，双链表要是循环的或者除了链表头外要而外维护一个尾指针，不然删最老的节点做不到O(1)。<br>","like_count":0},{"had_liked":false,"id":142919,"user_name":"Pyer","can_delete":false,"product_type":"c1","uid":1159237,"ip_address":"","ucode":"8287EFD2268211","user_header":"https://static001.geekbang.org/account/avatar/00/11/b0/45/f0a63850.jpg","comment_is_top":false,"comment_ctime":1571585126,"is_pvip":false,"replies":[{"id":"55209","content":"这个看你怎么设计的，链表中的数据是按照访问时间从大到小排列，还是从小到大排列。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1571614887,"ip_address":"","comment_id":142919,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571585126","product_id":100017301,"comment_content":"老师，当第 9 行代码访问到 key 为 5 的数据的时候，这里为什么是把5放在尾部而不是头部呢?<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471326,"discussion_content":"这个看你怎么设计的，链表中的数据是按照访问时间从大到小排列，还是从小到大排列。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571614887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142592,"user_name":"Pyer","can_delete":false,"product_type":"c1","uid":1159237,"ip_address":"","ucode":"8287EFD2268211","user_header":"https://static001.geekbang.org/account/avatar/00/11/b0/45/f0a63850.jpg","comment_is_top":false,"comment_ctime":1571407809,"is_pvip":false,"replies":[{"id":"55220","content":"是的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1571618297,"ip_address":"","comment_id":142592,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571407809","product_id":100017301,"comment_content":"那么hashmap用链表法解决哈希冲突，底层也是数组+链表吧，老师","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471189,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571618297,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141592,"user_name":"厚积薄发","can_delete":false,"product_type":"c1","uid":1657999,"ip_address":"","ucode":"6FE711F65C8C66","user_header":"https://static001.geekbang.org/account/avatar/00/19/4c/8f/83eefcff.jpg","comment_is_top":false,"comment_ctime":1571197269,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571197269","product_id":100017301,"comment_content":"LRU，看了几遍终于看懂了，其实开始先理解数据存储是用双链表【为了保持有序】，但是由于查找时间复杂度是O(n),使用了散列表，将值通过散列函数获取散列值，插入到散列表中，查找的复杂度降低值O(1),；为了解决散列冲突，图中使用了链表的方式，即hnext","like_count":0},{"had_liked":false,"id":136317,"user_name":"Geek_18b741","can_delete":false,"product_type":"c1","uid":1368496,"ip_address":"","ucode":"097BA0C2F44150","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLlztvlBgajZMEph8AvkP2pfoqNCGtYSalIKgrCbCg0MWDZJgJwqVRfWA6cgIoZicL6dKibfK0zjsWg/132","comment_is_top":false,"comment_ctime":1569408021,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569408021","product_id":100017301,"comment_content":"Redis与lru的区别是排序的字段不同。lru按照访问时间排序，Redis可以按照某个属性（例如分值）排序。linkedhashmap＝lru。","like_count":0},{"had_liked":false,"id":134739,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1568906358,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568906358","product_id":100017301,"comment_content":"2 首先根据猎头id为key进行散列，开链法解决冲突，然后再将节点依积分排序构建跳表","like_count":0},{"had_liked":false,"id":134738,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1568906239,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568906239","product_id":100017301,"comment_content":"1 单链表不行，因为通过散列找到节点后，如果是单链表无法直接定位到前驱节点<br>2","like_count":0},{"had_liked":false,"id":133721,"user_name":"Hwan","can_delete":false,"product_type":"c1","uid":1205627,"ip_address":"","ucode":"A728C6790511BD","user_header":"https://static001.geekbang.org/account/avatar/00/12/65/7b/66b9befd.jpg","comment_is_top":false,"comment_ctime":1568641046,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568641046","product_id":100017301,"comment_content":"1.考虑到LRU淘汰算法和LinkedHashMap都是通过hash表加上双向链表实现的，这里一起说下，我觉得改成单链表不行，比如查找一个元素，变成单链表之后，我们找到这个数据是O(1),但是将其移到链表尾部是O(n),删除一个元素操作，找到这个数据是O(1),但是因为是单链表，我们没法知道它的前驱节点，所以需要从头开始遍历找到它的前驱节点，为O(n),添加一个元素，在移到表尾的操作原来是O(1),现在是O(n)。<br>现在说下Redis有序集合，对于主要影响的还是根据键值进行的操作，比如删除操作，如果是单链表的话，也是On),因为需要从头开始遍历找到指定数据的前驱节点<br><br>2.前两个问题和Redis的有序集合一样，虽然第三个也是有序集合的操作，但是现在还不知道具体的实现，现在我的想法是，先取得所有的分数，然后排序取得第X到第Y的分数，具体的排序算法可以根据分数的分布情况选，得到分数X‘和Y’，然后就是和第二问的操作一样的\t","like_count":0},{"had_liked":false,"id":133279,"user_name":"方晓斌","can_delete":false,"product_type":"c1","uid":1042367,"ip_address":"","ucode":"A26FA55F05FE9E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e7/bf/b6dd86f4.jpg","comment_is_top":false,"comment_ctime":1568474188,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568474188","product_id":100017301,"comment_content":"单链表可以O(1)删除，用狸猫换太子方法，编程之美里给的方法","like_count":0},{"had_liked":false,"id":133169,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1568427183,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568427183","product_id":100017301,"comment_content":"一个有序，一个快速定位，完美转变为数组，","like_count":0},{"had_liked":false,"id":130734,"user_name":"静静聆听","can_delete":false,"product_type":"c1","uid":1263932,"ip_address":"","ucode":"0A8600CB928EFE","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/3c/5d54c510.jpg","comment_is_top":false,"comment_ctime":1567521820,"is_pvip":false,"replies":[{"id":"48961","content":"这个...学一下c把","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1567549597,"ip_address":"","comment_id":130734,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567521820","product_id":100017301,"comment_content":"老师，我是做java的，但是想debug redis的源码，要怎么操作","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466097,"discussion_content":"这个...学一下c把","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567549597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130705,"user_name":"puhan","can_delete":false,"product_type":"c1","uid":1529235,"ip_address":"","ucode":"50746E9A4990A8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/icniaGmw8xiboxib5xa1RSNvRDX1yVQTrcSqVOlJPibt0A6SM7EnFTHa6ib0YQKSUPqtx7wVksxZZXK4huUpCqrKjT1w/132","comment_is_top":false,"comment_ctime":1567514457,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567514457","product_id":100017301,"comment_content":"1.可以。时间复杂度会增大<br>2.“字典+跳表”的存储方式   --&gt;Redis有序集合","like_count":0},{"had_liked":false,"id":129267,"user_name":"半生瓜。","can_delete":false,"product_type":"c1","uid":1606288,"ip_address":"","ucode":"6D4CC445230D19","user_header":"https://static001.geekbang.org/account/avatar/00/18/82/90/295449c4.jpg","comment_is_top":false,"comment_ctime":1567074366,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1567074366","product_id":100017301,"comment_content":"其实要理解两个链表的含义才能理解老师讲的内容。hnext构建的链表和之前讲的hashmap中的拉练法解决冲突的一样。而双向链表是为了实现所有内容在插入、更新的时候的顺序，这里的顺序是指先后顺序，不是大小顺序。其实老师那个图分开画可能会更好理解一点。","like_count":0,"discussions":[{"author":{"id":1098987,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/eb/2285a345.jpg","nickname":"花晨少年","note":"","ucode":"6AA3537A6BA10E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":140239,"discussion_content":"我觉得老师讲的有迷惑性，hnext根本就不需要，因为左边是散列表，内部已经解决完冲突了，如果左边是数据，肯定要用hnext了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579353056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123136,"user_name":"未来的胡先森","can_delete":false,"product_type":"c1","uid":1234682,"ip_address":"","ucode":"AFF193AC0E2E6C","user_header":"https://static001.geekbang.org/account/avatar/00/12/d6/fa/1f5bf642.jpg","comment_is_top":false,"comment_ctime":1565612689,"is_pvip":false,"replies":[{"id":"45689","content":"最后一个问题的回复：不是，还是在跳表上操作的，需要改造跳表，价格range字段。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1565908873,"ip_address":"","comment_id":123136,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1565612689","product_id":100017301,"comment_content":"问题1：双向链表换成单链表依旧可以正常工作，不过设计上一结点的操作会更复杂。<br><br>问题2：<br><br>1、根据猎头的 ID 快速查找、删除、更新，维护散列表以猎头的 ID 为「key」，猎头积分信息为「value」<br><br>2、查找积分在某个区间的猎头 ID 列表，对应之前学习的数据结构跳表，以积分建立对应的跳表。<br><br>3、查找按照积分大小排名在第 X 位 到第 Y 位之间的猎头 ID 列表，这是 B+ 树吗？<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462553,"discussion_content":"最后一个问题的回复：不是，还是在跳表上操作的，需要改造跳表，价格range字段。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565908873,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645430,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiauonyMORA2s43W7mogGDH4WYjW0gBJtYmUa9icTB6aMPGqibicEKlLoQmLKLWEctwHzthbTZkKR20w/132","nickname":"Spring4J","note":"","ucode":"06F056085A2564","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338870,"discussion_content":"如果加个range字段，貌似每次插入或者删除节点还得后面所有节点的range值啊，这样不会慢吗？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609406587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114264,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1563263226,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563263226","product_id":100017301,"comment_content":"今日思考题<br>用分值作为索引的跳表和id为key的hash表可以处理高效的查询和增删功能，分值有关的操作复杂度为O(log n), id 有关的操作复杂度近似为O(1). 对于排名的查询估计要在引入新的索引，我的想法是类似于跳表建立一个对应于分值区间人数的索引，最高层把人数一分为二，下面再分为四，依次分下去，这样根据排名查询的复杂度也是O(log n)。","like_count":0},{"had_liked":false,"id":112281,"user_name":"Leon📷","can_delete":false,"product_type":"c1","uid":1219496,"ip_address":"","ucode":"B9BBD1EFAAE5A2","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/a8/6a391c66.jpg","comment_is_top":false,"comment_ctime":1562714773,"is_pvip":false,"replies":[{"id":"40903","content":"参考concurrrnthashmap 网上资料很多的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1562739379,"ip_address":"","comment_id":112281,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562714773","product_id":100017301,"comment_content":"老师，如果设计高并发的散列表呢，面试问到。期待讲一下","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457655,"discussion_content":"参考concurrrnthashmap 网上资料很多的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562739379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":110712,"user_name":"☆星月夜","can_delete":false,"product_type":"c1","uid":1215506,"ip_address":"","ucode":"22BCA9807D0BD4","user_header":"https://static001.geekbang.org/account/avatar/00/12/8c/12/ccf8d2ca.jpg","comment_is_top":false,"comment_ctime":1562318251,"is_pvip":false,"replies":[{"id":"40677","content":"hnext是哈希表中拉链的next指针。你再看下留言里的内容，我记得我解释过了。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1562631746,"ip_address":"","comment_id":110712,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562318251","product_id":100017301,"comment_content":"老师好，双向链表的hnext那个，还是看不明白，能不能解释下呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457020,"discussion_content":"hnext是哈希表中拉链的next指针。你再看下留言里的内容，我记得我解释过了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562631746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108149,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1561686998,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561686998","product_id":100017301,"comment_content":"LRU缓存淘汰算法中包含两条链，一条是散列表中的拉链，另一条是实现LRU算法的双向链表<br>散列表结合链表：利用散列表达到o(1)的访问时间，利用链表来保证有序特性","like_count":0},{"had_liked":false,"id":106097,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1561173449,"is_pvip":false,"replies":[{"id":"38648","content":"文章讲到的链表有两个地方。一个是散列表中的拉链，一个是独立的链表（记作a）。<br><br>在散列表的拉链中查找数据，是要遍历的。<br><br>但是通过散列表定位到数据之后，就不需要在链表（a）中再遍历了。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1561420087,"ip_address":"","comment_id":106097,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1561173449","product_id":100017301,"comment_content":"老师，为什么查找哈希表中双向链表某一节点的时间复杂度是o(1)，这里为什么不要遍历节点了啊，假设通过散列函数计算出在bucket0的位置，但是查找具体的节点还是需要遍历bucket0位置上的链表吧，只是说通过散列表的方式无需遍历整个链表，但是具体的bucket位置的上的链表还是需要遍历的吧。麻烦老师解答下，谢谢","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454948,"discussion_content":"文章讲到的链表有两个地方。一个是散列表中的拉链，一个是独立的链表（记作a）。\n\n在散列表的拉链中查找数据，是要遍历的。\n\n但是通过散列表定位到数据之后，就不需要在链表（a）中再遍历了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561420087,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1042685,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e8/fd/abb7bfe3.jpg","nickname":"Langzi233","note":"","ucode":"5A21AC08FC089B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4260,"discussion_content":"拉链中的链还是要遍历的，但是我们应该且必须要通过哈希桶的大小和哈希算法尽量避免拉链过长，也就是减少根据key值哈希出来的值有冲突，不然你的哈希表设计的就不合理了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565257265,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105699,"user_name":"ILoveKindness","can_delete":false,"product_type":"c1","uid":1559444,"ip_address":"","ucode":"A6210B034AAC62","user_header":"https://static001.geekbang.org/account/avatar/00/17/cb/94/eedbace3.jpg","comment_is_top":false,"comment_ctime":1561076826,"is_pvip":false,"replies":[{"id":"38637","content":"关于这个问题，你可以看下这篇文章：<br>https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;Md8tprLiESR6oQKXs_Aihw","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1561419589,"ip_address":"","comment_id":105699,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561076826","product_id":100017301,"comment_content":"老师您好，对于smallfly的精选留言，我不是很懂为什么他说“如果硬要操作，单链表也是可以实现O(1)时间复杂度删除，请求老师解答","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454780,"discussion_content":"关于这个问题，你可以看下这篇文章：\nhttps://mp.weixin.qq.com/s/Md8tprLiESR6oQKXs_Aihw","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561419589,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105067,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1560910526,"is_pvip":false,"replies":[{"id":"38119","content":"自己去看下源码吧：）","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1560987685,"ip_address":"","comment_id":105067,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1560910526","product_id":100017301,"comment_content":"请问下是不是jdk1.8中HashMap和LinkedHashmap出里hash冲突的拉链法用的头插法，而1.7两者中是用的尾插法？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454546,"discussion_content":"自己去看下源码吧：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560987685,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296104,"discussion_content":"告诉你你刚好说反了，1.7用的是头插法，1.8是尾插法，所以1.8在扩容后够保持同一条链中节点的先后顺序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596452512,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":102264,"user_name":"jm3640","can_delete":false,"product_type":"c1","uid":1558393,"ip_address":"","ucode":"ED2E78AC6F669B","user_header":"https://static001.geekbang.org/account/avatar/00/17/c7/79/657c05e7.jpg","comment_is_top":false,"comment_ctime":1560171688,"is_pvip":false,"replies":[{"id":"36901","content":"可以事先记录好链表尾部tail","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1560209998,"ip_address":"","comment_id":102264,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560171688","product_id":100017301,"comment_content":"LRU实现方法中 在链表尾部插入数据 难道不是要先查找尾节点么 查找尾节点这个操作的时间复杂度不能通过散列表提升到O(1) 吧 还是只能遍历整个链表才能找到 那时间复杂度不就还是O(n)么 请老师解答一下 谢谢","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453325,"discussion_content":"可以事先记录好链表尾部tail","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560209998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":100586,"user_name":"于无声处听惊雷","can_delete":false,"product_type":"c1","uid":1238872,"ip_address":"","ucode":"F2A6718BC2F1B6","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/58/0b494b16.jpg","comment_is_top":false,"comment_ctime":1559601710,"is_pvip":false,"replies":[{"id":"36266","content":"这个都可以的，看你怎么定义链表了，是从小到大，还是从大到小。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1559611998,"ip_address":"","comment_id":100586,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559601710","product_id":100017301,"comment_content":"而且最新的应该是经常访问的，应该放头部，怎么能放尾部？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452611,"discussion_content":"这个都可以的，看你怎么定义链表了，是从小到大，还是从大到小。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559611998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":100585,"user_name":"于无声处听惊雷","can_delete":false,"product_type":"c1","uid":1238872,"ip_address":"","ucode":"F2A6718BC2F1B6","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/58/0b494b16.jpg","comment_is_top":false,"comment_ctime":1559601622,"is_pvip":false,"replies":[{"id":"36267","content":"应该没啥问题，你再看一遍吧","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1559612018,"ip_address":"","comment_id":100585,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1559601622","product_id":100017301,"comment_content":"本文部分内容说的有问题，单链表淘汰算法，按时间从大到小排序，怎么是淘汰头部结点。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452610,"discussion_content":"应该没啥问题，你再看一遍吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559612018,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1606288,"avatar":"https://static001.geekbang.org/account/avatar/00/18/82/90/295449c4.jpg","nickname":"半生瓜。","note":"","ucode":"6D4CC445230D19","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6570,"discussion_content":"只要你记录了头尾指针，淘汰哪边不是都可以吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566979439,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99710,"user_name":"꧁花间一壶酒꧂","can_delete":false,"product_type":"c1","uid":1542238,"ip_address":"","ucode":"71CBBCFC4A926E","user_header":"https://static001.geekbang.org/account/avatar/00/17/88/5e/e9a8417d.jpg","comment_is_top":false,"comment_ctime":1559283389,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559283389","product_id":100017301,"comment_content":"菜鸟到此路过,坚持到底","like_count":0},{"had_liked":false,"id":99095,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1559141615,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559141615","product_id":100017301,"comment_content":"思考题1：如果改为单向链表，也能正常工作，但是对于节点的插入、删除效率会下降，因为做这两个操作必须要查找节点的前驱节点和后继节点<br>思考题2：我的想法是用数组和散列表想结合，在数组中按积分大小从小到大存贮ID和积分信息，此外，还要再多一个HNEXT指针，用于在散列表中形成拉链，然后用散列表来存贮各节点ID，这样就可根据ID来快速查询积分信息","like_count":0},{"had_liked":false,"id":98611,"user_name":"lzh","can_delete":false,"product_type":"c1","uid":1336951,"ip_address":"","ucode":"C3D83DF4230109","user_header":"https://static001.geekbang.org/account/avatar/00/14/66/77/194ba21d.jpg","comment_is_top":false,"comment_ctime":1559040707,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559040707","product_id":100017301,"comment_content":"Java LinkedHashMap的那个例子,当插入(3,26)后要删除(3,11),这里的删除应该不是真的把整个节点free掉吧,而是把(3,11)挂在(3,26)节点的hnext后面,同时把(3,26)节点维护进双向连表中<br><br>最后(3,11)的pre和next应该都会指向null","like_count":0},{"had_liked":false,"id":98402,"user_name":"快乐少年郎","can_delete":false,"product_type":"c1","uid":1488186,"ip_address":"","ucode":"A6DF373FEB50F7","user_header":"https://static001.geekbang.org/account/avatar/00/16/b5/3a/9f2e0d8e.jpg","comment_is_top":false,"comment_ctime":1558996670,"is_pvip":false,"replies":[{"id":"35202","content":"可以参考下这篇文章的解释：<br>https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;E-c41h2v_AfffrlAQpkyLg","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1559006092,"ip_address":"","comment_id":98402,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1558996670","product_id":100017301,"comment_content":"javascript中的数组底层是用链表来实现的，对象是用散列表和链表实现的","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451673,"discussion_content":"可以参考下这篇文章的解释：\nhttps://mp.weixin.qq.com/s/E-c41h2v_AfffrlAQpkyLg","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559006092,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93887,"user_name":"清风明月","can_delete":false,"product_type":"c1","uid":1233814,"ip_address":"","ucode":"0C1B6835A7405C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK1sKGBn6CkWu43to67hx3AYOBnb84moPlCmiamat2qrXKhMazKqJjJTzEPgguV6NIB7Nyia5yFCCRA/132","comment_is_top":false,"comment_ctime":1557652691,"is_pvip":false,"replies":[{"id":"33862","content":"你理解的没错，是没关系，两个独立的索引结构。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1557882195,"ip_address":"","comment_id":93887,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557652691","product_id":100017301,"comment_content":"老师， 不是很明白很多人说的使用散列表+单链表为啥删除一个节点的时间就是O(n), 看了下java LinkedHashMap的源码， 里面采用散列表+双链表时删除一个节点也是需要去遍历散列表中的单链表或树， 我理解这个和外围的单&#47;双链表应该无关才对，不知道老师怎么看该问题？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449810,"discussion_content":"你理解的没错，是没关系，两个独立的索引结构。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557882195,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92974,"user_name":"Shawn","can_delete":false,"product_type":"c1","uid":1014729,"ip_address":"","ucode":"B95D7B54465DE4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7b/c9/75c9002e.jpg","comment_is_top":false,"comment_ctime":1557371155,"is_pvip":false,"replies":[{"id":"33265","content":"是的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1557451415,"ip_address":"","comment_id":92974,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557371155","product_id":100017301,"comment_content":"散列表加双向链表实现LRU的时候，是不是需要两个指针指向双向链表的头尾呀？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449445,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557451415,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89360,"user_name":"吉页","can_delete":false,"product_type":"c1","uid":1244817,"ip_address":"","ucode":"8E25056FB25012","user_header":"https://static001.geekbang.org/account/avatar/00/12/fe/91/0ee2741a.jpg","comment_is_top":false,"comment_ctime":1556158783,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1556158783","product_id":100017301,"comment_content":"双向链表中的next和hnext其实可以理解为逻辑上的next（用户输入的顺序），地址上的next（hash后解决冲突往后加）<br>对于思考题中的第一题，看了置顶的评论，说找到一个对象的前一个对象时间复杂度为O(n)，这里指的前一个对象是逻辑上的前一个吧，刚开始想成地址上的前一个，搞混了，给大家提个醒哈哈","like_count":0,"discussions":[{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296105,"discussion_content":"hnext即hash next，哈希表中数组槽位为解决哈希冲突存储的链表，顾名思义的去理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596452848,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":88537,"user_name":"dovefi","can_delete":false,"product_type":"c1","uid":1007670,"ip_address":"","ucode":"9F8C59F095B187","user_header":"https://static001.geekbang.org/account/avatar/00/0f/60/36/1848c2b7.jpg","comment_is_top":false,"comment_ctime":1555938597,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555938597","product_id":100017301,"comment_content":"老师这里的双链表加hash 链表法的方式，看图是真的比较难理解到，我基础比较弱，也是网上再次找了一些资料，这里稍微说下我的看法，我觉得这里应该分成两部分理解<br>第一部分hash链表法<br>第二部分双链表<br>首先抛开双链表这个概念，单独看第一部分hash的链表表示，这里跟老师第一节说的没什么两样就是用来存储数据，方便查找，这是最大的特点，也是单链表LRU算法缺少的东西，但是光有存储是不够的，我们还不知道哪些数据是先存进来的，也就是说LRU本身需要存储数据的先后，那这一部分的工作由谁去做，答案就是双链表。<br>如果我要访问B4 那么，按照之前的单链表方式，我必须遍历整条链表时间负载读为O(n)，但是如果我使用hash存储的，那我直接就可以找B4,时间复杂度为O(1)  <br><br>","like_count":0},{"had_liked":false,"id":82275,"user_name":"mrlay","can_delete":false,"product_type":"c1","uid":1041640,"ip_address":"","ucode":"385A1954ED3317","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e4/e8/a1703783.jpg","comment_is_top":false,"comment_ctime":1554173837,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554173837","product_id":100017301,"comment_content":"我是算法导论看不下去了，然后过来的。觉得二者各有千秋，但很明显老师的效率高，实战性好，懂得快。","like_count":0},{"had_liked":false,"id":82255,"user_name":"Amark","can_delete":false,"product_type":"c1","uid":1121326,"ip_address":"","ucode":"E5F48633654002","user_header":"https://static001.geekbang.org/account/avatar/00/11/1c/2e/93812642.jpg","comment_is_top":false,"comment_ctime":1554170363,"is_pvip":false,"replies":[{"id":"29879","content":"事先存储好了的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1554249455,"ip_address":"","comment_id":82255,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554170363","product_id":100017301,"comment_content":"请问老师LRU 缓存淘汰算法中如何找到链表的头部或者尾部，是通过散列表吗?","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445526,"discussion_content":"事先存储好了的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554249455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81486,"user_name":"朱坤","can_delete":false,"product_type":"c1","uid":1098637,"ip_address":"","ucode":"65224DA2456EAB","user_header":"https://static001.geekbang.org/account/avatar/00/10/c3/8d/214ad614.jpg","comment_is_top":false,"comment_ctime":1553923947,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553923947","product_id":100017301,"comment_content":"第一遍看完做课后思考题，没啥思路。。再把文章看第二遍，有种，奥，原来是这样。。然后就知道思考题的解题思路了。课程设计的还是挺精妙的。","like_count":0},{"had_liked":false,"id":81484,"user_name":"朱坤","can_delete":false,"product_type":"c1","uid":1098637,"ip_address":"","ucode":"65224DA2456EAB","user_header":"https://static001.geekbang.org/account/avatar/00/10/c3/8d/214ad614.jpg","comment_is_top":false,"comment_ctime":1553923579,"is_pvip":false,"replies":[{"id":"29571","content":"是的 都要维护","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1553993325,"ip_address":"","comment_id":81484,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553923579","product_id":100017301,"comment_content":"老师您讲解的LRU 缓存淘汰算法中的插入和删除操作，除了需要做双向链表的指针更新，也要做维护哈希拉链的指针更新的吧，这块好像没有提到？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445224,"discussion_content":"是的 都要维护","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553993325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77529,"user_name":"康斯坦丁","can_delete":false,"product_type":"c1","uid":1368096,"ip_address":"","ucode":"C130E800E8D5C9","user_header":"https://static001.geekbang.org/account/avatar/00/14/e0/20/003190c1.jpg","comment_is_top":false,"comment_ctime":1552959747,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552959747","product_id":100017301,"comment_content":"1 单向链表删除的时间复杂度为O(n)<br>2 跳表+散列表实现","like_count":0},{"had_liked":false,"id":77493,"user_name":"大亮","can_delete":false,"product_type":"c1","uid":1203108,"ip_address":"","ucode":"C7DEAB77AC9597","user_header":"https://static001.geekbang.org/account/avatar/00/12/5b/a4/e01fc4f2.jpg","comment_is_top":false,"comment_ctime":1552956620,"is_pvip":false,"replies":[{"id":"28287","content":"是用链表法解决的。我只是说 单词linked并不是指这个意思","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1552958301,"ip_address":"","comment_id":77493,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552956620","product_id":100017301,"comment_content":"LinkedHashMap的Linked不是指用链表解决哈希冲突，那是用什么方法解决的呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443746,"discussion_content":"是用链表法解决的。我只是说 单词linked并不是指这个意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552958301,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77213,"user_name":"乐凡","can_delete":false,"product_type":"c1","uid":1239260,"ip_address":"","ucode":"918C9997EB6537","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/dc/32e78f02.jpg","comment_is_top":false,"comment_ctime":1552888659,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552888659","product_id":100017301,"comment_content":"1、若改为单链表，则无法向双链表那么高效，因为要是将结点移到尾部，需要在原位置删除，需要知道该结点的前结点，如果是单链表需要从头遍历找到前结点，这个时候时间复杂度就变味O(n)。效率太低。<br>2、通过散列表和双向链表来存储，将猎头信息按照积分从小到大构建一个跳表，再以ID构建一个散链表。<br>1）这样以ID查询信息、删除、更新信息时间复杂度为O(1)。<br>2）通过跳表可以查找积分在某个区间的ID列表。<br>3）目前所学的暂时无法根据排名查找对应的信息","like_count":0},{"had_liked":false,"id":76494,"user_name":"JD_Ahoi","can_delete":false,"product_type":"c1","uid":1445281,"ip_address":"","ucode":"2188A07A5FF7A5","user_header":"https://static001.geekbang.org/account/avatar/00/16/0d/a1/a6e16f9e.jpg","comment_is_top":false,"comment_ctime":1552619457,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552619457","product_id":100017301,"comment_content":"·HashMap：采用数组+链表的数据结构，1.8中，当链表长度大于8，链表会转为红黑树，小于8，又会转为链表(数据量较小的情况下，红黑树要维护平衡);<br>·LinkedHashMap：数组+链表，数组本身每个entry之间设计为双向链表，物理空间不连续，但是逻辑上连续的，实现了顺序输出的功能；","like_count":0},{"had_liked":false,"id":75770,"user_name":"吴涛","can_delete":false,"product_type":"c1","uid":1175639,"ip_address":"","ucode":"14248ED0C2CA6E","user_header":"https://static001.geekbang.org/account/avatar/00/11/f0/57/205cef6e.jpg","comment_is_top":false,"comment_ctime":1552466657,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552466657","product_id":100017301,"comment_content":"豁然开朗啊，Android中的LRUCache就是基于LinkedHashMap的","like_count":0},{"had_liked":false,"id":72789,"user_name":"鱼星草","can_delete":false,"product_type":"c1","uid":1123975,"ip_address":"","ucode":"066E61BA6BE4EF","user_header":"https://static001.geekbang.org/account/avatar/00/11/26/87/31c785a3.jpg","comment_is_top":false,"comment_ctime":1551717290,"is_pvip":false,"replies":[{"id":"26407","content":"哈哈，请看我的公众号“小争哥”里的补充讲解：）","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551752834,"ip_address":"","comment_id":72789,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551717290","product_id":100017301,"comment_content":"看了好几遍，终于把第一张图看明白了<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441745,"discussion_content":"哈哈，请看我的公众号“小争哥”里的补充讲解：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551752834,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72446,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1551627941,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551627941","product_id":100017301,"comment_content":"之前一直以为linkedhashmap就是双向链表+hash表，原来他是lru的一种实现","like_count":0},{"had_liked":false,"id":68510,"user_name":"浩涛","can_delete":false,"product_type":"c1","uid":1390697,"ip_address":"","ucode":"DCF935D3F9FC6D","user_header":"https://static001.geekbang.org/account/avatar/00/15/38/69/7b11b341.jpg","comment_is_top":false,"comment_ctime":1550536482,"is_pvip":false,"replies":[{"id":"24621","content":"Redis中跳表+散列表一块实现的有序集合。有序集合这个数据类型有点奇特，每个对象都有一个key和一个score值，key维护在散列表中，方便用key快速查找，score维护在跳表中，方便按照score查询。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1550719329,"ip_address":"","comment_id":68510,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1550536482","product_id":100017301,"comment_content":"既然跳表已经满足 查询，增删都很快，还要加上散列表增加复杂度？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439710,"discussion_content":"Redis中跳表+散列表一块实现的有序集合。有序集合这个数据类型有点奇特，每个对象都有一个key和一个score值，key维护在散列表中，方便用key快速查找，score维护在跳表中，方便按照score查询。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550719329,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":68446,"user_name":"刘涛涛","can_delete":false,"product_type":"c1","uid":1396130,"ip_address":"","ucode":"D2EE76FA0BB1C5","user_header":"https://static001.geekbang.org/account/avatar/00/15/4d/a2/9450ef89.jpg","comment_is_top":false,"comment_ctime":1550500655,"is_pvip":false,"replies":[{"id":"25062","content":"不是串行关系的。两个索引（跳表、散列表）都指向同样的数据。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551061740,"ip_address":"","comment_id":68446,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1550500655","product_id":100017301,"comment_content":"有个问题哈，既然redis的有序集合是按照跳表和散列表实现的，那么每次按照散列表进行查询和删除的时候，跳表不是也要变化么，那么代码中两个过程是串行关系么，如果是的话，那么复杂度不还是o(lgn)么","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439678,"discussion_content":"不是串行关系的。两个索引（跳表、散列表）都指向同样的数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551061740,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":68436,"user_name":"刘涛涛","can_delete":false,"product_type":"c1","uid":1396130,"ip_address":"","ucode":"D2EE76FA0BB1C5","user_header":"https://static001.geekbang.org/account/avatar/00/15/4d/a2/9450ef89.jpg","comment_is_top":false,"comment_ctime":1550499957,"is_pvip":false,"replies":[{"id":"25063","content":"我们可以维护两个指针，头指针、尾指针。这样，两种思路就都一样了。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551061779,"ip_address":"","comment_id":68436,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1550499957","product_id":100017301,"comment_content":"为什么使用链表实现LRU中最近访问的既可以放在头部也可以放在尾部？放在尾部的话不是要访问时间增加吗","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439673,"discussion_content":"我们可以维护两个指针，头指针、尾指针。这样，两种思路就都一样了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551061779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":67363,"user_name":"可妮","can_delete":false,"product_type":"c1","uid":1007885,"ip_address":"","ucode":"6F08A7F700EABE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKibr46Zzwgtl6TQweY6ibtjNyn5t6C4QLjq3EnvRJI73WwjBYoscmicYIRMTcb5Ef67usdlcVlQ8yjQ/132","comment_is_top":false,"comment_ctime":1550135442,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550135442","product_id":100017301,"comment_content":"思考题1：<br>在这里是比较单向链表和双链表的区别：<br>用单链表能实现双链表的功能，但是对于插入和删除操作，单链表的时间复杂度是O(N), 双链表可以从head,tail 同时操作，时间复杂度能达到O（logn）, 比单链表高效","like_count":0},{"had_liked":false,"id":64325,"user_name":"🐍","can_delete":false,"product_type":"c1","uid":1213611,"ip_address":"","ucode":"42B11C20DD3CB0","user_header":"https://static001.geekbang.org/account/avatar/00/12/84/ab/1842a785.jpg","comment_is_top":false,"comment_ctime":1548746723,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548746723","product_id":100017301,"comment_content":"第一位留言的朋友 PS  后的话互相冲突.","like_count":0},{"had_liked":false,"id":64185,"user_name":"且听疯吟","can_delete":false,"product_type":"c1","uid":1159459,"ip_address":"","ucode":"B010B16E5465F4","user_header":"https://static001.geekbang.org/account/avatar/00/11/b1/23/5df1f341.jpg","comment_is_top":false,"comment_ctime":1548688776,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1548688776","product_id":100017301,"comment_content":"以积分排序构建一个跳表，再以猎头 ID 构建一个散列表。<br><br>1）ID 在散列表中所以可以 O(1) 查找到这个猎头；<br>2）积分以跳表存储，跳表支持区间查询；<br>3）这点根据目前学习的知识暂时无法实现，老师文中也提到了。<br><br>跳表支持区间查找：<br>  vector&lt;int&gt; search(int low,int high){<br>      vector&lt;int&gt; ans;<br>       ListNode * left = this-&gt;head;<br>       ListNode * right = this-&gt;head;<br><br>       &#47;*left*&#47;<br>       for(int i = this-&gt;max_level-1; i &gt;= 0; --i){<br>           while(left-&gt;forwards[i] &amp;&amp; left-&gt;forwards[i]-&gt;val &lt; low){<br>               left = left-&gt;forwards[i];<br>           }<br>       }<br><br>       &#47;*right*&#47;<br>       for(int i = this-&gt;max_level-1; i &gt;= 0; --i){<br>           while(right-&gt;forwards[i] &amp;&amp; right-&gt;forwards[i]-&gt;val &lt;= high){<br>               right = right-&gt;forwards[i];<br>           }<br>       }<br><br>       while(left != right){<br>           if(left-&gt;forwards[0]){<br>                ans.push_back(left-&gt;forwards[0]-&gt;val);<br>                left = left-&gt;forwards[0];<br>           }<br>       }<br><br>       return ans;<br>    }","like_count":0,"discussions":[{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296189,"discussion_content":"代码有错误\n1左边界选找的循环条件是left->forwards[i]->val <low，这样你找的是左边界的前驱结点而不是左边界，最后结果会把左边界左边的值也算上，所以在结果list赋值时循环前多加一句left = left->forwards[0];当然这是对于闭区间查询来说，如果是开区间的话就再加一句\nif（left->forwards[0]&amp;&amp;left->val=low）{\n     left = left->forwards[0]\n}\n2.结果list赋值时循环条件是left != right，结果中缺少右边界right的值，如果区间查询是包含边界值的话应该加上右边界即返回结果之前加上右边界的值ans.push_back(right->val);","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596465714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":63043,"user_name":"拉马库斯阿尔德里奇","can_delete":false,"product_type":"c1","uid":1175519,"ip_address":"","ucode":"40BAA2A64485F0","user_header":"https://static001.geekbang.org/account/avatar/00/11/ef/df/c9240302.jpg","comment_is_top":false,"comment_ctime":1548235266,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548235266","product_id":100017301,"comment_content":"没搞懂这个 拉链是干嘛的为什么要维护它<br>仔细找了前面两篇关于散列表的文章中也没提到过拉链<br>维护一个双向链表来存储数据可以理解，这个维护一个拉链为处理散列冲突是怎么处理的<br>没想明白<br>求解求解","like_count":0},{"had_liked":false,"id":62708,"user_name":"泉","can_delete":false,"product_type":"c1","uid":1099760,"ip_address":"","ucode":"914709BE802A8D","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/f0/aa2e0749.jpg","comment_is_top":false,"comment_ctime":1548139116,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1548139116","product_id":100017301,"comment_content":"散列表和链表结合实现O(1)的插入，删除，查询。","like_count":0},{"had_liked":false,"id":61982,"user_name":"华","can_delete":false,"product_type":"c1","uid":1179374,"ip_address":"","ucode":"961A2FA7F6173F","user_header":"https://static001.geekbang.org/account/avatar/00/11/fe/ee/043e6630.jpg","comment_is_top":false,"comment_ctime":1547872614,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547872614","product_id":100017301,"comment_content":"1<br><br>一个链是刚刚我们提到的双向链表，另一个链是散列表中的拉链<br>，结合你的图也看不懂，老师能详解一下吗<br><br>","like_count":0},{"had_liked":false,"id":61602,"user_name":"Tattoo","can_delete":false,"product_type":"c1","uid":1036503,"ip_address":"","ucode":"CE926AC8582C96","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d0/d7/a09ef784.jpg","comment_is_top":false,"comment_ctime":1547733136,"is_pvip":true,"replies":[{"id":"23157","content":"key肯定是不变的。<br>双向链表和散列表是两个不搭噶的东西。<br>你可以看做是两个索引，你改变数据在一个索引中的位置，并不影响它在另一个索引中的位置。<br>","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1549179856,"ip_address":"","comment_id":61602,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1547733136","product_id":100017301,"comment_content":"有一个严重的问题想问一下老师：如果在访问一个页面之后将其移动到了双向链表的头部，那么key没变，下次通过 hash(key)，找到的下标还是原先的下标，这样岂不是会导致找不到对应的页面？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436925,"discussion_content":"key肯定是不变的。\n双向链表和散列表是两个不搭噶的东西。\n你可以看做是两个索引，你改变数据在一个索引中的位置，并不影响它在另一个索引中的位置。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549179856,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1542987,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","nickname":"行则将至","note":"","ucode":"DB972F2DF059C4","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575017,"discussion_content":"我理解是hNext那条线的key是不发生变化的，但是这个key的next要指向数量链表的tail了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654526849,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":61580,"user_name":"睡痴儿😑","can_delete":false,"product_type":"c1","uid":1187204,"ip_address":"","ucode":"750EF858EF2042","user_header":"https://static001.geekbang.org/account/avatar/00/12/1d/84/d0ec0064.jpg","comment_is_top":false,"comment_ctime":1547726870,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547726870","product_id":100017301,"comment_content":"第一个，不能。因为没有前一个的指针，无法对其进行删除和添加工作。<br>第二个，使用散列表和跳表共用的方式。","like_count":0},{"had_liked":false,"id":58997,"user_name":"halo","can_delete":false,"product_type":"c1","uid":1138057,"ip_address":"","ucode":"782892605CC855","user_header":"https://static001.geekbang.org/account/avatar/00/11/5d/89/93b837d6.jpg","comment_is_top":false,"comment_ctime":1547267527,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547267527","product_id":100017301,"comment_content":"有点想不明白，请问一下老师，为什么用了双向链表之后查找操作可以O(1)时间完成？","like_count":0},{"had_liked":false,"id":58465,"user_name":"刘大宇","can_delete":false,"product_type":"c1","uid":1200804,"ip_address":"","ucode":"A004F00DABBA62","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/a4/e9c39177.jpg","comment_is_top":false,"comment_ctime":1547086949,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547086949","product_id":100017301,"comment_content":"学得很痛快，老师讲得很好很细致，这课觉得很值","like_count":0},{"had_liked":false,"id":57624,"user_name":"aguan(^･ｪ･^)","can_delete":false,"product_type":"c1","uid":1107177,"ip_address":"","ucode":"04833EF2D18E1A","user_header":"https://static001.geekbang.org/account/avatar/00/10/e4/e9/0dd3829f.jpg","comment_is_top":false,"comment_ctime":1546852936,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546852936","product_id":100017301,"comment_content":"1、可以正常工作，在插入，删除等操作中，需要定义临时变量保存前驱（pre）的引用<br>2、参考文中提到的 redis有序集合中的内容<br>用积分将猎头对象构建成跳表结构，再用猎头ID将猎头对象构建成散列表结构","like_count":0},{"had_liked":false,"id":57194,"user_name":"crazyone","can_delete":false,"product_type":"c1","uid":1115042,"ip_address":"","ucode":"705E34642E41F5","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/a2/ceb37046.jpg","comment_is_top":false,"comment_ctime":1546679433,"is_pvip":false,"replies":[{"id":"21863","content":"class Node {<br>   int data; &#47;&#47; 数据放到这里，也可能不是int类型<br>   Node hnext; &#47;&#47; 散列表中拉链的hnext指针<br>   Node prev; &#47;&#47; 链表的prev、next指针<br>   Node next;<br>}","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1547710083,"ip_address":"","comment_id":57194,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546679433","product_id":100017301,"comment_content":"双向链表，利用hnext指向 散列表的元素，那散列表中，也会保存指向双向链表对应元素的引用吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435456,"discussion_content":"class Node {\n   int data; // 数据放到这里，也可能不是int类型\n   Node hnext; // 散列表中拉链的hnext指针\n   Node prev; // 链表的prev、next指针\n   Node next;\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547710083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57010,"user_name":"黄世仁","can_delete":false,"product_type":"c1","uid":1254911,"ip_address":"","ucode":"840C31DA4B5FAA","user_header":"","comment_is_top":false,"comment_ctime":1546600075,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546600075","product_id":100017301,"comment_content":"这个课程真的很棒，工作10多年了，算法一直是我心中的痛，看到了这个课后毫不犹豫的收入囊中，老师讲的通俗易懂。我也是初学Scala，打算用Scala把算法都实现一遍，即锻炼了算法，有熟悉了Scala语法，一举两得<br>刚刚用了将近2个小时的时间实现了这个课程所讲的LRU算法，请指正<br>https:&#47;&#47;github.com&#47;wangzheng0822&#47;algo&#47;pull&#47;215&#47;commits&#47;b639322dc565866c9769b2317cfc32a99e95b25e","like_count":0},{"had_liked":false,"id":54976,"user_name":"aguan(^･ｪ･^)","can_delete":false,"product_type":"c1","uid":1107177,"ip_address":"","ucode":"04833EF2D18E1A","user_header":"https://static001.geekbang.org/account/avatar/00/10/e4/e9/0dd3829f.jpg","comment_is_top":false,"comment_ctime":1545990598,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545990598","product_id":100017301,"comment_content":"老师好，我有个疑问<br>文中提到LRU算法散列实现，查找的时间复杂度“接近”是O(1),是不是在实际应用中数组后面带的链表的结点个数都是常量级的？","like_count":0},{"had_liked":false,"id":54608,"user_name":"刘榴","can_delete":false,"product_type":"c1","uid":1063491,"ip_address":"","ucode":"08C51E3CE77889","user_header":"https://static001.geekbang.org/account/avatar/00/10/3a/43/6abf3b7d.jpg","comment_is_top":false,"comment_ctime":1545913446,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545913446","product_id":100017301,"comment_content":"我想问老师一个问题:在建双向链表的时候为什么不是从拉链的最后一个节点串到下个槽中，而是从拉链的倒数第二个节点串到下个槽中？希望老师解答我的疑惑，谢谢","like_count":0},{"had_liked":false,"id":54417,"user_name":"ヾ(◍°∇°◍)ﾉﾞ","can_delete":false,"product_type":"c1","uid":1044175,"ip_address":"","ucode":"89545632BDA56E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJOBwR7MCVqwZbPA5RQ2mjUjd571jUXUcBCE7lY5vSMibWn8D5S4PzDZMaAhRPdnRBqYbVOBTJibhJg/132","comment_is_top":false,"comment_ctime":1545866081,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545866081","product_id":100017301,"comment_content":"关于最后的问题是不是可以利用类似linkedmap的有序实现。然后再加上跳表的结构上去就是redis的sortedmap了","like_count":0},{"had_liked":false,"id":53802,"user_name":"JRich","can_delete":false,"product_type":"c1","uid":1114901,"ip_address":"","ucode":"66AE9D61533960","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/15/293a185d.jpg","comment_is_top":false,"comment_ctime":1545729792,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545729792","product_id":100017301,"comment_content":"老师，为什么将散列表和链表（或者跳表）结合在一起使用，就能解决散列表按顺序遍历的问题呢？<br>","like_count":0},{"had_liked":false,"id":53106,"user_name":"谭棋钊","can_delete":false,"product_type":"c1","uid":1237976,"ip_address":"","ucode":"F7F982BE5978BA","user_header":"https://static001.geekbang.org/account/avatar/00/12/e3/d8/bc70f34a.jpg","comment_is_top":false,"comment_ctime":1545587816,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545587816","product_id":100017301,"comment_content":"老师在讲解的时候有提到LRU淘汰算法和Redis有序集合会使用的对应的数据结构知识，对于我这类职场新人来说根本不知道LRU和Redis，所以希望在以后的课程出现的一些名词希望老师大致说一下是什么？有什么用？","like_count":0},{"had_liked":false,"id":52943,"user_name":"wilson652033","can_delete":false,"product_type":"c1","uid":1350409,"ip_address":"","ucode":"7BA99858C65D02","user_header":"https://static001.geekbang.org/account/avatar/00/14/9b/09/e29c051a.jpg","comment_is_top":false,"comment_ctime":1545555757,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545555757","product_id":100017301,"comment_content":"LRU缓存<br>1.需要维护一个按照访问时间从大到小的有序排列的链表结构<br>2.若找到，就把它移动到链表尾部。<br><br>我的問題是<br>1.請問圖中的双向链表 好像透過前驱指针（prev）、后继指针（next）形成了一個環..這樣理解對嗎?<br>  所以是個循環链表<br>2.若找到，就把它移动到链表尾部 <br>  請問圖中的尾部在哪裡...<br>","like_count":0},{"had_liked":false,"id":52404,"user_name":"左胜利","can_delete":false,"product_type":"c1","uid":1327195,"ip_address":"","ucode":"E17B4F4285170D","user_header":"https://static001.geekbang.org/account/avatar/00/14/40/5b/3fe51d4a.jpg","comment_is_top":false,"comment_ctime":1545376223,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545376223","product_id":100017301,"comment_content":"课后思考<br>1、如果将双向链表修改成单链表，查找的复杂度仍然是O(1)，删除的复杂度为O(n),插入的时间复杂度是O(n)<br>2、以猎头id构建散列表，以积分构建跳表（用双向链表实现）","like_count":0},{"had_liked":false,"id":50823,"user_name":"匆匆","can_delete":false,"product_type":"c1","uid":1333414,"ip_address":"","ucode":"4DB39C6CD5743B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/H8NxrljQXliccaT5fjdXJQYS3ou3Z9ykAuKw6EgicicEA9L4jQLz3h85P0odgDSaK0cA9oTyUKibbiagdNvnHuuV5mQ/132","comment_is_top":false,"comment_ctime":1545050843,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545050843","product_id":100017301,"comment_content":"散列表总是和链表一起使用（案例如下）<br><br>LRU缓存淘汰算法：之前是只用链表将缓存串起来，当多一个缓存数据时先看缓存中有没有这个数据，有就移到表尾，然后删除表头，没有就直接移动到表尾，删除表头节点。时间O(n)。现在和散列表结合，即散列表和双向链表结合，双向链表里面多一个指针，这是和散列表相连的拉链，为了将其串再散列表中。这样查找、删除、添加的时间都是O(1)。<br><br>暂不做后面两个案例整理","like_count":0},{"had_liked":false,"id":50697,"user_name":"李小草","can_delete":false,"product_type":"c1","uid":1240476,"ip_address":"","ucode":"83DAA0BFDC2068","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/9c/7afa883f.jpg","comment_is_top":false,"comment_ctime":1545031312,"is_pvip":false,"replies":[{"id":"18333","content":"对的 👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545097991,"ip_address":"","comment_id":50697,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545031312","product_id":100017301,"comment_content":"每个元素会在两条链中这两条链分别是：next指针将所有元素串起来拉的链， 一个是散列表的拉链既散列表用的那个解决散列冲突的双向链表。不知道理解的对不对！还望老师指正！","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433064,"discussion_content":"对的 👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545097991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50677,"user_name":"李小草","can_delete":false,"product_type":"c1","uid":1240476,"ip_address":"","ucode":"83DAA0BFDC2068","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/9c/7afa883f.jpg","comment_is_top":false,"comment_ctime":1545028656,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545028656","product_id":100017301,"comment_content":"评论区的评论越来越少了！之前都看好久，现在很快就看完了！","like_count":0},{"had_liked":false,"id":49925,"user_name":"风羽星泉","can_delete":false,"product_type":"c1","uid":1198377,"ip_address":"","ucode":"CBC63AA00C5D70","user_header":"https://static001.geekbang.org/account/avatar/00/12/49/29/bbeccb9f.jpg","comment_is_top":false,"comment_ctime":1544790400,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544790400","product_id":100017301,"comment_content":"有些同学太厉害了","like_count":0},{"had_liked":false,"id":49812,"user_name":"唯她命","can_delete":false,"product_type":"c1","uid":1240398,"ip_address":"","ucode":"8F687E8D306840","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/4e/ef406442.jpg","comment_is_top":false,"comment_ctime":1544774509,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544774509","product_id":100017301,"comment_content":"为啥最新访问的节点要放在尾部，为啥链表尾部插入数据等，可以在 O(1) 的时间复杂度内完成<br>难道不该从头遍历的尾部吗","like_count":0},{"had_liked":false,"id":49120,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1544606755,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544606755","product_id":100017301,"comment_content":"LRU 缓存淘汰策略<br>散列表+双向链表 实现一个高效的支持LRU缓存淘汰算法的缓存系统原型：干得漂亮，这才是真的的学以致用<br>其他两个类似，第一回把我看懵了，感觉后面两个有点粗糙","like_count":0},{"had_liked":false,"id":47881,"user_name":"饭团","can_delete":false,"product_type":"c1","uid":1332557,"ip_address":"","ucode":"E24F240CC91BE8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erbY9UsqHZhhVoI69yXNibBBg0TRdUVsKLMg2UZ1R3NJxXdMicqceI5yhdKZ5Ad6CJYO0XpFHlJzIYQ/132","comment_is_top":false,"comment_ctime":1544244687,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544244687","product_id":100017301,"comment_content":"我怎么觉得要想删除的时候复杂度达到O(1)，那个node也需要保存一个hpre指针啊！","like_count":0},{"had_liked":false,"id":47169,"user_name":"小情绪","can_delete":false,"product_type":"c1","uid":1020311,"ip_address":"","ucode":"92D8081DB8DB45","user_header":"https://static001.geekbang.org/account/avatar/00/0f/91/97/3762ca10.jpg","comment_is_top":false,"comment_ctime":1544066854,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544066854","product_id":100017301,"comment_content":"第一个问题，双链表改成单链表一定是可以的，只不过在删除操作中，查找的时候都需要记录一个节点数据、而这个节点数据就是需要删的prev节点。","like_count":0},{"had_liked":false,"id":46020,"user_name":"范特西","can_delete":false,"product_type":"c1","uid":1213367,"ip_address":"","ucode":"E16372285CB6BB","user_header":"https://static001.geekbang.org/account/avatar/00/12/83/b7/971a00c7.jpg","comment_is_top":false,"comment_ctime":1543834285,"is_pvip":false,"replies":[{"id":"16531","content":"是的 用链表解决冲突的散列表 你应该知道张什么样子吧。这里只是又在每个元素上多了一个next指针 通过next指针将所有元素串了起来 所以每个元素处在两个链中 一个是散列表的拉链 一个是next指针拉的链","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543887997,"ip_address":"","comment_id":46020,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1543834285","product_id":100017301,"comment_content":"一个节点两个拉链，如果散列冲突找到了第一个hnext然后next是另一个散列函数key呢(根据老师的图，next指向不一定是同一个散列函数key)，是否一个散列得到key值也维护一个链表？没有太懂还望老师指点🤣","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431306,"discussion_content":"是的 用链表解决冲突的散列表 你应该知道张什么样子吧。这里只是又在每个元素上多了一个next指针 通过next指针将所有元素串了起来 所以每个元素处在两个链中 一个是散列表的拉链 一个是next指针拉的链","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543887997,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":45126,"user_name":"SIYI","can_delete":false,"product_type":"c1","uid":1238567,"ip_address":"","ucode":"FB3C629FF6A2C7","user_header":"https://static001.geekbang.org/account/avatar/00/12/e6/27/1c43bd65.jpg","comment_is_top":false,"comment_ctime":1543548310,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543548310","product_id":100017301,"comment_content":"老师，这一节里结合使用的链表都是有序链表是吧","like_count":0},{"had_liked":false,"id":45039,"user_name":"ning~","can_delete":false,"product_type":"c1","uid":1108374,"ip_address":"","ucode":"0ED5894F05BF90","user_header":"https://static001.geekbang.org/account/avatar/00/10/e9/96/38f54972.jpg","comment_is_top":false,"comment_ctime":1543541112,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543541112","product_id":100017301,"comment_content":"第一个问题，我感觉可以解决，通过快慢指针来解决删除问题","like_count":0},{"had_liked":false,"id":45008,"user_name":"想吃鱼","can_delete":false,"product_type":"c1","uid":1243314,"ip_address":"","ucode":"2AD55276707E97","user_header":"https://static001.geekbang.org/account/avatar/00/12/f8/b2/8df7f270.jpg","comment_is_top":false,"comment_ctime":1543538992,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543538992","product_id":100017301,"comment_content":"关于数组 链表 散列这几文章，我觉得老师写的文字配上图还是比较好理解的，比起其他书上写的理解起来要流畅不少，感谢","like_count":0},{"had_liked":false,"id":44625,"user_name":"海青","can_delete":false,"product_type":"c1","uid":1135113,"ip_address":"","ucode":"2ACBF25183AF30","user_header":"https://static001.geekbang.org/account/avatar/00/11/52/09/2b2de7e4.jpg","comment_is_top":false,"comment_ctime":1543466291,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543466291","product_id":100017301,"comment_content":"根据Smallfly同学第三点，我觉得可以通过双链表实现的跳表来找到第x名，比较x与y大小决定查找下一名积分对象，直到积分达到y","like_count":0},{"had_liked":false,"id":43321,"user_name":"蓝艺","can_delete":false,"product_type":"c1","uid":1239640,"ip_address":"","ucode":"FC81CC63C8F245","user_header":"https://static001.geekbang.org/account/avatar/00/12/ea/58/2aa56c18.jpg","comment_is_top":false,"comment_ctime":1543212637,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543212637","product_id":100017301,"comment_content":"用go写的lru缓存淘汰算法，散列表加双向链表实现：https:&#47;&#47;github.com&#47;lanyilee&#47;LRU","like_count":0},{"had_liked":false,"id":43051,"user_name":"qinggeouye","can_delete":false,"product_type":"c1","uid":1251536,"ip_address":"","ucode":"5B53EEDD7BEC9C","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/d0/49b06424.jpg","comment_is_top":false,"comment_ctime":1543150660,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543150660","product_id":100017301,"comment_content":"我的理解，如有不对，请老师指正。多谢。<br>散列表：利用了数组下标快速查找的特点；键值 key 是有序的，而存储的分值 score 是无序的。<br>链表（跳表）：分值 score 可以排成有序，可以查找位于某个分值区间的结点。","like_count":0},{"had_liked":false,"id":41957,"user_name":"路飞","can_delete":false,"product_type":"c1","uid":1257927,"ip_address":"","ucode":"8D9AD0FE66625A","user_header":"https://static001.geekbang.org/account/avatar/00/13/31/c7/ed568306.jpg","comment_is_top":false,"comment_ctime":1542880708,"is_pvip":false,"replies":[{"id":"15059","content":"可以参考lru的那个图","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542884908,"ip_address":"","comment_id":41957,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542880708","product_id":100017301,"comment_content":"讲LinkedHashMap的配图里只有双向链表结构没有体现散列表的结构啊","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429955,"discussion_content":"可以参考lru的那个图","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542884908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":41756,"user_name":"铁鸟","can_delete":false,"product_type":"c1","uid":1227710,"ip_address":"","ucode":"D89CDBEA75BD40","user_header":"https://static001.geekbang.org/account/avatar/00/12/bb/be/0f96379d.jpg","comment_is_top":false,"comment_ctime":1542848960,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542848960","product_id":100017301,"comment_content":"一个节点会存在两条拉链中，一条是双向链表，另一条是散列表中的拉链”，怎么想都不懂呀？求解答!<br><br><br>","like_count":0},{"had_liked":false,"id":40132,"user_name":"樱桃子77","can_delete":false,"product_type":"c1","uid":1260146,"ip_address":"","ucode":"676894101A6652","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJicwphCoQ0S1DaibWNarUJq3DrGOeADY02AreVbKCLkm0PWJmZR0f1rMrrXDRzOwLCmIQbqeibQ4uHQ/132","comment_is_top":false,"comment_ctime":1542515131,"is_pvip":false,"discussion_count":0,"race_medal":2,"score":"1542515131","product_id":100017301,"comment_content":"在散列表和链表相结合的情况下，最差的复杂度仍然是O(N)，对吧？最坏的情况：若散列冲突太多，所有元素集中于一个散列元素指向的双向链表中。。。","like_count":0},{"had_liked":false,"id":39212,"user_name":"方磊","can_delete":false,"product_type":"c1","uid":1233640,"ip_address":"","ucode":"AB9B3B621344E8","user_header":"https://static001.geekbang.org/account/avatar/00/12/d2/e8/3f0106cf.jpg","comment_is_top":false,"comment_ctime":1542210374,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542210374","product_id":100017301,"comment_content":"这节课上的用散列表结合双向链表实现LRU算法这个例子。我理解的LRU算法是按照最近最常使用来把数据排序，而后根据最近最常使用的顺序来遍历查找。可是在例子中，如果将 data 来计算散列值，以此来构建散列表的话，实质上是不用关心哪个元素是最近最常使用的？也就是说，这样的处理实质上是LRU的变种？甚至都不需要再将查找出来的数据移到双向链表的最后了？","like_count":0},{"had_liked":false,"id":37455,"user_name":"L   YT","can_delete":false,"product_type":"c1","uid":1237494,"ip_address":"","ucode":"A5D57302E40204","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/f6/6576162a.jpg","comment_is_top":false,"comment_ctime":1541594446,"is_pvip":false,"replies":[{"id":"13449","content":"结合着图看下呢","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541641408,"ip_address":"","comment_id":37455,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1541594446","product_id":100017301,"comment_content":"“一个节点会存在两条拉链中，一条是双向链表，另一条是散列表中的拉链”，怎么想都不懂呀。。。。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428344,"discussion_content":"结合着图看下呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541641408,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37325,"user_name":"🌀🐑hfy🐣","can_delete":false,"product_type":"c1","uid":1254367,"ip_address":"","ucode":"8A7E4BDC46CB35","user_header":"https://static001.geekbang.org/account/avatar/00/13/23/df/367f2c75.jpg","comment_is_top":false,"comment_ctime":1541551142,"is_pvip":false,"replies":[{"id":"13456","content":"散列表保存每个桶对应链表的头指针","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541642218,"ip_address":"","comment_id":37325,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1541551142","product_id":100017301,"comment_content":"请问老师散列表和双向链表的图中，散列表保存什么？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428292,"discussion_content":"散列表保存每个桶对应链表的头指针","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541642218,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37279,"user_name":"空白格","can_delete":false,"product_type":"c1","uid":1235765,"ip_address":"","ucode":"472F5456892E77","user_header":"https://static001.geekbang.org/account/avatar/00/12/db/35/f3b78d18.jpg","comment_is_top":false,"comment_ctime":1541516169,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541516169","product_id":100017301,"comment_content":"实现过程中，首先查找到元素的位置后，需要把他移动到双向链表的尾部，那这样的情况下不需要考虑双向链表的尾部这一行 是否对应的hash（key）计算出来的值了吗？就是该元素 hash（key） 计算的值一定会对应原来链表尾部对应的hash（key）的值吗？ 不知道我说明白了没有~<br>请指教","like_count":0},{"had_liked":false,"id":37127,"user_name":"远方不远","can_delete":false,"product_type":"c1","uid":1222940,"ip_address":"","ucode":"4549C59EF0E0B7","user_header":"https://static001.geekbang.org/account/avatar/00/12/a9/1c/3d9c3e68.jpg","comment_is_top":false,"comment_ctime":1541465193,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541465193","product_id":100017301,"comment_content":"使用散列表和链表实现LRU，其中散列表为了查找数据更快，链表为了解决冲突。那删除链头节点和插入链尾结点，都是通过hnext操作的吗？","like_count":0},{"had_liked":false,"id":37116,"user_name":"吴宇晨","can_delete":false,"product_type":"c1","uid":1199968,"ip_address":"","ucode":"F8F45B7067DF6D","user_header":"https://static001.geekbang.org/account/avatar/00/12/4f/60/049a20e9.jpg","comment_is_top":false,"comment_ctime":1541464633,"is_pvip":false,"replies":[{"id":"13241","content":"是的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541467645,"ip_address":"","comment_id":37116,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1541464633","product_id":100017301,"comment_content":"redis中每个节点有一个span跨度字段，来计算节点的排名","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428178,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541467645,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37106,"user_name":"blt","can_delete":false,"product_type":"c1","uid":1260301,"ip_address":"","ucode":"06754D3ADD1EC1","user_header":"https://static001.geekbang.org/account/avatar/00/13/3b/0d/dcfbbfc4.jpg","comment_is_top":false,"comment_ctime":1541463928,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541463928","product_id":100017301,"comment_content":"有个博弈的问题请教下，我有100城市的客户数和平均价格，现在有10个企业，每个企业有100万的折扣预算，如何对每个城市打折扣获得最多客户数，客户数获取公式是，（客户数*平均价-折扣）&#47;客户数*-1.09次方，如果某个企业没打折扣则用平均价*-1.09次方，然后按这个数的占比计算客户数，讲个方法或有什么参考的信息，我觉得博弈这块最重要，谢谢","like_count":0},{"had_liked":false,"id":37028,"user_name":"insist","can_delete":false,"product_type":"c1","uid":1054536,"ip_address":"","ucode":"1EE2800A900BA7","user_header":"https://static001.geekbang.org/account/avatar/00/10/17/48/3ab39c86.jpg","comment_is_top":false,"comment_ctime":1541425811,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541425811","product_id":100017301,"comment_content":"1、文中讲的几个例子，把双链表改成单链表不可行，删除操作要找到上一个节点需要遍历链表，时间复杂度退化成O(n)。<br>2、以猎头的ID为key，积分为value构建一个散列表，这样就可以根据猎头ID快速查询、删除、更新猎头的积分。再一猎头积分为key，构建一个跳表，这样就可以快速查找积分在某个区间范围内的猎头ID列表。","like_count":0},{"had_liked":false,"id":37014,"user_name":"峰","can_delete":false,"product_type":"c1","uid":1056019,"ip_address":"","ucode":"C53CB64E8E7D19","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg","comment_is_top":false,"comment_ctime":1541421496,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1541421496","product_id":100017301,"comment_content":"思考题第一题，让散列表的指向不再是原节点，而是其前驱节点，就可以在相同的时间复杂度内支持原先的操作。<br>第二题，主要是排序区间怎么支持，没想出来。。。。","like_count":0},{"had_liked":false,"id":37010,"user_name":"komo0104","can_delete":false,"product_type":"c1","uid":1084059,"ip_address":"","ucode":"90C40C69F7CC93","user_header":"https://static001.geekbang.org/account/avatar/00/10/8a/9b/feb182d3.jpg","comment_is_top":false,"comment_ctime":1541420841,"is_pvip":false,"replies":[{"id":"13249","content":"是要维护尾指针","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541467945,"ip_address":"","comment_id":37010,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1541420841","product_id":100017301,"comment_content":"有一个问题。<br>LRU算法中，查找的一个数据是O(1)，然后将他移动到尾部为什么还是O(1)呢。<br>除非也维护了一个指向尾部的指针？不然找到尾部的复杂度是O(n)呀。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428121,"discussion_content":"是要维护尾指针","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541467945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36957,"user_name":"longer","can_delete":false,"product_type":"c1","uid":1105881,"ip_address":"","ucode":"5D275DE2034E4D","user_header":"https://static001.geekbang.org/account/avatar/00/10/df/d9/d99c871d.jpg","comment_is_top":false,"comment_ctime":1541404734,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541404734","product_id":100017301,"comment_content":"1、如果改成单链表:对插入和删除有影响,因为单链表的插入和删除时间复杂度为O(n)，无法做到快速插入和删除；但是对查找没有影响，因为查找还是走的散列表，时间复杂度为O(1)。<br>2、(猎头Id， 积分)构建散列表，以猎头id做散列，分数做链表进行排序。","like_count":0},{"had_liked":false,"id":36923,"user_name":"雪无痕","can_delete":false,"product_type":"c1","uid":1235903,"ip_address":"","ucode":"261357711A568E","user_header":"https://static001.geekbang.org/account/avatar/00/12/db/bf/d990f851.jpg","comment_is_top":false,"comment_ctime":1541389824,"is_pvip":false,"replies":[{"id":"13259","content":"是的 已改正 多谢🙏","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541468290,"ip_address":"","comment_id":36923,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1541389824","product_id":100017301,"comment_content":"java LinkedHashMap讲解中的第二个链表图和第三个链表图中的（3，11）节点写错了，应该是（3，26）","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428086,"discussion_content":"是的 已改正 多谢🙏","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541468290,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36919,"user_name":"刘远通","can_delete":false,"product_type":"c1","uid":1253307,"ip_address":"","ucode":"4D3EE819E4B235","user_header":"https://static001.geekbang.org/account/avatar/00/13/1f/bb/c488d5db.jpg","comment_is_top":false,"comment_ctime":1541387802,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541387802","product_id":100017301,"comment_content":"散列表 按照key(一般是文字) 映射成数值  方便查找<br>score 链表 一般是 按顺序遍历 可以使用红黑树方式分层加速","like_count":0},{"had_liked":false,"id":36899,"user_name":"NeverMore","can_delete":false,"product_type":"c1","uid":1228498,"ip_address":"","ucode":"582698D772810D","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/d2/3d88cb8e.jpg","comment_is_top":false,"comment_ctime":1541382509,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541382509","product_id":100017301,"comment_content":"对于第一题，我觉得是可以的，每次查找时同时增加一个变量为前驱节点，多了一个O(1)的空间复杂度而已<br>第二题，类似于举的例子，通过散列表和链表或者调表等，都可以实现","like_count":0},{"had_liked":false,"id":36890,"user_name":"『LHCY』","can_delete":false,"product_type":"c1","uid":1188449,"ip_address":"","ucode":"A8B5E0467B5F25","user_header":"https://static001.geekbang.org/account/avatar/00/12/22/61/bbfb2d4a.jpg","comment_is_top":false,"comment_ctime":1541381361,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541381361","product_id":100017301,"comment_content":"1.不能，如果是单向链表，通过hash找到这个节点时，并不知道这个节点的上一个节点，在删除和移节点时还要从头遍历链表。<br>2.一个存储id和得分的哈希表，一个存储按照得分排序的猎头对象的堆。<br>","like_count":0},{"had_liked":false,"id":36888,"user_name":"拉欧","can_delete":false,"product_type":"c1","uid":1206605,"ip_address":"","ucode":"40996A8093A95F","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/4d/81c44f45.jpg","comment_is_top":false,"comment_ctime":1541381190,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541381190","product_id":100017301,"comment_content":"1.双向链表的插入和删除是O(1),单向链表因为要查额外查询前驱节点，所以是O(N),所以不合适<br>2.维护两个数据结构，第一个是key为id,value为score的hashmap，第二个是key为score，value为ID的hashmap。","like_count":0},{"had_liked":false,"id":36884,"user_name":"城","can_delete":false,"product_type":"c1","uid":1035315,"ip_address":"","ucode":"32C4FCE1944000","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cc/33/19f150d9.jpg","comment_is_top":false,"comment_ctime":1541380395,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541380395","product_id":100017301,"comment_content":"1.如果将双向链表改成单向链表，则无法正常工作，因为单向链表没有指向前驱节点的指针，在插入时，或许和双向链表一样，但是删除时，就要遍历单链表了。<br>2.考虑到有根据积分范围查询符合条件的猎头集合，因此选择跳表，要支持快速查找、删除、更新，数据结构再加上散列表。最后根据排名选择x-y排名的猎头，我简单的使用遍历。","like_count":0},{"had_liked":false,"id":36877,"user_name":"成楠Peter","can_delete":false,"product_type":"c1","uid":1252977,"ip_address":"","ucode":"4D13E7368D8CF2","user_header":"https://static001.geekbang.org/account/avatar/00/13/1e/71/9dcbe6c4.jpg","comment_is_top":false,"comment_ctime":1541380012,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541380012","product_id":100017301,"comment_content":"课后思考1，能用单向链表时间，不过每次删除操作，就需要重新遍历所有单向链表，时间复杂度会提高。","like_count":0}]}