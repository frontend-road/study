{"id":18035,"title":"13 | 结构体及其方法的使用法门","content":"<p>我们都知道，结构体类型表示的是实实在在的数据结构。一个结构体类型可以包含若干个字段，每个字段通常都需要有确切的名字和类型。</p><h2>前导内容：结构体类型基础知识</h2><p>当然了，结构体类型也可以不包含任何字段，这样并不是没有意义的，因为我们还可以为类型关联上一些方法，这里你可以把方法看做是函数的特殊版本。</p><p>函数是独立的程序实体。我们可以声明有名字的函数，也可以声明没名字的函数，还可以把它们当做普通的值传来传去。我们能把具有相同签名的函数抽象成独立的函数类型，以作为一组输入、输出（或者说一类逻辑组件）的代表。</p><p>方法却不同，它需要有名字，不能被当作值来看待，最重要的是，它必须隶属于某一个类型。方法所属的类型会通过其声明中的接收者（receiver）声明体现出来。</p><p>接收者声明就是在关键字<code>func</code>和方法名称之间的圆括号包裹起来的内容，其中必须包含确切的名称和类型字面量。</p><p><strong>接收者的类型其实就是当前方法所属的类型，而接收者的名称，则用于在当前方法中引用它所属的类型的当前值。</strong></p><p>我们举个例子来看一下。</p><pre><code>// AnimalCategory 代表动物分类学中的基本分类法。\ntype AnimalCategory struct {\n\tkingdom string // 界。\n\tphylum string // 门。\n\tclass  string // 纲。\n\torder  string // 目。\n\tfamily string // 科。\n\tgenus  string // 属。\n\tspecies string // 种。\n}\n\nfunc (ac AnimalCategory) String() string {\n\treturn fmt.Sprintf(&quot;%s%s%s%s%s%s%s&quot;,\n\t\tac.kingdom, ac.phylum, ac.class, ac.order,\n\t\tac.family, ac.genus, ac.species)\n}\n</code></pre><p>结构体类型<code>AnimalCategory</code>代表了动物的基本分类法，其中有7个<code>string</code>类型的字段，分别表示各个等级的分类。</p><!-- [[[read_end]]] --><p>下边有个名叫<code>String</code>的方法，从它的接收者声明可以看出它隶属于<code>AnimalCategory</code>类型。</p><p>通过该方法的接收者名称<code>ac</code>，我们可以在其中引用到当前值的任何一个字段，或者调用到当前值的任何一个方法（也包括<code>String</code>方法自己）。</p><p>这个<code>String</code>方法的功能是提供当前值的字符串表示形式，其中的各个等级分类会按照从大到小的顺序排列。使用时，我们可以这样表示：</p><pre><code>category := AnimalCategory{species: &quot;cat&quot;}\nfmt.Printf(&quot;The animal category: %s\\n&quot;, category)\n</code></pre><p>这里，我用字面量初始化了一个<code>AnimalCategory</code>类型的值，并把它赋给了变量<code>category</code>。为了不喧宾夺主，我只为其中的<code>species</code>字段指定了字符串值<code>\"cat\"</code>，该字段代表最末级分类“种”。</p><p>在Go语言中，我们可以通过为一个类型编写名为<code>String</code>的方法，来自定义该类型的字符串表示形式。这个<code>String</code>方法不需要任何参数声明，但需要有一个<code>string</code>类型的结果声明。</p><p>正因为如此，我在调用<code>fmt.Printf</code>函数时，使用占位符<code>%s</code>和<code>category</code>值本身就可以打印出后者的字符串表示形式，而无需显式地调用它的<code>String</code>方法。</p><p><code>fmt.Printf</code>函数会自己去寻找它。此时的打印内容会是<code>The animal category: cat</code>。显而易见，<code>category</code>的<code>String</code>方法成功地引用了当前值的所有字段。</p><blockquote>\n<p><span class=\"reference\">方法隶属的类型其实并不局限于结构体类型，但必须是某个自定义的数据类型，并且不能是任何接口类型。</span></p>\n<p><span class=\"reference\">一个数据类型关联的所有方法，共同组成了该类型的方法集合。同一个方法集合中的方法不能出现重名。并且，如果它们所属的是一个结构体类型，那么它们的名称与该类型中任何字段的名称也不能重复。</span></p>\n<p><span class=\"reference\">我们可以把结构体类型中的一个字段看作是它的一个属性或者一项数据，再把隶属于它的一个方法看作是附加在其中数据之上的一个能力或者一项操作。将属性及其能力（或者说数据及其操作）封装在一起，是面向对象编程（object-oriented programming）的一个主要原则。</span></p>\n<p><span class=\"reference\">Go语言摄取了面向对象编程中的很多优秀特性，同时也推荐这种封装的做法。从这方面看，Go语言其实是支持面向对象编程的，但它选择摒弃了一些在实际运用过程中容易引起程序开发者困惑的特性和规则。</span></p>\n</blockquote><p>现在，让我们再把目光放到结构体类型的字段声明上。我们来看下面的代码：</p><pre><code>type Animal struct {\n\tscientificName string // 学名。\n\tAnimalCategory    // 动物基本分类。\n}\n</code></pre><p>我声明了一个结构体类型，名叫<code>Animal</code>。它有两个字段。一个是<code>string</code>类型的字段<code>scientificName</code>，代表了动物的学名。而另一个字段声明中只有<code>AnimalCategory</code>，它正是我在前面编写的那个结构体类型的名字。这是什么意思呢？</p><p><strong>那么，我们今天的问题是：<code>Animal</code>类型中的字段声明<code>AnimalCategory</code>代表了什么？</strong></p><p>更宽泛地讲，如果结构体类型的某个字段声明中只有一个类型名，那么该字段代表了什么？</p><p><strong>这个问题的典型回答是</strong>：字段声明<code>AnimalCategory</code>代表了<code>Animal</code>类型的一个嵌入字段。Go语言规范规定，如果一个字段的声明中只有字段的类型名而没有字段的名称，那么它就是一个嵌入字段，也可以被称为匿名字段。我们可以通过此类型变量的名称后跟“.”，再后跟嵌入字段类型的方式引用到该字段。也就是说，嵌入字段的类型既是类型也是名称。</p><h2>问题解析</h2><p>说到引用结构体的嵌入字段，<code>Animal</code>类型有个方法叫<code>Category</code>，它是这么写的：</p><pre><code>func (a Animal) Category() string {\n\treturn a.AnimalCategory.String()\n}\n</code></pre><p><code>Category</code>方法的接收者类型是<code>Animal</code>，接收者名称是<code>a</code>。在该方法中，我通过表达式<code>a.AnimalCategory</code>选择到了<code>a</code>的这个嵌入字段，然后又选择了该字段的<code>String</code>方法并调用了它。</p><p>顺便提一下，在某个代表变量的标识符的右边加“.”，再加上字段名或方法名的表达式被称为选择表达式，它用来表示选择了该变量的某个字段或者方法。</p><p>这是Go语言规范中的说法，与“引用结构体的某某字段”或“调用结构体的某某方法”的说法是相通的。我在以后会混用这两种说法。</p><p>实际上，把一个结构体类型嵌入到另一个结构体类型中的意义不止如此。嵌入字段的方法集合会被无条件地合并进被嵌入类型的方法集合中。例如下面这种：</p><pre><code>animal := Animal{\n\tscientificName: &quot;American Shorthair&quot;,\n\tAnimalCategory: category,\n}\nfmt.Printf(&quot;The animal: %s\\n&quot;, animal)\n</code></pre><p>我声明了一个<code>Animal</code>类型的变量<code>animal</code>并对它进行初始化。我把字符串值<code>\"American Shorthair\"</code>赋给它的字段<code>scientificName</code>，并把前面声明过的变量<code>category</code>赋给它的嵌入字段<code>AnimalCategory</code>。</p><p>我在后面使用<code>fmt.Printf</code>函数和<code>%s</code>占位符试图打印<code>animal</code>的字符串表示形式，相当于调用<code>animal</code>的<code>String</code>方法。虽然我们还没有为<code>Animal</code>类型编写<code>String</code>方法，但这样做是没问题的。因为在这里，嵌入字段<code>AnimalCategory</code>的<code>String</code>方法会被当做<code>animal</code>的方法调用。</p><p><strong>那如果我也为<code>Animal</code>类型编写一个<code>String</code>方法呢？这里会调用哪一个呢？</strong></p><p>答案是，<code>animal</code>的<code>String</code>方法会被调用。这时，我们说，嵌入字段<code>AnimalCategory</code>的<code>String</code>方法被“屏蔽”了。注意，只要名称相同，无论这两个方法的签名是否一致，被嵌入类型的方法都会“屏蔽”掉嵌入字段的同名方法。</p><p>类似的，由于我们同样可以像访问被嵌入类型的字段那样，直接访问嵌入字段的字段，所以如果这两个结构体类型里存在同名的字段，那么嵌入字段中的那个字段一定会被“屏蔽”。这与我们在前面讲过的，可重名变量之间可能存在的“屏蔽”现象很相似。</p><p>正因为嵌入字段的字段和方法都可以“嫁接”到被嵌入类型上，所以即使在两个同名的成员一个是字段，另一个是方法的情况下，这种“屏蔽”现象依然会存在。</p><p>不过，即使被屏蔽了，我们仍然可以通过链式的选择表达式，选择到嵌入字段的字段或方法，就像我在<code>Category</code>方法中所做的那样。这种“屏蔽”其实还带来了一些好处。我们看看下面这个<code>Animal</code>类型的<code>String</code>方法的实现：</p><pre><code>func (a Animal) String() string {\n\treturn fmt.Sprintf(&quot;%s (category: %s)&quot;,\n\t\ta.scientificName, a.AnimalCategory)\n}\n</code></pre><p>在这里，我们把对嵌入字段的<code>String</code>方法的调用结果融入到了<code>Animal</code>类型的同名方法的结果中。这种将同名方法的结果逐层“包装”的手法是很常见和有用的，也算是一种惯用法了。</p><p><img src=\"https://static001.geekbang.org/resource/image/47/b2/471b42767d0c82af8acd22c13dfd33b2.png?wh=1920*941\" alt=\"\"><br>\n（结构体类型中的嵌入字段）</p><p><strong>最后，我还要提一下多层嵌入的问题。</strong>也就是说，嵌入字段本身也有嵌入字段的情况。请看我声明的<code>Cat</code>类型：</p><pre><code>type Cat struct {\n\tname string\n\tAnimal\n}\n\nfunc (cat Cat) String() string {\n\treturn fmt.Sprintf(&quot;%s (category: %s, name: %q)&quot;,\n\t\tcat.scientificName, cat.Animal.AnimalCategory, cat.name)\n}\n</code></pre><p>结构体类型<code>Cat</code>中有一个嵌入字段<code>Animal</code>，而<code>Animal</code>类型还有一个嵌入字段<code>AnimalCategory</code>。</p><p>在这种情况下，“屏蔽”现象会以嵌入的层级为依据，嵌入层级越深的字段或方法越可能被“屏蔽”。</p><p>例如，当我们调用<code>Cat</code>类型值的<code>String</code>方法时，如果该类型确有<code>String</code>方法，那么嵌入字段<code>Animal</code>和<code>AnimalCategory</code>的<code>String</code>方法都会被“屏蔽”。</p><p>如果该类型没有<code>String</code>方法，那么嵌入字段<code>Animal</code>的<code>String</code>方法会被调用，而它的嵌入字段<code>AnimalCategory</code>的<code>String</code>方法仍然会被屏蔽。</p><p>只有当<code>Cat</code>类型和<code>Animal</code>类型都没有<code>String</code>方法的时候，<code>AnimalCategory</code>的<code>String</code>方法菜会被调用。</p><p>最后的最后，如果处于同一个层级的多个嵌入字段拥有同名的字段或方法，那么从被嵌入类型的值那里，选择此名称的时候就会引发一个编译错误，因为编译器无法确定被选择的成员到底是哪一个。</p><p>以上关于嵌入字段的所有示例都在demo29.go中，希望能对你有所帮助。</p><h2>知识扩展</h2><p><strong>问题1：Go语言是用嵌入字段实现了继承吗？</strong></p><p>这里强调一下，Go语言中根本没有继承的概念，它所做的是通过嵌入字段的方式实现了类型之间的组合。这样做的具体原因和理念请见Go语言官网的FAQ中的<a href=\"https://golang.org/doc/faq#inheritance\">Why is there no type inheritance?</a>。</p><p>简单来说，面向对象编程中的继承，其实是通过牺牲一定的代码简洁性来换取可扩展性，而且这种可扩展性是通过侵入的方式来实现的。</p><p>类型之间的组合采用的是非声明的方式，我们不需要显式地声明某个类型实现了某个接口，或者一个类型继承了另一个类型。</p><p>同时，类型组合也是非侵入式的，它不会破坏类型的封装或加重类型之间的耦合。</p><p>我们要做的只是把类型当做字段嵌入进来，然后坐享其成地使用嵌入字段所拥有的一切。如果嵌入字段有哪里不合心意，我们还可以用“包装”或“屏蔽”的方式去调整和优化。</p><p>另外，类型间的组合也是灵活的，我们总是可以通过嵌入字段的方式把一个类型的属性和能力“嫁接”给另一个类型。</p><p>这时候，被嵌入类型也就自然而然地实现了嵌入字段所实现的接口。再者，组合要比继承更加简洁和清晰，Go语言可以轻而易举地通过嵌入多个字段来实现功能强大的类型，却不会有多重继承那样复杂的层次结构和可观的管理成本。</p><p>接口类型之间也可以组合。在Go语言中，接口类型之间的组合甚至更加常见，我们常常以此来扩展接口定义的行为或者标记接口的特征。与此有关的内容我在下一篇文章中再讲。</p><p>在我面试过的众多Go工程师中，有很多人都在说“Go语言用嵌入字段实现了继承”，而且深信不疑。</p><p>要么是他们还在用其他编程语言的视角和理念来看待Go语言，要么就是受到了某些所谓的“Go语言教程”的误导。每当这时，我都忍不住当场纠正他们，并建议他们去看看官网上的解答。</p><p><strong>问题2：值方法和指针方法都是什么意思，有什么区别？</strong></p><p>我们都知道，方法的接收者类型必须是某个自定义的数据类型，而且不能是接口类型或接口的指针类型。所谓的值方法，就是接收者类型是非指针的自定义数据类型的方法。</p><p>比如，我们在前面为<code>AnimalCategory</code>、<code>Animal</code>以及<code>Cat</code>类型声明的那些方法都是值方法。就拿<code>Cat</code>来说，它的<code>String</code>方法的接收者类型就是<code>Cat</code>，一个非指针类型。那什么叫指针类型呢？请看这个方法：</p><pre><code>func (cat *Cat) SetName(name string) {\n\tcat.name = name\n}\n</code></pre><p>方法<code>SetName</code>的接收者类型是<code>*Cat</code>。<code>Cat</code>左边再加个<code>*</code>代表的就是<code>Cat</code>类型的指针类型。</p><p>这时，<code>Cat</code>可以被叫做<code>*Cat</code>的基本类型。你可以认为这种指针类型的值表示的是指向某个基本类型值的指针。</p><p>我们可以通过把取值操作符<code>*</code>放在这样一个指针值的左边来组成一个取值表达式，以获取该指针值指向的基本类型值，也可以通过把取址操作符<code>&amp;</code>放在一个可寻址的基本类型值的左边来组成一个取址表达式，以获取该基本类型值的指针值。</p><p>所谓的指针方法，就是接收者类型是上述指针类型的方法。</p><p>那么值方法和指针方法之间有什么不同点呢？它们的不同如下所示。</p><ol>\n<li>\n<p>值方法的接收者是该方法所属的那个类型值的一个副本。我们在该方法内对该副本的修改一般都不会体现在原值上，除非这个类型本身是某个引用类型（比如切片或字典）的别名类型。<br>\n<br> 而指针方法的接收者，是该方法所属的那个基本类型值的指针值的一个副本。我们在这样的方法内对该副本指向的值进行修改，却一定会体现在原值上。<br></p>\n</li>\n<li>\n<p>一个自定义数据类型的方法集合中仅会包含它的所有值方法，而该类型的指针类型的方法集合却囊括了前者的所有方法，包括所有值方法和所有指针方法。<br><br>\n严格来讲，我们在这样的基本类型的值上只能调用到它的值方法。但是，Go语言会适时地为我们进行自动地转译，使得我们在这样的值上也能调用到它的指针方法。<br><br>\n比如，在<code>Cat</code>类型的变量<code>cat</code>之上，之所以我们可以通过<code>cat.SetName(\"monster\")</code>修改猫的名字，是因为Go语言把它自动转译为了<code>(&amp;cat).SetName(\"monster\")</code>，即：先取<code>cat</code>的指针值，然后在该指针值上调用<code>SetName</code>方法。</p>\n</li>\n<li>\n<p>在后边你会了解到，一个类型的方法集合中有哪些方法与它能实现哪些接口类型是息息相关的。如果一个基本类型和它的指针类型的方法集合是不同的，那么它们具体实现的接口类型的数量就也会有差异，除非这两个数量都是零。<br><br>\n比如，一个指针类型实现了某某接口类型，但它的基本类型却不一定能够作为该接口的实现类型。</p>\n</li>\n</ol><p>能够体现值方法和指针方法之间差异的小例子我放在demo30.go文件里了，你可以参照一下。</p><p><strong>总结</strong></p><p>结构体类型的嵌入字段比较容易让Go语言新手们迷惑，所以我在本篇文章着重解释了它的编写方法、基本的特性和规则以及更深层次的含义。在理解了结构体类型及其方法的组成方式和构造套路之后，这些知识应该是你重点掌握的。</p><p>嵌入字段是其声明中只有类型而没有名称的字段，它可以以一种很自然的方式为被嵌入的类型带来新的属性和能力。在一般情况下，我们用简单的选择表达式就可以直接引用到它们的字段和方法。</p><p>不过，我们需要小心可能产生“屏蔽”现象的地方，尤其是当存在多个嵌入字段或者多层嵌入的时候。“屏蔽”现象可能会让你的实际引用与你的预期不符。</p><p>另外，你一定要梳理清楚值方法和指针方法的不同之处，包括这两种方法各自能做什么、不能做什么以及会影响到其所属类型的哪些方面。这涉及值的修改、方法集合和接口实现。</p><p>最后，再次强调，嵌入字段是实现类型间组合的一种方式，这与继承没有半点儿关系。Go语言虽然支持面向对象编程，但是根本就没有“继承”这个概念。</p><p><strong>思考题</strong></p><ol>\n<li>我们可以在结构体类型中嵌入某个类型的指针类型吗？如果可以，有哪些注意事项？</li>\n<li>字面量<code>struct{}</code>代表了什么？又有什么用处？</li>\n</ol><p><a href=\"https://github.com/hyper0x/Golang_Puzzlers\">戳此查看Go语言专栏文章配套详细代码。</a></p><p></p>","comments":[{"had_liked":false,"id":23642,"user_name":"melon","can_delete":false,"product_type":"c1","uid":1023773,"ip_address":"","ucode":"7A80C20EBCAAA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9f/1d/ec173090.jpg","comment_is_top":false,"comment_ctime":1536564680,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"512637672904","product_id":100013101,"comment_content":"方法的定义感觉本质上也是一种语法糖形式，其本质就是一个函数，声明中的方法接收者就是函数的第一个入参，在调用时go会把施调变量作为函数的第一个入参的实参传入，比如<br>func (t MyType) MyMethod(in int) (out int) <br>可以看作是<br>func MyMethod(t Mytype, in int) (out int) <br><br>比如 myType.MyMethod(123) 就可以理解成是调用MyMethod(myType, 123)，如果myType是*MyType指针类型，则在调用是会自动进行指针解引用，实际就是这么调用的 MyMethod(*myType, 123)，这么一理解，值方法和指针方法的区别也就显而易见了。","like_count":119,"discussions":[{"author":{"id":1445744,"avatar":"https://static001.geekbang.org/account/avatar/00/16/0f/70/f59db672.jpg","nickname":"槑·先生","note":"","ucode":"897F0475592E3A","race_medal":2,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368470,"discussion_content":"感觉你讲的比老师的还清晰","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1618723859,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2294890,"avatar":"","nickname":"立豪同学6","note":"","ucode":"931CA42EC69E5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377764,"discussion_content":"所以如果没有特别的要求，都推荐用指针类型的方法，毕竟是指针传递，减少消耗。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1622818125,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1902166,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/YLAHxXYOfBkn9utpBnwI2wdElYUh7icg3e2O7fdI2yO5KSgeuxWUjwYRzX6iaJaN8gSnSIq23W4pcLRCoojNGrAQ/132","nickname":"Geek_5928e4","note":"","ucode":"6828D5BC744F63","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550433,"discussion_content":"有一点不一样，函数签名前面和后面肯定不同，要不然不同struct 的同名函数就编译不过","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1644544607,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2978983,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/74/a7/e609ca59.jpg","nickname":"大雄","note":"","ucode":"1639C6DAFB5E25","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590417,"discussion_content":"这里像 c#里面的扩展方法，(this class a)   代表给a加上什么方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665728756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":23778,"user_name":"来碗绿豆汤","can_delete":false,"product_type":"c1","uid":1070051,"ip_address":"","ucode":"B0AB63B8D9729F","user_header":"https://static001.geekbang.org/account/avatar/00/10/53/e3/39dcfb11.jpg","comment_is_top":false,"comment_ctime":1536648771,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"246349784643","product_id":100013101,"comment_content":"思考题1， 我们可以在结构体中嵌入某个类型的指针类型， 它和普通指针类似，默认初始化为nil,因此在用之前需要人为初始化，否则可能引起错误<br>思考题2， 空结构体不占用内存空间，但是具有结构体的一切属性，如可以拥有方法，可以写入channel。所以当我们需要使用结构体而又不需要具体属性时可以使用它。","like_count":57,"discussions":[{"author":{"id":2004538,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/96/3a/e06f8367.jpg","nickname":"胡小涵","note":"","ucode":"2E750C65EC282C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367596,"discussion_content":"可以写入channel怎么会不占用内存？1个字节都不占嘛？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618404150,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1198381,"avatar":"https://static001.geekbang.org/account/avatar/00/12/49/2d/4268ffb7.jpg","nickname":"louis","note":"","ucode":"C8A80284518FF4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2004538,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/96/3a/e06f8367.jpg","nickname":"胡小涵","note":"","ucode":"2E750C65EC282C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554130,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646225244,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":367596,"ip_address":""},"score":554130,"extra":""},{"author":{"id":1203653,"avatar":"https://static001.geekbang.org/account/avatar/00/12/5d/c5/6513b314.jpg","nickname":"At sea","note":"","ucode":"6B4977FA6FD275","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2004538,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/96/3a/e06f8367.jpg","nickname":"胡小涵","note":"","ucode":"2E750C65EC282C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558287,"discussion_content":"fmt.Println(unsafe.Sizeof(struct {\n\t}{}))","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648191941,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":367596,"ip_address":""},"score":558287,"extra":""}]}]},{"had_liked":false,"id":114654,"user_name":"风中花","can_delete":false,"product_type":"c1","uid":1085237,"ip_address":"","ucode":"067E0A1E116844","user_header":"https://static001.geekbang.org/account/avatar/00/10/8f/35/f1839bb2.jpg","comment_is_top":false,"comment_ctime":1563357208,"is_pvip":false,"discussion_count":10,"race_medal":0,"score":"224901656600","product_id":100013101,"comment_content":"老师的专业术语用的啊，我能坚持到现在我也不容易啊 ，费劲啊 。","like_count":52,"discussions":[{"author":{"id":1333577,"avatar":"https://static001.geekbang.org/account/avatar/00/14/59/49/3299e908.jpg","nickname":"Only Once","note":"","ucode":"5E98DDCB2FEAF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339212,"discussion_content":"作者很多东西写的很好，看懂有恍然大悟的感觉，但是太多让人搞不懂的陌生词语完全就影响阅读效率。有的词语完全可以用大众理解的方式或者其他老师共用的说法，但是这里就是不用。为什么现在用白话文不用文言文，就是因为难以阅读。有一些句子我都大声的读出来十几遍才能搞清楚是说了啥。","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1609563600,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1684297,"avatar":"https://static001.geekbang.org/account/avatar/00/19/b3/49/79024ed2.jpg","nickname":"Tr丶Zoey","note":"","ucode":"34A30F97E5A9DF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408803,"discussion_content":"顺便提一下，我这里是一种由<加粗>面粉、淀粉或小麦粉经过中国传统手艺加工制成，再由地方工艺加入独特原料制作而成的面饼<加粗>。除可直接食用外也可与蔬菜一起烩着食用，并且最早是由中国人命名的。    翻译一下：这是个 大饼","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1635325984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1032236,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c0/2c/87cc08ce.jpg","nickname":"baiyutang","note":"","ucode":"FD2436978BB447","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318681,"discussion_content":"是，有点生硬。不太符合惯例。有的时候不如直接用英文。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603806039,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1236766,"avatar":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","nickname":"传说中的成大大","note":"","ucode":"103543D6E706BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":209070,"discussion_content":"我也是 但是我把前面三节课程头疼完了过后 就感觉翻过了大山 现在都没那么头疼了哈哈哈","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584606212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757338,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d0/9a/0e2ce7d0.jpg","nickname":"jayden","note":"","ucode":"146AE28FFD9080","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589529,"discussion_content":"看起来很费劲啊。像绕口令一样。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665061365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1210003,"avatar":"https://static001.geekbang.org/account/avatar/00/12/76/93/c78a132a.jpg","nickname":"果然如此","note":"","ucode":"C7543BD0A67505","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":563550,"discussion_content":"技术文章，简洁精炼一下就好了，有些看着很累其实意思很简单，不能为了凑字数而写文章。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650022226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018200,"avatar":"","nickname":"一眼万年","note":"","ucode":"7B0823E39AE809","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318473,"discussion_content":"有点生搬英语翻译","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603762846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1117933,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0e/ed/1c662e93.jpg","nickname":"莫珣","note":"","ucode":"CAFE6F2AC5C177","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301643,"discussion_content":"用的不好还是好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598596000,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1144021,"avatar":"https://static001.geekbang.org/account/avatar/00/11/74/d5/de9641dc.jpg","nickname":"poettian","note":"","ucode":"26EE408F908D12","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1117933,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0e/ed/1c662e93.jpg","nickname":"莫珣","note":"","ucode":"CAFE6F2AC5C177","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394535,"discussion_content":"能看懂就好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631929756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301643,"ip_address":""},"score":394535,"extra":""}]},{"author":{"id":1255160,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/NnefngARTSPK2qLfYenRjDCNSv7NdGpia05NowusiarIvglJibkJn1WMnj2EzicgBay3XWbWpiaCfQJVr3PAeXcghzw/132","nickname":"民工哦","note":"","ucode":"6B6585EBBFC18A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289371,"discussion_content":"哈哈，真实","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594082946,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":50596,"user_name":"大马猴","can_delete":false,"product_type":"c1","uid":1012528,"ip_address":"","ucode":"E3482CBDF43CDE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/73/30/fd602742.jpg","comment_is_top":false,"comment_ctime":1545014374,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"138983967846","product_id":100013101,"comment_content":"return a.AnimalCategory.String()，这叫链式表达式吗？这不就是普通的调用吗？老乱用概念，让人很难理解","like_count":32,"discussions":[{"author":{"id":1905171,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/12/13/e103a6e3.jpg","nickname":"扩散性百万咸面包","note":"","ucode":"6D703D51553B42","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":228932,"discussion_content":"看你怎么理解链式表达式啊。。任何链式表达式都是由一个个普通的调用组成的。这里a.AnimalCategory肯定会返回一个对象，再在这个对象上调用，我觉得叫链式表达式也有道理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586591658,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1012528,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/73/30/fd602742.jpg","nickname":"大马猴","note":"","ucode":"E3482CBDF43CDE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1905171,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/12/13/e103a6e3.jpg","nickname":"扩散性百万咸面包","note":"","ucode":"6D703D51553B42","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":243068,"discussion_content":"链式调用特指返回被调用对象自身的调用形式，常用语builder模式，了解一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587518903,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":228932,"ip_address":""},"score":243068,"extra":""},{"author":{"id":1174304,"avatar":"https://static001.geekbang.org/account/avatar/00/11/eb/20/7ada2ffc.jpg","nickname":"橡皮查理","note":"","ucode":"3B2B89D3377BDF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1012528,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/73/30/fd602742.jpg","nickname":"大马猴","note":"","ucode":"E3482CBDF43CDE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320010,"discussion_content":"「链式调用特指返回被调用对象自身的调用形式」不太清楚这是哪里来的特指。而且不是链式表达式吗？怎么又是自己又说是「链式调用」了？\n英文环境中的 &#34;Method chaining&#34; 据我所知根本没有你说的什么特指，而原文所指的表达式也完全可以叫作链式表达式。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1604224789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":243068,"ip_address":""},"score":320010,"extra":""},{"author":{"id":1521568,"avatar":"https://static001.geekbang.org/account/avatar/00/17/37/a0/032d0828.jpg","nickname":"上杉夏香","note":"","ucode":"9FDDE0979BCC8C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1905171,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/12/13/e103a6e3.jpg","nickname":"扩散性百万咸面包","note":"","ucode":"6D703D51553B42","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361306,"discussion_content":"对，我觉得和微积分中的链式求导的感觉差不多。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616640265,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":228932,"ip_address":""},"score":361306,"extra":""}]}]},{"had_liked":false,"id":23793,"user_name":"colben","can_delete":false,"product_type":"c1","uid":1200769,"ip_address":"","ucode":"5E5DBA48578E96","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/81/745475e9.jpg","comment_is_top":false,"comment_ctime":1536658771,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"126090710355","product_id":100013101,"comment_content":"嘿嘿，看了郝老师的《go并发编程》，里面讲到空结构体类型变量不占内存空间，内存地址相同，建议用于在通道里传递“信号”……","like_count":29},{"had_liked":false,"id":160294,"user_name":"Iflei","can_delete":false,"product_type":"c1","uid":1351215,"ip_address":"","ucode":"812264ADE9CB33","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/AyccJq7eg6w3aCn7AxpicdplGhhY2xYOJLd9q2Xcjqxdbb6HO7rU4p37oxCjUnrcydpQVjNgcIhxOLKsI4w2KWQ/132","comment_is_top":false,"comment_ctime":1575906545,"is_pvip":false,"replies":[{"id":"61210","content":"Go 是把多个编程范式有机地融合在一起了。继承其实是很容易引起程序复杂度飙升的一个东西。GoF 提倡的设计原则中也有“多用组合，少用继承”一条。这不正是 Go 所做的嘛？组合和继承是两个不同的东西，虽然它们在某些时候可以起到同样的作用。<br><br>我觉得纯粹的 OO 有利有弊，而且不能说没有完全实现OO 的所有思想就不算支持 OO。<br>","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1575948318,"ip_address":"","comment_id":160294,"utype":1}],"discussion_count":6,"race_medal":0,"score":"78885317873","product_id":100013101,"comment_content":"一方面说go支持面向对象，一方面说go没有继承，这不很矛盾吗？面向对象三大特性之一就是继承，没有继承也敢叫面向对象。只是继承实现的方式不同罢了","like_count":18,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477327,"discussion_content":"Go 是把多个编程范式有机地融合在一起了。继承其实是很容易引起程序复杂度飙升的一个东西。GoF 提倡的设计原则中也有“多用组合，少用继承”一条。这不正是 Go 所做的嘛？组合和继承是两个不同的东西，虽然它们在某些时候可以起到同样的作用。\n\n我觉得纯粹的 OO 有利有弊，而且不能说没有完全实现OO 的所有思想就不算支持 OO。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575948318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1174304,"avatar":"https://static001.geekbang.org/account/avatar/00/11/eb/20/7ada2ffc.jpg","nickname":"橡皮查理","note":"","ucode":"3B2B89D3377BDF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320013,"discussion_content":"还是教条主义了，即使是 OOP 的提出者 Alan Kay 都没有说过 OOP 必须要有继承。相反，OOP 的最核心思想在于：Message passing、Encapsulation 和 Dynamic binding。而你所知道的继承只是一种实现手段。","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1604225126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1040666,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e1/1a/27193565.jpg","nickname":"Jinyun","note":"","ucode":"C96F34844CDC3C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":317878,"discussion_content":"组合优于继承，Go 真正把这一点发扬光大","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1603610262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018200,"avatar":"","nickname":"一眼万年","note":"","ucode":"7B0823E39AE809","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318475,"discussion_content":"继成和组合各有场景，没有谁好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603762968,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1209419,"avatar":"https://static001.geekbang.org/account/avatar/00/12/74/4b/c56452c3.jpg","nickname":"chain","note":"","ucode":"479D8351CE9F63","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":257463,"discussion_content":"看起来对OO的定义理解不一样，所以讨论一个概念前把定义统一一下能少很多争论","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588573289,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008348,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/dc/8876c73b.jpg","nickname":"moooofly","note":"","ucode":"4A20795C281B6F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":124793,"discussion_content":"这个讨论很有意义！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578451010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":23698,"user_name":"colben","can_delete":false,"product_type":"c1","uid":1200769,"ip_address":"","ucode":"5E5DBA48578E96","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/81/745475e9.jpg","comment_is_top":false,"comment_ctime":1536591600,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"74551035632","product_id":100013101,"comment_content":"go语言的结构体甚得我心！2009年我上大二学c++开始接触对象的概念，当时发现类的私有变量、成员函数完全可以用c的结构体配合函数指针来实现，完全没有必要去搞“类”！可惜后来的Java和python都没有摆脱class这个关键字，这次的go终于甩掉了臃肿的“对象”！","like_count":17,"discussions":[{"author":{"id":1135528,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/a8/abc96f70.jpg","nickname":"return","note":"","ucode":"42B8A3380DF04B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":240388,"discussion_content":"大佬牛逼啊， ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587358785,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123270,"user_name":"浩","can_delete":false,"product_type":"c1","uid":1394346,"ip_address":"","ucode":"BD7FE280C83152","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKoGnC6068nQia1bOiaPxMRmkOQsaDsw5ib2drXic4gKOLzIFyZnnFm4uJ6KniboKG1nQD3J15y4d3QxLA/132","comment_is_top":false,"comment_ctime":1565656504,"is_pvip":false,"replies":[{"id":"45486","content":"当值（比如这里说的cat）的方法集合中没有对应方法时，Go会去它的指针的方法集合中寻找，如果找到了，那么Go就会做这种转译。其他情况不会做转译。这属于一种语法糖，让我们能用同一种调用方式调用两种方法（值方法或指针方法）。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1565796174,"ip_address":"","comment_id":123270,"utype":1}],"discussion_count":2,"race_medal":0,"score":"70285133240","product_id":100013101,"comment_content":"前面都看懂了，最后这里有疑问，老师开始说，值类型的方法由于是类型值的副本，所以不会对原数据修改，指针类型的方法由于是指针的副本，所以会对原数据修改，这里都没有问题，但是，老师又说值类型的方法运行时，会被go自动转译成(&amp;cat).Setname(“newname”),那什么时候值类型会被转译呢","like_count":16,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462605,"discussion_content":"当值（比如这里说的cat）的方法集合中没有对应方法时，Go会去它的指针的方法集合中寻找，如果找到了，那么Go就会做这种转译。其他情况不会做转译。这属于一种语法糖，让我们能用同一种调用方式调用两种方法（值方法或指针方法）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565796174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1674466,"avatar":"https://static001.geekbang.org/account/avatar/00/19/8c/e2/48f4e4fa.jpg","nickname":"mkii","note":"","ucode":"534914EC7EA304","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347115,"discussion_content":"跑一下demo30就知道了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1612156817,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122767,"user_name":"🐶","can_delete":false,"product_type":"c1","uid":1459980,"ip_address":"","ucode":"D9E46DDB64BA77","user_header":"https://static001.geekbang.org/account/avatar/00/16/47/0c/f2f0245e.jpg","comment_is_top":false,"comment_ctime":1565515969,"is_pvip":false,"replies":[{"id":"45152","content":"嗯，对。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1565576847,"ip_address":"","comment_id":122767,"utype":1}],"discussion_count":2,"race_medal":0,"score":"61695058113","product_id":100013101,"comment_content":"1. 可以嵌入某个类型的指针类型，包括本结构体的指针类型，例如树的结构体的声明。但是在使用之前需要初始化<br>2. struct{}代表是一个空结构体，不占用内存空间，但是也是一个结构体！","like_count":14,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462395,"discussion_content":"嗯，对。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565576847,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1914504,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/36/88/20b6a6ee.jpg","nickname":"Simon","note":"","ucode":"A8A2E3E57BD029","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372135,"discussion_content":"不占用内存空间？C语言里，它至少是一个字节。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620206220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":28694,"user_name":"卡卡爱漂流","can_delete":false,"product_type":"c1","uid":1199840,"ip_address":"","ucode":"872CE4ADA497CC","user_header":"https://static001.geekbang.org/account/avatar/00/12/4e/e0/166d4548.jpg","comment_is_top":false,"comment_ctime":1538128084,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"44487801044","product_id":100013101,"comment_content":"如果一个method的receiver是*T,你可以在一个T类型的实例变量V上面调用这个method，而不需要&amp;V去调用这个method；<br>如果一个method的receiver是T，你可以在一个*T类型的变量P上面调用这个method，而不需要 *P去调用这个method。<br><br>所以，不用担心你是调用的指针的method还是不是指针的method，Go知道你要做的一切","like_count":10},{"had_liked":false,"id":23752,"user_name":"Q卓玛的男人","can_delete":false,"product_type":"c1","uid":1197978,"ip_address":"","ucode":"9480DAF15AAA25","user_header":"https://static001.geekbang.org/account/avatar/00/12/47/9a/12141630.jpg","comment_is_top":false,"comment_ctime":1536631901,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"44486304861","product_id":100013101,"comment_content":"感觉值方法修改的只是类型值的副本，这个很容易弄错误认为已经更新了类型值本身。那么如果我们定义方法都定义为指针方法，而不用值方法，会有什么问题吗？","like_count":10,"discussions":[{"author":{"id":1019568,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8e/b0/ef201991.jpg","nickname":"CcczzZ","note":"","ucode":"5F46DA5053D2BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":111050,"discussion_content":"都是指针方法，如果在方法里修改了类型值，会影响外层数据吧。在不需要修改类型值的时候可以定义为值方法， 约束一下代码，避免误操作","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1577775507,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":23652,"user_name":"苏浅","can_delete":false,"product_type":"c1","uid":1102398,"ip_address":"","ucode":"F7AD45AF84DA82","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/t82qauAVn2m2uQicV7eBByBMehSvUlj6tLOsiaBlficcsKB57vYfthTgoyWTpoW5X6OQOrdL0nVWlMBg2L3ictTJAw/132","comment_is_top":false,"comment_ctime":1536574123,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"35896312491","product_id":100013101,"comment_content":"每篇文章都有一个配图，这是有啥讲究吗？还是就是觉得好看？😏","like_count":8,"discussions":[{"author":{"id":1565759,"avatar":"https://static001.geekbang.org/account/avatar/00/17/e4/3f/9b91c8fb.jpg","nickname":"SplatoonY","note":"","ucode":"9A4B0B2D14FF87","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41466,"discussion_content":"平台给的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1572433579,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":23640,"user_name":"ossic","can_delete":false,"product_type":"c1","uid":1105919,"ip_address":"","ucode":"2C2BCBA82A2CB4","user_header":"https://static001.geekbang.org/account/avatar/00/10/df/ff/7f17e76f.jpg","comment_is_top":false,"comment_ctime":1536562413,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35896300781","product_id":100013101,"comment_content":"貌似github上的代码并没有更新","like_count":8},{"had_liked":false,"id":227386,"user_name":"杉松壁","can_delete":false,"product_type":"c1","uid":1080578,"ip_address":"","ucode":"ED904CE27CD3C4","user_header":"https://static001.geekbang.org/account/avatar/00/10/7d/02/4862f849.jpg","comment_is_top":false,"comment_ctime":1592369290,"is_pvip":false,"replies":[{"id":"84083","content":"内层函数相当于一种函数的不完整定义，外层函数相当于制造这种函数（即完整后的内层函数）的工厂。当你调用外层函数并传入参数值时，相当于在告诉外层函数“根据我给定的参数制造出一个函数”。你想想看，这实际上是在程序的运行过程中动态的生成代码（而不是数据），与创建一个值、一个数据结构的实例是截然不同的。<br><br>这里的代码不是死的，而是活的。这也可以被看作是一种简易的元编程。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1592546878,"ip_address":"","comment_id":227386,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31657140362","product_id":100013101,"comment_content":"老师，闭包我还是没能理解。<br>既然是内层的函数需要op的传值，为什么不能直接将op直接传给内层函数，而要通过外层函数的封装？","like_count":7,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498612,"discussion_content":"内层函数相当于一种函数的不完整定义，外层函数相当于制造这种函数（即完整后的内层函数）的工厂。当你调用外层函数并传入参数值时，相当于在告诉外层函数“根据我给定的参数制造出一个函数”。你想想看，这实际上是在程序的运行过程中动态的生成代码（而不是数据），与创建一个值、一个数据结构的实例是截然不同的。\n\n这里的代码不是死的，而是活的。这也可以被看作是一种简易的元编程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592546878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":24859,"user_name":"Yayu","can_delete":false,"product_type":"c1","uid":1058015,"ip_address":"","ucode":"5E7842458D8229","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/df/645f8087.jpg","comment_is_top":false,"comment_ctime":1537200057,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23012036537","product_id":100013101,"comment_content":"第二次学习本章节，对老师讲解的内容有了清晰的认识。回答一下老师的问题。1.一个结构体可以嵌入一个类型的指针类型，而且被嵌入的类型还可以是它自己，这样可以构造出树的数据结构。2.struct｛｝是一个空结构体字面量表示，它可以用来给一个变量赋值，这个变量虽然没有字段，但是可以绑定方法。","like_count":5},{"had_liked":false,"id":145945,"user_name":"风一般的梦幻","can_delete":false,"product_type":"c1","uid":1556304,"ip_address":"","ucode":"7E95425ECF3B89","user_header":"https://static001.geekbang.org/account/avatar/00/17/bf/50/3b370cd5.jpg","comment_is_top":false,"comment_ctime":1572404710,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18752273894","product_id":100013101,"comment_content":"Effective GO中一句话“还有种区分内嵌与子类的重要手段。当内嵌一个类型时，该类型的方法会成为外部类型的方法， 但当它们被调用时，该方法的接收者是内部类型，而非外部的。”可以帮助大家理解组合和继承的区别","like_count":4},{"had_liked":false,"id":29137,"user_name":"夏云","can_delete":false,"product_type":"c1","uid":1070570,"ip_address":"","ucode":"1883630F7E6EC1","user_header":"https://static001.geekbang.org/account/avatar/00/10/55/ea/e5a52934.jpg","comment_is_top":false,"comment_ctime":1538273632,"is_pvip":true,"replies":[{"id":"10645","content":"可以对照着示例项目中的代码看，实际上我也是这么设计的。另外，这个专栏的定位也不是只讲浅显的东西。一些核心的东西需要大家仔细研习，反复琢磨。想当初我也是这么做的。我希望这些内容能给你们带来长期的好处。<br><br>听音频可以让你们有个宏观的了解和大概的感觉，真正学起来还是需要看文字、看代码的。加油！","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1538452202,"ip_address":"","comment_id":29137,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18718142816","product_id":100013101,"comment_content":"这一讲概念性的文字太多，多一些例子就好了，不然第一遍云里雾里的","like_count":4,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425502,"discussion_content":"可以对照着示例项目中的代码看，实际上我也是这么设计的。另外，这个专栏的定位也不是只讲浅显的东西。一些核心的东西需要大家仔细研习，反复琢磨。想当初我也是这么做的。我希望这些内容能给你们带来长期的好处。\n\n听音频可以让你们有个宏观的了解和大概的感觉，真正学起来还是需要看文字、看代码的。加油！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538452202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145944,"user_name":"风一般的梦幻","can_delete":false,"product_type":"c1","uid":1556304,"ip_address":"","ucode":"7E95425ECF3B89","user_header":"https://static001.geekbang.org/account/avatar/00/17/bf/50/3b370cd5.jpg","comment_is_top":false,"comment_ctime":1572404612,"is_pvip":false,"replies":[{"id":"56473","content":"看过设计模式的书吗？其中有一条原则：多用组合，少用继承。这样才能低耦合。另外可以结合“组合模式”思考一下。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1572493841,"ip_address":"","comment_id":145944,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14457306500","product_id":100013101,"comment_content":"这句话“同时，类型组合也是非侵入式的，它不会破坏类型的封装或加重类型之间的耦合。”能否和Java对比举例说明一下呢？","like_count":3,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472642,"discussion_content":"看过设计模式的书吗？其中有一条原则：多用组合，少用继承。这样才能低耦合。另外可以结合“组合模式”思考一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572493841,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109131,"user_name":"Sky","can_delete":false,"product_type":"c1","uid":1392585,"ip_address":"","ucode":"4C5A5AB73E8B90","user_header":"https://static001.geekbang.org/account/avatar/00/15/3f/c9/1ccefb9a.jpg","comment_is_top":false,"comment_ctime":1561967814,"is_pvip":false,"replies":[{"id":"39848","content":"方法的声明形式是：func (xx XX) methodName() {...}，其中的 (xx XX) 是接收者声明。这个接收者就是某个类型 XX 啊，xx 是它被实例化后的指代变量。XX 叫接收者类型，xx 叫接收者变量。这就是方法与函数的区别啊。方法必须依附于某个类型，而函数不用，函数是独立的。调用方法的话，只能通过该方法依附的那个类型的某个实例去调用，比如：xx1.methodName()。而函数可以直接调用。<br><br>这些在你问的问题里基本都表述出来了。你没有察觉到吗？","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1562155912,"ip_address":"","comment_id":109131,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14446869702","product_id":100013101,"comment_content":"函数是独立的程序实体。这一段的表述，有点让人疑惑“函数”和“方法”到底有什么区别？从代码上看，如果没有“接收者类型”，函数和方法是完全一样的。方法如果没有“接收者类型”，那么它就是“函数”，为什么这里说“方法必须隶属于某一个类型”。","like_count":3,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456257,"discussion_content":"方法的声明形式是：func (xx XX) methodName() {...}，其中的 (xx XX) 是接收者声明。这个接收者就是某个类型 XX 啊，xx 是它被实例化后的指代变量。XX 叫接收者类型，xx 叫接收者变量。这就是方法与函数的区别啊。方法必须依附于某个类型，而函数不用，函数是独立的。调用方法的话，只能通过该方法依附的那个类型的某个实例去调用，比如：xx1.methodName()。而函数可以直接调用。\n\n这些在你问的问题里基本都表述出来了。你没有察觉到吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562155912,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":24312,"user_name":"manky","can_delete":false,"product_type":"c1","uid":1226745,"ip_address":"","ucode":"BDDBB16BADB5B5","user_header":"https://static001.geekbang.org/account/avatar/00/12/b7/f9/75bae002.jpg","comment_is_top":false,"comment_ctime":1536896142,"is_pvip":false,"replies":[{"id":"8928","content":"在基本值上调用它的指针方法时Go会先对基本值进行取址再调用它的指针方法，这就是我说的转义。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1536975414,"ip_address":"","comment_id":24312,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14421798030","product_id":100013101,"comment_content":"严格来讲，我们在这样的基本类型的值上只能调用到它的值方法。但是go语言会适时地进行转义.请问什么时候不会出现转义，或者说编译器进行转义有什么必备条件吗？","like_count":3,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423932,"discussion_content":"在基本值上调用它的指针方法时Go会先对基本值进行取址再调用它的指针方法，这就是我说的转义。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1536975414,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186702,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1583906623,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10173841215","product_id":100013101,"comment_content":"执行完demon30过后才回来写今天的本质<br>今天的主要内容就是结构体和方法<br>1.结构体嵌入<br>   1.1被嵌入的结构体 享有嵌入结构体的方法和属性 同样被嵌入的结构体可以屏蔽掉嵌入结构体的方法和属性，出现这个情况的时候 如果想要嵌入结构体的方法和属性时需要通过选择表达式指明<br>  1.2 方法或者属性的查找方式  首先会查找被嵌入结构体 找到就停止(返回) 如果没找到就去找嵌入结构找到则返回 没找到就没有这个方法或者属性<br>   1.3 如果同一层级 有多个嵌入类型 嵌入类型都含有相同的属性或者方法 则编译不通过 因为编译器不知道确定那个属性或者方法<br>2. 方法<br>   方法其实是作用于结构体上的一种特殊的函数<br>   方法分为值方法和指针方法<br>   指针方法拥有所有值方法 这个时候指针可以调用值方法<br>   但是值类型的却不拥有指针方法(典型的体现在接口那里) 如果一个指针方法和值方法 合起来共同实现了一个接口那么值方法可以实现该接口 但是值方法却不行<br>  虽然值可以调用所有的指针方法最后转换成(&amp;cat).setname()<br>go语言虽然支持面向对象编程  但是go语言中没有继承这一说,所以结构体中的嵌入实际上实现了组合方式<br>再对于指针方法和值方法调用的总结<br>不考虑羞不修改调用对象的内容 感觉就是 值和指针可以相互使用对方的方法 <br>1. 指针拥有值方法<br>2. 值调用的时候会转换成(&amp;cat)调用<br>区别就在于是否要修改内容 和有没有实现该方法！","like_count":2},{"had_liked":false,"id":61383,"user_name":"先听","can_delete":false,"product_type":"c1","uid":1151409,"ip_address":"","ucode":"82D8DA7A2FEB4B","user_header":"https://static001.geekbang.org/account/avatar/00/11/91/b1/fb117c21.jpg","comment_is_top":false,"comment_ctime":1547688761,"is_pvip":false,"replies":[{"id":"25237","content":"嵌入结构体可以部分实现继承的效果。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1551180613,"ip_address":"","comment_id":61383,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10137623353","product_id":100013101,"comment_content":"在go语言中，有没有办法实现继承呢？或者说有没有办法实现和继承一样的效果呢？","like_count":2,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436856,"discussion_content":"嵌入结构体可以部分实现继承的效果。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551180613,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37299,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1118976,"ip_address":"","ucode":"35F4FFAC4A4B15","user_header":"https://static001.geekbang.org/account/avatar/00/11/13/00/a4a2065f.jpg","comment_is_top":false,"comment_ctime":1541521098,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"10131455690","product_id":100013101,"comment_content":"郝大，有一句话理解不是很清除，还请赐教：一个自定义数据类型的方法集合中仅会包含它的所有值方法，而该类型的指针类型的方法集合却囊括了前者的所有方法，包括所有值方法和所有指针方法。<br><br>不是说，经过go语言自动进行转义，类型值 可以调用 类型指针值 方法，类型指针值 也可以调用 类型值方法吗，我咋觉得，类型值 和 类型指针值 拥有的方法数量应该是同样多的呢？<br><br>是不是因为 类型指针值 在 调用 类型值 方法的时候，会先解引用并且复制出一个新的值再去调用？","like_count":2,"discussions":[{"author":{"id":1306092,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ61zTDmLk7IhLJn6seBPOwsVaKIWUWaxk5YmsdYBZUOYMQCsyl9iaQVSg9U5qJVLLOCFUoLUuYnRA/132","nickname":"fjpcode","note":"","ucode":"C32C5E3ECB9A90","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":359501,"discussion_content":"我觉得这点主要是对接口类型的实现类型上面体现的比较明显，指针类型方法集合囊括了自定义类型的方法集合，这会影响某些基本类型值赋值给某个接口类型时编译器是否会报错；至于在指针类型值和基本类型值在调用方法的书写上由于语法糖倒是没有太大区别","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1616210620,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1526355,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4a/53/063f9d17.jpg","nickname":"moonfox","note":"","ucode":"902BFF40EFA9FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1306092,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ61zTDmLk7IhLJn6seBPOwsVaKIWUWaxk5YmsdYBZUOYMQCsyl9iaQVSg9U5qJVLLOCFUoLUuYnRA/132","nickname":"fjpcode","note":"","ucode":"C32C5E3ECB9A90","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367368,"discussion_content":"请问下基本类型赋值给接口时，为什么不进行自动转义呢？方法调用时却会","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618326977,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":359501,"ip_address":""},"score":367368,"extra":""},{"author":{"id":1312493,"avatar":"https://static001.geekbang.org/account/avatar/00/14/06/ed/5a167dda.jpg","nickname":"niceshot","note":"","ucode":"2C2BBC07A6E02D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1526355,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4a/53/063f9d17.jpg","nickname":"moonfox","note":"","ucode":"902BFF40EFA9FA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378008,"discussion_content":"指针类型也实现了值类型方法。而值类型没有实现对应的指针类型方法。至于为什么没有实现，可能是因为指针类型方法可能会修改源 但值类型设计的本意是不应该修改源的。\n其实方法就是一个参数带有接收者的函数。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1622995632,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":367368,"ip_address":""},"score":378008,"extra":""}]},{"author":{"id":1221991,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a5/67/bf286335.jpg","nickname":"AllenGFLiu","note":"","ucode":"90FA8A619A2629","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349757,"discussion_content":"老師在回復其他同學類似疑問時說：在基本值上调用它的指针方法时Go会先对基本值进行取址再调用它的指针方法，这就是我说的转义。\n另外老師還說過：轉義是一個語法糖。\n所以我得出的理解是：值類型本來只能調用值類型方法，而指針類型可以同時調用值類型方法和指針類型方法；但當用戶使用值類型去調用本來該指針類型調用的指針類型方法時，Go會幫助用戶自動把值類型轉義為指針類型。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1613522490,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35258,"user_name":"红科","can_delete":false,"product_type":"c1","uid":1078868,"ip_address":"","ucode":"30C0B61B99992B","user_header":"https://static001.geekbang.org/account/avatar/00/10/76/54/0aeb5e34.jpg","comment_is_top":false,"comment_ctime":1540478062,"is_pvip":false,"replies":[{"id":"13313","content":"别着急，思考题答案我会在后边补发。不过可能要耗费一些时间。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1541482133,"ip_address":"","comment_id":35258,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10130412654","product_id":100013101,"comment_content":"思考题能给出答案吗，有时候看留言也不知道哪个是正确的，自己也不会。自己谷歌查询，也是一知半解的，有时候还是不太明白。","like_count":2,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427491,"discussion_content":"别着急，思考题答案我会在后边补发。不过可能要耗费一些时间。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541482133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":28906,"user_name":"任性😀","can_delete":false,"product_type":"c1","uid":1209711,"ip_address":"","ucode":"F80DB5E6896105","user_header":"https://static001.geekbang.org/account/avatar/00/12/75/6f/8a6e0a14.jpg","comment_is_top":false,"comment_ctime":1538191949,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10128126541","product_id":100013101,"comment_content":"1、可以引入，实例化的时候需要传指针值<br>2、不知道<br>3、建议老师在下一遍文章里可以说说上一篇留的问题（有些看不懂啊）","like_count":2,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4582,"discussion_content":"专栏的最后有所有思考题的解答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565577069,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":24534,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1118976,"ip_address":"","ucode":"35F4FFAC4A4B15","user_header":"https://static001.geekbang.org/account/avatar/00/11/13/00/a4a2065f.jpg","comment_is_top":false,"comment_ctime":1537112045,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10127046637","product_id":100013101,"comment_content":"嵌入指针类型我觉得要注意的是：指针的默认值是 nil, 在对这个字段赋值之前，没法使用这个字段，调用的时候就会出错。<br><br>而值类型初始化的时候是有默认值得，不会有这样的风险。","like_count":2},{"had_liked":false,"id":23789,"user_name":"jians","can_delete":false,"product_type":"c1","uid":1204386,"ip_address":"","ucode":"2600DC7CE1E5E1","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK1iadgQFxhYdu7wIUf7n5XYZlchNicdGBsafY9GPX3hNq0313DfE7ia6CeRm7VZAmwGPsLI8icTJUqXg/132","comment_is_top":false,"comment_ctime":1536655859,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10126590451","product_id":100013101,"comment_content":"测试嵌套多个结构体存在同名方法的情况，同一级别的嵌套体内不能存在相同的方法，否则在顶层调用方法时报错，看来它没办法决定使用哪一个嵌套的方法，除非通过.点定位调用。<br>如果嵌套体在不同深度，会默认调用接近浅层的。","like_count":2},{"had_liked":false,"id":23628,"user_name":"世风十三","can_delete":false,"product_type":"c1","uid":1034414,"ip_address":"","ucode":"852E0EF615FDC6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c8/ae/f2b0bc01.jpg","comment_is_top":false,"comment_ctime":1536552773,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10126487365","product_id":100013101,"comment_content":"嵌入多个类型时，如果都有某个同名方法或字段，屏蔽的顺序是怎么样的？优先级？","like_count":2,"discussions":[{"author":{"id":1221991,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a5/67/bf286335.jpg","nickname":"AllenGFLiu","note":"","ucode":"90FA8A619A2629","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349758,"discussion_content":"老師文中有寫：如果處於同一個層級的嵌入字段擁有同名的方法或者字段，那當被嵌入類型引用此同名方法或者字段時會引發編譯錯誤。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613522737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":340883,"user_name":"咸鱼三月°","can_delete":false,"product_type":"c1","uid":2662227,"ip_address":"","ucode":"A4FBF948CA0C55","user_header":"https://static001.geekbang.org/account/avatar/00/28/9f/53/f5cbccfa.jpg","comment_is_top":false,"comment_ctime":1649212985,"is_pvip":false,"replies":[{"id":"124685","content":"我看到了这个：https:&#47;&#47;github.com&#47;golang&#47;go&#47;issues&#47;52146 是你提的issue吗？<br><br>我试验了一下，有几个方法可以避免这种不一致。比如，编写结构体方法、向 m 函数传递指针，等。<br><br>很遗憾，虽然我也觉得这是一个问题，但是Go团队的人貌似并不这么认为。<br><br>我现在依然坚持认为这样的不一致是有问题的。不过按照Go团队的说法，只能去用其他方法避免这种情况了。","user_name":"作者回复","user_name_real":"作者","uid":"1026643","ctime":1649331441,"ip_address":"","comment_id":340883,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5944180281","product_id":100013101,"comment_content":"package main<br><br>import (<br>\t&quot;fmt&quot;<br>)<br><br>func main() {<br>\ta := A{}<br>\tm(&quot;A&quot;, a, SetAI(&amp;a))<br>\tb := B{}<br>\tm(&quot;B&quot;, b, SetBI(&amp;b))<br>}<br><br>type A struct {<br>\tI int<br>\tS string<br>}<br><br>type B struct {<br>\tI int<br>}<br><br>func SetAI(a *A) A {<br>\ta.I = 10<br>\treturn *a<br>}<br><br>func SetBI(b *B) B {<br>\tb.I = 10<br>\treturn *b<br>}<br><br>func m(name string, arg1, arg2 interface{}) {<br>\tfmt.Println(name+&quot;:&quot;, arg1, arg2)<br>}<br><br><br><br><br>问题：在结构体只有一个属性时 打印方法会打印出相同结果，但是在结构体有多个属性时结果却不相同，上面是测试的代码。感觉很奇怪 输出为什么是 {0 } {10 } 和{10} {10}","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560444,"discussion_content":"我看到了这个：https://github.com/golang/go/issues/52146 是你提的issue吗？\n\n我试验了一下，有几个方法可以避免这种不一致。比如，编写结构体方法、向 m 函数传递指针，等。\n\n很遗憾，虽然我也觉得这是一个问题，但是Go团队的人貌似并不这么认为。\n\n我现在依然坚持认为这样的不一致是有问题的。不过按照Go团队的说法，只能去用其他方法避免这种情况了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649331441,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2662227,"avatar":"https://static001.geekbang.org/account/avatar/00/28/9f/53/f5cbccfa.jpg","nickname":"咸鱼三月°","note":"","ucode":"A4FBF948CA0C55","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":560504,"discussion_content":"感谢老师的解答，这个issue是我朋友帮助我提的，我也是偶然发现的，所以有些困惑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649348032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":560444,"ip_address":""},"score":560504,"extra":""}]}]},{"had_liked":false,"id":288312,"user_name":"胡小涵","can_delete":false,"product_type":"c1","uid":2004538,"ip_address":"","ucode":"2E750C65EC282C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/96/3a/e06f8367.jpg","comment_is_top":false,"comment_ctime":1618404445,"is_pvip":false,"replies":[{"id":"104684","content":"这只是习惯问题而已。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1618467474,"ip_address":"","comment_id":288312,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5913371741","product_id":100013101,"comment_content":"个人刚从c++转过来，虽然组合很灵活，但是一个对象和哪些interface产生了关联，感觉非常不直观，可读性上不如明确写出继承关系的语言。。。","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518587,"discussion_content":"这只是习惯问题而已。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618467474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1914504,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/36/88/20b6a6ee.jpg","nickname":"Simon","note":"","ucode":"A8A2E3E57BD029","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372137,"discussion_content":"应该是Go可读性更好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620206740,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203996,"user_name":"哼歌儿李","can_delete":false,"product_type":"c1","uid":1357897,"ip_address":"","ucode":"D384DE36455A62","user_header":"https://static001.geekbang.org/account/avatar/00/14/b8/49/99ca2069.jpg","comment_is_top":false,"comment_ctime":1586316772,"is_pvip":false,"replies":[{"id":"76915","content":"Cat 就是例子啊","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1586747184,"ip_address":"","comment_id":203996,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5881284068","product_id":100013101,"comment_content":"关于值方法和指针方法的对比，配合个具体的例子就好了","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491034,"discussion_content":"Cat 就是例子啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586747184,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169710,"user_name":"正伟","can_delete":false,"product_type":"c1","uid":1088703,"ip_address":"","ucode":"A7101870603840","user_header":"https://static001.geekbang.org/account/avatar/00/10/9c/bf/03f52156.jpg","comment_is_top":false,"comment_ctime":1578409404,"is_pvip":false,"replies":[{"id":"65896","content":"其实没有颠倒。组合是一种设计模式，其中并没有父子之类的辈分关系，只有借调关系。如果确实要以辈分关系这种角度来理解的话，你也可以这么想：子辈身体里存在着父辈的基因，流淌着父辈的血液。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1578459319,"ip_address":"","comment_id":169710,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5873376700","product_id":100013101,"comment_content":"Go中的组合，和传统的继承，在主次上做了一个颠倒。 继承中的父类，到了组合里，反而是被嵌入的儿子辈，组合者更高一级，决定着被组合进来的方法和字段使用与否及如何使用","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480684,"discussion_content":"其实没有颠倒。组合是一种设计模式，其中并没有父子之类的辈分关系，只有借调关系。如果确实要以辈分关系这种角度来理解的话，你也可以这么想：子辈身体里存在着父辈的基因，流淌着父辈的血液。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578459319,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134838,"user_name":"张sir","can_delete":false,"product_type":"c1","uid":1209431,"ip_address":"","ucode":"52958DF6705208","user_header":"https://static001.geekbang.org/account/avatar/00/12/74/57/7b828263.jpg","comment_is_top":false,"comment_ctime":1568941395,"is_pvip":false,"replies":[{"id":"51734","content":"会给默认的结构体；你用结构体的指针类型不就好了。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1568948569,"ip_address":"","comment_id":134838,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5863908691","product_id":100013101,"comment_content":"您好，老师，我想问下嵌入的结构体如果没有赋值，会给一个默认的空数据结构，但有的时候我要的实际效果是返回一个nil，请问这种怎么实现呢","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467918,"discussion_content":"会给默认的结构体；你用结构体的指针类型不就好了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568948569,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132816,"user_name":"安排","can_delete":false,"product_type":"c1","uid":1260026,"ip_address":"","ucode":"F78CFA9624CAEF","user_header":"https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg","comment_is_top":false,"comment_ctime":1568246890,"is_pvip":false,"replies":[{"id":"51016","content":"概念是基础，因为 Go 语言在这方面有很多不同之处。篇幅有限，再提其他语言中的概念，我怕会添乱。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1568437984,"ip_address":"","comment_id":132816,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5863214186","product_id":100013101,"comment_content":"接收者类型不就是通过对象调用方法吗？感觉弄了一堆专业术语很难懂，最好能结合一门其它语言，把这些概念提一下。一个接收者类型我看到最后评论才看懂。","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467133,"discussion_content":"概念是基础，因为 Go 语言在这方面有很多不同之处。篇幅有限，再提其他语言中的概念，我怕会添乱。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568437984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":68025,"user_name":"🐻","can_delete":false,"product_type":"c1","uid":1043072,"ip_address":"","ucode":"534EDAD496A0E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ea/80/8759e4c1.jpg","comment_is_top":false,"comment_ctime":1550391438,"is_pvip":false,"replies":[{"id":"25254","content":"因为，这个指针值的方法集合中也包含所有的值方法。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1551181879,"ip_address":"","comment_id":68025,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5845358734","product_id":100013101,"comment_content":"\tpointer_cat := &amp;Cat{<br>\t\tname:           &quot;little pig&quot;,<br>\t\tscientificName: &quot;American Shorthair&quot;,<br>\t\tcategory:       &quot;cat&quot;,<br>\t}<br>\tfmt.Println(pointer_cat.Category())<br><br>func (cat Cat) Category() string {<br>\treturn cat.category<br>}<br><br>指针变量也可以引用非指针方法，例如上面的 pointer_cat 是个指针变量，可以引用方法 `Category`<br><br>","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439477,"discussion_content":"因为，这个指针值的方法集合中也包含所有的值方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551181879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29668,"user_name":"ken","can_delete":false,"product_type":"c1","uid":1206788,"ip_address":"","ucode":"0571660A1231F6","user_header":"https://static001.geekbang.org/account/avatar/00/12/6a/04/63fd4c7b.jpg","comment_is_top":false,"comment_ctime":1538476690,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5833443986","product_id":100013101,"comment_content":"嵌入多个类型时，如果都有某个同名方法或字段，屏蔽的顺序是怎么样的？<br>如果一个嵌入字段对结构体打印时会调用嵌入字段的string方法，但如果有多个嵌入字段时，都有String方法时，是如何调用的呢？","like_count":1},{"had_liked":false,"id":23743,"user_name":"云学","can_delete":false,"product_type":"c1","uid":1027233,"ip_address":"","ucode":"366AE90BA06356","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ac/a1/43d83698.jpg","comment_is_top":false,"comment_ctime":1536628779,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5831596075","product_id":100013101,"comment_content":"继承确实会让代码腐烂，而且会被误用，增加复杂度，go语言坚持了〃组合优于继承〃的原则。","like_count":1},{"had_liked":false,"id":359784,"user_name":"enjoylearning","can_delete":false,"product_type":"c1","uid":1000237,"ip_address":"北京","ucode":"DCAF8538DEA277","user_header":"https://static001.geekbang.org/account/avatar/00/0f/43/2d/af86d73f.jpg","comment_is_top":false,"comment_ctime":1665895937,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665895937","product_id":100013101,"comment_content":"为什么不讲讲结构体的tag","like_count":0},{"had_liked":false,"id":355172,"user_name":"花见笑","can_delete":false,"product_type":"c1","uid":1219485,"ip_address":"广东","ucode":"8A5122BC11E695","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/9d/d487c368.jpg","comment_is_top":false,"comment_ctime":1661153009,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661153009","product_id":100013101,"comment_content":"这个方法和很多语言的self的语法糖一个原理","like_count":0},{"had_liked":false,"id":349490,"user_name":"BIZ_UI_3","can_delete":false,"product_type":"c1","uid":1655948,"ip_address":"","ucode":"1B9718610A5A59","user_header":"","comment_is_top":false,"comment_ctime":1655994034,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655994034","product_id":100013101,"comment_content":"就是个组合，非得说什么屏蔽。。","like_count":0},{"had_liked":false,"id":333262,"user_name":"小嘟嘟","can_delete":false,"product_type":"c1","uid":1285055,"ip_address":"","ucode":"1584DD1402502D","user_header":"https://static001.geekbang.org/account/avatar/00/13/9b/bf/a76eadff.jpg","comment_is_top":false,"comment_ctime":1644236865,"is_pvip":true,"replies":[{"id":"121809","content":"第3点是什么意思？","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1644292692,"ip_address":"","comment_id":333262,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1644236865","product_id":100013101,"comment_content":"struct{}  空结构体<br>1. 实现set<br>2. chan 传递消息信号<br>3. 函数的reviewer, 调用方法","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549915,"discussion_content":"第3点是什么意思？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644292692,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2725689,"avatar":"https://static001.geekbang.org/account/avatar/00/29/97/39/1f5c6350.jpg","nickname":"朱元彬🗿","note":"","ucode":"9CBD43225EE65B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":588069,"discussion_content":"应该是作为一个 只有方法没有字段的struct","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663513317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":549915,"ip_address":"广东"},"score":588069,"extra":""}]}]},{"had_liked":false,"id":332645,"user_name":"陈衎","can_delete":false,"product_type":"c1","uid":1810649,"ip_address":"","ucode":"8A6535DDB4B611","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a0/d9/49578be1.jpg","comment_is_top":false,"comment_ctime":1643439520,"is_pvip":false,"replies":[{"id":"121747","content":"不好意思，回复晚了。这要看你先调用的是哪一个方法了。在调用值方法的那一刻，新的副本才会被造出来。所以，如果你先调用的是指针方法，那么原始数据就已经改变了，之后再调用值方法的话只能拿到在已修改的数据的副本。<br><br>另外，在值方法中，副本就是副本，肯定不会也不能影响到原始数据。","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1644216055,"ip_address":"","comment_id":332645,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1643439520","product_id":100013101,"comment_content":"执行了demo30 的实例，也比较清楚的区分了指针类型引用和值类型引用的区别，通过指针直接修改了了结构体最原始的那一份基础数据。但是有一个疑问，就是我通过SetNameOfCopy方法，应该是对结构体的副本进行复制，我那在demo30列子中，通过指针修改了原始值，我还能同同时得到第二次被修改的那个副本吗。<br>也就是说 print 所打印出来的结果是<br>The cat: monster<br>The cat: little pig","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549700,"discussion_content":"不好意思，回复晚了。这要看你先调用的是哪一个方法了。在调用值方法的那一刻，新的副本才会被造出来。所以，如果你先调用的是指针方法，那么原始数据就已经改变了，之后再调用值方法的话只能拿到在已修改的数据的副本。\n\n另外，在值方法中，副本就是副本，肯定不会也不能影响到原始数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644216055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330380,"user_name":"Geek_d0799c","can_delete":false,"product_type":"c1","uid":1399896,"ip_address":"","ucode":"3DCF9092170A15","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/6ecX9hkk71IfQ4njgaguDfwJg4jXuarueEuCKgLVyIUOHac6iauiasZYqwV0yUOKh2fUaezNDoBhLjKR4X1rGIxA/132","comment_is_top":false,"comment_ctime":1641958619,"is_pvip":false,"replies":[{"id":"120554","content":"这就是一个Go语言内部的规则啊。","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1642060381,"ip_address":"","comment_id":330380,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1641958619","product_id":100013101,"comment_content":"有一个疑问，为什么打印cat变量，他会自动找cat.String方法呢","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545824,"discussion_content":"这就是一个Go语言内部的规则啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642060381,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":323504,"user_name":"jxs1211","can_delete":false,"product_type":"c1","uid":1101006,"ip_address":"","ucode":"B7F1F2D84389E7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKELX1Rd1vmLRWibHib8P95NA87F4zcj8GrHKYQL2RcLDVnxNy1ia2geTWgW6L2pWn2kazrPNZMRVrIg/132","comment_is_top":false,"comment_ctime":1637937151,"is_pvip":false,"replies":[{"id":"117473","content":"前面说得很好，最后面不够严谨。<br><br>若在原值（而非指针值）上进行调用，如果没找到对应的值方法，Go编译器就会去找对应的指针方法。注意，这是在编译时进行的。<br><br>如果找到了对应的指针方法，那么原先代码中的 val.Fun() 就会被自动改写为 (&amp;val).Func() 。<br><br>所以这属于基于编译器的语法糖。顺便说一句，对于这样的自动改写，我们在源码文件中是看不到的。","user_name":"作者回复","user_name_real":"作者","uid":"1026643","ctime":1638090264,"ip_address":"","comment_id":323504,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1637937151","product_id":100013101,"comment_content":"值方法和指针方法的调用都会复制选择符左边对应的类型值的副本，如果是值就是值的副本，指针就是指针的副本，如果在定义中找不到对应的方法，就会调用其类型指针或者值的同名方法","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534083,"discussion_content":"前面说得很好，最后面不够严谨。\n\n若在原值（而非指针值）上进行调用，如果没找到对应的值方法，Go编译器就会去找对应的指针方法。注意，这是在编译时进行的。\n\n如果找到了对应的指针方法，那么原先代码中的 val.Fun() 就会被自动改写为 (&val).Func() 。\n\n所以这属于基于编译器的语法糖。顺便说一句，对于这样的自动改写，我们在源码文件中是看不到的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638090264,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1101006,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKELX1Rd1vmLRWibHib8P95NA87F4zcj8GrHKYQL2RcLDVnxNy1ia2geTWgW6L2pWn2kazrPNZMRVrIg/132","nickname":"jxs1211","note":"","ucode":"B7F1F2D84389E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534241,"discussion_content":"所以反过来，receiver是自定义类型的指针的话，在方法中找不到对应的指针方法而找到值方法的过程，也是发生在编译时","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638148445,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":316071,"user_name":"南瓜","can_delete":false,"product_type":"c1","uid":1079562,"ip_address":"","ucode":"53561F551857A4","user_header":"https://static001.geekbang.org/account/avatar/00/10/79/0a/a417ec1c.jpg","comment_is_top":false,"comment_ctime":1634121285,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634121285","product_id":100013101,"comment_content":"老师的讲解方式，有点类似教科书，表述过于追求学术准确，以至于在含义自身的理解方面，有更多的干扰，更大的成本。 这类比较适合有个7、8层了解的，达到8、9层了解的状况。","like_count":0},{"had_liked":false,"id":293157,"user_name":"月光好猛烈","can_delete":false,"product_type":"c1","uid":1389733,"ip_address":"","ucode":"FFE328A2DA0B9D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/jiaCsf7sHE1wQRHrkGq4Cxsuv5X76tVHGfnr4pOhJ3fyouzPdmYEHsuq74Y8HmfUlibHl1zzXqsOCKraicwBibJgQQ/132","comment_is_top":false,"comment_ctime":1621247372,"is_pvip":false,"replies":[{"id":"106265","content":"你是问，Data应该是什么具体类型？还是？？<br><br>","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1621406342,"ip_address":"","comment_id":293157,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1621247372","product_id":100013101,"comment_content":"type ComResponse struct {<br>\tCode       int32       `json:&quot;err_code&quot;`<br>\tData       interface{} `json:&quot;data, omitempty&quot;`<br>}<br>这个如何声明Data的结构体，只声明不要初始化","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520099,"discussion_content":"你是问，Data应该是什么具体类型？还是？？\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621406342,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":288166,"user_name":"moonfox","can_delete":false,"product_type":"c1","uid":1526355,"ip_address":"","ucode":"902BFF40EFA9FA","user_header":"https://static001.geekbang.org/account/avatar/00/17/4a/53/063f9d17.jpg","comment_is_top":false,"comment_ctime":1618326461,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618326461","product_id":100013101,"comment_content":"讲的太细对于初学者反而不容易看懂，真不如把demo里的代码放到这里，反而让人更容易理解。","like_count":0},{"had_liked":false,"id":283259,"user_name":"MClink","can_delete":false,"product_type":"c1","uid":1435733,"ip_address":"","ucode":"F479190923355C","user_header":"https://static001.geekbang.org/account/avatar/00/15/e8/55/92f82281.jpg","comment_is_top":false,"comment_ctime":1615648732,"is_pvip":true,"replies":[{"id":"102818","content":"没有少字，一旦类型定义完成，它的方法集合也就形成了。这个类型的某个值只是持有了该类型的方法集合（的一个实例）而已。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1615787857,"ip_address":"","comment_id":283259,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1615648732","product_id":100013101,"comment_content":"一个自定义数据类型的方法集合中仅会包含它的所有值方法，而该类型的指针类型的方法集合却囊括了前者的所有方法，包括所有值方法和所有指针方法。 <br><br>是不是少了一个字，一个自定义数据类型的（值）方法集合中仅会包含它的所有值方法","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516971,"discussion_content":"没有少字，一旦类型定义完成，它的方法集合也就形成了。这个类型的某个值只是持有了该类型的方法集合（的一个实例）而已。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615787857,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":260389,"user_name":"甜质粥","can_delete":false,"product_type":"c1","uid":2153136,"ip_address":"","ucode":"696E929660A124","user_header":"https://static001.geekbang.org/account/avatar/00/20/da/b0/a2425eca.jpg","comment_is_top":false,"comment_ctime":1604996522,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604996522","product_id":100013101,"comment_content":"1. 需要注意结构体的初始化，因为嵌入的是一个指针，因此其零值为nil，而非指针类型的各个零值<br>2. 代表一个空的struct，以chan为同步手段中可以见到传递struct{}","like_count":0},{"had_liked":false,"id":217583,"user_name":"沐夜星光","can_delete":false,"product_type":"c1","uid":1447220,"ip_address":"","ucode":"22F699E237B179","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLia2EwyyEVs3tWRnMlqaAG7R7HvlW4vGvxthKsicgsCEeXO1qL7mMy6GAzgdkSKcH3c70Qa2hY3JLw/132","comment_is_top":false,"comment_ctime":1589537922,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589537922","product_id":100013101,"comment_content":"（1）方法在结构体外定义，而非在结构体内定义，是出于什么考虑？<br>（2）嵌入字段，感觉是在组合的基础上，加入了继承的特性。为什么允许被嵌入类直接调用嵌入字段的方法？这个屏蔽和继承中的隐藏太像了，而且还引入了多重继承中方法同名的问题。","like_count":0},{"had_liked":false,"id":195272,"user_name":"starj","can_delete":false,"product_type":"c1","uid":1108791,"ip_address":"","ucode":"3546E42F1340B2","user_header":"https://static001.geekbang.org/account/avatar/00/10/eb/37/a2f4c9f8.jpg","comment_is_top":false,"comment_ctime":1585152389,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585152389","product_id":100013101,"comment_content":"多用组合","like_count":0},{"had_liked":false,"id":189902,"user_name":"Cyril","can_delete":false,"product_type":"c1","uid":1024693,"ip_address":"","ucode":"29FFFAC32F911B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a2/b5/4dc0c109.jpg","comment_is_top":false,"comment_ctime":1584580831,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584580831","product_id":100013101,"comment_content":"多用组合，少用继承","like_count":0},{"had_liked":false,"id":167412,"user_name":"CcczzZ","can_delete":false,"product_type":"c1","uid":1019568,"ip_address":"","ucode":"5F46DA5053D2BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/b0/ef201991.jpg","comment_is_top":false,"comment_ctime":1577786545,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577786545","product_id":100013101,"comment_content":"重点<br>* 结构体类型基础知识，结构体类型和结构体方法<br>* 方法和函数的区别？<br>* 结构体类型的嵌入字段是什么，有什么用处<br>* 值方法和指针方法？<br><br>知识点：<br>1. 一个结构体类型可包含若干字段，也可不包含字段，每个字段通常要有确定的名称和类型；<br>2. 函数是独立的程序实体，可声明有名字函数，或者匿名函数，还可以把它们当作一个值来传递；而方法需要名字，不能被当作值传递，它必须隶属于一个某一个类型！<br>3. 嵌入字段，就是把某个类型名的字段嵌入到了一个结构体当中，只有类型名；被嵌入的结构体可以通过该类型名加 &quot;.&quot; 的方式调用其字段和方法<br>4. 方法的接收者类型必须是某个自定义类型数据。值方法，就是接收者类型是非指针的自定义类型数据方法；指针方法，接收者类型是指针类型的方法","like_count":0},{"had_liked":false,"id":132444,"user_name":"Geek_牛逼的人","can_delete":false,"product_type":"c1","uid":1372129,"ip_address":"","ucode":"0DCE0E4A85311E","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83erOXuR5pJ3zmoyMVRMXTqdYpUnROAnWMXzY8nrs9sderDaEJuSwGGcJTic3quibx9v9xaWDe6oGoyMA/132","comment_is_top":false,"comment_ctime":1568123632,"is_pvip":true,"replies":[{"id":"50866","content":"你可以贴一下你的试验代码。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1568213173,"ip_address":"","comment_id":132444,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568123632","product_id":100013101,"comment_content":"经过试验，感觉结构体方法的传参类似于深拷贝啊，方法内结构对象的属性的内存地址和元参属性的内存地址不同，这个不同于之前测试的类型的传参过程，其他很符合浅copy","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466941,"discussion_content":"你可以贴一下你的试验代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568213173,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109148,"user_name":"Sky","can_delete":false,"product_type":"c1","uid":1392585,"ip_address":"","ucode":"4C5A5AB73E8B90","user_header":"https://static001.geekbang.org/account/avatar/00/15/3f/c9/1ccefb9a.jpg","comment_is_top":false,"comment_ctime":1561971380,"is_pvip":false,"replies":[{"id":"39850","content":"平级上有同名方法的话，编译这个文件时会报错的。你的程序根本就跑不起来。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1562156764,"ip_address":"","comment_id":109148,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561971380","product_id":100013101,"comment_content":"type Animal struct {<br>    scientificName string &#47;&#47; 学名<br>    AnimalCategory        &#47;&#47; 动物学基本分类，只要写结构体名<br>    AnimalCategory1       &#47;&#47; 动物学基本分类，只要写结构体名<br>}<br>如果Animal没有实现String()方法，这时调用Printf时，是会调用AnimalCategory的String方法，还是AnimalCategory1的方法？<br>试了一下，结果是结构体内所有字段的String方法被“依次”调用了（包括scientificName 的String方法也被调用了），这是为什么？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456266,"discussion_content":"平级上有同名方法的话，编译这个文件时会报错的。你的程序根本就跑不起来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562156764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":53928,"user_name":"虢國技醬","can_delete":false,"product_type":"c1","uid":1056807,"ip_address":"","ucode":"5A192262AA037E","user_header":"https://static001.geekbang.org/account/avatar/00/10/20/27/a6932fbe.jpg","comment_is_top":false,"comment_ctime":1545757039,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545757039","product_id":100013101,"comment_content":"打卡：<br>值类型和引用类型理解是否到位很关键；对于引用类型变量为 nil 和new或者make出来的结果是不一样的，nil 表示只知道这个变量是引用类型，但是却没有指向内存中某个地址的指针，而new或者make就是申请内存地址和把变量连接起来的这个指针；","like_count":0},{"had_liked":false,"id":38080,"user_name":"川杰","can_delete":false,"product_type":"c1","uid":1099750,"ip_address":"","ucode":"815211E1D698E6","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/e6/11f21cb4.jpg","comment_is_top":false,"comment_ctime":1541927308,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541927308","product_id":100013101,"comment_content":"您好，我是一名c#语言使用者，四年工作经验。看了您的文章有个问题，您也知道oop的思想开发下，会出现对象嵌套过多的情况，在代码阅读上会产生障碍，那么对于go语言的设计哲学来讲，它是不是不鼓励这样过多的对象嵌套？","like_count":0},{"had_liked":false,"id":37591,"user_name":"Richard Zhong","can_delete":false,"product_type":"c1","uid":1213417,"ip_address":"","ucode":"F91A8EE5992FAB","user_header":"https://static001.geekbang.org/account/avatar/00/12/83/e9/3016ed84.jpg","comment_is_top":false,"comment_ctime":1541645781,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541645781","product_id":100013101,"comment_content":"请问郝老师，值类型的副本拷贝是深拷贝吗？","like_count":0},{"had_liked":false,"id":35100,"user_name":"杨赛军","can_delete":false,"product_type":"c1","uid":1050917,"ip_address":"","ucode":"12F314F9E6F158","user_header":"https://static001.geekbang.org/account/avatar/00/10/09/25/2db95c79.jpg","comment_is_top":false,"comment_ctime":1540426979,"is_pvip":false,"replies":[{"id":"13314","content":"贴源码，或者到群里使用，你可能打印的值不对。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1541482213,"ip_address":"","comment_id":35100,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540426979","product_id":100013101,"comment_content":"感觉对于本例子而言 不管是值方法还是指针方法，cat的name都会被修改成功啊。我","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427447,"discussion_content":"贴源码，或者到群里使用，你可能打印的值不对。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541482213,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34259,"user_name":"婺华","can_delete":false,"product_type":"c1","uid":1199788,"ip_address":"","ucode":"940D48C7535147","user_header":"https://static001.geekbang.org/account/avatar/00/12/4e/ac/4556ecf0.jpg","comment_is_top":false,"comment_ctime":1540050450,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540050450","product_id":100013101,"comment_content":"我也是接触了好几个语言了，神奇的是每个语言的类都有坑，并且每个类的坑不一样，所以就越来越复杂，搞不明白。","like_count":0},{"had_liked":false,"id":24442,"user_name":"金子菇凉的铁粉小逗","can_delete":false,"product_type":"c1","uid":1000602,"ip_address":"","ucode":"6A2C601F6EEBB5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/9a/c03bea17.jpg","comment_is_top":false,"comment_ctime":1537006980,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1537006980","product_id":100013101,"comment_content":"看完以后，我生物大补一下","like_count":0},{"had_liked":false,"id":23932,"user_name":"兔子高","can_delete":false,"product_type":"c1","uid":1213534,"ip_address":"","ucode":"4F710AD87D3B21","user_header":"https://static001.geekbang.org/account/avatar/00/12/84/5e/79568644.jpg","comment_is_top":false,"comment_ctime":1536723804,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1536723804","product_id":100013101,"comment_content":"你好请问什么样子的方法会像cat.SetName(&quot;monster&quot;)方法一样，go语言自动将值类型转换成引用类型调用呢?是以Set为前缀命名的方法吗？","like_count":0},{"had_liked":false,"id":23736,"user_name":"松烽","can_delete":false,"product_type":"c1","uid":1072474,"ip_address":"","ucode":"D850DBBBD3DAF0","user_header":"https://static001.geekbang.org/account/avatar/00/10/5d/5a/44858499.jpg","comment_is_top":false,"comment_ctime":1536627481,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1536627481","product_id":100013101,"comment_content":"string的方法不需要指针接受者么","like_count":0},{"had_liked":false,"id":23577,"user_name":"T、","can_delete":false,"product_type":"c1","uid":1214090,"ip_address":"","ucode":"11713A25556241","user_header":"https://static001.geekbang.org/account/avatar/00/12/86/8a/cb3b4b0f.jpg","comment_is_top":false,"comment_ctime":1536510922,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1536510922","product_id":100013101,"comment_content":"不错","like_count":0}]}