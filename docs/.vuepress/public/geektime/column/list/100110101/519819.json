{"id":519819,"title":"22｜自定义组件：如何满足业务的个性化需求？","content":"<p>你好，我是众文，这一讲还是由我和惠姝来讲解。</p><p>上一讲，我们讲了如何构建混合应用。当环境配置、载体页、调试打包都 OK 后，我们就要开始复杂业务的开发了。在实际开发中，除了负责 React Native 框架本身的维护迭代外，另一个重要的工作就是配合前端业务，开发对应的 Native 组件。</p><p>那么什么时候用这些自定义的 Native 组件呢？</p><p>比如，有时候 App 需要访问平台 API，但 React Native 可能还没有相应的模块包装；或者你需要复用公司内的一些用 Java/OC 写的通用组件，而不是用 JavaScript 重新实现一遍；又或者你需要实现某些高性能的、多线程的代码，譬如图片处理、数据库，或者各种高级扩展等。</p><p>当然，你可以通过官方文档（<a href=\"https://reactnative.cn/docs/native-modules-android\">Android</a>/<a href=\"https://reactnative.cn/docs/native-modules-ios\">iOS</a>），快速访问你的原生模块。但官方文档提供的主要是简单的 Demo 和步骤，在实际开发中，你可能还需要自定义组件的方方面面，包括新架构定义组件的全流程，以及实际业务中的踩坑指南等。</p><p>今天这一讲，我们会先带你补齐组件的相关基础知识，包括组件的生命周期、组件传输数据类型，并以新架构的TurboModule 和 Fabric 为案例，带你了解自定义组件的方方面面。你也能借此对React Native新架构建立起初步认识。接下来让我们先了解下期待已久的 React Native 新架构。</p><!-- [[[read_end]]] --><h2>新架构介绍</h2><p>我们现在先通过下面这张图简单对比下新老架构：</p><p><img src=\"https://static001.geekbang.org/resource/image/3e/31/3eb92714433185cd0a095yy2e1a36331.jpg?wh=1920x932\" alt=\"图片\"></p><p>新架构变更点主要在下面这几个方面：</p><p><img src=\"https://static001.geekbang.org/resource/image/4d/8d/4df0702732be0a4922444d575980828d.png?wh=1894x1216\" alt=\"图片\"></p><p>前面也说了，我们一讲将以 TurboModule 和 Fabric 为案例对自定义组件进行讲解。所以你现在需要对新架构有一个初步的认识，特别是要注意，TurboModule 和 Fabric 对比旧版的 Native Module 和 UIManager 有哪些差异和优势。</p><p>如果你还想了解新架构的更多信息，你可以参考<a href=\"https://reactnative.dev/docs/new-architecture-intro\">官方文档</a>。这里包括了新架构介绍、如何在 Android、iOS 上开启新架构、如何在 Android、iOS 上开启使用 TurboModule 和 Fabric等。你也可以根据官方文档试着编译运行新架构。</p><p>而且，<a href=\"https://github.com/software-mansion/react-native-screens\">react-native-screens</a>、<a href=\"https://github.com/software-mansion/react-native-gesture-handler\">react-native-gesture-handler</a> 等知名 React Native 库的新版都已适配了新架构，感兴趣的话，你可以去了解下。</p><p>好的，现在我们进入这一讲的正题，先来了解一下组件的生命周期。</p><h2>组件的生命周期</h2><p>组件的生命周期，指的是在组件创建、更新、销毁的过程中伴随的各种各样的函数执行。这些在组件特定的时期被触发的函数，统称为组件的生命周期。</p><p>让组件拥有生命周期，我们就可以更好地管理组件的状态、内存，跟随载体页的生命周期做相应的处理。</p><h3>Android</h3><p>在Android端，一个 Module 组件的生命周期包括：</p><pre><code class=\"language-plain\">构造 -&gt; 初始化 -&gt; onHostResume() -&gt; onHostPause() -&gt; onHostDestroy()\n</code></pre><p>这几个生命周期的意思是：</p><p><img src=\"https://static001.geekbang.org/resource/image/1b/1b/1bdfff7c48055490ce06ab49eff5f01b.png?wh=1824x1110\" alt=\"图片\"></p><p>如果你不熟悉 Android Activity/Fragment 生命周期，那你可以看下<a href=\"https://www.jianshu.com/p/1b3f829810a1\">这篇文章</a>加深下理解。</p><p>那么如何让 Native Module 具备生命周期呢？</p><p>React Native 给我们提供了一个接口：com.facebook.react.bridge.LifecycleEventListener。我们只需要在组件中添加这个接口的注册和取消注册，就可以让组件具备生命周期了。这里要注意，不要忘记在 onHostDestroy() 中移除注册，否则会造成内存泄漏。示例代码如下：</p><pre><code class=\"language-plain\">public class TestJavaModule extends ReactContextBaseJavaModule \n implements LifecycleEventListener, ReactModuleWithSpec, TurboModule {\n    public TestJavaModule(ReactApplicationContext reactContext) {\n       super(reactContext.real());\n       reactContext.addLifecycleEventListener(this);\n    }\n\n    @Override\n    public String getName() {\n       return getClass().getSimpleName();\n    }\n\n    @Override\n    public void onHostResume() {\n    }\n\n    @Override\n    public void onHostPause() {\n    }\n\n    @Override\n    public void onHostDestroy() {\n       getReactApplicationContext().removeLifecycleEventListener(this); \n    }\n}\n</code></pre><p>其实组件的生命周期原理很简单，就是观察者模式。当载体页触发自身的生命周期回调时，调用 ReactInstanceManager 的 onHostXXX() 方法，ReactInstanceManager 进而调用 ReactContext 的对应回调。</p><p>比如载体页调用 onResume() 时，最终会调用 ReactContext 的 onHostResume()，内部会遍历注册的事件进行回调：</p><pre><code class=\"language-plain\">public void onHostResume(@Nullable Activity activity) {\n    Iterator iterator = this.mLifecycleEventListeners.iterator();\n    while(iterator.hasNext()) {\n        LifecycleEventListener listener = (LifecycleEventListener) iterator.next();\n        // 观察者模式，载体页时调用已注册组件的生命周期回调\n        listener.onHostResume();\n    }\n}\n</code></pre><p>以上就是 Android 端组件生命周期的讲解，我们再来看看 iOS 端。</p><h3>iOS</h3><p>iOS中 NativeModules 组件的创建销毁时机，与bridge的创建销毁时机完全一致：</p><ul>\n<li>alloc：创建当前组件；</li>\n<li>dealloc：销毁当前组件。</li>\n</ul><p>创建一个组件TestNativeModule，通过RCT_EXPORT_MODULE() 声明组件，默认会根据类名声明组件名，当然也可以通过在参数中传入其他字符串作为组件的名。</p><pre><code class=\"language-plain\">@implementation TestNativeModule\nRCT_EXPORT_MODULE()\n\n- (instancetype)init{\n&nbsp; self = [super init];\n&nbsp; return self;\n}\n- (void)dealloc{\n  NSLog(@\"dealloc\");\n}\n</code></pre><p>而 <strong>TurboModule</strong> 组件的生命周期却与 NativeModule 不同。TurboModule 采用懒加载模式，在 Bridge 创建后页面中第一次 import 当前TurboModule ，也就是 JavaScript 端通过 <strong>TurboModuleRegistry.getEnforcing</strong>方法加载组件时， Native 会创建对应的 TurboModule 并进行缓存。如果 JS 端没有加载当前自定义组件，该组件就不会进行初始化。</p><p>JS 端加载组件方式如下：</p><pre><code class=\"language-plain\">export default (TurboModuleRegistry.getEnforcing&lt;Spec&gt;(\n   'TestTurboModule')\n  : Spec);\n</code></pre><p>而TurboModule 的销毁时机与 Bridge 的销毁时机一致。 Bridge 进行销毁时会发送一个 RCTBridgeDidInvalidateModulesNotification 通知，TurboModuleManager会监听该事件，依次对所有已创建的 TurboModule 进行销毁。示例代码如下：</p><pre><code class=\"language-plain\">- (void)bridgeDidInvalidateModules:(NSNotification *)notification\n{\n&nbsp; RCTBridge *bridge = notification.userInfo[@\"bridge\"];\n&nbsp; if (bridge != _bridge) {\n&nbsp; &nbsp; return;\n&nbsp; }\n&nbsp; [self _invalidateModules];//销毁所有TurboModules\n}\n</code></pre><p>了解完了组件的生命周期，我们再来看下组件的传输数据类型。在组件运行过程中，Native 与 JavaScript 不可避免地需要进行数据交互，如 JavaScript 调用组件方法传入数据，Native 向 JavaScript 回传结果，而 React Native 也帮我们封装好了对应的数据类型。</p><h2>组件传输数据类型</h2><p>在 Native 与 JavaScript 通信的过程中，组件需要获取输入参数、回传结果，对此 React Native 给我们包装了相应的数据类型，方便快速操作，我们通过一个Demo来简单了解下。</p><p>现在，我们让JavaScript端调用 TestModule 的 testMethod 方法，传入参数 type 和 message，接收 native 回传数据：</p><pre><code class=\"language-plain\">NativeModules.TestModule.testMethod({type: 1, message: \"fromJS\"}, (result)=&gt;{\n    console.info(result);\n  }\n);\n</code></pre><p>然后我们来看TestModule 在 Android、iOS 侧的实现。先来看 Android 端是怎么做的。</p><p>不过，在实现 TestModule 之前，我们需要先了解下 Android 端的组件传输数据类型：</p><p><img src=\"https://static001.geekbang.org/resource/image/61/87/615f0162574e42c30557a1356472ee87.png?wh=744x924\" alt=\"图片\"></p><p>这里你要注意，数字类型有点特殊。因为 JavaScript 不支持 long 64 位长类型，只支持 int (32)和double，所以对于长数字，JavaScript端统一用 double 表示。那么 Android 端如何转换成自己需要的数据类型呢？</p><p>我们以 long 为例，可以这样参考<a href=\"https://github.com/facebook/react-native/issues/12506\">官方issue</a>这样处理：</p><pre><code class=\"language-plain\">double value = readableMap.getDouble(key);\ntry {\n    // 判断是否为 long 的范围: 超过了 int 的最大值且为整数\n    if (value &gt; Integer.MAX_VALUE &amp;&amp; value % 1 == 0) {\n        long cv = (long) value;\n        // 转换成 long 型返回\n    }\n} catch (Exception e) {\n    // 异常时，仍使用 double\n}\n</code></pre><p>这段代码中，我们先将 JavaScript 传入的数值统一以双精度浮点数 double 来获取。获取完后，判断这个值是否超出了整数的最大值且不为小数，条件符合就将它转换成长整数 long，否则还是以 double 来返回。</p><p>了解完 Android 端的组件数据传输类型后，我们就可以来实现上文中的 TestModule了：</p><pre><code class=\"language-plain\">public class TestModule extends ReactContextBaseJavaModule implements ReactModuleWithSpec, TurboModule {\n   public TestModule(ReactApplicationContext reactContext) {\n      super(reactContext.real());\n   }\n\n   @Override\n   public String getName() {\n      return getClass().getSimpleName();\n   }\n   \n   @ReactMethod\n   public void testMethod(ReadableMap data, Callback callback) {\n      // 获取 JS 的调用输入参数\n      int type = data.getInt(\"type\");\n      String message = data.getString(\"message\");\n      // 回传数据给 JS\n      WritableMap resultMap = new WritableNativeMap();\n      map.putInt(\"code\", 1);\n      map.putString(\"message\", \"success\");\n      callback.invoke(resultMap);\n   }\n}\n</code></pre><p>上面代码中，我们定义了 Native 组件 TestModule，内部实现了 JavaScript 需要调用的 testMethod 方法。此方法包含两个参数：ReadableMap 和 Callback。ReadableMap 为 JavaScript 传入参数的字典，我们可以通过对应的 key 获取到 JavaScript 的入参值，而 Callback 是在 Native 回传数据时需要使用的，后面我们还有对通信方式这部分的讲解，这里我们只需要了解一下就好。</p><p>具体实现上，我们是首先获取 JavaScript 调用传入的 type 和 message，然后再通过 WritableMap 写入数据，最后通过 callback 回传给 JavaScript。</p><p>以上就是 Android 端的 React Native 读写数据类型，我们再来看下 iOS 端。</p><p>iOS端也是一样，在实现前面这个 demo 前，我们需要先看下 iOS 端支持的传入数据类型：</p><p><img src=\"https://static001.geekbang.org/resource/image/af/f8/afbea1f2yyfa12fec0df7248913d97f8.png?wh=772x956\" alt=\"图片\"></p><p>那么，iOS端中是如何实现上文中的TestModule的呢？我们可以在Module中进行callback，然后通过NSArray来返回，如下：</p><pre><code class=\"language-plain\">RCT_EXPORT_METHOD(getValueWithCallback : (RCTResponseSenderBlock)callback){\n&nbsp; if (!callback) {\n&nbsp; &nbsp; return;\n&nbsp; }\n&nbsp; callback(@[ @\"value from callback!\" ]);\n}\n\n</code></pre><p>不过，我们这个组件案例，只是演示了 Native 可以通过 callback 向 JavaScript 回传数据。那么除了 callback，React Native 与原生还有什么通信方式呢？</p><h2>React Native 与原生的通信方式</h2><p>总体来说，native 向 JavaScript 传递数据的方式分成以下三种：</p><ul>\n<li>Callback：由 JavaScript 主导触发，Native 进行回传，一次触发只能传递一次；</li>\n<li>Promise：由 JavaScript 主导触发，Native 进行回传，一次触发只能传递一次。Promise 是 ES6 的新特性，类似 RXJava 的链式调用。Promise 有三种状态，分别是pending (进行时)、resolve (已完成)、reject (已失败)；</li>\n<li>发送事件：由 Native 主导触发，可传递多次，类似 Android 的广播和 iOS 的通知中心。</li>\n</ul><p>Callback 在上面的例子中已经出现过了，我们通过 callback.invoke(xx) 就可以将数据回传给 JavaScript，使用起来比较简单，这边我们就不再赘述了。现在我们主要来看下 Promise 和发送事件的示例，以便更好地了解 React Native 和原生之间是如何进行通信的。</p><p><strong>首先我们来看下Promise 示例</strong>，我们从 JavaScript 如何触发、Native 如何回传数据两方面来进行讲解。</p><p>首先，JavaScript 端调用客户端定义的 SystemPropsModule 的 getSystemModel 来获取手机的设备类型，获取结果的方式使用 Promise 方式 （then… catch…）：</p><pre><code class=\"language-plain\">NativeModules.SystemPropsModule.getSystemModel().then(result=&gt; {\n  console.log(result);\n}).catch(error=&gt; {\n   console.log(error);\n});\n</code></pre><p>然后，Native 端定义 SystemPropsModule，实现 getSystemModel 方法，内部使用 promise 获取手机的 model 数据。使用 promise.reolve(xx) 为成功，promise.reject(xx) 为失败：</p><pre><code class=\"language-plain\">SystemPropsModule：\n...\n@ReactMethod\npublic void getSystemModel(Promise promise) {\n    // 回传成功，使用 resolve\n    promise.resolve(Build.MODEL);\n}\n...\n</code></pre><p><strong>接下来看发送事件示例</strong>，我们从 JavaScript 如何监听 Native 事件、Native 如何发送事件这两方面来进行讲解。</p><p>首先，JavaScript 端使用 EventEmitterManager 来注册 Native 的事件监听。通过 NativeModules 获取 EventEmitterManager，随后使用它构建出 NativeEventEmitter，最后通过 NativeEventEmitter 注册监听：</p><pre><code class=\"language-plain\">componentWillMount(){\n   // 拿到原生模块\n   var eventEmitterManager = NativeModules.EventEmitterManager;\n   const nativeEventEmitter = new NativeEventEmitter(eventEmitterManager);\n   const eventEmitterManagerEvent = EventEmitterManager.EventEmitterManagerEvent;\n   // 监听 Native 发送的通知\n   this.listener = nativeEventEmitter.addListener(eventEmitterManagerEvent, (data) =&gt; \n       console.log(\"Receive native event: \" + data);\n   );\n}\n\ncomponentWillUnmount(){\n   // 移除监听\n   this.listener.remove();\n}\n</code></pre><p>在 Native 端的使用则很简单。我们获取 RCTDeviceEventEmitter 这个 JSModule，使用 emit 方法就可以向 JavaScript 发送事件了：</p><pre><code class=\"language-plain\">reactContext.getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)\n  .emit(\"msg\", \"say hello\");\n</code></pre><p>自定义组件相关的知识点，我们先介绍到这里。接下来进入实战阶段，我们将分别以一个数据存取 TurboModule 和视频播放 Fabric component 的案例，加深你对自定义组件的理解。我们先来看TurboModule。</p><h2>TurboModule：数据存取</h2><p>TurboModule 采用懒加载模式，在运行时第一次 import 该 TurboModule 时， Native 会创建对应的 TurboModule 并进行缓存。而旧版本的 NativeModule 都是在创建环境时统一进行构造的，会对 React Native 的启动性能有比较大的影响。</p><p>接下来我们以一个实际的案例来带你了解 TurboModule。当你需要使用 native 数据存取相关能力，如跨进程存取、偏好存取、加密存取等，而 React Native 自带的数据存储 module 满足不了你的需求，你可以通过自定义数据存储的 TurboMoudle 来实现。我们先来看下 JavaScript 侧。</p><h3>JavaScript</h3><p>在 Spec 中定义方法，定义好存和取的方法后，再导出 StorageModule：</p><pre><code class=\"language-plain\">export interface Spec extends TurboModule {\n+save: (key: string, value: string, callback: (value: Object) =&gt; void) =&gt; void;\n+get: (key: string, callback: (value: Object) =&gt; void) =&gt; void;\n}\n// 导出 StorageModule\nexport default (TurboModuleRegistry.getEnforcing&lt;Spec&gt;(\n'StorageModule',\n): Spec);\n</code></pre><p>调用：</p><pre><code class=\"language-plain\">NativeModules.StorageModule.save(\"testKey\", \"testValue\", (result)=&gt;{\n    console.info(result);\n  }\n);\nNativeModules.StorageModule.get(\"testKey\", (result)=&gt;{\n    console.info(result);\n  }\n);\n</code></pre><p>接下来我们再看看 Android 端和 iOS 端的实现。</p><h3>Android</h3><p>在实现 StorageModule 之前，我们需要在混合工程中，将 React Native 新架构的运行配置搭建好，这套配置可以运行 TurboModule、Fabric，后面的 Fabric 案例也是基于此配置来运行的。</p><p>而且，上一讲在我们已经讲解了如何基于 React Native 最新版本（0.68.0）搭建混合应用，我们再这个基础上开启新架构配置就好了。</p><p><strong>第一步，我们要做些准备工作，也就是获取 newarchitecture 的模版代码。</strong></p><p>我们以 0.68.0 版本创建一个 React Native 工程，来获取新架构的模版代码，我们把这个工程名叫做ReactNativeNewArch：</p><pre><code class=\"language-plain\">npx react-native init ReactNativeNewArch --version 0.68.0\n</code></pre><p>创建好后，你将看到如下工程代码，包含 Java 和 C++：</p><p><img src=\"https://static001.geekbang.org/resource/image/f6/3a/f64e5f3da0730b6a6a8928dc9736ea3a.png?wh=1164x1394\" alt=\"图片\"></p><p>这些工程代码主要是新架构的 JSI、Fabric、TurboModule 的注册和加载代码，内部逻辑非常复杂，这一讲我们就不做过多分析了，先专注于实操部分。</p><p>如果我们想基于这个 Demo 去运行新架构，可以做如下操作：</p><pre><code class=\"language-plain\">1. 修改 android 目录下的 gradle.properties:\n# 开启新架构\nnewArchEnabled=true\n# 配置 java home 为 JDK 11\norg.gradle.java.home=/Library/Java/JavaVirtualMachines/jdk-11.0.2.jdk/Contents/Home\n\n2. 运行\nyarn react-native run-android\n</code></pre><p><strong>第二步，拷贝 newarchitecture 的模版代码到我们之前的混合工程。</strong></p><p>这一步中，我们需要将 Java 层和 C++ 层代码拷贝到混合工程中，需要拷贝的相关代码如下：</p><pre><code class=\"language-plain\">Java 层：\n- MainComponentsRegistry.java\n- MainApplicationTurboModuleManagerDelegate.java\n\nC++ 层：\n- jni 目录\n</code></pre><p>拷贝完的效果是这样的：</p><p><img src=\"https://static001.geekbang.org/resource/image/b5/73/b51022154e4d1831428ced687c224173.png?wh=880x1076\" alt=\"图片\"></p><p><strong>第三步是修改拷贝的代码，主要是下面这四点。</strong></p><p><strong>1.MainApplicationTurboModuleManagerDelegate.java：</strong></p><p>修改 so 库名称为我们自定义名称 geektime_new_arch。</p><pre><code class=\"language-plain\">@Override\nprotected synchronized void maybeLoadOtherSoLibraries() {\n  if (!sIsSoLibraryLoaded) {\n    SoLoader.loadLibrary(\"geektime_new_arch\");\n    sIsSoLibraryLoaded = true;\n  }\n}\n</code></pre><p><strong>2.jni/Android.mk：</strong>修改 Android.mk 中的 so 库名称为上面的 geektime_new_arch。</p><pre><code class=\"language-plain\"># You can customize the name of your application .so file here.\nLOCAL_MODULE := geektime_new_arch\n</code></pre><p><strong>3.jni/MainApplicationTurboModuleManagerDelegate.h：</strong>修改 MainApplicationTurboModuleManagerDelegate 对应的 Java 类路径，截图中拷贝好的 MainApplicationTurboModuleManagerDelegate.java 路径为 com/reactnativenewarch/newarchitecture/modules。</p><pre><code class=\"language-plain\">static constexpr auto kJavaDescriptor =\n    \"Lcom/reactnativenewarch/newarchitecture/modules/MainApplicationTurboModuleManagerDelegate;\";\n</code></pre><p><strong>4.jni/MainComponentsRegistry.h：</strong>修改 MainComponentsRegistry 对应的 Java 类路径，截图中拷贝好的 MainComponentsRegistry.java 路径为 com/reactnativenewarch/newarchitecture/components。</p><pre><code class=\"language-plain\">constexpr static auto kJavaDescriptor =\n    \"Lcom/reactnativenewarch/newarchitecture/components/MainComponentsRegistry;\";\n</code></pre><p><strong>做完后，最后一步就是修改 React Native 初始化代码了。</strong></p><p>这里有两处要修改。第一处是设置 ReactPackageTurboModuleManagerDelegateBuilder 为上面的 MainApplicationTurboModuleManagerDelegate（TurboModule 用）；第二处是设置 setJSIModulesPackage（Fabric 用，JSI 实现）：</p><pre><code class=\"language-plain\">public void initRN() {\n    ReactInstanceManagerBuilder builder = ReactInstanceManager.builder()\n        .setApplication((Application) getApplicationContext())\n        .addPackage(new MainReactPackage())\n        .setJSMainModulePath(\"index.android\")\n        .setInitialLifecycleState(LifecycleState.BEFORE_CREATE)\n        .setReactPackageTurboModuleManagerDelegateBuilder(new MainApplicationTurboModuleManagerDelegate.Builder())\n        .setJSIModulesPackage(getJSIModulePackage());\n\n    ReactInstanceManager reactInstanceManager = builder.build();\n}\n</code></pre><p>其中 getJSIModulePackage() 我特意摘出来放在了下面。这段代码实现需要从模版代码的 MainApplicationReactNativeHost 的 getJSIModulePackage 拷贝，内部调用了上面的 MainComponentsRegistry 进行注册：</p><pre><code class=\"language-plain\">static JSIModulePackage getJSIModulePackage() {\n  return new JSIModulePackage() {\n    @Override\n    public List&lt;JSIModuleSpec&gt; getJSIModules(\n      final ReactApplicationContext reactApplicationContext,\n      final JavaScriptContextHolder jsContext) {\n      final List&lt;JSIModuleSpec&gt; specs = new ArrayList&lt;&gt;();\n      specs.add(\n          new JSIModuleSpec() {\n            @Override\n            public JSIModuleType getJSIModuleType() {\n              return JSIModuleType.UIManager;\n            }\n\n            @Override\n            public JSIModuleProvider&lt;UIManager&gt; getJSIModuleProvider() {\n              final ComponentFactory componentFactory = new ComponentFactory();\n              CoreComponentsRegistry.register(componentFactory);\n              MainComponentsRegistry.register(componentFactory);\n\n              List&lt;ViewManager&gt; viewManagers = new ArrayList&lt;&gt;();\n              ViewManagerRegistry viewManagerRegistry = new ViewManagerRegistry(viewManagers);\n              return new FabricJSIModuleProvider(\n                  reactApplicationContext,\n                  componentFactory,\n                  new EmptyReactNativeConfig(),\n                  viewManagerRegistry);\n            }\n          });\n      return specs;\n    }\n  };\n}\n</code></pre><p>至此，我们新架构的运行环境就配置好了。由于目前新架构文章非常少，几乎没有混合工程运行新架构的方案，上面这些主要是我们用了大量的时间去调研和测试的结果，你可以参考一下。</p><p>好了，回到正题。在混合工程中，新架构的运行环境搭建好后，我们就可以简单快速地来写 TurboModule 和 Fabric 了。</p><p>我们继续来进行数据存储的 Demo 在 Java 层定义并实现  StorageModule。Android 端我们使用 SharedPreferences 来实现轻量级偏好存取。这里要注意，你需要继承 ReactModuleWithSpec和TurboModule，具体代码如下：</p><pre><code class=\"language-plain\">// 1. 定义 StorageModule，继承 ReactContextBaseJavaModule 类\n// 实现 ReactModuleWithSpec &amp; TurboModule 接口\npublic class StorageModule extends ReactContextBaseJavaModule\n    implements ReactModuleWithSpec, TurboModule {\n    // native 存储的 sp 文件名称\n    private static final String SP_NAME = \"rn_storage\";\n    // 返回给 JS 的结果码\n    private static final int CODE_SUCCESS = 1;\n    private static final int CODE_ERROR = 2;\n\n    public StorageModule(ReactApplicationContextWrapper reactContext) {\n       super(reactContext);\n    }\n\n    // 返回 module 名称，一般以类名作为 module 名称\n    @Override\n    public String getName() {\n       return StorageModule.class.getSimpleName();\n    }\n  \n    // 定义供 JS 调用的存储数据方法，isBlockingSynchronousMethod 表示是否同步执行\n    @ReactMethod(isBlockingSynchronousMethod = true)\n    public void save(String key, String value, Callback callback) {\n       WritableMap result = new WritableNativeMap();\n       // 如果 js 传入的 key 为空，则回传失败码和信息\n       if (TextUtils.isEmpty(key)) {\n           result.putInt(\"code\", CODE_ERROR);\n           result.putString(\"msg\", \"key is empty or null\");\n           callback.invoke(result);\n           return;\n       }\n       // 调用 native 的 sp 进行数据存储\n       SharedPreferences sp = getReactApplicationContext().getSharedPreferences(SP_NAME, Context.MODE_PRIVATE);\n       sp.edit().putString(key, value).apply();\n       result.putInt(\"code\", CODE_SUCCESS);\n       result.putString(\"msg\", \"save success\");\n       // 回传 js 告知存储成功\n       callback.invoke(result);\n   }\n\n    // 定义供 JS 调用的获取数据方法，isBlockingSynchronousMethod 表示是否同步执行\n   @ReactMethod(isBlockingSynchronousMethod = true)\n   public void get(String key, Callback callback) {\n      // 如果 js 传入的 key 为空，则回传失败码和信息\n      WritableMap result = new WritableNativeMap();\n      if (TextUtils.isEmpty(key)) {\n         result.putInt(\"code\", CODE_ERROR);\n         result.putString(\"msg\", \"key is empty or null\");\n         callback.invoke(result);\n         return;\n      }\n      // 调用 native 的 sp 获取 key 对应的 value 值\n      SharedPreferences sp = getReactApplicationContext().getSharedPreferences(SP_NAME, Context.MODE_PRIVATE);\n      String value = sp.getString(key, \"\");\n      result.putInt(\"code\", CODE_SUCCESS);\n      result.putString(\"data\", value);\n      // 将结果回传给 js\n      callback.invoke(result);\n  }\n}\n</code></pre><p>然后是注册组件，注意 Package 需要继承 TurboReactPackage：</p><pre><code class=\"language-plain\">public class MyTurboModulePackage extends TurboReactPackage {\n    @Override\n    public NativeModule getModule(String name, ReactApplicationContext reactContext) {\n        switch(name) {\n           case \"StorageModule\":\n              return new StorageModule(reactContext);\n              break;\n           default:\n              return null;\n        }\n    }\n    \n    @Override\n    public ReactModuleInfoProvider getReactModuleInfoProvider() {\n      //...\n    }\n}\n</code></pre><p>接下来注册到 ReactInstanceManager （使用 reactInstanceManagerBuilder注册）：</p><pre><code class=\"language-plain\">ReactInstanceManagerBuilder builder = ReactInstanceManager.builder()\n   .addPackage(new MyTurboModulePackage());\n... // 其他 RN 初始化配置\nReactInstanceManager reactInstanceManager = builder.build();\n</code></pre><p>然后我们利用新架构提供的 Codegen，生成新架构需要的 native 代码。不过，在使用 codegen 之前，我们需要在项目中应用相关的插件：</p><p>(1) 在工程根目录安装 react-native-gradle-plugin。</p><pre><code class=\"language-plain\">yarn add react-native-gradle-plugin\n</code></pre><p>(2) 在工程根目路的 settings.gradle 中配置 react-native-gradle-plugin，使用复合构建引入。</p><pre><code class=\"language-plain\">include ':app'\nrootProject.name = \"GeekTimeRNAndroid\"\nincludeBuild('./node_modules/react-native-gradle-plugin')\n</code></pre><p>(3) 在 app/build.gradle 中应用插件。</p><pre><code class=\"language-plain\">apply plugin: \"com.facebook.react\"\n</code></pre><p>这样做后，工程的 gradle 任务中就会出现 generateCodegenArtifactsFromSchema task。</p><pre><code class=\"language-plain\">配置好后，我们以后就可以使用 codegen 能力了，然后执行 generateCodegenArtifactsFromSchema，最后运行App就可以了。\n../gradlew generateCodegenArtifactsFromSchema\n</code></pre><p>Android端的就是这样，现在我们看iOS端需要怎么做。</p><h3>iOS</h3><p>在iOS端中，首先我们要创建一个类并遵循一个协议 spec ，协议中包含注册的API声明。而且，该协议需要遵循 RCTBridgeModule 协议和 RCTTurboModule 协议，并且创建一个JSI。示例代码如下：</p><pre><code class=\"language-plain\">//定义一个Spec协议\n@protocol DataStorageTurboModuleSpec &lt;RCTBridgeModule, RCTTurboModule&gt;\n- (NSString *)getString:(NSString *)string;\n@end\n\n//JSI实现\nnamespace facebook {\nnamespace react {\nclass JSI_EXPORT DataStorageTurboModuleSpecJSI : public ObjCTurboModule {\n&nbsp;  public:\n&nbsp;   DataStorageTurboModuleSpecJSI(const ObjCTurboModule::InitParams &amp;params);\n  };\n} // namespace react\n} // namespace facebook\n\n//定义一些方法\nnamespace facebook {\n&nbsp; namespace react {\n&nbsp; &nbsp;&nbsp;static facebook::jsi::Value __hostFunction_DataStorageTurboModuleSpecJSI_getString(\n&nbsp; &nbsp; facebook::jsi::Runtime &amp;rt,\n&nbsp; &nbsp; TurboModule &amp;turboModule,\n&nbsp; &nbsp; const facebook::jsi::Value *args,\n&nbsp; &nbsp; size_t count){\n&nbsp;   return static_cast&lt;ObjCTurboModule &amp;&gt;(turboModule)\n&nbsp; &nbsp; &nbsp; .invokeObjCMethod(rt, VoidKind, \"getString\", @selector(getString:), args, count);\n  }\n&nbsp;&nbsp; DataStorageTurboModuleSpecJSI::NativeSampleTurboModuleSpecJSI(const ObjCTurboModule::InitParams &amp;params)\n&nbsp; &nbsp; : ObjCTurboModule(params)\n&nbsp; {\n    //MethodMetadata 第一个参数为0代表该方法有一个参数\n&nbsp; &nbsp; methodMap_[\"getString\"] = MethodMetadata{1, __hostFunction_DataStorageTurboModuleSpecJSI_getString};\n&nbsp; }\n}\n}\n\n//TurboModule遵循Spec协议\n@interface DataStorageTurboModule : NSObject &lt;DataStorageTurboModuleSpec&gt;\n\n@end\n</code></pre><p>之后，我们要在该类中注册组件名和API：</p><pre><code class=\"language-plain\">//DataStorageTurboModule.mm\n@implementation DataStorageTurboModule\nRCT_EXPORT_MODULE()\n\n- (std::shared_ptr&lt;facebook::react::TurboModule&gt;)getTurboModule:\n&nbsp; &nbsp; (const facebook::react::ObjCTurboModule::InitParams &amp;)params{\n  //指定JSI\n&nbsp; return std::make_shared&lt;DataStorageTurboModuleSpecJSI&gt;(params);\n}\n\nRCT_EXPORT_METHOD(getString:(NSString *)string){\n  NSLog(@\"\");\n}\n@end\n</code></pre><p>以上便是自定义一个 TurboModule的流程。其实定义 TurboModule 并不复杂，而且 Facebook 也提供了代码生成工具 codegen，比较复杂的是在混合工程中搭建新架构的运行环境。前面我们花了不少内容讲述如何在客户端开启新架构，接下来的 Fabric 组件介绍也将在新架构环境基础上进行讲解，接下来我们继续来看Fabric 自定义组件。</p><h2>Fabric：视频播放</h2><p>Fabric 对标旧框架的 UIManager。FabricUIManager 可以和 C++ 层直接进行通讯，解除了原有的 UIManager 依赖单个 bridge 的问题。有了 JSI 后，以前批量依赖 bridge 的 UI 操作，都可以同步执行到 C++ 层，性能得到大幅提升，特别是在列表快速滑动、复杂动画交互方面提升更加明显。</p><p>现在，我们以一个视频播放组件为例，讲讲如何定义 Fabric 组件。我们先来看下 JavaScript 端的实现。</p><h3>JavaScipt</h3><p>JavaScript需要定义属性以及 API，并 export 组件。示例代码如下：</p><pre><code class=\"language-plain\">type NativeProps = $ReadOnly&lt;{|\n  ...ViewProps,\n  url?: string\n|}&gt;; // 定义视频播放的属性，url 为视频地址\n\nexport type VideoViewType = HostComponent&lt;NativeProps&gt;;\n\n// 定义视频播放的方法，包括开始播放、停止播放、暂停播放\ninterface NativeCommands {\n  +callNativeMethodToPlayVideo: (\n  ) =&gt; void;\n  +callNativeMethodToStopVideo: (\n  ) =&gt; void;\n  +callNativeMethodToPauseVideo: (\n  ) =&gt; void;\n}\n\n//导出外部调用的命令，包括开始播放、停止播放、暂停播放\nexport const Commands: NativeCommands = codegenNativeCommands&lt;NativeCommands&gt;({\n  supportedCommands: ['callNativeMethodToPlayVideo'],\n  supportedCommands: ['callNativeMethodToStopVideo'],\n  supportedCommands: ['callNativeMethodToPauseVideo'],\n});\n\n// 导出包装好的组件，其中 VideoView 为引入 Native 的组件\nexport default (codegenNativeComponent&lt;NativeProps&gt;(\n  'VideoView',\n): VideoViewType);\n\n</code></pre><p>JavaScript 端使用该组件：</p><pre><code class=\"language-plain\">// 导入 ViewView 组件和工具\nimport VideoView, {\n  Commands as VideoViewCommands,\n} from './VideoNativeComponent';\n\n// 外部调用此方法即可调用 ViewView 视频播放能力\nexport default function MyView(props: {}): React.Node {\n  return (\n     &lt;View&gt;\n         &lt;VideoView url={\"url\"} style={{flex: 1}} /&gt;\n         &lt;Button title=\"play\" onPress={()=&gt;{\n             VideoViewCommands.callNativeMethodToPlayVideo();\n           }\n         }\n     &lt;/View&gt;\n  )\n}\n</code></pre><p>接下来我们再看看 Android 端和 iOS 端的实现。</p><h3>Android</h3><p>由于在前面 TurboModule 的部分，我们已经讲解了如何在混合工程中开启新架构运行模式，我么这里就不再重复了。前面的方法同样适用于 Fabric，我们只需要搭建一次就好了。所以现在要在 Android 端实现 Fabric 组件也非常简单，我们来看下具体实现。</p><p><strong>第一步，定义视频播放接口。</strong></p><p>这里我们要定义 VideoViewManagerInterface，其中包含三个方法：播放视频、停止播放、暂停播放：</p><pre><code class=\"language-plain\">public interface VideoViewManagerInterface&lt;T extends View&gt; {\n   void playVideo(T view, String url);\n   void stopVideo(T view);\n   void pauseVideo(T view);\n}\n</code></pre><p><strong>第二步，定义视频播放 View。</strong></p><p>这一步中，我们要实现视频播放的 View。在 View 中，我们需要实现视频的播放、停止和暂停功能。但播放能力的实现并不是我们讲解的重点，我们这一讲侧重于新架构中 Frabic 组件的实现流程，所以我们这边使用伪代码：</p><pre><code class=\"language-plain\">public class MyVideoView extends View {\n   // ...\n     \n   public void playVideo(String url) {\n       // 播放视频实现\n   }\n     \n   public void stopVideo() {\n      // 停止视频播放实现\n   }\n\n   public void pauseVideo() {\n      // 暂停视频播放实现\n   }\n}\n</code></pre><p><strong>第三步，定义 ViewManager。</strong></p><p>在这一步中，我们要实现暴露给 React Native 调用的能力，包括视频播放、停止，以及暂停，内部会转发到上面我们定义的视频播放 View 的实现中。示例代码如下：</p><pre><code class=\"language-plain\">@ReactModule(name = VideoViewManager.REACT_CLASS)\npublic class VideoViewManager: ViewGroupManager&lt;VideoView&gt;(), VideoViewManagerInterface&lt;VideoView&gt; {\n     private static final String REACT_CLASS = \"VideoView\";\n     \n     public VideoViewManager() {\n     }\n\n     override\n     public String getName() {\n        return REACT_CLASS;\n     }\n     \n     override\n     public VideoView createViewInstance(ThemedReactContext reactContext) {\n        return new MyVideoView(reactContext);\n     }\n     \n     @ReactProp(name = \"url\")\n     override \n     public void playVideo(VideoView view, String url) {\n        view.playVideo(url);\n     }\n     \n     override \n     public void stopVideo(VideoView view) {\n        view.stopVideo();\n     }\n\n     override \n     public void pauseVideo(VideoView view) {\n        view.pauseVideo();\n     }\n}\n</code></pre><p><strong>最后一步就是注册 ViewManager。</strong>我们在 ReactInstanceManager 的 JSIModulesPackage 中注册 VideoViewManager：</p><pre><code class=\"language-plain\">List&lt;ViewManager&gt; viewManagers = new ArrayList&lt;&gt;();\nviewManagers.add(new VideoViewManager())\nViewManagerRegistry viewManagerRegistry = new ViewManagerRegistry(viewManagers);\n\nreturn new FabricJSIModuleProvider(\n    reactApplicationContext,\n    componentFactory,\n    new EmptyReactNativeConfig(),\n    viewManagerRegistry);\n</code></pre><p>然后我们利用新架构提供的 Codegen，调用 gradlew generateCodegenArtifactsFromSchema 生成代码 Native 代码：</p><pre><code class=\"language-plain\">../gradlew generateCodegenArtifactsFromSchema\n</code></pre><p>最后，运行即可。Android 端的实现就是这样，接下来我们再看下 iOS 端。</p><h3>iOS</h3><p>在iOS端汇总，首先我们要创建一个继承于RCTViewComponentView 的一个类作为视频组件，如下：</p><pre><code class=\"language-plain\">@interface VideoComponentView : RCTViewComponentView\n//声明播放器组件的一些方法\n//播放视频\n- (void)playVideo;\n//停止视频\n- (void)stopVideo;\n//暂停视频\n- (void)pauseVideo;\n@end\n</code></pre><p>之后，该类需要遵循一个协议，协议中需要声明执行Command的方法名，示例代码如下：</p><pre><code class=\"language-plain\">@protocol VideoComponentViewProtocol &lt;NSObject&gt;\n- (void)callNativeMethodToPlayVideo;\n- (void)callNativeMethodToStopyVideo;\n- (void)callNativeMethodToPauseVideo;\n@end\n\nRCT_EXTERN inline void VideoComponentCommand(\n        id&lt;VideoComponentViewProtocol&gt; componentView,\n&nbsp;       NSString const *commandName,\n&nbsp;       NSArray const *args)\n\n    if([commandName isEqualToString:@\"callNativeMethodToPlayVideo\"]){\n        [componentView callNativeMethodToPlayVideo];\n        return;\n    }\n    \n    if(![commandName isEqualToString:@\"callNativeMethodToStopVideo\"]){\n        [componentView callNativeMethodToStopVideo];\n        return;\n    }\n    \n    if(![commandName isEqualToString:@\"callNativeMethodToPauseVideo\"]){\n        [componentView callNativeMethodToPauseVideo];    \n        return;\n    }\n    return;\n)\n</code></pre><p>接下来，ComponentView需要遵循该Protocol协议，并在执行common时调用对应的方法。此外，我们还可以设置组件的属性：</p><pre><code class=\"language-plain\">using namespace facebook::react;\n\n@interface VideoComponentView() &lt;VideoComponentViewProtocol&gt;\n@end\n\n@implementation VideoComponentView{\n  VideoPlayer *_videoPlayer;\n}\n\n#pragma mark - Native Commands\n- (void)handleCommand:(const NSString *)commandName args:(const NSArray *)args{\n&nbsp; VideoComponentCommand(self, commandName, args);\n}\n\n- (void)callNativeMethodToPlayVideo{\n&nbsp; //实现视频播放功能\n  [_videoPlayer startPlay];\n}\n\n- (void)callNativeMethodToStopVideo{\n  //实现视频停止功能\n  [_videoPlayer stopPlay];\n}\n\n- (void)callNativeMethodToPauseVideo{\n  //实现视频暂停功能\n  [_videoPlayer pausePlay];\n}\n\n#pragma mark - Props\n//遵循descriptor协议\n+ (ComponentDescriptorProvider)componentDescriptorProvider{\n&nbsp; return concreteComponentDescriptorProvider&lt;VideoComponentDescriptor&gt;();\n}\n\n- (instancetype)initWithFrame:(CGRect)frame{\n&nbsp; if (self = [super initWithFrame:frame]) {\n&nbsp; &nbsp; static const auto defaultProps = std::make_shared&lt;const ComponentViewProps&gt;();\n&nbsp; &nbsp; _props = defaultProps;\n\n&nbsp; &nbsp; _videoPlayer = [[VideoPlayer alloc] init];\n&nbsp; &nbsp; self.contentView = _videoPlayer;\n&nbsp; }\n&nbsp; return self;\n}\n\n- (void)updateProps:(Props::Shared const &amp;)props oldProps:(Props::Shared const &amp;)oldProps{\n&nbsp; [super updateProps:props oldProps:oldProps];\n}\n\n- (void)onChange:(UIView *)sender{\n&nbsp; // No-op\n&nbsp; //&nbsp; std::dynamic_pointer_cast&lt;const ViewEventEmitter&gt;(_eventEmitter)\n&nbsp; //&nbsp; &nbsp; &nbsp; -&gt;onChange(ViewEventEmitter::OnChange{.value = static_cast&lt;bool&gt;(sender.on)});\n}\n\n@end\n\nClass&lt;RCTComponentViewProtocol&gt; VideoViewCls(void){\n&nbsp; return VideoComponentView.class;\n}\n</code></pre><p>接着，注册属性遵循VideoComponentDescriptor，并且需要指定该组件的名字：</p><pre><code class=\"language-plain\">namespace facebook {\nnamespace react {\nusing VideoComponentDescriptor = ConcreteComponentDescriptor&lt;VideoViewShadowNode&gt;;\n} // namespace react\n} // namespace facebook\n\nnamespace facebook {\nnamespace react {\n    extern const char VideoViewComponentName[];\n    using VideoViewShadowNode = ConcreteViewShadowNode&lt;\n&nbsp; &nbsp;      VideoViewComponentName,//组件名\n&nbsp; &nbsp;      VideoViewProps&gt;;//注册属性\n} // namespace react\n} // namespace facebook\n\nnamespace facebook {\nnamespace react {\nextern const char VideoViewComponentName[] = \"VideoView\";//组件名\n} // namespace react\n} // namespace facebook\n\nnamespace facebook {\nnamespace react {\n//属性定义\nclass VideoViewProps final : public ViewProps {\n&nbsp;public:\n&nbsp; VideoViewProps() = default;\n&nbsp; VideoViewProps(const PropsParserContext&amp; context, const VideoViewProps &amp;sourceProps, const RawProps &amp;rawProps);\n\n  #pragma mark - Props\n  std::string url{\"\"};//视频url\n};\n} // namespace react\n} // namespace facebook\n\n</code></pre><p>这样，我们就创建好了一个 React Native 的 Fabric 组件、定义属性以及 API 的方法。<br>\n以上便是如何使用 Fabric 自定义视频播放组件，在混合工程中搭建好新架构的运行环境后，只需要遵守 Fabric 的组件定义方式，进行接口定义、功能实现和组件注册即可。关于一些复杂的 Fabric 组件，可以查看 <a href=\"https://github.com/software-mansion/react-native-gesture-handler/tree/main/FabricExample\">https://github.com/software-mansion/react-native-gesture-handler/tree/main/FabricExample</a>，<a href=\"https://github.com/software-mansion/react-native-reanimated/tree/main/FabricExample\">https://github.com/software-mansion/react-native-reanimated/tree/main/FabricExample</a>，目前 react-native-gesture-handler、react-native-reanimated 都已经适配了新架构，感兴趣的同学可以去学习下。</p><h2>总结</h2><p>这一讲，我们系统讲解了个性化组件的使用场景、生命周期、传输类型，以及通信方式，并通过两个实际案例讲解了如何在新架构下定制个性化的 TurboModules 与 Fabric。而且，我们也简单介绍了一下React Native新架构，你可以通过官方文档进行新架构的体验。</p><p>这一讲是我们 Native 相关的三讲中花的时间最长的，也是最“伤肝”的，我们前前后后加调研花了两个月的时间。但我们相信，新架构在未来会有很好的发展，这是可以预见的。因为它解决了 React Native 几个最痛的点，包括启动速度、运行时性能等。如果新架构还能在易用性上继续优化，将会大大拓展 React Native 的用户群体。</p><p>因为目前新架构还处于未发布的状态，网上相关的文章大都是对官方纯 React Native 模式 Demo 和介绍，少数几篇会深挖原理，但讲混合模式的新架构运行文章几乎没有。我们这一讲中对 TurboModule 和 Fabric 的讲解，更侧重于如何在混合工程中开启并运行。如果有对 TurboModule、Fabric、JSI 的原理感兴趣的同学，后面有机会我们再来分享。</p><h2>作业</h2><ol>\n<li>设计一个打印 Native 日志的 TurboModule，以及一个 Native 加载进度条的 Fabric 组件。</li>\n</ol><p>欢迎在评论区写下你的想法和经验，和我们多多交流。我们下一讲见。</p>","neighbors":{"left":{"article_title":"21｜混合应用：如何从零开始集成React Native？","id":518965},"right":{"article_title":"23｜热更新：如何搭建一个热更新平台？","id":520647}},"comments":[{"had_liked":false,"id":377757,"user_name":"陈彦祖","can_delete":false,"product_type":"c1","uid":1591721,"ip_address":"北京","ucode":"75D5ED5BB67B4E","user_header":"https://static001.geekbang.org/account/avatar/00/18/49/a9/225c041f.jpg","comment_is_top":false,"comment_ctime":1689152780,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100110101,"comment_content":"WritableMap resultMap = new WritableNativeMap(); 下面两行有问题\n这行底下的代码有问题，变量名错了，应该是 resultMap.putInt(&quot;code&quot;, 1) 而不是 map\n","like_count":0},{"had_liked":false,"id":347007,"user_name":"Geek_ce9101","can_delete":false,"product_type":"c1","uid":1274174,"ip_address":"","ucode":"818FB7272EA27B","user_header":"","comment_is_top":false,"comment_ctime":1653614600,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100110101,"comment_content":"最近有个项目，想直接上rn，但怕未来搞不定，搜了很多，没发现有什么是原声可以而rn不可以的，除了一些动画性能之类的","like_count":0,"discussions":[{"author":{"id":2893420,"avatar":"","nickname":"程序员讲道理","note":"","ucode":"9C6F0DB859CE37","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583682,"discussion_content":"RN 从来不是为了扩展原生的能力，主要是要让原生开发更快","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660290051,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}