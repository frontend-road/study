{"id":165114,"title":"09 | 理论六：为什么基于接口而非实现编程？有必要为每个类都定义接口吗？","content":"<p>在上一节课中，我们讲了接口和抽象类，以及各种编程语言是如何支持、实现这两个语法概念的。今天，我们继续讲一个跟“接口”相关的知识点：基于接口而非实现编程。这个原则非常重要，是一种非常有效的提高代码质量的手段，在平时的开发中特别经常被用到。</p><p>为了让你理解透彻，并真正掌握这条原则如何应用，今天，我会结合一个有关图片存储的实战案例来讲解。除此之外，这条原则还很容易被过度应用，比如为每一个实现类都定义对应的接口。针对这类问题，在今天的讲解中，我也会告诉你如何来做权衡，怎样恰到好处地应用这条原则。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>如何解读原则中的“接口”二字？</h2><p>“基于接口而非实现编程”这条原则的英文描述是：“Program to an interface, not an implementation”。我们理解这条原则的时候，千万不要一开始就与具体的编程语言挂钩，局限在编程语言的“接口”语法中（比如Java中的interface接口语法）。这条原则最早出现于1994年GoF的《设计模式》这本书，它先于很多编程语言而诞生（比如Java语言），是一条比较抽象、泛化的设计思想。</p><p>实际上，理解这条原则的关键，就是理解其中的“接口”两个字。还记得我们上一节课讲的“接口”的定义吗？从本质上来看，“接口”就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”。“接口”在不同的应用场景下会有不同的解读，比如服务端与客户端之间的“接口”，类库提供的“接口”，甚至是一组通信的协议都可以叫作“接口”。刚刚对“接口”的理解，都比较偏上层、偏抽象，与实际的写代码离得有点远。如果落实到具体的编码，“基于接口而非实现编程”这条原则中的“接口”，可以理解为编程语言中的接口或者抽象类。</p><!-- [[[read_end]]] --><p>前面我们提到，这条原则能非常有效地提高代码质量，之所以这么说，那是因为，应用这条原则，可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。</p><p>实际上，“基于接口而非实现编程”这条原则的另一个表述方式，是“基于抽象而非实现编程”。后者的表述方式其实更能体现这条原则的设计初衷。在软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准。<strong>越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。</strong>而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。</p><h2>如何将这条原则应用到实战中？</h2><p>对于这条原则，我们结合一个具体的实战案例来进一步讲解一下。</p><p>假设我们的系统中有很多涉及图片处理和存储的业务逻辑。图片经过处理之后被上传到阿里云上。为了代码复用，我们封装了图片存储相关的代码逻辑，提供了一个统一的AliyunImageStore类，供整个系统来使用。具体的代码实现如下所示：</p><pre><code>public class AliyunImageStore {\n  //...省略属性、构造函数等...\n  \n  public void createBucketIfNotExisting(String bucketName) {\n    // ...创建bucket代码逻辑...\n    // ...失败会抛出异常..\n  }\n  \n  public String generateAccessToken() {\n    // ...根据accesskey/secrectkey等生成access token\n  }\n  \n  public String uploadToAliyun(Image image, String bucketName, String accessToken) {\n    //...上传图片到阿里云...\n    //...返回图片存储在阿里云上的地址(url）...\n  }\n  \n  public Image downloadFromAliyun(String url, String accessToken) {\n    //...从阿里云下载图片...\n  }\n}\n\n// AliyunImageStore类的使用举例\npublic class ImageProcessingJob {\n  private static final String BUCKET_NAME = &quot;ai_images_bucket&quot;;\n  //...省略其他无关代码...\n  \n  public void process() {\n    Image image = ...; //处理图片，并封装为Image对象\n    AliyunImageStore imageStore = new AliyunImageStore(/*省略参数*/);\n    imageStore.createBucketIfNotExisting(BUCKET_NAME);\n    String accessToken = imageStore.generateAccessToken();\n    imagestore.uploadToAliyun(image, BUCKET_NAME, accessToken);\n  }\n  \n}\n</code></pre><p>整个上传流程包含三个步骤：创建bucket（你可以简单理解为存储目录）、生成access token访问凭证、携带access token上传图片到指定的bucket中。代码实现非常简单，类中的几个方法定义得都很干净，用起来也很清晰，乍看起来没有太大问题，完全能满足我们将图片存储在阿里云的业务需求。</p><p>不过，软件开发中唯一不变的就是变化。过了一段时间后，我们自建了私有云，不再将图片存储到阿里云了，而是将图片存储到自建私有云上。为了满足这样一个需求的变化，我们该如何修改代码呢？</p><p>我们需要重新设计实现一个存储图片到私有云的PrivateImageStore类，并用它替换掉项目中所有的AliyunImageStore类对象。这样的修改听起来并不复杂，只是简单替换而已，对整个代码的改动并不大。不过，我们经常说，“细节是魔鬼”。这句话在软件开发中特别适用。实际上，刚刚的设计实现方式，就隐藏了很多容易出问题的“魔鬼细节”，我们一块来看看都有哪些。</p><p>新的PrivateImageStore类需要设计实现哪些方法，才能在尽量最小化代码修改的情况下，替换掉AliyunImageStore类呢？这就要求我们必须将AliyunImageStore类中所定义的所有public方法，在PrivateImageStore类中都逐一定义并重新实现一遍。而这样做就会存在一些问题，我总结了下面两点。</p><p>首先，AliyunImageStore类中有些函数命名暴露了实现细节，比如，uploadToAliyun()和downloadFromAliyun()。如果开发这个功能的同事没有接口意识、抽象思维，那这种暴露实现细节的命名方式就不足为奇了，毕竟最初我们只考虑将图片存储在阿里云上。而我们把这种包含“aliyun”字眼的方法，照抄到PrivateImageStore类中，显然是不合适的。如果我们在新类中重新命名uploadToAliyun()、downloadFromAliyun()这些方法，那就意味着，我们要修改项目中所有使用到这两个方法的代码，代码修改量可能就会很大。</p><p>其次，将图片存储到阿里云的流程，跟存储到私有云的流程，可能并不是完全一致的。比如，阿里云的图片上传和下载的过程中，需要生产access token，而私有云不需要access token。一方面，AliyunImageStore中定义的generateAccessToken()方法不能照抄到PrivateImageStore中；另一方面，我们在使用AliyunImageStore上传、下载图片的时候，代码中用到了generateAccessToken()方法，如果要改为私有云的上传下载流程，这些代码都需要做调整。</p><p>那这两个问题该如何解决呢？解决这个问题的根本方法就是，在编写代码的时候，要遵从“基于接口而非实现编程”的原则，具体来讲，我们需要做到下面这3点。</p><ol>\n<li>函数的命名不能暴露任何实现细节。比如，前面提到的uploadToAliyun()就不符合要求，应该改为去掉aliyun这样的字眼，改为更加抽象的命名方式，比如：upload()。</li>\n<li>封装具体的实现细节。比如，跟阿里云相关的特殊上传（或下载）流程不应该暴露给调用者。我们对上传（或下载）流程进行封装，对外提供一个包裹所有上传（或下载）细节的方法，给调用者使用。</li>\n<li>为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议。使用者依赖接口，而不是具体的实现类来编程。</li>\n</ol><p>我们按照这个思路，把代码重构一下。重构后的代码如下所示：</p><pre><code>public interface ImageStore {\n  String upload(Image image, String bucketName);\n  Image download(String url);\n}\n\npublic class AliyunImageStore implements ImageStore {\n  //...省略属性、构造函数等...\n\n  public String upload(Image image, String bucketName) {\n    createBucketIfNotExisting(bucketName);\n    String accessToken = generateAccessToken();\n    //...上传图片到阿里云...\n    //...返回图片在阿里云上的地址(url)...\n  }\n\n  public Image download(String url) {\n    String accessToken = generateAccessToken();\n    //...从阿里云下载图片...\n  }\n\n  private void createBucketIfNotExisting(String bucketName) {\n    // ...创建bucket...\n    // ...失败会抛出异常..\n  }\n\n  private String generateAccessToken() {\n    // ...根据accesskey/secrectkey等生成access token\n  }\n}\n\n// 上传下载流程改变：私有云不需要支持access token\npublic class PrivateImageStore implements ImageStore  {\n  public String upload(Image image, String bucketName) {\n    createBucketIfNotExisting(bucketName);\n    //...上传图片到私有云...\n    //...返回图片的url...\n  }\n\n  public Image download(String url) {\n    //...从私有云下载图片...\n  }\n\n  private void createBucketIfNotExisting(String bucketName) {\n    // ...创建bucket...\n    // ...失败会抛出异常..\n  }\n}\n\n// ImageStore的使用举例\npublic class ImageProcessingJob {\n  private static final String BUCKET_NAME = &quot;ai_images_bucket&quot;;\n  //...省略其他无关代码...\n  \n  public void process() {\n    Image image = ...;//处理图片，并封装为Image对象\n    ImageStore imageStore = new PrivateImageStore(...);\n    imagestore.upload(image, BUCKET_NAME);\n  }\n}\n</code></pre><p>除此之外，很多人在定义接口的时候，希望通过实现类来反推接口的定义。先把实现类写好，然后看实现类中有哪些方法，照抄到接口定义中。如果按照这种思考方式，就有可能导致接口定义不够抽象，依赖具体的实现。这样的接口设计就没有意义了。不过，如果你觉得这种思考方式更加顺畅，那也没问题，只是将实现类的方法搬移到接口定义中的时候，要有选择性的搬移，不要将跟具体实现相关的方法搬移到接口中，比如AliyunImageStore中的generateAccessToken()方法。</p><p>总结一下，我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。在定义接口的时候，不要暴露任何实现细节。接口的定义只表明做什么，而不是怎么做。而且，在设计接口的时候，我们要多思考一下，这样的接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候，不需要任何接口定义的改动。</p><h2>是否需要为每个类定义接口？</h2><p>看了刚刚的讲解，你可能会有这样的疑问：为了满足这条原则，我是不是需要给每个实现类都定义对应的接口呢？在开发的时候，是不是任何代码都要只依赖接口，完全不依赖实现编程呢？</p><p>做任何事情都要讲求一个“度”，过度使用这条原则，非得给每个类都定义接口，接口满天飞，也会导致不必要的开发负担。至于什么时候，该为某个类定义接口，实现基于接口的编程，什么时候不需要定义接口，直接使用实现类编程，我们做权衡的根本依据，还是要回归到设计原则诞生的初衷上来。只要搞清楚了这条原则是为了解决什么样的问题而产生的，你就会发现，很多之前模棱两可的问题，都会变得豁然开朗。</p><p>前面我们也提到，这条原则的设计初衷是，将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低代码间的耦合性，提高代码的扩展性。</p><p>从这个设计初衷上来看，如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了。</p><p>除此之外，越是不稳定的系统，我们越是要在代码的扩展性、维护性上下功夫。相反，如果某个系统特别稳定，在开发完之后，基本上不需要做维护，那我们就没有必要为其扩展性，投入不必要的开发时间。</p><h2>重点回顾</h2><p>今天的内容到此就讲完了。我们来一块总结回顾一下，你需要掌握的重点内容。</p><p>1.“基于接口而非实现编程”，这条原则的另一个表述方式，是“基于抽象而非实现编程”。后者的表述方式其实更能体现这条原则的设计初衷。我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性、扩展性、可维护性。</p><p>2.我们在定义接口的时候，一方面，命名要足够通用，不能包含跟具体实现相关的字眼；另一方面，与特定实现有关的方法不要定义在接口中。</p><p>3.“基于接口而非实现编程”这条原则，不仅仅可以指导非常细节的编程开发，还能指导更加上层的架构设计、系统设计等。比如，服务端与客户端之间的“接口”设计、类库的“接口”设计。</p><h2>课堂讨论</h2><p>在今天举的代码例子中，尽管我们通过接口来隔离了两个具体的实现。但是，在项目中很多地方，我们都是通过下面第8行的方式来使用接口的。这就会产生一个问题，那就是，如果我们要替换图片存储方式，还是需要修改很多类似第8行那样的代码。这样的设计还是不够完美，对此，你有更好的实现思路吗？</p><pre><code>// ImageStore的使用举例\npublic class ImageProcessingJob {\n  private static final String BUCKET_NAME = &quot;ai_images_bucket&quot;;\n  //...省略其他无关代码...\n  \n  public void process() {\n    Image image = ...;//处理图片，并封装为Image对象\n    ImageStore imageStore = new PrivateImageStore(/*省略构造函数*/);\n    imagestore.upload(image, BUCKET_NAME);\n  }\n</code></pre><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>","neighbors":{"left":{"article_title":"08 | 理论五：接口vs抽象类的区别？如何用普通的类模拟抽象类和接口？","id":165103},"right":{"article_title":"10 | 理论七：为何说要多用组合少用继承？如何决定该用组合还是继承？","id":169593}},"comments":[{"had_liked":false,"id":154400,"user_name":"zeta","can_delete":false,"product_type":"c1","uid":1255260,"ip_address":"","ucode":"AF84A72375827C","user_header":"https://static001.geekbang.org/account/avatar/00/13/27/5c/ee2a876f.jpg","comment_is_top":false,"comment_ctime":1574423004,"is_pvip":false,"discussion_count":62,"race_medal":0,"score":"2565669898716","product_id":100039001,"comment_content":"其实这篇和上一篇可以讲的更好的。首先，我反对接口是has-a的说法，我坚持接口的语义是behaves like(这个其实我也是在某一本书上看的). 咱们看下哪个更通顺和达意，A AliyunImageStorage has a DataStorage. or A AliyunImageStorage behaves like a DataStorage? 除非你在第一句加上 A AliyunImageStorage has some behaviors of DataStorage. 但这基本也就是behaves like的意思了。<br>第二，我觉得咬文嚼字的确没有什么意义，但为什么说上述话题，难道讲接口的例子不用出现接口多重继承么，引用我之前留言：拿一个C++中举的多重继承例子来说，吸血鬼分别继承自蝙蝠和人，那么吸血鬼is a蝙蝠么？吸血鬼is a人么？所以其实两个都不是，这就是设计上的语义问题。这里缺失了除了is a的另一个概念，behaves like，也就是多重继承的真义实际上是behaves like，也就是接口的意义。A vampire behaves like humans and bats. 而这是接口能多重的原因，一个类可以具有多重行为，但是不能是多种东西。<br>所以其实也就是说，只有当前模块涉及到抽象行为的时候，才有必要设计接口，才有可能利用接口多重继承的特性来更好的将各种行为分组。","like_count":597,"discussions":[{"author":{"id":1064449,"avatar":"https://static001.geekbang.org/account/avatar/00/10/3e/01/9bb11f13.jpg","nickname":"whyoyyx","note":"","ucode":"B111DDAF23AFE9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294691,"discussion_content":"引用文中的一段话，从本质上来看，“接口”就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”。\n\n\n如果这里你把has a理解成拥有什么能力或者具备什么行为这类的含义可能更符合些。例如：AliyunImageStorage具备数据存储的能力。如果用behave like不知道咋描述，是行为像存储？\n\n所以我觉得用has a可能更贴切一点。只是这里的has a容易让人类比组合里面的那个has a。但是细想想这两者想表达的意思是一样的。","likes_number":30,"is_delete":false,"is_hidden":false,"ctime":1595957052,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2465343,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKW6K5tAWnia6qO25hWEhHTpAhO6H6FHS2Bkg99DhZCaLm8opibQ8ZZNBzduCX5zl4F1PUnJcmEctEw/132","nickname":"Geek_383d72","note":"","ucode":"4AE2CFEB56237A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365038,"discussion_content":"抽象类在被继承时体现的是 is-a 关系，接口在被实现时体现的是 can-do 关系\n例如，Plane can fly. Bird can fly，应该把 fly 定义成一个接口。\n\n-- 参考 《码出自效Java 开发手册》","likes_number":22,"is_delete":false,"is_hidden":false,"ctime":1617691535,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1193784,"avatar":"https://static001.geekbang.org/account/avatar/00/12/37/38/5a3b72d4.jpg","nickname":"聂旋","note":"","ucode":"40061E5AFDA99C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2465343,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKW6K5tAWnia6qO25hWEhHTpAhO6H6FHS2Bkg99DhZCaLm8opibQ8ZZNBzduCX5zl4F1PUnJcmEctEw/132","nickname":"Geek_383d72","note":"","ucode":"4AE2CFEB56237A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569819,"discussion_content":"从接口角度来说，接口实现类体现的是，must can do and don&#39;t care how to do","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1651564304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":365038,"ip_address":""},"score":569819,"extra":""}]},{"author":{"id":2555948,"avatar":"","nickname":"Geek_b76b97","note":"","ucode":"5968DEF6D0018B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374733,"discussion_content":"has-a的意思就是拥有什么功能，跟你这个behaves like其实也差不多，表达都是一个意思，懂得是哪个意思就行","likes_number":14,"is_delete":false,"is_hidden":false,"ctime":1621330811,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1303954,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/1mOvT5fApeicXppMP3zADG6XIPicNt5D9dL6y46SF5UUcH0hicG21LM6xSgHJj5oAdzCyeGtLZYHYmlvaFwecrGOA/132","nickname":"考拉出山","note":"","ucode":"917E35FD7B2D06","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":274136,"discussion_content":"个人觉得这个很难概括全面，一定要描述的话。我的理解是抽象本身就是可以分类的。有的是对身份抽象，有的是对行为抽象。比如我们设计duck的时候，可以将鸭子叫这种能力变为接口，所有鸭子都具有speak叫的能力。这个时候代表所有鸭子has这种能力。但是如果我们把duck定义为抽象，里面声明一个speak方法。那么duck代表一类身份。同理同时继承蝙蝠和人。在代码层面他们的身份就是蝙蝠或者人，只不过从语义上理解应该是具有人和蝙蝠的能力。只能说这样的设计不合理？？ 强行去解释一个不好的设计本身就失去意义(语言不能约束一个人不能去继承一个duck的接口)。但这真的是不良设计？  能用就好，而且很多抽象都是空的，不带任何抽象方法，仅代表身份。约定大于规则\n","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1590545183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1245040,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ff/70/4a6f9065.jpg","nickname":"happyfucheng","note":"","ucode":"458E67028A5368","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393465,"discussion_content":"我觉得不必死抠这些说法，自己理解就行。比如java有很多接口，closeable,cloneable,serializable。一个类如果实现了这些接口，这时候我觉得has-a。表示它拥有这些方法，实现了这些协议，更合适吧。behaves like,看起来像。感觉不太合适。。。。。\n具体来说我觉得上节课老师总结的比较好。对java来说，抽象类主要是解决代码复用的问题，是一种自下而上的设计方法。接口是自上而下的设计方法，主要是为了解决解耦抽象的问题","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1631442790,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1303330,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e3/22/972dacba.jpg","nickname":"大白","note":"","ucode":"34B8D3BA215553","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60371,"discussion_content":"java只支持单继承，多接口。is a 和 has a 是抽象层面的表达。具化的话就是 has some behaviors。 吸血鬼既不是人，也不是蝙蝠。他是新物种，只是具备人和蝙蝠的某些行为。关系当然是has a。 你的抽象能力还不到火候，现在流行的 DDD开发就是根据具象化表达来实现代码。它只是对业务层面（领域，界限）解耦合。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1574729489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":8,"child_discussions":[{"author":{"id":1255260,"avatar":"https://static001.geekbang.org/account/avatar/00/13/27/5c/ee2a876f.jpg","nickname":"zeta","note":"","ucode":"AF84A72375827C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1303330,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e3/22/972dacba.jpg","nickname":"大白","note":"","ucode":"34B8D3BA215553","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60410,"discussion_content":"算了，不多说了。我发这个也不是为了说明咱们谁到没到火候的。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1574730863,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":60371,"ip_address":""},"score":60410,"extra":""},{"author":{"id":1440349,"avatar":"https://static001.geekbang.org/account/avatar/00/15/fa/5d/735fdc76.jpg","nickname":"╭(╯ε╰)╮","note":"","ucode":"4CB5FAEEE8CC5D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1303330,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e3/22/972dacba.jpg","nickname":"大白","note":"","ucode":"34B8D3BA215553","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":61522,"discussion_content":"只是具备人和蝙蝠的行为 我不人为是 has a 应该是 can do\n\n吸血鬼has a超能力\n吸血鬼can吸血\n吸血鬼can睡觉\n吸血鬼has a生前的容貌\n吸血鬼can说人话\n\n看下来 具备人和蝙蝠的某种行为 跟has a并没有关系 当然&#34;不是&#34;has a","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574780395,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":60371,"ip_address":""},"score":61522,"extra":""},{"author":{"id":1440349,"avatar":"https://static001.geekbang.org/account/avatar/00/15/fa/5d/735fdc76.jpg","nickname":"╭(╯ε╰)╮","note":"","ucode":"4CB5FAEEE8CC5D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1303330,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e3/22/972dacba.jpg","nickname":"大白","note":"","ucode":"34B8D3BA215553","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":61552,"discussion_content":"个人感觉 业务是千变万化的 书本上只提了&#34;has a&#34; &#34;is a&#34;并不代表所有的业务都往上套。这样思维会被束缚。经典的比喻:用惯了锤子，眼里一切都是钉子。曾经的我 不同阶段 对这段话的理解完全不同。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574780779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":60371,"ip_address":""},"score":61552,"extra":""}]},{"author":{"id":1371888,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ee/f0/f2577e45.jpg","nickname":"额。","note":"","ucode":"99B1942BAEC011","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370960,"discussion_content":"兄弟，我来晚了，是《敏捷软件开发》里面说的10.3.3 is-a是关于行为的。举了一个很好的例子就是，正方形到底要不要继承自矩形。\n书上还提到了一句话：术语Is-a的含义过于宽泛以至于不能作为子类型的定义。子类型的正确定义是&#34;可替换性的&#34;，这里的可替换性可以通过显示或者隐式的契约来定义","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1619594074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1337598,"avatar":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","nickname":"岁月","note":"","ucode":"29A2A2BC3C4FE4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":82906,"discussion_content":"其实这些说法都是对的，吸血鬼继承自蝙蝠或者实现了蝙蝠接口，从蝙蝠的角度来说，吸血鬼就是蝙蝠，别忘了蝙蝠有眼睛没视力啊，他们对同类的识别可不就是通过某种特性嘛，呵呵。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1576398838,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1109632,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ee/80/db52af6b.jpg","nickname":"Justin","note":"","ucode":"E6C4119C752465","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1337598,"avatar":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","nickname":"岁月","note":"","ucode":"29A2A2BC3C4FE4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292369,"discussion_content":"对抽象的理解，要看角度","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595207301,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":82906,"ip_address":""},"score":292369,"extra":""}]},{"author":{"id":2278659,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/TUMtkaIMdbFDS28AhjrQcqOhiapNvHyPMApz9QoZZkShZmomJRh6GX2aL2YeSMg4SicdydzdWxXZOZz49HNS9EtA/132","nickname":"Windqiu","note":"","ucode":"EF78D3CF73BCBB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360937,"discussion_content":"其实我一直对接口和抽象有迷迷糊糊的概念认知。\n不过通过各种课程，以及代码的观察。\n抽象类，之所以需要抽象，是从类出发的，如果此行为是属于类中必须有的，且具有共性的行为，那么成为抽象类的抽象方法，可以替代成复用。\n如果此行为只是类中的延展行为，可有可没有，非必须，但是针对此行为是有共性的，可以抽象成为接口，用接口的方式去实现。当然如果针对此类是延展行为，但是又非共性，则直接在抽象类实现行为，或者抽象成为抽象方法，让子类实现。\n这是从这一楼的答主上参悟的，具体是否如此，还需要在项目实战中进行深入理解。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1616561407,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1252396,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1c/2c/bb123f90.jpg","nickname":"Neexz","note":"","ucode":"BF68EFB92949B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":194946,"discussion_content":"Has the ability of an interface","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1583246365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1337598,"avatar":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","nickname":"岁月","note":"","ucode":"29A2A2BC3C4FE4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":82904,"discussion_content":"接口就是用来描述具有哪些行为。还是很容易理解的。经典翻译就是 &#34;鸭式辨型&#34;，像鸭子一样会嘎嘎叫的，虽然可能是个人，但是从类型的角度理解完全是可以认为人就是鸭子，因为鸭子眼里会嘎嘎叫的都是同类嘛。。。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1576398658,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1016799,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/hg9Tsg2iaBeG6Q5mxiczjw1ph0OvhKziblEIiaOxg4gwQ0Dgia7Fw7pDQ0mM8AL5SJAm2Yavk1RmBJrFd9jKPBQRkOw/132","nickname":"小毅","note":"","ucode":"5651C740D68038","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77287,"discussion_content":"behaves like的确从概念上更加贴合表达拥有某种能力～ 但是如果把has a的宾语换成接口中某一个方法是不是就可以说得通，我个人觉得具体的能力还看接口中最小粒度的方法，这是具体的能力和行为，接口只是对这组能力的抽象和封装～ 以上纯属我看了评论后的感受，仅仅提供另一种角度～\n\n另外请问zeta兄弟behaves like这个观点是从什么书看到？\n","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1575899254,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1255260,"avatar":"https://static001.geekbang.org/account/avatar/00/13/27/5c/ee2a876f.jpg","nickname":"zeta","note":"","ucode":"AF84A72375827C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1016799,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/hg9Tsg2iaBeG6Q5mxiczjw1ph0OvhKziblEIiaOxg4gwQ0Dgia7Fw7pDQ0mM8AL5SJAm2Yavk1RmBJrFd9jKPBQRkOw/132","nickname":"小毅","note":"","ucode":"5651C740D68038","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77419,"discussion_content":"具体什么书忘记了，大概十年前看的书了，也不是什么有名的书。\n我明白你的意思，但是方法命名都应该是动词，所以在has a 的语境里，无论是动词或动名词做宾语都不太合适。你感受下，has a fly? has a flying? 最终还是会回到has some specific behaviors, 也就是 behaves like.\n之所以斟酌这些文字是因为符合语义的通顺可以帮助更好的设计","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1575902811,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":77287,"ip_address":""},"score":77419,"extra":""},{"author":{"id":1001702,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/e6/36e0a735.jpg","nickname":"pino","note":"","ucode":"B2434724A51E7A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1016799,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/hg9Tsg2iaBeG6Q5mxiczjw1ph0OvhKziblEIiaOxg4gwQ0Dgia7Fw7pDQ0mM8AL5SJAm2Yavk1RmBJrFd9jKPBQRkOw/132","nickname":"小毅","note":"","ucode":"5651C740D68038","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":97280,"discussion_content":"冒号课堂这本书里有这种说法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577109664,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":77287,"ip_address":""},"score":97280,"extra":""}]},{"author":{"id":1440349,"avatar":"https://static001.geekbang.org/account/avatar/00/15/fa/5d/735fdc76.jpg","nickname":"╭(╯ε╰)╮","note":"","ucode":"4CB5FAEEE8CC5D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":61712,"discussion_content":"课程讲到这里 我个人感觉 大家没有注意到一个隐藏在背后的小鬼 那就是&#34;数据&#34;\n\n程序中很多时候继承是为了获得父类中的数据\n比如 我在项目中思考的\n管理员和普通用户会继承一个用户类，其中包括用户的通用数据比如用户名和头像。管理员会有一些额外的数据比如可管理的模块列表，普通用户会有访问历史等。\n业务中当然会有一些相关的操作对应到方法上，但我的项目中更关心这些数据，有时甚至需要只有数据没有方法。这种情况用接口简直是驴唇不对马嘴。我需要的是多重继承在子类用访问多个父类继承过来的数据。这也是getter和setter泛滥成灾的一个隐性原因。因为我没办法集成到我需要的数据，所以我不得不变相的使用setter getter把数据强行解释为行为！\n\n另外 我一直记在心里的\n面向对象的封装 有一层含义 是将数据和这些数据之上的操作封装封装到一起","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1574782682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1255260,"avatar":"https://static001.geekbang.org/account/avatar/00/13/27/5c/ee2a876f.jpg","nickname":"zeta","note":"","ucode":"AF84A72375827C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1440349,"avatar":"https://static001.geekbang.org/account/avatar/00/15/fa/5d/735fdc76.jpg","nickname":"╭(╯ε╰)╮","note":"","ucode":"4CB5FAEEE8CC5D","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":61996,"discussion_content":"写的这么多挺不容易的，回你一下。你从项目实用角度比较关注数据，但其实关于面相对象中数据层面的抽象基本上是有结论了，那就是可以用组合解决，参考下一章。面相对象理念一路发展下来，我了解的广泛使用的语言里，从最初c++支持多重继承，到java和c#只支持单继承，到现在rust和go连继承都没有了，其中rust在官方教程里明确说明rust采用组合代替继承。所以说至少语言设计者对继承这件事的态度还是比较明显的。\n然后关于你说的“不得不变相的使用setter getter把数据强行解释为行为”，set和get数据本来就是行为呀，当然这个各人理解不同，我就不多说了。而且java方面主流编译器也支持生成getter和setter代码，所以开发上的困扰也不会太多。\n最后我想说的是还是要尽量理解语言设计者的初衷和推荐的最佳实践，不然实际应用中可能导致一些不必要的困扰。","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1574812141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":61712,"ip_address":""},"score":61996,"extra":""}]},{"author":{"id":1999235,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/81/83/f93b1e62.jpg","nickname":"peaceForce","note":"","ucode":"98A318930DDC9A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374933,"discussion_content":"我喜欢这种说法","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1621415427,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1695455,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqUMEsVYklTc7akT2e6pfytu4jTQ88EVe1H6L2eHdXC6G8sbKCvfrnSDUIRq229M2Wt419LX2q8SQ/132","nickname":"时光流逝x","note":"","ucode":"D7334E717D9ED0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369296,"discussion_content":"我的理解是接口只是一个协议,来描述我能提供一种什么样的服务,所以接口只关注的是能不能,抽象类则是我除了能做原来的事情还能对外提供一些额外的服务,所以接口可以根据类的功能选择去实现而抽象类则是去拓展这么理解是否对呢","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1618998387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2063037,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","nickname":"西电","note":"","ucode":"95BD4CE9D93018","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291488,"discussion_content":"组合是has-a应该没有争议吧o(〃&#39;▽&#39;〃)o","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1594835926,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1455958,"avatar":"https://static001.geekbang.org/account/avatar/00/16/37/56/11068390.jpg","nickname":"倡印","note":"","ucode":"4F53AA5D017D89","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2063037,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","nickname":"西电","note":"","ucode":"95BD4CE9D93018","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292704,"discussion_content":"这个听起来很有道理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595311597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":291488,"ip_address":""},"score":292704,"extra":""}]},{"author":{"id":1127383,"avatar":"https://static001.geekbang.org/account/avatar/00/11/33/d7/4c443d3e.jpg","nickname":"不可描述","note":"","ucode":"3BEF775A9C6797","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335452,"discussion_content":"菱形继承问题 本来就是个有问题得设计","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1608197196,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1740322,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/8e/22/51f690e1.jpg","nickname":"big熊","note":"","ucode":"8D382BF137EF00","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326887,"discussion_content":"is a在java单继承里理解的话没有问题，不用死扣细节多继承时is a对不对，自己理解就行","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605694100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1389314,"avatar":"https://static001.geekbang.org/account/avatar/00/15/33/02/83f47bf9.jpg","nickname":"流沙","note":"","ucode":"6153686D1C34B7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324696,"discussion_content":"本来明白了，看了你们的解答，我又迷惑了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605154785,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1465986,"avatar":"https://static001.geekbang.org/account/avatar/00/16/5e/82/438c8534.jpg","nickname":"longslee","note":"","ucode":"C24E32E5B1B6F5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":265625,"discussion_content":"英语不错","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589421797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1136181,"avatar":"https://static001.geekbang.org/account/avatar/00/11/56/35/eeee9309.jpg","nickname":"sun","note":"","ucode":"948FD34662AFB0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62449,"discussion_content":"大佬，说的太有道理了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574843893,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1173517,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e8/0d/fcd95db8.jpg","nickname":"Lifelong Learning","note":"","ucode":"3E39BED3E13FB4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56313,"discussion_content":"人们总说c++多继承很困扰,带来了许多麻烦,但是如果正确使用的化或者正确理解设计者的初衷的话可能会减少这种麻烦,首先c++的多继承多用于类似java中接口的实现,而java中的继承和抽象完全可以用c++的“单继承”,这样使用C++多继承上也就没有那么多麻烦存在了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574472767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1811277,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a3/4d/59390ba9.jpg","nickname":"排骨","note":"","ucode":"A413CF46211E1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589566,"discussion_content":"我也赞成评论区大部分老哥的理解，其实has-a和behaves like等其他描述都是差不多的，理解上本质意思都差不多，主要表现为实现接口的类就得提供对应的功能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665130065,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"中国香港"},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1924882,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/aXnFBB3XD3lwB3jf1A0PQqT66aJy4yycbRupJI3ia2CUFMuLsvYthM41TDopIIjL8kz7k2xE5vrAtQggQ6Jt8Zw/132","nickname":"付磊","note":"","ucode":"719BD0B72FF2AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580570,"discussion_content":"文章中的理解更加容易让新手理解。懂那个意思就好了。简单才是真理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658275329,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2172520,"avatar":"https://static001.geekbang.org/account/avatar/00/21/26/68/b86dc4df.jpg","nickname":"R","note":"","ucode":"3721FC8C8DE174","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577528,"discussion_content":"我认为接口是一组行为的抽象。比如王者荣耀所有英雄都有闪现、加血、回城，这一组行为就可以定义为接口。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656165676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2849207,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/p7WrTfywicxkRZTdlSEvzTsrWssRF0YnmGY2ffFYGKjIoNC8fnbMiaI9Kic0gOD3icLiapY5vmYh89yLUH7qgZZicn3g/132","nickname":"Geek_8b8904","note":"","ucode":"3A7967582FFE8D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561933,"discussion_content":"我用的java，感觉用到接口的时候是用接口的方法，关注点在让类做什么，而如果用的是父类子类一般还会要他的属性，比如获取一个继承student的类一般会关注他的名字，但是获取一个实现CanSing的类其实只是想让他sing（），并不关心他是什么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649749821,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2838429,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/4f/9d/f9157b76.jpg","nickname":"🌝李洞宾","note":"","ucode":"B06F74C2FCD742","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":414259,"discussion_content":"好理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636703818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2757751,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/14/77/ebbbca83.jpg","nickname":"Hl","note":"","ucode":"2717A5845ED6BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393059,"discussion_content":"确实","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631237952,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1030657,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ba/01/5ce8ce0b.jpg","nickname":"Leoorz","note":"","ucode":"8912628AD6ADE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391923,"discussion_content":"Behaves like，这个说法词意感觉更贴切，感谢增加理解角度","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630714890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1199213,"avatar":"https://static001.geekbang.org/account/avatar/00/12/4c/6d/c20f2d5a.jpg","nickname":"LJK","note":"","ucode":"12B2441099FF1D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361947,"discussion_content":"那么我想问这里AliyunStorage is a ImageStore的话，是不是也可以用抽象类实现？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616810010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1268264,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5a/28/732d3f2f.jpg","nickname":"GEEKBANG_6638780","note":"","ucode":"952194E56FD8C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1199213,"avatar":"https://static001.geekbang.org/account/avatar/00/12/4c/6d/c20f2d5a.jpg","nickname":"LJK","note":"","ucode":"12B2441099FF1D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382743,"discussion_content":"完全可以，可以通过ImageStore提供模板方法设计，规定上传下载流程。 比如上传的时候检查目录是否存在，然后上传完毕后关闭流资源等。下载也可以按照类似设计。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625710743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":361947,"ip_address":""},"score":382743,"extra":""}]},{"author":{"id":1809713,"avatar":"","nickname":"sleepingcat","note":"","ucode":"AF7E7ED85E557F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350783,"discussion_content":"c++的多继承在java里的表现就是接口实现，那吸血鬼has 人和has 蝙蝠这个描述没异议吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614004509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1100117,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/55/3b2526ce.jpg","nickname":"深山何处钟","note":"","ucode":"5D42024E40D751","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326083,"discussion_content":"第二点说的，个人感觉是里氏替换原则的具体应用。真正严格的面向对象开发，应该是遵守里氏替换原则的。而这条原则和老哥你说的“相似的行为”概念有一定的重合。但里氏替换原则的应用其实更广，这里我觉得作者后面一定会专门讲一下这个原则的。莫慌，这才刚刚第9讲。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605517266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1182146,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/c2/8c5442bf.jpg","nickname":"老庄道人","note":"","ucode":"C102EA323A69B4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":321662,"discussion_content":"看起来将接口定位为has-a确实不太合适，但是第二段多重继承的问题不一定是接口，男人可以多重继承人和雄性两个类，男人is-a人，同时，男人is-a雄性。个人认为，如果多重继承发现并不是is-a的关系，那我怀疑是多重继承出了问题，似乎不应该使用多重继承","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604620321,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1200660,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/14/cb118a61.jpg","nickname":"键舞飞扬","note":"","ucode":"4EC7A8D2E7AC78","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1182146,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/c2/8c5442bf.jpg","nickname":"老庄道人","note":"","ucode":"C102EA323A69B4","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":342076,"discussion_content":"把雄性定义成类本来就是一个问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610590675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":321662,"ip_address":""},"score":342076,"extra":""},{"author":{"id":1250556,"avatar":"https://static001.geekbang.org/account/avatar/00/13/14/fc/3afb6a1f.jpg","nickname":"普朗克","note":"","ucode":"C7EB774F6B1E0B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1182146,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/c2/8c5442bf.jpg","nickname":"老庄道人","note":"","ucode":"C102EA323A69B4","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":359573,"discussion_content":"雄性应该是作为一个人的属性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616231683,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":321662,"ip_address":""},"score":359573,"extra":""}]},{"author":{"id":2098988,"avatar":"https://static001.geekbang.org/account/avatar/00/20/07/2c/106f95e2.jpg","nickname":"NSblacker","note":"","ucode":"9B134D217F9E70","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305332,"discussion_content":"我看到上一篇的时候，对has-a也稍微停下来想了一下。基本符合大家留言的意思，表示拥有接口中提供的能力，比如我设计Warrior类，他继承自Person抽象类，且实现一个Peoperty接口来计算攻击力，防御力，血量，表示Warrior拥有此套属性值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599880609,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1734656,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/78/00/675a5795.jpg","nickname":"小龙成Hu","note":"","ucode":"6AFCED06795C91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206710,"discussion_content":"其实继承除了 is-a  还有 like-a的 只是作者没有提及","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584431954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1102062,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d0/ee/f5c5e191.jpg","nickname":"LYy","note":"","ucode":"8D5C39B9531E71","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":114265,"discussion_content":"duck type","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577966445,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1004716,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/54/ac/8b94b8b2.jpg","nickname":"mr.su","note":"","ucode":"8A4B9910960118","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":76758,"discussion_content":"支持zeta大哥的说法，赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575852638,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1228759,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/d7/9e2c8648.jpg","nickname":"呆猫","note":"","ucode":"69E256E6A19225","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":66684,"discussion_content":"学习了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575098142,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1335155,"avatar":"https://static001.geekbang.org/account/avatar/00/14/5f/73/bb3dc468.jpg","nickname":"拒绝","note":"","ucode":"CB0264C4D3FE17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":61022,"discussion_content":"优秀！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574769821,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1125806,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/nVVI6Fib5LHbhAhv8CJ9MYPau7Lcp840ST6BeqnlibUNmI4UYvGIzxtOHcKIzFa10ERANAZQUaiaKkQg4SowsUR2g/132","nickname":"瓶子霸哥","note":"","ucode":"A7EEB459AB5550","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":59415,"discussion_content":"我觉得 behaves like 这个思路应该是对的, 也更接近我对接口的理解. 看很多接口定义都是 behaves 的定义. Clickable, Readable, Writeable 都是 behaves like 的语义. ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574688377,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57865,"discussion_content":"我觉得这种留言老师应该给出正面回复。毕竟，这篇和上篇都差那么一点意思。尤其是这篇的讨论题，这个题目本身就没有什么标准答案，而是分具体场景来说的。所以我觉得这个题目问在什么需求场景下来做什么样的设计比较好。毕竟如果工程中只有这么一个类，那么无论怎么做都是可以的。如果当项目中有除了阿里云和私有云之外其他的存储方式，可能就是工厂模式？并且如果允许在运行时改变行为方式或许加上策略模式更合适一点。而这些都还没有讲到，现在抛出这些问题有点超纲😥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574645098,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1255260,"avatar":"https://static001.geekbang.org/account/avatar/00/13/27/5c/ee2a876f.jpg","nickname":"zeta","note":"","ucode":"AF84A72375827C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":58216,"discussion_content":"面向对象设计就像写文章，如你所说，本来也没啥正确答案，而且往往话语权大的人的思想更容易广泛围传播。我毕竟也没什么大厂背景，实力也不足以开个课讲这些，我写的这个评论能被放出来我已经很知足了，大家觉得有道理的话，自行取用就好。上课吸收知识是一方面，带着自己的思考持续寻找答案也很重要。谢谢各位支持。","likes_number":13,"is_delete":false,"is_hidden":false,"ctime":1574659095,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":57865,"ip_address":""},"score":58216,"extra":""}]},{"author":{"id":1248510,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0c/fe/4a1f045e.jpg","nickname":"Sheamus","note":"","ucode":"F6EBDFF3575ADA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57763,"discussion_content":"has a 不是具备的意思吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574642586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1050508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","nickname":"蚂蚁内推+v","note":"","ucode":"24B10AEE54B3FD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56047,"discussion_content":"讲的真是很好，我一直就觉得抽象类对应is-a，接口对应has-a这种描述很有迷惑性，很多时候is-a 也可以用has-a去实现，并无不妥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574427527,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1740639,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/8f/5f/c6d10aa8.jpg","nickname":"码弓手","note":"","ucode":"B5D1EC8424B5D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1050508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","nickname":"蚂蚁内推+v","note":"","ucode":"24B10AEE54B3FD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":86240,"discussion_content":"现在继承的缺点相对较多，组合比继承更灵活，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576592462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":56047,"ip_address":""},"score":86240,"extra":""}]}]},{"had_liked":false,"id":154551,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1015754,"ip_address":"","ucode":"00DF2FEC58D2E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","comment_is_top":false,"comment_ctime":1574479205,"is_pvip":false,"discussion_count":11,"race_medal":0,"score":"1045251532133","product_id":100039001,"comment_content":"到目前为止老师所讲理的的理论都懂～至于思考题用简单工厂，反射等方式感觉都不行。给老师提个小小的建议：能不能和隔壁的『MySQL实现45讲』的专栏一样在下一节课程的末尾集中回答一下上一节课程的课后习题？感谢","like_count":243,"discussions":[{"author":{"id":1026960,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ab/90/52d85edf.jpg","nickname":"Alvin","note":"","ucode":"BAC5FDAF1E3E5E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312016,"discussion_content":"感觉依赖注入是最完美的O(∩_∩)O","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1602562409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1012889,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/74/99/dbdee494.jpg","nickname":"REAL_MADIRD","note":"","ucode":"9E327B5456739D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332588,"discussion_content":"这个建议不错，提完问题也要回答呀，这样才是一个闭环，对吧","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1607265648,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1063308,"avatar":"https://static001.geekbang.org/account/avatar/00/10/39/8c/089525aa.jpg","nickname":"小乙哥","note":"","ucode":"C77E79BEA0C325","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":58202,"discussion_content":"同意你的看法，有时候确实需要听到发问者自己对这个问题的思考","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1574658077,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1257347,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2f/83/516e62ac.jpg","nickname":"木同","note":"","ucode":"81A7C9E8D27A52","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1063308,"avatar":"https://static001.geekbang.org/account/avatar/00/10/39/8c/089525aa.jpg","nickname":"小乙哥","note":"","ucode":"C77E79BEA0C325","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74157,"discussion_content":"有道理","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575634993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":58202,"ip_address":""},"score":74157,"extra":""}]},{"author":{"id":1038798,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d9/ce/4528cb4b.jpg","nickname":"呼呼","note":"","ucode":"5D7B57C05B5D8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84776,"discussion_content":"不能再同意了，很想看到作者对于问题的思考","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1576506086,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2071327,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/9b/1f/9f3379d3.jpg","nickname":"Geek_7f21d2","note":"","ucode":"12204FDAD951BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295939,"discussion_content":"策略模式","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1596385364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2833619,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/3c/d3/fab9d588.jpg","nickname":"探雪","note":"","ucode":"2332650D9C8D54","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":414537,"discussion_content":"MySQL45讲 YYDS","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1636807749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1940536,"avatar":"","nickname":"haiyuan.wu","note":"","ucode":"22BD519B05F49D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337385,"discussion_content":"这也是很有必要。赞","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1608887346,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1337016,"avatar":"https://static001.geekbang.org/account/avatar/00/14/66/b8/ece79234.jpg","nickname":"王智","note":"","ucode":"37D2AD591C1AEC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535366,"discussion_content":"我也是。看了十来节，就想知道那些课后作业的答案。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638420086,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2555948,"avatar":"","nickname":"Geek_b76b97","note":"","ucode":"5968DEF6D0018B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374735,"discussion_content":"一般不都是配置文件改对象的吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621330874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1031734,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/be/36/abb7bfe3.jpg","nickname":"xenoblade3","note":"","ucode":"620DD0491EEFF3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302406,"discussion_content":"用简单工厂就是正确答案呀，把对象创建抽象为接口，这样就可以在imageJob中使用接口而不是特定的PrivateImageLoader编程了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598919909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154080,"user_name":"业余爱好者","can_delete":false,"product_type":"c1","uid":1482915,"ip_address":"","ucode":"A890935A982988","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","comment_is_top":false,"comment_ctime":1574379829,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"658704376117","product_id":100039001,"comment_content":"关于抽象和函数命名的问题，不知道哪个大佬说过这么一句话: <br><br>   每个优秀的程序员都知道，不应该定义一个attackBaghdad() ‘袭击巴格达‘ 的方法，而是应该把城市作为函数的参数 attack(city)。","like_count":153,"discussions":[{"author":{"id":1905357,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/12/cd/55e25527.jpg","nickname":"咕咕噜噜","note":"","ucode":"E9045BF11FAB7C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213292,"discussion_content":"我觉得这并不完全正确，取决于方法的复杂性，如果每个城市袭击的方式都大不一样，我觉得还是分开写比较好。有时候并不需要大而全方法，更多需要职责单一的方法","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1585062768,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":2063037,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","nickname":"西电","note":"","ucode":"95BD4CE9D93018","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1905357,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/12/cd/55e25527.jpg","nickname":"咕咕噜噜","note":"","ucode":"E9045BF11FAB7C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291489,"discussion_content":"可以这样，定义一些基础类attackByMissile，attackByPlane,attackByTank。 \n进攻巴格达时候再将需要的类继承或者组合一下","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594836664,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":213292,"ip_address":""},"score":291489,"extra":""},{"author":{"id":1200660,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/14/cb118a61.jpg","nickname":"键舞飞扬","note":"","ucode":"4EC7A8D2E7AC78","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1905357,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/12/cd/55e25527.jpg","nickname":"咕咕噜噜","note":"","ucode":"E9045BF11FAB7C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342077,"discussion_content":"可以定义为虚方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610590797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":213292,"ip_address":""},"score":342077,"extra":""},{"author":{"id":1133206,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4a/96/8756eaa2.jpg","nickname":"王也","note":"","ucode":"9EA69B51ECC99F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1905357,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/12/cd/55e25527.jpg","nickname":"咕咕噜噜","note":"","ucode":"E9045BF11FAB7C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371445,"discussion_content":"片面了, 抽象方法存在的意义之一 , 就是为了剞劂这种袭击方式不一样的场景.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619770623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":213292,"ip_address":""},"score":371445,"extra":""}]},{"author":{"id":1242573,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f5/cd/3890be04.jpg","nickname":"小川","note":"","ucode":"D462222DDBB978","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393100,"discussion_content":"高度抽象的情况下，甚至可以直接定义 attack方法，不需要参数。有 CitcyAttacker 这种类去实现 Attacker 接口","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1631250245,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2829583,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/2d/0f/52e5dcff.jpg","nickname":"右手特别大","note":"","ucode":"9B9A4600B97D81","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576924,"discussion_content":"名字在函数名中不一定就不合理，取决于在它是否在多个地方调用，并且需求上它们代表的同一个事情或场景。如果是， 城市名不作为参数实际上更合适，更加准确详细地表达了它们是同一件事这个信息。1.语法上确保他们的行为是一模一样，不会出现参数拼写错误。2.方便语法搜索阅读代码， 更清晰地查看到底哪些地方也做了这个事情。如果作为参数，也其他城市的也会出现在搜索结果中。3.假如未来这个事情内部逻辑发生变化，或者实现改变了，例如名字换成中文， 城市不再用字符串而是用类来表示等，所有调用它的地方都不受影响。这才是真正的面向接口编程， 面向当前需求概念中的接口，而不我们觉得未来可能会出现的接口。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655858924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154062,"user_name":"香蕉派2号","can_delete":false,"product_type":"c1","uid":1587685,"ip_address":"","ucode":"1BB5A449B6EA5E","user_header":"https://static001.geekbang.org/account/avatar/00/18/39/e5/53b1f697.jpg","comment_is_top":false,"comment_ctime":1574372402,"is_pvip":false,"discussion_count":18,"race_medal":0,"score":"452545938482","product_id":100039001,"comment_content":"思考题<br>解决方案=配置文件+反射+工厂模式","like_count":105,"discussions":[{"author":{"id":1009422,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/0e/c77ad9b1.jpg","nickname":"eason2017","note":"","ucode":"E070BA624FA490","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":121706,"discussion_content":"SPI方式，通过配置文件的方式，在启动的时候加载实现类","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1578322202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1132661,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","nickname":"乘坐Tornado的线程魔法师","note":"","ucode":"C4C9915866E769","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56355,"discussion_content":"tql=太强了","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1574475793,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1051470,"avatar":"https://static001.geekbang.org/account/avatar/00/10/0b/4e/fd946cb2.jpg","nickname":"allean","note":"","ucode":"A0D2DB4F219EAA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1132661,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","nickname":"乘坐Tornado的线程魔法师","note":"","ucode":"C4C9915866E769","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56986,"discussion_content":"国舅所言极是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574556832,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":56355,"ip_address":""},"score":56986,"extra":""}]},{"author":{"id":1111131,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f4/5b/8ee3bce0.jpg","nickname":"初八","note":"","ucode":"D40E15983BFAD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":118894,"discussion_content":"这种在spring源码中应用的太多太多。你可以在实现中定义一个是否匹配的方法根据一定的规则。详细参考springmvc handle。springmvc messageconvertor。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1578198233,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1677187,"avatar":"https://static001.geekbang.org/account/avatar/00/19/97/83/845b48e2.jpg","nickname":"Allen_","note":"","ucode":"CA5E00E4644CD5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1111131,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f4/5b/8ee3bce0.jpg","nickname":"初八","note":"","ucode":"D40E15983BFAD6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":178885,"discussion_content":"用自己的语言能讲出本质才是对技术的透彻领悟哦","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1582203055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":118894,"ip_address":""},"score":178885,"extra":""}]},{"author":{"id":1219438,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg","nickname":"蓝魔丶","note":"","ucode":"2AE4359E263558","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":58498,"discussion_content":"这不就是spring的思想嘛，不过你还是要修改配置文件，终逃不了要修改些地方","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574678611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":7,"child_discussions":[{"author":{"id":1140666,"avatar":"https://static001.geekbang.org/account/avatar/00/11/67/ba/5a1bd8c9.jpg","nickname":"噗╰_╯噗 ","note":"","ucode":"AFB831EB42256D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1219438,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg","nickname":"蓝魔丶","note":"","ucode":"2AE4359E263558","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":80912,"discussion_content":"配置修改已经将成本降到了最低，避免了打包发布服务重启等一系列的繁琐流程。如若觉得有更优解，望分享","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576203702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":58498,"ip_address":""},"score":80912,"extra":""},{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1140666,"avatar":"https://static001.geekbang.org/account/avatar/00/11/67/ba/5a1bd8c9.jpg","nickname":"噗╰_╯噗 ","note":"","ucode":"AFB831EB42256D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":85486,"discussion_content":"可以这样，将processJob抽象化，然后由子类提供getImageStore()的具体实现。思路是隔离变化，封装稳定。当获得imageStore变成不稳定时，就需要隔离他。\npublic void process() { \n    Image image = ...;//处理图片，并封装为Image对象 \n    ImageStore imageStore = getImageStore();\n    imageStore.upload(image, BUCKET_NAME); \n}\n\nabstract ImageStore getImageStore();","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576549200,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":80912,"ip_address":""},"score":85486,"extra":""},{"author":{"id":1140666,"avatar":"https://static001.geekbang.org/account/avatar/00/11/67/ba/5a1bd8c9.jpg","nickname":"噗╰_╯噗 ","note":"","ucode":"AFB831EB42256D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":102161,"discussion_content":"封装稳定隔离变化这没问题，现在的问题是，假如我的应用程序里有私有云和阿里云两个文件上传的实现，如何去切换上传文件时使用的实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577327462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":85486,"ip_address":""},"score":102161,"extra":""}]},{"author":{"id":1200660,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/14/cb118a61.jpg","nickname":"键舞飞扬","note":"","ucode":"4EC7A8D2E7AC78","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342078,"discussion_content":"依赖注入","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1610590847,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2111332,"avatar":"https://static001.geekbang.org/account/avatar/00/20/37/64/26704448.jpg","nickname":"Hello，World！：)","note":"","ucode":"89F1DB34D197B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590754,"discussion_content":"Spring：你直接报我身份证号算了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666064036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2108743,"avatar":"https://static001.geekbang.org/account/avatar/00/20/2d/47/6a5ab601.jpg","nickname":"CptW","note":"","ucode":"A3174302EBD4B2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301150,"discussion_content":"阿巴啊把","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598425413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1034204,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c7/dc/9408c8c2.jpg","nickname":"ban","note":"","ucode":"E523CE97E48266","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":91724,"discussion_content":"我觉得不用配置文件，直接配置在表里面更方便","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576846343,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1698258,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIx7FdRzUuQf4Fopr7DOXEHZyCFfH4GQViaqo7bymf1qaANcOvuEhHyTNwOOUFW7psxEeSQ5k9uXWw/132","nickname":"阿顺","note":"","ucode":"36F2AD6F980B11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55847,"discussion_content":"tql","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574405459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154084,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1574380081,"is_pvip":true,"discussion_count":14,"race_medal":0,"score":"405301305905","product_id":100039001,"comment_content":"关于思考题我想出两种方法改进：简单工厂方法和使用反射。<br><br>1、简单工厂方法<br>ImageStore imageStore = ImageStoreFactory.newInstance(SOTRE_TYPE_CONFIG);<br>config文件可以写类似properties的文件，使用key-value存储。<br><br>缺点：再新增另一种存储手段时，需要修改工厂类和添加新的类。修改工厂类，违反了开放-封闭原则。<br><br>那有没有更好一点的方法呢？<br><br>2、使用反射。<br>在配置文件中定义需要的image store类型。<br>在ProcessJob中<br>ImageStore store = (ImageStore) Class.forName(STORE_CLASS)<br>    .newInstance();<br><br>缺点：使用反射，在大量创建对象时会有性能损失。<br><br>关于减少ProcessJob中的修改，还有没有更好的方法呢？我只是抛砖引玉，希望和大家一起讨论。具体实现：https:&#47;&#47;github.com&#47;gdhucoder&#47;Algorithms4&#47;tree&#47;master&#47;geekbang&#47;designpattern&#47;u009<br><br>补充：<br>关于access token：Aliyun的AccessToken时有expireTime时限的。不需要每次重新获取，过期时重新获取即可。","like_count":94,"discussions":[{"author":{"id":1444122,"avatar":"https://static001.geekbang.org/account/avatar/00/16/09/1a/e0f95684.jpg","nickname":"空空","note":"","ucode":"8F6EFE5A6F6F64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":156434,"discussion_content":"为什么不使用多态呢？\npublic class ImageProcessingJob {\n  private static final String BUCKET_NAME = &#34;ai_images_bucket&#34;;\n  //...省略其他无关代码...\n  \n  public void process(ImageStore imageStore) {\n    Image image = ...;//处理图片，并封装为Image对象\n    imagestore.upload(image, BUCKET_NAME);\n  }","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1580363048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1437667,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ef/e3/db895077.jpg","nickname":"流放","note":"","ucode":"21E30A37E7F139","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56300,"discussion_content":"简单工厂模式改成抽象工厂模式不就保护了开闭原则","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574470824,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1437667,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ef/e3/db895077.jpg","nickname":"流放","note":"","ucode":"21E30A37E7F139","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56451,"discussion_content":"我在想抽象工厂仅需要增加代码，不使用反射的话，还是要修改客户端代码。还不如直接用反射，不用抽象工厂了。\n不知道我想的是否有问题？还望指出，谢谢！","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574481592,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":56300,"ip_address":""},"score":56451,"extra":""}]},{"author":{"id":1532404,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIvUlicgrWtibbDzwhLw5cQrDSy2JuE1mVvmXq11KQIwpLicgDuWfpp9asE0VCN6HhibPDWn7wBc2lfmA/132","nickname":"a、","note":"","ucode":"590FE8DB111492","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":64311,"discussion_content":"我觉得SPI是不是也可以？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574945179,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1532404,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIvUlicgrWtibbDzwhLw5cQrDSy2JuE1mVvmXq11KQIwpLicgDuWfpp9asE0VCN6HhibPDWn7wBc2lfmA/132","nickname":"a、","note":"","ucode":"590FE8DB111492","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":65117,"discussion_content":"service provider interface 会不会有点大材小用了？而且spi底层也是用反射。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574984405,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":64311,"ip_address":""},"score":65117,"extra":""}]},{"author":{"id":1248510,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0c/fe/4a1f045e.jpg","nickname":"Sheamus","note":"","ucode":"F6EBDFF3575ADA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57766,"discussion_content":"对于web项目来说，Spring注入List注入了解一下，只需要简单工厂和在接口配置一个方法即可","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574642768,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1248510,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0c/fe/4a1f045e.jpg","nickname":"Sheamus","note":"","ucode":"F6EBDFF3575ADA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57900,"discussion_content":"好的，谢谢建议！有段时间没做web项目了，spring都忘光了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574645874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":57766,"ip_address":""},"score":57900,"extra":""}]},{"author":{"id":1015483,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","nickname":"程序员小跃","note":"","ucode":"25BB96E0791A60","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55855,"discussion_content":"各自肯定都会缺点，得根绝实际情况，选择最优的即可","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574405996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1015483,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","nickname":"程序员小跃","note":"","ucode":"25BB96E0791A60","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":55914,"discussion_content":"谢谢回复！\n菜鸟和高手下象棋，看似两个人落子的位置都是当前棋面上对他来说最有利的位置（局部最优），最后菜鸟败给高手。菜鸟只能看1-2步棋，而高手能看的更远，我想这就是我们为什么要学习设计模式吧！","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1574411997,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":55855,"ip_address":""},"score":55914,"extra":""},{"author":{"id":1015483,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","nickname":"程序员小跃","note":"","ucode":"25BB96E0791A60","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":55955,"discussion_content":"正解，这就是为什么这么多人在学习吧，加油","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574416779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":55914,"ip_address":""},"score":55955,"extra":""}]},{"author":{"id":1242573,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f5/cd/3890be04.jpg","nickname":"小川","note":"","ucode":"D462222DDBB978","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308195,"discussion_content":"启动参数 ＋ Spring Bean 工厂，可以很好的解决问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600868236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1202782,"avatar":"https://static001.geekbang.org/account/avatar/00/12/5a/5e/a897cb0d.jpg","nickname":"grey927","note":"","ucode":"833E02ED835B4A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290484,"discussion_content":"使用Spring的Bean工厂就可以了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594485588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1182516,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0b/34/f41d73a4.jpg","nickname":"王盛武","note":"","ucode":"DE7EF246D3DCE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":66789,"discussion_content":"简单工厂方法就可以了，不需要过度设计","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575107131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1182516,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0b/34/f41d73a4.jpg","nickname":"王盛武","note":"","ucode":"DE7EF246D3DCE8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":66820,"discussion_content":"学了不少，总想用一下🤣","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575108744,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":66789,"ip_address":""},"score":66820,"extra":""}]}]},{"had_liked":false,"id":154057,"user_name":"秋惊蛰","can_delete":false,"product_type":"c1","uid":1620344,"ip_address":"","ucode":"3D9A6D5CA9C79F","user_header":"https://static001.geekbang.org/account/avatar/00/18/b9/78/a5804dae.jpg","comment_is_top":false,"comment_ctime":1574360501,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"233502594485","product_id":100039001,"comment_content":"依赖注入，从外部构建具体类的对象，传入使用的地方","like_count":54,"discussions":[{"author":{"id":2062402,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKOnpl8fRB9r2vED2s8j7Arwbn2K6M6HUBWNjgoqV4uqe94fTGK4WGpOJLeRxXcBXk3dp23eQR0AQ/132","nickname":"吴钩","note":"","ucode":"0EB50E8144BCDE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393595,"discussion_content":"那修改Type参数的地方是不是和原文一样多呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1631508263,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1024341,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a1/55/cff2322c.jpg","nickname":"雪中亮","note":"","ucode":"B294FDFF9F13E8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56664,"discussion_content":"spring依赖注入真香，直接@Resource(Type = ...)注入，需要更换实现时，直接将Type指定的类型改了就好。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574506643,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154336,"user_name":"雷霹雳的爸爸","can_delete":false,"product_type":"c1","uid":1119490,"ip_address":"","ucode":"99BBA6D83DD11F","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/02/66f65388.jpg","comment_is_top":false,"comment_ctime":1574411067,"is_pvip":true,"discussion_count":4,"race_medal":0,"score":"139013364539","product_id":100039001,"comment_content":"要不是有一开始的课程大纲，我以为课堂讨论是要启发大家，在下节就要讲创建型模式，工厂模式，工厂方法什么的了<br><br>但转念一想，这想法或许太肤浅了，毕竟大多数创建型方法都有一个明显的对具体类型的依赖（这里先预先排除抽象工厂，觉得有点小题大做这样搞），都不是一个最终能让人感到内心宁静的做法<br><br>这节既然讲的是依赖于抽象而不是依赖于具体，那比较得瑟的玩儿法恐怕应该是直接在ImageProcessingJob类和ImageStore接口这两个类型关系上充分体现出依赖倒置的思路，把最后一点执行创建ImageStore类型实例的痕迹彻底关在ImageProcessingJob的门外，虽然必然得有人去考虑实际至少调一下ImageStore具体类型实例的这个创建过程，但ImageProcessingJob这爷是不打算操心这事了，它只需要留个口子，让别人把ImageProcessingJob放到自己锅里，自己就可以开始炒菜了<br><br>也就是从形式上，ImageProcessingJob这个类只需要保留对ImageStore接口的依赖就可以了，具体留口子的手段则要考虑依赖注入，形式上有两种：<br><br>+ 一种是可能更OO样子的一点，即声明一个ImageStore的field在ImageProcessingJob类里面<br>  - 如果说有什么好处，恩，可以理解为能对客户程序隐藏了ImageStore类型的信息，是的，连类型信息都隐藏掉；好吧，还是得关心别人，毕竟这世界上不是仅有自己一个<br>  - 具体操作起来，由于不能声明field时候直接new，要不又变回去了，但又不能NPE吧，所以不考虑创建，我还是得考虑怎么把实例请进来，就是上面说的至少留个口子<br>  - 这时候可能不得不借助依赖注入的帮助了（否则就是依赖查找，还是工厂），即<br>  - 通过ImageProcessingJob的构造函数注入或者利用field注入来获取ImageStore接口的实例，或者ImageProcessingJob如果依赖项多，Builder一下也很好<br>  - 毕竟ImageProcessingJob这个类型在我们讨论的上下文里面是如此具体的一个类，就不过分追溯它的创建责任及执行在哪里了<br>+ 另一种，表面粗暴直接看似问题多多，但是细品也有点意思的，那就是process方法直接增加一个ImageStore的参数就完了，OMG我在干什么<br>  - 没有B方案的设计自身无法证明自己更好<br>  - 相对于上面的，直接的问题是会对process方法直接依赖的客户程序会和ImageStore这个类型产生耦合<br>    * 如果客户程序是一个类（还能是什么？），要么有一个field等着inject进来，要么是通过调用process的method传进来，要么就是无中生有（直接new了或用创建型模式）<br>    * 这都可能造成没有充分的设计隔离，至少让客户程序造成信息冗余，承担了不必要的职责等问题<br>  - 但事实上也不是完全没好处，这种灵活性体现在它没有把ImageStore的逻辑固化在任一个ImageProcessingJob实例里面<br>    * 考虑上面第三类无中生有的方式，假设是创建型的工厂方法或类似手段，则可以提供对method参数（业务层面的动态输入，例如最终操作用户的提供的值）的响应能力<br>    * 这和，执行排序算法骨架确定，但是需要给定两个元素（复杂对象）比较规则这种思路有相似之处，毕竟我需要的是对方的能力而不是对方的数据或者数据视图，这时候这么做还是很有诱惑力的<br>  - 如果脱离开场景，实际上这种动态性还更强，但问题就在于这种动态性会不会对于具体场景有价值<br>  - 从这个实例上看，也许没这么明显，因为不同的对象存储后端更有可能是环境（测试、生产？但12 factor让我们...好歹测试环境还是也上云吧）不同造成的，而非基于动态的用户信息输入<br>  - 但，事无绝对吧，假设，用户有选择我要针对具体这一张，我特么上传那一刻选择一个存储后端的需求<br>    - 然后为了方便用户，用户竟然可以勾选，以后使用同样地选择...<br>    - 我觉得除了脑子进水的犬类应该没人会干这种没问题制造问题也要上的方案吧<br> <br> 所以综上所属，还是field一个ImageStore接口来搞吧<br><br>这极客时间也让人想吐槽，能敲2000字，结果就只留这么大点儿一个输入框...你要不就限制200字我还能少敲一点...我这写的兴起还得外面写完了贴过来...","like_count":32,"discussions":[{"author":{"id":1740639,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/8f/5f/c6d10aa8.jpg","nickname":"码弓手","note":"","ucode":"B5D1EC8424B5D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":86308,"discussion_content":"我竟然看完了，似乎是个戏精来的感觉","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1576593567,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1119490,"avatar":"https://static001.geekbang.org/account/avatar/00/11/15/02/66f65388.jpg","nickname":"雷霹雳的爸爸","note":"","ucode":"99BBA6D83DD11F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1740639,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/8f/5f/c6d10aa8.jpg","nickname":"码弓手","note":"","ucode":"B5D1EC8424B5D5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":86710,"discussion_content":"😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576599191,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":86308,"ip_address":""},"score":86710,"extra":""}]},{"author":{"id":2100090,"avatar":"https://static001.geekbang.org/account/avatar/00/20/0b/7a/9ce7dc7d.jpg","nickname":"东瓜酱","note":"","ucode":"B1FEADF98DE292","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297841,"discussion_content":"我居然看完了，但还是不懂","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597070704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1119490,"avatar":"https://static001.geekbang.org/account/avatar/00/11/15/02/66f65388.jpg","nickname":"雷霹雳的爸爸","note":"","ucode":"99BBA6D83DD11F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2100090,"avatar":"https://static001.geekbang.org/account/avatar/00/20/0b/7a/9ce7dc7d.jpg","nickname":"东瓜酱","note":"","ucode":"B1FEADF98DE292","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297913,"discussion_content":"别说你了，我特么自己回来都看不懂…","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1597110426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":297841,"ip_address":""},"score":297913,"extra":""}]}]},{"had_liked":false,"id":154041,"user_name":"失火的夏天","can_delete":false,"product_type":"c1","uid":1241770,"ip_address":"","ucode":"10C6E66EB2A65F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","comment_is_top":false,"comment_ctime":1574352966,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"104653568070","product_id":100039001,"comment_content":"思考题估计就是要引出工厂模式了吧","like_count":24},{"had_liked":false,"id":154372,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1574416324,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"96063696836","product_id":100039001,"comment_content":"课堂讨论answer: <br>考虑使用工厂模式生成ImageStore实例.这样就可以将调用者和具体ImageStore解耦.<br><br>例:<br>public class ImgStoreFactory {<br><br>    private ImgStoreFactory(){<br><br>    }<br><br>    public static ImageStore create(Class&lt;?&gt; clz){<br>        if (clz == AliyunStore.class){<br>            return new AliyunStore();<br>        }else if (clz == PrivateYunStore.class){<br>            return new PrivateYunStore();<br>        }else {<br>            throw new IllegalStateException(&quot;..&quot;);<br>        }<br>    }<br><br>    public static void main(String[] args) {<br>        ImageStore store = ImgStoreFactory.create(AliyunStore.class);<br>        store.dosth();<br>    }<br>}<br><br>另外有一点不太同意作者的说法:<br>上节课作者将Contract翻译为&quot;协议&quot;,<br>我认为是不恰当的.<br>在计算机领域, 通常使用Protocol代表协议.<br>个人认为Contract更恰当的翻译是&quot;契约&quot;.","like_count":22,"discussions":[{"author":{"id":1236320,"avatar":"https://static001.geekbang.org/account/avatar/00/12/dd/60/a6a4f79a.jpg","nickname":"笨鸟","note":"","ucode":"68029ADA76AA5A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291397,"discussion_content":"问题没解决,换方式还得改XXX.class","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1594804002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1740639,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/8f/5f/c6d10aa8.jpg","nickname":"码弓手","note":"","ucode":"B5D1EC8424B5D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":86283,"discussion_content":"这个不行，如果以后加别的实现类时，创建方式还是得改，违反了开闭原则","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1576593192,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1742968,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/98/78/6459e29e.jpg","nickname":"麦芽科技学堂","note":"","ucode":"A90DDE4B6696BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":207813,"discussion_content":"需要修改的地方也没有减少啊","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1584515615,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1130122,"avatar":"https://static001.geekbang.org/account/avatar/00/11/3e/8a/891b0e58.jpg","nickname":"wnz27","note":"","ucode":"BC9ACB6B7C6FD9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":129606,"discussion_content":"所以呢？你说这个的意义是？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578718121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1793704,"avatar":"","nickname":"rao","note":"","ucode":"D5ACA241A8F636","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":191595,"discussion_content":"这个没解决问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583018562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1048286,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fe/de/2019f370.jpg","nickname":"jony","note":"","ucode":"80765A6B9ABA0D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":75823,"discussion_content":"有心了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575784038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154040,"user_name":"编程界的小学生","can_delete":false,"product_type":"c1","uid":1593289,"ip_address":"","ucode":"4A5BE9A5E877FA","user_header":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","comment_is_top":false,"comment_ctime":1574352859,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"91768666075","product_id":100039001,"comment_content":"首先这篇文章受益匪浅，尤其是第二点，与特定实现有关的方法不要暴露到接口中，深有体会。<br><br>其次问题解答<br>我个人的解决方案是这种情况不要去直接new，而是用工厂类去管理这个对象，然后名字可以起成getInstance这类不包含某个具体实现的含义的抽象名称。将来修改直接修改工厂类的getInstance方法即可，这种方式可取吗？还有其他更好的方式吗？求老师点评。","like_count":21,"discussions":[{"author":{"id":2063037,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","nickname":"西电","note":"","ucode":"95BD4CE9D93018","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292255,"discussion_content":"能分享一下&#34;与特定时限有关的方法，不要暴露到接口中。&#34;么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595156513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1810576,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","nickname":"M","note":"","ucode":"06F26E1D62E9C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":189243,"discussion_content":"如果用工厂模式创建，那将来也会有很多的工厂，管理起来也不是很方便吧。\n不过，也是一种方法，把对象的创建交给工厂，将来变化直接修改工厂即可。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582861274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154607,"user_name":"二星球","can_delete":false,"product_type":"c1","uid":1111552,"ip_address":"","ucode":"89EC5FEB98E7CE","user_header":"https://static001.geekbang.org/account/avatar/00/10/f6/00/2a248fd8.jpg","comment_is_top":false,"comment_ctime":1574491998,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"53114099550","product_id":100039001,"comment_content":"使用策略模式，在建一个Context类，使用聚合持有这个接口实例引用，其它所有地方都用这个context类，变动的时候，只变这个context类就行了，其它不动","like_count":12,"discussions":[{"author":{"id":1912022,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKgA8bMuSpADl8xc5DwayHwiaOYXRYIEnSjupnO3tBvVD0ZMobM69cUnm00AtIjZg8uKgEicf4zDziaw/132","nickname":"Geek_a2d228","note":"","ucode":"DCC710651F7D5F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333681,"discussion_content":"赞同,策略模式最好不过了,结合spring初始化的时候将不同的实现类封装到Map里,根据枚举code来取对应的实现类,执行就行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607592848,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175385,"user_name":"BitInit","can_delete":false,"product_type":"c1","uid":1007271,"ip_address":"","ucode":"BDDDA0F51B1EFB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/a7/8dc374e2.jpg","comment_is_top":false,"comment_ctime":1580701119,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"44530374079","product_id":100039001,"comment_content":"对于思考题，想到了两种方法：<br>1. 简单工厂+反射+配置<br>2. 通过使用控制反转&#47;依赖注入方式，类似于Spring","like_count":10,"discussions":[{"author":{"id":2089677,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/znc4EjKd64eg7KhiaRzicQAiaWPn6VDicwuRV52bQTBzu96FSwb26viccgFt3wBqtMF0DgXH0cHARdUVBicsLBgv1dYg/132","nickname":"Geek_ff1b3a","note":"","ucode":"1C001B254984B7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351203,"discussion_content":"我觉得是不是可以用配置文件+工厂模式+单例模式+反射来实现啊，因为接口本身不含有属性，所以不会引起并发环境下的数据不一致问题，同时也不会产生不必要的对象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614176738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154053,"user_name":"William","can_delete":false,"product_type":"c1","uid":1346215,"ip_address":"","ucode":"55F5D9DEE485B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","comment_is_top":false,"comment_ctime":1574357945,"is_pvip":true,"discussion_count":6,"race_medal":0,"score":"44524030905","product_id":100039001,"comment_content":"所以思考题，想到的是，将接口作为构造函数中的参数，传递进来，再调用.","like_count":10,"discussions":[{"author":{"id":2278659,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/TUMtkaIMdbFDS28AhjrQcqOhiapNvHyPMApz9QoZZkShZmomJRh6GX2aL2YeSMg4SicdydzdWxXZOZz49HNS9EtA/132","nickname":"Windqiu","note":"","ucode":"EF78D3CF73BCBB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360938,"discussion_content":"应该还有更优方案，如果实现多态特性是解决方案的一种。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616561859,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2100090,"avatar":"https://static001.geekbang.org/account/avatar/00/20/0b/7a/9ce7dc7d.jpg","nickname":"东瓜酱","note":"","ucode":"B1FEADF98DE292","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297843,"discussion_content":"感觉这样的话，就失去接口的意义了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597070813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1249136,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0f/70/759b1567.jpg","nickname":"张飞online","note":"","ucode":"C9787E4B35888C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55601,"discussion_content":"不对，我们理解错了，确实有最后一个问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574385517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1346215,"avatar":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","nickname":"William","note":"","ucode":"55F5D9DEE485B1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1249136,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0f/70/759b1567.jpg","nickname":"张飞online","note":"","ucode":"C9787E4B35888C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56568,"discussion_content":"哪个最后一个问题?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574498202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":55601,"ip_address":""},"score":56568,"extra":""}]},{"author":{"id":1249136,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0f/70/759b1567.jpg","nickname":"张飞online","note":"","ucode":"C9787E4B35888C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55551,"discussion_content":"说的对，感觉奇怪，目前好像我们实现了接口，但是使用的时候没有使用接口，导致最后的那个问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574383886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1346215,"avatar":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","nickname":"William","note":"","ucode":"55F5D9DEE485B1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1249136,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0f/70/759b1567.jpg","nickname":"张飞online","note":"","ucode":"C9787E4B35888C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55592,"discussion_content":"嗯，目前实现接口其实就是像争哥说的，一个不注意就没真正意义的抽象. 面向实现编程了.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574385222,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":55551,"ip_address":""},"score":55592,"extra":""}]}]},{"had_liked":false,"id":154341,"user_name":"Milittle","can_delete":false,"product_type":"c1","uid":1045455,"ip_address":"","ucode":"80E566639A8ABB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f3/cf/851dab01.jpg","comment_is_top":false,"comment_ctime":1574411460,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"40229117124","product_id":100039001,"comment_content":"再说一句 面向接口编程的精髓 我的理解是我们在使用接口的时候 关心我们要做什么 而不是怎么做 怎么做都封装在具体实现类中。而且最主要的是 接口抽象","like_count":9},{"had_liked":false,"id":154130,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1574383834,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"40229089498","product_id":100039001,"comment_content":"依赖注入可以解决思考题，基于接口的实现有多种时，注入处也需要指明是哪咤实现","like_count":9},{"had_liked":false,"id":154106,"user_name":"超威丶","can_delete":false,"product_type":"c1","uid":1180753,"ip_address":"","ucode":"1A18DE885D3C44","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/51/da465a93.jpg","comment_is_top":false,"comment_ctime":1574382092,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"35934120460","product_id":100039001,"comment_content":"个人觉得维护map是最好的选择，实现类型和具体实现对应。","like_count":8,"discussions":[{"author":{"id":1097497,"avatar":"https://static001.geekbang.org/account/avatar/00/10/bf/19/24cc3e7c.jpg","nickname":"二康","note":"","ucode":"45E85D80DE4544","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":63666,"discussion_content":"这个是策略模式 map存储实现类列表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574902016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154042,"user_name":"连边","can_delete":false,"product_type":"c1","uid":1391748,"ip_address":"","ucode":"54B5DA38449728","user_header":"https://static001.geekbang.org/account/avatar/00/15/3c/84/608f679b.jpg","comment_is_top":false,"comment_ctime":1574353224,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35934091592","product_id":100039001,"comment_content":"存储图片的方式写入到配置文件，第8行改用传入类型参数来实例化不同的对象，明天补上代码。","like_count":8},{"had_liked":false,"id":244612,"user_name":"Jasper","can_delete":false,"product_type":"c1","uid":1144132,"ip_address":"","ucode":"7AEF50986C7D8C","user_header":"https://static001.geekbang.org/account/avatar/00/11/75/44/ee170215.jpg","comment_is_top":false,"comment_ctime":1598595239,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"31663366311","product_id":100039001,"comment_content":"思考题：<br><br>    交由Spring容器管理此实现类，如果需要修改，修改此处代码重启即可<br><br>    @Bean<br>    public ImageStore getImageStore() {<br>        return new PrivateImageStore(&#47;*省略构造函数*&#47;);<br>    }<br><br>  ","like_count":7,"discussions":[{"author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383818,"discussion_content":"也行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626246531,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155289,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1574675022,"is_pvip":false,"replies":[{"id":"60020","content":"确实意义不大","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1574852242,"ip_address":"","comment_id":155289,"utype":1}],"discussion_count":17,"race_medal":0,"score":"31639446094","product_id":100039001,"comment_content":"那现在的MVC代码，要求service先写接口，然后再写实现，有必要嘛？<br>说实话，我一直没看懂这种行为的意义何在。","like_count":7,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475715,"discussion_content":"确实意义不大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574852242,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1242573,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f5/cd/3890be04.jpg","nickname":"小川","note":"","ucode":"D462222DDBB978","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393102,"discussion_content":"定义接口还是有意义的，大部分情况下，我们去了解业务，基本上是看接口包含了哪些方法，这样就一个这个服务包含了什么行为，直接看实现类的话，代码量大，还包含各种私有方法，没有接口看着通顺。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1631250666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1149143,"avatar":"https://static001.geekbang.org/account/avatar/00/11/88/d7/43cf7b60.jpg","nickname":"Cc°°","note":"","ucode":"6C88E8D2C4622D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1242573,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f5/cd/3890be04.jpg","nickname":"小川","note":"","ucode":"D462222DDBB978","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577185,"discussion_content":"不能赞同更多，接口的意义非凡，而更重要的是：接口包含了抽象的含义，是有抽象思考的过程的，和直接面向实现是完全不同的读写体验。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655961393,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":393102,"ip_address":""},"score":577185,"extra":""}]},{"author":{"id":1266482,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/IIkdC2gohpcibib0AJvSdnJQefAuQYGlLySQOticThpF7Ck9WuDUQLJlgZ7ic13LIFnGBXXbMsSP3nZsbibBN98ZjGA/132","nickname":"batman","note":"","ucode":"73C30ACFC0D612","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":160453,"discussion_content":"我认为给每个service定义接口的意义，就是满足可测试性。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1580805318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1516886,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/R4ALlUr7UoLJYXhxfNhWGwOSsF8cZYaOPT0zybxOXkCH8iaAo3iaUvQO7EcV0ay9nQv4gaTj7wl1qOD2HMQqExiag/132","nickname":"itrickzhang","note":"","ucode":"D6A9B141C944DF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":63587,"discussion_content":"考虑多协议的情况下还是有意义的，rest和rpc的实现不一样，接口一样","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574897651,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1025250,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a4/e2/abb7bfe3.jpg","nickname":"子杰","note":"","ucode":"717D10394391BE","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343760,"discussion_content":"典型的欠缺了接口概要设计过程，才会有这个问题，先定义Controller层与Service层接口，定义请求出参入参结构，配置好参数验证规则，Review评审设计，再更新接口到API文档中心，然后开始写具体实现，过程中的变更API是需要前后端沟通修改契约的，除非前后端相互阻塞式开发，或者接口文档输出在纸面上，需要二次手动转换成代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611150037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1438860,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f4/8c/0866b228.jpg","nickname":"子房","note":"","ucode":"CB05938C248BB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335866,"discussion_content":"主要是为了,  先定义行为吧, 毕竟实现一块写的比较慢. ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608359919,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1261636,"avatar":"https://static001.geekbang.org/account/avatar/00/13/40/44/0d0dc06c.jpg","nickname":"okeyja","note":"","ucode":"D83D78C6ACFEBC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332078,"discussion_content":"将@Service抽换到不同的Impl里面，比如interface Upload 下面有 AliyunUploadImpl，新实现的 AwsUploadImpl 支持去访问AWS的存储，只需要把@Service 注解从前者抽换到后者即可，Spring 自动就注入了 AWS 的实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607056836,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1144132,"avatar":"https://static001.geekbang.org/account/avatar/00/11/75/44/ee170215.jpg","nickname":"Jasper","note":"","ucode":"7AEF50986C7D8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301639,"discussion_content":"主要是分层开发，有人负责controller，有人负责service，这样就需要一个中间接口了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598594955,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1274117,"avatar":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","nickname":"👽","note":"","ucode":"D313AF941B412D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1144132,"avatar":"https://static001.geekbang.org/account/avatar/00/11/75/44/ee170215.jpg","nickname":"Jasper","note":"","ucode":"7AEF50986C7D8C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302667,"discussion_content":"你们公司 服务和控制层 是不同的人开发的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599005685,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301639,"ip_address":""},"score":302667,"extra":""},{"author":{"id":1274117,"avatar":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","nickname":"👽","note":"","ucode":"D313AF941B412D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1144132,"avatar":"https://static001.geekbang.org/account/avatar/00/11/75/44/ee170215.jpg","nickname":"Jasper","note":"","ucode":"7AEF50986C7D8C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302668,"discussion_content":"你们公司 服务和控制层 是不同的人开发的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599005686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301639,"ip_address":""},"score":302668,"extra":""},{"author":{"id":1144132,"avatar":"https://static001.geekbang.org/account/avatar/00/11/75/44/ee170215.jpg","nickname":"Jasper","note":"","ucode":"7AEF50986C7D8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1274117,"avatar":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","nickname":"👽","note":"","ucode":"D313AF941B412D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302724,"discussion_content":"嗯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599014504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":302668,"ip_address":""},"score":302724,"extra":""}]},{"author":{"id":1493907,"avatar":"https://static001.geekbang.org/account/avatar/00/16/cb/93/4adea49a.jpg","nickname":"努力努力再努力","note":"","ucode":"0C6EEA28FCE8C7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300835,"discussion_content":"不写接口 spring 无法注入的吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598278881,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1268264,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5a/28/732d3f2f.jpg","nickname":"GEEKBANG_6638780","note":"","ucode":"952194E56FD8C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1493907,"avatar":"https://static001.geekbang.org/account/avatar/00/16/cb/93/4adea49a.jpg","nickname":"努力努力再努力","note":"","ucode":"0C6EEA28FCE8C7","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":382746,"discussion_content":"看来被接口毒害太多了。 byType，type不一定是接口。 只是注入了CGLIB子类","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625711022,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":300835,"ip_address":""},"score":382746,"extra":""}]},{"author":{"id":1125104,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2a/f0/41590e10.jpg","nickname":"Citizen Z","note":"","ucode":"9CA547640A8629","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":130498,"discussion_content":"可能是为了防止新手不动脑子一顿面向实现编程而引入的机械性实践吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578757273,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1101929,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d0/69/5dbdc245.jpg","nickname":"张德","note":"","ucode":"31FE63E8725EFC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":68950,"discussion_content":"哈哈  我也是这么认为的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575247557,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154054,"user_name":"YouCompleteMe","can_delete":false,"product_type":"c1","uid":1232859,"ip_address":"","ucode":"89B5A75DA85E0A","user_header":"https://static001.geekbang.org/account/avatar/00/12/cf/db/9693d08f.jpg","comment_is_top":false,"comment_ctime":1574358648,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31639129720","product_id":100039001,"comment_content":"抽象工厂，把创建具体类型放到工厂类里","like_count":7},{"had_liked":false,"id":166766,"user_name":"ちよくん","can_delete":false,"product_type":"c1","uid":1398577,"ip_address":"","ucode":"B71E9B16E4408F","user_header":"https://static001.geekbang.org/account/avatar/00/15/57/31/6772744d.jpg","comment_is_top":false,"comment_ctime":1577589966,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"23052426446","product_id":100039001,"comment_content":"老师，我在看的过程就发现了你在课堂讨论的问题，本来想在评论中提出，老师在结尾自己提出来了，关于这个问题我的建议是再抽出来一层manager接口或者类均可，manager 实现类调用上传下载接口，外部统一调用manager 接口，外部不会因为manager 实现类的具体调用那个接口而改变任何代码，即可解决上面的问题。","like_count":5,"discussions":[{"author":{"id":2100090,"avatar":"https://static001.geekbang.org/account/avatar/00/20/0b/7a/9ce7dc7d.jpg","nickname":"东瓜酱","note":"","ucode":"B1FEADF98DE292","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297844,"discussion_content":"我也是这么想的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597070905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154133,"user_name":"bearlu","can_delete":false,"product_type":"c1","uid":1030862,"ip_address":"","ucode":"14F260C8B24E27","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/ce/fd45714f.jpg","comment_is_top":false,"comment_ctime":1574383978,"is_pvip":true,"replies":[{"id":"59171","content":"👌 我抽空整理一下放上去<br>https:&#47;&#47;github.com&#47;wangzheng0822","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1574385313,"ip_address":"","comment_id":154133,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23049220458","product_id":100039001,"comment_content":"老师，希望能把示例代码和问题代码也放到Github上。","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475384,"discussion_content":"👌 我抽空整理一下放上去\nhttps://github.com/wangzheng0822","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574385313,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1030862,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ba/ce/fd45714f.jpg","nickname":"bearlu","note":"","ucode":"14F260C8B24E27","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55603,"discussion_content":"谢谢，那样其他同学也可以用自己熟悉的语言实现一次并且上传到该库。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574385628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154085,"user_name":"水银","can_delete":false,"product_type":"c1","uid":1045948,"ip_address":"","ucode":"0FD9C79590E484","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/bc/63be02b6.jpg","comment_is_top":false,"comment_ctime":1574380290,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23049216770","product_id":100039001,"comment_content":"我是搞Java的，关于思考题，个人感觉主要依靠控制反转，即把对象的构造权交给容器，而非代码中直接写死。像Spring那种依赖注入的方式就可以，或者不使用Spring，可以把具体的实现类全路径名配置到配置文件中，代码中以Class.forName的方式得到Class，然后再用Class的newInstance方法得到实例并缓存起来以便后面使用避免重复构造实例。以后替换实现的时候只需要替换配置文件中的类全路径名即可。当然前提是这个Class需要实现统一抽象出来的接口，使用逻辑中也是","like_count":5},{"had_liked":false,"id":154075,"user_name":"NoAsk","can_delete":false,"product_type":"c1","uid":1122412,"ip_address":"","ucode":"71CA29776B4F68","user_header":"https://static001.geekbang.org/account/avatar/00/11/20/6c/e4966364.jpg","comment_is_top":false,"comment_ctime":1574378057,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23049214537","product_id":100039001,"comment_content":"关于什么时候定义接口的一些拙见：<br>当方法会有其他实现，或者不稳定的时候需要定义接口；<br>1.不稳定的方法一般能事先确定，用接口能提高可维护性<br>2.但在开发时往往不确定是否需要其他实现，我的原则是等到需要使用接口的时候再去实现。所以根据kiss原则一般我会先用方法实现，如果有一天真的需要有新的实现的时候再重新抽象出接口对代码进行小重构。<br><br>就老师的例子进行一下说明：<br>刚开始只需要阿里云进行图片上传下载功能，我就先只实现阿里云的图片上传下载方法。<br>后期发现需要有私有云的上传下载方法的话，那就对这个功能通过接口进行抽象。但是你永远不知道到底是新的图片上传下载功能先来到还是其他阿里接口先来到，如果是新的阿里接口，也是用的这一套token方法，那就用抽象方法或接口对token部分实现抽象。<br><br>课后问题：<br>简单工厂，工厂模式可以提高可扩展性，维护性。<br>java spring项目可以使用注入的方式。","like_count":5},{"had_liked":false,"id":154058,"user_name":"秋惊蛰","can_delete":false,"product_type":"c1","uid":1620344,"ip_address":"","ucode":"3D9A6D5CA9C79F","user_header":"https://static001.geekbang.org/account/avatar/00/18/b9/78/a5804dae.jpg","comment_is_top":false,"comment_ctime":1574361146,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"18754230330","product_id":100039001,"comment_content":"这一节解决了一些疑惑，但是还有三个问题想问一下：<br>1. 看到有些Spring Boot的代码，会给每个业务逻辑分别定义一个service接口，并用一个类来实现这个接口，然后在controller里像第8行那样调用。<br>这种是不是就过度使用接口了，还是说有必要考虑每个业务逻辑可能的实现方式。<br>2. 能不能具体的说一下哪些典型场景适合用接口抽象，比如输入输出，这两个地方肯定不止一种方式，用接口很有必要，还有其他场景吗？<br>3. Python这种动态语言怎么做到面向抽象编程？","like_count":4,"discussions":[{"author":{"id":1602420,"avatar":"https://static001.geekbang.org/account/avatar/00/18/73/74/3bf4b74e.jpg","nickname":"阿德","note":"","ucode":"186D5E19E3CB6E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60595,"discussion_content":"我也有相同的疑问，就是service层定义一个serviceimpl类，为什么还需要有接口service","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574739617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2124158,"avatar":"https://static001.geekbang.org/account/avatar/00/20/69/7e/6b94f44b.jpg","nickname":"逐梦","note":"","ucode":"682702AA87AAE7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382929,"discussion_content":"同感，本身引入引口估计是为了多实现时方便控制反转。但实际开发中感觉，大多数情况下接口都是多余的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625795206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134761,"avatar":"https://static001.geekbang.org/account/avatar/00/11/50/a9/3f8c7418.jpg","nickname":"冰糕不冰","note":"","ucode":"B754FE464BA426","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62004,"discussion_content":"现在golang 的很多项目也是用的java这一套。再mvc的基础上再抽象一个逻辑层，然后定义service接口，而有的又只是定义类。个人确实不知道哪种方式更好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574812740,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1123103,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/1f/6452b2e8.jpg","nickname":"刘清斌","note":"","ucode":"775B053AF87B53","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56538,"discussion_content":"python的duck coding编程方式可以实现面向接口编程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574495762,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1349528,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoViaN0hP07cXOl7vOIvHPu7DZ3wxHBz4iaLVEqG1TFfiagm1wUaiczbCyicwib7oDWw0vD4cXg9eZ0Okqg/132","nickname":"李湘河","note":"","ucode":"DB078B5DAAE82E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55491,"discussion_content":"你说的是mvc开发范式里面的吧，我觉得这样是和每个业务模块对应，为了更好的协同开发和后期维护，如果不这样，当一个项目被另外一个人接手，要想看代码逻辑得多费力，还有就是后期维护bug排查也容易些，个人见解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574381873,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1620344,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b9/78/a5804dae.jpg","nickname":"秋惊蛰","note":"","ucode":"3D9A6D5CA9C79F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1349528,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoViaN0hP07cXOl7vOIvHPu7DZ3wxHBz4iaLVEqG1TFfiagm1wUaiczbCyicwib7oDWw0vD4cXg9eZ0Okqg/132","nickname":"李湘河","note":"","ucode":"DB078B5DAAE82E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":59207,"discussion_content":"业务逻辑实现是要分开的，就是说能不能去掉接口呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574684938,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":55491,"ip_address":""},"score":59207,"extra":""},{"author":{"id":2347137,"avatar":"https://static001.geekbang.org/account/avatar/00/23/d0/81/d5c8e46e.jpg","nickname":"snake","note":"","ucode":"47BFFE4D048156","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1349528,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoViaN0hP07cXOl7vOIvHPu7DZ3wxHBz4iaLVEqG1TFfiagm1wUaiczbCyicwib7oDWw0vD4cXg9eZ0Okqg/132","nickname":"李湘河","note":"","ucode":"DB078B5DAAE82E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331219,"discussion_content":"这点同意","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606810119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":55491,"ip_address":""},"score":331219,"extra":""}]},{"author":{"id":1577856,"avatar":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","nickname":"L🚲🐱","note":"","ucode":"08A012739614DE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55451,"discussion_content":"sprigboot 接口注入么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574380173,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175712,"user_name":"batman","can_delete":false,"product_type":"c1","uid":1266482,"ip_address":"","ucode":"73C30ACFC0D612","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/IIkdC2gohpcibib0AJvSdnJQefAuQYGlLySQOticThpF7Ck9WuDUQLJlgZ7ic13LIFnGBXXbMsSP3nZsbibBN98ZjGA/132","comment_is_top":false,"comment_ctime":1580805428,"is_pvip":true,"discussion_count":1,"race_medal":1,"score":"14465707316","product_id":100039001,"comment_content":"简单点可以通过工厂模式；<br>复杂点可以通过JDK 标准的 SPI (Service Provider Interface) 扩展点发现机制;","like_count":3,"discussions":[{"author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383819,"discussion_content":"反正就是 从代码中抽取 创建类的 标识字符串;然后再由一个顶层容器保存着;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626247187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157997,"user_name":"plasmatium","can_delete":false,"product_type":"c1","uid":1356120,"ip_address":"","ucode":"1564F6A20186AE","user_header":"https://static001.geekbang.org/account/avatar/00/14/b1/58/7d4f968f.jpg","comment_is_top":false,"comment_ctime":1575295903,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14460197791","product_id":100039001,"comment_content":"如果用golang实现的话，可以非常优雅简洁。实现io.Writer和io.Reader接口即可。以下举例Writer接口<br>比如把各种字符串定义并取名为一种bucket类型（本质还是字符串，不增加任何动态汇编代码）：<br>type AliyunBucket string<br>type PrivateBucket string 等等。。。<br>然后实现各自的Write方法，其中包括token的获取等等各自关心的事情，然后可以这样用：<br>var bucket AliyunBucket = &quot;&#47;path&#47;to&#47;save&#47;on&#47;bucket.png&quot;<br>var bucket2 PrivateBucket = &quot;C:\\我的图片\\x.jpg&quot;<br>var bucket3 MyAwesomeBucket = &quot;http:&#47;&#47;192.168.1.234&#47;picture&#47;y.jpg&quot;<br>bucket.Write(imageBytes)<br>bucket2.Write(imageBytes)<br>bucket3.Write(imageBytes)<br>-------------------<br>实际上我们可以更灵活一些，某天你突然有了另一个bucket，并且需要支持转base64或者压缩支持，那都不是事儿，我可能会这么写：<br>type DataSaver interface {<br>      Save(io.Writer)<br>}<br>type imgData []byte<br>然后可以在imgData上实现这个DataSaver接口，然后这样调用：<br>var AliyunBucket = &quot;&#47;path&#47;to&#47;save&#47;on&#47;aliyun&#47;bucket.png&quot;<br>var filePath LocalFilePathBucket = &quot;C:\\Path\\to\\img.jpg&quot;<br>combinedWriter := base64.NewEncoder(base64.StdEncoding, AliyunBucket)<br>combinedWriter2 := someOtherEncoder.New(someParams, filePath)<br>combinedWriter3 := imgFilpEncoder.New(someParams, MyAwesomeBucket) &#47;&#47; 翻转图像后上传<br><br>img imgData := someImg<br>img.save(combineWriter) &#47;&#47; 以base64存阿里云<br>img.save(combineWriter2) &#47;&#47; 存本地<br>img.save(combineWriter3) &#47;&#47; 翻转后存私有云<br><br>同理，任何实现了DataSaver接口的东西（可能是一个结构体，一个byte数组，一个int，一个string等），都可以上传下载到任何地方（各种bucket，磁盘，网络，内存，只要实现了io.Writer和io.Reader）<br>-----------<br>另外考虑到只要实现io.Writer方法的都可以从这个接口得到好处，比如http.ResponseWriter，<br>那么就是用在服务器响应别人的请求的需求上了。<br><br>考虑到上传下载的本质，我们最终是要实现如何将一坨字节以某种方式搬运到另一处：将imgBytes从内存A，通过base64的encode方式搬运到内存B，然后应用某些参数来搬运到网卡C或者磁盘D，在golang里用装饰器模式实现起来比较好弄，上述例子中base64就是这样做的。<br><br>另外可以看到duck-type非常灵活，而且作为静态语言，编译器已经帮你把关了，你不可能遇到python或者js里的运行时错误","like_count":3},{"had_liked":false,"id":154337,"user_name":"Milittle","can_delete":false,"product_type":"c1","uid":1045455,"ip_address":"","ucode":"80E566639A8ABB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f3/cf/851dab01.jpg","comment_is_top":false,"comment_ctime":1574411091,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"14459312979","product_id":100039001,"comment_content":"读完这节课以后，有如下敢想，也可以用在以后编写程序的过程中：<br>1. 基于接口编程，我们首先需要明确我们要做什么，然后去定义接口，具体怎么做，我们封装在具体实现类中进行实现，这就是上层代码基于接口实现功能，底层基于具体类实现编程，做到不暴露任何实现细节给上层代码。<br>2. 基于抽象编程，我的理解是，我们再不断明确具体实现类要做的事情中，抽象出公共的代码，放在抽象类中进行共用，然后具体不同的实现我们还是可以确保在实现类中进行实现。<br>3. 这两者都可以在编程过程中实现基于接口而非实现编程。这样上层代码就不太需要在修改功能的时候，做大量的代码修改。<br>课堂讨论：<br>在C++中，我们让这种调用使用方式通过工厂模式来进行封装，到后来如果具体实现发生了改变，我们只需要扩展一个具体实现类，然后就可以做到开闭原则，对扩展开放，对封装关闭的原则。这样我们只需要在调用的时候，传入不同的参数，来构建不同的工厂实现类对象，最后调用该工厂实现类的具体实现来达到功能的迁移。（我的回到可能有点乱，不知道有人看得懂不，没看懂的 我们可以交流），最后感谢王争师兄给我这么好的学习机会 让自己的零散知识重新做一个总结，很实惠~谢谢","like_count":3},{"had_liked":false,"id":154059,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1574369752,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14459271640","product_id":100039001,"comment_content":"基于抽象而非具体体现了信息隐藏和分离代码中稳定性不同的部分。在一个上传图片的部分不需要知道图片是如何上传的，阿里云以及token就属于过多的信息，有必要隐藏这些信息。另外一方面上传图片这件事比阿里云实现要稳定的多，不上传图片的概率低于不用阿里云上传图片的概率。这里有必要分离图片上传这个接口和用阿里云上传这个实现。<br>不过原来的实现也没什么问题，毕竟谁也不能未卜先知，将来一定会替换阿里云。如果我拿到这个变更需求，我会先用同名接口替换原来的实现（原来的阿里类实现清晰，功能单一，只是不适合直接调用），然后用adapter来转接口，然后一步一步实现接口和实现的分离，目标是接口能够隐藏信息，实现能够清晰明了，每一步都能用IDE工具重构，每一步都能编译和测试。","like_count":3},{"had_liked":false,"id":165940,"user_name":"Kaybee","can_delete":false,"product_type":"c1","uid":1106900,"ip_address":"","ucode":"B94E578F12A365","user_header":"https://static001.geekbang.org/account/avatar/00/10/e3/d4/22d48e2a.jpg","comment_is_top":false,"comment_ctime":1577347131,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10167281723","product_id":100039001,"comment_content":"思考题：ImageProcessingJob 构造函数声明ImageStore接口为参数，实际运行时传入实现类实例","like_count":2},{"had_liked":false,"id":289255,"user_name":"Aibo","can_delete":false,"product_type":"c1","uid":2115387,"ip_address":"","ucode":"2CE3E77BD2D014","user_header":"https://static001.geekbang.org/account/avatar/00/20/47/3b/70198ceb.jpg","comment_is_top":false,"comment_ctime":1618939050,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5913906346","product_id":100039001,"comment_content":"需要解决的问题是多处修改的问题，方案如下<br>1.简单工厂+配置文件。      只需修改配置文件<br>2.依赖注入","like_count":1,"discussions":[{"author":{"id":2115387,"avatar":"https://static001.geekbang.org/account/avatar/00/20/47/3b/70198ceb.jpg","nickname":"Aibo","note":"","ucode":"2CE3E77BD2D014","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369145,"discussion_content":"依赖注入还有一个好处，上层依赖下层的抽象，方便测试mock。可以让业务逻辑层依赖于数据处理层，实现loc","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618939509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":265870,"user_name":"okeyja","can_delete":false,"product_type":"c1","uid":1261636,"ip_address":"","ucode":"D83D78C6ACFEBC","user_header":"https://static001.geekbang.org/account/avatar/00/13/40/44/0d0dc06c.jpg","comment_is_top":false,"comment_ctime":1607056627,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5902023923","product_id":100039001,"comment_content":"工厂方法，把需要用的具体哪一个类放到工厂里。Spring里面，替换Servic-Layer interface的@Service注解到不同的Impl类。","like_count":1},{"had_liked":false,"id":263441,"user_name":"大智","can_delete":false,"product_type":"c1","uid":1718373,"ip_address":"","ucode":"5FD45545611252","user_header":"https://static001.geekbang.org/account/avatar/00/1a/38/65/ad8c46bd.jpg","comment_is_top":false,"comment_ctime":1606134709,"is_pvip":true,"replies":[{"id":"96097","content":"嗯嗯","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606700767,"ip_address":"","comment_id":263441,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5901102005","product_id":100039001,"comment_content":"思考题的话，结合spring的话我觉得应该是初始化一个存储处理类并在使用类中@Autowired即可。初始化哪个类取决于你给哪个存储类进行了初始化","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510193,"discussion_content":"嗯嗯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217390,"user_name":"anders","can_delete":false,"product_type":"c1","uid":1153592,"ip_address":"","ucode":"610C80D742C331","user_header":"https://static001.geekbang.org/account/avatar/00/11/9a/38/118a890c.jpg","comment_is_top":false,"comment_ctime":1589474274,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5884441570","product_id":100039001,"comment_content":"为什么基于接口实现？<br><br>觉得作者这章直接命中核心的点是:<br>- 封装不确定性内容，暴露稳定的接口<br>- 与其说基于接口，不如更加通俗的基于协议，约定<br><br>编程效率本质上，是要应对需求的不确定性，应对变化中，更小成本的开发演进。<br><br>如何更小成本的开发？那当然是牵扯代码越少，效率越高。<br><br>如本章例子，只需要基于接口再实现一个类，并替换掉就好，这样做的好处除了改动少， QA 测试的范围少之外，还有就是测试好写（只需要测试新类即可），开发者心智负担也少（头发终于能保住了😂）<br><br>另外提到基于协议实现，让我想到了 vscode 的 Language Service Protocal 的流行，纷纷被 vim，emacs 支持，也是这个原因。语言插件基于 LSP 实现的话，就非常容易在各个编辑器中适配迁移，极大的降低了成本。","like_count":1},{"had_liked":false,"id":214506,"user_name":"大圣代","can_delete":false,"product_type":"c1","uid":1003080,"ip_address":"","ucode":"8A59114C8345C8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/48/bb0136d1.jpg","comment_is_top":false,"comment_ctime":1588759413,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5883726709","product_id":100039001,"comment_content":"基于接口编程体现的还是开闭原则：<br>1. 使用接口屏蔽了上层对于下次不稳定的感知，体现了对老代码修改关闭的原则提高了稳定性。<br>2. 使用接口完成多态降低了对单一实现的依赖，体现了对拓展开放的原则，降低了耦合，提升了拓展性。<br>3. 1 + 2 -&gt; 接口可以随意拓展，老代码根本感知不到这个变化，不会造成破坏，还拓展了功能，提高了项目的弹性。<br><br><br>什么时候使用面向接口编程：<br>1. 对于简单、短期内不可能有多重实现方式的场景，没必要做面向接口编程。<br>2. 对于越是不稳定，逻辑越复杂，越应该为期提高拓展性，使用面向接口编程。<br>这个问题完全是对个人经验和逻辑判断的考验","like_count":1},{"had_liked":false,"id":192178,"user_name":"Nick","can_delete":false,"product_type":"c1","uid":1921287,"ip_address":"","ucode":"64BBE005890845","user_header":"https://static001.geekbang.org/account/avatar/00/1d/51/07/b5a945b6.jpg","comment_is_top":false,"comment_ctime":1584842001,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879809297","product_id":100039001,"comment_content":"建议老师可以增加定期回答问题的文章，这一点可以学习得到专栏的老师","like_count":1},{"had_liked":false,"id":155173,"user_name":"帆大肚子","can_delete":false,"product_type":"c1","uid":1529040,"ip_address":"","ucode":"3DB11DB2FA1802","user_header":"https://static001.geekbang.org/account/avatar/00/17/54/d0/4e1fc664.jpg","comment_is_top":false,"comment_ctime":1574656549,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869623845","product_id":100039001,"comment_content":"直接工厂模式， 做什么事情都要有个度， 我很期待工厂模式的度是什么","like_count":1},{"had_liked":false,"id":154860,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1574582634,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869549930","product_id":100039001,"comment_content":"1.如果需求是，要么使用阿里云存储要么使用七牛云存储，这样非此即彼的方式。那么写死，然后基于功能开关发布。顺利发布后，在下个版本，将功能开关和老的阿里云存储代码干掉便是。<br>2.如果需求是，同时存在使用阿里云和七牛云的存储诉求，这种两者兼备的方式。那么通过工厂模式，依赖入参选择对应的实现模板，分别获得实现类即可。这里需要在入参上，为实现类型打上标记，以便运行时动态选择。","like_count":1},{"had_liked":false,"id":154831,"user_name":"指尖流逝","can_delete":false,"product_type":"c1","uid":1005381,"ip_address":"","ucode":"417009F674FAF1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/45/c418ea5c.jpg","comment_is_top":false,"comment_ctime":1574576951,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869544247","product_id":100039001,"comment_content":"第八行可以使用工厂类来创建接口实现类，把实例化接口实现的代码收拢到一个位置。避免项目代码中这一类的实例化满天飞","like_count":1},{"had_liked":false,"id":154371,"user_name":"木木","can_delete":false,"product_type":"c1","uid":1181486,"ip_address":"","ucode":"E82C58AF2604ED","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/2e/878d3c92.jpg","comment_is_top":false,"comment_ctime":1574416089,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5869383385","product_id":100039001,"comment_content":"看的我热血沸腾，马上重构以前的代码","like_count":1,"discussions":[{"author":{"id":1564002,"avatar":"https://static001.geekbang.org/account/avatar/00/17/dd/62/824e5e16.jpg","nickname":"沁塵","note":"","ucode":"4AD780EF50882B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":180926,"discussion_content":"打开IDE，双击源文件，卧槽，关机。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582306137,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154192,"user_name":"彦祖","can_delete":false,"product_type":"c1","uid":1235159,"ip_address":"","ucode":"784CBB0C8BFD47","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/d7/21cc617d.jpg","comment_is_top":false,"comment_ctime":1574389814,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869357110","product_id":100039001,"comment_content":"SPI","like_count":1},{"had_liked":false,"id":154155,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1574385599,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869352895","product_id":100039001,"comment_content":"设计模式解决","like_count":1},{"had_liked":false,"id":154096,"user_name":"黄林晴","can_delete":false,"product_type":"c1","uid":1362631,"ip_address":"","ucode":"B15C38AECDA88F","user_header":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","comment_is_top":false,"comment_ctime":1574381282,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869348578","product_id":100039001,"comment_content":"打卡✔","like_count":1},{"had_liked":false,"id":360821,"user_name":"H·H","can_delete":false,"product_type":"c1","uid":2108194,"ip_address":"上海","ucode":"113E95BA6B6F51","user_header":"https://static001.geekbang.org/account/avatar/00/20/2b/22/79d183db.jpg","comment_is_top":false,"comment_ctime":1666875946,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1666875946","product_id":100039001,"comment_content":"如果后面不止存储图片还需要存视频音频，例子还是不好扩展","like_count":0},{"had_liked":false,"id":357723,"user_name":"CL","can_delete":false,"product_type":"c1","uid":2894752,"ip_address":"贵州","ucode":"9CDF27EFE870AD","user_header":"https://static001.geekbang.org/account/avatar/00/2c/2b/a0/d1185ac6.jpg","comment_is_top":false,"comment_ctime":1663579965,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663579965","product_id":100039001,"comment_content":"牛","like_count":0},{"had_liked":false,"id":356370,"user_name":"Sherk","can_delete":false,"product_type":"c1","uid":2156245,"ip_address":"重庆","ucode":"AFE3E7F158258D","user_header":"https://static001.geekbang.org/account/avatar/00/20/e6/d5/4f1fc074.jpg","comment_is_top":false,"comment_ctime":1662204806,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662204806","product_id":100039001,"comment_content":"思考题： 通过工厂方法，通过传入一个存储类型，来返回具体的存储方式。、<br><br>本节主要讲了什么：如何使用接口。<br><br>   why：<br>    编程的方式应该是面向接口而不是具体实现。因为业务可能是多变的。软件开发时，需求是不断变化的，代码设计时越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。<br><br>   how <br>       1.接口名称应该抽象，不应该和具体实现挂钩。<br>       2. 写接口之前，梳理场景，哪些是可变的，哪些不可变。将不可变的部分抽象出来，可以理解为定义协议，未来的变化的东西都从按协议定义的框架实现自己的细节。比如客户端与服务端的接口设计，定义好协议，具体怎么实现各个客户端可以自己实现。<br>       3.防止过度使用接口。业务如果不会怎么变化就不要使用接口。<br>  <br><br>  <br>  <br><br>      ","like_count":0},{"had_liked":false,"id":356148,"user_name":"Stay_Gold","can_delete":false,"product_type":"c1","uid":1119904,"ip_address":"北京","ucode":"ACB8DCD2EF8F95","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJRCtuJkpyy2NTTABPFibg2k9tZscOOKx9wu80a85d5HspCorO9Nibj7Z7q9v1icPTVm5ia52r0RCzEaA/132","comment_is_top":false,"comment_ctime":1662012847,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662012847","product_id":100039001,"comment_content":"这样的设计还是不够完美，对此，你有更好的实现思路吗？<br>只能想到IOC的方式。<br>ImageStore imageStore = new PrivateImageStore(&#47;*省略构造函数*&#47;);<br>替换成<br>ImageStore imageStore = new ImageStore(传入具体要生成的对象);","like_count":0},{"had_liked":false,"id":352724,"user_name":"Asser","can_delete":false,"product_type":"c1","uid":1583575,"ip_address":"","ucode":"9A76AB911C8051","user_header":"https://static001.geekbang.org/account/avatar/00/18/29/d7/b2bcc28c.jpg","comment_is_top":false,"comment_ctime":1658899201,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658899201","product_id":100039001,"comment_content":"个人不是很熟悉java的语法，不过针对课程提出的问题，个人认为可以使用依赖注入的模式，将依赖的实例对象通过参数的方式传入","like_count":0},{"had_liked":false,"id":351035,"user_name":"SICUN","can_delete":false,"product_type":"c1","uid":1254261,"ip_address":"","ucode":"22A384904EB9E9","user_header":"https://static001.geekbang.org/account/avatar/00/13/23/75/2b599841.jpg","comment_is_top":false,"comment_ctime":1657470510,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657470510","product_id":100039001,"comment_content":"在laravel框架中可以编写图片服务提供者ImageServiceProvider,接口与实现类与文档中保持一致，然后将图片服务提供者与aliyun上传实现类做绑定，调用时使用依赖注入图片上传对象，更换为私有云上传时，则修改服务提供者的绑定为私有云图片实现类即可。","like_count":0},{"had_liked":false,"id":347227,"user_name":"邓嘉文","can_delete":false,"product_type":"c1","uid":2332845,"ip_address":"","ucode":"FCEDFABFB48055","user_header":"https://static001.geekbang.org/account/avatar/00/23/98/ad/f9d755f2.jpg","comment_is_top":false,"comment_ctime":1653830016,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653830016","product_id":100039001,"comment_content":"思考题: 配置文件+工厂模式","like_count":0},{"had_liked":false,"id":345170,"user_name":"杜威","can_delete":false,"product_type":"c1","uid":1294908,"ip_address":"","ucode":"CF49380E27467F","user_header":"https://static001.geekbang.org/account/avatar/00/13/c2/3c/a82d4ed0.jpg","comment_is_top":false,"comment_ctime":1652089153,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652089153","product_id":100039001,"comment_content":"面向接口编程能带来的好处是多态，关注点分离，让客户端只关注需要关注的方法。","like_count":0},{"had_liked":false,"id":343968,"user_name":"seven#羊啾啾JK","can_delete":false,"product_type":"c1","uid":2160692,"ip_address":"","ucode":"B3F1BF6F2F08B2","user_header":"https://static001.geekbang.org/account/avatar/00/20/f8/34/1c260560.jpg","comment_is_top":false,"comment_ctime":1651148935,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651148935","product_id":100039001,"comment_content":"使用抽象类来实现","like_count":0},{"had_liked":false,"id":342550,"user_name":"Geek_as","can_delete":false,"product_type":"c1","uid":1534500,"ip_address":"","ucode":"AB7B70DBC2B5F8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/qhonwcQle1RBufvLdTm4MgSNl554GBXUZtNNH65oYajbbRLxKsZX4hM9vFtrLLpDM0H93ZNWRFAZSrIZC7yAsQ/132","comment_is_top":false,"comment_ctime":1650337162,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650337162","product_id":100039001,"comment_content":"设置配置参数，使用工厂模式创建该类，在创建的时候通过传入配置参数，工厂模式根据配置动态决定创建对应的类","like_count":0},{"had_liked":false,"id":339334,"user_name":"Geek_783504","can_delete":false,"product_type":"c1","uid":2743789,"ip_address":"","ucode":"549D3F0549743C","user_header":"https://static001.geekbang.org/account/avatar/00/29/dd/ed/f6c5432b.jpg","comment_is_top":false,"comment_ctime":1648039272,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1648039272","product_id":100039001,"comment_content":"可以使用工厂模式和策略模式进行简化处理","like_count":0},{"had_liked":false,"id":336016,"user_name":"面朝大海春暖花开","can_delete":false,"product_type":"c1","uid":1197581,"ip_address":"","ucode":"7F5269EA6027D1","user_header":"https://static001.geekbang.org/account/avatar/00/12/46/0d/d995cb3b.jpg","comment_is_top":false,"comment_ctime":1645847416,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645847416","product_id":100039001,"comment_content":"注册树","like_count":0},{"had_liked":false,"id":335383,"user_name":"顺势而为","can_delete":false,"product_type":"c1","uid":2757858,"ip_address":"","ucode":"FE7D688D24823E","user_header":"https://static001.geekbang.org/account/avatar/00/2a/14/e2/f6f1627c.jpg","comment_is_top":false,"comment_ctime":1645498366,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645498366","product_id":100039001,"comment_content":"1.刚刚去看typescript的东西，关于面向对象的过程还是相对薄弱，因为interface的定义往往只有参数定义，没有方法定义。也很少像springboot那样，能定义一个接口，然后implement实现接口。<br>2.设计的时候，需要考虑命名的通用性是必须的，毕竟要为以后拓展。<br>3.楼下有句话很值得学习，不应该attackBagdad(),而是应该 attack(city)","like_count":0},{"had_liked":false,"id":335348,"user_name":"roie","can_delete":false,"product_type":"c1","uid":1371983,"ip_address":"","ucode":"0CC9598364820A","user_header":"https://static001.geekbang.org/account/avatar/00/14/ef/4f/8b7e1f1e.jpg","comment_is_top":false,"comment_ctime":1645460201,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645460201","product_id":100039001,"comment_content":"可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。老师这句话没太理解？就那imagestore例子，封装不稳定的实现，是封装upload和download这两个行为吗？暴露稳定的接口，不明白怎么理解？","like_count":0},{"had_liked":false,"id":327211,"user_name":"小苗晓雪","can_delete":false,"product_type":"c1","uid":1334583,"ip_address":"","ucode":"B15FDF455853D2","user_header":"https://static001.geekbang.org/account/avatar/00/14/5d/37/061e7fac.jpg","comment_is_top":false,"comment_ctime":1639985022,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1639985022","product_id":100039001,"comment_content":"思考题我一开始就有疑问 , 就应该不用接口 , 就用抽象类 , 本身他们都是图片云存储的需求 , 我就创建一个图片云存储的抽象类 , 让阿里云和私有云都继承我这个抽象类 , 我再写一些公有的通用的实现方法 , 特殊的私有的实现方法用抽象方法的形式体现 , 比如 upload 和 download 两个方法 , 让两个子类自己去实现这两个抽象方法 , 这样不管多少种图片云存储需求我都可以满足 , 我只需要用工厂方法 让云存储的指针指向真正的具体的子类的实现即可 , 这样的代码就更通用了~","like_count":0},{"had_liked":false,"id":327122,"user_name":"idiot","can_delete":false,"product_type":"c1","uid":2526391,"ip_address":"","ucode":"D7A6E980B530B4","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/fcftgBsticCicEEkuzB0GTkHIocX62YVTSvnhR1c94sccj42lVaYXrmcZyhzUI3l9NcvuN1rXLhXt2eBrZZ0Tw7A/132","comment_is_top":false,"comment_ctime":1639925168,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1639925168","product_id":100039001,"comment_content":"里面提到的修改量大的问题，感觉不是很有说服力。修改量大不一定复杂，如果只是改个函数&#47;类名，不管多少地方用了，一个replace或者refactor也能搞定了。","like_count":0},{"had_liked":false,"id":319711,"user_name":"逆风一战九","can_delete":false,"product_type":"c1","uid":2143900,"ip_address":"","ucode":"83127627F6F37C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI45zO9GOMquhD0ia1wTBSwtJ1juPcpFTSrOGicGW3jf6JclaudauHicN8OpADArQKL8zPtDicEx4aicgA/132","comment_is_top":false,"comment_ctime":1635919651,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635919651","product_id":100039001,"comment_content":"ioc通过注解的方式注入到统一的容器中，再各个类里面可以拿到引用","like_count":0},{"had_liked":false,"id":317017,"user_name":"音速起子代购","can_delete":false,"product_type":"c1","uid":2744922,"ip_address":"","ucode":"98C5A7A7D25475","user_header":"https://static001.geekbang.org/account/avatar/00/29/e2/5a/6696d429.jpg","comment_is_top":false,"comment_ctime":1634642332,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634642332","product_id":100039001,"comment_content":"使用简单工厂模式，生成一个工厂类，并设置一个方法，可以根据不同的信息生成不同的对象","like_count":0},{"had_liked":false,"id":315889,"user_name":"凉生凉忆","can_delete":false,"product_type":"c1","uid":2437375,"ip_address":"","ucode":"1F4B69F7435247","user_header":"https://static001.geekbang.org/account/avatar/00/25/30/ff/05ea390f.jpg","comment_is_top":false,"comment_ctime":1634031851,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634031851","product_id":100039001,"comment_content":"三板斧，接口多实现，每一个实现注册到一个工厂里，工厂维护一个map，可以定义一个枚举对象对应不同的实现类，将这个枚举对象作为map的key，value为具体的实现，调用方通过工厂传入一个枚举对象获得具体的接口实例即可。","like_count":0},{"had_liked":false,"id":314084,"user_name":"关耳","can_delete":false,"product_type":"c1","uid":1583598,"ip_address":"","ucode":"9036ADEB550BD4","user_header":"https://static001.geekbang.org/account/avatar/00/18/29/ee/7cc1d3d2.jpg","comment_is_top":false,"comment_ctime":1632830486,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1632830486","product_id":100039001,"comment_content":"感觉抽象类和接口应该是一个道理，都是上层设计，把要约束和定义的协议提取总结的结果。只不过抽象类可以定义方法内容和属性而已，这两个应该是一个理念吧，只不过java分了两个实现而已！<br>要说代码复用，这个跟抽象没啥关系吧","like_count":0},{"had_liked":false,"id":312344,"user_name":"Paradise","can_delete":false,"product_type":"c1","uid":1618275,"ip_address":"","ucode":"9CA103A82F5F38","user_header":"https://static001.geekbang.org/account/avatar/00/18/b1/63/68239c70.jpg","comment_is_top":false,"comment_ctime":1631761519,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631761519","product_id":100039001,"comment_content":"可以用依赖注入的方式吧～","like_count":0},{"had_liked":false,"id":309854,"user_name":"细雨轻风","can_delete":false,"product_type":"c1","uid":1193398,"ip_address":"","ucode":"504CD7DA4827EF","user_header":"https://static001.geekbang.org/account/avatar/00/12/35/b6/b574c397.jpg","comment_is_top":false,"comment_ctime":1630374879,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630374879","product_id":100039001,"comment_content":"spring框架下 ，使用基于接口的实现方式，在配置文件中添加实现类的bean名称，在调用类里使用@Qualifier(&quot;配置bean名称&quot;) 来指向具体的实现类。这样在实现改变的时候，修改配置文件中的bean名称即可","like_count":0},{"had_liked":false,"id":306672,"user_name":"易飞","can_delete":false,"product_type":"c1","uid":2630424,"ip_address":"","ucode":"32AC28754237F7","user_header":"https://static001.geekbang.org/account/avatar/00/28/23/18/4284361f.jpg","comment_is_top":false,"comment_ctime":1628666431,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628666431","product_id":100039001,"comment_content":"还没看到工厂模式，学完再回来","like_count":0},{"had_liked":false,"id":304282,"user_name":"九先生","can_delete":false,"product_type":"c1","uid":1122533,"ip_address":"","ucode":"A63A333299D485","user_header":"https://static001.geekbang.org/account/avatar/00/11/20/e5/f66d6144.jpg","comment_is_top":false,"comment_ctime":1627312864,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627312864","product_id":100039001,"comment_content":"这样的设计还是不够完美，对此，你有更好的实现思路吗？<br>答：spring依赖注入+策略模式","like_count":0},{"had_liked":false,"id":301575,"user_name":"JKwar","can_delete":false,"product_type":"c1","uid":1047466,"ip_address":"","ucode":"B733CA24D5701F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/aa/01fedf6c.jpg","comment_is_top":false,"comment_ctime":1625746662,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1625746662","product_id":100039001,"comment_content":"课堂讨论：依赖注入或者配置文件加反射","like_count":0},{"had_liked":false,"id":300493,"user_name":"小帅","can_delete":false,"product_type":"c1","uid":1239663,"ip_address":"","ucode":"4129A7E9427FFC","user_header":"https://static001.geekbang.org/account/avatar/00/12/ea/6f/09de5f65.jpg","comment_is_top":false,"comment_ctime":1625195910,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625195910","product_id":100039001,"comment_content":"思考题：用单例模式获取上传附件的工具类，在工具类当中决定使用的是哪个上传文件的具体实现，这样只要修改这个上传附件的工具类即可，不需要在各个业务地方更改，同时还可以在工具类中根据不同的环境决定使用哪个上传附件的类，比如本地用自己的文件服务器，线上环境用阿里云等","like_count":0},{"had_liked":false,"id":300109,"user_name":"Geek_f0f0bc","can_delete":false,"product_type":"c1","uid":2678074,"ip_address":"","ucode":"A754BEC95E2BC6","user_header":"https://static001.geekbang.org/account/avatar/00/28/dd/3a/92726fb6.jpg","comment_is_top":false,"comment_ctime":1625012813,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625012813","product_id":100039001,"comment_content":"最后问题应该违背 设计模式6大原则中的最少知道原则 也叫迪米特原则","like_count":0},{"had_liked":false,"id":300108,"user_name":"Geek_f0f0bc","can_delete":false,"product_type":"c1","uid":2678074,"ip_address":"","ucode":"A754BEC95E2BC6","user_header":"https://static001.geekbang.org/account/avatar/00/28/dd/3a/92726fb6.jpg","comment_is_top":false,"comment_ctime":1625012711,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625012711","product_id":100039001,"comment_content":"课后问题回复：ImageStore 作为ImageProcessingJob的属性 通过构造函数或者自动注入 进行具体实例对象的赋值","like_count":0},{"had_liked":false,"id":295835,"user_name":"I LOVE DM","can_delete":false,"product_type":"c1","uid":2006342,"ip_address":"","ucode":"6EA297D5A0E4C8","user_header":"https://static001.geekbang.org/account/avatar/00/1e/9d/46/ce8f7a26.jpg","comment_is_top":false,"comment_ctime":1622615506,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622615506","product_id":100039001,"comment_content":"配置（工厂选择算法的条件&#47;可以热部署）+策略模式（根据配置，运行时动态的获取执行对象）","like_count":0},{"had_liked":false,"id":293365,"user_name":"夜雨声烦","can_delete":false,"product_type":"c1","uid":1349749,"ip_address":"","ucode":"87D8DB1E32522A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK6mh3xlaMoGtWjmVJh2LutdLcQcPbKNjRlVru3bx8ynPhgwuGhhdzTkwEMoXbvBtgkcDSfom1kZg/132","comment_is_top":false,"comment_ctime":1621351731,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621351731","product_id":100039001,"comment_content":"没觉得重构之后的代码比之前的代码好啊。对于重构之后的代码如果需要更改为私有云的话还是要把之前调用阿里云的接口更改为私有云，要更改的地方一样多吧","like_count":0},{"had_liked":false,"id":293325,"user_name":"Jiang Zheng","can_delete":false,"product_type":"c1","uid":2362784,"ip_address":"","ucode":"B6F0BC5E5D91BF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/ribDhYiajmzh6OQ4t1IM2anh1o386xniaq4hK4QyDAB3oPfA4gj7h8RpqnSTLnztQwwTOgrJojiblpEN6GJheoQQZA/132","comment_is_top":false,"comment_ctime":1621335704,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621335704","product_id":100039001,"comment_content":"可以用配置或spi","like_count":0},{"had_liked":false,"id":292172,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1620711398,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620711398","product_id":100039001,"comment_content":"第8行代码，可以改用一个固定类来替代，该固定类用来实例化接口的实现类，固定类可以用一个静态的方法来返回，当接口中的实现类改变时，只需要要改变固定类的的实例化方法就可以了，其他引用固定类的源代码都不需要做任何改动。","like_count":0},{"had_liked":false,"id":290809,"user_name":"刘雨声","can_delete":false,"product_type":"c1","uid":1779782,"ip_address":"","ucode":"9A4A01B2E3F1C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL7LuzpjBx3skGGZUbbPaia3GibvicPSiciaozXGa8MM7Gj2TZ1wXg0y3cSsJpsAy0rHSWHIVd8boQ7BCw/132","comment_is_top":false,"comment_ctime":1619764461,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619764461","product_id":100039001,"comment_content":"ImageStoreFactory.getInstance() { new  PrivateImageStore();}<br><br>调用不用改，只改工厂实例就行了。","like_count":0},{"had_liked":false,"id":289828,"user_name":"怀斯登","can_delete":false,"product_type":"c1","uid":2365645,"ip_address":"","ucode":"14C35C572616E7","user_header":"https://static001.geekbang.org/account/avatar/00/24/18/cd/c1076045.jpg","comment_is_top":false,"comment_ctime":1619193212,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619193212","product_id":100039001,"comment_content":"可以使用策略者模式来解决具体使用什么样的图片存储方式。","like_count":0},{"had_liked":false,"id":288177,"user_name":"仧","can_delete":false,"product_type":"c1","uid":2562972,"ip_address":"","ucode":"FD5AA7D4BA206A","user_header":"https://static001.geekbang.org/account/avatar/00/27/1b/9c/a15a03a4.jpg","comment_is_top":false,"comment_ctime":1618330528,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618330528","product_id":100039001,"comment_content":"稳定的接口，不稳定的实现，用来判断是否使用接口","like_count":0},{"had_liked":false,"id":286081,"user_name":"吕成 Zero","can_delete":false,"product_type":"c1","uid":2410746,"ip_address":"","ucode":"5665769CC41329","user_header":"https://static001.geekbang.org/account/avatar/00/24/c8/fa/baf9847c.jpg","comment_is_top":false,"comment_ctime":1617152420,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617152420","product_id":100039001,"comment_content":"最后的思考题中第8行的 ImageStore imageStore 可以在 ImageProcessingJob 类中以属性的形式定义，这是一种组合的关系。","like_count":0},{"had_liked":false,"id":284300,"user_name":"。","can_delete":false,"product_type":"c1","uid":2529737,"ip_address":"","ucode":"BA28F53B20B647","user_header":"https://static001.geekbang.org/account/avatar/00/26/99/c9/6b193193.jpg","comment_is_top":false,"comment_ctime":1616154465,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616154465","product_id":100039001,"comment_content":"用模板模式，不香吗","like_count":0},{"had_liked":false,"id":283789,"user_name":"风","can_delete":false,"product_type":"c1","uid":1077538,"ip_address":"","ucode":"104638BF19B048","user_header":"https://static001.geekbang.org/account/avatar/00/10/71/22/b8c596b6.jpg","comment_is_top":false,"comment_ctime":1615936821,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615936821","product_id":100039001,"comment_content":"我们可以创建ImageStore的工厂类，在使用时指定不同的参数生产相应的ImageStore实现类；也可以使用反射，将具体实现类名作为参数配置，使用时直接使用反射构造，这样就可以在不修改代码的情况下实现不同策略之间的切换","like_count":0},{"had_liked":false,"id":282058,"user_name":"黄金果","can_delete":false,"product_type":"c1","uid":1456586,"ip_address":"","ucode":"329811FF99F4B8","user_header":"https://static001.geekbang.org/account/avatar/00/16/39/ca/cdc58834.jpg","comment_is_top":false,"comment_ctime":1615039276,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615039276","product_id":100039001,"comment_content":"对于课后的问题, 我有一种思路是否可以在ImageProcessingJob 调用的时候在封装一层, 比如叫ImageProcessing, 外界都通过 ImageProcessing调用, 需要修改的时候, 仅修改ImageProcessing内部一处即可","like_count":0},{"had_liked":false,"id":279822,"user_name":"DreamHeng","can_delete":false,"product_type":"c1","uid":1599490,"ip_address":"","ucode":"5562BFD8375138","user_header":"https://static001.geekbang.org/account/avatar/00/18/68/02/2d394d89.jpg","comment_is_top":false,"comment_ctime":1613976069,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613976069","product_id":100039001,"comment_content":"在写代码的时候，同事给过建议“不要为了复用而复用”，当时感觉挺对的，但现在感觉也不太对，在写一些工具类的时候是有些道理的，但是在写一些业务代码时，特别是需要对外暴露的服务代码，需要考虑下如何抽象出来代码模型，减少暴露代码细节","like_count":0},{"had_liked":false,"id":279191,"user_name":"星夜","can_delete":false,"product_type":"c1","uid":1128491,"ip_address":"","ucode":"3B46C09D994CEB","user_header":"https://static001.geekbang.org/account/avatar/00/11/38/2b/9db9406b.jpg","comment_is_top":false,"comment_ctime":1613650428,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613650428","product_id":100039001,"comment_content":"最常用的方式就是依赖注入了，修改注入的类型","like_count":0},{"had_liked":false,"id":278687,"user_name":"孙长平  ","can_delete":false,"product_type":"c1","uid":1216161,"ip_address":"","ucode":"412B7B3899AE6B","user_header":"","comment_is_top":false,"comment_ctime":1613201456,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613201456","product_id":100039001,"comment_content":"ImageStore imageStore 使用注入方式注入进去即可","like_count":0},{"had_liked":false,"id":278223,"user_name":"莯兮","can_delete":false,"product_type":"c1","uid":2438051,"ip_address":"","ucode":"792C49B2F9AB82","user_header":"https://static001.geekbang.org/account/avatar/00/25/33/a3/f228814d.jpg","comment_is_top":false,"comment_ctime":1612834360,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1612834360","product_id":100039001,"comment_content":"public interface ImageStore<br> { String upload(Image image, String bucketName); Image download(String url);}<br>这里为什么使用接口而不是抽象类呢？","like_count":0,"discussions":[{"author":{"id":1012815,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/74/4f/7975c7ee.jpg","nickname":"胡敏And","note":"","ucode":"8FA14B27F47F92","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374026,"discussion_content":"ImageStore类中无法抽取出各个子类都会使用的公共细节呀，抽象类侧重解决代码复用，在这个例子中没有需要复用的代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620975281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":277580,"user_name":"鲁鸣","can_delete":false,"product_type":"c1","uid":2152306,"ip_address":"","ucode":"974BA3C3E64630","user_header":"https://static001.geekbang.org/account/avatar/00/20/d7/72/cbef720d.jpg","comment_is_top":false,"comment_ctime":1612484635,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612484635","product_id":100039001,"comment_content":"最近实践中发现，如果某个类比较复杂，代码偏多，最好有接口，这样别人可以直接通过接口就可以知道类的功能","like_count":0},{"had_liked":false,"id":274294,"user_name":"funnyx","can_delete":false,"product_type":"c1","uid":1115049,"ip_address":"","ucode":"A9B8E27919AE4D","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoZqcVJzUjfu5noOW6OPAh6ibrBicibLmicibnVyVLHdf7GwAzf2th5s1oQ9pUbLpmq2mlVBauUZn8QUnw/132","comment_is_top":false,"comment_ctime":1610957277,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610957277","product_id":100039001,"comment_content":"如果只是为了这个接口的某个实现类可用与否，那可以借鉴Spring beanPostProcessor的处理，在具体的processor里来控制相应的处理是否可用，这样就可以主程序不需要修改，只有相应的组件修改","like_count":0},{"had_liked":false,"id":274280,"user_name":"刘立嘉","can_delete":false,"product_type":"c1","uid":2414637,"ip_address":"","ucode":"1241140EBE7FE3","user_header":"https://static001.geekbang.org/account/avatar/00/24/d8/2d/6ec3760c.jpg","comment_is_top":false,"comment_ctime":1610952533,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610952533","product_id":100039001,"comment_content":"使用静态工厂类","like_count":0},{"had_liked":false,"id":272066,"user_name":"会飞的蹦蹦","can_delete":false,"product_type":"c1","uid":1307168,"ip_address":"","ucode":"4A5B311F971DBE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtwfeiaW2Dwn1PQROLZAIMwCJnf95MVYicHVVzZDLYHoRLvkGr1KkgZZXdSrZaRuCiclZWELtHpmXxg/132","comment_is_top":false,"comment_ctime":1609924178,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609924178","product_id":100039001,"comment_content":"作者应该是想引出工厂模式的概念。但是我纠结的是，不管怎么改，最终如果在原有所谓aliyun的上传模式改为别的上传模式，都得去修改那一行代码吧，我觉得从这个角度出发，用不用工厂模式去抽象出来对象的创建，是不是意义也不大啊，这样是不是也有点为了模式而模式，或者说有点“过”了呢~","like_count":0},{"had_liked":false,"id":271805,"user_name":"zh","can_delete":false,"product_type":"c1","uid":1982711,"ip_address":"","ucode":"98772B1B6C6E06","user_header":"https://static001.geekbang.org/account/avatar/00/1e/40/f7/e62bbc62.jpg","comment_is_top":false,"comment_ctime":1609815950,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609815950","product_id":100039001,"comment_content":"个人觉得COM的接口和组件设计对理解面向对象、接口、基于接口编程很有帮助，接口更像一个协议、约定，基于接口编程是一种抽象思维的体现，使用者甚至完全不知道接口指向的具体类型，也就无从了解实现细节了。","like_count":0},{"had_liked":false,"id":265724,"user_name":"蓝天空的幸福","can_delete":false,"product_type":"c1","uid":2053568,"ip_address":"","ucode":"AB46C044F3B6D2","user_header":"https://static001.geekbang.org/account/avatar/00/1f/55/c0/1a7893d4.jpg","comment_is_top":false,"comment_ctime":1606994021,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606994021","product_id":100039001,"comment_content":"基于接口而非实现编程，某种程度上可以理解为 ：“关注“ 接口，”“忽略”实现类。<br>一切功能（API）以接口为准，实现类仅仅提供 为接口变量赋值的功能；我们 “只能使用” 接口提供的API，“不能使用” 实现类提供的API，即: 使用到的方法必须是 接口中定义的。","like_count":0},{"had_liked":false,"id":265191,"user_name":"snake","can_delete":false,"product_type":"c1","uid":2347137,"ip_address":"","ucode":"47BFFE4D048156","user_header":"https://static001.geekbang.org/account/avatar/00/23/d0/81/d5c8e46e.jpg","comment_is_top":false,"comment_ctime":1606809873,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606809873","product_id":100039001,"comment_content":"我想到的办法是使用spring的依赖自动注入，将接口实现纳入spring的管理范围，用的时候通过注解就可以实现自动注入","like_count":0},{"had_liked":false,"id":264528,"user_name":"刘小辉","can_delete":false,"product_type":"c1","uid":2340338,"ip_address":"","ucode":"E1D77D8B56F3A5","user_header":"https://static001.geekbang.org/account/avatar/00/23/b5/f2/58afc1d4.jpg","comment_is_top":false,"comment_ctime":1606490693,"is_pvip":true,"replies":[{"id":"96071","content":"������","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606700591,"ip_address":"","comment_id":264528,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1606490693","product_id":100039001,"comment_content":"第一：思考题我觉得可以用SPI！<br>第二：   抽象类的功能应该远远多于接口。但是定义抽象类的代价是比较高的。因为像java,C#这样的高级语言，是不允许多继承的所以，你在设计一个父类为抽象类的时候，一定得将这个类的子类所有的共同属性和方法都定义出来；但是接口可以不用这样。因为接口是一个方法的集合，一个类可以实现多个接口。所以，你的接口里面只有一个方法，还是两个方法，都是可以的。之后如果还有新的方法，我大不了再设计一个接口就是了。所以说，抽象类的设计必须谨慎，接口的设计很灵活。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510589,"discussion_content":"������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700591,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263542,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1606180721,"is_pvip":true,"replies":[{"id":"96092","content":"说的没错","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606700730,"ip_address":"","comment_id":263542,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1606180721","product_id":100039001,"comment_content":"我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性、扩展性、可维护性。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510230,"discussion_content":"说的没错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261983,"user_name":"Geek_5a5d9a","can_delete":false,"product_type":"c1","uid":2046477,"ip_address":"","ucode":"8A444C96DB4389","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/6gic9ib9c9865ec0rKEPZJtvbj2yINgrGtjibr95luMEZdJ0oBV0hJUbE7iaeia4B802CibweG3yicJSCo5c93MeCSxMg/132","comment_is_top":false,"comment_ctime":1605597219,"is_pvip":false,"replies":[{"id":"96128","content":"������","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606701212,"ip_address":"","comment_id":261983,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605597219","product_id":100039001,"comment_content":"我的想法是对外提供构造函数,  构造不同场景的上传, 例如:<br><br>public ImageProcessingJob aliyunProcessingJob() {<br>        &#47;&#47; 设置类的基本属性<br>        &#47;&#47; self.imageStore = new AliyunImageStore()<br>    }<br>    public ImageProcessingJob privateProcessingJob() {<br>        &#47;&#47; 设置类的属性<br>        &#47;&#47; self.imageStore = new PrivateImageStore()<br>    }","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509681,"discussion_content":"������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606701212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261516,"user_name":"刘永超","can_delete":false,"product_type":"c1","uid":2066121,"ip_address":"","ucode":"94CCA30F9E1567","user_header":"https://static001.geekbang.org/account/avatar/00/1f/86/c9/456f803d.jpg","comment_is_top":false,"comment_ctime":1605368809,"is_pvip":false,"replies":[{"id":"96141","content":"哈哈，爱你","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606701404,"ip_address":"","comment_id":261516,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605368809","product_id":100039001,"comment_content":"老师把行业“黑话”讲透彻了，捅破那层窗户纸，不用再纠结于一些基本概念。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509506,"discussion_content":"哈哈，爱你","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606701404,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257260,"user_name":"Kingram","can_delete":false,"product_type":"c1","uid":2247700,"ip_address":"","ucode":"212E403E81F2FC","user_header":"https://static001.geekbang.org/account/avatar/00/22/4c/14/8fa39544.jpg","comment_is_top":false,"comment_ctime":1603896925,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603896925","product_id":100039001,"comment_content":"工厂方法会好点，新需求修改只需要修改工厂的方法","like_count":0},{"had_liked":false,"id":257177,"user_name":"彭发红","can_delete":false,"product_type":"c1","uid":1461374,"ip_address":"","ucode":"9BAC208700791E","user_header":"https://static001.geekbang.org/account/avatar/00/16/4c/7e/4771d8a4.jpg","comment_is_top":false,"comment_ctime":1603872904,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1603872904","product_id":100039001,"comment_content":"传入可变参数+链式设计模式","like_count":0},{"had_liked":false,"id":255937,"user_name":"紫日","can_delete":false,"product_type":"c1","uid":1207410,"ip_address":"","ucode":"73A8DEE323AC19","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXSb2jAzlMM0JdTjWrNiaq2uR9eeloBYp906POddb9evmuj5f4CUoO6ge8TibibwtZicnl1sRHic9rW7g/132","comment_is_top":false,"comment_ctime":1603461202,"is_pvip":true,"discussion_count":0,"race_medal":4,"score":"1603461202","product_id":100039001,"comment_content":"我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。在定义接口的时候，不要暴露任何实现细节。接口的定义只表明做什么，而不是怎么做。而且，在设计接口的时候，我们要多思考一下，这样的接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候，不需要任何接口定义的改动。","like_count":0},{"had_liked":false,"id":253511,"user_name":"@许还真","can_delete":false,"product_type":"c1","uid":1099324,"ip_address":"","ucode":"6D754D5AE44CEC","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/3c/8ab9deb0.jpg","comment_is_top":false,"comment_ctime":1602757780,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602757780","product_id":100039001,"comment_content":"貌似是依赖注入，不要在里面new 一个对象，外面传进来。<br>面向接口，而非实现","like_count":0},{"had_liked":false,"id":250070,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1600924442,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600924442","product_id":100039001,"comment_content":"将图片存储类也抽象一个接口，并且通过依赖注入的方式注入进来","like_count":0},{"had_liked":false,"id":249775,"user_name":"朱月俊","can_delete":false,"product_type":"c1","uid":1017707,"ip_address":"","ucode":"4DA0728B862FBD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/6b/0b6cd39a.jpg","comment_is_top":false,"comment_ctime":1600786205,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600786205","product_id":100039001,"comment_content":"使用工厂模式，统一传入一个类型参数，然后在工厂实例化中根据类型名返回具体的存储实例。这样每次新增一种存储类型，只需要修改传入工厂的类型名即可。","like_count":0},{"had_liked":false,"id":247754,"user_name":"WilliamVector","can_delete":false,"product_type":"c1","uid":1898112,"ip_address":"","ucode":"E0D3C3D4FCB7C9","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f6/80/85ec2c2a.jpg","comment_is_top":false,"comment_ctime":1599819379,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599819379","product_id":100039001,"comment_content":"【要点】<br>1、“基于接口而非实现编程”，这条原则的另一个表述方式，是“基于抽象而非实现编程”。后者的表述方式其实更能体现这条原则的设计初衷。我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性、扩展性、可维护性。<br>2、我们在定义接口的时候，一方面，命名要足够通用，不能包含跟具体实现相关的字眼；另一方面，与特定实现有关的方法不要定义在接口中。<br>3、“基于接口而非实现编程”这条原则，不仅仅可以指导非常细节的编程开发，还能指导更加上层的架构设计、系统设计等。比如，服务端与客户端之间的“接口”设计、类库的“接口”设计。<br>【思考】<br>1、如果不需要上层进行选择存储图片到私有云还是公有云，则定义一个通用存储图片的类，在类内可通过读取配置文件等方法来具体指定图片服务器。<br>2、如果需要上层指定图片存储的位子，则通过工厂类实现，传入的参数为存储图片的位置。ImageStroageFactory.createStorage(storageType);","like_count":0},{"had_liked":false,"id":245807,"user_name":"JerryZhu","can_delete":false,"product_type":"c1","uid":1591223,"ip_address":"","ucode":"76850CD45786C1","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","comment_is_top":false,"comment_ctime":1599059273,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599059273","product_id":100039001,"comment_content":"作为一个6年一线开发经验的程序员来说， 回来再从零开始看看曾经为了面试而准备这些概念，其实感慨颇深， 基于抽象，易扩展， 易维护，真是十分感慨啊！深谙其重要性","like_count":0},{"had_liked":false,"id":245804,"user_name":"JerryZhu","can_delete":false,"product_type":"c1","uid":1591223,"ip_address":"","ucode":"76850CD45786C1","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","comment_is_top":false,"comment_ctime":1599059164,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599059164","product_id":100039001,"comment_content":"用动态代理或者静态工厂一类的替换掉第八行","like_count":0},{"had_liked":false,"id":245364,"user_name":"lengrongfu","can_delete":false,"product_type":"c1","uid":1494681,"ip_address":"","ucode":"FD6F35CA561E0B","user_header":"https://static001.geekbang.org/account/avatar/00/16/ce/99/447c33d4.jpg","comment_is_top":false,"comment_ctime":1598925123,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598925123","product_id":100039001,"comment_content":"课后讨论思考：我想的是这个需要放在两种项目场景中讨论，第一种是web项目，有IOC容器，这样就可以自动注入，不用手动创建，注入的Bean就由用户决定注入那个实现类。第二种是没有使用IOC容器的项目，这种场景下就需要使用创建型的设计模式了，对应这里的话就用静态工程就可以了。欢迎留言讨论。","like_count":0},{"had_liked":false,"id":244351,"user_name":"Geek_35cfdd","can_delete":false,"product_type":"c1","uid":1792214,"ip_address":"","ucode":"AD9615ABB4CA25","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoiaP1gptuBzj3AXMpY8yLTIkpuarouOVzLde4636UJ7zAgnOEZibiaAIRVAicFaO64ftH45YOn1pD3VA/132","comment_is_top":false,"comment_ctime":1598491179,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598491179","product_id":100039001,"comment_content":"面向接口编程的核心本质是分离稳定和变化。在外围依赖可以不感知下层的变化。已达到下游自身可扩展的目的。<br>","like_count":0},{"had_liked":false,"id":243018,"user_name":"CaptainZ","can_delete":false,"product_type":"c1","uid":1126126,"ip_address":"","ucode":"E017D84913F930","user_header":"https://static001.geekbang.org/account/avatar/00/11/2e/ee/d7070494.jpg","comment_is_top":false,"comment_ctime":1597920495,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597920495","product_id":100039001,"comment_content":"用策略模式 不策略返回不同对象","like_count":0},{"had_liked":false,"id":242927,"user_name":"郑大钱","can_delete":false,"product_type":"c1","uid":1503067,"ip_address":"","ucode":"114CF48056880E","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/5b/ff28088f.jpg","comment_is_top":false,"comment_ctime":1597894851,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597894851","product_id":100039001,"comment_content":"对埋点的封装，算是最典型的面相接口编程。最开始上报到TalkingData，接着上报到自己的大数据，后来集团融合导致上报迁移，业务层一句代码都不用改。<br>同时也做过过度设计，MJRefresh本来很完善，非要封装一个适配器，想着替换MJRefresh也会很方便。结果封装的适配器没有MJRefresh好用，再也没有人愿意维护。<br>面向接口编程的目的是将不稳定的实现封装成稳定的接口，如果像MJRefresh这种本身就很稳定的实现，就没有必要在为它封装接口了。","like_count":0},{"had_liked":false,"id":241517,"user_name":"JD_Zty","can_delete":false,"product_type":"c1","uid":1074248,"ip_address":"","ucode":"120A513029F728","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/48/c292eaa5.jpg","comment_is_top":false,"comment_ctime":1597318296,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597318296","product_id":100039001,"comment_content":"把ImageStore作为ImageProcessingJob的私有成员变量，在构造ImageProcessingJob类时，将ImageStore的实现实例传入，进行赋值。","like_count":0},{"had_liked":false,"id":241397,"user_name":"大力","can_delete":false,"product_type":"c1","uid":1364353,"ip_address":"","ucode":"1B2125C519443D","user_header":"https://static001.geekbang.org/account/avatar/00/14/d1/81/89ba9d81.jpg","comment_is_top":false,"comment_ctime":1597284218,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597284218","product_id":100039001,"comment_content":"思考题思路：抽象工厂模式 + 依赖注入","like_count":0},{"had_liked":false,"id":240804,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1597070392,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597070392","product_id":100039001,"comment_content":"通过依赖注入的方式传入对应的实现","like_count":0},{"had_liked":false,"id":239992,"user_name":"Geek_809561","can_delete":false,"product_type":"c1","uid":2037722,"ip_address":"","ucode":"94FA67AEFB6CA0","user_header":"","comment_is_top":false,"comment_ctime":1596707386,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596707386","product_id":100039001,"comment_content":"这节课感觉收获最大的一点是。如何设计出好的接口。抓住最基本的一点，接口就是是做什么的。任何其他附加的东西都不要。","like_count":0},{"had_liked":false,"id":239060,"user_name":"long","can_delete":false,"product_type":"c1","uid":1595158,"ip_address":"","ucode":"8424683A801718","user_header":"https://static001.geekbang.org/account/avatar/00/18/57/16/b7b4fe79.jpg","comment_is_top":false,"comment_ctime":1596424507,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596424507","product_id":100039001,"comment_content":"第一反应想到的是策略模式<br>1. 将 ImageStore 交给 spring 容器管理，在 @Bean 处统一替换，缺点就是一替换整体全部替换，不能做到灵活处理<br>2. 使用工厂+策略模式 getImageStore(String storeType).upload(image, BUCKET_NAME);，在 getImageStore 类中可以定义一个 map 实现将所有的实现装载好，这个时候取出来直接用即可","like_count":0},{"had_liked":false,"id":238871,"user_name":"Geek_a5edac","can_delete":false,"product_type":"c1","uid":1954784,"ip_address":"","ucode":"A47341B4DB9C8E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/d4MHbXBwovYHW7xA18j88ibw1wS2R1JCoH5oLJIMUTdXe07dyVeTNWNzqWUKT7nPg21oClPhy1rSZPFiaibHeUFBA/132","comment_is_top":false,"comment_ctime":1596351789,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596351789","product_id":100039001,"comment_content":"关于抽象，具体到代码编程的时候就是在创建类的时候该如何设计？个人以往对类的认知是一个对象，即一个Entity，然后往往对Entity抽象的时候没有明确的方法论，比如这样一个场景：一个文件上传的处理流程包含资源提取、上传的步骤，那么可以抽象成对应的接口满足不同细化的上传场景。<br>但这些接口本身的对象是什么？我们是基于什么对象抽象出这样的接口的？这时候可以从上传的资源这个对象做抽象，即对象是资源支持的方法有获取和上传。<br>另外，基于接口编程本身是一种抽象的过程，抽象类提供的方法本身是高度抽象的。<br>比如图片存储类，这里关注的是存储，作用的对象是图片。即需要对存储做一个抽象，比如包含上传、下载的行为。对存储做抽象是为了应对不同存储服务方对上传、下载的处理机制不一致的问题，方便扩展，本质上是对存储服务方这个对象的能力抽象。","like_count":0},{"had_liked":false,"id":238806,"user_name":"Java课代表","can_delete":false,"product_type":"c1","uid":1613052,"ip_address":"","ucode":"F17E4A1807FB12","user_header":"https://static001.geekbang.org/account/avatar/00/18/9c/fc/0aa200b5.jpg","comment_is_top":false,"comment_ctime":1596323363,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596323363","product_id":100039001,"comment_content":"思考题：<br>把具体实现对象通过依赖注入的方式传进来，将创建和使用解耦","like_count":0},{"had_liked":false,"id":238390,"user_name":"David","can_delete":false,"product_type":"c1","uid":1021825,"ip_address":"","ucode":"22CBBC13FC97A9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/97/81/e1eaf621.jpg","comment_is_top":false,"comment_ctime":1596158221,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1596158221","product_id":100039001,"comment_content":"使用工厂 或者是策略模式","like_count":0},{"had_liked":false,"id":238195,"user_name":"owen","can_delete":false,"product_type":"c1","uid":1902116,"ip_address":"","ucode":"0E79DA9080A085","user_header":"https://static001.geekbang.org/account/avatar/00/1d/06/24/c2ee3b16.jpg","comment_is_top":false,"comment_ctime":1596092775,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596092775","product_id":100039001,"comment_content":"工厂模式 ImageStore imageStore = ImageStoreFactory.newInstance(PrivateImageStore.class);","like_count":0},{"had_liked":false,"id":234941,"user_name":"西电","can_delete":false,"product_type":"c1","uid":2063037,"ip_address":"","ucode":"95BD4CE9D93018","user_header":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","comment_is_top":false,"comment_ctime":1594836330,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594836330","product_id":100039001,"comment_content":"笔记: 多继承和接口更恰当的说法是behaves like(表现的像)。 吸血鬼继承蝙蝠和人，不能说吸血鬼是人，也不能说吸血鬼是蝙蝠。最恰当的说法是吸血鬼表现的像人和蝙蝠","like_count":0},{"had_liked":false,"id":230660,"user_name":"任忠良","can_delete":false,"product_type":"c1","uid":1197169,"ip_address":"","ucode":"27AB8BEE245136","user_header":"https://static001.geekbang.org/account/avatar/00/12/44/71/28a1adb9.jpg","comment_is_top":false,"comment_ctime":1593442373,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593442373","product_id":100039001,"comment_content":"golang 中的接口更多的是像一种面向未来编程的思维，好多人提到了 io.Writer 和 io.Reader，但是我觉得最能代表 golang 接口的是 sort.Interface，它定义了实现排序的接口，只有 Len() int, Less(i, j int) bool 和 Swap(i, j int) 三个方法，整个 sort 包的大部分方法都是对这个接口的操作。所以在使用时候，任何数据结构实现这三个方法就可以使用 sort 包中的排序操作。","like_count":0},{"had_liked":false,"id":228941,"user_name":"陈衎","can_delete":false,"product_type":"c1","uid":1810649,"ip_address":"","ucode":"8A6535DDB4B611","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a0/d9/49578be1.jpg","comment_is_top":false,"comment_ctime":1592844518,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592844518","product_id":100039001,"comment_content":"配置项+ioc容器+DI注入","like_count":0},{"had_liked":false,"id":227041,"user_name":"潇洒哥","can_delete":false,"product_type":"c1","uid":1110623,"ip_address":"","ucode":"90D8D843D12559","user_header":"","comment_is_top":false,"comment_ctime":1592271545,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592271545","product_id":100039001,"comment_content":"第8行使用依赖倒置原则，改成DI容器注入","like_count":0},{"had_liked":false,"id":226880,"user_name":"X_L～","can_delete":false,"product_type":"c1","uid":1608383,"ip_address":"","ucode":"6BD8C24750F86B","user_header":"https://static001.geekbang.org/account/avatar/00/18/8a/bf/3f7c45c9.jpg","comment_is_top":false,"comment_ctime":1592221870,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592221870","product_id":100039001,"comment_content":"使用策略模式，在策略接口之前创建一个上下文类，然后根据不同的场景去进行路由切换<br>","like_count":0},{"had_liked":false,"id":226855,"user_name":"banana","can_delete":false,"product_type":"c1","uid":1356721,"ip_address":"","ucode":"81378DF8002609","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/3fgqmf5ocmgTHTHnWrN2Yq26dl6jWXiaBzm0P1Arpz4YDHX3EOEe2iaCWCX60icZJGEnjXicGbWArQyN5fGj1Cf3Sw/132","comment_is_top":false,"comment_ctime":1592217425,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592217425","product_id":100039001,"comment_content":"如果我们要替换图片存储方式，还是需要修改很多类似第 8 行那样的代码。这样的设计还是不够完美.<br>个人思考：process函数加上一个参数：public void process(ImageStore imageStore)<br>调用者根据自己的需求带上不同的参数，通过多态，实现不同的存储类型调用自己的方法。","like_count":0},{"had_liked":false,"id":225858,"user_name":"石头","can_delete":false,"product_type":"c1","uid":1437900,"ip_address":"","ucode":"44F1A83FECEDA9","user_header":"https://static001.geekbang.org/account/avatar/00/15/f0/cc/c57ec699.jpg","comment_is_top":false,"comment_ctime":1591876019,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591876019","product_id":100039001,"comment_content":"将ImageStore 作为构造参数注入，具体实现类由外部传入。","like_count":0},{"had_liked":false,"id":222538,"user_name":"Cheney","can_delete":false,"product_type":"c1","uid":1250828,"ip_address":"","ucode":"6ED4F3FDBA6D54","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/0c/53f2792c.jpg","comment_is_top":false,"comment_ctime":1590830235,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590830235","product_id":100039001,"comment_content":"思考题目:可以基于spi机制来实现不同的实现,或者策略模式,工厂模式等来实现","like_count":0},{"had_liked":false,"id":220594,"user_name":"小松","can_delete":false,"product_type":"c1","uid":1125878,"ip_address":"","ucode":"8B139C467E82F3","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/f6/f38f4428.jpg","comment_is_top":false,"comment_ctime":1590291858,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1590291858","product_id":100039001,"comment_content":"提供setImageStore方法， 注入依赖","like_count":0},{"had_liked":false,"id":219755,"user_name":"Geek_East","can_delete":false,"product_type":"c1","uid":1589947,"ip_address":"","ucode":"A1A7CBF9B8FB2D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXKSvfaeicog2Ficx4W3pNeA1KRLOS7iaFy2uoxCDoYpGkGnP6KPGecKia6Dr3MtCkNGpHxAzmTMd0LA/132","comment_is_top":false,"comment_ctime":1590074199,"is_pvip":true,"replies":[{"id":"85680","content":"代码复用","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1593912017,"ip_address":"","comment_id":219755,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590074199","product_id":100039001,"comment_content":"想问个问题，泛型的主要目的是代码复用还是抽象呀？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495934,"discussion_content":"代码复用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593912017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219503,"user_name":"郭俊杰","can_delete":false,"product_type":"c1","uid":1082785,"ip_address":"","ucode":"D328E5738A4413","user_header":"https://static001.geekbang.org/account/avatar/00/10/85/a1/2442332c.jpg","comment_is_top":false,"comment_ctime":1590033357,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590033357","product_id":100039001,"comment_content":"对于一直不写接口的我来说，今天算是明白了，在有可能业务变化的时候，为了不影响上游系统，最小的改动，一定要多思考一下抽象，哈哈。","like_count":0},{"had_liked":false,"id":216838,"user_name":"师哥","can_delete":false,"product_type":"c1","uid":1333376,"ip_address":"","ucode":"A86CD1661D370F","user_header":"https://static001.geekbang.org/account/avatar/00/14/58/80/c9e232b6.jpg","comment_is_top":false,"comment_ctime":1589353240,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589353240","product_id":100039001,"comment_content":" 基于接口编程 可以提高程序的可扩展性和灵活性。接口就是一种约定，要在需求可能发生变化的情况下使用，否则没有必要使用","like_count":0},{"had_liked":false,"id":216433,"user_name":"注定非凡","can_delete":false,"product_type":"c1","uid":1113597,"ip_address":"","ucode":"80673056E131B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","comment_is_top":false,"comment_ctime":1589258368,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1589258368","product_id":100039001,"comment_content":"基于接口编程或者说基于抽象编程，而不是实现。这样做的原因是为了提高代码的可扩展性，可变动性。<br><br>因为在实际开发中唯一不变的就是变化，我们需要在设计编码时，提高自己的抽象意识，封装意识，接口意识，写出易扩展，修改的代码","like_count":0},{"had_liked":false,"id":215741,"user_name":"darkleo","can_delete":false,"product_type":"c1","uid":1023395,"ip_address":"","ucode":"126DF780822654","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9d/a3/a780d006.jpg","comment_is_top":false,"comment_ctime":1589093267,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589093267","product_id":100039001,"comment_content":"如果把imagestore封装成工具呢？","like_count":0},{"had_liked":false,"id":215432,"user_name":"tuyu","can_delete":false,"product_type":"c1","uid":1448863,"ip_address":"","ucode":"B235325B541408","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/BIRpwViaN51yynIeFonD7QRlwDCVtKibrG956NTxzEqibOZZVjhMMgibOPmd3VicfYxpknZsic1oJq8KicZvXkmmiajuQg/132","comment_is_top":false,"comment_ctime":1588991481,"is_pvip":false,"replies":[{"id":"86788","content":"这个就没法抽象成接口了，只能每个不同的云平台不同处理了。我们也没法追求在替换云平台时，一点代码都不改。尽量少改动代码就可以了。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1594903956,"ip_address":"","comment_id":215432,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1588991481","product_id":100039001,"comment_content":"老师, 我今天碰到一个问题, 如果我创建阿里云k8s, 那么参数是很多很多, 根据接口原则, 我不太清楚未来不同云平台创建k8s需要哪些参数, 那我应该怎么做","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494434,"discussion_content":"这个就没法抽象成接口了，只能每个不同的云平台不同处理了。我们也没法追求在替换云平台时，一点代码都不改。尽量少改动代码就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594903956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212063,"user_name":"Tobias","can_delete":false,"product_type":"c1","uid":1803858,"ip_address":"","ucode":"F3225639EDA193","user_header":"https://static001.geekbang.org/account/avatar/00/1b/86/52/b92dc111.jpg","comment_is_top":false,"comment_ctime":1588055832,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588055832","product_id":100039001,"comment_content":"关于思考题：<br>首先要明白&quot;不够完美&quot;指的到底是么，究竟哪点不够完美？我理解是，（1）下游使用ImageStore 可能会new 出多个实例，不好。（2） 如果上游提供的 PrivateImageStore 如果不存在了，会对下游产生影响，上游接口提供方是否有兜底方案？ ","like_count":0},{"had_liked":false,"id":208157,"user_name":"youngitachi","can_delete":false,"product_type":"c1","uid":1214582,"ip_address":"","ucode":"88717CA8B8ED64","user_header":"https://static001.geekbang.org/account/avatar/00/12/88/76/c69b7fe5.jpg","comment_is_top":false,"comment_ctime":1587286267,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1587286267","product_id":100039001,"comment_content":"思考题，个人觉得，在实际编写代码运行的时候，无论如何都无法避免将一个具体的实例绑定到imageStore上去，也就是说，新增一个ImageStore的实现类后，除了新增的这部分代码，不可能在修改原来的代码的基础上就使用这个新的实现类。肯定有地方将这个新的实现类和imageStore绑定。不过考虑到对扩展开放，对修改关闭的原则。我觉得有一下办法修改设计。<br><br>1. 将具体的imageStore当作参数传进来：<br>```java<br><br>&#47;&#47; ImageStore的使用举例<br>public class ImageProcessingJob {<br>  private static final String BUCKET_NAME = &quot;ai_images_bucket&quot;;<br>  &#47;&#47;...省略其他无关代码...<br>  <br>  public void process(ImageStore imageStore) {<br>    Image image = ...;&#47;&#47;处理图片，并封装为Image对象<br>    imagestore.upload(image, BUCKET_NAME);<br>  }<br>```<br>2. 将imageStore设置为成员<br>```java<br><br>&#47;&#47; ImageStore的使用举例<br>public class ImageProcessingJob {<br>  private static final String BUCKET_NAME = &quot;ai_images_bucket&quot;;<br>  private ImageStore imageStore;<br>  &#47;&#47;...省略构造器和其他无关代码...<br>  <br>  public void process() {<br>    Image image = ...;&#47;&#47;处理图片，并封装为Image对象<br>    imagestore.upload(image, BUCKET_NAME);<br>  }<br>```<br>这个方法其实就是策略模式。<br>3、使用工厂方法模式。暂提一下，后面学到的时候自然就明白了。<br>","like_count":0},{"had_liked":false,"id":203291,"user_name":"酸辣土豆丝","can_delete":false,"product_type":"c1","uid":1751234,"ip_address":"","ucode":"0E3E4AFB31E1E6","user_header":"https://static001.geekbang.org/account/avatar/00/1a/b8/c2/d1904d74.jpg","comment_is_top":false,"comment_ctime":1586166885,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586166885","product_id":100039001,"comment_content":"定义一个配置参数来配置存储方式，程序加载的时候，根据配置的值，来动态的加载，对应的存储路径对象","like_count":0},{"had_liked":false,"id":202837,"user_name":"技术骨干","can_delete":false,"product_type":"c1","uid":1098720,"ip_address":"","ucode":"8FCF8DE6D29201","user_header":"https://static001.geekbang.org/account/avatar/00/10/c3/e0/3db22579.jpg","comment_is_top":false,"comment_ctime":1586075516,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586075516","product_id":100039001,"comment_content":"看完之后感觉可以用策略模式试试，<br>将图片的存储方式抽象成一个策略类，<br>然后创建两个实现策略类，比如aliyun 存储，私有云存储，腾讯云存储<br>再创建一个使用策略的类  Context(Strategy strategu) ，executeStrategy(img,arg....)<br>当使用哪种存储方式的时候，就直接调用Context 的executeStrategy","like_count":0},{"had_liked":false,"id":202825,"user_name":"技术骨干","can_delete":false,"product_type":"c1","uid":1098720,"ip_address":"","ucode":"8FCF8DE6D29201","user_header":"https://static001.geekbang.org/account/avatar/00/10/c3/e0/3db22579.jpg","comment_is_top":false,"comment_ctime":1586074609,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586074609","product_id":100039001,"comment_content":"接口的定义只表明做什么，而不是怎么做。而且，在设计接口的时候，我们要多思考一下，这样的接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候，不需要任何接口定义的改动。","like_count":0},{"had_liked":false,"id":202408,"user_name":"Geek_bb8d16","can_delete":false,"product_type":"c1","uid":1735740,"ip_address":"","ucode":"964BD4DB3D9653","user_header":"","comment_is_top":false,"comment_ctime":1585984979,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585984979","product_id":100039001,"comment_content":"模版模式，上传流程相对稳定，先处理，再加载要上传的服务器，再上传，父类定义流程，让子类来实现具体细节，而子类又可以通过接口来实现","like_count":0},{"had_liked":false,"id":201453,"user_name":"小北","can_delete":false,"product_type":"c1","uid":1101976,"ip_address":"","ucode":"4DAC260AC75B71","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/98/9779cf40.jpg","comment_is_top":false,"comment_ctime":1585790130,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585790130","product_id":100039001,"comment_content":"思考题：我觉得可以采用依赖倒置的原则。简单的版本可以基于工厂模式实现。但是在一般的项目中可以直接使用成熟的ioc框架实现依赖倒置。如java spring中自带的依赖注入，或者c#中的autofac，这些都是“器”级别的。","like_count":0},{"had_liked":false,"id":200335,"user_name":"elasting","can_delete":false,"product_type":"c1","uid":1820716,"ip_address":"","ucode":"03AAFF8D1A75B9","user_header":"","comment_is_top":false,"comment_ctime":1585573483,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585573483","product_id":100039001,"comment_content":"使用spring的条件注入，而条件的判断可以通过配置文件的配置项设置，要替换实例，只需要更改配置项的值就行，这与一个系统要兼容多个数据库是类似的","like_count":0},{"had_liked":false,"id":198524,"user_name":"面向百度编程","can_delete":false,"product_type":"c1","uid":1732780,"ip_address":"","ucode":"8FE04A019D71D1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","comment_is_top":false,"comment_ctime":1585455184,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585455184","product_id":100039001,"comment_content":"您这里说函数的命名不能包含更为详细的细节，您说了把uploadtoaliyun照抄到 privatetoaliyun不合适，这肯定不合适啊，我觉得并没有把为什么不合适讲明白。不暴露更为具体的实现细节，是不是一种好事呢，值得深思，但作为接口，确实是给上游暴露，只不过，再给某个具体实现子类实现的时候，比如aliyun ,privateyun 可以尽可能的简化在其类中的方法命名，看到类名就能知道具体的对应目标，但是如果没有接口用具体详细细节命名也没错，只是增加一点修改时间而已，同样能够给上游带来方便","like_count":0},{"had_liked":false,"id":197256,"user_name":"桂冠远航","can_delete":false,"product_type":"c1","uid":1155463,"ip_address":"","ucode":"5959E1A1DAA05D","user_header":"https://static001.geekbang.org/account/avatar/00/11/a1/87/259ab5a3.jpg","comment_is_top":false,"comment_ctime":1585365662,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585365662","product_id":100039001,"comment_content":"隐藏内部细节这个确实挺对的，最近也在做微信公众号的开发，accessToken获取的逻辑到底应该放在哪里，我也思考了很久。","like_count":0},{"had_liked":false,"id":195965,"user_name":"Six","can_delete":false,"product_type":"c1","uid":1220617,"ip_address":"","ucode":"E297BB638B2BD9","user_header":"https://static001.geekbang.org/account/avatar/00/12/a0/09/4af6ff52.jpg","comment_is_top":false,"comment_ctime":1585226417,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585226417","product_id":100039001,"comment_content":"对于作者的思考题。个人觉得需要考虑实际场景。有两种场景<br>1.如需改变就全部改变。那么在设计的时候提供一个静态方法比如<br> public static ImageStore createImageStoreStore(){<br>         return PrivateImageStore()<br>         &#47;&#47;return AliYunImageStore()<br>    }<br>这样只改这一处地方全局生效。对调用者来说，创建细节隐藏。<br>2.那如果是部分使用私有云部分使用阿里云，可以使用简单工厂。<br> public static ImageStore createImageStoreStore(String storeType){<br>           &#47;&#47;根据storeType来判断创建哪一个实现类 <br>}","like_count":0},{"had_liked":false,"id":194852,"user_name":"墨鱼","can_delete":false,"product_type":"c1","uid":1022720,"ip_address":"","ucode":"8FB5E4DCB8A024","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/00/654be3f7.jpg","comment_is_top":false,"comment_ctime":1585111138,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585111138","product_id":100039001,"comment_content":"想起来我以前写的代码，把所有的实现都放到一个函数里面，都时候需要改动的话，非常麻烦。后来把他们都分离了一下，抽象出来，变成几个函数。需要改动的时候，只需要改动具体的实现部分，逻辑没变。<br><br>这应该也是一种基于接口而非实现编程的案例","like_count":0},{"had_liked":false,"id":194363,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1585054667,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585054667","product_id":100039001,"comment_content":"可以使用代理模式，写一个代理类。就算后面要修改也是修改代理类而已，不会对上一层调用产生修改。","like_count":0},{"had_liked":false,"id":191563,"user_name":"秋风画扇","can_delete":false,"product_type":"c1","uid":1132356,"ip_address":"","ucode":"5BCBC1422C51EC","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/44/964aa665.jpg","comment_is_top":false,"comment_ctime":1584781572,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584781572","product_id":100039001,"comment_content":"接口只需要定义在有变化的地方既可以。图片处理的方式有很多，可以上传、删除、编辑，而上传又可以分很多存储介质。我们这里可以采用策略模式，process()方法只需要调用接口方法ImageStore#upload()就可以了，ImageStore作为ImageProcessingJob的成员变量，我们可以通过注入不同个实现类来调用不同处理逻辑，这里用到了“多态”","like_count":0},{"had_liked":false,"id":191559,"user_name":"秋风画扇","can_delete":false,"product_type":"c1","uid":1132356,"ip_address":"","ucode":"5BCBC1422C51EC","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/44/964aa665.jpg","comment_is_top":false,"comment_ctime":1584781287,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584781287","product_id":100039001,"comment_content":"联系题是抽象程度的问题，处理ImageProcessingJob的作用是处理图片，处理的方式有很多：上传、删除、编辑……每种处理方式又有不同的实现，上传可以传到私有云、阿里云……，我们在上面地方定义抽象取决变化在上面地方。如果仅仅是处理方式仅仅是上传，而上传可能到多个媒介，这时候我们就可以再上传这地方做文章。    process()方法里只需要调用存储的接口既可，具体实现也可以灵活替换","like_count":0},{"had_liked":false,"id":189453,"user_name":"治慧","can_delete":false,"product_type":"c1","uid":1245904,"ip_address":"","ucode":"47C331EF63EDC6","user_header":"https://static001.geekbang.org/account/avatar/00/13/02/d0/8abab63f.jpg","comment_is_top":false,"comment_ctime":1584517975,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584517975","product_id":100039001,"comment_content":"工厂模式去实话对象或者通过策略模式提供统一的Context如果通过定义枚举的方式获取对应的实现类bean名称在从依赖注入的map中取出实例对象来执行方法这样无论添加阿里云 百度云 还是华为云只需要写对应的实现类和在枚举中增加对应的bean名称即可","like_count":0},{"had_liked":false,"id":189132,"user_name":"jaryoung","can_delete":false,"product_type":"c1","uid":1077406,"ip_address":"","ucode":"6E72D107DB7E51","user_header":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","comment_is_top":false,"comment_ctime":1584458194,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584458194","product_id":100039001,"comment_content":"课后习题：配置文件配置的方式，能很好解决这个问题。","like_count":0},{"had_liked":false,"id":186567,"user_name":"ladidili","can_delete":false,"product_type":"c1","uid":1217498,"ip_address":"","ucode":"38886C1908DE6B","user_header":"https://static001.geekbang.org/account/avatar/00/12/93/da/0e47c76e.jpg","comment_is_top":false,"comment_ctime":1583885548,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1583885548","product_id":100039001,"comment_content":"接口是对相同功能的抽象，是协议，是对功能的描述，约定","like_count":0},{"had_liked":false,"id":186500,"user_name":"ladidili","can_delete":false,"product_type":"c1","uid":1217498,"ip_address":"","ucode":"38886C1908DE6B","user_header":"https://static001.geekbang.org/account/avatar/00/12/93/da/0e47c76e.jpg","comment_is_top":false,"comment_ctime":1583853500,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1583853500","product_id":100039001,"comment_content":"设计模式是思想上的东西，是前人总结出来的经验。没有什么具体的语法实现。<br>类，接口，继承是实在的语法。<br><br>基于接口而非实现编程就是基于抽象而非实现。关键点就是抽象。<br><br>一个新功能，可以思考这个功能点可能会有哪些变种。通过抽象出多个变种里共有的逻辑，抽象出来。其他的具体实现都基于这个抽象去实现。具体也就是抽象出一个个接口，面向这些接口实现。<br><br>","like_count":0},{"had_liked":false,"id":185837,"user_name":"大王叫我来巡山","can_delete":false,"product_type":"c1","uid":1099513,"ip_address":"","ucode":"1B8D0C701BC95E","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/f9/caf27bd3.jpg","comment_is_top":false,"comment_ctime":1583708921,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583708921","product_id":100039001,"comment_content":"面向配置文件编程","like_count":0},{"had_liked":false,"id":181623,"user_name":"悠游","can_delete":false,"product_type":"c1","uid":1222834,"ip_address":"","ucode":"4FDDDDF29AE3F0","user_header":"https://static001.geekbang.org/account/avatar/00/12/a8/b2/998448ca.jpg","comment_is_top":false,"comment_ctime":1582598935,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582598935","product_id":100039001,"comment_content":"可以基于策略模式，由用户传入的参数指定需要选用哪种图片存储方式，由此来创建响应的具体的类对象。","like_count":0},{"had_liked":false,"id":180701,"user_name":"未来小娃","can_delete":false,"product_type":"c1","uid":1047329,"ip_address":"","ucode":"477D166EBB6B70","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/21/d017438c.jpg","comment_is_top":false,"comment_ctime":1582367614,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1582367614","product_id":100039001,"comment_content":"编程依赖抽象而不是实现得前提条件是行为的变化，比如将毫秒时间戳换算为年月日就不存在行为的变化，那么直接用一个“实现类”，或者说普通类就可以了，反之如果文中提到的上传图片和下载图片的行为未来就是有可能变化的，比如图片存储从阿里云换成私有云就是变化，这就要求编程设计的时候多思考变化点，具备抽象思维。前面也提到接口是行为的抽象，是一组协议或者说契约，那么就决定了接口的行为必然是比较稳定的，比如就不能在图片存储的接口上加上获取日期这样的行为因为这是不相关的，也不能加上获取图片链接的行为，因为有些图片存储可能压根就没有获取图片链接的功能，因为这是关联性没那么大的行为。关于思考题我想的是实现上可以通过一个map初始化不同实现的图片存储，key是类型，value是具体的实现，需要哪个就从map的type拿就好了，本质上这就是Spring控制反转的原理，这也是各种@Autowired直接用起来贼爽的原因","like_count":0},{"had_liked":false,"id":180656,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1582359716,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582359716","product_id":100039001,"comment_content":"面向类、面向切面、面向抽象、面向接口、面向模式、面向对象、面向结构；面向正确的方向<br>最后是不是应该用建造模式中的一种，如工厂模式啊什么的","like_count":0},{"had_liked":false,"id":179836,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1582107595,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582107595","product_id":100039001,"comment_content":"Spring框架提供了很好的依赖注入特性,可以让实际的实现类并不在编写的时候和调用方挂钩,而是由容器来决定注入, 于是我给出的解决方案是,利用工厂类和依赖注入来进行解决,在一个工厂类中保证生产出的实现类是具有单例式的,然后调用者注入这个工厂类获取到生产出的实现类,在需要修改的时候,只需要修改这个工厂类产生的实现类就可以了,调用者不需要任何改变,即可获取到工厂类生产出的新实现类","like_count":0},{"had_liked":false,"id":177925,"user_name":"Rona","can_delete":false,"product_type":"c1","uid":1102822,"ip_address":"","ucode":"A301E295D45EC4","user_header":"https://static001.geekbang.org/account/avatar/00/10/d3/e6/6b43e010.jpg","comment_is_top":false,"comment_ctime":1581538427,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581538427","product_id":100039001,"comment_content":"思考题可以将ImageStore作为process方法的形参，使用ImageStore的子类作为实参传入","like_count":0},{"had_liked":false,"id":177580,"user_name":"月马穿关","can_delete":false,"product_type":"c1","uid":1338088,"ip_address":"","ucode":"2CE20CA1EB827D","user_header":"https://static001.geekbang.org/account/avatar/00/14/6a/e8/4bb87c34.jpg","comment_is_top":false,"comment_ctime":1581428149,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581428149","product_id":100039001,"comment_content":"思考题懵逼中 我知道我平日里直接使用Ioc直接注入进来接口","like_count":0},{"had_liked":false,"id":175949,"user_name":"Pluto","can_delete":false,"product_type":"c1","uid":1038251,"ip_address":"","ucode":"E292AFAD428135","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d7/ab/15c9b94e.jpg","comment_is_top":false,"comment_ctime":1580890371,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1580890371","product_id":100039001,"comment_content":"看了很多答案，很多都是换汤不换药。如果第八行的代码大量存在，用配置一类的方式应该可以解决，做到最小修改；如果第八行的代码少量存在，直接修改第八行代码就是了。既然需求已经变了，那么修改代码是必然的事情，修改代码在可以承受范围之内就没有必要过度设计。","like_count":0,"discussions":[{"author":{"id":2347137,"avatar":"https://static001.geekbang.org/account/avatar/00/23/d0/81/d5c8e46e.jpg","nickname":"snake","note":"","ucode":"47BFFE4D048156","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331220,"discussion_content":"同意","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606810450,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175395,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1371891,"ip_address":"","ucode":"8BEFC518F06AC7","user_header":"https://static001.geekbang.org/account/avatar/00/14/ee/f3/a94cee23.jpg","comment_is_top":false,"comment_ctime":1580705198,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580705198","product_id":100039001,"comment_content":"课后思考题<br>因为存在多种实现的方案，具体哪一种，可以根据标识来选择，对应的设计想到的是策略设计模式。","like_count":0},{"had_liked":false,"id":175297,"user_name":"刘明丰","can_delete":false,"product_type":"c1","uid":1591790,"ip_address":"","ucode":"64C1D6CC769F75","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eocPWoTKicQG9ic42hLQBOqEziaNYxBekyGXljWrYfhk8gjLGZWfUX0JlObCvOIUSA8tRXicfxeSDJMMw/132","comment_is_top":false,"comment_ctime":1580647402,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580647402","product_id":100039001,"comment_content":"控制反转，依赖注入 是优雅的实现方案。","like_count":0},{"had_liked":false,"id":174657,"user_name":"不记年","can_delete":false,"product_type":"c1","uid":1045945,"ip_address":"","ucode":"287E40C68356DC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/b9/888fe350.jpg","comment_is_top":false,"comment_ctime":1580310890,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580310890","product_id":100039001,"comment_content":"1. 依赖注入 + 配置文件 ， 也就是spring<br>2. 工厂方法","like_count":0},{"had_liked":false,"id":174408,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1580195910,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580195910","product_id":100039001,"comment_content":"脑海里第一个想法就是：工厂模式；","like_count":0},{"had_liked":false,"id":174235,"user_name":"李轩","can_delete":false,"product_type":"c1","uid":1633845,"ip_address":"","ucode":"991FFF291B7E29","user_header":"https://static001.geekbang.org/account/avatar/00/18/ee/35/45a91ad0.jpg","comment_is_top":false,"comment_ctime":1580102762,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580102762","product_id":100039001,"comment_content":"设策略模式比较适合。","like_count":0},{"had_liked":false,"id":173546,"user_name":"帝都牛人","can_delete":false,"product_type":"c1","uid":1027982,"ip_address":"","ucode":"53EC02284680C7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/af/8e/6f0f4a56.jpg","comment_is_top":false,"comment_ctime":1579592794,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579592794","product_id":100039001,"comment_content":"我觉得用策略","like_count":0},{"had_liked":false,"id":172975,"user_name":"LF","can_delete":false,"product_type":"c1","uid":1434867,"ip_address":"","ucode":"ECED172D2273D3","user_header":"https://static001.geekbang.org/account/avatar/00/15/e4/f3/60a7b345.jpg","comment_is_top":false,"comment_ctime":1579400955,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579400955","product_id":100039001,"comment_content":"配置文件加工厂模式 和 反射的方式实现，学到了","like_count":0},{"had_liked":false,"id":171666,"user_name":"lecy_L","can_delete":false,"product_type":"c1","uid":1127659,"ip_address":"","ucode":"7C96DDBB3D1F7E","user_header":"https://static001.geekbang.org/account/avatar/00/11/34/eb/d00aedb0.jpg","comment_is_top":false,"comment_ctime":1578988191,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578988191","product_id":100039001,"comment_content":"课后问题解决方案：加一个接口实现类，ImageStoreServiceImpl 实现接口，在接口实现类ImageStoreServiceImpl里面不做具体上传的实现，只调用具体的实现类；具体的实现类也不用实现接口了。老师你觉得这样可以吗","like_count":0},{"had_liked":false,"id":171525,"user_name":"古之岳","can_delete":false,"product_type":"c1","uid":1256216,"ip_address":"","ucode":"355F8CE7FCF695","user_header":"https://static001.geekbang.org/account/avatar/00/13/2b/18/cee3b5b4.jpg","comment_is_top":false,"comment_ctime":1578961417,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578961417","product_id":100039001,"comment_content":"关于思考题，使用工厂模式。明白需求来源，为什么在使用了阿里云后还要使用私有云，肯定是阿里云不再满足新的业务要求，比如公司要求私密文件存储于私有云，公用图片存储于阿里云。所以可以将这个不同的使用策略抽象出来，业务层只需要将使用策略传入即可，工厂类根据传入的策略值创建具体的图片存储类。","like_count":0},{"had_liked":false,"id":169359,"user_name":"eason2017","can_delete":false,"product_type":"c1","uid":1009422,"ip_address":"","ucode":"E070BA624FA490","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/0e/c77ad9b1.jpg","comment_is_top":false,"comment_ctime":1578322157,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578322157","product_id":100039001,"comment_content":"可以通过SPI的方式来实现动态加载对应的实现类","like_count":0},{"had_liked":false,"id":169042,"user_name":"varotene","can_delete":false,"product_type":"c1","uid":1004441,"ip_address":"","ucode":"B37E9B6D35090C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/53/99/56f148bc.jpg","comment_is_top":false,"comment_ctime":1578263616,"is_pvip":false,"replies":[{"id":"65752","content":"理解的没问题~ 基于接口而非实现是一种抽象的思维","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1578380894,"ip_address":"","comment_id":169042,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578263616","product_id":100039001,"comment_content":"Programming against interface 是不是也是抽象(abstraction)的一种手段？把原来具体的问题或者实现（aliyun或者私有云）抽象成任意的云，然后通过interface来予以描述。<br>至于什么时候用interface，什么时候不用，感觉也跟什么时候用抽象什么时候不用抽象是一个道理？因为进行抽象是需要成本的， 但不需要的时候，我们就可以略过，节省工程成本（YAGNI原则）。这么理解对吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480412,"discussion_content":"理解的没问题~ 基于接口而非实现是一种抽象的思维","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578380894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167714,"user_name":"我叫郭小黑","can_delete":false,"product_type":"c1","uid":1463441,"ip_address":"","ucode":"C238592EB5EDBC","user_header":"https://static001.geekbang.org/account/avatar/00/16/54/91/0d4647d9.jpg","comment_is_top":false,"comment_ctime":1577921638,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577921638","product_id":100039001,"comment_content":"基于配置文件的简单工厂模式，或者基于配置文件的反射，类似于jdbc切换数据库方言一样，更换驱动类就可以实现对具体实现的转换","like_count":0},{"had_liked":false,"id":167459,"user_name":"乾坤瞬间","can_delete":false,"product_type":"c1","uid":1683130,"ip_address":"","ucode":"15BDCF29CBF8EB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","comment_is_top":false,"comment_ctime":1577808260,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577808260","product_id":100039001,"comment_content":"最近在看Livy源码，其实在课后思考题的过程中，有一种方法可以更加优雅，其中可以使用当前线程的动态类加载机制，根据具体的类的权限定名进行实例的加载。在。Livy中，在启动后端RSCbootstrap类中，加载的类RSCClient有多种方式，其中ReplClient继承了RSCClient.返回的都是。RSCClient对象，不过RSCClient并不是接口","like_count":0},{"had_liked":false,"id":166778,"user_name":"fly","can_delete":false,"product_type":"c1","uid":1025992,"ip_address":"","ucode":"D1F6938C9CE15D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a7/c8/5608cbdb.jpg","comment_is_top":false,"comment_ctime":1577593169,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577593169","product_id":100039001,"comment_content":"接口：理解为“协议”或者“约定”，能帮助跳出具体语言的条条框框。<br>基于接口而非实现的编程：主要降低代码间耦合度，屏蔽实现的细节。我们在做设计时，加强接口意识、封装意识、抽象意识，脱离具体的实现，可以做的通用性更好。<br>过度使用：接口是一个常被用到，也容易被过度使用。是否每个类都需要接口，根据实现后是否比较稳定，一旦完成后，几乎不改动来考虑。","like_count":0},{"had_liked":false,"id":166593,"user_name":"zmysang","can_delete":false,"product_type":"c1","uid":1642663,"ip_address":"","ucode":"8A98057E7819DD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/tjhOILHBAmlx6YiaTZJzqzxn1uyB6XpdvGDIZhBn127TYEcoLLzxRiaKvtVd3HllQqPx7cqf2YmibyBUgGGGJPDkw/132","comment_is_top":false,"comment_ctime":1577512484,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577512484","product_id":100039001,"comment_content":"没有学过设计模式，目前的想法是可以使用配置文件的方式来选择使用的存储后端类……","like_count":0},{"had_liked":false,"id":166564,"user_name":"Geek_e70156","can_delete":false,"product_type":"c1","uid":1633140,"ip_address":"","ucode":"82883975A7CA83","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIwbHuA4O3men6SpIUUqjicvbIQ5jTNFtDCtBxJjJylr1AaDd7o2T7O5xOrVsW6sMmjfmKbK0gSiatQ/132","comment_is_top":false,"comment_ctime":1577502960,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577502960","product_id":100039001,"comment_content":"思考题：<br>“这就会产生一个问题，那就是，如果我们要替换图片存储方式，还是需要修改很多类似第 8 行那样的代码。”<br>我的思路是设计一个ImageService来管理这些Image对象的创建细节，调用方只需要调用ImageService.upload就可以了，具体的创建细节不要暴露给调用方。","like_count":0},{"had_liked":false,"id":166483,"user_name":"Yangjing","can_delete":false,"product_type":"c1","uid":1018061,"ip_address":"","ucode":"D88DFD4958D07C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/88/cd/2c3808ce.jpg","comment_is_top":false,"comment_ctime":1577457316,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1577457316","product_id":100039001,"comment_content":"通过配置+抽象工厂模式。不同的配置对应不同的 Storage.","like_count":0},{"had_liked":false,"id":166145,"user_name":"喵喵喵","can_delete":false,"product_type":"c1","uid":1211713,"ip_address":"","ucode":"E3AD8BF42E19DF","user_header":"https://static001.geekbang.org/account/avatar/00/12/7d/41/3c5b770b.jpg","comment_is_top":false,"comment_ctime":1577409029,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577409029","product_id":100039001,"comment_content":"打卡～","like_count":0},{"had_liked":false,"id":165457,"user_name":"古德","can_delete":false,"product_type":"c1","uid":1037755,"ip_address":"","ucode":"E3F646BB73F60E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d5/bb/98b93862.jpg","comment_is_top":false,"comment_ctime":1577240006,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577240006","product_id":100039001,"comment_content":"第8行的问题，可以用几种方式解决<br>1.如果使用的是SpringBoot这种框架，可以通过配置文件参数，控制bean注入进行切换。<br>2.通过SPI的方式指定。<br>3.把获取实现类的方式收拢到一个方法中，通过动态参数控制。","like_count":0},{"had_liked":false,"id":165442,"user_name":"wai","can_delete":false,"product_type":"c1","uid":1439529,"ip_address":"","ucode":"29CE3BE148FB79","user_header":"https://static001.geekbang.org/account/avatar/00/15/f7/29/60e01017.jpg","comment_is_top":false,"comment_ctime":1577238674,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577238674","product_id":100039001,"comment_content":"依赖注入","like_count":0},{"had_liked":false,"id":165248,"user_name":"Richie","can_delete":false,"product_type":"c1","uid":1019588,"ip_address":"","ucode":"12314EF0347693","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/c4/8d1150f3.jpg","comment_is_top":false,"comment_ctime":1577187938,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577187938","product_id":100039001,"comment_content":"课堂讨论题的思路：<br>将 ImageStore 设计成一个接口，修改 ImageProcessingJob 类，使其接收一个 ImageStore 类型的对象，内部基于接口去调用对应的 upload、download 等方法。至于 ImageStore 类型对象的初始化，则通过依赖注入的方式去实现，最终初始化为哪个具体类的对象，是在运行时决定的。","like_count":0},{"had_liked":false,"id":162570,"user_name":"海罗沃德","can_delete":false,"product_type":"c1","uid":1165364,"ip_address":"","ucode":"8704F1D6980FA0","user_header":"https://static001.geekbang.org/account/avatar/00/11/c8/34/fb871b2c.jpg","comment_is_top":false,"comment_ctime":1576557623,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576557623","product_id":100039001,"comment_content":"檢討了一下，公司的代碼裡被新來的Jr developer寫了無數的接口，每個接口只有一個實現類，實現類也不會更換實現方式","like_count":0},{"had_liked":false,"id":162238,"user_name":"刘铁俊","can_delete":false,"product_type":"c1","uid":1066959,"ip_address":"","ucode":"779591AB5E61FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/cf/d7613e91.jpg","comment_is_top":false,"comment_ctime":1576484525,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576484525","product_id":100039001,"comment_content":"思考题我觉得比较优雅的实现可以用SPI，真正做大对新增开放，对修改关闭。或者依赖注入。","like_count":0},{"had_liked":false,"id":162044,"user_name":"张蒙","can_delete":false,"product_type":"c1","uid":1035858,"ip_address":"","ucode":"CF8727F5DCFD55","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ce/52/4f1911b5.jpg","comment_is_top":false,"comment_ctime":1576455632,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576455632","product_id":100039001,"comment_content":"课后作业:使用适配器模式。使用图片的类不依赖于具体实现类。而是使用ImagdStorage做一层包装。这样就可以使得不用改动业务实现代码。","like_count":0},{"had_liked":false,"id":161705,"user_name":"黄马","can_delete":false,"product_type":"c1","uid":1019506,"ip_address":"","ucode":"93E391B4678EC2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/72/63c94eee.jpg","comment_is_top":false,"comment_ctime":1576303131,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1576303131","product_id":100039001,"comment_content":"前面我们也提到，这条原则的设计初衷是，将接口和实现相分离，封装不稳定的实现，暴露稳定的接口；","like_count":0},{"had_liked":false,"id":161620,"user_name":"|･ω･｀)","can_delete":false,"product_type":"c1","uid":1636123,"ip_address":"","ucode":"34E1DF62058D80","user_header":"https://static001.geekbang.org/account/avatar/00/18/f7/1b/8036958c.jpg","comment_is_top":false,"comment_ctime":1576250670,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576250670","product_id":100039001,"comment_content":"思考题回答：目前能想到的方法是，使用工厂模式<br>在真正使用实例类前，根据定好的参数获得对应的实例类，然后再直接调用实例类的方法<br>如果新增ImageStore类，则调用的地方只需要更改传入的参数即可","like_count":0},{"had_liked":false,"id":161197,"user_name":"冬渐暖","can_delete":false,"product_type":"c1","uid":1586800,"ip_address":"","ucode":"907E41AAE9A36C","user_header":"https://static001.geekbang.org/account/avatar/00/18/36/70/00122b24.jpg","comment_is_top":false,"comment_ctime":1576142603,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576142603","product_id":100039001,"comment_content":"接口的一些规范<br>1.命名规范，不能吧实现的细节放到命名里面去。比如不要写getOrdersRefundFromWriter(）--》从写库读<br>2.封闭实现流程：只要让别人该传什么，能得到什么。比如别人调你的退款接口，不要跟他说你会改什么表的数据，怎么改。<br>3.为一群人去定义接口，而不是一个人。 他们用的是你的接口，而不是你的实现类<br>设计接口的时候，我们要多思考一下，这样的接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候，不需要任何接口定义的改动。<br><br>什么时候用：<br>容易变的地方。接口是稳定的，实现是容易变的。如果只有一种固定的实现就没必要去浪费时间搞了<br>","like_count":0},{"had_liked":false,"id":160753,"user_name":"乾坤瞬间","can_delete":false,"product_type":"c1","uid":1683130,"ip_address":"","ucode":"15BDCF29CBF8EB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","comment_is_top":false,"comment_ctime":1576029374,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576029374","product_id":100039001,"comment_content":"我觉得用反射技巧谈编程的都是耍流氓$因为反射好像只能在java中有$而且反射的本质对思考题没有有影响。我觉得使用 字符串作为入参+ 静态类封装一个以这个字符串为方法的生成不同类型的对象方法就行$很简单的不用搞那么复杂吧","like_count":0},{"had_liked":false,"id":160611,"user_name":"alls well","can_delete":false,"product_type":"c1","uid":1072439,"ip_address":"","ucode":"8E3EB5A3DF6E0D","user_header":"https://static001.geekbang.org/account/avatar/00/10/5d/37/8261fc68.jpg","comment_is_top":false,"comment_ctime":1575985899,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575985899","product_id":100039001,"comment_content":"基于接口而非实现编程，期待下一篇的课题引入","like_count":0},{"had_liked":false,"id":160510,"user_name":"蜗牛","can_delete":false,"product_type":"c1","uid":1086220,"ip_address":"","ucode":"01CC18F12E556D","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/0c/0a6a0d5e.jpg","comment_is_top":false,"comment_ctime":1575967241,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575967241","product_id":100039001,"comment_content":"利用工厂模式~","like_count":0},{"had_liked":false,"id":160464,"user_name":"tuyu","can_delete":false,"product_type":"c1","uid":1448863,"ip_address":"","ucode":"B235325B541408","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/BIRpwViaN51yynIeFonD7QRlwDCVtKibrG956NTxzEqibOZZVjhMMgibOPmd3VicfYxpknZsic1oJq8KicZvXkmmiajuQg/132","comment_is_top":false,"comment_ctime":1575955265,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575955265","product_id":100039001,"comment_content":"python路过, 想了半天不知道怎么实现interface的功能","like_count":0},{"had_liked":false,"id":160253,"user_name":"小毅","can_delete":false,"product_type":"c1","uid":1016799,"ip_address":"","ucode":"5651C740D68038","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/hg9Tsg2iaBeG6Q5mxiczjw1ph0OvhKziblEIiaOxg4gwQ0Dgia7Fw7pDQ0mM8AL5SJAm2Yavk1RmBJrFd9jKPBQRkOw/132","comment_is_top":false,"comment_ctime":1575899361,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575899361","product_id":100039001,"comment_content":"思考题大家都说了很多设计模式，我觉得从工程上来说IoC足矣","like_count":0},{"had_liked":false,"id":160235,"user_name":"wyf2317","can_delete":false,"product_type":"c1","uid":1236837,"ip_address":"","ucode":"7F3E61A6188B39","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ub4icibeRLzff8Nf6ORsolib9KHtmeu3d4cCCAFd3Xgah3v78WfDYQB7WKq9iaIPXPwHBxw7mkBP9wYxDGMT9m1Rbw/132","comment_is_top":false,"comment_ctime":1575896879,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1575896879","product_id":100039001,"comment_content":"赶紧使用简单工厂会更合适一点","like_count":0},{"had_liked":false,"id":160094,"user_name":"Geek_ecf7bb","can_delete":false,"product_type":"c1","uid":1523207,"ip_address":"","ucode":"5BF4DD62425BE0","user_header":"https://static001.geekbang.org/account/avatar/00/17/3e/07/c27b53b8.jpg","comment_is_top":false,"comment_ctime":1575868771,"is_pvip":false,"replies":[{"id":"61122","content":"等我有空了，集中答疑一下。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1575895697,"ip_address":"","comment_id":160094,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1575868771","product_id":100039001,"comment_content":"依赖注入可以。在注入配置初修改实现类，这样只需要修改一处就可以。<br>ps：不知道老师能不能在某个地方对课后习题进行一些讲解...","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477255,"discussion_content":"等我有空了，集中答疑一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575895697,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160049,"user_name":"cv0cv0","can_delete":false,"product_type":"c1","uid":1360093,"ip_address":"","ucode":"93FF9277F03FD0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLEIsgI4ub1VOKWtVOfouAzSqx8Yt8ibQEsAnwNJsJHmuJzzpQqG79HullvYwpic8hgiclgON2GwXSjw/132","comment_is_top":false,"comment_ctime":1575860624,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575860624","product_id":100039001,"comment_content":"写一个类，返回 ImageStore 就行了。","like_count":0},{"had_liked":false,"id":160032,"user_name":"爱水人家","can_delete":false,"product_type":"c1","uid":1730305,"ip_address":"","ucode":"0C94C6ACBC9CEB","user_header":"https://static001.geekbang.org/account/avatar/00/1a/67/01/44626cb9.jpg","comment_is_top":false,"comment_ctime":1575859299,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575859299","product_id":100039001,"comment_content":"停了这一章的讲课，外加看了留言，我彻底弄懂了抽象类和接口的使用情况了。抽象类是一种is-a关系，即“属于”关系。而接口是一组行为特性，一种“有xxxx的行为”。对于C++来说，本身没有定义接口，但是“接口”的设计感觉就是为了解决多继承的问题。比如留言榜第一条中的例子，吸血鬼分别继承自蝙蝠和人，那么它同时具有了蝙蝠和人的某些行为，这时就可以用接口。（道行不深，说错勿喷）","like_count":0},{"had_liked":false,"id":159172,"user_name":"lengrongfu","can_delete":false,"product_type":"c1","uid":1494681,"ip_address":"","ucode":"FD6F35CA561E0B","user_header":"https://static001.geekbang.org/account/avatar/00/16/ce/99/447c33d4.jpg","comment_is_top":false,"comment_ctime":1575552018,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575552018","product_id":100039001,"comment_content":"老师好，你定义接口中的方法如下<br>String upload(Image image, String bucketName)，这里面的buckeName是不是不应该作为upload的一个参数呢，这个参数感觉和具体实现有关系，比如私有存储可能没有bucket这个概念呢，这个参数应该最为aliyun的构造方法中的一个参数会更好一些吧。老师你觉得呢？","like_count":0},{"had_liked":false,"id":158929,"user_name":"progyoung","can_delete":false,"product_type":"c1","uid":1014692,"ip_address":"","ucode":"0B4898AE78F9F5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7b/a4/24955994.jpg","comment_is_top":false,"comment_ctime":1575503116,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575503116","product_id":100039001,"comment_content":"原则早就听过，但是结合具体的例子才真正理解了，这节课很有收获，谢谢老师。","like_count":0},{"had_liked":false,"id":157706,"user_name":"书中迷梦","can_delete":false,"product_type":"c1","uid":1103010,"ip_address":"","ucode":"1C6B697F41698F","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/a2/fa41c8a8.jpg","comment_is_top":false,"comment_ctime":1575249136,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575249136","product_id":100039001,"comment_content":"我觉得老师说的那个判断时候使用接口的标准，对于初学者或者项目经验欠缺的人来说有点困难，因为经验少没有办法判断出该实现以后时候经常变化！我觉得这些东西都是经过多次代码重构才能达到一个好的效果","like_count":0},{"had_liked":false,"id":157579,"user_name":"Joker","can_delete":false,"product_type":"c1","uid":1241567,"ip_address":"","ucode":"C42E11098E1B38","user_header":"https://static001.geekbang.org/account/avatar/00/12/f1/df/8ba04bec.jpg","comment_is_top":false,"comment_ctime":1575201655,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575201655","product_id":100039001,"comment_content":"课堂讨论：通过泛型来解决？","like_count":0},{"had_liked":false,"id":157052,"user_name":"CHS","can_delete":false,"product_type":"c1","uid":1240227,"ip_address":"","ucode":"3D8B2DABC0A1D6","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/a3/28763399.jpg","comment_is_top":false,"comment_ctime":1575019289,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575019289","product_id":100039001,"comment_content":"注解加反射，工厂模式","like_count":0},{"had_liked":false,"id":156671,"user_name":"Eric","can_delete":false,"product_type":"c1","uid":1575571,"ip_address":"","ucode":"7EB511C384BD7B","user_header":"https://static001.geekbang.org/account/avatar/00/18/0a/93/a189ec16.jpg","comment_is_top":false,"comment_ctime":1574933861,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574933861","product_id":100039001,"comment_content":"针对于文中的示例，其实不需要接口，只要把uploadToAliyun这类方法名取的抽象一点就可以实现了啊，所以接口存在的意义是更加优雅吗？强制新类实现同样的方法，并且不会取错方法名？望老师解答。","like_count":0},{"had_liked":false,"id":156538,"user_name":"我能走多远","can_delete":false,"product_type":"c1","uid":1240465,"ip_address":"","ucode":"07DF5D5DADFA3C","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/91/1d332031.jpg","comment_is_top":false,"comment_ctime":1574907197,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574907197","product_id":100039001,"comment_content":"作业，我是C语言开发。以我的理解来说吧。我们应该在process提供一个mode参数。供调用者选择使用共有云还是私有云。mode可以扩展很多。比如存储到硬盘或者redis服务器等等。<br>","like_count":0},{"had_liked":false,"id":156422,"user_name":"和你一起搬砖的胡大爷","can_delete":false,"product_type":"c1","uid":1008587,"ip_address":"","ucode":"54607F4E17917A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/cb/7c004188.jpg","comment_is_top":false,"comment_ctime":1574869464,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574869464","product_id":100039001,"comment_content":"老程序员在Spring的service层喜欢定义一个接口，再写实现，如果按业务需求理解，这个服务绝无可能会有第二种实现。请问这样做的意义是什么？","like_count":0},{"had_liked":false,"id":156347,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1574859711,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574859711","product_id":100039001,"comment_content":"思考题，依赖注入，变成入参，更上层的代码去控制","like_count":0},{"had_liked":false,"id":156323,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1574856474,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574856474","product_id":100039001,"comment_content":"课堂讨论：其实这个就需要使用到了设计模式的具体模式，创建型模式中的工厂模式。来进行替换","like_count":0},{"had_liked":false,"id":156206,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1574836351,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574836351","product_id":100039001,"comment_content":"诚如评论中所言，下一步怕是要引出来设计模式了。因为这里的问题就不单单是语言可以解决的了，语言只能提供基础的工具，如何组合和设计就是设计模式的内容了。<br>ps：这门课难度真不小，不过喜欢这种各抒己见的学习方式，既然老师安排了这么多课程，那就跟着学习下去吧","like_count":0},{"had_liked":false,"id":156077,"user_name":"星空123","can_delete":false,"product_type":"c1","uid":1596920,"ip_address":"","ucode":"E998A7C585671B","user_header":"https://static001.geekbang.org/account/avatar/00/18/5d/f8/7de2c1cc.jpg","comment_is_top":false,"comment_ctime":1574817404,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574817404","product_id":100039001,"comment_content":"利用接口来帮助代码解耦的重要性","like_count":0},{"had_liked":false,"id":155859,"user_name":"拒绝","can_delete":false,"product_type":"c1","uid":1335155,"ip_address":"","ucode":"CB0264C4D3FE17","user_header":"https://static001.geekbang.org/account/avatar/00/14/5f/73/bb3dc468.jpg","comment_is_top":false,"comment_ctime":1574769204,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574769204","product_id":100039001,"comment_content":"JAVA或DUBBO的SPI","like_count":0},{"had_liked":false,"id":155789,"user_name":"老杨同志","can_delete":false,"product_type":"c1","uid":1246199,"ip_address":"","ucode":"3F334F0CFD3DE6","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/f7/3a493bec.jpg","comment_is_top":false,"comment_ctime":1574757080,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574757080","product_id":100039001,"comment_content":"思考题的两种方式：1）使用工厂模式  2)java的SPI机制","like_count":0},{"had_liked":false,"id":155782,"user_name":"坎迪汪","can_delete":false,"product_type":"c1","uid":1017033,"ip_address":"","ucode":"5B1ADFA2AF2934","user_header":"https://static001.geekbang.org/account/avatar/00/0f/84/c9/cfed3a2f.jpg","comment_is_top":false,"comment_ctime":1574756193,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574756193","product_id":100039001,"comment_content":"接口设计不好也是白搭，重构特别重要，尽量快速重构。","like_count":0},{"had_liked":false,"id":155642,"user_name":"黄振宇","can_delete":false,"product_type":"c1","uid":1686397,"ip_address":"","ucode":"976BC7B46DA419","user_header":"https://static001.geekbang.org/account/avatar/00/19/bb/7d/26340713.jpg","comment_is_top":false,"comment_ctime":1574731883,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574731883","product_id":100039001,"comment_content":"我写的类就是基于实现而非接口的。。最近疯狂修改自己之前的代码","like_count":0},{"had_liked":false,"id":155631,"user_name":"小乙哥","can_delete":false,"product_type":"c1","uid":1063308,"ip_address":"","ucode":"C77E79BEA0C325","user_header":"https://static001.geekbang.org/account/avatar/00/10/39/8c/089525aa.jpg","comment_is_top":false,"comment_ctime":1574730669,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574730669","product_id":100039001,"comment_content":"基于抽象编程，分离变化的实现。和架构原则中的“分离变化点和稳定点”契合","like_count":0},{"had_liked":false,"id":155346,"user_name":"子夜2104","can_delete":false,"product_type":"c1","uid":1070286,"ip_address":"","ucode":"C4FF54AEA6002F","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/ce/92029d2f.jpg","comment_is_top":false,"comment_ctime":1574680525,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574680525","product_id":100039001,"comment_content":"基于接口而非实现编程。我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性、扩展性、可维护性。<br><br>接口就是提供了一个“功能列表”。我们在做一件事情时，都需要先有个整体的概念，然后再具体。那么接口就是我们在软件工程设计时的抽象概念，用于把握整体。<br><br>我们在定义接口的时候，一方面，命名要足够通用，不能包含跟具体实现相关的字眼；另一方面，与特定实现有关的方法不要定义在接口中。","like_count":0},{"had_liked":false,"id":155311,"user_name":"liliumss","can_delete":false,"product_type":"c1","uid":1333094,"ip_address":"","ucode":"A52AC5042F3115","user_header":"https://static001.geekbang.org/account/avatar/00/14/57/66/e57bdb18.jpg","comment_is_top":false,"comment_ctime":1574677199,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574677199","product_id":100039001,"comment_content":"目前spring框架是javaEE的事实标准，和非ioc环境下的demo比起来实现一些设计模式有不同之处","like_count":0},{"had_liked":false,"id":155281,"user_name":"Kevin","can_delete":false,"product_type":"c1","uid":1429627,"ip_address":"","ucode":"9DFFD6E3960CF7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJN64OCUT0Jp0h2Wiau9Os0o1WbwUeoq2QL0U2vZpib8ozPxo0XDiaPM9xcKfbkoBL24ztEHelxPIMVg/132","comment_is_top":false,"comment_ctime":1574673865,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574673865","product_id":100039001,"comment_content":"课堂讨论题<br>那行代码其实就是创建了一个对象，<br>那创建对象能不能面向接口，而不是实现呢？ <br>能。<br>欢迎收听下节，简单工厂与抽象工厂设计模式。<br>","like_count":0},{"had_liked":false,"id":155185,"user_name":"小乙哥","can_delete":false,"product_type":"c1","uid":1063308,"ip_address":"","ucode":"C77E79BEA0C325","user_header":"https://static001.geekbang.org/account/avatar/00/10/39/8c/089525aa.jpg","comment_is_top":false,"comment_ctime":1574657977,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574657977","product_id":100039001,"comment_content":"其实，spring就是为了解决这种依赖控制反转而生的，由spirng容器负责管理具体的装配细节","like_count":0},{"had_liked":false,"id":155165,"user_name":"辉仔lovers","can_delete":false,"product_type":"c1","uid":1210219,"ip_address":"","ucode":"3DC5B0CD0B8E71","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLVhJRVwJ0eVlC7zjNfWP6PP7VmUkF1X2m6qfh7Wic3NhAOz2fSGibF6LXLcJ59zOz7nBpCcByvtFjw/132","comment_is_top":false,"comment_ctime":1574654515,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574654515","product_id":100039001,"comment_content":"通过反射+配置文件的方式。将实现类的全限定名配置到配置文件中。加载配置文件，Class.forName()加载实现类。newInstance() 创建对象。简单点的方式是通过jdk spi 扩展机制。","like_count":0},{"had_liked":false,"id":155152,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1574652478,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574652478","product_id":100039001,"comment_content":"基于接口而非实现编程<br>使用场景：实现方式可能存在多个。或者目前实现只有一个，将来极有可能变化；或者目前已经有很多不同的实现方式。<br>注意事项：接口方法要是通用方法，命名要够抽象，不能与某个实现相关。<br><br>课后习题：<br>工厂模式+枚举。<br><br><br><br><br>","like_count":0},{"had_liked":false,"id":155068,"user_name":"Sheamus","can_delete":false,"product_type":"c1","uid":1248510,"ip_address":"","ucode":"F6EBDFF3575ADA","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/fe/4a1f045e.jpg","comment_is_top":false,"comment_ctime":1574643055,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574643055","product_id":100039001,"comment_content":"课后思考题思路:1. 配置+反射+工厂 2. 策略+工厂 ……感觉策略和配置+反射是一样的😂","like_count":0},{"had_liked":false,"id":154983,"user_name":"DullBird","can_delete":false,"product_type":"c1","uid":1110494,"ip_address":"","ucode":"80E2FD5F9687CB","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/de/3ebcbb3f.jpg","comment_is_top":false,"comment_ctime":1574608890,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574608890","product_id":100039001,"comment_content":"打卡，课后作业的代码。可以把主动new的代码，替换为工厂模式(简单工厂), 或者工厂方法。","like_count":0},{"had_liked":false,"id":154941,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1018370,"ip_address":"","ucode":"7A488CC6FE15E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","comment_is_top":false,"comment_ctime":1574600984,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574600984","product_id":100039001,"comment_content":"现在能想到的有两种方式：<br>1. 通过配置的方式，值为实现类的全限定名，在运行时将第8行代码换成使用反射构造对象的方式；<br>2. 通过工厂方法来实现对象的生产。","like_count":0},{"had_liked":false,"id":154882,"user_name":"William Ning","can_delete":false,"product_type":"c1","uid":1592279,"ip_address":"","ucode":"4DB8D05E69E5F3","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","comment_is_top":false,"comment_ctime":1574587552,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574587552","product_id":100039001,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":154809,"user_name":"逍遥思","can_delete":false,"product_type":"c1","uid":1015512,"ip_address":"","ucode":"340F05C786730F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/d8/92a98fb6.jpg","comment_is_top":false,"comment_ctime":1574570565,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574570565","product_id":100039001,"comment_content":"的确是想不到，一看大家的答案，原来是要引出下一讲的内容，这种模式非常好，无比期待！","like_count":0},{"had_liked":false,"id":154789,"user_name":"Tom.G","can_delete":false,"product_type":"c1","uid":1206034,"ip_address":"","ucode":"7929B45C1A51F8","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/12/5c6eb568.jpg","comment_is_top":false,"comment_ctime":1574565512,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574565512","product_id":100039001,"comment_content":"1.简单工厂，优点简单，缺乏灵活性<br>2.抽象工厂，优点方便扩展，缺点复杂<br>3.依赖注入，优点方便扩展，缺点需引入IoC组件","like_count":0},{"had_liked":false,"id":154764,"user_name":"allean","can_delete":false,"product_type":"c1","uid":1051470,"ip_address":"","ucode":"A0D2DB4F219EAA","user_header":"https://static001.geekbang.org/account/avatar/00/10/0b/4e/fd946cb2.jpg","comment_is_top":false,"comment_ctime":1574557582,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574557582","product_id":100039001,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":154708,"user_name":"Geek_6bf244","can_delete":false,"product_type":"c1","uid":1685861,"ip_address":"","ucode":"65D467C9C3272F","user_header":"","comment_is_top":false,"comment_ctime":1574517597,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574517597","product_id":100039001,"comment_content":"反射","like_count":0},{"had_liked":false,"id":154706,"user_name":"飞飞","can_delete":false,"product_type":"c1","uid":1657762,"ip_address":"","ucode":"E9644EE0AA8350","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKSjC36vSdPia1g9FMib8F5nT9iaI00SXl0FVOVicYGOLrfIhFDnlszMGKsNOq0hZEDpI6fLYtV9sBb6w/132","comment_is_top":false,"comment_ctime":1574516833,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574516833","product_id":100039001,"comment_content":"期待下周一的工厂模式课程","like_count":0},{"had_liked":false,"id":154691,"user_name":"2018","can_delete":false,"product_type":"c1","uid":1107371,"ip_address":"","ucode":"4C2CD47AD70177","user_header":"https://static001.geekbang.org/account/avatar/00/10/e5/ab/6fab2492.jpg","comment_is_top":false,"comment_ctime":1574512506,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574512506","product_id":100039001,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":154689,"user_name":"沈康","can_delete":false,"product_type":"c1","uid":1611025,"ip_address":"","ucode":"02AFA50738AB8E","user_header":"https://static001.geekbang.org/account/avatar/00/18/95/11/eb431e52.jpg","comment_is_top":false,"comment_ctime":1574511447,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574511447","product_id":100039001,"comment_content":"可能就是常说的策略模式+工厂模式吧。<br><br>以spring为例的话，在容器初始化利用容器的生命周期方法时候把相应为一组的相同接口实现 Map&lt;实现类型枚举，具体实现]&gt;注入到spring容器，<br>在运行时，需要程序新增一个使用的类型枚举输入，由容器查找该枚举的具体实现并调用。<br><br>这个和JNDI的实现方式差不多。","like_count":0},{"had_liked":false,"id":154605,"user_name":"段启超","can_delete":false,"product_type":"c1","uid":1258209,"ip_address":"","ucode":"164CF3018071B2","user_header":"https://static001.geekbang.org/account/avatar/00/13/32/e1/c9aacb37.jpg","comment_is_top":false,"comment_ctime":1574491559,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574491559","product_id":100039001,"comment_content":"可以用工厂模式+配置文件的方式来改进。<br>用工厂模式来产生不同类型的图片库实例，用配置文件来配置获取哪一个实例。","like_count":0},{"had_liked":false,"id":154604,"user_name":"相逢是缘","can_delete":false,"product_type":"c1","uid":1060730,"ip_address":"","ucode":"CB299F53A95654","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg","comment_is_top":false,"comment_ctime":1574490511,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574490511","product_id":100039001,"comment_content":"打卡：<br>1、接口实际是抽象的产物，是一种规范和约束（是做什么，而不是怎么做），是功能提供者提供给使用者的一个功能列表。Android中的HAL层的功能和接口定义就是这种思想。能定义出好的接口前提是对需求和业务理解比较清楚，如：需要抽象一个播放器接口，你现在用到的功能可能是开始播放start、停止播放stop。但是从对播放器的接口抽象看，这个接口定义不是很好的，因为后续业务需求还有暂定pause和回复resume的操作。<br>2、在进行接口定义时，命名要足够通用，不能包含和具体实现相关的字眼，特定实现的功能不要定义在接口中。<br>3、不要过度使用这个原则，基于接口编程的初衷是不必关心内部的实现，不依赖于具体的实现细节，当实现发生变化时，业务代码不需要改动，依次来降低代码之间的耦合性，提高代码的扩展性。如果在业务场景中，某个功能实现之后未来不可能被更改，那就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以。","like_count":0},{"had_liked":false,"id":154599,"user_name":"慢慢懂","can_delete":false,"product_type":"c1","uid":1694112,"ip_address":"","ucode":"6296BBF970AF13","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/a0/184e7cf6.jpg","comment_is_top":false,"comment_ctime":1574489469,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574489469","product_id":100039001,"comment_content":"这个就是为什么lavaver框架里面为什么要用接口的做契约的意义","like_count":0},{"had_liked":false,"id":154592,"user_name":"工画师","can_delete":false,"product_type":"c1","uid":1025850,"ip_address":"","ucode":"FFABE897B2CF8E","user_header":"","comment_is_top":false,"comment_ctime":1574488000,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574488000","product_id":100039001,"comment_content":"public void process(ImageStore imageStore) {}","like_count":0},{"had_liked":false,"id":154570,"user_name":"shniu","can_delete":false,"product_type":"c1","uid":1019555,"ip_address":"","ucode":"E64CD8BED96D8D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/a3/d7e5fe8a.jpg","comment_is_top":false,"comment_ctime":1574481049,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574481049","product_id":100039001,"comment_content":"依赖注入应该是一种思路，由容器去管理实例，将需要的对象注入进来，底层还是依赖了反射或者配置文件或者配置类，将对象组装抽离出来，这是容易发生变化的地方；SPI 也是一种灵活的方式","like_count":0},{"had_liked":false,"id":154555,"user_name":"乘坐Tornado的线程魔法师","can_delete":false,"product_type":"c1","uid":1132661,"ip_address":"","ucode":"C4C9915866E769","user_header":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","comment_is_top":false,"comment_ctime":1574479618,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574479618","product_id":100039001,"comment_content":"针对思考题的情景，就算是用了简单工厂模式或是抽象工厂模式，如果要替换图片存储方式，在传递参数的时候仍然要把AliyunImageStore类型的参数修改为PrivateImageStore类型，所以使用工厂模式与文中提到的方案相比，根本的好处（优势）在哪里呢？","like_count":0},{"had_liked":false,"id":154532,"user_name":"Lifelong Learning","can_delete":false,"product_type":"c1","uid":1173517,"ip_address":"","ucode":"3E39BED3E13FB4","user_header":"https://static001.geekbang.org/account/avatar/00/11/e8/0d/fcd95db8.jpg","comment_is_top":false,"comment_ctime":1574475167,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574475167","product_id":100039001,"comment_content":"基于接口进行设计,主要是“做什么”,而非“怎样做”,过度使用接口,就会导致为了“接口”而“接口”,这样其实和之前讲的,用IDE将类中的成员变量进行set和get方法的定义,这样就会破坏掉“面向对象”编程的原则,而如果乱用接口,或者不管什么类,都有一个对应的接口的实现,那么就会导致接口满天飞反而不利于代码的维护,看起来好像扩展性很好,其实写了一堆根本以后用不到的接口,这样的接口没有存在的意义,反而是冗余的","like_count":0},{"had_liked":false,"id":154485,"user_name":"sulatwx","can_delete":false,"product_type":"c1","uid":1348141,"ip_address":"","ucode":"366237F13DE8A7","user_header":"","comment_is_top":false,"comment_ctime":1574443093,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574443093","product_id":100039001,"comment_content":"使用工厂方法，可以根据参数生成不同的实例，再定义返回默认实例的方法getDefaultImgStore，使用时，尽量使用返回默认实例的，这样只修改返回的默认实例的即可","like_count":0},{"had_liked":false,"id":154474,"user_name":"Fun","can_delete":false,"product_type":"c1","uid":1145502,"ip_address":"","ucode":"5D89BA4C678785","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJdUGdEj3R25CrYqibPibYibibRicqUfyL4aTTPbMagyywjKMhXGZE37RTe7lEdvC4DibvtYpzg8zXvt9HQ/132","comment_is_top":false,"comment_ctime":1574438471,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574438471","product_id":100039001,"comment_content":"# day 11<br>今天学习基于接口而非实现编程。其实这本身已经带了设计的理念在内了。接口是综合考虑后设计出来的，它是思考的产物，是程序员价值的体现。","like_count":0},{"had_liked":false,"id":154440,"user_name":"James","can_delete":false,"product_type":"c1","uid":1134861,"ip_address":"","ucode":"48B0F2A334D1C1","user_header":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","comment_is_top":false,"comment_ctime":1574431102,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574431102","product_id":100039001,"comment_content":"第八行的例子,确实很多时候都会因为修改不同方式而大量修改.暂时想不到具体方法.<br>评论人才辈出啊.学习他人做法.","like_count":0},{"had_liked":false,"id":154429,"user_name":"斐波那契","can_delete":false,"product_type":"c1","uid":1464006,"ip_address":"","ucode":"85E2EBC01392B1","user_header":"https://static001.geekbang.org/account/avatar/00/16/56/c6/0b449bc6.jpg","comment_is_top":false,"comment_ctime":1574428384,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574428384","product_id":100039001,"comment_content":"老师 我有个疑问 项目中原则上是少调用I&#47;O 但是总感觉不能每一个新功能就写一套sql 那这样sql也臃肿 可复用之前写的sql业务上要调用好几个组合起来才行 有没有好的方法能平衡这两个情况","like_count":0},{"had_liked":false,"id":154424,"user_name":"汤小高","can_delete":false,"product_type":"c1","uid":1555565,"ip_address":"","ucode":"D4AB7766273D52","user_header":"https://static001.geekbang.org/account/avatar/00/17/bc/6d/f6f0a442.jpg","comment_is_top":false,"comment_ctime":1574427287,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574427287","product_id":100039001,"comment_content":"为了应对需求的不断变化，我们设计代码的时候就应该要隔离变化，把不变的和变化的隔离开来。针对接口编程而非实现编程就是实现这种目标的手段之一，通过接口把统一的、稳定的功能列表对外暴露，通过实现类把不稳定，可能变化的的实现隐藏。<br>具有稳定的，不会变化的功能的类不需要使用接口<br>具有不稳定的，可能会变化的功能的类需要使用接口隔离变化","like_count":0},{"had_liked":false,"id":154413,"user_name":"Warn","can_delete":false,"product_type":"c1","uid":1465310,"ip_address":"","ucode":"F2F7FCDB0940D0","user_header":"https://static001.geekbang.org/account/avatar/00/16/5b/de/152f1c2c.jpg","comment_is_top":false,"comment_ctime":1574424642,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574424642","product_id":100039001,"comment_content":"基于接口而非基于实现编程，抽象的全局思维。<br>讨论区，又学习了一圈。","like_count":0},{"had_liked":false,"id":154405,"user_name":"Jimbol","can_delete":false,"product_type":"c1","uid":1178008,"ip_address":"","ucode":"8D9190B3B3E08B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f9/98/95b13446.jpg","comment_is_top":false,"comment_ctime":1574423700,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574423700","product_id":100039001,"comment_content":"1.spring 的@Qualifer 或@Resource<br>2.使用抽象工厂模式，把具体创建对象的过程封装起来，在工厂内部进行替换","like_count":0},{"had_liked":false,"id":154399,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1574422831,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1574422831","product_id":100039001,"comment_content":"简单来看，可以使用工厂方法来实现","like_count":0},{"had_liked":false,"id":154390,"user_name":"Geek_862694","can_delete":false,"product_type":"c1","uid":1366022,"ip_address":"","ucode":"977B4195C7CFB1","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/ajNVdqHZLLBP7piae8iaHU7w2a4TyLKPFI7xiaia3Hias2ibMPftnFEic0lqGU315U70peQs7X3Kyd3bDgJjF6nBQg7xA/132","comment_is_top":false,"comment_ctime":1574421340,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574421340","product_id":100039001,"comment_content":"依赖注入 完美解决问题","like_count":0},{"had_liked":false,"id":154354,"user_name":"Heiky","can_delete":false,"product_type":"c1","uid":1623626,"ip_address":"","ucode":"03AA79E1BC4AE4","user_header":"https://static001.geekbang.org/account/avatar/00/18/c6/4a/3bd896fc.jpg","comment_is_top":false,"comment_ctime":1574413598,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574413598","product_id":100039001,"comment_content":"小争哥，是想引出简单工厂模式了","like_count":0},{"had_liked":false,"id":154340,"user_name":"小小征","can_delete":false,"product_type":"c1","uid":1358930,"ip_address":"","ucode":"335380EFE0FC61","user_header":"https://static001.geekbang.org/account/avatar/00/14/bc/52/52745d32.jpg","comment_is_top":false,"comment_ctime":1574411280,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574411280","product_id":100039001,"comment_content":"策略模式找到对应的实现类","like_count":0},{"had_liked":false,"id":154339,"user_name":"刘p辉","can_delete":false,"product_type":"c1","uid":1114781,"ip_address":"","ucode":"84851C7419474F","user_header":"https://static001.geekbang.org/account/avatar/00/11/02/9d/902cd381.jpg","comment_is_top":false,"comment_ctime":1574411170,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574411170","product_id":100039001,"comment_content":"配置+策略模式<br>1、定义接口，策略处理器实现接口，策略处理器有spring管理；<br>1、定义业务类型与策略处理器配置，初始化到内存中；<br>2、根据业务类型获取spring管理策略处理器的bean处理具体业务。","like_count":0},{"had_liked":false,"id":154329,"user_name":"明日","can_delete":false,"product_type":"c1","uid":1003917,"ip_address":"","ucode":"348899EC65AE8D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/51/8d/09f28606.jpg","comment_is_top":false,"comment_ctime":1574410225,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574410225","product_id":100039001,"comment_content":"工厂+配置  or  Java SPI","like_count":0},{"had_liked":false,"id":154327,"user_name":"向前走","can_delete":false,"product_type":"c1","uid":1112651,"ip_address":"","ucode":"8956E92DCEFB60","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/4b/c385f755.jpg","comment_is_top":false,"comment_ctime":1574409997,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574409997","product_id":100039001,"comment_content":"基于接口而不是实现类<br>1.主要表达的是基于抽象还不是具体实现,主要是为了他提高代码的灵活性和可维护性<br>2.如果我们的功能只有一种实现方法,未来也不可能被其它方式替换,则可以不为其设计接口<br>3.接口的命名最好通用,只包含具体实现类的共同特征","like_count":0},{"had_liked":false,"id":154324,"user_name":"学好习，做好人","can_delete":false,"product_type":"c1","uid":1205294,"ip_address":"","ucode":"C991643DB458E2","user_header":"https://static001.geekbang.org/account/avatar/00/12/64/2e/e70a317a.jpg","comment_is_top":false,"comment_ctime":1574409482,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574409482","product_id":100039001,"comment_content":"单纯的脱离现在各种各样的框架来解决这个问题的话，个人感觉依赖工厂+策略模式即可，最简单的工厂模式也能解决，为每种图片解决方式配置一个类型或者其他的标记，在使用的时候传入不同的flag来创建具体的处理方式，不管是阿里云还是私有云，或者说未来还有各种其他云，都是对图片处理的一种方式策略","like_count":0},{"had_liked":false,"id":154319,"user_name":"大脸猫","can_delete":false,"product_type":"c1","uid":1199628,"ip_address":"","ucode":"5BFDD8779589AC","user_header":"https://static001.geekbang.org/account/avatar/00/12/4e/0c/5f04e43e.jpg","comment_is_top":false,"comment_ctime":1574408636,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1574408636","product_id":100039001,"comment_content":"老师 我想请教个问题 使用接口时 例如<br>ImageStore imageStore = new AliyunImageStore(&#47;*省略构造函数*&#47;);<br> imagestore.upload(image, BUCKET_NAME);<br>我想用的是阿里云的存储 我需要 generateAccessToken()方法<br>但我直接new 出来返回的是ImageStore 接口 <br>我应该怎么调用generateAccessToken()方法呢 <br>意思是 我又想用接口的方法 又想调用自身的一些函数 这个怎么处理  一直没有想明白？","like_count":0,"discussions":[{"author":{"id":1433535,"avatar":"https://static001.geekbang.org/account/avatar/00/15/df/bf/96b50d1e.jpg","nickname":"😚 46","note":"","ucode":"EED0EBBBF80A43","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57063,"discussion_content":"generateAccessToken()没必要暴露给其他外部调用者，对外暴露upload和download即可，generateAccessToken()方法仅作为AliyunImageStore在upload和download所需的一个参数，因此可以将其封装成私有方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574564017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154300,"user_name":"程序员小跃","can_delete":false,"product_type":"c1","uid":1015483,"ip_address":"","ucode":"25BB96E0791A60","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","comment_is_top":false,"comment_ctime":1574406156,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"1574406156","product_id":100039001,"comment_content":"在《Head First设计模式》的结尾，就说过，设计模式只是一种思路，并不是让你每次都需要去考虑。而是要学会如何更好的运用，去适当的使用，而不是滥用。<br><br>设计模式算是锦上添花的操作，只有在必要的时候方可进行。你说搞一个基本的功能，或者是一个helloworld，那用设计模式，岂不是大材小用。<br><br>思考题：还是参考了大家的评论，引出了另一个设计模式“工厂模式”或者反射，期待下一节课","like_count":0,"discussions":[{"author":{"id":1032484,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c1/24/0ea08c9e.jpg","nickname":"柴柴777","note":"","ucode":"5208B935ECB6F7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55989,"discussion_content":"不是为了用而用  是需要用了才去用  ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574420604,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1015483,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","nickname":"程序员小跃","note":"","ucode":"25BB96E0791A60","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1032484,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c1/24/0ea08c9e.jpg","nickname":"柴柴777","note":"","ucode":"5208B935ECB6F7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56518,"discussion_content":"哈哈，那是自然，不然有时候大材小用了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574492774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":55989,"ip_address":""},"score":56518,"extra":""}]}]},{"had_liked":false,"id":154292,"user_name":"阿卡牛","can_delete":false,"product_type":"c1","uid":1022247,"ip_address":"","ucode":"0BC43A904C3199","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","comment_is_top":false,"comment_ctime":1574405082,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574405082","product_id":100039001,"comment_content":"基于不变而非细节编程:)","like_count":0},{"had_liked":false,"id":154289,"user_name":"不似旧日","can_delete":false,"product_type":"c1","uid":1161271,"ip_address":"","ucode":"DF4C5E3AB9570C","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","comment_is_top":false,"comment_ctime":1574404933,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574404933","product_id":100039001,"comment_content":"1.  接口和实现相分离，封装不稳定的实现，暴露稳定的接口。 <br>2. 函数名不能暴露任何实现细节。 <br>3. 封装具体的实现细节， 与特定实现有关的方法不要暴露到接口中 。<br>4. 先定义接口后写实现，不要反过来。<br>5. 过度使用接口","like_count":0},{"had_liked":false,"id":154285,"user_name":"爽了个爽","can_delete":false,"product_type":"c1","uid":1261326,"ip_address":"","ucode":"D5B10F75A02AB1","user_header":"https://static001.geekbang.org/account/avatar/00/13/3f/0e/3a2fb9ff.jpg","comment_is_top":false,"comment_ctime":1574403703,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574403703","product_id":100039001,"comment_content":"工厂模式   具体：SpringContextUtils.getBean（）+枚举类型。不同的实现类不同的类型。 这里用的spring自带的工厂，也可以自己实现工厂。","like_count":0},{"had_liked":false,"id":154277,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1574403036,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574403036","product_id":100039001,"comment_content":"类似spring的di","like_count":0},{"had_liked":false,"id":154274,"user_name":"连边","can_delete":false,"product_type":"c1","uid":1391748,"ip_address":"","ucode":"54B5DA38449728","user_header":"https://static001.geekbang.org/account/avatar/00/15/3c/84/608f679b.jpg","comment_is_top":false,"comment_ctime":1574402217,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574402217","product_id":100039001,"comment_content":"tp里边有一段现成的代码。配置文件里边配置 STORAGE_TYPE；然后再使用的时候创建链接。<br>Storage::connect(STORAGE_TYPE);<br>通过connect方法来调用不同的驱动。<br>&#47;**<br>     * 连接分布式文件系统<br>     * @access public<br>     * @param string $type 文件类型<br>     * @param array $options  配置数组<br>     * @return void<br>     *&#47;<br>    static public function connect($type=&#39;File&#39;,$options=array()) {<br>        $class  =   &#39;Think\\\\Storage\\\\Driver\\\\&#39;.ucwords($type);<br>        self::$handler = new $class($options);<br>    }","like_count":0},{"had_liked":false,"id":154267,"user_name":"Yuuuuu","can_delete":false,"product_type":"c1","uid":1233780,"ip_address":"","ucode":"64FD04761D2111","user_header":"https://static001.geekbang.org/account/avatar/00/12/d3/74/578b169d.jpg","comment_is_top":false,"comment_ctime":1574400532,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574400532","product_id":100039001,"comment_content":"使用工厂模式，根据调用工厂方法时传入的参数返回不同的实例。通过这种模式，把创建对象时类型的选择逻辑全部集中到工厂方法中，方便修改代码。对于配置文件+反射这种方式我觉得并不是很好。修改配置文件是修改，修改工厂的方法也是修改，在判断逻辑不复杂的情况下我觉得直接使用工厂模式更好。","like_count":0},{"had_liked":false,"id":154266,"user_name":"Todd  BD","can_delete":false,"product_type":"c1","uid":1015267,"ip_address":"","ucode":"21F27169916949","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/e3/ad6a4758.jpg","comment_is_top":false,"comment_ctime":1574400409,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574400409","product_id":100039001,"comment_content":"依赖倒置","like_count":0},{"had_liked":false,"id":154265,"user_name":"袁阳","can_delete":false,"product_type":"c1","uid":1329594,"ip_address":"","ucode":"B397F760CDC53A","user_header":"https://static001.geekbang.org/account/avatar/00/14/49/ba/02742d56.jpg","comment_is_top":false,"comment_ctime":1574399708,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574399708","product_id":100039001,"comment_content":"工厂模式","like_count":0},{"had_liked":false,"id":154262,"user_name":"熊斌","can_delete":false,"product_type":"c1","uid":1026280,"ip_address":"","ucode":"24D0C32F397113","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a8/e8/bc84c47d.jpg","comment_is_top":false,"comment_ctime":1574399408,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574399408","product_id":100039001,"comment_content":"平时开发的过程中，第八行这样的应该是类似于Sping里面依赖注入的原理来使用。<br><br>","like_count":0},{"had_liked":false,"id":154258,"user_name":"唐朝农民","can_delete":false,"product_type":"c1","uid":1133947,"ip_address":"","ucode":"6F8F43C6652225","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIaOAxRlZjFkGfRBn420LuAcyWkMrpq5iafGdqthX5icJPjql0ibZOAdafaqbfvw4ZpVzDmsaYglVXDw/132","comment_is_top":false,"comment_ctime":1574398990,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574398990","product_id":100039001,"comment_content":"有个问题，需不需抽象主要看稳不稳定，但是问题是很多时候我们不知道这是不稳定的。","like_count":0},{"had_liked":false,"id":154245,"user_name":"Vettel","can_delete":false,"product_type":"c1","uid":1639787,"ip_address":"","ucode":"FB3E71DD1E8E7C","user_header":"https://static001.geekbang.org/account/avatar/00/19/05/6b/d9d6d68b.jpg","comment_is_top":false,"comment_ctime":1574396426,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574396426","product_id":100039001,"comment_content":"可以参考Spring的IOC和DI吧，但其实说到底还是配置文件+反射+工厂,只是现在都用注解代替写配置文件","like_count":0},{"had_liked":false,"id":154238,"user_name":"拂尘","can_delete":false,"product_type":"c1","uid":1609964,"ip_address":"","ucode":"9563C002E4B06A","user_header":"https://static001.geekbang.org/account/avatar/00/18/90/ec/ede93589.jpg","comment_is_top":false,"comment_ctime":1574394918,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574394918","product_id":100039001,"comment_content":"超级感谢老师，感觉这真的是融汇贯通了。以前虽然对有些设计都有一些认识，但总是结合不到一起来，今天看了文章感觉真的是舒服了；自己看了工厂模式，看了springioc，理论总是说将创建对象交给ioc容器；但总想不到这样做有什么具体意义；以前也想过面向接口编程而非面向实现编；然后以后进行扩展的时候就几乎不用更改源代码；但不过我再想不是也应该要更改new的对象那里嘛；其实使用反射，配置文件也是想到了；但不过我一直也串联不起来或者是没想到；就一直感觉很不好；而且今天也对面向抽象编程而非面向实现有了新的认识；","like_count":0},{"had_liked":false,"id":154219,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1574392140,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574392140","product_id":100039001,"comment_content":"我也想说思考题 是要引出设计模式了哈哈哈哈","like_count":0},{"had_liked":false,"id":154209,"user_name":"Jesse","can_delete":false,"product_type":"c1","uid":1368038,"ip_address":"","ucode":"727CA882B84DA0","user_header":"https://static001.geekbang.org/account/avatar/00/14/df/e6/bd1b3c0b.jpg","comment_is_top":false,"comment_ctime":1574390885,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574390885","product_id":100039001,"comment_content":"思考题<br>用抽象工厂模式解决将process()中的具体的ImageStore类解耦出来，我觉得组合模式也可以，ImageProcessingJob持有一个ImageStore 引用，能达到同样的效果。","like_count":0},{"had_liked":false,"id":154208,"user_name":"塔兹米","can_delete":false,"product_type":"c1","uid":1425252,"ip_address":"","ucode":"1A58C81EF9B0A4","user_header":"https://static001.geekbang.org/account/avatar/00/15/bf/64/c9a0e913.jpg","comment_is_top":false,"comment_ctime":1574390855,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574390855","product_id":100039001,"comment_content":"打卡，<br>关于是思考题，我们用 Java 的解决方法就是spring的依赖注入了，在配置文件里，配置好实现类的地址，<br>将接口声明成，成员变量然后注入即可。","like_count":0},{"had_liked":false,"id":154207,"user_name":"moqifei","can_delete":false,"product_type":"c1","uid":1358410,"ip_address":"","ucode":"E0A6C858B78A3A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLGovXf8jNP5ZqHsDKLwajjicbFwpX9on1xiaJDR4CgWaWP2KcfOdneasBfKFo3dO3dwQyGG6WjK40w/132","comment_is_top":false,"comment_ctime":1574390836,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574390836","product_id":100039001,"comment_content":"抽象工厂设计模式可解","like_count":0},{"had_liked":false,"id":154199,"user_name":"Paper","can_delete":false,"product_type":"c1","uid":1305388,"ip_address":"","ucode":"7EE26C2E892899","user_header":"https://static001.geekbang.org/account/avatar/00/13/eb/2c/ab72fda4.jpg","comment_is_top":false,"comment_ctime":1574390237,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1574390237","product_id":100039001,"comment_content":"接口的使用前提还是要对系统变化进行预估，稳定性高的功能确实很没有必要。","like_count":0},{"had_liked":false,"id":154195,"user_name":"丿淡忘","can_delete":false,"product_type":"c1","uid":1139645,"ip_address":"","ucode":"604AE01961A026","user_header":"https://static001.geekbang.org/account/avatar/00/11/63/bd/80f587ad.jpg","comment_is_top":false,"comment_ctime":1574389865,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1574389865","product_id":100039001,"comment_content":"利用工厂方法","like_count":0},{"had_liked":false,"id":154193,"user_name":"scott","can_delete":false,"product_type":"c1","uid":1276032,"ip_address":"","ucode":"A3C507695AAF9D","user_header":"https://static001.geekbang.org/account/avatar/00/13/78/80/d2547579.jpg","comment_is_top":false,"comment_ctime":1574389832,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574389832","product_id":100039001,"comment_content":"“基于接口而非实现编程“，接口抽象出不稳定，容易变化的实现。实现变动少，不用过度设计接口。具体问题具体分析。","like_count":0},{"had_liked":false,"id":154184,"user_name":"Eden Ma","can_delete":false,"product_type":"c1","uid":1457408,"ip_address":"","ucode":"755312F0D154F9","user_header":"https://static001.geekbang.org/account/avatar/00/16/3d/00/7daa7403.jpg","comment_is_top":false,"comment_ctime":1574388723,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574388723","product_id":100039001,"comment_content":"思考题：用抽象工厂或者工厂模式把具体的存储方式放到具体的类中。","like_count":0},{"had_liked":false,"id":154167,"user_name":"平风造雨","can_delete":false,"product_type":"c1","uid":1014349,"ip_address":"","ucode":"F9EE4704F31E22","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/4d/b0228a1a.jpg","comment_is_top":false,"comment_ctime":1574386659,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574386659","product_id":100039001,"comment_content":"图片上传这个场景是容易想到接口的定义要相对抽象的，但是一些实际的业务场景，比如某个业务领域的查询服务，提供接口的时候，如果不把接口方法名写的具体一点，清楚一点，是不是也不太好","like_count":0},{"had_liked":false,"id":154163,"user_name":"小喵喵","can_delete":false,"product_type":"c1","uid":1062444,"ip_address":"","ucode":"FDBBB2A59DB8B6","user_header":"https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg","comment_is_top":false,"comment_ctime":1574386077,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574386077","product_id":100039001,"comment_content":"基于接口而非实现编程，就是为了应对未来的需求变化，那么请问下老师如何能预测系统未来可能的变化？","like_count":0},{"had_liked":false,"id":154162,"user_name":"小喵喵","can_delete":false,"product_type":"c1","uid":1062444,"ip_address":"","ucode":"FDBBB2A59DB8B6","user_header":"https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg","comment_is_top":false,"comment_ctime":1574386000,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574386000","product_id":100039001,"comment_content":"ImageStore imageStore = new PrivateImageStore(&#47;*省略构造函数*&#47;);<br>上游系统调用的时候，还不是一样依赖细节（PrivateImageStore）吗？<br>=的左边是接口，=右边是细节啊？","like_count":0},{"had_liked":false,"id":154158,"user_name":"deepz","can_delete":false,"product_type":"c1","uid":1570088,"ip_address":"","ucode":"4BD23A44CDB384","user_header":"https://static001.geekbang.org/account/avatar/00/17/f5/28/898a6947.jpg","comment_is_top":false,"comment_ctime":1574385898,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574385898","product_id":100039001,"comment_content":"各位大佬好..我有一个比较..的问题：<br>最近公司重构，表结构改了，之前某业务查询一行数据是，getByBusinessNo(),现在改成走主键id，所有用到的方法我都改了一遍。<br>问题：这种不同条件的业务，我是定义多个方法在接口吗？还是一个方法，传参指明条件这样？😬😬","like_count":0},{"had_liked":false,"id":154142,"user_name":"啦啦啦","can_delete":false,"product_type":"c1","uid":1131687,"ip_address":"","ucode":"6B12EC90A62525","user_header":"https://static001.geekbang.org/account/avatar/00/11/44/a7/171c1e86.jpg","comment_is_top":false,"comment_ctime":1574384552,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574384552","product_id":100039001,"comment_content":"写代码要有抽象意识，把变化多的业务抽象出来，让调用者依赖抽象，不依赖具体实现，可以用接口来实现这种方式，同时也不要每个类都用接口实现，只把变化多的不稳定的搞成接口","like_count":0},{"had_liked":false,"id":154139,"user_name":"小畅","can_delete":false,"product_type":"c1","uid":1322880,"ip_address":"","ucode":"D031CC07CD564E","user_header":"","comment_is_top":false,"comment_ctime":1574384342,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574384342","product_id":100039001,"comment_content":"看到这里差不多要去补习设计模式基础理论了，项目用的少，看来要多用才有所体会","like_count":0},{"had_liked":false,"id":154128,"user_name":"张飞online","can_delete":false,"product_type":"c1","uid":1249136,"ip_address":"","ucode":"C9787E4B35888C","user_header":"https://static001.geekbang.org/account/avatar/00/13/0f/70/759b1567.jpg","comment_is_top":false,"comment_ctime":1574383793,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574383793","product_id":100039001,"comment_content":"最后一问，应该使用接口类作为参数啊，不然定义接口就没有意义了，接口就是为了下面都遵循，上层调用简单，多态的意义","like_count":0},{"had_liked":false,"id":154120,"user_name":"何妨","can_delete":false,"product_type":"c1","uid":1385377,"ip_address":"","ucode":"EC3983BFF7992A","user_header":"https://static001.geekbang.org/account/avatar/00/15/23/a1/b08f3ee7.jpg","comment_is_top":false,"comment_ctime":1574382918,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574382918","product_id":100039001,"comment_content":"重点:1.在定义接口的时候，不要暴露任何实现细节。接口的定义只表明做什么，而不是怎么做。<br>2.接口勿滥用，权衡接口在系统中的作用","like_count":0},{"had_liked":false,"id":154118,"user_name":"WIZ","can_delete":false,"product_type":"c1","uid":1260348,"ip_address":"","ucode":"313AF84674475C","user_header":"https://static001.geekbang.org/account/avatar/00/13/3b/3c/2947127c.jpg","comment_is_top":false,"comment_ctime":1574382876,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574382876","product_id":100039001,"comment_content":"打卡，简略可以用反射+配置文件","like_count":0},{"had_liked":false,"id":154116,"user_name":"安静的boy","can_delete":false,"product_type":"c1","uid":1196475,"ip_address":"","ucode":"F5F44B75228A85","user_header":"https://static001.geekbang.org/account/avatar/00/12/41/bb/21ce60d2.jpg","comment_is_top":false,"comment_ctime":1574382717,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574382717","product_id":100039001,"comment_content":"读完这篇文章终于明白，基于接口编程而非实现编程中的实现是什么意思了。以前总觉着用一个功能不就是需要编写其实现吗，一个接口也需要去实现，怎么就不要基于实现编程了？<br>原来使我把实现这个概念理解错了，实现其实指的是一个完整功能的实现(比如上传图片)细节，这些实现细节是基于特定场景的，后期需求变动后，这些实现细节可能就不能在使用，如果暴露给用户，那需求变动后，改动将会很大。而我们将一个完整的不包含细节的方法提供出去，就算我们改动了具体的实现细节，用户那边也不会变动，提高了系统的稳定性和扩展性。","like_count":0},{"had_liked":false,"id":154112,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1574382572,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574382572","product_id":100039001,"comment_content":"设计模式_09：<br>1. 对于第8行的问题，可以使用基于KV的模式统一配置。<br>2. 今天的内容给我的一个感想是，旧话重提：先思考，后编码。对于很多程序员，编码的过程伴随着快感，于是就像需求的翻译器一样(当然，产品同事一直这么认为)，拿了需求立马开干，一顿操作就完成了新需求，然后，一个小的改动需要重新梳理和修改核心流程，每天加班，时间久了代码完全改不动了。就像文中所说，实现没有变化的业务直接使用实现类，但这个标准在实践中并不那么容易辨别，需要长期的试错式的思考和实践来掌握尺度。","like_count":0},{"had_liked":false,"id":154104,"user_name":"傲慢与偏执，","can_delete":false,"product_type":"c1","uid":1236496,"ip_address":"","ucode":"E9F81223DFAD24","user_header":"https://static001.geekbang.org/account/avatar/00/12/de/10/9f15527d.jpg","comment_is_top":false,"comment_ctime":1574382024,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574382024","product_id":100039001,"comment_content":" 使用工厂模式 创建不同实现","like_count":0},{"had_liked":false,"id":154103,"user_name":"Flash","can_delete":false,"product_type":"c1","uid":1236163,"ip_address":"","ucode":"E285075C9E0B02","user_header":"https://static001.geekbang.org/account/avatar/00/12/dc/c3/e4ba51d5.jpg","comment_is_top":false,"comment_ctime":1574381973,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574381973","product_id":100039001,"comment_content":"思考题:<br>利用AOP切面，将散落的处理图片上传的逻辑集中到切面中处理。","like_count":0},{"had_liked":false,"id":154097,"user_name":"Sirius","can_delete":false,"product_type":"c1","uid":1006740,"ip_address":"","ucode":"257A1F0FC03821","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/94/d8dc54f2.jpg","comment_is_top":false,"comment_ctime":1574381459,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574381459","product_id":100039001,"comment_content":"Ioc","like_count":0},{"had_liked":false,"id":154094,"user_name":"№修罗★幻影","can_delete":false,"product_type":"c1","uid":1010302,"ip_address":"","ucode":"FF89FB2C584833","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6a/7e/a6af4c00.jpg","comment_is_top":false,"comment_ctime":1574380961,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574380961","product_id":100039001,"comment_content":"思考题：<br>可以考虑控制反转(IoC)的思路，不自己主动去实例化(new)，而且依赖容器自动注入(反射)，这样只需要在配置文件中调整好具体实现的类路径，就能完成替换，代码所有引用的地方都无需修改。","like_count":0},{"had_liked":false,"id":154093,"user_name":"刘大明","can_delete":false,"product_type":"c1","uid":1035081,"ip_address":"","ucode":"83C063FBD9BF2B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cb/49/0b9ffc8e.jpg","comment_is_top":false,"comment_ctime":1574380949,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574380949","product_id":100039001,"comment_content":"读完这篇真的感觉以前写的接口很多都包含了实现细节，而且完全不知道这种方式确实不利于需求的变化。要培养自己基于接口编程的思维模式。<br>思考题里面可以用简单工厂模式来把具体的类型放到工厂里面去对方提供方法。","like_count":0},{"had_liked":false,"id":154088,"user_name":"探索无止境","can_delete":false,"product_type":"c1","uid":1044178,"ip_address":"","ucode":"91D2A9907DFA79","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/d2/7024431c.jpg","comment_is_top":false,"comment_ctime":1574380579,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574380579","product_id":100039001,"comment_content":"控制反转，交给第三方容器来注入","like_count":0},{"had_liked":false,"id":154086,"user_name":"冀云","can_delete":false,"product_type":"c1","uid":1175189,"ip_address":"","ucode":"01E3B55795E90A","user_header":"https://static001.geekbang.org/account/avatar/00/11/ee/95/6fe64a45.jpg","comment_is_top":false,"comment_ctime":1574380470,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574380470","product_id":100039001,"comment_content":"下节课要讲工厂模式了，提前埋下了伏笔！","like_count":0},{"had_liked":false,"id":154083,"user_name":"乐溪溪520","can_delete":false,"product_type":"c1","uid":1168975,"ip_address":"","ucode":"99FBCEC0083E06","user_header":"https://static001.geekbang.org/account/avatar/00/11/d6/4f/008f9d6a.jpg","comment_is_top":false,"comment_ctime":1574380029,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574380029","product_id":100039001,"comment_content":"通过工厂方法设计模式，将具体的实现抽离出来。","like_count":0},{"had_liked":false,"id":154082,"user_name":"L🚲🐱","can_delete":false,"product_type":"c1","uid":1577856,"ip_address":"","ucode":"08A012739614DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","comment_is_top":false,"comment_ctime":1574380024,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574380024","product_id":100039001,"comment_content":"如果是java 就用spring 容器管理接口 这样接口就统一管理了，不需要我们修改大量的代码","like_count":0},{"had_liked":false,"id":154079,"user_name":"Cy23","can_delete":false,"product_type":"c1","uid":1591293,"ip_address":"","ucode":"8DC561C5151758","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/fd/895f0c27.jpg","comment_is_top":false,"comment_ctime":1574379567,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574379567","product_id":100039001,"comment_content":"原来对接口的作用只是模糊的了解，这回理解的更深刻了，<br>课后讨论题：我觉得应该有一个类可以通过读取全局配置然后选择当前用哪一个图片上传下载，然后具体的调用类直接调用该类方法，而没必要了解具体的选择及实现","like_count":0},{"had_liked":false,"id":154400,"user_name":"zeta","can_delete":false,"product_type":"c1","uid":1255260,"ip_address":"","ucode":"AF84A72375827C","user_header":"https://static001.geekbang.org/account/avatar/00/13/27/5c/ee2a876f.jpg","comment_is_top":false,"comment_ctime":1574423004,"is_pvip":false,"discussion_count":62,"race_medal":0,"score":"2565669898716","product_id":100039001,"comment_content":"其实这篇和上一篇可以讲的更好的。首先，我反对接口是has-a的说法，我坚持接口的语义是behaves like(这个其实我也是在某一本书上看的). 咱们看下哪个更通顺和达意，A AliyunImageStorage has a DataStorage. or A AliyunImageStorage behaves like a DataStorage? 除非你在第一句加上 A AliyunImageStorage has some behaviors of DataStorage. 但这基本也就是behaves like的意思了。<br>第二，我觉得咬文嚼字的确没有什么意义，但为什么说上述话题，难道讲接口的例子不用出现接口多重继承么，引用我之前留言：拿一个C++中举的多重继承例子来说，吸血鬼分别继承自蝙蝠和人，那么吸血鬼is a蝙蝠么？吸血鬼is a人么？所以其实两个都不是，这就是设计上的语义问题。这里缺失了除了is a的另一个概念，behaves like，也就是多重继承的真义实际上是behaves like，也就是接口的意义。A vampire behaves like humans and bats. 而这是接口能多重的原因，一个类可以具有多重行为，但是不能是多种东西。<br>所以其实也就是说，只有当前模块涉及到抽象行为的时候，才有必要设计接口，才有可能利用接口多重继承的特性来更好的将各种行为分组。","like_count":597,"discussions":[{"author":{"id":1358045,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b8/dd/37726c34.jpg","nickname":"小马哥","note":"","ucode":"B2C0FF38F8C9BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371883,"discussion_content":"代理模式的静态代理与装饰器实现上几乎一样, 起到的作用也差不多都是对代码进行增强; 不过在实现的目的上: 代理模式一般用于对业务代码增加额外非业务功能(例如: 为业务代码打日志, 两者代码功能不同); 装饰器模式一般用于对业务代码增强(例如java的io流: 为字节流增加缓冲, 两者代码是进化增强)","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1620037227,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2152306,"avatar":"https://static001.geekbang.org/account/avatar/00/20/d7/72/cbef720d.jpg","nickname":"鲁鸣","note":"","ucode":"974BA3C3E64630","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305526,"discussion_content":"看不懂加一","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599982969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1097943,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJB6qS9nxicvToSX4fTrDNv7OVBtsrfr6VwLjPLcwZS8ibicczM15qVx473KgrYQg0TIFeibXD0RgK6WQ/132","nickname":"传志","note":"","ucode":"2B0F67BCFCB3D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":235528,"discussion_content":"静态代理硬编码，通过继承多态等特性完成功能增强，动态代理其实就是动态的生成代理类字节码，比如你通过反射拿到方法名称，参数列表等，你可以自己生成一个java文件，然后编译在加载到jvm中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587043690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1196864,"avatar":"https://static001.geekbang.org/account/avatar/00/12/43/40/e7ef18de.jpg","nickname":"嘉一","note":"","ucode":"8D16BD0B75B019","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":232151,"discussion_content":"其实Java里面实现动态代理的底层技术是反射，你可以把typescript里面的装饰器实现的功能就是Java里面反射技术实现的功能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586857052,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1732683,"avatar":"","nickname":"Geek_323c91","note":"","ucode":"AE946A94605456","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213855,"discussion_content":"我也看不懂了 懵逼  ，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585127877,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154551,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1015754,"ip_address":"","ucode":"00DF2FEC58D2E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","comment_is_top":false,"comment_ctime":1574479205,"is_pvip":false,"discussion_count":11,"race_medal":0,"score":"1045251532133","product_id":100039001,"comment_content":"到目前为止老师所讲理的的理论都懂～至于思考题用简单工厂，反射等方式感觉都不行。给老师提个小小的建议：能不能和隔壁的『MySQL实现45讲』的专栏一样在下一节课程的末尾集中回答一下上一节课程的课后习题？感谢","like_count":243},{"had_liked":false,"id":154080,"user_name":"业余爱好者","can_delete":false,"product_type":"c1","uid":1482915,"ip_address":"","ucode":"A890935A982988","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","comment_is_top":false,"comment_ctime":1574379829,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"658704376117","product_id":100039001,"comment_content":"关于抽象和函数命名的问题，不知道哪个大佬说过这么一句话: <br><br>   每个优秀的程序员都知道，不应该定义一个attackBaghdad() ‘袭击巴格达‘ 的方法，而是应该把城市作为函数的参数 attack(city)。","like_count":153,"discussions":[{"author":{"id":2098988,"avatar":"https://static001.geekbang.org/account/avatar/00/20/07/2c/106f95e2.jpg","nickname":"NSblacker","note":"","ucode":"9B134D217F9E70","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346403,"discussion_content":"哎 拿UITableView类比了半天，在代码设计上和这节课的说的代理真是差异太大了；如你这般解释好像能说通，但是这就要考虑究竟如何来定义代理模式了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611935125,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154062,"user_name":"香蕉派2号","can_delete":false,"product_type":"c1","uid":1587685,"ip_address":"","ucode":"1BB5A449B6EA5E","user_header":"https://static001.geekbang.org/account/avatar/00/18/39/e5/53b1f697.jpg","comment_is_top":false,"comment_ctime":1574372402,"is_pvip":false,"discussion_count":18,"race_medal":0,"score":"452545938482","product_id":100039001,"comment_content":"思考题<br>解决方案=配置文件+反射+工厂模式","like_count":105,"discussions":[{"author":{"id":2831233,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/33/81/3693f4d9.jpg","nickname":"坚定的抢手","note":"","ucode":"E5A5EC6196C518","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575033,"discussion_content":"对象指针＋类成员函数指针＋可变参数模板，就能支持代理了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654563408,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154084,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1574380081,"is_pvip":true,"discussion_count":14,"race_medal":0,"score":"405301305905","product_id":100039001,"comment_content":"关于思考题我想出两种方法改进：简单工厂方法和使用反射。<br><br>1、简单工厂方法<br>ImageStore imageStore = ImageStoreFactory.newInstance(SOTRE_TYPE_CONFIG);<br>config文件可以写类似properties的文件，使用key-value存储。<br><br>缺点：再新增另一种存储手段时，需要修改工厂类和添加新的类。修改工厂类，违反了开放-封闭原则。<br><br>那有没有更好一点的方法呢？<br><br>2、使用反射。<br>在配置文件中定义需要的image store类型。<br>在ProcessJob中<br>ImageStore store = (ImageStore) Class.forName(STORE_CLASS)<br>    .newInstance();<br><br>缺点：使用反射，在大量创建对象时会有性能损失。<br><br>关于减少ProcessJob中的修改，还有没有更好的方法呢？我只是抛砖引玉，希望和大家一起讨论。具体实现：https:&#47;&#47;github.com&#47;gdhucoder&#47;Algorithms4&#47;tree&#47;master&#47;geekbang&#47;designpattern&#47;u009<br><br>补充：<br>关于access token：Aliyun的AccessToken时有expireTime时限的。不需要每次重新获取，过期时重新获取即可。","like_count":94,"discussions":[{"author":{"id":1444122,"avatar":"https://static001.geekbang.org/account/avatar/00/16/09/1a/e0f95684.jpg","nickname":"空空","note":"","ucode":"8F6EFE5A6F6F64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":156434,"discussion_content":"为什么不使用多态呢？\npublic class ImageProcessingJob {\n  private static final String BUCKET_NAME = &#34;ai_images_bucket&#34;;\n  //...省略其他无关代码...\n  \n  public void process(ImageStore imageStore) {\n    Image image = ...;//处理图片，并封装为Image对象\n    imagestore.upload(image, BUCKET_NAME);\n  }","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1580363048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1437667,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ef/e3/db895077.jpg","nickname":"流放","note":"","ucode":"21E30A37E7F139","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56300,"discussion_content":"简单工厂模式改成抽象工厂模式不就保护了开闭原则","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574470824,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1437667,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ef/e3/db895077.jpg","nickname":"流放","note":"","ucode":"21E30A37E7F139","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56451,"discussion_content":"我在想抽象工厂仅需要增加代码，不使用反射的话，还是要修改客户端代码。还不如直接用反射，不用抽象工厂了。\n不知道我想的是否有问题？还望指出，谢谢！","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574481592,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":56300,"ip_address":""},"score":56451,"extra":""}]},{"author":{"id":1532404,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIvUlicgrWtibbDzwhLw5cQrDSy2JuE1mVvmXq11KQIwpLicgDuWfpp9asE0VCN6HhibPDWn7wBc2lfmA/132","nickname":"a、","note":"","ucode":"590FE8DB111492","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":64311,"discussion_content":"我觉得SPI是不是也可以？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574945179,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1532404,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIvUlicgrWtibbDzwhLw5cQrDSy2JuE1mVvmXq11KQIwpLicgDuWfpp9asE0VCN6HhibPDWn7wBc2lfmA/132","nickname":"a、","note":"","ucode":"590FE8DB111492","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":65117,"discussion_content":"service provider interface 会不会有点大材小用了？而且spi底层也是用反射。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574984405,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":64311,"ip_address":""},"score":65117,"extra":""}]},{"author":{"id":1248510,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0c/fe/4a1f045e.jpg","nickname":"Sheamus","note":"","ucode":"F6EBDFF3575ADA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57766,"discussion_content":"对于web项目来说，Spring注入List注入了解一下，只需要简单工厂和在接口配置一个方法即可","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574642768,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1248510,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0c/fe/4a1f045e.jpg","nickname":"Sheamus","note":"","ucode":"F6EBDFF3575ADA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57900,"discussion_content":"好的，谢谢建议！有段时间没做web项目了，spring都忘光了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574645874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":57766,"ip_address":""},"score":57900,"extra":""}]},{"author":{"id":1015483,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","nickname":"程序员小跃","note":"","ucode":"25BB96E0791A60","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55855,"discussion_content":"各自肯定都会缺点，得根绝实际情况，选择最优的即可","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574405996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1015483,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","nickname":"程序员小跃","note":"","ucode":"25BB96E0791A60","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":55914,"discussion_content":"谢谢回复！\n菜鸟和高手下象棋，看似两个人落子的位置都是当前棋面上对他来说最有利的位置（局部最优），最后菜鸟败给高手。菜鸟只能看1-2步棋，而高手能看的更远，我想这就是我们为什么要学习设计模式吧！","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1574411997,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":55855,"ip_address":""},"score":55914,"extra":""},{"author":{"id":1015483,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","nickname":"程序员小跃","note":"","ucode":"25BB96E0791A60","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":55955,"discussion_content":"正解，这就是为什么这么多人在学习吧，加油","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574416779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":55914,"ip_address":""},"score":55955,"extra":""}]},{"author":{"id":1242573,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f5/cd/3890be04.jpg","nickname":"小川","note":"","ucode":"D462222DDBB978","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308195,"discussion_content":"启动参数 ＋ Spring Bean 工厂，可以很好的解决问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600868236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1202782,"avatar":"https://static001.geekbang.org/account/avatar/00/12/5a/5e/a897cb0d.jpg","nickname":"grey927","note":"","ucode":"833E02ED835B4A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290484,"discussion_content":"使用Spring的Bean工厂就可以了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594485588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1182516,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0b/34/f41d73a4.jpg","nickname":"王盛武","note":"","ucode":"DE7EF246D3DCE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":66789,"discussion_content":"简单工厂方法就可以了，不需要过度设计","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575107131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1182516,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0b/34/f41d73a4.jpg","nickname":"王盛武","note":"","ucode":"DE7EF246D3DCE8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":66820,"discussion_content":"学了不少，总想用一下🤣","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575108744,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":66789,"ip_address":""},"score":66820,"extra":""}]}]},{"had_liked":false,"id":154057,"user_name":"秋惊蛰","can_delete":false,"product_type":"c1","uid":1620344,"ip_address":"","ucode":"3D9A6D5CA9C79F","user_header":"https://static001.geekbang.org/account/avatar/00/18/b9/78/a5804dae.jpg","comment_is_top":false,"comment_ctime":1574360501,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"233502594485","product_id":100039001,"comment_content":"依赖注入，从外部构建具体类的对象，传入使用的地方","like_count":54,"discussions":[{"author":{"id":2062402,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKOnpl8fRB9r2vED2s8j7Arwbn2K6M6HUBWNjgoqV4uqe94fTGK4WGpOJLeRxXcBXk3dp23eQR0AQ/132","nickname":"吴钩","note":"","ucode":"0EB50E8144BCDE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393595,"discussion_content":"那修改Type参数的地方是不是和原文一样多呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1631508263,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1024341,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a1/55/cff2322c.jpg","nickname":"雪中亮","note":"","ucode":"B294FDFF9F13E8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56664,"discussion_content":"spring依赖注入真香，直接@Resource(Type = ...)注入，需要更换实现时，直接将Type指定的类型改了就好。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574506643,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154336,"user_name":"雷霹雳的爸爸","can_delete":false,"product_type":"c1","uid":1119490,"ip_address":"","ucode":"99BBA6D83DD11F","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/02/66f65388.jpg","comment_is_top":false,"comment_ctime":1574411067,"is_pvip":true,"discussion_count":4,"race_medal":0,"score":"139013364539","product_id":100039001,"comment_content":"要不是有一开始的课程大纲，我以为课堂讨论是要启发大家，在下节就要讲创建型模式，工厂模式，工厂方法什么的了<br><br>但转念一想，这想法或许太肤浅了，毕竟大多数创建型方法都有一个明显的对具体类型的依赖（这里先预先排除抽象工厂，觉得有点小题大做这样搞），都不是一个最终能让人感到内心宁静的做法<br><br>这节既然讲的是依赖于抽象而不是依赖于具体，那比较得瑟的玩儿法恐怕应该是直接在ImageProcessingJob类和ImageStore接口这两个类型关系上充分体现出依赖倒置的思路，把最后一点执行创建ImageStore类型实例的痕迹彻底关在ImageProcessingJob的门外，虽然必然得有人去考虑实际至少调一下ImageStore具体类型实例的这个创建过程，但ImageProcessingJob这爷是不打算操心这事了，它只需要留个口子，让别人把ImageProcessingJob放到自己锅里，自己就可以开始炒菜了<br><br>也就是从形式上，ImageProcessingJob这个类只需要保留对ImageStore接口的依赖就可以了，具体留口子的手段则要考虑依赖注入，形式上有两种：<br><br>+ 一种是可能更OO样子的一点，即声明一个ImageStore的field在ImageProcessingJob类里面<br>  - 如果说有什么好处，恩，可以理解为能对客户程序隐藏了ImageStore类型的信息，是的，连类型信息都隐藏掉；好吧，还是得关心别人，毕竟这世界上不是仅有自己一个<br>  - 具体操作起来，由于不能声明field时候直接new，要不又变回去了，但又不能NPE吧，所以不考虑创建，我还是得考虑怎么把实例请进来，就是上面说的至少留个口子<br>  - 这时候可能不得不借助依赖注入的帮助了（否则就是依赖查找，还是工厂），即<br>  - 通过ImageProcessingJob的构造函数注入或者利用field注入来获取ImageStore接口的实例，或者ImageProcessingJob如果依赖项多，Builder一下也很好<br>  - 毕竟ImageProcessingJob这个类型在我们讨论的上下文里面是如此具体的一个类，就不过分追溯它的创建责任及执行在哪里了<br>+ 另一种，表面粗暴直接看似问题多多，但是细品也有点意思的，那就是process方法直接增加一个ImageStore的参数就完了，OMG我在干什么<br>  - 没有B方案的设计自身无法证明自己更好<br>  - 相对于上面的，直接的问题是会对process方法直接依赖的客户程序会和ImageStore这个类型产生耦合<br>    * 如果客户程序是一个类（还能是什么？），要么有一个field等着inject进来，要么是通过调用process的method传进来，要么就是无中生有（直接new了或用创建型模式）<br>    * 这都可能造成没有充分的设计隔离，至少让客户程序造成信息冗余，承担了不必要的职责等问题<br>  - 但事实上也不是完全没好处，这种灵活性体现在它没有把ImageStore的逻辑固化在任一个ImageProcessingJob实例里面<br>    * 考虑上面第三类无中生有的方式，假设是创建型的工厂方法或类似手段，则可以提供对method参数（业务层面的动态输入，例如最终操作用户的提供的值）的响应能力<br>    * 这和，执行排序算法骨架确定，但是需要给定两个元素（复杂对象）比较规则这种思路有相似之处，毕竟我需要的是对方的能力而不是对方的数据或者数据视图，这时候这么做还是很有诱惑力的<br>  - 如果脱离开场景，实际上这种动态性还更强，但问题就在于这种动态性会不会对于具体场景有价值<br>  - 从这个实例上看，也许没这么明显，因为不同的对象存储后端更有可能是环境（测试、生产？但12 factor让我们...好歹测试环境还是也上云吧）不同造成的，而非基于动态的用户信息输入<br>  - 但，事无绝对吧，假设，用户有选择我要针对具体这一张，我特么上传那一刻选择一个存储后端的需求<br>    - 然后为了方便用户，用户竟然可以勾选，以后使用同样地选择...<br>    - 我觉得除了脑子进水的犬类应该没人会干这种没问题制造问题也要上的方案吧<br> <br> 所以综上所属，还是field一个ImageStore接口来搞吧<br><br>这极客时间也让人想吐槽，能敲2000字，结果就只留这么大点儿一个输入框...你要不就限制200字我还能少敲一点...我这写的兴起还得外面写完了贴过来...","like_count":32,"discussions":[{"author":{"id":1740639,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/8f/5f/c6d10aa8.jpg","nickname":"码弓手","note":"","ucode":"B5D1EC8424B5D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":86308,"discussion_content":"我竟然看完了，似乎是个戏精来的感觉","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1576593567,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1119490,"avatar":"https://static001.geekbang.org/account/avatar/00/11/15/02/66f65388.jpg","nickname":"雷霹雳的爸爸","note":"","ucode":"99BBA6D83DD11F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1740639,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/8f/5f/c6d10aa8.jpg","nickname":"码弓手","note":"","ucode":"B5D1EC8424B5D5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":86710,"discussion_content":"😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576599191,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":86308,"ip_address":""},"score":86710,"extra":""}]},{"author":{"id":2100090,"avatar":"https://static001.geekbang.org/account/avatar/00/20/0b/7a/9ce7dc7d.jpg","nickname":"东瓜酱","note":"","ucode":"B1FEADF98DE292","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297841,"discussion_content":"我居然看完了，但还是不懂","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597070704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1119490,"avatar":"https://static001.geekbang.org/account/avatar/00/11/15/02/66f65388.jpg","nickname":"雷霹雳的爸爸","note":"","ucode":"99BBA6D83DD11F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2100090,"avatar":"https://static001.geekbang.org/account/avatar/00/20/0b/7a/9ce7dc7d.jpg","nickname":"东瓜酱","note":"","ucode":"B1FEADF98DE292","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297913,"discussion_content":"别说你了，我特么自己回来都看不懂…","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1597110426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":297841,"ip_address":""},"score":297913,"extra":""}]}]},{"had_liked":false,"id":154041,"user_name":"失火的夏天","can_delete":false,"product_type":"c1","uid":1241770,"ip_address":"","ucode":"10C6E66EB2A65F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","comment_is_top":false,"comment_ctime":1574352966,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"104653568070","product_id":100039001,"comment_content":"思考题估计就是要引出工厂模式了吧","like_count":24},{"had_liked":false,"id":154372,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1574416324,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"96063696836","product_id":100039001,"comment_content":"课堂讨论answer: <br>考虑使用工厂模式生成ImageStore实例.这样就可以将调用者和具体ImageStore解耦.<br><br>例:<br>public class ImgStoreFactory {<br><br>    private ImgStoreFactory(){<br><br>    }<br><br>    public static ImageStore create(Class&lt;?&gt; clz){<br>        if (clz == AliyunStore.class){<br>            return new AliyunStore();<br>        }else if (clz == PrivateYunStore.class){<br>            return new PrivateYunStore();<br>        }else {<br>            throw new IllegalStateException(&quot;..&quot;);<br>        }<br>    }<br><br>    public static void main(String[] args) {<br>        ImageStore store = ImgStoreFactory.create(AliyunStore.class);<br>        store.dosth();<br>    }<br>}<br><br>另外有一点不太同意作者的说法:<br>上节课作者将Contract翻译为&quot;协议&quot;,<br>我认为是不恰当的.<br>在计算机领域, 通常使用Protocol代表协议.<br>个人认为Contract更恰当的翻译是&quot;契约&quot;.","like_count":22,"discussions":[{"author":{"id":1236320,"avatar":"https://static001.geekbang.org/account/avatar/00/12/dd/60/a6a4f79a.jpg","nickname":"笨鸟","note":"","ucode":"68029ADA76AA5A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291397,"discussion_content":"问题没解决,换方式还得改XXX.class","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1594804002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1740639,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/8f/5f/c6d10aa8.jpg","nickname":"码弓手","note":"","ucode":"B5D1EC8424B5D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":86283,"discussion_content":"这个不行，如果以后加别的实现类时，创建方式还是得改，违反了开闭原则","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1576593192,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1742968,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/98/78/6459e29e.jpg","nickname":"麦芽科技学堂","note":"","ucode":"A90DDE4B6696BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":207813,"discussion_content":"需要修改的地方也没有减少啊","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1584515615,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1130122,"avatar":"https://static001.geekbang.org/account/avatar/00/11/3e/8a/891b0e58.jpg","nickname":"wnz27","note":"","ucode":"BC9ACB6B7C6FD9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":129606,"discussion_content":"所以呢？你说这个的意义是？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578718121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1793704,"avatar":"","nickname":"rao","note":"","ucode":"D5ACA241A8F636","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":191595,"discussion_content":"这个没解决问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583018562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1048286,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fe/de/2019f370.jpg","nickname":"jony","note":"","ucode":"80765A6B9ABA0D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":75823,"discussion_content":"有心了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575784038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154040,"user_name":"编程界的小学生","can_delete":false,"product_type":"c1","uid":1593289,"ip_address":"","ucode":"4A5BE9A5E877FA","user_header":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","comment_is_top":false,"comment_ctime":1574352859,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"91768666075","product_id":100039001,"comment_content":"首先这篇文章受益匪浅，尤其是第二点，与特定实现有关的方法不要暴露到接口中，深有体会。<br><br>其次问题解答<br>我个人的解决方案是这种情况不要去直接new，而是用工厂类去管理这个对象，然后名字可以起成getInstance这类不包含某个具体实现的含义的抽象名称。将来修改直接修改工厂类的getInstance方法即可，这种方式可取吗？还有其他更好的方式吗？求老师点评。","like_count":21},{"had_liked":false,"id":154607,"user_name":"二星球","can_delete":false,"product_type":"c1","uid":1111552,"ip_address":"","ucode":"89EC5FEB98E7CE","user_header":"https://static001.geekbang.org/account/avatar/00/10/f6/00/2a248fd8.jpg","comment_is_top":false,"comment_ctime":1574491998,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"53114099550","product_id":100039001,"comment_content":"使用策略模式，在建一个Context类，使用聚合持有这个接口实例引用，其它所有地方都用这个context类，变动的时候，只变这个context类就行了，其它不动","like_count":12,"discussions":[{"author":{"id":1095857,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","nickname":"梦倚栏杆","note":"","ucode":"BDEB97F2822445","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212707,"discussion_content":"不是，这完全是俩，在这个方法里完全没有用到proxy。 proxiedObject 指的是成员变量 proxiedObject。 但是为什么这样，其他我也不太懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585010269,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175385,"user_name":"BitInit","can_delete":false,"product_type":"c1","uid":1007271,"ip_address":"","ucode":"BDDDA0F51B1EFB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/a7/8dc374e2.jpg","comment_is_top":false,"comment_ctime":1580701119,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"44530374079","product_id":100039001,"comment_content":"对于思考题，想到了两种方法：<br>1. 简单工厂+反射+配置<br>2. 通过使用控制反转&#47;依赖注入方式，类似于Spring","like_count":10,"discussions":[{"author":{"id":1541669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/86/25/25ded6c3.jpg","nickname":"zhengyu.nie","note":"","ucode":"FFE0377D323E46","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213217,"discussion_content":"不必纠结，接口随意，类就不用jdk代理，cglib和其他asm框架皆可。设计模式不用绕进去，你觉得长期合适就行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585059690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154053,"user_name":"William","can_delete":false,"product_type":"c1","uid":1346215,"ip_address":"","ucode":"55F5D9DEE485B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","comment_is_top":false,"comment_ctime":1574357945,"is_pvip":true,"discussion_count":6,"race_medal":0,"score":"44524030905","product_id":100039001,"comment_content":"所以思考题，想到的是，将接口作为构造函数中的参数，传递进来，再调用.","like_count":10,"discussions":[{"author":{"id":2920655,"avatar":"","nickname":"Geek_69090b","note":"","ucode":"758C05A4865E4F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553625,"discussion_content":"只是修改代理类，就可以了。业务处理类不需要修改","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646001622,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154341,"user_name":"Milittle","can_delete":false,"product_type":"c1","uid":1045455,"ip_address":"","ucode":"80E566639A8ABB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f3/cf/851dab01.jpg","comment_is_top":false,"comment_ctime":1574411460,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"40229117124","product_id":100039001,"comment_content":"再说一句 面向接口编程的精髓 我的理解是我们在使用接口的时候 关心我们要做什么 而不是怎么做 怎么做都封装在具体实现类中。而且最主要的是 接口抽象","like_count":9},{"had_liked":false,"id":154130,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1574383834,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"40229089498","product_id":100039001,"comment_content":"依赖注入可以解决思考题，基于接口的实现有多种时，注入处也需要指明是哪咤实现","like_count":9},{"had_liked":false,"id":154106,"user_name":"超威丶","can_delete":false,"product_type":"c1","uid":1180753,"ip_address":"","ucode":"1A18DE885D3C44","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/51/da465a93.jpg","comment_is_top":false,"comment_ctime":1574382092,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"35934120460","product_id":100039001,"comment_content":"个人觉得维护map是最好的选择，实现类型和具体实现对应。","like_count":8,"discussions":[{"author":{"id":1097497,"avatar":"https://static001.geekbang.org/account/avatar/00/10/bf/19/24cc3e7c.jpg","nickname":"二康","note":"","ucode":"45E85D80DE4544","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":63666,"discussion_content":"这个是策略模式 map存储实现类列表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574902016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154042,"user_name":"连边","can_delete":false,"product_type":"c1","uid":1391748,"ip_address":"","ucode":"54B5DA38449728","user_header":"https://static001.geekbang.org/account/avatar/00/15/3c/84/608f679b.jpg","comment_is_top":false,"comment_ctime":1574353224,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35934091592","product_id":100039001,"comment_content":"存储图片的方式写入到配置文件，第8行改用传入类型参数来实例化不同的对象，明天补上代码。","like_count":8},{"had_liked":false,"id":244612,"user_name":"Jasper","can_delete":false,"product_type":"c1","uid":1144132,"ip_address":"","ucode":"7AEF50986C7D8C","user_header":"https://static001.geekbang.org/account/avatar/00/11/75/44/ee170215.jpg","comment_is_top":false,"comment_ctime":1598595239,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"31663366311","product_id":100039001,"comment_content":"思考题：<br><br>    交由Spring容器管理此实现类，如果需要修改，修改此处代码重启即可<br><br>    @Bean<br>    public ImageStore getImageStore() {<br>        return new PrivateImageStore(&#47;*省略构造函数*&#47;);<br>    }<br><br>  ","like_count":7,"discussions":[{"author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383818,"discussion_content":"也行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626246531,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155289,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1574675022,"is_pvip":false,"replies":[{"id":"60020","content":"确实意义不大","user_name":"作者回复","comment_id":155289,"uid":"1190123","ip_address":"","utype":1,"ctime":1574852242,"user_name_real":"王争"}],"discussion_count":17,"race_medal":0,"score":"31639446094","product_id":100039001,"comment_content":"那现在的MVC代码，要求service先写接口，然后再写实现，有必要嘛？<br>说实话，我一直没看懂这种行为的意义何在。","like_count":7},{"had_liked":false,"id":154054,"user_name":"YouCompleteMe","can_delete":false,"product_type":"c1","uid":1232859,"ip_address":"","ucode":"89B5A75DA85E0A","user_header":"https://static001.geekbang.org/account/avatar/00/12/cf/db/9693d08f.jpg","comment_is_top":false,"comment_ctime":1574358648,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31639129720","product_id":100039001,"comment_content":"抽象工厂，把创建具体类型放到工厂类里","like_count":7},{"had_liked":false,"id":166766,"user_name":"ちよくん","can_delete":false,"product_type":"c1","uid":1398577,"ip_address":"","ucode":"B71E9B16E4408F","user_header":"https://static001.geekbang.org/account/avatar/00/15/57/31/6772744d.jpg","comment_is_top":false,"comment_ctime":1577589966,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"23052426446","product_id":100039001,"comment_content":"老师，我在看的过程就发现了你在课堂讨论的问题，本来想在评论中提出，老师在结尾自己提出来了，关于这个问题我的建议是再抽出来一层manager接口或者类均可，manager 实现类调用上传下载接口，外部统一调用manager 接口，外部不会因为manager 实现类的具体调用那个接口而改变任何代码，即可解决上面的问题。","like_count":5,"discussions":[{"author":{"id":2100090,"avatar":"https://static001.geekbang.org/account/avatar/00/20/0b/7a/9ce7dc7d.jpg","nickname":"东瓜酱","note":"","ucode":"B1FEADF98DE292","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297844,"discussion_content":"我也是这么想的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597070905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154133,"user_name":"bearlu","can_delete":false,"product_type":"c1","uid":1030862,"ip_address":"","ucode":"14F260C8B24E27","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/ce/fd45714f.jpg","comment_is_top":false,"comment_ctime":1574383978,"is_pvip":true,"replies":[{"id":"59171","content":"👌 我抽空整理一下放上去<br>https:&#47;&#47;github.com&#47;wangzheng0822","user_name":"作者回复","comment_id":154133,"uid":"1190123","ip_address":"","utype":1,"ctime":1574385313,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"23049220458","product_id":100039001,"comment_content":"老师，希望能把示例代码和问题代码也放到Github上。","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475384,"discussion_content":"👌 我抽空整理一下放上去\nhttps://github.com/wangzheng0822","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574385313,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1030862,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ba/ce/fd45714f.jpg","nickname":"bearlu","note":"","ucode":"14F260C8B24E27","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55603,"discussion_content":"谢谢，那样其他同学也可以用自己熟悉的语言实现一次并且上传到该库。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574385628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154085,"user_name":"水银","can_delete":false,"product_type":"c1","uid":1045948,"ip_address":"","ucode":"0FD9C79590E484","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/bc/63be02b6.jpg","comment_is_top":false,"comment_ctime":1574380290,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23049216770","product_id":100039001,"comment_content":"我是搞Java的，关于思考题，个人感觉主要依靠控制反转，即把对象的构造权交给容器，而非代码中直接写死。像Spring那种依赖注入的方式就可以，或者不使用Spring，可以把具体的实现类全路径名配置到配置文件中，代码中以Class.forName的方式得到Class，然后再用Class的newInstance方法得到实例并缓存起来以便后面使用避免重复构造实例。以后替换实现的时候只需要替换配置文件中的类全路径名即可。当然前提是这个Class需要实现统一抽象出来的接口，使用逻辑中也是","like_count":5},{"had_liked":false,"id":154075,"user_name":"NoAsk","can_delete":false,"product_type":"c1","uid":1122412,"ip_address":"","ucode":"71CA29776B4F68","user_header":"https://static001.geekbang.org/account/avatar/00/11/20/6c/e4966364.jpg","comment_is_top":false,"comment_ctime":1574378057,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23049214537","product_id":100039001,"comment_content":"关于什么时候定义接口的一些拙见：<br>当方法会有其他实现，或者不稳定的时候需要定义接口；<br>1.不稳定的方法一般能事先确定，用接口能提高可维护性<br>2.但在开发时往往不确定是否需要其他实现，我的原则是等到需要使用接口的时候再去实现。所以根据kiss原则一般我会先用方法实现，如果有一天真的需要有新的实现的时候再重新抽象出接口对代码进行小重构。<br><br>就老师的例子进行一下说明：<br>刚开始只需要阿里云进行图片上传下载功能，我就先只实现阿里云的图片上传下载方法。<br>后期发现需要有私有云的上传下载方法的话，那就对这个功能通过接口进行抽象。但是你永远不知道到底是新的图片上传下载功能先来到还是其他阿里接口先来到，如果是新的阿里接口，也是用的这一套token方法，那就用抽象方法或接口对token部分实现抽象。<br><br>课后问题：<br>简单工厂，工厂模式可以提高可扩展性，维护性。<br>java spring项目可以使用注入的方式。","like_count":5},{"had_liked":false,"id":154058,"user_name":"秋惊蛰","can_delete":false,"product_type":"c1","uid":1620344,"ip_address":"","ucode":"3D9A6D5CA9C79F","user_header":"https://static001.geekbang.org/account/avatar/00/18/b9/78/a5804dae.jpg","comment_is_top":false,"comment_ctime":1574361146,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"18754230330","product_id":100039001,"comment_content":"这一节解决了一些疑惑，但是还有三个问题想问一下：<br>1. 看到有些Spring Boot的代码，会给每个业务逻辑分别定义一个service接口，并用一个类来实现这个接口，然后在controller里像第8行那样调用。<br>这种是不是就过度使用接口了，还是说有必要考虑每个业务逻辑可能的实现方式。<br>2. 能不能具体的说一下哪些典型场景适合用接口抽象，比如输入输出，这两个地方肯定不止一种方式，用接口很有必要，还有其他场景吗？<br>3. Python这种动态语言怎么做到面向抽象编程？","like_count":4,"discussions":[{"author":{"id":1602420,"avatar":"https://static001.geekbang.org/account/avatar/00/18/73/74/3bf4b74e.jpg","nickname":"阿德","note":"","ucode":"186D5E19E3CB6E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60595,"discussion_content":"我也有相同的疑问，就是service层定义一个serviceimpl类，为什么还需要有接口service","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574739617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2124158,"avatar":"https://static001.geekbang.org/account/avatar/00/20/69/7e/6b94f44b.jpg","nickname":"逐梦","note":"","ucode":"682702AA87AAE7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382929,"discussion_content":"同感，本身引入引口估计是为了多实现时方便控制反转。但实际开发中感觉，大多数情况下接口都是多余的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625795206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134761,"avatar":"https://static001.geekbang.org/account/avatar/00/11/50/a9/3f8c7418.jpg","nickname":"冰糕不冰","note":"","ucode":"B754FE464BA426","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62004,"discussion_content":"现在golang 的很多项目也是用的java这一套。再mvc的基础上再抽象一个逻辑层，然后定义service接口，而有的又只是定义类。个人确实不知道哪种方式更好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574812740,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1123103,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/1f/6452b2e8.jpg","nickname":"刘清斌","note":"","ucode":"775B053AF87B53","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56538,"discussion_content":"python的duck coding编程方式可以实现面向接口编程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574495762,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1349528,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoViaN0hP07cXOl7vOIvHPu7DZ3wxHBz4iaLVEqG1TFfiagm1wUaiczbCyicwib7oDWw0vD4cXg9eZ0Okqg/132","nickname":"李湘河","note":"","ucode":"DB078B5DAAE82E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55491,"discussion_content":"你说的是mvc开发范式里面的吧，我觉得这样是和每个业务模块对应，为了更好的协同开发和后期维护，如果不这样，当一个项目被另外一个人接手，要想看代码逻辑得多费力，还有就是后期维护bug排查也容易些，个人见解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574381873,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1620344,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b9/78/a5804dae.jpg","nickname":"秋惊蛰","note":"","ucode":"3D9A6D5CA9C79F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1349528,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoViaN0hP07cXOl7vOIvHPu7DZ3wxHBz4iaLVEqG1TFfiagm1wUaiczbCyicwib7oDWw0vD4cXg9eZ0Okqg/132","nickname":"李湘河","note":"","ucode":"DB078B5DAAE82E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":59207,"discussion_content":"业务逻辑实现是要分开的，就是说能不能去掉接口呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574684938,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":55491,"ip_address":""},"score":59207,"extra":""},{"author":{"id":2347137,"avatar":"https://static001.geekbang.org/account/avatar/00/23/d0/81/d5c8e46e.jpg","nickname":"snake","note":"","ucode":"47BFFE4D048156","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1349528,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoViaN0hP07cXOl7vOIvHPu7DZ3wxHBz4iaLVEqG1TFfiagm1wUaiczbCyicwib7oDWw0vD4cXg9eZ0Okqg/132","nickname":"李湘河","note":"","ucode":"DB078B5DAAE82E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331219,"discussion_content":"这点同意","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606810119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":55491,"ip_address":""},"score":331219,"extra":""}]},{"author":{"id":1577856,"avatar":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","nickname":"L🚲🐱","note":"","ucode":"08A012739614DE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55451,"discussion_content":"sprigboot 接口注入么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574380173,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175712,"user_name":"batman","can_delete":false,"product_type":"c1","uid":1266482,"ip_address":"","ucode":"73C30ACFC0D612","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/IIkdC2gohpcibib0AJvSdnJQefAuQYGlLySQOticThpF7Ck9WuDUQLJlgZ7ic13LIFnGBXXbMsSP3nZsbibBN98ZjGA/132","comment_is_top":false,"comment_ctime":1580805428,"is_pvip":true,"discussion_count":1,"race_medal":1,"score":"14465707316","product_id":100039001,"comment_content":"简单点可以通过工厂模式；<br>复杂点可以通过JDK 标准的 SPI (Service Provider Interface) 扩展点发现机制;","like_count":3,"discussions":[{"author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383819,"discussion_content":"反正就是 从代码中抽取 创建类的 标识字符串;然后再由一个顶层容器保存着;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626247187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157997,"user_name":"plasmatium","can_delete":false,"product_type":"c1","uid":1356120,"ip_address":"","ucode":"1564F6A20186AE","user_header":"https://static001.geekbang.org/account/avatar/00/14/b1/58/7d4f968f.jpg","comment_is_top":false,"comment_ctime":1575295903,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14460197791","product_id":100039001,"comment_content":"如果用golang实现的话，可以非常优雅简洁。实现io.Writer和io.Reader接口即可。以下举例Writer接口<br>比如把各种字符串定义并取名为一种bucket类型（本质还是字符串，不增加任何动态汇编代码）：<br>type AliyunBucket string<br>type PrivateBucket string 等等。。。<br>然后实现各自的Write方法，其中包括token的获取等等各自关心的事情，然后可以这样用：<br>var bucket AliyunBucket = &quot;&#47;path&#47;to&#47;save&#47;on&#47;bucket.png&quot;<br>var bucket2 PrivateBucket = &quot;C:\\我的图片\\x.jpg&quot;<br>var bucket3 MyAwesomeBucket = &quot;http:&#47;&#47;192.168.1.234&#47;picture&#47;y.jpg&quot;<br>bucket.Write(imageBytes)<br>bucket2.Write(imageBytes)<br>bucket3.Write(imageBytes)<br>-------------------<br>实际上我们可以更灵活一些，某天你突然有了另一个bucket，并且需要支持转base64或者压缩支持，那都不是事儿，我可能会这么写：<br>type DataSaver interface {<br>      Save(io.Writer)<br>}<br>type imgData []byte<br>然后可以在imgData上实现这个DataSaver接口，然后这样调用：<br>var AliyunBucket = &quot;&#47;path&#47;to&#47;save&#47;on&#47;aliyun&#47;bucket.png&quot;<br>var filePath LocalFilePathBucket = &quot;C:\\Path\\to\\img.jpg&quot;<br>combinedWriter := base64.NewEncoder(base64.StdEncoding, AliyunBucket)<br>combinedWriter2 := someOtherEncoder.New(someParams, filePath)<br>combinedWriter3 := imgFilpEncoder.New(someParams, MyAwesomeBucket) &#47;&#47; 翻转图像后上传<br><br>img imgData := someImg<br>img.save(combineWriter) &#47;&#47; 以base64存阿里云<br>img.save(combineWriter2) &#47;&#47; 存本地<br>img.save(combineWriter3) &#47;&#47; 翻转后存私有云<br><br>同理，任何实现了DataSaver接口的东西（可能是一个结构体，一个byte数组，一个int，一个string等），都可以上传下载到任何地方（各种bucket，磁盘，网络，内存，只要实现了io.Writer和io.Reader）<br>-----------<br>另外考虑到只要实现io.Writer方法的都可以从这个接口得到好处，比如http.ResponseWriter，<br>那么就是用在服务器响应别人的请求的需求上了。<br><br>考虑到上传下载的本质，我们最终是要实现如何将一坨字节以某种方式搬运到另一处：将imgBytes从内存A，通过base64的encode方式搬运到内存B，然后应用某些参数来搬运到网卡C或者磁盘D，在golang里用装饰器模式实现起来比较好弄，上述例子中base64就是这样做的。<br><br>另外可以看到duck-type非常灵活，而且作为静态语言，编译器已经帮你把关了，你不可能遇到python或者js里的运行时错误","like_count":3},{"had_liked":false,"id":154337,"user_name":"Milittle","can_delete":false,"product_type":"c1","uid":1045455,"ip_address":"","ucode":"80E566639A8ABB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f3/cf/851dab01.jpg","comment_is_top":false,"comment_ctime":1574411091,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"14459312979","product_id":100039001,"comment_content":"读完这节课以后，有如下敢想，也可以用在以后编写程序的过程中：<br>1. 基于接口编程，我们首先需要明确我们要做什么，然后去定义接口，具体怎么做，我们封装在具体实现类中进行实现，这就是上层代码基于接口实现功能，底层基于具体类实现编程，做到不暴露任何实现细节给上层代码。<br>2. 基于抽象编程，我的理解是，我们再不断明确具体实现类要做的事情中，抽象出公共的代码，放在抽象类中进行共用，然后具体不同的实现我们还是可以确保在实现类中进行实现。<br>3. 这两者都可以在编程过程中实现基于接口而非实现编程。这样上层代码就不太需要在修改功能的时候，做大量的代码修改。<br>课堂讨论：<br>在C++中，我们让这种调用使用方式通过工厂模式来进行封装，到后来如果具体实现发生了改变，我们只需要扩展一个具体实现类，然后就可以做到开闭原则，对扩展开放，对封装关闭的原则。这样我们只需要在调用的时候，传入不同的参数，来构建不同的工厂实现类对象，最后调用该工厂实现类的具体实现来达到功能的迁移。（我的回到可能有点乱，不知道有人看得懂不，没看懂的 我们可以交流），最后感谢王争师兄给我这么好的学习机会 让自己的零散知识重新做一个总结，很实惠~谢谢","like_count":3},{"had_liked":false,"id":154059,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1574369752,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14459271640","product_id":100039001,"comment_content":"基于抽象而非具体体现了信息隐藏和分离代码中稳定性不同的部分。在一个上传图片的部分不需要知道图片是如何上传的，阿里云以及token就属于过多的信息，有必要隐藏这些信息。另外一方面上传图片这件事比阿里云实现要稳定的多，不上传图片的概率低于不用阿里云上传图片的概率。这里有必要分离图片上传这个接口和用阿里云上传这个实现。<br>不过原来的实现也没什么问题，毕竟谁也不能未卜先知，将来一定会替换阿里云。如果我拿到这个变更需求，我会先用同名接口替换原来的实现（原来的阿里类实现清晰，功能单一，只是不适合直接调用），然后用adapter来转接口，然后一步一步实现接口和实现的分离，目标是接口能够隐藏信息，实现能够清晰明了，每一步都能用IDE工具重构，每一步都能编译和测试。","like_count":3},{"had_liked":false,"id":165940,"user_name":"Kaybee","can_delete":false,"product_type":"c1","uid":1106900,"ip_address":"","ucode":"B94E578F12A365","user_header":"https://static001.geekbang.org/account/avatar/00/10/e3/d4/22d48e2a.jpg","comment_is_top":false,"comment_ctime":1577347131,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10167281723","product_id":100039001,"comment_content":"思考题：ImageProcessingJob 构造函数声明ImageStore接口为参数，实际运行时传入实现类实例","like_count":2},{"had_liked":false,"id":289255,"user_name":"Aibo","can_delete":false,"product_type":"c1","uid":2115387,"ip_address":"","ucode":"2CE3E77BD2D014","user_header":"https://static001.geekbang.org/account/avatar/00/20/47/3b/70198ceb.jpg","comment_is_top":false,"comment_ctime":1618939050,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5913906346","product_id":100039001,"comment_content":"需要解决的问题是多处修改的问题，方案如下<br>1.简单工厂+配置文件。      只需修改配置文件<br>2.依赖注入","like_count":1,"discussions":[{"author":{"id":2115387,"avatar":"https://static001.geekbang.org/account/avatar/00/20/47/3b/70198ceb.jpg","nickname":"Aibo","note":"","ucode":"2CE3E77BD2D014","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369145,"discussion_content":"依赖注入还有一个好处，上层依赖下层的抽象，方便测试mock。可以让业务逻辑层依赖于数据处理层，实现loc","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618939509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":265870,"user_name":"okeyja","can_delete":false,"product_type":"c1","uid":1261636,"ip_address":"","ucode":"D83D78C6ACFEBC","user_header":"https://static001.geekbang.org/account/avatar/00/13/40/44/0d0dc06c.jpg","comment_is_top":false,"comment_ctime":1607056627,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5902023923","product_id":100039001,"comment_content":"工厂方法，把需要用的具体哪一个类放到工厂里。Spring里面，替换Servic-Layer interface的@Service注解到不同的Impl类。","like_count":1},{"had_liked":false,"id":263441,"user_name":"大智","can_delete":false,"product_type":"c1","uid":1718373,"ip_address":"","ucode":"5FD45545611252","user_header":"https://static001.geekbang.org/account/avatar/00/1a/38/65/ad8c46bd.jpg","comment_is_top":false,"comment_ctime":1606134709,"is_pvip":true,"replies":[{"id":"96097","content":"嗯嗯","user_name":"作者回复","comment_id":263441,"uid":"1190123","ip_address":"","utype":1,"ctime":1606700767,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"5901102005","product_id":100039001,"comment_content":"思考题的话，结合spring的话我觉得应该是初始化一个存储处理类并在使用类中@Autowired即可。初始化哪个类取决于你给哪个存储类进行了初始化","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510193,"discussion_content":"嗯嗯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217390,"user_name":"anders","can_delete":false,"product_type":"c1","uid":1153592,"ip_address":"","ucode":"610C80D742C331","user_header":"https://static001.geekbang.org/account/avatar/00/11/9a/38/118a890c.jpg","comment_is_top":false,"comment_ctime":1589474274,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5884441570","product_id":100039001,"comment_content":"为什么基于接口实现？<br><br>觉得作者这章直接命中核心的点是:<br>- 封装不确定性内容，暴露稳定的接口<br>- 与其说基于接口，不如更加通俗的基于协议，约定<br><br>编程效率本质上，是要应对需求的不确定性，应对变化中，更小成本的开发演进。<br><br>如何更小成本的开发？那当然是牵扯代码越少，效率越高。<br><br>如本章例子，只需要基于接口再实现一个类，并替换掉就好，这样做的好处除了改动少， QA 测试的范围少之外，还有就是测试好写（只需要测试新类即可），开发者心智负担也少（头发终于能保住了😂）<br><br>另外提到基于协议实现，让我想到了 vscode 的 Language Service Protocal 的流行，纷纷被 vim，emacs 支持，也是这个原因。语言插件基于 LSP 实现的话，就非常容易在各个编辑器中适配迁移，极大的降低了成本。","like_count":1},{"had_liked":false,"id":214506,"user_name":"大圣代","can_delete":false,"product_type":"c1","uid":1003080,"ip_address":"","ucode":"8A59114C8345C8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/48/bb0136d1.jpg","comment_is_top":false,"comment_ctime":1588759413,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5883726709","product_id":100039001,"comment_content":"基于接口编程体现的还是开闭原则：<br>1. 使用接口屏蔽了上层对于下次不稳定的感知，体现了对老代码修改关闭的原则提高了稳定性。<br>2. 使用接口完成多态降低了对单一实现的依赖，体现了对拓展开放的原则，降低了耦合，提升了拓展性。<br>3. 1 + 2 -&gt; 接口可以随意拓展，老代码根本感知不到这个变化，不会造成破坏，还拓展了功能，提高了项目的弹性。<br><br><br>什么时候使用面向接口编程：<br>1. 对于简单、短期内不可能有多重实现方式的场景，没必要做面向接口编程。<br>2. 对于越是不稳定，逻辑越复杂，越应该为期提高拓展性，使用面向接口编程。<br>这个问题完全是对个人经验和逻辑判断的考验","like_count":1},{"had_liked":false,"id":192178,"user_name":"Nick","can_delete":false,"product_type":"c1","uid":1921287,"ip_address":"","ucode":"64BBE005890845","user_header":"https://static001.geekbang.org/account/avatar/00/1d/51/07/b5a945b6.jpg","comment_is_top":false,"comment_ctime":1584842001,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879809297","product_id":100039001,"comment_content":"建议老师可以增加定期回答问题的文章，这一点可以学习得到专栏的老师","like_count":1},{"had_liked":false,"id":155173,"user_name":"帆大肚子","can_delete":false,"product_type":"c1","uid":1529040,"ip_address":"","ucode":"3DB11DB2FA1802","user_header":"https://static001.geekbang.org/account/avatar/00/17/54/d0/4e1fc664.jpg","comment_is_top":false,"comment_ctime":1574656549,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869623845","product_id":100039001,"comment_content":"直接工厂模式， 做什么事情都要有个度， 我很期待工厂模式的度是什么","like_count":1},{"had_liked":false,"id":154860,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1574582634,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869549930","product_id":100039001,"comment_content":"1.如果需求是，要么使用阿里云存储要么使用七牛云存储，这样非此即彼的方式。那么写死，然后基于功能开关发布。顺利发布后，在下个版本，将功能开关和老的阿里云存储代码干掉便是。<br>2.如果需求是，同时存在使用阿里云和七牛云的存储诉求，这种两者兼备的方式。那么通过工厂模式，依赖入参选择对应的实现模板，分别获得实现类即可。这里需要在入参上，为实现类型打上标记，以便运行时动态选择。","like_count":1},{"had_liked":false,"id":154831,"user_name":"指尖流逝","can_delete":false,"product_type":"c1","uid":1005381,"ip_address":"","ucode":"417009F674FAF1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/45/c418ea5c.jpg","comment_is_top":false,"comment_ctime":1574576951,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869544247","product_id":100039001,"comment_content":"第八行可以使用工厂类来创建接口实现类，把实例化接口实现的代码收拢到一个位置。避免项目代码中这一类的实例化满天飞","like_count":1},{"had_liked":false,"id":154371,"user_name":"木木","can_delete":false,"product_type":"c1","uid":1181486,"ip_address":"","ucode":"E82C58AF2604ED","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/2e/878d3c92.jpg","comment_is_top":false,"comment_ctime":1574416089,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5869383385","product_id":100039001,"comment_content":"看的我热血沸腾，马上重构以前的代码","like_count":1,"discussions":[{"author":{"id":1564002,"avatar":"https://static001.geekbang.org/account/avatar/00/17/dd/62/824e5e16.jpg","nickname":"沁塵","note":"","ucode":"4AD780EF50882B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":180926,"discussion_content":"打开IDE，双击源文件，卧槽，关机。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582306137,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154192,"user_name":"彦祖","can_delete":false,"product_type":"c1","uid":1235159,"ip_address":"","ucode":"784CBB0C8BFD47","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/d7/21cc617d.jpg","comment_is_top":false,"comment_ctime":1574389814,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869357110","product_id":100039001,"comment_content":"SPI","like_count":1},{"had_liked":false,"id":154155,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1574385599,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869352895","product_id":100039001,"comment_content":"设计模式解决","like_count":1},{"had_liked":false,"id":154096,"user_name":"黄林晴","can_delete":false,"product_type":"c1","uid":1362631,"ip_address":"","ucode":"B15C38AECDA88F","user_header":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","comment_is_top":false,"comment_ctime":1574381282,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5869348578","product_id":100039001,"comment_content":"打卡✔","like_count":1},{"had_liked":false,"id":360821,"user_name":"H·H","can_delete":false,"product_type":"c1","uid":2108194,"ip_address":"上海","ucode":"113E95BA6B6F51","user_header":"https://static001.geekbang.org/account/avatar/00/20/2b/22/79d183db.jpg","comment_is_top":false,"comment_ctime":1666875946,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1666875946","product_id":100039001,"comment_content":"如果后面不止存储图片还需要存视频音频，例子还是不好扩展","like_count":0},{"had_liked":false,"id":357723,"user_name":"CL","can_delete":false,"product_type":"c1","uid":2894752,"ip_address":"贵州","ucode":"9CDF27EFE870AD","user_header":"https://static001.geekbang.org/account/avatar/00/2c/2b/a0/d1185ac6.jpg","comment_is_top":false,"comment_ctime":1663579965,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663579965","product_id":100039001,"comment_content":"牛","like_count":0},{"had_liked":false,"id":356370,"user_name":"Sherk","can_delete":false,"product_type":"c1","uid":2156245,"ip_address":"重庆","ucode":"AFE3E7F158258D","user_header":"https://static001.geekbang.org/account/avatar/00/20/e6/d5/4f1fc074.jpg","comment_is_top":false,"comment_ctime":1662204806,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662204806","product_id":100039001,"comment_content":"思考题： 通过工厂方法，通过传入一个存储类型，来返回具体的存储方式。、<br><br>本节主要讲了什么：如何使用接口。<br><br>   why：<br>    编程的方式应该是面向接口而不是具体实现。因为业务可能是多变的。软件开发时，需求是不断变化的，代码设计时越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。<br><br>   how <br>       1.接口名称应该抽象，不应该和具体实现挂钩。<br>       2. 写接口之前，梳理场景，哪些是可变的，哪些不可变。将不可变的部分抽象出来，可以理解为定义协议，未来的变化的东西都从按协议定义的框架实现自己的细节。比如客户端与服务端的接口设计，定义好协议，具体怎么实现各个客户端可以自己实现。<br>       3.防止过度使用接口。业务如果不会怎么变化就不要使用接口。<br>  <br><br>  <br>  <br><br>      ","like_count":0},{"had_liked":false,"id":356148,"user_name":"Stay_Gold","can_delete":false,"product_type":"c1","uid":1119904,"ip_address":"北京","ucode":"ACB8DCD2EF8F95","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJRCtuJkpyy2NTTABPFibg2k9tZscOOKx9wu80a85d5HspCorO9Nibj7Z7q9v1icPTVm5ia52r0RCzEaA/132","comment_is_top":false,"comment_ctime":1662012847,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662012847","product_id":100039001,"comment_content":"这样的设计还是不够完美，对此，你有更好的实现思路吗？<br>只能想到IOC的方式。<br>ImageStore imageStore = new PrivateImageStore(&#47;*省略构造函数*&#47;);<br>替换成<br>ImageStore imageStore = new ImageStore(传入具体要生成的对象);","like_count":0},{"had_liked":false,"id":352724,"user_name":"Asser","can_delete":false,"product_type":"c1","uid":1583575,"ip_address":"","ucode":"9A76AB911C8051","user_header":"https://static001.geekbang.org/account/avatar/00/18/29/d7/b2bcc28c.jpg","comment_is_top":false,"comment_ctime":1658899201,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658899201","product_id":100039001,"comment_content":"个人不是很熟悉java的语法，不过针对课程提出的问题，个人认为可以使用依赖注入的模式，将依赖的实例对象通过参数的方式传入","like_count":0},{"had_liked":false,"id":351035,"user_name":"SICUN","can_delete":false,"product_type":"c1","uid":1254261,"ip_address":"","ucode":"22A384904EB9E9","user_header":"https://static001.geekbang.org/account/avatar/00/13/23/75/2b599841.jpg","comment_is_top":false,"comment_ctime":1657470510,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657470510","product_id":100039001,"comment_content":"在laravel框架中可以编写图片服务提供者ImageServiceProvider,接口与实现类与文档中保持一致，然后将图片服务提供者与aliyun上传实现类做绑定，调用时使用依赖注入图片上传对象，更换为私有云上传时，则修改服务提供者的绑定为私有云图片实现类即可。","like_count":0},{"had_liked":false,"id":347227,"user_name":"邓嘉文","can_delete":false,"product_type":"c1","uid":2332845,"ip_address":"","ucode":"FCEDFABFB48055","user_header":"https://static001.geekbang.org/account/avatar/00/23/98/ad/f9d755f2.jpg","comment_is_top":false,"comment_ctime":1653830016,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653830016","product_id":100039001,"comment_content":"思考题: 配置文件+工厂模式","like_count":0},{"had_liked":false,"id":345170,"user_name":"杜威","can_delete":false,"product_type":"c1","uid":1294908,"ip_address":"","ucode":"CF49380E27467F","user_header":"https://static001.geekbang.org/account/avatar/00/13/c2/3c/a82d4ed0.jpg","comment_is_top":false,"comment_ctime":1652089153,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652089153","product_id":100039001,"comment_content":"面向接口编程能带来的好处是多态，关注点分离，让客户端只关注需要关注的方法。","like_count":0},{"had_liked":false,"id":343968,"user_name":"seven#羊啾啾JK","can_delete":false,"product_type":"c1","uid":2160692,"ip_address":"","ucode":"B3F1BF6F2F08B2","user_header":"https://static001.geekbang.org/account/avatar/00/20/f8/34/1c260560.jpg","comment_is_top":false,"comment_ctime":1651148935,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651148935","product_id":100039001,"comment_content":"使用抽象类来实现","like_count":0},{"had_liked":false,"id":342550,"user_name":"Geek_as","can_delete":false,"product_type":"c1","uid":1534500,"ip_address":"","ucode":"AB7B70DBC2B5F8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/qhonwcQle1RBufvLdTm4MgSNl554GBXUZtNNH65oYajbbRLxKsZX4hM9vFtrLLpDM0H93ZNWRFAZSrIZC7yAsQ/132","comment_is_top":false,"comment_ctime":1650337162,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650337162","product_id":100039001,"comment_content":"设置配置参数，使用工厂模式创建该类，在创建的时候通过传入配置参数，工厂模式根据配置动态决定创建对应的类","like_count":0},{"had_liked":false,"id":339334,"user_name":"Geek_783504","can_delete":false,"product_type":"c1","uid":2743789,"ip_address":"","ucode":"549D3F0549743C","user_header":"https://static001.geekbang.org/account/avatar/00/29/dd/ed/f6c5432b.jpg","comment_is_top":false,"comment_ctime":1648039272,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1648039272","product_id":100039001,"comment_content":"可以使用工厂模式和策略模式进行简化处理","like_count":0},{"had_liked":false,"id":336016,"user_name":"面朝大海春暖花开","can_delete":false,"product_type":"c1","uid":1197581,"ip_address":"","ucode":"7F5269EA6027D1","user_header":"https://static001.geekbang.org/account/avatar/00/12/46/0d/d995cb3b.jpg","comment_is_top":false,"comment_ctime":1645847416,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645847416","product_id":100039001,"comment_content":"注册树","like_count":0},{"had_liked":false,"id":335383,"user_name":"顺势而为","can_delete":false,"product_type":"c1","uid":2757858,"ip_address":"","ucode":"FE7D688D24823E","user_header":"https://static001.geekbang.org/account/avatar/00/2a/14/e2/f6f1627c.jpg","comment_is_top":false,"comment_ctime":1645498366,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645498366","product_id":100039001,"comment_content":"1.刚刚去看typescript的东西，关于面向对象的过程还是相对薄弱，因为interface的定义往往只有参数定义，没有方法定义。也很少像springboot那样，能定义一个接口，然后implement实现接口。<br>2.设计的时候，需要考虑命名的通用性是必须的，毕竟要为以后拓展。<br>3.楼下有句话很值得学习，不应该attackBagdad(),而是应该 attack(city)","like_count":0},{"had_liked":false,"id":335348,"user_name":"roie","can_delete":false,"product_type":"c1","uid":1371983,"ip_address":"","ucode":"0CC9598364820A","user_header":"https://static001.geekbang.org/account/avatar/00/14/ef/4f/8b7e1f1e.jpg","comment_is_top":false,"comment_ctime":1645460201,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645460201","product_id":100039001,"comment_content":"可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。老师这句话没太理解？就那imagestore例子，封装不稳定的实现，是封装upload和download这两个行为吗？暴露稳定的接口，不明白怎么理解？","like_count":0},{"had_liked":false,"id":327211,"user_name":"小苗晓雪","can_delete":false,"product_type":"c1","uid":1334583,"ip_address":"","ucode":"B15FDF455853D2","user_header":"https://static001.geekbang.org/account/avatar/00/14/5d/37/061e7fac.jpg","comment_is_top":false,"comment_ctime":1639985022,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1639985022","product_id":100039001,"comment_content":"思考题我一开始就有疑问 , 就应该不用接口 , 就用抽象类 , 本身他们都是图片云存储的需求 , 我就创建一个图片云存储的抽象类 , 让阿里云和私有云都继承我这个抽象类 , 我再写一些公有的通用的实现方法 , 特殊的私有的实现方法用抽象方法的形式体现 , 比如 upload 和 download 两个方法 , 让两个子类自己去实现这两个抽象方法 , 这样不管多少种图片云存储需求我都可以满足 , 我只需要用工厂方法 让云存储的指针指向真正的具体的子类的实现即可 , 这样的代码就更通用了~","like_count":0},{"had_liked":false,"id":327122,"user_name":"idiot","can_delete":false,"product_type":"c1","uid":2526391,"ip_address":"","ucode":"D7A6E980B530B4","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/fcftgBsticCicEEkuzB0GTkHIocX62YVTSvnhR1c94sccj42lVaYXrmcZyhzUI3l9NcvuN1rXLhXt2eBrZZ0Tw7A/132","comment_is_top":false,"comment_ctime":1639925168,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1639925168","product_id":100039001,"comment_content":"里面提到的修改量大的问题，感觉不是很有说服力。修改量大不一定复杂，如果只是改个函数&#47;类名，不管多少地方用了，一个replace或者refactor也能搞定了。","like_count":0},{"had_liked":false,"id":319711,"user_name":"逆风一战九","can_delete":false,"product_type":"c1","uid":2143900,"ip_address":"","ucode":"83127627F6F37C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI45zO9GOMquhD0ia1wTBSwtJ1juPcpFTSrOGicGW3jf6JclaudauHicN8OpADArQKL8zPtDicEx4aicgA/132","comment_is_top":false,"comment_ctime":1635919651,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635919651","product_id":100039001,"comment_content":"ioc通过注解的方式注入到统一的容器中，再各个类里面可以拿到引用","like_count":0},{"had_liked":false,"id":317017,"user_name":"音速起子代购","can_delete":false,"product_type":"c1","uid":2744922,"ip_address":"","ucode":"98C5A7A7D25475","user_header":"https://static001.geekbang.org/account/avatar/00/29/e2/5a/6696d429.jpg","comment_is_top":false,"comment_ctime":1634642332,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634642332","product_id":100039001,"comment_content":"使用简单工厂模式，生成一个工厂类，并设置一个方法，可以根据不同的信息生成不同的对象","like_count":0},{"had_liked":false,"id":315889,"user_name":"凉生凉忆","can_delete":false,"product_type":"c1","uid":2437375,"ip_address":"","ucode":"1F4B69F7435247","user_header":"https://static001.geekbang.org/account/avatar/00/25/30/ff/05ea390f.jpg","comment_is_top":false,"comment_ctime":1634031851,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634031851","product_id":100039001,"comment_content":"三板斧，接口多实现，每一个实现注册到一个工厂里，工厂维护一个map，可以定义一个枚举对象对应不同的实现类，将这个枚举对象作为map的key，value为具体的实现，调用方通过工厂传入一个枚举对象获得具体的接口实例即可。","like_count":0},{"had_liked":false,"id":314084,"user_name":"关耳","can_delete":false,"product_type":"c1","uid":1583598,"ip_address":"","ucode":"9036ADEB550BD4","user_header":"https://static001.geekbang.org/account/avatar/00/18/29/ee/7cc1d3d2.jpg","comment_is_top":false,"comment_ctime":1632830486,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1632830486","product_id":100039001,"comment_content":"感觉抽象类和接口应该是一个道理，都是上层设计，把要约束和定义的协议提取总结的结果。只不过抽象类可以定义方法内容和属性而已，这两个应该是一个理念吧，只不过java分了两个实现而已！<br>要说代码复用，这个跟抽象没啥关系吧","like_count":0},{"had_liked":false,"id":312344,"user_name":"Paradise","can_delete":false,"product_type":"c1","uid":1618275,"ip_address":"","ucode":"9CA103A82F5F38","user_header":"https://static001.geekbang.org/account/avatar/00/18/b1/63/68239c70.jpg","comment_is_top":false,"comment_ctime":1631761519,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631761519","product_id":100039001,"comment_content":"可以用依赖注入的方式吧～","like_count":0},{"had_liked":false,"id":309854,"user_name":"细雨轻风","can_delete":false,"product_type":"c1","uid":1193398,"ip_address":"","ucode":"504CD7DA4827EF","user_header":"https://static001.geekbang.org/account/avatar/00/12/35/b6/b574c397.jpg","comment_is_top":false,"comment_ctime":1630374879,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630374879","product_id":100039001,"comment_content":"spring框架下 ，使用基于接口的实现方式，在配置文件中添加实现类的bean名称，在调用类里使用@Qualifier(&quot;配置bean名称&quot;) 来指向具体的实现类。这样在实现改变的时候，修改配置文件中的bean名称即可","like_count":0},{"had_liked":false,"id":306672,"user_name":"易飞","can_delete":false,"product_type":"c1","uid":2630424,"ip_address":"","ucode":"32AC28754237F7","user_header":"https://static001.geekbang.org/account/avatar/00/28/23/18/4284361f.jpg","comment_is_top":false,"comment_ctime":1628666431,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628666431","product_id":100039001,"comment_content":"还没看到工厂模式，学完再回来","like_count":0},{"had_liked":false,"id":304282,"user_name":"九先生","can_delete":false,"product_type":"c1","uid":1122533,"ip_address":"","ucode":"A63A333299D485","user_header":"https://static001.geekbang.org/account/avatar/00/11/20/e5/f66d6144.jpg","comment_is_top":false,"comment_ctime":1627312864,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627312864","product_id":100039001,"comment_content":"这样的设计还是不够完美，对此，你有更好的实现思路吗？<br>答：spring依赖注入+策略模式","like_count":0},{"had_liked":false,"id":301575,"user_name":"JKwar","can_delete":false,"product_type":"c1","uid":1047466,"ip_address":"","ucode":"B733CA24D5701F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/aa/01fedf6c.jpg","comment_is_top":false,"comment_ctime":1625746662,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1625746662","product_id":100039001,"comment_content":"课堂讨论：依赖注入或者配置文件加反射","like_count":0},{"had_liked":false,"id":300493,"user_name":"小帅","can_delete":false,"product_type":"c1","uid":1239663,"ip_address":"","ucode":"4129A7E9427FFC","user_header":"https://static001.geekbang.org/account/avatar/00/12/ea/6f/09de5f65.jpg","comment_is_top":false,"comment_ctime":1625195910,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625195910","product_id":100039001,"comment_content":"思考题：用单例模式获取上传附件的工具类，在工具类当中决定使用的是哪个上传文件的具体实现，这样只要修改这个上传附件的工具类即可，不需要在各个业务地方更改，同时还可以在工具类中根据不同的环境决定使用哪个上传附件的类，比如本地用自己的文件服务器，线上环境用阿里云等","like_count":0},{"had_liked":false,"id":300109,"user_name":"Geek_f0f0bc","can_delete":false,"product_type":"c1","uid":2678074,"ip_address":"","ucode":"A754BEC95E2BC6","user_header":"https://static001.geekbang.org/account/avatar/00/28/dd/3a/92726fb6.jpg","comment_is_top":false,"comment_ctime":1625012813,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625012813","product_id":100039001,"comment_content":"最后问题应该违背 设计模式6大原则中的最少知道原则 也叫迪米特原则","like_count":0},{"had_liked":false,"id":300108,"user_name":"Geek_f0f0bc","can_delete":false,"product_type":"c1","uid":2678074,"ip_address":"","ucode":"A754BEC95E2BC6","user_header":"https://static001.geekbang.org/account/avatar/00/28/dd/3a/92726fb6.jpg","comment_is_top":false,"comment_ctime":1625012711,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625012711","product_id":100039001,"comment_content":"课后问题回复：ImageStore 作为ImageProcessingJob的属性 通过构造函数或者自动注入 进行具体实例对象的赋值","like_count":0},{"had_liked":false,"id":295835,"user_name":"I LOVE DM","can_delete":false,"product_type":"c1","uid":2006342,"ip_address":"","ucode":"6EA297D5A0E4C8","user_header":"https://static001.geekbang.org/account/avatar/00/1e/9d/46/ce8f7a26.jpg","comment_is_top":false,"comment_ctime":1622615506,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622615506","product_id":100039001,"comment_content":"配置（工厂选择算法的条件&#47;可以热部署）+策略模式（根据配置，运行时动态的获取执行对象）","like_count":0},{"had_liked":false,"id":293365,"user_name":"夜雨声烦","can_delete":false,"product_type":"c1","uid":1349749,"ip_address":"","ucode":"87D8DB1E32522A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK6mh3xlaMoGtWjmVJh2LutdLcQcPbKNjRlVru3bx8ynPhgwuGhhdzTkwEMoXbvBtgkcDSfom1kZg/132","comment_is_top":false,"comment_ctime":1621351731,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621351731","product_id":100039001,"comment_content":"没觉得重构之后的代码比之前的代码好啊。对于重构之后的代码如果需要更改为私有云的话还是要把之前调用阿里云的接口更改为私有云，要更改的地方一样多吧","like_count":0},{"had_liked":false,"id":293325,"user_name":"Jiang Zheng","can_delete":false,"product_type":"c1","uid":2362784,"ip_address":"","ucode":"B6F0BC5E5D91BF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/ribDhYiajmzh6OQ4t1IM2anh1o386xniaq4hK4QyDAB3oPfA4gj7h8RpqnSTLnztQwwTOgrJojiblpEN6GJheoQQZA/132","comment_is_top":false,"comment_ctime":1621335704,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621335704","product_id":100039001,"comment_content":"可以用配置或spi","like_count":0},{"had_liked":false,"id":292172,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1620711398,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620711398","product_id":100039001,"comment_content":"第8行代码，可以改用一个固定类来替代，该固定类用来实例化接口的实现类，固定类可以用一个静态的方法来返回，当接口中的实现类改变时，只需要要改变固定类的的实例化方法就可以了，其他引用固定类的源代码都不需要做任何改动。","like_count":0},{"had_liked":false,"id":290809,"user_name":"刘雨声","can_delete":false,"product_type":"c1","uid":1779782,"ip_address":"","ucode":"9A4A01B2E3F1C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL7LuzpjBx3skGGZUbbPaia3GibvicPSiciaozXGa8MM7Gj2TZ1wXg0y3cSsJpsAy0rHSWHIVd8boQ7BCw/132","comment_is_top":false,"comment_ctime":1619764461,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619764461","product_id":100039001,"comment_content":"ImageStoreFactory.getInstance() { new  PrivateImageStore();}<br><br>调用不用改，只改工厂实例就行了。","like_count":0},{"had_liked":false,"id":289828,"user_name":"怀斯登","can_delete":false,"product_type":"c1","uid":2365645,"ip_address":"","ucode":"14C35C572616E7","user_header":"https://static001.geekbang.org/account/avatar/00/24/18/cd/c1076045.jpg","comment_is_top":false,"comment_ctime":1619193212,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619193212","product_id":100039001,"comment_content":"可以使用策略者模式来解决具体使用什么样的图片存储方式。","like_count":0},{"had_liked":false,"id":288177,"user_name":"仧","can_delete":false,"product_type":"c1","uid":2562972,"ip_address":"","ucode":"FD5AA7D4BA206A","user_header":"https://static001.geekbang.org/account/avatar/00/27/1b/9c/a15a03a4.jpg","comment_is_top":false,"comment_ctime":1618330528,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618330528","product_id":100039001,"comment_content":"稳定的接口，不稳定的实现，用来判断是否使用接口","like_count":0},{"had_liked":false,"id":286081,"user_name":"吕成 Zero","can_delete":false,"product_type":"c1","uid":2410746,"ip_address":"","ucode":"5665769CC41329","user_header":"https://static001.geekbang.org/account/avatar/00/24/c8/fa/baf9847c.jpg","comment_is_top":false,"comment_ctime":1617152420,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617152420","product_id":100039001,"comment_content":"最后的思考题中第8行的 ImageStore imageStore 可以在 ImageProcessingJob 类中以属性的形式定义，这是一种组合的关系。","like_count":0},{"had_liked":false,"id":284300,"user_name":"。","can_delete":false,"product_type":"c1","uid":2529737,"ip_address":"","ucode":"BA28F53B20B647","user_header":"https://static001.geekbang.org/account/avatar/00/26/99/c9/6b193193.jpg","comment_is_top":false,"comment_ctime":1616154465,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616154465","product_id":100039001,"comment_content":"用模板模式，不香吗","like_count":0},{"had_liked":false,"id":283789,"user_name":"风","can_delete":false,"product_type":"c1","uid":1077538,"ip_address":"","ucode":"104638BF19B048","user_header":"https://static001.geekbang.org/account/avatar/00/10/71/22/b8c596b6.jpg","comment_is_top":false,"comment_ctime":1615936821,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615936821","product_id":100039001,"comment_content":"我们可以创建ImageStore的工厂类，在使用时指定不同的参数生产相应的ImageStore实现类；也可以使用反射，将具体实现类名作为参数配置，使用时直接使用反射构造，这样就可以在不修改代码的情况下实现不同策略之间的切换","like_count":0},{"had_liked":false,"id":282058,"user_name":"黄金果","can_delete":false,"product_type":"c1","uid":1456586,"ip_address":"","ucode":"329811FF99F4B8","user_header":"https://static001.geekbang.org/account/avatar/00/16/39/ca/cdc58834.jpg","comment_is_top":false,"comment_ctime":1615039276,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615039276","product_id":100039001,"comment_content":"对于课后的问题, 我有一种思路是否可以在ImageProcessingJob 调用的时候在封装一层, 比如叫ImageProcessing, 外界都通过 ImageProcessing调用, 需要修改的时候, 仅修改ImageProcessing内部一处即可","like_count":0},{"had_liked":false,"id":279822,"user_name":"DreamHeng","can_delete":false,"product_type":"c1","uid":1599490,"ip_address":"","ucode":"5562BFD8375138","user_header":"https://static001.geekbang.org/account/avatar/00/18/68/02/2d394d89.jpg","comment_is_top":false,"comment_ctime":1613976069,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613976069","product_id":100039001,"comment_content":"在写代码的时候，同事给过建议“不要为了复用而复用”，当时感觉挺对的，但现在感觉也不太对，在写一些工具类的时候是有些道理的，但是在写一些业务代码时，特别是需要对外暴露的服务代码，需要考虑下如何抽象出来代码模型，减少暴露代码细节","like_count":0},{"had_liked":false,"id":279191,"user_name":"星夜","can_delete":false,"product_type":"c1","uid":1128491,"ip_address":"","ucode":"3B46C09D994CEB","user_header":"https://static001.geekbang.org/account/avatar/00/11/38/2b/9db9406b.jpg","comment_is_top":false,"comment_ctime":1613650428,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613650428","product_id":100039001,"comment_content":"最常用的方式就是依赖注入了，修改注入的类型","like_count":0},{"had_liked":false,"id":278687,"user_name":"孙长平  ","can_delete":false,"product_type":"c1","uid":1216161,"ip_address":"","ucode":"412B7B3899AE6B","user_header":"","comment_is_top":false,"comment_ctime":1613201456,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613201456","product_id":100039001,"comment_content":"ImageStore imageStore 使用注入方式注入进去即可","like_count":0},{"had_liked":false,"id":278223,"user_name":"莯兮","can_delete":false,"product_type":"c1","uid":2438051,"ip_address":"","ucode":"792C49B2F9AB82","user_header":"https://static001.geekbang.org/account/avatar/00/25/33/a3/f228814d.jpg","comment_is_top":false,"comment_ctime":1612834360,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1612834360","product_id":100039001,"comment_content":"public interface ImageStore<br> { String upload(Image image, String bucketName); Image download(String url);}<br>这里为什么使用接口而不是抽象类呢？","like_count":0,"discussions":[{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363035,"discussion_content":"看来桥接模式的层次更高啊","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1617101444,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1160678,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b5/e6/c67f12bd.jpg","nickname":"左耳朵东","note":"","ucode":"60134ACF12BB52","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":407307,"discussion_content":"也就是说，单从面相接口编程的角度，可以写出文中接口告警的第一种写法（仅对告警功能进行抽象），从桥接模式的角度才能写出第二种写法（将告警功能细分成严重程度、通知渠道两个维度，分别进行抽象，并在使用的时候自由组合）","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1634975438,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1529210,"avatar":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","nickname":"freesocean","note":"","ucode":"CAD4C80CF569D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":398987,"discussion_content":"关与接口也要变化，我的理解是java中有JDBC，但同样在.Net等用到的可能是ODBC，ADO等接口。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1632883158,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2589175,"avatar":"","nickname":"Geek_ea09cb","note":"","ucode":"24B660A6777A88","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371017,"discussion_content":"logger 这个例子好，appender 负责数据输出到什么地方去，encoder 负责数据输出的格式，这两东西合起来就是一个 log","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1619611878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1101017,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cc/d9/20d4f7c2.jpg","nickname":"大雁小鱼","note":"","ucode":"44090581E59FDA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336139,"discussion_content":"没看出来这是桥接","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1608512543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1227840,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/40/2279cfb5.jpg","nickname":"大力水手Jerry","note":"","ucode":"E4A6C71E275DB5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1101017,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cc/d9/20d4f7c2.jpg","nickname":"大雁小鱼","note":"","ucode":"44090581E59FDA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338154,"discussion_content":"logger相当于是桥接器，它的具类包含了appender和encoder的接口实例","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1609204513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":336139,"ip_address":""},"score":338154,"extra":""}]},{"author":{"id":1766127,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/f2/ef/014389c5.jpg","nickname":"李明威","note":"","ucode":"199C95F3A4C1A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332956,"discussion_content":"解释的很通透","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1607401956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1880582,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/b2/06/2086d76d.jpg","nickname":"buggetout","note":"","ucode":"63A948EF415FDD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":273127,"discussion_content":"Logger这个例子是真好","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590414262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1323834,"avatar":"https://static001.geekbang.org/account/avatar/00/14/33/3a/2ac7a35e.jpg","nickname":"FrancisTmac","note":"","ucode":"A5AE74F266DA63","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559984,"discussion_content":"我理解稳定是指对于使用者的稳定，变化则是不可避免的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649092127,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1476490,"avatar":"https://static001.geekbang.org/account/avatar/00/16/87/8a/07ab933c.jpg","nickname":"璀璨星空","note":"","ucode":"CE6324C4261A52","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381023,"discussion_content":"总结很到位啊，桥接真是设计模式的一门艺术了，醍醐灌顶","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624870921,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1203564,"avatar":"https://static001.geekbang.org/account/avatar/00/12/5d/6c/40bb7d92.jpg","nickname":"张玉棠","note":"","ucode":"40BF9506955A0B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295563,"discussion_content":"非常好，GET到了新知识","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596250035,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1155275,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","nickname":"张三丰","note":"","ucode":"3A6215A40B3B21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286421,"discussion_content":"这个解释太牛逼了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593169037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":277580,"user_name":"鲁鸣","can_delete":false,"product_type":"c1","uid":2152306,"ip_address":"","ucode":"974BA3C3E64630","user_header":"https://static001.geekbang.org/account/avatar/00/20/d7/72/cbef720d.jpg","comment_is_top":false,"comment_ctime":1612484635,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612484635","product_id":100039001,"comment_content":"最近实践中发现，如果某个类比较复杂，代码偏多，最好有接口，这样别人可以直接通过接口就可以知道类的功能","like_count":0},{"had_liked":false,"id":274294,"user_name":"funnyx","can_delete":false,"product_type":"c1","uid":1115049,"ip_address":"","ucode":"A9B8E27919AE4D","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoZqcVJzUjfu5noOW6OPAh6ibrBicibLmicibnVyVLHdf7GwAzf2th5s1oQ9pUbLpmq2mlVBauUZn8QUnw/132","comment_is_top":false,"comment_ctime":1610957277,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610957277","product_id":100039001,"comment_content":"如果只是为了这个接口的某个实现类可用与否，那可以借鉴Spring beanPostProcessor的处理，在具体的processor里来控制相应的处理是否可用，这样就可以主程序不需要修改，只有相应的组件修改","like_count":0},{"had_liked":false,"id":274280,"user_name":"刘立嘉","can_delete":false,"product_type":"c1","uid":2414637,"ip_address":"","ucode":"1241140EBE7FE3","user_header":"https://static001.geekbang.org/account/avatar/00/24/d8/2d/6ec3760c.jpg","comment_is_top":false,"comment_ctime":1610952533,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610952533","product_id":100039001,"comment_content":"使用静态工厂类","like_count":0},{"had_liked":false,"id":272066,"user_name":"会飞的蹦蹦","can_delete":false,"product_type":"c1","uid":1307168,"ip_address":"","ucode":"4A5B311F971DBE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtwfeiaW2Dwn1PQROLZAIMwCJnf95MVYicHVVzZDLYHoRLvkGr1KkgZZXdSrZaRuCiclZWELtHpmXxg/132","comment_is_top":false,"comment_ctime":1609924178,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609924178","product_id":100039001,"comment_content":"作者应该是想引出工厂模式的概念。但是我纠结的是，不管怎么改，最终如果在原有所谓aliyun的上传模式改为别的上传模式，都得去修改那一行代码吧，我觉得从这个角度出发，用不用工厂模式去抽象出来对象的创建，是不是意义也不大啊，这样是不是也有点为了模式而模式，或者说有点“过”了呢~","like_count":0},{"had_liked":false,"id":271805,"user_name":"zh","can_delete":false,"product_type":"c1","uid":1982711,"ip_address":"","ucode":"98772B1B6C6E06","user_header":"https://static001.geekbang.org/account/avatar/00/1e/40/f7/e62bbc62.jpg","comment_is_top":false,"comment_ctime":1609815950,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609815950","product_id":100039001,"comment_content":"个人觉得COM的接口和组件设计对理解面向对象、接口、基于接口编程很有帮助，接口更像一个协议、约定，基于接口编程是一种抽象思维的体现，使用者甚至完全不知道接口指向的具体类型，也就无从了解实现细节了。","like_count":0},{"had_liked":false,"id":265724,"user_name":"蓝天空的幸福","can_delete":false,"product_type":"c1","uid":2053568,"ip_address":"","ucode":"AB46C044F3B6D2","user_header":"https://static001.geekbang.org/account/avatar/00/1f/55/c0/1a7893d4.jpg","comment_is_top":false,"comment_ctime":1606994021,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606994021","product_id":100039001,"comment_content":"基于接口而非实现编程，某种程度上可以理解为 ：“关注“ 接口，”“忽略”实现类。<br>一切功能（API）以接口为准，实现类仅仅提供 为接口变量赋值的功能；我们 “只能使用” 接口提供的API，“不能使用” 实现类提供的API，即: 使用到的方法必须是 接口中定义的。","like_count":0},{"had_liked":false,"id":265191,"user_name":"snake","can_delete":false,"product_type":"c1","uid":2347137,"ip_address":"","ucode":"47BFFE4D048156","user_header":"https://static001.geekbang.org/account/avatar/00/23/d0/81/d5c8e46e.jpg","comment_is_top":false,"comment_ctime":1606809873,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606809873","product_id":100039001,"comment_content":"我想到的办法是使用spring的依赖自动注入，将接口实现纳入spring的管理范围，用的时候通过注解就可以实现自动注入","like_count":0},{"had_liked":false,"id":264528,"user_name":"刘小辉","can_delete":false,"product_type":"c1","uid":2340338,"ip_address":"","ucode":"E1D77D8B56F3A5","user_header":"https://static001.geekbang.org/account/avatar/00/23/b5/f2/58afc1d4.jpg","comment_is_top":false,"comment_ctime":1606490693,"is_pvip":true,"replies":[{"id":"96071","content":"������","user_name":"作者回复","comment_id":264528,"uid":"1190123","ip_address":"","utype":1,"ctime":1606700591,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"1606490693","product_id":100039001,"comment_content":"第一：思考题我觉得可以用SPI！<br>第二：   抽象类的功能应该远远多于接口。但是定义抽象类的代价是比较高的。因为像java,C#这样的高级语言，是不允许多继承的所以，你在设计一个父类为抽象类的时候，一定得将这个类的子类所有的共同属性和方法都定义出来；但是接口可以不用这样。因为接口是一个方法的集合，一个类可以实现多个接口。所以，你的接口里面只有一个方法，还是两个方法，都是可以的。之后如果还有新的方法，我大不了再设计一个接口就是了。所以说，抽象类的设计必须谨慎，接口的设计很灵活。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510589,"discussion_content":"������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700591,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263542,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1606180721,"is_pvip":true,"replies":[{"id":"96092","content":"说的没错","user_name":"作者回复","comment_id":263542,"uid":"1190123","ip_address":"","utype":1,"ctime":1606700730,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"1606180721","product_id":100039001,"comment_content":"我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性、扩展性、可维护性。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510230,"discussion_content":"说的没错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261983,"user_name":"Geek_5a5d9a","can_delete":false,"product_type":"c1","uid":2046477,"ip_address":"","ucode":"8A444C96DB4389","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/6gic9ib9c9865ec0rKEPZJtvbj2yINgrGtjibr95luMEZdJ0oBV0hJUbE7iaeia4B802CibweG3yicJSCo5c93MeCSxMg/132","comment_is_top":false,"comment_ctime":1605597219,"is_pvip":false,"replies":[{"id":"96128","content":"������","user_name":"作者回复","comment_id":261983,"uid":"1190123","ip_address":"","utype":1,"ctime":1606701212,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"1605597219","product_id":100039001,"comment_content":"我的想法是对外提供构造函数,  构造不同场景的上传, 例如:<br><br>public ImageProcessingJob aliyunProcessingJob() {<br>        &#47;&#47; 设置类的基本属性<br>        &#47;&#47; self.imageStore = new AliyunImageStore()<br>    }<br>    public ImageProcessingJob privateProcessingJob() {<br>        &#47;&#47; 设置类的属性<br>        &#47;&#47; self.imageStore = new PrivateImageStore()<br>    }","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509681,"discussion_content":"������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606701212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261516,"user_name":"刘永超","can_delete":false,"product_type":"c1","uid":2066121,"ip_address":"","ucode":"94CCA30F9E1567","user_header":"https://static001.geekbang.org/account/avatar/00/1f/86/c9/456f803d.jpg","comment_is_top":false,"comment_ctime":1605368809,"is_pvip":false,"replies":[{"id":"96141","content":"哈哈，爱你","user_name":"作者回复","comment_id":261516,"uid":"1190123","ip_address":"","utype":1,"ctime":1606701404,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"1605368809","product_id":100039001,"comment_content":"老师把行业“黑话”讲透彻了，捅破那层窗户纸，不用再纠结于一些基本概念。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509506,"discussion_content":"哈哈，爱你","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606701404,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257260,"user_name":"Kingram","can_delete":false,"product_type":"c1","uid":2247700,"ip_address":"","ucode":"212E403E81F2FC","user_header":"https://static001.geekbang.org/account/avatar/00/22/4c/14/8fa39544.jpg","comment_is_top":false,"comment_ctime":1603896925,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603896925","product_id":100039001,"comment_content":"工厂方法会好点，新需求修改只需要修改工厂的方法","like_count":0},{"had_liked":false,"id":257177,"user_name":"彭发红","can_delete":false,"product_type":"c1","uid":1461374,"ip_address":"","ucode":"9BAC208700791E","user_header":"https://static001.geekbang.org/account/avatar/00/16/4c/7e/4771d8a4.jpg","comment_is_top":false,"comment_ctime":1603872904,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1603872904","product_id":100039001,"comment_content":"传入可变参数+链式设计模式","like_count":0},{"had_liked":false,"id":255937,"user_name":"紫日","can_delete":false,"product_type":"c1","uid":1207410,"ip_address":"","ucode":"73A8DEE323AC19","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXSb2jAzlMM0JdTjWrNiaq2uR9eeloBYp906POddb9evmuj5f4CUoO6ge8TibibwtZicnl1sRHic9rW7g/132","comment_is_top":false,"comment_ctime":1603461202,"is_pvip":true,"discussion_count":0,"race_medal":4,"score":"1603461202","product_id":100039001,"comment_content":"我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。在定义接口的时候，不要暴露任何实现细节。接口的定义只表明做什么，而不是怎么做。而且，在设计接口的时候，我们要多思考一下，这样的接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候，不需要任何接口定义的改动。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493515,"discussion_content":"是我说的第二种理解方式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588130058,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1792693,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLksibnCgErxGkPrbA3eCdmamvGHD7HAL6LwBOT7U6oTlql8arcb64tVMKBy6rXkBOfe8n4vdSeiaPQ/132","nickname":"Geek_pillar6699","note":"","ucode":"5DBC09E915FA05","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":353559,"discussion_content":"这个例子比争哥文中的例子似乎好理解一些（还是说争哥文中的例子更有深度、本人不才暂时理解不到呢😂）","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1615173497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1022349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/99/8d/4d5dbfc5.jpg","nickname":"王喜春","note":"","ucode":"436E91FDED1B30","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387478,"discussion_content":"&#34;那么这种模式只有M+N个类就可以描述所有类型，这就是M*N的继承类爆炸简化成了M+N组合。&#34;, 赞这个总结。 ","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1628210772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384347,"discussion_content":"盖了帽了我的老baby","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1626510433,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2225926,"avatar":"","nickname":"Geek_eaff30","note":"","ucode":"751D26C18D13C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380299,"discussion_content":"这个确实好理解多了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1624430157,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1351418,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9e/fa/8d206a46.jpg","nickname":"丁丁丁丁丁大树。","note":"","ucode":"9145022F723883","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591548,"discussion_content":"看到这个评价，我悟了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666652604,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2546944,"avatar":"https://static001.geekbang.org/account/avatar/00/26/dd/00/63bfbea9.jpg","nickname":"码不能停","note":"","ucode":"D43C94F7106936","race_medal":5,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590270,"discussion_content":"透彻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665643892,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"中国香港"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1913231,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIgiarK8ic7vY1RuR65ESnibhR5D6ic4rCf6DW9PBS4UCHcEZjibZWwGeicU82EllIic5nBcia0B0x0TcsVdQ/132","nickname":"程辉","note":"","ucode":"E9B49C5DDA84CD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588400,"discussion_content":"评论区里面有大神","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663743148,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2041199,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/25/6f/bbf7bded.jpg","nickname":"Andrew","note":"","ucode":"837D7A71307A49","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588032,"discussion_content":"我觉得可以讲品牌和档位都独立成类，然后组合进car这个类中","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663480684,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"中国香港"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2662969,"avatar":"https://static001.geekbang.org/account/avatar/00/28/a2/39/3ee6f996.jpg","nickname":"You","note":"","ucode":"ACBDB82E9B39C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568709,"discussion_content":"我个人觉得，桥接模式就类似于多个继承模式的嵌套。首先Car作为抽象，而宝马、奔驰、迪奥...作为一套实现没问题，但是因为Car的挡位又有一套实现，如果不再考虑继承模式，那么就需要给宝马、奔驰、迪奥...每人各自来一套实现，就需要总共实现N*M次，这样显得很麻烦，如果再给Car中的挡位再来一套低维度的抽象（我认为所谓的低维度就是作为属性的对象），再给Car的挡位再做一套实现即可，此时只需要实现N+M次。初始Car中抽象就包含了另一套Car挡位的抽象了，此时使用Car组合Car挡位就可以认为是Car桥接了Car挡位，Car可以独立开发，而Car挡位也可以独立开发。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651204572,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1397516,"avatar":"https://static001.geekbang.org/account/avatar/00/15/53/0c/b4907516.jpg","nickname":"Marco","note":"","ucode":"796A4B9D1DE55D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551120,"discussion_content":"牛逼...看了这个理解茅塞顿开了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644903329,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2634637,"avatar":"https://static001.geekbang.org/account/avatar/00/28/33/8d/767a13ec.jpg","nickname":"InHero","note":"","ucode":"F1D09AA0EBABDF","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542970,"discussion_content":"牛逼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640919053,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2831163,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/33/3b/0b25b622.jpg","nickname":"陆一鸣猜不动","note":"","ucode":"68E89A037F9A0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531680,"discussion_content":"牛逼！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637381957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1561173,"avatar":"","nickname":"笑天","note":"","ucode":"B71B671B302D3B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":414134,"discussion_content":"我有一点疑问，我认为概念里一个抽象的不同纬度的实现，和你举的例子不太一样。你说的m+n我赞同，但是需要是一个抽象的实现，应该不是这种一来就是以依赖存在的一种关系。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636676223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1542752,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8a/60/6c3e104c.jpg","nickname":"jestem","note":"","ucode":"808083CDFE69BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":410084,"discussion_content":"厉害。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635595444,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2571052,"avatar":"https://static001.geekbang.org/account/avatar/00/27/3b/2c/c82d7989.jpg","nickname":"夸虾滑专家","note":"","ucode":"33328A4B1D3D57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382580,"discussion_content":"企业级理解！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625640446,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363036,"discussion_content":"牛逼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617101732,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2258139,"avatar":"https://static001.geekbang.org/account/avatar/00/22/74/db/9a19a859.jpg","nickname":"海南小硕哥","note":"","ucode":"EA5AA6D5E35667","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328653,"discussion_content":"M*N < M+N时候 是不是就不用桥接来实现了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606204288,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1948635,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/bb/db/f8c74599.jpg","nickname":"学了忘","note":"","ucode":"00789BBC1E51E9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2258139,"avatar":"https://static001.geekbang.org/account/avatar/00/22/74/db/9a19a859.jpg","nickname":"海南小硕哥","note":"","ucode":"EA5AA6D5E35667","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384416,"discussion_content":"什么情况下M*N < M+N","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626578818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":328653,"ip_address":""},"score":384416,"extra":""},{"author":{"id":1293322,"avatar":"https://static001.geekbang.org/account/avatar/00/13/bc/0a/173061df.jpg","nickname":"嬷嬷默默拔萝卜","note":"","ucode":"65FE68B1187C39","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1948635,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/bb/db/f8c74599.jpg","nickname":"学了忘","note":"","ucode":"00789BBC1E51E9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393932,"discussion_content":"mn<m+n 假如市面上有很多牌子的车但是只有手动挡存在 ？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631666724,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":384416,"ip_address":""},"score":393932,"extra":""},{"author":{"id":2819343,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/05/0f/f86cf69c.jpg","nickname":"L","note":"","ucode":"231712A1236927","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1293322,"avatar":"https://static001.geekbang.org/account/avatar/00/13/bc/0a/173061df.jpg","nickname":"嬷嬷默默拔萝卜","note":"","ucode":"65FE68B1187C39","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558844,"discussion_content":"那就不是多个纬度变化了吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648481709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":393932,"ip_address":""},"score":558844,"extra":""}]},{"author":{"id":1139128,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJh4fE4WryeIpjKCYB7TuWS2IEFV0paiaZt3hSh8jrPZRD8cvalPWndTv1VbdDiaEKibY0IgGGPEMbCw/132","nickname":"刘聪为","note":"","ucode":"8DFDCA7B37D04E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326479,"discussion_content":"这个好理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605604521,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2122539,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","nickname":"阿骨打","note":"","ucode":"35EADA5550162A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306600,"discussion_content":"牛，真是盖了帽了！你说的意思 我觉得理解起来更容易，更符合我的想法！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600326489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253511,"user_name":"@许还真","can_delete":false,"product_type":"c1","uid":1099324,"ip_address":"","ucode":"6D754D5AE44CEC","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/3c/8ab9deb0.jpg","comment_is_top":false,"comment_ctime":1602757780,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602757780","product_id":100039001,"comment_content":"貌似是依赖注入，不要在里面new 一个对象，外面传进来。<br>面向接口，而非实现","like_count":0},{"had_liked":false,"id":250070,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1600924442,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600924442","product_id":100039001,"comment_content":"将图片存储类也抽象一个接口，并且通过依赖注入的方式注入进来","like_count":0},{"had_liked":false,"id":249775,"user_name":"朱月俊","can_delete":false,"product_type":"c1","uid":1017707,"ip_address":"","ucode":"4DA0728B862FBD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/6b/0b6cd39a.jpg","comment_is_top":false,"comment_ctime":1600786205,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600786205","product_id":100039001,"comment_content":"使用工厂模式，统一传入一个类型参数，然后在工厂实例化中根据类型名返回具体的存储实例。这样每次新增一种存储类型，只需要修改传入工厂的类型名即可。","like_count":0},{"had_liked":false,"id":247754,"user_name":"WilliamVector","can_delete":false,"product_type":"c1","uid":1898112,"ip_address":"","ucode":"E0D3C3D4FCB7C9","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f6/80/85ec2c2a.jpg","comment_is_top":false,"comment_ctime":1599819379,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599819379","product_id":100039001,"comment_content":"【要点】<br>1、“基于接口而非实现编程”，这条原则的另一个表述方式，是“基于抽象而非实现编程”。后者的表述方式其实更能体现这条原则的设计初衷。我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性、扩展性、可维护性。<br>2、我们在定义接口的时候，一方面，命名要足够通用，不能包含跟具体实现相关的字眼；另一方面，与特定实现有关的方法不要定义在接口中。<br>3、“基于接口而非实现编程”这条原则，不仅仅可以指导非常细节的编程开发，还能指导更加上层的架构设计、系统设计等。比如，服务端与客户端之间的“接口”设计、类库的“接口”设计。<br>【思考】<br>1、如果不需要上层进行选择存储图片到私有云还是公有云，则定义一个通用存储图片的类，在类内可通过读取配置文件等方法来具体指定图片服务器。<br>2、如果需要上层指定图片存储的位子，则通过工厂类实现，传入的参数为存储图片的位置。ImageStroageFactory.createStorage(storageType);","like_count":0},{"had_liked":false,"id":245807,"user_name":"JerryZhu","can_delete":false,"product_type":"c1","uid":1591223,"ip_address":"","ucode":"76850CD45786C1","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","comment_is_top":false,"comment_ctime":1599059273,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599059273","product_id":100039001,"comment_content":"作为一个6年一线开发经验的程序员来说， 回来再从零开始看看曾经为了面试而准备这些概念，其实感慨颇深， 基于抽象，易扩展， 易维护，真是十分感慨啊！深谙其重要性","like_count":0},{"had_liked":false,"id":245804,"user_name":"JerryZhu","can_delete":false,"product_type":"c1","uid":1591223,"ip_address":"","ucode":"76850CD45786C1","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","comment_is_top":false,"comment_ctime":1599059164,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599059164","product_id":100039001,"comment_content":"用动态代理或者静态工厂一类的替换掉第八行","like_count":0},{"had_liked":false,"id":245364,"user_name":"lengrongfu","can_delete":false,"product_type":"c1","uid":1494681,"ip_address":"","ucode":"FD6F35CA561E0B","user_header":"https://static001.geekbang.org/account/avatar/00/16/ce/99/447c33d4.jpg","comment_is_top":false,"comment_ctime":1598925123,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598925123","product_id":100039001,"comment_content":"课后讨论思考：我想的是这个需要放在两种项目场景中讨论，第一种是web项目，有IOC容器，这样就可以自动注入，不用手动创建，注入的Bean就由用户决定注入那个实现类。第二种是没有使用IOC容器的项目，这种场景下就需要使用创建型的设计模式了，对应这里的话就用静态工程就可以了。欢迎留言讨论。","like_count":0},{"had_liked":false,"id":244351,"user_name":"Geek_35cfdd","can_delete":false,"product_type":"c1","uid":1792214,"ip_address":"","ucode":"AD9615ABB4CA25","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoiaP1gptuBzj3AXMpY8yLTIkpuarouOVzLde4636UJ7zAgnOEZibiaAIRVAicFaO64ftH45YOn1pD3VA/132","comment_is_top":false,"comment_ctime":1598491179,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598491179","product_id":100039001,"comment_content":"面向接口编程的核心本质是分离稳定和变化。在外围依赖可以不感知下层的变化。已达到下游自身可扩展的目的。<br>","like_count":0},{"had_liked":false,"id":243018,"user_name":"CaptainZ","can_delete":false,"product_type":"c1","uid":1126126,"ip_address":"","ucode":"E017D84913F930","user_header":"https://static001.geekbang.org/account/avatar/00/11/2e/ee/d7070494.jpg","comment_is_top":false,"comment_ctime":1597920495,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597920495","product_id":100039001,"comment_content":"用策略模式 不策略返回不同对象","like_count":0},{"had_liked":false,"id":242927,"user_name":"郑大钱","can_delete":false,"product_type":"c1","uid":1503067,"ip_address":"","ucode":"114CF48056880E","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/5b/ff28088f.jpg","comment_is_top":false,"comment_ctime":1597894851,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597894851","product_id":100039001,"comment_content":"对埋点的封装，算是最典型的面相接口编程。最开始上报到TalkingData，接着上报到自己的大数据，后来集团融合导致上报迁移，业务层一句代码都不用改。<br>同时也做过过度设计，MJRefresh本来很完善，非要封装一个适配器，想着替换MJRefresh也会很方便。结果封装的适配器没有MJRefresh好用，再也没有人愿意维护。<br>面向接口编程的目的是将不稳定的实现封装成稳定的接口，如果像MJRefresh这种本身就很稳定的实现，就没有必要在为它封装接口了。","like_count":0},{"had_liked":false,"id":241517,"user_name":"JD_Zty","can_delete":false,"product_type":"c1","uid":1074248,"ip_address":"","ucode":"120A513029F728","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/48/c292eaa5.jpg","comment_is_top":false,"comment_ctime":1597318296,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597318296","product_id":100039001,"comment_content":"把ImageStore作为ImageProcessingJob的私有成员变量，在构造ImageProcessingJob类时，将ImageStore的实现实例传入，进行赋值。","like_count":0},{"had_liked":false,"id":241397,"user_name":"大力","can_delete":false,"product_type":"c1","uid":1364353,"ip_address":"","ucode":"1B2125C519443D","user_header":"https://static001.geekbang.org/account/avatar/00/14/d1/81/89ba9d81.jpg","comment_is_top":false,"comment_ctime":1597284218,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597284218","product_id":100039001,"comment_content":"思考题思路：抽象工厂模式 + 依赖注入","like_count":0},{"had_liked":false,"id":240804,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1597070392,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597070392","product_id":100039001,"comment_content":"通过依赖注入的方式传入对应的实现","like_count":0},{"had_liked":false,"id":239992,"user_name":"Geek_809561","can_delete":false,"product_type":"c1","uid":2037722,"ip_address":"","ucode":"94FA67AEFB6CA0","user_header":"","comment_is_top":false,"comment_ctime":1596707386,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596707386","product_id":100039001,"comment_content":"这节课感觉收获最大的一点是。如何设计出好的接口。抓住最基本的一点，接口就是是做什么的。任何其他附加的东西都不要。","like_count":0},{"had_liked":false,"id":239060,"user_name":"long","can_delete":false,"product_type":"c1","uid":1595158,"ip_address":"","ucode":"8424683A801718","user_header":"https://static001.geekbang.org/account/avatar/00/18/57/16/b7b4fe79.jpg","comment_is_top":false,"comment_ctime":1596424507,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596424507","product_id":100039001,"comment_content":"第一反应想到的是策略模式<br>1. 将 ImageStore 交给 spring 容器管理，在 @Bean 处统一替换，缺点就是一替换整体全部替换，不能做到灵活处理<br>2. 使用工厂+策略模式 getImageStore(String storeType).upload(image, BUCKET_NAME);，在 getImageStore 类中可以定义一个 map 实现将所有的实现装载好，这个时候取出来直接用即可","like_count":0},{"had_liked":false,"id":238871,"user_name":"Geek_a5edac","can_delete":false,"product_type":"c1","uid":1954784,"ip_address":"","ucode":"A47341B4DB9C8E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/d4MHbXBwovYHW7xA18j88ibw1wS2R1JCoH5oLJIMUTdXe07dyVeTNWNzqWUKT7nPg21oClPhy1rSZPFiaibHeUFBA/132","comment_is_top":false,"comment_ctime":1596351789,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596351789","product_id":100039001,"comment_content":"关于抽象，具体到代码编程的时候就是在创建类的时候该如何设计？个人以往对类的认知是一个对象，即一个Entity，然后往往对Entity抽象的时候没有明确的方法论，比如这样一个场景：一个文件上传的处理流程包含资源提取、上传的步骤，那么可以抽象成对应的接口满足不同细化的上传场景。<br>但这些接口本身的对象是什么？我们是基于什么对象抽象出这样的接口的？这时候可以从上传的资源这个对象做抽象，即对象是资源支持的方法有获取和上传。<br>另外，基于接口编程本身是一种抽象的过程，抽象类提供的方法本身是高度抽象的。<br>比如图片存储类，这里关注的是存储，作用的对象是图片。即需要对存储做一个抽象，比如包含上传、下载的行为。对存储做抽象是为了应对不同存储服务方对上传、下载的处理机制不一致的问题，方便扩展，本质上是对存储服务方这个对象的能力抽象。","like_count":0},{"had_liked":false,"id":238806,"user_name":"Java课代表","can_delete":false,"product_type":"c1","uid":1613052,"ip_address":"","ucode":"F17E4A1807FB12","user_header":"https://static001.geekbang.org/account/avatar/00/18/9c/fc/0aa200b5.jpg","comment_is_top":false,"comment_ctime":1596323363,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596323363","product_id":100039001,"comment_content":"思考题：<br>把具体实现对象通过依赖注入的方式传进来，将创建和使用解耦","like_count":0},{"had_liked":false,"id":238390,"user_name":"David","can_delete":false,"product_type":"c1","uid":1021825,"ip_address":"","ucode":"22CBBC13FC97A9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/97/81/e1eaf621.jpg","comment_is_top":false,"comment_ctime":1596158221,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1596158221","product_id":100039001,"comment_content":"使用工厂 或者是策略模式","like_count":0},{"had_liked":false,"id":238195,"user_name":"owen","can_delete":false,"product_type":"c1","uid":1902116,"ip_address":"","ucode":"0E79DA9080A085","user_header":"https://static001.geekbang.org/account/avatar/00/1d/06/24/c2ee3b16.jpg","comment_is_top":false,"comment_ctime":1596092775,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596092775","product_id":100039001,"comment_content":"工厂模式 ImageStore imageStore = ImageStoreFactory.newInstance(PrivateImageStore.class);","like_count":0},{"had_liked":false,"id":234941,"user_name":"西电","can_delete":false,"product_type":"c1","uid":2063037,"ip_address":"","ucode":"95BD4CE9D93018","user_header":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","comment_is_top":false,"comment_ctime":1594836330,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594836330","product_id":100039001,"comment_content":"笔记: 多继承和接口更恰当的说法是behaves like(表现的像)。 吸血鬼继承蝙蝠和人，不能说吸血鬼是人，也不能说吸血鬼是蝙蝠。最恰当的说法是吸血鬼表现的像人和蝙蝠","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498201,"discussion_content":"有点那个意思~👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592526404,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1239916,"avatar":"https://static001.geekbang.org/account/avatar/00/12/eb/6c/5b0e78e5.jpg","nickname":"ming","note":"","ucode":"8A620BA51442C1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582874,"discussion_content":"简单明了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659742209,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"河南"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230660,"user_name":"任忠良","can_delete":false,"product_type":"c1","uid":1197169,"ip_address":"","ucode":"27AB8BEE245136","user_header":"https://static001.geekbang.org/account/avatar/00/12/44/71/28a1adb9.jpg","comment_is_top":false,"comment_ctime":1593442373,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593442373","product_id":100039001,"comment_content":"golang 中的接口更多的是像一种面向未来编程的思维，好多人提到了 io.Writer 和 io.Reader，但是我觉得最能代表 golang 接口的是 sort.Interface，它定义了实现排序的接口，只有 Len() int, Less(i, j int) bool 和 Swap(i, j int) 三个方法，整个 sort 包的大部分方法都是对这个接口的操作。所以在使用时候，任何数据结构实现这三个方法就可以使用 sort 包中的排序操作。","like_count":0},{"had_liked":false,"id":228941,"user_name":"陈衎","can_delete":false,"product_type":"c1","uid":1810649,"ip_address":"","ucode":"8A6535DDB4B611","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a0/d9/49578be1.jpg","comment_is_top":false,"comment_ctime":1592844518,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592844518","product_id":100039001,"comment_content":"配置项+ioc容器+DI注入","like_count":0},{"had_liked":false,"id":227041,"user_name":"潇洒哥","can_delete":false,"product_type":"c1","uid":1110623,"ip_address":"","ucode":"90D8D843D12559","user_header":"","comment_is_top":false,"comment_ctime":1592271545,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592271545","product_id":100039001,"comment_content":"第8行使用依赖倒置原则，改成DI容器注入","like_count":0},{"had_liked":false,"id":226880,"user_name":"X_L～","can_delete":false,"product_type":"c1","uid":1608383,"ip_address":"","ucode":"6BD8C24750F86B","user_header":"https://static001.geekbang.org/account/avatar/00/18/8a/bf/3f7c45c9.jpg","comment_is_top":false,"comment_ctime":1592221870,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592221870","product_id":100039001,"comment_content":"使用策略模式，在策略接口之前创建一个上下文类，然后根据不同的场景去进行路由切换<br>","like_count":0},{"had_liked":false,"id":226855,"user_name":"banana","can_delete":false,"product_type":"c1","uid":1356721,"ip_address":"","ucode":"81378DF8002609","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/3fgqmf5ocmgTHTHnWrN2Yq26dl6jWXiaBzm0P1Arpz4YDHX3EOEe2iaCWCX60icZJGEnjXicGbWArQyN5fGj1Cf3Sw/132","comment_is_top":false,"comment_ctime":1592217425,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592217425","product_id":100039001,"comment_content":"如果我们要替换图片存储方式，还是需要修改很多类似第 8 行那样的代码。这样的设计还是不够完美.<br>个人思考：process函数加上一个参数：public void process(ImageStore imageStore)<br>调用者根据自己的需求带上不同的参数，通过多态，实现不同的存储类型调用自己的方法。","like_count":0},{"had_liked":false,"id":225858,"user_name":"石头","can_delete":false,"product_type":"c1","uid":1437900,"ip_address":"","ucode":"44F1A83FECEDA9","user_header":"https://static001.geekbang.org/account/avatar/00/15/f0/cc/c57ec699.jpg","comment_is_top":false,"comment_ctime":1591876019,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591876019","product_id":100039001,"comment_content":"将ImageStore 作为构造参数注入，具体实现类由外部传入。","like_count":0},{"had_liked":false,"id":222538,"user_name":"Cheney","can_delete":false,"product_type":"c1","uid":1250828,"ip_address":"","ucode":"6ED4F3FDBA6D54","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/0c/53f2792c.jpg","comment_is_top":false,"comment_ctime":1590830235,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590830235","product_id":100039001,"comment_content":"思考题目:可以基于spi机制来实现不同的实现,或者策略模式,工厂模式等来实现","like_count":0},{"had_liked":false,"id":220594,"user_name":"小松","can_delete":false,"product_type":"c1","uid":1125878,"ip_address":"","ucode":"8B139C467E82F3","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/f6/f38f4428.jpg","comment_is_top":false,"comment_ctime":1590291858,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1590291858","product_id":100039001,"comment_content":"提供setImageStore方法， 注入依赖","like_count":0},{"had_liked":false,"id":219755,"user_name":"Geek_East","can_delete":false,"product_type":"c1","uid":1589947,"ip_address":"","ucode":"A1A7CBF9B8FB2D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXKSvfaeicog2Ficx4W3pNeA1KRLOS7iaFy2uoxCDoYpGkGnP6KPGecKia6Dr3MtCkNGpHxAzmTMd0LA/132","comment_is_top":false,"comment_ctime":1590074199,"is_pvip":true,"replies":[{"id":"85680","content":"代码复用","user_name":"作者回复","comment_id":219755,"uid":"1190123","ip_address":"","utype":1,"ctime":1593912017,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"1590074199","product_id":100039001,"comment_content":"想问个问题，泛型的主要目的是代码复用还是抽象呀？","like_count":0,"discussions":[{"author":{"id":2122539,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","nickname":"阿骨打","note":"","ucode":"35EADA5550162A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309079,"discussion_content":"JDBC是这样的， Class.forName(&#34;xxxx.driver&#34;)\nDriver是实现类的同一接口\n抽象类就是ManageDriver，它去调用Driver的实现类，但是怎么实现的不清楚。\n&#34;xxxx.driver&#34; 在类加载期间，会去找ManageDriver的静态方法register，把自己注册进去，形成桥接模式\n抽象层：我要访问数据库\n实现层：我要怎么访问，访问什么数据库。\n\n我的浅薄理解。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1601186737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1053934,"avatar":"https://static001.geekbang.org/account/avatar/00/10/14/ee/d72a8222.jpg","nickname":"攻城拔寨","note":"","ucode":"CBC37183DAB6B2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2122539,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","nickname":"阿骨打","note":"","ucode":"35EADA5550162A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310100,"discussion_content":"我对这种的理解是策略模式😂","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1601617515,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":309079,"ip_address":""},"score":310100,"extra":""},{"author":{"id":2122539,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","nickname":"阿骨打","note":"","ucode":"35EADA5550162A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1053934,"avatar":"https://static001.geekbang.org/account/avatar/00/10/14/ee/d72a8222.jpg","nickname":"攻城拔寨","note":"","ucode":"CBC37183DAB6B2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312278,"discussion_content":"没问题，因为桥接模式是结构型，策略模式是行为型，一个是粗粒度，一个细粒度，一个抽象，一个实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602648026,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":310100,"ip_address":""},"score":312278,"extra":""}]},{"author":{"id":1334409,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIjRETqRjvLESLDZkNTjIiaSibtNYBaS1o8WMUicOFn3ycF3Mgh6LRJibqSBjVBjiaO2ibW0gHkafATb21A/132","nickname":"lmdcx","note":"","ucode":"F2CDD0091ADFD7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211548,"discussion_content":"我和你一样不理解 JDBC 那个例子的意图是想要讲明什么\n我和你的对桥接模式的理解也很相似,.\n\n我自己还有另外一些感触是：\n用设计模式(编码)的方式解决这种匹配关系, 还是有点复杂\n特别是各种对象关系复杂的时候, 不如用数据的方式解决来的灵活\n比如，如果需求进化为：\n根据通知 level 来确定通知哪部分人，以及何种方式通知 \n(比如 level1 的邮件通知运维, level3 的短信、微信、邮件通知所有人)  \n用设计模式解决起来, 显然没有查(数据)表的方式更容易理解更简洁","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584863872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1328354,"avatar":"https://static001.geekbang.org/account/avatar/00/14/44/e2/763526e9.jpg","nickname":"程晓擘","note":"","ucode":"96986D5AE2B96C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1334409,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIjRETqRjvLESLDZkNTjIiaSibtNYBaS1o8WMUicOFn3ycF3Mgh6LRJibqSBjVBjiaO2ibW0gHkafATb21A/132","nickname":"lmdcx","note":"","ucode":"F2CDD0091ADFD7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291280,"discussion_content":"同感，可能我是做客户端开发的，JDBC的例子，真的吸收不了呀。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594771958,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":211548,"ip_address":""},"score":291280,"extra":""},{"author":{"id":1486211,"avatar":"https://static001.geekbang.org/account/avatar/00/16/ad/83/e6a858d2.jpg","nickname":"BK","note":"","ucode":"3772E283DB8AFA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1328354,"avatar":"https://static001.geekbang.org/account/avatar/00/14/44/e2/763526e9.jpg","nickname":"程晓擘","note":"","ucode":"96986D5AE2B96C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363280,"discussion_content":"同感","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617161341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":291280,"ip_address":""},"score":363280,"extra":""}]},{"author":{"id":1195017,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3c/09/b7f0eac6.jpg","nickname":"谁都会变","note":"","ucode":"9965748F7EBB57","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579269,"discussion_content":"1 桥接模式：JDBC 有点person.setWeaPon(Weapon weapon)，设置为刀，枪等等。然后我人去干架 peron.ganJia（）{weapon.attack();}，用得就是武器攻击。 \n2 策略模式：根据策略类型，获取不同的策略。它是strategy.ganJia()。\n然后衍生出\nqiongBPersonStrategy.ganJia()\nvipPersonStrategy.ganJia()。\n\n所以我个人觉得桥接模式是包含了策略模式，比如person.setWeapon(Weapon weapon),这里就是设置不同的策略了。同时它又可以在person这个类的维度做派生自己的子类。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657272617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2699218,"avatar":"","nickname":"Geek_279849","note":"","ucode":"FC6A3514FC955C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556365,"discussion_content":"JDBC和driver，类比车和发动机？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647329580,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219503,"user_name":"郭俊杰","can_delete":false,"product_type":"c1","uid":1082785,"ip_address":"","ucode":"D328E5738A4413","user_header":"https://static001.geekbang.org/account/avatar/00/10/85/a1/2442332c.jpg","comment_is_top":false,"comment_ctime":1590033357,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590033357","product_id":100039001,"comment_content":"对于一直不写接口的我来说，今天算是明白了，在有可能业务变化的时候，为了不影响上游系统，最小的改动，一定要多思考一下抽象，哈哈。","like_count":0},{"had_liked":false,"id":216838,"user_name":"师哥","can_delete":false,"product_type":"c1","uid":1333376,"ip_address":"","ucode":"A86CD1661D370F","user_header":"https://static001.geekbang.org/account/avatar/00/14/58/80/c9e232b6.jpg","comment_is_top":false,"comment_ctime":1589353240,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589353240","product_id":100039001,"comment_content":" 基于接口编程 可以提高程序的可扩展性和灵活性。接口就是一种约定，要在需求可能发生变化的情况下使用，否则没有必要使用","like_count":0},{"had_liked":false,"id":216433,"user_name":"注定非凡","can_delete":false,"product_type":"c1","uid":1113597,"ip_address":"","ucode":"80673056E131B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","comment_is_top":false,"comment_ctime":1589258368,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1589258368","product_id":100039001,"comment_content":"基于接口编程或者说基于抽象编程，而不是实现。这样做的原因是为了提高代码的可扩展性，可变动性。<br><br>因为在实际开发中唯一不变的就是变化，我们需要在设计编码时，提高自己的抽象意识，封装意识，接口意识，写出易扩展，修改的代码","like_count":0},{"had_liked":false,"id":215741,"user_name":"darkleo","can_delete":false,"product_type":"c1","uid":1023395,"ip_address":"","ucode":"126DF780822654","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9d/a3/a780d006.jpg","comment_is_top":false,"comment_ctime":1589093267,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589093267","product_id":100039001,"comment_content":"如果把imagestore封装成工具呢？","like_count":0},{"had_liked":false,"id":215432,"user_name":"tuyu","can_delete":false,"product_type":"c1","uid":1448863,"ip_address":"","ucode":"B235325B541408","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/BIRpwViaN51yynIeFonD7QRlwDCVtKibrG956NTxzEqibOZZVjhMMgibOPmd3VicfYxpknZsic1oJq8KicZvXkmmiajuQg/132","comment_is_top":false,"comment_ctime":1588991481,"is_pvip":false,"replies":[{"id":"86788","content":"这个就没法抽象成接口了，只能每个不同的云平台不同处理了。我们也没法追求在替换云平台时，一点代码都不改。尽量少改动代码就可以了。","user_name":"作者回复","comment_id":215432,"uid":"1190123","ip_address":"","utype":1,"ctime":1594903956,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"1588991481","product_id":100039001,"comment_content":"老师, 我今天碰到一个问题, 如果我创建阿里云k8s, 那么参数是很多很多, 根据接口原则, 我不太清楚未来不同云平台创建k8s需要哪些参数, 那我应该怎么做","like_count":0,"discussions":[{"author":{"id":1385377,"avatar":"https://static001.geekbang.org/account/avatar/00/15/23/a1/b08f3ee7.jpg","nickname":"何妨","note":"","ucode":"EC3983BFF7992A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":406039,"discussion_content":"我觉得问题不是这个，而是传进来的是数组对象，在外部是有可能被改变的，比如多线程后","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634693811,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212063,"user_name":"Tobias","can_delete":false,"product_type":"c1","uid":1803858,"ip_address":"","ucode":"F3225639EDA193","user_header":"https://static001.geekbang.org/account/avatar/00/1b/86/52/b92dc111.jpg","comment_is_top":false,"comment_ctime":1588055832,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588055832","product_id":100039001,"comment_content":"关于思考题：<br>首先要明白&quot;不够完美&quot;指的到底是么，究竟哪点不够完美？我理解是，（1）下游使用ImageStore 可能会new 出多个实例，不好。（2） 如果上游提供的 PrivateImageStore 如果不存在了，会对下游产生影响，上游接口提供方是否有兜底方案？ ","like_count":0},{"had_liked":false,"id":208157,"user_name":"youngitachi","can_delete":false,"product_type":"c1","uid":1214582,"ip_address":"","ucode":"88717CA8B8ED64","user_header":"https://static001.geekbang.org/account/avatar/00/12/88/76/c69b7fe5.jpg","comment_is_top":false,"comment_ctime":1587286267,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1587286267","product_id":100039001,"comment_content":"思考题，个人觉得，在实际编写代码运行的时候，无论如何都无法避免将一个具体的实例绑定到imageStore上去，也就是说，新增一个ImageStore的实现类后，除了新增的这部分代码，不可能在修改原来的代码的基础上就使用这个新的实现类。肯定有地方将这个新的实现类和imageStore绑定。不过考虑到对扩展开放，对修改关闭的原则。我觉得有一下办法修改设计。<br><br>1. 将具体的imageStore当作参数传进来：<br>```java<br><br>&#47;&#47; ImageStore的使用举例<br>public class ImageProcessingJob {<br>  private static final String BUCKET_NAME = &quot;ai_images_bucket&quot;;<br>  &#47;&#47;...省略其他无关代码...<br>  <br>  public void process(ImageStore imageStore) {<br>    Image image = ...;&#47;&#47;处理图片，并封装为Image对象<br>    imagestore.upload(image, BUCKET_NAME);<br>  }<br>```<br>2. 将imageStore设置为成员<br>```java<br><br>&#47;&#47; ImageStore的使用举例<br>public class ImageProcessingJob {<br>  private static final String BUCKET_NAME = &quot;ai_images_bucket&quot;;<br>  private ImageStore imageStore;<br>  &#47;&#47;...省略构造器和其他无关代码...<br>  <br>  public void process() {<br>    Image image = ...;&#47;&#47;处理图片，并封装为Image对象<br>    imagestore.upload(image, BUCKET_NAME);<br>  }<br>```<br>这个方法其实就是策略模式。<br>3、使用工厂方法模式。暂提一下，后面学到的时候自然就明白了。<br>","like_count":0},{"had_liked":false,"id":203291,"user_name":"酸辣土豆丝","can_delete":false,"product_type":"c1","uid":1751234,"ip_address":"","ucode":"0E3E4AFB31E1E6","user_header":"https://static001.geekbang.org/account/avatar/00/1a/b8/c2/d1904d74.jpg","comment_is_top":false,"comment_ctime":1586166885,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586166885","product_id":100039001,"comment_content":"定义一个配置参数来配置存储方式，程序加载的时候，根据配置的值，来动态的加载，对应的存储路径对象","like_count":0},{"had_liked":false,"id":202837,"user_name":"技术骨干","can_delete":false,"product_type":"c1","uid":1098720,"ip_address":"","ucode":"8FCF8DE6D29201","user_header":"https://static001.geekbang.org/account/avatar/00/10/c3/e0/3db22579.jpg","comment_is_top":false,"comment_ctime":1586075516,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586075516","product_id":100039001,"comment_content":"看完之后感觉可以用策略模式试试，<br>将图片的存储方式抽象成一个策略类，<br>然后创建两个实现策略类，比如aliyun 存储，私有云存储，腾讯云存储<br>再创建一个使用策略的类  Context(Strategy strategu) ，executeStrategy(img,arg....)<br>当使用哪种存储方式的时候，就直接调用Context 的executeStrategy","like_count":0},{"had_liked":false,"id":202825,"user_name":"技术骨干","can_delete":false,"product_type":"c1","uid":1098720,"ip_address":"","ucode":"8FCF8DE6D29201","user_header":"https://static001.geekbang.org/account/avatar/00/10/c3/e0/3db22579.jpg","comment_is_top":false,"comment_ctime":1586074609,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586074609","product_id":100039001,"comment_content":"接口的定义只表明做什么，而不是怎么做。而且，在设计接口的时候，我们要多思考一下，这样的接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候，不需要任何接口定义的改动。","like_count":0},{"had_liked":false,"id":202408,"user_name":"Geek_bb8d16","can_delete":false,"product_type":"c1","uid":1735740,"ip_address":"","ucode":"964BD4DB3D9653","user_header":"","comment_is_top":false,"comment_ctime":1585984979,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585984979","product_id":100039001,"comment_content":"模版模式，上传流程相对稳定，先处理，再加载要上传的服务器，再上传，父类定义流程，让子类来实现具体细节，而子类又可以通过接口来实现","like_count":0,"discussions":[{"author":{"id":1073099,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5f/cb/8cb0f54b.jpg","nickname":"Peteryoyo","note":"","ucode":"A0738DA4CC46E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333632,"discussion_content":"说的很通透，理解了才能有这样的总结","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607583484,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1306032,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJcxSpNMqwqyicMvdOSr9ic0p1ABiauHnv7g7YQVSJuoHPoQbYDu3YzdpgmSAk2KricUBQ5yibWBWIq75w/132","nickname":"桂城老托尼","note":"","ucode":"139E4B8EE88B79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219424,"discussion_content":"这个解释有点意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585754552,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":201453,"user_name":"小北","can_delete":false,"product_type":"c1","uid":1101976,"ip_address":"","ucode":"4DAC260AC75B71","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/98/9779cf40.jpg","comment_is_top":false,"comment_ctime":1585790130,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585790130","product_id":100039001,"comment_content":"思考题：我觉得可以采用依赖倒置的原则。简单的版本可以基于工厂模式实现。但是在一般的项目中可以直接使用成熟的ioc框架实现依赖倒置。如java spring中自带的依赖注入，或者c#中的autofac，这些都是“器”级别的。","like_count":0},{"had_liked":false,"id":200335,"user_name":"elasting","can_delete":false,"product_type":"c1","uid":1820716,"ip_address":"","ucode":"03AAFF8D1A75B9","user_header":"","comment_is_top":false,"comment_ctime":1585573483,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585573483","product_id":100039001,"comment_content":"使用spring的条件注入，而条件的判断可以通过配置文件的配置项设置，要替换实例，只需要更改配置项的值就行，这与一个系统要兼容多个数据库是类似的","like_count":0},{"had_liked":false,"id":198524,"user_name":"面向百度编程","can_delete":false,"product_type":"c1","uid":1732780,"ip_address":"","ucode":"8FE04A019D71D1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","comment_is_top":false,"comment_ctime":1585455184,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585455184","product_id":100039001,"comment_content":"您这里说函数的命名不能包含更为详细的细节，您说了把uploadtoaliyun照抄到 privatetoaliyun不合适，这肯定不合适啊，我觉得并没有把为什么不合适讲明白。不暴露更为具体的实现细节，是不是一种好事呢，值得深思，但作为接口，确实是给上游暴露，只不过，再给某个具体实现子类实现的时候，比如aliyun ,privateyun 可以尽可能的简化在其类中的方法命名，看到类名就能知道具体的对应目标，但是如果没有接口用具体详细细节命名也没错，只是增加一点修改时间而已，同样能够给上游带来方便","like_count":0},{"had_liked":false,"id":197256,"user_name":"桂冠远航","can_delete":false,"product_type":"c1","uid":1155463,"ip_address":"","ucode":"5959E1A1DAA05D","user_header":"https://static001.geekbang.org/account/avatar/00/11/a1/87/259ab5a3.jpg","comment_is_top":false,"comment_ctime":1585365662,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585365662","product_id":100039001,"comment_content":"隐藏内部细节这个确实挺对的，最近也在做微信公众号的开发，accessToken获取的逻辑到底应该放在哪里，我也思考了很久。","like_count":0},{"had_liked":false,"id":195965,"user_name":"Six","can_delete":false,"product_type":"c1","uid":1220617,"ip_address":"","ucode":"E297BB638B2BD9","user_header":"https://static001.geekbang.org/account/avatar/00/12/a0/09/4af6ff52.jpg","comment_is_top":false,"comment_ctime":1585226417,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585226417","product_id":100039001,"comment_content":"对于作者的思考题。个人觉得需要考虑实际场景。有两种场景<br>1.如需改变就全部改变。那么在设计的时候提供一个静态方法比如<br> public static ImageStore createImageStoreStore(){<br>         return PrivateImageStore()<br>         &#47;&#47;return AliYunImageStore()<br>    }<br>这样只改这一处地方全局生效。对调用者来说，创建细节隐藏。<br>2.那如果是部分使用私有云部分使用阿里云，可以使用简单工厂。<br> public static ImageStore createImageStoreStore(String storeType){<br>           &#47;&#47;根据storeType来判断创建哪一个实现类 <br>}","like_count":0},{"had_liked":false,"id":194852,"user_name":"墨鱼","can_delete":false,"product_type":"c1","uid":1022720,"ip_address":"","ucode":"8FB5E4DCB8A024","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/00/654be3f7.jpg","comment_is_top":false,"comment_ctime":1585111138,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585111138","product_id":100039001,"comment_content":"想起来我以前写的代码，把所有的实现都放到一个函数里面，都时候需要改动的话，非常麻烦。后来把他们都分离了一下，抽象出来，变成几个函数。需要改动的时候，只需要改动具体的实现部分，逻辑没变。<br><br>这应该也是一种基于接口而非实现编程的案例","like_count":0},{"had_liked":false,"id":194363,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1585054667,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585054667","product_id":100039001,"comment_content":"可以使用代理模式，写一个代理类。就算后面要修改也是修改代理类而已，不会对上一层调用产生修改。","like_count":0},{"had_liked":false,"id":191563,"user_name":"秋风画扇","can_delete":false,"product_type":"c1","uid":1132356,"ip_address":"","ucode":"5BCBC1422C51EC","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/44/964aa665.jpg","comment_is_top":false,"comment_ctime":1584781572,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584781572","product_id":100039001,"comment_content":"接口只需要定义在有变化的地方既可以。图片处理的方式有很多，可以上传、删除、编辑，而上传又可以分很多存储介质。我们这里可以采用策略模式，process()方法只需要调用接口方法ImageStore#upload()就可以了，ImageStore作为ImageProcessingJob的成员变量，我们可以通过注入不同个实现类来调用不同处理逻辑，这里用到了“多态”","like_count":0},{"had_liked":false,"id":191559,"user_name":"秋风画扇","can_delete":false,"product_type":"c1","uid":1132356,"ip_address":"","ucode":"5BCBC1422C51EC","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/44/964aa665.jpg","comment_is_top":false,"comment_ctime":1584781287,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584781287","product_id":100039001,"comment_content":"联系题是抽象程度的问题，处理ImageProcessingJob的作用是处理图片，处理的方式有很多：上传、删除、编辑……每种处理方式又有不同的实现，上传可以传到私有云、阿里云……，我们在上面地方定义抽象取决变化在上面地方。如果仅仅是处理方式仅仅是上传，而上传可能到多个媒介，这时候我们就可以再上传这地方做文章。    process()方法里只需要调用存储的接口既可，具体实现也可以灵活替换","like_count":0},{"had_liked":false,"id":189453,"user_name":"治慧","can_delete":false,"product_type":"c1","uid":1245904,"ip_address":"","ucode":"47C331EF63EDC6","user_header":"https://static001.geekbang.org/account/avatar/00/13/02/d0/8abab63f.jpg","comment_is_top":false,"comment_ctime":1584517975,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584517975","product_id":100039001,"comment_content":"工厂模式去实话对象或者通过策略模式提供统一的Context如果通过定义枚举的方式获取对应的实现类bean名称在从依赖注入的map中取出实例对象来执行方法这样无论添加阿里云 百度云 还是华为云只需要写对应的实现类和在枚举中增加对应的bean名称即可","like_count":0},{"had_liked":false,"id":189132,"user_name":"jaryoung","can_delete":false,"product_type":"c1","uid":1077406,"ip_address":"","ucode":"6E72D107DB7E51","user_header":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","comment_is_top":false,"comment_ctime":1584458194,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584458194","product_id":100039001,"comment_content":"课后习题：配置文件配置的方式，能很好解决这个问题。","like_count":0},{"had_liked":false,"id":186567,"user_name":"ladidili","can_delete":false,"product_type":"c1","uid":1217498,"ip_address":"","ucode":"38886C1908DE6B","user_header":"https://static001.geekbang.org/account/avatar/00/12/93/da/0e47c76e.jpg","comment_is_top":false,"comment_ctime":1583885548,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1583885548","product_id":100039001,"comment_content":"接口是对相同功能的抽象，是协议，是对功能的描述，约定","like_count":0},{"had_liked":false,"id":186500,"user_name":"ladidili","can_delete":false,"product_type":"c1","uid":1217498,"ip_address":"","ucode":"38886C1908DE6B","user_header":"https://static001.geekbang.org/account/avatar/00/12/93/da/0e47c76e.jpg","comment_is_top":false,"comment_ctime":1583853500,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1583853500","product_id":100039001,"comment_content":"设计模式是思想上的东西，是前人总结出来的经验。没有什么具体的语法实现。<br>类，接口，继承是实在的语法。<br><br>基于接口而非实现编程就是基于抽象而非实现。关键点就是抽象。<br><br>一个新功能，可以思考这个功能点可能会有哪些变种。通过抽象出多个变种里共有的逻辑，抽象出来。其他的具体实现都基于这个抽象去实现。具体也就是抽象出一个个接口，面向这些接口实现。<br><br>","like_count":0},{"had_liked":false,"id":185837,"user_name":"大王叫我来巡山","can_delete":false,"product_type":"c1","uid":1099513,"ip_address":"","ucode":"1B8D0C701BC95E","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/f9/caf27bd3.jpg","comment_is_top":false,"comment_ctime":1583708921,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583708921","product_id":100039001,"comment_content":"面向配置文件编程","like_count":0},{"had_liked":false,"id":181623,"user_name":"悠游","can_delete":false,"product_type":"c1","uid":1222834,"ip_address":"","ucode":"4FDDDDF29AE3F0","user_header":"https://static001.geekbang.org/account/avatar/00/12/a8/b2/998448ca.jpg","comment_is_top":false,"comment_ctime":1582598935,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582598935","product_id":100039001,"comment_content":"可以基于策略模式，由用户传入的参数指定需要选用哪种图片存储方式，由此来创建响应的具体的类对象。","like_count":0},{"had_liked":false,"id":180701,"user_name":"未来小娃","can_delete":false,"product_type":"c1","uid":1047329,"ip_address":"","ucode":"477D166EBB6B70","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/21/d017438c.jpg","comment_is_top":false,"comment_ctime":1582367614,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1582367614","product_id":100039001,"comment_content":"编程依赖抽象而不是实现得前提条件是行为的变化，比如将毫秒时间戳换算为年月日就不存在行为的变化，那么直接用一个“实现类”，或者说普通类就可以了，反之如果文中提到的上传图片和下载图片的行为未来就是有可能变化的，比如图片存储从阿里云换成私有云就是变化，这就要求编程设计的时候多思考变化点，具备抽象思维。前面也提到接口是行为的抽象，是一组协议或者说契约，那么就决定了接口的行为必然是比较稳定的，比如就不能在图片存储的接口上加上获取日期这样的行为因为这是不相关的，也不能加上获取图片链接的行为，因为有些图片存储可能压根就没有获取图片链接的功能，因为这是关联性没那么大的行为。关于思考题我想的是实现上可以通过一个map初始化不同实现的图片存储，key是类型，value是具体的实现，需要哪个就从map的type拿就好了，本质上这就是Spring控制反转的原理，这也是各种@Autowired直接用起来贼爽的原因","like_count":0},{"had_liked":false,"id":180656,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1582359716,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582359716","product_id":100039001,"comment_content":"面向类、面向切面、面向抽象、面向接口、面向模式、面向对象、面向结构；面向正确的方向<br>最后是不是应该用建造模式中的一种，如工厂模式啊什么的","like_count":0},{"had_liked":false,"id":179836,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1582107595,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582107595","product_id":100039001,"comment_content":"Spring框架提供了很好的依赖注入特性,可以让实际的实现类并不在编写的时候和调用方挂钩,而是由容器来决定注入, 于是我给出的解决方案是,利用工厂类和依赖注入来进行解决,在一个工厂类中保证生产出的实现类是具有单例式的,然后调用者注入这个工厂类获取到生产出的实现类,在需要修改的时候,只需要修改这个工厂类产生的实现类就可以了,调用者不需要任何改变,即可获取到工厂类生产出的新实现类","like_count":0},{"had_liked":false,"id":177925,"user_name":"Rona","can_delete":false,"product_type":"c1","uid":1102822,"ip_address":"","ucode":"A301E295D45EC4","user_header":"https://static001.geekbang.org/account/avatar/00/10/d3/e6/6b43e010.jpg","comment_is_top":false,"comment_ctime":1581538427,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581538427","product_id":100039001,"comment_content":"思考题可以将ImageStore作为process方法的形参，使用ImageStore的子类作为实参传入","like_count":0},{"had_liked":false,"id":177580,"user_name":"月马穿关","can_delete":false,"product_type":"c1","uid":1338088,"ip_address":"","ucode":"2CE20CA1EB827D","user_header":"https://static001.geekbang.org/account/avatar/00/14/6a/e8/4bb87c34.jpg","comment_is_top":false,"comment_ctime":1581428149,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581428149","product_id":100039001,"comment_content":"思考题懵逼中 我知道我平日里直接使用Ioc直接注入进来接口","like_count":0},{"had_liked":false,"id":175949,"user_name":"Pluto","can_delete":false,"product_type":"c1","uid":1038251,"ip_address":"","ucode":"E292AFAD428135","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d7/ab/15c9b94e.jpg","comment_is_top":false,"comment_ctime":1580890371,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1580890371","product_id":100039001,"comment_content":"看了很多答案，很多都是换汤不换药。如果第八行的代码大量存在，用配置一类的方式应该可以解决，做到最小修改；如果第八行的代码少量存在，直接修改第八行代码就是了。既然需求已经变了，那么修改代码是必然的事情，修改代码在可以承受范围之内就没有必要过度设计。","like_count":0},{"had_liked":false,"id":175395,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1371891,"ip_address":"","ucode":"8BEFC518F06AC7","user_header":"https://static001.geekbang.org/account/avatar/00/14/ee/f3/a94cee23.jpg","comment_is_top":false,"comment_ctime":1580705198,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580705198","product_id":100039001,"comment_content":"课后思考题<br>因为存在多种实现的方案，具体哪一种，可以根据标识来选择，对应的设计想到的是策略设计模式。","like_count":0},{"had_liked":false,"id":175297,"user_name":"刘明丰","can_delete":false,"product_type":"c1","uid":1591790,"ip_address":"","ucode":"64C1D6CC769F75","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eocPWoTKicQG9ic42hLQBOqEziaNYxBekyGXljWrYfhk8gjLGZWfUX0JlObCvOIUSA8tRXicfxeSDJMMw/132","comment_is_top":false,"comment_ctime":1580647402,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580647402","product_id":100039001,"comment_content":"控制反转，依赖注入 是优雅的实现方案。","like_count":0},{"had_liked":false,"id":174657,"user_name":"不记年","can_delete":false,"product_type":"c1","uid":1045945,"ip_address":"","ucode":"287E40C68356DC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/b9/888fe350.jpg","comment_is_top":false,"comment_ctime":1580310890,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580310890","product_id":100039001,"comment_content":"1. 依赖注入 + 配置文件 ， 也就是spring<br>2. 工厂方法","like_count":0},{"had_liked":false,"id":174408,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1580195910,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580195910","product_id":100039001,"comment_content":"脑海里第一个想法就是：工厂模式；","like_count":0},{"had_liked":false,"id":174235,"user_name":"李轩","can_delete":false,"product_type":"c1","uid":1633845,"ip_address":"","ucode":"991FFF291B7E29","user_header":"https://static001.geekbang.org/account/avatar/00/18/ee/35/45a91ad0.jpg","comment_is_top":false,"comment_ctime":1580102762,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580102762","product_id":100039001,"comment_content":"设策略模式比较适合。","like_count":0},{"had_liked":false,"id":173546,"user_name":"帝都牛人","can_delete":false,"product_type":"c1","uid":1027982,"ip_address":"","ucode":"53EC02284680C7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/af/8e/6f0f4a56.jpg","comment_is_top":false,"comment_ctime":1579592794,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579592794","product_id":100039001,"comment_content":"我觉得用策略","like_count":0},{"had_liked":false,"id":172975,"user_name":"LF","can_delete":false,"product_type":"c1","uid":1434867,"ip_address":"","ucode":"ECED172D2273D3","user_header":"https://static001.geekbang.org/account/avatar/00/15/e4/f3/60a7b345.jpg","comment_is_top":false,"comment_ctime":1579400955,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579400955","product_id":100039001,"comment_content":"配置文件加工厂模式 和 反射的方式实现，学到了","like_count":0},{"had_liked":false,"id":171666,"user_name":"lecy_L","can_delete":false,"product_type":"c1","uid":1127659,"ip_address":"","ucode":"7C96DDBB3D1F7E","user_header":"https://static001.geekbang.org/account/avatar/00/11/34/eb/d00aedb0.jpg","comment_is_top":false,"comment_ctime":1578988191,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578988191","product_id":100039001,"comment_content":"课后问题解决方案：加一个接口实现类，ImageStoreServiceImpl 实现接口，在接口实现类ImageStoreServiceImpl里面不做具体上传的实现，只调用具体的实现类；具体的实现类也不用实现接口了。老师你觉得这样可以吗","like_count":0},{"had_liked":false,"id":171525,"user_name":"古之岳","can_delete":false,"product_type":"c1","uid":1256216,"ip_address":"","ucode":"355F8CE7FCF695","user_header":"https://static001.geekbang.org/account/avatar/00/13/2b/18/cee3b5b4.jpg","comment_is_top":false,"comment_ctime":1578961417,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578961417","product_id":100039001,"comment_content":"关于思考题，使用工厂模式。明白需求来源，为什么在使用了阿里云后还要使用私有云，肯定是阿里云不再满足新的业务要求，比如公司要求私密文件存储于私有云，公用图片存储于阿里云。所以可以将这个不同的使用策略抽象出来，业务层只需要将使用策略传入即可，工厂类根据传入的策略值创建具体的图片存储类。","like_count":0},{"had_liked":false,"id":169359,"user_name":"eason2017","can_delete":false,"product_type":"c1","uid":1009422,"ip_address":"","ucode":"E070BA624FA490","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/0e/c77ad9b1.jpg","comment_is_top":false,"comment_ctime":1578322157,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578322157","product_id":100039001,"comment_content":"可以通过SPI的方式来实现动态加载对应的实现类","like_count":0},{"had_liked":false,"id":169042,"user_name":"varotene","can_delete":false,"product_type":"c1","uid":1004441,"ip_address":"","ucode":"B37E9B6D35090C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/53/99/56f148bc.jpg","comment_is_top":false,"comment_ctime":1578263616,"is_pvip":false,"replies":[{"id":"65752","content":"理解的没问题~ 基于接口而非实现是一种抽象的思维","user_name":"作者回复","comment_id":169042,"uid":"1190123","ip_address":"","utype":1,"ctime":1578380894,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"1578263616","product_id":100039001,"comment_content":"Programming against interface 是不是也是抽象(abstraction)的一种手段？把原来具体的问题或者实现（aliyun或者私有云）抽象成任意的云，然后通过interface来予以描述。<br>至于什么时候用interface，什么时候不用，感觉也跟什么时候用抽象什么时候不用抽象是一个道理？因为进行抽象是需要成本的， 但不需要的时候，我们就可以略过，节省工程成本（YAGNI原则）。这么理解对吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480412,"discussion_content":"理解的没问题~ 基于接口而非实现是一种抽象的思维","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578380894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167714,"user_name":"我叫郭小黑","can_delete":false,"product_type":"c1","uid":1463441,"ip_address":"","ucode":"C238592EB5EDBC","user_header":"https://static001.geekbang.org/account/avatar/00/16/54/91/0d4647d9.jpg","comment_is_top":false,"comment_ctime":1577921638,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577921638","product_id":100039001,"comment_content":"基于配置文件的简单工厂模式，或者基于配置文件的反射，类似于jdbc切换数据库方言一样，更换驱动类就可以实现对具体实现的转换","like_count":0},{"had_liked":false,"id":167459,"user_name":"乾坤瞬间","can_delete":false,"product_type":"c1","uid":1683130,"ip_address":"","ucode":"15BDCF29CBF8EB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","comment_is_top":false,"comment_ctime":1577808260,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577808260","product_id":100039001,"comment_content":"最近在看Livy源码，其实在课后思考题的过程中，有一种方法可以更加优雅，其中可以使用当前线程的动态类加载机制，根据具体的类的权限定名进行实例的加载。在。Livy中，在启动后端RSCbootstrap类中，加载的类RSCClient有多种方式，其中ReplClient继承了RSCClient.返回的都是。RSCClient对象，不过RSCClient并不是接口","like_count":0},{"had_liked":false,"id":166778,"user_name":"fly","can_delete":false,"product_type":"c1","uid":1025992,"ip_address":"","ucode":"D1F6938C9CE15D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a7/c8/5608cbdb.jpg","comment_is_top":false,"comment_ctime":1577593169,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577593169","product_id":100039001,"comment_content":"接口：理解为“协议”或者“约定”，能帮助跳出具体语言的条条框框。<br>基于接口而非实现的编程：主要降低代码间耦合度，屏蔽实现的细节。我们在做设计时，加强接口意识、封装意识、抽象意识，脱离具体的实现，可以做的通用性更好。<br>过度使用：接口是一个常被用到，也容易被过度使用。是否每个类都需要接口，根据实现后是否比较稳定，一旦完成后，几乎不改动来考虑。","like_count":0},{"had_liked":false,"id":166593,"user_name":"zmysang","can_delete":false,"product_type":"c1","uid":1642663,"ip_address":"","ucode":"8A98057E7819DD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/tjhOILHBAmlx6YiaTZJzqzxn1uyB6XpdvGDIZhBn127TYEcoLLzxRiaKvtVd3HllQqPx7cqf2YmibyBUgGGGJPDkw/132","comment_is_top":false,"comment_ctime":1577512484,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577512484","product_id":100039001,"comment_content":"没有学过设计模式，目前的想法是可以使用配置文件的方式来选择使用的存储后端类……","like_count":0},{"had_liked":false,"id":166564,"user_name":"Geek_e70156","can_delete":false,"product_type":"c1","uid":1633140,"ip_address":"","ucode":"82883975A7CA83","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIwbHuA4O3men6SpIUUqjicvbIQ5jTNFtDCtBxJjJylr1AaDd7o2T7O5xOrVsW6sMmjfmKbK0gSiatQ/132","comment_is_top":false,"comment_ctime":1577502960,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577502960","product_id":100039001,"comment_content":"思考题：<br>“这就会产生一个问题，那就是，如果我们要替换图片存储方式，还是需要修改很多类似第 8 行那样的代码。”<br>我的思路是设计一个ImageService来管理这些Image对象的创建细节，调用方只需要调用ImageService.upload就可以了，具体的创建细节不要暴露给调用方。","like_count":0},{"had_liked":false,"id":166483,"user_name":"Yangjing","can_delete":false,"product_type":"c1","uid":1018061,"ip_address":"","ucode":"D88DFD4958D07C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/88/cd/2c3808ce.jpg","comment_is_top":false,"comment_ctime":1577457316,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1577457316","product_id":100039001,"comment_content":"通过配置+抽象工厂模式。不同的配置对应不同的 Storage.","like_count":0},{"had_liked":false,"id":166145,"user_name":"喵喵喵","can_delete":false,"product_type":"c1","uid":1211713,"ip_address":"","ucode":"E3AD8BF42E19DF","user_header":"https://static001.geekbang.org/account/avatar/00/12/7d/41/3c5b770b.jpg","comment_is_top":false,"comment_ctime":1577409029,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577409029","product_id":100039001,"comment_content":"打卡～","like_count":0},{"had_liked":false,"id":165457,"user_name":"古德","can_delete":false,"product_type":"c1","uid":1037755,"ip_address":"","ucode":"E3F646BB73F60E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d5/bb/98b93862.jpg","comment_is_top":false,"comment_ctime":1577240006,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577240006","product_id":100039001,"comment_content":"第8行的问题，可以用几种方式解决<br>1.如果使用的是SpringBoot这种框架，可以通过配置文件参数，控制bean注入进行切换。<br>2.通过SPI的方式指定。<br>3.把获取实现类的方式收拢到一个方法中，通过动态参数控制。","like_count":0},{"had_liked":false,"id":165442,"user_name":"wai","can_delete":false,"product_type":"c1","uid":1439529,"ip_address":"","ucode":"29CE3BE148FB79","user_header":"https://static001.geekbang.org/account/avatar/00/15/f7/29/60e01017.jpg","comment_is_top":false,"comment_ctime":1577238674,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577238674","product_id":100039001,"comment_content":"依赖注入","like_count":0},{"had_liked":false,"id":165248,"user_name":"Richie","can_delete":false,"product_type":"c1","uid":1019588,"ip_address":"","ucode":"12314EF0347693","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/c4/8d1150f3.jpg","comment_is_top":false,"comment_ctime":1577187938,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577187938","product_id":100039001,"comment_content":"课堂讨论题的思路：<br>将 ImageStore 设计成一个接口，修改 ImageProcessingJob 类，使其接收一个 ImageStore 类型的对象，内部基于接口去调用对应的 upload、download 等方法。至于 ImageStore 类型对象的初始化，则通过依赖注入的方式去实现，最终初始化为哪个具体类的对象，是在运行时决定的。","like_count":0},{"had_liked":false,"id":162570,"user_name":"海罗沃德","can_delete":false,"product_type":"c1","uid":1165364,"ip_address":"","ucode":"8704F1D6980FA0","user_header":"https://static001.geekbang.org/account/avatar/00/11/c8/34/fb871b2c.jpg","comment_is_top":false,"comment_ctime":1576557623,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576557623","product_id":100039001,"comment_content":"檢討了一下，公司的代碼裡被新來的Jr developer寫了無數的接口，每個接口只有一個實現類，實現類也不會更換實現方式","like_count":0},{"had_liked":false,"id":162238,"user_name":"刘铁俊","can_delete":false,"product_type":"c1","uid":1066959,"ip_address":"","ucode":"779591AB5E61FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/cf/d7613e91.jpg","comment_is_top":false,"comment_ctime":1576484525,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576484525","product_id":100039001,"comment_content":"思考题我觉得比较优雅的实现可以用SPI，真正做大对新增开放，对修改关闭。或者依赖注入。","like_count":0},{"had_liked":false,"id":162044,"user_name":"张蒙","can_delete":false,"product_type":"c1","uid":1035858,"ip_address":"","ucode":"CF8727F5DCFD55","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ce/52/4f1911b5.jpg","comment_is_top":false,"comment_ctime":1576455632,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576455632","product_id":100039001,"comment_content":"课后作业:使用适配器模式。使用图片的类不依赖于具体实现类。而是使用ImagdStorage做一层包装。这样就可以使得不用改动业务实现代码。","like_count":0},{"had_liked":false,"id":161705,"user_name":"黄马","can_delete":false,"product_type":"c1","uid":1019506,"ip_address":"","ucode":"93E391B4678EC2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/72/63c94eee.jpg","comment_is_top":false,"comment_ctime":1576303131,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1576303131","product_id":100039001,"comment_content":"前面我们也提到，这条原则的设计初衷是，将接口和实现相分离，封装不稳定的实现，暴露稳定的接口；","like_count":0},{"had_liked":false,"id":161620,"user_name":"|･ω･｀)","can_delete":false,"product_type":"c1","uid":1636123,"ip_address":"","ucode":"34E1DF62058D80","user_header":"https://static001.geekbang.org/account/avatar/00/18/f7/1b/8036958c.jpg","comment_is_top":false,"comment_ctime":1576250670,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576250670","product_id":100039001,"comment_content":"思考题回答：目前能想到的方法是，使用工厂模式<br>在真正使用实例类前，根据定好的参数获得对应的实例类，然后再直接调用实例类的方法<br>如果新增ImageStore类，则调用的地方只需要更改传入的参数即可","like_count":0},{"had_liked":false,"id":161197,"user_name":"冬渐暖","can_delete":false,"product_type":"c1","uid":1586800,"ip_address":"","ucode":"907E41AAE9A36C","user_header":"https://static001.geekbang.org/account/avatar/00/18/36/70/00122b24.jpg","comment_is_top":false,"comment_ctime":1576142603,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576142603","product_id":100039001,"comment_content":"接口的一些规范<br>1.命名规范，不能吧实现的细节放到命名里面去。比如不要写getOrdersRefundFromWriter(）--》从写库读<br>2.封闭实现流程：只要让别人该传什么，能得到什么。比如别人调你的退款接口，不要跟他说你会改什么表的数据，怎么改。<br>3.为一群人去定义接口，而不是一个人。 他们用的是你的接口，而不是你的实现类<br>设计接口的时候，我们要多思考一下，这样的接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候，不需要任何接口定义的改动。<br><br>什么时候用：<br>容易变的地方。接口是稳定的，实现是容易变的。如果只有一种固定的实现就没必要去浪费时间搞了<br>","like_count":0},{"had_liked":false,"id":160753,"user_name":"乾坤瞬间","can_delete":false,"product_type":"c1","uid":1683130,"ip_address":"","ucode":"15BDCF29CBF8EB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","comment_is_top":false,"comment_ctime":1576029374,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576029374","product_id":100039001,"comment_content":"我觉得用反射技巧谈编程的都是耍流氓$因为反射好像只能在java中有$而且反射的本质对思考题没有有影响。我觉得使用 字符串作为入参+ 静态类封装一个以这个字符串为方法的生成不同类型的对象方法就行$很简单的不用搞那么复杂吧","like_count":0},{"had_liked":false,"id":160611,"user_name":"alls well","can_delete":false,"product_type":"c1","uid":1072439,"ip_address":"","ucode":"8E3EB5A3DF6E0D","user_header":"https://static001.geekbang.org/account/avatar/00/10/5d/37/8261fc68.jpg","comment_is_top":false,"comment_ctime":1575985899,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575985899","product_id":100039001,"comment_content":"基于接口而非实现编程，期待下一篇的课题引入","like_count":0},{"had_liked":false,"id":160510,"user_name":"蜗牛","can_delete":false,"product_type":"c1","uid":1086220,"ip_address":"","ucode":"01CC18F12E556D","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/0c/0a6a0d5e.jpg","comment_is_top":false,"comment_ctime":1575967241,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575967241","product_id":100039001,"comment_content":"利用工厂模式~","like_count":0},{"had_liked":false,"id":160464,"user_name":"tuyu","can_delete":false,"product_type":"c1","uid":1448863,"ip_address":"","ucode":"B235325B541408","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/BIRpwViaN51yynIeFonD7QRlwDCVtKibrG956NTxzEqibOZZVjhMMgibOPmd3VicfYxpknZsic1oJq8KicZvXkmmiajuQg/132","comment_is_top":false,"comment_ctime":1575955265,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575955265","product_id":100039001,"comment_content":"python路过, 想了半天不知道怎么实现interface的功能","like_count":0},{"had_liked":false,"id":160253,"user_name":"小毅","can_delete":false,"product_type":"c1","uid":1016799,"ip_address":"","ucode":"5651C740D68038","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/hg9Tsg2iaBeG6Q5mxiczjw1ph0OvhKziblEIiaOxg4gwQ0Dgia7Fw7pDQ0mM8AL5SJAm2Yavk1RmBJrFd9jKPBQRkOw/132","comment_is_top":false,"comment_ctime":1575899361,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575899361","product_id":100039001,"comment_content":"思考题大家都说了很多设计模式，我觉得从工程上来说IoC足矣","like_count":0},{"had_liked":false,"id":160235,"user_name":"wyf2317","can_delete":false,"product_type":"c1","uid":1236837,"ip_address":"","ucode":"7F3E61A6188B39","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ub4icibeRLzff8Nf6ORsolib9KHtmeu3d4cCCAFd3Xgah3v78WfDYQB7WKq9iaIPXPwHBxw7mkBP9wYxDGMT9m1Rbw/132","comment_is_top":false,"comment_ctime":1575896879,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1575896879","product_id":100039001,"comment_content":"赶紧使用简单工厂会更合适一点","like_count":0},{"had_liked":false,"id":160094,"user_name":"Geek_ecf7bb","can_delete":false,"product_type":"c1","uid":1523207,"ip_address":"","ucode":"5BF4DD62425BE0","user_header":"https://static001.geekbang.org/account/avatar/00/17/3e/07/c27b53b8.jpg","comment_is_top":false,"comment_ctime":1575868771,"is_pvip":false,"replies":[{"id":"61122","content":"等我有空了，集中答疑一下。","user_name":"作者回复","comment_id":160094,"uid":"1190123","ip_address":"","utype":1,"ctime":1575895697,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"1575868771","product_id":100039001,"comment_content":"依赖注入可以。在注入配置初修改实现类，这样只需要修改一处就可以。<br>ps：不知道老师能不能在某个地方对课后习题进行一些讲解...","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477255,"discussion_content":"等我有空了，集中答疑一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575895697,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160049,"user_name":"cv0cv0","can_delete":false,"product_type":"c1","uid":1360093,"ip_address":"","ucode":"93FF9277F03FD0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLEIsgI4ub1VOKWtVOfouAzSqx8Yt8ibQEsAnwNJsJHmuJzzpQqG79HullvYwpic8hgiclgON2GwXSjw/132","comment_is_top":false,"comment_ctime":1575860624,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575860624","product_id":100039001,"comment_content":"写一个类，返回 ImageStore 就行了。","like_count":0},{"had_liked":false,"id":160032,"user_name":"爱水人家","can_delete":false,"product_type":"c1","uid":1730305,"ip_address":"","ucode":"0C94C6ACBC9CEB","user_header":"https://static001.geekbang.org/account/avatar/00/1a/67/01/44626cb9.jpg","comment_is_top":false,"comment_ctime":1575859299,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575859299","product_id":100039001,"comment_content":"停了这一章的讲课，外加看了留言，我彻底弄懂了抽象类和接口的使用情况了。抽象类是一种is-a关系，即“属于”关系。而接口是一组行为特性，一种“有xxxx的行为”。对于C++来说，本身没有定义接口，但是“接口”的设计感觉就是为了解决多继承的问题。比如留言榜第一条中的例子，吸血鬼分别继承自蝙蝠和人，那么它同时具有了蝙蝠和人的某些行为，这时就可以用接口。（道行不深，说错勿喷）","like_count":0},{"had_liked":false,"id":159172,"user_name":"lengrongfu","can_delete":false,"product_type":"c1","uid":1494681,"ip_address":"","ucode":"FD6F35CA561E0B","user_header":"https://static001.geekbang.org/account/avatar/00/16/ce/99/447c33d4.jpg","comment_is_top":false,"comment_ctime":1575552018,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575552018","product_id":100039001,"comment_content":"老师好，你定义接口中的方法如下<br>String upload(Image image, String bucketName)，这里面的buckeName是不是不应该作为upload的一个参数呢，这个参数感觉和具体实现有关系，比如私有存储可能没有bucket这个概念呢，这个参数应该最为aliyun的构造方法中的一个参数会更好一些吧。老师你觉得呢？","like_count":0},{"had_liked":false,"id":158929,"user_name":"progyoung","can_delete":false,"product_type":"c1","uid":1014692,"ip_address":"","ucode":"0B4898AE78F9F5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7b/a4/24955994.jpg","comment_is_top":false,"comment_ctime":1575503116,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575503116","product_id":100039001,"comment_content":"原则早就听过，但是结合具体的例子才真正理解了，这节课很有收获，谢谢老师。","like_count":0},{"had_liked":false,"id":157706,"user_name":"书中迷梦","can_delete":false,"product_type":"c1","uid":1103010,"ip_address":"","ucode":"1C6B697F41698F","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/a2/fa41c8a8.jpg","comment_is_top":false,"comment_ctime":1575249136,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575249136","product_id":100039001,"comment_content":"我觉得老师说的那个判断时候使用接口的标准，对于初学者或者项目经验欠缺的人来说有点困难，因为经验少没有办法判断出该实现以后时候经常变化！我觉得这些东西都是经过多次代码重构才能达到一个好的效果","like_count":0},{"had_liked":false,"id":157579,"user_name":"Joker","can_delete":false,"product_type":"c1","uid":1241567,"ip_address":"","ucode":"C42E11098E1B38","user_header":"https://static001.geekbang.org/account/avatar/00/12/f1/df/8ba04bec.jpg","comment_is_top":false,"comment_ctime":1575201655,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575201655","product_id":100039001,"comment_content":"课堂讨论：通过泛型来解决？","like_count":0},{"had_liked":false,"id":157052,"user_name":"CHS","can_delete":false,"product_type":"c1","uid":1240227,"ip_address":"","ucode":"3D8B2DABC0A1D6","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/a3/28763399.jpg","comment_is_top":false,"comment_ctime":1575019289,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575019289","product_id":100039001,"comment_content":"注解加反射，工厂模式","like_count":0},{"had_liked":false,"id":156671,"user_name":"Eric","can_delete":false,"product_type":"c1","uid":1575571,"ip_address":"","ucode":"7EB511C384BD7B","user_header":"https://static001.geekbang.org/account/avatar/00/18/0a/93/a189ec16.jpg","comment_is_top":false,"comment_ctime":1574933861,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574933861","product_id":100039001,"comment_content":"针对于文中的示例，其实不需要接口，只要把uploadToAliyun这类方法名取的抽象一点就可以实现了啊，所以接口存在的意义是更加优雅吗？强制新类实现同样的方法，并且不会取错方法名？望老师解答。","like_count":0},{"had_liked":false,"id":156538,"user_name":"我能走多远","can_delete":false,"product_type":"c1","uid":1240465,"ip_address":"","ucode":"07DF5D5DADFA3C","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/91/1d332031.jpg","comment_is_top":false,"comment_ctime":1574907197,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574907197","product_id":100039001,"comment_content":"作业，我是C语言开发。以我的理解来说吧。我们应该在process提供一个mode参数。供调用者选择使用共有云还是私有云。mode可以扩展很多。比如存储到硬盘或者redis服务器等等。<br>","like_count":0},{"had_liked":false,"id":156422,"user_name":"和你一起搬砖的胡大爷","can_delete":false,"product_type":"c1","uid":1008587,"ip_address":"","ucode":"54607F4E17917A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/cb/7c004188.jpg","comment_is_top":false,"comment_ctime":1574869464,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574869464","product_id":100039001,"comment_content":"老程序员在Spring的service层喜欢定义一个接口，再写实现，如果按业务需求理解，这个服务绝无可能会有第二种实现。请问这样做的意义是什么？","like_count":0},{"had_liked":false,"id":156347,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1574859711,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574859711","product_id":100039001,"comment_content":"思考题，依赖注入，变成入参，更上层的代码去控制","like_count":0},{"had_liked":false,"id":156323,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1574856474,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574856474","product_id":100039001,"comment_content":"课堂讨论：其实这个就需要使用到了设计模式的具体模式，创建型模式中的工厂模式。来进行替换","like_count":0},{"had_liked":false,"id":156206,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1574836351,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574836351","product_id":100039001,"comment_content":"诚如评论中所言，下一步怕是要引出来设计模式了。因为这里的问题就不单单是语言可以解决的了，语言只能提供基础的工具，如何组合和设计就是设计模式的内容了。<br>ps：这门课难度真不小，不过喜欢这种各抒己见的学习方式，既然老师安排了这么多课程，那就跟着学习下去吧","like_count":0},{"had_liked":false,"id":156077,"user_name":"星空123","can_delete":false,"product_type":"c1","uid":1596920,"ip_address":"","ucode":"E998A7C585671B","user_header":"https://static001.geekbang.org/account/avatar/00/18/5d/f8/7de2c1cc.jpg","comment_is_top":false,"comment_ctime":1574817404,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574817404","product_id":100039001,"comment_content":"利用接口来帮助代码解耦的重要性","like_count":0},{"had_liked":false,"id":155859,"user_name":"拒绝","can_delete":false,"product_type":"c1","uid":1335155,"ip_address":"","ucode":"CB0264C4D3FE17","user_header":"https://static001.geekbang.org/account/avatar/00/14/5f/73/bb3dc468.jpg","comment_is_top":false,"comment_ctime":1574769204,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574769204","product_id":100039001,"comment_content":"JAVA或DUBBO的SPI","like_count":0},{"had_liked":false,"id":155789,"user_name":"老杨同志","can_delete":false,"product_type":"c1","uid":1246199,"ip_address":"","ucode":"3F334F0CFD3DE6","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/f7/3a493bec.jpg","comment_is_top":false,"comment_ctime":1574757080,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574757080","product_id":100039001,"comment_content":"思考题的两种方式：1）使用工厂模式  2)java的SPI机制","like_count":0},{"had_liked":false,"id":155782,"user_name":"坎迪汪","can_delete":false,"product_type":"c1","uid":1017033,"ip_address":"","ucode":"5B1ADFA2AF2934","user_header":"https://static001.geekbang.org/account/avatar/00/0f/84/c9/cfed3a2f.jpg","comment_is_top":false,"comment_ctime":1574756193,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574756193","product_id":100039001,"comment_content":"接口设计不好也是白搭，重构特别重要，尽量快速重构。","like_count":0},{"had_liked":false,"id":155642,"user_name":"黄振宇","can_delete":false,"product_type":"c1","uid":1686397,"ip_address":"","ucode":"976BC7B46DA419","user_header":"https://static001.geekbang.org/account/avatar/00/19/bb/7d/26340713.jpg","comment_is_top":false,"comment_ctime":1574731883,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574731883","product_id":100039001,"comment_content":"我写的类就是基于实现而非接口的。。最近疯狂修改自己之前的代码","like_count":0},{"had_liked":false,"id":155631,"user_name":"小乙哥","can_delete":false,"product_type":"c1","uid":1063308,"ip_address":"","ucode":"C77E79BEA0C325","user_header":"https://static001.geekbang.org/account/avatar/00/10/39/8c/089525aa.jpg","comment_is_top":false,"comment_ctime":1574730669,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574730669","product_id":100039001,"comment_content":"基于抽象编程，分离变化的实现。和架构原则中的“分离变化点和稳定点”契合","like_count":0},{"had_liked":false,"id":155346,"user_name":"子夜2104","can_delete":false,"product_type":"c1","uid":1070286,"ip_address":"","ucode":"C4FF54AEA6002F","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/ce/92029d2f.jpg","comment_is_top":false,"comment_ctime":1574680525,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574680525","product_id":100039001,"comment_content":"基于接口而非实现编程。我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性、扩展性、可维护性。<br><br>接口就是提供了一个“功能列表”。我们在做一件事情时，都需要先有个整体的概念，然后再具体。那么接口就是我们在软件工程设计时的抽象概念，用于把握整体。<br><br>我们在定义接口的时候，一方面，命名要足够通用，不能包含跟具体实现相关的字眼；另一方面，与特定实现有关的方法不要定义在接口中。","like_count":0},{"had_liked":false,"id":155311,"user_name":"liliumss","can_delete":false,"product_type":"c1","uid":1333094,"ip_address":"","ucode":"A52AC5042F3115","user_header":"https://static001.geekbang.org/account/avatar/00/14/57/66/e57bdb18.jpg","comment_is_top":false,"comment_ctime":1574677199,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574677199","product_id":100039001,"comment_content":"目前spring框架是javaEE的事实标准，和非ioc环境下的demo比起来实现一些设计模式有不同之处","like_count":0},{"had_liked":false,"id":155281,"user_name":"Kevin","can_delete":false,"product_type":"c1","uid":1429627,"ip_address":"","ucode":"9DFFD6E3960CF7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJN64OCUT0Jp0h2Wiau9Os0o1WbwUeoq2QL0U2vZpib8ozPxo0XDiaPM9xcKfbkoBL24ztEHelxPIMVg/132","comment_is_top":false,"comment_ctime":1574673865,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574673865","product_id":100039001,"comment_content":"课堂讨论题<br>那行代码其实就是创建了一个对象，<br>那创建对象能不能面向接口，而不是实现呢？ <br>能。<br>欢迎收听下节，简单工厂与抽象工厂设计模式。<br>","like_count":0},{"had_liked":false,"id":155185,"user_name":"小乙哥","can_delete":false,"product_type":"c1","uid":1063308,"ip_address":"","ucode":"C77E79BEA0C325","user_header":"https://static001.geekbang.org/account/avatar/00/10/39/8c/089525aa.jpg","comment_is_top":false,"comment_ctime":1574657977,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574657977","product_id":100039001,"comment_content":"其实，spring就是为了解决这种依赖控制反转而生的，由spirng容器负责管理具体的装配细节","like_count":0},{"had_liked":false,"id":155165,"user_name":"辉仔lovers","can_delete":false,"product_type":"c1","uid":1210219,"ip_address":"","ucode":"3DC5B0CD0B8E71","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLVhJRVwJ0eVlC7zjNfWP6PP7VmUkF1X2m6qfh7Wic3NhAOz2fSGibF6LXLcJ59zOz7nBpCcByvtFjw/132","comment_is_top":false,"comment_ctime":1574654515,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574654515","product_id":100039001,"comment_content":"通过反射+配置文件的方式。将实现类的全限定名配置到配置文件中。加载配置文件，Class.forName()加载实现类。newInstance() 创建对象。简单点的方式是通过jdk spi 扩展机制。","like_count":0},{"had_liked":false,"id":155152,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1574652478,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574652478","product_id":100039001,"comment_content":"基于接口而非实现编程<br>使用场景：实现方式可能存在多个。或者目前实现只有一个，将来极有可能变化；或者目前已经有很多不同的实现方式。<br>注意事项：接口方法要是通用方法，命名要够抽象，不能与某个实现相关。<br><br>课后习题：<br>工厂模式+枚举。<br><br><br><br><br>","like_count":0},{"had_liked":false,"id":155068,"user_name":"Sheamus","can_delete":false,"product_type":"c1","uid":1248510,"ip_address":"","ucode":"F6EBDFF3575ADA","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/fe/4a1f045e.jpg","comment_is_top":false,"comment_ctime":1574643055,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574643055","product_id":100039001,"comment_content":"课后思考题思路:1. 配置+反射+工厂 2. 策略+工厂 ……感觉策略和配置+反射是一样的😂","like_count":0},{"had_liked":false,"id":154983,"user_name":"DullBird","can_delete":false,"product_type":"c1","uid":1110494,"ip_address":"","ucode":"80E2FD5F9687CB","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/de/3ebcbb3f.jpg","comment_is_top":false,"comment_ctime":1574608890,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574608890","product_id":100039001,"comment_content":"打卡，课后作业的代码。可以把主动new的代码，替换为工厂模式(简单工厂), 或者工厂方法。","like_count":0},{"had_liked":false,"id":154941,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1018370,"ip_address":"","ucode":"7A488CC6FE15E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","comment_is_top":false,"comment_ctime":1574600984,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574600984","product_id":100039001,"comment_content":"现在能想到的有两种方式：<br>1. 通过配置的方式，值为实现类的全限定名，在运行时将第8行代码换成使用反射构造对象的方式；<br>2. 通过工厂方法来实现对象的生产。","like_count":0},{"had_liked":false,"id":154882,"user_name":"William Ning","can_delete":false,"product_type":"c1","uid":1592279,"ip_address":"","ucode":"4DB8D05E69E5F3","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","comment_is_top":false,"comment_ctime":1574587552,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574587552","product_id":100039001,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":154809,"user_name":"逍遥思","can_delete":false,"product_type":"c1","uid":1015512,"ip_address":"","ucode":"340F05C786730F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/d8/92a98fb6.jpg","comment_is_top":false,"comment_ctime":1574570565,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574570565","product_id":100039001,"comment_content":"的确是想不到，一看大家的答案，原来是要引出下一讲的内容，这种模式非常好，无比期待！","like_count":0},{"had_liked":false,"id":154789,"user_name":"Tom.G","can_delete":false,"product_type":"c1","uid":1206034,"ip_address":"","ucode":"7929B45C1A51F8","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/12/5c6eb568.jpg","comment_is_top":false,"comment_ctime":1574565512,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574565512","product_id":100039001,"comment_content":"1.简单工厂，优点简单，缺乏灵活性<br>2.抽象工厂，优点方便扩展，缺点复杂<br>3.依赖注入，优点方便扩展，缺点需引入IoC组件","like_count":0},{"had_liked":false,"id":154764,"user_name":"allean","can_delete":false,"product_type":"c1","uid":1051470,"ip_address":"","ucode":"A0D2DB4F219EAA","user_header":"https://static001.geekbang.org/account/avatar/00/10/0b/4e/fd946cb2.jpg","comment_is_top":false,"comment_ctime":1574557582,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574557582","product_id":100039001,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":154708,"user_name":"Geek_6bf244","can_delete":false,"product_type":"c1","uid":1685861,"ip_address":"","ucode":"65D467C9C3272F","user_header":"","comment_is_top":false,"comment_ctime":1574517597,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574517597","product_id":100039001,"comment_content":"反射","like_count":0},{"had_liked":false,"id":154706,"user_name":"飞飞","can_delete":false,"product_type":"c1","uid":1657762,"ip_address":"","ucode":"E9644EE0AA8350","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKSjC36vSdPia1g9FMib8F5nT9iaI00SXl0FVOVicYGOLrfIhFDnlszMGKsNOq0hZEDpI6fLYtV9sBb6w/132","comment_is_top":false,"comment_ctime":1574516833,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574516833","product_id":100039001,"comment_content":"期待下周一的工厂模式课程","like_count":0},{"had_liked":false,"id":154691,"user_name":"2018","can_delete":false,"product_type":"c1","uid":1107371,"ip_address":"","ucode":"4C2CD47AD70177","user_header":"https://static001.geekbang.org/account/avatar/00/10/e5/ab/6fab2492.jpg","comment_is_top":false,"comment_ctime":1574512506,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574512506","product_id":100039001,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":154689,"user_name":"沈康","can_delete":false,"product_type":"c1","uid":1611025,"ip_address":"","ucode":"02AFA50738AB8E","user_header":"https://static001.geekbang.org/account/avatar/00/18/95/11/eb431e52.jpg","comment_is_top":false,"comment_ctime":1574511447,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574511447","product_id":100039001,"comment_content":"可能就是常说的策略模式+工厂模式吧。<br><br>以spring为例的话，在容器初始化利用容器的生命周期方法时候把相应为一组的相同接口实现 Map&lt;实现类型枚举，具体实现]&gt;注入到spring容器，<br>在运行时，需要程序新增一个使用的类型枚举输入，由容器查找该枚举的具体实现并调用。<br><br>这个和JNDI的实现方式差不多。","like_count":0},{"had_liked":false,"id":154605,"user_name":"段启超","can_delete":false,"product_type":"c1","uid":1258209,"ip_address":"","ucode":"164CF3018071B2","user_header":"https://static001.geekbang.org/account/avatar/00/13/32/e1/c9aacb37.jpg","comment_is_top":false,"comment_ctime":1574491559,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574491559","product_id":100039001,"comment_content":"可以用工厂模式+配置文件的方式来改进。<br>用工厂模式来产生不同类型的图片库实例，用配置文件来配置获取哪一个实例。","like_count":0},{"had_liked":false,"id":154604,"user_name":"相逢是缘","can_delete":false,"product_type":"c1","uid":1060730,"ip_address":"","ucode":"CB299F53A95654","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg","comment_is_top":false,"comment_ctime":1574490511,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574490511","product_id":100039001,"comment_content":"打卡：<br>1、接口实际是抽象的产物，是一种规范和约束（是做什么，而不是怎么做），是功能提供者提供给使用者的一个功能列表。Android中的HAL层的功能和接口定义就是这种思想。能定义出好的接口前提是对需求和业务理解比较清楚，如：需要抽象一个播放器接口，你现在用到的功能可能是开始播放start、停止播放stop。但是从对播放器的接口抽象看，这个接口定义不是很好的，因为后续业务需求还有暂定pause和回复resume的操作。<br>2、在进行接口定义时，命名要足够通用，不能包含和具体实现相关的字眼，特定实现的功能不要定义在接口中。<br>3、不要过度使用这个原则，基于接口编程的初衷是不必关心内部的实现，不依赖于具体的实现细节，当实现发生变化时，业务代码不需要改动，依次来降低代码之间的耦合性，提高代码的扩展性。如果在业务场景中，某个功能实现之后未来不可能被更改，那就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以。","like_count":0},{"had_liked":false,"id":154599,"user_name":"慢慢懂","can_delete":false,"product_type":"c1","uid":1694112,"ip_address":"","ucode":"6296BBF970AF13","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/a0/184e7cf6.jpg","comment_is_top":false,"comment_ctime":1574489469,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574489469","product_id":100039001,"comment_content":"这个就是为什么lavaver框架里面为什么要用接口的做契约的意义","like_count":0},{"had_liked":false,"id":154592,"user_name":"工画师","can_delete":false,"product_type":"c1","uid":1025850,"ip_address":"","ucode":"FFABE897B2CF8E","user_header":"","comment_is_top":false,"comment_ctime":1574488000,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574488000","product_id":100039001,"comment_content":"public void process(ImageStore imageStore) {}","like_count":0},{"had_liked":false,"id":154570,"user_name":"shniu","can_delete":false,"product_type":"c1","uid":1019555,"ip_address":"","ucode":"E64CD8BED96D8D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/a3/d7e5fe8a.jpg","comment_is_top":false,"comment_ctime":1574481049,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574481049","product_id":100039001,"comment_content":"依赖注入应该是一种思路，由容器去管理实例，将需要的对象注入进来，底层还是依赖了反射或者配置文件或者配置类，将对象组装抽离出来，这是容易发生变化的地方；SPI 也是一种灵活的方式","like_count":0},{"had_liked":false,"id":154555,"user_name":"乘坐Tornado的线程魔法师","can_delete":false,"product_type":"c1","uid":1132661,"ip_address":"","ucode":"C4C9915866E769","user_header":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","comment_is_top":false,"comment_ctime":1574479618,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574479618","product_id":100039001,"comment_content":"针对思考题的情景，就算是用了简单工厂模式或是抽象工厂模式，如果要替换图片存储方式，在传递参数的时候仍然要把AliyunImageStore类型的参数修改为PrivateImageStore类型，所以使用工厂模式与文中提到的方案相比，根本的好处（优势）在哪里呢？","like_count":0},{"had_liked":false,"id":154532,"user_name":"Lifelong Learning","can_delete":false,"product_type":"c1","uid":1173517,"ip_address":"","ucode":"3E39BED3E13FB4","user_header":"https://static001.geekbang.org/account/avatar/00/11/e8/0d/fcd95db8.jpg","comment_is_top":false,"comment_ctime":1574475167,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574475167","product_id":100039001,"comment_content":"基于接口进行设计,主要是“做什么”,而非“怎样做”,过度使用接口,就会导致为了“接口”而“接口”,这样其实和之前讲的,用IDE将类中的成员变量进行set和get方法的定义,这样就会破坏掉“面向对象”编程的原则,而如果乱用接口,或者不管什么类,都有一个对应的接口的实现,那么就会导致接口满天飞反而不利于代码的维护,看起来好像扩展性很好,其实写了一堆根本以后用不到的接口,这样的接口没有存在的意义,反而是冗余的","like_count":0},{"had_liked":false,"id":154485,"user_name":"sulatwx","can_delete":false,"product_type":"c1","uid":1348141,"ip_address":"","ucode":"366237F13DE8A7","user_header":"","comment_is_top":false,"comment_ctime":1574443093,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574443093","product_id":100039001,"comment_content":"使用工厂方法，可以根据参数生成不同的实例，再定义返回默认实例的方法getDefaultImgStore，使用时，尽量使用返回默认实例的，这样只修改返回的默认实例的即可","like_count":0},{"had_liked":false,"id":154474,"user_name":"Fun","can_delete":false,"product_type":"c1","uid":1145502,"ip_address":"","ucode":"5D89BA4C678785","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJdUGdEj3R25CrYqibPibYibibRicqUfyL4aTTPbMagyywjKMhXGZE37RTe7lEdvC4DibvtYpzg8zXvt9HQ/132","comment_is_top":false,"comment_ctime":1574438471,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574438471","product_id":100039001,"comment_content":"# day 11<br>今天学习基于接口而非实现编程。其实这本身已经带了设计的理念在内了。接口是综合考虑后设计出来的，它是思考的产物，是程序员价值的体现。","like_count":0,"discussions":[{"author":{"id":1022349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/99/8d/4d5dbfc5.jpg","nickname":"王喜春","note":"","ucode":"436E91FDED1B30","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387480,"discussion_content":"需要磕磕碰碰地反复研磨才能吃透","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628211347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363254,"discussion_content":"似懂非懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617155420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154440,"user_name":"James","can_delete":false,"product_type":"c1","uid":1134861,"ip_address":"","ucode":"48B0F2A334D1C1","user_header":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","comment_is_top":false,"comment_ctime":1574431102,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574431102","product_id":100039001,"comment_content":"第八行的例子,确实很多时候都会因为修改不同方式而大量修改.暂时想不到具体方法.<br>评论人才辈出啊.学习他人做法.","like_count":0},{"had_liked":false,"id":154429,"user_name":"斐波那契","can_delete":false,"product_type":"c1","uid":1464006,"ip_address":"","ucode":"85E2EBC01392B1","user_header":"https://static001.geekbang.org/account/avatar/00/16/56/c6/0b449bc6.jpg","comment_is_top":false,"comment_ctime":1574428384,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574428384","product_id":100039001,"comment_content":"老师 我有个疑问 项目中原则上是少调用I&#47;O 但是总感觉不能每一个新功能就写一套sql 那这样sql也臃肿 可复用之前写的sql业务上要调用好几个组合起来才行 有没有好的方法能平衡这两个情况","like_count":0},{"had_liked":false,"id":154424,"user_name":"汤小高","can_delete":false,"product_type":"c1","uid":1555565,"ip_address":"","ucode":"D4AB7766273D52","user_header":"https://static001.geekbang.org/account/avatar/00/17/bc/6d/f6f0a442.jpg","comment_is_top":false,"comment_ctime":1574427287,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574427287","product_id":100039001,"comment_content":"为了应对需求的不断变化，我们设计代码的时候就应该要隔离变化，把不变的和变化的隔离开来。针对接口编程而非实现编程就是实现这种目标的手段之一，通过接口把统一的、稳定的功能列表对外暴露，通过实现类把不稳定，可能变化的的实现隐藏。<br>具有稳定的，不会变化的功能的类不需要使用接口<br>具有不稳定的，可能会变化的功能的类需要使用接口隔离变化","like_count":0},{"had_liked":false,"id":154413,"user_name":"Warn","can_delete":false,"product_type":"c1","uid":1465310,"ip_address":"","ucode":"F2F7FCDB0940D0","user_header":"https://static001.geekbang.org/account/avatar/00/16/5b/de/152f1c2c.jpg","comment_is_top":false,"comment_ctime":1574424642,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574424642","product_id":100039001,"comment_content":"基于接口而非基于实现编程，抽象的全局思维。<br>讨论区，又学习了一圈。","like_count":0},{"had_liked":false,"id":154405,"user_name":"Jimbol","can_delete":false,"product_type":"c1","uid":1178008,"ip_address":"","ucode":"8D9190B3B3E08B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f9/98/95b13446.jpg","comment_is_top":false,"comment_ctime":1574423700,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574423700","product_id":100039001,"comment_content":"1.spring 的@Qualifer 或@Resource<br>2.使用抽象工厂模式，把具体创建对象的过程封装起来，在工厂内部进行替换","like_count":0},{"had_liked":false,"id":154399,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1574422831,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1574422831","product_id":100039001,"comment_content":"简单来看，可以使用工厂方法来实现","like_count":0},{"had_liked":false,"id":154390,"user_name":"Geek_862694","can_delete":false,"product_type":"c1","uid":1366022,"ip_address":"","ucode":"977B4195C7CFB1","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/ajNVdqHZLLBP7piae8iaHU7w2a4TyLKPFI7xiaia3Hias2ibMPftnFEic0lqGU315U70peQs7X3Kyd3bDgJjF6nBQg7xA/132","comment_is_top":false,"comment_ctime":1574421340,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574421340","product_id":100039001,"comment_content":"依赖注入 完美解决问题","like_count":0},{"had_liked":false,"id":154354,"user_name":"Heiky","can_delete":false,"product_type":"c1","uid":1623626,"ip_address":"","ucode":"03AA79E1BC4AE4","user_header":"https://static001.geekbang.org/account/avatar/00/18/c6/4a/3bd896fc.jpg","comment_is_top":false,"comment_ctime":1574413598,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574413598","product_id":100039001,"comment_content":"小争哥，是想引出简单工厂模式了","like_count":0},{"had_liked":false,"id":154340,"user_name":"小小征","can_delete":false,"product_type":"c1","uid":1358930,"ip_address":"","ucode":"335380EFE0FC61","user_header":"https://static001.geekbang.org/account/avatar/00/14/bc/52/52745d32.jpg","comment_is_top":false,"comment_ctime":1574411280,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574411280","product_id":100039001,"comment_content":"策略模式找到对应的实现类","like_count":0},{"had_liked":false,"id":154339,"user_name":"刘p辉","can_delete":false,"product_type":"c1","uid":1114781,"ip_address":"","ucode":"84851C7419474F","user_header":"https://static001.geekbang.org/account/avatar/00/11/02/9d/902cd381.jpg","comment_is_top":false,"comment_ctime":1574411170,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574411170","product_id":100039001,"comment_content":"配置+策略模式<br>1、定义接口，策略处理器实现接口，策略处理器有spring管理；<br>1、定义业务类型与策略处理器配置，初始化到内存中；<br>2、根据业务类型获取spring管理策略处理器的bean处理具体业务。","like_count":0},{"had_liked":false,"id":154329,"user_name":"明日","can_delete":false,"product_type":"c1","uid":1003917,"ip_address":"","ucode":"348899EC65AE8D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/51/8d/09f28606.jpg","comment_is_top":false,"comment_ctime":1574410225,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574410225","product_id":100039001,"comment_content":"工厂+配置  or  Java SPI","like_count":0},{"had_liked":false,"id":154327,"user_name":"向前走","can_delete":false,"product_type":"c1","uid":1112651,"ip_address":"","ucode":"8956E92DCEFB60","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/4b/c385f755.jpg","comment_is_top":false,"comment_ctime":1574409997,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574409997","product_id":100039001,"comment_content":"基于接口而不是实现类<br>1.主要表达的是基于抽象还不是具体实现,主要是为了他提高代码的灵活性和可维护性<br>2.如果我们的功能只有一种实现方法,未来也不可能被其它方式替换,则可以不为其设计接口<br>3.接口的命名最好通用,只包含具体实现类的共同特征","like_count":0},{"had_liked":false,"id":154324,"user_name":"学好习，做好人","can_delete":false,"product_type":"c1","uid":1205294,"ip_address":"","ucode":"C991643DB458E2","user_header":"https://static001.geekbang.org/account/avatar/00/12/64/2e/e70a317a.jpg","comment_is_top":false,"comment_ctime":1574409482,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574409482","product_id":100039001,"comment_content":"单纯的脱离现在各种各样的框架来解决这个问题的话，个人感觉依赖工厂+策略模式即可，最简单的工厂模式也能解决，为每种图片解决方式配置一个类型或者其他的标记，在使用的时候传入不同的flag来创建具体的处理方式，不管是阿里云还是私有云，或者说未来还有各种其他云，都是对图片处理的一种方式策略","like_count":0},{"had_liked":false,"id":154319,"user_name":"大脸猫","can_delete":false,"product_type":"c1","uid":1199628,"ip_address":"","ucode":"5BFDD8779589AC","user_header":"https://static001.geekbang.org/account/avatar/00/12/4e/0c/5f04e43e.jpg","comment_is_top":false,"comment_ctime":1574408636,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1574408636","product_id":100039001,"comment_content":"老师 我想请教个问题 使用接口时 例如<br>ImageStore imageStore = new AliyunImageStore(&#47;*省略构造函数*&#47;);<br> imagestore.upload(image, BUCKET_NAME);<br>我想用的是阿里云的存储 我需要 generateAccessToken()方法<br>但我直接new 出来返回的是ImageStore 接口 <br>我应该怎么调用generateAccessToken()方法呢 <br>意思是 我又想用接口的方法 又想调用自身的一些函数 这个怎么处理  一直没有想明白？","like_count":0,"discussions":[{"author":{"id":1433535,"avatar":"https://static001.geekbang.org/account/avatar/00/15/df/bf/96b50d1e.jpg","nickname":"😚 46","note":"","ucode":"EED0EBBBF80A43","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":57063,"discussion_content":"generateAccessToken()没必要暴露给其他外部调用者，对外暴露upload和download即可，generateAccessToken()方法仅作为AliyunImageStore在upload和download所需的一个参数，因此可以将其封装成私有方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574564017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154300,"user_name":"程序员小跃","can_delete":false,"product_type":"c1","uid":1015483,"ip_address":"","ucode":"25BB96E0791A60","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","comment_is_top":false,"comment_ctime":1574406156,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"1574406156","product_id":100039001,"comment_content":"在《Head First设计模式》的结尾，就说过，设计模式只是一种思路，并不是让你每次都需要去考虑。而是要学会如何更好的运用，去适当的使用，而不是滥用。<br><br>设计模式算是锦上添花的操作，只有在必要的时候方可进行。你说搞一个基本的功能，或者是一个helloworld，那用设计模式，岂不是大材小用。<br><br>思考题：还是参考了大家的评论，引出了另一个设计模式“工厂模式”或者反射，期待下一节课","like_count":0,"discussions":[{"author":{"id":1032484,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c1/24/0ea08c9e.jpg","nickname":"柴柴777","note":"","ucode":"5208B935ECB6F7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55989,"discussion_content":"不是为了用而用  是需要用了才去用  ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574420604,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1015483,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","nickname":"程序员小跃","note":"","ucode":"25BB96E0791A60","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1032484,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c1/24/0ea08c9e.jpg","nickname":"柴柴777","note":"","ucode":"5208B935ECB6F7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56518,"discussion_content":"哈哈，那是自然，不然有时候大材小用了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574492774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":55989,"ip_address":""},"score":56518,"extra":""}]}]},{"had_liked":false,"id":154292,"user_name":"阿卡牛","can_delete":false,"product_type":"c1","uid":1022247,"ip_address":"","ucode":"0BC43A904C3199","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","comment_is_top":false,"comment_ctime":1574405082,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574405082","product_id":100039001,"comment_content":"基于不变而非细节编程:)","like_count":0},{"had_liked":false,"id":154289,"user_name":"不似旧日","can_delete":false,"product_type":"c1","uid":1161271,"ip_address":"","ucode":"DF4C5E3AB9570C","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","comment_is_top":false,"comment_ctime":1574404933,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574404933","product_id":100039001,"comment_content":"1.  接口和实现相分离，封装不稳定的实现，暴露稳定的接口。 <br>2. 函数名不能暴露任何实现细节。 <br>3. 封装具体的实现细节， 与特定实现有关的方法不要暴露到接口中 。<br>4. 先定义接口后写实现，不要反过来。<br>5. 过度使用接口","like_count":0},{"had_liked":false,"id":154285,"user_name":"爽了个爽","can_delete":false,"product_type":"c1","uid":1261326,"ip_address":"","ucode":"D5B10F75A02AB1","user_header":"https://static001.geekbang.org/account/avatar/00/13/3f/0e/3a2fb9ff.jpg","comment_is_top":false,"comment_ctime":1574403703,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574403703","product_id":100039001,"comment_content":"工厂模式   具体：SpringContextUtils.getBean（）+枚举类型。不同的实现类不同的类型。 这里用的spring自带的工厂，也可以自己实现工厂。","like_count":0},{"had_liked":false,"id":154277,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1574403036,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574403036","product_id":100039001,"comment_content":"类似spring的di","like_count":0},{"had_liked":false,"id":154274,"user_name":"连边","can_delete":false,"product_type":"c1","uid":1391748,"ip_address":"","ucode":"54B5DA38449728","user_header":"https://static001.geekbang.org/account/avatar/00/15/3c/84/608f679b.jpg","comment_is_top":false,"comment_ctime":1574402217,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574402217","product_id":100039001,"comment_content":"tp里边有一段现成的代码。配置文件里边配置 STORAGE_TYPE；然后再使用的时候创建链接。<br>Storage::connect(STORAGE_TYPE);<br>通过connect方法来调用不同的驱动。<br>&#47;**<br>     * 连接分布式文件系统<br>     * @access public<br>     * @param string $type 文件类型<br>     * @param array $options  配置数组<br>     * @return void<br>     *&#47;<br>    static public function connect($type=&#39;File&#39;,$options=array()) {<br>        $class  =   &#39;Think\\\\Storage\\\\Driver\\\\&#39;.ucwords($type);<br>        self::$handler = new $class($options);<br>    }","like_count":0},{"had_liked":false,"id":154267,"user_name":"Yuuuuu","can_delete":false,"product_type":"c1","uid":1233780,"ip_address":"","ucode":"64FD04761D2111","user_header":"https://static001.geekbang.org/account/avatar/00/12/d3/74/578b169d.jpg","comment_is_top":false,"comment_ctime":1574400532,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574400532","product_id":100039001,"comment_content":"使用工厂模式，根据调用工厂方法时传入的参数返回不同的实例。通过这种模式，把创建对象时类型的选择逻辑全部集中到工厂方法中，方便修改代码。对于配置文件+反射这种方式我觉得并不是很好。修改配置文件是修改，修改工厂的方法也是修改，在判断逻辑不复杂的情况下我觉得直接使用工厂模式更好。","like_count":0},{"had_liked":false,"id":154266,"user_name":"Todd  BD","can_delete":false,"product_type":"c1","uid":1015267,"ip_address":"","ucode":"21F27169916949","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/e3/ad6a4758.jpg","comment_is_top":false,"comment_ctime":1574400409,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574400409","product_id":100039001,"comment_content":"依赖倒置","like_count":0},{"had_liked":false,"id":154265,"user_name":"袁阳","can_delete":false,"product_type":"c1","uid":1329594,"ip_address":"","ucode":"B397F760CDC53A","user_header":"https://static001.geekbang.org/account/avatar/00/14/49/ba/02742d56.jpg","comment_is_top":false,"comment_ctime":1574399708,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574399708","product_id":100039001,"comment_content":"工厂模式","like_count":0},{"had_liked":false,"id":154262,"user_name":"熊斌","can_delete":false,"product_type":"c1","uid":1026280,"ip_address":"","ucode":"24D0C32F397113","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a8/e8/bc84c47d.jpg","comment_is_top":false,"comment_ctime":1574399408,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574399408","product_id":100039001,"comment_content":"平时开发的过程中，第八行这样的应该是类似于Sping里面依赖注入的原理来使用。<br><br>","like_count":0},{"had_liked":false,"id":154258,"user_name":"唐朝农民","can_delete":false,"product_type":"c1","uid":1133947,"ip_address":"","ucode":"6F8F43C6652225","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIaOAxRlZjFkGfRBn420LuAcyWkMrpq5iafGdqthX5icJPjql0ibZOAdafaqbfvw4ZpVzDmsaYglVXDw/132","comment_is_top":false,"comment_ctime":1574398990,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574398990","product_id":100039001,"comment_content":"有个问题，需不需抽象主要看稳不稳定，但是问题是很多时候我们不知道这是不稳定的。","like_count":0},{"had_liked":false,"id":154245,"user_name":"Vettel","can_delete":false,"product_type":"c1","uid":1639787,"ip_address":"","ucode":"FB3E71DD1E8E7C","user_header":"https://static001.geekbang.org/account/avatar/00/19/05/6b/d9d6d68b.jpg","comment_is_top":false,"comment_ctime":1574396426,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574396426","product_id":100039001,"comment_content":"可以参考Spring的IOC和DI吧，但其实说到底还是配置文件+反射+工厂,只是现在都用注解代替写配置文件","like_count":0},{"had_liked":false,"id":154238,"user_name":"拂尘","can_delete":false,"product_type":"c1","uid":1609964,"ip_address":"","ucode":"9563C002E4B06A","user_header":"https://static001.geekbang.org/account/avatar/00/18/90/ec/ede93589.jpg","comment_is_top":false,"comment_ctime":1574394918,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574394918","product_id":100039001,"comment_content":"超级感谢老师，感觉这真的是融汇贯通了。以前虽然对有些设计都有一些认识，但总是结合不到一起来，今天看了文章感觉真的是舒服了；自己看了工厂模式，看了springioc，理论总是说将创建对象交给ioc容器；但总想不到这样做有什么具体意义；以前也想过面向接口编程而非面向实现编；然后以后进行扩展的时候就几乎不用更改源代码；但不过我再想不是也应该要更改new的对象那里嘛；其实使用反射，配置文件也是想到了；但不过我一直也串联不起来或者是没想到；就一直感觉很不好；而且今天也对面向抽象编程而非面向实现有了新的认识；","like_count":0},{"had_liked":false,"id":154219,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1574392140,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574392140","product_id":100039001,"comment_content":"我也想说思考题 是要引出设计模式了哈哈哈哈","like_count":0},{"had_liked":false,"id":154209,"user_name":"Jesse","can_delete":false,"product_type":"c1","uid":1368038,"ip_address":"","ucode":"727CA882B84DA0","user_header":"https://static001.geekbang.org/account/avatar/00/14/df/e6/bd1b3c0b.jpg","comment_is_top":false,"comment_ctime":1574390885,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574390885","product_id":100039001,"comment_content":"思考题<br>用抽象工厂模式解决将process()中的具体的ImageStore类解耦出来，我觉得组合模式也可以，ImageProcessingJob持有一个ImageStore 引用，能达到同样的效果。","like_count":0},{"had_liked":false,"id":154208,"user_name":"塔兹米","can_delete":false,"product_type":"c1","uid":1425252,"ip_address":"","ucode":"1A58C81EF9B0A4","user_header":"https://static001.geekbang.org/account/avatar/00/15/bf/64/c9a0e913.jpg","comment_is_top":false,"comment_ctime":1574390855,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574390855","product_id":100039001,"comment_content":"打卡，<br>关于是思考题，我们用 Java 的解决方法就是spring的依赖注入了，在配置文件里，配置好实现类的地址，<br>将接口声明成，成员变量然后注入即可。","like_count":0},{"had_liked":false,"id":154207,"user_name":"moqifei","can_delete":false,"product_type":"c1","uid":1358410,"ip_address":"","ucode":"E0A6C858B78A3A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLGovXf8jNP5ZqHsDKLwajjicbFwpX9on1xiaJDR4CgWaWP2KcfOdneasBfKFo3dO3dwQyGG6WjK40w/132","comment_is_top":false,"comment_ctime":1574390836,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574390836","product_id":100039001,"comment_content":"抽象工厂设计模式可解","like_count":0},{"had_liked":false,"id":154199,"user_name":"Paper","can_delete":false,"product_type":"c1","uid":1305388,"ip_address":"","ucode":"7EE26C2E892899","user_header":"https://static001.geekbang.org/account/avatar/00/13/eb/2c/ab72fda4.jpg","comment_is_top":false,"comment_ctime":1574390237,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1574390237","product_id":100039001,"comment_content":"接口的使用前提还是要对系统变化进行预估，稳定性高的功能确实很没有必要。","like_count":0},{"had_liked":false,"id":154195,"user_name":"丿淡忘","can_delete":false,"product_type":"c1","uid":1139645,"ip_address":"","ucode":"604AE01961A026","user_header":"https://static001.geekbang.org/account/avatar/00/11/63/bd/80f587ad.jpg","comment_is_top":false,"comment_ctime":1574389865,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1574389865","product_id":100039001,"comment_content":"利用工厂方法","like_count":0},{"had_liked":false,"id":154193,"user_name":"scott","can_delete":false,"product_type":"c1","uid":1276032,"ip_address":"","ucode":"A3C507695AAF9D","user_header":"https://static001.geekbang.org/account/avatar/00/13/78/80/d2547579.jpg","comment_is_top":false,"comment_ctime":1574389832,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574389832","product_id":100039001,"comment_content":"“基于接口而非实现编程“，接口抽象出不稳定，容易变化的实现。实现变动少，不用过度设计接口。具体问题具体分析。","like_count":0},{"had_liked":false,"id":154184,"user_name":"Eden Ma","can_delete":false,"product_type":"c1","uid":1457408,"ip_address":"","ucode":"755312F0D154F9","user_header":"https://static001.geekbang.org/account/avatar/00/16/3d/00/7daa7403.jpg","comment_is_top":false,"comment_ctime":1574388723,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574388723","product_id":100039001,"comment_content":"思考题：用抽象工厂或者工厂模式把具体的存储方式放到具体的类中。","like_count":0},{"had_liked":false,"id":154167,"user_name":"平风造雨","can_delete":false,"product_type":"c1","uid":1014349,"ip_address":"","ucode":"F9EE4704F31E22","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/4d/b0228a1a.jpg","comment_is_top":false,"comment_ctime":1574386659,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574386659","product_id":100039001,"comment_content":"图片上传这个场景是容易想到接口的定义要相对抽象的，但是一些实际的业务场景，比如某个业务领域的查询服务，提供接口的时候，如果不把接口方法名写的具体一点，清楚一点，是不是也不太好","like_count":0},{"had_liked":false,"id":154163,"user_name":"小喵喵","can_delete":false,"product_type":"c1","uid":1062444,"ip_address":"","ucode":"FDBBB2A59DB8B6","user_header":"https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg","comment_is_top":false,"comment_ctime":1574386077,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574386077","product_id":100039001,"comment_content":"基于接口而非实现编程，就是为了应对未来的需求变化，那么请问下老师如何能预测系统未来可能的变化？","like_count":0},{"had_liked":false,"id":154162,"user_name":"小喵喵","can_delete":false,"product_type":"c1","uid":1062444,"ip_address":"","ucode":"FDBBB2A59DB8B6","user_header":"https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg","comment_is_top":false,"comment_ctime":1574386000,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574386000","product_id":100039001,"comment_content":"ImageStore imageStore = new PrivateImageStore(&#47;*省略构造函数*&#47;);<br>上游系统调用的时候，还不是一样依赖细节（PrivateImageStore）吗？<br>=的左边是接口，=右边是细节啊？","like_count":0},{"had_liked":false,"id":154158,"user_name":"deepz","can_delete":false,"product_type":"c1","uid":1570088,"ip_address":"","ucode":"4BD23A44CDB384","user_header":"https://static001.geekbang.org/account/avatar/00/17/f5/28/898a6947.jpg","comment_is_top":false,"comment_ctime":1574385898,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574385898","product_id":100039001,"comment_content":"各位大佬好..我有一个比较..的问题：<br>最近公司重构，表结构改了，之前某业务查询一行数据是，getByBusinessNo(),现在改成走主键id，所有用到的方法我都改了一遍。<br>问题：这种不同条件的业务，我是定义多个方法在接口吗？还是一个方法，传参指明条件这样？😬😬","like_count":0},{"had_liked":false,"id":154142,"user_name":"啦啦啦","can_delete":false,"product_type":"c1","uid":1131687,"ip_address":"","ucode":"6B12EC90A62525","user_header":"https://static001.geekbang.org/account/avatar/00/11/44/a7/171c1e86.jpg","comment_is_top":false,"comment_ctime":1574384552,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574384552","product_id":100039001,"comment_content":"写代码要有抽象意识，把变化多的业务抽象出来，让调用者依赖抽象，不依赖具体实现，可以用接口来实现这种方式，同时也不要每个类都用接口实现，只把变化多的不稳定的搞成接口","like_count":0},{"had_liked":false,"id":154139,"user_name":"小畅","can_delete":false,"product_type":"c1","uid":1322880,"ip_address":"","ucode":"D031CC07CD564E","user_header":"","comment_is_top":false,"comment_ctime":1574384342,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574384342","product_id":100039001,"comment_content":"看到这里差不多要去补习设计模式基础理论了，项目用的少，看来要多用才有所体会","like_count":0},{"had_liked":false,"id":154128,"user_name":"张飞online","can_delete":false,"product_type":"c1","uid":1249136,"ip_address":"","ucode":"C9787E4B35888C","user_header":"https://static001.geekbang.org/account/avatar/00/13/0f/70/759b1567.jpg","comment_is_top":false,"comment_ctime":1574383793,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574383793","product_id":100039001,"comment_content":"最后一问，应该使用接口类作为参数啊，不然定义接口就没有意义了，接口就是为了下面都遵循，上层调用简单，多态的意义","like_count":0},{"had_liked":false,"id":154120,"user_name":"何妨","can_delete":false,"product_type":"c1","uid":1385377,"ip_address":"","ucode":"EC3983BFF7992A","user_header":"https://static001.geekbang.org/account/avatar/00/15/23/a1/b08f3ee7.jpg","comment_is_top":false,"comment_ctime":1574382918,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574382918","product_id":100039001,"comment_content":"重点:1.在定义接口的时候，不要暴露任何实现细节。接口的定义只表明做什么，而不是怎么做。<br>2.接口勿滥用，权衡接口在系统中的作用","like_count":0},{"had_liked":false,"id":154118,"user_name":"WIZ","can_delete":false,"product_type":"c1","uid":1260348,"ip_address":"","ucode":"313AF84674475C","user_header":"https://static001.geekbang.org/account/avatar/00/13/3b/3c/2947127c.jpg","comment_is_top":false,"comment_ctime":1574382876,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574382876","product_id":100039001,"comment_content":"打卡，简略可以用反射+配置文件","like_count":0},{"had_liked":false,"id":154116,"user_name":"安静的boy","can_delete":false,"product_type":"c1","uid":1196475,"ip_address":"","ucode":"F5F44B75228A85","user_header":"https://static001.geekbang.org/account/avatar/00/12/41/bb/21ce60d2.jpg","comment_is_top":false,"comment_ctime":1574382717,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574382717","product_id":100039001,"comment_content":"读完这篇文章终于明白，基于接口编程而非实现编程中的实现是什么意思了。以前总觉着用一个功能不就是需要编写其实现吗，一个接口也需要去实现，怎么就不要基于实现编程了？<br>原来使我把实现这个概念理解错了，实现其实指的是一个完整功能的实现(比如上传图片)细节，这些实现细节是基于特定场景的，后期需求变动后，这些实现细节可能就不能在使用，如果暴露给用户，那需求变动后，改动将会很大。而我们将一个完整的不包含细节的方法提供出去，就算我们改动了具体的实现细节，用户那边也不会变动，提高了系统的稳定性和扩展性。","like_count":0},{"had_liked":false,"id":154112,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1574382572,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574382572","product_id":100039001,"comment_content":"设计模式_09：<br>1. 对于第8行的问题，可以使用基于KV的模式统一配置。<br>2. 今天的内容给我的一个感想是，旧话重提：先思考，后编码。对于很多程序员，编码的过程伴随着快感，于是就像需求的翻译器一样(当然，产品同事一直这么认为)，拿了需求立马开干，一顿操作就完成了新需求，然后，一个小的改动需要重新梳理和修改核心流程，每天加班，时间久了代码完全改不动了。就像文中所说，实现没有变化的业务直接使用实现类，但这个标准在实践中并不那么容易辨别，需要长期的试错式的思考和实践来掌握尺度。","like_count":0},{"had_liked":false,"id":154104,"user_name":"傲慢与偏执，","can_delete":false,"product_type":"c1","uid":1236496,"ip_address":"","ucode":"E9F81223DFAD24","user_header":"https://static001.geekbang.org/account/avatar/00/12/de/10/9f15527d.jpg","comment_is_top":false,"comment_ctime":1574382024,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574382024","product_id":100039001,"comment_content":" 使用工厂模式 创建不同实现","like_count":0},{"had_liked":false,"id":154103,"user_name":"Flash","can_delete":false,"product_type":"c1","uid":1236163,"ip_address":"","ucode":"E285075C9E0B02","user_header":"https://static001.geekbang.org/account/avatar/00/12/dc/c3/e4ba51d5.jpg","comment_is_top":false,"comment_ctime":1574381973,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574381973","product_id":100039001,"comment_content":"思考题:<br>利用AOP切面，将散落的处理图片上传的逻辑集中到切面中处理。","like_count":0},{"had_liked":false,"id":154097,"user_name":"Sirius","can_delete":false,"product_type":"c1","uid":1006740,"ip_address":"","ucode":"257A1F0FC03821","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/94/d8dc54f2.jpg","comment_is_top":false,"comment_ctime":1574381459,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574381459","product_id":100039001,"comment_content":"Ioc","like_count":0},{"had_liked":false,"id":154094,"user_name":"№修罗★幻影","can_delete":false,"product_type":"c1","uid":1010302,"ip_address":"","ucode":"FF89FB2C584833","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6a/7e/a6af4c00.jpg","comment_is_top":false,"comment_ctime":1574380961,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574380961","product_id":100039001,"comment_content":"思考题：<br>可以考虑控制反转(IoC)的思路，不自己主动去实例化(new)，而且依赖容器自动注入(反射)，这样只需要在配置文件中调整好具体实现的类路径，就能完成替换，代码所有引用的地方都无需修改。","like_count":0},{"had_liked":false,"id":154093,"user_name":"刘大明","can_delete":false,"product_type":"c1","uid":1035081,"ip_address":"","ucode":"83C063FBD9BF2B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cb/49/0b9ffc8e.jpg","comment_is_top":false,"comment_ctime":1574380949,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574380949","product_id":100039001,"comment_content":"读完这篇真的感觉以前写的接口很多都包含了实现细节，而且完全不知道这种方式确实不利于需求的变化。要培养自己基于接口编程的思维模式。<br>思考题里面可以用简单工厂模式来把具体的类型放到工厂里面去对方提供方法。","like_count":0},{"had_liked":false,"id":154088,"user_name":"探索无止境","can_delete":false,"product_type":"c1","uid":1044178,"ip_address":"","ucode":"91D2A9907DFA79","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/d2/7024431c.jpg","comment_is_top":false,"comment_ctime":1574380579,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574380579","product_id":100039001,"comment_content":"控制反转，交给第三方容器来注入","like_count":0},{"had_liked":false,"id":154086,"user_name":"冀云","can_delete":false,"product_type":"c1","uid":1175189,"ip_address":"","ucode":"01E3B55795E90A","user_header":"https://static001.geekbang.org/account/avatar/00/11/ee/95/6fe64a45.jpg","comment_is_top":false,"comment_ctime":1574380470,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574380470","product_id":100039001,"comment_content":"下节课要讲工厂模式了，提前埋下了伏笔！","like_count":0},{"had_liked":false,"id":154083,"user_name":"乐溪溪520","can_delete":false,"product_type":"c1","uid":1168975,"ip_address":"","ucode":"99FBCEC0083E06","user_header":"https://static001.geekbang.org/account/avatar/00/11/d6/4f/008f9d6a.jpg","comment_is_top":false,"comment_ctime":1574380029,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574380029","product_id":100039001,"comment_content":"通过工厂方法设计模式，将具体的实现抽离出来。","like_count":0},{"had_liked":false,"id":154082,"user_name":"L🚲🐱","can_delete":false,"product_type":"c1","uid":1577856,"ip_address":"","ucode":"08A012739614DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","comment_is_top":false,"comment_ctime":1574380024,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574380024","product_id":100039001,"comment_content":"如果是java 就用spring 容器管理接口 这样接口就统一管理了，不需要我们修改大量的代码","like_count":0},{"had_liked":false,"id":154079,"user_name":"Cy23","can_delete":false,"product_type":"c1","uid":1591293,"ip_address":"","ucode":"8DC561C5151758","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/fd/895f0c27.jpg","comment_is_top":false,"comment_ctime":1574379567,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574379567","product_id":100039001,"comment_content":"原来对接口的作用只是模糊的了解，这回理解的更深刻了，<br>课后讨论题：我觉得应该有一个类可以通过读取全局配置然后选择当前用哪一个图片上传下载，然后具体的调用类直接调用该类方法，而没必要了解具体的选择及实现","like_count":0}]}