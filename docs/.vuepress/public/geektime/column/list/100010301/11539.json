{"id":11539,"title":"04 | JVM是如何执行方法调用的？（上）","content":"<p>前不久在写代码的时候，我不小心踩到一个可变长参数的坑。你或许已经猜到了，它正是可变长参数方法的重载造成的。（注：官方文档建议避免重载可变长参数方法，见[1]的最后一段。）</p><p>我把踩坑的过程放在了文稿里，你可以点击查看。</p><pre><code>void invoke(Object obj, Object... args) { ... }\nvoid invoke(String s, Object obj, Object... args) { ... }\n\ninvoke(null, 1);    // 调用第二个invoke方法\ninvoke(null, 1, 2); // 调用第二个invoke方法\ninvoke(null, new Object[]{1}); // 只有手动绕开可变长参数的语法糖，\n                               // 才能调用第一个invoke方法\n\n</code></pre><p>当时情况是这样子的，某个API定义了两个同名的重载方法。其中，第一个接收一个Object，以及声明为Object…的变长参数；而第二个则接收一个String、一个Object，以及声明为Object…的变长参数。</p><p>这里我想调用第一个方法，传入的参数为(null, 1)。也就是说，声明为Object的形式参数所对应的实际参数为null，而变长参数则对应1。</p><p>通常来说，之所以不提倡可变长参数方法的重载，是因为Java编译器可能无法决定应该调用哪个目标方法。</p><p>在这种情况下，编译器会报错，并且提示这个方法调用有二义性。然而，Java编译器直接将我的方法调用识别为调用第二个方法，这究竟是为什么呢？</p><p>带着这个问题，我们来看一看Java虚拟机是怎么识别目标方法的。</p><h2>重载与重写</h2><p>在Java程序里，如果同一个类中出现多个名字相同，并且参数类型相同的方法，那么它无法通过编译。也就是说，在正常情况下，如果我们想要在同一个类中定义名字相同的方法，那么它们的参数类型必须不同。这些方法之间的关系，我们称之为重载。</p><!-- [[[read_end]]] --><pre><code>小知识：这个限制可以通过字节码工具绕开。也就是说，在编译完成之后，我们可以再向class文件中添加方法名和参数类型相同，而返回类型不同的方法。当这种包括多个方法名相同、参数类型相同，而返回类型不同的方法的类，出现在Java编译器的用户类路径上时，它是怎么确定需要调用哪个方法的呢？当前版本的Java编译器会直接选取第一个方法名以及参数类型匹配的方法。并且，它会根据所选取方法的返回类型来决定可不可以通过编译，以及需不需要进行值转换等。\n</code></pre><p>重载的方法在编译过程中即可完成识别。具体到每一个方法调用，Java编译器会根据所传入参数的声明类型（注意与实际类型区分）来选取重载方法。选取的过程共分为三个阶段：</p><ol>\n<li>在不考虑对基本类型自动装拆箱（auto-boxing，auto-unboxing），以及可变长参数的情况下选取重载方法；</li>\n<li>如果在第1个阶段中没有找到适配的方法，那么在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法；</li>\n<li>如果在第2个阶段中没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况下选取重载方法。</li>\n</ol><p>如果Java编译器在同一个阶段中找到了多个适配的方法，那么它会在其中选择一个最为贴切的，而决定贴切程度的一个关键就是形式参数类型的继承关系。</p><p>在开头的例子中，当传入null时，它既可以匹配第一个方法中声明为Object的形式参数，也可以匹配第二个方法中声明为String的形式参数。由于String是Object的子类，因此Java编译器会认为第二个方法更为贴切。</p><p>除了同一个类中的方法，重载也可以作用于这个类所继承而来的方法。也就是说，如果子类定义了与父类中非私有方法同名的方法，而且这两个方法的参数类型不同，那么在子类中，这两个方法同样构成了重载。</p><p>那么，如果子类定义了与父类中非私有方法同名的方法，而且这两个方法的参数类型相同，那么这两个方法之间又是什么关系呢？</p><p>如果这两个方法都是静态的，那么子类中的方法隐藏了父类中的方法。如果这两个方法都不是静态的，且都不是私有的，那么子类的方法重写了父类中的方法。</p><p>众所周知，Java是一门面向对象的编程语言，它的一个重要特性便是多态。而方法重写，正是多态最重要的一种体现方式：它允许子类在继承父类部分功能的同时，拥有自己独特的行为。</p><p>打个比方，如果你经常漫游，那么你可能知道，拨打10086会根据你当前所在地，连接到当地的客服。重写调用也是如此：它会根据调用者的动态类型，来选取实际的目标方法。</p><h2>JVM的静态绑定和动态绑定</h2><p>接下来，我们来看看Java虚拟机是怎么识别方法的。</p><p>Java虚拟机识别方法的关键在于类名、方法名以及方法描述符（method descriptor）。前面两个就不做过多的解释了。至于方法描述符，它是由方法的参数类型以及返回类型所构成。在同一个类中，如果同时出现多个名字相同且描述符也相同的方法，那么Java虚拟机会在类的验证阶段报错。</p><p>可以看到，Java虚拟机与Java语言不同，它并不限制名字与参数类型相同，但返回类型不同的方法出现在同一个类中，对于调用这些方法的字节码来说，由于字节码所附带的方法描述符包含了返回类型，因此Java虚拟机能够准确地识别目标方法。</p><p>Java虚拟机中关于方法重写的判定同样基于方法描述符。也就是说，如果子类定义了与父类中非私有、非静态方法同名的方法，那么只有当这两个方法的参数类型以及返回类型一致，Java虚拟机才会判定为重写。</p><p>对于Java语言中重写而Java虚拟机中非重写的情况，编译器会通过生成桥接方法[2]来实现Java中的重写语义。</p><p>由于对重载方法的区分在编译阶段已经完成，我们可以认为Java虚拟机不存在重载这一概念。因此，在某些文章中，重载也被称为静态绑定（static binding），或者编译时多态（compile-time polymorphism）；而重写则被称为动态绑定（dynamic binding）。</p><p>这个说法在Java虚拟机语境下并非完全正确。这是因为某个类中的重载方法可能被它的子类所重写，因此Java编译器会将所有对非私有实例方法的调用编译为需要动态绑定的类型。</p><p>确切地说，Java虚拟机中的静态绑定指的是在解析时便能够直接识别目标方法的情况，而动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况。</p><p>具体来说，Java字节码中与调用相关的指令共有五种。</p><ol>\n<li>invokestatic：用于调用静态方法。</li>\n<li>invokespecial：用于调用私有实例方法、构造器，以及使用super关键字调用父类的实例方法或构造器，和所实现接口的默认方法。</li>\n<li>invokevirtual：用于调用非私有实例方法。</li>\n<li>invokeinterface：用于调用接口方法。</li>\n<li>invokedynamic：用于调用动态方法。</li>\n</ol><p>由于invokedynamic指令较为复杂，我将在后面的篇章中单独介绍。这里我们只讨论前四种。</p><p>我在文章中贴了一段代码，展示了编译生成这四种调用指令的情况。</p><pre><code>interface 客户 {\n  boolean isVIP();\n}\n\nclass 商户 {\n  public double 折后价格(double 原价, 客户 某客户) {\n    return 原价 * 0.8d;\n  }\n}\n\nclass 奸商 extends 商户 {\n  @Override\n  public double 折后价格(double 原价, 客户 某客户) {\n    if (某客户.isVIP()) {                         // invokeinterface      \n      return 原价 * 价格歧视();                    // invokestatic\n    } else {\n      return super.折后价格(原价, 某客户);          // invokespecial\n    }\n  }\n  public static double 价格歧视() {\n    // 咱们的杀熟算法太粗暴了，应该将客户城市作为随机数生成器的种子。\n    return new Random()                          // invokespecial\n           .nextDouble()                         // invokevirtual\n           + 0.8d;\n  }\n}\n</code></pre><p>在代码中，“商户”类定义了一个成员方法，叫做“折后价格”，它将接收一个double类型的参数，以及一个“客户”类型的参数。这里“客户”是一个接口，它定义了一个接口方法，叫“isVIP”。</p><p>我们还定义了另一个叫做“奸商”的类，它继承了“商户”类，并且重写了“折后价格”这个方法。如果客户是VIP，那么它会被给到一个更低的折扣。</p><p>在这个方法中，我们首先会调用“客户”接口的”isVIP“方法。该调用会被编译为invokeinterface指令。</p><p>如果客户是VIP，那么我们会调用奸商类的一个名叫“价格歧视”的静态方法。该调用会被编译为invokestatic指令。如果客户不是VIP，那么我们会通过super关键字调用父类的“折后价格”方法。该调用会被编译为invokespecial指令。</p><p>在静态方法“价格歧视”中，我们会调用Random类的构造器。该调用会被编译为invokespecial指令。然后我们会以这个新建的Random对象为调用者，调用Random类中的nextDouble方法。该调用会被编译为invokevirutal指令。</p><p>对于invokestatic以及invokespecial而言，Java虚拟机能够直接识别具体的目标方法。</p><p>而对于invokevirtual以及invokeinterface而言，在绝大部分情况下，虚拟机需要在执行过程中，根据调用者的动态类型，来确定具体的目标方法。</p><p>唯一的例外在于，如果虚拟机能够确定目标方法有且仅有一个，比如说目标方法被标记为final[3][4]，那么它可以不通过动态类型，直接确定目标方法。</p><h2>调用指令的符号引用</h2><p>在编译过程中，我们并不知道目标方法的具体内存地址。因此，Java编译器会暂时用符号引用来表示该目标方法。这一符号引用包括目标方法所在的类或接口的名字，以及目标方法的方法名和方法描述符。</p><p>符号引用存储在class文件的常量池之中。根据目标方法是否为接口方法，这些引用可分为接口符号引用和非接口符号引用。我在文章中贴了一个例子，利用“javap -v”打印某个类的常量池，如果你感兴趣的话可以到文章中查看。</p><pre><code>// 在奸商.class的常量池中，#16为接口符号引用，指向接口方法&quot;客户.isVIP()&quot;。而#22为非接口符号引用，指向静态方法&quot;奸商.价格歧视()&quot;。\n$ javap -v 奸商.class ...\nConstant pool:\n...\n  #16 = InterfaceMethodref #27.#29        // 客户.isVIP:()Z\n...\n  #22 = Methodref          #1.#33         // 奸商.价格歧视:()D\n...\n</code></pre><p>上一篇中我曾提到过，在执行使用了符号引用的字节码前，Java虚拟机需要解析这些符号引用，并替换为实际引用。</p><p>对于非接口符号引用，假定该符号引用所指向的类为C，则Java虚拟机会按照如下步骤进行查找。</p><ol>\n<li>在C中查找符合名字及描述符的方法。</li>\n<li>如果没有找到，在C的父类中继续搜索，直至Object类。</li>\n<li>如果没有找到，在C所直接实现或间接实现的接口中搜索，这一步搜索得到的目标方法必须是非私有、非静态的。并且，如果目标方法在间接实现的接口中，则需满足C与该接口之间没有其他符合条件的目标方法。如果有多个符合条件的目标方法，则任意返回其中一个。</li>\n</ol><p>从这个解析算法可以看出，静态方法也可以通过子类来调用。此外，子类的静态方法会隐藏（注意与重写区分）父类中的同名、同描述符的静态方法。</p><p>对于接口符号引用，假定该符号引用所指向的接口为I，则Java虚拟机会按照如下步骤进行查找。</p><ol>\n<li>在I中查找符合名字及描述符的方法。</li>\n<li>如果没有找到，在Object类中的公有实例方法中搜索。</li>\n<li>如果没有找到，则在I的超接口中搜索。这一步的搜索结果的要求与非接口符号引用步骤3的要求一致。</li>\n</ol><p>经过上述的解析步骤之后，符号引用会被解析成实际引用。对于可以静态绑定的方法调用而言，实际引用是一个指向方法的指针。对于需要动态绑定的方法调用而言，实际引用则是一个方法表的索引。具体什么是方法表，我会在下一篇中做出解答。</p><h2>总结与实践</h2><p>今天我介绍了Java以及Java虚拟机是如何识别目标方法的。</p><p>在Java中，方法存在重载以及重写的概念，重载指的是方法名相同而参数类型不相同的方法之间的关系，重写指的是方法名相同并且参数类型也相同的方法之间的关系。</p><p>Java虚拟机识别方法的方式略有不同，除了方法名和参数类型之外，它还会考虑返回类型。</p><p>在Java虚拟机中，静态绑定指的是在解析时便能够直接识别目标方法的情况，而动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况。由于Java编译器已经区分了重载的方法，因此可以认为Java虚拟机中不存在重载。</p><p>在class文件中，Java编译器会用符号引用指代目标方法。在执行调用指令前，它所附带的符号引用需要被解析成实际引用。对于可以静态绑定的方法调用而言，实际引用为目标方法的指针。对于需要动态绑定的方法调用而言，实际引用为辅助动态绑定的信息。</p><p>在文中我曾提到，Java的重写与Java虚拟机中的重写并不一致，但是编译器会通过生成桥接方法来弥补。今天的实践环节，我们来看一下两个生成桥接方法的例子。你可以通过“javap -v”来查看class文件所包含的方法。</p><ol>\n<li>重写方法的返回类型不一致：</li>\n</ol><pre><code>interface Customer {\n  boolean isVIP();\n}\n\nclass Merchant {\n  public Number actionPrice(double price, Customer customer) {\n    ...\n  }\n}\n\nclass NaiveMerchant extends Merchant {\n  @Override\n  public Double actionPrice(double price, Customer customer) {\n    ...\n  }\n}\n</code></pre><ol>\n<li>范型参数类型造成的方法参数类型不一致：</li>\n</ol><pre><code>interface Customer {\n  boolean isVIP();\n}\n\nclass Merchant&lt;T extends Customer&gt; {\n \tpublic double actionPrice(double price, T customer) {\n\t\t  ...\n \t}\n}\n\nclass VIPOnlyMerchant extends Merchant&lt;VIP&gt; {\n\t @Override\n \tpublic double actionPrice(double price, VIP customer) {\n    ...\n \t}\n}\n</code></pre><p>[1] <a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/language/varargs.html\">https://docs.oracle.com/javase/8/docs/technotes/guides/language/varargs.html</a><br>\n[2]<br>\n<a href=\"https://docs.oracle.com/javase/tutorial/java/generics/bridgeMethods.html\">https://docs.oracle.com/javase/tutorial/java/generics/bridgeMethods.html</a><br>\n[3]<br>\n<a href=\"https://wiki.openjdk.java.net/display/HotSpot/VirtualCalls\">https://wiki.openjdk.java.net/display/HotSpot/VirtualCalls</a><br>\n[4]<br>\n<a href=\"https://wiki.openjdk.java.net/display/HotSpot/InterfaceCalls\">https://wiki.openjdk.java.net/display/HotSpot/InterfaceCalls</a></p><p></p>","comments":[{"had_liked":false,"id":17497,"user_name":"Thomas","can_delete":false,"product_type":"c1","uid":1178585,"ip_address":"","ucode":"36950010DB3D29","user_header":"https://static001.geekbang.org/account/avatar/00/11/fb/d9/055e5383.jpg","comment_is_top":true,"comment_ctime":1532689088,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"9.223372210186199e+18","product_id":100010301,"comment_content":"看明白了......这篇真好","like_count":41,"discussions":[{"author":{"id":1598229,"avatar":"https://static001.geekbang.org/account/avatar/00/18/63/15/cbbbdba0.jpg","nickname":"纯风","note":"","ucode":"CCA837A3E9BF2A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285488,"discussion_content":"这他妈就置顶了。。。这书真他妹白买了","likes_number":13,"is_delete":false,"is_hidden":false,"ctime":1592842012,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1440772,"avatar":"https://static001.geekbang.org/account/avatar/00/15/fc/04/d83a555e.jpg","nickname":"Kevin⚡️Zhou","note":"","ucode":"C0FC2673705212","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1598229,"avatar":"https://static001.geekbang.org/account/avatar/00/18/63/15/cbbbdba0.jpg","nickname":"纯风","note":"","ucode":"CCA837A3E9BF2A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294411,"discussion_content":"哈哈哈, 精选留言精选好评","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595868302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":285488,"ip_address":""},"score":294411,"extra":""},{"author":{"id":1553046,"avatar":"https://static001.geekbang.org/account/avatar/00/17/b2/96/a524ebf6.jpg","nickname":"silas","note":"","ucode":"EEFF1E8ED00EE6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1440772,"avatar":"https://static001.geekbang.org/account/avatar/00/15/fc/04/d83a555e.jpg","nickname":"Kevin⚡️Zhou","note":"","ucode":"C0FC2673705212","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387254,"discussion_content":"赞同。笑死 哈哈哈","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1628074216,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":294411,"ip_address":""},"score":387254,"extra":""},{"author":{"id":3200055,"avatar":"","nickname":"Geek_db4ed1","note":"","ucode":"3DADCDF0D27D8F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1598229,"avatar":"https://static001.geekbang.org/account/avatar/00/18/63/15/cbbbdba0.jpg","nickname":"纯风","note":"","ucode":"CCA837A3E9BF2A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590337,"discussion_content":"我没花钱，哈哈哈哈","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1665664173,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":285488,"ip_address":"吉林"},"score":590337,"extra":""}]},{"author":{"id":2305369,"avatar":"","nickname":"Geek_e06822","note":"","ucode":"039375628C4F41","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325503,"discussion_content":"啥也不是","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605331335,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2238635,"avatar":"https://static001.geekbang.org/account/avatar/00/22/28/ab/b8905658.jpg","nickname":"AsYouWish99","note":"","ucode":"A5CE38DAD56115","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2305369,"avatar":"","nickname":"Geek_e06822","note":"","ucode":"039375628C4F41","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578592,"discussion_content":"啥也不是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656913310,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":325503,"ip_address":""},"score":578592,"extra":""}]},{"author":{"id":1057413,"avatar":"https://static001.geekbang.org/account/avatar/00/10/22/85/3c3da0d5.jpg","nickname":"Siu","note":"","ucode":"457557F4918BF2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":562081,"discussion_content":"我都不好意思说看不懂了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649771815,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1308989,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/U3vlJMexUDicb8x8Xugky0vdPyyC7wl7bgy69nxal54XPOhTRV6tiaoxzSopKEJf7QUcP8lLB5Siby71xozul0W6A/132","nickname":"kyle","note":"","ucode":"8C66FCA0B0D3C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1057413,"avatar":"https://static001.geekbang.org/account/avatar/00/10/22/85/3c3da0d5.jpg","nickname":"Siu","note":"","ucode":"457557F4918BF2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572662,"discussion_content":"我就看不懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652885909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":562081,"ip_address":""},"score":572662,"extra":""}]}]},{"had_liked":false,"id":17658,"user_name":"永烁星光","can_delete":false,"product_type":"c1","uid":1119617,"ip_address":"","ucode":"D26A9097F9D24C","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/81/2c31cf79.jpg","comment_is_top":false,"comment_ctime":1532851126,"is_pvip":false,"discussion_count":9,"race_medal":0,"score":"847641408438","product_id":100010301,"comment_content":"写的有点晦涩难懂，看了好几遍，还是有点迷糊","like_count":198,"discussions":[{"author":{"id":1208265,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6f/c9/22022094.jpg","nickname":"丁奇老师的粉丝","note":"","ucode":"6341E0D78CF998","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587,"discussion_content":"作者可能自己也不知道自己在说什么","likes_number":13,"is_delete":false,"is_hidden":false,"ctime":1561730735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2060756,"avatar":"","nickname":"在下蟑螂王","note":"","ucode":"E66A65A327095A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1208265,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6f/c9/22022094.jpg","nickname":"丁奇老师的粉丝","note":"","ucode":"6341E0D78CF998","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300735,"discussion_content":"厉害了竟然改名了，我感觉丁奇像lol的主播毒纪","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598250869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":587,"ip_address":""},"score":300735,"extra":""}]},{"author":{"id":1622007,"avatar":"https://static001.geekbang.org/account/avatar/00/18/bf/f7/691a9200.jpg","nickname":"炮灰","note":"","ucode":"45A24460D8D195","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365535,"discussion_content":"我也觉得，他写的云里雾里的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1617815768,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1905194,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/12/2a/47517056.jpg","nickname":"LeonJump2sky","note":"","ucode":"A183F115939395","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261174,"discussion_content":"好难啊。。。看不懂","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1588944495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1161271,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","nickname":"不似旧日","note":"","ucode":"DF4C5E3AB9570C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220620,"discussion_content":"我就读到了JVM没有方法重载的概念","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1585907913,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1168195,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d3/43/f22b39c3.jpg","nickname":"举个荔枝","note":"","ucode":"7F6B8EC3A3E0E1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42828,"discussion_content":"还是 周志明写的好","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1572787297,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1161271,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","nickname":"不似旧日","note":"","ucode":"DF4C5E3AB9570C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1168195,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d3/43/f22b39c3.jpg","nickname":"举个荔枝","note":"","ucode":"7F6B8EC3A3E0E1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220619,"discussion_content":"周志明是谁? ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585907875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":42828,"ip_address":""},"score":220619,"extra":""},{"author":{"id":1883035,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/bb/9b/d649f756.jpg","nickname":"月夜枫","note":"","ucode":"A153D482576782","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1168195,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d3/43/f22b39c3.jpg","nickname":"举个荔枝","note":"","ucode":"7F6B8EC3A3E0E1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308188,"discussion_content":"侧重点不一样，把知识讲透就行，周志明的我看了一遍还是糊涂，这个老师讲的就懂了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600866012,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":42828,"ip_address":""},"score":308188,"extra":""}]},{"author":{"id":2414042,"avatar":"","nickname":"pmwx9","note":"","ucode":"CEB5A20A64978F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":405212,"discussion_content":"确实有点云里雾里 太概念了 这里感觉还是得了解虚拟机的源码和原理才能理解透彻","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1634530801,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":53989,"user_name":"胡小榕","can_delete":false,"product_type":"c1","uid":1300169,"ip_address":"","ucode":"351E2032C75CB6","user_header":"https://static001.geekbang.org/account/avatar/00/13/d6/c9/08a62ac7.jpg","comment_is_top":false,"comment_ctime":1545784451,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"469697219715","product_id":100010301,"comment_content":"请不要用中文定义类&#47;变量，有强迫症","like_count":110,"discussions":[{"author":{"id":1566013,"avatar":"https://static001.geekbang.org/account/avatar/00/17/e5/3d/2af3943a.jpg","nickname":"傲雲+","note":"","ucode":"08EDC63609C4F6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":128533,"discussion_content":"用中文定义真是看了头疼","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1578647997,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1294716,"avatar":"https://static001.geekbang.org/account/avatar/00/13/c1/7c/63f60a17.jpg","nickname":"迷","note":"","ucode":"F280A7D44470F9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":258783,"discussion_content":"既然都看jvm，一般都Java有一定的熟练度了，赞同不要用中文命名，看着别扭","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588728016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1763992,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/ea/98/65a13c45.jpg","nickname":"木木","note":"","ucode":"B182555D11946D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586388,"discussion_content":"+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662180653,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1997159,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/79/67/b4546e48.jpg","nickname":"咕噜咕噜咕","note":"","ucode":"291A60A726AA19","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577054,"discussion_content":"确实，看中文感觉怪怪的~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655902647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1397672,"avatar":"https://static001.geekbang.org/account/avatar/00/15/53/a8/73618c92.jpg","nickname":"kai楷","note":"","ucode":"623D38565BF0EF","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358241,"discussion_content":"看完中文，我都忘了这段代码什么意思了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615951383,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1062997,"avatar":"https://static001.geekbang.org/account/avatar/00/10/38/55/a719a520.jpg","nickname":"Marshal丶","note":"","ucode":"15A3EB0F06E42C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324264,"discussion_content":"+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605081870,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1622408,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c1/88/66e1f886.jpg","nickname":"幸福就在不远处","note":"","ucode":"1643DE193A7310","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":243128,"discussion_content":"一样的感觉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587522335,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":17744,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1532921848,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"194806450168","product_id":100010301,"comment_content":"1:方法重载<br>方法名相同、方法参数类型不同（其中包括参数的个数、类型、次序，三者之中只要有一个不同就行）。以前的理解方法重载是在一个类内，今天读后感觉类间有继承关系也是存在方法重载的，需要验证一下？<br><br>2:方法重写<br>方法名相同、方法参数类型相同、方法返回值相同，类之间有继承关系，便构成方法重写。<br>这个概念和之前一样，不过老师强调了父类中的方法是飞私有、非静态的，这个有待验证一下？<br><br>3:JVM定位目标方法的关键是类名+方法名+方法参数类型+方法返回值类型，于是就出现了两种JVM找目标方法的方式，静态绑定、动态绑定<br><br>4:静态绑定<br>在解析时JVM便知道该调用那个目标方法<br><br>5:动态绑定<br>在运行时JVM需要根据对应的类类型来具体定位应该调用那个目标方法。对于方法重写，对应的类会拥有一个方法表（一个二维数组表，给方法标上序号，重写的方法序号一致）<br><br>听了几遍，也看了几遍，感觉对具体细节还是不清楚，比如：<br>1:静态绑定具体咋实现的？<br>2:方法表在那里？啥时候创建的？咋和具体的类关联起来的呢？<br>可能篇幅有限啊！总体老师讲的很好，有些细节没讲到，我的感觉！","like_count":46,"discussions":[{"author":{"id":1254864,"avatar":"https://static001.geekbang.org/account/avatar/00/13/25/d0/3d5696d8.jpg","nickname":"无嘴小呆子","note":"","ucode":"4165B025F20929","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8863,"discussion_content":"非虚方法比如构造器,在一个类加载阶段就已经可以确定是唯一的,不会有多态的,动态绑定主要是针对多态,在运行期才能确定具体调用哪个方法,使用的方法表,在类加载的<clinit>初始化方法中确定,每个类都有一个包含所有方法描述符的数组,子类重写了父类的情况下调用其实父类子类的方法表中都存在相同方法名的方法,调用关系是先查找子类中是否存在,如果存在就调用子类,如果不存在就调用父类的,这就是多态,也就是动态单分配","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1568085630,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1338584,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6c/d8/68fec932.jpg","nickname":"花花young","note":"","ucode":"95AD30303C2B21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1254864,"avatar":"https://static001.geekbang.org/account/avatar/00/13/25/d0/3d5696d8.jpg","nickname":"无嘴小呆子","note":"","ucode":"4165B025F20929","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":241967,"discussion_content":"厉害厉害，长知识","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587452931,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":8863,"ip_address":""},"score":241967,"extra":""}]},{"author":{"id":1115724,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLwSoTjHPX5tm4whBSfoZLX6toZxrZGUaLABQywKNf4MDc9toK3QSV7Z99ATcGicFCysoleQ5ISzmw/132","nickname":"乘风","note":"","ucode":"0420C5535DACB7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1591,"discussion_content":"静态绑定：在解析阶段会将非虚方法的符号引用解析为直接引用，因为非虚方法的调用归属在静态编译时期就可以确定了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1562723192,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1598229,"avatar":"https://static001.geekbang.org/account/avatar/00/18/63/15/cbbbdba0.jpg","nickname":"纯风","note":"","ucode":"CCA837A3E9BF2A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263221,"discussion_content":"老师没给你评论  证明你说的不对\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589189525,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37290,"user_name":"jiaobuchongจุ๊บ","can_delete":false,"product_type":"c1","uid":1118938,"ip_address":"","ucode":"0AEE4E579DC3A2","user_header":"https://static001.geekbang.org/account/avatar/00/11/12/da/a3ea305f.jpg","comment_is_top":false,"comment_ctime":1541518519,"is_pvip":false,"replies":[{"id":"14103","content":"赞！","user_name":"作者回复","comment_id":37290,"uid":"1176688","ip_address":"","utype":1,"ctime":1542279960,"user_name_real":"郑雨迪"}],"discussion_count":2,"race_medal":0,"score":"186225112247","product_id":100010301,"comment_content":"参考老师最后的例子，写了博客总结了一下：https:&#47;&#47;blog.csdn.net&#47;jiaobuchong&#47;article&#47;details&#47;83722193，欢迎拍砖。","like_count":44,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428280,"discussion_content":"赞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542279960,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1126593,"avatar":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","nickname":"密码123456","note":"","ucode":"9889463CC0EA71","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":397585,"discussion_content":"这么看，桥接方法，就是以重载的形式来适配重写。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632646130,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":56648,"user_name":"...","can_delete":false,"product_type":"c1","uid":1118296,"ip_address":"","ucode":"B699B369FCFE77","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/58/c5248989.jpg","comment_is_top":false,"comment_ctime":1546516430,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"70265993166","product_id":100010301,"comment_content":"没完全理解，上来开头没有好的引入。","like_count":16},{"had_liked":false,"id":20175,"user_name":"蒙奇•D•273°","can_delete":false,"product_type":"c1","uid":1179601,"ip_address":"","ucode":"5570919A507386","user_header":"https://static001.geekbang.org/account/avatar/00/11/ff/d1/28adb620.jpg","comment_is_top":false,"comment_ctime":1534298274,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"53073905826","product_id":100010301,"comment_content":"没完全理解。有个问题，接口符号指向接口方法，但是接口是没有实现的，他的实现在其实现类里面，我理解最终应该指向接口的实现类","like_count":12,"discussions":[{"author":{"id":1254864,"avatar":"https://static001.geekbang.org/account/avatar/00/13/25/d0/3d5696d8.jpg","nickname":"无嘴小呆子","note":"","ucode":"4165B025F20929","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8865,"discussion_content":"你创建一个 Interface i的时候在编译器是静态编译,只能先将符号引用->指向接口i里面的方法,至于它的实现方式是在运行期通过多态来确定具体是哪个类实现,该类中的方法表中肯定有实现方法(接口中的方法必须实现的),我们就能用具体类中的方法","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1568085885,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1179601,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ff/d1/28adb620.jpg","nickname":"蒙奇•D•273°","note":"","ucode":"5570919A507386","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1254864,"avatar":"https://static001.geekbang.org/account/avatar/00/13/25/d0/3d5696d8.jpg","nickname":"无嘴小呆子","note":"","ucode":"4165B025F20929","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49909,"discussion_content":"受益了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573649396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":8865,"ip_address":""},"score":49909,"extra":""}]}]},{"had_liked":false,"id":17567,"user_name":"Askerlve","can_delete":false,"product_type":"c1","uid":1178535,"ip_address":"","ucode":"BF29F9A8674507","user_header":"https://static001.geekbang.org/account/avatar/00/11/fb/a7/12c90699.jpg","comment_is_top":false,"comment_ctime":1532750740,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"44482423700","product_id":100010301,"comment_content":"任督二脉就靠这个系列打通了～🤑","like_count":10},{"had_liked":false,"id":174500,"user_name":"Hi Young","can_delete":false,"product_type":"c1","uid":1548645,"ip_address":"","ucode":"E1E9C88399F3C2","user_header":"https://static001.geekbang.org/account/avatar/00/17/a1/65/44853770.jpg","comment_is_top":false,"comment_ctime":1580253249,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"40234958913","product_id":100010301,"comment_content":"从一个没有了解过jvm的读者角度看，这篇文章的行文组织没有简单的明确的讲清楚，最初看的一头雾水，看了两遍再+额外查找其他资料+自己写读书笔记才理解。<br>建议开头时候准确的回答出全部的调用过程，其中涉猎的未知的领域或概念，可以逐步的在后续展开，这样对于初学者来说更友好","like_count":8},{"had_liked":false,"id":17449,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1532653977,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"35892392345","product_id":100010301,"comment_content":"需要看三遍","like_count":9,"discussions":[{"author":{"id":2451310,"avatar":"https://static001.geekbang.org/account/avatar/00/25/67/6e/ec7299ec.jpg","nickname":"达芬奇","note":"","ucode":"B174F5347557B3","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585029,"discussion_content":"还得温故","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661302090,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2055017,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/5b/69/477a9071.jpg","nickname":"璟","note":"","ucode":"EA244A298C262B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297141,"discussion_content":"看了五遍 总结两遍看的差不多明白","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596785430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":17612,"user_name":"小贝_No_7","can_delete":false,"product_type":"c1","uid":1063224,"ip_address":"","ucode":"84C39D64EF04C3","user_header":"https://static001.geekbang.org/account/avatar/00/10/39/38/4c962666.jpg","comment_is_top":false,"comment_ctime":1532779928,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"31597551000","product_id":100010301,"comment_content":"如果这两个方法都是静态的，那么子类中的方法隐藏了父类中的方法。<br><br>这句没太明白，这个(隐藏)是否有更深一层的意义？","like_count":7,"discussions":[{"author":{"id":1254864,"avatar":"https://static001.geekbang.org/account/avatar/00/13/25/d0/3d5696d8.jpg","nickname":"无嘴小呆子","note":"","ucode":"4165B025F20929","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8868,"discussion_content":"可以这样理解,父类Father中有一个静态方法getName(),如果子类Son也有一个相同的静态方法getName(),则使用 Son son = new Son(), son.getName(),调用的是子类中的getName(),如果将子类中的getName()去掉,则会调用Father中的getName()方法,相当于子类将父类的方法给隐藏掉了,但是这个规则不适合于多态情况,比如Father father = new Son(),此时father.getName()是属于静态多分派在编译器就确定了方法调用肯定是父类的,希望你能明白","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1568086529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1104287,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d9/9f/7b2f2a97.jpg","nickname":"师爷","note":"","ucode":"20E6831DABF755","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1254864,"avatar":"https://static001.geekbang.org/account/avatar/00/13/25/d0/3d5696d8.jpg","nickname":"无嘴小呆子","note":"","ucode":"4165B025F20929","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335047,"discussion_content":"非静态不也是这样么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608079761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":8868,"ip_address":""},"score":335047,"extra":""},{"author":{"id":1702886,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fb/e6/1b9edb91.jpg","nickname":"练习生","note":"","ucode":"60203A2AA0EA36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1254864,"avatar":"https://static001.geekbang.org/account/avatar/00/13/25/d0/3d5696d8.jpg","nickname":"无嘴小呆子","note":"","ucode":"4165B025F20929","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337737,"discussion_content":"你说的Father father = new Son()这个例子，确实是对的。但是感觉和非接口符号引用替换为真实引用的过程冲突了，按照文章说会先去Son类中查找符合条件的方法。请问是我哪里理解的有偏差吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609065271,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":8868,"ip_address":""},"score":337737,"extra":""}]},{"author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41524,"discussion_content":"我觉得就是通过符号引用查找的时候找不到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572445133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1115724,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLwSoTjHPX5tm4whBSfoZLX6toZxrZGUaLABQywKNf4MDc9toK3QSV7Z99ATcGicFCysoleQ5ISzmw/132","nickname":"乘风","note":"","ucode":"0420C5535DACB7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1592,"discussion_content":"如果父类的静态方法在子类中也有签名的静态方法，则在编译阶段其符号引用指向的就是子类","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562723350,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31357,"user_name":"xzy","can_delete":false,"product_type":"c1","uid":1002095,"ip_address":"","ucode":"1A44368083A19E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/6f/e36b3908.jpg","comment_is_top":false,"comment_ctime":1539158448,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"27308962224","product_id":100010301,"comment_content":"符号引用转实际引用时，对于非接口符号引用的第三条，在该类及父类中没有找到目标方法，便会在其直接和间接实现的接口中查找。如果存在多个符合条件的方法，并不会随机选择一个，而是优先选择拥有最具体实现的默认方法的接口，即如果 B 继承了 A，那么 B 就比 A 更加具体。代码如下：<br> interface A {<br>\tdefault void hello() {<br>\t\tSystem.out.println(&quot;Hello form A&quot;);<br>\t}<br>}<br>interface B extends A {<br>\tdefault void hello() {<br>\t\tSystem.out.println(&quot;Hello from B&quot;);<br>\t}<br>}<br>public class C implements A,B {<br>\tpublic static void main(String[] args) {<br>\t\tnew C().hello();   &#47;&#47;输出 Hello from B<br>\t}<br>}<br><br>在 java 里如果无法判断谁更具体，则需要在 C 里面显示的覆盖 hello（）方法。","like_count":6,"discussions":[{"author":{"id":1460942,"avatar":"https://static001.geekbang.org/account/avatar/00/16/4a/ce/affe4307.jpg","nickname":"叫啥不行","note":"","ucode":"A84B9B6594BF35","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296816,"discussion_content":"老师意思是不是虚拟机是随机的，但java编译不会通过，有没有大佬知道。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596673547,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1174379,"avatar":"https://static001.geekbang.org/account/avatar/00/11/eb/6b/544c7ab2.jpg","nickname":"E = mc ²","note":"","ucode":"85E42DBC341AA8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1460942,"avatar":"https://static001.geekbang.org/account/avatar/00/16/4a/ce/affe4307.jpg","nickname":"叫啥不行","note":"","ucode":"A84B9B6594BF35","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":395375,"discussion_content":"我试了下用 ASM 生成一个实现了两个 B 同级别的接口，可以加载但是执行会报错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632296191,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":296816,"ip_address":""},"score":395375,"extra":""}]}]},{"had_liked":false,"id":17659,"user_name":"永烁星光","can_delete":false,"product_type":"c1","uid":1119617,"ip_address":"","ucode":"D26A9097F9D24C","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/81/2c31cf79.jpg","comment_is_top":false,"comment_ctime":1532851316,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"27302655092","product_id":100010301,"comment_content":"唯一的例外在于，如果虚拟机能够确定目标方法有且仅有一个，比如说目标方法被标记为 final[3][4]<br>请问这里的final[3][4] 是什么意思","like_count":6,"discussions":[{"author":{"id":1101491,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ce/b3/804aa247.jpg","nickname":"大熊","note":"","ucode":"DBD3FEE0AA6DB6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327836,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605965750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1702886,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fb/e6/1b9edb91.jpg","nickname":"练习生","note":"","ucode":"60203A2AA0EA36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1101491,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ce/b3/804aa247.jpg","nickname":"大熊","note":"","ucode":"DBD3FEE0AA6DB6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337741,"discussion_content":"[3][4]指的是文章末尾的引用文章的索引标注","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1609065921,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":327836,"ip_address":""},"score":337741,"extra":""}]}]},{"had_liked":false,"id":201991,"user_name":"靠人品去赢","can_delete":false,"product_type":"c1","uid":1301286,"ip_address":"","ucode":"7A20F9EBE847E1","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/26/54f2c164.jpg","comment_is_top":false,"comment_ctime":1585885227,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"23060721707","product_id":100010301,"comment_content":"我先来说一下桥接方法这个概念，为什么有桥接方法，因为泛型的缘故。<br>实际上我们，泛型这个类型有点特殊，虽然是Java两大类型中的基本类型引用类型中的引用类型的一种，但世界，也就是JVM会产生，最后还是会“泛型擦除”，变成Object，妥妥的工具人。<br>问题来了，使用泛型会涉及到一个双亲委派，那一个方法可能会调用父类的那咋办，中间会用一个方法，同名的来做个桥，用这个桥接方法在调用子类的实际方法。<br><br>父类接口----桥接方法-----子类实际方法<br>这样即使是泛型也不至于因为摩擦成了Object，返回的也是Object。也是为什么IDE上会有Override提示，因为是桥接方法而来，可以看作一个机制吧<br>","like_count":5,"discussions":[{"author":{"id":1702886,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fb/e6/1b9edb91.jpg","nickname":"练习生","note":"","ucode":"60203A2AA0EA36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337747,"discussion_content":"除了 父类接口----桥接方法-----子类实际方法这句话 其他没看明白","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609068412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":19694,"user_name":"曲东方","can_delete":false,"product_type":"c1","uid":1177819,"ip_address":"","ucode":"6C3EA2F47A0B98","user_header":"https://static001.geekbang.org/account/avatar/00/11/f8/db/c4edf697.jpg","comment_is_top":false,"comment_ctime":1533974461,"is_pvip":false,"replies":[{"id":"7071","content":"1 对的，为了保证重写语义。<br>2 生成的桥接方法还有一个acc_synthetic标记，代表对程序不可见。因此javac不能直接选取那个方法。","user_name":"作者回复","comment_id":19694,"uid":"1176688","ip_address":"","utype":1,"ctime":1534328749,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"23008810941","product_id":100010301,"comment_content":"Merchant类中actionPrice方法返回值类型为Number<br>NaiveMerchant类中actionPrice方法返回值类型为Double<br><br>NaiveMerchant类生成的字节码中有两个参数类型相同返回值类型不同的actionPrice方法<br> Method actionPrice:(DLCustomer;)Ljava&#47;lang&#47;Double;<br> Method actionPrice:(DLCustomer;)Ljava&#47;lang&#47;Number; &#47;&#47; 桥接到返回值为double的方法 flags: ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC<br><br> 方法返回值不同为何也要产生桥接方法呢？ 为了保证重写语义？<br><br>不知为何javac在编译<br><br>NaiveMerchant naiveMerchant = new NaiveMerchant();<br>Number number = naiveMerchant.actionPrice(1d, null) &#47;&#47; 特意要求Number类型的返回值(方法描述符)<br><br>时，总invokevirtual到Method NaiveMerchant.actionPrice:(DLCustomer;)Ljava&#47;lang&#47;Double，这又是为什么呢？<br><br>附jdk版本<br>java version &quot;1.8.0_172&quot;<br>Java(TM) SE Runtime Environment (build 1.8.0_172-b11)<br>GraalVM 1.0.0-rc5 (build 25.71-b01-internal-jvmci-0.46, mixed mode)<br><br><br>","like_count":6,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421942,"discussion_content":"1 对的，为了保证重写语义。\n2 生成的桥接方法还有一个acc_synthetic标记，代表对程序不可见。因此javac不能直接选取那个方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534328749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":17495,"user_name":"vimfun","can_delete":false,"product_type":"c1","uid":1007359,"ip_address":"","ucode":"EAB2281FC0552A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/ff/295bcf2c.jpg","comment_is_top":false,"comment_ctime":1532686182,"is_pvip":false,"replies":[{"id":"6080","content":"静态方法都是静态绑定。调用的目标方法是public final 的话，HotSpot虚拟机也会静态绑定。但这属于优化，其它虚拟机不一定这么做。","user_name":"作者回复","comment_id":17495,"uid":"1176688","ip_address":"","utype":1,"ctime":1532705695,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"23007522662","product_id":100010301,"comment_content":"老师，public final 或 public static final 的方法，是不是在 虚拟机中解析为静态绑定的","like_count":5,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421178,"discussion_content":"静态方法都是静态绑定。调用的目标方法是public final 的话，HotSpot虚拟机也会静态绑定。但这属于优化，其它虚拟机不一定这么做。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1532705695,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":19223,"user_name":"Kenneth","can_delete":false,"product_type":"c1","uid":1183069,"ip_address":"","ucode":"AF46C8EEBDA3D0","user_header":"https://static001.geekbang.org/account/avatar/00/12/0d/5d/e50cf9c7.jpg","comment_is_top":false,"comment_ctime":1533720519,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"18713589703","product_id":100010301,"comment_content":"老师你好，课后的例子编译不通过，提示有重复的类Merchant，另外，提示找不到类VIP。可以指导一下，课后的练习题的具体操作教程吗？非常感谢🙏！","like_count":4,"discussions":[{"author":{"id":1564267,"avatar":"https://static001.geekbang.org/account/avatar/00/17/de/6b/adee88bb.jpg","nickname":"宿臾洛城","note":"","ucode":"362CC728E256F7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":280054,"discussion_content":"这个确实是基础的问题。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591463575,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41526,"discussion_content":"我想说下，这说明你的基础有问题，其实就是两个 java 文件，你要像平时创建普通的 java 类那样才行。。不是直接复制粘贴。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572445217,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1183069,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0d/5d/e50cf9c7.jpg","nickname":"Kenneth","note":"","ucode":"AF46C8EEBDA3D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":208722,"discussion_content":"谢谢你基础没问题的大佬，键盘很香呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584578013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":41526,"ip_address":""},"score":208722,"extra":""},{"author":{"id":1059674,"avatar":"","nickname":"三行","note":"","ucode":"3BBEA32B643538","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":210879,"discussion_content":"大佬，有个问题，问一下，接口符号引用和非接口符号引用是对于静态绑定而言，还是对于静态绑定和动态绑定都是使用这种方式的呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584786944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":41526,"ip_address":""},"score":210879,"extra":""},{"author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1183069,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0d/5d/e50cf9c7.jpg","nickname":"Kenneth","note":"","ucode":"AF46C8EEBDA3D0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":221682,"discussion_content":"我貌似是回复错了楼层。。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586046380,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":208722,"ip_address":""},"score":221682,"extra":""}]}]},{"had_liked":false,"id":17573,"user_name":"曲东方","can_delete":false,"product_type":"c1","uid":1177819,"ip_address":"","ucode":"6C3EA2F47A0B98","user_header":"https://static001.geekbang.org/account/avatar/00/11/f8/db/c4edf697.jpg","comment_is_top":false,"comment_ctime":1532754164,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18712623348","product_id":100010301,"comment_content":"好顶赞👍","like_count":4},{"had_liked":false,"id":17509,"user_name":"杨春鹏","can_delete":false,"product_type":"c1","uid":1172056,"ip_address":"","ucode":"518F38232F97B5","user_header":"https://static001.geekbang.org/account/avatar/00/11/e2/58/8c8897c8.jpg","comment_is_top":false,"comment_ctime":1532694501,"is_pvip":false,"replies":[{"id":"6074","content":"多谢指出！这里我指的是使用super关键字调用所实现接口的默认方法。","user_name":"作者回复","comment_id":17509,"uid":"1176688","ip_address":"","utype":1,"ctime":1532705182,"user_name_real":"郑雨迪"}],"discussion_count":3,"race_medal":0,"score":"18712563685","product_id":100010301,"comment_content":"老师，关于方法调用的字节码指令中的invokespecial:调用实现接口的默认方法。<br>我测试了一下，发现子类中调用实现接口的默认方法还是使用的invokeinrerface。<br>","like_count":4,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421183,"discussion_content":"多谢指出！这里我指的是使用super关键字调用所实现接口的默认方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1532705182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1702886,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fb/e6/1b9edb91.jpg","nickname":"练习生","note":"","ucode":"60203A2AA0EA36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337745,"discussion_content":"刚试了，确实这样。之前没看出来这个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609067883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41530,"discussion_content":"我了歌曲～～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572446364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":54046,"user_name":"Nevermore","can_delete":false,"product_type":"c1","uid":1228011,"ip_address":"","ucode":"06EBD2E6A9B436","user_header":"https://static001.geekbang.org/account/avatar/00/12/bc/eb/c22ef3a5.jpg","comment_is_top":false,"comment_ctime":1545789013,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10135723605","product_id":100010301,"comment_content":"由于对重载方法的区分在编译阶段已经完成，我们可以认为 Java 虚拟机不存在重载这一概念。<br><br>为什么这么说？编译阶段和虚拟机有什么联系？","like_count":2,"discussions":[{"author":{"id":1179403,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ff/0b/346b4aa6.jpg","nickname":"Co","note":"","ucode":"9896E67C6047AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":14568,"discussion_content":"我觉得是从方法描述符来说的，重载的话，参数是一定不一样的，这样的话方法参数符就是唯一的了，这样虚拟机能够确定唯一位置，多个重载对虚拟机来说就是多个不同的方法了（对虚拟机来说意味着没用重载，全都是不同的方法）。重写的话是参数和返回类型一样（方法描述符一样），只有类是不一样的，这样就可以认定是重写了","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1568771562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1115724,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLwSoTjHPX5tm4whBSfoZLX6toZxrZGUaLABQywKNf4MDc9toK3QSV7Z99ATcGicFCysoleQ5ISzmw/132","nickname":"乘风","note":"","ucode":"0420C5535DACB7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1594,"discussion_content":"因为针对方法私有重载而言，其方法参数类型已经固定，在静态编译时期就可以通过编译来确定其唯一地址，而针对于非私有重载而言，这是重写了--所以从JVM层面理解不存在重载，我是这样理解的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1562723508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":46910,"user_name":"小乙哥","can_delete":false,"product_type":"c1","uid":1063308,"ip_address":"","ucode":"C77E79BEA0C325","user_header":"https://static001.geekbang.org/account/avatar/00/10/39/8c/089525aa.jpg","comment_is_top":false,"comment_ctime":1544000230,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10133934822","product_id":100010301,"comment_content":"类名，方法名，参数名可以不用中午吗？","like_count":2},{"had_liked":false,"id":24171,"user_name":"石妖","can_delete":false,"product_type":"c1","uid":1230322,"ip_address":"","ucode":"C6DD9EFEDD2416","user_header":"https://static001.geekbang.org/account/avatar/00/12/c5/f2/fccf87bb.jpg","comment_is_top":false,"comment_ctime":1536829112,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10126763704","product_id":100010301,"comment_content":"对于Java编译器选取重载方法的第一个规则不太明白：<br>public static void invoke(String s, int i, Object... args) {<br>    System.out.println(&quot;无装拆箱&quot; + i);<br>}<br><br>public static void invoke(String s, Object obj, Object... args) {<br>    System.out.println(&quot;object类型参数&quot; + obj);<br>}<br>执行如下调用时：<br>    int i = 2;<br>    invoke(null, i);<br>为什么会报引用不明确的错误？根据第一个规则，应该匹配第一个方法的呀？","like_count":2,"discussions":[{"author":{"id":1702886,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fb/e6/1b9edb91.jpg","nickname":"练习生","note":"","ucode":"60203A2AA0EA36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337767,"discussion_content":"改成这样的话 会调用第一个方法\npublic static void invoke( int i) {\n        System.out.println(&#34;无装拆箱&#34; + i);\n    }\n\n    public static void invoke(Object obj, Object... args) {\n        System.out.println(&#34;object类型参数&#34; + obj);\n    }\n\n    public static void main(String[] args) {\n        invoke(1);\n    }\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609072282,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1702886,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fb/e6/1b9edb91.jpg","nickname":"练习生","note":"","ucode":"60203A2AA0EA36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337766,"discussion_content":"我刚用JDK8试了 编译报错 对invoke的引用不明确的异常\n\njava: 对invoke的引用不明确\n  方法invoke(java.lang.String,int,java.lang.Object...) 和方法 invoke(java.lang.String,java.lang.Object,java.lang.Object...) 都匹配","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609072100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":18217,"user_name":"lxz","can_delete":false,"product_type":"c1","uid":1182582,"ip_address":"","ucode":"D0FE6660E62BC2","user_header":"https://static001.geekbang.org/account/avatar/00/12/0b/76/e5ffbdf1.jpg","comment_is_top":false,"comment_ctime":1533195315,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10123129907","product_id":100010301,"comment_content":"接口的符号引用这部分没看懂，字节码确实是能看到invokeinterface指向了接口的方法，但是实际执行的时候，是怎么做的呢，应该执行具体实现类的字节码啊。<br>另外，一个小问题，方法字节码code段内，有些类似行号的数字，在每行开头，后面跟着一个冒号，是什么意思，是行号吗？","like_count":2},{"had_liked":false,"id":17516,"user_name":"L.B.Q.Y","can_delete":false,"product_type":"c1","uid":1069325,"ip_address":"","ucode":"5567989D1CDBBE","user_header":"https://static001.geekbang.org/account/avatar/00/10/51/0d/14d9364a.jpg","comment_is_top":false,"comment_ctime":1532701975,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10122636567","product_id":100010301,"comment_content":"开篇例子中的invoke(null,1)之所以选择第二个invoke()，按照重载方法选择三步骤的布骤二，不考虑变长参数但是考虑基本类型的拆装箱，正好匹配第二个invoke.<br>而invoke(null,1,2)按照重载方法选择三步骤的步骤三，两个invoke方法都匹配，考虑类型的继承关系，第二个invoke更恰当。","like_count":2},{"had_liked":false,"id":17415,"user_name":"陈树义","can_delete":false,"product_type":"c1","uid":1076264,"ip_address":"","ucode":"AF83C4BDC192B5","user_header":"https://static001.geekbang.org/account/avatar/00/10/6c/28/a1f9f0ad.jpg","comment_is_top":false,"comment_ctime":1532625762,"is_pvip":true,"replies":[{"id":"6073","content":"我在java8和java10里测得的都一样","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1532704409,"ip_address":"","comment_id":17415,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10122560354","product_id":100010301,"comment_content":"文章开头的例子，我在JDK8环境下写了个例子测试，发现貌似和文中所说的不一致。  不知道是不是因为JDK版本问题，还是我例子有问题？  ","like_count":2,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421144,"discussion_content":"我在java8和java10里测得的都一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1532704409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263624,"user_name":"程序员小跃","can_delete":false,"product_type":"c1","uid":1015483,"ip_address":"","ucode":"25BB96E0791A60","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","comment_is_top":false,"comment_ctime":1606200625,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5901167921","product_id":100010301,"comment_content":"基本的都懂，但是涉及到一些深层次的就需要多看几遍，坚持把它给啃了。课程买了挺久了，算是给之前还债来啦","like_count":1},{"had_liked":false,"id":212729,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1588204236,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5883171532","product_id":100010301,"comment_content":"对jvm略有了解，讲的晦涩难懂，读一半就不想继续了，我记得那本深入理解java虚拟机没这么难读啊，再重头看一遍","like_count":1,"discussions":[{"author":{"id":1148422,"avatar":"https://static001.geekbang.org/account/avatar/00/11/86/06/72b01bb7.jpg","nickname":"美美","note":"","ucode":"44CC95C45AF345","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286593,"discussion_content":"那本书和这个讲的还不太一样，这篇文章还是没那么细","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593239286,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":191655,"user_name":"三行","can_delete":false,"product_type":"c1","uid":1059674,"ip_address":"","ucode":"3BBEA32B643538","user_header":"","comment_is_top":false,"comment_ctime":1584786956,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879754252","product_id":100010301,"comment_content":"大佬们，有个问题，问一下，接口符号引用和非接口符号引用是对于静态绑定而言，还是对于静态绑定和动态绑定都是使用这种方式的呢？","like_count":1},{"had_liked":false,"id":123726,"user_name":"星期八","can_delete":false,"product_type":"c1","uid":1185504,"ip_address":"","ucode":"34A37F73A48E7F","user_header":"https://static001.geekbang.org/account/avatar/00/12/16/e0/7abad3cc.jpg","comment_is_top":false,"comment_ctime":1565747899,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5860715195","product_id":100010301,"comment_content":"老师：静态内部类的单例模式中  public static SingleTon getInstance(){<br>    return SingleTonHoler.INSTANCE;<br>  }的这个方法，需要加final关键字吗，我觉得是不需要，因为调用内部类，只会被初始化一次，所以即使重载了这个方法，获取应该还是单例的吧","like_count":1},{"had_liked":false,"id":88400,"user_name":"小鱼儿","can_delete":false,"product_type":"c1","uid":1003391,"ip_address":"","ucode":"39CD8C85A1318F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4f/7f/8b486756.jpg","comment_is_top":false,"comment_ctime":1555916192,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5850883488","product_id":100010301,"comment_content":"&quot;从这个解析算法可以看出,静态方法也可以通过子类来调用&quot;   老师这个能解释下吗？我没看出来....","like_count":1},{"had_liked":false,"id":80622,"user_name":"Junzi","can_delete":false,"product_type":"c1","uid":1004612,"ip_address":"","ucode":"4AC663769C1873","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/44/4e541a86.jpg","comment_is_top":false,"comment_ctime":1553690018,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5848657314","product_id":100010301,"comment_content":"Java语言中，重写要求：<br>1. 方法名相同<br>2. 入参个数和类型相同<br>3. 返回值类型与父类返回值类型相同，或者是父类方法返回值类型的子类。如例子中Double是Number的子类<br><br>Java虚拟机对重写要求:<br>1. 方法名相同<br>2. 入参个数和类型相同<br>3. 返回值类型相同<br><br>由于JVM规范中的重写与Java语言层面的重写语义不一致，为了保持重写语义的一致，JVM通过桥接的方式实现Java语言层面的重写。不然我Java代码明明重写了，但代码实际运行不是重写的结果。","like_count":1,"discussions":[{"author":{"id":1702886,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fb/e6/1b9edb91.jpg","nickname":"练习生","note":"","ucode":"60203A2AA0EA36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337759,"discussion_content":"桥接方法是编译器生成的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609071410,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":47330,"user_name":"小兵","can_delete":false,"product_type":"c1","uid":1261674,"ip_address":"","ucode":"AA3BA727C25179","user_header":"https://static001.geekbang.org/account/avatar/00/13/40/6a/ab1cf396.jpg","comment_is_top":false,"comment_ctime":1544108500,"is_pvip":false,"replies":[{"id":"16981","content":"接口的default方法，可能这样写比较清楚些","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1544176817,"ip_address":"","comment_id":47330,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5839075796","product_id":100010301,"comment_content":"invokespecial：用于调用私有实例方法、构造器，以...和所实现接口的默认方法。<br>这里所实现接口的默认方法具体是指什么？<br>","like_count":1,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431739,"discussion_content":"接口的default方法，可能这样写比较清楚些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544176817,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1702886,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fb/e6/1b9edb91.jpg","nickname":"练习生","note":"","ucode":"60203A2AA0EA36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337760,"discussion_content":"jdk8 中接口允许使用default关键字定义默认方法。当使用super调用父类实现或间接实现的接口的默认方法时，对应底层方法调用的字节码是invokespecial","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609071628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35318,"user_name":"王侦","can_delete":false,"product_type":"c1","uid":1244727,"ip_address":"","ucode":"37B0A077A7E46E","user_header":"https://static001.geekbang.org/account/avatar/00/12/fe/37/ba1bebc0.jpg","comment_is_top":false,"comment_ctime":1540516729,"is_pvip":false,"replies":[{"id":"12767","content":"多个文件。我这边代码实际上是分开的，上传时合成一个代码框了。回头我改一下。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1540823610,"ip_address":"","comment_id":35318,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5835484025","product_id":100010301,"comment_content":"老师，最后那个例子能不能重新整理一下？说明一下操作步骤。不知道怎么操作！是写在一个文件还是多个文件？而且编译时报两个错误：一个是VIP要有一个类，一个是NaiveMerchant报错？","like_count":1,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427512,"discussion_content":"多个文件。我这边代码实际上是分开的，上传时合成一个代码框了。回头我改一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540823610,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":27022,"user_name":"zhaomengsen1","can_delete":false,"product_type":"c1","uid":1251830,"ip_address":"","ucode":"96561091A9610F","user_header":"https://static001.geekbang.org/account/avatar/00/13/19/f6/72e98a61.jpg","comment_is_top":false,"comment_ctime":1537799541,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5832766837","product_id":100010301,"comment_content":"public class T1 extends T {<br>\t<br>public\tstatic void tt() {<br>\t\tSystem.out.println(&quot;T1&quot;);<br>\t\tT.tt();<br>\t\t<br>\t}<br>\tpublic static void main(String[] args) {<br>\t\tT1.tt();<br>\t\t&#47;&#47;tt();<br>\t}<br>}<br><br>&#47;&#47;结果<br>T1<br>T <br>子类可以调用父类方法","like_count":1},{"had_liked":false,"id":24908,"user_name":"Go Ashton","can_delete":false,"product_type":"c1","uid":1189704,"ip_address":"","ucode":"D435BB37BE8B37","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/48/f793d74d.jpg","comment_is_top":false,"comment_ctime":1537229762,"is_pvip":true,"replies":[{"id":"9157","content":"C implements Interface1，Interface1 extends Interface2，C直接实现Interface1，间接实现Interface2。<br><br>如果你知道更加通用的叫法，麻烦留言告诉我哈","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1537259743,"ip_address":"","comment_id":24908,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5832197058","product_id":100010301,"comment_content":"如果没有找到，在 C 所直接实现或间接实现的接口中搜索” 能否有个例子，什么是直接实现？什么是间接实现？ 可能我知道这是什么，但叫法不同","like_count":1,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424132,"discussion_content":"C implements Interface1，Interface1 extends Interface2，C直接实现Interface1，间接实现Interface2。\n\n如果你知道更加通用的叫法，麻烦留言告诉我哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537259743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1702886,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fb/e6/1b9edb91.jpg","nickname":"练习生","note":"","ucode":"60203A2AA0EA36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337763,"discussion_content":"间接实现还包括C extends B ,B implements Interface1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609071781,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20444,"user_name":"Tom","can_delete":false,"product_type":"c1","uid":1128565,"ip_address":"","ucode":"6CED326ED9F0CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/38/75/6ab62df4.jpg","comment_is_top":false,"comment_ctime":1534446941,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5829414237","product_id":100010301,"comment_content":"对于继承关系中的隐藏和重写还是不太理解，到底在哪里他们是有区别的呢？因为在调用中根本无法清楚隐藏到底是个什么概念，是在字节码文件中还是指令中有些许区别呢？感受不到区别","like_count":1,"discussions":[{"author":{"id":1702886,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fb/e6/1b9edb91.jpg","nickname":"练习生","note":"","ucode":"60203A2AA0EA36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337769,"discussion_content":"隐藏没有多态，重写有多态的特性。\n比如Son ，Father两个类都定义相同的静态方法，Father f= new Son();f.invoke()调用的Father的静态方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609072587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":19930,"user_name":"包子","can_delete":false,"product_type":"c1","uid":1089345,"ip_address":"","ucode":"6CC4EBB8CD3924","user_header":"https://static001.geekbang.org/account/avatar/00/10/9f/41/82306dfe.jpg","comment_is_top":false,"comment_ctime":1534166243,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5829133539","product_id":100010301,"comment_content":"Java识别方法是在java代码——&gt;字节流class编译阶段的。<br>Jvm识别方法是在字节码class——&gt;机器码阶段的。也就是加载，链接，初始化","like_count":1},{"had_liked":false,"id":19420,"user_name":"陈勇明","can_delete":false,"product_type":"c1","uid":1179132,"ip_address":"","ucode":"2413F7D25AF22A","user_header":"https://static001.geekbang.org/account/avatar/00/11/fd/fc/0a9ec89f.jpg","comment_is_top":false,"comment_ctime":1533820435,"is_pvip":false,"replies":[{"id":"6795","content":"就是C1.m()调用不到C.m()了。如果C1没有定义m()，那么用C1.m()可以调用C.m()","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1533900783,"ip_address":"","comment_id":19420,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5828787731","product_id":100010301,"comment_content":"如果这两个方法都是静态的，那么子类中的方法隐藏了父类中的方法，这里的隐藏是什么意思？父类的方法调用不到了吗？类C及子类C1都有静态方法m,那么C.m()与C.m()，以及这两个类的实例调用该方法应该都互不影响吧","like_count":1,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421834,"discussion_content":"就是C1.m()调用不到C.m()了。如果C1没有定义m()，那么用C1.m()可以调用C.m()","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1533900783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":17653,"user_name":"安小依","can_delete":false,"product_type":"c1","uid":1101660,"ip_address":"","ucode":"A5C414C7B994FF","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/5c/d4e19eb6.jpg","comment_is_top":false,"comment_ctime":1532842080,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5827809376","product_id":100010301,"comment_content":"对 null 强转类型至 Object 或者 String ，可以灵活控制调用第一个还是第二个函数。","like_count":1},{"had_liked":false,"id":17413,"user_name":"瑜斌","can_delete":false,"product_type":"c1","uid":1178756,"ip_address":"","ucode":"171FAF5736F334","user_header":"https://static001.geekbang.org/account/avatar/00/11/fc/84/9f8afa9b.jpg","comment_is_top":false,"comment_ctime":1532623902,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5827591198","product_id":100010301,"comment_content":"沙发！","like_count":1},{"had_liked":false,"id":343435,"user_name":"苏成","can_delete":false,"product_type":"c1","uid":2668694,"ip_address":"","ucode":"80A8E7B243DD73","user_header":"https://static001.geekbang.org/account/avatar/00/28/b8/96/716ba431.jpg","comment_is_top":false,"comment_ctime":1650852766,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1650852766","product_id":100010301,"comment_content":"不太适合初学者，但是专栏的整体框架不错，带着专栏的问题去看《深入理解JAVA虚拟机》挺不错的","like_count":0},{"had_liked":false,"id":337149,"user_name":"フォドラの暁風","can_delete":false,"product_type":"c1","uid":1702502,"ip_address":"","ucode":"609C59A2D2B4B1","user_header":"https://static001.geekbang.org/account/avatar/00/19/fa/66/1edbfe83.jpg","comment_is_top":false,"comment_ctime":1646647037,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646647037","product_id":100010301,"comment_content":"我觉得用中文还挺好的，加深记忆","like_count":0},{"had_liked":false,"id":336442,"user_name":"כן אני אמריקאי","can_delete":false,"product_type":"c1","uid":1527429,"ip_address":"","ucode":"56C5C2B369121B","user_header":"https://static001.geekbang.org/account/avatar/00/17/4e/85/ef0108cd.jpg","comment_is_top":false,"comment_ctime":1646146772,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646146772","product_id":100010301,"comment_content":"JVM系列之：JVM如何执行方法调用（https:&#47;&#47;juejin.cn&#47;post&#47;7069628730452213797）","like_count":0},{"had_liked":false,"id":313156,"user_name":"E = mc ²","can_delete":false,"product_type":"c1","uid":1174379,"ip_address":"","ucode":"85E42DBC341AA8","user_header":"https://static001.geekbang.org/account/avatar/00/11/eb/6b/544c7ab2.jpg","comment_is_top":false,"comment_ctime":1632298937,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632298937","product_id":100010301,"comment_content":"非接口符号引用的查找步骤第三点<br>如果没有找到，在 C 所直接实现或间接实现的接口中搜索，这一步搜索得到的目标方法必须是非私有、非静态的。并且，如果目标方法在间接实现的接口中，则需满足 C 与该接口之间没有其他符合条件的目标方法。如果有多个符合条件的目标方法，则任意返回其中一个。<br><br>D extends C implements B    C implements A（不重写 A 接口的默认方法）    B implements A  （重写 A 的 默认方法） 这样 D  还是会调 B 的方法不会调 A 的，没有懂最后所说的如果有多个符合条件的目标方法，任意返回一个，任意的逻辑是怎么样的还有按照一定的逻辑返回最先找到的","like_count":0},{"had_liked":false,"id":307210,"user_name":"ppyh","can_delete":false,"product_type":"c1","uid":1351148,"ip_address":"","ucode":"14022ADEC9B53F","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/ec/235b74c0.jpg","comment_is_top":false,"comment_ctime":1628936981,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628936981","product_id":100010301,"comment_content":"确实都是精华，但需要多读几遍","like_count":0},{"had_liked":false,"id":299059,"user_name":"滴答丶滴","can_delete":false,"product_type":"c1","uid":1181206,"ip_address":"","ucode":"2093C2948B4327","user_header":"https://static001.geekbang.org/account/avatar/00/12/06/16/e85c1fa8.jpg","comment_is_top":false,"comment_ctime":1624444083,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1624444083","product_id":100010301,"comment_content":"这里为什么说是&quot;子类的静态方法会隐藏父类中的同名，同描述符的静态方法&quot;，A a = new B()；这里调用同名同描述符的静态方法，调用的是A的静态方法呀,这是怎么回事???<br>同样B b = new B();调用的是B的静态方法<br><br>代码如下: <br>public class B extends A{<br>    static int g(int n){<br>        int m = A.g(n);<br>        &#47;&#47; 9 + 3 = 12<br>        return m+n;<br>    }<br>}<br><br>public class A {<br>    static int g(int n){<br>        &#47;&#47; 9<br>        return n*n;<br>    }<br>}<br><br>","like_count":0,"discussions":[{"author":{"id":1645411,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eriauykjnzG06SILWiaPJCM6wtj1a3FyGCjrm020aQDEaKCDZrEiaDexicrM3EPgkBJfdrlzsF0wJs4TA/132","nickname":"Geek_13f7a6","note":"","ucode":"776737FF0EA22E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380373,"discussion_content":"如果B没有定义g() B.g()会调到A的g() B定义了g() 则不会调到A的g()","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624459558,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":298989,"user_name":"滴答丶滴","can_delete":false,"product_type":"c1","uid":1181206,"ip_address":"","ucode":"2093C2948B4327","user_header":"https://static001.geekbang.org/account/avatar/00/12/06/16/e85c1fa8.jpg","comment_is_top":false,"comment_ctime":1624417098,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624417098","product_id":100010301,"comment_content":"在编译过程中，我们并不知道目标方法的具体内存地址。因此，Java 编译器会暂时用符号引用来表示该目标方法。这一符号引用包括目标方法所在的类或接口的名字，以及目标方法的方法名和方法描述符<br><br>这句话的&quot;我们&quot;指的是JVM还是JAVA编译器呀?","like_count":0},{"had_liked":false,"id":289332,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1618978720,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1618978720","product_id":100010301,"comment_content":"为什么调用指令有5种呢？不能一种解决的原因是什么呢？","like_count":0},{"had_liked":false,"id":281687,"user_name":"守望者","can_delete":false,"product_type":"c1","uid":1623487,"ip_address":"","ucode":"DEE375A5F2D57A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/sPORo6cN3GSVxjHj9nqSAPn7KG4wtSTqNUommjNndpf8qd7bHKHquuldXZfxD5nF1ldy4LeoAQNwSsOgcmWG9w/132","comment_is_top":false,"comment_ctime":1614847653,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614847653","product_id":100010301,"comment_content":"编译器确定五种方法调用指令的具体规则是怎样的？有大佬可以提供这方面的知识介绍吗?","like_count":0},{"had_liked":false,"id":254648,"user_name":"为光","can_delete":false,"product_type":"c1","uid":1907362,"ip_address":"","ucode":"70E21C9BA5B791","user_header":"https://static001.geekbang.org/account/avatar/00/1d/1a/a2/8484b2cf.jpg","comment_is_top":false,"comment_ctime":1603161835,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603161835","product_id":100010301,"comment_content":"把一个部分反反复复看了很多遍，终于懂了，真好","like_count":0},{"had_liked":false,"id":248608,"user_name":"妥协","can_delete":false,"product_type":"c1","uid":1249656,"ip_address":"","ucode":"7201DFE9C12669","user_header":"https://static001.geekbang.org/account/avatar/00/13/11/78/4f0cd172.jpg","comment_is_top":false,"comment_ctime":1600240910,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600240910","product_id":100010301,"comment_content":"请教老师，动态代理，是只对需要动态绑定的方法调用生效吗？？本来调用目标方法的调用，如何变成调用代理对象的方法了？？","like_count":0},{"had_liked":false,"id":246643,"user_name":"信了","can_delete":false,"product_type":"c1","uid":1368648,"ip_address":"","ucode":"EA188A1DD1D390","user_header":"https://static001.geekbang.org/account/avatar/00/14/e2/48/6c066714.jpg","comment_is_top":false,"comment_ctime":1599445282,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599445282","product_id":100010301,"comment_content":"如果invokespecial是使用super调用父类的非私有方法，但是父类的非私有方法也是有可能会重写父类的父类方法，这种情况也是无法识别到具体的目标方法呢？","like_count":0},{"had_liked":false,"id":242595,"user_name":"xmeng","can_delete":false,"product_type":"c1","uid":1731543,"ip_address":"","ucode":"C0CA2182BA3B4B","user_header":"https://static001.geekbang.org/account/avatar/00/1a/6b/d7/8872624a.jpg","comment_is_top":false,"comment_ctime":1597794196,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1597794196","product_id":100010301,"comment_content":"隐藏父类的静态方法如何理解？<br><br>可以这样理解,父类Father中有一个静态方法getName(),如果子类Son也有一个相同的静态方法getName(),则使用 Son son = new Son(), son.getName(),调用的是子类中的getName(),如果将子类中的getName()去掉,则会调用Father中的getName()方法,相当于子类将父类的方法给隐藏掉了,但是这个规则不适合于多态情况,比如Father father = new Son(),此时father.getName()是属于静态多分派在编译器就确定了方法调用肯定是父类的,希望你能明白","like_count":0},{"had_liked":false,"id":223488,"user_name":"海无语","can_delete":false,"product_type":"c1","uid":1308200,"ip_address":"","ucode":"0BCBDC09283C0F","user_header":"https://static001.geekbang.org/account/avatar/00/13/f6/28/96e030aa.jpg","comment_is_top":false,"comment_ctime":1591101105,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591101105","product_id":100010301,"comment_content":"作可能太拘泥于细节了，看出作者一直努力想描述清楚那个抽象的世界","like_count":0},{"had_liked":false,"id":202135,"user_name":"不似旧日","can_delete":false,"product_type":"c1","uid":1161271,"ip_address":"","ucode":"DF4C5E3AB9570C","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","comment_is_top":false,"comment_ctime":1585907618,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585907618","product_id":100010301,"comment_content":"以前以为调用重载方法时,要判断参数  这样会影响效率; 现在知道到了JVM中并没有方法重载的概念对效率没有影响。","like_count":0},{"had_liked":false,"id":188179,"user_name":"Jeff Yang","can_delete":false,"product_type":"c1","uid":1073709,"ip_address":"","ucode":"420A0E56476D7C","user_header":"https://static001.geekbang.org/account/avatar/00/10/62/2d/d798d877.jpg","comment_is_top":false,"comment_ctime":1584326992,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584326992","product_id":100010301,"comment_content":"例子举例的真好，一下子就看明白了","like_count":0},{"had_liked":false,"id":173330,"user_name":"好名字让朋友更好记住你","can_delete":false,"product_type":"c1","uid":1721007,"ip_address":"","ucode":"EDB60EE399F8AB","user_header":"https://static001.geekbang.org/account/avatar/00/1a/42/af/4b3280d8.jpg","comment_is_top":false,"comment_ctime":1579505993,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579505993","product_id":100010301,"comment_content":"牛逼了，有那么一点点懂了","like_count":0},{"had_liked":false,"id":162203,"user_name":"李飞","can_delete":false,"product_type":"c1","uid":1555180,"ip_address":"","ucode":"930458850AA05B","user_header":"https://static001.geekbang.org/account/avatar/00/17/ba/ec/2b1c6afc.jpg","comment_is_top":false,"comment_ctime":1576476754,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576476754","product_id":100010301,"comment_content":"本来只是为了温故，后来看了3遍，最后静下心来，仔细一字一句扣过去的","like_count":0},{"had_liked":false,"id":161761,"user_name":"饭粒","can_delete":false,"product_type":"c1","uid":1153455,"ip_address":"","ucode":"4C3220B0D43997","user_header":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","comment_is_top":false,"comment_ctime":1576319091,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576319091","product_id":100010301,"comment_content":"重载，编译解析阶段就能确定调用的方法，静态绑定。重写，JVM 执行过程中需要通过方法表的索引才能确定调用的方法（例外：标记为 final 的方法），动态绑定。","like_count":0},{"had_liked":false,"id":161388,"user_name":"BOB","can_delete":false,"product_type":"c1","uid":1066638,"ip_address":"","ucode":"239C06A7CD3BD5","user_header":"https://static001.geekbang.org/account/avatar/00/10/46/8e/334d25ba.jpg","comment_is_top":false,"comment_ctime":1576200794,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576200794","product_id":100010301,"comment_content":"当这种包括多个方法名相同、参数类型相同，而返回类型不同的方法的类，出现在Java编译器的用户类路径上时，它是怎么确定需要调用哪个方法的呢？<br>这段话不太理解，这里指的编译器是javac还是jit呢？<br>如果是javac的话，源码中不是不能出现仅有返回值不同的两个方法声明么","like_count":0},{"had_liked":false,"id":157055,"user_name":"无言的约定","can_delete":false,"product_type":"c1","uid":1128953,"ip_address":"","ucode":"5E8046EB6B7956","user_header":"https://static001.geekbang.org/account/avatar/00/11/39/f9/acfb9a48.jpg","comment_is_top":false,"comment_ctime":1575019802,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575019802","product_id":100010301,"comment_content":"请老师解答，涉及父类子类（NEW 或者多态）的属性及方法的调用顺序是？","like_count":0},{"had_liked":false,"id":156860,"user_name":"无言的约定","can_delete":false,"product_type":"c1","uid":1128953,"ip_address":"","ucode":"5E8046EB6B7956","user_header":"https://static001.geekbang.org/account/avatar/00/11/39/f9/acfb9a48.jpg","comment_is_top":false,"comment_ctime":1574988964,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574988964","product_id":100010301,"comment_content":"涉及父类子类的构造方法，静态方法，非静态方法，重写的方法，以及重载方法的调用顺序是什么？new一个对象，或者多态这两种情况","like_count":0},{"had_liked":false,"id":146057,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1572426612,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1572426612","product_id":100010301,"comment_content":"上一篇中我曾提到过，在执行使用了符号引用的字节码前，Java 虚拟机需要解析这些符号引用，并替换为实际引用。<br><br>这个就是类加载的解析过程吧，想问下老师，是会将所有的符号引用都转为直接引用，还是说只把和本次调用相关的符号引用转为直接引用？<br><br>","like_count":0,"discussions":[{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":399019,"discussion_content":"用到的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632887559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131878,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1567947701,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1567947701","product_id":100010301,"comment_content":"静态绑定：解析时便能直接识别目标方法的情况，如invokestatic和invokespecial调用<br>动态绑定：需要在运行过程中根据调用者的动态类型来识别目标方法的情况，如部分invokevirtual和invokespecial调用<br>编译时的符号引用设置：接口符号引用、非接口符号引用","like_count":0,"discussions":[{"author":{"id":1059674,"avatar":"","nickname":"三行","note":"","ucode":"3BBEA32B643538","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":210894,"discussion_content":"你好，大佬，请问一下，接口符号引用、非接口符号引用是只属于静态绑定的？还是既属于动态绑定，也属于静态绑定的呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584788832,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":116524,"user_name":"王二宝","can_delete":false,"product_type":"c1","uid":1042241,"ip_address":"","ucode":"E147D6E597EF5B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e7/41/2ea1f5dc.jpg","comment_is_top":false,"comment_ctime":1563863607,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1563863607","product_id":100010301,"comment_content":"当传入 null 时，它既可以匹配第一个方法中声明为 Object 的形式参数，也可以匹配第二个方法中声明为 String 的形式参数。由于 String 是 Object 的子类，因此 Java 编译器会认为子类的那个方法更为贴切。","like_count":0,"discussions":[{"author":{"id":1615785,"avatar":"https://static001.geekbang.org/account/avatar/00/18/a7/a9/f1826b48.jpg","nickname":"眉间雪","note":"","ucode":"094AC0B86C1504","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55876,"discussion_content":"那如果第invoke(null,null)为什么显示第一个方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574408556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1702886,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fb/e6/1b9edb91.jpg","nickname":"练习生","note":"","ucode":"60203A2AA0EA36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1615785,"avatar":"https://static001.geekbang.org/account/avatar/00/18/a7/a9/f1826b48.jpg","nickname":"眉间雪","note":"","ucode":"094AC0B86C1504","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337774,"discussion_content":"invoke(null,null)的确调了第一个，发现越试验越迷糊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609073442,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":55876,"ip_address":""},"score":337774,"extra":""}]}]},{"had_liked":false,"id":96236,"user_name":"樱小路依然","can_delete":false,"product_type":"c1","uid":1269957,"ip_address":"","ucode":"DBA9FF68015FE5","user_header":"https://static001.geekbang.org/account/avatar/00/13/60/c5/69286d58.jpg","comment_is_top":false,"comment_ctime":1558361748,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1558361748","product_id":100010301,"comment_content":"老师，我还有个问题，您这里说的接口符号引用转实际引用。比如 Cat 实现了 Animal 接口中的 eat()方法，然后调用时，Animal animal = new Cat();   animal.eat()，是怎么找到 Cat 实现的方法的呢？","like_count":0,"discussions":[{"author":{"id":1702886,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fb/e6/1b9edb91.jpg","nickname":"练习生","note":"","ucode":"60203A2AA0EA36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337775,"discussion_content":"通过非接口符号引用的方式去找，在步骤一就找到了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609073608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95557,"user_name":"樱小路依然","can_delete":false,"product_type":"c1","uid":1269957,"ip_address":"","ucode":"DBA9FF68015FE5","user_header":"https://static001.geekbang.org/account/avatar/00/13/60/c5/69286d58.jpg","comment_is_top":false,"comment_ctime":1558081161,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558081161","product_id":100010301,"comment_content":"我有个问题，开篇老师讲解的遇到的那个坑中，匹配到第二个方法，第一个调用invoke(null, 1); ，难道不是因为：首先没有考虑到 可变长参数，而 null，1 分别对应第二个方法的String，Object参数，所以优先被选择到的吗？感觉老师这里直接解释说  String 是 Object的子类，所以是选第二个方法，有点以偏概全？或者说 String 是 Object 的子类，选第二个方法的优先级更靠前一点呢？","like_count":0},{"had_liked":false,"id":94733,"user_name":"木易","can_delete":false,"product_type":"c1","uid":1519409,"ip_address":"","ucode":"7EFB96D269FCF4","user_header":"https://static001.geekbang.org/account/avatar/00/17/2f/31/42b12e3b.jpg","comment_is_top":false,"comment_ctime":1557886425,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1557886425","product_id":100010301,"comment_content":"老师，有一个问题，就是虚拟机对重写的识别标准和java语言对重写的定义都是：方法名，参数，返回值一致，那么怎么会出现 java语言重写而java虚拟机不重写的情况呢？","like_count":0,"discussions":[{"author":{"id":1730576,"avatar":"","nickname":"27","note":"","ucode":"B5D7A54EA47206","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78460,"discussion_content":"java语言重写的返回值类型可以是子类","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575990073,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93614,"user_name":"草戊","can_delete":false,"product_type":"c1","uid":1044202,"ip_address":"","ucode":"F1B0CB0A4FA762","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/ea/c8136dfd.jpg","comment_is_top":false,"comment_ctime":1557536446,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557536446","product_id":100010301,"comment_content":"编译阶段，已经把名字区分了，通过参数加的名称上，在虚拟机加载class时，看到的已经是不同的方法","like_count":0},{"had_liked":false,"id":90653,"user_name":"pinocc","can_delete":false,"product_type":"c1","uid":1112428,"ip_address":"","ucode":"163321B38AC6FA","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/6c/4d5a65ae.jpg","comment_is_top":false,"comment_ctime":1556601407,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556601407","product_id":100010301,"comment_content":"看了好几遍，配合深入理解jvm总算看懂了","like_count":0},{"had_liked":false,"id":89862,"user_name":"balance","can_delete":false,"product_type":"c1","uid":1007182,"ip_address":"","ucode":"324D909BBE69DE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/4e/85502e98.jpg","comment_is_top":false,"comment_ctime":1556287889,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1556287889","product_id":100010301,"comment_content":"这个说法在 Java 虚拟机语境下并非完全正确。这是因为某个类中的重载方法可能被它的子类所重写，因此 Java 编译器会将所有对非私有实例方法的调用编译为需要动态绑定的类型。<br>==============================<br>这段没有理解，老师能不能再给解释一下，谢谢！","like_count":0,"discussions":[{"author":{"id":1115724,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLwSoTjHPX5tm4whBSfoZLX6toZxrZGUaLABQywKNf4MDc9toK3QSV7Z99ATcGicFCysoleQ5ISzmw/132","nickname":"乘风","note":"","ucode":"0420C5535DACB7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1595,"discussion_content":"非虚和虚方法的区别，非虚方法可以理解为实方法，其引用地址是确定的，而虚方法由于java的动态特性，引用地址会在动态运行时才能确定，参考栈帧上的动态连接，在执行时才会解析其具体引用，并且JIT也会针对虚方法进行优化，如虚方法的方法内联优化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562723714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87058,"user_name":"奥北北北北北北","can_delete":false,"product_type":"c1","uid":1461607,"ip_address":"","ucode":"082BBBDFF8384F","user_header":"https://static001.geekbang.org/account/avatar/00/16/4d/67/a13a2421.jpg","comment_is_top":false,"comment_ctime":1555504491,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555504491","product_id":100010301,"comment_content":"暂时理解起来有点困难，不知道看了后边的返回来再看会不会好点","like_count":0},{"had_liked":false,"id":74371,"user_name":"ipromiseu","can_delete":false,"product_type":"c1","uid":1159317,"ip_address":"","ucode":"775E2CC0E7CA69","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erbUHD8KH3mYz39QuHj5BXB06VqCus5WR4oHfNuSYdPVLno3Tq61yhMiaugxpMicKibDFQ4KwX7icoDWQ/132","comment_is_top":false,"comment_ctime":1552204358,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1552204358","product_id":100010301,"comment_content":"对于 Java 语言中重写而 Java 虚拟机中非重写<br>对这句话能否举个例子？","like_count":0,"discussions":[{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":399023,"discussion_content":"如果子类定义了与父类中非私有、非静态方法同名的方法，那么只有当这两个方法的参数类型以及返回类型一致，Java 虚拟机才会判定为重写","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632888690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1730576,"avatar":"","nickname":"27","note":"","ucode":"B5D7A54EA47206","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78474,"discussion_content":"Java语言 重写的返回值类型可以是该类型的子类，而Java虚拟机中认定的重写必须和基类的返回类型一致，所以会有桥接","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575990271,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1179480,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ff/58/1c3c195b.jpg","nickname":"楚门的世界","note":"","ucode":"F411D2481812B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53613,"discussion_content":"我也想问这个，看得我一脸懵逼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574178891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73510,"user_name":"西西","can_delete":false,"product_type":"c1","uid":1270133,"ip_address":"","ucode":"19445764BB2F3A","user_header":"https://static001.geekbang.org/account/avatar/00/13/61/75/1a91db4d.jpg","comment_is_top":false,"comment_ctime":1551919240,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551919240","product_id":100010301,"comment_content":"编译阶段？","like_count":0},{"had_liked":false,"id":71604,"user_name":"jack Wong","can_delete":false,"product_type":"c1","uid":1356930,"ip_address":"","ucode":"EDF88971815846","user_header":"https://static001.geekbang.org/account/avatar/00/14/b4/82/62548de6.jpg","comment_is_top":false,"comment_ctime":1551400288,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551400288","product_id":100010301,"comment_content":"学习了，继续复习","like_count":0},{"had_liked":false,"id":68618,"user_name":"Michael 🛡YZY","can_delete":false,"product_type":"c1","uid":1186115,"ip_address":"","ucode":"F1D2BF8489A7D2","user_header":"https://static001.geekbang.org/account/avatar/00/12/19/43/226ca347.jpg","comment_is_top":false,"comment_ctime":1550559174,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550559174","product_id":100010301,"comment_content":"建议把关键的概念尽量配英文解释 朗读的时候尽量加入一些语义的感觉 否则感觉跟绕口令一样 不太容易产生语义关联 进而不太容易理解 ","like_count":0},{"had_liked":false,"id":67964,"user_name":"neohope","can_delete":false,"product_type":"c1","uid":1043475,"ip_address":"","ucode":"C0268F6E7E2B6E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","comment_is_top":false,"comment_ctime":1550371394,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1550371394","product_id":100010301,"comment_content":"无论是返回值发生变化，还是参数发生变化，都会生成桥接方法。而桥接方法中的内容明显是直接调用了子类中实际实现的方法并返回。桥接方法上会有 ACC_SYNTHETIC两个标志，表示对于javac不可用。<br><br>那我想问一下桥接方法是在什么场景下会被调用呢？感谢！","like_count":0,"discussions":[{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":399025,"discussion_content":"一个子类在继承（或实现）一个父类（或接口）的泛型方法时，在子类中明确指定了泛型类型，那么在编译时编译器会自动生成桥接方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632888998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1730576,"avatar":"","nickname":"27","note":"","ucode":"B5D7A54EA47206","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78477,"discussion_content":"参数发生变化会有桥接？都不是重写了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575990345,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1644950,"avatar":"https://static001.geekbang.org/account/avatar/00/19/19/96/3b49b437.jpg","nickname":"郭某某","note":"","ucode":"5E53B60527DCDF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1730576,"avatar":"","nickname":"27","note":"","ucode":"B5D7A54EA47206","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294825,"discussion_content":"参数为泛型","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596010195,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":78477,"ip_address":""},"score":294825,"extra":""}]}]},{"had_liked":false,"id":67713,"user_name":"neohope","can_delete":false,"product_type":"c1","uid":1043475,"ip_address":"","ucode":"C0268F6E7E2B6E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","comment_is_top":false,"comment_ctime":1550228178,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550228178","product_id":100010301,"comment_content":"感觉JVM比C、CPP还是有不少相似的地方：<br>比如JVM的ClassLoader与C、CPP下的Dll加载机制+LoadLibrary还是有些相似的。<br>比如JVM下重载时对方法的判断，和C、CPP下的函数签名感觉挺相似的。<br><br>但也有一些不一样的地方：<br>JVM在invoke上，比Win32的汇编要复杂很多，Win32汇编下面一个invoke就搞定了，而JVM下面就有很多。<br>JVM是默认支持运行时类型识别的，但C、CPP就没有这样的支持咯，需要自己来实现。","like_count":0},{"had_liked":false,"id":53630,"user_name":"雨天","can_delete":false,"product_type":"c1","uid":1056406,"ip_address":"","ucode":"FD9FB404ECA463","user_header":"https://static001.geekbang.org/account/avatar/00/10/1e/96/3162d51f.jpg","comment_is_top":false,"comment_ctime":1545702726,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545702726","product_id":100010301,"comment_content":"重写父类方法应该违反了里式替换原则.多态应该是通过实现接口[抽象类]来实现是不是更好?","like_count":0},{"had_liked":false,"id":50276,"user_name":"小泷哥","can_delete":false,"product_type":"c1","uid":1255252,"ip_address":"","ucode":"128C9C4B0AFE7F","user_header":"https://static001.geekbang.org/account/avatar/00/13/27/54/d38c34a0.jpg","comment_is_top":false,"comment_ctime":1544941960,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544941960","product_id":100010301,"comment_content":"1、方法重载在调用时是如何匹配的<br>2、JVM的方法识别方式<br>3、方法调用指令及使用方式<br>4、class静态文件在加载进JVM后，JVM是如何解析其中的方法符号引用(主要是动态)。<br>5、静态绑定是一个指针，动态绑定是一个方法表索引<br>疑问：<br>1、重载方法对JVM来说是两个不同的方法？是固定的指针？<br>2、重写对JVM来说是一个方法表?<br>标题可以改成：从零实现一个简单的OOP虚拟机","like_count":0},{"had_liked":false,"id":46358,"user_name":"楊_宵夜","can_delete":false,"product_type":"c1","uid":1019302,"ip_address":"","ucode":"7BA0CADC5F23BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/a6/22c37c91.jpg","comment_is_top":false,"comment_ctime":1543907161,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543907161","product_id":100010301,"comment_content":"划重点：<br>1. Customer, Merchant, NaiveMerchant是第一个例子<br>2. Customer, Merchant&lt;T&gt;, VIPOnlyMerchant是第二个例子，请各位分开测试；<br>3.【JVM】为了保证【JAVA语言】对【重写】的语义完整性，会生成【桥接方法】；<br><br>以下走个描述流程：<br>在NaiveMerchant例子中：<br>- 在【Java语言规范】看来，Naive已经【重写】了actionPrice()；但在【JVM规范】看来，actionPrice()并未重写；<br>- 在上述基础上，【JVM】会生成【桥接方法】，为了【保证JAVA语言层面的语义完整性】;<br><br>- 那这个【桥接方法】是用在哪里呢？<br>请试下以下方式，看返回值是什么？但真正调用的方法又是谁？<br>((Merchant) naiveMerchant).actionPrice(0.75d, null);<br><br>这是【动态绑定】的一个例子，也是【Java多态性】的重要体现;","like_count":0},{"had_liked":false,"id":41628,"user_name":"骑车吃火锅","can_delete":false,"product_type":"c1","uid":1303591,"ip_address":"","ucode":"6C00EEB90AD539","user_header":"https://static001.geekbang.org/account/avatar/00/13/e4/27/73359af3.jpg","comment_is_top":false,"comment_ctime":1542812410,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542812410","product_id":100010301,"comment_content":"为什么invokevirtual属于动态绑定","like_count":0},{"had_liked":false,"id":41465,"user_name":"梁林","can_delete":false,"product_type":"c1","uid":1157887,"ip_address":"","ucode":"A06C1F654E246F","user_header":"https://static001.geekbang.org/account/avatar/00/11/aa/ff/056f60bd.jpg","comment_is_top":false,"comment_ctime":1542787536,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542787536","product_id":100010301,"comment_content":"&quot;如果这两个方法都是静态的，那么子类中的方法隐藏了父类中的方法&quot; 这里应该是指编译器在编译阶段就识别出了调用的是子类的静态方法还是父类的静态方法。如果是子类的静态方法，那么生成的class文件就只有子类的静态方法","like_count":0},{"had_liked":false,"id":40369,"user_name":"Demter","can_delete":false,"product_type":"c1","uid":1158439,"ip_address":"","ucode":"BE3B6F726916CE","user_header":"https://static001.geekbang.org/account/avatar/00/11/ad/27/5556ae50.jpg","comment_is_top":false,"comment_ctime":1542606300,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542606300","product_id":100010301,"comment_content":"为什么对于invokespecial，Java 虚拟机能够直接识别具体的目标方法，而对于invokevirtual不能识别出来呢？<br><br><br>","like_count":0},{"had_liked":false,"id":34745,"user_name":"★诸神的黄昏","can_delete":false,"product_type":"c1","uid":1267542,"ip_address":"","ucode":"F79EEE55A83EAD","user_header":"https://static001.geekbang.org/account/avatar/00/13/57/56/fdde2384.jpg","comment_is_top":false,"comment_ctime":1540280027,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540280027","product_id":100010301,"comment_content":"老师，重载部分小知识是不是可以说的更清晰点。Java源文件编译成class文件后，使用字节码工具注入方法名、方法参数相同，返回值不同的方法，接下来原文中所谓的“出现在Java编译器用户类路径上时”，这里说的又是什么部分呢？不是已经编译了吗，为了这里还有编译，应该是直接调用了吧？我理解这里是调用然后匹配，可怎么会又有“它会根据所选取方法的返回类型来决定可不可以通过编译”这样的说法呢，读到这里很迷糊。","like_count":0},{"had_liked":false,"id":33002,"user_name":"刹那间的永恒","can_delete":false,"product_type":"c1","uid":1114738,"ip_address":"","ucode":"DAB8A1BE22C4EC","user_header":"https://static001.geekbang.org/account/avatar/00/11/02/72/6933412b.jpg","comment_is_top":false,"comment_ctime":1539739498,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539739498","product_id":100010301,"comment_content":"老师，您好，对于非接口符号引用第三个步骤最后点您说如果存在多个目标方法，则是任意返回一个？这个任意不太理解，难道会存在任意调用其中一个方法的情况？","like_count":0},{"had_liked":false,"id":27492,"user_name":"易水寒","can_delete":false,"product_type":"c1","uid":1238961,"ip_address":"","ucode":"F5D8127ED4754E","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/b1/5c63be67.jpg","comment_is_top":false,"comment_ctime":1537895630,"is_pvip":false,"replies":[{"id":"10285","content":"谢谢！我之后会统一一下引用方式，方便在文中就能点击。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1538114795,"ip_address":"","comment_id":27492,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1537895630","product_id":100010301,"comment_content":"给下面某人解释一个问题，final[3][4]指的是参考下面的链接3，4链接，论文当中引用了别人的东西都这么写","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424924,"discussion_content":"谢谢！我之后会统一一下引用方式，方便在文中就能点击。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538114795,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":27439,"user_name":"Eric","can_delete":false,"product_type":"c1","uid":1249927,"ip_address":"","ucode":"5EF343ADCB5C60","user_header":"https://static001.geekbang.org/account/avatar/00/13/12/87/765a5366.jpg","comment_is_top":false,"comment_ctime":1537887714,"is_pvip":false,"replies":[{"id":"10293","content":"不少习题都比较发散，主要是希望大家深入探索。应该有留言已经回答了。<br><br>等完成专栏后面的文章，我再回来把讲解补上的。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1538116337,"ip_address":"","comment_id":27439,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1537887714","product_id":100010301,"comment_content":"每节课布置的题都没有讲解，让人很困扰。","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424913,"discussion_content":"不少习题都比较发散，主要是希望大家深入探索。应该有留言已经回答了。\n\n等完成专栏后面的文章，我再回来把讲解补上的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538116337,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":23645,"user_name":"QlDoors","can_delete":false,"product_type":"c1","uid":1005911,"ip_address":"","ucode":"394F3E6CE39392","user_header":"https://static001.geekbang.org/account/avatar/00/0f/59/57/449e76fb.jpg","comment_is_top":false,"comment_ctime":1536567810,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1536567810","product_id":100010301,"comment_content":"1. invokespecial：和所实现接口的默认方法<br>2. 非接口符号引用步骤3<br>3. 接口符号引用步骤2<br>老师上面这个三个没有太搞明白，能否举个代码实现的例子，谢谢","like_count":0},{"had_liked":false,"id":23230,"user_name":"白院伟","can_delete":false,"product_type":"c1","uid":1187420,"ip_address":"","ucode":"CE6AC96814DA9E","user_header":"https://static001.geekbang.org/account/avatar/00/12/1e/5c/6de299ba.jpg","comment_is_top":false,"comment_ctime":1536222668,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1536222668","product_id":100010301,"comment_content":"在选取重载方法的第一阶段中，应该也不考虑对象的向上转型吧？？？紧接着下面提到的贴切程度应该就是这个意思吧？？","like_count":0},{"had_liked":false,"id":22813,"user_name":"liu","can_delete":false,"product_type":"c1","uid":1109402,"ip_address":"","ucode":"041F179BB00A59","user_header":"https://static001.geekbang.org/account/avatar/00/10/ed/9a/bbeec5bb.jpg","comment_is_top":false,"comment_ctime":1535982483,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1535982483","product_id":100010301,"comment_content":"高质量","like_count":0},{"had_liked":false,"id":22143,"user_name":"哇！怎么这么大个","can_delete":false,"product_type":"c1","uid":1196856,"ip_address":"","ucode":"87106662D244C9","user_header":"https://static001.geekbang.org/account/avatar/00/12/43/38/72feb2e0.jpg","comment_is_top":false,"comment_ctime":1535506484,"is_pvip":false,"replies":[{"id":"8018","content":"可以和15篇参照着看。其中的桥接方法就是同名同参数不同返回类型的方法。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1535623817,"ip_address":"","comment_id":22143,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1535506484","product_id":100010301,"comment_content":"”Java 虚拟机识别方法的方式略有不同，除了方法名和参数类型之外，它还会考虑返回类型。”<br>如果JAVA虚拟机考虑到了返回类型，那么是否可以定义同名类且同名方法相同参数不同返回类型的方法（实际上在ide中会报错，那JAVA虚拟机是出于怎么样的考虑会将返回类型也加入到方法描述符中去）","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423015,"discussion_content":"可以和15篇参照着看。其中的桥接方法就是同名同参数不同返回类型的方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535623817,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21376,"user_name":"Geek_7bfa8b","can_delete":false,"product_type":"c1","uid":1110522,"ip_address":"","ucode":"7ED7F2DE53C39B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/7x045Wg58RRz5Tl2SDd6tVmII34Yub4KupAAc3mMInBREsRmGzregkqMyTjKcmprgnznGusLGCScTCTvfxJPpg/132","comment_is_top":false,"comment_ctime":1535068121,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1535068121","product_id":100010301,"comment_content":"边听，边看，不少于七遍了~可以！","like_count":0},{"had_liked":false,"id":21046,"user_name":"Hizkijah","can_delete":false,"product_type":"c1","uid":1106569,"ip_address":"","ucode":"C32996967BC5E4","user_header":"https://static001.geekbang.org/account/avatar/00/10/e2/89/2c07a3c1.jpg","comment_is_top":false,"comment_ctime":1534898168,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1534898168","product_id":100010301,"comment_content":"1:静态绑定具体咋实现的？<br>2:方法表在那里？啥时候创建的？咋和具体的类关联起来的呢？<br>我觉得这两问题很好，老师可以解答一下吗","like_count":0},{"had_liked":false,"id":20911,"user_name":"preston","can_delete":false,"product_type":"c1","uid":1192115,"ip_address":"","ucode":"A98A587D4B716C","user_header":"","comment_is_top":false,"comment_ctime":1534813722,"is_pvip":false,"replies":[{"id":"7432","content":"就是可以通过子类类名来调用父类静态方法。看了下面这个例子就懂啦<br><br><br>class Foo { static void m(){} }<br>class Bar extends Foo{}<br><br><br>Bar.m();","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1534932278,"ip_address":"","comment_id":20911,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1534813722","product_id":100010301,"comment_content":"请问子类可以调用父类的静态方法是什么意思？我有点不太明白。","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422453,"discussion_content":"就是可以通过子类类名来调用父类静态方法。看了下面这个例子就懂啦\n\n\nclass Foo { static void m(){} }\nclass Bar extends Foo{}\n\n\nBar.m();","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534932278,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20164,"user_name":"皮卡皮卡丘","can_delete":false,"product_type":"c1","uid":1106062,"ip_address":"","ucode":"6764F465FF975B","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/8e/0e4bc2a9.jpg","comment_is_top":false,"comment_ctime":1534296277,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1534296277","product_id":100010301,"comment_content":"开篇的例子测试结果正好与老师的相反，jdk8","like_count":0},{"had_liked":false,"id":19935,"user_name":"包子","can_delete":false,"product_type":"c1","uid":1089345,"ip_address":"","ucode":"6CC4EBB8CD3924","user_header":"https://static001.geekbang.org/account/avatar/00/10/9f/41/82306dfe.jpg","comment_is_top":false,"comment_ctime":1534168909,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1534168909","product_id":100010301,"comment_content":"对于 Java 语言中重写而 Java 虚拟机中非重写的情况，编译器会通过生成桥接方法 [2] 来实现 Java 中的重写语义。<br><br>您好老师，文章中多次提到的Java语言和Java虚拟机。对这块一直很模糊。<br>例如上述的Java语言重写我理解是编译阶段，也就是java代码到class文件阶段。<br>而Java虚拟机重写是在什么阶段判定的？或者说Java虚拟机识别方法实在什么时候识别的。<br>Java代码从写到执行我理解的步骤是：<br>1. 通过javac命令从代码到class文件阶段<br>2. 加载class文件到虚拟机阶段（加载，链接，初始化）<br>3. 字节码到机器码阶段<br>4.执行机器码","like_count":0},{"had_liked":false,"id":19402,"user_name":"hacker time","can_delete":false,"product_type":"c1","uid":1017296,"ip_address":"","ucode":"41F0870C832ECD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/85/d0/71bc9d31.jpg","comment_is_top":false,"comment_ctime":1533811707,"is_pvip":false,"replies":[{"id":"6779","content":"这里要覆盖掉的。你也可以换个名字。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1533894569,"ip_address":"","comment_id":19402,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1533811707","product_id":100010301,"comment_content":"这篇文章的课后习题，一个是class merchant一个是class merchant&lt;T extends Merchant&gt;,把这段代码写在一个文件里面会报编译错误，请问老师怎么解决","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421825,"discussion_content":"这里要覆盖掉的。你也可以换个名字。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1533894569,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":19268,"user_name":"贾智文","can_delete":false,"product_type":"c1","uid":1100235,"ip_address":"","ucode":"600CF0AB215D1A","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/cb/7b6802cc.jpg","comment_is_top":false,"comment_ctime":1533740667,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1533740667","product_id":100010301,"comment_content":"文章最后的例子会编译错误吧？","like_count":0},{"had_liked":false,"id":18371,"user_name":"贾智文","can_delete":false,"product_type":"c1","uid":1100235,"ip_address":"","ucode":"600CF0AB215D1A","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/cb/7b6802cc.jpg","comment_is_top":false,"comment_ctime":1533273050,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1533273050","product_id":100010301,"comment_content":"什么情况下会出现java语言重写，虚拟机没有重写的情况呢？子类如果返回类型和父类不一样，会变异错误吧？排除这种情况java语言应该和虚拟机一致吧","like_count":0},{"had_liked":false,"id":17768,"user_name":"Ennis LM","can_delete":false,"product_type":"c1","uid":1188522,"ip_address":"","ucode":"8AA2004DB0DDE4","user_header":"https://static001.geekbang.org/account/avatar/00/12/22/aa/c7725dd8.jpg","comment_is_top":false,"comment_ctime":1532944708,"is_pvip":false,"replies":[{"id":"6176","content":"假如C实现了I，I继承I1，I1继承I2，那么C和I2之间就隔着I和I1","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1532973601,"ip_address":"","comment_id":17768,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1532944708","product_id":100010301,"comment_content":"并且，如果目标方法在间接实现的接口中，则需满足 C 与该接口之间没有其他符合条件的目标方法。如果有多个符合条件的目标方法，则任意返回其中一个。<br><br>请问C 与该接口之间有其他符合条件的目标方法是什么情况，这里我看不太懂","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421265,"discussion_content":"假如C实现了I，I继承I1，I1继承I2，那么C和I2之间就隔着I和I1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1532973601,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":17767,"user_name":"Ennis LM","can_delete":false,"product_type":"c1","uid":1188522,"ip_address":"","ucode":"8AA2004DB0DDE4","user_header":"https://static001.geekbang.org/account/avatar/00/12/22/aa/c7725dd8.jpg","comment_is_top":false,"comment_ctime":1532944594,"is_pvip":false,"replies":[{"id":"6177","content":"应该会编译错误，你可以试一试","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1532973842,"ip_address":"","comment_id":17767,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1532944594","product_id":100010301,"comment_content":"如果这两个方法都是静态的，那么子类中的方法隐藏了父类中的方法。如果这两个方法都不是静态的，且都不是私有的，那么子类的方法重写了父类中的方法。<br><br>那如果两个方法不是“都是静态的”，也不是“都不是静态的，且都不是私有的”，这样会是什么情况呢，隐藏？重写？还是都不是","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421264,"discussion_content":"应该会编译错误，你可以试一试","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1532973842,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":17593,"user_name":"云学","can_delete":false,"product_type":"c1","uid":1027233,"ip_address":"","ucode":"366AE90BA06356","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ac/a1/43d83698.jpg","comment_is_top":false,"comment_ctime":1532764313,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1532764313","product_id":100010301,"comment_content":"看上去和c++的重载&#47;重写 RTTI类似","like_count":0},{"had_liked":false,"id":17504,"user_name":"Nu11PointerEx","can_delete":false,"product_type":"c1","uid":1177802,"ip_address":"","ucode":"D5C19A98F894B7","user_header":"https://static001.geekbang.org/account/avatar/00/11/f8/ca/1a1e190a.jpg","comment_is_top":false,"comment_ctime":1532692396,"is_pvip":false,"replies":[{"id":"6081","content":"课后习题列举了两种情况，可以参照一下","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1532705747,"ip_address":"","comment_id":17504,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1532692396","product_id":100010301,"comment_content":"&quot;对于 Java 语言中重写而 Java 虚拟机中非重写的情况&quot;<br>这种是什么样的情况？","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421180,"discussion_content":"课后习题列举了两种情况，可以参照一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1532705747,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":17496,"user_name":"vimfun","can_delete":false,"product_type":"c1","uid":1007359,"ip_address":"","ucode":"EAB2281FC0552A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/ff/295bcf2c.jpg","comment_is_top":false,"comment_ctime":1532686268,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1532686268","product_id":100010301,"comment_content":"老师，public final 的方法，是不是在虚拟机中静态绑定？","like_count":0},{"had_liked":false,"id":17484,"user_name":"蒙奇·D·淡抹🎈","can_delete":false,"product_type":"c1","uid":1179760,"ip_address":"","ucode":"E04D33A3EA7308","user_header":"https://static001.geekbang.org/account/avatar/00/12/00/70/13b33785.jpg","comment_is_top":false,"comment_ctime":1532677701,"is_pvip":false,"replies":[{"id":"6076","content":"哈，所以在设计API时要避免这些情况","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1532705376,"ip_address":"","comment_id":17484,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1532677701","product_id":100010301,"comment_content":"开头的坑，我也遇见过，我的例子是：<br>public void method(String str){<br>    ...<br>}<br>public void method(Object obj){<br>    ...<br>}<br><br>method(null);一直调用的是string参数的方法","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421172,"discussion_content":"哈，所以在设计API时要避免这些情况","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1532705376,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":17475,"user_name":"Thomas","can_delete":false,"product_type":"c1","uid":1178585,"ip_address":"","ucode":"36950010DB3D29","user_header":"https://static001.geekbang.org/account/avatar/00/11/fb/d9/055e5383.jpg","comment_is_top":false,"comment_ctime":1532672624,"is_pvip":false,"replies":[{"id":"6077","content":"下一篇会讲动态绑定，看完就应该理解啦","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1532705428,"ip_address":"","comment_id":17475,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1532672624","product_id":100010301,"comment_content":"老师～接口与接口实现是怎么联系的？","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421170,"discussion_content":"下一篇会讲动态绑定，看完就应该理解啦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1532705428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":17452,"user_name":"Fwng","can_delete":false,"product_type":"c1","uid":1186483,"ip_address":"","ucode":"8CC2448320AF79","user_header":"https://static001.geekbang.org/account/avatar/00/12/1a/b3/b9f601e3.jpg","comment_is_top":false,"comment_ctime":1532654874,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1532654874","product_id":100010301,"comment_content":"老师早上好，jvm的方法查找发生在哪一阶段呢？","like_count":0}]}