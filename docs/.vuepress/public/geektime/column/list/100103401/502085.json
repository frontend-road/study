{"id":502085,"title":"31 | 图解Channel：如何理解它的CSP通信模型？","content":"<p>你好，我是朱涛。今天我们来分析Channel的源码。</p><p>Kotlin的Channel是一个非常重要的组件，在它出现之前，协程之间很难进行通信，有了它以后，协程之间的通信就轻而易举了。在<a href=\"https://time.geekbang.org/column/article/493069\">第22讲</a>当中，我们甚至还借助Channel实现的Actor做到了并发安全。</p><p>那么总的来说，Channel是热的，同时它还是一个<strong>线程安全的数据管道</strong>。而由于Channel具有线程安全的特性，因此，它最常见的用法，就是建立CSP通信模型（Communicating Sequential Processes）。</p><p>不过你可能会觉得，CSP太抽象了不好理解，但其实，这个通信模型我们在第22讲里就接触过了。当时我们虽然是通过Actor来实现的，但却是把它当作CSP在用，它们两者的差异其实很小。</p><p><video poster=\"https://media001.geekbang.org/e2f6d9ef4c8e4a67b051a16e64808084/snapshots/a465772fb3354c83bf29a2e6c50a1ca6-00004.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/54981571-17f69fc57d6-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/97b00e96eb0d465c9ca8552b52f6d725/5cfcdb560f644b90b9fd41d335f023b4-dead5a81ab78def2dfeefb98f2c92342-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><p>关于<a href=\"https://en.wikipedia.org/wiki/Communicating_sequential_processes\">CSP的理论</a>，它的精确定义其实比较复杂，不过它的核心理念用一句话就可以概括：<strong>不要共享内存来通信；而是要用通信来共享内存</strong>（Don’t communicate by sharing memory; share memory by communicating）。</p><p>可是，我们为什么可以通过Channel实现CSP通信模型呢？这背后的技术细节，则需要我们通过源码来发掘了。</p><!-- [[[read_end]]] --><h2>Channel背后的数据结构</h2><p>为了研究Channel的源代码，我们仍然是以一个简单的Demo为例，来跟踪它的代码执行流程。</p><pre><code class=\"language-plain\">// 代码段1\n\nfun main()  {\n    val scope = CoroutineScope(Job() + mySingleDispatcher)\n    // 1，创建管道\n    val channel = Channel&lt;Int&gt;()\n\n    scope.launch {\n        // 2，在一个单独的协程当中发送管道消息\n        repeat(3)  {\n            channel.send(it)\n            println(\"Send: $it\")\n        }\n\n        channel.close()\n    }\n\n    scope.launch {\n        // 3，在一个单独的协程当中接收管道消息\n        repeat(3) {\n            val result = channel.receive()\n            println(\"Receive ${result}\")\n        }\n    }\n\n    println(\"end\")\n    Thread.sleep(2000000L)\n}\n\n/*\n输出结果：\nend\nReceive 0\nSend: 0\nSend: 1\nReceive 1\nReceive 2\nSend: 2\n*/\n</code></pre><p>以上代码主要分为三个部分，分别是：Channel创建、发送数据、接收数据。</p><p>我们先来分析注释1处的Channel创建逻辑。我们都知道Channel其实是一个接口，它是通过组合SendChannel、ReceiveChannel得来的。而注释1处调用的Channel()，其实是一个普通的顶层函数，只是<strong>它发挥的作用是构造函数，因此它的首字母是大写的</strong>，这跟我们上节课分析的CoroutineScope、Job也是类似的。</p><pre><code class=\"language-plain\">// 代码段2\n\npublic interface Channel&lt;E&gt; : SendChannel&lt;E&gt;, ReceiveChannel&lt;E&gt; {\n\npublic fun &lt;E&gt; Channel(\n    capacity: Int = RENDEZVOUS,\n    onBufferOverflow: BufferOverflow = BufferOverflow.SUSPEND,\n    onUndeliveredElement: ((E) -&gt; Unit)? = null\n): Channel&lt;E&gt; =\n    when (capacity) {\n        RENDEZVOUS -&gt; {\n            if (onBufferOverflow == BufferOverflow.SUSPEND)\n                RendezvousChannel(onUndeliveredElement) \n            else\n                ArrayChannel(1, onBufferOverflow, onUndeliveredElement) \n        }\n        CONFLATED -&gt; {\n            ConflatedChannel(onUndeliveredElement)\n        }\n        UNLIMITED -&gt; LinkedListChannel(onUndeliveredElement) \n        BUFFERED -&gt; ArrayChannel( \n            if (onBufferOverflow == BufferOverflow.SUSPEND) CHANNEL_DEFAULT_CAPACITY else 1,\n            onBufferOverflow, onUndeliveredElement\n        )\n        else -&gt; {\n            if (capacity == 1 &amp;&amp; onBufferOverflow == BufferOverflow.DROP_OLDEST)\n                ConflatedChannel(onUndeliveredElement) \n            else\n                ArrayChannel(capacity, onBufferOverflow, onUndeliveredElement)\n        }\n    }\n</code></pre><p>然后，从上面的代码里，我们可以看到，<strong>Channel()方法的核心逻辑就是一个when表达式</strong>，它根据传入的参数，会创建不同类型的Channel实例，包括了：RendezvousChannel、ArrayChannel、ConflatedChannel、LinkedListChannel。而这些实现类都有一个共同的父类：<strong>AbstractChannel</strong>。</p><pre><code class=\"language-plain\">// 代码段3\n\ninternal abstract class AbstractSendChannel&lt;E&gt;(\n    @JvmField protected val onUndeliveredElement: OnUndeliveredElement&lt;E&gt;?\n) : SendChannel&lt;E&gt; {\n\n    protected val queue = LockFreeLinkedListHead()\n\n    // 省略\n\n    internal abstract class AbstractChannel&lt;E&gt;(\n    onUndeliveredElement: OnUndeliveredElement&lt;E&gt;?\n) : AbstractSendChannel&lt;E&gt;(onUndeliveredElement), Channel&lt;E&gt; {}\n}\n</code></pre><p>可以看到，AbstractChannel其实是AbstractSendChannel的内部类，同时它也是AbstractSendChannel的子类。而Channel当中的核心逻辑，都是依靠AbstractSendChannel当中的 <strong>LockFreeLinkedListHead</strong> 实现的。我们接着来看下它的源代码：</p><pre><code class=\"language-plain\">// 代码段4\n\npublic actual open class LockFreeLinkedListHead : LockFreeLinkedListNode() {\n    public actual val isEmpty: Boolean get() = next === this\n}\n\npublic actual open class LockFreeLinkedListNode {\n    // 1\n    private val _next = atomic&lt;Any&gt;(this)\n    private val _prev = atomic(this)\n    private val _removedRef = atomic&lt;Removed?&gt;(null)\n}\n</code></pre><p>可见，LockFreeLinkedListHead其实继承自 <strong>LockFreeLinkedListNode</strong>，而LockFreeLinkedListNode则是实现Channel核心功能的关键数据结构。整个数据结构的核心思想，来自于2004年的一篇论文：<a href=\"https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.140.4693&rep=rep1&type=pdf\">《Lock-Free and Practical Doubly Linked List-Based Deques Using Single-Word Compare-and-Swap》</a>。如果你对其中的原理感兴趣，可以去看看这篇论文。这里，为了不偏离主题，我们只分析它的核心思想。</p><p>LockFreeLinkedListNode，我们可以将其区分开来看待，即LockFree和LinkedList。</p><p>第一个部分：<strong>LockFree</strong>，它是通过<a href=\"https://zh.wikipedia.org/wiki/%E6%AF%94%E8%BE%83%E5%B9%B6%E4%BA%A4%E6%8D%A2\">CAS</a>（Compare And Swap）的思想来实现的，比如JDK提供的java.util.concurrent.atomic。这一点，我们从上面注释1的atomic也可以看出来。</p><p>第二个部分：<strong>LinkedList</strong>，这说明LockFreeLinkedList本质上还是一个<strong>链表</strong>。简单来说，它其实是一个循环双向链表，而LockFreeLinkedListHead其实是一个<strong>哨兵节点</strong>，如果你熟悉链表这个数据结构，也可以将其看作是链表当中的<a href=\"https://stackoverflow.com/questions/37324972/what-is-a-dummy-head\">虚拟头结点</a>，这个节点本身不会用于存储任何数据，它的next指针会指向整个链表的<strong>头节点</strong>，而它的prev指针会指向整个链表的<strong>尾节点</strong>。</p><p>为了方便你理解，我画了一张图描述这个链表的结构：</p><p><img src=\"https://static001.geekbang.org/resource/image/b0/ef/b040356bb5e6e6eab4b4fb4bcdbb74ef.jpg?wh=2000x713\" alt=\"\"></p><p>请看图片左边的部分，<strong>当链表为空的时候</strong>，LockFreeLinkedListHead的next指针和prev指针，都是指向自身的。这也就意味着，这个Head节点是不会存储数据，同时，也是不会被删除的。</p><p>然后再看图片右边的部分，<strong>当链表有2个元素的时候</strong>，这时LockFreeLinkedListHead节点的next指针才是第一个节点，而Head的prev指针则是指向尾结点。</p><p>实际上，寻常的循环双向链表是可以在首尾添加元素的，同时也支持“正向遍历、逆向遍历”的。但Channel内部的这个数据结构只能在末尾添加，而它遍历的顺序则是从队首开始的。这样的设计，就让它的行为在变成了先进先出<strong>单向队列</strong>的同时，还实现了队尾添加操作，只需要O(1)的时间复杂度。</p><p><img src=\"https://static001.geekbang.org/resource/image/47/c4/479f6fcb5cf2a9eb2f56951546eefdc4.jpg?wh=2000x683\" alt=\"\"></p><p>可以说，正是因为LockFreeLinkedList这个数据结构，我们才能使用Channel实现CSP通信模型。</p><p>好，在弄清楚LockFreeLinkedList这个数据结构以后，Channel后续的源码分析就很简单了。让我们来分别分析一下Channel的send()、receive()的流程。</p><h2>发送和接收的流程</h2><p>我们回过头来看代码段1当中的逻辑，我们分别启动了两个协程，在这两个协程中，我们分别发送了三次数据，也接收了三次数据。程序首先会执行send()，由于Channel在默认情况下容量是0，所以，send()首先会被挂起。让我们来看看这部分的逻辑：</p><pre><code class=\"language-plain\">// 代码段5\n\npublic final override suspend fun send(element: E) {\n    // 1\n    if (offerInternal(element) === OFFER_SUCCESS) return\n    // 2\n    return sendSuspend(element)\n}\n\nprotected open fun offerInternal(element: E): Any {\n    while (true) {\n        // 3\n        val receive = takeFirstReceiveOrPeekClosed() ?: return OFFER_FAILE\n        // 省略\n    }\n}\n\nprivate suspend fun sendSuspend(element: E): Unit = suspendCancellableCoroutineReusable sc@ { cont -&gt;\n    loop@ while (true) {\n        if (isFullImpl) {\n            // 4\n            val send = if (onUndeliveredElement == null)\n                SendElement(element, cont) else\n                SendElementWithUndeliveredHandler(element, cont, onUndeliveredElement)\n            val enqueueResult = enqueueSend(send)\n            when {\n                enqueueResult == null -&gt; {\n                    // 5\n                    cont.removeOnCancellation(send)\n                    return@sc\n                }\n                enqueueResult is Closed&lt;*&gt; -&gt; {\n                }\n                enqueueResult === ENQUEUE_FAILED -&gt; {} \n                enqueueResult is Receive&lt;*&gt; -&gt; {} \n                else -&gt; error(\"enqueueSend returned $enqueueResult\")\n            }\n        }\n        // 省略\n    }\n}\n</code></pre><p>上面的挂起函数send()分为两个部分：</p><ul>\n<li>注释1，尝试向Channel发送数据，如果这时候Channel已经有了消费者，那么if就会为true，send()方法就会return。不过，按照代码段1的逻辑，首次调用send()的时候，Channel还不存在消费者，因此在注释3处，尝试从LockFreeLinkedList取出消费者是不可能的。所以，程序会继续执行注释2处的逻辑。</li>\n<li>注释2，会调用挂起函数sendSuspend()，它是由高阶函数suspendCancellableCoroutineReusable{} 实现的。我们看它的名字就能知道，它跟suspendCancellableCoroutine{} 是类似的（如果你有些忘了，可以回过头去看看<a href=\"https://time.geekbang.org/column/article/497868\">加餐五</a>）。另外，请留意下这个方法的注释4，它会将发送的元素封装成SendElement对象，然后调用enqueueSend()方法，将其添加到LockFreeLinkedList这个队列的末尾。如果enqueueSend()执行成功了，就会执行注释5，注册一个回调，用于将SendElement从队列中移除掉。</li>\n</ul><p>如果你足够细心的话，你会发现这整个流程并没有涉及到resume的调用，因此，这也意味着sendSuspend()会一直被挂起，而这就意味着send()会一直被挂起！那么，问题来了，<strong>send()会在什么时候被恢复</strong>？</p><p>答案当然是：<strong>receive()被调用的时候</strong>！</p><pre><code class=\"language-plain\">// 代码段6\n\npublic final override suspend fun receive(): E {\n    // 1\n    val result = pollInternal()\n\n    @Suppress(\"UNCHECKED_CAST\")\n    if (result !== POLL_FAILED &amp;&amp; result !is Closed&lt;*&gt;) return result as E\n    // 2\n    return receiveSuspend(RECEIVE_THROWS_ON_CLOSE)\n}\n\nprotected open fun pollInternal(): Any? {\n    while (true) {\n        // 3\n        val send = takeFirstSendOrPeekClosed() ?: return POLL_FAILED\n        val token = send.tryResumeSend(null)\n        if (token != null) {\n            assert { token === RESUME_TOKEN }\n            //4\n            send.completeResumeSend()\n            return send.pollResult\n        }\n\n        send.undeliveredElement()\n    }\n}\n\n// CancellableContinuationImpl\nprivate fun dispatchResume(mode: Int) {\n    if (tryResume()) return \n    // 5\n    dispatch(mode)\n}\n\ninternal fun &lt;T&gt; DispatchedTask&lt;T&gt;.dispatch(mode: Int) {\n    // 省略\n    if (!undispatched &amp;&amp; delegate is DispatchedContinuation&lt;*&gt; &amp;&amp; mode.isCancellableMode == resumeMode.isCancellableMode) {\n\n        val dispatcher = delegate.dispatcher\n        val context = delegate.context\n        if (dispatcher.isDispatchNeeded(context)) {\n            // 6\n            dispatcher.dispatch(context, this)\n        } else {\n            resumeUnconfined()\n        }\n    } else {\n        // 省略\n    }\n}\n</code></pre><p>可以看到，挂起函数receive()的逻辑，跟代码段5当中的send()是类似的。</p><ul>\n<li>注释1，尝试从LockFree队列当中找出是否有正在被挂起的<strong>发送方</strong>。具体的逻辑在注释3处，它会从队首开始遍历，寻找Send节点。</li>\n<li>接着上面的代码段1的案例分析，此时我们一定是可以从队列中找到一个Send节点的，因此程序会继续执行注释4处的代码。</li>\n<li>注释4，completeResumeSend()，它最终会调用注释5处的dispatch(mode)，而dispatch(mode)其实就是DispatchedTask的dispatch()，是不是觉得很熟悉？这个DispatchedTask其实就是我们在<a href=\"https://time.geekbang.org/column/article/500420\">第29讲</a>当中分析过的DispatchedTask，这里的dispatch()就是协程体当中的代码在线程执行的时机。最终，它会执行在Java的Executor之上。至此，我们之前被挂起的send()方法，其实就算是恢复了。</li>\n</ul><p>另外，你可以再留意上面的注释2，当LockFree队列当中没有正在挂起的发送方时，它会执行receiveSuspend()，而receiveSuspend()也同样会被挂起：</p><pre><code class=\"language-plain\">private suspend fun &lt;R&gt; receiveSuspend(receiveMode: Int): R = suspendCancellableCoroutineReusable sc@ { cont -&gt;\n    val receive = if (onUndeliveredElement == null)\n        ReceiveElement(cont as CancellableContinuation&lt;Any?&gt;, receiveMode) else\n        ReceiveElementWithUndeliveredHandler(cont as CancellableContinuation&lt;Any?&gt;, receiveMode, onUndeliveredElement)\n    while (true) {\n        if (enqueueReceive(receive)) {\n            removeReceiveOnCancel(cont, receive)\n            return@sc\n        }\n\n        val result = pollInternal()\n        if (result is Closed&lt;*&gt;) {\n            receive.resumeReceiveClosed(result)\n            return@sc\n        }\n        if (result !== POLL_FAILED) {\n            cont.resume(receive.resumeValue(result as E), receive.resumeOnCancellationFun(result as E))\n            return@sc\n        }\n    }\n}\n</code></pre><p>所以，这里的逻辑其实跟之前的sendSuspend()是类似的。首先，它会封装一个ReceiveElement对象，并且将其添加到LockFree队列的末尾，如果添加成功的话，这个receiveSuspend就会继续挂起，这就意味着receive()也会被挂起。而receive()被恢复的时机，其实就对应了代码段5当中注释1的代码：offerInternal(element)。</p><p>至此，Channel的发送和接收流程，我们就都已经分析完了。按照惯例，我们还是通过一个视频来回顾代码的整体执行流程：</p><p><video poster=\"https://media001.geekbang.org/5e802d680a944610923fa5aef8ec195e/snapshots/c0a015f2fc92490487ca71ef5869d1ff-00004.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/4dc6e14-17fe818d116-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/238c705ce5ae4e178b2016740f5e7c2d/cffb3c5afd144013b0ddb3c33bc91d24-f86120202e2c15a5f41d05f11e710bf6-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><h2>小结</h2><p>通过这节课，我们知道，Channel其实是一个线程安全的管道。它最常见的用法，就是实现CSP通信模型。它的核心理念是：<strong>不要共享内存来通信；而是要用通信来共享内存</strong>。而Channel之所以可以用来实现CSP通信模型，主要还是因为它底层用到的数据结构：LockFreeLinkedList。</p><p>LockFreeLinkedList虽然是一个循环双向链表，但在Channel的源码中，它会被当做<strong>先进先出</strong>的单向队列，它只在队列末尾插入节点，而遍历则只正向遍历。</p><p>还有Channel的send()，它会分为两种情况，一种是当前的LockFree队列当中已经有被挂起的<strong>接收方</strong>，这时候，send()会恢复Receive节点的执行，并且将数据发送给对方。第二种情况是：当前队列当中没有被挂起的接收方，这时候send()就会被挂起，而被发送的数据会被封装成SendElement对象插入到队列的末尾，等待被下次的receive()恢复执行。</p><p>而Channel的receive()，也是分为两种情况，一种是当前的LockFree队列当中已经存在被挂起的<strong>发送方</strong>，这时候receive()会恢复Send节点的执行，并且取出Send节点当中带过来的数据。第二种情况是：当前队列没有被挂起的发送方，这时候receive()就会被挂起，同时它也会被封装成一个ReceiveElement对象插入到队列的末尾，等待被下次的send()恢复执行。</p><p>其实，Kotlin推崇CSP模型进行并发的原因还有很多，比如门槛低、可读性高、扩展性好，还有一点是会被很多人提到的：不容易发生死锁。</p><p>不过，这里需要特别注意的是，CSP场景下的并发模型，并非不可能发生死锁，在一些特殊场景下，它也是可能发生死锁的，比如：通信死锁（Communication Deadlock）。因此，CSP也并不是解决所有并发问题的万能解药，我们还是要具体问题具体分析。</p><h2>思考题</h2><p>在课程的开头，我们分析了Channel一共有四种实现方式：RendezvousChannel、ArrayChannel、ConflatedChannel、LinkedListChannel，请问你能结合今天学习的知识，分析LinkedListChannel的原理吗？</p><pre><code class=\"language-plain\">internal open class LinkedListChannel&lt;E&gt;(onUndeliveredElement: OnUndeliveredElement&lt;E&gt;?) : AbstractChannel&lt;E&gt;(onUndeliveredElement) {\n    protected final override val isBufferAlwaysEmpty: Boolean get() = true\n    protected final override val isBufferEmpty: Boolean get() = true\n    protected final override val isBufferAlwaysFull: Boolean get() = false\n    protected final override val isBufferFull: Boolean get() = false\n\n    protected override fun offerInternal(element: E): Any {\n        while (true) {\n            val result = super.offerInternal(element)\n            when {\n                result === OFFER_SUCCESS -&gt; return OFFER_SUCCESS\n                result === OFFER_FAILED -&gt; { // try to buffer\n                    when (val sendResult = sendBuffered(element)) {\n                        null -&gt; return OFFER_SUCCESS\n                        is Closed&lt;*&gt; -&gt; return sendResult\n                    }\n                    // otherwise there was receiver in queue, retry super.offerInternal\n                }\n                result is Closed&lt;*&gt; -&gt; return result\n                else -&gt; error(\"Invalid offerInternal result $result\")\n            }\n        }\n    }\n\n    protected override fun offerSelectInternal(element: E, select: SelectInstance&lt;*&gt;): Any {\n        while (true) {\n            val result = if (hasReceiveOrClosed)\n                super.offerSelectInternal(element, select) else\n                (select.performAtomicTrySelect(describeSendBuffered(element)) ?: OFFER_SUCCESS)\n            when {\n                result === ALREADY_SELECTED -&gt; return ALREADY_SELECTED\n                result === OFFER_SUCCESS -&gt; return OFFER_SUCCESS\n                result === OFFER_FAILED -&gt; {} // retry\n                result === RETRY_ATOMIC -&gt; {} // retry\n                result is Closed&lt;*&gt; -&gt; return result\n                else -&gt; error(\"Invalid result $result\")\n            }\n        }\n    }\n}\n</code></pre>","neighbors":{"left":{"article_title":"30 | CoroutineScope是如何管理协程的？","id":501702},"right":{"article_title":"32 | 图解Flow：原来你是只纸老虎？","id":503629}},"comments":[]}