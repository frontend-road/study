{"id":131720,"title":"53 | 设计大型DMP系统（下）：SSD拯救了所有的DBA","content":"<p>上一讲里，根据DMP系统的各个应用场景，我们从抽象的原理层面，选择了AeroSpike作为KV数据库，Kafka作为数据管道，Hadoop/Hive来作为数据仓库。</p><p>不过呢，肯定有不信邪的工程师会问，为什么MongoDB，甚至是MySQL这样的文档数据库或者传统的关系型数据库不适用呢？为什么不能通过优化SQL、添加缓存这样的调优手段，解决这个问题呢？</p><p>今天DMP的下半场，我们就从数据库实现的原理，一起来看一看，这背后的原因。如果你能弄明白今天的这些更深入、更细节的原理，对于什么场景使用什么数据库，就会更加胸有成竹，而不是只有跑了大量的性能测试才知道。下次做数据库选型的时候，你就可以“以理服人”了。</p><h2>关系型数据库：不得不做的随机读写</h2><p>我们先来想一想，如果现在让你自己写一个最简单的关系型数据库，你的数据要怎么存放在硬盘上？</p><p>最简单最直观的想法是，用一个CSV文件格式。一个文件就是一个数据表。文件里面的每一行就是这个表里面的一条记录。如果要修改数据库里面的某一条记录，那么我们要先找到这一行，然后直接去修改这一行的数据。读取数据也是一样的。</p><p>要找到这样数据，最笨的办法自然是一行一行读，也就是遍历整个CSV文件。不过这样的话，相当于随便读取任何一条数据都要扫描全表，太浪费硬盘的吞吐量了。那怎么办呢？我们可以试试给这个CSV文件加一个索引。比如，给数据的行号加一个索引。如果你学过数据库原理或者算法和数据结构，那你应该知道，通过B+树多半是可以来建立这样一个索引的。</p><!-- [[[read_end]]] --><p>索引里面没有一整行的数据，只有一个映射关系，这个映射关系可以让行号直接从硬盘的某个位置去读。所以，索引比起数据小很多。我们可以把索引加载到内存里面。即使不在内存里面，要找数据的时候快速遍历一下整个索引，也不需要读太多的数据。</p><p>加了索引之后，我们要读取特定的数据，就不用去扫描整个数据表文件了。直接从特定的硬盘位置，就可以读到想要的行。索引不仅可以索引行号，还可以索引某个字段。我们可以创建很多个不同的独立的索引。写SQL的时候，where子句后面的查询条件可以用到这些索引。</p><p>不过，这样的话，写入数据的时候就会麻烦一些。我们不仅要在数据表里面写入数据，对于所有的索引也都需要进行更新。这个时候，写入一条数据就要触发好几个随机写入的更新。</p><p><img src=\"https://static001.geekbang.org/resource/image/f3/3c/f3c01bc2de99dbb83ad17cef1fb38a3c.jpeg?wh=2629*2026\" alt=\"\"></p><p>在这样一个数据模型下，查询操作很灵活。无论是根据哪个字段查询，只要有索引，我们就可以通过一次随机读，很快地读到对应的数据。但是，这个灵活性也带来了一个很大的问题，那就是无论干点什么，都有大量的随机读写请求。而随机读写请求，如果请求最终是要落到硬盘上，特别是HDD硬盘的话，我们就很难做到高并发了。毕竟HDD硬盘只有100左右的QPS。</p><p>而这个随时添加索引，可以根据任意字段进行查询，这样表现出的灵活性，又是我们的DMP系统里面不太需要的。DMP的KV数据库主要的应用场景，是根据主键的随机查询，不需要根据其他字段进行筛选查询。数据管道的需求，则只需要不断追加写入和顺序读取就好了。即使进行数据分析的数据仓库，通常也不是根据字段进行数据筛选，而是全量扫描数据进行分析汇总。</p><p>后面的两个场景还好说，大不了我们让程序去扫描全表或者追加写入。但是，在KV数据库这个需求上，刚才这个最简单的关系型数据库的设计，就会面临大量的随机写入和随机读取的挑战。</p><p>所以，在实际的大型系统中，大家都会使用专门的分布式KV数据库，来满足这个需求。那么下面，我们就一起来看一看，Facebook开源的Cassandra的数据存储和读写是怎么做的，这些设计是怎么解决高并发的随机读写问题的。</p><h2>Cassandra：顺序写和随机读</h2><h3>Cassandra的数据模型</h3><p>作为一个分布式的KV数据库，Cassandra的键一般被称为Row Key。其实就是一个16到36个字节的字符串。每一个Row Key对应的值其实是一个哈希表，里面可以用键值对，再存入很多你需要的数据。</p><p>Cassandra本身不像关系型数据库那样，有严格的Schema，在数据库创建的一开始就定义好了有哪些列（Column）。但是，它设计了一个叫作列族（Column Family）的概念，我们需要把经常放在一起使用的字段，放在同一个列族里面。比如，DMP里面的人口属性信息，我们可以把它当成是一个列族。用户的兴趣信息，可以是另外一个列族。这样，既保持了不需要严格的Schema这样的灵活性，也保留了可以把常常一起使用的数据存放在一起的空间局部性。</p><p>往Cassandra的里面读写数据，其实特别简单，就好像是在一个巨大的分布式的哈希表里面写数据。我们指定一个Row Key，然后插入或者更新这个Row Key的数据就好了。</p><h3>Cassandra的写操作</h3><p><img src=\"https://static001.geekbang.org/resource/image/02/58/02d58b12403f7907975e00549a008c58.jpeg?wh=2629*1486\" alt=\"\"></p><center><span class=\"reference\">Cassandra只有顺序写入，没有随机写入</span></center><p>Cassandra解决随机写入数据的解决方案，简单来说，就叫作“不随机写，只顺序写”。对于Cassandra数据库的写操作，通常包含两个动作。第一个是往磁盘上写入一条提交日志（Commit Log）。另一个操作，则是直接在内存的数据结构上去更新数据。后面这个往内存的数据结构里面的数据更新，只有在提交日志写成功之后才会进行。每台机器上，都有一个可靠的硬盘可以让我们去写入提交日志。写入提交日志都是顺序写（Sequential Write），而不是随机写（Random Write），这使得我们最大化了写入的吞吐量。</p><p>如果你不明白这是为什么，可以回到<a href=\"https://time.geekbang.org/column/article/118191\">第47讲</a>，看看硬盘的性能评测。无论是HDD硬盘还是SSD硬盘，顺序写入都比随机写入要快得多。</p><p>内存的空间比较有限，一旦内存里面的数据量或者条目超过一定的限额，Cassandra就会把内存里面的数据结构dump到硬盘上。这个Dump的操作，也是顺序写而不是随机写，所以性能也不会是一个问题。除了Dump的数据结构文件，Cassandra还会根据row key来生成一个索引文件，方便后续基于索引来进行快速查询。</p><p>随着硬盘上的Dump出来的文件越来越多，Cassandra会在后台进行文件的对比合并。在很多别的KV数据库系统里面，也有类似这种的合并动作，比如AeroSpike或者Google的BigTable。这些操作我们一般称之为Compaction。合并动作同样是顺序读取多个文件，在内存里面合并完成，再Dump出来一个新的文件。整个操作过程中，在硬盘层面仍然是顺序读写。</p><h3>Cassandra的读操作</h3><p><img src=\"https://static001.geekbang.org/resource/image/68/b0/68855c2861f07417bbc2eb64672d36b0.jpeg?wh=2629*1516\" alt=\"\"></p><center><span class=\"reference\">Cassandra的读请求，会通过缓存、BloomFilter进行两道过滤，尽可能避免数据请求命中硬盘</span></center><p>当我们要从Cassandra读数据的时候，会从内存里面找数据，再从硬盘读数据，然后把两部分的数据合并成最终结果。这些硬盘上的文件，在内存里面会有对应的Cache，只有在Cache里面找不到，我们才会去请求硬盘里面的数据。</p><p>如果不得不访问硬盘，因为硬盘里面可能Dump了很多个不同时间点的内存数据的快照。所以，找数据的时候，我们也是按照时间从新的往旧的里面找。</p><p>这也就带来另外一个问题，我们可能要查询很多个Dump文件，才能找到我们想要的数据。所以，Cassandra在这一点上又做了一个优化。那就是，它会为每一个Dump的文件里面所有Row Key生成一个BloomFilter，然后把这个BloomFilter放在内存里面。这样，如果想要查询的Row Key在数据文件里面不存在，那么99%以上的情况下，它会被BloomFilter过滤掉，而不需要访问硬盘。</p><p>这样，只有当数据在内存里面没有，并且在硬盘的某个特定文件上的时候，才会触发一次对于硬盘的读请求。</p><h2>SSD：DBA们的大救星</h2><p>Cassandra是Facebook在2008年开源的。那个时候，SSD硬盘还没有那么普及。可以看到，它的读写设计充分考虑了硬件本身的特性。在写入数据进行持久化上，Cassandra没有任何的随机写请求，无论是Commit Log还是Dump，全部都是顺序写。</p><p>在数据读的请求上，最新写入的数据都会更新到内存。如果要读取这些数据，会优先从内存读到。这相当于是一个使用了LRU的缓存机制。只有在万般无奈的情况下，才会有对于硬盘的随机读请求。即使在这样的情况下，Cassandra也在文件之前加了一层BloomFilter，把本来因为Dump文件带来的需要多次读硬盘的问题，简化成多次内存读和一次硬盘读。</p><p>这些设计，使得Cassandra即使是在HDD硬盘上，也能有不错的访问性能。因为所有的写入都是顺序写或者写入到内存，所以，写入可以做到高并发。HDD硬盘的吞吐率还是很不错的，每秒可以写入100MB以上的数据，如果一条数据只有1KB，那么10万的WPS（Writes per seconds）也是能够做到的。这足够支撑我们DMP期望的写入压力了。</p><p>而对于数据的读，就有一些挑战了。如果数据读请求有很强的局部性，那我们的内存就能搞定DMP需要的访问量。</p><p>但是，问题就出在这个局部性上。DMP的数据访问分布，其实是缺少局部性的。你仔细想一想DMP的应用场景就明白了。DMP里面的Row Key都是用户的唯一标识符。普通用户的上网时长怎么会有局部性呢？每个人上网的时间和访问网页的次数就那么多。上网多的人，一天最多也就24小时。大部分用户一天也要上网2～3小时。我们没办法说，把这些用户的数据放在内存里面，那些用户不放。</p><p><img src=\"https://static001.geekbang.org/resource/image/cf/ca/cf55146f8cf79029af6d1f86f3de86ca.jpeg?wh=2086*376\" alt=\"\"></p><center><span class=\"reference\">DMP系统，只有根据国家和时区不同有比较明显的局部性，是局部性不强的系统</span></center><p>那么，我们可不可能有一定的时间局部性呢？如果是Facebook那样的全球社交网络，那可能还有一定的时间局部性。毕竟不同国家的人的时区不一样。我们可以说，在印度人民的白天，把印度人民的数据加载到内存里面，美国人民的数据就放在硬盘上。到了印度人民的晚上，再把美国人民的数据换到内存里面来。</p><p>如果你的主要业务是在国内，那这个时间局部性就没有了。大家的上网高峰时段，都是在早上上班路上、中午休息的时候以及晚上下班之后的时间，没有什么区分度。</p><p>面临这个情况，如果你们的CEO或者CTO问你，是不是可以通过优化程序来解决这个问题？如果你没有仔细从数据分布和原理的层面思考这个问题，而直接一口答应下来，那你可能之后要头疼了，因为这个问题很有可能是搞不定的。</p><p>因为缺少了时间局部性，我们内存的缓存能够起到的作用就很小了，大部分请求最终还是要落到HDD硬盘的随机读上。但是，HDD硬盘的随机读的性能太差了，我们在<a href=\"https://time.geekbang.org/column/article/116104\">第45讲</a>看过，也就是100QPS左右。而如果全都放内存，那就太贵了，成本在HDD硬盘100倍以上。</p><p>不过，幸运的是，从2010年开始，SSD硬盘的大规模商用帮助我们解决了这个问题。它的价格在HDD硬盘的10倍，但是随机读的访问能力在HDD硬盘的百倍以上。也就是说，用上了SSD硬盘，我们可以用1/10的成本获得和内存同样的QPS。同样的价格的SSD硬盘，容量则是内存的几十倍，也能够满足我们的需求，用较低的成本存下整个互联网用户信息。</p><p>不夸张地说，过去十年的“大数据”“高并发”“千人千面”，有一半的功劳应该归在让SSD容量不断上升、价格不断下降的硬盘产业上。</p><p>回到我们看到的Cassandra的读写设计，你会发现，Cassandra的写入机制完美匹配了我们在第46和47讲所说的SSD硬盘的优缺点。</p><p>在数据写入层面，Cassandra的数据写入都是Commit Log的顺序写入，也就是不断地在硬盘上往后追加内容，而不是去修改现有的文件内容。一旦内存里面的数据超过一定的阈值，Cassandra又会完整地Dump一个新文件到文件系统上。这同样是一个追加写入。</p><p>数据的对比和紧凑化（Compaction），同样是读取现有的多个文件，然后写一个新的文件出来。写入操作只追加不修改的特性，正好天然地符合SSD硬盘只能按块进行擦除写入的操作。在这样的写入模式下，Cassandra用到的SSD硬盘，不需要频繁地进行后台的Compaction，能够最大化SSD硬盘的使用寿命。这也是为什么，Cassandra在SSD硬盘普及之后，能够获得进一步快速发展。</p><h2>总结延伸</h2><p>好了，关于DMP和存储器的内容，讲到这里就差不多了。希望今天的这一讲，能够让你从Cassandra的数据库实现的细节层面，彻底理解怎么运用好存储器的性能特性和原理。</p><p>传统的关系型数据库，我们把一条条数据存放在一个地方，同时再把索引存放在另外一个地方。这样的存储方式，其实很方便我们进行单次的随机读和随机写，数据的存储也可以很紧凑。但是问题也在于此，大部分的SQL请求，都会带来大量的随机读写的请求。这使得传统的关系型数据库，其实并不适合用在真的高并发的场景下。</p><p>我们的DMP需要的访问场景，其实没有复杂的索引需求，但是会有比较高的并发性。我带你一看了Facebook开源的Cassandra这个分布式KV数据库的读写设计。通过在追加写入Commit Log和更新内存，Cassandra避开了随机写的问题。内存数据的Dump和后台的对比合并，同样也都避开了随机写的问题，使得Cassandra的并发写入性能极高。</p><p>在数据读取层面，通过内存缓存和BloomFilter，Cassandra已经尽可能地减少了需要随机读取硬盘里面数据的情况。不过挑战在于，DMP系统的局部性不强，使得我们最终的随机读的请求还是要到硬盘上。幸运的是，SSD硬盘在数据海量增长的那几年里价格不断下降，使得我们最终通过SSD硬盘解决了这个问题。</p><p>而SSD硬盘本身的擦除后才能写入的机制，正好非常适合Cassandra的数据读写模式，最终使得Cassandra在SSD硬盘普及之后得到了更大的发展。</p><h2>推荐阅读</h2><p>今天的推荐阅读，是一篇相关的论文。我推荐你去读一读<a href=\"https://www.cs.cornell.edu/projects/ladis2009/papers/lakshman-ladis2009.pdf\">Cassandra - A Decentralized Structured Storage System</a>。读完这篇论文，一方面你会对分布式KV数据库的设计原则有所了解，了解怎么去做好数据分片、故障转移、数据复制这些机制；另一方面，你可以看到基于内存和硬盘的不同存储设备的特性，Cassandra是怎么有针对性地设计数据读写和持久化的方式的。</p><h2>课后思考</h2><p>除了MySQL这样的关系型数据库，还有Cassandra这样的分布式KV数据库。实际上，在海量数据分析的过程中，还有一种常见的数据库，叫作列式存储的OLAP的数据库，比如<a href=\"https://clickhouse.yandex/\">Clickhouse</a>。你可以研究一下，Clickhouse这样的数据库里面的数据是怎么存储在硬盘上的。</p><p>欢迎把你研究的结果写在留言区，和大家一起分享、交流。如果觉得有帮助，你也可以把这篇文章分享给你的朋友，和他一起讨论、学习。</p>","comments":[{"had_liked":false,"id":130830,"user_name":"xindoo","can_delete":false,"product_type":"c1","uid":1101718,"ip_address":"","ucode":"AEAF3208E644BC","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/96/251c0cee.jpg","comment_is_top":false,"comment_ctime":1567557889,"is_pvip":true,"replies":[{"id":"51043","content":"哈哈，其实在10-15年这段时间，这样的性能提升和解决方案是常态","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1568446458,"ip_address":"","comment_id":130830,"utype":1}],"discussion_count":3,"race_medal":0,"score":"160481347841","product_id":100026001,"comment_content":"我想起来一个段子，某大厂对外宣称把mysql的性能提升了十几倍，其实是改用了SSD。","like_count":38,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466145,"discussion_content":"哈哈，其实在10-15年这段时间，这样的性能提升和解决方案是常态","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568446458,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1325297,"avatar":"https://static001.geekbang.org/account/avatar/00/14/38/f1/996a070d.jpg","nickname":"LW","note":"","ucode":"89820332658E98","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312548,"discussion_content":"砸钱也是性能提升的重要手段啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602731858,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1612275,"avatar":"https://static001.geekbang.org/account/avatar/00/18/99/f3/ca2c0dc6.jpg","nickname":"我好读","note":"","ucode":"34C4858F446BEF","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297914,"discussion_content":"硬件的提升也叫提升，狭隘了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597110469,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130874,"user_name":"免费的人","can_delete":false,"product_type":"c1","uid":1032106,"ip_address":"","ucode":"2B12D8ED63C564","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bf/aa/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1567563032,"is_pvip":false,"replies":[{"id":"51161","content":"只追加不修改，一般操作系统和文件系统会为你处理好顺序写的问题的。<br><br>修改特定文件中间的内容，那自然就是随机写啦。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1568548355,"ip_address":"","comment_id":130874,"utype":1}],"discussion_count":2,"race_medal":0,"score":"134711549208","product_id":100026001,"comment_content":"用户态程序 怎么控制顺序写还是随机写？","like_count":32,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466170,"discussion_content":"只追加不修改，一般操作系统和文件系统会为你处理好顺序写的问题的。\n\n修改特定文件中间的内容，那自然就是随机写啦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568548355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1793962,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/5f/aa/63e641c1.jpg","nickname":"H","note":"","ucode":"04D7D030245E27","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336573,"discussion_content":"能不能讲讲，什么是随机写，什么是顺序写？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608627269,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239366,"user_name":"学而不思则惘","can_delete":false,"product_type":"c1","uid":1668117,"ip_address":"","ucode":"8ED2B08AA5A755","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJLgibqHsl97Oq3nvnEVz7V3kaGKLmia0Ja8c4yXO7QeLKiakganRJomNGgYToW4RnFs60zibDTHicjE5w/132","comment_is_top":false,"comment_ctime":1596512218,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"44546185178","product_id":100026001,"comment_content":"之前一直没有研究过Cassandra，看了这篇文章才知道，原来和hbase等系列的日志型nosql基本一致，同样的lms树的随机读取效率低，同样的内置布隆过滤器，内置的查询缓存，还有同样的compact，甚至大文件拆分，Google的BigTable还真是影响深远啊","like_count":11},{"had_liked":false,"id":130942,"user_name":"leslie","can_delete":false,"product_type":"c1","uid":1324255,"ip_address":"","ucode":"798E7C1CC98CC2","user_header":"https://static001.geekbang.org/account/avatar/00/14/34/df/64e3d533.jpg","comment_is_top":false,"comment_ctime":1567581460,"is_pvip":false,"replies":[{"id":"51056","content":"欢迎多质疑，我写的内容其实也还是有不少错漏的。<br><br>嗯，其实我用CSV来举例子是希望简化描述问题。MySQL这样得数据库，底层的存储自然不是一个CSV这样的格式。<br><br><br>不过作为一门入门的课程，直接再去讲MySQL里面的存储格式，无论是篇幅还是难度可能对大部分同学都大了一些。<br><br>也许用更简单的数据库，比如SQLite的底层B+树的存储格式可能更合适一些。<br><br>课程内容到今天已经写完了，接下来会把写文章的时间回复掉大家所有的问题，做一些内容的订正，以及根据反馈再发几篇FAQ和加餐。<br>","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1568450318,"ip_address":"","comment_id":130942,"utype":1}],"discussion_count":2,"race_medal":0,"score":"27337385236","product_id":100026001,"comment_content":"      提出一点质疑希望老师不要介意啊，毕竟学习的过程以及和老师交互还是比较愉快：老师用CSV格式去说MYSQL好像不太合适吧，mysql其实很少会导出成CSV格式-oracle的特性，至少5.5和5.6都会导成sql格式，sql server都很少会用这种格式去导成CSV文件-导入不太方便，Oracle倒是这种形式最方便且速度方面最稳定。<br>       老师说马上就要完课了：这门课还有多久啊？真正沉浸学习中发现课程结束的都超快，两门课结合着学习-发现时光如梭，前天刘老师的课刚收尾，老师的课就要结束了；真快。","like_count":7,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466206,"discussion_content":"欢迎多质疑，我写的内容其实也还是有不少错漏的。\n\n嗯，其实我用CSV来举例子是希望简化描述问题。MySQL这样得数据库，底层的存储自然不是一个CSV这样的格式。\n\n\n不过作为一门入门的课程，直接再去讲MySQL里面的存储格式，无论是篇幅还是难度可能对大部分同学都大了一些。\n\n也许用更简单的数据库，比如SQLite的底层B+树的存储格式可能更合适一些。\n\n课程内容到今天已经写完了，接下来会把写文章的时间回复掉大家所有的问题，做一些内容的订正，以及根据反馈再发几篇FAQ和加餐。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568450318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1032106,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/bf/aa/abb7bfe3.jpg","nickname":"免费的人","note":"","ucode":"2B12D8ED63C564","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7726,"discussion_content":"说csv是为了说明关系型数据库的特点吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567653404,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130786,"user_name":"安排","can_delete":false,"product_type":"c1","uid":1260026,"ip_address":"","ucode":"F78CFA9624CAEF","user_header":"https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg","comment_is_top":false,"comment_ctime":1567552094,"is_pvip":false,"replies":[{"id":"51135","content":"可以这样做也可以不这样做。一般来说大部分都不会直接存放物理地址。仍然是通过操作系统的文件系统来管理的。<br><br>B+树序列化地存放在文件里面，反序列化加载的过程就是B+树生成的过程啊。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1568539265,"ip_address":"","comment_id":130786,"utype":1}],"discussion_count":6,"race_medal":0,"score":"27337355870","product_id":100026001,"comment_content":"b+ 树索引中会存储每行数据在硬盘中的物理地址吗？这个物理地址是不是由好几部分组成，比如柱面，磁道，扇区的组合。<br>那B+ 树索引本身又是怎么存放的呢？b+树要存到硬盘上的话需要做特殊的序列化吗？怎么才能保证从硬盘读入索引数据后快速的在内存生成一棵B+树呢？","like_count":7,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466125,"discussion_content":"可以这样做也可以不这样做。一般来说大部分都不会直接存放物理地址。仍然是通过操作系统的文件系统来管理的。\n\nB+树序列化地存放在文件里面，反序列化加载的过程就是B+树生成的过程啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568539265,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1441830,"avatar":"https://static001.geekbang.org/account/avatar/00/16/00/26/a80010f0.jpg","nickname":"JL","note":"","ucode":"07BD8069AE2CBD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":257195,"discussion_content":"&#34;主键索引对应的那颗\n棵b+树直接存储了整行数据(不是数据的地址减少一次寻址)。普通索引存的是主键(通过普通索引查询需要多遍历一棵主键索引)。&#34;\n应该就是clustered index 和 non-clustered index","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1588526625,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1900944,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKDdkdC6WfWDzEVBDuFGic2fohmqyY5Iowias8Hrg90mLDksQxuVYoOP2ribrdu4TQhfb2WPxBymjJHw/132","nickname":"201201091","note":"","ucode":"611DE64AE00F8F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349284,"discussion_content":"btree里放的是<key, (blocknum,offset)>这样的数据，是逻辑地址，可以持久化到磁盘上的。不用重建，直接从磁盘读取上来就行了，接下来是用的文件系统的接口来访问。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1613038261,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1276613,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/gmP4Yh00MZPwNvr4UQdLeXaX3TVyZEEp195S3vD3Sfl1xz5jBr1474Mt6w5OPr0KsrnQObfLRy5PkKNFjSBiasA/132","nickname":"大头爸爸","note":"","ucode":"131E25DB04D222","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217168,"discussion_content":"计算机不可能知道其硬盘的物理地址(柱面，磁道，扇区等)，只可能知道逻辑地址。硬盘会把逻辑地址转换成物理地址。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585523555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1210699,"avatar":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","nickname":"-W.LI-","note":"","ucode":"3556786538664F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7542,"discussion_content":"保证硬盘读入索引数据后快速生成一棵B+树，有对应的B+树生成，树分裂，树合并算法。就和堆可以用数组表示一样。我猜有特定的优化后的数据结构。你知道要是找到答案了回复我下谢谢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567561244,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1210699,"avatar":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","nickname":"-W.LI-","note":"","ucode":"3556786538664F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7540,"discussion_content":"b+树索引存储数据的结构和存储引擎和，是否主键索引有关。innoDB下，主键索引对应的那颗\n棵b+树直接存储了整行数据(不是数据的地址减少一次寻址)。普通索引存的是主键(通过普通索引查询需要多遍历一棵主键索引)。硬盘在物理上实现上就是柱面，磁道，扇区。操作系统才使用时也许是采用逻辑概念的，具体不知。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567560919,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131844,"user_name":"易儿易","can_delete":false,"product_type":"c1","uid":1242864,"ip_address":"","ucode":"B15D1031CA841E","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqLcWH3mSPmhjrs1aGL4b3TqI7xDqWWibM4nYFrRlp0z7FNSWaJz0mqovrgIA7ibmrPt8zRScSfRaqQ/132","comment_is_top":false,"comment_ctime":1567934020,"is_pvip":false,"replies":[{"id":"51049","content":"👍加油","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1568449508,"ip_address":"","comment_id":131844,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14452835908","product_id":100026001,"comment_content":"透过现象看本质，跟着老师的讲解一层层剥离原理，知其然，并知所以然~希望以后自己也能深度分析技术原理进行技术选型，而不是盲从大流以及试试看不行就换……","like_count":4,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466641,"discussion_content":"👍加油","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568449508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169220,"user_name":"山间竹","can_delete":false,"product_type":"c1","uid":1696212,"ip_address":"","ucode":"FA7F16EF01D659","user_header":"https://static001.geekbang.org/account/avatar/00/19/e1/d4/1b5ac51e.jpg","comment_is_top":false,"comment_ctime":1578296014,"is_pvip":false,"replies":[{"id":"68091","content":"山间竹同学，<br><br>你好，Cassandra最新版本的代码我没有那么熟悉。不过早期版本的Cassandra用过很长一段时间，如果我没有记错的话，基本的逻辑是这样的。<br><br>1. 通过Write Ahead Log的方式先把操作写入到日志<br>2. 再写入数据到内存里面<br>3. 内存定期会Dump到磁盘上<br>4. 后台有进程做Compact来减少Dump的数据和日志<br><br>在做Compaction的过程中，顺序写的性能和在线访问的性能都会受一定影响。不过主要是磁盘IO，而不是碎片问题。可以认为Compaction其实就是不停做碎片整理。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1580632873,"ip_address":"","comment_id":169220,"utype":1}],"discussion_count":4,"race_medal":0,"score":"10168230606","product_id":100026001,"comment_content":"我想问一下，Cassandra在hdd上删除重写是个怎么样的机制呢？会不会出现碎片，然后直接影响到顺序大块写？","like_count":3,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480464,"discussion_content":"山间竹同学，\n\n你好，Cassandra最新版本的代码我没有那么熟悉。不过早期版本的Cassandra用过很长一段时间，如果我没有记错的话，基本的逻辑是这样的。\n\n1. 通过Write Ahead Log的方式先把操作写入到日志\n2. 再写入数据到内存里面\n3. 内存定期会Dump到磁盘上\n4. 后台有进程做Compact来减少Dump的数据和日志\n\n在做Compaction的过程中，顺序写的性能和在线访问的性能都会受一定影响。不过主要是磁盘IO，而不是碎片问题。可以认为Compaction其实就是不停做碎片整理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580632873,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1252585,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1c/e9/48cc8f57.jpg","nickname":"小梅子","note":"","ucode":"B9797DE06232D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576079,"discussion_content":"我的理解是，\n1. Casanndra本身有算法，去把重复的数据去重。\n2. Cansandra本身下hdd dump数据时，是通过操作系统的文件系统。文件系统在管理自己的空间（这里是逻辑空间）会自己管理文件系统的碎片。记得windows的文件系统，经常自己要做碎片清零。\n3.文件系统负责把Cansandra要dump的数据写到HDD上。HDD本身有个自己管理程序（一般这是HDD的firmware）。HDD自己会管理脆片。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655272580,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1243901,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fa/fd/ec24cba7.jpg","nickname":"fcb的鱼","note":"","ucode":"88667EBF09CEC0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":164417,"discussion_content":"删除重写实际上没有从磁盘上删除，所以不会有内存碎片一说。因为对rowkkey做了hash，只需要让原rowkey指向新的存储地址就可以了，原数据相当于没有引用就用不到了，不用去做删除。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581174018,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1122034,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1e/f2/453d5f88.jpg","nickname":"seker","note":"","ucode":"9B705F91355873","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1243901,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fa/fd/ec24cba7.jpg","nickname":"fcb的鱼","note":"","ucode":"88667EBF09CEC0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298239,"discussion_content":"对于HDD来说，那就是原数据没有做物理删除，而是通过覆写来“处理掉”这些原数据？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597225430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":164417,"ip_address":""},"score":298239,"extra":""}]}]},{"had_liked":false,"id":249371,"user_name":"Ki","can_delete":false,"product_type":"c1","uid":1470477,"ip_address":"","ucode":"5B675CC101FFC0","user_header":"https://static001.geekbang.org/account/avatar/00/16/70/0d/f4c7a01f.jpg","comment_is_top":false,"comment_ctime":1600612900,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600612900","product_id":100026001,"comment_content":"请问下、怎么快速找到一个软件对应的论文呢、比如我想找kafka的论文、或者是找flink的论文、该怎么找呢","like_count":1},{"had_liked":false,"id":222803,"user_name":"🄽🄸🅇🅄🅂","can_delete":false,"product_type":"c1","uid":1000060,"ip_address":"","ucode":"853763C229A5AA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/7c/8ef14715.jpg","comment_is_top":false,"comment_ctime":1590915267,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590915267","product_id":100026001,"comment_content":"1、BloomFilter过滤掉不存在的数据的读取后，在读存在的数据的时候，还是要去硬盘读，“按照从新到旧的读取方式”，应该如何理解“从新到旧读取”呢？“从新到旧读”，是读一次还是读多次？<br>2、在进行合并compaction的时候，怎么知道合并后的数据地址？是用像前面讲内存的时候，讲到的页映射吗？还是说，合并compaction执行的就是类似MySQL的update操作？如果是这样的话，还是会有insert后，数据地址变动的问题在；","like_count":0},{"had_liked":false,"id":218710,"user_name":"brian","can_delete":false,"product_type":"c1","uid":1117039,"ip_address":"","ucode":"438D60BB6413C3","user_header":"https://static001.geekbang.org/account/avatar/00/11/0b/6f/68cd0614.jpg","comment_is_top":false,"comment_ctime":1589857825,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1589857825","product_id":100026001,"comment_content":"老师，上一讲设计DMP kv数据库是选择 AeroSpike <br>这一讲用Cassandra，两者有什么区别吗？","like_count":0,"discussions":[{"author":{"id":1122034,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1e/f2/453d5f88.jpg","nickname":"seker","note":"","ucode":"9B705F91355873","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298245,"discussion_content":"结合第47讲和53讲的内容来看，Cassandra是支持HDD和SSD的，而Aerospike仅支持SSD","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1597226833,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217310,"user_name":"hshayq","can_delete":false,"product_type":"c1","uid":1237880,"ip_address":"","ucode":"F5435E14BCCD25","user_header":"https://static001.geekbang.org/account/avatar/00/12/e3/78/3321053c.jpg","comment_is_top":false,"comment_ctime":1589463361,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589463361","product_id":100026001,"comment_content":"今天刚看 ddia 中说明 Cassandra 的存储原理，没想到这里也看到了(oﾟvﾟ)ノ","like_count":0},{"had_liked":false,"id":207104,"user_name":"王坤祥","can_delete":false,"product_type":"c1","uid":1003327,"ip_address":"","ucode":"FB988B9F381A33","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4f/3f/6f62f982.jpg","comment_is_top":false,"comment_ctime":1587007048,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1587007048","product_id":100026001,"comment_content":"&gt; SSD 硬盘本身的擦除后才能写入的机制，正好非常适合 Cassandra 的数据读写模式<br><br>各位，有谁帮忙解释下，我怎么get不到这一点呀?","like_count":0,"discussions":[{"author":{"id":1441830,"avatar":"https://static001.geekbang.org/account/avatar/00/16/00/26/a80010f0.jpg","nickname":"JL","note":"","ucode":"07BD8069AE2CBD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":257196,"discussion_content":"因为写是追加写，所以就是不擦除，新的往后面写就行了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588526772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":199954,"user_name":"大头爸爸","can_delete":false,"product_type":"c1","uid":1276613,"ip_address":"","ucode":"131E25DB04D222","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/gmP4Yh00MZPwNvr4UQdLeXaX3TVyZEEp195S3vD3Sfl1xz5jBr1474Mt6w5OPr0KsrnQObfLRy5PkKNFjSBiasA/132","comment_is_top":false,"comment_ctime":1585519264,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1585519264","product_id":100026001,"comment_content":"Cassandra和BigTable是什么区别啊？看了一下基本原理好像是一样的？","like_count":0,"discussions":[{"author":{"id":1122034,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1e/f2/453d5f88.jpg","nickname":"seker","note":"","ucode":"9B705F91355873","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298248,"discussion_content":"Cassandra不仅吸收了Dynamo论文中：如何做分布式、如何做副本复制、故障容错等方面成功的经验。又吸取了Google BigTable中LSM单机引擎层面精华。师出名门 ^_^","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597227020,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":191527,"user_name":"Anthony","can_delete":false,"product_type":"c1","uid":1309908,"ip_address":"","ucode":"9E0C98A9123365","user_header":"https://static001.geekbang.org/account/avatar/00/13/fc/d4/743d3f02.jpg","comment_is_top":false,"comment_ctime":1584779254,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584779254","product_id":100026001,"comment_content":"Cassandra的列族让我想到了es的存储方式，建一个个index来区分不同类型的数据，方便查询和存储","like_count":0},{"had_liked":false,"id":176818,"user_name":"fcb的鱼","can_delete":false,"product_type":"c1","uid":1243901,"ip_address":"","ucode":"88667EBF09CEC0","user_header":"https://static001.geekbang.org/account/avatar/00/12/fa/fd/ec24cba7.jpg","comment_is_top":false,"comment_ctime":1581173756,"is_pvip":false,"replies":[{"id":"68630","content":"fcb的鱼同学，<br><br>你好<br><br>1. 对应比例要看实际的数据访问分布，并没有一个固定答案，其实可以回头重新看看讲存储分层里面的案例，你可以根据你的实际应用场景来估算。<br>内存占用也是要看你的硬件配置，你只配1G内存当然用不了2G对不对<br><br>2. 我不是MySQL的专家，没有仔细研读过MySQL的代码。不过MySQL肯定也会用类似BloomFilter机制，以及必然会有缓存，来减少对于磁盘的访问。以提升整个数据库在实际应用中的表现。","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1581218674,"ip_address":"","comment_id":176818,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1581173756","product_id":100026001,"comment_content":"你好，问下<br>1.Cassandr 数据库在数据读取层面，通过内存缓存+ BloomFilte+硬盘的机制来保证随机读的问题。想问下这个随机读的过程中，请求只查询内存的数据占多大比例呢？在Cassandr数据库的架构里边，这个内存占用率是多少(比如是不是硬盘是10G,内存是1G).这种架构。<br>2.如果mysql在不考虑随机写的场景下，使用这种内存+硬盘的方案是不是也可以的？","like_count":1,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483222,"discussion_content":"fcb的鱼同学，\n\n你好\n\n1. 对应比例要看实际的数据访问分布，并没有一个固定答案，其实可以回头重新看看讲存储分层里面的案例，你可以根据你的实际应用场景来估算。\n内存占用也是要看你的硬件配置，你只配1G内存当然用不了2G对不对\n\n2. 我不是MySQL的专家，没有仔细研读过MySQL的代码。不过MySQL肯定也会用类似BloomFilter机制，以及必然会有缓存，来减少对于磁盘的访问。以提升整个数据库在实际应用中的表现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581218674,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144414,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1571916523,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571916523","product_id":100026001,"comment_content":"只有明白1+1，才可以推到公式，读这篇文章有种酣畅淋漓的感觉，赞赞赞","like_count":0},{"had_liked":false,"id":142491,"user_name":"prader26","can_delete":false,"product_type":"c1","uid":1433707,"ip_address":"","ucode":"5EFFFC374ADECE","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/6b/f61d7466.jpg","comment_is_top":false,"comment_ctime":1571379424,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571379424","product_id":100026001,"comment_content":"cassendra (通过优化随机读取) 和ssd  硬盘可以更好的支持并发。","like_count":0},{"had_liked":false,"id":133418,"user_name":"活的潇洒","can_delete":false,"product_type":"c1","uid":1238830,"ip_address":"","ucode":"666C30CA894754","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/2e/1522a7d6.jpg","comment_is_top":false,"comment_ctime":1568557316,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568557316","product_id":100026001,"comment_content":"坚持到最后、你会收获不一样的自己、加油<br><br>day53 笔记：https:&#47;&#47;www.cnblogs.com&#47;luoahong&#47;p&#47;11514616.html","like_count":1},{"had_liked":false,"id":131114,"user_name":"暴风雪","can_delete":false,"product_type":"c1","uid":1283139,"ip_address":"","ucode":"BF1523D69866FF","user_header":"https://static001.geekbang.org/account/avatar/00/13/94/43/46a7d0a8.jpg","comment_is_top":false,"comment_ctime":1567645826,"is_pvip":false,"replies":[{"id":"51128","content":"谢谢","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1568538153,"ip_address":"","comment_id":131114,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567645826","product_id":100026001,"comment_content":"中途一度落后了20多节课，然后每天都看一两篇再度追上了进度，课程越后面越精彩","like_count":1,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466291,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568538153,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131101,"user_name":"吴宇晨","can_delete":false,"product_type":"c1","uid":1199968,"ip_address":"","ucode":"F8F45B7067DF6D","user_header":"https://static001.geekbang.org/account/avatar/00/12/4f/60/049a20e9.jpg","comment_is_top":false,"comment_ctime":1567644166,"is_pvip":false,"replies":[{"id":"51048","content":"能更具体一点么？","user_name":"作者回复","user_name_real":"徐文浩","uid":"1053568","ctime":1568449498,"ip_address":"","comment_id":131101,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567644166","product_id":100026001,"comment_content":"列式存储是按同一列数据cun","like_count":1,"discussions":[{"author":{"id":1053568,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/80/8de66543.jpg","nickname":"徐文浩","note":"","ucode":"1D39AC564172E9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466285,"discussion_content":"能更具体一点么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568449498,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}