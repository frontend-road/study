{"id":237810,"title":"85 | 开源实战四（中）：剖析Spring框架中用来支持扩展的两种设计模式","content":"<p>上一节课中，我们学习了Spring框架背后蕴藏的一些经典设计思想，比如约定优于配置、低侵入松耦合、模块化轻量级等等。我们可以将这些设计思想借鉴到其他框架开发中，在大的设计层面提高框架的代码质量。这也是我们在专栏中讲解这部分内容的原因。</p><p>除了上一节课中讲到的设计思想，实际上，可扩展也是大部分框架应该具备的一个重要特性。所谓的框架可扩展，我们之前也提到过，意思就是，框架使用者在不修改框架源码的情况下，基于扩展点定制扩展新的功能。</p><p>前面在理论部分，我们也讲到，常用来实现扩展特性的设计模式有：观察者模式、模板模式、职责链模式、策略模式等。今天，我们再剖析Spring框架为了支持可扩展特性用的2种设计模式：观察者模式和模板模式。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>观察者模式在Spring中的应用</h2><p>在前面我们讲到，Java、Google Guava都提供了观察者模式的实现框架。Java提供的框架比较简单，只包含java.util.Observable和java.util.Observer两个类。Google Guava提供的框架功能比较完善和强大：通过EventBus事件总线来实现观察者模式。实际上，Spring也提供了观察者模式的实现框架。今天，我们就再来讲一讲它。</p><!-- [[[read_end]]] --><p>Spring中实现的观察者模式包含三部分：Event事件（相当于消息）、Listener监听者（相当于观察者）、Publisher发送者（相当于被观察者）。我们通过一个例子来看下，Spring提供的观察者模式是怎么使用的。代码如下所示：</p><pre><code>// Event事件\npublic class DemoEvent extends ApplicationEvent {\n  private String message;\n\n  public DemoEvent(Object source, String message) {\n    super(source);\n  }\n\n  public String getMessage() {\n    return this.message;\n  }\n}\n\n// Listener监听者\n@Component\npublic class DemoListener implements ApplicationListener&lt;DemoEvent&gt; {\n  @Override\n  public void onApplicationEvent(DemoEvent demoEvent) {\n    String message = demoEvent.getMessage();\n    System.out.println(message);\n  }\n}\n\n// Publisher发送者\n@Component\npublic class DemoPublisher {\n  @Autowired\n  private ApplicationContext applicationContext;\n\n  public void publishEvent(DemoEvent demoEvent) {\n    this.applicationContext.publishEvent(demoEvent);\n  }\n}\n</code></pre><p>从代码中，我们可以看出，框架使用起来并不复杂，主要包含三部分工作：定义一个继承ApplicationEvent的事件（DemoEvent）；定义一个实现了ApplicationListener的监听器（DemoListener）；定义一个发送者（DemoPublisher），发送者调用ApplicationContext来发送事件消息。</p><p>其中，ApplicationEvent和ApplicationListener的代码实现都非常简单，内部并不包含太多属性和方法。实际上，它们最大的作用是做类型标识之用（继承自ApplicationEvent的类是事件，实现ApplicationListener的类是监听器）。</p><pre><code>public abstract class ApplicationEvent extends EventObject {\n  private static final long serialVersionUID = 7099057708183571937L;\n  private final long timestamp = System.currentTimeMillis();\n\n  public ApplicationEvent(Object source) {\n    super(source);\n  }\n\n  public final long getTimestamp() {\n    return this.timestamp;\n  }\n}\n\npublic class EventObject implements java.io.Serializable {\n    private static final long serialVersionUID = 5516075349620653480L;\n    protected transient Object  source;\n\n    public EventObject(Object source) {\n        if (source == null)\n            throw new IllegalArgumentException(&quot;null source&quot;);\n        this.source = source;\n    }\n\n    public Object getSource() {\n        return source;\n    }\n\n    public String toString() {\n        return getClass().getName() + &quot;[source=&quot; + source + &quot;]&quot;;\n    }\n}\n\npublic interface ApplicationListener&lt;E extends ApplicationEvent&gt; extends EventListener {\n  void onApplicationEvent(E var1);\n}\n</code></pre><p>在前面讲到观察者模式的时候，我们提到，观察者需要事先注册到被观察者（JDK的实现方式）或者事件总线（EventBus的实现方式）中。那在Spring的实现中，观察者注册到了哪里呢？又是如何注册的呢？</p><p>我想你应该猜到了，我们把观察者注册到了ApplicationContext对象中。这里的ApplicationContext就相当于Google EventBus框架中的“事件总线”。不过，稍微提醒一下，ApplicationContext这个类并不只是为观察者模式服务的。它底层依赖BeanFactory（IOC的主要实现类），提供应用启动、运行时的上下文信息，是访问这些信息的最顶层接口。</p><p>实际上，具体到源码来说，ApplicationContext只是一个接口，具体的代码实现包含在它的实现类AbstractApplicationContext中。我把跟观察者模式相关的代码，摘抄到了下面。你只需要关注它是如何发送事件和注册监听者就好，其他细节不需要细究。</p><pre><code>public abstract class AbstractApplicationContext extends ... {\n  private final Set&lt;ApplicationListener&lt;?&gt;&gt; applicationListeners;\n  \n  public AbstractApplicationContext() {\n    this.applicationListeners = new LinkedHashSet();\n    //...\n  }\n  \n  public void publishEvent(ApplicationEvent event) {\n    this.publishEvent(event, (ResolvableType)null);\n  }\n\n  public void publishEvent(Object event) {\n    this.publishEvent(event, (ResolvableType)null);\n  }\n\n  protected void publishEvent(Object event, ResolvableType eventType) {\n    //...\n    Object applicationEvent;\n    if (event instanceof ApplicationEvent) {\n      applicationEvent = (ApplicationEvent)event;\n    } else {\n      applicationEvent = new PayloadApplicationEvent(this, event);\n      if (eventType == null) {\n        eventType = ((PayloadApplicationEvent)applicationEvent).getResolvableType();\n      }\n    }\n\n    if (this.earlyApplicationEvents != null) {\n      this.earlyApplicationEvents.add(applicationEvent);\n    } else {\n      this.getApplicationEventMulticaster().multicastEvent(\n            (ApplicationEvent)applicationEvent, eventType);\n    }\n\n    if (this.parent != null) {\n      if (this.parent instanceof AbstractApplicationContext) {\n        ((AbstractApplicationContext)this.parent).publishEvent(event, eventType);\n      } else {\n        this.parent.publishEvent(event);\n      }\n    }\n  }\n  \n  public void addApplicationListener(ApplicationListener&lt;?&gt; listener) {\n    Assert.notNull(listener, &quot;ApplicationListener must not be null&quot;);\n    if (this.applicationEventMulticaster != null) {\n    this.applicationEventMulticaster.addApplicationListener(listener);\n    } else {\n      this.applicationListeners.add(listener);\n    }  \n  }\n  \n  public Collection&lt;ApplicationListener&lt;?&gt;&gt; getApplicationListeners() {\n    return this.applicationListeners;\n  }\n  \n  protected void registerListeners() {\n    Iterator var1 = this.getApplicationListeners().iterator();\n\n    while(var1.hasNext()) {\n      ApplicationListener&lt;?&gt; listener = (ApplicationListener)var1.next();     this.getApplicationEventMulticaster().addApplicationListener(listener);\n    }\n\n    String[] listenerBeanNames = this.getBeanNamesForType(ApplicationListener.class, true, false);\n    String[] var7 = listenerBeanNames;\n    int var3 = listenerBeanNames.length;\n\n    for(int var4 = 0; var4 &lt; var3; ++var4) {\n      String listenerBeanName = var7[var4];\n      this.getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);\n    }\n\n    Set&lt;ApplicationEvent&gt; earlyEventsToProcess = this.earlyApplicationEvents;\n    this.earlyApplicationEvents = null;\n    if (earlyEventsToProcess != null) {\n      Iterator var9 = earlyEventsToProcess.iterator();\n\n      while(var9.hasNext()) {\n        ApplicationEvent earlyEvent = (ApplicationEvent)var9.next();\n        this.getApplicationEventMulticaster().multicastEvent(earlyEvent);\n      }\n    }\n  }\n}\n</code></pre><p>从上面的代码中，我们发现，真正的消息发送，实际上是通过ApplicationEventMulticaster这个类来完成的。这个类的源码我只摘抄了最关键的一部分，也就是multicastEvent()这个消息发送函数。不过，它的代码也并不复杂，我就不多解释了。这里我稍微提示一下，它通过线程池，支持异步非阻塞、同步阻塞这两种类型的观察者模式。</p><pre><code>public void multicastEvent(ApplicationEvent event) {\n  this.multicastEvent(event, this.resolveDefaultEventType(event));\n}\n\npublic void multicastEvent(final ApplicationEvent event, ResolvableType eventType) {\n  ResolvableType type = eventType != null ? eventType : this.resolveDefaultEventType(event);\n  Iterator var4 = this.getApplicationListeners(event, type).iterator();\n\n  while(var4.hasNext()) {\n    final ApplicationListener&lt;?&gt; listener = (ApplicationListener)var4.next();\n    Executor executor = this.getTaskExecutor();\n    if (executor != null) {\n      executor.execute(new Runnable() {\n        public void run() {\n          SimpleApplicationEventMulticaster.this.invokeListener(listener, event);\n        }\n      });\n    } else {\n      this.invokeListener(listener, event);\n    }\n  }\n\n}\n</code></pre><p>借助Spring提供的观察者模式的骨架代码，如果我们要在Spring下实现某个事件的发送和监听，只需要做很少的工作，定义事件、定义监听器、往ApplicationContext中发送事件就可以了，剩下的工作都由Spring框架来完成。实际上，这也体现了Spring框架的扩展性，也就是在不需要修改任何代码的情况下，扩展新的事件和监听。</p><h2>模板模式在Spring中的应用</h2><p>刚刚讲的是观察者模式在Spring中的应用，现在我们再讲下模板模式。</p><p>我们来看下一下经常在面试中被问到的一个问题：请你说下Spring Bean的创建过程包含哪些主要的步骤。这其中就涉及模板模式。它也体现了Spring的扩展性。利用模板模式，Spring能让用户定制Bean的创建过程。</p><p>Spring Bean的创建过程，可以大致分为两大步：对象的创建和对象的初始化。</p><p>对象的创建是通过反射来动态生成对象，而不是new方法。不管是哪种方式，说白了，总归还是调用构造函数来生成对象，没有什么特殊的。对象的初始化有两种实现方式。一种是在类中自定义一个初始化函数，并且通过配置文件，显式地告知Spring，哪个函数是初始化函数。我举了一个例子解释一下。如下所示，在配置文件中，我们通过init-method属性来指定初始化函数。</p><pre><code>public class DemoClass {\n  //...\n  \n  public void initDemo() {\n    //...初始化..\n  }\n}\n\n// 配置：需要通过init-method显式地指定初始化方法\n&lt;bean id=&quot;demoBean&quot; class=&quot;com.xzg.cd.DemoClass&quot; init-method=&quot;initDemo&quot;&gt;&lt;/bean&gt;\n</code></pre><p>这种初始化方式有一个缺点，初始化函数并不固定，由用户随意定义，这就需要Spring通过反射，在运行时动态地调用这个初始化函数。而反射又会影响代码执行的性能，那有没有替代方案呢？</p><p>Spring提供了另外一个定义初始化函数的方法，那就是让类实现Initializingbean接口。这个接口包含一个固定的初始化函数定义（afterPropertiesSet()函数）。Spring在初始化Bean的时候，可以直接通过bean.afterPropertiesSet()的方式，调用Bean对象上的这个函数，而不需要使用反射来调用了。我举个例子解释一下，代码如下所示。</p><pre><code>public class DemoClass implements InitializingBean{\n  @Override\n  public void afterPropertiesSet() throws Exception {\n    //...初始化...      \n  }\n}\n\n// 配置：不需要显式地指定初始化方法\n&lt;bean id=&quot;demoBean&quot; class=&quot;com.xzg.cd.DemoClass&quot;&gt;&lt;/bean&gt;\n</code></pre><p>尽管这种实现方式不会用到反射，执行效率提高了，但业务代码（DemoClass）跟框架代码（InitializingBean）耦合在了一起。框架代码侵入到了业务代码中，替换框架的成本就变高了。所以，我并不是太推荐这种写法。</p><p>实际上，在Spring对Bean整个生命周期的管理中，还有一个跟初始化相对应的过程，那就是Bean的销毁过程。我们知道，在Java中，对象的回收是通过JVM来自动完成的。但是，我们可以在将Bean正式交给JVM垃圾回收前，执行一些销毁操作（比如关闭文件句柄等等）。</p><p>销毁过程跟初始化过程非常相似，也有两种实现方式。一种是通过配置destroy-method指定类中的销毁函数，另一种是让类实现DisposableBean接口。因为destroy-method、DisposableBean跟init-method、InitializingBean非常相似，所以，这部分我们就不详细讲解了，你可以自行研究下。</p><p>实际上，Spring针对对象的初始化过程，还做了进一步的细化，将它拆分成了三个小步骤：初始化前置操作、初始化、初始化后置操作。其中，中间的初始化操作就是我们刚刚讲的那部分，初始化的前置和后置操作，定义在接口BeanPostProcessor中。BeanPostProcessor的接口定义如下所示：</p><pre><code>public interface BeanPostProcessor {\n  Object postProcessBeforeInitialization(Object var1, String var2) throws BeansException;\n\n  Object postProcessAfterInitialization(Object var1, String var2) throws BeansException;\n}\n</code></pre><p>我们再来看下，如何通过BeanPostProcessor来定义初始化前置和后置操作？</p><p>我们只需要定义一个实现了BeanPostProcessor接口的处理器类，并在配置文件中像配置普通Bean一样去配置就可以了。Spring中的ApplicationContext会自动检测在配置文件中实现了BeanPostProcessor接口的所有Bean，并把它们注册到BeanPostProcessor处理器列表中。在Spring容器创建Bean的过程中，Spring会逐一去调用这些处理器。</p><p>通过上面的分析，我们基本上弄清楚了Spring Bean的整个生命周期（创建加销毁）。针对这个过程，我画了一张图，你可以结合着刚刚讲解一块看下。</p><p><img src=\"https://static001.geekbang.org/resource/image/ca/4d/cacaf86b03a9432a4885385d2869264d.jpg?wh=2693*1352\" alt=\"\"></p><p>不过，你可能会说，这里哪里用到了模板模式啊？模板模式不是需要定义一个包含模板方法的抽象模板类，以及定义子类实现模板方法吗？</p><p>实际上，这里的模板模式的实现，并不是标准的抽象类的实现方式，而是有点类似我们前面讲到的Callback回调的实现方式，也就是将要执行的函数封装成对象（比如，初始化方法封装成InitializingBean对象），传递给模板（BeanFactory）来执行。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>今天我讲到了Spring中用到的两种支持扩展的设计模式，观察者模式和模板模式。</p><p>其中，观察者模式在Java、Google Guava、Spring中都有提供相应的实现代码。在平时的项目开发中，基于这些实现代码，我们可以轻松地实现一个观察者模式。</p><p>Java提供的框架比较简单，只包含java.util.Observable和java.util.Observer两个类。Google Guava提供的框架功能比较完善和强大，可以通过EventBus事件总线来实现观察者模式。Spring提供了观察者模式包含Event事件、Listener监听者、Publisher发送者三部分。事件发送到ApplicationContext中，然后，ApplicationConext将消息发送给事先注册好的监听者。</p><p>除此之外，我们还讲到模板模式在Spring中的一个典型应用，那就是Bean的创建过程。Bean的创建包含两个大的步骤，对象的创建和对象的初始化。其中，对象的初始化又可以分解为3个小的步骤：初始化前置操作、初始化、初始化后置操作。</p><h2>课堂讨论</h2><p>在Google Guava的EventBus实现中，被观察者发送消息到事件总线，事件总线根据消息的类型，将消息发送给可匹配的观察者。那在Spring提供的观察者模式的实现中，是否也支持按照消息类型匹配观察者呢？如果能，它是如何实现的？如果不能，你有什么方法可以让它支持吗？</p><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>","neighbors":{"left":{"article_title":"84 | 开源实战四（上）：剖析Spring框架中蕴含的经典设计思想或原则","id":236935},"right":{"article_title":"86 | 开源实战四（下）：总结Spring框架用到的11种设计模式","id":238418}},"comments":[{"had_liked":false,"id":224237,"user_name":"zz","can_delete":false,"product_type":"c1","uid":1237202,"ip_address":"","ucode":"EA1CD86520FE14","user_header":"https://static001.geekbang.org/account/avatar/00/12/e0/d2/fb5306c4.jpg","comment_is_top":false,"comment_ctime":1591321761,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"126145373345","product_id":100039001,"comment_content":"看到源码中有这么多的if else，瞬间给了自己一些信心。","like_count":29,"discussions":[{"author":{"id":1133194,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4a/8a/c1069412.jpg","nickname":"makermade","note":"","ucode":"03386B90CB8F20","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557718,"discussion_content":"源码不是给你同事看的；但是你的代码 是给你同事看的。框架更注重通用 性能，业务代码更注重可读性","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1647940180,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1441569,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ff/21/8815d2e5.jpg","nickname":"亮子","note":"","ucode":"DF37D5E0714D02","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550944,"discussion_content":"作者说过，不要过度设计，有时候最简单的，也是最易读的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1644821037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1103292,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/2m49Z7YV3PGMA15rXTubL3psY8X9bdpd4Xe4qnv7iaVBQjnt5YWicBP2icQCpSYphricllXDLzm8KfZHK3GUOLZBNg/132","nickname":"Ngzhilin","note":"","ucode":"F8EFEC2ACD08A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351567,"discussion_content":"我们的目标是要比源码更多","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1614327753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1213322,"avatar":"https://static001.geekbang.org/account/avatar/00/12/83/8a/7c7df3b3.jpg","nickname":"董昌强","note":"","ucode":"0803D7E3ABD3FD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591604,"discussion_content":"擦，这是源码的槽点，这啥要学缺点了 ？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666696153,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1992059,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/65/7b/058d17f3.jpg","nickname":"耶low","note":"","ucode":"4CCEB741583544","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":405766,"discussion_content":"实际去看看，信心马上又没了，😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634641972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1455958,"avatar":"https://static001.geekbang.org/account/avatar/00/16/37/56/11068390.jpg","nickname":"倡印","note":"","ucode":"4F53AA5D017D89","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388982,"discussion_content":"跑偏了+","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629083628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1438860,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f4/8c/0866b228.jpg","nickname":"子房","note":"","ucode":"CB05938C248BB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348117,"discussion_content":"哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612430371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218271,"user_name":"悟光","can_delete":false,"product_type":"c1","uid":1439777,"ip_address":"","ucode":"E81339EBC4F492","user_header":"https://static001.geekbang.org/account/avatar/00/15/f8/21/3fa228e6.jpg","comment_is_top":false,"comment_ctime":1589769196,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35949507564","product_id":100039001,"comment_content":"支持按照消息类型匹配观察者，最终调用 SimpleApplicationEventMulticaster 类的multicastEvent方法通过反射匹配类型。根据配置采用异步还是同步的监听方式。<br>\tpublic void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) {<br>\t\tResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));<br>\t\tExecutor executor = getTaskExecutor();<br>\t\tfor (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) {<br>\t\t\tif (executor != null) {<br>\t\t\t\texecutor.execute(() -&gt; invokeListener(listener, event));<br>\t\t\t}<br>\t\t\telse {<br>\t\t\t\tinvokeListener(listener, event);<br>\t\t\t}<br>\t\t}<br>\t}<br>","like_count":9},{"had_liked":false,"id":218249,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1589765140,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35949503508","product_id":100039001,"comment_content":"用反射获取的type","like_count":8},{"had_liked":false,"id":218396,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1589796160,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"31654567232","product_id":100039001,"comment_content":"看了下源码,其流程可以从<br>图片: https:&#47;&#47;uploader.shimo.im&#47;f&#47;fZuIVWFIlWQnnRFq.png<br>推送Event时候,去发送Event开始走<br>主要就是这个<br>在此方法中,会调用getApplicationListeners(event,eventType)函数<br>图片: https:&#47;&#47;uploader.shimo.im&#47;f&#47;3mZZvSBhmc8CXLnx.png<br>在这个方法中,会获取到对应的所有监听者,如何获取到的,会先通过一个锁来从一个名为retrieverCache的map中尝试获取到对应的监听者<br>如果拿不到,会进入到retrieveApplicationListeners()这个函数之中<br>图片: https:&#47;&#47;uploader.shimo.im&#47;f&#47;GFvS2QEKGlMctZrc.png<br>在这个方法中,会在add返回的结果的时候,会调用一个方法supportsEvent(),<br>这才是真正进行匹配的方法<br>图片: https:&#47;&#47;uploader.shimo.im&#47;f&#47;102Ia9ToqIw5ZOyq.png<br>匹配事件和源类型是否一致,一致才算做可以发送","like_count":7},{"had_liked":false,"id":219298,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1589985550,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"27359789326","product_id":100039001,"comment_content":"定义了一个bean同时实现了InitializingBean, BeanPostProcessor, DisposableBean，发现方法跟老师最后一张图的不一致：<br>1、顺序是构造器、afterPropertiesSet、postProcessBeforeInitialization、postProcessAfterInitialization、destroy<br>2、postProcessBeforeInitialization、postProcessAfterInitialization这两个方法交替执行了N次","like_count":6,"discussions":[{"author":{"id":1237655,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e2/97/dfadcc92.jpg","nickname":"Kang","note":"","ucode":"088A8DA0A16BDE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":115372,"discussion_content":"让他们等着，你先想想","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578012923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218217,"user_name":"我的腿腿","can_delete":false,"product_type":"c1","uid":1239277,"ip_address":"","ucode":"2AAA36A7C3AD75","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/ed/f9347e5e.jpg","comment_is_top":false,"comment_ctime":1589760884,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"23064597364","product_id":100039001,"comment_content":"昨天刚好在隔壁小马哥那里看到了，两个课一起听，侧重点不同，都很重要啊","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480213,"discussion_content":"单元测试真的很有用，谁写谁知道。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578490425,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1323102,"avatar":"https://static001.geekbang.org/account/avatar/00/14/30/5e/c42bc33f.jpg","nickname":"Younger Ku","note":"","ucode":"D157DC38BDB515","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307550,"discussion_content":"单元测试需要测试service还是controller?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600682144,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1055334,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1a/66/2d9db9ed.jpg","nickname":"苦行僧","note":"","ucode":"726024A9A9CF44","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278330,"discussion_content":"单元测试是王道","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591174754,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":237477,"user_name":"Tobias","can_delete":false,"product_type":"c1","uid":1803858,"ip_address":"","ucode":"F3225639EDA193","user_header":"https://static001.geekbang.org/account/avatar/00/1b/86/52/b92dc111.jpg","comment_is_top":false,"comment_ctime":1595841397,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14480743285","product_id":100039001,"comment_content":"Spring 提供的观察者模式是支持按照消息类型匹配观察者。getApplicationListeners(event, type) 方法会根据eventtype 找到对应的的listeners. getApplicationListeners(event, type) 通过反射找到 event 以及event的子类 对应的listeners.","like_count":3},{"had_liked":false,"id":252743,"user_name":"握了个大蚂蚱","can_delete":false,"product_type":"c1","uid":1488356,"ip_address":"","ucode":"AD34AD4FA37371","user_header":"https://static001.geekbang.org/account/avatar/00/16/b5/e4/e6faf686.jpg","comment_is_top":false,"comment_ctime":1602472939,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5897440235","product_id":100039001,"comment_content":"1.实现InitializingBean的初始化方法，也是约定优于配置的一个体现，只不过不是覆盖默认值而是实现init-method的一个前置方法afterPropertiesSet。<br>2.实现InitializingBean的初始化方法和自己指定init-method相比，侵入性更高，所以不太推荐。可以用注解版的@Bean(initMethod = &quot;xx&quot;)来指定初始化方法，或者使用JSR250中的@PostConstruct标注在初始化方法上来让程序回调。","like_count":1},{"had_liked":false,"id":232333,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1593959081,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"5888926377","product_id":100039001,"comment_content":"spring中的refresh是一个模板方法：<br>大致有：注册beanFactoryPostProcessor，beanPostProcessor，读取bean definition，创建并初始化bean,等","like_count":1,"discussions":[{"author":{"id":1087243,"avatar":"https://static001.geekbang.org/account/avatar/00/10/97/0b/a943bcb3.jpg","nickname":"zhou","note":"","ucode":"E1CE8575B3F106","race_medal":3,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":239195,"discussion_content":"嗯 往往几个月后，回头查一个问题的时候会指着自己的代码说，这是哪个傻X写的代码","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587283604,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":357700,"user_name":"tonyli","can_delete":false,"product_type":"c1","uid":1011969,"ip_address":"中国香港","ucode":"6001A47BC5C9E7","user_header":"","comment_is_top":false,"comment_ctime":1663573250,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663573250","product_id":100039001,"comment_content":"使用模板模式定义了一系列步骤的骨架，是各类框架的根本设计模式。","like_count":0},{"had_liked":false,"id":332124,"user_name":"李金鹏","can_delete":false,"product_type":"c1","uid":1445362,"ip_address":"","ucode":"8FCCA5B8BD8DDD","user_header":"https://static001.geekbang.org/account/avatar/00/16/0d/f2/3865fe28.jpg","comment_is_top":false,"comment_ctime":1643030474,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643030474","product_id":100039001,"comment_content":"自定义注解加AOP可以实现支持按照消息类型匹配观察者","like_count":0},{"had_liked":false,"id":280432,"user_name":"David","can_delete":false,"product_type":"c1","uid":1021825,"ip_address":"","ucode":"22CBBC13FC97A9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/97/81/e1eaf621.jpg","comment_is_top":false,"comment_ctime":1614216376,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1614216376","product_id":100039001,"comment_content":"策论模式 缓存对象类型和处理器的关系","like_count":0,"discussions":[{"author":{"id":1463740,"avatar":"https://static001.geekbang.org/account/avatar/00/16/55/bc/fad0090b.jpg","nickname":"Yeyw","note":"","ucode":"C9D20DB91C3BE5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368756,"discussion_content":"我之前项目的就是自己实现注册策略接口类型和策略实现，每个策略都带有相应的types","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618824106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":277491,"user_name":"子房","can_delete":false,"product_type":"c1","uid":1438860,"ip_address":"","ucode":"CB05938C248BB3","user_header":"https://static001.geekbang.org/account/avatar/00/15/f4/8c/0866b228.jpg","comment_is_top":false,"comment_ctime":1612430476,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612430476","product_id":100039001,"comment_content":"spring 中通过 simple 实现类发送事件，并维护了事件和监听者的映射关系，当需要发送一个事件时会把该事件对应的监听者取出，并执行。","like_count":0},{"had_liked":false,"id":258071,"user_name":"o0oi1i","can_delete":false,"product_type":"c1","uid":1132312,"ip_address":"","ucode":"D1F6AD4AAEAFBE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/18/293cd24d.jpg","comment_is_top":false,"comment_ctime":1604286104,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604286104","product_id":100039001,"comment_content":"打卡85","like_count":0}]}