{"id":827196,"title":"43｜ProxySQL：数据库高可用了，应用高可用怎么做？","content":"<p>你好，我是俊达。</p><p>通过前面几讲，我们知道了怎么使用MySQL的数据复制技术，来实现数据库层面的高可用。但是对于应用系统，当后端的MySQL发生高可用切换时，应该怎么处理？</p><p>这里有几种可选的方案。</p><ol>\n<li>\n<p>应用通过域名访问数据库。域名指向主库，当后端数据库发生主备切换后，将域名指向新的主库。使用域名存在几个问题，包括域名缓存的问题，以及端口的问题。因为域名只能解析到IP，如果主库和备库的端口不一样，就无法直接通过切换域名来解决。</p>\n</li>\n<li>\n<p>在客户端解决。将MySQL集群中的实例信息都配置到应用程序中，在应用程序中自动检测主库和备库信息。也可以引入一些客户端的SDK来实现高可用。使用客户端的方案，会给应用开发带来额外的编码工作，或者对程序的开发语言有要求。</p>\n</li>\n<li>\n<p>引入Proxy，应用程序只访问Proxy。Proxy内部自动识别主库，将应用的请求转发给正确的后端数据库。这里Proxy的作用，和在web高可用架构中的负载均衡器作用类似。使用Proxy的好处，一是对客户端的限制少，你可以使用熟悉的方式访问数据库。而且有的Proxy可以通过一些策略，实现读写分离、SQL黑名单和白名单、SQL改写等功能。</p>\n</li>\n</ol><p>业界MySQL Proxy的产品比较多。这一讲中，我们就以开源的ProxySQL为例，来看一下数据库高可用的一种实现方式。</p><!-- [[[read_end]]] --><p>ProxySQL支持MySQL传统的主备复制架构，也支持MGR架构。</p><p>客户端使用标准的MySQL协议访问ProxySQL，在客户端眼里，ProxySQL和MySQL没有大的区别。ProxySQL根据访问的用户、执行的SQL语句，将请求转发给后端MySQL，SQL执行完成后，再由ProxySQL将结果返回到客户端。</p><p><img src=\"https://static001.geekbang.org/resource/image/5e/40/5ef6c62e2cd7cce08c5c18bc5bb17b40.jpg?wh=1130x907\" alt=\"图片\"></p><h2>ProxySQL安装部署</h2><p>先安装一个ProxySQL。</p><ol>\n<li>从github下载安装包</li>\n</ol><p>根据OS版本，选择对应的安装包。这里我们以CentOS 7为例，选择了当前最新的版本。</p><pre><code class=\"language-plain\">wget https://github.com/sysown/proxysql/releases/download/v2.7.1/proxysql-2.7.1-1-centos7.x86_64.rpm\n</code></pre><p>下载后验证一下文件校验码是否正确。</p><pre><code class=\"language-plain\"># sha256sum proxysql-2.7.1-1-centos7.x86_64.rpm\n336b913c1b2bde5bdac49b1b6290a6ce636405e5e19090a1de6030e47b92b8fa  proxysql-2.7.1-1-centos7.x86_64.rpm\n</code></pre><ol start=\"2\">\n<li>安装ProxySQL</li>\n</ol><p>我们下载的是rpm安装包，使用rpm命令进行安装。先安装依赖包。</p><pre><code class=\"language-plain\">yum install perl-DBI\nyum install perl-DBD-mysql\n</code></pre><p>再安装ProxySQL。</p><pre><code class=\"language-plain\">[root@172-16-121-234 opt]# rpm -ivh proxysql-2.7.1-1-centos7.x86_64.rpm\n警告：proxysql-2.7.1-1-centos7.x86_64.rpm: 头V4 RSA/SHA512 Signature, 密钥 ID 8217c97e: NOKEY\n准备中...                          ################################# [100%]\n正在升级/安装...\n   1:proxysql-2.7.1-1                 ################################# [100%]\n</code></pre><p>安装完成后，使用系统脚本启动ProxySQL。</p><pre><code class=\"language-plain\"># systemctl start proxysql\n\n\n# systemctl status proxysql\n● proxysql.service - High Performance Advanced Proxy for MySQL\n   Loaded: loaded (/etc/systemd/system/proxysql.service; enabled; vendor preset: disabled)\n   Active: active (running) since 四 2024-11-14 14:15:19 CST; 38s ago\n  Process: 10042 ExecStart=/usr/bin/proxysql --idle-threads -c /etc/proxysql.cnf $PROXYSQL_OPTS (code=exited, status=0/SUCCESS)\n Main PID: 10044 (proxysql)\n   CGroup: /system.slice/proxysql.service\n           ├─10044 /usr/bin/proxysql --idle-threads -c /etc/proxysql.cnf\n           └─10045 /usr/bin/proxysql --idle-threads -c /etc/proxysql.cnf\n</code></pre><h3>配置ProxySQL</h3><p>有几个地方可以配置ProxySQL。</p><ol start=\"3\">\n<li>配置文件。</li>\n</ol><p>默认的配置文件是/etc/proxysql.cnf，也可以通过命令行参数-c指定配置文件。</p><pre><code class=\"language-plain\">## /etc/proxysql.cnf\ndatadir=\"/var/lib/proxysql\"\nerrorlog=\"/var/lib/proxysql/proxysql.log\"\n\nadmin_variables=\n{\n\tadmin_credentials=\"admin:admin\"\n\tmysql_ifaces=\"0.0.0.0:6032\"\n}\n\nmysql_variables=\n{\n\tthreads=4\n\tinterfaces=\"0.0.0.0:6033\"\n  ...\n}\n\n...\n</code></pre><p>datadir指定了proxysql内置数据库的存放路径。需要注意的是，proxysql.cnf中的配置只在初次启动proxysql时生效。如果proxysql的内置数据库已经创建，后续只会从内置的数据库中读取配置信息，这时再修改proxysql.cnf就不起作用了。</p><ol start=\"4\">\n<li>配置数据库</li>\n</ol><p>你可以用mysql客户端登录proxysql的admin端口，使用标准的SQL语句来配置参数。admin端口由参数admin_variables mysql_ifaces指定，admin账号密码由参数admin_credentials指定。admin账号只能在本地登录。登录后可以查看和修改配置项。</p><pre><code class=\"language-plain\"># mysql -uadmin -padmin -P6032 -h127.0.0.1\nServer version: 5.5.30 (ProxySQL Admin Module)\n\nmysql&gt; \n\nmysql&gt; show databases;\n+-----+---------------+-------------------------------------+\n| seq | name          | file                                |\n+-----+---------------+-------------------------------------+\n| 0   | main          |                                     |\n| 2   | disk          | /var/lib/proxysql/proxysql.db       |\n| 3   | stats         |                                     |\n| 4   | monitor       |                                     |\n| 5   | stats_history | /var/lib/proxysql/proxysql_stats.db\n</code></pre><p>使用show databases命令，可以看到ProxySQL的几个配置数据库。</p><ul>\n<li>\n<p>main：内存数据库。这个库里的表分两类，runtime开头的表存的是当前实际生效的配置。其它表存的是配置值，可通过load命令加载到runtime中，通过save命令持久化到磁盘中。</p>\n</li>\n<li>\n<p>disk：sqllite数据库。proxysql启动时从这个数据库加载配置项。</p>\n</li>\n</ul><p>常用的一些配置表，我整理到了这个表格中，后续我会通过一些具体的例子来介绍这些表的使用方法。</p><p><img src=\"https://static001.geekbang.org/resource/image/0a/7e/0a1cfb18ffcf961f127fec498c31187e.png?wh=1506x1334\" alt=\"图片\"></p><p>使用ProxySQL，一般要完成下面这几项内容的配置。</p><ol>\n<li>\n<p>配置监控账号，监控账号用来检测后端MySQL实例是否健康，比如是否能连接上、复制是否正常、复制是否有延迟等。</p>\n</li>\n<li>\n<p>配置后端mysql实例连接信息，实例连接信息存储在mysql_servers表。</p>\n</li>\n<li>\n<p>配置连接proxysql和后端实例的账号，账号信息存储在mysql_users表。</p>\n</li>\n<li>\n<p>配置查询路由信息，路由信息存储在mysql_query_rules表。</p>\n</li>\n<li>\n<p>配置后端mysql集群信息，根据后端mysql集群架构，配置分别存储在mysql_replication_hostgroups、mysql_group_replication_hostgroups、runtime_mysql_galera_hostgroups、runtime_mysql_aws_aurora_hostgroups等表中。</p>\n</li>\n<li>\n<p>根据具体需要，调优相关参数，参数存储在global_variables表。</p>\n</li>\n</ol><h3>配置监控账号</h3><p>ProxySQL使用监控账号来探测后端MySQL实例的健康度。监控账号要有一些基本的权限，包括：连接数据库、查看复制状态（replication client）、查看group replication相关表（performance_schema）。</p><p>使用下面这些命令创建监控账号。</p><pre><code class=\"language-plain\">create user 'dbmonitor'@'%' identified with mysql_native_password \n by 'monitorpasswd';\n \ngrant replication client on *.* to 'dbmonitor'@'%';\n\n-- group replication\ngrant select on performance_schema.replication_group_member_stats \n to 'dbmonitor'@'%';\n\ngrant select on performance_schema.replication_group_members \n to 'dbmonitor'@'%';\n</code></pre><p>然后在ProxySQL中配置监控账号。</p><pre><code class=\"language-plain\">set mysql-monitor_username = 'dbmonitor';\nset mysql-monitor_password = 'monitorpasswd';\nload mysql variables to runtime;\nsave mysql variables to disk;\n</code></pre><h2>ProxySQL使用场景</h2><p>接下来我们通过一些使用场景，来看看怎么配置ProxySQL。例子中，会用到两个MySQL集群，一个是普通的主备复制集群，一个是MGR集群。</p><p><img src=\"https://static001.geekbang.org/resource/image/6b/c0/6ba48f8bf9da5966096807da4b7dccc0.png?wh=1920x1057\" alt=\"图片\"></p><h3>场景1：使用Proxysql实现读写分离</h3><p>我们把下面这个MySQL数据复制集群配置到ProxySQL中。</p><p><img src=\"https://static001.geekbang.org/resource/image/f2/30/f2777afdaa47f3f339199f6009abc730.jpg?wh=1244x664\" alt=\"图片\"></p><h4>配置hostgroup</h4><p>先把数据库节点的信息写到mysql_servers表。</p><pre><code class=\"language-plain\">insert into mysql_servers (\n  hostgroup_id, hostname, port, max_replication_lag)\nvalues ( 200, '172.16.121.234', 3308, 3);\n\ninsert into mysql_servers (\n  hostgroup_id, hostname, port, max_replication_lag)\nvalues ( 201, '172.16.121.236', 3308, 3);\n\ninsert into mysql_servers (\n  hostgroup_id, hostname, port, max_replication_lag)\nvalues ( 201, '172.16.121.237', 3308, 3);\n\nload mysql servers  to runtime; \nsave mysql servers  to disk;\n</code></pre><p>这里我们把两个备库都加到了hostgroup 201中。</p><h4>配置用户信息</h4><p>然后到ProxySQL中配置用户信息。</p><pre><code class=\"language-plain\">insert into mysql_users\n(username, password, default_hostgroup, transaction_persistent, backend, frontend, comment)\nvalues ('user1', 'somepass', 200, 1, 1, 1, 'user1');\n\n\nload mysql users  to runtime; \nsave mysql users  TO disk;\n</code></pre><p>这里我们将用户的请求默认转发到hostgroup 200，也就是主库。transaction_persistent设置为1，这是为了将一个事务中的所有SQL都发送到同一个后端MySQL。</p><p>当然，还要到后端的MySQL上创建用户和授权。</p><pre><code class=\"language-plain\">create user 'user1'@'%' identified by 'somepass';\ngrant create,alter,insert,update,delete,select on *.* to 'user1'@'%';\n</code></pre><p>关于用户认证插件，在ProxySQL2.6.0版本前，如果后端账号使用了caching_sha2_password插件认证，配置用户时需要做一些特殊处理。</p><p>先把admin-hash_passwords设置为false。</p><pre><code class=\"language-plain\"> set admin-hash_passwords=1;\n\n LOAD ADMIN VARIABLES to runtime;\n save ADMIN VARIABLES to disk;\n\n -- 确认配置生效\n mysql&gt; select * from runtime_global_variables where variable_name = 'admin-hash_passwords';\n+----------------------+----------------+\n| variable_name        | variable_value |\n+----------------------+----------------+\n| admin-hash_passwords | false           |\n+----------------------+----------------+\n</code></pre><p>然后再配置用户表，以明文的形式存储password字段。</p><pre><code class=\"language-plain\">load mysql users to runtime;\nsave mysql users to disk;\n\n-- 确认runtime_mysql_users表中的密码是明文\nmysql&gt; select username, password \n  from runtime_mysql_users \n  where username = 'user1';\n+----------+---------------+\n| username | password      |\n+----------+---------------+\n| user1    | user1-backend |\n</code></pre><h4>配置读写分离规则</h4><p>按前面这样配置，读写请求都会路由到主库。如果你想将一些查询转发到备库上执行，可以到mysql_query_rules表中添加一些转发规则。</p><pre><code class=\"language-plain\">insert into mysql_query_rules\n(rule_id, username, match_pattern, destination_hostgroup,active, apply, comment )\nvalues (101, 'user1', '^SELECT.*FOR UPDATE$', 200,1,1, 'route to hostgroup 200');\n\ninsert into mysql_query_rules\n(rule_id, username, match_pattern, destination_hostgroup, active, apply, comment)\nvalues (102, 'user1', '^SELECT', 201,1,1, 'select query route to hostgroup 201');\n\nload mysql query rules to runtime; \nsave mysql query rules to disk;\n</code></pre><p>上面这个例子中，除了select for update，其他所有SELECT开头的查询都转发到备库。</p><pre><code class=\"language-plain\">mysql&gt; select @@hostname,@@server_id  for update;\n+----------------+-------------+\n| @@hostname     | @@server_id |\n+----------------+-------------+\n| 172-16-121-234 |     3308234 |\n+----------------+-------------+\n1 row in set (0.00 sec)\n\n\nmysql&gt; select @@hostname,@@server_id ;\n+----------------+-------------+\n| @@hostname     | @@server_id |\n+----------------+-------------+\n| 172-16-121-237 |     3308237 |\n+----------------+-------------+\n1 row in set (0.00 sec)\n\n\nmysql&gt; /*+ comment */ select  @@hostname,@@server_id ;\n+----------------+-------------+\n| @@hostname     | @@server_id |\n+----------------+-------------+\n| 172-16-121-234 |     3308234 |\n+----------------+-------------+\n</code></pre><p>上面这个配置，只是一个演示的例子，正式环境中，并不建议像这样将所有SELECT都无条件转发到备库。我建议你根据业务的需求，配置更精确的转发规则。而且在正式环境中添加转发规则前，要做好充分的测试。</p><h3>场景2：后端MySQL自动切换</h3><p>上一个场景中，所有的写入都转发到hostgroup 200。如果后端的数据库发生了主备切换，怎么将写请求转发到新的主库呢？</p><p>我们可以到mysql_replication_hostgroups表里添加一条配置记录，告诉ProxySQL，hostgroup 200和201是一个数据复制集群。</p><pre><code class=\"language-plain\">insert into mysql_replication_hostgroups\n(writer_hostgroup, reader_hostgroup, check_type, comment)\nvalues(200, 201, 'read_only', 'mysql mm cluster');\n\nload mysql servers to runtime;\nsave mysql servers to disk;\n</code></pre><p>这样配置后，ProxySQL会检测主备库的read_only状态。检测到read_only从OFF变成ON时，会将writer_hostgroup中的主机添加到reader_hostgrup中；当检测到read_only从ON变成OFF时，会将主机从reader_hostgroup中移到writer_hostgroup中。</p><p>这里check_type可以设置为read_only、innodb_read_only、super_read_only、read_only|innodb_read_only、read_only&amp;innodb_read_only这几种类型，区别就是检测的条件不一样。</p><p>我们来做一个测试。当前172.16.121.234是主库。</p><pre><code class=\"language-plain\">mysql&gt; select hostgroup_id, hostname, port, status from runtime_mysql_servers;\n+--------------+----------------+------+--------+\n| hostgroup_id | hostname       | port | status |\n+--------------+----------------+------+--------+\n| 200          | 172.16.121.234 | 3308 | ONLINE |\n| 201          | 172.16.121.236 | 3308 | ONLINE |\n| 201          | 172.16.121.237 | 3308 | ONLINE |\n+--------------+----------------+------+--------+\n</code></pre><p>我们把172.16.121.236切换为主库，先将172.16.121.234的Read_only设置为ON。这时可以看到hostgroup 200中的主机被下线了。</p><pre><code class=\"language-plain\">mysql&gt; select hostgroup_id, hostname, port, status from runtime_mysql_servers;\n+--------------+----------------+------+--------------+\n| hostgroup_id | hostname       | port | status       |\n+--------------+----------------+------+--------------+\n| 200          | 172.16.121.234 | 3308 | OFFLINE_HARD |\n| 201          | 172.16.121.234 | 3308 | ONLINE       |\n| 201          | 172.16.121.236 | 3308 | ONLINE       |\n| 201          | 172.16.121.237 | 3308 | ONLINE       |\n+--------------+----------------+------+--------------+\n</code></pre><p>然后再把172.16.121.236的read_only设置为OFF。可以看到，172.16.121.236加到了hostgroup 200中。</p><pre><code class=\"language-plain\">mysql&gt; select hostgroup_id, hostname, port, status from runtime_mysql_servers;\n+--------------+----------------+------+--------------+\n| hostgroup_id | hostname       | port | status       |\n+--------------+----------------+------+--------------+\n| 200          | 172.16.121.234 | 3308 | OFFLINE_HARD |\n| 200          | 172.16.121.236 | 3308 | ONLINE       |\n| 201          | 172.16.121.234 | 3308 | ONLINE       |\n| 201          | 172.16.121.236 | 3308 | ONLINE       |\n| 201          | 172.16.121.237 | 3308 | ONLINE       |\n+--------------+----------------+------+--------------+\n</code></pre><p>上面的例子中，172.16.121.236加到hostgroup 200后，同时还在hostgroup 201中。</p><p>如果需要将这个实例从read hostgroup中移除，要将参数mysql-monitor_writer_is_also_reader 设置为false。</p><pre><code class=\"language-plain\">set mysql-monitor_writer_is_also_reader='false';\nload mysql variables to runtime;\nsave mysql variables to disk;\n</code></pre><p>然后再重新加载mysql server，就可以把设置了read_only=OFF状态的后端实例从read hostgroup中移除。</p><pre><code class=\"language-plain\">mysql&gt; load mysql servers to runtime;\n\nmysql&gt; select hostgroup_id, hostname, port, status from runtime_mysql_servers;\n+--------------+----------------+------+--------------+\n| hostgroup_id | hostname       | port | status       |\n+--------------+----------------+------+--------------+\n| 200          | 172.16.121.234 | 3308 | OFFLINE_HARD |\n| 200          | 172.16.121.236 | 3308 | ONLINE       |\n| 201          | 172.16.121.234 | 3308 | ONLINE       |\n| 201          | 172.16.121.237 | 3308 | ONLINE       |\n+--------------+----------------+------+--------------+\n</code></pre><p>ProxySQL只根据后端MySQL的read_only状态来判断，是将实例放到write hostgroup还是read hostgroup。所以需要正确地设置read_only状态。如果主备实例都设置了read_only=OFF，会发生双写，容易引起数据不一致。如果在备库复制有延迟或备库复制中断的情况下，将备库的read only设置为OFF，同样也可能会引起数据不一致。</p><p>这通常要使用一些MySQL自动切换的工具，比如MHA，来进行判断、设置。</p><h3>场景3：ProxySQL和MGR配合使用</h3><p>MGR自带故障检测和自动切换能力，接下来我们看一下MGR的一个例子。</p><h4>配置集群节点</h4><pre><code class=\"language-plain\">insert into mysql_servers (\n  hostgroup_id, hostname, port, max_replication_lag)\nvalues ( 500, '172.16.121.234', 3307, 3);\n\ninsert into mysql_servers (\n  hostgroup_id, hostname, port, max_replication_lag)\nvalues ( 501, '172.16.121.236', 3307, 3);\n\ninsert into mysql_servers (\n  hostgroup_id, hostname, port, max_replication_lag)\nvalues ( 501, '172.16.121.237', 3307, 3);\n\n\nload mysql servers  to runtime; \nsave mysql servers  to disk;\n</code></pre><h4>配置集群信息</h4><p>到mysql_group_replication_hostgroups表中添加一条记录，告诉ProxySQL，hostgroup 500，501组成了一个MGR集群。</p><pre><code class=\"language-plain\">insert into mysql_group_replication_hostgroups\n(writer_hostgroup, backup_writer_hostgroup, reader_hostgroup, \noffline_hostgroup, active, max_writers, writer_is_also_reader,\nmax_transactions_behind, comment)\nvalues(500, 502, 501, 503, 1, 1, 0, 0, 'mysql mgr cluster 1');\n\nload mysql servers to runtime;\nsave mysql servers to disk;\n</code></pre><h4>创建和配置用户信息</h4><p>在ProxySQL中配置用户信息。</p><pre><code class=\"language-plain\">insert into mysql_users\n(username, password, transaction_persistent, backend, frontend, default_hostgroup, comment)\nvalues ('mgr', 'mgr123', 1, 1, 1, 500, 'backend user for mgr cluster');\n\nload mysql users  to runtime; \nsave mysql users to disk;\n</code></pre><p>然后到后端MySQL创建用户。</p><pre><code class=\"language-plain\">create user 'mgr'@'%' identified by 'mgr123';\ngrant select,insert,update,delete,create,alter on *.* to 'mgr'@'%';\n</code></pre><p>都配置好之后，查看集群的配置信息。</p><pre><code class=\"language-plain\">mysql&gt; select hostgroup_id, hostname, port, status \n  from runtime_mysql_servers\n  where hostgroup_id &gt;= 500;\n+--------------+----------------+------+--------------+\n| hostgroup_id | hostname       | port | status       |\n+--------------+----------------+------+--------------+\n| 500          | 172.16.121.234 | 3307 | ONLINE       |\n| 501          | 172-16-121-236 | 3307 | ONLINE       |\n| 501          | 172-16-121-237 | 3307 | ONLINE       |\n| 501          | 172.16.121.236 | 3307 | ONLINE       |\n| 501          | 172.16.121.237 | 3307 | ONLINE       |\n+--------------+----------------+------+--------------+\n</code></pre><p>我们把172.16.121.234强制下线，可以看到集群选举了新的主节点。</p><pre><code class=\"language-plain\">mysql&gt; select  member_host, member_port, member_state, member_role from replication_group_members;\n+----------------+-------------+--------------+-------------+\n| member_host    | member_port | member_state | member_role |\n+----------------+-------------+--------------+-------------+\n| 172-16-121-237 |        3307 | ONLINE       | PRIMARY     |\n| 172-16-121-236 |        3307 | ONLINE       | SECONDARY   |\n+----------------+-------------+--------------+-------------+\n</code></pre><p>ProxySQL中的hostgroup也自动更新了。</p><pre><code class=\"language-plain\">mysql&gt; select hostgroup_id, hostname, port, status\n       from runtime_mysql_servers\n       where hostgroup_id &gt;= 500;\n+--------------+----------------+------+---------+\n| hostgroup_id | hostname       | port | status  |\n+--------------+----------------+------+---------+\n| 500          | 172.16.121.237 | 3307 | ONLINE  |\n| 501          | 172-16-121-236 | 3307 | ONLINE  |\n| 501          | 172.16.121.236 | 3307 | ONLINE  |\n| 502          | 172-16-121-237 | 3307 | ONLINE  |\n| 503          | 172-16-121-234 | 3307 | SHUNNED |\n| 503          | 172.16.121.234 | 3307 | SHUNNED |\n+--------------+----------------+------+---------+\n</code></pre><h3>场景4：强制查询走主库</h3><p>使用读写分离时，有时候我们可能想让一些查询到主库上执行。这里提供一些强制让查询路由到主库的方法。</p><h4>方法一：使用用户表的transaction_persistent设置</h4><p>先把用户transaction_persistent字段设置为1。</p><pre><code class=\"language-plain\">update mysql_users set transaction_persistent=1 where username='user1';\nload mysql users to runtime;\n</code></pre><p>查询前先开启事务，这样查询就会转发到主库。</p><pre><code class=\"language-plain\">mysql&gt; start transaction read only;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; select @@hostname;\n+----------------+\n| @@hostname     |\n+----------------+\n| 172-16-121-236 |\n+----------------+\n1 row in set (0.00 sec)\n\nmysql&gt; commit;\nQuery OK, 0 rows affected (0.00 sec)\n</code></pre><h4>方法二：使用query注释</h4><p>还有一种方法是通过注释，指定主库的hostgroup。</p><pre><code class=\"language-plain\">mysql&gt; SELECT /*+ ;hostgroup=200 */ @@hostname;\n+----------------+\n| @@hostname     |\n+----------------+\n| 172-16-121-236 |\n+----------------+\n1 row in set (0.00 sec)\n\nmysql&gt; SELECT /*+ ;hostgroup=201 */ @@hostname;\n+----------------+\n| @@hostname     |\n+----------------+\n| 172-16-121-237 |\n+----------------+\n1 row in set (0.00 sec)\n</code></pre><p>需要注意，如果指定的hostgroup不存在，查询会超时。</p><pre><code class=\"language-plain\">mysql&gt; SELECT /*+ ;hostgroup=999 */ @@hostname;\nERROR 9001 (HY000): Max connect timeout reached while reaching hostgroup 999 after 10000ms\n</code></pre><h3>场景5：SQL黑名单</h3><p>利用mysql_query_rules表中的error_msg字段，可以实现SQL黑名单的功能。如果规则设置了error_msg，当SQL语句匹配这条规则时，proxysql会直接将error_msg的内容返回给客户端。</p><p>当遇到一些大查询严重影响数据库性能时，可以使用proxysql规则临时屏蔽这些SQL。</p><h4>查询stats_mysql_query_digest</h4><p>假设我们想屏蔽下面这条SQL。</p><pre><code class=\"language-plain\">select count(*) from information_schema.tables;\n</code></pre><p>先到stats_mysql_query_digest查询这个SQL的摘要，使用SQL摘要可以精确屏蔽某一类SQL。</p><pre><code class=\"language-plain\">mysql&gt; select * from stats.stats_mysql_query_digest \n  where digest_text like '%tables%' limit 1\\G\n\n*************************** 1. row ***************************\n        hostgroup: 201\n       schemaname: information_schema\n         username: user1\n   client_address:\n           digest: 0x98CB260C02C33558\n      digest_text: select count(*) from information_schema.tables\n       count_star: 1\n       first_seen: 1731567555\n        last_seen: 1731567555\n         sum_time: 25779\n         min_time: 25779\n         max_time: 25779\nsum_rows_affected: 0\n    sum_rows_sent: 1\n</code></pre><h4>配置屏蔽规则</h4><p>我们选择按查询的digest来屏蔽，往mysql_query_rules写入下面这条规则。</p><pre><code class=\"language-plain\">insert into mysql_query_rules\n(rule_id, username, digest, error_msg, active, apply, comment )\nvalues (10, 'user1', '0x98CB260C02C33558', 'request denied by rule' ,1,1, 'request denied by rule');\n\nload mysql query rules to runtime;\nsave mysql query rules to disk;\n</code></pre><p>需要注意，屏蔽规则的rule_id需要比其它规则的rule_id小，proxysql是按rule_id的顺序依次判断是否匹配规则。</p><h4>测试屏蔽效果</h4><p>使用digest，屏蔽的是一类SQL，如果SQL只是传入的参数有差异，SQL的digest一样，那么也会匹配该规则。</p><pre><code class=\"language-plain\">mysql&gt; select count(*) from information_schema.tables;\nERROR 1148 (42000): request denied by rule\n</code></pre><h3>场景6：改写SQL</h3><p>使用查询修改功能，可以在不改变应用程序的情况下，修改SQL语句。比如，我们可以使用SQL改写的功能，给SQL添加hint，以此来优化性能。</p><pre><code class=\"language-plain\">delete from mysql_query_rules;\n\ninsert into mysql_query_rules\n(rule_id, username, match_pattern, replace_pattern, \n  destination_hostgroup, active, apply, comment )\nvalues (20, 'user1',\n  '^SELECT\\s+(.*?)\\s+FROM\\s+ta\\s+where\\s+a\\s+=\\s+(\\d+)$',\n  'SELECT \\1 FROM ta force index(idx_a) WHERE A = \\2', \n  200, 1, 1, 'add force index');\n\nload mysql query rules to runtime;\n</code></pre><p>在上面的例子中，我们给TA表的查询加上了force index提示。</p><pre><code class=\"language-plain\">mysql&gt; select * from ta where a = 10;\nERROR 1176 (42000): Key 'idx_a' doesn't exist in table 'ta'\n\nmysql&gt; select a, val from ta where a = 10;\nERROR 1176 (42000): Key 'idx_a' doesn't exist in table 'ta'\n</code></pre><h3>场景7：SQL Mirror</h3><p>使用ProxySQL的镜像（mirror）功能，可以把SQL发送到一个额外的后端实例执行。</p><p>还可以把发送到镜像的SQL进行改写，以测试修改后的SQL是否能正常执行。</p><p>通过mirror_flagOut字段，可以将多条规则串联起来。</p><pre><code class=\"language-plain\">delete from mysql_query_rules;\n\n-- 执行SQL，同时将SQL mirror一份\ninsert into mysql_query_rules\n(rule_id, username, match_pattern, destination_hostgroup, \n mirror_flagOut, active, apply, comment )\nvalues (20, 'user1', '^SELECT', 200, \n  1001, 1, 1, 'mirror');\n\n-- 对于mirror的SQL，增加注释，发送到hostgroup 201执行\ninsert into mysql_query_rules\n(rule_id, username, flagIn, match_pattern, destination_hostgroup, \n replace_pattern, active, apply, comment )\nvalues (21, 'user1', 1001, '^SELECT', 201, \n  'select /*+ mirrored */', 1, 1, 'mirror sql modified');\n\n\nload mysql query rules to runtime;\n</code></pre><p>上面的例子中，rule_id为20的规则，设置了mirror_flagOut=1001，rule_id为21的规则，设置了flagIn=1001，也就是将转发给hostgroup 200的Select语句，同时也转发一份到hostgroup 201，转发时，还加上了一个注释。</p><h2>ProxySQL本身的高可用</h2><p>ProxySQL作为一个程序，本身也可能出现故障。部署ProxySQL的服务器也可能出现故障。高可用架构的一个基本原则是消除单点。那我们怎么解决ProxySQL的单点问题呢？</p><p>我们来看解决办法。你可以在多台服务器上部署ProxySQL，在ProxySQL前再加一层负载均衡（如使用LVS或其他网络层的技术），从而消除ProxySQL的单点。</p><p><img src=\"https://static001.geekbang.org/resource/image/36/ca/3654072765f00ee62a2fb7f95285a7ca.jpg?wh=1344x974\" alt=\"图片\"></p><p>部署多台ProxySQL后，需要保证配置信息同步。不然就可能会引起客户端访问出错。可以使用ProxySQL自带的集群功能，来实现多个节点之间的配置信息同步。</p><p>开启ProxySQL的集群功能，需要做一些配置。</p><ol>\n<li>\n<p>配置cluster账号，用于查询对比集群内各proxysql节点的配置信息。</p>\n</li>\n<li>\n<p>配置proxysql_servers，将集群内的proxysql节点信息添加到proxysql_servers表。</p>\n</li>\n</ol><p>这些操作要到集群中的所有ProxySQL节点上执行。</p><h3>配置cluster账号</h3><p>通过参数admin-cluster_username和admin-cluster_password设置cluster账号。不能使用admin账号作为cluster账号，因为admin账号只能在本地（127.0.0.1）登录。同时还需要将cluster账号添加到参数admin-admin_credentials中。</p><pre><code class=\"language-plain\">set admin-admin_credentials = 'admin:admin;clusteradmin:passadmin';\n\nset admin-cluster_username='clusteradmin';\nset admin-cluster_password='passadmin';\n\nload admin variables to runtime;\nsave admin variables to disk;\n</code></pre><h3>使用ProxySQL集群</h3><p>我们把组成proxysql集群的多个节点的信息添加到proxysql_servers表。</p><pre><code class=\"language-plain\">mysql&gt; show create table proxysql_servers\\G\n*************************** 1. row ***************************\n       table: proxysql_servers\nCreate Table: CREATE TABLE proxysql_servers (\n    hostname VARCHAR NOT NULL,\n    port INT NOT NULL DEFAULT 6032,\n    weight INT CHECK (weight &gt;= 0) NOT NULL DEFAULT 0,\n    comment VARCHAR NOT NULL DEFAULT '',\n    PRIMARY KEY (hostname, port) )\n1 row in set (0.00 sec)\n\ninsert into proxysql_servers（hostname, port, weight, comment)\n    values('172.16.121.234', 6032, 1, 'proxysql node 1');\n    \ninsert into proxysql_servers \n    values('172.16.121.236', 7032, 1, 'proxysql node 2');\n\n\nload proxysql servers to runtime;\nsave proxysql servers to disk;\n</code></pre><p>这样配置好之后，在一个ProxySQL节点上修改的配置，会自动同步到集群的其他节点上。</p><h2>ProxySQL配置表参考</h2><p>ProxySQL的配置主要通过一些配置表来实现。这里我对文章中用到的几个配置表做一个简单的说明，方便你查看。更详细的信息，你可以看<a href=\"https://proxysql.com/documentation/main-runtime/\">官方文档</a>。</p><h3>mysql_servers</h3><p><img src=\"https://static001.geekbang.org/resource/image/59/8f/5926bf91221e0a9fd9028ca63a3b3f8f.png?wh=1518x1406\" alt=\"图片\"></p><h3>mysql_users</h3><p><img src=\"https://static001.geekbang.org/resource/image/b0/dc/b00d47234ce3276dab01a285abb00bdc.png?wh=1518x1440\" alt=\"图片\"></p><h3>mysql_query_rules</h3><p><img src=\"https://static001.geekbang.org/resource/image/9d/6f/9d0c9607f8127e64fef00982be82b36f.png?wh=1620x1532\" alt=\"图片\"></p><h3>mysql_replication_hostgroups</h3><p><img src=\"https://static001.geekbang.org/resource/image/c9/f2/c9c36e35e9608yy0928yy587b56ce6f2.png?wh=1920x764\" alt=\"图片\"></p><h3>mysql_group_replication_hostgroups</h3><p><img src=\"https://static001.geekbang.org/resource/image/1a/39/1a777fa64274d8f256eebccf7d722839.png?wh=1470x1374\" alt=\"图片\"></p><h2>总结</h2><p>在应用程序和后端MySQL之间，增加一层Proxy，可以向应用屏蔽掉后端MySQL主备切换的一些细节。这样对应用程序而言，使用起来更加方便。同时，Proxy还可以起到连接池的作用。</p><p>这里，其实还有一个问题没有解决，就是后端的MySQL怎么切换？早期比较有名的是MHA工具。在云上，各个云厂商提供的RDS高可用版本，一般都标配了数据库自动切换的功能。</p><p>如果是自建的环境，你可以调研下一些开源的工具，比如MHA、Orchestrator等。如果数据库的数量有一定的规模，你也可以考虑自己实现一个数据库自动切换的工具。</p><h2>思考题</h2><p>如果自己实现一个MySQL的自动切换程序，要考虑哪些方面的问题？</p><p>期待你的思考，欢迎在留言区中与我交流。如果今天的课程让你有所收获，也欢迎转发给有需要的朋友。我们下节课再见。</p>","comments":[{"had_liked":false,"id":396140,"user_name":"美妙的代码","can_delete":false,"product_type":"c1","uid":1111985,"ip_address":"黑龙江","ucode":"9DADD72C193296","user_header":"https://static001.geekbang.org/account/avatar/00/10/f7/b1/982ea185.jpg","comment_is_top":false,"comment_ctime":1733226300,"is_pvip":true,"replies":[{"id":143823,"content":"是的。","user_name":"作者回复","user_name_real":"编辑","uid":3898827,"ctime":1733305795,"ip_address":"浙江","comment_id":396140,"utype":1}],"discussion_count":1,"race_medal":1,"score":2,"product_id":100799401,"comment_content":"MySQLproxy，MySQL router 都是这个功能吧","like_count":0,"discussions":[{"author":{"id":3898827,"avatar":"https://static001.geekbang.org/account/avatar/00/3b/7d/cb/fa3dae58.jpg","nickname":"俊达","note":"","ucode":"F79BF9651AD086","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":654720,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1733305795,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]}]}