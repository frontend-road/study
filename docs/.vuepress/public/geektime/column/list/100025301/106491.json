{"id":106491,"title":"33 | 横看成岭侧成峰：再战Streaming WordCount","content":"<p>你好，我是蔡元楠。</p><p>今天我要与你分享的主题是“横看成岭侧成峰：再战Streaming WordCount”。</p><p>在上一讲中，我们学习了Beam窗口（Window）的概念。当时，我们提到窗口技术的产生是因为我们想要根据时间戳去分组处理一个PCollection中的元素。</p><p>我们也提到了在“统计莎士比亚文集词频”这个例子中，如果莎士比亚穿越到了现代，成了一名极客时间的专栏作家，我们就可能需要根据他文章的写作时间来统计词频了。</p><p>举个具体的例子的话，就是我们能不能灵活地得到莎士比亚在2017年9月使用的高频词汇？或者是他在2018年第7个周五偏爱使用的高频词汇呢？</p><p>时效性是数据处理很重要的一部分，类似上面这样的问题还有很多。</p><p>比如，能不能根据实时交通数据，得到最近24小时之内拥堵的道路？能不能根据所有微信分享文章的点击数据，得到过去一周最热门的文章？这些问题都是可以用窗口技术来解决。</p><p>所以今天这一讲，我们就来看看怎样在WordCount这个例子中使用窗口技术。我会介绍怎样在Beam中实现以下六个问题：</p><ol>\n<li>怎样区分有界数据还是无界数据？</li>\n<li>怎样读取无边界数据？</li>\n<li>怎样给PCollection数据添加时间戳？</li>\n<li>怎样在PCollection应用窗口？</li>\n<li>怎样复用之前的DoFn和PTransform？</li>\n<li>怎样存储无边界数据？</li>\n</ol><!-- [[[read_end]]] --><h3>怎样区分有界数据还是无界数据？</h3><p>我们知道，在Beam中你可以用同一个Pipeline处理有边界数据或者无边界数据。但我们在处理两者时的思考方式和操作方法还是有细微的不同的。</p><p>比如，有界数据之所以有界，是因为你在处理数据时，所有的数据就已经准备就绪了。</p><p>在<a href=\"https://time.geekbang.org/column/article/105324\">第31讲</a>的WordCount例子中，莎士比亚文集早已成为历史，不会有新的作品了。所以，你可以用有界数据的处理方式进行实现。当你的数据输入是有界的时候，下游的数据一般也是有界的。因为你的数据元素是有限的，在数据处理的过程中，不会凭空造出无限多的数据。</p><p>而无边界数据的到来是时刻不停的。在你处理处理流水线的任意时刻，数据都没有完全结束。</p><p>比如，在我们<a href=\"https://time.geekbang.org/column/article/90081\">第1讲</a>中提到的处理美团外卖电动车例子中，美团外卖电动车的图片就是一直在不停地更新。你不可能说“我已经有了所有的外卖电动车图片了”。在无界数据的处理流水线中，因为输入数据是无界的，所以下游的处理结果一般也是无界的。</p><p>相信你已经掌握了区分区分有界和无界数据方法。在接下来的内容中，我们会看到针对两种数据的不同处理方式。</p><p>但是，不论是有界数据还是无界数据，在Beam中我们都可以用窗口把数据按时间分割成一些有限大小的集合。只是对于无界数据，你必须使用窗口对数据进行分割，然后对每个窗口内的数据集进行处理。</p><h3>怎样读取无边界数据？</h3><p>在<a href=\"https://time.geekbang.org/column/article/105324\">第31讲</a>WordCount的案例中，我们从一个外部文本文件读取了莎士比亚全集的文本内容。当时，我们使用的是Beam的TextIO：</p><p>Java</p><pre><code>Pipeline p = Pipeline.create(options);\n\np.apply(&quot;ReadLines&quot;, TextIO.read().from(options.getInputFile()))\n</code></pre><p>这是因为我们当时面对的是有边界的数据，在我们的数据处理流水线运行之前，所有的莎士比亚全集文本早已准备就绪，所以我们可以一股脑儿全部读进来。但是当输入数据是无界的时候，我们就没法这样读取数据了。常见的无界数据读取自logging系统或者Pub/Sub系统。</p><p>由于logging系统一直在不断地运行，新的log在不停地产生，并且每条log都自带时间戳。比如，我们想要根据用户对于微信文章的点击log分析不同时刻的热门文章，我们就可以去读取微信文章的log。而在Pub/Sub系统中，我们订阅的消息也会永无止境地到来，类似的一般Pub/Sub订阅的每条消息也会自带原生的时间戳。</p><p>这一讲中，我们已经假设莎士比亚穿越到现代在极客时间开了个专栏。我们不妨把他的专栏文章更新设计在一个Kafka消息系统中。</p><p>如下图所示，即使你并没有使用过Kafka也没有关系。你只需要知道在我们的数据处理系统中能够不定时地收到来自莎士比亚的文章更新，每一次的文章更新包含了更新的文章标题和更新内容。</p><p><img src=\"https://static001.geekbang.org/resource/image/4f/85/4f075951e25ad5eb9792468d4c802085.png?wh=1500*764\" alt=\"\"></p><p>这时，我们可以使用Beam的Kafka IO来读取来自Kafka的订阅消息。</p><p>在下面的示例代码中，我们指定了需要读取的Kafka消息主题“shakespeare”，以及Kafka消息的key/value类型都是String。你需要注意这里的读取选项withLogAppendTime()，它的意思是我们用Kafka的log append time作为我们beam PCollection数据集的时间戳。</p><p>Java</p><pre><code>pipeline\n    .apply(KafkaIO.&lt;String, String&gt;read()\n       .withBootstrapServers(&quot;broker_1:9092,broker_2:9092&quot;)\n       .withTopic(&quot;shakespeare&quot;)  // use withTopics(List&lt;String&gt;) to read from multiple topics.\n       .withKeyDeserializer(StringDeserializer.class)\n       .withValueDeserializer(StringDeserializer.class)\n       .withLogAppendTime()\n    )\n</code></pre><h3>怎样给PCollection数据添加时间戳？</h3><p>一般情况下，窗口的使用场景中，时间戳都是原生的。就如同我们从Kafka中读取消息记录一样，时间戳是自带在每一条Kafka消息中的。</p><p>但Beam也允许我们手动给PCollection的元素添加时间戳。例如第31讲的WordCount例子本身就是一个有界数据集，你还记得吗？那么我们怎么给这些有界数据集添加时间戳呢？</p><p>第31讲的输入数据格式就是简单的文本文件：</p><pre><code>\tHAMLET\n\nACT I\n\nSCENE I\tElsinore. A platform before the castle.\n\n\t[FRANCISCO at his post. Enter to him BERNARDO]\n\nBERNARDO\tWho's there?\n\nFRANCISCO\tNay, answer me: stand, and unfold yourself.\n</code></pre><p>为了方便阐述概念，我们不妨假设一下，现在我们的输入文件变成了如下的格式，每一行的开头都会带有一个时间戳，在冒号分隔符号之后才是我们需要处理的文本：</p><pre><code>2019-07-05:\tHAMLET\n\n2019-07-06: ACT I\n\n2019-07-06:  SCENE I\tElsinore. A platform before the castle.\n\n2019-07-07: \t[FRANCISCO at his post. Enter to him BERNARDO]\n\n2019-07-07: BERNARDO\tWho's there?\n\n2019-07-07: FRANCISCO\tNay, answer me: stand, and unfold yourself.\n</code></pre><p>当时我们是直接对每一行的文本提取了所有的单词。但在现在这样的输入格式下，我们就可以先把每一行开头的时间戳提取出来。在DoFn的processElement实现中，我们用outputWithTimestamp()方法，可以对于每一个元素附上它所对应的时间戳。</p><p>Java</p><pre><code>static class ExtractTimestampFn extends DoFn&lt;String, String&gt; {\n  @ProcessElement\n  public void processElement(ProcessContext c) {\n    String extractedLine = extractLine(c.element());\n    Instant timestamp =\n      new Instant(extractTimestamp(c.element());\n\n    c.outputWithTimestamp(extractedLine, timestamp);\n  }\n}\n</code></pre><h3>怎样在PCollection应用窗口？</h3><p>通过前面的内容，我们已经解决了“PCollection的时间戳来自于哪里”的问题。在无界数据的应用场景中，时间戳往往是数据记录自带的，比如来自Kafka消息。在有界数据的应用场景中，时间戳往往需要自己指定，比如我们读取的自定义的莎士比亚文集格式。</p><p>PCollection元素有了时间戳，我们就能根据时间戳应用窗口对数据进行划分。<a href=\"https://time.geekbang.org/column/article/105707\">第32讲</a>中，我们已经介绍了常见的窗口种类，有固定窗口、滑动窗口和会话窗口。</p><p>要把特定的窗口应用到PCollection上，我们同样使用PCollection的apply()方法。如果是固定窗口，我们就用FixedWindows类型，如果是滑动窗口就用SlidingWindows类型，相应的如果是会话窗口我们就用Sessions窗口类型。下面的代码示例就是使用FixedWindows的情况：</p><p>Java</p><pre><code>PCollection&lt;String&gt; windowedWords = input\n  .apply(Window.&lt;String&gt;into(\n    FixedWindows.of(Duration.standardMinutes(options.getWindowSize()))));\n</code></pre><h3>怎样复用之前的DoFn和PTransform？</h3><p>有了窗口，我们下一步就是把之前的DoFn和PTransform应用到数据集上。</p><p>这一步其实是最简单的。因为Beam的Transform不区分有界数据还是无界数据。我们可以一行代码不改，和第31讲用到的例子一样，直接使用之前的CountWords这个PTransform就可以了。</p><p>Java</p><pre><code>PCollection&lt;KV&lt;String, Long&gt;&gt; wordCounts = windowedWords.apply(new WordCount.CountWords());\n</code></pre><p>值得注意的是，在应用了窗口之后，Beam的transform是在每一个窗口中间进行数据处理的。在我们的例子中，词频统计的是每一个窗口里的词频，而不再是全局的词频。</p><h3>怎样输出无边界数据？</h3><p>同数据读取对应，无边界数据的输出也是与有界数据大相径庭。在第31讲中，我们把数据处理结果写进了一个外部文件中，使用了TextIO：</p><p>Java</p><pre><code>pipeline.apply(&quot;WriteCounts&quot;, TextIO.write().to(options.getOutput()));\n</code></pre><p>但是在无边界的应用场景中，数据在持续不断地进来。最常见的输出模式是把处理结果还是以Pub/Sub的模式发布出去。</p><p>假设我们用Google Pub/Sub输出我们的处理结果的话，我们可以用PubsubIO.writeStrings()方法。同样，这里的输出结果是针对每一个窗口的，每一个窗口都会输出自己的词频统计结果。</p><p>Java</p><pre><code>pipeline.apply(&quot;Write to PubSub&quot;, PubsubIO.writeStrings().to(options.getOutputTopic()));\n</code></pre><h2>小结</h2><p>今天我们深入探索了Beam窗口在流处理的场景中的应用。</p><p>我们巩固了区分有界数据还是无界数据的方法，掌握了在Beam中怎样读取无边界数据，怎样给PCollection数据添加时间戳，怎样在PCollection应用窗口，怎样复用之前的DoFn和PTransform和怎样输出无边界数据。</p><p>将这些方法融会贯通后，相信类似的时间性数据处理或者是流处理问题在你手中都能迎刃而解了。</p><h2>思考题</h2><p>你的工作中有哪些应用场景不适合一般的数据批处理呢？能否利用这里介绍窗口方式处理？</p><p>欢迎你把答案写在留言区，与我和其他同学一起讨论。如果你觉得有所收获，也欢迎把文章分享给你的朋友。</p><p></p>","neighbors":{"left":{"article_title":"32 | Beam Window：打通流处理的任督二脉","id":105707},"right":{"article_title":"34 | Amazon热销榜Beam Pipeline实战","id":107053}},"comments":[{"had_liked":false,"id":112430,"user_name":"陈","can_delete":false,"product_type":"c1","uid":1006448,"ip_address":"","ucode":"A8E6AFF6E5775D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5b/70/6411282d.jpg","comment_is_top":false,"comment_ctime":1562731388,"is_pvip":false,"replies":[{"id":"41403","content":"谢谢你的留言！窗口理论是可以无限大的，如果你想计算每天用户访问量比较直观的做法就是设置一个窗口时长为24小时的固定窗口。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1563144004,"ip_address":"","comment_id":112430,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10152665980","product_id":100025301,"comment_content":"老师，窗口的跨度能多大，比如我想计算每天用户访问量？","like_count":3,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457731,"discussion_content":"谢谢你的留言！窗口理论是可以无限大的，如果你想计算每天用户访问量比较直观的做法就是设置一个窗口时长为24小时的固定窗口。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563144004,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":112577,"user_name":"Ming","can_delete":false,"product_type":"c1","uid":1516011,"ip_address":"","ucode":"69BB73B8AB7E3F","user_header":"https://static001.geekbang.org/account/avatar/00/17/21/eb/bb2e7a3b.jpg","comment_is_top":false,"comment_ctime":1562764146,"is_pvip":false,"replies":[{"id":"41475","content":"谢谢你的留言！你所说的pipeline更换计算逻辑是指应用层的逻辑还是底层实现的抽象方法？如果是底层实现的抽象方法，那还是要由底层来实现的。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1563166988,"ip_address":"","comment_id":112577,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5857731442","product_id":100025301,"comment_content":"假如要给一个流处理的pipeline更换计算逻辑的话，在Beam层上要做相应处理吗？还是完全由底层的实现来处理的？<br><br>Beam虽好，但是似乎，作为开发首当其冲的还是要熟练掌握一个底层计算框架。","like_count":1,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457801,"discussion_content":"谢谢你的留言！你所说的pipeline更换计算逻辑是指应用层的逻辑还是底层实现的抽象方法？如果是底层实现的抽象方法，那还是要由底层来实现的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563166988,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1897610,"avatar":"","nickname":"Fiery","note":"","ucode":"CDB000687A6B14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":204560,"discussion_content":"operator级别的优化和开发都是在底层做的，不过beam是会帮你做一定的DAG级别的优化，所以DAG级别的优化和开发可以在beam里做，但是感觉有好多优化和应该和数据存储形式和底层计算方式的实现分不开的所以还是得在底层才能做好，这种时候感觉前后端分离就不如垂直整合好了。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584192181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":112518,"user_name":"三水","can_delete":false,"product_type":"c1","uid":1017781,"ip_address":"","ucode":"11837CF38FD9BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/b5/dd0353f4.jpg","comment_is_top":false,"comment_ctime":1562750349,"is_pvip":false,"replies":[{"id":"41624","content":"谢谢你的提问！其实Beam对于python的支撑确实没有Java的多。在没有原生支持的情况下是需要自己实现。我知道python对于KafkaIO现在有Work in process的。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1563247105,"ip_address":"","comment_id":112518,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5857717645","product_id":100025301,"comment_content":"老师，现在使用 Beam 模型的项目中，使用 Python 语言的多吗？如果用 Python 语言的话，Beam 除了Google的 云 Pub&#47;Sub，还不支持 Kafka 类似的，Built-in I&#47;O Transform 也太少了，这些都需要自己实现吗？","like_count":1,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457776,"discussion_content":"谢谢你的提问！其实Beam对于python的支撑确实没有Java的多。在没有原生支持的情况下是需要自己实现。我知道python对于KafkaIO现在有Work in process的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563247105,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":266993,"user_name":"端碗吹水","can_delete":false,"product_type":"c1","uid":1513890,"ip_address":"","ucode":"D4D0126969650A","user_header":"https://static001.geekbang.org/account/avatar/00/17/19/a2/f70dae3a.jpg","comment_is_top":false,"comment_ctime":1607565320,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1607565320","product_id":100025301,"comment_content":"请问老师，假设有个报表需求是实时显示从起始至今所有数据的平均值，那么流处理能否实现这种对开始至今的数据求平均值，如果能的话是不是每次新数据到来都得重算数据","like_count":0},{"had_liked":false,"id":207094,"user_name":"Junjie.M","can_delete":false,"product_type":"c1","uid":1667133,"ip_address":"","ucode":"6E40909A02DFB1","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/3d/93aa82b6.jpg","comment_is_top":false,"comment_ctime":1587005853,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587005853","product_id":100025301,"comment_content":"老师请问对于PTransform Runner是DIRECT时可以设置并行度吗","like_count":0},{"had_liked":false,"id":112351,"user_name":"JohnT3e","can_delete":false,"product_type":"c1","uid":1063982,"ip_address":"","ucode":"CF4AAAC933529C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLdWHFCr66TzHS2CpCkiaRaDIk3tU5sKPry16Q7ic0mZZdy8LOCYc38wOmyv5RZico7icBVeaPX8X2jcw/132","comment_is_top":false,"comment_ctime":1562722874,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1562722874","product_id":100025301,"comment_content":"无界数据中窗口的时间跨度的选择是否可以从下面这些方面考虑：<br>1. 业务实时性要求<br>2. 数据量<br>比如文章中的统计一个月的高频词和某一周的，那么可以选择窗口长度为一周的固定窗口（常用英文单词是有限的，且莎士比亚一周产出的文章数量也是比较有限的。同时也符合业务上的时间要求），后面再设置一个长度为一个月的窗口，将上一个输出的PCollection结果进行合并。","like_count":0,"discussions":[{"author":{"id":1127175,"avatar":"https://static001.geekbang.org/account/avatar/00/11/33/07/8f351609.jpg","nickname":"JustDoDT","note":"","ucode":"6AF0B80F00EAEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":9533,"discussion_content":"我认为还是重新计算，当你算一个月窗口的时候，有可能之前的数据会有变动。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568182616,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}