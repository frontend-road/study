{"id":325794,"title":"03 | 重复代码：简单需求到处修改，怎么办？","content":"<p>你好，我是郑晔。</p><p>前面两讲，我们讨论了命名中的坏味道。今天，我们来讨论另外一个常见的坏味道：重复代码。</p><p>记得我刚开始工作的时候，有人开玩笑说，编程实际上就是 CVS（CVS是当时流行的一个版本控制工具，相当于今天的 Git），也就是 Ctrl+C、Ctrl+V、Ctrl+S，或许你已经听出来了，这是在调侃很多程序员写程序依靠的是复制粘贴。</p><p>时至今日，很多初级程序员写代码依然规避不了复制粘贴，基本的做法就是把一段代码复制过来，改动几个地方，然后，跑一下没有太大问题就万事大吉了。殊不知，这种做法就是在给未来挖坑。</p><p>通常情况下，只要这些复制代码其中有一点逻辑要修改，就意味着所有复制粘贴的地方都要修改。所以，我们在实际的项目中，常常看见这样的情况：明明是一个简单的需求，你却需要改很多的地方，需要花费很长的时间，结果无论是项目经理，还是产品经理，对进度都很不满意。</p><p>更可怕的是，只要你少改了一处，就意味着留下一处潜在的问题。问题会在不经意间爆发出来，让人陷入难堪的境地。</p><p>复制粘贴是最容易产生重复代码的地方，所以，一个最直白的建议就是，不要使用复制粘贴。<strong>真正应该做的是，先提取出函数，然后，在需要的地方调用这个函数。</strong></p><p>其实，复制粘贴的重复代码是相对容易发现的，但有一些代码是有类似的结构，这也是重复代码，有些人对这类坏味道却视而不见。</p><!-- [[[read_end]]] --><h2>重复的结构</h2><p>我们看一下下面的几段代码：</p><pre><code>@Task\npublic void sendBook() {\n  try {\n    this.service.sendBook();\n  } catch (Throwable t) {\n    this.notification.send(new SendFailure(t)));\n    throw t;\n  }\n}\n</code></pre><pre><code>@Task\npublic void sendChapter() {\n  try {\n    this.service.sendChapter();\n  } catch (Throwable t) {\n    this.notification.send(new SendFailure(t)));\n    throw t;\n  }\n}\n</code></pre><pre><code>@Task\npublic void startTranslation() {\n  try {\n    this.service.startTranslation();\n  } catch (Throwable t) {\n    this.notification.send(new SendFailure(t)));\n    throw t;\n  }\n}\n</code></pre><p>这三段函数业务的背景是：一个系统要把作品的相关信息发送给翻译引擎。所以，结合着代码，我们就不难理解它们的含义，sendBook 是把作品信息发出去，sendChapter 就是把章节发送出去，而 startTranslation 则是启动翻译。</p><p>这几个业务都是以后台的方式在执行，所以，它们的函数签名上增加了一个 Task 的 Annotation，表明它们是任务调度的入口。然后，实际的代码执行放到了对应的业务方法上，也就是 service 里面的方法。</p><p>这三个函数可能在许多人看来已经写得很简洁了，但是，这段代码的结构上却是有重复的，请把注意力放到 catch 语句里。</p><p>之所以要做一次捕获（catch），是为了防止系统出问题无人发觉。捕获到异常后，我们把出错的信息通过即时通讯工具发给相关人等，代码里的 notification.send 就是发通知的入口。相比于原来的业务逻辑，这个逻辑是后来加上的，所以，这段代码的作者不厌其烦地在每一处修改了代码。</p><p>我们可以看到，虽然这三个函数调用的业务代码不同，但它们的结构是一致的，其基本流程可以理解为：</p><ul>\n<li>调用业务函数；</li>\n<li>如果出错，发通知。</li>\n</ul><p>当你能够发现结构上的重复，我们就可以把这个结构提取出来。从面向对象的设计来说，就是提出一个接口，就像下面这样：</p><pre><code>private void executeTask(final Runnable runnable) {\n  try {\n    runnable.run();\n  } catch (Throwable t) {\n    this.notification.send(new SendFailure(t)));\n    throw t;\n  }\n}\n</code></pre><p>有了这个结构，前面几个函数就可以用它来改写了。对于支持函数式编程的程序设计语言来说，可以用语言提供的便利写法简化代码的编写，像下面的代码就是用了 Java 里的方法引用（Method Reference）：</p><pre><code>@Task\npublic void sendBook() {\n  executeTask(this.service::sendBook);\n}\n</code></pre><pre><code>@Task\npublic void sendChapter() {\n  executeTask(this.service::sendChapter);\n}\n</code></pre><pre><code>@Task\npublic void startTranslation() {\n  executeTask(this.service::startTranslation);\n}\n</code></pre><p>经过这个例子的改写，如果再有一些通用的结构调整，比如，在任务执行前后要加上一些日志信息，这样的改动就可以放到 executeTask 这个函数里，而不用四处去改写了。</p><p>这个例子并不复杂，关键点在于，能不能发现结构上的重复。因为相比于直接复制的代码，结构上的重复看上去会有一些迷惑性。比如，在这个例子里，发送作品信息、发送章节、启动翻译看起来是三件不同的事，很难让人一下反应过来它也是重复代码。</p><p>一般来说，参数是名词，而函数调用，是动词。我们传统的程序设计教育中，对于名词是极度重视的，但我们必须认识到一点，动词也扮演着重要的角色，尤其是在函数式编程兴起之后。那你就需要知道，动词不同时，并不代表没有重复代码产生。</p><p>理解到这一点，我们就容易发现结构上的相似之处。比如在上面的例子中，发送作品信息、发送章节、启动翻译之所以看上去是三件不同的事，只是因为它们的动词不同，但是除了这几个动词之外的其它部分是相同的，所以，它们在结构上是重复的。</p><h2>做真正的选择</h2><p>我们再来看一段代码：</p><pre><code>if (user.isEditor()) {\n  service.editChapter(chapterId, title, content, true);\n} else {\n  service.editChapter(chapterId, title, content, false);\n}\n</code></pre><p>这是一段对章节内容进行编辑的代码。这里有一个业务逻辑，章节只有在审核通过之后，才能去做后续的处理，比如，章节的翻译。所以，这里的 editChapter 方法最后那个参数表示是否审核通过。</p><p>在这段代码里面，目前的处理逻辑是，如果这个章节是由作者来编辑的，那么这个章节是需要审核的，如果这个章节是由编辑来编辑的，那么审核就直接通过了，因为编辑本身同时也是审核人。不过，这里的业务逻辑不是重点，只是帮助你理解这段代码。</p><p>问题来了，这个 if 选择的到底是什么呢？</p><p>相信你和我一样，第一眼看到这段代码的感觉一定是，if 选择的一定是两段不同的业务处理。但只要你稍微看一下，就会发现，if 和 else 两段代码几乎是一模一样的。在经过仔细地“找茬”之后，才能发现，原来是最后一个参数不一样。</p><p>只有参数不同，是不是和前面说的重复代码是如出一辙的？没错，这其实也是一种重复代码。</p><p>只不过，这种重复代码通常情况下是作者自己写出来的，而不是粘贴出来的。因为作者在写这段代码时，<strong>脑子只想到 if 语句判断之后要做什么，而没有想到这个 if 语句判断的到底是什么。</strong>但这段代码客观上也造就了重复。</p><p>写代码要有表达性。把意图准确地表达出来，是写代码过程中非常重要的一环。显然，这里的 if 判断区分的是参数，而非动作。所以，我们可以把这段代码稍微调整一下，会让代码看上去更容易理解：</p><pre><code>boolean approved = user.isEditor();\nservice.editChapter(chapterId, title, content, approved);\n</code></pre><p>请注意，这里我把 user.isEditor() 判断的结果赋值给了一个 approved 的变量，而不是直接作为一个参数传给 editChapter，这么做也是为了提高这段代码的可读性。因为 editChapter 最后一个参数表示的是这个章节是否审核通过。通过引入 approved 变量，我们可以清楚地看到，一个章节审核是否通过的判断条件是“用户是否是一个编辑”，这种写法会让代码更清晰。</p><p>如果将来审核通过的条件改变了，变化的点全都在 approved 的这个变量的赋值上面。如果你追求更有表达性的做法，甚至可以提取一个函数出来，这样，就把变化都放到这个函数里了，就像下面这样：</p><pre><code>boolean approved = isApproved(user);\nservice.editChapter(chapterId, title, content, approved);\n\n\nprivate boolean isApproved(final User user) {\n  return user.isEditor();\n}\n</code></pre><p>为了说明问题，我特意选择了一段简单的代码，if 语句的代码块里只有一个语句。在实际的工作中，if 语句没有有效地去选择目标是经常出现的，有的是参数列表比较长，有的是在 if 的代码块里有多个语句。</p><p>所以，<strong>只要你看到 if 语句出现，而且 if 和 else 的代码块长得又比较像，多半就是出现了这个坏味道。</strong>如果你不想所有人都来玩“找茬”游戏，赶紧消灭它。</p><p>重复是一个泥潭，对于程序员来说，时刻提醒自己不要重复是至关重要的。在软件开发里，有一个重要的原则叫做 Don't Repeat Yourself（不要重复自己，简称 DRY），我在《<a href=\"https://time.geekbang.org/column/intro/100052601\">软件设计之美</a>》中也讲到过它，而更经典的叙述在《<a href=\"https://book.douban.com/subject/35006892/\">程序员修炼之道</a>》中。</p><blockquote>\n<p>在一个系统中，每一处知识都必须有单一、明确、权威地表述。<br>\nEvery piece of knowledge must have a single, unambiguous, authoritative representation within a system.</p>\n</blockquote><p><strong>写代码要想做到 DRY，一个关键点是能够发现重复</strong>。发现重复，一种是在泥潭中挣扎后，被动地发现，还有一种是提升自己识别能力，主动地发现重复。这种主动识别的能力，其实背后要有对软件设计更好的理解，尤其是对分离关注点的理解（如果你对“分离关注点”的知识感兴趣，可以参考我在《软件设计之美》中的<a href=\"https://time.geekbang.org/column/article/240749\">02</a>讲）。</p><h2>总结时刻</h2><p>这一讲我们讲到重复代码，讲到了几个典型的坏味道：</p><ul>\n<li>复制粘贴的代码；</li>\n<li>结构重复的代码；</li>\n<li>if 和 else 代码块中的语句高度类似。</li>\n</ul><p>很多重复代码的产生通常都是从程序员偷懒开始的，而这些程序员的借口都是为了快，却为后续工作埋下更多地隐患，真正的“欲速而不达”。</p><p>复制粘贴的代码和结构重复的代码，虽然从观感上有所差异，但本质上都是重复，只不过，一个是名词的微调，一个是动词的微调。</p><p>程序员千万不要复制粘贴，<strong>如果需要复制粘贴，首先应该做的是提取一个新的函数出来，把公共的部分先统一掉。</strong></p><p>if 和 else 的代码块中的语句高度类似，通常是程序员不经意造成的，但这也是对于写代码没有高标准要求的结果。让 if 语句做真正的选择，是提高代码表达准确性的重要一步。</p><p>作为一个精进中的程序员，我们一定要把 DRY 原则记在心中，时时刻刻保持对“重复”的敏感度，把各种重复降到最低。</p><p>如果今天的内容你只能记住一件事，那请记住：<strong>不要重复自己，不要复制粘贴</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/b1/d0/b191yy7a7dc54572cb7fce85d80f5fd0.jpg?wh=2284*3156\" alt=\"\"></p><h2>思考题</h2><p>这一讲的主题是重复代码，你在实际工作中都遇到过什么样的重复代码，你是怎样处理它们的呢？欢迎在留言区分享你的经验。</p><p><span class=\"reference\">参考资料：</span><br>\n<a href=\"https://time.geekbang.org/column/article/240749\">分离关注点：软件设计至关重要的第一步</a></p><p><a href=\"https://time.geekbang.org/column/article/265128\">简单设计：难道一开始就要把设计做复杂吗？</a></p>","comments":[{"had_liked":false,"id":271890,"user_name":"醒了不起床","can_delete":false,"product_type":"c1","uid":1210561,"ip_address":"","ucode":"3BFA9BE661A3AE","user_header":"https://static001.geekbang.org/account/avatar/00/12/78/c1/e9f7f6ad.jpg","comment_is_top":false,"comment_ctime":1609853341,"is_pvip":false,"replies":[{"id":"98602","content":"很好的补充","user_name":"作者回复","comment_id":271890,"uid":"1258861","ip_address":"","utype":1,"ctime":1609891522,"user_name_real":"郑晔"}],"discussion_count":2,"race_medal":0,"score":"61739395485","product_id":100068401,"comment_content":"自己总结重复代码过多的一些原因<br>    1 代码结构不合理导致同一个实现散落各处由于初期代码结构设计不合理导致后续功能实现无法快速找到已有实现，或者找到了但是不好引用已有实现。改进：初期设计代码逻辑合理，对于不合理的地方要及时重构 防止演变成原因2<br>    2 为了稳定性，不动老逻辑 拷贝一份。由于对于业务的不熟悉和对自己代码能力的不信任不敢重构导致。改进通过微重构进行多次迭代小改进慢慢优化<br>    3 写的时候为了快 由于时间紧张或者能力问题无法识别出的坏代码。改进提升能力","like_count":15,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513083,"discussion_content":"很好的补充","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609891522,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1193874,"avatar":"https://static001.geekbang.org/account/avatar/00/12/37/92/961ba560.jpg","nickname":"授人以🐟，不如授人以渔","note":"","ucode":"BD53829E924B66","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":566523,"discussion_content":"请问，对于代码结构的设计问题，如何提升？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650709502,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":513083,"ip_address":""},"score":566523,"extra":""}]}]},{"had_liked":false,"id":272330,"user_name":"sfqqyq","can_delete":false,"product_type":"c1","uid":2394942,"ip_address":"","ucode":"F0E237D311F867","user_header":"https://static001.geekbang.org/account/avatar/00/24/8b/3e/9f0a4ccb.jpg","comment_is_top":false,"comment_ctime":1610034673,"is_pvip":false,"replies":[{"id":"98795","content":"在一个职业的队伍里，谁发现谁修改","user_name":"作者回复","comment_id":272330,"uid":"1258861","ip_address":"","utype":1,"ctime":1610152745,"user_name_real":"郑晔"}],"discussion_count":1,"race_medal":0,"score":"44559707633","product_id":100068401,"comment_content":"和别人共同协作开发的时候，有时候也挺纠结是不是和别人有重复的代码，如果有谁来修改的问题。","like_count":11,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513241,"discussion_content":"在一个职业的队伍里，谁发现谁修改","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1610152745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":272513,"user_name":"桃子-夏勇杰","can_delete":false,"product_type":"c1","uid":1158436,"ip_address":"","ucode":"5D5F38AABA980F","user_header":"https://static001.geekbang.org/account/avatar/00/11/ad/24/c6b763b4.jpg","comment_is_top":false,"comment_ctime":1610105083,"is_pvip":true,"replies":[{"id":"98784","content":"反复利用的代码，为什么不是去写一个程序库？<br><br>得到的课程是另外一个问题，你要是觉得雷同，说明你的见识涨了。","user_name":"作者回复","comment_id":272513,"uid":"1258861","ip_address":"","utype":1,"ctime":1610116092,"user_name_real":"郑晔"}],"discussion_count":1,"race_medal":0,"score":"40264810747","product_id":100068401,"comment_content":"郑老师，俗话说，天下文章一大抄，代码估计也是同理。但是，如果代码写好了，老程序员是不是可以反复利用自己写过的代码了，而慢慢地变得没有什么代码好写了呢？（有感于自己写文章，写来写去也没有什么特别新的洞见，最近学习也有类似的感觉，很多得到上的付费课程感觉都是东抄抄西抄抄）","like_count":10,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513299,"discussion_content":"反复利用的代码，为什么不是去写一个程序库？\n\n得到的课程是另外一个问题，你要是觉得雷同，说明你的见识涨了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1610116092,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":271827,"user_name":"刘大明","can_delete":false,"product_type":"c1","uid":1035081,"ip_address":"","ucode":"83C063FBD9BF2B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cb/49/0b9ffc8e.jpg","comment_is_top":false,"comment_ctime":1609827866,"is_pvip":false,"replies":[{"id":"98582","content":"对，很多问题是可以用设计模式和工具框架去解决的。","user_name":"作者回复","comment_id":271827,"uid":"1258861","ip_address":"","utype":1,"ctime":1609832701,"user_name_real":"郑晔"}],"discussion_count":1,"race_medal":0,"score":"27379631642","product_id":100068401,"comment_content":"代码重复这个在项目中太常见了.<br>有些创建对象new 对象重复，这个时候我一般用工厂模式去解决<br>再就是很多if条件处理不同的逻辑，这种情况一般都用策略模式去解决<br>再就是实体之间的赋值，一般都用工具BeanUtils 或者 MapStruct","like_count":7,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513058,"discussion_content":"对，很多问题是可以用设计模式和工具框架去解决的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609832701,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":272557,"user_name":"adang","can_delete":false,"product_type":"c1","uid":1143712,"ip_address":"","ucode":"0F2ECF8B92D46B","user_header":"https://static001.geekbang.org/account/avatar/00/11/73/a0/7dcc9212.jpg","comment_is_top":false,"comment_ctime":1610148119,"is_pvip":false,"replies":[{"id":"98804","content":"我特别鼓励代码的集体所有，这样，就没有代码属于谁的说法了。不能透明沟通的人，不适合在团队中工作。","user_name":"作者回复","comment_id":272557,"uid":"1258861","ip_address":"","utype":1,"ctime":1610159026,"user_name_real":"郑晔"}],"discussion_count":3,"race_medal":0,"score":"23084984599","product_id":100068401,"comment_content":"1. 对于自己写的代码，重复写了多遍的，或者逻辑相似但是又不好直接引用的地方，发现后及时重构，如果项目时间紧迫来不及修改，会写好TODO，在下一次做修改或者闲暇的时候修改好；<br>2. 多人协作，对于别人的代码还是要考虑一下的，会和对方打个招呼再去改动。以前有位同事就很不喜欢别人改动他的代码，一次因为有人重构了他的代码引发了bug，他当场大发雷霆。同时他也不去改动别人的代码，即使逻辑一样他也会再写一遍，问其原因，回答要么是不知道，要么说抽象好的方法写的太复杂看不懂，不敢用。基于这样的原因，代码库里留存着很多重复的代码。","like_count":5,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513308,"discussion_content":"我特别鼓励代码的集体所有，这样，就没有代码属于谁的说法了。不能透明沟通的人，不适合在团队中工作。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1610159026,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":3179334,"avatar":"","nickname":"Geek_aa483d","note":"","ucode":"D8AC77CEB8E4EB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":588040,"discussion_content":"这背后有一个事后追责的问题，也是这个原因，导致了轻易不动别人的代码，即使他人代码确实很烂。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663488831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":513308,"ip_address":"广东"},"score":588040,"extra":""}]},{"author":{"id":1147948,"avatar":"https://static001.geekbang.org/account/avatar/00/11/84/2c/1b0926b4.jpg","nickname":"Even","note":"","ucode":"C3555903EE9525","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557106,"discussion_content":"@adang 重构别人的代码，你就得保证质量，这个是基本原则吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647662951,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":271878,"user_name":"Archer","can_delete":false,"product_type":"c1","uid":1106463,"ip_address":"","ucode":"4245EE818DE08F","user_header":"https://static001.geekbang.org/account/avatar/00/10/e2/1f/79cd6d64.jpg","comment_is_top":false,"comment_ctime":1609849846,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18789719030","product_id":100068401,"comment_content":"确实讲的很好，我在写代码的时候也经常纠结这些，全讲到了","like_count":4},{"had_liked":false,"id":299314,"user_name":"Aprelude","can_delete":false,"product_type":"c1","uid":1658796,"ip_address":"","ucode":"840D3F7A35AEEF","user_header":"https://static001.geekbang.org/account/avatar/00/19/4f/ac/80439ba7.jpg","comment_is_top":false,"comment_ctime":1624576985,"is_pvip":false,"replies":[{"id":"108726","content":"如果有返回值，就用有返回值的，比如，Function","user_name":"作者回复","comment_id":299314,"uid":"1258861","ip_address":"","utype":1,"ctime":1624880505,"user_name_real":"郑晔"}],"discussion_count":4,"race_medal":0,"score":"5919544281","product_id":100068401,"comment_content":"如果这个runable传入之后有返回值这个怎么写","like_count":1,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522400,"discussion_content":"如果有返回值，就用有返回值的，比如，Function","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624880505,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1174943,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ed/9f/497fbe0f.jpg","nickname":"Defu Li","note":"","ucode":"CAE47E53962801","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555448,"discussion_content":"作者的例子是不是错了？ 你们本地能编译吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646906775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1174943,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ed/9f/497fbe0f.jpg","nickname":"Defu Li","note":"","ucode":"CAE47E53962801","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550746,"discussion_content":"用其他的函数式接口","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644723534,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1658796,"avatar":"https://static001.geekbang.org/account/avatar/00/19/4f/ac/80439ba7.jpg","nickname":"Aprelude","note":"","ucode":"840D3F7A35AEEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380568,"discussion_content":"用callable.call可以吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624585254,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":285108,"user_name":"李叶","can_delete":false,"product_type":"c1","uid":1470449,"ip_address":"","ucode":"41B33FA8526E48","user_header":"https://static001.geekbang.org/account/avatar/00/16/6f/f1/35f9f16f.jpg","comment_is_top":false,"comment_ctime":1616629396,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5911596692","product_id":100068401,"comment_content":"DRY不要重复自己，代码重复，结构重复，分支结构类似都是重复，学习抽象，分离关注点","like_count":1},{"had_liked":false,"id":275940,"user_name":"benxiong","can_delete":false,"product_type":"c1","uid":1624574,"ip_address":"","ucode":"F6498059D439D9","user_header":"https://static001.geekbang.org/account/avatar/00/18/c9/fe/874b172b.jpg","comment_is_top":false,"comment_ctime":1611723321,"is_pvip":false,"replies":[{"id":"100277","content":"我鼓励的做法是都加上 final 参数，如果没加，可能是漏了。后面讲到可变的数据时，提到了 final 的使用，你可以看一下。","user_name":"作者回复","comment_id":275940,"uid":"1258861","ip_address":"","utype":1,"ctime":1611843694,"user_name_real":"郑晔"}],"discussion_count":2,"race_medal":0,"score":"5906690617","product_id":100068401,"comment_content":"郑老师，我看到你有的方法参数加了 final 修饰，有的没有。我只知道 final 修饰一个对象，对象的引用不可修改，对象的值是可以改的。不知道这里加 final 的意义在哪里，希望老师能解惑一下，谢谢。","like_count":1,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514537,"discussion_content":"我鼓励的做法是都加上 final 参数，如果没加，可能是漏了。后面讲到可变的数据时，提到了 final 的使用，你可以看一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611843694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1169313,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJkeOAC8k7aPMfQZ4ickiavpfR9mTQs1wGhGtIicotzAoszE5qkLfFTabkDU2E39ovSgoibJ1IiaLXtGicg/132","nickname":"bigben","note":"","ucode":"DBD15A6C8E2590","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388989,"discussion_content":"有必要，虽然可以修改内部的值，至少有两个作用：1.引用不能再修改；2.提示不要修改内部值；","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629084473,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":272815,"user_name":"Geek_3b1096","can_delete":false,"product_type":"c1","uid":1549364,"ip_address":"","ucode":"A6BD92B79B3632","user_header":"","comment_is_top":false,"comment_ctime":1610295760,"is_pvip":false,"replies":[{"id":"98960","content":"意识到是改进的前提条件。","user_name":"作者回复","comment_id":272815,"uid":"1258861","ip_address":"","utype":1,"ctime":1610457149,"user_name_real":"郑晔"}],"discussion_count":1,"race_medal":0,"score":"5905263056","product_id":100068401,"comment_content":"原来我一直在犯结构重复","like_count":1,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513400,"discussion_content":"意识到是改进的前提条件。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610457149,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":354540,"user_name":"Peter Yu","can_delete":false,"product_type":"c1","uid":1077598,"ip_address":"浙江","ucode":"D56786A6E85321","user_header":"https://static001.geekbang.org/account/avatar/00/10/71/5e/5393a76d.jpg","comment_is_top":false,"comment_ctime":1660523646,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1660523646","product_id":100068401,"comment_content":"老师您好，有个问题困惑着我：我们写业务代码的时候，对象会分DO、DTO、VO，比如Uer相关的类会有UserDO、UerDTO、UserVO，这三种对象中可能有重复的字段，更极端一点，三者的字段可能完全相同，这种重复可以通过继承来解决吗，还是有更好地处理方式。我的理解，如果是完全继承，可能导致一些隐秘信息的泄露，比如密码。如果是部分复用，那抽离出来复用的类该如何命名","like_count":0},{"had_liked":false,"id":350009,"user_name":"杯莫停","can_delete":false,"product_type":"c1","uid":1759325,"ip_address":"","ucode":"4FA1D5CBBEF702","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d8/5d/07dfb3b5.jpg","comment_is_top":false,"comment_ctime":1656502767,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1656502767","product_id":100068401,"comment_content":"我一般写代码会刻意去找重复代码，把一堆代码优化到几行，感觉很有成就感。哈哈，自娱自乐。","like_count":0},{"had_liked":false,"id":347025,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1653626720,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653626720","product_id":100068401,"comment_content":"不要重复自己，不要复制粘贴--记下来","like_count":0},{"had_liked":false,"id":343213,"user_name":"授人以🐟，不如授人以渔","can_delete":false,"product_type":"c1","uid":1193874,"ip_address":"","ucode":"BD53829E924B66","user_header":"https://static001.geekbang.org/account/avatar/00/12/37/92/961ba560.jpg","comment_is_top":false,"comment_ctime":1650709948,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650709948","product_id":100068401,"comment_content":"我自己因为一次代码重复问题，导致了一些异常现象，调用不同的函数（执行的是相同的业务逻辑），获取到的是系统相反的状态。这排查问题的过程中，花费了很长时间，这是损失之一，更严重的是误操作了测试数据库，这是不容原谅的。","like_count":0},{"had_liked":false,"id":343205,"user_name":"授人以🐟，不如授人以渔","can_delete":false,"product_type":"c1","uid":1193874,"ip_address":"","ucode":"BD53829E924B66","user_header":"https://static001.geekbang.org/account/avatar/00/12/37/92/961ba560.jpg","comment_is_top":false,"comment_ctime":1650706855,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650706855","product_id":100068401,"comment_content":"课前提问：<br>1. 重复代码的表现形式有哪些？举例说说在项目中遇到的重复代码。<br>2. 重复代码带来的潜在问题是什么？<br>3. 如何对重复修改进行修改，为什么这么修改？","like_count":0},{"had_liked":false,"id":337595,"user_name":"Defu Li","can_delete":false,"product_type":"c1","uid":1174943,"ip_address":"","ucode":"CAE47E53962801","user_header":"https://static001.geekbang.org/account/avatar/00/11/ed/9f/497fbe0f.jpg","comment_is_top":false,"comment_ctime":1646906691,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1646906691","product_id":100068401,"comment_content":"我本地模拟了一下作者的消除重复异常这个例子，发现编译不过。<br><br>    private void sendBook() throws StreamCollectionException {<br>        throw new StreamCollectionException(&quot;&quot;);<br>    }<br><br>    private void executTask(Runnable runnable) {<br>        try {<br>            runnable.run();<br>        } catch (Throwable t) {<br>            throw t;<br>        }<br>    }<br><br>    private void send() {<br>        executTask(this::sendBook);<br>    }","like_count":0,"discussions":[{"author":{"id":1054958,"avatar":"https://static001.geekbang.org/account/avatar/00/10/18/ee/a1ed60d1.jpg","nickname":"ABC","note":"","ucode":"7501AD9C0C4A70","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571613,"discussion_content":"升级你的JDK版本到最新。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652313405,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336452,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1646149586,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1646149586","product_id":100068401,"comment_content":"什么程度算是重复？有时候一个方法里掉用另一个方法两次，就感觉有点重复","like_count":0,"discussions":[{"author":{"id":1032345,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c0/99/259a412f.jpg","nickname":"Geeker","note":"","ucode":"9937127DE96D78","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556872,"discussion_content":"个人想法“以三为数”。\n写代码的时候有很多种情况，举几个例子:\n1. 项目周期非常紧张\n2. 需求变化频繁\n因为我比较在意代码可读性，会考虑到可维护性，所以很多时候都很难下手，但是因为第一点原因，又必须赶紧行动起来。\n然后，现在觉得先 getting things done 然后 do better，当然必须得有这个“然后“。\n这样写代码的时候就照着自己思路来，功能完成之后再“回检“。\n如果有代码片段出现三次或三次以上就考虑抽取公共函数/方法。\n兼顾考虑到第二点需求可能发生的变化，有选择性的进行重构，不是所有重复代码的情况都适合一开始就抽出来，我觉得可以“等等”，等需求沉淀一段时间，再在合适的时候消灭重复。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1647562417,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1479120,"avatar":"https://static001.geekbang.org/account/avatar/00/16/91/d0/35bc62b1.jpg","nickname":"无咎","note":"","ucode":"B9759B5646F3AB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580475,"discussion_content":"还是以二为准，完成功能之后，检查一下是否有重复，如果有则重构。留到下一次，常常会因为时间紧，遗忘等原因就缺失了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658199389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}