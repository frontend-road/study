{"id":572534,"title":"加餐01｜留言区心愿单：真·子组件以及jsx-runtime","content":"<p>你好，我是宋一玮，欢迎回到React应用开发的学习。</p><p>这是专栏的第一次加餐。我和专栏编辑从已上线课程的留言区中，选择了一些具有代表性的问题。这次加餐我们先来讲讲“真·子组件”，以及JSX这一语法糖在React 17版本以后发生的变化。在心愿单里呼声同样比较高的，还有Fiber协调引擎，会放到下节加餐中。</p><p>好的，接下来开始我们的加餐内容。</p><h2>真·子组件</h2><p>在第5节课中，我曾提到过：</p><blockquote>\n<p>React还流行过一波真·子组件（Sub-components）的设计模式，代表性的组件库有<a href=\"https://react.semantic-ui.com/#sub-components\">Semantic UI React</a>、<a href=\"https://recharts.org/zh-CN/guide/getting-started\">Recharts</a>……如果你感兴趣的话，在靠后面的课程中我会讲解一下这种模式的具体实现。</p>\n</blockquote><p>在React领域，一般提到中文“子组件”，指的是Child Component，用于描述在React运行时（Runtime）构建的组件树（元素树）中，组件与组件之间的父子关系。</p><p>而这里提到的Sub-components，主要还是在<strong>描述设计时</strong>（Design-time）<strong>组件与组件间的强包含关系</strong>（Containment），而在运行时这些组件之间却不一定是父子关系。所以，把Sub-components直译成“子组件”就不太合适，我就改用了“真·子组件”这种中二的翻译，意在与Child Component区别开。事实上，“附属组件”、“次级组件”、“副组件”也都是可行的名字。</p><!-- [[[read_end]]] --><p>如果用真·子组件模式设计 <code>KanbanColumn</code> 组件，那么它的 <code>title</code> 属性可能是这样的：</p><pre><code class=\"language-javascript\">&lt;KanbanColumn className=\"column-todo\"&gt;\n  &lt;KanbanColumn.Title&gt;\n    待处理&lt;button onClick={handleAdd}\n      disabled={showAdd}&gt;&amp;#8853; 添加新卡片&lt;/button&gt;\n  &lt;/KanbanColumn.Title&gt;\n  {/* ...省略 */}\n&lt;/KanbanColumn&gt;\n</code></pre><p>你也许会吐槽，这跟在 <code>title={}</code> 里直接写JSX区别不大啊。那我们再来看一个props比较复杂的组件：</p><pre><code class=\"language-javascript\">&lt;Dialog\n  modal\n  onClose={() =&gt; {}}\n&nbsp; title=\"这是标题\"\n&nbsp; titleClass=\"dialog-title\"\n&nbsp; titleStyle={{ color: 'blue' }}\n  content=\"这是正文。\"\n  contentClass=\"dialog-content\"\n  contentStyle={{ color: 'red' }}\n&nbsp; showConfirmButton={true}\n  confirmButtonText=\"确认\"\n  onConfirmButtonClick={() =&gt; {}}\n  showCancelButton={false}\n  cancelButtonText=\"\"\n  onCancelButtonClick={() =&gt; {}}\n  {/* ...还有很多props */}\n/&gt;\n</code></pre><p>也许这个组件的设计者对加入这么多props不以为然，但这个组件的使用者们，看着茫茫props会觉得无从下手。这种情况下，双方就组件接口设计会提出如下需求：</p><ol>\n<li>组件的props需要更加结构化、语义化；</li>\n<li>降低组件props结构与组件内部实现的耦合。</li>\n</ol><p>这就轮到真·子组件上场了，通过简单的梳理，我们为 <code>Dialog</code> 设计了如下几个真·子组件：</p><pre><code class=\"language-javascript\">const Dialog = (props) =&gt; {/* 待实现 */};\nDialog.Title = () =&gt; null;\nDialog.Content = () =&gt; null;\nDialog.Action = () =&gt; null;\n</code></pre><p>期待的使用方式如下：</p><pre><code class=\"language-javascript\">&lt;Dialog modal onClose={() =&gt; {}}&gt;\n  &lt;Dialog.Title className=\"dialog-title\" style={{ color: 'blue' }}&gt;\n    这是标题\n  &lt;/Dialog.Title&gt;\n  &lt;Dialog.Content&gt;\n    &lt;p&gt;这是正文。&lt;/p&gt;\n    &lt;p&gt;这是正文第二段。&lt;/p&gt;\n  &lt;/Dialog.Content&gt;\n  &lt;Dialog.Action type=\"confirm\" onClick={() =&gt; {}}&gt;确认&lt;/Dialog.Action&gt;\n  &lt;Dialog.Action type=\"cancel\" onClick={() =&gt; {}}&gt;取消&lt;/Dialog.Action&gt;\n&lt;/Dialog&gt;\n</code></pre><p>这样设计对于 <code>Dialog</code> 组件的使用者来说，还是很好用的，但对于 <code>Dialog</code> 组件的开发者就有一定挑战了。</p><p>具体来说，在渲染时，这些真·子组件与其他自定义组件一样，会创建对应的React元素出来，但它们会导致元素树变得冗长。我们并不希望这样，而只想把它们当作是 <code>Dialog</code> 组件的一种扩展属性。这就需要在 <code>Dialog</code> 的 <code>children</code> 属性上做文章。</p><p>首先基于 <code>React.Children</code>  API，定义两个工具函数 <code>findByType</code> 和 <code>findAllByType</code>，用于选取 <code>children</code> 中特定类型的React元素：</p><pre><code class=\"language-javascript\">function findByType(children, type) {\n&nbsp; return React.Children.toArray(children).find(c =&gt; c.type === type);\n}\n\nfunction findAllByType(children, type) {\n&nbsp; return React.Children.toArray(children).filter(c =&gt; c.type === type);\n}\n</code></pre><p>然后在 <code>Dialog</code> 组件函数体中，定义渲染标题、正文和动作按钮的函数，并在返回的JSX中调用它们：</p><pre><code class=\"language-javascript\">const Dialog = ({ modal, onClose, children }) =&gt; {\n&nbsp; const renderTitle = () =&gt; {\n&nbsp; &nbsp; const subElement = findByType(children, Dialog.Title);\n&nbsp; &nbsp; if (subElement) {\n&nbsp; &nbsp; &nbsp; const { className, style, children } = subElement.props;\n&nbsp; &nbsp; &nbsp; return (&lt;h1 {...{ className, style }}&gt;{children}&lt;/h1&gt;);\n&nbsp; &nbsp; }\n&nbsp; &nbsp; return null;\n&nbsp; };\n&nbsp; const renderContent = () =&gt; {\n&nbsp; &nbsp; const subElement = findByType(children, Dialog.Content);\n&nbsp; &nbsp; return subElement?.props?.children;\n&nbsp; };\n&nbsp; const renderButtons = () =&gt; {\n&nbsp; &nbsp; const subElements = findAllByType(children, Dialog.Action);\n&nbsp; &nbsp; return subElements.map(({ props: { onClick, children } }) =&gt; (\n&nbsp; &nbsp; &nbsp; &lt;button onClick={onClick} key={children}&gt;{children}&lt;/button&gt;\n&nbsp; &nbsp; ));\n&nbsp; };\n&nbsp; return (\n&nbsp; &nbsp; &lt;dialog open&gt;\n&nbsp; &nbsp; &nbsp; &lt;header&gt;{renderTitle()}&lt;/header&gt;\n&nbsp; &nbsp; &nbsp; &lt;main&gt;{renderContent()}&lt;/main&gt;\n&nbsp; &nbsp; &nbsp; &lt;footer&gt;{renderButtons()}&lt;/footer&gt;\n&nbsp; &nbsp; &lt;/dialog&gt;\n&nbsp; );\n};\nDialog.Title = () =&gt; null;\nDialog.Content = () =&gt; null;\nDialog.Action = () =&gt; null;\n</code></pre><p>可以看到，三个渲染函数行为都稍有不同， <code>renderTitle</code> 是从 <code>&lt;Dialog.Title&gt;</code> 中获取 <code>className</code> 、 <code>children</code> 等props，然后用在 <code>&lt;h1&gt;</code> 上； <code>renderContent</code> 是直接返回 <code>&lt;Dialog.Content&gt;</code> 的 <code>children</code> 子元素；而 <code>renderButtons</code> 则是从多个 <code>&lt;Dialog.Action&gt;</code> 中获取多组 <code>onClick</code> 、 <code>children</code> 属性，然后分别渲染成 <code>&lt;button&gt;</code>。</p><p>在浏览器中可以观察到渲染结果：</p><p><img src=\"https://static001.geekbang.org/resource/image/b7/9c/b7607fef52dd3357eccb67ed61b92a9c.png?wh=774x643\" alt=\"图片\"></p><p>还有一种情况，如果是用真·子组件定义类似模版的元素，在组件中有可能需要调用 <code>React.cloneElement</code>  API来克隆这个模版元素。</p><p>更详细的例子请参考 <a href=\"https://github.com/Semantic-Org/Semantic-UI-React/tree/next-v3\">Github上Semantic-UI-React的v3版本</a>。之所以推荐v3版本，是因为这个版本大量使用了组件函数+Hooks，而目前主干版本的v2.x，主要还是基于类组件实现的。</p><p>除了真·子组件，你仍然有其他选择可以实现上述目标：</p><ul>\n<li>使用类似JSON这样的DSL（Domain Specific Language）作为props，让组件内部逻辑解析DSL来决定如何渲染；</li>\n<li>组件的组合（Composition），这方面的知识和最佳实践，我们在后面第18节课代码复用会讲到。</li>\n</ul><h2>React 17/18中的react/jsx-runtime</h2><p>在第4节课我们提到过JSX是 <code>React.createElement</code> 的语法糖。如果你对React底层实现感兴趣，那你也需要了解这个语法糖在React新版中的变化：React从17版本开始已经启用全新的JSX运行时来替代 <code>React.createElement</code> 。这要感谢留言区“<em>Geek_fcdf7b</em> ”同学的提醒。</p><p>在启用新JSX运行时的状态下，用代码编译器编译JSX：</p><ul>\n<li>在生产模式下被编译成了 <code>react/jsx-runtime</code> 下的 <code>jsx</code> 或 <code>jsxs</code> （目前同 <code>jsx</code> ）；</li>\n<li>在开发模式下JSX被编译成了 <code>react/jsx-dev-runtime</code> 下的 <code>jsxDEV</code> 。</li>\n</ul><p>作为编译输入，JSX的语法没有改变，编译输出无论是 <code>jsx-runtime</code> 还是 <code>React.createElement</code> 函数，它们的返回值也同样都是React元素。可见，代码编译器为开发者隐藏了新旧API的差异。这个变化并不影响已有的对JSX的理解。</p><p>另外，如果是开发者手工创建React元素，依旧应该调用 <code>React.createElement</code> 。这个API并不会被移除。而 <code>jsx-runtime</code> 代码只应由编译器生成，开发者不应直接调用这个函数。</p><p>在React 17版本，新JSX运行时的具体更新日志可参考：&nbsp; <a href=\"https://zh-hans.reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html\">https://zh-hans.reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html</a> ；</p><p>引入新JSX运行时的动机主要是因为原有的 <code>React.createElement</code> 是为了类组件设计的，而目前函数组件已然成为主流，老接口限制了进一步的优化，具体可以参考官方的征求意见贴： <a href=\"https://github.com/reactjs/rfcs/pull/107\">https://github.com/reactjs/rfcs/pull/107</a> 。里面提及React v0.12版本以来JSX的实现，在性能优化方面存在一些痛点，包括：</p><ul>\n<li>每次创建元素时都需要动态检查组件是否用 <code>.defaultProps</code> 定义了props默认值；</li>\n<li>在 <code>React.lazy</code> 懒加载中，更是需要在渲染阶段解析props默认值；</li>\n<li>子元素 <code>children</code> 需要被动态合并到props中，导致调用方无法更早获知元素props的完整结构；</li>\n<li>从JSX编译出来的 <code>React.createElement</code> 是React对象的属性，而不是更容易优化的模块范围常量；</li>\n<li>无法确定传入的props是否是一个用户创建的可变对象，所以每次都必须克隆对象；</li>\n<li>必须从props中取出 <code>key</code> 和 <code>ref</code> ；</li>\n<li>同样是 <code>key</code> 和 <code>ref</code> ，也有可能以属性展开的方式传进来，如 <code>&lt;div {...props} /&gt;</code> ，我们需要动态检查其中是否有这两个属性；</li>\n<li>要想让JSX编译出来的 <code>React.createElement</code> 生效，需要模块显式导入<code>React</code>。</li>\n</ul><p>为了解决上面这些痛点，以及在远期能对React框架的部分概念做简化，React官方将陆续引入三个步骤：</p><ol>\n<li>新的JSX编译目标；</li>\n<li>对部分功能标注即将弃用；</li>\n<li>语义层面的破坏性更新。</li>\n</ol><p>React 17版本加入的新JSX运行时就是这第一步。与<code>React.createElement</code> 相比的变化包括：</p><ul>\n<li>自动导入；</li>\n<li>在props之外传递 <code>key</code> 属性；</li>\n<li>将 <code>children</code> 直接作为props的一部分；</li>\n<li>分离生产模式和开发模式的JSX运行时。</li>\n</ul><p>我在 <code>oh-my-kanban</code> 项目里验证了一下，确实。</p><pre><code class=\"language-javascript\">var KanbanCard = function KanbanCard(_ref) {\n&nbsp; var title = _ref.title,\n&nbsp; &nbsp; status = _ref.status;\n&nbsp; return /*#__PURE__*/ (0, jsx_runtime.jsxs)(\"li\", {\n&nbsp; &nbsp; className: \"kanban-card\",\n&nbsp; &nbsp; children: [\n&nbsp; &nbsp; &nbsp; /*#__PURE__*/ (0, jsx_runtime.jsx)(\"div\", {\n&nbsp; &nbsp; &nbsp; &nbsp; className: \"card-title\",\n&nbsp; &nbsp; &nbsp; &nbsp; children: title,\n&nbsp; &nbsp; &nbsp; }),\n&nbsp; &nbsp; &nbsp; /*#__PURE__*/ (0, jsx_runtime.jsx)(\"div\", {\n&nbsp; &nbsp; &nbsp; &nbsp; className: \"card-status\",\n&nbsp; &nbsp; &nbsp; &nbsp; children: status,\n&nbsp; &nbsp; &nbsp; }),\n&nbsp; &nbsp; ],\n&nbsp; });\n};\n</code></pre><p>从编译结果看，与 <code>React.createElement</code> 在 <code>children</code> 的处理上是不同， <code>jsx_runtime.jsx</code> 的 <code>children</code> 直接就是props的一部分。</p><p>在本专栏选用的React 18.2.0版本和与它配套的CRA中，新JSX运行时也是被默认启用的。</p><p>好了，这节加餐就到这里。如果你还有其他想听的话题，或者在课程学习中有什么疑问，欢迎在留言区告诉我。下节课再见！</p>","comments":[{"had_liked":false,"id":358342,"user_name":"杨永安","can_delete":false,"product_type":"c1","uid":1218183,"ip_address":"北京","ucode":"D23013C30D435B","user_header":"https://static001.geekbang.org/account/avatar/00/12/96/87/bbdeb4ee.jpg","comment_is_top":false,"comment_ctime":1664214839,"is_pvip":false,"replies":[{"id":130439,"content":"你好，杨永安，谢谢支持！我也喜欢在半夜2点吃夜宵（虽然不太健康啦）。","user_name":"作者回复","user_name_real":"编辑","uid":1033973,"ctime":1664364992,"ip_address":"北京","comment_id":358342,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100119601,"comment_content":"夜宵支持","like_count":1,"discussions":[{"author":{"id":1033973,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c6/f5/dae613e0.jpg","nickname":"宋一玮","note":"","ucode":"55E5B710556C1E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589049,"discussion_content":"你好，杨永安，谢谢支持！我也喜欢在半夜2点吃夜宵（虽然不太健康啦）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664364992,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358082,"user_name":"joel","can_delete":false,"product_type":"c1","uid":1550366,"ip_address":"北京","ucode":"46E91C3F3F1414","user_header":"https://static001.geekbang.org/account/avatar/00/17/a8/1e/4ec85e24.jpg","comment_is_top":false,"comment_ctime":1663901775,"is_pvip":false,"replies":[{"id":130403,"content":"你好，joel，感谢你的心愿单。1、React更新机制在加餐02的Fiber协调引擎中有所涉及；2、自定义Hooks会在后面的第18节课代码复用中有介绍；3、这个我也很有兴趣想写一写，不过最近还是先赶稿，等我有喘息机会尽量安排 :)","user_name":"作者回复","user_name_real":"编辑","uid":1033973,"ctime":1664213541,"ip_address":"北京","comment_id":358082,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100119601,"comment_content":"老师你好，我希望以下心愿单：\n1、react 更新机制原理等比较进阶的东西\n2、react 自定义hooks 比较经典的案例场景，以及hooks 实现原理\n3、对比vue 的原理机制，比如 vue 没有fiber, react 的设计的原理貌似跟vue 不一样，虽然都是有xxx等特点","like_count":0,"discussions":[{"author":{"id":1033973,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c6/f5/dae613e0.jpg","nickname":"宋一玮","note":"","ucode":"55E5B710556C1E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588920,"discussion_content":"你好，joel，感谢你的心愿单。1、React更新机制在加餐02的Fiber协调引擎中有所涉及；2、自定义Hooks会在后面的第18节课代码复用中有介绍；3、这个我也很有兴趣想写一写，不过最近还是先赶稿，等我有喘息机会尽量安排 :)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664213541,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":357843,"user_name":"风太大太大","can_delete":false,"product_type":"c1","uid":1368376,"ip_address":"北京","ucode":"E0221487898D62","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/dCfVz7wIUT4fM7zQO3gIwXo3BGodP5FJuCdMxobZ5dXpzBeTXiaB3icoFqj22EbIGCu1xxd1FLo9xic0a2pGnunibg/132","comment_is_top":false,"comment_ctime":1663675771,"is_pvip":false,"replies":[{"id":130406,"content":"你好，风太大太大，在后面的第18节课代码复用，会跟大家探讨自定义Hooks和高阶组件，敬请期待。","user_name":"作者回复","user_name_real":"编辑","uid":1033973,"ctime":1664214098,"ip_address":"北京","comment_id":357843,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100119601,"comment_content":"想听听react的高阶级用法，例如使用高阶组件。\n怎么利用react-hooks 进行项目工程化改造，\n怎么自己封装合理且好用的自定义hooks","like_count":0,"discussions":[{"author":{"id":1033973,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c6/f5/dae613e0.jpg","nickname":"宋一玮","note":"","ucode":"55E5B710556C1E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588923,"discussion_content":"你好，风太大太大，在后面的第18节课代码复用，会跟大家探讨自定义Hooks和高阶组件，敬请期待。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664214098,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}