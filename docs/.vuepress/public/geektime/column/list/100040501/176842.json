{"id":176842,"title":"07 | 迭代器和好用的新for循环","content":"<p>你好，我是吴咏炜。</p><p>我们已经讲过了容器。在使用容器的过程中，你也应该对迭代器（iterator）或多或少有了些了解。今天，我们就来系统地讲一下迭代器。</p><h2>什么是迭代器？</h2><p>迭代器是一个很通用的概念，并不是一个特定的类型。它实际上是一组对类型的要求（<span class=\"orange\">[1]</span>）。它的最基本要求就是从一个端点出发，下一步、下一步地到达另一个端点。按照一般的中文习惯，也许“遍历”是比“迭代”更好的用词。我们可以遍历一个字符串的字符，遍历一个文件的内容，遍历目录里的所有文件，等等。这些都可以用迭代器来表达。</p><p>我在用 output_container.h 输出容器内容的时候，实际上就对容器的 <code>begin</code> 和 <code>end</code> 成员函数返回的对象类型提出了要求。假设前者返回的类型是 I，后者返回的类型是 S，这些要求是：</p><ul>\n<li>I 对象支持 <code>*</code> 操作，解引用取得容器内的某个对象。</li>\n<li>I 对象支持 <code>++</code>，指向下一个对象。</li>\n<li>I 对象可以和 I 或 S 对象进行相等比较，判断是否遍历到了特定位置（在 S 的情况下是是否结束了遍历）。</li>\n</ul><p>注意在 C++17 之前，<code>begin</code> 和 <code>end</code> 返回的类型 I 和 S 必须是相同的。从 C++17 开始，I 和 S 可以是不同的类型。这带来了更大的灵活性和更多的优化可能性。</p><p>上面的类型 I，多多少少就是一个满足输入迭代器（input iterator）的类型了。不过，output_container.h 只使用了前置 <code>++</code>，但输入迭代器要求前置和后置 <code>++</code> 都得到支持。</p><!-- [[[read_end]]] --><p>输入迭代器不要求对同一迭代器可以多次使用 <code>*</code> 运算符，也不要求可以保存迭代器来重新遍历对象，换句话说，只要求可以单次访问。如果取消这些限制、允许多次访问的话，那迭代器同时满足了前向迭代器（forward iterator）。</p><p>一个前向迭代器的类型，如果同时支持 <code>--</code>（前置及后置），回到前一个对象，那它就是个双向迭代器（bidirectional iterator）。也就是说，可以正向遍历，也可以反向遍历。</p><p>一个双向迭代器，如果额外支持在整数类型上的 <code>+</code>、<code>-</code>、<code>+=</code>、<code>-=</code>，跳跃式地移动迭代器；支持 <code>[]</code>，数组式的下标访问；支持迭代器的大小比较（之前只要求相等比较）；那它就是个随机访问迭代器（random-access iterator）。</p><p>一个随机访问迭代器 <code>i</code> 和一个整数 <code>n</code>，在 <code>*i</code> 可解引用且 <code>i + n</code> 是合法迭代器的前提下，如果额外还满足 <code>*(addressdof(*i) + n)</code> 等价于 <code>*(i + n)</code>，即保证迭代器指向的对象在内存里是连续存放的，那它（在 C++20 里）就是个连续迭代器（contiguous iterator）。</p><p>以上这些迭代器只考虑了读取。如果一个类型像输入迭代器，但 <code>*i</code> 只能作为左值来写而不能读，那它就是个输出迭代器（output iterator）。</p><p>而比输入迭代器和输出迭代器更底层的概念，就是迭代器了。基本要求是：</p><ul>\n<li>对象可以被拷贝构造、拷贝赋值和析构。</li>\n<li>对象支持 <code>*</code> 运算符。</li>\n<li>对象支持前置 <code>++</code> 运算符。</li>\n</ul><p>迭代器类型的关系可从下图中全部看到：</p><p><img src=\"https://static001.geekbang.org/resource/image/dd/5a/dd25c3f074fe0b792dddecfd15f74e5a.png?wh=1218*892\" alt=\"\"></p><p>迭代器通常是对象。但需要注意的是，指针可以满足上面所有的迭代器要求，因而也是迭代器。这应该并不让人惊讶，因为本来迭代器就是根据指针的特性，对其进行抽象的结果。事实上，<code>vector</code> 的迭代器，在很多实现里就直接是使用指针的。</p><h2>常用迭代器</h2><p>最常用的迭代器就是容器的 <code>iterator</code> 类型了。以我们学过的顺序容器为例，它们都定义了嵌套的 <code>iterator</code> 类型和 <code>const_iterator</code> 类型。一般而言，<code>iterator</code> 可写入，<code>const_iterator</code> 类型不可写入，但这些迭代器都被定义为输入迭代器或其派生类型：</p><ul>\n<li><code>vector::iterator</code> 和 <code>array::iterator</code> 可以满足到连续迭代器。</li>\n<li><code>deque::iterator</code> 可以满足到随机访问迭代器（记得它的内存只有部分连续）。</li>\n<li><code>list::iterator</code> 可以满足到双向迭代器（链表不能快速跳转）。</li>\n<li><code>forward_list::iterator</code> 可以满足到前向迭代器（单向链表不能反向遍历）。</li>\n</ul><p>很常见的一个输出迭代器是 <code>back_inserter</code> 返回的类型 <code>back_inserter_iterator</code> 了；用它我们可以很方便地在容器的尾部进行插入操作。另外一个常见的输出迭代器是 <code>ostream_iterator</code>，方便我们把容器内容“拷贝”到一个输出流。示例如下：</p><pre><code class=\"language-c++\">#include &lt;algorithm&gt;  // std::copy\n#include &lt;iterator&gt;   // std::back_inserter\n#include &lt;vector&gt;     // std::vector\nusing namespace std;\n</code></pre><pre><code class=\"language-c++\">vector&lt;int&gt; v1{1, 2, 3, 4, 5};\nvector&lt;int&gt; v2;\ncopy(v1.begin(), v1.end(),\n     back_inserter(v2));\n</code></pre><pre><code class=\"language-c++\">v2\n</code></pre><blockquote>\n<p><code>{ 1, 2, 3, 4, 5 }</code></p>\n</blockquote><pre><code class=\"language-c++\">#include &lt;iostream&gt;  // std::cout\ncopy(v2.begin(), v2.end(),\n     ostream_iterator&lt;int&gt;(cout, \" \"));\n</code></pre><blockquote>\n<p><code>1 2 3 4 5</code></p>\n</blockquote><h2>使用输入行迭代器</h2><p>下面我们来看一下一个我写的输入迭代器。它的功能本身很简单，就是把一个输入流（<code>istream</code>）的内容一行行读进来。配上 C++11 引入的基于范围的 for 循环的语法，我们可以把遍历输入流的代码以一种自然、非过程式的方式写出来，如下所示：</p><pre><code class=\"language-c++\">for (const string&amp; line :\n     istream_line_reader(is)) {\n  // 示例循环体中仅进行简单输出\n  cout &lt;&lt; line &lt;&lt; endl;\n}\n</code></pre><p>我们可以对比一下以传统的方式写的 C++ 代码，其中需要照顾不少细节：</p><pre><code class=\"language-c++\">string line;\nfor (;;) {\n  getline(is, line);\n  if (!is) {\n    break;\n  }\n  cout &lt;&lt; line &lt;&lt; endl;\n}\n</code></pre><p>从 <code>is</code> 读入输入行的逻辑，在前面的代码里一个语句就全部搞定了，在这儿用了 5 个语句……</p><p>我们后面会分析一下这个输入迭代器。在此之前，我先解说一下基于范围的 for 循环这个语法。虽然这可以说是个语法糖，但它对提高代码的可读性真的非常重要。如果不用这个语法糖的话，简洁性上的优势就小多了。我们直接把这个循环改写成等价的普通 for 循环的样子。</p><pre><code class=\"language-c++\">{\n  auto&amp;&amp; r = istream_line_reader(is);\n  auto it = r.begin();\n  auto end = r.end();\n  for (; it != end; ++it) {\n    const string&amp; line = *it;\n    cout &lt;&lt; line &lt;&lt; endl;\n  }\n}\n</code></pre><p>可以看到，它做的事情也不复杂，就是：</p><ul>\n<li>获取冒号后边的范围表达式的结果，并隐式产生一个引用，在整个循环期间都有效。注意根据生命期延长规则，表达式结果如果是临时对象的话，这个对象要在循环结束后才被销毁。</li>\n<li>自动生成遍历这个范围的迭代器。</li>\n<li>循环内自动生成根据冒号左边的声明和 <code>*it</code> 来进行初始化的语句。</li>\n<li>下面就是完全正常的循环体。</li>\n</ul><p>生成迭代器这一步有可能是——但不一定是——调用 <code>r</code> 的 <code>begin</code> 和 <code>end</code> 成员函数。具体规则是：</p><ul>\n<li>对于 C 数组（必须是没有退化为指针的情况），编译器会自动生成指向数组头尾的指针（相当于自动应用可用于数组的 <code>std::begin</code> 和 <code>std::end</code> 函数）。</li>\n<li>对于有 <code>begin</code> 和 <code>end</code> 成员的对象，编译器会调用其 <code>begin</code> 和 <code>end</code> 成员函数（我们目前的情况）。</li>\n<li>否则，编译器会尝试在 <code>r</code> 对象所在的名空间寻找可以用于 <code>r</code> 的 <code>begin</code> 和 <code>end</code> 函数，并调用 <code>begin(r)</code> 和 <code>end(r)</code>；找不到的话则失败报错。</li>\n</ul><h2>定义输入行迭代器</h2><p>下面我们看一下，要实现这个输入行迭代器，需要做些什么工作。</p><p>C++ 里有些固定的类型要求规范。对于一个迭代器，我们需要定义下面的类型：</p><pre><code class=\"language-c++\">class istream_line_reader {\npublic:\n  class iterator {  // 实现 InputIterator\n  public:\n    typedef ptrdiff_t difference_type;\n    typedef string value_type;\n    typedef const value_type* pointer;\n    typedef const value_type&amp; reference;\n    typedef input_iterator_tag\n      iterator_category;\n    …\n  };\n  …\n};\n</code></pre><p>仿照一般的容器，我们把迭代器定义为 <code>istream_line_reader</code> 的嵌套类。它里面的这五个类型是必须定义的（其他泛型 C++ 代码可能会用到这五个类型；之前标准库定义了一个可以继承的类模板 <code>std::iterator</code> 来产生这些类型定义，但这个类目前已经被废弃 <span class=\"orange\">[2]</span>）。其中：</p><ul>\n<li><code>difference_type</code> 是代表迭代器之间距离的类型，定义为 <code>ptrdiff_t</code> 只是种标准做法（指针间差值的类型），对这个类型没什么特别作用。</li>\n<li><code>value_type</code> 是迭代器指向的对象的值类型，我们使用 <code>string</code>，表示迭代器指向的是字符串。</li>\n<li><code>pointer</code> 是迭代器指向的对象的指针类型，这儿就平淡无奇地定义为 <code>value_type</code> 的常指针了（我们可不希望别人来更改指针指向的内容）。</li>\n<li>类似的，<code>reference</code> 是 <code>value_type</code> 的常引用。</li>\n<li><code>iterator_category</code> 被定义为 <code>input_iterator_tag</code>，标识这个迭代器的类型是 input iterator（输入迭代器）。</li>\n</ul><p>作为一个真的只能读一次的输入迭代器，有个特殊的麻烦（前向迭代器或其衍生类型没有）：到底应该让 <code>*</code> 负责读取还是 <code>++</code> 负责读取。我们这儿采用常见、也较为简单的做法，让 <code>++</code> 负责读取，<code>*</code> 负责返回读取的内容（这个做法会有些副作用，但按我们目前的用法则没有问题）。这样的话，这个 <code>iterator</code> 类需要有一个数据成员指向输入流，一个数据成员来存放读取的结果。根据这个思路，我们定义这个类的基本成员函数和数据成员：</p><pre><code class=\"language-c++\">class istream_line_reader {\npublic:\n  class iterator {\n    …\n    iterator() noexcept\n      : stream_(nullptr) {}\n    explicit iterator(istream&amp; is)\n      : stream_(&amp;is)\n    {\n      ++*this;\n    }\n\n    reference operator*() const noexcept\n    {\n      return line_;\n    }\n    pointer operator-&gt;() const noexcept\n    {\n      return &amp;line_;\n    }\n    iterator&amp; operator++()\n    {\n      getline(*stream_, line_);\n      if (!*stream_) {\n        stream_ = nullptr;\n      }\n      return *this;\n    }\n    iterator operator++(int)\n    {\n      iterator temp(*this);\n      ++*this;\n      return temp;\n    }\n\n  private:\n    istream* stream_;\n    string line_;\n  };\n  …\n};\n</code></pre><p>我们定义了默认构造函数，将 <code>stream_</code> 清空；相应的，在带参数的构造函数里，我们根据传入的输入流来设置 <code>stream_</code>。我们也定义了 <code>*</code> 和 <code>-&gt;</code> 运算符来取得迭代器指向的文本行的引用和指针，并用 <code>++</code> 来读取输入流的内容（后置 <code>++</code> 则以惯常方式使用前置 <code>++</code> 和拷贝构造来实现）。唯一“特别”点的地方，是我们在构造函数里调用了 <code>++</code>，确保在构造后调用 <code>*</code> 运算符时可以读取内容，符合日常先使用 <code>*</code>、再使用 <code>++</code> 的习惯。一旦文件读取到尾部（或出错），则 <code>stream_</code> 被清空，回到默认构造的情况。</p><p>对于迭代器之间的比较，我们则主要考虑文件有没有读到尾部的情况，简单定义为：</p><pre><code class=\"language-c++\">    bool operator==(const iterator&amp; rhs)\n      const noexcept\n    {\n      return stream_ == rhs.stream_;\n    }\n    bool operator!=(const iterator&amp; rhs)\n      const noexcept\n    {\n      return !operator==(rhs);\n    }\n</code></pre><p>有了这个 <code>iterator</code> 的定义后，<code>istream_line_reader</code> 的定义就简单得很了：</p><pre><code class=\"language-c++\">class istream_line_reader {\npublic:\n  class iterator {…};\n  istream_line_reader() noexcept\n    : stream_(nullptr) {}\n  explicit istream_line_reader(\n    istream&amp; is) noexcept\n    : stream_(&amp;is) {}\n  iterator begin()\n  {\n    return iterator(*stream_);\n  }\n  iterator end() const noexcept\n  {\n    return iterator();\n  }\n\nprivate:\n  istream* stream_;\n};\n</code></pre><p>也就是说，构造函数只是简单地把输入流的指针赋给 <code>stream_</code> 成员变量。<code>begin</code> 成员函数则负责构造一个真正有意义的迭代器；<code>end</code> 成员函数则只是返回一个默认构造的迭代器而已。</p><p>以上就是一个完整的基于输入流的行迭代器了。这个行输入模板的设计动机和性能测试结果可参见参考资料 <span class=\"orange\">[3]</span> 和 <span class=\"orange\">[4]</span>；完整的工程可用代码，请参见参考资料 <span class=\"orange\">[5]</span>。该项目中还提供了利用 C 文件接口的 file_line_reader 和基于内存映射文件的 mmap_line_reader。</p><h2>内容小结</h2><p>今天我们介绍了所有的迭代器类型，并介绍了基于范围的 for 循环。随后，我们介绍了一个实际的输入迭代器工具，并用它来简化从输入流中读入文本行这一常见操作。最后，我们展示了这个输入迭代器的定义。</p><h2>课后思考</h2><p>请思考一下：</p><ol>\n<li>目前这个输入行迭代器的行为，在什么情况下可能导致意料之外的后果？</li>\n<li>请尝试一下改进这个输入行迭代器，看看能不能消除这种意外。如果可以，该怎么做？如果不可以，为什么？</li>\n</ol><p>欢迎留言和我交流你的看法。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] cppreference.com, “Iterator library”. <a href=\"https://en.cppreference.com/w/cpp/iterator\">https://en.cppreference.com/w/cpp/iterator</a> </span></p><p><span class=\"reference\">[1a] cppreference.com, “迭代器库”. <a href=\"https://zh.cppreference.com/w/cpp/iterator\">https://zh.cppreference.com/w/cpp/iterator</a> </span></p><p><span class=\"reference\">[2] Jonathan Boccara, “std::iterator is deprecated: why, what it was, and what to use instead”. <a href=\"https://www.fluentcpp.com/2018/05/08/std-iterator-deprecated/\">https://www.fluentcpp.com/2018/05/08/std-iterator-deprecated/</a> </span></p><p><span class=\"reference\">[3] 吴咏炜, “Python <code>yield</code> and C++ coroutines”. <a href=\"https://yongweiwu.wordpress.com/2016/08/16/python-yield-and-cplusplus-coroutines/\">https://yongweiwu.wordpress.com/2016/08/16/python-yield-and-cplusplus-coroutines/</a> </span></p><p><span class=\"reference\">[4] 吴咏炜, “Performance of my line readers”. <a href=\"https://yongweiwu.wordpress.com/2016/11/12/performance-of-my-line-readers/\">https://yongweiwu.wordpress.com/2016/11/12/performance-of-my-line-readers/</a> </span></p><p><span class=\"reference\">[5] 吴咏炜, nvwa. <a href=\"https://github.com/adah1972/nvwa/\">https://github.com/adah1972/nvwa/</a> </span></p>","neighbors":{"left":{"article_title":"06 | 异常：用还是不用，这是个问题","id":175579},"right":{"article_title":"08 | 易用性改进 I：自动类型推断和初始化","id":176850}},"comments":[{"had_liked":false,"id":160817,"user_name":"小一日一","can_delete":false,"product_type":"c1","uid":1301097,"ip_address":"","ucode":"0A506C2B918C14","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtVXiaJbfkpeXH4udkPUIlFte7z3HWMebdogk8jFpgFEkJ0ruGiawUMUcZj9RLpLkIWxV7QOzbHoSg/132","comment_is_top":false,"comment_ctime":1576037730,"is_pvip":false,"replies":[{"id":61356,"content":"肯定还有更好的 C++ 代码的。学习无止境！\n\n认真学习，应该不用那么久（我还没有极客时间专栏来帮助我学习呢😌）。\n\n反过来，说明老程序员还有点价值么。🤗","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576060691,"ip_address":"","comment_id":160817,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"看了老师的代码再看自己学的代码，感觉我的C++是小学生水平。\n\n以为自己看过几遍C++ PRIMER 5th, 看过并理解effective++, more effective c++, inside the c++ object model, 能应付平时的开发需要，也能看懂公司别人的代码，就觉得自己的C++不错了，看了老师github的代码后我是彻底服了，感叹C++太博大精深，永远不敢说自己精通C++。\n\n我什么时候才能达到老师对C++理解并使用的高度呢，难道也需要20年么？","like_count":31},{"had_liked":false,"id":172645,"user_name":"Geek_b68b74","can_delete":false,"product_type":"c1","uid":1780585,"ip_address":"","ucode":"7CB026A020D513","user_header":"","comment_is_top":false,"comment_ctime":1579242815,"is_pvip":false,"replies":[{"id":67016,"content":"你的两个疑问实际是针对同一个地方。\n\nauto&amp;&amp; 那句是用一个“万能”引用捕获一个对象，左值和右值都可以。C++ 的生命期延长规则，保证了引用有效期间，istream_line_reader 这个“临时”对象一直存在。没有生命期延长的话，临时对象在当前语句执行结束后即销毁。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1579268673,"ip_address":"","comment_id":172645,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"1、使用输入行迭代器  这一部分里，“ auto&amp;&amp; r = istream_line_reader(is);”  这里为什么要用右值引用呢？\n2、还是使用输入行迭代器这里， \n\nfor (const string&amp; line :\n     istream_line_reader(is)) {\n  &#47;&#47;  示例循环体中仅进行简单输出\n  cout &lt;&lt; line &lt;&lt; endl;\n}\n“获取冒号后边的范围表达式的结果，并隐式产生一个引用，在整个循环期间都有效。注意根据生命期延长规则，表达式结果如果是临时对象的话，这个对象要在循环结束后才被销毁。”  \n 第一句是说line在整个循环期间有效？这是想表达什么呢？还有第二句，指的是哪个临时对象呢？在哪个循环结束后销毁呢？期待您的解答\n","like_count":10,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477488,"discussion_content":"肯定还有更好的 C++ 代码的。学习无止境！\n\n认真学习，应该不用那么久（我还没有极客时间专栏来帮助我学习呢😌）。\n\n反过来，说明老程序员还有点价值么。🤗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576060691,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3542569,"avatar":"https://static001.geekbang.org/account/avatar/00/36/0e/29/fa3601d3.jpg","nickname":"🐶的巴普洛夫","note":"","ucode":"1213DD5A056674","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":607063,"discussion_content":"一年精通，三年熟悉，五年了解，十年用过","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1677586747,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"日本","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1625233,"avatar":"https://static001.geekbang.org/account/avatar/00/18/cc/91/d56a81af.jpg","nickname":"CoderArthur","note":"","ucode":"5B591914F0F67C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360909,"discussion_content":"被你这么一说，感觉自己要找块地钻进去了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616556253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1486168,"avatar":"https://static001.geekbang.org/account/avatar/00/16/ad/58/7d6a0b8e.jpg","nickname":"Deep","note":"","ucode":"EF3281F0A5824A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334882,"discussion_content":"我感觉我是幼儿园水平。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608017924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162978,"user_name":"千鲤湖","can_delete":false,"product_type":"c1","uid":1076506,"ip_address":"","ucode":"C626F15967C219","user_header":"https://static001.geekbang.org/account/avatar/00/10/6d/1a/d1d44258.jpg","comment_is_top":false,"comment_ctime":1576637080,"is_pvip":false,"replies":[{"id":61927,"content":"公布第 1 个问题的答案吧：\n\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &quot;istream_line_reader.h&quot;\n\nusing namespace std;\n\nint main()\n{\n    ifstream ifs{&quot;test.cpp&quot;};\n    istream_line_reader reader{ifs};\n    auto begin = reader.begin();\n    for (auto it = reader.begin();\n         it != reader.end(); ++it) {\n        cout &lt;&lt; *it &lt;&lt; &#39;\\n&#39;;\n    }\n}\n\n以上代码，因为 begin 多调用了一次，输出就少了一行……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576647776,"ip_address":"","comment_id":162978,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"过来看看老师问的那两个问题，好奇中。。。","like_count":10,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481804,"discussion_content":"你的两个疑问实际是针对同一个地方。\n\nauto&amp;amp;&amp;amp; 那句是用一个“万能”引用捕获一个对象，左值和右值都可以。C++ 的生命期延长规则，保证了引用有效期间，istream_line_reader 这个“临时”对象一直存在。没有生命期延长的话，临时对象在当前语句执行结束后即销毁。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1579268673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1276571,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7a/9b/266818bd.jpg","nickname":"秋葛格","note":"","ucode":"2935C020897809","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":185227,"discussion_content":"这里也可以用 const auto &amp; 来捕获临时变量，但是后续对其还有修改，所以用auto &amp;&amp;来捕获。\n我这样理解是不是也可以？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582605272,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1276571,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7a/9b/266818bd.jpg","nickname":"秋葛格","note":"","ucode":"2935C020897809","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":268611,"discussion_content":"我写 auto&amp;&amp; 是表示编译器是如何展开的。如果自己写，又不修改的话，const auto&amp; 确实也可以。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589808055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":185227,"ip_address":"","group_id":0},"score":268611,"extra":""}]}]},{"had_liked":false,"id":160909,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1576059311,"is_pvip":false,"replies":[{"id":61378,"content":"cout &lt;&lt; *it 就是读；\n*it = 42 就是写。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576106257,"ip_address":"","comment_id":160909,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"输入迭代器和输出迭代器，\n这个入和出是相对于什么而言的？\n感觉有点绕。\n\n谢谢！","like_count":6,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478195,"discussion_content":"公布第 1 个问题的答案吧：\n\n#include &amp;lt;fstream&amp;gt;\n#include &amp;lt;iostream&amp;gt;\n#include &amp;quot;istream_line_reader.h&amp;quot;\n\nusing namespace std;\n\nint main()\n{\n    ifstream ifs{&amp;quot;test.cpp&amp;quot;};\n    istream_line_reader reader{ifs};\n    auto begin = reader.begin();\n    for (auto it = reader.begin();\n         it != reader.end(); ++it) {\n        cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39;\\n&amp;#39;;\n    }\n}\n\n以上代码，因为 begin 多调用了一次，输出就少了一行……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576647776,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342897,"user_name":"Slience-0°C","can_delete":false,"product_type":"c1","uid":1151612,"ip_address":"","ucode":"B50665EC6A80F5","user_header":"https://static001.geekbang.org/account/avatar/00/11/92/7c/12c571b6.jpg","comment_is_top":false,"comment_ctime":1650526323,"is_pvip":false,"replies":[{"id":125263,"content":"auto&amp;&amp; 是转发引用（第 8 讲也会简单提到）。转发引用的概念在第 3 讲里提过（我可能会在第 37 讲再展开探讨一下），但在那里的形式是 T&amp;&amp;。\n\nauto&amp;&amp; 能匹配所有的引用（const 左值、非 const 左值、右值等），使用正确的场景下后续应该使用 std::forward。如果你没看到后续用 std::forward，那这个使用很有可能不是最好的写法。根据你是否需要修改 vec 中的内容，auto&amp; 或 const auto&amp; 会更加明确。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1650548391,"ip_address":"","comment_id":342897,"utype":1}],"discussion_count":6,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"有个问题请教老师，工作中看到基于范围的for循环中，使用了auto &amp;&amp;来获取数据，而不是auto&amp;,有啥区别么？难道是为了使用移动构造函数？伪代码如下：std::vectors&lt;std::string&gt; vec;\nfor (auto&amp;&amp; : vec)","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":565837,"discussion_content":"auto&amp;&amp; 是转发引用（第 8 讲也会简单提到）。转发引用的概念在第 3 讲里提过（我可能会在第 37 讲再展开探讨一下），但在那里的形式是 T&amp;&amp;。\n\nauto&amp;&amp; 能匹配所有的引用（const 左值、非 const 左值、右值等），使用正确的场景下后续应该使用 std::forward。如果你没看到后续用 std::forward，那这个使用很有可能不是最好的写法。根据你是否需要修改 vec 中的内容，auto&amp; 或 const auto&amp; 会更加明确。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650548391,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":5,"child_discussions":[{"author":{"id":1151612,"avatar":"https://static001.geekbang.org/account/avatar/00/11/92/7c/12c571b6.jpg","nickname":"Slience-0°C","note":"","ucode":"B50665EC6A80F5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":566049,"discussion_content":"std::vector&lt;std::string&gt; drive_list;\nfor (auto&amp;&amp; dir : drive_list) \n{\n\tboost::system::error_code ec;\n\tif (boost::filesystem::exists(dir, ec)) \n    {\n\t\tif (boost::filesystem::is_directory(dir, ec)) \n        {\n\t\t\tfor (boost::filesystem::recursive_directory_iterator itr(dir, ec); itr != boost::filesystem::recursive_directory_iterator(); itr.increment(ec)) \n            {\n\t\t\t\tif (!boost::filesystem::is_directory(itr-&gt;path(), ec)) \n                {\n\t\t\t\t\t\tauto result = opr.call&lt;std::string&gt;(&#34;AntiVirus::scan_file&#34;, itr-&gt;path().string());\n\t\t\t\t\t\t// TODO something\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse \n        {\n\t\t\tauto result = opr.call&lt;std::string&gt;(&#34;AntiVirus::scan_file&#34;, dir);\n\t\t\t// TODO something\n\t\t}\n\t}\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650592520,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":565837,"ip_address":"","group_id":0},"score":566049,"extra":""},{"author":{"id":1151612,"avatar":"https://static001.geekbang.org/account/avatar/00/11/92/7c/12c571b6.jpg","nickname":"Slience-0°C","note":"","ucode":"B50665EC6A80F5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":566050,"discussion_content":"代码附在留言了，麻烦老师看下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650592564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":565837,"ip_address":"","group_id":0},"score":566050,"extra":""},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1151612,"avatar":"https://static001.geekbang.org/account/avatar/00/11/92/7c/12c571b6.jpg","nickname":"Slience-0°C","note":"","ucode":"B50665EC6A80F5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":566059,"discussion_content":"看起来完全可以用 const auto&amp;，更明确不会修改 drive_list。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650593475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":566050,"ip_address":"","group_id":0},"score":566059,"extra":""}]}]},{"had_liked":false,"id":161028,"user_name":"nelson","can_delete":false,"product_type":"c1","uid":1271183,"ip_address":"","ucode":"773BE75A23C1C9","user_header":"","comment_is_top":false,"comment_ctime":1576086521,"is_pvip":false,"replies":[{"id":61380,"content":"得到一个空的不能遍历的迭代器。跟任何 end() 相等比较返回真，因而你不可以对它做 ++ 操作。如果你要硬来，它就死给你看。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576107066,"ip_address":"","comment_id":161028,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"如果stream_是nullptr会怎么样？","like_count":3,"discussions":[{"author":{"id":1477855,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","nickname":"禾桃","note":"","ucode":"9FE85C34A9E9E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79742,"discussion_content":"“如果你要硬来，它就死给你看。”\n\n😂😂","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1576109187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477578,"discussion_content":"得到一个空的不能遍历的迭代器。跟任何 end() 相等比较返回真，因而你不可以对它做 ++ 操作。如果你要硬来，它就死给你看。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576107066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165120,"user_name":"EncodedStar","can_delete":false,"product_type":"c1","uid":1504234,"ip_address":"","ucode":"03958CA7DDD6AE","user_header":"https://static001.geekbang.org/account/avatar/00/16/f3/ea/2b2adda5.jpg","comment_is_top":false,"comment_ctime":1577166130,"is_pvip":false,"replies":[{"id":62948,"content":"1 对。2 你需要自己实验一下，再想想会不会有其他副作用。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577182408,"ip_address":"","comment_id":165120,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"课后思考\n1.目前这个输入迭代器的行为，在干什么情况下可能导致意料之外的后果？\n答：目前这个输入迭代器在构造里调用了++，所以，多一次构造就可能读到意料之外的结果了。\n\n2.请尝试一下改进这个输入行迭代器，看看能不能消除这种意外，如果可以，该怎么做？如果不可以，为什么？\n答：可以啊，文章里提到了，这个输入行迭代器构造的使用了++，是为了与日常使用一致，如果想改进这个一块，我们也可以改构造的时候","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479034,"discussion_content":"1 对。2 你需要自己实验一下，再想想会不会有其他副作用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577182408,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161671,"user_name":"旭东","can_delete":false,"product_type":"c1","uid":1760877,"ip_address":"","ucode":"71C43009D5D2B3","user_header":"https://static001.geekbang.org/account/avatar/00/1a/de/6d/c0d049f2.jpg","comment_is_top":false,"comment_ctime":1576292218,"is_pvip":false,"replies":[{"id":61589,"content":"1. 不能写 const，因为你修改了自己。\n\n2. 就算能写也防不了，因为你返回的是个全新的对象。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576304314,"ip_address":"","comment_id":161671,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，您好，iterater中后置++的实现是不是应该返回const；避免（i++)++这样的代码通过编译？","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479034,"discussion_content":"1 对。2 你需要自己实验一下，再想想会不会有其他副作用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577182408,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160802,"user_name":"晚风·和煦","can_delete":false,"product_type":"c1","uid":1236047,"ip_address":"","ucode":"0B1DB8F437A4B2","user_header":"","comment_is_top":false,"comment_ctime":1576034092,"is_pvip":false,"replies":[{"id":61354,"content":"现在 r.begin() 和 r.end() 可以是不同类型了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576060473,"ip_address":"","comment_id":160802,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"从 C++17 开始，I 和 S 可以是不同的类型。这带来了更大的灵活性和更多的优化可能性。   没太理解这句话😂","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477481,"discussion_content":"现在 r.begin() 和 r.end() 可以是不同类型了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576060473,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":280232,"user_name":"doge","can_delete":false,"product_type":"c1","uid":1593251,"ip_address":"","ucode":"9E2D4C8F9B4CBC","user_header":"https://static001.geekbang.org/account/avatar/00/18/4f/a3/0e56b4e5.jpg","comment_is_top":false,"comment_ctime":1614138529,"is_pvip":false,"replies":[{"id":101795,"content":"对的，这题的目的就是让你理解目前这种做法实际还是个不错的折中。也可以参考一下参考答案那节。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1614213758,"ip_address":"","comment_id":280232,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"第二个问题想了半天，好像做不到，根据begin的语义，拿到stream_对象后就必须取得第一行内容，否则返回的就是一个空string而不是文件的第一行。但是在iterator对象内好像没办法记录“第一次从strem_读”这样的一个状态。我尝试标记第一次，但是会忽视读的操作，这样还是会导致第一行内容的丢失。希望老师解惑。\n    explicit iterator(istream&amp; is) : stream_(&amp;is) {}\n    iterator begin() {\n        cout &lt;&lt; &quot;first_ = &quot; &lt;&lt; first_ &lt;&lt; endl;\n        if (first_) {\n            first_ = false;\n            return ++iterator(*stream_);\n        } else {\n            return iterator(*stream_);\n        }\n    }","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516029,"discussion_content":"对的，这题的目的就是让你理解目前这种做法实际还是个不错的折中。也可以参考一下参考答案那节。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614213758,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160817,"user_name":"小一日一","can_delete":false,"product_type":"c1","uid":1301097,"ip_address":"","ucode":"0A506C2B918C14","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtVXiaJbfkpeXH4udkPUIlFte7z3HWMebdogk8jFpgFEkJ0ruGiawUMUcZj9RLpLkIWxV7QOzbHoSg/132","comment_is_top":false,"comment_ctime":1576037730,"is_pvip":false,"replies":[{"id":61356,"content":"肯定还有更好的 C++ 代码的。学习无止境！\n\n认真学习，应该不用那么久（我还没有极客时间专栏来帮助我学习呢😌）。\n\n反过来，说明老程序员还有点价值么。🤗","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576060691,"ip_address":"","comment_id":160817,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"看了老师的代码再看自己学的代码，感觉我的C++是小学生水平。\n\n以为自己看过几遍C++ PRIMER 5th, 看过并理解effective++, more effective c++, inside the c++ object model, 能应付平时的开发需要，也能看懂公司别人的代码，就觉得自己的C++不错了，看了老师github的代码后我是彻底服了，感叹C++太博大精深，永远不敢说自己精通C++。\n\n我什么时候才能达到老师对C++理解并使用的高度呢，难道也需要20年么？","like_count":31,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477488,"discussion_content":"肯定还有更好的 C++ 代码的。学习无止境！\n\n认真学习，应该不用那么久（我还没有极客时间专栏来帮助我学习呢😌）。\n\n反过来，说明老程序员还有点价值么。🤗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576060691,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3542569,"avatar":"https://static001.geekbang.org/account/avatar/00/36/0e/29/fa3601d3.jpg","nickname":"🐶的巴普洛夫","note":"","ucode":"1213DD5A056674","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":607063,"discussion_content":"一年精通，三年熟悉，五年了解，十年用过","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1677586747,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"日本","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1625233,"avatar":"https://static001.geekbang.org/account/avatar/00/18/cc/91/d56a81af.jpg","nickname":"CoderArthur","note":"","ucode":"5B591914F0F67C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360909,"discussion_content":"被你这么一说，感觉自己要找块地钻进去了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616556253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1486168,"avatar":"https://static001.geekbang.org/account/avatar/00/16/ad/58/7d6a0b8e.jpg","nickname":"Deep","note":"","ucode":"EF3281F0A5824A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334882,"discussion_content":"我感觉我是幼儿园水平。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608017924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172645,"user_name":"Geek_b68b74","can_delete":false,"product_type":"c1","uid":1780585,"ip_address":"","ucode":"7CB026A020D513","user_header":"","comment_is_top":false,"comment_ctime":1579242815,"is_pvip":false,"replies":[{"id":67016,"content":"你的两个疑问实际是针对同一个地方。\n\nauto&amp;&amp; 那句是用一个“万能”引用捕获一个对象，左值和右值都可以。C++ 的生命期延长规则，保证了引用有效期间，istream_line_reader 这个“临时”对象一直存在。没有生命期延长的话，临时对象在当前语句执行结束后即销毁。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1579268673,"ip_address":"","comment_id":172645,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"1、使用输入行迭代器  这一部分里，“ auto&amp;&amp; r = istream_line_reader(is);”  这里为什么要用右值引用呢？\n2、还是使用输入行迭代器这里， \n\nfor (const string&amp; line :\n     istream_line_reader(is)) {\n  &#47;&#47;  示例循环体中仅进行简单输出\n  cout &lt;&lt; line &lt;&lt; endl;\n}\n“获取冒号后边的范围表达式的结果，并隐式产生一个引用，在整个循环期间都有效。注意根据生命期延长规则，表达式结果如果是临时对象的话，这个对象要在循环结束后才被销毁。”  \n 第一句是说line在整个循环期间有效？这是想表达什么呢？还有第二句，指的是哪个临时对象呢？在哪个循环结束后销毁呢？期待您的解答\n","like_count":10,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481804,"discussion_content":"你的两个疑问实际是针对同一个地方。\n\nauto&amp;amp;&amp;amp; 那句是用一个“万能”引用捕获一个对象，左值和右值都可以。C++ 的生命期延长规则，保证了引用有效期间，istream_line_reader 这个“临时”对象一直存在。没有生命期延长的话，临时对象在当前语句执行结束后即销毁。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1579268673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1276571,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7a/9b/266818bd.jpg","nickname":"秋葛格","note":"","ucode":"2935C020897809","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":185227,"discussion_content":"这里也可以用 const auto &amp; 来捕获临时变量，但是后续对其还有修改，所以用auto &amp;&amp;来捕获。\n我这样理解是不是也可以？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582605272,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1276571,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7a/9b/266818bd.jpg","nickname":"秋葛格","note":"","ucode":"2935C020897809","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":268611,"discussion_content":"我写 auto&amp;&amp; 是表示编译器是如何展开的。如果自己写，又不修改的话，const auto&amp; 确实也可以。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589808055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":185227,"ip_address":"","group_id":0},"score":268611,"extra":""}]}]},{"had_liked":false,"id":162978,"user_name":"千鲤湖","can_delete":false,"product_type":"c1","uid":1076506,"ip_address":"","ucode":"C626F15967C219","user_header":"https://static001.geekbang.org/account/avatar/00/10/6d/1a/d1d44258.jpg","comment_is_top":false,"comment_ctime":1576637080,"is_pvip":false,"replies":[{"id":61927,"content":"公布第 1 个问题的答案吧：\n\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &quot;istream_line_reader.h&quot;\n\nusing namespace std;\n\nint main()\n{\n    ifstream ifs{&quot;test.cpp&quot;};\n    istream_line_reader reader{ifs};\n    auto begin = reader.begin();\n    for (auto it = reader.begin();\n         it != reader.end(); ++it) {\n        cout &lt;&lt; *it &lt;&lt; &#39;\\n&#39;;\n    }\n}\n\n以上代码，因为 begin 多调用了一次，输出就少了一行……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576647776,"ip_address":"","comment_id":162978,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"过来看看老师问的那两个问题，好奇中。。。","like_count":10,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478195,"discussion_content":"公布第 1 个问题的答案吧：\n\n#include &amp;lt;fstream&amp;gt;\n#include &amp;lt;iostream&amp;gt;\n#include &amp;quot;istream_line_reader.h&amp;quot;\n\nusing namespace std;\n\nint main()\n{\n    ifstream ifs{&amp;quot;test.cpp&amp;quot;};\n    istream_line_reader reader{ifs};\n    auto begin = reader.begin();\n    for (auto it = reader.begin();\n         it != reader.end(); ++it) {\n        cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39;\\n&amp;#39;;\n    }\n}\n\n以上代码，因为 begin 多调用了一次，输出就少了一行……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576647776,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160909,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1576059311,"is_pvip":false,"replies":[{"id":61378,"content":"cout &lt;&lt; *it 就是读；\n*it = 42 就是写。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576106257,"ip_address":"","comment_id":160909,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"输入迭代器和输出迭代器，\n这个入和出是相对于什么而言的？\n感觉有点绕。\n\n谢谢！","like_count":6,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477528,"discussion_content":"cout &amp;lt;&amp;lt; *it 就是读；\n*it = 42 就是写。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576106257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342897,"user_name":"Slience-0°C","can_delete":false,"product_type":"c1","uid":1151612,"ip_address":"","ucode":"B50665EC6A80F5","user_header":"https://static001.geekbang.org/account/avatar/00/11/92/7c/12c571b6.jpg","comment_is_top":false,"comment_ctime":1650526323,"is_pvip":false,"replies":[{"id":125263,"content":"auto&amp;&amp; 是转发引用（第 8 讲也会简单提到）。转发引用的概念在第 3 讲里提过（我可能会在第 37 讲再展开探讨一下），但在那里的形式是 T&amp;&amp;。\n\nauto&amp;&amp; 能匹配所有的引用（const 左值、非 const 左值、右值等），使用正确的场景下后续应该使用 std::forward。如果你没看到后续用 std::forward，那这个使用很有可能不是最好的写法。根据你是否需要修改 vec 中的内容，auto&amp; 或 const auto&amp; 会更加明确。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1650548391,"ip_address":"","comment_id":342897,"utype":1}],"discussion_count":6,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"有个问题请教老师，工作中看到基于范围的for循环中，使用了auto &amp;&amp;来获取数据，而不是auto&amp;,有啥区别么？难道是为了使用移动构造函数？伪代码如下：std::vectors&lt;std::string&gt; vec;\nfor (auto&amp;&amp; : vec)","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477528,"discussion_content":"cout &amp;lt;&amp;lt; *it 就是读；\n*it = 42 就是写。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576106257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161028,"user_name":"nelson","can_delete":false,"product_type":"c1","uid":1271183,"ip_address":"","ucode":"773BE75A23C1C9","user_header":"","comment_is_top":false,"comment_ctime":1576086521,"is_pvip":false,"replies":[{"id":61380,"content":"得到一个空的不能遍历的迭代器。跟任何 end() 相等比较返回真，因而你不可以对它做 ++ 操作。如果你要硬来，它就死给你看。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576107066,"ip_address":"","comment_id":161028,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"如果stream_是nullptr会怎么样？","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":565837,"discussion_content":"auto&amp;&amp; 是转发引用（第 8 讲也会简单提到）。转发引用的概念在第 3 讲里提过（我可能会在第 37 讲再展开探讨一下），但在那里的形式是 T&amp;&amp;。\n\nauto&amp;&amp; 能匹配所有的引用（const 左值、非 const 左值、右值等），使用正确的场景下后续应该使用 std::forward。如果你没看到后续用 std::forward，那这个使用很有可能不是最好的写法。根据你是否需要修改 vec 中的内容，auto&amp; 或 const auto&amp; 会更加明确。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650548391,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":5,"child_discussions":[{"author":{"id":1151612,"avatar":"https://static001.geekbang.org/account/avatar/00/11/92/7c/12c571b6.jpg","nickname":"Slience-0°C","note":"","ucode":"B50665EC6A80F5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":566049,"discussion_content":"std::vector&lt;std::string&gt; drive_list;\nfor (auto&amp;&amp; dir : drive_list) \n{\n\tboost::system::error_code ec;\n\tif (boost::filesystem::exists(dir, ec)) \n    {\n\t\tif (boost::filesystem::is_directory(dir, ec)) \n        {\n\t\t\tfor (boost::filesystem::recursive_directory_iterator itr(dir, ec); itr != boost::filesystem::recursive_directory_iterator(); itr.increment(ec)) \n            {\n\t\t\t\tif (!boost::filesystem::is_directory(itr-&gt;path(), ec)) \n                {\n\t\t\t\t\t\tauto result = opr.call&lt;std::string&gt;(&#34;AntiVirus::scan_file&#34;, itr-&gt;path().string());\n\t\t\t\t\t\t// TODO something\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse \n        {\n\t\t\tauto result = opr.call&lt;std::string&gt;(&#34;AntiVirus::scan_file&#34;, dir);\n\t\t\t// TODO something\n\t\t}\n\t}\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650592520,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":565837,"ip_address":"","group_id":0},"score":566049,"extra":""},{"author":{"id":1151612,"avatar":"https://static001.geekbang.org/account/avatar/00/11/92/7c/12c571b6.jpg","nickname":"Slience-0°C","note":"","ucode":"B50665EC6A80F5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":566050,"discussion_content":"代码附在留言了，麻烦老师看下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650592564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":565837,"ip_address":"","group_id":0},"score":566050,"extra":""},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1151612,"avatar":"https://static001.geekbang.org/account/avatar/00/11/92/7c/12c571b6.jpg","nickname":"Slience-0°C","note":"","ucode":"B50665EC6A80F5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":566059,"discussion_content":"看起来完全可以用 const auto&amp;，更明确不会修改 drive_list。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650593475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":566050,"ip_address":"","group_id":0},"score":566059,"extra":""}]}]},{"had_liked":false,"id":165120,"user_name":"EncodedStar","can_delete":false,"product_type":"c1","uid":1504234,"ip_address":"","ucode":"03958CA7DDD6AE","user_header":"https://static001.geekbang.org/account/avatar/00/16/f3/ea/2b2adda5.jpg","comment_is_top":false,"comment_ctime":1577166130,"is_pvip":false,"replies":[{"id":62948,"content":"1 对。2 你需要自己实验一下，再想想会不会有其他副作用。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1577182408,"ip_address":"","comment_id":165120,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"课后思考\n1.目前这个输入迭代器的行为，在干什么情况下可能导致意料之外的后果？\n答：目前这个输入迭代器在构造里调用了++，所以，多一次构造就可能读到意料之外的结果了。\n\n2.请尝试一下改进这个输入行迭代器，看看能不能消除这种意外，如果可以，该怎么做？如果不可以，为什么？\n答：可以啊，文章里提到了，这个输入行迭代器构造的使用了++，是为了与日常使用一致，如果想改进这个一块，我们也可以改构造的时候","like_count":2,"discussions":[{"author":{"id":1477855,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","nickname":"禾桃","note":"","ucode":"9FE85C34A9E9E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79742,"discussion_content":"“如果你要硬来，它就死给你看。”\n\n😂😂","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1576109187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477578,"discussion_content":"得到一个空的不能遍历的迭代器。跟任何 end() 相等比较返回真，因而你不可以对它做 ++ 操作。如果你要硬来，它就死给你看。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576107066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161671,"user_name":"旭东","can_delete":false,"product_type":"c1","uid":1760877,"ip_address":"","ucode":"71C43009D5D2B3","user_header":"https://static001.geekbang.org/account/avatar/00/1a/de/6d/c0d049f2.jpg","comment_is_top":false,"comment_ctime":1576292218,"is_pvip":false,"replies":[{"id":61589,"content":"1. 不能写 const，因为你修改了自己。\n\n2. 就算能写也防不了，因为你返回的是个全新的对象。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576304314,"ip_address":"","comment_id":161671,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，您好，iterater中后置++的实现是不是应该返回const；避免（i++)++这样的代码通过编译？","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477806,"discussion_content":"1. 不能写 const，因为你修改了自己。\n\n2. 就算能写也防不了，因为你返回的是个全新的对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576304314,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160802,"user_name":"晚风·和煦","can_delete":false,"product_type":"c1","uid":1236047,"ip_address":"","ucode":"0B1DB8F437A4B2","user_header":"","comment_is_top":false,"comment_ctime":1576034092,"is_pvip":false,"replies":[{"id":61354,"content":"现在 r.begin() 和 r.end() 可以是不同类型了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576060473,"ip_address":"","comment_id":160802,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"从 C++17 开始，I 和 S 可以是不同的类型。这带来了更大的灵活性和更多的优化可能性。   没太理解这句话😂","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477806,"discussion_content":"1. 不能写 const，因为你修改了自己。\n\n2. 就算能写也防不了，因为你返回的是个全新的对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576304314,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":280232,"user_name":"doge","can_delete":false,"product_type":"c1","uid":1593251,"ip_address":"","ucode":"9E2D4C8F9B4CBC","user_header":"https://static001.geekbang.org/account/avatar/00/18/4f/a3/0e56b4e5.jpg","comment_is_top":false,"comment_ctime":1614138529,"is_pvip":false,"replies":[{"id":101795,"content":"对的，这题的目的就是让你理解目前这种做法实际还是个不错的折中。也可以参考一下参考答案那节。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1614213758,"ip_address":"","comment_id":280232,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"第二个问题想了半天，好像做不到，根据begin的语义，拿到stream_对象后就必须取得第一行内容，否则返回的就是一个空string而不是文件的第一行。但是在iterator对象内好像没办法记录“第一次从strem_读”这样的一个状态。我尝试标记第一次，但是会忽视读的操作，这样还是会导致第一行内容的丢失。希望老师解惑。\n    explicit iterator(istream&amp; is) : stream_(&amp;is) {}\n    iterator begin() {\n        cout &lt;&lt; &quot;first_ = &quot; &lt;&lt; first_ &lt;&lt; endl;\n        if (first_) {\n            first_ = false;\n            return ++iterator(*stream_);\n        } else {\n            return iterator(*stream_);\n        }\n    }","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477481,"discussion_content":"现在 r.begin() 和 r.end() 可以是不同类型了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576060473,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187428,"user_name":"englefly","can_delete":false,"product_type":"c1","uid":1145907,"ip_address":"","ucode":"E3FCF19E618718","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep2gRIticwS6CiatsCiaU4QRjAODKibQevrhSciatrmd90lNIZFxywE9yyZgAxKTmWiaBSH4zZUcRIV46qQ/132","comment_is_top":false,"comment_ctime":1584108361,"is_pvip":false,"replies":[{"id":72380,"content":"目的就是要允许 it 和 end 是不同类型……\n\n当然，这两个类型之间是需要允许比较操作的。后面有个例子，你可以先看一下：\n\nhttps:&#47;&#47;github.com&#47;adah1972&#47;geek_time_cpp&#47;blob&#47;master&#47;29&#47;test05_null_sentinel.cpp\n\n要点是，这种情况下，比较的时候可以不是比较迭代器本身，而是做一下更复杂的操作。如检查文件是否结束，读取的内容是否为 NUL（例子里的情况），甚至比较永远失败（无限循环的情况）。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1584175891,"ip_address":"","comment_id":187428,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"&quot;从 C++17 开始，I 和 S 可以是不同的类型&quot; 意味着 &quot; r.begin() 和 r.end() 可以是不同类型了。&quot;\n那么常见的循环遍历是不是就有问题了?比如下代码, it = r.begin() 此时 it是r.begin() 的类型,但it还要和r.end()比较,这时就是两个不同类型在比较了\n\nauto it = r.begin(); \nauto end = r.end(); \nfor (; it != end; ++it) {...}","like_count":1},{"had_liked":false,"id":180757,"user_name":"公众号【xii说孔方兄】","can_delete":false,"product_type":"c1","uid":1188924,"ip_address":"","ucode":"F815846C454D9D","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/3c/63bb1a53.jpg","comment_is_top":false,"comment_ctime":1582381736,"is_pvip":false,"replies":[{"id":70146,"content":"直接到 wordpress.com 上自己申请就好了。支持 Markdown，免费的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1582427642,"ip_address":"","comment_id":180757,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"吴老师，您好，我对您的自建博客很感兴趣，https:&#47;&#47;yongweiwu.wordpress.com&#47;  ，看域名使用WordPress搭建的，想向您将请教这方面的问题。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484779,"discussion_content":"直接到 wordpress.com 上自己申请就好了。支持 Markdown，免费的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582427642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168007,"user_name":"robonix","can_delete":false,"product_type":"c1","uid":1212323,"ip_address":"","ucode":"866EC82EDA455B","user_header":"https://static001.geekbang.org/account/avatar/00/12/7f/a3/23540579.jpg","comment_is_top":false,"comment_ctime":1577974900,"is_pvip":false,"replies":[{"id":65257,"content":"好问题。不过，你和getline的版本仔细分析比较一下的话，也是一个string，大家半斤八两。毕竟，按我们的用法，一个流上你也只会用一个有效的istream_line_reader::iterator。另外，遍历的时候我用的是const string&amp;，没有额外的拷贝。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578007383,"ip_address":"","comment_id":168007,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，iterator begin()函数返回一个iterator对象，这个对象还包含了string成员，这样就得拷贝了吧，效率会不会不高呢","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480097,"discussion_content":"好问题。不过，你和getline的版本仔细分析比较一下的话，也是一个string，大家半斤八两。毕竟，按我们的用法，一个流上你也只会用一个有效的istream_line_reader::iterator。另外，遍历的时候我用的是const string&amp;amp;，没有额外的拷贝。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578007383,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162391,"user_name":"总统老唐","can_delete":false,"product_type":"c1","uid":1490070,"ip_address":"","ucode":"F2CC66E5BB4871","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/96/c679bb3d.jpg","comment_is_top":false,"comment_ctime":1576508269,"is_pvip":false,"replies":[{"id":61796,"content":"1. 用 ++ 是最合理的，但也有一个奇怪的地方，目前还没人说到。\n\n2. 这个就是后置 ++。迭代器要求前置和后置 ++ 都要定义，虽然我目前只使用了前置版本。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576545045,"ip_address":"","comment_id":162391,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"吴老师，这一课有两个疑问：\n1，“到底应该让 * 负责读取还是 ++ 负责读取”，该怎样理解？如果“读取”指的是在istream上读取一行，放入line_成员中，用++实现这个操作是最常见和直觉的，同时，用 * 返回读取的内容也在最容易想到的方式，反过来，什么情况下会需要”用*来负责读取“？\n2，输入迭代器为什么要定义 iterator operator++(int) ","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478036,"discussion_content":"1. 用 ++ 是最合理的，但也有一个奇怪的地方，目前还没人说到。\n\n2. 这个就是后置 ++。迭代器要求前置和后置 ++ 都要定义，虽然我目前只使用了前置版本。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576545045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161289,"user_name":"我不生产bug，我只是bug的搬运工","can_delete":false,"product_type":"c1","uid":1757474,"ip_address":"","ucode":"C70AEAF23665C8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJKEyibia4u3kq3bia4ZiaARfvj7fRqyAN9DIqaQytdy5IsPsfpl9UCdgiaF88tTyia5w1dBynyzkatDt2A/132","comment_is_top":false,"comment_ctime":1576166594,"is_pvip":false,"replies":[{"id":61542,"content":"作为input iterator，本来你就不应该遍历第二次的。这个不是问题。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576237062,"ip_address":"","comment_id":161289,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"遍历一遍后，第二次调用begin会崩溃，stream_指针已经为空","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477677,"discussion_content":"作为input iterator，本来你就不应该遍历第二次的。这个不是问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576237062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160701,"user_name":"Geek_71d4ac","can_delete":false,"product_type":"c1","uid":1513070,"ip_address":"","ucode":"81FBA4DA79F5E4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ibb1HJTBX85TuIYRQv3eUxib5Zdc5paH1mULBaLFZf0N6C1WxLrw6ZUc4oiaEPQEdfrQMkIjIYtTib66l8VfgrtHRQ/132","comment_is_top":false,"comment_ctime":1576024006,"is_pvip":false,"replies":[{"id":61352,"content":"本身没有任何问题。如何保证行为安全（如异常安全）是个独立问题，跟是否在构造函数里没啥关系。尽量不使用裸指针非常重要，用了的话就需要照顾很多细节了……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576060189,"ip_address":"","comment_id":160701,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"在构造函数中使用this是否安全？万一构造中途失败了呢？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477456,"discussion_content":"本身没有任何问题。如何保证行为安全（如异常安全）是个独立问题，跟是否在构造函数里没啥关系。尽量不使用裸指针非常重要，用了的话就需要照顾很多细节了……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576060189,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":394251,"user_name":"淡漠落寞","can_delete":false,"product_type":"c1","uid":1049550,"ip_address":"北京","ucode":"17FF0A02D13098","user_header":"https://static001.geekbang.org/account/avatar/00/10/03/ce/ec3b8de9.jpg","comment_is_top":false,"comment_ctime":1726221116,"is_pvip":false,"replies":[{"id":143141,"content":"让调用者简单，不需要手工用 &amp;。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1726617510,"ip_address":"上海","comment_id":394251,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，请问下为什么iterator类构造函数参数不是用istream*而是要用istream&amp;？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":651235,"discussion_content":"让调用者简单，不需要手工用 &amp;。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1726617510,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1049550,"avatar":"https://static001.geekbang.org/account/avatar/00/10/03/ce/ec3b8de9.jpg","nickname":"淡漠落寞","note":"","ucode":"17FF0A02D13098","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":651655,"discussion_content":"谢谢解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1727231550,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":337568,"user_name":"水月","can_delete":false,"product_type":"c1","uid":2344034,"ip_address":"","ucode":"78FC68615016DB","user_header":"https://static001.geekbang.org/account/avatar/00/23/c4/62/269aae3f.jpg","comment_is_top":false,"comment_ctime":1646898047,"is_pvip":false,"replies":[{"id":123351,"content":"等看到第30讲，再配合一点开源库，还是很香的：\n\nhttps:&#47;&#47;github.com&#47;andreasbuhr&#47;cppcoro\nhttps:&#47;&#47;github.com&#47;netcan&#47;asyncio","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1646913843,"ip_address":"","comment_id":337568,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"看了老师关于Python yield的那篇博客，体会非常深刻。一些小算法虽然用python确实慢，但是函数式编程配上yield+yield from能给代码简化到非常不人道的水平。非常期待C++也能把这些程序员友好型设计尽快收进来","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555457,"discussion_content":"等看到第30讲，再配合一点开源库，还是很香的：\n\nhttps://github.com/andreasbuhr/cppcoro\nhttps://github.com/netcan/asyncio","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646913843,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":297636,"user_name":"怪兽","can_delete":false,"product_type":"c1","uid":1324007,"ip_address":"","ucode":"3342C55CB83B08","user_header":"https://static001.geekbang.org/account/avatar/00/14/33/e7/145be2f9.jpg","comment_is_top":false,"comment_ctime":1623681759,"is_pvip":false,"replies":[{"id":108108,"content":"输入流是 std::cin 你怎么办？","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1623753089,"ip_address":"","comment_id":297636,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"对于问题2，既然输入迭代器不禁止调用begin多次，那是否可以在每次调用begin时，重置输入流的位置到开头？不也正好符合begin的语义？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521887,"discussion_content":"输入流是 std::cin 你怎么办？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623753089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":234528,"user_name":"zhengfan","can_delete":false,"product_type":"c1","uid":1020160,"ip_address":"","ucode":"B3AC0E10BF7A14","user_header":"https://static001.geekbang.org/account/avatar/00/0f/91/00/2007d2f3.jpg","comment_is_top":false,"comment_ctime":1594714812,"is_pvip":false,"replies":[{"id":86535,"content":"不会。后置++是先把整个iterator，包括其中的string，复制了一份。只用*的话，就是访问原先的内容。\n\n当然，这个后置++复制了整个string，效率不高。不必要的话，不要使用。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1594735122,"ip_address":"","comment_id":234528,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"吴老师您好。\n我对于对于后置++的实现有些疑问。\n如果通过后置++获得了Itr并解引用，string内容其实已经是经过++的了吧？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501414,"discussion_content":"不会。后置++是先把整个iterator，包括其中的string，复制了一份。只用*的话，就是访问原先的内容。\n\n当然，这个后置++复制了整个string，效率不高。不必要的话，不要使用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594735122,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1020160,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/91/00/2007d2f3.jpg","nickname":"zhengfan","note":"","ucode":"B3AC0E10BF7A14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291352,"discussion_content":"同理，我觉得多次调用begin()导致itr输出内容不全，不应该认为是缺陷，这不属于\nsurprising的结果，而是input iterator的应有之意。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594788634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1020160,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/91/00/2007d2f3.jpg","nickname":"zhengfan","note":"","ucode":"B3AC0E10BF7A14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291271,"discussion_content":"嗯嗯是的，解引用的结果是line_决定的。所以最常用的“++之后解引用”的使用形式，结果是正确的。操作返回的itr副本遍历不在input itr定义行为中，不保证行为的结果。完美。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594749271,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187428,"user_name":"englefly","can_delete":false,"product_type":"c1","uid":1145907,"ip_address":"","ucode":"E3FCF19E618718","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep2gRIticwS6CiatsCiaU4QRjAODKibQevrhSciatrmd90lNIZFxywE9yyZgAxKTmWiaBSH4zZUcRIV46qQ/132","comment_is_top":false,"comment_ctime":1584108361,"is_pvip":false,"replies":[{"id":72380,"content":"目的就是要允许 it 和 end 是不同类型……\n\n当然，这两个类型之间是需要允许比较操作的。后面有个例子，你可以先看一下：\n\nhttps:&#47;&#47;github.com&#47;adah1972&#47;geek_time_cpp&#47;blob&#47;master&#47;29&#47;test05_null_sentinel.cpp\n\n要点是，这种情况下，比较的时候可以不是比较迭代器本身，而是做一下更复杂的操作。如检查文件是否结束，读取的内容是否为 NUL（例子里的情况），甚至比较永远失败（无限循环的情况）。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1584175891,"ip_address":"","comment_id":187428,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"&quot;从 C++17 开始，I 和 S 可以是不同的类型&quot; 意味着 &quot; r.begin() 和 r.end() 可以是不同类型了。&quot;\n那么常见的循环遍历是不是就有问题了?比如下代码, it = r.begin() 此时 it是r.begin() 的类型,但it还要和r.end()比较,这时就是两个不同类型在比较了\n\nauto it = r.begin(); \nauto end = r.end(); \nfor (; it != end; ++it) {...}","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487105,"discussion_content":"目的就是要允许 it 和 end 是不同类型……\n\n当然，这两个类型之间是需要允许比较操作的。后面有个例子，你可以先看一下：\n\nhttps://github.com/adah1972/geek_time_cpp/blob/master/29/test05_null_sentinel.cpp\n\n要点是，这种情况下，比较的时候可以不是比较迭代器本身，而是做一下更复杂的操作。如检查文件是否结束，读取的内容是否为 NUL（例子里的情况），甚至比较永远失败（无限循环的情况）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584175891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180757,"user_name":"公众号【xii说孔方兄】","can_delete":false,"product_type":"c1","uid":1188924,"ip_address":"","ucode":"F815846C454D9D","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/3c/63bb1a53.jpg","comment_is_top":false,"comment_ctime":1582381736,"is_pvip":false,"replies":[{"id":70146,"content":"直接到 wordpress.com 上自己申请就好了。支持 Markdown，免费的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1582427642,"ip_address":"","comment_id":180757,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"吴老师，您好，我对您的自建博客很感兴趣，https:&#47;&#47;yongweiwu.wordpress.com&#47;  ，看域名使用WordPress搭建的，想向您将请教这方面的问题。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487105,"discussion_content":"目的就是要允许 it 和 end 是不同类型……\n\n当然，这两个类型之间是需要允许比较操作的。后面有个例子，你可以先看一下：\n\nhttps://github.com/adah1972/geek_time_cpp/blob/master/29/test05_null_sentinel.cpp\n\n要点是，这种情况下，比较的时候可以不是比较迭代器本身，而是做一下更复杂的操作。如检查文件是否结束，读取的内容是否为 NUL（例子里的情况），甚至比较永远失败（无限循环的情况）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584175891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168007,"user_name":"robonix","can_delete":false,"product_type":"c1","uid":1212323,"ip_address":"","ucode":"866EC82EDA455B","user_header":"https://static001.geekbang.org/account/avatar/00/12/7f/a3/23540579.jpg","comment_is_top":false,"comment_ctime":1577974900,"is_pvip":false,"replies":[{"id":65257,"content":"好问题。不过，你和getline的版本仔细分析比较一下的话，也是一个string，大家半斤八两。毕竟，按我们的用法，一个流上你也只会用一个有效的istream_line_reader::iterator。另外，遍历的时候我用的是const string&amp;，没有额外的拷贝。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578007383,"ip_address":"","comment_id":168007,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，iterator begin()函数返回一个iterator对象，这个对象还包含了string成员，这样就得拷贝了吧，效率会不会不高呢","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484779,"discussion_content":"直接到 wordpress.com 上自己申请就好了。支持 Markdown，免费的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582427642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162391,"user_name":"总统老唐","can_delete":false,"product_type":"c1","uid":1490070,"ip_address":"","ucode":"F2CC66E5BB4871","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/96/c679bb3d.jpg","comment_is_top":false,"comment_ctime":1576508269,"is_pvip":false,"replies":[{"id":61796,"content":"1. 用 ++ 是最合理的，但也有一个奇怪的地方，目前还没人说到。\n\n2. 这个就是后置 ++。迭代器要求前置和后置 ++ 都要定义，虽然我目前只使用了前置版本。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576545045,"ip_address":"","comment_id":162391,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"吴老师，这一课有两个疑问：\n1，“到底应该让 * 负责读取还是 ++ 负责读取”，该怎样理解？如果“读取”指的是在istream上读取一行，放入line_成员中，用++实现这个操作是最常见和直觉的，同时，用 * 返回读取的内容也在最容易想到的方式，反过来，什么情况下会需要”用*来负责读取“？\n2，输入迭代器为什么要定义 iterator operator++(int) ","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480097,"discussion_content":"好问题。不过，你和getline的版本仔细分析比较一下的话，也是一个string，大家半斤八两。毕竟，按我们的用法，一个流上你也只会用一个有效的istream_line_reader::iterator。另外，遍历的时候我用的是const string&amp;amp;，没有额外的拷贝。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578007383,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161289,"user_name":"我不生产bug，我只是bug的搬运工","can_delete":false,"product_type":"c1","uid":1757474,"ip_address":"","ucode":"C70AEAF23665C8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJKEyibia4u3kq3bia4ZiaARfvj7fRqyAN9DIqaQytdy5IsPsfpl9UCdgiaF88tTyia5w1dBynyzkatDt2A/132","comment_is_top":false,"comment_ctime":1576166594,"is_pvip":false,"replies":[{"id":61542,"content":"作为input iterator，本来你就不应该遍历第二次的。这个不是问题。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576237062,"ip_address":"","comment_id":161289,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"遍历一遍后，第二次调用begin会崩溃，stream_指针已经为空","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478036,"discussion_content":"1. 用 ++ 是最合理的，但也有一个奇怪的地方，目前还没人说到。\n\n2. 这个就是后置 ++。迭代器要求前置和后置 ++ 都要定义，虽然我目前只使用了前置版本。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576545045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160701,"user_name":"Geek_71d4ac","can_delete":false,"product_type":"c1","uid":1513070,"ip_address":"","ucode":"81FBA4DA79F5E4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ibb1HJTBX85TuIYRQv3eUxib5Zdc5paH1mULBaLFZf0N6C1WxLrw6ZUc4oiaEPQEdfrQMkIjIYtTib66l8VfgrtHRQ/132","comment_is_top":false,"comment_ctime":1576024006,"is_pvip":false,"replies":[{"id":61352,"content":"本身没有任何问题。如何保证行为安全（如异常安全）是个独立问题，跟是否在构造函数里没啥关系。尽量不使用裸指针非常重要，用了的话就需要照顾很多细节了……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576060189,"ip_address":"","comment_id":160701,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"在构造函数中使用this是否安全？万一构造中途失败了呢？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477677,"discussion_content":"作为input iterator，本来你就不应该遍历第二次的。这个不是问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576237062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":394251,"user_name":"淡漠落寞","can_delete":false,"product_type":"c1","uid":1049550,"ip_address":"北京","ucode":"17FF0A02D13098","user_header":"https://static001.geekbang.org/account/avatar/00/10/03/ce/ec3b8de9.jpg","comment_is_top":false,"comment_ctime":1726221116,"is_pvip":false,"replies":[{"id":143141,"content":"让调用者简单，不需要手工用 &amp;。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1726617510,"ip_address":"上海","comment_id":394251,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，请问下为什么iterator类构造函数参数不是用istream*而是要用istream&amp;？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477456,"discussion_content":"本身没有任何问题。如何保证行为安全（如异常安全）是个独立问题，跟是否在构造函数里没啥关系。尽量不使用裸指针非常重要，用了的话就需要照顾很多细节了……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576060189,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":337568,"user_name":"水月","can_delete":false,"product_type":"c1","uid":2344034,"ip_address":"","ucode":"78FC68615016DB","user_header":"https://static001.geekbang.org/account/avatar/00/23/c4/62/269aae3f.jpg","comment_is_top":false,"comment_ctime":1646898047,"is_pvip":false,"replies":[{"id":123351,"content":"等看到第30讲，再配合一点开源库，还是很香的：\n\nhttps:&#47;&#47;github.com&#47;andreasbuhr&#47;cppcoro\nhttps:&#47;&#47;github.com&#47;netcan&#47;asyncio","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1646913843,"ip_address":"","comment_id":337568,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"看了老师关于Python yield的那篇博客，体会非常深刻。一些小算法虽然用python确实慢，但是函数式编程配上yield+yield from能给代码简化到非常不人道的水平。非常期待C++也能把这些程序员友好型设计尽快收进来","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":651235,"discussion_content":"让调用者简单，不需要手工用 &amp;。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1726617510,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1049550,"avatar":"https://static001.geekbang.org/account/avatar/00/10/03/ce/ec3b8de9.jpg","nickname":"淡漠落寞","note":"","ucode":"17FF0A02D13098","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":651655,"discussion_content":"谢谢解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1727231550,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":297636,"user_name":"怪兽","can_delete":false,"product_type":"c1","uid":1324007,"ip_address":"","ucode":"3342C55CB83B08","user_header":"https://static001.geekbang.org/account/avatar/00/14/33/e7/145be2f9.jpg","comment_is_top":false,"comment_ctime":1623681759,"is_pvip":false,"replies":[{"id":108108,"content":"输入流是 std::cin 你怎么办？","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1623753089,"ip_address":"","comment_id":297636,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"对于问题2，既然输入迭代器不禁止调用begin多次，那是否可以在每次调用begin时，重置输入流的位置到开头？不也正好符合begin的语义？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555457,"discussion_content":"等看到第30讲，再配合一点开源库，还是很香的：\n\nhttps://github.com/andreasbuhr/cppcoro\nhttps://github.com/netcan/asyncio","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646913843,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":234528,"user_name":"zhengfan","can_delete":false,"product_type":"c1","uid":1020160,"ip_address":"","ucode":"B3AC0E10BF7A14","user_header":"https://static001.geekbang.org/account/avatar/00/0f/91/00/2007d2f3.jpg","comment_is_top":false,"comment_ctime":1594714812,"is_pvip":false,"replies":[{"id":86535,"content":"不会。后置++是先把整个iterator，包括其中的string，复制了一份。只用*的话，就是访问原先的内容。\n\n当然，这个后置++复制了整个string，效率不高。不必要的话，不要使用。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1594735122,"ip_address":"","comment_id":234528,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"吴老师您好。\n我对于对于后置++的实现有些疑问。\n如果通过后置++获得了Itr并解引用，string内容其实已经是经过++的了吧？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521887,"discussion_content":"输入流是 std::cin 你怎么办？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623753089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220217,"user_name":"The Answer........","can_delete":false,"product_type":"c1","uid":2003313,"ip_address":"","ucode":"896638729520A6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/dQQR8nfd3k8zO9Z7TjOxSneFmiarGct9o6JORPrzMyyic8ZnPB97SuvYp544UKCQ24dj2LOvsbUQE3zb1uAGWG7Q/132","comment_is_top":false,"comment_ctime":1590207815,"is_pvip":false,"replies":[{"id":81352,"content":"end() 实际上是返回一个常值，是 const 应该没疑问。begin() 不是 const，是因为从“语义”上来说，调用 begin 就会修改这个“范围”。在实际使用中实际上是没什么差异的，因为一个 input iterator&#47;range 总是会修改输入的内容的。一般没有纯 input range（不是前向或更强的情况）可以使用 const 访问的情况。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1590247452,"ip_address":"","comment_id":220217,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"iterator begin()  {    return iterator(*stream_);  }  \niterator end() const noexcept  {    return iterator();  }\n\n吴老师我这里对istream_line_reader类中的成员函数begin()和end()有一个疑问.\n为什么begin()没有加const标注成一个accessor, 而end()函数加了一个const标注成了accessor.\nbegin()函数构建了一个以*istream为参数的iterator, 不是也没有改变istream_line_reader私有成员istream_指针的state吗. 有变化的只是istream_指针指向的输入流对象. 但是指针的状态并没有发生改变. 这不是还是符合accessor的定义吗.","like_count":0},{"had_liked":false,"id":168153,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1217554,"ip_address":"","ucode":"C5A540BC5A60B9","user_header":"https://static001.geekbang.org/account/avatar/00/12/94/12/15558f28.jpg","comment_is_top":false,"comment_ctime":1578021136,"is_pvip":false,"replies":[{"id":65326,"content":"从实际使用上讲是这样。单从规定上来讲，输入迭代器不禁止调用begin多次的。所以目前的行为不理想，但一般没问题。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578049954,"ip_address":"","comment_id":168153,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"针对第二个问题，我回头想这是一个输入迭代器，不需要满足多次访问，所以两次begin不是它的职责范围吧，使用新标准的for循环就不会出现意外结果。老师是这样吗？想了一晚上，哈哈","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480154,"discussion_content":"从实际使用上讲是这样。单从规定上来讲，输入迭代器不禁止调用begin多次的。所以目前的行为不理想，但一般没问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578049954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162171,"user_name":"千鲤湖","can_delete":false,"product_type":"c1","uid":1076506,"ip_address":"","ucode":"C626F15967C219","user_header":"https://static001.geekbang.org/account/avatar/00/10/6d/1a/d1d44258.jpg","comment_is_top":false,"comment_ctime":1576470830,"is_pvip":false,"replies":[{"id":61713,"content":"不是我想的那个……\n\n这个是个问题，但一般不必解决。要能够比较，对性能影响太大。我线上的版本里是有下面这段注释的：\n\n&#47;&#47; This implementation basically says, any iterators\n&#47;&#47; pointing to the same stream are equal.  This behaviour\n&#47;&#47; may seem a little surprising in the beginning, but, in\n&#47;&#47; reality, it hardly has any consequences, as people\n&#47;&#47; usually compare an input iterator only to the sentinel\n&#47;&#47; object.  The alternative, using _M_stream-&gt;tellg() to\n&#47;&#47; get the exact position, harms the performance too dearly.\n&#47;&#47; I do not really have a better choice.\n&#47;&#47;\n&#47;&#47; If you do need to compare valid iterators, consider using\n&#47;&#47; file_line_reader or mmap_line_reader.\n","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576474714,"ip_address":"","comment_id":162171,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"１．可能是operator==中，比较时没有获取当前文件流位置，这样的话，无法比较不同istream(同一个文件)创建的iterator?　\n\n2  采用ftell获取当前文件流位置","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480154,"discussion_content":"从实际使用上讲是这样。单从规定上来讲，输入迭代器不禁止调用begin多次的。所以目前的行为不理想，但一般没问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578049954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161877,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1576388119,"is_pvip":false,"replies":[{"id":61645,"content":"#1 对我来讲，这不是意外。就像你对空指针解引用崩溃也不是意外一样。没有有效的 istream，你要取这个流的开头，出错很正常。\n\n#2 因为你没有看到我想的问题，所以第二部分也不是我要的回答……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576394395,"ip_address":"","comment_id":161877,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"#1 目前这个输入行迭代器的行为，在什么情况下可能导致意料之外的后果？\n    auto x  = istream_line_reader();\n    auto xit = x.begin(); \n   这个函数会调用istream_line_reader:: iterator::operator++() {\n   getline(*nullptr, _M_line); &lt;----  死翘翘 }\n但是用户觉得，我只是调用了x.begin, 不至于死的这么突然吧：（\n\n#2 请尝试一下改进这个输入行迭代器，看看能不能消除这种意外。如果可以，该怎么做？如果不可以，为什么？\n看了您的git代码, 看到了对nullptr的识别和抛出异常的处理，这是个解决方案。或者我们可以istream_line_reader() = delete? 没想到我们需要构造函数istream_line_reader() 的场景。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477975,"discussion_content":"不是我想的那个……\n\n这个是个问题，但一般不必解决。要能够比较，对性能影响太大。我线上的版本里是有下面这段注释的：\n\n// This implementation basically says, any iterators\n// pointing to the same stream are equal.  This behaviour\n// may seem a little surprising in the beginning, but, in\n// reality, it hardly has any consequences, as people\n// usually compare an input iterator only to the sentinel\n// object.  The alternative, using _M_stream-&amp;gt;tellg() to\n// get the exact position, harms the performance too dearly.\n// I do not really have a better choice.\n//\n// If you do need to compare valid iterators, consider using\n// file_line_reader or mmap_line_reader.\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576474714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161781,"user_name":"MT","can_delete":false,"product_type":"c1","uid":1757966,"ip_address":"","ucode":"82DB096F2376C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/BDK5t6TTCibvGI2GiccmrkROwHE7BKHOVd5O9wpmuB7AR0Ecao6ECsZTkDHWYSExJD7S72UBO4RuWibNp270IpF7w/132","comment_is_top":false,"comment_ctime":1576325947,"is_pvip":false,"replies":[{"id":61643,"content":"前面部分没有问题。后面的失败部分，没看懂你的意思。\n\n我这个例子重点在于，null_sentinel 表示的不是一个位置，而是一个条件。我们可以用迭代器来表示一个条件，这是对它的功能的很大扩展。虽然这种扩展方式性能非常好，但这个功能主要不是优化，而是新的可能性。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576393747,"ip_address":"","comment_id":161781,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"老师，这次是上次关于那个例子的补充：\n1. 在进行迭代的时候，begin()和end()方法，即你所说的，编译器会自动生成指向数组头尾的指针\n2. 在end()方法内返回了struct null_sentinel{} 的一个对象，即 I 和 S 的类型不同\n3.通过使用 struct null_sentinel{}；所提供的operator!=() 从而达到对字符串遍历的截至\n如有不对，请老师指出\n之后我尝试过，在 c_string_view{} 中的 end 方法，返回一个它本身的对象，并为NULL，同时重载它的 ！= 运算符，但是失败了。\n我想问下，这便算是属于一种更多的优化可能性吗？在之后，若需要只需要修改struct null_sentinel{}；即可？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477856,"discussion_content":"前面部分没有问题。后面的失败部分，没看懂你的意思。\n\n我这个例子重点在于，null_sentinel 表示的不是一个位置，而是一个条件。我们可以用迭代器来表示一个条件，这是对它的功能的很大扩展。虽然这种扩展方式性能非常好，但这个功能主要不是优化，而是新的可能性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576393747,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161377,"user_name":"木瓜777","can_delete":false,"product_type":"c1","uid":1512537,"ip_address":"","ucode":"FC52A499AF6374","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/aFAYPyw7ywC1xE9h1qibnTBwtWn2ClJqlicy5cMomhZVaruMyqSq76wMkS279mUaGhrLGwWo9ZnW0WCWfmMovlXw/132","comment_is_top":false,"comment_ctime":1576199368,"is_pvip":false,"replies":[{"id":61552,"content":"拷贝构造失败的话，直接抛异常了，当然不会继续读取下一行。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576275233,"ip_address":"","comment_id":161377,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"iterator operator++(int)    {      iterator temp(*this);      ++*this;      return temp;    }\n\n这个拷贝构造，是否会出问题？ 如果失败，this继续读取下一行，但temp是异常的。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477700,"discussion_content":"拷贝构造失败的话，直接抛异常了，当然不会继续读取下一行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576275233,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161219,"user_name":"MT","can_delete":false,"product_type":"c1","uid":1757966,"ip_address":"","ucode":"82DB096F2376C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/BDK5t6TTCibvGI2GiccmrkROwHE7BKHOVd5O9wpmuB7AR0Ecao6ECsZTkDHWYSExJD7S72UBO4RuWibNp270IpF7w/132","comment_is_top":false,"comment_ctime":1576150181,"is_pvip":false,"replies":[{"id":61481,"content":"给个例子你仔细研读一下吧。功能是遍历字符串，直到遇到字符串结尾（事先不知道字符串长度）。\n\n#include &lt;stdio.h&gt;\n\nstruct null_sentinel {};\n\nbool operator!=(const char* ptr, null_sentinel)\n{\n    return *ptr != 0;\n}\n\n&#47;&#47; operator!=(null_sentinel, const char* ptr), operator==, ...\n\nstruct c_string_view {\n    c_string_view(const char* str) : str_(str) {}\n    const char* begin() const { return str_; }\n    null_sentinel end() const { return null_sentinel{}; }\n    const char* str_;\n};\n\nint main()\n{\n    c_string_view msg{&quot;Hello world!&quot;};\n    for (char ch : msg) {\n        putchar(ch);\n    }\n    putchar(&#39;\\n&#39;);\n}\n","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576168839,"ip_address":"","comment_id":161219,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"老师，可以讲以下为什么可以将I 和 S 设置成不同的类型吗？具体使用在那些方面?","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477646,"discussion_content":"给个例子你仔细研读一下吧。功能是遍历字符串，直到遇到字符串结尾（事先不知道字符串长度）。\n\n#include &amp;lt;stdio.h&amp;gt;\n\nstruct null_sentinel {};\n\nbool operator!=(const char* ptr, null_sentinel)\n{\n    return *ptr != 0;\n}\n\n// operator!=(null_sentinel, const char* ptr), operator==, ...\n\nstruct c_string_view {\n    c_string_view(const char* str) : str_(str) {}\n    const char* begin() const { return str_; }\n    null_sentinel end() const { return null_sentinel{}; }\n    const char* str_;\n};\n\nint main()\n{\n    c_string_view msg{&amp;quot;Hello world!&amp;quot;};\n    for (char ch : msg) {\n        putchar(ch);\n    }\n    putchar(&amp;#39;\\n&amp;#39;);\n}\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576168839,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161140,"user_name":"Scott","can_delete":false,"product_type":"c1","uid":1014800,"ip_address":"","ucode":"7E57FDCB5E5D49","user_header":"","comment_is_top":false,"comment_ctime":1576129674,"is_pvip":false,"replies":[{"id":61457,"content":"你对容器的 end() 解引用，同样可能崩溃（取决于实现）。你不被允许这么做。这么做，你就进入了 undefined behavior 的领域，系统是死还是出 bug 都正常。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576140894,"ip_address":"","comment_id":161140,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"我的理解是istream_line_reader的iterator在到达end时，再++会直接crash，这个和STL里面主流容器的行为是不一致的。\n可以在get_line之前，判断一下stream_是否为nullptr，不是才调用，对end的iterator反复进行++都一直返回自己本身。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477613,"discussion_content":"你对容器的 end() 解引用，同样可能崩溃（取决于实现）。你不被允许这么做。这么做，你就进入了 undefined behavior 的领域，系统是死还是出 bug 都正常。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576140894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160853,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1576047373,"is_pvip":false,"replies":[{"id":61357,"content":"你说的情况会出问题，但这个是需要调用者保证的，我做不了什么事情。\n\n再想想。🤓","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576060789,"ip_address":"","comment_id":160853,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"意料之外的后果，是不是主要就是资源发生了不可控或不可知的泄露或状态改变？\n\n这里的资源我觉得一是string对象，一个是istream对象，那么在这两个对象的内存管理上会引起问题？\n\n比如构造函数中传入的istream指针没有被管理起来，它指向的对象如果被析构就会发生异常？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477503,"discussion_content":"你说的情况会出问题，但这个是需要调用者保证的，我做不了什么事情。\n\n再想想。🤓","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576060789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160816,"user_name":"小一日一","can_delete":false,"product_type":"c1","uid":1301097,"ip_address":"","ucode":"0A506C2B918C14","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtVXiaJbfkpeXH4udkPUIlFte7z3HWMebdogk8jFpgFEkJ0ruGiawUMUcZj9RLpLkIWxV7QOzbHoSg/132","comment_is_top":false,"comment_ctime":1576037154,"is_pvip":false,"replies":[{"id":61355,"content":"抛异常是很正常的呀，不是问题。不过，IO streams 缺省应该是不抛异常的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576060581,"ip_address":"","comment_id":160816,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"1. 我能想到的一点是，istream_line_reader在构造时没有对输入流的状态做检测，如果在输入流处于错误状态时调用getline()，会抛 ios_base::failure异常。\n2. 我把带输入流检查的构造贴一下：\n    istream_line_reader() noexcept : stream_(nullptr) {}                                                                                   \n    explicit istream_line_reader( istream&amp; is) noexcept {                                                                                  \n        if (is.good()) stream_ = &amp;is;                                                                                                      \n        else stream_ = nullptr;                                                                                                            \n    }","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477487,"discussion_content":"抛异常是很正常的呀，不是问题。不过，IO streams 缺省应该是不抛异常的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576060581,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220217,"user_name":"The Answer........","can_delete":false,"product_type":"c1","uid":2003313,"ip_address":"","ucode":"896638729520A6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/dQQR8nfd3k8zO9Z7TjOxSneFmiarGct9o6JORPrzMyyic8ZnPB97SuvYp544UKCQ24dj2LOvsbUQE3zb1uAGWG7Q/132","comment_is_top":false,"comment_ctime":1590207815,"is_pvip":false,"replies":[{"id":81352,"content":"end() 实际上是返回一个常值，是 const 应该没疑问。begin() 不是 const，是因为从“语义”上来说，调用 begin 就会修改这个“范围”。在实际使用中实际上是没什么差异的，因为一个 input iterator&#47;range 总是会修改输入的内容的。一般没有纯 input range（不是前向或更强的情况）可以使用 const 访问的情况。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1590247452,"ip_address":"","comment_id":220217,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"iterator begin()  {    return iterator(*stream_);  }  \niterator end() const noexcept  {    return iterator();  }\n\n吴老师我这里对istream_line_reader类中的成员函数begin()和end()有一个疑问.\n为什么begin()没有加const标注成一个accessor, 而end()函数加了一个const标注成了accessor.\nbegin()函数构建了一个以*istream为参数的iterator, 不是也没有改变istream_line_reader私有成员istream_指针的state吗. 有变化的只是istream_指针指向的输入流对象. 但是指针的状态并没有发生改变. 这不是还是符合accessor的定义吗.","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496091,"discussion_content":"end() 实际上是返回一个常值，是 const 应该没疑问。begin() 不是 const，是因为从“语义”上来说，调用 begin 就会修改这个“范围”。在实际使用中实际上是没什么差异的，因为一个 input iterator/range 总是会修改输入的内容的。一般没有纯 input range（不是前向或更强的情况）可以使用 const 访问的情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590247452,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168153,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1217554,"ip_address":"","ucode":"C5A540BC5A60B9","user_header":"https://static001.geekbang.org/account/avatar/00/12/94/12/15558f28.jpg","comment_is_top":false,"comment_ctime":1578021136,"is_pvip":false,"replies":[{"id":65326,"content":"从实际使用上讲是这样。单从规定上来讲，输入迭代器不禁止调用begin多次的。所以目前的行为不理想，但一般没问题。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578049954,"ip_address":"","comment_id":168153,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"针对第二个问题，我回头想这是一个输入迭代器，不需要满足多次访问，所以两次begin不是它的职责范围吧，使用新标准的for循环就不会出现意外结果。老师是这样吗？想了一晚上，哈哈","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496091,"discussion_content":"end() 实际上是返回一个常值，是 const 应该没疑问。begin() 不是 const，是因为从“语义”上来说，调用 begin 就会修改这个“范围”。在实际使用中实际上是没什么差异的，因为一个 input iterator/range 总是会修改输入的内容的。一般没有纯 input range（不是前向或更强的情况）可以使用 const 访问的情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590247452,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162171,"user_name":"千鲤湖","can_delete":false,"product_type":"c1","uid":1076506,"ip_address":"","ucode":"C626F15967C219","user_header":"https://static001.geekbang.org/account/avatar/00/10/6d/1a/d1d44258.jpg","comment_is_top":false,"comment_ctime":1576470830,"is_pvip":false,"replies":[{"id":61713,"content":"不是我想的那个……\n\n这个是个问题，但一般不必解决。要能够比较，对性能影响太大。我线上的版本里是有下面这段注释的：\n\n&#47;&#47; This implementation basically says, any iterators\n&#47;&#47; pointing to the same stream are equal.  This behaviour\n&#47;&#47; may seem a little surprising in the beginning, but, in\n&#47;&#47; reality, it hardly has any consequences, as people\n&#47;&#47; usually compare an input iterator only to the sentinel\n&#47;&#47; object.  The alternative, using _M_stream-&gt;tellg() to\n&#47;&#47; get the exact position, harms the performance too dearly.\n&#47;&#47; I do not really have a better choice.\n&#47;&#47;\n&#47;&#47; If you do need to compare valid iterators, consider using\n&#47;&#47; file_line_reader or mmap_line_reader.\n","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576474714,"ip_address":"","comment_id":162171,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"１．可能是operator==中，比较时没有获取当前文件流位置，这样的话，无法比较不同istream(同一个文件)创建的iterator?　\n\n2  采用ftell获取当前文件流位置","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477975,"discussion_content":"不是我想的那个……\n\n这个是个问题，但一般不必解决。要能够比较，对性能影响太大。我线上的版本里是有下面这段注释的：\n\n// This implementation basically says, any iterators\n// pointing to the same stream are equal.  This behaviour\n// may seem a little surprising in the beginning, but, in\n// reality, it hardly has any consequences, as people\n// usually compare an input iterator only to the sentinel\n// object.  The alternative, using _M_stream-&amp;gt;tellg() to\n// get the exact position, harms the performance too dearly.\n// I do not really have a better choice.\n//\n// If you do need to compare valid iterators, consider using\n// file_line_reader or mmap_line_reader.\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576474714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161877,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1576388119,"is_pvip":false,"replies":[{"id":61645,"content":"#1 对我来讲，这不是意外。就像你对空指针解引用崩溃也不是意外一样。没有有效的 istream，你要取这个流的开头，出错很正常。\n\n#2 因为你没有看到我想的问题，所以第二部分也不是我要的回答……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576394395,"ip_address":"","comment_id":161877,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"#1 目前这个输入行迭代器的行为，在什么情况下可能导致意料之外的后果？\n    auto x  = istream_line_reader();\n    auto xit = x.begin(); \n   这个函数会调用istream_line_reader:: iterator::operator++() {\n   getline(*nullptr, _M_line); &lt;----  死翘翘 }\n但是用户觉得，我只是调用了x.begin, 不至于死的这么突然吧：（\n\n#2 请尝试一下改进这个输入行迭代器，看看能不能消除这种意外。如果可以，该怎么做？如果不可以，为什么？\n看了您的git代码, 看到了对nullptr的识别和抛出异常的处理，这是个解决方案。或者我们可以istream_line_reader() = delete? 没想到我们需要构造函数istream_line_reader() 的场景。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477890,"discussion_content":"#1 对我来讲，这不是意外。就像你对空指针解引用崩溃也不是意外一样。没有有效的 istream，你要取这个流的开头，出错很正常。\n\n#2 因为你没有看到我想的问题，所以第二部分也不是我要的回答……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576394395,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161781,"user_name":"MT","can_delete":false,"product_type":"c1","uid":1757966,"ip_address":"","ucode":"82DB096F2376C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/BDK5t6TTCibvGI2GiccmrkROwHE7BKHOVd5O9wpmuB7AR0Ecao6ECsZTkDHWYSExJD7S72UBO4RuWibNp270IpF7w/132","comment_is_top":false,"comment_ctime":1576325947,"is_pvip":false,"replies":[{"id":61643,"content":"前面部分没有问题。后面的失败部分，没看懂你的意思。\n\n我这个例子重点在于，null_sentinel 表示的不是一个位置，而是一个条件。我们可以用迭代器来表示一个条件，这是对它的功能的很大扩展。虽然这种扩展方式性能非常好，但这个功能主要不是优化，而是新的可能性。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576393747,"ip_address":"","comment_id":161781,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"老师，这次是上次关于那个例子的补充：\n1. 在进行迭代的时候，begin()和end()方法，即你所说的，编译器会自动生成指向数组头尾的指针\n2. 在end()方法内返回了struct null_sentinel{} 的一个对象，即 I 和 S 的类型不同\n3.通过使用 struct null_sentinel{}；所提供的operator!=() 从而达到对字符串遍历的截至\n如有不对，请老师指出\n之后我尝试过，在 c_string_view{} 中的 end 方法，返回一个它本身的对象，并为NULL，同时重载它的 ！= 运算符，但是失败了。\n我想问下，这便算是属于一种更多的优化可能性吗？在之后，若需要只需要修改struct null_sentinel{}；即可？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477890,"discussion_content":"#1 对我来讲，这不是意外。就像你对空指针解引用崩溃也不是意外一样。没有有效的 istream，你要取这个流的开头，出错很正常。\n\n#2 因为你没有看到我想的问题，所以第二部分也不是我要的回答……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576394395,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161377,"user_name":"木瓜777","can_delete":false,"product_type":"c1","uid":1512537,"ip_address":"","ucode":"FC52A499AF6374","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/aFAYPyw7ywC1xE9h1qibnTBwtWn2ClJqlicy5cMomhZVaruMyqSq76wMkS279mUaGhrLGwWo9ZnW0WCWfmMovlXw/132","comment_is_top":false,"comment_ctime":1576199368,"is_pvip":false,"replies":[{"id":61552,"content":"拷贝构造失败的话，直接抛异常了，当然不会继续读取下一行。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576275233,"ip_address":"","comment_id":161377,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"iterator operator++(int)    {      iterator temp(*this);      ++*this;      return temp;    }\n\n这个拷贝构造，是否会出问题？ 如果失败，this继续读取下一行，但temp是异常的。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477856,"discussion_content":"前面部分没有问题。后面的失败部分，没看懂你的意思。\n\n我这个例子重点在于，null_sentinel 表示的不是一个位置，而是一个条件。我们可以用迭代器来表示一个条件，这是对它的功能的很大扩展。虽然这种扩展方式性能非常好，但这个功能主要不是优化，而是新的可能性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576393747,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161219,"user_name":"MT","can_delete":false,"product_type":"c1","uid":1757966,"ip_address":"","ucode":"82DB096F2376C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/BDK5t6TTCibvGI2GiccmrkROwHE7BKHOVd5O9wpmuB7AR0Ecao6ECsZTkDHWYSExJD7S72UBO4RuWibNp270IpF7w/132","comment_is_top":false,"comment_ctime":1576150181,"is_pvip":false,"replies":[{"id":61481,"content":"给个例子你仔细研读一下吧。功能是遍历字符串，直到遇到字符串结尾（事先不知道字符串长度）。\n\n#include &lt;stdio.h&gt;\n\nstruct null_sentinel {};\n\nbool operator!=(const char* ptr, null_sentinel)\n{\n    return *ptr != 0;\n}\n\n&#47;&#47; operator!=(null_sentinel, const char* ptr), operator==, ...\n\nstruct c_string_view {\n    c_string_view(const char* str) : str_(str) {}\n    const char* begin() const { return str_; }\n    null_sentinel end() const { return null_sentinel{}; }\n    const char* str_;\n};\n\nint main()\n{\n    c_string_view msg{&quot;Hello world!&quot;};\n    for (char ch : msg) {\n        putchar(ch);\n    }\n    putchar(&#39;\\n&#39;);\n}\n","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576168839,"ip_address":"","comment_id":161219,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"老师，可以讲以下为什么可以将I 和 S 设置成不同的类型吗？具体使用在那些方面?","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477700,"discussion_content":"拷贝构造失败的话，直接抛异常了，当然不会继续读取下一行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576275233,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161140,"user_name":"Scott","can_delete":false,"product_type":"c1","uid":1014800,"ip_address":"","ucode":"7E57FDCB5E5D49","user_header":"","comment_is_top":false,"comment_ctime":1576129674,"is_pvip":false,"replies":[{"id":61457,"content":"你对容器的 end() 解引用，同样可能崩溃（取决于实现）。你不被允许这么做。这么做，你就进入了 undefined behavior 的领域，系统是死还是出 bug 都正常。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576140894,"ip_address":"","comment_id":161140,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"我的理解是istream_line_reader的iterator在到达end时，再++会直接crash，这个和STL里面主流容器的行为是不一致的。\n可以在get_line之前，判断一下stream_是否为nullptr，不是才调用，对end的iterator反复进行++都一直返回自己本身。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477646,"discussion_content":"给个例子你仔细研读一下吧。功能是遍历字符串，直到遇到字符串结尾（事先不知道字符串长度）。\n\n#include &amp;lt;stdio.h&amp;gt;\n\nstruct null_sentinel {};\n\nbool operator!=(const char* ptr, null_sentinel)\n{\n    return *ptr != 0;\n}\n\n// operator!=(null_sentinel, const char* ptr), operator==, ...\n\nstruct c_string_view {\n    c_string_view(const char* str) : str_(str) {}\n    const char* begin() const { return str_; }\n    null_sentinel end() const { return null_sentinel{}; }\n    const char* str_;\n};\n\nint main()\n{\n    c_string_view msg{&amp;quot;Hello world!&amp;quot;};\n    for (char ch : msg) {\n        putchar(ch);\n    }\n    putchar(&amp;#39;\\n&amp;#39;);\n}\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576168839,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160853,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1576047373,"is_pvip":false,"replies":[{"id":61357,"content":"你说的情况会出问题，但这个是需要调用者保证的，我做不了什么事情。\n\n再想想。🤓","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576060789,"ip_address":"","comment_id":160853,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"意料之外的后果，是不是主要就是资源发生了不可控或不可知的泄露或状态改变？\n\n这里的资源我觉得一是string对象，一个是istream对象，那么在这两个对象的内存管理上会引起问题？\n\n比如构造函数中传入的istream指针没有被管理起来，它指向的对象如果被析构就会发生异常？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477613,"discussion_content":"你对容器的 end() 解引用，同样可能崩溃（取决于实现）。你不被允许这么做。这么做，你就进入了 undefined behavior 的领域，系统是死还是出 bug 都正常。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576140894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160816,"user_name":"小一日一","can_delete":false,"product_type":"c1","uid":1301097,"ip_address":"","ucode":"0A506C2B918C14","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtVXiaJbfkpeXH4udkPUIlFte7z3HWMebdogk8jFpgFEkJ0ruGiawUMUcZj9RLpLkIWxV7QOzbHoSg/132","comment_is_top":false,"comment_ctime":1576037154,"is_pvip":false,"replies":[{"id":61355,"content":"抛异常是很正常的呀，不是问题。不过，IO streams 缺省应该是不抛异常的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576060581,"ip_address":"","comment_id":160816,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"1. 我能想到的一点是，istream_line_reader在构造时没有对输入流的状态做检测，如果在输入流处于错误状态时调用getline()，会抛 ios_base::failure异常。\n2. 我把带输入流检查的构造贴一下：\n    istream_line_reader() noexcept : stream_(nullptr) {}                                                                                   \n    explicit istream_line_reader( istream&amp; is) noexcept {                                                                                  \n        if (is.good()) stream_ = &amp;is;                                                                                                      \n        else stream_ = nullptr;                                                                                                            \n    }","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477503,"discussion_content":"你说的情况会出问题，但这个是需要调用者保证的，我做不了什么事情。\n\n再想想。🤓","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576060789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160778,"user_name":"廖熊猫","can_delete":false,"product_type":"c1","uid":1141444,"ip_address":"","ucode":"8E8C475CD11FBC","user_header":"https://static001.geekbang.org/account/avatar/00/11/6a/c4/8679ca8a.jpg","comment_is_top":false,"comment_ctime":1576031832,"is_pvip":false,"replies":[{"id":61379,"content":"你说的用法我觉得还是不会让人惊讶的……\n\n你是说 Ivan Čukić 写的 Functional Programming in C++ 吗？我是那本书的技术校对……嗯，我当然推荐它的。Range 下面会单独有一讲。\n\n学语言，还是要多读多写多练。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576106548,"ip_address":"","comment_id":160778,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"我认为是因为stream操作有副作用吧，在使用++还是*读取的时候有提到，每次读取的话都会受到影响，如果我在使用迭代器之前操作了stream，这个迭代器的操作范围就不是我预期的范围了。迭代器玩法很多啊，有一本《Functional C++》讲了很多基于范围的操作，不过水平不够，没学到什么精髓。","like_count":0},{"had_liked":false,"id":160655,"user_name":"玄兴梦影","can_delete":false,"product_type":"c1","uid":1364855,"ip_address":"","ucode":"D9EDBBC61317E9","user_header":"https://static001.geekbang.org/account/avatar/00/14/d3/77/fb38ccf1.jpg","comment_is_top":false,"comment_ctime":1575995029,"is_pvip":false,"replies":[{"id":61303,"content":"auto 正是下一讲的主要内容。第二个问题，在正文里搜“基于范围的 for 循环”。代码例子没细看么？🤔","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576022802,"ip_address":"","comment_id":160655,"utype":1}],"discussion_count":2,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"老师，可以讲讲auto？\n我一直很期待新的for，可是没看到在哪？\n这儿就详细介绍了迭代器及各种不同的迭代器。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477475,"discussion_content":"你说的用法我觉得还是不会让人惊讶的……\n\n你是说 Ivan Čukić 写的 Functional Programming in C++ 吗？我是那本书的技术校对……嗯，我当然推荐它的。Range 下面会单独有一讲。\n\n学语言，还是要多读多写多练。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576106548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329067,"user_name":"Geek_d89079","can_delete":false,"product_type":"c1","uid":2878862,"ip_address":"","ucode":"75177B6DB13CAA","user_header":"","comment_is_top":false,"comment_ctime":1641092562,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":1,"score":5,"product_id":100040501,"comment_content":"我可能学的是C-- ","like_count":7},{"had_liked":false,"id":340050,"user_name":"硕","can_delete":false,"product_type":"c1","uid":2540708,"ip_address":"","ucode":"1F68B408F4BBED","user_header":"https://static001.geekbang.org/account/avatar/00/26/c4/a4/20f44910.jpg","comment_is_top":false,"comment_ctime":1648555707,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"写得真巧妙。佩服佩服！","like_count":1},{"had_liked":false,"id":215035,"user_name":"易轻尘","can_delete":false,"product_type":"c1","uid":1136684,"ip_address":"","ucode":"0D0CB9D6D45A70","user_header":"https://static001.geekbang.org/account/avatar/00/11/58/2c/92c7ce3b.jpg","comment_is_top":false,"comment_ctime":1588894702,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"原来这就是高手写的c++吗","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477448,"discussion_content":"auto 正是下一讲的主要内容。第二个问题，在正文里搜“基于范围的 for 循环”。代码例子没细看么？🤔","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576022802,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1364855,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d3/77/fb38ccf1.jpg","nickname":"玄兴梦影","note":"","ucode":"D9EDBBC61317E9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78805,"discussion_content":"看到了，期待下一讲","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576023895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160778,"user_name":"廖熊猫","can_delete":false,"product_type":"c1","uid":1141444,"ip_address":"","ucode":"8E8C475CD11FBC","user_header":"https://static001.geekbang.org/account/avatar/00/11/6a/c4/8679ca8a.jpg","comment_is_top":false,"comment_ctime":1576031832,"is_pvip":false,"replies":[{"id":61379,"content":"你说的用法我觉得还是不会让人惊讶的……\n\n你是说 Ivan Čukić 写的 Functional Programming in C++ 吗？我是那本书的技术校对……嗯，我当然推荐它的。Range 下面会单独有一讲。\n\n学语言，还是要多读多写多练。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576106548,"ip_address":"","comment_id":160778,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"我认为是因为stream操作有副作用吧，在使用++还是*读取的时候有提到，每次读取的话都会受到影响，如果我在使用迭代器之前操作了stream，这个迭代器的操作范围就不是我预期的范围了。迭代器玩法很多啊，有一本《Functional C++》讲了很多基于范围的操作，不过水平不够，没学到什么精髓。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477475,"discussion_content":"你说的用法我觉得还是不会让人惊讶的……\n\n你是说 Ivan Čukić 写的 Functional Programming in C++ 吗？我是那本书的技术校对……嗯，我当然推荐它的。Range 下面会单独有一讲。\n\n学语言，还是要多读多写多练。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576106548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160655,"user_name":"玄兴梦影","can_delete":false,"product_type":"c1","uid":1364855,"ip_address":"","ucode":"D9EDBBC61317E9","user_header":"https://static001.geekbang.org/account/avatar/00/14/d3/77/fb38ccf1.jpg","comment_is_top":false,"comment_ctime":1575995029,"is_pvip":false,"replies":[{"id":61303,"content":"auto 正是下一讲的主要内容。第二个问题，在正文里搜“基于范围的 for 循环”。代码例子没细看么？🤔","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576022802,"ip_address":"","comment_id":160655,"utype":1}],"discussion_count":2,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"老师，可以讲讲auto？\n我一直很期待新的for，可是没看到在哪？\n这儿就详细介绍了迭代器及各种不同的迭代器。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477448,"discussion_content":"auto 正是下一讲的主要内容。第二个问题，在正文里搜“基于范围的 for 循环”。代码例子没细看么？🤔","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576022802,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1364855,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d3/77/fb38ccf1.jpg","nickname":"玄兴梦影","note":"","ucode":"D9EDBBC61317E9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78805,"discussion_content":"看到了，期待下一讲","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576023895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329067,"user_name":"Geek_d89079","can_delete":false,"product_type":"c1","uid":2878862,"ip_address":"","ucode":"75177B6DB13CAA","user_header":"","comment_is_top":false,"comment_ctime":1641092562,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":1,"score":5,"product_id":100040501,"comment_content":"我可能学的是C-- ","like_count":7},{"had_liked":false,"id":340050,"user_name":"硕","can_delete":false,"product_type":"c1","uid":2540708,"ip_address":"","ucode":"1F68B408F4BBED","user_header":"https://static001.geekbang.org/account/avatar/00/26/c4/a4/20f44910.jpg","comment_is_top":false,"comment_ctime":1648555707,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"写得真巧妙。佩服佩服！","like_count":1},{"had_liked":false,"id":215035,"user_name":"易轻尘","can_delete":false,"product_type":"c1","uid":1136684,"ip_address":"","ucode":"0D0CB9D6D45A70","user_header":"https://static001.geekbang.org/account/avatar/00/11/58/2c/92c7ce3b.jpg","comment_is_top":false,"comment_ctime":1588894702,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100040501,"comment_content":"原来这就是高手写的c++吗","like_count":0}]}