{"id":615427,"title":"15｜定制运营拖拽组件：如何实现运营搭建页面的拖拽功能？","content":"<p>你好，我是杨文坚。</p><p>上节课，我们学习了单元测试，也收尾了基础组件库相关开发。从今天开始，我们会正式围绕着课程的最终实战项目——运营搭建平台，打造相关的Vue.js业务组件和业务功能。</p><p>运营搭建平台，核心是搭建功能，“核心业务”就是提供搭建页面的能力。那这节课，我们就围绕着这个搭建页面的“核心业务”来打造业务组件，搭建页面需要用到拖拽布局组件。</p><p>可能你会问，为什么要把拖拽组件划分成业务组件？拖拽功能也很基础，为什么不划分成基础组件呢？</p><p>这是因为，拖拽功能，虽然基础，但很难做到通用，不同场景下拖拽的需求效果是不一样的。比如，是实现布局弹性排序？还是让布局直接调整位置？还是把组件从一个布局容器拖到另外一个布局容器里？当然，不同的开发团队，组件规范定义有一定差异，不过，这些功能实现，跟业务需求特点息息相关，很难做到一个组件兼顾所有拖拽功能。</p><p>那如何搭建拖拽布局组件呢？我们开始今天的学习。</p><h2>为什么需要拖拽布局组件？</h2><p>搭建页面，原理就是通过配置数据，来驱动页面渲染对应内容，数据描述的是目标页面的布局情况，例如页面有多少个区块、每个区块里有多少个子区块，描述布局的数据也包含了每个区块里要渲染什么组件。</p><p>这就意味着，使用者只要能控制数据就行了。所以，实际上，即使没有拖拽布局组件，我们也是能实现运营搭建页面的基本操作功能。</p><!-- [[[read_end]]] --><p>但是，并不是所有项目的使用者都是前端开发程序员，也并不是所有项目的使用者都懂得搭建页面的数据格式、数据的规律和实现原理。</p><p><strong>我们的运营搭建平台，目的就是要让非开发人员能低成本地搭建网页，不需要投入前端程序员的开发时间。</strong>假设搭建页面直接配置数据是一个“解答题”，那么拖拽配置页面就是一个“选择题”。“解答题”是留给专业人员来做，例如前端开发程序员，“选择题”是给非专业人员使用，例如运营同事和产品同事。</p><p>因此，开发拖拽布局组件，其实就是要降低配置页面的难度，让非前端开发的人员能直接上手，使用这个配置页面的功能，用技术来解放生产力。</p><p>既然拖拽布局业务组件对运营搭建平台这么重要，如何实现呢？我们还是按老规矩，先实现一个最简单的功能案例，分析清楚原理，再来抽象逻辑，封装成组件。</p><h2>如何实现简单的拖拽布局功能？</h2><p>我们先从一个简单的拖拽布局功能学起。我主要用原生的JavaScript API方式来实现功能，不使用任何框架，带你掌握拖拽实现的技术原理，希望能“授你以渔”。</p><p>对于<strong>拖拽布局功能，常见的功能要求是要在一个限定范围的“容器”内，让指定的“子模块”可以拖拽移动，在拖拽过程中还需要重新对模块进行排位。</strong></p><p>具体实现可以分成五步：</p><ol>\n<li>定义父容器和子模块；</li>\n<li>监听子模块的拖拽开始事件；</li>\n<li>监听拖拽过程经过父容器里哪些子模块；</li>\n<li>计算和重新渲染拖拽过程的临时布局；</li>\n<li>监听拖拽结束事件，更新最终模块布局。</li>\n</ol><p>我们一步步分析相关的操作实现。</p><h3><strong>第一步定义父容器和子模块</strong></h3><p>这里“父容器”就是限定拖拽范围的DOM，“子模块”就是在父容器DOM里的指定排序的 children&nbsp; DOM，也就是子节点。在定义子模块的DOM时，我们还要加上draggable属性，让它能够实现鼠标拖拽的视觉效果。</p><p>这里要注意一点，这个draggable属性，仅仅是让DOM在鼠标拖拽时有视觉上的移动，当鼠标释放DOM时，DOM会自动复原，不能直接实现拖拽功能。</p><p>看具体实现的HTML代码：</p><pre><code class=\"language-xml\">&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"utf-8\" /&gt;\n  &lt;/head&gt;\n  &lt;style&gt;\n    .drag-layout {\n      display: block;\n      width: 400px;\n      margin: 0 auto;\n      box-sizing: border-box;\n      padding: 10px;\n      border: 1px solid #999999;\n    }\n    .drag-item {\n      height: 40px;\n      border: 1px solid #cccccc;\n      margin-bottom: 10px;\n      font-size: 20px;\n    }\n    .drag-item.active {\n      opacity: 0.4;\n    }\n  &lt;/style&gt;\n  &lt;body&gt;\n    &lt;div class=\"drag-layout\"&gt;\n      &lt;div draggable=\"true\" class=\"drag-item\" style=\"background: #00bcd4;\"&gt;\n        模块1\n      &lt;/div&gt;\n      &lt;div draggable=\"true\" class=\"drag-item\" style=\"background: #8bc34a;\"&gt;\n        模块2\n      &lt;/div&gt;\n      &lt;div draggable=\"true\" class=\"drag-item\" style=\"background: #ffeb3b;\"&gt;\n        模块3\n      &lt;/div&gt;\n      &lt;div draggable=\"true\" class=\"drag-item\" style=\"background: #ff5722;\"&gt;\n        模块4\n      &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;script type=\"module\" src=\"./drag-demo.js\"&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>效果图如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/c7/7d/c75565b32f488ff7782965d463dbfe7d.png?wh=1238x822\" alt=\"图片\"></p><h3><strong>第二步监听子模块的拖拽开始事件</strong></h3><p>具体的监听方式，是以父容器的DOM作为事件代理来监听。这里，就要用到DOM的原生事件监听API addEventListener，来监听dragstart事件。</p><p>拖拽子模块时，子模块的拖拽事件会通过“事件冒泡”的方式让父容器捕获，所以我们监听父容器，就能捕获到子模块的开始拖拽事件dragstart，并且监听这个事件。</p><p>这个时候，我们需要定义一个变量，来标记当前拖拽中的子模块原始位置，给后续拖拽布局重新排序时候计算用。我通过原生的DOM API写了一个方法，可以根据子模块DOM来计算定位到父容器DOM里的位置序号。</p><p>具体代码如下所示：</p><pre><code class=\"language-javascript\">const dragLayout = document.querySelector('.drag-layout');\n// 被拖拽时的子模块DOM所在序号\nlet activeIndex = -1;\n// 拖拽到某个子模块上口的序号\nlet dragToIndex = -1;\n// 上一次所有子模块顺序的DOM的列表\nlet prevItems = [];\n\n// 根据DOM来获取在父容器里的序号\nfunction getItemIndex(item) {\n  let elem = item;\n  let index = -1;\n  if (!elem || !elem.parentElement) {\n    return index;\n  }\n  index = 0;\n  elem = elem.previousElementSibling;\n  while (elem) {\n    index++;\n    elem = elem.previousElementSibling;\n  }\n  return index;\n}\n\n// 在父容器上监听 拖拽开始事件\ndragLayout.addEventListener('dragstart', (e) =&gt; {\n  const dom = e.target;\n  const isItem = dom.classList.contains('drag-item');\n  if (isItem) {\n    const itemDOMs = document.querySelectorAll('.drag-item');\n    prevItems = Array.from(itemDOMs);\n\n    const itemIndex = getItemIndex(dom);\n    activeIndex = itemIndex;\n    dom.classList.add('active');\n  }\n});\n</code></pre><h3><strong>第三步监听拖拽过程经过父容器里哪些子模块</strong></h3><p>这个需要监听父容器的dragover事件，基于拖拽事件，可以冒泡到父容器DOM来捕获，然后我们就可以通过dragover事件，来监听当前拖拽子组件的的鼠标位置，在哪个其它子模块的“上空”。</p><p>我们可以在事件里实时“捕获”鼠标拖拽到某个新位置下面的子模块DOM，然后通过上一步实现的查找子模块位置的方法，计算出拖拽过程中的新位置序号，这个序号也就是当前“被拖拽的子模块”可能被“释放”的新位置。</p><p>具体代码如下所示：</p><pre><code class=\"language-javascript\">// 监听拖拽过程中的事件，\n// 用来计算移动到某个子模块“上空”\ndragLayout.addEventListener('dragover', (e) =&gt; {\n  e.preventDefault();\n  const dom = e.target;\n  const isItem = dom.classList.contains('drag-item');\n  if (isItem) {\n    const overItemIndex = getItemIndex(dom);\n    dragToIndex = overItemIndex;\n    // 重新排序渲染子模块\n    resetItems();\n  }\n});\n</code></pre><h3><strong>第四步计算和重新渲染拖拽过程的临时布局</strong></h3><p>前面步骤中所有的子模块DOM，是在父容器DOM里并排显示的。当“被拖拽的子模块”经过“某个其他子模块”上空时，就可以做个临时重新排序渲染，“被拖拽的子模块”从原来位置抽出来，整个子模块布局就按顺序补位，把“被拖拽的子模块”插入经过的“某个其他子模块”的位置，达到重新排序的操作。</p><p>具体实现代码如下：</p><pre><code class=\"language-javascript\">// 根据拖拽的数据重新排序\nfunction resetItems() {\n  if (!prevItems[activeIndex]) {\n    return;\n  }\n  if (dragToIndex &gt;= 0 &amp;&amp; dragToIndex &lt; prevItems.length) {\n    const newList = prevItems.map((item) =&gt; item);\n    const [activeItem] = newList.splice(activeIndex, 1);\n    if (dragToIndex === 0) {\n      newList.unshift(activeItem);\n    } else {\n      newList.splice(dragToIndex, 0, activeItem);\n    }\n    Array.from(dragLayout.children).forEach((child) =&gt; {\n      dragLayout.removeChild(child);\n    });\n    newList.forEach((item) =&gt; {\n      dragLayout.appendChild(item);\n    });\n  }\n}\n</code></pre><p>代码中，我用了一个临时的子模块数组，缓存上一次未被修改的子模块排序数据，在拖拽dragover过程中，就根据上述算法来重新排序渲染。</p><p>我们已经完成拖拽布局的绝大部分功能，接下来就是收尾工作。</p><h3><strong>第五步监听拖拽结束事件，更新最终模块布局</strong></h3><p>这里，我们监听父容器DOM的dragend事件，捕获最终位置，然后通过第四步的位置布局方法重新渲染子模块DOM的顺序。具体代码实现如下：</p><pre><code class=\"language-javascript\">// 渲染结束，更新数据\ndragLayout.addEventListener('dragend', (e) =&gt; {\n  e.preventDefault();\n  prevItems.forEach((item) =&gt; {\n    item.classList.remove('active');\n  });\n  dragToIndex = -1;\n  activeIndex = -1;\n});\n</code></pre><p>最终的功能效果如动图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/6a/a5/6a40d6b7c1b9c94652d0f21yy7ddafa5.gif?wh=600x385\" alt=\"图片\"></p><p>这五步就是一个完整的拖拽布局的原生JavaScript API实现过程。</p><p>我们还可以改一下HTML代码里的CSS样式，让这个纵向的拖拽布局变成横向的拖拽布局功能：</p><pre><code class=\"language-css\">.drag-layout.horizontal {\n  flex-direction: row;\n  display: flex;\n}\n.drag-layout.horizontal .drag-item {\n  width: 100px;\n}\n</code></pre><p>最终的功能效果如动图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/66/62/661cfae39f146fcd24fec536fdcb3962.gif?wh=600x385\" alt=\"图片\"></p><p>现在，你应该知道原生JavaScript API如何实现一个简单的拖拽布局功能了吧，那么，把这个实现思路融入到Vue.js 3.x这个框架环境里，该怎么做呢？或者说，如果要用Vue.js 3.x来封装拖拽布局的业务组件，我们应该怎么做呢？</p><h2>如何用Vue3封装拖拽布局的业务组件？</h2><p>通过上面的简单实现过程，我们可以知道，拖拽布局操作核心就是在“父容器”里拖拽控制“子模块”，那么，在Vue.js中，我们就可以把“父容器”和“子模块”封装成两个独立的Vue.js组件来进行组合，实现拖拽功能。</p><p>基于上面的五步，通过Vue.js的组件封装思维，我们可以精简成三步来实现：</p><ul>\n<li>第一步，封装父容器组件；</li>\n<li>第二步，封装子容器组件；</li>\n<li>第三步，组合父容器和子容器。</li>\n</ul><p>来看看每一步的具体实现细节。</p><p><strong>第一步，封装父容器组件。</strong>这里主要的操作就是在父容器里直接监听dragstart、dragover和dragend事件。因为子容器会在父容器中使用，所以我们可以使用Vue3的API provide/inject，来实现父子组件里的轻量级数据通信。</p><p>具体实现，就是用provide在父容器定义好共享响应式数据，然后在子容器里用inject，来使用父容器定义的共享响应式数据。</p><p>父容器Vue.js 3.x组件代码的具体实现：</p><pre><code class=\"language-typescript\">&lt;template&gt;\n  &lt;div\n    :className=\"baseClassName\"\n    @dragstart=\"onDragStart\"\n    @dragover=\"onDragOver\"\n    @dragend=\"onDragEnd\"\n  &gt;\n    &lt;slot&gt;&lt;/slot&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup lang=\"ts\"&gt;\nimport { reactive, provide, toRaw } from 'vue';\nimport {\n  DRAG_CONTEXT_KEY,\n  getElementIndex,\n  getDraggingElement\n} from './common';\nimport { prefixName } from '../theme/index';\nimport type { DragContext } from './common';\nconst baseClassName = `${prefixName}-drag-layout`;\n\nconst emits = defineEmits&lt;{\n  (event: 'dragStart', e: { activeIndex: number; dragToIndex: number }): void;\n  (event: 'dragOver', e: { activeIndex: number; dragToIndex: number }): void;\n  (event: 'dragEnd', e: { activeIndex: number; dragToIndex: number }): void;\n}&gt;();\n\nconst dragContext = reactive&lt;DragContext&gt;({\n  activeIndex: -1,\n  dragToIndex: -1\n});\n\nprovide(DRAG_CONTEXT_KEY, dragContext);\n\nconst onDragStart = () =&gt; {\n  emits('dragStart', {\n    activeIndex: toRaw(dragContext.activeIndex),\n    dragToIndex: toRaw(dragContext.dragToIndex)\n  });\n};\n\nconst onDragOver = (e: DragEvent) =&gt; {\n  e.preventDefault();\n  const target: HTMLElement | null = getDraggingElement(\n    e?.target as HTMLElement\n  );\n  const dragToIndex = getElementIndex(target);\n  dragContext.dragToIndex = dragToIndex;\n  emits('dragOver', {\n    activeIndex: toRaw(dragContext.activeIndex),\n    dragToIndex: toRaw(dragContext.dragToIndex)\n  });\n};\n\nconst onDragEnd = () =&gt; {\n  dragContext.activeIndex = -1;\n  dragContext.dragToIndex = -1;\n  emits('dragEnd', {\n    activeIndex: toRaw(dragContext.activeIndex),\n    dragToIndex: toRaw(dragContext.dragToIndex)\n  });\n};\n&lt;/script&gt;\n\n</code></pre><p>完整代码在源码文件 packages/business/src/drag/drag-layout.vue 里。</p><p><strong>第二步，封装子容器组件。</strong></p><p>我们直接注册监听拖拽事件，同时，触发事件时来跟父容器进行数据通信。也就是说，当子容器触发dragstart事件时，通过inject拿到共享的响应式数据，来传递拖拽选中的组件序号位置。具体代码实现如下所示：</p><pre><code class=\"language-xml\">&lt;template&gt;\n  &lt;div\n    ref=\"domItem\"\n    :className=\"baseClassName\"\n    draggable=\"true\"\n    data-drag-item=\"yes\"\n    @dragstart=\"onDragItem\"\n  &gt;\n    &lt;slot /&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup lang=\"ts\"&gt;\nimport { ref, inject } from 'vue';\nimport { DRAG_CONTEXT_KEY, getElementIndex } from './common';\nimport { prefixName } from '../theme/index';\nimport type { DragContext } from './common';\nconst baseClassName = `${prefixName}-drag-item`;\n\nconst domItem = ref&lt;HTMLDivElement&gt;();\nconst dragContext: DragContext | undefined =\n  inject&lt;DragContext&gt;(DRAG_CONTEXT_KEY);\n\nconst onDragItem = (e: DragEvent) =&gt; {\n  e.stopPropagation();\n  const index = getElementIndex(domItem?.value || null);\n  if (dragContext &amp;&amp; dragContext?.activeIndex &gt;= -1) {\n    dragContext.activeIndex = index;\n  }\n};\n&lt;/script&gt;\n\n</code></pre><p>完整代码在源码文件 packages/business/src/drag/drag-item.vue 里。</p><p><strong>第三步，组合父容器和子容器。</strong></p><p>这是最重要的，我们要将子容器和父容器组件进行组合，同时要处理子容器里可以用插槽来实现自定义拖拽的内容。所以，这里需要一个Map，来注册有哪些自定义组件要进行拖拽，然后再加一个数组，来描述拖拽的初始位置。</p><p>最后我用了Vue.js的 <code>&lt;component&gt;</code> 组件来实现动态组件渲染，并实现了自定义渲染拖拽内容。具体代码如下所示：</p><pre><code class=\"language-xml\">&lt;template&gt;\n  &lt;div :class=\"baseClassName\"&gt;\n    &lt;DragLayout @dragOver=\"onDragOver\" @dragEnd=\"onDragEnd\"&gt;\n      &lt;DragItem v-for=\"(item, index) in viewData.list\" :key=\"index\"&gt;\n        &lt;div&gt;{{ item.name }}&lt;/div&gt;\n        &lt;component\n          v-if=\"item?.componentName\"\n          :is=\"componentMap?.[item.componentName]\"\n        &gt;&lt;/component&gt;\n      &lt;/DragItem&gt;\n    &lt;/DragLayout&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup lang=\"ts\"&gt;\nimport { reactive, toRaw } from 'vue';\nimport DragLayout from './drag-layout.vue';\nimport DragItem from './drag-item.vue';\nimport { prefixName } from '../theme/index';\nimport type { Component } from 'vue';\nimport type { DragContext } from './common';\nconst baseClassName = `${prefixName}-drag`;\n\nconst props = defineProps&lt;{\n  componentMap: { [name: string]: Component };\n  layoutList: { name: string; componentName: string }[];\n}&gt;();\n\nconst emits = defineEmits&lt;{\n  (\n    event: 'change',\n    e: { layoutList: { name: string; componentName: string }[] }\n  ): void;\n}&gt;();\n\nconst componentMap = toRaw(props.componentMap);\nconst prevContext: DragContext = {\n  activeIndex: -1,\n  dragToIndex: -1\n};\n\n// TODO\nconst clone = (data: unknown) =&gt; {\n  return JSON.parse(JSON.stringify(data));\n};\n\nlet layoutList: { name: string; componentName: string }[] = toRaw(\n  props.layoutList\n);\n\nconst viewData = reactive&lt;{\n  list: { name: string; componentName: string }[];\n}&gt;({\n  list: clone(layoutList)\n});\n\nfunction resetLayoutList(context: DragContext) {\n  const { activeIndex, dragToIndex } = context;\n  const tempList: { name: string; componentName: string }[] = clone(layoutList);\n  if (\n    prevContext.activeIndex === activeIndex &amp;&amp;\n    prevContext.dragToIndex === dragToIndex\n  ) {\n    return;\n  }\n\n  if (activeIndex &gt;= 0 &amp;&amp; dragToIndex &gt;= 0) {\n    const [target] = tempList.splice(activeIndex, 1);\n    if (dragToIndex === 0) {\n      tempList.unshift(target);\n    } else if (dragToIndex &gt;= tempList.length) {\n      tempList.push(target);\n    } else {\n      tempList.splice(dragToIndex, 0, target);\n    }\n    viewData.list = tempList;\n  }\n\n  prevContext.activeIndex = activeIndex;\n  prevContext.dragToIndex = dragToIndex;\n}\n\nconst onDragOver = (ctx: DragContext) =&gt; {\n  resetLayoutList(ctx);\n};\n\nconst onDragEnd = () =&gt; {\n  layoutList = toRaw(viewData.list);\n  emits('change', { layoutList });\n};\n&lt;/script&gt;\n\n</code></pre><p>完整代码在源码文件 packages/business/src/drag/drag.vue 里。</p><p>当我们基于Vue3实现了拖拽功能组件代码后，可以这么使用：</p><pre><code class=\"language-xml\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;Drag\n      :componentMap=\"componentMap\"\n      :layoutList=\"layoutList\"\n      @change=\"onChange\"\n    &gt;&lt;/Drag&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup lang=\"ts\"&gt;\nimport { Drag } from '../src/index';\nimport Mod1 from './modules/mod-1.vue';\nimport Mod2 from './modules/mod-2.vue';\nimport Mod3 from './modules/mod-3.vue';\n\nconst componentMap = {\n  Mod1: Mod1,\n  Mod2: Mod2,\n  Mod3: Mod3\n};\n\nconst layoutList = [\n  {\n    name: '组件001',\n    componentName: 'Mod1'\n  },\n  {\n    name: '组件002',\n    componentName: 'Mod2'\n  },\n  {\n    name: '组件003',\n    componentName: 'Mod3'\n  }\n];\n\nconst onChange = (e: unknown) =&gt; {\n  console.log('onChange ===', e);\n};\n&lt;/script&gt;\n\n</code></pre><p>具体效果如图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/23/1c/23d5b544b2866bbb0dd5e2291e643e1c.gif?wh=600x360\" alt=\"图片\"></p><p>现在，我们基于Vue.js 3.x正式实现了拖拽布局组件。</p><h2>如何优雅扩展拖拽布局组件的业务能力？</h2><p>在实际的业务项目中，业务方可能会随时随地修改功能的业务需求，所以，做这类拖拽组件，我们可能会有随时快速定制的要求，例如需要拖拽布局组件可以自定义横向和纵向的布局操作等。那如何优雅扩展拖拽布局组件的业务能力呢？</p><p>我们可以基于上述封装Vue3组件，对组件的Props进行调整和修改。</p><p>我们可以添加一个horizontal的Prop，来控制整个拖拽功能的布局方向CSS样式，具体就是根据这个horizontal变量来判断是否要加上对应的className。而且，还要改造一下父容器布局的CSS样式，也就是 drag-layout.vue的代码。</p><p>修改如下所示：</p><pre><code class=\"language-xml\">&lt;template&gt;\n  &lt;div\n    :class=\"{ [baseClassName]: true, ['is-horizontal']: props.horizontal }\"\n    @dragstart=\"onDragStart\"\n    @dragover=\"onDragOver\"\n    @dragend=\"onDragEnd\"\n  &gt;\n    &lt;slot&gt;&lt;/slot&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup lang=\"ts\"&gt;\n// 省略原来其他代码 ...\n\n// 修改代码\nconst props = defineProps&lt;{ horizontal?: boolean }&gt;();\n \n// 省略原来其他代码 ...\n&lt;/script&gt;\n\n</code></pre><p>添加布局样式：</p><pre><code class=\"language-less\">\n.@{prefix-name}-drag-layout {\n  // 省略原来其他代码 ...\n\n  &amp;.is-horizontal {\n    flex-direction: row;\n  }\n}\n</code></pre><p>实现效果如动图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/14/b1/145082b185944a770156f5aec66559b1.gif?wh=599x268\" alt=\"图片\"></p><p>总之，如果后续业务方要对业务组件的功能进行修改或者定制，你可以封装成对应的Vue3组件的Props API进行控制，尽可能用最小的代码修改量，对组件的功能进行调整。</p><h2>总结</h2><p>现在，你应该对拖拽布局组件的实现有清晰的认识了。拖拽布局组件的功能很难界定，业务需求也变化多端，所以我们把它定位成业务组件。</p><p>基于原生JavaScript API来实现拖拽布局功能，核心就是要定义“父容器”来承载和限制拖拽的范围，定义“子容器”来控制拖拽操作。父、子容器拖拽交互和子容器重新排序，主要是要记录每次“被拖拽”和“拖拽到”两个容器位置的序号数据，再通过这两个数据，换算出重新排序的位置，最后达到排序重新渲染。</p><p>基于原生JavaScript API实现的步骤，我们再通过Vue.js 3.x的API重新实现了一遍。如果你真的充分理解了原生JavaScript API和Vue.js 3.x实现步骤，即使换成React.js，你也完全可以实现出类似的拖拽功能，这也是我前面说的“授人以渔”。</p><p>最后，业务需求都是千变万化，在实现业务组件时候，你要时刻做好用优雅的改造方式对原有组件做功能调整和改造的准备。</p><h2>思考题</h2><p>我们实现了拖拽布局组件，只是通过拖拽调整了布局，那么，如果要从一个布局拖拽到另外一个布局里，应该怎么实现这个“拖放”布局组件呢？</p><p>期待你的留言，和我和其他同学一起讨论。下节课见。</p><h3><a href=\"https://github.com/FE-star/vue3-course/tree/main/chapter/15\">完整的代码在这里</a></h3>","comments":[{"had_liked":false,"id":366928,"user_name":"x","can_delete":false,"product_type":"c1","uid":1472233,"ip_address":"浙江","ucode":"75FA829EA820AB","user_header":"https://static001.geekbang.org/account/avatar/00/16/76/e9/73ed6cc1.jpg","comment_is_top":false,"comment_ctime":1674623174,"is_pvip":false,"replies":[{"id":134962,"content":"您好，你提到的“方式是否走歪”取决于功能是否实用？是否真的提高效率？这个没有绝对的正确答案，因为不同业务场景特点不一样，需要多次尝试才能找到“实用”的方案。","user_name":"作者回复","user_name_real":"编辑","uid":3217031,"ctime":1678526398,"ip_address":"浙江","comment_id":366928,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311101,"comment_content":"老师您好，我想弄个简单的东西，让运营自己整一些简单的页面。比如我定义一个p标签的对象，pobj={tag:&#39;p&#39;,attrs:{}}这种格式。然后运营拖特定组件到固定地方后在一个全局json中添加这个对象，并且在这个对象中添加一个全局唯一的id。然后运营在页面中点击我通过一个深度递归函数生成的这个p,就可以通过id找到这个对象从而给这个元素修改宽高等属性。请老师指教一下。。我感觉我现在这样写走歪了。。","like_count":0,"discussions":[{"author":{"id":3217031,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/TZnA0PlXExlp9byxOxCeOG6ia0ykwfpxqAq2vslTzL1z5ibTBsgf1nYx0bUXgrOTnSOnmdXQZZibYx9tRSPHFjibPQ/132","nickname":"文坚老师","note":"","ucode":"4E0C838B2A3725","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608582,"discussion_content":"您好，你提到的“方式是否走歪”取决于功能是否实用？是否真的提高效率？这个没有绝对的正确答案，因为不同业务场景特点不一样，需要多次尝试才能找到“实用”的方案。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678526398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365218,"user_name":"定宇","can_delete":false,"product_type":"c1","uid":1354764,"ip_address":"中国台湾","ucode":"4553609D96BD10","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/1ornnGqSaTxRdbxhUHibeygI3PLtDXAH5GRhRJ286Sbtz7YyGFUHobN2EgiaLhtWn2dLReBRBU1n577DWqrsaBBw/132","comment_is_top":false,"comment_ctime":1672280274,"is_pvip":false,"replies":[{"id":134978,"content":"您好，本课的源码案例就有包括dts文件的生成。可以参考第10讲的源码案例 https:&#47;&#47;github.com&#47;FE-star&#47;vue3-course&#47;blob&#47;main&#47;chapter&#47;10&#47;scripts&#47;build-dts.ts \n ","user_name":"作者回复","user_name_real":"编辑","uid":3217031,"ctime":1678612909,"ip_address":"浙江","comment_id":365218,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100311101,"comment_content":"老师您好\n想问一下后续会有讲到打包Vue组件到npm上+index.d.ts的内容吗\n最近刚好遇到类似的需求\n但研究了两天没有什么太好的解法\n尤其简单打包然后npm install后没办法有ts提示","like_count":0,"discussions":[{"author":{"id":3217031,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/TZnA0PlXExlp9byxOxCeOG6ia0ykwfpxqAq2vslTzL1z5ibTBsgf1nYx0bUXgrOTnSOnmdXQZZibYx9tRSPHFjibPQ/132","nickname":"文坚老师","note":"","ucode":"4E0C838B2A3725","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608695,"discussion_content":"您好，本课的源码案例就有包括dts文件的生成。可以参考第10讲的源码案例 https://github.com/FE-star/vue3-course/blob/main/chapter/10/scripts/build-dts.ts \n ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678612909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1230852,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c8/04/fed4c1ad.jpg","nickname":"若川","note":"","ucode":"B8C3DD4B38CC6F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598053,"discussion_content":"我觉得可以参考下 vant 组件库的源码。\nhttps://github.com/vant-ui/vant\n\n我之前写过 vant 源码系列文章 https://juejin.cn/column/7140264842954276871，可以参考学会看 vant 的源码。不过没写你说的 index.d.ts 内容。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672480278,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1507277,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/rUqhSN2OVg5aHw10Hxib61nGv1SXxD6zowFl27oSm9Y6g8grRpTxCxwk7qg14a1TtmpzMTM2y810MnibBhwn75Mg/132","nickname":"初烬","note":"","ucode":"7ED4A301A7CC11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1230852,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c8/04/fed4c1ad.jpg","nickname":"若川","note":"","ucode":"B8C3DD4B38CC6F","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":598194,"discussion_content":"抓到大佬一只","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672661274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":598053,"ip_address":"陕西","group_id":0},"score":598194,"extra":""}]}]},{"had_liked":false,"id":394319,"user_name":"ifelse","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"浙江","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1726478164,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":3,"score":2,"product_id":100311101,"comment_content":"学习打卡","like_count":0},{"had_liked":false,"id":391502,"user_name":"Geek_12e8fd","can_delete":false,"product_type":"c1","uid":2728813,"ip_address":"浙江","ucode":"4BC4A879CB5AFE","user_header":"","comment_is_top":false,"comment_ctime":1718349294,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100311101,"comment_content":"DropTarget.vue（放置目标）：\n\nvue\n&lt;template&gt;  \n  &lt;div  \n    class=&quot;drop-target&quot;  \n    @dragover.prevent  \n    @drop=&quot;dropItem&quot;  \n  &gt;  \n    &lt;!-- 容器内容 --&gt;  \n  &lt;&#47;div&gt;  \n&lt;&#47;template&gt;  \n  \n&lt;script&gt;  \nexport default {  \n  methods: {  \n    dropItem(event) {  \n      &#47;&#47; 阻止默认行为  \n      event.preventDefault();  \n      &#47;&#47; 从拖拽数据中获取被拖拽项的 id  \n      const itemId = event.dataTransfer.getData(&#39;text&#47;plain&#39;);  \n      &#47;&#47; 调用父组件或状态管理逻辑来移动项  \n      this.$emit(&#39;itemDropped&#39;, itemId);  \n    }  \n  },  \n  &#47;&#47; ... 其他选项 ...  \n};  \n&lt;&#47;script&gt;\n在父组件或状态管理逻辑中，你需要监听 itemDropped 事件，并根据需要更新数据模型或执行其他逻辑来移动项。这通常涉及从源容器数组中移除项，并将其添加到目标容器数组中。然后，你可以使用 Vue 的响应性系统来自动更新 UI。\n\n请注意，这只是一个简化的示例，实际应用中可能需要处理更复杂的逻辑和边界情况。此外，还可以考虑使用第三方库（如 Vue.Draggable）来简化拖拽和放置功能的实现。","like_count":0},{"had_liked":false,"id":391501,"user_name":"Geek_12e8fd","can_delete":false,"product_type":"c1","uid":2728813,"ip_address":"浙江","ucode":"4BC4A879CB5AFE","user_header":"","comment_is_top":false,"comment_ctime":1718349288,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100311101,"comment_content":"实现从一个布局拖拽到另外一个布局里的“拖放”布局组件，需要处理跨容器的拖拽逻辑。这通常涉及几个关键步骤：\n\n监听拖拽事件：\n在被拖拽的元素上监听 dragstart 事件，设置拖拽的数据（通常使用 setData 方法）。\n在目标容器上监听 dragover 事件，并阻止其默认行为（使用 event.preventDefault()），以允许放置。\n在目标容器上监听 drop 事件，处理放置逻辑。\n设置允许放置：\n为了使元素可以被放置到目标容器内，目标容器需要设置 dropzone 属性或者通过 CSS 设置 user-select: none; 和合适的指针样式。\n处理放置逻辑：\n在 drop 事件处理函数中，从拖拽数据中获取被拖拽元素的信息。\n根据需要从源容器移除被拖拽的元素，并添加到目标容器。\n更新任何相关的数据模型或状态，以反映新的布局。\n处理边界情况：\n确保拖拽操作不会超出浏览器窗口或容器的边界。\n处理被拖拽元素与容器内其他元素的碰撞检测（如果需要）。\n反馈和动画：\n提供视觉反馈，如高亮显示目标容器或预览放置位置。\n使用 CSS 动画或过渡来平滑地移动被拖拽的元素。\n错误处理和兼容性：\n处理不同浏览器对 HTML5 拖拽 API 的支持差异。\n添加错误处理逻辑，以应对拖拽过程中可能出现的任何问题。\n以下是一个简化的代码示例，展示了如何在 Vue.js 组件中实现跨容器的拖拽放置功能：\n\nDraggableItem.vue（可拖拽的项）：\n\nvue\n&lt;template&gt;  \n  &lt;div  \n    class=&quot;draggable-item&quot;  \n    draggable=&quot;true&quot;  \n    @dragstart=&quot;dragStart&quot;  \n  &gt;  \n    &lt;!-- 内容 --&gt;  \n  &lt;&#47;div&gt;  \n&lt;&#47;template&gt;  \n  \n&lt;script&gt;  \nexport default {  \n  methods: {  \n    dragStart(event) {  \n      &#47;&#47; 设置拖拽数据  \n      event.dataTransfer.setData(&#39;text&#47;plain&#39;, this.itemId); &#47;&#47; 假设每个项都有一个唯一的 itemId  \n    }  \n  },  \n  &#47;&#47; ... 其他选项 ...  \n};  \n&lt;&#47;script&gt;","like_count":0},{"had_liked":false,"id":386428,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"江苏","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1704791428,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100311101,"comment_content":"提一个小白问题，在执行第 15 课的源码的时候，提示如下错误：\n\nThe following dependencies are imported but could not be resolved:\n\n  @my&#47;components&#47;css&#47;index.css (imported by ..&#47;vue3-course&#47;chapter&#47;15&#47;packages&#47;business&#47;main.ts)\n\nAre they installed?\n\n应该是我引用的那个 css 文件没有正确的加载，是少了什么命令操作么？","like_count":0}]}