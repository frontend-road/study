{"id":528660,"title":"04｜创建容器镜像：如何编写正确、高效的Dockerfile","content":"<p>你好，我是Chrono。</p><p>上一次的课程里我们一起学习了容器化的应用，也就是被打包成镜像的应用程序，然后再用各种Docker命令来运行、管理它们。</p><p>那么这又会带来一个疑问：这些镜像是怎么创建出来的？我们能不能够制作属于自己的镜像呢？</p><p>所以今天，我就来讲解镜像的内部机制，还有高效、正确地编写Dockerfile制作容器镜像的方法。</p><h2>镜像的内部机制是什么</h2><p>现在你应该知道，镜像就是一个打包文件，里面包含了应用程序还有它运行所依赖的环境，例如文件系统、环境变量、配置参数等等。</p><p>环境变量、配置参数这些东西还是比较简单的，随便用一个manifest清单就可以管理，真正麻烦的是文件系统。为了保证容器运行环境的一致性，镜像必须把应用程序所在操作系统的根目录，也就是rootfs，都包含进来。</p><p>虽然这些文件里不包含系统内核（因为容器共享了宿主机的内核），但如果每个镜像都重复做这样的打包操作，仍然会导致大量的冗余。可以想象，如果有一千个镜像，都基于Ubuntu系统打包，那么这些镜像里就会重复一千次Ubuntu根目录，对磁盘存储、网络传输都是很大的浪费。</p><p>很自然的，我们就会想到，应该把重复的部分抽取出来，只存放一份Ubuntu根目录文件，然后让这一千个镜像以某种方式共享这部分数据。</p><!-- [[[read_end]]] --><p>这个思路，也正是容器镜像的一个重大创新点：分层，术语叫“<strong>Layer</strong>”。</p><p>容器镜像内部并不是一个平坦的结构，而是由许多的镜像层组成的，每层都是只读不可修改的一组文件，相同的层可以在镜像之间共享，然后多个层像搭积木一样堆叠起来，再使用一种叫“<strong>Union FS联合文件系统</strong>”的技术把它们合并在一起，就形成了容器最终看到的文件系统（<a href=\"https://linoxide.com/wp-content/uploads/2015/03/docker-filesystems-busyboxrw.png\">图片来源</a>）。</p><p><img src=\"https://static001.geekbang.org/resource/image/c7/3f/c750a7795ff4787c6639dd42bf0a473f.png?wh=800x600\" alt=\"图片\"></p><p>我来拿大家都熟悉的千层糕做一个形象的比喻吧。</p><p>千层糕也是由很多层叠加在一起的，从最上面可以看到每层里面镶嵌的葡萄干、核桃、杏仁、青丝等，每一层糕就相当于一个Layer，干果就好比是Layer里的各个文件。但如果某两层的同一个位置都有干果，也就是有文件同名，那么我们就只能看到上层的文件，而下层的就被屏蔽了。</p><p>你可以用命令 <code>docker inspect</code> 来查看镜像的分层信息，比如nginx:alpine镜像：</p><pre><code class=\"language-plain\">docker inspect nginx:alpine\n</code></pre><p>它的分层信息在“RootFS”部分：<br>\n<img src=\"https://static001.geekbang.org/resource/image/5y/b7/5yybd821a12ec1323f6ea8bb5a5c4ab7.png?wh=1920x592\" alt=\"图片\"></p><p>通过这张截图就可以看到，nginx:alpine镜像里一共有6个Layer。</p><p>相信你现在也就明白，之前在使用 <code>docker pull</code>、<code>docker rmi</code> 等命令操作镜像的时候，那些“奇怪”的输出信息是什么了，其实就是镜像里的各个Layer。Docker会检查是否有重复的层，如果本地已经存在就不会重复下载，如果层被其他镜像共享就不会删除，这样就可以节约磁盘和网络成本。</p><h2>Dockerfile是什么</h2><p>知道了容器镜像的内部结构和基本原理，我们就可以来学习如何自己动手制作容器镜像了，也就是自己打包应用。</p><p>在之前我们讲容器的时候，曾经说过容器就是“小板房”，镜像就是“样板间”。那么，要造出这个“样板间”，就必然要有一个“施工图纸”，由它来规定如何建造地基、铺设水电、开窗搭门等动作。这个“施工图纸”就是“<strong>Dockerfile</strong>”。</p><p>比起容器、镜像来说，Dockerfile非常普通，它就是一个纯文本，里面记录了一系列的构建指令，比如选择基础镜像、拷贝文件、运行脚本等等，每个指令都会生成一个Layer，而Docker顺序执行这个文件里的所有步骤，最后就会创建出一个新的镜像出来。</p><p>我们来看一个最简单的Dockerfile实例：</p><pre><code class=\"language-plain\"># Dockerfile.busybox\nFROM busybox                  # 选择基础镜像\nCMD echo \"hello world\"        # 启动容器时默认运行的命令\n</code></pre><p>这个文件里只有两条指令。</p><p>第一条指令是 <code>FROM</code>，所有的Dockerfile都要从它开始，表示选择构建使用的基础镜像，相当于“打地基”，这里我们使用的是busybox。</p><p>第二条指令是 <code>CMD</code>，它指定 <code>docker run</code> 启动容器时默认运行的命令，这里我们使用了echo命令，输出“hello world”字符串。</p><p>现在有了Dockerfile这张“施工图纸”，我们就可以请出“施工队”了，用 <code>docker build</code> 命令来创建出镜像：</p><pre><code class=\"language-plain\">docker build -f Dockerfile.busybox .\n\nSending build context to Docker daemon&nbsp; &nbsp;7.68kB\nStep 1/2 : FROM busybox\n&nbsp;---&gt; d38589532d97\nStep 2/2 : CMD echo \"hello world\"\n&nbsp;---&gt; Running in c5a762edd1c8\nRemoving intermediate container c5a762edd1c8\n&nbsp;---&gt; b61882f42db7\nSuccessfully built b61882f42db7\n</code></pre><p>你需要特别注意命令的格式，用 <code>-f</code> 参数指定Dockerfile文件名，后面必须跟一个文件路径，叫做“<strong>构建上下文</strong>”（build’s context），这里只是一个简单的点号，表示当前路径的意思。</p><p>接下来，你就会看到Docker会逐行地读取并执行Dockerfile里的指令，依次创建镜像层，再生成完整的镜像。</p><p>新的镜像暂时还没有名字（用 <code>docker images</code> 会看到是 <code>&lt;none&gt;</code>），但我们可以直接使用“IMAGE ID”来查看或者运行：</p><pre><code class=\"language-plain\">docker inspect b61\ndocker run b61\n</code></pre><h2>怎样编写正确、高效的Dockerfile</h2><p>大概了解了Dockerfile之后，我再来讲讲编写Dockerfile的一些常用指令和最佳实践，帮你在今后的工作中把它写好、用好。</p><p>首先因为构建镜像的第一条指令必须是 <code>FROM</code>，所以基础镜像的选择非常关键。如果关注的是镜像的安全和大小，那么一般会选择Alpine；如果关注的是应用的运行稳定性，那么可能会选择Ubuntu、Debian、CentOS。</p><pre><code class=\"language-plain\">FROM alpine:3.15                # 选择Alpine镜像\nFROM ubuntu:bionic              # 选择Ubuntu镜像\n</code></pre><p>我们在本机上开发测试时会产生一些源码、配置等文件，需要打包进镜像里，这时可以使用 <code>COPY</code> 命令，它的用法和Linux的cp差不多，不过拷贝的源文件必须是“<strong>构建上下文</strong>”路径里的，不能随意指定文件。也就是说，如果要从本机向镜像拷贝文件，就必须把这些文件放到一个专门的目录，然后在 <code>docker build</code> 里指定“构建上下文”到这个目录才行。</p><p>这里有两个 <code>COPY</code> 命令示例，你可以看一下：</p><pre><code class=\"language-plain\">COPY ./a.txt  /tmp/a.txt    # 把构建上下文里的a.txt拷贝到镜像的/tmp目录\nCOPY /etc/hosts  /tmp       # 错误！不能使用构建上下文之外的文件\n</code></pre><p>接下来要说的就是Dockerfile里最重要的一个指令 <code>RUN</code> ，它可以执行任意的Shell命令，比如更新系统、安装应用、下载文件、创建目录、编译程序等等，实现任意的镜像构建步骤，非常灵活。</p><p><code>RUN</code> 通常会是Dockerfile里最复杂的指令，会包含很多的Shell命令，但Dockerfile里一条指令只能是一行，所以有的 <code>RUN</code> 指令会在每行的末尾使用续行符 <code>\\</code>，命令之间也会用 <code>&amp;&amp;</code> 来连接，这样保证在逻辑上是一行，就像下面这样：</p><pre><code class=\"language-plain\">RUN apt-get update \\\n&nbsp; &nbsp; &amp;&amp; apt-get install -y \\\n&nbsp; &nbsp; &nbsp; &nbsp; build-essential \\\n&nbsp; &nbsp; &nbsp; &nbsp; curl \\\n&nbsp; &nbsp; &nbsp; &nbsp; make \\\n&nbsp; &nbsp; &nbsp; &nbsp; unzip \\\n&nbsp; &nbsp; &amp;&amp; cd /tmp \\\n&nbsp; &nbsp; &amp;&amp; curl -fSL xxx.tar.gz -o xxx.tar.gz\\\n&nbsp; &nbsp; &amp;&amp; tar xzf xxx.tar.gz \\\n&nbsp; &nbsp; &amp;&amp; cd xxx \\\n&nbsp; &nbsp; &amp;&amp; ./config \\\n&nbsp; &nbsp; &amp;&amp; make \\\n    &amp;&amp; make clean\n</code></pre><p>有的时候在Dockerfile里写这种超长的 <code>RUN</code> 指令很不美观，而且一旦写错了，每次调试都要重新构建也很麻烦，所以你可以采用一种变通的技巧：<strong>把这些Shell命令集中到一个脚本文件里，用 <code>COPY</code> 命令拷贝进去再用 <code>RUN</code> 来执行</strong>：</p><pre><code class=\"language-plain\">COPY setup.sh  /tmp/                # 拷贝脚本到/tmp目录\n\nRUN cd /tmp &amp;&amp; chmod +x setup.sh \\  # 添加执行权限\n    &amp;&amp; ./setup.sh &amp;&amp; rm setup.sh    # 运行脚本然后再删除\n</code></pre><p><code>RUN</code> 指令实际上就是Shell编程，如果你对它有所了解，就应该知道它有变量的概念，可以实现参数化运行，这在Dockerfile里也可以做到，需要使用两个指令 <code>ARG</code> 和<code> ENV</code>。</p><p><strong>它们区别在于 <code>ARG</code> 创建的变量只在镜像构建过程中可见，容器运行时不可见，而 <code>ENV</code> 创建的变量不仅能够在构建镜像的过程中使用，在容器运行时也能够以环境变量的形式被应用程序使用。</strong></p><p>下面是一个简单的例子，使用 <code>ARG</code> 定义了基础镜像的名字（可以用在“FROM”指令里），使用 <code>ENV</code> 定义了两个环境变量：</p><pre><code class=\"language-plain\">ARG IMAGE_BASE=\"node\"\nARG IMAGE_TAG=\"alpine\"\n\nENV PATH=$PATH:/tmp\nENV DEBUG=OFF\n</code></pre><p>还有一个重要的指令是 <code>EXPOSE</code>，它用来声明容器对外服务的端口号，对现在基于Node.js、Tomcat、Nginx、Go等开发的微服务系统来说非常有用：</p><pre><code class=\"language-plain\">EXPOSE 443           # 默认是tcp协议\nEXPOSE 53/udp        # 可以指定udp协议\n</code></pre><p>讲了这些Dockerfile指令之后，我还要特别强调一下，因为每个指令都会生成一个镜像层，所以Dockerfile里最好不要滥用指令，尽量精简合并，否则太多的层会导致镜像臃肿不堪。</p><h2>docker build是怎么工作的</h2><p>Dockerfile必须要经过 <code>docker build</code> 才能生效，所以我们再来看看 <code>docker build</code> 的详细用法。</p><p>刚才在构建镜像的时候，你是否对“构建上下文”这个词感到有些困惑呢？它到底是什么含义呢？</p><p>我觉得用Docker的官方架构图来理解会比较清楚（注意图中与“docker build”关联的虚线）。</p><p>因为命令行“docker”是一个简单的客户端，真正的镜像构建工作是由服务器端的“Docker daemon”来完成的，所以“docker”客户端就只能把“构建上下文”目录打包上传（显示信息 <code>Sending build context to Docker daemon</code> ），这样服务器才能够获取本地的这些文件。</p><p><img src=\"https://static001.geekbang.org/resource/image/c8/fe/c8116066bdbf295a7c9fc25b87755dfe.jpg?wh=1920x1048\" alt=\"图片\"></p><p>明白了这一点，你就会知道，“构建上下文”其实与Dockerfile并没有直接的关系，它其实指定了要打包进镜像的一些依赖文件。而 <code>COPY</code> 命令也只能使用基于“构建上下文”的相对路径，因为“Docker daemon”看不到本地环境，只能看到打包上传的那些文件。</p><p>但这个机制也会导致一些麻烦，如果目录里有的文件（例如readme/.git/.svn等）不需要拷贝进镜像，docker也会一股脑地打包上传，效率很低。</p><p>为了避免这种问题，你可以在“构建上下文”目录里再建立一个 <code>.dockerignore</code> 文件，语法与 <code>.gitignore</code> 类似，排除那些不需要的文件。</p><p>下面是一个简单的示例，表示不打包上传后缀是“swp”“sh”的文件：</p><pre><code class=\"language-plain\"># docker ignore\n*.swp\n*.sh\n</code></pre><p>另外关于Dockerfile，一般应该在命令行里使用 <code>-f</code> 来显式指定。但如果省略这个参数，<code>docker build</code> 就会在当前目录下找名字是 <code>Dockerfile</code> 的文件。所以，如果只有一个构建目标的话，文件直接叫“Dockerfile”是最省事的。</p><p>现在我们使用 <code>docker build</code> 应该就没什么难点了，不过构建出来的镜像只有“IMAGE ID”没有名字，不是很方便。</p><p>为此你可以加上一个 <code>-t</code> 参数，也就是指定镜像的标签（tag），这样Docker就会在构建完成后自动给镜像添加名字。当然，名字必须要符合上节课里的命名规范，用 <code>:</code> 分隔名字和标签，如果不提供标签默认就是“latest”。</p><h2>小结</h2><p>好了，今天我们一起学习了容器镜像的内部结构，重点理解<strong>容器镜像是由多个只读的Layer构成的，同一个Layer可以被不同的镜像共享</strong>，减少了存储和传输的成本。</p><p>如何编写Dockerfile内容稍微多一点，我再简单做个小结：</p><ol>\n<li>创建镜像需要编写Dockerfile，写清楚创建镜像的步骤，每个指令都会生成一个Layer。</li>\n<li>Dockerfile里，第一个指令必须是 <code>FROM</code>，用来选择基础镜像，常用的有Alpine、Ubuntu等。其他常用的指令有：<code>COPY</code>、<code>RUN</code>、<code>EXPOSE</code>，分别是拷贝文件，运行Shell命令，声明服务端口号。</li>\n<li><code>docker build</code> 需要用 <code>-f</code> 来指定Dockerfile，如果不指定就使用当前目录下名字是“Dockerfile”的文件。</li>\n<li><code>docker build</code> 需要指定“构建上下文”，其中的文件会打包上传到Docker daemon，所以尽量不要在“构建上下文”中存放多余的文件。</li>\n<li>创建镜像的时候应当尽量使用 <code>-t</code> 参数，为镜像起一个有意义的名字，方便管理。</li>\n</ol><p>今天讲了不少，但关于创建镜像还有很多高级技巧等待你去探索，比如使用缓存、多阶段构建等等，你可以再参考Docker官方文档（<a href=\"https://docs.docker.com/engine/reference/builder/\">https://docs.docker.com/engine/reference/builder/</a>），或者一些知名应用的镜像（如Nginx、Redis、Node.js等）进一步学习。</p><h2>课下作业</h2><p>最后是课下作业时间，这里有一个完整的Dockerfile示例，你可以尝试着去解释一下它的含义，然后再自己构建一下：</p><pre><code class=\"language-plain\"># Dockerfile\n# docker build -t ngx-app .\n# docker build -t ngx-app:1.0 .\n\nARG IMAGE_BASE=\"nginx\"\nARG IMAGE_TAG=\"1.21-alpine\"\n\nFROM ${IMAGE_BASE}:${IMAGE_TAG}\n\nCOPY ./default.conf /etc/nginx/conf.d/\n\nRUN cd /usr/share/nginx/html \\\n&nbsp; &nbsp; &amp;&amp; echo \"hello nginx\" &gt; a.txt\n\nEXPOSE 8081 8082 8083\n</code></pre><p>当然还有两个思考题：</p><ol>\n<li>镜像里的层都是只读不可修改的，但容器运行的时候经常会写入数据，这个冲突应该怎么解决呢？（答案在本期找）</li>\n<li>你能再列举一下镜像的分层结构带来了哪些好处吗？</li>\n</ol><p>欢迎积极留言。如果你觉得有收获，也欢迎分享给身边的朋友同事一起讨论学习。</p><p><img src=\"https://static001.geekbang.org/resource/image/17/24/1705133103a8aaf6c7fed770afa6dc24.jpg?wh=1920x2805\" alt=\"\"></p>","neighbors":{"left":{"article_title":"03｜容器化的应用：会了这些你就是Docker高手","id":528651},"right":{"article_title":"05｜镜像仓库：该怎样用好Docker Hub这个宝藏","id":528677}},"comments":[]}