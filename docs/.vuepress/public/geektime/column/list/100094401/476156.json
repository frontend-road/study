{"id":476156,"title":"35｜Vite原理：写一个迷你的Vite","content":"<p>你好，我是大圣。</p><p>上一讲学完了Vue的编译原理后，我们就把Vue的整体流程梳理完毕了，但是我们在使用Vue的时候，还会用到很多Vue生态的库。所以从今天开始，我会带你了解几个Vue生态中重要成员的原理和源码，今天我先带你剖析一下我们项目中用的工程化工具Vite的原理。</p><h2>现在工程化的痛点</h2><p>现在前端开发项目的时候，工程化工具已经成为了标准配置，webpack是现在使用率最高的工程化框架，它可以很好地帮助我们完成从代码调试到打包的全过程，但是随着项目规模的爆炸式增长，<strong>webpack也带来了一些痛点问题</strong>。</p><p>最早webpack可以帮助我们在JavaScript文件中使用require导入其他JavaScript、CSS、image等文件，并且提供了dev-server启动测试服务器，极大地提高了我们开发项目的效率。</p><p>webpack的核心原理就是通过分析JavaScript中的require语句，分析出当前JavaScript文件所有的依赖文件，然后递归分析之后，就得到了整个项目的一个依赖图。对图中不同格式的文件执行不同的loader，比如会把CSS文件解析成加载CSS标签的JavaScript代码，最后基于这个依赖图获取所有的文件。</p><!-- [[[read_end]]] --><p>进行打包处理之后，放在内存中提供给浏览器使用，然后dev-server会启动一个测试服务器打开页面，并且在代码文件修改之后可以通过WebSocket通知前端自动更新页面，<strong>也就是我们熟悉的热更新功能</strong>。</p><p>由于webpack在项目调试之前，要把所有文件的依赖关系收集完，打包处理后才能启动测试，很多大项目我们执行调试命令后需要等1分钟以上才能开始调试。这对于开发者来说，这段时间除了摸鱼什么都干不了，而且热更新也需要等几秒钟才能生效，极大地影响了我们开发的效率。所以针对webpack这种打包bundle的思路，社区就诞生了bundless的框架，Vite就是其中的佼佼者。</p><p>前端的项目之所以需要webpack打包，是因为<strong>浏览器里的JavaScript没有很好的方式去引入其他文件</strong>。webpack提供的打包功能可以帮助我们更好地组织开发代码，但是现在大部分浏览器都支持了ES6的module功能，我们在浏览器内使用type=\"module\"标记一个script后，在src/main.js中就可以直接使用import语法去引入一个新的JavaScript文件。这样我们其实可以不依赖webpack的打包功能，利用浏览器的module功能就可以重新组织我们的代码。</p><pre><code class=\"language-javascript\">    &lt;script type=\"module\" src=\"/src/main.js\"&gt;&lt;/script&gt;\n</code></pre><h2>Vite原理</h2><p>了解了script的使用方式之后，我们来实现一个<strong>迷你的 Vite</strong>来讲解其大致的原理。</p><p>首先，浏览器的module功能有一些限制需要额外处理。浏览器识别出JavaScript中的import语句后，会发起一个新的网络请求去获取新的文件，所以只支持/\b、./和…/开头的路径。</p><p>而在下面的Vue项目启动代码中，首先浏览器并不知道Vue是从哪来，我们第一个要做的，就是分析文件中的import语句。如果路径不是一个相对路径或者绝对路径，那就说明这个模块是来自node_modules，我们需要去node_modules查找这个文件的入口文件后返回浏览器。然后 ./App.vue是相对路径，可以找到文件，但是浏览器不支持 .vue文件的解析，并且index.css也不是一个合法的JavaScript文件。</p><p><strong>我们需要解决以上三个问题，才能让Vue项目很好地在浏览器里跑起来。</strong></p><pre><code class=\"language-javascript\">import { createApp } from 'vue'\nimport App from './App.vue'\nimport './index.css'\n\nconst app = createApp(App)\napp.mount('#app')\n\n</code></pre><p>怎么做呢？首先我们需要使用Koa搭建一个server，用来拦截浏览器发出的所有网络请求，才能实现上述功能。在下面代码中，我们使用Koa启动了一个服务器，并且访问首页内容读取index.html的内容。</p><pre><code class=\"language-javascript\">const fs = require('fs')\nconst path = require('path')\nconst Koa = require('koa')\nconst app = new Koa()\n\napp.use(async ctx=&gt;{\n  const {request:{url,query} } = ctx\nif(url=='/'){\n    ctx.type=\"text/html\"\n    let content = fs.readFileSync('./index.html','utf-8')\n    \n    ctx.body = content\n  }\n})\napp.listen(24678, ()=&gt;{\n  console.log('快来快来数一数，端口24678')\n})\n</code></pre><p>下面就是首页index.html的内容，一个div作为Vue启动的容器，并且通过script引入src.main.js。我们访问首页之后，就会看到浏览器内显示的geektime文本，并且发起了一个main.js的HTTP请求，<strong>然后我们来解决页面中的报错问题</strong>。</p><pre><code class=\"language-javascript\">&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n  &lt;meta charset=\"UTF-8\"&gt;\n  &lt;link rel=\"icon\" href=\"/favicon.ico\" /&gt;\n  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n  &lt;title&gt;Vite App&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h1&gt;geek time&lt;/h1&gt;\n  &lt;div id=\"app\"&gt;&lt;/div&gt;\n  &lt;script type=\"module\" src=\"/src/main.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n</code></pre><p>首先import {createApp} from Vue这一步由于浏览器无法识别Vue的路径，就会直接抛出错误，所以我们要在Koa中把Vue的路径重写。为了方便演示，我们可以直接使用replace语句，把Vue改成/@modules/vue，使用@module开头的地址来告诉Koa这是一个需要去node_modules查询的模块。</p><p>在下面的代码中，我们判断如果请求地址是js结尾，就去读取对应的文件内容，使用rewriteImport函数处理后再返回文件内容。在rewriteImport中我们实现了路径的替换，把Vue变成了 @modules/vue， 现在浏览器就会发起一个<a href=\"http://localhost:24678/@modules/vue\">http://localhost:24678/@modules/vue</a> 的请求，下一步我们要在Koa中拦截这个请求，并且返回Vue的代码内容。</p><pre><code class=\"language-javascript\">const fs = require('fs')\nconst path = require('path')\nconst Koa = require('koa')\nconst app = new Koa()\n\nfunction rewriteImport(content){\n  return content.replace(/ from ['|\"]([^'\"]+)['|\"]/g, function(s0,s1){\n    // . ../ /开头的，都是相对路径\n    if(s1[0]!=='.'&amp;&amp; s1[1]!=='/'){\n      return ` from '/@modules/${s1}'`\n    }else{\n      return s0\n    }\n  })\n}\n\napp.use(async ctx=&gt;{\n  const {request:{url,query} } = ctx\n  if(url=='/'){\n      ctx.type=\"text/html\"\n      let content = fs.readFileSync('./index.html','utf-8')\n      \n      ctx.body = content\n  }else if(url.endsWith('.js')){\n    // js文件\n    const p = path.resolve(__dirname,url.slice(1))\n    ctx.type = 'application/javascript'\n    const content = fs.readFileSync(p,'utf-8')\n    ctx.body = rewriteImport(content)\n  }\n})\napp.listen(24678, ()=&gt;{\n  console.log('快来快来说一书，端口24678')\n})\n\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/c3/62/c39f700e37b638345ae4cbd0228fd762.png?wh=1125x387\" alt=\"图片\"></p><p>然后我们在Koa中判断请求地址，如果是@module的地址，就把后面的Vue解析出来，去node_modules中查询。然后拼接出目标路径 ./node_modules/vue/package.json去读取Vue项目中package.json的module字段，这个字段的地址就是 ES6 规范的入口文件。在我们读取到文件后，再使用rewriteImport处理后返回即可。</p><p>这里还要使用rewriteImport的原因是，Vue文件内部也会使用import的语法去加载其他模块。然后我们就可以看到浏览器网络请求列表中多了好几个Vue的请求。</p><pre><code class=\"language-javascript\">else if(url.startsWith('/@modules/')){\n    // 这是一个node_module里的东西\n    const prefix = path.resolve(__dirname,'node_modules',url.replace('/@modules/',''))\n    const module = require(prefix+'/package.json').module\n    const p = path.resolve(prefix,module)\n    const ret = fs.readFileSync(p,'utf-8')\n    ctx.type = 'application/javascript'\n    ctx.body = rewriteImport(ret)\n}\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/7f/fb/7fb5564ac59ffba085d9c7fd24f8f9fb.png?wh=1681x512\" alt=\"图片\"></p><p><strong>这样我们就实现了node_modules模块的解析，然后我们来处理浏览器无法识别 .vue文件的错误。</strong></p><p>.vue文件是Vue中特有的文件格式，我们上一节课提过Vue内部通过@vue/compiler-sfc来解析单文件组件，把组件分成template、style、script三个部分，我们要做的就是在Node环境下，把template的内容解析成render函数，并且和script的内容组成组件对象，再返回即可。</p><p>其中，compiler-dom解析template的流程我们学习过，今天我们来看下如何使用。</p><p>在下面的代码中，我们判断 .vue的文件请求后，通过compilerSFC.parse方法解析Vue组件，通过返回的descriptor.script获取JavaScript代码，并且发起一个type=template的方法去获取render函数。在query.type是template的时候，调用compilerDom.compile解析template内容，直接返回render函数。</p><pre><code class=\"language-javascript\">const compilerSfc = require('@vue/compiler-sfc') // .vue\nconst compilerDom = require('@vue/compiler-dom') // 模板\n\n\n\n\n\nif(url.indexOf('.vue')&gt;-1){\n    // vue单文件组件\n    const p = path.resolve(__dirname, url.split('?')[0].slice(1))\n    const {descriptor} = compilerSfc.parse(fs.readFileSync(p,'utf-8'))\n\n    if(!query.type){\n      ctx.type = 'application/javascript'\n      // 借用vue自导的compile框架 解析单文件组件，其实相当于vue-loader做的事情\n      ctx.body = `\n  ${rewriteImport(descriptor.script.content.replace('export default ','const __script = '))}\n  import { render as __render } from \"${url}?type=template\"\n  __script.render = __render\n  export default __script\n      `\n    }else if(query.type==='template'){\n      // 模板内容\n      const template = descriptor.template\n      // 要在server端吧compiler做了\n      const render = compilerDom.compile(template.content, {mode:\"module\"}).code\n      ctx.type = 'application/javascript'\n\n      ctx.body = rewriteImport(render)\n    }\n    \n</code></pre><p>上面的代码实现之后，我们就可以在浏览器中看到App.vue组件解析的结果。App.vue会额外发起一个App.vue?type=template的请求，最终完成了整个App组件的解析。</p><p><img src=\"https://static001.geekbang.org/resource/image/f9/90/f986571970188eac47bb4fac1af37d90.png?wh=1920x552\" alt=\"图片\"><img src=\"https://static001.geekbang.org/resource/image/cc/46/cc696c23a2a6d4e9eacf401375320146.png?wh=1920x384\" alt=\"图片\"></p><p><strong>接下来我们再来实现对CSS文件的支持。</strong>下面的代码中，如果url是CSS结尾，我们就返回一段JavaScript代码。这段JavaScript代码会在浏览器里创建一个style标签，标签内部放入我们读取的CSS文件代码。这种对CSS文件的处理方式，让CSS以JavaScript的形式返回，这样我们就实现了在Node中对Vue组件的渲染。</p><pre><code class=\"language-javascript\">if(url.endsWith('.css')){\n    const p = path.resolve(__dirname,url.slice(1))\n    const file = fs.readFileSync(p,'utf-8')\n    const content = `\n    const css = \"${file.replace(/\\n/g,'')}\"\n    let link = document.createElement('style')\n    link.setAttribute('type', 'text/css')\n    document.head.appendChild(link)\n    link.innerHTML = css\n    export default css\n    `\n    ctx.type = 'application/javascript'\n    ctx.body = content\n  }\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/9f/f7/9f50c5ca0d9b74b680e41963055c99f7.png?wh=1920x628\" alt=\"图片\"></p><h2>Vite的热更新</h2><p>最后我们再来看一下热更新如何实现。热更新的目的就是在我们修改代码之后，<strong>浏览器能够自动渲染更新的内容</strong>，所以我们要在客户端注入一个额外的JavaScript文件，这个文件用来和后端实现WebSocket通信。然后后端启动WebSocket服务，通过chokidar库监听文件夹的变化后，再通过WebSocket去通知浏览器即可。</p><p>下面的代码中，我们通过chokidar.watch实现了文件夹变更的监听，并且通过handleHMRUpdate通知客户端文件更新的类型。</p><pre><code class=\"language-javascript\">\nexport function watch() {\n  const watcher = chokidar.watch(appRoot, {\n    ignored: ['**/node_modules/**', '**/.git/**'],\n    ignoreInitial: true,\n    ignorePermissionErrors: true,\n    disableGlobbing: true,\n  });\n  watcher;\n\n  return watcher;\n}\nexport function handleHMRUpdate(opts: { file: string; ws: any }) {\n  const { file, ws } = opts;\n  const shortFile = getShortName(file, appRoot);\n  const timestamp = Date.now();\n\n  console.log(`[file change] ${chalk.dim(shortFile)}`);\n  let updates;\n  if (shortFile.endsWith('.css')) {\n    updates = [\n      {\n        type: 'js-update',\n        timestamp,\n        path: `/${shortFile}`,\n        acceptedPath: `/${shortFile}`,\n      },\n    ];\n  }\n\n  ws.send({\n    type: 'update',\n    updates,\n  });\n}\n\n</code></pre><p>然后客户端注入一段额外的JavaScript代码，判断后端传递的类型是js-update还是css-update去执行不同的函数即可。</p><pre><code class=\"language-javascript\">async function handleMessage(payload: any) {\n  switch (payload.type) {\n    case 'connected':\n      console.log(`[vite] connected.`);\n\n      setInterval(() =&gt; socket.send('ping'), 30000);\n      break;\n\n    case 'update':\n      payload.updates.forEach((update: Update) =&gt; {\n        if (update.type === 'js-update') {\n          fetchUpdate(update);\n        } \n      });\n      break;\n  }\n}\n\n</code></pre><h2>总结</h2><p>以上就是今天的主要内容，我们来总结一下吧！</p><p>首先，我们通过了解webpack的大致原理，知道了现在webpack在开发体验上的痛点。除了用户体验UX之外，开发者的体验DX也是项目质量的重要因素。</p><p>webpack启动服务器之前需要进行项目的打包，而Vite则是可以直接启动服务，通过浏览器运行时的请求拦截，实现首页文件的按需加载，这样开发服务器启动的时间就和整个项目的复杂度解耦。任何时候我们启动Vite的调试服务器，基本都可以在一秒以内响应，这极大地提升了开发者的体验，这也是Vite的使用率越来越高的原因。</p><p>并且我们可以看到，Vite的主要目的就是提供一个调试服务器。Vite也可以和Vue解耦，实现对任何框架的支持，如果使用Vite支持React，只需要解析React中的JSX就可以实现。这也是Vite项目的现状，我们只需要使用框架对应的Vite插件就可以支持任意框架。</p><p>Vite能够做到这么快的原因，还有一部分是因为使用了esbuild去解析JavaScript文件。esbuild是一个用Go语言实现的JavaScript打包器，支持JavaScript和TypeScript语法，现在前端工程化领域的工具也越来越多地使用Go和Rust等更高效的语言书写，这也是性能优化的一个方向。</p><h2>思考题</h2><p>最后留一个思考题吧。如果一个模块文件是分散的，导致Vite首页一下子要加载1000个JavaScript文件造成卡顿，我们该如何处理这种情况呢？</p><p>欢迎在评论区分享你的答案，我们下一讲再见！</p>","comments":[{"had_liked":false,"id":331162,"user_name":"若川","can_delete":false,"product_type":"c1","uid":1230852,"ip_address":"","ucode":"B8C3DD4B38CC6F","user_header":"https://static001.geekbang.org/account/avatar/00/12/c8/04/fed4c1ad.jpg","comment_is_top":false,"comment_ctime":1642469948,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"78951881276","product_id":100094401,"comment_content":"我之前也写过一篇mini-vue的分析文章，感兴趣的可以结合大圣老师的文章对比看看实现～<br><br>尤雨溪几年前开发的“玩具 vite”，才100多行代码，却十分有助于理解 vite 原理<br>https:&#47;&#47;juejin.cn&#47;post&#47;7021306258057592862","like_count":19},{"had_liked":false,"id":330730,"user_name":"特供版","can_delete":false,"product_type":"c1","uid":1269739,"ip_address":"","ucode":"9D6D547DFA2C05","user_header":"https://static001.geekbang.org/account/avatar/00/13/5f/eb/ef7aa4c1.jpg","comment_is_top":false,"comment_ctime":1642136846,"is_pvip":false,"replies":[{"id":"120838","content":"very good","user_name":"作者回复","comment_id":330730,"uid":"1003715","ip_address":"","utype":1,"ctime":1642338359,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"23116973326","product_id":100094401,"comment_content":"流程：<br>1.  请求 首页http:&#47;&#47;xxx.xxx.xxx&#47; <br>2.  返回 index.html<br>3.  请求 &#47;src&#47;main.js<br>4. 发现请求js文件，替换路径为相对路径后，返回修改后的js文件<br>5.  请求 @module&#47;vue<br>6.  发现请求@module内的文件，替换文件内为相对路径后，返回package.json中module定义的入口文件<br>7.  请求 .&#47;App.vue<br>8.  判断 .vue 的请求后，通过 compilerSFC.parse解析 Vue 组件，通过返回的 descriptor.script 获取 js 代码<br>9.  请求 .&#47;App.vue?type=template<br>10.  调用 compilerDom.compile 解析 template 内容，直接返回 render 函数","like_count":6,"discussions":[{"author":{"id":1003715,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/50/c3/0aa50246.jpg","nickname":"花果山大圣","note":"","ucode":"25C0A36D628037","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546539,"discussion_content":"very good","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642338359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330130,"user_name":"润培","can_delete":false,"product_type":"c1","uid":1334652,"ip_address":"","ucode":"1CC2CD568CECC5","user_header":"https://static001.geekbang.org/account/avatar/00/14/5d/7c/3cfece5e.jpg","comment_is_top":false,"comment_ctime":1641807955,"is_pvip":false,"replies":[{"id":"120844","content":"赞","user_name":"作者回复","comment_id":330130,"uid":"1003715","ip_address":"","utype":1,"ctime":1642338666,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"14526709843","product_id":100094401,"comment_content":"模块如果是分散的，可以使用“依赖预构建”，通过预构建生成一个模块，这样只会有一个 http 请求。<br><br>https:&#47;&#47;cn.vitejs.dev&#47;guide&#47;dep-pre-bundling.html<br><br>https:&#47;&#47;cn.vitejs.dev&#47;config&#47;#dep-optimization-options","like_count":3,"discussions":[{"author":{"id":1003715,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/50/c3/0aa50246.jpg","nickname":"花果山大圣","note":"","ucode":"25C0A36D628037","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546547,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642338666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330907,"user_name":"tequ1lAneio","can_delete":false,"product_type":"c1","uid":1936087,"ip_address":"","ucode":"41336E87FF2E1A","user_header":"https://static001.geekbang.org/account/avatar/00/1d/8a/d7/daabec34.jpg","comment_is_top":false,"comment_ctime":1642266075,"is_pvip":true,"replies":[{"id":"120833","content":"这部分源码在这里<br>https:&#47;&#47;github.com&#47;shengxinjing&#47;geektime-vue-course&#47;tree&#47;main&#47;vite-mini","user_name":"作者回复","comment_id":330907,"uid":"1003715","ip_address":"","utype":1,"ctime":1642337892,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"10232200667","product_id":100094401,"comment_content":"有源码吗，一直在报process未定义的错误","like_count":3,"discussions":[{"author":{"id":1003715,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/50/c3/0aa50246.jpg","nickname":"花果山大圣","note":"","ucode":"25C0A36D628037","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546532,"discussion_content":"这部分源码在这里\nhttps://github.com/shengxinjing/geektime-vue-course/tree/main/vite-mini","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642337892,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330961,"user_name":"吴颜","can_delete":false,"product_type":"c1","uid":1159556,"ip_address":"","ucode":"CB5EAFF67BA816","user_header":"https://static001.geekbang.org/account/avatar/00/11/b1/84/d7034d7c.jpg","comment_is_top":false,"comment_ctime":1642326479,"is_pvip":true,"replies":[{"id":"120888","content":"只实现了核心的node_module以及.vue和css文件的解析","user_name":"作者回复","comment_id":330961,"uid":"1003715","ip_address":"","utype":1,"ctime":1642384998,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"5937293775","product_id":100094401,"comment_content":"写的太简单，你这也没写出一个迷你的vite啊","like_count":1,"discussions":[{"author":{"id":1003715,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/50/c3/0aa50246.jpg","nickname":"花果山大圣","note":"","ucode":"25C0A36D628037","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546656,"discussion_content":"只实现了核心的node_module以及.vue和css文件的解析","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642384999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345901,"user_name":"Geek_07f3c3","can_delete":false,"product_type":"c1","uid":2979036,"ip_address":"","ucode":"658EFEBCEF60DD","user_header":"","comment_is_top":false,"comment_ctime":1652687849,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1652687849","product_id":100094401,"comment_content":"vite打包时提示包体积过大，请问应该怎压缩呢或者怎么分包","like_count":0,"discussions":[{"author":{"id":2859387,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK2ibcQVCzwThRQWhAVVDHjiaaCOXqrYKC2qlM9iaAVrSZcpJmPAPBHoPiapG9pPYbjf4NtvNOVfrLOtw/132","nickname":"MIKE LIU","note":"","ucode":"ADD9672A6D7A80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578442,"discussion_content":"这个之前遇到过，提示打包体积过大，可以试着修改warning的大小，当然最好的方法就是按需加载组件库。\n\nhttps://cn.vitejs.dev/config/build-options.html\n\nbuild.reportCompressedSize ¶\n类型： boolean\n默认： true\n启用/禁用 gzip 压缩大小报告。压缩大型输出文件可能会很慢，因此禁用该功能可能会提高大型项目的构建性能。\n\nbuild.chunkSizeWarningLimit ¶\n类型： number\n默认： 500\nchunk 大小警告的限制（以 kbs 为单位）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656753135,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":334702,"user_name":"null","can_delete":false,"product_type":"c1","uid":1464663,"ip_address":"","ucode":"A0C199F5D731C7","user_header":"https://static001.geekbang.org/account/avatar/00/16/59/57/7201d6ce.jpg","comment_is_top":false,"comment_ctime":1645083750,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645083750","product_id":100094401,"comment_content":"开发过程中出现加载慢，timeout。","like_count":0},{"had_liked":false,"id":333364,"user_name":"逗逼章鱼","can_delete":false,"product_type":"c1","uid":1197314,"ip_address":"","ucode":"5E8A5E1CC375B7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJfTnE46bP9zFU0MJicYZmKYTPhm97YjgSEmNVKr3ic1BY3CL8ibPUFCBVTqyoHQPpBcbe9GRKEN1CyA/132","comment_is_top":false,"comment_ctime":1644311314,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1644311314","product_id":100094401,"comment_content":"以后 importmap 会变成主流吗？","like_count":0},{"had_liked":false,"id":331181,"user_name":"Geek_4da4e1","can_delete":false,"product_type":"c1","uid":2815773,"ip_address":"","ucode":"16BDB5EE676AD4","user_header":"","comment_is_top":false,"comment_ctime":1642476007,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1642476007","product_id":100094401,"comment_content":"css文件替换换行符windows下不行，&#47;r也有可能","like_count":0,"discussions":[{"author":{"id":2826309,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/20/45/6c8bb3aa.jpg","nickname":"小花（fa）","note":"","ucode":"7F88A9F990712B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554081,"discussion_content":"windows下 css换行替换改为： const css = &#34;${file.replace(/\\r\\n/g, &#39;&#39;)}&#34;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646207158,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330937,"user_name":"Chen.Lu","can_delete":false,"product_type":"c1","uid":2646269,"ip_address":"","ucode":"37A6E7DE4441DA","user_header":"https://static001.geekbang.org/account/avatar/00/28/60/fd/c08731d7.jpg","comment_is_top":false,"comment_ctime":1642313375,"is_pvip":false,"replies":[{"id":"120889","content":"感谢提醒  fix  下面一句就说的是chokidar","user_name":"作者回复","comment_id":330937,"uid":"1003715","ip_address":"","utype":1,"ctime":1642385302,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1642313375","product_id":100094401,"comment_content":"【Vite 热更新】小模块中 chalk 是定义 log 颜色的工具，不是监听文件&#47;文件夹的工具吧。<br>chokidar 是监听文件&#47;文件夹的工具","like_count":0,"discussions":[{"author":{"id":1003715,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/50/c3/0aa50246.jpg","nickname":"花果山大圣","note":"","ucode":"25C0A36D628037","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546658,"discussion_content":"感谢提醒  fix  下面一句就说的是chokidar","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642385302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330107,"user_name":"InfoQ_e521a4ce8a54","can_delete":false,"product_type":"c1","uid":2128328,"ip_address":"","ucode":"6D8988948DD291","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIkBhCDbibPDmDTEW6Uia1LAEOcFf75QxA897gcL4oXFMOwgsqFwf7rhPoUoJWgICl0xFT8Iz2cuWRg/132","comment_is_top":false,"comment_ctime":1641799935,"is_pvip":false,"replies":[{"id":"120845","content":"现在代码都集中推到这个仓库里<br>https:&#47;&#47;github.com&#47;shengxinjing&#47;geektime-vue-course","user_name":"作者回复","comment_id":330107,"uid":"1003715","ip_address":"","utype":1,"ctime":1642338703,"user_name_real":"编辑"}],"discussion_count":2,"race_medal":0,"score":"1641799935","product_id":100094401,"comment_content":"从[Vite 的热更新]开始，代码片段所在的文件目录和所需的依赖就搞不清楚了。。。","like_count":0,"discussions":[{"author":{"id":1003715,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/50/c3/0aa50246.jpg","nickname":"花果山大圣","note":"","ucode":"25C0A36D628037","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546549,"discussion_content":"现在代码都集中推到这个仓库里\nhttps://github.com/shengxinjing/geektime-vue-course","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642338703,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1020726,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/93/36/abb7bfe3.jpg","nickname":"Hhpon","note":"","ucode":"12FE37D4B67631","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585415,"discussion_content":"这个仓库里面好像并没有vite热更新的内容呀😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661520426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"湖北"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}