{"id":191136,"title":"24 | Boost：你需要的“瑞士军刀”","content":"<p>你好，我是吴咏炜。</p><p>我们已经零零碎碎提到过几次 Boost 了。作为 C++ 世界里标准库之外最知名的开放源码程序库，我们值得专门用一讲来讨论一下 Boost。</p><h2>Boost 概览</h2><p>Boost 的网站把 Boost 描述成为经过同行评审的、可移植的 C++ 源码库（peer-reviewed portable C++ source libraries）<span class=\"orange\">[1]</span>。换句话说，它跟很多个人开源库不一样的地方在于，它的代码是经过评审的。事实上，Boost 项目的背后有很多 C++ 专家，比如发起人之一的 Dave Abarahams 是 C++ 标准委员会的成员，也是《C++ 模板元编程》一书 <span class=\"orange\">[2]</span> 的作者。这也就使得 Boost 有了很不一样的特殊地位：它既是 C++ 标准库的灵感来源之一，也是 C++ 标准库的试验田。下面这些 C++ 标准库就源自 Boost：</p><ul>\n<li>智能指针</li>\n<li>thread</li>\n<li>regex</li>\n<li>random</li>\n<li>array</li>\n<li>bind</li>\n<li>tuple</li>\n<li>optional</li>\n<li>variant</li>\n<li>any</li>\n<li>string_view</li>\n<li>filesystem</li>\n<li>等等</li>\n</ul><p>当然，将来还会有新的库从 Boost 进入 C++ 标准，如网络库的标准化就是基于 Boost.Asio 进行的。因此，即使相关的功能没有被标准化，我们也可能可以从 Boost 里看到某个功能可能会被标准化的样子——当然，最终标准化之后的样子还是经常有所变化的。</p><!-- [[[read_end]]] --><p>我们也可以在我们的编译器落后于标准、不能提供标准库的某个功能时使用 Boost 里的替代品。比如，我之前提到过老版本的 macOS 上苹果的编译器不支持 optional 和 variant。除了我描述的不正规做法，改用 Boost 也是方法之一。比如，对于 variant，所需的改动只是：</p><ul>\n<li>把包含 &lt;variant&gt; 改成包含 &lt;boost/variant.hpp&gt;</li>\n<li>把代码中的 <code>std::variant</code> 改成 <code>boost::variant</code></li>\n</ul><p>这样，就基本大功告成了。</p><p>作为一个准标准的库，很多环境里缺省会提供 Boost。这种情况下，在程序里使用 Boost 不会额外增加编译或运行时的依赖，减少了可能的麻烦。如果我需要某个功能，在标准库里没有，在 Boost 里有，我会很乐意直接使用 Boost 里的方案，而非另外去查找。如果我要使用非 Boost 的第三方库的话，那一般要么是 Boost 里没有，要么就是那个库比 Boost 里的要好用很多了。</p><p>鉴于 Boost 是一个库集合，当前版本（1.72）有 160 个独立库，即使写本书也不可能完整地讨论所有的库。这一讲里，我们也就管中窥豹式地浏览几个 Boost 库。具体你需要什么，还是得你自己回头去细细品味。</p><h3>Boost 的安装</h3><p>在主要的开发平台上，现在你都可以直接安装 Boost，而不需要自己从源代码编译了：</p><ul>\n<li>在 Windows 下使用 MSVC，我们可以使用 NuGet 安装（按需逐个安装）</li>\n<li>在 Linux 下，我们可以使用系统的包管理器（如 apt 和 yum）安装（按需逐个安装，或一次性安装所有的开发需要的包）</li>\n<li>在 macOS 下，我们可以使用 Homebrew 安装（一次性安装完整的 Boost）</li>\n</ul><p>如果你在某个平台上使用非缺省的编译器，如在 Windows 上或 macOS 上使用 GCC，一般就需要自己编译了，具体步骤请参见 Boost 的文档。不过，很多 Boost 库是完全不需要编译的，只需要把头文件加到编译器能找到的路径里就可以——如我们上一讲讨论的 Boost.Multiprecision 就是这样。我们讨论 Boost 库的时候，也会提一下使用这个库是否需要链接某个 Boost 库——需要的话，也就意味着需要编译和安装这个 Boost 库。</p><h2>Boost.TypeIndex</h2><p>TypeIndex 是一个很轻量级的库，它不需要链接，解决的也是使用模板时的一个常见问题，如何精确地知道一个表达式或变量的类型。我们还是看一个例子：</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n#include &lt;boost/type_index.hpp&gt;\n\nusing namespace std;\nusing boost::typeindex::type_id;\nusing boost::typeindex::\n  type_id_with_cvr;\n\nint main()\n{\n  vector&lt;int&gt; v;\n  auto it = v.cbegin();\n\n  cout &lt;&lt; \"*** Using typeid\\n\";\n  cout &lt;&lt; typeid(const int).name()\n       &lt;&lt; endl;\n  cout &lt;&lt; typeid(v).name() &lt;&lt; endl;\n  cout &lt;&lt; typeid(it).name() &lt;&lt; endl;\n\n  cout &lt;&lt; \"*** Using type_id\\n\";\n  cout &lt;&lt; type_id&lt;const int&gt;() &lt;&lt; endl;\n  cout &lt;&lt; type_id&lt;decltype(v)&gt;()\n       &lt;&lt; endl;\n  cout &lt;&lt; type_id&lt;decltype(it)&gt;()\n       &lt;&lt; endl;\n\n  cout &lt;&lt; \"*** Using \"\n          \"type_id_with_cvr\\n\";\n  cout\n    &lt;&lt; type_id_with_cvr&lt;const int&gt;()\n    &lt;&lt; endl;\n  cout &lt;&lt; type_id_with_cvr&lt;decltype(\n            (v))&gt;()\n       &lt;&lt; endl;\n  cout &lt;&lt; type_id_with_cvr&lt;decltype(\n            move((v)))&gt;()\n       &lt;&lt; endl;\n  cout &lt;&lt; type_id_with_cvr&lt;decltype(\n            (it))&gt;()\n       &lt;&lt; endl;\n}\n</code></pre><p>上面的代码里，展示了标准的 <code>typeid</code> 和 Boost 的 <code>type_id</code> 和 <code>type_id_with_cvr</code> 的使用。它们的区别是：</p><ul>\n<li><code>typeid</code> 是标准 C++ 的关键字，可以应用到变量或类型上，返回一个 <code>std::type_info</code>。我们可以用它的 <code>name</code> 成员函数把结果转换成一个字符串，但标准不保证这个字符串的可读性和唯一性。</li>\n<li><code>type_id</code> 是 Boost 提供的函数模板，必须提供类型作为模板参数——所以对于表达式和变量我们需要使用 <code>decltype</code>。结果可以直接输出到 IO 流上。</li>\n<li><code>type_id_with_cvr</code> 和 <code>type_id</code> 相似，但它获得的结果会包含 const/volatile 状态及引用类型。</li>\n</ul><p>上面程序在 MSVC 下的输出为：</p><blockquote>\n<p><code>*** Using typeid</code><br>\n<code>int</code><br>\n<code>class std::vector&lt;int,class std::allocator&lt;int&gt; &gt;</code><br>\n<code>class std::_Vector_const_iterator&lt;class std::_Vector_val&lt;struct std::_Simple_types&lt;int&gt; &gt; &gt;</code><br>\n<code>*** Using type_id</code><br>\n<code>int</code><br>\n<code>class std::vector&lt;int,class std::allocator&lt;int&gt; &gt;</code><br>\n<code>class std::_Vector_const_iterator&lt;class std::_Vector_val&lt;struct std::_Simple_types&lt;int&gt; &gt; &gt;</code><br>\n<code>*** Using type_id_with_cvr</code><br>\n<code>int const</code><br>\n<code>class std::vector&lt;int,class std::allocator&lt;int&gt; &gt; &amp;</code><br>\n<code>class std::vector&lt;int,class std::allocator&lt;int&gt; &gt; &amp;&amp;</code><br>\n<code>class std::_Vector_const_iterator&lt;class std::_Vector_val&lt;struct std::_Simple_types&lt;int&gt; &gt; &gt; &amp;</code></p>\n</blockquote><p>在 GCC 下的输出为：</p><blockquote>\n<p><code>*** Using typeid</code><br>\n<code>i</code><br>\n<code>St6vectorIiSaIiEE</code><br>\n<code>N9__gnu_cxx17__normal_iteratorIPKiSt6vectorIiSaIiEEEE</code><br>\n<code>*** Using type_id</code><br>\n<code>int</code><br>\n<code>std::vector&lt;int, std::allocator&lt;int&gt; &gt;</code><br>\n<code>__gnu_cxx::__normal_iterator&lt;int const*, std::vector&lt;int, std::allocator&lt;int&gt; &gt; &gt;</code><br>\n<code>*** Using type_id_with_cvr</code><br>\n<code>int const</code><br>\n<code>std::vector&lt;int, std::allocator&lt;int&gt; &gt;&amp;</code><br>\n<code>std::vector&lt;int, std::allocator&lt;int&gt; &gt;&amp;&amp;</code><br>\n<code>__gnu_cxx::__normal_iterator&lt;int const*, std::vector&lt;int, std::allocator&lt;int&gt; &gt; &gt;&amp;</code></p>\n</blockquote><p>我们可以看到 MSVC 下 <code>typeid</code> 直接输出了比较友好的类型名称，但 GCC 下没有。此外，我们可以注意到：</p><ul>\n<li><code>typeid</code> 的输出忽略了 const 修饰，也不能输出变量的引用类型。</li>\n<li><code>type_id</code> 保证可以输出友好的类型名称，输出时也不需要调用成员函数，但例子里它忽略了 <code>int</code> 的 const 修饰，也和 <code>typeid</code> 一样不能输出表达式的引用类型。</li>\n<li><code>type_id_with_cvr</code> 可以输出 const/volatile 状态和引用类型，注意这种情况下模板参数必须包含引用类型，所以我用了 <code>decltype((v))</code> 这种写法，而不是 <code>decltype(v)</code>。如果你忘了这两者的区别，请复习一下<a href=\"https://time.geekbang.org/column/article/176850\">[第 8 讲]</a> 的 <code>decltype</code>。</li>\n</ul><p>显然，除非你正在使用 MSVC，否则调试期 <code>typeid</code> 的用法完全应该用 Boost 的 <code>type_id</code> 来替代。另外，如果你的开发环境要求禁用 RTTI（运行时类型识别），那 <code>typeid</code> 在 Clang 和 GCC 下根本不能使用，而使用 Boost.TypeIndex 库仍然没有问题。</p><p>当然，上面说的前提都是你在调试中试图获得变量的类型，而不是要获得一个多态对象的运行时类型。后者还是离不开 RTTI 的——虽然你也可以用一些其他方式来模拟 RTTI，但我个人觉得一般的项目不太有必要这样做。下面的代码展示了 <code>typeid</code> 和 <code>type_id</code> 在获取对象类型上的差异：</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n#include &lt;boost/type_index.hpp&gt;\n\nusing namespace std;\nusing boost::typeindex::type_id;\n\nclass shape {\npublic:\n  virtual ~shape() {}\n};\n\nclass circle : public shape {};\n\n#define CHECK_TYPEID(object, type) \\\n  cout &lt;&lt; \"typeid(\" #object &lt;&lt; \")\" \\\n       &lt;&lt; (typeid(object) ==       \\\n               typeid(type)        \\\n             ? \" is \"              \\\n             : \" is NOT \")         \\\n       &lt;&lt; #type &lt;&lt; endl\n\n#define CHECK_TYPE_ID(object,      \\\n                      type)        \\\n  cout &lt;&lt; \"type_id(\" #object       \\\n       &lt;&lt; \")\"                      \\\n       &lt;&lt; (type_id&lt;decltype(       \\\n                 object)&gt;() ==     \\\n               type_id&lt;type&gt;()     \\\n             ? \" is \"              \\\n             : \" is NOT \")         \\\n       &lt;&lt; #type &lt;&lt; endl\n\nint main()\n{\n  shape* ptr = new circle();\n  CHECK_TYPEID(*ptr, shape);\n  CHECK_TYPEID(*ptr, circle);\n  CHECK_TYPE_ID(*ptr, shape);\n  CHECK_TYPE_ID(*ptr, circle);\n  delete ptr;\n}\n</code></pre><p>输出为：</p><blockquote>\n<p><code>typeid(*ptr) is NOT shape</code><br>\n<code>typeid(*ptr) is circle</code><br>\n<code>type_id(*ptr) is shape</code><br>\n<code>type_id(*ptr) is NOT circle</code></p>\n</blockquote><h2>Boost.Core</h2><p>Core 里面提供了一些通用的工具，这些工具常常被 Boost 的其他库用到，而我们也可以使用，不需要链接任何库。在这些工具里，有些已经（可能经过一些变化后）进入了 C++ 标准，如：</p><ul>\n<li><code>addressof</code>，在即使用户定义了 <code>operator&amp;</code> 时也能获得对象的地址</li>\n<li><code>enable_if</code>，这个我们已经深入讨论过了（<a href=\"https://time.geekbang.org/column/article/181636\">[第 14 讲]</a>）</li>\n<li><code>is_same</code>，判断两个类型是否相同，C++11 开始在 &lt;type_traits&gt; 中定义</li>\n<li><code>ref</code>，和标准库的相同，我们在<a href=\"https://time.geekbang.org/column/article/186689\">[第 19 讲]</a> 讨论线程时用过</li>\n</ul><p>我们在剩下的里面来挑几个讲讲。</p><h3>boost::core::demangle</h3><p><code>boost::core::demangle</code> 能够用来把 <code>typeid</code> 返回的内部名称“反粉碎”（demangle）成可读的形式，看代码和输出应该就非常清楚了：</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n#include &lt;vector&gt;\n#include &lt;boost/core/demangle.hpp&gt;\n\nusing namespace std;\nusing boost::core::demangle;\n\nint main()\n{\n  vector&lt;int&gt; v;\n  auto it = v.cbegin();\n\n  cout &lt;&lt; \"*** Using typeid\\n\";\n  cout &lt;&lt; typeid(const int).name()\n       &lt;&lt; endl;\n  cout &lt;&lt; typeid(v).name() &lt;&lt; endl;\n  cout &lt;&lt; typeid(it).name() &lt;&lt; endl;\n\n  cout &lt;&lt; \"*** Demangled\\n\";\n  cout &lt;&lt; demangle(typeid(const int)\n                     .name())\n       &lt;&lt; endl;\n  cout &lt;&lt; demangle(typeid(v).name())\n       &lt;&lt; endl;\n  cout &lt;&lt; demangle(\n            typeid(it).name())\n       &lt;&lt; endl;\n}\n</code></pre><p>GCC 下的输出为：</p><blockquote>\n<p><code>*** Using typeid</code><br>\n<code>i</code><br>\n<code>St6vectorIiSaIiEE</code><br>\n<code>N9__gnu_cxx17__normal_iteratorIPKiSt6vectorIiSaIiEEEE</code><br>\n<code>*** Demangled</code><br>\n<code>int</code><br>\n<code>std::vector&lt;int, std::allocator&lt;int&gt; &gt;</code><br>\n<code>__gnu_cxx::__normal_iterator&lt;int const*, std::vector&lt;int, std::allocator&lt;int&gt; &gt; &gt;</code></p>\n</blockquote><p>如果你不使用 RTTI 的话，那直接使用 TypeIndex 应该就可以。如果你需要使用 RTTI、又不是（只）使用 MSVC 的话，<code>demangle</code> 就会给你不少帮助。</p><h3>boost::noncopyable</h3><p><code>boost::noncopyable</code> 提供了一种非常简单也很直白的把类声明成不可拷贝的方式。比如，我们<a href=\"https://time.geekbang.org/column/article/169225\">[第 1 讲]</a> 里的 <code>shape_wrapper</code>，用下面的写法就明确表示了它不允许被拷贝：</p><pre><code class=\"language-c++\">#include &lt;boost/core/noncopyable.hpp&gt;\n\nclass shape_wrapper\n  : private boost::noncopyable {\n  …\n};\n</code></pre><p>你当然也可以自己把拷贝构造和拷贝赋值函数声明成 <code>= delete</code>，不过，上面的写法是不是可读性更佳？</p><h3>boost::swap</h3><p>你有没有印象在通用的代码如何对一个不知道类型的对象执行交换操作？不记得的话，标准做法是这样的：</p><pre><code class=\"language-c++\">{\n  using std::swap;\n  swap(lhs, rhs);\n}\n</code></pre><p>即，我们需要（在某个小作用域里）引入 <code>std::swap</code>，然后让编译器在“看得到” <code>std::swap</code> 的情况下去编译 <code>swap</code> 指令。根据 ADL，如果在被交换的对象所属类型的名空间下有 <code>swap</code> 函数，那个函数会被优先使用，否则，编译器会选择通用的 <code>std::swap</code>。</p><p>似乎有点小啰嗦。使用 Boost 的话，你可以一行搞定：</p><pre><code class=\"language-c++\">boost::swap(lhs, rhs);\n</code></pre><p>当然，你需要包含头文件 &lt;boost/core/swap.hpp&gt;。</p><h2>Boost.Conversion</h2><p>Conversion 同样是一个不需要链接的轻量级的库。它解决了标准 C++ 里的另一个问题，标准类型之间的转换不够方便。在 C++11 之前，这个问题尤为严重。在 C++11 里，标准引入了一系列的函数，已经可以满足常用类型之间的转换。但使用 Boost.Conversion 里的 <code>lexical_cast</code> 更不需要去查阅方法名称或动脑子去努力记忆。</p><p>下面是一个例子：</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;stdexcept&gt;\n#include &lt;string&gt;\n#include &lt;boost/lexical_cast.hpp&gt;\n\nusing namespace std;\nusing boost::bad_lexical_cast;\nusing boost::lexical_cast;\n\nint main()\n{\n  // 整数到字符串的转换\n  int d = 42;\n  auto d_str =\n    lexical_cast&lt;string&gt;(d);\n  cout &lt;&lt; d_str &lt;&lt; endl;\n\n  // 字符串到浮点数的转换\n  auto f =\n    lexical_cast&lt;float&gt;(d_str) /\n    4.0;\n  cout &lt;&lt; f &lt;&lt; endl;\n\n  // 测试 lexical_cast 的转换异常\n  try {\n    int t = lexical_cast&lt;int&gt;(\"x\");\n    cout &lt;&lt; t &lt;&lt; endl;\n  }\n  catch (bad_lexical_cast&amp; e) {\n    cout &lt;&lt; e.what() &lt;&lt; endl;\n  }\n\n  // 测试标准库 stoi 的转换异常\n  try {\n    int t = std::stoi(\"x\");\n    cout &lt;&lt; t &lt;&lt; endl;\n  }\n  catch (invalid_argument&amp; e) {\n    cout &lt;&lt; e.what() &lt;&lt; endl;\n  }\n}\n</code></pre><p>GCC 下的输出为：</p><blockquote>\n<p><code>42</code><br>\n<code>10.5</code><br>\n<code>bad lexical cast: source type value could not be interpreted as target</code><br>\n<code>stoi</code></p>\n</blockquote><p>我觉得 GCC 里 <code>stoi</code> 的异常输出有点太言简意赅了……而 <code>lexical_cast</code> 的异常输出在不同的平台上有很好的一致性。</p><h2>Boost.ScopeExit</h2><p>我们说过 RAII 是推荐的 C++ 里管理资源的方式。不过，作为 C++ 程序员，跟 C 函数打交道也很正常。每次都写个新的 RAII 封装也有点浪费。Boost 里提供了一个简单的封装，你可以从下面的示例代码里看到它是如何使用的：</p><pre><code class=\"language-c++\">#include &lt;stdio.h&gt;\n#include &lt;boost/scope_exit.hpp&gt;\n\nvoid test()\n{\n  FILE* fp = fopen(\"test.cpp\", \"r\");\n  if (fp == NULL) {\n    perror(\"Cannot open file\");\n  }\n  BOOST_SCOPE_EXIT(&amp;fp) {\n    if (fp) {\n      fclose(fp);\n      puts(\"File is closed\");\n    }\n  } BOOST_SCOPE_EXIT_END\n  puts(\"Faking an exception\");\n  throw 42;\n}\n\nint main()\n{\n  try {\n    test();\n  }\n  catch (int) {\n    puts(\"Exception received\");\n  }\n}\n</code></pre><p>唯一需要说明的可能就是 <code>BOOST_SCOPE_EXIT</code> 里的那个 <code>&amp;</code> 符号了——把它理解成 lambda 表达式的按引用捕获就对了（虽然 <code>BOOST_SCOPE_EXIT</code> 可以支持 C++98 的代码）。如果不需要捕获任何变量，<code>BOOST_SCOPE_EXIT</code> 的参数必须填为 <code>void</code>。</p><p>输出为（假设 test.cpp 存在）：</p><blockquote>\n<p><code>Faking an exception</code><br>\n<code>File is closed</code><br>\n<code>Exception received</code></p>\n</blockquote><p>使用这个库也只需要头文件。注意实现类似的功能在 C++11 里相当容易，但由于 ScopeExit 可以支持 C++98 的代码，因而它的实现还是相当复杂的。</p><h2>Boost.Program_options</h2><p>传统上 C 代码里处理命令行参数会使用 <code>getopt</code>。我也用过，比如在下面的代码中：</p><p><a href=\"https://github.com/adah1972/breaktext/blob/master/breaktext.c\">https://github.com/adah1972/breaktext/blob/master/breaktext.c</a></p><p>这种方式有不少缺陷：</p><ul>\n<li>一个选项通常要在三个地方重复：说明文本里，<code>getopt</code> 的参数里，以及对 <code>getopt</code> 的返回结果进行处理时。不知道你觉得怎样，我反正发生过改了一处、漏改其他的错误。</li>\n<li>对选项的附加参数需要手工写代码处理，因而常常不够严格（C 的类型转换不够方便，尤其是检查错误）。</li>\n</ul><p>Program_options 正是解决这个问题的。这个代码有点老了，不过还挺实用；懒得去找特别的处理库时，至少这个伸手可用。使用这个库需要链接 boost_program_options 库。</p><p>下面的代码展示了代替上面的 <code>getopt</code> 用法的代码：</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;boost/program_options.hpp&gt;\n\nnamespace po = boost::program_options;\nusing std::cout;\nusing std::endl;\nusing std::string;\n\nstring locale;\nstring lang;\nint width = 72;\nbool keep_indent = false;\nbool verbose = false;\n\nint main(int argc, char* argv[])\n{\n  po::options_description desc(\n    \"Usage: breaktext [OPTION]... \"\n    \"&lt;Input File&gt; [Output File]\\n\"\n    \"\\n\"\n    \"Available options\");\n  desc.add_options()\n    (\"locale,L\",\n     po::value&lt;string&gt;(&amp;locale),\n     \"Locale of the console (system locale by default)\")\n    (\"lang,l\",\n     po::value&lt;string&gt;(&amp;lang),\n     \"Language of input (asssume no language by default)\")\n    (\"width,w\",\n     po::value&lt;int&gt;(&amp;width),\n     \"Width of output text (72 by default)\")\n    (\"help,h\", \"Show this help message and exit\")\n    (\",i\",\n     po::bool_switch(&amp;keep_indent),\n     \"Keep space indentation\")\n    (\",v\",\n     po::bool_switch(&amp;verbose),\n     \"Be verbose\");\n\n  po::variables_map vm;\n  try {\n    po::store(\n      po::parse_command_line(\n        argc, argv, desc),\n      vm);\n  }\n  catch (po::error&amp; e) {\n    cout &lt;&lt; e.what() &lt;&lt; endl;\n    exit(1);\n  }\n  vm.notify();\n\n  if (vm.count(\"help\")) {\n    cout &lt;&lt; desc &lt;&lt; \"\\n\";\n    exit(1);\n  }\n}\n</code></pre><p>略加说明一下：</p><ul>\n<li><code>options_description</code> 是基本的选项描述对象的类型，构造时我们给出对选项的基本描述。</li>\n<li><code>options_description</code> 对象的 <code>add_options</code> 成员函数会返回一个函数对象，然后我们直接用括号就可以添加一系列的选项。</li>\n<li>每个选项初始化时可以有两个或三个参数，第一项是选项的形式，使用长短选项用逗号隔开的字符串（可以只提供一种），最后一项是选项的文字描述，中间如果还有一项的话，就是选项的值描述。</li>\n<li>选项的值描述可以用 <code>value</code>、<code>bool_switch</code> 等方法，参数是输出变量的指针。</li>\n<li><code>variables_map</code>，变量映射表，用来存储对命令行的扫描结果；它继承了标准的 <code>std::map</code>。</li>\n<li><code>notify</code> 成员函数用来把变量映射表的内容实际传送到选项值描述里提供的那些变量里去。</li>\n<li><code>count</code> 成员函数继承自 <code>std::map</code>，只能得到 0 或 1 的结果。</li>\n</ul><p>这样，我们的程序就能处理上面的那些选项了。如果运行时在命令行加上 <code>-h</code> 或 <code>--help</code> 选项，程序就会输出跟原来类似的帮助输出——额外的好处是选项的描述信息较长时还能自动帮你折行，不需要手工排版了。建议你自己尝试一下，提供各种正确或错误的选项，来检查一下运行的结果。</p><p>当然现在有些更新的选项处理库，但它们应该都和 Program_options 更接近，而不是和 <code>getopt</code> 更接近。如果你感觉 Program_options 功能不足了，换一个其他库不会是件麻烦事。</p><h2>Boost.Hana</h2><p>Boost 里自然也有模板元编程相关的东西。但我不打算介绍 MPL、Fusion 和 Phoenix 那些，因为有些技巧，在 C++11 和 Lambda 表达式到来之后，已经略显得有点过时了。Hana 则不同，它是一个使用了 C++11/14 实现技巧和惯用法的新库，也和一般的模板库一样，只要有头文件就能使用。</p><p>Hana 里定义了一整套供<strong>编译期</strong>使用的数据类型和函数。我们现在看一下它提供的部分类型：</p><ul>\n<li><code>type</code>：把类型转化成对象（我们在<a href=\"https://time.geekbang.org/column/article/181608\">[第 13 讲]</a> 曾经示例过相反的动作，把数值转化成对象），来方便后续处理。</li>\n<li><code>integral_constant</code>：跟 <code>std::integral_constant</code> 相似，但定义了更多的运算符和语法糖。特别的，你可以用字面量来生成一个 <code>long long</code> 类型的 <code>integral_constant</code>，如 <code>1_c</code>。</li>\n<li><code>string</code>：一个编译期使用的字符串类型。</li>\n<li><code>tuple</code>：跟 <code>std::tuple</code> 类似，意图是当作编译期的 <code>vector</code> 来使用。</li>\n<li><code>map</code>：编译期使用的关联数组。</li>\n<li><code>set</code>：编译期使用的集合。</li>\n</ul><p>Hana 里的算法的名称跟标准库的类似，我就不一一列举了。下面的例子展示了一个基本用法：</p><pre><code class=\"language-c++\">#include &lt;boost/hana.hpp&gt;\nnamespace hana = boost::hana;\n\nclass shape {};\nclass circle {};\nclass triangle {};\n\nint main()\n{\n  using namespace hana::literals;\n\n  constexpr auto tup =\n    hana::make_tuple(\n      hana::type_c&lt;shape*&gt;,\n      hana::type_c&lt;circle&gt;,\n      hana::type_c&lt;triangle&gt;);\n\n  constexpr auto no_pointers =\n    hana::remove_if(\n      tup, [](auto a) {\n        return hana::traits::\n          is_pointer(a);\n      });\n\n  static_assert(\n    no_pointers ==\n    hana::make_tuple(\n      hana::type_c&lt;circle&gt;,\n      hana::type_c&lt;triangle&gt;));\n  static_assert(\n    hana::reverse(no_pointers) ==\n    hana::make_tuple(\n      hana::type_c&lt;triangle&gt;,\n      hana::type_c&lt;circle&gt;));\n  static_assert(\n    tup[1_c] == hana::type_c&lt;circle&gt;);\n}\n</code></pre><p>这个程序可以编译，但没有任何运行输出。在这个程序里，我们做了下面这几件事：</p><ul>\n<li>使用 <code>type_c</code> 把类型转化成 <code>type</code> 对象，并构造了类型对象的 <code>tuple</code></li>\n<li>使用 <code>remove_if</code> 算法移除了 <code>tup</code> 中的指针类型</li>\n<li>使用静态断言确认了结果是我们想要的</li>\n<li>使用静态断言确认了可以用 <code>reverse</code> 把 <code>tup</code> 反转一下</li>\n<li>使用静态断言确认了可以用方括号运算符来获取 <code>tup</code> 中的某一项</li>\n</ul><p>可以看到，Hana 本质上以类似普通的运行期编程的写法，来做编译期的计算。上面展示的只是一些最基本的用法，而 Hana 的文档里展示了很多有趣的用法。尤其值得一看的是，文档中展示了如何利用 Hana 提供的机制，来自己定义 <code>switch_</code>、<code>case_</code>、<code>default_</code>，使得下面的代码可以通过编译：</p><pre><code class=\"language-c++\">boost::any a = 'x';\nstd::string r =\n  switch_(a)(\n    case_&lt;int&gt;([](auto i) {\n      return \"int: \"s +\n             std::to_string(i);\n    }),\n    case_&lt;char&gt;([](auto c) {\n      return \"char: \"s +\n             std::string{c};\n    }),\n    default_(\n      [] { return \"unknown\"s; }));\nassert(r == \"char: x\"s);\n</code></pre><p>我个人认为很有意思。</p><h2>内容小结</h2><p>本讲我们对 Boost 的意义做了概要介绍，并蜻蜓点水地简单描述了若干 Boost 库的功能。如果你想进一步了解 Boost 的细节的话，就得自行查看文档了。</p><h2>课后思考</h2><p>请你考虑一下，我今天描述的 Boost 库里的功能是如何实现的。然后自己去看一下源代码（开源真是件大好事！），检查一下跟自己想象的是不是有出入。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Boost C++ Libraries. <a href=\"https://www.boost.org/\">https://www.boost.org/</a> </span></p><p><span class=\"reference\">[2] David Abarahams and Aleksey Gurtovoy, <em>C++ Template Metaprogramming</em>. Addison-Wesley, 2004. 有中文版（荣耀译，机械工业出版社，2010 年） </span></p>","neighbors":{"left":{"article_title":"23 | 数字计算：介绍线性代数和数值计算库","id":189042},"right":{"article_title":"25 | 两个单元测试库：C++里如何进行单元测试?","id":191714}},"comments":[{"had_liked":false,"id":173220,"user_name":"风羽星泉","can_delete":false,"product_type":"c1","uid":1198377,"ip_address":"","ucode":"CBC63AA00C5D70","user_header":"https://static001.geekbang.org/account/avatar/00/12/49/29/bbeccb9f.jpg","comment_is_top":false,"comment_ctime":1579481015,"is_pvip":false,"replies":[{"id":67279,"content":"定义一个RAII类模板，构造时接受一个lambda表达式，把它存到成员里。析构时调用这个成员就行啦。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1579602531,"ip_address":"","comment_id":173220,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师的文章里提到：“实现类似（Boost.ScopeExit）的功能在 C++11 里相当容易“。能教我怎么实现吗？","like_count":7},{"had_liked":false,"id":184614,"user_name":"Geek_Frank","can_delete":false,"product_type":"c1","uid":1757456,"ip_address":"","ucode":"5984DF79629DC9","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/k9xeicX1iasjoNmVMTPcKIuvn0Uf8hWHraQicz8AHK8Ewb1icWUrQ0pwUp5MsyGxv5EgvjH6CpUzKvL53bkaaALqgg/132","comment_is_top":false,"comment_ctime":1583371689,"is_pvip":false,"replies":[{"id":71418,"content":"不熟，没法给出技术评价。\n\n从理念上来说，我不喜欢大框架。小而精的东西更容易和其他东西组合。而框架的东西，一旦用了某一个，就很难在重叠的领域用其他的东西，总体不见得有利。也就初期上手可能容易些吧，从学习的角度，还是可以看看。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1583386788,"ip_address":"","comment_id":184614,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"您好，POCO库您觉得怎么样？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482000,"discussion_content":"定义一个RAII类模板，构造时接受一个lambda表达式，把它存到成员里。析构时调用这个成员就行啦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579602531,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173221,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1579481075,"is_pvip":false,"replies":[{"id":67281,"content":"可以看自己感兴趣的实现。都看（太多了）没必要。另外，Boost很多库都是前C++11的，有些技巧现在已经不必要了，这点留意一下。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1579602796,"ip_address":"","comment_id":173221,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，通过看某些源代码来学习现代C++，看Boost库的，是一个好的开始不？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486066,"discussion_content":"不熟，没法给出技术评价。\n\n从理念上来说，我不喜欢大框架。小而精的东西更容易和其他东西组合。而框架的东西，一旦用了某一个，就很难在重叠的领域用其他的东西，总体不见得有利。也就初期上手可能容易些吧，从学习的角度，还是可以看看。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583386788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1014142,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/79/7e/c38ac02f.jpg","nickname":"北冥Master","note":"","ucode":"EBCCEC79AFC5DF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":199939,"discussion_content":"poco网络库很常见啊，很多系统都用，比如clickhouse","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583638878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757456,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/k9xeicX1iasjoNmVMTPcKIuvn0Uf8hWHraQicz8AHK8Ewb1icWUrQ0pwUp5MsyGxv5EgvjH6CpUzKvL53bkaaALqgg/132","nickname":"Geek_Frank","note":"","ucode":"5984DF79629DC9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":197196,"discussion_content":"好的 感谢指导，同意您的观点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583412573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":389410,"user_name":"小一日一","can_delete":false,"product_type":"c1","uid":1301097,"ip_address":"北京","ucode":"0A506C2B918C14","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtVXiaJbfkpeXH4udkPUIlFte7z3HWMebdogk8jFpgFEkJ0ruGiawUMUcZj9RLpLkIWxV7QOzbHoSg/132","comment_is_top":false,"comment_ctime":1712474657,"is_pvip":false,"replies":[{"id":141686,"content":"见“课前必读”。我的预设是所有代码都用 c++17 标准（除了那些要求 20 的）。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1712704496,"ip_address":"上海","comment_id":389410,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"使用低版本的 G++ 编译器编译老师提供的 Hana 例子，需要加 -std=c++17","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":641490,"discussion_content":"见“课前必读”。我的预设是所有代码都用 c++17 标准（除了那些要求 20 的）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1712704497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":355596,"user_name":"Ben","can_delete":false,"product_type":"c1","uid":1983916,"ip_address":"上海","ucode":"9BD8D8CE0DFD12","user_header":"https://static001.geekbang.org/account/avatar/00/1e/45/ac/3dc59a5e.jpg","comment_is_top":false,"comment_ctime":1661520138,"is_pvip":false,"replies":[{"id":129525,"content":"奇怪，我没有遇到类似问题……\n\n这是我在第 23 讲代码的 cmake 输出：\n\n-- Found Armadillo: &#47;usr&#47;local&#47;include (found version &quot;11.2.3&quot;) \n-- Found Boost: &#47;usr&#47;local&#47;lib&#47;cmake&#47;Boost-1.78.0&#47;BoostConfig.cmake (found version &quot;1.78.0&quot;)  \n-- Found GMP: &#47;usr&#47;local&#47;include  \n","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1661836424,"ip_address":"上海","comment_id":355596,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"吴老师，我希望分享一个踩坑经历。在mac brew 安装之后大概率要使用pkg-config 这个命令告诉编译器 Armadillo的位置。要不然安装之后cmake 找不到。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585809,"discussion_content":"奇怪，我没有遇到类似问题……\n\n这是我在第 23 讲代码的 cmake 输出：\n\n-- Found Armadillo: /usr/local/include (found version &#34;11.2.3&#34;) \n-- Found Boost: /usr/local/lib/cmake/Boost-1.78.0/BoostConfig.cmake (found version &#34;1.78.0&#34;)  \n-- Found GMP: /usr/local/include  \n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661836424,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333789,"user_name":"weing","can_delete":false,"product_type":"c1","uid":1984655,"ip_address":"","ucode":"95701BDA31F6F6","user_header":"","comment_is_top":false,"comment_ctime":1644536581,"is_pvip":false,"replies":[{"id":121966,"content":"内存池基本上是一种定制的东西……我有计划补充一下这方面的内容。如果急着看这方面的内容的话，可以看一下我个人网站上的英文文章 http:&#47;&#47;wyw.dcweb.cn&#47;","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1644583409,"ip_address":"","comment_id":333789,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，有推荐的C++ 内存池库吗？\n想在C++代码里使用内存池进行内存管理","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585809,"discussion_content":"奇怪，我没有遇到类似问题……\n\n这是我在第 23 讲代码的 cmake 输出：\n\n-- Found Armadillo: /usr/local/include (found version &#34;11.2.3&#34;) \n-- Found Boost: /usr/local/lib/cmake/Boost-1.78.0/BoostConfig.cmake (found version &#34;1.78.0&#34;)  \n-- Found GMP: /usr/local/include  \n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661836424,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173209,"user_name":"Sochooligan","can_delete":false,"product_type":"c1","uid":1318528,"ip_address":"","ucode":"B66F78B6B86476","user_header":"https://static001.geekbang.org/account/avatar/00/14/1e/80/e409fff6.jpg","comment_is_top":false,"comment_ctime":1579479565,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"来了，来了。","like_count":0},{"had_liked":false,"id":173220,"user_name":"风羽星泉","can_delete":false,"product_type":"c1","uid":1198377,"ip_address":"","ucode":"CBC63AA00C5D70","user_header":"https://static001.geekbang.org/account/avatar/00/12/49/29/bbeccb9f.jpg","comment_is_top":false,"comment_ctime":1579481015,"is_pvip":false,"replies":[{"id":67279,"content":"定义一个RAII类模板，构造时接受一个lambda表达式，把它存到成员里。析构时调用这个成员就行啦。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1579602531,"ip_address":"","comment_id":173220,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师的文章里提到：“实现类似（Boost.ScopeExit）的功能在 C++11 里相当容易“。能教我怎么实现吗？","like_count":7,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482000,"discussion_content":"定义一个RAII类模板，构造时接受一个lambda表达式，把它存到成员里。析构时调用这个成员就行啦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579602531,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184614,"user_name":"Geek_Frank","can_delete":false,"product_type":"c1","uid":1757456,"ip_address":"","ucode":"5984DF79629DC9","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/k9xeicX1iasjoNmVMTPcKIuvn0Uf8hWHraQicz8AHK8Ewb1icWUrQ0pwUp5MsyGxv5EgvjH6CpUzKvL53bkaaALqgg/132","comment_is_top":false,"comment_ctime":1583371689,"is_pvip":false,"replies":[{"id":71418,"content":"不熟，没法给出技术评价。\n\n从理念上来说，我不喜欢大框架。小而精的东西更容易和其他东西组合。而框架的东西，一旦用了某一个，就很难在重叠的领域用其他的东西，总体不见得有利。也就初期上手可能容易些吧，从学习的角度，还是可以看看。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1583386788,"ip_address":"","comment_id":184614,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"您好，POCO库您觉得怎么样？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486066,"discussion_content":"不熟，没法给出技术评价。\n\n从理念上来说，我不喜欢大框架。小而精的东西更容易和其他东西组合。而框架的东西，一旦用了某一个，就很难在重叠的领域用其他的东西，总体不见得有利。也就初期上手可能容易些吧，从学习的角度，还是可以看看。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583386788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1014142,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/79/7e/c38ac02f.jpg","nickname":"北冥Master","note":"","ucode":"EBCCEC79AFC5DF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":199939,"discussion_content":"poco网络库很常见啊，很多系统都用，比如clickhouse","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583638878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757456,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/k9xeicX1iasjoNmVMTPcKIuvn0Uf8hWHraQicz8AHK8Ewb1icWUrQ0pwUp5MsyGxv5EgvjH6CpUzKvL53bkaaALqgg/132","nickname":"Geek_Frank","note":"","ucode":"5984DF79629DC9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":197196,"discussion_content":"好的 感谢指导，同意您的观点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583412573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173221,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1579481075,"is_pvip":false,"replies":[{"id":67281,"content":"可以看自己感兴趣的实现。都看（太多了）没必要。另外，Boost很多库都是前C++11的，有些技巧现在已经不必要了，这点留意一下。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1579602796,"ip_address":"","comment_id":173221,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，通过看某些源代码来学习现代C++，看Boost库的，是一个好的开始不？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482001,"discussion_content":"可以看自己感兴趣的实现。都看（太多了）没必要。另外，Boost很多库都是前C++11的，有些技巧现在已经不必要了，这点留意一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579602796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":389410,"user_name":"小一日一","can_delete":false,"product_type":"c1","uid":1301097,"ip_address":"北京","ucode":"0A506C2B918C14","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtVXiaJbfkpeXH4udkPUIlFte7z3HWMebdogk8jFpgFEkJ0ruGiawUMUcZj9RLpLkIWxV7QOzbHoSg/132","comment_is_top":false,"comment_ctime":1712474657,"is_pvip":false,"replies":[{"id":141686,"content":"见“课前必读”。我的预设是所有代码都用 c++17 标准（除了那些要求 20 的）。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1712704496,"ip_address":"上海","comment_id":389410,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"使用低版本的 G++ 编译器编译老师提供的 Hana 例子，需要加 -std=c++17","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482001,"discussion_content":"可以看自己感兴趣的实现。都看（太多了）没必要。另外，Boost很多库都是前C++11的，有些技巧现在已经不必要了，这点留意一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579602796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":355596,"user_name":"Ben","can_delete":false,"product_type":"c1","uid":1983916,"ip_address":"上海","ucode":"9BD8D8CE0DFD12","user_header":"https://static001.geekbang.org/account/avatar/00/1e/45/ac/3dc59a5e.jpg","comment_is_top":false,"comment_ctime":1661520138,"is_pvip":false,"replies":[{"id":129525,"content":"奇怪，我没有遇到类似问题……\n\n这是我在第 23 讲代码的 cmake 输出：\n\n-- Found Armadillo: &#47;usr&#47;local&#47;include (found version &quot;11.2.3&quot;) \n-- Found Boost: &#47;usr&#47;local&#47;lib&#47;cmake&#47;Boost-1.78.0&#47;BoostConfig.cmake (found version &quot;1.78.0&quot;)  \n-- Found GMP: &#47;usr&#47;local&#47;include  \n","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1661836424,"ip_address":"上海","comment_id":355596,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"吴老师，我希望分享一个踩坑经历。在mac brew 安装之后大概率要使用pkg-config 这个命令告诉编译器 Armadillo的位置。要不然安装之后cmake 找不到。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":641490,"discussion_content":"见“课前必读”。我的预设是所有代码都用 c++17 标准（除了那些要求 20 的）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1712704497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333789,"user_name":"weing","can_delete":false,"product_type":"c1","uid":1984655,"ip_address":"","ucode":"95701BDA31F6F6","user_header":"","comment_is_top":false,"comment_ctime":1644536581,"is_pvip":false,"replies":[{"id":121966,"content":"内存池基本上是一种定制的东西……我有计划补充一下这方面的内容。如果急着看这方面的内容的话，可以看一下我个人网站上的英文文章 http:&#47;&#47;wyw.dcweb.cn&#47;","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1644583409,"ip_address":"","comment_id":333789,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，有推荐的C++ 内存池库吗？\n想在C++代码里使用内存池进行内存管理","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550548,"discussion_content":"内存池基本上是一种定制的东西……我有计划补充一下这方面的内容。如果急着看这方面的内容的话，可以看一下我个人网站上的英文文章 http://wyw.dcweb.cn/","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644583409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173209,"user_name":"Sochooligan","can_delete":false,"product_type":"c1","uid":1318528,"ip_address":"","ucode":"B66F78B6B86476","user_header":"https://static001.geekbang.org/account/avatar/00/14/1e/80/e409fff6.jpg","comment_is_top":false,"comment_ctime":1579479565,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"来了，来了。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550548,"discussion_content":"内存池基本上是一种定制的东西……我有计划补充一下这方面的内容。如果急着看这方面的内容的话，可以看一下我个人网站上的英文文章 http://wyw.dcweb.cn/","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644583409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}