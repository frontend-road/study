{"id":740898,"title":"附录 B 将应用程序打包为 Docker 镜像","content":"\n<p>在 5.3 节中，我们详细介绍了 Spring Boot 应用的打包过程，打包的 Fat Jar 可以直接用 <code>java -jar</code> 命令运行。但在实际生产过程中，Fat Jar 未必是最终交付物，在广泛使用 Kubernetes 的今天，交付一个 Docker 镜像也许会更合适一些。接下来，就让我们来了解下如何将 Spring Boot 应用打包成 Docker 镜像。</p>\n<p>传统的打包运行就三步：</p>\n<ul>\n<li>编写 Dockerfile</li>\n<li>使用打包命令构建镜像</li>\n<li>运行镜像</li>\n</ul>\n<h2 id=\"nav_point_263\">B.1　编写 Dockerfile</h2>\n<p>先来看看最简单的方式，直接编写一个 Dockfile，将打包好的 Fat Jar 文件复制到镜像中，然后通过 <code>docker</code> 命令执行构建。此处，我们仍然以第 10 章的 binarytea-jwt-auth 作为例子 <span class=\"comment-number\">1</span>，在项目目录中添加一个 Dockerfile 文件，具体内容如代码示例 B-1 所示。</p>\n\n<blockquote>\n<p><strong>代码示例 B-1</strong>　一个简单的 Dockerfile 示例</p>\n</blockquote>\n<pre class=\"code-rows\"><code>FROM openjdk:11\nARG JAR_FILE\nCOPY $ app.jar\nENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"]</code></pre>\n<p>在这个文件中，我们一共做了四件事：</p>\n<p>(1) 指定了基础镜像，这里选择了 OpenJDK 11 的官方镜像；</p><!-- [[[read_end]]] -->\n<p>(2) 声明了一个 <code>JAR_FILE</code> 参数，代表我们要复制到镜像中的 Jar 文件；</p>\n<p>(3) 将指定的 Jar 文件复制到 app.jar；</p>\n<p>(4) 指定镜像启动的入口，使用命令 <code>java -jar /app.jar</code><span class=\"comment-number\">2</span>。</p>\n\n<p>这只是一个很简单的 Dockerfile，感兴趣的同学可以参考官方文档，了解更多的指令，表 B-1 中罗列了一些常用的内容。</p>\n<p><strong>表 B-1　一些常用的 Dockerfile 指令</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>指令</p></th>\n<th><p>格式 <span class=\"comment-number\">3</span></p></th>\n<th><p>说明</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>ARG</code></p></td>\n<td><p><code>ARG &lt;name&gt;[=&lt;default value&gt;]</code></p></td>\n<td><p>定义构建时可在命令中传入的参数</p></td>\n</tr>\n<tr>\n<td><p><code>CMD</code></p></td>\n<td><p><code>CMD [\"executable\",\"param1\",\"param2\"]</code></p></td>\n<td><p>指定容器的默认执行命令，Dockerfile 中只能有一个有效的 <code>CMD</code> 指令，如果有多条，则最后一条会生效</p></td>\n</tr>\n<tr>\n<td><p><code>COPY</code></p></td>\n<td><p><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</code></p></td>\n<td><p>将文件复制到目标位置，目标位置可以是绝对路径，也可以是相对于 <code>WORKDIR</code> 的相对路径</p></td>\n</tr>\n<tr>\n<td><p><code>ENTRYPOINT</code></p></td>\n<td><p><code>ENTRYPOINT [\"executable\", \"param1\", \"param2\"]</code></p></td>\n<td><p>指定容器运行时的命令，Dockerfile 中只能有一个有效的 <code>ENTRYPOINT</code> 指令，如果有多条，则最后一条会生效</p></td>\n</tr>\n<tr>\n<td><p><code>ENV</code></p></td>\n<td><p><code>ENV &lt;key&gt;=&lt;value&gt; ...</code></p></td>\n<td><p>指定环境变量</p></td>\n</tr>\n<tr>\n<td><p><code>EXPOSE</code></p></td>\n<td><p><code>EXPOSE &lt;port&gt;[/&lt;protocol&gt;] [&lt;port&gt;/&lt;protocol&gt;...]</code></p></td>\n<td><p>指定容器要监听的端口</p></td>\n</tr>\n<tr>\n<td><p><code>FROM</code></p></td>\n<td><p><code>FROM [--platform=&lt;platform&gt;] &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]</code></p></td>\n<td><p>初始化构建过程，为后续指令设置基础镜像</p></td>\n</tr>\n<tr>\n<td><p><code>LABEL</code></p></td>\n<td><p><code>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</code></p></td>\n<td><p>为镜像添加标签</p></td>\n</tr>\n<tr>\n<td><p><code>RUN</code></p></td>\n<td><p><code>RUN &lt;command&gt;</code></p></td>\n<td><p>在镜像的当前层上执行命令，包含执行结果的镜像会被用于 Dockerfile 中的后续步骤</p></td>\n</tr>\n<tr>\n<td><p><code>VOLUME</code></p></td>\n<td><p><code>VOLUME &lt; 挂载点 &gt; ...</code></p></td>\n<td><p>指定一个或多个挂载点</p></td>\n</tr>\n<tr>\n<td><p><code>WORKDIR</code></p></td>\n<td><p><code>WORKDIR &lt; 路径 &gt;</code></p></td>\n<td><p>指定工作路径</p></td>\n</tr>\n</tbody>\n</table>\n\n<blockquote>\n<p><strong>茶歇时间：如何选择基础 Java Docker 镜像</strong></p>\n<p>在构建镜像时，需要选择基础镜像，一般公司都会维护一个内部的基础镜像，提供最基本的功能。作为一个 Java 程序，自然在运行时需要 Java 环境，通常会安装 JDK。有些场景下，出于安全考虑，也会限制只安装 JRE。</p>\n<p>在 Docker Hub 上，我们能找到不同 Java 发行版的镜像，如果没有强制要求，也可以考虑用表 B-2 中的镜像作为基础，再进行定制。例如，运行在 AWS 上，可以选择 Amazon 的 Corretto；要用来跑 SAP 的服务，则可以考虑 SapMachine。</p>\n<p><strong>表 B-2　一些不同 Java 发行版的镜像</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>镜像名称</p></th>\n<th><p>发行版</p></th>\n<th><p>供应商</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>openjdk</p></td>\n<td><p>OpenJDK</p></td>\n<td><p>Oracle</p></td>\n</tr>\n<tr>\n<td><p>amazoncorretto</p></td>\n<td><p>Corretto</p></td>\n<td><p>Amazon</p></td>\n</tr>\n<tr>\n<td><p>eclipse-temurin</p></td>\n<td><p>Temurin</p></td>\n<td><p>Eclipse</p></td>\n</tr>\n<tr>\n<td><p>ibm-semeru-runtimes</p></td>\n<td><p>Semeru</p></td>\n<td><p>IBM</p></td>\n</tr>\n<tr>\n<td><p>sapmachine</p></td>\n<td><p>SapMachine</p></td>\n<td><p>SAP</p></td>\n</tr>\n<tr>\n<td><p>azul/zulu-openjdk</p></td>\n<td><p>Zulu</p></td>\n<td><p>Azul</p></td>\n</tr>\n<tr>\n<td><p>dragonwell/dragonwell<span class=\"comment-number\">4</span></p></td>\n<td><p>Dragonwell（龙井）</p></td>\n<td><p>阿里巴巴</p></td>\n</tr>\n<tr>\n<td><p>konajdk/konajdk</p></td>\n<td><p>KonaJDK</p></td>\n<td><p>腾讯</p></td>\n</tr>\n</tbody>\n</table>\n<p>表中的镜像都提供了不同 Java 版本的镜像，通过 Tag 可以选择版本。<span class=\"comment-number\">5</span> 此外，不少镜像的标签中还有 <code>-alpine</code> 字样，这是基于 Alpine Linux 打包的镜像。Alpine Linux 的镜像会比一般 Linux 要小不少，但由于它使用的是 musl C 库而不是 glibc 库，所以有些软件的运行可能会有问题。OpenJDK 中的 Portola 项目就是专门用来支持 OpenJDK 的 Alpine 移植的，该项目尚处于早期阶段，还不能用于生产环境，所以建议大家慎重选择带 <code>-alpine</code> 字样的标签。</p>\n<p>假设要用 Amazon Corretto 17 的版本，在 Dockerfile 中可以这样来写：</p>\n<pre class=\"code-rows\"><code>FROM amazoncorretto:17</code></pre>\n<p>要直接拉取镜像，则可以执行：</p>\n<pre class=\"code-rows\"><code>docker pull amazoncorretto:17</code></pre>\n</blockquote>\n\n\n<h2 id=\"nav_point_264\">B.2　构建并运行镜像</h2>\n<p>通过 Dockerfile 构建镜像的方法十分简单，直接利用 <code>docker build</code> 命令即可，在项目目录中，执行如下命令：</p>\n<pre class=\"code-rows\"><code>▸ docker build --build-arg JAR_FILE=target/binarytea-0.0.1-SNAPSHOT.jar -t learning.spring/binarytea .</code></pre>\n<p>命令执行后会看到类似下面的输出（如果是第一次执行，还需要等待各种镜像的下载，会花一些时间 <span class=\"comment-number\">6</span>）：</p>\n\n<pre class=\"code-rows\"><code>[+] Building 0.6s (7/7) FINISHED\n =&gt; [internal] load build definition from Dockerfile                                                0.0s\n =&gt; =&gt; transferring dockerfile: 36B                                                                 0.0s\n =&gt; [internal] load .dockerignore                                                                   0.0s\n =&gt; =&gt; transferring context: 2B                                                                     0.0s\n =&gt; [internal] load metadata for docker.io/library/openjdk:11                                       0.6s\n =&gt; [1/2] FROM docker.io/library/openjdk:11@sha256:33c346c637ebb17823cbeda4d4e5601\n c66262752dadcae559a03b090f6505a47                                                                  0.0s\n =&gt; [internal] load build context                                                                   0.0s\n =&gt; =&gt; transferring context: 85B                                                                    0.0s\n =&gt; CACHED [2/2] COPY target/binarytea-0.0.1-SNAPSHOT.jar app.jar                                   0.0s\n =&gt; exporting to image                                                                              0.0s\n =&gt; =&gt; exporting layers                                                                             0.0s\n =&gt; =&gt; writing image sha256:1ead3f3b24e24d2ab9d3dbe76b85b8c20db7574935a1b688924e7c313e01a92e        0.0s\n =&gt; =&gt; naming to learning.spring/binarytea                                                          0.0s</code></pre>\n<p>表 B-3 罗列了 <code>build</code> 命令的一些常用参数，更多信息可以查看 Docker 的官方文档。</p>\n<p><strong>表 B-3　<code>docker build</code> 命令的一些常用参数</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>参数</p></th>\n<th><p>默认值</p></th>\n<th><p>说明</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>--tag</code> 或 <code>-t</code></p></td>\n<td><p>&nbsp;</p></td>\n<td><p>指定镜像的名称与标签，格式是 <code>name:tag</code></p></td>\n</tr>\n<tr>\n<td><p><code>--file</code> 或 <code>-f</code></p></td>\n<td><p>当前位置的 Dockerfile</p></td>\n<td><p>指定要用于构建的 Dockerfile</p></td>\n</tr>\n<tr>\n<td><p><code>--build-arg</code></p></td>\n<td><p>&nbsp;</p></td>\n<td><p>设置构建时使用的参数</p></td>\n</tr>\n<tr>\n<td><p><code>--label</code></p></td>\n<td><p>&nbsp;</p></td>\n<td><p>设置镜像的元数据</p></td>\n</tr>\n<tr>\n<td><p><code>--quiet</code> 或 <code>-q</code></p></td>\n<td><p>&nbsp;</p></td>\n<td><p>抑制构建时的输出信息</p></td>\n</tr>\n<tr>\n<td><p><code>--no-cache</code></p></td>\n<td><p>&nbsp;</p></td>\n<td><p>构建时不使用缓存</p></td>\n</tr>\n</tbody>\n</table>\n<p>完成构建后，通过下面的命令就能在本地启动一个 BinaryTea 服务了：</p>\n<pre class=\"code-rows\"><code>▸ docker run -d -p 8080:8080 --name binarytea learning.spring/binarytea</code></pre>\n<h2 id=\"nav_point_265\">B.3　构建分层镜像</h2>\n<p>把 Fat Jar 作为一个整体打包在镜像里，意味着后续每次更新都需要完整拉取基础镜像以外的内容。但实际上，应用系统的发布更多时候只是调整了代码，对其依赖的调整相对较少，而升级 Spring 相关版本的情况就更少了。如果我们能把这些内容分成镜像中的不同层来存放，那在更新时，很有可能就只需要拉取业务代码部分。</p>\n<p>Spring Boot 为我们提供了一个简单的分层工具 spring-boot-jarmode-layertools，它默认会将 Fat Jar 展开，分成如下四层：</p>\n<ul>\n<li>dependencies，放置已正式发布的各种依赖，都在 BOOT-INF/lib 下；</li>\n<li>spring-boot-loader，放置 Spring Boot 启动相关的内容，都在 org/springframework/boot/loader 下；</li>\n<li>snapshot-dependencies，放置快照版本的各种依赖，都在 BOOT-INF/lib 下；</li>\n<li>application，放置应用的各种类和资源，都在 META-INF 和 BOOT-INF/classes 下。</li>\n</ul>\n<p>在 Dockerfile 中每执行一次 <code>COPY</code> 指令，都会新建一层，可以自己把 Fat Jar 展开复制多次，有了 spring-boot-jarmode-layertools，我们可以通过它来展开 Fat Jar。通过如下命令可以展开：</p>\n<pre class=\"code-rows\"><code>▸ java -Djarmode=layertools -jar target/binarytea-0.0.1-SNAPSHOT.jar extract</code></pre>\n<p>我们对 Dockerfile 稍作调整，将构建动作分成两部分，先展开 Fat Jar，然后分四层复制文件，将这个文件命名为 Dockerfile-layering，具体如代码示例 B-2 所示。</p>\n<blockquote>\n<p><strong>代码示例 B-2</strong>　Dockerfile-layering 文件内容</p>\n</blockquote>\n<pre class=\"code-rows\"><code>FROM openjdk:11 as builder\nWORKDIR application\nARG JAR_FILE\nCOPY $ app.jar\nRUN java -Djarmode=layertools -jar app.jar extract\n\nFROM openjdk:11\nWORKDIR application\nCOPY --from=builder application/dependencies/ ./\nCOPY --from=builder application/spring-boot-loader/ ./\nCOPY --from=builder application/snapshot-dependencies/ ./\nCOPY --from=builder application/application/ ./\nENTRYPOINT [\"java\", \"org.springframework.boot.loader.JarLauncher\"]</code></pre>\n<p>该文件对应的构建命令如下（通过 <code>-f</code> 指定了要使用的 Dockerfile）：</p>\n<pre class=\"code-rows\"><code>▸ docker build --build-arg JAR_FILE=target/binarytea-0.0.1-SNAPSHOT.jar -f Dockerfile-layering -t\nlearning.spring/binarytea .</code></pre>\n<p>在运行镜像后，可以用如下命令进入运行时的容器，可以看到文件系统里的内容。连接进入容器后，我们已经在 /application 目录里了，这就是 <code>WORKDIR</code> 指定的位置，展开后的内容全在 /application 目录里。</p>\n<pre class=\"code-rows\"><code>▸ docker run -p 8080:8080 -d --name binarytea learning.spring/binarytea\nc22898aa9901cd9909dd07515d62c8256c07a7b3e951c7da25541c4a854e7613\n▸ docker exec -it binarytea /bin/bash\nroot@c22898aa9901:/application# ls\nBOOT-INF META-INF org\nroot@c22898aa9901:/application# ls BOOT-INF/\nclasses classpath.idx layers.idx lib</code></pre>\n<h2 id=\"nav_point_266\">B.4　其他打包方式</h2>\n<p>Spring Boot 还支持使用 Spring Boot Maven Plugin 的方式进行 Docker 镜像构建，无须编写 Dockerfile，直接通过如下的命令就能构建出一个 Docker 镜像：</p>\n<pre class=\"code-rows\"><code>▸ mvn spring-boot:build-image</code></pre>\n<p>所有与镜像构建相关的配置，都可以放在 pom.xml 中 spring-boot-maven-plugin 的 <code>&lt;configuration/&gt;</code> 中。该插件会通过 Cloud Native Buildpacks 完成打包工作，在这个过程中会通过网络下载很多内容，默认用的是 BellSoft 的 Liberica OpenJDK。不得不提的是在当前的网络环境下，整个的下载和构建过程可能非常的慢，而且极容易出问题。此外，该插件的自定义配置也不够灵活，可能<strong>不是</strong>构建的最佳选择。</p>\n<p>我们也可以选择 Spotify 的 dockerfile-maven-plugin 来进行构建，它依然需要编写 Dockerfile，但可以实现一些自动化的构建与发布工作，感兴趣的同学可以通过官方文档了解更多信息。</p>\n<p>综合来看，编写 Dockerfile 随后通过 <code>docker build</code> 命令构建镜像，基本能够应付大部分场景。通过持续集成设施能够将应用构建、Docker 镜像构建、镜像发布与部署等动作完整地集成到一起。</p>\n\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"附录 A 从 Spring Boot 2. 升级到 3.0","id":740897},"right":{"article_title":"附录 C 通过 Spring Native 打包本地镜像","id":740899}},"comments":[]}