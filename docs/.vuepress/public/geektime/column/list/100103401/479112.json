{"id":479112,"title":"09 | 委托：你为何总是被低估？","content":"<p>你好，我是朱涛。今天我们来学习Kotlin的委托特性。</p><p>Kotlin的委托主要有两个应用场景，一个是委托类，另一个是委托属性。对比第6讲我们学过的<a href=\"https://time.geekbang.org/column/article/475684\">扩展</a>来看的话，Kotlin委托这个特性就没有那么“神奇”了。</p><p>因为扩展可以从类的外部，为一个类“添加”成员方法和属性，因此Kotlin扩展的应用场景也十分明确，而Kotlin委托的应用场景就没那么清晰了。这也是很多人会“重视扩展”，而“轻视委托”的原因。</p><p>然而，我要告诉你的是，<strong>Kotlin“委托”的重要性一点也不比“扩展”低</strong>。Kotlin委托在软件架构中可以发挥巨大的作用，在掌握了Kotlin委托特性后，你不仅可以改善应用的架构，还可以大大提升开发效率。</p><p>另外，如果你是Android工程师，你会发现Jetpack Compose当中大量使用了Kotlin委托特性。可以说，如果你不理解委托，你就无法真正理解Jetpack Compose。</p><p>看到这里，想必你也已经知道Kotlin委托的重要性了，接下来就来开启我们的学习之旅吧！</p><h2>委托类</h2><p>我们先从委托类开始，它的使用场景非常简单易懂：它常常用于实现类的“委托模式”。我们来看个简单例子：</p><pre><code class=\"language-plain\">interface DB {\n    fun save()\n}\n\nclass SqlDB() : DB {\n    override fun save() { println(\"save to sql\") }\n}\n\nclass GreenDaoDB() : DB {\n    override fun save() { println(\"save to GreenDao\") }\n}\n//               参数  通过 by 将接口实现委托给 db \n//                ↓            ↓\nclass UniversalDB(db: DB) : DB by db\n\nfun main() {\n    UniversalDB(SqlDB()).save()\n    UniversalDB(GreenDaoDB()).save()\n}\n\n/*\n输出：\nsave to sql\nsave to GreenDao\n*/\n</code></pre><!-- [[[read_end]]] --><p>以上的代码当中，我们定义了一个DB接口，它的save()方法用于数据库存储，SqlDB和GreenDaoDB都实现了这个接口。接着，我们的UniversalDB也实现了这个接口，同时通过by这个关键字，将接口的实现委托给了它的参数db。</p><p>这种委托模式在我们的实际编程中十分常见，UniversalDB相当于一个壳，它虽然实现了DB这个接口，但并不关心它怎么实现。具体是用SQL还是GreenDao，传不同的委托对象进去，它就会有不同的行为。</p><p>另外，以上委托类的写法，等价于以下Java代码，我们可以再进一步来看下：</p><pre><code class=\"language-java\">class UniversalDB implements DB {\n    DB db;\n    public UniversalDB(DB db) { this.db = db; }\n             //  手动重写接口，将 save 委托给 db.save()\n    @Override//            ↓\n    public void save() { db.save(); }\n}\n</code></pre><p>以上代码显示，save()将执行流程委托给了传入的db对象。所以说，Kotlin的委托类提供了<strong>语法层面的委托模式</strong>。通过这个by关键字，就可以自动将接口里的方法委托给一个对象，从而可以帮我们省略很多接口方法适配的模板代码。</p><p>委托类很好理解，下面让我们重点来看看Kotlin的委托属性。</p><h2>委托属性</h2><p>正如我们前面所讲的，<strong>Kotlin“委托类”委托的是接口方法，而“委托属性”委托的，则是属性的getter、setter。</strong>在<a href=\"https://time.geekbang.org/column/article/472154\">第1讲</a>中，我们知道val定义的属性，它只有get()方法；而var定义的属性，既有get()方法，也有set()方法。</p><p>那么，属性的getter、setter委托出去以后，能有什么用呢？我们可以从Kotlin官方提供的标准委托那里找到答案。</p><h3>标准委托</h3><p>Kotlin提供了好几种标准委托，其中包括两个属性之间的直接委托、by lazy懒加载委托、Delegates.observable观察者委托，以及by map映射委托。前面两个的使用频率比较高，后面两个频率比较低。这里，我们就主要来了解下前两种委托属性。</p><p><strong>将属性A委托给属性B</strong></p><p>从Kotlin 1.4 开始，我们可以直接在语法层面将“属性A”委托给“属性B”，就像下面这样：</p><pre><code class=\"language-plain\">class Item {\n    var count: Int = 0\n    //              ①  ②\n    //              ↓   ↓\n    var total: Int by ::count\n}\n</code></pre><p>以上代码定义了两个变量，count和total，其中total的值与count完全一致，因为我们把total这个属性的getter和setter都委托给了count。</p><p>注意，代码中的两处注释是关键：注释①，代表total属性的getter、setter会被委托出去；注释②，::count，代表total被委托给了count。这里的“::count”是<strong>属性的引用</strong>，它跟我们前面学过的<a href=\"https://time.geekbang.org/column/article/476637\">函数引用</a>是一样的概念。</p><p>total和count两者之间的委托关系一旦建立，就代表了它们两者的getter和setter会完全绑定在一起，如果要用代码来解释它们背后的逻辑，它们之间的关系会是这样：</p><pre><code class=\"language-plain\">// 近似逻辑，实际上，底层会生成一个Item$total$2类型的delegate来实现\n\nclass Item {\n    var count: Int = 0\n\n    var total: Int\n        get() = count\n\n        set(value: Int) {\n            count = value\n        }\n}\n</code></pre><p>也就是，当total的get()方法被调用时，它会直接返回count的值，也就意味着会调用count的get()方法；而当total的set()方法被调用时，它会将value传递给count，也就意味着会调用count的set()方法。</p><p>也许你会好奇：Kotlin 1.4提供的这个特性有啥用？为什么要分别定义count和total？我们直接用count不好吗？</p><p>这个特性，其实对我们<strong>软件版本之间的兼容</strong>很有帮助。假设Item是服务端接口的返回数据，1.0版本的时候，我们的Item当中只count这一个变量：</p><pre><code class=\"language-plain\">// 1.0 版本\nclass Item {\n    var count: Int = 0\n}\n</code></pre><p>而到了2.0版本的时候，我们需要将count修改成total，这时候问题就出现了，如果我们直接将count修改成total，我们的老用户就无法正常使用了。但如果我们借助委托，就可以很方便地实现这种兼容。我们可以定义一个新的变量total，然后将其委托给count，这样的话，2.0的用户访问total，而1.0的用户访问原来的count，由于它们是委托关系，也不必担心数值不一致的问题。</p><p>好了，除了属性之间的直接委托以外，还有一种委托是我们经常会用到的，那就是懒加载委托。</p><p><strong>懒加载委托</strong></p><p>懒加载，顾名思义，就是对于一些需要消耗计算机资源的操作，我们希望它在被访问的时候才去触发，从而避免不必要的资源开销。前面<a href=\"https://time.geekbang.org/column/article/475058\">第5讲</a>学习单例的时候，我们就用到了by lazy的懒加载。其实，这也是软件设计里十分常见的模式，我们来看一个例子：</p><pre><code class=\"language-plain\">//            定义懒加载委托\n//               ↓   ↓\nval data: String by lazy {\n    request()\n}\n\nfun request(): String {\n    println(\"执行网络请求\")\n    return \"网络数据\"\n}\n\nfun main() {\n    println(\"开始\")\n    println(data)\n    println(data)\n}\n\n结果：\n开始\n执行网络请求\n网络数据\n网络数据\n</code></pre><p>通过“<strong>by lazy{}</strong>”，我们就可以实现属性的懒加载了。这样，通过上面的执行结果我们会发现：main()函数的第一行代码，由于没有用到data，所以request()函数也不会被调用。到了第二行代码，我们要用到data的时候，request()才会被触发执行。到了第三行代码，由于前面我们已经知道了data的值，因此也不必重复计算，直接返回结果即可。</p><p>并且，如果你去看懒加载委托的源代码，你会发现，它其实是一个<strong>高阶函数</strong>：</p><pre><code class=\"language-plain\">public actual fun &lt;T&gt; lazy(initializer: () -&gt; T): Lazy&lt;T&gt; = SynchronizedLazyImpl(initializer)\n\n\npublic actual fun &lt;T&gt; lazy(mode: LazyThreadSafetyMode, initializer: () -&gt; T): Lazy&lt;T&gt; =\n    when (mode) {\n        LazyThreadSafetyMode.SYNCHRONIZED -&gt; SynchronizedLazyImpl(initializer)\n        LazyThreadSafetyMode.PUBLICATION -&gt; SafePublicationLazyImpl(initializer)\n        LazyThreadSafetyMode.NONE -&gt; UnsafeLazyImpl(initializer)\n    }\n</code></pre><p>可以看到，lazy()函数可以接收一个LazyThreadSafetyMode类型的参数，如果我们不传这个参数，它就会直接使用SynchronizedLazyImpl的方式。而且通过它的名字我们也能猜出来，它是为了多线程同步的。而剩下的SafePublicationLazyImpl、UnsafeLazyImpl，则不是多线程安全的。</p><p>好了，除了这两种标准委托以外，Kotlin也还提供了<a href=\"https://kotlinlang.org/docs/delegated-properties.html#observable-properties\">Delegates.observable观察者委托</a>、<a href=\"https://kotlinlang.org/docs/delegated-properties.html#storing-properties-in-a-map\">by map映射委托</a>，这两种委托比较简单，你可以点击这里给出的链接去了解它们的定义与用法。</p><h3>自定义委托</h3><p>在学完Kotlin的标准委托以后，你也许会好奇：<strong>是否可以根据需求实现自己的属性委托呢？</strong>答案当然是可以的。</p><p>不过，为了自定义委托，我们必须遵循Kotlin制定的规则。</p><pre><code class=\"language-plain\">class StringDelegate(private var s: String = \"Hello\") {\n//     ①                           ②                              ③\n//     ↓                            ↓                               ↓\n    operator fun getValue(thisRef: Owner, property: KProperty&lt;*&gt;): String {\n        return s\n    }\n//      ①                          ②                                     ③ \n//      ↓                           ↓                                      ↓\n    operator fun setValue(thisRef: Owner, property: KProperty&lt;*&gt;, value: String) {\n            s = value\n    }\n}\n\n//      ②\n//      ↓\nclass Owner {\n//               ③\n//               ↓     \n    var text: String by StringDelegate()\n}\n</code></pre><p>以上代码一共有三套注释，我分别标注了①、②、③，其中注释①有两处，注释②有三处，注释③也有三处，相同注释标注出来的地方，它们之间存在密切的关联。</p><p>首先，看到两处注释①对应的代码，对于var修饰的属性，我们必须要有getValue、setValue这两个方法，同时，这两个方法必须有 <strong>operator</strong> 关键字修饰。</p><p>其次，看到三处注释②对应的代码，我们的text属性是处于Owner这个类当中的，因此getValue、setValue这两个方法中的thisRef的类型，必须要是Owner，或者是Owner的父类。也就是说，我们将thisRef的类型改为 <strong>Any</strong> 也是可以的。一般来说，这三处的类型是一致的，当我们不确定委托属性会处于哪个类的时候，就可以将thisRef的类型定义为“Any?”。</p><p>最后，看到三处注释③对应的代码，由于我们的text属性是String类型的，为了实现对它的委托，getValue的返回值类型，以及setValue的参数类型，都必须是 <strong>String类型或者是它的父类</strong>。大部分情况下，这三处的类型都应该是一致的。</p><p>不过上面这段代码看起来还挺吓人的，刚开始的时候你也许会不太适应。但没关系，<strong>你只需要把它当作一个固定格式就行了</strong>。你在自定义委托的时候，只需要关心3个注释标注出来的地方即可。</p><p>而如果你觉得这样的写法实在很繁琐，也可以借助Kotlin提供的ReadWriteProperty、ReadOnlyProperty这两个接口，来自定义委托。</p><pre><code class=\"language-plain\">public fun interface ReadOnlyProperty&lt;in T, out V&gt; {\n    public operator fun getValue(thisRef: T, property: KProperty&lt;*&gt;): V\n}\n\npublic interface ReadWriteProperty&lt;in T, V&gt; : ReadOnlyProperty&lt;T, V&gt; {\n    public override operator fun getValue(thisRef: T, property: KProperty&lt;*&gt;): V\n\n    public operator fun setValue(thisRef: T, property: KProperty&lt;*&gt;, value: V)\n}\n</code></pre><p>如果我们需要为val属性定义委托，我们就去实现ReadOnlyProperty这个接口；如果我们需要为var属性定义委托，我们就去实现ReadWriteProperty这个接口。这样做的好处是，通过实现接口的方式，IntelliJ可以帮我们自动生成override的getValue、setValue方法。</p><p>以前面的代码为例，我们的StringDelegate，也可以通过实现ReadWriteProperty接口来编写：</p><pre><code class=\"language-plain\">class StringDelegate(private var s: String = \"Hello\"): ReadWriteProperty&lt;Owner, String&gt; {\n    override operator fun getValue(thisRef: Owner, property: KProperty&lt;*&gt;): String {\n        return s\n    }\n    override operator fun setValue(thisRef: Owner, property: KProperty&lt;*&gt;, value: String) {\n        s = value\n    }\n}\n</code></pre><h3>提供委托（provideDelegate）</h3><p>接着前面的例子，假设我们现在有一个这样的需求：我们希望StringDelegate(s: String)传入的初始值s，可以根据委托属性的名字的变化而变化。我们应该怎么做？</p><p>实际上，要想在属性委托之前再做一些额外的判断工作，我们可以使用<strong>provideDelegate</strong>来实现。</p><p>看看下面的SmartDelegator你就会明白：</p><pre><code class=\"language-plain\">class SmartDelegator {\n\n    operator fun provideDelegate(\n        thisRef: Owner,\n        prop: KProperty&lt;*&gt;\n    ): ReadWriteProperty&lt;Owner, String&gt; {\n\n        return if (prop.name.contains(\"log\")) {\n            StringDelegate(\"log\")\n        } else {\n            StringDelegate(\"normal\")\n        }\n    }\n}\n\nclass Owner {\n    var normalText: String by SmartDelegator()\n    var logText: String by SmartDelegator()\n}\n\nfun main() {\n    val owner = Owner()\n    println(owner.normalText)\n    println(owner.logText)\n}\n\n结果：\nnormal\nlog\n</code></pre><p>可以看到，为了在委托属性的同时进行一些额外的逻辑判断，我们使用创建了一个新的SmartDelegator，通过它的成员方法provideDelegate嵌套了一层，在这个方法当中，我们进行了一些逻辑判断，然后再把属性委托给StringDelegate。</p><p>如此一来，通过provideDelegate这样的方式，我们不仅可以嵌套Delegator，还可以根据不同的逻辑派发不同的Delegator。</p><h2>实战与思考</h2><p>至此，我们就算是完成了Kotlin委托的学习，包括委托类、委托属性，还有4种标准委托模式。除了这些之外，我们还学习了如何自定义委托属性，其中包括我们自己实现getValue、setValue两个方法，还有通过实现ReadOnlyProperty、ReadWriteProperty这两个接口。而对于更复杂的委托逻辑，我们还需要采用provideDelegate的方式，来嵌套Delegator。</p><p>这里，为了让你对Kotlin委托的应用场景有一个更清晰的认识，我再带你一起来看看几个Android的代码案例。</p><h3>案例1：属性可见性封装</h3><p>在软件设计当中，我们会遇到这样的需求：对于某个成员变量data，我们希望类的外部可以访问它的值，但不允许类的外部修改它的值。因此我们经常会写出类似这样的代码：</p><pre><code class=\"language-plain\">class Model {\n    var data: String = \"\"\n        // ①\n        private set\n\n    private fun load() {\n        // 网络请求\n        data = \"请求结果\"\n    }\n}\n</code></pre><p>请留意代码注释①处，我们将data属性的set方法声明为private的，这时候，data属性的set方法只能从类的内部访问，这就意味着类的外部无法修改data的值了，但类的外部仍然可以访问data的值。</p><p>这样的代码模式很常见，我们在Java/C当中也经常使用，不过当我们的data类型从String变成集合以后，问题就不一样了。</p><pre><code class=\"language-plain\">class Model {\n    val data: MutableList&lt;String&gt; = mutableListOf()\n\n    private fun load() {\n        // 网络请求\n        data.add(\"Hello\")\n    }\n}\n\nfun main() {\n    val model = Model()\n    // 类的外部仍然可以修改data\n    model.data.add(\"World\")\n}\n</code></pre><p>对于集合而言，即使我们将其定义为只读变量val，类的外部一旦获取到data的实例，它仍然可以调用集合的add()方法修改它的值。这个问题在Java当中几乎没有优雅的解法。只要你暴露了集合的实例给外部，外部就可以随意修改集合的值。这往往也是Bug的来源，这样的Bug还非常难排查。</p><p>而在这个场景下，我们前面学习的“两个属性之间的委托”这个语法，就可以派上用场了。</p><pre><code class=\"language-plain\">class Model {\n    val data: List&lt;String&gt; by ::_data\n    private val _data: MutableList&lt;String&gt; = mutableListOf()\n\n    fun load() {\n        _data.add(\"Hello\")\n    }\n}\n</code></pre><p>在上面的代码中，我们定义了两个变量，一个变量是公开的“data”，它的类型是List，这是Kotlin当中不可修改的List，它是没有add、remove等方法的。</p><p>接着，我们通过委托语法，将data的getter委托给了_data这个属性。而_data这个属性的类型是MutableList，这是Kotlin当中的可变集合，它是有add、remove方法的。由于它是private修饰的，类的外部无法直接访问，通过这种方式，我们就成功地将修改权保留在了类的内部，而类的外部访问是不可变的List，因此类的外部只能访问数据。</p><h3>案例2：数据与View的绑定</h3><p>在Android当中，如果我们要对“数据”与“View”进行绑定，我们可以用DataBinding，不过DataBinding太重了，也会影响编译速度。其实，除了DataBinding以外，我们还可以借助Kotlin的自定义委托属性来实现类似的功能。这种方式不一定完美，但也是一个有趣的思路。</p><p>这里我们以TextView为例：</p><pre><code class=\"language-plain\">operator fun TextView.provideDelegate(value: Any?, property: KProperty&lt;*&gt;) = object : ReadWriteProperty&lt;Any?, String?&gt; {\n    override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String? = text\n    override fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String?) {\n        text = value\n    }\n}\n</code></pre><p>以上的代码，我们为TextView定义了一个扩展函数TextView.provideDelegate，而这个扩展函数的返回值类型是ReadWriteProperty。通过这样的方式，我们的TextView就相当于支持了String属性的委托了。</p><p>它的使用方式也很简单：</p><pre><code class=\"language-plain\">val textView = findViewById&lt;textView&gt;(R.id.textView)\n\n// ①\nvar message: String? by textView\n\n// ②\ntextView.text = \"Hello\"\nprintln(message)\n\n// ③\nmessage = \"World\"\nprintln(textView.text)\n\n\n结果：\nHello\nWorld\n</code></pre><p>在注释①处的代码，我们通过委托的方式，将message委托给了textView。这意味着，message的getter和setter都将与TextView关联到一起。</p><p>在注释②处，我们修改了textView的text属性，由于我们的message也委托给了textView，因此这时候，println(message)的结果也会变成“Hello”。</p><p>在注释③处，我们改为修改message的值，由于message的setter也委托给了textView，因此这时候，println(textView.text)的结果会跟着变成“World”。</p><h3>案例3：ViewModel委托</h3><p>在Android当中，我们会经常用到ViewModel来存储界面数据。同时，我们不会直接创建ViewModel的实例，而对应的，我们会使用委托的方式来实现。</p><pre><code class=\"language-plain\">// MainActivity.kt\n\nprivate val mainViewModel: MainViewModel by viewModels()\n</code></pre><p>这一行代码虽然看起来很简单，但它背后隐藏了ViewModel复杂的实现原理。为了不偏离本节课的主题，我们先抛开ViewModel的实现原理不谈。在这里，我们专注于研究ViewModel的委托是如何实现的。</p><p>我们先来看看viewModels()是如何实现的：</p><pre><code class=\"language-plain\">public inline fun &lt;reified VM : ViewModel&gt; ComponentActivity.viewModels(\n    noinline factoryProducer: (() -&gt; Factory)? = null\n): Lazy&lt;VM&gt; {\n    val factoryPromise = factoryProducer ?: {\n        defaultViewModelProviderFactory\n    }\n\n    return ViewModelLazy(VM::class, { viewModelStore }, factoryPromise)\n}\n\npublic interface Lazy&lt;out T&gt; {\n\n    public val value: T\n\n    public fun isInitialized(): Boolean\n}\n</code></pre><p>原来，viewModels()是Activity的一个<strong>扩展函数</strong>。也是因为这个原因，我们才可以直接在Activity当中直接调用viewModels()这个方法。</p><p>另外，我们注意到，viewModels()这个方法的返回值类型是Lazy，那么，它是如何实现委托功能的呢？</p><pre><code class=\"language-plain\">public inline operator fun &lt;T&gt; Lazy&lt;T&gt;.getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T = value\n</code></pre><p>实际上，Lazy类在<strong>外部</strong>还定义了一个扩展函数getValue()，这样，我们的只读属性的委托就实现了。而Android官方这样的代码设计，就再一次体现了<strong>职责划分、关注点分离</strong>的原则。Lazy类只包含核心的成员，其他附属功能，以扩展的形式在Lazy外部提供。</p><h2>小结</h2><p>最后，让我们来做一个总结吧。</p><ul>\n<li>委托类，委托的是<strong>接口的方法</strong>，它在语法层面支持了“委托模式”。</li>\n<li>委托属性，委托的是<strong>属性的getter、setter</strong>。虽然它的核心理念很简单，但我们借助这个特性可以设计出非常复杂的代码。</li>\n<li>另外，Kotlin官方还提供了几种标准的属性委托，它们分别是：两个属性之间的直接委托、by lazy懒加载委托、Delegates.observable观察者委托，以及by map映射委托；</li>\n<li>两个属性之间的直接委托，它是Kotlin 1.4提供的新特性，它在<strong>属性版本更新、可变性封装</strong>上，有着很大的用处；</li>\n<li>by lazy懒加载委托，可以让我们灵活地使用<strong>懒加载</strong>，它一共有三种线程同步模式，默认情况下，它就是线程安全的；Android当中的viewModels()这个扩展函数在它的内部实现的懒加载委托，从而实现了功能强大的ViewModel；</li>\n<li>除了标准委托以外，Kotlin可以让我们开发者<strong>自定义委托</strong>。自定义委托，我们需要<strong>遵循Kotlin提供的一套语法规范</strong>，只要符合这套语法规范，就没问题；</li>\n<li>在自定义委托的时候，如果我们有灵活的需求时，可以使用<strong>provideDelegate</strong>来动态调整委托逻辑。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/bd/2c/bd5668ecfb84e324f6239e7f24ddcf2c.jpg?wh=2000x1160\" alt=\"\"></p><p>看到这里，相信你也发现了，Kotlin当中看起来毫不起眼的委托，实际上它的功能是极其强大的，甚至可以说它比起<strong>扩展</strong>毫不逊色。其实，只是因为Kotlin的委托语法要比扩展更难一些，所以它的价值才更难被挖掘出来，进而也就容易被开发者所低估。</p><p>希望这节课的内容可以对你有所启发，也希望你可以将Kotlin强大的委托语法，应用到自己的工作当中去。</p><h2>思考题</h2><p>这节课我们学习了Kotlin的委托语法，也研究了几个委托语法的使用场景，请问你还能想到哪些Kotlin委托的使用场景呢？欢迎在评论区分享你的思路，我们下节课再见。</p>","comments":[{"had_liked":false,"id":332760,"user_name":"ZircoN","can_delete":false,"product_type":"c1","uid":1033848,"ip_address":"","ucode":"E665DF0DBB7381","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c6/78/9b1e4b15.jpg","comment_is_top":false,"comment_ctime":1643557700,"is_pvip":false,"replies":[{"id":"121631","content":"没错，这也是一个比较常见的应用场景。另外，针对这样的委托封装，我们在变量命名的时候，最好是可以跟普通变量区分开。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1643591345,"ip_address":"","comment_id":332760,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23118394180","product_id":100103401,"comment_content":"SP读写的委托封装，经常用","like_count":6,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549123,"discussion_content":"没错，这也是一个比较常见的应用场景。另外，针对这样的委托封装，我们在变量命名的时候，最好是可以跟普通变量区分开。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643591345,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331068,"user_name":"文茂权","can_delete":false,"product_type":"c1","uid":1175422,"ip_address":"","ucode":"2F71862083D6CF","user_header":"https://static001.geekbang.org/account/avatar/00/11/ef/7e/231c9fa2.jpg","comment_is_top":false,"comment_ctime":1642407381,"is_pvip":true,"replies":[{"id":"120992","content":"赞~很好的补充。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1642479232,"ip_address":"","comment_id":331068,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10232341973","product_id":100103401,"comment_content":"给没看懂自定义委托的同学做点笔记：<br>kotlin.properties.PropertyDelegateProvider 接口：可以用于属性委托的基本接口，但开发者可以直接 override fun 而不声明实现。 <br>在这里 SmartDelegator 是直接实现了provideDelegate 方法，（隐式实现了这个接口），所以可以直接对 Owner 提供委托的实现。","like_count":2,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546960,"discussion_content":"赞~很好的补充。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642479232,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331499,"user_name":"曾帅","can_delete":false,"product_type":"c1","uid":1234319,"ip_address":"","ucode":"322F049DA9284D","user_header":"https://static001.geekbang.org/account/avatar/00/12/d5/8f/d0874a01.jpg","comment_is_top":false,"comment_ctime":1642608454,"is_pvip":false,"replies":[{"id":"121125","content":"说的很好，赞~","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1642646566,"ip_address":"","comment_id":331499,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5937575750","product_id":100103401,"comment_content":"委托，或者说代理，开发中比较常见的还有 mock 数据，主界面版本的迭代，开源框架的功能包裹。感觉这些概念还是一样，只是 Kotlin 让这些东西写起来更加简单，或者更加方便。","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547358,"discussion_content":"说的很好，赞~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642646567,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359603,"user_name":"黑矮人","can_delete":false,"product_type":"c1","uid":1019379,"ip_address":"上海","ucode":"96154A2CFEC3F2","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/33dVHfOPRwHGLtbsxS6GP3cjlB27QSlTQ9twmNMSx8dFTjnoOOtJY3Pq1INF3peB38k6XgB4uRjvBGvkxduRuw/132","comment_is_top":false,"comment_ctime":1665671628,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665671628","product_id":100103401,"comment_content":"&#47;&#47;控件可见性委托<br>fun View.isVisible(keepBounds: Boolean): ReadWriteProperty&lt;Any, Boolean&gt; =<br>        object : ReadWriteProperty&lt;Any, Boolean&gt; {<br>            override fun getValue(<br>                thisRef: Any,<br>                property: KProperty&lt;*&gt;<br>            ): Boolean = visibility == View.VISIBLE<br><br>            override fun setValue(<br>                thisRef: Any,<br>                property: KProperty&lt;*&gt;,<br>                value: Boolean<br>            ) {<br>                visibility = when {<br>                    value -&gt; View.VISIBLE<br>                    keepBounds -&gt; View.INVISIBLE<br>                    else -&gt; View.GONE<br>                }<br>            }<br>        }","like_count":0},{"had_liked":false,"id":355231,"user_name":"钟意","can_delete":false,"product_type":"c1","uid":2340622,"ip_address":"湖南","ucode":"0C1954C3CF1151","user_header":"https://static001.geekbang.org/account/avatar/00/23/b7/0e/f7b48767.jpg","comment_is_top":false,"comment_ctime":1661215638,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661215638","product_id":100103401,"comment_content":"operator fun TextView.provideDelegate(value: Any?, property: KProperty&lt;*&gt;) {<br>    object : ReadWriteProperty&lt;Any?, String?&gt; {<br>        var text: String? = null<br><br>        override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String? = text<br>        override fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String?) {<br>            text = value<br>        }<br>}<br><br>class MainActivity : AppCompatActivity() {<br>    override fun onCreate(savedInstanceState: Bundle?) {<br>        super.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>        <br>        var textView : TextView = findViewById&lt;TextView&gt;(R.id.tv)<br><br>        &#47;&#47; ①<br>        var message: String? by textView &#47;&#47; 报错：Type &#39;Unit&#39; has no method &#39;getValue(Nothing?, KProperty&lt;*&gt;)&#39; and thus it cannot serve as a delegate","like_count":0},{"had_liked":false,"id":354660,"user_name":"echoliulin","can_delete":false,"product_type":"c1","uid":1296112,"ip_address":"陕西","ucode":"37585581244706","user_header":"https://static001.geekbang.org/account/avatar/00/13/c6/f0/e5aec198.jpg","comment_is_top":false,"comment_ctime":1660647547,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660647547","product_id":100103401,"comment_content":"public fun interface ReadOnlyProperty {}<br>这个写法没太懂","like_count":0},{"had_liked":false,"id":352593,"user_name":"郑峰","can_delete":false,"product_type":"c1","uid":1112517,"ip_address":"","ucode":"4D4C0C020E507C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/c5/95b97dfa.jpg","comment_is_top":false,"comment_ctime":1658799322,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658799322","product_id":100103401,"comment_content":"late init for Primitive type <br><br>var name: String by notNull()","like_count":0},{"had_liked":false,"id":344052,"user_name":"尋道","can_delete":false,"product_type":"c1","uid":1163979,"ip_address":"","ucode":"089DCC2ABDCD25","user_header":"https://static001.geekbang.org/account/avatar/00/11/c2/cb/99f8d9fc.jpg","comment_is_top":false,"comment_ctime":1651213816,"is_pvip":false,"replies":[{"id":"125629","content":"这个的实现在Kotlin的源码里面，你去GitHub下载Kotlin的工程，导入IDE就能找到了：<br><br>```<br>&#47;&#47; 对应 JVM 的 getOrImplicitDefaultNullable<br>internal fun &lt;K, V&gt; Map&lt;K, V&gt;.getOrImplicitDefault(key: K): V {<br>    if (this is MapWithDefault)<br>        return this.getOrImplicitDefault(key)<br><br>    return getOrElseNullable(key, { throw NoSuchElementException(&quot;Key $key is missing in the map.&quot;) })<br>}<br>```","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1651245210,"ip_address":"","comment_id":344052,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1651213816","product_id":100103401,"comment_content":"@NotNull<br>   public final String getName() {<br>      Map var1 = this.name$delegate;<br>      KProperty var3 = $$delegatedProperties[0];<br>      boolean var4 = false;<br>      return (String)MapsKt.getOrImplicitDefaultNullable(var1, var3.getName());<br>   }<br>您好，我尝试将 kotlin 编译后的 class 反编译为 java 文件来学习 by map 委托的原理，但是 MapsKt.getOrImplicitDefaultNullable 这个方法我为何找不到？MapsKt 类可以在 Kotlin 的开源库内找到，该方法实现却没有，望帮忙解答，谢谢","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568872,"discussion_content":"这个的实现在Kotlin的源码里面，你去GitHub下载Kotlin的工程，导入IDE就能找到了：\n\n```\n// 对应 JVM 的 getOrImplicitDefaultNullable\ninternal fun &lt;K, V&gt; Map&lt;K, V&gt;.getOrImplicitDefault(key: K): V {\n    if (this is MapWithDefault)\n        return this.getOrImplicitDefault(key)\n\n    return getOrElseNullable(key, { throw NoSuchElementException(&#34;Key $key is missing in the map.&#34;) })\n}\n```","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651245210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338772,"user_name":"H.ZWei","can_delete":false,"product_type":"c1","uid":1329072,"ip_address":"","ucode":"48FFADE574C327","user_header":"https://static001.geekbang.org/account/avatar/00/14/47/b0/8c301d00.jpg","comment_is_top":false,"comment_ctime":1647709580,"is_pvip":false,"replies":[{"id":"124306","content":"会不会是导包有问题？你在Kotlin的在线环境运行试试：https:&#47;&#47;play.kotlinlang.org&#47;","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1648522382,"ip_address":"","comment_id":338772,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1647709580","product_id":100103401,"comment_content":"var total: Int by ::count<br>报错：Type KMutableProperty0 has no method getValue&#47;setValue and thus it cannot serve as a delegate<br>kotlin是1.6版本，IDE是intelliJ 2021.3版本的","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558917,"discussion_content":"会不会是导包有问题？你在Kotlin的在线环境运行试试：https://play.kotlinlang.org/","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648522382,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":335096,"user_name":"Universe","can_delete":false,"product_type":"c1","uid":1589291,"ip_address":"","ucode":"724AB258476E79","user_header":"https://static001.geekbang.org/account/avatar/00/18/40/2b/fcf4c7a8.jpg","comment_is_top":false,"comment_ctime":1645330399,"is_pvip":false,"replies":[{"id":"122399","content":"嗯嗯，确实很好用。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1645369698,"ip_address":"","comment_id":335096,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1645330399","product_id":100103401,"comment_content":"&quot;案例 1：属性可见性封装&quot; 例子很好，很有用","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552258,"discussion_content":"嗯嗯，确实很好用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645369698,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":334568,"user_name":"白乾涛","can_delete":false,"product_type":"c1","uid":1339841,"ip_address":"","ucode":"0C704B0B90C8D7","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/c1/cbc55e06.jpg","comment_is_top":false,"comment_ctime":1645002872,"is_pvip":false,"replies":[{"id":"122238","content":"你Kotlin版本多少？这是Kotlin1.4的新特性。如果是新版本，那大概率环境有问题，你可以新创建一个类，或者工程看看？","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1645062036,"ip_address":"","comment_id":334568,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1645002872","product_id":100103401,"comment_content":"var total: Int by ::count<br><br>为啥我这里报错呢，提示：Type KMutableProperty0 has no method getValue&#47;setValue and thus it cannot serve as a delegate","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551548,"discussion_content":"你Kotlin版本多少？这是Kotlin1.4的新特性。如果是新版本，那大概率环境有问题，你可以新创建一个类，或者工程看看？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645062036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1339841,"avatar":"https://static001.geekbang.org/account/avatar/00/14/71/c1/cbc55e06.jpg","nickname":"白乾涛","note":"","ucode":"0C704B0B90C8D7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552025,"discussion_content":"是kotlin版本的问题，之前的 IDE 版本太低了，自带的 kotlin 版本也低","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645238283,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332128,"user_name":"遇见จุ๊บ","can_delete":false,"product_type":"c1","uid":1120543,"ip_address":"","ucode":"A5B8E9F0D2DDF5","user_header":"https://static001.geekbang.org/account/avatar/00/11/19/1f/644ae553.jpg","comment_is_top":false,"comment_ctime":1643032603,"is_pvip":false,"replies":[{"id":"121364","content":"其实，ViewModelLazy只是Lazy的一个实现类，这里我们只关心它的委托语法是如何实现的，所以只分析了Lazy&lt;T&gt;。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1643076405,"ip_address":"","comment_id":332128,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1643032603","product_id":100103401,"comment_content":"ViewModelLazy是啥 似乎少了一段东西？","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548192,"discussion_content":"其实，ViewModelLazy只是Lazy的一个实现类，这里我们只关心它的委托语法是如何实现的，所以只分析了Lazy&lt;T&gt;。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643076405,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332110,"user_name":"l-zesong","can_delete":false,"product_type":"c1","uid":2880199,"ip_address":"","ucode":"7BE93E5AAA3616","user_header":"https://static001.geekbang.org/account/avatar/00/2b/f2/c7/c5855ff3.jpg","comment_is_top":false,"comment_ctime":1643020726,"is_pvip":false,"replies":[{"id":"121363","content":"这个其实就是见仁见智了。我个人的看法就是：如果要费很大力气去实现某个变量的懒加载的话，可能得不偿失；但如果是简单一个by lazy就能实现的话，也没太高的成本。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1643076197,"ip_address":"","comment_id":332110,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1643020726","product_id":100103401,"comment_content":"现在手机内存这么大，by lazy有必要吗？","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548191,"discussion_content":"这个其实就是见仁见智了。我个人的看法就是：如果要费很大力气去实现某个变量的懒加载的话，可能得不偿失；但如果是简单一个by lazy就能实现的话，也没太高的成本。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643076197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1090798,"avatar":"https://static001.geekbang.org/account/avatar/00/10/a4/ee/cffd8ee6.jpg","nickname":"魏全运","note":"","ucode":"3FED702C724E2A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554651,"discussion_content":"不一定是内存，很多时候是为了性能，比如你要构造一个类，如果默认赋值的成员变量是有性能损耗的，这时就很值得用懒加载，只有当你去做类似启动或秒开优化时你才会体会到真正的价值。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1646536358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331860,"user_name":"杨浩","can_delete":false,"product_type":"c1","uid":1333606,"ip_address":"","ucode":"4D51BD8452BF04","user_header":"https://static001.geekbang.org/account/avatar/00/14/59/66/e2839938.jpg","comment_is_top":false,"comment_ctime":1642837335,"is_pvip":false,"replies":[{"id":"121306","content":"是啊，表面上越简单的东西，底层就越复杂。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1642990032,"ip_address":"","comment_id":331860,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1642837335","product_id":100103401,"comment_content":"java很容易就上手，基本语法很少。<br>感觉kotlin，把很多的设计模式都变成了语法，很强大，同时也很深奥。<br>","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547992,"discussion_content":"是啊，表面上越简单的东西，底层就越复杂。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642990032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1342000,"avatar":"https://static001.geekbang.org/account/avatar/00/14/7a/30/23fc4089.jpg","nickname":"24隋心所欲","note":"","ucode":"1B8B2789F68C94","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591847,"discussion_content":"Java 语法也不少吧，而且新版本中也加入了很多新的特性，lamda、函数式接口等。容易先入为主倒是真的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666861043,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"河北"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331706,"user_name":"A Lonely Cat","can_delete":false,"product_type":"c1","uid":2885349,"ip_address":"","ucode":"382EBFDD8E5115","user_header":"https://static001.geekbang.org/account/avatar/00/2c/06/e5/51ef9735.jpg","comment_is_top":false,"comment_ctime":1642732386,"is_pvip":false,"replies":[{"id":"121177","content":"感谢你提出了一个这么有深度的问题。我那句话的语境，其实是Java当中的java.util.ArrayList实例暴露出去以后，肯定就能随意修改了。<br><br>当然，我知道你的意思。我们可以将其转换成Java里特殊的类型，比如：你提到的Arrays.ArrayList、还有SingletonList或者是自定义的集合。但这种做法终归是不优雅的，因为调用方不知情的话，是会抛出UnsupportedOperationException导致崩溃的。<br><br>关于这一点，我在后面的加餐当中也有讨论，到时候我们可以一起交流~","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1642756724,"ip_address":"","comment_id":331706,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1642732386","product_id":100103401,"comment_content":"只要你暴露了集合的实例给外部，外部就可以随意修改集合的值。<br><br>实现了 List 接口的集合类如果没有实现某些方法，外部调用时就会抛出 UnsupportedOperationException 这个异常，Arrays.ArrayList 这个内部类就没有实现 List 接口的某些方法，所以外部在调用这些方法时就会抛出异常，也就无法随意修改集合的值了。","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547581,"discussion_content":"感谢你提出了一个这么有深度的问题。我那句话的语境，其实是Java当中的java.util.ArrayList实例暴露出去以后，肯定就能随意修改了。\n\n当然，我知道你的意思。我们可以将其转换成Java里特殊的类型，比如：你提到的Arrays.ArrayList、还有SingletonList或者是自定义的集合。但这种做法终归是不优雅的，因为调用方不知情的话，是会抛出UnsupportedOperationException导致崩溃的。\n\n关于这一点，我在后面的加餐当中也有讨论，到时候我们可以一起交流~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642756724,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2885349,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/06/e5/51ef9735.jpg","nickname":"A Lonely Cat","note":"","ucode":"382EBFDD8E5115","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":547702,"discussion_content":"我觉得调用方不知情的原因之一是因为那个类的命名有些迷惑，我最初遇到这个坑的时候就是因为类名一模一样，以为是我想用的那个 ArrayList ，如果改成其他名字估计我就能及时意识到这个类有问题，否则只能看源码或者搜索文章了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642832891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":547581,"ip_address":""},"score":547702,"extra":""}]}]},{"had_liked":false,"id":331488,"user_name":"白乾涛","can_delete":false,"product_type":"c1","uid":1339841,"ip_address":"","ucode":"0C704B0B90C8D7","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/c1/cbc55e06.jpg","comment_is_top":false,"comment_ctime":1642600424,"is_pvip":false,"replies":[{"id":"121122","content":"是的，语法确实看起来太吓人了。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1642646485,"ip_address":"","comment_id":331488,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1642600424","product_id":100103401,"comment_content":"设计的太复杂了，这么复杂的语法肯定劝退了好多人","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547355,"discussion_content":"是的，语法确实看起来太吓人了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642646486,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331428,"user_name":"#果力乘#","can_delete":false,"product_type":"c1","uid":2325761,"ip_address":"","ucode":"80AA5DB4678062","user_header":"https://static001.geekbang.org/account/avatar/00/23/7d/01/3577c256.jpg","comment_is_top":false,"comment_ctime":1642582890,"is_pvip":false,"replies":[{"id":"121121","content":"最简单的：自定义getter、setter可以实现类似的需求哈。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1642646470,"ip_address":"","comment_id":331428,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1642582890","product_id":100103401,"comment_content":"var count:Int =0<br>var total:Int by ::count<br><br>这个在kotlin1.4才可以吗？1.3会报错，怎么在1.3实现呢？","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547354,"discussion_content":"最简单的：自定义getter、setter可以实现类似的需求哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642646470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2325761,"avatar":"https://static001.geekbang.org/account/avatar/00/23/7d/01/3577c256.jpg","nickname":"#果力乘#","note":"","ucode":"80AA5DB4678062","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":547360,"discussion_content":"老师，idea kotlin自动升级只能升到1.3为啥，我本地下载kotlin插件后怎么配置呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642646765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":547354,"ip_address":""},"score":547360,"extra":""}]}]},{"had_liked":false,"id":331039,"user_name":"7Promise","can_delete":false,"product_type":"c1","uid":2879220,"ip_address":"","ucode":"BF7C7F042E51F3","user_header":"https://static001.geekbang.org/account/avatar/00/2b/ee/f4/27a5080a.jpg","comment_is_top":false,"comment_ctime":1642390800,"is_pvip":false,"replies":[{"id":"120993","content":"不错~理解到位。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1642479262,"ip_address":"","comment_id":331039,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1642390800","product_id":100103401,"comment_content":"Kotlin 委托的使用场景：列表控件的适配器对象可以通过懒加载（by lazy）获得。可以待数据获取成功时才使用该适配器对象，从而避免不需要的时候创建该对象。","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546961,"discussion_content":"不错~理解到位。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642479262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}