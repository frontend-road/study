{"id":446948,"title":"36｜阶段实操（4）：构建一个简单的KV server-网络处理","content":"<p>你好，我是陈天。</p><p>经历了基础篇和进阶篇中两讲的构建和优化，到现在，我们的KV server 核心功能已经比较完善了。不知道你有没有注意，之前一直在使用一个神秘的 <a href=\"https://github.com/tyrchen/async-prost\">async-prost</a> 库，我们神奇地完成了TCP frame 的封包和解包。是怎么完成的呢？</p><p>async-prost 是我仿照 Jonhoo 的 <a href=\"https://github.com/jonhoo/async-bincode\">async-bincode</a> 做的一个处理 protobuf frame 的库，它可以和各种网络协议适配，包括 TCP / WebSocket / HTTP2 等。由于考虑通用性，它的抽象级别比较高，用了大量的泛型参数，主流程如下图所示：<br>\n<img src=\"https://static001.geekbang.org/resource/image/5a/4f/5afafe8646ee8b05b69a463ab5f5554f.png?wh=1428x895\" alt=\"\"></p><p>主要的思路就是在序列化数据的时候，添加一个头部来提供 frame 的长度，反序列化的时候，先读出头部，获得长度，再读取相应的数据。感兴趣的同学可以去看代码，这里就不展开了。</p><p>今天我们的挑战就是，在上一次完成的 KV server 的基础上，来试着不依赖 async-prost，自己处理封包和解包的逻辑。如果你掌握了这个能力，配合 protobuf，就可以设计出任何可以承载实际业务的协议了。</p><h2>如何定义协议的 Frame？</h2><p>protobuf 帮我们解决了协议消息如何定义的问题，然而一个消息和另一个消息之间如何区分，是个伤脑筋的事情。我们需要定义合适的分隔符。</p><!-- [[[read_end]]] --><p>分隔符 + 消息数据，就是一个 Frame。之前在28网络开发<a href=\"https://time.geekbang.org/column/article/432162\">那一讲</a>简单说过如何界定一个frame。</p><p>很多基于 TCP 的协议会使用 \\r\\n 做分隔符，比如 FTP；也有使用消息长度做分隔符的，比如 gRPC；还有混用两者的，比如 Redis 的 RESP；更复杂的如 HTTP，header 之间使用 \\r\\n 分隔，header / body 之间使用 \\r\\n\\r\\n，header 中会提供 body 的长度等等。</p><p>“\\r\\n” 这样的分隔符，适合协议报文是 ASCII 数据；而通过长度进行分隔，适合协议报文是二进制数据。<strong>我们的 KV Server 承载的 protobuf 是二进制，所以就在 payload 之前放一个长度，来作为 frame 的分隔</strong>。</p><p>这个长度取什么大小呢？如果使用 2 个字节，那么 payload 最大是 64k；如果使用 4 个字节，payload 可以到 4G。一般的应用取 4 个字节就足够了。如果你想要更灵活些，也可以使用 <a href=\"https://en.wikipedia.org/wiki/Variable-length_quantity\">varint</a>。</p><p>tokio 有个 tokio-util 库，已经帮我们处理了和 frame 相关的封包解包的主要需求，包括 LinesDelimited（处理 \\r\\n 分隔符）和 LengthDelimited（处理长度分隔符）。我们可以使用它的 <a href=\"https://docs.rs/tokio-util/0.6.8/tokio_util/codec/length_delimited/index.html\">LengthDelimitedCodec</a> 尝试一下。</p><p>首先在 Cargo.toml 里添加依赖：</p><pre><code class=\"language-rust\">[dev-dependencies]\n...\ntokio-util = { version = \"0.6\", features = [\"codec\"]}\n...\n</code></pre><p>然后创建 examples/server_with_codec.rs 文件，添入如下代码：</p><pre><code class=\"language-rust\">use anyhow::Result;\nuse futures::prelude::*;\nuse kv2::{CommandRequest, MemTable, Service, ServiceInner};\nuse prost::Message;\nuse tokio::net::TcpListener;\nuse tokio_util::codec::{Framed, LengthDelimitedCodec};\nuse tracing::info;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;()&gt; {\n    tracing_subscriber::fmt::init();\n    let service: Service = ServiceInner::new(MemTable::new()).into();\n    let addr = \"127.0.0.1:9527\";\n    let listener = TcpListener::bind(addr).await?;\n    info!(\"Start listening on {}\", addr);\n    loop {\n        let (stream, addr) = listener.accept().await?;\n        info!(\"Client {:?} connected\", addr);\n        let svc = service.clone();\n        tokio::spawn(async move {\n            let mut stream = Framed::new(stream, LengthDelimitedCodec::new());\n            while let Some(Ok(mut buf)) = stream.next().await {\n                let cmd = CommandRequest::decode(&amp;buf[..]).unwrap();\n                info!(\"Got a new command: {:?}\", cmd);\n                let res = svc.execute(cmd);\n                buf.clear();\n                res.encode(&amp;mut buf).unwrap();\n                stream.send(buf.freeze()).await.unwrap();\n            }\n            info!(\"Client {:?} disconnected\", addr);\n        });\n    }\n}\n</code></pre><p>你可以对比一下它和之前的 examples/server.rs 的差别，主要改动了这一行：</p><pre><code class=\"language-rust\">// let mut stream = AsyncProstStream::&lt;_, CommandRequest, CommandResponse, _&gt;::from(stream).for_async();\nlet mut stream = Framed::new(stream, LengthDelimitedCodec::new());\n</code></pre><p>完成之后，我们打开一个命令行窗口，运行：<code>RUST_LOG=info cargo run --example server_with_codec --quiet</code>。然后在另一个命令行窗口，运行：<code>RUST_LOG=info cargo run --example client --quiet</code>。此时，服务器和客户端都收到了彼此的请求和响应，并且处理正常。</p><p>你这会是不是有点疑惑，为什么客户端没做任何修改也能和服务器通信？那是因为在目前的使用场景下，使用 AsyncProst 的客户端兼容 LengthDelimitedCodec。</p><h2>如何撰写处理 Frame 的代码？</h2><p><a href=\"https://docs.rs/tokio-util/0.6.8/tokio_util/codec/length_delimited/index.html\">LengthDelimitedCodec</a> 非常好用，它的代码也并不复杂，非常建议你有空研究一下。既然这一讲主要围绕网络开发展开，那么我们也来尝试一下撰写自己的对 Frame 处理的代码吧。</p><p>按照前面分析，我们在 protobuf payload 前加一个 4 字节的长度，这样，对端读取数据时，可以先读 4 字节，然后根据读到的长度，进一步读取满足这个长度的数据，之后就可以用相应的数据结构解包了。</p><p>为了更贴近实际，<strong>我们把4字节长度的最高位拿出来作为是否压缩的信号</strong>，如果设置了，代表后续的 payload 是 gzip 压缩过的 protobuf，否则直接是 protobuf：<br>\n<img src=\"https://static001.geekbang.org/resource/image/71/03/712735ae12d0cdf39b3dcf5bb242f103.jpg?wh=2149x1485\" alt=\"\"></p><p>按照惯例，还是先来定义处理这个逻辑的 trait：</p><pre><code class=\"language-rust\">pub trait FrameCoder\nwhere\n    Self: Message + Sized + Default,\n{\n    /// 把一个 Message encode 成一个 frame\n    fn encode_frame(&amp;self, buf: &amp;mut BytesMut) -&gt; Result&lt;(), KvError&gt;;\n    /// 把一个完整的 frame decode 成一个 Message\n    fn decode_frame(buf: &amp;mut BytesMut) -&gt; Result&lt;Self, KvError&gt;;\n}\n</code></pre><p>定义了两个方法：</p><ul>\n<li>encode_frame() 可以把诸如 CommandRequest 这样的消息<strong>封装</strong>成一个 frame，写入传进来的 BytesMut；</li>\n<li>decode_frame() 可以把收到的一个完整的、放在 BytesMut 中的数据，<strong>解封装</strong>成诸如 CommandRequest 这样的消息。</li>\n</ul><p>如果要实现这个 trait，Self 需要实现了 prost::Message，大小是固定的，并且实现了 Default（prost 的需求）。</p><p>好，我们再写实现代码。首先创建 src/network 目录，并在其下添加两个文件<a href=\"http://mod.rs\">mod.rs</a> 和 <a href=\"http://frame.rs\">frame.rs</a>。然后在 src/network/mod.rs 里引入 src/network/frame.rs：</p><pre><code class=\"language-rust\">mod frame;\npub use frame::FrameCoder;\n</code></pre><p>同时在 <a href=\"http://lib.rs\">lib.rs</a> 里引入 network：</p><pre><code class=\"language-rust\">mod network;\npub use network::*;\n</code></pre><p>因为要处理 gzip 压缩，还需要在 Cargo.toml 中引入 <a href=\"https://github.com/rust-lang/flate2-rs\">flate2</a>，同时，因为今天这一讲引入了网络相关的操作和数据结构，我们需要把 tokio 从 dev-dependencies 移到 dependencies 里，为简单起见，就用 full features：</p><pre><code class=\"language-rust\">[dependencies]\n...\nflate2 = \"1\" # gzip 压缩\n...\ntokio = { version = \"1\", features = [\"full\"] } # 异步网络库\n...\n</code></pre><p>然后，在 src/network/frame.rs 里添加 trait 和实现 trait 的代码：</p><pre><code class=\"language-rust\">use std::io::{Read, Write};\n\nuse crate::{CommandRequest, CommandResponse, KvError};\nuse bytes::{Buf, BufMut, BytesMut};\nuse flate2::{read::GzDecoder, write::GzEncoder, Compression};\nuse prost::Message;\nuse tokio::io::{AsyncRead, AsyncReadExt};\nuse tracing::debug;\n\n/// 长度整个占用 4 个字节\npub const LEN_LEN: usize = 4;\n/// 长度占 31 bit，所以最大的 frame 是 2G\nconst MAX_FRAME: usize = 2 * 1024 * 1024 * 1024;\n/// 如果 payload 超过了 1436 字节，就做压缩\nconst COMPRESSION_LIMIT: usize = 1436;\n/// 代表压缩的 bit（整个长度 4 字节的最高位）\nconst COMPRESSION_BIT: usize = 1 &lt;&lt; 31;\n\n/// 处理 Frame 的 encode/decode\npub trait FrameCoder\nwhere\n    Self: Message + Sized + Default,\n{\n    /// 把一个 Message encode 成一个 frame\n    fn encode_frame(&amp;self, buf: &amp;mut BytesMut) -&gt; Result&lt;(), KvError&gt; {\n        let size = self.encoded_len();\n\n        if size &gt;= MAX_FRAME {\n            return Err(KvError::FrameError);\n        }\n\n        // 我们先写入长度，如果需要压缩，再重写压缩后的长度\n        buf.put_u32(size as _);\n\n        if size &gt; COMPRESSION_LIMIT {\n            let mut buf1 = Vec::with_capacity(size);\n            self.encode(&amp;mut buf1)?;\n\n            // BytesMut 支持逻辑上的 split（之后还能 unsplit）\n            // 所以我们先把长度这 4 字节拿走，清除\n            let payload = buf.split_off(LEN_LEN);\n            buf.clear();\n\n            // 处理 gzip 压缩，具体可以参考 flate2 文档\n            let mut encoder = GzEncoder::new(payload.writer(), Compression::default());\n            encoder.write_all(&amp;buf1[..])?;\n\n            // 压缩完成后，从 gzip encoder 中把 BytesMut 再拿回来\n            let payload = encoder.finish()?.into_inner();\n            debug!(\"Encode a frame: size {}({})\", size, payload.len());\n\n            // 写入压缩后的长度\n            buf.put_u32((payload.len() | COMPRESSION_BIT) as _);\n\n            // 把 BytesMut 再合并回来\n            buf.unsplit(payload);\n\n            Ok(())\n        } else {\n            self.encode(buf)?;\n            Ok(())\n        }\n    }\n\n    /// 把一个完整的 frame decode 成一个 Message\n    fn decode_frame(buf: &amp;mut BytesMut) -&gt; Result&lt;Self, KvError&gt; {\n        // 先取 4 字节，从中拿出长度和 compression bit\n        let header = buf.get_u32() as usize;\n        let (len, compressed) = decode_header(header);\n        debug!(\"Got a frame: msg len {}, compressed {}\", len, compressed);\n\n        if compressed {\n            // 解压缩\n            let mut decoder = GzDecoder::new(&amp;buf[..len]);\n            let mut buf1 = Vec::with_capacity(len * 2);\n            decoder.read_to_end(&amp;mut buf1)?;\n            buf.advance(len);\n\n            // decode 成相应的消息\n            Ok(Self::decode(&amp;buf1[..buf1.len()])?)\n        } else {\n            let msg = Self::decode(&amp;buf[..len])?;\n            buf.advance(len);\n            Ok(msg)\n        }\n    }\n}\n\nimpl FrameCoder for CommandRequest {}\nimpl FrameCoder for CommandResponse {}\n\nfn decode_header(header: usize) -&gt; (usize, bool) {\n    let len = header &amp; !COMPRESSION_BIT;\n    let compressed = header &amp; COMPRESSION_BIT == COMPRESSION_BIT;\n    (len, compressed)\n}\n</code></pre><p>这段代码本身并不难理解。我们直接为 FrameCoder 提供了缺省实现，然后 CommandRequest / CommandResponse 做了空实现。其中使用了之前介绍过的 bytes 库里的 BytesMut，以及新引入的 GzEncoder / GzDecoder。你可以按照 <a href=\"https://time.geekbang.org/column/article/424017\">20 讲</a>介绍的阅读源码的方式，了解这几个数据类型的用法。最后还写了个辅助函数 decode_header()，让 decode_frame() 的代码更直观一些。</p><p>如果你有些疑惑为什么 <code>COMPRESSION_LIMIT</code> 设成 1436？</p><p>这是因为以太网的 MTU 是 1500，除去 IP 头 20 字节、TCP 头 20 字节，还剩 1460；一般 TCP 包会包含一些 Option（比如 timestamp），IP 包也可能包含，所以我们预留 20 字节；再减去 4 字节的长度，就是<strong>1436，不用分片的最大消息长度。如果大于这个，很可能会导致分片，我们就干脆压缩一下</strong>。</p><p>现在，CommandRequest / CommandResponse 就可以做 frame 级别的处理了，我们写一些测试验证是否工作。还是在 src/network/frame.rs 里，添加测试代码：</p><pre><code class=\"language-rust\">#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::Value;\n    use bytes::Bytes;\n\n    #[test]\n    fn command_request_encode_decode_should_work() {\n        let mut buf = BytesMut::new();\n\n        let cmd = CommandRequest::new_hdel(\"t1\", \"k1\");\n        cmd.encode_frame(&amp;mut buf).unwrap();\n\n        // 最高位没设置\n        assert_eq!(is_compressed(&amp;buf), false);\n\n        let cmd1 = CommandRequest::decode_frame(&amp;mut buf).unwrap();\n        assert_eq!(cmd, cmd1);\n    }\n\n    #[test]\n    fn command_response_encode_decode_should_work() {\n        let mut buf = BytesMut::new();\n\n        let values: Vec&lt;Value&gt; = vec![1.into(), \"hello\".into(), b\"data\".into()];\n        let res: CommandResponse = values.into();\n        res.encode_frame(&amp;mut buf).unwrap();\n\n        // 最高位没设置\n        assert_eq!(is_compressed(&amp;buf), false);\n\n        let res1 = CommandResponse::decode_frame(&amp;mut buf).unwrap();\n        assert_eq!(res, res1);\n    }\n\n    #[test]\n    fn command_response_compressed_encode_decode_should_work() {\n        let mut buf = BytesMut::new();\n\n        let value: Value = Bytes::from(vec![0u8; COMPRESSION_LIMIT + 1]).into();\n        let res: CommandResponse = value.into();\n        res.encode_frame(&amp;mut buf).unwrap();\n\n        // 最高位设置了\n        assert_eq!(is_compressed(&amp;buf), true);\n\n        let res1 = CommandResponse::decode_frame(&amp;mut buf).unwrap();\n        assert_eq!(res, res1);\n    }\n\n    fn is_compressed(data: &amp;[u8]) -&gt; bool {\n        if let &amp;[v] = &amp;data[..1] {\n            v &gt;&gt; 7 == 1\n        } else {\n            false\n        }\n    }\n}\n</code></pre><p>这个测试代码里面有从 [u8; N] 到 Value（<code>b\"data\".into()</code>） 以及从 Bytes 到 Value 的转换，所以我们需要在 src/pb/mod.rs 里添加 From trait 的相应实现：</p><pre><code class=\"language-rust\">impl&lt;const N: usize&gt; From&lt;&amp;[u8; N]&gt; for Value {\n    fn from(buf: &amp;[u8; N]) -&gt; Self {\n        Bytes::copy_from_slice(&amp;buf[..]).into()\n    }\n}\n\nimpl From&lt;Bytes&gt; for Value {\n    fn from(buf: Bytes) -&gt; Self {\n        Self {\n            value: Some(value::Value::Binary(buf)),\n        }\n    }\n}\n</code></pre><p>运行 <code>cargo test</code> ，所有测试都可以通过。</p><p>到这里，我们就完成了 Frame 的序列化（encode_frame）和反序列化（decode_frame），并且用测试确保它的正确性。<strong>做网络开发的时候，要尽可能把实现逻辑和 IO 分离，这样有助于可测性以及应对未来 IO 层的变更</strong>。目前，这个代码没有触及任何和 socket IO 相关的内容，只是纯逻辑，接下来我们要将它和我们用于处理服务器客户端的 TcpStream 联系起来。</p><p>在进一步写网络相关的代码前，还有一个问题需要解决：decode_frame() 函数使用的 BytesMut，是如何从 socket 里拿出来的？显然，先读 4 个字节，取出长度 N，然后再读 N 个字节。这个细节和 frame 关系很大，所以还需要在 src/network/frame.rs 里写个辅助函数 read_frame()：</p><pre><code class=\"language-rust\">/// 从 stream 中读取一个完整的 frame\npub async fn read_frame&lt;S&gt;(stream: &amp;mut S, buf: &amp;mut BytesMut) -&gt; Result&lt;(), KvError&gt;\nwhere\n    S: AsyncRead + Unpin + Send,\n{\n    let header = stream.read_u32().await? as usize;\n    let (len, _compressed) = decode_header(header);\n\t\t// 如果没有这么大的内存，就分配至少一个 frame 的内存，保证它可用\n    buf.reserve(LEN_LEN + len);\n    buf.put_u32(header as _);\n    // advance_mut 是 unsafe 的原因是，从当前位置 pos 到 pos + len，\n    // 这段内存目前没有初始化。我们就是为了 reserve 这段内存，然后从 stream\n    // 里读取，读取完，它就是初始化的。所以，我们这么用是安全的\n    unsafe { buf.advance_mut(len) };\n    stream.read_exact(&amp;mut buf[LEN_LEN..]).await?;\n    Ok(())\n}\n</code></pre><p>在写 read_frame() 时，我们不希望它只能被用于 TcpStream，这样太不灵活，<strong>所以用了泛型参数 S，要求传入的 S 必须满足 AsyncRead + Unpin + Send</strong>。我们来看看这3个约束。</p><p><a href=\"https://docs.rs/tokio/1.12.0/tokio/io/trait.AsyncRead.html\">AsyncRead</a> 是 tokio 下的一个 trait，用于做异步读取，它有一个方法 poll_read()：</p><pre><code class=\"language-rust\">pub trait AsyncRead {\n    fn poll_read(\n        self: Pin&lt;&amp;mut Self&gt;, \n        cx: &amp;mut Context&lt;'_&gt;, \n        buf: &amp;mut ReadBuf&lt;'_&gt;\n    ) -&gt; Poll&lt;Result&lt;()&gt;&gt;;\n}\n</code></pre><p>一旦某个数据结构实现了 AsyncRead，它就可以使用 <a href=\"https://docs.rs/tokio/1.12.0/tokio/io/trait.AsyncReadExt.html\">AsyncReadExt</a> 提供的多达 29 个辅助方法。这是因为任何实现了 AsyncRead 的数据结构，都自动实现了 AsyncReadExt：</p><pre><code class=\"language-rust\">impl&lt;R: AsyncRead + ?Sized&gt; AsyncReadExt for R {}\n</code></pre><p>我们虽然还没有正式学怎么做异步处理，但是之前已经看到了很多 async/await 的代码。</p><p><strong>异步处理，目前你可以把它想象成一个内部有个状态机的数据结构</strong>，异步运行时根据需要不断地对其做 poll 操作，直到它返回 Poll::Ready，说明得到了处理结果；如果它返回 Poll::Pending，说明目前还无法继续，异步运行时会将其挂起，等下次某个事件将这个任务唤醒。</p><p>对于 Socket 来说，读取 socket 就是一个不断 poll_read() 的过程，直到读到了满足 ReadBuf 需要的内容。</p><p>至于 Send 约束，很好理解，S 需要能在不同线程间移动所有权。对于 Unpin 约束，未来讲 Future 的时候再具体说。现在你就权且记住，如果编译器抱怨一个泛型参数 “cannot be unpinned” ，一般来说，这个泛型参数需要加 Unpin 的约束。你可以试着把 Unpin 去掉，看看编译器的报错。</p><p>好，既然又写了一些代码，自然需为其撰写相应的测试。但是，要测 read_frame() 函数，需要一个支持 AsyncRead 的数据结构，虽然 TcpStream 支持它，但是我们不应该在单元测试中引入太过复杂的行为。<strong>为了测试 read_frame() 而建立 TCP 连接，显然没有必要。怎么办</strong>？</p><p>在<a href=\"https://time.geekbang.org/column/article/429063\">第 25 讲</a>，我们聊过测试代码和产品代码同等的重要性，所以，在开发中，也要为测试代码创建合适的生态环境，让测试简洁、可读性强。那这里，我们就创建一个简单的数据结构，使其实现 AsyncRead，这样就可以“单元”测试 read_frame() 了。</p><p>在 src/network/frame.rs 里的 mod tests 下加入：</p><pre><code class=\"language-rust\">#[cfg(test)]\nmod tests {\n\t\tstruct DummyStream {\n        buf: BytesMut,\n    }\n\n    impl AsyncRead for DummyStream {\n        fn poll_read(\n            self: std::pin::Pin&lt;&amp;mut Self&gt;,\n            _cx: &amp;mut std::task::Context&lt;'_&gt;,\n            buf: &amp;mut tokio::io::ReadBuf&lt;'_&gt;,\n        ) -&gt; std::task::Poll&lt;std::io::Result&lt;()&gt;&gt; {\n\t\t\t\t\t\t// 看看 ReadBuf 需要多大的数据\n            let len = buf.capacity();\n\n            // split 出这么大的数据\n            let data = self.get_mut().buf.split_to(len);\n\n            // 拷贝给 ReadBuf\n            buf.put_slice(&amp;data);\n\n            // 直接完工\n            std::task::Poll::Ready(Ok(()))\n        }\n    }\n}\n</code></pre><p>因为只需要保证 AsyncRead 接口的正确性，所以不需要太复杂的逻辑，我们就放一个 buffer，poll_read() 需要读多大的数据，我们就给多大的数据。有了这个 DummyStream，就可以测试 read_frame() 了：</p><pre><code class=\"language-rust\">#[tokio::test]\nasync fn read_frame_should_work() {\n    let mut buf = BytesMut::new();\n    let cmd = CommandRequest::new_hdel(\"t1\", \"k1\");\n    cmd.encode_frame(&amp;mut buf).unwrap();\n    let mut stream = DummyStream { buf };\n\n    let mut data = BytesMut::new();\n    read_frame(&amp;mut stream, &amp;mut data).await.unwrap();\n\n    let cmd1 = CommandRequest::decode_frame(&amp;mut data).unwrap();\n    assert_eq!(cmd, cmd1);\n}\n</code></pre><p>运行 “cargo test”，测试通过。如果你的代码无法编译，可以看看编译错误，是不是缺了一些 use 语句来把某些数据结构和 trait 引入。你也可以对照 GitHub 上的代码修改。</p><h2>让网络层可以像 AsyncProst 那样方便使用</h2><p>现在，我们的 frame 已经可以正常工作了。接下来要构思一下，服务端和客户端该如何封装。</p><p>对于服务器，我们期望可以对 accept 下来的 TcpStream 提供一个 process() 方法，处理协议的细节：</p><pre><code class=\"language-rust\">#[tokio::main]\nasync fn main() -&gt; Result&lt;()&gt; {\n    tracing_subscriber::fmt::init();\n    let addr = \"127.0.0.1:9527\";\n    let service: Service = ServiceInner::new(MemTable::new()).into();\n    let listener = TcpListener::bind(addr).await?;\n    info!(\"Start listening on {}\", addr);\n    loop {\n        let (stream, addr) = listener.accept().await?;\n        info!(\"Client {:?} connected\", addr);\n        let stream = ProstServerStream::new(stream, service.clone());\n        tokio::spawn(async move { stream.process().await });\n    }\n}\n</code></pre><p>这个 process() 方法，实际上就是对 examples/server.rs 中 tokio::spawn 里的 while loop 的封装：</p><pre><code class=\"language-rust\">while let Some(Ok(cmd)) = stream.next().await {\n    info!(\"Got a new command: {:?}\", cmd);\n    let res = svc.execute(cmd);\n    stream.send(res).await.unwrap();\n}\n</code></pre><p>对客户端，我们也希望可以直接 execute() 一个命令，就能得到结果：</p><pre><code class=\"language-rust\">#[tokio::main]\nasync fn main() -&gt; Result&lt;()&gt; {\n    tracing_subscriber::fmt::init();\n\n    let addr = \"127.0.0.1:9527\";\n    // 连接服务器\n    let stream = TcpStream::connect(addr).await?;\n\n    let mut client = ProstClientStream::new(stream);\n\n    // 生成一个 HSET 命令\n    let cmd = CommandRequest::new_hset(\"table1\", \"hello\", \"world\".to_string().into());\n\n    // 发送 HSET 命令\n    let data = client.execute(cmd).await?;\n    info!(\"Got response {:?}\", data);\n\n    Ok(())\n}\n</code></pre><p>这个 execute()，实际上就是对 examples/client.rs 中发送和接收代码的封装：</p><pre><code class=\"language-rust\">client.send(cmd).await?;\nif let Some(Ok(data)) = client.next().await {\n    info!(\"Got response {:?}\", data);\n}\n</code></pre><p>这样的代码，看起来很简洁，维护起来也很方便。</p><p>好，先看服务器处理一个 TcpStream 的数据结构，它需要包含 TcpStream，还有我们之前创建的用于处理客户端命令的 Service。所以，让服务器处理 TcpStream 的结构包含这两部分：</p><pre><code class=\"language-rust\">pub struct ProstServerStream&lt;S&gt; {\n    inner: S,\n    service: Service,\n}\n</code></pre><p>而客户端处理 TcpStream 的结构就只需要包含 TcpStream：</p><pre><code class=\"language-rust\">pub struct ProstClientStream&lt;S&gt; {\n    inner: S,\n}\n</code></pre><p>这里，依旧使用了泛型参数 S。未来，如果要支持 WebSocket，或者在 TCP 之上支持 TLS，它都可以让我们无需改变这一层的代码。</p><p>接下来就是具体的实现。有了 frame 的封装，服务器的 process() 方法和客户端的 execute() 方法都很容易实现。我们直接在 src/network/mod.rs 里添加完整代码：</p><pre><code class=\"language-rust\">mod frame;\nuse bytes::BytesMut;\npub use frame::{read_frame, FrameCoder};\nuse tokio::io::{AsyncRead, AsyncWrite, AsyncWriteExt};\nuse tracing::info;\n\nuse crate::{CommandRequest, CommandResponse, KvError, Service};\n\n/// 处理服务器端的某个 accept 下来的 socket 的读写\npub struct ProstServerStream&lt;S&gt; {\n    inner: S,\n    service: Service,\n}\n\n/// 处理客户端 socket 的读写\npub struct ProstClientStream&lt;S&gt; {\n    inner: S,\n}\n\nimpl&lt;S&gt; ProstServerStream&lt;S&gt;\nwhere\n    S: AsyncRead + AsyncWrite + Unpin + Send,\n{\n    pub fn new(stream: S, service: Service) -&gt; Self {\n        Self {\n            inner: stream,\n            service,\n        }\n    }\n\n    pub async fn process(mut self) -&gt; Result&lt;(), KvError&gt; {\n        while let Ok(cmd) = self.recv().await {\n            info!(\"Got a new command: {:?}\", cmd);\n            let res = self.service.execute(cmd);\n            self.send(res).await?;\n        }\n        // info!(\"Client {:?} disconnected\", self.addr);\n        Ok(())\n    }\n\n    async fn send(&amp;mut self, msg: CommandResponse) -&gt; Result&lt;(), KvError&gt; {\n        let mut buf = BytesMut::new();\n        msg.encode_frame(&amp;mut buf)?;\n        let encoded = buf.freeze();\n        self.inner.write_all(&amp;encoded[..]).await?;\n        Ok(())\n    }\n\n    async fn recv(&amp;mut self) -&gt; Result&lt;CommandRequest, KvError&gt; {\n        let mut buf = BytesMut::new();\n        let stream = &amp;mut self.inner;\n        read_frame(stream, &amp;mut buf).await?;\n        CommandRequest::decode_frame(&amp;mut buf)\n    }\n}\n\nimpl&lt;S&gt; ProstClientStream&lt;S&gt;\nwhere\n    S: AsyncRead + AsyncWrite + Unpin + Send,\n{\n    pub fn new(stream: S) -&gt; Self {\n        Self { inner: stream }\n    }\n\n    pub async fn execute(&amp;mut self, cmd: CommandRequest) -&gt; Result&lt;CommandResponse, KvError&gt; {\n        self.send(cmd).await?;\n        Ok(self.recv().await?)\n    }\n\n    async fn send(&amp;mut self, msg: CommandRequest) -&gt; Result&lt;(), KvError&gt; {\n        let mut buf = BytesMut::new();\n        msg.encode_frame(&amp;mut buf)?;\n        let encoded = buf.freeze();\n        self.inner.write_all(&amp;encoded[..]).await?;\n        Ok(())\n    }\n\n    async fn recv(&amp;mut self) -&gt; Result&lt;CommandResponse, KvError&gt; {\n        let mut buf = BytesMut::new();\n        let stream = &amp;mut self.inner;\n        read_frame(stream, &amp;mut buf).await?;\n        CommandResponse::decode_frame(&amp;mut buf)\n    }\n}\n</code></pre><p>这段代码不难阅读，基本上和 frame 的测试代码大同小异。</p><p>当然了，我们还是需要写段代码来测试客户端和服务器交互的整个流程：</p><pre><code class=\"language-rust\">#[cfg(test)]\nmod tests {\n    use anyhow::Result;\n    use bytes::Bytes;\n    use std::net::SocketAddr;\n    use tokio::net::{TcpListener, TcpStream};\n\n    use crate::{assert_res_ok, MemTable, ServiceInner, Value};\n\n    use super::*;\n\n    #[tokio::test]\n    async fn client_server_basic_communication_should_work() -&gt; anyhow::Result&lt;()&gt; {\n        let addr = start_server().await?;\n\n        let stream = TcpStream::connect(addr).await?;\n        let mut client = ProstClientStream::new(stream);\n\n        // 发送 HSET，等待回应\n\n        let cmd = CommandRequest::new_hset(\"t1\", \"k1\", \"v1\".into());\n        let res = client.execute(cmd).await.unwrap();\n\n        // 第一次 HSET 服务器应该返回 None\n        assert_res_ok(res, &amp;[Value::default()], &amp;[]);\n\n        // 再发一个 HSET\n        let cmd = CommandRequest::new_hget(\"t1\", \"k1\");\n        let res = client.execute(cmd).await?;\n\n        // 服务器应该返回上一次的结果\n        assert_res_ok(res, &amp;[\"v1\".into()], &amp;[]);\n\n        Ok(())\n    }\n\n    #[tokio::test]\n    async fn client_server_compression_should_work() -&gt; anyhow::Result&lt;()&gt; {\n        let addr = start_server().await?;\n\n        let stream = TcpStream::connect(addr).await?;\n        let mut client = ProstClientStream::new(stream);\n\n        let v: Value = Bytes::from(vec![0u8; 16384]).into();\n        let cmd = CommandRequest::new_hset(\"t2\", \"k2\", v.clone().into());\n        let res = client.execute(cmd).await?;\n\n        assert_res_ok(res, &amp;[Value::default()], &amp;[]);\n\n        let cmd = CommandRequest::new_hget(\"t2\", \"k2\");\n        let res = client.execute(cmd).await?;\n\n        assert_res_ok(res, &amp;[v.into()], &amp;[]);\n\n        Ok(())\n    }\n\n    async fn start_server() -&gt; Result&lt;SocketAddr&gt; {\n        let listener = TcpListener::bind(\"127.0.0.1:0\").await.unwrap();\n        let addr = listener.local_addr().unwrap();\n\n        tokio::spawn(async move {\n            loop {\n                let (stream, _) = listener.accept().await.unwrap();\n                let service: Service = ServiceInner::new(MemTable::new()).into();\n                let server = ProstServerStream::new(stream, service);\n                tokio::spawn(server.process());\n            }\n        });\n\n        Ok(addr)\n    }\n}\n</code></pre><p>测试代码基本上是之前 examples 下的 <a href=\"http://server.rs/client.rs\">server.rs/client.rs</a> 中的内容。我们测试了不做压缩和做压缩的两种情况。运行 <code>cargo test</code> ，应该所有测试都通过了。</p><h2>正式创建 kv-server 和 kv-client</h2><p>我们之前写了很多代码，真正可运行的 server/client 都是 examples 下的代码。现在我们终于要正式创建 kv-server / kv-client 了。</p><p>首先在 Cargo.toml 中，加入两个可执行文件：kvs（kv-server）和 kvc（kv-client）。还需要把一些依赖移动到 dependencies 下。修改之后，Cargo.toml 长这个样子：</p><pre><code class=\"language-rust\">[package]\nname = \"kv2\"\nversion = \"0.1.0\"\nedition = \"2018\"\n\n[[bin]]\nname = \"kvs\"\npath = \"src/server.rs\"\n\n[[bin]]\nname = \"kvc\"\npath = \"src/client.rs\"\n\n[dependencies]\nanyhow = \"1\" # 错误处理\nbytes = \"1\" # 高效处理网络 buffer 的库\ndashmap = \"4\" # 并发 HashMap\nflate2 = \"1\" # gzip 压缩\nhttp = \"0.2\" # 我们使用 HTTP status code 所以引入这个类型库\nprost = \"0.8\" # 处理 protobuf 的代码\nsled = \"0.34\" # sled db\nthiserror = \"1\" # 错误定义和处理\ntokio = { version = \"1\", features = [\"full\" ] } # 异步网络库\ntracing = \"0.1\" # 日志处理\ntracing-subscriber = \"0.2\" # 日志处理\n\n[dev-dependencies]\nasync-prost = \"0.2.1\" # 支持把 protobuf 封装成 TCP frame\nfutures = \"0.3\" # 提供 Stream trait\ntempfile = \"3\" # 处理临时目录和临时文件\ntokio-util = { version = \"0.6\", features = [\"codec\"]}\n\n[build-dependencies]\nprost-build = \"0.8\" # 编译 protobuf\n</code></pre><p>然后，创建 src/client.rs 和 src/server.rs，分别写入下面的代码。src/client.rs：</p><pre><code class=\"language-rust\">use anyhow::Result;\nuse kv2::{CommandRequest, ProstClientStream};\nuse tokio::net::TcpStream;\nuse tracing::info;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;()&gt; {\n    tracing_subscriber::fmt::init();\n\n    let addr = \"127.0.0.1:9527\";\n    // 连接服务器\n    let stream = TcpStream::connect(addr).await?;\n\n    let mut client = ProstClientStream::new(stream);\n\n    // 生成一个 HSET 命令\n    let cmd = CommandRequest::new_hset(\"table1\", \"hello\", \"world\".to_string().into());\n\n    // 发送 HSET 命令\n    let data = client.execute(cmd).await?;\n    info!(\"Got response {:?}\", data);\n\n    Ok(())\n}\n</code></pre><p>src/server.rs：</p><pre><code class=\"language-rust\">use anyhow::Result;\nuse kv2::{MemTable, ProstServerStream, Service, ServiceInner};\nuse tokio::net::TcpListener;\nuse tracing::info;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;()&gt; {\n    tracing_subscriber::fmt::init();\n    let addr = \"127.0.0.1:9527\";\n    let service: Service = ServiceInner::new(MemTable::new()).into();\n    let listener = TcpListener::bind(addr).await?;\n    info!(\"Start listening on {}\", addr);\n    loop {\n        let (stream, addr) = listener.accept().await?;\n        info!(\"Client {:?} connected\", addr);\n        let stream = ProstServerStream::new(stream, service.clone());\n        tokio::spawn(async move { stream.process().await });\n    }\n}\n</code></pre><p>这和之前的 client / server 的代码几乎一致，不同的是，我们使用了自己撰写的 frame  处理方法。</p><p>完成之后，我们可以打开一个命令行窗口，运行：<code>RUST_LOG=info cargo run --bin kvs --quiet</code>。然后在另一个命令行窗口，运行：<code>RUST_LOG=info cargo run --bin kvc --quiet</code>。此时，服务器和客户端都收到了彼此的请求和响应，并且处理正常。现在，我们的 KV server 越来越像回事了！</p><h2>小结</h2><p>网络开发是 Rust 下一个很重要的应用场景。tokio 为我们提供了很棒的异步网络开发的支持。</p><p>在开发网络协议时，你要确定你的 frame 如何封装，一般来说，长度 + protobuf 足以应付绝大多数复杂的协议需求。这一讲我们虽然详细介绍了自己该如何处理用长度封装 frame 的方法，其实 tokio-util 提供了 <a href=\"https://docs.rs/tokio-util/0.6.8/tokio_util/codec/length_delimited/index.html\">LengthDelimitedCodec</a>，可以完成今天关于 frame 部分的处理。如果你自己撰写网络程序，可以直接使用它。</p><p><strong>在网络开发的时候，如何做单元测试是一大痛点，我们可以根据其实现的接口，围绕着接口来构建测试数据结构</strong>，比如 TcpStream 实现了 AsycnRead / AsyncWrite。考虑简洁和可读，为了测试read_frame() ，我们构建了 DummyStream 来协助测试。你也可以用类似的方式处理你所做项目的测试需求。</p><p>结构良好架构清晰的代码，一定是容易测试的代码，纵观整个项目，从 CommandService trait 和 Storage trait 的测试，一路到现在网络层的测试。如果使用 <a href=\"https://github.com/xd009642/tarpaulin\">tarpaulin</a> 来看测试覆盖率，你会发现，这个项目目前已经有 89%了，如果不算 src/server.rs 和 src/client.rs 的话，有接近 92% 的测试覆盖率。即便在生产环境的代码里，这也算是很高质量的测试覆盖率了。</p><pre><code class=\"language-bash\">INFO cargo_tarpaulin::report: Coverage Results:\n|| Tested/Total Lines:\n|| src/client.rs: 0/9 +0.00%\n|| src/network/frame.rs: 80/82 +0.00%\n|| src/network/mod.rs: 65/66 +4.66%\n|| src/pb/mod.rs: 54/75 +0.00%\n|| src/server.rs: 0/11 +0.00%\n|| src/service/command_service.rs: 120/129 +0.00%\n|| src/service/mod.rs: 79/84 +0.00%\n|| src/storage/memory.rs: 34/37 +0.00%\n|| src/storage/mod.rs: 58/58 +0.00%\n|| src/storage/sleddb.rs: 40/43 +0.00%\n||\n89.23% coverage, 530/594 lines covered\n</code></pre><h3>思考题</h3><ol>\n<li>在设计 frame 的时候，如果我们的压缩方法不止 gzip 一种，而是服务器或客户端都会根据各自的情况，在需要的时候做某种算法的压缩。假设服务器和客户端都支持 gzip、lz4 和 zstd 这三种压缩算法。那么 frame 该如何设计呢？需要用几个 bit 来存放压缩算法的信息？</li>\n<li>目前我们的 client 只适合测试，你可以将其修改成一个完整的命令行程序么？小提示，可以使用 clap 或 structopt，用户可以输入不同的命令；或者做一个交互式的命令行，使用 <a href=\"https://docs.rs/shellfish\">shellfish</a> 或 <a href=\"https://github.com/kkawakam/rustyline\">rustyline</a>，就像 redis-cli 那样。</li>\n<li>试着使用 LengthDelimitedCodec 来重写 frame 这一层。</li>\n</ol><p>欢迎在留言区分享你的思考，感谢你的收听。你已经完成Rust学习的第36次打卡啦。</p><h3>延伸阅读</h3><p><a href=\"https://github.com/xd009642/tarpaulin\">tarpaulin</a> 是 Rust 下做测试覆盖率的工具。因为使用了操作系统和 CPU 的特殊指令追踪代码的执行，所以它目前只支持 x86_64 / Linux。测试覆盖率一般在 CI 中使用，所以有 Linux 的支持也足够了。</p><p>一般来说，我们在生产环境中运行的代码，都要求至少有 80% 以上的测试覆盖率。为项目构建足够好的测试覆盖率并不容易，因为这首先意味着写出来的代码要容易测试。所以，<strong>对于新的项目，最好一开始就在 CI 中为测试覆盖率设置一个门槛</strong>，这样可以倒逼着大家保证单元测试的数量。同时，单元测试又会倒逼代码要有良好的结构和良好的接口，否则不容易测试。</p><p>如果觉得有收获，也欢迎你分享给身边的朋友，邀他一起讨论。我们下节课见～</p>","comments":[{"had_liked":false,"id":322650,"user_name":"乌龙猹","can_delete":false,"product_type":"c1","uid":2739949,"ip_address":"","ucode":"43F94A0DEC54BE","user_header":"https://static001.geekbang.org/account/avatar/00/29/ce/ed/3dbe915b.jpg","comment_is_top":false,"comment_ctime":1637543787,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14522445675","product_id":100085301,"comment_content":"内容夯实 思路清晰  结构完整  循序渐进 每周都期待着老师更新课程内容 ","like_count":3},{"had_liked":false,"id":322951,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1320487,"ip_address":"","ucode":"96BAFAA147341F","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","comment_is_top":false,"comment_ctime":1637668310,"is_pvip":false,"replies":[{"id":"118897","content":":)","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1639850795,"ip_address":"","comment_id":322951,"utype":1}],"discussion_count":1,"race_medal":2,"score":"10227602902","product_id":100085301,"comment_content":"越来越接近实际工作了，老师特别用心，目前没找到网络这块讲解这么详细的内容了。","like_count":2,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539858,"discussion_content":":)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639850795,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":326919,"user_name":"荒野林克","can_delete":false,"product_type":"c1","uid":2051117,"ip_address":"","ucode":"8A5F0F03FD901B","user_header":"https://static001.geekbang.org/account/avatar/00/1f/4c/2d/a0d6a610.jpg","comment_is_top":false,"comment_ctime":1639750865,"is_pvip":false,"replies":[{"id":"120821","content":"对，确实如此。多谢指正。","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1642311505,"ip_address":"","comment_id":326919,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5934718161","product_id":100085301,"comment_content":"老师，代码里当 frame 刚好是 2G 时，按理说应该已经越界了吧？","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546466,"discussion_content":"对，确实如此。多谢指正。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642311506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359525,"user_name":"进击的Lancelot","can_delete":false,"product_type":"c1","uid":2620407,"ip_address":"广东","ucode":"3BCC355801DC61","user_header":"https://static001.geekbang.org/account/avatar/00/27/fb/f7/88ab6f83.jpg","comment_is_top":false,"comment_ctime":1665624513,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1665624513","product_id":100085301,"comment_content":"思考题 1: 如果要压缩方式需要同时支持 gzip、lz4、zstd 这三种，则需要 2bit 的标记位，00 表示不压缩、01 表示 gzip、10 表示 lz4、11 表示 zstd，同样也是提取出一个 compressor 的 trait 并针对不同的压缩算法实现相应的 compress 和 decompress 方法，具体可以参考我的代码仓库：https:&#47;&#47;github.com&#47;Phoenix500526&#47;simple_kv&#47;blob&#47;main&#47;src&#47;network&#47;compress 下的文件<br><br>思考题 2: 我采用了 shellfish 实现了 simple-kv-cli，代码可以参考：https:&#47;&#47;github.com&#47;Phoenix500526&#47;simple_kv&#47;blob&#47;main&#47;src&#47;kvc-cli.rs","like_count":0},{"had_liked":false,"id":354920,"user_name":"Rex Wang","can_delete":false,"product_type":"c1","uid":2992421,"ip_address":"北京","ucode":"FB419F40A5BA65","user_header":"","comment_is_top":false,"comment_ctime":1660881209,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660881209","product_id":100085301,"comment_content":"GitHub代码里36_kv&#47;src&#47;error.rs中，KvError去掉了PartialEq属性宏，这是因为std::io::Error不支持binary操作符。<br><br>为了保证之前的test依然有效，可以自己定义一个IoError替换原文中KvError中的std::io::Error，手动实现impl From&lt;std::io::Error&gt; for KvError。","like_count":1}]}