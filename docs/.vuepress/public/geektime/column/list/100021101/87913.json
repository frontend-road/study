{"id":87913,"title":"练习Sample跑起来 | 唯鹿同学的练习手记 第3辑","content":"<p>没想到之前的写的练习心得得到了老师的认可，看来我要更加认真努力练习了。今天来练习第22、27、ASM这三课的Sample。</p><p><a href=\"https://github.com/AndroidAdvanceWithGeektime/Chapter22\"><strong>Chapter22</strong></a></p><blockquote>\n<p>尝试使用Facebook ReDex库来优化我们的安装包。</p>\n</blockquote><p><strong>准备工作</strong></p><p>首先是下载ReDex：</p><pre><code>git clone https://github.com/facebook/redex.git\ncd redex\n</code></pre><p>接着是安装：</p><pre><code>autoreconf -ivf &amp;&amp; ./configure &amp;&amp; make -j4\nsudo make install\n</code></pre><p>在安装时执行到这里，报出下图错误：</p><p><img src=\"https://static001.geekbang.org/resource/image/40/fa/40ba14544153f1ef67bfd21a884c1efa.jpg?wh=1385*604\" alt=\"\"></p><p>其实就是没有安装Boost，所以执行下面的命令安装它。</p><pre><code>brew install boost jsoncpp\n</code></pre><p>安装Boost完成后，再等待十几分钟时间安装ReDex。</p><p>下来就是编译我们的Sample，得到的安装包信息如下。</p><p><img src=\"https://static001.geekbang.org/resource/image/bc/0b/bcf38372f4d9315b9d288607e437040b.jpeg?wh=1446*899\" alt=\"\"></p><p>可以看到有三个Dex文件，APK大小为13.7MB。</p><p><strong>通过ReDex命令优化</strong></p><p>为了让我们可以更加清楚流程，你可以输出ReDex的日志。</p><pre><code>export TRACE=2\n</code></pre><p>去除Debuginfo的方法，需要在项目根目录执行：</p><pre><code>redex --sign -s ReDexSample/keystore/debug.keystore -a androiddebugkey -p android -c redex-test/stripdebuginfo.config -P ReDexSample/proguard-rules.pro  -o redex-test/strip_output.apk ReDexSample/build/outputs/apk/debug/ReDexSample-debug.apk\n</code></pre><p>上面这段很长的命令，其实可以拆解为几部分：</p><ul>\n<li>\n<p><code>--sign</code> 签名信息</p>\n</li>\n<li>\n<p><code>-s</code>（keystore）签名文件路径</p>\n</li>\n<li>\n<p><code>-a</code>（keyalias）签名的别名</p>\n</li>\n<li>\n<p><code>-p</code>（keypass）签名的密码</p>\n</li>\n<li>\n<p><code>-c</code> 指定ReDex的配置文件路径</p>\n</li>\n<li>\n<p><code>-P</code> ProGuard规则文件路径</p>\n</li>\n<li>\n<p><code>-o</code> 输出的文件路径</p>\n</li>\n<li>\n<p>最后是要处理APK文件的路径</p>\n</li>\n</ul><!-- [[[read_end]]] --><p>但在使用时，我遇到了下图的问题：</p><p><img src=\"https://static001.geekbang.org/resource/image/f9/42/f942ef115b2293562b6c3d533c0abd42.png?wh=1419*438\" alt=\"\"></p><p>这里是找不到<code>Zipalign</code>，所以需要我们配置Android SDK的根目录路径，添加在原命令前面：</p><pre><code>ANDROID_SDK=/path/to/android/sdk redex [... arguments ...]\n</code></pre><p>结果如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/4f/28/4f442a95f1518cbe38311b042cdda028.png?wh=2010*870\" alt=\"\"></p><p>实际的优化效果是，原Debug包为14.21MB，去除Debuginfo的方法后为12.91MB，效果还是不错的。<strong>去除的内容就是一些调试信息及堆栈行号。</strong></p><p><img src=\"https://static001.geekbang.org/resource/image/fd/07/fda8e0b637df6f145f9867764720ab07.jpeg?wh=1411*937\" alt=\"\"></p><p>不过老师在Sample的proguard-rules.pro中添加了<code>-keepattributes SourceFile,LineNumberTable</code>保留了行号信息。</p><p>所以处理后的包安装后进入首页，还是可以看到堆栈信息的行号。</p><p><strong>Dex重分包的方法</strong></p><pre><code>redex --sign -s ReDexSample/keystore/debug.keystore -a androiddebugkey -p android -c redex-test/interdex.config -P ReDexSample/proguard-rules.pro  -o redex-test/interdex_output.apk ReDexSample/build/outputs/apk/debug/ReDexSample-debug.apk\n</code></pre><p>和之前的命令一样，只是<code>-c</code>使用的配置文件为interdex.config。</p><p>输出信息：</p><p><img src=\"https://static001.geekbang.org/resource/image/29/aa/293f13ab6fe75ede7d4840d04f0d56aa.jpeg?wh=1396*832\" alt=\"\"></p><p>优化效果为，原Debug包为14.21MB、3个Dex，优化后为13.34MB、2个Dex。</p><p><img src=\"https://static001.geekbang.org/resource/image/77/c3/77abb69a81448e677b64bb5cbd59fec3.jpeg?wh=1436*901\" alt=\"\"></p><p>根据老师的介绍，<strong>如果你的应用有4个以上的Dex，这个体积优化至少有10%</strong>。 看来效果还是很棒棒的。至于其他问题，比如在Windows环境使用ReDex，可以参看ReDex的<a href=\"https://fbredex.com/docs/installation\">使用文档</a>。</p><p><a href=\"https://github.com/AndroidAdvanceWithGeektime/Chapter27\"><strong>Chapter27</strong></a></p><blockquote>\n<p>利用AspectJ实现插桩的例子。</p>\n</blockquote><p>效果和<a href=\"https://github.com/AndroidAdvanceWithGeektime/Chapter07\">Chapter07</a>是一样的，只是Chapter07使用的是ASM方式实现的，这次是AspectJ实现。ASM与AspectJ都是Java字节码处理框架，相比较来说AspectJ使用更加简单，同样的功能实现只需下面这点代码，但是ASM比AspectJ更加高效和灵活。</p><p>AspectJ实现代码：</p><pre><code>@Aspect\npublic class TraceTagAspectj {\n\n    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n    @Before(&quot;execution(* **(..))&quot;)\n    public void before(JoinPoint joinPoint) {\n        Trace.beginSection(joinPoint.getSignature().toString());\n    }\n\n    /**\n     * hook method when it's called out.\n     */\n    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\n    @After(&quot;execution(* **(..))&quot;)\n    public void after() {\n        Trace.endSection();\n    }\n</code></pre><p>简单介绍下上面代码的意思：</p><ul>\n<li>\n<p><code>@Aspect</code>：在编译时AspectJ会查找被<code>@Aspect</code>注解的类，然后执行我们的AOP实现。</p>\n</li>\n<li>\n<p><code>@Before</code>：可以简单理解为方法执行前。</p>\n</li>\n<li>\n<p><code>@After</code>：可以简单理解为方法执行后。</p>\n</li>\n<li>\n<p><code>execution</code>：方法执行。</p>\n</li>\n<li>\n<p><code>* **(..)</code>：第一个星号代表任意返回类型，第二个星号代表任意类，第三个代表任意方法，括号内为方法参数无限制。星号和括号内都是可以替换为具体值，比如String TestClass.test(String)。</p>\n</li>\n</ul><p>知道了相关注解的含义，那么实现的代码含义就是，<strong>所有方法在执行前后插入相应指定操作</strong>。</p><p>效果对比如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/64/77/644381974bcd1e3b2d468cdeb432ed77.png?wh=664*388\" alt=\"\"><br>\n<img src=\"https://static001.geekbang.org/resource/image/02/ca/02b99a9e7fd70da8d9fdf086f31c78ca.png?wh=1738*916\" alt=\"\"></p><p>下来实现给MainActivity的<code>onResume</code>方法增加try catch。</p><pre><code>@Aspect\npublic class TryCatchAspect {\n    \n    @Pointcut(&quot;execution(* com.sample.systrace.MainActivity.onResume())&quot;) // &lt;- 指定类与方法\n    public void methodTryCatch() {\n    }\n\n    @Around(&quot;methodTryCatch()&quot;)\n    public void aroundTryJoinPoint(ProceedingJoinPoint joinPoint) throws Throwable {\n       \n         // try catch\n         try {\n             joinPoint.proceed(); // &lt;- 调用原方法\n         } catch (Exception e) {\n              e.printStackTrace();\n         }\n    }\n}\n</code></pre><p>上面用到了两个新注解：</p><ul>\n<li>\n<p><code>@Around</code>：用于替换以前的代码，使用joinPoint.proceed()可以调用原方法。</p>\n</li>\n<li>\n<p><code>@Pointcut</code>：指定一个切入点。</p>\n</li>\n</ul><p>实现就是指定一个切入点，利用替换原方法的思路包裹一层try catch。</p><p>效果对比如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/7f/c0/7f4a5bb6995c53872966c956d7e78ec0.png?wh=635*420\" alt=\"\"><br>\n<img src=\"https://static001.geekbang.org/resource/image/08/bc/08d123aa792c8f4fc8538fd5658cb9bc.png?wh=1723*902\" alt=\"\"></p><p>当然AspectJ还有很多用法，Sample中包含有《AspectJ程序设计指南》，便于我们具体了解和学习AspectJ。</p><p><a href=\"https://github.com/AndroidAdvanceWithGeektime/Chapter-ASM\"><strong>Chapter-ASM</strong></a></p><blockquote>\n<p>Sample利用ASM实现了统计方法耗时和替换项目中所有的new Thread。</p>\n</blockquote><ul>\n<li>\n<p>运行项目首先要注掉ASMSample build.gradle的<code>apply plugin: 'com.geektime.asm-plugin'</code>和根目录build.gradle的<code>classpath (\"com.geektime.asm:asm-gradle-plugin:1.0\") { changing = true }</code>。</p>\n</li>\n<li>\n<p>运行<code>gradle task \":asm-gradle-plugin:buildAndPublishToLocalMaven\"</code>编译plugin插件，编译的插件在本地<code>.m2\\repository</code>目录下</p>\n</li>\n<li>\n<p>打开第一步注掉的内容就可以运行了。</p>\n</li>\n</ul><p>实现的大致过程是，先利用Transform遍历所有文件，再通过ASM的<code>visitMethod</code>遍历所有方法，最后通过AdviceAdapter实现最终的修改字节码。具体实现可以看代码和<a href=\"https://time.geekbang.org/column/article/83148\">《练习Sample跑起来 | ASM插桩强化练习》</a>。</p><p>效果对比：</p><p><img src=\"https://static001.geekbang.org/resource/image/ee/0b/ee98c9349e62d5aca66b883a89cd470b.png?wh=734*601\" alt=\"\"><br>\n<img src=\"https://static001.geekbang.org/resource/image/d0/3a/d0dd3c68ac2d56b6eebf6853f871c43a.png?wh=1055*920\" alt=\"\"></p><p>下面是两个练习：</p><p>1.给某个方法增加try catch</p><p>这里我就给MainActivity的<code>mm</code>方法进行try catch。实现很简单，直接修改ASMCode的TraceMethodAdapter。</p><pre><code>public static class TraceMethodAdapter extends AdviceAdapter {\n\n        private final String methodName;\n        private final String className;\n        private final Label tryStart = new Label();\n        private final Label tryEnd = new Label();\n        private final Label catchStart = new Label();\n        private final Label catchEnd = new Label();\n\n        protected TraceMethodAdapter(int api, MethodVisitor mv, int access, String name, String desc, String className) {\n            super(api, mv, access, name, desc);\n            this.className = className;\n            this.methodName = name;\n        }\n\n        @Override\n        protected void onMethodEnter() {\n            if (className.equals(&quot;com/sample/asm/MainActivity&quot;) &amp;&amp; methodName.equals(&quot;mm&quot;)) {\n                mv.visitTryCatchBlock(tryStart, tryEnd, catchStart, &quot;java/lang/Exception&quot;);\n                mv.visitLabel(tryStart);\n            }\n        }\n\n        @Override\n        protected void onMethodExit(int opcode) {\n            if (className.equals(&quot;com/sample/asm/MainActivity&quot;) &amp;&amp; methodName.equals(&quot;mm&quot;)) {\n                mv.visitLabel(tryEnd);\n                mv.visitJumpInsn(GOTO, catchEnd);\n                mv.visitLabel(catchStart);\n                mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/RuntimeException&quot;, &quot;printStackTrace&quot;, &quot;()V&quot;, false);\n                mv.visitInsn(Opcodes.RETURN);\n                mv.visitLabel(catchEnd);\n            }\n        }\n</code></pre><p><code>visitTryCatchBlock</code>方法：前三个参数均是Label实例，其中一、二表示try块的范围，三则是catch块的开始位置，第四个参数是异常类型。其他的方法及参数就不细说了，具体你可以参考<a href=\"https://asm.ow2.io/asm4-guide.pdf\">ASM文档</a>。</p><p>实现类似AspectJ，在方法执行开始及结束时插入我们的代码。</p><p>效果我就不截图了，代码如下：</p><pre><code>public void mm() {\n        try {\n            A a = new A(new B(2));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n</code></pre><p>2.查看代码中谁获取了IMEI</p><p>这个就更简单了，直接寻找谁使用了TelephonyManager的<code>getDeviceId</code>方法，并且在Sample中有答案。</p><pre><code>public class IMEIMethodAdapter extends AdviceAdapter {\n\n    private final String methodName;\n    private final String className;\n\n    protected IMEIMethodAdapter(int api, MethodVisitor mv, int access, String name, String desc, String className) {\n        super(api, mv, access, name, desc);\n        this.className = className;\n        this.methodName = name;\n    }\n\n    @Override\n    public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n        super.visitMethodInsn(opcode, owner, name, desc, itf);\n\n        if (owner.equals(&quot;android/telephony/TelephonyManager&quot;) &amp;&amp; name.equals(&quot;getDeviceId&quot;) &amp;&amp; desc.equals(&quot;()Ljava/lang/String;&quot;)) {\n            Log.e(&quot;asmcode&quot;, &quot;get imei className:%s, method:%s, name:%s&quot;, className, methodName, name);\n        }\n    }\n}  \n</code></pre><p>Build后输出如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/2d/94/2d5c01eee4fc651b5831c0341d6e0994.png?wh=814*339\" alt=\"\"></p><p>总体来说ASM的上手难度还是高于AspectJ，需要我们了解编译后的字节码，这里所使用的功能也只是冰山一角。课代表鹏飞同学推荐的ASM Bytecode Outline插件是个好帮手！最后我将我练习的代码也上传到了<a href=\"https://github.com/simplezhli/Chapter-ASM\">GitHub</a>，里面还包括一份中文版的ASM文档，有兴趣的同学可以下载看看。</p><p>参考</p><ul>\n<li><a href=\"http://time.geekbang.org/column/article/83148\">练习Sample跑起来 | ASM插桩强化练</a></li>\n<li><a href=\"http://asm.ow2.io/asm4-guide.pdf\">ASM文档</a></li>\n</ul><p></p>","neighbors":{"left":{"article_title":"练习Sample跑起来 | 唯鹿同学的练习手记 第2辑","id":84405},"right":{"article_title":"Android JVM TI机制详解（内含福利彩蛋）","id":74484}},"comments":[{"had_liked":false,"id":85604,"user_name":"小小代码","can_delete":false,"product_type":"c1","uid":1290642,"ip_address":"","ucode":"F3D4E2C23FC9BD","user_header":"https://static001.geekbang.org/account/avatar/00/13/b1/92/f3dabcb1.jpg","comment_is_top":false,"comment_ctime":1555138937,"is_pvip":false,"replies":[{"id":"31108","content":"因为Sample的是保留了行号，你需要在配置文件里面设成所有都去掉","user_name":"作者回复","user_name_real":"张绍文","uid":"1009577","ctime":1555397378,"ip_address":"","comment_id":85604,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555138937","product_id":100021101,"comment_content":"试了下Redex去除Dex文件Debuginfo行号信息的功能，发现行号由正确的com.sample.redex.MainActivity.onCreate(MainActivity.java:20)变为不正确的com.sample.redex.MainActivity.onCreate(Unknown Source:13)，并没有像支付宝所说的变成-1","like_count":0,"discussions":[{"author":{"id":1009577,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/a9/e251ace7.jpg","nickname":"张绍文","note":"","ucode":"94B49E5F80BFDE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446731,"discussion_content":"因为Sample的是保留了行号，你需要在配置文件里面设成所有都去掉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555397378,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}