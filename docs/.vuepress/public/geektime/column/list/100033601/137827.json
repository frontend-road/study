{"id":137827,"title":"20 | async/await：使用同步的方式去写异步代码","content":"<p>在<a href=\"https://time.geekbang.org/column/article/136895\">上篇文章</a>中，我们介绍了怎么使用Promise来实现回调操作，使用Promise能很好地解决回调地狱的问题，但是这种方式充满了Promise的then()方法，如果处理流程比较复杂的话，那么整段代码将充斥着then，语义化不明显，代码不能很好地表示执行流程。</p><p>比如下面这样一个实际的使用场景：我先请求极客邦的内容，等返回信息之后，我再请求极客邦的另外一个资源。下面代码展示的是使用fetch来实现这样的需求，fetch被定义在window对象中，可以用它来发起对远程资源的请求，该方法返回的是一个Promise对象，这和我们上篇文章中讲的XFetch很像，只不过fetch是浏览器原生支持的，并有没利用XMLHttpRequest来封装。</p><pre><code>fetch('https://www.geekbang.org')\n      .then((response) =&gt; {\n          console.log(response)\n          return fetch('https://www.geekbang.org/test')\n      }).then((response) =&gt; {\n          console.log(response)\n      }).catch((error) =&gt; {\n          console.log(error)\n      })\n</code></pre><p>从这段Promise代码可以看出来，使用promise.then也是相当复杂，虽然整个请求流程已经线性化了，但是代码里面包含了大量的then函数，使得代码依然不是太容易阅读。<strong>基于这个原因，ES7 引入了async/await，这是JavaScript异步编程的一个重大改进，提供了在不阻塞主线程的情况下使用同步代码实现异步访问资源的能力，并且使得代码逻辑更加清晰</strong>。你可以参考下面这段代码：</p><!-- [[[read_end]]] --><pre><code>async function foo(){\n  try{\n    let response1 = await fetch('https://www.geekbang.org')\n    console.log('response1')\n    console.log(response1)\n    let response2 = await fetch('https://www.geekbang.org/test')\n    console.log('response2')\n    console.log(response2)\n  }catch(err) {\n       console.error(err)\n  }\n}\nfoo()\n</code></pre><p>通过上面代码，你会发现整个异步处理的逻辑都是使用同步代码的方式来实现的，而且还支持try catch来捕获异常，这就是完全在写同步代码，所以是非常符合人的线性思维的。但是很多人都习惯了异步回调的编程思维，对于这种采用同步代码实现异步逻辑的方式，还需要一个转换的过程，因为这中间隐藏了一些容易让人迷惑的细节。</p><p>那么本篇文章我们继续深入，看看JavaScript引擎是如何实现async/await的。如果上来直接介绍async/await的使用方式的话，那么你可能会有点懵，所以我们就从其最底层的技术点一步步往上讲解，从而带你彻底弄清楚async和await到底是怎么工作的。</p><p>本文我们首先介绍生成器（Generator）是如何工作的，接着讲解Generator的底层实现机制——协程（Coroutine）；又因为async/await使用了Generator和Promise两种技术，所以紧接着我们就通过Generator和Promise来分析async/await到底是如何以同步的方式来编写异步代码的。</p><h2>生成器 VS 协程</h2><p>我们先来看看什么是生成器函数？</p><p><strong>生成器函数是一个带星号函数，而且是可以暂停执行和恢复执行的</strong>。我们可以看下面这段代码：</p><pre><code>function* genDemo() {\n    console.log(&quot;开始执行第一段&quot;)\n    yield 'generator 2'\n\n    console.log(&quot;开始执行第二段&quot;)\n    yield 'generator 2'\n\n    console.log(&quot;开始执行第三段&quot;)\n    yield 'generator 2'\n\n    console.log(&quot;执行结束&quot;)\n    return 'generator 2'\n}\n\nconsole.log('main 0')\nlet gen = genDemo()\nconsole.log(gen.next().value)\nconsole.log('main 1')\nconsole.log(gen.next().value)\nconsole.log('main 2')\nconsole.log(gen.next().value)\nconsole.log('main 3')\nconsole.log(gen.next().value)\nconsole.log('main 4')\n</code></pre><p>执行上面这段代码，观察输出结果，你会发现函数genDemo并不是一次执行完的，全局代码和genDemo函数交替执行。其实这就是生成器函数的特性，可以暂停执行，也可以恢复执行。下面我们就来看看生成器函数的具体使用方式：</p><ol>\n<li>在生成器函数内部执行一段代码，如果遇到yield关键字，那么JavaScript引擎将返回关键字后面的内容给外部，并暂停该函数的执行。</li>\n<li>外部函数可以通过next方法恢复函数的执行。</li>\n</ol><p>关于函数的暂停和恢复，相信你一定很好奇这其中的原理，那么接下来我们就来简单介绍下JavaScript引擎V8是如何实现一个函数的暂停和恢复的，这也会有助于你理解后面要介绍的async/await。</p><p>要搞懂函数为何能暂停和恢复，那你首先要了解协程的概念。<strong>协程是一种比线程更加轻量级的存在</strong>。你可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程，比如当前执行的是A协程，要启动B协程，那么A协程就需要将主线程的控制权交给B协程，这就体现在A协程暂停执行，B协程恢复执行；同样，也可以从B协程中启动A协程。通常，<strong>如果从A协程启动B协程，我们就把A协程称为B协程的父协程</strong>。</p><p>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p><p>为了让你更好地理解协程是怎么执行的，我结合上面那段代码的执行过程，画出了下面的“协程执行流程图”，你可以对照着代码来分析：</p><p><img src=\"https://static001.geekbang.org/resource/image/5e/37/5ef98bd693bcd5645e83418b0856e437.png?wh=1142*497\" alt=\"\"></p><center><span class=\"reference\">协程执行流程图</span></center><p>从图中可以看出来协程的四点规则：</p><ol>\n<li>通过调用生成器函数genDemo来创建一个协程gen，创建之后，gen协程并没有立即执行。</li>\n<li>要让gen协程执行，需要通过调用gen.next。</li>\n<li>当协程正在执行的时候，可以通过yield关键字来暂停gen协程的执行，并返回主要信息给父协程。</li>\n<li>如果协程在执行期间，遇到了return关键字，那么JavaScript引擎会结束当前协程，并将return后面的内容返回给父协程。</li>\n</ol><p>不过，对于上面这段代码，你可能又有这样疑问：父协程有自己的调用栈，gen协程时也有自己的调用栈，当gen协程通过yield把控制权交给父协程时，V8是如何切换到父协程的调用栈？当父协程通过gen.next恢复gen协程时，又是如何切换gen协程的调用栈？</p><p>要搞清楚上面的问题，你需要关注以下两点内容。</p><p>第一点：gen协程和父协程是在主线程上交互执行的，并不是并发执行的，它们之前的切换是通过yield和gen.next来配合完成的。</p><p>第二点：当在gen协程中调用了yield方法时，JavaScript引擎会保存gen协程当前的调用栈信息，并恢复父协程的调用栈信息。同样，当在父协程中执行gen.next时，JavaScript引擎会保存父协程的调用栈信息，并恢复gen协程的调用栈信息。</p><p>为了直观理解父协程和gen协程是如何切换调用栈的，你可以参考下图：</p><p><img src=\"https://static001.geekbang.org/resource/image/92/40/925f4a9a1c85374352ee93c5e3c41440.png?wh=1142*795\" alt=\"\"></p><center><span class=\"reference\">gen协程和父协程之间的切换</span></center><p>到这里相信你已经弄清楚了协程是怎么工作的，其实在JavaScript中，生成器就是协程的一种实现方式，这样相信你也就理解什么是生成器了。那么接下来，我们使用生成器和Promise来改造开头的那段Promise代码。改造后的代码如下所示：</p><pre><code>//foo函数\nfunction* foo() {\n    let response1 = yield fetch('https://www.geekbang.org')\n    console.log('response1')\n    console.log(response1)\n    let response2 = yield fetch('https://www.geekbang.org/test')\n    console.log('response2')\n    console.log(response2)\n}\n\n//执行foo函数的代码\nlet gen = foo()\nfunction getGenPromise(gen) {\n    return gen.next().value\n}\ngetGenPromise(gen).then((response) =&gt; {\n    console.log('response1')\n    console.log(response)\n    return getGenPromise(gen)\n}).then((response) =&gt; {\n    console.log('response2')\n    console.log(response)\n})\n</code></pre><p>从图中可以看到，foo函数是一个生成器函数，在foo函数里面实现了用同步代码形式来实现异步操作；但是在foo函数外部，我们还需要写一段执行foo函数的代码，如上述代码的后半部分所示，那下面我们就来分析下这段代码是如何工作的。</p><ul>\n<li>首先执行的是<code>let gen = foo()</code>，创建了gen协程。</li>\n<li>然后在父协程中通过执行gen.next把主线程的控制权交给gen协程。</li>\n<li>gen协程获取到主线程的控制权后，就调用fetch函数创建了一个Promise对象response1，然后通过yield暂停gen协程的执行，并将response1返回给父协程。</li>\n<li>父协程恢复执行后，调用response1.then方法等待请求结果。</li>\n<li>等通过fetch发起的请求完成之后，会调用then中的回调函数，then中的回调函数拿到结果之后，通过调用gen.next放弃主线程的控制权，将控制权交gen协程继续执行下个请求。</li>\n</ul><p>以上就是协程和Promise相互配合执行的一个大致流程。不过通常，我们把执行生成器的代码封装成一个函数，并把这个执行生成器代码的函数称为<strong>执行器</strong>（可参考著名的co框架），如下面这种方式：</p><pre><code>function* foo() {\n    let response1 = yield fetch('https://www.geekbang.org')\n    console.log('response1')\n    console.log(response1)\n    let response2 = yield fetch('https://www.geekbang.org/test')\n    console.log('response2')\n    console.log(response2)\n}\nco(foo());\n</code></pre><p>通过使用生成器配合执行器，就能实现使用同步的方式写出异步代码了，这样也大大加强了代码的可读性。</p><h2>async/await</h2><p>虽然生成器已经能很好地满足我们的需求了，但是程序员的追求是无止境的，这不又在ES7中引入了async/await，这种方式能够彻底告别执行器和生成器，实现更加直观简洁的代码。其实async/await技术背后的秘密就是Promise和生成器应用，往低层说就是微任务和协程应用。要搞清楚async和await的工作原理，我们就得对async和await分开分析。</p><h3>1. async</h3><p>我们先来看看async到底是什么？根据MDN定义，async是一个通过<strong>异步执行</strong>并<strong>隐式返回 Promise</strong> 作为结果的函数。</p><p>对async函数的理解，这里需要重点关注两个词：<strong>异步执行</strong>和<strong>隐式返回 Promise</strong>。</p><p>关于异步执行的原因，我们一会儿再分析。这里我们先来看看是如何隐式返回Promise的，你可以参考下面的代码：</p><pre><code>async function foo() {\n    return 2\n}\nconsole.log(foo())  // Promise {&lt;resolved&gt;: 2}\n</code></pre><p>执行这段代码，我们可以看到调用async声明的foo函数返回了一个Promise对象，状态是resolved，返回结果如下所示：</p><pre><code>Promise {&lt;resolved&gt;: 2}\n</code></pre><h3>2. await</h3><p>我们知道了async函数返回的是一个Promise对象，那下面我们再结合文中这段代码来看看await到底是什么。</p><pre><code>async function foo() {\n    console.log(1)\n    let a = await 100\n    console.log(a)\n    console.log(2)\n}\nconsole.log(0)\nfoo()\nconsole.log(3)\n</code></pre><p>观察上面这段代码，你能判断出打印出来的内容是什么吗？这得先来分析async结合await到底会发生什么。在详细介绍之前，我们先站在协程的视角来看看这段代码的整体执行流程图：</p><p><img src=\"https://static001.geekbang.org/resource/image/8d/94/8dcd8cfa77d43d1fb928d8b001229b94.png?wh=1142*508\" alt=\"\"></p><center><span class=\"reference\">async/await执行流程图</span></center><p>结合上图，我们来一起分析下async/await的执行流程。</p><p>首先，执行<code>console.log(0)</code>这个语句，打印出来0。</p><p>紧接着就是执行foo函数，由于foo函数是被async标记过的，所以当进入该函数的时候，JavaScript引擎会保存当前的调用栈等信息，然后执行foo函数中的<code>console.log(1)</code>语句，并打印出1。</p><p>接下来就执行到foo函数中的<code>await 100</code>这个语句了，这里是我们分析的重点，因为在执行<code>await 100</code>这个语句时，JavaScript引擎在背后为我们默默做了太多的事情，那么下面我们就把这个语句拆开，来看看JavaScript到底都做了哪些事情。</p><p>当执行到<code>await 100</code>时，会默认创建一个Promise对象，代码如下所示：</p><pre><code>let promise_ = new Promise((resolve,reject){\n  resolve(100)\n})\n</code></pre><p>在这个promise_对象创建的过程中，我们可以看到在executor函数中调用了resolve函数，JavaScript引擎会将该任务提交给微任务队列（<a href=\"https://time.geekbang.org/column/article/136895\">上一篇文章</a>中我们讲解过）。</p><p>然后JavaScript引擎会暂停当前协程的执行，将主线程的控制权转交给父协程执行，同时会将promise_对象返回给父协程。</p><p>主线程的控制权已经交给父协程了，这时候父协程要做的一件事是调用promise_.then来监控promise状态的改变。</p><p>接下来继续执行父协程的流程，这里我们执行<code>console.log(3)</code>，并打印出来3。随后父协程将执行结束，在结束之前，会进入微任务的检查点，然后执行微任务队列，微任务队列中有<code>resolve(100)</code>的任务等待执行，执行到这里的时候，会触发promise_.then中的回调函数，如下所示：</p><pre><code>promise_.then((value)=&gt;{\n   //回调函数被激活后\n  //将主线程控制权交给foo协程，并将vaule值传给协程\n})\n</code></pre><p>该回调函数被激活以后，会将主线程的控制权交给foo函数的协程，并同时将value值传给该协程。</p><p>foo协程激活之后，会把刚才的value值赋给了变量a，然后foo协程继续执行后续语句，执行完成之后，将控制权归还给父协程。</p><p>以上就是await/async的执行流程。正是因为async和await在背后为我们做了大量的工作，所以我们才能用同步的方式写出异步代码来。</p><h2>总结</h2><p>好了，今天就介绍到这里，下面我来总结下今天的主要内容。</p><p>Promise的编程模型依然充斥着大量的then方法，虽然解决了回调地狱的问题，但是在语义方面依然存在缺陷，代码中充斥着大量的then函数，这就是async/await出现的原因。</p><p>使用async/await可以实现用同步代码的风格来编写异步代码，这是因为async/await的基础技术使用了生成器和Promise，生成器是协程的实现，利用生成器能实现生成器函数的暂停和恢复。</p><p>另外，V8引擎还为async/await做了大量的语法层面包装，所以了解隐藏在背后的代码有助于加深你对async/await的理解。</p><p>async/await无疑是异步编程领域非常大的一个革新，也是未来的一个主流的编程风格。其实，除了JavaScript，Python、Dart、C#等语言也都引入了async/await，使用它不仅能让代码更加整洁美观，而且还能确保该函数始终都能返回Promise。</p><h2>思考时间</h2><p>下面这段代码整合了定时器、Promise和async/await，你能分析出来这段代码执行后输出的内容吗？</p><pre><code>async function foo() {\n    console.log('foo')\n}\nasync function bar() {\n    console.log('bar start')\n    await foo()\n    console.log('bar end')\n}\nconsole.log('script start')\nsetTimeout(function () {\n    console.log('setTimeout')\n}, 0)\nbar();\nnew Promise(function (resolve) {\n    console.log('promise executor')\n    resolve();\n}).then(function () {\n    console.log('promise then')\n})\nconsole.log('script end')\n</code></pre><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p><p></p>","comments":[{"had_liked":false,"id":134450,"user_name":"mfist","can_delete":false,"product_type":"c1","uid":1373624,"ip_address":"","ucode":"4F99F422C23FB4","user_header":"https://static001.geekbang.org/account/avatar/00/14/f5/b8/9f165f4b.jpg","comment_is_top":false,"comment_ctime":1568847815,"is_pvip":false,"discussion_count":20,"race_medal":0,"score":"448245446599","product_id":100033601,"comment_content":"1. 首先在主协程中初始化异步函数foo和bar，碰到console.log打印script start；<br>2. 解析到setTimeout，初始化一个Timer，创建一个新的task<br>3. 执行bar函数，将控制权交给协程，输出bar start，碰到await，执行foo，输出foo，创建一个 Promise返回给主协程<br>4. 将返回的promise添加到微任务队列，向下执行 new Promise，输出 promise executor，返回resolve 添加到微任务队列<br>5. 输出script end<br>6. 当前task结束之前检查微任务队列，执行第一个微任务，将控制器交给协程输出bar end<br>7. 执行第二个微任务 输出 promise then<br>8. 当前任务执行完毕进入下一个任务，输出setTimeout","like_count":104,"discussions":[{"author":{"id":1821835,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/cc/8b/0060a75c.jpg","nickname":"tomision","note":"","ucode":"92A251597DADB0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":165757,"discussion_content":"执行bar函数，将控制权交给协程，输出bar start，碰到await，执行foo，此时为什么不是又出现一个协程？","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1581322861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1506085,"avatar":"https://static001.geekbang.org/account/avatar/00/16/fb/25/f6743e97.jpg","nickname":"进击的前端er","note":"","ucode":"9229B410F48B85","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269750,"discussion_content":"chrome80浏览器，执行先输出 promise then","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589945429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2147566,"avatar":"https://static001.geekbang.org/account/avatar/00/20/c4/ee/dd012869.jpg","nickname":"栗子","note":"","ucode":"5C3FC815418DFC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1506085,"avatar":"https://static001.geekbang.org/account/avatar/00/16/fb/25/f6743e97.jpg","nickname":"进击的前端er","note":"","ucode":"9229B410F48B85","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552298,"discussion_content":"这个是什么原因呢？我这边也遇到了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645403930,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":269750,"ip_address":""},"score":552298,"extra":""},{"author":{"id":3053127,"avatar":"","nickname":"Geek_884254","note":"","ucode":"43F3296D15F0E9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1506085,"avatar":"https://static001.geekbang.org/account/avatar/00/16/fb/25/f6743e97.jpg","nickname":"进击的前端er","note":"","ucode":"9229B410F48B85","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583860,"discussion_content":"最新的chrome浏览器没有这种情况","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660451066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":269750,"ip_address":"海南"},"score":583860,"extra":""}]},{"author":{"id":1106123,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKOASyV1lpdkW6It8WQltNGj9021PTibqOwRUTccaSUEM1GmQThOTIRp9Eu7XNZZFfGGNveLbUSw9Q/132","nickname":"tick","note":"","ucode":"D2C864306C06CB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":21138,"discussion_content":"第3步应该是返回的Promise的参数还是个Promise对象，会再次放一次微任务队列","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1569423302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1394410,"avatar":"https://static001.geekbang.org/account/avatar/00/15/46/ea/b86667b8.jpg","nickname":"王玄","note":"","ucode":"E54ABB340D1E49","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368689,"discussion_content":"主协程 是不是应该是主线程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618803115,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2416820,"avatar":"https://static001.geekbang.org/account/avatar/00/24/e0/b4/a8b7b04c.jpg","nickname":"Lehamber","note":"","ucode":"5882CCFD72C26A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1394410,"avatar":"https://static001.geekbang.org/account/avatar/00/15/46/ea/b86667b8.jpg","nickname":"王玄","note":"","ucode":"E54ABB340D1E49","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372214,"discussion_content":"可以这么理解，我觉的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620226869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":368689,"ip_address":""},"score":372214,"extra":""},{"author":{"id":2741739,"avatar":"","nickname":"Geek_1dcec7","note":"","ucode":"5D600692D19865","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1394410,"avatar":"https://static001.geekbang.org/account/avatar/00/15/46/ea/b86667b8.jpg","nickname":"王玄","note":"","ucode":"E54ABB340D1E49","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390246,"discussion_content":"就是主携程,也可以说是父携程,因为foo协程是从父协程中转移过去的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1629726765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":368689,"ip_address":""},"score":390246,"extra":""}]},{"author":{"id":1229032,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c0/e8/bf987d79.jpg","nickname":"Rookie","note":"","ucode":"893C46F39346AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348713,"discussion_content":"主协程到底是不是渲染进程？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612686425,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1229032,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c0/e8/bf987d79.jpg","nickname":"Rookie","note":"","ucode":"893C46F39346AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348250,"discussion_content":"父协程到底是个啥，有人能说下么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612491559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1246059,"avatar":"https://static001.geekbang.org/account/avatar/00/13/03/6b/f31d4538.jpg","nickname":"这么写的闫","note":"","ucode":"95B0D1E1A094C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308554,"discussion_content":"所以父协程是主线程吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600995969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1392260,"avatar":"https://static001.geekbang.org/account/avatar/00/15/3e/84/db2de66a.jpg","nickname":"mark_huang","note":"","ucode":"C9CDE7123B856B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292668,"discussion_content":"老师不出来解答一下吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595301986,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1585737,"avatar":"https://static001.geekbang.org/account/avatar/00/18/32/49/a97fc6df.jpg","nickname":"Mr. Cheng","note":"","ucode":"A6D81A7D92160E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":47978,"discussion_content":"360急速浏览器极速模式先执行promise then,后执行bar end","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573439155,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1560751,"avatar":"https://static001.geekbang.org/account/avatar/00/17/d0/af/c91083c3.jpg","nickname":"阿懂","note":"","ucode":"DC49DF11305C00","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1585737,"avatar":"https://static001.geekbang.org/account/avatar/00/18/32/49/a97fc6df.jpg","nickname":"Mr. Cheng","note":"","ucode":"A6D81A7D92160E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158756,"discussion_content":"Safari 也是这样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580621208,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":47978,"ip_address":""},"score":158756,"extra":""}]},{"author":{"id":1622536,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c2/08/d008ca7e.jpg","nickname":"紫竹林","note":"","ucode":"006E053C8DBD39","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":36940,"discussion_content":"node v10 版本下，foo函数如果返回的不是Promise，则先执行bar end后执行promise then","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571466679,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1295848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/yicibWmBIDaSpBYI5wCBDQcYu6mxjvz3XZzBibxSNXFfqCS6OJOjvy2Nc2lyDicZfmneW9ZY4KbicA1sNgLktVSicgkw/132","nickname":"老余","note":"","ucode":"17AC6C60D0EB86","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":25599,"discussion_content":"是的，和 Y 说的一样，node v10.16.1和浏览器 chrome 75环境跑出来的不一致，怎么理解？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570541734,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1555967,"avatar":"https://static001.geekbang.org/account/avatar/00/17/bd/ff/f4f2ae6a.jpg","nickname":"Y","note":"","ucode":"4AA6170E230C0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":20172,"discussion_content":"实际跑出来的结果是先执行promise then后执行bar end","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569286952,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1373624,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f5/b8/9f165f4b.jpg","nickname":"mfist","note":"","ucode":"4F99F422C23FB4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1555967,"avatar":"https://static001.geekbang.org/account/avatar/00/17/bd/ff/f4f2ae6a.jpg","nickname":"Y","note":"","ucode":"4AA6170E230C0C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":20180,"discussion_content":"在node环境下面，还是浏览器环境下？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569287303,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":20172,"ip_address":""},"score":20180,"extra":""},{"author":{"id":1555967,"avatar":"https://static001.geekbang.org/account/avatar/00/17/bd/ff/f4f2ae6a.jpg","nickname":"Y","note":"","ucode":"4AA6170E230C0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1373624,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f5/b8/9f165f4b.jpg","nickname":"mfist","note":"","ucode":"4F99F422C23FB4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":20181,"discussion_content":"node","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569287381,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":20180,"ip_address":""},"score":20181,"extra":""},{"author":{"id":1623567,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c6/0f/3937645e.jpg","nickname":"NBE01","note":"","ucode":"DF0D22D4495D54","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1555967,"avatar":"https://static001.geekbang.org/account/avatar/00/17/bd/ff/f4f2ae6a.jpg","nickname":"Y","note":"","ucode":"4AA6170E230C0C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":26666,"discussion_content":"最新的node版本 12 已经和浏览器的一样了。 听说是调整event loop的机制与 浏览器保持一致了，还是按照浏览器去理解吧。历史遗留问题。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1570613129,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":20172,"ip_address":""},"score":26666,"extra":""}]}]},{"had_liked":false,"id":134565,"user_name":"Luke","can_delete":false,"product_type":"c1","uid":1003156,"ip_address":"","ucode":"4060B4E2EF1D13","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/94/0b22b6a2.jpg","comment_is_top":false,"comment_ctime":1568867533,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"147597755597","product_id":100033601,"comment_content":"generator 函数是如何暂停执行程序的？<br>答案是通过协程来控制程序执行。<br>generator 函数是一个生成器，执行它会返回一个迭代器，这个迭代器同时也是一个协程。一个线程中可以有多个协程，但是同时只能有一个协程在执行。线程的执行是在内核态，是由操作系统来控制；协程的执行是在用户态，是完全由程序来进行控制，通过调用生成器的next()方法可以让该协程执行，通过yield关键字可以让该协程暂停，交出主线程控制权，通过return 关键字可以让该协程结束。协程切换是在用户态执行，而线程切换时需要从用户态切换到内核态，在内核态进行调度，协程相对于线程来说更加轻量、高效。<br>async function实现原理？ <br>async function 是通过 promise + generator 来实现的。generator 是通过协程来控制程序调度的。<br>​在协程中执行异步任务时，先用promise封装该异步任务，如果异步任务完成，会将其结果放入微任务队列中，然后通过yield 让出主线程执行权，继续执行主线程js，主线程js执行完毕后，会去扫描微任务队列，如果有任务则取出任务进行执行，这时通过调用迭代器的next(result)方法，并传入任务执行结果result，将主线程执行权转交给该协程继续执行，并且将result赋值给yield 表达式左边的变量，从而以同步的方式实现了异步编程。<br>所以说到底async function 还是通过协程+微任务+浏览器事件循环机制来实现的。","like_count":34,"discussions":[{"author":{"id":1555880,"avatar":"https://static001.geekbang.org/account/avatar/00/17/bd/a8/e90de356.jpg","nickname":"小肥羊","note":"","ucode":"45680BE3E5B0E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413018,"discussion_content":"https://devwebapps.yjbtest.com/yjbwxkh/openstock/web/index.html?app_id=web","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636361320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218085,"user_name":"EmilyLucky","can_delete":false,"product_type":"c1","uid":1972343,"ip_address":"","ucode":"DBA5FE296CF473","user_header":"https://static001.geekbang.org/account/avatar/00/1e/18/77/d665f258.jpg","comment_is_top":false,"comment_ctime":1589711057,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"113258860753","product_id":100033601,"comment_content":"1.首先执行console.log(&#39;script start&#39;);打印出script start<br>2.接着遇到定时器，创建一个新任务，放在延迟队列中<br>3.紧接着执行bar函数，由于bar函数被async标记的，所以进入该函数时，JS引擎会保存当前调用栈等信息，然后执行bar函数中的console.log(&#39;bar start&#39;);语句，打印bar start。<br>4.接下来执行到bar函数中的await foo();语句，执行foo函数，也由于foo函数被async标记的，所以进入该函数时，JS引擎会保存当前调用栈等信息，然后执行foo函数中的console.log(&#39;foo&#39;);语句，打印foo。<br>5.执行到await foo()时，会默认创建一个Promise对象<br>6.在创建Promise对象过程中，调用了resolve()函数，且JS引擎将该任务交给微任务队列<br>7.然后JS引擎会暂停当前协程的执行，将主线程的控制权交给父协程，同时将创建的Promise对象返回给父协程<br>8.主线程的控制权交给父协程后，父协程就调用该Promise对象的then()方法监控该Promise对象的状态改变<br>9.接下来继续父协程的流程，执行new Promise()，打印输出promise executor，其中调用了 resolve 函数，JS引擎将该任务添加到微任务队列队尾<br>10.继续执行父协程上的流程，执行console.log(&#39;script end&#39;);，打印出来script end<br>11.随后父协程将执行结束，在结束前，会进入微任务检查点，然后执行微任务队列，微任务队列中有两个微任务等待执行，先执行第一个微任务，触发第一个promise.then()中的回调函数，将主线程的控制权交给bar函数的协程，bar函数的协程激活后，继续执行后续语句，执行 console.log(&#39;bar end&#39;);，打印输出bar end<br>12.bar函数协程执行完成后，执行微任务队列中的第二个微任务，触发第二个promise.then()中的回调函数，该回调函数被激活后，执行console.log(&#39;promise then&#39;);，打印输出promise then<br>13.执行完之后，将控制权归还给主线程，当前任务执行完毕，取出延迟队列中的任务，执行console.log(&#39;setTimeout&#39;);，打印输出setTimeout。<br><br>故：最终输出顺序是：script start =&gt; bar start =&gt; foo =&gt; promise executor =&gt; script end =&gt; bar end =&gt; promise then =&gt; setTimeout<br>","like_count":26,"discussions":[{"author":{"id":2246757,"avatar":"https://static001.geekbang.org/account/avatar/00/22/48/65/3277386b.jpg","nickname":"刘至","note":"","ucode":"030D761BDF4957","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368196,"discussion_content":"说的很好，但是纠正一点，父子协程是在主线程上执行的，控制权是相对于父子协程的，父子协程对主线程的控制权可以相互转换，并没有“控制权归还给主线程”一说。另外，文中提到“如果从 A 协程启动 B 协程，我们就把 A 协程称为 B 协程的父协程”。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1618593450,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1925183,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N5zF2REeLrydaYZgJKq9Xjang0XKMKdgE4pBgKtdtYe1UDRLAVamzgd2WFkghoI9ZyalCoSOLslxsuZzCwbiaBg/132","nickname":"小猪猪","note":"","ucode":"ECA72490E8BB9B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352332,"discussion_content":"太牛了 这个回答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614687841,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1141142,"avatar":"https://static001.geekbang.org/account/avatar/00/11/69/96/470939dc.jpg","nickname":"Zaynah","note":"","ucode":"9A2EC8EC2C47B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281938,"discussion_content":"为什么在浏览器中是这样，node运行时倒数第二个跟倒数第三个打印顺序相反","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591844407,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2258397,"avatar":"https://static001.geekbang.org/account/avatar/00/22/75/dd/9affd4d5.jpg","nickname":"九千七","note":"","ucode":"1E385C88B3401A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1141142,"avatar":"https://static001.geekbang.org/account/avatar/00/11/69/96/470939dc.jpg","nickname":"Zaynah","note":"","ucode":"9A2EC8EC2C47B1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343964,"discussion_content":"node的事件循环机制和浏览器不一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611219328,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":281938,"ip_address":""},"score":343964,"extra":""},{"author":{"id":1390601,"avatar":"https://static001.geekbang.org/account/avatar/00/15/38/09/b4106772.jpg","nickname":"samam","note":"","ucode":"51A678CF1C6AA5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1141142,"avatar":"https://static001.geekbang.org/account/avatar/00/11/69/96/470939dc.jpg","nickname":"Zaynah","note":"","ucode":"9A2EC8EC2C47B1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":566000,"discussion_content":"现在版本顺序也一样了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650589228,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":281938,"ip_address":""},"score":566000,"extra":""}]}]},{"had_liked":false,"id":134551,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1568863502,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"40223569166","product_id":100033601,"comment_content":"感谢老师的分享，懂了，生成器+Promise+自动迭代器=async&#47;await。","like_count":9},{"had_liked":false,"id":137715,"user_name":"淡","can_delete":false,"product_type":"c1","uid":1456392,"ip_address":"","ucode":"6856CA319DE2F0","user_header":"https://static001.geekbang.org/account/avatar/00/16/39/08/09055b47.jpg","comment_is_top":false,"comment_ctime":1569828578,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"35929566946","product_id":100033601,"comment_content":"你好，这还有个小疑问：<br>就是foo函数被标记上async后，会隐式生成一个promise，然后在await foo（）处，await本身又会生成一个promise_，这两个promise是什么关系？","like_count":8,"discussions":[{"author":{"id":1807662,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/95/2e/f8575abb.jpg","nickname":"小蛋糕","note":"","ucode":"335A6F4301CF22","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":159358,"discussion_content":"隐式转换嘛，如果已经是 Promise 就不转了","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1580689007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1202089,"avatar":"https://static001.geekbang.org/account/avatar/00/12/57/a9/9abbe7a4.jpg","nickname":"神三元","note":"","ucode":"0FB2E7C0683599","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53869,"discussion_content":"没有关系","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1574226872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1343414,"avatar":"https://static001.geekbang.org/account/avatar/00/14/7f/b6/09efa8e5.jpg","nickname":"snow","note":"","ucode":"750FBF37CCFD86","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331687,"discussion_content":"不是2个，表面上，async相当于是new promise构造部分，await相当于. then部分。内部就是切换协程。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1606950237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2840430,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/57/6e/0010eec8.jpg","nickname":"月光林地","note":"","ucode":"827DFEBA385367","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532452,"discussion_content":"await不生成promise，await后面跟一个promise，前面的response会在父协程触发then之后被赋值，就是resolve的值。所以await后面的可以简单看做then。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1637598973,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1098566,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c3/46/308c3958.jpg","nickname":"不蒸馒头","note":"","ucode":"EB26EC2B9CFC6B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544936,"discussion_content":"没有关系，foo函数被标记上async后，会隐式生成一个Promise，这个Promise的返回值跟foo函数的return 值有关, 而await 后面的promise的值，可以通过函数内部定义的一个变量接收，这两个promise是没有任何关系的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641786551,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2258397,"avatar":"https://static001.geekbang.org/account/avatar/00/22/75/dd/9affd4d5.jpg","nickname":"九千七","note":"","ucode":"1E385C88B3401A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343963,"discussion_content":"没有任何关系","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611219236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207508,"user_name":"穿秋裤的男孩","can_delete":false,"product_type":"c1","uid":1748640,"ip_address":"","ucode":"D0F48C66377893","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ae/a0/707350ef.jpg","comment_is_top":false,"comment_ctime":1587095811,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"31651866883","product_id":100033601,"comment_content":"以前一直以为promise.then就是添加微任务，原来真的的微任务是promise.resolve&#47;reject。then函数只是resolve&#47;reject执行的副产品","like_count":7,"discussions":[{"author":{"id":2930028,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/b5/6c/18c5b2ed.jpg","nickname":"一七","note":"","ucode":"681C7720FAB84B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585157,"discussion_content":"结合知乎和掘金上大佬写的promise源码分析文章，我理解应该是这样的，在调用then方法的时候，如果此时promise的状态已经是fulfilled状态，那么就会把onfulfilled回调加到微任务队列，比如这样\nnew Promise(resolve =&gt; resolve(1)).then(res =&gt; console.log(res))\n如果还是pending状态，那么就会先把onfulfilled回调存起来，等之后resolve方法被调用，然后再把存起来的onfulfilled回调加入到微任务队列,比如这样\nnew Promise(resolve =&gt; setTimeout(() =&gt; resolve(1))).then(res =&gt; console.log(res))\n这样就能解释的通了\nhttps://zhuanlan.zhihu.com/p/264944183 源码分析文章在这，文章里有很详细的解释，关于then方法和resolve方法的内部实现","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1661349806,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2511095,"avatar":"https://static001.geekbang.org/account/avatar/00/26/50/f7/9ef24365.jpg","nickname":"for forever","note":"","ucode":"33BBBD2FB30B58","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368069,"discussion_content":"好像不是的。\nvar p1 = new Promise((res,rej)=>{\n  res(1);\n})\nvar p2 =new Promise((res,rej)=>{\n  res(2)\n})\np2.then(val=>{\n  console.log(val)\n})\np1.then(val=>{\n  console.log(val)\n})\n这样子是先打印2，再打印1，说明是then的时候才添加进微任务队列的吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1618556541,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2547859,"avatar":"https://static001.geekbang.org/account/avatar/00/26/e0/93/c512e343.jpg","nickname":"云销雨霁","note":"","ucode":"0F3F5867B9EC82","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2511095,"avatar":"https://static001.geekbang.org/account/avatar/00/26/50/f7/9ef24365.jpg","nickname":"for forever","note":"","ucode":"33BBBD2FB30B58","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389727,"discussion_content":"var p1 = new Promise((res,rej)=>{\n  res(1);\n})\nvar p2 =new Promise((res,rej)=>{\n  res(2)\n})\nconsole.log(p1, p2) // Promise {<fulfilled>: 1} Promise {<fulfilled>: 2}\n\np2.then(val=>{\n  console.log(val)\n})\np1.then(val=>{\n  console.log(val)\n})\n我觉是resolve的逻辑优化了吧，resolve 非异步触发，直接就返回promise并且状态置为fulfilled，所以谁先掉用then，谁先触发","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629393347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":368069,"ip_address":""},"score":389727,"extra":""},{"author":{"id":1376098,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ff/62/8c302aa5.jpg","nickname":"李扬","note":"","ucode":"9ABA00C143C34D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2511095,"avatar":"https://static001.geekbang.org/account/avatar/00/26/50/f7/9ef24365.jpg","nickname":"for forever","note":"","ucode":"33BBBD2FB30B58","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":401949,"discussion_content":"之前看了一些有关手写promise的文章，那些文章的实现也是说：调用then的时候会把回调函数再用一个函数包裹起来放入 resolveCbs里面，这个包裹函数的具体实现就是：创建一个微任务\n\n所以我也恨不明白，老师说的是resolve的时候 才会创建微任务","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633771599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":368069,"ip_address":""},"score":401949,"extra":""}]},{"author":{"id":2930028,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/b5/6c/18c5b2ed.jpg","nickname":"一七","note":"","ucode":"681C7720FAB84B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554730,"discussion_content":"微任务真正执行的还是then里面的事情","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646572397,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2930028,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/b5/6c/18c5b2ed.jpg","nickname":"一七","note":"","ucode":"681C7720FAB84B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554729,"discussion_content":"我理解应该是resolve去触发then的第一个回调，然后创建的微任务，你如果只有resolve没有then的话，创建微任务是没有任何意义的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646572355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1623117,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c4/4d/85014aab.jpg","nickname":"一叉树","note":"","ucode":"BFC984403ACD1F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305529,"discussion_content":"看了你的评论有种顿悟的感觉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599985302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1288733,"avatar":"https://static001.geekbang.org/account/avatar/00/13/aa/1d/b8fdd622.jpg","nickname":"laoergege","note":"","ucode":"559CCF36805A04","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":268522,"discussion_content":"哈哈，我也是一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589796367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":196897,"user_name":"墨灵","can_delete":false,"product_type":"c1","uid":1409700,"ip_address":"","ucode":"185D70CA20BEEE","user_header":"https://static001.geekbang.org/account/avatar/00/15/82/a4/a92c6eca.jpg","comment_is_top":false,"comment_ctime":1585321962,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27355125738","product_id":100033601,"comment_content":"直到现在才构建起一个比较完整的异步编程范式的体系，真是深入浅出。","like_count":6},{"had_liked":false,"id":273508,"user_name":"啊哈哈","can_delete":false,"product_type":"c1","uid":1243584,"ip_address":"","ucode":"A8542946C03707","user_header":"https://static001.geekbang.org/account/avatar/00/12/f9/c0/20b4a205.jpg","comment_is_top":false,"comment_ctime":1610617353,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18790486537","product_id":100033601,"comment_content":"那也就是说，await之后的行为，全部作为promise.then()的微任务加入进微任务队列中了。最后在本轮宏任务执行完成后才执行当前宏任务下的微任务队列。","like_count":4,"discussions":[{"author":{"id":2172330,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKw8ictgYcqf6upCGib0uBXa6oeWfVJARSLL1SFXtrz3TkJiavPicesLEoBg9RL7ibRYKTtZDexsrJPjJA/132","nickname":"victorykong","note":"","ucode":"76C1BE240D53F8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351841,"discussion_content":"是的，我也这么理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614491300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220562,"user_name":"张萌","can_delete":false,"product_type":"c1","uid":1377299,"ip_address":"","ucode":"89C08DB3239BE5","user_header":"https://static001.geekbang.org/account/avatar/00/15/04/13/84d35588.jpg","comment_is_top":false,"comment_ctime":1590288777,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10180223369","product_id":100033601,"comment_content":"最新的 node 14 已经支持顶层 await 了","like_count":2},{"had_liked":false,"id":333152,"user_name":"路漫漫","can_delete":false,"product_type":"c1","uid":1273044,"ip_address":"","ucode":"F70F1DC612DE9D","user_header":"https://static001.geekbang.org/account/avatar/00/13/6c/d4/85ef1463.jpg","comment_is_top":false,"comment_ctime":1644138241,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5939105537","product_id":100033601,"comment_content":"好文，看了许久和配合es6的文档才看明白的，收获极大","like_count":1},{"had_liked":false,"id":314896,"user_name":"A LETTER","can_delete":false,"product_type":"c1","uid":2752142,"ip_address":"","ucode":"56C82015945CDE","user_header":"https://static001.geekbang.org/account/avatar/00/29/fe/8e/895f05a2.jpg","comment_is_top":false,"comment_ctime":1633535714,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5928503010","product_id":100033601,"comment_content":"awiat会向父协程传递创建的promise_,并执行resolve(result)，该方法会被放入微任务队列中执行，之后在赋值前通过yield跳出该协程，转到父协程，然后父协程通过调用promise_.then方法来监听这个promise的变化，当父协程执行结束之前，到达检查点，去执行微任务队列时，执行到之前注册的resolve(result)时，会调用之前then注册的回调函数，在该回调函数中通过next(result)来进入子协程，并将result的值，赋值给await等式左边的变量，然后继续执行该子协程的代码，就相当于在之前的then中注册的回调函数里执行一样，实现了同步的方式来进行异步操作。","like_count":1},{"had_liked":false,"id":288970,"user_name":"王玄","can_delete":false,"product_type":"c1","uid":1394410,"ip_address":"","ucode":"E54ABB340D1E49","user_header":"https://static001.geekbang.org/account/avatar/00/15/46/ea/b86667b8.jpg","comment_is_top":false,"comment_ctime":1618803172,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5913770468","product_id":100033601,"comment_content":"老师 可以否按照mfist这种流程详细讲解一下练习题","like_count":1},{"had_liked":false,"id":286673,"user_name":"张宗伟","can_delete":false,"product_type":"c1","uid":1374181,"ip_address":"","ucode":"1447A20C7A8982","user_header":"https://static001.geekbang.org/account/avatar/00/14/f7/e5/ec543f3b.jpg","comment_is_top":false,"comment_ctime":1617471059,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5912438355","product_id":100033601,"comment_content":"具体步骤如下，并不严谨，欢迎指教：<br>1. 输出 “script start”。<br>2. 执行 setTimeout，将其加入到定时消息队列(宏任务)。<br>3. 执行 bar()，以协程的角度，创建一个 bar 协程，首先输出 “bar start”，执行到 await 后，调用 foo (创建一个foo协程)，输出 “ foo”，并新建一个Promise实例传递给父协程，父协程将其添加到当前宏任务的微任务队列(微任务队列元素+1)。<br>4. 执行新建 Promise 实例，输出 “promise executor”，执行 resolve() 添加到微任务队列中(微任务队列元素+1)。<br>5. 输出 “script end”。<br>6. 当前宏任务执行完毕，开始检查微任务队列，按照添加的先后顺序，首先输出 “bar end”，再次输出 “promise then”。<br>7. 消息队列中的任务在下一次事件循环中执行，输出 “ setTimeout”。","like_count":1},{"had_liked":false,"id":283817,"user_name":"🍃","can_delete":false,"product_type":"c1","uid":1337052,"ip_address":"","ucode":"D1E4560C49139A","user_header":"https://static001.geekbang.org/account/avatar/00/14/66/dc/fdffbc96.jpg","comment_is_top":false,"comment_ctime":1615946659,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"5910913955","product_id":100033601,"comment_content":"如果已经到了检查点，await后面的内容还没有resolve，会出现什么情况呢","like_count":1,"discussions":[{"author":{"id":2547859,"avatar":"https://static001.geekbang.org/account/avatar/00/26/e0/93/c512e343.jpg","nickname":"云销雨霁","note":"","ucode":"0F3F5867B9EC82","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389730,"discussion_content":"会卡住","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629394867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1500320,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e4/a0/62a8b07e.jpg","nickname":"阿东","note":"","ucode":"E9393F62B4091D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386892,"discussion_content":"我理解resolve触发时在才在当前微任务队列加入onResolve","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627881445,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1008474,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/5a/4ec96cfe.jpg","nickname":"林高鸿","note":"","ucode":"34AD2C0A7542AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1500320,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e4/a0/62a8b07e.jpg","nickname":"阿东","note":"","ucode":"E9393F62B4091D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386927,"discussion_content":"我理解也是这样，这里感觉大部分人（可能也包括老师）都弄错了，我理解的是：\n\n对我们（普通使用者）来说，用 Promise 是因为有宏任务问题（AJAX，SetTimeout）需要解决，而专注问题解决时是不需要考虑工具（Promise）自身实现原理（微任务）的\n\n简言之，对普通使用者来说，把 Promise 和微任务联系起来是本末倒置\n\n\nPS：其实，如果能保证用 Promise 解决的是异步问题（宏任务/微任务），那 Promise 自身实现原理也不需要微任务来“延迟绑定”（因为异步回来要 resolve 时，then 一定已经执行绑定...）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627895159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":386892,"ip_address":""},"score":386927,"extra":""},{"author":{"id":2653213,"avatar":"https://static001.geekbang.org/account/avatar/00/28/7c/1d/81902e6a.jpg","nickname":"..................东","note":"","ucode":"03E333B1FF226A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1008474,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/5a/4ec96cfe.jpg","nickname":"林高鸿","note":"","ucode":"34AD2C0A7542AB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":533614,"discussion_content":"你理解错了 宝贝","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637916696,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":386927,"ip_address":""},"score":533614,"extra":""}]},{"author":{"id":1200380,"avatar":"https://static001.geekbang.org/account/avatar/00/12/50/fc/eec5242d.jpg","nickname":"RoyChen","note":"","ucode":"FECBAAC7B7D8DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385715,"discussion_content":"你这个应该是一个真的异步操作了，比方setTimeout或者IO操作。这部分的操作就会放等异步事件返回之后，在下一个eventloop的时候在宏任务队列里面处理回调，在处理回调的时候才会触发resolve，并放到微任务队列里面。在微任务队列里面没有要处理的事件的时候，应该就会跳过进入后面的步骤了。所以我理解不会等待，而是继续后续的执行，直到resolve被调用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627223376,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1374181,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f7/e5/ec543f3b.jpg","nickname":"张宗伟","note":"","ucode":"1447A20C7A8982","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362393,"discussion_content":"我感觉会等待。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616936140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214942,"user_name":"LearnAndTry","can_delete":false,"product_type":"c1","uid":1512860,"ip_address":"","ucode":"0ECF4398C870DC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Rr8ABLicfgJHZ3xs3bXNjHdicwVN0zBiaFtIEXw4D1licedSuia3zicxJC4lqtrNwPmCeAW5UR2Ugia0dNfcvtXYnpOwQ/132","comment_is_top":false,"comment_ctime":1588853946,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5883821242","product_id":100033601,"comment_content":"有个问题没看懂，父协程和gen协程切换调用栈那块。是不是本质上还是gen协程执行上下文进出栈？？“切换”两个字让我感觉是有指针指向两个执行上下文","like_count":1,"discussions":[{"author":{"id":1854952,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/4d/e8/b94f7438.jpg","nickname":"CaptainJack","note":"","ucode":"2630B57EE4DFCC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301575,"discussion_content":"这一点我也是心存疑问，感觉generator运行原理还不是很清楚","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598579123,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186267,"user_name":"stone","can_delete":false,"product_type":"c1","uid":1112708,"ip_address":"","ucode":"3FA105FB89CF5F","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/84/b91ee3a9.jpg","comment_is_top":false,"comment_ctime":1583811629,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5878778925","product_id":100033601,"comment_content":"&#47;&#47; 老师, node本地执行 promise then先执行 <br>&#47;&#47; node本地执行  <br>&#47;&#47; 1 script start<br>&#47;&#47; 2 bar start<br>&#47;&#47; 3 foo<br>&#47;&#47; 4 promise executor<br>&#47;&#47; 5 script end<br>&#47;&#47; 6 promise then<br>&#47;&#47; 7 bar end<br>&#47;&#47; 8 setTimeout<br><br>&#47;&#47; 浏览器执行<br>&#47;&#47; 1 script start<br>&#47;&#47; 2 bar start<br>&#47;&#47; 3 foo<br>&#47;&#47; 4 promise executor<br>&#47;&#47; 5 script end<br>&#47;&#47; 6 bar end<br>&#47;&#47; 7 promise then<br>&#47;&#47; 8 setTimeout<br>","like_count":1,"discussions":[{"author":{"id":1445936,"avatar":"https://static001.geekbang.org/account/avatar/00/16/10/30/c07d419c.jpg","nickname":"卡尔","note":"","ucode":"BD6F76BC18FF8F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284301,"discussion_content":"我也是跟你一样\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592492410,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1389909,"avatar":"https://static001.geekbang.org/account/avatar/00/15/35/55/7c7c6acc.jpg","nickname":"nbsp","note":"","ucode":"DE76BEC9D0C81B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1445936,"avatar":"https://static001.geekbang.org/account/avatar/00/16/10/30/c07d419c.jpg","nickname":"卡尔","note":"","ucode":"BD6F76BC18FF8F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293882,"discussion_content":"卡尔大大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595697909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":284301,"ip_address":""},"score":293882,"extra":""}]},{"author":{"id":1027182,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ac/6e/2a272fce.jpg","nickname":"风语菡","note":"","ucode":"E96C91E47FEF77","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282970,"discussion_content":"我的node版本是12.16.1，执行的结果和你贴出的浏览器的结果一致，promise then 倒数第二个输出","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592131276,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135194,"user_name":"bobi","can_delete":false,"product_type":"c1","uid":1616931,"ip_address":"","ucode":"6796146DFB791D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/xRYuVOluJxeuRtmKPjwwkSibKeeHEia1fVyiaK14JQtdM3bLqHShGTSvF3yRY4Mp81gz2hLw6BZoY02AXSFHZiaBxg/132","comment_is_top":false,"comment_ctime":1569057975,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5864025271","product_id":100033601,"comment_content":"&#47;&#47;foo 函数<br>function* foo() {<br>    let response1 = yield fetch(&#39;https:&#47;&#47;www.geekbang.org&#39;)<br>    console.log(&#39;response1&#39;)<br>    console.log(response1) &#47;&#47; 这里为什么是undefined<br>    let response2 = yield fetch(&#39;https:&#47;&#47;www.geekbang.org&#47;test&#39;)<br>    console.log(&#39;response2&#39;)<br>    console.log(response2) &#47;&#47; 这里为什么是undefined<br>}<br>老师，在你举的生成器和Promise结合的例子中，为什么执行器里面取不到接口的值啊？<br>","like_count":1,"discussions":[{"author":{"id":1649415,"avatar":"","nickname":"黄钦钦","note":"","ucode":"E2E9CB1E084BB9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":23941,"discussion_content":"yield表达式的返回值，是由下一次调用next传递过来的。如果想拿到response的值，应该在promise then回调时，通过调用gen的next传递给协程内部","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1569942610,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1910075,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/25/3b/a971fc8e.jpg","nickname":"阿感","note":"","ucode":"7BCB7E44A832D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":262645,"discussion_content":"可以看看阮一峰老师的es6入门","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589119287,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134621,"user_name":"Geek_f74777","can_delete":false,"product_type":"c1","uid":1626734,"ip_address":"","ucode":"8B512972A145A7","user_header":"","comment_is_top":false,"comment_ctime":1568880947,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5863848243","product_id":100033601,"comment_content":"老师，课后习题中的第一个异步foo函数中会异步执行返回一个Promise对象，那么这个Promise对象在创建返回的过程中，是否会往微任务队列中添加微任务？既然foo()执行返回的结果已经是一个Promise了，那么V8引擎还会将await后的foo()<br>返回的Promise再进行一次Promise封装吗？","like_count":1},{"had_liked":false,"id":360156,"user_name":"Geek_2500a0","can_delete":false,"product_type":"c1","uid":3022858,"ip_address":"广东","ucode":"2A5199816D9E56","user_header":"","comment_is_top":false,"comment_ctime":1666239093,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1666239093","product_id":100033601,"comment_content":"输出结果如下：<br>script start<br>bar start<br>foo<br>promise executor<br>script end<br>bar end<br>promise then<br>setTimeout<br><br>分析如下：<br>1、首先执行 console.log(&#39;script start&#39;)，输出 script start。<br>2、执行 setTimeout，产生一个宏任务，放到消息队列里。<br>3、再执行 bar() ，产生一个协程bar，并输出 bar start。<br>4、然后执行 await foo() ，此时输出 foo，并隐式执行 resolve(undefined)，产生第一个微任务，并暂停协程bar。<br>5、返回父协程继续执行，输出 promise executor， 并产生第二个微任务。<br>6、最后再执行 console.log(&#39;script end&#39;)， 输出 script end。此时该宏任务执行完毕，到了检查点，开始执行微任务队列的内容。<br>7、第一个微任务执行，返回 undefined，然后输出 bar end。<br>8、第二个微任务执行， 输出 promise then。<br>9、最后当前宏任务下的微任务都执行完成，开始下一个宏任务（setTimeout）执行，输出 setTimeout。","like_count":0},{"had_liked":false,"id":359763,"user_name":"开开之之","can_delete":false,"product_type":"c1","uid":1152069,"ip_address":"广东","ucode":"2B7FC13D6F32C4","user_header":"https://static001.geekbang.org/account/avatar/00/11/94/45/7ea3dd47.jpg","comment_is_top":false,"comment_ctime":1665846238,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665846238","product_id":100033601,"comment_content":"首先执行console.log(&#39;script start&#39;)<br>然后执行setTimeout，由于setTimeout是宏任务，因此会把它的回调函数放入消息队列中。<br>执行bar(): 启动bar协程，这个时候会执行 console.log(&#39;bar start&#39;)。<br>然后执行await foo()，这个时候会执行console.log(&#39;foo&#39;), 并且创建一个promise对象, 把resolve放入微任务队列中。<br>new Promise((resolve, reject()) =&gt; {<br>    resolve()<br>})<br>&#47;&#47; 在主协程中创建一个promise.then函数，用于把协程控制权返回给bar协程<br>promise._then(() =&gt; {<br>   &#47;&#47; 启动foo协程<br>})<br>执行new Promise，执行 console.log(&#39;promise executor&#39;)，并把resolve()放入微任务队列中<br>执行console.log(&#39;script end&#39;)<br>这个时候主函数执行完毕，开始执行微任务，由于先进先出，会先执行bar协程创建的promise对象的resolve任务，因此下一步是触发bar协程，继续执行完 console.log(&#39;bar end&#39;)。<br>继续执行微任务队列，执行下一个promise的resolve函数，并触发执行其then函数<br>console.log(&#39;promise then&#39;)<br>微任务执行完毕，继续执行下一个宏任务 console.log(&#39;setTimeout&#39;)","like_count":0},{"had_liked":false,"id":357307,"user_name":"罗武钢","can_delete":false,"product_type":"c1","uid":2843394,"ip_address":"广东","ucode":"E739A170C1D341","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLzSRrK59sydknSSYZdeTww3Cgib9Gy9N4BJGgSXMYdmVIxJYwDXPsLCIE68AbwTkgUct8J4iboAqicA/132","comment_is_top":false,"comment_ctime":1663146799,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663146799","product_id":100033601,"comment_content":"感谢老师的分享，懂了，生成器+Promise+自动迭代器=async&#47;await。","like_count":0},{"had_liked":false,"id":341559,"user_name":"七月拾思","can_delete":false,"product_type":"c1","uid":1466882,"ip_address":"","ucode":"7E405CBB9820F1","user_header":"https://static001.geekbang.org/account/avatar/00/16/62/02/fd00a1de.jpg","comment_is_top":false,"comment_ctime":1649689595,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649689595","product_id":100033601,"comment_content":"async function foo() {<br>    console.log(1)<br>    let a = await 100<br>    console.log(a)<br>    console.log(2)<br>    return &#39;hello&#39;<br>}<br>console.log(0)<br>let res = await foo()<br>console.log(3)<br>console.log(res);<br><br>如果在 foo() 前面加上 await，这样只有当 foo 函数执行完有返回值了，才继续往下面执行<br><br>输出： <br><br>0<br>1<br>100<br>2<br>3<br>hello","like_count":0},{"had_liked":false,"id":335111,"user_name":"Geek_aa1c31","can_delete":false,"product_type":"c1","uid":2913864,"ip_address":"","ucode":"1AC14C053638AF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/MYShyjtRtib2GIQiaK4hV3ZP9pQ1qiaS74DA4K4YHY4SIiaFDfsCKgiaMWwm9zFsSn3bt5pawp5Kdn5MWgiaw5909nug/132","comment_is_top":false,"comment_ctime":1645340647,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1645340647","product_id":100033601,"comment_content":"<br>async function foo() {<br>    console.log(1)<br>    let a = await 100<br>    console.log(a)<br>    console.log(2)<br>}<br>console.log(0)<br>foo()<br>console.log(3)<br>相当于:<br>function* foo() {<br>  console.log(1);<br>  const a = yield new Promise(resolve =&gt; {<br>    resolve(100);<br>  });<br>  console.log(a);<br>  console.log(2);<br>}<br>console.log(0);<br>const gen = foo();<br>gen.next().value.then(v =&gt; {<br>  gen.next(v);<br>});<br>console.log(3);<br><br>=================================<br><br>async function foo() {<br>    console.log(&#39;foo&#39;)<br>}<br>async function bar() {<br>    console.log(&#39;bar start&#39;)<br>    await foo()<br>    console.log(&#39;bar end&#39;)<br>}<br>console.log(&#39;script start&#39;)<br>setTimeout(function () {<br>    console.log(&#39;setTimeout&#39;)<br>}, 0)<br>bar();<br>new Promise(function (resolve) {<br>    console.log(&#39;promise executor&#39;)<br>    resolve();<br>}).then(function () {<br>    console.log(&#39;promise then&#39;)<br>})<br>console.log(&#39;script end&#39;)<br>相当于:<br>function* foo() {<br>  console.log(&#39;foo&#39;);<br>}<br><br>function* bar() {<br>  console.log(&#39;bar start&#39;);<br>  yield new Promise(resolve =&gt; {<br>    resolve(foo().next());<br>  });<br>  console.log(&#39;bar end&#39;);<br>}<br>console.log(&#39;script start&#39;);<br><br>setTimeout(() =&gt; {<br>  console.log(&#39;setTimeout&#39;);<br>}, 0);<br><br>const genBar = bar();<br>genBar.next().value.then(v =&gt; {<br>  genBar.next(v);<br>});<br><br>new Promise(resolve =&gt; {<br>  console.log(&#39;promise executor&#39;);<br>  resolve();<br>}).then(() =&gt; {<br>  console.log(&#39;promise then&#39;);<br>});<br>console.log(&#39;script end&#39;);","like_count":0},{"had_liked":false,"id":314252,"user_name":"bequiet","can_delete":false,"product_type":"c1","uid":1256533,"ip_address":"","ucode":"6B3A1AA02D17A6","user_header":"https://static001.geekbang.org/account/avatar/00/13/2c/55/f4c908ef.jpg","comment_is_top":false,"comment_ctime":1632914856,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1632914856","product_id":100033601,"comment_content":"请问老师 await foo() 的 then 函数作为主协程的微任务执行后，把控制权交给 async bar 协程，该协程执行结束后是如何切回到主协程下一个微任务的？默认顺序执行吗。谢谢！","like_count":0},{"had_liked":false,"id":303126,"user_name":"_Undefined","can_delete":false,"product_type":"c1","uid":1347163,"ip_address":"","ucode":"A992C46C48DFEF","user_header":"https://static001.geekbang.org/account/avatar/00/14/8e/5b/ae6f3e33.jpg","comment_is_top":false,"comment_ctime":1626601624,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1626601624","product_id":100033601,"comment_content":"async function foo() {<br>    &#47;&#47; 6-执行<br>    console.log(&#39;foo&#39;)<br>}<br>async function bar() {<br>    &#47;&#47; 4-执行<br>    console.log(&#39;bar start&#39;)<br>    &#47;**<br>     * 5-执行foo函数并生成第一个Promise微任务，相当于<br>     * new Promise((resolved) =&gt; {<br>     *     resolved(foo())<br>     *     &#47;&#47;将主线程控制权交给父协程<br>     * }).then(<br>     *     &#47;&#47; 9-执行微任务<br>     *     (value)=&gt;{<br>     *         &#47;&#47;将主线程控制权交给foo协程，并将vaule值传给协程<br>     *     }<br>     * )<br>     *&#47;<br>    await foo()<br>    &#47;&#47; 10-协程继续，执行代码<br>    console.log(&#39;bar end&#39;)<br>}<br>&#47;&#47; 1-执行<br>console.log(&#39;script start&#39;)<br>setTimeout(<br>    &#47;&#47; 2-进入延时队列尾<br>    &#47;&#47; 13-执行延时队列任务（宏任务）<br>    function () {<br>        console.log(&#39;setTimeout&#39;)<br>    }<br>    , 0<br>)<br>&#47;&#47; 3-执行<br>bar();<br>&#47;&#47; 7-执行<br>new Promise(function (resolve) {<br>    console.log(&#39;promise executor&#39;)<br>    resolve();<br>    &#47;&#47; 8-生成第二个微任务<br>}).then(<br>    &#47;&#47; 11-执行微任务<br>    function () {<br>        console.log(&#39;promise then&#39;)<br>    }<br>)<br>&#47;&#47; 9-执行<br>console.log(&#39;script end&#39;)","like_count":0},{"had_liked":false,"id":300403,"user_name":"Geek_8d85b5","can_delete":false,"product_type":"c1","uid":2591531,"ip_address":"","ucode":"03D42BA8CF5FDC","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKOzicrAGqUJW40icXNgaIytqKVbxkDGaRbMa3ly86FicvDx7tibhfobPict2vL3icgwyfkIJDqXicQz3mew/132","comment_is_top":false,"comment_ctime":1625141289,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1625141289","product_id":100033601,"comment_content":"有个疑问，为什么async&#47;await 的异步错误可以被捕获，而promise中的必须链式捕获，async中的异步流程不也是在任务队列中嘛 ，求大神解答","like_count":0,"discussions":[{"author":{"id":2547859,"avatar":"https://static001.geekbang.org/account/avatar/00/26/e0/93/c512e343.jpg","nickname":"云销雨霁","note":"","ucode":"0F3F5867B9EC82","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389729,"discussion_content":"try {\n  Promise.reject(111) // try 无法捕获 \n} catch (error) {\n  console.log(error, 333)\n}\ntry {\n  await Promise.reject(111)  // await 会将异步的错误的返回值获取，并且抛出,后面的语句无法执行\n  console.log(222)\n} catch (error) {\n  console.log(error, 333)\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629394793,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300320,"user_name":"黄浩","can_delete":false,"product_type":"c1","uid":1553647,"ip_address":"","ucode":"4A849AB4BD9783","user_header":"https://static001.geekbang.org/account/avatar/00/17/b4/ef/8d8a30b6.jpg","comment_is_top":false,"comment_ctime":1625113834,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625113834","product_id":100033601,"comment_content":"NB","like_count":0},{"had_liked":false,"id":283525,"user_name":"XinYi💛","can_delete":false,"product_type":"c1","uid":2174116,"ip_address":"","ucode":"4AC0E31A62C25C","user_header":"https://static001.geekbang.org/account/avatar/00/21/2c/a4/b681fa30.jpg","comment_is_top":false,"comment_ctime":1615807345,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1615807345","product_id":100033601,"comment_content":"老师这里await 返回的promise有return的时候为什么比后面执行的微任务还晚执行呢？？？？<br><br>async function async1() {<br>  console.log(&#39;async1 start&#39;) &#47;&#47; 2<br>  await async2()<br>  console.log(&#39;async1 end&#39;) &#47;&#47; 6----8 &#47;&#47; 这里注意！！ <br>  &#47;&#47; async2 中是 return 的 promise 导致这个的输出比下面的 promise2 promise3 都晚<br>}<br><br>async function async2() {<br>  console.log(&#39;async2 start&#39;) &#47;&#47;3<br>  &#47;&#47; 注意这里是return的，会影响到上面async1里面await后的执行顺序；若去掉return 关键字，则&#39;async1 end&#39;还是会早于 promise2 promise3 的输出<br>  return new Promise((resolve, reject) =&gt; { <br>    resolve()<br>    console.log(&#39;async2 end&#39;) &#47;&#47; 4 &#47;&#47; 这里也答错了，resolve后面也是可以执行的！！<br>  })<br>}<br><br>console.log(&#39;script start&#39;) &#47;&#47; 1<br>setTimeout(()=&gt;{<br>  console.log(&#39;setTimeout&#39;);  &#47;&#47; 9<br>}, 0)<br><br>async1();<br><br>new Promise(function(resolve) {<br><br>  console.log(&#39;promise1&#39;); &#47;&#47;5<br><br>  resolve();<br><br>}).then(function() {<br><br>  console.log(&#39;promise2&#39;); &#47;&#47; 7-----6 &#47;&#47; 注意，就算这里没有返回，后面的 then 也是可以执行的！！<br><br>}).then(function() {<br><br>  console.log(&#39;promise3&#39;); &#47;&#47;8-----7<br><br>});<br><br>console.log(&#39;script end&#39;); &#47;&#47;6<br>","like_count":0,"discussions":[{"author":{"id":2547859,"avatar":"https://static001.geekbang.org/account/avatar/00/26/e0/93/c512e343.jpg","nickname":"云销雨霁","note":"","ucode":"0F3F5867B9EC82","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389782,"discussion_content":"async2() return promise 我猜测 处理是有两个微任务，微任务队列里 ，有 微任务async1， promise，然后执行 async1，async1 里又有个微任务 async2，推入到队列中， 当前微任务队列就有  promise   ，async2， 我没办法证明，去看看源码先","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629429372,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":283425,"user_name":"小M","can_delete":false,"product_type":"c1","uid":1334823,"ip_address":"","ucode":"4210C9B7F18AF7","user_header":"https://static001.geekbang.org/account/avatar/00/14/5e/27/a871073d.jpg","comment_is_top":false,"comment_ctime":1615778377,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615778377","product_id":100033601,"comment_content":"好文","like_count":0},{"had_liked":false,"id":273967,"user_name":"o.O君程","can_delete":false,"product_type":"c1","uid":1002575,"ip_address":"","ucode":"8AE7F23875068F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4c/4f/858a8a70.jpg","comment_is_top":false,"comment_ctime":1610768925,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1610768925","product_id":100033601,"comment_content":"老师，请问一下，协程能通过performance去查看吗？这道题目的图还是有点难画，老师能给个答案吗？","like_count":0},{"had_liked":false,"id":273510,"user_name":"啊哈哈","can_delete":false,"product_type":"c1","uid":1243584,"ip_address":"","ucode":"A8542946C03707","user_header":"https://static001.geekbang.org/account/avatar/00/12/f9/c0/20b4a205.jpg","comment_is_top":false,"comment_ctime":1610617612,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610617612","product_id":100033601,"comment_content":"async function foo() { console.log(1) let a = await 100 console.log(a) console.log(2)}console.log(0)foo()console.log(3)<br><br>a的输出依赖于内部创建的promise的then，当时2为啥依赖呢？","like_count":0},{"had_liked":false,"id":271570,"user_name":"A.     成事在天","can_delete":false,"product_type":"c1","uid":2056450,"ip_address":"","ucode":"0B069A8EAD0E9B","user_header":"https://static001.geekbang.org/account/avatar/00/1f/61/02/6ccf315c.jpg","comment_is_top":false,"comment_ctime":1609719689,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609719689","product_id":100033601,"comment_content":"想问下老师，在nodejs中打印async函数等待的是promise是怎么解释呢，还有生成器函数是携程实现的有官方说明地址吗，疑问挺多的烦请老师解答","like_count":0},{"had_liked":false,"id":271300,"user_name":"keyboard3","can_delete":false,"product_type":"c1","uid":1147511,"ip_address":"","ucode":"E0C7BF44A28822","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/77/2c46f57a.jpg","comment_is_top":false,"comment_ctime":1609518262,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1609518262","product_id":100033601,"comment_content":"我的理解 async 封装了用promise的微任务来调度子协程中同步代码里异步任务完成的进度。await主要是yield关键字的作用","like_count":0},{"had_liked":false,"id":270101,"user_name":"🍁","can_delete":false,"product_type":"c1","uid":1533237,"ip_address":"","ucode":"C3DBE6AEACA9F7","user_header":"https://static001.geekbang.org/account/avatar/00/17/65/35/92b0f8ef.jpg","comment_is_top":false,"comment_ctime":1608905203,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608905203","product_id":100033601,"comment_content":"1、script start<br>2、bar start<br>3、foo<br>4、promise executor<br>5、script end<br>6、bar end<br>7、promise then<br>8、setTimeout","like_count":0},{"had_liked":false,"id":264424,"user_name":"Salman","can_delete":false,"product_type":"c1","uid":2276850,"ip_address":"","ucode":"A9CAE0E254F87F","user_header":"https://static001.geekbang.org/account/avatar/00/22/bd/f2/f21085cd.jpg","comment_is_top":false,"comment_ctime":1606461888,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1606461888","product_id":100033601,"comment_content":"问题：A协程启动B协程，则A是B父协程；那么A协程（也就是第一个协程）是怎么来的？难道主线程中默认维护了一个协程吗？","like_count":0,"discussions":[{"author":{"id":1386084,"avatar":"https://static001.geekbang.org/account/avatar/00/15/26/64/b58779db.jpg","nickname":"哈","note":"","ucode":"911AF435797571","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382805,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625728570,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261978,"user_name":"劳码识途","can_delete":false,"product_type":"c1","uid":1598564,"ip_address":"","ucode":"7AEF4D9407F097","user_header":"https://static001.geekbang.org/account/avatar/00/18/64/64/865c1eb4.jpg","comment_is_top":false,"comment_ctime":1605596067,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605596067","product_id":100033601,"comment_content":"老师讲的太好了！！！","like_count":0},{"had_liked":false,"id":255089,"user_name":"zgy","can_delete":false,"product_type":"c1","uid":1387798,"ip_address":"","ucode":"05EA6845199250","user_header":"https://static001.geekbang.org/account/avatar/00/15/2d/16/b525a71d.jpg","comment_is_top":false,"comment_ctime":1603264995,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603264995","product_id":100033601,"comment_content":"首先是上下文：<br>script start<br>bar start<br>promise executor<br>script end<br>foo协程<br>foo<br>bar end<br>微任务<br>promise then<br>延时任务<br>setTimeout","like_count":0},{"had_liked":false,"id":245474,"user_name":"悠米","can_delete":false,"product_type":"c1","uid":1377073,"ip_address":"","ucode":"7669A317A34FA9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/mX9k3VNGc2mZkfTmI9zia209EugGkpFyLXl8ia1HcnhJCrAsoJ2UliaHQaeDjKOkoCaQOia6iaoj1Dkv3gZqsONlaMg/132","comment_is_top":false,"comment_ctime":1598953002,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598953002","product_id":100033601,"comment_content":"2、await 这部分<br>如果 await 之后是个函数，如下代码，await 执行流程中默认创建的Promise 对象的 executor 函数长什么样？<br>function bar() {<br>  console.log(&#39;test&#39;);<br>}<br>async function foo() {<br>  console.log(1);<br>  const a = await bar();<br>  console.log(a);<br>  console.log(2);<br>}<br>console.log(0);<br>foo();<br>console.log(3);","like_count":0},{"had_liked":false,"id":244378,"user_name":"Sinvi","can_delete":false,"product_type":"c1","uid":1064018,"ip_address":"","ucode":"2A90976980CA3C","user_header":"https://static001.geekbang.org/account/avatar/00/10/3c/52/5951ffb4.jpg","comment_is_top":false,"comment_ctime":1598497926,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598497926","product_id":100033601,"comment_content":"醍醐灌顶","like_count":0},{"had_liked":false,"id":229415,"user_name":"逆舟","can_delete":false,"product_type":"c1","uid":1270780,"ip_address":"","ucode":"B303B4B8E10E0C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er8AdNibZHbZriaqLQZrNPcX8hVOpY91o0ELl7eOq7qy3aTibjia10ymIsKUKW6Ucs9SuXBDWlg6sjahw/132","comment_is_top":false,"comment_ctime":1592988781,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592988781","product_id":100033601,"comment_content":"&quot;然后 JavaScript 引擎会暂停当前协程的执行，将主线程的控制权转交给父协程执行，同时会将 promise_ 对象返回给父协程。<br>接下来继续执行父协程的流程，这里我们执行console.log(3)，并打印出来 3。随后父协程将执行结束，在结束之前，会进入微任务的检查点，然后执行微任务队列，微任务队列中有resolve(100)的任务等待执行，执行到这里的时候，会触发 promise_.then 中的回调函数，如下所示：&quot;<br>老师，await 产生的 promise_ 不会返回给父协程，显式或者隐式return的才会吧。  <br>await产生的promise_ 最后resolve时也不会经过父协程的 then，而是直接resolve返回 async协程，赋值给await前面的变量。<br>具体可以看这段代码：<br>async function foo() {<br>    console.log(1)<br>    let a = await 100<br>    console.log(a)<br>    console.log(2);<br>    return 200;<br>}<br>console.log(0)<br>var p = foo();<br>console.log(p);<br>p.then(v=&gt;{ console.log(v);return v+1;});<br>console.log(3)","like_count":0},{"had_liked":false,"id":224909,"user_name":"William Ning","can_delete":false,"product_type":"c1","uid":1592279,"ip_address":"","ucode":"4DB8D05E69E5F3","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","comment_is_top":false,"comment_ctime":1591589416,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1591589416","product_id":100033601,"comment_content":"答案对了, 但是理解方面还说不太清楚~~  thinking~~","like_count":0},{"had_liked":false,"id":223432,"user_name":"孜孜","can_delete":false,"product_type":"c1","uid":1018203,"ip_address":"","ucode":"7EF4FB644357CE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/89/5b/d8f78c1e.jpg","comment_is_top":false,"comment_ctime":1591088004,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1591088004","product_id":100033601,"comment_content":"为什么我感觉协程的调用就比普通函数多了保存堆栈信息呢？如果像个办法把堆栈信息传给普通函数，这样是不是协程就是普通的函数调用了呢？","like_count":0},{"had_liked":false,"id":219341,"user_name":"sh","can_delete":false,"product_type":"c1","uid":1428920,"ip_address":"","ucode":"720991D01D50D9","user_header":"https://static001.geekbang.org/account/avatar/00/15/cd/b8/14597b01.jpg","comment_is_top":false,"comment_ctime":1589992192,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589992192","product_id":100033601,"comment_content":"感谢 以前总是不明白为啥微任务没有另外启动一个线程 而在当前线程就做了异步<br>原来是是协程 协程使得一个线程也能执行多任务 只是不能并行 同一时间还是只能执行一个任务而已","like_count":0},{"had_liked":false,"id":208810,"user_name":"l_j_dota_1111","can_delete":false,"product_type":"c1","uid":1490128,"ip_address":"","ucode":"4CA8A41F5107C7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJwHLLQK3AicN8XqichEbfqSACpRB5kry8bIMBcuB3bSiaeic9hABrmn7TZgqaWJ8Xc1gWh6icasZCt3Fg/132","comment_is_top":false,"comment_ctime":1587441319,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587441319","product_id":100033601,"comment_content":"所以async await 底层不是基于generator，而是基于promise","like_count":0},{"had_liked":false,"id":208807,"user_name":"l_j_dota_1111","can_delete":false,"product_type":"c1","uid":1490128,"ip_address":"","ucode":"4CA8A41F5107C7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJwHLLQK3AicN8XqichEbfqSACpRB5kry8bIMBcuB3bSiaeic9hABrmn7TZgqaWJ8Xc1gWh6icasZCt3Fg/132","comment_is_top":false,"comment_ctime":1587441214,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1587441214","product_id":100033601,"comment_content":"async await 底层并没有用到generator的语法，而是基于Promise的？","like_count":0,"discussions":[{"author":{"id":1972343,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/18/77/d665f258.jpg","nickname":"EmilyLucky","note":"","ucode":"DBA5FE296CF473","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":267900,"discussion_content":"async/await 的基础技术使用了生成器和 Promise，生成器是协程的实现，利用生成器能实现生成器函数的暂停和恢复。async/await是generator的语法糖。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589707219,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200413,"user_name":"沧海一声笑","can_delete":false,"product_type":"c1","uid":1039904,"ip_address":"","ucode":"5297F2F4736B63","user_header":"https://static001.geekbang.org/account/avatar/00/0f/de/20/03130a39.jpg","comment_is_top":false,"comment_ctime":1585581115,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1585581115","product_id":100033601,"comment_content":"    async function b() {<br><br>        return Promise.resolve(&quot;b&quot;);<br>    }<br><br>    async function a() {<br>        console.log(&#39;a start&#39;);<br>        let _b = await b();<br>        console.log(_b);<br>        console.log(&#39;a end&#39;)<br>    }<br><br>    a();<br><br>    Promise.resolve(&quot;c&quot;).then(console.log);<br><br><br>按照理解 我们会认为输入顺序如下<br>1. a start<br>2. b<br>3. a end<br>4. c <br><br>但真实的结果是 <br><br>1. a start<br>2. c <br>3. b<br>4. a end<br><br>为什么会这样呢？  如果一个函数使用async 修饰了 （会隐式返回 Promise）. 但是如果我们显示返回了一个Promise 呢，这个过程中发生了什么呢。  查阅了不少资料，未能得起结果。 希望老师予以解惑 ，再次表示感谢。","like_count":0,"discussions":[{"author":{"id":1910075,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/25/3b/a971fc8e.jpg","nickname":"阿感","note":"","ucode":"7BCB7E44A832D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":264169,"discussion_content":"https://www.zhihu.com/question/268007969","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589292071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1234676,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d6/f4/bad64a45.jpg","nickname":"韭菜不加蛋。","note":"","ucode":"2CDEFDD180C69A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305738,"discussion_content":"这个是在微队列里面又套了一层微队列？return Promise.resolve(&#34;b&#34;); 这一行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600072633,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1910075,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/25/3b/a971fc8e.jpg","nickname":"阿感","note":"","ucode":"7BCB7E44A832D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":264144,"discussion_content":"https://juejin.im/post/5dc28ea66fb9a04a881d1ac0#heading-4\n这里看看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589291120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":191401,"user_name":"FreezeSoul","can_delete":false,"product_type":"c1","uid":1015930,"ip_address":"","ucode":"0B67142C4EA3D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/80/7a/02fdf1a2.jpg","comment_is_top":false,"comment_ctime":1584770607,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584770607","product_id":100033601,"comment_content":"这章内容非常棒","like_count":0},{"had_liked":false,"id":177324,"user_name":"tomision","can_delete":false,"product_type":"c1","uid":1821835,"ip_address":"","ucode":"92A251597DADB0","user_header":"https://static001.geekbang.org/account/avatar/00/1b/cc/8b/0060a75c.jpg","comment_is_top":false,"comment_ctime":1581347576,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581347576","product_id":100033601,"comment_content":"async function inner() {<br>  console.log(&#39;inner&#39;)<br>}<br><br>async function foo() {<br>  console.log(&#39;foo start&#39;)<br>  await inner()<br>  console.log(&#39;foo end&#39;)<br>}<br><br>async function bar() {<br>  console.log(&#39;bar start&#39;)<br>  await foo()<br>  console.log(&#39;bar end&#39;)<br>}<br><br>老师 如果 bar 函数的实现是这样的呢？协程可以再开协程么？","like_count":0},{"had_liked":false,"id":175031,"user_name":"4!!","can_delete":false,"product_type":"c1","uid":1487663,"ip_address":"","ucode":"188445590D97DF","user_header":"https://static001.geekbang.org/account/avatar/00/16/b3/2f/867b94d8.jpg","comment_is_top":false,"comment_ctime":1580532346,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1580532346","product_id":100033601,"comment_content":"父协程就是主线程吗？","like_count":0,"discussions":[{"author":{"id":1910075,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/25/3b/a971fc8e.jpg","nickname":"阿感","note":"","ucode":"7BCB7E44A832D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":264154,"discussion_content":"看文章里提的解释。不一定","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589291576,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1624537,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c9/d9/00870178.jpg","nickname":"Slowdive","note":"","ucode":"AF3429CE47C462","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":233328,"discussion_content":"不一定， 就像git分支，从哪里分哪个就是他父协程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586918227,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175009,"user_name":"NikkiZeng","can_delete":false,"product_type":"c1","uid":1765894,"ip_address":"","ucode":"F669C811773394","user_header":"https://static001.geekbang.org/account/avatar/00/1a/f2/06/ebb5b764.jpg","comment_is_top":false,"comment_ctime":1580526083,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1580526083","product_id":100033601,"comment_content":"老师,请问一下,在promise的执行器中,如果resolve&#47;reject函数被调用的时候,promise状态就会发生改变,随之,对应的then方法身上的回调也会选择其中一个被触发了,为什么是resolve还会被放到微任务中呢?","like_count":0,"discussions":[{"author":{"id":1196864,"avatar":"https://static001.geekbang.org/account/avatar/00/12/43/40/e7ef18de.jpg","nickname":"嘉一","note":"","ucode":"8D16BD0B75B019","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":264885,"discussion_content":"resolve/reject函数被调用的时候对应的then方法身上的回调并不会马上触发，而是此时会把then方法要执行这个任务放到微任务里面，等当前宏任务执行完了才会执行then方法","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589355909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167646,"user_name":"Objectivezt","can_delete":false,"product_type":"c1","uid":1396184,"ip_address":"","ucode":"D088F33E22B108","user_header":"https://static001.geekbang.org/account/avatar/00/15/4d/d8/30355c61.jpg","comment_is_top":false,"comment_ctime":1577886219,"is_pvip":false,"discussion_count":0,"race_medal":2,"score":"1577886219","product_id":100033601,"comment_content":"search 下 : “将主线程控制权交给foo协程，并将vaule值传给协程, ”   value有书写错误。","like_count":0},{"had_liked":false,"id":164718,"user_name":"Zzzrd","can_delete":false,"product_type":"c1","uid":1232242,"ip_address":"","ucode":"524593B1193AFE","user_header":"https://static001.geekbang.org/account/avatar/00/12/cd/72/b7083420.jpg","comment_is_top":false,"comment_ctime":1577082184,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1577082184","product_id":100033601,"comment_content":"const test2 = async () =&gt; {<br>        let a = await 100;<br>        console.log(a);<br>   }<br>   const pro = test2();<br>    console.log(pro);<br>    pro.then(res =&gt; {<br>        console.log(res);<br>    })<br><br>老师，这里的res为什么是undefined，不是100？","like_count":0,"discussions":[{"author":{"id":1379882,"avatar":"https://static001.geekbang.org/account/avatar/00/15/0e/2a/2156518c.jpg","nickname":"yulingogo","note":"","ucode":"23BC47AE89C986","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":104185,"discussion_content":"test2没返回值","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577415891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164717,"user_name":"Zzzrd","can_delete":false,"product_type":"c1","uid":1232242,"ip_address":"","ucode":"524593B1193AFE","user_header":"https://static001.geekbang.org/account/avatar/00/12/cd/72/b7083420.jpg","comment_is_top":false,"comment_ctime":1577082017,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577082017","product_id":100033601,"comment_content":"script start;<br>    bar start;<br>    promise executor<br>    script end<br>    bar end<br>    promise then<br>    setTimeout","like_count":0},{"had_liked":false,"id":154903,"user_name":"大海","can_delete":false,"product_type":"c1","uid":1001446,"ip_address":"","ucode":"20913D0265971B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/47/e6/67b0b711.jpg","comment_is_top":false,"comment_ctime":1574594451,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574594451","product_id":100033601,"comment_content":"yield &#39;generator 2&#39; 这段代码写错了，全部都是yield &#39;generator 2&#39;  应该是1-4","like_count":0},{"had_liked":false,"id":143199,"user_name":"歌顿","can_delete":false,"product_type":"c1","uid":1154982,"ip_address":"","ucode":"EA84E55C61F61A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIVA6yj0YzARUJV3uqD5Qu0OUNbypl5QvCEwx0rTXubaXlU9TPoorQaZT8SMMvXZMnHLjIpBvIsnA/132","comment_is_top":false,"comment_ctime":1571647326,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1571647326","product_id":100033601,"comment_content":"await 100 讲清楚了，但是 await async 函数没有讲清楚啊。<br>比如说 foo函数被标记上async后，会隐式生成一个promise，然后在await foo（）处，await本身又会生成一个promise_，这两个promise是什么关系？","like_count":0,"discussions":[{"author":{"id":1748290,"avatar":"","nickname":"vianem","note":"","ucode":"59A2D19426ABC4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":69189,"discussion_content":"async foo() {\n  ...\n}\nasync bar() {\n  const f = await foo()\n}\nconst f = await foo()时相当于\nPromise.resolve(foo()).then(fooVal => f = fooVal)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575269466,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136540,"user_name":"忘忧草的约定","can_delete":false,"product_type":"c1","uid":1114753,"ip_address":"","ucode":"F99D2F5D179B2A","user_header":"https://static001.geekbang.org/account/avatar/00/11/02/81/489e1cd4.jpg","comment_is_top":false,"comment_ctime":1569467299,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1569467299","product_id":100033601,"comment_content":"老师对于&#39;bar end&#39;和&#39;promise then&#39;的顺序我还是有点疑问，既然是microtask中恢复bar协程的的执行、不应该是先执行“bar end”吗","like_count":0,"discussions":[{"author":{"id":1910075,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/25/3b/a971fc8e.jpg","nickname":"阿感","note":"","ucode":"7BCB7E44A832D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":267236,"discussion_content":"async,await里面还有很多弯弯道道，会导致执行延迟。看看文章研究下\nhttps://www.zhihu.com/question/268007969\nhttps://juejin.im/post/5c3cc981f265da616a47e028#heading-16","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589618881,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136534,"user_name":"忘忧草的约定","can_delete":false,"product_type":"c1","uid":1114753,"ip_address":"","ucode":"F99D2F5D179B2A","user_header":"https://static001.geekbang.org/account/avatar/00/11/02/81/489e1cd4.jpg","comment_is_top":false,"comment_ctime":1569465996,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569465996","product_id":100033601,"comment_content":"<br>&#39;script start&#39;<br>&#39;bar start&#39;<br>&#39;foo&#39;<br>&#39;promise executor&#39;<br>&#39;script end&#39;<br>&#39;bar end&#39;<br>&#39;promise then&#39;<br>&#39;setTimeout&#39;","like_count":0},{"had_liked":false,"id":136304,"user_name":"蓝配鸡","can_delete":false,"product_type":"c1","uid":1348738,"ip_address":"","ucode":"C79A7CA8885B7C","user_header":"https://static001.geekbang.org/account/avatar/00/14/94/82/d0a417ba.jpg","comment_is_top":false,"comment_ctime":1569405611,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569405611","product_id":100033601,"comment_content":"Script then<br>Bar start<br>Foo<br>Promise executor<br>Script end<br>Promise then<br>Settimeout <br><br>老师相信我真的不是跑出来的😂<br><br>主要考查了promise，微任务， 宏任务， 还有使用async await时候协程时间的相互合作。 <br>","like_count":0},{"had_liked":false,"id":136010,"user_name":"小兵","can_delete":false,"product_type":"c1","uid":1261674,"ip_address":"","ucode":"AA3BA727C25179","user_header":"https://static001.geekbang.org/account/avatar/00/13/40/6a/ab1cf396.jpg","comment_is_top":false,"comment_ctime":1569327897,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569327897","product_id":100033601,"comment_content":"async function foo() {<br>    console.log(1)<br>    let a = await 100<br>    &#47;&#47; 从这里开始的内容是不是可以看作then绑定的回调函数的内容啊，看图又不像，不好理解。<br>    console.log(a)<br>    console.log(2)<br>}<br>console.log(0)<br>foo()<br>console.log(3)<br>","like_count":0},{"had_liked":false,"id":134987,"user_name":"Louis Hu","can_delete":false,"product_type":"c1","uid":1627255,"ip_address":"","ucode":"289E322B45B5EE","user_header":"https://static001.geekbang.org/account/avatar/00/18/d4/77/6d82909e.jpg","comment_is_top":false,"comment_ctime":1568969592,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1568969592","product_id":100033601,"comment_content":"老师您好：<br>想请问一下如果 await 是一个Promise的对象呢？<br>这时会发生什么？","like_count":0,"discussions":[{"author":{"id":1748290,"avatar":"","nickname":"vianem","note":"","ucode":"59A2D19426ABC4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":69195,"discussion_content":"等待Promise变成resolved或rejected，将resolved或rejected的值作为值返回给await左侧表达式","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575269746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134941,"user_name":"柒月","can_delete":false,"product_type":"c1","uid":1371240,"ip_address":"","ucode":"839A8F88C376A3","user_header":"https://static001.geekbang.org/account/avatar/00/14/ec/68/06d59613.jpg","comment_is_top":false,"comment_ctime":1568960095,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1568960095","product_id":100033601,"comment_content":"async function foo() {<br>    console.log(&#39;foo&#39;); &#47;&#47;3 foo<br>}<br>async function bar() {<br>    console.log(&#39;bar start&#39;);<br>    await foo()<br>    console.log(&#39;bar end&#39;); &#47;&#47;6 bar end<br>}<br>console.log(&#39;script start&#39;);&#47;&#47;1 script start<br>setTimeout(()=&gt;{<br>    console.log(&#39;setTimeout&#39;); 7&#47;&#47;setTimeout<br>},0)<br>bar();&#47;&#47;2 bar start<br>new Promise(function (resolve) {<br>    resolve();<br>}).then(function () {<br>    console.log(&#39;promise then&#39;); &#47;&#47;5 promise then<br>})<br>console.log(&#39;script end&#39;);&#47;&#47; 4 script end <br><br>浏览器和node环境是有点不一样呢？为啥呢？","like_count":0,"discussions":[{"author":{"id":1910075,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/25/3b/a971fc8e.jpg","nickname":"阿感","note":"","ucode":"7BCB7E44A832D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":267238,"discussion_content":"async,await里面还有很多弯弯道道，会导致执行延迟。看看文章研究下\nhttps://www.zhihu.com/question/268007969\nhttps://juejin.im/post/5c3cc981f265da616a47e028#heading-16\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589618966,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134592,"user_name":"李柏良","can_delete":false,"product_type":"c1","uid":1373744,"ip_address":"","ucode":"FF55E250E71018","user_header":"https://static001.geekbang.org/account/avatar/00/14/f6/30/ac25ef50.jpg","comment_is_top":false,"comment_ctime":1568875497,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1568875497","product_id":100033601,"comment_content":" 浏览器<br>script start -&gt; bar start -&gt; foo -&gt; promise executor -&gt; script end -&gt; bar end -&gt; promise then -&gt; setTimeout<br>在vscode bash 中 执行 node<br>script start -&gt; bar start -&gt; foo -&gt; promise executor -&gt; script end -&gt; promise then -&gt; bar end -&gt; setTimeout<br>bar end 和 promise then 的顺序不一样","like_count":0,"discussions":[{"author":{"id":1282777,"avatar":"https://static001.geekbang.org/account/avatar/00/13/92/d9/84c1de45.jpg","nickname":"傻子来了快跑丶","note":"","ucode":"662624121A1DFA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275613,"discussion_content":"有可能和node版本有关系","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590740178,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134568,"user_name":"Luke","can_delete":false,"product_type":"c1","uid":1003156,"ip_address":"","ucode":"4060B4E2EF1D13","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/94/0b22b6a2.jpg","comment_is_top":false,"comment_ctime":1568867713,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568867713","product_id":100033601,"comment_content":"之前一直都很困惑generator 的执行机制，今天终于明白了，原来是协程！感谢老师的分享！","like_count":0},{"had_liked":false,"id":134545,"user_name":"oc7","can_delete":false,"product_type":"c1","uid":1436976,"ip_address":"","ucode":"05067ED84F1493","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJibVeub5HnlS9HgLdrDSnQma6VINyAyf1bTOhKh4MGQkMydoCVs7ofbicePRomxjDM873A56fqx97w/132","comment_is_top":false,"comment_ctime":1568862414,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"1568862414","product_id":100033601,"comment_content":"node和浏览器环境下跑的结果不一致，这是为什么？","like_count":0,"discussions":[{"author":{"id":2591531,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKOzicrAGqUJW40icXNgaIytqKVbxkDGaRbMa3ly86FicvDx7tibhfobPict2vL3icgwyfkIJDqXicQz3mew/132","nickname":"Geek_8d85b5","note":"","ucode":"03D42BA8CF5FDC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381605,"discussion_content":"node11之后的事件循环机制才和浏览器的一致，之前的是先把全部宏任务执行完毕","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625141418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1910075,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/25/3b/a971fc8e.jpg","nickname":"阿感","note":"","ucode":"7BCB7E44A832D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":267240,"discussion_content":"标准和实践问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589619001,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1319638,"avatar":"https://static001.geekbang.org/account/avatar/00/14/22/d6/9378f4d5.jpg","nickname":"隔夜果酱","note":"","ucode":"5AFEB62E832BCB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":17451,"discussion_content":"node在11+以后的事件机制和浏览器一致了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568967844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015542,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7e/f6/abb7bfe3.jpg","nickname":"永远蔡","note":"","ucode":"ABE9FA50A3C28D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":17077,"discussion_content":"node 环境下的事件执行机制不一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568945693,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134541,"user_name":"Geek_Jamorx","can_delete":false,"product_type":"c1","uid":1608908,"ip_address":"","ucode":"5B5669D0C75FBD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ0F94uoYZQicRd7YEFjEJWm0EaUJXzkhiaqa5GQQ8a1FkicQIoHC4sp2ZG9m1JAFABuGsj34ucztjibA/132","comment_is_top":false,"comment_ctime":1568861649,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1568861649","product_id":100033601,"comment_content":"script start<br>bar start<br>promise executor<br>script end<br>foo<br>bar end<br>promise then<br>setTimeout","like_count":0,"discussions":[{"author":{"id":1608908,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ0F94uoYZQicRd7YEFjEJWm0EaUJXzkhiaqa5GQQ8a1FkicQIoHC4sp2ZG9m1JAFABuGsj34ucztjibA/132","nickname":"Geek_Jamorx","note":"","ucode":"5B5669D0C75FBD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":16143,"discussion_content":"错了，foo应该先调用，在promise executor之前。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568873267,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134524,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1568858347,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1568858347","product_id":100033601,"comment_content":"假设进程下有三个线程：A、B、C，其中A是主线程。 那么，文中用的“主线程”是指A吗？ B和C不是主线程，就不能有协程吗？","like_count":0,"discussions":[{"author":{"id":1003156,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4e/94/0b22b6a2.jpg","nickname":"Luke","note":"","ucode":"4060B4E2EF1D13","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":15951,"discussion_content":"协程不是线程，一个线程中可以有多个协程，协程切换是在用户态完成的，只用保存cpu当前执行上下文，占用的资源非常少，比线程更加轻量，要高效很多","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1568863684,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}