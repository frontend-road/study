{"id":177110,"title":"17 | 理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？","content":"<p>在上两节课中，我们学习了SOLID原则中的单一职责原则和开闭原则，这两个原则都比较重要，想要灵活应用也比较难，需要你在实践中多加练习、多加体会。今天，我们再来学习SOLID中的“L”对应的原则：里式替换原则。</p><p>整体上来讲，这个设计原则是比较简单、容易理解和掌握的。今天我主要通过几个反例，带你看看，哪些代码是违反里式替换原则的？我们该如何将它们改造成满足里式替换原则？除此之外，这条原则从定义上看起来，跟我们之前讲过的“多态”有点类似。所以，我今天也会讲一下，它跟多态的区别。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>如何理解“里式替换原则”？</h2><p>里式替换原则的英文翻译是：Liskov Substitution Principle，缩写为LSP。这个原则最早是在1986年由Barbara Liskov提出，他是这么描述这条原则的：</p><blockquote>\n<p>If S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program。</p>\n</blockquote><p>在1996年，Robert Martin在他的SOLID原则中，重新描述了这个原则，英文原话是这样的：</p><!-- [[[read_end]]] --><blockquote>\n<p>Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it。</p>\n</blockquote><p>我们综合两者的描述，将这条原则用中文描述出来，是这样的：子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。</p><p>这么说还是比较抽象，我们通过一个例子来解释一下。如下代码中，父类Transporter使用org.apache.http库中的HttpClient类来传输网络数据。子类SecurityTransporter继承父类Transporter，增加了额外的功能，支持传输appId和appToken安全认证信息。</p><pre><code>public class Transporter {\n  private HttpClient httpClient;\n  \n  public Transporter(HttpClient httpClient) {\n    this.httpClient = httpClient;\n  }\n\n  public Response sendRequest(Request request) {\n    // ...use httpClient to send request\n  }\n}\n\npublic class SecurityTransporter extends Transporter {\n  private String appId;\n  private String appToken;\n\n  public SecurityTransporter(HttpClient httpClient, String appId, String appToken) {\n    super(httpClient);\n    this.appId = appId;\n    this.appToken = appToken;\n  }\n\n  @Override\n  public Response sendRequest(Request request) {\n    if (StringUtils.isNotBlank(appId) &amp;&amp; StringUtils.isNotBlank(appToken)) {\n      request.addPayload(&quot;app-id&quot;, appId);\n      request.addPayload(&quot;app-token&quot;, appToken);\n    }\n    return super.sendRequest(request);\n  }\n}\n\npublic class Demo {    \n  public void demoFunction(Transporter transporter) {    \n    Reuqest request = new Request();\n    //...省略设置request中数据值的代码...\n    Response response = transporter.sendRequest(request);\n    //...省略其他逻辑...\n  }\n}\n\n// 里式替换原则\nDemo demo = new Demo();\ndemo.demofunction(new SecurityTransporter(/*省略参数*/););\n</code></pre><p>在上面的代码中，子类SecurityTransporter的设计完全符合里式替换原则，可以替换父类出现的任何位置，并且原来代码的逻辑行为不变且正确性也没有被破坏。</p><p>不过，你可能会有这样的疑问，刚刚的代码设计不就是简单利用了面向对象的多态特性吗？多态和里式替换原则说的是不是一回事呢？从刚刚的例子和定义描述来看，里式替换原则跟多态看起来确实有点类似，但实际上它们完全是两回事。为什么这么说呢？</p><p>我们还是通过刚才这个例子来解释一下。不过，我们需要对SecurityTransporter类中sendRequest()函数稍加改造一下。改造前，如果appId或者appToken没有设置，我们就不做校验；改造后，如果appId或者appToken没有设置，则直接抛出NoAuthorizationRuntimeException未授权异常。改造前后的代码对比如下所示：</p><pre><code>// 改造前：\npublic class SecurityTransporter extends Transporter {\n  //...省略其他代码..\n  @Override\n  public Response sendRequest(Request request) {\n    if (StringUtils.isNotBlank(appId) &amp;&amp; StringUtils.isNotBlank(appToken)) {\n      request.addPayload(&quot;app-id&quot;, appId);\n      request.addPayload(&quot;app-token&quot;, appToken);\n    }\n    return super.sendRequest(request);\n  }\n}\n\n// 改造后：\npublic class SecurityTransporter extends Transporter {\n  //...省略其他代码..\n  @Override\n  public Response sendRequest(Request request) {\n    if (StringUtils.isBlank(appId) || StringUtils.isBlank(appToken)) {\n      throw new NoAuthorizationRuntimeException(...);\n    }\n    request.addPayload(&quot;app-id&quot;, appId);\n    request.addPayload(&quot;app-token&quot;, appToken);\n    return super.sendRequest(request);\n  }\n}\n</code></pre><p>在改造之后的代码中，如果传递进demoFunction()函数的是父类Transporter对象，那demoFunction()函数并不会有异常抛出，但如果传递给demoFunction()函数的是子类SecurityTransporter对象，那demoFunction()有可能会有异常抛出。尽管代码中抛出的是运行时异常（Runtime Exception），我们可以不在代码中显式地捕获处理，但子类替换父类传递进demoFunction函数之后，整个程序的逻辑行为有了改变。</p><p>虽然改造之后的代码仍然可以通过Java的多态语法，动态地用子类SecurityTransporter来替换父类Transporter，也并不会导致程序编译或者运行报错。但是，从设计思路上来讲，SecurityTransporter的设计是不符合里式替换原则的。</p><p>好了，我们稍微总结一下。虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。</p><h2>哪些代码明显违背了LSP？</h2><p>实际上，里式替换原则还有另外一个更加能落地、更有指导意义的描述，那就是“Design By Contract”，中文翻译就是“按照协议来设计”。</p><p>看起来比较抽象，我来进一步解读一下。子类在设计的时候，要遵守父类的行为约定（或者叫协议）。父类定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。这里的行为约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。实际上，定义中父类和子类之间的关系，也可以替换成接口和实现类之间的关系。</p><p>为了更好地理解这句话，我举几个违反里式替换原则的例子来解释一下。</p><h3>1.子类违背父类声明要实现的功能</h3><p>父类中提供的sortOrdersByAmount()订单排序函数，是按照金额从小到大来给订单排序的，而子类重写这个sortOrdersByAmount()订单排序函数之后，是按照创建日期来给订单排序的。那子类的设计就违背里式替换原则。</p><h3>2.子类违背父类对输入、输出、异常的约定</h3><p>在父类中，某个函数约定：运行出错的时候返回null；获取数据为空的时候返回空集合（empty collection）。而子类重载函数之后，实现变了，运行出错返回异常（exception），获取不到数据返回null。那子类的设计就违背里式替换原则。</p><p>在父类中，某个函数约定，输入数据可以是任意整数，但子类实现的时候，只允许输入数据是正整数，负数就抛出，也就是说，子类对输入的数据的校验比父类更加严格，那子类的设计就违背了里式替换原则。</p><p>在父类中，某个函数约定，只会抛出ArgumentNullException异常，那子类的设计实现中只允许抛出ArgumentNullException异常，任何其他异常的抛出，都会导致子类违背里式替换原则。</p><h3>3.子类违背父类注释中所罗列的任何特殊说明</h3><p>父类中定义的withdraw()提现函数的注释是这么写的：“用户的提现金额不得超过账户余额……”，而子类重写withdraw()函数之后，针对VIP账号实现了透支提现的功能，也就是提现金额可以大于账户余额，那这个子类的设计也是不符合里式替换原则的。</p><p>以上便是三种典型的违背里式替换原则的情况。除此之外，判断子类的设计实现是否违背里式替换原则，还有一个小窍门，那就是拿父类的单元测试去验证子类的代码。如果某些单元测试运行失败，就有可能说明，子类的设计实现没有完全地遵守父类的约定，子类有可能违背了里式替换原则。</p><p>实际上，你有没有发现，里式替换这个原则是非常宽松的。一般情况下，我们写的代码都不怎么会违背它。所以，只要你能看懂我今天讲的这些，这个原则就不难掌握，也不难应用。</p><h2>重点回顾</h2><p>今天的内容到此就讲完了。我们来一块总结回顾一下，你需要掌握的重点内容。</p><p>里式替换原则是用来指导，继承关系中子类该如何设计的一个原则。理解里式替换原则，最核心的就是理解“design by contract，按照协议来设计”这几个字。父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数原有的“约定”。这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。</p><p>理解这个原则，我们还要弄明白里式替换原则跟多态的区别。虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。</p><h2>课堂讨论</h2><p>把复杂的东西讲简单，把简单的东西讲深刻，都是比较难的事情。而里式替换原则存在的意义可以说不言自喻，非常简单明确，但是越是这种不言自喻的道理，越是难组织成文字或语言来描述，有点儿只可意会不可言传的意思，所以，今天的课堂讨论的话题是：请你有条理、有深度地讲一讲里式替换原则存在的意义。</p><p>欢迎在留言区写下你的想法，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>","neighbors":{"left":{"article_title":"16 | 理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？","id":176075},"right":{"article_title":"18 | 理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？","id":177442}},"comments":[{"had_liked":false,"id":161349,"user_name":"年轻的我们","can_delete":false,"product_type":"c1","uid":1763079,"ip_address":"","ucode":"D7D7D6AE9F4CB7","user_header":"https://static001.geekbang.org/account/avatar/00/1a/e7/07/0e9d85c3.jpg","comment_is_top":false,"comment_ctime":1576196726,"is_pvip":false,"replies":[{"id":"61493","content":"理解的没错","user_name":"作者回复","comment_id":161349,"uid":"1190123","ip_address":"","utype":1,"ctime":1576198866,"user_name_real":"王争"}],"discussion_count":18,"race_medal":0,"score":"1148332464758","product_id":100039001,"comment_content":"个人理解里氏替换就是子类完美继承父类的设计初衷，并做了增强对吗","like_count":268,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477694,"discussion_content":"理解的没错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576198866,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1567940,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ec/c4/19f85ada.jpg","nickname":"乃鱼同学","note":"","ucode":"50A96C24978057","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380212,"discussion_content":"儿子的DNA必须是老子的，其他随意。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1624373942,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1597071,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLe9iavda8ia7vNkbMVEHsCKs43l6U6HGWibiaxxKd9PuiaYu5wRedicC96PLicZ9VIh0ic5Jg8YHPrta3IAQ/132","nickname":"Geek_00e01b","note":"","ucode":"BC76A83B53D0EF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328875,"discussion_content":"就像文中提到的vip用户可以实现透支提现情况，我觉得没啥不合理啊。但却违背了LSP原则，这怎么解释呢","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1606266226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":2042568,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/2a/c8/dc4e314e.jpg","nickname":"米豆丸","note":"","ucode":"CE99FE3A1EBCAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1597071,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLe9iavda8ia7vNkbMVEHsCKs43l6U6HGWibiaxxKd9PuiaYu5wRedicC96PLicZ9VIh0ic5Jg8YHPrta3IAQ/132","nickname":"Geek_00e01b","note":"","ucode":"BC76A83B53D0EF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333469,"discussion_content":"同问，求回答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607524990,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":328875,"ip_address":""},"score":333469,"extra":""},{"author":{"id":1183221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0d/f5/0fe960cd.jpg","nickname":"y","note":"","ucode":"D27C06881D13A5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2042568,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/2a/c8/dc4e314e.jpg","nickname":"米豆丸","note":"","ucode":"CE99FE3A1EBCAF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363596,"discussion_content":"说一下个人愚见，首先这个需求是合理的，不合理的话争哥不会拿这个举例。但这个透支提现改掉了方法原有的功能，可能会导致调用处出现不可预知的问题，所以说一千道一万还是尽量扩展，而不是修改。","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1617241962,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":333469,"ip_address":""},"score":363596,"extra":""},{"author":{"id":1015189,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7d/95/dd73022c.jpg","nickname":"我是曾经那个少年","note":"","ucode":"9F02F7FF147D14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1597071,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLe9iavda8ia7vNkbMVEHsCKs43l6U6HGWibiaxxKd9PuiaYu5wRedicC96PLicZ9VIh0ic5Jg8YHPrta3IAQ/132","nickname":"Geek_00e01b","note":"","ucode":"BC76A83B53D0EF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":395929,"discussion_content":"项目是迭代出来的，而不是设计出来的。这些原则我感觉是指导我们在刚开始设计的时候要考虑扩展性。这种需求违反了也没啥关系，例如SecurityTransporter违反了原则，但是一般我新增了我也不会让子类去掉用。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1632364350,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":328875,"ip_address":""},"score":395929,"extra":""}]},{"author":{"id":1193385,"avatar":"https://static001.geekbang.org/account/avatar/00/12/35/a9/e2a0ad48.jpg","nickname":"懒散","note":"","ucode":"6FC704ABE5A9E1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318700,"discussion_content":"这么理解感觉有点像装饰器模式？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1603810145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1250807,"avatar":"https://static001.geekbang.org/account/avatar/00/13/15/f7/744720a2.jpg","nickname":"DriveMan_邱佳源","note":"","ucode":"A4C83BF07DEE7A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1193385,"avatar":"https://static001.geekbang.org/account/avatar/00/12/35/a9/e2a0ad48.jpg","nickname":"懒散","note":"","ucode":"6FC704ABE5A9E1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352488,"discussion_content":"我感觉像是 模板模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614752403,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":318700,"ip_address":""},"score":352488,"extra":""},{"author":{"id":2853072,"avatar":"","nickname":"小杰同学","note":"","ucode":"C6FC59D58F772C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1250807,"avatar":"https://static001.geekbang.org/account/avatar/00/13/15/f7/744720a2.jpg","nickname":"DriveMan_邱佳源","note":"","ucode":"A4C83BF07DEE7A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582978,"discussion_content":"这是原则 模式就是根据原则来的。。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1659857699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":352488,"ip_address":"福建"},"score":582978,"extra":""}]},{"author":{"id":2276155,"avatar":"https://static001.geekbang.org/account/avatar/00/22/bb/3b/6e020a32.jpg","nickname":"多学多看多记","note":"","ucode":"0670C833007510","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":402196,"discussion_content":"go语言，这个设计原则是不是凉了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1633829086,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2806043,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLBFkSq1oiaEMRjtyyv4ZpCI0OuaSsqs04ODm0OkZF6QhsAh3SvqhxibS2n7PLAVZE3QRSn5Hic0DyXg/132","nickname":"ddh","note":"","ucode":"8E852375365F16","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2276155,"avatar":"https://static001.geekbang.org/account/avatar/00/22/bb/3b/6e020a32.jpg","nickname":"多学多看多记","note":"","ucode":"0670C833007510","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542428,"discussion_content":"啊哈哈哈， go语言里没有继承，只有组合","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640747422,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":402196,"ip_address":""},"score":542428,"extra":""}]},{"author":{"id":1455958,"avatar":"https://static001.geekbang.org/account/avatar/00/16/37/56/11068390.jpg","nickname":"倡印","note":"","ucode":"4F53AA5D017D89","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295347,"discussion_content":"厉害啊，好几年了竟然比不上你这一句话的精辟","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596171797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1328500,"avatar":"https://static001.geekbang.org/account/avatar/00/14/45/74/7a82eebb.jpg","nickname":"Ins","note":"","ucode":"A2509BAD9CB72C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577478,"discussion_content":"评论区大佬","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656136243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1567940,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ec/c4/19f85ada.jpg","nickname":"乃鱼同学","note":"","ucode":"50A96C24978057","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380209,"discussion_content":"子类是父类在某些维度即设计原则上的子集。而不能是交集。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624373708,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1112490,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f9/aa/3e80212e.jpg","nickname":"龙猫","note":"","ucode":"FD726CC969EF9C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296992,"discussion_content":"简洁、精辟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596724031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1283461,"avatar":"https://static001.geekbang.org/account/avatar/00/13/95/85/15cd21c2.jpg","nickname":"杨锋","note":"","ucode":"85A7828A538FB0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286132,"discussion_content":"感谢解惑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593069529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160684,"user_name":"Chen","can_delete":false,"product_type":"c1","uid":1503113,"ip_address":"","ucode":"C1128558AB5BC4","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/89/8c73a24d.jpg","comment_is_top":false,"comment_ctime":1576020937,"is_pvip":false,"discussion_count":12,"race_medal":0,"score":"873454382025","product_id":100039001,"comment_content":"135看设计模式，246看数据结构与算法。争哥大法好","like_count":203,"discussions":[{"author":{"id":1118560,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/0SDRac7XoordnKYgDLhz5wxAOtE6xqcsSywsywEtKQAR7xicBZQ6ceYftfZjl4Ivq3a5dzvRhYkn2GcUWiaQK7ZQ/132","nickname":"ThinkingQuest","note":"","ucode":"597D0C00DAEFE4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301866,"discussion_content":"拜争教","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1598689662,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1366022,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/ajNVdqHZLLBP7piae8iaHU7w2a4TyLKPFI7xiaia3Hias2ibMPftnFEic0lqGU315U70peQs7X3Kyd3bDgJjF6nBQg7xA/132","nickname":"Geek_862694","note":"","ucode":"977B4195C7CFB1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79375,"discussion_content":"原来不是我一个人这么做的啊😂","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576074317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2636178,"avatar":"https://static001.geekbang.org/account/avatar/00/28/39/92/88ed94f2.jpg","nickname":"YX","note":"","ucode":"CC108CCE845EAE","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534010,"discussion_content":"下午学mysql45讲","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1638070135,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1792800,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/5b/20/ae2d4489.jpg","nickname":"zkr","note":"","ucode":"8BF9D0348BBF87","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585818,"discussion_content":"信争哥，得永生（doge","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661842244,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2636178,"avatar":"https://static001.geekbang.org/account/avatar/00/28/39/92/88ed94f2.jpg","nickname":"YX","note":"","ucode":"CC108CCE845EAE","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534008,"discussion_content":"我就不一样，我是早上看设计模式，晚上学算法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638070111,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1591223,"avatar":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","nickname":"JerryZhu","note":"","ucode":"76850CD45786C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303495,"discussion_content":"和我一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599283787,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1447569,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/WtHCCMoLJ2DvzqQwPYZyj2RlN7eibTLMHDMTSO4xIKjfKR1Eh9L98AMkkZY7FmegWyGLahRQJ5ibPzeeFtfpeSow/132","nickname":"脱缰的野马__","note":"","ucode":"D5F993E7232C61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283242,"discussion_content":"那7干嘛","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592220737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2100090,"avatar":"https://static001.geekbang.org/account/avatar/00/20/0b/7a/9ce7dc7d.jpg","nickname":"东瓜酱","note":"","ucode":"B1FEADF98DE292","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1447569,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/WtHCCMoLJ2DvzqQwPYZyj2RlN7eibTLMHDMTSO4xIKjfKR1Eh9L98AMkkZY7FmegWyGLahRQJ5ibPzeeFtfpeSow/132","nickname":"脱缰的野马__","note":"","ucode":"D5F993E7232C61","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301734,"discussion_content":"明显7那天就是脱缰的野马","likes_number":20,"is_delete":false,"is_hidden":false,"ctime":1598622033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":283242,"ip_address":""},"score":301734,"extra":""},{"author":{"id":2875397,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/5mOXmBMEctr0icDNSZHqsdQcN7ricoKD0GeR5jPNFXMhicmia9ECzzbL17uDEMayewliczngU7xrAiaehkeZ5CrPgPSQ/132","nickname":"Geek_a99d59","note":"","ucode":"BFC2C85B96CCA1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2100090,"avatar":"https://static001.geekbang.org/account/avatar/00/20/0b/7a/9ce7dc7d.jpg","nickname":"东瓜酱","note":"","ucode":"B1FEADF98DE292","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546063,"discussion_content":"hhh，绝了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642147180,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301734,"ip_address":""},"score":546063,"extra":""}]},{"author":{"id":1247965,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0a/dd/88fa7b52.jpg","nickname":"Geek_41d472","note":"","ucode":"DEC2B6329460CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":187980,"discussion_content":"卧槽,你们这么闲的吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582784557,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1338088,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6a/e8/4bb87c34.jpg","nickname":"月马穿关","note":"","ucode":"2CE20CA1EB827D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":172896,"discussion_content":"哈哈哈哈哈哈嗝 咱们的计划是一样的！！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581815593,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1790368,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/51/a0/5db02ac2.jpg","nickname":"點點點，点顛","note":"","ucode":"1BC77F6E044650","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":104353,"discussion_content":"争个大法好！哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577426327,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160721,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1576025601,"is_pvip":true,"discussion_count":13,"race_medal":0,"score":"688770792961","product_id":100039001,"comment_content":"LSP的意义：<br>一、改进已有实现。例如程序最开始实现时采用了低效的排序算法，改进时使用LSP实现更高效的排序算法。<br>二、指导程序开发。告诉我们如何组织类和子类（subtype），子类的方法（非私有方法）要符合contract。<br>三、改进抽象设计。如果一个子类中的实现违反了LSP，那么是不是考虑抽象或者设计出了问题。<br><br>补充：<br>Liskov是美国历史上第一个女计算机博士，曾获得过图灵奖。<br>In 1968 she became one of the first women in the United States to be awarded a Ph.D from a computer science department when she was awarded her degree from Stanford University. At Stanford she worked with John McCarthy and was supported to work in artificial intelligence.<br><br>https:&#47;&#47;en.wikipedia.org&#47;wiki&#47;Barbara_Liskov","like_count":160,"discussions":[{"author":{"id":1323102,"avatar":"https://static001.geekbang.org/account/avatar/00/14/30/5e/c42bc33f.jpg","nickname":"Younger Ku","note":"","ucode":"D157DC38BDB515","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304649,"discussion_content":"如今作为计算机行业的佼佼者，Barbara在谈到自己的经验时，体会最深刻的就是：没有专心致志的精神就不会成功，创造性偶尔会出现，但这不是人所能计划的。专心做一件事，不一定会有创造性的想法，但是这总会让你有所进步，因此，她第一个经验就是，你必须要专心地解决一些问题；但是，同时要谨记不要时时刻刻都想着它，很多有创意的想法都是在比较轻松的时刻出现的。她从来不晚上在家工作，而是喜欢早晨进入工作状态之后再想应该做什么，这个时候往往会有一些好的想法涌现，因此，既要有精力高度集中的时刻，也需要有喘息的机会。她说，有些年轻人整天不停的工作，忽略了朋友，丢掉了爱好，这些都是不可取的，有一个平衡的生活状态是非常重要的，富有幽默感也很重要。有很多人爱抱怨，如果你能微笑着面对许多的不如意，事情往往就会向一个积极的方向发展。最后，还要信任他人。","likes_number":30,"is_delete":false,"is_hidden":false,"ctime":1599635048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1458302,"avatar":"https://static001.geekbang.org/account/avatar/00/16/40/7e/97a8d96d.jpg","nickname":"李小任","note":"","ucode":"BF738A5C1678DE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295940,"discussion_content":"one of the first women","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596385546,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2096765,"avatar":"","nickname":"Geek_cde7db","note":"","ucode":"D8A7F8EA700009","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1458302,"avatar":"https://static001.geekbang.org/account/avatar/00/16/40/7e/97a8d96d.jpg","nickname":"李小任","note":"","ucode":"BF738A5C1678DE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296466,"discussion_content":"如同 世界上最高的山之一","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596549551,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":295940,"ip_address":""},"score":296466,"extra":""}]},{"author":{"id":1333094,"avatar":"https://static001.geekbang.org/account/avatar/00/14/57/66/e57bdb18.jpg","nickname":"liliumss","note":"","ucode":"A52AC5042F3115","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":115614,"discussion_content":"lisvo原来是女得 豪杰啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578022608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1333094,"avatar":"https://static001.geekbang.org/account/avatar/00/14/57/66/e57bdb18.jpg","nickname":"liliumss","note":"","ucode":"A52AC5042F3115","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":115618,"discussion_content":"是呀！不看不知道！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578022774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":115614,"ip_address":""},"score":115618,"extra":""}]},{"author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84466,"discussion_content":"增强已有实现。为这一点点赞👍！不理解为什么老师只说了违背的案例没说遵守的案例。不像数据结构课程的质量啊！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576497953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1027352,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ad/18/41831eae.jpg","nickname":"AaronChun","note":"","ucode":"0D4A4CBD676A3D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":92867,"discussion_content":"个人认为增强已有实现应该是面向对象中多态特性的一种实践阐述，毕竟里氏替换是一种设计思想，本质上关注的是“怎么做”的问题，“做的好”应该是实现语言范畴内的一种要求。PS：其实不用过于深究，多态和里氏替换都都可以做到增强已有实现，争哥没提可能有这方面的考虑（都是自己猜猜的^_^）","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576890811,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":84466,"ip_address":""},"score":92867,"extra":""},{"author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1027352,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ad/18/41831eae.jpg","nickname":"AaronChun","note":"","ucode":"0D4A4CBD676A3D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":93193,"discussion_content":"为你点赞👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576913119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":92867,"ip_address":""},"score":93193,"extra":""}]},{"author":{"id":1443663,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIang00R9vkklnkFCLhzRysNfocr0sLnCdoZwOT3UkulAPefk5BDvd0PfIeQSODSQg1DjKWUmJOaA/132","nickname":"陈迎春","note":"","ucode":"2870BA6D6E5B1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":80106,"discussion_content":"赞一个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576147191,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1132661,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","nickname":"乘坐Tornado的线程魔法师","note":"","ucode":"C4C9915866E769","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79302,"discussion_content":"棒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576072764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1048799,"avatar":"https://static001.geekbang.org/account/avatar/00/10/00/df/58fe37df.jpg","nickname":"左","note":"","ucode":"FE02803AE2C0F0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79132,"discussion_content":"你是最棒的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576060145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1048799,"avatar":"https://static001.geekbang.org/account/avatar/00/10/00/df/58fe37df.jpg","nickname":"左","note":"","ucode":"FE02803AE2C0F0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79185,"discussion_content":"我也这么觉着😀","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576066501,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":79132,"ip_address":""},"score":79185,"extra":""}]},{"author":{"id":1015483,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","nickname":"程序员小跃","note":"","ucode":"25BB96E0791A60","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78925,"discussion_content":"棒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576033234,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160937,"user_name":"任鹏斌","can_delete":false,"product_type":"c1","uid":1104086,"ip_address":"","ucode":"34319B05EA6E74","user_header":"https://static001.geekbang.org/account/avatar/00/10/d8/d6/47da34bf.jpg","comment_is_top":false,"comment_ctime":1576065154,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"534152009858","product_id":100039001,"comment_content":"里氏替换就是说父亲能干的事儿子也别挑，该怎么干就怎么干，儿子可以比父亲更有能力，但传统不能变","like_count":125,"discussions":[{"author":{"id":1440025,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f9/19/7c3b12ee.jpg","nickname":"Geek_deb968","note":"","ucode":"2305597B009AF3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289126,"discussion_content":"传统这个词用的好ヾ ^_^♪","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1593999235,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160692,"user_name":"失火的夏天","can_delete":false,"product_type":"c1","uid":1241770,"ip_address":"","ucode":"10C6E66EB2A65F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","comment_is_top":false,"comment_ctime":1576022825,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"409597915945","product_id":100039001,"comment_content":"里氏替换最终一句话还是对扩展开放，对修改关闭，不能改变父类的入参，返回，但是子类可以自己扩展方法中的逻辑。父类方法名很明显限定了逻辑内容，比如按金额排序这种，子类就不要去重写金额排序，改成日期排序之类的，而应该抽出一个排序方法，然后再写一个获取排序的方法，父类获取排序调用金额排序，子类就重写调用排序方法，获取日期排序。<br><br>个人感觉也是为了避免“二意性”，这里是只父类的逻辑和子类逻辑差别太多，读代码的人会感觉模棱两可，父类一套，子类一套，到底应该读哪种。感觉会混乱。<br><br>总之就是，子类的重写最好是扩展父类，而不要修改父类。","like_count":96,"discussions":[{"author":{"id":1608383,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8a/bf/3f7c45c9.jpg","nickname":"X_L～","note":"","ucode":"6BD8C24750F86B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302855,"discussion_content":"对于老祖宗定下的规矩,只能修订,不能修改","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599048418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1049576,"avatar":"https://static001.geekbang.org/account/avatar/00/10/03/e8/4c943503.jpg","nickname":"乐","note":"","ucode":"4505CB6BD9C144","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":86994,"discussion_content":"避免二意性，说的很到位","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576636481,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1095997,"avatar":"https://static001.geekbang.org/account/avatar/00/10/b9/3d/e061a652.jpg","nickname":"Geek_109a0b","note":"","ucode":"93A45B581947FC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287095,"discussion_content":"简单点说就是继承了父类，最好只做代码添加，不做逻辑改动","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593359650,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1132661,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","nickname":"乘坐Tornado的线程魔法师","note":"","ucode":"C4C9915866E769","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":91801,"discussion_content":"兄弟你提到的：“而应该抽出一个排序方法，然后再写一个获取排序的方法，父类获取排序调用金额排序，子类就重写调用排序方法，获取日期排序。” 可以解释得再具体一些嘛？如果父类实现了sort方法，那么子类也要重写sort方法吗？还是说不重写sort方法，而新写一个sortByDate方法？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576848041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1258380,"avatar":"https://static001.geekbang.org/account/avatar/00/13/33/8c/23eef8d7.jpg","nickname":"feifei","note":"","ucode":"BFA3BE8D8773A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87512,"discussion_content":"你这说得好像跟文章里说的相反吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576671375,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1258380,"avatar":"https://static001.geekbang.org/account/avatar/00/13/33/8c/23eef8d7.jpg","nickname":"feifei","note":"","ucode":"BFA3BE8D8773A7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87543,"discussion_content":"哪里相反了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576672423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":87512,"ip_address":""},"score":87543,"extra":""}]},{"author":{"id":1298279,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cf/67/057e5d93.jpg","nickname":"flying","note":"","ucode":"69AB7872B36B23","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":80242,"discussion_content":"说的好，子类要是不能比父类功能多，感觉除了提高性能外，感觉就没啥用了。关键还是要扩展其他接口，提供更多的功能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576156567,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160822,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1576039905,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"233504273889","product_id":100039001,"comment_content":"里式替换是细力度的开闭原则。这个准则应用的场景，往往是在方法功能的调整上，要达到的效果是：该方法对已经调用的代码的效果不变，并能支撑新的功能或提供更好的性能。换句话说，就是在保证兼容的前提条件下做扩展和调整。<br><br>spring对里式替换贯彻得不错，从1.x到4.x能看到大部分代码都坚强的保留着兼容性。<br>但springboot就有点跳脱了，1.x小版本就会有违背里式替换的破坏性升级。1.x到2.x更是出现跳票重灾的情况。带来的损失相信做过springboot版本升级的人都很有感触，而这份损失也表达出坚守里式替换原则的重要性。不过，既然springboot会违背经营多年的原则（向下兼容），那么绝非空穴来风，相信在他们看来，违背里式替换做的升级，带来的价值能够盖过损失。所以我觉得里式替换依旧是个权衡项，在日常开发中我们要坚守，但当发现不合理，比如设计缺陷或则业务场景质变时，做破坏性改造也意味着即使止损，是一个可选项。","like_count":55,"discussions":[{"author":{"id":1313115,"avatar":"https://static001.geekbang.org/account/avatar/00/14/09/5b/e9ee3b41.jpg","nickname":"音为","note":"","ucode":"D78E4CBCE6BF45","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587080,"discussion_content":"里氏替换原则还可以指导版本的向后兼容","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662767598,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1637228,"avatar":"https://static001.geekbang.org/account/avatar/00/18/fb/6c/12fdc372.jpg","nickname":"迈向架构师","note":"","ucode":"2476594CF76001","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":135576,"discussion_content":"诶？ 里式替换还能用来指导版本升级的吗？  我以为是用来约束同个版本的不同子类的行为","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579097020,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1637228,"avatar":"https://static001.geekbang.org/account/avatar/00/18/fb/6c/12fdc372.jpg","nickname":"迈向架构师","note":"","ucode":"2476594CF76001","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":136313,"discussion_content":"版本和原则两码事。spring里面xxxapplication这种一般都是模板模式。2.x引入注解驱动，该驱动实现其操作和父类保持一致，所以1.x只要加上注解改用注解驱动，其他不用动。springboot1.0-1.4部分注解（注解的伴生关系算得上是一种伪继承实现），内部有比较大变化，比如xxxoncondition，升级版本（功能迭代），会导致api调用方异常。\n例子不好，大概这个意思。看的是代码变动后的影响，而不是版本。里式替换指的子父类的这种关系，但其实往宽的看就是针对代码变动后，对所有api调用方的影响。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579137393,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":135576,"ip_address":""},"score":136313,"extra":""}]}]},{"had_liked":false,"id":160674,"user_name":"Kevinlvlc","can_delete":false,"product_type":"c1","uid":1176980,"ip_address":"","ucode":"90DFD58CED138C","user_header":"https://static001.geekbang.org/account/avatar/00/11/f5/94/67fabf8e.jpg","comment_is_top":false,"comment_ctime":1576017802,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"194849546122","product_id":100039001,"comment_content":"我觉得可以从两个角度谈里式替换原则的意义。<br>首先，从接口或父类的角度出发，顶层的接口&#47;父类要设计的足够通用，并且可扩展，不要为子类或实现类指定实现逻辑，尽量只定义接口规范以及必要的通用性逻辑，这样实现类就可以根据具体场景选择具体实现逻辑而不必担心破坏顶层的接口规范。<br>从子类或实现类角度出发，底层实现不应该轻易破坏顶层规定的接口规范或通用逻辑，也不应该随意添加不属于这个类要实现的功能接口，这样接口的外部使用者可以不必关心具体实现，安全的替换任意实现类，同时内部各个不同子类既可以根据不同场景做各自的扩展，又不破坏顶层的设计，从维护性和扩展性来说都能得到保证","like_count":45},{"had_liked":false,"id":160687,"user_name":"时光勿念","can_delete":false,"product_type":"c1","uid":1025003,"ip_address":"","ucode":"72C8EC5A62C700","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a3/eb/d26459ae.jpg","comment_is_top":false,"comment_ctime":1576021303,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"151899876663","product_id":100039001,"comment_content":"呃，我不知道这样理解对不对。<br>多态是一种特性、能力，里氏替换是一种原则、约定。<br>虽然多态和里氏替换不是一回事，但是里氏替换这个原则 需要 多态这种能力 才能实现。<br>里氏替换最重要的就是替换之后原本的功能一点不能少。","like_count":35,"discussions":[{"author":{"id":1368038,"avatar":"https://static001.geekbang.org/account/avatar/00/14/df/e6/bd1b3c0b.jpg","nickname":"Jesse","note":"","ucode":"727CA882B84DA0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78881,"discussion_content":"好像功能也不能多。。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1576029584,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1161271,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","nickname":"不似旧日","note":"","ucode":"DF4C5E3AB9570C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79038,"discussion_content":"是功能不变, 方法的功能和规则不能变,具体的实现逻辑可以变","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576048900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1754311,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/c4/c7/bd963efc.jpg","nickname":"Tosca","note":"","ucode":"605ABDCEA945DF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":83081,"discussion_content":"也不能多","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576414757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160708,"user_name":"何妨","can_delete":false,"product_type":"c1","uid":1385377,"ip_address":"","ucode":"EC3983BFF7992A","user_header":"https://static001.geekbang.org/account/avatar/00/15/23/a1/b08f3ee7.jpg","comment_is_top":false,"comment_ctime":1576024470,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"70295501206","product_id":100039001,"comment_content":"多态是语法特性，是一种实现方法。里式替换是设计原则，是一种规范。其存在的意义是用来规范我们对方法的使用，即指导我们如何正确的使用多态。","like_count":16},{"had_liked":false,"id":161129,"user_name":"destiny","can_delete":false,"product_type":"c1","uid":1744284,"ip_address":"","ucode":"8D38BF89E76450","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9d/9c/2d5eac97.jpg","comment_is_top":false,"comment_ctime":1576125396,"is_pvip":false,"discussion_count":10,"race_medal":0,"score":"53115732948","product_id":100039001,"comment_content":"VIP提现可透支这种情况如何不违背里氏替换原则？","like_count":12,"discussions":[{"author":{"id":1429627,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJN64OCUT0Jp0h2Wiau9Os0o1WbwUeoq2QL0U2vZpib8ozPxo0XDiaPM9xcKfbkoBL24ztEHelxPIMVg/132","nickname":"Kevin","note":"","ucode":"9DFFD6E3960CF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84008,"discussion_content":"注释未考虑到未来的需求扩展。 修改父类的注释。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1576480414,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1624574,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c9/fe/874b172b.jpg","nickname":"benxiong","note":"","ucode":"F6498059D439D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1429627,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJN64OCUT0Jp0h2Wiau9Os0o1WbwUeoq2QL0U2vZpib8ozPxo0XDiaPM9xcKfbkoBL24ztEHelxPIMVg/132","nickname":"Kevin","note":"","ucode":"9DFFD6E3960CF7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386115,"discussion_content":"哈哈修改注释这个可以的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1627428270,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":84008,"ip_address":""},"score":386115,"extra":""}]},{"author":{"id":1268264,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5a/28/732d3f2f.jpg","nickname":"GEEKBANG_6638780","note":"","ucode":"952194E56FD8C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383277,"discussion_content":"改用策略模式， 每种等级一个策略。 保不齐vip还分等级，然后透支程度不一样","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1626018557,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1448126,"avatar":"https://static001.geekbang.org/account/avatar/00/16/18/be/ad3127e0.jpg","nickname":"慕高迪","note":"","ucode":"EB1CB5EA4E3A90","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290527,"discussion_content":"新创建方法吧，withDrawForVIP() ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594523560,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1196641,"avatar":"https://static001.geekbang.org/account/avatar/00/12/42/61/de579755.jpg","nickname":"醉碧川","note":"","ucode":"B0DCE5E48FDD82","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1448126,"avatar":"https://static001.geekbang.org/account/avatar/00/16/18/be/ad3127e0.jpg","nickname":"慕高迪","note":"","ucode":"EB1CB5EA4E3A90","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304578,"discussion_content":"我觉得修改父类的约定或者新增方法应该都是可以的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1599619581,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":290527,"ip_address":""},"score":304578,"extra":""}]},{"author":{"id":1075334,"avatar":"https://static001.geekbang.org/account/avatar/00/10/68/86/348be7f8.jpg","nickname":"Lingo","note":"","ucode":"82ECA2E0533B78","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576406,"discussion_content":"修改父类函数的定义，完善单元测试，支持子类透支功能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655527091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1488356,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b5/e4/e6faf686.jpg","nickname":"握了个大蚂蚱","note":"","ucode":"AD34AD4FA37371","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383661,"discussion_content":"修改注释是正解，只是为了举这个例子，从方法名和提现业务本身来说，透支都是没毛病的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626183877,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1565950,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKvnkXZiaop0hbe9w5kuAvf6d17suDPB6W1j2hlYPJ43eRogABUic5pUV7ia5rPHjXLWEfDZLHiafMUiaQ/132","nickname":"marsly","note":"","ucode":"1F61DE32D99426","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281773,"discussion_content":"我也很是疑惑怎么修改这个，或者针对VIP实现单独的函数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591802426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1125834,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2d/ca/02b0e397.jpg","nickname":"fomy","note":"","ucode":"CD87EA03B1F327","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":115473,"discussion_content":"1、修改注释，然后新增VIP的实现类即可。\n2、接口新增一个提现方法，VIP实现这个接口方法。其他实现类还是调用原来的体提现即可。然后逐步改造使用新的提现接口。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578015296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84455,"discussion_content":"可能只能修改协议了。因为我感觉用多态来实现这个再合适不过了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576497794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160695,"user_name":"Cy23","can_delete":false,"product_type":"c1","uid":1591293,"ip_address":"","ucode":"8DC561C5151758","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/fd/895f0c27.jpg","comment_is_top":false,"comment_ctime":1576023244,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"53115630796","product_id":100039001,"comment_content":"听完感觉就是，子类可以无损替换父类，就是里氏替换原则。对否","like_count":12},{"had_liked":false,"id":180842,"user_name":"ladidili","can_delete":false,"product_type":"c1","uid":1217498,"ip_address":"","ucode":"38886C1908DE6B","user_header":"https://static001.geekbang.org/account/avatar/00/12/93/da/0e47c76e.jpg","comment_is_top":false,"comment_ctime":1582427421,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"35942165789","product_id":100039001,"comment_content":"多态是工具，是实在的东西。里式替换是设计思路，是虚的东西。<br><br>多态做到外壳，做到结构一致。<br>里式替换在结构一致的前提下还要保持底层逻辑一致。<br><br>设计模式都是用来指导开发的。里式替换指导父类更加抽象复用，子类更加贴近最初的原则。<br>","like_count":8},{"had_liked":false,"id":163569,"user_name":"王加武","can_delete":false,"product_type":"c1","uid":1665471,"ip_address":"","ucode":"DDCFE578C6C428","user_header":"https://static001.geekbang.org/account/avatar/00/19/69/bf/50a824a4.jpg","comment_is_top":false,"comment_ctime":1576746866,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35936485234","product_id":100039001,"comment_content":"在继承当中，尽量不要去重写父类的方法<br>里氏替换原则告诉我们，继承实际上是提高了两个类的耦合性，在适当的情况下，我们可以使用组合，依赖，聚合等来解决问题！","like_count":8},{"had_liked":false,"id":160714,"user_name":"知行合一","can_delete":false,"product_type":"c1","uid":1521486,"ip_address":"","ucode":"2B8E634FC4CFB7","user_header":"https://static001.geekbang.org/account/avatar/00/17/37/4e/5c3153b2.jpg","comment_is_top":false,"comment_ctime":1576025190,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35935763558","product_id":100039001,"comment_content":"多态是种能力，里氏是一种约定。能力是摆在那里的，约定却不一定强制遵守，有时候可能会打破约定。需要权衡","like_count":8},{"had_liked":false,"id":160779,"user_name":"qqq","can_delete":false,"product_type":"c1","uid":1006786,"ip_address":"","ucode":"91B0ACF8CBE7BD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/c2/8ffd2ad0.jpg","comment_is_top":false,"comment_ctime":1576031897,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"27345835673","product_id":100039001,"comment_content":"遵守协议，保证一致性","like_count":6},{"had_liked":false,"id":163875,"user_name":"雨幕下的稻田","can_delete":false,"product_type":"c1","uid":1388799,"ip_address":"","ucode":"1FBFF3187AE9C4","user_header":"https://static001.geekbang.org/account/avatar/00/15/30/ff/b3e54147.jpg","comment_is_top":false,"comment_ctime":1576816032,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"23051652512","product_id":100039001,"comment_content":"LSP感觉是在多态的基础上强调了协议的重要性","like_count":5,"discussions":[{"author":{"id":1107666,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e6/d2/638ca831.jpg","nickname":"z","note":"","ucode":"CDB0BE8562ECB6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300318,"discussion_content":"同感，LSP的实现依赖多态","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598021302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160732,"user_name":"帆大肚子","can_delete":false,"product_type":"c1","uid":1529040,"ip_address":"","ucode":"3DB11DB2FA1802","user_header":"https://static001.geekbang.org/account/avatar/00/17/54/d0/4e1fc664.jpg","comment_is_top":false,"comment_ctime":1576027133,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23050863613","product_id":100039001,"comment_content":"在可拔插的设计中，保证原有代码的正确性","like_count":5},{"had_liked":false,"id":180779,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1582385559,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18762254743","product_id":100039001,"comment_content":"父类假如在协议上约定得非常细，方法命名中说明了实现细节，就会导致子类扩展受限，也是对里氏替换的一种限制。","like_count":4},{"had_liked":false,"id":164519,"user_name":"G","can_delete":false,"product_type":"c1","uid":1547293,"ip_address":"","ucode":"50D8E1ADAE0330","user_header":"https://static001.geekbang.org/account/avatar/00/17/9c/1d/34c96367.jpg","comment_is_top":false,"comment_ctime":1577019505,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18756888689","product_id":100039001,"comment_content":"我感觉里式替换对心智的负担比较大，虽然没有改写父类，但实际父类不再使用了，等同于修改了父类。这种重构让我想起了js的痛苦，逻辑都要在运行时才能知道，而且静态编译时，编译器无法帮助推断，还不如多态直接告诉编译器。","like_count":4},{"had_liked":false,"id":160702,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1576024049,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18755893233","product_id":100039001,"comment_content":"设计模式_17:<br>里氏替换：<br>协议(一致性)带来效率！<br><br>从多态的角度，真的可以随便写，越是与父类不同，就显得越多态。<br>但如果没有限制&#47;协议地多态，抽象就困难起来，在任何时候都需要考虑所有子类的实现细节，多态也就没有意义。","like_count":4,"discussions":[{"author":{"id":1734656,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/78/00/675a5795.jpg","nickname":"小龙成Hu","note":"","ucode":"6AFCED06795C91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":209937,"discussion_content":"我感觉多态注重关系层面的替换，里氏替换原则更感觉基于多态思想的一种细节落地","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584692037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284448,"user_name":"建锋","can_delete":false,"product_type":"c1","uid":1616445,"ip_address":"","ucode":"DF4AAE135B152B","user_header":"https://static001.geekbang.org/account/avatar/00/18/aa/3d/c14e338e.jpg","comment_is_top":false,"comment_ctime":1616251302,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14501153190","product_id":100039001,"comment_content":"带着镣铐舞蹈","like_count":3},{"had_liked":false,"id":169186,"user_name":"董瑞","can_delete":false,"product_type":"c1","uid":1117752,"ip_address":"","ucode":"5A701013987147","user_header":"https://static001.geekbang.org/account/avatar/00/11/0e/38/cffa4734.jpg","comment_is_top":false,"comment_ctime":1578287890,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14463189778","product_id":100039001,"comment_content":"里氏替换原则存在的意义：<br>1. 增强父类或接口进行约定，子类进行实现的设计原则，明确父类是抽象定义，子类是具体实现的面向对象编程思想<br>2. 为子类设计和实现提供了明确而有用的指导思想，子类的协议实现不能超越父类的抽象定义，否则，违背约定的子类实现会导致系统可读性、可运行性会出现不符合预期的逻辑行为<br>3. 增加了对多态编程方法的应用指导，多态是一种编码实现的思路，设计和实现可以很宽泛，应用里氏替换原则的指导，可以设计出高质量的多态编程，从而让面向对象编程实现的程序的可读性、健壮性更好","like_count":3},{"had_liked":false,"id":168545,"user_name":"迷羊","can_delete":false,"product_type":"c1","uid":1286251,"ip_address":"","ucode":"85AF8CED3436C8","user_header":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","comment_is_top":false,"comment_ctime":1578107813,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14463009701","product_id":100039001,"comment_content":"一、如何理解里氏替换原则？<br>1.子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。（示例可查看专栏文章）<br>2.里氏替换原则更有指导意义的描述是：按照协议来设计。子类在设计的时候，要遵守父类的行为约定&#47;协议。父类定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。行为约定包括：函数声明要实现的功能；对输入、输出、异常的约定；注释中所罗列的特殊说明。同理也可以对应到接口和实现类。<br><br>二、哪些代码明显违背了LSP?<br>1.子类违背父类声明要实现的功能<br>父类中提供的sortOrdersByAmount()订单排序函数，是按照金额从小到大来给订单排序的，而子类重写这个方法之后是按照创建日期来给订单排序的。那子类的设计就违背里氏替换原则。<br>2.子类违背父类对输入、输出、异常的约定<br>父类中某个函数约定：运行出错返回null；获取数据为空时返回空集合。子类重写函数之后，运行出错返回异常，获取不到数据返回null。那子类的设计就违背里氏替换原则。<br>父类中某个函数约定，输入数据可以是任意整数，子类实现只允许输入数据是正整数，负数就抛出，也就是说子类对输入的数据的校验比父类更加严格，那子类的设计就违背了里氏替换原则。<br>父类中某个函数约定，只会抛出ArgumentNullException异常，子类的设计实现抛出了其他的异常，那子类的设计就违背了里氏替换原则。<br>3.子类违背父类注释中所罗列的任何特殊说明<br>父类中定义的 withdraw() 提现函数的注释是这么写的：“用户的提现金额不得超过账户余额……”，而子类重写 withdraw() 函数之后，针对 VIP 账号实现了透支提现的功能，也就是提现金额可以大于账户余额，那这个子类的设计也是不符合里式替换原则的。<br>4.判断子类的设计实现是否违背里氏替换原则，我们可以拿父类的单元测试去验证子类的代码。如果某些单元测试运行事呗，就有可能说明子类的设计实现没有完全遵守父类的约定，子类就有可能违背了里氏替换原则。<br><br>三、多态和里氏替换原则的区别<br>多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。","like_count":3},{"had_liked":false,"id":163953,"user_name":"岁月","can_delete":false,"product_type":"c1","uid":1337598,"ip_address":"","ucode":"29A2A2BC3C4FE4","user_header":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","comment_is_top":false,"comment_ctime":1576833755,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14461735643","product_id":100039001,"comment_content":"我觉得, 子类的设计更多的是为了增加&quot;某个需求的实现&quot;的方式, 比如后端, 一个读写类, 子类可以分别实现多种类型数据库的读写. 比如做前端, 一个界面的渲染, 子类可以提供多种多样的渲染结果. 所以一般子类是不会去重写父类的&quot;按照数量排序&quot;这种代码, 除非真的只是为了优化性能, 但是优化性能一般是直接修改父类代码而不是新增一个高性能子类, 除非是增加一个&quot;用空间换时间&quot;这样的高性能子类, 但是这样的子类又变成了我一开头说的:  为了增加&quot;某个需求的实现&quot;.","like_count":3,"discussions":[{"author":{"id":1565950,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKvnkXZiaop0hbe9w5kuAvf6d17suDPB6W1j2hlYPJ43eRogABUic5pUV7ia5rPHjXLWEfDZLHiafMUiaQ/132","nickname":"marsly","note":"","ucode":"1F61DE32D99426","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281779,"discussion_content":"是啊，如果真的是优化，此时在父类优化最好啊~~~除非这个优化是有限制的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591802668,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":281801,"user_name":"Geek_ad9237","can_delete":false,"product_type":"c1","uid":1996239,"ip_address":"","ucode":"FED3652DFAE79F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIeTLkHYdJ3lTe21qGTH6j6KibTfFicc8IBj5gHbIZlBruoyT02HyBbVVMGSz93PMmN9xRVib40dKlyw/132","comment_is_top":false,"comment_ctime":1614908023,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10204842615","product_id":100039001,"comment_content":"里氏替换原则约束了多态行为，以防出现不符合规约的多态在运行时出现意料之外的行为，如：参数校验、返回值、业务逻辑的规约","like_count":2},{"had_liked":false,"id":273230,"user_name":"青蛙军曹ψ","can_delete":false,"product_type":"c1","uid":1736523,"ip_address":"","ucode":"F7D6CA78203472","user_header":"https://static001.geekbang.org/account/avatar/00/1a/7f/4b/b0afc0ae.jpg","comment_is_top":false,"comment_ctime":1610503481,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10200438073","product_id":100039001,"comment_content":"多态是一种语法，lsp 是一种设计原则。lsp依赖多态的语法机制，但lsp从功能，输入，输出，异常等方面的约定，对子类提出了跟进一步的要求。","like_count":2},{"had_liked":false,"id":202636,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1586020609,"is_pvip":false,"discussion_count":1,"race_medal":1,"score":"10175955201","product_id":100039001,"comment_content":"里式替换原则，可以形象的理解为：做一个上进的乖孩子！","like_count":2,"discussions":[{"author":{"id":2409059,"avatar":"https://static001.geekbang.org/account/avatar/00/24/c2/63/f304703d.jpg","nickname":"光林","note":"","ucode":"BA9A36E3BB65D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344156,"discussion_content":"这个比较通俗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611307263,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168026,"user_name":"- -","can_delete":false,"product_type":"c1","uid":1338203,"ip_address":"","ucode":"FBB2869AD5FEA5","user_header":"https://static001.geekbang.org/account/avatar/00/14/6b/5b/16a93d9d.jpg","comment_is_top":false,"comment_ctime":1577979436,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10167914028","product_id":100039001,"comment_content":"最直接的感受是增加可读性，也就是只要理解父类的方法是做什么的，阅读子类时大原则是不变的，只是逻辑实现会有点不一样","like_count":2},{"had_liked":false,"id":162801,"user_name":"Treasure","can_delete":false,"product_type":"c1","uid":1177602,"ip_address":"","ucode":"4211ECEB347C3D","user_header":"https://static001.geekbang.org/account/avatar/00/11/f8/02/a02d127d.jpg","comment_is_top":false,"comment_ctime":1576591328,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10166525920","product_id":100039001,"comment_content":"在改造之后的代码中，如果传递进 demoFunction() 函数的是父类 Transporter 对象，那 demoFunction() 函数并不会有异常抛出，但如果传递给 demoFunction() 函数的是子类 SecurityTransporter 对象，那 demoFunction() 有可能会有异常抛出。<br><br>——————————————————<br>为什么可能会有异常啊，看了好久，也没发现原因，求解答。","like_count":2,"discussions":[{"author":{"id":1107666,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e6/d2/638ca831.jpg","nickname":"z","note":"","ucode":"CDB0BE8562ECB6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300320,"discussion_content":"改造后的子类，第20行代码抛异常了，是有可能执行到这一行的，所以说是可能抛异常。文章描述是有点让人误解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598021714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161964,"user_name":"秋天","can_delete":false,"product_type":"c1","uid":1057056,"ip_address":"","ucode":"A7E1D953EF7E17","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/20/1299e137.jpg","comment_is_top":false,"comment_ctime":1576417762,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10166352354","product_id":100039001,"comment_content":"打卡坚持学习","like_count":2},{"had_liked":false,"id":160994,"user_name":"无道win","can_delete":false,"product_type":"c1","uid":1461075,"ip_address":"","ucode":"0C026BB03A53EA","user_header":"https://static001.geekbang.org/account/avatar/00/16/4b/53/f797f031.jpg","comment_is_top":false,"comment_ctime":1576074470,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"10166009062","product_id":100039001,"comment_content":"有个疑问，如果现实开发中遇到类似于SecurityTransporte类新增校验的情况，那么应该怎么处理呢？是否违背李式替换，在子类中新增父类中没有的异常？","like_count":2,"discussions":[{"author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":117284,"discussion_content":"我觉得不能太死板，主要还是看具体业务，如果开发中遇到了你说的这种情况，大胆取用就好了，毕竟编程还是为了解决实际问题","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578106492,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":281443,"user_name":"DriveMan_邱佳源","can_delete":false,"product_type":"c1","uid":1250807,"ip_address":"","ucode":"A4C83BF07DEE7A","user_header":"https://static001.geekbang.org/account/avatar/00/13/15/f7/744720a2.jpg","comment_is_top":false,"comment_ctime":1614752346,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5909719642","product_id":100039001,"comment_content":"感觉这个里式替换原则和模板模式 相似","like_count":1},{"had_liked":false,"id":244017,"user_name":"。华伟","can_delete":false,"product_type":"c1","uid":2095422,"ip_address":"","ucode":"CD2645632E70D0","user_header":"https://static001.geekbang.org/account/avatar/00/1f/f9/3e/aef7a849.jpg","comment_is_top":false,"comment_ctime":1598352561,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5893319857","product_id":100039001,"comment_content":"感觉是严格意义上的对扩展开放，对修改关闭","like_count":1},{"had_liked":false,"id":242145,"user_name":"火影.海诺","can_delete":false,"product_type":"c1","uid":2091565,"ip_address":"","ucode":"34729AFEE93B6D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/ea/2d/34cb8e0a.jpg","comment_is_top":false,"comment_ctime":1597623778,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5892591074","product_id":100039001,"comment_content":"没有全新的了解……印象深刻的一个理解是，抽象意义上的子类在替换父类后不能改变代码原来的逻辑和程序正确性！还是会回到扩展性这个问题是，替换原则也要准寻的一个原则是你可以扩展我，但你不能改变我！","like_count":1},{"had_liked":false,"id":212359,"user_name":"简单猫","can_delete":false,"product_type":"c1","uid":1866485,"ip_address":"","ucode":"EA027D4C344E25","user_header":"https://static001.geekbang.org/account/avatar/00/1c/7a/f5/54a5084b.jpg","comment_is_top":false,"comment_ctime":1588089130,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5883056426","product_id":100039001,"comment_content":"里氏替代原则，父类的行为 子类要与其一致。对修改关闭 对扩展开放。但是我认为重载父方法 在其内部调用super.父类方法前后做一些类似日志操作 应该不算是违反了 里氏替代原则吧<br>","like_count":1},{"had_liked":false,"id":194032,"user_name":"黑客时间","can_delete":false,"product_type":"c1","uid":1831324,"ip_address":"","ucode":"7E22D76EECAC4D","user_header":"https://static001.geekbang.org/account/avatar/00/1b/f1/9c/cd12361d.jpg","comment_is_top":false,"comment_ctime":1585016458,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879983754","product_id":100039001,"comment_content":"如果我确实需要一个像这种参数校验的功能，如果没有这两个参数，会对后续的业务流程产生影响，那该怎么扩展这个方法呢","like_count":1},{"had_liked":false,"id":161768,"user_name":"淞淞同学","can_delete":false,"product_type":"c1","uid":1179533,"ip_address":"","ucode":"529A326B898008","user_header":"https://static001.geekbang.org/account/avatar/00/11/ff/8d/8601f035.jpg","comment_is_top":false,"comment_ctime":1576321134,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5871288430","product_id":100039001,"comment_content":"我的理解，多态是满足了语法和编译层面上的转换兼容，没有逻辑实现层面上的转换兼容。里氏替换原则要求的是两个函数可以替换类似重构的要求，不改变原有函数的行为。","like_count":1},{"had_liked":false,"id":161686,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1576296090,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5871263386","product_id":100039001,"comment_content":"提到里氏替换原则，让我想起了，cpp的纯虚类，和纯虚函数就有点类似里氏替换，他必须要实现父类的纯虚函数，再由于cpp函数编译过程的原因就导致必须要和父类的函数，名字，参数，返回值等等都一模一样！","like_count":1,"discussions":[{"author":{"id":1247039,"avatar":"https://static001.geekbang.org/account/avatar/00/13/07/3f/53ae01f6.jpg","nickname":"Kevin.zhang🌏","note":"","ucode":"5C52AE51538906","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215593,"discussion_content":"就是cpp虚函数的多态特性支持了该原则。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585359998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161276,"user_name":"Yayu","can_delete":false,"product_type":"c1","uid":1058015,"ip_address":"","ucode":"5E7842458D8229","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/df/645f8087.jpg","comment_is_top":false,"comment_ctime":1576163724,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5871131020","product_id":100039001,"comment_content":"关于『里氏代换原则』<br><br>这个世界上如果没有继承，就不会有里氏代换原则。该原则本质是想用设计规范来约束可能出现的恶劣结果，而这个恶劣结果源于语言层面的劣质特性。 ","like_count":1},{"had_liked":false,"id":160960,"user_name":"Zhe_Pu","can_delete":false,"product_type":"c1","uid":1755640,"ip_address":"","ucode":"C50476D91EC367","user_header":"https://static001.geekbang.org/account/avatar/00/1a/c9/f8/5e6fa8b5.jpg","comment_is_top":false,"comment_ctime":1576070134,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5871037430","product_id":100039001,"comment_content":"里式替换原则保证子类的实现不超过父类的接口定义规范，只是对功能的扩展，而不是对功能的修改，满足”对扩展开发，修改关闭“。同时在父类定义的框架下，子类虽然可以扩展，但也不能超过父类定义的范围，也在一定基础上满足了单一设计原则。","like_count":1},{"had_liked":false,"id":160914,"user_name":"阿冰777","can_delete":false,"product_type":"c1","uid":1373893,"ip_address":"","ucode":"F365EB44F971F3","user_header":"https://static001.geekbang.org/account/avatar/00/14/f6/c5/6329ddcc.jpg","comment_is_top":false,"comment_ctime":1576059898,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5871027194","product_id":100039001,"comment_content":"里氏替换原则.我觉得目的就是为了防止以后扩充功能的时候,对原先的父类造成了影响.当子类复写父类的功能,要保证你复写的时候,函数的行为是和原先一样的,这样就不会对原有的功能造成破坏.其实就是理解按协议编程,什么是按协议编程?我们对一个类的函数&#47;行为 进行规定,他有前置条件,后置条件,和内部不变式.如果子类复写了他,那么必须保证前置条件不会增强,后置条件不会减弱,内部不定式不变.什么是前置条件, 个人理解就是对函数输入的约束,后置条件就是对函数返回的约束,内部不定式可以理解为断言,就是对内部属性进行断言,复写的时候断言依旧全部通过.所以我觉得可以用测试用例来保证里氏替换原则,找到前置和后置的零界点,同时在内部增加断言.","like_count":1},{"had_liked":false,"id":160726,"user_name":"thomas","can_delete":false,"product_type":"c1","uid":1341964,"ip_address":"","ucode":"88440A9C773832","user_header":"https://static001.geekbang.org/account/avatar/00/14/7a/0c/5abd1cf9.jpg","comment_is_top":false,"comment_ctime":1576026174,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5870993470","product_id":100039001,"comment_content":"一个词说里氏替换原则就是：合约。子类要遵守父类设定的合约，也就是设计的初衷。子类改变逻辑思维边界是父类声明的合约。","like_count":1,"discussions":[{"author":{"id":1738326,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","nickname":"守拙","note":"","ucode":"F594B2DA3F6D4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79077,"discussion_content":"同意这位朋友的理解。\n\n补充一句：LSP一定意义上的约束了多态的实现，从而避免滥用多态导致的灾难性后果。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576053618,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160700,"user_name":"狼的诱惑","can_delete":false,"product_type":"c1","uid":1257043,"ip_address":"","ucode":"AE89DFC5963C42","user_header":"https://static001.geekbang.org/account/avatar/00/13/2e/53/bf62683f.jpg","comment_is_top":false,"comment_ctime":1576023816,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5870991112","product_id":100039001,"comment_content":"多态是JAVA语法，里氏替换是设计思路和规范；<br>里氏替换是在多态语法的基础上实现的，在不改变函数原有逻辑的基础上对函数功能的一种增强<br>老师讲的很好","like_count":1,"discussions":[{"author":{"id":1429627,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJN64OCUT0Jp0h2Wiau9Os0o1WbwUeoq2QL0U2vZpib8ozPxo0XDiaPM9xcKfbkoBL24ztEHelxPIMVg/132","nickname":"Kevin","note":"","ucode":"9DFFD6E3960CF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84009,"discussion_content":"你这个多态是java语法就显得很业余。  多态是面向对象的思想，java只是一种面向对象编程语言。 ","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576480539,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160672,"user_name":"高源","can_delete":false,"product_type":"c1","uid":1048887,"ip_address":"","ucode":"751B41FD38EF7D","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/37/12e4c9c9.jpg","comment_is_top":false,"comment_ctime":1576015395,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5870982691","product_id":100039001,"comment_content":"听王老师讲的很好理解😊书上的比较绕","like_count":1},{"had_liked":false,"id":359995,"user_name":"Nio","can_delete":false,"product_type":"c1","uid":1529642,"ip_address":"广东","ucode":"A1B8D3C01FB937","user_header":"https://static001.geekbang.org/account/avatar/00/17/57/2a/c6c95f37.jpg","comment_is_top":false,"comment_ctime":1666107281,"is_pvip":true,"discussion_count":0,"race_medal":4,"score":"1666107281","product_id":100039001,"comment_content":"青出于蓝而胜于蓝","like_count":0},{"had_liked":false,"id":359967,"user_name":"逐梦","can_delete":false,"product_type":"c1","uid":2124158,"ip_address":"上海","ucode":"682702AA87AAE7","user_header":"https://static001.geekbang.org/account/avatar/00/20/69/7e/6b94f44b.jpg","comment_is_top":false,"comment_ctime":1666092654,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1666092654","product_id":100039001,"comment_content":"感觉里氏替换主要是以方便阅读为基础，方便维护为辅助。因为子类若不按父类的定义进行扩展补充，就会使别人难以读懂代码逻辑关系，从而使维护变的困难。","like_count":0},{"had_liked":false,"id":358307,"user_name":"Geek_5e38c0","can_delete":false,"product_type":"c1","uid":3180236,"ip_address":"山东","ucode":"C714F0DB9FF9A4","user_header":"","comment_is_top":false,"comment_ctime":1664183766,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664183766","product_id":100039001,"comment_content":"这是对多态的增强吧，保持代码不违背LSP也是让代码保持更高可维护性的一种方式","like_count":0},{"had_liked":false,"id":356971,"user_name":"音为","can_delete":false,"product_type":"c1","uid":1313115,"ip_address":"北京","ucode":"D78E4CBCE6BF45","user_header":"https://static001.geekbang.org/account/avatar/00/14/09/5b/e9ee3b41.jpg","comment_is_top":false,"comment_ctime":1662767416,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662767416","product_id":100039001,"comment_content":"里氏替换原则本质上是对扩展开放，修改封闭的父子关系的具体实现","like_count":0},{"had_liked":false,"id":353194,"user_name":"王政","can_delete":false,"product_type":"c1","uid":2297381,"ip_address":"湖南","ucode":"A7DCA909FC8A38","user_header":"https://static001.geekbang.org/account/avatar/00/23/0e/25/aad87c07.jpg","comment_is_top":false,"comment_ctime":1659250903,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1659250903","product_id":100039001,"comment_content":"里氏替换，是模块化思维的一种体现，对于一个模块的开发维护者而言，当外界对于该模块的输入输出确定下来之后，要确保自己在模块内部的一切行为都符合外部对该模块的预期，任何修改都是仅仅对模块内部生效的。确保别人对我们的预期不变，赢得外部世界的信任（哲学起来了。","like_count":0},{"had_liked":false,"id":351125,"user_name":"李建军","can_delete":false,"product_type":"c1","uid":3041498,"ip_address":"","ucode":"599DD628C9A183","user_header":"","comment_is_top":false,"comment_ctime":1657536044,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657536044","product_id":100039001,"comment_content":"多态是java语言设计中的一种语言技术，而里式替换确实从业务层面去在多态的基础上做约定。我理解的对吗？","like_count":0},{"had_liked":false,"id":349412,"user_name":"时光流逝x","can_delete":false,"product_type":"c1","uid":1695455,"ip_address":"","ucode":"D7334E717D9ED0","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqUMEsVYklTc7akT2e6pfytu4jTQ88EVe1H6L2eHdXC6G8sbKCvfrnSDUIRq229M2Wt419LX2q8SQ/132","comment_is_top":false,"comment_ctime":1655956278,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655956278","product_id":100039001,"comment_content":"我对里氏替换原则的理解是子类可以对父类的功能做增强，但是不能改变已应用的逻辑，想想实际开发中，如果有一个父类已经完成了功能，系统正常运行中，但是由于后续需要增强部分功能而设计了子类去替换并且没有保留父类功能的原有效果那么系统大概会乱套吧。","like_count":0},{"had_liked":false,"id":348797,"user_name":"Geek_624df5","can_delete":false,"product_type":"c1","uid":1397370,"ip_address":"","ucode":"3C6801F9B7475D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJuAPSxrfe7zwKQlqu3I1iaWkUc0hDUBKdVUpSbqnw7actcfrfia279zLfKEycYccYR4HICrPiaNCN5Q/132","comment_is_top":false,"comment_ctime":1655417949,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655417949","product_id":100039001,"comment_content":"里氏替换是对面向对象多态特性应用过程的一个规范，如果我们的代码遵循面对接口编程，那接口与接口之间的协作都是通过接口的描述来进行的，如果在实现或继承这些接口的时候，没有完全按照接口的描述来提供行为，那就会发生欺骗，调用方在使用你的接口的时候就很容易出错。接口与接口间的信任就不存在了","like_count":0},{"had_liked":false,"id":348706,"user_name":"JLOMG","can_delete":false,"product_type":"c1","uid":2984369,"ip_address":"","ucode":"17EB1366167299","user_header":"https://static001.geekbang.org/account/avatar/00/2d/89/b1/6444e86b.jpg","comment_is_top":false,"comment_ctime":1655336007,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655336007","product_id":100039001,"comment_content":"里氏替换原则是子类和父类之间的契约，要求子类完全按照父类的行为规范设计，可以改变内部逻辑但要求最终结果不可以与父类结果相反","like_count":0},{"had_liked":false,"id":348366,"user_name":"ACT","can_delete":false,"product_type":"c1","uid":2600235,"ip_address":"","ucode":"8E5747D75045A7","user_header":"https://static001.geekbang.org/account/avatar/00/27/ad/2b/46b4a196.jpg","comment_is_top":false,"comment_ctime":1655023961,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655023961","product_id":100039001,"comment_content":"里氏替换原则就是在按照父类的约定来进行实现，其中可以修改函数的逻辑等，但是修改后的子类不能违背LSP的几个方面，如函数的实现，父类的输入输出 异常抛出，父类的一些特殊情况等，就是父类所有满足的情况，子类都要满足，不能出现父类可以，而子类不可以的情况，这种可以用父类的单元测试来尝试测试！！","like_count":0},{"had_liked":false,"id":347338,"user_name":"邓嘉文","can_delete":false,"product_type":"c1","uid":2332845,"ip_address":"","ucode":"FCEDFABFB48055","user_header":"https://static001.geekbang.org/account/avatar/00/23/98/ad/f9d755f2.jpg","comment_is_top":false,"comment_ctime":1653960740,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653960740","product_id":100039001,"comment_content":"之类重写父类方法改变了函数定义的功能，输入，输出，异常等约定","like_count":0},{"had_liked":false,"id":344734,"user_name":"冯仁彬","can_delete":false,"product_type":"c1","uid":2960877,"ip_address":"","ucode":"6E5CA08BC6366B","user_header":"","comment_is_top":false,"comment_ctime":1651742140,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651742140","product_id":100039001,"comment_content":"里氏替换原则是基于多态来实现的，但是在实现的子类代码逻辑中不能出现与父类输入、输出、逻辑和语义的不一致。<br><br>里氏替换原则的意义是让我们在不破坏原有代码逻辑的基础上进行功能扩展、增强。","like_count":0},{"had_liked":false,"id":344145,"user_name":"oracle98","can_delete":false,"product_type":"c1","uid":2302762,"ip_address":"","ucode":"F5A2795B46E27B","user_header":"","comment_is_top":false,"comment_ctime":1651300982,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651300982","product_id":100039001,"comment_content":"子类完美继承父类的设计初衷。精彩！","like_count":0},{"had_liked":false,"id":341622,"user_name":"Geek_441001","can_delete":false,"product_type":"c1","uid":2421724,"ip_address":"","ucode":"159C7D1965FDD9","user_header":"","comment_is_top":false,"comment_ctime":1649738234,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649738234","product_id":100039001,"comment_content":"多态是面向对象编程语言提供的一种特性，只要求子类中重写的方法输入输出相同，不关心内部具体实现。而里氏替换原则，则是针对子类方法如何重写的一种约束。","like_count":0},{"had_liked":false,"id":338882,"user_name":"顺势而为","can_delete":false,"product_type":"c1","uid":2757858,"ip_address":"","ucode":"FE7D688D24823E","user_header":"https://static001.geekbang.org/account/avatar/00/2a/14/e2/f6f1627c.jpg","comment_is_top":false,"comment_ctime":1647770986,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647770986","product_id":100039001,"comment_content":"1.里氏替换原则的目的是为了解决设计，也就是约定我们如何实现代码的设计的。<br>2.有了他，你可以重写父类，但是不要违背父类的基本，否则你自己和父类脱离关系，自己搞一个class发展吧，别污染。<br>3.要明白，多态和里氏替换原则是区分开的。<br>多态就是你可以做很多事情，和父类无关。<br>里氏替换原则就是，你做的事情，不能违背父类。","like_count":0},{"had_liked":false,"id":338109,"user_name":"鹏","can_delete":false,"product_type":"c1","uid":1528796,"ip_address":"","ucode":"5E0F60BBA91129","user_header":"https://static001.geekbang.org/account/avatar/00/17/53/dc/3a16bb1e.jpg","comment_is_top":false,"comment_ctime":1647306180,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647306180","product_id":100039001,"comment_content":"要符合顶层协议","like_count":0},{"had_liked":false,"id":335612,"user_name":"乌木玉","can_delete":false,"product_type":"c1","uid":1243753,"ip_address":"","ucode":"9B5220D073538C","user_header":"https://static001.geekbang.org/account/avatar/00/12/fa/69/352fb079.jpg","comment_is_top":false,"comment_ctime":1645603987,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645603987","product_id":100039001,"comment_content":"关于多态以及LSP，个人的一些思考：<br>多态是面向对象编程的一大特性，开发者可以利用多态，随意继承和改写父类方法，以适应多变的业务需求。如果不加以约束，会出现歪曲父类方法约定，让人不知所云，导致容易用错或无法使用的情况。 <br>LSP则在这种背景下，加以约束，让开发者在一开始设计时，就能了解父类的真实目的和边界，从而更合理的设计子类，当不适合设计为继承关系的，可以优先考虑组合关系，将逻辑剥离；这样做，更印证了单一原则。","like_count":0},{"had_liked":false,"id":334437,"user_name":"走向200","can_delete":false,"product_type":"c1","uid":1730554,"ip_address":"","ucode":"B197202CB63A6D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/9qx9Zwr6vIZJch6a5VUgwBLlZ0bfuLQ559keeekPF8RBBFZ50Im6AXFHXnSnlgfAdwzCKhGPbYv3pNfPQOoJiaQ/132","comment_is_top":false,"comment_ctime":1644935385,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644935385","product_id":100039001,"comment_content":"感觉里氏替换原则就是“父债子还”的意思，而且一分都不能少","like_count":0},{"had_liked":false,"id":334019,"user_name":"it to learn","can_delete":false,"product_type":"c1","uid":2407402,"ip_address":"","ucode":"B1D3316042BEAD","user_header":"https://static001.geekbang.org/account/avatar/00/24/bb/ea/160e4c38.jpg","comment_is_top":false,"comment_ctime":1644674628,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644674628","product_id":100039001,"comment_content":"里氏替换原则指的是子类必须“兼容”父类的逻辑，不能因为重写父类方法而是父类方法逻辑缺损丢失吗？","like_count":0},{"had_liked":false,"id":333899,"user_name":"跳跳","can_delete":false,"product_type":"c1","uid":2771298,"ip_address":"","ucode":"8999B46CF6D197","user_header":"https://static001.geekbang.org/account/avatar/00/2a/49/62/db480ab6.jpg","comment_is_top":false,"comment_ctime":1644573658,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1644573658","product_id":100039001,"comment_content":"感觉这是个在重构代码时，需要遵守的原则。","like_count":0},{"had_liked":false,"id":333528,"user_name":"斑马线","can_delete":false,"product_type":"c1","uid":2805127,"ip_address":"","ucode":"32232868BAE53C","user_header":"https://static001.geekbang.org/account/avatar/00/2a/cd/87/d06540db.jpg","comment_is_top":false,"comment_ctime":1644394359,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644394359","product_id":100039001,"comment_content":"如果子类确实会违反父类的约定，是不是表明父类设计得不合理？一般这种场景如何处理？放弃使用继承吗？","like_count":0},{"had_liked":false,"id":332753,"user_name":"vinci","can_delete":false,"product_type":"c1","uid":2050522,"ip_address":"","ucode":"F7A0B618F36812","user_header":"https://static001.geekbang.org/account/avatar/00/1f/49/da/d284b8d3.jpg","comment_is_top":false,"comment_ctime":1643549154,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643549154","product_id":100039001,"comment_content":"如果父类有一个方法大部分子类都需要用到，但是有一个子类不应该有这个方法，那么应该如何实现呢?<br>是应该严格遵守lsp，把这个方法的定义分别放到其他子类中；还是应该在把这个方法放在父类，在不需要这个方法的子类中，对这个方法进行诸如抛出错误之类的禁用手段呢?","like_count":0},{"had_liked":false,"id":328691,"user_name":"邵亮","can_delete":false,"product_type":"c1","uid":1810890,"ip_address":"","ucode":"8407C3FDD11C0E","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a1/ca/aae116f5.jpg","comment_is_top":false,"comment_ctime":1640844070,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1640844070","product_id":100039001,"comment_content":"指导程序开发，在这基础上做增强","like_count":0},{"had_liked":false,"id":327503,"user_name":"程伟","can_delete":false,"product_type":"c1","uid":2398017,"ip_address":"","ucode":"A1EF868FD7D4A6","user_header":"https://static001.geekbang.org/account/avatar/00/24/97/41/63115c89.jpg","comment_is_top":false,"comment_ctime":1640153684,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640153684","product_id":100039001,"comment_content":"里氏替换需要借助多态来实现，但是用到多态的地方不一定是里氏替换。","like_count":0},{"had_liked":false,"id":327161,"user_name":"孙大龙Lemon","can_delete":false,"product_type":"c1","uid":1028041,"ip_address":"","ucode":"040F363A07FC64","user_header":"https://static001.geekbang.org/account/avatar/00/0f/af/c9/9db8fc5d.jpg","comment_is_top":false,"comment_ctime":1639964464,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1639964464","product_id":100039001,"comment_content":"如果不通过lsp对集成关系做约束，那么继承关系一旦超过2层，基本不可维护，使用者需要知道每一层累具体的实现，违背了继承的初衷","like_count":0},{"had_liked":false,"id":326807,"user_name":"江谢木","can_delete":false,"product_type":"c1","uid":1563403,"ip_address":"","ucode":"E1B1B0F0F03D41","user_header":"https://static001.geekbang.org/account/avatar/00/17/db/0b/f0ded153.jpg","comment_is_top":false,"comment_ctime":1639706866,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639706866","product_id":100039001,"comment_content":"既然是继承就说明两则是相关的，相关的东西一般是扩展&#47;增强实现，如果是重写就说明是不相关的，不相关的应该重新定义类而不是继承。所以LSP的意义在于保持设计初衷的统一性，代码的易读性。","like_count":0},{"had_liked":false,"id":323651,"user_name":"YX","can_delete":false,"product_type":"c1","uid":2636178,"ip_address":"","ucode":"CC108CCE845EAE","user_header":"https://static001.geekbang.org/account/avatar/00/28/39/92/88ed94f2.jpg","comment_is_top":false,"comment_ctime":1638070067,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1638070067","product_id":100039001,"comment_content":"不以规矩，不成方圆<br>父母在，不远游","like_count":0},{"had_liked":false,"id":323040,"user_name":"天亮前说晚安","can_delete":false,"product_type":"c1","uid":1541014,"ip_address":"","ucode":"1D82EE562A7C71","user_header":"https://static001.geekbang.org/account/avatar/00/17/83/96/73ff13a0.jpg","comment_is_top":false,"comment_ctime":1637715152,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637715152","product_id":100039001,"comment_content":"多态是语言的特性，理式变换是编程的原则。多态可以用于实现这个原则。协议就是输入输出和异常；强类型语言中，输入输出都很容易遵守，但是异常可能很多人忽视的一个方面。本人以前也没理解异常这个输出。","like_count":0},{"had_liked":false,"id":321121,"user_name":"二小","can_delete":false,"product_type":"c1","uid":1593919,"ip_address":"","ucode":"5377CB552237B2","user_header":"https://static001.geekbang.org/account/avatar/00/18/52/3f/c8b40efe.jpg","comment_is_top":false,"comment_ctime":1636683945,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636683945","product_id":100039001,"comment_content":"还是为了代码的扩展性，当利用多态进行扩展的时候，我们新写的功能如果违背了LSP，那么就有可能在某个替换点出现异常，如果替换点少还好，如果多的话会使替换变的繁琐","like_count":0},{"had_liked":false,"id":320284,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1636201227,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636201227","product_id":100039001,"comment_content":"思考题，个人理解：<br>里氏替换原则存在的意义有两条：<br>第一，程序移植，由于里氏替换原则要求子类的实现不能违背父类要实现的功能，也不能违背父类对输入、输出、异常的约定，因此，在把一个应用从一个平台移植到另一个平台时，把要移植的类看成是父类，然后重新构造它的一个子类，对类中的某些功能，可以应用里氏替换设计原则结合新平台的特征覆盖其原有功能，重构后的功能、输入、输出及异常捕捉都和原有父类中的功能保持一致，从而达到跨平台应用的目的。<br><br>第二，程序重构和优化，如果类中的某些功能实现较复杂，代码混乱且没有按规范书写，如果要对这些代码进行重构和优化，那就需要读懂原有代码的业务逻辑和算法，对于书写不规范，可读性差的代码这是一件相当困难的事；而如果原有的这个功能有较完整的功能说明或详细设计，那就可以应用里氏替换原则，把原有的类当做是父类，重新构造其的一个子类，根据功能说明，重新实现需要优化或重构的那块功能，这样就不需要去读原有的代码就可达到代码重构的目的。","like_count":0},{"had_liked":false,"id":319699,"user_name":"Geek_jerry","can_delete":false,"product_type":"c1","uid":1736148,"ip_address":"","ucode":"684923936D7849","user_header":"","comment_is_top":false,"comment_ctime":1635915075,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635915075","product_id":100039001,"comment_content":"老师，请问下为什么要遵守这个原则，不遵守这个原则会造成哪些问题？","like_count":0},{"had_liked":false,"id":316611,"user_name":"Zeroassetsor","can_delete":false,"product_type":"c1","uid":1042221,"ip_address":"","ucode":"151747E0300D2D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e7/2d/e71299b9.jpg","comment_is_top":false,"comment_ctime":1634451072,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634451072","product_id":100039001,"comment_content":"核心要义就是按照父类的契约设计子类，改进扩展父类的方法，而不破坏原有逻辑，使程序顺利运行。","like_count":0},{"had_liked":false,"id":316244,"user_name":"千锤百炼领悟之极限","can_delete":false,"product_type":"c1","uid":1744257,"ip_address":"","ucode":"224B5CF2101716","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9d/81/d748b7eb.jpg","comment_is_top":false,"comment_ctime":1634218003,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634218003","product_id":100039001,"comment_content":"里氏替换原则的思想是desgin by contract，用来指导继承关系中子类的设计，是一种设计原则。多态是面向对象编程的语法，是代码实现的思想。","like_count":0},{"had_liked":false,"id":315632,"user_name":"王智洋","can_delete":false,"product_type":"c1","uid":1666517,"ip_address":"","ucode":"B38934EA504663","user_header":"https://static001.geekbang.org/account/avatar/00/19/6d/d5/81e72368.jpg","comment_is_top":false,"comment_ctime":1633931271,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633931271","product_id":100039001,"comment_content":"进行扩展的同时不会破坏原有的业务逻辑","like_count":0},{"had_liked":false,"id":313443,"user_name":" 你的名字","can_delete":false,"product_type":"c1","uid":1514987,"ip_address":"","ucode":"FAFE636695004D","user_header":"https://static001.geekbang.org/account/avatar/00/17/1d/eb/1b39d28e.jpg","comment_is_top":false,"comment_ctime":1632445036,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632445036","product_id":100039001,"comment_content":"多态是面相对象中的一种语法，替换原则里氏是一种设计原则","like_count":0},{"had_liked":false,"id":313356,"user_name":" 你的名字","can_delete":false,"product_type":"c1","uid":1514987,"ip_address":"","ucode":"FAFE636695004D","user_header":"https://static001.geekbang.org/account/avatar/00/17/1d/eb/1b39d28e.jpg","comment_is_top":false,"comment_ctime":1632387268,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632387268","product_id":100039001,"comment_content":"里氏替换原则：子类的设计要在父类被替换的时候，保证不改变原有逻辑并且不破坏原有程序的正确性的情况下进行","like_count":0},{"had_liked":false,"id":312644,"user_name":"charmsongo","can_delete":false,"product_type":"c1","uid":1609051,"ip_address":"","ucode":"4FBEE716E93A1A","user_header":"https://static001.geekbang.org/account/avatar/00/18/8d/5b/383a49e4.jpg","comment_is_top":false,"comment_ctime":1631925066,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631925066","product_id":100039001,"comment_content":"多态是面向对象的一种语法，里式替换原则是一种设计原则，父类方法的约定，子类不能破坏，约定包括 方法生命的实际作用，入参、出参、异常处理和特殊处理的声明，子类都不能破坏。<br><br>个人感觉多态范围更广，里式替换原则只是基于该语法上的一种设计方案","like_count":0},{"had_liked":false,"id":309088,"user_name":"小王在努力","can_delete":false,"product_type":"c1","uid":2733574,"ip_address":"","ucode":"A324EF87198905","user_header":"https://static001.geekbang.org/account/avatar/00/29/b6/06/cd1eaa49.jpg","comment_is_top":false,"comment_ctime":1629939347,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629939347","product_id":100039001,"comment_content":"里氏替换原则中针对父类已实现的方法，子类是不应该进行重写吧，子类可以可以重写父类的抽象方法，不是这样吗？","like_count":0},{"had_liked":false,"id":308858,"user_name":"小马哥","can_delete":false,"product_type":"c1","uid":1358045,"ip_address":"","ucode":"B2C0FF38F8C9BC","user_header":"https://static001.geekbang.org/account/avatar/00/14/b8/dd/37726c34.jpg","comment_is_top":false,"comment_ctime":1629826553,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629826553","product_id":100039001,"comment_content":"里式替换原则存在的意义: 指导子类的设计, 即按照约定来设计, 做到在功能上设计出来的子类可以替换掉父类, 而不是违背了父类的意图.","like_count":0},{"had_liked":false,"id":307828,"user_name":"You","can_delete":false,"product_type":"c1","uid":2662969,"ip_address":"","ucode":"ACBDB82E9B39C4","user_header":"https://static001.geekbang.org/account/avatar/00/28/a2/39/3ee6f996.jpg","comment_is_top":false,"comment_ctime":1629274403,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629274403","product_id":100039001,"comment_content":"个人觉得：LSP主要起到的作用是维护“接口”的稳定性、提高可扩展性、提高在不改变父类实现，违背开闭原则的前提下还能做到提高性能。维护“接口”的稳定性是子类实现和父类实现的“协议”相同，直接点说就是子类可以完全替代父类执行。在没有实现子类之前，外来接口调用父类方法可以完成任务，实现子类之后，外来接口就可以直接调用高效的子类方式代替父类执行。相比直接修改父类代码，违背开闭原则的方式来提高性能要做得更好，并且保持协议不变的情况下做到版本迭代优化。","like_count":0},{"had_liked":false,"id":307188,"user_name":"易飞","can_delete":false,"product_type":"c1","uid":2630424,"ip_address":"","ucode":"32AC28754237F7","user_header":"https://static001.geekbang.org/account/avatar/00/28/23/18/4284361f.jpg","comment_is_top":false,"comment_ctime":1628926071,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628926071","product_id":100039001,"comment_content":"保证老的单元测试正常，保证结果不变","like_count":0},{"had_liked":false,"id":306704,"user_name":"Geek_b7eb88","can_delete":false,"product_type":"c1","uid":1573715,"ip_address":"","ucode":"0EB46381D9B1CB","user_header":"","comment_is_top":false,"comment_ctime":1628673126,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628673126","product_id":100039001,"comment_content":"可以大致认为里氏替换原则是为了规范继承的子类和多态的使用吗","like_count":0},{"had_liked":false,"id":304478,"user_name":"morningking","can_delete":false,"product_type":"c1","uid":1067728,"ip_address":"","ucode":"4BBCABA455941B","user_header":"https://static001.geekbang.org/account/avatar/00/10/4a/d0/d75f0c62.jpg","comment_is_top":false,"comment_ctime":1627445116,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627445116","product_id":100039001,"comment_content":"多态是面向对象编程的一种特性和语法。<br>里氏替换是面向对象编程的一个原则，指导子类如何设计而不破坏协议约束，即子类可以扩展协议，但是不能修改协议。<br>协议包括接口的型构，接口的功能&#47;异常约定。","like_count":0},{"had_liked":false,"id":304049,"user_name":"Geek_tao","can_delete":false,"product_type":"c1","uid":2659998,"ip_address":"","ucode":"CD0FADA06B0659","user_header":"","comment_is_top":false,"comment_ctime":1627207099,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627207099","product_id":100039001,"comment_content":"可是有时候父类实现的是一个默认排序比如按时间， 方便扩展， 有多个子类， 不同的子类实现不同的排序方式， 这是否违反了里式原则","like_count":0},{"had_liked":false,"id":303603,"user_name":"米豆丸","can_delete":false,"product_type":"c1","uid":2042568,"ip_address":"","ucode":"CE99FE3A1EBCAF","user_header":"https://static001.geekbang.org/account/avatar/00/1f/2a/c8/dc4e314e.jpg","comment_is_top":false,"comment_ctime":1626870360,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626870360","product_id":100039001,"comment_content":"爹是有原则的，孩子们在原则范围内自由发挥成长","like_count":0},{"had_liked":false,"id":303137,"user_name":"九尾","can_delete":false,"product_type":"c1","uid":2429969,"ip_address":"","ucode":"3E6BDF7B9C78FC","user_header":"https://static001.geekbang.org/account/avatar/00/25/14/11/f1220081.jpg","comment_is_top":false,"comment_ctime":1626607727,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626607727","product_id":100039001,"comment_content":"突然想起之前修改代码的过于随意了，难怪我在添加函数参数之后发现，过不了多久类就会变得难以维护，导致了一大堆的拷贝代码","like_count":0},{"had_liked":false,"id":300897,"user_name":"爱上我们的微笑","can_delete":false,"product_type":"c1","uid":1459863,"ip_address":"","ucode":"40CDB7AB0991CE","user_header":"https://static001.geekbang.org/account/avatar/00/16/46/97/ddd4b05f.jpg","comment_is_top":false,"comment_ctime":1625445594,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625445594","product_id":100039001,"comment_content":"LSP核心为“Design By Contract”。子类的重写函数要求协议输入，输出，异常处理都为一致。该协议主要指导子类如何设计实现。<br>","like_count":0},{"had_liked":false,"id":300780,"user_name":"布拉姆","can_delete":false,"product_type":"c1","uid":1311125,"ip_address":"","ucode":"479FF27D73BCAD","user_header":"https://static001.geekbang.org/account/avatar/00/14/01/95/fd09e8a8.jpg","comment_is_top":false,"comment_ctime":1625385029,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625385029","product_id":100039001,"comment_content":"LSP: 子类相比父类，功能只能细化、增强而不能修改。","like_count":0},{"had_liked":false,"id":298866,"user_name":"geek_666888","can_delete":false,"product_type":"c1","uid":2024635,"ip_address":"","ucode":"3E348CCE186ACF","user_header":"","comment_is_top":false,"comment_ctime":1624350179,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624350179","product_id":100039001,"comment_content":"本质就是要“萧规曹随”“祖制不可改”。 而多态可以只是嘴上“遵循祖制”。","like_count":0},{"had_liked":false,"id":298049,"user_name":"昵称C","can_delete":false,"product_type":"c1","uid":1234963,"ip_address":"","ucode":"1BB2D537942DC2","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/13/082013bc.jpg","comment_is_top":false,"comment_ctime":1623896753,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623896753","product_id":100039001,"comment_content":"里氏替换原则存在的意义:<br>里氏替换原则是多态特性的践行原则，可以保证在写出扩展性好的代码同时，也保证代码功能的一致性和稳定性；","like_count":0},{"had_liked":false,"id":297053,"user_name":"小万叔叔","can_delete":false,"product_type":"c1","uid":1448768,"ip_address":"","ucode":"41966A18867C63","user_header":"https://static001.geekbang.org/account/avatar/00/16/1b/40/68e59e53.jpg","comment_is_top":false,"comment_ctime":1623291766,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623291766","product_id":100039001,"comment_content":"里氏替换是建立在继承和多态的基础上，但却对继承和多态加了一个限制；保证了父类行为不被破坏，父类能诠释子类的作用，也增强了父类的指导意义。","like_count":0},{"had_liked":false,"id":296962,"user_name":"zart","can_delete":false,"product_type":"c1","uid":1148637,"ip_address":"","ucode":"E32677C0FD4421","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eomCrCRrLAWib0gMI2L2NbicMummlxOY6nVmphsDO0J3xx7OygNd8wJicc88RbNoHrcuXBsKLtCMvgFQ/132","comment_is_top":false,"comment_ctime":1623241416,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1623241416","product_id":100039001,"comment_content":"里式替换存在的意义：向下兼容","like_count":0},{"had_liked":false,"id":296290,"user_name":"李金鹏","can_delete":false,"product_type":"c1","uid":1445362,"ip_address":"","ucode":"8FCCA5B8BD8DDD","user_header":"https://static001.geekbang.org/account/avatar/00/16/0d/f2/3865fe28.jpg","comment_is_top":false,"comment_ctime":1622884457,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622884457","product_id":100039001,"comment_content":"我觉得里式替换原则存在的意义是，指导我们在编写子类时，不改变父类的原有功能。很多一开始设计很好的系统，最后变成祖传的烂代码，很多就是因为没有遵守里式替换原则","like_count":0},{"had_liked":false,"id":296094,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1622741369,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1622741369","product_id":100039001,"comment_content":"lsp，主要是用来指导设计子类的原则。","like_count":0},{"had_liked":false,"id":295810,"user_name":"奋斗","can_delete":false,"product_type":"c1","uid":2149661,"ip_address":"","ucode":"E9D191295B37D9","user_header":"https://static001.geekbang.org/account/avatar/00/20/cd/1d/64f014fe.jpg","comment_is_top":false,"comment_ctime":1622605144,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622605144","product_id":100039001,"comment_content":"如果 在SecurityTransporter 中不对入参进行必填校验，是不是业务上会出现问题呢，甚至都有可能调不通，这样的问题怎么权衡呢","like_count":0},{"had_liked":false,"id":295066,"user_name":"神垂死","can_delete":false,"product_type":"c1","uid":1016334,"ip_address":"","ucode":"EE924E8E0A6814","user_header":"https://static001.geekbang.org/account/avatar/00/0f/82/0e/9c42e6f9.jpg","comment_is_top":false,"comment_ctime":1622203454,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622203454","product_id":100039001,"comment_content":"如果子类满足里式替换的话，可以把父类的引用直接删掉，全部replace子类吗？这样就算重构了吧","like_count":0},{"had_liked":false,"id":294870,"user_name":"泰深森","can_delete":false,"product_type":"c1","uid":1401258,"ip_address":"","ucode":"A444D9F5C8B989","user_header":"https://static001.geekbang.org/account/avatar/00/15/61/aa/85e0592a.jpg","comment_is_top":false,"comment_ctime":1622118522,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622118522","product_id":100039001,"comment_content":"一句话，子类要能精准复刻父类行为，并且功能上有所扩展，","like_count":0},{"had_liked":false,"id":294321,"user_name":"Geek_5b7d28","can_delete":false,"product_type":"c1","uid":2057476,"ip_address":"","ucode":"BAA1CDD539C369","user_header":"","comment_is_top":false,"comment_ctime":1621899064,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621899064","product_id":100039001,"comment_content":"多态是告诉你可以这么用，里氏替换原则是告诉你怎么用。","like_count":0},{"had_liked":false,"id":293706,"user_name":"黄金果","can_delete":false,"product_type":"c1","uid":1456586,"ip_address":"","ucode":"329811FF99F4B8","user_header":"https://static001.geekbang.org/account/avatar/00/16/39/ca/cdc58834.jpg","comment_is_top":false,"comment_ctime":1621500517,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621500517","product_id":100039001,"comment_content":"里氏替换原则存在的意义是否是因为, 当使用多态的时候, 子类表达为父类, 如果子类违反了里氏替换原则(例如 : 子类违背父类对输入、输出、异常的约定), 则需要对各个子类做不同的处理, 就失去了多态的意义","like_count":0},{"had_liked":false,"id":290614,"user_name":"MrVito","can_delete":false,"product_type":"c1","uid":1252169,"ip_address":"","ucode":"716FF6F8871706","user_header":"https://static001.geekbang.org/account/avatar/00/13/1b/49/ddefc656.jpg","comment_is_top":false,"comment_ctime":1619659722,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619659722","product_id":100039001,"comment_content":"改进已实现，不能改动已实现的","like_count":0},{"had_liked":false,"id":290556,"user_name":"k先生","can_delete":false,"product_type":"c1","uid":1221532,"ip_address":"","ucode":"76D292DC62B52D","user_header":"https://static001.geekbang.org/account/avatar/00/12/a3/9c/8a14b7db.jpg","comment_is_top":false,"comment_ctime":1619616470,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619616470","product_id":100039001,"comment_content":"那么问题来了，必须遵守这个规则吗？或者说好的设计模式必须遵守吗？","like_count":0},{"had_liked":false,"id":290529,"user_name":"Geek_56a189","can_delete":false,"product_type":"c1","uid":2586543,"ip_address":"","ucode":"F3258B958DF2FB","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/KQyib1vpanF1CBYpBFadYdHPYlnv6TNtkqUMW6Xk0HoRNs5CXiaWQFguWGQicU34ykib9qX2yv3SmSHhHqia4SQ5icIg/132","comment_is_top":false,"comment_ctime":1619601317,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619601317","product_id":100039001,"comment_content":"个人理解里式替换就像我们想要换手机更新换代以一样，一般新出的手机（子类）都要比旧手机（父类）功能要多，速度要好，谁也不像换手机之后原有的功能不好使了，或者发短信功能变成打电话了之类的","like_count":0},{"had_liked":false,"id":288390,"user_name":"sailor","can_delete":false,"product_type":"c1","uid":1592031,"ip_address":"","ucode":"3B301A4BE9FB11","user_header":"https://static001.geekbang.org/account/avatar/00/18/4a/df/a3ee01da.jpg","comment_is_top":false,"comment_ctime":1618451927,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618451927","product_id":100039001,"comment_content":"LSP: 里氏替换原则，子类必须满足：<br>1.  与父类的功能实现一致<br>2. 与父类的协议约定一致（输入，输出，异常，特殊限制）","like_count":0},{"had_liked":false,"id":288175,"user_name":"Jiantao","can_delete":false,"product_type":"c1","uid":1163504,"ip_address":"","ucode":"444580EC5EF109","user_header":"https://static001.geekbang.org/account/avatar/00/11/c0/f0/1aabc056.jpg","comment_is_top":false,"comment_ctime":1618330296,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618330296","product_id":100039001,"comment_content":"存在意义：在代码扩展能力上，约束子类实现，保证系统行为一致","like_count":0},{"had_liked":false,"id":287688,"user_name":"二少","can_delete":false,"product_type":"c1","uid":1442885,"ip_address":"","ucode":"190983809CD3EC","user_header":"https://static001.geekbang.org/account/avatar/00/16/04/45/0c474d47.jpg","comment_is_top":false,"comment_ctime":1618109673,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618109673","product_id":100039001,"comment_content":"个人理解里氏代换的意义在于，可以在保持使用原有父类时所要遵守的约定不变的前提下，可以灵活地替换成不同的子类。","like_count":0},{"had_liked":false,"id":285112,"user_name":"小马哥","can_delete":false,"product_type":"c1","uid":1358045,"ip_address":"","ucode":"B2C0FF38F8C9BC","user_header":"https://static001.geekbang.org/account/avatar/00/14/b8/dd/37726c34.jpg","comment_is_top":false,"comment_ctime":1616631998,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616631998","product_id":100039001,"comment_content":"一句话总结LSP与多态的区别:<br>多态的目的: 让父类或接口根据引用的子类或实现的不同, 呈现出不同的功能形态;<br>里氏代换原则的目的: 对于多态中呈现出来的功能形态, 加了经验约束(不能违背父类功能的大方向).","like_count":0},{"had_liked":false,"id":283751,"user_name":"Graham","can_delete":false,"product_type":"c1","uid":1994570,"ip_address":"","ucode":"C2545DE16EC3DD","user_header":"","comment_is_top":false,"comment_ctime":1615903987,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615903987","product_id":100039001,"comment_content":"如果一定要破坏LSP原则，要怎么弄，重新设计基类，还是怎么弄？","like_count":0},{"had_liked":false,"id":282915,"user_name":"江小田","can_delete":false,"product_type":"c1","uid":1003149,"ip_address":"","ucode":"C5197BF856E8D3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/8d/34e0f6f3.jpg","comment_is_top":false,"comment_ctime":1615461504,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615461504","product_id":100039001,"comment_content":"原则的意思是要保留父类设计的初衷。<br>意义在于，如果有一天想要把父类替换成更强大的子类的时候。那么调用方对于父类调用方法的入参、异常处理、返回值处理，都可以做到无缝对接，无需担心某个地方未处理导致的新问题。","like_count":0},{"had_liked":false,"id":282042,"user_name":"椰子","can_delete":false,"product_type":"c1","uid":1537505,"ip_address":"","ucode":"55723E3E193D8F","user_header":"https://static001.geekbang.org/account/avatar/00/17/75/e1/1a5e8eb8.jpg","comment_is_top":false,"comment_ctime":1615026144,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615026144","product_id":100039001,"comment_content":"感觉就是违背了里氏替换会导致程序出现一些很不容易发现的BUG，所以要遵循它","like_count":0},{"had_liked":false,"id":280728,"user_name":"Lanyok","can_delete":false,"product_type":"c1","uid":1016669,"ip_address":"","ucode":"FB55036166E4AE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/83/5d/1129ca22.jpg","comment_is_top":false,"comment_ctime":1614328515,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614328515","product_id":100039001,"comment_content":"里式替换原则是表达子类与分类，或实现类与接口的设计关系和替换关系。<br>设计是要考虑到 design by contract.替换时子类可以替换父类，而代码的环境不会受到影响。","like_count":0},{"had_liked":false,"id":280533,"user_name":"饭太司替可","can_delete":false,"product_type":"c1","uid":1171829,"ip_address":"","ucode":"9A47FCA16199B0","user_header":"https://static001.geekbang.org/account/avatar/00/11/e1/75/bbdf9052.jpg","comment_is_top":false,"comment_ctime":1614243656,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614243656","product_id":100039001,"comment_content":"父类中有一个 打开客厅灯 的方法，具体实现是 按一下客厅灯的开关，子类 重写了这个方法，实现是 发出声音触发客厅灯的声控开关，但是如果子类发出声音后不仅打开了客厅灯，顺便打开了厨房的灯，那就是违反了LSP原则吧？","like_count":0},{"had_liked":false,"id":280428,"user_name":"小川","can_delete":false,"product_type":"c1","uid":1242573,"ip_address":"","ucode":"D462222DDBB978","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/cd/3890be04.jpg","comment_is_top":false,"comment_ctime":1614215261,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614215261","product_id":100039001,"comment_content":"扩展性是衡量代码好坏最重要的特性之一<br><br>抽象与多态特性能很好的支持扩展性<br><br>lsp 防止多态滥用，规定了子类实现或者继承父类（多态）所需的原则","like_count":0},{"had_liked":false,"id":280241,"user_name":"Chloe","can_delete":false,"product_type":"c1","uid":1004953,"ip_address":"","ucode":"C4848ED5B35752","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/99/4bdadfd3.jpg","comment_is_top":false,"comment_ctime":1614140284,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614140284","product_id":100039001,"comment_content":"请问如果说LSP是 Design by Contract，同时interface也是定义Contract，但是我们不能说只要按照interface写class就遵循了LSP，LSP可以是在实现上违背了contract的定义，对吗？","like_count":0},{"had_liked":false,"id":280236,"user_name":"DreamHeng","can_delete":false,"product_type":"c1","uid":1599490,"ip_address":"","ucode":"5562BFD8375138","user_header":"https://static001.geekbang.org/account/avatar/00/18/68/02/2d394d89.jpg","comment_is_top":false,"comment_ctime":1614138767,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614138767","product_id":100039001,"comment_content":"LSP里氏替换原则，其实就是约定规则，子类要遵守父类的约定，在任一父类对象中，都可以被子类对象所代替","like_count":0},{"had_liked":false,"id":278944,"user_name":"曾泽浩","can_delete":false,"product_type":"c1","uid":1104601,"ip_address":"","ucode":"A7E5CF9E1571A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/da/d9/f051962f.jpg","comment_is_top":false,"comment_ctime":1613477133,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1613477133","product_id":100039001,"comment_content":"想问一个问题，子类对父类的重载是违背了里式原则吗？<br>","like_count":0,"discussions":[{"author":{"id":2042568,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/2a/c8/dc4e314e.jpg","nickname":"米豆丸","note":"","ucode":"CE99FE3A1EBCAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385072,"discussion_content":"你应该说的方法重写，按照协议走怎么会违背呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626869362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":278569,"user_name":"Geek_b7f618","can_delete":false,"product_type":"c1","uid":2400950,"ip_address":"","ucode":"8782A53CB61E15","user_header":"","comment_is_top":false,"comment_ctime":1613086285,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613086285","product_id":100039001,"comment_content":"里氏代换原则是一种设计思路，需要确保子类在接口级别上与父类保持一致的约定，包括出参入参异常等。这样才能保证使用多态时，子类的对象替代父类时能让外部调用程序天然适配。","like_count":0},{"had_liked":false,"id":276174,"user_name":"我不是黄蓉我不会武功","can_delete":false,"product_type":"c1","uid":2416157,"ip_address":"","ucode":"E4BE01B01AF1BB","user_header":"https://static001.geekbang.org/account/avatar/00/24/de/1d/c1bd26dc.jpg","comment_is_top":false,"comment_ctime":1611821661,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611821661","product_id":100039001,"comment_content":"我理解的是虽然多态是一个OOP的特性之一，里氏替换是一种指导子类的设计原则，但是多态和里氏替换还是有很强的关系，离开了多态里氏替换几乎不可能实现","like_count":0},{"had_liked":false,"id":272432,"user_name":"Gabriel","can_delete":false,"product_type":"c1","uid":1437358,"ip_address":"","ucode":"714772A93E93DC","user_header":"https://static001.geekbang.org/account/avatar/00/15/ee/ae/855b7e6e.jpg","comment_is_top":false,"comment_ctime":1610089030,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610089030","product_id":100039001,"comment_content":"在说里式替换之前：咱们先得理清楚多态，这个概念（多态是面向对象的重要特性，简单点说：“一个接口，多种实现”，指一个基类中派生出不同的子类，且每个子类的继承了同样的方法名和**同时又对父类的方法做不同的实现**，就是同一个事物表现出多种形态。<br>多态：相当于，就是父母给孩子取了一个名字，名字只是一个孩子的简称，那孩子以后干什么，怎么干都不关父母的事。<br>里式替换呢：相当于法律，法律规定的条款，给你做事的范围，你怎么做不要紧，但是你不能超出法律的限制。<br>securityTransporter.java 继承了 Transport在，要实现的都是sendRequest的方法，但是中间你要怎么做验证，都没有改变父类的初衷。","like_count":0},{"had_liked":false,"id":269487,"user_name":"江南一笑","can_delete":false,"product_type":"c1","uid":2234620,"ip_address":"","ucode":"E38938A1178827","user_header":"https://static001.geekbang.org/account/avatar/00/22/18/fc/4f92ee4e.jpg","comment_is_top":false,"comment_ctime":1608685272,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608685272","product_id":100039001,"comment_content":"从自然认知上理解子类父类的关系。比如：&quot;人&quot; 是&quot;男人&quot;、&quot;女人&quot;的父类，但 &quot;成年人&quot;就不是&quot;男人&quot;,&quot;女人&quot;的父类。 把找个逻辑关系把握住了，就抓住了liskov substitution principle. ","like_count":0},{"had_liked":false,"id":268117,"user_name":"刘建军","can_delete":false,"product_type":"c1","uid":2348590,"ip_address":"","ucode":"25210BF7BE6BA8","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/We0naYhWttpJPDoO7TCndu5w1r4PSCdo57M61Zia8khXmM8GibicDzYdXiaJXZNok7274mSfB4aEMgxyiaDY1pRba0w/132","comment_is_top":false,"comment_ctime":1608078280,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608078280","product_id":100039001,"comment_content":"感觉一直在违背这个原则，override就是为了改变行为","like_count":0},{"had_liked":false,"id":267513,"user_name":"liupan","can_delete":false,"product_type":"c1","uid":1612910,"ip_address":"","ucode":"C6C7C48BCCAE12","user_header":"https://static001.geekbang.org/account/avatar/00/18/9c/6e/01b4d5d2.jpg","comment_is_top":false,"comment_ctime":1607782269,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607782269","product_id":100039001,"comment_content":"感觉里氏替换肯定是多态的实现，但是多态不一定满足理氏替换，有可能破坏了原则","like_count":0},{"had_liked":false,"id":266055,"user_name":"落尘","can_delete":false,"product_type":"c1","uid":1802622,"ip_address":"","ucode":"7B76B94CA301D7","user_header":"https://static001.geekbang.org/account/avatar/00/1b/81/7e/fb688b5c.jpg","comment_is_top":false,"comment_ctime":1607152327,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607152327","product_id":100039001,"comment_content":"里氏替换原则，是指导如何设计继承父类的子类的原则。最核心的思想是“design by contract 按照协议设计”，具体来说就是子类不能改变父类的逻辑行为，不能破坏程序的正确性。<br><br>其实里氏替换原则与基于接口编程的原则有共通之处，还记得争哥讲接口的时候提到接口就是“contract 协议”。顾名思义就是要遵循“协议”来实现接口和设计子类的方法实现。那么什么是“协议”，归根结底就是，OOP中类所抽象出来的行为。<br><br>里氏替换原则遵循了OOP抽象的需要，规范了继承时容易出现的多态问题，避免运行时出现不易察觉的错误。","like_count":0},{"had_liked":false,"id":263649,"user_name":"狼行天下","can_delete":false,"product_type":"c1","uid":1053161,"ip_address":"","ucode":"A3F22B276B88B1","user_header":"https://static001.geekbang.org/account/avatar/00/10/11/e9/13f28df2.jpg","comment_is_top":false,"comment_ctime":1606206848,"is_pvip":false,"replies":[{"id":"96087","content":"嗯嗯 ������","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606700694,"ip_address":"","comment_id":263649,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1606206848","product_id":100039001,"comment_content":"LSP 规定子类替换父类，不能改变父类的输入、输出、异常等约定<br>常见的反例类型包括：1、子类违背父类声明要实现的功能。2、子类改变父类的输入、输出、异常等约定。3、子类违背父类注释中所罗列的特殊说明","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510256,"discussion_content":"嗯嗯 ������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262121,"user_name":"航哥很帅","can_delete":false,"product_type":"c1","uid":1145270,"ip_address":"","ucode":"23A1CB2A3723AF","user_header":"https://static001.geekbang.org/account/avatar/00/11/79/b6/faaa95a2.jpg","comment_is_top":false,"comment_ctime":1605616657,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1605616657","product_id":100039001,"comment_content":"里式替换原则的关键在于子类继承父类以后，可以改变重写函数的业务逻辑，但是有一些东西是不能改变的，比如：函数声明要实现的功能，输入和输出的限制，抛出异常的情况等。说的更简单一些，里式替换原则其实就是让子类的继承更加增强了。子类可以通过继承来实现多态，但这个继承是有限制的，这个限制就是里式替换原则。<br><br><br>有一个非常简单的检查子类是否满足里式替换原则的方法：用父类中的单元测试方法验证子类中的功能是否正常，如果单元测试出现异常，就说明极有可能子类的实现违反了里式替换原则。","like_count":0},{"had_liked":false,"id":256176,"user_name":"紫日","can_delete":false,"product_type":"c1","uid":1207410,"ip_address":"","ucode":"73A8DEE323AC19","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXSb2jAzlMM0JdTjWrNiaq2uR9eeloBYp906POddb9evmuj5f4CUoO6ge8TibibwtZicnl1sRHic9rW7g/132","comment_is_top":false,"comment_ctime":1603547021,"is_pvip":true,"discussion_count":0,"race_medal":4,"score":"1603547021","product_id":100039001,"comment_content":"用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。","like_count":0},{"had_liked":false,"id":255840,"user_name":"刘长锋","can_delete":false,"product_type":"c1","uid":1060922,"ip_address":"","ucode":"E4ABC6E335C989","user_header":"https://static001.geekbang.org/account/avatar/00/10/30/3a/e970285b.jpg","comment_is_top":false,"comment_ctime":1603441362,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603441362","product_id":100039001,"comment_content":"个人理解，里氏替换原则，使类的代码功能设计更规范，更符合源码阅读者的预期，方便维护。","like_count":0},{"had_liked":false,"id":251935,"user_name":"大力水手Jerry","can_delete":false,"product_type":"c1","uid":1227840,"ip_address":"","ucode":"E4A6C71E275DB5","user_header":"https://static001.geekbang.org/account/avatar/00/12/bc/40/2279cfb5.jpg","comment_is_top":false,"comment_ctime":1601988020,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601988020","product_id":100039001,"comment_content":"在面向对象领域，我们关注多态，除了希望利用函数行为的**差异性**外，还希望函数行为**表现一致**，确保相关业务逻辑实现的一致：我们希望所有实现类的特定接口行为表现，在输入条件，输出结果（正常和异常）都是一样的。否则我们就需要根据具体类（不论它们是否是父子类，还是接口&#47;实现类关系）的不同，定制不同的业务处理逻辑，而这将大大的损害多态的名声。","like_count":0},{"had_liked":false,"id":250608,"user_name":"朱月俊","can_delete":false,"product_type":"c1","uid":1017707,"ip_address":"","ucode":"4DA0728B862FBD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/6b/0b6cd39a.jpg","comment_is_top":false,"comment_ctime":1601170666,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601170666","product_id":100039001,"comment_content":"Design by contract适用于不同模块，类，方法之间交互，不会因为模块，类，方法内部实现的改变而影响其他模块，类，方法的功能，从这个层面来说，达到了解耦的效果。","like_count":0},{"had_liked":false,"id":247589,"user_name":"Harlan","can_delete":false,"product_type":"c1","uid":2134882,"ip_address":"","ucode":"F43595A0A00B19","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erpYZalYvFGcBs7zZvYwaQAZwTLiaw0mycJ4PdYpP3VxAYkAtyIRHhjSOrOK0yESaPpgEbVQUwf6LA/132","comment_is_top":false,"comment_ctime":1599749140,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599749140","product_id":100039001,"comment_content":"里式替换法则更多是一种开闭原则","like_count":0},{"had_liked":false,"id":247215,"user_name":"Younger Ku","can_delete":false,"product_type":"c1","uid":1323102,"ip_address":"","ucode":"D157DC38BDB515","user_header":"https://static001.geekbang.org/account/avatar/00/14/30/5e/c42bc33f.jpg","comment_is_top":false,"comment_ctime":1599635161,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599635161","product_id":100039001,"comment_content":"还有个依赖倒置，和李氏替换也有一定关系吧。今天学了李氏替换感觉理解更深入了一层。","like_count":0},{"had_liked":false,"id":247155,"user_name":"醉碧川","can_delete":false,"product_type":"c1","uid":1196641,"ip_address":"","ucode":"B0DCE5E48FDD82","user_header":"https://static001.geekbang.org/account/avatar/00/12/42/61/de579755.jpg","comment_is_top":false,"comment_ctime":1599619706,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599619706","product_id":100039001,"comment_content":"里氏替换原则的理解，父类能做到的事情，子类必须一板一眼的照做，不能做任何的变动，但是父类没有的功能，子类可以增加。","like_count":0},{"had_liked":false,"id":246911,"user_name":"大力","can_delete":false,"product_type":"c1","uid":1364353,"ip_address":"","ucode":"1B2125C519443D","user_header":"https://static001.geekbang.org/account/avatar/00/14/d1/81/89ba9d81.jpg","comment_is_top":false,"comment_ctime":1599528980,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599528980","product_id":100039001,"comment_content":"里氏替换原则的意义就是，子类可以任意扩充或替换父类的逻辑，前提是在不违反父类制定的“协议”的情况下。","like_count":0},{"had_liked":false,"id":246339,"user_name":"JerryZhu","can_delete":false,"product_type":"c1","uid":1591223,"ip_address":"","ucode":"76850CD45786C1","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","comment_is_top":false,"comment_ctime":1599285445,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599285445","product_id":100039001,"comment_content":"里氏替换原则最大作用就是在保证父类实现方法的 入参 出参  异常等不变的前提下， 尽可能的实现子类对父类多样化功能的扩展， 我来举个例子不知道对不对， 老师可以帮我检查一下，  比如提现可以发送通知， 而父类只有提现的逻辑， 子类可以扩充一个异步mq提现通知，这个算不算里氏替换， 因为发送mq通知业务如果并不需要关注是否一定发送成功，那么完全不会影响到原父类逻辑","like_count":0},{"had_liked":false,"id":246241,"user_name":"郁晨","can_delete":false,"product_type":"c1","uid":1257469,"ip_address":"","ucode":"760E0A6B3136B9","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/fd/d5683568.jpg","comment_is_top":false,"comment_ctime":1599218530,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599218530","product_id":100039001,"comment_content":"子类与父类实现逻辑与输入输出的信息都不违背","like_count":0},{"had_liked":false,"id":245953,"user_name":"宇天飞","can_delete":false,"product_type":"c1","uid":1126444,"ip_address":"","ucode":"3FB37D1E2DAA61","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/2c/06375913.jpg","comment_is_top":false,"comment_ctime":1599120525,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1599120525","product_id":100039001,"comment_content":"LSP：指导子对象的设计，保证子对象继承父对象的行为不变，包括声明、注释、异常、功能等","like_count":0},{"had_liked":false,"id":245249,"user_name":"郑大钱","can_delete":false,"product_type":"c1","uid":1503067,"ip_address":"","ucode":"114CF48056880E","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/5b/ff28088f.jpg","comment_is_top":false,"comment_ctime":1598875549,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598875549","product_id":100039001,"comment_content":"里式替换是规范使用多态的一个原则，不改变父类方法原有的执行流程，不修改父类方法的设计初衷，只通过重写的方式来扩展父类的方法。<br>如果不得已要修改父类的设计，那要考虑看看是不是抽象出了问题，是否需要重构代码。","like_count":0},{"had_liked":false,"id":244204,"user_name":"好名字","can_delete":false,"product_type":"c1","uid":1951501,"ip_address":"","ucode":"E2BFD96F912A67","user_header":"https://static001.geekbang.org/account/avatar/00/1d/c7/0d/0dab398b.jpg","comment_is_top":false,"comment_ctime":1598428282,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598428282","product_id":100039001,"comment_content":"父类方法尽量通用，父类是接口类最好，子类可以任意定义实现，都不会影响里示替换，否则子类重写父类方法，就一定不要修改输入&#47;输出&#47;异常情况。等于说继承不要无限制的继承。","like_count":0},{"had_liked":false,"id":243388,"user_name":"TING","can_delete":false,"product_type":"c1","uid":1178451,"ip_address":"","ucode":"75F2BF2EE1DF7B","user_header":"https://static001.geekbang.org/account/avatar/00/11/fb/53/ceaa0bf0.jpg","comment_is_top":false,"comment_ctime":1598083167,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598083167","product_id":100039001,"comment_content":"子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。行为约定包括：函数声明要实现的功能；对输入、输出、异常的约定","like_count":0},{"had_liked":false,"id":243051,"user_name":"Henry","can_delete":false,"product_type":"c1","uid":1929375,"ip_address":"","ucode":"7C554C97935443","user_header":"https://static001.geekbang.org/account/avatar/00/1d/70/9f/741cd6a4.jpg","comment_is_top":false,"comment_ctime":1597932147,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597932147","product_id":100039001,"comment_content":"感觉实际开发中用多态的情况比较多，很难保证以后会不需要改变父类的行为。","like_count":0},{"had_liked":false,"id":242890,"user_name":"嘉嘉☕","can_delete":false,"product_type":"c1","uid":1059771,"ip_address":"","ucode":"632A5CC4B53BB1","user_header":"https://static001.geekbang.org/account/avatar/00/10/2b/bb/5cf70df8.jpg","comment_is_top":false,"comment_ctime":1597886134,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597886134","product_id":100039001,"comment_content":"里氏替换原则, 就是对继承行为做了控制, 告诉子类标准; 并且与开闭类似, 不要破坏原有代码的正常运行, 不要破坏原有的单元测试","like_count":0},{"had_liked":false,"id":242815,"user_name":"超越自我","can_delete":false,"product_type":"c1","uid":2130462,"ip_address":"","ucode":"8A55D972EEFADA","user_header":"https://static001.geekbang.org/account/avatar/00/20/82/1e/f3cb3d57.jpg","comment_is_top":false,"comment_ctime":1597848218,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597848218","product_id":100039001,"comment_content":"老祖宗定下来的规矩，后代不要打破它，要传承。","like_count":0},{"had_liked":false,"id":242548,"user_name":"Canon.Din","can_delete":false,"product_type":"c1","uid":1158109,"ip_address":"","ucode":"2C5448AAF7CF46","user_header":"https://static001.geekbang.org/account/avatar/00/11/ab/dd/31942fb9.jpg","comment_is_top":false,"comment_ctime":1597756722,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597756722","product_id":100039001,"comment_content":"里式替换几个使用场景<br>1.代码重构，提取逻辑，代码迁移或者改调用方时，切记不可手贱优化<br>2. SQL拆分时，代码实现SQL逻辑就要一个条件一个条件对应，遗漏条件就不满足里式替换了","like_count":0},{"had_liked":false,"id":240624,"user_name":"David","can_delete":false,"product_type":"c1","uid":1021825,"ip_address":"","ucode":"22CBBC13FC97A9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/97/81/e1eaf621.jpg","comment_is_top":false,"comment_ctime":1597021073,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1597021073","product_id":100039001,"comment_content":"lsp：按照协议设计。子类只能增强，不能破坏协议。<br>意义：遵循协议编程 沟通成本低。","like_count":0},{"had_liked":false,"id":240143,"user_name":"Jason.w","can_delete":false,"product_type":"c1","uid":1366413,"ip_address":"","ucode":"EE39ADEB7C6BC8","user_header":"https://static001.geekbang.org/account/avatar/00/14/d9/8d/a6984f12.jpg","comment_is_top":false,"comment_ctime":1596770526,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596770526","product_id":100039001,"comment_content":"继承要做到增强而不破坏.","like_count":0},{"had_liked":false,"id":239832,"user_name":"Geek_31594d","can_delete":false,"product_type":"c1","uid":2030240,"ip_address":"","ucode":"9058787881CE82","user_header":"","comment_is_top":false,"comment_ctime":1596674664,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596674664","product_id":100039001,"comment_content":"遵循协议 继承传统 增强","like_count":0},{"had_liked":false,"id":238918,"user_name":"克一","can_delete":false,"product_type":"c1","uid":1612666,"ip_address":"","ucode":"1C9F8229B5739A","user_header":"https://static001.geekbang.org/account/avatar/00/18/9b/7a/78dde0a2.jpg","comment_is_top":false,"comment_ctime":1596369553,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596369553","product_id":100039001,"comment_content":"里氏替换选择，好比父子关系，子的籍贯，姓这些原则的协议不能改，其他的可以跟老子不一样，比如生几个孩子，娶几个老婆。","like_count":0},{"had_liked":false,"id":238485,"user_name":"汉江","can_delete":false,"product_type":"c1","uid":1788647,"ip_address":"","ucode":"01622D984B8F9B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/4a/e7/6c16af5d.jpg","comment_is_top":false,"comment_ctime":1596182022,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596182022","product_id":100039001,"comment_content":"里式替换原则我觉得意义有两点：1 减少代码出错的概率  2.减少沟通成本","like_count":0},{"had_liked":false,"id":237798,"user_name":"写代码的","can_delete":false,"product_type":"c1","uid":2085090,"ip_address":"","ucode":"F58186409A3D65","user_header":"https://static001.geekbang.org/account/avatar/00/1f/d0/e2/1d00c079.jpg","comment_is_top":false,"comment_ctime":1595960626,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595960626","product_id":100039001,"comment_content":"里氏替换原则存在的意义就是提升代码的可维护性和灵活性。里氏替换原则一般要和静态工厂方法结合，这样替换成子类的工作只需要在这个静态工厂方法里做，而不需要在整个项目中去修改代码。","like_count":0},{"had_liked":false,"id":233200,"user_name":"Geek_71cea9","can_delete":false,"product_type":"c1","uid":2058308,"ip_address":"","ucode":"DE88271BA527DD","user_header":"","comment_is_top":false,"comment_ctime":1594259160,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594259160","product_id":100039001,"comment_content":"多态更多是子类继承父类的一种能力和实现方式，来达到扩展性 ，而里斯替换是一种设计原则 和规范 需要在日常写代码中去遵守 ","like_count":0},{"had_liked":false,"id":231365,"user_name":"谭棋钊","can_delete":false,"product_type":"c1","uid":1237976,"ip_address":"","ucode":"F7F982BE5978BA","user_header":"https://static001.geekbang.org/account/avatar/00/12/e3/d8/bc70f34a.jpg","comment_is_top":false,"comment_ctime":1593657822,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593657822","product_id":100039001,"comment_content":"我的理解:在面对需求时，我们会想到可以用多态来实现，而在实现的过程中，需要用到里式替换原则的思想","like_count":0},{"had_liked":false,"id":231013,"user_name":"zlig","can_delete":false,"product_type":"c1","uid":1475134,"ip_address":"","ucode":"DD5850FA4235E5","user_header":"https://static001.geekbang.org/account/avatar/00/16/82/3e/1fc6e36a.jpg","comment_is_top":false,"comment_ctime":1593565733,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593565733","product_id":100039001,"comment_content":"多态是一种很强的扩展能力，需要控制使用，比如子类通过多态能把父类的加法扩展成减法。里氏替换原则就是对多态的超能力的一种约束，在上面的例子中，子类的扩展也只能是加法，具体怎么加不管。","like_count":0},{"had_liked":false,"id":230817,"user_name":"西门吹牛","can_delete":false,"product_type":"c1","uid":1508990,"ip_address":"","ucode":"E5D3624DDE1E83","user_header":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","comment_is_top":false,"comment_ctime":1593502562,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593502562","product_id":100039001,"comment_content":"里斯替换的实现基础是多态和继承，在继承的基础上进行了加强。用多态语法实现的代码，不一定满足里氏替换原则，里斯替换对子类有更高的要求。但是满足里斯替换原则的代码，一定是建立在多态和继承的基础上。","like_count":0},{"had_liked":false,"id":229548,"user_name":"被过去推开","can_delete":false,"product_type":"c1","uid":1276690,"ip_address":"","ucode":"8B4F34FE93FD5B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Cib5umA0W17N9pichI08pnrXAExdbyh7AVzH4nEhD6KN3FXuELk4LJJuqUPPD7xmIy9nq5Hjbgnzic7sVZG5BKiaUQ/132","comment_is_top":false,"comment_ctime":1593054795,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593054795","product_id":100039001,"comment_content":"里氏替换原则最基本的逻辑行为是不破坏原有逻辑的行为。假如我要根据不同的接收方发送不同的消息协议，那么可以依照里氏替换原则，增加或删减消息。","like_count":0},{"had_liked":false,"id":229277,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1592957210,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592957210","product_id":100039001,"comment_content":"里氏替换原则就是，子类重写父类方法时，只能增强原有方法的功能，不能修改本身的逻辑","like_count":0},{"had_liked":false,"id":229218,"user_name":"maybe","can_delete":false,"product_type":"c1","uid":1475528,"ip_address":"","ucode":"93D160F617E750","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/c8/5ce842f6.jpg","comment_is_top":false,"comment_ctime":1592925559,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1592925559","product_id":100039001,"comment_content":"死扣定义，不属于单一职责原则、接口隔离原则。但是实际上我们认为它是符合单于职责原则、接口隔离原则的，这个函数很简单，只是对一个数的递增后返回递增前的值。是个完整且功能单一的数字操作，符合单于职责原则。对于调用者来说，他希望递增一个数字、递增一个数字并返回之前的值的需求，然后调用这个函数。这个函数并未有其它过多的操作，记录递增前的值也不需要任何其它消耗的操作才能获得，符合接口隔离原则","like_count":0},{"had_liked":false,"id":229151,"user_name":"maybe","can_delete":false,"product_type":"c1","uid":1475528,"ip_address":"","ucode":"93D160F617E750","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/c8/5ce842f6.jpg","comment_is_top":false,"comment_ctime":1592909172,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1592909172","product_id":100039001,"comment_content":"里氏替换原则指导类继承设计，在扩展的同时不修改原有行为逻辑，实现热替换","like_count":0},{"had_liked":false,"id":228898,"user_name":"命运的脚步","can_delete":false,"product_type":"c1","uid":1699087,"ip_address":"","ucode":"5A859A91B0C03A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKxaChY8P85zfcQ0hvQCZbQmbXIvyP5VoOz9QqcMrlQ21y6eNSNl1npicEGkzq9ldw9lbTUC9RY6Tw/132","comment_is_top":false,"comment_ctime":1592835702,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592835702","product_id":100039001,"comment_content":"父类做了边界的设定，子类增强了父类的功能，但不要越过边界。","like_count":0},{"had_liked":false,"id":226592,"user_name":"maybe","can_delete":false,"product_type":"c1","uid":1475528,"ip_address":"","ucode":"93D160F617E750","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/c8/5ce842f6.jpg","comment_is_top":false,"comment_ctime":1592147074,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1592147074","product_id":100039001,"comment_content":"里氏替换原则的意义：指导子类设计，应该遵循父类的协议。如果一个子类已经不按照父类的协议，这个子类就是有问题或者已经不该继承这个父类了。一个子类违反里氏替换原则，那么使用的时候会产生让人误解的因素，导致类的误用或用错导致代码错误","like_count":0},{"had_liked":false,"id":225642,"user_name":"N。","can_delete":false,"product_type":"c1","uid":1647830,"ip_address":"","ucode":"8EE55D4A24004A","user_header":"https://static001.geekbang.org/account/avatar/00/19/24/d6/c65a71b3.jpg","comment_is_top":false,"comment_ctime":1591803829,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591803829","product_id":100039001,"comment_content":"里氏替换原则指导设计子类的时对父类的增强，而非改变父类原本逻辑","like_count":0},{"had_liked":false,"id":223807,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1591184670,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591184670","product_id":100039001,"comment_content":"里式替换是指导多态的设计原则，按照契约来扩展父类，契约包含函数“名称”和“注释”要实现的功能、函数的签名(入参和返回值)约定、异常处理约定。<br>golang对的函数返回值是集合时不要用指针！！空对象、空集合、null有编译检查可以强制一致。<br>在编写扩展实现时，违反里式替换不会有编译错误。","like_count":0},{"had_liked":false,"id":223767,"user_name":"微末凡尘","can_delete":false,"product_type":"c1","uid":1099525,"ip_address":"","ucode":"25EDFD0914D0F4","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/05/19c5c255.jpg","comment_is_top":false,"comment_ctime":1591176627,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591176627","product_id":100039001,"comment_content":"子类可以完全的替换父类实现相同的功能","like_count":0},{"had_liked":false,"id":223765,"user_name":"微末凡尘","can_delete":false,"product_type":"c1","uid":1099525,"ip_address":"","ucode":"25EDFD0914D0F4","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/05/19c5c255.jpg","comment_is_top":false,"comment_ctime":1591176422,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591176422","product_id":100039001,"comment_content":"里氏替换原则就是子类完美的继承了父类的功能，而且做了增强，更加的完善和高效","like_count":0},{"had_liked":false,"id":220346,"user_name":"Random.nextName()","can_delete":false,"product_type":"c1","uid":1244960,"ip_address":"","ucode":"8D18D91B8D3BC7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ0lHhbutibIdWRv0pm2EPtvxqcVz0PblEic7GDxHK8JUSkyuWQl1B1NVQTzEowQIxfOf3saRBOTtog/132","comment_is_top":false,"comment_ctime":1590225342,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590225342","product_id":100039001,"comment_content":"利用多态的特性进行代码组织和扩展，基于里式替换原则进行子类的设计。","like_count":0},{"had_liked":false,"id":218296,"user_name":"师哥","can_delete":false,"product_type":"c1","uid":1333376,"ip_address":"","ucode":"A86CD1661D370F","user_header":"https://static001.geekbang.org/account/avatar/00/14/58/80/c9e232b6.jpg","comment_is_top":false,"comment_ctime":1589772855,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589772855","product_id":100039001,"comment_content":"  里式替换 就是说子类可以替换父类，并且程序的逻辑性和正确性 都不受影响。它的主要原则就是按照协议来设计。","like_count":0},{"had_liked":false,"id":217014,"user_name":"Next","can_delete":false,"product_type":"c1","uid":1748213,"ip_address":"","ucode":"D5ADDF248A9504","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ac/f5/2f97e279.jpg","comment_is_top":false,"comment_ctime":1589385365,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589385365","product_id":100039001,"comment_content":"里式替换的意义：<br>避免程序出现意外的错误，保证扩展的可靠性；保证逻辑清晰可信，提高可读性、可维护性。","like_count":0},{"had_liked":false,"id":216604,"user_name":"zhou","can_delete":false,"product_type":"c1","uid":1087243,"ip_address":"","ucode":"E1CE8575B3F106","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/0b/a943bcb3.jpg","comment_is_top":false,"comment_ctime":1589294333,"is_pvip":false,"discussion_count":0,"race_medal":3,"score":"1589294333","product_id":100039001,"comment_content":"里式替换原则，就好比一辆车，低配车是父亲，高配车是儿子。","like_count":0},{"had_liked":false,"id":214890,"user_name":"Tobias","can_delete":false,"product_type":"c1","uid":1803858,"ip_address":"","ucode":"F3225639EDA193","user_header":"https://static001.geekbang.org/account/avatar/00/1b/86/52/b92dc111.jpg","comment_is_top":false,"comment_ctime":1588842624,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588842624","product_id":100039001,"comment_content":"个人理解里氏替换 可以通过 集合的包含关系来描述: 子类的功能逻辑是一个集合，父类的功能逻辑一个集合，子类集合必须包含父类集合。","like_count":0},{"had_liked":false,"id":214819,"user_name":"刘同青","can_delete":false,"product_type":"c1","uid":1818343,"ip_address":"","ucode":"84B62DF8BC61FB","user_header":"","comment_is_top":false,"comment_ctime":1588824171,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588824171","product_id":100039001,"comment_content":"子类可以重写父类方法，但是要支持父类对该方法所有的定义。作用:  当使用多态时，代码中除了实例化时会new子类对象，其他代码使用的均是父类中的方法，编码也是根据父类中的方法的定义和注释进行，甚至这时候还没有子类的实现，所以如果子类不遵从父类约定随意重写，就可能完成使用父类方法的代码出现问题，<br>父类方法定义可能抛出的异常是ParamException<br>所以代码中捕获异常<br>但是有个子类重写后非要抛出ValidateException，<br>这就造成获取异常的代码失效，<br><br>总结就是:  凡事都要有个公共标准，要不然会越来越乱<br>","like_count":0},{"had_liked":false,"id":213797,"user_name":"编程界的小学生","can_delete":false,"product_type":"c1","uid":1593289,"ip_address":"","ucode":"4A5BE9A5E877FA","user_header":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","comment_is_top":false,"comment_ctime":1588563696,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588563696","product_id":100039001,"comment_content":"为啥我觉得策略模式肯定违反了这个原则，因为策略模式针对的不同算法，它的结果正确性肯定会遭到破坏，希望老师解答下，有点困惑。","like_count":0},{"had_liked":false,"id":211896,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1588036679,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588036679","product_id":100039001,"comment_content":"面向对象继承关系中，子类和父类的关系是is-a，即任何使用父类的地方都可以用子类来代替。这不仅是语法上的，也是语义上的。里氏替换原则就是用来保证这一点的","like_count":0},{"had_liked":false,"id":210486,"user_name":"指尖流逝","can_delete":false,"product_type":"c1","uid":1005381,"ip_address":"","ucode":"417009F674FAF1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/45/c418ea5c.jpg","comment_is_top":false,"comment_ctime":1587776232,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587776232","product_id":100039001,"comment_content":"里式替换原则：多态特性的一种现实应用，可以将代码中”某块变化的功能“和不变的功能进行隔离，在有需要的时候灵活替换”变化“，既然是替换，那么就需要遵守规则或约定：输入、输出、异常三者都需要符合既定约束","like_count":0},{"had_liked":false,"id":208875,"user_name":"郭强","can_delete":false,"product_type":"c1","uid":1192928,"ip_address":"","ucode":"38F36F0F4CC775","user_header":"https://static001.geekbang.org/account/avatar/00/12/33/e0/387ab6fd.jpg","comment_is_top":false,"comment_ctime":1587455912,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587455912","product_id":100039001,"comment_content":"里氏替换原则解决了什么问题，不遵守会造成什么影响？我对这个原则的意思懂了，但理解的不深刻。最好能有实际项目中里氏替换原则带好实际好处的例子！","like_count":0},{"had_liked":false,"id":207034,"user_name":"minsky","can_delete":false,"product_type":"c1","uid":1351075,"ip_address":"","ucode":"7296ECA064E89B","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/a3/79fc9017.jpg","comment_is_top":false,"comment_ctime":1586998638,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586998638","product_id":100039001,"comment_content":"个人理解里氏替换原则是在前提上保证多态特性在使用时不出错的，或则说是让多态特性更完善和精准。可以想象如果子类设计时不遵循里氏替换原则，那么代码使用多态时经常会出现一些意想不到的错误，尤其是父类或者接口有多个子类的时候。","like_count":0},{"had_liked":false,"id":204077,"user_name":"zhanyd","can_delete":false,"product_type":"c1","uid":1073845,"ip_address":"","ucode":"4C994EE512A3C4","user_header":"https://static001.geekbang.org/account/avatar/00/10/62/b5/4159fa05.jpg","comment_is_top":false,"comment_ctime":1586330164,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586330164","product_id":100039001,"comment_content":"里氏替换原则就是父类给子类设定的边界，子类可以在边界内自由发挥，但是不能越过边界，超出父类的控制。","like_count":0},{"had_liked":false,"id":202633,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1586020300,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1586020300","product_id":100039001,"comment_content":"里式替换原则可以形象的理解为：做一个乖孩子。","like_count":0},{"had_liked":false,"id":201966,"user_name":"改名不换人","can_delete":false,"product_type":"c1","uid":1118242,"ip_address":"","ucode":"7E25577829FA0F","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/22/910f705c.jpg","comment_is_top":false,"comment_ctime":1585882928,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585882928","product_id":100039001,"comment_content":"里式替换原则的意义我认为就是在我们通过多态(继承)来扩展程序的功能时，不能因为扩展了新的功能而影响了原有代码的逻辑，也就是要遵守父类方法的协议，使得子类可以安全的替换所有父类出现的地方。这个原则的关键是：保证原来程序的逻辑行为不变和正确性不被破坏。","like_count":0},{"had_liked":false,"id":201707,"user_name":"Ray","can_delete":false,"product_type":"c1","uid":1604089,"ip_address":"","ucode":"3A66800D8E35D6","user_header":"https://static001.geekbang.org/account/avatar/00/18/79/f9/3cd59b29.jpg","comment_is_top":false,"comment_ctime":1585821935,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585821935","product_id":100039001,"comment_content":"个人观点：<br>最后讲到的里式替换原则与多态是区别很重要，更好的区分了这二者的概念<br>里式替换是设计原则，而多态是代码的实现方式，从本质上来讲是不一样的","like_count":0},{"had_liked":false,"id":201226,"user_name":"这得从我捡到一个鼠标垫开始说起","can_delete":false,"product_type":"c1","uid":1272321,"ip_address":"","ucode":"2FF4347B4E7A9B","user_header":"https://static001.geekbang.org/account/avatar/00/13/6a/01/d9cb531d.jpg","comment_is_top":false,"comment_ctime":1585735510,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585735510","product_id":100039001,"comment_content":"里氏替换原则避免替换了实现了之后，出现不正确的行为。","like_count":0},{"had_liked":false,"id":200845,"user_name":"Nick","can_delete":false,"product_type":"c1","uid":1921287,"ip_address":"","ucode":"64BBE005890845","user_header":"https://static001.geekbang.org/account/avatar/00/1d/51/07/b5a945b6.jpg","comment_is_top":false,"comment_ctime":1585660186,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585660186","product_id":100039001,"comment_content":"我是这么理解的，LSP原则其实也是符合面向接口编程而不是面向实现编程这一原则的，接口或者是父类定义好的方法，子类则不能违背其约定或者说是原则。","like_count":0},{"had_liked":false,"id":200303,"user_name":"面向百度编程","can_delete":false,"product_type":"c1","uid":1732780,"ip_address":"","ucode":"8FE04A019D71D1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","comment_is_top":false,"comment_ctime":1585570519,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585570519","product_id":100039001,"comment_content":"如果说按照 design by contract  的话，那么我觉得继承了父类既然不做修改，遵从约定，那么子类就是把原有的功能都继承下来，从而自己在增强原有功能，达到替换效果，感觉有点装饰者模式，代理模式味道，我指的味道是思想上的哈，都是增强功能","like_count":0},{"had_liked":false,"id":200215,"user_name":"墨鱼","can_delete":false,"product_type":"c1","uid":1022720,"ip_address":"","ucode":"8FB5E4DCB8A024","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/00/654be3f7.jpg","comment_is_top":false,"comment_ctime":1585559190,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585559190","product_id":100039001,"comment_content":"里式替换原则是：按照协议设计，子类如果要修改父类的代码，核心逻辑不能变，实现可以修改，包括注释里写的设计原则。","like_count":0},{"had_liked":false,"id":197934,"user_name":"桂冠远航","can_delete":false,"product_type":"c1","uid":1155463,"ip_address":"","ucode":"5959E1A1DAA05D","user_header":"https://static001.geekbang.org/account/avatar/00/11/a1/87/259ab5a3.jpg","comment_is_top":false,"comment_ctime":1585404096,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585404096","product_id":100039001,"comment_content":"感觉LSP和Java中子类覆写父类方法要求是一样的。","like_count":0},{"had_liked":false,"id":197217,"user_name":"韶年","can_delete":false,"product_type":"c1","uid":1269934,"ip_address":"","ucode":"EA4149F98FF39B","user_header":"https://static001.geekbang.org/account/avatar/00/13/60/ae/88d88232.jpg","comment_is_top":false,"comment_ctime":1585363603,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585363603","product_id":100039001,"comment_content":"里式替换的使用场景是什么？不符合里式替换的继承有什么坏处？","like_count":0},{"had_liked":false,"id":197199,"user_name":"韶年","can_delete":false,"product_type":"c1","uid":1269934,"ip_address":"","ucode":"EA4149F98FF39B","user_header":"https://static001.geekbang.org/account/avatar/00/13/60/ae/88d88232.jpg","comment_is_top":false,"comment_ctime":1585362975,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585362975","product_id":100039001,"comment_content":"子类调用super.sendRequest(request)，那子类存在的意义是什么呢？仅仅是设置密码吗？这样子是不是过度设计了。","like_count":0},{"had_liked":false,"id":197195,"user_name":"韶年","can_delete":false,"product_type":"c1","uid":1269934,"ip_address":"","ucode":"EA4149F98FF39B","user_header":"https://static001.geekbang.org/account/avatar/00/13/60/ae/88d88232.jpg","comment_is_top":false,"comment_ctime":1585362786,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585362786","product_id":100039001,"comment_content":"感觉比开闭原则难理解多了，看了两边硬是没看明白。","like_count":0},{"had_liked":false,"id":197147,"user_name":"Kevin.zhang🌏","can_delete":false,"product_type":"c1","uid":1247039,"ip_address":"","ucode":"5C52AE51538906","user_header":"https://static001.geekbang.org/account/avatar/00/13/07/3f/53ae01f6.jpg","comment_is_top":false,"comment_ctime":1585360270,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585360270","product_id":100039001,"comment_content":"不支持OOB的C语言其实也支持李式替换原则，函数指针真神器！可以实现接口、多态、模板方法等OO特性。","like_count":0},{"had_liked":false,"id":195854,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1585219460,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585219460","product_id":100039001,"comment_content":"有点类似于继承并增强了父类功能，就像模版模式那样。又有点像策略模式。总之，接口保持和父类一致。","like_count":0},{"had_liked":false,"id":194329,"user_name":"然","can_delete":false,"product_type":"c1","uid":1347648,"ip_address":"","ucode":"43B7D3896D706B","user_header":"https://static001.geekbang.org/account/avatar/00/14/90/40/dfa19744.jpg","comment_is_top":false,"comment_ctime":1585051101,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585051101","product_id":100039001,"comment_content":"里氏置换原则是用来指导子类继承父类如何设计的原则，子类需要遵守函数原有的约定：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明","like_count":0},{"had_liked":false,"id":194262,"user_name":"jaryoung","can_delete":false,"product_type":"c1","uid":1077406,"ip_address":"","ucode":"6E72D107DB7E51","user_header":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","comment_is_top":false,"comment_ctime":1585043284,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585043284","product_id":100039001,"comment_content":"今天学习里氏替换原则，收获如下：<br>规约要遵守，例如你继承别人的超人的能力，你要去干坏事（大家都知道超人是好人）<br>约定包括：：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。","like_count":0},{"had_liked":false,"id":193889,"user_name":"陈包佳","can_delete":false,"product_type":"c1","uid":1576712,"ip_address":"","ucode":"9DAAC87C75D91F","user_header":"https://static001.geekbang.org/account/avatar/00/18/0f/08/7abf466e.jpg","comment_is_top":false,"comment_ctime":1584977681,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584977681","product_id":100039001,"comment_content":"里氏原则指导了子类的设计原则，要求子类替换父类后不能破坏父类的功能和逻辑。与多态的区别，多态是面向对象的特性，是程序实现的方法，而里氏原则是指导子类继承父类时的设计原则，要求子类能按照父类定义的功能编写方法，不能改变父类程序的功能，以及输入输出和异常。","like_count":0},{"had_liked":false,"id":192408,"user_name":"秋风画扇","can_delete":false,"product_type":"c1","uid":1132356,"ip_address":"","ucode":"5BCBC1422C51EC","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/44/964aa665.jpg","comment_is_top":false,"comment_ctime":1584849143,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584849143","product_id":100039001,"comment_content":"同面向接口编程一个道理，使用时不需要关注内部实现。里式替换也一样，不能改变规定好的协议，保证接口、方法统一。","like_count":0},{"had_liked":false,"id":189983,"user_name":"Eden Ma","can_delete":false,"product_type":"c1","uid":1457408,"ip_address":"","ucode":"755312F0D154F9","user_header":"https://static001.geekbang.org/account/avatar/00/16/3d/00/7daa7403.jpg","comment_is_top":false,"comment_ctime":1584588755,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584588755","product_id":100039001,"comment_content":"存在意义:方法实现功能上的同一性、一致性,这样不会导致子类实现的方法出现意料之外的情况.","like_count":0},{"had_liked":false,"id":187685,"user_name":"林峰峰","can_delete":false,"product_type":"c1","uid":1457609,"ip_address":"","ucode":"83C2093135BBB8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/3B5MoC4DfBt00nnVshEBFHHkNVgbcBrXsd3SxFicdN3XX5ILOe7GJxKvtJKCY53xNCuxSV8ABxNulbhkibm1lXIw/132","comment_is_top":false,"comment_ctime":1584192714,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584192714","product_id":100039001,"comment_content":"design by contract，按照协议来设计 ,通过父类定义协议，其他子类遵守。这个可以规定子类的行为。 大家统一按照一个设计进行，方便外部调用。","like_count":0},{"had_liked":false,"id":187402,"user_name":"未来小娃","can_delete":false,"product_type":"c1","uid":1047329,"ip_address":"","ucode":"477D166EBB6B70","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/21/d017438c.jpg","comment_is_top":false,"comment_ctime":1584102361,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584102361","product_id":100039001,"comment_content":"【设计模式笔记18】20200313<br>之前理解的里氏替换是子类可以替换父类，里氏替换是是指在不改变父类功能的情况下子类替换父类。但是这个原则能解决什么问题呢，保持程序的扩展性，假如子类替换父类后功能变了就违反了父类的功能特性，逻辑就被改变了，这说明程度不够健壮。那假如一定要改变父类的功能怎么办呢：1）使用接口；2）使用抽象方法，这样任何子类都可以实现自己的逻辑，父类只是一个函数，没有功能的约定。下面说下多态和里氏替换原则的关系，里氏替换是一种指导怎么设计父类和子类的原则，多态是一种语法，没有功能约束，一个是语法一个是原则。","like_count":0},{"had_liked":false,"id":187233,"user_name":"88591","can_delete":false,"product_type":"c1","uid":1254656,"ip_address":"","ucode":"04CE3E46455185","user_header":"https://static001.geekbang.org/account/avatar/00/13/25/00/3afbab43.jpg","comment_is_top":false,"comment_ctime":1584066145,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584066145","product_id":100039001,"comment_content":"代码是人来写，所以需要效率和质量。任何有利于效率和质量的设计就是好的，反之则需要权衡利弊，改进设计。大多数情况下面经典的设计原则都是高效率和高质量的设计，但是也需要依据实际情况进行取舍。","like_count":0},{"had_liked":false,"id":184770,"user_name":"von","can_delete":false,"product_type":"c1","uid":1736813,"ip_address":"","ucode":"403C8CF955AFF3","user_header":"","comment_is_top":false,"comment_ctime":1583398361,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583398361","product_id":100039001,"comment_content":"多态，更多的是指从java语法层面，父类引用可以指向子类的一个实例，运行时执行子类的方法；<br>LSP，侧重的是约定父类中被子类重写的方法行为，即重写的方法不能在逻辑上与父类原方法有出入。<br>所以，两者说的是不同的事情。","like_count":0},{"had_liked":false,"id":182965,"user_name":"糖","can_delete":false,"product_type":"c1","uid":1542834,"ip_address":"","ucode":"784DDA19104392","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJzP9yB6eIRRyVNe3iab0gXB6yOeaNRHGx6raTQz2grfE5N2LWl6uIj1mrSU7nxiaEzeSLp6xAkE3iaQ/132","comment_is_top":false,"comment_ctime":1582899704,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1582899704","product_id":100039001,"comment_content":"有一点疑问：子类在重载父类的函数之后，如果子类和父类的重载函数对于外在表现完全一致，那么除了实现方法的不同之外，怎么体现子类相对于父类的扩展呢？比如像文中提到的vip用户withdraw（）函数还和普通用户存在一样的行为，那vip用户相对于其他用户是不是就没有区别了呢？","like_count":0,"discussions":[{"author":{"id":1318719,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1f/3f/659bb0d8.jpg","nickname":"苍玄晶魄","note":"","ucode":"2EF6583344E446","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":203091,"discussion_content":"我理解外在表现一致是指约定一致\n类似于接口和实现类的关系\n例如飞机-飞,我们可以实现直升机的螺旋翼飞,也可以喷气式飞\n但父类直接就定义了方法,命名和注释都表明了是喷气式飞行,再在子类实现直升机就不合适了\n归根结底,对于继承需要更抽象的看待问题,继承可以实现多态,但不是无约束的实现多态","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583995066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180869,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1582432445,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582432445","product_id":100039001,"comment_content":"大前提就是，易用、易读、易维护、易扩展；LSP，就主要是为了易读，易维护、易扩展好像也包含在里面；心法完全靠领会啊","like_count":0},{"had_liked":false,"id":180574,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1582339963,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582339963","product_id":100039001,"comment_content":"我个人认为里氏替换原则的存在意义,<br>1.方便维护我们的开闭原则 即对修改关闭对扩展开放，避免因为不必要因为新的扩展而打破父类所约定的协议，二是，在重构的时候，在原有服务类的基础上新增子类，在子类当中做到更高效地实现原有的父类的需求，从而替换父类","like_count":0},{"had_liked":false,"id":177797,"user_name":"嘿泥鳅","can_delete":false,"product_type":"c1","uid":1285186,"ip_address":"","ucode":"A22BDA7A6DA23E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/F5Srwp8IibOU9PDCDgmpdIZF9UXQZzfPKzNseHW5GR0WmusGfrkmzQ6wq32omW3uTtl8aXjkudYSA0NEmibxAcnw/132","comment_is_top":false,"comment_ctime":1581502180,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581502180","product_id":100039001,"comment_content":"我认为回答任何原则的意义都要落地到专栏开头讲到的，如何写出高质量的代码和其评判标准上来。里式替换原则主要指导继承关系如何设计，那么为什么要设计继承关系?是为了让子类能替换父类,那又为什么要替换父类？答案是多态，多态主要解决的是扩展性和复用性，也是很多设计原则、设计模式的实现基础。综上，里式替换原则存在的意义主要解决的是编程中复用性、扩展性的问题。","like_count":0},{"had_liked":false,"id":177355,"user_name":"巨龙的力量啊","can_delete":false,"product_type":"c1","uid":1684858,"ip_address":"","ucode":"8FC6978929E48F","user_header":"https://static001.geekbang.org/account/avatar/00/19/b5/7a/a126c48f.jpg","comment_is_top":false,"comment_ctime":1581352972,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581352972","product_id":100039001,"comment_content":"多态是能这么做，里氏替换是应该这么做","like_count":0},{"had_liked":false,"id":175833,"user_name":"wai","can_delete":false,"product_type":"c1","uid":1439529,"ip_address":"","ucode":"29CE3BE148FB79","user_header":"https://static001.geekbang.org/account/avatar/00/15/f7/29/60e01017.jpg","comment_is_top":false,"comment_ctime":1580865933,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580865933","product_id":100039001,"comment_content":"我认为里式替换原则存在的主要意义：一个项目都是团队开发，针对父类会有多个子类，不同的人设计不同的子类的时候要有一个统一的设计标准，确保程序运行时尽量减少未知异常的出现。","like_count":0},{"had_liked":false,"id":175654,"user_name":"刘明丰","can_delete":false,"product_type":"c1","uid":1591790,"ip_address":"","ucode":"64C1D6CC769F75","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eocPWoTKicQG9ic42hLQBOqEziaNYxBekyGXljWrYfhk8gjLGZWfUX0JlObCvOIUSA8tRXicfxeSDJMMw/132","comment_is_top":false,"comment_ctime":1580790707,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580790707","product_id":100039001,"comment_content":"里式替换原则存在的意义还是很大的，首先能把这条原则说清楚，一定是一位经验丰富的编码人员，在不断的总结和的出来的宝贵经验。它能解决问题的是在我们使用多态特性的同时基本能保证整体的系统能正常工作，不出现不可预期的情况。","like_count":0},{"had_liked":false,"id":175204,"user_name":"密码123456","can_delete":false,"product_type":"c1","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1580615191,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580615191","product_id":100039001,"comment_content":"我觉得，这里用的最好的就是spring。比如提供的缓存抽象。只要实现对应的接口，就可以轻易的替换使用缓存的规则。","like_count":0},{"had_liked":false,"id":174655,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1580309879,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1580309879","product_id":100039001,"comment_content":"利用LSP原则可以实现OCP，如果违反了LSP，那么程序也会违反OCP","like_count":0},{"had_liked":false,"id":174588,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1580287266,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1580287266","product_id":100039001,"comment_content":"我只关心结果是不是我想要的，你怎么做到我不管","like_count":0},{"had_liked":false,"id":174430,"user_name":"老余","can_delete":false,"product_type":"c1","uid":1295848,"ip_address":"","ucode":"17AC6C60D0EB86","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/yicibWmBIDaSpBYI5wCBDQcYu6mxjvz3XZzBibxSNXFfqCS6OJOjvy2Nc2lyDicZfmneW9ZY4KbicA1sNgLktVSicgkw/132","comment_is_top":false,"comment_ctime":1580206303,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580206303","product_id":100039001,"comment_content":"里式替换原则可以约束父子类行为的关系。任何使用父类的地方可以使用子类替换，并且没有异常行为。理解里式替换原则，最核心的就是理解“design by contract，按照协议来设计”这几个字。父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数原有的“约定”。这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。","like_count":0},{"had_liked":false,"id":174337,"user_name":"磊","can_delete":false,"product_type":"c1","uid":1070732,"ip_address":"","ucode":"858BF8BFBFB0B8","user_header":"https://static001.geekbang.org/account/avatar/00/10/56/8c/a8317e23.jpg","comment_is_top":false,"comment_ctime":1580165872,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1580165872","product_id":100039001,"comment_content":"里式替换原则存在的意义：使父类的行为和属性在被继承的过程中不被修改，以保证程序的稳定性","like_count":0},{"had_liked":false,"id":173890,"user_name":"SXPeople","can_delete":false,"product_type":"c1","uid":1313127,"ip_address":"","ucode":"C6D9E2AE5278A9","user_header":"https://static001.geekbang.org/account/avatar/00/14/09/67/b46d3045.jpg","comment_is_top":false,"comment_ctime":1579759773,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579759773","product_id":100039001,"comment_content":"历史替换原则：忠于原创，高于原创","like_count":0},{"had_liked":false,"id":173311,"user_name":"桂城老托尼","can_delete":false,"product_type":"c1","uid":1306032,"ip_address":"","ucode":"139E4B8EE88B79","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJcxSpNMqwqyicMvdOSr9ic0p1ABiauHnv7g7YQVSJuoHPoQbYDu3YzdpgmSAk2KricUBQ5yibWBWIq75w/132","comment_is_top":false,"comment_ctime":1579501376,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579501376","product_id":100039001,"comment_content":"学习到了，之前没太注意和多态的区别","like_count":0},{"had_liked":false,"id":172185,"user_name":"gwen","can_delete":false,"product_type":"c1","uid":1114452,"ip_address":"","ucode":"82A01FD8458671","user_header":"https://static001.geekbang.org/account/avatar/00/11/01/54/46266631.jpg","comment_is_top":false,"comment_ctime":1579103174,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579103174","product_id":100039001,"comment_content":"里式替换就是父类定义了函数的“约定”（或者叫协议），那子类必须按照约定来实现，可以改变函数的内部实现逻辑，但不能改变函数原有的“约定”。这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。检验方法是使用父类的地方，使用子类来替换，测试用例是PASS的！","like_count":0},{"had_liked":false,"id":171964,"user_name":"www","can_delete":false,"product_type":"c1","uid":1275203,"ip_address":"","ucode":"951B364F2CB211","user_header":"https://static001.geekbang.org/account/avatar/00/13/75/43/c6058200.jpg","comment_is_top":false,"comment_ctime":1579058524,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579058524","product_id":100039001,"comment_content":"里氏替换原则存在的意义：<br>父类的静态方法其实就是一种约定&#47;协议，如果子类继承了父类，而又不遵守这种约定，那么则与“继承”这个特性相违背，这时就应该考虑新写一个父类来继承了","like_count":0},{"had_liked":false,"id":171296,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1578896252,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1578896252","product_id":100039001,"comment_content":"里氏替换原则给我最大的好处是方便扩展，很完美地阐述了子类和父类的关系：继承不代表可以override任何逻辑，子类需要遵从父类的contract。真落到实处，我感觉设计父类的时候就需要很有经验的工程师结合业务涉及基础逻辑和交互框架，不然就是在不断的重构中优化代码。后者应该更现实点","like_count":0},{"had_liked":false,"id":170349,"user_name":"刘学习来学习","can_delete":false,"product_type":"c1","uid":1464013,"ip_address":"","ucode":"5078B1EC8D8A66","user_header":"https://static001.geekbang.org/account/avatar/00/16/56/cd/0add8290.jpg","comment_is_top":false,"comment_ctime":1578576195,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578576195","product_id":100039001,"comment_content":"lsp是设计上面的一种原则，用来指导设计，多态是编程语言提供的能力，换一种语言来理解这个就好理解一点了","like_count":0},{"had_liked":false,"id":169540,"user_name":"宇宙全栈","can_delete":false,"product_type":"c1","uid":1001309,"ip_address":"","ucode":"2E984CA0ECFB85","user_header":"https://static001.geekbang.org/account/avatar/00/0f/47/5d/9afdf648.jpg","comment_is_top":false,"comment_ctime":1578374589,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578374589","product_id":100039001,"comment_content":"LSP的意义：<br>1、可读：父类型的变量赋值了一个子类型的实例，这是不用读子类代码，也能确定程序的逻辑。<br>2、可维护：优化代码时，不用担心有坑，不用改测试用例。","like_count":0},{"had_liked":false,"id":169413,"user_name":"弹簧人","can_delete":false,"product_type":"c1","uid":1697679,"ip_address":"","ucode":"BCB4A6FC76EA17","user_header":"https://static001.geekbang.org/account/avatar/00/19/e7/8f/56387f77.jpg","comment_is_top":false,"comment_ctime":1578334523,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578334523","product_id":100039001,"comment_content":"多态和里氏替换并不冲突。里氏替换也是针对父类和子类而言的。对于父类的方法，多态是指overide。只要overide的方法和父类逻辑是一致的就行","like_count":0},{"had_liked":false,"id":169195,"user_name":"CHS","can_delete":false,"product_type":"c1","uid":1240227,"ip_address":"","ucode":"3D8B2DABC0A1D6","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/a3/28763399.jpg","comment_is_top":false,"comment_ctime":1578289902,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578289902","product_id":100039001,"comment_content":"子类在继承父类的功能的时候，要在父类原有逻辑的基础上实现增强，不能改变父类的原有的逻辑，保证逻辑的一致性。","like_count":0},{"had_liked":false,"id":168820,"user_name":"ちよくん","can_delete":false,"product_type":"c1","uid":1398577,"ip_address":"","ucode":"B71E9B16E4408F","user_header":"https://static001.geekbang.org/account/avatar/00/15/57/31/6772744d.jpg","comment_is_top":false,"comment_ctime":1578192728,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578192728","product_id":100039001,"comment_content":"扩展父类的业务实现方案，但是不要修改业务规则以及协议规则","like_count":0},{"had_liked":false,"id":168380,"user_name":"Yangjing","can_delete":false,"product_type":"c1","uid":1018061,"ip_address":"","ucode":"D88DFD4958D07C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/88/cd/2c3808ce.jpg","comment_is_top":false,"comment_ctime":1578058320,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1578058320","product_id":100039001,"comment_content":"遵从里氏替换原则，再代码发生改变、扩展时，不会有异常。因为从语法上多态保证了编译时的正确，如果子类无法完全替换父类，有可能程序就会有一些没考虑到的异常","like_count":0},{"had_liked":false,"id":168116,"user_name":"fomy","can_delete":false,"product_type":"c1","uid":1125834,"ip_address":"","ucode":"CD87EA03B1F327","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/ca/02b0e397.jpg","comment_is_top":false,"comment_ctime":1578015499,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578015499","product_id":100039001,"comment_content":"1、应用场景有哪些？<br>答：子类实现父类所有的方法，并且对父类进行增强。符合开闭原则，对扩展开发，对修改关闭。<br><br>2、跟面向接口编程有什么区别？<br>答：（个人见解）面向接口编程也符合里氏替换原则，只是里氏替换原则的其中一种实现而已。想听听大家的理解。","like_count":0},{"had_liked":false,"id":168082,"user_name":"James","can_delete":false,"product_type":"c1","uid":1134861,"ip_address":"","ucode":"48B0F2A334D1C1","user_header":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","comment_is_top":false,"comment_ctime":1578012005,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578012005","product_id":100039001,"comment_content":"就是遵从父类语意，不修改原有逻辑以及程序正确性。","like_count":0},{"had_liked":false,"id":168011,"user_name":"程晓擘","can_delete":false,"product_type":"c1","uid":1328354,"ip_address":"","ucode":"96986D5AE2B96C","user_header":"https://static001.geekbang.org/account/avatar/00/14/44/e2/763526e9.jpg","comment_is_top":false,"comment_ctime":1577975540,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577975540","product_id":100039001,"comment_content":"二刷啦，里氏替换选择存在的意义，父类定义了规范，子类就应该照规范执行，要不就乱套啦，进一步思考，父类引用指向子类，我们拿着父类的引用，不知道指向的是哪个子类，所以子类必须遵守父类的规范，要不出了问题，开发者一头雾水。","like_count":0},{"had_liked":false,"id":167344,"user_name":"啦啦啦","can_delete":false,"product_type":"c1","uid":1131687,"ip_address":"","ucode":"6B12EC90A62525","user_header":"https://static001.geekbang.org/account/avatar/00/11/44/a7/171c1e86.jpg","comment_is_top":false,"comment_ctime":1577772074,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577772074","product_id":100039001,"comment_content":"这个原则就是子类可以修改父类的实现逻辑，但是不能改父类对外的约定","like_count":0},{"had_liked":false,"id":167305,"user_name":"Richie","can_delete":false,"product_type":"c1","uid":1019588,"ip_address":"","ucode":"12314EF0347693","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/c4/8d1150f3.jpg","comment_is_top":false,"comment_ctime":1577760235,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577760235","product_id":100039001,"comment_content":"个人理解，里氏替换原则与多态的关系，就是理论和实践的关系，里氏替换原则指导我们如何正确的使用多态特性。","like_count":0},{"had_liked":false,"id":167224,"user_name":"程晓擘","can_delete":false,"product_type":"c1","uid":1328354,"ip_address":"","ucode":"96986D5AE2B96C","user_header":"https://static001.geekbang.org/account/avatar/00/14/44/e2/763526e9.jpg","comment_is_top":false,"comment_ctime":1577720607,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577720607","product_id":100039001,"comment_content":"二刷喽，里氏替换选择存在的意义，父类定义了规范，子类就应该照规范执行，要不就乱套啦。","like_count":0},{"had_liked":false,"id":166561,"user_name":"汤小高","can_delete":false,"product_type":"c1","uid":1555565,"ip_address":"","ucode":"D4AB7766273D52","user_header":"https://static001.geekbang.org/account/avatar/00/17/bc/6d/f6f0a442.jpg","comment_is_top":false,"comment_ctime":1577501365,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577501365","product_id":100039001,"comment_content":"多态是一种编程语言提供的能力，LSP是限制滥用多态的一种原则和约束，即子类可以重写父类的方法，但是不能修改原父类方法本身要求实现的约定，包括要实现的功能、抛出的异常等，但是子类重写的方法中可以在原父类实现的功能基础上拓展一些新功能。不知道我理解是不是对的？","like_count":0},{"had_liked":false,"id":166080,"user_name":"Next","can_delete":false,"product_type":"c1","uid":1748213,"ip_address":"","ucode":"D5ADDF248A9504","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ac/f5/2f97e279.jpg","comment_is_top":false,"comment_ctime":1577375973,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577375973","product_id":100039001,"comment_content":"如果子类和父类的功能约定不一致，调用者就需要关注子类和父类的细节来保证调用的正确性，而且正确性没有保证；<br>输入输出约定不一致，客户就不能进行一致性调用，增加了额外编码量和维护成本，而且随着后续的扩展，代码将变得混乱复杂度，可读性，维护性将急剧增加！","like_count":0},{"had_liked":false,"id":165192,"user_name":"杨松","can_delete":false,"product_type":"c1","uid":1512517,"ip_address":"","ucode":"FB3C73BC44C94D","user_header":"https://static001.geekbang.org/account/avatar/00/17/14/45/adf079ae.jpg","comment_is_top":false,"comment_ctime":1577177943,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577177943","product_id":100039001,"comment_content":"老师您好，我遇到个问题，和这节课没什么关系，但困扰很久，不知道老师和一起学习的同学们是否有好的建议。问题如下：<br>我单位有俩个网段：132.XX.XX.XX和10.XX.XX.XX，我现在有一台centos7的服务器，里面部署着基于springboot开发的一个小系统，我现在想在该服务器上配置俩块网卡，132.XX.XX.101和10.XX.XX.101，想让两个网段的用户都可以访问，但配置过程中发现我只能在一块网卡的配置文件中添加网关，这样现在造成只能是网关的那个网段可以访问系统，另一个网段的用户根本平ping不通，请问大家有什么好办法吗？","like_count":0},{"had_liked":false,"id":164265,"user_name":"EdisonLi","can_delete":false,"product_type":"c1","uid":1505950,"ip_address":"","ucode":"A85CBF3E2B5620","user_header":"https://static001.geekbang.org/account/avatar/00/16/fa/9e/306a5ce7.jpg","comment_is_top":false,"comment_ctime":1576919637,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576919637","product_id":100039001,"comment_content":"举个Android开发的例子，比如我现在想要实现加载图片功能，想获取Bitmap,然后加载，父类定义一个接口用来拿到Bitmap实现加载图片的逻辑，假如子类继承的父类老版本使用的ImageLoader框架进行加载，现在我想要使用Glide进行加载图片，其实最终的目的就是拿到图片的bitmap，我不管你用什么框架进行加载图片。","like_count":0},{"had_liked":false,"id":164129,"user_name":"AaronChun","can_delete":false,"product_type":"c1","uid":1027352,"ip_address":"","ucode":"0D4A4CBD676A3D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ad/18/41831eae.jpg","comment_is_top":false,"comment_ctime":1576892321,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576892321","product_id":100039001,"comment_content":"多态于里氏替换原则区别：多态是编程语言中支持的一种特性，增强程序设计的扩展性和复用性，里氏替换是对继承关系中子类该如何设计作出说明。","like_count":0},{"had_liked":false,"id":163847,"user_name":"yu","can_delete":false,"product_type":"c1","uid":1138645,"ip_address":"","ucode":"56856DCC0C8387","user_header":"https://static001.geekbang.org/account/avatar/00/11/5f/d5/2fec2911.jpg","comment_is_top":false,"comment_ctime":1576810840,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576810840","product_id":100039001,"comment_content":"个人理解，LSP存在的意义是为了统一子类和父类的行为，对调用方更可控；避免调用时因为行为不一致，或者新加了子类后出现了新的异常，而调用方未处理的情况。","like_count":0},{"had_liked":false,"id":163833,"user_name":"被歌唱拯救中","can_delete":false,"product_type":"c1","uid":1153342,"ip_address":"","ucode":"84E73FB0D1E56A","user_header":"https://static001.geekbang.org/account/avatar/00/11/99/3e/8a813e51.jpg","comment_is_top":false,"comment_ctime":1576808993,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576808993","product_id":100039001,"comment_content":"在使用父类的角度有疑问：<br><br>针对子类做针对性的编程(即向下转型，而且是安全的向下转型)是否可取？是否违反了里氏替换原则？<br>给人的感觉是，其实是已经违反了里氏替换原则，这样做只是在违反之后采用的补救措施。<br>java提供这样的语法，是不是有他的设计考虑？什么时候可以这样使用。<br>例如：<br>```java<br>    public void method(BaseClass baseInstance) {<br>        if (baseInstance instanceof ASubClass) {<br>            ASubClass subInstance = (ASubClass)baseInstance;<br>            subInstance.xxxx();<br>        }<br>    }<br>```","like_count":0},{"had_liked":false,"id":163567,"user_name":"August","can_delete":false,"product_type":"c1","uid":1747702,"ip_address":"","ucode":"21794846E0E510","user_header":"https://static001.geekbang.org/account/avatar/00/1a/aa/f6/66cc1bcb.jpg","comment_is_top":false,"comment_ctime":1576746555,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1576746555","product_id":100039001,"comment_content":"我觉得LSP的意义在于，能够完美继承父类现有的约定的同时，又能灵活的按照自己的需求进行重写，就像原则中规定的一样，不要人为的去破坏这种已有的约定就好","like_count":0,"discussions":[{"author":{"id":1252107,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1b/0b/bf56c9e7.jpg","nickname":"bing5tui3","note":"","ucode":"7A313BAC3E6665","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":98801,"discussion_content":"赞同，里氏替换的主要指导思想还是不要去重写父类的方法！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577187121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163130,"user_name":"蜗牛","can_delete":false,"product_type":"c1","uid":1086220,"ip_address":"","ucode":"01CC18F12E556D","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/0c/0a6a0d5e.jpg","comment_is_top":false,"comment_ctime":1576661036,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576661036","product_id":100039001,"comment_content":"有条理、有深度地讲一讲里式替换原则存在的意义。<br>：兼容以前实现的代码，减少出错的可能性","like_count":0},{"had_liked":false,"id":163098,"user_name":"shniu","can_delete":false,"product_type":"c1","uid":1019555,"ip_address":"","ucode":"E64CD8BED96D8D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/a3/d7e5fe8a.jpg","comment_is_top":false,"comment_ctime":1576656269,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576656269","product_id":100039001,"comment_content":"LSP 的意义是应对复杂多变的需求<br>首先，我们要合作方之间设计规范，设计约束，设计如何共同完成一件事情<br>其次，有了规范，可能在不同阶段会有不同的实现来满足不同阶段的发展，那每种实现都必须严格符合规范和约束，不能随意变动，这也是为了尽可能保护协议的稳定性，做到对扩展开放","like_count":0},{"had_liked":false,"id":162941,"user_name":"陈拾柒","can_delete":false,"product_type":"c1","uid":1473069,"ip_address":"","ucode":"22213E2FA5143A","user_header":"https://static001.geekbang.org/account/avatar/00/16/7a/2d/e3a5c52e.jpg","comment_is_top":false,"comment_ctime":1576632932,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576632932","product_id":100039001,"comment_content":"有两个疑问，希望老师解答一下 <br>1. 对于某些没有抽象类的语言，例如oc，自己实现抽象类的逻辑的时候，定义好抽象类，但是在抽象类中的方法实现，都使用NSAssert去抛出异常，这样在开发的时候就可以不能直接使用抽象类，子类必须重写实现抽象类的方法才行。 这种是否违背了里氏替换原则，是否有必要在父类中使用assert抛出异常？ <br>2. 对于里氏替换原则，子类输入参数的类型范围必须大于父类，这个我可以理解。但是输出类型，准确的说应该是子类输出参数的类型和父类相同或者是父类输出参数的子类吧？老师这一点说的不是很详细，觉得可以作为补充。","like_count":0},{"had_liked":false,"id":162675,"user_name":"二十四","can_delete":false,"product_type":"c1","uid":1341111,"ip_address":"","ucode":"9EFA55E9636289","user_header":"https://static001.geekbang.org/account/avatar/00/14/76/b7/3ac99a8f.jpg","comment_is_top":false,"comment_ctime":1576576582,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576576582","product_id":100039001,"comment_content":"里氏替换原则的意义：从灵活性上讲，代码调用方的逻辑不需要做修改；从可读性上讲，父类的方法含义和注释不会与子类产生冲突。","like_count":0},{"had_liked":false,"id":162632,"user_name":"斐波那契","can_delete":false,"product_type":"c1","uid":1464006,"ip_address":"","ucode":"85E2EBC01392B1","user_header":"https://static001.geekbang.org/account/avatar/00/16/56/c6/0b449bc6.jpg","comment_is_top":false,"comment_ctime":1576569835,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576569835","product_id":100039001,"comment_content":"听完这一讲感觉又迷惑了 不违反约定这个可以理解 但是子类不能“修改”父类这个就不清楚了 拿这一讲里面一个例子--子类对于负数就抛异常 相对于父类要求更严格了--来说，如果需求是要求变严格那应该怎么改？直接在父类上改么？","like_count":0},{"had_liked":false,"id":162398,"user_name":"|･ω･｀)","can_delete":false,"product_type":"c1","uid":1636123,"ip_address":"","ucode":"34E1DF62058D80","user_header":"https://static001.geekbang.org/account/avatar/00/18/f7/1b/8036958c.jpg","comment_is_top":false,"comment_ctime":1576509157,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576509157","product_id":100039001,"comment_content":"我对里氏替换原则的理解是：外部在调用子类的时候，和调用父类是一样的，不会导致其他的效果或者影响流程<br>外部可以安全地替换任意实现类","like_count":0},{"had_liked":false,"id":162339,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1576501721,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576501721","product_id":100039001,"comment_content":"校验是否满足里氏替换原则：使用父类的单元测试去测试字类的功能模块","like_count":0},{"had_liked":false,"id":162318,"user_name":"我的心里只有工作","can_delete":false,"product_type":"c1","uid":1238185,"ip_address":"","ucode":"488DD6F9590EB8","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/a9/117fe480.jpg","comment_is_top":false,"comment_ctime":1576499458,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576499458","product_id":100039001,"comment_content":"今天看了文章，才明白里氏替换原则","like_count":0},{"had_liked":false,"id":162228,"user_name":"Kevin","can_delete":false,"product_type":"c1","uid":1429627,"ip_address":"","ucode":"9DFFD6E3960CF7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJN64OCUT0Jp0h2Wiau9Os0o1WbwUeoq2QL0U2vZpib8ozPxo0XDiaPM9xcKfbkoBL24ztEHelxPIMVg/132","comment_is_top":false,"comment_ctime":1576480745,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576480745","product_id":100039001,"comment_content":"LSP  可以理解为是 开闭原则的边界约束。  对扩展开放，开放到什么程度，不能开放到修改了原有代码逻辑。也是对修改关闭的一种体现。","like_count":0},{"had_liked":false,"id":162222,"user_name":"马哲富","can_delete":false,"product_type":"c1","uid":1107917,"ip_address":"","ucode":"D6BDDFE3CC07ED","user_header":"https://static001.geekbang.org/account/avatar/00/10/e7/cd/08088f14.jpg","comment_is_top":false,"comment_ctime":1576479976,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576479976","product_id":100039001,"comment_content":"听完感觉恍然大悟","like_count":0},{"had_liked":false,"id":162100,"user_name":"堵车","can_delete":false,"product_type":"c1","uid":1145404,"ip_address":"","ucode":"7BC1E50A4F8D3D","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/3c/87e015f8.jpg","comment_is_top":false,"comment_ctime":1576461551,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576461551","product_id":100039001,"comment_content":"违背了里氏替换原则会有什么后果呢？比如有个订单查询方法，参数有多个。父类允许参数都是空，子类要求必须有一个值不为空。子类校验了参数，抛出异常。这样就会违反历史替换原则。这样改回导致什么问题呢？","like_count":0},{"had_liked":false,"id":161940,"user_name":"Douglas","can_delete":false,"product_type":"c1","uid":1073027,"ip_address":"","ucode":"CFDE3D76B9DAE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/83/bb728e53.jpg","comment_is_top":false,"comment_ctime":1576410007,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576410007","product_id":100039001,"comment_content":"还是争哥牛， 总是把别人解释不通不明的说的彻底。","like_count":0},{"had_liked":false,"id":161915,"user_name":"炫炫","can_delete":false,"product_type":"c1","uid":1358609,"ip_address":"","ucode":"FDC7A0C6E08B02","user_header":"https://static001.geekbang.org/account/avatar/00/14/bb/11/7069b8eb.jpg","comment_is_top":false,"comment_ctime":1576400831,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576400831","product_id":100039001,"comment_content":"里氏替换原则是设计准则，多态是我们实现子类时候用到的编程方法，  我们设计子类时候应当按照里氏替换原则的准则去设计，当然编程是自由的。","like_count":0},{"had_liked":false,"id":161819,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1576339491,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576339491","product_id":100039001,"comment_content":"里式替换原则存在的意义：对面向对象程序开发中子类和父类的设计有明确的指导作用—子类应该在不影响父类功能的前提下进行功能增强","like_count":0},{"had_liked":false,"id":161732,"user_name":"小刀","can_delete":false,"product_type":"c1","uid":1351063,"ip_address":"","ucode":"94DF8C45E09E42","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/iaByN5IfYbE9jMtWrtTDXtPEIHeV77KW1p7ZkiasiaGgA50VXaibo4fbp5ib2JkFP3iaIe4AUudLibufkEIofu5euCNHg/132","comment_is_top":false,"comment_ctime":1576310018,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576310018","product_id":100039001,"comment_content":"扩展而非修改","like_count":0},{"had_liked":false,"id":161670,"user_name":"李稳","can_delete":false,"product_type":"c1","uid":1401912,"ip_address":"","ucode":"B8164B6B65E26C","user_header":"https://static001.geekbang.org/account/avatar/00/15/64/38/1bd1324e.jpg","comment_is_top":false,"comment_ctime":1576292148,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576292148","product_id":100039001,"comment_content":"里式替换：按协议设计，子类可以改变逻辑，但不能改变约定.<br>约定1.功能2.输入输出异常3.注释<br>多态：java语法特性<br>里式替换：设计原则，执导子类设计","like_count":0},{"had_liked":false,"id":161602,"user_name":"join","can_delete":false,"product_type":"c1","uid":1130132,"ip_address":"","ucode":"C097D89F7BA3EF","user_header":"https://static001.geekbang.org/account/avatar/00/11/3e/94/c6460883.jpg","comment_is_top":false,"comment_ctime":1576244862,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576244862","product_id":100039001,"comment_content":"多态是面向对象编程的一种特征，而里氏替换是编程的设计原则，里氏替换可以通过多态的方式来实现。<br>里氏替换比多态有更多的约束。","like_count":0},{"had_liked":false,"id":161564,"user_name":"Miaozhe","can_delete":false,"product_type":"c1","uid":1113660,"ip_address":"","ucode":"62872E8C138B67","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","comment_is_top":false,"comment_ctime":1576233639,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576233639","product_id":100039001,"comment_content":"里氏替换，能写出低耦合的代码，方便扩展，重减少重构的影响。<br><br>不过如果基类设计的质量差，会影响后续子类的实现。","like_count":0},{"had_liked":false,"id":161563,"user_name":"Miaozhe","can_delete":false,"product_type":"c1","uid":1113660,"ip_address":"","ucode":"62872E8C138B67","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","comment_is_top":false,"comment_ctime":1576233371,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576233371","product_id":100039001,"comment_content":"多态是思想，指导大家实现程序的可扩展性。<br>里氏替换原则，是原则和规范，能约束大家，写出可读性,可维护性强的程序。","like_count":0},{"had_liked":false,"id":161541,"user_name":"相逢是缘","can_delete":false,"product_type":"c1","uid":1060730,"ip_address":"","ucode":"CB299F53A95654","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg","comment_is_top":false,"comment_ctime":1576226515,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576226515","product_id":100039001,"comment_content":"打卡<br>1、里式替换原则定义：子类对象可以替换程序中任何地方的父类对象，替换之后程序的逻辑和正确性保持不变；<br>2、核心是&quot;按协议来设计&quot;，父类定义函数的“约定”，子类可以改变内部分实现逻辑，但是不能改变约定。具体来说需要遵循以下规则不能改变：<br>1）函数声明要实现的功能<br>2）输入、输出及异常<br>3）其他的特殊的约定和说明<br> \t从上层接口设计看，这要求在进行接口或父类设计时对上层的约定足够抽象，比较通用。从子类设计看，不要破坏上层的协议约定。<br>3、里式替换和多态的区别：关注的角度不一样，多态是面向对象语言的一种语法，是编程的一种实现思路。里式替换原则是一种设计原则，用来指导继承关系中子类如何进行设计","like_count":0},{"had_liked":false,"id":161475,"user_name":"NYang","can_delete":false,"product_type":"c1","uid":1239235,"ip_address":"","ucode":"FCDB3246D1195A","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/c3/11479173.jpg","comment_is_top":false,"comment_ctime":1576213715,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576213715","product_id":100039001,"comment_content":"课堂笔记<br><br>里式替换原则是一种代码的设计规范，更多是人为约束的。不同于多态，多态是代码的特性。<br><br>多态保证子类在替换父类的过程中程序运行正常，但不要求子类实现符合父类的规范。<br><br>而里式替换规定子类的实现必须符合父类的规范，包括但不限于方法的入参，出参，异常等。","like_count":0},{"had_liked":false,"id":161427,"user_name":"丿淡忘","can_delete":false,"product_type":"c1","uid":1139645,"ip_address":"","ucode":"604AE01961A026","user_header":"https://static001.geekbang.org/account/avatar/00/11/63/bd/80f587ad.jpg","comment_is_top":false,"comment_ctime":1576204300,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1576204300","product_id":100039001,"comment_content":"lsp存在的意义直白点应该就是保证代码的可读性吧","like_count":0},{"had_liked":false,"id":161358,"user_name":"小先生","can_delete":false,"product_type":"c1","uid":1055214,"ip_address":"","ucode":"E5F2052E0323C0","user_header":"https://static001.geekbang.org/account/avatar/00/10/19/ee/e395a35e.jpg","comment_is_top":false,"comment_ctime":1576198040,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576198040","product_id":100039001,"comment_content":"如果就是需要改变父类的实现和期望输出。应该怎么做？","like_count":0},{"had_liked":false,"id":161356,"user_name":"Geek_e7834d","can_delete":false,"product_type":"c1","uid":1530493,"ip_address":"","ucode":"ABAF1B1B7E6490","user_header":"","comment_is_top":false,"comment_ctime":1576197833,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576197833","product_id":100039001,"comment_content":"子类是父类契约的具体实现， 但是子类如果扩展了父类怎么办？扩展的功能在调用的时候就无法使用父类的接口， 只能转换为子类来调用。这种情况怎么解决呢？ 增加另外一个接口来描述扩展的部分功能？","like_count":0},{"had_liked":false,"id":161355,"user_name":"quietwater","can_delete":false,"product_type":"c1","uid":1055029,"ip_address":"","ucode":"C25E2CD356D3F9","user_header":"https://static001.geekbang.org/account/avatar/00/10/19/35/be8372be.jpg","comment_is_top":false,"comment_ctime":1576197737,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576197737","product_id":100039001,"comment_content":"里式替换原则存在的意义在于面向抽象编程，也就是面向约定编程，父类定义了约定，子类遵守约定，使用时只使用父类，也就是向上转型，符合开闭原则。","like_count":0},{"had_liked":false,"id":161290,"user_name":"小海","can_delete":false,"product_type":"c1","uid":1183874,"ip_address":"","ucode":"E566E4B9E9852C","user_header":"https://static001.geekbang.org/account/avatar/00/12/10/82/f5a3ecf5.jpg","comment_is_top":false,"comment_ctime":1576166597,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576166597","product_id":100039001,"comment_content":"里氏替换主要用来指导子类如何设计，而子类存在的意义就在于功能的扩展，结合里氏替换的定义，得出该原则存在的意义在于保证原有功能稳定的前提下（兼容性），做出更具备健壮性的功能扩展。","like_count":0},{"had_liked":false,"id":161284,"user_name":"Jackey","can_delete":false,"product_type":"c1","uid":1063751,"ip_address":"","ucode":"125DE81993FEDD","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/47/f6c772a1.jpg","comment_is_top":false,"comment_ctime":1576165958,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576165958","product_id":100039001,"comment_content":"前面提到许多设计模式和设计原则都是为了代码的可扩展性。我认为LSP也是，当代码需要修改时，直接继承一个类，进行修改，讲父类应用之处都替换成子类。从而达到扩展功能的目的。不知道这样理解对不对","like_count":0},{"had_liked":false,"id":161275,"user_name":"xuanyuan","can_delete":false,"product_type":"c1","uid":1113737,"ip_address":"","ucode":"1EC79B9372868F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2icbib62icXtibTkThtyRksbuJLoTLMts7zook2S30MiaBtbz0f5JskwYicwqXkhpYfvCpuYkcvPTibEaQ/132","comment_is_top":false,"comment_ctime":1576163267,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576163267","product_id":100039001,"comment_content":"这讲非常赞，考虑到大多数人会把里式替换原则理解为多态。关键是把抽象的原则给出了具体可实施的标准","like_count":0},{"had_liked":false,"id":161250,"user_name":"连边","can_delete":false,"product_type":"c1","uid":1391748,"ip_address":"","ucode":"54B5DA38449728","user_header":"https://static001.geekbang.org/account/avatar/00/15/3c/84/608f679b.jpg","comment_is_top":false,"comment_ctime":1576156915,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576156915","product_id":100039001,"comment_content":"另外一种方式接口约定存在，接口是项目一开始就定义好的，而利用里氏替换原则来重写方法，也是保证返回值与参数的一致性，从而可以达到兼容的目的。","like_count":0},{"had_liked":false,"id":161246,"user_name":"AgCl","can_delete":false,"product_type":"c1","uid":1408804,"ip_address":"","ucode":"2C7660E3C5565D","user_header":"https://static001.geekbang.org/account/avatar/00/15/7f/24/719ce9d4.jpg","comment_is_top":false,"comment_ctime":1576156136,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576156136","product_id":100039001,"comment_content":"听完之后，虽然老师强调了多态和里式替换原则是两个概念，总觉得多态的效果是不符合里式替换原则而有意义的","like_count":0},{"had_liked":false,"id":161229,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1576152017,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576152017","product_id":100039001,"comment_content":"是人就要吃饭。<br>男人是人，所以男人也要吃饭。<br>女人是人，所以女人也要吃饭。","like_count":0},{"had_liked":false,"id":161210,"user_name":"CarlXu","can_delete":false,"product_type":"c1","uid":1585713,"ip_address":"","ucode":"6A5DF4459907C2","user_header":"https://static001.geekbang.org/account/avatar/00/18/32/31/449513a1.jpg","comment_is_top":false,"comment_ctime":1576148951,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576148951","product_id":100039001,"comment_content":"多态不是为了实现和父类不一定的功能的吗？ 如果子类完全遵守父类的约定，就直接使用父类方法就好了，干嘛要重写呢。 ","like_count":0},{"had_liked":false,"id":161057,"user_name":"醉比","can_delete":false,"product_type":"c1","uid":1248399,"ip_address":"","ucode":"79E65F62BE7809","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/8f/4ebd303a.jpg","comment_is_top":false,"comment_ctime":1576111233,"is_pvip":false,"replies":[{"id":"61497","content":"我自己觉得意义也不大 你可以看下我文章里的说明😂","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1576199336,"ip_address":"","comment_id":161057,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1576111233","product_id":100039001,"comment_content":"第一遍学完这节课，我的问题就是里式替换存在的意义是为啥哈哈哈哈","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477589,"discussion_content":"我自己觉得意义也不大 你可以看下我文章里的说明😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576199336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161037,"user_name":"王喜春","can_delete":false,"product_type":"c1","uid":1022349,"ip_address":"","ucode":"436E91FDED1B30","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/8d/4d5dbfc5.jpg","comment_is_top":false,"comment_ctime":1576104908,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576104908","product_id":100039001,"comment_content":"想了解下，使用里氏代换后系统的带来的好处，如哪些开源框架中有使用？<br>另一方面， 现在的业务系统“设计”（姑且叫设计）时，大多不知这个原则，体现的问题是？怎么破解？","like_count":0},{"had_liked":false,"id":161034,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1576097513,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576097513","product_id":100039001,"comment_content":"多态是分离接口与实现，以及抽象类与具体类的具体工具，是编程语言层面的功能。里氏替换替换原则是从对象运行的环境去审视对象的公共方法和属性。所有能够满足接口的对象不但要满足了接口或者基类语言层面的约束（这一点和多态类似），也要满足所有接口和基类功能层面的约束（这一点和多态不同）。<br>我想Java编译期的异常可能就是基于这个层面设计的。但是把异常分为编译期和运行期也增加了很多编程负担，新的语言Kotlin就没有这项区分。<br>我个人觉得这条原则实战中用的不多，因为异常，类型检查等通常是实现细节，放到基类和接口中本身就很值得商榷，接口或者基类足够抽象，派生类足够灵活，一般也就够用了。","like_count":0},{"had_liked":false,"id":161024,"user_name":"筱乐乐哦","can_delete":false,"product_type":"c1","uid":1307611,"ip_address":"","ucode":"AE92539F0419C3","user_header":"https://static001.geekbang.org/account/avatar/00/13/f3/db/5b7a8fd8.jpg","comment_is_top":false,"comment_ctime":1576082516,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576082516","product_id":100039001,"comment_content":"<br>如果不遵循里氏替换原则，可能会有以下问题：<br>1、类继承会变得很混乱，因此奇怪的行为会发生<br>2、对于父类的单元测试对于子类是无效的，因此会降低代码的可测试性和验证程度<br>个人想法：<br>1、可以通过在子类中调用父类的公有方法来获取一些内部状态变量，而不是直接使用它。这样我们就可以保证父类抽象中正确的状态语义，从而避免了副作用和非法的状态转变。<br>2、父类设计的应该简单单一，这样子类才能方便拓展，如果一个父类是比较复杂的，那么子类在覆盖它的时候，在不影响父类状态语义的情况下进行扩展绝非易事。<br>3、可以检测出自己开发的新功能是否对原有功能产生了影响，这点我感觉很重要<br>","like_count":0},{"had_liked":false,"id":161016,"user_name":"王小念","can_delete":false,"product_type":"c1","uid":1057147,"ip_address":"","ucode":"2062E25909B8E0","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/7b/53a325d1.jpg","comment_is_top":false,"comment_ctime":1576079702,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576079702","product_id":100039001,"comment_content":"“里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。” 这里讲到‘不改变原有程序的逻辑’。 <br>后面“父类定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。” 这里又讲到‘可以改变内部时间逻辑’。<br>乍一看感觉有点矛盾和疑惑。<br>后来想想，前者可能是指的整个程序上的业务逻辑，后者指的是如何实现这些业务逻辑的具体函数的实现逻辑，不知道理解的对不对？","like_count":0},{"had_liked":false,"id":160923,"user_name":"柳志焕","can_delete":false,"product_type":"c1","uid":1235940,"ip_address":"","ucode":"42375930DC2AA0","user_header":"https://static001.geekbang.org/account/avatar/00/12/db/e4/a1b45d79.jpg","comment_is_top":false,"comment_ctime":1576060986,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576060986","product_id":100039001,"comment_content":"里式替换原则存在的意义：子类可以扩展父类的功能，但不能改变父类原有的功能。","like_count":0},{"had_liked":false,"id":160920,"user_name":"蛤蟆先生","can_delete":false,"product_type":"c1","uid":1125703,"ip_address":"","ucode":"8353492D68DBBF","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/47/7c3baa15.jpg","comment_is_top":false,"comment_ctime":1576060458,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576060458","product_id":100039001,"comment_content":"取钱那个例子，子类可以透支取钱为什么就不符合里氏替换原则了呢，而且对于设计原则来讲，难道不应该刨除业务逻辑吗","like_count":0},{"had_liked":false,"id":160919,"user_name":"左","can_delete":false,"product_type":"c1","uid":1048799,"ip_address":"","ucode":"FE02803AE2C0F0","user_header":"https://static001.geekbang.org/account/avatar/00/10/00/df/58fe37df.jpg","comment_is_top":false,"comment_ctime":1576060376,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576060376","product_id":100039001,"comment_content":"所有的多态实现，假如不遵循里氏替换原则，就会出异常。","like_count":0},{"had_liked":false,"id":160918,"user_name":"刘大明","can_delete":false,"product_type":"c1","uid":1035081,"ip_address":"","ucode":"83C063FBD9BF2B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cb/49/0b9ffc8e.jpg","comment_is_top":false,"comment_ctime":1576060295,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576060295","product_id":100039001,"comment_content":"里式替换原则。我觉得应该是父类替换子类，程序的行为没有任何变化。正是因为此，才让开闭原则成为了可能。对修改关闭，对扩展开放。","like_count":0},{"had_liked":false,"id":160883,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1576053426,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576053426","product_id":100039001,"comment_content":"课堂讨论answer:<br><br>    里氏替换原则(LSP)是OOD中继承方面的指导原则：凡是父类实例存在的地方，应该可以用子类实例替换，且程序不被破坏。<br><br>    从程序设计角度自顶向下看，LSP鼓励使用多态的方式设计api。<br><br>    从编码实现的角度看， LSP约束子类慎重的实现从父类继承的方法，让开发者更谨慎的实现子类，不要违反父类的Contract，从而提升代码的健壮性。","like_count":0},{"had_liked":false,"id":160875,"user_name":"[耶]友超","can_delete":false,"product_type":"c1","uid":1400962,"ip_address":"","ucode":"890572F77C3670","user_header":"https://static001.geekbang.org/account/avatar/00/15/60/82/9a43504b.jpg","comment_is_top":false,"comment_ctime":1576052219,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576052219","product_id":100039001,"comment_content":"&quot;里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。&quot;我感觉这就是答案了，为了保证父类的方法被子类重写时，其基本逻辑不会被改变。","like_count":0},{"had_liked":false,"id":160833,"user_name":"辉仔lovers","can_delete":false,"product_type":"c1","uid":1210219,"ip_address":"","ucode":"3DC5B0CD0B8E71","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLVhJRVwJ0eVlC7zjNfWP6PP7VmUkF1X2m6qfh7Wic3NhAOz2fSGibF6LXLcJ59zOz7nBpCcByvtFjw/132","comment_is_top":false,"comment_ctime":1576043485,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576043485","product_id":100039001,"comment_content":"之前没有想过多态和里式替换的关系，以为使用多态，子类就可以替换掉父类。<br>总结：多态是面向对象的编程方式。里式替换是一种设计原则，指导子类是如何设计的。","like_count":0},{"had_liked":false,"id":160828,"user_name":"LJK","can_delete":false,"product_type":"c1","uid":1199213,"ip_address":"","ucode":"12B2441099FF1D","user_header":"https://static001.geekbang.org/account/avatar/00/12/4c/6d/c20f2d5a.jpg","comment_is_top":false,"comment_ctime":1576041737,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1576041737","product_id":100039001,"comment_content":"接口类也适用吗？","like_count":0,"discussions":[{"author":{"id":1114452,"avatar":"https://static001.geekbang.org/account/avatar/00/11/01/54/46266631.jpg","nickname":"gwen","note":"","ucode":"82A01FD8458671","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":135974,"discussion_content":"同问？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579103284,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160825,"user_name":"Eden Ma","can_delete":false,"product_type":"c1","uid":1457408,"ip_address":"","ucode":"755312F0D154F9","user_header":"https://static001.geekbang.org/account/avatar/00/16/3d/00/7daa7403.jpg","comment_is_top":false,"comment_ctime":1576040958,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576040958","product_id":100039001,"comment_content":"LSP存在的意义我觉得应该是提高了代码的稳定性和易于理解性，后续维护可以更清晰的明白子类的职责，减少一些不明所以的状况发生。","like_count":0},{"had_liked":false,"id":160820,"user_name":"Crazy.","can_delete":false,"product_type":"c1","uid":1066838,"ip_address":"","ucode":"FB093FE6E0A66B","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/56/e22477c7.jpg","comment_is_top":false,"comment_ctime":1576039847,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576039847","product_id":100039001,"comment_content":"子类可以扩展父类的功能，但不能改变父类原有的功能","like_count":0},{"had_liked":false,"id":160811,"user_name":"秋惊蛰","can_delete":false,"product_type":"c1","uid":1620344,"ip_address":"","ucode":"3D9A6D5CA9C79F","user_header":"https://static001.geekbang.org/account/avatar/00/18/b9/78/a5804dae.jpg","comment_is_top":false,"comment_ctime":1576036293,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576036293","product_id":100039001,"comment_content":"如果想用可替换的组件来构建软件系统, 那么这些组件就必须遵守同一个约定, 以便让这些组件可以相互替换.<br>事实上, 这不止是父类和子类之间的关系, 而是接口与实现之间的应该遵守的原则.","like_count":0},{"had_liked":false,"id":160794,"user_name":"程序员小跃","can_delete":false,"product_type":"c1","uid":1015483,"ip_address":"","ucode":"25BB96E0791A60","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","comment_is_top":false,"comment_ctime":1576033400,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576033400","product_id":100039001,"comment_content":"我所理解的里式替换，最重要的意义在于子类是对父类的进一步的从内容上扩充，但是最终返回的是和父类实现一样的结果。<br><br>就像楼上“辣么大”说的第一条，优化父类的算法，提高性能；或者优化里面实现的函数，数据结构的方式，达到自定义的条件，但是最终呈现回同一个想要的结果，这点意义重大。<br><br>这样就能很好的扩充现有的一些父类不足的地方，我们可以更好的去操作","like_count":0},{"had_liked":false,"id":160791,"user_name":"pines","can_delete":false,"product_type":"c1","uid":1200708,"ip_address":"","ucode":"7B925605B36B4E","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/44/de7f2b98.jpg","comment_is_top":false,"comment_ctime":1576032979,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576032979","product_id":100039001,"comment_content":"1.里式替换原则 是子类重写父类接口的限定，不过内部逻辑怎么处理，但是结果的返回，错误的处理必须完全一致。<br>2.他的存在意义让开闭原则变得更加健壮。在此降低了业务代码修改的风险","like_count":0},{"had_liked":false,"id":160772,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1576031240,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576031240","product_id":100039001,"comment_content":"里氏替换原则可以认为是开闭原则的一种具体运用。子类替换父类，实现了功能的“扩展”，并且修改没有影响原来的使用逻辑，因此可以认为是“关闭的”。<br>","like_count":0},{"had_liked":false,"id":160771,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1576031007,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576031007","product_id":100039001,"comment_content":"订单排序的反例：<br>如果从原有的按照金额排序，变为了按照创建时间排序，是不行的。<br>但是，如果从单纯按照金额排序，变成了，首要排序条件是金额，次要排序条件是创建时间，这种情况违背里氏替换吗？<br>","like_count":0},{"had_liked":false,"id":160769,"user_name":"潇潇雨歇","can_delete":false,"product_type":"c1","uid":1251429,"ip_address":"","ucode":"4BD52BF0F0A084","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/65/35361f02.jpg","comment_is_top":false,"comment_ctime":1576030929,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576030929","product_id":100039001,"comment_content":"里氏替换原则是一种协议，约定；对于子类的约定，必须要遵守父类函数的约定，如果子类破坏了原有的设计，说明设计没有弄好，我觉得这是设计层面上的指导意义。","like_count":0},{"had_liked":false,"id":160747,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1576028778,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576028778","product_id":100039001,"comment_content":"虽然多态和lsp角度不同，但感觉lsp也是对多态的一种扩展或补充。","like_count":0},{"had_liked":false,"id":160746,"user_name":"Yayu","can_delete":false,"product_type":"c1","uid":1058015,"ip_address":"","ucode":"5E7842458D8229","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/df/645f8087.jpg","comment_is_top":false,"comment_ctime":1576028771,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576028771","product_id":100039001,"comment_content":"只可意会不可言传的东西是不是都不够有生命力？面向协议设计，为什么不把里氏替换原则中的父类替换成接口？如果换成了接口，这个原则有什么必要存在吗？","like_count":0},{"had_liked":false,"id":160745,"user_name":"evolution","can_delete":false,"product_type":"c1","uid":1088402,"ip_address":"","ucode":"105C59822BF75B","user_header":"https://static001.geekbang.org/account/avatar/00/10/9b/92/c0863297.jpg","comment_is_top":false,"comment_ctime":1576028677,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576028677","product_id":100039001,"comment_content":"里氏替换是代码涉及多态时，需要参考的一个原则。目的是对外提供一致性的输入输出值","like_count":0},{"had_liked":false,"id":160741,"user_name":"weineel","can_delete":false,"product_type":"c1","uid":1049741,"ip_address":"","ucode":"6DC6EF4F256A53","user_header":"https://static001.geekbang.org/account/avatar/00/10/04/8d/005c2ff3.jpg","comment_is_top":false,"comment_ctime":1576027761,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1576027761","product_id":100039001,"comment_content":"重写的父类方法时，其子类实现对方法外部环境的影响应该小于等于父类。<br><br>子类-&gt;父类， 实现类-&gt;接口。","like_count":0},{"had_liked":false,"id":160736,"user_name":"拂尘","can_delete":false,"product_type":"c1","uid":1609964,"ip_address":"","ucode":"9563C002E4B06A","user_header":"https://static001.geekbang.org/account/avatar/00/18/90/ec/ede93589.jpg","comment_is_top":false,"comment_ctime":1576027313,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576027313","product_id":100039001,"comment_content":"感觉里式替换原则的话，也是上一章的开闭原则的一个支撑咯。因为只有当完全遵守约定进行的扩展，才能够在不修改原有代码的基础，完美的兼容。","like_count":0},{"had_liked":false,"id":160734,"user_name":"子夜2104","can_delete":false,"product_type":"c1","uid":1070286,"ip_address":"","ucode":"C4FF54AEA6002F","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/ce/92029d2f.jpg","comment_is_top":false,"comment_ctime":1576027163,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576027163","product_id":100039001,"comment_content":"里氏替换<br><br>子类可以在任何地方替换父类，而不影响原有程序的逻辑行为。<br>里氏替换的好处还是为了使得代码有更好的扩展性和维护性，父类和子类有一样的行为，也方便测试。<br><br>里氏替换最核心的就是design by contract，按照协议来设计这几个字。父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数原有的“约定”。这里的约定包括：<br><br>函数声明要实现的功能；<br>对输入、输出、异常的约定；<br>甚至包括注释中所罗列的任何特殊说明。<br>里氏替换和多态还是不一样的，多态是子类可以替换父类，更多情况是在形参上父类接受子类，就可以了。而里氏替换还需要满足约定，替换后，程序逻辑、功能、行为、表达含义还是要跟原有的一样。","like_count":0},{"had_liked":false,"id":160733,"user_name":"编程界的小学生","can_delete":false,"product_type":"c1","uid":1593289,"ip_address":"","ucode":"4A5BE9A5E877FA","user_header":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","comment_is_top":false,"comment_ctime":1576027138,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576027138","product_id":100039001,"comment_content":"我觉得里氏替换也采取了面向对象的多态特性，只是再多态的基础上多了几个约束条件，使函数变的有条不紊。","like_count":0},{"had_liked":false,"id":160725,"user_name":"PHP是世界上最好的需要","can_delete":false,"product_type":"c1","uid":1655326,"ip_address":"","ucode":"EE23A54B831D17","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIma3PJUyqDEQKt40nEh3Jt840af6hKnuK8k8dIscm43EUzJwLvynbxRnvO9Ivibv7KssUSqoBdY1w/132","comment_is_top":false,"comment_ctime":1576026114,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576026114","product_id":100039001,"comment_content":"我理解的  里氏替换强调的是“保留特征”，子类具体实现逻辑与父类可以截然不同，但是对父类而言子类却保留了基本的输入输出约定。对于多态，里氏替换会比较“守规则”而多态则比较“任性”。考虑到应用场景，里氏替换比较适合不同业务线里相同业务点，但是最终的产出是雷同的，只是输入数据和具体实现逻辑存在差异。不对的希望老师指正","like_count":0},{"had_liked":false,"id":160724,"user_name":"jaryoung","can_delete":false,"product_type":"c1","uid":1077406,"ip_address":"","ucode":"6E72D107DB7E51","user_header":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","comment_is_top":false,"comment_ctime":1576025892,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576025892","product_id":100039001,"comment_content":"优雅地扩展的作用，而不是瞎扩展。规约大于配置，顺从规约，一切美好。","like_count":0},{"had_liked":false,"id":160720,"user_name":"William","can_delete":false,"product_type":"c1","uid":1346215,"ip_address":"","ucode":"55F5D9DEE485B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","comment_is_top":false,"comment_ctime":1576025559,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576025559","product_id":100039001,"comment_content":"多态是特性，是面向对象的特性.<br><br>里氏替换是原则-父类出现的任何地方都可以用子类代替，而不影响功能和逻辑. 是定义子类编码的规范， 子类对于扩展父类的方法实现的时候 ，不能违背父类定义. <br><br>但是还是有点跟多态（重写方法）搞混...<br><br><br><br><br>","like_count":0},{"had_liked":false,"id":160718,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1576025540,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1576025540","product_id":100039001,"comment_content":"里氏替换的意义在于提供了在不改变原系统设计的前提下，提供了扩展原有软件系统功能的作用。以文中的例子为例，比如原系统退钱的功能（withdraw）并没有通知用户的功能，这时我们为了增加通知的功能，我们可以利用LSP原则扩展withdraw函数的功能，让其在成功退钱后发送通知出去。","like_count":0},{"had_liked":false,"id":160715,"user_name":"bearlu","can_delete":false,"product_type":"c1","uid":1030862,"ip_address":"","ucode":"14F260C8B24E27","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/ce/fd45714f.jpg","comment_is_top":false,"comment_ctime":1576025313,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576025313","product_id":100039001,"comment_content":"135学习设计模式，246学习数据结构与算法","like_count":0},{"had_liked":false,"id":160713,"user_name":"miracle","can_delete":false,"product_type":"c1","uid":1276137,"ip_address":"","ucode":"FD7074F1062AE9","user_header":"https://static001.geekbang.org/account/avatar/00/13/78/e9/9d807269.jpg","comment_is_top":false,"comment_ctime":1576025063,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576025063","product_id":100039001,"comment_content":"什么场景下需要用里式替换选择，这个跟子类扩展父类的功能好像是对立的？","like_count":0},{"had_liked":false,"id":160711,"user_name":"ghostfevil","can_delete":false,"product_type":"c1","uid":1184888,"ip_address":"","ucode":"E7355B2D81C4FE","user_header":"","comment_is_top":false,"comment_ctime":1576024696,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576024696","product_id":100039001,"comment_content":"个人觉得里氏替换原则的意义在于代码的复用性和可扩展性，里氏替换原则对父类的定义要求足够的通用性，这样子类继承和扩展就方便许多。","like_count":0},{"had_liked":false,"id":160706,"user_name":"deepz","can_delete":false,"product_type":"c1","uid":1570088,"ip_address":"","ucode":"4BD23A44CDB384","user_header":"https://static001.geekbang.org/account/avatar/00/17/f5/28/898a6947.jpg","comment_is_top":false,"comment_ctime":1576024307,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576024307","product_id":100039001,"comment_content":"没明白这样的话，用子类替换的意义。。意思是所有子类功能都一样是吗🤔 还是说继承下来了重写的方法必须按照父类约定的“协议”来，然后子类自己定义的方法用来表示子类与子类间的不同。🤔    就没太明白用多态来实现里氏替换，那多态的意义就。。额。。回头再看看文章回味下🙄","like_count":0},{"had_liked":false,"id":160693,"user_name":"teddytyy","can_delete":false,"product_type":"c1","uid":1268738,"ip_address":"","ucode":"E1569D81A4154E","user_header":"https://static001.geekbang.org/account/avatar/00/13/5c/02/e7af1750.jpg","comment_is_top":false,"comment_ctime":1576022933,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576022933","product_id":100039001,"comment_content":"子类中有方法不是重载自父类的方法是不是就不符合里式替换了？","like_count":0},{"had_liked":false,"id":160683,"user_name":"阿卡牛","can_delete":false,"product_type":"c1","uid":1022247,"ip_address":"","ucode":"0BC43A904C3199","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","comment_is_top":false,"comment_ctime":1576020733,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576020733","product_id":100039001,"comment_content":"个人觉得主要为了扩展性","like_count":0},{"had_liked":false,"id":160682,"user_name":"业余爱好者","can_delete":false,"product_type":"c1","uid":1482915,"ip_address":"","ucode":"A890935A982988","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","comment_is_top":false,"comment_ctime":1576020689,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576020689","product_id":100039001,"comment_content":"多态是语法层面的，里式替换是业务层面的。我的理解是，多态是里式替换的子集，是里式替换实现的手段。<br><br>父类或接口是一种协议，子类实现必须严格遵守协议实现，这样才能在父类出现的任何的地方用子类任意替换。客户端的使用只需关注父类提供的协议所述的功能。这是面向接口编程的思想。要实现这一目标，子类必须严格按照父类的协议实现。而实现手段是编程语言语法上的多态。","like_count":0},{"had_liked":false,"id":160676,"user_name":"与雨日肇事的爱","can_delete":false,"product_type":"c1","uid":1288032,"ip_address":"","ucode":"A3B88A1F4AF2D5","user_header":"https://static001.geekbang.org/account/avatar/00/13/a7/60/f175d953.jpg","comment_is_top":false,"comment_ctime":1576018657,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576018657","product_id":100039001,"comment_content":"Number 1.打卡","like_count":0},{"had_liked":false,"id":161349,"user_name":"年轻的我们","can_delete":false,"product_type":"c1","uid":1763079,"ip_address":"","ucode":"D7D7D6AE9F4CB7","user_header":"https://static001.geekbang.org/account/avatar/00/1a/e7/07/0e9d85c3.jpg","comment_is_top":false,"comment_ctime":1576196726,"is_pvip":false,"replies":[{"id":"61493","content":"理解的没错","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1576198866,"ip_address":"","comment_id":161349,"utype":1}],"discussion_count":18,"race_medal":0,"score":"1148332464758","product_id":100039001,"comment_content":"个人理解里氏替换就是子类完美继承父类的设计初衷，并做了增强对吗","like_count":268,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477694,"discussion_content":"理解的没错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576198866,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1567940,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ec/c4/19f85ada.jpg","nickname":"乃鱼同学","note":"","ucode":"50A96C24978057","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380212,"discussion_content":"儿子的DNA必须是老子的，其他随意。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1624373942,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1597071,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLe9iavda8ia7vNkbMVEHsCKs43l6U6HGWibiaxxKd9PuiaYu5wRedicC96PLicZ9VIh0ic5Jg8YHPrta3IAQ/132","nickname":"Geek_00e01b","note":"","ucode":"BC76A83B53D0EF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328875,"discussion_content":"就像文中提到的vip用户可以实现透支提现情况，我觉得没啥不合理啊。但却违背了LSP原则，这怎么解释呢","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1606266226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":2042568,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/2a/c8/dc4e314e.jpg","nickname":"米豆丸","note":"","ucode":"CE99FE3A1EBCAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1597071,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLe9iavda8ia7vNkbMVEHsCKs43l6U6HGWibiaxxKd9PuiaYu5wRedicC96PLicZ9VIh0ic5Jg8YHPrta3IAQ/132","nickname":"Geek_00e01b","note":"","ucode":"BC76A83B53D0EF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333469,"discussion_content":"同问，求回答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607524990,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":328875,"ip_address":""},"score":333469,"extra":""},{"author":{"id":1183221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0d/f5/0fe960cd.jpg","nickname":"y","note":"","ucode":"D27C06881D13A5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2042568,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/2a/c8/dc4e314e.jpg","nickname":"米豆丸","note":"","ucode":"CE99FE3A1EBCAF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363596,"discussion_content":"说一下个人愚见，首先这个需求是合理的，不合理的话争哥不会拿这个举例。但这个透支提现改掉了方法原有的功能，可能会导致调用处出现不可预知的问题，所以说一千道一万还是尽量扩展，而不是修改。","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1617241962,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":333469,"ip_address":""},"score":363596,"extra":""},{"author":{"id":1015189,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7d/95/dd73022c.jpg","nickname":"我是曾经那个少年","note":"","ucode":"9F02F7FF147D14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1597071,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLe9iavda8ia7vNkbMVEHsCKs43l6U6HGWibiaxxKd9PuiaYu5wRedicC96PLicZ9VIh0ic5Jg8YHPrta3IAQ/132","nickname":"Geek_00e01b","note":"","ucode":"BC76A83B53D0EF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":395929,"discussion_content":"项目是迭代出来的，而不是设计出来的。这些原则我感觉是指导我们在刚开始设计的时候要考虑扩展性。这种需求违反了也没啥关系，例如SecurityTransporter违反了原则，但是一般我新增了我也不会让子类去掉用。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1632364350,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":328875,"ip_address":""},"score":395929,"extra":""}]},{"author":{"id":1193385,"avatar":"https://static001.geekbang.org/account/avatar/00/12/35/a9/e2a0ad48.jpg","nickname":"懒散","note":"","ucode":"6FC704ABE5A9E1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318700,"discussion_content":"这么理解感觉有点像装饰器模式？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1603810145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1250807,"avatar":"https://static001.geekbang.org/account/avatar/00/13/15/f7/744720a2.jpg","nickname":"DriveMan_邱佳源","note":"","ucode":"A4C83BF07DEE7A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1193385,"avatar":"https://static001.geekbang.org/account/avatar/00/12/35/a9/e2a0ad48.jpg","nickname":"懒散","note":"","ucode":"6FC704ABE5A9E1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352488,"discussion_content":"我感觉像是 模板模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614752403,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":318700,"ip_address":""},"score":352488,"extra":""},{"author":{"id":2853072,"avatar":"","nickname":"小杰同学","note":"","ucode":"C6FC59D58F772C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1250807,"avatar":"https://static001.geekbang.org/account/avatar/00/13/15/f7/744720a2.jpg","nickname":"DriveMan_邱佳源","note":"","ucode":"A4C83BF07DEE7A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582978,"discussion_content":"这是原则 模式就是根据原则来的。。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1659857699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":352488,"ip_address":"福建"},"score":582978,"extra":""}]},{"author":{"id":2276155,"avatar":"https://static001.geekbang.org/account/avatar/00/22/bb/3b/6e020a32.jpg","nickname":"多学多看多记","note":"","ucode":"0670C833007510","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":402196,"discussion_content":"go语言，这个设计原则是不是凉了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1633829086,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2806043,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLBFkSq1oiaEMRjtyyv4ZpCI0OuaSsqs04ODm0OkZF6QhsAh3SvqhxibS2n7PLAVZE3QRSn5Hic0DyXg/132","nickname":"ddh","note":"","ucode":"8E852375365F16","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2276155,"avatar":"https://static001.geekbang.org/account/avatar/00/22/bb/3b/6e020a32.jpg","nickname":"多学多看多记","note":"","ucode":"0670C833007510","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542428,"discussion_content":"啊哈哈哈， go语言里没有继承，只有组合","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640747422,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":402196,"ip_address":""},"score":542428,"extra":""}]},{"author":{"id":1455958,"avatar":"https://static001.geekbang.org/account/avatar/00/16/37/56/11068390.jpg","nickname":"倡印","note":"","ucode":"4F53AA5D017D89","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295347,"discussion_content":"厉害啊，好几年了竟然比不上你这一句话的精辟","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596171797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1328500,"avatar":"https://static001.geekbang.org/account/avatar/00/14/45/74/7a82eebb.jpg","nickname":"Ins","note":"","ucode":"A2509BAD9CB72C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577478,"discussion_content":"评论区大佬","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656136243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1567940,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ec/c4/19f85ada.jpg","nickname":"乃鱼同学","note":"","ucode":"50A96C24978057","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380209,"discussion_content":"子类是父类在某些维度即设计原则上的子集。而不能是交集。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624373708,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1112490,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f9/aa/3e80212e.jpg","nickname":"龙猫","note":"","ucode":"FD726CC969EF9C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296992,"discussion_content":"简洁、精辟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596724031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1283461,"avatar":"https://static001.geekbang.org/account/avatar/00/13/95/85/15cd21c2.jpg","nickname":"杨锋","note":"","ucode":"85A7828A538FB0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286132,"discussion_content":"感谢解惑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593069529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160684,"user_name":"Chen","can_delete":false,"product_type":"c1","uid":1503113,"ip_address":"","ucode":"C1128558AB5BC4","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/89/8c73a24d.jpg","comment_is_top":false,"comment_ctime":1576020937,"is_pvip":false,"discussion_count":12,"race_medal":0,"score":"873454382025","product_id":100039001,"comment_content":"135看设计模式，246看数据结构与算法。争哥大法好","like_count":203,"discussions":[{"author":{"id":1118560,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/0SDRac7XoordnKYgDLhz5wxAOtE6xqcsSywsywEtKQAR7xicBZQ6ceYftfZjl4Ivq3a5dzvRhYkn2GcUWiaQK7ZQ/132","nickname":"ThinkingQuest","note":"","ucode":"597D0C00DAEFE4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301866,"discussion_content":"拜争教","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1598689662,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1366022,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/ajNVdqHZLLBP7piae8iaHU7w2a4TyLKPFI7xiaia3Hias2ibMPftnFEic0lqGU315U70peQs7X3Kyd3bDgJjF6nBQg7xA/132","nickname":"Geek_862694","note":"","ucode":"977B4195C7CFB1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79375,"discussion_content":"原来不是我一个人这么做的啊😂","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576074317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2636178,"avatar":"https://static001.geekbang.org/account/avatar/00/28/39/92/88ed94f2.jpg","nickname":"YX","note":"","ucode":"CC108CCE845EAE","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534010,"discussion_content":"下午学mysql45讲","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1638070135,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1792800,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/5b/20/ae2d4489.jpg","nickname":"zkr","note":"","ucode":"8BF9D0348BBF87","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585818,"discussion_content":"信争哥，得永生（doge","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661842244,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2636178,"avatar":"https://static001.geekbang.org/account/avatar/00/28/39/92/88ed94f2.jpg","nickname":"YX","note":"","ucode":"CC108CCE845EAE","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534008,"discussion_content":"我就不一样，我是早上看设计模式，晚上学算法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638070111,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1591223,"avatar":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","nickname":"JerryZhu","note":"","ucode":"76850CD45786C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303495,"discussion_content":"和我一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599283787,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1447569,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/WtHCCMoLJ2DvzqQwPYZyj2RlN7eibTLMHDMTSO4xIKjfKR1Eh9L98AMkkZY7FmegWyGLahRQJ5ibPzeeFtfpeSow/132","nickname":"脱缰的野马__","note":"","ucode":"D5F993E7232C61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283242,"discussion_content":"那7干嘛","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592220737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2100090,"avatar":"https://static001.geekbang.org/account/avatar/00/20/0b/7a/9ce7dc7d.jpg","nickname":"东瓜酱","note":"","ucode":"B1FEADF98DE292","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1447569,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/WtHCCMoLJ2DvzqQwPYZyj2RlN7eibTLMHDMTSO4xIKjfKR1Eh9L98AMkkZY7FmegWyGLahRQJ5ibPzeeFtfpeSow/132","nickname":"脱缰的野马__","note":"","ucode":"D5F993E7232C61","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301734,"discussion_content":"明显7那天就是脱缰的野马","likes_number":20,"is_delete":false,"is_hidden":false,"ctime":1598622033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":283242,"ip_address":""},"score":301734,"extra":""},{"author":{"id":2875397,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/5mOXmBMEctr0icDNSZHqsdQcN7ricoKD0GeR5jPNFXMhicmia9ECzzbL17uDEMayewliczngU7xrAiaehkeZ5CrPgPSQ/132","nickname":"Geek_a99d59","note":"","ucode":"BFC2C85B96CCA1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2100090,"avatar":"https://static001.geekbang.org/account/avatar/00/20/0b/7a/9ce7dc7d.jpg","nickname":"东瓜酱","note":"","ucode":"B1FEADF98DE292","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546063,"discussion_content":"hhh，绝了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642147180,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301734,"ip_address":""},"score":546063,"extra":""}]},{"author":{"id":1247965,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0a/dd/88fa7b52.jpg","nickname":"Geek_41d472","note":"","ucode":"DEC2B6329460CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":187980,"discussion_content":"卧槽,你们这么闲的吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582784557,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1338088,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6a/e8/4bb87c34.jpg","nickname":"月马穿关","note":"","ucode":"2CE20CA1EB827D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":172896,"discussion_content":"哈哈哈哈哈哈嗝 咱们的计划是一样的！！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581815593,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1790368,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/51/a0/5db02ac2.jpg","nickname":"點點點，点顛","note":"","ucode":"1BC77F6E044650","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":104353,"discussion_content":"争个大法好！哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577426327,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160721,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1576025601,"is_pvip":true,"discussion_count":13,"race_medal":0,"score":"688770792961","product_id":100039001,"comment_content":"LSP的意义：<br>一、改进已有实现。例如程序最开始实现时采用了低效的排序算法，改进时使用LSP实现更高效的排序算法。<br>二、指导程序开发。告诉我们如何组织类和子类（subtype），子类的方法（非私有方法）要符合contract。<br>三、改进抽象设计。如果一个子类中的实现违反了LSP，那么是不是考虑抽象或者设计出了问题。<br><br>补充：<br>Liskov是美国历史上第一个女计算机博士，曾获得过图灵奖。<br>In 1968 she became one of the first women in the United States to be awarded a Ph.D from a computer science department when she was awarded her degree from Stanford University. At Stanford she worked with John McCarthy and was supported to work in artificial intelligence.<br><br>https:&#47;&#47;en.wikipedia.org&#47;wiki&#47;Barbara_Liskov","like_count":160},{"had_liked":false,"id":160937,"user_name":"任鹏斌","can_delete":false,"product_type":"c1","uid":1104086,"ip_address":"","ucode":"34319B05EA6E74","user_header":"https://static001.geekbang.org/account/avatar/00/10/d8/d6/47da34bf.jpg","comment_is_top":false,"comment_ctime":1576065154,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"534152009858","product_id":100039001,"comment_content":"里氏替换就是说父亲能干的事儿子也别挑，该怎么干就怎么干，儿子可以比父亲更有能力，但传统不能变","like_count":125,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502594,"discussion_content":"没法做到一点都不修改代码的哦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596109727,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1274328,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLicryBoLjDicckia0c5bkOoAlYoR2I9NMK8BiaD7HCGxhS1eM9YSfDuUJuZC90uwv9FvHIVSsBoxFgZw/132","nickname":"MwumLi","note":"","ucode":"9A8A72334ADF6E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570792,"discussion_content":"如果把二维表抽离成静态资源, 那么可以做到不修改代码实现状态迁移逻辑以及分数的调整","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651910118,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2234620,"avatar":"https://static001.geekbang.org/account/avatar/00/22/18/fc/4f92ee4e.jpg","nickname":"江南一笑","note":"","ucode":"E38938A1178827","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372078,"discussion_content":"至少需要在 enmu State { }这个类中新增一个状态。再改改表。仅此而已。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620179005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160692,"user_name":"失火的夏天","can_delete":false,"product_type":"c1","uid":1241770,"ip_address":"","ucode":"10C6E66EB2A65F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","comment_is_top":false,"comment_ctime":1576022825,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"409597915945","product_id":100039001,"comment_content":"里氏替换最终一句话还是对扩展开放，对修改关闭，不能改变父类的入参，返回，但是子类可以自己扩展方法中的逻辑。父类方法名很明显限定了逻辑内容，比如按金额排序这种，子类就不要去重写金额排序，改成日期排序之类的，而应该抽出一个排序方法，然后再写一个获取排序的方法，父类获取排序调用金额排序，子类就重写调用排序方法，获取日期排序。<br><br>个人感觉也是为了避免“二意性”，这里是只父类的逻辑和子类逻辑差别太多，读代码的人会感觉模棱两可，父类一套，子类一套，到底应该读哪种。感觉会混乱。<br><br>总之就是，子类的重写最好是扩展父类，而不要修改父类。","like_count":96,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499010,"discussion_content":"嗯嗯 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593910513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160822,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1576039905,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"233504273889","product_id":100039001,"comment_content":"里式替换是细力度的开闭原则。这个准则应用的场景，往往是在方法功能的调整上，要达到的效果是：该方法对已经调用的代码的效果不变，并能支撑新的功能或提供更好的性能。换句话说，就是在保证兼容的前提条件下做扩展和调整。<br><br>spring对里式替换贯彻得不错，从1.x到4.x能看到大部分代码都坚强的保留着兼容性。<br>但springboot就有点跳脱了，1.x小版本就会有违背里式替换的破坏性升级。1.x到2.x更是出现跳票重灾的情况。带来的损失相信做过springboot版本升级的人都很有感触，而这份损失也表达出坚守里式替换原则的重要性。不过，既然springboot会违背经营多年的原则（向下兼容），那么绝非空穴来风，相信在他们看来，违背里式替换做的升级，带来的价值能够盖过损失。所以我觉得里式替换依旧是个权衡项，在日常开发中我们要坚守，但当发现不合理，比如设计缺陷或则业务场景质变时，做破坏性改造也意味着即使止损，是一个可选项。","like_count":55,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491581,"discussion_content":"没有啊，你看看上面那个表格","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594904767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1045078,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f2/56/c39046c0.jpg","nickname":"Jie","note":"","ucode":"AB94041E548FEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":243518,"discussion_content":"没有写错啊，small的吃了蘑菇变super了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587547347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160674,"user_name":"Kevinlvlc","can_delete":false,"product_type":"c1","uid":1176980,"ip_address":"","ucode":"90DFD58CED138C","user_header":"https://static001.geekbang.org/account/avatar/00/11/f5/94/67fabf8e.jpg","comment_is_top":false,"comment_ctime":1576017802,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"194849546122","product_id":100039001,"comment_content":"我觉得可以从两个角度谈里式替换原则的意义。<br>首先，从接口或父类的角度出发，顶层的接口&#47;父类要设计的足够通用，并且可扩展，不要为子类或实现类指定实现逻辑，尽量只定义接口规范以及必要的通用性逻辑，这样实现类就可以根据具体场景选择具体实现逻辑而不必担心破坏顶层的接口规范。<br>从子类或实现类角度出发，底层实现不应该轻易破坏顶层规定的接口规范或通用逻辑，也不应该随意添加不属于这个类要实现的功能接口，这样接口的外部使用者可以不必关心具体实现，安全的替换任意实现类，同时内部各个不同子类既可以根据不同场景做各自的扩展，又不破坏顶层的设计，从维护性和扩展性来说都能得到保证","like_count":45},{"had_liked":false,"id":160687,"user_name":"时光勿念","can_delete":false,"product_type":"c1","uid":1025003,"ip_address":"","ucode":"72C8EC5A62C700","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a3/eb/d26459ae.jpg","comment_is_top":false,"comment_ctime":1576021303,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"151899876663","product_id":100039001,"comment_content":"呃，我不知道这样理解对不对。<br>多态是一种特性、能力，里氏替换是一种原则、约定。<br>虽然多态和里氏替换不是一回事，但是里氏替换这个原则 需要 多态这种能力 才能实现。<br>里氏替换最重要的就是替换之后原本的功能一点不能少。","like_count":35,"discussions":[{"author":{"id":1368038,"avatar":"https://static001.geekbang.org/account/avatar/00/14/df/e6/bd1b3c0b.jpg","nickname":"Jesse","note":"","ucode":"727CA882B84DA0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78881,"discussion_content":"好像功能也不能多。。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1576029584,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1161271,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","nickname":"不似旧日","note":"","ucode":"DF4C5E3AB9570C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79038,"discussion_content":"是功能不变, 方法的功能和规则不能变,具体的实现逻辑可以变","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576048900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1754311,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/c4/c7/bd963efc.jpg","nickname":"Tosca","note":"","ucode":"605ABDCEA945DF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":83081,"discussion_content":"也不能多","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576414757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160708,"user_name":"何妨","can_delete":false,"product_type":"c1","uid":1385377,"ip_address":"","ucode":"EC3983BFF7992A","user_header":"https://static001.geekbang.org/account/avatar/00/15/23/a1/b08f3ee7.jpg","comment_is_top":false,"comment_ctime":1576024470,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"70295501206","product_id":100039001,"comment_content":"多态是语法特性，是一种实现方法。里式替换是设计原则，是一种规范。其存在的意义是用来规范我们对方法的使用，即指导我们如何正确的使用多态。","like_count":16},{"had_liked":false,"id":161129,"user_name":"destiny","can_delete":false,"product_type":"c1","uid":1744284,"ip_address":"","ucode":"8D38BF89E76450","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9d/9c/2d5eac97.jpg","comment_is_top":false,"comment_ctime":1576125396,"is_pvip":false,"discussion_count":10,"race_medal":0,"score":"53115732948","product_id":100039001,"comment_content":"VIP提现可透支这种情况如何不违背里氏替换原则？","like_count":12,"discussions":[{"author":{"id":1429627,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJN64OCUT0Jp0h2Wiau9Os0o1WbwUeoq2QL0U2vZpib8ozPxo0XDiaPM9xcKfbkoBL24ztEHelxPIMVg/132","nickname":"Kevin","note":"","ucode":"9DFFD6E3960CF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84008,"discussion_content":"注释未考虑到未来的需求扩展。 修改父类的注释。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1576480414,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1624574,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c9/fe/874b172b.jpg","nickname":"benxiong","note":"","ucode":"F6498059D439D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1429627,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJN64OCUT0Jp0h2Wiau9Os0o1WbwUeoq2QL0U2vZpib8ozPxo0XDiaPM9xcKfbkoBL24ztEHelxPIMVg/132","nickname":"Kevin","note":"","ucode":"9DFFD6E3960CF7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386115,"discussion_content":"哈哈修改注释这个可以的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1627428270,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":84008,"ip_address":""},"score":386115,"extra":""}]},{"author":{"id":1268264,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5a/28/732d3f2f.jpg","nickname":"GEEKBANG_6638780","note":"","ucode":"952194E56FD8C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383277,"discussion_content":"改用策略模式， 每种等级一个策略。 保不齐vip还分等级，然后透支程度不一样","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1626018557,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1448126,"avatar":"https://static001.geekbang.org/account/avatar/00/16/18/be/ad3127e0.jpg","nickname":"慕高迪","note":"","ucode":"EB1CB5EA4E3A90","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290527,"discussion_content":"新创建方法吧，withDrawForVIP() ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594523560,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1196641,"avatar":"https://static001.geekbang.org/account/avatar/00/12/42/61/de579755.jpg","nickname":"醉碧川","note":"","ucode":"B0DCE5E48FDD82","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1448126,"avatar":"https://static001.geekbang.org/account/avatar/00/16/18/be/ad3127e0.jpg","nickname":"慕高迪","note":"","ucode":"EB1CB5EA4E3A90","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304578,"discussion_content":"我觉得修改父类的约定或者新增方法应该都是可以的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1599619581,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":290527,"ip_address":""},"score":304578,"extra":""}]},{"author":{"id":1075334,"avatar":"https://static001.geekbang.org/account/avatar/00/10/68/86/348be7f8.jpg","nickname":"Lingo","note":"","ucode":"82ECA2E0533B78","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576406,"discussion_content":"修改父类函数的定义，完善单元测试，支持子类透支功能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655527091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1488356,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b5/e4/e6faf686.jpg","nickname":"握了个大蚂蚱","note":"","ucode":"AD34AD4FA37371","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383661,"discussion_content":"修改注释是正解，只是为了举这个例子，从方法名和提现业务本身来说，透支都是没毛病的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626183877,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1565950,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKvnkXZiaop0hbe9w5kuAvf6d17suDPB6W1j2hlYPJ43eRogABUic5pUV7ia5rPHjXLWEfDZLHiafMUiaQ/132","nickname":"marsly","note":"","ucode":"1F61DE32D99426","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281773,"discussion_content":"我也很是疑惑怎么修改这个，或者针对VIP实现单独的函数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591802426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1125834,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2d/ca/02b0e397.jpg","nickname":"fomy","note":"","ucode":"CD87EA03B1F327","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":115473,"discussion_content":"1、修改注释，然后新增VIP的实现类即可。\n2、接口新增一个提现方法，VIP实现这个接口方法。其他实现类还是调用原来的体提现即可。然后逐步改造使用新的提现接口。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578015296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84455,"discussion_content":"可能只能修改协议了。因为我感觉用多态来实现这个再合适不过了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576497794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160695,"user_name":"Cy23","can_delete":false,"product_type":"c1","uid":1591293,"ip_address":"","ucode":"8DC561C5151758","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/fd/895f0c27.jpg","comment_is_top":false,"comment_ctime":1576023244,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"53115630796","product_id":100039001,"comment_content":"听完感觉就是，子类可以无损替换父类，就是里氏替换原则。对否","like_count":12},{"had_liked":false,"id":180842,"user_name":"ladidili","can_delete":false,"product_type":"c1","uid":1217498,"ip_address":"","ucode":"38886C1908DE6B","user_header":"https://static001.geekbang.org/account/avatar/00/12/93/da/0e47c76e.jpg","comment_is_top":false,"comment_ctime":1582427421,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"35942165789","product_id":100039001,"comment_content":"多态是工具，是实在的东西。里式替换是设计思路，是虚的东西。<br><br>多态做到外壳，做到结构一致。<br>里式替换在结构一致的前提下还要保持底层逻辑一致。<br><br>设计模式都是用来指导开发的。里式替换指导父类更加抽象复用，子类更加贴近最初的原则。<br>","like_count":8},{"had_liked":false,"id":163569,"user_name":"王加武","can_delete":false,"product_type":"c1","uid":1665471,"ip_address":"","ucode":"DDCFE578C6C428","user_header":"https://static001.geekbang.org/account/avatar/00/19/69/bf/50a824a4.jpg","comment_is_top":false,"comment_ctime":1576746866,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35936485234","product_id":100039001,"comment_content":"在继承当中，尽量不要去重写父类的方法<br>里氏替换原则告诉我们，继承实际上是提高了两个类的耦合性，在适当的情况下，我们可以使用组合，依赖，聚合等来解决问题！","like_count":8},{"had_liked":false,"id":160714,"user_name":"知行合一","can_delete":false,"product_type":"c1","uid":1521486,"ip_address":"","ucode":"2B8E634FC4CFB7","user_header":"https://static001.geekbang.org/account/avatar/00/17/37/4e/5c3153b2.jpg","comment_is_top":false,"comment_ctime":1576025190,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35935763558","product_id":100039001,"comment_content":"多态是种能力，里氏是一种约定。能力是摆在那里的，约定却不一定强制遵守，有时候可能会打破约定。需要权衡","like_count":8},{"had_liked":false,"id":160779,"user_name":"qqq","can_delete":false,"product_type":"c1","uid":1006786,"ip_address":"","ucode":"91B0ACF8CBE7BD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/c2/8ffd2ad0.jpg","comment_is_top":false,"comment_ctime":1576031897,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"27345835673","product_id":100039001,"comment_content":"遵守协议，保证一致性","like_count":6},{"had_liked":false,"id":163875,"user_name":"雨幕下的稻田","can_delete":false,"product_type":"c1","uid":1388799,"ip_address":"","ucode":"1FBFF3187AE9C4","user_header":"https://static001.geekbang.org/account/avatar/00/15/30/ff/b3e54147.jpg","comment_is_top":false,"comment_ctime":1576816032,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"23051652512","product_id":100039001,"comment_content":"LSP感觉是在多态的基础上强调了协议的重要性","like_count":5,"discussions":[{"author":{"id":1107666,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e6/d2/638ca831.jpg","nickname":"z","note":"","ucode":"CDB0BE8562ECB6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300318,"discussion_content":"同感，LSP的实现依赖多态","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598021302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160732,"user_name":"帆大肚子","can_delete":false,"product_type":"c1","uid":1529040,"ip_address":"","ucode":"3DB11DB2FA1802","user_header":"https://static001.geekbang.org/account/avatar/00/17/54/d0/4e1fc664.jpg","comment_is_top":false,"comment_ctime":1576027133,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23050863613","product_id":100039001,"comment_content":"在可拔插的设计中，保证原有代码的正确性","like_count":5},{"had_liked":false,"id":180779,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1582385559,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18762254743","product_id":100039001,"comment_content":"父类假如在协议上约定得非常细，方法命名中说明了实现细节，就会导致子类扩展受限，也是对里氏替换的一种限制。","like_count":4},{"had_liked":false,"id":164519,"user_name":"G","can_delete":false,"product_type":"c1","uid":1547293,"ip_address":"","ucode":"50D8E1ADAE0330","user_header":"https://static001.geekbang.org/account/avatar/00/17/9c/1d/34c96367.jpg","comment_is_top":false,"comment_ctime":1577019505,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18756888689","product_id":100039001,"comment_content":"我感觉里式替换对心智的负担比较大，虽然没有改写父类，但实际父类不再使用了，等同于修改了父类。这种重构让我想起了js的痛苦，逻辑都要在运行时才能知道，而且静态编译时，编译器无法帮助推断，还不如多态直接告诉编译器。","like_count":4},{"had_liked":false,"id":160702,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1576024049,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18755893233","product_id":100039001,"comment_content":"设计模式_17:<br>里氏替换：<br>协议(一致性)带来效率！<br><br>从多态的角度，真的可以随便写，越是与父类不同，就显得越多态。<br>但如果没有限制&#47;协议地多态，抽象就困难起来，在任何时候都需要考虑所有子类的实现细节，多态也就没有意义。","like_count":4},{"had_liked":false,"id":284448,"user_name":"建锋","can_delete":false,"product_type":"c1","uid":1616445,"ip_address":"","ucode":"DF4AAE135B152B","user_header":"https://static001.geekbang.org/account/avatar/00/18/aa/3d/c14e338e.jpg","comment_is_top":false,"comment_ctime":1616251302,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14501153190","product_id":100039001,"comment_content":"带着镣铐舞蹈","like_count":3},{"had_liked":false,"id":169186,"user_name":"董瑞","can_delete":false,"product_type":"c1","uid":1117752,"ip_address":"","ucode":"5A701013987147","user_header":"https://static001.geekbang.org/account/avatar/00/11/0e/38/cffa4734.jpg","comment_is_top":false,"comment_ctime":1578287890,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14463189778","product_id":100039001,"comment_content":"里氏替换原则存在的意义：<br>1. 增强父类或接口进行约定，子类进行实现的设计原则，明确父类是抽象定义，子类是具体实现的面向对象编程思想<br>2. 为子类设计和实现提供了明确而有用的指导思想，子类的协议实现不能超越父类的抽象定义，否则，违背约定的子类实现会导致系统可读性、可运行性会出现不符合预期的逻辑行为<br>3. 增加了对多态编程方法的应用指导，多态是一种编码实现的思路，设计和实现可以很宽泛，应用里氏替换原则的指导，可以设计出高质量的多态编程，从而让面向对象编程实现的程序的可读性、健壮性更好","like_count":3},{"had_liked":false,"id":168545,"user_name":"迷羊","can_delete":false,"product_type":"c1","uid":1286251,"ip_address":"","ucode":"85AF8CED3436C8","user_header":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","comment_is_top":false,"comment_ctime":1578107813,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14463009701","product_id":100039001,"comment_content":"一、如何理解里氏替换原则？<br>1.子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。（示例可查看专栏文章）<br>2.里氏替换原则更有指导意义的描述是：按照协议来设计。子类在设计的时候，要遵守父类的行为约定&#47;协议。父类定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。行为约定包括：函数声明要实现的功能；对输入、输出、异常的约定；注释中所罗列的特殊说明。同理也可以对应到接口和实现类。<br><br>二、哪些代码明显违背了LSP?<br>1.子类违背父类声明要实现的功能<br>父类中提供的sortOrdersByAmount()订单排序函数，是按照金额从小到大来给订单排序的，而子类重写这个方法之后是按照创建日期来给订单排序的。那子类的设计就违背里氏替换原则。<br>2.子类违背父类对输入、输出、异常的约定<br>父类中某个函数约定：运行出错返回null；获取数据为空时返回空集合。子类重写函数之后，运行出错返回异常，获取不到数据返回null。那子类的设计就违背里氏替换原则。<br>父类中某个函数约定，输入数据可以是任意整数，子类实现只允许输入数据是正整数，负数就抛出，也就是说子类对输入的数据的校验比父类更加严格，那子类的设计就违背了里氏替换原则。<br>父类中某个函数约定，只会抛出ArgumentNullException异常，子类的设计实现抛出了其他的异常，那子类的设计就违背了里氏替换原则。<br>3.子类违背父类注释中所罗列的任何特殊说明<br>父类中定义的 withdraw() 提现函数的注释是这么写的：“用户的提现金额不得超过账户余额……”，而子类重写 withdraw() 函数之后，针对 VIP 账号实现了透支提现的功能，也就是提现金额可以大于账户余额，那这个子类的设计也是不符合里式替换原则的。<br>4.判断子类的设计实现是否违背里氏替换原则，我们可以拿父类的单元测试去验证子类的代码。如果某些单元测试运行事呗，就有可能说明子类的设计实现没有完全遵守父类的约定，子类就有可能违背了里氏替换原则。<br><br>三、多态和里氏替换原则的区别<br>多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。","like_count":3},{"had_liked":false,"id":163953,"user_name":"岁月","can_delete":false,"product_type":"c1","uid":1337598,"ip_address":"","ucode":"29A2A2BC3C4FE4","user_header":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","comment_is_top":false,"comment_ctime":1576833755,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14461735643","product_id":100039001,"comment_content":"我觉得, 子类的设计更多的是为了增加&quot;某个需求的实现&quot;的方式, 比如后端, 一个读写类, 子类可以分别实现多种类型数据库的读写. 比如做前端, 一个界面的渲染, 子类可以提供多种多样的渲染结果. 所以一般子类是不会去重写父类的&quot;按照数量排序&quot;这种代码, 除非真的只是为了优化性能, 但是优化性能一般是直接修改父类代码而不是新增一个高性能子类, 除非是增加一个&quot;用空间换时间&quot;这样的高性能子类, 但是这样的子类又变成了我一开头说的:  为了增加&quot;某个需求的实现&quot;.","like_count":3,"discussions":[{"author":{"id":1565950,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKvnkXZiaop0hbe9w5kuAvf6d17suDPB6W1j2hlYPJ43eRogABUic5pUV7ia5rPHjXLWEfDZLHiafMUiaQ/132","nickname":"marsly","note":"","ucode":"1F61DE32D99426","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281779,"discussion_content":"是啊，如果真的是优化，此时在父类优化最好啊~~~除非这个优化是有限制的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591802668,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":281801,"user_name":"Geek_ad9237","can_delete":false,"product_type":"c1","uid":1996239,"ip_address":"","ucode":"FED3652DFAE79F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIeTLkHYdJ3lTe21qGTH6j6KibTfFicc8IBj5gHbIZlBruoyT02HyBbVVMGSz93PMmN9xRVib40dKlyw/132","comment_is_top":false,"comment_ctime":1614908023,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10204842615","product_id":100039001,"comment_content":"里氏替换原则约束了多态行为，以防出现不符合规约的多态在运行时出现意料之外的行为，如：参数校验、返回值、业务逻辑的规约","like_count":2},{"had_liked":false,"id":273230,"user_name":"青蛙军曹ψ","can_delete":false,"product_type":"c1","uid":1736523,"ip_address":"","ucode":"F7D6CA78203472","user_header":"https://static001.geekbang.org/account/avatar/00/1a/7f/4b/b0afc0ae.jpg","comment_is_top":false,"comment_ctime":1610503481,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10200438073","product_id":100039001,"comment_content":"多态是一种语法，lsp 是一种设计原则。lsp依赖多态的语法机制，但lsp从功能，输入，输出，异常等方面的约定，对子类提出了跟进一步的要求。","like_count":2},{"had_liked":false,"id":202636,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1586020609,"is_pvip":false,"discussion_count":1,"race_medal":1,"score":"10175955201","product_id":100039001,"comment_content":"里式替换原则，可以形象的理解为：做一个上进的乖孩子！","like_count":2,"discussions":[{"author":{"id":2409059,"avatar":"https://static001.geekbang.org/account/avatar/00/24/c2/63/f304703d.jpg","nickname":"光林","note":"","ucode":"BA9A36E3BB65D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344156,"discussion_content":"这个比较通俗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611307263,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168026,"user_name":"- -","can_delete":false,"product_type":"c1","uid":1338203,"ip_address":"","ucode":"FBB2869AD5FEA5","user_header":"https://static001.geekbang.org/account/avatar/00/14/6b/5b/16a93d9d.jpg","comment_is_top":false,"comment_ctime":1577979436,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10167914028","product_id":100039001,"comment_content":"最直接的感受是增加可读性，也就是只要理解父类的方法是做什么的，阅读子类时大原则是不变的，只是逻辑实现会有点不一样","like_count":2},{"had_liked":false,"id":162801,"user_name":"Treasure","can_delete":false,"product_type":"c1","uid":1177602,"ip_address":"","ucode":"4211ECEB347C3D","user_header":"https://static001.geekbang.org/account/avatar/00/11/f8/02/a02d127d.jpg","comment_is_top":false,"comment_ctime":1576591328,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10166525920","product_id":100039001,"comment_content":"在改造之后的代码中，如果传递进 demoFunction() 函数的是父类 Transporter 对象，那 demoFunction() 函数并不会有异常抛出，但如果传递给 demoFunction() 函数的是子类 SecurityTransporter 对象，那 demoFunction() 有可能会有异常抛出。<br><br>——————————————————<br>为什么可能会有异常啊，看了好久，也没发现原因，求解答。","like_count":2,"discussions":[{"author":{"id":1107666,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e6/d2/638ca831.jpg","nickname":"z","note":"","ucode":"CDB0BE8562ECB6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300320,"discussion_content":"改造后的子类，第20行代码抛异常了，是有可能执行到这一行的，所以说是可能抛异常。文章描述是有点让人误解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598021714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161964,"user_name":"秋天","can_delete":false,"product_type":"c1","uid":1057056,"ip_address":"","ucode":"A7E1D953EF7E17","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/20/1299e137.jpg","comment_is_top":false,"comment_ctime":1576417762,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10166352354","product_id":100039001,"comment_content":"打卡坚持学习","like_count":2},{"had_liked":false,"id":160994,"user_name":"无道win","can_delete":false,"product_type":"c1","uid":1461075,"ip_address":"","ucode":"0C026BB03A53EA","user_header":"https://static001.geekbang.org/account/avatar/00/16/4b/53/f797f031.jpg","comment_is_top":false,"comment_ctime":1576074470,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"10166009062","product_id":100039001,"comment_content":"有个疑问，如果现实开发中遇到类似于SecurityTransporte类新增校验的情况，那么应该怎么处理呢？是否违背李式替换，在子类中新增父类中没有的异常？","like_count":2,"discussions":[{"author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":117284,"discussion_content":"我觉得不能太死板，主要还是看具体业务，如果开发中遇到了你说的这种情况，大胆取用就好了，毕竟编程还是为了解决实际问题","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578106492,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":281443,"user_name":"DriveMan_邱佳源","can_delete":false,"product_type":"c1","uid":1250807,"ip_address":"","ucode":"A4C83BF07DEE7A","user_header":"https://static001.geekbang.org/account/avatar/00/13/15/f7/744720a2.jpg","comment_is_top":false,"comment_ctime":1614752346,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5909719642","product_id":100039001,"comment_content":"感觉这个里式替换原则和模板模式 相似","like_count":1},{"had_liked":false,"id":244017,"user_name":"。华伟","can_delete":false,"product_type":"c1","uid":2095422,"ip_address":"","ucode":"CD2645632E70D0","user_header":"https://static001.geekbang.org/account/avatar/00/1f/f9/3e/aef7a849.jpg","comment_is_top":false,"comment_ctime":1598352561,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5893319857","product_id":100039001,"comment_content":"感觉是严格意义上的对扩展开放，对修改关闭","like_count":1},{"had_liked":false,"id":242145,"user_name":"火影.海诺","can_delete":false,"product_type":"c1","uid":2091565,"ip_address":"","ucode":"34729AFEE93B6D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/ea/2d/34cb8e0a.jpg","comment_is_top":false,"comment_ctime":1597623778,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5892591074","product_id":100039001,"comment_content":"没有全新的了解……印象深刻的一个理解是，抽象意义上的子类在替换父类后不能改变代码原来的逻辑和程序正确性！还是会回到扩展性这个问题是，替换原则也要准寻的一个原则是你可以扩展我，但你不能改变我！","like_count":1},{"had_liked":false,"id":212359,"user_name":"简单猫","can_delete":false,"product_type":"c1","uid":1866485,"ip_address":"","ucode":"EA027D4C344E25","user_header":"https://static001.geekbang.org/account/avatar/00/1c/7a/f5/54a5084b.jpg","comment_is_top":false,"comment_ctime":1588089130,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5883056426","product_id":100039001,"comment_content":"里氏替代原则，父类的行为 子类要与其一致。对修改关闭 对扩展开放。但是我认为重载父方法 在其内部调用super.父类方法前后做一些类似日志操作 应该不算是违反了 里氏替代原则吧<br>","like_count":1},{"had_liked":false,"id":194032,"user_name":"黑客时间","can_delete":false,"product_type":"c1","uid":1831324,"ip_address":"","ucode":"7E22D76EECAC4D","user_header":"https://static001.geekbang.org/account/avatar/00/1b/f1/9c/cd12361d.jpg","comment_is_top":false,"comment_ctime":1585016458,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879983754","product_id":100039001,"comment_content":"如果我确实需要一个像这种参数校验的功能，如果没有这两个参数，会对后续的业务流程产生影响，那该怎么扩展这个方法呢","like_count":1},{"had_liked":false,"id":161768,"user_name":"淞淞同学","can_delete":false,"product_type":"c1","uid":1179533,"ip_address":"","ucode":"529A326B898008","user_header":"https://static001.geekbang.org/account/avatar/00/11/ff/8d/8601f035.jpg","comment_is_top":false,"comment_ctime":1576321134,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5871288430","product_id":100039001,"comment_content":"我的理解，多态是满足了语法和编译层面上的转换兼容，没有逻辑实现层面上的转换兼容。里氏替换原则要求的是两个函数可以替换类似重构的要求，不改变原有函数的行为。","like_count":1},{"had_liked":false,"id":161686,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1576296090,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5871263386","product_id":100039001,"comment_content":"提到里氏替换原则，让我想起了，cpp的纯虚类，和纯虚函数就有点类似里氏替换，他必须要实现父类的纯虚函数，再由于cpp函数编译过程的原因就导致必须要和父类的函数，名字，参数，返回值等等都一模一样！","like_count":1,"discussions":[{"author":{"id":1247039,"avatar":"https://static001.geekbang.org/account/avatar/00/13/07/3f/53ae01f6.jpg","nickname":"Kevin.zhang🌏","note":"","ucode":"5C52AE51538906","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215593,"discussion_content":"就是cpp虚函数的多态特性支持了该原则。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585359998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161276,"user_name":"Yayu","can_delete":false,"product_type":"c1","uid":1058015,"ip_address":"","ucode":"5E7842458D8229","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/df/645f8087.jpg","comment_is_top":false,"comment_ctime":1576163724,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5871131020","product_id":100039001,"comment_content":"关于『里氏代换原则』<br><br>这个世界上如果没有继承，就不会有里氏代换原则。该原则本质是想用设计规范来约束可能出现的恶劣结果，而这个恶劣结果源于语言层面的劣质特性。 ","like_count":1},{"had_liked":false,"id":160960,"user_name":"Zhe_Pu","can_delete":false,"product_type":"c1","uid":1755640,"ip_address":"","ucode":"C50476D91EC367","user_header":"https://static001.geekbang.org/account/avatar/00/1a/c9/f8/5e6fa8b5.jpg","comment_is_top":false,"comment_ctime":1576070134,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5871037430","product_id":100039001,"comment_content":"里式替换原则保证子类的实现不超过父类的接口定义规范，只是对功能的扩展，而不是对功能的修改，满足”对扩展开发，修改关闭“。同时在父类定义的框架下，子类虽然可以扩展，但也不能超过父类定义的范围，也在一定基础上满足了单一设计原则。","like_count":1},{"had_liked":false,"id":160914,"user_name":"阿冰777","can_delete":false,"product_type":"c1","uid":1373893,"ip_address":"","ucode":"F365EB44F971F3","user_header":"https://static001.geekbang.org/account/avatar/00/14/f6/c5/6329ddcc.jpg","comment_is_top":false,"comment_ctime":1576059898,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5871027194","product_id":100039001,"comment_content":"里氏替换原则.我觉得目的就是为了防止以后扩充功能的时候,对原先的父类造成了影响.当子类复写父类的功能,要保证你复写的时候,函数的行为是和原先一样的,这样就不会对原有的功能造成破坏.其实就是理解按协议编程,什么是按协议编程?我们对一个类的函数&#47;行为 进行规定,他有前置条件,后置条件,和内部不变式.如果子类复写了他,那么必须保证前置条件不会增强,后置条件不会减弱,内部不定式不变.什么是前置条件, 个人理解就是对函数输入的约束,后置条件就是对函数返回的约束,内部不定式可以理解为断言,就是对内部属性进行断言,复写的时候断言依旧全部通过.所以我觉得可以用测试用例来保证里氏替换原则,找到前置和后置的零界点,同时在内部增加断言.","like_count":1},{"had_liked":false,"id":160726,"user_name":"thomas","can_delete":false,"product_type":"c1","uid":1341964,"ip_address":"","ucode":"88440A9C773832","user_header":"https://static001.geekbang.org/account/avatar/00/14/7a/0c/5abd1cf9.jpg","comment_is_top":false,"comment_ctime":1576026174,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5870993470","product_id":100039001,"comment_content":"一个词说里氏替换原则就是：合约。子类要遵守父类设定的合约，也就是设计的初衷。子类改变逻辑思维边界是父类声明的合约。","like_count":1,"discussions":[{"author":{"id":1738326,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","nickname":"守拙","note":"","ucode":"F594B2DA3F6D4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79077,"discussion_content":"同意这位朋友的理解。\n\n补充一句：LSP一定意义上的约束了多态的实现，从而避免滥用多态导致的灾难性后果。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576053618,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160700,"user_name":"狼的诱惑","can_delete":false,"product_type":"c1","uid":1257043,"ip_address":"","ucode":"AE89DFC5963C42","user_header":"https://static001.geekbang.org/account/avatar/00/13/2e/53/bf62683f.jpg","comment_is_top":false,"comment_ctime":1576023816,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5870991112","product_id":100039001,"comment_content":"多态是JAVA语法，里氏替换是设计思路和规范；<br>里氏替换是在多态语法的基础上实现的，在不改变函数原有逻辑的基础上对函数功能的一种增强<br>老师讲的很好","like_count":1,"discussions":[{"author":{"id":1429627,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJN64OCUT0Jp0h2Wiau9Os0o1WbwUeoq2QL0U2vZpib8ozPxo0XDiaPM9xcKfbkoBL24ztEHelxPIMVg/132","nickname":"Kevin","note":"","ucode":"9DFFD6E3960CF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84009,"discussion_content":"你这个多态是java语法就显得很业余。  多态是面向对象的思想，java只是一种面向对象编程语言。 ","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576480539,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160672,"user_name":"高源","can_delete":false,"product_type":"c1","uid":1048887,"ip_address":"","ucode":"751B41FD38EF7D","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/37/12e4c9c9.jpg","comment_is_top":false,"comment_ctime":1576015395,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5870982691","product_id":100039001,"comment_content":"听王老师讲的很好理解😊书上的比较绕","like_count":1},{"had_liked":false,"id":359995,"user_name":"Nio","can_delete":false,"product_type":"c1","uid":1529642,"ip_address":"广东","ucode":"A1B8D3C01FB937","user_header":"https://static001.geekbang.org/account/avatar/00/17/57/2a/c6c95f37.jpg","comment_is_top":false,"comment_ctime":1666107281,"is_pvip":true,"discussion_count":0,"race_medal":4,"score":"1666107281","product_id":100039001,"comment_content":"青出于蓝而胜于蓝","like_count":0},{"had_liked":false,"id":359967,"user_name":"逐梦","can_delete":false,"product_type":"c1","uid":2124158,"ip_address":"上海","ucode":"682702AA87AAE7","user_header":"https://static001.geekbang.org/account/avatar/00/20/69/7e/6b94f44b.jpg","comment_is_top":false,"comment_ctime":1666092654,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1666092654","product_id":100039001,"comment_content":"感觉里氏替换主要是以方便阅读为基础，方便维护为辅助。因为子类若不按父类的定义进行扩展补充，就会使别人难以读懂代码逻辑关系，从而使维护变的困难。","like_count":0},{"had_liked":false,"id":358307,"user_name":"Geek_5e38c0","can_delete":false,"product_type":"c1","uid":3180236,"ip_address":"山东","ucode":"C714F0DB9FF9A4","user_header":"","comment_is_top":false,"comment_ctime":1664183766,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664183766","product_id":100039001,"comment_content":"这是对多态的增强吧，保持代码不违背LSP也是让代码保持更高可维护性的一种方式","like_count":0},{"had_liked":false,"id":356971,"user_name":"音为","can_delete":false,"product_type":"c1","uid":1313115,"ip_address":"北京","ucode":"D78E4CBCE6BF45","user_header":"https://static001.geekbang.org/account/avatar/00/14/09/5b/e9ee3b41.jpg","comment_is_top":false,"comment_ctime":1662767416,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662767416","product_id":100039001,"comment_content":"里氏替换原则本质上是对扩展开放，修改封闭的父子关系的具体实现","like_count":0},{"had_liked":false,"id":353194,"user_name":"王政","can_delete":false,"product_type":"c1","uid":2297381,"ip_address":"湖南","ucode":"A7DCA909FC8A38","user_header":"https://static001.geekbang.org/account/avatar/00/23/0e/25/aad87c07.jpg","comment_is_top":false,"comment_ctime":1659250903,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1659250903","product_id":100039001,"comment_content":"里氏替换，是模块化思维的一种体现，对于一个模块的开发维护者而言，当外界对于该模块的输入输出确定下来之后，要确保自己在模块内部的一切行为都符合外部对该模块的预期，任何修改都是仅仅对模块内部生效的。确保别人对我们的预期不变，赢得外部世界的信任（哲学起来了。","like_count":0},{"had_liked":false,"id":351125,"user_name":"李建军","can_delete":false,"product_type":"c1","uid":3041498,"ip_address":"","ucode":"599DD628C9A183","user_header":"","comment_is_top":false,"comment_ctime":1657536044,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657536044","product_id":100039001,"comment_content":"多态是java语言设计中的一种语言技术，而里式替换确实从业务层面去在多态的基础上做约定。我理解的对吗？","like_count":0},{"had_liked":false,"id":349412,"user_name":"时光流逝x","can_delete":false,"product_type":"c1","uid":1695455,"ip_address":"","ucode":"D7334E717D9ED0","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqUMEsVYklTc7akT2e6pfytu4jTQ88EVe1H6L2eHdXC6G8sbKCvfrnSDUIRq229M2Wt419LX2q8SQ/132","comment_is_top":false,"comment_ctime":1655956278,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655956278","product_id":100039001,"comment_content":"我对里氏替换原则的理解是子类可以对父类的功能做增强，但是不能改变已应用的逻辑，想想实际开发中，如果有一个父类已经完成了功能，系统正常运行中，但是由于后续需要增强部分功能而设计了子类去替换并且没有保留父类功能的原有效果那么系统大概会乱套吧。","like_count":0},{"had_liked":false,"id":348797,"user_name":"Geek_624df5","can_delete":false,"product_type":"c1","uid":1397370,"ip_address":"","ucode":"3C6801F9B7475D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJuAPSxrfe7zwKQlqu3I1iaWkUc0hDUBKdVUpSbqnw7actcfrfia279zLfKEycYccYR4HICrPiaNCN5Q/132","comment_is_top":false,"comment_ctime":1655417949,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655417949","product_id":100039001,"comment_content":"里氏替换是对面向对象多态特性应用过程的一个规范，如果我们的代码遵循面对接口编程，那接口与接口之间的协作都是通过接口的描述来进行的，如果在实现或继承这些接口的时候，没有完全按照接口的描述来提供行为，那就会发生欺骗，调用方在使用你的接口的时候就很容易出错。接口与接口间的信任就不存在了","like_count":0},{"had_liked":false,"id":348706,"user_name":"JLOMG","can_delete":false,"product_type":"c1","uid":2984369,"ip_address":"","ucode":"17EB1366167299","user_header":"https://static001.geekbang.org/account/avatar/00/2d/89/b1/6444e86b.jpg","comment_is_top":false,"comment_ctime":1655336007,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655336007","product_id":100039001,"comment_content":"里氏替换原则是子类和父类之间的契约，要求子类完全按照父类的行为规范设计，可以改变内部逻辑但要求最终结果不可以与父类结果相反","like_count":0},{"had_liked":false,"id":348366,"user_name":"ACT","can_delete":false,"product_type":"c1","uid":2600235,"ip_address":"","ucode":"8E5747D75045A7","user_header":"https://static001.geekbang.org/account/avatar/00/27/ad/2b/46b4a196.jpg","comment_is_top":false,"comment_ctime":1655023961,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655023961","product_id":100039001,"comment_content":"里氏替换原则就是在按照父类的约定来进行实现，其中可以修改函数的逻辑等，但是修改后的子类不能违背LSP的几个方面，如函数的实现，父类的输入输出 异常抛出，父类的一些特殊情况等，就是父类所有满足的情况，子类都要满足，不能出现父类可以，而子类不可以的情况，这种可以用父类的单元测试来尝试测试！！","like_count":0},{"had_liked":false,"id":347338,"user_name":"邓嘉文","can_delete":false,"product_type":"c1","uid":2332845,"ip_address":"","ucode":"FCEDFABFB48055","user_header":"https://static001.geekbang.org/account/avatar/00/23/98/ad/f9d755f2.jpg","comment_is_top":false,"comment_ctime":1653960740,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653960740","product_id":100039001,"comment_content":"之类重写父类方法改变了函数定义的功能，输入，输出，异常等约定","like_count":0},{"had_liked":false,"id":344734,"user_name":"冯仁彬","can_delete":false,"product_type":"c1","uid":2960877,"ip_address":"","ucode":"6E5CA08BC6366B","user_header":"","comment_is_top":false,"comment_ctime":1651742140,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651742140","product_id":100039001,"comment_content":"里氏替换原则是基于多态来实现的，但是在实现的子类代码逻辑中不能出现与父类输入、输出、逻辑和语义的不一致。<br><br>里氏替换原则的意义是让我们在不破坏原有代码逻辑的基础上进行功能扩展、增强。","like_count":0},{"had_liked":false,"id":344145,"user_name":"oracle98","can_delete":false,"product_type":"c1","uid":2302762,"ip_address":"","ucode":"F5A2795B46E27B","user_header":"","comment_is_top":false,"comment_ctime":1651300982,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651300982","product_id":100039001,"comment_content":"子类完美继承父类的设计初衷。精彩！","like_count":0},{"had_liked":false,"id":341622,"user_name":"Geek_441001","can_delete":false,"product_type":"c1","uid":2421724,"ip_address":"","ucode":"159C7D1965FDD9","user_header":"","comment_is_top":false,"comment_ctime":1649738234,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649738234","product_id":100039001,"comment_content":"多态是面向对象编程语言提供的一种特性，只要求子类中重写的方法输入输出相同，不关心内部具体实现。而里氏替换原则，则是针对子类方法如何重写的一种约束。","like_count":0},{"had_liked":false,"id":338882,"user_name":"顺势而为","can_delete":false,"product_type":"c1","uid":2757858,"ip_address":"","ucode":"FE7D688D24823E","user_header":"https://static001.geekbang.org/account/avatar/00/2a/14/e2/f6f1627c.jpg","comment_is_top":false,"comment_ctime":1647770986,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647770986","product_id":100039001,"comment_content":"1.里氏替换原则的目的是为了解决设计，也就是约定我们如何实现代码的设计的。<br>2.有了他，你可以重写父类，但是不要违背父类的基本，否则你自己和父类脱离关系，自己搞一个class发展吧，别污染。<br>3.要明白，多态和里氏替换原则是区分开的。<br>多态就是你可以做很多事情，和父类无关。<br>里氏替换原则就是，你做的事情，不能违背父类。","like_count":0},{"had_liked":false,"id":338109,"user_name":"鹏","can_delete":false,"product_type":"c1","uid":1528796,"ip_address":"","ucode":"5E0F60BBA91129","user_header":"https://static001.geekbang.org/account/avatar/00/17/53/dc/3a16bb1e.jpg","comment_is_top":false,"comment_ctime":1647306180,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647306180","product_id":100039001,"comment_content":"要符合顶层协议","like_count":0},{"had_liked":false,"id":335612,"user_name":"乌木玉","can_delete":false,"product_type":"c1","uid":1243753,"ip_address":"","ucode":"9B5220D073538C","user_header":"https://static001.geekbang.org/account/avatar/00/12/fa/69/352fb079.jpg","comment_is_top":false,"comment_ctime":1645603987,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645603987","product_id":100039001,"comment_content":"关于多态以及LSP，个人的一些思考：<br>多态是面向对象编程的一大特性，开发者可以利用多态，随意继承和改写父类方法，以适应多变的业务需求。如果不加以约束，会出现歪曲父类方法约定，让人不知所云，导致容易用错或无法使用的情况。 <br>LSP则在这种背景下，加以约束，让开发者在一开始设计时，就能了解父类的真实目的和边界，从而更合理的设计子类，当不适合设计为继承关系的，可以优先考虑组合关系，将逻辑剥离；这样做，更印证了单一原则。","like_count":0},{"had_liked":false,"id":334437,"user_name":"走向200","can_delete":false,"product_type":"c1","uid":1730554,"ip_address":"","ucode":"B197202CB63A6D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/9qx9Zwr6vIZJch6a5VUgwBLlZ0bfuLQ559keeekPF8RBBFZ50Im6AXFHXnSnlgfAdwzCKhGPbYv3pNfPQOoJiaQ/132","comment_is_top":false,"comment_ctime":1644935385,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644935385","product_id":100039001,"comment_content":"感觉里氏替换原则就是“父债子还”的意思，而且一分都不能少","like_count":0},{"had_liked":false,"id":334019,"user_name":"it to learn","can_delete":false,"product_type":"c1","uid":2407402,"ip_address":"","ucode":"B1D3316042BEAD","user_header":"https://static001.geekbang.org/account/avatar/00/24/bb/ea/160e4c38.jpg","comment_is_top":false,"comment_ctime":1644674628,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644674628","product_id":100039001,"comment_content":"里氏替换原则指的是子类必须“兼容”父类的逻辑，不能因为重写父类方法而是父类方法逻辑缺损丢失吗？","like_count":0},{"had_liked":false,"id":333899,"user_name":"跳跳","can_delete":false,"product_type":"c1","uid":2771298,"ip_address":"","ucode":"8999B46CF6D197","user_header":"https://static001.geekbang.org/account/avatar/00/2a/49/62/db480ab6.jpg","comment_is_top":false,"comment_ctime":1644573658,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1644573658","product_id":100039001,"comment_content":"感觉这是个在重构代码时，需要遵守的原则。","like_count":0},{"had_liked":false,"id":333528,"user_name":"斑马线","can_delete":false,"product_type":"c1","uid":2805127,"ip_address":"","ucode":"32232868BAE53C","user_header":"https://static001.geekbang.org/account/avatar/00/2a/cd/87/d06540db.jpg","comment_is_top":false,"comment_ctime":1644394359,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644394359","product_id":100039001,"comment_content":"如果子类确实会违反父类的约定，是不是表明父类设计得不合理？一般这种场景如何处理？放弃使用继承吗？","like_count":0},{"had_liked":false,"id":332753,"user_name":"vinci","can_delete":false,"product_type":"c1","uid":2050522,"ip_address":"","ucode":"F7A0B618F36812","user_header":"https://static001.geekbang.org/account/avatar/00/1f/49/da/d284b8d3.jpg","comment_is_top":false,"comment_ctime":1643549154,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643549154","product_id":100039001,"comment_content":"如果父类有一个方法大部分子类都需要用到，但是有一个子类不应该有这个方法，那么应该如何实现呢?<br>是应该严格遵守lsp，把这个方法的定义分别放到其他子类中；还是应该在把这个方法放在父类，在不需要这个方法的子类中，对这个方法进行诸如抛出错误之类的禁用手段呢?","like_count":0},{"had_liked":false,"id":328691,"user_name":"邵亮","can_delete":false,"product_type":"c1","uid":1810890,"ip_address":"","ucode":"8407C3FDD11C0E","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a1/ca/aae116f5.jpg","comment_is_top":false,"comment_ctime":1640844070,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1640844070","product_id":100039001,"comment_content":"指导程序开发，在这基础上做增强","like_count":0},{"had_liked":false,"id":327503,"user_name":"程伟","can_delete":false,"product_type":"c1","uid":2398017,"ip_address":"","ucode":"A1EF868FD7D4A6","user_header":"https://static001.geekbang.org/account/avatar/00/24/97/41/63115c89.jpg","comment_is_top":false,"comment_ctime":1640153684,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640153684","product_id":100039001,"comment_content":"里氏替换需要借助多态来实现，但是用到多态的地方不一定是里氏替换。","like_count":0},{"had_liked":false,"id":327161,"user_name":"孙大龙Lemon","can_delete":false,"product_type":"c1","uid":1028041,"ip_address":"","ucode":"040F363A07FC64","user_header":"https://static001.geekbang.org/account/avatar/00/0f/af/c9/9db8fc5d.jpg","comment_is_top":false,"comment_ctime":1639964464,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1639964464","product_id":100039001,"comment_content":"如果不通过lsp对集成关系做约束，那么继承关系一旦超过2层，基本不可维护，使用者需要知道每一层累具体的实现，违背了继承的初衷","like_count":0},{"had_liked":false,"id":326807,"user_name":"江谢木","can_delete":false,"product_type":"c1","uid":1563403,"ip_address":"","ucode":"E1B1B0F0F03D41","user_header":"https://static001.geekbang.org/account/avatar/00/17/db/0b/f0ded153.jpg","comment_is_top":false,"comment_ctime":1639706866,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639706866","product_id":100039001,"comment_content":"既然是继承就说明两则是相关的，相关的东西一般是扩展&#47;增强实现，如果是重写就说明是不相关的，不相关的应该重新定义类而不是继承。所以LSP的意义在于保持设计初衷的统一性，代码的易读性。","like_count":0},{"had_liked":false,"id":323651,"user_name":"YX","can_delete":false,"product_type":"c1","uid":2636178,"ip_address":"","ucode":"CC108CCE845EAE","user_header":"https://static001.geekbang.org/account/avatar/00/28/39/92/88ed94f2.jpg","comment_is_top":false,"comment_ctime":1638070067,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1638070067","product_id":100039001,"comment_content":"不以规矩，不成方圆<br>父母在，不远游","like_count":0},{"had_liked":false,"id":323040,"user_name":"天亮前说晚安","can_delete":false,"product_type":"c1","uid":1541014,"ip_address":"","ucode":"1D82EE562A7C71","user_header":"https://static001.geekbang.org/account/avatar/00/17/83/96/73ff13a0.jpg","comment_is_top":false,"comment_ctime":1637715152,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637715152","product_id":100039001,"comment_content":"多态是语言的特性，理式变换是编程的原则。多态可以用于实现这个原则。协议就是输入输出和异常；强类型语言中，输入输出都很容易遵守，但是异常可能很多人忽视的一个方面。本人以前也没理解异常这个输出。","like_count":0},{"had_liked":false,"id":321121,"user_name":"二小","can_delete":false,"product_type":"c1","uid":1593919,"ip_address":"","ucode":"5377CB552237B2","user_header":"https://static001.geekbang.org/account/avatar/00/18/52/3f/c8b40efe.jpg","comment_is_top":false,"comment_ctime":1636683945,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636683945","product_id":100039001,"comment_content":"还是为了代码的扩展性，当利用多态进行扩展的时候，我们新写的功能如果违背了LSP，那么就有可能在某个替换点出现异常，如果替换点少还好，如果多的话会使替换变的繁琐","like_count":0},{"had_liked":false,"id":320284,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1636201227,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636201227","product_id":100039001,"comment_content":"思考题，个人理解：<br>里氏替换原则存在的意义有两条：<br>第一，程序移植，由于里氏替换原则要求子类的实现不能违背父类要实现的功能，也不能违背父类对输入、输出、异常的约定，因此，在把一个应用从一个平台移植到另一个平台时，把要移植的类看成是父类，然后重新构造它的一个子类，对类中的某些功能，可以应用里氏替换设计原则结合新平台的特征覆盖其原有功能，重构后的功能、输入、输出及异常捕捉都和原有父类中的功能保持一致，从而达到跨平台应用的目的。<br><br>第二，程序重构和优化，如果类中的某些功能实现较复杂，代码混乱且没有按规范书写，如果要对这些代码进行重构和优化，那就需要读懂原有代码的业务逻辑和算法，对于书写不规范，可读性差的代码这是一件相当困难的事；而如果原有的这个功能有较完整的功能说明或详细设计，那就可以应用里氏替换原则，把原有的类当做是父类，重新构造其的一个子类，根据功能说明，重新实现需要优化或重构的那块功能，这样就不需要去读原有的代码就可达到代码重构的目的。","like_count":0},{"had_liked":false,"id":319699,"user_name":"Geek_jerry","can_delete":false,"product_type":"c1","uid":1736148,"ip_address":"","ucode":"684923936D7849","user_header":"","comment_is_top":false,"comment_ctime":1635915075,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635915075","product_id":100039001,"comment_content":"老师，请问下为什么要遵守这个原则，不遵守这个原则会造成哪些问题？","like_count":0},{"had_liked":false,"id":316611,"user_name":"Zeroassetsor","can_delete":false,"product_type":"c1","uid":1042221,"ip_address":"","ucode":"151747E0300D2D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e7/2d/e71299b9.jpg","comment_is_top":false,"comment_ctime":1634451072,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634451072","product_id":100039001,"comment_content":"核心要义就是按照父类的契约设计子类，改进扩展父类的方法，而不破坏原有逻辑，使程序顺利运行。","like_count":0},{"had_liked":false,"id":316244,"user_name":"千锤百炼领悟之极限","can_delete":false,"product_type":"c1","uid":1744257,"ip_address":"","ucode":"224B5CF2101716","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9d/81/d748b7eb.jpg","comment_is_top":false,"comment_ctime":1634218003,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634218003","product_id":100039001,"comment_content":"里氏替换原则的思想是desgin by contract，用来指导继承关系中子类的设计，是一种设计原则。多态是面向对象编程的语法，是代码实现的思想。","like_count":0},{"had_liked":false,"id":315632,"user_name":"王智洋","can_delete":false,"product_type":"c1","uid":1666517,"ip_address":"","ucode":"B38934EA504663","user_header":"https://static001.geekbang.org/account/avatar/00/19/6d/d5/81e72368.jpg","comment_is_top":false,"comment_ctime":1633931271,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633931271","product_id":100039001,"comment_content":"进行扩展的同时不会破坏原有的业务逻辑","like_count":0},{"had_liked":false,"id":313443,"user_name":" 你的名字","can_delete":false,"product_type":"c1","uid":1514987,"ip_address":"","ucode":"FAFE636695004D","user_header":"https://static001.geekbang.org/account/avatar/00/17/1d/eb/1b39d28e.jpg","comment_is_top":false,"comment_ctime":1632445036,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632445036","product_id":100039001,"comment_content":"多态是面相对象中的一种语法，替换原则里氏是一种设计原则","like_count":0},{"had_liked":false,"id":313356,"user_name":" 你的名字","can_delete":false,"product_type":"c1","uid":1514987,"ip_address":"","ucode":"FAFE636695004D","user_header":"https://static001.geekbang.org/account/avatar/00/17/1d/eb/1b39d28e.jpg","comment_is_top":false,"comment_ctime":1632387268,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632387268","product_id":100039001,"comment_content":"里氏替换原则：子类的设计要在父类被替换的时候，保证不改变原有逻辑并且不破坏原有程序的正确性的情况下进行","like_count":0},{"had_liked":false,"id":312644,"user_name":"charmsongo","can_delete":false,"product_type":"c1","uid":1609051,"ip_address":"","ucode":"4FBEE716E93A1A","user_header":"https://static001.geekbang.org/account/avatar/00/18/8d/5b/383a49e4.jpg","comment_is_top":false,"comment_ctime":1631925066,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631925066","product_id":100039001,"comment_content":"多态是面向对象的一种语法，里式替换原则是一种设计原则，父类方法的约定，子类不能破坏，约定包括 方法生命的实际作用，入参、出参、异常处理和特殊处理的声明，子类都不能破坏。<br><br>个人感觉多态范围更广，里式替换原则只是基于该语法上的一种设计方案","like_count":0},{"had_liked":false,"id":309088,"user_name":"小王在努力","can_delete":false,"product_type":"c1","uid":2733574,"ip_address":"","ucode":"A324EF87198905","user_header":"https://static001.geekbang.org/account/avatar/00/29/b6/06/cd1eaa49.jpg","comment_is_top":false,"comment_ctime":1629939347,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629939347","product_id":100039001,"comment_content":"里氏替换原则中针对父类已实现的方法，子类是不应该进行重写吧，子类可以可以重写父类的抽象方法，不是这样吗？","like_count":0},{"had_liked":false,"id":308858,"user_name":"小马哥","can_delete":false,"product_type":"c1","uid":1358045,"ip_address":"","ucode":"B2C0FF38F8C9BC","user_header":"https://static001.geekbang.org/account/avatar/00/14/b8/dd/37726c34.jpg","comment_is_top":false,"comment_ctime":1629826553,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629826553","product_id":100039001,"comment_content":"里式替换原则存在的意义: 指导子类的设计, 即按照约定来设计, 做到在功能上设计出来的子类可以替换掉父类, 而不是违背了父类的意图.","like_count":0},{"had_liked":false,"id":307828,"user_name":"You","can_delete":false,"product_type":"c1","uid":2662969,"ip_address":"","ucode":"ACBDB82E9B39C4","user_header":"https://static001.geekbang.org/account/avatar/00/28/a2/39/3ee6f996.jpg","comment_is_top":false,"comment_ctime":1629274403,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629274403","product_id":100039001,"comment_content":"个人觉得：LSP主要起到的作用是维护“接口”的稳定性、提高可扩展性、提高在不改变父类实现，违背开闭原则的前提下还能做到提高性能。维护“接口”的稳定性是子类实现和父类实现的“协议”相同，直接点说就是子类可以完全替代父类执行。在没有实现子类之前，外来接口调用父类方法可以完成任务，实现子类之后，外来接口就可以直接调用高效的子类方式代替父类执行。相比直接修改父类代码，违背开闭原则的方式来提高性能要做得更好，并且保持协议不变的情况下做到版本迭代优化。","like_count":0},{"had_liked":false,"id":307188,"user_name":"易飞","can_delete":false,"product_type":"c1","uid":2630424,"ip_address":"","ucode":"32AC28754237F7","user_header":"https://static001.geekbang.org/account/avatar/00/28/23/18/4284361f.jpg","comment_is_top":false,"comment_ctime":1628926071,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628926071","product_id":100039001,"comment_content":"保证老的单元测试正常，保证结果不变","like_count":0},{"had_liked":false,"id":306704,"user_name":"Geek_b7eb88","can_delete":false,"product_type":"c1","uid":1573715,"ip_address":"","ucode":"0EB46381D9B1CB","user_header":"","comment_is_top":false,"comment_ctime":1628673126,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628673126","product_id":100039001,"comment_content":"可以大致认为里氏替换原则是为了规范继承的子类和多态的使用吗","like_count":0},{"had_liked":false,"id":304478,"user_name":"morningking","can_delete":false,"product_type":"c1","uid":1067728,"ip_address":"","ucode":"4BBCABA455941B","user_header":"https://static001.geekbang.org/account/avatar/00/10/4a/d0/d75f0c62.jpg","comment_is_top":false,"comment_ctime":1627445116,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627445116","product_id":100039001,"comment_content":"多态是面向对象编程的一种特性和语法。<br>里氏替换是面向对象编程的一个原则，指导子类如何设计而不破坏协议约束，即子类可以扩展协议，但是不能修改协议。<br>协议包括接口的型构，接口的功能&#47;异常约定。","like_count":0},{"had_liked":false,"id":304049,"user_name":"Geek_tao","can_delete":false,"product_type":"c1","uid":2659998,"ip_address":"","ucode":"CD0FADA06B0659","user_header":"","comment_is_top":false,"comment_ctime":1627207099,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627207099","product_id":100039001,"comment_content":"可是有时候父类实现的是一个默认排序比如按时间， 方便扩展， 有多个子类， 不同的子类实现不同的排序方式， 这是否违反了里式原则","like_count":0},{"had_liked":false,"id":303603,"user_name":"米豆丸","can_delete":false,"product_type":"c1","uid":2042568,"ip_address":"","ucode":"CE99FE3A1EBCAF","user_header":"https://static001.geekbang.org/account/avatar/00/1f/2a/c8/dc4e314e.jpg","comment_is_top":false,"comment_ctime":1626870360,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626870360","product_id":100039001,"comment_content":"爹是有原则的，孩子们在原则范围内自由发挥成长","like_count":0},{"had_liked":false,"id":303137,"user_name":"九尾","can_delete":false,"product_type":"c1","uid":2429969,"ip_address":"","ucode":"3E6BDF7B9C78FC","user_header":"https://static001.geekbang.org/account/avatar/00/25/14/11/f1220081.jpg","comment_is_top":false,"comment_ctime":1626607727,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626607727","product_id":100039001,"comment_content":"突然想起之前修改代码的过于随意了，难怪我在添加函数参数之后发现，过不了多久类就会变得难以维护，导致了一大堆的拷贝代码","like_count":0},{"had_liked":false,"id":300897,"user_name":"爱上我们的微笑","can_delete":false,"product_type":"c1","uid":1459863,"ip_address":"","ucode":"40CDB7AB0991CE","user_header":"https://static001.geekbang.org/account/avatar/00/16/46/97/ddd4b05f.jpg","comment_is_top":false,"comment_ctime":1625445594,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625445594","product_id":100039001,"comment_content":"LSP核心为“Design By Contract”。子类的重写函数要求协议输入，输出，异常处理都为一致。该协议主要指导子类如何设计实现。<br>","like_count":0},{"had_liked":false,"id":300780,"user_name":"布拉姆","can_delete":false,"product_type":"c1","uid":1311125,"ip_address":"","ucode":"479FF27D73BCAD","user_header":"https://static001.geekbang.org/account/avatar/00/14/01/95/fd09e8a8.jpg","comment_is_top":false,"comment_ctime":1625385029,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625385029","product_id":100039001,"comment_content":"LSP: 子类相比父类，功能只能细化、增强而不能修改。","like_count":0},{"had_liked":false,"id":298866,"user_name":"geek_666888","can_delete":false,"product_type":"c1","uid":2024635,"ip_address":"","ucode":"3E348CCE186ACF","user_header":"","comment_is_top":false,"comment_ctime":1624350179,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624350179","product_id":100039001,"comment_content":"本质就是要“萧规曹随”“祖制不可改”。 而多态可以只是嘴上“遵循祖制”。","like_count":0},{"had_liked":false,"id":298049,"user_name":"昵称C","can_delete":false,"product_type":"c1","uid":1234963,"ip_address":"","ucode":"1BB2D537942DC2","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/13/082013bc.jpg","comment_is_top":false,"comment_ctime":1623896753,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623896753","product_id":100039001,"comment_content":"里氏替换原则存在的意义:<br>里氏替换原则是多态特性的践行原则，可以保证在写出扩展性好的代码同时，也保证代码功能的一致性和稳定性；","like_count":0},{"had_liked":false,"id":297053,"user_name":"小万叔叔","can_delete":false,"product_type":"c1","uid":1448768,"ip_address":"","ucode":"41966A18867C63","user_header":"https://static001.geekbang.org/account/avatar/00/16/1b/40/68e59e53.jpg","comment_is_top":false,"comment_ctime":1623291766,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623291766","product_id":100039001,"comment_content":"里氏替换是建立在继承和多态的基础上，但却对继承和多态加了一个限制；保证了父类行为不被破坏，父类能诠释子类的作用，也增强了父类的指导意义。","like_count":0},{"had_liked":false,"id":296962,"user_name":"zart","can_delete":false,"product_type":"c1","uid":1148637,"ip_address":"","ucode":"E32677C0FD4421","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eomCrCRrLAWib0gMI2L2NbicMummlxOY6nVmphsDO0J3xx7OygNd8wJicc88RbNoHrcuXBsKLtCMvgFQ/132","comment_is_top":false,"comment_ctime":1623241416,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1623241416","product_id":100039001,"comment_content":"里式替换存在的意义：向下兼容","like_count":0},{"had_liked":false,"id":296290,"user_name":"李金鹏","can_delete":false,"product_type":"c1","uid":1445362,"ip_address":"","ucode":"8FCCA5B8BD8DDD","user_header":"https://static001.geekbang.org/account/avatar/00/16/0d/f2/3865fe28.jpg","comment_is_top":false,"comment_ctime":1622884457,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622884457","product_id":100039001,"comment_content":"我觉得里式替换原则存在的意义是，指导我们在编写子类时，不改变父类的原有功能。很多一开始设计很好的系统，最后变成祖传的烂代码，很多就是因为没有遵守里式替换原则","like_count":0},{"had_liked":false,"id":296094,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1622741369,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1622741369","product_id":100039001,"comment_content":"lsp，主要是用来指导设计子类的原则。","like_count":0},{"had_liked":false,"id":295810,"user_name":"奋斗","can_delete":false,"product_type":"c1","uid":2149661,"ip_address":"","ucode":"E9D191295B37D9","user_header":"https://static001.geekbang.org/account/avatar/00/20/cd/1d/64f014fe.jpg","comment_is_top":false,"comment_ctime":1622605144,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622605144","product_id":100039001,"comment_content":"如果 在SecurityTransporter 中不对入参进行必填校验，是不是业务上会出现问题呢，甚至都有可能调不通，这样的问题怎么权衡呢","like_count":0},{"had_liked":false,"id":295066,"user_name":"神垂死","can_delete":false,"product_type":"c1","uid":1016334,"ip_address":"","ucode":"EE924E8E0A6814","user_header":"https://static001.geekbang.org/account/avatar/00/0f/82/0e/9c42e6f9.jpg","comment_is_top":false,"comment_ctime":1622203454,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622203454","product_id":100039001,"comment_content":"如果子类满足里式替换的话，可以把父类的引用直接删掉，全部replace子类吗？这样就算重构了吧","like_count":0,"discussions":[{"author":{"id":1250922,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIzGGthScz54sECZJKX3lgyjCATkgrvSt5N3eOsYB34jibCr3SkAX88QaZ5IVmME9Ec7VdkQGwRSPw/132","nickname":"哈哈哈","note":"","ucode":"8AC20A1C9C7DF8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306412,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600264693,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015483,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","nickname":"程序员小跃","note":"","ucode":"25BB96E0791A60","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":223710,"discussion_content":"最后一句是经典，选择适合自己的方式解决业务问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586247536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294870,"user_name":"泰深森","can_delete":false,"product_type":"c1","uid":1401258,"ip_address":"","ucode":"A444D9F5C8B989","user_header":"https://static001.geekbang.org/account/avatar/00/15/61/aa/85e0592a.jpg","comment_is_top":false,"comment_ctime":1622118522,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622118522","product_id":100039001,"comment_content":"一句话，子类要能精准复刻父类行为，并且功能上有所扩展，","like_count":0},{"had_liked":false,"id":294321,"user_name":"Geek_5b7d28","can_delete":false,"product_type":"c1","uid":2057476,"ip_address":"","ucode":"BAA1CDD539C369","user_header":"","comment_is_top":false,"comment_ctime":1621899064,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621899064","product_id":100039001,"comment_content":"多态是告诉你可以这么用，里氏替换原则是告诉你怎么用。","like_count":0},{"had_liked":false,"id":293706,"user_name":"黄金果","can_delete":false,"product_type":"c1","uid":1456586,"ip_address":"","ucode":"329811FF99F4B8","user_header":"https://static001.geekbang.org/account/avatar/00/16/39/ca/cdc58834.jpg","comment_is_top":false,"comment_ctime":1621500517,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621500517","product_id":100039001,"comment_content":"里氏替换原则存在的意义是否是因为, 当使用多态的时候, 子类表达为父类, 如果子类违反了里氏替换原则(例如 : 子类违背父类对输入、输出、异常的约定), 则需要对各个子类做不同的处理, 就失去了多态的意义","like_count":0},{"had_liked":false,"id":290614,"user_name":"MrVito","can_delete":false,"product_type":"c1","uid":1252169,"ip_address":"","ucode":"716FF6F8871706","user_header":"https://static001.geekbang.org/account/avatar/00/13/1b/49/ddefc656.jpg","comment_is_top":false,"comment_ctime":1619659722,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619659722","product_id":100039001,"comment_content":"改进已实现，不能改动已实现的","like_count":0},{"had_liked":false,"id":290556,"user_name":"k先生","can_delete":false,"product_type":"c1","uid":1221532,"ip_address":"","ucode":"76D292DC62B52D","user_header":"https://static001.geekbang.org/account/avatar/00/12/a3/9c/8a14b7db.jpg","comment_is_top":false,"comment_ctime":1619616470,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619616470","product_id":100039001,"comment_content":"那么问题来了，必须遵守这个规则吗？或者说好的设计模式必须遵守吗？","like_count":0},{"had_liked":false,"id":290529,"user_name":"Geek_56a189","can_delete":false,"product_type":"c1","uid":2586543,"ip_address":"","ucode":"F3258B958DF2FB","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/KQyib1vpanF1CBYpBFadYdHPYlnv6TNtkqUMW6Xk0HoRNs5CXiaWQFguWGQicU34ykib9qX2yv3SmSHhHqia4SQ5icIg/132","comment_is_top":false,"comment_ctime":1619601317,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619601317","product_id":100039001,"comment_content":"个人理解里式替换就像我们想要换手机更新换代以一样，一般新出的手机（子类）都要比旧手机（父类）功能要多，速度要好，谁也不像换手机之后原有的功能不好使了，或者发短信功能变成打电话了之类的","like_count":0},{"had_liked":false,"id":288390,"user_name":"sailor","can_delete":false,"product_type":"c1","uid":1592031,"ip_address":"","ucode":"3B301A4BE9FB11","user_header":"https://static001.geekbang.org/account/avatar/00/18/4a/df/a3ee01da.jpg","comment_is_top":false,"comment_ctime":1618451927,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618451927","product_id":100039001,"comment_content":"LSP: 里氏替换原则，子类必须满足：<br>1.  与父类的功能实现一致<br>2. 与父类的协议约定一致（输入，输出，异常，特殊限制）","like_count":0},{"had_liked":false,"id":288175,"user_name":"Jiantao","can_delete":false,"product_type":"c1","uid":1163504,"ip_address":"","ucode":"444580EC5EF109","user_header":"https://static001.geekbang.org/account/avatar/00/11/c0/f0/1aabc056.jpg","comment_is_top":false,"comment_ctime":1618330296,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618330296","product_id":100039001,"comment_content":"存在意义：在代码扩展能力上，约束子类实现，保证系统行为一致","like_count":0},{"had_liked":false,"id":287688,"user_name":"二少","can_delete":false,"product_type":"c1","uid":1442885,"ip_address":"","ucode":"190983809CD3EC","user_header":"https://static001.geekbang.org/account/avatar/00/16/04/45/0c474d47.jpg","comment_is_top":false,"comment_ctime":1618109673,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618109673","product_id":100039001,"comment_content":"个人理解里氏代换的意义在于，可以在保持使用原有父类时所要遵守的约定不变的前提下，可以灵活地替换成不同的子类。","like_count":0},{"had_liked":false,"id":285112,"user_name":"小马哥","can_delete":false,"product_type":"c1","uid":1358045,"ip_address":"","ucode":"B2C0FF38F8C9BC","user_header":"https://static001.geekbang.org/account/avatar/00/14/b8/dd/37726c34.jpg","comment_is_top":false,"comment_ctime":1616631998,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616631998","product_id":100039001,"comment_content":"一句话总结LSP与多态的区别:<br>多态的目的: 让父类或接口根据引用的子类或实现的不同, 呈现出不同的功能形态;<br>里氏代换原则的目的: 对于多态中呈现出来的功能形态, 加了经验约束(不能违背父类功能的大方向).","like_count":0},{"had_liked":false,"id":283751,"user_name":"Graham","can_delete":false,"product_type":"c1","uid":1994570,"ip_address":"","ucode":"C2545DE16EC3DD","user_header":"","comment_is_top":false,"comment_ctime":1615903987,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615903987","product_id":100039001,"comment_content":"如果一定要破坏LSP原则，要怎么弄，重新设计基类，还是怎么弄？","like_count":0},{"had_liked":false,"id":282915,"user_name":"江小田","can_delete":false,"product_type":"c1","uid":1003149,"ip_address":"","ucode":"C5197BF856E8D3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/8d/34e0f6f3.jpg","comment_is_top":false,"comment_ctime":1615461504,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615461504","product_id":100039001,"comment_content":"原则的意思是要保留父类设计的初衷。<br>意义在于，如果有一天想要把父类替换成更强大的子类的时候。那么调用方对于父类调用方法的入参、异常处理、返回值处理，都可以做到无缝对接，无需担心某个地方未处理导致的新问题。","like_count":0},{"had_liked":false,"id":282042,"user_name":"椰子","can_delete":false,"product_type":"c1","uid":1537505,"ip_address":"","ucode":"55723E3E193D8F","user_header":"https://static001.geekbang.org/account/avatar/00/17/75/e1/1a5e8eb8.jpg","comment_is_top":false,"comment_ctime":1615026144,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615026144","product_id":100039001,"comment_content":"感觉就是违背了里氏替换会导致程序出现一些很不容易发现的BUG，所以要遵循它","like_count":0},{"had_liked":false,"id":280728,"user_name":"Lanyok","can_delete":false,"product_type":"c1","uid":1016669,"ip_address":"","ucode":"FB55036166E4AE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/83/5d/1129ca22.jpg","comment_is_top":false,"comment_ctime":1614328515,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614328515","product_id":100039001,"comment_content":"里式替换原则是表达子类与分类，或实现类与接口的设计关系和替换关系。<br>设计是要考虑到 design by contract.替换时子类可以替换父类，而代码的环境不会受到影响。","like_count":0},{"had_liked":false,"id":280533,"user_name":"饭太司替可","can_delete":false,"product_type":"c1","uid":1171829,"ip_address":"","ucode":"9A47FCA16199B0","user_header":"https://static001.geekbang.org/account/avatar/00/11/e1/75/bbdf9052.jpg","comment_is_top":false,"comment_ctime":1614243656,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614243656","product_id":100039001,"comment_content":"父类中有一个 打开客厅灯 的方法，具体实现是 按一下客厅灯的开关，子类 重写了这个方法，实现是 发出声音触发客厅灯的声控开关，但是如果子类发出声音后不仅打开了客厅灯，顺便打开了厨房的灯，那就是违反了LSP原则吧？","like_count":0},{"had_liked":false,"id":280428,"user_name":"小川","can_delete":false,"product_type":"c1","uid":1242573,"ip_address":"","ucode":"D462222DDBB978","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/cd/3890be04.jpg","comment_is_top":false,"comment_ctime":1614215261,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614215261","product_id":100039001,"comment_content":"扩展性是衡量代码好坏最重要的特性之一<br><br>抽象与多态特性能很好的支持扩展性<br><br>lsp 防止多态滥用，规定了子类实现或者继承父类（多态）所需的原则","like_count":0},{"had_liked":false,"id":280241,"user_name":"Chloe","can_delete":false,"product_type":"c1","uid":1004953,"ip_address":"","ucode":"C4848ED5B35752","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/99/4bdadfd3.jpg","comment_is_top":false,"comment_ctime":1614140284,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614140284","product_id":100039001,"comment_content":"请问如果说LSP是 Design by Contract，同时interface也是定义Contract，但是我们不能说只要按照interface写class就遵循了LSP，LSP可以是在实现上违背了contract的定义，对吗？","like_count":0},{"had_liked":false,"id":280236,"user_name":"DreamHeng","can_delete":false,"product_type":"c1","uid":1599490,"ip_address":"","ucode":"5562BFD8375138","user_header":"https://static001.geekbang.org/account/avatar/00/18/68/02/2d394d89.jpg","comment_is_top":false,"comment_ctime":1614138767,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614138767","product_id":100039001,"comment_content":"LSP里氏替换原则，其实就是约定规则，子类要遵守父类的约定，在任一父类对象中，都可以被子类对象所代替","like_count":0},{"had_liked":false,"id":278944,"user_name":"曾泽浩","can_delete":false,"product_type":"c1","uid":1104601,"ip_address":"","ucode":"A7E5CF9E1571A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/da/d9/f051962f.jpg","comment_is_top":false,"comment_ctime":1613477133,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1613477133","product_id":100039001,"comment_content":"想问一个问题，子类对父类的重载是违背了里式原则吗？<br>","like_count":0},{"had_liked":false,"id":278569,"user_name":"Geek_b7f618","can_delete":false,"product_type":"c1","uid":2400950,"ip_address":"","ucode":"8782A53CB61E15","user_header":"","comment_is_top":false,"comment_ctime":1613086285,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613086285","product_id":100039001,"comment_content":"里氏代换原则是一种设计思路，需要确保子类在接口级别上与父类保持一致的约定，包括出参入参异常等。这样才能保证使用多态时，子类的对象替代父类时能让外部调用程序天然适配。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503348,"discussion_content":"快照本身就是我自己想出来的一个题目，确实没有需求啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597453667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1179028,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fd/94/0247f945.jpg","nickname":"咸鱼","note":"","ucode":"5E79636DE48155","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298870,"discussion_content":"🤣","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597454853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":276174,"user_name":"我不是黄蓉我不会武功","can_delete":false,"product_type":"c1","uid":2416157,"ip_address":"","ucode":"E4BE01B01AF1BB","user_header":"https://static001.geekbang.org/account/avatar/00/24/de/1d/c1bd26dc.jpg","comment_is_top":false,"comment_ctime":1611821661,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611821661","product_id":100039001,"comment_content":"我理解的是虽然多态是一个OOP的特性之一，里氏替换是一种指导子类的设计原则，但是多态和里氏替换还是有很强的关系，离开了多态里氏替换几乎不可能实现","like_count":0},{"had_liked":false,"id":272432,"user_name":"Gabriel","can_delete":false,"product_type":"c1","uid":1437358,"ip_address":"","ucode":"714772A93E93DC","user_header":"https://static001.geekbang.org/account/avatar/00/15/ee/ae/855b7e6e.jpg","comment_is_top":false,"comment_ctime":1610089030,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610089030","product_id":100039001,"comment_content":"在说里式替换之前：咱们先得理清楚多态，这个概念（多态是面向对象的重要特性，简单点说：“一个接口，多种实现”，指一个基类中派生出不同的子类，且每个子类的继承了同样的方法名和**同时又对父类的方法做不同的实现**，就是同一个事物表现出多种形态。<br>多态：相当于，就是父母给孩子取了一个名字，名字只是一个孩子的简称，那孩子以后干什么，怎么干都不关父母的事。<br>里式替换呢：相当于法律，法律规定的条款，给你做事的范围，你怎么做不要紧，但是你不能超出法律的限制。<br>securityTransporter.java 继承了 Transport在，要实现的都是sendRequest的方法，但是中间你要怎么做验证，都没有改变父类的初衷。","like_count":0},{"had_liked":false,"id":269487,"user_name":"江南一笑","can_delete":false,"product_type":"c1","uid":2234620,"ip_address":"","ucode":"E38938A1178827","user_header":"https://static001.geekbang.org/account/avatar/00/22/18/fc/4f92ee4e.jpg","comment_is_top":false,"comment_ctime":1608685272,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608685272","product_id":100039001,"comment_content":"从自然认知上理解子类父类的关系。比如：&quot;人&quot; 是&quot;男人&quot;、&quot;女人&quot;的父类，但 &quot;成年人&quot;就不是&quot;男人&quot;,&quot;女人&quot;的父类。 把找个逻辑关系把握住了，就抓住了liskov substitution principle. ","like_count":0},{"had_liked":false,"id":268117,"user_name":"刘建军","can_delete":false,"product_type":"c1","uid":2348590,"ip_address":"","ucode":"25210BF7BE6BA8","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/We0naYhWttpJPDoO7TCndu5w1r4PSCdo57M61Zia8khXmM8GibicDzYdXiaJXZNok7274mSfB4aEMgxyiaDY1pRba0w/132","comment_is_top":false,"comment_ctime":1608078280,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608078280","product_id":100039001,"comment_content":"感觉一直在违背这个原则，override就是为了改变行为","like_count":0},{"had_liked":false,"id":267513,"user_name":"liupan","can_delete":false,"product_type":"c1","uid":1612910,"ip_address":"","ucode":"C6C7C48BCCAE12","user_header":"https://static001.geekbang.org/account/avatar/00/18/9c/6e/01b4d5d2.jpg","comment_is_top":false,"comment_ctime":1607782269,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607782269","product_id":100039001,"comment_content":"感觉里氏替换肯定是多态的实现，但是多态不一定满足理氏替换，有可能破坏了原则","like_count":0},{"had_liked":false,"id":266055,"user_name":"落尘","can_delete":false,"product_type":"c1","uid":1802622,"ip_address":"","ucode":"7B76B94CA301D7","user_header":"https://static001.geekbang.org/account/avatar/00/1b/81/7e/fb688b5c.jpg","comment_is_top":false,"comment_ctime":1607152327,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607152327","product_id":100039001,"comment_content":"里氏替换原则，是指导如何设计继承父类的子类的原则。最核心的思想是“design by contract 按照协议设计”，具体来说就是子类不能改变父类的逻辑行为，不能破坏程序的正确性。<br><br>其实里氏替换原则与基于接口编程的原则有共通之处，还记得争哥讲接口的时候提到接口就是“contract 协议”。顾名思义就是要遵循“协议”来实现接口和设计子类的方法实现。那么什么是“协议”，归根结底就是，OOP中类所抽象出来的行为。<br><br>里氏替换原则遵循了OOP抽象的需要，规范了继承时容易出现的多态问题，避免运行时出现不易察觉的错误。","like_count":0},{"had_liked":false,"id":263649,"user_name":"狼行天下","can_delete":false,"product_type":"c1","uid":1053161,"ip_address":"","ucode":"A3F22B276B88B1","user_header":"https://static001.geekbang.org/account/avatar/00/10/11/e9/13f28df2.jpg","comment_is_top":false,"comment_ctime":1606206848,"is_pvip":false,"replies":[{"id":"96087","content":"嗯嗯 ������","user_name":"作者回复","comment_id":263649,"uid":"1190123","ip_address":"","utype":1,"ctime":1606700694,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"1606206848","product_id":100039001,"comment_content":"LSP 规定子类替换父类，不能改变父类的输入、输出、异常等约定<br>常见的反例类型包括：1、子类违背父类声明要实现的功能。2、子类改变父类的输入、输出、异常等约定。3、子类违背父类注释中所罗列的特殊说明","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510256,"discussion_content":"嗯嗯 ������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262121,"user_name":"航哥很帅","can_delete":false,"product_type":"c1","uid":1145270,"ip_address":"","ucode":"23A1CB2A3723AF","user_header":"https://static001.geekbang.org/account/avatar/00/11/79/b6/faaa95a2.jpg","comment_is_top":false,"comment_ctime":1605616657,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1605616657","product_id":100039001,"comment_content":"里式替换原则的关键在于子类继承父类以后，可以改变重写函数的业务逻辑，但是有一些东西是不能改变的，比如：函数声明要实现的功能，输入和输出的限制，抛出异常的情况等。说的更简单一些，里式替换原则其实就是让子类的继承更加增强了。子类可以通过继承来实现多态，但这个继承是有限制的，这个限制就是里式替换原则。<br><br><br>有一个非常简单的检查子类是否满足里式替换原则的方法：用父类中的单元测试方法验证子类中的功能是否正常，如果单元测试出现异常，就说明极有可能子类的实现违反了里式替换原则。","like_count":0},{"had_liked":false,"id":256176,"user_name":"紫日","can_delete":false,"product_type":"c1","uid":1207410,"ip_address":"","ucode":"73A8DEE323AC19","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXSb2jAzlMM0JdTjWrNiaq2uR9eeloBYp906POddb9evmuj5f4CUoO6ge8TibibwtZicnl1sRHic9rW7g/132","comment_is_top":false,"comment_ctime":1603547021,"is_pvip":true,"discussion_count":0,"race_medal":4,"score":"1603547021","product_id":100039001,"comment_content":"用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。","like_count":0},{"had_liked":false,"id":255840,"user_name":"刘长锋","can_delete":false,"product_type":"c1","uid":1060922,"ip_address":"","ucode":"E4ABC6E335C989","user_header":"https://static001.geekbang.org/account/avatar/00/10/30/3a/e970285b.jpg","comment_is_top":false,"comment_ctime":1603441362,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603441362","product_id":100039001,"comment_content":"个人理解，里氏替换原则，使类的代码功能设计更规范，更符合源码阅读者的预期，方便维护。","like_count":0},{"had_liked":false,"id":251935,"user_name":"大力水手Jerry","can_delete":false,"product_type":"c1","uid":1227840,"ip_address":"","ucode":"E4A6C71E275DB5","user_header":"https://static001.geekbang.org/account/avatar/00/12/bc/40/2279cfb5.jpg","comment_is_top":false,"comment_ctime":1601988020,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601988020","product_id":100039001,"comment_content":"在面向对象领域，我们关注多态，除了希望利用函数行为的**差异性**外，还希望函数行为**表现一致**，确保相关业务逻辑实现的一致：我们希望所有实现类的特定接口行为表现，在输入条件，输出结果（正常和异常）都是一样的。否则我们就需要根据具体类（不论它们是否是父子类，还是接口&#47;实现类关系）的不同，定制不同的业务处理逻辑，而这将大大的损害多态的名声。","like_count":0},{"had_liked":false,"id":250608,"user_name":"朱月俊","can_delete":false,"product_type":"c1","uid":1017707,"ip_address":"","ucode":"4DA0728B862FBD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/6b/0b6cd39a.jpg","comment_is_top":false,"comment_ctime":1601170666,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601170666","product_id":100039001,"comment_content":"Design by contract适用于不同模块，类，方法之间交互，不会因为模块，类，方法内部实现的改变而影响其他模块，类，方法的功能，从这个层面来说，达到了解耦的效果。","like_count":0},{"had_liked":false,"id":247589,"user_name":"Harlan","can_delete":false,"product_type":"c1","uid":2134882,"ip_address":"","ucode":"F43595A0A00B19","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erpYZalYvFGcBs7zZvYwaQAZwTLiaw0mycJ4PdYpP3VxAYkAtyIRHhjSOrOK0yESaPpgEbVQUwf6LA/132","comment_is_top":false,"comment_ctime":1599749140,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599749140","product_id":100039001,"comment_content":"里式替换法则更多是一种开闭原则","like_count":0},{"had_liked":false,"id":247215,"user_name":"Younger Ku","can_delete":false,"product_type":"c1","uid":1323102,"ip_address":"","ucode":"D157DC38BDB515","user_header":"https://static001.geekbang.org/account/avatar/00/14/30/5e/c42bc33f.jpg","comment_is_top":false,"comment_ctime":1599635161,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599635161","product_id":100039001,"comment_content":"还有个依赖倒置，和李氏替换也有一定关系吧。今天学了李氏替换感觉理解更深入了一层。","like_count":0},{"had_liked":false,"id":247155,"user_name":"醉碧川","can_delete":false,"product_type":"c1","uid":1196641,"ip_address":"","ucode":"B0DCE5E48FDD82","user_header":"https://static001.geekbang.org/account/avatar/00/12/42/61/de579755.jpg","comment_is_top":false,"comment_ctime":1599619706,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599619706","product_id":100039001,"comment_content":"里氏替换原则的理解，父类能做到的事情，子类必须一板一眼的照做，不能做任何的变动，但是父类没有的功能，子类可以增加。","like_count":0},{"had_liked":false,"id":246911,"user_name":"大力","can_delete":false,"product_type":"c1","uid":1364353,"ip_address":"","ucode":"1B2125C519443D","user_header":"https://static001.geekbang.org/account/avatar/00/14/d1/81/89ba9d81.jpg","comment_is_top":false,"comment_ctime":1599528980,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599528980","product_id":100039001,"comment_content":"里氏替换原则的意义就是，子类可以任意扩充或替换父类的逻辑，前提是在不违反父类制定的“协议”的情况下。","like_count":0},{"had_liked":false,"id":246339,"user_name":"JerryZhu","can_delete":false,"product_type":"c1","uid":1591223,"ip_address":"","ucode":"76850CD45786C1","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","comment_is_top":false,"comment_ctime":1599285445,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599285445","product_id":100039001,"comment_content":"里氏替换原则最大作用就是在保证父类实现方法的 入参 出参  异常等不变的前提下， 尽可能的实现子类对父类多样化功能的扩展， 我来举个例子不知道对不对， 老师可以帮我检查一下，  比如提现可以发送通知， 而父类只有提现的逻辑， 子类可以扩充一个异步mq提现通知，这个算不算里氏替换， 因为发送mq通知业务如果并不需要关注是否一定发送成功，那么完全不会影响到原父类逻辑","like_count":0},{"had_liked":false,"id":246241,"user_name":"郁晨","can_delete":false,"product_type":"c1","uid":1257469,"ip_address":"","ucode":"760E0A6B3136B9","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/fd/d5683568.jpg","comment_is_top":false,"comment_ctime":1599218530,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599218530","product_id":100039001,"comment_content":"子类与父类实现逻辑与输入输出的信息都不违背","like_count":0},{"had_liked":false,"id":245953,"user_name":"宇天飞","can_delete":false,"product_type":"c1","uid":1126444,"ip_address":"","ucode":"3FB37D1E2DAA61","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/2c/06375913.jpg","comment_is_top":false,"comment_ctime":1599120525,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1599120525","product_id":100039001,"comment_content":"LSP：指导子对象的设计，保证子对象继承父对象的行为不变，包括声明、注释、异常、功能等","like_count":0},{"had_liked":false,"id":245249,"user_name":"郑大钱","can_delete":false,"product_type":"c1","uid":1503067,"ip_address":"","ucode":"114CF48056880E","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/5b/ff28088f.jpg","comment_is_top":false,"comment_ctime":1598875549,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598875549","product_id":100039001,"comment_content":"里式替换是规范使用多态的一个原则，不改变父类方法原有的执行流程，不修改父类方法的设计初衷，只通过重写的方式来扩展父类的方法。<br>如果不得已要修改父类的设计，那要考虑看看是不是抽象出了问题，是否需要重构代码。","like_count":0},{"had_liked":false,"id":244204,"user_name":"好名字","can_delete":false,"product_type":"c1","uid":1951501,"ip_address":"","ucode":"E2BFD96F912A67","user_header":"https://static001.geekbang.org/account/avatar/00/1d/c7/0d/0dab398b.jpg","comment_is_top":false,"comment_ctime":1598428282,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598428282","product_id":100039001,"comment_content":"父类方法尽量通用，父类是接口类最好，子类可以任意定义实现，都不会影响里示替换，否则子类重写父类方法，就一定不要修改输入&#47;输出&#47;异常情况。等于说继承不要无限制的继承。","like_count":0},{"had_liked":false,"id":243388,"user_name":"TING","can_delete":false,"product_type":"c1","uid":1178451,"ip_address":"","ucode":"75F2BF2EE1DF7B","user_header":"https://static001.geekbang.org/account/avatar/00/11/fb/53/ceaa0bf0.jpg","comment_is_top":false,"comment_ctime":1598083167,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598083167","product_id":100039001,"comment_content":"子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。行为约定包括：函数声明要实现的功能；对输入、输出、异常的约定","like_count":0},{"had_liked":false,"id":243051,"user_name":"Henry","can_delete":false,"product_type":"c1","uid":1929375,"ip_address":"","ucode":"7C554C97935443","user_header":"https://static001.geekbang.org/account/avatar/00/1d/70/9f/741cd6a4.jpg","comment_is_top":false,"comment_ctime":1597932147,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597932147","product_id":100039001,"comment_content":"感觉实际开发中用多态的情况比较多，很难保证以后会不需要改变父类的行为。","like_count":0},{"had_liked":false,"id":242890,"user_name":"嘉嘉☕","can_delete":false,"product_type":"c1","uid":1059771,"ip_address":"","ucode":"632A5CC4B53BB1","user_header":"https://static001.geekbang.org/account/avatar/00/10/2b/bb/5cf70df8.jpg","comment_is_top":false,"comment_ctime":1597886134,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597886134","product_id":100039001,"comment_content":"里氏替换原则, 就是对继承行为做了控制, 告诉子类标准; 并且与开闭类似, 不要破坏原有代码的正常运行, 不要破坏原有的单元测试","like_count":0},{"had_liked":false,"id":242815,"user_name":"超越自我","can_delete":false,"product_type":"c1","uid":2130462,"ip_address":"","ucode":"8A55D972EEFADA","user_header":"https://static001.geekbang.org/account/avatar/00/20/82/1e/f3cb3d57.jpg","comment_is_top":false,"comment_ctime":1597848218,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597848218","product_id":100039001,"comment_content":"老祖宗定下来的规矩，后代不要打破它，要传承。","like_count":0},{"had_liked":false,"id":242548,"user_name":"Canon.Din","can_delete":false,"product_type":"c1","uid":1158109,"ip_address":"","ucode":"2C5448AAF7CF46","user_header":"https://static001.geekbang.org/account/avatar/00/11/ab/dd/31942fb9.jpg","comment_is_top":false,"comment_ctime":1597756722,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597756722","product_id":100039001,"comment_content":"里式替换几个使用场景<br>1.代码重构，提取逻辑，代码迁移或者改调用方时，切记不可手贱优化<br>2. SQL拆分时，代码实现SQL逻辑就要一个条件一个条件对应，遗漏条件就不满足里式替换了","like_count":0},{"had_liked":false,"id":240624,"user_name":"David","can_delete":false,"product_type":"c1","uid":1021825,"ip_address":"","ucode":"22CBBC13FC97A9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/97/81/e1eaf621.jpg","comment_is_top":false,"comment_ctime":1597021073,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1597021073","product_id":100039001,"comment_content":"lsp：按照协议设计。子类只能增强，不能破坏协议。<br>意义：遵循协议编程 沟通成本低。","like_count":0},{"had_liked":false,"id":240143,"user_name":"Jason.w","can_delete":false,"product_type":"c1","uid":1366413,"ip_address":"","ucode":"EE39ADEB7C6BC8","user_header":"https://static001.geekbang.org/account/avatar/00/14/d9/8d/a6984f12.jpg","comment_is_top":false,"comment_ctime":1596770526,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596770526","product_id":100039001,"comment_content":"继承要做到增强而不破坏.","like_count":0},{"had_liked":false,"id":239832,"user_name":"Geek_31594d","can_delete":false,"product_type":"c1","uid":2030240,"ip_address":"","ucode":"9058787881CE82","user_header":"","comment_is_top":false,"comment_ctime":1596674664,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596674664","product_id":100039001,"comment_content":"遵循协议 继承传统 增强","like_count":0},{"had_liked":false,"id":238918,"user_name":"克一","can_delete":false,"product_type":"c1","uid":1612666,"ip_address":"","ucode":"1C9F8229B5739A","user_header":"https://static001.geekbang.org/account/avatar/00/18/9b/7a/78dde0a2.jpg","comment_is_top":false,"comment_ctime":1596369553,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596369553","product_id":100039001,"comment_content":"里氏替换选择，好比父子关系，子的籍贯，姓这些原则的协议不能改，其他的可以跟老子不一样，比如生几个孩子，娶几个老婆。","like_count":0},{"had_liked":false,"id":238485,"user_name":"汉江","can_delete":false,"product_type":"c1","uid":1788647,"ip_address":"","ucode":"01622D984B8F9B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/4a/e7/6c16af5d.jpg","comment_is_top":false,"comment_ctime":1596182022,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596182022","product_id":100039001,"comment_content":"里式替换原则我觉得意义有两点：1 减少代码出错的概率  2.减少沟通成本","like_count":0},{"had_liked":false,"id":237798,"user_name":"写代码的","can_delete":false,"product_type":"c1","uid":2085090,"ip_address":"","ucode":"F58186409A3D65","user_header":"https://static001.geekbang.org/account/avatar/00/1f/d0/e2/1d00c079.jpg","comment_is_top":false,"comment_ctime":1595960626,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595960626","product_id":100039001,"comment_content":"里氏替换原则存在的意义就是提升代码的可维护性和灵活性。里氏替换原则一般要和静态工厂方法结合，这样替换成子类的工作只需要在这个静态工厂方法里做，而不需要在整个项目中去修改代码。","like_count":0},{"had_liked":false,"id":233200,"user_name":"Geek_71cea9","can_delete":false,"product_type":"c1","uid":2058308,"ip_address":"","ucode":"DE88271BA527DD","user_header":"","comment_is_top":false,"comment_ctime":1594259160,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594259160","product_id":100039001,"comment_content":"多态更多是子类继承父类的一种能力和实现方式，来达到扩展性 ，而里斯替换是一种设计原则 和规范 需要在日常写代码中去遵守 ","like_count":0},{"had_liked":false,"id":231365,"user_name":"谭棋钊","can_delete":false,"product_type":"c1","uid":1237976,"ip_address":"","ucode":"F7F982BE5978BA","user_header":"https://static001.geekbang.org/account/avatar/00/12/e3/d8/bc70f34a.jpg","comment_is_top":false,"comment_ctime":1593657822,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593657822","product_id":100039001,"comment_content":"我的理解:在面对需求时，我们会想到可以用多态来实现，而在实现的过程中，需要用到里式替换原则的思想","like_count":0},{"had_liked":false,"id":231013,"user_name":"zlig","can_delete":false,"product_type":"c1","uid":1475134,"ip_address":"","ucode":"DD5850FA4235E5","user_header":"https://static001.geekbang.org/account/avatar/00/16/82/3e/1fc6e36a.jpg","comment_is_top":false,"comment_ctime":1593565733,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593565733","product_id":100039001,"comment_content":"多态是一种很强的扩展能力，需要控制使用，比如子类通过多态能把父类的加法扩展成减法。里氏替换原则就是对多态的超能力的一种约束，在上面的例子中，子类的扩展也只能是加法，具体怎么加不管。","like_count":0},{"had_liked":false,"id":230817,"user_name":"西门吹牛","can_delete":false,"product_type":"c1","uid":1508990,"ip_address":"","ucode":"E5D3624DDE1E83","user_header":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","comment_is_top":false,"comment_ctime":1593502562,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593502562","product_id":100039001,"comment_content":"里斯替换的实现基础是多态和继承，在继承的基础上进行了加强。用多态语法实现的代码，不一定满足里氏替换原则，里斯替换对子类有更高的要求。但是满足里斯替换原则的代码，一定是建立在多态和继承的基础上。","like_count":0},{"had_liked":false,"id":229548,"user_name":"被过去推开","can_delete":false,"product_type":"c1","uid":1276690,"ip_address":"","ucode":"8B4F34FE93FD5B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Cib5umA0W17N9pichI08pnrXAExdbyh7AVzH4nEhD6KN3FXuELk4LJJuqUPPD7xmIy9nq5Hjbgnzic7sVZG5BKiaUQ/132","comment_is_top":false,"comment_ctime":1593054795,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593054795","product_id":100039001,"comment_content":"里氏替换原则最基本的逻辑行为是不破坏原有逻辑的行为。假如我要根据不同的接收方发送不同的消息协议，那么可以依照里氏替换原则，增加或删减消息。","like_count":0},{"had_liked":false,"id":229277,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1592957210,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592957210","product_id":100039001,"comment_content":"里氏替换原则就是，子类重写父类方法时，只能增强原有方法的功能，不能修改本身的逻辑","like_count":0},{"had_liked":false,"id":229218,"user_name":"maybe","can_delete":false,"product_type":"c1","uid":1475528,"ip_address":"","ucode":"93D160F617E750","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/c8/5ce842f6.jpg","comment_is_top":false,"comment_ctime":1592925559,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1592925559","product_id":100039001,"comment_content":"死扣定义，不属于单一职责原则、接口隔离原则。但是实际上我们认为它是符合单于职责原则、接口隔离原则的，这个函数很简单，只是对一个数的递增后返回递增前的值。是个完整且功能单一的数字操作，符合单于职责原则。对于调用者来说，他希望递增一个数字、递增一个数字并返回之前的值的需求，然后调用这个函数。这个函数并未有其它过多的操作，记录递增前的值也不需要任何其它消耗的操作才能获得，符合接口隔离原则","like_count":0},{"had_liked":false,"id":229151,"user_name":"maybe","can_delete":false,"product_type":"c1","uid":1475528,"ip_address":"","ucode":"93D160F617E750","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/c8/5ce842f6.jpg","comment_is_top":false,"comment_ctime":1592909172,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1592909172","product_id":100039001,"comment_content":"里氏替换原则指导类继承设计，在扩展的同时不修改原有行为逻辑，实现热替换","like_count":0},{"had_liked":false,"id":228898,"user_name":"命运的脚步","can_delete":false,"product_type":"c1","uid":1699087,"ip_address":"","ucode":"5A859A91B0C03A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKxaChY8P85zfcQ0hvQCZbQmbXIvyP5VoOz9QqcMrlQ21y6eNSNl1npicEGkzq9ldw9lbTUC9RY6Tw/132","comment_is_top":false,"comment_ctime":1592835702,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592835702","product_id":100039001,"comment_content":"父类做了边界的设定，子类增强了父类的功能，但不要越过边界。","like_count":0},{"had_liked":false,"id":226592,"user_name":"maybe","can_delete":false,"product_type":"c1","uid":1475528,"ip_address":"","ucode":"93D160F617E750","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/c8/5ce842f6.jpg","comment_is_top":false,"comment_ctime":1592147074,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1592147074","product_id":100039001,"comment_content":"里氏替换原则的意义：指导子类设计，应该遵循父类的协议。如果一个子类已经不按照父类的协议，这个子类就是有问题或者已经不该继承这个父类了。一个子类违反里氏替换原则，那么使用的时候会产生让人误解的因素，导致类的误用或用错导致代码错误","like_count":0},{"had_liked":false,"id":225642,"user_name":"N。","can_delete":false,"product_type":"c1","uid":1647830,"ip_address":"","ucode":"8EE55D4A24004A","user_header":"https://static001.geekbang.org/account/avatar/00/19/24/d6/c65a71b3.jpg","comment_is_top":false,"comment_ctime":1591803829,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591803829","product_id":100039001,"comment_content":"里氏替换原则指导设计子类的时对父类的增强，而非改变父类原本逻辑","like_count":0},{"had_liked":false,"id":223807,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1591184670,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591184670","product_id":100039001,"comment_content":"里式替换是指导多态的设计原则，按照契约来扩展父类，契约包含函数“名称”和“注释”要实现的功能、函数的签名(入参和返回值)约定、异常处理约定。<br>golang对的函数返回值是集合时不要用指针！！空对象、空集合、null有编译检查可以强制一致。<br>在编写扩展实现时，违反里式替换不会有编译错误。","like_count":0},{"had_liked":false,"id":223767,"user_name":"微末凡尘","can_delete":false,"product_type":"c1","uid":1099525,"ip_address":"","ucode":"25EDFD0914D0F4","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/05/19c5c255.jpg","comment_is_top":false,"comment_ctime":1591176627,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591176627","product_id":100039001,"comment_content":"子类可以完全的替换父类实现相同的功能","like_count":0},{"had_liked":false,"id":223765,"user_name":"微末凡尘","can_delete":false,"product_type":"c1","uid":1099525,"ip_address":"","ucode":"25EDFD0914D0F4","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/05/19c5c255.jpg","comment_is_top":false,"comment_ctime":1591176422,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591176422","product_id":100039001,"comment_content":"里氏替换原则就是子类完美的继承了父类的功能，而且做了增强，更加的完善和高效","like_count":0},{"had_liked":false,"id":220346,"user_name":"Random.nextName()","can_delete":false,"product_type":"c1","uid":1244960,"ip_address":"","ucode":"8D18D91B8D3BC7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ0lHhbutibIdWRv0pm2EPtvxqcVz0PblEic7GDxHK8JUSkyuWQl1B1NVQTzEowQIxfOf3saRBOTtog/132","comment_is_top":false,"comment_ctime":1590225342,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590225342","product_id":100039001,"comment_content":"利用多态的特性进行代码组织和扩展，基于里式替换原则进行子类的设计。","like_count":0},{"had_liked":false,"id":218296,"user_name":"师哥","can_delete":false,"product_type":"c1","uid":1333376,"ip_address":"","ucode":"A86CD1661D370F","user_header":"https://static001.geekbang.org/account/avatar/00/14/58/80/c9e232b6.jpg","comment_is_top":false,"comment_ctime":1589772855,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589772855","product_id":100039001,"comment_content":"  里式替换 就是说子类可以替换父类，并且程序的逻辑性和正确性 都不受影响。它的主要原则就是按照协议来设计。","like_count":0},{"had_liked":false,"id":217014,"user_name":"Next","can_delete":false,"product_type":"c1","uid":1748213,"ip_address":"","ucode":"D5ADDF248A9504","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ac/f5/2f97e279.jpg","comment_is_top":false,"comment_ctime":1589385365,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589385365","product_id":100039001,"comment_content":"里式替换的意义：<br>避免程序出现意外的错误，保证扩展的可靠性；保证逻辑清晰可信，提高可读性、可维护性。","like_count":0},{"had_liked":false,"id":216604,"user_name":"zhou","can_delete":false,"product_type":"c1","uid":1087243,"ip_address":"","ucode":"E1CE8575B3F106","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/0b/a943bcb3.jpg","comment_is_top":false,"comment_ctime":1589294333,"is_pvip":false,"discussion_count":0,"race_medal":3,"score":"1589294333","product_id":100039001,"comment_content":"里式替换原则，就好比一辆车，低配车是父亲，高配车是儿子。","like_count":0},{"had_liked":false,"id":214890,"user_name":"Tobias","can_delete":false,"product_type":"c1","uid":1803858,"ip_address":"","ucode":"F3225639EDA193","user_header":"https://static001.geekbang.org/account/avatar/00/1b/86/52/b92dc111.jpg","comment_is_top":false,"comment_ctime":1588842624,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588842624","product_id":100039001,"comment_content":"个人理解里氏替换 可以通过 集合的包含关系来描述: 子类的功能逻辑是一个集合，父类的功能逻辑一个集合，子类集合必须包含父类集合。","like_count":0},{"had_liked":false,"id":214819,"user_name":"刘同青","can_delete":false,"product_type":"c1","uid":1818343,"ip_address":"","ucode":"84B62DF8BC61FB","user_header":"","comment_is_top":false,"comment_ctime":1588824171,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588824171","product_id":100039001,"comment_content":"子类可以重写父类方法，但是要支持父类对该方法所有的定义。作用:  当使用多态时，代码中除了实例化时会new子类对象，其他代码使用的均是父类中的方法，编码也是根据父类中的方法的定义和注释进行，甚至这时候还没有子类的实现，所以如果子类不遵从父类约定随意重写，就可能完成使用父类方法的代码出现问题，<br>父类方法定义可能抛出的异常是ParamException<br>所以代码中捕获异常<br>但是有个子类重写后非要抛出ValidateException，<br>这就造成获取异常的代码失效，<br><br>总结就是:  凡事都要有个公共标准，要不然会越来越乱<br>","like_count":0},{"had_liked":false,"id":213797,"user_name":"编程界的小学生","can_delete":false,"product_type":"c1","uid":1593289,"ip_address":"","ucode":"4A5BE9A5E877FA","user_header":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","comment_is_top":false,"comment_ctime":1588563696,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588563696","product_id":100039001,"comment_content":"为啥我觉得策略模式肯定违反了这个原则，因为策略模式针对的不同算法，它的结果正确性肯定会遭到破坏，希望老师解答下，有点困惑。","like_count":0},{"had_liked":false,"id":211896,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1588036679,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588036679","product_id":100039001,"comment_content":"面向对象继承关系中，子类和父类的关系是is-a，即任何使用父类的地方都可以用子类来代替。这不仅是语法上的，也是语义上的。里氏替换原则就是用来保证这一点的","like_count":0},{"had_liked":false,"id":210486,"user_name":"指尖流逝","can_delete":false,"product_type":"c1","uid":1005381,"ip_address":"","ucode":"417009F674FAF1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/45/c418ea5c.jpg","comment_is_top":false,"comment_ctime":1587776232,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587776232","product_id":100039001,"comment_content":"里式替换原则：多态特性的一种现实应用，可以将代码中”某块变化的功能“和不变的功能进行隔离，在有需要的时候灵活替换”变化“，既然是替换，那么就需要遵守规则或约定：输入、输出、异常三者都需要符合既定约束","like_count":0},{"had_liked":false,"id":208875,"user_name":"郭强","can_delete":false,"product_type":"c1","uid":1192928,"ip_address":"","ucode":"38F36F0F4CC775","user_header":"https://static001.geekbang.org/account/avatar/00/12/33/e0/387ab6fd.jpg","comment_is_top":false,"comment_ctime":1587455912,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587455912","product_id":100039001,"comment_content":"里氏替换原则解决了什么问题，不遵守会造成什么影响？我对这个原则的意思懂了，但理解的不深刻。最好能有实际项目中里氏替换原则带好实际好处的例子！","like_count":0},{"had_liked":false,"id":207034,"user_name":"minsky","can_delete":false,"product_type":"c1","uid":1351075,"ip_address":"","ucode":"7296ECA064E89B","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/a3/79fc9017.jpg","comment_is_top":false,"comment_ctime":1586998638,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586998638","product_id":100039001,"comment_content":"个人理解里氏替换原则是在前提上保证多态特性在使用时不出错的，或则说是让多态特性更完善和精准。可以想象如果子类设计时不遵循里氏替换原则，那么代码使用多态时经常会出现一些意想不到的错误，尤其是父类或者接口有多个子类的时候。","like_count":0},{"had_liked":false,"id":204077,"user_name":"zhanyd","can_delete":false,"product_type":"c1","uid":1073845,"ip_address":"","ucode":"4C994EE512A3C4","user_header":"https://static001.geekbang.org/account/avatar/00/10/62/b5/4159fa05.jpg","comment_is_top":false,"comment_ctime":1586330164,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586330164","product_id":100039001,"comment_content":"里氏替换原则就是父类给子类设定的边界，子类可以在边界内自由发挥，但是不能越过边界，超出父类的控制。","like_count":0},{"had_liked":false,"id":202633,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1586020300,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1586020300","product_id":100039001,"comment_content":"里式替换原则可以形象的理解为：做一个乖孩子。","like_count":0},{"had_liked":false,"id":201966,"user_name":"改名不换人","can_delete":false,"product_type":"c1","uid":1118242,"ip_address":"","ucode":"7E25577829FA0F","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/22/910f705c.jpg","comment_is_top":false,"comment_ctime":1585882928,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585882928","product_id":100039001,"comment_content":"里式替换原则的意义我认为就是在我们通过多态(继承)来扩展程序的功能时，不能因为扩展了新的功能而影响了原有代码的逻辑，也就是要遵守父类方法的协议，使得子类可以安全的替换所有父类出现的地方。这个原则的关键是：保证原来程序的逻辑行为不变和正确性不被破坏。","like_count":0},{"had_liked":false,"id":201707,"user_name":"Ray","can_delete":false,"product_type":"c1","uid":1604089,"ip_address":"","ucode":"3A66800D8E35D6","user_header":"https://static001.geekbang.org/account/avatar/00/18/79/f9/3cd59b29.jpg","comment_is_top":false,"comment_ctime":1585821935,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585821935","product_id":100039001,"comment_content":"个人观点：<br>最后讲到的里式替换原则与多态是区别很重要，更好的区分了这二者的概念<br>里式替换是设计原则，而多态是代码的实现方式，从本质上来讲是不一样的","like_count":0},{"had_liked":false,"id":201226,"user_name":"这得从我捡到一个鼠标垫开始说起","can_delete":false,"product_type":"c1","uid":1272321,"ip_address":"","ucode":"2FF4347B4E7A9B","user_header":"https://static001.geekbang.org/account/avatar/00/13/6a/01/d9cb531d.jpg","comment_is_top":false,"comment_ctime":1585735510,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585735510","product_id":100039001,"comment_content":"里氏替换原则避免替换了实现了之后，出现不正确的行为。","like_count":0},{"had_liked":false,"id":200845,"user_name":"Nick","can_delete":false,"product_type":"c1","uid":1921287,"ip_address":"","ucode":"64BBE005890845","user_header":"https://static001.geekbang.org/account/avatar/00/1d/51/07/b5a945b6.jpg","comment_is_top":false,"comment_ctime":1585660186,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585660186","product_id":100039001,"comment_content":"我是这么理解的，LSP原则其实也是符合面向接口编程而不是面向实现编程这一原则的，接口或者是父类定义好的方法，子类则不能违背其约定或者说是原则。","like_count":0},{"had_liked":false,"id":200303,"user_name":"面向百度编程","can_delete":false,"product_type":"c1","uid":1732780,"ip_address":"","ucode":"8FE04A019D71D1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","comment_is_top":false,"comment_ctime":1585570519,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585570519","product_id":100039001,"comment_content":"如果说按照 design by contract  的话，那么我觉得继承了父类既然不做修改，遵从约定，那么子类就是把原有的功能都继承下来，从而自己在增强原有功能，达到替换效果，感觉有点装饰者模式，代理模式味道，我指的味道是思想上的哈，都是增强功能","like_count":0},{"had_liked":false,"id":200215,"user_name":"墨鱼","can_delete":false,"product_type":"c1","uid":1022720,"ip_address":"","ucode":"8FB5E4DCB8A024","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/00/654be3f7.jpg","comment_is_top":false,"comment_ctime":1585559190,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585559190","product_id":100039001,"comment_content":"里式替换原则是：按照协议设计，子类如果要修改父类的代码，核心逻辑不能变，实现可以修改，包括注释里写的设计原则。","like_count":0},{"had_liked":false,"id":197934,"user_name":"桂冠远航","can_delete":false,"product_type":"c1","uid":1155463,"ip_address":"","ucode":"5959E1A1DAA05D","user_header":"https://static001.geekbang.org/account/avatar/00/11/a1/87/259ab5a3.jpg","comment_is_top":false,"comment_ctime":1585404096,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585404096","product_id":100039001,"comment_content":"感觉LSP和Java中子类覆写父类方法要求是一样的。","like_count":0},{"had_liked":false,"id":197217,"user_name":"韶年","can_delete":false,"product_type":"c1","uid":1269934,"ip_address":"","ucode":"EA4149F98FF39B","user_header":"https://static001.geekbang.org/account/avatar/00/13/60/ae/88d88232.jpg","comment_is_top":false,"comment_ctime":1585363603,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585363603","product_id":100039001,"comment_content":"里式替换的使用场景是什么？不符合里式替换的继承有什么坏处？","like_count":0},{"had_liked":false,"id":197199,"user_name":"韶年","can_delete":false,"product_type":"c1","uid":1269934,"ip_address":"","ucode":"EA4149F98FF39B","user_header":"https://static001.geekbang.org/account/avatar/00/13/60/ae/88d88232.jpg","comment_is_top":false,"comment_ctime":1585362975,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585362975","product_id":100039001,"comment_content":"子类调用super.sendRequest(request)，那子类存在的意义是什么呢？仅仅是设置密码吗？这样子是不是过度设计了。","like_count":0},{"had_liked":false,"id":197195,"user_name":"韶年","can_delete":false,"product_type":"c1","uid":1269934,"ip_address":"","ucode":"EA4149F98FF39B","user_header":"https://static001.geekbang.org/account/avatar/00/13/60/ae/88d88232.jpg","comment_is_top":false,"comment_ctime":1585362786,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585362786","product_id":100039001,"comment_content":"感觉比开闭原则难理解多了，看了两边硬是没看明白。","like_count":0},{"had_liked":false,"id":197147,"user_name":"Kevin.zhang🌏","can_delete":false,"product_type":"c1","uid":1247039,"ip_address":"","ucode":"5C52AE51538906","user_header":"https://static001.geekbang.org/account/avatar/00/13/07/3f/53ae01f6.jpg","comment_is_top":false,"comment_ctime":1585360270,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585360270","product_id":100039001,"comment_content":"不支持OOB的C语言其实也支持李式替换原则，函数指针真神器！可以实现接口、多态、模板方法等OO特性。","like_count":0},{"had_liked":false,"id":195854,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1585219460,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585219460","product_id":100039001,"comment_content":"有点类似于继承并增强了父类功能，就像模版模式那样。又有点像策略模式。总之，接口保持和父类一致。","like_count":0},{"had_liked":false,"id":194329,"user_name":"然","can_delete":false,"product_type":"c1","uid":1347648,"ip_address":"","ucode":"43B7D3896D706B","user_header":"https://static001.geekbang.org/account/avatar/00/14/90/40/dfa19744.jpg","comment_is_top":false,"comment_ctime":1585051101,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585051101","product_id":100039001,"comment_content":"里氏置换原则是用来指导子类继承父类如何设计的原则，子类需要遵守函数原有的约定：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明","like_count":0},{"had_liked":false,"id":194262,"user_name":"jaryoung","can_delete":false,"product_type":"c1","uid":1077406,"ip_address":"","ucode":"6E72D107DB7E51","user_header":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","comment_is_top":false,"comment_ctime":1585043284,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585043284","product_id":100039001,"comment_content":"今天学习里氏替换原则，收获如下：<br>规约要遵守，例如你继承别人的超人的能力，你要去干坏事（大家都知道超人是好人）<br>约定包括：：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。","like_count":0},{"had_liked":false,"id":193889,"user_name":"陈包佳","can_delete":false,"product_type":"c1","uid":1576712,"ip_address":"","ucode":"9DAAC87C75D91F","user_header":"https://static001.geekbang.org/account/avatar/00/18/0f/08/7abf466e.jpg","comment_is_top":false,"comment_ctime":1584977681,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584977681","product_id":100039001,"comment_content":"里氏原则指导了子类的设计原则，要求子类替换父类后不能破坏父类的功能和逻辑。与多态的区别，多态是面向对象的特性，是程序实现的方法，而里氏原则是指导子类继承父类时的设计原则，要求子类能按照父类定义的功能编写方法，不能改变父类程序的功能，以及输入输出和异常。","like_count":0},{"had_liked":false,"id":192408,"user_name":"秋风画扇","can_delete":false,"product_type":"c1","uid":1132356,"ip_address":"","ucode":"5BCBC1422C51EC","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/44/964aa665.jpg","comment_is_top":false,"comment_ctime":1584849143,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584849143","product_id":100039001,"comment_content":"同面向接口编程一个道理，使用时不需要关注内部实现。里式替换也一样，不能改变规定好的协议，保证接口、方法统一。","like_count":0},{"had_liked":false,"id":189983,"user_name":"Eden Ma","can_delete":false,"product_type":"c1","uid":1457408,"ip_address":"","ucode":"755312F0D154F9","user_header":"https://static001.geekbang.org/account/avatar/00/16/3d/00/7daa7403.jpg","comment_is_top":false,"comment_ctime":1584588755,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584588755","product_id":100039001,"comment_content":"存在意义:方法实现功能上的同一性、一致性,这样不会导致子类实现的方法出现意料之外的情况.","like_count":0},{"had_liked":false,"id":187685,"user_name":"林峰峰","can_delete":false,"product_type":"c1","uid":1457609,"ip_address":"","ucode":"83C2093135BBB8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/3B5MoC4DfBt00nnVshEBFHHkNVgbcBrXsd3SxFicdN3XX5ILOe7GJxKvtJKCY53xNCuxSV8ABxNulbhkibm1lXIw/132","comment_is_top":false,"comment_ctime":1584192714,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584192714","product_id":100039001,"comment_content":"design by contract，按照协议来设计 ,通过父类定义协议，其他子类遵守。这个可以规定子类的行为。 大家统一按照一个设计进行，方便外部调用。","like_count":0},{"had_liked":false,"id":187402,"user_name":"未来小娃","can_delete":false,"product_type":"c1","uid":1047329,"ip_address":"","ucode":"477D166EBB6B70","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/21/d017438c.jpg","comment_is_top":false,"comment_ctime":1584102361,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584102361","product_id":100039001,"comment_content":"【设计模式笔记18】20200313<br>之前理解的里氏替换是子类可以替换父类，里氏替换是是指在不改变父类功能的情况下子类替换父类。但是这个原则能解决什么问题呢，保持程序的扩展性，假如子类替换父类后功能变了就违反了父类的功能特性，逻辑就被改变了，这说明程度不够健壮。那假如一定要改变父类的功能怎么办呢：1）使用接口；2）使用抽象方法，这样任何子类都可以实现自己的逻辑，父类只是一个函数，没有功能的约定。下面说下多态和里氏替换原则的关系，里氏替换是一种指导怎么设计父类和子类的原则，多态是一种语法，没有功能约束，一个是语法一个是原则。","like_count":0},{"had_liked":false,"id":187233,"user_name":"88591","can_delete":false,"product_type":"c1","uid":1254656,"ip_address":"","ucode":"04CE3E46455185","user_header":"https://static001.geekbang.org/account/avatar/00/13/25/00/3afbab43.jpg","comment_is_top":false,"comment_ctime":1584066145,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584066145","product_id":100039001,"comment_content":"代码是人来写，所以需要效率和质量。任何有利于效率和质量的设计就是好的，反之则需要权衡利弊，改进设计。大多数情况下面经典的设计原则都是高效率和高质量的设计，但是也需要依据实际情况进行取舍。","like_count":0},{"had_liked":false,"id":184770,"user_name":"von","can_delete":false,"product_type":"c1","uid":1736813,"ip_address":"","ucode":"403C8CF955AFF3","user_header":"","comment_is_top":false,"comment_ctime":1583398361,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583398361","product_id":100039001,"comment_content":"多态，更多的是指从java语法层面，父类引用可以指向子类的一个实例，运行时执行子类的方法；<br>LSP，侧重的是约定父类中被子类重写的方法行为，即重写的方法不能在逻辑上与父类原方法有出入。<br>所以，两者说的是不同的事情。","like_count":0},{"had_liked":false,"id":182965,"user_name":"糖","can_delete":false,"product_type":"c1","uid":1542834,"ip_address":"","ucode":"784DDA19104392","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJzP9yB6eIRRyVNe3iab0gXB6yOeaNRHGx6raTQz2grfE5N2LWl6uIj1mrSU7nxiaEzeSLp6xAkE3iaQ/132","comment_is_top":false,"comment_ctime":1582899704,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1582899704","product_id":100039001,"comment_content":"有一点疑问：子类在重载父类的函数之后，如果子类和父类的重载函数对于外在表现完全一致，那么除了实现方法的不同之外，怎么体现子类相对于父类的扩展呢？比如像文中提到的vip用户withdraw（）函数还和普通用户存在一样的行为，那vip用户相对于其他用户是不是就没有区别了呢？","like_count":0,"discussions":[{"author":{"id":1318719,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1f/3f/659bb0d8.jpg","nickname":"苍玄晶魄","note":"","ucode":"2EF6583344E446","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":203091,"discussion_content":"我理解外在表现一致是指约定一致\n类似于接口和实现类的关系\n例如飞机-飞,我们可以实现直升机的螺旋翼飞,也可以喷气式飞\n但父类直接就定义了方法,命名和注释都表明了是喷气式飞行,再在子类实现直升机就不合适了\n归根结底,对于继承需要更抽象的看待问题,继承可以实现多态,但不是无约束的实现多态","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583995066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180869,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1582432445,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582432445","product_id":100039001,"comment_content":"大前提就是，易用、易读、易维护、易扩展；LSP，就主要是为了易读，易维护、易扩展好像也包含在里面；心法完全靠领会啊","like_count":0},{"had_liked":false,"id":180574,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1582339963,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582339963","product_id":100039001,"comment_content":"我个人认为里氏替换原则的存在意义,<br>1.方便维护我们的开闭原则 即对修改关闭对扩展开放，避免因为不必要因为新的扩展而打破父类所约定的协议，二是，在重构的时候，在原有服务类的基础上新增子类，在子类当中做到更高效地实现原有的父类的需求，从而替换父类","like_count":0},{"had_liked":false,"id":177797,"user_name":"嘿泥鳅","can_delete":false,"product_type":"c1","uid":1285186,"ip_address":"","ucode":"A22BDA7A6DA23E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/F5Srwp8IibOU9PDCDgmpdIZF9UXQZzfPKzNseHW5GR0WmusGfrkmzQ6wq32omW3uTtl8aXjkudYSA0NEmibxAcnw/132","comment_is_top":false,"comment_ctime":1581502180,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581502180","product_id":100039001,"comment_content":"我认为回答任何原则的意义都要落地到专栏开头讲到的，如何写出高质量的代码和其评判标准上来。里式替换原则主要指导继承关系如何设计，那么为什么要设计继承关系?是为了让子类能替换父类,那又为什么要替换父类？答案是多态，多态主要解决的是扩展性和复用性，也是很多设计原则、设计模式的实现基础。综上，里式替换原则存在的意义主要解决的是编程中复用性、扩展性的问题。","like_count":0},{"had_liked":false,"id":177355,"user_name":"巨龙的力量啊","can_delete":false,"product_type":"c1","uid":1684858,"ip_address":"","ucode":"8FC6978929E48F","user_header":"https://static001.geekbang.org/account/avatar/00/19/b5/7a/a126c48f.jpg","comment_is_top":false,"comment_ctime":1581352972,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581352972","product_id":100039001,"comment_content":"多态是能这么做，里氏替换是应该这么做","like_count":0},{"had_liked":false,"id":175833,"user_name":"wai","can_delete":false,"product_type":"c1","uid":1439529,"ip_address":"","ucode":"29CE3BE148FB79","user_header":"https://static001.geekbang.org/account/avatar/00/15/f7/29/60e01017.jpg","comment_is_top":false,"comment_ctime":1580865933,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580865933","product_id":100039001,"comment_content":"我认为里式替换原则存在的主要意义：一个项目都是团队开发，针对父类会有多个子类，不同的人设计不同的子类的时候要有一个统一的设计标准，确保程序运行时尽量减少未知异常的出现。","like_count":0},{"had_liked":false,"id":175654,"user_name":"刘明丰","can_delete":false,"product_type":"c1","uid":1591790,"ip_address":"","ucode":"64C1D6CC769F75","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eocPWoTKicQG9ic42hLQBOqEziaNYxBekyGXljWrYfhk8gjLGZWfUX0JlObCvOIUSA8tRXicfxeSDJMMw/132","comment_is_top":false,"comment_ctime":1580790707,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580790707","product_id":100039001,"comment_content":"里式替换原则存在的意义还是很大的，首先能把这条原则说清楚，一定是一位经验丰富的编码人员，在不断的总结和的出来的宝贵经验。它能解决问题的是在我们使用多态特性的同时基本能保证整体的系统能正常工作，不出现不可预期的情况。","like_count":0},{"had_liked":false,"id":175204,"user_name":"密码123456","can_delete":false,"product_type":"c1","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1580615191,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580615191","product_id":100039001,"comment_content":"我觉得，这里用的最好的就是spring。比如提供的缓存抽象。只要实现对应的接口，就可以轻易的替换使用缓存的规则。","like_count":0},{"had_liked":false,"id":174655,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1580309879,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1580309879","product_id":100039001,"comment_content":"利用LSP原则可以实现OCP，如果违反了LSP，那么程序也会违反OCP","like_count":0},{"had_liked":false,"id":174588,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1580287266,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1580287266","product_id":100039001,"comment_content":"我只关心结果是不是我想要的，你怎么做到我不管","like_count":0},{"had_liked":false,"id":174430,"user_name":"老余","can_delete":false,"product_type":"c1","uid":1295848,"ip_address":"","ucode":"17AC6C60D0EB86","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/yicibWmBIDaSpBYI5wCBDQcYu6mxjvz3XZzBibxSNXFfqCS6OJOjvy2Nc2lyDicZfmneW9ZY4KbicA1sNgLktVSicgkw/132","comment_is_top":false,"comment_ctime":1580206303,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580206303","product_id":100039001,"comment_content":"里式替换原则可以约束父子类行为的关系。任何使用父类的地方可以使用子类替换，并且没有异常行为。理解里式替换原则，最核心的就是理解“design by contract，按照协议来设计”这几个字。父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数原有的“约定”。这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。","like_count":0},{"had_liked":false,"id":174337,"user_name":"磊","can_delete":false,"product_type":"c1","uid":1070732,"ip_address":"","ucode":"858BF8BFBFB0B8","user_header":"https://static001.geekbang.org/account/avatar/00/10/56/8c/a8317e23.jpg","comment_is_top":false,"comment_ctime":1580165872,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1580165872","product_id":100039001,"comment_content":"里式替换原则存在的意义：使父类的行为和属性在被继承的过程中不被修改，以保证程序的稳定性","like_count":0},{"had_liked":false,"id":173890,"user_name":"SXPeople","can_delete":false,"product_type":"c1","uid":1313127,"ip_address":"","ucode":"C6D9E2AE5278A9","user_header":"https://static001.geekbang.org/account/avatar/00/14/09/67/b46d3045.jpg","comment_is_top":false,"comment_ctime":1579759773,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579759773","product_id":100039001,"comment_content":"历史替换原则：忠于原创，高于原创","like_count":0},{"had_liked":false,"id":173311,"user_name":"桂城老托尼","can_delete":false,"product_type":"c1","uid":1306032,"ip_address":"","ucode":"139E4B8EE88B79","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJcxSpNMqwqyicMvdOSr9ic0p1ABiauHnv7g7YQVSJuoHPoQbYDu3YzdpgmSAk2KricUBQ5yibWBWIq75w/132","comment_is_top":false,"comment_ctime":1579501376,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579501376","product_id":100039001,"comment_content":"学习到了，之前没太注意和多态的区别","like_count":0},{"had_liked":false,"id":172185,"user_name":"gwen","can_delete":false,"product_type":"c1","uid":1114452,"ip_address":"","ucode":"82A01FD8458671","user_header":"https://static001.geekbang.org/account/avatar/00/11/01/54/46266631.jpg","comment_is_top":false,"comment_ctime":1579103174,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579103174","product_id":100039001,"comment_content":"里式替换就是父类定义了函数的“约定”（或者叫协议），那子类必须按照约定来实现，可以改变函数的内部实现逻辑，但不能改变函数原有的“约定”。这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。检验方法是使用父类的地方，使用子类来替换，测试用例是PASS的！","like_count":0},{"had_liked":false,"id":171964,"user_name":"www","can_delete":false,"product_type":"c1","uid":1275203,"ip_address":"","ucode":"951B364F2CB211","user_header":"https://static001.geekbang.org/account/avatar/00/13/75/43/c6058200.jpg","comment_is_top":false,"comment_ctime":1579058524,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579058524","product_id":100039001,"comment_content":"里氏替换原则存在的意义：<br>父类的静态方法其实就是一种约定&#47;协议，如果子类继承了父类，而又不遵守这种约定，那么则与“继承”这个特性相违背，这时就应该考虑新写一个父类来继承了","like_count":0},{"had_liked":false,"id":171296,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1578896252,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1578896252","product_id":100039001,"comment_content":"里氏替换原则给我最大的好处是方便扩展，很完美地阐述了子类和父类的关系：继承不代表可以override任何逻辑，子类需要遵从父类的contract。真落到实处，我感觉设计父类的时候就需要很有经验的工程师结合业务涉及基础逻辑和交互框架，不然就是在不断的重构中优化代码。后者应该更现实点","like_count":0},{"had_liked":false,"id":170349,"user_name":"刘学习来学习","can_delete":false,"product_type":"c1","uid":1464013,"ip_address":"","ucode":"5078B1EC8D8A66","user_header":"https://static001.geekbang.org/account/avatar/00/16/56/cd/0add8290.jpg","comment_is_top":false,"comment_ctime":1578576195,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578576195","product_id":100039001,"comment_content":"lsp是设计上面的一种原则，用来指导设计，多态是编程语言提供的能力，换一种语言来理解这个就好理解一点了","like_count":0},{"had_liked":false,"id":169540,"user_name":"宇宙全栈","can_delete":false,"product_type":"c1","uid":1001309,"ip_address":"","ucode":"2E984CA0ECFB85","user_header":"https://static001.geekbang.org/account/avatar/00/0f/47/5d/9afdf648.jpg","comment_is_top":false,"comment_ctime":1578374589,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578374589","product_id":100039001,"comment_content":"LSP的意义：<br>1、可读：父类型的变量赋值了一个子类型的实例，这是不用读子类代码，也能确定程序的逻辑。<br>2、可维护：优化代码时，不用担心有坑，不用改测试用例。","like_count":0},{"had_liked":false,"id":169413,"user_name":"弹簧人","can_delete":false,"product_type":"c1","uid":1697679,"ip_address":"","ucode":"BCB4A6FC76EA17","user_header":"https://static001.geekbang.org/account/avatar/00/19/e7/8f/56387f77.jpg","comment_is_top":false,"comment_ctime":1578334523,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578334523","product_id":100039001,"comment_content":"多态和里氏替换并不冲突。里氏替换也是针对父类和子类而言的。对于父类的方法，多态是指overide。只要overide的方法和父类逻辑是一致的就行","like_count":0},{"had_liked":false,"id":169195,"user_name":"CHS","can_delete":false,"product_type":"c1","uid":1240227,"ip_address":"","ucode":"3D8B2DABC0A1D6","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/a3/28763399.jpg","comment_is_top":false,"comment_ctime":1578289902,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578289902","product_id":100039001,"comment_content":"子类在继承父类的功能的时候，要在父类原有逻辑的基础上实现增强，不能改变父类的原有的逻辑，保证逻辑的一致性。","like_count":0},{"had_liked":false,"id":168820,"user_name":"ちよくん","can_delete":false,"product_type":"c1","uid":1398577,"ip_address":"","ucode":"B71E9B16E4408F","user_header":"https://static001.geekbang.org/account/avatar/00/15/57/31/6772744d.jpg","comment_is_top":false,"comment_ctime":1578192728,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578192728","product_id":100039001,"comment_content":"扩展父类的业务实现方案，但是不要修改业务规则以及协议规则","like_count":0},{"had_liked":false,"id":168380,"user_name":"Yangjing","can_delete":false,"product_type":"c1","uid":1018061,"ip_address":"","ucode":"D88DFD4958D07C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/88/cd/2c3808ce.jpg","comment_is_top":false,"comment_ctime":1578058320,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1578058320","product_id":100039001,"comment_content":"遵从里氏替换原则，再代码发生改变、扩展时，不会有异常。因为从语法上多态保证了编译时的正确，如果子类无法完全替换父类，有可能程序就会有一些没考虑到的异常","like_count":0},{"had_liked":false,"id":168116,"user_name":"fomy","can_delete":false,"product_type":"c1","uid":1125834,"ip_address":"","ucode":"CD87EA03B1F327","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/ca/02b0e397.jpg","comment_is_top":false,"comment_ctime":1578015499,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578015499","product_id":100039001,"comment_content":"1、应用场景有哪些？<br>答：子类实现父类所有的方法，并且对父类进行增强。符合开闭原则，对扩展开发，对修改关闭。<br><br>2、跟面向接口编程有什么区别？<br>答：（个人见解）面向接口编程也符合里氏替换原则，只是里氏替换原则的其中一种实现而已。想听听大家的理解。","like_count":0},{"had_liked":false,"id":168082,"user_name":"James","can_delete":false,"product_type":"c1","uid":1134861,"ip_address":"","ucode":"48B0F2A334D1C1","user_header":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","comment_is_top":false,"comment_ctime":1578012005,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578012005","product_id":100039001,"comment_content":"就是遵从父类语意，不修改原有逻辑以及程序正确性。","like_count":0},{"had_liked":false,"id":168011,"user_name":"程晓擘","can_delete":false,"product_type":"c1","uid":1328354,"ip_address":"","ucode":"96986D5AE2B96C","user_header":"https://static001.geekbang.org/account/avatar/00/14/44/e2/763526e9.jpg","comment_is_top":false,"comment_ctime":1577975540,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577975540","product_id":100039001,"comment_content":"二刷啦，里氏替换选择存在的意义，父类定义了规范，子类就应该照规范执行，要不就乱套啦，进一步思考，父类引用指向子类，我们拿着父类的引用，不知道指向的是哪个子类，所以子类必须遵守父类的规范，要不出了问题，开发者一头雾水。","like_count":0},{"had_liked":false,"id":167344,"user_name":"啦啦啦","can_delete":false,"product_type":"c1","uid":1131687,"ip_address":"","ucode":"6B12EC90A62525","user_header":"https://static001.geekbang.org/account/avatar/00/11/44/a7/171c1e86.jpg","comment_is_top":false,"comment_ctime":1577772074,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577772074","product_id":100039001,"comment_content":"这个原则就是子类可以修改父类的实现逻辑，但是不能改父类对外的约定","like_count":0},{"had_liked":false,"id":167305,"user_name":"Richie","can_delete":false,"product_type":"c1","uid":1019588,"ip_address":"","ucode":"12314EF0347693","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/c4/8d1150f3.jpg","comment_is_top":false,"comment_ctime":1577760235,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577760235","product_id":100039001,"comment_content":"个人理解，里氏替换原则与多态的关系，就是理论和实践的关系，里氏替换原则指导我们如何正确的使用多态特性。","like_count":0},{"had_liked":false,"id":167224,"user_name":"程晓擘","can_delete":false,"product_type":"c1","uid":1328354,"ip_address":"","ucode":"96986D5AE2B96C","user_header":"https://static001.geekbang.org/account/avatar/00/14/44/e2/763526e9.jpg","comment_is_top":false,"comment_ctime":1577720607,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577720607","product_id":100039001,"comment_content":"二刷喽，里氏替换选择存在的意义，父类定义了规范，子类就应该照规范执行，要不就乱套啦。","like_count":0},{"had_liked":false,"id":166561,"user_name":"汤小高","can_delete":false,"product_type":"c1","uid":1555565,"ip_address":"","ucode":"D4AB7766273D52","user_header":"https://static001.geekbang.org/account/avatar/00/17/bc/6d/f6f0a442.jpg","comment_is_top":false,"comment_ctime":1577501365,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577501365","product_id":100039001,"comment_content":"多态是一种编程语言提供的能力，LSP是限制滥用多态的一种原则和约束，即子类可以重写父类的方法，但是不能修改原父类方法本身要求实现的约定，包括要实现的功能、抛出的异常等，但是子类重写的方法中可以在原父类实现的功能基础上拓展一些新功能。不知道我理解是不是对的？","like_count":0},{"had_liked":false,"id":166080,"user_name":"Next","can_delete":false,"product_type":"c1","uid":1748213,"ip_address":"","ucode":"D5ADDF248A9504","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ac/f5/2f97e279.jpg","comment_is_top":false,"comment_ctime":1577375973,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577375973","product_id":100039001,"comment_content":"如果子类和父类的功能约定不一致，调用者就需要关注子类和父类的细节来保证调用的正确性，而且正确性没有保证；<br>输入输出约定不一致，客户就不能进行一致性调用，增加了额外编码量和维护成本，而且随着后续的扩展，代码将变得混乱复杂度，可读性，维护性将急剧增加！","like_count":0},{"had_liked":false,"id":165192,"user_name":"杨松","can_delete":false,"product_type":"c1","uid":1512517,"ip_address":"","ucode":"FB3C73BC44C94D","user_header":"https://static001.geekbang.org/account/avatar/00/17/14/45/adf079ae.jpg","comment_is_top":false,"comment_ctime":1577177943,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577177943","product_id":100039001,"comment_content":"老师您好，我遇到个问题，和这节课没什么关系，但困扰很久，不知道老师和一起学习的同学们是否有好的建议。问题如下：<br>我单位有俩个网段：132.XX.XX.XX和10.XX.XX.XX，我现在有一台centos7的服务器，里面部署着基于springboot开发的一个小系统，我现在想在该服务器上配置俩块网卡，132.XX.XX.101和10.XX.XX.101，想让两个网段的用户都可以访问，但配置过程中发现我只能在一块网卡的配置文件中添加网关，这样现在造成只能是网关的那个网段可以访问系统，另一个网段的用户根本平ping不通，请问大家有什么好办法吗？","like_count":0},{"had_liked":false,"id":164265,"user_name":"EdisonLi","can_delete":false,"product_type":"c1","uid":1505950,"ip_address":"","ucode":"A85CBF3E2B5620","user_header":"https://static001.geekbang.org/account/avatar/00/16/fa/9e/306a5ce7.jpg","comment_is_top":false,"comment_ctime":1576919637,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576919637","product_id":100039001,"comment_content":"举个Android开发的例子，比如我现在想要实现加载图片功能，想获取Bitmap,然后加载，父类定义一个接口用来拿到Bitmap实现加载图片的逻辑，假如子类继承的父类老版本使用的ImageLoader框架进行加载，现在我想要使用Glide进行加载图片，其实最终的目的就是拿到图片的bitmap，我不管你用什么框架进行加载图片。","like_count":0},{"had_liked":false,"id":164129,"user_name":"AaronChun","can_delete":false,"product_type":"c1","uid":1027352,"ip_address":"","ucode":"0D4A4CBD676A3D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ad/18/41831eae.jpg","comment_is_top":false,"comment_ctime":1576892321,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576892321","product_id":100039001,"comment_content":"多态于里氏替换原则区别：多态是编程语言中支持的一种特性，增强程序设计的扩展性和复用性，里氏替换是对继承关系中子类该如何设计作出说明。","like_count":0},{"had_liked":false,"id":163847,"user_name":"yu","can_delete":false,"product_type":"c1","uid":1138645,"ip_address":"","ucode":"56856DCC0C8387","user_header":"https://static001.geekbang.org/account/avatar/00/11/5f/d5/2fec2911.jpg","comment_is_top":false,"comment_ctime":1576810840,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576810840","product_id":100039001,"comment_content":"个人理解，LSP存在的意义是为了统一子类和父类的行为，对调用方更可控；避免调用时因为行为不一致，或者新加了子类后出现了新的异常，而调用方未处理的情况。","like_count":0},{"had_liked":false,"id":163833,"user_name":"被歌唱拯救中","can_delete":false,"product_type":"c1","uid":1153342,"ip_address":"","ucode":"84E73FB0D1E56A","user_header":"https://static001.geekbang.org/account/avatar/00/11/99/3e/8a813e51.jpg","comment_is_top":false,"comment_ctime":1576808993,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576808993","product_id":100039001,"comment_content":"在使用父类的角度有疑问：<br><br>针对子类做针对性的编程(即向下转型，而且是安全的向下转型)是否可取？是否违反了里氏替换原则？<br>给人的感觉是，其实是已经违反了里氏替换原则，这样做只是在违反之后采用的补救措施。<br>java提供这样的语法，是不是有他的设计考虑？什么时候可以这样使用。<br>例如：<br>```java<br>    public void method(BaseClass baseInstance) {<br>        if (baseInstance instanceof ASubClass) {<br>            ASubClass subInstance = (ASubClass)baseInstance;<br>            subInstance.xxxx();<br>        }<br>    }<br>```","like_count":0},{"had_liked":false,"id":163567,"user_name":"August","can_delete":false,"product_type":"c1","uid":1747702,"ip_address":"","ucode":"21794846E0E510","user_header":"https://static001.geekbang.org/account/avatar/00/1a/aa/f6/66cc1bcb.jpg","comment_is_top":false,"comment_ctime":1576746555,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1576746555","product_id":100039001,"comment_content":"我觉得LSP的意义在于，能够完美继承父类现有的约定的同时，又能灵活的按照自己的需求进行重写，就像原则中规定的一样，不要人为的去破坏这种已有的约定就好","like_count":0,"discussions":[{"author":{"id":1252107,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1b/0b/bf56c9e7.jpg","nickname":"bing5tui3","note":"","ucode":"7A313BAC3E6665","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":98801,"discussion_content":"赞同，里氏替换的主要指导思想还是不要去重写父类的方法！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577187121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163130,"user_name":"蜗牛","can_delete":false,"product_type":"c1","uid":1086220,"ip_address":"","ucode":"01CC18F12E556D","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/0c/0a6a0d5e.jpg","comment_is_top":false,"comment_ctime":1576661036,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576661036","product_id":100039001,"comment_content":"有条理、有深度地讲一讲里式替换原则存在的意义。<br>：兼容以前实现的代码，减少出错的可能性","like_count":0},{"had_liked":false,"id":163098,"user_name":"shniu","can_delete":false,"product_type":"c1","uid":1019555,"ip_address":"","ucode":"E64CD8BED96D8D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/a3/d7e5fe8a.jpg","comment_is_top":false,"comment_ctime":1576656269,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576656269","product_id":100039001,"comment_content":"LSP 的意义是应对复杂多变的需求<br>首先，我们要合作方之间设计规范，设计约束，设计如何共同完成一件事情<br>其次，有了规范，可能在不同阶段会有不同的实现来满足不同阶段的发展，那每种实现都必须严格符合规范和约束，不能随意变动，这也是为了尽可能保护协议的稳定性，做到对扩展开放","like_count":0},{"had_liked":false,"id":162941,"user_name":"陈拾柒","can_delete":false,"product_type":"c1","uid":1473069,"ip_address":"","ucode":"22213E2FA5143A","user_header":"https://static001.geekbang.org/account/avatar/00/16/7a/2d/e3a5c52e.jpg","comment_is_top":false,"comment_ctime":1576632932,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576632932","product_id":100039001,"comment_content":"有两个疑问，希望老师解答一下 <br>1. 对于某些没有抽象类的语言，例如oc，自己实现抽象类的逻辑的时候，定义好抽象类，但是在抽象类中的方法实现，都使用NSAssert去抛出异常，这样在开发的时候就可以不能直接使用抽象类，子类必须重写实现抽象类的方法才行。 这种是否违背了里氏替换原则，是否有必要在父类中使用assert抛出异常？ <br>2. 对于里氏替换原则，子类输入参数的类型范围必须大于父类，这个我可以理解。但是输出类型，准确的说应该是子类输出参数的类型和父类相同或者是父类输出参数的子类吧？老师这一点说的不是很详细，觉得可以作为补充。","like_count":0},{"had_liked":false,"id":162675,"user_name":"二十四","can_delete":false,"product_type":"c1","uid":1341111,"ip_address":"","ucode":"9EFA55E9636289","user_header":"https://static001.geekbang.org/account/avatar/00/14/76/b7/3ac99a8f.jpg","comment_is_top":false,"comment_ctime":1576576582,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576576582","product_id":100039001,"comment_content":"里氏替换原则的意义：从灵活性上讲，代码调用方的逻辑不需要做修改；从可读性上讲，父类的方法含义和注释不会与子类产生冲突。","like_count":0},{"had_liked":false,"id":162632,"user_name":"斐波那契","can_delete":false,"product_type":"c1","uid":1464006,"ip_address":"","ucode":"85E2EBC01392B1","user_header":"https://static001.geekbang.org/account/avatar/00/16/56/c6/0b449bc6.jpg","comment_is_top":false,"comment_ctime":1576569835,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576569835","product_id":100039001,"comment_content":"听完这一讲感觉又迷惑了 不违反约定这个可以理解 但是子类不能“修改”父类这个就不清楚了 拿这一讲里面一个例子--子类对于负数就抛异常 相对于父类要求更严格了--来说，如果需求是要求变严格那应该怎么改？直接在父类上改么？","like_count":0},{"had_liked":false,"id":162398,"user_name":"|･ω･｀)","can_delete":false,"product_type":"c1","uid":1636123,"ip_address":"","ucode":"34E1DF62058D80","user_header":"https://static001.geekbang.org/account/avatar/00/18/f7/1b/8036958c.jpg","comment_is_top":false,"comment_ctime":1576509157,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576509157","product_id":100039001,"comment_content":"我对里氏替换原则的理解是：外部在调用子类的时候，和调用父类是一样的，不会导致其他的效果或者影响流程<br>外部可以安全地替换任意实现类","like_count":0},{"had_liked":false,"id":162339,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1576501721,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576501721","product_id":100039001,"comment_content":"校验是否满足里氏替换原则：使用父类的单元测试去测试字类的功能模块","like_count":0},{"had_liked":false,"id":162318,"user_name":"我的心里只有工作","can_delete":false,"product_type":"c1","uid":1238185,"ip_address":"","ucode":"488DD6F9590EB8","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/a9/117fe480.jpg","comment_is_top":false,"comment_ctime":1576499458,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576499458","product_id":100039001,"comment_content":"今天看了文章，才明白里氏替换原则","like_count":0},{"had_liked":false,"id":162228,"user_name":"Kevin","can_delete":false,"product_type":"c1","uid":1429627,"ip_address":"","ucode":"9DFFD6E3960CF7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJN64OCUT0Jp0h2Wiau9Os0o1WbwUeoq2QL0U2vZpib8ozPxo0XDiaPM9xcKfbkoBL24ztEHelxPIMVg/132","comment_is_top":false,"comment_ctime":1576480745,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576480745","product_id":100039001,"comment_content":"LSP  可以理解为是 开闭原则的边界约束。  对扩展开放，开放到什么程度，不能开放到修改了原有代码逻辑。也是对修改关闭的一种体现。","like_count":0},{"had_liked":false,"id":162222,"user_name":"马哲富","can_delete":false,"product_type":"c1","uid":1107917,"ip_address":"","ucode":"D6BDDFE3CC07ED","user_header":"https://static001.geekbang.org/account/avatar/00/10/e7/cd/08088f14.jpg","comment_is_top":false,"comment_ctime":1576479976,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576479976","product_id":100039001,"comment_content":"听完感觉恍然大悟","like_count":0},{"had_liked":false,"id":162100,"user_name":"堵车","can_delete":false,"product_type":"c1","uid":1145404,"ip_address":"","ucode":"7BC1E50A4F8D3D","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/3c/87e015f8.jpg","comment_is_top":false,"comment_ctime":1576461551,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576461551","product_id":100039001,"comment_content":"违背了里氏替换原则会有什么后果呢？比如有个订单查询方法，参数有多个。父类允许参数都是空，子类要求必须有一个值不为空。子类校验了参数，抛出异常。这样就会违反历史替换原则。这样改回导致什么问题呢？","like_count":0},{"had_liked":false,"id":161940,"user_name":"Douglas","can_delete":false,"product_type":"c1","uid":1073027,"ip_address":"","ucode":"CFDE3D76B9DAE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/83/bb728e53.jpg","comment_is_top":false,"comment_ctime":1576410007,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576410007","product_id":100039001,"comment_content":"还是争哥牛， 总是把别人解释不通不明的说的彻底。","like_count":0},{"had_liked":false,"id":161915,"user_name":"炫炫","can_delete":false,"product_type":"c1","uid":1358609,"ip_address":"","ucode":"FDC7A0C6E08B02","user_header":"https://static001.geekbang.org/account/avatar/00/14/bb/11/7069b8eb.jpg","comment_is_top":false,"comment_ctime":1576400831,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576400831","product_id":100039001,"comment_content":"里氏替换原则是设计准则，多态是我们实现子类时候用到的编程方法，  我们设计子类时候应当按照里氏替换原则的准则去设计，当然编程是自由的。","like_count":0},{"had_liked":false,"id":161819,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1576339491,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576339491","product_id":100039001,"comment_content":"里式替换原则存在的意义：对面向对象程序开发中子类和父类的设计有明确的指导作用—子类应该在不影响父类功能的前提下进行功能增强","like_count":0},{"had_liked":false,"id":161732,"user_name":"小刀","can_delete":false,"product_type":"c1","uid":1351063,"ip_address":"","ucode":"94DF8C45E09E42","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/iaByN5IfYbE9jMtWrtTDXtPEIHeV77KW1p7ZkiasiaGgA50VXaibo4fbp5ib2JkFP3iaIe4AUudLibufkEIofu5euCNHg/132","comment_is_top":false,"comment_ctime":1576310018,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576310018","product_id":100039001,"comment_content":"扩展而非修改","like_count":0},{"had_liked":false,"id":161670,"user_name":"李稳","can_delete":false,"product_type":"c1","uid":1401912,"ip_address":"","ucode":"B8164B6B65E26C","user_header":"https://static001.geekbang.org/account/avatar/00/15/64/38/1bd1324e.jpg","comment_is_top":false,"comment_ctime":1576292148,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576292148","product_id":100039001,"comment_content":"里式替换：按协议设计，子类可以改变逻辑，但不能改变约定.<br>约定1.功能2.输入输出异常3.注释<br>多态：java语法特性<br>里式替换：设计原则，执导子类设计","like_count":0},{"had_liked":false,"id":161602,"user_name":"join","can_delete":false,"product_type":"c1","uid":1130132,"ip_address":"","ucode":"C097D89F7BA3EF","user_header":"https://static001.geekbang.org/account/avatar/00/11/3e/94/c6460883.jpg","comment_is_top":false,"comment_ctime":1576244862,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576244862","product_id":100039001,"comment_content":"多态是面向对象编程的一种特征，而里氏替换是编程的设计原则，里氏替换可以通过多态的方式来实现。<br>里氏替换比多态有更多的约束。","like_count":0},{"had_liked":false,"id":161564,"user_name":"Miaozhe","can_delete":false,"product_type":"c1","uid":1113660,"ip_address":"","ucode":"62872E8C138B67","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","comment_is_top":false,"comment_ctime":1576233639,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576233639","product_id":100039001,"comment_content":"里氏替换，能写出低耦合的代码，方便扩展，重减少重构的影响。<br><br>不过如果基类设计的质量差，会影响后续子类的实现。","like_count":0},{"had_liked":false,"id":161563,"user_name":"Miaozhe","can_delete":false,"product_type":"c1","uid":1113660,"ip_address":"","ucode":"62872E8C138B67","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","comment_is_top":false,"comment_ctime":1576233371,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576233371","product_id":100039001,"comment_content":"多态是思想，指导大家实现程序的可扩展性。<br>里氏替换原则，是原则和规范，能约束大家，写出可读性,可维护性强的程序。","like_count":0},{"had_liked":false,"id":161541,"user_name":"相逢是缘","can_delete":false,"product_type":"c1","uid":1060730,"ip_address":"","ucode":"CB299F53A95654","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg","comment_is_top":false,"comment_ctime":1576226515,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576226515","product_id":100039001,"comment_content":"打卡<br>1、里式替换原则定义：子类对象可以替换程序中任何地方的父类对象，替换之后程序的逻辑和正确性保持不变；<br>2、核心是&quot;按协议来设计&quot;，父类定义函数的“约定”，子类可以改变内部分实现逻辑，但是不能改变约定。具体来说需要遵循以下规则不能改变：<br>1）函数声明要实现的功能<br>2）输入、输出及异常<br>3）其他的特殊的约定和说明<br> \t从上层接口设计看，这要求在进行接口或父类设计时对上层的约定足够抽象，比较通用。从子类设计看，不要破坏上层的协议约定。<br>3、里式替换和多态的区别：关注的角度不一样，多态是面向对象语言的一种语法，是编程的一种实现思路。里式替换原则是一种设计原则，用来指导继承关系中子类如何进行设计","like_count":0},{"had_liked":false,"id":161475,"user_name":"NYang","can_delete":false,"product_type":"c1","uid":1239235,"ip_address":"","ucode":"FCDB3246D1195A","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/c3/11479173.jpg","comment_is_top":false,"comment_ctime":1576213715,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576213715","product_id":100039001,"comment_content":"课堂笔记<br><br>里式替换原则是一种代码的设计规范，更多是人为约束的。不同于多态，多态是代码的特性。<br><br>多态保证子类在替换父类的过程中程序运行正常，但不要求子类实现符合父类的规范。<br><br>而里式替换规定子类的实现必须符合父类的规范，包括但不限于方法的入参，出参，异常等。","like_count":0},{"had_liked":false,"id":161427,"user_name":"丿淡忘","can_delete":false,"product_type":"c1","uid":1139645,"ip_address":"","ucode":"604AE01961A026","user_header":"https://static001.geekbang.org/account/avatar/00/11/63/bd/80f587ad.jpg","comment_is_top":false,"comment_ctime":1576204300,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1576204300","product_id":100039001,"comment_content":"lsp存在的意义直白点应该就是保证代码的可读性吧","like_count":0},{"had_liked":false,"id":161358,"user_name":"小先生","can_delete":false,"product_type":"c1","uid":1055214,"ip_address":"","ucode":"E5F2052E0323C0","user_header":"https://static001.geekbang.org/account/avatar/00/10/19/ee/e395a35e.jpg","comment_is_top":false,"comment_ctime":1576198040,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576198040","product_id":100039001,"comment_content":"如果就是需要改变父类的实现和期望输出。应该怎么做？","like_count":0},{"had_liked":false,"id":161356,"user_name":"Geek_e7834d","can_delete":false,"product_type":"c1","uid":1530493,"ip_address":"","ucode":"ABAF1B1B7E6490","user_header":"","comment_is_top":false,"comment_ctime":1576197833,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576197833","product_id":100039001,"comment_content":"子类是父类契约的具体实现， 但是子类如果扩展了父类怎么办？扩展的功能在调用的时候就无法使用父类的接口， 只能转换为子类来调用。这种情况怎么解决呢？ 增加另外一个接口来描述扩展的部分功能？","like_count":0},{"had_liked":false,"id":161355,"user_name":"quietwater","can_delete":false,"product_type":"c1","uid":1055029,"ip_address":"","ucode":"C25E2CD356D3F9","user_header":"https://static001.geekbang.org/account/avatar/00/10/19/35/be8372be.jpg","comment_is_top":false,"comment_ctime":1576197737,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576197737","product_id":100039001,"comment_content":"里式替换原则存在的意义在于面向抽象编程，也就是面向约定编程，父类定义了约定，子类遵守约定，使用时只使用父类，也就是向上转型，符合开闭原则。","like_count":0},{"had_liked":false,"id":161290,"user_name":"小海","can_delete":false,"product_type":"c1","uid":1183874,"ip_address":"","ucode":"E566E4B9E9852C","user_header":"https://static001.geekbang.org/account/avatar/00/12/10/82/f5a3ecf5.jpg","comment_is_top":false,"comment_ctime":1576166597,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576166597","product_id":100039001,"comment_content":"里氏替换主要用来指导子类如何设计，而子类存在的意义就在于功能的扩展，结合里氏替换的定义，得出该原则存在的意义在于保证原有功能稳定的前提下（兼容性），做出更具备健壮性的功能扩展。","like_count":0},{"had_liked":false,"id":161284,"user_name":"Jackey","can_delete":false,"product_type":"c1","uid":1063751,"ip_address":"","ucode":"125DE81993FEDD","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/47/f6c772a1.jpg","comment_is_top":false,"comment_ctime":1576165958,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576165958","product_id":100039001,"comment_content":"前面提到许多设计模式和设计原则都是为了代码的可扩展性。我认为LSP也是，当代码需要修改时，直接继承一个类，进行修改，讲父类应用之处都替换成子类。从而达到扩展功能的目的。不知道这样理解对不对","like_count":0},{"had_liked":false,"id":161275,"user_name":"xuanyuan","can_delete":false,"product_type":"c1","uid":1113737,"ip_address":"","ucode":"1EC79B9372868F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2icbib62icXtibTkThtyRksbuJLoTLMts7zook2S30MiaBtbz0f5JskwYicwqXkhpYfvCpuYkcvPTibEaQ/132","comment_is_top":false,"comment_ctime":1576163267,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576163267","product_id":100039001,"comment_content":"这讲非常赞，考虑到大多数人会把里式替换原则理解为多态。关键是把抽象的原则给出了具体可实施的标准","like_count":0},{"had_liked":false,"id":161250,"user_name":"连边","can_delete":false,"product_type":"c1","uid":1391748,"ip_address":"","ucode":"54B5DA38449728","user_header":"https://static001.geekbang.org/account/avatar/00/15/3c/84/608f679b.jpg","comment_is_top":false,"comment_ctime":1576156915,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576156915","product_id":100039001,"comment_content":"另外一种方式接口约定存在，接口是项目一开始就定义好的，而利用里氏替换原则来重写方法，也是保证返回值与参数的一致性，从而可以达到兼容的目的。","like_count":0},{"had_liked":false,"id":161246,"user_name":"AgCl","can_delete":false,"product_type":"c1","uid":1408804,"ip_address":"","ucode":"2C7660E3C5565D","user_header":"https://static001.geekbang.org/account/avatar/00/15/7f/24/719ce9d4.jpg","comment_is_top":false,"comment_ctime":1576156136,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576156136","product_id":100039001,"comment_content":"听完之后，虽然老师强调了多态和里式替换原则是两个概念，总觉得多态的效果是不符合里式替换原则而有意义的","like_count":0},{"had_liked":false,"id":161229,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1576152017,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576152017","product_id":100039001,"comment_content":"是人就要吃饭。<br>男人是人，所以男人也要吃饭。<br>女人是人，所以女人也要吃饭。","like_count":0},{"had_liked":false,"id":161210,"user_name":"CarlXu","can_delete":false,"product_type":"c1","uid":1585713,"ip_address":"","ucode":"6A5DF4459907C2","user_header":"https://static001.geekbang.org/account/avatar/00/18/32/31/449513a1.jpg","comment_is_top":false,"comment_ctime":1576148951,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576148951","product_id":100039001,"comment_content":"多态不是为了实现和父类不一定的功能的吗？ 如果子类完全遵守父类的约定，就直接使用父类方法就好了，干嘛要重写呢。 ","like_count":0},{"had_liked":false,"id":161057,"user_name":"醉比","can_delete":false,"product_type":"c1","uid":1248399,"ip_address":"","ucode":"79E65F62BE7809","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/8f/4ebd303a.jpg","comment_is_top":false,"comment_ctime":1576111233,"is_pvip":false,"replies":[{"id":"61497","content":"我自己觉得意义也不大 你可以看下我文章里的说明😂","user_name":"作者回复","comment_id":161057,"uid":"1190123","ip_address":"","utype":1,"ctime":1576199336,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"1576111233","product_id":100039001,"comment_content":"第一遍学完这节课，我的问题就是里式替换存在的意义是为啥哈哈哈哈","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477589,"discussion_content":"我自己觉得意义也不大 你可以看下我文章里的说明😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576199336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161037,"user_name":"王喜春","can_delete":false,"product_type":"c1","uid":1022349,"ip_address":"","ucode":"436E91FDED1B30","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/8d/4d5dbfc5.jpg","comment_is_top":false,"comment_ctime":1576104908,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576104908","product_id":100039001,"comment_content":"想了解下，使用里氏代换后系统的带来的好处，如哪些开源框架中有使用？<br>另一方面， 现在的业务系统“设计”（姑且叫设计）时，大多不知这个原则，体现的问题是？怎么破解？","like_count":0},{"had_liked":false,"id":161034,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1576097513,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576097513","product_id":100039001,"comment_content":"多态是分离接口与实现，以及抽象类与具体类的具体工具，是编程语言层面的功能。里氏替换替换原则是从对象运行的环境去审视对象的公共方法和属性。所有能够满足接口的对象不但要满足了接口或者基类语言层面的约束（这一点和多态类似），也要满足所有接口和基类功能层面的约束（这一点和多态不同）。<br>我想Java编译期的异常可能就是基于这个层面设计的。但是把异常分为编译期和运行期也增加了很多编程负担，新的语言Kotlin就没有这项区分。<br>我个人觉得这条原则实战中用的不多，因为异常，类型检查等通常是实现细节，放到基类和接口中本身就很值得商榷，接口或者基类足够抽象，派生类足够灵活，一般也就够用了。","like_count":0},{"had_liked":false,"id":161024,"user_name":"筱乐乐哦","can_delete":false,"product_type":"c1","uid":1307611,"ip_address":"","ucode":"AE92539F0419C3","user_header":"https://static001.geekbang.org/account/avatar/00/13/f3/db/5b7a8fd8.jpg","comment_is_top":false,"comment_ctime":1576082516,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576082516","product_id":100039001,"comment_content":"<br>如果不遵循里氏替换原则，可能会有以下问题：<br>1、类继承会变得很混乱，因此奇怪的行为会发生<br>2、对于父类的单元测试对于子类是无效的，因此会降低代码的可测试性和验证程度<br>个人想法：<br>1、可以通过在子类中调用父类的公有方法来获取一些内部状态变量，而不是直接使用它。这样我们就可以保证父类抽象中正确的状态语义，从而避免了副作用和非法的状态转变。<br>2、父类设计的应该简单单一，这样子类才能方便拓展，如果一个父类是比较复杂的，那么子类在覆盖它的时候，在不影响父类状态语义的情况下进行扩展绝非易事。<br>3、可以检测出自己开发的新功能是否对原有功能产生了影响，这点我感觉很重要<br>","like_count":0},{"had_liked":false,"id":161016,"user_name":"王小念","can_delete":false,"product_type":"c1","uid":1057147,"ip_address":"","ucode":"2062E25909B8E0","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/7b/53a325d1.jpg","comment_is_top":false,"comment_ctime":1576079702,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576079702","product_id":100039001,"comment_content":"“里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。” 这里讲到‘不改变原有程序的逻辑’。 <br>后面“父类定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。” 这里又讲到‘可以改变内部时间逻辑’。<br>乍一看感觉有点矛盾和疑惑。<br>后来想想，前者可能是指的整个程序上的业务逻辑，后者指的是如何实现这些业务逻辑的具体函数的实现逻辑，不知道理解的对不对？","like_count":0},{"had_liked":false,"id":160923,"user_name":"柳志焕","can_delete":false,"product_type":"c1","uid":1235940,"ip_address":"","ucode":"42375930DC2AA0","user_header":"https://static001.geekbang.org/account/avatar/00/12/db/e4/a1b45d79.jpg","comment_is_top":false,"comment_ctime":1576060986,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576060986","product_id":100039001,"comment_content":"里式替换原则存在的意义：子类可以扩展父类的功能，但不能改变父类原有的功能。","like_count":0},{"had_liked":false,"id":160920,"user_name":"蛤蟆先生","can_delete":false,"product_type":"c1","uid":1125703,"ip_address":"","ucode":"8353492D68DBBF","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/47/7c3baa15.jpg","comment_is_top":false,"comment_ctime":1576060458,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576060458","product_id":100039001,"comment_content":"取钱那个例子，子类可以透支取钱为什么就不符合里氏替换原则了呢，而且对于设计原则来讲，难道不应该刨除业务逻辑吗","like_count":0},{"had_liked":false,"id":160919,"user_name":"左","can_delete":false,"product_type":"c1","uid":1048799,"ip_address":"","ucode":"FE02803AE2C0F0","user_header":"https://static001.geekbang.org/account/avatar/00/10/00/df/58fe37df.jpg","comment_is_top":false,"comment_ctime":1576060376,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576060376","product_id":100039001,"comment_content":"所有的多态实现，假如不遵循里氏替换原则，就会出异常。","like_count":0},{"had_liked":false,"id":160918,"user_name":"刘大明","can_delete":false,"product_type":"c1","uid":1035081,"ip_address":"","ucode":"83C063FBD9BF2B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cb/49/0b9ffc8e.jpg","comment_is_top":false,"comment_ctime":1576060295,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576060295","product_id":100039001,"comment_content":"里式替换原则。我觉得应该是父类替换子类，程序的行为没有任何变化。正是因为此，才让开闭原则成为了可能。对修改关闭，对扩展开放。","like_count":0},{"had_liked":false,"id":160883,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1576053426,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576053426","product_id":100039001,"comment_content":"课堂讨论answer:<br><br>    里氏替换原则(LSP)是OOD中继承方面的指导原则：凡是父类实例存在的地方，应该可以用子类实例替换，且程序不被破坏。<br><br>    从程序设计角度自顶向下看，LSP鼓励使用多态的方式设计api。<br><br>    从编码实现的角度看， LSP约束子类慎重的实现从父类继承的方法，让开发者更谨慎的实现子类，不要违反父类的Contract，从而提升代码的健壮性。","like_count":0},{"had_liked":false,"id":160875,"user_name":"[耶]友超","can_delete":false,"product_type":"c1","uid":1400962,"ip_address":"","ucode":"890572F77C3670","user_header":"https://static001.geekbang.org/account/avatar/00/15/60/82/9a43504b.jpg","comment_is_top":false,"comment_ctime":1576052219,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576052219","product_id":100039001,"comment_content":"&quot;里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。&quot;我感觉这就是答案了，为了保证父类的方法被子类重写时，其基本逻辑不会被改变。","like_count":0,"discussions":[{"author":{"id":1337598,"avatar":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","nickname":"岁月","note":"","ucode":"29A2A2BC3C4FE4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220488,"discussion_content":"对, 图画错了...","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585883713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1634681,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoxgWxeetICvoiadIicia5IoA0ITcQeHc1uc2CxQgvlic9GVW9eibaIbRbHso3bdHdnzmGiapdqENMiack7Q/132","nickname":"Valarchie","note":"","ucode":"D56EF3006B3124","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293482,"discussion_content":"看得有点懵逼  赶紧拉下来看评论 结果还真是画错了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595555764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1131070,"avatar":"https://static001.geekbang.org/account/avatar/00/11/42/3e/c1f76202.jpg","nickname":"青山","note":"","ucode":"749BAD1834AC0F","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292973,"discussion_content":"哈哈哈 到现在还没改 我还在想 这是我没理解还是什么，如果有问题应该有同学已经指出改正了呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595400400,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1045078,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f2/56/c39046c0.jpg","nickname":"Jie","note":"","ucode":"AB94041E548FEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":239252,"discussion_content":" 恩，顶上去求修正","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587287620,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1228852,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c0/34/0574bb44.jpg","nickname":"最初的印象","note":"","ucode":"4DD68307FA274E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":222311,"discussion_content":"确实是画错了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586133286,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1484184,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","nickname":"djfhchdh","note":"","ucode":"E71D75328CE398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":221208,"discussion_content":"图确实错了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585989539,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160833,"user_name":"辉仔lovers","can_delete":false,"product_type":"c1","uid":1210219,"ip_address":"","ucode":"3DC5B0CD0B8E71","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLVhJRVwJ0eVlC7zjNfWP6PP7VmUkF1X2m6qfh7Wic3NhAOz2fSGibF6LXLcJ59zOz7nBpCcByvtFjw/132","comment_is_top":false,"comment_ctime":1576043485,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576043485","product_id":100039001,"comment_content":"之前没有想过多态和里式替换的关系，以为使用多态，子类就可以替换掉父类。<br>总结：多态是面向对象的编程方式。里式替换是一种设计原则，指导子类是如何设计的。","like_count":0},{"had_liked":false,"id":160828,"user_name":"LJK","can_delete":false,"product_type":"c1","uid":1199213,"ip_address":"","ucode":"12B2441099FF1D","user_header":"https://static001.geekbang.org/account/avatar/00/12/4c/6d/c20f2d5a.jpg","comment_is_top":false,"comment_ctime":1576041737,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1576041737","product_id":100039001,"comment_content":"接口类也适用吗？","like_count":0,"discussions":[{"author":{"id":1738326,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","nickname":"守拙","note":"","ucode":"F594B2DA3F6D4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":221418,"discussion_content":"看了一圈 问题2只有你答对了 其他人都不看源码么... 明明ArrayList和LinkedList用的都是AbstractList的Iterator, 而且iterator#next()在LinkedList中调用get()明明是通过下标拿的..","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1586008056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1738326,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","nickname":"守拙","note":"","ucode":"F594B2DA3F6D4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":221424,"discussion_content":"LinkedList#remove(index)调用unlink()了, 明明里面都修改modCount了, 所以LinkedList遍历时移除元素铁定报ConcurrentModificationException的.","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1586008264,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2115387,"avatar":"https://static001.geekbang.org/account/avatar/00/20/47/3b/70198ceb.jpg","nickname":"Aibo","note":"","ucode":"2CE3E77BD2D014","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387667,"discussion_content":"当在游标及游标之前增删元素时会使有的元素遍历不到，这里应该不是问题；删除了元素本来就应该遍历不到；数组删除游标之前的元素有问题，是因为所有元素都前移一位，导致本来没有被删除的那个当前游标下的元素遍历不到了；","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628331756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369725,"discussion_content":"@Test\n    public void removeTest2() {\n        List<Integer> integers = new ArrayList<>();\n        integers.add(0);\n        integers.add(1);\n        integers.add(2);\n\n        Iterator<Integer> it = integers.iterator();\n        while (it.hasNext()) {\n            Integer next = it.next();\n            System.out.println(next);\n            integers.add(3, 3);\n        }\n    }\n这明显报错啊...第二题回答也不对吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619142612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160825,"user_name":"Eden Ma","can_delete":false,"product_type":"c1","uid":1457408,"ip_address":"","ucode":"755312F0D154F9","user_header":"https://static001.geekbang.org/account/avatar/00/16/3d/00/7daa7403.jpg","comment_is_top":false,"comment_ctime":1576040958,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576040958","product_id":100039001,"comment_content":"LSP存在的意义我觉得应该是提高了代码的稳定性和易于理解性，后续维护可以更清晰的明白子类的职责，减少一些不明所以的状况发生。","like_count":0},{"had_liked":false,"id":160820,"user_name":"Crazy.","can_delete":false,"product_type":"c1","uid":1066838,"ip_address":"","ucode":"FB093FE6E0A66B","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/56/e22477c7.jpg","comment_is_top":false,"comment_ctime":1576039847,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576039847","product_id":100039001,"comment_content":"子类可以扩展父类的功能，但不能改变父类原有的功能","like_count":0},{"had_liked":false,"id":160811,"user_name":"秋惊蛰","can_delete":false,"product_type":"c1","uid":1620344,"ip_address":"","ucode":"3D9A6D5CA9C79F","user_header":"https://static001.geekbang.org/account/avatar/00/18/b9/78/a5804dae.jpg","comment_is_top":false,"comment_ctime":1576036293,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576036293","product_id":100039001,"comment_content":"如果想用可替换的组件来构建软件系统, 那么这些组件就必须遵守同一个约定, 以便让这些组件可以相互替换.<br>事实上, 这不止是父类和子类之间的关系, 而是接口与实现之间的应该遵守的原则.","like_count":0},{"had_liked":false,"id":160794,"user_name":"程序员小跃","can_delete":false,"product_type":"c1","uid":1015483,"ip_address":"","ucode":"25BB96E0791A60","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","comment_is_top":false,"comment_ctime":1576033400,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576033400","product_id":100039001,"comment_content":"我所理解的里式替换，最重要的意义在于子类是对父类的进一步的从内容上扩充，但是最终返回的是和父类实现一样的结果。<br><br>就像楼上“辣么大”说的第一条，优化父类的算法，提高性能；或者优化里面实现的函数，数据结构的方式，达到自定义的条件，但是最终呈现回同一个想要的结果，这点意义重大。<br><br>这样就能很好的扩充现有的一些父类不足的地方，我们可以更好的去操作","like_count":0},{"had_liked":false,"id":160791,"user_name":"pines","can_delete":false,"product_type":"c1","uid":1200708,"ip_address":"","ucode":"7B925605B36B4E","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/44/de7f2b98.jpg","comment_is_top":false,"comment_ctime":1576032979,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576032979","product_id":100039001,"comment_content":"1.里式替换原则 是子类重写父类接口的限定，不过内部逻辑怎么处理，但是结果的返回，错误的处理必须完全一致。<br>2.他的存在意义让开闭原则变得更加健壮。在此降低了业务代码修改的风险","like_count":0},{"had_liked":false,"id":160772,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1576031240,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576031240","product_id":100039001,"comment_content":"里氏替换原则可以认为是开闭原则的一种具体运用。子类替换父类，实现了功能的“扩展”，并且修改没有影响原来的使用逻辑，因此可以认为是“关闭的”。<br>","like_count":0},{"had_liked":false,"id":160771,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1576031007,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576031007","product_id":100039001,"comment_content":"订单排序的反例：<br>如果从原有的按照金额排序，变为了按照创建时间排序，是不行的。<br>但是，如果从单纯按照金额排序，变成了，首要排序条件是金额，次要排序条件是创建时间，这种情况违背里氏替换吗？<br>","like_count":0},{"had_liked":false,"id":160769,"user_name":"潇潇雨歇","can_delete":false,"product_type":"c1","uid":1251429,"ip_address":"","ucode":"4BD52BF0F0A084","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/65/35361f02.jpg","comment_is_top":false,"comment_ctime":1576030929,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576030929","product_id":100039001,"comment_content":"里氏替换原则是一种协议，约定；对于子类的约定，必须要遵守父类函数的约定，如果子类破坏了原有的设计，说明设计没有弄好，我觉得这是设计层面上的指导意义。","like_count":0},{"had_liked":false,"id":160747,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1576028778,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576028778","product_id":100039001,"comment_content":"虽然多态和lsp角度不同，但感觉lsp也是对多态的一种扩展或补充。","like_count":0},{"had_liked":false,"id":160746,"user_name":"Yayu","can_delete":false,"product_type":"c1","uid":1058015,"ip_address":"","ucode":"5E7842458D8229","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/df/645f8087.jpg","comment_is_top":false,"comment_ctime":1576028771,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576028771","product_id":100039001,"comment_content":"只可意会不可言传的东西是不是都不够有生命力？面向协议设计，为什么不把里氏替换原则中的父类替换成接口？如果换成了接口，这个原则有什么必要存在吗？","like_count":0},{"had_liked":false,"id":160745,"user_name":"evolution","can_delete":false,"product_type":"c1","uid":1088402,"ip_address":"","ucode":"105C59822BF75B","user_header":"https://static001.geekbang.org/account/avatar/00/10/9b/92/c0863297.jpg","comment_is_top":false,"comment_ctime":1576028677,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576028677","product_id":100039001,"comment_content":"里氏替换是代码涉及多态时，需要参考的一个原则。目的是对外提供一致性的输入输出值","like_count":0},{"had_liked":false,"id":160741,"user_name":"weineel","can_delete":false,"product_type":"c1","uid":1049741,"ip_address":"","ucode":"6DC6EF4F256A53","user_header":"https://static001.geekbang.org/account/avatar/00/10/04/8d/005c2ff3.jpg","comment_is_top":false,"comment_ctime":1576027761,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1576027761","product_id":100039001,"comment_content":"重写的父类方法时，其子类实现对方法外部环境的影响应该小于等于父类。<br><br>子类-&gt;父类， 实现类-&gt;接口。","like_count":0},{"had_liked":false,"id":160736,"user_name":"拂尘","can_delete":false,"product_type":"c1","uid":1609964,"ip_address":"","ucode":"9563C002E4B06A","user_header":"https://static001.geekbang.org/account/avatar/00/18/90/ec/ede93589.jpg","comment_is_top":false,"comment_ctime":1576027313,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576027313","product_id":100039001,"comment_content":"感觉里式替换原则的话，也是上一章的开闭原则的一个支撑咯。因为只有当完全遵守约定进行的扩展，才能够在不修改原有代码的基础，完美的兼容。","like_count":0},{"had_liked":false,"id":160734,"user_name":"子夜2104","can_delete":false,"product_type":"c1","uid":1070286,"ip_address":"","ucode":"C4FF54AEA6002F","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/ce/92029d2f.jpg","comment_is_top":false,"comment_ctime":1576027163,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576027163","product_id":100039001,"comment_content":"里氏替换<br><br>子类可以在任何地方替换父类，而不影响原有程序的逻辑行为。<br>里氏替换的好处还是为了使得代码有更好的扩展性和维护性，父类和子类有一样的行为，也方便测试。<br><br>里氏替换最核心的就是design by contract，按照协议来设计这几个字。父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数原有的“约定”。这里的约定包括：<br><br>函数声明要实现的功能；<br>对输入、输出、异常的约定；<br>甚至包括注释中所罗列的任何特殊说明。<br>里氏替换和多态还是不一样的，多态是子类可以替换父类，更多情况是在形参上父类接受子类，就可以了。而里氏替换还需要满足约定，替换后，程序逻辑、功能、行为、表达含义还是要跟原有的一样。","like_count":0},{"had_liked":false,"id":160733,"user_name":"编程界的小学生","can_delete":false,"product_type":"c1","uid":1593289,"ip_address":"","ucode":"4A5BE9A5E877FA","user_header":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","comment_is_top":false,"comment_ctime":1576027138,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576027138","product_id":100039001,"comment_content":"我觉得里氏替换也采取了面向对象的多态特性，只是再多态的基础上多了几个约束条件，使函数变的有条不紊。","like_count":0},{"had_liked":false,"id":160725,"user_name":"PHP是世界上最好的需要","can_delete":false,"product_type":"c1","uid":1655326,"ip_address":"","ucode":"EE23A54B831D17","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIma3PJUyqDEQKt40nEh3Jt840af6hKnuK8k8dIscm43EUzJwLvynbxRnvO9Ivibv7KssUSqoBdY1w/132","comment_is_top":false,"comment_ctime":1576026114,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576026114","product_id":100039001,"comment_content":"我理解的  里氏替换强调的是“保留特征”，子类具体实现逻辑与父类可以截然不同，但是对父类而言子类却保留了基本的输入输出约定。对于多态，里氏替换会比较“守规则”而多态则比较“任性”。考虑到应用场景，里氏替换比较适合不同业务线里相同业务点，但是最终的产出是雷同的，只是输入数据和具体实现逻辑存在差异。不对的希望老师指正","like_count":0},{"had_liked":false,"id":160724,"user_name":"jaryoung","can_delete":false,"product_type":"c1","uid":1077406,"ip_address":"","ucode":"6E72D107DB7E51","user_header":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","comment_is_top":false,"comment_ctime":1576025892,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576025892","product_id":100039001,"comment_content":"优雅地扩展的作用，而不是瞎扩展。规约大于配置，顺从规约，一切美好。","like_count":0},{"had_liked":false,"id":160720,"user_name":"William","can_delete":false,"product_type":"c1","uid":1346215,"ip_address":"","ucode":"55F5D9DEE485B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","comment_is_top":false,"comment_ctime":1576025559,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576025559","product_id":100039001,"comment_content":"多态是特性，是面向对象的特性.<br><br>里氏替换是原则-父类出现的任何地方都可以用子类代替，而不影响功能和逻辑. 是定义子类编码的规范， 子类对于扩展父类的方法实现的时候 ，不能违背父类定义. <br><br>但是还是有点跟多态（重写方法）搞混...<br><br><br><br><br>","like_count":0,"discussions":[{"author":{"id":1701867,"avatar":"https://static001.geekbang.org/account/avatar/00/19/f7/eb/e7127bb8.jpg","nickname":"，","note":"","ucode":"A5543C8DFEB198","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349477,"discussion_content":"感谢各位，去年月薪涨了五千，今年涨了接近一万，不过感觉还没有达到极限，能力也得到了领导认可，已经不那么慌了","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1613227932,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1182146,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/c2/8c5442bf.jpg","nickname":"老庄道人","note":"","ucode":"C102EA323A69B4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345222,"discussion_content":"个人感觉每天学习2-3个小时就好，学多了反而有问题，比如身体吃不消，比如无法消化 等，学习也要讲科学呀~~另外个人感觉可以多读一些其他人文书，程序员也要混社会，提高自身的思想境界也是必须的\n我的情况跟您差不多，铁饭碗工作压力不大，但是总有技术恐慌感，然后每天坚持学习2-3小时，到现在大概5年了，感觉这样可以不耽误工作、不耽误生活\n另外建议管理预期，以我为例，想要学到世界顶尖是不现实的。想想自己为什么学习，是真的喜欢编程还是就是想要找到好的工作。每个人的能力是不同的，努力然后接受自己就好","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1611703581,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1147453,"avatar":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","nickname":"忆水寒","note":"","ucode":"E3F86BD8AA8903","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":221721,"discussion_content":"不盲目的学习，基础还是要打牢的。每天学习根据个人情况来，但是持之以恒最关键。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1586050887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015483,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","nickname":"程序员小跃","note":"","ucode":"25BB96E0791A60","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":223733,"discussion_content":"所以，需要经常锻炼，在工作期间，时不时的站起来活动下颈椎。技术提升，都是日积月累，厚积薄发的过程，加油加油。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586249668,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":222582,"discussion_content":"还怕猝死，这强度，你想多了。 每周锻炼3次。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586159264,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":6,"child_discussions":[{"author":{"id":1701867,"avatar":"https://static001.geekbang.org/account/avatar/00/19/f7/eb/e7127bb8.jpg","nickname":"，","note":"","ucode":"A5543C8DFEB198","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":227395,"discussion_content":"是真的，不骗你，情况确实是这样.不过也不是没有收获.我刚上班的时候每天坚持学习10个小时,运维的,后端的,用到什么学什么,实体书,腾讯课堂,网上的博客,看到什么学什么,持续了将近一年,所以在2000人的公司一年从外包转正,同时技术和对业务的理解,对项目环境的熟悉,正式工同事里基本找不到比我强的,可是我感觉付出的代价也不少,眼睛熬坏了,起初也就眼睛有点干,发展到后来盯一会电脑眼睛就涨疼,脑袋也涨疼,腰,背,颈椎更是难受的不行,然后我就辞职休息.旅游,按摩,玩一玩新出的游戏,以往上班光积累搬砖的技能了,现在有时间了就补补基础知识.休息了大概一个月,再出去面试,中级java这个段位基本没有我拿不到的offer了,最高的offer是20k,不过得大小周,而且入职时卡我学历,然后我挑了一家工作环境不错的单位,工资低不少,但胜在工作任务少,环境舒适,从不加班,领导,同事也都很好.由于每天并不忙,就开始补习基础,半年左右吧,光在极客时间这一个平台的学习时间至少要在200个钟头以上了,实体书,新出的深入理解java虚拟机第三版,我一个月看了两遍,连带着做笔记(https://www.processon.com/view/link/5e5e71dae4b08601cf46e3c2),之前我就在不下5个平台学习过jvm和并发编程的知识,所以这本书一看起来就停不下的感觉,项目有code review,又去撸了一遍代码整洁之道,项目中有用到c++的sdk,又撸了半本c++ primer,学visual studio怎么用,写代码,打包,部署都过了一遍,项目做起来也没问题了,可我就是停不下来的感觉,effective java买来开撸,看到在咱们专栏讲过的设计模式的内容又兴奋了,高性能mysql买来开撸,看到跟mysql实战45讲有关联的内容,看到以前卡了我两三天的主备配置,又兴奋的停不下来.收获就是慢慢的在这家公司,同职称的同事里,无论是搬砖技能还是知识积累,也都找不到对手了.令我难受的是,分明能感觉到身体已经很累了,脑子也基本不转了,可就是不知道该怎么缓解,每天下班的时候就根本睁不开眼,干涩肿胀,明明没什么工作任务,就是能把自己搞得很累.周末我会去奥森跑跑步,确实会有所好转,可是一到周一又那样了.我觉得我是心态问题导致了身体问题,我已经走火入魔了,我需要休息可我停不下来,我原定的目标是三年冲刺大厂,现在已经过去一年零7个月了,一想起这个我就感觉很难受,明明当初只是个愿景,慢慢地也不知为什么变成了必须做到的事,北漂两年我的价值观反而变得十分单一,所以我想知道大家是怎么想的,怎么做的,可以让我参考参考吗?","likes_number":20,"is_delete":false,"is_hidden":false,"ctime":1586488595,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":222582,"ip_address":""},"score":227395,"extra":""},{"author":{"id":1738326,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","nickname":"守拙","note":"","ucode":"F594B2DA3F6D4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1701867,"avatar":"https://static001.geekbang.org/account/avatar/00/19/f7/eb/e7127bb8.jpg","nickname":"，","note":"","ucode":"A5543C8DFEB198","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":285929,"discussion_content":"不知道你今年多大, 但你已经很猛了.\n别把自己弄的太累, 呆在舒适圈外恐慌圈内就好.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592990795,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":227395,"ip_address":""},"score":285929,"extra":""},{"author":{"id":1905357,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/12/cd/55e25527.jpg","nickname":"咕咕噜噜","note":"","ucode":"E9045BF11FAB7C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1701867,"avatar":"https://static001.geekbang.org/account/avatar/00/19/f7/eb/e7127bb8.jpg","nickname":"，","note":"","ucode":"A5543C8DFEB198","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":292429,"discussion_content":"老哥加个微信探讨探讨","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595222584,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":227395,"ip_address":""},"score":292429,"extra":""}]},{"author":{"id":1197455,"avatar":"https://static001.geekbang.org/account/avatar/00/12/45/8f/a56b2214.jpg","nickname":"innocent","note":"","ucode":"368659A0DDE7E4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289895,"discussion_content":"每天十个小时？你不用上班的么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594260484,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1701867,"avatar":"https://static001.geekbang.org/account/avatar/00/19/f7/eb/e7127bb8.jpg","nickname":"，","note":"","ucode":"A5543C8DFEB198","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1197455,"avatar":"https://static001.geekbang.org/account/avatar/00/12/45/8f/a56b2214.jpg","nickname":"innocent","note":"","ucode":"368659A0DDE7E4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292761,"discussion_content":"工作难度不高，也不重，很快就能完成，一周的活两三天就能做完，剩下时间可以自己利用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595322478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":289895,"ip_address":""},"score":292761,"extra":""}]}]},{"had_liked":false,"id":160718,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1576025540,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1576025540","product_id":100039001,"comment_content":"里氏替换的意义在于提供了在不改变原系统设计的前提下，提供了扩展原有软件系统功能的作用。以文中的例子为例，比如原系统退钱的功能（withdraw）并没有通知用户的功能，这时我们为了增加通知的功能，我们可以利用LSP原则扩展withdraw函数的功能，让其在成功退钱后发送通知出去。","like_count":0},{"had_liked":false,"id":160715,"user_name":"bearlu","can_delete":false,"product_type":"c1","uid":1030862,"ip_address":"","ucode":"14F260C8B24E27","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/ce/fd45714f.jpg","comment_is_top":false,"comment_ctime":1576025313,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576025313","product_id":100039001,"comment_content":"135学习设计模式，246学习数据结构与算法","like_count":0},{"had_liked":false,"id":160713,"user_name":"miracle","can_delete":false,"product_type":"c1","uid":1276137,"ip_address":"","ucode":"FD7074F1062AE9","user_header":"https://static001.geekbang.org/account/avatar/00/13/78/e9/9d807269.jpg","comment_is_top":false,"comment_ctime":1576025063,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576025063","product_id":100039001,"comment_content":"什么场景下需要用里式替换选择，这个跟子类扩展父类的功能好像是对立的？","like_count":0},{"had_liked":false,"id":160711,"user_name":"ghostfevil","can_delete":false,"product_type":"c1","uid":1184888,"ip_address":"","ucode":"E7355B2D81C4FE","user_header":"","comment_is_top":false,"comment_ctime":1576024696,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576024696","product_id":100039001,"comment_content":"个人觉得里氏替换原则的意义在于代码的复用性和可扩展性，里氏替换原则对父类的定义要求足够的通用性，这样子类继承和扩展就方便许多。","like_count":0},{"had_liked":false,"id":160706,"user_name":"deepz","can_delete":false,"product_type":"c1","uid":1570088,"ip_address":"","ucode":"4BD23A44CDB384","user_header":"https://static001.geekbang.org/account/avatar/00/17/f5/28/898a6947.jpg","comment_is_top":false,"comment_ctime":1576024307,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576024307","product_id":100039001,"comment_content":"没明白这样的话，用子类替换的意义。。意思是所有子类功能都一样是吗🤔 还是说继承下来了重写的方法必须按照父类约定的“协议”来，然后子类自己定义的方法用来表示子类与子类间的不同。🤔    就没太明白用多态来实现里氏替换，那多态的意义就。。额。。回头再看看文章回味下🙄","like_count":0},{"had_liked":false,"id":160693,"user_name":"teddytyy","can_delete":false,"product_type":"c1","uid":1268738,"ip_address":"","ucode":"E1569D81A4154E","user_header":"https://static001.geekbang.org/account/avatar/00/13/5c/02/e7af1750.jpg","comment_is_top":false,"comment_ctime":1576022933,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576022933","product_id":100039001,"comment_content":"子类中有方法不是重载自父类的方法是不是就不符合里式替换了？","like_count":0},{"had_liked":false,"id":160683,"user_name":"阿卡牛","can_delete":false,"product_type":"c1","uid":1022247,"ip_address":"","ucode":"0BC43A904C3199","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","comment_is_top":false,"comment_ctime":1576020733,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576020733","product_id":100039001,"comment_content":"个人觉得主要为了扩展性","like_count":0},{"had_liked":false,"id":160682,"user_name":"业余爱好者","can_delete":false,"product_type":"c1","uid":1482915,"ip_address":"","ucode":"A890935A982988","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","comment_is_top":false,"comment_ctime":1576020689,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576020689","product_id":100039001,"comment_content":"多态是语法层面的，里式替换是业务层面的。我的理解是，多态是里式替换的子集，是里式替换实现的手段。<br><br>父类或接口是一种协议，子类实现必须严格遵守协议实现，这样才能在父类出现的任何的地方用子类任意替换。客户端的使用只需关注父类提供的协议所述的功能。这是面向接口编程的思想。要实现这一目标，子类必须严格按照父类的协议实现。而实现手段是编程语言语法上的多态。","like_count":0},{"had_liked":false,"id":160676,"user_name":"与雨日肇事的爱","can_delete":false,"product_type":"c1","uid":1288032,"ip_address":"","ucode":"A3B88A1F4AF2D5","user_header":"https://static001.geekbang.org/account/avatar/00/13/a7/60/f175d953.jpg","comment_is_top":false,"comment_ctime":1576018657,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576018657","product_id":100039001,"comment_content":"Number 1.打卡","like_count":0}]}