{"id":79159,"title":"52 | 算法实战（一）：剖析Redis常用数据类型对应的数据结构","content":"<p>到此为止，专栏前三部分我们全部讲完了。从今天开始，我们就正式进入实战篇的部分。这部分我主要通过一些开源项目、经典系统，真枪实弹地教你，如何将数据结构和算法应用到项目中。所以这部分的内容，更多的是知识点的回顾，相对于基础篇、高级篇的内容，其实这部分会更加容易看懂。</p><p>不过，我希望你不要只是看懂就完了。你要多举一反三地思考，自己接触过的开源项目、基础框架、中间件中，都用过哪些数据结构和算法。你也可以想一想，在自己做的项目中，有哪些可以用学过的数据结构和算法进一步优化。这样的学习效果才会更好。</p><p>好了，今天我就带你一块儿看下，<strong><span class=\"orange\">经典数据库Redis中的常用数据类型，底层都是用哪种数据结构实现的？</span></strong></p><h2>Redis数据库介绍</h2><p>Redis是一种键值（Key-Value）数据库。相对于关系型数据库（比如MySQL），Redis也被叫作<strong>非关系型数据库</strong>。</p><p>像MySQL这样的关系型数据库，表的结构比较复杂，会包含很多字段，可以通过SQL语句，来实现非常复杂的查询需求。而Redis中只包含“键”和“值”两部分，只能通过“键”来查询“值”。正是因为这样简单的存储结构，也让Redis的读写效率非常高。</p><p>除此之外，Redis主要是作为内存数据库来使用，也就是说，数据是存储在内存中的。尽管它经常被用作内存数据库，但是，它也支持将数据存储在硬盘中。这一点，我们后面会介绍。</p><!-- [[[read_end]]] --><p>Redis中，键的数据类型是字符串，但是为了丰富数据存储的方式，方便开发者使用，值的数据类型有很多，常用的数据类型有这样几种，它们分别是字符串、列表、字典、集合、有序集合。</p><p>“字符串（string）”这种数据类型非常简单，对应到数据结构里，就是<strong>字符串</strong>。你应该非常熟悉，这里我就不多介绍了。我们着重看下，其他四种比较复杂点的数据类型，看看它们底层都依赖了哪些数据结构。</p><h2>列表（list）</h2><p>我们先来看列表。列表这种数据类型支持存储一组数据。这种数据类型对应两种实现方法，一种是<strong>压缩列表</strong>（ziplist），另一种是双向循环链表。</p><p>当列表中存储的数据量比较小的时候，列表就可以采用压缩列表的方式实现。具体需要同时满足下面两个条件：</p><ul>\n<li>\n<p>列表中保存的单个数据（有可能是字符串类型的）小于64字节；</p>\n</li>\n<li>\n<p>列表中数据个数少于512个。</p>\n</li>\n</ul><p>关于压缩列表，我这里稍微解释一下。它并不是基础数据结构，而是Redis自己设计的一种数据存储结构。它有点儿类似数组，通过一片连续的内存空间，来存储数据。不过，它跟数组不同的一点是，它允许存储的数据大小不同。具体的存储结构也非常简单，你可以看我下面画的这幅图。</p><p><img src=\"https://static001.geekbang.org/resource/image/49/b5/49fd8d46eb94f463ace98717f11c2cb5.jpg?wh=1142*381\" alt=\"\"></p><p>现在，我们来看看，压缩列表中的“压缩”两个字该如何理解？</p><p>听到“压缩”两个字，直观的反应就是节省内存。之所以说这种存储结构节省内存，是相较于数组的存储思路而言的。我们知道，数组要求每个元素的大小相同，如果我们要存储不同长度的字符串，那我们就需要用最大长度的字符串大小作为元素的大小（假设是20个字节）。那当我们存储小于20个字节长度的字符串的时候，便会浪费部分存储空间。听起来有点儿拗口，我画个图解释一下。</p><p><img src=\"https://static001.geekbang.org/resource/image/2e/69/2e2f2e5a2fe25d26dc2fc04cfe88f869.jpg?wh=1142*415\" alt=\"\"></p><p>压缩列表这种存储结构，一方面比较节省内存，另一方面可以支持不同类型数据的存储。而且，因为数据存储在一片连续的内存空间，通过键来获取值为列表类型的数据，读取的效率也非常高。</p><p>当列表中存储的数据量比较大的时候，也就是不能同时满足刚刚讲的两个条件的时候，列表就要通过双向循环链表来实现了。</p><p>在<a href=\"https://time.geekbang.org/column/article/41013\">链表</a>里，我们已经讲过双向循环链表这种数据结构了，如果不记得了，你可以先回去复习一下。这里我们着重看一下Redis中双向链表的编码实现方式。</p><p>Redis的这种双向链表的实现方式，非常值得借鉴。它额外定义一个list结构体，来组织链表的首、尾指针，还有长度等信息。这样，在使用的时候就会非常方便。</p><pre><code>// 以下是C语言代码，因为Redis是用C语言实现的。\ntypedef struct listnode {\n  struct listNode *prev;\n  struct listNode *next;\n  void *value;\n} listNode;\n\n\ntypedef struct list {\n  listNode *head;\n  listNode *tail;\n  unsigned long len;\n  // ....省略其他定义\n} list;\n</code></pre><h2>字典（hash）</h2><p>字典类型用来存储一组数据对。每个数据对又包含键值两部分。字典类型也有两种实现方式。一种是我们刚刚讲到的<strong>压缩列表</strong>，另一种是<strong>散列表</strong>。</p><p>同样，只有当存储的数据量比较小的情况下，Redis才使用压缩列表来实现字典类型。具体需要满足两个条件：</p><ul>\n<li>\n<p>字典中保存的键和值的大小都要小于64字节；</p>\n</li>\n<li>\n<p>字典中键值对的个数要小于512个。</p>\n</li>\n</ul><p>当不能同时满足上面两个条件的时候，Redis就使用散列表来实现字典类型。Redis使用<a href=\"https://zh.wikipedia.org/wiki/Murmur%E5%93%88%E5%B8%8C\">MurmurHash2</a>这种运行速度快、随机性好的哈希算法作为哈希函数。对于哈希冲突问题，Redis使用链表法来解决。除此之外，Redis还支持散列表的动态扩容、缩容。</p><p>当数据动态增加之后，散列表的装载因子会不停地变大。为了避免散列表性能的下降，当装载因子大于1的时候，Redis会触发扩容，将散列表扩大为原来大小的2倍左右（具体值需要计算才能得到，如果感兴趣，你可以去阅读<a href=\"https://github.com/antirez/redis/blob/unstable/src/dict.c\">源码</a>）。</p><p>当数据动态减少之后，为了节省内存，当装载因子小于0.1的时候，Redis就会触发缩容，缩小为字典中数据个数的大约2倍大小（这个值也是计算得到的，如果感兴趣，你也可以去阅读<a href=\"https://github.com/antirez/redis/blob/unstable/src/dict.c\">源码</a>）。</p><p>我们前面讲过，扩容缩容要做大量的数据搬移和哈希值的重新计算，所以比较耗时。针对这个问题，Redis使用我们在<a href=\"https://time.geekbang.org/column/article/64586\">散列表（中）</a>讲的渐进式扩容缩容策略，将数据的搬移分批进行，避免了大量数据一次性搬移导致的服务停顿。</p><h2>集合（set）</h2><p>集合这种数据类型用来存储一组不重复的数据。这种数据类型也有两种实现方法，一种是基于有序数组，另一种是基于散列表。</p><p>当要存储的数据，同时满足下面这样两个条件的时候，Redis就采用有序数组，来实现集合这种数据类型。</p><ul>\n<li>\n<p>存储的数据都是整数；</p>\n</li>\n<li>\n<p>存储的数据元素个数不超过512个。</p>\n</li>\n</ul><p>当不能同时满足这两个条件的时候，Redis就使用散列表来存储集合中的数据。</p><h2>有序集合（sortedset）</h2><p>有序集合这种数据类型，我们在<a href=\"https://time.geekbang.org/column/article/42896\">跳表</a>里已经详细讲过了。它用来存储一组数据，并且每个数据会附带一个得分。通过得分的大小，我们将数据组织成跳表这样的数据结构，以支持快速地按照得分值、得分区间获取数据。</p><p>实际上，跟Redis的其他数据类型一样，有序集合也并不仅仅只有跳表这一种实现方式。当数据量比较小的时候，Redis会用压缩列表来实现有序集合。具体点说就是，使用压缩列表来实现有序集合的前提，有这样两个：</p><ul>\n<li>\n<p>所有数据的大小都要小于64字节；</p>\n</li>\n<li>\n<p>元素个数要小于128个。</p>\n</li>\n</ul><h2>数据结构持久化</h2><p>尽管Redis经常会被用作内存数据库，但是，它也支持数据落盘，也就是将内存中的数据存储到硬盘中。这样，当机器断电的时候，存储在Redis中的数据也不会丢失。在机器重新启动之后，Redis只需要再将存储在硬盘中的数据，重新读取到内存，就可以继续工作了。</p><p>刚刚我们讲到，Redis的数据格式由“键”和“值”两部分组成。而“值”又支持很多数据类型，比如字符串、列表、字典、集合、有序集合。像字典、集合等类型，底层用到了散列表，散列表中有指针的概念，而指针指向的是内存中的存储地址。 那Redis是如何将这样一个跟具体内存地址有关的数据结构存储到磁盘中的呢？</p><p>实际上，Redis遇到的这个问题并不特殊，很多场景中都会遇到。我们把它叫作<strong>数据结构的持久化问题</strong>，或者<strong>对象的持久化问题</strong>。这里的“持久化”，你可以笼统地理解为“存储到磁盘”。</p><p>如何将数据结构持久化到硬盘？我们主要有两种解决思路。</p><p>第一种是清除原有的存储结构，只将数据存储到磁盘中。当我们需要从磁盘还原数据到内存的时候，再重新将数据组织成原来的数据结构。实际上，Redis采用的就是这种持久化思路。</p><p>不过，这种方式也有一定的弊端。那就是数据从硬盘还原到内存的过程，会耗用比较多的时间。比如，我们现在要将散列表中的数据存储到磁盘。当我们从磁盘中，取出数据重新构建散列表的时候，需要重新计算每个数据的哈希值。如果磁盘中存储的是几GB的数据，那重构数据结构的耗时就不可忽视了。</p><p>第二种方式是保留原来的存储格式，将数据按照原有的格式存储在磁盘中。我们拿散列表这样的数据结构来举例。我们可以将散列表的大小、每个数据被散列到的槽的编号等信息，都保存在磁盘中。有了这些信息，我们从磁盘中将数据还原到内存中的时候，就可以避免重新计算哈希值。</p><h2>总结引申</h2><p>今天，我们学习了Redis中常用数据类型底层依赖的数据结构，总结一下大概有这五种：<strong>压缩列表</strong>（可以看作一种特殊的数组）、<strong>有序数组</strong>、<strong>链表</strong>、<strong>散列表</strong>、<strong>跳表</strong>。实际上，Redis就是这些常用数据结构的封装。</p><p>你有没有发现，有了数据结构和算法的基础之后，再去阅读Redis的源码，理解起来就容易多了？很多原来觉得很深奥的设计思想，是不是就都会觉得顺理成章了呢？</p><p>还是那句话，夯实基础很重要。同样是看源码，有些人只能看个热闹，了解一些皮毛，无法形成自己的知识结构，不能化为己用，过不几天就忘了。而有些人基础很好，不但能知其然，还能知其所以然，从而真正理解作者设计的动机。这样不但能有助于我们理解所用的开源软件，还能为我们自己创新添砖加瓦。</p><h2>课后思考</h2><ol>\n<li>\n<p>你有没有发现，在数据量比较小的情况下，Redis中的很多数据类型，比如字典、有序集合等，都是通过多种数据结构来实现的，为什么会这样设计呢？用一种固定的数据结构来实现，不是更加简单吗？</p>\n</li>\n<li>\n<p>我们讲到数据结构持久化有两种方法。对于二叉查找树这种数据结构，我们如何将它持久化到磁盘中呢？</p>\n</li>\n</ol><p>欢迎留言和我分享，也欢迎点击“<span class=\"orange\">请朋友读</span>”，把今天的内容分享给你的好友，和他一起讨论、学习。</p>","comments":[{"had_liked":false,"id":63508,"user_name":"在路上","can_delete":false,"product_type":"c1","uid":1205712,"ip_address":"","ucode":"18337C6DD5E618","user_header":"https://static001.geekbang.org/account/avatar/00/12/65/d0/b5b00bc2.jpg","comment_is_top":false,"comment_ctime":1548386952,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"658678383240","product_id":100017301,"comment_content":"思考题1：redis的数据结构由多种数据结构来实现，主要是出于时间和空间的考虑，当数据量小的时候通过数组下标访问最快、占用内存最小，而压缩列表只是数组的升级版；<br>因为数组需要占用连续的内存空间，所以当数据量大的时候，就需要使用链表了，同时为了保证速度又需要和数组结合，也就有了散列表。<br>对于数据的大小和多少采用哪种数据结构，相信redis团队一定是根据大多数的开发场景而定的。<br><br>思考题2：二叉查找树的存储，我倾向于存储方式一，通过填充叶子节点形成完全二叉树，然后以数组的形式存储到硬盘，数据还原过程也是非常高效的。如果用存储方式二就比较复杂了。","like_count":154,"discussions":[{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332942,"discussion_content":"压缩链表，不支持随机访问。只是节省了内存空间。故，访问速度怎么快了？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1607399329,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339480,"discussion_content":"压缩列表因为是连续内存空间，所以可以使用cpu的缓存。","likes_number":12,"is_delete":false,"is_hidden":false,"ctime":1609685268,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":332942,"ip_address":""},"score":339480,"extra":""}]}]},{"had_liked":false,"id":63532,"user_name":"郑晨Cc","can_delete":false,"product_type":"c1","uid":1324942,"ip_address":"","ucode":"57146E444D6329","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/8e/cf0b4575.jpg","comment_is_top":false,"comment_ctime":1548393933,"is_pvip":false,"replies":[{"id":"22468","content":"哈哈，你说的没错。压缩列表不支持随机访问。有点类似链表。但是比较省存储空间啊。Redis一般都是通过key获取整个value的值，也就是整个压缩列表的数据，并不需要随机访问。","user_name":"作者回复","comment_id":63532,"uid":"1190123","ip_address":"","utype":1,"ctime":1548403870,"user_name_real":"gg"}],"discussion_count":13,"race_medal":0,"score":"456814927309","product_id":100017301,"comment_content":"老师 关于redis的压缩列表有个地方不太明白<br>虽然压缩列表看起来想数组 但他能像数组一样支持按照下标进行直接随机访问吗？比如我要访问下标为n的数据我启不是需要知道之前从0到n-1的所有数据的长度才能找到n，那这跟链表的时间复杂读没啥区别啊，而且还占用了连续的内存空间？ 还是说压缩列表中的每个元素的长度都记录在它的头部可以一次性的获取？","like_count":107,"discussions":[{"author":{"id":1347348,"avatar":"https://static001.geekbang.org/account/avatar/00/14/8f/14/d5498b47.jpg","nickname":"过客","note":"","ucode":"22FDEBFD565620","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220783,"discussion_content":"很多网络协议也是使用压缩列表组装报文的","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1585924413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437622,"discussion_content":"哈哈，你说的没错。压缩列表不支持随机访问。有点类似链表。但是比较省存储空间啊。Redis一般都是通过key获取整个value的值，也就是整个压缩列表的数据，并不需要随机访问。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1548403870,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2449060,"avatar":"https://static001.geekbang.org/account/avatar/00/25/5e/a4/d48b8298.jpg","nickname":"Geek_sz","note":"","ucode":"72E86D7D6554CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":575592,"discussion_content":"压缩列表你说类似数组又说类似链表，这个可以多讲一点，很多人看完还是蒙的，它又怎么能实现hash字典的？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1654944024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":437622,"ip_address":""},"score":575592,"extra":""}]},{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341594,"discussion_content":"不支持随机访问，因为数组的寻址公式：a[i]_address =base_address + i * data_type_size。data_type_size 表示数组中每个元素的大小。但此时压缩列表每个位置的data_type_size不一定相等，所以无法支持随机访问。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1610459126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1939316,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/97/74/a933d664.jpg","nickname":"莜戏","note":"","ucode":"C3488A2BB44359","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346221,"discussion_content":"根据Key取Value(整个压缩列表数据)，不必随机取Value中的某个字段","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1611888997,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018620,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/fc/d1dd57dd.jpg","nickname":"ipofss","note":"","ucode":"DE3061C9259F9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287927,"discussion_content":"我也有同样的疑问，不过又细想一下，人家有前提条件，就是每个数据比较小，并且数据的个数比较少，这样的话，那样的顺序遍历，而不是随机访问，牺牲的性能几乎可以忽略了。还请指教","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1593590930,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1018620,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/fc/d1dd57dd.jpg","nickname":"ipofss","note":"","ucode":"DE3061C9259F9E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332943,"discussion_content":"我的感觉是，既然数据小，为啥不直接用数组，这样可以随机存储。相反数据量大，才需要这么压缩内存空间。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1607399580,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":287927,"ip_address":""},"score":332943,"extra":""},{"author":{"id":1939316,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/97/74/a933d664.jpg","nickname":"莜戏","note":"","ucode":"C3488A2BB44359","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":354839,"discussion_content":"这只是一条数据，如果有很多条小数据，空间节省就很可观了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1615348422,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":332943,"ip_address":""},"score":354839,"extra":""},{"author":{"id":1647092,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Ojib9WKYcoLTeWHRgkyCcbjsPNfqicib8cJicJjAor8jaUKUZIWSppWr8PqFr9bp8ic6cfqLlrFm9sDZFZHj3Lylw4w/132","nickname":"土地规划与管理","note":"","ucode":"39E15226880C64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1939316,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/97/74/a933d664.jpg","nickname":"莜戏","note":"","ucode":"C3488A2BB44359","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":359433,"discussion_content":"毕竟是内存数据库，相比节省时间，可能更倾向于节省空间吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1616200894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":354839,"ip_address":""},"score":359433,"extra":""}]},{"author":{"id":1107786,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e7/4a/4dfb565a.jpg","nickname":"凌霄","note":"","ucode":"19C4BFB0298276","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383113,"discussion_content":"底层实现就是链表吧，我觉得这个一定要让大家知道，类似数组，可实际上是链表。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625908018,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2249227,"avatar":"https://static001.geekbang.org/account/avatar/00/22/52/0b/50bf0f05.jpg","nickname":"橙子橙","note":"","ucode":"CD51367A14D955","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325693,"discussion_content":"为什么不需要随机访问? 如果需要获取hash中特定key的值, hget 是先把压缩列表整个取出来, 然后顺序遍历到特定的key?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605408261,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1186807,"avatar":"https://static001.geekbang.org/account/avatar/00/12/1b/f7/45e8b64a.jpg","nickname":"Fire","note":"","ucode":"4A2C50B77EDB2C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311850,"discussion_content":"好问题啊！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602505722,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1928441,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/cfNtHoAbHvia1O0jIopiafYbnppEPiawgicKa8vdI2FxMMEdqORB4VLzkYTuGJGA7HibustnU0hDTOD7YSDAWuxhmrg/132","nickname":"Geek_299a34","note":"","ucode":"79AECE06F08E87","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295612,"discussion_content":"看一下寻址公式就知道为什么不支持随机访问了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596262587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":65199,"user_name":"李靖峰","can_delete":false,"product_type":"c1","uid":1139247,"ip_address":"","ucode":"AA4DE3E91A1FFA","user_header":"https://static001.geekbang.org/account/avatar/00/11/62/2f/6fe8ee9e.jpg","comment_is_top":false,"comment_ctime":1549101821,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"220592433917","product_id":100017301,"comment_content":"数据量小时采用连续内存的数据结构是为了CPU缓存读取连续内存来提高命中率，而限制数据数量和数据大小应该是考虑到CPU缓存的大小","like_count":51,"discussions":[{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332945,"discussion_content":"你这理由不错。那上数组，不用压缩列表。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607399654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341595,"discussion_content":"压缩列表内存也是连续的呀，而且相比数组会节省内存，数组的优势是啥呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610459270,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":332945,"ip_address":""},"score":341595,"extra":""}]}]},{"had_liked":false,"id":65485,"user_name":"青铜5 周群力","can_delete":false,"product_type":"c1","uid":1111965,"ip_address":"","ucode":"EA80B442EC8A68","user_header":"https://static001.geekbang.org/account/avatar/00/10/f7/9d/c7295d17.jpg","comment_is_top":false,"comment_ctime":1549413154,"is_pvip":false,"replies":[{"id":"24296","content":"是的，有这么个好处。越小越有利于CPU缓存。","user_name":"作者回复","comment_id":65485,"uid":"1190123","ip_address":"","utype":1,"ctime":1550542715,"user_name_real":"gg"}],"discussion_count":4,"race_medal":0,"score":"156168235810","product_id":100017301,"comment_content":"我猜压缩列表的好处是能利用l2缓存?","like_count":36,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438467,"discussion_content":"是的，有这么个好处。越小越有利于CPU缓存。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550542715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2839430,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/gcOIudbznzT7xENLxS7KSTMoun0vs7eicv3vFhWs6j1uIDnGfk1pot8VrM4EthbOmxyu5HVu8NKakkM76zveasQ/132","nickname":"balance zhu","note":"","ucode":"E0114D91B81E11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":534287,"discussion_content":"也不一定越小约有利吧，多个数据共享同一个cache line，可能导致 false sharing","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638155079,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":438467,"ip_address":""},"score":534287,"extra":""}]},{"author":{"id":1372609,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f1/c1/f9bfcd08.jpg","nickname":"DonaldCen","note":"","ucode":"5DA0A28613E9AD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413967,"discussion_content":"压缩列表能利用l2缓存？这个怎么理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636622589,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2839430,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/gcOIudbznzT7xENLxS7KSTMoun0vs7eicv3vFhWs6j1uIDnGfk1pot8VrM4EthbOmxyu5HVu8NKakkM76zveasQ/132","nickname":"balance zhu","note":"","ucode":"E0114D91B81E11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1372609,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f1/c1/f9bfcd08.jpg","nickname":"DonaldCen","note":"","ucode":"5DA0A28613E9AD","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":534286,"discussion_content":"cache line 大小是 64 byte ，与压缩列表单个数据大小上限相同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638154985,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":413967,"ip_address":""},"score":534286,"extra":""}]}]},{"had_liked":false,"id":84446,"user_name":"来碗绿豆汤","can_delete":false,"product_type":"c1","uid":1070051,"ip_address":"","ucode":"B0AB63B8D9729F","user_header":"https://static001.geekbang.org/account/avatar/00/10/53/e3/39dcfb11.jpg","comment_is_top":false,"comment_ctime":1554864437,"is_pvip":false,"replies":[{"id":"30474","content":"是的 没错","user_name":"作者回复","comment_id":84446,"uid":"1190123","ip_address":"","utype":1,"ctime":1554939258,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"151878719797","product_id":100017301,"comment_content":"压缩列表每个元素所占用的空间大小是不一定的，所以当想要随机访问某个元素的时候还是要像列表那样从头开始遍历，所以不能太大。理解对吗？","like_count":35,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446365,"discussion_content":"是的 没错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554939258,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1796438,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/zlWt0lPDicdib5BTUbuwA3wLLUuejtZ5icGu3DHMBPd6PicXOdhZ3zYFts8VkXjjyQuxzUJas2w5OTmx3icWKiaZM1Vg/132","nickname":"youyou.L","note":"","ucode":"B3DB0D0700EEAC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326450,"discussion_content":"有点像网络协议的报头","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605597666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176722,"user_name":"注定非凡","can_delete":false,"product_type":"c1","uid":1113597,"ip_address":"","ucode":"80673056E131B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","comment_is_top":false,"comment_ctime":1581150184,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"113250299880","product_id":100017301,"comment_content":"Redis 数据库介绍<br>\t Redis 中，键的数据类型是字符串，但是值的数据类型有很多，常用的数据类型是：字符串、列表、字典、集合、有序集合<br><br>列表（list）<br>1，列表这种数据类型支持存储一组数据<br>2，两种实现方法：（1）压缩列表（ziplist）（2）双向循环链表<br>\t* 当列表中存储的数据量比较小时，可以采用压缩列表的方式实现。<br>\t* 具体需要同时满足下面两个条件：<br>（1）列表中保存的单个数据（可能是字符串类型的）小于 64 字节；<br>（2）列表中数据个数少于 512 个<br><br>3，关于压缩列表<br>\t* 它并不是基础数据结构，而是 Redis 自己设计的一种数据存储结构<br>\t* 类似数组，通过一片连续的内存空间来存储数据<br>\t* 跟数组不同的是它允许存储的数据大小不同<br><br>4，压缩列表中的“压缩”如何理解？<br>\t* “压缩”：就是节省内存，之所以说节省内存，是相较于数组的存储思路而言的。数组要求每个元素的大小相同，如果要存储不同长度的字符串，就需要用最大长度的字符串大小作为元素的大小。但压缩数组允许不同的存储空间。<br><br>\t* 压缩列表这种存储结构，另一方面可以支持不同类型数据的存储<br>\t* 数据存储在一片连续的内存空间，通过键来获取值为列表类型的数据，读取的效率也非常高。<br><br>5，不能同时满足压缩列表的两个条件时，列表就要通过双向循环链表来实现<br><br>字典（hash）<br>1，字典类型用来存储一组数据对。<br>2，每个数据对又包含键值两部分，也有两种实现方式：（1）压缩列表（2）散列表<br>3，同样，只有当存储的数据量比较小的情况下，Redis 才使用压缩列表来实现字典类型。具体需要满足两个条件：<br><br>（1）字典中保存的键和值的大小都要小于 64 字节<br>（2）字典中键值对的个数要小于 512 个<br><br>4，当不能同时满足上面两个条件的时候，Redis 就使用散列表来实现字典类型<br>\t* Redis 使用MurmurHash2这种运行速度快、随机性好的哈希算法作为哈希函数<br>\t* 对于哈希冲突问题，Redis 使用链表法来解决<br>\t* 除此之外，Redis 还支持散列表的动态扩容、缩容。<br><br>当数据动态增加，装载因子会不停地变大。为了避免散列表性能的下降，当装载因子大于 1 的时候，Redis 会触发扩容，将散列表扩大为原来大小的 2 倍左右（具体值需要计算才能得到）。<br><br>当数据动态减少之后，为了节省内存，当装载因子小于 0.1 的时候，Redis 就会触发缩容，缩小为字典中数据个数的大约 2 倍大小（这个值也是计算得到的）<br><br>扩容缩容要做大量的数据搬移和哈希值的重新计算，比较耗时。针对这个问题，Redis 使用渐进式扩容缩容策略：将数据的搬移分批进行，避免了大量数据一次性搬移导致的服务停顿。<br><br>集合（set）<br>1，集合这种数据类型用来存储一组不重复的数据<br>2，这种数据类型也有两种实现方法：（1）有序数组（2）散列表<br>3，Redis 若采用有序数组，要同时满足下面这样两个条件：<br><br>（1）存储的数据都是整数；<br>（2）存储的数据元素个数不超过 512 个。<br>当不能同时满足这两个条件的时候，Redis 就使用散列表来存储集合中的数据。<br>有序集合（sortedset）<br>1，它用来存储一组数据，并且每个数据会附带一个得分。通过得分的大小，将数据组织成跳表这样的数据结构，以支持快速地按照得分值、得分区间获取数据。<br>2，当数据量比较小的时候，Redis 可用压缩列表来实现有序集合。使用的前提有两个：<br><br>（1）所有数据的大小都要小于 64 字节；<br>（2）元素个数要小于 128 个<br>数据结构持久化<br>1，尽管 Redis 经常会被用作内存数据库，但它也支持将内存中的数据存储到硬盘中。当机器断电的时，存储在 Redis 中的数据不会丢失<br><br>Redis 的数据格式由“键”和“值”两部分组成。而“值”又支持很多数据类型，像字典、集合等类型，底层用到了散列表，散列表中有指针的概念，而指针指向的是内存中的存储地址。<br><br>Redis 是如何将一个跟具体内存地址有关的数据结构存储到磁盘中的？<br>1，Redis 遇到的这个问题被称为数据结构的持久化问题，或者对象的持久化问题<br>2，将数据结构持久化到硬盘主要有两种解决思路：<br>\t* 第一种是清除原有的存储结构，只将数据存储到磁盘中。<br>\t\t（1）当需要从磁盘还原数据到内存时，再重新将数据组织成原来的数据结构。Redis 采用的就是这种持久化思路。<br>\t\t（2） 这种方式有一定的弊端：数据从硬盘还原到内存的过程，会耗用比较多的时间<br>\t\t<br>\t* 第二种方式是保留原来的存储格式，将数据按照原有的格式存储在磁盘中","like_count":26},{"had_liked":false,"id":63431,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1548371108,"is_pvip":false,"replies":[{"id":"22461","content":"看来是没少刷专栏😄","user_name":"编辑回复","comment_id":63431,"uid":"1058895","ip_address":"","utype":2,"ctime":1548392650,"user_name_real":"王锦"}],"discussion_count":2,"race_medal":0,"score":"65972880548","product_id":100017301,"comment_content":"发现一个功能：左滑进入上一篇，右滑进入下一篇","like_count":15,"discussions":[{"author":{"id":1058895,"avatar":"https://static001.geekbang.org/account/avatar/00/10/28/4f/48e48553.jpg","nickname":"@阿锦啊","note":"","ucode":"3C5F00333D7174","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437584,"discussion_content":"看来是没少刷专栏😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548392650,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1077406,"avatar":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","nickname":"jaryoung","note":"","ucode":"6E72D107DB7E51","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":19929,"discussion_content":"现在好像没有这个功能了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569238796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":63590,"user_name":"田伟 คิดถึง","can_delete":false,"product_type":"c1","uid":1280941,"ip_address":"","ucode":"401C8EB3748A34","user_header":"https://static001.geekbang.org/account/avatar/00/13/8b/ad/6325c4c4.jpg","comment_is_top":false,"comment_ctime":1548409829,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"61677951973","product_id":100017301,"comment_content":"看完前边的课程，当知识点连成线和面之后，才发现原来是这么回事，再来看redis确认是豁然开朗。知识成体系之后记忆会更深刻，不过也带来了更多的思考和发现-----知识边界扩大了","like_count":14},{"had_liked":false,"id":137680,"user_name":"复兴","can_delete":false,"product_type":"c1","uid":1363230,"ip_address":"","ucode":"C172A87873001A","user_header":"https://static001.geekbang.org/account/avatar/00/14/cd/1e/692c3313.jpg","comment_is_top":false,"comment_ctime":1569821613,"is_pvip":false,"replies":[{"id":"53635","content":"是的，你理解的没错","user_name":"作者回复","comment_id":137680,"uid":"1190123","ip_address":"","utype":1,"ctime":1570582839,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"44519494573","product_id":100017301,"comment_content":"值是字符串类型，老师一笔带过了，其实我想知道的是，值为字符串的键值对，是不是通过hash实现的，将键转换成index存储在hash表中。","like_count":10,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469207,"discussion_content":"是的，你理解的没错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570582839,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1928441,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/cfNtHoAbHvia1O0jIopiafYbnppEPiawgicKa8vdI2FxMMEdqORB4VLzkYTuGJGA7HibustnU0hDTOD7YSDAWuxhmrg/132","nickname":"Geek_299a34","note":"","ucode":"79AECE06F08E87","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304628,"discussion_content":"String类型，底层是简单动态字符串","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599630626,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":63740,"user_name":"目","can_delete":false,"product_type":"c1","uid":1103603,"ip_address":"","ucode":"F55B94023D2331","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/f3/601f5f29.jpg","comment_is_top":false,"comment_ctime":1548482476,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"44498155436","product_id":100017301,"comment_content":"问题1:            压缩列表优点：访问存取快速，节省内存。但是受到操作系统空闲内存限制。越大的连续内存空间越不容易申请到。所以用了其他数据结构比如链表替代。","like_count":10},{"had_liked":false,"id":70628,"user_name":"Twogou27","can_delete":false,"product_type":"c1","uid":1246802,"ip_address":"","ucode":"9EDE93F195BF22","user_header":"https://static001.geekbang.org/account/avatar/00/13/06/52/3ad97645.jpg","comment_is_top":false,"comment_ctime":1551149686,"is_pvip":false,"replies":[{"id":"25402","content":"就是拉了很长的链表","user_name":"作者回复","comment_id":70628,"uid":"1190123","ip_address":"","utype":1,"ctime":1551232562,"user_name_real":"gg"}],"discussion_count":3,"race_medal":0,"score":"31615920758","product_id":100017301,"comment_content":"老师，Redis字典数据类型中散列表的装载因子最大不就是1么，大于1是什么情况？","like_count":7,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440738,"discussion_content":"就是拉了很长的链表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551232562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":96516,"discussion_content":"即 存在 hash冲突的情况，","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1577070634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1082785,"avatar":"https://static001.geekbang.org/account/avatar/00/10/85/a1/2442332c.jpg","nickname":"郭俊杰","note":"","ucode":"D328E5738A4413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":249961,"discussion_content":"把冲突上挂的链表也算上了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587979292,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122013,"user_name":"铁匠","can_delete":false,"product_type":"c1","uid":1088309,"ip_address":"","ucode":"D403835F5DB8F7","user_header":"https://static001.geekbang.org/account/avatar/00/10/9b/35/79e42357.jpg","comment_is_top":false,"comment_ctime":1565268746,"is_pvip":false,"replies":[{"id":"44833","content":"跳表更灵活 更容易实现","user_name":"作者回复","comment_id":122013,"uid":"1190123","ip_address":"","utype":1,"ctime":1565304191,"user_name_real":"王争"}],"discussion_count":3,"race_medal":0,"score":"23040105226","product_id":100017301,"comment_content":"跳表和B+数既然大部分场景下可以互换，为什么redis没有使用B+树而选择跳表？","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462057,"discussion_content":"跳表更灵活 更容易实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565304191,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1082785,"avatar":"https://static001.geekbang.org/account/avatar/00/10/85/a1/2442332c.jpg","nickname":"郭俊杰","note":"","ucode":"D328E5738A4413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":249962,"discussion_content":"还有一点，redis作者想跟mysql底层也不一样。有二远一的可能，就用另一种，我问过他，哈哈","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1587979403,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2139807,"avatar":"https://static001.geekbang.org/account/avatar/00/20/a6/9f/3c60fffd.jpg","nickname":"青阳","note":"","ucode":"3591D366BAB0B9","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376538,"discussion_content":"感觉是redis是内存数据库，不用IO，不用B+树，B+树是为了减少IO的目的吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1622181878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99998,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1559382323,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"23034218803","product_id":100017301,"comment_content":"思考题2：对二叉搜索树进行前序遍历，得到的结果以数组的形式存储到磁盘，还原的过程就是顺序遍历数组，构建二叉搜索树","like_count":5,"discussions":[{"author":{"id":1184397,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/mr9icibzvJmiatdx2FumKBY8ykmbUcUY4A8z8Ey4icqqtgUT6bZCGBo4ZFiaxrE5WmbtKia3xWYWrcrVtvdnmnWxrDjw/132","nickname":"王三白","note":"","ucode":"FE21B3D81384DE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":205152,"discussion_content":"除非是完全二叉树, 否则单独的任何一种遍历方式都无法重建. 可以用先序 + 中序两个数组保存.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584274068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1266043,"avatar":"https://static001.geekbang.org/account/avatar/00/13/51/7b/191a2112.jpg","nickname":"愤怒的虾干","note":"","ucode":"CEBD1B2BE7BCEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1184397,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/mr9icibzvJmiatdx2FumKBY8ykmbUcUY4A8z8Ey4icqqtgUT6bZCGBo4ZFiaxrE5WmbtKia3xWYWrcrVtvdnmnWxrDjw/132","nickname":"王三白","note":"","ucode":"FE21B3D81384DE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296261,"discussion_content":"二叉搜索树中序序列本来就是有序结构，故可以只使用前序序列重构二叉搜索树。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596499965,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":205152,"ip_address":""},"score":296261,"extra":""}]}]},{"had_liked":false,"id":63462,"user_name":"Xianping","can_delete":false,"product_type":"c1","uid":1240709,"ip_address":"","ucode":"108EF4AFF699C9","user_header":"https://static001.geekbang.org/account/avatar/00/12/ee/85/59e39469.jpg","comment_is_top":false,"comment_ctime":1548379619,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18728248803","product_id":100017301,"comment_content":"比高级篇，没那么烧脑了<br>","like_count":4},{"had_liked":false,"id":192187,"user_name":"Geek_d142f6","can_delete":false,"product_type":"c1","uid":1783608,"ip_address":"","ucode":"DFC61440374E79","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Ryl35QN5UMAtDW4akGRyMzXEOzjXzTaXD9Tvf0M8mEvf7Kds5u8b9RvFul8oItBib8icrhyOy1xWXVDqDbicWu3nQ/132","comment_is_top":false,"comment_ctime":1584842311,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14469744199","product_id":100017301,"comment_content":"程序员这行越干越焦虑，看到好多岗位都有年龄限制，好焦虑。<br>争哥，可以给点建议吗？","like_count":3},{"had_liked":false,"id":133558,"user_name":"static","can_delete":false,"product_type":"c1","uid":1138754,"ip_address":"","ucode":"1697966367370E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKYfReHXMbPaxO890ib9GvY9iciclPIUvaAYMYON4scP7ElXCPVzicghF0SH5HN2LqibYOrdrppC7DuSpw/132","comment_is_top":false,"comment_ctime":1568604665,"is_pvip":false,"replies":[{"id":"51416","content":"intset也不错啊，对CPU缓存也很友好的，不能指望所有的设计都是一样的呀。","user_name":"作者回复","comment_id":133558,"uid":"1190123","ip_address":"","utype":1,"ctime":1568760788,"user_name_real":"王争"}],"discussion_count":5,"race_medal":0,"score":"14453506553","product_id":100017301,"comment_content":"想问老师一个困扰我很久的redis问题。<br><br>redis中字典（hash）在数据量少时会采用ziplist数据结构，由于数据量少，并且可以利用CPU缓存，即不失查询速度的情况下又能大幅减少内存占用。但是同为散列表的集合（set）为什么没有采用同样的策略，在数据量少时使用ziplist？而是使用了intset这种有序整数数组？<br><br>感谢老师回答！","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467428,"discussion_content":"intset也不错啊，对CPU缓存也很友好的，不能指望所有的设计都是一样的呀。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568760788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2721761,"avatar":"https://static001.geekbang.org/account/avatar/00/29/87/e1/b85dce85.jpg","nickname":"无尽蔚蓝","note":"","ucode":"A665DF46833A81","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":587563,"discussion_content":"听君一席话，胜听一席话","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1663146614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":467428,"ip_address":"上海"},"score":587563,"extra":""}]},{"author":{"id":2159460,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/dsZ5CFV7mCIKEn7YcVFJXksO201eeqsJXoT4EYNvcibAKNSWSQVZPbbRgPKraWqg6YnaaRlVoywic9MEsflicRDibQ/132","nickname":"潜龙勿用","note":"","ucode":"EEB8A6F3E4A1B8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325264,"discussion_content":"set的插入要判重的，有序数组支持随机访问，用二分查询一个元素是否存在的效率更高","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1605259397,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2721761,"avatar":"https://static001.geekbang.org/account/avatar/00/29/87/e1/b85dce85.jpg","nickname":"无尽蔚蓝","note":"","ucode":"A665DF46833A81","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":2159460,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/dsZ5CFV7mCIKEn7YcVFJXksO201eeqsJXoT4EYNvcibAKNSWSQVZPbbRgPKraWqg6YnaaRlVoywic9MEsflicRDibQ/132","nickname":"潜龙勿用","note":"","ucode":"EEB8A6F3E4A1B8","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":586698,"discussion_content":"妙呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662443423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":325264,"ip_address":"上海"},"score":586698,"extra":""}]},{"author":{"id":1082785,"avatar":"https://static001.geekbang.org/account/avatar/00/10/85/a1/2442332c.jpg","nickname":"郭俊杰","note":"","ucode":"D328E5738A4413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":249960,"discussion_content":"假如set在数据量小的时候，也用ziplist, 那么当有一组数据量小的整型数据来了，你用ziplist操作肯定比用intset操作麻烦，因为zipList长度是可变的，那么写操作肯定比intset差，redis的集合用intset也许是为了多一种可能，多一种适合的场景吧。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1587979240,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":63706,"user_name":"read","can_delete":false,"product_type":"c1","uid":1063112,"ip_address":"","ucode":"F0E4AE2FD92923","user_header":"https://static001.geekbang.org/account/avatar/00/10/38/c8/dfc7a25b.jpg","comment_is_top":false,"comment_ctime":1548470892,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14433372780","product_id":100017301,"comment_content":"老师您好，有这样一个场景，A关注了B,这样的操作会同时写两个链表一个是A的关注列表，另一个是B的粉丝列表，比如用redis 的sortset来存储。现在要检查所有不一致的情况(比如，A的关注列表有B，但是B的粉丝列表没有A，或者A的关注列表没有B，但是B的粉丝列表有A)。这种情况有什么好的方法吗?","like_count":3},{"had_liked":false,"id":63601,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1548412642,"is_pvip":true,"discussion_count":3,"race_medal":0,"score":"14433314530","product_id":100017301,"comment_content":"有个疑问，比如对于有序集合，这个数据量可能会逐步增加，那么数据量达到阈值时就会切换成跳表吗？是数据全部移动到跳表，然后删除列表吗？","like_count":3,"discussions":[{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341607,"discussion_content":"我觉得这个问题和哈希表扩容数据迁移有点类似，每次新来的数据插入新的跳表，然后移动一部分旧数据，均摊到每次不会用时太久，查询时两个调表都查，不知道对不对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610461098,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1249656,"avatar":"https://static001.geekbang.org/account/avatar/00/13/11/78/4f0cd172.jpg","nickname":"妥协","note":"","ucode":"7201DFE9C12669","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":216430,"discussion_content":"同问，包括list，set，sortedset，是不是都要迁移数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585449874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1353753,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJnguccGyM8nvOb0N9B0kCnBV6OwNjvG9trYdiakmgYWVyfJkpD1vJBfnicmaQseupa7A7ic1rian0NlA/132","nickname":"陈园","note":"","ucode":"21BC5886297707","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":181312,"discussion_content":"我理解是这个集合里面的都移动。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582359696,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":63488,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1548382378,"is_pvip":false,"replies":[{"id":"22470","content":"对于Redis来说，重启并不是很经常的事情。所以并不会经常从硬盘加载数据到内存再重构成数据结构。<br><br>实际上，两种存储格式都可以，可能Redis就是随意选择了一个而已。不要太纠结为啥选的是这个，而不是那个。","user_name":"作者回复","comment_id":63488,"uid":"1190123","ip_address":"","utype":1,"ctime":1548404217,"user_name_real":"gg"}],"discussion_count":2,"race_medal":0,"score":"14433284266","product_id":100017301,"comment_content":"王老师两种数据结构持久化：<br>redius用“清除格式，持久化数据再组织数据结构” 这么看来是很消耗性能，为什么不用“保留数据结构”的方式。我理解后者只牺牲部分空间换取了更多性能 。<br>麻烦王老师解释下？","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437608,"discussion_content":"对于Redis来说，重启并不是很经常的事情。所以并不会经常从硬盘加载数据到内存再重构成数据结构。\n\n实际上，两种存储格式都可以，可能Redis就是随意选择了一个而已。不要太纠结为啥选的是这个，而不是那个。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548404217,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1042983,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/27/a3737d61.jpg","nickname":"Shanks-王冲","note":"","ucode":"C4B90A17850E20","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302721,"discussion_content":"其实也不会纠结拉，就是好奇Redis有更好的理由支持它的选择；那既然是随便选择的话，那我也就随便啦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599014277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":237926,"user_name":"Ivan.Qi","can_delete":false,"product_type":"c1","uid":1099170,"ip_address":"","ucode":"36F46A4D1F0EAA","user_header":"https://static001.geekbang.org/account/avatar/00/10/c5/a2/4ece341b.jpg","comment_is_top":false,"comment_ctime":1596006190,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10185940782","product_id":100017301,"comment_content":"Redis2 和 Redis5数据结构<br>https:&#47;&#47;github.com&#47;Ivanqi&#47;RedisDataStructure","like_count":2},{"had_liked":false,"id":134290,"user_name":"package coder.wjx;","can_delete":false,"product_type":"c1","uid":1139089,"ip_address":"","ucode":"F2B6304B00B614","user_header":"https://static001.geekbang.org/account/avatar/00/11/61/91/9e30b3fe.jpg","comment_is_top":false,"comment_ctime":1568796301,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10158730893","product_id":100017301,"comment_content":"关于思考题二，我想可以有两种方法。<br>1）平衡的树的保存<br>那么说明其高度是接近logn的，也就是接近完全二叉树的状态，那么使用数组就能够高效的保存这棵树，即便有些地方会是空的，但是这是以空间换时间，加上数组对缓存友好，保存读取应该都会很快。<br>保存的时候，首先查看最大的高度，申请一个足够大的数组。然后，从根节点开始，进行遍历，顺序无所谓。重要的是，我们要确定每个节点在数组中的下标，不过很简单，节点i的两个子节点的下标分别是2i+1和2i+2，画个图便清楚了。<br>还原的时候，首先获取数组第一个节点，构建节点，放入队列中，再使用类似广度遍历的方式，节点出对，在数组中查找其两个子节点，构建并连接两个子节点，子节点入队，直至队列空，构建就完成了。<br>保存与还原的时间复杂度与空间复杂度都是Ｏ(n)。<br>2）非平衡的树的保存<br>情况复杂一点，但是仍然能够使用下标。<br>保存的时候，为了方便后面的查找和读取，我们访问节点的顺序，是按下标升序的顺序走的，也就是广度遍历的顺序（加入子节点的时候注意先加左节点后右节点（好像本来就是这样的:-D）），这样一来，就能保存一条升序的列表，因而能够使用二分查找的方法寻找子节点的下标。<br>还原的时候，构建根节点，入队。进入循环，节点出队，使用二分查找的方法找到其两个子节点，构建连接并入队，直至队列为空。<br>空间复杂度为Ｏ(n)，时间复杂度，保存的是O(n)。还原时，n个节点的遍历需要O(n)，而遍历单个节点需要查找两次数组，因此是O(logn)，总体就是O(nlogn)。<br>不知有没有更快的方法，大家可以一起讨论下","like_count":2},{"had_liked":false,"id":86606,"user_name":"balancer","can_delete":false,"product_type":"c1","uid":1145758,"ip_address":"","ucode":"A865FAFF2FE1FA","user_header":"https://static001.geekbang.org/account/avatar/00/11/7b/9e/37d69ff0.jpg","comment_is_top":false,"comment_ctime":1555409750,"is_pvip":false,"replies":[{"id":"31222","content":"一整个都是用压缩列表实现的。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1555469061,"ip_address":"","comment_id":86606,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10145344342","product_id":100017301,"comment_content":"老师说的压缩列表，是整个数据 hash 或者set 实现是 压缩列表实现的，还是指 hash 或list 里面的具体一个元素是压缩列表实现的？ 压缩列表的结构不太清楚","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447091,"discussion_content":"一整个都是用压缩列表实现的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555469061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":63790,"user_name":"wei","can_delete":false,"product_type":"c1","uid":1013347,"ip_address":"","ucode":"345682FEFD1A90","user_header":"","comment_is_top":false,"comment_ctime":1548506194,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10138440786","product_id":100017301,"comment_content":"老师，如果字典保存的键和值的大小都小于 64 字节，并且键值对的个数小于 512 个，Redis 用压缩列表实现。从 [源码](https:&#47;&#47;github.com&#47;antirez&#47;redis&#47;blob&#47;unstable&#47;src&#47;ziplist.c) （ziplist.c ziplistFind） 来看压缩列表根据键查找值的方式，就是一个个遍历。如果有几百个键值对，这么查找比散列表快吗？","like_count":2,"discussions":[{"author":{"id":1338334,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6b/de/686585ee.jpg","nickname":"小C","note":"","ucode":"27C2D021A9E21E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305223,"discussion_content":"不是为了快，是为了省空间","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599821231,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307821,"user_name":"ppyh","can_delete":false,"product_type":"c1","uid":1351148,"ip_address":"","ucode":"14022ADEC9B53F","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/ec/235b74c0.jpg","comment_is_top":false,"comment_ctime":1629272210,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5924239506","product_id":100017301,"comment_content":"争哥，前面章节说到的跳跃表的排名问题留下的疑问怎么解决啊？<br>前两天看jdk和protobuf的序列化，总想不出怎么描述区分他两的优缺点，争哥说的对象持久化的两种解决思路真是太棒了，解决了我的疑问","like_count":1},{"had_liked":false,"id":252229,"user_name":"walle斌","can_delete":false,"product_type":"c1","uid":1062848,"ip_address":"","ucode":"0DB3243004951F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","comment_is_top":false,"comment_ctime":1602207405,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5897174701","product_id":100017301,"comment_content":"其实 老师应该讲一下redis的基本数据结构 sds  简单动态字符串的，redis的string使用这个结构，由此引申出，对于int 以及 embstr结构下速度比raw的更快。同时 引申出redis的预分配问题，一般的string 尽量不要append等操作，同时可以再引申出内存碎片率问题，与另外一款经典的内存数据库 memcache的作对比，毕竟后者的数据钙化问题还是蛮严重的一个问题。","like_count":1},{"had_liked":false,"id":242251,"user_name":"奥佛铎","can_delete":false,"product_type":"c1","uid":1234919,"ip_address":"","ucode":"A1D544E5F22B7F","user_header":"","comment_is_top":false,"comment_ctime":1597648800,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5892616096","product_id":100017301,"comment_content":"第一个问题：不同数据规模对于不同的时间复杂度意义不同，例如数据量小的时候有时常数时间甚至耗时多过O（lgn），为了应对不同的场景，需要具体问题具体分析，把优化做到极致<br>第二个：想到之前做的leetcode题目，给中序遍历和前序遍历数组，要求还原二叉树，我们可以将数组存下来，online的时候再做一次还原操作","like_count":1},{"had_liked":false,"id":103418,"user_name":"锦","can_delete":false,"product_type":"c1","uid":1468298,"ip_address":"","ucode":"CB0EB4B68C468B","user_header":"https://static001.geekbang.org/account/avatar/00/16/67/8a/babd74dc.jpg","comment_is_top":false,"comment_ctime":1560430971,"is_pvip":false,"replies":[{"id":"37455","content":"😂 自己看看redis官方文档吧","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1560472501,"ip_address":"","comment_id":103418,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5855398267","product_id":100017301,"comment_content":"常常听人说可以使用Redis作为消息队列，这是为什么呢？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453868,"discussion_content":"😂 自己看看redis官方文档吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560472501,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1204628,"avatar":"https://static001.geekbang.org/account/avatar/00/12/61/94/713b38ef.jpg","nickname":"小和尚笨南北","note":"","ucode":"17C9BBB6DD25D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":18159,"discussion_content":"或许和发布订阅有关系","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569027855,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1157636,"avatar":"https://static001.geekbang.org/account/avatar/00/11/aa/04/34ed47a5.jpg","nickname":"骑着炮弹进城","note":"","ucode":"4081F4E4279E92","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1204628,"avatar":"https://static001.geekbang.org/account/avatar/00/12/61/94/713b38ef.jpg","nickname":"小和尚笨南北","note":"","ucode":"17C9BBB6DD25D2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295811,"discussion_content":"嗯，我们用了这个功能实现的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596353598,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":18159,"ip_address":""},"score":295811,"extra":""}]}]},{"had_liked":false,"id":84579,"user_name":"xuery","can_delete":false,"product_type":"c1","uid":1027584,"ip_address":"","ucode":"F461B61BE06131","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/00/025f37e7.jpg","comment_is_top":false,"comment_ctime":1554879208,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5849846504","product_id":100017301,"comment_content":"1. 这个是因为每种数据结构都有适合自己的场景，比如压缩列表（特殊的有序数组）比较适合查询操作，删除新增的时间复杂度较高为O（n）,数据量小的时候可以使用，因为结构简单，数据量大的时候删除新增的效率非常低；所以量大的时候要考虑增删改查都比较快的数据结构，比如散列表、跳表、二叉树、红黑树等等数据结构了<br>2. 二叉树可以通过前序+中序写入磁盘，之后通过前序+中序还原；或者类似于将堆的时候，将数据按层遍历存入数组中，从下标1开始存储，下标i的左右子树存储在(2*i,2*i+1)下标中，然后顺序写入磁盘，这个的缺点是会产生空洞，因为不一定是满二叉树","like_count":1},{"had_liked":false,"id":79016,"user_name":"红红股海","can_delete":false,"product_type":"c1","uid":1064854,"ip_address":"","ucode":"188FD60BEFD25F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKnoSoric6IJjI9icQdhaL3IKRwbeic4IoLYAFricOzm0LnGbALtY6VQCYZ1AOiaux2foHok3OpRY94oxw/132","comment_is_top":false,"comment_ctime":1553323817,"is_pvip":false,"replies":[{"id":"28851","content":"后者","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1553386881,"ip_address":"","comment_id":79016,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5848291113","product_id":100017301,"comment_content":"&quot;字典中保存的键和值的大小都要小于 64 字节&quot;<br>老师，请问这句话的意思是 size(键+值)&lt;64   还是 size(键) &lt;64  &amp;&amp; size(值)&lt;64","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444327,"discussion_content":"后者","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553386881,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":63493,"user_name":"Yakmoz","can_delete":false,"product_type":"c1","uid":1257502,"ip_address":"","ucode":"1FA18A711457A0","user_header":"https://static001.geekbang.org/account/avatar/00/13/30/1e/0b05530d.jpg","comment_is_top":false,"comment_ctime":1548383491,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5843350787","product_id":100017301,"comment_content":"1. redis作为一个内存存储数据，应该会在时间复杂度不是很高的情况下，尽可能的少使用内存，基于这个原则对不同情况，采取不同策略，像set在都是整数的情况下，占用空间大小都是固定的就没必要在存储数据长度了<br>2. 序列化和反序列化，可以按照中序后序前序遍历树进行存储","like_count":1},{"had_liked":false,"id":360181,"user_name":"张德雷","can_delete":false,"product_type":"c1","uid":1747918,"ip_address":"上海","ucode":"788BEC93FB7971","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ab/ce/a4d03c2c.jpg","comment_is_top":false,"comment_ctime":1666256472,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1666256472","product_id":100017301,"comment_content":"感觉写的很简陋，很多东西都一路带过，很多细节都是可以细细的将来，本文章篇幅不长，所讲的点却很多，但是每个点都一笔带过。","like_count":0},{"had_liked":false,"id":345995,"user_name":"苏成","can_delete":false,"product_type":"c1","uid":2668694,"ip_address":"","ucode":"80A8E7B243DD73","user_header":"https://static001.geekbang.org/account/avatar/00/28/b8/96/716ba431.jpg","comment_is_top":false,"comment_ctime":1652755680,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1652755680","product_id":100017301,"comment_content":"Java基础泛型看完<br><br>第52讲：Redis常用的数据结构（都是用作值）<br><br>1. Redis介绍<br>   - Key-Value数据库。（key是字符串， value数据类型很多：字符串，列表，字典，集合，有序集合）<br>   - 主要是内存数据库<br>2. 列表<br>   - 压缩列表（小数据）：连续空间，每个数据大小不一致（节省空间、读取效率高）<br>   - 双向循环链表：多定义了一个list结构体：组织首尾指针，长度<br>3. 字典（字典的值又分为）<br>   - 压缩列表<br>   - 散列表（渐进式扩容缩容）<br>4. 集合<br>   - 有序数组（整数数据小）<br>   - 散列表<br>5. 有序集合（跳表）<br>6. 数据持久化（存储在硬盘）<br>   - 只存储数据，磁盘到内存，内存到磁盘组织成原来的数据结构<br>   - 保留数据结构信息。比如存散列表，存数据之外，还存散列表大小，数据被散列的槽信息","like_count":0},{"had_liked":false,"id":339373,"user_name":"H.H","can_delete":false,"product_type":"c1","uid":2668479,"ip_address":"","ucode":"3C0BB1E2A3EC51","user_header":"https://static001.geekbang.org/account/avatar/00/28/b7/bf/815f0ec6.jpg","comment_is_top":false,"comment_ctime":1648046483,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1648046483","product_id":100017301,"comment_content":"看了一下redis源码，发现ziplist 换成了listpack.","like_count":0},{"had_liked":false,"id":334291,"user_name":"Aibo","can_delete":false,"product_type":"c1","uid":2115387,"ip_address":"","ucode":"2CE3E77BD2D014","user_header":"https://static001.geekbang.org/account/avatar/00/20/47/3b/70198ceb.jpg","comment_is_top":false,"comment_ctime":1644851882,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644851882","product_id":100017301,"comment_content":"压缩列表的优点：节省空间，因为是连续的空间，可以更好的利用cpu cache，更便于gc以及内存复用。<br><br>缺点也很明显，查询其中某个key时间复杂度O(n)，随着列表增长，查询时间也在变慢。<br><br>总结 平衡各个资源的开销，权衡时间和空间复杂度","like_count":0},{"had_liked":false,"id":332915,"user_name":"简单猫","can_delete":false,"product_type":"c1","uid":1866485,"ip_address":"","ucode":"EA027D4C344E25","user_header":"https://static001.geekbang.org/account/avatar/00/1c/7a/f5/54a5084b.jpg","comment_is_top":false,"comment_ctime":1643811027,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643811027","product_id":100017301,"comment_content":"问题1，之所以根据数据大小来换结构。<br>数据量小的时候 用空间换时间。<br>数据量大的时候 考虑到内存占用率问题，又会牺牲部分数据来提高内存利用率<br>问题2<br>二叉查找树 <br>根据树的深度来平衡 到底是使用第一种还是第二种<br>其实也就是考时间 和 空间的问题<br>当数据真好在某个比例上 可能直接从新构造新的二叉树可能会更快  因为你要考虑到读写磁盘io也会有时间损耗","like_count":0},{"had_liked":false,"id":304246,"user_name":"GeekTerry","can_delete":false,"product_type":"c1","uid":2611431,"ip_address":"","ucode":"7C05FA14D90FC4","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/guTSzEA3CV4YicMQlZEW4POWiaKtlDljrPzLY8dIESpicQBs9XfTu7dicz9THUm7InBf4NZNeLI3X4WHRxDKyjCkKw/132","comment_is_top":false,"comment_ctime":1627304807,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627304807","product_id":100017301,"comment_content":"思考題二：把 binary tree 轉化成 array 的方式儲存。可以試著寫寫看 LeetCode 297。","like_count":0},{"had_liked":false,"id":302499,"user_name":"二小","can_delete":false,"product_type":"c1","uid":1593919,"ip_address":"","ucode":"5377CB552237B2","user_header":"https://static001.geekbang.org/account/avatar/00/18/52/3f/c8b40efe.jpg","comment_is_top":false,"comment_ctime":1626240767,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626240767","product_id":100017301,"comment_content":"第二个思考题让我想到了B+树，可以把每个节点放在一页上进行存储，不过就需要额外字段只想子树存储的页","like_count":0},{"had_liked":false,"id":291719,"user_name":"白菜","can_delete":false,"product_type":"c1","uid":2230467,"ip_address":"","ucode":"C3AE527ECE970E","user_header":"https://static001.geekbang.org/account/avatar/00/22/08/c3/bf4fe285.jpg","comment_is_top":false,"comment_ctime":1620448528,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1620448528","product_id":100017301,"comment_content":"有序集合除了跳表外应该还有哈希表的结构吧？不然像 ZSCORE 这中通过member查分数的就要遍历跳表了","like_count":0},{"had_liked":false,"id":288716,"user_name":"Wheat","can_delete":false,"product_type":"c1","uid":1260141,"ip_address":"","ucode":"7D99EA149B6DE8","user_header":"https://static001.geekbang.org/account/avatar/00/13/3a/6d/910b2445.jpg","comment_is_top":false,"comment_ctime":1618638526,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618638526","product_id":100017301,"comment_content":"老师可能我java基础不是很好，想弱弱地问一下，String数组里存的不是字符串的内存地址吗，难道存的是字符串码？如果存的字符串的话，那创建数组对象申请内存空间的时候，每个元素的大小不应该都已经定好了吗","like_count":0},{"had_liked":false,"id":269303,"user_name":"一念_风生","can_delete":false,"product_type":"c1","uid":1577339,"ip_address":"","ucode":"13211B6B33C491","user_header":"https://static001.geekbang.org/account/avatar/00/18/11/7b/3426351c.jpg","comment_is_top":false,"comment_ctime":1608607035,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1608607035","product_id":100017301,"comment_content":"老师，redis的双向链表我这么理解不知道可行？<br>list是redis的一种数据结构，但是redis改变了list的底层存储实现 将数组改成了双向链表实现，然后list里面只存了首尾的引用和一些list必要的属性而已","like_count":0},{"had_liked":false,"id":252501,"user_name":"万里国度","can_delete":false,"product_type":"c1","uid":1364248,"ip_address":"","ucode":"9B47C4E69DAC8E","user_header":"https://static001.geekbang.org/account/avatar/00/14/d1/18/5cc21f63.jpg","comment_is_top":false,"comment_ctime":1602320565,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1602320565","product_id":100017301,"comment_content":"关于redis得持久化策略王老师大可不必这样说，因为确实说的有瑕疵。<br>redis得两种持久化策略 rdb和aof  一个是内存中的数据存储映像，一个是数据添加优化的加载命令<br>简单说一下就行了","like_count":0,"discussions":[{"author":{"id":1640978,"avatar":"https://static001.geekbang.org/account/avatar/00/19/0a/12/f8b988b8.jpg","nickname":"Kyle(","note":"","ucode":"0C14C4C086CAA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374824,"discussion_content":"这个加载命令不是原语句的添加吗？类似于mysql的binlog希望存的是原sql语句？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621382806,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":242092,"user_name":"王小白白白","can_delete":false,"product_type":"c1","uid":1140277,"ip_address":"","ucode":"7049DA34B12208","user_header":"https://static001.geekbang.org/account/avatar/00/11/66/35/1b14f2af.jpg","comment_is_top":false,"comment_ctime":1597588415,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597588415","product_id":100017301,"comment_content":"老师，在跳表一节里说到，有序集合还用到散列表，这里说用到压缩列表，那么？","like_count":0},{"had_liked":false,"id":234015,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1594552906,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594552906","product_id":100017301,"comment_content":"思考题：<br>1.采用多种数据结构来实现多种数据类型，可以发挥各数据结构的性能优势，能使得Redis在存贮性能和查找性能方面发挥最大的优势。<br>2.可以采用两种方式：<br>第一种方式：对二叉查找树采用两种遍历方法，比如先序遍历和中序遍历，然后把两种遍历结果全部持久化到磁盘中，从磁盘中还原时，根据两种遍历结果可以唯一确定一颗二叉树；<br>第二种方式：对二叉查找树的每个节点进行编号，持久化时，保存每个节点的编号、每个节点的数据值、每个节点的父节点编号，每个节点在父节点中的左&#47;右位置信息<br>采用第一种方式，会稍微节省存贮空间，但当节点数较多时，会比较耗时；第二种方式，存贮空间比较多，但还原时比较简单高效。","like_count":0},{"had_liked":false,"id":233292,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1594280657,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594280657","product_id":100017301,"comment_content":"数据的持久化是不是就是序列化？","like_count":0},{"had_liked":false,"id":228612,"user_name":"晚风·和煦","can_delete":false,"product_type":"c1","uid":1236047,"ip_address":"","ucode":"0B1DB8F437A4B2","user_header":"","comment_is_top":false,"comment_ctime":1592752458,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592752458","product_id":100017301,"comment_content":"老师，面试应该怎么回答 有序列表用跳表而不是b+树呢","like_count":0},{"had_liked":false,"id":216782,"user_name":"迈克糖","can_delete":false,"product_type":"c1","uid":1749228,"ip_address":"","ucode":"A55D3DB2B20C4B","user_header":"https://static001.geekbang.org/account/avatar/00/1a/b0/ec/78be126d.jpg","comment_is_top":false,"comment_ctime":1589341411,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589341411","product_id":100017301,"comment_content":"红黑树这种存储形式，可以以文件结构落地到磁盘上，比如根节点，然后一层一层的生成文件。就类似于我们在磁盘上找文件一样。","like_count":0},{"had_liked":false,"id":215010,"user_name":"黄平","can_delete":false,"product_type":"c1","uid":1142708,"ip_address":"","ucode":"2207224A09735C","user_header":"https://static001.geekbang.org/account/avatar/00/11/6f/b4/4aefe4c0.jpg","comment_is_top":false,"comment_ctime":1588868051,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588868051","product_id":100017301,"comment_content":"字典类型怎么用压缩列表实现呢？","like_count":0},{"had_liked":false,"id":208886,"user_name":"prader26","can_delete":false,"product_type":"c1","uid":1433707,"ip_address":"","ucode":"5EFFFC374ADECE","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/6b/f61d7466.jpg","comment_is_top":false,"comment_ctime":1587458226,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587458226","product_id":100017301,"comment_content":"今天，我们学习了 Redis 中常用数据类型底层依赖的数据结构，总结一下大概有这五种：压缩列表（可以看作一种特殊的数组）、有序数组、链表、散列表、跳表。实际上，Redis 就是这些常用数据结构的封装。","like_count":0},{"had_liked":false,"id":201677,"user_name":"蜗牛","can_delete":false,"product_type":"c1","uid":1086220,"ip_address":"","ucode":"01CC18F12E556D","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/0c/0a6a0d5e.jpg","comment_is_top":false,"comment_ctime":1585819437,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585819437","product_id":100017301,"comment_content":"因为内存相比磁盘，是比较少的资源。所以需要优化，减少内存使用吧？","like_count":0},{"had_liked":false,"id":199261,"user_name":"gtp","can_delete":false,"product_type":"c1","uid":1372089,"ip_address":"","ucode":"12E21307343B3A","user_header":"https://static001.geekbang.org/account/avatar/00/14/ef/b9/c0c12bea.jpg","comment_is_top":false,"comment_ctime":1585485032,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585485032","product_id":100017301,"comment_content":"不同的场景不用的技术选型，工程师大部分工作其实是在做决策","like_count":0},{"had_liked":false,"id":196442,"user_name":"恋雪","can_delete":false,"product_type":"c1","uid":1185590,"ip_address":"","ucode":"B0D8870130A314","user_header":"https://static001.geekbang.org/account/avatar/00/12/17/36/ece951b4.jpg","comment_is_top":false,"comment_ctime":1585281611,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585281611","product_id":100017301,"comment_content":"现在好多概念性的链接都打不开了，如MurmurHash2，还有这个课程中其他文章里面的也是","like_count":0},{"had_liked":false,"id":196320,"user_name":"恋雪","can_delete":false,"product_type":"c1","uid":1185590,"ip_address":"","ucode":"B0D8870130A314","user_header":"https://static001.geekbang.org/account/avatar/00/12/17/36/ece951b4.jpg","comment_is_top":false,"comment_ctime":1585272346,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585272346","product_id":100017301,"comment_content":"压缩列表并不是通过下标随机访问每个数据的，每个节点记录了前一个节点的长度及自身节点的长度，访问的时候通过当前节点的指针+自身节点长度&#47;前一节点长度，来访问下一节点&#47;前一节点。与链表的访问类似","like_count":0},{"had_liked":false,"id":182351,"user_name":"发霉的宅大人","can_delete":false,"product_type":"c1","uid":1738243,"ip_address":"","ucode":"6757E30FE5E48D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/03/95004954.jpg","comment_is_top":false,"comment_ctime":1582772206,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582772206","product_id":100017301,"comment_content":"思考题：<br>1、方案一定是为解决某个问题而提出的，这里封装的数据结构也应该是如此。<br>压缩列表（可以看作一种特殊的数组）——节省内存<br>有序数组——顺序打印输出<br>链表——节省空间的大量数据储存同时兼顾增删改查<br>散列表——快速查找<br>跳表——增删改查方便的同时提供快速查找<br>2、二叉树永久化，我觉得可以将二叉树按照一定的顺序存储，比如说从根节点开始，从上往下，从左往右依次存储到硬盘如果遇到空节点我们就存储一个特殊标识，直到最后一个叶子节点被存储后加一个结尾符号<br>我们读取的时候也从根节点开始依次读取，因为是二叉树，保证了每个节点都只有两个节点，我们再读取数据的时候分别放到左右节点（遇到特殊符号就是空节点，为NULL），直至读取到结尾符号。","like_count":0},{"had_liked":false,"id":182347,"user_name":"发霉的宅大人","can_delete":false,"product_type":"c1","uid":1738243,"ip_address":"","ucode":"6757E30FE5E48D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/03/95004954.jpg","comment_is_top":false,"comment_ctime":1582771691,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582771691","product_id":100017301,"comment_content":"提问：<br>老师，文中的<br>“Redis 中，键的数据类型是字符串，但是为了丰富数据存储的方式，方便开发者使用，值的数据类型有很多，常用的数据类型有这样几种，它们分别是字符串、列表、字典、集合、有序集合。”<br>这一段话，意思是说，key-value的value可以是完整的字符串、列表、字典、集合、有序集合吗？<br>那这么说如果value是列表，就是一个key值对应一个大的hash表。<br>这样的话，那查询不会很麻烦吗？先根据一个key值查询到hash表，再根据一个key值去查询hash表中的值.......","like_count":0},{"had_liked":false,"id":182346,"user_name":"发霉的宅大人","can_delete":false,"product_type":"c1","uid":1738243,"ip_address":"","ucode":"6757E30FE5E48D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/03/95004954.jpg","comment_is_top":false,"comment_ctime":1582771330,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582771330","product_id":100017301,"comment_content":"问题：老师，请问文中提到<br>“压缩列表这种存储结构，一方面比较节省内存，另一方面可以支持不同类型数据的存储。而且，因为数据存储在一片连续的内存空间，通过键来获取值为列表类型的数据，读取的效率也非常高。”<br>如果一个key值对用一个value，这个value是一块连续内存但是里面数据大小不一，要读取里面的单个数据，我能想到的只有遍历来查找数据了，这样的效率不是应该很低吗？","like_count":0},{"had_liked":false,"id":172395,"user_name":"wod.Y","can_delete":false,"product_type":"c1","uid":1064423,"ip_address":"","ucode":"CFAFCE8BA59862","user_header":"https://static001.geekbang.org/account/avatar/00/10/3d/e7/d04bf0cf.jpg","comment_is_top":false,"comment_ctime":1579168280,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579168280","product_id":100017301,"comment_content":"小数据量时获取压缩列表所有数据直接顺序查找即可，因为量小，不会太影响查找性能；<br>大数据量时考虑查找性能和连续内存空间的申请，不再适合压缩列表。","like_count":0},{"had_liked":false,"id":172219,"user_name":"梦想的优惠券","can_delete":false,"product_type":"c1","uid":1257418,"ip_address":"","ucode":"D3B44F6C618CA7","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/ca/cbce6e94.jpg","comment_is_top":false,"comment_ctime":1579135207,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1579135207","product_id":100017301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":137679,"user_name":"复兴","can_delete":false,"product_type":"c1","uid":1363230,"ip_address":"","ucode":"C172A87873001A","user_header":"https://static001.geekbang.org/account/avatar/00/14/cd/1e/692c3313.jpg","comment_is_top":false,"comment_ctime":1569821403,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569821403","product_id":100017301,"comment_content":"老师能说下，压缩列表具体怎样实现的嘛","like_count":0},{"had_liked":false,"id":136054,"user_name":"方晓斌","can_delete":false,"product_type":"c1","uid":1042367,"ip_address":"","ucode":"A26FA55F05FE9E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e7/bf/b6dd86f4.jpg","comment_is_top":false,"comment_ctime":1569336701,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569336701","product_id":100017301,"comment_content":"第二题清除数据结构存储有两种思路，保持前中后序遍历串，或者填充成完全二叉树用数组。都能还原","like_count":0},{"had_liked":false,"id":135399,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1569145957,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569145957","product_id":100017301,"comment_content":"1 只所以采用不同的数据结构，目的都是为了优化性能。因为数据结构和算法性能是依托于具体的场景和数据规模的。例如redis中的列表，当数据规模较小时，使用的是ziplist，节约了空间，同时数据连续存储有利于cpu缓存。当数据量较大时使用双向链表，这是因为ziplist要求连续内存存储，数据量大的话要求的连续内存尺寸也会增大，这不利于利用碎片化的内存<br>2 二叉树的结构化存储，实际上难点是指针的序列化，二叉树节点中包含数据，左子节点指针和由子节点指针，序列化左右子节点指针时，我们直接存储其所指向的子节点的数据在文件中的存储位置","like_count":0},{"had_liked":false,"id":134635,"user_name":"Amark","can_delete":false,"product_type":"c1","uid":1121326,"ip_address":"","ucode":"E5F48633654002","user_header":"https://static001.geekbang.org/account/avatar/00/11/1c/2e/93812642.jpg","comment_is_top":false,"comment_ctime":1568883445,"is_pvip":false,"replies":[{"id":"51693","content":"貌似有点难度 ","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1568934086,"ip_address":"","comment_id":134635,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568883445","product_id":100017301,"comment_content":"请教一个问题，redis hash 能存储多级字典吗?，比如:{‘a’: {&#39;b&#39;: {&#39;c&#39;: 9}}}","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467837,"discussion_content":"貌似有点难度 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568934086,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133556,"user_name":"static","can_delete":false,"product_type":"c1","uid":1138754,"ip_address":"","ucode":"1697966367370E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKYfReHXMbPaxO890ib9GvY9iciclPIUvaAYMYON4scP7ElXCPVzicghF0SH5HN2LqibYOrdrppC7DuSpw/132","comment_is_top":false,"comment_ctime":1568604420,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568604420","product_id":100017301,"comment_content":"想问一下老师一个困扰我很久的redis问题。","like_count":0},{"had_liked":false,"id":131680,"user_name":"z.l","can_delete":false,"product_type":"c1","uid":1181055,"ip_address":"","ucode":"805CC5784D3F76","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/7f/d35ab9a1.jpg","comment_is_top":false,"comment_ctime":1567844313,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567844313","product_id":100017301,"comment_content":"压缩列表虽然省内存，但是随机插入删除需要做内存拷贝，所以数据量大了之后影响性能","like_count":0},{"had_liked":false,"id":124819,"user_name":"erlang","can_delete":false,"product_type":"c1","uid":1455660,"ip_address":"","ucode":"352C33E78A0C92","user_header":"https://static001.geekbang.org/account/avatar/00/16/36/2c/e334a734.jpg","comment_is_top":false,"comment_ctime":1566001573,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566001573","product_id":100017301,"comment_content":"redis里的字符串，用的是数组存储的吧？和java里的ArrayList 很像，支持动态扩容的","like_count":0},{"had_liked":false,"id":121925,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1565250604,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565250604","product_id":100017301,"comment_content":"思考题二<br>二叉查找树存储的时候，可以分两部分存储，所有节点可以在一个数组中。相互连接关系可以节点数组下标作为索引的方式存在另一个数组中。","like_count":0},{"had_liked":false,"id":121923,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1565250233,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565250233","product_id":100017301,"comment_content":"思考题1<br>选择两种数据结构可能是因为问题规模不同，最佳方案也不同。存储量少的时候，数组的弊端不明显，因为这时整块的内存比较容易得到，数据的搬运代价不大。数组的存储紧凑，遍历的时候可以充分利用CPU的缓存等优点可以给系统带来时间空间两方面的效率。当数据量变大，整块的大内存变的稀缺，数据搬运代价巨大，这个时候用扩展性好的双向链表或者哈希表，即使付出了一些指针的代价，牺牲了缓存的效率之后还是更划算一些。","like_count":0},{"had_liked":false,"id":101163,"user_name":"danvid","can_delete":false,"product_type":"c1","uid":1270415,"ip_address":"","ucode":"84C50611B1DEA5","user_header":"https://static001.geekbang.org/account/avatar/00/13/62/8f/c0f40d98.jpg","comment_is_top":false,"comment_ctime":1559732055,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559732055","product_id":100017301,"comment_content":"数据不需要存储太多的其他引用字段，减少内存空间，但是很多结构需要对数组遍历才能满足功能所以大数据量时会导致效率低，所以才这样设计","like_count":0},{"had_liked":false,"id":98521,"user_name":"哈哈","can_delete":false,"product_type":"c1","uid":1240120,"ip_address":"","ucode":"8B6D697CE6C83D","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/38/c7819759.jpg","comment_is_top":false,"comment_ctime":1559016687,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559016687","product_id":100017301,"comment_content":"使用压缩列表, 应该也是使用了操作系统对于连续内存  预加载的特性(忘了在哪里看到的了)","like_count":0},{"had_liked":false,"id":78083,"user_name":"且听疯吟","can_delete":false,"product_type":"c1","uid":1159459,"ip_address":"","ucode":"B010B16E5465F4","user_header":"https://static001.geekbang.org/account/avatar/00/11/b1/23/5df1f341.jpg","comment_is_top":false,"comment_ctime":1553068325,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553068325","product_id":100017301,"comment_content":"1.肯定对于不同的存储类型，需采用不同的数据结构，这是与自身的业务特性相关联的。<br>2.对于二叉树的持久化可以参考leetcode接口，采用数组即可。","like_count":0},{"had_liked":false,"id":68000,"user_name":"Tattoo","can_delete":false,"product_type":"c1","uid":1036503,"ip_address":"","ucode":"CE926AC8582C96","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d0/d7/a09ef784.jpg","comment_is_top":false,"comment_ctime":1550380850,"is_pvip":true,"replies":[{"id":"25064","content":"有可能。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551061797,"ip_address":"","comment_id":68000,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1550380850","product_id":100017301,"comment_content":"压缩列表是不是用变长数组实现的呐？<br>char  str[0[]","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439462,"discussion_content":"有可能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551061797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":67543,"user_name":"途","can_delete":false,"product_type":"c1","uid":1178240,"ip_address":"","ucode":"7715FE183557FF","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/80/f8be387d.jpg","comment_is_top":false,"comment_ctime":1550194846,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1550194846","product_id":100017301,"comment_content":"有一个问题，关于压缩列表的描述中有句话有个疑问，“而且，因为数据存储在一片连续的内存空间，通过键来获取值为列表类型的数据，读取的效率也非常高”，数据存储在一片连续的内存空间中只是压缩列表内部的存储结构，这应该不是通过键获取值时读取效率非常高的的原因吧？","like_count":0,"discussions":[{"author":{"id":1114579,"avatar":"https://static001.geekbang.org/account/avatar/00/11/01/d3/5cbaeb95.jpg","nickname":"HUNTER","note":"","ucode":"184725E9ED0E2C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4114,"discussion_content":"连续的内存空间可以有效利用CPU缓存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565140916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64247,"user_name":"目","can_delete":false,"product_type":"c1","uid":1103603,"ip_address":"","ucode":"F55B94023D2331","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/f3/601f5f29.jpg","comment_is_top":false,"comment_ctime":1548726259,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548726259","product_id":100017301,"comment_content":"王老师，既然可以用压缩列表，为啥数据超过512个的时候不用单链表","like_count":0},{"had_liked":false,"id":63898,"user_name":"骏彩灬星驰","can_delete":false,"product_type":"c1","uid":1047248,"ip_address":"","ucode":"016DBBF58632ED","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fa/d0/808c2fd9.jpg","comment_is_top":false,"comment_ctime":1548587141,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548587141","product_id":100017301,"comment_content":"我只想说老师你优秀，很用心，我会尽量赶上来！","like_count":0},{"had_liked":false,"id":63637,"user_name":"莫弹弹","can_delete":false,"product_type":"c1","uid":1239978,"ip_address":"","ucode":"60A25C709A665F","user_header":"https://static001.geekbang.org/account/avatar/00/12/eb/aa/db213a66.jpg","comment_is_top":false,"comment_ctime":1548425619,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548425619","product_id":100017301,"comment_content":"思考题1<br>redis的各个存储都有判断数据大小再选择存储结构，那么可以猜想是为了平衡时间与空间，但是优先保证空间（毕竟是内存），单一结构简单易懂，大概redis多种结构就是从单一结构优化而来的吧。<br>这里有个疑问，判断条件512和128是随便写的？这有什么计算方案？<br><br>2持久化<br>普通树可以选择一个遍历方式，例如前序遍历，把树变成链表，把数据挨个保存，等需要取出来再按顺序把所有元素加到树里面。<br>二叉查找树本身底层就是使用数组，整个数组写进磁盘就完事了，取出来也是连续数组，完全不用保存树结构","like_count":0},{"had_liked":false,"id":63604,"user_name":"纯洁的憎恶","can_delete":false,"product_type":"c1","uid":1130512,"ip_address":"","ucode":"5E9757DE6F45DF","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/10/b6bf3c3c.jpg","comment_is_top":false,"comment_ctime":1548413185,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1548413185","product_id":100017301,"comment_content":"Redis这种K-Value非关系数据库是否也能够很好的支持分布式文件系统呢？","like_count":0},{"had_liked":false,"id":63586,"user_name":"猫头鹰爱拿铁","can_delete":false,"product_type":"c1","uid":1105958,"ip_address":"","ucode":"24266B58968428","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/26/4942a09e.jpg","comment_is_top":false,"comment_ctime":1548408568,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1548408568","product_id":100017301,"comment_content":"思考题 <br>1. redis主要作为内存数据库来使用，数据存储在内存中。而内存相比于又便宜空间又大的磁盘而言，需要考虑存储空间相对有限和贵的问题。针对于数据量比较小的情况，尽量使用节省空间的数据结构。这个价格成本和实现成本比较是划算的。<br>2. 如果用指针来表示二叉查找树的成员变量会导致持久化后物理地址失效的问题。可否借用数组的思想，存储二叉查找树节点的数据以数组的形式组织，如树中没有节点的位置在数组的对应位置使用0或null。例如二叉查找树5、3、8、2、9则存储相应的数据值5、3、8、2、0、0、9同时存储数组的长度<br>","like_count":0},{"had_liked":false,"id":63494,"user_name":"废材壶","can_delete":false,"product_type":"c1","uid":1151751,"ip_address":"","ucode":"C8A46065DF81D7","user_header":"https://static001.geekbang.org/account/avatar/00/11/93/07/c66c1ba4.jpg","comment_is_top":false,"comment_ctime":1548383541,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548383541","product_id":100017301,"comment_content":"后边很少有跟上的😂","like_count":0},{"had_liked":false,"id":63463,"user_name":"Sharry","can_delete":false,"product_type":"c1","uid":1239293,"ip_address":"","ucode":"045DDB864659F6","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/fd/035f4c94.jpg","comment_is_top":false,"comment_ctime":1548379926,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548379926","product_id":100017301,"comment_content":"1. 对于数据量较小的情况, 使用链表直接遍历的增删改查的效率比起复杂的 树&#47;散列表&#47;跳表 忽略了旋转, hash...等运算, 没有太明显的劣势, 效率反而会更高<br>2. 关于树的序列化:     可以使用前序遍历二叉树的规则序列化, 左右子孩子为 NULL 则记为 &#39;#&#39;<br>3. 关于树的反序列化:  使用前序遍历二叉树的规则还原, 遇到 &#39;#&#39; 则说明遍历到了叶子结点","like_count":0},{"had_liked":false,"id":63453,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1548377583,"is_pvip":false,"replies":[{"id":"22471","content":"1. 看具体应用了。这种实现思路跟我们平常直接定义链表的方式有点不一样（Node * list = null;这样子）。所以我就稍微提了一下。<br>2. 这个跟数据结构和算法关系不大了。我没仔细研究过。理论上猜一下的话，就是按照一个pair（key+value）一个pair的顺序存储在文件中。pair之间用一定方法分割，方便读取。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1548404495,"ip_address":"","comment_id":63453,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1548377583","product_id":100017301,"comment_content":"想问老师两个问题: <br>1.在列表的双向链表数据结构中, 使用额外的list来存储首位节点和长度等信息后使用起来就会方便呢?<br>2.redis的持久化策略中, 清除原有的存储结构只将数据存在磁盘中, 那这些数据具体在磁盘中是怎么存储的? 是采用压缩列表的方式吗?","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437592,"discussion_content":"1. 看具体应用了。这种实现思路跟我们平常直接定义链表的方式有点不一样（Node * list = null;这样子）。所以我就稍微提了一下。\n2. 这个跟数据结构和算法关系不大了。我没仔细研究过。理论上猜一下的话，就是按照一个pair（key+value）一个pair的顺序存储在文件中。pair之间用一定方法分割，方便读取。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548404495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}