{"id":740908,"title":"第 3 章 使用 Go 语言实现 HTTP/1.0 客户端","content":"\n    \n    <p>第 1 章介绍了 HTTP 的如下 4 个基本元素，以及发送和接收这些基本元素的 curl 命令的写法。</p>\n    <blockquote>\n        <ul>\n            <li>方法和路径</li>\n            <li>首部</li>\n            <li>主体</li>\n            <li>状态码</li>\n        </ul>\n    </blockquote>\n    <p>本章我们来学习一下如何使用 Go 语言来编写发送和接收上述内容的代码。</p>\n    <blockquote>\n        <p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100009/image00381.jpeg\" alt=\"\" width=\"7%\" style=\"width: 7%\" inline-img=\"true\" />　在前面的章节中，curl 命令都带有 HTTP/1.0\n            中的运行选项（<code>--http1.0</code>），本章会省略该选项。虽然在执行 curl 命令时会像“HTTP/1.1”这样显示协议版本，但动作与 HTTP/1.0 并没有太大区别。</p>\n    </blockquote>\n    <h2 id=\"nav_point_78\">3.1　为何使用 Go 语言</h2>\n    <p>Google 公司在 2007 年发布了 Go 语言。近年来，Go 语言得到广泛应用。Go 语言的优点体现在以下几个方面。</p>\n    <blockquote>\n        <ul>\n            <li>拥有轻量级语言规范和丰富的标准库</li>\n            <li>编译速度快，可与动态脚本语言的运行速度匹敌，会进行类型检查</li>\n            <li>运行速度快，易于实现多核性能，节省内存</li>\n            <li>易于交叉编译</li>\n            <li>输出的是单一的二进制文件，易于发布</li>\n        </ul>\n    </blockquote>\n    <p>另外，本书之所以采用 Go 语言来实现 HTTP 代码，也是因为它是一门优秀的教学语言，具体体现在以下几个方面。</p>\n    <blockquote>\n        <ul>\n            <li>语言规范少于其他编程语言，使用其他编程语言的用户也能轻松理解 Go 语言的运行方式，因此 Go 作为描述语言也非常优秀</li>\n            <li>Go 语言是编译语言，能够检查语法结构和类型，易于发现输入错误</li>\n            <li>仅使用标准库即可创建访问 HTTP 的程序</li>\n            <li>实际上，Go 语言也用作各种 Web 服务的 CLI 客户端的实现语言</li>\n        </ul>\n    </blockquote>\n    <p>单看每个特征，我们也能发现 Go 语言相比其他编程语言的优秀之处。例如，Go 语言的运行速度比 C 和 C++\n        快，生成的二进制文件也比较小。不过，交叉编译环境搭建起来比较费事，而且在编译和发布时，要把需要用到的库都集中起来创建编译环境，这也很麻烦。拥有包管理器的 Python、Ruby 和 Node.js\n        等脚本语言无须编译，但不会输出单一的二进制文件，运行速度比 Go 语言慢一点儿，内存消耗量方面也比 Go\n        语言大一点儿。我们在学生时代都参加过模拟考试，应该知道用自己擅长的学科弥补不擅长的学科是一件很难的事情，只有所有学科都取得好成绩，才能提高偏差值 <span class=\"comment-number\">1</span>。Go\n        语言就是一种能够完美解决各种问题的语言。</p><!-- [[[read_end]]] -->\n    \n    <p>本书不会详细介绍 Go 语言的基础知识，其他编程语言的使用者可通过在线教程“A Tour of Go”了解 Go 语言。如今，Go 语言的相关图书不断增多，学习也变得更加方便。大家还可以参考集中介绍了 Go 语法的“Java\n        to Go in-depth tutorial”。</p>\n    <h2 id=\"nav_point_79\">3.2　Go 语言的 API 结构</h2>\n    <p>Go 语言中提供的 HTTP 的客户端 API 大致分为如下 3 类。</p>\n    <blockquote>\n        <ul>\n            <li>功能有限，但易于使用的 API</li>\n            <li>能使用 Cookie 的、可稍加控制的 API</li>\n            <li>原生的、可访问所有功能的 API</li>\n        </ul>\n    </blockquote>\n    <p>前两种 API 比较简单，写出来的代码也比较短，但在处理更详细的内容时，就需要使用最后一种 API 了。前两种 API 是基于后一种 API 构建的。我们首先使用比较简单的 API\n        来实现频繁使用的处理的代码，然后学习如何使用原生 API 来实现更加详细的 HTTP 访问。</p>\n    <h2 id=\"nav_point_80\">3.3　本章的主要内容</h2>\n    <p>第 1 章和第 2 章介绍了 HTTP 的基本结构，以及浏览器发送和接收信息的模式（表 3-1）。下面我们来学习一下如何使用 Go 语言来实现其中几个比较典型的模式。</p>\n    <p><strong>表 3-1　浏览器发送和接收信息的模式</strong></p>\n    <table width=\"90%\" border=\"1\">\n        <thead>\n            <tr>\n                <th>\n                    <p>模式</p>\n                </th>\n                <th>\n                    <p>方法</p>\n                </th>\n                <th>\n                    <p>Go 语言的 API</p>\n                </th>\n            </tr>\n        </thead>\n        <tbody>\n            <tr>\n                <td>\n                    <p>使用 <code>GET</code> 获取信息</p>\n                </td>\n                <td>\n                    <p><code>GET</code></p>\n                </td>\n                <td>\n                    <p><code>http.Get</code></p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p>获取带查询的信息</p>\n                </td>\n                <td>\n                    <p><code>GET</code></p>\n                </td>\n                <td>\n                    <p><code>http.Get</code></p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p>使用 <code>HEAD</code> 获取首部</p>\n                </td>\n                <td>\n                    <p><code>HEAD</code></p>\n                </td>\n                <td>\n                    <p><code>http.Head</code></p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p>使用 <code>x-www-form-urlencoded</code> 发送表单</p>\n                </td>\n                <td>\n                    <p><code>POST</code></p>\n                </td>\n                <td>\n                    <p><code>http.PostForm</code></p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p>使用 <code>POST</code> 发送文件</p>\n                </td>\n                <td>\n                    <p><code>POST</code></p>\n                </td>\n                <td>\n                    <p><code>http.Post</code></p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p>使用 <code>multipart</code>/<code>form-data</code> 发送文件</p>\n                </td>\n                <td>\n                    <p><code>POST</code></p>\n                </td>\n                <td>\n                    <p><code>http.PostForm</code></p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p>发送和接收 Cookie</p>\n                </td>\n                <td>\n                    <p><code>GET</code>、<code>HEAD</code>、<code>POST</code></p>\n                </td>\n                <td>\n                    <p><code>http.Client</code></p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p>代理</p>\n                </td>\n                <td>\n                    <p><code>GET</code>、<code>HEAD</code>、<code>POST</code></p>\n                </td>\n                <td>\n                    <p><code>http.Client</code></p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p>访问文件系统</p>\n                </td>\n                <td>\n                    <p><code>GET</code>、<code>HEAD</code>、<code>POST</code></p>\n                </td>\n                <td>\n                    <p><code>http.Client</code></p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p>发送任意方法</p>\n                </td>\n                <td>\n                    <p>所有</p>\n                </td>\n                <td>\n                    <p><code>http.Request</code>、<code>http.Client</code></p>\n                </td>\n            </tr>\n            <tr>\n                <td>\n                    <p>发送首部</p>\n                </td>\n                <td>\n                    <p>所有</p>\n                </td>\n                <td>\n                    <p><code>http.Request</code>、<code>http.Client</code></p>\n                </td>\n            </tr>\n        </tbody>\n    </table>\n    <p>表 3-1 中的前 6 项使用简单的 API，接下来笔者会首先介绍这部分内容，之后介绍用于把 Cookie 和代理设置为有效的 <code>http.Client</code> 的使用方法，最后介绍可以访问所有功能的\n        API，即 <code>http.Request</code> 和 <code>http.Client</code> 的组合。</p>\n    <p>很多读者可能使用的并不是 Go 语言，但各种编程语言的库基本上会提供与常用的 <code>GET</code> 和 <code>POST</code> 相关的 API 和专用方法，然后追加提供可以访问所有功能的 API。\n    </p>\n    <h2 id=\"nav_point_81\">3.4　GET 方法的发送及主体、状态码和首部的接收</h2>\n    <p>首先来看最简单的发送 <code>GET</code> 方法的代码，它与下面的 curl 命令是等价的。</p>\n    <pre class=\"code-rows\"><code>$ curl http://localhost:18888</code></pre>\n    <p>代码清单 3-1 中的代码用于发送 <code>GET</code> 方法，并将响应主体输出到画面上。代码中也包含了错误处理。这是保持良好运行的最低限度的代码。</p>\n    <p><strong>代码清单 3-1　发送 GET 方法，并将响应主体输出到画面上</strong></p>\n    <pre class=\"code-rows\"><code>package main                // ❶\n\nimport (                    // ❷\n    \"io/ioutil\"\n    \"log\"\n    \"net/http\"\n)\n\nfunc main() {                // ❸\n    resp, err := http.Get(\"http://localhost:18888\")\n    if err != nil {          // ❹\n        panic(err)\n    }\n    defer resp.Body.Close()  // ❺\n    body, err := ioutil.ReadAll(resp.Body) // ❻\n    if err != nil {          // ❹\n        panic(err)\n    }\n    log.Println(string(body))  // ❼\n}</code></pre>\n    <blockquote>\n        <p>❶ 库之外的源代码必须以 <code>package main</code> 开始。</p>\n        <p>❷ 导入需要用到的包。在 Go 语言中，无法使用文件中未声明的包。</p>\n        <p>❸ 所有程序在最开始都会调用 <code>main</code> 包（❶ 中创建的包）中的 <code>main</code> 函数。</p>\n        <p>❹ Go 语言的错误处理代码。Go 语言的函数会将错误作为返回值返回，因此需要确认返回值是否为 <code>nil</code>。这里没有异常处理。<code>panic</code>\n            用来显示错误并结束程序。库擅自结束程序会给使用的应用程序带来麻烦，因此在打包为库时，Go 语言通常会像 <code>http.Get()</code> 那样，将错误作为返回值的最终项返回。</p>\n        <p>❺ 这是后处理的代码。如果加上 <code>defer</code>，在跳出 <code>main</code> 函数后，就会执行该语句。这是通过套接字读取主体之后的处理。</p>\n        <p>❻ 将主体内容读取为字节序列。</p>\n        <p>❼ 将字节序列转换为 UTF-8 字符串并输出到画面上。</p>\n    </blockquote>\n    <p>&nbsp;</p>\n    <blockquote>\n        <p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100009/image00380.jpeg\" alt=\"\" width=\"5%\" style=\"width: 5%\" inline-img=\"true\" />　关于 ❺ 处的\n            <code>defer</code>，虽然运行的时间点不一样，但与资源的创建（接收）在相同的作用域内，所以可以利用 <code>defer</code> 机制编写结束处理，或者使其自动执行。在 C++\n            中，可以通过调用本地的析构函数，使用智能指针（smart pointer）来销毁栈。在 Ruby 中，可以像 <code>File.open</code> 方法那样使用代码块。在 Python 中，可以使用\n            <code>with</code> 语法结构。在异常处理中，无论是否发生错误，<code>finally</code> 代码块都会被调用。拥有这种 <code>finally</code> 代码块的语言也会使用\n            <code>defer</code>。</p>\n    </blockquote>\n    <p>在 <code>simpleget</code> 文件夹中，创建一个名为 <code>main.go</code> 的文件（文件名任意），输入前面的代码，然后像下面这样在 <code>simpleget</code>\n        文件夹中进行编译。这里会生成一个与文件夹同名的执行文件，我们试着运行这个执行文件。</p>\n    <pre class=\"code-rows\"><code>$ go build\n$ ./simpleget</code></pre>\n    <p>在 Windows 中，程序如下运行。</p>\n    <pre class=\"code-rows\"><code>&gt; go build\n&gt; simpleget.exe</code></pre>\n    <p>如果像下面这样启动，则也可以像脚本语言一样，在运行时不关心编译内容。</p>\n    <pre class=\"code-rows\"><code>$ go run main.go</code></pre>\n    <p>代码清单 3-2 中的代码省略了错误检查，更加简短。</p>\n    <p><strong>代码清单 3-2　无错误检查的代码</strong></p>\n    <pre class=\"code-rows\"><code>package main\n\nimport (\n    \"io/ioutil\"\n    \"log\"\n    \"net/http\"\n)\n\nfunc main() {\n    resp, _ := http.Get(\"http://localhost:18888\")\n    defer resp.Body.Close()\n    body, _ := ioutil.ReadAll(resp.Body)\n    log.Println(string(body))\n}</code></pre>\n    <p><code>resp</code> 变量中保存的元素是 <code>http.Response</code> 类型的对象。该对象中保存着从服务器返回的各种信息。主体保存在成员变量 <code>Body</code>\n        中，<code>StatusCode</code> 中使用 <code>200</code> 之类的数值来保存状态码，<code>Status</code> 中使用 <code>\"200 OK\"</code>\n        之类的字符串来保存状态码。将代码清单 3-3 的代码插入到 <code>resp</code> 变量的定义后面，就会在控制台上显示状态码。</p>\n    <p><strong>代码清单 3-3　在控制台上显示状态码</strong></p>\n    <pre class=\"code-rows\"><code>// 字符串 \"200 OK\"\nlog.Println(\"Status:\", resp.Status)\n// 数值 200\nlog.Println(\"StatusCode:\", resp.StatusCode)</code></pre>\n    <p>同样，<code>resp.Header</code> 中保存着首部。首部是字符串数组 <code>map</code> 类型。下面这行代码用于在控制台上输出响应首部。</p>\n    <p><strong>输出响应首部</strong><br /><code>log.Println(\"Headers:\", resp.Header)</code></p>\n    <p>也存在仅获取指定项目的开头元素的 <code>GET</code> 方法，如下所示。</p>\n    <p><strong>获取指定的首部</strong><br /><code>log.Println(\"Content-Length:\", resp.Header.Get(\"Content-Length\"))</code></p>\n    <p>运行结果如下所示。</p>\n    <pre class=\"code-rows\"><code>2016/06/08 01:43:38 &lt;html&gt;&lt;body&gt;hello&lt;/body&gt;&lt;/html&gt;\n2016/06/08 01:43:38 Status: 200 OK\n2016/06/08 01:43:38 StatusCode: 200\n2016/06/08 01:43:38 Headers: map[Date:[Tue, 07 Jun 2016 16:43:38 GMT] Content-\nLength:[32] Content-Type:[text/html; charset=utf-8]]\n2016/06/08 01:43:38 Content-Length: 32</code></pre>\n    <p><code>http.Get()</code> 函数是一种高级 API，即使什么也不指定，也可以用它进行 10 次重定向等，而无须关心与浏览器的动作的差别。</p>\n    <h3 id=\"nav_point_82\">io.Reader</h3>\n    <p>代码清单 3-1 中存在如下代码。</p>\n    <p><strong>读取整个主体数据，返回字节数组</strong><br /><code>body, err := ioutil.ReadAll(resp.Body) // ❻</code></p>\n    <p>在 Go 语言中，数据流的输入和输出会抽象化为 <code>io.Reader</code> 接口和 <code>io.Writer</code>\n        接口。文件和套接字等处都会用到这些接口。<code>http.Response</code> 类型的变量 <code>resp</code> 的成员变量 <code>Body</code> 也是一个持有\n        <code>io.Reader</code> 接口的对象。</p>\n    <p>准备一个字节数组的缓冲区，并调用 <code>Read()</code> 方法，即可直接处理 <code>io.Reader</code>。<code>io.Writer()</code>\n        也一样，只需准备一个字节数组，然后调用 <code>Write()</code> 方法即可。它们都是原生的，因此实际中如果这样使用，代码行数就会增多。Go 语言提供了既能处理文件又能处理套接字的许多高级功能。</p>\n    <blockquote>\n        <p><code>func ioutil.ReadAll(reader io.Reader) ([]byte, error)</code></p>\n        <p>汇总 <code>io.Reader</code> 的内容，并将其读入字节数组。</p>\n        <p><code>func Copy(dst io.Writer, src io.Reader) (written int64, err error)</code></p>\n        <p>将所有内容从 <code>io.Reader</code> 复制到 <code>io.Writer</code> 中。</p>\n        <p><code>bufio.NewReader(reader io.Reader) *bufio.Reader</code></p>\n        <p>包装 <code>io.Reader</code>，添加缓冲结构，创建能够新增许多便捷方法的对象。</p>\n        <p><code>bytes.Buffer</code></p>\n        <p>能够读写内存，并且可用作 <code>io.Reader</code> 和 <code>io.Writer</code>。</p>\n        <p><code>strings.Reader</code></p>\n        <p>能够读取字符串，并且可用作 <code>io.Reader</code>。</p>\n    </blockquote>\n    <p>另外，以下函数也很常用。</p>\n    <blockquote>\n        <p><code>fmt.Fprintf(writer io.Writer, format string, ... variant{})</code></p>\n        <p>将格式化的字符串写出到 <code>io.Writer</code> 中。</p>\n    </blockquote>\n    <p>Go 语言拥有通过组合使用接口来提高代码抽象度的结构。因为我们需要记住一些库，所以一开始可能感觉比较难，不过熟悉之后，就可以对所有的输入和输出目标执行高级操作了 <span class=\"comment-number\">2</span>。</p>\n    \n    <h2 id=\"nav_point_83\">3.5　使用 GET 方法发送查询</h2>\n    <p>接下来介绍如何使用 <code>GET</code> 方法发送查询。我们来编写与下面的 curl 命令基本等价的代码。</p>\n    <pre class=\"code-rows\"><code>$ curl -G --data-urlencode \"query=hello world\" http://localhost:18888</code></pre>\n    <p>如果查询中没有空格或不可以在 URL 中使用的字符，就可以使用 <code>--data</code> 或者其缩写 <code>-d</code> 来代替\n        <code>--data-urlencode</code>。<code>-G</code> 是 <code>--get</code> 的缩写。</p>\n    <p>代码清单 3-4 是使用 Go 语言实现的代码。</p>\n    <p><strong>代码清单 3-4　使用 GET 方法发送查询</strong></p>\n    <pre class=\"code-rows\"><code>package main\n\nimport (\n    \"io/ioutil\"\n    \"log\"\n    \"net/http\"\n    \"net/url\"\n)\n\nfunc main() {\n    values := url.Values{    // ❶\n        \"query\": {\"hello world\"},\n    }\n    // ❷\n    resp, _ := http.Get(\"http://localhost:18888\" + \"?\" + values.Encode())\n    defer resp.Body.Close()\n    body, _ := ioutil.ReadAll(resp.Body)\n    log.Println(string(body))\n}</code></pre>\n    <blockquote>\n        <p>❶ 首先，创建查询字符串。查询字符串使用 <code>url.Values</code> 类型进行声明，调用 <code>value.Encode()</code> 方法来创建。字符串的转义也由该方法执行。</p>\n        <p>❷ 最后，在 URL 的末尾添加结果字符串。</p>\n    </blockquote>\n    <p>如下所示，查看服务器端的日志就可以发现，URL 中附加了查询。另外，我们还能得知查询被正确传递，成了字符串数组的映射。</p>\n    <p><strong>接收查询的服务器端的日志</strong></p>\n    <pre class=\"code-rows\"><code>URL: \"/?query=hello+world\"\nQuery: {\n    \"query\": []string{\n        \"hello world\",\n    },\n}</code></pre>\n    <h2 id=\"nav_point_84\">3.6　使用 HEAD 方法获取首部</h2>\n    <p><code>HEAD</code> 方法的实现很简单，只要将 <code>http.Get</code> 替换为 <code>http.Head()</code> 即可。下面的 curl 命令也可实现\n        <code>HEAD</code> 方法的处理。</p>\n    <pre class=\"code-rows\"><code>$ curl --head http://localhost:18888</code></pre>\n    <p><strong>代码清单 3-5　发送 HEAD 方法来获取首部</strong></p>\n    <pre class=\"code-rows\"><code>package main\n\nimport (\n    \"log\"\n    \"net/http\"\n)\n\nfunc main() {\n    resp, err := http.Head(\"http://localhost:18888\")\n    if err != nil {\n        panic(err)\n    }\n    log.Println(\"Status:\", resp.Status)\n    log.Println(\"Headers:\", resp.Header)\n}</code></pre>\n    <p>正如 <code>HEAD</code> 方法定义的那样，它无法获取主体。如果像 <code>GET</code> 方法那样读取主体，虽然不会发生错误，但会得到一个长度为 0 的字节数组。</p>\n    <h2 id=\"nav_point_85\">3.7　使用 POST 方法发送 x-www-form-urlencoded 形式的表单</h2>\n    <p>笔者最开始介绍了如何使用 <code>GET</code> 方法实现与普通的 Web 浏览器相同的操作，然后介绍了如何使用 <code>GET</code> 方法发送查询。从本节到 3.9 节，笔者将介绍 HTTP/1.0\n        中使用 <code>POST</code> 方法发送表单的相关内容。本节主要介绍在未改变编码的情况下，如何使用默认的 <code>x-www-form-urlencoded</code> 形式发送表单。</p>\n    <p>我们来回顾一下第 2 章的内容。在使用 curl 命令以与 <code>x-www-form-urlencoded</code> 相同的形式发送表单时，使用如下命令。</p>\n    <pre class=\"code-rows\"><code>$ curl -d test=value http://localhost:18888</code></pre>\n    <p>实际的 Go 语言代码如代码清单 3-6 所示。由于该代码仅进行发送，所以访问发送结果的主体等的相关内容请参考其他代码。</p>\n    <p><strong>代码清单 3-6　发送 x-www-form-urlencoded 形式的表单</strong></p>\n    <pre class=\"code-rows\"><code>package main\n\nimport (\n    \"log\"\n    \"net/http\"\n    \"net/url\"\n)\n\nfunc main() {\n    values := url.Values{\n        \"test\": {\"value\"},\n    }\n\n    resp, err := http.PostForm(\"http://localhost:18888\", values)\n    if err != nil {\n        // 发送失败\n        panic(err)\n    }\n    log.Println(\"Status:\", resp.Status)\n}</code></pre>\n    <p>上面的代码中再次出现了 <code>url.Values</code>，但这里并未调用 <code>url.Values.Encode()</code> 方法，而是将 <code>url.Values</code> 传递给了\n        <code>http.PostForm()</code> 函数。第 2 章开头介绍过使用 <code>x-www-form-urlencode</code> 发送表单的相关内容，其中提到了 URL 编码可分为两类，但如果在\n        Go 语言中使用这种调用方法，就会执行基于 RFC 3986 的转换。</p>\n    <h2 id=\"nav_point_86\">3.8　使用 POST 方法发送任意主体</h2>\n    <p>使用 <code>POST</code> 方法可以将任意内容放入主体中发送。虽然无法使用 HTTP/1.0 的浏览器发送主体，但可以使用 HTTP/1.1 之后出现的 <code>XMLHttpRequest</code>\n        来实现。由于在介绍如何编写发送 multipart 表单的代码时需要用到这些内容，所以笔者提前对此进行介绍。</p>\n    <p>使用 curl 命令发送从文件中读取的任意内容的代码如下所示。</p>\n    <pre class=\"code-rows\"><code>$ curl -T main.go -H \"Content-Type: text/plain\" http://localhost:18888</code></pre>\n    <p>代码清单 3-7 是使用 Go 语言实现上述处理的代码。</p>\n    <p><strong>代码清单 3-7　使用 POST 方法发送任意的主体</strong></p>\n    <pre class=\"code-rows\"><code>package main\n\nimport (\n    \"log\"\n    \"net/http\"\n    \"os\"\n)\n\nfunc main() {\n    file, err := os.Open(\"main.go\")\n    if err != nil {\n        panic(err)\n    }\n    resp, err := http.Post(\"http://localhost:18888\", \"text/plain\", file)\n    if err != nil {\n        // 发送失败\n        panic(err)\n    }\n    log.Println(\"Status:\", resp.Status)\n}</code></pre>\n    <p><code>http.Post()</code> 方法的第 2 个参数中指定了 <code>Content-Type</code> 首部的内容。另外，发送的内容并不是采用文本形式传递的，而是采用了\n        <code>io.Reader</code> 的形式。<code>os.Open()</code> 函数创建的 <code>os.File</code> 对象属于 <code>io.Reader</code>\n        接口，因此可以直接传递给 <code>http.Post()</code>。</p>\n    <p>在将程序中创建的文本（而不是文件）传递给 <code>http.Post</code> 时，如代码清单 3-8 所示，使用 <code>bytes.Buffer</code> 或\n        <code>strings.Reader</code> 将字符串实现为 <code>io.Reader</code> 接口。</p>\n    <p><strong>代码清单 3-8　将字符串实现为 io.Reader 接口</strong></p>\n    <pre class=\"code-rows\"><code>package main\n\nimport (\n    \"log\"\n    \"net/http\"\n    \"strings\"\n)\n\nfunc main() {\n    reader := strings.NewReader(\" 文本\")\n    resp, err := http.Post(\"http://localhost:18888\", \"text/plain\", reader)\n    if err != nil {\n        // 发送失败\n        panic(err)\n    }\n    log.Println(\"Status:\", resp.Status)\n}</code></pre>\n    <h2 id=\"nav_point_87\">3.9　使用 multipart/form-data 形式发送文件</h2>\n    <p>在 HTTP/1.0 的 HTML 中，最复杂的发送处理就是使用 <code>multipart/form-data</code> 发送文件，相应的 curl 命令如下所示。</p>\n    <pre&#10; class=\"code-rows\"><code>$ curl -F \"name=Michael Jackson\" -F \"thumbnail=@photo.jpg\" http://localhost:18888</code>\n    <p>该 curl 命令用于发送文本数据和文件。使用 Go 语言实现这一处理的代码如代码清单 3-9 所示。</p>\n    <p><strong>代码清单 3-9　使用 multipart/form-data 形式发送文件</strong></p>\n    <pre class=\"code-rows\"><code>package main\n\nimport (\n    \"bytes\"\n    \"io\"\n    \"log\"\n    \"mime/multipart\"\n    \"net/http\"\n    \"os\"\n)\n\nfunc main() {\n    var buffer bytes.Buffer                // ❶\n    writer := multipart.NewWriter(&amp;buffer) // ❷\n    writer.WriteField(\"name\", \"Michael Jackson\")       // ❸\n    // ❹\n    fileWriter, err := writer.CreateFormFile(\"thumbnail\", \"photo.jpg\")\n    if err != nil {\n        panic(err)\n    }\n    readFile, err := os.Open(\"photo.jpg\")   // ❺\n    if err != nil {\n        // 文件读取失败\n        panic(err)\n    }\n    defer readFile.Close()\n    io.Copy(fileWriter, readFile)           // ❻\n    writer.Close()                          // ❼\n\n    resp, err := http.Post(\"http://localhost:18888\", writer.FormDataContentType(),\n&amp;buffer)\n    if err != nil {\n        // 发送失败\n        panic(err)\n    }\n    log.Println(\"Status:\", resp.Status)\n}</code></pre>\n    <blockquote>\n        <p>❶ 声明缓冲区，用来存储 multipart 部分构建后的字节序列。</p>\n        <p>❷ 创建 <code>Writer</code>，用来构建 multipart。</p>\n        <p>❸ 文件以外的字段通过 <code>WriteField()</code> 方法进行登录。</p>\n        <p>❹ ❹ ~ ❻ 是文件的读取操作。首先创建写入单个文件的 <code>io.Writer</code>。</p>\n        <p>❺ 打开文件。</p>\n        <p>❻ 使用 <code>io.Copy()</code>，将文件的所有内容复制到用于写入文件的 <code>io.Writer</code> 中。</p>\n        <p>❼ 最后关闭 multipart 的 <code>io.Writer</code>，将所有内容写入到缓冲区中。</p>\n    </blockquote>\n    <p>之后，像上一节一样使用 <code>http.Post()</code> 发送该缓冲区，就可以发送表单了。</p>\n    <p>代码行数有点多。最开始在作为 <code>io.Reader</code> 的 <code>bytes.Buffer</code> 中创建了 multipart 表单的发送内容。创建该内容时使用的是\n        <code>multipart.Writer</code> 对象。当通过该对象写入表单项和文件时，表单项和文件就会写入到作为 <code>multipart.NewWriter()</code> 的参数传递的\n        <code>bytes.Buffer</code> 中。这个 <code>bytes.Buffer</code> 既是 <code>io.Reader</code>，又是 <code>io.Writer</code>。\n    </p>\n    <p><code>Content-Type</code> 中需要放入边界字符串。边界字符串是 <code>multipart.Writer</code> 对象在内部使用随机数生成的。边界字符串可以通过\n        <code>Boundary()</code> 方法获取，因此，我们也可以按照代码清单 3-10 的方法构建\n        <code>Content-Type</code>。<code>FormDataContentType()</code> 方法是该代码的“快捷方式”。</p>\n    <p><strong>代码清单 3-10　与 FormDataContentType() 作用相同的代码</strong></p>\n    <pre class=\"code-rows\"><code>\"multipart/form-data; boundary=\" + writer.Boundary()</code></pre>\n    <h3 id=\"nav_point_88\">对发送的文件设置任意的 MIME 类型</h3>\n    <p>上一节介绍的代码可以用来发送文件，不过各个文件的 <code>Content-Type</code> 实际变成了 <code>application/octet-stream</code> 类型。我们可以使用\n        <code>textproto.MIMEHeader</code> 来设置任意的 MIME 类型 <span class=\"comment-number\">3</span>。试着对代码清单 3-9 中 ❹ ~ ❻ 的部分进行改写，将 MIME\n        类型设置为 <code>image/jpeg</code>，改写的部分如代码清单 3-11 所示。</p>\n    \n    <p><strong>代码清单 3-11　将 MIME 类型设置为 image/jpeg</strong></p>\n    <pre class=\"code-rows\"><code>import (\n     \"net/textproto\"\n)\n︙\npart := make(textproto.MIMEHeader)\npart.Set(\"Content-Type\", \"image/jpeg\")\npart.Set(\"Content-Disposition\", `form-data; name=\"thumbnail\"; filename=\"photo.jpg\"`)\nfileWriter, err := writer.CreatePart(part)\nif err != nil {\n    panic(err)\n}\nreadFile, err := os.Open(\"photo.jpg\")\nif err != nil {\n    panic(err)\n}\nio.Copy(fileWriter, readFile)\n︙</code></pre>\n    <p>上一节使用的 <code>multipart.Writer.WriteField()</code> 方法和 <code>multipart.Writer.CreateFormFile()</code> 方法属于高级\n        API，可以在不直接操作 multipart 的构成元素的情况下创建内容，各部分持有的首部也可以自动设置。代码清单 3-11 中的代码是通过抽出各个方法中执行的详细处理来指定任意的\n        <code>Content-Type</code> 的。</p>\n    <h2 id=\"nav_point_89\">3.10　Cookie 的发送和接收</h2>\n    <p>前面介绍的代码仅执行一次发送 HTTP 的请求。HTTP 是无状态的，因此每次发送请求时使用的函数之间不会相互影响。如果服务器未持有状态，那么即使改变函数的调用顺序，结果也不会发生改变。</p>\n    <p>在使用 Cookie 的情况下，浏览器内部必须持有状态，这时就需要使用 <code>http.Client</code> 结构体，而不是前面介绍的各个函数，如代码清单 3-12 所示。</p>\n    <p><strong>代码清单 3-12　Cookie 的发送和接收</strong></p>\n    <pre class=\"code-rows\"><code>package main\n\nimport (\n    \"log\"\n    \"net/http\"\n    \"net/http/cookiejar\"\n    \"net/http/httputil\"\n)\n\nfunc main() {\n    jar, err := cookiejar.New(nil)   // ❶\n    if err != nil {\n        panic(err)\n    }\n    client := http.Client{           // ❷\n        Jar: jar,\n    }\n    for i := 0; i &lt; 2; i++ {         // ❸\n        // ❹\n        resp, err := client.Get(\"http://localhost:18888/cookie\")\n        if err != nil {\n            panic(err)\n        }\n        dump, err := httputil.DumpResponse(resp, true)\n        if err != nil {\n            panic(err)\n        }\n        log.Println(string(dump))\n    }\n}</code></pre>\n    <blockquote>\n        <p>❶ 创建 <code>cookiejar</code>（Cookie 容器）的实例来保存 Cookie。</p>\n        <p>❷ 创建可保存 Cookie 的 <code>http.Client</code> 实例。</p>\n        <p>❸ 由于 Cookie 的结构是客户端第一次访问服务器时接收 Cookie，第二次及之后访问时向服务器发送 Cookie，因此这里进行两次访问。</p>\n        <p>❹ 使用所创建的客户端的 <code>Get()</code> 方法（而非 <code>http.Get()</code>）进行访问。</p>\n    </blockquote>\n    <p><code>net/http/cookiejar</code> 是作为内置库实现的 Cookie 的一个功能。Go 语言的 <code>http.Client</code> 将实现\n        <code>http.CookieJar</code> 接口的任意对象用作处理 Cookie 的后台。因为在默认的实现中，Cookie 仅保存在内存中，所以当程序再次启动时，Cookie 就被删掉了。标准库中并未提供可以将\n        Cookie 永久保存在文件中的实现，因此我们需要使用第三方实现，或者自己动手进行实现。</p>\n    <p><code>http.Client</code> 结构体与 <code>http</code> 包一样，也实现了\n        <code>Get()</code>、<code>Head()</code>、<code>Post()</code> 和\n        <code>PostForm()</code>，我们可以直接按照前面介绍的方法使用这些函数。<code>http</code> 包中的大部分函数在内部成了默认的 <code>http.Client</code>\n        结构体实例的各个方法的别名。像代码清单 3-13 那样改写默认的客户端可以使 Cookie 有效。当然，这会影响该流程中 <code>net/http</code>\n        包的运行，因此在改写默认的客户端时要注意其影响范围，比如只在可通过批处理立刻执行完毕的程序中执行该操作。</p>\n    <p><strong>代码清单 3-13　改写默认的客户端，使 Cookie 有效</strong></p>\n    <pre class=\"code-rows\"><code>http.DefaultClient = &amp;http.Client{\n    Jar: jar,\n}\n︙\nresp, err := http.Get(\"http://localhost:18888/cookie\")</code></pre>\n    <p>在本书中，我们主要通过赋初始值来创建 Go 语言的对象，如代码清单 3-14 所示。</p>\n    <p><strong>代码清单 3-14　使用 Go 语言创建对象的方法</strong></p>\n    <pre class=\"code-rows\"><code>// 通过赋初始值来创建\na := Struct{\n    Member: \"Value\",\n}\n\n// 使用 new() 函数进行初始化\na := new(Struct)\n\n// 使用 make() 函数进行初始化\n// 数组切片、映射和通道专用\na := make(map[string]string)\n\n// 使用库提供的构造函数来创建\n// 内部使用上述其中一种语法\na := library.New()</code></pre>\n    <p>具体来说有两种做法：一种是结构体使用 <code>{}</code> 赋初始值，创建实例；另一种是使用 <code>new()</code> 函数进行初始化。另外，内置类型的数组切片、映射和通道使用\n        <code>make()</code> 函数进行初始化。在设置任意的 MIME 类型的示例代码中出现的 <code>textproto.MIMEHeader</code> 是 <code>map</code>\n        的别名，因此也使用 <code>make()</code> 函数。最后的方法是使用库提供的构造函数，当然其内部也使用了前面几种语法之一。</p>\n    <h2 id=\"nav_point_90\">3.11　使用代理</h2>\n    <p>在使用代理时也会用到 <code>http.Client</code>。在 Cookie 的情况下，可以通过设置 <code>Jar</code> 成员变量而使其有效，但这里使用的是\n        <code>Transport</code>。<code>Transport</code> 是进行实际的通信的后台。下面是设置代理的 curl 命令。</p>\n    <pre class=\"code-rows\"><code>$ curl -x http://localhost:18888 http://github.com</code></pre>\n    <p>等价的 Go 语言代码如代码清单 3-15 所示。</p>\n    <p><strong>代码清单 3-15　通过 Transport 使用代理</strong></p>\n    <pre class=\"code-rows\"><code>package main\n\nimport (\n    \"log\"\n    \"net/http\"\n    \"net/http/httputil\"\n    \"net/url\"\n)\n\nfunc main() {\n    proxyUrl, err := url.Parse(\"http://localhost:18888\")\n    if err != nil {\n        panic(err)\n    }\n    client := http.Client{\n        Transport: &amp;http.Transport{\n            Proxy: http.ProxyURL(proxyUrl),\n        },\n    }\n    resp, err := client.Get(\"http://github.com\")\n    if err != nil {\n        panic(err)\n    }\n    dump, err := httputil.DumpResponse(resp, true)\n    if err != nil {\n        panic(err)\n    }\n    log.Println(string(dump))\n}</code></pre>\n    <p>虽然 <code>client.Get()</code>\n        的访问目标是外部站点，但代理指向的是本地的测试服务器。在运行上面的代码后，请求并没有被直接发送到外部，而是由本地服务器暂时接收。但由于本地服务器会直接返回响应，所以使用该代码并不能访问\n        <code>github.com</code>。</p>\n    <p>如果将代理的 URL 改为代码清单 3-16 的形式，就可以赋上 BASIC 认证中的用户名和密码了。</p>\n    <p><strong>代码清单 3-16　给代理设置 BASIC 认证信息</strong></p>\n    <pre class=\"code-rows\"><code>http://用户名:密码@github.com</code></pre>\n    <p>因为 <code>http.Client</code> 默认使用的代理参数会从环境变量中获取信息并设置代理，所以在设置了各种程序共用的环境变量的 <code>HTTP_PROXY</code> 和\n        <code>HTTPS_PROXY</code> 的情况下，客户端就会向环境变量中设置的代理发送请求。另外，在 <code>NO_PROXY</code>\n        中写上略去设置的主机名，客户端就可以在不经过代理的情况下直接与所设置的主机进行通信。</p>\n    <p>与使用 Cookie 时相同，如果像代码清单 3-17 那样添加代码，将 <code>http.Client</code> 中 <code>Transport</code> 类型的成员变量设置为\n        <code>http</code> 包的 <code>DefaultTransport</code>，<code>http.Get()</code> 等全局函数就可以使用代理了。</p>\n    <p><strong>代码清单 3-17　让全局函数也能使用代理</strong></p>\n    <pre class=\"code-rows\"><code>http.DefaultTransport = &amp;http.Transport{\n    Proxy: http.ProxyURL(proxyUrl),\n}</code></pre>\n    <blockquote>\n        <p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100009/image00380.jpeg\" alt=\"\" width=\"5%\" style=\"width: 5%\" inline-img=\"true\" />　mattn 的博客中介绍了如何通过 Go 语言使用\n            Internet Explorer 中设置的代理信息（仅限于 Windows）。</p>\n    </blockquote>\n    <h2 id=\"nav_point_91\">3.12　访问文件系统</h2>\n    <p>第 1 章在介绍 HTTP/1.0 时提到了 URL 结构中的方案。到目前为止的程序访问的都是 <code>http</code> 或 <code>https</code> 方案。<code>file</code>\n        方案用于访问本地文件。如果执行下面的 curl 命令，作业文件夹中的文件内容就会输出到控制台上。</p>\n    <pre class=\"code-rows\"><code>$ curl file://main.go</code></pre>\n    <p>通信后台的 <code>http.Transport</code> 中存在 <code>RegisterProtocol</code> 方法，该方法用来添加这些方案之外的方案所用的\n        <code>Transport</code>。<code>http.NewFileTransport()</code> 是用于文件访问的后台。使用这些方法和后台就可以访问本地文件。与前面示例中 URL\n        的记述方法稍有不同，本地文件的内容会存储在响应主体中返回（代码清单 3-18）。</p>\n    <p><strong>代码清单 3-18　访问本地文件</strong></p>\n    <pre class=\"code-rows\"><code>package main\n\nimport (\n    \"log\"\n    \"net/http\"\n    \"net/http/httputil\"\n)\n\nfunc main() {\n    transport := &amp;http.Transport{}\n    transport.RegisterProtocol(\"file\", http.NewFileTransport(http.Dir(\".\")))\n    client := http.Client{\n        Transport: transport,\n    }\n    resp, err := client.Get(\"file://./main.go\")\n    if err != nil {\n        panic(err)\n    }\n    dump, err := httputil.DumpResponse(resp, true)\n    if err != nil {\n        panic(err)\n    }\n    log.Println(string(dump))\n}</code></pre>\n    <h2 id=\"nav_point_92\">3.13　发送任意方法</h2>\n    <p>前面的代码使用的都是 <code>http</code> 模块的函数或者 <code>http.Client</code> 结构体的方法，这些方法仅支持 <code>GET</code>、<code>HEAD</code> 和\n        <code>POST</code>。当使用其他方法发送请求时，需要使用 <code>http.Request</code> 结构体的对象。使用下面的 curl 命令可以发送 <code>DELETE</code> 方法。\n    </p>\n    <pre class=\"code-rows\"><code>$ curl -X DELETE http://localhost:18888</code></pre>\n    <p>代码清单 3-19 是使用 Go 语实现的代码。</p>\n    <p><strong>代码清单 3-19　使用 http.Request 结构体发送 DELETE 方法</strong></p>\n    <pre class=\"code-rows\"><code>package main\n\nimport (\n    \"log\"\n    \"net/http\"\n    \"net/http/httputil\"\n)\n\nfunc main() {\n    client := &amp;http.Client{}\n    request, err := http.NewRequest(\"DELETE\", \"http://localhost:18888\", nil)\n    if err != nil {\n        panic(err)\n    }\n    resp, err := client.Do(request)\n    if err != nil {\n        panic(err)\n    }\n    dump, err := httputil.DumpResponse(resp, true)\n    if err != nil {\n        panic(err)\n    }\n    log.Println(string(dump))\n}</code></pre>\n    <p><code>http.Request</code> 结构体是通过构造函数 <code>http.NewRequest()</code> 创建的。函数的参数为方法、URL 和主体。与 <code>POST</code>\n        一样，主体中可以使用 <code>io.Reader</code>。因此，本章介绍的发送文件的代码和发送 multipart 表单的代码都可以直接使用。要想转换为通过 <code>PostForm</code>\n        发送的形式，就需要将 <code>url.Values</code> 转换为符合 <code>io.Reader</code> 接口的对象，如代码清单 3-20 所示。</p>\n    <p><strong>代码清单 3-20　转换为使用 PostForm 发送结构体的形式</strong></p>\n    <pre class=\"code-rows\"><code>import (\n    \"strings\"   // 添加该内容\n    \"net/url\"\n)\n\nvalues := url.Values{\"test\": {\"value\"}}\nreader := strings.NewReader(values.Encode())</code></pre>\n    <h2 id=\"nav_point_93\">3.14　发送首部</h2>\n    <p>最后，我们来看一下如何发送首部。在 curl 命令中，需要指定 <code>-H</code> 选项来发送首部。</p>\n    <pre class=\"code-rows\"><code>$ curl -H \"Content-Type=image/jpeg\" -d \"@image.jpeg\" http://localhost:18888</code></pre>\n    <p>用于发送任意方法的 <code>http.Request</code> 结构体持有 <code>Header</code> 字段，它与 <code>http.Response</code> 结构体的\n        <code>Header</code> 字段是同一个字段。<code>GET</code> 方法的示例代码中使用了 <code>Get()</code> 方法来获取首部的值，而添加首部需要使用\n        <code>Add()</code> 方法。</p>\n    <pre class=\"code-rows\"><code>// 添加首部\nrequest.Header.Add(\"Content-Type\", \"image/jpeg\")</code></pre>\n    <p>curl 命令中为特定的首部提供了便捷选项，比如用于 BASIC 认证的“<code>--basic –u 用户名 : 密码</code>”选项，以及用于 Cookie 的“<code>-c 文件</code>”选项等。Go\n        语言中也提供了类似的辅助方法作为 <code>http.Request</code> 结构体的方法，具体如下所示。</p>\n    <pre class=\"code-rows\"><code>// BASIC 认证\nrequest.SetBasicAuth(\" 用户名\", \" 密码\")\n// 手动添加一个 Cookie\nrequest.AddCookie(&amp;http.Cookie)</code></pre>\n    <p>即使首部中未设置 Cookie，也可以通过在 <code>http.Client</code> 的 <code>Jar</code> 中设置 <code>cookiejar.Jar</code> 的实例来发送和接收\n        Cookie。通过手动进行设置，也可以自由地发送未接收的 Cookie。</p>\n    <h2 id=\"nav_point_94\">3.15　超时</h2>\n    <p>我们可以在 curl 命令中使用 <code>-m</code> 选项来设置超时时间，具体如下所示。</p>\n    <pre class=\"code-rows\"><code>$ curl -m 2 http://localhost:8080/slow_page</code></pre>\n    <p>从版本 1.7 开始，Go 的标准库中引入了 Context 机制。Context 有以下两个功能。</p>\n    <blockquote>\n        <ul>\n            <li>从外部停止所有的处理（类似于 C# 中的 <code>CancellationToken</code>）</li>\n            <li>在与同一个请求相关的处理中（请求范围）共享值（类似于 Java 等编程语言中的线程本地存储）</li>\n        </ul>\n    </blockquote>\n    <p>第一个功能可以用于实现超时处理。Context 是 Go 语言中与应用程序设计紧密相关的功能，但本书的重点并不是介绍 Go 语言的编程方法，因此这里就不再详细介绍 Context 了。</p>\n    <blockquote>\n        <p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100009/image00380.jpeg\" alt=\"\" width=\"5%\" style=\"width: 5%\" inline-img=\"true\" />　网上有许多关于 Context\n            的详细介绍，请读者自行查阅。本节仅介绍超时的相关内容。第二个功能将在第 12 章介绍。</p>\n    </blockquote>\n    <p>Context 具有父子关系。根 Context（使用 <code>context.Background()</code> 创建）不会自动结束。拥有超时控制的 Context 要使用\n        <code>context.WithTimeout()</code> 函数创建。在创建请求时，使用 <code>http.NewRequestWithContext()</code> 代替\n        <code>http.NewRequest()</code>，在传入 Context 后，超时就设置好了。多个请求可以共享同一个 Context，这样一来，相关的所有请求就可以同时停止。</p>\n    <pre class=\"code-rows\"><code>// 先创建 Context\nctx, cancel := context.WithTimeout(context.Background(), 2 * time.Second)\ndefer cancel()\n\n// 创建拥有根 Context 的请求\nreq, _ := http.NewRequestWithContext(ctx, \"GET\", \"http:/localhost:8080/slow_page,\nnil)\n// 然后正常发送请求\nres, err := http.DefaultClient.Do(req)</code></pre>\n    <p>在 Go 1.7 之前的版本中，我们可以使用 <code>http.Client</code> 的 <code>Timeout</code> 属性或 <code>http.Transport</code>\n        等方法实现超时，而如今，如无特殊要求，最好使用 Context。</p>\n    <h2 id=\"nav_point_95\">3.16　国际化域名</h2>\n    <p>第 1 章中介绍了与 URL 国际化有关的内容。当时介绍了用于转换的服务，而使用 Go 语言也可以进行转换。</p>\n    <p><code>idna.ToASCII()</code> 和 <code>idna.ToUnicode()</code> 函数用来转换域名。在发送请求之前，通过 <code>idna.ToASCII()</code>\n        转换域名并使用前面介绍的 API，就可以获取域名的站点信息（代码清单 3-21）。</p>\n    <p><strong>代码清单 3-21　URL 国际化的应对方法</strong></p>\n    <pre class=\"code-rows\"><code>package main\n\nimport (\n    \"fmt\"\n    \"golang.org/x/net/idna\"\n)\n\nfunc main() {\n    src := \" 握力王\"\n    ascii, err := idna.ToASCII(src)\n    if err != nil {\n        panic(err)\n    }\n    fmt.Printf(\"%s -&gt; %s\\n\", src, ascii)\n}</code></pre>\n    <h2 id=\"nav_point_96\">3.17　本章小结</h2>\n    <p>本章介绍了如何使用 Go 语言实现 HTTP/1.0 中出现的各种请求模式。关于 Go 语言，我们对在阅读伪代码时比较难理解的实例的创建，以及只看语法的话难以理解其用法的 <code>io.Reader</code> 和\n        <code>io.Writer</code> 的处理进行了补充说明。</p>\n    <p>本章介绍了许多模式，我们可以通过图 3-1 来了解在各种模式下使用什么方法。</p>\n    <p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100009/image00393.jpeg\" alt=\"{%}\" /></p>\n    <p class=\"ebook-image-title\"><strong>图 3-1　各种模式下使用的方法</strong></p>\n    <p>第 1 章介绍了使用 curl 命令处理 4 个基本元素的方法，本章介绍了使用编程语言处理 4 个基本元素的方法。第 2 章提到过，HTTP 的许多功能是通过运用 4\n        个基本元素来实现的。如果按照浏览器来实现缓存结构，就要编写大量代码，而本章至少涵盖了与服务器直接通信的相关内容。本章介绍的 API 对 HTTP/2 也适用。如果只是使用 Web API，阅读本章的内容就足够了。</p>\n\n    <br style=\"page-break-after:always\" />\n    </pre&#10;>","neighbors":{"left":{"article_title":"第 2 章 HTTP/1.0 的语义：浏览器基本功能的背后(2)","id":740907},"right":{"article_title":"第 4 章 HTTP/1.1 的语法：追求高速化和安全性(1)","id":740909}},"comments":[]}