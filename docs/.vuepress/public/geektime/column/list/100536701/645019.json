{"id":645019,"title":"11｜ModelAndView ：如何将处理结果返回给前端？","content":"<p>你好，我是郭屹。今天我们继续手写MiniSpring。这也是MVC内容的最后一节。</p><p>上节课，我们对HTTP请求传入的参数进行了自动绑定，并调用了目标方法。我们再看一下整个MVC的流程，现在就到最后一步了，也就是把返回数据回传给前端进行渲染。</p><p><img src=\"https://static001.geekbang.org/resource/image/a5/f3/a51576e7bc6a3dba052274546f5311f3.png?wh=1660x916\" alt=\"图片\"></p><p>调用目标方法得到返回值之后，我们有两条路可以返回给前端。第一，返回的是简单的纯数据，第二，返回的是一个页面。</p><p>最近几年，第一种情况渐渐成为主流，也就是我们常说的“前后端分离”，后端处理完成后，只是把数据返回给前端，由前端自行渲染界面效果。比如前端用React或者Vue.js自行组织界面表达，这些前端脚本只需要从后端service拿到返回的数据就可以了。</p><p>第二种情况，由后端controller根据某种规则拿到一个页面，把数据整合进去，然后整个回传给前端浏览器，典型的技术就是JSP。这条路前些年是主流，最近几年渐渐不流行了。</p><p>我们手写MiniSpring的目的是深入理解Spring框架，剖析它的程序结构，所以作为学习的对象，这两种情况我们都会分析到。</p><h2>处理返回数据</h2><p>和绑定传入的参数相对，处理返回数据是反向的，也就是说，要从后端把方法得到的返回值（一个Java对象）按照某种字符串格式回传给前端。我们以这个@ResponseBody注解为例，来分析一下。</p><!-- [[[read_end]]] --><p>先定义一个接口，增加一个功能，让controller返回给前端的字符流数据可以进行格式转换。</p><pre><code class=\"language-plain\">package com.minis.web;\n\nimport java.io.IOException;\nimport javax.servlet.http.HttpServletResponse;\n\npublic interface HttpMessageConverter {\n\tvoid write(Object obj, HttpServletResponse response) throws IOException;\n}\n</code></pre><p>我们这里给一个默认的实现——DefaultHttpMessageConverter，把Object转成JSON串。</p><pre><code class=\"language-plain\">package com.minis.web;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class DefaultHttpMessageConverter implements HttpMessageConverter {\n\tString defaultContentType = \"text/json;charset=UTF-8\";\n\tString defaultCharacterEncoding = \"UTF-8\";\n\tObjectMapper objectMapper;\n\t\n\tpublic ObjectMapper getObjectMapper() {\n\t\treturn objectMapper;\n\t}\n\tpublic void setObjectMapper(ObjectMapper objectMapper) {\n\t\tthis.objectMapper = objectMapper;\n\t}\n\tpublic void write(Object obj, HttpServletResponse response) throws IOException {\n&nbsp; &nbsp; &nbsp; &nbsp; response.setContentType(defaultContentType);\n&nbsp; &nbsp; &nbsp; &nbsp; response.setCharacterEncoding(defaultCharacterEncoding);\n&nbsp; &nbsp; &nbsp; &nbsp; writeInternal(obj, response);\n&nbsp; &nbsp; &nbsp; &nbsp; response.flushBuffer();\n\t}\n\tprivate void writeInternal(Object obj, HttpServletResponse response) throws IOException{\n\t\tString sJsonStr = this.objectMapper.writeValuesAsString(obj);\n\t\tPrintWriter pw = response.getWriter();\n\t\tpw.write(sJsonStr);\n\t}\n}\n</code></pre><p>这个message converter很简单，就是给response写字符串，用到的工具是ObjectMapper。我们就重点看看这个mapper是怎么做的。</p><p>定义一个接口ObjectMapper。</p><pre><code class=\"language-plain\">package com.minis.web;\npublic interface ObjectMapper {\n\tvoid setDateFormat(String dateFormat);\n\tvoid setDecimalFormat(String decimalFormat);\n\tString writeValuesAsString(Object obj);\n}\n</code></pre><p>最重要的接口方法就是writeValuesAsString()，将对象转成字符串。</p><p>我们给一个默认的实现——DefaultObjectMapper，在writeValuesAsString中拼JSON串。</p><pre><code class=\"language-plain\">package com.minis.web;\n\nimport java.lang.reflect.Field;\nimport java.math.BigDecimal;\nimport java.text.DecimalFormat;\nimport java.time.LocalDate;\nimport java.time.ZoneId;\nimport java.time.format.DateTimeFormatter;\nimport java.util.Date;\n\npublic class DefaultObjectMapper implements ObjectMapper{\n\tString dateFormat = \"yyyy-MM-dd\";\n\tDateTimeFormatter datetimeFormatter = DateTimeFormatter.ofPattern(dateFormat);\n\t\n\tString decimalFormat = \"#,##0.00\";\n\tDecimalFormat decimalFormatter = new DecimalFormat(decimalFormat);\n\n\tpublic DefaultObjectMapper() {\n\t}\n\t\n\t@Override\n\tpublic void setDateFormat(String dateFormat) {\n\t\tthis.dateFormat = dateFormat;\n\t\tthis.datetimeFormatter = DateTimeFormatter.ofPattern(dateFormat);\n\t}\n\n\t@Override\n\tpublic void setDecimalFormat(String decimalFormat) {\n\t\tthis.decimalFormat = decimalFormat;\n\t\tthis.decimalFormatter = new DecimalFormat(decimalFormat);\n\t}\n\tpublic String writeValuesAsString(Object obj) {\n\t\tString sJsonStr = \"{\";\t\t\n\t\tClass&lt;?&gt; clz = obj.getClass();\n\t\t\n\t\tField[] fields = clz.getDeclaredFields();\n        //对返回对象中的每一个属性进行格式转换\n\t\tfor (Field field : fields) {\n\t\t\tString sField = \"\";\n\t\t\tObject value = null;\n\t\t\tClass&lt;?&gt; type = null;\n\t\t\tString name = field.getName();\n\t\t\tString strValue = \"\";\n\t\t\tfield.setAccessible(true);\n\t\t\tvalue = field.get(obj);\n\t\t\ttype = field.getType();\n\t\t\t\n            //针对不同的数据类型进行格式转换\n\t\t\tif (value instanceof Date) {\n\t\t\t\tLocalDate localDate = ((Date)value).toInstant().atZone(ZoneId.systemDefault()).toLocalDate();\n\t\t\t\tstrValue = localDate.format(this.datetimeFormatter);\n\t\t\t}\n\t\t\telse if (value instanceof BigDecimal || value instanceof Double || value instanceof Float){\n\t\t\t\tstrValue = this.decimalFormatter.format(value);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstrValue = value.toString();\n\t\t\t}\n\t\t\t\n            //拼接Json串\n\t\t\tif (sJsonStr.equals(\"{\")) {\n\t\t\t\tsField = \"\\\"\" + name + \"\\\":\\\"\" + strValue + \"\\\"\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsField = \",\\\"\" + name + \"\\\":\\\"\" + strValue + \"\\\"\";\t\n\t\t\t}\n\t\t\t\n\t\t\tsJsonStr += sField;\n\t\t}\n\t\tsJsonStr += \"}\";\n\t\treturn sJsonStr;\n\t}\n}\n</code></pre><p>实际转换过程用到了LocalDate和DecimalFormatter。从上述代码中也可以看出，目前为止，我们也只支持Date、Number和String三种类型。你自己可以考虑扩展到更多的数据类型。</p><p>那么我们在哪个地方用这个工具来处理返回的数据呢？其实跟绑定参数一样，数据返回之前，也是要经过方法调用。所以我们还是要回到RequestMappingHandlerAdapter这个类，增加一个属性messageConverter，通过它来转换数据。</p><p>程序变成了这个样子。</p><pre><code class=\"language-plain\">\tpublic class RequestMappingHandlerAdapter implements HandlerAdapter {\n\t\tprivate WebBindingInitializer webBindingInitializer = null;\n\t\tprivate HttpMessageConverter messageConverter = null;\n</code></pre><p>现在既有传入的webBingingInitializer，也有传出的messageConverter。<br>\n在关键方法invokeHandlerMethod()里增加对@ResponseBody的处理，也就是调用messageConverter.write()把方法返回值转换成字符串。</p><pre><code class=\"language-plain\">\tprotected ModelAndView invokeHandlerMethod(HttpServletRequest request,\n\t\tHttpServletResponse response, HandlerMethod handlerMethod) throws Exception {\n\t\t... ...\n\t\tif (invocableMethod.isAnnotationPresent(ResponseBody.class)){ //ResponseBody\n\t&nbsp; &nbsp; &nbsp; &nbsp; this.messageConverter.write(returnObj, response);\n\t\t}\t\n\t\t... ...\n\t}\n</code></pre><p>同样的webBindingInitializer和messageConverter都可以通过配置注入。</p><pre><code class=\"language-plain\">\t&lt;bean id=\"handlerAdapter\" class=\"com.minis.web.servlet.RequestMappingHandlerAdapter\"&gt;&nbsp;\n\t &lt;property type=\"com.minis.web.HttpMessageConverter\" name=\"messageConverter\" ref=\"messageConverter\"/&gt;\n\t &lt;property type=\"com.minis.web.WebBindingInitializer\" name=\"webBindingInitializer\" ref=\"webBindingInitializer\"/&gt;\n\t&lt;/bean&gt;\n\t\n\t&lt;bean id=\"webBindingInitializer\" class=\"com.test.DateInitializer\" /&gt;&nbsp;\n\t\n\t&lt;bean id=\"messageConverter\" class=\"com.minis.web.DefaultHttpMessageConverter\"&gt;&nbsp;\n\t &lt;property type=\"com.minis.web.ObjectMapper\" name=\"objectMapper\" ref=\"objectMapper\"/&gt;\n\t&lt;/bean&gt;\n\t&lt;bean id=\"objectMapper\" class=\"com.minis.web.DefaultObjectMapper\" &gt;\n\t &lt;property type=\"String\" name=\"dateFormat\" value=\"yyyy/MM/dd\"/&gt;\n\t &lt;property type=\"String\" name=\"decimalFormat\" value=\"###.##\"/&gt;\n\t&lt;/bean&gt;\n</code></pre><p>最后在DispatcherServlet里，通过getBean获取handlerAdapter，当然这里需要约定一个名字，整个过程就连起来了。</p><pre><code class=\"language-plain\">\tprotected void initHandlerAdapters(WebApplicationContext wac) {\n&nbsp;\t\tthis.handlerAdapter = (HandlerAdapter) wac.getBean(HANDLER_ADAPTER_BEAN_NAME);\n&nbsp; &nbsp; }\n</code></pre><p>测试的客户程序HelloWorldBean修改如下：</p><pre><code class=\"language-plain\">\t@RequestMapping(\"/test7\")\n\t@ResponseBody\n\tpublic User doTest7(User user) {\n\t\tuser.setName(user.getName() + \"---\");\n\t\tuser.setBirthday(new Date());\n\t\treturn user;\n\t}\t\n</code></pre><p>程序里面声明了一个注解@ResponseBody，程序中返回的是对象User，框架处理的时候用message converter将其转换成JSON字符串返回。</p><p>到这里，我们就知道MVC是如何把方法返回对象自动转换成response字符串的了。我们在调用目标方法后，通过messageConverter进行转换，它要分别转换每一种数据类型的格式，同时格式可以由用户自己指定。</p><h2>ModelAndView</h2><p>调用完目标方法，得到返回值，把数据按照指定格式转换好之后，就该处理它们，并把它们送到前端去了。我们用一个统一的结构，包装调用方法之后返回的数据，以及需要启动的前端页面，这个结构就是ModelAndView，我们看下它的定义。</p><pre><code class=\"language-plain\">package com.minis.web.servlet;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class ModelAndView {\n\tprivate Object view;\n\tprivate Map&lt;String, Object&gt; model = new HashMap&lt;&gt;();\n\n\tpublic ModelAndView() {\n\t}\n\tpublic ModelAndView(String viewName) {\n\t\tthis.view = viewName;\n\t}\n\tpublic ModelAndView(View view) {\n\t\tthis.view = view;\n\t}\n\tpublic ModelAndView(String viewName, Map&lt;String, ?&gt; modelData) {\n\t\tthis.view = viewName;\n\t\tif (modelData != null) {\n\t\t\taddAllAttributes(modelData);\n\t\t}\n\t}\n\tpublic ModelAndView(View view, Map&lt;String, ?&gt; model) {\n\t\tthis.view = view;\n\t\tif (model != null) {\n\t\t\taddAllAttributes(model);\n\t\t}\n\t}\n\tpublic ModelAndView(String viewName, String modelName, Object modelObject) {\n\t\tthis.view = viewName;\n\t\taddObject(modelName, modelObject);\n\t}\n\tpublic ModelAndView(View view, String modelName, Object modelObject) {\n\t\tthis.view = view;\n\t\taddObject(modelName, modelObject);\n\t}\n\tpublic void setViewName(String viewName) {\n\t\tthis.view = viewName;\n\t}\n\tpublic String getViewName() {\n\t\treturn (this.view instanceof String ? (String) this.view : null);\n\t}\n\tpublic void setView(View view) {\n\t\tthis.view = view;\n\t}\n\tpublic View getView() {\n\t\treturn (this.view instanceof View ? (View) this.view : null);\n\t}\n\tpublic boolean hasView() {\n\t\treturn (this.view != null);\n\t}\n\tpublic boolean isReference() {\n\t\treturn (this.view instanceof String);\n\t}\n\tpublic Map&lt;String, Object&gt; getModel() {\n\t\treturn this.model;\n\t}\n\tprivate void addAllAttributes(Map&lt;String, ?&gt; modelData) {\n\t\tif (modelData != null) {\n\t\t\tmodel.putAll(modelData);\n\t\t}\n\t}\n\tpublic void addAttribute(String attributeName, Object attributeValue) {\n\t\tmodel.put(attributeName, attributeValue);\n\t}\n\tpublic ModelAndView addObject(String attributeName, Object attributeValue) {\n\t\taddAttribute(attributeName, attributeValue);\n\t\treturn this;\n\t}\n}\n</code></pre><p>这个类里面定义了Model和View，分别代表返回的数据以及前端表示，我们这里就是指JSP。</p><p>有了这个结构，我们回头看调用目标方法之后返回的那段代码，把类RequestMappingHandlerAdapter的方法invokeHandlerMethod()返回值改为ModelAndView。</p><pre><code class=\"language-plain\">protected ModelAndView invokeHandlerMethod(HttpServletRequest request,\n       \t\t\tHttpServletResponse response, HandlerMethod handlerMethod) throws Exception {\n\tModelAndView mav = null;\n    //如果是ResponseBody注解，仅仅返回值，则转换数据格式后直接写到response\n\tif (invocableMethod.isAnnotationPresent(ResponseBody.class)){ //ResponseBody\n\t&nbsp; &nbsp; &nbsp; &nbsp; this.messageConverter.write(returnObj, response);\n\t}\n\telse { //返回的是前端页面\n\t\tif (returnObj instanceof ModelAndView) {\n\t\t\tmav = (ModelAndView)returnObj;\n\t\t}\n\t\telse if(returnObj instanceof String) { //字符串也认为是前端页面\n\t\t\tString sTarget = (String)returnObj;\n\t\t\tmav = new ModelAndView();\n\t\t\tmav.setViewName(sTarget);\n\t\t}\n\t}\n\t\t\n\treturn mav;\n}\n</code></pre><p>通过上面这段代码我们可以知道，调用方法返回的时候，我们处理了三种情况。</p><ol>\n<li>如果声明返回的是ResponseBody，那就用MessageConvert把结果转换一下，之后直接写回response。</li>\n<li>如果声明返回的是ModelAndView，那就把结果包装成一个ModelAndView对象返回。</li>\n<li>如果声明返回的是字符串，就以这个字符串为目标，最后还是包装成ModelAndView返回。</li>\n</ol><h2>View</h2><p>到这里，调用方法就返回了。不过事情还没完，之后我们就把注意力转移到MVC环节的最后一部分：View层。View，顾名思义，就是负责前端界面展示的部件，当然它最主要的功能就是，把数据按照一定格式显示并输出到前端界面上，因此可以抽象出它的核心方法render()，我们可以看下View接口的定义。</p><pre><code class=\"language-plain\">package com.minis.web.servlet;\n\nimport java.util.Map;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic interface View {\n\tvoid render(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows Exception;\n\tdefault String getContentType() {\n\t\treturn null;\n\t}\n\tvoid setContentType(String contentType);\n\tvoid setUrl(String url);\n\tString getUrl();\n\tvoid setRequestContextAttribute(String requestContextAttribute);\n\tString getRequestContextAttribute();\n}\n</code></pre><p>这个render()方法的思路很简单，就是获取HTTP请求的request和response，以及中间产生的业务数据Model，最后写到response里面。request和response是HTTP访问时由服务器创建的，ModelAndView是由我们的MiniSpring创建的。</p><p>准备好数据之后，我们以JSP为例，来看看怎么把结果显示在前端界面上。其实，这跟我们自己手工写JSP是一样的，先设置属性值，然后把请求转发（forward）出去，就像下面我给出的这几行代码。</p><pre><code class=\"language-plain\">\trequest.setAttribute(key1, value1);\n\trequest.setAttribute(key2, value2);\n\trequest.getRequestDispatcher(url).forward(request, response);\n</code></pre><p>照此办理，DispatcherServlet的doDispatch()方法调用目标方法后，可以通过一个render()来渲染这个JSP，你可以看一下doDispatch()相关代码。</p><pre><code class=\"language-plain\">\tHandlerAdapter ha = this.handlerAdapter;\n\tmv = ha.handle(processedRequest, response, handlerMethod);\n\trender(processedRequest, response, mv);\n</code></pre><p>这个render()方法可以考虑这样实现。</p><pre><code class=\"language-plain\">\t//用jsp 进行render\n\tprotected void render( HttpServletRequest request, HttpServletResponse response,ModelAndView mv) throws Exception {\n\t\t//获取model，写到request的Attribute中：\n\t\tMap&lt;String, Object&gt; modelMap = mv.getModel();\n\t\tfor (Map.Entry&lt;String, Object&gt; e : modelMap.entrySet()) {\n\t\t\trequest.setAttribute(e.getKey(),e.getValue());\n\t\t}\n        //输出到目标JSP\n\t\tString sTarget = mv.getViewName();\n\t\tString sPath = \"/\" + sTarget + \".jsp\";\n\t\trequest.getRequestDispatcher(sPath).forward(request, response);\n\t}\n</code></pre><p>我们看到了，程序从Model里获取数据，并将其作为属性值写到request的attribute里，然后获取页面路径，再显示出来，跟手工写JSP过程一样，简明有效。</p><p>但是上面的程序有两个问题，一是这个程序是怎么找到显示目标View的呢？上面的例子，我们是写了一个固定的路径/xxxx.jsp，但实际上这些应该是可以让用户自己来配置的，不应该写死在代码中。二是拿到View后，直接用的是request的forward()方法，这只对JSP有效，没办法扩展到别的页面，比如说Excel、PDF。所以上面的render()是需要改造的。</p><p>先解决第一个问题，怎么找到需要显示的目标View? 这里又得引出了一个新的部件ViewResolver，由它来根据某个规则或者是用户配置来确定View在哪里，下面是它的定义。</p><pre><code class=\"language-plain\">package com.minis.web.servlet;\n\npublic interface ViewResolver {\n\tView resolveViewName(String viewName) throws Exception;\n}\n</code></pre><p>这个ViewResolver就是根据View的名字找到实际的View，有了这个ViewResolver，就不用写死JSP路径，而是可以通过resolveViewName()方法来获取一个View。拿到目标View之后，我们把实际渲染的功能交给View自己完成。我们把程序改成下面这个样子。</p><pre><code class=\"language-plain\">\tprotected void render( HttpServletRequest request, HttpServletResponse response,ModelAndView mv) throws Exception {\n\t\tString sTarget = mv.getViewName();\n\t\tMap&lt;String, Object&gt; modelMap = mv.getModel();\n\t\tView view = resolveViewName(sTarget, modelMap, request);\n\t\tview.render(modelMap, request, response);\n\t}\n</code></pre><p>在MiniSpring里，我们提供一个InternalResourceViewResolver，作为启动JSP的默认实现，它是这样定位到显示目标View的。</p><pre><code class=\"language-plain\">package com.minis.web.servlet.view;\n\nimport com.minis.web.servlet.View;\nimport com.minis.web.servlet.ViewResolver;\n\npublic class InternalResourceViewResolver implements ViewResolver{\n\tprivate Class&lt;?&gt; viewClass = null;\n\tprivate String viewClassName = \"\";\t\n\tprivate String prefix = \"\";\n\tprivate String suffix = \"\";\n\tprivate String contentType;\n\t\n\tpublic InternalResourceViewResolver() {\n\t\tif (getViewClass() == null) {\n\t\t\tsetViewClass(JstlView.class);\t\t\t\n\t\t}\n\t}\n\t\n\tpublic void setViewClassName(String viewClassName) {\n\t\tthis.viewClassName = viewClassName;\n\t\tClass&lt;?&gt; clz = null;\n\t\ttry {\n\t\t\tclz = Class.forName(viewClassName);\n\t\t} catch (ClassNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tsetViewClass(clz);\n\t}\n\t\n\tprotected String getViewClassName() {\n\t\treturn this.viewClassName;\n\t}\n\tpublic void setViewClass(Class&lt;?&gt; viewClass) {\n\t\tthis.viewClass = viewClass;\n\t}\n\tprotected Class&lt;?&gt; getViewClass() {\n\t\treturn this.viewClass;\n\t}\n\tpublic void setPrefix(String prefix) {\n\t\tthis.prefix = (prefix != null ? prefix : \"\");\n\t}\n\tprotected String getPrefix() {\n\t\treturn this.prefix;\n\t}\n\tpublic void setSuffix(String suffix) {\n\t\tthis.suffix = (suffix != null ? suffix : \"\");\n\t}\n\tprotected String getSuffix() {\n\t\treturn this.suffix;\n\t}\n\tpublic void setContentType(String contentType) {\n\t\tthis.contentType = contentType;\n\t}\n\tprotected String getContentType() {\n\t\treturn this.contentType;\n\t}\n\n\t@Override\n\tpublic View resolveViewName(String viewName) throws Exception {\n\t\treturn buildView(viewName);\n\t}\n\n\tprotected View buildView(String viewName) throws Exception {\n\t\tClass&lt;?&gt; viewClass = getViewClass();\n\n\t\tView view = (View) viewClass.newInstance();\n\t\tview.setUrl(getPrefix() + viewName + getSuffix());\n\n\t\tString contentType = getContentType();\n\t\tview.setContentType(contentType);\n\n\t\treturn view;\n\t}\n}\n</code></pre><p>从代码里可以知道，它先创建View实例，通过配置生成URL定位到显示目标，然后设置ContentType。这个过程也跟我们手工写JSP是一样的。通过这个resolver，就解决了第一个问题，框架会根据配置从/jsp/路径下拿到xxxx.jsp页面。</p><p>对于第二个问题，DispatcherServlet是不应该负责实际的渲染工作的，它只负责控制流程，并不知道如何渲染前端，这些工作由具体的View实现类来完成。所以我们不再把request forward()这样的代码写到DispatcherServlet里，而是写到View的render()方法中。</p><p>MiniSpring也提供了一个默认的实现：JstlView。</p><pre><code class=\"language-plain\">package com.minis.web.servlet.view;\n\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport com.minis.web.servlet.View;\n\npublic class JstlView implements View{\n\tpublic static final String DEFAULT_CONTENT_TYPE = \"text/html;charset=ISO-8859-1\";\n\tprivate String contentType = DEFAULT_CONTENT_TYPE;\n\tprivate String requestContextAttribute;\n\tprivate String beanName;\n\tprivate String url;\n\n\tpublic void setContentType(String contentType) {\n\t\tthis.contentType = contentType;\n\t}\n\tpublic String getContentType() {\n\t\treturn this.contentType;\n\t}\n\tpublic void setRequestContextAttribute(String requestContextAttribute) {\n\t\tthis.requestContextAttribute = requestContextAttribute;\n\t}\n\tpublic String getRequestContextAttribute() {\n\t\treturn this.requestContextAttribute;\n\t}\n\tpublic void setBeanName(String beanName) {\n\t\tthis.beanName = beanName;\n\t}\n\tpublic String getBeanName() {\n\t\treturn this.beanName;\n\t}\n\tpublic void setUrl(String url) {\n\t\tthis.url = url;\n\t}\n\tpublic String getUrl() {\n\t\treturn this.url;\n\t}\n\tpublic void render(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows Exception {\n\t\tfor (Entry&lt;String, ?&gt; e : model.entrySet()) {\n\t\t\trequest.setAttribute(e.getKey(),e.getValue());\n\t\t}\t\n\t\trequest.getRequestDispatcher(getUrl()).forward(request, response);\n\t}\n}\n</code></pre><p>从代码里可以看到，程序其实还是一样的，因为要完成的任务是一样的，只不过现在这个代码移到了View这个位置。但是这个位置的移动，就让前端的渲染工作解耦了，DispatcherServlet不负责渲染了，我们可以由此扩展到多种前端，如Excel、PDF等等。</p><p>然后，对于InternalResourceViewResolver和JstlView，我们可以再次利用IoC容器机制通过配置进行注入。</p><pre><code class=\"language-plain\">&nbsp; &nbsp; &lt;bean id=\"viewResolver\" class=\"com.minis.web.servlet.view.InternalResourceViewResolver\" &gt;\n\t &lt;property type=\"String\" name=\"viewClassName\" value=\"com.minis.web.servlet.view.JstlView\" /&gt;\n\t &lt;property type=\"String\" name=\"prefix\" value=\"/jsp/\" /&gt;\n\t &lt;property type=\"String\" name=\"suffix\" value=\".jsp\" /&gt;\n&nbsp; &nbsp; &lt;/bean&gt;\n</code></pre><p>当DispatcherServlet初始化的时候，根据配置获取实际的ViewResolver和View。</p><p>整个过程就完美结束了。</p><h2>小结</h2><p>这节课，我们重点探讨了MVC调用目标方法之后的处理过程，如何自动转换数据、如何找到指定的View、如何去渲染页面。我们可以看到，作为一个框架，我们没有规定数据要如何转换格式，而是交给了MessageConverter去做；我们也没有规定如何找到这些目标页面，而是交给了ViewResolver去做；我们同样没有规定如何去渲染前端界面，而是通过View这个接口去做。我们可以自由地实现具体的场景。</p><p>这里，我们的重点并不是去看具体代码如何实现，而是要学习Spring框架如何分解这些工作，把专门的事情交给专门的部件去完成。虽然现在已经不流行JSP，我们不用特地去学习它，但是把这些部件解耦的框架思想，却是值得我们好好琢磨的。</p><p>完整源代码参见：<a href=\"https://github.com/YaleGuo/minis\">https://github.com/YaleGuo/minis</a></p><h2>课后题</h2><p>学完这节课，我也给你留一道思考题。现在我们返回的数据只支持Date、Number和String三种类型，如何扩展到更多的数据类型？现在也只支持JSP，如何扩展到别的前端？欢迎你在留言区和我交流讨论，也欢迎你把这节课分享给需要的朋友。我们下节课见！</p>","neighbors":{"left":{"article_title":"10｜数据绑定: 如何自动转换传入的参数？","id":644987},"right":{"article_title":"12｜再回首：如何实现Spring MVC？","id":646763}},"comments":[{"had_liked":false,"id":378984,"user_name":"Geek3485","can_delete":false,"product_type":"c1","uid":3575783,"ip_address":"上海","ucode":"60C560A26445B9","user_header":"","comment_is_top":false,"comment_ctime":1691106947,"is_pvip":false,"replies":[{"id":138111,"content":"老师正在准备tomcat的相关课程，后续课程上线就可以看到啦～","user_name":"编辑回复","user_name_real":"编辑","uid":2843479,"ctime":1691132675,"ip_address":"北京","comment_id":378984,"utype":2}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"老师的minitomcat源码在哪可以看到","like_count":1,"discussions":[{"author":{"id":2843479,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/63/57/cba4c68b.jpg","nickname":"小虎子🐯","note":"","ucode":"4C9530B3FB407B","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":624979,"discussion_content":"老师正在准备tomcat的相关课程，后续课程上线就可以看到啦～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1691132675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":8}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":372309,"user_name":"马儿","can_delete":false,"product_type":"c1","uid":2247080,"ip_address":"四川","ucode":"542E23D7B6AB01","user_header":"","comment_is_top":false,"comment_ctime":1680955576,"is_pvip":false,"replies":[{"id":135912,"content":"1 你说的是，线下课确实是作为扩展练习的。\n2 你可以这么考虑，对别的view，要用不同的view resolver，即写一个与InternalResourceViewResolver对等的实现来支持别的view。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1681045218,"ip_address":"澳大利亚","comment_id":372309,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"1.目前如果加了ResponseBody注解返回String的话返回的是String在内存中的信息，而需要的字符串值字段在这个json中也是内存中的地址值，这将导致结果不符合预期，这里应该还需要对writeValuesAsString这个函数优化一下，或者是拓展一些其他的实现。\n2. 目前在InternalResourceViewResolver中写死了处理Jsp的View，可以在加一个有参构造函数，传入参数为资源类型，InternalResourceViewResolver内部维护一个资源类型和View的Map\n\n希望老师可以抽时间加一些答疑课，对之前一些同学问到的问题在课上统一解答一下。或者是将一些mini-spring中的一些拓展点提供一个思路，比如上节课遇到的传参数不支持基本类型和自定义类型中WebDataBinder不可用的问题。谢谢老师。","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612969,"discussion_content":"1 你说的是，线下课确实是作为扩展练习的。\n2 你可以这么考虑，对别的view，要用不同的view resolver，即写一个与InternalResourceViewResolver对等的实现来支持别的view。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681045218,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3866578,"avatar":"https://static001.geekbang.org/account/avatar/00/3a/ff/d2/c1f5334d.jpg","nickname":"dirtychill","note":"","ucode":"4D3172C60E522A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":646176,"discussion_content":"同问，第一个bug咋解决的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1717496720,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":372149,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1680782584,"is_pvip":false,"replies":[{"id":135825,"content":"Peter你好。MiniSpring是模仿Spring框架的一个简化版本，目的是作为一个简要地图便于大家理解Spring的结构和源代码，MiniSpring的包结构类名和主要流程方法都是跟Sping框架本身一样的，所以学习了MiniSpring，会比较容易继续深入了解Spring的源代码。\nrequest是对http request的包装，大小主要依赖于客户端传上来的数据包大小，不考虑附件，一般不会太大，应该在200K以内。你要再学一下我的MiniTomcat后就会更加清楚。\nView这个类的定位是前端展示，如果是JSP，就是吧数据填充到JSP中，然后展示出来。最近这些年都是前后端分离了，这一部分简单了解一下就可以。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1680827940,"ip_address":"澳大利亚","comment_id":372149,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"请教老师几个问题：\nQ1：本文所讲的内容，就是模仿SpringMVC，对吗？\nQ2：很多信息都存在request中，那这个request对象会占用很大内存吗？对于一个用户，一般地讲，会占用多大内存？比如10M？\nQ3：View这个类，是生成一个页面文件吗？还是把数据填充到已经存在的页面上？","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612634,"discussion_content":"Peter你好。MiniSpring是模仿Spring框架的一个简化版本，目的是作为一个简要地图便于大家理解Spring的结构和源代码，MiniSpring的包结构类名和主要流程方法都是跟Sping框架本身一样的，所以学习了MiniSpring，会比较容易继续深入了解Spring的源代码。\nrequest是对http request的包装，大小主要依赖于客户端传上来的数据包大小，不考虑附件，一般不会太大，应该在200K以内。你要再学一下我的MiniTomcat后就会更加清楚。\nView这个类的定位是前端展示，如果是JSP，就是吧数据填充到JSP中，然后展示出来。最近这些年都是前后端分离了，这一部分简单了解一下就可以。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680827940,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":372886,"user_name":"梦某人","can_delete":false,"product_type":"c1","uid":3228991,"ip_address":"河北","ucode":"D9F14B15AC2A12","user_header":"https://static001.geekbang.org/account/avatar/00/31/45/3f/e4fc2781.jpg","comment_is_top":false,"comment_ctime":1681751846,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"打卡成功，从理解上这节课并不难，虽然很多代码（主要是User类和一些辅助）需要参考GitHub不然无法进行。但是调整环境浪费了接近2个小时，因为访问jsp一直报404的错误，后来意识到是没在idea的Project Structe 中的 Module设置资源文件夹。。。。另外目前的返回来讲，string包装成了 ModelAndView，但是这样做在reander的时候无法辨别，导致最基础的 &#47;test反而无法访问。思考题来说，View的两个类，一个负责分析内容，一个负责渲染内容，将 ViewResolver 进行扩展就可以解决相关问题了。","like_count":2},{"had_liked":false,"id":381125,"user_name":"Geek_b3425a","can_delete":false,"product_type":"c1","uid":2984386,"ip_address":"上海","ucode":"08FC79F0D93225","user_header":"","comment_is_top":false,"comment_ctime":1694701893,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"最新版初始化的handleAdapter的时候并没有给webBindingInitialize赋值，只给了一个set方法但是没有找到调用的地方，这样有请求进来的时候不会就空指针了吗？是我漏看东西了吗","like_count":1},{"had_liked":false,"id":381123,"user_name":"Geek_b3425a","can_delete":false,"product_type":"c1","uid":2984386,"ip_address":"上海","ucode":"08FC79F0D93225","user_header":"","comment_is_top":false,"comment_ctime":1694701060,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"\n\n有点不懂，老师仓库代码，handleMaping和handleAdapter都实现了applicationContextAware接口，类中applicationContext属性是abstractApplicationContext在getBean的时候给set进去的，不懂得是在容器启动的时候并没有这个bean相应的实体对象，并不会调用这个方法，我本地handleMapping中容器属性也是空，并没有掉set方法给他赋值","like_count":0},{"had_liked":false,"id":372124,"user_name":"C.","can_delete":false,"product_type":"c1","uid":1444698,"ip_address":"江苏","ucode":"5AE269220EFD73","user_header":"https://static001.geekbang.org/account/avatar/00/16/0b/5a/453ad411.jpg","comment_is_top":false,"comment_ctime":1680763652,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"结束结束！","like_count":0,"discussions":[{"author":{"id":2984386,"avatar":"","nickname":"Geek_b3425a","note":"","ucode":"08FC79F0D93225","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":627950,"discussion_content":"有点不懂，老师仓库代码，handleMaping和handleAdapter都实现了applicationContextAware接口，类中applicationContext属性是abstractApplicationContext在getBean的时候给set进去的，不懂得是在容器启动的时候并没有这个bean相应的实体对象，并不会调用这个方法，我本地handleMapping中容器属性也是空，并没有掉set方法给他赋值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1694701000,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}