{"id":809565,"title":"17｜SQL优化第一步：理解访问路径","content":"<p>你好，我是俊达。</p><p>大家都知道，我们使用SQL来访问数据库，而优化 SQL 对于保证数据库系统的高效、稳定运行，以及满足业务需求和降低成本都具有至关重要的意义。从这一讲开始，我们来系统地学习SQL优化。一条SQL语句，在数据库内部是怎么执行的呢？SQL的性能，又会受哪些因素影响呢？</p><p>关系型数据库中，SQL语句的执行主要分为几个大的步骤。</p><ol>\n<li>\n<p>对SQL文本进行解析，生成SQL语法树。</p>\n</li>\n<li>\n<p>优化器根据SQL语法树、表和索引的结构和统计信息，生成执行计划。</p>\n</li>\n<li>\n<p>SQL执行引擎根据执行计划，按一定的步骤，调用存储引擎接口获取数据，执行表连接、排序等操作，生成结果集。</p>\n</li>\n<li>\n<p>将结果集发送给客户端。</p>\n</li>\n</ol><p><img src=\"https://static001.geekbang.org/resource/image/74/78/748d265eb3b0e5b737eb9fa9aa473d78.jpg?wh=1602x766\" alt=\"图片\"></p><p>在这一讲和接下来的几讲中，我将围绕<strong>优化器、执行计划、SQL执行引擎</strong>，把SQL优化讲透。</p><p>我们先从访问路径（Access path）开始。访问路径是指根据表的物理存储结构，以及给定的查询条件，从表中获取数据的方法。访问路径包括表扫描和索引访问，还包括表连接的算法，如嵌套循环连接（Nested Loop Join）、哈希连接（Hash Join）、排序合并连接（Sort Merge Join）。</p><h2>表的物理存储</h2><h3>数据页</h3><p>数据页是数据表中数据存储的基本单位。一个数据页的大小通常可能为4K、8K、16K、32K。在InnoDB中，默认的页面大小为16K。记录以行的形式存储在数据页中，每行记录在数据页中占用一段连续的空间。通常1行记录可能占用几十字节到几百或几千字节。每个数据页能容纳的记录数一般在几行到几百行之间。</p><!-- [[[read_end]]] --><p>InnoDB对行的长度有一定的限制，每行记录的长度不能超过页面大小的一半。对于16K的页面大小，1行记录最长大概在8000字节多一点。如果1行记录平均长度为200字节，那么一个页面最多可以容纳八十多行记录。</p><p>下面是数据页的一个示意图。</p><p><img src=\"https://static001.geekbang.org/resource/image/72/72/72a4feaf9698db6a9579cc86af1bc872.jpg?wh=1236x743\" alt=\"图片\"></p><h3>数据段</h3><p>每个表由一系列的数据页组成。一个表的数据页数量主要由表中的记录数决定。如果记录平均长度为200字节，每个数据页存80行记录，那么存储1000万行记录，大致需要12.5万个数据页。</p><p>InnoDB中，表的数据以聚簇索引的方式，存储在一个数据段（Segment）中，一个数据段由一系列区块（Extent）组成。每个区块由64个16K的连续的页面组成。</p><p><img src=\"https://static001.geekbang.org/resource/image/58/4a/5807fc6962f4fde46b8c43f0d938d04a.jpg?wh=1282x431\" alt=\"图片\"></p><h3>索引</h3><p><strong>索引是用来快速检索数据的一种结构。</strong>InnoDB支持的索引类型包括B+树索引、全文索引、空间索引、Hash索引。我们课程中，说索引的时候，一般默认是指 <strong>B+ 树结构的索引</strong>。全文索引、空间索引、Hash索引不做过多介绍。</p><p>B+树索引是一种Key-Value结构，通过Key可以快速查找到对应的Value。B+树索引由根页面（Root）、分支页面（Branch）和叶子页面（Leaf）组成一棵树的结构。InnoDB中，索引页面的大小由参数innodb_page_size控制，默认为16K。<br>\n<img src=\"https://static001.geekbang.org/resource/image/fd/42/fd11b330fc90b2fbe0b7ec821665a942.jpg?wh=1442x826\" alt=\"图片\"><br>\n每个索引页面内存储了一系列索引条目，格式为（Key，Value），这些记录按Key的顺序排列。每个索引页面里可容纳的条目数量跟条目的长度相关。一个索引页内最少存储2行记录，因为如果索引页内只有1行记录，就无法构成树的结构了，这也是InnoDB限制一行记录最大长度的根本原因。</p><p>索引中Key包含了哪些字段呢？这是由索引的定义决定的。比如对于下面的这个表，索引idx_a中，Key就包括字段了a、b、id。Value中存了什么呢？在分支页面中，Value存了下一层索引页面的编号（Page No），页面编号就是页面在数据文件中的地址。而在叶子页面中，Value又是什么呢？对于InnoDB的二级索引，你可以认为叶子页面中不存Value，而对于聚簇索引，Value是表里面的所有字段。聚簇索引的含义后面会具体介绍。</p><pre><code class=\"language-plain\">create table t_index(\n    id int not null primary key,\n    a int,\n    b int,\n    c varchar(100),\n    key idx_a(a,b)\n) engine=innodb;\n</code></pre><p>索引页面内的n条记录（k1, v1)，（k2, v2），…（kn, vn），将Key的取值划分为n+1个区间。</p><p><span class=\"reference\">注：在InnoDB的实现上，每一层最左侧页面中的第一个索引条目有一点特殊，Key值比k(1)小的记录，也要到这个索引条目指向的下一层页面中查找。</span></p><p><img src=\"https://static001.geekbang.org/resource/image/55/48/5545fe8fc75656f9b938a5afb2f70948.jpg?wh=1400x808\" alt=\"图片\"><br>\n而下一层的索引页面中，每个页面中的索引条目，又将区间划分为更小的范围。假设我们需要查找Key为Kx的记录。</p><pre><code class=\"language-plain\">select * from tab where key = Kx\n</code></pre><p>先在根页面内查找，找到包含值Kx的那个区间，k(i) &lt;= Kx &lt; k(i+1)。而索引条目(ki, vi）中的vi是下一层索引页面的地址。递归到下一层页面中按相同的方法查找，最终会定位到某个叶子页面。叶子页面中的记录也是按 (key, value) 的方式存储。如果叶子页面中不存在Key为Kx的记录，则说明表中不存在这条记录。如果在叶子页面中找到了对应的索引条目，那么就可以根据索引条中的主键值，到聚簇索引中查找完整的记录。</p><h4>聚簇索引</h4><p>InnoDB中，表里的数据按聚簇索引的形式存储。聚簇索引的Key字段为表结构定义中Primary Key指定的字段。如果不指定Primay Key，则会以非空的唯一索引作为Primary Key，或者InnoDB自动生成一个隐藏字段作为Primary Key。</p><p>下面这个例子中，t_user表的主键为id。聚簇索引的Key字段为ID，其他字段作为Value，存储在索引的叶子页面中。</p><pre><code class=\"language-plain\">create table t_user(\n\tid int not null,\n    username varchar(30),\n    email varchar(128),\n    phone varchar(15),\n    login_time datetime,\n    key idx_username(username),\n    primary key(id)\n);\n</code></pre><p>下面是聚簇索引的一个示意图，分支页面中的索引条目为 (id, page num)，叶子页面中，索引条目为 (id, db_trx_id, db_roll_ptr, user_name, …）。这里的 db_trx_id、db_roll_ptr 是InnoDB中的隐藏字段，后续的课程中还会详细介绍。</p><p><img src=\"https://static001.geekbang.org/resource/image/7e/6f/7ee87b17ba7bb96b4fe00a46b564dd6f.jpg?wh=1796x833\" alt=\"图片\"></p><h4>二级索引</h4><p>下面是索引idx_username的一个示意图，分支页面中，索引条目为 (username, id, page num），叶子页面中，索引条目为 (username, id）。</p><p><img src=\"https://static001.geekbang.org/resource/image/09/54/09dea79a57325beff273bae8ea508754.jpg?wh=1782x829\" alt=\"图片\"></p><p>虽然索引idx_username的定义中只有username字段，但是我们把username和id拼在一起看作是Key字段。username可能有重复值，但是username和id拼在一起，就不会重复了。</p><h3>索引结构详解</h3><p>我们来看一下B+树索引的结构，索引记录在页面中有序存放，每个索引页通过Next和Prev指针指向相邻的页面。</p><p><img src=\"https://static001.geekbang.org/resource/image/ef/6d/ef9be3b9c91a39ab3c9fa782dfdf476d.jpg?wh=1580x895\" alt=\"图片\"></p><p>在上图展示的3个相邻的叶子页面中，Page i中的记录总是小于Page j中的记录，Page j中的记录总是小于Page k中的记录，依次扫描i、j、k这3个页面得到的记录（Ki1，Ki2，…，Kj1，Kj2，…，Kk1，Kk2，…）已经是有序的。</p><p>如果我们要查询的记录，K介于Kpj和Kpk之间，最终会定位到叶子页面Page j，使用二分查找法，就能找到这条记录，或者发现这条记录不存在。这里我们假设K的值没有重复。对K的值有重复的情况，可以参考接下来对组合索引的描述。</p><h4>组合索引</h4><p>组合索引是指定义中包含多个字段的索引，下面这个例子中的idx_abc就是一个组合索引。</p><pre><code class=\"language-plain\">create table tab(\n    id int not null,\n    a int,\n    b int,\n    c int,\n    ......,\n    primary key(id),\n    key idx_abc(a,b,c)\n) engine=innodb;\n</code></pre><p>组合索引的结构实际上和单列索引是一样的，只不过索引条目由更多的字段组成。我们来看一下组合索引idx_abc局部结构的示意图。</p><p><img src=\"https://static001.geekbang.org/resource/image/0a/60/0aa8102417f9e606bf12b6a72a22d960.jpg?wh=1814x1066\" alt=\"图片\"><br>\n组合索引中，索引条目也是按顺序存放的。</p><p>我们来考虑组合索引idx_abc的两条索引记录：记录1（A1，B1，C1，ID1）和记录2（A2，B2，C2，ID2），如何比较这两条记录的大小？</p><p>比较规则如下：</p><ol>\n<li>\n<p>先比较字段A的大小，如果A1 &gt; A2，则记录1大，如果A1 &lt; A2，则记录2大。</p>\n</li>\n<li>\n<p>如果A1 == A2，则继续比较B1和B2。如果B1 &gt; B2，则记录1大，如果B1 &lt; B2，则记录2大。</p>\n</li>\n<li>\n<p>如果B1 == B2，则继续比较C1和C2。如果C1 &gt; C2，则记录1大，如果C1 &lt;  C2，则记录2大。</p>\n</li>\n<li>\n<p>如果C1 == C2，则继续比较ID1和ID2。因为ID是主键，所以ID1和ID2一定不相等，比较ID1和ID2就能得出记录的大小。</p>\n</li>\n</ol><p>对于非唯一索引，索引记录中Key的值可能存在重复值。但是索引记录中还包括了主键字段，加上主键字段后，整条索引记录就不会重复了。</p><h2>访问路径</h2><p>SQL语句查询数据时，通过在WHERE子句中指定字段需要满足的条件来获取的数据，不需要指定数据的物理属性。数据库引擎需要将逻辑的SQL语句转换为物理的访问路径，从表中获取数据。</p><h3>全表扫描</h3><p>InnoDB中，表的数据存储在聚簇索引的叶子页面中。全表扫描时，需要依次访问每一个叶子页面。对于下面这个SQL，phone字段既不是主键，也没有建二级索引，因此需要扫描所有的叶子页面，才能获取到满足条件的数据。</p><pre><code class=\"language-plain\">select * from t_user where phone='xxx';\n</code></pre><p>大表的全表扫描会大量消耗CPU和IO，应当尽量避免。有些情况下可给查询字段建立合适的索引，避免全表扫描。当然有的场景下，业务可能就是需要获取整个表的所有数据，比如数据仓库需要同步整个表的数据做数据分析。可以考虑在业务低峰期执行这类全表扫描的SQL，或者建立读库，专门执行这类SQL。</p><h3>索引访问</h3><h4>索引字段等值匹配</h4><p>等值匹配是指WHERE条件中，索引字段以等于 (=) 方式匹配。对于组合索引，可以使用索引的前缀字段。刚刚例子里的组合索引 idx_abc(a,b,c)，以下查询都可以使用索引匹配：</p><pre><code class=\"language-plain\">select * from tab where a = 'a';\nselect * from tab where a = 'a' and b = 'b'\nselect * from tab where a = 'a' and b = 'b' and c = 'c'\n</code></pre><p>但是下面这几个查询就无法使用索引匹配了，因为缺少了字段a的等于条件。</p><pre><code class=\"language-plain\">select * from tab where b = 'b'\nselect * from tab where c = 'c'\nselect * from tab where b = 'b' and c = 'c'\n</code></pre><p>对于下面这个SQL，可以用到索引前缀字段A进行等值匹配，但是字段C则无法用到索引等值匹配中。</p><pre><code class=\"language-plain\">select * from tab where a = 'a' and c = 'c'\n</code></pre><p>我们用下面这个例子，来说明索引等值匹配的执行过程。</p><pre><code class=\"language-plain\">select * from tab where a = 'Aj' \n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/46/14/466038532e7d5796ed58ff294a0d4a14.jpg?wh=1840x1072\" alt=\"图片\"><br>\n执行过程大致如下：</p><ol>\n<li>\n<p>根据where条件，定位到记录所在的最开始的那个叶子页面。</p>\n</li>\n<li>\n<p>在叶子页面中定位到第1条满足条件的记录。如果使用的是二级索引，则还需要根据索引记录中的主键值，到聚簇索引查找数据。获取到记录后，检查该记录是否满足WHERE子句中的其他条件。若满足条件，则将这一行记录返回给Server层处理。</p>\n</li>\n<li>\n<p>处理下一条的记录。如果当前页面的记录已经处理完了，则继续处理下一个相邻页面中的记录。</p>\n</li>\n<li>\n<p>如果获取到的记录不满足索引条件（where A = Aj），则说明没有更多的数据了，停止扫描。</p>\n</li>\n</ol><h4>索引范围扫描（Index Range Scan）</h4><p>索引范围扫描是很常见的一种执行方式。索引范围扫描可以分为几种情况：</p><ol>\n<li>\n<p>只限制了范围的最大值，没有限制最小值，如where A &lt;= Aj。</p>\n</li>\n<li>\n<p>只限制了范围的最小值，没有限制最大值，如where A &gt;= Aj。</p>\n</li>\n<li>\n<p>限制了范围的最小值和最大值，如where A &gt;= Ai and A &lt;= Aj。</p>\n</li>\n</ol><p>每种情况下，还要看是否包含边界值。使用大于（&gt;）和小于（&lt;）条件时，不包含边界值。</p><p>索引范围扫描和索引等值匹配的执行过程比较相似，主要的区别在于如何确定扫描的边界。如果没有限制最小值，则要从索引中的第1条记录开始扫描。如果没有限制最大值，则需要一直扫描到索引的最后一个叶子页面。</p><p>我们来对比下面这2个语句。</p><pre><code class=\"language-plain\">## 语句1\nselect * from tab where A &gt;= Aj\n\n\n## 语句2\nselect * from tab where A &gt; Aj\n</code></pre><p>这2个语句都要根据边界值Aj来定位扫描的开始位置，语句1从记录 (Aj, B2, C1,I Di2) 开始扫描。语句2从记录 (Ak, B3, C, IDk3) 开始扫描。</p><p><img src=\"https://static001.geekbang.org/resource/image/ae/0b/ae481f65bd4f5be735a1ef6ed7123f0b.jpg?wh=1840x936\" alt=\"图片\"></p><h4>索引逆序扫描</h4><p>索引还支持逆序扫描，比如下面这个SQL中，使用了order b desc。</p><pre><code class=\"language-plain\">select * from tab where A = Aj order by B desc\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/d2/58/d2c662152c8427f66d7ea7493d09fc58.jpg?wh=1812x993\" alt=\"图片\"></p><p>由于索引中的条目都是有序的，在字段A的值固定的情况下，字段B是有序的，因此只需要按索引条目的顺序反向扫描就可以了。</p><p>逆序扫描有几个特点：</p><ol>\n<li>\n<p>逆序扫描从区间的最大值处开始。如果where条件中没有限制最大值，则从索引的最后一个页面开始扫描。</p>\n</li>\n<li>\n<p>在InnoDB的实现上，逆序扫描比顺序扫描成本要更高一些。索引页面中，索引条目顺序组成一个单向的链表，逆序访问时，需要做更多的计算。</p>\n</li>\n</ol><h4>无法使用索引的一些情况</h4><ol>\n<li>组合索引中，缺少前缀字段的查询条件。考虑下面这个组合索引，索引字段为C1，C2，……，Ck。</li>\n</ol><pre><code class=\"language-plain\">alter table tab add key idx_c1tok(c1, c2, c3, ..., ck);\n</code></pre><p>一个语句能用到这个索引需要满足这些前置条件。</p><ul>\n<li>\n<p>索引前缀字段以等值匹配的形式出现在where子句中。</p>\n</li>\n<li>\n<p>如果索引中的某个字段Ci没有出现在where子句中，或者where子句中Ci以非等值匹配的形式出现，则该字段之后的索引字段不能用来减少索引扫描的范围。</p>\n</li>\n</ul><p>比如下面这两个SQL中，语句1缺少了C2的查询条件，语句2中C2使用了范围条件，因此C3上的条件并不能用来限制索引的扫描范围。</p><pre><code class=\"language-plain\">语句1: select * from tab where c1 = 'x' and c3 = 'y';\n语句2: select * from tab where c1 = 'x' and c2 &gt;= 'p' and c2 &lt;= 'q' and c3 = 'y';\n</code></pre><ul>\n<li>索引字段Cj可以使用范围扫描的前提条件：字段Cj是索引的第一个字段，或者索引中Cj之前的字段都以等值匹配的形式出现在where子句中。</li>\n</ul><ol start=\"2\">\n<li>where子句中，在索引字段上进行了运算，则无法使用索引。比如下面这几个SQL，虽然字段A上建有索引，但是WHERE子句，对字段A做了运算，所以无法使用到索引。</li>\n</ol><pre><code class=\"language-plain\">select * from tab where a+0 = 1;\nselect * from tab where to_char(a) = '1';\n</code></pre><ol start=\"3\">\n<li>索引字段存在隐式转换。如果索引字段和传入的参数类型不匹配，可能会在索引字段上发生类型隐式转换，这会导致索引无法使用。</li>\n</ol><pre><code class=\"language-plain\">create table tab (\n    id int not null,\n    b varchar(30),\n    ......\n    primary key(id),\n    key idx_b(b)\n);\n\n\nselect * from tab where b = 1;\n</code></pre><ol start=\"4\">\n<li>使用了不支持的运算符。</li>\n</ol><pre><code class=\"language-plain\">select * from tab where a != 1;\n</code></pre><h4>索引的其他作用</h4><p>除了用来快速检索数据，索引还有一些其他的作用。</p><ol>\n<li><strong>利用索引的有序性消除排序</strong></li>\n</ol><p>如果SQL里order by字段顺序和索引字段顺序一致，则可以利用索引的有序性避免排序。下面这个例子中，使用了Order by C2, C3，同时C1有等值匹配的条件，因此按索引条目的顺序读取的数据，已经满足了SQL的要求，MySQL就不用再额外进行排序了。</p><pre><code class=\"language-plain\">index (C1, C2, C3, C4, ...)\n\n\nselect * from tab\nwhere C1 = x\norder by C2, C3\n</code></pre><p>当然，利用索引来避免排序也有一些前置条件。</p><ul>\n<li>\n<p>查询本身能使用这个索引。</p>\n</li>\n<li>\n<p>order by中列的顺序和索引中字段顺序一致，并且排序方向一致。</p>\n</li>\n<li>\n<p>where子句中以等值匹配形式出现的索引列和order by中的列连在一起是索引的前缀。</p>\n</li>\n</ul><p>比如下面这些SQL都需要额外排序。</p><pre><code class=\"language-plain\">## 少了C2\nselect * from tab where C1 = x1 order by C3, C4\n\n\n## C2使用了范围条件\nselect * from tab where C1 = x1 and C2 &gt;= x2 order by C3\n\n\n## C3用了逆序\nselect * from tab where C1 = x1 order by C2, C3 desc\n\n\n## order by中字段顺序和索引不一致\nselect * from tab where C1 = x1 order by C3, C2\n</code></pre><ol start=\"2\">\n<li><strong>覆盖索引</strong></li>\n</ol><p>如果一个查询涉及到的字段全都包含在一个索引中，则可以使用索引来满足查询，不需要回表。</p><p>下面这个语句中，所有涉及到的字段都包含在同一个索引中，因此可以使用覆盖索引来满足查询。</p><pre><code class=\"language-plain\">index(C1, C2, C3, C4, C5)\n\n\nselect C1,C2 \nfrom tab\nwhere C3=x\norder by C5\n</code></pre><p>如果索引占用的空间比聚簇索引要小很多，那么扫描索引的成本也会比扫描整个表要低，使用覆盖索引可以提升查询的性能。当然，由于MySQL MVCC的实现机制，即便是用到了覆盖索引，也有可能需要回表，以构建记录的历史版本，关于这一点我们在第三章再详细介绍。</p><ol start=\"3\">\n<li><strong>索引条件下推</strong></li>\n</ol><p>对于下面这样的SQL，虽然字段C3的条件不能用来限制索引扫描的范围，但是MySQL可以将这个条件下推给InnoDB，InnoDB可以利用索引中C3字段的值来过滤掉一些不满足条件的记录，减少回表的次数。</p><pre><code class=\"language-plain\">index(C1, C2, C3)\n\n\nselect * from tab where C1 = x and C3 = y\n</code></pre><p>我们可以利用这个特点，在创建索引时冗余一些常用的查询字段，来提升性能。</p><h3>表连接</h3><p>最后我们来简单介绍下表连接的几种算法。</p><h4>嵌套循环连接</h4><p>嵌套循环连接是MySQL中最早支持的连接算法。</p><p><img src=\"https://static001.geekbang.org/resource/image/bd/db/bd0230cb1152498f7e81250705484bdb.jpg?wh=1442x836\" alt=\"图片\"><br>\n上面这个就是嵌套循环连接的一个示意图，执行步骤大致是：</p><ol>\n<li>\n<p>使用驱动表Tab_1的条件定位到满足条件的记录。</p>\n</li>\n<li>\n<p>每次从步骤1获取到一行记录后，查询Tab_2表。</p>\n</li>\n<li>\n<p>查询Tab_2时，使用从Tab_1表带过来的关联条件，以及Tab_2原先的条件，来获取数据。</p>\n</li>\n</ol><p>嵌套查询连接的性能，取决于3个因素。</p><ol>\n<li>\n<p>从驱动表获取数据的效率如何。</p>\n</li>\n<li>\n<p>驱动表中满足条件的记录数，这决定了被驱动表需要查询多少次。</p>\n</li>\n<li>\n<p>从被驱动表中获取数据的效率如何。</p>\n</li>\n</ol><h4>哈希连接</h4><p>在嵌套循环连接算法下，如果被驱动表没有合适的索引可以使用，那么从驱动表每获取一行记录，都要全表扫描一次被驱动表。这种情况下，MySQL使用了块嵌套循环（BNL）策略，先将驱动表中的一批数据缓存到Join Buffer中，然后再全表扫描被驱动表，和Join Buffer中的记录进行匹配。MySQL 8.0在块嵌套循环的基础上，支持了哈希连接算法。</p><p><img src=\"https://static001.geekbang.org/resource/image/fe/e9/feb076d58yy1a2e3fd0f26bfc621c4e9.jpg?wh=1650x864\" alt=\"图片\"></p><p>哈希连接算法的执行步骤大致为：</p><ol>\n<li>\n<p>扫描驱动表Tab_1，并构建哈希表；</p>\n</li>\n<li>\n<p>扫描被驱动表Tab_2；</p>\n</li>\n<li>\n<p>使用从Tab_2中获取到的记录，到步骤1构建的哈希表中匹配数据。</p>\n</li>\n</ol><p>如果驱动表满足条件的记录数较多，无法一次性加载到Join Buffer中，则需要分批处理。</p><h4>合并排序连接</h4><p>实际上，到8.0版本为止，MySQL并不支持排序合并连接。</p><p><img src=\"https://static001.geekbang.org/resource/image/5c/69/5cf786f5fd77c39608423cc1c4061469.jpg?wh=1664x830\" alt=\"图片\"></p><p>合并排序连接算法的执行步骤大致为：</p><ol>\n<li>\n<p>获取Tab_1表满足条件的记录，按连接键排序。</p>\n</li>\n<li>\n<p>获取Tab_2表满足条件的记录，按连接键排序。</p>\n</li>\n<li>\n<p>读取步骤1、2生成的有序数据，执行合并连接。</p>\n</li>\n</ol><h2>总结</h2><p>这一讲中，我们学习了数据库中最重要的几种访问路径：全表扫描、索引访问、表连接。理解这些内容，能帮你更好地掌握SQL优化。</p><p>当然，一个SQL语句，并不是说用了索引性能就一定好，不用索引性能就一定不好。优化器会根据具体的情况来进行评估要不要使用索引、使用哪些索引，对于表连接，优化器还需要确定连接的顺序和连接的算法，这些内容在接下来的几讲中揭秘。</p><h2>思考题</h2><pre><code class=\"language-plain\">create table t_n(a int not null, primary key(a));\n\ninsert into t_n values(1),(2),(3),(4),(5),(6),(7),(8),(9),(10),\n  (11),(12),(13),(14),(15),(16),(17),(18),(19),(20);\n\ncreate table t_abc(\n    id int not null auto_increment,\n    a int not null,\n    b int not null,\n    c int not null,\n    d int not null,\n    padding varchar(200),\n    primary key(id),\n    key idx_abc(a,b,c)\n) engine=innodb;\n\ninsert into t_abc(a,b,c,d, padding)\nselect t1.a, t2.a, t3.a, t3.a, rpad('', 200, 'ABC DEF G XYZ')\nfrom t_n t1, t_n t2, t_n t3;\n</code></pre><p>根据测试表t_abc的结构，分析下面这几个SQL语句的执行路径，有哪些区别？</p><pre><code class=\"language-plain\">select * from t_abc where a = 10 and b = 10;\nselect * from t_abc where a = 10 and c = 10;\nselect * from t_abc where a = 10 and d = 10;\n\n\nselect * from t_abc where a = 10 order by a,c;\nselect * from t_abc where a = 10 order by b,c;\n\nselect id, a, b, c from t_abc where a = 10;\nselect id, a, b, c from t_abc where b = 10;\nselect id, a, b, c, d from t_abc where b = 10;\n</code></pre><p>期待你的思考，欢迎在留言区中与我交流。如果今天的课程让你有所收获，也欢迎转发给有需要的朋友。我们下节课再见！</p>","neighbors":{"left":{"article_title":"16｜如何在不影响业务的情况下平滑升级MySQL？","id":809542},"right":{"article_title":"18｜读懂MySQL中的执行计划（上）","id":810683}},"comments":[{"had_liked":false,"id":394584,"user_name":"123","can_delete":false,"product_type":"c1","uid":2662872,"ip_address":"浙江","ucode":"5A343B568B9524","user_header":"https://static001.geekbang.org/account/avatar/00/28/a1/d8/42252c48.jpg","comment_is_top":false,"comment_ctime":1727246850,"is_pvip":false,"replies":[{"id":143234,"content":"解读非常全面👍","user_name":"作者回复","user_name_real":"编辑","uid":3898827,"ctime":1727333051,"ip_address":"浙江","comment_id":394584,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100799401,"comment_content":"思考题：\n以下测验均在mysql8.0.29版本中：\n\n#符合idx_abc索引的顺序条件，可以通过a,b进行条件筛选，但是需要回表\nselect * from t_abc where a = 10 and b = 10;\n\n#符合idx_abc索引的最左匹配原则，c=10未能使用索引匹配，但可以使用索引条件下推，过滤一些索引行\nselect * from t_abc where a = 10 and c = 10;\n\n#符合idx_abc索引最左匹配，但只能利用a字段过滤，需要回表，再判断d的值，若改成or则不走索引\nselect * from t_abc where a = 10 and d = 10;\n\n上述三条语句全部走索引，区别在于能利用索引提升的速度不同；\n\n#无法利用索引有序性消除排序，因为字段顺序不连续(Using filesort)\nselect * from t_abc where a = 10 order by a,c;\n\n#无需额外排序\nselect * from t_abc where a = 10 order by b,c;\n\n#完美匹配idx_abc，走覆盖索引\nselect id, a, b, c from t_abc where a = 10;\n\n上述两条sql语句区别在于能否通过索引原有的顺序而消除排序；\n\n#因为不符合最左匹配原则，应该不走二级索引，但是由于所需字段均在idx_abc中，mysql认为走索引的扫描成本会更低，所以走了索引，扫描行数和下面的全表扫描的行数是一致的，走了覆盖索引(Using index)\nselect id, a, b, c from t_abc where b = 10;\n\n#和select * 无异，因为b上面建索引且不符合最左匹配原则，走全表扫描\nselect id, a, b, c, d from t_abc where b = 10;\n\n上述三条sql区别在于是否可以利用覆盖索引，根据语句的内容选择扫描成本低的方案","like_count":1,"discussions":[{"author":{"id":3898827,"avatar":"https://static001.geekbang.org/account/avatar/00/3b/7d/cb/fa3dae58.jpg","nickname":"俊达","note":"","ucode":"F79BF9651AD086","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":651723,"discussion_content":"解读非常全面👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1727333051,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":395261,"user_name":"山河已无恙","can_delete":false,"product_type":"c1","uid":2882998,"ip_address":"内蒙古","ucode":"D5961E0B59A137","user_header":"https://static001.geekbang.org/account/avatar/00/2b/fd/b6/5edc8c70.jpg","comment_is_top":false,"comment_ctime":1729935637,"is_pvip":false,"replies":[{"id":143511,"content":"从执行计划看，使用索引hotel_id过滤出来的数据有300多万行，差不多占了整个表数据的一半。\n\n使用索引的话，SQL要回表300多万次，相当于300多万次基于主键的查询。\n\n不用索引的话，走全表扫描，遍历聚簇索引的叶子页面。扫描的过程中，过滤数据，再排序。确实可能会比使用索引的效率更高。","user_name":"作者回复","user_name_real":"编辑","uid":3898827,"ctime":1730104497,"ip_address":"浙江","comment_id":395261,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100799401,"comment_content":"测试用的表，用于模拟业务表\n```sql\nSET profiling=1;\nSELECT COUNT(*)  FROM ams_accounts_order;\n&#47;* 受影响记录行数: 0  已找到记录行: 1  警告: 0  持续时间 1 查询: 1.469 秒. *&#47;\nSHOW PROFILE;\n```\n数据量\n\nams_accounts_order\n---\n| COUNT(*) | \n| ---: | \n| 6202700 | \n\n默认情况下只有主键，两个查询条件的查询时间\n\n```sql\nSET profiling=1;\nSELECT * from ams_accounts_order where hotel_id = 10029 AND room_order_no = &#39;UDDH807015895560880128&#39; ORDER BY accounts_id DESC \n\n;\n&#47;* 受影响记录行数: 0  已找到记录行: 18  警告: 0  持续时间 1 查询: 6.250 秒. *&#47;\nSHOW PROFILE;\nSET profiling=0;\n```\n\n对其中一个查询条件添加索引\n\n```sql\nALTER TABLE `ams_accounts_order`\n\tDROP INDEX `hotel_id`,\n\tADD INDEX `hotel_id` (`hotel_id`);\n```\n\n再次查询\n\n```sql\nSET profiling=1;\nSELECT * from ams_accounts_order where hotel_id = 10029 AND room_order_no = &#39;UDDH807015895560880128&#39; ORDER BY accounts_id DESC ;\n&#47;* 受影响记录行数: 0  已找到记录行: 18  警告: 0  持续时间 1 查询: 18.547 秒. *&#47;\nSHOW PROFILE;\nSET profiling=0;\n```\n发现加了不如不加，时间是原来的 3 倍多\n\n查看 `EXPLAIN` 结果中的 `key` 和 `Extra` 字段,确认使用了创建的索引\n\n\nEXPLAIN\n| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | \n| ---: | --- | --- | --- | --- | --- | --- | --- | --- | ---: | ---: | --- | \n| 1 | SIMPLE | ams_accounts_order | \\N | ref | hotel_id | hotel_id | 4 | const | 3069172 | 10.00 | Using where | \n\n老师这种情况为什么加了不如不加","like_count":0,"discussions":[{"author":{"id":3898827,"avatar":"https://static001.geekbang.org/account/avatar/00/3b/7d/cb/fa3dae58.jpg","nickname":"俊达","note":"","ucode":"F79BF9651AD086","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":653036,"discussion_content":"从执行计划看，使用索引hotel_id过滤出来的数据有300多万行，差不多占了整个表数据的一半。\n\n使用索引的话，SQL要回表300多万次，相当于300多万次基于主键的查询。\n\n不用索引的话，走全表扫描，遍历聚簇索引的叶子页面。扫描的过程中，过滤数据，再排序。确实可能会比使用索引的效率更高。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1730104497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":1,"child_discussions":[{"author":{"id":2882998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/fd/b6/5edc8c70.jpg","nickname":"山河已无恙","note":"","ucode":"D5961E0B59A137","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":3898827,"avatar":"https://static001.geekbang.org/account/avatar/00/3b/7d/cb/fa3dae58.jpg","nickname":"俊达","note":"","ucode":"F79BF9651AD086","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":653264,"discussion_content":"明白了，谢谢老师 ^_^","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1730526117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":653036,"ip_address":"内蒙古","group_id":0},"score":653264,"extra":""}]}]},{"had_liked":false,"id":394587,"user_name":"123","can_delete":false,"product_type":"c1","uid":2662872,"ip_address":"浙江","ucode":"5A343B568B9524","user_header":"https://static001.geekbang.org/account/avatar/00/28/a1/d8/42252c48.jpg","comment_is_top":false,"comment_ctime":1727249100,"is_pvip":false,"replies":[{"id":143233,"content":"问题1：第三章会讲物理存储结构。页面编号在每个页面头部有记录。页面编号可以直接转换为文件中的偏移量：PageNumber * PageSize，PageSize是固定的，默认就是16384。\n\n问题2：每个区块中的64个页面，在文件中是连续的（1M空间），但是对应到磁盘中的扇区，不一定是连续的。\n页面分裂时，InnoDB会使用一些方法，尽量让索引页面在文件中相邻，但不保证。\n页面分裂时会复制一部分数据到新的页面。同一层中，索引页面逻辑上组成一个双向链表。\n","user_name":"作者回复","user_name_real":"编辑","uid":3898827,"ctime":1727332871,"ip_address":"浙江","comment_id":394587,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100799401,"comment_content":"老师，请教两个问题：\n1、“在分支页面中，Value 存了下一层索引页面的编号（Page No），页面编号就是页面在数据文件中的地址”，其中页面编号就是页面在数据文件中地址，这个数据文件应该就是.ibd文件吧，存储了数据信息，并且一二级索引的数据都在这个文件里面，所在在ibd文件中哪里可以看到页编号，老师后面会讲数据的物理存储结构吗？\n\n2、表数据存储在页中，页中存储行数据，当行数据变大之后，例如可变长VARCHAR字段，则就会进行页的新增，老师文中提到，每个区块由连续的64个数据页组成，这里应该是物理连续吧？那么行内数据增加后务必会造成数据页的分裂，也就是说原来一页能存100条，现在只能存储50条了，同时为了保证连续，多出的页面会造成后续页面在空间上移动，进而造成在磁盘空间中数据的移动，不知道怎么理解对不对，那么为了防止大量的数据移动，区块或者段数据之间应该是逻辑连续而不是物理连续，也就是说使用链表的形式连接？","like_count":0,"discussions":[{"author":{"id":3898827,"avatar":"https://static001.geekbang.org/account/avatar/00/3b/7d/cb/fa3dae58.jpg","nickname":"俊达","note":"","ucode":"F79BF9651AD086","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":651722,"discussion_content":"问题1：第三章会讲物理存储结构。页面编号在每个页面头部有记录。页面编号可以直接转换为文件中的偏移量：PageNumber * PageSize，PageSize是固定的，默认就是16384。\n\n问题2：每个区块中的64个页面，在文件中是连续的（1M空间），但是对应到磁盘中的扇区，不一定是连续的。\n页面分裂时，InnoDB会使用一些方法，尽量让索引页面在文件中相邻，但不保证。\n页面分裂时会复制一部分数据到新的页面。同一层中，索引页面逻辑上组成一个双向链表。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1727332871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]}]}