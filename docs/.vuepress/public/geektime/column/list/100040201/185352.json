{"id":185352,"title":"20 | 领域驱动设计：35岁的程序员应该写什么样的代码？","content":"<p>我在阿里巴巴工作的头一年，坐在我对面的同事负责开发一个公司统一的运维系统。他对这个系统经过谨慎的调研和认真的思考，花费了半年多的时间开发，终于开发完了。然后邀请各个部门的相关同事做发布评审，如果大家没什么意见就发布上线，全公司范围统一推广使用。</p><p>结果在这个发布会上，几乎所有部门的同事都提出了不同的意见：虽然这个功能是我们需要的，但是那个特性却是不能接受的，我们以往不是这样的……</p><p>最糟糕的是，不同部门的这个功能和那个特性又几乎不相同。最终讨论的结果是，这个系统不发布推广，需要重新设计。</p><p>这个同事又花了几个月的时间尝试满足所有部门的不同的需求，最终发现无法统一这些功能需求，于是辞职了……</p><p>他离职后，有次会上我们又讨论起这个项目为什么会失败，其中有个同事的话让我印象深刻，他的话的大意是：如果你对自己要开发的业务领域没有清晰的定义和边界，<strong>没有设计系统的领域模型</strong>，而仅仅跟着所谓的需求不断开发功能，一旦需求来自多个方面，就可能发生需求冲突，或者随着时间的推移，前后功能也会发生冲突，这时你越是试图弥补这些冲突，就越是陷入更大的冲突之中。</p><p>回想一下我经历的各种项目，似乎确实如此。用户或者产品经理的需求零零散散，不断变更。工程师在各处代码中寻找可以实现这些需求变更的代码，修修补补。软件只有需求分析，并没有真正的设计，系统没有一个统一的领域模型维持其内在的逻辑一致性。功能特性并不是按照领域模型内在的逻辑设计，而是按照各色人等自己的主观想象设计。项目时间一长，各种困难重重，需求不断延期，线上bug不断，管理者考虑是不是要推到重来，而程序员则考虑是不是要跑路。</p><!-- [[[read_end]]] --><h2>领域模型模式</h2><p>目前企业级应用开发中，业务逻辑的组织方式主要是<strong>事务脚本</strong>模式。事务脚本按照业务处理的过程组织业务逻辑，每个过程处理来自客户端的单个请求。客户端的每次请求都包含了一定的业务处理逻辑，而程序则按照每次请求的业务逻辑进行划分。</p><p>事务脚本模式典型的就是Controller→Service→Dao这样的程序设计模式。Controller封装用户请求，根据请求参数构造一些数据对象调用Service，Service里面包含大量的业务逻辑代码，完成对数据的处理，期间可能需要通过Dao从数据库中获取数据，或者将数据写入数据库中。</p><p>比如这样一个业务场景：每个销售合同都包含一个产品，根据销售的不同产品类型计算收入，当用户支付的时候，需要计算合同收入。</p><p>按照事务脚本模式，也就是我们目前习惯的方法，程序设计可能是这样的：</p><p><img src=\"https://static001.geekbang.org/resource/image/0f/20/0f207cfe38ec0bf2fed2a6e7a6517620.png?wh=1050*516\" alt=\"\"></p><p>用户发起请求到Controller，Controller调用Service的calculateRecognition方法，并将合同ID传递过去计算确认收入。Service根据合同ID调用Dao查找合同信息，根据合同获得产品类型，再根据产品类型计算收入，然后把确认收入保存到数据库。</p><p>这里一个很大的问题在于，不同产品类型收入的计算方法不同，如果修改计算方法，或者增加新的产品类型，都需要修改这个Service类，随着业务不断复杂，这个类会变得越来越难以维护。</p><p>在这里，Service只是用来放收入计算方法的一个类，并没有什么设计的约束。如果有一天，另一个客户端需要计算另一种产品类型收入，很大可能会重新写一个Service。于是，相同的业务在不同的地方维护，事情变得更加复杂。</p><p>由于事务脚本模式中，Service、Dao这些对象只有方法，没有数值成员变量，而方法调用时传递的数值对象没有方法（或者只有一些getter、setter方法），因此事务脚本又被称作<strong>贫血模型</strong>。</p><p><strong>领域模型</strong>模式和事务脚本模式不同。在领域模型模式下，业务逻辑围绕领域模型设计。比如收入确认是和合同强相关的，是合同对象的一个职责，那么合同对象就应该提供一个calculateRecognition方法计算收入。</p><p>领域模型中的对象和事务脚本中的对象有很大的不同，比如事务脚本中也有合同Contract这个对象，但是这个Contract只包含合同的数据信息，不包含和合同有关的计算逻辑，计算逻辑在Service类里。</p><p>而领域模型的对象则包含了对象的数据和计算逻辑，比如合同对象，既包含合同数据，也包含合同相关的计算。因此从面向对象的角度看，领域模型才是真正的面向对象。如果用领域模型设计上面的合同收入确认，是这样的：</p><p><img src=\"https://static001.geekbang.org/resource/image/00/76/00974ec0e16cb4fa0045303162b95076.png?wh=1798*582\" alt=\"\"></p><p>计算收入的请求直接提交给合同对象Contract，这个时候，就无需传递合同ID，因为请求的合同对象就是这个ID的对象。合同对象聚合了一个产品对Product，并调用这个product的calculateRecognition方法，把合同对象传递过去。不同产品关联不同的收入确认策略recognitionStrategy，调用recognitionStrategy的calculateRecognition，完成收入对象revenueRecognition的创建，也就完成了收入计算。</p><p>这里Contract和Product都是领域模型对象，<strong>领域模型是合并了行为和数据的领域的对象模型</strong>。通过领域模型对象的交互完成业务逻辑的实现，也就是说，设计好了领域模型对象，也就设计好了业务逻辑实现。和事务脚本被称作贫血模型相对应的，领域模型也被称为充血模型。</p><p>对于复杂的业务逻辑实现来说，用领域模型模式更有优势。特别是在持续的需求变更和业务迭代过程中，把握好领域模型，对业务逻辑本身也会有更清晰的认识。使用领域模型增加新的产品类型的时候，就不需要修改现有的代码，只需要扩展新的产品类和收入策略类就可以了。</p><p>在需求变更过程中，如果一个需求和领域模型有冲突，和模型的定义以及模型间的交互逻辑不一致，那么很有可能这个需求本身就是伪需求。很多看似合理的需求其实和业务的内在逻辑是有冲突的，这样的需求也不会带来业务的价值，通过领域模型分析，可以识别出这样的伪需求，使系统更好地保持一致性，也可以使开发资源投入到更有价值的地方去。</p><h2>领域驱动设计（DDD）</h2><p>前面我讲到领域模型模式，那么如何用领域模型模式设计一个完整而复杂的系统，有没有完整的方法和过程指导整个系统的设计？领域驱动设计，即DDD就是用来解决这一问题的。</p><p><strong>领域</strong>是一个组织所做的事情以及其包含的一切，通俗地说，就是组织的业务范围和做事方式，也是软件开发的目标范围。比如对于淘宝这样一个以电子商务为主要业务的组织，C2C电子商务就是它的领域。<strong>领域驱动设计就是从领域出发，分析领域内模型及其关系，进而设计软件系统的方法。</strong></p><p>但是如果我们说要对C2C电子商务这个领域进行建模设计，那么这个范围就太大了，不知道该如何下手。所以通常的做法是把整个领域拆分成多个<strong>子域</strong>，比如用户、商品、订单、库存、物流、发票等。强相关的多个子域组成一个<strong>限界上下文</strong>，限界上下文是对业务领域范围的描述，对于系统实现而言，可以想象成相当于是一个子系统或者是一个模块。限界上下文和子域共同组成组织的领域，如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/fc/1a/fc05b9e59b857be7eb79fd42d7b4741a.jpg?wh=1280*917\" alt=\"\" title=\"图片源自网络\"></p><p>不同的限界上下文，也就是不同的子系统或者模块之间会有各种的交互合作。如何设计这些交互合作呢？DDD使用<strong>上下文映射图</strong>来完成，如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/0a/bb/0a802030bd21f0234fe0814a8f4c3fbb.png?wh=722*372\" alt=\"\"></p><p>在DDD中，领域模型对象也被称为<strong>实体</strong>，每个实体都是唯一的，具有一个唯一标识，一个订单对象是一个实体，一个产品对象也是一个实体，订单ID或者产品ID是它们的唯一标识。实体可能会发生变化，比如订单的状态会变化，但是它们的唯一标识不会变化。</p><p><strong>实体设计</strong>是DDD的核心所在，首先通过业务分析，识别出实体对象，然后通过相关的业务逻辑设计实体的属性和方法。这里最重要的，是要把握住实体的特征是什么，实体应该承担什么职责，不应该承担什么职责，分析的时候要放在业务场景和限界上下文中，而不是想当然地认为这样的实体就应该承担这样的角色。</p><p>事实上，并不是领域内的对象都应该被设计为实体，DDD推荐尽可能将对象设计为<strong>值对象</strong>。比如像住址这样的对象就是典型的值对象，也许建在住址上的房子可以被当做一个实体，但是住址仅仅是对房子的一个描述，像这样仅仅用来做度量或描述的对象应该被设计为值对象。</p><p>值对象的一个特点是不变性，一个值对象创建以后就不能再改变了。如果地址改变了，那就是一个新地址，而一个订单实体则可能会经历创建、待支付、已支付、代发货、已发货、待签收、待评价等各种变化。</p><p>领域实体和限界上下文包含了业务的主要逻辑，但是最终如何构建一个系统，如何将领域实体对外暴露，开发出一个完整的系统。事实上，DDD支持各种架构方案，比如典型的<strong>分层架构</strong>：</p><p><img src=\"https://static001.geekbang.org/resource/image/0a/1c/0a2b32ee054a0c9bcc202c6f7c043c1c.png?wh=306*372\" alt=\"\"></p><p>领域实体被放置在领域层，通过应用层对领域实体进行包装，最终提供一组访问接口，通过接口层对外开放。</p><p><strong>六边形架构</strong>是DDD中比较知名的一种架构方式，领域模型通过应用程序封装成一个相对比较独立的模块，而不同的外部系统则通过不同的适配器和领域模型交互，比如可以通过HTTP接口访问领域模型，也可以通过Web Service或者消息队列访问领域模型，只需要为这些不同的访问接口提供不同的适配器就可以了。</p><p><img src=\"https://static001.geekbang.org/resource/image/e4/0d/e4506951ed15f90bd4c61c8fe58ef40d.png?wh=1116*732\" alt=\"\"></p><p>领域驱动设计的技术体系内还有其他一些方法和概念，但是最核心的还是领域模型本身，<strong>通过领域实体及其交互完成业务逻辑处理才是DDD的核心目标</strong>。至于是不是用了CQRS，是不是事件驱动，有没有事件溯源，并不是DDD的核心。</p><h2>小结</h2><p>回到我们的题目，一个35岁的程序员应该写什么样的代码？如果一个工作十多年的程序员，还是仅仅写一些跟他工作第一年差不多的CRUD代码。那么他迟早会遇到自己的职业危机。公司必然愿意用更年轻、更努力，当然也更低薪水的程序员来代替他。至于学习新技术的能力，其实多年工作经验也并没有太多帮助，有时候也许还是劣势。</p><p>在我看来，35岁的程序员真正有优势的是他在一个业务领域的多年积淀，对业务领域有更深刻的理解和认知。</p><p>那么如何将这些业务沉淀和理解反映到工作中，体现在代码中呢？也许可以尝试探索领域驱动设计。如果一个人有多年的领域经验，那么必然对领域模型设计有更深刻的认识，把握好领域模型在不断的需求变更中的演进，使系统维持更好的活力，并因此体现自己真正的价值。</p><h2>思考题</h2><p>你觉得大龄程序员的优势是什么？如何在公司保持自己的优势和地位？</p><p>欢迎你在评论区写下你的思考，也欢迎把这篇文章分享给你的朋友或者同事，一起交流一下。</p>","neighbors":{"left":{"article_title":"19 | 组件设计原则：组件的边界在哪里？","id":185043},"right":{"article_title":"答疑丨对于设计模式而言，场景到底有多重要？","id":186504}},"comments":[{"had_liked":false,"id":170898,"user_name":"leon","can_delete":false,"product_type":"c1","uid":1217955,"ip_address":"","ucode":"97610F35D2543A","user_header":"https://static001.geekbang.org/account/avatar/00/12/95/a3/0a3cde60.jpg","comment_is_top":false,"comment_ctime":1578753266,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"216327118066","product_id":100040201,"comment_content":"公司是不需要程序员的，公司只需要能创造价值的人。大龄程序员的优势是他不仅仅是一个程序员了，他更是在某一业务、某一领域内的领域专家，而且知道如何用技术去解决实际问题，创造价值。","like_count":51},{"had_liked":false,"id":169169,"user_name":"搞怪者😘 😒 😏 👿","can_delete":false,"product_type":"c1","uid":1300678,"ip_address":"","ucode":"40DFF5D3E3B24C","user_header":"https://static001.geekbang.org/account/avatar/00/13/d8/c6/2b2a58cf.jpg","comment_is_top":false,"comment_ctime":1578283194,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"83182661818","product_id":100040201,"comment_content":"老师可以提供一下领域模型的例子吗，光看这个有点不懂","like_count":19,"discussions":[{"author":{"id":1088710,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/c6/05a6798f.jpg","nickname":"苗","note":"","ucode":"5ECCC6C855E541","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296234,"discussion_content":"可以参考DDD的专栏。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596476524,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169828,"user_name":"Zend","can_delete":false,"product_type":"c1","uid":1053921,"ip_address":"","ucode":"80EBB0B6772E27","user_header":"https://static001.geekbang.org/account/avatar/00/10/14/e1/ee5705a2.jpg","comment_is_top":false,"comment_ctime":1578453292,"is_pvip":false,"replies":[{"id":"65988","content":"👍","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1578531925,"ip_address":"","comment_id":169828,"utype":1}],"discussion_count":2,"race_medal":0,"score":"78887864620","product_id":100040201,"comment_content":"记得在老师的一篇文章中说好的程序员的工作效率是一般程序员的10倍甚至更多。好的程序员不仅代码写的漂亮，可维护性强 ，面对需求变动时能更从容面对。那如何做一个好的程序员 我想对领域的理解，对需求的理解 ，具有一定的前瞻性思考，适时提出自己的建设性建议，通过代码让公司的业务系统可持续发展，推动公司业务的增长。","like_count":18,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480736,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578531925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2033730,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/08/42/b14f3a32.jpg","nickname":"Geek_2ecc5d","note":"","ucode":"4B6D777B754A80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287044,"discussion_content":"给你多少钱，你考虑的比马云还牛逼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593353242,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172200,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1579130937,"is_pvip":false,"replies":[{"id":"66809","content":"👍","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1579137331,"ip_address":"","comment_id":172200,"utype":1}],"discussion_count":2,"race_medal":0,"score":"66003640377","product_id":100040201,"comment_content":"事务脚本模式的特点在于状态都在数据库里，业务逻辑在service层，业务逻辑与状态完全分离。<br>领域对象模型，特点是聚合状态和操作，提供相对独立的模块和类。领域的模型的对象之一是实体，有唯一标识，实体被销毁前标识不变，能通过标识获得，实体的状态会变化。领域的另外一种对象是值对象，状态在生命周期内不变，因而更简单。领域对象因为有状态可以表达更为丰富的关系。但是设计好的领域对象依靠的主要不是技术而是对业务的理解。大龄程序员选择的业务领域的余地还是越来越小的，可能人老了就是这样。<br>","like_count":15,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481661,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579137331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1177931,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f9/4b/5532c234.jpg","nickname":"Messi","note":"","ucode":"04302B9E7F1D75","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215889,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585394985,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169724,"user_name":"山猫","can_delete":false,"product_type":"c1","uid":1466682,"ip_address":"","ucode":"004F622AEDA906","user_header":"https://static001.geekbang.org/account/avatar/00/16/61/3a/a259c187.jpg","comment_is_top":false,"comment_ctime":1578415283,"is_pvip":false,"replies":[{"id":"65879","content":"👍","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1578451160,"ip_address":"","comment_id":169724,"utype":1}],"discussion_count":1,"race_medal":0,"score":"44528088243","product_id":100040201,"comment_content":"第一次听到DDD这个东西还是在一年前，仔细了解后发现，其实这个早在学习软件工程的时候就被提及。简单地说，就是针对某个领域，从功能或者组件的角度去进行对象的设计。<br><br>另外关于 35 岁的问题，我认为除了要保持学习能力外，还需要有系统架构能力和丰富的经验，同时还需要了解经济、历史、政治，锻炼自己的社交和口才。","like_count":10,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480694,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578451160,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250389,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1601046571,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"35960784939","product_id":100040201,"comment_content":"算是领域驱动设计的入门篇吧，如果想要深入学习，估计还得去隔壁的专栏看看，另外更重要的是如何在项目中落地。<br><br>有一个疑惑，关于实体，在面向对象分析的时候，似乎也是强调要找到业务领域、找到实体，当然可能不像领域驱动设计这么有针对性。<br><br>大龄程序员有什么优势？<br><br>先说劣势，比年轻人更贵，但是对工作的投入程度可能不如年轻人，如果不持续学习的话，那么技术也可能落伍，综合起来就是性价比太低。<br><br>优势呢，可能比年轻人成熟稳定一些，一般情况下不敢删库跑路，毕竟还要养家糊口。如果单写 CRUD 估计写不过年轻小伙子，但是如果是复杂一点的业务逻辑，经验可能还是会有一些作用。<br><br>对于大龄程序员在业务领域的积累，我有一点怀疑。其实这个和学习新技术一样，如果你不去学习和思考，那么就不会有什么积累。<br><br>最后，作为一个不必面对“35岁问题”的大龄程序员（因为我已经 40+ 了），仍然希望自己能去做技术，可是“留给中国队的时间不多了”。","like_count":9},{"had_liked":false,"id":222399,"user_name":"左耳朵狮子","can_delete":false,"product_type":"c1","uid":1067280,"ip_address":"","ucode":"095DD787E58967","user_header":"https://static001.geekbang.org/account/avatar/00/10/49/10/af49fa20.jpg","comment_is_top":false,"comment_ctime":1590791320,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"23065627800","product_id":100040201,"comment_content":"大龄人的优势，会学习和学习方向的效率是没有经验的人无法比的。 （比如，有经验的用google search 较没经验的用google search，可能就是两种完全不同的工具）。或者通俗来讲，学习某一方面，你不知道你不知道什么。有经验的，打一枪可能就学会了。没经验的打10枪才学会。（有人可能说，年轻的是个快枪手，那35岁怎么定的界限？心老了，18岁就已经是81岁了。这里不杠，34.5岁就年轻了？36.2岁就年老了？）","like_count":5,"discussions":[{"author":{"id":1079495,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/c7/083a3a0b.jpg","nickname":"新世界","note":"","ucode":"4473DC1505F158","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":277447,"discussion_content":"兄弟，你这名字霸气啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591058965,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169221,"user_name":"ant","can_delete":false,"product_type":"c1","uid":1556708,"ip_address":"","ucode":"A39A03AF257471","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKYLPAlGUWic4yAqsGtEYBSRR7gDjyg9yiaJicNhMwiaNw4rMKQ5DHTfp7gmic0gpqEwCZaou8G6CdHKCg/132","comment_is_top":false,"comment_ctime":1578296027,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"14463197915","product_id":100040201,"comment_content":"这一章，真的是感受到了理解层面的难度，或许当我对某一领域有了完全充分的理解，并参与了类似的模型设计，才能更好的理解理论层面！","like_count":3,"discussions":[{"author":{"id":1529298,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/iacfiaRC2Vze9eEaVibAFkngm4nmA0DwoibC3kHj6pCOQ87VDa955kK3kavnrDnibmfeIFd4G6Ab2fDkNrbUapL8ibAQ/132","nickname":"你的美","note":"","ucode":"71B97BDBA3CDC3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":122886,"discussion_content":"来我这里，参与一次领域模型设计","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578378421,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1020525,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","nickname":"escray","note":"","ucode":"1F4204930E47C4","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":1529298,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/iacfiaRC2Vze9eEaVibAFkngm4nmA0DwoibC3kHj6pCOQ87VDa955kK3kavnrDnibmfeIFd4G6Ab2fDkNrbUapL8ibAQ/132","nickname":"你的美","note":"","ucode":"71B97BDBA3CDC3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308725,"discussion_content":"还招人么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601045636,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":122886,"ip_address":""},"score":308725,"extra":""}]}]},{"had_liked":false,"id":239278,"user_name":"苗","can_delete":false,"product_type":"c1","uid":1088710,"ip_address":"","ucode":"5ECCC6C855E541","user_header":"https://static001.geekbang.org/account/avatar/00/10/9c/c6/05a6798f.jpg","comment_is_top":false,"comment_ctime":1596474743,"is_pvip":false,"replies":[{"id":"88399","content":"可以写一篇文章详细讲讲你的领域驱动设计实践吗？文章发到评论区一起学习下。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1596504779,"ip_address":"","comment_id":239278,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10186409335","product_id":100040201,"comment_content":"个人从传统mvc转到领域驱动的主要动力是，领域驱动的代码模型中使用设计模式提高对需求的响应能力很方便，比如校验做成责任链，加个策略实现，模板。","like_count":2,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503043,"discussion_content":"可以写一篇文章详细讲讲你的领域驱动设计实践吗？文章发到评论区一起学习下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596504779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223810,"user_name":"而立斋","can_delete":false,"product_type":"c1","uid":1087258,"ip_address":"","ucode":"5FED6E9E148195","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/1a/389eab84.jpg","comment_is_top":false,"comment_ctime":1591185428,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5886152724","product_id":100040201,"comment_content":"最大的优势就是耐操","like_count":1},{"had_liked":false,"id":184745,"user_name":"探索无止境","can_delete":false,"product_type":"c1","uid":1044178,"ip_address":"","ucode":"91D2A9907DFA79","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/d2/7024431c.jpg","comment_is_top":false,"comment_ctime":1583395250,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5878362546","product_id":100040201,"comment_content":"老师能否加餐再通过一个案例讲讲DDD？老师总能把复杂的东西讲得清晰明了","like_count":1},{"had_liked":false,"id":172018,"user_name":"靠人品去赢","can_delete":false,"product_type":"c1","uid":1301286,"ip_address":"","ucode":"7A20F9EBE847E1","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/26/54f2c164.jpg","comment_is_top":false,"comment_ctime":1579072219,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5874039515","product_id":100040201,"comment_content":"其实这个贫血模型，应该指的是Dao一类的吧，就是一个存值取值的一个东西，没啥逻辑。最后都是交给service处理，不关心业务逻辑，扩展会导致增加service，万一要做什么新的扩展关于dao导致别的service也要考虑。<br>这个Service只管逻辑的也是贫血模型吗？充血模型有什么比较好的最佳实践吗？","like_count":1},{"had_liked":false,"id":169328,"user_name":"唐二毛","can_delete":false,"product_type":"c1","uid":1597884,"ip_address":"","ucode":"7C16F45165F4BA","user_header":"https://static001.geekbang.org/account/avatar/00/18/61/bc/a656bee7.jpg","comment_is_top":false,"comment_ctime":1578315453,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"5873282749","product_id":100040201,"comment_content":"老师，我在DDD 的实践过程中，遇到两个问题: 1. 业务逻辑包含在Aggregate A中，而业务逻辑往往需要查询多个其他aggregate , 但是 Aggregate 又不能用 @Autowired 的方式来注入service&#47;repository, 所以我的做法是首先将依赖的aggregate 查询出来，再作为参数传入到处理业务的aggtegate A中，感觉这种做法并不是很好，因为查询aggregate B 的参数也是业务逻辑的一部分，所以无法真正将业务逻辑收在 Aggregate A 里面， 希望老师指点一下! <br>2. 我们的aggregate 关联链条很长，A -&gt; B-&gt; ... -&gt; G , 并且，业务逻辑中往往需要用到这些关联的数据，如果用@ManyToMany的方式，就会使得 Aggregate 特别大，查询效率也很慢，还有就是循环依赖的问题，以前的做法都是用一个中间关联表来记录，但是这样好像是面向表编程，按照DDD，应该怎么设计呢？ 如何在Aggregate 中来实现这些业务逻辑呢？","like_count":1,"discussions":[{"author":{"id":1179565,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ff/ad/5020a8c5.jpg","nickname":"Farewell丶","note":"","ucode":"A0D69893C5375C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":136770,"discussion_content":"实体或者聚合应该向更小的方向去设计。面对你这种情况，看起来是一个查询需求，而不是业务操作，那么应该利用类似CQRS的架构方式，将这个查询视图单独映射出来，而不是通过一个聚合来整体管理，不然代码很难搞，效率也不高。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1579163154,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1597884,"avatar":"https://static001.geekbang.org/account/avatar/00/18/61/bc/a656bee7.jpg","nickname":"唐二毛","note":"","ucode":"7C16F45165F4BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1179565,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ff/ad/5020a8c5.jpg","nickname":"Farewell丶","note":"","ucode":"A0D69893C5375C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":139606,"discussion_content":"不单是查询，例如: 生成一笔订单的时候要计算手续费，计算手续费就需要: 用户的信息，用户来源的相关信息，用户的交易历史信息，还需要手续费计算规则的信息，这些信息都是在不同的微服务中的，计算手续费只是众多步骤中的一步，还有其他步骤，需要更多的信息，这些信息几乎涵盖了整个系统，这种情况怎么处理?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579307099,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":136770,"ip_address":""},"score":139606,"extra":""},{"author":{"id":1179565,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ff/ad/5020a8c5.jpg","nickname":"Farewell丶","note":"","ucode":"A0D69893C5375C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1597884,"avatar":"https://static001.geekbang.org/account/avatar/00/18/61/bc/a656bee7.jpg","nickname":"唐二毛","note":"","ucode":"7C16F45165F4BA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":150849,"discussion_content":"那么我觉得根据你们自己业务所做的微服务划分并不太合理。比如用户交易历史，手续费计算规则，这些是不是应该统合到订单服务中，都想要根据你的因为进行更多的思考讨论判断。通过ddd做微服务最后应该保持相对比较良好的边界，微服务调用是不可避免，但是网络太多有可能存在问题。当然也就是有可能哈，之前看过b站的微服务调用示例，一个用户接口就涉及了20多个微服务调用，也是正常的。关键还是要思考自己的微服务到底划分合不合理，每个微服务是不是高性能，全流程能不能保证正常情况下的高性能，和异常情况下得高可用。对经验不多的业务开发和架构来说，这个业务加技术的综合考量，甚至有时候还有公司战略和内部政治的因素在里边，在决策和判断上就更显得比较困难了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1579831212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":139606,"ip_address":""},"score":150849,"extra":""},{"author":{"id":1088710,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/c6/05a6798f.jpg","nickname":"苗","note":"","ucode":"5ECCC6C855E541","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1597884,"avatar":"https://static001.geekbang.org/account/avatar/00/18/61/bc/a656bee7.jpg","nickname":"唐二毛","note":"","ucode":"7C16F45165F4BA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296235,"discussion_content":"这些参数就是值对象，在应用层调用其它聚合暴露的接口获取数据，然后传递给实现核心业务的聚合。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596476845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":139606,"ip_address":""},"score":296235,"extra":""}]},{"author":{"id":1529298,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/iacfiaRC2Vze9eEaVibAFkngm4nmA0DwoibC3kHj6pCOQ87VDa955kK3kavnrDnibmfeIFd4G6Ab2fDkNrbUapL8ibAQ/132","nickname":"你的美","note":"","ucode":"71B97BDBA3CDC3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":122908,"discussion_content":"这是不是多个聚合完成同一个业务逻辑，假如微服务内有提供总线服务，就按顺序直接调用完成。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578379592,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":350134,"user_name":"java小霸王","can_delete":false,"product_type":"c1","uid":1168540,"ip_address":"","ucode":"7094BCD9F25E1E","user_header":"https://static001.geekbang.org/account/avatar/00/11/d4/9c/030e80d3.jpg","comment_is_top":false,"comment_ctime":1656589395,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1656589395","product_id":100040201,"comment_content":"优势应该是 深度和广度的积累，学习新技术的速度，看问题的本质，在某个领域的权威，同时具有一定的创造性","like_count":1},{"had_liked":false,"id":298797,"user_name":"黄老板","can_delete":false,"product_type":"c1","uid":1424264,"ip_address":"","ucode":"7C420E7FDFEA17","user_header":"https://static001.geekbang.org/account/avatar/00/15/bb/88/2d4b475c.jpg","comment_is_top":false,"comment_ctime":1624327874,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624327874","product_id":100040201,"comment_content":"老师下面这段话说的很有道理，但是实际开发过程中就是存在各种伪需求客户要求实现，领导、产品不管什么设计模型不管合理性，就是霸王硬上弓就是要开发就算各种写死把代码弄的一团糟也要快速实现，这是很多中小企业目前为了生成而面临的现状，完全就是客户说啥就是啥，所以做开发越来越累了，各种无脑加班<br><br>上文原话如下：<br>在需求变更过程中，如果一个需求和领域模型有冲突，和模型的定义以及模型间的交互逻辑不一致，那么很有可能这个需求本身就是伪需求。很多看似合理的需求其实和业务的内在逻辑是有冲突的，这样的需求也不会带来业务的价值，通过领域模型分析，可以识别出这样的伪需求，使系统更好地保持一致性，也可以使开发资源投入到更有价值的地方去。","like_count":0},{"had_liked":false,"id":218764,"user_name":"小高","can_delete":false,"product_type":"c1","uid":1283052,"ip_address":"","ucode":"FCD422249F7355","user_header":"https://static001.geekbang.org/account/avatar/00/13/93/ec/985675c8.jpg","comment_is_top":false,"comment_ctime":1589871610,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589871610","product_id":100040201,"comment_content":"在工作中也要努力提升作为一个程序员的编程技能和软实力。","like_count":0},{"had_liked":false,"id":193446,"user_name":"X.L.","can_delete":false,"product_type":"c1","uid":1682258,"ip_address":"","ucode":"3402A8DCE81099","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/UuOV8OrMeRGuibY76OXzuBwOoL4Eru5VcFlctXlBDauibRUD0rXSsG1ibogBasmeDTbXdJOD4NGjTI2u5HAQK2bWg/132","comment_is_top":false,"comment_ctime":1584893256,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584893256","product_id":100040201,"comment_content":"如果能做一个项目从需求到拆解领域模型，到伪代码开发，并且有例子规范各个子域的互相调用方式就更好了","like_count":0},{"had_liked":false,"id":171756,"user_name":"Haan","can_delete":false,"product_type":"c1","uid":1388133,"ip_address":"","ucode":"7A7BBE0D0CD39E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eq8qpSvBoZz89u3BhGXWLibs2OibCkZl8bx74aLSJ58f467bR8anNaTiccJklcqjBdhfvvJpvLVmYesA/132","comment_is_top":false,"comment_ctime":1579007154,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579007154","product_id":100040201,"comment_content":"大龄程序员 除了基本的技能之外，需要扎根于某一特定的领域。right？","like_count":0}]}