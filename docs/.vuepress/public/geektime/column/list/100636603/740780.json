{"id":740780,"title":"第 16 章 解析器(1)","content":"<h1 id=\"nav_point_152\">第 16 章　解析器</h1>\n<p>在第 15 章中，我们初步讨论了解析器（parser）的工作原理，知道了解析器本质上是一个状态机。但我们也曾提到，正则表达式其实也是一个状态机。因此在编写 <code>parser</code> 的时候，利用正则表达式能够让我们少写不少代码。本章我们将更多地利用正则表达式来实现 HTML 解析器。另外，一个完善的 HTML 解析器远比想象的要复杂。我们知道，浏览器会对 HTML 文本进行解析，那么它是如何做的呢？其实关于 HTML 文本的解析，是有规范可循的，即 WHATWG 关于 HTML 的解析规范，其中定义了完整的错误处理和状态机的状态迁移流程，还提及了一些特殊的状态，例如 <code>DATA</code>、<code>CDATA</code>、<code>RCDATA</code>、<code>RAWTEXT</code> 等。那么，这些状态有什么含义呢？它们对解析器有哪些影响呢？什么是 HTML 实体，以及 Vue.js 模板解析器需要如何处理 HTML 实体呢？这些问题都会在本章中讨论。</p>\n<h2 id=\"nav_point_153\">16.1　文本模式及其对解析器的影响</h2>\n<p>文本模式指的是<strong>解析器</strong>在工作时所进入的一些特殊状态，在不同的特殊状态下，解析器对文本的解析行为会有所不同。具体来说，当解析器遇到一些特殊标签时，会切换模式，从而影响其对文本的解析行为。这些特殊标签是：</p>\n<ul>\n<li><code>&lt;title&gt;</code> 标签、<code>&lt;textarea&gt;</code> 标签，当解析器遇到这两个标签时，会切换到 <code>RCDATA</code> 模式；</li>\n<li><code>&lt;style&gt;</code>、<code>&lt;xmp&gt;</code>、<code>&lt;iframe&gt;</code>、<code>&lt;noembed&gt;</code>、<code>&lt;noframes&gt;</code>、<code>&lt;noscript&gt;</code> 等标签，当解析器遇到这些标签时，会切换到 <code>RAWTEXT</code> 模式；</li>\n<li>当解析器遇到 <code>&lt;![CDATA[</code> 字符串时，会进入 <code>CDATA</code> 模式。</li>\n</ul>\n<p>解析器的初始模式则是 <code>DATA</code> 模式。对于 Vue.js 的模板 DSL 来说，模板中不允许出现 <code>&lt;script&gt;</code> 标签，因此 Vue.js 模板解析器在遇到 <code>&lt;script&gt;</code> 标签时也会切换到 <code>RAWTEXT</code> 模式。</p><!-- [[[read_end]]] -->\n<p>解析器的行为会因工作模式的不同而不同。WHATWG 规范的第 13.2.5.1 节给出了初始模式下解析器的工作流程，如图 16-1 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00633.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 16-1　WHATWG 规范中关于 <code>Data state</code> 的描述</strong></p>\n<p>我们对图 16-1 做一些必要的解释。在默认的 <code>DATA</code> 模式下，解析器在遇到字符 <code>&lt;</code> 时，会切换到<strong>标签开始状态</strong>（tag open state）。换句话说，在该模式下，解析器能够解析标签元素。当解析器遇到字符 <code>&amp;</code> 时，会切换到<strong>字符引用状态</strong>（character reference state），也称 HTML 字符实体状态。也就是说，在 <code>DATA</code> 模式下，解析器能够处理 HTML 字符实体。</p>\n<p>我们再来看看当解析器处于 <code>RCDATA</code> 状态时，它的工作情况如何。图 16-2 给出了 WHATWG 规范第 13.2.5.2 节的内容。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00634.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 16-2　WHATWG 规范中关于 <code>RCDATA state</code> 的描述</strong></p>\n<p>由图 16-2 可知，当解析器遇到字符 <code>&lt;</code> 时，不会再切换到标签开始状态，而会切换到 <code>RCDATA less-than sign state</code> 状态。图 16-3 给出了 <code>RCDATA less-than sign state</code> 状态下解析器的工作方式。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00635.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 16-3　WHATWG 规范中关于 <code>RCDATA less-than sign state</code> 的描述</strong></p>\n<p>由图 16-3 可知，在 <code>RCDATA less-than sign state</code> 状态下，如果解析器遇到字符 <code>/</code>，则直接切换到 <code>RCDATA</code> 的结束标签状态，即 <code>RCDATA end tag open state</code>；否则会将当前字符 <code>&lt;</code> 作为普通字符处理，然后继续处理后面的字符。由此可知，在 <code>RCDATA</code> 状态下，解析器不能识别标签元素。这其实间接说明了在 <code>&lt;textarea&gt;</code> 内可以将字符 <code>&lt;</code> 作为普通文本，解析器并不会认为字符 <code>&lt;</code> 是标签开始的标志，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> &lt;textarea&gt;\n   &lt;div&gt;asdf&lt;/div&gt;asdfasdf\n &lt;/textarea&gt;\n</code></pre>\n<p>在上面这段 HTML 代码中，<code>&lt;textarea&gt;</code> 标签内存在一个 <code>&lt;div&gt;</code> 标签。但解析器并不会把 <code>&lt;div&gt;</code> 解析为标签元素，而是作为普通文本处理。但是，由图 16-2 可知，在 <code>RCDATA</code> 模式下，解析器仍然支持 HTML 实体。因为当解析器遇到字符 <code>&amp;</code> 时，会切换到字符引用状态，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> &lt;textarea&gt;&amp;copy;&lt;/textarea&gt;\n</code></pre>\n<p>浏览器在渲染这段 HTML 代码时，会在文本框内展示字符 ©。</p>\n<p>解析器在 <code>RAWTEXT</code> 模式下的工作方式与在 <code>RCDATA</code> 模式下类似。唯一不同的是，在 <code>RAWTEXT</code> 模式下，解析器将不再支持 HTML 实体。图 16-4 给出了 WHATWG 规范第 13.2.5.3 节中所定义的 <code>RAWTEXT</code> 模式下状态机的工作方式。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00636.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 16-4　WHATWG 规范中关于 <code>RAWTEXT state</code> 的描述</strong></p>\n<p>对比图 16-4 与图 16-2 可知，<code>RAWTEXT</code> 模式的确不支持 HTML 实体。在该模式下，解析器会将 HTML 实体字符作为普通字符处理。Vue.js 的单文件组件的解析器在遇到 <code>&lt;script&gt;</code> 标签时就会进入 <code>RAWTEXT</code> 模式，这时它会把 <code>&lt;script&gt;</code> 标签内的内容全部作为普通文本处理。</p>\n<p><code>CDATA</code> 模式在 <code>RAWTEXT</code> 模式的基础上更进一步。图 16-5 给出了 WHATWG 规范第 13.2.5.69 节中所定义的 CDATA 模式下状态机的工作方式。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00637.jpeg\" alt=\"\" width=\"70%\" style=\"width: 70%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 16-5　WHATWG 规范中关于 <code>CDATA section state</code> 的描述</strong></p>\n<p>在 <code>CDATA</code> 模式下，解析器将把任何字符都作为普通字符处理，直到遇到 <code>CDATA</code> 的结束标志为止。</p>\n<p>实际上，在 WHATWG 规范中还定义了 <code>PLAINTEXT</code> 模式，该模式与 <code>RAWTEXT</code> 模式类似。不同的是，解析器一旦进入 <code>PLAINTEXT</code> 模式，将不会再退出。另外，Vue.js 的模板 DSL 解析器是用不到 <code>PLAINTEXT</code> 模式的，因此我们不会过多介绍它。</p>\n<p>表 16-1 汇总了不同的模式及各其特性。</p>\n<p><strong>表 16-1　不同的模式及其特性</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>模式</p></th>\n<th><p>能否解析标签</p></th>\n<th><p>是否支持 HTML 实体</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>DATA</code></p></td>\n<td><p>能</p></td>\n<td><p>是</p></td>\n</tr>\n<tr>\n<td><p><code>RCDATA</code></p></td>\n<td><p>否</p></td>\n<td><p>是</p></td>\n</tr>\n<tr>\n<td><p><code>RAWTEXT</code></p></td>\n<td><p>否</p></td>\n<td><p>否</p></td>\n</tr>\n<tr>\n<td><p><code>CDATA</code></p></td>\n<td><p>否</p></td>\n<td><p>否</p></td>\n</tr>\n</tbody>\n</table>\n<p>除了表 16-1 列出的特性之外，不同的模式还会影响解析器对于终止解析的判断，后文会具体讨论。另外，后续编写解析器代码时，我们会将上述模式定义为状态表，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> const TextModes = {\n   DATA: 'DATA',\n   RCDATA: 'RCDATA',\n   RAWTEXT: 'RAWTEXT',\n   CDATA: 'CDATA'\n }\n</code></pre>\n<h2 id=\"nav_point_154\">16.2　递归下降算法构造模板 AST</h2>\n<p>从本节开始，我们将着手实现一个更加完善的模板解析器。解析器的基本架构模型如下：</p>\n<pre class=\"code-rows\"><code> // 定义文本模式，作为一个状态表\n const TextModes = {\n   DATA: 'DATA',\n   RCDATA: 'RCDATA',\n   RAWTEXT: 'RAWTEXT',\n   CDATA: 'CDATA'\n }\n<p>// 解析器函数，接收模板作为参数<br />\nfunction parse(str) {<br />\n// 定义上下文对象<br />\nconst context = {<br />\n// source 是模板内容，用于在解析过程中进行消费<br />\nsource: str,<br />\n// 解析器当前处于文本模式，初始模式为 DATA<br />\nmode: TextModes.DATA<br />\n}<br />\n// 调用 parseChildren 函数开始进行解析，它返回解析后得到的子节点<br />\n// parseChildren 函数接收两个参数：<br />\n// 第一个参数是上下文对象 context<br />\n// 第二个参数是由父代节点构成的节点栈，初始时栈为空<br />\nconst nodes = parseChildren(context, [])</p>\n<p>// 解析器返回 Root 根节点<br />\nreturn {<br />\ntype: ‘Root’,<br />\n// 使用 nodes 作为根节点的 children<br />\nchildren: nodes<br />\n}<br />\n}<br />\n</code></pre></p>\n<p>在上面这段代码中，我们首先定义了一个状态表 <code>TextModes</code>，它用来描述预定义的文本模式。然后，我们定义了 <code>parse</code> 函数，即解析器函数，在其中定义了上下文对象 <code>context</code>，用来维护解析程序执行过程中程序的各种状态。接着，调用 <code>parseChildren</code> 函数进行解析，该函数会返回解析后得到的子节点，并使用这些子节点作为 <code>children</code> 来创建 <code>Root</code> 根节点。最后，<code>parse</code> 函数返回根节点，完成模板 AST 的构建。</p>\n<p>这段代码的思路与我们在第 15 章中讲述的关于模板 AST 的构建思路有所不同。在第 15 章中，我们首先对模板内容进行标记化得到一系列 Token，然后根据这些 Token 构建模板 AST。实际上，创建 Token 与构造模板 AST 的过程可以同时进行，因为模板和模板 AST 具有同构的特性。</p>\n<p>另外，在上面这段代码中，<code>parseChildren</code> 函数是整个解析器的核心。后续我们会递归地调用它来不断地消费模板内容。<code>parseChildren</code> 函数会返回解析后得到的子节点。举个例子，假设有如下模板：</p>\n<pre class=\"code-rows\"><code> &lt;p&gt;1&lt;/p&gt;\n &lt;p&gt;2&lt;/p&gt;\n</code></pre>\n<p>上面这段模板有两个根节点，即两个 <code>&lt;p&gt;</code> 标签。<code>parseChildren</code> 函数在解析这段模板后，会得到由这两个 <code>&lt;p&gt;</code> 节点组成的数组：</p>\n<pre class=\"code-rows\"><code> [\n   { type: 'Element', tag: 'p', children: [/*...*/]  },\n   { type: 'Element', tag: 'p', children: [/*...*/]  },\n ]\n</code></pre>\n<p>之后，这个数组将作为 <code>Root</code> 根节点的 <code>children</code>。</p>\n<p><code>parseChildren</code> 函数接收两个参数。</p>\n<ul>\n<li>第一个参数：上下文对象 <code>context</code>。</li>\n<li>第二个参数：由父代节点构成的栈，用于维护节点间的父子级关系。</li>\n</ul>\n<p><code>parseChildren</code> 函数本质上也是一个状态机，该状态机有多少种状态取决于子节点的类型数量。在模板中，元素的子节点可以是以下几种。</p>\n<ul>\n<li>标签节点，例如 <code>&lt;div&gt;</code>。</li>\n<li>文本插值节点，例如 <code>{{ val }}</code>。</li>\n<li>普通文本节点，例如：<code>text</code>。</li>\n<li>注释节点，例如 <code>&lt;!----&gt;</code>。</li>\n<li><code>CDATA</code> 节点，例如 <code>&lt;![CDATA[ xxx ]]&gt;</code>。</li>\n</ul>\n<p>在标准的 HTML 中，节点的类型将会更多，例如 <code>DOCTYPE</code> 节点等。为了降低复杂度，我们仅考虑上述类型的节点。</p>\n<p>图 16-6 给出了 <code>parseChildren</code> 函数在解析模板过程中的状态迁移过程。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00638.jpeg\" alt=\"\" width=\"80%\" style=\"width: 80%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 16-6　<code>parseChildren</code> 函数在解析模板过程中的状态迁移过程</strong></p>\n<p>我们可以把图 16-6 所展示的状态迁移过程总结如下。</p>\n<ul>\n<li>当遇到字符 <code>&lt;</code> 时，进入临时状态。<ul>\n<li>如果下一个字符匹配正则 <code>/a-z/i</code>，则认为这是一个标签节点，于是调用 <code>parseElement</code> 函数完成标签的解析。注意正则表达式 <code>/a-z/i</code> 中的 <code>i</code>，意思是忽略大小写（case-insensitive）。</li>\n<li>如果字符串以 <code>&lt;!--</code> 开头，则认为这是一个注释节点，于是调用 <code>parseComment</code> 函数完成注释节点的解析。</li>\n<li>如果字符串以 <code>&lt;![CDATA[</code> 开头，则认为这是一个 <code>CDATA</code> 节点，于是调用 <code>parseCDATA</code> 函数完成 <code>CDATA</code> 节点的解析。</li>\n</ul>\n</li>\n<li>如果字符串以 <code>{{</code> 开头，则认为这是一个插值节点，于是调用 <code>parseInterpolation</code> 函数完成插值节点的解析。</li>\n<li>其他情况，都作为普通文本，调用 <code>parseText</code> 函数完成文本节点的解析。</li>\n</ul>\n<p>落实到代码时，我们还需要结合文本模式，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function parseChildren(context, ancestors) {\n   // 定义 nodes 数组存储子节点，它将作为最终的返回值\n   let nodes = []\n   // 从上下文对象中取得当前状态，包括模式 mode 和模板内容 source\n   const { mode, source } = context\n<p>// 开启 while 循环，只要满足条件就会一直对字符串进行解析<br />\n// 关于 isEnd() 后文会详细讲解<br />\nwhile(!isEnd(context, ancestors)) {<br />\nlet node<br />\n// 只有 DATA 模式和 RCDATA 模式才支持插值节点的解析<br />\nif (mode === TextModes.DATA || mode === TextModes.RCDATA) {<br />\n// 只有 DATA 模式才支持标签节点的解析<br />\nif (mode === TextModes.DATA &amp;&amp; source[0] === ‘&lt;’) {<br />\nif (source[1] === ‘!’) {<br />\nif (source.startsWith(‘&lt;!–’)) {<br />\n// 注释<br />\nnode = parseComment(context)<br />\n} else if (source.startsWith(‘&lt;![CDATA[’)) {<br />\n// CDATA<br />\nnode = parseCDATA(context, ancestors)<br />\n}<br />\n} else if (source[1] === ‘/’) {<br />\n// 结束标签，这里需要抛出错误，后文会详细解释原因<br />\n} else if (/[a-z]/i.test(source[1])) {<br />\n// 标签<br />\nnode = parseElement(context, ancestors)<br />\n}<br />\n} else if (source.startsWith(‘{{’)) {<br />\n// 解析插值<br />\nnode = parseInterpolation(context)<br />\n}<br />\n}</p>\n<pre><code> // node 不存在，说明处于其他模式，即非 DATA 模式且非 RCDATA 模式\n // 这时一切内容都作为文本处理\n if (!node) {\n   // 解析文本节点\n   node = parseText(context)\n }\n\n // 将节点添加到 nodes 数组中\n nodes.push(node)\n</code></pre>\n<p>}</p>\n<p>// 当 while 循环停止后，说明子节点解析完毕，返回子节点<br />\nreturn nodes<br />\n}<br />\n</code></pre></p>\n<p>上面这段代码完整地描述了图 16-6 所示的状态迁移过程，这里有几点需要注意。</p>\n<ul>\n<li><code>parseChildren</code> 函数的返回值是由子节点组成的数组，每次 <code>while</code> 循环都会解析一个或多个节点，这些节点会被添加到 <code>nodes</code> 数组中，并作为 <code>parseChildren</code> 函数的返回值返回。</li>\n<li>解析过程中需要判断当前的文本模式。根据表 16-1 可知，只有处于 <code>DATA</code> 模式或 <code>RCDATA</code> 模式时，解析器才支持插值节点的解析。并且，只有处于 <code>DATA</code> 模式时，解析器才支持标签节点、注释节点和 <code>CDATA</code> 节点的解析。</li>\n<li>在 16.1 节中我们介绍过，当遇到特定标签时，解析器会切换模式。一旦解析器切换到 <code>DATA</code> 模式和 <code>RCDATA</code> 模式之外的模式时，一切字符都将作为文本节点被解析。当然，即使在 <code>DATA</code> 模式或 <code>RCDATA</code> 模式下，如果无法匹配标签节点、注释节点、<code>CDATA</code> 节点、插值节点，那么也会作为文本节点解析。</li>\n</ul>\n<p>除了上述三点内容外，你可能对这段代码仍然有疑问，其中之一是 <code>while</code> 循环何时停止？以及 <code>isEnd()</code> 函数的用途是什么？这里我们给出简单的解释，<code>parseChildren</code> 函数是用来解析子节点的，因此 <code>while</code> 循环一定要遇到父级节点的结束标签才会停止，这是正常的思路。但这个思路存在一些问题，不过我们这里暂时将其忽略，后文会详细讨论。</p>\n<p>我们可以通过一个例子来更加直观地了解 <code>parseChildren</code> 函数，以及其他解析函数在解析模板时的工作职责和工作流程。以下面的模板为例：</p>\n<pre class=\"code-rows\"><code> const template = `&lt;div&gt;\n   &lt;p&gt;Text1&lt;/p&gt;\n   &lt;p&gt;Text2&lt;/p&gt;\n &lt;/div&gt;`\n</code></pre>\n<p>这里需要强调的是，在解析模板时，我们不能忽略空白字符。这些空白字符包括：换行符（<code>\\n</code>）、回车符（<code>\\r</code>）、空格（<code>' '</code>）、制表符（<code>\\t</code>）以及换页符（<code>\\f</code>）。如果我们用加号（<code>+</code>）代表换行符，用减号（<code>-</code>）代表空格字符。那么上面的模板可以表示为：</p>\n<pre class=\"code-rows\"><code> const template = `&lt;div&gt;+--&lt;p&gt;Text1&lt;/p&gt;+--&lt;p&gt;Text2&lt;/p&gt;+&lt;/div&gt;`\n</code></pre>\n<p>接下来，我们以这段模板作为输入来执行解析过程。</p>\n<p>解析器一开始处于 <code>DATA</code> 模式。开始执行解析后，解析器遇到的第一个字符为 <code>&lt;</code>，并且第二个字符能够匹配正则表达式 <code>/a-z/i</code>，所以解析器会进入标签节点状态，并调用 <code>parseElement</code> 函数进行解析。</p>\n<p><code>parseElement</code> 函数会做三件事：解析开始标签，解析子节点，解析结束标签。可以用下面的伪代码来表达 <code>parseElement</code> 函数所做的事情：</p>\n<pre class=\"code-rows\"><code> function parseElement() {\n   // 解析开始标签\n   const element = parseTag()\n   // 这里递归地调用 parseChildren 函数进行 &lt;div&gt; 标签子节点的解析\n   element.children = parseChildren()\n   // 解析结束标签\n   parseEndTag()\n<p>return element<br />\n}<br />\n</code></pre></p>\n<p>如果一个标签不是自闭合标签，则可以认为，一个完整的标签元素是由开始标签、子节点和结束标签这三部分构成的。因此，在 <code>parseElement</code> 函数内，我们分别调用三个解析函数来处理这三部分内容。以上述模板为例。</p>\n<ul>\n<li><p><code>parseTag</code> 解析开始标签。<code>parseTag</code> 函数用于解析开始标签，包括开始标签上的属性和指令。因此，在 <code>parseTag</code> 解析函数执行完毕后，会消费字符串中的内容 <code>&lt;div&gt;</code>，处理后的模板内容将变为：</p>\n<pre class=\"code-rows\"><code> const template = `+--&lt;p&gt;Text1&lt;/p&gt;+--&lt;p&gt;Text2&lt;/p&gt;+&lt;/div&gt;`\n</code></pre>\n</li>\n<li><p>递归地调用 <code>parseChildren</code> 函数解析子节点。<code>parseElement</code> 函数在解析开始标签时，会产生一个标签节点 <code>element</code>。在 <code>parseElement</code> 函数执行完毕后，剩下的模板内容应该作为 <code>element</code> 的子节点被解析，即 <code>element.children</code>。因此，我们要递归地调用 <code>parseChildren</code> 函数。在这个过程中，<code>parseChildren</code> 函数会消费字符串的内容：<code>+--&lt;p&gt;Text1&lt;/p&gt;+--&lt;p&gt;Text2&lt;/p&gt;+</code>。处理后的模板内容将变为：</p>\n<pre class=\"code-rows\"><code> const template = `&lt;/div&gt;`\n</code></pre>\n</li>\n<li><p><code>parseEndTag</code> 处理结束标签。可以看到，在经过 <code>parseChildren</code> 函数处理后，模板内容只剩下一个结束标签了。因此，只需要调用 <code>parseEndTag</code> 解析函数来消费它即可。</p>\n</li>\n</ul>\n<p>经过上述三个步骤的处理后，这段模板就被解析完毕了，最终得到了模板 AST。但这里值得注意的是，为了解析标签的子节点，我们递归地调用了 <code>parseChildren</code> 函数。这意味着，一个新的状态机开始运行了，我们称其为“状态机 2”。“状态机 2”所处理的模板内容为：</p>\n<pre class=\"code-rows\"><code> const template = `+--&lt;p&gt;Text1&lt;/p&gt;+--&lt;p&gt;Text2&lt;/p&gt;+`\n</code></pre>\n<p>接下来，我们继续分析“状态机 2”的状态迁移流程。在“状态机 2”开始运行时，模板的第一个字符是换行符（字符 <code>+</code> 代表换行符）。因此，解析器会进入文本节点状态，并调用 <code>parseText</code> 函数完成文本节点的解析。<code>parseText</code> 函数会将下一个 <code>&lt;</code> 字符之前的所有字符都视作文本节点的内容。换句话说，<code>parseText</code> 函数会消费模板内容 <code>+--</code>，并产生一个文本节点。在 <code>parseText</code> 解析函数执行完毕后，剩下的模板内容为：</p>\n<pre class=\"code-rows\"><code> const template = `&lt;p&gt;Text1&lt;/p&gt;+--&lt;p&gt;Text2&lt;/p&gt;+`\n</code></pre>\n<p>接着，<code>parseChildren</code> 函数继续执行。此时模板的第一个字符为 <code>&lt;</code>，并且下一个字符能够匹配正则 <code>/a-z/i</code>。于是解析器再次进入 <code>parseElement</code> 解析函数的执行阶段，这会消费模板内容 <code>&lt;p&gt;Text1&lt;/p&gt;</code>。在这一步过后，剩下的模板内容为：</p>\n<pre class=\"code-rows\"><code> const template = `+--&lt;p&gt;Text2&lt;/p&gt;+`\n</code></pre>\n<p>可以看到，此时模板的第一个字符是换行符，于是调用 <code>parseText</code> 函数消费模板内容 <code>+--</code>。现在，模板中剩下的内容是：</p>\n<pre class=\"code-rows\"><code> const template = `&lt;p&gt;Text2&lt;/p&gt;+`\n</code></pre>\n<p>解析器会再次调用 <code>parseElement</code> 函数处理标签节点。在这之后，剩下的模板内容为：</p>\n<pre class=\"code-rows\"><code> const template = `+`\n</code></pre>\n<p>可以看到，现在模板内容只剩下一个换行符了。<code>parseChildren</code> 函数会继续执行并调用 <code>parseText</code> 函数消费剩下的内容，并产生一个文本节点。最终，模板被解析完毕，“状态机 2”停止运行。</p>\n<p>在“状态机 2”运行期间，为了处理标签节点，我们又调用了两次 <code>parseElement</code> 函数。第一次调用用于处理内容 <code>&lt;p&gt;Text1&lt;/p&gt;</code>，第二次调用用于处理内容 <code>&lt;p&gt;Text2&lt;/p&gt;</code>。我们知道，<code>parseElement</code> 函数会递归地调用 <code>parseChildren</code> 函数完成子节点的解析，这就意味着解析器会再开启了两个新的状态机。</p>\n<p>通过上述例子我们能够认识到，<code>parseChildren</code> 解析函数是整个状态机的核心，状态迁移操作都在该函数内完成。在 <code>parseChildren</code> 函数运行过程中，为了处理标签节点，会调用 <code>parseElement</code> 解析函数，这会间接地调用 <code>parseChildren</code> 函数，并产生一个新的状态机。随着标签嵌套层次的增加，新的状态机会随着 <code>parseChildren</code> 函数被递归地调用而不断创建，这就是“递归下降”中“递归”二字的含义。而上级 <code>parseChildren</code> 函数的调用用于构造上级模板 AST 节点，被递归调用的下级 <code>parseChildren</code> 函数则用于构造下级模板 AST 节点。最终，会构造出一棵树型结构的模板 AST，这就是“递归下降”中“下降”二字的含义。</p>\n<h2 id=\"nav_point_155\">16.3　状态机的开启与停止</h2>\n<p>在上一节中，我们讨论了递归下降算法的含义。我们知道，<code>parseChildren</code> 函数本质上是一个状态机，它会开启一个 <code>while</code> 循环使得状态机自动运行，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function parseChildren(context, ancestors) {\n   let nodes = []\n<p>const { mode } = context<br />\n// 运行状态机<br />\nwhile(!isEnd(context, ancestors)) {<br />\n// 省略部分代码<br />\n}</p>\n<p>return nodes<br />\n}<br />\n</code></pre></p>\n<p>这里的问题在于，状态机何时停止呢？换句话说，<code>while</code> 循环应该何时停止运行呢？这涉及 <code>isEnd()</code> 函数的判断逻辑。为了搞清楚这个问题，我们需要模拟状态机的运行过程。</p>\n<p>我们知道，在调用 <code>parseElement</code> 函数解析标签节点时，会递归地调用 <code>parseChildren</code> 函数，从而开启新的状态机，如图 16-7 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00639.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 16-7　开启新的状态机</strong></p>\n<p>为了便于描述，我们可以把图 16-7 中所示的新的状态机称为“状态机 1”。“状态机 1”开始运行，继续解析模板，直到遇到下一个 <code>&lt;p&gt;</code> 标签，如图 16-8 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00640.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 16-8　递归地开启新的状态机</strong></p>\n<p>因为遇到了 <code>&lt;p&gt;</code> 标签，所以“状态机 1”也会调用 <code>parseElement</code> 函数进行解析。于是又重复了上述过程，即把当前解析的标签节点压入父级节点栈，然后递归地调用 <code>parseChildren</code> 函数开启新的状态机，即“状态机 2”。可以看到，此时有两个状态机在同时运行。</p>\n<p>此时“状态机 2”拥有程序的执行权，它持续解析模板直到遇到结束标签 <code>&lt;/p&gt;</code>。因为这是一个结束标签，并且在父级节点栈中存在与该结束标签同名的标签节点，所以“状态机 2”会停止运行，并弹出父级节点栈中处于栈顶的节点，如图 16-9 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00641.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 16-9　状态机 2 停止运行</strong></p>\n<p>此时“状态机 2”已经停止运行了，但“状态机 1”仍在运行中，于是会继续解析模板，直到遇到下一个 <code>&lt;p&gt;</code> 标签。这时“状态机 1”会再次调用 <code>parseElement</code> 函数解析标签节点，因此又会执行压栈并开启新的“状态机 3”，如图 16-10 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00642.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 16-10　开启状态机 3</strong></p>\n<p>此时“状态机 3”拥有程序的执行权，它会继续解析模板，直到遇到结束标签 <code>&lt;/p&gt;</code>。因为这是一个结束标签，并且在父级节点栈中存在与该结束标签同名的标签节点，所以“状态机 3”会停止运行，并弹出父级节点栈中处于栈顶的节点，如图 16-11 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00643.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 16-11　状态机 3 停止运行</strong></p>\n<p>当“状态机 3”停止运行后，程序的执行权交还给“状态机 1”。“状态机 1”会继续解析模板，直到遇到最后的 <code>&lt;/div&gt;</code> 结束标签。这时“状态机 1”发现父级节点栈中存在与结束标签同名的标签节点，于是将该节点弹出父级节点栈，并停止运行，如图 16-12 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00644.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 16-12　状态机 1 停止</strong></p>\n<p>这时父级节点栈为空，状态机全部停止运行，模板解析完毕。</p>\n<p>通过上面的描述，我们能够清晰地认识到，解析器会在何时开启新的状态机，以及状态机会在何时停止。结论是：当<strong>解析器遇到开始标签时，会将该标签压入父级节点栈，同时开启新的状态机。当解析器遇到结束标签，并且父级节点栈中存在与该标签同名的开始标签节点时，会停止当前正在运行的状态机</strong>。根据上述规则，我们可以给出 <code>isEnd</code> 函数的逻辑，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function isEnd(context, ancestors) {\n   // 当模板内容解析完毕后，停止\n   if (!context.source) return true\n   // 获取父级标签节点\n   const parent = ancestors[ancestors.length - 1]\n   // 如果遇到结束标签，并且该标签与父级标签节点同名，则停止\n   if (parent &amp;&amp; context.source.startsWith(`&lt;/$`)) {\n     return true\n   }\n }\n</code></pre>\n<p>上面这段代码展示了状态机的停止时机，具体如下：</p>\n<ul>\n<li>第一个停止时机是当模板内容被解析完毕时；</li>\n<li>第二个停止时机则是在遇到结束标签时，这时解析器会取得父级节点栈栈顶的节点作为父节点，检查该结束标签是否与父节点的标签同名，如果相同，则状态机停止运行。</li>\n</ul>\n<p>这里需要注意的是，在第二个停止时机中，我们直接比较结束标签的名称与栈顶节点的标签名称。这么做的确可行，但严格来讲是有瑕疵的。例如下面的模板所示：</p>\n<pre class=\"code-rows\"><code> &lt;div&gt;&lt;span&gt;&lt;/div&gt;&lt;/span&gt;\n</code></pre>\n<p>观察上述模板，它存在一个明显的问题，你能发现吗？实际上，这段模板有两种解释方式，图 16-13 给出了第一种。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00645.jpeg\" alt=\"\" width=\"35%\" style=\"width: 35%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 16-13　第一种模板解释方式</strong></p>\n<p>如图 16-13 所示，这种解释方式的流程如下。</p>\n<ul>\n<li>“状态机 1”遇到 <code>&lt;div&gt;</code> 开始标签，调用 <code>parseElement</code> 解析函数，这会开启“状态机 2”来完成子节点的解析。</li>\n<li>“状态机 2”遇到 <code>&lt;span&gt;</code> 开始标签，调用 <code>parseElement</code> 解析函数，这会开启“状态机 3”来完成子节点的解析。</li>\n<li>“状态机 3”遇到 <code>&lt;/div&gt;</code> 结束标签。由于此时父级节点栈栈顶的节点名称是 <code>span</code>，并不是 <code>div</code>，所以“状态机 3”不会停止运行。这时，“状态机 3”遭遇了不符合预期的状态，因为结束标签 <code>&lt;/div&gt;</code> 缺少与之对应的开始标签，所以这时“状态机 3”会抛出错误：“无效的结束标签”。</li>\n</ul>\n<p>上述流程的思路与我们当前的实现相符，状态机会遭遇不符合预期的状态。下面 <code>parseChildren</code> 函数的代码能够体现这一点：</p>\n<pre class=\"code-rows\"><code> function parseChildren(context, ancestors) {\n   let nodes = []\n<p>const { mode } = context</p>\n<p>while(!isEnd(context, ancestors)) {<br />\nlet node</p>\n<pre><code> if (mode === TextModes.DATA || mode === TextModes.RCDATA) {\n   if (mode === TextModes.DATA &amp;amp;&amp;amp; context.source[0] === '&amp;lt;') {\n     if (context.source[1] === '!') {\n       // 省略部分代码\n     } else if (context.source[1] === '/') {\n       // 状态机遭遇了闭合标签，此时应该抛出错误，因为它缺少与之对应的开始标签\n       console.error('无效的结束标签')\n       continue\n     } else if (/[a-z]/i.test(context.source[1])) {\n       // 省略部分代码\n     }\n   } else if (context.source.startsWith('{{')) {\n       // 省略部分代码\n   }\n }\n // 省略部分代码\n</code></pre>\n<p>}</p>\n<p>return nodes<br />\n}<br />\n</code></pre></p>\n<p>换句话说，按照我们当前的实现思路来解析上述例子中的模板，最终得到的错误信息是：“无效的结束标签”。但其实还有另外一种更好的解析方式。观察上例中给出的模板，其中存在一段完整的内容，如图 16-14 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00646.jpeg\" alt=\"\" width=\"32%\" style=\"width: 32%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 16-14　第二种模板解释方式</strong></p>\n<p>从图 16-14 中可以看到，模板中存在一段完整的内容，我们希望解析器可以正常对其进行解析，这很可能也是符合用户意图的。但实际上，无论哪一种解释方式，对程序的影响都不大。两者的区别体现在错误处理上。对于第一种解释方式，我们得到的错误信息是：“无效的结束标签”。而对于第二种解释方式，在“完整的内容”部分被解析完毕后，解析器就会打印错误信息：“<code>&lt;span&gt;</code> 标签缺少闭合标签”。很显然，第二种解释方式更加合理。</p>\n<p>为了实现第二种解释方式，我们需要调整 <code>isEnd</code> 函数的逻辑。当判断状态机是否应该停止时，我们不应该总是与栈顶的父级节点做比较，而是应该与整个父级节点栈中的所有节点做比较。只要父级节点栈中存在与当前遇到的结束标签同名的节点，就停止状态机，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function isEnd(context, ancestors) {\n   if (!context.source) return true\n<p>// 与父级节点栈内所有节点做比较<br />\nfor (let i = ancestors.length - 1; i &gt;= 0; --i) {<br />\n// 只要栈中存在与当前结束标签同名的节点，就停止状态机<br />\nif (context.source.startsWith(<code>&amp;lt;/$</code>)) {<br />\nreturn true<br />\n}<br />\n}<br />\n}<br />\n</code></pre></p>\n<p>按照新的思路再次对如下模板执行解析：</p>\n<pre class=\"code-rows\"><code> &lt;div&gt;&lt;span&gt;&lt;/div&gt;&lt;/span&gt;\n</code></pre>\n<p>其流程如下。</p>\n<ul>\n<li>“状态机 1”遇到 <code>&lt;div&gt;</code> 开始标签，调用 <code>parseElement</code> 解析函数，并开启“状态机 2”解析子节点。</li>\n<li>“状态机 2”遇到 <code>&lt;span&gt;</code> 开始标签，调用 <code>parseElement</code> 解析函数，并开启“状态机 3”解析子节点。</li>\n<li>“状态机 3”遇到 <code>&lt;/div&gt;</code> 结束标签，由于节点栈中存在名为 <code>div</code> 的标签节点，于是“状态机 3”停止了。</li>\n</ul>\n<p>在这个过程中，“状态机 2”在调用 <code>parseElement</code> 解析函数时，<code>parseElement</code> 函数能够发现 <code>&lt;span&gt;</code> 缺少闭合标签，于是会打印错误信息“<code>&lt;span&gt;</code> 标签缺少闭合标签”，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function parseElement(context, ancestors) {\n   const element = parseTag(context)\n   if (element.isSelfClosing) return element\n<p>ancestors.push(element)<br />\nelement.children = parseChildren(context, ancestors)<br />\nancestors.pop()</p>\n<p>if (context.source.startsWith(<code>&amp;lt;/$</code>)) {<br />\nparseTag(context, ‘end’)<br />\n} else {<br />\n// 缺少闭合标签<br />\nconsole.error(<code>$ 标签缺少闭合标签</code>)<br />\n}</p>\n<p>return element<br />\n}<br />\n</code></pre></p>\n<h2 id=\"nav_point_156\">16.4　解析标签节点</h2>\n<p>在上一节给出的 <code>parseElement</code> 函数的实现中，无论是解析开始标签还是闭合标签，我们都调用了 <code>parseTag</code> 函数。同时，我们使用 <code>parseChildren</code> 函数来解析开始标签与闭合标签中间的部分，如下面的代码及注释所示：</p>\n<pre class=\"code-rows\"><code> function parseElement(context, ancestors) {\n   // 调用 parseTag 函数解析开始标签\n   const element = parseTag(context)\n   if (element.isSelfClosing) return element\n<p>ancestors.push(element)<br />\nelement.children = parseChildren(context, ancestors)<br />\nancestors.pop()</p>\n<p>if (context.source.startsWith(<code>&amp;lt;/$</code>)) {<br />\n// 再次调用 parseTag 函数解析结束标签，传递了第二个参数：‘end’<br />\nparseTag(context, ‘end’)<br />\n} else {<br />\nconsole.error(<code>$ 标签缺少闭合标签</code>)<br />\n}</p>\n<p>return element<br />\n}<br />\n</code></pre></p>\n<p>标签节点的整个解析过程如图 16-15 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00647.jpeg\" alt=\"\" width=\"85%\" style=\"width: 85%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 16-15　解析标签节点的过程</strong></p>\n<p>这里需要注意的是，由于开始标签与结束标签的格式非常类似，所以我们统一使用 <code>parseTag</code> 函数处理，并通过该函数的第二个参数来指定具体的处理类型。当第二个参数值为字符串 <code>'end'</code> 时，意味着解析的是结束标签。另外，无论处理的是开始标签还是结束标签，<code>parseTag</code> 函数都会消费对应的内容。为了实现对模板内容的消费，我们需要在上下文对象中新增两个工具函数，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function parse(str) {\n   // 上下文对象\n   const context = {\n     // 模板内容\n     source: str,\n     mode: TextModes.DATA,\n     // advanceBy 函数用来消费指定数量的字符，它接收一个数字作为参数\n     advanceBy(num) {\n       // 根据给定字符数 num，截取位置 num 后的模板内容，并替换当前模板内容\n       context.source = context.source.slice(num)\n     },\n     // 无论是开始标签还是结束标签，都可能存在无用的空白字符，例如 &lt;div    &gt;\n     advanceSpaces() {\n       // 匹配空白字符\n       const match = /^[\\t\\r\\n\\f ]+/.exec(context.source)\n       if (match) {\n         // 调用 advanceBy 函数消费空白字符\n         context.advanceBy(match[0].length)\n       }\n     }\n   }\n<p>const nodes = parseChildren(context, [])</p>\n<p>return {<br />\ntype: ‘Root’,<br />\nchildren: nodes<br />\n}<br />\n}<br />\n</code></pre></p>\n<p>在上面这段代码中，我们为上下文对象增加了 <code>advanceBy</code> 函数和 <code>advanceSpaces</code> 函数。其中 <code>advanceBy</code> 函数用来消费指定数量的字符。其实现原理很简单，即调用字符串的 <code>slice</code> 函数，根据指定位置截取剩余字符串，并使用截取后的结果作为新的模板内容。<code>advanceSpaces</code> 函数则用来消费无用的空白字符，因为标签中可能存在空白字符，例如在模板 <code>&lt;div----&gt;</code> 中减号（<code>-</code>）代表空白字符。</p>\n<p>有了 <code>advanceBy</code> 和 <code>advanceSpaces</code> 函数后，我们就可以给出 <code>parseTag</code> 函数的实现了，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> // 由于 parseTag 既用来处理开始标签，也用来处理结束标签，因此我们设计第二个参数 type，\n // 用来代表当前处理的是开始标签还是结束标签，type 的默认值为 'start'，即默认作为开始标签处理\n function parseTag(context, type = 'start') {\n   // 从上下文对象中拿到 advanceBy 函数\n   const { advanceBy, advanceSpaces } = context\n<p>// 处理开始标签和结束标签的正则表达式不同<br />\nconst match = type === ‘start’<br />\n// 匹配开始标签<br />\n? /^&lt;([a-z][^\\t\\r\\n\\f /&gt;]<em>)/i.exec(context.source)<br />\n// 匹配结束标签<br />\n: /^&lt;/([a-z][^\\t\\r\\n\\f /&gt;]</em>)/i.exec(context.source)<br />\n// 匹配成功后，正则表达式的第一个捕获组的值就是标签名称<br />\nconst tag = match[1]<br />\n// 消费正则表达式匹配的全部内容，例如 ‘&lt;div’ 这段内容<br />\nadvanceBy(match[0].length)<br />\n// 消费标签中无用的空白字符<br />\nadvanceSpaces()</p>\n<p>// 在消费匹配的内容后，如果字符串以 ‘/&gt;’ 开头，则说明这是一个自闭合标签<br />\nconst isSelfClosing = context.source.startsWith(‘/&gt;’)<br />\n// 如果是自闭合标签，则消费 ‘/&gt;’， 否则消费 ‘&gt;’<br />\nadvanceBy(isSelfClosing ? 2 : 1)</p>\n<p>// 返回标签节点<br />\nreturn {<br />\ntype: ‘Element’,<br />\n// 标签名称<br />\ntag,<br />\n// 标签的属性暂时留空<br />\nprops: [],<br />\n// 子节点留空<br />\nchildren: [],<br />\n// 是否自闭合<br />\nisSelfClosing<br />\n}<br />\n}<br />\n</code></pre></p>\n<p>上面这段代码有两个关键点。</p>\n<ul>\n<li>由于 <code>parseTag</code> 函数既用于解析开始标签，又用于解析结束标签，因此需要用一个参数来标识当前处理的标签类型，即 <code>type</code>。</li>\n<li>对于开始标签和结束标签，用于匹配它们的正则表达式只有一点不同：结束标签是以字符串 <code>&lt;/</code> 开头的。图 16-16 给出了用于匹配开始标签的正则表达式的含义。</li>\n</ul>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00648.jpeg\" alt=\"\" width=\"85%\" style=\"width: 85%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 16-16　用于匹配开始标签和结束标签的正则</strong></p>\n<p>下面给出了几个使用图 16-16 所示的正则来匹配开始标签的例子。</p>\n<ul>\n<li>对于字符串 <code>'&lt;div&gt;'</code>，会匹配出字符串 <code>'&lt;div'</code>，剩余 <code>'&gt;'</code>。</li>\n<li>对于字符串 <code>'&lt;div/&gt;'</code>，会匹配出字符串 <code>'&lt;div'</code>，剩余 <code>'/&gt;'</code>。</li>\n<li>对于字符串 <code>'&lt;div----&gt;'</code>，其中减号（<code>-</code>）代表空白符，会匹配出字符串 <code>'&lt;div'</code>，剩余 <code>'----&gt;'</code>。</li>\n</ul>\n<p>另外，图 16-16 中所示的正则拥有一个捕获组，它用来捕获标签名称。</p>\n<p>除了正则表达式外，<code>parseTag</code> 函数的另外几个关键点如下。</p>\n<ul>\n<li>在完成正则匹配后，需要调用 <code>advanceBy</code> 函数消费由正则匹配的全部内容。</li>\n<li>根据上面给出的第三个正则匹配例子可知，由于标签中可能存在无用的空白字符，例如 <code>&lt;div----&gt;</code>，因此我们需要调用 <code>advanceSpaces</code> 函数消费空白字符。</li>\n<li>在消费由正则匹配的内容后，需要检查剩余模板内容是否以字符串 <code>/&gt;</code> 开头。如果是，则说明当前解析的是一个自闭合标签，这时需要将标签节点的 <code>isSelfClosing</code> 属性设置为 <code>true</code>。</li>\n<li>最后，判断标签是否自闭合。如果是，则调用 <code>advnaceBy</code> 函数消费内容 <code>/&gt;</code>，否则只需要消费内容 <code>&gt;</code> 即可。</li>\n</ul>\n<p>在经过上述处理后，<code>parseTag</code> 函数会返回一个标签节点。<code>parseElement</code> 函数在得到由 <code>parseTag</code> 函数产生的标签节点后，需要根据节点的类型完成文本模式的切换，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function parseElement(context, ancestors) {\n   const element = parseTag(context)\n   if (element.isSelfClosing) return element\n<p>// 切换到正确的文本模式<br />\nif (element.tag === ‘textarea’ || element.tag === ‘title’) {<br />\n// 如果由 parseTag 解析得到的标签是 &lt;textarea&gt; 或 &lt;title&gt;，则切换到 RCDATA 模式<br />\ncontext.mode = TextModes.RCDATA<br />\n} else if (/style|xmp|iframe|noembed|noframes|noscript/.test(element.tag)) {<br />\n// 如果由 parseTag 解析得到的标签是：<br />\n// &lt;style&gt;、&lt;xmp&gt;、&lt;iframe&gt;、&lt;noembed&gt;、&lt;noframes&gt;、&lt;noscript&gt;<br />\n// 则切换到 RAWTEXT 模式<br />\ncontext.mode = TextModes.RAWTEXT<br />\n} else {<br />\n// 否则切换到 DATA 模式<br />\ncontext.mode = TextModes.DATA<br />\n}</p>\n<p>ancestors.push(element)<br />\nelement.children = parseChildren(context, ancestors)<br />\nancestors.pop()</p>\n<p>if (context.source.startsWith(<code>&amp;lt;/$</code>)) {<br />\nparseTag(context, ‘end’)<br />\n} else {<br />\nconsole.error(<code>$ 标签缺少闭合标签</code>)<br />\n}</p>\n<p>return element<br />\n}<br />\n</code></pre></p>\n<p>至此，我们就实现了对标签节点的解析。但是目前的实现忽略了节点中的属性和指令，下一节将会讲解。</p>\n","comments":[]}