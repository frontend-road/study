{"id":438660,"title":"25 | 特征工程（下）：有哪些常用的特征处理函数？","content":"<p>你好，我是吴磊。</p><p>在上一讲，我们提到，典型的特征工程包含如下几个环节，即预处理、特征选择、归一化、离散化、Embedding和向量计算，如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/fb/8a/fb2e1de527829c503514731396edb68a.jpg?wh=1920x912\" alt=\"图片\" title=\"特征工程一览 &amp; Spark MLlib特征处理函数分类\"></p><p>在上一讲，我们着重讲解了其中的前3个环节，也就是预处理、特征选择和归一化。按照之前的课程安排，今天这一讲，咱们继续来说说剩下的离散化、Embedding与向量计算。</p><p>特征工程是机器学习的重中之重，只要你耐心学下去，必然会不虚此行。这一讲的最后，我还会对应用了6种不同特征工程的模型性能加以对比，帮你深入理解特征工程中不同环节的作用与效果。</p><h2>特征工程</h2><p><img src=\"https://static001.geekbang.org/resource/image/90/fa/901883f5abd7fbc9def60905025faffa.jpg?wh=1920x885\" alt=\"图片\" title=\"特征工程进度打卡\"></p><p>在上一讲，我们打卡到了“第三关”：归一化。因此，接下来，我们先从“第四关”：离散化说起。</p><h3>离散化：Bucketizer</h3><p>与归一化一样，离散化也是用来处理数值型字段的。离散化可以把原本连续的数值打散，从而降低原始数据的多样性（Cardinality）。举例来说，“BedroomAbvGr”字段的含义是居室数量，在train.csv这份数据样本中，“BedroomAbvGr”包含从1到8的连续整数。</p><p>现在，我们根据居室数量，把房屋粗略地划分为小户型、中户型和大户型。</p><p><img src=\"https://static001.geekbang.org/resource/image/e8/87/e85c3fabb51693c35dfa444e9bcf6687.jpg?wh=1920x824\" alt=\"图片\" title=\"BedroomAbvGr离散化\"></p><p>不难发现，“BedroomAbvGr”离散化之后，数据多样性由原来的8降低为现在的3。那么问题来了，原始的连续数据好好的，为什么要对它做离散化呢？<strong>离散化的动机，主要在于提升特征数据的区分度与内聚性，从而与预测标的产生更强的关联</strong>。</p><!-- [[[read_end]]] --><p>就拿“BedroomAbvGr”来说，我们认为一居室和两居室对于房价的影响差别不大，同样，三居室和四居室之间对于房价的影响，也是微乎其微。</p><p>但是，小户型与中户型之间，以及中户型与大户型之间，房价往往会出现跃迁的现象。换句话说，相比居室数量，户型的差异对于房价的影响更大、区分度更高。因此，把“BedroomAbvGr”做离散化处理，目的在于提升它与预测标的之间的关联性。</p><p>那么，在Spark MLlib的框架下，离散化具体该怎么做呢？与其他环节一样，Spark MLlib提供了多个离散化函数，比如Binarizer、Bucketizer和QuantileDiscretizer。我们不妨以Bucketizer为代表，结合居室数量“BedroomAbvGr”这个字段，来演示离散化的具体用法。老规矩，还是先上代码为敬。</p><pre><code class=\"language-scala\">// 原始字段\nval fieldBedroom: String = \"BedroomAbvGrInt\"\n// 包含离散化数据的目标字段\nval fieldBedroomDiscrete: String = \"BedroomDiscrete\"\n// 指定离散区间，分别是[负无穷, 2]、[3, 4]和[5, 正无穷]\nval splits: Array[Double] = Array(Double.NegativeInfinity, 3, 5, Double.PositiveInfinity)\n&nbsp;\nimport org.apache.spark.ml.feature.Bucketizer\n&nbsp;\n// 定义并初始化Bucketizer\nval bucketizer = new Bucketizer()\n// 指定原始列\n.setInputCol(fieldBedroom)\n// 指定目标列\n.setOutputCol(fieldBedroomDiscrete)\n// 指定离散区间\n.setSplits(splits)\n&nbsp;\n// 调用transform完成离散化转换\nengineeringData = bucketizer.transform(engineeringData)\n</code></pre><p>不难发现，Spark MLlib提供的特征处理函数，在用法上大同小异。首先，我们创建Bucketizer实例，然后将数值型字段BedroomAbvGrInt作为参数传入setInputCol，同时使用setOutputCol来指定用于保存离散数据的新字段BedroomDiscrete。</p><p>离散化的过程是把连续值打散为离散值，但具体的离散区间如何划分，还需要我们通过在setSplits里指定。离散区间由浮点型数组splits提供，从负无穷到正无穷划分出了[负无穷, 2]、[3, 4]和[5, 正无穷]这三个区间。最终，我们调用Bucketizer的transform函数，对engineeringData做离散化。</p><p>离散化前后的数据对比，如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/ae/3b/ae1fffddda872ed8a7byyf24f098a73b.jpg?wh=1920x967\" alt=\"图片\" title=\"离散化前后数据对比\"></p><p>好啦，到此为止，我们以Bucketizer为代表，学习了Spark MLlib框架中数据离散化的用法，轻松打通了特征工程的第四关。</p><p><img src=\"https://static001.geekbang.org/resource/image/20/75/20766bd849bb45aa55b3dd3db6f75175.jpg?wh=1920x907\" alt=\"图片\" title=\"打卡特征工程第四关：离散化\"></p><h3>Embedding</h3><p>实际上，Embedding是一个非常大的话题，随着机器学习与人工智能的发展，Embedding的方法也是日新月异、层出不穷。从最基本的热独编码到PCA降维，从Word2Vec到Item2Vec，从矩阵分解到基于深度学习的协同过滤，可谓百花齐放、百家争鸣。更有学者提出：“万物皆可Embedding”。那么问题来了，什么是Embedding呢？</p><p>Embedding是个英文术语，如果非要找一个中文翻译对照的话，我觉得“向量化”（Vectorize）最合适。Embedding的过程，就是把数据集合映射到向量空间，进而把数据进行向量化的过程。这句话听上去有些玄乎，我换个更好懂的说法，Embedding的目标，就是找到一组合适的向量，来刻画现有的数据集合。</p><p>以GarageType字段为例，它有6个取值，也就是说我们总共有6种车库类型。那么对于这6个字符串来说，我们该如何用数字化的方式来表示它们呢？毕竟，模型只能消费数值，不能直接消费字符串。</p><p><img src=\"https://static001.geekbang.org/resource/image/3d/35/3d01765800f906d5f566676d396eba35.jpg?wh=1920x769\" alt=\"图片\" title=\"GarageType的6个取值\"></p><p>一种方法是采用预处理环节的StringIndexer，把字符串转换为连续的整数，然后让模型去消费这些整数。在理论上，这么做没有任何问题。但从模型的效果出发，整数的表达方式并不合理。为什么这么说呢？</p><p>我们知道，连续整数之间，是存在比较关系的，比如1 &lt; 3，6 &gt; 5，等等。但是原始的字符串之间，比如，“Attchd”与“Detchd”并不存在大小关系，如果强行用0表示“Attchd”、用1表示“Detchd”，逻辑上就会出现“Attchd”&lt;“Detchd”的悖论。</p><p>因此，预处理环节的StringIndexer，仅仅是把字符串转换为数字，转换得到的数值是不能直接喂给模型做训练。我们需要把这些数字进一步向量化，才能交给模型去消费。那么问题来了，对于StringIndexer输出的数值，我们该怎么对他们进行向量化呢？这就要用到Embedding了。</p><p>作为入门课，咱们不妨从最简单的<strong>热独编码（One Hot Encoding）</strong>开始，去认识Embedding并掌握它的基本用法。我们先来说说，热独编码，是怎么一回事。相比照本宣科说概念，咱们不妨以GarageType为例，从示例入手，你反而更容易心领神会。</p><p><img src=\"https://static001.geekbang.org/resource/image/29/04/29099068173252b7988a8409dc5bb204.jpg?wh=1920x955\" alt=\"图片\" title=\"热独编码示例\"></p><p>首先，通过StringIndexer，我们把GarageType的6个取值分别映射为0到5的六个数值。接下来，使用热独编码，我们把每一个数值都转化为一个向量。</p><p>向量的维度为6，与原始字段（GarageType）的多样性（Cardinality）保持一致。换句话说，热独编码的向量维度，就是原始字段的取值个数。</p><p>仔细观察上图的六个向量，只有一个维度取值为1，其他维度全部为0。取值为1的维度与StringIndexer输出的索引相一致。举例来说，字符串“Attchd”被StringIndexer映射为0，对应的热独向量是[1, 0, 0, 0, 0, 0]。向量中索引为0的维度取值为1，其他维度全部取0。</p><p>不难发现，热独编码是一种简单直接的Embedding方法，甚至可以说是“简单粗暴”。不过，在日常的机器学习开发中，“简单粗暴”的热独编码却颇受欢迎。</p><p>接下来，我们还是从“房价预测”的项目出发，说一说热独编码的具体用法。</p><p>在预处理环节，我们已经用StringIndexer把非数值字段全部转换为索引字段，接下来，我们再用OneHotEncoder，把索引字段进一步转换为向量字段。</p><pre><code class=\"language-scala\">import org.apache.spark.ml.feature.OneHotEncoder\n&nbsp;\n// 非数值字段对应的目标索引字段，也即StringIndexer所需的“输出列”\n// val indexFields: Array[String] = categoricalFields.map(_ + \"Index\").toArray\n&nbsp;\n// 热独编码的目标字段，也即OneHotEncoder所需的“输出列”\nval oheFields: Array[String] = categoricalFields.map(_ + \"OHE\").toArray\n&nbsp;\n// 循环遍历所有索引字段，对其进行热独编码\nfor ((indexField, oheField) &lt;- indexFields.zip(oheFields)) {\nval oheEncoder = new OneHotEncoder()\n.setInputCol(indexField)\n.setOutputCol(oheField)\nengineeringData= oheEncoder.transform(engineeringData)\n}\n</code></pre><p>可以看到，我们循环遍历所有非数值特征，依次创建OneHotEncoder实例。在实例初始化的过程中，我们把索引字段传入给setInputCol函数，把热独编码目标字段传递给setOutputCol函数。最终通过调用OneHotEncoder的transform，在engineeringData之上完成转换。</p><p>好啦，到此为止，我们以OneHotEncoder为代表，学习了Spark MLlib框架中Embedding的用法，初步打通了特征工程的第五关。</p><p>尽管还有很多其他Embedding方法需要我们进一步探索，不过从入门的角度来说，OneHotEncoder完全可以应对大部分机器学习应用。</p><p><img src=\"https://static001.geekbang.org/resource/image/73/6f/73ab34506811e943613d93582f40646f.jpg?wh=1920x871\" alt=\"图片\" title=\"打卡特征工程第五关：Embedding\"></p><h3>向量计算</h3><p>打通第五关之后，特征工程“这套游戏”还剩下最后一道关卡：向量计算。</p><p><strong>向量计算，作为特征工程的最后一个环节，主要用于构建训练样本中的特征向量（Feature Vectors）</strong>。在Spark MLlib框架下，训练样本由两部分构成，第一部分是预测标的（Label），在“房价预测”的项目中，Label是房价。</p><p>而第二部分，就是特征向量，在形式上，特征向量可以看作是元素类型为Double的数组。根据前面的特征工程流程图，我们不难发现，特征向量的构成来源多种多样，比如原始的数值字段、归一化或是离散化之后的数值字段、以及向量化之后的特征字段，等等。</p><p>Spark MLlib在向量计算方面提供了丰富的支持，比如前面介绍过的、用于集成特征向量的VectorAssembler，用于对向量做剪裁的VectorSlicer，以元素为单位做乘法的ElementwiseProduct，等等。灵活地运用这些函数，我们可以随意地组装特征向量，从而构建模型所需的训练样本。</p><p>在前面的几个环节中（预处理、特征选择、归一化、离散化、Embedding），我们尝试对数值和非数值类型特征做各式各样的转换，目的在于探索可能对预测标的影响更大的潜在因素。</p><p>接下来，我们使用VectorAssembler将这些潜在因素全部拼接在一起、构建特征向量，从而为后续的模型训练准备好训练样本。</p><pre><code class=\"language-scala\">import org.apache.spark.ml.feature.VectorAssembler\n&nbsp;\n/**\n入选的数值特征：selectedFeatures\n归一化的数值特征：scaledFields\n离散化的数值特征：fieldBedroomDiscrete\n热独编码的非数值特征：oheFields\n*/\n&nbsp;\nval assembler = new VectorAssembler()\n.setInputCols(selectedFeatures ++ scaledFields ++ fieldBedroomDiscrete ++ oheFields)\n.setOutputCol(\"features\")\n&nbsp;\nengineeringData = assembler.transform(engineeringData)\n</code></pre><p>转换完成之后，engineeringData这个DataFrame就包含了一列名为“features”的新字段，这个字段的内容，就是每条训练样本的特征向量。接下来，我们就可以像上一讲那样，通过setFeaturesCol和setLabelCol来指定特征向量与预测标的，定义出线性回归模型。</p><pre><code class=\"language-scala\">// 定义线性回归模型\nval lr = new LinearRegression()\n.setFeaturesCol(\"features\")\n.setLabelCol(\"SalePriceInt\")\n.setMaxIter(100)\n&nbsp;\n// 训练模型\nval lrModel = lr.fit(engineeringData)\n&nbsp;\n// 获取训练状态\nval trainingSummary = lrModel.summary\n// 获取训练集之上的预测误差\nprintln(s\"Root Mean Squared Error (RMSE) on train data: ${trainingSummary.rootMeanSquaredError}\")\n</code></pre><p>好啦，到此为止，我们打通了特征工程所有关卡，恭喜你！尽管不少关卡还有待我们进一步去深入探索，但这并不影响我们从整体上把握特征工程，构建结构化的知识体系。对于没讲到的函数与技巧，你完全可以利用自己的碎片时间，借鉴这两节课我给你梳理的学习思路，来慢慢地将它们补齐，加油！</p><p><img src=\"https://static001.geekbang.org/resource/image/7c/24/7c6397186f48ce07679f3ef63c6e4524.jpg?wh=1920x824\" alt=\"图片\" title=\"通关！\"></p><h2>通关奖励：模型效果对比</h2><p>学习过VectorAssembler的用法之后，你会发现，特征工程任一环节的输出，都可以用来构建特征向量，从而用于模型训练。在介绍特征工程的部分，我们花了大量篇幅，介绍不同环节的作用与用法。</p><p>你可能会好奇：“这些不同环节的特征处理，真的会对模型效果有帮助吗？毕竟，折腾了半天，我们还是要看模型效果的”。</p><p>没错，特征工程的最终目的，是调优模型效果。接下来，通过将不同环节输出的训练样本喂给模型，我们来对比不同特征处理方法对应的模型效果。</p><p><img src=\"https://static001.geekbang.org/resource/image/80/0b/8023260593e5552ce7ea6eb1e868c30b.jpeg?wh=1920x974\" alt=\"图片\" title=\"特征工程不同环节优化过后的模型效果\"></p><p>不同环节对应的代码地址如下：</p><p>1.<a href=\"https://github.com/wulei-bj-cn/learn-spark/blob/main/chapter25/v0-baseline.scala\">调优对比基准</a><br>\n2.<a href=\"https://github.com/wulei-bj-cn/learn-spark/blob/main/chapter25/v1-numeric-features.scala\">特征工程-调优1</a><br>\n3.<a href=\"https://github.com/wulei-bj-cn/learn-spark/blob/main/chapter25/v2-selected-features.scala\">特征工程-调优2</a><br>\n4.<a href=\"https://github.com/wulei-bj-cn/learn-spark/blob/main/chapter25/v3-scaled-features.scala\">特征工程-调优3</a><br>\n5.<a href=\"https://github.com/wulei-bj-cn/learn-spark/blob/main/chapter25/v4-with-bucketized-feature.scala\">特征工程-调优4</a><br>\n6.<a href=\"https://github.com/wulei-bj-cn/learn-spark/blob/main/chapter25/v5-with-embedding.scala\">特征工程-调优5</a><br>\n7.<a href=\"https://github.com/wulei-bj-cn/learn-spark/blob/main/chapter25/v6-all-applied.scala\">特征工程-调优6</a></p><p>可以看到，随着特征工程的推进，模型在训练集上的预测误差越来越小，这说明模型的拟合能力越来越强，而这也就意味着，特征工程确实有助于模型性能的提升。</p><p>对应特征工程不同环节的训练代码，我整理到了最后的“<a href=\"https://github.com/wulei-bj-cn/learn-spark/tree/main/chapter25\">代码地址</a>”那一列。强烈建议你动手运行这些代码，对比不同环节的特征处理方法，以及对应的模型效果。</p><p>当然，我们在评估模型效果的时候，不能仅仅关注它的拟合能力，更重要的是模型的泛化能力。拟合能力强，只能说明模型在训练集上的预测误差足够小；而泛化能力，量化的是模型在测试集上的预测误差。换句话说，泛化能力的含义是，模型在一份“未曾谋面”的数据集上表现如何。</p><p>这一讲，咱们的重点是特征工程，因此暂时忽略了模型在测试集上的表现。从下一讲的模型训练开始，对于模型效果，我们将同时关注模型这两方面的能力：拟合与泛化。</p><h2>重点回顾</h2><p>好啦，今天的内容讲完啦，我们一起来做个总结。今天这一讲，我们主要围绕着特征工程中的离散化、Embedding和向量计算展开，你需要掌握其中最具代表性的特征处理函数。</p><p>到此为止，Spark MLlib特征工程中涉及的6大类特征处理函数，我们就都讲完了。为了让你对他们有一个整体上的把握，同时能够随时回顾不同环节的作用与效果，我把每一个大类的特点、以及咱们讲过的处理函数，都整理到了如下的表格中，供你参考。</p><p><img src=\"https://static001.geekbang.org/resource/image/26/1e/261971f0b0177fcd04ed2b9415d69f1e.jpg?wh=1920x1098\" alt=\"图片\"></p><p>今天的内容很多，需要我们多花时间去消化。受2/8理论的支配，在机器学习实践中，特征工程往往会花费我们80%的时间和精力。由于特征工程制约着模型效果的上限，因此，尽管特征工程的步骤繁多、过程繁琐，但是我们千万不能在这个环节偷懒，一定要认真对待。</p><p>这也是为什么我们分为上、下两部分来着重讲解特征工程，从概览到每一个环节，从每一个环节的作用到它包含的具体方法。数据质量构筑了模型效果的天花板，特征工程道阻且长，然而行则将至，让我们一起加油！</p><h2>每课一练</h2><p>结合上一讲，对于我们介绍过的所有特征处理函数，如StringIndexer、ChiSqSelector、MinMaxScaler、Bucketizer、OneHotEncoder和VectorAssembler，你能说说他们之间的区别和共同点吗？</p><p>欢迎你在留言区记录你的收获与思考，也欢迎你向更多同事、朋友分享今天的内容，说不定就能帮他解决特征工程方面的问题。</p>","comments":[{"had_liked":false,"id":320483,"user_name":"Geek_d4ccac","can_delete":false,"product_type":"c1","uid":2319416,"ip_address":"","ucode":"765580851490C3","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM4gIlRyVTOlTP8p1ucUN7Ahf2XMAicFpOHfk2UcrxEFm8GKIyCKGxd0PgBU0tMKwfPia8Ulk6rYBHVw/132","comment_is_top":false,"comment_ctime":1636349672,"is_pvip":false,"replies":[{"id":"116298","content":"好问题，其实坦白说，这样的问题，没有唯一的答案，或者说，就没有标准答案。特征工程也好，模型训练也罢，其实都是为模型效果服务的。而模型效果，其实很多时候并不取决于单一因素，往往是多种因素的叠加。咱们的入门篇，其实更多地，是给大家介绍，Spark MLlib子框架，都能提供哪些能力，允许开发者自由地选择、搭配。<br><br>回答你的问题，至于先归一化、再特征选择，还是先特征选择、再归一化，我更倾向于后者，就是先特征选择，然后再考虑归一化、离散化。当然，其实这并不绝对，很多时候，离散化与否，决定了特征本身的区分度，也许离散化之前，特征不会入选，但离散化之后，特征因为区分度的变化，可以入选。<br><br>机器学习本身，更偏向于实践科学，我们往往会有一些大面上的理论指导或者说方向，然后以效果为导向去做特征工程、模型调优。所以说，还是那句话，关于特征工程中的顺序问题，我觉得没有标准答案。咱们课程中按顺序介绍，其实仅仅是方便大家在逻辑上理解特征工程的不同环节，不同环节通常情况下确实会有先后之分，但是并不绝对，可能我在原文补充上这句话，更好一些~","user_name":"作者回复","user_name_real":"吴磊","uid":"1043100","ctime":1636470253,"ip_address":"","comment_id":320483,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18816218856","product_id":100090001,"comment_content":"老师好！我印象中如果优化用到了梯度下降（比如说linear regression）那一定要做归一化，但这一节里面最后的model里把特征选择后的top20（没归一化）都放到了特征向量里，这样不会使优化不稳定么， 实际工作中是不是还是要尽量都归一化或者离散化呢？还有一个问题就是如果归一化和离散化包含了特征选择剔除的原始特征，这样会不会引入额外的noise呢，换句话说，归一化和离散化是不是要基于特征选择之上呢？谢谢！","like_count":3,"discussions":[{"author":{"id":1043100,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/9c/230061e7.jpg","nickname":"吴磊","note":"","ucode":"136DC8CF1B10DC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530008,"discussion_content":"好问题，其实坦白说，这样的问题，没有唯一的答案，或者说，就没有标准答案。特征工程也好，模型训练也罢，其实都是为模型效果服务的。而模型效果，其实很多时候并不取决于单一因素，往往是多种因素的叠加。咱们的入门篇，其实更多地，是给大家介绍，Spark MLlib子框架，都能提供哪些能力，允许开发者自由地选择、搭配。\n\n回答你的问题，至于先归一化、再特征选择，还是先特征选择、再归一化，我更倾向于后者，就是先特征选择，然后再考虑归一化、离散化。当然，其实这并不绝对，很多时候，离散化与否，决定了特征本身的区分度，也许离散化之前，特征不会入选，但离散化之后，特征因为区分度的变化，可以入选。\n\n机器学习本身，更偏向于实践科学，我们往往会有一些大面上的理论指导或者说方向，然后以效果为导向去做特征工程、模型调优。所以说，还是那句话，关于特征工程中的顺序问题，我觉得没有标准答案。咱们课程中按顺序介绍，其实仅仅是方便大家在逻辑上理解特征工程的不同环节，不同环节通常情况下确实会有先后之分，但是并不绝对，可能我在原文补充上这句话，更好一些~","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1636470253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2319416,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM4gIlRyVTOlTP8p1ucUN7Ahf2XMAicFpOHfk2UcrxEFm8GKIyCKGxd0PgBU0tMKwfPia8Ulk6rYBHVw/132","nickname":"Geek_d4ccac","note":"","ucode":"765580851490C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413604,"discussion_content":"谢谢老师！所以其实在离散化和归一化之后还是会有特征选择这一步，这是一个循环往复的过程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636523274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320765,"user_name":"千里马","can_delete":false,"product_type":"c1","uid":2034674,"ip_address":"","ucode":"829A075C14E5CA","user_header":"https://static001.geekbang.org/account/avatar/00/1f/0b/f2/a8b0d8a6.jpg","comment_is_top":false,"comment_ctime":1636507560,"is_pvip":false,"replies":[{"id":"116375","content":"没错~ 老弟概括的极为精辟，就是这么回事！向量计算是必须的，因为模型只能消费这样的数据。而至于特征工程中的各个环节，如你提到的“特征选择”、“归一化”、“离散化”、“Embedding”，实际上都是结合实践与效果有选择地进行取舍","user_name":"作者回复","user_name_real":"吴磊","uid":"1043100","ctime":1636555517,"ip_address":"","comment_id":320765,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1636507560","product_id":100090001,"comment_content":"老师好，我想问下，中间的“特征选择”、“归一化”、“离散化”、“Embedding”是不是都可以根据实际情况选择性进行，但最后一步“向量计算”是必须进行的？","like_count":1,"discussions":[{"author":{"id":1043100,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/9c/230061e7.jpg","nickname":"吴磊","note":"","ucode":"136DC8CF1B10DC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530103,"discussion_content":"没错~ 老弟概括的极为精辟，就是这么回事！向量计算是必须的，因为模型只能消费这样的数据。而至于特征工程中的各个环节，如你提到的“特征选择”、“归一化”、“离散化”、“Embedding”，实际上都是结合实践与效果有选择地进行取舍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636555517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}