{"id":169468,"title":"加餐二｜任务调度：有了setTimeOut，为什么还要使用rAF？","content":"<p>你好，我是李兵。</p><p>我们都知道，要想利用JavaScript实现高性能的动画，那就得使用requestAnimationFrame这个API，我们简称rAF，那么为什么都推荐使用rAF而不是setTimeOut呢？</p><p>要解释清楚这个问题，就要从渲染进程的任务调度系统讲起，理解了渲染进程任务调度系统，你自然就明白了rAF和setTimeOut的区别。其次，如果你理解任务调度系统，那么你就能将渲染流水线和浏览器系统架构等知识串起来，理解了这些概念也有助于你理解Performance标签是如何工作的。</p><p>要想了解最新Chrome的任务调度系统是怎么工作的，我们得先来回顾下之前介绍的消息循环系统，我们知道了渲染进程内部的大多数任务都是在主线程上执行的，诸如JavaScript执行、DOM、CSS、计算布局、V8的垃圾回收等任务。要让这些任务能够在主线程上有条不紊地运行，就需要引入消息队列。</p><p>在前面的《<a href=\"https://time.geekbang.org/column/article/134456\">16 | WebAPI：setTimeout是如何实现的？</a>》这篇文章中，我们还介绍了，主线程维护了一个普通的消息队列和一个延迟消息队列，调度模块会按照规则依次取出这两个消息队列中的任务，并在主线程上执行。为了下文讲述方便，在这里我把普通的消息队列和延迟队列都当成一个消息队列。</p><!-- [[[read_end]]] --><p>新的任务都是被放进消息队列中去的，然后主线程再依次从消息队列中取出这些任务来顺序执行。这就是我们之前介绍的消息队列和事件循环系统。</p><h2>单消息队列的队头阻塞问题</h2><p>我们知道，渲染主线程会按照先进先出的顺序执行消息队列中的任务，具体地讲，当产生了新的任务，渲染进程会将其添加到消息队列尾部，在执行任务过程中，渲染进程会顺序地从消息队列头部取出任务并依次执行。</p><p>在最初，采用这种方式没有太大的问题，因为页面中的任务还不算太多，渲染主线程也不是太繁忙。不过浏览器是向前不停进化的，其进化路线体现在架构的调整、功能的增加以及更加精细的优化策略等方面，这些变化让渲染进程所需要处理的任务变多了，对应的渲染进程的主线程也变得越拥挤。下图所展示的仅仅是部分运行在主线程上的任务，你可以参考下：</p><p><img src=\"https://static001.geekbang.org/resource/image/fa/f4/fa9f5853a5dcad650aaaf39072820ef4.png?wh=1546*460\" alt=\"\"></p><center><span class=\"reference\">任务和消息队列</span></center><p>你可以试想一下，在基于这种单消息队列的架构下，如果用户发出一个点击事件或者缩放页面的事件，而在此时，该任务前面可能还有很多不太重要的任务在排队等待着被执行，诸如V8的垃圾回收、DOM定时器等任务，如果执行这些任务需要花费的时间过久的话，那么就会让用户产生卡顿的感觉。你可以参看下图：</p><p><img src=\"https://static001.geekbang.org/resource/image/cc/ff/cc7c32fa82207cece9c78015e4b841ff.jpg?wh=2583*651\" alt=\"\"></p><center><span class=\"reference\">队头阻塞问题</span></center><p>因此，<strong>在单消息队列架构下，存在着低优先级任务会阻塞高优先级任务的情况</strong>，比如在一些性能不高的手机上，有时候滚动页面需要等待一秒以上。这像极了我们在介绍HTTP协议时所谈论的队头阻塞问题，那么我们也把这个问题称为消息队列的队头阻塞问题吧。</p><h2>Chromium是如何解决队头阻塞问题的？</h2><p>为了解决由于单消息队列而造成的队头阻塞问题，Chromium团队从2013年到现在，花了大量的精力在持续重构底层消息机制。在接下来的篇幅里，我会按照Chromium团队的重构消息系统的思路，来带你分析下他们是如何解决掉队头阻塞问题的。</p><h4>1. 第一次迭代：引入一个高优先级队列</h4><p>首先在最理想的情况下，我们希望能够快速跟踪高优先级任务，比如在交互阶段，下面几种任务都应该视为高优先级的任务：</p><ul>\n<li>通过鼠标触发的点击任务、滚动页面任务；</li>\n<li>通过手势触发的页面缩放任务；</li>\n<li>通过CSS、JavaScript等操作触发的动画特效等任务。</li>\n</ul><p>这些任务被触发后，用户想立即得到页面的反馈，所以我们需要让这些任务能够优先与其他的任务执行。要实现这种效果，我们可以增加一个高优级的消息队列，将高优先级的任务都添加到这个队列里面，然后优先执行该消息队列中的任务。最终效果如下图所示:</p><p><img src=\"https://static001.geekbang.org/resource/image/03/c1/039fdf4c399d20a75d7dea9448cc8fc1.jpg?wh=2671*1077\" alt=\"\"></p><center><span class=\"reference\">引入高优先级的消息队列</span></center><p>观察上图，我们使用了一个优先级高的消息队列和一个优先级低消息队列，渲染进程会将它认为是紧急的任务添加到高优先级队列中，不紧急的任务就添加到低优先级的队列中。然后我们再在渲染进程中引入一个<strong>任务调度器</strong>，负责从多个消息队列中选出合适的任务，通常实现的逻辑，先按照顺序从高优先级队列中取出任务，如果高优先级的队列为空，那么再按照顺序从低优级队列中取出任务。</p><p>我们还可以更进一步，将任务划分为多个不同的优先级，来实现更加细粒度的任务调度，比如可以划分为高优先级，普通优先级和低优先级，最终效果如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/d7/78/d7c71113c6c13047fb79e7d120173b78.jpg?wh=3814*1805\" alt=\"\"></p><center><span class=\"reference\">增加多个不同优先级的消息队列</span></center><p>观察上图，我们实现了三个不同优先级的消息队列，然后可以使用任务调度器来统一调度这三个不同消息队列中的任务。</p><p>好了，现在我们引入了多个消息队列，结合任务调度器我们就可以灵活地调度任务了，这样我们就可以让高优先级的任务提前执行，采用这种方式似乎解决了消息队列的队头阻塞问题。</p><p>不过大多数任务需要保持其相对执行顺序，如果将用户输入的消息或者合成消息添加进多个不同优先级的队列中，那么这种任务的相对执行顺序就会被打乱，甚至有可能出现还未处理输入事件，就合成了该事件要显示的图片。因此我们需要让一些相同类型的任务保持其相对执行顺序。</p><h4>2.  第二次迭代：根据消息类型来实现消息队列</h4><p>要解决上述问题，我们可以为不同类型的任务创建不同优先级的消息队列，比如：</p><ul>\n<li>可以创建输入事件的消息队列，用来存放输入事件。</li>\n<li>可以创建合成任务的消息队列，用来存放合成事件。</li>\n<li>可以创建默认消息队列，用来保存如资源加载的事件和定时器回调等事件。</li>\n<li>还可以创建一个空闲消息队列，用来存放V8的垃圾自动垃圾回收这一类实时性不高的事件。</li>\n</ul><p>最终实现效果如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/56/ce/56ec510f7f7d4738e9db83dbd51f3fce.png?wh=1118*578\" alt=\"\"></p><center><span class=\"reference\">根据消息类型实现不同优先级的消息队列</span></center><p>通过迭代，这种策略已经相当实用了，但是它依然存在着问题，那就是这几种消息队列的优先级都是固定的，任务调度器会按照这种固定好的静态的优先级来分别调度任务。那么静态优先级会带来什么问题呢？</p><p>我们在《<a href=\"https://time.geekbang.org/column/article/143889\">25 | 页面性能：如何系统地优化页面？</a>》这节分析过页面的生存周期，页面大致的生存周期大体分为两个阶段，加载阶段和交互阶段。</p><p>虽然在交互阶段，采用上述这种静态优先级的策略没有什么太大问题的，但是在页面加载阶段，如果依然要优先执行用户输入事件和合成事件，那么页面的解析速度将会被拖慢。Chromium团队曾测试过这种情况，使用静态优先级策略，网页的加载速度会被拖慢14%。</p><h2>3. 第三次迭代：动态调度策略</h2><p>可以看出，我们所采用的优化策略像个跷跷板，虽然优化了高优先级任务，却拖慢低优先级任务，之所以会这样，是因为我们采取了静态的任务调度策略，对于各种不同的场景，这种静态策略就显得过于死板。</p><p>所以我们还得根据实际场景来继续平衡这个跷跷板，也就是说在不同的场景下，根据实际情况，动态调整消息队列的优先级。一图胜过千言，我们先看下图：</p><p><img src=\"https://static001.geekbang.org/resource/image/3c/f5/3cc95247daae7f90f0dced017d349af5.png?wh=1746*776\" alt=\"\"></p><center><span class=\"reference\">动态调度策略</span></center><p>这张图展示了Chromium在不同的场景下，是如何调整消息队列优先级的。通过这种动态调度策略，就可以满足不同场景的核心诉求了，同时这也是Chromium当前所采用的任务调度策略。</p><p>上图列出了三个不同的场景，分别是加载过程，合成过程以及正常状态。下面我们就结合这三种场景，来分析下Chromium为何做这种调整。</p><p>首先我们来看看<strong>页面加载阶段</strong>的场景，在这个阶段，用户的最高诉求是在尽可能短的时间内看到页面，至于交互和合成并不是这个阶段的核心诉求，因此我们需要调整策略，在加载阶段将页面解析，JavaScript脚本执行等任务调整为优先级最高的队列，降低交互合成这些队列的优先级。</p><p>页面加载完成之后就进入了<strong>交互阶段</strong>，在介绍Chromium是如何调整交互阶段的任务调度策略之前，我们还需要岔开一下，来回顾下页面的渲染过程。</p><p>在《<a href=\"https://time.geekbang.org/column/article/118826\">06 | 渲染流程（下）：HTML、CSS和JavaScript，是如何变成页面的？</a>》和《<a href=\"https://time.geekbang.org/column/article/141842\">24 | 分层和合成机制：为什么CSS动画比JavaScript高效？</a>》这两节，我们分析了一个页面是如何渲染并显示出来的。</p><p>在显卡中有一块叫着<strong>前缓冲区</strong>的地方，这里存放着显示器要显示的图像，显示器会按照一定的频率来读取这块前缓冲区，并将前缓冲区中的图像显示在显示器上，不同的显示器读取的频率是不同的，通常情况下是60HZ，也就是说显示器会每间隔1/60秒就读取一次前缓冲区。</p><p>如果浏览器要更新显示的图片，那么浏览器会将新生成的图片提交到显卡的<strong>后缓冲区</strong>中，提交完成之后，GPU会将<strong>后缓冲区和前缓冲区互换位置</strong>，也就是前缓冲区变成了后缓冲区，后缓冲区变成了前缓冲区，这就保证了显示器下次能读取到GPU中最新的图片。</p><p>这时候我们会发现，显示器从前缓冲区读取图片，和浏览器生成新的图像到后缓冲区的过程是不同步的，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/1c/38/1c3a9d8a0f56b73331041ea603ad3738.png?wh=1478*710\" alt=\"\"></p><center><span class=\"reference\">VSync时钟周期和渲染引擎生成图片不同步问题</span></center><p>这种显示器读取图片和浏览器生成图片不同步，容易造成众多问题。</p><ul>\n<li>如果渲染进程生成的帧速比屏幕的刷新率慢，那么屏幕会在两帧中显示同一个画面，当这种断断续续的情况持续发生时，用户将会很明显地察觉到动画卡住了。</li>\n<li>如果渲染进程生成的帧速率实际上比屏幕刷新率快，那么也会出现一些视觉上的问题，比如当帧速率在100fps而刷新率只有60Hz的时候，GPU所渲染的图像并非全都被显示出来，这就会造成丢帧现象。</li>\n<li>就算屏幕的刷新频率和GPU更新图片的频率一样，由于它们是两个不同的系统，所以屏幕生成帧的周期和VSync的周期也是很难同步起来的。</li>\n</ul><p>所以VSync和系统的时钟不同步就会造成掉帧、卡顿、不连贯等问题。</p><p>为了解决这些问题，就需要将显示器的时钟同步周期和浏览器生成页面的周期绑定起来，Chromium也是这样实现，那么下面我们就来看看Chromium具体是怎么实现的？</p><p><strong>当显示器将一帧画面绘制完成后，并在准备读取下一帧之前，显示器会发出一个垂直同步信号（vertical synchronization）给GPU，简称 VSync。</strong>这时候浏览器就会充分利用好VSync信号。</p><p>具体地讲，当GPU接收到VSync信号后，会将VSync信号同步给浏览器进程，浏览器进程再将其同步到对应的渲染进程，渲染进程接收到VSync信号之后，就可以准备绘制新的一帧了，具体流程你可以参考下图：</p><p><img src=\"https://static001.geekbang.org/resource/image/06/08/06206ed4846e9531351a0cb7d1db6208.png?wh=1618*776\" alt=\"\"></p><center><span class=\"reference\">绑定VSync时钟同步周期和浏览器生成页面周期</span></center><p>上面其实是非常粗略的介绍，实际实现过程也是非常复杂的，如果感兴趣，你可以参考<a href=\"https://docs.google.com/document/d/16822du6DLKDZ1vQVNWI3gDVYoSqCSezgEmWZ0arvkP8/edit\">这篇文章</a>。</p><p>好了，我们花了很大篇幅介绍了VSync和页面中的一帧是怎么显示出来，有了这些知识，我们就可以回到主线了，来分析下渲染进程是如何优化交互阶段页面的任务调度策略的？</p><p>从上图可以看出，当渲染进程接收到用户交互的任务后，接下来大概率是要进行绘制合成操作，因此我们可以设置，<strong>当在执行用户交互的任务时，将合成任务的优先级调整到最高。</strong></p><p>接下来，处理完成DOM，计算好布局和绘制，就需要将信息提交给合成线程来合成最终图片了，然后合成线程进入工作状态。现在的场景是合成线程在工作了，<strong>那么我们就可以把下个合成任务的优先级调整为最低，并将页面解析、定时器等任务优先级提升。</strong></p><p>在合成完成之后，合成线程会提交给渲染主线程提交完成合成的消息，如果当前合成操作执行的非常快，比如从用户发出消息到完成合成操作只花了8毫秒，因为VSync同步周期是16.66（1/60）毫秒，那么这个VSync时钟周期内就不需要再次生成新的页面了。那么从合成结束到下个VSync周期内，就进入了一个空闲时间阶段，那么就可以在这段空闲时间内执行一些不那么紧急的任务，比如V8的垃圾回收，或者通过window.requestIdleCallback()设置的回调任务等，都会在这段空闲时间内执行。</p><h4>4. 第四次迭代：任务饿死</h4><p>好了，以上方案看上去似乎非常完美了，不过依然存在一个问题，那就是在某个状态下，一直有新的高优先级的任务加入到队列中，这样就会导致其他低优先级的任务得不到执行，这称为任务饿死。</p><p>Chromium为了解决任务饿死的问题，给每个队列设置了执行权重，也就是如果连续执行了一定个数的高优先级的任务，那么中间会执行一次低优先级的任务，这样就缓解了任务饿死的情况。</p><h2>总结</h2><p>好了，本节的内容就介绍到这里，下面我来总结下本文的主要内容：</p><p>首先我们分析了基于单消息队列会引起队头阻塞的问题，为了解决队头阻塞问题，我们引入了多个不同优级的消息队列，并将紧急的任务添加到高优先级队列，不过大多数任务需要保持其相对执行顺序，如果将用户输入的消息或者合成消息添加进多个不同优先级的队列中，那么这种任务的相对执行顺序就会被打乱，所以我们又迭代了第二个版本。</p><p>在第二个版本中，按照不同的任务类型来划分任务优先级，不过由于采用的静态优先级策略，对于其他一些场景，这种静态调度的策略并不是太适合，所以接下来，我们又迭代了第三版。</p><p>第三个版本，基于不同的场景来动态调整消息队列的优先级，到了这里已经非常完美了，不过依然存在着任务饿死的问题，为了解决任务饿死的问题，我们给每个队列一个权重，如果连续执行了一定个数的高优先级的任务，那么中间会执行一次低优先级的任务，这样我们就完成了Chromium的任务改造。</p><p>通过整个过程的分析，我们应该能理解，在开发一个项目时，不要试图去找最完美的方案，完美的方案往往是不存在的，我们需要根据实际的场景来寻找最适合我们的方案。</p><h2>思考题</h2><p>我们知道CSS动画是由渲染进程自动处理的，所以渲染进程会让CSS渲染每帧动画的过程与VSync的时钟保持一致,这样就能保证CSS动画的高效率执行。</p><p>但是JavaScript是由用户控制的，如果采用setTimeout来触发动画每帧的绘制，那么其绘制时机是很难和VSync时钟保持一致的，所以JavaScript中又引入了window.requestAnimationFrame，用来和VSync的时钟周期同步，那么我留给你的问题是：你知道requestAnimationFrame回调函数的执行时机吗？</p><h2>参考资料</h2><p>下面是我参考的一些资料：</p><ul>\n<li><a href=\"https://chromium.googlesource.com/chromium/src/+/refs/tags/80.0.3968.1/third_party/blink/renderer/platform/scheduler/\">Blink Scheduler  </a></li>\n<li><a href=\"https://docs.google.com/presentation/d/1V09Qq08_jOucvOFs-C7P4Hz2Vsswa6imqLxAf7ONomQ/edit#slide=id.g3ef47b745_0104\">Blink Scheduler PPT</a></li>\n<li><a href=\"https://chromium.googlesource.com/chromium/src/third_party/+/master/blink/public/platform/task_type.h\">Chrome的消息类型</a></li>\n<li><a href=\"https://chromium.googlesource.com/chromium/src/base/+/refs/heads/master/task/sequence_manager/task_queue.h\">Chrome消息优先级</a></li>\n<li><a href=\"https://docs.google.com/presentation/d/1OnvR0S2s8yrn0KWAJaFEgOasrSnwR_I7JFzTB6f-G3U/htmlpresent\">无头浏览器</a></li>\n</ul><p>欢迎在留言区分享你的想法。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p><p></p>","neighbors":{"left":{"article_title":"加餐一｜浏览上下文组：如何计算Chrome中渲染进程的个数？","id":165897},"right":{"article_title":"加餐三｜加载阶段性能：使用Audits来优化Web性能","id":174254}},"comments":[{"had_liked":false,"id":156823,"user_name":"木瓜777","can_delete":false,"product_type":"c1","uid":1512537,"ip_address":"","ucode":"FC52A499AF6374","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/aFAYPyw7ywC1xE9h1qibnTBwtWn2ClJqlicy5cMomhZVaruMyqSq76wMkS279mUaGhrLGwWo9ZnW0WCWfmMovlXw/132","comment_is_top":false,"comment_ctime":1574985184,"is_pvip":false,"replies":[{"id":"60303","content":"应该说raf的回调任务会在每一帧的开始执行","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1575084142,"ip_address":"","comment_id":156823,"utype":1}],"discussion_count":2,"race_medal":0,"score":"126129036768","product_id":100033601,"comment_content":"window.requestAnimationFrame 应该是在每一帧的开始就执行吧？","like_count":30,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476242,"discussion_content":"应该说raf的回调任务会在每一帧的开始执行","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575084142,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1039904,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/de/20/03130a39.jpg","nickname":"沧海一声笑","note":"","ucode":"5297F2F4736B63","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291587,"discussion_content":"window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行\n\n也就是外面文章所说的 发生在下次UI渲染之前","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594880445,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221047,"user_name":"wens","can_delete":false,"product_type":"c1","uid":1997759,"ip_address":"","ucode":"373E4D7A02C2F1","user_header":"","comment_is_top":false,"comment_ctime":1590391215,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"48835031471","product_id":100033601,"comment_content":"react fiber的实现应该是借鉴了chromium的消息队列机制","like_count":12,"discussions":[{"author":{"id":2840430,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/57/6e/0010eec8.jpg","nickname":"月光林地","note":"","ucode":"827DFEBA385367","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536160,"discussion_content":"确切的说是借鉴了任务优先级机制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638703369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158174,"user_name":"Geek_0d3179","can_delete":false,"product_type":"c1","uid":1728349,"ip_address":"","ucode":"536FDEC6017135","user_header":"","comment_is_top":false,"comment_ctime":1575341983,"is_pvip":false,"replies":[{"id":"60602","content":"会啊，一个任务在执行的时候是不会被中断的，即使有再高优先级的任务，都需要等到当前dr任务执行结束，所以如果raf回调函数中的代码过于耗时的话，那么会影响渲染帧率！<br><br>等当前任务执行结束循环系统才会挑下个选优先级高的任务执行，因为用户输入的有限级高于raf的回调，所以会优先执行用户输入！<br><br><br>","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1575345868,"ip_address":"","comment_id":158174,"utype":1}],"discussion_count":1,"race_medal":0,"score":"48819982239","product_id":100033601,"comment_content":"如果raf的回调任务会在每一帧的开始执行，如果它执行时间很长（超过一帧），那就会阻碍后面所有任务的执行么？比如说用户的交互事件等高优先级任务也会受到影响导致卡顿么？<br>我在网上看到的资料：为啥是先执行用户的交互任务，在执行raf的回调？？？","like_count":11,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476653,"discussion_content":"会啊，一个任务在执行的时候是不会被中断的，即使有再高优先级的任务，都需要等到当前dr任务执行结束，所以如果raf回调函数中的代码过于耗时的话，那么会影响渲染帧率！\n\n等当前任务执行结束循环系统才会挑下个选优先级高的任务执行，因为用户输入的有限级高于raf的回调，所以会优先执行用户输入！\n\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575345868,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158165,"user_name":"Geek_0d3179","can_delete":false,"product_type":"c1","uid":1728349,"ip_address":"","ucode":"536FDEC6017135","user_header":"","comment_is_top":false,"comment_ctime":1575341119,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"31640112191","product_id":100033601,"comment_content":"老师您好~ 在网上搜了一大圈之后还是存在疑惑，非常希望您的解惑~十分感谢！<br>1、我了解到event loop的流程是：一个macrotask &gt;&gt; UI 渲染 &gt;&gt; 任务队列取下一个macrotask<br>疑问：每执行一个macrotask后面一定会UI 渲染吗？如果此时DOM和样式并没有改变，根本不需要重新渲染呢？也就是根本不需要回流、重绘和合成。<br>2、听了老师的讲解后，得知渲染进程在每一帧时间里都会重新绘制，合成一帧图片推到后缓冲区，就算UI没有变化也会执行吗？那这个执行的时机是？是得到VSync信号的时候吗？那这是作为一个宏任务执行的吗？<br>3、我并没有搞清楚上面1和2的关系。也就是event loop 和 一帧时间的关系。我的理解：在一帧的时间里会不断的从任务队列中取出任务执行，那如果任务队列有太多任务，“重新绘制一帧推到后缓冲区”这个操作会被延迟吗？<br>","like_count":7,"discussions":[{"author":{"id":1039904,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/de/20/03130a39.jpg","nickname":"沧海一声笑","note":"","ucode":"5297F2F4736B63","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292076,"discussion_content":"你好，我想请教下：\n\n浏览器页面没有任何变化也会以每隔16ms左右进行 UI render吗\n执行一个宏任务就会触发一次UI render吗 （UI render里面不是也会产生很多宏任务 嗯嗯...这样一想不是一个死循环吗）\n16ms的相对时间怎么计算的，我怎么知道我这个交互触发是更好在一个16ms周期进行时，还是结束时","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595074322,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1039904,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/de/20/03130a39.jpg","nickname":"沧海一声笑","note":"","ucode":"5297F2F4736B63","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291718,"discussion_content":"UI渲染不是也会产生宏任务事件吗？？？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594914944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1718831,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/3a/2f/70c1007f.jpg","nickname":"梦星魂","note":"","ucode":"062AB6E7AE5BD2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286877,"discussion_content":"会的，实际你在主线程里面写个死循环，下一帧根本得不到绘制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593315383,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179334,"user_name":"小蛋糕","can_delete":false,"product_type":"c1","uid":1807662,"ip_address":"","ucode":"335A6F4301CF22","user_header":"https://static001.geekbang.org/account/avatar/00/1b/95/2e/f8575abb.jpg","comment_is_top":false,"comment_ctime":1581981116,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27351784892","product_id":100033601,"comment_content":"老师的图其实已经给出了答案，VSync 的开始就会执行 RAF 的回调。","like_count":6},{"had_liked":false,"id":157043,"user_name":"gigot","can_delete":false,"product_type":"c1","uid":1355699,"ip_address":"","ucode":"FCAA7BCEC157CC","user_header":"https://static001.geekbang.org/account/avatar/00/14/af/b3/3486dea2.jpg","comment_is_top":false,"comment_ctime":1575017147,"is_pvip":false,"replies":[{"id":"60302","content":"不管在哪里请求setTimeout，它的回调函数都是在宏任务中执行的。<br><br>不过在微任务中产生了新的微任务，新的微任务还是在当前的微任务队列中，所以如果在微任务中不停产生新的微任务，是会阻塞页面的！","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1575081878,"ip_address":"","comment_id":157043,"utype":1}],"discussion_count":3,"race_medal":0,"score":"27344820923","product_id":100033601,"comment_content":"老师，我想问下在 primose.then 中执行宏任务（setTimeout或 ajax），其中该宏任务应该加入哪个事件队列。<br>是说微任务队列都是按顺序执行，其中每个微任务又有新的事件循环（包括宏任务和微任务），类似于新得全局环境，这样理解对吗","like_count":6,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476312,"discussion_content":"不管在哪里请求setTimeout，它的回调函数都是在宏任务中执行的。\n\n不过在微任务中产生了新的微任务，新的微任务还是在当前的微任务队列中，所以如果在微任务中不停产生新的微任务，是会阻塞页面的！","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1575081878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1560751,"avatar":"https://static001.geekbang.org/account/avatar/00/17/d0/af/c91083c3.jpg","nickname":"阿懂","note":"","ucode":"DC49DF11305C00","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":160505,"discussion_content":"宏任务的事件队列只有一个。在当前宏任务A的 promise.then 中触发宏任务B，这个宏任务B会放进全局事件队列等待执行，接下来这个 promise.then 如果没有同步产生微任务（resolve 或 reject，pending 状态的 promise 是不会在当前宏任务产生微任务的），那当前的宏任务A执行就结束了。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1580811140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1375838,"avatar":"https://static001.geekbang.org/account/avatar/00/14/fe/5e/9b723d19.jpg","nickname":"空山鸟语","note":"","ucode":"BA9993D7A4DC80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":68913,"discussion_content":"我以前也有这个疑问，不过写个demo，答案就出来了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575245442,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338853,"user_name":"一七","can_delete":false,"product_type":"c1","uid":2930028,"ip_address":"","ucode":"681C7720FAB84B","user_header":"https://static001.geekbang.org/account/avatar/00/2c/b5/6c/18c5b2ed.jpg","comment_is_top":false,"comment_ctime":1647763205,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14532665093","product_id":100033601,"comment_content":"https:&#47;&#47;www.bilibili.com&#47;video&#47;BV1K4411D7Jb?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click<br>强烈推荐大家看一下这个视频，讲事件循环的","like_count":4},{"had_liked":false,"id":301015,"user_name":"Trust_","can_delete":false,"product_type":"c1","uid":2145853,"ip_address":"","ucode":"B7E947BE7CDF69","user_header":"https://static001.geekbang.org/account/avatar/00/20/be/3d/2d2cc4fa.jpg","comment_is_top":false,"comment_ctime":1625485307,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10215419899","product_id":100033601,"comment_content":"&lt;html&gt;<br>&lt;head&gt;<br>  &lt;title&gt;Main&lt;&#47;title&gt;<br>  &lt;style&gt;<br>    .test {<br>      width: 100px;<br>      height: 100px;<br>      background-color: royalblue;<br>    }<br>  &lt;&#47;style&gt;<br>&lt;&#47;head&gt;<br>&lt;body&gt;<br>  &lt;button&gt;点击&lt;&#47;button&gt;<br>  &lt;div class=&quot;test&quot;&gt;&lt;&#47;div&gt;<br>  &lt;script&gt;<br><br>    document.querySelector(&#39;button&#39;).addEventListener(&#39;click&#39;, () =&gt; {<br>      const test = document.querySelector(&#39;.test&#39;);<br>      test.style.transform = &#39;translate(400px, 0)&#39;;<br><br>      requestAnimationFrame(() =&gt; {<br>        test.style.transition = &#39;transform 3s linear&#39;;<br>        test.style.transform = &#39;translate(200px, 0)&#39;;<br>      });<br>    });<br><br>  &lt;&#47;script&gt;<br>&lt;&#47;body&gt;<br>&lt;&#47;html&gt;<br><br><br>这段代码在Chrome执行之后，元素是从右往左移动的，说明是先绘制然后才执行的rAf<br>在火狐执行之后相反，是从右往左移动的<br><br>老师能解答一下吗","like_count":3},{"had_liked":false,"id":216085,"user_name":"暖桔灯笼","can_delete":false,"product_type":"c1","uid":1733173,"ip_address":"","ucode":"67D79C54544C03","user_header":"https://static001.geekbang.org/account/avatar/00/1a/72/35/e21d4fe8.jpg","comment_is_top":false,"comment_ctime":1589186781,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10179121373","product_id":100033601,"comment_content":"老师，在 宏任务与微任务 那一章的讲解中，下面有一个您的回答说在浏览器的实现中目前只实现了一个消息队列和一个延迟队列？这和这里第二次迭代--根据消息类型来实现消息队列 说法是不是冲突？如果确实实现了多个消息队列，会不会跟之前说的&quot;循环系统的一个循环中，先从消息队列头部取出一个任务执行，该任务执行完后，再去延迟队列中找到所有的过期任务依次执行完&quot;有冲突？我现在有点迷惑浏览器到底实现了几个几个消息队列？囧。。。","like_count":2,"discussions":[{"author":{"id":1506085,"avatar":"https://static001.geekbang.org/account/avatar/00/16/fb/25/f6743e97.jpg","nickname":"进击的前端er","note":"","ucode":"9229B410F48B85","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271414,"discussion_content":"主线程一直是依次执行一个队列中的任务，这里的多个队列和优先级，是另外一个调度系统，决定了先把哪个任务放入主线程的执行队列中","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1590133367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":191586,"user_name":"神三元","can_delete":false,"product_type":"c1","uid":1202089,"ip_address":"","ucode":"0FB2E7C0683599","user_header":"https://static001.geekbang.org/account/avatar/00/12/57/a9/9abbe7a4.jpg","comment_is_top":false,"comment_ctime":1584783302,"is_pvip":false,"discussion_count":13,"race_medal":0,"score":"10174717894","product_id":100033601,"comment_content":"讲的有问题，rAF的回调在微任务执行完成之后才会进行","like_count":2,"discussions":[{"author":{"id":2246757,"avatar":"https://static001.geekbang.org/account/avatar/00/22/48/65/3277386b.jpg","nickname":"刘至","note":"","ucode":"030D761BDF4957","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404403,"discussion_content":"如果非要比较 rAF 、微任务、宏任务的执行顺序，分析如下：\n\n1. 本次事件循环中微任务执行顺序优于 下次事件循环中的宏任务。\n2.rAF的回调发生在下次重绘前，如果页面渲染未被阻塞，浏览器一般16.7ms 发生一次重绘。然而 js 执行会阻塞页面渲染，也就是说本次事件循环中的宏任务、微任务会优于下次事件循环中的 rAF。\n3. 那么下次事件循环的宏任务 和 rAF回调的执行顺序呢，由于一次事件循环过程中未必发生页面重绘，相反一次页面重绘必定发生在一次事件循环中。\n因此，如果下一次页面重绘发生在下一次的事件循环中，rAF回调的执行顺序优于 下次事件循环的宏任务，当然也优于 下次事件循环的微任务；\n否则， 下次事件循环的宏任务优于 下次事件循环的微任务，更优于执行在下次重绘前 rAF的回调了。\n","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1634301187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2383973,"avatar":"https://static001.geekbang.org/account/avatar/00/24/60/65/0658ca66.jpg","nickname":"付伟超","note":"","ucode":"2CD9A5902B1FA8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338874,"discussion_content":"感觉讲的没错，老师讲的是以一个VSync为起始点，先执行rAF，再执行消息队列中的任务，再查询微任务消息队列执行微任务。\n\nnew Promise((resolve)=>{\n    console.log(&#39;promise&#39;)\n    resolve();\n})\nrequestAnimationFrame(()=>{\n    console.log(&#39;frame&#39;);\n\n})\nsetTimeout(()=>{\nconsole.log(&#39;timer&#39;)\n},0)","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1609407449,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1244231,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fc/47/a4be64d8.jpg","nickname":"Liber","note":"","ucode":"A5CBFDB15A7745","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2383973,"avatar":"https://static001.geekbang.org/account/avatar/00/24/60/65/0658ca66.jpg","nickname":"付伟超","note":"","ucode":"2CD9A5902B1FA8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369195,"discussion_content":"老师这是看着源码讲的，肯定是没问题的，我也看过Udacity上的老外的课程，也是说rAF的回调是在每个帧的开头执行的。\n至于这个代码为啥是先输出promise，个人分析是因为我们的代码被执行到的时候已经不是这一帧的开头的时候了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1618971441,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":338874,"ip_address":""},"score":369195,"extra":""},{"author":{"id":1373262,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f4/4e/2e804f2a.jpg","nickname":"syne✨","note":"","ucode":"F56E1BA7CF46CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1244231,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fc/47/a4be64d8.jpg","nickname":"Liber","note":"","ucode":"A5CBFDB15A7745","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389529,"discussion_content":"肯定先输出promise啊，promise同步执行，requestAnimationFrame和setTimeout异步执行，优先取requestAnimationFrame然后再执行setTimeout","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1629304326,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":369195,"ip_address":""},"score":389529,"extra":""},{"author":{"id":1822733,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/d0/0d/752ff95f.jpg","nickname":"justorez","note":"","ucode":"071D8394E62D90","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2383973,"avatar":"https://static001.geekbang.org/account/avatar/00/24/60/65/0658ca66.jpg","nickname":"付伟超","note":"","ucode":"2CD9A5902B1FA8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556596,"discussion_content":"promise executor 是同步执行的，你的这段代码根本没有微任务","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647422548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":338874,"ip_address":""},"score":556596,"extra":""}]},{"author":{"id":2644996,"avatar":"","nickname":"Geek_2a1e86","note":"","ucode":"8573861C0EF092","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538027,"discussion_content":"开始我也怀疑讲的有点问题，后来做了下实验发现讲的应该没错。raf的回调是在下一个vsync之后才开始第一个执行的。具体可以参考我写的在线代码\nhttps://jsbin.com/rimijogoyu/edit?js,output","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639304229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2246757,"avatar":"https://static001.geekbang.org/account/avatar/00/22/48/65/3277386b.jpg","nickname":"刘至","note":"","ucode":"030D761BDF4957","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404379,"discussion_content":"我看了两遍，没看见文章中有提到 rAF 和 微任务执行顺序的内容。\n另外，三元同学还是 respect 的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634296497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2644996,"avatar":"","nickname":"Geek_2a1e86","note":"","ucode":"8573861C0EF092","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380218,"discussion_content":"raf的回调在当前task中的microtask之前执行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624376827,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1377834,"avatar":"https://static001.geekbang.org/account/avatar/00/15/06/2a/3964c2a2.jpg","nickname":"天然呆","note":"","ucode":"EA738C87964EA5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260112,"discussion_content":"这个问题的关键是，这个requestAnimationFrame回调函数执行是在本轮事件循环末尾，也就是当前宏任务所属微任务队列都执行完才执行，还是下一个事件循环开始的时候执行。希望三元大神，给出相关文章说明下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588848875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1039904,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/de/20/03130a39.jpg","nickname":"沧海一声笑","note":"","ucode":"5297F2F4736B63","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1377834,"avatar":"https://static001.geekbang.org/account/avatar/00/15/06/2a/3964c2a2.jpg","nickname":"天然呆","note":"","ucode":"EA738C87964EA5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291722,"discussion_content":"他也是抄这里的 有啥好吹的","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1594917223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":260112,"ip_address":""},"score":291722,"extra":""},{"author":{"id":2395657,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erdpKbFgRLnicjRHfgBKo2N4JeuVViabFt5n3JicPR30ReORsTzhFicYicdBf6Ffr0ZwhiatsDRXbHzeojg/132","nickname":"余生","note":"","ucode":"2851EFE3FF79B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1377834,"avatar":"https://static001.geekbang.org/account/avatar/00/15/06/2a/3964c2a2.jpg","nickname":"天然呆","note":"","ucode":"EA738C87964EA5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577348,"discussion_content":"它能给出说明，就不会在这里说有问题了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656042993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":260112,"ip_address":""},"score":577348,"extra":""}]},{"author":{"id":1624489,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c9/a9/b3dcc723.jpg","nickname":"舔命难违","note":"","ucode":"F0A6F07DF6E32A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215044,"discussion_content":"搜索了下，好像是的:requestAnimationFrame姑且也算是宏任务吧，requestAnimationFrame在MDN的定义为，下次页面重绘前所执行的操作，而重绘也是作为宏任务的一个步骤来存在的，且该步骤晚于微任务的执行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585276234,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158723,"user_name":"猫叔","can_delete":false,"product_type":"c1","uid":1229411,"ip_address":"","ucode":"0B72F3DCB0E126","user_header":"https://static001.geekbang.org/account/avatar/00/12/c2/63/e91ba1c4.jpg","comment_is_top":false,"comment_ctime":1575440621,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"10165375213","product_id":100033601,"comment_content":"老师，通过window.postMessage 发送的消息执行回调也是在空闲时间内执行的吗。因为我看到react框架为了模拟兼容requestIdleCallback。使用了postMessage","like_count":2,"discussions":[{"author":{"id":1202089,"avatar":"https://static001.geekbang.org/account/avatar/00/12/57/a9/9abbe7a4.jpg","nickname":"神三元","note":"","ucode":"0FB2E7C0683599","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":160426,"discussion_content":"明明是MessageChannel\n","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1580802542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1991463,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/63/27/deefd03f.jpg","nickname":"HucerF","note":"","ucode":"68F847741F8D8D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284389,"discussion_content":"掘金三元大神居然也在","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592526577,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1202089,"avatar":"https://static001.geekbang.org/account/avatar/00/12/57/a9/9abbe7a4.jpg","nickname":"神三元","note":"","ucode":"0FB2E7C0683599","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":161991,"discussion_content":"不是这样的，这个是为了启动一个宏任务，说明UI渲染完成了，以此来计算是否还有空闲时间","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580951523,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":352695,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1658886774,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658886774","product_id":100033601,"comment_content":"让我想起了操作系统的进程调度问题","like_count":0},{"had_liked":false,"id":350316,"user_name":"Geek_aa1c31","can_delete":false,"product_type":"c1","uid":2913864,"ip_address":"","ucode":"1AC14C053638AF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/MYShyjtRtib2GIQiaK4hV3ZP9pQ1qiaS74DA4K4YHY4SIiaFDfsCKgiaMWwm9zFsSn3bt5pawp5Kdn5MWgiaw5909nug/132","comment_is_top":false,"comment_ctime":1656788145,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1656788145","product_id":100033601,"comment_content":"这里有一篇将eventloop，rAF, rIC的文章， 强烈建议可以去看一下。<br>https:&#47;&#47;developpaper.com&#47;in-depth-analysis-of-event-loop-and-browser-rendering-frame-animation-idle-callback-animation-demonstration&#47;","like_count":0},{"had_liked":false,"id":349673,"user_name":"极客雷","can_delete":false,"product_type":"c1","uid":1041465,"ip_address":"","ucode":"0DBAC4CB9C7BCD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e4/39/a06ade33.jpg","comment_is_top":false,"comment_ctime":1656216644,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1656216644","product_id":100033601,"comment_content":"headless chrome","like_count":0},{"had_liked":false,"id":339110,"user_name":"Geek_850f66","can_delete":false,"product_type":"c1","uid":1871638,"ip_address":"","ucode":"73C37394B08DB8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLfhZXC5a4ibMpVy0x7IEOicYrqEribFUDHdBc3DENR3pQicD3Bmobh7wmwcXY4xkVzjOUl5jVEiaala6w/132","comment_is_top":false,"comment_ctime":1647920847,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647920847","product_id":100033601,"comment_content":"对我前端技术影响最深远的一门课程，没有之一，非常感谢。希望老师可以出本书，一定会购买，反复阅读体会","like_count":0},{"had_liked":false,"id":336591,"user_name":"Hhpon","can_delete":false,"product_type":"c1","uid":1020726,"ip_address":"","ucode":"12FE37D4B67631","user_header":"https://static001.geekbang.org/account/avatar/00/0f/93/36/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1646230026,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646230026","product_id":100033601,"comment_content":"所以当我们代码中包含触发重排操作的时候，是不是也会等到收到sync信号的时候再去重新绘制呢。","like_count":0},{"had_liked":false,"id":332330,"user_name":"Geek_88dd24","can_delete":false,"product_type":"c1","uid":2143354,"ip_address":"","ucode":"FEDB18454C9E05","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqKk79X0JKQ5kyPQCnGN5BibI0wsOSAIp7gAhY0FlIukt7K1BJ2nibEpiciba1Rb6bk5Tl7AlhRjdBrsw/132","comment_is_top":false,"comment_ctime":1643179380,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643179380","product_id":100033601,"comment_content":"老师有个问题，如果浏览器在下一次收到vsyncA信号时，上次绘制还没完成，那么浏览器会怎么处理这个vsyncA","like_count":0},{"had_liked":false,"id":327807,"user_name":"hao-kuai","can_delete":false,"product_type":"c1","uid":1272354,"ip_address":"","ucode":"DFDFDDDBA4503C","user_header":"https://static001.geekbang.org/account/avatar/00/13/6a/22/527904b2.jpg","comment_is_top":false,"comment_ctime":1640311388,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1640311388","product_id":100033601,"comment_content":"从关键渲染路径的角度来看，rAF 回调的执行时机用来做合适修改，有助于减少回流的次数","like_count":0},{"had_liked":false,"id":316401,"user_name":"刘至","can_delete":false,"product_type":"c1","uid":2246757,"ip_address":"","ucode":"030D761BDF4957","user_header":"https://static001.geekbang.org/account/avatar/00/22/48/65/3277386b.jpg","comment_is_top":false,"comment_ctime":1634296556,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634296556","product_id":100033601,"comment_content":"浏览器渲染进程主线程任务调度<br><br>在单消息队列架构下，存在着低优先级任务会阻塞高优先级任务的情况，也就是队首阻塞问题。<br><br>为了解决此问题：<br>1. 引入优先级队列，高优先级任务队列中的任务先执行，并且为不同类型的任务创建不同优先级的消息队列。目的是为了方便调整一类任务的优先级。<br><br>2.动态调整消息队列优先级，以满足页面加载阶段、用户交互阶段、空闲阶段不同场景下的不同需求。<br><br>3. 为解决饥饿问题，给每个队列设置权重，在某个优先执行的高优先级消息队列的任务执行到一定个数，间或执行低优先级任务。<br><br>中间穿插了Vsync的知识<br>1. 显示器按照一定频率，通常是60HZ，从显卡的缓冲区读取浏览器生成的图像来呈现画面，这里使用双缓存技术解决图像闪烁问题。<br>2. 当浏览器生成图像频率和显示器读取图像不一致，会造成不连贯的问题，具体表现在浏览器生成图像频率慢则卡顿、快则丢帧。<br>3.为同步浏览器与显示器的频率，显示器会在读取下一帧图像前，发送垂直同步信号 VSync 给到 Gpu，Gpu给到 浏览器进程，浏览器进程给到渲染进程，渲染进程收到信号后着手准备新一帧图像的生成，收到信号前的空闲阶段则可以处理低优先级任务（垃圾回收，rI）。<br>4. rAF回调函数 发生在渲染进程接受到 VSync 信号之后，绘制下一帧图像（style计算，layout）之前。","like_count":0},{"had_liked":false,"id":293273,"user_name":"tokey","can_delete":false,"product_type":"c1","uid":1337746,"ip_address":"","ucode":"5278487F37D4EC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJS0jwYKhjm1hq96go05J4R7XDd5FFXXaoyIfX9TgoI3mLURAu2ET72SvYGM2iaET7IV3WDvMibAVfw/132","comment_is_top":false,"comment_ctime":1621319133,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1621319133","product_id":100033601,"comment_content":"老师您好！想请教下：<br>1、requestAnimationFrame 是宏任务么？如果不是，那它属于什么呢？<br>2、<br>setTimeout(() =&gt; {console.log(&#39;setTimeout&#39;)})<br>requestAnimationFrame(() =&gt; {console.log(&#39;requestAnimationFrame&#39;)})<br>requestIdleCallback(() =&gt; {console.log(&#39;requestIdleCallback&#39;)})<br>多次执行，他们的顺序都是不确定的，如何用“宏任务的执行”和“浏览器的渲染”结合着去解释他们的执行顺序呢？<br>","like_count":0,"discussions":[{"author":{"id":2930028,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/b5/6c/18c5b2ed.jpg","nickname":"一七","note":"","ucode":"681C7720FAB84B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557316,"discussion_content":"首先我认为requestAnimationFrame不是宏任务，肯定不会和其他宏任务放在一个消息队列中，而是会有一个单独的队列，每次在帧绘制之前，来清空这个队列。\n对于setTimeout和requestAnimationFrame，raf是在每一帧绘制之前执行，所以按照60的帧率来算的话，raf的执行频率就是每1/16ms一次，而setTimeout的话，不传第二个参数默认就是0，虽然不会真的是0，但是也肯定比1/16ms快，所以在每两次raf执行的中间，setTimeout会执行多次，这个可以在performance面板中录制一下，就可以很清楚的看到。\n而requestIdleCallback，window.requestIdleCallback()方法插入一个函数，这个函数将在浏览器空闲时期被调用，浏览器啥会空闲只有他自己知道，所以我理解他本身就不会规律的执行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647763043,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1337746,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJS0jwYKhjm1hq96go05J4R7XDd5FFXXaoyIfX9TgoI3mLURAu2ET72SvYGM2iaET7IV3WDvMibAVfw/132","nickname":"tokey","note":"","ucode":"5278487F37D4EC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2930028,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/b5/6c/18c5b2ed.jpg","nickname":"一七","note":"","ucode":"681C7720FAB84B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559193,"discussion_content":"大佬，有些理解了，还有个问题，浏览器的事件循环是先清空微任务，第二步执行浏览器的绘制，第三部清空宏任务队列。而每一帧的执行是先执行宏任务，再执行渲染，是不有点冲突","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648642879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":557316,"ip_address":""},"score":559193,"extra":""}]}]},{"had_liked":false,"id":275188,"user_name":"灵感_idea","can_delete":false,"product_type":"c1","uid":1231317,"ip_address":"","ucode":"E0DBDDFA6040F6","user_header":"https://static001.geekbang.org/account/avatar/00/12/c9/d5/b08a27ed.jpg","comment_is_top":false,"comment_ctime":1611377102,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611377102","product_id":100033601,"comment_content":"一直看课程的到现在，明显感觉到这就像是平时我们开发项目一样，初始版本总是个最小产出的东西，当遇到某种问题（或者用户，或者测试）再去在先前的版本上去做适当优化，挺好~","like_count":0},{"had_liked":false,"id":264400,"user_name":"老人与海","can_delete":false,"product_type":"c1","uid":1779570,"ip_address":"","ucode":"0FF209A906F5C1","user_header":"https://static001.geekbang.org/account/avatar/00/1b/27/72/1be6dbb0.jpg","comment_is_top":false,"comment_ctime":1606456300,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606456300","product_id":100033601,"comment_content":"李老师好，请教一个问题，为什么打开一个标签页时，有4个RenderFrameHostIMPL对象被创建。但是打开的同源标签页，却只创建3个。<br>创建的这3，4个对象，分别有什么功能呢？<br>有什么资料可以去学习吗？","like_count":0},{"had_liked":false,"id":241487,"user_name":"水鱼兄","can_delete":false,"product_type":"c1","uid":1378412,"ip_address":"","ucode":"8376480F1E12D4","user_header":"https://static001.geekbang.org/account/avatar/00/15/08/6c/789b8583.jpg","comment_is_top":false,"comment_ctime":1597307783,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597307783","product_id":100033601,"comment_content":"老师你之前说虽然标准里面定义了很多类型的消息队列，但是实现的时候只有两种，但是这里又突然多了很多的消息队列，所以哪一个才是对的？","like_count":0},{"had_liked":false,"id":239471,"user_name":"Geek_012295","can_delete":false,"product_type":"c1","uid":1687802,"ip_address":"","ucode":"41721DD2144F77","user_header":"https://static001.geekbang.org/account/avatar/00/19/c0/fa/61f78abd.jpg","comment_is_top":false,"comment_ctime":1596542635,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596542635","product_id":100033601,"comment_content":"raf保证在接收到vsync信号时开始执行，而setTimeout异步回调的执行时机却是不确定的，如果采用setTimeout则会造成fps的不稳定出现掉帧或者丢帧","like_count":0},{"had_liked":false,"id":235862,"user_name":"neohope","can_delete":false,"product_type":"c1","uid":1043475,"ip_address":"","ucode":"C0268F6E7E2B6E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","comment_is_top":false,"comment_ctime":1595227649,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1595227649","product_id":100033601,"comment_content":"0. 消息循环和消息队列（没有优先级）<br>1. 引入带优先级的队列，并引入任务调度器（采用不同队列区分优先级，优先处理高优先级队列任务）<br>2. 不同消息类型，优先级不同（不同消息类型，不同静态优先级，优先处理高优先级任务）<br>3. 不同阶段，不同消息类型，不同优先级（根据阶段，不同消息类型，动态调整优先级，优先处理该阶段高优先级任务）<br>4. 防止饥饿（动态升高饥饿任务优先级）","like_count":0},{"had_liked":false,"id":235527,"user_name":"沧海一声笑","can_delete":false,"product_type":"c1","uid":1039904,"ip_address":"","ucode":"5297F2F4736B63","user_header":"https://static001.geekbang.org/account/avatar/00/0f/de/20/03130a39.jpg","comment_is_top":false,"comment_ctime":1595074304,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595074304","product_id":100033601,"comment_content":"L老师，我想请教下：<br><br>浏览器页面没有任何变化也会以每隔16ms左右进行 UI render吗<br>执行一个宏任务就会触发一次UI render吗 （UI render里面不是也会产生很多宏任务 嗯嗯...这样一想不是一个死循环吗）<br>16ms的相对时间怎么计算的，我怎么知道我这个交互触发是更好在一个16ms周期进行时，还是结束时<br><br>上述问题困扰我很久了，请老师解答","like_count":0},{"had_liked":false,"id":226246,"user_name":"james","can_delete":false,"product_type":"c1","uid":1232771,"ip_address":"","ucode":"AC42035106E5B9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/yyibGRYCArsUNBfCAEAibua09Yb9D5AdO8TkCmXymhAepibqmlz0hzg06ggBLxyvXicnjqFVGr7zYF0rQoZ0aXCBAg/132","comment_is_top":false,"comment_ctime":1592014445,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1592014445","product_id":100033601,"comment_content":"rAF的回调会在当前宏任务中的微任务队列全部执行完成之后进行","like_count":0},{"had_liked":false,"id":179480,"user_name":"GitHubGanKai","can_delete":false,"product_type":"c1","uid":1477351,"ip_address":"","ucode":"BF6D6F8F3EED31","user_header":"https://static001.geekbang.org/account/avatar/00/16/8a/e7/a6c603cf.jpg","comment_is_top":false,"comment_ctime":1582013298,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1582013298","product_id":100033601,"comment_content":"老师你好，请问一下，为什么浏览器对ajax请求有同源策略，但是像script img这样的请求过来的资源却没有呢？还有，好像表单提交也没有同源策略～","like_count":0,"discussions":[{"author":{"id":1910075,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/25/3b/a971fc8e.jpg","nickname":"阿感","note":"","ucode":"7BCB7E44A832D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281612,"discussion_content":"我看其他课程老师给你回答了\nhttps://time.geekbang.org/course/detail/100026801-98912\n是的，这其实是实际需求决定的。因为图片、JS资源根据性能、部署灵活性等要求，必须能够分布在不同的域名下，而且不会产生太多安全性问题。\n而POST表单，处理服务器也与资源服务器往往也不在一个域名，历史原因同源策略放过了它，但这也导致CSRF复用Cookie攻击方式的存在，使得服务器必须在表单里放一些随机数，在提交的时候来验证。\n后出现的AJAX攻击方式更多，因此完全用SOP限制了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591776736,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163933,"user_name":"-_-|||","can_delete":false,"product_type":"c1","uid":1328142,"ip_address":"","ucode":"94B21594658BF9","user_header":"https://static001.geekbang.org/account/avatar/00/14/44/0e/ce14b7d3.jpg","comment_is_top":false,"comment_ctime":1576830802,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1576830802","product_id":100033601,"comment_content":"“当 GPU 接收到 VSync 信号后，会将 VSync 信号同步给浏览器进程，浏览器进程再将其同步到对应的渲染进程，渲染进程接收到 VSync 信号之后，就可以准备绘制新的一帧了”，感觉GPU就收到转发了个信号，其它什么都没干，渲染进程收到信号后开始绘“制新的一帧了“。GPU不是渲染图像的吗，为什么GPU不开始“绘制新的一帧“呢。","like_count":0},{"had_liked":false,"id":163931,"user_name":"-_-|||","can_delete":false,"product_type":"c1","uid":1328142,"ip_address":"","ucode":"94B21594658BF9","user_header":"https://static001.geekbang.org/account/avatar/00/14/44/0e/ce14b7d3.jpg","comment_is_top":false,"comment_ctime":1576830625,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1576830625","product_id":100033601,"comment_content":"“绑定 VSync 时钟同步周期和浏览器生成页面周期”这幅图中VSync之间的距离我猜测是8.33毫秒，这个信号应该是类似正余弦曲线波有正负，“VSync 同步周期是 16.66（1&#47;60）毫秒”那么最小正周期是16.66，挡在最大值时发送一个1信号给GPU，GPU将信号同步给浏览器进程。","like_count":0},{"had_liked":false,"id":163926,"user_name":"-_-|||","can_delete":false,"product_type":"c1","uid":1328142,"ip_address":"","ucode":"94B21594658BF9","user_header":"https://static001.geekbang.org/account/avatar/00/14/44/0e/ce14b7d3.jpg","comment_is_top":false,"comment_ctime":1576828908,"is_pvip":false,"discussion_count":2,"race_medal":1,"score":"1576828908","product_id":100033601,"comment_content":"&quot;.....提交完成之后，GPU 会将后缓冲区和前缓冲区互换位置，也就是前缓冲区变成了后缓冲区&quot;，前缓冲区为什么要变成后缓存区，个人感觉应该是后缓存区变成前缓冲区，然后前缓冲区被回收。前缓存区的图像应该过时了","like_count":0,"discussions":[{"author":{"id":1506085,"avatar":"https://static001.geekbang.org/account/avatar/00/16/fb/25/f6743e97.jpg","nickname":"进击的前端er","note":"","ucode":"9229B410F48B85","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271416,"discussion_content":"GPU一直是从前缓冲区取出图像，GPU感知不到这个缓冲区的存在，前后缓冲区互换类似于索引的指向来回在前后缓冲区指，GPU拿出图像信息，前缓冲区肯定就变空了啊","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1590133770,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1202089,"avatar":"https://static001.geekbang.org/account/avatar/00/12/57/a9/9abbe7a4.jpg","nickname":"神三元","note":"","ucode":"0FB2E7C0683599","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":161993,"discussion_content":"是啊，你的评论都很精彩，老师回复一下啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1580951562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155669,"user_name":"王博","can_delete":false,"product_type":"c1","uid":1374221,"ip_address":"","ucode":"B0A747BD6D0244","user_header":"https://static001.geekbang.org/account/avatar/00/14/f8/0d/0afa80d4.jpg","comment_is_top":false,"comment_ctime":1574734837,"is_pvip":false,"replies":[{"id":"59890","content":"keynote啊","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1574772550,"ip_address":"","comment_id":155669,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1574734837","product_id":100033601,"comment_content":"觉得老师的绘图工具挺好的，老师可以推荐一下吗？谢谢","like_count":0,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475824,"discussion_content":"keynote啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574772550,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1202089,"avatar":"https://static001.geekbang.org/account/avatar/00/12/57/a9/9abbe7a4.jpg","nickname":"神三元","note":"","ucode":"0FB2E7C0683599","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":161994,"discussion_content":"可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580951626,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1390549,"avatar":"https://static001.geekbang.org/account/avatar/00/15/37/d5/22299804.jpg","nickname":"大树","note":"","ucode":"0B4C9091520DFA","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62228,"discussion_content":"老师课程里讲解了 异步编程的 callback 和Promise，那么 Node的 EventEmitter模块  也可以用 消息循环系统来理解吗 ？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574825103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}