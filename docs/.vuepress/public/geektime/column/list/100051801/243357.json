{"id":243357,"title":"13 | 五花八门的算法：不要再手写for循环了","content":"<p>你好，我是Chrono。</p><p>上节课我提到了计算机界的经典公式“算法 + 数据结构 = 程序”，公式里的“数据结构”就是C++里的容器，容器我们已经学过了，今天就来学习下公式里的“算法”。</p><p>虽然算法是STL（标准库前身）的三大要件之一（容器、算法、迭代器），也是C++标准库里一个非常重要的部分，但它却没有像容器那样被大众广泛接受。</p><p>从我观察到的情况来看，很多人都会在代码里普遍应用vector、set、map，但几乎从来不用任何算法，聊起算法这个话题，也是“一问三不知”，这的确是一个比较奇怪的现象。而且，很多语言对算法也不太“上心”。</p><p>但是，在C++里，算法的地位非常高，甚至有一个专门的“算法库”。早期，它是泛型编程的示范和应用，而在C++引入lambda表达式后，它又成了函数式编程的具体实践，所以，<strong>学习掌握算法能够很好地训练你的编程思维，帮你开辟出面向对象之外的新天地</strong>。</p><h2>认识算法</h2><p>从纯理论上来说，算法就是一系列定义明确的操作步骤，并且会在有限次运算后得到结果。</p><p>计算机科学里有很多种算法，像排序算法、查找算法、遍历算法、加密算法，等等。但是在C++里，算法的含义就要狭窄很多了。</p><p>C++里的算法，指的是<strong>工作在容器上的一些泛型函数</strong>，会对容器内的元素实施的各种操作。</p><!-- [[[read_end]]] --><p>C++标准库目前提供了上百个算法，真的可以说是“五花八门”，涵盖了绝大部分的“日常工作”。比如：</p><ul>\n<li>remove，移除某个特定值；</li>\n<li>sort，快速排序；</li>\n<li>binary_search，执行二分查找；</li>\n<li>make_heap，构造一个堆结构；</li>\n<li>……</li>\n</ul><p>不过要是“说白了”，算法其实并不神秘，因为所有的算法本质上都是for或者while，通过循环遍历来逐个处理容器里的元素。</p><p>比如说count算法，它的功能非常简单，就是统计某个元素的出现次数，完全可以用range-for来实现同样的功能：</p><pre><code>vector&lt;int&gt; v = {1,3,1,7,5};    // vector容器\n\nauto n1 = std::count(          // count算法计算元素的数量 \n    begin(v), end(v), 1        // begin()、end()获取容器的范围\n);  \n\nint n2 = 0;\nfor(auto x : v) {              // 手写for循环\n    if (x == 1) {              // 判断条件，然后统计\n        n2++;\n    }\n}  \n</code></pre><p>你可能会问，既然是这样，我们直接写for循环不就好了吗，为什么还要调用算法来“多此一举”呢？</p><p>在我看来，这应该是一种“境界”，<strong>追求更高层次上的抽象和封装</strong>，也是函数式编程的基本理念。</p><p>每个算法都有一个清晰、准确的命名，不需要额外的注释，让人一眼就可以知道操作的意图，而且，算法抽象和封装了反复出现的操作逻辑，也更有利于重用代码，减少手写的错误。</p><p>还有更重要的一点：和容器一样，算法是由那些“超级程序员”创造的，它的内部实现肯定要比你随手写出来的循环更高效，而且必然经过了良好的验证测试，绝无Bug，无论是功能还是性能，都是上乘之作。</p><p>如果在以前，你不使用算法还有一个勉强可以说的理由，就是很多算法必须要传入一个函数对象，写起来很麻烦。但是现在，因为有可以“<strong>就地定义函数</strong>”的lambda表达式，算法的形式就和普通循环非常接近了，所以刚刚说的也就不再是什么问题了。</p><p>用算法加上lambda表达式，你就可以初步体验函数式编程的感觉（即函数套函数）：</p><pre><code>auto n = std::count_if(      // count_if算法计算元素的数量\n    begin(v), end(v),       // begin()、end()获取容器的范围\n    [](auto x) {            // 定义一个lambda表达式\n        return x &gt; 2;       // 判断条件\n    }\n);                          // 大函数里面套了三个小函数\n</code></pre><h2>认识迭代器</h2><p>在详细介绍算法之前，还有一个必须要了解的概念，那就是迭代器（iterator），它相当于算法的“手脚”。</p><p>虽然刚才我说算法操作容器，但实际上它看到的并不是容器，而是指向起始位置和结束位置的迭代器，算法只能通过迭代器去“<strong>间接</strong>”访问容器以及元素，算法的能力是由迭代器决定的。</p><p>这种间接的方式有什么好处呢？</p><p>这就是泛型编程的理念，与面向对象正好相反，<strong>分离了数据和操作</strong>。算法可以不关心容器的内部结构，以一致的方式去操作元素，适用范围更广，用起来也更灵活。</p><p>当然万事无绝对，这种方式也有弊端。因为算法是通用的，免不了对有的数据结构虽然可行但效率比较低。所以，对于merge、sort、unique等一些特别的算法，容器就提供了专门的替代成员函数（相当于特化），这个稍后我会再提一下。</p><p>C++里的迭代器也有很多种，比如输入迭代器、输出迭代器、双向迭代器、随机访问迭代器，等等，概念解释起来不太容易。不过，你也没有必要把它们搞得太清楚，因为常用的迭代器用法都是差不多的。你可以把它简单地理解为另一种形式的“智能指针”，只是它<strong>强调的是对数据的访问</strong>，而不是生命周期管理。</p><p>容器一般都会提供begin()、end()成员函数，调用它们就可以得到表示两个端点的迭代器，具体类型最好用auto自动推导，不要过分关心：</p><pre><code>vector&lt;int&gt; v = {1,2,3,4,5};    // vector容器\n\nauto iter1 = v.begin();        // 成员函数获取迭代器，自动类型推导\nauto iter2 = v.end();\n</code></pre><p>不过，我建议你使用更加通用的全局函数begin()、end()，虽然效果是一样的，但写起来比较方便，看起来也更清楚（另外还有cbegin()、cend()函数，返回的是常量迭代器）：</p><pre><code>auto iter3 = std::begin(v);   // 全局函数获取迭代器，自动类型推导\nauto iter4 = std::end(v);\n</code></pre><p>迭代器和指针类似，也可以前进和后退，但你不能假设它一定支持“<code>++</code>”“<code>--</code>”操作符，最好也要用函数来操作，常用的有这么几个：</p><ul>\n<li>distance()，计算两个迭代器之间的距离；</li>\n<li>advance()，前进或者后退N步；</li>\n<li>next()/prev()，计算迭代器前后的某个位置。</li>\n</ul><p>你可以参考下面的示例代码快速了解它们的作用：</p><pre><code>array&lt;int, 5&gt; arr = {0,1,2,3,4};  // array静态数组容器\n\nauto b = begin(arr);          // 全局函数获取迭代器，首端\nauto e = end(arr);            // 全局函数获取迭代器，末端\n\nassert(distance(b, e) == 5);  // 迭代器的距离\n\nauto p = next(b);              // 获取“下一个”位置\nassert(distance(b, p) == 1);    // 迭代器的距离\nassert(distance(p, b) == -1);  // 反向计算迭代器的距离\n\nadvance(p, 2);                // 迭代器前进两个位置，指向元素'3'\nassert(*p == 3);\nassert(p == prev(e, 2));     // 是末端迭代器的前两个位置\n</code></pre><h2>最有用的算法</h2><p>接下来我们就要大量使用各种函数，进入算法的函数式编程领域了。</p><h4>手写循环的替代品</h4><p>首先，我带你来认识一个最基本的算法for_each，它是手写for循环的真正替代品。</p><p>for_each在逻辑和形式上与for循环几乎完全相同：</p><pre><code>vector&lt;int&gt; v = {3,5,1,7,10};   // vector容器\n\nfor(const auto&amp; x : v) {        // range for循环\n    cout &lt;&lt; x &lt;&lt; &quot;,&quot;;\n}\n\nauto print = [](const auto&amp; x)  // 定义一个lambda表达式\n{\n    cout &lt;&lt; x &lt;&lt; &quot;,&quot;;\n};\nfor_each(cbegin(v), cend(v), print);// for_each算法\n\nfor_each(                      // for_each算法，内部定义lambda表达式\n    cbegin(v), cend(v),        // 获取常量迭代器\n    [](const auto&amp; x)          // 匿名lambda表达式\n    {\n        cout &lt;&lt; x &lt;&lt; &quot;,&quot;;\n    }\n);\n</code></pre><p>初看上去for_each算法显得有些累赘，既要指定容器的范围，又要写lambda表达式，没有range-for那么简单明了。</p><p>对于很简单的for循环来说，确实是如此，我也不建议你对这么简单的事情用for_each算法。</p><p>但更多的时候，for循环体里会做很多事情，会由if-else、break、continue等语句组成很复杂的逻辑。而单纯的for是“无意义”的，你必须去查看注释或者代码，才能知道它到底做了什么，回想一下曾经被巨大的for循环支配的“恐惧”吧。</p><p>for_each算法的价值就体现在这里，它把要做的事情分成了两部分，也就是两个函数：一个<strong>遍历容器元素</strong>，另一个<strong>操纵容器元素</strong>，而且名字的含义更明确，代码也有更好的封装。</p><p>我自己是很喜欢用for_each算法的，我也建议你尽量多用for_each来替代for，因为它能够促使我们更多地以“函数式编程”来思考，使用lambda来封装逻辑，得到更干净、更安全的代码。</p><h4>排序算法</h4><p>for_each是for的等价替代，还不能完全体现出算法的优越性。但对于“排序”这个计算机科学里的经典问题，你是绝对没有必要自己写for循环的，必须坚决地选择标准算法。</p><p>在求职面试的时候，你也许手写过不少排序算法吧，像选择排序、插入排序、冒泡排序，等等，但标准库里的算法绝对要比你所能写出的任何实现都要好。</p><p>说到排序，你脑海里跳出的第一个词可能就是sort()，它是经典的快排算法，通常用它准没错。</p><pre><code>auto print = [](const auto&amp; x)  // lambda表达式输出元素\n{\n    cout &lt;&lt; x &lt;&lt; &quot;,&quot;;\n};\n\nstd::sort(begin(v), end(v));         // 快速排序\nfor_each(cbegin(v), cend(v), print); // for_each算法\n</code></pre><p>不过，排序也有多种不同的应用场景，sort()虽然快，但它是不稳定的，而且是全排所有元素。</p><p>很多时候，这样做的成本比较高，比如TopN、中位数、最大最小值等，我们只关心一部分数据，如果你用sort()，就相当于“杀鸡用牛刀”，是一种浪费。</p><p>C++为此准备了多种不同的算法，不过它们的名字不全叫sort，所以你要认真理解它们的含义。</p><p>我来介绍一些常见问题对应的算法：</p><ul>\n<li>要求排序后仍然保持元素的相对顺序，应该用stable_sort，它是稳定的；</li>\n<li>选出前几名（TopN），应该用partial_sort；</li>\n<li>选出前几名，但不要求再排出名次（BestN），应该用nth_element；</li>\n<li>中位数（Median）、百分位数（Percentile），还是用nth_element；</li>\n<li>按照某种规则把元素划分成两组，用partition；</li>\n<li>第一名和最后一名，用minmax_element。</li>\n</ul><p>下面的代码使用vector容器示范了这些算法，注意它们“函数套函数”的形式：</p><pre><code>// top3\nstd::partial_sort(\n    begin(v), next(begin(v), 3), end(v));  // 取前3名\n\n// best3\nstd::nth_element(\n    begin(v), next(begin(v), 3), end(v));  // 最好的3个\n\n// Median\nauto mid_iter =                            // 中位数的位置\n    next(begin(v), v.size()/2);\nstd::nth_element( begin(v), mid_iter, end(v));// 排序得到中位数\ncout &lt;&lt; &quot;median is &quot; &lt;&lt; *mid_iter &lt;&lt; endl;\n    \n// partition\nauto pos = std::partition(                // 找出所有大于9的数\n    begin(v), end(v),\n    [](const auto&amp; x)                    // 定义一个lambda表达式\n    {\n        return x &gt; 9;\n    }\n); \nfor_each(begin(v), pos, print);         // 输出分组后的数据  \n\n// min/max\nauto value = std::minmax_element(        //找出第一名和倒数第一\n    cbegin(v), cend(v)\n);\n</code></pre><p>在使用这些排序算法时，还要注意一点，它们对迭代器要求比较高，通常都是随机访问迭代器（minmax_element除外），所以<strong>最好在顺序容器array/vector上调用</strong>。</p><p>如果是list容器，应该调用成员函数sort()，它对链表结构做了特别的优化。有序容器set/map本身就已经排好序了，直接对迭代器做运算就可以得到结果。而对无序容器，则不要调用排序算法，原因你应该不难想到（散列表结构的特殊性质，导致迭代器不满足要求、元素无法交换位置）。</p><h4>查找算法</h4><p>排序算法的目标是让元素有序，这样就可以快速查找，节约时间。</p><p>算法binary_search，顾名思义，就是在已经排好序的区间里执行二分查找。但糟糕的是，它只返回一个bool值，告知元素是否存在，而更多的时候，我们是想定位到那个元素，所以binary_search几乎没什么用。</p><pre><code>vector&lt;int&gt; v = {3,5,1,7,10,99,42};  // vector容器\nstd::sort(begin(v), end(v));        // 快速排序\n\nauto found = binary_search(         // 二分查找，只能确定元素在不在\n    cbegin(v), cend(v), 7\n); \n</code></pre><p>想要在已序容器上执行二分查找，要用到一个名字比较怪的算法：lower_bound，它返回第一个“<strong>大于或等于</strong>”值的位置：</p><pre><code>decltype(cend(v)) pos;            // 声明一个迭代器，使用decltype\n\npos = std::lower_bound(          // 找到第一个&gt;=7的位置\n    cbegin(v), cend(v), 7\n);  \nfound = (pos != cend(v)) &amp;&amp; (*pos == 7); // 可能找不到，所以必须要判断\nassert(found);                          // 7在容器里\n\npos = std::lower_bound(               // 找到第一个&gt;=9的位置\n    cbegin(v), cend(v), 9\n);  \nfound = (pos != cend(v)) &amp;&amp; (*pos == 9); // 可能找不到，所以必须要判断\nassert(!found);                          // 9不在容器里\n</code></pre><p>lower_bound的返回值是一个迭代器，所以就要做一点判断工作，才能知道是否真的找到了。判断的条件有两个，一个是迭代器是否有效，另一个是迭代器的值是不是要找的值。</p><p>注意lower_bound的查找条件是“<strong>大于等于</strong>”，而不是“等于”，所以它的真正含义是“大于等于值的第一个位置”。相应的也就有“大于等于值的最后一个位置”，算法叫upper_bound，返回的是第一个“<strong>大于</strong>”值的元素。</p><pre><code>pos = std::upper_bound(             // 找到第一个&gt;9的位置\n    cbegin(v), cend(v), 9\n);\n</code></pre><p>因为这两个算法不是简单的判断相等，作用有点“绕”，不太好掌握，我来给你解释一下。</p><p>它俩的返回值构成一个区间，这个区间往前就是所有比被查找值小的元素，往后就是所有比被查找值大的元素，可以写成一个简单的不等式：</p><pre><code>begin &lt;    x &lt;= lower_bound &lt; upper_bound     &lt; end\n</code></pre><p>比如，在刚才的这个例子里，对数字9执行lower_bound和upper_bound，就会返回[10,10]这样的区间。</p><p>对于有序容器set/map，就不需要调用这三个算法了，它们有等价的成员函数find/lower_bound/upper_bound，效果是一样的。</p><p>不过，你要注意find与binary_search不同，它的返回值不是bool而是迭代器，可以参考下面的示例代码：</p><pre><code>multiset&lt;int&gt; s = {3,5,1,7,7,7,10,99,42};  // multiset，允许重复\n\nauto pos = s.find(7);                      // 二分查找，返回迭代器\nassert(pos != s.end());                   // 与end()比较才能知道是否找到\n\nauto lower_pos = s.lower_bound(7);       // 获取区间的左端点\nauto upper_pos = s.upper_bound(7);       // 获取区间的右端点\n\nfor_each(                                // for_each算法\n    lower_pos, upper_pos, print          // 输出7,7,7\n);\n</code></pre><p>除了binary_search、lower_bound和upper_bound，标准库里还有一些查找算法可以用于未排序的容器，虽然肯定没有排序后的二分查找速度快，但也正因为不需要排序，所以适应范围更广。</p><p>这些算法以find和search命名，不过可能是当时制定标准时的疏忽，名称有点混乱，其中用于查找区间的find_first_of/find_end，或许更应该叫作search_first/search_last。</p><p>这几个算法调用形式都是差不多的，用起来也很简单：</p><pre><code>vector&lt;int&gt; v = {1,9,11,3,5,7};  // vector容器\n\ndecltype(v.end()) pos;          // 声明一个迭代器，使用decltype\n\npos = std::find(                 // 查找算法，找到第一个出现的位置\n    begin(v), end(v), 3\n);  \nassert(pos != end(v));         // 与end()比较才能知道是否找到\n\npos = std::find_if(            // 查找算法，用lambda判断条件\n    begin(v), end(v),\n    [](auto x) {              // 定义一个lambda表达式\n        return x % 2 == 0;    // 判断是否偶数\n    }\n);  \nassert(pos == end(v));        // 与end()比较才能知道是否找到\n\narray&lt;int, 2&gt; arr = {3,5};    // array容器\npos = std::find_first_of(      // 查找一个子区间\n    begin(v), end(v),\n    begin(arr), end(arr)\n);  \nassert(pos != end(v));       // 与end()比较才能知道是否找到\n</code></pre><h2>小结</h2><p>C++里有上百个算法，我们不可能也没办法在一节课的时间里全部搞懂，所以我就精挑细选了一些我个人认为最有用的for_each、排序和查找算法，把它们介绍给你。</p><p>在我看来，C++里的算法像是一个大宝库，非常值得你去发掘。比如类似memcpy的copy/move算法（搭配插入迭代器）、检查元素的all_of/any_of算法，用好了都可以替代很多手写for循环。</p><p>你可以课后仔细阅读<a href=\"https://en.cppreference.com/w/cpp/algorithm\">标准文档</a>，对照自己的现有代码，看看哪些能用得上，再试着用算法来改写实现，体会一下算法的简洁和高效。</p><p>简单小结一下这次的内容：</p><ol>\n<li>算法是专门操作容器的函数，是一种“智能for循环”，它的最佳搭档是lambda表达式；</li>\n<li>算法通过迭代器来间接操作容器，使用两个端点指定操作范围，迭代器决定了算法的能力；</li>\n<li>for_each算法是for的替代品，以函数式编程替代了面向过程编程；</li>\n<li>有多种排序算法，最基本的是sort，但应该根据实际情况选择其他更合适的算法，避免浪费；</li>\n<li>在已序容器上可以执行二分查找，应该使用的算法是lower_bound；</li>\n<li>list/set/map提供了等价的排序、查找函数，更适应自己的数据结构；</li>\n<li>find/search是通用的查找算法，效率不高，但不必排序也能使用。</li>\n</ol><p>和上节课一样，我再附送一个小技巧。</p><p>因为标准算法的名字实在是太普通、太常见了，所以建议你一定要显式写出“std::”名字空间限定，这样看起来更加醒目，也避免了无意的名字冲突。</p><h2>课下作业</h2><p>最后是课下作业时间，给你留两个思考题：</p><ol>\n<li>你觉得for_each算法能完全替代for循环吗？</li>\n<li>试着自己总结归纳一下，这些排序和查找算法在实际开发中应该如何使用。</li>\n</ol><p>欢迎你在留言区写下你的思考和答案，如果觉得今天的内容对你有所帮助，也欢迎分享给你的朋友。我们下节课见。</p><p><img src=\"https://static001.geekbang.org/resource/image/77/d4/77cbcdf7cf05fe7c6fac877649d627d4.jpg?wh=1900*2852\" alt=\"\"></p>","comments":[{"had_liked":false,"id":225500,"user_name":"屈肖东","can_delete":false,"product_type":"c1","uid":1995346,"ip_address":"","ucode":"A6E2250A3CFEA5","user_header":"https://static001.geekbang.org/account/avatar/00/1e/72/52/8e81daf1.jpg","comment_is_top":false,"comment_ctime":1591771021,"is_pvip":false,"replies":[{"id":"83054","content":"C++的问题就是标准更新的太迟缓了，C++11&#47;14的普及依然任重道远，好在现在很多开源库都开始要求至少C++11了，侧面上也在推进标准更新。<br>","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591777302,"ip_address":"","comment_id":225500,"utype":1}],"discussion_count":2,"race_medal":0,"score":"53131378573","product_id":100051801,"comment_content":"学习C++最蛋疼的地方之一，就是总要去确定哪些内容是C++11以及之后才具有的，哪些是C++11之前就有的，像我们公司，根本不支持C++11，C++11再牛逼也没用。只能在学习C++的时候刻意的去记C++11才有的功能，然后在开发时不去使用。这一点比C差太多了，C几乎完全不会考虑版本问题，因为最常用的C标准是C99和C89，现在系统自带的GCC基本不可能不支持。","like_count":13,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497869,"discussion_content":"C++的问题就是标准更新的太迟缓了，C++11/14的普及依然任重道远，好在现在很多开源库都开始要求至少C++11了，侧面上也在推进标准更新。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591777302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1047043,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fa/03/619e3e48.jpg","nickname":"风清扬","note":"","ucode":"651F1390B64953","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":322919,"discussion_content":"这个情况和我很像，工作了几年一直在写C，C++的话就是C++98，模板 c++11等特性完全不让使用，原因有几点1.新人多怕翻车  2.调试不方便 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604842362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223949,"user_name":"Zivon","can_delete":false,"product_type":"c1","uid":2005287,"ip_address":"","ucode":"2C7D4557C2903D","user_header":"https://static001.geekbang.org/account/avatar/00/1e/99/27/15d2c4f5.jpg","comment_is_top":false,"comment_ctime":1591239570,"is_pvip":false,"replies":[{"id":"82457","content":"可以利用lambda表达式的闭包特性，用[&amp;var]传出值。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591248682,"ip_address":"","comment_id":223949,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23066076050","product_id":100051801,"comment_content":"for_each是不是无法返回pos，在需要得到元素位置的情况不太合适？","like_count":6,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497310,"discussion_content":"可以利用lambda表达式的闭包特性，用[&amp;amp;var]传出值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591248682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223877,"user_name":"EncodedStar","can_delete":false,"product_type":"c1","uid":1504234,"ip_address":"","ucode":"03958CA7DDD6AE","user_header":"https://static001.geekbang.org/account/avatar/00/16/f3/ea/2b2adda5.jpg","comment_is_top":false,"comment_ctime":1591200740,"is_pvip":false,"replies":[{"id":"82435","content":"希望大家都能多用算法，少写for。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591231718,"ip_address":"","comment_id":223877,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18771069924","product_id":100051801,"comment_content":"这个标题成功吸引了我。","like_count":4,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497278,"discussion_content":"希望大家都能多用算法，少写for。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591231718,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223929,"user_name":"EncodedStar","can_delete":false,"product_type":"c1","uid":1504234,"ip_address":"","ucode":"03958CA7DDD6AE","user_header":"https://static001.geekbang.org/account/avatar/00/16/f3/ea/2b2adda5.jpg","comment_is_top":false,"comment_ctime":1591234554,"is_pvip":false,"replies":[{"id":"82443","content":"有时间多看看标准库文档，还有参考书，就可以少造些轮子，让自己也轻松一点。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591239508,"ip_address":"","comment_id":223929,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14476136442","product_id":100051801,"comment_content":"用c++很多年了，确实会遇到手写类似标准库的函数，手写完之后才发现标准库有同样功能高效的函数，简直让人感觉是闭门造车，哭笑不得。<br>既然老师文章都提到以后尽量用for_each，我也觉得就可以替代for，以后尽量用老师教的，还有就是小技巧很实用！","like_count":4,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497304,"discussion_content":"有时间多看看标准库文档，还有参考书，就可以少造些轮子，让自己也轻松一点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591239508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1504234,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f3/ea/2b2adda5.jpg","nickname":"EncodedStar","note":"","ucode":"03958CA7DDD6AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278837,"discussion_content":"感谢老师分享","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591240115,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223881,"user_name":"Luca","can_delete":false,"product_type":"c1","uid":1205040,"ip_address":"","ucode":"0161C4DCB9ECF4","user_header":"https://static001.geekbang.org/account/avatar/00/12/63/30/6f4b925c.jpg","comment_is_top":false,"comment_ctime":1591204623,"is_pvip":false,"replies":[{"id":"82434","content":"在lambda表达式里可以用return，这样就可以结束循环，实现类似break的效果。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591231701,"ip_address":"","comment_id":223881,"utype":1}],"discussion_count":5,"race_medal":0,"score":"14476106511","product_id":100051801,"comment_content":"回答一下第一个问题，不知是否正确：for_each循环不能完全代替for循环，比如在for循环中可以使用break跳出，而在for_each中在语法层面是没有跳出的，如果要跳出的话，可能需要借助异常机制了。<br>当然，应用for_each的函数式设计思想，也不应出现需要跳出循环的情况。<br>请老师与大家指正！","like_count":4,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497281,"discussion_content":"在lambda表达式里可以用return，这样就可以结束循环，实现类似break的效果。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591231701,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1136605,"avatar":"https://static001.geekbang.org/account/avatar/00/11/57/dd/34d829bb.jpg","nickname":"庆智","note":"","ucode":"386798503A19F5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":279801,"discussion_content":"return 可以替换continue,替换break也用return吗？","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1591418826,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281641,"discussion_content":"是我忽略了，return替换的是continue，抱歉，一时大脑short了。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1591781463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281680,"discussion_content":"luca同学说的很好，for_each算法不能实现break，这也是和for_each算法自身的特性相关，毕竟是要遍历所有的元素。\n想要break效果，可以改换其他的算法，抛异常我是不太赞成的，有点剑走偏锋了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591791143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1460660,"avatar":"","nickname":"java2c++","note":"","ucode":"C4F8C3D7B1A910","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281023,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591664076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240608,"user_name":"l c","can_delete":false,"product_type":"c1","uid":1245596,"ip_address":"","ucode":"7D43CC471595EC","user_header":"https://static001.geekbang.org/account/avatar/00/13/01/9c/1a750bc7.jpg","comment_is_top":false,"comment_ctime":1597003613,"is_pvip":false,"replies":[{"id":"88813","content":"自由的哲学思想贯彻于C++始终，真的是感觉非常好，自由不受约束。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1597020948,"ip_address":"","comment_id":240608,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10186938205","product_id":100051801,"comment_content":"是从Java&#47;Python转的c++，之前对c++其实是抱有一些成见的，大概就是难学难写，很古板很“笨重”。但是越学越发现c++是一个非常全能的语言，有一种什么都给你了随便你干什么的感觉，而且随着协议不断在更新这些工具。<br>觉得c++远没有到过时的时候，依然有它的活力啊。<br>","like_count":3,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503501,"discussion_content":"自由的哲学思想贯彻于C++始终，真的是感觉非常好，自由不受约束。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597020948,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240025,"user_name":"flying","can_delete":false,"product_type":"c1","uid":1298279,"ip_address":"","ucode":"69AB7872B36B23","user_header":"https://static001.geekbang.org/account/avatar/00/13/cf/67/057e5d93.jpg","comment_is_top":false,"comment_ctime":1596719855,"is_pvip":false,"replies":[{"id":"88639","content":"这个实际上是数据结构的问题了，比如像json，就只能是这样的多层Key-Value，如果想要简化，就要从需求、设计等更前面的地方入手，而不是纠结于C++的容器、算法。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1596761912,"ip_address":"","comment_id":240025,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10186654447","product_id":100051801,"comment_content":"老师，对于多层map有没有好的解决方案：<br>比如：<br>typedef std::map&lt;sd::string, std::map&lt;std::string, std::map&lt;string, Info&gt;&gt; Firm2Cus2CommInfo;<br>然后对这个三级map中的Info进行操作，同时还会用到第一级、第二级的key。<br>感觉用for_each不太好实现。<br>用map的原因是，方便查询，通过key就能获取到结果。<br>但是用for的话，就是好多层for，看着难受。<br><br>老师有没有好的解决方法呢？","like_count":2,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503311,"discussion_content":"这个实际上是数据结构的问题了，比如像json，就只能是这样的多层Key-Value，如果想要简化，就要从需求、设计等更前面的地方入手，而不是纠结于C++的容器、算法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596761912,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235747,"user_name":"怪兽","can_delete":false,"product_type":"c1","uid":1324007,"ip_address":"","ucode":"3342C55CB83B08","user_header":"https://static001.geekbang.org/account/avatar/00/14/33/e7/145be2f9.jpg","comment_is_top":false,"comment_ctime":1595168830,"is_pvip":false,"replies":[{"id":"87066","content":"<br>1.sort不是只读算法，这种多线程操作容器，要线程安全就必须要加锁。<br><br>2.它们都是二分查找，效率一样，但效果是不同的。find返回的是否找到，lower_bound和upper_bound返回的是上下界。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1595207743,"ip_address":"","comment_id":235747,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10185103422","product_id":100051801,"comment_content":"老师，在实践中遇到的2个问题：<br>1. 一个线程中，每间隔几秒调用sort，对vector中的元素进行排序。其他N个线程依据某种条件，从该vector容器中取出元素。对着这样的操作，vector容器作为公共资源需要上锁吗？也就是说sort是只读算法吗？<br>2. set&#47;map中的lower_bound和upper_bound成员函数，也都是二分查找法吗？它们和find成员函数的查找效率哪个更高，或者哪个更好？","like_count":3,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501818,"discussion_content":"\n1.sort不是只读算法，这种多线程操作容器，要线程安全就必须要加锁。\n\n2.它们都是二分查找，效率一样，但效果是不同的。find返回的是否找到，lower_bound和upper_bound返回的是上下界。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595207743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":281321,"user_name":"Stephen","can_delete":false,"product_type":"c1","uid":1165201,"ip_address":"","ucode":"0D49223E6CB7B1","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ7mAt63VrbLZPHpeZxSc4IlBYswQSnaAB5wGePaGFDehgiaNfIxI1SJ5yIHIlmVk8hsw0RaoaSCPA/132","comment_is_top":false,"comment_ctime":1614689766,"is_pvip":false,"replies":[{"id":"102154","content":"总结的很好，for_each算法顾名思义，就是专门为遍历容器所设计的，所以如果有一些特殊需求就不太合适了。<br><br>不过如果在for_each里用return，可以近似实现break的效果。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1614734380,"ip_address":"","comment_id":281321,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5909657062","product_id":100051801,"comment_content":"1.感觉for_each不能够完全替代for循环,就像if-else,break,continue这些for_each没法用.<br>2.根据自己的需求选择合适的算法:<br>排序中:<br>只是找出前几名的,选择partial_sort;而如果选出第一名和最后一名采用minmax_element;对于list容器,使用成员函数sort;有序容器map,set已经排好序了,直接迭代就可.<br>查找中:<br>需要先排好序的:<br>二分查找binary_search只能够告知元素是否存在;真正好用的还是lower_bound和upper_bound分别是返回该值的下界位置和上界位置(后一个位置);<br>有序的set&#47;map,提供等价的成员函数find&#47;lower_bound&#47;upper_bound.<br>不需要排序的:<br>find,search","like_count":1,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516358,"discussion_content":"总结的很好，for_each算法顾名思义，就是专门为遍历容器所设计的，所以如果有一些特殊需求就不太合适了。\n\n不过如果在for_each里用return，可以近似实现break的效果。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614734380,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1165201,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ7mAt63VrbLZPHpeZxSc4IlBYswQSnaAB5wGePaGFDehgiaNfIxI1SJ5yIHIlmVk8hsw0RaoaSCPA/132","nickname":"Stephen","note":"","ucode":"0D49223E6CB7B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352730,"discussion_content":"老师我看前面您更正为“return替换的是continue”，怎么又改回来了呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614831372,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347165,"user_name":"KevinJ","can_delete":false,"product_type":"c1","uid":2941881,"ip_address":"","ucode":"74A9D474A94C9E","user_header":"https://static001.geekbang.org/account/avatar/00/2c/e3/b9/9a934f5c.jpg","comment_is_top":false,"comment_ctime":1653771097,"is_pvip":true,"replies":[{"id":"126686","content":"最新的C++编译器能省很多事情。","user_name":"作者回复","user_name_real":"编辑","uid":"1181974","ctime":1654085969,"ip_address":"","comment_id":347165,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1653771097","product_id":100051801,"comment_content":"C++17 允许并行策略 但是gcc9下需要引进intel TBB。也可以使用gnu自带的并行算法库拓展 但是必须开启fopenmp。但是在gcc11下就不用了 直接开启C++20标准然后include execution就好。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574492,"discussion_content":"最新的C++编译器能省很多事情。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654085969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":317291,"user_name":"于小咸","can_delete":false,"product_type":"c1","uid":1640946,"ip_address":"","ucode":"833D5E92016430","user_header":"https://static001.geekbang.org/account/avatar/00/19/09/f2/6ed195f4.jpg","comment_is_top":false,"comment_ctime":1634733421,"is_pvip":false,"replies":[{"id":"115036","content":"good，等入门了之后可以再看看C++17&#47;20里的range算法，更有意思。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1634806458,"ip_address":"","comment_id":317291,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1634733421","product_id":100051801,"comment_content":"老师给我打开了新世界的大门，C++的算法用得还是比较少，以后工作中要多尝试用起来","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528750,"discussion_content":"good，等入门了之后可以再看看C++17/20里的range算法，更有意思。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634806458,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284288,"user_name":"出卖灵魂的教练Kerry","can_delete":false,"product_type":"c1","uid":1807943,"ip_address":"","ucode":"8C64517DA556FE","user_header":"https://static001.geekbang.org/account/avatar/00/1b/96/47/93838ff7.jpg","comment_is_top":false,"comment_ctime":1616150689,"is_pvip":true,"replies":[{"id":"103134","content":"这样的面试题太绕人了，说实话我也不能给出最佳解法，抱歉。<br><br>但文件映射应该不是考点，要点在于利用1G的内存存hash，可以搜一下，看看解题思路。<br>","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1616211283,"ip_address":"","comment_id":284288,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1616150689","product_id":100051801,"comment_content":"老师你好，问你一个最近面试遇到的问题，希望可以解答。一个100G的URL文件，如何哈希分为1000个小文件呢？内存不超过1G。是否可以用文件映射，依次读是否效率太低了？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517299,"discussion_content":"这样的面试题太绕人了，说实话我也不能给出最佳解法，抱歉。\n\n但文件映射应该不是考点，要点在于利用1G的内存存hash，可以搜一下，看看解题思路。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616211283,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":282615,"user_name":"巴菲特不非","can_delete":false,"product_type":"c1","uid":2440496,"ip_address":"","ucode":"9E2B911ED5BF08","user_header":"https://static001.geekbang.org/account/avatar/00/25/3d/30/9e5e5d4d.jpg","comment_is_top":false,"comment_ctime":1615341106,"is_pvip":false,"replies":[{"id":"102600","content":"我觉得没说错，可能是表述上容易造成误解，抱歉了。<br><br>后面说的是“大于等于值的最后一个位置”，强调的是位置，而upper_bound返回的是第一个“大于”值的元素，是在这个位置之后。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1615346340,"ip_address":"","comment_id":282615,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1615341106","product_id":100051801,"comment_content":" “lower_bound 的查找条件是“大于等于”，而不是“等于”，所以它的真正含义是“大于等于值的第一个位置”。相应的也就有“大于等于值的最后一个位置”，算法叫 upper_bound，返回的是第一个“大于”值的元素。”<br>这里下半部分有矛盾吧，upper_bound应该是“大于值的第一个位置”。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516790,"discussion_content":"我觉得没说错，可能是表述上容易造成误解，抱歉了。\n\n后面说的是“大于等于值的最后一个位置”，强调的是位置，而upper_bound返回的是第一个“大于”值的元素，是在这个位置之后。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615346340,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":278699,"user_name":"Stephen","can_delete":false,"product_type":"c1","uid":1165201,"ip_address":"","ucode":"0D49223E6CB7B1","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ7mAt63VrbLZPHpeZxSc4IlBYswQSnaAB5wGePaGFDehgiaNfIxI1SJ5yIHIlmVk8hsw0RaoaSCPA/132","comment_is_top":false,"comment_ctime":1613209673,"is_pvip":false,"replies":[{"id":"101341","content":"这个属于个人的喜好了，我觉得全局函数begin()、end()的含义更通用一些，没有“隶属于”具体容器的含义。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1613390836,"ip_address":"","comment_id":278699,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1613209673","product_id":100051801,"comment_content":"“不过，我建议你使用更加通用的全局函数 begin()、end()，虽然效果是一样的，但写起来比较方便，看起来也更清楚”。从代码长度上来看，老师我感觉全局函数写的更多啊。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515473,"discussion_content":"这个属于个人的喜好了，我觉得全局函数begin()、end()的含义更通用一些，没有“隶属于”具体容器的含义。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613390836,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1165201,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ7mAt63VrbLZPHpeZxSc4IlBYswQSnaAB5wGePaGFDehgiaNfIxI1SJ5yIHIlmVk8hsw0RaoaSCPA/132","nickname":"Stephen","note":"","ucode":"0D49223E6CB7B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349676,"discussion_content":"嗯嗯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613449174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":260673,"user_name":"出卖灵魂的教练Kerry","can_delete":false,"product_type":"c1","uid":1807943,"ip_address":"","ucode":"8C64517DA556FE","user_header":"https://static001.geekbang.org/account/avatar/00/1b/96/47/93838ff7.jpg","comment_is_top":false,"comment_ctime":1605081338,"is_pvip":true,"replies":[{"id":"94719","content":"是的，可能是因为标准库出来的比较晚，里面的东西比较杂，而C++自造轮子的传统又太强大。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1605143404,"ip_address":"","comment_id":260673,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605081338","product_id":100051801,"comment_content":"自我感觉c++标准库普及的不够。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509259,"discussion_content":"是的，可能是因为标准库出来的比较晚，里面的东西比较杂，而C++自造轮子的传统又太强大。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605143404,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245468,"user_name":"宇天飞","can_delete":false,"product_type":"c1","uid":1126444,"ip_address":"","ucode":"3FB37D1E2DAA61","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/2c/06375913.jpg","comment_is_top":false,"comment_ctime":1598950780,"is_pvip":true,"replies":[{"id":"90275","content":"keep studying","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1598951430,"ip_address":"","comment_id":245468,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1598950780","product_id":100051801,"comment_content":"你觉得 for_each 算法能完全替代 for 循环吗？<br>1、可以<br>如果要计数的话，for会更方便，i++<br><br>试着自己总结归纳一下，这些排序和查找算法在实际开发中应该如何使用。<br>1、业务需要的数据是否有顺序要求，选用对用的数据结构<br>2、场景：最热门的10个影片，成绩最好，满足什么条件的用户","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504889,"discussion_content":"keep studying","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598951430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":238416,"user_name":"andi轩","can_delete":false,"product_type":"c1","uid":1214649,"ip_address":"","ucode":"3AE241BE60A3E0","user_header":"https://static001.geekbang.org/account/avatar/00/12/88/b9/af5db174.jpg","comment_is_top":false,"comment_ctime":1596163067,"is_pvip":false,"replies":[{"id":"88076","content":"这个是相当于binary_search的精确查找，所以要比较迭代器是否是要找的值（7）。<br><br>如果你想找别的，就可以改判断。而且lower_bound的查找结果必然是&gt;=，所以你改的第二个比较没有意义。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1596163886,"ip_address":"","comment_id":238416,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1596163067","product_id":100051801,"comment_content":"老师，lower_bound示例里:<br>found = (pos != cend(v)) &amp;&amp; (*pos == 7); &#47;&#47; 可能找不到，所以必须要判断<br>应该是<br>found = (pos != cend(v)) &amp;&amp; (*pos &gt;= 7); &#47;&#47; 可能找不到，所以必须要判断<br>对吧？<br>因为是要找第一个&gt;=7的位置，有可能没有7，找到个8也是对的","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502743,"discussion_content":"这个是相当于binary_search的精确查找，所以要比较迭代器是否是要找的值（7）。\n\n如果你想找别的，就可以改判断。而且lower_bound的查找结果必然是&amp;gt;=，所以你改的第二个比较没有意义。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596163886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1214649,"avatar":"https://static001.geekbang.org/account/avatar/00/12/88/b9/af5db174.jpg","nickname":"andi轩","note":"","ucode":"3AE241BE60A3E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295323,"discussion_content":"假如原始待查找vector的具体元素是不可知的，我想找到第一个>=7的元素的位置，就得用这个方式来判断了是吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596164729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224556,"user_name":"Geek_5dc295","can_delete":false,"product_type":"c1","uid":1939871,"ip_address":"","ucode":"9E14516D3CDFFF","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJlgy0OxSZOQIqfgZLoSVMjG7OrgBVtpVEOTUtWKhG62BYccoXvUD4KcGJ8c7Lpo7QflYceBaOJSg/132","comment_is_top":false,"comment_ctime":1591442324,"is_pvip":false,"replies":[{"id":"82662","content":"npos应该是字符串string的未找到标志吧，我觉得这个应该算是设计字符串与容器时的一个失误，导致与迭代器的概念不兼容。<br><br>你可以把npos只理解成字符串位置相关的概念，表示未找到，不要把它和容器、迭代器联系起来，否则容易搞糊涂。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591446339,"ip_address":"","comment_id":224556,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591442324","product_id":100051801,"comment_content":"有时候find 如果未找到对应位置不是会返回值有时候和npos对比判断，想问一下npos和迭代器之间是什么关系呀","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497523,"discussion_content":"npos应该是字符串string的未找到标志吧，我觉得这个应该算是设计字符串与容器时的一个失误，导致与迭代器的概念不兼容。\n\n你可以把npos只理解成字符串位置相关的概念，表示未找到，不要把它和容器、迭代器联系起来，否则容易搞糊涂。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591446339,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224466,"user_name":"范闲","can_delete":false,"product_type":"c1","uid":1073125,"ip_address":"","ucode":"F21FD7DF6BA53C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","comment_is_top":false,"comment_ctime":1591411910,"is_pvip":false,"replies":[{"id":"82628","content":"在算法里auto用的不多，多的是begin、end获取迭代器，再用lambda表达式处理元素，和for的差距还是挺大的。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591429569,"ip_address":"","comment_id":224466,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591411910","product_id":100051801,"comment_content":"1.用的比较多的是auto<br>2.for each range for看起来更像Python的语法糖，提高编程效率","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497485,"discussion_content":"在算法里auto用的不多，多的是begin、end获取迭代器，再用lambda表达式处理元素，和for的差距还是挺大的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591429569,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224400,"user_name":"TC128","can_delete":false,"product_type":"c1","uid":1993621,"ip_address":"","ucode":"C5FF12BB7406FB","user_header":"","comment_is_top":false,"comment_ctime":1591368033,"is_pvip":false,"replies":[{"id":"82593","content":"肯定是可以的，因为数组地址，也就是指针，它的作用和迭代器是一样的，泛型算法不会区别对待指针和迭代器。<br><br>可以把出错的代码贴出来看看，应该是用的有问题。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591399943,"ip_address":"","comment_id":224400,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1591368033","product_id":100051801,"comment_content":"老师好，请问为什么有些算法可以传入数组地址，有些却不可以？比如：<br>  int myints[] = { 10, 20, 30, 40 };<br>  int * p;<br>  p = std::find (myints, myints+4, 30);<br>但for_earch就不可以。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497461,"discussion_content":"肯定是可以的，因为数组地址，也就是指针，它的作用和迭代器是一样的，泛型算法不会区别对待指针和迭代器。\n\n可以把出错的代码贴出来看看，应该是用的有问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591399943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281634,"discussion_content":"error C3861: &#39;for_each&#39;: identifier not found，是没有找到for_each的名字吧，加上std::试试\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591781293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1993621,"avatar":"","nickname":"TC128","note":"","ucode":"C5FF12BB7406FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":279723,"discussion_content":"老师，请帮忙看看。\n\n#include <iostream>     // std::cout\n#include <algorithm>    // std::for_each\n#include <vector>       // std::vector\n\nvoid myfunction(int i) {  // function:\n\tstd::cout << &#39; &#39; << i;\n}\n\nstruct myclass {           // function object type:\n\tvoid operator() (int i) { std::cout << &#39; &#39; << i; }\n} myobject;\n\nint main() {\n\t//////////////////////////////////////////////////////////\n\t//这里是正常可以运行的代码\n\tstd::vector<int> myvector;\n\tmyvector.push_back(10);\n\tmyvector.push_back(20);\n\tmyvector.push_back(30);\n\n\tstd::cout << &#34;myvector contains:&#34;;\n\tfor_each(myvector.begin(), myvector.end(), myfunction);\n\tstd::cout << &#39;\\n&#39;;\n\n\tstd::cout << &#34;myvector contains:&#34;;\n\tfor_each(myvector.begin(), myvector.end(), myobject);\n\tstd::cout << &#39;\\n&#39;;\n\t//////////////////////////////////////////////////////////\n\n\n\t//////////////////////////////////////////////////////////\n\t//以下代码编译错误：error C3861: &#39;for_each&#39;: identifier not found\n\tint myints[] = { 10, 20, 30 };\n\tstd::cout << &#34;myints contains:&#34;;\n\tfor_each(myints, myints + 3, myfunction);\n\tstd::cout << &#39;\\n&#39;;\n\t\n\tstd::cout << &#34;myints contains:&#34;;\n\tfor_each(myints, myints + 3, myobject);\n\tstd::cout << &#39;\\n&#39;;\n\t//////////////////////////////////////////////////////////\n\n\t//system(&#34;pause&#34;);\n\treturn 0;\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591405355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224231,"user_name":"robonix","can_delete":false,"product_type":"c1","uid":1212323,"ip_address":"","ucode":"866EC82EDA455B","user_header":"https://static001.geekbang.org/account/avatar/00/12/7f/a3/23540579.jpg","comment_is_top":false,"comment_ctime":1591320469,"is_pvip":false,"replies":[{"id":"82551","content":"当然了，没有比较语义是肯定无法查找的。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591324217,"ip_address":"","comment_id":224231,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591320469","product_id":100051801,"comment_content":"老师，如果将二分查找算法应用在普通类元素上，是不是还得手写比较函数？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497409,"discussion_content":"当然了，没有比较语义是肯定无法查找的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591324217,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224048,"user_name":"Confidant.","can_delete":false,"product_type":"c1","uid":1660039,"ip_address":"","ucode":"6E137F863906B0","user_header":"https://static001.geekbang.org/account/avatar/00/19/54/87/3b1f9de4.jpg","comment_is_top":false,"comment_ctime":1591262887,"is_pvip":false,"replies":[{"id":"82557","content":"filesystem是C++17里的吧，11&#47;14里没有，我还没有用过，只是用过它的前身boost.filesystem。<br><br>从我的经验来看，path只是一个路径的字符串表示，不和实际的磁盘关联，就是一个普通对象，用shared_ptr完全可以管理。<br><br>等我有机会用新的GCC来试试吧。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591324751,"ip_address":"","comment_id":224048,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1591262887","product_id":100051801,"comment_content":"向问老师一个和今天内容没有关系的问题<br><br>#include &lt;iostream&gt;<br>#include &lt;filesystem&gt;<br><br>using namespace std;<br>using namespace filesystem;<br><br>int main()<br>{<br>    string s(&quot;log&quot;);<br>    shared_ptr&lt;path&gt; p = make_shared&lt;path&gt;(s);<br>    return 0;<br>}<br><br>这段代码在Linux下跑的时候，析构path就会崩溃，智能指针不能管理path类吗？在log文件存在于当前运行目录下","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497344,"discussion_content":"filesystem是C++17里的吧，11/14里没有，我还没有用过，只是用过它的前身boost.filesystem。\n\n从我的经验来看，path只是一个路径的字符串表示，不和实际的磁盘关联，就是一个普通对象，用shared_ptr完全可以管理。\n\n等我有机会用新的GCC来试试吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591324751,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281638,"discussion_content":"这种情况建议用boost来屏蔽标准的差异。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591781367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1660039,"avatar":"https://static001.geekbang.org/account/avatar/00/19/54/87/3b1f9de4.jpg","nickname":"Confidant.","note":"","ucode":"6E137F863906B0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281072,"discussion_content":"解决了，是g++的版本对C++17的支持不够完整，需要升级到9.3，之前的就算支持C++17也只是支持部分特性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591668116,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223997,"user_name":"hy","can_delete":false,"product_type":"c1","uid":1580046,"ip_address":"","ucode":"7D492373043C96","user_header":"https://static001.geekbang.org/account/avatar/00/18/1c/0e/f2954d1c.jpg","comment_is_top":false,"comment_ctime":1591252148,"is_pvip":false,"replies":[{"id":"82474","content":"不会的，lambda就像是一个函数，发生异常自然会向外传，可以自己写代码试验一下。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591252947,"ip_address":"","comment_id":223997,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591252148","product_id":100051801,"comment_content":"lambda表达式里面发生错误或者是出现异常外面是不是无法捕获的呀???","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497330,"discussion_content":"不会的，lambda就像是一个函数，发生异常自然会向外传，可以自己写代码试验一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591252947,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}