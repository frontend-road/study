{"id":92960,"title":"08 | 发布/订阅模式：流处理架构中的瑞士军刀","content":"<p>你好，我是蔡元楠。</p><p>今天我想要与你分享的是在处理大规模数据中十分流行的一种设计模式：发布/订阅模式（Publish/Subscribe Pattern），有些地方也称它为Pub/Sub。</p><p>在了解发布/订阅模式之前，我想先简单介绍几个基础概念——消息（Message）和消息队列（Message Queue）。</p><h2>消息</h2><p>消息是什么呢？</p><p>在分布式架构里，架构中的各个组件（Component）需要相互联系沟通。组件可以是后台的数据库，可以是前端的浏览器，也可以是公司内部不同的服务终端（Service Endpoint）。</p><p>而各个组件间就是依靠通过发送消息互相通讯的。如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/36/90/360c700398719d1abb62e202ab9dd390.jpg?wh=535*93\" alt=\"\"></p><p>消息可以是任意格式的。例如，我们可以利用JSON格式来传输一个消息，也能利用XML格式来传输一个消息，甚至可以使用一种自己定义的格式。</p><h2>消息队列</h2><p>知道了消息的含义后，你知道消息队列有什么作用吗？</p><p>消息队列在发布/订阅模式中起的是一个持久化缓冲（Durable Buffer）的作用。</p><p>消息的发送方可以发送任意消息至这个消息队列中，消息队列在接收到消息之后会将消息保存好，直到消息的接收方确认已经从这个队列拿到了这个消息，才会将这条消息从消息队列中删除。</p><p>有的消息系统平台如Apache Kafka，它能够让用户自己定义消息队列对消息的保留时间，我将会在介绍Apache Kafka的时候讲到。</p><!-- [[[read_end]]] --><p>有了消息队列后，整个发送消息的流程就变成下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/1e/2e/1ee9fe4ed0fcc75710e718784e03cd2e.jpg?wh=624*77\" alt=\"\"></p><h2>发布/订阅模式</h2><p>在了解了消息和消息队列后，现在我想和你正式地介绍发布/订阅模式的概念。</p><p><span class=\"orange\">发布/订阅模式指的是消息的发送方可以将消息异步地发送给一个系统中不同组件，而无需知道接收方是谁。</span>在发布/订阅模式中，发送方被称为发布者（Publisher），接收方则被称作订阅者（Subscriber）。</p><p>发布者将消息发送到消息队列中，订阅者可以从消息队列里取出自己感兴趣的消息。</p><p>在发布/订阅模式里，可以有任意多个发布者发送消息，也可以有任意多个订阅者接收消息，如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/d7/a4/d7a10c4975ad59e11c05a357f0e7f5a4.jpg?wh=624*283\" alt=\"\"></p><p>读到这里，你可能会有一个疑问，从概念上看，发布/订阅模式只是简单地在消息发送方和消息接收方中间多加了一个消息队列，为什么这种设计架构在实际应用会如此流行呢？我来给你举个例子说明一下。</p><p>现在假设，你是一个移动支付App公司里支付团队的开发人员，App里所有的支付操作都是由你的团队来开发的。而公司最近新成立了一个欺诈预防团队，他们希望从你的支付团队里获取交易数据。</p><p>也就是说，每次有交易发生的时候，你都需要通知他们交易的金额、地点、时间这些数据，让他们能够实时分析这次的交易是否存在欺诈行为。</p><p>按照传统的做法，两个团队需要开会交流，以确定数据消息传输的API和传输数据的格式。确定后，两个团队系统的交流方式会如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/e6/29/e6624bd049e75e05b8261d6eda77cb29.jpg?wh=617*315\" alt=\"\"></p><p>欺诈预防团队将自己需要的数据格式定义在API中告诉支付团队，每次有交易产生的时候，支付系统就会通过调用欺诈预防系统API的方式通知他们。</p><p>一段时间过后，公司希望和商家一起合作推动一项优惠活动，不同的商家会有不同的优惠。公司希望能够精准投放优惠活动的广告给感兴趣的用户，所以又成立了一个新部门，我们叫它广告推荐组吧。</p><p>广告推荐组的同事也希望从你的支付团队里获取交易数据。这个时候，你有两种选择，一种是选择第六讲中说到的批处理方式，另一种就是今天讲的发布/订阅模式。</p><p>批处理方式会从数据库中一次性读取全部用户的交易数据来进行推荐分析。</p><p>这种做法有几个不好的地方。</p><p>它需要你开放自己数据库的权限给广告推荐组，推荐组每次大量读取数据时，可能也会造成你自己的数据库性能下降。同时，还要考虑广告推荐组也想维护一份自己的数据库的需求。</p><p>如果还是按照之前欺诈预防团队的做法，让广告推荐组分享API给你，每次有交易产生的时候再通知他们的话，系统的运行模式会如文中图片所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/5d/39/5de2522f2f436141dbf802ff2a19a439.jpg?wh=617*361\" alt=\"\"></p><p>看到这里你应该明白了。每一次有一个新的系统想从支付团队里读取数据的话，都要双方开会讨论，定义一个新的API，然后修改支付团队现有的系统，将API加入系统中。</p><p>而且这些API通常都是同步调用的，过多的API调用会让系统的延迟越来越大。这样的设计模式被称作观察者模式（Observer Pattern），系统中的各个组件紧耦合（Tightly Coupled）在一起。</p><p>如果是采用发布/订阅模式来重新设计呢？整个系统就如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/f2/00/f2f3daa13f6db54f96c1c18f61a93200.jpg?wh=617*348\" alt=\"\"></p><p>采用这样的数据处理模式，作为消息发布者的支付团队无需过多考虑以后有多少其它的团队需要读取交易数据，只需要设计好自己提供的数据内容与格式，在每次交易发生时发送消息进消息队列中就可以了。任何对这些数据感兴趣的团队只需要从消息队列中自行读取便可。</p><h2>发布/订阅模式的优缺点</h2><p>说到这里，我们可以看到发布/订阅模式会有以下几个优点：</p><ul>\n<li>\n<p>松耦合（Loose Coupling）：消息的发布者和消息的订阅者在开发的时候完全不需要事先知道对方的存在，可以独立地进行开发。</p>\n</li>\n<li>\n<p>高伸缩性（High Scalability）：发布/订阅模式中的消息队列可以独立的作为一个数据存储中心存在。在分布式环境中，更是消息队列更是可以扩展至上千个服务器中。我们从Linkedin公司的技术博客中可以得知，光在2016年，Linkedin公司就维护开发了将近1400个消息队列。</p>\n</li>\n<li>\n<p>系统组件间通信更加简洁：因为不需要为每一个消息的订阅者准备专门的消息格式，只要知道了消息队列中保存消息的格式，发布者就可以按照这个格式发送消息，订阅者也只需要按照这个格式接收消息。</p>\n</li>\n</ul><p>虽然发布/订阅模式的数据处理模式优点多多，但是还是存在着自身的缺点的。</p><p>例如，在整个数据模式中，我们不能保证发布者发送的数据一定会送达订阅者。如果要保证数据一定送达的话，需要开发者自己实现响应机制。</p><p>在硅谷，很多大型云平台都是运用这个发布/订阅数据处理模式。</p><p>例如，Google的Cloud Pub/Sub平台，AWS的Amazon Simple Notification Service（SNS）。被Linkedin、Uber等硅谷大厂所广泛使用的开源平台Apache Kafka也是搭建在发布/订阅数据处理模式之上的。甚至是连Redis也支持原生的发布/订阅模式。</p><p>Apache Kafka作为一个被在硅谷大厂与独角兽广泛使用的开源平台，如果你是在创业阶段的话，说不定可以用得上，所以在这里我想简单介绍一下Apache Kafka。</p><p>在Apache Kafka中，消息的发送方被称为Producer，消息的接收方被称为Consumer，而消息队列被称为Topic。</p><p><img src=\"https://static001.geekbang.org/resource/image/b3/0e/b31f636250ed7e4ea9d20ef6bac3e90e.jpg?wh=436*386\" alt=\"\"></p><p>Apache Kafka在判断消息是否被接收方接收是利用了Log offset机制。</p><p>什么是Log offset机制呢？我举个例子给你解释一下。</p><p>假设发送方连续发送了5条数据到消息队列Topics中，这5条消息被编号为10000、10001、10002、10003和10004。</p><p>如果接收方读取数据之后回应消息队列它接收的Log offset是10000、10001和10003，那么消息队列就会认为接收方最多只接收了消息10000和10001，剩下的消息10002、10003和10004则会继续发送给接收方，直到接收方回应接收了消息10002、10003和10004。</p><h2>发布/订阅模式的适用场景</h2><p>我们说回到发布/订阅模式来，看看它能用在哪些场景。</p><p>如果你在处理数据的时候碰到以下场景，那么就可以考虑使用发布/订阅的数据处理模式。</p><ul>\n<li>\n<p>系统的发送方需要向大量的接收方广播消息。</p>\n</li>\n<li>\n<p>系统中某一个组件需要与多个独立开发的组件或服务进行通信，而这些独立开发的组件或服务可以使用不同的编程语言和通信协议。</p>\n</li>\n<li>\n<p>系统的发送方在向接收方发送消息之后无需接收方进行实时响应。</p>\n</li>\n<li>\n<p>系统中对数据一致性的要求只需要支持数据的最终一致性（Eventual Consistency）模型。</p>\n</li>\n</ul><p>要提醒你注意的一点是，如果系统的发送方在向接收方发送消息之后，需要接收方进行实时响应的话，那么绝大多数情况下，都不要考虑使用发布/订阅的数据处理模式。</p><h2>小结</h2><p>今天我们一起学习了大规模数据处理中一种十分流行的设计模式——发布/订阅模式。它能够很好地解耦（Decouple）系统中不同的组件，许多实时的流处理架构就是利用这个数据处理的设计模式搭建起来的。因为发布/订阅模式同时具有很好的伸缩性。</p><p>如果你在开发的场景适合我所讲到的适应场景，可以优先考虑使用发布/订阅模式。</p><h2>思考题</h2><p>你认为微信的朋友圈功能适合使用发布/订阅模式吗？为什么？</p><p>欢迎你把答案写在留言区，与我和其他同学一起讨论。如果你觉得有所收获，也欢迎把文章分享给你的朋友。</p><p></p>","neighbors":{"left":{"article_title":"07 | Workflow设计模式：让你在大规模数据世界中君临天下","id":92928},"right":{"article_title":"09 | CAP定理：三选二，架构师必须学会的取舍","id":93044}},"comments":[{"had_liked":false,"id":91116,"user_name":"挖矿的小戈","can_delete":false,"product_type":"c1","uid":1503917,"ip_address":"","ucode":"2078A85139BD5D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/9chAb6SjxFiapSeicsAsGqzziaNlhX9d5aEt8Z0gUNsZJ9dICaDHqAypGvjv4Bx3PryHnj7OFnOXFOp7Ik21CVXEA/132","comment_is_top":false,"comment_ctime":1556869068,"is_pvip":false,"replies":[{"id":"32964","content":"谢谢你的答案，观点基本我都是赞同的！","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557205333,"ip_address":"","comment_id":91116,"utype":1}],"discussion_count":4,"race_medal":0,"score":"126110920652","product_id":100025301,"comment_content":"盆友圈适合使用pub&#47;sub模式<br>\t原因1：消息发送方需要向多个接收方（n个可以看自己盆友圈的好友）广播消息<br>\t原因2：多消费者组（微信朋友圈数据应该不仅仅只是用于社交，可能还有其他作用吧，所以可能会有多个模块需要用到这份数据）<br>\t原因3：发送方发送消息之后是不需要接收方立即进行响应的（异步），所以用消息队列可以有效起到解耦的作用<br>\t原因4：微信朋友圈对于数据而言，满足最终一致性的","like_count":30,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448812,"discussion_content":"谢谢你的答案，观点基本我都是赞同的！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557205333,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066752,"avatar":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","nickname":"piboye","note":"","ucode":"7CFD8712857A85","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310989,"discussion_content":"这里有一个问题，用户基数太大，关注列表也很大。原因1说的不能满足。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602165896,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1503129,"avatar":"https://static001.geekbang.org/account/avatar/00/16/ef/99/cc30e2ca.jpg","nickname":"人唯优","note":"","ucode":"7949FE2500759B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":146153,"discussion_content":"分析的不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579600174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1120583,"avatar":"https://static001.geekbang.org/account/avatar/00/11/19/47/b27f1314.jpg","nickname":"kissrain","note":"","ucode":"2177C53E3B2DCC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6667,"discussion_content":"我觉得在发朋友圈这个场景并不适合消息订阅，实时性要求很高，但消息落地后的异步调用或者提供给接收方或者第三方适合。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567043840,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91350,"user_name":"paradox","can_delete":false,"product_type":"c1","uid":1087615,"ip_address":"","ucode":"4ABDAB21D0F7E9","user_header":"https://static001.geekbang.org/account/avatar/00/10/98/7f/9ce24253.jpg","comment_is_top":false,"comment_ctime":1556992764,"is_pvip":false,"replies":[{"id":"32974","content":"谢谢你的留言！总结得很到位啊！","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557208934,"ip_address":"","comment_id":91350,"utype":1}],"discussion_count":2,"race_medal":0,"score":"87456338684","product_id":100025301,"comment_content":"1. 微博粉丝订阅机制<br>由于存在流量明星，针对不同情况的用户，系统可以区别对待，在线用户采用“推”模式，尽量及时更新订阅者的timeline；不在线的用户采用“拉”模式，在该用户上线后更新timeline。<br><br>2. 微信朋友圈机制<br>由于不太可能存在微博这种超级发布者，因此可仅采用“推”模式。<br><br>3. 两款产品的共同点<br>a) 发布者必须实时同步处理，因为发布成功后需要直接看到自己生产的消息。<br>b) 订阅者可以异步处理，只要保证系统满足最终一致性即可。","like_count":21,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448895,"discussion_content":"谢谢你的留言！总结得很到位啊！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557208934,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1110662,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f2/86/d689f77e.jpg","nickname":"Hank_Yan","note":"","ucode":"86899B561C502B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289447,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594102700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91047,"user_name":"NEVER SETTLE","can_delete":false,"product_type":"c1","uid":1101894,"ip_address":"","ucode":"9C86BDAFDBF768","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/46/1a9229b3.jpg","comment_is_top":false,"comment_ctime":1556833236,"is_pvip":false,"replies":[{"id":"32985","content":"谢谢你的留言提问！个人觉得即便公司会开发自己的MQ，很多都是建立在这些开源项目之上的。一方面可能因为开源项目的一些属性并不能满足到自身的应用场景，所以加以改进。另一方面如果是大厂的话，可以打造出自己的一套生态圈，开发接口更加适合内部使用。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557213158,"ip_address":"","comment_id":91047,"utype":1}],"discussion_count":1,"race_medal":0,"score":"70276309972","product_id":100025301,"comment_content":"老师，当今有许多很好的开源MQ，响Kafka，RabbitMQ等等，但是在看许多技术分享大会，为什么许多公司还会自己开发MQ呢？","like_count":17,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448780,"discussion_content":"谢谢你的留言提问！个人觉得即便公司会开发自己的MQ，很多都是建立在这些开源项目之上的。一方面可能因为开源项目的一些属性并不能满足到自身的应用场景，所以加以改进。另一方面如果是大厂的话，可以打造出自己的一套生态圈，开发接口更加适合内部使用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557213158,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91046,"user_name":"LJK","can_delete":false,"product_type":"c1","uid":1199213,"ip_address":"","ucode":"12B2441099FF1D","user_header":"https://static001.geekbang.org/account/avatar/00/12/4c/6d/c20f2d5a.jpg","comment_is_top":false,"comment_ctime":1556826460,"is_pvip":false,"replies":[{"id":"32987","content":"你好呀，感谢你的提问！<br><br>其实在观察者模式下，你也可以通过消息队列去传递消息。但是更本质的区别是在观察者模式下，观察者必须知道被监听者的存在。就像例子所示，观察者必须调用被监听者的接口。而发布&#47;订阅模式下，两者是解耦的，互相都不用知道对方的存在。<br><br>消息队列中既可以使用push模式也可以使用pull模式，关键在于应用场景的考虑。例如如果消息跟新发布频繁，而下游的接收者能够处理的qps不高，那可能会更加倾向于采取pull模式。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557213521,"ip_address":"","comment_id":91046,"utype":1}],"discussion_count":2,"race_medal":0,"score":"57391401308","product_id":100025301,"comment_content":"老师好，有一点模糊的地方，请问观察者模式和发布&#47;订阅模式的区别从消息的传递上来看就是是否通过消息队列传递数据么？另外消息队列是对接收者push消息还是接收者主动从消息队列中pull消息出来呢？谢谢老师","like_count":13,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448779,"discussion_content":"你好呀，感谢你的提问！\n\n其实在观察者模式下，你也可以通过消息队列去传递消息。但是更本质的区别是在观察者模式下，观察者必须知道被监听者的存在。就像例子所示，观察者必须调用被监听者的接口。而发布/订阅模式下，两者是解耦的，互相都不用知道对方的存在。\n\n消息队列中既可以使用push模式也可以使用pull模式，关键在于应用场景的考虑。例如如果消息跟新发布频繁，而下游的接收者能够处理的qps不高，那可能会更加倾向于采取pull模式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557213521,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1052446,"avatar":"https://static001.geekbang.org/account/avatar/00/10/0f/1e/7877ce4d.jpg","nickname":"RussellSN","note":"","ucode":"E570B075D4AD21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4358,"discussion_content":"观察者模式在实现时一般通过向被观察者被动注册的方式。不会让被观察者主动发现有多少观察者的。基于这一点，被观察者也是不知道有多少观察者的。\n以上是实现层面的方式，运行时还是你说的那样。有必要解释一下这个细节。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1565335060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91785,"user_name":"Chn.K","can_delete":false,"product_type":"c1","uid":1285191,"ip_address":"","ucode":"F82E8CE20C16FA","user_header":"https://static001.geekbang.org/account/avatar/00/13/9c/47/50cf2cab.jpg","comment_is_top":false,"comment_ctime":1557107763,"is_pvip":false,"replies":[{"id":"32898","content":"谢谢你的留言提问！一般来说，这种发送机制叫做at least once delivery，这种情况需要消费者自身具备Idempotency，也就是幂等性。消费者需要自己知道哪些消息是duplicate的，从而知道怎么处理这些重复消息。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557188943,"ip_address":"","comment_id":91785,"utype":1}],"discussion_count":2,"race_medal":0,"score":"48801748019","product_id":100025301,"comment_content":"log offset类似tcp的滑动窗口机制，有个问题：如例子讲的10003，在第一次由于某种原因未被消费者消费，生产者又发了一次10003，然后第一次发送的10003又到了消费者，那么10003会被消费者消费两次，这种情况kafka会有什么处理机制吗？","like_count":11,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449028,"discussion_content":"谢谢你的留言提问！一般来说，这种发送机制叫做at least once delivery，这种情况需要消费者自身具备Idempotency，也就是幂等性。消费者需要自己知道哪些消息是duplicate的，从而知道怎么处理这些重复消息。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1557188943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1187478,"avatar":"https://static001.geekbang.org/account/avatar/00/12/1e/96/c735ad6b.jpg","nickname":"滩涂曳尾","note":"","ucode":"40F650F2A419D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":606,"discussion_content":"学习了。原来这就是at least once。一般来说，exactly once是怎么做到的呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561794234,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91622,"user_name":"J Zhang","can_delete":false,"product_type":"c1","uid":1049115,"ip_address":"","ucode":"A64B2E61A8B6A8","user_header":"https://static001.geekbang.org/account/avatar/00/10/02/1b/e1e89267.jpg","comment_is_top":false,"comment_ctime":1557062315,"is_pvip":false,"replies":[{"id":"32994","content":"哈哈哈，感觉你的基本功很扎实啊，那这一讲你可以当作是复习章节，当然也可以留言和我讨论更高级的内容。我的专栏也希望能对初学者友好一点，对于初学者来说，这一讲是全新的内容呢。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557217588,"ip_address":"","comment_id":91622,"utype":1}],"discussion_count":1,"race_medal":0,"score":"48801702571","product_id":100025301,"comment_content":"感觉没啥内容啊","like_count":12,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448969,"discussion_content":"哈哈哈，感觉你的基本功很扎实啊，那这一讲你可以当作是复习章节，当然也可以留言和我讨论更高级的内容。我的专栏也希望能对初学者友好一点，对于初学者来说，这一讲是全新的内容呢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557217588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92964,"user_name":"cl","can_delete":false,"product_type":"c1","uid":1307039,"ip_address":"","ucode":"E868BD3A20006D","user_header":"https://static001.geekbang.org/account/avatar/00/13/f1/9f/96240774.jpg","comment_is_top":false,"comment_ctime":1557369296,"is_pvip":false,"replies":[{"id":"33184","content":"谢谢你的提问！如果我没理解错你的问题的话，你是想问接收方是否回复了10000、10001和10003这三个Log offset对吧？是的，接收的log offset有10003。因为消息队列需要接收到连续的log offset才会判定接收方接收到消息，这里因为log offset从10002断开了，所以消息队列会认为接收方从10002开始往后的消息都没有接收到。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557387685,"ip_address":"","comment_id":92964,"utype":1}],"discussion_count":2,"race_medal":0,"score":"40212074960","product_id":100025301,"comment_content":"如果接收方读取数据之后回应消息队列它接收的 Log offset 是 10000、10001 和 10003，那么消息队列就会认为接收方最多只接收了消息 10000 和 10001，剩下的消息 10002、10003 和 10004 则会继续发送给接收方，直到接收方回应接收了消息 10002、10003 和 10004。<br>第一句接收的log offset有10003吗？","like_count":10,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449440,"discussion_content":"谢谢你的提问！如果我没理解错你的问题的话，你是想问接收方是否回复了10000、10001和10003这三个Log offset对吧？是的，接收的log offset有10003。因为消息队列需要接收到连续的log offset才会判定接收方接收到消息，这里因为log offset从10002断开了，所以消息队列会认为接收方从10002开始往后的消息都没有接收到。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557387685,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1506831,"avatar":"https://static001.geekbang.org/account/avatar/00/16/fe/0f/5c778928.jpg","nickname":"一雪","note":"","ucode":"224DE0CDEA4067","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":12388,"discussion_content":"原来如此，我还以为是笔误","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568526344,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91202,"user_name":"涵","can_delete":false,"product_type":"c1","uid":1502742,"ip_address":"","ucode":"BB8575DB13F1E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/ee/16/742956ac.jpg","comment_is_top":false,"comment_ctime":1556921492,"is_pvip":false,"replies":[{"id":"32945","content":"涵你好，谢谢你的留言与提问！<br><br>第一个问题，一般不同的系统有不同的机制去确定消息队列中消息会被保存多久。像Apache Kafka中可以通过设定Retention Period来确定消息被保存多久，甚至可以设置Retention Period为Forever来永久保存。<br><br>第二个问题，只要没有超过保留期，消息会一直保存在队列并且一直尝试发送给第五个订阅者。当然订阅者也可以自己设定retry times，如果第五个订阅者告诉消息队列只需要重试一次，那这条消息就不会再发送给第五个订阅者了。如果你要保证操作一定成功，就要考虑用RPC来调用了。<br><br>第三个问题还是要看系统设计了，设计上收到与不收到都可以做到，像Apache Kafka可以通过重设Log Offset的位置去实现新的订阅者收取队列里面旧的消息。如果你使用开源项目的话，文档里应该会有说明的。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557198542,"ip_address":"","comment_id":91202,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27326725268","product_id":100025301,"comment_content":"老师好，对于消息队列中的消息存储有一个问题。在一个发布订阅模式下的消息队列中消息会被保存多久呢?具体情景是如果有五个接收方订阅了一个队列的消息，其中四个成功接收了，第五个总也无法接收，这条消息会一直保存在队列中，并且不断尝试发给第五个订阅者吗？还是会设置最多重复次数?另一个情景，在发布者发送消息至队列后，新增加了一个订阅者，这时新的订阅者可以收到队列里已放入的消息吗？谢谢。","like_count":6,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448842,"discussion_content":"涵你好，谢谢你的留言与提问！\n\n第一个问题，一般不同的系统有不同的机制去确定消息队列中消息会被保存多久。像Apache Kafka中可以通过设定Retention Period来确定消息被保存多久，甚至可以设置Retention Period为Forever来永久保存。\n\n第二个问题，只要没有超过保留期，消息会一直保存在队列并且一直尝试发送给第五个订阅者。当然订阅者也可以自己设定retry times，如果第五个订阅者告诉消息队列只需要重试一次，那这条消息就不会再发送给第五个订阅者了。如果你要保证操作一定成功，就要考虑用RPC来调用了。\n\n第三个问题还是要看系统设计了，设计上收到与不收到都可以做到，像Apache Kafka可以通过重设Log Offset的位置去实现新的订阅者收取队列里面旧的消息。如果你使用开源项目的话，文档里应该会有说明的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557198542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91173,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1556888697,"is_pvip":false,"replies":[{"id":"32965","content":"谢谢你的答案！分析得很详细，基本上我都是赞同的！","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557205389,"ip_address":"","comment_id":91173,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23031725177","product_id":100025301,"comment_content":"微信朋友圈适合用消息发布－订阅模式<br>1.系统的发送方需要向大量的接收方广播消息。一个人打朋友圈，需要向有好友关系的多方发消息<br><br>2.朋友圈的数据会被多个独立的业务方使用，比如做数据分析用于投放朋友圈广告，进行用户行为分析，构建用户画像<br><br>3.系统的发送方在向接收方发送消息之后无需接收方进行实时响应。因为朋友圈这种业务应该使用pull模式，当A发朋友圈时，A的好友B C D，只有当B C D进行刷新朋友圈时，会去pull数据<br><br>4.朋友圈对数据一致性只会要求最终一致性<br><br>所以朋友圈很适合消息发布－订阅模式","like_count":5,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448834,"discussion_content":"谢谢你的答案！分析得很详细，基本上我都是赞同的！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557205389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92267,"user_name":"purh","can_delete":false,"product_type":"c1","uid":1138751,"ip_address":"","ucode":"ED69F92440F2A0","user_header":"https://static001.geekbang.org/account/avatar/00/11/60/3f/594c19bc.jpg","comment_is_top":false,"comment_ctime":1557217622,"is_pvip":false,"replies":[{"id":"33054","content":"谢谢你的提问！<br><br>我的理解是两者都会有。作为底层实现的话，流处理的数据是无限的，流引擎也不可能无止境地等待数据到来，所以一般处理这种无限流数据的话都需要定义window和trigger。所谓window就是你希望处理数据的时间窗口多大，trigger定义了什么时候你想处理时间窗口内的数据。就如你所举的例子，如果Kafka后面接的是Flink的话，Flink会将这些数据抽象成DataStream，一个时间窗口内的数据你可以把它看作就是传统数据库中已有的数据，可以做类似关系数据库的操作。Flink会监听Kafka新传来的数据，等到下一个trigger开始了，Flink又会像之前一样计算这些新传来的在一定时间窗口内的数据。<br><br>希望这能帮助你理解到你所问的问题。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557273636,"ip_address":"","comment_id":92267,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18737086806","product_id":100025301,"comment_content":"谢谢老师的答复，我的问题没表述完整，kafka后面接关系数据库可以重做这些日志以落地数据，并进一步用sql处理数据，但是如果Kafka后面接流处理引擎比如Flink等，Kafka里面存的redo日志，传给流引擎，在流引擎里面如何处理这些日志？比如分别针对一个表执行了insert update delete，流引擎会去重做类似关系数据库对这些DML日志的操作，再基于结果数据做分析么，还是直接操作这些增量日志。<br><br>我没有流计算的实战经验，问题可能比较菜，请老师见谅。","like_count":4,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449200,"discussion_content":"谢谢你的提问！\n\n我的理解是两者都会有。作为底层实现的话，流处理的数据是无限的，流引擎也不可能无止境地等待数据到来，所以一般处理这种无限流数据的话都需要定义window和trigger。所谓window就是你希望处理数据的时间窗口多大，trigger定义了什么时候你想处理时间窗口内的数据。就如你所举的例子，如果Kafka后面接的是Flink的话，Flink会将这些数据抽象成DataStream，一个时间窗口内的数据你可以把它看作就是传统数据库中已有的数据，可以做类似关系数据库的操作。Flink会监听Kafka新传来的数据，等到下一个trigger开始了，Flink又会像之前一样计算这些新传来的在一定时间窗口内的数据。\n\n希望这能帮助你理解到你所问的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557273636,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":110631,"user_name":"John","can_delete":false,"product_type":"c1","uid":1020861,"ip_address":"","ucode":"E4ADF8488953FB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/93/bd/f3977ebb.jpg","comment_is_top":false,"comment_ctime":1562306883,"is_pvip":false,"replies":[{"id":"40296","content":"谢谢你的提问！这个问题挺常见的，PubSub肯定是可以做到的。具体的做法还是看你的架构吧。如果你是own整一套系统的话，一种做法是你的service直接对这两个数据库进行dual write。如果你只是own这两个database的话，我相信Oracle应该是有一些database change notification的机制，这个时候你可以将这个data change publish到一个service中，然后再做同步。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1562368881,"ip_address":"","comment_id":110631,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14447208771","product_id":100025301,"comment_content":"請問老師 如果想把Oracle的數據實時同步到其他的地方比如MongoDB 要求幾秒鐘以內的latency 有沒有辦法使用pubsub的概念做到呢 又該如何做呢 謝謝","like_count":3,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456979,"discussion_content":"谢谢你的提问！这个问题挺常见的，PubSub肯定是可以做到的。具体的做法还是看你的架构吧。如果你是own整一套系统的话，一种做法是你的service直接对这两个数据库进行dual write。如果你只是own这两个database的话，我相信Oracle应该是有一些database change notification的机制，这个时候你可以将这个data change publish到一个service中，然后再做同步。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562368881,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91097,"user_name":"川杰","can_delete":false,"product_type":"c1","uid":1099750,"ip_address":"","ucode":"815211E1D698E6","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/e6/11f21cb4.jpg","comment_is_top":false,"comment_ctime":1556855222,"is_pvip":false,"replies":[{"id":"32967","content":"谢谢你的留言！我觉得本质上还是有所不同的，毕竟在观察者模式中观察者需要知道被监听的对象，而发布&#47;订阅模式通过消息队列解耦了这一层关系。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557205683,"ip_address":"","comment_id":91097,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14441757110","product_id":100025301,"comment_content":"老师您好，个人理解，观察者模式本质上是消息推出，订阅该消息的对象获取消息并进行处理；所以我认为，发布&#47;订阅模式其实是一种特殊的观察者模式，或者是观察者模式的实现方式。","like_count":3,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448802,"discussion_content":"谢谢你的留言！我觉得本质上还是有所不同的，毕竟在观察者模式中观察者需要知道被监听的对象，而发布/订阅模式通过消息队列解耦了这一层关系。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557205683,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1013147,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/75/9b/611e74ab.jpg","nickname":"技术修行者","note":"","ucode":"28CA41A1214D6B","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324570,"discussion_content":"对于观察者模式，我们可以把订阅者信息抽象成配置信息，发布者读取配置信息后，按照统一的接口通知订阅者，这样在订阅者有变化的时候，只需要修改配置信息，无需对代码做任何调整。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605137089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117912,"user_name":"潘腾","can_delete":false,"product_type":"c1","uid":1566689,"ip_address":"","ucode":"04FEC6FFD62F43","user_header":"","comment_is_top":false,"comment_ctime":1564190893,"is_pvip":false,"replies":[{"id":"43290","content":"谢谢你的提问！这个看你的设计了，即便真的使用发布订阅模式的话，同一个队列的消费者可以通过设置filter来只接收自己感兴趣的内容。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1564269303,"ip_address":"","comment_id":117912,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10154125485","product_id":100025301,"comment_content":"如果微信朋友圈使用发布订阅模式的话，那么是不是意味着每一个用户对应一个消息队列呢，那这样的话是不是就得有好几亿消息队列？","like_count":2,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460176,"discussion_content":"谢谢你的提问！这个看你的设计了，即便真的使用发布订阅模式的话，同一个队列的消费者可以通过设置filter来只接收自己感兴趣的内容。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564269303,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1566689,"avatar":"","nickname":"潘腾","note":"","ucode":"04FEC6FFD62F43","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3174,"discussion_content":"感谢您的回答，这种方式也想过，如果1000个用户用一个队列，假设一个用户有100个好友，则可能需要订阅10万个用户的消息，然后过滤100个自己好友的消息。可能存在很多资源消耗。\n\n网上查了一下，微信朋友圈的实现大概流程是，发完朋友圈之后，将这条朋友圈写入到发圈人好友的各个朋友圈时间线里面，更像是观察着模式实现的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564276922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91275,"user_name":"lwenbin","can_delete":false,"product_type":"c1","uid":1202109,"ip_address":"","ucode":"05C4CC6BE0B56C","user_header":"https://static001.geekbang.org/account/avatar/00/12/57/bd/acf40fa0.jpg","comment_is_top":false,"comment_ctime":1556960827,"is_pvip":false,"replies":[{"id":"32969","content":"谢谢你的答案！是的，朋友圈还是以pull为主，而如何做到通知客户端朋友圈有更新这一步还是可以用pub&#47;sub模式的。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557206196,"ip_address":"","comment_id":91275,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10146895419","product_id":100025301,"comment_content":"我觉得朋友圈可以用pub&#47;sub模式，但是如果只是为了满足发朋友圈让好友能看到，应该在技术实现上不太会用消息队列实现。<br>对于其他应用可能会有一个大的消息队列或者按照某些规则分区，存放所有用户发布的消息，供下游应用消费，比如合规检查，统计等等。<br>单从朋友圈发布查看如果用消息队列，代价可能太大，消息队列会过多，而且某些消息可能不一定有订阅者。朋友圈这种查看基本以pull为主。","like_count":2,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448867,"discussion_content":"谢谢你的答案！是的，朋友圈还是以pull为主，而如何做到通知客户端朋友圈有更新这一步还是可以用pub/sub模式的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557206196,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91139,"user_name":"JohnT3e","can_delete":false,"product_type":"c1","uid":1063982,"ip_address":"","ucode":"CF4AAAC933529C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLdWHFCr66TzHS2CpCkiaRaDIk3tU5sKPry16Q7ic0mZZdy8LOCYc38wOmyv5RZico7icBVeaPX8X2jcw/132","comment_is_top":false,"comment_ctime":1556877331,"is_pvip":false,"replies":[{"id":"32953","content":"谢谢你的答案！","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557200984,"ip_address":"","comment_id":91139,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10146811923","product_id":100025301,"comment_content":"适合，1. 场景对实时性要求不高；2. 用户自己可以刷新拉取；","like_count":2,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448825,"discussion_content":"谢谢你的答案！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557200984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94578,"user_name":"杨建","can_delete":false,"product_type":"c1","uid":1503896,"ip_address":"","ucode":"A4D657C33CE626","user_header":"https://static001.geekbang.org/account/avatar/00/16/f2/98/6cd90598.jpg","comment_is_top":false,"comment_ctime":1557844837,"is_pvip":false,"replies":[{"id":"33839","content":"谢谢你的留言！哈哈，那可能是中美差异了，在北美这边的信用卡支付和盗刷alert是平行进行的，如果持卡人发现真的被盗刷了再dispute掉这笔交易。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557865683,"ip_address":"","comment_id":94578,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5852812133","product_id":100025301,"comment_content":"老师，想问一下，举的例子中，那个支付部门和防诈骗部门之间如果采用发布&#47;订阅模式是不是有问题，因为在我看来防诈骗这个功能应该是和支付之间存在时序上的先后关系的，只有防诈骗小组检验通过了，才能进一步支付，而发布&#47;订阅模式是异步的，并不能保证这个时序，不知道我理解的有没有问题","like_count":1,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450111,"discussion_content":"谢谢你的留言！哈哈，那可能是中美差异了，在北美这边的信用卡支付和盗刷alert是平行进行的，如果持卡人发现真的被盗刷了再dispute掉这笔交易。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557865683,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91716,"user_name":"...","can_delete":false,"product_type":"c1","uid":1322702,"ip_address":"","ucode":"6AB5B1F9386267","user_header":"https://static001.geekbang.org/account/avatar/00/14/2e/ce/2151c3a9.jpg","comment_is_top":false,"comment_ctime":1557100065,"is_pvip":false,"replies":[{"id":"32936","content":"谢谢你的留言！是的，10003数据会被重复消费，这种消息发送机制也被称为at-least-once delivery。作为下游的客户端，一定要保证系统具有Idempotency幂等性，来保证重复的消息能够被正确处理。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557197635,"ip_address":"","comment_id":91716,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5852067361","product_id":100025301,"comment_content":"如果接收方读取数据之后回应消息队列它接收的 Log offset 是 10000、10001 和 10003，那么消息队列就会认为接收方最多只接收了消息 10000 和 10001，剩下的消息 10002、10003 和 10004 则会继续发送给接收方，直到接收方回应接收了消息 10002、10003 和 10004。<br><br>这样10003数据是不是被重复消费了","like_count":1,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449002,"discussion_content":"谢谢你的留言！是的，10003数据会被重复消费，这种消息发送机制也被称为at-least-once delivery。作为下游的客户端，一定要保证系统具有Idempotency幂等性，来保证重复的消息能够被正确处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557197635,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91506,"user_name":"purh","can_delete":false,"product_type":"c1","uid":1138751,"ip_address":"","ucode":"ED69F92440F2A0","user_header":"https://static001.geekbang.org/account/avatar/00/11/60/3f/594c19bc.jpg","comment_is_top":false,"comment_ctime":1557044670,"is_pvip":false,"replies":[{"id":"32976","content":"谢谢你的提问！Kappa架构11讲会讲到，你这是预知未来了啊哈哈。<br><br>如果我没有理解错你的问题的话，维度聚合这一步一般不会放在Kafka里面完成。即便你的Kafka消息队列里面存放的是Redo log，也是需要把这些Redo log message发送到下游客户端中，例如像你说的，下游客户端将这些message保存在关系数据库之后再进行聚合。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557209642,"ip_address":"","comment_id":91506,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5852011966","product_id":100025301,"comment_content":"老师好，Kappa模式如果用Kafaka做持久化，Kafaka里面存的消息和关系数据库的表应该是不同的，关系数据库可以很轻易的用SQL访问表，比如做维度聚合，Kafaka里面存的是比如Redo日志，基于这些DML日志如何如何做数据分析？","like_count":1,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448927,"discussion_content":"谢谢你的提问！Kappa架构11讲会讲到，你这是预知未来了啊哈哈。\n\n如果我没有理解错你的问题的话，维度聚合这一步一般不会放在Kafka里面完成。即便你的Kafka消息队列里面存放的是Redo log，也是需要把这些Redo log message发送到下游客户端中，例如像你说的，下游客户端将这些message保存在关系数据库之后再进行聚合。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557209642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91201,"user_name":"LJK","can_delete":false,"product_type":"c1","uid":1199213,"ip_address":"","ucode":"12B2441099FF1D","user_header":"https://static001.geekbang.org/account/avatar/00/12/4c/6d/c20f2d5a.jpg","comment_is_top":false,"comment_ctime":1556915775,"is_pvip":false,"replies":[{"id":"32970","content":"谢谢你的答案！把发朋友圈分成两步这个考虑非常好，自己发送朋友圈的时候一般都是需要确认发送成功了，而不是fire and forget。后面follower的朋友圈通知我也是十分赞同的。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557206844,"ip_address":"","comment_id":91201,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5851883071","product_id":100025301,"comment_content":"我觉得朋友圈分成两部分吧<br>- 自己发送的时候需要同步返回结果并且在自己的朋友圈立即可见<br>- 自己发送完成之后在follower的朋友圈中显示可以是发布订阅模式","like_count":1,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448841,"discussion_content":"谢谢你的答案！把发朋友圈分成两步这个考虑非常好，自己发送朋友圈的时候一般都是需要确认发送成功了，而不是fire and forget。后面follower的朋友圈通知我也是十分赞同的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557206844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91073,"user_name":"apollo","can_delete":false,"product_type":"c1","uid":1228699,"ip_address":"","ucode":"64DC84485F57E5","user_header":"https://static001.geekbang.org/account/avatar/00/12/bf/9b/ecb24ad9.jpg","comment_is_top":false,"comment_ctime":1556847315,"is_pvip":false,"replies":[{"id":"32978","content":"谢谢你的提问！我是了解过RabbitMQ可以通过Direct reply-to实现RPC，不过我不太清楚使用场景，可能是因为公司已经在使用RabbitMQ而又需要有RPC的那种request-response机制，但是技术迁移成本太大。一般来说我们都希望Pub&#47;Sub就使用专门的framework而RPC也使用专门的RPC framework。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557211158,"ip_address":"","comment_id":91073,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5851814611","product_id":100025301,"comment_content":"蔡老师对基于RabbitMQ,MQTT实现RPC怎么看？","like_count":1,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448787,"discussion_content":"谢谢你的提问！我是了解过RabbitMQ可以通过Direct reply-to实现RPC，不过我不太清楚使用场景，可能是因为公司已经在使用RabbitMQ而又需要有RPC的那种request-response机制，但是技术迁移成本太大。一般来说我们都希望Pub/Sub就使用专门的framework而RPC也使用专门的RPC framework。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557211158,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91056,"user_name":"Liu C.","can_delete":false,"product_type":"c1","uid":1504607,"ip_address":"","ucode":"29F3988DD8128A","user_header":"https://static001.geekbang.org/account/avatar/00/16/f5/5f/217c6a14.jpg","comment_is_top":false,"comment_ctime":1556840832,"is_pvip":false,"replies":[{"id":"32995","content":"谢谢你的答案，分析得不错！","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557217638,"ip_address":"","comment_id":91056,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5851808128","product_id":100025301,"comment_content":"我觉得适合，原因：<br>1 接收方不需要实时响应（微信客户端），只需要被定期提醒新内容并在打开时获取新内容即可<br>2 采取订阅模式朋友圈可以支持大量后台分析的api","like_count":1,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448783,"discussion_content":"谢谢你的答案，分析得不错！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557217638,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":209116,"user_name":"北冥有鱼","can_delete":false,"product_type":"c1","uid":1592243,"ip_address":"","ucode":"1690734A1061F4","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/b3/51bb33f2.jpg","comment_is_top":false,"comment_ctime":1587512237,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587512237","product_id":100025301,"comment_content":"学完老师的课程，我在思考我们现有的项目中那些是可以从观察者模式改为发布订阅模式的。老师，我们需要频繁的呈现或让下游系统下载我们的报表数据，这让我们的服务器压力很大，这里可以改为发布订阅模式吗？","like_count":0},{"had_liked":false,"id":187789,"user_name":"Eden2020","can_delete":false,"product_type":"c1","uid":1899158,"ip_address":"","ucode":"0DEE62F2335237","user_header":"https://static001.geekbang.org/account/avatar/00/1c/fa/96/4a7b7505.jpg","comment_is_top":false,"comment_ctime":1584242173,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584242173","product_id":100025301,"comment_content":"朋友圈文章发布和留言都适合发布订阅模式，两个原因，接收方不需要实时接收，且满足最终一致性模型。","like_count":0},{"had_liked":false,"id":171340,"user_name":"切比雪夫","can_delete":false,"product_type":"c1","uid":1506525,"ip_address":"","ucode":"F09638D15FF229","user_header":"https://static001.geekbang.org/account/avatar/00/16/fc/dd/df0ad1b6.jpg","comment_is_top":false,"comment_ctime":1578905273,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578905273","product_id":100025301,"comment_content":"作为小白，这门课程真的很有帮助！","like_count":0},{"had_liked":false,"id":120477,"user_name":"wong ka seng","can_delete":false,"product_type":"c1","uid":1338885,"ip_address":"","ucode":"C1A713082D0D64","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/05/d47cee18.jpg","comment_is_top":false,"comment_ctime":1564910043,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564910043","product_id":100025301,"comment_content":"老师好!<br>&quot;发布 &#47; 订阅模式指的是消息的发送方可以将消息异步地发送给一个系统中不同组件，而无需知道接收方是谁。&quot; =&gt; 那麽BROWSER探访网站伺服器这个情况, 算不算发布 &#47; 订阅模式?<br>","like_count":0},{"had_liked":false,"id":110784,"user_name":"Geek_fengchen","can_delete":false,"product_type":"c1","uid":1544896,"ip_address":"","ucode":"87CD06306CEC5E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eotaMCDHogj3lQ9SQic8P9BxPtaMC4rYfmulupeuAECicmTJDJz1Rff0nzYiatbC6wKEqF59oS8yJiciag/132","comment_is_top":false,"comment_ctime":1562332291,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562332291","product_id":100025301,"comment_content":"有顺序的","like_count":0},{"had_liked":false,"id":109674,"user_name":"小乙哥","can_delete":false,"product_type":"c1","uid":1063308,"ip_address":"","ucode":"C77E79BEA0C325","user_header":"https://static001.geekbang.org/account/avatar/00/10/39/8c/089525aa.jpg","comment_is_top":false,"comment_ctime":1562075612,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562075612","product_id":100025301,"comment_content":"文中提到kafka的log offset的例子，应该是争对某个topic下的partition吧？不是说整个topic吧？一个topic下会有多个partition，每个partition都有各自的log offset","like_count":0},{"had_liked":false,"id":108530,"user_name":"滩涂曳尾","can_delete":false,"product_type":"c1","uid":1187478,"ip_address":"","ucode":"40F650F2A419D4","user_header":"https://static001.geekbang.org/account/avatar/00/12/1e/96/c735ad6b.jpg","comment_is_top":false,"comment_ctime":1561793900,"is_pvip":false,"replies":[{"id":"39316","content":"谢谢你的留言和分享！总结得不错啊！","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1561836129,"ip_address":"","comment_id":108530,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561793900","product_id":100025301,"comment_content":"学习心得：<br><br>消息队列有2个重点：<br>1. 解耦合——vs. 观察者模式实现相同效果，而且每次都要和观察者协商消息格式）<br>2. 高伸缩性——消息队列可以作为一个“独立”的“分布式存储”，专业团队维护。<br><br>apache kafka: Producer -&gt; topics -&gt; Consumer<br><br>发布&#47;订阅模式限制：<br>1. 发送之后，无法做到接收方实时响应；<br>2. 只能满足“最终一致性，不能满足强一致性” （知乎有篇文章很好：https:&#47;&#47;zhuanlan.zhihu.com&#47;p&#47;67949045）","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456028,"discussion_content":"谢谢你的留言和分享！总结得不错啊！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561836129,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106316,"user_name":"funnycrab","can_delete":false,"product_type":"c1","uid":1514280,"ip_address":"","ucode":"D2347BEE382C08","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJBmhAFTauQ7UdT3B58h2oW11hYqPicbExsryET9Do5u6MHzQfbYUyqoCeDgk0KIdPu5rtolPbgyfw/132","comment_is_top":false,"comment_ctime":1561263104,"is_pvip":false,"replies":[{"id":"38434","content":"啊哈哈，谢谢你的支持啊，同时也谢谢你的建议！","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1561272145,"ip_address":"","comment_id":106316,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561263104","product_id":100025301,"comment_content":"我上交学长就是厉害 课程形象生动 易于理解！<br><br>指出一个小typo，<br>“在了解了消息和消息队列后，现在我想和你正式地向你介绍...”<br>应为<br>“在了解了消息和消息队列后，现在我想和你正式地介绍...”<br>或者<br>“在了解了消息和消息队列后，现在我想正式地向你介绍...”","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455043,"discussion_content":"啊哈哈，谢谢你的支持啊，同时也谢谢你的建议！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561272145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106115,"user_name":"西北偏北","can_delete":false,"product_type":"c1","uid":1043160,"ip_address":"","ucode":"64BD69C84EE6A1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erdpKbFgRLnicjsr6qkrPVKZcFrG3aS2V51HhjFP6Mh2CYcjWric9ud1Qiclo8A49ia3eZ1NhibDib0AOCg/132","comment_is_top":false,"comment_ctime":1561179888,"is_pvip":false,"replies":[{"id":"38460","content":"谢谢留言！总结得不错啊！不过消息队列也不一定是可靠性送达的，在一些极端的情况下也是有可能出现丢包。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1561330275,"ip_address":"","comment_id":106115,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561179888","product_id":100025301,"comment_content":"消息队列用于解耦多个系统之间的通信。特别是一对多的通信。假设a系统要发消息给b和c 如果没有消息队列，a系统需要实现对b和c发送的机制，考虑消息丢失的问题，考虑消息过大时的并发和容错问题。  <br><br><br>引入消息队列后，a只需跟消息队列大交道，消息队列一般实现了消息的可靠性送达，高并发下的数据集群服务。","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454958,"discussion_content":"谢谢留言！总结得不错啊！不过消息队列也不一定是可靠性送达的，在一些极端的情况下也是有可能出现丢包。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561330275,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104124,"user_name":"夷，这也可以","can_delete":false,"product_type":"c1","uid":1487004,"ip_address":"","ucode":"09D87564352730","user_header":"https://static001.geekbang.org/account/avatar/00/16/b0/9c/0afabca6.jpg","comment_is_top":false,"comment_ctime":1560658503,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560658503","product_id":100025301,"comment_content":"蔡老师好！朋友圈消息从重要功能来说<br>1、消息需要发送给多个可见用户<br>2、消息不需要实时响应，接收用户需要时再拉去(消费)<br>3、只需最晚一致性即可<br>至于其他地方使用这个可能会有。所以可以使用消息队列。<br>可能老师就这个例子是为了说明什么时候应该用消息队列，让大家理解和思考。<br>我这有疑问就是实际开发中，<br>1可能是有个一个topic用来交互朋友圈的消息。<br>2消息内容是这条消息的发送者和消息的接受者有哪些人及其他时间和空间附加信息。<br>3整个朋友圈的信息只有一个topic 。<br>这种情况在消息发送和消息处理不在一个模块时是可以的，而如果是在同一个模块，多线程异步处理就可以了。实际生产中不可能说为每个用户建立一个topic，然后一个人的消息发送给朋友圈的每个用户的topic。这是不合理的！<br>所以我感觉消息队列更多的还是模块和模块之间有1对多或者多对多关系而又不关心实时响应时使用。可能说的比较乱啊","like_count":0},{"had_liked":false,"id":103823,"user_name":"dancer","can_delete":false,"product_type":"c1","uid":1019036,"ip_address":"","ucode":"B8D5641A3AC490","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/9c/d48473ab.jpg","comment_is_top":false,"comment_ctime":1560521261,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560521261","product_id":100025301,"comment_content":"朋友圈是比较适合采用pubsub模式的，朋友圈消息经过消费者处理可以push到个个好友。但是像删除好友的操作，就需要更新自己更新自己的朋友圈消息列表，老师有没有比较好的解决方法，感谢！","like_count":0},{"had_liked":false,"id":101019,"user_name":"这个名字居然都有","can_delete":false,"product_type":"c1","uid":1476984,"ip_address":"","ucode":"8972F5BF888261","user_header":"https://static001.geekbang.org/account/avatar/00/16/89/78/311dbb8b.jpg","comment_is_top":false,"comment_ctime":1559701655,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559701655","product_id":100025301,"comment_content":"老师，请问kafka是不是能替代物联网中的mqtt呢","like_count":0},{"had_liked":false,"id":95639,"user_name":"Blakemmmm","can_delete":false,"product_type":"c1","uid":1006809,"ip_address":"","ucode":"2C0BE4465D1B43","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/d9/dc6bd5d4.jpg","comment_is_top":false,"comment_ctime":1558108407,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558108407","product_id":100025301,"comment_content":"老师，对于接收方需要相应，比如配置下发，建议使用什么模式呢？","like_count":0},{"had_liked":false,"id":94820,"user_name":"漫漫越","can_delete":false,"product_type":"c1","uid":1249222,"ip_address":"","ucode":"F9F1E3AC4CF692","user_header":"https://static001.geekbang.org/account/avatar/00/13/0f/c6/cf344f74.jpg","comment_is_top":false,"comment_ctime":1557903632,"is_pvip":false,"replies":[{"id":"33966","content":"谢谢你的提问！在我举的例子里还是会在消息队列里的，消息是否会被删除一般会通过retention period来控制，而不是说发送给了消费者后消息就被删除了。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557953376,"ip_address":"","comment_id":94820,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557903632","product_id":100025301,"comment_content":"对对于发布&#47;订阅模式有个疑惑点，比如生产者发送一个消息到队列中，而消费者有5个，一个消费者消费消息后，这个消息还会再队列里吗？其他生产者还能获得消息吗？，如果不能，那么老师举得关于各部门获得消费数据的例子就不成立了呀","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450221,"discussion_content":"谢谢你的提问！在我举的例子里还是会在消息队列里的，消息是否会被删除一般会通过retention period来控制，而不是说发送给了消费者后消息就被删除了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557953376,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94592,"user_name":"purh","can_delete":false,"product_type":"c1","uid":1138751,"ip_address":"","ucode":"ED69F92440F2A0","user_header":"https://static001.geekbang.org/account/avatar/00/11/60/3f/594c19bc.jpg","comment_is_top":false,"comment_ctime":1557847077,"is_pvip":false,"replies":[{"id":"34208","content":"谢谢你的提问！Flink实战的话我并不是特别了解，不过我觉得你搜索一些Flink DataStream实战指南之类的信息应该可以找到用法。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1558128974,"ip_address":"","comment_id":94592,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557847077","product_id":100025301,"comment_content":"谢谢老师的指导。<br><br>想咨询下，有没有相关资料介绍Flink是如何将Kafka传过来的log抽象成DataStream的","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450123,"discussion_content":"谢谢你的提问！Flink实战的话我并不是特别了解，不过我觉得你搜索一些Flink DataStream实战指南之类的信息应该可以找到用法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558128974,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94346,"user_name":"Steven","can_delete":false,"product_type":"c1","uid":1141382,"ip_address":"","ucode":"BDE4911550BDE6","user_header":"https://static001.geekbang.org/account/avatar/00/11/6a/86/f1876812.jpg","comment_is_top":false,"comment_ctime":1557793783,"is_pvip":false,"replies":[{"id":"33715","content":"谢谢你的提问！消息队列中的消息格式和内容当然是需要事先定义好一个contract的，消息发布者和订阅者都是需要知道这个。一旦定义好了contract之后，消息发布者和订阅者就不需要知道对方的存在了。例如一个消息队列如果是存放实时股票价格消息的，大家知道了这个内容和消息格式之后，发布者也不用知道到底有谁在订阅这些消息，订阅者也不用知道到底是谁在发布这些消息。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557796333,"ip_address":"","comment_id":94346,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557793783","product_id":100025301,"comment_content":"&quot;消息的发布者和消息的订阅者在开发的时候完全不需要事先知道对方的存在&quot;, 这句话怎么理解呢？ 消息的发布者不需要考虑消息的订阅者需要哪些消息么？ 消息的订阅者不需要知道有哪些消息可供订阅么？ ","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450029,"discussion_content":"谢谢你的提问！消息队列中的消息格式和内容当然是需要事先定义好一个contract的，消息发布者和订阅者都是需要知道这个。一旦定义好了contract之后，消息发布者和订阅者就不需要知道对方的存在了。例如一个消息队列如果是存放实时股票价格消息的，大家知道了这个内容和消息格式之后，发布者也不用知道到底有谁在订阅这些消息，订阅者也不用知道到底是谁在发布这些消息。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557796333,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93895,"user_name":"ca01ei","can_delete":false,"product_type":"c1","uid":1001944,"ip_address":"","ucode":"5319718B43FE18","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/d8/71860550.jpg","comment_is_top":false,"comment_ctime":1557655723,"is_pvip":true,"replies":[{"id":"33550","content":"感谢大佬，学习了！看来我也要重新追赶时代的潮流了。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557690139,"ip_address":"","comment_id":93895,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557655723","product_id":100025301,"comment_content":"报告大佬，AWS官方更推荐使用AWS SQS作为消息队列的实现方式，而不是SNS。请参考 https:&#47;&#47;docs.aws.amazon.com&#47;sns&#47;latest&#47;dg&#47;sns-sqs-as-subscriber.html","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449817,"discussion_content":"感谢大佬，学习了！看来我也要重新追赶时代的潮流了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557690139,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93748,"user_name":"回眸望见三生","can_delete":false,"product_type":"c1","uid":1063783,"ip_address":"","ucode":"C926D5A8754A83","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/67/78e0c4ba.jpg","comment_is_top":false,"comment_ctime":1557578334,"is_pvip":false,"replies":[{"id":"33502","content":"谢谢你的留言提问！如果我没有理解错的你问题的话，你是在问如果发送数据之后需要实时知道发送结果应该怎么设计对吧。这种需求一般就不会使用发布&#47;订阅模式了，而是使用RPC服务了。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557642768,"ip_address":"","comment_id":93748,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557578334","product_id":100025301,"comment_content":"老师，您好，如果需要接受当实时返回结果，那应该怎么设计呢？","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449759,"discussion_content":"谢谢你的留言提问！如果我没有理解错的你问题的话，你是在问如果发送数据之后需要实时知道发送结果应该怎么设计对吧。这种需求一般就不会使用发布/订阅模式了，而是使用RPC服务了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557642768,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92644,"user_name":"happiness","can_delete":false,"product_type":"c1","uid":1026587,"ip_address":"","ucode":"C5F25D57C7A1DC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/aa/1b/b43c8519.jpg","comment_is_top":false,"comment_ctime":1557308307,"is_pvip":false,"replies":[{"id":"33138","content":"谢谢你的答案！我也赞同这个做法！","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557337932,"ip_address":"","comment_id":92644,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557308307","product_id":100025301,"comment_content":"需要队列来做更新通知。大致流程是用户发布了新的朋友圈消息后，更新应用发送一条队列消息，用于触关注了发该用户的所有用户朋友圈消息列表更新。","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449344,"discussion_content":"谢谢你的答案！我也赞同这个做法！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557337932,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92321,"user_name":"SpanningWings","can_delete":false,"product_type":"c1","uid":1503174,"ip_address":"","ucode":"A5E98A2626F187","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/dV2JvjoAOHOibxVqExibsBv0ib9jJ9zD8icYaDtFbicUgP0GmRbzmgujvz6pOl6drUcgdvfQXTJpOOY9OL45WrkInbA/132","comment_is_top":false,"comment_ctime":1557231978,"is_pvip":false,"replies":[{"id":"33038","content":"谢谢你的思路分享！","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557262650,"ip_address":"","comment_id":92321,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557231978","product_id":100025301,"comment_content":"朋友圈适合pub-sub模型。前面讨论过朋友圈的一致性模型是最终一致性，朋友没有必要实时获得更新。那么pub-sub模型用来解耦最合适了，A的朋友作为consumer，subscribe A的topic，仅在需要的时候拉取。只是在大规模的环境中，维持亿级的topic，资源分配和均衡问题等需要考虑，但是由于pub-sub模型简化了实现，把一个复杂问题分解为一个简单问题的重复，效果还是不错的。","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449216,"discussion_content":"谢谢你的思路分享！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557262650,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92182,"user_name":"Geek_1c9f7c","can_delete":false,"product_type":"c1","uid":1110419,"ip_address":"","ucode":"9A5611F231C474","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKic4Sia2vW3FdODLrSLzGEXqq2s6wRywMXSWHNdPY9Ge1ecW57pQ29dXRMSSl6aYLpv2uXH2U3Nliaw/132","comment_is_top":false,"comment_ctime":1557196840,"is_pvip":false,"replies":[{"id":"32939","content":"谢谢你的留言！哈哈，N-N的关系pub&#47;sub也是可以支持的，关键还是要看你怎么设计了。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557197916,"ip_address":"","comment_id":92182,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557196840","product_id":100025301,"comment_content":"不合适啊。N-N 这个关系单纯的pub&#47;sub 不合适的","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449171,"discussion_content":"谢谢你的留言！哈哈，N-N的关系pub/sub也是可以支持的，关键还是要看你怎么设计了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557197916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91851,"user_name":"Codelife","can_delete":false,"product_type":"c1","uid":1041421,"ip_address":"","ucode":"10458683978083","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLhMtBwGqqmyhxp5uaDTvvp18iaalQj8qHv6u8rv1FQXGozfl3alPvdPHpEsTWwFPFVOoP6EeKT4bw/132","comment_is_top":false,"comment_ctime":1557120155,"is_pvip":false,"replies":[{"id":"32940","content":"谢谢你的答案！Timeline这个概念还是不错的，如果要优化的话可以考虑是否每次都推送一整个Timeline出去。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557197998,"ip_address":"","comment_id":91851,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557120155","product_id":100025301,"comment_content":"微信朋友圈应该是发布订阅模式，但是订阅的不是消息，而是服务器端维护的timeline；发布的消息经过后台程序处理成timeline，每个用户维护一个timeline，如果用户在线，服务器端主动推送timeline到客户端，否则，用户上线后主动拉timeline至本地","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449058,"discussion_content":"谢谢你的答案！Timeline这个概念还是不错的，如果要优化的话可以考虑是否每次都推送一整个Timeline出去。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557197998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91607,"user_name":"不贰过先生","can_delete":false,"product_type":"c1","uid":1496958,"ip_address":"","ucode":"B208B8DF5FA109","user_header":"https://static001.geekbang.org/account/avatar/00/16/d7/7e/6b6384e9.jpg","comment_is_top":false,"comment_ctime":1557060583,"is_pvip":false,"replies":[{"id":"32950","content":"谢谢你的答案！啊哈哈，从适用场景来说可以的，当然真正设计的时候还要考虑应用场景。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557200739,"ip_address":"","comment_id":91607,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557060583","product_id":100025301,"comment_content":"根据老师所讲的发布&#47;订阅模式适用场景：1:系统需要向大量接收方广播消息；2:无需实时响应；3:最终一致性；故微信如果从这3方面考虑是适合用发布&#47;订阅模式的","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448964,"discussion_content":"谢谢你的答案！啊哈哈，从适用场景来说可以的，当然真正设计的时候还要考虑应用场景。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557200739,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91399,"user_name":"Hunter Liu","can_delete":false,"product_type":"c1","uid":1474463,"ip_address":"","ucode":"BD1FD203A295DC","user_header":"https://static001.geekbang.org/account/avatar/00/16/7f/9f/ca7b20cd.jpg","comment_is_top":false,"comment_ctime":1557025305,"is_pvip":false,"replies":[{"id":"32951","content":"你好，谢谢你的提问！消息队列不会的阻塞的。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557200883,"ip_address":"","comment_id":91399,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557025305","product_id":100025301,"comment_content":"老师好，消息队列会不会有阻塞？","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448906,"discussion_content":"你好，谢谢你的提问！消息队列不会的阻塞的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557200883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91117,"user_name":"挖矿的小戈","can_delete":false,"product_type":"c1","uid":1503917,"ip_address":"","ucode":"2078A85139BD5D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/9chAb6SjxFiapSeicsAsGqzziaNlhX9d5aEt8Z0gUNsZJ9dICaDHqAypGvjv4Bx3PryHnj7OFnOXFOp7Ik21CVXEA/132","comment_is_top":false,"comment_ctime":1556869088,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556869088","product_id":100025301,"comment_content":"盆友圈适合使用pub&#47;sub模式<br>\t原因1：消息发送方需要向多个接收方（n个可以看自己盆友圈的好友）广播消息<br>\t原因2：多消费者组（微信朋友圈数据应该不仅仅只是用于社交，可能还有其他作用吧，所以可能会有多个模块需要用到这份数据）<br>\t原因3：发送方发送消息之后是不需要接收方立即进行响应的（异步），所以用消息队列可以有效起到解耦的作用<br>\t原因4：微信朋友圈对于数据而言，满足最终一致性的","like_count":0},{"had_liked":false,"id":91098,"user_name":"胡鹏","can_delete":false,"product_type":"c1","uid":1326455,"ip_address":"","ucode":"52644EC57FA4DB","user_header":"https://static001.geekbang.org/account/avatar/00/14/3d/77/45e5e06d.jpg","comment_is_top":false,"comment_ctime":1556856288,"is_pvip":false,"replies":[{"id":"32966","content":"谢谢你的答案！","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557205441,"ip_address":"","comment_id":91098,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556856288","product_id":100025301,"comment_content":"我觉得朋友圈消息是发布订阅模式，评论是类似于的接口模式，然后评论返回到客户端是push","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448803,"discussion_content":"谢谢你的答案！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557205441,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91093,"user_name":"君哥聊技术","can_delete":false,"product_type":"c1","uid":1325816,"ip_address":"","ucode":"2C9A22BCE4C79E","user_header":"https://static001.geekbang.org/account/avatar/00/14/3a/f8/c1a939e7.jpg","comment_is_top":false,"comment_ctime":1556853601,"is_pvip":false,"replies":[{"id":"32972","content":"谢谢你的答案！基本我都是赞同的！","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557208023,"ip_address":"","comment_id":91093,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556853601","product_id":100025301,"comment_content":"微信朋友圈用消息队列可以，一方面是异步消息，另一方面有订阅取消的场景<br>互加好友后，默认订阅朋友圈消息，删除好友或者屏蔽朋友圈后取消订阅<br>如果设置了只显示3天内更新，消息队列可以设置3天以上消息消息过期","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448800,"discussion_content":"谢谢你的答案！基本我都是赞同的！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557208023,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91082,"user_name":"hd900","can_delete":false,"product_type":"c1","uid":1057579,"ip_address":"","ucode":"8CCC03F3BA080A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/IjFRWDxE5DUQZ4YJHVjN862xsDjhLObf2kKibFha2vcpNoHdzoqoBsvGibdPSNGZCJI8akhVPecf8vS9xgee2Dng/132","comment_is_top":false,"comment_ctime":1556850716,"is_pvip":false,"replies":[{"id":"32984","content":"谢谢你的答案！分析得不错！","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557212942,"ip_address":"","comment_id":91082,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556850716","product_id":100025301,"comment_content":"朋友圈适合发布&#47;订阅模式<br>发布朋友圈，不需要知道有哪些好友看了这条朋友圈（可能被他人屏蔽或者屏蔽他人看）<br>点赞评论的行为也不需要发布的人实时的知道，只要在下一次进入朋友圈的时候去获取点赞和评论，<br>回复评论的行为也可以在评论人下一次进入的时候再去获取就可以了","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448793,"discussion_content":"谢谢你的答案！分析得不错！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557212942,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]}]}