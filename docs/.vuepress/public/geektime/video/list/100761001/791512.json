{"id":791512,"title":"35｜泛型工具实践（三）：列举","content":"","comments":[{"had_liked":false,"id":395514,"user_name":"Vongola","can_delete":false,"product_type":"c3","uid":1047073,"ip_address":"陕西","ucode":"F2FDAEBC049CBC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fa/21/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1731038741,"is_pvip":false,"replies":[{"id":143574,"content":"其实这个题特别难解。因为TS里面，单个字符和字符字面量都是string，没有办法用长度之类的来区分。如果使用&quot;${infer C}${infer X}&quot;这样的方式来提取（并识别X是never），那么就会碰到C是命名集合（例如string&#47;any）的问题。总之，这个问题的解决难度与直接识别模板是一样的。\n\n你的测试结果中T244并不符合预期~~~当然这还与联合类型的特殊性有关系。总之还有改进的余地呵~","user_name":"作者回复","user_name_real":"作者","uid":1521669,"ctime":1731063053,"ip_address":"江苏","comment_id":395514,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100761001,"comment_content":"感觉还是有些问题：\ntype Primitive = `${number}` | `${bigint}` | `${any}`;\ntype IsNever&lt;T&gt; = [T] extends [never] ? true : false;\ntype isSingleCharacter&lt;S extends string, R = Primitive&gt; = S extends `${infer C}${infer X}` \n    ? IsNever&lt;R extends C ? any : never&gt; extends true ? isSingleCharacter&lt;X&gt; : false\n    : string extends S ? false : true\n\ntype T211 = isSingleCharacter&lt;&#39;abcd&#39;&gt;;\ntype T222 = isSingleCharacter&lt;`ab${`b` extends string ? true : false}cd`&gt;;\ntype T223 = isSingleCharacter&lt;`fasdf${number}123`&gt;;\ntype T233 = isSingleCharacter&lt;`ab${true}cd`&gt;;\ntype T244 = isSingleCharacter&lt;`ab${boolean}cd`&gt;;\ntype T255 = isSingleCharacter&lt;`a13b${any}cd${string}o3o${bigint}xx`&gt;;","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":653538,"discussion_content":"另外，需要注意的是，其实第一行代码中的Primitive会被合并成`${any}`。所以一些基于这个表达式的计算就都会有问题了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1731067802,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":393582,"user_name":"Jack Q","can_delete":false,"product_type":"c3","uid":1160078,"ip_address":"广东","ucode":"A7DBC311884FFA","user_header":"https://static001.geekbang.org/account/avatar/00/11/b3/8e/1c564eb2.jpg","comment_is_top":false,"comment_ctime":1724244015,"is_pvip":false,"replies":[{"id":142994,"content":"在ToFlatTuple&lt;T&gt;里面的`X extends any[]`这里处理得有问题。试试：\n```\ntype BAD_CASE = ToFlatTuple&lt;[&#39;a&#39;, string[], &#39;b&#39;]&gt;;\n```","user_name":"作者回复","user_name_real":"编辑","uid":1521669,"ctime":1725043612,"ip_address":"江苏","comment_id":393582,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100761001,"comment_content":"&#47;&#47; 实现 ToFlatTuple\ntype IsTuple&lt;T&gt; = T extends\n  | readonly []\n  | readonly [any, ...any]\n  | readonly [...any, any]\n  ? true\n  : false\n\ntype ToFlatTuple&lt;T extends any[]&gt; = IsTuple&lt;T&gt; extends true ? T extends [infer X, ...infer Y] ? X extends any[] ? [\n  ...ToFlatTuple&lt;X&gt;,\n  ...ToFlatTuple&lt;Y&gt;\n] : [X, ...ToFlatTuple&lt;Y&gt;] : [] : never;\n\ntype CASE = ToFlatTuple&lt;[1, 2, { a: 3 }]&gt;;&#47;&#47; [1, 2, { a: 3 }]\ntype CASE_1 = ToFlatTuple&lt;[1, [{ a: 2, length: 2, c: [1] }], [3]]&gt;; &#47;&#47; [1, { a:2, length:2, c:[1] }, 3]\ntype CASE_2 = ToFlatTuple&lt;[1,[2],3,[4,[5], [{ a: 6 }, [7]]]]&gt;; &#47;&#47; [1, 2, 3, 4, 5, {a:6}, 7]\ntype CASE_3 = ToFlatTuple&lt;[number, [string]]&gt;; &#47;&#47; [number, string]\ntype CASE_4 = ToFlatTuple&lt;[number[], [string]]&gt;; &#47;&#47; [...number[], string]\ntype CASE_5 = ToFlatTuple&lt;number[]&gt;; &#47;&#47; never: number[] is not tuple\ntype CASE_6 = ToFlatTuple&lt;number[][]&gt;; &#47;&#47; never: number[][] is not tuple","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":650466,"discussion_content":"在ToFlatTuple&lt;T&gt;里面的`X extends any[]`这里处理得有问题。试试：\n```\ntype BAD_CASE = ToFlatTuple&lt;[&#39;a&#39;, string[], &#39;b&#39;]&gt;;\n```","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1725043612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":393581,"user_name":"Jack Q","can_delete":false,"product_type":"c3","uid":1160078,"ip_address":"广东","ucode":"A7DBC311884FFA","user_header":"https://static001.geekbang.org/account/avatar/00/11/b3/8e/1c564eb2.jpg","comment_is_top":false,"comment_ctime":1724243991,"is_pvip":false,"replies":[{"id":142995,"content":"应该可以简化逻辑。要考虑索引签名的情况，除了签名之外，也可以考虑使用Omit、Exclude等泛型工具来简化一般key的逻辑。","user_name":"作者回复","user_name_real":"作者","uid":1521669,"ctime":1725044381,"ip_address":"江苏","comment_id":393581,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100761001,"comment_content":"&#47;&#47; 实现 Assign （类似js中Object.assign(A,B)效果，存在B与A存在相同属性时，B会覆盖A中对应的属性值)\ntype MergeArrayTarget&lt;A,B&gt; = {\n  [key in keyof B as key extends number ? key : never]: B[key]\n} &amp; {\n  [key in keyof A as key extends number ? never : key]: A[key]\n}\n\ntype MergeTupleTarget&lt;A,B&gt; = {\n  [key in keyof B as key extends `${number}` ? key : never]: B[key]\n} &amp; {\n  [key in keyof A as key extends (`${number}` | number) ? never : key]: A[key]\n};\n\ntype MergeTarget&lt;T&gt; = {\n  [K in keyof T]: T[K]\n};\n\ntype NormalMerge&lt;A,B&gt; = \n&#47;&#47; A &amp; B 共有属性\n{\n  [key in Extract&lt;keyof B, keyof A&gt;]: B[key]\n} &amp; \n&#47;&#47; A 中去除 B 上相同的属性\n{\n  [key in keyof A as key extends Extract&lt;keyof B, keyof A&gt; ? never : key]: A[key]\n} &amp;\n&#47;&#47; B 中去除 A 上相同的 string | number 类型属性\n{\n  [key in Exclude&lt;keyof B, keyof A&gt; as key extends string | number ? key : never]: B[key]\n}\n\ntype Assign&lt;A, B&gt; = AnyOrNever&lt;A&gt;  extends true ? A : &#47;&#47; current A is any or never\n    [A] extends [LiteralType] ?  A : &#47;&#47; current A IsLiteral : \n      [A] extends [object] ?  &#47;&#47; charge A is interface\n        AnyOrNever&lt;B&gt; extends true ? A : \n          [B] extends [LiteralType] ? A : \n            [B] extends [object] ? IsArray&lt;B&gt; extends true ? MergeTarget&lt;MergeArrayTarget&lt;A, B&gt;&gt; : \n              IsTuple&lt;B&gt; extends true ? MergeTarget&lt;MergeTupleTarget&lt;A, B&gt;&gt; : \n              MergeTarget&lt;NormalMerge&lt;A,B&gt;&gt;\n    : A \n      : ([A] extends [symbol] ? \n        symbol : &#47;&#47; symbol will return it self\n        never); &#47;&#47; void or undefined (throw error in js)","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":650467,"discussion_content":"应该可以简化逻辑。要考虑索引签名的情况，除了签名之外，也可以考虑使用Omit、Exclude等泛型工具来简化一般key的逻辑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1725044381,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]}]}