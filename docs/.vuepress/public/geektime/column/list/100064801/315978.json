{"id":315978,"title":"05｜如何有效避免长度延展攻击？","content":"<p>你好，我是范学雷。</p><p>上一讲，我们列举了常见的单向散列函数，我们还知道了退役的、遗留的和现行的算法，通过对处理能力限制和算法的性能的讨论，我们对如何选择哈希算法有了更明确的认知。</p><p>还记得我们留了一个小尾巴吗？我们提到了“长度延展攻击”。“长度延展攻击”是怎么一回事？我们为什么要了解它？在单向散列函数的使用上，我们需要注意哪些安全问题？</p><p>这就是我们这一次要解决的事情。</p><h2>什么是长度延展攻击？</h2><p>我们先来看看什么是“长度延展”，这样会有利于你理解“长度延展攻击”。</p><p>现在，假设我们有两段数据，S和M，以及一个单向散列函数h。如果我们要把这两段数据合并起来，并且还要计算合并后的散列值，这就叫做单向散列函数的长度延展。</p><p>不过，问题来了，是S放在前面（h(S|M)），还是M放在前面（h(M|S)）？既然，我们说，散列值是无法预测的，那么，数据编排的顺序有意义吗？</p><p>如果S和M都是公开的信息，顺序是不重要的。可如果S是机密信息，M是公开信息，这两段数据的排列顺序就至关重要了。<strong>如果机密信息放在了前面，就存在“长度延展攻击”的风险</strong>。</p><p>弄清楚了长度延展，长度延展攻击就很好理解了，就是说我们可以利用已知数据的散列值，计算原数据外加一段延展数据后的散列值。也就是说，如果我们知道了h(S|M)，我们就可以计算h(S|M|N)。其中，数据N就是原数据追加的延展数据。</p><!-- [[[read_end]]] --><p>如果S和M都是公开的信息，能够计算延展数据的散列值也没什么紧要的。但是，如果S是机密数据，它的用途一般就和机密有点关系。比如说，因为没有人知道我拥有的机密数据S，所以，当我给定一段公开信息M后，只有我自己才能计算S和M的散列值。</p><p>通过验证S和M的散列值，我就知道一个给定散列值是我计算、派发出去的，还是别人伪造的。</p><p>比如下面的这段数据：</p><pre><code>key_id=44fefa051fc1c61f5e76f27e620f51d5&amp;perms=read&amp;hash_sig=38d39516d896f879d403bd327a932d9e\n</code></pre><p>其中，key_id表示机密数据的编号，perms表示操作权限，hash_sig是使用机密数据key对perms的签名。签名的计算，就是使用单向散列函数：</p><pre><code>sig = h(key|perms)\n</code></pre><p>由于使用了机密数据key，按照设想，这段数据只能由机密数据的持有者生成，然后分发出去，供授权的人使用。机密数据的持有者接收到这样的数据后，重新计算数据签名，然后对比请求数据里的签名。如果两个签名相同，就表示这是一个自己生成的、合法的授权，就可以授予请求数据所要求的权利。</p><p>不过，这个设计就存在“长度延展攻击”的风险。攻击者并不需要知道机密数据，就可以通过一个已知的URL，构造出一个新的合法的URL，从而获得不同的授权。</p><p>伪造的数据看起来像下面的样子：</p><pre><code>key_id=44fefa051fc1c61f5e76f27e620f51d5&amp;perms=read\\0x80\\0x00...\\0x02&amp;delete&amp;hash_sig=a8e6b9704f1da6ae779ad481c4c165a3\n</code></pre><p>在这段伪造的数据中，0x80到0x02之间的数据是数据块补齐数据，而且新添加了删除的权限，并且重新计算、替换了数据签名。</p><p>其中，数据签名需要使用机密数据，而攻击者并不知道机密数据，那么攻击者怎样伪造数据签名呢？要解决这个疑问，我们需要先看看单向散列函数的构造。</p><p>我们在上一讲简单地提到过，一起来重新回顾一下。一个典型的单向散列函数，应该由四个部分组成：数据分组、链接模式、压缩函数和终结函数。</p><p>我们之前着重说了数据分组，我们现在来看看其他的部分：</p><p><img src=\"https://static001.geekbang.org/resource/image/76/63/766c6b81c43b684a0f083c540ea94163.jpeg?wh=2284*1285\" alt=\"\" title=\"单向散列函数处理过程\"></p><ul>\n<li>压缩函数是单向函数，负责着算法的单向性要求；</li>\n<li>终结函数不是单向函数，负责着整理压缩函数的输出，形成散列值的任务；</li>\n<li>链接模式，负责把下一个数据分组和上一个压缩函数的输出结果结合起来，确保算法的雪崩效应能够延续。</li>\n</ul><p>值得一提的是，在MD5，SHA-1，SHA-256和SHA-512的算法设计中，终结函数就是把压缩函数的输出向量排列成一个字节串。知道了字节串，我们也就知道了压缩函数的输出向量。</p><p>压缩函数接收一个数据分组和上一个压缩函数的运算结果。如果知道了上一个压缩函数的运算结果，我们就能够计算下一个分组数据的压缩函数运算结果。<strong>这里，就是出现安全漏洞的地方</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/e6/38/e6339667aff222cbdefa25dc79549638.jpeg?wh=2284*1285\" alt=\"\" title=\"单向散列函数压缩函数示意图\"></p><p>我们把原来的散列值作为压缩函数的一个输入，我们再按照数据补齐规范，去补齐原来数据到数据分组的整数倍，然后加入新的数据，我们就可以计算原数据和扩展数据的散列值了。</p><p><img src=\"https://static001.geekbang.org/resource/image/31/a5/31e2ea275d7e21d49f34294319e31ea5.jpeg?wh=2284*1285\" alt=\"\" title=\"单向散列函数长度延展攻击示意图\"></p><p>新的散列值的计算，不需要知道预先设想的机密数据。但是整个散列值的计算，又的确使用了机密数据。只不过，这个计算过程需要两个部分，第一部分由机密数据的持有者计算，第二部分是攻击者使用第一部分的结果，伪造了一个使用了机密数据的散列值。</p><p>但是，如果我们把数据编排顺序换一下，把公开信息M放在前面，机密信息S放在后面，长度延展攻击就不起作用了。这就是数据编排顺序对数据安全性的影响。</p><h2>怎么有效避免长度延展攻击？</h2><p>一个单向散列函数，只要使用了类似上述的压缩函数和链接模式，都是“长度延展攻击”的可疑对象。我们上一次提到的MD2、MD5、SHA-0、SHA-1、SHA-2，都有长度延展攻击的风险。其中，对于下列算法，长度延展攻击是完全有效的：</p><ul>\n<li>MD2</li>\n<li>MD5</li>\n<li>SHA-0</li>\n<li>SHA-1</li>\n<li>SHA-256</li>\n<li>SHA-512</li>\n</ul><p>对于下列算法，长度延展攻击虽然不是完全有效，但是算法的安全级别显著降低了：</p><ul>\n<li>SHA-224</li>\n<li>SHA-384</li>\n</ul><p>对于下列算法，长度延展攻击没有效果（包括所有的SHA-3算法）：</p><ul>\n<li>SHA-512/224</li>\n<li>SHA-512/256</li>\n<li>SHA-3</li>\n</ul><p>上面这么长的列表，你是不是觉得好多，有点烦？其实，我们讨论长度延展攻击，目的不是让你记住上述的列表。</p><p>我们要从中学会、理解一个实用的经验：<strong>不要单纯使用单向散列函数来处理既包含机密信息、又包含公开信息的数据</strong>。即使我们把机密信息放在最后处理，这种使用方式也不省心。</p><p><strong>如果<strong><strong>我们</strong></strong>需要使用机密数据产生数据的签名，我们应该使用设计好的、经过验证的算法，比如我们后面会讨论的消息验证码（Message Authentication Code）和基于单向散列函数的消息验证码（Hash-based Message Authentication Code）</strong>。</p><p>另外，如果需要设计算法，我们还要理解另外一个实用的原则：<strong>算法要皮实、耐用，不能有意无意地用错了就有安全漏洞</strong>。你看，SHA-1和SHA-2已经很简单、皮实了，用错了场景还是有严重的问题。相比之下，SHA-3同样简单，但是更皮实。</p><p>这和我们在<a href=\"https://time.geekbang.org/column/intro/100019601\">《代码精进之路》</a>的专栏里反复讨论的API要简单、直观、皮实，是一个道理。</p><p>既然我们不能单纯地使用单向散列函数处理混合了机密信息和公开信息的数据。那我们能不能单纯地使用机密信息，或者单纯地使用公开信息？回答这个问题，还要看具体的使用场景。</p><h2>有哪些典型的适用场景？</h2><p>我们已经知道了，单向散列函数是密码学的核心。下面是一些典型的使用单向散列函数的场景：</p><ul>\n<li>校验数据完整性；</li>\n<li>数字签名，和非对称密钥及其算法结合使用；</li>\n<li>消息验证码，和对称密钥及其算法结合使用；</li>\n<li>生成伪随机数；</li>\n<li>生成对称密钥。</li>\n</ul><p>还记得我们在之前，讨论过了怎么使用单向散列函数校验数据完整性。</p><pre><code>输入：\n    1、数据D\n    2、原始数据的散列值H\n    3、计算散列值使用的散列函数\n输出：\n    数据D是不是完整的？\n\n\n运算：\n    1、使用散列函数计算数据D的散列值H';\n    2、对比数据的散列值H和计算获得的散列值，如果两个散列值相同，则数据D是完整的；否则，数据D是修改过的数据。\n</code></pre><p>如果我们单纯地使用单向散列函数校验数据完整性，是要对比数据的散列值的。既然是对比，也就意味着有两个散列值。这时候，我们需要考虑的主要问题就是：给定的散列值有没有被更改？</p><p>散列值的计算是公开的，给定一段数据，谁都可以计算它的散列值。如果数据可以被修改，而且给定的散列值也是修改后的数据的散列值，这个数据完整性校验是没有意义的。</p><p>所以，单纯使用单向散列函数去校验数据的完整性，我们需要确保给定的散列值是不能被修改的，这就是这个使用场景的限制。</p><p>其余的单向散列函数的使用场景，我们后面还会接着讨论。</p><h2>Take Away（今日收获）</h2><p>今天，我们讨论了单向散列函数的长度延展攻击，以及使用单向散列函数需要注意的事项，还列举了典型的单向散列函数使用场景。</p><p>通过今天的讨论，我们要：</p><ul>\n<li>知道单向散列函数存在长度延展攻击；</li>\n<li>了解避免长度延展攻击的办法；</li>\n<li>尽量不要单纯使用单向散列函数来处理包含机密信息的数据。</li>\n</ul><p>另外，今天也是单向散列函数这一模块的最后一讲了。我们也来小结一下这一模块要注意的知识点，拉个清单。</p><p>在这一模块里，我们要掌握下面的基本概念和最佳实践：</p><ol>\n<li><strong>知道单向散列函数的三个特点：正向计算容易，逆向计算困难，散列值长度固定。</strong></li>\n<li><strong>如果散列值不能被恶意修改，单向散列函数可以用来解决数据完整性问题。</strong></li>\n<li><strong>知道有退役的算法、遗留的算法和现行的算法，并且不要使用退役的算法，尽快升级遗留的算法。</strong></li>\n<li><strong>了解密码学算法常用的三个推荐系统，美国的 NIST</strong>、<strong>德国的 BSI和欧洲的 ECRYPT-CSA，要养成定期查看推荐指标的习惯，跟得上密码学的进展。</strong></li>\n<li><strong>知道安全强度，以及现在要使用128位的安全强度的密码学算法，长期系统要考虑使用256位的密码学算法。</strong></li>\n<li><strong>知道要尽量选用现行的、流行的算法。对于单向散列函数来说，它们是SHA-256，SHA-384和 SHA-512。</strong></li>\n<li><strong>尽量不要单纯使用单向散列函数来处理包含机密信息的数据，如果不得已，要尽量避免长度延展攻击。</strong></li>\n</ol><h2>思考题</h2><p>好的，又到了留思考题的时间了。</p><p>今天的思考题是一个拓展题，你要自己去发现单向散列函数的更多适用场景。</p><p>我们一直强调，使用单向散列函数校验数据完整性，需要保证原始的散列值不能被更改。你能不能找到一些场景，可以让我们不用担心原始的散列值被更改，单纯使用单向散列函数就可以校验数据完整性？</p><p>除了我们上面列出来的一些场景，你能不能找出更多的单向散列函数使用场景？比如说，利用散列值长度固定的特点，利用碰撞困难的特点？</p><p>欢迎在留言区留言，记录、讨论你发现的新使用场景。</p><p>好的，今天就这样，我们下次再聊。</p>","neighbors":{"left":{"article_title":"04｜选择哈希算法应该考虑哪些因素？","id":314660},"right":{"article_title":"06｜对称密钥：如何保护私密数据？","id":316802}},"comments":[{"had_liked":false,"id":274267,"user_name":"zzzz","can_delete":false,"product_type":"c1","uid":2336388,"ip_address":"","ucode":"1E84C07366CBB0","user_header":"https://static001.geekbang.org/account/avatar/00/23/a6/84/5ca855d6.jpg","comment_is_top":false,"comment_ctime":1610946733,"is_pvip":false,"replies":[{"id":"99586","content":"1. 机密信息也就是私密信息，是需要保密的信息，比如你的银行账户密码。<br><br>2. 你可以试着理一理计算的过程。按照文中的例子，M是S的持有者派发出去的，并使用hash(S|M)签名。S的持有者并不需要保存M和hash(S|M)签名。也就是说信息的接收者收到的是M和hash(S|M)签名。要想得到授权，信息的接收者还要把这两段信息送回来，也就是M和hash(S|M)签名。然后S的持有者，根据M重新计算hash(S|M)。如果重新计算的签名和接收到的签名是一样的，也就是说，这个数据是S的持有者派发出去的原始数据，没有篡改，可以授权信息的接收者。如果不一样，也就是说，这个数据不是S的持有者派发出去的原始数据，不能授权信息的接收者。<br><br>为什么S|M的拼接方式成立呢？因为信息的接收者可以把M延展成M&#39;（M|N）（延展办法参考正文），然后被M&#39;送给S的持有者，还包括延展后的hash(S|M&#39;)签名。S的持有者重新计算hash(S|M&#39;)签名，然后对比接收到的hash(S|M&#39;)签名。由于hash(S|M&#39;)签名是攻击者通过延展构造的，S的持有者的检验过程不能够识别篡改，因此会认为M&#39;(M|N)就是自己发送出去的数据，授权就被攻破了。<br><br>为什么M|S的拼接方式不成立呢？因为延展攻击的计算链条被打破了。按照延展攻击的计算链条，攻击者可以计算M|S|N的散列值，但是不能计算M|N|S的散列值。如果攻击者把M&#39;（M|N）送给S的持有者，S的持有者计算的是hash(M|N|S)，而不是hash(M|S|N)。攻击当然是不成立的。<br><br>3. 长度延展攻击可以伪造含有机密信息的散列值的计算。具体的破坏性要看具体的场景，文中的例子破坏了授权。比如说，系统本来只允许一个银行账户存取自己的钱，如果攻击成立，授权可以被放大，这个银行账户可以存取任何人的钱，然后再把银行的系统的记录抹平了。","user_name":"作者回复","user_name_real":"范学雷","uid":"1111315","ctime":1610994488,"ip_address":"","comment_id":274267,"utype":1}],"discussion_count":1,"race_medal":0,"score":"48855586989","product_id":100064801,"comment_content":"老师，我可能理解的特别不好，但是找了好多资料依然不能理解这个“长度延展攻击”，反而越找越乱，所以只能来留言问您了，希望您还能回复。<br>1，什么是机密信息啊？机密信息是只有写机密信息的人才能用的机密信息吗？机密信息的作用是什么呢？<br>2，M是一般信息，S表示机密信息，为什么我们额外加的数据N只能在M后面而不能在S后面呢？无论S和M如何组合，不都是信息吗？我们把S和M的任意排列认为是data的话，按照图里说的，hash(hash(data)+自己加的数)=hash(data+自己加的数) 这个公式都是成立的啊，所以S和M如何排序重要吗？<br>3 ，长度延展攻击到底想做什么啊，只是得到hash(data+自己加的数)  有什么作用吗？<br>老师，我看大家都没有问过我说的这些问题，所以可能我理解的特别特别不好。但是我也真的认真看了，也对不懂的地方查了很多很多资料，还是不明白，希望老师能够帮助我，谢谢老师！<br>","like_count":11,"discussions":[{"author":{"id":2042208,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/kY0SHaPHHGlD6qYG51YU8B2k26exKlTyeF1GESQ5hF62SZjB4otsoAlzwLMssmP12fiaNSrTqBx1icibpiab8HENSA/132","nickname":"Geek_2a5671","note":"","ucode":"FE4CF28D1F8E67","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345039,"discussion_content":"老师，我理解了hash(M|N|S)和hash(M|S|N)是不同的，所以S的持有者校验会不通过，而hash(S|M|N)和hash(S|M|N)是一样的，所以校验会通过。我的问题是，既然M是公开的，就是谁都知道通过什么途径去查到，但是这个N却是来得莫名其妙，既然知道了N的来源不可靠，那直接把数据丢掉不就行了，为什么还要计算校验通过呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611644756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":265341,"user_name":"Lorin","can_delete":false,"product_type":"c1","uid":1379988,"ip_address":"","ucode":"7D546F70082DF0","user_header":"https://static001.geekbang.org/account/avatar/00/15/0e/94/4a2bb019.jpg","comment_is_top":false,"comment_ctime":1606873738,"is_pvip":false,"replies":[{"id":"96438","content":"1、补齐规则是公开的，固定的数据长度，它的补齐数据是固定的。只要知道数据长度，得到补齐数据也就没有什么难度了。<br>2、接受者会重新计算散列值，然后对比攻击者附带的散列值，而不是保存一份散列值在本地。重新的计算散列值和附带的散列值是不是相同，才是要做的对比。","user_name":"作者回复","user_name_real":"范学雷","uid":"1111315","ctime":1606881815,"ip_address":"","comment_id":265341,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14491775626","product_id":100064801,"comment_content":"老师，我有两个问题：<br>1、长度延展攻击中，补齐数据是怎么获取到的啊？<br>2、长度延展攻击后，原散列值和扩展数据的散列值肯定不一样，这样的话，接收者都已经知道收到的数据与原散列值不一致了，这个时候长度延展攻击有什么意义呢？","like_count":3,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510890,"discussion_content":"1、补齐规则是公开的，固定的数据长度，它的补齐数据是固定的。只要知道数据长度，得到补齐数据也就没有什么难度了。\n2、接受者会重新计算散列值，然后对比攻击者附带的散列值，而不是保存一份散列值在本地。重新的计算散列值和附带的散列值是不是相同，才是要做的对比。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606881815,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":305950,"user_name":"Reol","can_delete":false,"product_type":"c1","uid":2071180,"ip_address":"","ucode":"D79C96E9912671","user_header":"https://static001.geekbang.org/account/avatar/00/1f/9a/8c/aeadf040.jpg","comment_is_top":false,"comment_ctime":1628241125,"is_pvip":false,"replies":[{"id":"110818","content":"密码学的世界里，使用公开的加密算法要比使用不公开的算法更安全，没有必要使用不公开的加密算法。 请参考专栏里相关的讨论。","user_name":"作者回复","user_name_real":"范学雷","uid":"1111315","ctime":1628447712,"ip_address":"","comment_id":305950,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10218175717","product_id":100064801,"comment_content":"老师我还有个小问题，发送者是否要公开自己的加密算法？<br><br>按理说没有公开加密算法的必要，那么接收者不知道加密算法什么都做不了，不知道分组大小和压缩函数的固定处理位数，无法反推每个分组的输出向量，也不知道补充数据的格式。最重要的是没有算法无法自己计算延长数据的散列值。","like_count":2,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524571,"discussion_content":"密码学的世界里，使用公开的加密算法要比使用不公开的算法更安全，没有必要使用不公开的加密算法。 请参考专栏里相关的讨论。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628447712,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":275044,"user_name":"咱是吓大的","can_delete":false,"product_type":"c1","uid":1292324,"ip_address":"","ucode":"A47C6DA5C00C6F","user_header":"https://static001.geekbang.org/account/avatar/00/13/b8/24/039f84a2.jpg","comment_is_top":false,"comment_ctime":1611284446,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10201219038","product_id":100064801,"comment_content":"对长度延展攻击，可否理解为：如果把机密信息比作正宗猪肉，最后的散列值比作火腿肠，那么延展数据可以认为是其它不知道什么东西的黑暗肉类，反正最后的产品是一个味道。","like_count":2},{"had_liked":false,"id":332186,"user_name":"单芮","can_delete":false,"product_type":"c1","uid":2843253,"ip_address":"","ucode":"5AEA9201E84B45","user_header":"","comment_is_top":false,"comment_ctime":1643090100,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5938057396","product_id":100064801,"comment_content":"问题1：以SHA-256为例，分组数据块中不是有64位用来表示输入数据的长度吗<br>长度延展攻击后，每个数据块中的数据长度表示部分不需要修改吗<br>问题2：SHA-256为什么以64位来表示输入数据的长度，有些不明白，有什么计算公式吗","like_count":1},{"had_liked":false,"id":305943,"user_name":"Reol","can_delete":false,"product_type":"c1","uid":2071180,"ip_address":"","ucode":"D79C96E9912671","user_header":"https://static001.geekbang.org/account/avatar/00/1f/9a/8c/aeadf040.jpg","comment_is_top":false,"comment_ctime":1628240117,"is_pvip":false,"replies":[{"id":"110819","content":"我没有理解#1中拼接的意思。延展攻击中，延展后的数据是(M | N). 如果我们把M记做M&#39;= M | N, 那么h(S|M&#39;) = h(S|M|N).<br><br>#2，N是构造的数据，已经包含了补充数据了。如果你想要单独标记补充数据和不弃数据，也没有问题。N = m + n.  会不会觉得奇怪这个问题，你可以参考文中罗列出来的适用场景，看看有哪些场景会奇怪，那些不会奇怪，那些没能力奇怪。","user_name":"作者回复","user_name_real":"范学雷","uid":"1111315","ctime":1628448329,"ip_address":"","comment_id":305943,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5923207413","product_id":100064801,"comment_content":"老师我有两个小问题，求解答！！！！！！<br><br>假设：S私密，M公开，N延长<br><br>1. 关于长度延展的理解：对于散列值 h(S|M)，因为可以根据终结函数的顺序输出，来推断出每个原文分组的压缩函数的输出。所以延长实际上的操作是，推断提取出散列值 h(S|M) 中最后一个分组的压缩函数输出向量，将其作为初始向量来运算散列值 h(N)，然后直接拼接两个散列值 h(S|M) + h(N) = h(S|M|N)，结果就是消息S|M|N的散列值 ，这样理解对吗？<br><br>2. 按照我对专栏原文还有配图的理解，在延长攻击中原文 S|M 后面要加上补充数据 (假设为m)，然后再加上N和其补充数据 n。这样得出的 h(S|M|N) 实际上是 h(S|M|m|N) 对应的原文应该是 S|M|m|N 而不是 S|M|N，所以验证时是把原文 S|M|Bm|N 和  h(S|M|m|N) 发给S的持有者来验证。但这样S的持有者获得的原文里面M和N中间多了一段意义不明的m，S的持有者不会觉得奇怪吗？","like_count":1,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524567,"discussion_content":"我没有理解#1中拼接的意思。延展攻击中，延展后的数据是(M | N). 如果我们把M记做M&amp;#39;= M | N, 那么h(S|M&amp;#39;) = h(S|M|N).\n\n#2，N是构造的数据，已经包含了补充数据了。如果你想要单独标记补充数据和不弃数据，也没有问题。N = m + n.  会不会觉得奇怪这个问题，你可以参考文中罗列出来的适用场景，看看有哪些场景会奇怪，那些不会奇怪，那些没能力奇怪。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628448329,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":265383,"user_name":"qinsi","can_delete":false,"product_type":"c1","uid":1667175,"ip_address":"","ucode":"090D9C4068FF12","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","comment_is_top":false,"comment_ctime":1606883824,"is_pvip":true,"replies":[{"id":"96458","content":"很多场景下，机密数据的长度都是固定的。另外，即使不知道长度，也可以一个字节一个字节的猜，不过是猜几十还是几百&#47;千&#47;万次的问题。猜中一次，以后就知道了。","user_name":"作者回复","user_name_real":"范学雷","uid":"1111315","ctime":1606891556,"ip_address":"","comment_id":265383,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5901851120","product_id":100064801,"comment_content":"疑问：补齐数据应该是由数据长度决定的，那么在不知道机密数据 S 的长度的情况下，攻击者要如何知道该补多长的数据？跟 S 在前或在后有关吗？","like_count":1,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510912,"discussion_content":"很多场景下，机密数据的长度都是固定的。另外，即使不知道长度，也可以一个字节一个字节的猜，不过是猜几十还是几百/千/万次的问题。猜中一次，以后就知道了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606891556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238114,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/62/c350c09e.jpg","nickname":"最爱小雅的树为🐾","note":"","ucode":"3B1FECD4D75E64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547027,"discussion_content":"终于找到了我要的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642499684,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":361398,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"浙江","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1667463365,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1667463365","product_id":100064801,"comment_content":"单纯使用单向散列函数去校验数据的完整性，我们需要确保给定的散列值是不能被修改的，这就是这个使用场景的限制。--记下来","like_count":0},{"had_liked":false,"id":361397,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"浙江","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1667463235,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1667463235","product_id":100064801,"comment_content":"学习打卡","like_count":0},{"had_liked":false,"id":329890,"user_name":"Ankhetsin","can_delete":false,"product_type":"c1","uid":1028469,"ip_address":"","ucode":"3CA233D08D4A72","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b1/75/60a71bbd.jpg","comment_is_top":false,"comment_ctime":1641629462,"is_pvip":false,"replies":[{"id":"120378","content":" 如果时机合适的话，我会找个时间聊聊SM。","user_name":"作者回复","user_name_real":"编辑","uid":"1111315","ctime":1641970916,"ip_address":"","comment_id":329890,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1641629462","product_id":100064801,"comment_content":"老师，md6和国密sm系列算法怎么样？","like_count":0,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545472,"discussion_content":" 如果时机合适的话，我会找个时间聊聊SM。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641970917,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313445,"user_name":"漂泊的小飘","can_delete":false,"product_type":"c1","uid":1222578,"ip_address":"","ucode":"25C0CA4887D8AD","user_header":"https://static001.geekbang.org/account/avatar/00/12/a7/b2/274a4192.jpg","comment_is_top":false,"comment_ctime":1632445899,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632445899","product_id":100064801,"comment_content":"sha-3因为没有原文长度补齐所以不会被攻击？那sha-3有什么特别的补齐方式吗？没有长度补齐不就是10000，不也能被攻击吗","like_count":0},{"had_liked":false,"id":293823,"user_name":"木头发芽","can_delete":false,"product_type":"c1","uid":1419723,"ip_address":"","ucode":"657B381C5DA963","user_header":"https://static001.geekbang.org/account/avatar/00/15/a9/cb/a431bde5.jpg","comment_is_top":false,"comment_ctime":1621565808,"is_pvip":false,"replies":[{"id":"106661","content":"规则不会泄漏吗？","user_name":"作者回复","user_name_real":"范学雷","uid":"1111315","ctime":1621750515,"ip_address":"","comment_id":293823,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1621565808","product_id":100064801,"comment_content":"引用问题:<br>&quot;散列值的计算是公开的，给定一段数据，谁都可以计算它的散列值。如果数据可以被修改，而且给定的散列值也是修改后的数据的散列值，这个数据完整性校验是没有意义的。&quot;<br><br>方案:<br>给数据+盐后计算散列值, 这个盐是一定规则生成不在网络上传输的,如果攻击者替换了数据和散列值,但因为不知道盐值,跟验证者生成的散列值不一致,就知道数据被串改,<br>该方案是否可行?","like_count":0,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520381,"discussion_content":"规则不会泄漏吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621750515,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":286030,"user_name":"bugs","can_delete":false,"product_type":"c1","uid":1147357,"ip_address":"","ucode":"5944A8A4E11EC7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqy3lXp1RcSlabmQJKxULT6s5r6TOtLxRO5JB8BDBUmsjw0gPqfmCHcXwuqVaUg3t9Iianib6ASAsVQ/132","comment_is_top":false,"comment_ctime":1617112961,"is_pvip":true,"replies":[{"id":"103914","content":"没明白这个结论怎么来的。","user_name":"作者回复","user_name_real":"范学雷","uid":"1111315","ctime":1617260485,"ip_address":"","comment_id":286030,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1617112961","product_id":100064801,"comment_content":"老师好，<br>散列算法的数据分组是连序性的吗？如果是的话，链接模式能保证靠前的数据块修改后的雪崩效应，不能保证靠后数据块修改的雪崩效应。","like_count":0,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517849,"discussion_content":"没明白这个结论怎么来的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617260485,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2071180,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/9a/8c/aeadf040.jpg","nickname":"Reol","note":"","ucode":"D79C96E9912671","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387537,"discussion_content":"1）雪崩效应（Avalanche Effect）：指输入数据的微小变换，就会导致输出数据的巨大变化（密码学算法的常见特点）\n2）严格雪崩效应：如果输入数据的一位反转，输出数据的每一位都有50%的概率发生变化（雪崩效应的形式化指标，也常用于衡量均匀分布）\n3）链接模式：负责把下一个数据分组和上一个压缩函数的输出结合起来，确保算法的雪崩效应能够延续\n\n链接模式每组数据输出受到上一组输出的影响，前面的组影响后面，后面的组影响不了前面，所以满足不了 严格雪崩效应 ，但是是可以满足 雪崩效应，文中表述个人认为没有问题，这位同学可能没记混定义了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628237215,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":274268,"user_name":"zzzz","can_delete":false,"product_type":"c1","uid":2336388,"ip_address":"","ucode":"1E84C07366CBB0","user_header":"https://static001.geekbang.org/account/avatar/00/23/a6/84/5ca855d6.jpg","comment_is_top":false,"comment_ctime":1610947294,"is_pvip":false,"replies":[{"id":"99587","content":"稍微有点差别，下属没有机密信息，是没有办法验证这个散列值的。可以稍微修改一下。这个长官有很多部门，每一个部门都有不同的命令，命令太多长官又记不住。就给每个部分传达命令M，附带上命令M的签名，这样可以防止下属更改命令。M的签名使用机密信息，这样可以防止下属修改签名。下属要执行命令时，就来长官这里或者长官的秘书这里要求资源。这时候，长官或者秘书就要检验原来下达的命令是不是准确的，要检验M是不是被篡改过，检验的办法，就是重新计算M的签名（使用机密信息的散列值）。","user_name":"作者回复","user_name_real":"范学雷","uid":"1111315","ctime":1610995082,"ip_address":"","comment_id":274268,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1610947294","product_id":100064801,"comment_content":"老师，追写一下我自己的思路，如果前一条问题太多太···不知如何回答，老师看看我对上面的问题的理解对不对：<br>首先，长度拓展攻击的目的就是，根据已知的hash(A),得到hash(A+B)，其中，B是自己随意加的数据<br>机密数据S就相当于一个身份，有机密数据的人就想相当于有这个身份，，这个人传递的信息就是hash(S+M)，其中S表示机密数据身份，M表示他想传递的信息。比如这个人是一个长官，S就是他的长官身份，M就是他传递的命令，这个hash值就传给他的下属。但是现在有一个人想要冒充长官给下属下发命令N，于是他就把自己想要追加的命令放在原来的S+M后面，构成S+M+N。下属们收到hash之后，因为这个hash依然是有S的，所以下属们以为这个就是他们长官的命令，所以连M和N这两个命令都执行了。所以长度有效攻击的作用就是冒充身份，让自己的hash里带上S<br>对吗老师","like_count":0,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513956,"discussion_content":"稍微有点差别，下属没有机密信息，是没有办法验证这个散列值的。可以稍微修改一下。这个长官有很多部门，每一个部门都有不同的命令，命令太多长官又记不住。就给每个部分传达命令M，附带上命令M的签名，这样可以防止下属更改命令。M的签名使用机密信息，这样可以防止下属修改签名。下属要执行命令时，就来长官这里或者长官的秘书这里要求资源。这时候，长官或者秘书就要检验原来下达的命令是不是准确的，要检验M是不是被篡改过，检验的办法，就是重新计算M的签名（使用机密信息的散列值）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610995082,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":272919,"user_name":"LXX","can_delete":false,"product_type":"c1","uid":2349160,"ip_address":"","ucode":"6BBE9967406E0F","user_header":"https://static001.geekbang.org/account/avatar/00/23/d8/68/89770b8b.jpg","comment_is_top":false,"comment_ctime":1610355116,"is_pvip":false,"replies":[{"id":"98939","content":"你把“原数据和扩展数据”看做一个数据。数据有了，是不是就可以计算这个数据的散列值了？如果你知道怎么计算A的散列值，当然也就知道了怎么计算C(C=A+B)的散列值。","user_name":"作者回复","user_name_real":"范学雷","uid":"1111315","ctime":1610395568,"ip_address":"","comment_id":272919,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1610355116","product_id":100064801,"comment_content":"老师好，把原来的散列值作为压缩函数的一个输入，再按照数据补齐规范，去补齐原来数据到数据分组的整数倍，然后加入新的数据，我们就可以计算原数据和扩展数据的散列值了，这块不是很理解，可以详细讲述一下吗？我不是很清楚为什么通过这个方式就可以计算原数据和扩展数据的散列值，或者有什么文章可以推荐借鉴理解的。谢谢老师<br>","like_count":0,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513427,"discussion_content":"你把“原数据和扩展数据”看做一个数据。数据有了，是不是就可以计算这个数据的散列值了？如果你知道怎么计算A的散列值，当然也就知道了怎么计算C(C=A+B)的散列值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610395568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2349160,"avatar":"https://static001.geekbang.org/account/avatar/00/23/d8/68/89770b8b.jpg","nickname":"LXX","note":"","ucode":"6BBE9967406E0F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341421,"discussion_content":"老师好，那如何知道源数据使用的单向散列值呢？是一个个尝试吗？谢谢老师。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610418006,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":266945,"user_name":"wrzgeek","can_delete":false,"product_type":"c1","uid":1031589,"ip_address":"","ucode":"69C4980053E388","user_header":"","comment_is_top":false,"comment_ctime":1607531552,"is_pvip":false,"replies":[{"id":"96932","content":"是的。","user_name":"作者回复","user_name_real":"范学雷","uid":"1111315","ctime":1607581911,"ip_address":"","comment_id":266945,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1607531552","product_id":100064801,"comment_content":"是不是可以这样理解，无论是(M|S)还是(S|M)结构，延展数据N都是要紧跟着M的，也就是延展后的数据结构是(M|N|S)或者(S|M|N)，这样的话，对于S在后边的结构，就无法进行延展攻击了。","like_count":0,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511456,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607581911,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":265442,"user_name":"Litt1eQ","can_delete":false,"product_type":"c1","uid":2083695,"ip_address":"","ucode":"D80D0B14F3B312","user_header":"https://static001.geekbang.org/account/avatar/00/1f/cb/6f/b6693f43.jpg","comment_is_top":false,"comment_ctime":1606898854,"is_pvip":true,"replies":[{"id":"96512","content":"密码以散列值的情况保存，是单向散列函数一个常用的场景，还比如Unix&#47;Linux操作系统中的影子密码。这个场景特殊的地方在于，这个散列值是本地存储、本地计算的，并不需要传递散列值。所以，攻击者没有机会既更改明文（密码），又更改散列值，除非本地被植入了恶意程序。","user_name":"作者回复","user_name_real":"范学雷","uid":"1111315","ctime":1606928780,"ip_address":"","comment_id":265442,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1606898854","product_id":100064801,"comment_content":"单纯使用单向散列函数就可以直接校验数据的完整性，我想到了存储在数据库中的密码，通常情况下存到数据库中的密码是不会直接存储明文的，一般都是把用户的原始密码经过散列之后保存，这样我们校验用户输入的密码经过散列之后和数据库存贮的散列值进行比较，感觉并没有考虑到数据库当中的散列值被修改的情况。<br>我记得在区块链中，好像是利用散列计算的困难性，找到一个某个满足要求的散列值。","like_count":0,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510929,"discussion_content":"密码以散列值的情况保存，是单向散列函数一个常用的场景，还比如Unix/Linux操作系统中的影子密码。这个场景特殊的地方在于，这个散列值是本地存储、本地计算的，并不需要传递散列值。所以，攻击者没有机会既更改明文（密码），又更改散列值，除非本地被植入了恶意程序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606928780,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":265417,"user_name":"qinsi","can_delete":false,"product_type":"c1","uid":1667175,"ip_address":"","ucode":"090D9C4068FF12","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","comment_is_top":false,"comment_ctime":1606893316,"is_pvip":true,"replies":[{"id":"96513","content":"你这个理解是对的，无论S在前或者在后补齐数据都可以得到。只是，当S放在最后的时候，也就是说，S是单向散列函数输入数据的最后一段数据，这样，就不存在延展数据了。你按照专栏里延展攻击的图，画一画S放在后面的情况，就会明白了。","user_name":"作者回复","user_name_real":"范学雷","uid":"1111315","ctime":1606929326,"ip_address":"","comment_id":265417,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1606893316","product_id":100064801,"comment_content":"感谢解答。看来猜测数据长度是需要一个Oracle存在的（比如服务端返回请求是否合法）。下一个问题是，假设已知数据的长度，那么无论机密数据 S 在前或在后，应该都能得到补齐数据才对，为什么说放在后面的时候攻击就不起作用了呢？","like_count":0,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510924,"discussion_content":"你这个理解是对的，无论S在前或者在后补齐数据都可以得到。只是，当S放在最后的时候，也就是说，S是单向散列函数输入数据的最后一段数据，这样，就不存在延展数据了。你按照专栏里延展攻击的图，画一画S放在后面的情况，就会明白了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606929326,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1667175,"avatar":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","nickname":"qinsi","note":"","ucode":"090D9C4068FF12","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331765,"discussion_content":"emm...我看了图还不是很明白，不过回头又看了下伪造的请求就明白了。因为伪造的请求是对M进行延展，如果M不是在最后就没法补齐数据了。感谢老师解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606972119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":265370,"user_name":"天天有吃的","can_delete":false,"product_type":"c1","uid":1604355,"ip_address":"","ucode":"6267FE8E68DEE5","user_header":"https://static001.geekbang.org/account/avatar/00/18/7b/03/03583011.jpg","comment_is_top":false,"comment_ctime":1606879355,"is_pvip":false,"replies":[{"id":"96471","content":"都是很好的问题。你看看我有没有回答明白，如果还有问题，咱们继续留言。 一个留言一个问题比较好，我可以用碎片时间回复。<br><br>问题1：机密数据不是放在那个步骤后面，是放在输入数据的最后。如果你有两端数据，S机密，M一般，计算M+S，不要计算S+M的散列值。这就是说的机密数据放后面。<br><br>问题2：知道了 h(M|S)也可以知道h(M|S|N)，这句话是没毛病。可是机密数据的持有者计算的时候，是把S放在后面，所以不会去计算h(M|S|N). 如果数据A|B|C|D, \b也是把ABCD看作M，计算H(ABCD|S)。<br><br>问题3: 被授权者拿这个签名，就是到这是机密信息持有者生成的数据了。因为，不持有私密信息，没有办法生成这样的散列值。<br><br>问题4：输出向量指的是压缩函数的输出结果，用来当终结函数的输入。<br><br>问题5： 散列值能为伪造，最轻的说明秘密信息没起到作用，就没有使用机密信息的意义了。如果是用作签名，就是身份伪造，就可以冒充身份诈骗了。<br><br>问题6：相信我，有了代码糊涂的更快。我建议你拿纸笔画一画，画完了，就清楚很多了。<br><br>问题7：这个专栏应该是最最基础的，最容易看懂的了，如果我能够表达清楚的话。你可以看看开篇词里介绍的《应用密码学》，我认为是最值得读的就是这一本。学习密码学算法细节的话，可能需要的数学知识就多了，学习用的话，初中数学加上逻辑清晰就够了。","user_name":"作者回复","user_name_real":"范学雷","uid":"1111315","ctime":1606892700,"ip_address":"","comment_id":265370,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1606879355","product_id":100064801,"comment_content":"小白追更打卡，不熟悉的感觉越来越多了，麻烦老师了.. <br>问题1：机密数据放后面是哪个步骤的后面，是终结函数前的h5吗？<br><br>为题2：知道了 h(M|S)也可以知道h(M|S|N)，还是放在最后即h(M|N|S)？<br><br>问题3：比如我是机密数据持有者，是给有权限的人分发S、M的散列值（散列值就是签名）；然后我能收到一段数据（就是需要重新对比签名的），数据跟这个签名有什么关系呢（或者说被授权者拿这个签名干什么）？<br><br>问题4：终结函数就是把压缩函数的输出向量排列成一个字节串 =&gt; 知道了字节串，我们也就知道了压缩函数的输出向量，这里的输出向量指的是什么&#47;有什么作用？<br><br>问题5：就算是伪造了一个散列值（即长度延展攻击），有什么危害呢？可以想到的是被授权方用延展后的签名作用于数据上，持密者就无法验证签名相同了？<br><br>问题6：理论性比较多，有点没法跟自己接触过的代码结合起来想了，有一种懂一点又不懂自己懂了什么的感觉=_=|，有没有代码跑一跑看一看？<br><br>问题7：如果比较基础的书籍或者课程推荐的吗（或者学习路径，比如需要数学什么...代码知识什么..），专栏两天一讲，还是有空闲的时间补补基础的？<br>","like_count":0,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510906,"discussion_content":"都是很好的问题。你看看我有没有回答明白，如果还有问题，咱们继续留言。 一个留言一个问题比较好，我可以用碎片时间回复。\n\n问题1：机密数据不是放在那个步骤后面，是放在输入数据的最后。如果你有两端数据，S机密，M一般，计算M+S，不要计算S+M的散列值。这就是说的机密数据放后面。\n\n问题2：知道了 h(M|S)也可以知道h(M|S|N)，这句话是没毛病。可是机密数据的持有者计算的时候，是把S放在后面，所以不会去计算h(M|S|N). 如果数据A|B|C|D, \b也是把ABCD看作M，计算H(ABCD|S)。\n\n问题3: 被授权者拿这个签名，就是到这是机密信息持有者生成的数据了。因为，不持有私密信息，没有办法生成这样的散列值。\n\n问题4：输出向量指的是压缩函数的输出结果，用来当终结函数的输入。\n\n问题5： 散列值能为伪造，最轻的说明秘密信息没起到作用，就没有使用机密信息的意义了。如果是用作签名，就是身份伪造，就可以冒充身份诈骗了。\n\n问题6：相信我，有了代码糊涂的更快。我建议你拿纸笔画一画，画完了，就清楚很多了。\n\n问题7：这个专栏应该是最最基础的，最容易看懂的了，如果我能够表达清楚的话。你可以看看开篇词里介绍的《应用密码学》，我认为是最值得读的就是这一本。学习密码学算法细节的话，可能需要的数学知识就多了，学习用的话，初中数学加上逻辑清晰就够了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606892700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1604355,"avatar":"https://static001.geekbang.org/account/avatar/00/18/7b/03/03583011.jpg","nickname":"天天有吃的","note":"","ucode":"6267FE8E68DEE5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331545,"discussion_content":"明白了，回答都很清晰！下次我提问会注意","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606897732,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":265346,"user_name":"孜孜","can_delete":false,"product_type":"c1","uid":1018203,"ip_address":"","ucode":"7EF4FB644357CE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/89/5b/d8f78c1e.jpg","comment_is_top":false,"comment_ctime":1606874847,"is_pvip":true,"replies":[{"id":"96439","content":"这个有意思，有人说单向函数的散列值是不可压缩的（也就是均匀分布的另外一个说法），这当然是最牛的压缩。但是，我们通常谈到压缩，往往有对应的解压，能从压缩过的数据复原原数据，这个单向散列函数没有。","user_name":"作者回复","user_name_real":"范学雷","uid":"1111315","ctime":1606882136,"ip_address":"","comment_id":265346,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1606874847","product_id":100064801,"comment_content":"突然有个脑洞，既然散列函数在计算量足够大的情况下可逆。那么在不考虑计算量的情况下，散列函数是不是时间上最牛的压缩算法? 或许即使可逆，也可能逆出无数种原数据，也无法得到真实的原数据?","like_count":0,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510894,"discussion_content":"这个有意思，有人说单向函数的散列值是不可压缩的（也就是均匀分布的另外一个说法），这当然是最牛的压缩。但是，我们通常谈到压缩，往往有对应的解压，能从压缩过的数据复原原数据，这个单向散列函数没有。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606882136,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":265331,"user_name":"sugar","can_delete":false,"product_type":"c1","uid":1167046,"ip_address":"","ucode":"454538FF253B5F","user_header":"https://static001.geekbang.org/account/avatar/00/11/ce/c6/958212b5.jpg","comment_is_top":false,"comment_ctime":1606871102,"is_pvip":false,"replies":[{"id":"96437","content":"加密算法的强度，要比枚举所有的密钥的可能性小很多。关于加密是怎么知道是不是明文的问题，这是一个好问题！后面的加密部分，我们会讲这个问题的。","user_name":"作者回复","user_name_real":"范学雷","uid":"1111315","ctime":1606881574,"ip_address":"","comment_id":265331,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1606871102","product_id":100064801,"comment_content":"老师 我有个关于密码学具体的应用场景下的问题，想听听您的看法。假设现在有一个文件，使用aes算法 进行了对称加密，想解密需要知道密钥才行。而我们这几节课探讨的加密算法的强度，我理解其实就是用程序进行枚举所有可能的密钥。但我想问，一个文件被加密之后，暴破时又是怎么知道每一次尝试时 得到的文件明文 真的是文件的真实内容呢？ ","like_count":0,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510882,"discussion_content":"加密算法的强度，要比枚举所有的密钥的可能性小很多。关于加密是怎么知道是不是明文的问题，这是一个好问题！后面的加密部分，我们会讲这个问题的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606881574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1667175,"avatar":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","nickname":"qinsi","note":"","ucode":"090D9C4068FF12","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331475,"discussion_content":"我猜需要对文件的内容有些先验的知识。比如你知道文件本身是个文本文件，那么如果解密出来的文件是二进制文件就说明密钥不对。或者比如是图片文件压缩文件之类的，那么看文件头是不是符合格式就知道了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606880423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1667175,"avatar":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","nickname":"qinsi","note":"","ucode":"090D9C4068FF12","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":331679,"discussion_content":"这是一个办法，通常我们在程序里要做输入数据有效性检验，可以规避掉一部分解密失败的错误。加密技术本身解决不了这个问题，需要结合单向散列函数使用。换个说法，这个问题是数据完整性问题+数据机密性问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606929672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":331475,"ip_address":""},"score":331679,"extra":""}]}]}]}