{"id":80531,"title":"39 | 自增主键为什么不是连续的？","content":"<p>在<a href=\"https://time.geekbang.org/column/article/69236\">第4篇文章</a>中，我们提到过自增主键，由于自增主键可以让主键索引尽量地保持递增顺序插入，避免了页分裂，因此索引更紧凑。</p><p>之前我见过有的业务设计依赖于自增主键的连续性，也就是说，这个设计假设自增主键是连续的。但实际上，这样的假设是错的，因为自增主键不能保证连续递增。</p><p>今天这篇文章，我们就来说说这个问题，看看什么情况下自增主键会出现 “空洞”？</p><p>为了便于说明，我们创建一个表t，其中id是自增主键字段、c是唯一索引。</p><pre><code>CREATE TABLE `t` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `c` int(11) DEFAULT NULL,\n  `d` int(11) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `c` (`c`)\n) ENGINE=InnoDB;\n</code></pre><h1>自增值保存在哪儿？</h1><p>在这个空表t里面执行insert into t values(null, 1, 1);插入一行数据，再执行show create table命令，就可以看到如下图所示的结果：</p><p><img src=\"https://static001.geekbang.org/resource/image/cb/ff/cb2637cada0201b18650f56875e94fff.png?wh=1430*542\" alt=\"\"></p><center><span class=\"reference\">图1 自动生成的AUTO_INCREMENT值</span></center><p>可以看到，表定义里面出现了一个AUTO_INCREMENT=2，表示下一次插入数据时，如果需要自动生成自增值，会生成id=2。</p><p>其实，这个输出结果容易引起这样的误解：自增值是保存在表结构定义里的。实际上，<strong>表的结构定义存放在后缀名为.frm的文件中，但是并不会保存自增值。</strong></p><p>不同的引擎对于自增值的保存策略不同。</p><ul>\n<li>MyISAM引擎的自增值保存在数据文件中。</li>\n<li>InnoDB引擎的自增值，其实是保存在了内存里，并且到了MySQL 8.0版本后，才有了“自增值持久化”的能力，也就是才实现了“如果发生重启，表的自增值可以恢复为MySQL重启前的值”，具体情况是：\n<ul>\n<li>在MySQL 5.7及之前的版本，自增值保存在内存里，并没有持久化。每次重启后，第一次打开表的时候，都会去找自增值的最大值max(id)，然后将max(id)+1作为这个表当前的自增值。﻿<br>\n举例来说，如果一个表当前数据行里最大的id是10，AUTO_INCREMENT=11。这时候，我们删除id=10的行，AUTO_INCREMENT还是11。但如果马上重启实例，重启后这个表的AUTO_INCREMENT就会变成10。﻿<br>\n也就是说，MySQL重启可能会修改一个表的AUTO_INCREMENT的值。</li>\n<li>在MySQL 8.0版本，将自增值的变更记录在了redo log中，重启的时候依靠redo log恢复重启之前的值。</li>\n</ul>\n</li>\n</ul><!-- [[[read_end]]] --><p>理解了MySQL对自增值的保存策略以后，我们再看看自增值修改机制。</p><h1>自增值修改机制</h1><p>在MySQL里面，如果字段id被定义为AUTO_INCREMENT，在插入一行数据的时候，自增值的行为如下：</p><ol>\n<li>\n<p>如果插入数据时id字段指定为0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT值填到自增字段；</p>\n</li>\n<li>\n<p>如果插入数据时id字段指定了具体的值，就直接使用语句里指定的值。</p>\n</li>\n</ol><p>根据要插入的值和当前自增值的大小关系，自增值的变更结果也会有所不同。假设，某次要插入的值是X，当前的自增值是Y。</p><ol>\n<li>\n<p>如果X&lt;Y，那么这个表的自增值不变；</p>\n</li>\n<li>\n<p>如果X≥Y，就需要把当前自增值修改为新的自增值。</p>\n</li>\n</ol><p><strong>新的自增值生成算法是</strong>：从auto_increment_offset开始，以auto_increment_increment为步长，持续叠加，直到找到第一个大于X的值，作为新的自增值。</p><p>其中，auto_increment_offset 和 auto_increment_increment是两个系统参数，分别用来表示自增的初始值和步长，默认值都是1。</p><blockquote>\n<p>备注：在一些场景下，使用的就不全是默认值。比如，双M的主备结构里要求双写的时候，我们就可能会设置成auto_increment_increment=2，让一个库的自增id都是奇数，另一个库的自增id都是偶数，避免两个库生成的主键发生冲突。</p>\n</blockquote><p>当auto_increment_offset和auto_increment_increment都是1的时候，新的自增值生成逻辑很简单，就是：</p><ol>\n<li>\n<p>如果准备插入的值&gt;=当前自增值，新的自增值就是“准备插入的值+1”；</p>\n</li>\n<li>\n<p>否则，自增值不变。</p>\n</li>\n</ol><p>这就引入了我们文章开头提到的问题，在这两个参数都设置为1的时候，自增主键id却不能保证是连续的，这是什么原因呢？</p><h1>自增值的修改时机</h1><p>要回答这个问题，我们就要看一下自增值的修改时机。</p><p>假设，表t里面已经有了(1,1,1)这条记录，这时我再执行一条插入数据命令：</p><pre><code>insert into t values(null, 1, 1); \n</code></pre><p>这个语句的执行流程就是：</p><ol>\n<li>\n<p>执行器调用InnoDB引擎接口写入一行，传入的这一行的值是(0,1,1);</p>\n</li>\n<li>\n<p>InnoDB发现用户没有指定自增id的值，获取表t当前的自增值2；</p>\n</li>\n<li>\n<p>将传入的行的值改成(2,1,1);</p>\n</li>\n<li>\n<p>将表的自增值改成3；</p>\n</li>\n<li>\n<p>继续执行插入数据操作，由于已经存在c=1的记录，所以报Duplicate key error，语句返回。</p>\n</li>\n</ol><p>对应的执行流程图如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/f1/d3/f16d89a6e7ad6e2cde13b32bb2292dd3.jpg?wh=1142*1522\" alt=\"\"></p><center><span class=\"reference\">图2 insert(null, 1,1)唯一键冲突</span></center><p>可以看到，这个表的自增值改成3，是在真正执行插入数据的操作之前。这个语句真正执行的时候，因为碰到唯一键c冲突，所以id=2这一行并没有插入成功，但也没有将自增值再改回去。</p><p>所以，在这之后，再插入新的数据行时，拿到的自增id就是3。也就是说，出现了自增主键不连续的情况。</p><p>如图3所示就是完整的演示结果。</p><p><img src=\"https://static001.geekbang.org/resource/image/77/26/77b87820b649692a555f19b562d5d926.png?wh=659*641\" alt=\"\"></p><center><span class=\"reference\">图3 一个自增主键id不连续的复现步骤</span></center><p>可以看到，这个操作序列复现了一个自增主键id不连续的现场(没有id=2的行）。可见，<strong>唯一键冲突是导致自增主键id不连续的第一种原因。</strong></p><p>同样地，事务<strong>回滚也会产生类似的现象，这就是第二种原因。</strong></p><p>下面这个语句序列就可以构造不连续的自增id，你可以自己验证一下。</p><pre><code>insert into t values(null,1,1);\nbegin;\ninsert into t values(null,2,2);\nrollback;\ninsert into t values(null,2,2);\n//插入的行是(3,2,2)\n</code></pre><p>你可能会问，为什么在出现唯一键冲突或者回滚的时候，MySQL没有把表t的自增值改回去呢？如果把表t的当前自增值从3改回2，再插入新数据的时候，不就可以生成id=2的一行数据了吗？</p><p>其实，MySQL这么设计是为了提升性能。接下来，我就跟你分析一下这个设计思路，看看<strong>自增值为什么不能回退。</strong></p><p>假设有两个并行执行的事务，在申请自增值的时候，为了避免两个事务申请到相同的自增id，肯定要加锁，然后顺序申请。</p><ol>\n<li>\n<p>假设事务A申请到了id=2， 事务B申请到id=3，那么这时候表t的自增值是4，之后继续执行。</p>\n</li>\n<li>\n<p>事务B正确提交了，但事务A出现了唯一键冲突。</p>\n</li>\n<li>\n<p>如果允许事务A把自增id回退，也就是把表t的当前自增值改回2，那么就会出现这样的情况：表里面已经有id=3的行，而当前的自增id值是2。</p>\n</li>\n<li>\n<p>接下来，继续执行的其他事务就会申请到id=2，然后再申请到id=3。这时，就会出现插入语句报错“主键冲突”。</p>\n</li>\n</ol><p>而为了解决这个主键冲突，有两种方法：</p><ol>\n<li>\n<p>每次申请id之前，先判断表里面是否已经存在这个id。如果存在，就跳过这个id。但是，这个方法的成本很高。因为，本来申请id是一个很快的操作，现在还要再去主键索引树上判断id是否存在。</p>\n</li>\n<li>\n<p>把自增id的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增id。这个方法的问题，就是锁的粒度太大，系统并发能力大大下降。</p>\n</li>\n</ol><p>可见，这两个方法都会导致性能问题。造成这些麻烦的罪魁祸首，就是我们假设的这个“允许自增id回退”的前提导致的。</p><p>因此，InnoDB放弃了这个设计，语句执行失败也不回退自增id。也正是因为这样，所以才只保证了自增id是递增的，但不保证是连续的。</p><h1>自增锁的优化</h1><p>可以看到，自增id锁并不是一个事务锁，而是每次申请完就马上释放，以便允许别的事务再申请。其实，在MySQL 5.1版本之前，并不是这样的。</p><p>接下来，我会先给你介绍下自增锁设计的历史，这样有助于你分析接下来的一个问题。</p><p>在MySQL 5.0版本的时候，自增锁的范围是语句级别。也就是说，如果一个语句申请了一个表自增锁，这个锁会等语句执行结束以后才释放。显然，这样设计会影响并发度。</p><p>MySQL 5.1.22版本引入了一个新策略，新增参数innodb_autoinc_lock_mode，默认值是1。</p><ol>\n<li>\n<p>这个参数的值被设置为0时，表示采用之前MySQL 5.0版本的策略，即语句执行结束后才释放锁；</p>\n</li>\n<li>\n<p>这个参数的值被设置为1时：</p>\n<ul>\n<li>普通insert语句，自增锁在申请之后就马上释放；</li>\n<li>类似insert … select这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；</li>\n</ul>\n</li>\n<li>\n<p>这个参数的值被设置为2时，所有的申请自增主键的动作都是申请后就释放锁。</p>\n</li>\n</ol><p>你一定有两个疑问：<strong>为什么默认设置下，insert … select 要使用语句级的锁？为什么这个参数的默认值不是2？</strong></p><p>答案是，这么设计还是为了数据的一致性。</p><p>我们一起来看一下这个场景：</p><p><img src=\"https://static001.geekbang.org/resource/image/e0/df/e0a69e151277de54a8262657e4ec89df.png?wh=933*278\" alt=\"\"></p><center><span class=\"reference\">图4 批量插入数据的自增锁</span></center><p>在这个例子里，我往表t1中插入了4行数据，然后创建了一个相同结构的表t2，然后两个session同时执行向表t2中插入数据的操作。</p><p>你可以设想一下，如果session B是申请了自增值以后马上就释放自增锁，那么就可能出现这样的情况：</p><ul>\n<li>session B先插入了两个记录，(1,1,1)、(2,2,2)；</li>\n<li>然后，session A来申请自增id得到id=3，插入了（3,5,5)；</li>\n<li>之后，session B继续执行，插入两条记录(4,3,3)、 (5,4,4)。</li>\n</ul><p>你可能会说，这也没关系吧，毕竟session B的语义本身就没有要求表t2的所有行的数据都跟session A相同。</p><p>是的，从数据逻辑上看是对的。但是，如果我们现在的binlog_format=statement，你可以设想下，binlog会怎么记录呢？</p><p>由于两个session是同时执行插入数据命令的，所以binlog里面对表t2的更新日志只有两种情况：要么先记session A的，要么先记session B的。</p><p>但不论是哪一种，这个binlog拿去从库执行，或者用来恢复临时实例，备库和临时实例里面，session B这个语句执行出来，生成的结果里面，id都是连续的。这时，这个库就发生了数据不一致。</p><p>你可以分析一下，出现这个问题的原因是什么？</p><p>其实，这是因为原库session B的insert语句，生成的id不连续。这个不连续的id，用statement格式的binlog来串行执行，是执行不出来的。</p><p>而要解决这个问题，有两种思路：</p><ol>\n<li>\n<p>一种思路是，让原库的批量插入数据语句，固定生成连续的id值。所以，自增锁直到语句执行结束才释放，就是为了达到这个目的。</p>\n</li>\n<li>\n<p>另一种思路是，在binlog里面把插入数据的操作都如实记录进来，到备库执行的时候，不再依赖于自增主键去生成。这种情况，其实就是innodb_autoinc_lock_mode设置为2，同时binlog_format设置为row。</p>\n</li>\n</ol><p>因此，<strong>在生产上，尤其是有insert … select这种批量插入数据的场景时，从并发插入数据性能的角度考虑，我建议你这样设置：innodb_autoinc_lock_mode=2 ，并且 binlog_format=row</strong>.这样做，既能提升并发性，又不会出现数据一致性问题。</p><p>需要注意的是，我这里说的<strong>批量插入数据，包含的语句类型是insert … select、replace … select和load data语句。</strong></p><p>但是，在普通的insert语句里面包含多个value值的情况下，即使innodb_autoinc_lock_mode设置为1，也不会等语句执行完成才释放锁。因为这类语句在申请自增id的时候，是可以精确计算出需要多少个id的，然后一次性申请，申请完成后锁就可以释放了。</p><p>也就是说，批量插入数据的语句，之所以需要这么设置，是因为“不知道要预先申请多少个id”。</p><p>既然预先不知道要申请多少个自增id，那么一种直接的想法就是需要一个时申请一个。但如果一个select … insert语句要插入10万行数据，按照这个逻辑的话就要申请10万次。显然，这种申请自增id的策略，在大批量插入数据的情况下，不但速度慢，还会影响并发插入的性能。</p><p>因此，对于批量插入数据的语句，MySQL有一个批量申请自增id的策略：</p><ol>\n<li>\n<p>语句执行过程中，第一次申请自增id，会分配1个；</p>\n</li>\n<li>\n<p>1个用完以后，这个语句第二次申请自增id，会分配2个；</p>\n</li>\n<li>\n<p>2个用完以后，还是这个语句，第三次申请自增id，会分配4个；</p>\n</li>\n<li>\n<p>依此类推，同一个语句去申请自增id，每次申请到的自增id个数都是上一次的两倍。</p>\n</li>\n</ol><p>举个例子，我们一起看看下面的这个语句序列：</p><pre><code>insert into t values(null, 1,1);\ninsert into t values(null, 2,2);\ninsert into t values(null, 3,3);\ninsert into t values(null, 4,4);\ncreate table t2 like t;\ninsert into t2(c,d) select c,d from t;\ninsert into t2 values(null, 5,5);\n</code></pre><p>insert…select，实际上往表t2中插入了4行数据。但是，这四行数据是分三次申请的自增id，第一次申请到了id=1，第二次被分配了id=2和id=3， 第三次被分配到id=4到id=7。</p><p>由于这条语句实际只用上了4个id，所以id=5到id=7就被浪费掉了。之后，再执行insert into t2 values(null, 5,5)，实际上插入的数据就是（8,5,5)。</p><p><strong>这是主键id出现自增id不连续的第三种原因。</strong></p><h1>小结</h1><p>今天，我们从“自增主键为什么会出现不连续的值”这个问题开始，首先讨论了自增值的存储。</p><p>在MyISAM引擎里面，自增值是被写在数据文件上的。而在InnoDB中，自增值是被记录在内存的。MySQL直到8.0版本，才给InnoDB表的自增值加上了持久化的能力，确保重启前后一个表的自增值不变。</p><p>然后，我和你分享了在一个语句执行过程中，自增值改变的时机，分析了为什么MySQL在事务回滚的时候不能回收自增id。</p><p>MySQL 5.1.22版本开始引入的参数innodb_autoinc_lock_mode，控制了自增值申请时的锁范围。从并发性能的角度考虑，我建议你将其设置为2，同时将binlog_format设置为row。我在前面的文章中其实多次提到，binlog_format设置为row，是很有必要的。今天的例子给这个结论多了一个理由。</p><p>最后，我给你留一个思考题吧。</p><p>在最后一个例子中，执行insert into t2(c,d) select c,d from t;这个语句的时候，如果隔离级别是可重复读（repeatable read），binlog_format=statement。这个语句会对表t的所有记录和间隙加锁。</p><p>你觉得为什么需要这么做呢？</p><p>你可以把你的思考和分析写在评论区，我会在下一篇文章和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p><h1>上期问题时间</h1><p>上期的问题是，如果你维护的MySQL系统里有内存表，怎么避免内存表突然丢数据，然后导致主备同步停止的情况。</p><p>我们假设的是主库暂时不能修改引擎，那么就把备库的内存表引擎先都改成InnoDB。对于每个内存表，执行</p><pre><code>set sql_log_bin=off;\nalter table tbl_name engine=innodb;\n</code></pre><p>这样就能避免备库重启的时候，数据丢失的问题。</p><p>由于主库重启后，会往binlog里面写“delete from tbl_name”，这个命令传到备库，备库的同名的表数据也会被清空。</p><p>因此，就不会出现主备同步停止的问题。</p><p>如果由于主库异常重启，触发了HA，这时候我们之前修改过引擎的备库变成了主库。而原来的主库变成了新备库，在新备库上把所有的内存表（这时候表里没数据）都改成InnoDB表。</p><p>所以，如果我们不能直接修改主库上的表引擎，可以配置一个自动巡检的工具，在备库上发现内存表就把引擎改了。</p><p>同时，跟业务开发同学约定好建表规则，避免创建新的内存表。</p><p>评论区留言点赞板：</p><blockquote>\n<p>大家在春节期间还坚持看专栏，并且深入地思考和回复，给大家点赞。<br>\n@长杰 同学提到的将数据保存到InnoDB表用来持久化，也是一个方法。不过，我还是建议釜底抽薪，直接修改备库的内存表的引擎。<br>\n@老杨同志 提到的是主库异常重启的场景，这时候是不会报主备不一致的，因为主库重启的时候写了delete from tbl_name，主备的内存表都清空了。</p>\n</blockquote><p></p>","comments":[{"had_liked":false,"id":66078,"user_name":"长杰","can_delete":false,"product_type":"c1","uid":1312212,"ip_address":"","ucode":"DD52C9494005F7","user_header":"https://static001.geekbang.org/account/avatar/00/14/05/d4/e06bf86d.jpg","comment_is_top":false,"comment_ctime":1549871877,"is_pvip":false,"replies":[{"id":"23413","content":"👍 这是一个典型的场景","user_name":"作者回复","comment_id":66078,"uid":"1264162","ip_address":"","utype":1,"ctime":1549879446,"user_name_real":"林晓斌"}],"discussion_count":4,"race_medal":0,"score":"426751634181","product_id":100020801,"comment_content":"在最后一个例子中，执行 insert into t2(c,d) select c,d from t; 这个语句的时候，如果隔离级别是可重复读（repeatable read），binlog_format=statement。这个语句会对表 t 的所有记录和间隙加锁。<br>你觉得为什么需要这么做呢？<br>假如原库不对t表所有记录和间隙加锁，如果有其他事物新增数据并先与这个批量操作提交，由于事物的隔离级别是可重复读，t2是看不到新增的数据的。但是记录的binlog是statement格式，备库或基于binlog恢复的临时库，t2会看到新增的数据，出现数据不一致的情况。","like_count":100,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438694,"discussion_content":"👍 这是一个典型的场景","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549879446,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2448277,"avatar":"https://static001.geekbang.org/account/avatar/00/25/5b/95/462890c6.jpg","nickname":"叶涛","note":"","ucode":"B45348979BE159","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372820,"discussion_content":"有没有这种情况呢：\n1. t表的先新增一条数据, 然后执行 insert into t2(c,d) select c,d from t，t表正常加锁, \n2. 但如果binlog记录的是 insert into t2...select... t 和 insert t...\n3. 在从库执行的时候先执行了insert into t2 select....，此时t新增的数据的sql还没有执行，这样是不是也是主备数据不一致了 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620470144,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1575571,"avatar":"https://static001.geekbang.org/account/avatar/00/18/0a/93/a189ec16.jpg","nickname":"Eric","note":"","ucode":"7EB511C384BD7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2448277,"avatar":"https://static001.geekbang.org/account/avatar/00/25/5b/95/462890c6.jpg","nickname":"叶涛","note":"","ucode":"B45348979BE159","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":405252,"discussion_content":"binlog按顺序执行的。。如果连顺序执行都保证不了，那就全乱套了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634540947,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":372820,"ip_address":""},"score":405252,"extra":""},{"author":{"id":1986739,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/50/b3/9269cd59.jpg","nickname":"LWD","note":"","ucode":"DDA444DB113C01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2448277,"avatar":"https://static001.geekbang.org/account/avatar/00/25/5b/95/462890c6.jpg","nickname":"叶涛","note":"","ucode":"B45348979BE159","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588441,"discussion_content":"你说的这种情况rr事务级别会通过间隙锁保证出现冲突的事务执行顺序和事务提交顺序一致；","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1663761586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":372820,"ip_address":"广东"},"score":588441,"extra":""}]}]},{"had_liked":false,"id":121399,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1565134327,"is_pvip":false,"replies":[{"id":"44650","content":"👍","user_name":"作者回复","comment_id":121399,"uid":"1264162","ip_address":"","utype":1,"ctime":1565157626,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"229198401015","product_id":100020801,"comment_content":"最喜欢这样的文章，以为比较简单和熟悉，也能打开一扇窗，让人看到一个不同的世界，并且无比丰富多彩。<br>在什么场景下自增主键可能不连续？<br>1：唯一键冲突<br>2：事务回滚<br>3：自增主键的批量申请<br>深层次原因是，不判断自增主键是否已存在和减少加锁的时间范围和粒度-&gt;为了更高的性能-&gt;自增主键不能回退-&gt;自增主键不连续<br>自增主键是怎么做的唯一性的？<br>自增值加1，自增锁控制并发<br>自增主键的生成性能如何？<br>这个需要测试一下，数据库的自增主键也用做生成唯一数字，作为其他单号，比如：并发量小的订单号，性能可能一般。<br>自增主键有最大值嘛？如果有，到了咋弄？<br>最大值应该有，因为数字总有个范围，到了当做字符串的一部分，然后再自增拼接上另一部分，貌似也可以。<br>自增主键的作用？保存机制？修改机制？<br>作用：让主键索引尽量地保持递增顺序插入，避免页分裂，使索引更紧凑。<br>保存机制：不同的存储引擎不一样。<br>MyISAM 引擎的自增值保存在数据文件中。<br>InnoDB 引擎的自增值，先是保存在了内存里，到了 MySQL 8.0 版本后，才有了“自增值持久化”的能力，放在了redolog里。<br>修改机制：<br>在 MySQL 里面，如果字段 id 被定义为 AUTO_INCREMENT，在插入一行数据的时候，自增值的行为如下：<br>1：如果插入数据时 id 字段指定为 0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT 值填到自增字段；<br>2：如果插入数据时 id 字段指定了具体的值，就直接使用语句里指定的值。<br><br>根据要插入的值和当前自增值的大小关系，自增值的变更结果也会有所不同。假设，某次要插入的值是 X，当前的自增值是 Y。<br>1：如果 X&lt;Y，那么这个表的自增值不变；<br>2：如果 X≥Y，就需要把当前自增值修改为新的自增值。","like_count":54,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461775,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565157626,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101090,"user_name":"Nomius","can_delete":false,"product_type":"c1","uid":1239274,"ip_address":"","ucode":"68FBF07180BCA9","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/ea/a4568138.jpg","comment_is_top":false,"comment_ctime":1559714814,"is_pvip":false,"replies":[{"id":"36730","content":"1. 是的<br>2. 我觉得最初的一个原因是，由于以前（8.0版本前）自增主键值是不持久化的，只放在内存里面。每次重启后，重新打开表时，需要计算“自增字段里面的最大值”，然后加1，作为当前的autoincrement的值。<br>如果没有索引，算这个值就要做全表扫描，性能可能很差，影响访问表的速度。<br>好问题。不过这个只是我个人猜测，也可能还有别的原因。😆","user_name":"作者回复","comment_id":101090,"uid":"1264162","ip_address":"","utype":1,"ctime":1560041332,"user_name_real":"林晓斌"}],"discussion_count":2,"race_medal":0,"score":"212013112318","product_id":100020801,"comment_content":"不知道老师还关不关注. <br>(1)问一下为什么一张表上面只能有一个自增的字段?  (这个大概能从文章中分析出来,因为autoincrement是定义在表结构中,如果有多个的话实现自增的时候逻辑太复杂了)<br>(2)为什么自增的字段上面必须要有索引?  ","like_count":50,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452800,"discussion_content":"1. 是的\n2. 我觉得最初的一个原因是，由于以前（8.0版本前）自增主键值是不持久化的，只放在内存里面。每次重启后，重新打开表时，需要计算“自增字段里面的最大值”，然后加1，作为当前的autoincrement的值。\n如果没有索引，算这个值就要做全表扫描，性能可能很差，影响访问表的速度。\n好问题。不过这个只是我个人猜测，也可能还有别的原因。😆","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560041332,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188023,"avatar":"https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg","nickname":"Eternal","note":"","ucode":"EA6FE7CC98F740","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":399048,"discussion_content":"一个表为什么不能有连个自增长字段","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632895119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":67050,"user_name":"帽子掉了","can_delete":false,"product_type":"c1","uid":1174781,"ip_address":"","ucode":"344892D6136346","user_header":"https://static001.geekbang.org/account/avatar/00/11/ec/fd/bad2abf5.jpg","comment_is_top":false,"comment_ctime":1550062158,"is_pvip":false,"replies":[{"id":"23800","content":"好问题，不会<br>因为binlog在记录这种带自增值的语句之前，会在前面多一句，用于指定“接下来这个语句要需要的 自增ID值是多少”，而这个值，是在主库上这一行插入成功后对应的自增值，所以是一致的","user_name":"作者回复","comment_id":67050,"uid":"1264162","ip_address":"","utype":1,"ctime":1550127517,"user_name_real":"林晓斌"}],"discussion_count":8,"race_medal":0,"score":"169053786702","product_id":100020801,"comment_content":"老师您好，我有一个时序问题，想请教一下。<br>从这篇文章的介绍来看，获取自增id和写binlog是有先后顺序的。<br>那么在binlog为statement的情况下。<br>语句A先获取id=1，然后B获取id=2，接着B提交，写binlog，再A写binlog。<br>这个时候如果binlog重放，是不是会发生B的id为1，而A的id为2的不一致的情况？","like_count":40,"discussions":[{"author":{"id":1514623,"avatar":"https://static001.geekbang.org/account/avatar/00/17/1c/7f/8b421ebb.jpg","nickname":"向前","note":"","ucode":"4DD08BF0CD6B78","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60874,"discussion_content":"在binlog_format=STATEMENT 时，对于&#34;simple insert&#34; 语句binlog中会记录该语句插入的自增i值。如下：SET INSERT_ID=4/*!*/;。对于&#34;Bulk insert&#34;binlog中会记录该语句用到的第一个自增值","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1574761570,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1189225,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIlRVTQ1mpTLY34BAje4xRY0PFSJk6J1su2jicrtEQASP3DakQ7lQkWZNADoh8mLibwATLJB9EMrIVQ/132","nickname":"Z","note":"","ucode":"C199B14177A951","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1514623,"avatar":"https://static001.geekbang.org/account/avatar/00/17/1c/7f/8b421ebb.jpg","nickname":"向前","note":"","ucode":"4DD08BF0CD6B78","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304659,"discussion_content":"这样的话，图4场景，从库消费的时候会不会产生主键冲突？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599636704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":60874,"ip_address":""},"score":304659,"extra":""},{"author":{"id":1526355,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4a/53/063f9d17.jpg","nickname":"moonfox","note":"","ucode":"902BFF40EFA9FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1189225,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIlRVTQ1mpTLY34BAje4xRY0PFSJk6J1su2jicrtEQASP3DakQ7lQkWZNADoh8mLibwATLJB9EMrIVQ/132","nickname":"Z","note":"","ucode":"C199B14177A951","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":335293,"discussion_content":"那个是假设，假设批量插入时，id被打撒，产生了不连续的情况。真实情况是批量插入时，id都是连续的，又同时记录了insert的初始值，所以无论是先执行谁，都可以保证主备一致的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608142509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":304659,"ip_address":""},"score":335293,"extra":""}]},{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439029,"discussion_content":"好问题，不会\n因为binlog在记录这种带自增值的语句之前，会在前面多一句，用于指定“接下来这个语句要需要的 自增ID值是多少”，而这个值，是在主库上这一行插入成功后对应的自增值，所以是一致的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1550127517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1476588,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJayib1ZcRfOaoLsdsWZokiaO5tLAdC4uNAicQJRIVXrz9fIchib7QwXibnRrsJaoh5TUlia7faUf36g8Bw/132","nickname":"明月","note":"","ucode":"D3C649B954A519","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46012,"discussion_content":"我也不理解 前面不是说会不一致 所以采用记录操作记录和设置binlog的格式为rowid来避免吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573110992,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1210699,"avatar":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","nickname":"-W.LI-","note":"","ucode":"3556786538664F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":20067,"discussion_content":" 没明白啊，这个没问题的话，insert select ，+statement为啥就会出现主键主备不一致呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569253531,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1306086,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ed/e6/320eb55f.jpg","nickname":"Lomy","note":"","ucode":"2D1B9EC8565034","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1210699,"avatar":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","nickname":"-W.LI-","note":"","ucode":"3556786538664F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368725,"discussion_content":"因为statement记录的是原始语句，并不会记录主库分配的自增值，备库在应用时会自行重新分配自增值吧，所以才说要加锁批量获取连续的自增ID，如果是ROW模式就会记录主库分配的自增值","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1618818892,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":20067,"ip_address":""},"score":368725,"extra":""},{"author":{"id":1657304,"avatar":"https://static001.geekbang.org/account/avatar/00/19/49/d8/533b1968.jpg","nickname":"王泽","note":"","ucode":"726A5F21BE7390","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1210699,"avatar":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","nickname":"-W.LI-","note":"","ucode":"3556786538664F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540041,"discussion_content":"评论这里说的是怕重放 binlog 时的顺序不一致导致 id 不一致，文章里说的是主库的事务连续拿到的自增 id 跟备库同一个事务重放 binlog 时连续拿到的自增 id 不一致","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639925495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":20067,"ip_address":""},"score":540041,"extra":""}]}]},{"had_liked":false,"id":66571,"user_name":"aliang","can_delete":false,"product_type":"c1","uid":1149502,"ip_address":"","ucode":"B36B94B362477F","user_header":"https://static001.geekbang.org/account/avatar/00/11/8a/3e/30c05bce.jpg","comment_is_top":false,"comment_ctime":1549960480,"is_pvip":true,"replies":[{"id":"23582","content":"“（时间+业务+机器+序列，bigint类型，实际长度有17位，其中序列保存在内存中，每次递增，主键值不连续）。” ----bigint就是8位，这个你需要确定一下。如果是8位的还好，如果是17位的字符串，就比较耗费空间；<br><br>（1）如果“序列”是递增的，还是不能直接用来体现业务逻辑吧？ 创建有业务意义的字段索引估计还是省不了的 ？<br>（2）mysql确实做不到“插入之前就先算好接下来的id是多少”，一般都是insert执行完成后，再执行select last_insert_id<br> (3) 先insert a再update b再update a，确实看上去比较奇怪，不过感觉这个逻辑应该是可以优化的，不应该作为“主键选择”的一个依据。你可否脱敏一下，把模拟的表结构和业务逻辑说下，看看是不是可以优化的。<br><br>总之，按照你说的“时间+业务+机器+序列”这种模式，有点像用uuid，主要的问题还是，如果这个表的索引多，占用的空间比较大","user_name":"作者回复","comment_id":66571,"uid":"1264162","ip_address":"","utype":1,"ctime":1549979118,"user_name_real":"林晓斌"}],"discussion_count":4,"race_medal":0,"score":"74564404512","product_id":100020801,"comment_content":"老师，我们这边有的开发不喜欢用mysql自带的主键自增功能，而是在程序中控制主键（时间+业务+机器+序列，bigint类型，实际长度有17位，其中序列保存在内存中，每次递增，主键值不连续）。理由是<br>（1）通过这样的主键可以直接定位数据，减少索引（2）如果自增，必须先存数据得到主键才可继续下面的程序，如果自己计算主键，可以在入库前进行异步处理<br>（3）a表要insert得到主键，然后处理b表，然后根据条件还要update a表。如果程序自己控制，就不用先insert a表，数据可以在内存中，直到最后一次提交。（对于a表，本来是insert+update，最后只是一条insert，少一次数据库操作）<br>我想请问的是：<br>（1）针对理由1，是否可以用组合索引替代？<br>（2）针对理由2，是否mysql自身的主键自增分配逻辑就已经能实现了？<br>（3）针对理由3，主键更长意味着更大的索引（主键索引和普通索引），你觉得怎样做会更好呢","like_count":18,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438840,"discussion_content":"“（时间+业务+机器+序列，bigint类型，实际长度有17位，其中序列保存在内存中，每次递增，主键值不连续）。” ----bigint就是8位，这个你需要确定一下。如果是8位的还好，如果是17位的字符串，就比较耗费空间；\n\n（1）如果“序列”是递增的，还是不能直接用来体现业务逻辑吧？ 创建有业务意义的字段索引估计还是省不了的 ？\n（2）mysql确实做不到“插入之前就先算好接下来的id是多少”，一般都是insert执行完成后，再执行select last_insert_id\n (3) 先insert a再update b再update a，确实看上去比较奇怪，不过感觉这个逻辑应该是可以优化的，不应该作为“主键选择”的一个依据。你可否脱敏一下，把模拟的表结构和业务逻辑说下，看看是不是可以优化的。\n\n总之，按照你说的“时间+业务+机器+序列”这种模式，有点像用uuid，主要的问题还是，如果这个表的索引多，占用的空间比较大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549979118,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1325297,"avatar":"https://static001.geekbang.org/account/avatar/00/14/38/f1/996a070d.jpg","nickname":"LW","note":"","ucode":"89820332658E98","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":205851,"discussion_content":"最烦用uuid做主键的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1584350413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1320727,"avatar":"https://static001.geekbang.org/account/avatar/00/14/27/17/be14b93e.jpg","nickname":"Mike","note":"","ucode":"7172D06E3BA75B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2943,"discussion_content":"我们业务直接用uuid char(32)的，我表示想死了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564051725,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1986739,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/50/b3/9269cd59.jpg","nickname":"LWD","note":"","ucode":"DDA444DB113C01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1320727,"avatar":"https://static001.geekbang.org/account/avatar/00/14/27/17/be14b93e.jpg","nickname":"Mike","note":"","ucode":"7172D06E3BA75B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588461,"discussion_content":"用uuid还不如直接用雪花。单调自增还保证空间唯一","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663770630,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2943,"ip_address":"广东"},"score":588461,"extra":""}]}]},{"had_liked":false,"id":67469,"user_name":"Ryoma","can_delete":false,"product_type":"c1","uid":1130590,"ip_address":"","ucode":"7F692369239692","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/5e/b8fada94.jpg","comment_is_top":false,"comment_ctime":1550154083,"is_pvip":true,"replies":[{"id":"24001","content":"👍 大势所趋😆","user_name":"作者回复","comment_id":67469,"uid":"1264162","ip_address":"","utype":1,"ctime":1550298513,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":2,"score":"70269630819","product_id":100020801,"comment_content":"在8.0.3版本后，innodb_autoinc_lock_mode默认值已是2，在binlog_format默认值为row的前提下，想来也是为了增加并发。 <br><br>https:&#47;&#47;dev.mysql.com&#47;doc&#47;refman&#47;8.0&#47;en&#47;innodb-parameters.html#sysvar_innodb_autoinc_lock_mode","like_count":17,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439213,"discussion_content":"👍 大势所趋😆","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550298513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75149,"user_name":"进阶的码农","can_delete":false,"product_type":"c1","uid":1017821,"ip_address":"","ucode":"D8991282640334","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/dd/4f53f95d.jpg","comment_is_top":false,"comment_ctime":1552358619,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"23027195099","product_id":100020801,"comment_content":"课后题<br>在最后一个例子中，执行 insert into t2(c,d) select c,d from t; 这个语句的时候，如果隔离级别是可重复读（repeatable read），binlog_format=statement会加记录锁和间隙锁。啥我的binlog_format=row也加锁了","like_count":5,"discussions":[{"author":{"id":1332557,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erbY9UsqHZhhVoI69yXNibBBg0TRdUVsKLMg2UZ1R3NJxXdMicqceI5yhdKZ5Ad6CJYO0XpFHlJzIYQ/132","nickname":"饭团","note":"","ucode":"E24F240CC91BE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":126819,"discussion_content":"我试了一下 我没有锁 我是mysql5.7","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578540659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":88135,"user_name":"Aaron_涛","can_delete":false,"product_type":"c1","uid":1180617,"ip_address":"","ucode":"067F3CBB1F036C","user_header":"https://static001.geekbang.org/account/avatar/00/12/03/c9/9a9d82ab.jpg","comment_is_top":false,"comment_ctime":1555857093,"is_pvip":false,"replies":[{"id":"34324","content":"是说自增主键没指定？<br><br>两个语句分别去申请自增主键，申请到的值是不一样的，所以并不冲突","user_name":"作者回复","comment_id":88135,"uid":"1264162","ip_address":"","utype":1,"ctime":1558261747,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"18735726277","product_id":100020801,"comment_content":"老师，能如果两个事务同时并发插入，主键没有指明的话，加锁的情况能说明下吗","like_count":4,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447743,"discussion_content":"是说自增主键没指定？\n\n两个语句分别去申请自增主键，申请到的值是不一样的，所以并不冲突","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558261747,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72897,"user_name":"hetiu","can_delete":false,"product_type":"c1","uid":1056127,"ip_address":"","ucode":"35D9338C3ABD20","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/7f/aabc1b66.jpg","comment_is_top":false,"comment_ctime":1551752323,"is_pvip":false,"replies":[{"id":"26695","content":"全局的","user_name":"作者回复","comment_id":72897,"uid":"1264162","ip_address":"","utype":1,"ctime":1551876523,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"18731621507","product_id":100020801,"comment_content":"老师，请问下innodb_autoinc_lock_mode配置是库级别的还是实例级别的？","like_count":4,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441814,"discussion_content":"全局的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551876523,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160598,"user_name":"宝仔","can_delete":false,"product_type":"c1","uid":1013493,"ip_address":"","ucode":"A0F17DFF99DB21","user_header":"https://static001.geekbang.org/account/avatar/00/0f/76/f5/e3f5bd8d.jpg","comment_is_top":false,"comment_ctime":1575982619,"is_pvip":true,"discussion_count":4,"race_medal":0,"score":"14460884507","product_id":100020801,"comment_content":"老师这种情况<br>insert into t (id,c,d) values (1,1,1),(2,2,2),(3,3,3),(null,4,4);<br>或者<br>insert into t (id,c,d) values (1,1,1),(null,2,2),(3,3,3),(null,4,4);<br>能解释下吗？<br>第一种情况自增id变成8了<br>第二种情况自增id变成6了","like_count":3,"discussions":[{"author":{"id":1026078,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/1e/0b124c05.jpg","nickname":"冥王星","note":"","ucode":"995A56EF84E5F6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580259,"discussion_content":"不是的 这个可以参考官方的文档 你这样的insert属于mix mode insert，默认的 innodb_autoinc_lock_mode 为1，当执行的时候会一次申请4个id，虽然用不掉。还是会申请完，这样你就看到一个8,8=3+4+1.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658045808,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1609043,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8d/53/0c5ec2bb.jpg","nickname":"贤子磊","note":"","ucode":"59B558C85045E4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373306,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620695182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1327313,"avatar":"https://static001.geekbang.org/account/avatar/00/14/40/d1/fb6f402a.jpg","nickname":"melon","note":"","ucode":"AFBE9426C10AFA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":205070,"discussion_content":"你这个问题搞明白了吗 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584259703,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1367043,"avatar":"https://static001.geekbang.org/account/avatar/00/14/dc/03/ad9574b3.jpg","nickname":"习兮习兮","note":"","ucode":"E616E924188CBA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1327313,"avatar":"https://static001.geekbang.org/account/avatar/00/14/40/d1/fb6f402a.jpg","nickname":"melon","note":"","ucode":"AFBE9426C10AFA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293500,"discussion_content":"for ${batch_insert} {\n\tif (tmp_ids.allUsed()) {\n\t\ttmp_ids = [cur_id, ..., 2*cur_id];\n\t}\n\tif (data.id == null || data.id == 0) {\n\t\tdata.id = tmp_ids.getNextId();\n\t} else {\n\t\tcur_id = data.id;\n\t\ttmp_ids.setEmpty();\n\t}\n\tinsert(data);\n}","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1595559821,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":205070,"ip_address":""},"score":293500,"extra":""}]}]},{"had_liked":false,"id":66364,"user_name":"牛在天上飞","can_delete":false,"product_type":"c1","uid":1137660,"ip_address":"","ucode":"972DAF20F085ED","user_header":"https://static001.geekbang.org/account/avatar/00/11/5b/fc/5c24080b.jpg","comment_is_top":false,"comment_ctime":1549933208,"is_pvip":false,"replies":[{"id":"23580","content":"也没啥，主要就是不好管理。。<br>毕竟event是写在MySQL里的，写程序的同学不一定会记得。<br>比较建议将这类逻辑写在应用程序里面","user_name":"作者回复","comment_id":66364,"uid":"1264162","ip_address":"","utype":1,"ctime":1549978302,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"14434835096","product_id":100020801,"comment_content":"老师，请问产生大量的event事件会对mysql服务器有什么影响？主要是哪几个方面的影响？","like_count":4,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438789,"discussion_content":"也没啥，主要就是不好管理。。\n毕竟event是写在MySQL里的，写程序的同学不一定会记得。\n比较建议将这类逻辑写在应用程序里面","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549978302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188168,"user_name":"mickey","can_delete":false,"product_type":"c1","uid":1051663,"ip_address":"","ucode":"8B490C2DDE4010","user_header":"https://static001.geekbang.org/account/avatar/00/10/0c/0f/93d1c8eb.jpg","comment_is_top":false,"comment_ctime":1584326093,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10174260685","product_id":100020801,"comment_content":"在讲 insert … select 要使用语句级的锁 的例子时，Session A和B 是不是讲反了？？","like_count":2,"discussions":[{"author":{"id":1887586,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLhicDSmL4vicPADhxxzOzukMar8nV5Tc3ic2dz4FQIxMX3WmX5a2V3sdD121eWpvfQI8NXIkkDZoDFw/132","nickname":"Geek_536b54","note":"","ucode":"F62BC7781D9212","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337170,"discussion_content":"仔细阅读 没有反\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608812528,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176871,"user_name":"yihang","can_delete":false,"product_type":"c1","uid":1012361,"ip_address":"","ucode":"A5506F085D1793","user_header":"https://static001.geekbang.org/account/avatar/00/0f/72/89/1a83120a.jpg","comment_is_top":false,"comment_ctime":1581209618,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10171144210","product_id":100020801,"comment_content":"主键 id 出现自增 id 不连续的第三种原因 没有实验出来啊innodb_autoinc_lock_mode=0，1，2 都试了，mysql 版本是8.0, 最后自增列还是连续的","like_count":2},{"had_liked":false,"id":75189,"user_name":"进阶的码农","can_delete":false,"product_type":"c1","uid":1017821,"ip_address":"","ucode":"D8991282640334","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/dd/4f53f95d.jpg","comment_is_top":false,"comment_ctime":1552361597,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10142296189","product_id":100020801,"comment_content":"上期问题解答，有点疑问<br>set sql_log_bin=off;<br>alter table tbl_name engine=innodb;<br><br>为什么备库需要执行set sql_log_bin=off这一句<br>把表的引擎改成innodb不就能解决重启后内存表被删除的问题吗？<br>","like_count":2},{"had_liked":false,"id":315684,"user_name":"盘胧","can_delete":false,"product_type":"c1","uid":1650748,"ip_address":"","ucode":"5386CC4C92ECC2","user_header":"https://static001.geekbang.org/account/avatar/00/19/30/3c/0668d6ae.jpg","comment_is_top":false,"comment_ctime":1633944772,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5928912068","product_id":100020801,"comment_content":"https:&#47;&#47;dev.mysql.com&#47;doc&#47;refman&#47;8.0&#47;en&#47;innodb-auto-increment-handling.html<br>这里面有说规则，自增id不连续的情况，也给了demo。好家伙，老师这这这","like_count":2},{"had_liked":false,"id":70354,"user_name":"唐名之","can_delete":false,"product_type":"c1","uid":1004394,"ip_address":"","ucode":"F472C71E043E03","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/JKKWS6TzhncvAA0p0NDiaATPIvMicSM76vNAg9IG1ibibcJYPAiaicYjZfq4gAV8GRtcTpOibfRD8vzqHBtL0ibmhwQsbg/132","comment_is_top":false,"comment_ctime":1551083257,"is_pvip":false,"replies":[{"id":"25106","content":"这样思路上是ok的，<br><br>不过表b怎么有两个自增列？一个表只能有一个自增列。<br>","user_name":"作者回复","comment_id":70354,"uid":"1264162","ip_address":"","utype":1,"ctime":1551092709,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"5846050553","product_id":100020801,"comment_content":"老师，如果我业务场景必须需要一个带有序自增值，设业务为表A，另外添加一张表记录自增为表B，表B包含3个字段（自增主键，表A唯一键，自增列）；伪代码如下；这样能实现吗？或者有其他什么好的方案？<br>begin；<br>insert into A values（字段1, 唯一键）；<br>insert into B value (表A唯一键，自增列)；<br>commit；","like_count":2,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440581,"discussion_content":"这样思路上是ok的，\n\n不过表b怎么有两个自增列？一个表只能有一个自增列。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551092709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":69396,"user_name":"AstonPutting","can_delete":false,"product_type":"c1","uid":1303239,"ip_address":"","ucode":"1DB579A7922964","user_header":"https://static001.geekbang.org/account/avatar/00/13/e2/c7/d6a0927a.jpg","comment_is_top":false,"comment_ctime":1550734137,"is_pvip":false,"replies":[{"id":"24660","content":"innodb_autoinc_lock_mode = 2的时候就要binlog_format = row才好","user_name":"作者回复","comment_id":69396,"uid":"1264162","ip_address":"","utype":1,"ctime":1550738680,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"5845701433","product_id":100020801,"comment_content":"老师，innodb_autoinc_lock_mode = 2，binlog_format = statement 不也会出现数据不一致的问题吗？不是很理解 binlog_format = statement 的情况下，1 与 2 的区别。","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440097,"discussion_content":"innodb_autoinc_lock_mode = 2的时候就要binlog_format = row才好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550738680,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":66471,"user_name":"Goal","can_delete":false,"product_type":"c1","uid":1307012,"ip_address":"","ucode":"C337CD4C7E07B0","user_header":"https://static001.geekbang.org/account/avatar/00/13/f1/84/7d21bd9e.jpg","comment_is_top":false,"comment_ctime":1549943355,"is_pvip":false,"replies":[{"id":"23575","content":"👍","user_name":"作者回复","comment_id":66471,"uid":"1264162","ip_address":"","utype":1,"ctime":1549978004,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"5844910651","product_id":100020801,"comment_content":"赶上了进度，把春节期间的补回来了","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438811,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549978004,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":66425,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1111985,"ip_address":"","ucode":"9DADD72C193296","user_header":"https://static001.geekbang.org/account/avatar/00/10/f7/b1/982ea185.jpg","comment_is_top":false,"comment_ctime":1549937356,"is_pvip":true,"replies":[{"id":"23581","content":"是的，我手残了。。<br><br>多谢指出，发起勘误了哈<br>","user_name":"作者回复","comment_id":66425,"uid":"1264162","ip_address":"","utype":1,"ctime":1549978431,"user_name_real":"林晓斌"}],"discussion_count":1,"race_medal":0,"score":"5844904652","product_id":100020801,"comment_content":"insert into t values(null,1,1);<br>begin;<br>insert into t values(null,2,2);<br>rolllack;<br>insert into t values(null,2,2);<br>&#47;&#47; 插入的行是 (3,2,2)<br><br>老师 里面是 rollback 吧","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438799,"discussion_content":"是的，我手残了。。\n\n多谢指出，发起勘误了哈\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549978431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":349052,"user_name":"prader26","can_delete":false,"product_type":"c1","uid":1433707,"ip_address":"","ucode":"5EFFFC374ADECE","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/6b/f61d7466.jpg","comment_is_top":false,"comment_ctime":1655694691,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655694691","product_id":100020801,"comment_content":"主键不连续场景：<br>1：唯一键冲突<br>2：事务回滚<br>3：自增主键的批量申请","like_count":0},{"had_liked":false,"id":349049,"user_name":"亚林","can_delete":false,"product_type":"c1","uid":1018972,"ip_address":"","ucode":"4A5A6D24314B79","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/5c/3f164f66.jpg","comment_is_top":false,"comment_ctime":1655692442,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655692442","product_id":100020801,"comment_content":"所以，这些稍微带点业务的事情，还是别让数据库来干","like_count":0},{"had_liked":false,"id":347986,"user_name":"joker","can_delete":false,"product_type":"c1","uid":1101750,"ip_address":"","ucode":"09C3F66C262AB8","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/b6/3fcfa7e5.jpg","comment_is_top":false,"comment_ctime":1654651427,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654651427","product_id":100020801,"comment_content":"如果我要一个字段严格递增呢？类似排名，要如何实现呢？","like_count":0},{"had_liked":false,"id":343180,"user_name":"再见理想","can_delete":false,"product_type":"c1","uid":1245999,"ip_address":"","ucode":"FAC88B3F6F6DFD","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/2f/0a5e0751.jpg","comment_is_top":false,"comment_ctime":1650693919,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650693919","product_id":100020801,"comment_content":"innodb的自增Id在5.7及之前的版本是保存在内存当中的，后面增加了自增Id持久化的机制。<br>导致自增Id不连续的原因：<br>1.语句唯一键冲突，导致申请到自增Id后，语句执行失败，但是自增Id+1。<br>2.事务回滚，导致语句没有执行成功，但是自增Id已经变化。<br>3.innodb的批量申请自增Id策略，为了提高申请自增Id的性能，会按照1&#47;2&#47;4&#47;8的增长速度获取自增Id，但是其中可能存在自增id浪费的情况。<br>自增Id锁有一个配置 ，innodb_autoinc_lock_mode,默认为1：<br>1，为0时，语句执行结束之后，才会释放自增Id锁。<br>2，为1时，普通情况申请到自增Id后，即可释放锁，但是insert..select语句需要语句执行完成之后才能释放自增Id锁。(防止binlog statement格式主从数据不一致问题)。<br>3，所有情况都会在申请到自增Id后，释放自增Id锁。","like_count":0},{"had_liked":false,"id":341057,"user_name":"王斌","can_delete":false,"product_type":"c1","uid":1442064,"ip_address":"","ucode":"244631718BCD0C","user_header":"https://static001.geekbang.org/account/avatar/00/16/01/10/669f7b79.jpg","comment_is_top":false,"comment_ctime":1649317491,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649317491","product_id":100020801,"comment_content":"1、binlog_format=statement 是拿原来的sql执行的，如果在主库执行的时候t表是10条数据(锁t表)，但是在从库执行，会有时间间隔，这个时候在执行这个语句(同样是锁了t表，但是这会儿t表已经有12条了)，从库插入了12条数据，和主库也就不一样了，数据不一致了<br>2、binlog_format=row 不会有这个问题","like_count":0},{"had_liked":false,"id":338388,"user_name":"bestgopher","can_delete":false,"product_type":"c1","uid":2254917,"ip_address":"","ucode":"D89735C8CA9C6E","user_header":"https://static001.geekbang.org/account/avatar/00/22/68/45/ddf89612.jpg","comment_is_top":false,"comment_ctime":1647480380,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1647480380","product_id":100020801,"comment_content":"不连续原因：1.唯一键冲突；2.回滚；3.自增键的申请策略","like_count":0},{"had_liked":false,"id":335993,"user_name":"Geek_35fe0b","can_delete":false,"product_type":"c1","uid":2721741,"ip_address":"","ucode":"D45F716676BBD0","user_header":"","comment_is_top":false,"comment_ctime":1645832983,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645832983","product_id":100020801,"comment_content":"距离老师写这篇文章过了这么久，不知道老师还能不能看到我的评论，有个问题想请教一下：<br>RR隔离级别下，insert ... select 这类语句中的select是否遵循可重复读的限制？<br>如果遵循那select查询的结果是能确定行数的，既然能确定行数，那mysql为什么还要使用1+2+4+8这种申请方式？直接按查询结果申请行数不省事吗？","like_count":0},{"had_liked":false,"id":320007,"user_name":"先听","can_delete":false,"product_type":"c1","uid":1151409,"ip_address":"","ucode":"82D8DA7A2FEB4B","user_header":"https://static001.geekbang.org/account/avatar/00/11/91/b1/fb117c21.jpg","comment_is_top":false,"comment_ctime":1636037315,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636037315","product_id":100020801,"comment_content":"5.7.29之前，在自增模式为1以上时，假如A进程使用insert..select..on duplicate update... 时，如果有另一个进程B也在处理同一个表，A可能会在晕乎乎地把人家B的数据给更新了。请问有没有在不打补丁情况下的解决建议呢？","like_count":1},{"had_liked":false,"id":316014,"user_name":"张诚","can_delete":false,"product_type":"c1","uid":1115702,"ip_address":"","ucode":"F623703194769B","user_header":"https://static001.geekbang.org/account/avatar/00/11/06/36/d288bcc7.jpg","comment_is_top":false,"comment_ctime":1634107873,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1634107873","product_id":100020801,"comment_content":"有个疑问，当初不知道在哪里看到过，对于现在的系统单表行数一般到千万级就到极限了，再多了查询性能就可能成指数级下降，为什么主键类型不选择INT 而选择BIGINT呢？不是说尽量减少主键的数据类型大小吗？","like_count":0},{"had_liked":false,"id":315680,"user_name":"盘胧","can_delete":false,"product_type":"c1","uid":1650748,"ip_address":"","ucode":"5386CC4C92ECC2","user_header":"https://static001.geekbang.org/account/avatar/00/19/30/3c/0668d6ae.jpg","comment_is_top":false,"comment_ctime":1633944175,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633944175","product_id":100020801,"comment_content":"https:&#47;&#47;dev.mysql.com&#47;doc&#47;refman&#47;8.0&#47;en&#47;innodb-auto-increment-handling.html  自增id的文档","like_count":0},{"had_liked":false,"id":306035,"user_name":"Leo","can_delete":false,"product_type":"c1","uid":2649276,"ip_address":"","ucode":"CEBAD9CDCFC2A3","user_header":"https://static001.geekbang.org/account/avatar/00/28/6c/bc/f751786b.jpg","comment_is_top":false,"comment_ctime":1628310117,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628310117","product_id":100020801,"comment_content":"留作记录，嘿嘿：<br>在什么场景下自增主键可能不连续？<br>1：唯一键冲突<br>2：事务回滚<br>3：自增主键的批量申请","like_count":0},{"had_liked":false,"id":301421,"user_name":"Jamey","can_delete":false,"product_type":"c1","uid":2344373,"ip_address":"","ucode":"449E4F65339CDE","user_header":"https://static001.geekbang.org/account/avatar/00/23/c5/b5/25179772.jpg","comment_is_top":false,"comment_ctime":1625670839,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625670839","product_id":100020801,"comment_content":"大家有没有想过为什么自增ID锁不用原子操作？","like_count":0},{"had_liked":false,"id":291768,"user_name":"叶涛","can_delete":false,"product_type":"c1","uid":2448277,"ip_address":"","ucode":"B45348979BE159","user_header":"https://static001.geekbang.org/account/avatar/00/25/5b/95/462890c6.jpg","comment_is_top":false,"comment_ctime":1620470174,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620470174","product_id":100020801,"comment_content":"有没有这种情况呢：<br>1. t表的先新增一条数据, 然后执行 insert into t2(c,d) select c,d from t，t表正常加锁,<br>2. 但如果binlog记录的是 insert into t2...select... t 和 insert t...<br>3. 在从库执行的时候先执行了insert into t2 select....，此时t新增的数据的sql还没有执行，这样是不是也是主备数据不一致了","like_count":0},{"had_liked":false,"id":287423,"user_name":"特兰克斯","can_delete":false,"product_type":"c1","uid":2449886,"ip_address":"","ucode":"97917B24C1136E","user_header":"https://static001.geekbang.org/account/avatar/00/25/61/de/94ee070a.jpg","comment_is_top":false,"comment_ctime":1617939720,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617939720","product_id":100020801,"comment_content":"老师, mybatis  加了   useGeneratedKeys=&quot;true&quot;   keyProperty=&quot;id&quot;  保存的时候返回id, 但是有时候缺没返回, 但是数据库确实是保存了,是什么情况呀","like_count":0},{"had_liked":false,"id":282661,"user_name":"帝江","can_delete":false,"product_type":"c1","uid":1590610,"ip_address":"","ucode":"93CBA4E4D05DA5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/B9vSOjMc2a86kYA8R5yDkVdFiaj2JeBZ1PuI9oUKhbnvuZwuibdUam6FTcGzDaiaFdk2GWJveUGhfCVpv4KaOdicoQ/132","comment_is_top":false,"comment_ctime":1615355619,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615355619","product_id":100020801,"comment_content":"文章提到过.特意提出来.删除也会导致自增主键不连续","like_count":0},{"had_liked":false,"id":271423,"user_name":"邬磊","can_delete":false,"product_type":"c1","uid":1068178,"ip_address":"","ucode":"D938FD4ED5E67E","user_header":"https://static001.geekbang.org/account/avatar/00/10/4c/92/a9cf4fb6.jpg","comment_is_top":false,"comment_ctime":1609604175,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609604175","product_id":100020801,"comment_content":"当 innodb_autoinc_lock_mode!=0的时候，on duplicate key update语句  也会导致自增主键不连续。","like_count":0},{"had_liked":false,"id":268068,"user_name":"moonfox","can_delete":false,"product_type":"c1","uid":1526355,"ip_address":"","ucode":"902BFF40EFA9FA","user_header":"https://static001.geekbang.org/account/avatar/00/17/4a/53/063f9d17.jpg","comment_is_top":false,"comment_ctime":1608043366,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1608043366","product_id":100020801,"comment_content":"请问老师，在批量插入数据，使用批量申请id策略时，当多次申请id期间，锁是被一直持有么，下一次的申请和上一次申请之间，自增锁会被释放么？还是这期间一直持有，直到分配完成？","like_count":0,"discussions":[{"author":{"id":1526355,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4a/53/063f9d17.jpg","nickname":"moonfox","note":"","ucode":"902BFF40EFA9FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335718,"discussion_content":"自己回答下，锁是被一直持有，不会释放，直到申请到所有ID。这样才能保证申请到的ID都是连续的，同步到备库后，主备数据才能是一致的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1608283118,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":258772,"user_name":"Johnson","can_delete":false,"product_type":"c1","uid":1326108,"ip_address":"","ucode":"C6B6FF9EA4CC60","user_header":"https://static001.geekbang.org/account/avatar/00/14/3c/1c/47e5b7aa.jpg","comment_is_top":false,"comment_ctime":1604552364,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604552364","product_id":100020801,"comment_content":"林老师，在一些业务场景中，客户经常会要求按天提供连续的编号，比如20191201001，20191201002，...，并要求不能断号，在数据库设计方面，希望老师能提供一些建议。","like_count":0},{"had_liked":false,"id":253994,"user_name":"CharAt","can_delete":false,"product_type":"c1","uid":1813207,"ip_address":"","ucode":"D7D44B48FC4E79","user_header":"https://static001.geekbang.org/account/avatar/00/1b/aa/d7/a417ad5b.jpg","comment_is_top":false,"comment_ctime":1603008579,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603008579","product_id":100020801,"comment_content":"在分布式大量高并发的业务场景下，可不可以使用disruptor并发框架使用号段模型批量产生自增id，指定id，这样会不会减少mysql自增id的压力。","like_count":0},{"had_liked":false,"id":244631,"user_name":"瑞哲","can_delete":false,"product_type":"c1","uid":1502093,"ip_address":"","ucode":"9F170728A055AD","user_header":"https://static001.geekbang.org/account/avatar/00/16/eb/8d/8ee78d3d.jpg","comment_is_top":false,"comment_ctime":1598600242,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598600242","product_id":100020801,"comment_content":"如果不加记录和间隙锁，而binlog_format又是statement。那么此时如果有另一个事务对t有写操作，比如insert into t values(x, x, x)，这时由于事务的隔离级别是可重复读，t2是看不到新增的数据逇。而我们的binlog记录时如果将insert into t2(c, d) select c,d from t；记在了刚才那个语句的后面。那么在备库使用binlog同步的时候，备库会基于binlog恢复临时库，t2会看到新增的数据，就会造成主备数据的不一致。","like_count":0},{"had_liked":false,"id":222754,"user_name":"指尖以东","can_delete":false,"product_type":"c1","uid":1092218,"ip_address":"","ucode":"1DEE134FE92FD0","user_header":"https://static001.geekbang.org/account/avatar/00/10/aa/7a/ae8c247d.jpg","comment_is_top":false,"comment_ctime":1590905989,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590905989","product_id":100020801,"comment_content":"自增主键不连续虽然自己跑也很常见，但是从来没有留意过为什么。今天学习了三种情况<br>一，插入事务回滚了<br>二，插入的时候唯一键冲突了<br>三，批量插入第一条取一个主键，第二条会获取两个主键，第四条会获取四个主键，因为获取两倍递增部分可能用不到就形成了不连续<br><br>温故了binlog使用用row的好处，线上数据同步用的otter也必须用这个配置<br>","like_count":0},{"had_liked":false,"id":179136,"user_name":"王艺霖","can_delete":false,"product_type":"c1","uid":1113992,"ip_address":"","ucode":"351C456CAEAD25","user_header":"https://static001.geekbang.org/account/avatar/00/10/ff/88/1da2546f.jpg","comment_is_top":false,"comment_ctime":1581925371,"is_pvip":false,"replies":[{"id":"69527","content":"这么神奇，这个表有主键的是吧？<br>那如果你这时候执行insert语句，会主键冲突吗","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1581932602,"ip_address":"","comment_id":179136,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1581925371","product_id":100020801,"comment_content":"老师，我们的mysql8装上以后，重启服务的时候，部分表的auto_increment被重置为1，大概五十张表会有20张出现。。这是bug吗？","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484106,"discussion_content":"这么神奇，这个表有主键的是吧？\n那如果你这时候执行insert语句，会主键冲突吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581932602,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1113992,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ff/88/1da2546f.jpg","nickname":"王艺霖","note":"","ucode":"351C456CAEAD25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":175068,"discussion_content":"是的，就是在insert的时候报错说有重复id发现的。。还在定位中。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581949673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174739,"user_name":"Zhaoyang","can_delete":false,"product_type":"c1","uid":1037190,"ip_address":"","ucode":"131D83AC2566D2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d3/86/b5d72c87.jpg","comment_is_top":false,"comment_ctime":1580367200,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580367200","product_id":100020801,"comment_content":"读了第一遍，大致了解了innodb的主键自增，是存储在内存里面的，大致理解了主键idi不连续的原因，<br>1. 唯一健值冲突<br>2. 批量数据导入时，申请id是成倍申请的，会导致浪费一些id。<br><br>还得需要多读几遍，因为自己平常根本没有注意过这些。","like_count":0},{"had_liked":false,"id":174252,"user_name":"Geek_eb2e49","can_delete":false,"product_type":"c1","uid":1637789,"ip_address":"","ucode":"21671F0C4E7872","user_header":"https://wx.qlogo.cn/mmopen/vi_32/4PvDe2mRia2vdMGyickA40y2libhpf8ibmIEQquLUZFMXUMqqDjfVb96Y69p7bS6USgxicOKCCHxQHczHBnNb5L9nfA/132","comment_is_top":false,"comment_ctime":1580110020,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580110020","product_id":100020801,"comment_content":"老师，非常感谢您的专栏，让我能接触到更多的原理，但是我还是个小白，有些理解的可能不是那么透彻，想请教下<br>由于主库重启后，会往 binlog 里面写“delete from tbl_name”，这个命令传到备库，备库的同名的表数据也会被清空。因此，就不会出现主备同步停止的问题。如果由于主库异常重启，触发了 HA，这时候我们之前修改过引擎的备库变成了主库。而原来的主库变成了新备库，在新备库上把所有的内存表（这时候表里没数据）都改成 InnoDB 表。<br>这样的话主库和从库原来内存表里面的数据不会都丢失了吗？ 还是说因为从库的内存表改了引擎以后，数据可以保存到磁盘中，但是这样不会出现原主库的数据不见了，而新主库的数据保存到磁盘上，从而主从数据不一致吗？","like_count":0},{"had_liked":false,"id":161087,"user_name":"Jacin","can_delete":false,"product_type":"c1","uid":1323763,"ip_address":"","ucode":"F7AA8CCB1C678C","user_header":"https://static001.geekbang.org/account/avatar/00/14/32/f3/698734e2.jpg","comment_is_top":false,"comment_ctime":1576116618,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576116618","product_id":100020801,"comment_content":"自增id，能保证时间顺序上先insert的id更小吗？<br>我遇到Oracle数据库序列的问题，序列有个order选项来保证顺序。应该是出于并发性能考虑。不知道MySQL是否有类似机制，保证自增id时间上严格顺序？","like_count":0},{"had_liked":false,"id":117630,"user_name":"alioo","can_delete":false,"product_type":"c1","uid":1022507,"ip_address":"","ucode":"F36A38C1F5FFAB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqOpANMwDibLmj5IGJh6dTw300sZ1BHM5sG3sZv1A1rvCHOiblPD3jgFOiaMVVujtctWnQbVFoNPpRgw/132","comment_is_top":false,"comment_ctime":1564103577,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564103577","product_id":100020801,"comment_content":"mysql8.0自增id记录到redolog里，redolog是滚动的会不会丢失啊？","like_count":0},{"had_liked":false,"id":117628,"user_name":"alioo","can_delete":false,"product_type":"c1","uid":1022507,"ip_address":"","ucode":"F36A38C1F5FFAB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqOpANMwDibLmj5IGJh6dTw300sZ1BHM5sG3sZv1A1rvCHOiblPD3jgFOiaMVVujtctWnQbVFoNPpRgw/132","comment_is_top":false,"comment_ctime":1564103405,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564103405","product_id":100020801,"comment_content":"binglog是statement的话，记录锁是为了防止t 表在上述sql执行期间产生更新，间隙锁是为了防止t表在上述sql执行期间产生插入操作","like_count":0},{"had_liked":false,"id":114954,"user_name":"醉红尘","can_delete":false,"product_type":"c1","uid":1434669,"ip_address":"","ucode":"C084FEFF5DC1B9","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIGsON5PiclibWicubWbskkVIxJUuxdbrLOp84AZFSNQNibkR0ky1FybqdWEr00gH4g8eOiao0ZvwgFrvg/132","comment_is_top":false,"comment_ctime":1563438051,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563438051","product_id":100020801,"comment_content":"😂我错了<br>老师我想问的是  在row模式下，使用 replace into 还是会导致主从的自增ID不一致问题，这个有解决方法吗？<br>","like_count":0},{"had_liked":false,"id":114943,"user_name":"醉红尘","can_delete":false,"product_type":"c1","uid":1434669,"ip_address":"","ucode":"C084FEFF5DC1B9","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIGsON5PiclibWicubWbskkVIxJUuxdbrLOp84AZFSNQNibkR0ky1FybqdWEr00gH4g8eOiao0ZvwgFrvg/132","comment_is_top":false,"comment_ctime":1563436917,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563436917","product_id":100020801,"comment_content":"老师，请问一下，有什么办法解决存在唯一索引的表的主从自增主键不一致问题吗？<br>示例如下：<br>1、新建一张带有唯一索引的表并写入测试数据<br>CREATE TABLE  TTT(ID INT AUTO_INCREMENT PRIMARY KEY,USER_NAME VARCHAR(50),USER_AGE VARCHAR(50),UNIQUE key IDX_NAME(USER_NAME))<br><br>INSERT INTO TTT(USER_NAME,USER_AGE) VALUES(&#39;A1&#39;,&#39;1&#39;),(&#39;A2&#39;,&#39;2&#39;),(&#39;A3&#39;,&#39;3&#39;),(&#39;A4&#39;,&#39;4&#39;),(&#39;A5&#39;,&#39;5&#39;),(&#39;A6&#39;,&#39;6&#39;);<br><br>2、唯一键冲突场景<br>INSERT INTO TTT(USER_NAME,USER_AGE) VALUES(&#39;A1&#39;,&#39;1&#39;),(&#39;A2&#39;,&#39;2&#39;),(&#39;A3&#39;,&#39;3&#39;),(&#39;A4&#39;,&#39;4&#39;),(&#39;A5&#39;,&#39;5&#39;),(&#39;A6&#39;,&#39;6&#39;);","like_count":0},{"had_liked":false,"id":105227,"user_name":"李刚","can_delete":false,"product_type":"c1","uid":1424487,"ip_address":"","ucode":"BFA253F932F01B","user_header":"https://static001.geekbang.org/account/avatar/00/15/bc/67/2e19e8ef.jpg","comment_is_top":false,"comment_ctime":1560942197,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560942197","product_id":100020801,"comment_content":"1、如果插入的时候，是主键冲突了，AUTO_INCREMENT值不会改变。<br>2、如果插入的field，类型不匹配，比如定义的是int，结果插入英文字符串，AUTO_INCREMENT值也不会改变。<br>帮忙解释下，这2种现象。","like_count":0},{"had_liked":false,"id":100383,"user_name":"红鲤鱼与绿鲤鱼与驴baci","can_delete":false,"product_type":"c1","uid":1199902,"ip_address":"","ucode":"CB7D8A522D665E","user_header":"https://static001.geekbang.org/account/avatar/00/12/4f/1e/cb8ddbe9.jpg","comment_is_top":false,"comment_ctime":1559543458,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559543458","product_id":100020801,"comment_content":"老师 这个第三种id 不连续的情况 ，它是一个什么规律呀？  我自己实验了一下，t表  插入了 1-8 条数据，然后安装 你上边代码的顺序  creat table t2  ..， insert into t2（c,d） select c,d from t. 插入完之后 t2 表的 AUTO_INCREMENT =16了","like_count":0},{"had_liked":false,"id":89221,"user_name":"zhima_hu","can_delete":false,"product_type":"c1","uid":1311188,"ip_address":"","ucode":"33A4496556D9B1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/rBCoNmJbagIGlkrDDfdQv9YjrtoHfvExqSSiavHwgUaukTxnO2jTBGrrHUF49VZqaS1FBolLc4Bibk883sabroyQ/132","comment_is_top":false,"comment_ctime":1556111053,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556111053","product_id":100020801,"comment_content":"你好，下面这种insert select语句会加几个锁，因为现在线上这个语句出现死锁，整不明白<br>INSERT INTO rule_prom_activity<br>        (<br>        `act_id`,<br>        `act_name`,<br>        `create_time`,<br>        `modified_time`)<br>        SELECT<br>        #{activityId},<br>        #{name},\t\t    <br>        now(),<br>        now()<br>\t\tFROM<br>\t\t\tdual<br>\t\tWHERE NOT EXISTS(SELECT 1 FROM rule_prom_activity WHERE act_id = #{activityId})","like_count":0},{"had_liked":false,"id":81844,"user_name":"归心","can_delete":false,"product_type":"c1","uid":1036567,"ip_address":"","ucode":"985E3188A9F6FE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d1/17/356cc426.jpg","comment_is_top":false,"comment_ctime":1554049712,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1554049712","product_id":100020801,"comment_content":"老师好，这边有个问题：经测试，不论是mysql版本是5.7 还是8.0，当mysql重启后自增值都是max(id) + 1，但是当不指定id值插入时，例如 insert into table values()，id值是第一个大于 max(id) 的新生成的自增值。这个好像和老师将的不一样，望老师解答谢谢！","like_count":0,"discussions":[{"author":{"id":1318528,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1e/80/e409fff6.jpg","nickname":"Sochooligan","note":"","ucode":"B66F78B6B86476","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":133388,"discussion_content":"你实证的方式很好，自己找找答案或者看源码不好么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578963737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72830,"user_name":"二十四桥仍在","can_delete":false,"product_type":"c1","uid":1232468,"ip_address":"","ucode":"5498FE5949190F","user_header":"https://static001.geekbang.org/account/avatar/00/12/ce/54/c13b1d63.jpg","comment_is_top":false,"comment_ctime":1551746015,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1551746015","product_id":100020801,"comment_content":"UUID生成主键","like_count":0},{"had_liked":false,"id":66540,"user_name":"郭烊千玺","can_delete":false,"product_type":"c1","uid":1302416,"ip_address":"","ucode":"15736D91964DA3","user_header":"https://static001.geekbang.org/account/avatar/00/13/df/90/68408c1b.jpg","comment_is_top":false,"comment_ctime":1549955876,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549955876","product_id":100020801,"comment_content":"请教老师个额外话题 select concat(truncate(sum(data_length)&#47;1024&#47;1024,2),&#39;MB&#39;) as data_size,<br>concat(truncate(sum(max_data_length)&#47;1024&#47;1024,2),&#39;MB&#39;) as max_data_size,<br>concat(truncate(sum(data_free)&#47;1024&#47;1024,2),&#39;MB&#39;) as data_free,<br>concat(truncate(sum(index_length)&#47;1024&#47;1024,2),&#39;MB&#39;) as index_size<br>from information_schema.tables where TABLE_SCHEMA = &#39;databasename&#39;;  网上广为流传的这个统计的表大小的方法准确吗 mysql内部是怎么统计的？并且data_free这个mydql内部又是怎么统计的 是采样8个页来评估整表吗 并且实验总感觉这样统计不准啊 到底靠谱吗 求赐教求赐教啊 困惑好久了 ","like_count":0},{"had_liked":false,"id":66082,"user_name":"aliang","can_delete":false,"product_type":"c1","uid":1149502,"ip_address":"","ucode":"B36B94B362477F","user_header":"https://static001.geekbang.org/account/avatar/00/11/8a/3e/30c05bce.jpg","comment_is_top":false,"comment_ctime":1549873818,"is_pvip":true,"replies":[{"id":"23414","content":"就表示还在“killed”状态，看一下32篇哈","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1549879662,"ip_address":"","comment_id":66082,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1549873818","product_id":100020801,"comment_content":"老师，执行SELECT `ID`, `USER`, `HOST`, `DB`, `COMMAND`, `TIME`, `STATE`, LEFT(`INFO`, 51200) AS `Info` FROM `information_schema`.`PROCESSLIST`;后不时有COMMAND为killed但info为null的进程，请问是怎么回事呢","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438695,"discussion_content":"就表示还在“killed”状态，看一下32篇哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549879662,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":66038,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1549855799,"is_pvip":true,"replies":[{"id":"23397","content":"确实是考虑并发 , 不过并不会有这个现象哦，因为一个语句执行期间还是有一致性视图的。<br><br>把binlog加进去考虑下哈<br>","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1549873324,"ip_address":"","comment_id":66038,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1549855799","product_id":100020801,"comment_content":"防止insert语句执行过程中，原表有新增数据，进而导致的插入新表的数据比原表少","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438684,"discussion_content":"确实是考虑并发 , 不过并不会有这个现象哦，因为一个语句执行期间还是有一致性视图的。\n\n把binlog加进去考虑下哈\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549873324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}