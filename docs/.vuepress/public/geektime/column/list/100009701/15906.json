{"id":15906,"title":"27 | 利用Mock与回放技术助力自动化回归","content":"<p>你好，我是王潇俊。今天我和你分享的主题是：利用Mock与回放技术助力自动化回归。</p>\n<p>在《代码静态检查实践》和《越来越重要的破坏性测试 》这次的分享中，我介绍了对持续交付有重大影响的两个测试类型，即静态代码检查和破坏性测试。</p>\n<p>你可能已经发现，这两种测试正好适用于持续集成和测试管理的一头、一尾：</p>\n<ul>\n<li>静态代码检查，适合在所有其他测试类型开始之前优先进行，把住第一关；</li>\n<li>破坏性测试，则适用于集成或验收测试之后，甚至是对系统进行持续长久的测试。</li>\n</ul>\n<p>那么，我们现在再一起来看看，持续交付过程中还有哪些测试方法，以及还有哪些问题和难点吧。</p>\n<h2>持续交付中的测试难点</h2>\n<p>其实，对于持续交付中的测试来说，自动化回归测试是不可或缺的，占了很大的测试比重。而进行自动化回归测试，就始终会有“三座大山”横在你面前。</p>\n<p><strong>“第一座大山”：测试数据的准备和清理。</strong></p>\n<p>通常情况下，回归测试的用例是可以复用的，所以比较固定，结果校验也比较确定。而如果要实现回归测试的自动化，就需要保证每次测试时的初始数据尽量一致，以确保测试脚本可复用。</p>\n<p>如果每次的数据都不同，那么每次的测试结果也会受到影响。为了做到测试结果的可信赖，就有两种方法：</p>\n<ul>\n<li>一种是，每次全新的测试都使用全新初始化数据；</li>\n<li>另一种是，在测试完成后，清除变更数据，将数据还原。</li>\n</ul><!-- [[[read_end]]] -->\n<p>但是，这两种方法的实现，都比较麻烦，而且很容易出错。</p>\n<p><strong>“第二座大山”：分布式系统的依赖。</strong></p>\n<p>分布式系统因为有服务依赖的问题，所以进行一些回归测试时，也会存在依赖的问题。这个问题，在持续交付中比较难解决：</p>\n<ol>\n<li>\n<p>单元测试时要面对两难选择，测依赖还是不测依赖；</p>\n</li>\n<li>\n<p>集成测试时，如何保证依赖服务的稳定性，或者说排除由稳定性带来的干扰，所以到底是依赖服务的问题，还是被测服务的问题很难确定；</p>\n</li>\n<li>\n<p>真实的业务系统中，往往还存在多层依赖的问题，你还要想办法解决被测应用依赖的服务的依赖服务。</p>\n</li>\n</ol>\n<p>我的天呢，“这座大山”简直难以翻越。</p>\n<p><strong>“第三座大山”：测试用例的高度仿真。</strong></p>\n<p>如何才能模拟出和用户一样的场景，一直困扰着我们。</p>\n<p>如果我们的回归测试不是自己设计的假想用例，而是真实用户在生产环境中曾经发生过的实际用例的话，那么肯定可以取得更好的回归测试效果。那么，有没有什么办法或技术能够帮助我们做到这一点呢？</p>\n<p><span class=\"orange\">如何翻越这“三座大山”，我在这里给你准备了Mock和回放技术这个两大利器，也就是我接下来要和你重点分享的内容。</span></p>\n<h2>两大利器之一Mock</h2>\n<p>我先来说说什么是Mock：</p>\n<blockquote>\n<p>如果某个对象在测试过程中依赖于另一个复杂对象，而这个复杂对象又很难被从测试过程中剥离出来，那么就可以利用Mock去模拟并代替这个复杂对象。</p>\n</blockquote>\n<p>听起来是不是有点抽象？下面这张图就是Mock定义的一个具象化展示，我们一起来看看吧。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/e2/9f/e2e79f8ec5f10e7ef3b3c84c8781d39f.png?wh=292*381\" alt=\"\" /></p>\n<center>图1 测试过程中，被测对象的外部依赖情况展示</center>\n<p>在测试过程中，你可能会遇到这样的情况。你要测试某个方法和对象，而这个被测方法和对象依赖了外部的一些对象或者操作，比如：读写数据库、依赖另外一个对象的实体；依赖另一个外部服务的数据返回。</p>\n<p>而实际的测试过程很难实现这三种情况，比如：单元测试环境与数据库的网络不通；依赖的对象接口还没有升级到兼容版本；依赖的外部服务属于其他团队，你没有办法部署等等。</p>\n<p>那么，这时，你就可以利用Mock技术去模拟这些外部依赖，完成自己的测试工作。</p>\n<p>Mock因为这样的模拟能力，为测试和持续交付带来的价值，可以总结为以下三点：</p>\n<ol>\n<li>\n<p><strong>使测试用例更独立、更解耦</strong>。利用Mock技术，无论是单体应用，还是分布式架构，都可以保证测试用例完全独立运行，而且还能保证测试用例的可迁移性和高稳定性。为什么呢？<br />\n因为足够独立，测试用例无论在哪里运行，都可以保证预期结果；而由于不再依赖于外部的任何条件，使得测试用例也不再受到外部的干扰，稳定性也必然得到提升。</p>\n</li>\n<li>\n<p><strong>提升测试用例的执行速度</strong>。由于Mock技术只是对实际操作或对象的模拟，所以运行返回非常快。特别是对于一些数据库操作，或者复杂事务的处理，可以明显缩短整个测试用来的执行时间。<br />\n这样做最直接的好处就是，可以加快测试用例的执行，从而快速得到测试结果，提升整个持续交付流程的效率。</p>\n</li>\n<li>\n<p><strong>提高测试用例准备的效率</strong>。因为Mock技术可以实现对外部依赖的完全可控，所以测试人员在编写测试用例时，无需再去特别考虑依赖端的情况了，只要按照既定方式设计用例就可以了。</p>\n</li>\n</ol>\n<p>那么，如何在测试中使用Mock技术呢？</p>\n<p>目前，市场上有很多不同的Mock框架，你可以根据自己的情况进行选择。主要的应用场景可以分为两类：基于对象和类的Mock，基于微服务的Mock。</p>\n<p><strong>第一，基于对象和类的Mock</strong></p>\n<p>基于对象和类的Mock，我比较推荐使用的框架是Mockito或者EasyMock。</p>\n<p>Mockito或者EasyMock这两个框架的实现原理，都是在运行时，为每一个被Mock的对象或类动态生成一个代理对象，由这个代理对象返回预先设计的结果。</p>\n<p>这类框架非常适合模拟DAO层的数据操作和复杂逻辑，所以它们往往只能用于单元测试阶段。而到了集成测试阶段，你需要模拟一个外部依赖服务时，就需要基于微服务的Mock粉墨登场了。</p>\n<p><strong>第二，基于微服务的Mock</strong></p>\n<p>基于微服务的Mock，我个人比较推荐的框架是Weir Mock 和 Mock Server。这两个框架，都可以很好地模拟API、http形式的对象。</p>\n<p>从编写测试代码的角度看，Weir Mock 和 Mock Server这两种测试框架实现Mock的方式基本一致：</p>\n<ol>\n<li>\n<p>标记被代理的类或对象，或声明被代理的服务；</p>\n</li>\n<li>\n<p>通过Mock框架定制代理的行为；</p>\n</li>\n<li>\n<p>调用代理，从而获得预期的结果。</p>\n</li>\n</ol>\n<p>可见，这两种Mock框架，都很容易被上手使用。</p>\n<p><strong>第三，携程的Mock Service实践</strong></p>\n<p>在携程，我们一次集成测试，可能依赖的外部服务和数据服务会有几百个，而这几百个服务中很多都属于基础服务，都有被Mock的价值。</p>\n<p>所以，携程借鉴了Mock Server的想法，在整个测试环境中构建了一套Mock Service：所有服务的请求，都会优先通过这套系统；同时，所有服务的返回也会被拦截。这套Mock Service看起来就像是一个巨大的代理，代理了所有请求。</p>\n<p>那么，测试人员只要去配置自己的哪些请求需要被Mock Service代理就可以了，如果请求的入参相同，且Mock Service中存在该请求曾经的返回，则直接被代理。反之，则透传到真正的服务。</p>\n<p>虽然这会增加性能开销，但是对于整体的回归测试来说，价值巨大，而且方便好用、无需编码。</p>\n<p>Mock技术，通过模拟，绕过了实际的数据调用和服务调用问题，横在我们面前的“三座大山”中的其中两座，测试数据的准备和清理、分布式系统的依赖算是铲平了。但是如何解决“第三座大山”呢，即如何做到模拟用户真正的操作行为呢？</p>\n<h2>两大利器之二“回放”技术</h2>\n<p><strong>要做到和实际用户操作一致，最好的方法就是记录实际用户在生产环境的操作，然后在测试环境中回放。</strong></p>\n<p>当然，我们要记录的并不是用户在客户端的操作过程，而是用户产生的最终请求。这样做，我们就能规避掉客户端产生的干扰，直接对功能进行测试了。</p>\n<p><strong>首先，我们一起来看一下如何把用户的请求记录下来。</strong></p>\n<p>这里我们需要明确一个前提原则，即：我们并不需要记录所有用户的请求，只要抽样即可，这样既可以保持用例的新鲜度，又可以减少成本。</p>\n<p>我们在携程有两种方案来拦截记录用户操作：</p>\n<ul>\n<li>第一种方案是，在统一的SLB上做统一的拦截和复制转发处理。这个方案的好处是，管理统一，实现难度也不算太大。但问题是，SLB毕竟是生产主路径上的处理服务，一不小心，就可能影响本身的路由服务，形成故障。所以，我们有了第二种替换方案。</li>\n<li>第二种方案是，在集群中扩容一台服务器，在该服务器上启动一个软交换，由该软交换负责复制和转发用户请求，而真正的用户请求，仍旧由该服务器进行处理。<br />\n这个方案比第一种方案稍微复杂了一些，但在云计算的支持下，却显得更经济。你可以按需扩容服务器来获取抽样结果，记录结束后释放该服务器资源。这个过程中，你也不需要进行过多的配置操作，就和正常的扩容配置一样，减少了风险。</li>\n</ul>\n<p>这样，我们就完成了用户行为的拦截记录。而用户行为记录的保存格式，你也可以根据要使用的的回放工具来决定。</p>\n<p><strong>然后，我们再一起看看回放的多样性。</strong></p>\n<p>因为回放过程完全由我们来控制，所以除了正常的原样回放外，我们还可以利用回放过程达到更多的目的。</p>\n<p>我们既可以按照正常的时间间隔，按照记录进行顺序回放；也可以压缩回放时间，形成一定的压力，进行回放，达到压力测试的目的。</p>\n<p>而且，如果可以对记录的请求数据做到更精细的管理，我们还可以对回放进一步抽样和删选，比如只回放符合条件的某些请求等等，找出边界用例，利用这些用例完成系统的容错性和兼容性测试。</p>\n<p>当然，你如果希望做到回放的精细管理，那我的建议是根据你的实际业务特性自研回放工具。</p>\n<p>自研回放工具的整体思路其实非常简单，就是读取拦截的访问记录、模拟实际协议、进行再次访问。当然，你还可以给它加上更多额外的功能，比如数据筛选、异常处理、循环重复等等。</p>\n<p>现在，利用“回放”技术，我们也顺利翻越了最后“一座山”，实现了用户行为的高度仿真。</p>\n<h2>总结</h2>\n<p>我以提出问题-分析问题-解决问题的思路，和你展开了今天的分享内容。</p>\n<p>首先，我和你分享了自动化回归测试会遇到的三个难题：测试数据的准备和清理、分布式系统的依赖，以及测试用例的高度仿真。</p>\n<p>我们可以利用Mock技术（即通过代理的方式模拟被依赖的对象、方法或服务的技术），通过不同的框架，解决自动化回归测试的前两个问题：</p>\n<ul>\n<li>基于对象和类的Mock，解决一个应用内部依赖的问题；</li>\n<li>基于微服务的Mock，解决应用与应用之间外部依赖的问题。</li>\n</ul>\n<p>然后，我和你分享了携程的“回放技术”，即先通过虚拟交换机，复制和记录生产用户的实际请求，在测试时“回放”这些真实操作，以达到更逼真地模拟用户行为的目的，从而解决了自动化回归测试遇到的第三个问题。</p>\n<p>所以，利用Mock和“回放”技术，我们能够提高自动化回归测试的效率和准确度，从而使整个持续交付过程更顺滑，自动化程度更高。</p>\n<h2>思考题</h2>\n<p>你所在的公司，有没有合理的回归测试过程？如果没有，是为什么呢，遇到了什么困难？通过我今天分享的内容，你将如何去优化这个回归测试的过程呢？</p>\n<p>感谢你的收听，欢迎你给我留言。</p>\n<p></p>\n","neighbors":{"left":{"article_title":"26 | 越来越重要的破坏性测试","id":14633},"right":{"article_title":"28 | 持续交付为什么要平台化设计？","id":17823}},"comments":[{"had_liked":false,"id":36401,"user_name":"debugtalk","can_delete":false,"product_type":"c1","uid":1005452,"ip_address":"","ucode":"D6F0E57E79808C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/8c/8fba0bdd.jpg","comment_is_top":false,"comment_ctime":1541081309,"is_pvip":false,"replies":[{"id":"12981","content":"流量请求本身不会具有问题，只是对数据产生影响，对数据加以处理，或者利用影子库来处理，就可以了","user_name":"作者回复","user_name_real":"潇俊","uid":"1004285","ctime":1541144939,"ip_address":"","comment_id":36401,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18720950493","product_id":100009701,"comment_content":"很多流量是具有时效性，或者不可重复性的，对于这类流量你们是怎么复制回放的呢？","like_count":5,"discussions":[{"author":{"id":1004285,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/52/fd/abb7bfe3.jpg","nickname":"潇俊","note":"","ucode":"D5DFD3E2119D95","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427849,"discussion_content":"流量请求本身不会具有问题，只是对数据产生影响，对数据加以处理，或者利用影子库来处理，就可以了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541144939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64345,"user_name":"zhongjia19900829","can_delete":false,"product_type":"c1","uid":1367970,"ip_address":"","ucode":"33200E1B9B9525","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/AaQknrwU7ltWcahiaEiaCXyYib2TEqocHBhZmAAxJ61oJibAUSrsxCSpdPO1pMZQpR7VJtmpNvQYaFoAibFa9jiaEqZw/132","comment_is_top":false,"comment_ctime":1548750552,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5843717848","product_id":100009701,"comment_content":"生产和测试的环境的数据  怎么保持一致？ ","like_count":1},{"had_liked":false,"id":25588,"user_name":"zhf_sy","can_delete":false,"product_type":"c1","uid":1054604,"ip_address":"","ucode":"2BE4592F66CCF1","user_header":"https://static001.geekbang.org/account/avatar/00/10/17/8c/f3ada7dc.jpg","comment_is_top":false,"comment_ctime":1537370616,"is_pvip":false,"replies":[{"id":"9505","content":"一般类似ovs这样的软交换都有分流功能，技术上，熟悉网络及设备的话，也不是很复杂","user_name":"作者回复","user_name_real":"潇俊","uid":"1004285","ctime":1537505763,"ip_address":"","comment_id":25588,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5832337912","product_id":100009701,"comment_content":"第二种方案是，在集群中扩容一台服务器，在该服务器上启动一个软交换，由该软交换负责复制和转发用户请求，而真正的用户请求，仍旧由该服务器进行处理。<br><br>请问这个技术上怎么实现？复杂吗？","like_count":1,"discussions":[{"author":{"id":1004285,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/52/fd/abb7bfe3.jpg","nickname":"潇俊","note":"","ucode":"D5DFD3E2119D95","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424354,"discussion_content":"一般类似ovs这样的软交换都有分流功能，技术上，熟悉网络及设备的话，也不是很复杂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537505763,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":282989,"user_name":"lyonger","can_delete":false,"product_type":"c1","uid":1313840,"ip_address":"","ucode":"E89A75DADEA2A1","user_header":"https://static001.geekbang.org/account/avatar/00/14/0c/30/bb4bfe9d.jpg","comment_is_top":false,"comment_ctime":1615512349,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615512349","product_id":100009701,"comment_content":"老师，[通过虚拟交换机，复制和记录生产用户的实际请求]，这个相当于用户所有请求的入口都要经过这个虚拟交换机，不会有单点或者性能瓶颈么？","like_count":0},{"had_liked":false,"id":218556,"user_name":"楚耳","can_delete":false,"product_type":"c1","uid":1068208,"ip_address":"","ucode":"7661633F3297C6","user_header":"https://static001.geekbang.org/account/avatar/00/10/4c/b0/f22017b0.jpg","comment_is_top":false,"comment_ctime":1589817504,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589817504","product_id":100009701,"comment_content":"回放这块，如果都是写的接口也进行回放吗，这样不会对生产环境数据产生影响吗","like_count":0},{"had_liked":false,"id":191515,"user_name":"孙瑜","can_delete":false,"product_type":"c1","uid":1808713,"ip_address":"","ucode":"D57C35FF311B8F","user_header":"https://static001.geekbang.org/account/avatar/00/1b/99/49/43bd37b4.jpg","comment_is_top":false,"comment_ctime":1584778525,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584778525","product_id":100009701,"comment_content":"针对回过测试流程，公司项目中的接口和UI先不论，比较痛苦的是公司数据处理有大量存储过程，然后近半年用帆软reports开发了大量的报表 软件升级时人工回归测试工作量巨大。","like_count":1},{"had_liked":false,"id":104202,"user_name":"王凡","can_delete":false,"product_type":"c1","uid":1337012,"ip_address":"","ucode":"5C7ECB5EB34FA0","user_header":"https://static001.geekbang.org/account/avatar/00/14/66/b4/6b6fb152.jpg","comment_is_top":false,"comment_ctime":1560680556,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560680556","product_id":100009701,"comment_content":"”mock可以解决数据的准备和清理的工作”请问怎么做到的？我目前理解的mock只是对第依赖部分不产生真实数据，但mock的上下游服务如果有数据产生，则依旧会产生，还是需要额外去做数据准备和清理，不知道理解是否有偏差？","like_count":0},{"had_liked":false,"id":57842,"user_name":"王毅","can_delete":false,"product_type":"c1","uid":1204208,"ip_address":"","ucode":"D06D1EBC440FC0","user_header":"https://static001.geekbang.org/account/avatar/00/12/5f/f0/0c4b1548.jpg","comment_is_top":false,"comment_ctime":1546925752,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1546925752","product_id":100009701,"comment_content":"流量拷贝算不算回放的一种？","like_count":1},{"had_liked":false,"id":53205,"user_name":"疯癫","can_delete":false,"product_type":"c1","uid":1170341,"ip_address":"","ucode":"E9A570B084EB0C","user_header":"https://static001.geekbang.org/account/avatar/00/11/db/a5/3a94e0bc.jpg","comment_is_top":false,"comment_ctime":1545615812,"is_pvip":false,"replies":[{"id":"20614","content":"触发某些行为才能记录，用户行为可以靠埋点，但批量模拟还是比较麻烦的","user_name":"作者回复","user_name_real":"潇俊","uid":"1004285","ctime":1546670277,"ip_address":"","comment_id":53205,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545615812","product_id":100009701,"comment_content":"回放是对请求的记录和复制，主要是接口层面，那么app端的功能回归测试，有没有方法获得用户操作的真实场景呢？","like_count":0,"discussions":[{"author":{"id":1004285,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/52/fd/abb7bfe3.jpg","nickname":"潇俊","note":"","ucode":"D5DFD3E2119D95","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434063,"discussion_content":"触发某些行为才能记录，用户行为可以靠埋点，但批量模拟还是比较麻烦的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546670277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}