{"id":740886,"title":"第 12 章 微服务与云原生应用","content":"\n<blockquote>\n<p><strong>本章内容</strong></p>\n<ul>\n<li>微服务的基本概念</li>\n<li>RESTful 风格微服务的设计思路</li>\n<li>云原生应用的基本概念</li>\n<li>云原生时代下的十二要素应用</li>\n</ul>\n</blockquote>\n<p>早期的应用大多是单体（monolithic）应用，所有的功能都集中在一个庞大的应用中，为了支撑这么一个“庞然大物”，有时甚至需要将它部署在小型机上。如果应用的某个功能容量不足，我们无法按需变更，只能对整个应用做扩容。后来 SOA（Service Oriented Architecture，面向服务的架构）的概念兴起，大家开始把大应用拆小。近几年，SOA 又进一步发展到了微服务，再加上云计算技术的广泛应用，开发一个高可用的分布式应用的成本越来越低了。在开始各种实践操作前，我们先来了解一下微服务与云原生相关的概念，随后看一下 REST 这一重要的服务设计风格。</p>\n<h2 id=\"nav_point_190\">12.1　走近微服务</h2>\n<p>在大家的日常工作中，应该或多或少已经与微服务打过一些交道了，只是自己可能没有察觉到，因为微服务的运用已经越来越常见了。那什么样的服务才能算是微服务，它又有什么特点呢？下面就让我们一起跟微服务来个“亲密接触”。</p>\n<h3 id=\"nav_point_191\">12.1.1　什么是微服务</h3>\n<p>2014 年，Martin Fowler 在一篇名为“Microservices”的博客文章中对微服务做了比较详细的介绍。按照文中的说法，微服务是一种软件设计方法，即以若干组可独立部署的服务的方式进行软件应用系统的设计，通过一组小型服务来构建整个应用系统。与之对应的就是传统的单体应用，一小一大形成了鲜明的对比。后来，Sam Newman 出版了《微服务设计》一书，书中将微服务定义为“<strong>一些小而自治的服务</strong>”，我们该如何理解其中的“小而自治”呢？</p><!-- [[[read_end]]] -->\n<p>先来看看“小”，人们通常很容易把“微”和“小”联系在一起，微服务是小服务，那到底多小的服务才算微服务呢？在微服务的概念刚出现时，一定有不少人将其理解为“一个进程就提供一个具体的接口”，但这时就出现了一些让人理解不了的问题。例如，一个功能可能需要十几个接口协同工作才能完成，如果一个接口就要部署一组进程（为了高可用，起码要在两台服务器上分别部署），那十几个接口就要部署“茫茫多”的进程，更别提背后要管理的连接池等资源了，就算有先进的运维平台，但这样真的对吗？</p>\n<p>也许，另一种理解可能更合理一些。微服务是一些高内聚的小接口的集合，它们聚焦于做好同一件事。例如，一个商城的系统，其中与订单相关的服务都集中在一起，包括创建订单、修改订单内容、推进订单状态等，这就是一个订单微服务系统；与会员相关的服务也集中在一个会员微服务系统里，提供的接口包括创建会员、修改会员信息等。每个接口本身的职责都比较单一，多个相关的接口在一起提供相对复杂的功能。再进一步，怎么才是小，每个人都会有自己的理解，只要自己不觉得困扰就行了。要想明白一件事，万事皆有<strong>成本</strong>，服务的<strong>颗粒度</strong>越小，组装服务和运维的成本就越高，找到一个适合自己的<strong>平衡点</strong>就可以了。</p>\n<p>再来看看“自治”，我们前面说把一些高内聚的小接口集中在一起，它就是一个可独立部署的微服务系统了，可以部署为独立的进程，也可以放进 Web 容器，或者在 Kubernetes 里作为一个 Pod 运行，总之它是我们部署的<strong>最小单元</strong>。不同的微服务系统之间是低耦合的，各自完成自己的功能，这一点非常重要，自己的业务逻辑必须自己封装起来（有些功能的实现需要调用下游的服务，这是允许的）。系统之间通过事先约定好的 API 进行交互，API 的实现细节其他人并不关心，只要能按照契约发起调用，获得结果就行了。</p>\n<p>最后，很多人可能会好奇，微服务与 SOA 是什么关系？两者名字里都有服务，微服务是不是 SOA 的一种？SOA 是一种架构风格，它的全称是 Service Oriented Architecture，即面向服务的架构。通常当我们在讨论 SOA 时，都会联想起运用了中心化的 ESB（企业服务总线）系统——通过 ESB 和 SOAP 等技术来实现复杂的企业级系统曾经也流行一时。事实证明，ESB 可能在很多场景下并不是一个理想的选择。SOA 中提到的服务是广义上的服务，微服务本身也是一种服务，也许微服务就是在用正确的方式落地 SOA，是做“对”了的 SOA。</p>\n<h3 id=\"nav_point_192\">12.1.2　微服务的特点</h3>\n<p>在理解了什么是微服务后，再来看看微服务架构为我们带来了什么好处，为什么微服务备受青睐。</p>\n<ol>\n<li><p><strong>模块化</strong></p>\n<p>前面我们提到运用了微服务架构的系统会将大系统拆分为多个可独立部署的单元，这些单元（也就是系统中的模块）满足<strong>高耦合</strong>、<strong>低内聚</strong>的特点。其实，说“部署”可能并不够准确，传统的软件库也可以看作独立的模块。高德纳教授说“<strong>过早优化是万恶之源</strong>”，如果系统的规模没有大到要拆分为分布式系统的程度，那可以先用模块化的方式将系统拆成多个库，但仍部署在一个单元里。在通常情况下，我们所讨论的模块化指的是分布式系统，而非类库。</p>\n<p>既然已经把系统拆成了多个可独立部署的模块，那就不用拘泥于整个系统都用同一种技术栈来实现，模块 A 用 Java 来写，模块 B 用 Go 来写都是可以的，这就实现了整个系统的异构性。放到以前，要重构一个历史悠久的遗留系统，伤筋动骨不说，风险还很高；但如果是重构其中的一个小模块，那风险就低了很多。模块小，哪怕是重写，代价都不会大到不可接受，每个部分都具备可替换性。</p>\n<p>模块化还带来了另一个好处，即组成系统的各个模块能够与组织结构对齐。康威定律（Conway's Law）说“<strong>设计系统的架构受制于产生这些设计的组织的沟通结构</strong>”，有人将其解释为产品必然是其组织沟通结构的缩影。在微服务架构的帮助下，每个团队都会有其对应的模块，这样的对齐也许也是微服务能够流行的原因吧。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>扩展性</strong></p>\n<p>大多数系统在整个生命周期中的容量都会有波峰波谷，起先没有太多人使用，没什么性能容量的压力，但随着时间的推移，用户量逐渐增长，甚至出现了爆发式增长，这时我们就要考虑扩容。在遇到类似“双十一”这样的活动时，更要事先做好应对流量高峰的准备。如果是一个单体应用，那不管哪个功能模块的流量预期会增长，都得整体扩容，况且要启动一个大应用，本身就要耗费比较多的资源。如果将这个系统转换为微服务架构的多个子系统情况就不同了，按需对特定模块扩容就行了。</p>\n<p>假设对于一个大的 Java 单体应用，启动一个实例需要一台 12 核 CPU、24GB 内存的虚拟机，每次扩容我们都需要准备这样规格的机器，一台标准的 PC 服务器也虚拟不了几台这样的虚拟机。换成微服务应用后，我们不需要整体扩容，只需要针对部分链路涉及的模块进行扩容即可，而每个应用可能只需要 2 核 CPU、4GB 内存的虚拟机。如果放到 Kubernetes 环境下，还可以进一步细化，分配出 1 核，乃至 0.5 核的 Pod 都是可以的。这就在很大程度上提升了整个系统的扩展性。</p>\n<p>再者说，启动一个大应用的代价也大，不仅是占用的资源多，编译、打包、部署的时间都很长，那种“提交一行代码，开始编译后去泡杯茶，回来一看编译报错了，改一下再去溜达一圈”的事情在开发大系统时很容易遇到，启动需要几分钟到十几分钟都是很“正常”的。而小系统就不同了，因为体积小，所以每个步骤都很轻量化，甚至能够实现秒级部署，再配合容器相关的技术，降低部署的复杂度，这样就为快速弹性伸缩奠定了坚实的基础。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>隔离性</strong></p>\n<p>在系统出问题时，单体应用可谓一损俱损，设想一个 Java 系统因为某些原因内存溢出（Out Of Memory，OOM）了，那这个应用就无法正常提供服务了。哪怕是一个很边缘的功能出问题，也会影响到核心业务，这往往是不能接受的。一种解决方案是根据不同的业务独立部署不同的集群，但这样的维护成本比较高。</p>\n<p>如果是微服务应用，情况就不一样了。一个模块出问题，只要处理得当（比如设置了合理的超时时间和服务降级），就不会造成大范围的故障，这就体现出了多模块隔离的好处。<span class=\"comment-number\">1</span> 我们在后续的章节中也会聊到与服务故障处理、服务限流、降级相关的话题。</p>\n<p>但这样的隔离性也不是免费的，由于引入了分布式系统相关的技术，随之而来的问题也必须得到重视，比如网络的问题。远程调用毕竟不是本地调用（虽然看起来很像），我们还是需要细心处理各种异常。所以说，除非确实需要，不要过早地建设分布式系统，单体应用也不是一无是处，选择<strong>合适的架构</strong>才是最重要的。</p>\n</li>\n</ol>\n\n<h2 id=\"nav_point_193\">12.2　RESTful 风格的微服务</h2>\n<p>在理解了什么是微服务之后，随之而来的问题就是怎么设计好的微服务。目前行业内比较主流的观点是在 Web 的大背景下，遵循 REST 架构来设计微服务是比较好的选择。本节就让我们一起来了解一下如何设计 RESTful 风格的微服务。</p>\n<h3 id=\"nav_point_194\">12.2.1　什么是 RESTful 风格的微服务</h3>\n<p>REST 一词最早出现在 2000 年，是由计算机科学家 Roy Thomas Fielding 在博士论文《架构风格与基于网络的软件架构设计》<span class=\"comment-number\">2</span> 中提出的。Fielding 是 Apache HTTP 服务器的核心开发者，也是 HTTP/1.1 协议专家组的负责人。HTTP/1.1 协议于 1999 年成为 IETF 的正式规范，它是如此成功，以至于在 20 多年后的今天仍有大量网站在使用 HTTP/1.1 提供服务。Fielding 对 Web 有着深刻的理解，他在论文中系统地陈述了自己设计 HTTP/1.1 时使用的理论框架，并推导出了一种架构风格—— Representational State Transfer，中文译为“表述性状态转移”，我们通常将其简称为 REST。</p>\n\n<ol>\n<li><p><strong>REST 基础知识</strong></p>\n<p>在《理解本真的 REST 架构风格》一文中，作者李锟这样写道：</p>\n<blockquote>\n<p>REST 是 Web 自身的架构风格。REST 也是 Web 之所以取得成功的技术架构方面因素的总结。REST 是世界上最成功的分布式应用架构风格。</p>\n</blockquote>\n<p>这是对 REST 非常高的评价。文中还指出 REST 是所有 Web 应用都应该遵守的架构设计指导原则。需要特别说明的是，REST 不是某一项具体的技术，它是一种架构风格，用来指导系统的设计，帮助我们做出正确的选择。</p>\n<p>REST 中有个五个关键的概念，分别是<strong>资源</strong>、<strong>资源的表述</strong>、<strong>状态转移</strong>、<strong>统一接口</strong>和<strong>超文本驱动</strong>，它们对于我们理解 REST 很重要。</p>\n<p><strong>资源</strong>（Resource）是一个抽象的概念，可以指服务器上的静态文件、动态请求的处理器、数据库里的表等。要识别系统中的资源，最关键的就是寻找名词，像我们之前的例子中提到的菜单、饮品和订单都是资源。资源是通过 URI 来标识的，所以资源的使用者可以通过资源的 URI 与之交互，最常见的就是用浏览器访问 Web 网站的页面。我们用 curl 命令访问 BinaryTea 的资源也是类似的。</p>\n<p><strong>资源的表述</strong>（Representation）表示的是资源在某个时刻的状态，同一种状态可以有多种不同的格式，例如 JSON、XML、HTML 都是常用的格式。我们可以通过 HTTP 请求头或者 URI 后的参数来指定希望的格式，也可以通过 HTTP 的内容协商机制来确定最终使用的格式，就像 9.3 节里介绍的那样。</p>\n<p><strong>状态转移</strong>（State Transfer）是指在服务端与客户端之间转移状态的表述，通俗点说，通过状态转移可以操作资源，我们平时做的增删改查操作其实都是状态转移。</p>\n<p>要对资源做操作，就需要有能操作的接口。<strong>统一接口</strong>（Uniform Interface）能省去很多麻烦，HTTP/1.1 里就为资源操作定义了一套接口。我们日常就已经接触过这个统一接口了，只是自己可能不知道而已。它包含了 7 种 <code>HTTP</code> 方法（也叫 HTTP 动词，常用的是 <code>GET</code>、<code>POST</code>、<code>PUT</code> 和 <code>DELETE</code>，后面还会讲到其他的）、HTTP 头、HTTP 响应码、内容协商机制、缓存机制和身份认证机制。仔细回想一下，是不是基本都在书中出现过呢？</p>\n<p><strong>超文本驱动</strong>（Hypertext Driven）还有个更响亮的名称——HATEOAS，是 Hypermedia As The Engine Of Application State 的首字母简写，译为“将超媒体作为应用状态的引擎”。资源之间通过超链接相互关联，超链接不仅包含了 URI，更包含了相应的语义（通常是用 <code>ref</code> 来表示的），即通过这个超链接能够做什么。超媒体结合了数据内容与超链接，我们的系统通过超媒体来对外提供资源。客户端可以通过一个入口，自己发现所需的资源，该做哪些操作，只要能够理解超媒体表示的语义即可。这个理念听起来十分先进，甚至还有些“魔幻”，目前也没有太多实现这个理念的案例。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>Richardson 成熟度模型</strong></p>\n<p>想要知道自己的系统设计在多大程度上符合 REST 架构的要求，最好能有个标准。Leonard Richardson 在分析了大量不同类型 Web 服务的设计后，于 2008 年在旧金山 QCon 的演讲 <span class=\"comment-number\">3</span> 中提出了一套成熟度模型，用来指导 RESTful 风格服务的落地，这就是后来为大家所熟知的 Richardson 成熟度模型（Richardson Maturity Model），如图 12-1 所示。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00787.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 12-1　Richardson 成熟度模型示意图</strong></p>\n<p>Richardson 成熟度模型一共分为四个层级，从下往上分别是：</p>\n<ul>\n<li>第 0 级，POX（Plain Old XML）的泥沼（The Swamp of POX）</li>\n<li>第 1 级，资源（Resources）</li>\n<li>第 2 级，HTTP 动词 <span class=\"comment-number\">4</span>（HTTP Verbs）</li>\n<li>第 3 级，超媒体控制（Hypermedia Controls）</li>\n</ul>\n<p>在第 0 级时，整个系统仅将 HTTP 协议作为传输层的协议，没有用到 HTTP 中的任何特性，所以请求使用同一种 HTTP 动词（一般会是 <code>POST</code>）发往同一个 URI。请求的报文中使用不同的内容来区分所要进行的操作，报文的格式通常是 XML，也可以是 JSON 或其他类似形式。</p>\n<p>到了第 1 级，情况稍有好转，至少我们开始识别资源了，这是 REST 中的重要概念，不再完全通过一个 URI 来做交互，不同的资源承担不同的交互角色。但美中不足的是第 1 级中我们还是仅使用一种 HTTP 动词，动词所代表的的语义并未发挥出来。</p>\n<p>第 2 级就弥补了第 1 级的缺陷，不再局限在一种动词上，HTTP/1.1 定义了 7 种动词，各有各的语义，可以用在不同的场景下，具体如表 12-1 所示。表中的安全性是指这个动作是否会对资源造成影响，例如改变状态；幂等性是指对同一个资源发起多次请求的效果是否一致。</p>\n<p><strong>表 12-1　HTTP/1.1 中的 7 种动词</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>动词</th><th>安全性</th><th>幂等性</th><th>用途</th></tr><tr><td><code>GET</code></td><td>是</td><td>是</td><td>获取资源</td></tr><tr><td><code>POST</code></td><td><b>否</b></td><td><b>否</b></td><td>该方法用途广泛，可用于创建或更新一个资源，也可以同时修改多个资源</td></tr><tr><td><code>DELETE</code></td><td><b>否</b></td><td>是</td><td>删除资源</td></tr><tr><td><code>PUT</code></td><td><b>否</b></td><td>是</td><td>更新或者完全替换一个资源</td></tr><tr><td><code>HEAD</code></td><td>是</td><td>是</td><td>获取与 <code>GET</code> 一样的 HTTP 头信息，但没有响应体</td></tr><tr><td><code>OPTIONS</code></td><td>是</td><td>是</td><td>获取资源支持的 HTTP 动词列表</td></tr><tr><td><code>TRACE</code></td><td>是</td><td>是</td><td>让服务器返回其收到的 HTTP 头</td></tr></table>\n\n<p>早期 Web 站点后台的删除操作就是在浏览器里点击一下链接，其实就是对删除的 URI 发起了一次 <code>GET</code> 请求。遇到网络爬虫时，问题就来了，爬虫每访问一个地址就相当于发起了一次 <code>GET</code> 请求，爬着爬着就把 Web 站点里的文章都删完了。这就是对各种 HTTP 动词的误用，如果我们遵循表 12-1 中的要求，使用 <code>DELETE</code> 进行删除，再不济使用 <code>POST</code> 都会比 <code>GET</code> 要强。</p>\n<p>第 3 级成熟度的要求就比较高了，相比事先知道资源的 URI，以及这个 URI 是做什么操作的，超媒体控制仅需要知道一个入口 URI，通过请求这个入口就能找到所有的资源以及后续的操作。因为无须事先约定，客户端完全根据入口 URI 的应答来推断可以执行的操作，这给双方都留下了很大的灵活性。正如前文所说，目前能真正做到超媒体驱动或者超媒体控制的系统并不多见，所以还没有公认的最佳实践，但《REST 实战》<span class=\"comment-number\">5</span> 一书中推荐大家遵循 ATOM（RFC 4287）来设计 HATEOAS 的系统。在 ATOM 中，通过 <code>&lt;link&gt;</code> 来表示超链接，其中的 <code>uri</code> 属性指明了目标资源的 URI，<code>rel</code> 属性用来描述关系类型。Spring 也提供了 Spring HATEOAS 来帮助大家实现满足第 3 级成熟度的系统，不过 Spring HATEOAS 并不在我们目前的讨论范围内，感兴趣的朋友可以自行查阅相关文档。</p>\n</li>\n</ol>\n\n\n\n<h3 id=\"nav_point_195\">12.2.2　设计 RESTful 风格的微服务</h3>\n<p>在对 REST 有了个大概的认识后，下一步就该动手去设计 RESTful 风格的服务了，整个过程大概可以分为四步，下面我们逐一来分解一下。</p>\n<ol>\n<li><p><strong>识别资源</strong></p>\n<p>之前我们反复强调在 REST 中资源是个重要的概念，因此，在设计服务时，我们的第一步就是要找出那些资源。资源通常都是名词，所以要在描述中寻找那些能被操作的领域名词，例如菜单、菜单项、订单这些都是可以拿来当作资源的领域名词。</p>\n<p>资源可大可小，不同粒度的资源适用于不同的场景。仍旧以菜单为例，假设只是一页纸的菜单，大概率只会放菜品的名称和价格，而那种放桌上让客人慢慢翻的整本菜单，内容则会更丰富一些。对于合理地选择资源粒度，可以先从客户端的角度出发，做些权衡：</p>\n<ul>\n<li>可缓存性，资源应该尽可能多地被缓存下来；</li>\n<li>修改频率，为了更多地使用缓存，应减少资源的修改频率；</li>\n<li>可变性，如果资源中的一部分内容经常变更，而另一部分则不太变更，那应该将两者分离开。</li>\n</ul>\n<p>由此可见，我们在大部分情况下都在考虑通过缓存来改善客户端和服务器端的交互效率。其实，还有些更显而易见的点：越是粗粒度的资源，包含的内容就越多，网络上要传输的内容也越多，如果需要频繁交互，但每次只用其中很小的一部分，这就不太划算；但如果是个富客户端，一次交互将尽可能多的内容取回去，然后客户端自己再做处理，那么粗粒度的资源就很合适，这也是从资源对客户端的易用性角度来考虑的。</p>\n<p>对于有相同特性的资源，可以将它们组织成集合资源，像一个整体那样来进行引用，而不用一个个获取单个资源，多个菜单项可以打包成一个菜单资源。对集合资源，可以执行分页、检索和创建新资源等操作。而对于那些有关联关系的资源，则可以考虑将它们组合起来，变成复合资源，这样订单就可以看成一个包含了菜单项、制作者等资源的复合资源。</p>\n<p>除了领域名词，还有一种特殊的情况，比如类似计算和数据验证的任务，可以将诸如此类的处理任务也抽象为资源，例如地图服务中计算两地距离的功能。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>设计 URI</strong></p>\n<p>有了资源，接下来就该设计一个 URI 来标识资源了。URI 中除了资源名称，还可以包含很多内容。好的 URI 应该清晰明了，好读好记。下面让我们简单罗列一些设计 URI 的实践：</p>\n<ul>\n<li>使用域及子域对资源进行合理的分组或划分；</li>\n<li>在 URI 的路径部分使用 <code>/</code> 来表示资源之间的层次关系；</li>\n<li>在 URI 的路径部分使用 <code>,</code> 和 <code>;</code> 来表示非层次元素；</li>\n<li>使用 <code>-</code> 和 <code>_</code> 来改善长路径中名称的可读性；</li>\n<li>在 URI 的查询部分使用 <code>&amp;</code> 来分隔参数；</li>\n<li>在 URI 中避免出现文件扩展名。</li>\n</ul>\n<p>万维网联盟（World Wide Web Consortium）有一篇介绍 URI 风格的文章，它的标题是《酷的 URI 是不会改变的》（Cool URIs don't change）。可见一个好的 URI 是能“流名千古”的，为了让 URI 保持稳定，不太变动，在设计时就要考虑使用稳定的概念。即使在系统的演化过程中，系统的功能发生了变化，发布出去的 URI 也要考虑保留下来，但可以结合一些特定含义的 HTTP 响应码（有时也称 HTTP 状态码）将客户端重定向到新的 URI，例如用 <code>301 Moved Permanently</code>。表 12-2 中列举了一些常</p>\n<p>用的 HTTP 响应码，针对每个请求，我们要选择合适的响应码。</p>\n<p><strong>表 12-2　常用的 HTTP 响应码</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>响应码</th><th>描述</th></tr><tr><td><code>200 OK</code></td><td>表示请求已处理</td></tr><tr><td><code>201 Created</code></td><td>表示请求已处理，并成功创建了一个资源</td></tr><tr><td><code>202 Accepted</code></td><td>表示请求已受理，但尚未处理</td></tr><tr><td><code>204 No Content</code></td><td>表示请求已处理，但是这个返回没有任何内容</td></tr><tr><td><code>301 Moved Permanently</code></td><td>表示所请求的资源已永久移动到新位置</td></tr><tr><td><code>302 Move Temporarily</code></td><td>表示所请求的资源目前临时被移动到了新位置，后续还是应该请求原 URI</td></tr><tr><td><code>304 Not Modified</code></td><td>用来响应带条件的 <code>GET</code> 请求，如果内容没有发生变化，就返回这个响应码</td></tr><tr><td><code>400 Bad Request</code></td><td>表示请求有问题，例如参数不正确</td></tr><tr><td><code>401 Unauthorized</code></td><td>表示当前请求需要进行用户认证</td></tr><tr><td><code>403 Forbidden</code></td><td>表示服务器接收到了请求，但拒绝执行</td></tr><tr><td><code>404 Not Found</code></td><td>表示服务器没有找到要请求的资源</td></tr><tr><td><code>410 Gone</code></td><td>表示当前访问的资源已经不再有效了</td></tr><tr><td><code>500 Internal Server Error</code></td><td>表示服务器遇到了意料之外的错误，通常是服务端的代码有问题</td></tr><tr><td><code>502 Bad Gateway</code></td><td>如果当前访问的是一个网关或者代理，这个响应码表示背后的真实服务器返回了错误的应答</td></tr><tr><td><code>503 Service Unavailable</code></td><td>表示服务器由于临时维护或者负载过高无法处理请求了</td></tr></table>\n\n<p>我们可以大概对响应码做一个划分：<code>2XX</code> 的响应码表示请求已处理，<code>3XX</code> 表示重定向，<code>4XX</code> 表示请求有问题，<code>5XX</code> 则表示服务端有问题。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>选择合适的 HTTP 方法</strong></p>\n<p>设计好了 URI，就可以发起请求了。既然找到的是那些能被操作的资源，那自然就会有对应的操作，CRUD 风格的操作就对应到了 HTTP 的 <code>POST</code>、<code>GET</code>、<code>PUT</code> 和 <code>DELETE</code> 方法，根据表 12-1 我们需要按照实际的场景选择合适的 HTTP 方法，尤其要注意对应 URI 的实现逻辑是否满足安全性和幂等性的要求。我们的二进制奶茶店里就有很多能拿来做例子的 URI 与 HTTP 方法组合，表 12-3 中列出了其中的一部分。</p>\n<p><strong>表 12-3　二进制奶茶店中可以用到的一些 URI 与 HTTP 方法组合</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>URI</th><th>HTTP 方法</th><th>说明</th></tr><tr><td><code>/menu</code></td><td><code>GET</code></td><td>获取菜单信息，其中包含了多个菜单项</td></tr><tr><td><code>/menu</code></td><td><code>POST</code></td><td>向菜单中添加新菜单项</td></tr><tr><td><code>/menu/</code></td><td><code>GET</code></td><td>获取特定 ID 的菜单项内容</td></tr><tr><td><code>/menu/</code></td><td><code>PUT</code></td><td>修改特定 ID 的菜单项内容</td></tr><tr><td><code>/menu/</code></td><td><code>DELETE</code></td><td>删除特定 ID 的菜单项</td></tr></table>\n\n<p>&nbsp;</p>\n</li>\n<li><p><strong>设计资源的表述</strong></p>\n<p>如果资源的 URI 看起来比较抽象，那资源的表述就是看得见摸得着的东西了，因为服务端返回给客户端的东西就是资源的表述，它表示资源特定时刻的状态。表述分为两个部分——HTTP 头和正文。</p>\n<p>HTTP/1.1 中定义了很多 HTTP 头，实际上我们使用的 Web 框架和 Web 容器能替我们处理大部分常用 HTTP 头，除了自定义的一些头，或者有特殊含义的头，我们并不需要自己来设置 HTTP 头，表 12-4 中是一些常用的 HTTP 头。</p>\n<p><strong>表 12-4　常用的 HTTP 头</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>HTTP 头</th><th>说明</th></tr><tr><td><code>Content-Type</code></td><td>表示表述的内容类型，例如 <code>application/json;charset=UTF-8</code></td></tr><tr><td><code>Content-Length</code></td><td>表示内容的长度。从 HTTP/1.1 开始，可以用 <code>Transfer-Encoding: chunked</code> 来启用分块传输编码（chuncked transfer encoding）机制，如果用了这个头，可以不用 <code>Content-Length</code></td></tr><tr><td><code>Content-Encoding</code></td><td>表示正文使用了压缩类型，值可以是 <code>gzip</code>、<code>compress</code> 或 <code>deflate</code>，客户端可以用 <code>AcceptEncoding</code> 头来标明自己能接受的压缩类型</td></tr><tr><td><code>Content-Language</code></td><td>表示内容的语言，例如 <code>en-US</code> 和 <code>zh-CN</code></td></tr><tr><td><code>Cache-Control</code></td><td>控制缓存相关的属性</td></tr><tr><td><code>Last-Modified</code></td><td>表示服务端最后修改当前资源表述的时间戳</td></tr><tr><td><code>Etag</code></td><td>表示服务端对象的标签，和 <code>If-None-Match</code> 搭配，如果标签未发生改变，就直接返回 <code>304 Not Modified</code> 响应码</td></tr><tr><td><code>Location</code></td><td>搭配 3XX 的响应码使用，给出跳转的目标 URI</td></tr><tr><td><code>X-Forwarded-For</code></td><td>当服务器在负载均衡设备之后时，通过这个头来传递真实客户端的 IP</td></tr></table>\n\n<p>如果 HTTP/1.1 提供的 HTTP 头不能满足我们的需求，可以在 HTTP 头部增加自定义的头，这类头通常使用 <code>X-</code> 开头，就像上表中的 <code>X-Forwarded-For</code> 那样。</p>\n<p>资源表述的正文可以用各种媒体类型（就是大家通常所说的 MIME 类型）来呈现，服务端用的哪种类型就在 <code>Content-Type</code> 头里写上哪种类型。表 12-5 罗列了一些常用的 MIME 类型。完整的媒体类型清单，可以到 IANA<span class=\"comment-number\">6</span> 的相关页面上去查看。</p>\n<p><strong>表 12-5　常用的 MIME 类型</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>MIME 类型</th><th>说明</th></tr><tr><td><code>application/javascript</code></td><td>JavaScript 类型</td></tr><tr><td><code>application/json</code></td><td>JSON 类型</td></tr><tr><td><code>application/pdf</code></td><td>Adobe 的 PDF 类型</td></tr><tr><td><code>application/xml</code></td><td>XML 类型</td></tr><tr><td><code>application/x-www-form-urlencoded</code></td><td>做过编码转换的表单类型</td></tr><tr><td><code>multipart/form-data</code></td><td>分段表单数据类型</td></tr><tr><td><code>text/css</code></td><td>CSS 样式表类型</td></tr><tr><td><code>text/csv</code></td><td>CSV 类型（用逗号分隔的文本）</td></tr><tr><td><code>text/html</code></td><td>HTML 类型</td></tr><tr><td><code>text/plain</code></td><td>纯文本类型</td></tr><tr><td><code>image/png</code></td><td>PNG 图形类型</td></tr></table>\n\n<p>对于那些用文本来表示的类型，我们还要尽量避免字符编码不匹配的问题——大家花在转码问题上的时间着实不算少。在发送表述时，如果所选的媒体类型支持使用 <code>charset</code> 参数，那我们可以通过这个参数来指定字符编码，就像下面这样：</p>\n<pre class=\"code-rows\"><code>Content-Type: application/xml;charset=UTF-8</code></pre>\n<p>目前在 RESTful 风格的微服务中使用比较多的媒体类型是 <code>application/json</code> 和 <code>application/xml</code>，如果这个资源的表述是给人看的，那可以选择 <code>text/html</code>，二进制奶茶店的例子就是这样来实现的。至于怎么生成对应的 JSON、XML 或 HTML 内容，就交给框架来处理吧，我们在第 9 章里已经讨论过这个话题了。</p>\n<p>最后，我们讨论一下如何表示错误。表 12-2 中的 <code>4XX</code> 与 <code>5XX</code> 响应码分别表示客户端和服务端的错误，我们需要合理地选择其中的响应码来告诉服务调用者发生了什么问题，并在正文中提供一些具体的错误描述。<strong>切忌不分青红皂白地将所有应答都设置为 2XX 响应码，然后通过正文中的结果码来表示处理结果。</strong><span class=\"comment-number\">7</span></p>\n</li>\n</ol>\n\n\n<h3 id=\"nav_point_196\">12.2.3　了解领域驱动设计</h3>\n<p>2020 年的 QCon 全球软件开发大会上海站，开设了一个微服务专场，主题是“微服务的‘道’与‘术’”。大多数人将自己的精力集中在微服务的实现技术上，例如怎么去做微服务的注册与发现，怎么做微服务的限流，却不怎么关心怎么更好地设计微服务——这个主题要强调的一点就是“<strong>开发微服务，设计先行</strong>”。</p>\n<p>无独有偶，时钟再往前拨到 2017 年，在 ThoughtWorks 举办的第一届 DDD 中国峰会上，也有人提出了类似的观点：</p>\n<blockquote>\n<p>不可否认，很多人是因为微服务才了解 DDD 的。但是当他们实际去做微服务架构的时候，会发现自己做得并不好，“就算用了微服务架构也不能解决他们的问题，反而会带来很多开发与运维上的负担”。于是他们去咨询、去找方法，最后发现其实是自己划分微服务的方法出错了，这个时候才知道人们在谈论微服务的时候，其实都没有讲到一个点：应该用 DDD 的思想去指导微服务的实践。</p>\n</blockquote>\n<p>设计对于微服务的重要性由此可见一斑，更准确地说是 DDD（Domain-Driven Design，领域驱动设计）的重要性。DDD 一词最早是 Eric Evans 在 2003 年出版的 <em>Domain-Driven Design: Tackling Complexity in the Heart of Software</em><span class=\"comment-number\">8</span> 一书中提出的，是一种针对复杂需求的软件开发方法。DDD 将软件的实现与不断演进的核心业务概念模型连接在了一起，可以帮助我们设计出高质量的软件。</p>\n\n<p>相信有不少人开发软件是以数据表为中心的，拿到需求后先想这个数据该怎么存储，然后设计几张表，剩下的就是对这几张表的增删改查操作，可谓“一顿操作猛如虎”。是时候把以数据表为中心的思想改改了，也许领域模型才是更应该关注的。按照 Eric Evans 的定义 <span class=\"comment-number\">9</span>，所谓<strong>领域</strong>，是知识、影响或活动的范围，例如，金融系统里的账务是一个领域，清结算是一个领域，奶茶店的相关知识也是一个领域。领域还可以被拆成多个不同的子域，其中比较重要的就是核心域。而<strong>模型</strong>则是指一个抽象的系统，描述了领域的某些方面，可用于解决与该领域有关的问题。</p>\n\n<p>除了领域和模型，DDD 中还有不少重要的概念，表 12-6 就列举了其中的一些。</p>\n<p><strong>表 12-6　DDD 中的一些重要概念</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>概念</p></th>\n<th><p>说明</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>通用语言</p></td>\n<td><p>围绕领域模型建立的一种语言，有时也称为“统一语言”</p></td>\n</tr>\n<tr>\n<td><p>限界上下文</p></td>\n<td><p>特定模型的限界应用，通俗一点儿说就是一个有范围的语境</p></td>\n</tr>\n<tr>\n<td><p>实体</p></td>\n<td><p>一种对象，它不是由属性来定义的，而是通过一连串的连续事件和标识定义的</p></td>\n</tr>\n<tr>\n<td><p>值对象</p></td>\n<td><p>一种描述了某种特征或属性但没有概念标识的对象</p></td>\n</tr>\n<tr>\n<td><p>存储库</p></td>\n<td><p>一种把存储、检索和搜索行为封装起来的机制，它类似于一个对象集合</p></td>\n</tr>\n<tr>\n<td><p>领域服务</p></td>\n<td><p>当领域中的某些操作不是实体或值对象的职责时，就将它们放到特殊的接口里，这些接口就是领域服务</p></td>\n</tr>\n</tbody>\n</table>\n<p>DDD 强调<strong>要让领域专家与开发人员走到一起</strong>，这样开发出的软件才能真正反映出领域专家的思想。团队所有成员都使用通用语言把团队的所有活动与软件联系起来，大家都能站在同一个维度交流，不会出现“鸡同鸭讲”的尴尬场面，这也有助于减少大家的分歧。不同的领域一般都对应了自己的限界上下文，这使团队所有成员能够明确地知道什么必须保持一致，什么必须独立开发。通常，在不同的限界上下文里会有不同的通用语言，例如，同样是货物，在商城货架上的货物，和在物流系统里流转的货物就会有不同的属性。</p>\n<p>在工作中，很多公司都会按照不同的业务来组织团队，组织结构会与业务架构对齐，而业务架构又与系统架构对齐。这时很可能一个团队就会对应一个或多个领域，或者说限界上下文。在实际开发时，一个限界上下文很可能就是一个项目工程。如果能做到这样的一一对应，那真是幸运的。</p>\n<p>要实施 DDD，大致可以分为下面几个步骤：</p>\n<p>(1) 理解业务需求，根据需求初步划分领域和限界上下文，明确上下文之间的关系；</p>\n<p>(2) 详细分析限界上下文的情况，识别出实体和值对象，明确它们的关系，找出聚合根；</p>\n<p>(3) 为聚合根设计存储库，细化实体和值对象的各种操作方式；</p>\n<p>(4) 在实践过程中打磨领域模型，进行验证和重构。</p>\n<p>关于第 (2) 步，需要详细展开一下。实体和值对象有时还是比较难区分的：实体有自己的生命周期，有明确的业务含义，有自己的状态机，状态会发生变化；而值对象就没有这么多东西，它只关心值本身，并不关心值会怎么变化。聚合根本质上也是一个实体，所以我们是先找实体，再找聚合根，生命周期长的实体往往更可能是聚合根。</p>\n<p>上面说的只是最粗、最简单的 DDD 实施步骤，DDD 博大精深，仅凭三两句话是没有办法讲透彻的。如果大家对 DDD 感兴趣的话，可以阅读一下《领域驱动设计：软件核心复杂性应对之道》《实现领域驱动设计》《领域驱动设计精粹》等经典著作。</p>\n<h2 id=\"nav_point_197\">12.3　理解云原生</h2>\n<p>以前的应用都直接部署在机房的服务器上，那些“古董级”的应用可能要占用一台小型机，谁都不想去动它。时代不同了，随着去 IOE 浪潮的兴起和云计算技术的普及，越来越多的系统被放到了云上，慢慢地就有了“云原生”（Cloud Native）。这一节就让我们来聊聊云原生应用。</p>\n<h3 id=\"nav_point_198\">12.3.1　什么是云原生应用</h3>\n<p>“云原生”的概念最早是由 Pivotal 的 Matt Stine 在 2013 年提出的。云原生并不是一项特定的技术或者框架，与微服务类似，把它看成一套思想也许更为恰当。云原生计算基金会（Cloud Native Computing Foundation，CNCF）在其官网的文档中是这么介绍云原生的：</p>\n<blockquote>\n<p>云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式 API。</p>\n<p>这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统作出频繁和可预测的重大变更。</p>\n</blockquote>\n<p>从这段描述中，我们可以抽取出以下关键点：</p>\n<ul>\n<li>云原生应用能部署在多种不同的云环境中，对云有良好的支持；</li>\n<li>云原生应用具备一定的可扩展性、容错性和可观察性；</li>\n<li>云原生应用是一套松耦合的分布式系统；</li>\n<li>有大量不同的技术在支撑着云原生应用。</li>\n</ul>\n<p>其中的第四点值得重点展开解释一下——云原生并没有自己去发明创造一系列的新技术，而是充分利用现有的技术，结合了大量的最佳实践。例如，云原生应用运行的云环境就可以构建在目前主流的 IaaS 和 PaaS 上 <span class=\"comment-number\">10</span>，与 Kubernetes 等容器技术可以无缝整合。</p>\n\n<p>在主流的观点中，云原生目前有四个要素：<strong>持续交付</strong>、<strong>DevOps</strong>、<strong>微服务和容器</strong>。持续交付和 DevOps 更偏工作方式与文化一些，鼓励采用更敏捷的方法，让驱动团队更高效地交付有价值的产品和服务。微服务和容器则更偏架构和技术一些：微服务在 12.1 节中已经介绍过了，此处不再赘述；容器技术将运行时的差异封装在容器中，平台可以统一管理我们的应用，容器化也让我们能更高效地利用资源，实现弹性资源调度。</p>\n<p>云原生对基础设施提出了较高的要求，不仅是底层的云平台，周边的生态也是一样。在本书中，我们后续要介绍的 Spring Cloud 就能让基于 Spring 开发的应用快速满足弹性、可伸缩、高可用等多项云原生的要求。而对非 Spring Cloud，或者是非 Java 开发的应用，就没有这样完善的设施，于是就有人提出将某些基础能力从应用的 SDK 剥离到独立的 Side Car<span class=\"comment-number\">11</span> 中，其中最为知名的实现就是 Envoy。目前最流行的服务网格 <span class=\"comment-number\">12</span> 实现 Istio 就依赖了 Envoy。</p>\n\n\n<p>ODCA（Open Data Center Alliance，开放数据中心联盟）2014 年发表了一篇论文 <span class=\"comment-number\">13</span>，为云上的应用建立了一个成熟度模型，一共分为 4 个层级，具体见表 12-7。</p>\n\n<p><strong>表 12-7　ODCA 的云应用成熟度模型</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>层级</p></th>\n<th><p>成熟度</p></th>\n<th><p>说明</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>第 0 级</p></td>\n<td><p>虚拟化（Virtualized）</p></td>\n<td><p>让应用能跑在不同的虚拟机或云实例上，通过脚本或镜像完成应用的初始化。可以通过创建不可变的应用镜像（例如 Docker 镜像）来实现这一层</p></td>\n</tr>\n<tr>\n<td><p>第 1 级</p></td>\n<td><p>松耦合（Loosely coupled）</p></td>\n<td><p>应用要与底层设施分离，起码要做到应用与存储的分离，例如应用系统和数据库不在一起，应用不依赖于 NAS 存储。应用各模块之间也要是松耦合的。各服务之间要通过名称来实现服务的发现</p></td>\n</tr>\n<tr>\n<td><p>第 2 级</p></td>\n<td><p>抽象化（Abstracted）</p></td>\n<td><p>这一级不仅要求实现对运行环境的抽象，对相关的各种流程也要能抽象出来，例如部署、弹性扩缩容等。为此，服务必须是无状态的，还要求应用能够容忍所依赖的服务的故障</p></td>\n</tr>\n<tr>\n<td><p>第 3 级</p></td>\n<td><p>适应性（Adaptive）</p></td>\n<td><p>应用程序需要能够自动适配各种环境的变化，自动基于流量进行弹性伸缩。还要能够在不中断业务的前提下实现在不同云服务厂商之间的迁移</p></td>\n</tr>\n</tbody>\n</table>\n<p>这里的成熟度是从上往下排列的，第 0 级要求最低，第 3 级则最高，尤其是其中在不同云厂商之间的迁移，更是困难重重。一般情况下，只要使用了合适的架构和基础设施，云原生应用基本还是能达到第 2 级成熟度的。</p>\n<h3 id=\"nav_point_199\">12.3.2　十二要素应用</h3>\n<p>在提到云原生应用时，通常我们还会聊到十二要素应用（The Twelve-Factor App），这是由知名 PaaS 平台 Heroku 的 CTO Adam Wiggins 提出的。十二要素应用说的是在云上运行的应用需要遵守的 12 条最佳实践，但它其实也同样适用于云原生应用。在 12.3.1 节的最后我们介绍了 ODCA 的云应用成熟度模型，这并非是唯一的成熟度模型，摩根大通 <span class=\"comment-number\">14</span> 的 Allan Beck 和 John McTeague 也设计了一套成熟度模型，具体如表 12-8 所示。</p>\n\n<p><strong>表 12-8　摩根大通的云应用成熟度模型</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>成熟度</p></th>\n<th><p>说明</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>云原生（Cloud Native）</p></td>\n<td><p>遵循微服务架构与原则，设计良好的 API 来提供服务</p></td>\n</tr>\n<tr>\n<td><p>云弹性（Cloud Resilient）</p></td>\n<td><p>对故障有一定的容忍度，遵循 DevOps 的思想，不依赖于特定的云厂商</p></td>\n</tr>\n<tr>\n<td><p>云友好（Cloud Friendly）</p></td>\n<td><p>充分利用平台来实现高可用，能够水平伸缩，符合十二要素应用</p></td>\n</tr>\n<tr>\n<td><p>云就绪（Cloud Ready）</p></td>\n<td><p>自包含应用，对文件系统没有依赖，完全托管在云平台上</p></td>\n</tr>\n</tbody>\n</table>\n<p>可以看到，十二要素应用被明确列在这个成熟度模型的“云友好”一级中，它是云原生的基础要求之一，所以有必要来了解一下这十二条实践。</p>\n<ol>\n<li><p><strong>基准代码</strong></p>\n<p>一份基准代码（codebase），多份部署。</p>\n<p>相信在正规的公司中，大部分代码都会托管在代码仓库里，哪怕是自己个人时间开发的代码通常也会放在 GitHub 或者其他代码托管服务上，所以使用代码版本管理系统已经成为行业共识了。基准代码指的是主干代码（SVN 里是 <code>trunk</code> 分支，Git 里是 <code>master</code> 分支或者 <code>main</code> 分支），一份基准代码就是一个应用，分布式系统中的每个应用都有自己的基准代码。但这个关系并非是一一对应的，一份基准代码可以存在多份部署，设想以下场景。</p>\n<ul>\n<li>线上存在多套环境，用户验收测试 UAT 环境、灰度环境、生产环境，这时会把同一份基准代码（或者说应用）部署在这几个不同的环境里，而且这几套环境中的代码很可能不是同一个版本的。</li>\n<li>相同的系统通过开关或者配置，实现不同的功能，例如一个网关系统，可以在入口处部署一套做流入网关，也可以在出口处部署一套做流出网关，这本质上也是“一套基准代码，多份部署”。</li>\n</ul>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>依赖</strong></p>\n<p>显式声明依赖关系。</p>\n<p>大部分主流的编程语言都提供了依赖管理的工具，在 Java 中 Maven 和 Gradle 都非常出色，我们通过它们可以很方便地显式管理 Java 库之间的依赖。除了 Java 类库的依赖，我们也不能隐式地依赖系统的各种工具和库，如果有需要，也要显式声明这层关系。好在容器早已是一项相对成熟的技术了，我们可以将所有的环境依赖都配置在 Dockerfile 里，导出的镜像就包含了所有的依赖。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>配置</strong></p>\n<p>在环境中存储配置。</p>\n<p>在第一条“基准代码”中我们提到了一份基准代码会有多份部署，在这些部署之间往往都是存在配置差异的，那该如何处理这些配置呢？首先，配置与代码必须分开存放，这是不可打破的铁律。如果选择配置文件，那必须要避免配置文件被误传入代码仓库，Spring Boot 的配置文件可以独立放在不同于 Jar 包的目录里，这样失误概率能小不少。</p>\n<p>十二要素建议将配置存储在环境中，这里的环境更多是指环境变量，例如，在 Linux 中我们可以通过 <code>JAVA_OPTS</code> 来指定 Java 进程运行的参数。在 Docker 容器中，环境变量可以配置在 Dockerfile 里，也可以在运行时传入设置。但在实际操作中，我们也许会更倾向于将配置保存在配置中心里，配置中心可以实现配置项集中管理、变更实时推送等各种功能，在后续的章节里我们会做相应的介绍。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>后端服务</strong></p>\n<p>把后端服务（backing services）当作附加资源。</p>\n<p>这里的后端服务指应用运行所需的各种服务，例如数据库、消息队列和 Redis 等。应用会通过网络来调用这些服务，要将这些服务视为自己所依赖的资源。除了我们自己部署的服务，实际也有可能会用到外部第三方的一些服务。十二要素应用并不会严格区分这两种服务，它们都是程序运行时依赖的资源，必要时这些资源甚至还能互相替换，而这类改动都不需要修改代码，改几行配置就行了。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>构建、发布、运行</strong></p>\n<p>严格分离构建和运行。</p>\n<p>从编写完毕的代码到能实际运行的系统，当中会经过很多步骤，至少应该有构建、发布和运行这几个环节。构建对 Java 系统而言就是将代码编译为 class 文件，随后按需打包为 JAR、WAR 或 EAR 包；发布是将打包的产物与对应配置一同部署到指定环境（服务器或容器）；运行是将要发布的内容启动起来，例如将部署了 WAR 包的 Tomcat 容器启动起来，或者是用 <code>java -jar</code> 命令执行 Spring Boot 工程构建出的可执行 JAR 包。</p>\n<p>对于十二要素应用而言，构建、发布和运行这三个步骤是严格分离且顺序执行的。实际上，代码一旦开发完毕，触发持续集成构建产物后，从测试阶段开始就应该始终使用上一步构建的产物，一直到发布与运行。如果有问题需要修改，就要退回重新构建，而不是在要最终运行的包里直接修改。一个合格的运维平台，会对每个构建的产物、每次的发布动作都进行记录，做到版本化，最终再选择要运行哪个版本。如果最新发布的版本有问题，将发布回滚到上一个可稳定运行的版本，重新运行就可以了。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>进程</strong></p>\n<p>以一个或多个无状态进程运行应用。</p>\n<p>我们运行的应用程序都是以进程的方式存在于系统中，比如 Java 程序在运行时就是一个 <code>java</code> 进程。这条最佳实践的重点在于无状态，如果不同进程的内存中保存了不同的内容，那这种进程不符合十二要素应用的要求。例如在 11.3.1 节介绍常见负载均衡时提到过的会话保持，就是将会话状态保持在特定的服务器进程中，这就是个常见的反面案例，十二要素应用更倾向于将会话保存在分布式缓存或者其他后端存储里。有一种说法，进程在十二要素应用中是“一等公民”。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>端口绑定</strong></p>\n<p>通过端口绑定提供服务。</p>\n<p>在单机应用的时代，会有进程间通信这样的交互方式。在分布式系统中，大家早就熟悉了容器或者应用系统自己监听一个端口对外发布服务的方式，通过这个端口其他系统就能发起远程调用，这与第 4 条实践“后端服务”所倡导的内容是互相呼应的。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>并发</strong></p>\n<p>通过进程模型进行扩展。</p>\n<p>说到扩展，大家会想到使用更多节点进行“水平扩展”，也可以使用更多 CPU、内存和磁盘等资源进行“垂直扩展”。在十二要素应用需要进行扩展时，会优先考虑部署更多的进程，通过更多的进程进行水平扩展。无论是在同一台机器上启动更多的进程，还是在 Kubernetes 集群中启动更多的 Pod，都可以视为部署更多进程，其本质是一样的。能采取这种方式得益于第 6 条实践，要求所有进程都是无状态的，只有这样才能方便地进行扩展。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>易处理</strong></p>\n<p>快速启动和优雅终止可最大化健壮性。</p>\n<p>这里说的“易处理”，指的是在进程的启动和停止时能更方便地处理。快速启动很好理解，启动越快，发布时间越少，在需要弹性伸缩时，达到目标容量所需的时间就越短。优雅终止则需要解释一下，应用在停止时如果不做处理，往往还有些任务在上面运行，或者有流量跑在上面，如果直接粗暴地停止进程，那这些任务或者请求就会失败，这种失败是我们不想看到的，也是可以避免的。因此，在停止前，我们可以先关掉这个节点的流量，不让进程接收新的请求，不收新的消息，不跑新的调度，总之就是让已经落到上面的工作执行完，同时也不再接收新的工作。这样一来可以尽可能避免进程终止带来的业务影响。</p>\n<p>除此之外，面对无法做到优雅终止的情况，例如物理机宕机、网络中断等，十二要素应用也要求我们能尽量从故障中自动恢复，通过各种手段降低故障带来的损失。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>开发环境与线上环境等价</strong></p>\n<p>尽可能地保持开发、预发布、线上环境相同。</p>\n<p>保持各个环境相同，这条要实现的目标比较好理解，但需要注意其中强调的“尽可能”——出于成本、资源等方面的考虑，通常在开发和测试环境中很难做到与产线一致。例如，测试环境的规模会和产线规模不同，这在一定程度上是可以接受的。但在基础设施上要尽可能保持一致，产线是 MySQL 和 Redis，到了测试环境不要换成 PostgreSQL 和 Memcached。在开发时，虽然目前我们可以用 Docker 很方便地在笔记本电脑上启动各种组件，但如果依赖很多，就很难在一台笔记本电脑上启动所有的东西。如果需要用 Oracle 或者 SQL Server 数据库，那就更麻烦了。所以在开发过程中，做单机自测的时候还是会做些变通。除了开发用的笔记本电脑上的环境以外，尽可能保持其他环节的各种依赖、配置与生产一致。差异越少，就越有可能发现问题。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>日志</strong></p>\n<p>把日志当作事件流。</p>\n<p>运行在生产环境中的应用程序不像在笔记本电脑上，遇到问题可以随时调试。运行中的程序一定要输出必要的日志信息，再结合监控，不然连程序究竟在干什么都说不清。一般的 Java 程序，我们会用 Log4J 或者 LogBack 这样的日志框架将日志输出到文件里。十二要素应用不建议通过应用管理日志文件，建议把日志输出到 <code>STDOUT</code> 和 <code>STDERR</code> 里，然后由 Logstash 或者 Fluentd 这样的工具将标准输入输出收集起来。</p>\n<p>个人建议我们可以做个变通，继续分门别类地输出日志文件，但不要仅仅将文件保存在本地，同样应该使用 Logstash 或者 Fluentd 将这些文件以流的方式收集起来，然后统一处理。像 ELK<span class=\"comment-number\">15</span> 这样的组合已经非常成熟了，可以应付日常的基本日志查询需求，收集上来的日志也可以集中归档存储，或者转储到大数据平台里进行进一步的分析。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>管理进程</strong></p>\n<p>后台管理任务当作一次性进程运行。</p>\n<p>关于这条实践，多少有些 Heroku 等 PaaS 平台的特殊性在里面，个人感觉它并不是个普适的实践。对于一些并不常用的管理任务，我们的确可以写个简单的脚本或者工具，需要时跑一下；但更多的时候，系统后台的任务是各种常规操作，有个管理后台也许更加方便，而且这个后台除了基本的功能，还要添加权限管理等各种额外的能力。</p>\n<p>不过，十二要素应用强调要像对待常规任务进程那样来对待后台管理任务的进程。推而广之，我们也不该仅将注意力集中在主逻辑上，后台管理平台的各种功能也是要关注的。很多公司甚至有专门开发、维护后台系统的团队，这也是系统重要的组成部分。</p>\n</li>\n</ol>\n\n<h3 id=\"nav_point_200\">12.3.3　Spring Cloud 概述</h3>\n<p>前面我们聊了微服务，聊了云原生，那怎么才能方便、快捷地开发出符合最佳实践的云原生系统呢？答案是不仅要实现业务的功能性需求，更要实现业务没有提到的那些非功能性需求，例如服务发现、配置管理、服务降级、链路追踪等。随着系统的发展，自身逐步演化出这些功能自然是一种方法，但那样不仅耗时，还可能重复各种别人已经踩过的坑，中小公司往往无法负担这样的成本。是否可以站在巨人的肩膀上，由专业人士将大量的实践沉淀到一套工具或者框架中，就像 Spring Framework 对于 Java 企业级应用的意义那样？答案是肯定的，而且这套框架还是由 Spring Framework 的团队打造的，它就是本书后续部分会着重展开介绍的 Spring Cloud。在 1.1 节中我们已经对 Spring Cloud 做了个大概的介绍，此处再详细展开一下。</p>\n<p>Spring Cloud 通过框架的方式对大量云原生应用开发过程中需要考虑的问题做了抽象。在统一的抽象层之下，随着底层组件的不同，会有不同的实现，但这些差异都被 Spring Cloud 屏蔽掉了，这正是 Spring 家族一贯带给开发者的那种一致的体验。早期，Spring Cloud 提供的大量功能是与 Netflix 打配合的，封装了 Netflix 的开源组件，例如 Eureka 和 Ribbon。如今，Spring Cloud 提供的东西会更多样化，支持更多的场景，甚至对不同的云厂商也有各自的适配，例如国外的亚马逊 AWS、微软 Azure 和谷歌 GCP，像国内使用较多的阿里云也在支持范围内，阿里还专门开发了 Spring Cloud Alibaba 开源项目并整合进了 Spring Cloud 大家庭里。</p>\n<p>Spring Cloud 为我们统一管理了下面的子项目版本和各种依赖，我们可以手动在项目中导入这些依赖，就像下面这样：</p>\n<pre class=\"code-rows\"><code>&lt;properties&gt;\n    &lt;spring.cloud-version&gt;2021.0.1&lt;/spring.cloud-version&gt;\n&lt;/properties&gt;\n&lt;dependencyManagement&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;\n            &lt;version&gt;$&lt;/version&gt;\n            &lt;type&gt;pom&lt;/type&gt;\n            &lt;scope&gt;import&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/dependencyManagement&gt;</code></pre>\n<p>随后通过表 12-9 中罗列的这些常用的 Spring Cloud 起步依赖来引入对应的能力。</p>\n<p><strong>表 12-9　常用的 Spring Cloud 起步依赖</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>名称</p></th>\n<th><p>依赖 <span class=\"comment-number\">16</span></p></th>\n<th><p>说明</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>Spring Cloud Alibaba</p></td>\n<td><p><code>spring-cloud-starter-alibaba-*</code></p></td>\n<td><p>对阿里云及相关开源组件的各种支持</p></td>\n</tr>\n<tr>\n<td><p>Spring Cloud Config</p></td>\n<td><p><code>spring-cloud-starter-config</code></p></td>\n<td><p>提供了分布式系统中的服务端与客户端配置能力</p></td>\n</tr>\n<tr>\n<td><p>Spring Cloud Consul</p></td>\n<td><p><code>spring-cloud-starter-consul-*</code></p></td>\n<td><p>提供了对 HashiCorp Consul 的支持，它可以用于服务的注册发现、配置管理等多个方面</p></td>\n</tr>\n<tr>\n<td><p>Spring Cloud Gateway</p></td>\n<td><p><code>spring-cloud-starter-gateway</code></p></td>\n<td><p>基于 Spring WebFlux 提供了一套简单高效的微服务网关</p></td>\n</tr>\n<tr>\n<td><p>Spring Cloud Netflix</p></td>\n<td><p><code>spring-cloud-starter-netflix-*</code></p></td>\n<td><p>提供了对 Netflix OSS 各开源组件的整合支持，例如 Eureka、Hystrix 和 Zuul 等</p></td>\n</tr>\n<tr>\n<td><p>Spring Cloud OpenFeign</p></td>\n<td><p><code>spring-cloud-starter-openfeign</code></p></td>\n<td><p>提供了对 OpenFeign 的支持，这是一款 REST 客户端</p></td>\n</tr>\n<tr>\n<td><p>Spring Cloud Sleuth</p></td>\n<td><p><code>spring-cloud-starter-sleuth</code></p></td>\n<td><p>提供了对服务治理相关功能的支持</p></td>\n</tr>\n<tr>\n<td><p>Spring Cloud Stream</p></td>\n<td><p><code>spring-cloud-starter-stream-*</code></p></td>\n<td><p>提供事件驱动微服务所需的消息系统支持</p></td>\n</tr>\n<tr>\n<td><p>Spring Cloud Zookeeper</p></td>\n<td><p><code>spring-cloud-starter-zookeeper-*</code></p></td>\n<td><p>提供了对 Apache Zookeeper 的支持，它可以用于服务的注册发现、配置管理等多个方面</p></td>\n</tr>\n</tbody>\n</table>\n\n<h2 id=\"nav_point_201\">12.4　小结</h2>\n<p>本章我们大致了解了一下目前流行的微服务架构，什么是微服务，微服务带来了哪些好处。在介绍什么样的微服务可以算好的微服务时，我们聊了 RESTful 风格的微服务。关于领域驱动设计，虽然用的篇幅不大，但要做好微服务，必须设计先行，因此强烈建议大家做些关于 DDD 的拓展阅读。最后还谈到了云原生应用，这可以看成未来几年的发展方向——理解什么是云原生，如何实施云原生是有实际意义的。</p>\n<p>本书后续一些章节将围绕如何基于 Spring 系列框架和各种基础设施实现云原生微服务来展开，例如，接下来的第 13 章就会谈到微服务的注册与发现机制。</p>\n\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"第四部分 使用 Spring 开发微服务","id":740885},"right":{"article_title":"第 13 章 服务注册与发现(1)","id":740887}},"comments":[]}