{"id":475111,"title":"11 | Loadbalancer 实战：通过自定义负载均衡策略实现金丝雀测试","content":"<p>你好，我是姚秋辰。</p><p>上一课我们学习了如何借助Nacos的服务发现机制获取可用服务节点列表，并发起远程服务调用。在服务调用的环节里，还有一处细节需要你思考一下：Nacos通过服务发现拿到了所有的可用服务节点列表，但服务请求只能发给一个节点，你知道服务调用是根据什么规则选择目标节点的吗？</p><p>“小孩子才做选择，大人全都要”，Nacos就是这个全都要的大人。服务列表都被它拿到了手里，但如果要完成一次完整的服务调用，它还需要一个小孩子帮忙做选择，这个做选择题的小孩就是客户端负载均衡组件Spring Cloud Loadbalancer，它根据负载均衡规则，从Nacos获取的服务列表中选取服务调用的目标地址。</p><p>那么，Loadbalancer背后是如何工作的呢？今天我就带你了解Spring Cloud御用负载均衡器Loadbalancer的原理。通过这节课，你可以收获以下内容。</p><ol>\n<li><strong>负载均衡的作用</strong>：了解负载均衡的两大门派，它们分别是网关层负载均衡和客户端负载均衡。你还会理解客户端负载均衡在微服务架构中的优势；</li>\n<li><strong>Loadbalancer工作原理</strong>：了解Loadbalancer如何运用@Loadbalanced注解进行加载；</li>\n<li><strong>自定义负载均衡策略</strong>：了解Loadbalancer的自定义扩展点，在实战项目中实现金丝雀测试。</li>\n</ol><!-- [[[read_end]]] --><p>接下来，我们先来看一下负载均衡在微服务中的作用。</p><h2>为什么需要负载均衡</h2><p>俗话说在生产队薅羊毛不能逮着一只羊薅，在微服务领域也是这个道理。面对一个庞大的微服务集群，如果你每次发起服务调用都只盯着那一两台服务器，在大用户访问量的情况下，这几台被薅羊毛的服务器一定会不堪重负。</p><p>因此，我们需要<strong>将访问流量分散到集群中的各个服务器上</strong>，实现雨露均沾，这就是所谓的“<strong>负载均衡技术</strong>”。</p><p>道理是这个道理，但实现起来就有两条不同的路径。负载均衡有两大门派，<strong>服务端负载均衡</strong>和<strong>客户端负载均衡</strong>。我们先来聊聊这两个不同门派的使用场景，再来看看本节课的主角Loadbalancer属于哪门哪派。</p><h3>网关层负载均衡</h3><p>网关层负载均衡也被称为服务端负载均衡，就是在服务集群内设置一个中心化负载均衡器，比如API Gateway服务。发起服务间调用的时候，服务请求并不直接发向目标服务器，而是发给这个全局负载均衡器，它再根据配置的负载均衡策略将请求转发到目标服务。我把这个过程画成了下面这张流程图。</p><p><img src=\"https://static001.geekbang.org/resource/image/75/b5/755871b87002c5b85b2db5e16362b5b5.jpg?wh=2000x1338\" alt=\"\"></p><p>网关层负载均衡的应用范围非常广，它不依赖于服务发现技术，客户端并不需要拉取完整的服务列表；同时，发起服务调用的客户端也不用操心该使用什么负载均衡策略。</p><p>不过，网关层负载均衡的劣势也很明显。</p><ol>\n<li><strong>网络消耗</strong>：多了一次客户端请求网关层的网络开销，在线上高并发场景下这层调用会增加10ms～20ms左右的服务响应时间。别小瞧了这十几毫秒的时间，在超高QPS的场景下，性能损耗也会被同步放大，降低系统的吞吐量；</li>\n<li><strong>复杂度和故障率提升</strong>：需要额外搭建内部网关组件作为负载均衡器，增加了系统复杂度，而多出来的那一次的网络调用无疑也增加了请求失败率。</li>\n</ol><p>Spring Cloud Loadbalancer可以很好地弥补上面的劣势，那么它是如何做到的呢？</p><h3>客户端负载均衡</h3><p>Spring Cloud Loadbalancer采用了客户端负载均衡技术，每个发起服务调用的客户端都存有完整的目标服务地址列表，根据配置的负载均衡策略，由客户端自己决定向哪台服务器发起调用。</p><p><img src=\"https://static001.geekbang.org/resource/image/13/ce/13bb64bfbd9c6a9515d53e66d441a6ce.jpg?wh=2000x1191\" alt=\"\"></p><p>客户端负载均衡的优势很明显。</p><ol>\n<li><strong>网络开销小</strong>：由客户端直接发起点对点的服务调用，没有中间商赚差价；</li>\n<li><strong>配置灵活</strong>：各个客户端可以根据自己的需要灵活定制负载均衡策略。</li>\n</ol><p>不过呢，如果想要应用客户端负载均衡，那么还需要满足一个前置条件，发起服务调用的客户端需要获取所有目标服务的地址，这样它才能使用负载均衡规则选取要调用的服务。也就是说，<strong>客户端负载均衡技术往往需要依赖服务发现技术来获取服务列表</strong>。</p><p>所以，Nacos和Loadbalancer自然而然地走到了一起，一个通过服务发现获取服务列表，另一个使用负载均衡规则选出目标服务器。</p><p>了解了负载均衡的作用之后，我们来看看Loadbalancer的工作原理。</p><h2>Loadbalancer工作原理</h2><p>你一定还记得我们在Nacos实战部分使用WebClient发起服务调用的过程吧。我在coupon-customer-serv中声明WebClient的时候加了一个机关，那就是@Loadbalanced注解，这个注解就是开启负载均衡功能的玄机。</p><pre><code>@Bean\n@LoadBalanced\npublic WebClient.Builder register() {\n    return WebClient.builder();\n}\n</code></pre><p>Loadbalancer组件通过@Loadbalanced注解对WebClient动了一番手脚，在启动过程中利用了自动装配器机制，分三步偷偷摸摸地向WebClient中塞了一个特殊的Filter（过滤器），通过过滤器实现了负载均衡功能。</p><pre><code>Builder filter(ExchangeFilterFunction filter);\n</code></pre><p>接下来，我们深入源码，看看Loadbalancer是如何通过注解将过滤器添加到WebClient对象中的，这个过程分为三步。</p><p><strong>第一步，声明负载均衡过滤器</strong>。ReactorLoadBalancerClientAutoConfiguration是一个自动装配器类，我们在项目中引入了WebClient和ReactiveLoadBalancer类之后，自动装配流程就开始忙活起来了。在这个过程中，它会初始化一个实现了ExchangeFilterFunction的实例，在后面的步骤中，该实例将作为过滤器被注入到WebClient。</p><p>下面是自动装配器的源码。</p><pre><code>@Configuration(proxyBeanMethods = false)\n// 只要Path路径上能加载到WebClient和ReactiveLoadBalancer\n// 则开启自动装配流程\n@ConditionalOnClass(WebClient.class)\n@ConditionalOnBean(ReactiveLoadBalancer.Factory.class)\npublic class ReactorLoadBalancerClientAutoConfiguration {\n\n   // 如果开启了Loadbalancer重试功能(默认开启）\n   // 则初始化RetryableLoadBalancerExchangeFilterFunction\n   @ConditionalOnMissingBean\n   @ConditionalOnProperty(value = &quot;spring.cloud.loadbalancer.retry.enabled&quot;, havingValue = &quot;true&quot;)\n   @Bean\n   public RetryableLoadBalancerExchangeFilterFunction retryableLoadBalancerExchangeFilterFunction(\n         ReactiveLoadBalancer.Factory&lt;ServiceInstance&gt; loadBalancerFactory, LoadBalancerProperties properties,\n         LoadBalancerRetryPolicy retryPolicy) {\n      return new RetryableLoadBalancerExchangeFilterFunction(retryPolicy, loadBalancerFactory, properties);\n   }\n   \n    // 如果关闭了Loadbalancer的重试功能\n    // 则初始化ReactorLoadBalancerExchangeFilterFunction对象\n    @ConditionalOnMissingBean\n    @ConditionalOnProperty(value = &quot;spring.cloud.loadbalancer.retry.enabled&quot;, havingValue = &quot;false&quot;,\n        matchIfMissing = true)\n    @Bean\n    public ReactorLoadBalancerExchangeFilterFunction loadBalancerExchangeFilterFunction(\n        ReactiveLoadBalancer.Factory&lt;ServiceInstance&gt; loadBalancerFactory, LoadBalancerProperties properties) {\n        return new ReactorLoadBalancerExchangeFilterFunction(loadBalancerFactory, properties);\n    }\n   // ...省略部分代码\n}\n</code></pre><p><strong>第二步，声明后置处理器</strong>。LoadBalancerBeanPostProcessorAutoConfiguration是第二个登场的自动装配器，它的主要作用是将第一步中创建的ExchangeFilterFunction拦截器实例添加到一个后置处理器（LoadBalancerWebClientBuilderBeanPostProcessor）中。</p><pre><code>// 省略部分代码\npublic class LoadBalancerBeanPostProcessorAutoConfiguration {\n\n   // 内部配置类\n   @Configuration(proxyBeanMethods = false)\n   @ConditionalOnBean(ReactiveLoadBalancer.Factory.class)\n   protected static class ReactorDeferringLoadBalancerFilterConfig {\n      \n      // 将第一步中创建的ExchangeFilterFunction实例封装到另一个名为\n      // DeferringLoadBalancerExchangeFilterFunction的过滤器中\n      @Bean\n      @Primary\n      DeferringLoadBalancerExchangeFilterFunction&lt;LoadBalancedExchangeFilterFunction&gt; reactorDeferringLoadBalancerExchangeFilterFunction(\n            ObjectProvider&lt;LoadBalancedExchangeFilterFunction&gt; exchangeFilterFunctionProvider) {\n         return new DeferringLoadBalancerExchangeFilterFunction&lt;&gt;(exchangeFilterFunctionProvider);\n      }\n   }\n   \n   // 将过滤器打包到后置处理器中\n   @Bean\n   public LoadBalancerWebClientBuilderBeanPostProcessor loadBalancerWebClientBuilderBeanPostProcessor(\n         DeferringLoadBalancerExchangeFilterFunction deferringExchangeFilterFunction, ApplicationContext context) {\n      return new LoadBalancerWebClientBuilderBeanPostProcessor(deferringExchangeFilterFunction, context);\n   }\n}\n</code></pre><p><strong>第三<strong><strong>步</strong></strong>，添加过滤器到WebClient</strong>。LoadBalancerWebClientBuilderBeanPostProcessor后置处理器开始发挥作用，将过滤器添加到WebClient中。注意<strong>不是所有的WebClient都会被注入过滤器，只有被@Loadbalanced注解修饰的WebClient实例才能享受这个待遇</strong>。</p><pre><code>public class LoadBalancerWebClientBuilderBeanPostProcessor implements BeanPostProcessor {\n   // ... 省略部分代码\n   \n   // 对过滤器动手脚\n   @Override\n   public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n      // 如果满足以下条件，则将过滤器添加到WebClient中\n      // 1) 当前Bean是WebClient.Builder实例\n      // 2) WebClient被@LoadBalanced注解修饰\n      if (bean instanceof WebClient.Builder) {\n         if (context.findAnnotationOnBean(beanName, LoadBalanced.class) == null) {\n            return bean;\n         }\n         // 添加过滤器\n         ((WebClient.Builder) bean).filter(exchangeFilterFunction);\n      }\n      return bean;\n   }\n\n}\n</code></pre><p>好了，到这里Loadbalancer组件就完成了过滤器的注入。过滤器是一个搭建在WebClient和负载均衡策略之间的桥梁，在WebClient发出一个请求前，过滤器会横插一脚，召唤出负载均衡策略，决定这个请求要发配到哪一台服务器。如果你感兴趣，可以自己阅读过滤器的源码，深入了解它是如何从LoadBalancerFactory中获取到具体的负载均衡策略的。</p><p>了解了Loadbalancer的底层原理，接下来我带你深入了解Loadbalancer组件的负载均衡扩展点，看一看如何<strong>深度定制一个属于自己的负载均衡策略</strong>。</p><h2>自定义负载均衡策略实现金丝雀测试</h2><p>Loadbalancer提供了两种内置负载均衡策略。</p><ul>\n<li><strong>RandomLoadBalancer</strong>：在服务列表中随机挑选一台服务器发起调用，属于拼人品系列；</li>\n<li><strong>RoundRobinLoadBalancer</strong>：通过内部保存的一个position计数器，按照次序从上到下依次调用服务，每次调用后计数器+1，属于排好队一个个来系列。</li>\n</ul><p>如果以上负载均衡策略无法满足你的要求，那么应该怎么实现自定义的负载均衡策略呢？</p><p>Loadbalancer提供了一个顶层的抽象接口ReactiveLoadBalancer，你可以通过继承这个接口，来实现自定义的负载均衡策略。现在我就带你沿着这个路子实现一个用于“金丝雀测试”的负载均衡策略，在动手之前，我先带你了解一下什么是“金丝雀测试”。</p><h3>金丝雀测试</h3><p>金丝雀测试是灰度测试的一种。</p><p>我们的线上应用平稳运行在一个集群中，当你想要上线一个涉及上下游代码改动的线上应用的时候，首先想到的是先要做一个线上测试。这个测试必须在极小规模的范围内进行，不能影响到整个集群。</p><p>我们可以把代码改动部署到极个别的几台机器上，这几台机器就叫做“金丝雀”。只有带着“<strong>测试流量标记</strong>”的请求会被发到这几台服务器上，而正常的流量只会打到集群中的其它机器上。下面的图解释了金丝雀测试的流程。</p><p><img src=\"https://static001.geekbang.org/resource/image/cd/11/cd5687f2e678d2da14eaaf660c50d111.jpg?wh=2000x1191\" alt=\"\"></p><p>现在你了解了金丝雀测试，接下来我们就将它应用在用户领券这个场景中。</p><p>用户领券的接口位于coupon-customer-serv子模块中，它通过负载均衡策略调用了coupon-template-serv完成了领券操作。我把负载均衡策略定义在coupon-customer-serv中，把coupon-template-serv作为金丝雀测试的目标服务，项目实战这就开始了！</p><p>首先我们需要在项目中编写自定义的负载均衡策略。</p><h3>编写CanaryRule负载均衡</h3><p>我在项目中创建了一个叫CanaryRule的负载均衡规则类，它继承自Loadbalancer项目的标准接口ReactorServiceInstanceLoadBalancer。</p><p>CanaryRule借助Http Header中的属性和Nacos服务节点的metadata完成测试流量的负载均衡。在这个过程里，它需要准确识别哪些请求是测试流量，并且把测试流量导向到正确的目标服务。</p><p><strong>CanaryRule如何识别测试流量</strong>：如果WebClient发出一个请求，其Header的key-value列表中包含了特定的流量Key：traffic-version，那么这个请求就被识别为一个测试请求，只能发送到特定的金丝雀服务器上。</p><p><strong>CanaryRule如何对测试流量做负载均衡</strong>：包含了新的代码改动的服务器就是这个金丝雀，我会在这台服务器的Nacos元数据中插入同样的流量密码：traffic-version。如果Nacos元数据中的traffic-version值与测试流量Header中的一样，那么这个Instance就是我们要找的那只金丝雀。</p><p>我们先来看看CanaryRule的源码。</p><pre><code>// 可以将这个负载均衡策略单独拎出来，作为一个公共组件提供服务\n@Slf4j\npublic class CanaryRule implements ReactorServiceInstanceLoadBalancer {\n    private ObjectProvider&lt;ServiceInstanceListSupplier&gt; serviceInstanceListSupplierProvider;\n    private String serviceId;\n    // 定义一个轮询策略的种子\n    final AtomicInteger position;\n    \n    // ...省略构造器代码\n    \n    // 这个服务是Loadbalancer的标准接口，也是负载均衡策略选择服务器的入口方法\n    @Override\n    public Mono&lt;Response&lt;ServiceInstance&gt;&gt; choose(Request request) {\n        ServiceInstanceListSupplier supplier = serviceInstanceListSupplierProvider\n                .getIfAvailable(NoopServiceInstanceListSupplier::new);\n        return supplier.get(request).next()\n                .map(serviceInstances -&gt; processInstanceResponse(supplier, serviceInstances, request));\n    }\n    \n    // 省略该方法内容，本方法主要完成了对getInstanceResponse的调用\n    private Response&lt;ServiceInstance&gt; processInstanceResponse(\n    }\n    \n    // 根据金丝雀的规则返回目标节点\n    Response&lt;ServiceInstance&gt; getInstanceResponse(List&lt;ServiceInstance&gt; instances, Request request) {\n        // 注册中心无可用实例 返回空\n        if (CollectionUtils.isEmpty(instances)) {\n            log.warn(&quot;No instance available {}&quot;, serviceId);\n            return new EmptyResponse();\n        }\n        // 从WebClient请求的Header中获取特定的流量打标值\n        // 注意：以下代码仅适用于WebClient调用，使用RestTemplate或者Feign则需要额外适配\n        DefaultRequestContext context = (DefaultRequestContext) request.getContext();\n        RequestData requestData = (RequestData) context.getClientRequest();\n        HttpHeaders headers = requestData.getHeaders();\n        // 获取到header中的流量标记\n        String trafficVersion = headers.getFirst(TRAFFIC_VERSION);\n        \n        // 如果没有找到打标标记，或者标记为空，则使用RoundRobin规则进行查找\n        if (StringUtils.isBlank(trafficVersion)) {\n            // 过滤掉所有金丝雀测试的节点，即Nacos Metadaba中包含流量标记的节点\n            // 从剩余的节点中进行RoundRobin查找\n            List&lt;ServiceInstance&gt; noneCanaryInstances = instances.stream()\n                    .filter(e -&gt; !e.getMetadata().containsKey(TRAFFIC_VERSION))\n                    .collect(Collectors.toList());\n            return getRoundRobinInstance(noneCanaryInstances);\n        }\n        \n        // 如果WelClient的Header里包含流量标记\n        // 循环每个Nacos服务节点，过滤出metadata值相同的instance，再使用RoundRobin查找\n        List&lt;ServiceInstance&gt; canaryInstances = instances.stream().filter(e -&gt; {\n            String trafficVersionInMetadata = e.getMetadata().get(TRAFFIC_VERSION);\n            return StringUtils.equalsIgnoreCase(trafficVersionInMetadata, trafficVersion);\n        }).collect(Collectors.toList());\n        return getRoundRobinInstance(canaryInstances);\n    }\n    \n    // 使用RoundRobin机制获取节点\n    private Response&lt;ServiceInstance&gt; getRoundRobinInstance(List&lt;ServiceInstance&gt; instances) {\n        // 如果没有可用节点，则返回空\n        if (instances.isEmpty()) {\n            log.warn(&quot;No servers available for service: &quot; + serviceId);\n            return new EmptyResponse();\n        }\n        \n        // 每一次计数器都自动+1，实现轮询的效果\n        int pos = Math.abs(this.position.incrementAndGet());\n        ServiceInstance instance = instances.get(pos % instances.size());\n        return new DefaultResponse(instance);\n    }\n}\n</code></pre><p>完成了负载均衡规则的编写之后，我们还要将这个负载均衡策略配置到方法调用过程中去。</p><h3>配置负载均衡策略</h3><p>CanaryRule负载均衡规则位于coupon-customer-serv项目里，那么相对应的配置类也放到同一个项目中。我创建了一个名为CanaryRuleConfiguration的类，因为我不希望把这个负载均衡策略应用到全局，所以我没有为这个配置类添加@Configuration注解。</p><pre><code>// 注意这里不要写上@Configuration注解\npublic class CanaryRuleConfiguration {\n\n    @Bean\n    public ReactorLoadBalancer&lt;ServiceInstance&gt; reactorServiceInstanceLoadBalancer(\n            Environment environment,\n            LoadBalancerClientFactory loadBalancerClientFactory) {\n        String name = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);\n        // 在Spring上下文中声明了一个CanaryRule规则\n        return new CanaryRule(loadBalancerClientFactory.getLazyProvider(name,\n                ServiceInstanceListSupplier.class), name);\n    }\n}\n</code></pre><p>写好配置类之后，我们需要在coupon-customer-serv的启动类上添加一个@LoadBalancerClient注解，将Configuration类和目标服务关联起来。</p><pre><code>// 发到coupon-template-serv的调用，使用CanaryRuleConfiguration中定义的负载均衡Rule\n@LoadBalancerClient(value = &quot;coupon-template-serv&quot;, configuration = CanaryRuleConfiguration.class)\npublic class Application {\n   // xxx省略方法\n}\n</code></pre><p>配置好负载均衡方案后，我们就要想办法将“测试流量标记”传入到WebClient的header里。</p><h3>测试流量打标</h3><p>测试流量打标的方法有很多种，比如添加一个特殊的key-value到Http header，或者塞一个值到RPC Context中。为了方便演示，我这里采用了一种更为简单的方式，直接在用户领券接口的请求参数对象RequestCoupon中添加了一个trafficVersion成员变量，用来标识测试流量。</p><pre><code>public class RequestCoupon {\n  //.. 省略其他成员变量\n\n  // Loadbalancer - 用作测试流量打标\n  private String trafficVersion;\n}\n</code></pre><p>同时，我对用户领券接口中调用coupon-template-serv的部分做了一个小改动。在构造WebClient对象的时候，我将RequestCoupon中的流量标记放在了WebClient请求的header中。这样一来，CanaryRule负载均衡策略就可以根据header判断当前请求是否为测试流量。</p><pre><code>@Override\npublic Coupon requestCoupon(RequestCoupon request) {\n    CouponTemplateInfo templateInfo = webClientBuilder.build().get()\n            .uri(&quot;http://coupon-template-serv/template/getTemplate?id=&quot; + request.getCouponTemplateId())\n            // 将流量标记传入WebClient请求的Header中\n            .header(TRAFFIC_VERSION, request.getTrafficVersion())\n            .retrieve()\n            .bodyToMono(CouponTemplateInfo.class)\n            .block();\n \n    // xxx 省略以下代码           \n}\n</code></pre><p>一切配置妥当之后，我们还剩最后一步：借助Nacos元数据将coupon-template-serv标记为一只金丝雀。</p><h3>添加Nacos元数据</h3><p>我在本地启动了两个coupon-template-serv实例，接下来我将其中一个实例设置为金丝雀。</p><p>你可以打开Nacos的服务列表页面，点击coupon-template-serv服务右方的“详情”按钮，进入到服务详情页。</p><p><img src=\"https://static001.geekbang.org/resource/image/ab/3a/ab045fd51ee5a8103e45b4df3d11f33a.jpg?wh=2000x876\" alt=\"\"></p><p>在服务详情页中，你可以看到本地启动的两个coupon-template-serv应用，然后选中其中的一个instance，点击图中的“编辑”按钮，添加一个新的变量到元数据中：traffic-version=coupon-template-test001。</p><p><img src=\"https://static001.geekbang.org/resource/image/bc/d8/bcac234c6a3760372cde4cc50ce8d1d8.jpg?wh=2000x1830\" alt=\"\"></p><p>好，到这里，我们的金丝雀负载均衡策略的就已经完成了。</p><p>你可以在本地启动项目并调用coupon-customer-serv的用户领券接口做测试。如果你在请求参数中指定了traffic-version=coupon-template-test001，那么这个请求将调用到金丝雀服务器；如果没有指定traffic-version，那么请求会被转发到正常的服务节点；如果你乱填了一个错误的traffic-version，那么方法会返回503-Service Unavailable的异常。</p><h2>总结</h2><p>现在，我们来回顾一下这节课的重点内容。今天我们了解了负载均衡技术在微服务领域的应用，深入理解了Spring Cloud Loadbalancer的底层原理和扩展点，并且通过一个“金丝雀测试”的例子，动手编写了一个自定义负载均衡策略。</p><p>这里需要注意的是，<strong>课程中编写的自定义负载均衡策略主要是针对WebClient方式的远程调用，如果你使用RestTemplate或者Feign发起调用，则需要在实现层面做一些额外的定制</strong>。希望这节课讲到的原理和方法能够起到一个授之以渔的作用，启发你向下深挖Loadbalancer如何支持其它HTTP调用方式。</p><p>我还想和你聊一聊我的一个学习心得，很多技术人员都会以为只学习工作里用到的技术就够了，其实这个想法会极大程度限制他以后的职业发展。我举个例子，负载均衡技术Loadbalancer，它并不是一个日常工作里经常用到的技术，在大公司通常这类框架层面的组件都由Framework团队封装好给到开发人员直接使用就可以了，所以你可能会认为并不需要学习。</p><p>但我的经验告诉自己，技术人员的成长来源于两个方面，一个是工作中用到的新技术和高并发挑战，另一个就是自己主动的拓展。而越到后期，你会发现第二个方向对自己的提升逐渐占据了主导地位。为什么呢？当你工作积累到一定年限之后，很容易发现工作内的业务需求已经没有太多的技术挑战，你的技术积累也足以应付每天的工作。这时候如果没有自己由内向外的主动拓展，你很容易就陷入了一个原地踏步的境地。</p><p>所以，希望你不要在技术学习上给自己设界，多去了解更多技术框架的全貌，积累到一定程度之后，这些努力都会在未来某一个时刻给你回报。</p><h2>思考题</h2><p>你能设计一个自定义负载均衡策略，实现集群优先的负载均衡吗？即优先调用同一个Cluster的服务器，如果同一个Cluster中没有可用服务，再调用其他Cluster的服务。</p><p>实现这个功能并不难，但是需要你仔细阅读Nacos和Loadbalancer的源码，找到获取当前服务和远程服务的Cluster Name的方法。</p><p>当然了，方法有很多，还要看你能否找到一个简单优雅的方式实现这个需求。如果你能够完成这个小挑战，那你的源码阅读能力一定是相当不错的，在评论区说出你的奇思妙想吧！</p><p>好啦，这节课就结束啦。欢迎你把这节课分享给更多对Spring Cloud感兴趣的朋友。我是姚秋辰，我们下节课再见！</p>","comments":[{"had_liked":false,"id":329465,"user_name":"思绪走了灬光✨","can_delete":false,"product_type":"c1","uid":1101661,"ip_address":"","ucode":"512DD0FA5C024C","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/5d/99756164.jpg","comment_is_top":false,"comment_ctime":1641357358,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"66065866798","product_id":100101301,"comment_content":"技术人员的成长来源于两个方面，一个是工作中用到的新技术和高并发挑战，另一个就是自己主动的拓展。而越到后期，你会发现第二个方向对自己的提升逐渐占据了主导地位。为什么呢？当你工作积累到一定年限之后，很容易发现工作内的业务需求已经没有太多的技术挑战，你的技术积累也足以应付每天的工作。这时候如果没有自己由内向外的主动拓展，你很容易就陷入了一个原地踏步的境地。","like_count":16,"discussions":[{"author":{"id":1064489,"avatar":"https://static001.geekbang.org/account/avatar/00/10/3e/29/cc30bd9d.jpg","nickname":"逝影落枫","note":"","ucode":"34788B4A504CD1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544011,"discussion_content":"外驱力不确定性，内驱力稳定持续。百川汇聚，终成江海。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1641379365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331653,"user_name":"与路同飞","can_delete":false,"product_type":"c1","uid":1138821,"ip_address":"","ucode":"2985F1440A1962","user_header":"https://static001.geekbang.org/account/avatar/00/11/60/85/f72f1d94.jpg","comment_is_top":false,"comment_ctime":1642686427,"is_pvip":true,"replies":[{"id":"121192","content":"api网关只负责网关-&gt;微服务的链路，但是基于服务发现构建的微服务架构里，微服务之间互相调用是不经过网关的","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1642777023,"ip_address":"","comment_id":331653,"utype":1}],"discussion_count":1,"race_medal":0,"score":"36002424795","product_id":100101301,"comment_content":"现在公司所有api服务都是注册到api网关上去了。api网关替我们做了负载均衡和路由规则。那业务团队是不是就不需要引用负载均衡组件了","like_count":9,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547630,"discussion_content":"api网关只负责网关-&gt;微服务的链路，但是基于服务发现构建的微服务架构里，微服务之间互相调用是不经过网关的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642777023,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329572,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1641432841,"is_pvip":true,"replies":[{"id":"120089","content":"还是需要nginx的，微服务网关和nginx扮演的角色不一样，nginx作为高性能反向代理，性能上是完爆任何微服务网关的。而且一般公司会根据安全策略设置多层LVS+Nginx网关，比如secure zone, unsecure zone等等，内部网络拓扑非常复杂，这里依然需要nginx来扮演网关的角色。<br><br>而微服务网关，比如后面我们要看到的spring cloud gateway，往往扮演的角色是在外部网关和内部微服务之间的桥梁，通常不会作为最外层网关直接承接外部用户流量","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1641486670,"ip_address":"","comment_id":329572,"utype":1}],"discussion_count":3,"race_medal":0,"score":"18821302025","product_id":100101301,"comment_content":"老师我有个关于代理的问题：一般用nginx将请求转发到后端多个应用服务器上。现在用了API网关，由API网关将请求转发到后端应用服务器上。这样的话，API网关和nginx的功能就重复了，就不需要nginx了，对吗？ 尤其对于中小公司，服务器数量不是很多，nginx就足够了，或者用API网关就足够了，两者选一个就够了啊。","like_count":5,"discussions":[{"author":{"id":1138821,"avatar":"https://static001.geekbang.org/account/avatar/00/11/60/85/f72f1d94.jpg","nickname":"与路同飞","note":"","ucode":"2985F1440A1962","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547470,"discussion_content":"nginx网关一般南北流向，外部网络访问内网服务。api网关一般东西流向，内部微服务互相调用","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1642686290,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544381,"discussion_content":"还是需要nginx的，微服务网关和nginx扮演的角色不一样，nginx作为高性能反向代理，性能上是完爆任何微服务网关的。而且一般公司会根据安全策略设置多层LVS+Nginx网关，比如secure zone, unsecure zone等等，内部网络拓扑非常复杂，这里依然需要nginx来扮演网关的角色。\n\n而微服务网关，比如后面我们要看到的spring cloud gateway，往往扮演的角色是在外部网关和内部微服务之间的桥梁，通常不会作为最外层网关直接承接外部用户流量","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1641486670,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1167233,"avatar":"https://static001.geekbang.org/account/avatar/00/11/cf/81/96f656ef.jpg","nickname":"杨逸林","note":"","ucode":"4BF3CF3E2F1AC7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544302,"discussion_content":"理论上来说，是这样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641461171,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347399,"user_name":"Geek_0b93c0","can_delete":false,"product_type":"c1","uid":2971019,"ip_address":"","ucode":"ACAA7817AD2C61","user_header":"","comment_is_top":false,"comment_ctime":1653990029,"is_pvip":false,"replies":[{"id":"126733","content":"perfect, 从metadata这个属性里可以读到很多data做各种定制","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1654238297,"ip_address":"","comment_id":347399,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14538891917","product_id":100101301,"comment_content":"集群优先代码<br><br>    private Response&lt;ServiceInstance&gt; getSameClusterService(Request request, List&lt;ServiceInstance&gt; instances) {<br>        String clusterName = environment.resolvePlaceholders(&quot;${spring.cloud.nacos.discovery.cluster-name:}&quot;);<br>        List&lt;ServiceInstance&gt; instanceList = instances.stream().filter(v -&gt; {<br>            Map&lt;String, String&gt; metadata = v.getMetadata();<br>            String serviceClusterName = metadata.get(&quot;nacos.cluster&quot;);<br>            return clusterName.equals(serviceClusterName);<br>        }).collect(Collectors.toList());<br>        &#47;&#47;有同集群下服务 RoundRobin算法挑选<br>        if (CollectionUtils.isNotEmpty(instanceList)){<br>            return getRoundRobinInstance(instanceList);<br>        }else {<br>            return getRoundRobinInstance(instances);<br>        }<br>    }","like_count":4,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574673,"discussion_content":"perfect, 从metadata这个属性里可以读到很多data做各种定制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654238297,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330966,"user_name":"~","can_delete":false,"product_type":"c1","uid":2495621,"ip_address":"","ucode":"BE5E3BD6EE3665","user_header":"https://static001.geekbang.org/account/avatar/00/26/14/85/73e55be5.jpg","comment_is_top":false,"comment_ctime":1642328894,"is_pvip":false,"replies":[{"id":"121041","content":"同学是一个爱思考的三好学生，非常不错。我思考题里面埋了一个机关是“集群优先”，所以这里还需要判定一下当前instance所属的集群是否与当前这台服务器一致，当前服务的集群可以从配置文件中读取，而instance的集群其实被封装到了每个instance的metadata里，可以从中读取并比较","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1642523398,"ip_address":"","comment_id":330966,"utype":1}],"discussion_count":3,"race_medal":0,"score":"14527230782","product_id":100101301,"comment_content":"说一下思考题我的思路：<br>从 CanaryRule 就可以看出来了，其实实现负载均衡的逻辑就在getRoundRobinInstance中，我们只需要改造这里就可以了。我的想法是设置一个缓存（map 也好，其他的也好），存放上次选择出的 serverInstance，如果是第一次选择，那么使用老逻辑选出一个，如果上次选择的服务已经不可用了，就从缓存中清除，重新选一个就可以了。<br>补充2点：<br>1. 怎么判断一个服务是否可用？其实在这里的代码中，传入的 List&lt;ServiceInstance&gt; 参数就是从 nacos 中获取到的可用服务的列表。那么只需要判断缓存中存放的 serviceInstance 是否也在 list 中就可以了。具体怎么获取到可用服务列表的，需要进一步查看源码才能了解。<br>2. 仅做一个猜想，不具有实际意义，老师如果能解答也再好不过了：能否直接在获取可用服务列表那步就直接确定一个服务？其他的逻辑也是如此。就算可行其实设计上也是不合理的，因为获取可用服务的代码就应该只负责相关逻辑，负载均衡代码就应该只管负载均衡。提出这个猜想只不过是想对源码有进一步了解，设计上还是各司其职更合理。<br><br>以上就是我的思考，附上代码（超过字数限制了，放在我的留言的回复里了），如果有问题，欢迎指出问题~<br>","like_count":3,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547105,"discussion_content":"同学是一个爱思考的三好学生，非常不错。我思考题里面埋了一个机关是“集群优先”，所以这里还需要判定一下当前instance所属的集群是否与当前这台服务器一致，当前服务的集群可以从配置文件中读取，而instance的集群其实被封装到了每个instance的metadata里，可以从中读取并比较","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642523399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2495621,"avatar":"https://static001.geekbang.org/account/avatar/00/26/14/85/73e55be5.jpg","nickname":"~","note":"","ucode":"BE5E3BD6EE3665","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546645,"discussion_content":"@Slf4j\npublic class PriorityRule implements ReactorServiceInstanceLoadBalancer {\n\n    private ObjectProvider&lt;ServiceInstanceListSupplier&gt; serviceInstanceListSupplier;\n    private String serviceId;\n    private ConcurrentHashMap&lt;String, ServiceInstance&gt; cache;\n    private AtomicInteger position;\n\n    public PriorityRule(ObjectProvider&lt;ServiceInstanceListSupplier&gt; serviceInstanceListSupplier, String serviceId) {\n        this.serviceInstanceListSupplier = serviceInstanceListSupplier;\n        this.serviceId = serviceId;\n        this.cache = new ConcurrentHashMap&lt;&gt;();\n        this.position = new AtomicInteger();\n    }\n\n    // 只保留修改的代码，其他的都是从 CanaryRule 中 copy 的\n    private Response&lt;ServiceInstance&gt; getInstanceResponse(List&lt;ServiceInstance&gt; serviceInstances,\n                                                          Request request) {\n\n        if (cache.isEmpty()) {\n            return getRoundRobinInstance(serviceInstances);\n        }\n\n        for (ServiceInstance instance : serviceInstances) {\n            if (cache.containsKey(instance.getServiceId())) {\n                return new DefaultResponse(instance);\n            }\n        }\n\n        cache.clear();\n\n        return getRoundRobinInstance(serviceInstances);\n    }\n\n    private Response&lt;ServiceInstance&gt; getRoundRobinInstance(List&lt;ServiceInstance&gt; instances) {\n        if (instances.isEmpty()) {\n            log.warn(&#34;No servers available for service: &#34; +serviceId);\n            return new EmptyResponse();\n        }\n\n        int pos = Math.abs(this.position.incrementAndGet());\n        ServiceInstance instance = instances.get(pos % instances.size());\n        cache.put(instance.getServiceId(), instance);\n\n        return new DefaultResponse(instance);\n    }\n}","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1642383662,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2495621,"avatar":"https://static001.geekbang.org/account/avatar/00/26/14/85/73e55be5.jpg","nickname":"~","note":"","ucode":"BE5E3BD6EE3665","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547446,"discussion_content":"看了老师的回答，我发现我的理解可能是有点偏差，老师想要的是从多个相同服务集群中选定一个集群请求，我的是从一个集群里指定一台机器请求。不过修改应该比较简单（大概），保留一下请求的集群名称，然后在 matedata 里进行匹配就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642677348,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341811,"user_name":"何衍其","can_delete":false,"product_type":"c1","uid":1501693,"ip_address":"","ucode":"B031AB5EB778A3","user_header":"https://static001.geekbang.org/account/avatar/00/16/e9/fd/4abed049.jpg","comment_is_top":false,"comment_ctime":1649840892,"is_pvip":false,"replies":[{"id":"125190","content":"非常正确，metadata里面包罗万象","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1650417146,"ip_address":"","comment_id":341811,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10239775484","product_id":100101301,"comment_content":"&#47;&#47; 当前服务的集群名称<br> String clusterName = environment.resolvePlaceholders(&quot;${spring.cloud.nacos.discovery.cluster-name:}&quot;);<br><br>&#47;&#47; 服务实列所属集群名称<br>serviceInstance.getMetadata().get(&quot;nacos.cluster&quot;);","like_count":3,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":565220,"discussion_content":"非常正确，metadata里面包罗万象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650417146,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2971019,"avatar":"","nickname":"Geek_0b93c0","note":"","ucode":"ACAA7817AD2C61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573913,"discussion_content":"soga原来这么用 我还在源码找哪里能直接拿clusterName","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653727897,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":337729,"user_name":"找工作","can_delete":false,"product_type":"c1","uid":1756876,"ip_address":"","ucode":"DFD2FFACAEDC12","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ce/cc/ec5895b0.jpg","comment_is_top":false,"comment_ctime":1646996526,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5941963822","product_id":100101301,"comment_content":"在postman里加header怎么都没用，鼓捣了一小时发现，不是requestcoupon的header，而是应该加在gettemplate的header","like_count":1,"discussions":[{"author":{"id":2845977,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/6d/19/204b0900.jpg","nickname":"Black Jack","note":"","ucode":"CB16C8F44EF422","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570402,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651756667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1130275,"avatar":"https://static001.geekbang.org/account/avatar/00/11/3f/23/8ff389d2.jpg","nickname":"郁方林","note":"","ucode":"8ABEAFDA815DDE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558254,"discussion_content":"1. 请求/coupon-customer/requestCoupon，携带header头 \n2. /coupon-customer/requestCoupon请求/template/getTemplate，并在webClient中新增header头\n3. 根据header头CanaryRule会负载均衡到指定的机器上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648178676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333229,"user_name":"密码123456","can_delete":false,"product_type":"c1","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1644223128,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5939190424","product_id":100101301,"comment_content":"整明白了，根据服务名称多次建立spring容器。而且带有层级的容器。动态刷新的负载均衡配置，LoadBalancerClientSpecification","like_count":1},{"had_liked":false,"id":358590,"user_name":"Yarnbo","can_delete":false,"product_type":"c1","uid":2244829,"ip_address":"上海","ucode":"9A9BF8E5A089F1","user_header":"https://static001.geekbang.org/account/avatar/00/22/40/dd/0ed6f0b9.jpg","comment_is_top":false,"comment_ctime":1664446268,"is_pvip":false,"replies":[{"id":"130690","content":"同学都说出正确答案了，没错，其实“优先调用同一个cluster”是一种最简单的单元化能力。假设前置网关能根据用户location等条件做单元调用（淘系用户就分单元&#47;中心机房等等），比如说江浙沪的用户请求进上海机房，相对应的全链路缓存都构建再同一个机房，那么将打到单元A的流量只在内部做流转能降低请求响应时间","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1665411569,"ip_address":"上海","comment_id":358590,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1664446268","product_id":100101301,"comment_content":"姚总好，学习了您的本节课受益匪浅。虽然照葫芦画瓢也实现了“优先调用同一个 Cluster 的服务器”，但是这样做的意义有哪些，能结合您的经验介绍下吗？（我能盲猜到的是，假如服务以集群为基本单元提供服务能力，将来方便弹性扩展机器）","like_count":0,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589965,"discussion_content":"同学都说出正确答案了，没错，其实“优先调用同一个cluster”是一种最简单的单元化能力。假设前置网关能根据用户location等条件做单元调用（淘系用户就分单元/中心机房等等），比如说江浙沪的用户请求进上海机房，相对应的全链路缓存都构建再同一个机房，那么将打到单元A的流量只在内部做流转能降低请求响应时间","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665411570,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":357853,"user_name":"乘风","can_delete":false,"product_type":"c1","uid":2112229,"ip_address":"上海","ucode":"D25976CDD1D39B","user_header":"https://static001.geekbang.org/account/avatar/00/20/3a/e5/1a1b08ad.jpg","comment_is_top":false,"comment_ctime":1663683992,"is_pvip":true,"replies":[{"id":"130689","content":"bingo，我示例中的版本是强绑定webclient了，如果要应用到openfeign要做些改造","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1665411298,"ip_address":"上海","comment_id":357853,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1663683992","product_id":100101301,"comment_content":"金丝雀负载均衡策略好像并没有强依赖WebClient呀，为什么说它是专门针对WebClient方式的远程调用，难道openFeigh用不了？","like_count":0,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589962,"discussion_content":"bingo，我示例中的版本是强绑定webclient了，如果要应用到openfeign要做些改造","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665411299,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":355107,"user_name":"二饼","can_delete":false,"product_type":"c1","uid":2415448,"ip_address":"上海","ucode":"48120565D135F7","user_header":"https://static001.geekbang.org/account/avatar/00/24/db/58/a7a0a85b.jpg","comment_is_top":false,"comment_ctime":1661090482,"is_pvip":true,"replies":[{"id":"130679","content":"同学要在本地换一个端口再启动一个coupon-template-serv服务，确保有两个同名但占用端口不同的服务启动并注册","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1665410289,"ip_address":"上海","comment_id":355107,"utype":1}],"discussion_count":2,"race_medal":1,"score":"1661090482","product_id":100101301,"comment_content":"Nacos-服务管理-服务列表-开发环境 `coupon-template-serv` 只有一个实例，不是两个，我又把前面的文章看了一遍，没有发现什么地方又说定义了两个实例，和示例代码比对了一下配置文件没看出什么问题，请教一下老师我这是什么造成的？","like_count":0,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589951,"discussion_content":"同学要在本地换一个端口再启动一个coupon-template-serv服务，确保有两个同名但占用端口不同的服务启动并注册","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665410289,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2415448,"avatar":"https://static001.geekbang.org/account/avatar/00/24/db/58/a7a0a85b.jpg","nickname":"二饼","note":"","ucode":"48120565D135F7","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585128,"discussion_content":"不过目前看来没什么影响","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661335794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"重庆"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351463,"user_name":"Geek_eca226","can_delete":false,"product_type":"c1","uid":3021110,"ip_address":"","ucode":"E738A5618F3218","user_header":"","comment_is_top":false,"comment_ctime":1657808216,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1657808216","product_id":100101301,"comment_content":"原来后置处理器是这样用的，最开始学习spring讲bean的生命周期时有个前置处理，后置处理一直不知道起什么作用","like_count":0},{"had_liked":false,"id":349322,"user_name":"Jaising","can_delete":false,"product_type":"c1","uid":1037630,"ip_address":"","ucode":"F68830B7B90F96","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d5/3e/7f3a9c2b.jpg","comment_is_top":false,"comment_ctime":1655886012,"is_pvip":false,"replies":[{"id":"127581","content":"这个问题可能就要往底层排查咯，要debug到A的负载均衡策略里，看一下是否因为依赖项污染导致负载均衡失效。比如说A底层负载均衡需要一个组件A1，但B项目也同时存在这个A1同类型的实例，导致A初始化的时候注入了另一个二方库的错误组件","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1657105248,"ip_address":"","comment_id":349322,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1655886012","product_id":100101301,"comment_content":"半仙老师，遇到个负载失效的问题帮忙排查下怎么回事，应用中引入了两个二方库starter A和B，两个starter都各自定义了一个RestTemplate，A做了LoadBalance，B没有，单独引入A或B都可以正常发起http调用，但是同时引入两个starter后，B正常，A却负载失效了报错no instances available，这是咋回事","like_count":0,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578979,"discussion_content":"这个问题可能就要往底层排查咯，要debug到A的负载均衡策略里，看一下是否因为依赖项污染导致负载均衡失效。比如说A底层负载均衡需要一个组件A1，但B项目也同时存在这个A1同类型的实例，导致A初始化的时候注入了另一个二方库的错误组件","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657105249,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1037630,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d5/3e/7f3a9c2b.jpg","nickname":"Jaising","note":"","ucode":"F68830B7B90F96","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577479,"discussion_content":"后一天找到原因并解决了，是工程内间接引入了WebFlux依赖，SpringCloud对响应式的优先级是比阻塞式的高的，参见LoadBalancerClientConfiguration，这样阻塞式的RestTemplate就没法做服务发现了，只需要spring.factoriest排除对应自动配置类ReactiveSupportConfiguration或是properities添加属性spring.cloud.discovery.reactive.enabled=false即可","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656137295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347023,"user_name":"Geek_5d68ab","can_delete":false,"product_type":"c1","uid":2767290,"ip_address":"","ucode":"30EEDCB7B8B10C","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLyfaTNuvbkiclibb8EuNOiaI2sicPgB0icmOB7f81POSbchoRickQpDxXC3p83D41icIppbHXJ4Vx1j3ulw/132","comment_is_top":false,"comment_ctime":1653623205,"is_pvip":true,"replies":[{"id":"126731","content":"同学要使用Loadbalancer对应章节的代码来跑CanaryRule，在后面章节的对应代码中我没有使用CanaryRule","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1654238089,"ip_address":"","comment_id":347023,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1653623205","product_id":100101301,"comment_content":"把老师的代码down下来之后，启动服务，请求接口不经过CanaryRule是怎么回事？","like_count":0,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574670,"discussion_content":"同学要使用Loadbalancer对应章节的代码来跑CanaryRule，在后面章节的对应代码中我没有使用CanaryRule","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654238089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344953,"user_name":"胖子菜","can_delete":false,"product_type":"c1","uid":2577403,"ip_address":"","ucode":"5B72717FFEA894","user_header":"https://static001.geekbang.org/account/avatar/00/27/53/fb/c62a8490.jpg","comment_is_top":false,"comment_ctime":1651893644,"is_pvip":false,"replies":[{"id":"126174","content":"我一般是直接用dubbo原生的负载均衡策略，spring cloud自带的loadbalancer其实功能性还不如ribbon，内置的负载均衡策略也没得比，完全是为了去netflix化搞的这么个玩意儿","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1652585317,"ip_address":"","comment_id":344953,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1651893644","product_id":100101301,"comment_content":"dubbo整合了nacos后，因为我用的最新版本的nacos没有自带ribbon,我又引入了loadbalancer依赖，我想问下dubbo有负载均衡机制，loadbancer也有，他们冲突么，谁会生效呢","like_count":1,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572059,"discussion_content":"我一般是直接用dubbo原生的负载均衡策略，spring cloud自带的loadbalancer其实功能性还不如ribbon，内置的负载均衡策略也没得比，完全是为了去netflix化搞的这么个玩意儿","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1652585317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":340466,"user_name":"丶凯","can_delete":false,"product_type":"c1","uid":2385275,"ip_address":"","ucode":"D4BDE757C92C59","user_header":"https://static001.geekbang.org/account/avatar/00/24/65/7b/cddf667b.jpg","comment_is_top":false,"comment_ctime":1648826325,"is_pvip":false,"replies":[{"id":"125179","content":"这段新上线的代码只部署在特定的几台机器上，这几台机器就是金丝雀服务器","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1650416533,"ip_address":"","comment_id":340466,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1648826325","product_id":100101301,"comment_content":"包含了新的代码改动的服务器就是这个金丝雀,  老师这句话什么意思？<br>","like_count":0,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":565182,"discussion_content":"这段新上线的代码只部署在特定的几台机器上，这几台机器就是金丝雀服务器","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650416533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":340376,"user_name":"靠人品去赢","can_delete":false,"product_type":"c1","uid":1301286,"ip_address":"","ucode":"7A20F9EBE847E1","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/26/54f2c164.jpg","comment_is_top":false,"comment_ctime":1648783490,"is_pvip":false,"replies":[{"id":"125174","content":"万一打标错了，一个最好的方案就是扣打标的那个人的年终奖吧。<br><br>金丝雀可以只打线上测试流量，下单商品也打上测试标，即使产生影响也不影响线上真实客户","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1650416285,"ip_address":"","comment_id":340376,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1648783490","product_id":100101301,"comment_content":"像金丝雀这些线上验证，会产生线上数据，万一没搞好打标打错了或者没配置好，导入到正常服务的机器上没有到金丝雀上，怎么辨别消除影响呢？","like_count":1,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":565166,"discussion_content":"万一打标错了，一个最好的方案就是扣打标的那个人的年终奖吧。\n\n金丝雀可以只打线上测试流量，下单商品也打上测试标，即使产生影响也不影响线上真实客户","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650416285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333196,"user_name":"密码123456","can_delete":false,"product_type":"c1","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1644204601,"is_pvip":false,"replies":[{"id":"121833","content":"服务名称相当于这个服务的注册名称，同学想随便写的值是什么？","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1644326815,"ip_address":"","comment_id":333196,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1644204601","product_id":100101301,"comment_content":"LoadBalancerClientFactory.getLazyProvider这个方法，为什么name随便写一个值不行？必须是服务名称？","like_count":0,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550001,"discussion_content":"服务名称相当于这个服务的注册名称，同学想随便写的值是什么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644326815,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1126593,"avatar":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","nickname":"密码123456","note":"","ucode":"9889463CC0EA71","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":550067,"discussion_content":"现在理解了，当时是想，服务发现是nacos进行处理。不太明白，这里为啥还要写服务名。后来发现，应该是分层管理的原则把，把不同的服务名，构建一个spring容器，加载一次负载均衡类。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644373944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":550001,"ip_address":""},"score":550067,"extra":""}]}]},{"had_liked":false,"id":331716,"user_name":"星星滴蓝天","can_delete":false,"product_type":"c1","uid":1465990,"ip_address":"","ucode":"2F2F56F93AD828","user_header":"https://static001.geekbang.org/account/avatar/00/16/5e/86/40877404.jpg","comment_is_top":false,"comment_ctime":1642734813,"is_pvip":false,"replies":[{"id":"121280","content":"文中实现的灰度策略对跨部门没有影响，只要上下游改动都上线了，给流量打上标签就可以。<br><br>不过公司级别一般有自研的灰度框架，各个大厂千差万别，还是要case by case来看","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1642920772,"ip_address":"","comment_id":331716,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1642734813","product_id":100101301,"comment_content":"这种灰度控制一个公司里面多个部门咋协调呢？会不会搞出来冲突","like_count":0,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547879,"discussion_content":"文中实现的灰度策略对跨部门没有影响，只要上下游改动都上线了，给流量打上标签就可以。\n\n不过公司级别一般有自研的灰度框架，各个大厂千差万别，还是要case by case来看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642920772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329666,"user_name":"张叔叔","can_delete":false,"product_type":"c1","uid":2868797,"ip_address":"","ucode":"E8D37CC3596A53","user_header":"https://static001.geekbang.org/account/avatar/00/2b/c6/3d/8a84d713.jpg","comment_is_top":false,"comment_ctime":1641461560,"is_pvip":false,"replies":[{"id":"120087","content":"这个是集群模式下一致性问题，如果是配置了多节点的集群，可以试着重新启动一下。或者把清一下&#47;data&#47;protocol下的内容。最简单的方式是直接以-m standalone单机模式来启动","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1641486225,"ip_address":"","comment_id":329666,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1641461560","product_id":100101301,"comment_content":"老师 添加元数据的时候 报错&quot;caused: errCode: 500, errMsg: do metadata operation failed ;caused: errCode: 500, errMsg: do metadata operation failed Could not find leader : naming_instance_metadata ;&quot; 是什么原因呢","like_count":0,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544379,"discussion_content":"这个是集群模式下一致性问题，如果是配置了多节点的集群，可以试着重新启动一下。或者把清一下/data/protocol下的内容。最简单的方式是直接以-m standalone单机模式来启动","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641486225,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1749926,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/b3/a6/cf4b6798.jpg","nickname":"未知","note":"","ucode":"2ADB7EDF9F3B1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544532,"discussion_content":"还可以启动的时候追加vm的参数 -Dspring.cloud.nacos.discovery.metadata.traffic-version=coupon-template-test001","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1641550391,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2845977,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/6d/19/204b0900.jpg","nickname":"Black Jack","note":"","ucode":"CB16C8F44EF422","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1749926,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/b3/a6/cf4b6798.jpg","nickname":"未知","note":"","ucode":"2ADB7EDF9F3B1F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570766,"discussion_content":"-m standalone 一直不行，你的可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651906158,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":544532,"ip_address":""},"score":570766,"extra":""}]}]},{"had_liked":false,"id":329578,"user_name":"so long","can_delete":false,"product_type":"c1","uid":1449679,"ip_address":"","ucode":"2A6B47BB32FC18","user_header":"https://static001.geekbang.org/account/avatar/00/16/1e/cf/97cd8be1.jpg","comment_is_top":false,"comment_ctime":1641433704,"is_pvip":false,"replies":[{"id":"120091","content":"哦呦，我把同样的代码复制了两遍，同学真细心，我来改一下","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1641487163,"ip_address":"","comment_id":329578,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1641433704","product_id":100101301,"comment_content":"老师，自动装配器ReactorLoadBalancerClientAutoConfiguration中， 如果关闭了Loadbalancer的重试功能 ，则初始化ReactorLoadBalancerExchangeFilterFunction对象的代码复制错了","like_count":0,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544384,"discussion_content":"哦呦，我把同样的代码复制了两遍，同学真细心，我来改一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641487163,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329491,"user_name":"gallifrey","can_delete":false,"product_type":"c1","uid":1366631,"ip_address":"","ucode":"A4E5E0E7E2DEF9","user_header":"https://static001.geekbang.org/account/avatar/00/14/da/67/73a0c754.jpg","comment_is_top":false,"comment_ctime":1641369801,"is_pvip":false,"replies":[{"id":"120019","content":"同学可以看一下后台Nacos的logs文件夹下面的日志报了什么错误信息","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1641399468,"ip_address":"","comment_id":329491,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1641369801","product_id":100101301,"comment_content":"服务详情-编辑实例中，点击确定没有任何更新怎么办。。。找不到解决方案","like_count":0,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544127,"discussion_content":"同学可以看一下后台Nacos的logs文件夹下面的日志报了什么错误信息","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641399469,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2891347,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/1e/53/60f91b65.jpg","nickname":"人在江湖飘也不飘","note":"","ucode":"35674C456E2F44","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549506,"discussion_content":"重新刷新一下页面，有时候要多刷新几次","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644039133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}