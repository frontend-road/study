{"id":96994,"title":"12 | 进程内协同：同步、互斥与通讯","content":"<p>你好，我是七牛云许式伟。</p><p>上一讲开始我们进入了多任务的世界，我们详细介绍了三类执行体：进程、线程和协程，并且介绍了每一种执行体的特点。</p><p>既然启动了多个执行体，它们就需要相互协同，今天我们先讨论进程内的执行体协同。</p><p>考虑到进程内的执行体有两类：用户态的协程（以 Go 语言的 goroutine 为代表）、操作系统的线程，我们对这两类执行体的协同机制做个概要。如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/57/1b/575d31c0ebf3f4a6148a211387bdae1b.jpg?wh=613*571\" alt=\"\"></p><p>让我们逐一详细分析一下它们。</p><h2>原子操作</h2><p>首先让我们看一下原子操作。需要注意的是，原子操作是 CPU 提供的能力，与操作系统无关。这里列上只是为了让你能够看到进程内通讯的全貌。</p><p>顾名思义，原子操作的每一个操作都是原子的，不会中途被人打断，这个原子性是 CPU 保证的，与执行体的种类无关，无论 goroutine 还是操作系统线程都适用。</p><p>从语义上来说，原子操作可以用互斥体来实现，只不过原子操作要快得多。</p><p>例如：</p><pre><code>var val int32\n...\nnewval = atomic.AddInt32(&amp;val, delta)\n</code></pre><p>等价于：</p><pre><code>var val int32\nvar mutex sync.Mutex\n...\nmutex.Lock()\nval += delta\nnewval = val\nmutex.Unlock()\n</code></pre><h2>执行体的互斥</h2><p>互斥体也叫锁。锁用于多个执行体之间的互斥访问，避免多个执行体同时操作一组数据产生竞争。其使用界面上大概是这样的：</p><pre><code>func (m *Mutex) Lock()\nfunc (m *Mutex) Unlock()\n</code></pre><p>锁的使用范式比较简单：在操作需要互斥的数据前，先调用 Lock，操作完成后就调用 Unlock。但总是存在一些不求甚解的人，对锁存在各种误解。</p><!-- [[[read_end]]] --><p>有的人会说锁很慢。甚至我曾看到有 Go 程序员用 channel 来模拟锁，理由就是锁太慢了，尽量不要用锁。产生“锁慢，channel 快”这种错觉的一个原因，可能是人们经常看到这样的忠告：</p><blockquote>\n<p><strong>不要通过共享内存（锁）来通信，要通过通信（channel）来共享内存。</strong></p>\n</blockquote><p>不明就里的人们看到这话后，可能就有了这样的印象：锁是坏的，锁是性能杀手，channel 是好的，是 Go 发明的先进武器，应该尽可能用 channel，而不要用锁。</p><p>快慢是相对而言的。锁的确会导致代码串行执行，所以在某段代码并发度非常高的情况下，串行执行的确会导致性能的显著降低。但平心而论，相比其他的进程内通讯的原语来说，锁并不慢。从进程内通讯来说，比锁快的东西，只有原子操作。</p><p>例如 channel，作为进程内执行体间传递数据的设施来说，它本身是共享变量，所以 channel 的每个操作必然是有锁的。事实上，channel 的每个操作都比较耗时。关于这一点，在下文解释 channel 背后的工作机理后，你就会清楚知道。</p><p>那么锁的问题在哪里？锁的最大问题在于不容易控制。锁 Lock 了但是忘记 Unlock 后是灾难性的，因为相当于服务器挂了，所有和该锁相关的代码都不能被执行。</p><p>比如：</p><pre><code>mutex.Lock()\ndoSth()\nmutex.Unlock()\n</code></pre><p>在考虑异常的情况下，这段代码是不安全的，如果 doSth 抛出了异常，那么服务器就会出现问题。</p><p>为此 Go 语言还专门发明了一个 defer 语法来保证配对：</p><pre><code>mutex.Lock()\ndefer mutex.Unlock()\ndoSth()\n</code></pre><p>这样可以保证即使 doSth 发生异常，mutex.Unlock 仍然会被正确地执行。这类在异常情况下也能够正常工作的代码，我们称之为 “对异常安全的代码”。如果语言不支持 defer，而是支持 try .. catch，那么代码可能是这样的：</p><pre><code>mutex.Lock()\ntry {\n    doSth()\n} catch (e Exception) {\n    mutex.Unlock()\n    throw e\n}\nmutex.Unlock()\n</code></pre><p>锁不容易控制的另一个表现是锁粒度的问题。例如上面 doSth 函数里面如果调用了网络 IO 请求，而网络 IO 请求在少数特殊情况下可能会出现慢请求，要好几秒才返回。那么这几秒对服务器来说就好像挂了，无法处理请求。</p><p>对服务器来说这是极为致命的。对后端程序员来说，有一句箴言要牢记：</p><blockquote>\n<p><strong>不要在锁里面执行费时操作。</strong></p>\n</blockquote><p>这里 “锁里面” 是指在<code>mutex.Lock</code>和<code>mutex.Unlock</code>之间的代码。</p><p>在锁的最佳编程实践中，如果明确一组数据的并发访问符合 “绝大部分情况下是读操作，少量情况有写操作” ，这种 “读多写少” 特征，那么应该用读写锁。</p><p>所谓读写锁，是把锁里面的操作分为读操作和写操作两种，对应调用不同的互斥操作。</p><p>如果是读操作，代码如下：</p><pre><code>mutex.RLock()\ndefer mutex.RUnlock()\ndoReadOnlyThings\n</code></pre><p>如果是锁里面是写操作，代码就和普通锁一样，如下：</p><pre><code>mutex.Lock()\ndefer mutex.Unlock()\ndoWriteThings\n</code></pre><p>为什么在 “读多写少” 的情况下，这样的使用范式能够优化性能？</p><p>因为从需求上来说，如果当前我们正在执行某个读操作，那么再来一个新的读操作，是不应该挡在外面的，大家都不修改数据，可以安全地并发执行。但如果来的是写操作，就应该挡在外面，等待读操作执行完。整体来说，读写锁的特性就是：</p><blockquote>\n<p><strong>读操作不阻止读操作，阻止写操作；</strong><br>\n<strong>写操作阻止一切，不管读操作还是写操作。</strong></p>\n</blockquote><h2>执行体的同步</h2><p>聊完了执行体的互斥，我们再来看下执行体之间的同步。</p><p>同步的一个最常见的场景是：把一个大任务分解为n个小任务，分配给n个执行体并行去做，等待它们一起做完。这种同步机制我们叫 “等待组”。</p><p>其使用界面上大概是这样的：</p><pre><code>func (wg *WaitGroup) Add(n int)\nfunc (wg *WaitGroup) Done()\nfunc (wg *WaitGroup) Wait()\n</code></pre><p>用法上大概是这样的：</p><pre><code>var wg WaitGroup\n...\nwg.Add(n)\nfor 循环n次 {\n    go func() {\n        defer wg.Done()\n        doTaski  // 执行第i个任务\n    }()\n}\nwg.Wait()\n</code></pre><p>简而言之，在每个任务开始的时候调用 wg.Add(1)，结束的时候调用 wg.Done()，然后在主执行体调用 wg.Wait() 等待这些任务结束。</p><p>需要注意的是，wg.Add(1) 是要在任务的 goroutine 还没有开始就先调用，否则可能出现某个任务还没有开始执行就被认为结束了。</p><p>条件变量（Condition Variable）是一个更通用的同步原语，设计精巧又极为强大。强大到什么程度？像 channel 这样的通讯机制都可以用它来实现。</p><p>条件变量的使用界面上大概是这样的：</p><pre><code>func NewCond(l Locker) *Cond\nfunc (c *Cond) Broadcast()\nfunc (c *Cond) Signal()\nfunc (c *Cond) Wait()\n</code></pre><p>那么，怎么用条件变量？</p><p>我们先看下初始化。条件变量初始化的时候需要传入一个互斥体，它可以是普通锁（Mutex)，也可以是读写锁（RWMutex）。如下：</p><pre><code>var mutex sync.Mutex  // 也可以是 sync.RWMutex\nvar cond = sync.NewCond(&amp;mutex)\n...\n</code></pre><p>为什么创建条件变量需要传入锁？因为 cond.Wait() 的需要。Wait 内部实现逻辑是：</p><pre><code>把自己加入到挂起队列\nmutex.Unlock()\n等待被唤醒  // 挂起的执行体会被后续的 cond.Broadcast 或 cond.Signal() 唤醒\nmutex.Lock()\n</code></pre><p>初始化了条件变量后，我们再来看看它的使用方式。条件变量的用法有一个标准化的模板，看起来大概是这样的：</p><pre><code>mutex.Lock()\ndefer mutex.Unlock()\nfor conditionNotMetToDo {\n    cond.Wait()\n}\ndoSomething\nif conditionNeedNotify {\n    cond.Broadcast()\n    // 有时可以优化为 cond.Signal()\n}\n</code></pre><p>看起来有些复杂，让我们来解释一下。加锁后，先用一个 for 循环判断当前是否能够做我们想做的事情，如果做不了就调用 cond.Wait() 进行等待。</p><p>这里很重要的一个细节是注意用的是 for 循环，而不是 if 语句。这是因为 cond.Wait() 得到了执行权后不代表我们想做的事情就一定能够干了，所以要再重新判断一次条件是否满足。</p><p>确定能够做事情了，于是 doSomething。在做的过程中间，如果我们判断可能挂起队列中的部分执行体满足了重新执行的条件，就用 cond.Broadcast 或 cond.Signal 唤醒它们。</p><p>cond.Broadcast 比较粗暴，它唤醒了所有在这个条件变量挂起的执行体，而 cond.Signal 则只唤醒其中的一个。</p><p>什么情况下应该用 cond.Broadcast，什么情况下应该用 cond.Signal？最偷懒的方式当然是不管三七二十一，用 cond.Broadcast 一定没问题。但是本着经济的角度，我们还是要交代清楚 cond.Signal 的适用范围：</p><ul>\n<li>挂起在这个条件变量上的执行体，它们等待的条件是一致的；</li>\n<li>本次 doSomething 操作完成后，所释放的资源只够一个执行体来做事情。</li>\n</ul><p>Cond 原语虽然叫条件变量，但是实际上它既没有明白说变量具体是什么样的，也没有说条件具体是什么样的。变量是指 “一组要在多个执行体之间协同的数据”。条件是指做任务前 Wait 的 “前置条件”，和做任务时需要唤醒其它人的 “唤醒条件”。</p><p>这样的介绍相当的抽象。我们拿 Go 语言的 channel 开刀，自己实现一个。代码如下：</p><pre><code>type Channel struct {\n    mutex sync.Mutex\n    cond *sync.Cond\n    queue *Queue\n    n int\n}\n\nfunc NewChannel(n int) *Channel {\n    if n &lt; 1 {\n        panic(&quot;todo: support unbuffered channel&quot;)\n    }\n    c := new(Channel)\n    c.cond = sync.NewCond(&amp;c.mutex)\n    c.queue = NewQueue()\n    // 这里 NewQueue 得到一个普通的队列\n    // 代码从略\n    c.n = n\n    return c\n}\n\nfunc (c *Channel) Push(v interface{}) {\n    c.mutex.Lock()\n    defer c.mutex.Unlock()\n    for c.queue.Len() == c.n { // 等待队列不满\n        c.cond.Wait()\n    }\n    if c.queue.Len() == 0 { // 原来队列是空的，可能有人等待数据，通知它们\n        c.cond.Broadcast()\n    }\n    c.queue.Push(v)\n}\n\nfunc (c *Channel) Pop() (v interface{}) {\n    c.mutex.Lock()\n    defer c.mutex.Unlock()\n    for c.queue.Len() == 0 { // 等待队列不空\n        c.cond.Wait()\n    }\n    if c.queue.Len() == c.n { // 原来队列是满的，可能有人等着写数据，通知它们\n        c.cond.Broadcast()\n    }\n    return c.queue.Pop()\n}\n\nfunc (c *Channel) TryPop() (v interface{}, ok bool) {\n    c.mutex.Lock()\n    defer c.mutex.Unlock()\n    if c.queue.Len() == 0 { // 如果队列为空，直接返回\n        return\n    }\n    if c.queue.Len() == c.n { // 原来队列是满的，可能有人等着写数据，通知它们\n        c.cond.Broadcast()\n    }\n    return c.queue.Pop(), true\n}\n\nfunc (c *Channel) TryPush(v interface{}) (ok bool) {\n    c.mutex.Lock()\n    defer c.mutex.Unlock()\n    if c.queue.Len() == c.n { // 如果队列满，直接返回\n        return\n    }\n    if c.queue.Len() == 0 { // 原来队列是空的，可能有人等待数据，通知它们\n        c.cond.Broadcast()\n    }\n    c.queue.Push(v)\n    return true\n}\n</code></pre><p>对着这个 Channel 的实现，你是否对条件变量有感觉很多？顺便提醒一点，这个 Channel 的实现不支持无缓冲 channel，也就是不支持 NewChannel(0) 的情况。如果你感兴趣，可以改改这个问题。</p><h2>执行体的通讯</h2><p>聊完同步与互斥，我们接着聊执行体的通讯：怎么在执行体间收发消息。</p><p>管道是大家都很熟知的执行体间的通讯机制。规格如下：</p><pre><code>func Pipe() (pr *PipeReader, pw PipeWriter)\n</code></pre><p>用法上，先调用<code>pr, pw := io.Pipe()</code>得到管道的写入端和读出端，分别传给两个并行执行的 goroutine（其他语言也类似），然后一个 goroutine 读，一个 goroutine 写就好了。</p><p>管道用处很多。一个比较常见的用法是做读写转换，例如，假设我手头有一个算法：</p><pre><code>func Foo(w io.Writer) error\n</code></pre><p>这个算法生成的数据流，需要作为另一个函数的输入，但是这个函数的输入是 io.Reader，原型如下：</p><pre><code>func Bar(r io.Reader)\n</code></pre><p>那么怎么把它们串起来呢？用管道我们很容易实现这样的变换：</p><pre><code>func FooReader() io.ReadCloser {\n    pr, pw := io.Pipe()\n    go func() {\n        err := Foo(pw)\n        pw.CloseWithError(err)\n    }()\n    return pr\n}\n</code></pre><p>这个 FooReader 函数几句话就把 Foo 变成了一个符合 io.Reader 接口的对象，它就可以很方便的和 Bar 函数结合了。</p><p>其实 Go 语言中引入的 channel 也是管道，只不过它是类型安全的管道。具体用法如下：</p><pre><code>c := make(chan Type, n) // 创建一个能够传递 Type 类型数据的管道，缓冲大小为 n\n...\ngo func() {\n    val := &lt;-c // 从管道读入\n}()\n...\ngo func() {\n    c &lt;- val // 向管道写入\n}()\n</code></pre><p>我们后面在 “服务端开发” 一章，我们还会比较详细讨论 channel，今天先了解一个大体的语义。</p><h2>结语</h2><p>总结一下，我们今天主要聊了执行体间的协同机制：原子操作、同步、互斥与通讯。我们重点聊了锁和同步原语 “条件变量”。</p><p>锁在一些人心中是有误解的，但实际上锁在服务端编程中的比重并不低，我们可能经常需要和它打交道，建议多花精力理解它们。</p><p>条件变量是最复杂的同步原语，功能强大。虽然平常我们直接使用条件变量的机会不是太多，大部分常见的场景往往有更高阶的原语（例如 channel）可以取代。但是它的设计精巧而高效，值得细细体会。</p><p>你会发现，操作系统课本上的信号量这样的同步原语，我们这里没有交代，这是因为它被更强大而且性能更好的同步原语 “条件变量” 所取代了。</p><p>上面我们为了介绍条件变量的用法，我们实作了一个 channel，你也可以考虑用信号量这样的东西来实现一遍，然后分析一下为什么我们说基于 “条件变量” 的版本是更优的。</p><p>如果你对今天的内容有什么思考与解读，欢迎给我留言，我们一起讨论。在下期，我们将讨论进程与进程之间的协同：进程间的同步互斥、资源共享与通讯。</p><p>如果你觉得有所收获，也欢迎把文章分享给你的朋友。感谢你的收听，我们下期再见。</p>","neighbors":{"left":{"article_title":"11 | 多任务：进程、线程与协程","id":96324},"right":{"article_title":"13 | 进程间的同步互斥、资源共享与通讯","id":97617}},"comments":[{"had_liked":false,"id":97451,"user_name":"笨拙的自由","can_delete":false,"product_type":"c1","uid":1309452,"ip_address":"","ucode":"BEDD613DEDD8ED","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLRwauvbuyKfib8Qm3NBNU908zhKS0WPnvTEN4EJYSJyKwMuSHTWgXqP5WrSexgQAhLSiblydA24EMg/132","comment_is_top":false,"comment_ctime":1558674013,"is_pvip":false,"replies":[{"id":"34868","content":"如果用 Java，代码看起来是这样的：<br><br>class Channel {<br>    private final Lock lock = new ReentrantLock();<br>    private Condition cond = lock.newCondition();<br>    private final Queue queue = new Queue();<br>    private int n;<br><br>    public Channel(int cap) {<br>         n = cap;<br>    }<br><br>    public void push(Object v) {<br>         lock.lock();<br>         try {<br>             while (queue.size() == n) {<br>                  cond.await();<br>             }<br>             if (queue.size() == 0) {<br>                  cond.signalAll();<br>             }<br>             queue.push(v);<br>         } finally {<br>             lock.unlock();<br>         }<br>    }<br><br>    public Object pop() {<br>         lock.lock();<br>         try {<br>             while (queue.size() == 0) {<br>                  cond.await();<br>             }<br>             if (queue.size() == n) {<br>                  cond.signalAll();<br>             }<br>             return queue.pop();<br>         } finally {<br>             lock.unlock();<br>         }<br>    }<br>}","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1558688857,"ip_address":"","comment_id":97451,"utype":1}],"discussion_count":3,"race_medal":0,"score":"216307038813","product_id":100025201,"comment_content":"希望老师类比java说一下,特别是条件原语那块看得有点懵","like_count":51,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451283,"discussion_content":"如果用 Java，代码看起来是这样的：\n\nclass Channel {\n    private final Lock lock = new ReentrantLock();\n    private Condition cond = lock.newCondition();\n    private final Queue queue = new Queue();\n    private int n;\n\n    public Channel(int cap) {\n         n = cap;\n    }\n\n    public void push(Object v) {\n         lock.lock();\n         try {\n             while (queue.size() == n) {\n                  cond.await();\n             }\n             if (queue.size() == 0) {\n                  cond.signalAll();\n             }\n             queue.push(v);\n         } finally {\n             lock.unlock();\n         }\n    }\n\n    public Object pop() {\n         lock.lock();\n         try {\n             while (queue.size() == 0) {\n                  cond.await();\n             }\n             if (queue.size() == n) {\n                  cond.signalAll();\n             }\n             return queue.pop();\n         } finally {\n             lock.unlock();\n         }\n    }\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558688857,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1021825,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/97/81/e1eaf621.jpg","nickname":"David","note":"","ucode":"22CBBC13FC97A9","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384942,"discussion_content":"blockingqueue","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626828852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1311772,"avatar":"https://static001.geekbang.org/account/avatar/00/14/04/1c/b0c6c009.jpg","nickname":"zhj","note":"","ucode":"65B9E222D6E075","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":196681,"discussion_content":"类比java的blockqueue就可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583368756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98198,"user_name":"立耳","can_delete":false,"product_type":"c1","uid":1497753,"ip_address":"","ucode":"99C8E4DC67ED01","user_header":"https://static001.geekbang.org/account/avatar/00/16/da/99/80222c2a.jpg","comment_is_top":false,"comment_ctime":1558929026,"is_pvip":false,"replies":[{"id":"35155","content":"代码没有问题的。先 Push 还是先通知都可以，次序可以交换的。因为反正锁还没有释放，这里只是标记一下哪些执行体可以调度，并没有真正发生控制权的转移。而且就算转移了也没问题的，你可以留意下本文贴的条件变量的 Wait 函数实现，它获得控制权后下一句就是 mutex.Lock 去申请锁，而我们这里是 Push 后才调用 mutex.Unlock 释放锁的，所以 Broadcast 和 Push 的次序可以随意交换。","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1558938276,"ip_address":"","comment_id":98198,"utype":1}],"discussion_count":4,"race_medal":0,"score":"87458274946","product_id":100025201,"comment_content":"许老师，下面的这段代码是不是存在问题，以Push为例，应该先执行 c.queue.Push 再进行广播，否则可能通知到其他协程进行Pop，系统调度可能先进行了另外一个协程的c.queue.Pop()， 这个时候还没有入队列。<br> <br>func (c *Channel) Push(v interface{}) {<br>    c.mutex.Lock()<br>    defer c.mutex.Unlock()<br>    for c.queue.Len() == c.n { &#47;&#47; 等待队列不满<br>        c.cond.Wait()<br>    }<br>    if c.queue.Len() == 0 { &#47;&#47; 原来队列是空的，可能有人等待数据，通知它们<br>        c.cond.Broadcast()<br>    }<br>    c.queue.Push(v)<br>}<br><br>func (c *Channel) Pop() (v interface{}) {<br>    c.mutex.Lock()<br>    defer c.mutex.Unlock()<br>    for c.queue.Len() == 0 { &#47;&#47; 等待队列不空<br>        c.cond.Wait()<br>    }<br>    if c.queue.Len() == c.n { &#47;&#47; 原来队列是满的，可能有人等着写数据，通知它们<br>        c.cond.Broadcast()<br>    }<br>    return c.queue.Pop()<br>}<br><br>func (c *Channel) TryPop() (v interface{}, ok bool) {<br>    c.mutex.Lock()<br>    defer c.mutex.Unlock()<br>    if c.queue.Len() == 0 { &#47;&#47; 如果队列为空，直接返回<br>        return<br>    }<br>    if c.queue.Len() == c.n { &#47;&#47; 原来队列是满的，可能有人等着写数据，通知它们<br>        c.cond.Broadcast()<br>    }<br>    return c.queue.Pop(), true<br>}<br><br>func (c *Channel) TryPush(v interface{}) (ok bool) {<br>    c.mutex.Lock()<br>    defer c.mutex.Unlock()<br>    if c.queue.Len() == c.n { &#47;&#47; 如果队列满，直接返回<br>        return<br>    }<br>    if c.queue.Len() == 0 { &#47;&#47; 原来队列是空的，可能有人等待数据，通知它们<br>        c.cond.Broadcast()<br>    }<br>    c.queue.Push(v)<br>    return true<br>}<br>","like_count":21,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451595,"discussion_content":"代码没有问题的。先 Push 还是先通知都可以，次序可以交换的。因为反正锁还没有释放，这里只是标记一下哪些执行体可以调度，并没有真正发生控制权的转移。而且就算转移了也没问题的，你可以留意下本文贴的条件变量的 Wait 函数实现，它获得控制权后下一句就是 mutex.Lock 去申请锁，而我们这里是 Push 后才调用 mutex.Unlock 释放锁的，所以 Broadcast 和 Push 的次序可以随意交换。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1558938276,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1592279,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","nickname":"William Ning","note":"","ucode":"4DB8D05E69E5F3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572571,"discussion_content":"这代码应该是文中的代码块，其实可以说明是哪个代码块就行，版面占据太大～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652860187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1105385,"avatar":"https://static001.geekbang.org/account/avatar/00/10/dd/e9/40a98e2f.jpg","nickname":"卓修武","note":"","ucode":"21B8FFBDCACBDF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":265456,"discussion_content":"标记可以调度的执行体，以执行体是线程为例，  这个是操作系统来完成的吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589388250,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1474356,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI3F4IdQuDZrhN8ThibP85eCiaSWTYpTrcC6QB9EoAkw3IIj6otMibb1CgrS1uzITAnJmGLXQ2tgIkAQ/132","nickname":"cugphoenix","note":"","ucode":"80101AF04C00D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":96409,"discussion_content":"这条留言问了我想问的，许老师的解答也看懂了👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577063769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97438,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1558669100,"is_pvip":false,"replies":[{"id":"34851","content":"一个操作系统调度，一个用户态自己来调度","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1558675961,"ip_address":"","comment_id":97438,"utype":1}],"discussion_count":4,"race_medal":0,"score":"53098276652","product_id":100025201,"comment_content":"协程和线程还是没区别清楚","like_count":13,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451280,"discussion_content":"一个操作系统调度，一个用户态自己来调度","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558675961,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2038718,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/1b/be/525e05ae.jpg","nickname":"NiceBlueChai","note":"","ucode":"2043333890C448","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375406,"discussion_content":"其实线程也分用户态线程和内核态的线程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621609971,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1676962,"avatar":"https://static001.geekbang.org/account/avatar/00/19/96/a2/c1596dd8.jpg","nickname":"🤔","note":"","ucode":"40ACB53BF3C6B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2038718,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/1b/be/525e05ae.jpg","nickname":"NiceBlueChai","note":"","ucode":"2043333890C448","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":566474,"discussion_content":"用户线程的缺点主要有：线程发生I/O或页面故障引起的阻塞时，如果调用阻塞系统调用则内核由于不知道有多线程的存在，而会阻塞整个进程从而阻塞所有线程, 因此同一进程中只能同时有一个线程在运行；go协程就是解决了这个缺点了\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650699075,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":375406,"ip_address":""},"score":566474,"extra":""}]},{"author":{"id":1394115,"avatar":"https://static001.geekbang.org/account/avatar/00/15/45/c3/051ffe83.jpg","nickname":"rubys_","note":"","ucode":"931AD02864126A","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362956,"discussion_content":"线程不是操作系统调度的吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617080012,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97869,"user_name":"Geek_gooy","can_delete":false,"product_type":"c1","uid":1504570,"ip_address":"","ucode":"FC168C31530040","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLluwfFjxlCmg9p2rJVicBdBo6OYpN0EAotUguias8wc78WtAEPHsWic0880CqGwyNypy2KZqVpYhGiag/132","comment_is_top":false,"comment_ctime":1558800581,"is_pvip":false,"replies":[{"id":"34991","content":"是这样，你可以看我文章中Wait的代码，在唤醒后第一件事情是lock，也就是请求锁，所以只有A线程unlock后，其他被唤醒的线程中的一个会得到锁往下走。","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1558828401,"ip_address":"","comment_id":97869,"utype":1}],"discussion_count":1,"race_medal":0,"score":"44508473541","product_id":100025201,"comment_content":"老师<br>我明白了， 比如A线程notify或者signal，被唤醒的线程并不会马上执行，而是需要等待A线程退出同步块或者unlock才会执行。<br><br>如果是notifyAll，也同样如此，但是等到唤醒并获得执行权的线程执行结束后，CPU会优先把执行权交给上次唤醒没有得到执行权的某个线程，而不会给阻塞在锁外面等待锁的线程。和调用notify只唤醒一个还是有些许区别的。","like_count":11,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451456,"discussion_content":"是这样，你可以看我文章中Wait的代码，在唤醒后第一件事情是lock，也就是请求锁，所以只有A线程unlock后，其他被唤醒的线程中的一个会得到锁往下走。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558828401,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97834,"user_name":"Geek_gooy","can_delete":false,"product_type":"c1","uid":1504570,"ip_address":"","ucode":"FC168C31530040","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLluwfFjxlCmg9p2rJVicBdBo6OYpN0EAotUguias8wc78WtAEPHsWic0880CqGwyNypy2KZqVpYhGiag/132","comment_is_top":false,"comment_ctime":1558790686,"is_pvip":false,"replies":[{"id":"34982","content":"1、你是对的，用两个cond性能会更好。但是用一个也是可以正常工作的。<br>2、cond.signal 不是把锁释放了，是让等待在这个cond上的执行体改变状态（从挂起到可被调度），从而允许调度程序给它执行权。<br>3、对的","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1558796959,"ip_address":"","comment_id":97834,"utype":1}],"discussion_count":1,"race_medal":0,"score":"44508463646","product_id":100025201,"comment_content":"老师<br>1、像这种有进有出的是不是应该创建两个condition。大小为满时，避免进的线程，唤醒的可能还是进的线程。大小为零时，出的唤醒的还是出的线程。<br>2、cond.signal()方法把lock锁释放了吗，如果释放了，后面再unlock是不是没做任何操作。<br>3、像老师评论中的Java单锁channel举例改为普通的sync,object.wait(),notify是不是效果一样，但性能没lock好。对于两个condition，java对象的notify就不好指定唤醒了。","like_count":11,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451444,"discussion_content":"1、你是对的，用两个cond性能会更好。但是用一个也是可以正常工作的。\n2、cond.signal 不是把锁释放了，是让等待在这个cond上的执行体改变状态（从挂起到可被调度），从而允许调度程序给它执行权。\n3、对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558796959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97666,"user_name":"Taozi","can_delete":false,"product_type":"c1","uid":1021926,"ip_address":"","ucode":"DD6567A31B3E33","user_header":"","comment_is_top":false,"comment_ctime":1558745869,"is_pvip":false,"replies":[{"id":"34926","content":"对的","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1558759844,"ip_address":"","comment_id":97666,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35918484237","product_id":100025201,"comment_content":"总算明白为什么叫条件变量了，拿这里的Channel 实现来说，几个执行体要读写的队列是“变量”，队列的长度是“等待条件”和“唤醒条件”。是这样理解吗？","like_count":8,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451367,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558759844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98665,"user_name":"Cordova","can_delete":false,"product_type":"c1","uid":1507212,"ip_address":"","ucode":"CADCB5D4F48F33","user_header":"https://static001.geekbang.org/account/avatar/00/16/ff/8c/a6a2b26b.jpg","comment_is_top":false,"comment_ctime":1559053514,"is_pvip":false,"replies":[{"id":"35314","content":"1、go和java的代码只是形似，实质不同，因为go里面的channel是协程的通讯设施，java版本的是线程的通讯设施，大相径庭；<br>2、我们本节提的同步，和同步io的同步，两个是完全不同含义的同步；<br>3、我们课程不太会讲资料已经相对多的某个细节，除非这个细节非常关键影响到全局的理解。","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1559059822,"ip_address":"","comment_id":98665,"utype":1}],"discussion_count":2,"race_medal":0,"score":"31623824586","product_id":100025201,"comment_content":"看完代码后发现go做的通信发现并没有什么优势，其他语言做通信也这么干、刷了下评论区提到libevent、才恍然发现标题这节讲的是同步！可能是我太期待许老师讲异步了😂～ 目前python我用异步首选会把异步过程交给libuv。听了老师上节讲到python的协程只是一种编程范式，想到内置的asyncio虽然是做了异步但还是有很较大的性能提升空间这个逻辑也就通了！希望许老师在讲异步的时候能多提一提跨平台异步库他们是怎么实现","like_count":7,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451777,"discussion_content":"1、go和java的代码只是形似，实质不同，因为go里面的channel是协程的通讯设施，java版本的是线程的通讯设施，大相径庭；\n2、我们本节提的同步，和同步io的同步，两个是完全不同含义的同步；\n3、我们课程不太会讲资料已经相对多的某个细节，除非这个细节非常关键影响到全局的理解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559059822,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1592279,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","nickname":"William Ning","note":"","ucode":"4DB8D05E69E5F3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572573,"discussion_content":"“我们本节提的同步，和同步io的同步，两个是完全不同含义的同步；” ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652861376,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97908,"user_name":"f抵达","can_delete":false,"product_type":"c1","uid":1147808,"ip_address":"","ucode":"98D52386C35AA8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIIDUnsfAibxPWsyo6y0yZ3ZUZVzgN1U3uvYHGvJ1tSfmDtNwUVDcm0pM3uHzzR5Lwlu28519aUMQQ/132","comment_is_top":false,"comment_ctime":1558837774,"is_pvip":false,"replies":[{"id":"35028","content":"寄存器不是输入输出设备，操作寄存器不需要经过操作系统，编译器整天和寄存器打交道的。","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1558855214,"ip_address":"","comment_id":97908,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31623608846","product_id":100025201,"comment_content":"如果是用户太自己对寄存器进行操作？<br>对物理器件的操作不都是要经过系统调用么？<br>难道协程x是用户态的操作系统？","like_count":8,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451467,"discussion_content":"寄存器不是输入输出设备，操作寄存器不需要经过操作系统，编译器整天和寄存器打交道的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558855214,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":247635,"user_name":"Eternal","can_delete":false,"product_type":"c1","uid":1188023,"ip_address":"","ucode":"EA6FE7CC98F740","user_header":"https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg","comment_is_top":false,"comment_ctime":1599784240,"is_pvip":false,"replies":[{"id":"90939","content":"信号量的条件太死板，不可编程。条件变量的条件是任意条件，是可编程的。","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1599793369,"ip_address":"","comment_id":247635,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18779653424","product_id":100025201,"comment_content":"信号量只能实现一个条件，条件变量能实现多了条件，不知理解对不对","like_count":5,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505457,"discussion_content":"信号量的条件太死板，不可编程。条件变量的条件是任意条件，是可编程的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599793369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101437,"user_name":"Ender","can_delete":false,"product_type":"c1","uid":1354521,"ip_address":"","ucode":"FB33FCE576912D","user_header":"https://static001.geekbang.org/account/avatar/00/14/ab/19/23034ffa.jpg","comment_is_top":false,"comment_ctime":1559808871,"is_pvip":false,"replies":[{"id":"36572","content":"向 channel.push 一个对象时，要考虑 channel 满了，这时会等待，这就是 cond.Wait 的逻辑","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1559815763,"ip_address":"","comment_id":101437,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14444710759","product_id":100025201,"comment_content":"还是没太明白条件变量在channel代码里面的意义，所有操作都是先获取锁，在一个操作没完成的情况下其他都不会进到cond.Wait()呀。按理只需要锁就能做到了channel的实现了。","like_count":4,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452961,"discussion_content":"向 channel.push 一个对象时，要考虑 channel 满了，这时会等待，这就是 cond.Wait 的逻辑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559815763,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97905,"user_name":"Geek_03056e","can_delete":false,"product_type":"c1","uid":1509657,"ip_address":"","ucode":"6D4289AD71BC1A","user_header":"","comment_is_top":false,"comment_ctime":1558837099,"is_pvip":false,"replies":[{"id":"35027","content":"不一样，这样写最终用的是libevent的异步回调模式。没法用同步io模型。","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1558855107,"ip_address":"","comment_id":97905,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14443738987","product_id":100025201,"comment_content":"将线程统一申请，弄一个线程池，使用条件变量唤醒，使用时唤醒，用完后休眠，就像nginx中的线程池。这种设计是不和协程就一样了，在用户态构建执行体？","like_count":3,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451466,"discussion_content":"不一样，这样写最终用的是libevent的异步回调模式。没法用同步io模型。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558855107,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97773,"user_name":"白小狮","can_delete":false,"product_type":"c1","uid":1148049,"ip_address":"","ucode":"222BAC022A630A","user_header":"https://static001.geekbang.org/account/avatar/00/11/84/91/1a7dc912.jpg","comment_is_top":false,"comment_ctime":1558770169,"is_pvip":false,"replies":[{"id":"34937","content":"设计上，goroutine 应该自己去 recover 错误，而不是主进程来 recover。","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1558777765,"ip_address":"","comment_id":97773,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14443672057","product_id":100025201,"comment_content":"go中的panic会导致整个主进程都挂掉，goroutine里面的panic后cover不住，是逻辑上就是应该整个主进程都退出吗","like_count":3,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451412,"discussion_content":"设计上，goroutine 应该自己去 recover 错误，而不是主进程来 recover。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558777765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97715,"user_name":"cc","can_delete":false,"product_type":"c1","uid":1239833,"ip_address":"","ucode":"AA1B8EA613E3A9","user_header":"https://static001.geekbang.org/account/avatar/00/12/eb/19/19e706a5.jpg","comment_is_top":false,"comment_ctime":1558752944,"is_pvip":false,"replies":[{"id":"34925","content":"次序可以交换的。因为反正锁还没有释放，这里只是标记一下哪些执行体可以调度","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1558759710,"ip_address":"","comment_id":97715,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14443654832","product_id":100025201,"comment_content":"老师，我看你的chanel代码实现，比如pop方法。是先broadcast，后pop。我的理解刚好相反。应该是先pop后通知。请教下问什么","like_count":3,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451383,"discussion_content":"次序可以交换的。因为反正锁还没有释放，这里只是标记一下哪些执行体可以调度","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558759710,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97439,"user_name":"輪迴","can_delete":false,"product_type":"c1","uid":1010641,"ip_address":"","ucode":"7504F61285BE35","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/d1/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1558669231,"is_pvip":true,"replies":[{"id":"34852","content":"👍","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1558677427,"ip_address":"","comment_id":97439,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14443571119","product_id":100025201,"comment_content":"同时在看《深入浅出计算机组成原理》和《GO 语言从入门到实战》，发现三个课程之间的关联性还是蛮多的，相辅相成，更加帮助知识点的深入理解","like_count":4,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451281,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558677427,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97392,"user_name":"mz","can_delete":false,"product_type":"c1","uid":1003581,"ip_address":"","ucode":"1D714C23F78446","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/MlmSR4YXUfrNlZdMv7bv1ic64HaxxVKcVtaxjzhXCvNC4XByICCmYUTprhOESzIV8p59N6DnSJ7HywfvGr5nicgA/132","comment_is_top":false,"comment_ctime":1558663922,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14443565810","product_id":100025201,"comment_content":"感觉和 Java 的 wait notify notifyall 很像","like_count":3,"discussions":[{"author":{"id":1188023,"avatar":"https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg","nickname":"Eternal","note":"","ucode":"EA6FE7CC98F740","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305094,"discussion_content":"wait notify notifyall只实现了一个信号","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599784050,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98699,"user_name":"thewangzl","can_delete":false,"product_type":"c1","uid":1006661,"ip_address":"","ucode":"5968FDED0C5AC8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/45/2fa66e67.jpg","comment_is_top":false,"comment_ctime":1559059926,"is_pvip":false,"replies":[{"id":"35326","content":"你说的是对的。我其实没想到什么情况下用signal，大部分情况下都是用 broadcast，包括本文中的例子。因为用 signal 意味着每次资源的使用都要通知，其实退化为信号量的 PV 操作了，这一定性能是变差的。","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1559083676,"ip_address":"","comment_id":98699,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10148994518","product_id":100025201,"comment_content":"老师你好，文章中说Signal比Broadcast好些，但是王宝令老师的专栏《Java并发编程实战》第15章提到Dubbo唤醒等待线程从signal优化为signalAll。是因为java中的signal&#47;signalAll和Go的Signal&#47;Broadcast有差异吗？","like_count":3,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451796,"discussion_content":"你说的是对的。我其实没想到什么情况下用signal，大部分情况下都是用 broadcast，包括本文中的例子。因为用 signal 意味着每次资源的使用都要通知，其实退化为信号量的 PV 操作了，这一定性能是变差的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559083676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98433,"user_name":"Bachue Zhou","can_delete":false,"product_type":"c1","uid":1494491,"ip_address":"","ucode":"3175754775CA32","user_header":"https://static001.geekbang.org/account/avatar/00/16/cd/db/7467ad23.jpg","comment_is_top":false,"comment_ctime":1559004147,"is_pvip":false,"replies":[{"id":"35199","content":"管道合理的使用场景是什么？","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1559005707,"ip_address":"","comment_id":98433,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10148938739","product_id":100025201,"comment_content":"看不懂为什么要把管道的使用场景放在 Goroutine 之间通讯，这并不是管道合理的使用场景啊，至于和 Channel 做对比就更没有意义了。","like_count":2,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451685,"discussion_content":"管道合理的使用场景是什么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559005707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1592279,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","nickname":"William Ning","note":"","ucode":"4DB8D05E69E5F3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572574,"discussion_content":"个人想法，Channel这里的意思是通道，管道。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652861989,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98420,"user_name":"82","can_delete":false,"product_type":"c1","uid":1494935,"ip_address":"","ucode":"C58365A8A3843D","user_header":"https://static001.geekbang.org/account/avatar/00/16/cf/97/fcd8957d.jpg","comment_is_top":false,"comment_ctime":1559002811,"is_pvip":true,"replies":[{"id":"35197","content":"获取锁失败只有一种可能就是mutex对象非法（比如为nil），那就抛出异常，本身也是属于异常安全的代码。","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1559003102,"ip_address":"","comment_id":98420,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10148937403","product_id":100025201,"comment_content":"获取锁本身是什么样的操作，怎么保证在这个点上不出现异常呢？<br>","like_count":2,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451679,"discussion_content":"获取锁失败只有一种可能就是mutex对象非法（比如为nil），那就抛出异常，本身也是属于异常安全的代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559003102,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97376,"user_name":"觉","can_delete":false,"product_type":"c1","uid":1503600,"ip_address":"","ucode":"95E85D30E92170","user_header":"https://static001.geekbang.org/account/avatar/00/16/f1/70/bca09d2d.jpg","comment_is_top":false,"comment_ctime":1558662022,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10148596614","product_id":100025201,"comment_content":"感恩大佬分享 随喜大佬","like_count":2},{"had_liked":false,"id":97365,"user_name":"kylexy_0817","can_delete":false,"product_type":"c1","uid":1068372,"ip_address":"","ucode":"392DD9DD5E4B6E","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/54/9c214885.jpg","comment_is_top":false,"comment_ctime":1558660387,"is_pvip":false,"replies":[{"id":"34798","content":"channel 有锁这是从实现角度来讲，内部用到了锁。channel 是锁，这是从使用界面来讲，这显然是错误的。channel 会阻塞，是因为它实现了生产者消费者模型，如果两边的速度不匹配，自然会出现等待，这本身是一个feature，不是问题。channel 的开销更大，但是说不上谁好或者不好，因为锁和channel适用的场景几乎没有重叠。","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1558661677,"ip_address":"","comment_id":97365,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10148594979","product_id":100025201,"comment_content":"今天刚好阅读到老师写的go语言编程并发的章节，里面说到通过channel进行goroutine间的消息传递，是会阻塞的，所以可以理解成也是锁吗？性能方面并不会比锁好？","like_count":2,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451250,"discussion_content":"channel 有锁这是从实现角度来讲，内部用到了锁。channel 是锁，这是从使用界面来讲，这显然是错误的。channel 会阻塞，是因为它实现了生产者消费者模型，如果两边的速度不匹配，自然会出现等待，这本身是一个feature，不是问题。channel 的开销更大，但是说不上谁好或者不好，因为锁和channel适用的场景几乎没有重叠。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558661677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":293923,"user_name":"NiceBlueChai","can_delete":false,"product_type":"c1","uid":2038718,"ip_address":"","ucode":"2043333890C448","user_header":"https://static001.geekbang.org/account/avatar/00/1f/1b/be/525e05ae.jpg","comment_is_top":false,"comment_ctime":1621609915,"is_pvip":true,"replies":[{"id":"106586","content":"c++一直在求大而全","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1621640729,"ip_address":"","comment_id":293923,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5916577211","product_id":100025201,"comment_content":"这里就有我就有疑问了,既然条件变量更优, 那既然c++11中引入了信号量, 为啥又在最新版的C++20标准中引入了信号量(Semaphore)","like_count":1,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520431,"discussion_content":"c++一直在求大而全","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621640729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1592279,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","nickname":"William Ning","note":"","ucode":"4DB8D05E69E5F3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572575,"discussion_content":"“既然c++11中引入了信号量, 为啥又在最新版的C++20标准中引入了信号量(Semaphore)” ？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652862233,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205457,"user_name":"喆里","can_delete":false,"product_type":"c1","uid":1125033,"ip_address":"","ucode":"0B4B38104645CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/2a/a9/83684d4a.jpg","comment_is_top":false,"comment_ctime":1586620464,"is_pvip":true,"replies":[{"id":"76761","content":"只有在 == 0 的时候，才有可能有 goroutine 因为没有数据而等待。不管三七二十一就 broadcast 固然不会有问题，但是要知道这是一个费时操作，调用次数当然越少越好。我为什么说 Cond 是信号量（sema）的改进版本也是这个原因，因为信号量是每次都需要操作的，尤其当 sema 是一个内核对象时，可以想象性能不可能太好。","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1586665439,"ip_address":"","comment_id":205457,"utype":1}],"discussion_count":2,"race_medal":1,"score":"5881587760","product_id":100025201,"comment_content":"请教个问题，对channel实现代码的push 和pop 的  c.cond.Broadcast()时机不大理解。<br>不应该是c.queue.Push(v) 完直接 c.cond.Broadcast()，告诉有数据了，可以来取了，为什么要加上c.queue.Len() == 0的判断？<br>同样不应该是pop完，直接Broadcast，告诉数据消费完了，有空间了，可以存了，为什么要加c.queue.Len() == c.n？<br>还希望许老师多多指教<br>","like_count":1,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491486,"discussion_content":"只有在 == 0 的时候，才有可能有 goroutine 因为没有数据而等待。不管三七二十一就 broadcast 固然不会有问题，但是要知道这是一个费时操作，调用次数当然越少越好。我为什么说 Cond 是信号量（sema）的改进版本也是这个原因，因为信号量是每次都需要操作的，尤其当 sema 是一个内核对象时，可以想象性能不可能太好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586665439,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1592279,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","nickname":"William Ning","note":"","ucode":"4DB8D05E69E5F3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572576,"discussion_content":"sema = Semaphore","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652862297,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172693,"user_name":"Yayu","can_delete":false,"product_type":"c1","uid":1058015,"ip_address":"","ucode":"5E7842458D8229","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/df/645f8087.jpg","comment_is_top":false,"comment_ctime":1579252274,"is_pvip":false,"replies":[{"id":"66988","content":"是这样，理解完全正确。用Go的条件变量性能上会更好。","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1579256881,"ip_address":"","comment_id":172693,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5874219570","product_id":100025201,"comment_content":"Go 中条件变量的封装是用来控制 goroutine 的，是不是意味着 sync.cond 并不是对各个操作系统中条件变量 api 的封装，而是自己实现了一套用来控制多个 goroutine 之间的同步控制的同步原语？因为前面讲过区别于系统线程 goroutine 是用户级并发执行体抽象。","like_count":1,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481821,"discussion_content":"是这样，理解完全正确。用Go的条件变量性能上会更好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579256881,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129420,"user_name":"aiueo","can_delete":false,"product_type":"c1","uid":1230099,"ip_address":"","ucode":"96100CD14AB501","user_header":"https://static001.geekbang.org/account/avatar/00/12/c5/13/99baef26.jpg","comment_is_top":false,"comment_ctime":1567127739,"is_pvip":false,"replies":[{"id":"48201","content":"是的","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1567131697,"ip_address":"","comment_id":129420,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5862095035","product_id":100025201,"comment_content":"文章中:<br><br>把自己加入到挂起队列<br>mutex.Unlock()<br>等待被唤醒  &#47;&#47; 挂起的执行体会被后续的 cond.Broadcast 或 cond.Signal() 唤醒<br>mutex.Lock()<br><br>这段说明不是很理解 先解锁，然后等待唤醒后再加锁吗？","like_count":1,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465458,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567131697,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98459,"user_name":"Bachue Zhou","can_delete":false,"product_type":"c1","uid":1494491,"ip_address":"","ucode":"3175754775CA32","user_header":"https://static001.geekbang.org/account/avatar/00/16/cd/db/7467ad23.jpg","comment_is_top":false,"comment_ctime":1559006314,"is_pvip":false,"replies":[{"id":"35236","content":"Go语言里面有两个管道实现，一个io.Pipe，是用于goroutine之间的；一个是os.Pipe，是用于进程之间的。","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1559011809,"ip_address":"","comment_id":98459,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5853973610","product_id":100025201,"comment_content":"管道合理的使用场景是什么？难道不是父子间进程通讯或是子进程之间的通讯吗？进程间通讯可不是 Goroutine 能轻易取代的。","like_count":1,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451697,"discussion_content":"Go语言里面有两个管道实现，一个io.Pipe，是用于goroutine之间的；一个是os.Pipe，是用于进程之间的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559011809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98432,"user_name":"82","can_delete":false,"product_type":"c1","uid":1494935,"ip_address":"","ucode":"C58365A8A3843D","user_header":"https://static001.geekbang.org/account/avatar/00/16/cf/97/fcd8957d.jpg","comment_is_top":false,"comment_ctime":1559004145,"is_pvip":true,"replies":[{"id":"35208","content":"当然是锁。如果这都保证不了，那它就不是锁了","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1559006380,"ip_address":"","comment_id":98432,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5853971441","product_id":100025201,"comment_content":"在高并发下获取锁操作，谁来保证单次操作的原子性，操作系统还是cpu或者其他呢？","like_count":1,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451684,"discussion_content":"当然是锁。如果这都保证不了，那它就不是锁了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559006380,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98127,"user_name":"keshawn","can_delete":false,"product_type":"c1","uid":1319270,"ip_address":"","ucode":"CFCC24F58D1651","user_header":"https://static001.geekbang.org/account/avatar/00/14/21/66/f9125286.jpg","comment_is_top":false,"comment_ctime":1558918410,"is_pvip":false,"replies":[{"id":"35152","content":"本质上是的，不过它有一些高级用法是常规队列没有的，比如用select去多个channel同时进行读写。","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1558936490,"ip_address":"","comment_id":98127,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5853885706","product_id":100025201,"comment_content":"Channel只是一个并发阻塞队列？","like_count":1,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451569,"discussion_content":"本质上是的，不过它有一些高级用法是常规队列没有的，比如用select去多个channel同时进行读写。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558936490,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98039,"user_name":"Dean","can_delete":false,"product_type":"c1","uid":1178744,"ip_address":"","ucode":"23B6BE5CAEE11C","user_header":"https://static001.geekbang.org/account/avatar/00/11/fc/78/ef1cb09c.jpg","comment_is_top":false,"comment_ctime":1558880985,"is_pvip":false,"replies":[{"id":"35072","content":"如果只是简单实现，我文章中给出的是一种参考。不过Go语言的channel功能其实不止于此，要完整实现是比较难的，尤其是Go channel还支持多channel一起读或取。","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1558915427,"ip_address":"","comment_id":98039,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5853848281","product_id":100025201,"comment_content":"请问java如何实现管道，是类似SynchronousQueue的方式吗","like_count":1,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451529,"discussion_content":"如果只是简单实现，我文章中给出的是一种参考。不过Go语言的channel功能其实不止于此，要完整实现是比较难的，尤其是Go channel还支持多channel一起读或取。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558915427,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97830,"user_name":"stern","can_delete":false,"product_type":"c1","uid":1501057,"ip_address":"","ucode":"3120A647C6B6AD","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKx6EdicYYuYKibnUiajL1ba1cmzXpK6RmvAoIX4mTgdzVELf6Ljzk2chQIBhk37xRuOAnAwtOjkaRMA/132","comment_is_top":false,"comment_ctime":1558789178,"is_pvip":false,"replies":[{"id":"34981","content":"这个是你自己的程序逻辑，线程并没有什么机会去帮你判断","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1558796479,"ip_address":"","comment_id":97830,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5853756474","product_id":100025201,"comment_content":"非常钦佩老师学问深度😀😀，读写锁是不是可以理解为一个请求过来，当前线程判断该操作是读操作还是写操作，如果是读操作则允许执行，如果是写操作则等待锁释放后执行，如果是这样的话，那读操作还需要加文中写到的mutex.RLock吗？","like_count":1,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451442,"discussion_content":"这个是你自己的程序逻辑，线程并没有什么机会去帮你判断","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558796479,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97761,"user_name":"科春","can_delete":false,"product_type":"c1","uid":1500869,"ip_address":"","ucode":"5766A7E9B9F497","user_header":"https://static001.geekbang.org/account/avatar/00/16/e6/c5/d7aa290b.jpg","comment_is_top":false,"comment_ctime":1558767812,"is_pvip":false,"replies":[{"id":"34929","content":"建议去学习一下","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1558769168,"ip_address":"","comment_id":97761,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5853735108","product_id":100025201,"comment_content":"哎呀，进入到有程序代码章节就看不懂了，没有编程的经验。","like_count":1,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451403,"discussion_content":"建议去学习一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558769168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97405,"user_name":"冯同学","can_delete":false,"product_type":"c1","uid":1385963,"ip_address":"","ucode":"5C20A9545650C1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTII0u388mhWLGy3XE8lzAqAUj79OpUpHRPpvc3e7icmmCZFJt2DqSTZUlFBy7QWCHfd6dyicHicCruEg/132","comment_is_top":false,"comment_ctime":1558665318,"is_pvip":false,"replies":[{"id":"34839","content":"忽略语法，理解一下语义就行","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1558670200,"ip_address":"","comment_id":97405,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5853632614","product_id":100025201,"comment_content":"能同时类比下JAVA么，感觉go没学过有点吃力","like_count":1,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451270,"discussion_content":"忽略语法，理解一下语义就行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558670200,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97397,"user_name":"浅醉","can_delete":false,"product_type":"c1","uid":1522672,"ip_address":"","ucode":"5E6EE05F0E732F","user_header":"https://static001.geekbang.org/account/avatar/00/17/3b/f0/4bd5234f.jpg","comment_is_top":false,"comment_ctime":1558664528,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5853631824","product_id":100025201,"comment_content":"没有接触过go😂","like_count":1},{"had_liked":false,"id":97387,"user_name":"龙宝宝","can_delete":false,"product_type":"c1","uid":1511926,"ip_address":"","ucode":"355AF9ADC92CE8","user_header":"https://static001.geekbang.org/account/avatar/00/17/11/f6/36bd007d.jpg","comment_is_top":false,"comment_ctime":1558663353,"is_pvip":false,"replies":[{"id":"34842","content":"这个描述可能不是很到位，可以看下后面详细的介绍","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1558670554,"ip_address":"","comment_id":97387,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5853630649","product_id":100025201,"comment_content":"文章中第一张图片中的 条件变量对应的语义说明 “如果资源不足下等待”？","like_count":1,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451262,"discussion_content":"这个描述可能不是很到位，可以看下后面详细的介绍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558670554,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97374,"user_name":"杜超","can_delete":false,"product_type":"c1","uid":1183380,"ip_address":"","ucode":"8123F1E13D6A68","user_header":"https://static001.geekbang.org/account/avatar/00/12/0e/94/67fffed1.jpg","comment_is_top":false,"comment_ctime":1558661894,"is_pvip":true,"replies":[{"id":"34840","content":"忽略语法，理解一下语义就行","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1558670213,"ip_address":"","comment_id":97374,"utype":1}],"discussion_count":1,"race_medal":1,"score":"5853629190","product_id":100025201,"comment_content":"这……  是不是得先学下go","like_count":1,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451254,"discussion_content":"忽略语法，理解一下语义就行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558670213,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97319,"user_name":"一笔一画","can_delete":false,"product_type":"c1","uid":1495254,"ip_address":"","ucode":"2B9BC8ADF97106","user_header":"https://static001.geekbang.org/account/avatar/00/16/d0/d6/f335954b.jpg","comment_is_top":false,"comment_ctime":1558656322,"is_pvip":false,"replies":[{"id":"34799","content":"Go有挺好的竞争检测，一般这种情况下会异常而崩溃，注意看错误信息里面打印的堆栈信息。","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1558661806,"ip_address":"","comment_id":97319,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5853623618","product_id":100025201,"comment_content":"老师，请教一下，go语言里面涉及锁挂死，有什么好的调试方法吗","like_count":1,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451224,"discussion_content":"Go有挺好的竞争检测，一般这种情况下会异常而崩溃，注意看错误信息里面打印的堆栈信息。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558661806,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":301522,"user_name":"coder甲","can_delete":false,"product_type":"c1","uid":1503417,"ip_address":"","ucode":"B57E6026AF4A70","user_header":"https://static001.geekbang.org/account/avatar/00/16/f0/b9/67167dc2.jpg","comment_is_top":false,"comment_ctime":1625727483,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625727483","product_id":100025201,"comment_content":"希望老师推荐几本关于计算机原理、数据结构、操作系统、编译原理等类型的，能够了解大厦基层的书籍，或者老师自己出一系列此类的课程吧。","like_count":0},{"had_liked":false,"id":294261,"user_name":"恬毅","can_delete":false,"product_type":"c1","uid":1015240,"ip_address":"","ucode":"914ED16F3BE714","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/c8/e4727683.jpg","comment_is_top":false,"comment_ctime":1621853479,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621853479","product_id":100025201,"comment_content":"看第二遍的时候，通透了一些，其实是围绕着第一表格展开讲的。<br>1、go的条件类似于java的同步。只不过java是线程间的同步，go的条件变量是协程之间的，性能上go优于java<br>2、java的同步是直接用sychronize{}，然后大括号里面的代码都是同步的，不会存在漏写的问题，而go的lock和unlock分开了。容易漏掉，这个java可以说在语法安全保证方面略胜一筹。","like_count":0},{"had_liked":false,"id":285851,"user_name":"不温暖啊不纯良","can_delete":false,"product_type":"c1","uid":2079117,"ip_address":"","ucode":"204474A214E00C","user_header":"https://static001.geekbang.org/account/avatar/00/1f/b9/8d/00bded19.jpg","comment_is_top":false,"comment_ctime":1617032301,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617032301","product_id":100025201,"comment_content":"这一讲我理解的几个线程之间的协作方式。<br><br>线程锁。他设计是为了避免多个线程同时去改变同一个数据，他还有一个读写锁的概念，读的操作不会原本的数据，所以当下一个线程依然是毒读操作，就不需要加锁，使用时还需要注意，在锁的内部不应当执行比较费时的操作。<br><br>等待组依然需要依赖，互斥体(线程锁)来完成，等待条件，是指前面的线程还没有执行完毕，这个时候此县城是等待状态。唤醒条件，是指前面的县城已经执行完毕，子线程被唤醒，然后去释放前一个线程的线程锁，然后再给自己加锁，开始执行，唤醒中有全部唤醒和单个唤醒，全部唤醒的话，如果可执行资源不够，那就得这些被唤醒的线程去抢锁，谁抢到锁谁就可以执行，其他的则继续等待。<br><br>管道是线程之间的通讯手段，两个现成的通讯动作，一个负责往管道里面写数据，一个负责从管道里传读数据，这样便完成了县城之间的通讯。<br><br>以上就是对本篇文章的思考，如果有理解不对的地方，还请老师指出。","like_count":0},{"had_liked":false,"id":284664,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1096397,"ip_address":"","ucode":"14C0858C413E00","user_header":"https://static001.geekbang.org/account/avatar/00/10/ba/cd/1f91aa44.jpg","comment_is_top":false,"comment_ctime":1616409631,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616409631","product_id":100025201,"comment_content":"老师说的是用户态修改寄存器，是不是可以理解为用户态已经拿到了寄存器的地址。可以根据寄存器名称直接修改。","like_count":0},{"had_liked":false,"id":284311,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1616159105,"is_pvip":true,"replies":[{"id":"103123","content":"信号量用得不多了 一般会用条件变量","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1616163220,"ip_address":"","comment_id":284311,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1616159105","product_id":100025201,"comment_content":"进程内同行方式可以用：<br>锁（Mutex）；<br>读写锁（RWMutex）；<br>信号量（Semaphore）；<br>等待组（WaitGroup）；<br>条件变量（Cond）。","like_count":0,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517306,"discussion_content":"信号量用得不多了 一般会用条件变量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616163220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284305,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1616157088,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1616157088","product_id":100025201,"comment_content":"用锁重要提醒： 不要在锁里面执行费时操作。","like_count":0},{"had_liked":false,"id":266783,"user_name":"Jerry Chou","can_delete":false,"product_type":"c1","uid":2336895,"ip_address":"","ucode":"87206EA1B9E0CA","user_header":"https://static001.geekbang.org/account/avatar/00/23/a8/7f/c2ce3fc2.jpg","comment_is_top":false,"comment_ctime":1607486270,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607486270","product_id":100025201,"comment_content":"看完文章，包括留言，发现那个Push的实现问题是不是老许特地留在那里的。<br>这个地方，我自己也咯噔了一下，随后在仔细看代码就能明白这里先push还是先通知顺序并不重要了了。<br><br>这也从侧面说明了一个问题，异步是反直觉的，你能在一定程度上理解，加上实现的复杂度的时候还是很容易出错，这也是为什么作为go要花这么大精力将异步调用尽量在使用方看起来是同步的。","like_count":0},{"had_liked":false,"id":194084,"user_name":"活水","can_delete":false,"product_type":"c1","uid":1154935,"ip_address":"","ucode":"8A93734B62AF04","user_header":"https://static001.geekbang.org/account/avatar/00/11/9f/77/3a8fb89f.jpg","comment_is_top":false,"comment_ctime":1585023148,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585023148","product_id":100025201,"comment_content":"这节和go密切绑定了，需要类比其他语言的实现，是否有类似的用法，才能学习到原理","like_count":0},{"had_liked":false,"id":184605,"user_name":"zhj","can_delete":false,"product_type":"c1","uid":1311772,"ip_address":"","ucode":"65B9E222D6E075","user_header":"https://static001.geekbang.org/account/avatar/00/14/04/1c/b0c6c009.jpg","comment_is_top":false,"comment_ctime":1583370224,"is_pvip":false,"replies":[{"id":"71407","content":"1、对的，协程通常是跑在线程池上的；2、对的","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1583384799,"ip_address":"","comment_id":184605,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1583370224","product_id":100025201,"comment_content":"1 因为操作系统最小调度的执行体是线程，所以即便是模拟出了用户态协程执行体，在操作系统看本质上也是跑在线程上的吧？2  还有协程的io同步也会阻塞，只是阻塞切换的成本由于是用户态可以忽略不计，底层是委托异步网络io线程模型来做的，只是库屏蔽了异步的复杂性，向上层封装了易用的同步接口，这样理解对吗","like_count":0,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486063,"discussion_content":"1、对的，协程通常是跑在线程池上的；2、对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583384799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173057,"user_name":"Yayu","can_delete":false,"product_type":"c1","uid":1058015,"ip_address":"","ucode":"5E7842458D8229","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/df/645f8087.jpg","comment_is_top":false,"comment_ctime":1579418442,"is_pvip":false,"replies":[{"id":"67121","content":"是这样","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1579439343,"ip_address":"","comment_id":173057,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1579418442","product_id":100025201,"comment_content":"请教老师，文中“其实 Go 语言中引入的 channel 也是管道，只不过它是类型安全的管道。” 可否这样理解，channel 是 Go 语言为了避免开发人员编写过程出现类型错误而定义的一个内置数据类型。而抛开类型安全的问题，我们完全可以使用 io.pipe 来实现 goroutine 之间的数据传输，当然，io.pipe 只能实现 unbuffered channel 类似的语意。","like_count":0,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481944,"discussion_content":"是这样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579439343,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173042,"user_name":"Yayu","can_delete":false,"product_type":"c1","uid":1058015,"ip_address":"","ucode":"5E7842458D8229","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/df/645f8087.jpg","comment_is_top":false,"comment_ctime":1579416629,"is_pvip":false,"replies":[{"id":"67122","content":"类型安全是指channel规定了数据传递的类型，比如 chan int 只能传递整型值。","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1579439408,"ip_address":"","comment_id":173042,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1579416629","product_id":100025201,"comment_content":"请问老师文中提及的 “其实 Go 语言中引入的 channel 也是管道，只不过它是类型安全的管道。” 其中“类型安全”到底是什么意思？","like_count":0,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481938,"discussion_content":"类型安全是指channel规定了数据传递的类型，比如 chan int 只能传递整型值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579439408,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159411,"user_name":"sswrock","can_delete":false,"product_type":"c1","uid":1683896,"ip_address":"","ucode":"9D8DA794D7378D","user_header":"https://static001.geekbang.org/account/avatar/00/19/b1/b8/9ff50118.jpg","comment_is_top":false,"comment_ctime":1575617197,"is_pvip":false,"replies":[{"id":"60930","content":"类似，只是特性会有较大不同","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1575623357,"ip_address":"","comment_id":159411,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1575617197","product_id":100025201,"comment_content":"go的channel，个人感觉可以理解成java的BlockingQueue （貌似里面的实现原理是一样的）<br>","like_count":0,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477046,"discussion_content":"类似，只是特性会有较大不同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575623357,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155805,"user_name":"虢國技醬","can_delete":false,"product_type":"c1","uid":1056807,"ip_address":"","ucode":"5A192262AA037E","user_header":"https://static001.geekbang.org/account/avatar/00/10/20/27/a6932fbe.jpg","comment_is_top":false,"comment_ctime":1574759315,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574759315","product_id":100025201,"comment_content":"这篇估计gopher童鞋看起来比较嗨😄","like_count":0},{"had_liked":false,"id":131236,"user_name":"feihui","can_delete":false,"product_type":"c1","uid":1007294,"ip_address":"","ucode":"13F1D4A82BC650","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/be/9ea55f46.jpg","comment_is_top":false,"comment_ctime":1567676313,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1567676313","product_id":100025201,"comment_content":"评价一种实现与另一种实现的性能差距，直接看下源码最为直观，就文中说的 lock 和 channel 的误区，按照我自己的理解 channel 既然要实现同步，也肯定少不了 cas 或者 lock 的，当然这个是我对 java 库实现的理解，不知道 go 的实现有没有差异。","like_count":0},{"had_liked":false,"id":120739,"user_name":"半桶水","can_delete":false,"product_type":"c1","uid":1000475,"ip_address":"","ucode":"AFC053EB627E48","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/1b/fa287ed5.jpg","comment_is_top":false,"comment_ctime":1564987473,"is_pvip":false,"replies":[{"id":"44355","content":"C可以","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1565005944,"ip_address":"","comment_id":120739,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1564987473","product_id":100025201,"comment_content":"读写锁一个疑问，假设A获取了读锁，这时候B尝试获取写锁，A还没释放锁C又尝试去获取读锁，这个时候C能否成功获取到读锁？","like_count":0,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461455,"discussion_content":"C可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565005944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1411864,"avatar":"https://static001.geekbang.org/account/avatar/00/15/8b/18/e0d71ce7.jpg","nickname":"pretender","note":"","ucode":"E10CE42D27A612","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":111031,"discussion_content":"看了一下，go的RWMutex是公平锁，C得等B用完    \n    22  // If a goroutine holds a RWMutex for reading and another goroutine might\n    23  // call Lock, no goroutine should expect to be able to acquire a read lock\n    24  // until the initial read lock is released. In particular, this prohibits\n    25  // recursive read locking. This is to ensure that the lock eventually becomes\n    26  // available; a blocked Lock call excludes new readers from acquiring the\n    27  // lock.\n    28  type RWMutex struct {","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577773614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1411864,"avatar":"https://static001.geekbang.org/account/avatar/00/15/8b/18/e0d71ce7.jpg","nickname":"pretender","note":"","ucode":"E10CE42D27A612","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":110907,"discussion_content":"对go不太熟悉，如果是Java的话，初始化时可以指定为公平锁或非公平锁，非公平锁的情况下C可以直接获取到读锁，缺点是在一个读操作很频繁的环境下，B有可能会“饿死”，因为一直有读操作无法获取到写锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577764248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119627,"user_name":"五年","can_delete":false,"product_type":"c1","uid":1081224,"ip_address":"","ucode":"28A6F945FB0626","user_header":"https://static001.geekbang.org/account/avatar/00/10/7f/88/c4263c58.jpg","comment_is_top":false,"comment_ctime":1564640691,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564640691","product_id":100025201,"comment_content":"跟着对go的理解也深入了好多 👍","like_count":0},{"had_liked":false,"id":119066,"user_name":"饭","can_delete":false,"product_type":"c1","uid":1610573,"ip_address":"","ucode":"B3F1702D4DE604","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJKj3GbvevFibxwJibTqm16NaE8MXibwDUlnt5tt73KF9WS2uypha2m1Myxic6Q47Zaj2DZOwia3AgicO7Q/132","comment_is_top":false,"comment_ctime":1564496014,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564496014","product_id":100025201,"comment_content":"老师，我不懂GO，如果按JAVA来理解的话，协程的思想主要体现在哪些地方了","like_count":0},{"had_liked":false,"id":104993,"user_name":"nightmare","can_delete":false,"product_type":"c1","uid":1056314,"ip_address":"","ucode":"EF2E51C2122A86","user_header":"https://static001.geekbang.org/account/avatar/00/10/1e/3a/5b21c01c.jpg","comment_is_top":false,"comment_ctime":1560903980,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560903980","product_id":100025201,"comment_content":"感觉go的chanel就相当于java的一个有界队列，只不过是基于协程调度，不会发生内核切换","like_count":0},{"had_liked":false,"id":102389,"user_name":"Julian","can_delete":false,"product_type":"c1","uid":1020566,"ip_address":"","ucode":"6DD1BB78E0E265","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/96/586fe25a.jpg","comment_is_top":false,"comment_ctime":1560215364,"is_pvip":false,"replies":[{"id":"36934","content":"原子操作和锁语义完全不同。只不过可以用锁来实现原子操作。","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1560220246,"ip_address":"","comment_id":102389,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560215364","product_id":100025201,"comment_content":"请问您讲的原子操作和互斥体（锁）的语义是一样的，那他们到底有什么不一样呢？能详细讲讲吗？","like_count":0,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453393,"discussion_content":"原子操作和锁语义完全不同。只不过可以用锁来实现原子操作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560220246,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101969,"user_name":"川","can_delete":false,"product_type":"c1","uid":1030859,"ip_address":"","ucode":"0C1C11A3B31AE8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/cb/f1355b40.jpg","comment_is_top":false,"comment_ctime":1560077178,"is_pvip":true,"replies":[{"id":"36763","content":"只是借用了go的语法","user_name":"作者回复","user_name_real":"许式伟-七牛云(已满)","uid":"1228022","ctime":1560088937,"ip_address":"","comment_id":101969,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1560077178","product_id":100025201,"comment_content":"虽然我也是go粉，但这章实在是过于像golang科普而非普适性的对问题的抽象和建模了。不知道没学过go的读者看起来会是什么体验。","like_count":0,"discussions":[{"author":{"id":1228022,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/f6/e61d4b8f.jpg","nickname":"许式伟-七牛云(已满)","note":"","ucode":"1A2F8AA6F6DB54","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453194,"discussion_content":"只是借用了go的语法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560088937,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1114772,"avatar":"https://static001.geekbang.org/account/avatar/00/11/02/94/2bf394f3.jpg","nickname":"Numbpad1","note":"","ucode":"2F075AC7E3847D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535442,"discussion_content":"体验极差，对于不了解go的同学来说学习成本较高","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638444215,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1676962,"avatar":"https://static001.geekbang.org/account/avatar/00/19/96/a2/c1596dd8.jpg","nickname":"🤔","note":"","ucode":"40ACB53BF3C6B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1114772,"avatar":"https://static001.geekbang.org/account/avatar/00/11/02/94/2bf394f3.jpg","nickname":"Numbpad1","note":"","ucode":"2F075AC7E3847D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":566477,"discussion_content":"这篇估计gopher童鞋看起来比较嗨😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650699367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":535442,"ip_address":""},"score":566477,"extra":""}]}]},{"had_liked":false,"id":101383,"user_name":"苟范儿","can_delete":false,"product_type":"c1","uid":1364883,"ip_address":"","ucode":"B06B86765512FA","user_header":"https://static001.geekbang.org/account/avatar/00/14/d3/93/bef5a186.jpg","comment_is_top":false,"comment_ctime":1559794192,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559794192","product_id":100025201,"comment_content":"感谢老师对同步、互斥、通讯的讲解～","like_count":0},{"had_liked":false,"id":101330,"user_name":"闫飞","can_delete":false,"product_type":"c1","uid":1013162,"ip_address":"","ucode":"30C782D30108D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/aa/21275b9d.jpg","comment_is_top":false,"comment_ctime":1559783064,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559783064","product_id":100025201,"comment_content":"Rust语言采用强制的ownership检查，对象生命周期一致性检查和主动的冲突检测试图从另外一个层面解决这个问题，有没有用户态的GC设施的开销，应该是另外一个不错的方向。Talko库非常强大了，可惜Rust2018关于同步方面的设施还没有完全成熟。","like_count":0},{"had_liked":false,"id":99562,"user_name":"而立斋","can_delete":false,"product_type":"c1","uid":1087258,"ip_address":"","ucode":"5FED6E9E148195","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/1a/389eab84.jpg","comment_is_top":false,"comment_ctime":1559261209,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559261209","product_id":100025201,"comment_content":"老师想呈现出来的是老虎🐯，而我还天真的以为这是一只老鼠🐭，连猫🐱都没有想到","like_count":0},{"had_liked":false,"id":98105,"user_name":"Barry","can_delete":false,"product_type":"c1","uid":1003308,"ip_address":"","ucode":"79117738B2B26E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4f/2c/a17b23f7.jpg","comment_is_top":false,"comment_ctime":1558916293,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558916293","product_id":100025201,"comment_content":"虽然对go的语法只是一个基本的了解，但是看到代码的语义，感觉瞬间顿悟了好多。也体会到了这些代码设计的巧妙之处，特别是是条件变量。我觉得这些设计可以在不少的业务场景中运用起来，无关语言。赞","like_count":0},{"had_liked":false,"id":98037,"user_name":"Dean","can_delete":false,"product_type":"c1","uid":1178744,"ip_address":"","ucode":"23B6BE5CAEE11C","user_header":"https://static001.geekbang.org/account/avatar/00/11/fc/78/ef1cb09c.jpg","comment_is_top":false,"comment_ctime":1558880544,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558880544","product_id":100025201,"comment_content":"channel的例子很像juc的很多实现","like_count":0},{"had_liked":false,"id":97672,"user_name":"小辉辉","can_delete":false,"product_type":"c1","uid":1189661,"ip_address":"","ucode":"9FF25E25C85350","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/1d/1cb36854.jpg","comment_is_top":false,"comment_ctime":1558747201,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558747201","product_id":100025201,"comment_content":"之前把两个学习go的专栏看完了，再来理解老师说的这个，又让我加深了对go的理解😀😀😀   看评论说想看java例子的，我推荐王宝令老师的《java并发编程实战》专栏，里面讲的也不错。当然像许老师说的，可以忽略语法，不过对比着看可以更清楚原理。","like_count":0},{"had_liked":false,"id":97603,"user_name":"ljf10000","can_delete":false,"product_type":"c1","uid":1494064,"ip_address":"","ucode":"44957329A61EAE","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eop9WylZJicLQ5wib49kcMPqCTRT1aThh6mMAVl6qseLwbVOLhicVLjZCxCoyQd5CrrHHibs2CVPaoK3g/132","comment_is_top":false,"comment_ctime":1558709536,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558709536","product_id":100025201,"comment_content":"锁只能保障资源的互斥，但无法保障时序。","like_count":0},{"had_liked":false,"id":97317,"user_name":"Aaron Cheung","can_delete":false,"product_type":"c1","uid":1079816,"ip_address":"","ucode":"03972759C53667","user_header":"https://static001.geekbang.org/account/avatar/00/10/7a/08/4d3e47dd.jpg","comment_is_top":false,"comment_ctime":1558655265,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558655265","product_id":100025201,"comment_content":"打卡12 深入进程","like_count":0},{"had_liked":false,"id":97307,"user_name":"lckfa李钊","can_delete":false,"product_type":"c1","uid":1356899,"ip_address":"","ucode":"AD13D205104AA6","user_header":"https://static001.geekbang.org/account/avatar/00/14/b4/63/84960032.jpg","comment_is_top":false,"comment_ctime":1558651942,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558651942","product_id":100025201,"comment_content":"个人理解 进程内的协同 ，其实就是线程或协程的协同（对协程没多少概念，不确定 协程如何与线程协同），协同包括了大家先各自为政，偶尔的交流往来，也可能需要保持数据同步。既然需要各自为政，就得保证互不干扰，于是就需要把某些公用的资源在使用时做记号，原子，互斥操作可以达成这个目地，公用资源的使用往往有谁抢到谁用，后到的就给我等着的意味；交流往来时可以使用管道，在二者之间建立连接，有单向的管道，也有双向的管道，看通信的需求而定；最后，交流方也可能需要保持同步，规定谁先谁后，此时，信号量，条件变量就可以登场了，一般的说，同步其实包含了互斥，比如可以对某公共资源的使用，通过同步保证一定是A先B后的使用。","like_count":0}]}