{"id":67477,"title":"41 | io包中的接口和工具 （下）","content":"<p>上一篇文章中，我主要讲到了<code>io.Reader</code>的扩展接口和实现类型。当然，<code>io</code>代码包中的核心接口不止<code>io.Reader</code>一个。</p><p>我们基于它引出的一条主线，只是<code>io</code>包类型体系中的一部分。我们很有必要再从另一个角度去探索一下，以求对<code>io</code>包有更加全面的了解。</p><p>下面的一个问题就与此有关。</p><h2>知识扩展</h2><h3>问题：<code>io</code>包中的接口都有哪些？它们之间都有着怎样的关系？</h3><p>我们可以把没有嵌入其他接口并且只定义了一个方法的接口叫做<strong>简单接口</strong>。在<code>io</code>包中，这样的接口一共有11个。</p><p>在它们之中，有的接口有着众多的扩展接口和实现类型，我们可以称之为<strong>核心接口</strong>。<strong><code>io</code>包中的核心接口只有3个，它们是：<code>io.Reader</code>、<code>io.Writer</code>和<code>io.Closer</code>。</strong></p><p>我们还可以把<code>io</code>包中的简单接口分为四大类。这四大类接口分别针对于四种操作，即：读取、写入、关闭和读写位置设定。前三种操作属于基本的I/O操作。</p><p><strong>关于读取操作，我们在前面已经重点讨论过核心接口<code>io.Reader</code>。它在<code>io</code>包中有5个扩展接口，并有6个实现类型。除了它，这个包中针对读取操作的接口还有不少。我们下面就来梳理一下。</strong></p><p>首先来看<code>io.ByteReader</code>和<code>io.RuneReader</code>这两个简单接口。它们分别定义了一个读取方法，即：<code>ReadByte</code>和<code>ReadRune</code>。</p><!-- [[[read_end]]] --><p>但与<code>io.Reader</code>接口中<code>Read</code>方法不同的是，这两个读取方法分别只能够读取下一个单一的字节和Unicode字符。</p><p>我们之前讲过的数据类型<code>strings.Reader</code>和<code>bytes.Buffer</code>都是<code>io.ByteReader</code>和<code>io.RuneReader</code>的实现类型。</p><p>不仅如此，这两个类型还都实现了<code>io.ByteScanner</code>接口和<code>io.RuneScanner</code>接口。</p><p><code>io.ByteScanner</code>接口内嵌了简单接口<code>io.ByteReader</code>，并定义了额外的<code>UnreadByte</code>方法。如此一来，它就抽象出了一个能够读取和读回退单个字节的功能集。</p><p>与之类似，<code>io.RuneScanner</code>内嵌了简单接口<code>io.RuneReader</code>，并定义了额外的<code>UnreadRune</code>方法。它抽象的是可以读取和读回退单个Unicode字符的功能集。</p><p>再来看<code>io.ReaderAt</code>接口。它也是一个简单接口，其中只定义了一个方法<code>ReadAt</code>。与我们在前面说过的读取方法都不同，<code>ReadAt</code>是一个纯粹的只读方法。</p><p>它只去读取其所属值中包含的字节，而不对这个值进行任何的改动，比如，它绝对不能去修改已读计数的值。这也是<code>io.ReaderAt</code>接口与其实现类型之间最重要的一个约定。</p><p>因此，如果仅仅并发地调用某一个值的<code>ReadAt</code>方法，那么安全性应该是可以得到保障的。</p><p>另外，还有一个读取操作相关的接口我们没有介绍过，它就是<code>io.WriterTo</code>。这个接口定义了一个名为<code>WriteTo</code>的方法。</p><p>千万不要被它的名字迷惑，这个<code>WriteTo</code>方法其实是一个读取方法。它会接受一个<code>io.Writer</code>类型的参数值，并会把其所属值中的数据读出并写入到这个参数值中。</p><p>与之相对应的是<code>io.ReaderFrom</code>接口。它定义了一个名叫<code>ReadFrom</code>的写入方法。该方法会接受一个<code>io.Reader</code>类型的参数值，并会从该参数值中读出数据,并写入到其所属值中。</p><p>值得一提的是，我们在前面用到过的<code>io.CopyN</code>函数，在复制数据的时候会先检测其参数<code>src</code>的值，是否实现了<code>io.WriterTo</code>接口。如果是，那么它就直接利用该值的<code>WriteTo</code>方法，把其中的数据拷贝给参数<code>dst</code>代表的值。</p><p>类似的，这个函数还会检测<code>dst</code>的值是否实现了<code>io.ReaderFrom</code>接口。如果是，那么它就会利用这个值的<code>ReadFrom</code>方法，直接从<code>src</code>那里把数据拷贝进该值。</p><p>实际上，对于<code>io.Copy</code>函数和<code>io.CopyBuffer</code>函数来说也是如此，因为它们在内部做数据复制的时候用的都是同一套代码。</p><p>你也看到了，<code>io.ReaderFrom</code>接口与<code>io.WriterTo</code>接口对应得很规整。<strong>实际上，在<code>io</code>包中，与写入操作有关的接口都与读取操作的相关接口有着一定的对应关系。下面，我们就来说说写入操作相关的接口。</strong></p><p>首先当然是核心接口<code>io.Writer</code>。基于它的扩展接口除了有我们已知的<code>io.ReadWriter</code>、<code>io.ReadWriteCloser</code>和<code>io.ReadWriteSeeker</code>之外，还有<code>io.WriteCloser</code>和<code>io.WriteSeeker</code>。</p><p>我们之前提及的<code>*io.pipe</code>就是<code>io.ReadWriter</code>接口的实现类型。然而，在<code>io</code>包中并没有<code>io.ReadWriteCloser</code>接口的实现，它的实现类型主要集中在<code>net</code>包中。</p><p>除此之外，写入操作相关的简单接口还有<code>io.ByteWriter</code>和<code>io.WriterAt</code>。可惜，<code>io</code>包中也没有它们的实现类型。不过，有一个数据类型值得在这里提一句，那就是<code>*os.File</code>。</p><p>这个类型不但是<code>io.WriterAt</code>接口的实现类型，还同时实现了<code>io.ReadWriteCloser</code>接口和<code>io.ReadWriteSeeker</code>接口。也就是说，该类型支持的I/O操作非常的丰富。</p><p><code>io.Seeker</code>接口作为一个读写位置设定相关的简单接口，也仅仅定义了一个方法，名叫<code>Seek</code>。</p><p>我在讲<code>strings.Reader</code>类型的时候还专门说过这个<code>Seek</code>方法，当时还给出了一个与已读计数估算有关的例子。该方法主要用于寻找并设定下一次读取或写入时的起始索引位置。</p><p><code>io</code>包中有几个基于<code>io.Seeker</code>的扩展接口，包括前面讲过的<code>io.ReadSeeker</code>和<code>io.ReadWriteSeeker</code>，以及还未曾提过的<code>io.WriteSeeker</code>。<code>io.WriteSeeker</code>是基于<code>io.Writer</code>和<code>io.Seeker</code>的扩展接口。</p><p>我们之前多次提到的两个指针类型<code>strings.Reader</code>和<code>io.SectionReader</code>都实现了<code>io.Seeker</code>接口。顺便说一句，这两个类型也都是<code>io.ReaderAt</code>接口的实现类型。</p><p>最后，关闭操作相关的接口<code>io.Closer</code>非常通用，它的扩展接口和实现类型都不少。我们单从名称上就能够一眼看出<code>io</code>包中的哪些接口是它的扩展接口。至于它的实现类型，<code>io</code>包中只有<code>io.PipeReader</code>和<code>io.PipeWriter</code>。</p><h2>总结</h2><p>我们来总结一下这两篇的内容。在Go语言中，对接口的扩展是通过接口类型之间的嵌入来实现的，这也常被叫做接口的组合。而<code>io</code>代码包恰恰就可以作为接口扩展的一个标杆，它可以成为我们运用这种技巧时的一个参考标准。</p><p>在本文中，我根据接口定义的方法的数量以及是否有接口嵌入，把<code>io</code>包中的接口分为了简单接口和扩展接口。</p><p>同时，我又根据这些简单接口的扩展接口和实现类型的数量级，把它们分为了核心接口和非核心接口。</p><p>在<code>io</code>包中，称得上核心接口的简单接口只有3个，即：<code>io.Reader</code>、<code>io.Writer</code>和<code>io.Closer</code>。这些核心接口在Go语言标准库中的实现类型都在200个以上。</p><p>另外，根据针对的I/O操作的不同，我还把简单接口分为了四大类。这四大类接口针对的操作分别是：读取、写入、关闭和读写位置设定。</p><p>其中，前三种操作属于基本的I/O操作。基于此，我带你梳理了每个类别的简单接口，并讲解了它们在<code>io</code>包中的扩展接口，以及具有代表性的实现类型。</p><p><img src=\"https://static001.geekbang.org/resource/image/e5/0b/e5b4af00105769cdc9f0ab729bb3b30b.png?wh=1822*1016\" alt=\"\"></p><p>（ io包中的接口体系）</p><p>除此之外，我还从多个维度为你描述了一些重要程序实体的功用和机理，比如：数据段读取器<code>io.SectionReader</code>、作为同步内存管道核心实现的<code>io.pipe</code>类型，以及用于数据拷贝的<code>io.CopyN</code>函数，等等。</p><p>我如此详尽且多角度的阐释，正是为了让你能够记牢<code>io</code>代码包中有着网状关系的接口和数据类型。我希望这个目的已经达到了，最起码，本文可以作为你深刻记忆它们的开始。</p><p>最后再强调一下，<code>io</code>包中的简单接口共有11个。其中，读取操作相关的接口有5个，写入操作相关的接口有4个，而与关闭操作有关的接口只有1个，另外还有一个读写位置设定相关的接口。</p><p>此外，<code>io</code>包还包含了9个基于这些简单接口的扩展接口。你需要在今后思考和实践的是，你在什么时候应该编写哪些数据类型实现<code>io</code>包中的哪些接口，并以此得到最大的好处。</p><h2>思考题</h2><p>今天的思考题是：<code>io</code>包中的同步内存管道的运作机制是什么？</p><p><a href=\"https://github.com/hyper0x/Golang_Puzzlers\">戳此查看Go语言专栏文章配套详细代码。</a></p><p></p>","comments":[{"had_liked":false,"id":160894,"user_name":"虢國技醬","can_delete":false,"product_type":"c1","uid":1056807,"ip_address":"","ucode":"5A192262AA037E","user_header":"https://static001.geekbang.org/account/avatar/00/10/20/27/a6932fbe.jpg","comment_is_top":false,"comment_ctime":1576055907,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"66000565347","product_id":100013101,"comment_content":"二刷<br>io包中io.go文件中的相关接口，特别是函数和类型方法的实现的代码写的真是简洁、精炼！看后真是惭愧自己什么时候能写出这么简洁优雅的代码！<br>墙裂推荐io.go源码，叹为观止","like_count":15},{"had_liked":false,"id":39154,"user_name":"我要攻击之爪","can_delete":false,"product_type":"c1","uid":1092661,"ip_address":"","ucode":"CCA9D04B7D1376","user_header":"https://static001.geekbang.org/account/avatar/00/10/ac/35/b6dbfab8.jpg","comment_is_top":false,"comment_ctime":1542199985,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"40196905649","product_id":100013101,"comment_content":"郝总，身体怎么样了，祝早日康复！","like_count":10},{"had_liked":false,"id":288968,"user_name":"noisyes","can_delete":false,"product_type":"c1","uid":2538540,"ip_address":"","ucode":"94EC310B284AD2","user_header":"https://static001.geekbang.org/account/avatar/00/26/bc/2c/963688bb.jpg","comment_is_top":false,"comment_ctime":1618802667,"is_pvip":false,"replies":[{"id":"104915","content":"简短的回答：是这样的。这是正常的。<br><br>复杂的回答：<br>实际上，“同时”是不可能发生的（说到底，任何代码的执行总会有先后，最多在时间上的距离非常非常非常近而已）。我们只能说在一段很短的时间段内，它们同时执行了（但现在大家常常简写为“同时执行”）。<br><br>如果这种“同时执行”的情况真的发生了，那么“它们谁先谁后”这种太过细微的判断就只能忽略不计了。一个原因是这种判断的成本远远大于收益，另一个原因是实在没有必要扣这么细。<br><br>所以，当 pipe 中的 wrCh 有“信号”的同时 done 也有“信号”，那么在此次直接返回 readCloseError 与在下次读时再返回 readCloseError 的差别可以忽略不计。原因我在上面说过了。<br><br>它们的结局都是“因 pipe 被提前关闭，导致数据读取不完整”。<br><br>在程序设计上，我们应该在 Write 方法的调用一方关闭 pipe。如果 Write 方法正常执行结束，那么你说的这种情况就不会出现，因为 Write 方法中有如下代码：<br><br>\tfor once := true; once || len(b) &gt; 0; once = false {<br>\t\tselect {<br>\t\tcase p.wrCh &lt;- b:<br>\t\t\tnw := &lt;-p.rdCh &#47;&#47; 此行是关键。<br>\t\t&#47;&#47; ......<br>\t}<br><br><br><br>","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1618900147,"ip_address":"","comment_id":288968,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27388606443","product_id":100013101,"comment_content":"func (p *pipe) Read(b []byte) (n int, err error) {<br>\tselect {<br>\tcase &lt;-p.done:<br>\t\treturn 0, p.readCloseError()<br>\tdefault:<br>\t}<br><br>\tselect {<br>\tcase bw := &lt;-p.wrCh:<br>\t\tnr := copy(b, bw)<br>\t\tp.rdCh &lt;- nr<br>\t\treturn nr, nil<br>\tcase &lt;-p.done:<br>\t\treturn 0, p.readCloseError()<br>\t}<br>}<br>以上是pipereader的代码，有个疑问select语句中 p.wrCh和p.done同时有信号产生，但是最终选择了done的分支语句，是不是就意味着后续数据就没法读出来了，这种情况是正常的吗","like_count":6,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518781,"discussion_content":"简短的回答：是这样的。这是正常的。\n\n复杂的回答：\n实际上，“同时”是不可能发生的（说到底，任何代码的执行总会有先后，最多在时间上的距离非常非常非常近而已）。我们只能说在一段很短的时间段内，它们同时执行了（但现在大家常常简写为“同时执行”）。\n\n如果这种“同时执行”的情况真的发生了，那么“它们谁先谁后”这种太过细微的判断就只能忽略不计了。一个原因是这种判断的成本远远大于收益，另一个原因是实在没有必要扣这么细。\n\n所以，当 pipe 中的 wrCh 有“信号”的同时 done 也有“信号”，那么在此次直接返回 readCloseError 与在下次读时再返回 readCloseError 的差别可以忽略不计。原因我在上面说过了。\n\n它们的结局都是“因 pipe 被提前关闭，导致数据读取不完整”。\n\n在程序设计上，我们应该在 Write 方法的调用一方关闭 pipe。如果 Write 方法正常执行结束，那么你说的这种情况就不会出现，因为 Write 方法中有如下代码：\n\n\tfor once := true; once || len(b) &amp;gt; 0; once = false {\n\t\tselect {\n\t\tcase p.wrCh &amp;lt;- b:\n\t\t\tnw := &amp;lt;-p.rdCh // 此行是关键。\n\t\t// ......\n\t}\n\n\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618900147,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":40616,"user_name":"我来也","can_delete":false,"product_type":"c1","uid":1205253,"ip_address":"","ucode":"773D6104F56767","user_header":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","comment_is_top":false,"comment_ctime":1542636545,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27312440321","product_id":100013101,"comment_content":"感觉这个专栏很值。最开始写的11月2号更新完，现在还在更。最近这几章的基础包，我只是过了一遍，觉得写的很详细，但自己消化的很有限。准备过段时间了再回过头来看看。","like_count":6},{"had_liked":false,"id":176186,"user_name":"CcczzZ","can_delete":false,"product_type":"c1","uid":1019568,"ip_address":"","ucode":"5F46DA5053D2BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/b0/ef201991.jpg","comment_is_top":false,"comment_ctime":1580982307,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10170916899","product_id":100013101,"comment_content":"io相关文章偏源码，需要慢慢消化，日常开发还未使用到，但是它实现的接口组合方式，却是在日常开发经常用到的，赞！","like_count":2},{"had_liked":false,"id":87486,"user_name":"🄽🄸🅇🅄🅂","can_delete":false,"product_type":"c1","uid":1000060,"ip_address":"","ucode":"853763C229A5AA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/7c/8ef14715.jpg","comment_is_top":false,"comment_ctime":1555609535,"is_pvip":false,"replies":[{"id":"31513","content":"加油加油！","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1555651475,"ip_address":"","comment_id":87486,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5850576831","product_id":100013101,"comment_content":"本以为go标准库, 学习起来会比前面的轻松一些的, 结果发现完全不是这么回事, 感觉比之前学起来更累","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447479,"discussion_content":"加油加油！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555651475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82724,"user_name":"嘎嘎","can_delete":false,"product_type":"c1","uid":1356047,"ip_address":"","ucode":"039447D8E1353A","user_header":"https://static001.geekbang.org/account/avatar/00/14/b1/0f/e81a93ed.jpg","comment_is_top":false,"comment_ctime":1554287647,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5849254943","product_id":100013101,"comment_content":"分为读写wr、rd 两个chan，均为阻塞。writer在wr中无未读取数据时写入，reader读取到数据后，向rd写入读取到的数据的长度。","like_count":1},{"had_liked":false,"id":52814,"user_name":"lovyhui","can_delete":false,"product_type":"c1","uid":1203034,"ip_address":"","ucode":"92338CEE283378","user_header":"https://static001.geekbang.org/account/avatar/00/12/5b/5a/24fb6f33.jpg","comment_is_top":false,"comment_ctime":1545534650,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"5840501946","product_id":100013101,"comment_content":"问题:<br>基于非缓冲通道传输数据, 堵塞读, 直至结束. 堵塞写, 根据通道已读计数,计算每一次写入通道的数据, 直至结束","like_count":1},{"had_liked":false,"id":359674,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1217554,"ip_address":"浙江","ucode":"C5A540BC5A60B9","user_header":"https://static001.geekbang.org/account/avatar/00/12/94/12/15558f28.jpg","comment_is_top":false,"comment_ctime":1665740439,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665740439","product_id":100013101,"comment_content":"io包中的同步内存管道的运作机制是通过pipe中的rdCh和wrCh进行数据的流转。读端会一直阻塞直到写端写入数据，或者写端关闭管道。写端会一直阻塞直到读端读走数据或读端关闭管道。写端会根据读端返回的读取长度，来继续写入数据，并保证写入的数据能完整的被读端读取。","like_count":0},{"had_liked":false,"id":334455,"user_name":"Geek_f62433","can_delete":false,"product_type":"c1","uid":2897824,"ip_address":"","ucode":"227F8013345AD6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJYJ74BKhY0ibtDEsWs0eBcWERTSOcsibQ6ke5ibhicibWYRmeyuQOoCN0t7mw0pf9o3lWmtU7ZPY2Azg/132","comment_is_top":false,"comment_ctime":1644967932,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1644967932","product_id":100013101,"comment_content":"写的很好，很详细，各个接口的关系也很清楚","like_count":0},{"had_liked":false,"id":76572,"user_name":"manatee","can_delete":false,"product_type":"c1","uid":1041112,"ip_address":"","ucode":"708D90E7A265BD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e2/d8/f0562ede.jpg","comment_is_top":false,"comment_ctime":1552633977,"is_pvip":false,"replies":[{"id":"28881","content":"嗯，必须的，这些类型很核心。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1553399236,"ip_address":"","comment_id":76572,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552633977","product_id":100013101,"comment_content":"io包包含的类型需要好好再消化一下","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443359,"discussion_content":"嗯，必须的，这些类型很核心。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553399236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73905,"user_name":"虢國技醬","can_delete":false,"product_type":"c1","uid":1056807,"ip_address":"","ucode":"5A192262AA037E","user_header":"https://static001.geekbang.org/account/avatar/00/10/20/27/a6932fbe.jpg","comment_is_top":false,"comment_ctime":1552030202,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552030202","product_id":100013101,"comment_content":"打卡<br>","like_count":0},{"had_liked":false,"id":41148,"user_name":"有匪君子","can_delete":false,"product_type":"c1","uid":1204061,"ip_address":"","ucode":"72B91AFC96E285","user_header":"https://static001.geekbang.org/account/avatar/00/12/5f/5d/63010e32.jpg","comment_is_top":false,"comment_ctime":1542732865,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1542732865","product_id":100013101,"comment_content":"你好，我定义了一个结构体，每次传过来的值都是[]byte类型，想用biranry.write直接写进去。但每次都需要不安排[]byte转换成buffers才能写进结构体。有可以直接写的方法吗？","like_count":0,"discussions":[{"author":{"id":1217554,"avatar":"https://static001.geekbang.org/account/avatar/00/12/94/12/15558f28.jpg","nickname":"Jason","note":"","ucode":"C5A540BC5A60B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590432,"discussion_content":"https://github.com/lunixbochs/struc","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665737823,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}