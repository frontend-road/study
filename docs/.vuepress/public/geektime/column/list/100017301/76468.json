{"id":76468,"title":"44 | 最短路径：地图软件是如何计算出最优出行路径的？","content":"<p>基础篇的时候，我们学习了图的两种搜索算法，深度优先搜索和广度优先搜索。这两种算法主要是针对无权图的搜索算法。针对有权图，也就是图中的每条边都有一个权重，我们该如何计算两点之间的最短路径（经过的边的权重和最小）呢？今天，我就从地图软件的路线规划问题讲起，带你看看常用的<strong>最短路径算法</strong>（Shortest Path Algorithm）。</p><p>像Google地图、百度地图、高德地图这样的地图软件，我想你应该经常使用吧？如果想从家开车到公司，你只需要输入起始、结束地址，地图就会给你规划一条最优出行路线。这里的最优，有很多种定义，比如最短路线、最少用时路线、最少红绿灯路线等等。<strong><span class=\"orange\">作为一名软件开发工程师，你是否思考过，地图软件的最优路线是如何计算出来的吗？底层依赖了什么算法呢？</span></strong></p><h2>算法解析</h2><p>我们刚提到的最优问题包含三个：最短路线、最少用时和最少红绿灯。我们先解决最简单的，最短路线。</p><p>解决软件开发中的实际问题，最重要的一点就是<strong>建模</strong>，也就是将复杂的场景抽象成具体的数据结构。针对这个问题，我们该如何抽象成数据结构呢？</p><p>我们之前也提到过，图这种数据结构的表达能力很强，显然，把地图抽象成图最合适不过了。我们把每个岔路口看作一个顶点，岔路口与岔路口之间的路看作一条边，路的长度就是边的权重。如果路是单行道，我们就在两个顶点之间画一条有向边；如果路是双行道，我们就在两个顶点之间画两条方向不同的边。这样，整个地图就被抽象成一个有向有权图。</p><!-- [[[read_end]]] --><p>具体的代码实现，我放在下面了。于是，我们要求解的问题就转化为，在一个有向有权图中，求两个顶点间的最短路径。</p><pre><code>public class Graph { // 有向有权图的邻接表表示\n  private LinkedList&lt;Edge&gt; adj[]; // 邻接表\n  private int v; // 顶点个数\n\n  public Graph(int v) {\n    this.v = v;\n    this.adj = new LinkedList[v];\n    for (int i = 0; i &lt; v; ++i) {\n      this.adj[i] = new LinkedList&lt;&gt;();\n    }\n  }\n\n  public void addEdge(int s, int t, int w) { // 添加一条边\n    this.adj[s].add(new Edge(s, t, w));\n  }\n\n  private class Edge {\n    public int sid; // 边的起始顶点编号\n    public int tid; // 边的终止顶点编号\n    public int w; // 权重\n    public Edge(int sid, int tid, int w) {\n      this.sid = sid;\n      this.tid = tid;\n      this.w = w;\n    }\n  }\n  // 下面这个类是为了dijkstra实现用的\n  private class Vertex {\n    public int id; // 顶点编号ID\n    public int dist; // 从起始顶点到这个顶点的距离\n    public Vertex(int id, int dist) {\n      this.id = id;\n      this.dist = dist;\n    }\n  }\n}\n</code></pre><p>想要解决这个问题，有一个非常经典的算法，最短路径算法，更加准确地说，是<strong>单源最短路径算法</strong>（一个顶点到一个顶点）。提到最短路径算法，最出名的莫过于Dijkstra算法了。所以，我们现在来看，Dijkstra算法是怎么工作的。</p><p>这个算法的原理稍微有点儿复杂，单纯的文字描述，不是很好懂。所以，我还是结合代码来讲解。</p><pre><code>// 因为Java提供的优先级队列，没有暴露更新数据的接口，所以我们需要重新实现一个\nprivate class PriorityQueue { // 根据vertex.dist构建小顶堆\n  private Vertex[] nodes;\n  private int count;\n  public PriorityQueue(int v) {\n    this.nodes = new Vertex[v+1];\n    this.count = v;\n  }\n  public Vertex poll() { // TODO: 留给读者实现... }\n  public void add(Vertex vertex) { // TODO: 留给读者实现...}\n  // 更新结点的值，并且从下往上堆化，重新符合堆的定义。时间复杂度O(logn)。\n  public void update(Vertex vertex) { // TODO: 留给读者实现...} \n  public boolean isEmpty() { // TODO: 留给读者实现...}\n}\n\npublic void dijkstra(int s, int t) { // 从顶点s到顶点t的最短路径\n  int[] predecessor = new int[this.v]; // 用来还原最短路径\n  Vertex[] vertexes = new Vertex[this.v];\n  for (int i = 0; i &lt; this.v; ++i) {\n    vertexes[i] = new Vertex(i, Integer.MAX_VALUE);\n  }\n  PriorityQueue queue = new PriorityQueue(this.v);// 小顶堆\n  boolean[] inqueue = new boolean[this.v]; // 标记是否进入过队列\n  vertexes[s].dist = 0;\n  queue.add(vertexes[s]);\n  inqueue[s] = true;\n  while (!queue.isEmpty()) {\n    Vertex minVertex= queue.poll(); // 取堆顶元素并删除\n    if (minVertex.id == t) break; // 最短路径产生了\n    for (int i = 0; i &lt; adj[minVertex.id].size(); ++i) {\n      Edge e = adj[minVertex.id].get(i); // 取出一条minVetex相连的边\n      Vertex nextVertex = vertexes[e.tid]; // minVertex--&gt;nextVertex\n      if (minVertex.dist + e.w &lt; nextVertex.dist) { // 更新next的dist\n        nextVertex.dist = minVertex.dist + e.w;\n        predecessor[nextVertex.id] = minVertex.id;\n        if (inqueue[nextVertex.id] == true) {\n          queue.update(nextVertex); // 更新队列中的dist值\n        } else {\n          queue.add(nextVertex);\n          inqueue[nextVertex.id] = true;\n        }\n      }\n    }\n  }\n  // 输出最短路径\n  System.out.print(s);\n  print(s, t, predecessor);\n}\n\nprivate void print(int s, int t, int[] predecessor) {\n  if (s == t) return;\n  print(s, predecessor[t], predecessor);\n  System.out.print(&quot;-&gt;&quot; + t);\n}\n</code></pre><p>我们用vertexes数组，记录从起始顶点到每个顶点的距离（dist）。起初，我们把所有顶点的dist都初始化为无穷大（也就是代码中的Integer.MAX_VALUE）。我们把起始顶点的dist值初始化为0，然后将其放到优先级队列中。</p><p>我们从优先级队列中取出dist最小的顶点minVertex，然后考察这个顶点可达的所有顶点（代码中的nextVertex）。如果minVertex的dist值加上minVertex与nextVertex之间边的权重w小于nextVertex当前的dist值，也就是说，存在另一条更短的路径，它经过minVertex到达nextVertex。那我们就把nextVertex的dist更新为minVertex的dist值加上w。然后，我们把nextVertex加入到优先级队列中。重复这个过程，直到找到终止顶点t或者队列为空。</p><p>以上就是Dijkstra算法的核心逻辑。除此之外，代码中还有两个额外的变量，predecessor数组和inqueue数组。</p><p>predecessor数组的作用是为了还原最短路径，它记录每个顶点的前驱顶点。最后，我们通过递归的方式，将这个路径打印出来。打印路径的print递归代码我就不详细讲了，这个跟我们在图的搜索中讲的打印路径方法一样。如果不理解的话，你可以回过头去看下那一节。</p><p>inqueue数组是为了避免将一个顶点多次添加到优先级队列中。我们更新了某个顶点的dist值之后，如果这个顶点已经在优先级队列中了，就不要再将它重复添加进去了。</p><p>看完了代码和文字解释，你可能还是有点懵，那我就举个例子，再给你解释一下。</p><p><img src=\"https://static001.geekbang.org/resource/image/e2/a9/e20907173c458fac741e556c947bb9a9.jpg?wh=1142*856\" alt=\"\"></p><p>理解了Dijkstra的原理和代码实现，我们来看下，<strong>Dijkstra算法的时间复杂度是多少？</strong></p><p>在刚刚的代码实现中，最复杂就是while循环嵌套for循环那部分代码了。while循环最多会执行V次（V表示顶点的个数），而内部的for循环的执行次数不确定，跟每个顶点的相邻边的个数有关，我们分别记作E0，E1，E2，……，E(V-1)。如果我们把这V个顶点的边都加起来，最大也不会超过图中所有边的个数E（E表示边的个数）。</p><p>for循环内部的代码涉及从优先级队列取数据、往优先级队列中添加数据、更新优先级队列中的数据，这样三个主要的操作。我们知道，优先级队列是用堆来实现的，堆中的这几个操作，时间复杂度都是O(logV)（堆中的元素个数不会超过顶点的个数V）。</p><p>所以，综合这两部分，再利用乘法原则，整个代码的时间复杂度就是O(E*logV)。</p><p>弄懂了Dijkstra算法，我们再来回答之前的问题，如何计算最优出行路线？</p><p>从理论上讲，用Dijkstra算法可以计算出两点之间的最短路径。但是，你有没有想过，对于一个超级大地图来说，岔路口、道路都非常多，对应到图这种数据结构上来说，就有非常多的顶点和边。如果为了计算两点之间的最短路径，在一个超级大图上动用Dijkstra算法，遍历所有的顶点和边，显然会非常耗时。那我们有没有什么优化的方法呢？</p><p>做工程不像做理论，一定要给出个最优解。理论上算法再好，如果执行效率太低，也无法应用到实际的工程中。<strong>对于软件开发工程师来说，我们经常要根据问题的实际背景，对解决方案权衡取舍。类似出行路线这种工程上的问题，我们没有必要非得求出个绝对最优解。很多时候，为了兼顾执行效率，我们只需要计算出一个可行的次优解就可以了</strong>。</p><p>有了这个原则，你能想出刚刚那个问题的优化方案吗？</p><p>虽然地图很大，但是两点之间的最短路径或者说较好的出行路径，并不会很“发散”，只会出现在两点之间和两点附近的区块内。所以我们可以在整个大地图上，划出一个小的区块，这个小区块恰好可以覆盖住两个点，但又不会很大。我们只需要在这个小区块内部运行Dijkstra算法，这样就可以避免遍历整个大图，也就大大提高了执行效率。</p><p>不过你可能会说了，如果两点距离比较远，从北京海淀区某个地点，到上海黄浦区某个地点，那上面的这种处理方法，显然就不工作了，毕竟覆盖北京和上海的区块并不小。</p><p>我给你点提示，你可以现在打开地图App，缩小放大一下地图，看下地图上的路线有什么变化，然后再思考，这个问题该怎么解决。</p><p>对于这样两点之间距离较远的路线规划，我们可以把北京海淀区或者北京看作一个顶点，把上海黄浦区或者上海看作一个顶点，先规划大的出行路线。比如，如何从北京到上海，必须要经过某几个顶点，或者某几条干道，然后再细化每个阶段的小路线。</p><p>这样，最短路径问题就解决了。我们再来看另外两个问题，最少时间和最少红绿灯。</p><p>前面讲最短路径的时候，每条边的权重是路的长度。在计算最少时间的时候，算法还是不变，我们只需要把边的权重，从路的长度变成经过这段路所需要的时间。不过，这个时间会根据拥堵情况时刻变化。如何计算车通过一段路的时间呢？这是一个蛮有意思的问题，你可以自己思考下。</p><p>每经过一条边，就要经过一个红绿灯。关于最少红绿灯的出行方案，实际上，我们只需要把每条边的权值改为1即可，算法还是不变，可以继续使用前面讲的Dijkstra算法。不过，边的权值为1，也就相当于无权图了，我们还可以使用之前讲过的广度优先搜索算法。因为我们前面讲过，广度优先搜索算法计算出来的两点之间的路径，就是两点的最短路径。</p><p>不过，这里给出的所有方案都非常粗糙，只是为了给你展示，如何结合实际的场景，灵活地应用算法，让算法为我们所用，真实的地图软件的路径规划，要比这个复杂很多。而且，比起Dijkstra算法，地图软件用的更多的是类似A*的启发式搜索算法，不过也是在Dijkstra算法上的优化罢了，我们后面会讲到，这里暂且不展开。</p><h2>总结引申</h2><p>今天，我们学习了一种非常重要的图算法，<strong>Dijkstra最短路径算法</strong>。实际上，最短路径算法还有很多，比如Bellford算法、Floyd算法等等。如果感兴趣，你可以自己去研究。</p><p>关于Dijkstra算法，我只讲了原理和代码实现。对于正确性，我没有去证明。之所以这么做，是因为证明过程会涉及比较复杂的数学推导。这个并不是我们的重点，你只要掌握这个算法的思路就可以了。</p><p>这些算法实现思路非常经典，掌握了这些思路，我们可以拿来指导、解决其他问题。比如Dijkstra这个算法的核心思想，就可以拿来解决下面这个看似完全不相关的问题。这个问题是我之前工作中遇到的真实的问题，为了在较短的篇幅里把问题介绍清楚，我对背景做了一些简化。</p><p>我们有一个翻译系统，只能针对单个词来做翻译。如果要翻译一整个句子，我们需要将句子拆成一个一个的单词，再丢给翻译系统。针对每个单词，翻译系统会返回一组可选的翻译列表，并且针对每个翻译打一个分，表示这个翻译的可信程度。</p><p><img src=\"https://static001.geekbang.org/resource/image/91/67/91b68e47e0d8521cb3ce66bb9827c767.jpg?wh=1142*544\" alt=\"\"></p><p>针对每个单词，我们从可选列表中，选择其中一个翻译，组合起来就是整个句子的翻译。每个单词的翻译的得分之和，就是整个句子的翻译得分。随意搭配单词的翻译，会得到一个句子的不同翻译。针对整个句子，我们希望计算出得分最高的前k个翻译结果，你会怎么编程来实现呢？</p><p><img src=\"https://static001.geekbang.org/resource/image/76/53/769cab20f6a50c0b7a4ed571c9f28a53.jpg?wh=1142*484\" alt=\"\"></p><p>当然，最简单的办法还是借助回溯算法，穷举所有的排列组合情况，然后选出得分最高的前k个翻译结果。但是，这样做的时间复杂度会比较高，是O(m^n)，其中，m表示平均每个单词的可选翻译个数，n表示一个句子中包含多少个单词。这个解决方案，你可以当作回溯算法的练习题，自己编程实现一下，我就不多说了。</p><p>实际上，这个问题可以借助Dijkstra算法的核心思想，非常高效地解决。每个单词的可选翻译是按照分数从大到小排列的，所以$a_{0}b_{0}c_{0}$肯定是得分最高组合结果。我们把$a_{0}b_{0}c_{0}$及得分作为一个对象，放入到优先级队列中。</p><p>我们每次从优先级队列中取出一个得分最高的组合，并基于这个组合进行扩展。扩展的策略是每个单词的翻译分别替换成下一个单词的翻译。比如$a_{0}b_{0}c_{0}$扩展后，会得到三个组合，$a_{1}b_{0}c_{0}$、$a_{0}b_{1}c_{0}$、$a_{0}b_{0}c_{1}$。我们把扩展之后的组合，加到优先级队列中。重复这个过程，直到获取到k个翻译组合或者队列为空。</p><p><img src=\"https://static001.geekbang.org/resource/image/e7/6c/e71f307ca575d364ba2b23a022779f6c.jpg?wh=1142*797\" alt=\"\"></p><p>我们来看，这种实现思路的时间复杂度是多少？</p><p>假设句子包含n个单词，每个单词平均有m个可选的翻译，我们求得分最高的前k个组合结果。每次一个组合出队列，就对应着一个组合结果，我们希望得到k个，那就对应着k次出队操作。每次有一个组合出队列，就有n个组合入队列。优先级队列中出队和入队操作的时间复杂度都是O(logX)，X表示队列中的组合个数。所以，总的时间复杂度就是O(k*n*logX)。那X到底是多少呢？</p><p>k次出入队列，队列中的总数据不会超过k*n，也就是说，出队、入队操作的时间复杂度是O(log(k*n))。所以，总的时间复杂度就是O(k*n*log(k*n))，比之前的指数级时间复杂度降低了很多。</p><h2>课后思考</h2><ol>\n<li>\n<p>在计算最短时间的出行路线中，如何获得通过某条路的时间呢？这个题目很有意思，我之前面试的时候也被问到过，你可以思考看看。</p>\n</li>\n<li>\n<p>今天讲的出行路线问题，我假设的是开车出行，那如果是公交出行呢？如果混合地铁、公交、步行，又该如何规划路线呢？</p>\n</li>\n</ol><p>欢迎留言和我分享，也欢迎点击“<span class=\"orange\">请朋友读</span>”，把今天的内容分享给你的好友，和他一起讨论、学习。</p>","comments":[{"had_liked":false,"id":57467,"user_name":"五岳寻仙","can_delete":false,"product_type":"c1","uid":1247467,"ip_address":"","ucode":"88A46A4E1832CE","user_header":"https://static001.geekbang.org/account/avatar/00/13/08/eb/594e9e6c.jpg","comment_is_top":false,"comment_ctime":1546818364,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"688741585724","product_id":100017301,"comment_content":"课后思考题，自己能想到的。<br><br>1.获取通过某条路的时间：通过某条路的时间与①路长度②路况(是否平坦等)③拥堵情况④红绿灯个数等因素相关。获取这些因素后就可以建立一个回归模型(比如线性回归)来估算时间。其中①②④因素比较固定，容易获得。③是动态的，但也可以通过a.与交通部门合作获得路段拥堵情况；b.联合其他导航软件获得在该路段的在线人数；c.通过现在时间段正好在次路段的其他用户的真实情况等方式估算。<br><br>2.混合公交、地铁和步行时：地铁时刻表是固定的，容易估算。公交虽然没那么准时，大致时间是可以估计的，步行时间受路拥堵状况小，基本与道路长度成正比，也容易估算。总之，感觉公交、地铁、步行，时间估算会比开车更容易，也更准确些。","like_count":161,"discussions":[{"author":{"id":1397351,"avatar":"https://static001.geekbang.org/account/avatar/00/15/52/67/fcba0967.jpg","nickname":"zapup","note":"","ucode":"388D6BB5D7B137","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":221116,"discussion_content":"我的理解，两个点之间就有多种连线方式了，当然其权重也是方式对应的时间","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585978271,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1237874,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e3/72/754314c2.jpg","nickname":"Jackson","note":"","ucode":"A76BC6A4EE13A1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87256,"discussion_content":"其实感觉公交跟开车需要考虑的是差不多的，只不过，公交多了一个等待时间和每站停靠时间","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576656151,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1027207,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ac/87/8ed5880a.jpg","nickname":"大碗","note":"","ucode":"F9CDC0C5BE48AC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538859,"discussion_content":"疫情期间上车出示健康码也影响了公车时间的估算","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639540270,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1205485,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJUhJakYu4BI7eFnheKDdibDjZqz32ia2rhN0Jz5YoR1ZRlDrLcFNr4MJnPg3WiaxaocWotOANeqsBibw/132","nickname":"小白","note":"","ucode":"862EA133563634","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261062,"discussion_content":"优秀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588935855,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":88827,"discussion_content":"em\n公交和开车差不多，除非 都有专用道","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576733226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1237874,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e3/72/754314c2.jpg","nickname":"Jackson","note":"","ucode":"A76BC6A4EE13A1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87253,"discussion_content":"考虑是不是跟马路限速或者天气也有一定的关系","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576655877,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1258401,"avatar":"https://static001.geekbang.org/account/avatar/00/13/33/a1/f3835f01.jpg","nickname":"社会猪","note":"","ucode":"CFF5EA7F247373","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":20355,"discussion_content":"哈哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569304794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":59321,"user_name":"李东勇","can_delete":false,"product_type":"c1","uid":1236071,"ip_address":"","ucode":"7D1EA72D326F32","user_header":"https://static001.geekbang.org/account/avatar/00/12/dc/67/5149a60b.jpg","comment_is_top":false,"comment_ctime":1547350699,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"147576238763","product_id":100017301,"comment_content":"有兴趣的可以看下LeetCode 上这道题： https:&#47;&#47;leetcode.com&#47;problems&#47;network-delay-time&#47;<br>用到的就是Dijkstra 算法","like_count":34,"discussions":[{"author":{"id":1537033,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJu6UPy60jo9osWZs00xZ54eHcxHjUTg5s8p6M7l2sUFQcibk9PVFxDIplD9ENFYfx4B5Ljicnmu0VQ/132","nickname":"Geek_python","note":"","ucode":"0F4AB46B923765","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":243303,"discussion_content":"leetcode743","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1587532847,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1231623,"avatar":"https://static001.geekbang.org/account/avatar/00/12/cb/07/482b7155.jpg","nickname":"牛玉富","note":"","ucode":"DD962676F8FAF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549721,"discussion_content":"找到的就是它","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644219399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57493,"user_name":"徐凯","can_delete":false,"product_type":"c1","uid":1244991,"ip_address":"","ucode":"12F82BA3649CD5","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/3f/bbb8a88c.jpg","comment_is_top":false,"comment_ctime":1546822751,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"134690808927","product_id":100017301,"comment_content":"@五岳寻仙的答案太棒了 👏 我感觉每条道路应该还有限速，这个因素也要考察。","like_count":31,"discussions":[{"author":{"id":1796438,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/zlWt0lPDicdib5BTUbuwA3wLLUuejtZ5icGu3DHMBPd6PicXOdhZ3zYFts8VkXjjyQuxzUJas2w5OTmx3icWKiaZM1Vg/132","nickname":"youyou.L","note":"","ucode":"B3DB0D0700EEAC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":323784,"discussion_content":"第一个想到的是 最短时间：路程 / 限速速度； 平均时间：最短时间 * （1 + 最短时间/平均时间)，后面才想着拥堵状态，加入拥堵状态后实际复杂很多","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604996125,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57777,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1546908639,"is_pvip":false,"replies":[{"id":"21860","content":"Dijkstra实际上可以看做动态规划：）","user_name":"作者回复","comment_id":57777,"uid":"1190123","ip_address":"","utype":1,"ctime":1547709754,"user_name_real":"gg"}],"discussion_count":8,"race_medal":0,"score":"117511025631","product_id":100017301,"comment_content":"有2个疑问：<br><br>1 Dijkstra就是贪心算法吧？<br>2 它的解可能不是最优解","like_count":27,"discussions":[{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":88830,"discussion_content":"1、怎么可能是贪心。。。。贪心是每次根据贪心选择性直接一条路走到黑了\n2、就是最优解，本身这个题 就是 多阶段决策最优解模型，完全符合DP。。\n至于这个解题的思路。。。不是那么好想的。。。\n感觉 直接符合了 堆或者说 优先级队列的适用场景。。。。\n\n","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1576733413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1691507,"avatar":"https://static001.geekbang.org/account/avatar/00/19/cf/73/639a8c06.jpg","nickname":"Leo","note":"","ucode":"CBEAB0E759BF89","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300606,"discussion_content":"一开始我也理解是贪心，不过看到下面老师的回复，我又想了一下，每一次其实都会更新未遍历节点的最小距离，感觉符合DP，我再去看看DP。。。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1598189761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1045078,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f2/56/c39046c0.jpg","nickname":"Jie","note":"","ucode":"AB94041E548FEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271456,"discussion_content":"当初算法分析课就说过，是贪心的例子。\n通过证明，局部最优就是全局最优。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1590140715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1986940,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/51/7c/2a286799.jpg","nickname":"颜值不算太高","note":"","ucode":"2B074A6F24FF4B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":253335,"discussion_content":"我们课本上Dijkstra算法是在贪心算法这一章讲的...","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1588227460,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435753,"discussion_content":"Dijkstra实际上可以看做动态规划：）","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1547709754,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330096,"discussion_content":"是的。想到堆或者优先级队列很容易。但是dijkstra算法就想不到了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606531018,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1796438,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/zlWt0lPDicdib5BTUbuwA3wLLUuejtZ5icGu3DHMBPd6PicXOdhZ3zYFts8VkXjjyQuxzUJas2w5OTmx3icWKiaZM1Vg/132","nickname":"youyou.L","note":"","ucode":"B3DB0D0700EEAC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":323785,"discussion_content":"动态规划好吧。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604996182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1257418,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2f/ca/cbce6e94.jpg","nickname":"梦想的优惠券","note":"","ucode":"D3B44F6C618CA7","race_medal":4,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":117495,"discussion_content":"打卡","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578121925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168041,"user_name":"book尾汁","can_delete":false,"product_type":"c1","uid":1446375,"ip_address":"","ucode":"AE2B8DFC643ACC","user_header":"https://static001.geekbang.org/account/avatar/00/16/11/e7/044a9a6c.jpg","comment_is_top":false,"comment_ctime":1577984409,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"87477330329","product_id":100017301,"comment_content":"感觉这个算法最不容易让人理解的地方就是优先级队列里的某个顶点B pop出去以后，会不会以后会有某个还没有入队列的节点C 使经过节点C到B到源点的距离更近，实际这是不会的，因为优先级队列每次都是pop出当前离源点距离最近的点，假如节点C经过B使B到源点的距离更近，那么C点在优先级队列一定会比B先pop出去，然后更新B到源点的距离，想明白这一点，这个算法就很好理解了。","like_count":20,"discussions":[{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330097,"discussion_content":"赞。关键部分就是这里。只要图包含了所有路径，就是小顶堆思路。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1606531123,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1030657,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ba/01/5ce8ce0b.jpg","nickname":"Leoorz","note":"","ucode":"8912628AD6ADE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295742,"discussion_content":"老铁，我理解你说的，也是我比较纠结的一个点，反证法终于想通了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596326693,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":66982,"user_name":"林大涛","can_delete":false,"product_type":"c1","uid":1125058,"ip_address":"","ucode":"E8A23BE3738CFE","user_header":"","comment_is_top":false,"comment_ctime":1550050800,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"83154429424","product_id":100017301,"comment_content":"用小顶堆，就是为了确保每个阶段，堆顶的节点都是目前阶段的最短路径的节点。","like_count":19},{"had_liked":false,"id":171766,"user_name":"Shaohong","can_delete":false,"product_type":"c1","uid":1039902,"ip_address":"","ucode":"CFC342E182357B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/de/1e/4e3d207f.jpg","comment_is_top":false,"comment_ctime":1579009073,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"57413583921","product_id":100017301,"comment_content":"geeksforgeeks上面对Dijkstra算法介绍很好懂。https:&#47;&#47;www.geeksforgeeks.org&#47;dijkstras-shortest-path-algorithm-greedy-algo-7<br>根据这个算法，老师没有必要用inqueue数组。可以一开始就把所有Vertex都加入到PriorityQueue中，之后就只做取顶操作和更新操作。","like_count":13},{"had_liked":false,"id":115559,"user_name":"mrlay","can_delete":false,"product_type":"c1","uid":1041640,"ip_address":"","ucode":"385A1954ED3317","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e4/e8/a1703783.jpg","comment_is_top":false,"comment_ctime":1563624708,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"48808264964","product_id":100017301,"comment_content":"这是一个动态规划的问题，我最开始也以为是个贪心算法，会有这样的想法是每次都会去选择dist最小的那个顶点，殊不知这个顶点是在算完每个邻接顶点后（有可能是间接相邻的）选择最小的那个。<br>vertex 临时数组的作用就是为了临时记录从起点到该顶点dist, 用来更新最小优先队列。","like_count":11,"discussions":[{"author":{"id":2302244,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/OlIKJXCtPSstqW2bwUo2LoCiaKeKUcoUEmaDDrjXK9CZ9Tj3ILCF8ibHsUib5QicFb6vqwzzgusCc8y5lGOibPyWAFg/132","nickname":"Geek_ba2cd6","note":"","ucode":"8821766E645C15","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369702,"discussion_content":"的确看到好多写博客的理解为贪心思想，感觉有误导，应该是动态规划","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619139918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330092,"discussion_content":"翻译题，怎么想到dijkstra算法？跟图的最短路径思想差距好远。跟堆的思想距离近，倒是容易联想到用堆。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606530383,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329913,"discussion_content":"老师的翻译题，为啥不分组排序？排序后，取最大值就可以。O(nlog10) ==O(n)了 ---每个单词不可能有10个选择。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606480860,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":59054,"user_name":"yongxiang","can_delete":false,"product_type":"c1","uid":1082351,"ip_address":"","ucode":"16D826814D4C4B","user_header":"https://static001.geekbang.org/account/avatar/00/10/83/ef/445e1421.jpg","comment_is_top":false,"comment_ctime":1547288397,"is_pvip":false,"replies":[{"id":"21475","content":"嗯嗯 我更新下代码","user_name":"作者回复","comment_id":59054,"uid":"1190123","ip_address":"","utype":1,"ctime":1547431410,"user_name_real":"gg"}],"discussion_count":1,"race_medal":3,"score":"40201994061","product_id":100017301,"comment_content":"王老师，我输入代码运行后，实际出队列的顺序跟图中的不一样，实际（15，0）出队列 在（13，3）出队列前面。我看了代码，应该是修改（25，1）为 （13，3）的时候，小顶堆不会自动更新顺序。需要对22行进行如下修改，更新已经在队列中，又改了dist的Vertex的优先级：<br>                   if (inQueue[nextVertex.id] == false){<br>                        queue.add(nextVertex);<br>                        inQueue[nextVertex.id] = true;<br>                    }<br>                    else { &#47;&#47; 更新已经在队列中，又改了dist的Vertex的优先级<br>                        queue.remove(nextVertex);<br>                        queue.add(nextVertex);<br>                    }","like_count":9,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436285,"discussion_content":"嗯嗯 我更新下代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547431410,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187266,"user_name":"王策","can_delete":false,"product_type":"c1","uid":1101632,"ip_address":"","ucode":"F4BD51DBD92353","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/40/8d02f5ef.jpg","comment_is_top":false,"comment_ctime":1584070554,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"31648841626","product_id":100017301,"comment_content":"文章翻译系统的例子与Leetcode上这一题类似：https:&#47;&#47;leetcode-cn.com&#47;problems&#47;find-k-pairs-with-smallest-sums&#47;","like_count":8,"discussions":[{"author":{"id":1537033,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJu6UPy60jo9osWZs00xZ54eHcxHjUTg5s8p6M7l2sUFQcibk9PVFxDIplD9ENFYfx4B5Ljicnmu0VQ/132","nickname":"Geek_python","note":"","ucode":"0F4AB46B923765","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":243310,"discussion_content":"leetcode373","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1587533130,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176129,"user_name":"Geek_94adb8","can_delete":false,"product_type":"c1","uid":1638187,"ip_address":"","ucode":"B142F473E1A0B3","user_header":"","comment_is_top":false,"comment_ctime":1580966234,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"27350770010","product_id":100017301,"comment_content":"使用内部类，代码的可读性很差！","like_count":7,"discussions":[{"author":{"id":1100439,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ca/97/5042c207.jpg","nickname":"king","note":"","ucode":"FFC090D0EF1F80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349845,"discussion_content":"怎么就差了，放一起看不更好","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1613575466,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1444484,"avatar":"https://static001.geekbang.org/account/avatar/00/16/0a/84/12698aff.jpg","nickname":"Shelter🐏","note":"","ucode":"51CF7ABF62F243","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584652,"discussion_content":"不熟悉Java的，看得有点吃力","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661001290,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1939316,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/97/74/a933d664.jpg","nickname":"莜戏","note":"","ucode":"C3488A2BB44359","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382386,"discussion_content":"注意此处场景，灵活判断","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625553816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78814,"user_name":"xuery","can_delete":false,"product_type":"c1","uid":1027584,"ip_address":"","ucode":"F461B61BE06131","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/00/025f37e7.jpg","comment_is_top":false,"comment_ctime":1553244874,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"27323048650","product_id":100017301,"comment_content":"构建优先队列的update函数时，时间复杂度应该是O(n)，因为小顶堆查找的时间复杂度是O(n)，虽然查找之后向上堆化的时间复杂度时O（logn）","like_count":6,"discussions":[{"author":{"id":2628460,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK9Yvy5STDw874VEEuPehIcONR9kEq7knIicUNuINU0ovf2ViabhFqiabZiaoXC5FqL89YDCxp3tBnFzA/132","nickname":"Geek_5b2ab1","note":"","ucode":"C1AF841A9F0B6C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411516,"discussion_content":"可以建一个hashmap, key是节点，value是 节点在堆数组中的下标。哈希的查找 修改 删除都是O(1) ,  堆化过程中最多使用哈希O( logn )次， 总的时间复杂度还是O(logn) 。利用哈希快速定位节点的思想 在LRU 中也出现过，https://leetcode-cn.com/problems/lru-cache/","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635944276,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214963,"user_name":"社会你强哥","can_delete":false,"product_type":"c1","uid":1243570,"ip_address":"","ucode":"325B9005588D9B","user_header":"https://static001.geekbang.org/account/avatar/00/12/f9/b2/2ed800b4.jpg","comment_is_top":false,"comment_ctime":1588858261,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18768727445","product_id":100017301,"comment_content":"不能只有代码，解释代码就完事了，能够从原理的角度来描述dijkstra是怎么做的么？","like_count":5},{"had_liked":false,"id":202372,"user_name":"zapup","can_delete":false,"product_type":"c1","uid":1397351,"ip_address":"","ucode":"388D6BB5D7B137","user_header":"https://static001.geekbang.org/account/avatar/00/15/52/67/fcba0967.jpg","comment_is_top":false,"comment_ctime":1585978731,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18765847915","product_id":100017301,"comment_content":"动态累计，谁最小谁行动","like_count":4},{"had_liked":false,"id":168029,"user_name":"book尾汁","can_delete":false,"product_type":"c1","uid":1446375,"ip_address":"","ucode":"AE2B8DFC643ACC","user_header":"https://static001.geekbang.org/account/avatar/00/16/11/e7/044a9a6c.jpg","comment_is_top":false,"comment_ctime":1577980306,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"18757849490","product_id":100017301,"comment_content":"第十三天：<br>地图软件是如何计算出最短路径的<br>我们把每个岔路口看作一个顶点，岔路口与岔路口之间的路看作一条边，路的长度就是边的权重。如果路是单行道，我们就在两个顶点之间画一条有向边；如果路是双行道，我们就在两个顶点之间画两条方向不同的边，这样就构成了一幅有向有权图。这个问题就转化为求一个有向有权图中，两个顶点最短路径的问题。<br>上述问题可以使用dijkstra算法<br>原理：将每个顶点到起始顶点的距离初始为无穷，然后从起始点开始，将其加入一个优先级队列中，从优先级队列中取出到源点距离最小的顶点，然后比较其周围顶点离源点的距离是否大于其到源点的距离+其到周围顶点的距离，如果大于的话，更新周围顶点到源点的距离为较小的值以及其前序节点，并将其加入优先级队列中（如果已经加入过，就不需加入了），再取出优先级队列中的距离最小值，循环往复，直到取出终止顶点t，或者优先级队列为空。此时倒序输出终止顶点t的前序节点，前序节点的前序节点。。。，直到前序节点的前序节点为s,此时路径即为最短路径。<br>计算最少红绿灯依然可以采用上述的思路，构造一个有向无权图。<br>对于地点跨度范围比较大，可以分阶段来计算，找出哪些点是必经的点，然后拆分阶段。具体到每个区域，可以找个合适的区域将源点与中点覆盖进去，来减少顶点的数量。","like_count":5},{"had_liked":false,"id":156334,"user_name":"三年过后","can_delete":false,"product_type":"c1","uid":1283157,"ip_address":"","ucode":"5E9106C5F11BED","user_header":"https://static001.geekbang.org/account/avatar/00/13/94/55/afc64956.jpg","comment_is_top":false,"comment_ctime":1574858048,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18754727232","product_id":100017301,"comment_content":"优先队列代码：<br>class PriorityQueue{&#47;&#47;构建小顶堆<br>\t\tVertex[] nodes;<br>\t\tprivate int count;&#47;&#47;队列个数<br>\t\tpublic PriorityQueue(int v){<br>\t\t\tnodes = new Vertex[v+1];&#47;&#47;小顶堆，数组从小标1开始，好计算<br>\t\t\tthis.count = 0;&#47;&#47;初始0个元素<br>\t\t}<br>\t\tpublic Vertex poll(){<br>\t\t\tVertex v =  nodes[1];&#47;&#47;返回堆顶原始<br>\t\t\tnodes[1] = nodes[count];&#47;&#47;将最后一个元素添加到堆顶，自上而下堆化<br>\t\t\t--count;<br>\t\t\theapifyUpToDown(1);&#47;&#47;堆顶从上而下堆化<br>\t\t\treturn v;<br>\t\t}<br>\t\tpublic void add(Vertex vertex){<br>\t\t\tnodes[++count] = vertex;<br>\t\t\tvertex.i = count;<br>\t\t\theapifyDownToUp(count);&#47;&#47;从下往上堆化<br>\t\t}<br>\t\tpublic void update(Vertex vertex){<br>\t\t\t&#47;&#47;查找，并更新<br>\t\t\tnodes[vertex.i].dist = vertex.dist;<br>\t\t\theapifyDownToUp(vertex.i);&#47;&#47;从下往上堆化<br>\t\t}<br>\t\tpublic boolean isEmpty(){<br>\t\t\treturn this.count == 0 ? true : false;<br>\t\t}<br>\t\t&#47;&#47;自上而下堆化<br>\t\tprivate void heapifyUpToDown(int i) {<br>\t\t\twhile(i&lt;=count){<br>\t\t\t\tint maxPos = i;<br>\t\t\t\tif((i*2)&lt;=count &amp;&amp; nodes[maxPos].dist &gt; nodes[i*2].dist) maxPos = 2*i;<br>\t\t\t\telse if((i*2+1)&lt;=count &amp;&amp; nodes[maxPos].dist &gt; nodes[i*2+1].dist) maxPos = 2*i+1;<br>\t\t\t\telse if(maxPos == i)break;<br>\t\t\t\tswap(i,maxPos);&#47;&#47;交换<br>\t\t\t\ti = maxPos;<br>\t\t\t}<br>\t\t}<br>\t\t&#47;&#47;从下往上堆化<br>\t\tprivate void heapifyDownToUp(int i) {<br>\t\t\twhile (i &#47; 2 &gt; 0 &amp;&amp; nodes[i].dist &lt; nodes[i &#47; 2].dist) {<br>\t\t\t\tswap(i,i&#47;2);&#47;&#47;交换<br>\t\t\t\ti = i &#47; 2;<br>\t\t\t}<br>\t\t}<br>\t\t&#47;**<br>\t\t * 数据交换<br>\t\t * @param i<br>\t\t * @param maxPos<br>\t\t *&#47;<br>\t\tprivate void swap(int i, int maxPos) {<br>\t\t\tnodes[i].i = maxPos;&#47;&#47;下标交换记录<br>\t\t\tnodes[maxPos].i = i;<br>\t\t\t<br>\t\t\tVertex tmp = nodes[i];<br>\t\t\tnodes[i] = nodes[maxPos];<br>\t\t\tnodes[maxPos] = tmp;<br>\t\t}<br>\t}","like_count":4,"discussions":[{"author":{"id":2162521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/MaX06SRk19zM2lAaymYylpXD6LMtIPFlDyxZKgRhmZCjhNE4nIdDGBmh08razhebVCgAv54xialYBBIIwmleBew/132","nickname":"Geek_6d1382","note":"","ucode":"B61E65CFEB684F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":533858,"discussion_content":"这个update方法实现是不是遗漏一种条件，应该分二种情况，这里这实现了自底向上的，还有自顶向下的堆化情况，小顶堆情况，如果更新后的值小于更新前，自底向上堆化；如果更新后大于更新前，自顶向下堆化；值没变，无需变化","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1637995449,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129623,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1567175309,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14452077197","product_id":100017301,"comment_content":"Dijkstra算法的最后到例子-那张图，各个节点的(0,无), (10,0)等等代表什么意思","like_count":3,"discussions":[{"author":{"id":1250907,"avatar":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","nickname":"Monday","note":"","ucode":"77B9BACC783598","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6925,"discussion_content":"看明白了，前面的数字是到源点的最短距离，后面的数字是到达源点最短距离时上个节点下id","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1567176276,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":95735,"user_name":"mαnajay","can_delete":false,"product_type":"c1","uid":1067450,"ip_address":"","ucode":"6DE9FBD1BEC8AD","user_header":"https://static001.geekbang.org/account/avatar/00/10/49/ba/23c9246a.jpg","comment_is_top":false,"comment_ctime":1558153029,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14443054917","product_id":100017301,"comment_content":"最开始以为是贪心算法, 再看了一遍,才发现优先级队列的作用(拥有类似回溯的功能),按照已添加队列中最短距离进行小顶堆, 每次 poll 的过程中,都有可能将之前已经计算过的顶点再拿出来, 遍历邻接表,重复到目的顶点 ","like_count":3},{"had_liked":false,"id":292275,"user_name":"风","can_delete":false,"product_type":"c1","uid":1444483,"ip_address":"","ucode":"E1CE0825AAF805","user_header":"https://static001.geekbang.org/account/avatar/00/16/0a/83/f916f903.jpg","comment_is_top":false,"comment_ctime":1620748821,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10210683413","product_id":100017301,"comment_content":"当权值变为1时，<br>Dijkstra算法退化为BFS，<br>prioQueue 退化为 queue，<br>inqueue 数组退化为 visited 数组，<br>predecessor 数组退化为 prev 数组","like_count":2},{"had_liked":false,"id":278655,"user_name":"Geek_6c75ea","can_delete":false,"product_type":"c1","uid":1636304,"ip_address":"","ucode":"820876A0DC0756","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKTvHVDjMcR30V0BlLmsMfIFb6OKSwjVHJL3BNSzN5jiaptGsjuRxXaKtiafvSyiax2zhr0tia1NBCibyw/132","comment_is_top":false,"comment_ctime":1613181447,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10203116039","product_id":100017301,"comment_content":"为啥我觉得dijkstra算法，就是带了权重的广度优先搜索？","like_count":2,"discussions":[{"author":{"id":2694205,"avatar":"https://static001.geekbang.org/account/avatar/00/29/1c/3d/76465ee4.jpg","nickname":"摘星","note":"","ucode":"55D8CAFC938F91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551258,"discussion_content":"差不多...但是搜索是..全都要，这里是只要最值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644941409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":231992,"user_name":"tuyu","can_delete":false,"product_type":"c1","uid":1448863,"ip_address":"","ucode":"B235325B541408","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/BIRpwViaN51yynIeFonD7QRlwDCVtKibrG956NTxzEqibOZZVjhMMgibOPmd3VicfYxpknZsic1oJq8KicZvXkmmiajuQg/132","comment_is_top":false,"comment_ctime":1593825706,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10183760298","product_id":100017301,"comment_content":"学了两年, 终于可以看懂Dijkstra算法了","like_count":2},{"had_liked":false,"id":57484,"user_name":"hughieyu","can_delete":false,"product_type":"c1","uid":1206690,"ip_address":"","ucode":"FC1A64B2BAB784","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/a2/c30ac459.jpg","comment_is_top":false,"comment_ctime":1546821718,"is_pvip":false,"replies":[{"id":"20708","content":"会自动更新位置的 相当于堆中更新一个节点的值","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1546825189,"ip_address":"","comment_id":57484,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10136756310","product_id":100017301,"comment_content":"更新vertex后是否要更新一下对象在优先级队列中的位置，否则会预期更晚弹出优先级队列，会影响查找的速度，除此之外还没有可能出现其他的问题","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435599,"discussion_content":"会自动更新位置的 相当于堆中更新一个节点的值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546825189,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57472,"user_name":"許敲敲","can_delete":false,"product_type":"c1","uid":1046681,"ip_address":"","ucode":"6486466820E7BF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/99/8e760987.jpg","comment_is_top":false,"comment_ctime":1546819829,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10136754421","product_id":100017301,"comment_content":"类似的python代码也会更新嘛，还不熟悉java的","like_count":2},{"had_liked":false,"id":306867,"user_name":"Dancer_aaa","can_delete":false,"product_type":"c1","uid":1371954,"ip_address":"","ucode":"B411D90711201A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epFRbF5IkEBkMQmMfaZRrQpvZtxF1emYS1pEICFb9AaM5k4QluSxLZEGsnLASprt317uTzmaNegCg/132","comment_is_top":false,"comment_ctime":1628756759,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5923724055","product_id":100017301,"comment_content":"可以把这个邻接表看成是一个二维数组来理解（仅概念上，实际上不是数组）。<br>这个二维数组的第一维表示的是有向有权图中的每一个顶点，假设图中共有v个顶点，那么adj的第一维就有长度v行。<br><br>二维数组的第二维表示每一个顶点可以直接到达（不经过其他中间顶点）的下一个顶点，比如1号顶点可以直接到达2号和3号顶点，那么就会存在adj[1][2]和adj[1][3]这两个元素。同时需要注意的是，在有向图中判断1号顶点是否能够直达2或3号顶点时，取决于是否存在由1号顶点出发，指向2号或3号的有向边存在。（这是在地图导航场景下，使用有向边的意义，即道路存在双向或单行道的区别。）<br><br>理解上面的概念后，再来区分邻接表和数组的区别。<br>这里使用邻接表，目的是不浪费那些不能直达的顶点之间的元素所占用的无用内存空间。由此导致的结果是，邻接表中，若1号顶点可以直达2号和3号顶点，那么adj[1]下所存的并非是adj[1][2]和adj[1][3]，而是adj[1][0]和adj[1][1]，只不过，其中的二维[0]和[1]中所存的对象中，包含了指名该顶点编号的自定义类型Edge。<br><br>不仅如此，Edge类型中也存储了它的前置直达顶点的编号以及从前置直达顶点到达本顶点的长度（边权数）。<br><br>通过addEdge()方法将完整的有向有权图添加到adj邻接表中。<br><br>最后，定义了一个Vertex类型，用来存储每一个顶点的路径长度，这个路径长度指的是由起始顶点开始经过若干个中转顶点（&gt;=0）到达本顶点的总路径长度（边权之和）。<br><br>这里先定义了一个PriorityQueue的自定义类型，该类型主要是实现一个小顶二叉堆的数据结构。由于在进行Dijkstra算法的过程中，会需要频繁对一组数据使用“取最小值” “删除元素” “更新排序”等操作，因此使用小顶二叉堆更为合适。<br><br>该PriorityQueue是以上文中定义的Vertex类型中的“起始顶点开始经过若干个中转顶点到达本顶点的总路径长度”作为比较数据进行排序的。具体的代码作者留给了读者来实现， 实际上就是以对象中的某个元素值来实现小顶堆的代码，忘记的同学可以看之前的章节，小顶堆的代码实现在这里不是重点，只需要知道我们要使用小顶堆的功能即可。<br><br>接下来是Dijkstra算法的核心部分，先了解一下算法的基本理念。<br>Dijkstra算法会从起始顶点开始，依次计算它能直达的每个顶点的最短路径长度（最短边权数），再进一步计算这些顶点与它们所能直达的每个顶点的最短路径长度，以此循环，直到找到目的顶点。需要注意的是，这里计算的所有顶点的最短路径长度，指的是从起始顶点开始到达该顶点的最短路径长度（中间可能经过多个中转顶点）。这也是每个顶点所对应的Vertex类型中的dist信息所存储的内容锁表示的含义。<br><br>随后将起始顶点本身的Vertex类型对象中的dist值设置成0（自己到自己的路径总是0），并加入到小顶堆中。<br><br>inqueue数组用来标记已经计算过最短路径值（Vertex类型对象中的dist值）并放入了小顶堆的Vertex顶点对象，以防重复放入小顶堆。<br><br>接下来进入while循环，正式遍历计算从起始顶点开始到达所有顶点的最短路径值，直到找到目标顶点（目的地），便不再遍历剩余的顶点。<br><br>在遍历循环中，由起始顶点开始，依次计算并更新后继直达顶点的最短路径值（Vertex类型对象中的dist值），随后将更新过的后继直达顶点所对应的Vertex类型对象放入小顶堆。我们可以称此时的起始顶点为当前扩展顶点或者说当前的计算基础顶点。记住，每一轮的遍历，都是将当前扩展顶点作为前驱顶点，来计算它的所有后继直达顶点的最短路径值。<br><br>第二轮遍历将会从小顶堆中取dist最小的那个Vertex顶点对象（也就是小顶堆的堆顶元素），并把它当做当前扩展顶点，来计算它的所有后继直达顶点的最短路径值。每次取出堆顶元素时，都会在小顶堆中删除该元素，这是因为，已经被作为扩展顶点使用过的顶点，就不再需要参与下一轮循环计算了。<br><br>在循环迭代过程中，可能存在某个扩展顶点的后继直达顶点已经被计算过最短路径的情况，此时重新计算了该后继直达顶点的最短路径后，不能将其重复放入小顶堆，而应该直接使用update()方法更新小顶堆中的排序（也就是所谓的做一次堆化）。代码中通过inqueue数组来判断某个后继直达顶点是否在之前的循环中已经被放入过小顶堆中。<br><br>最后，每个顶点在计算它的最短路径时，都会将它的前驱直达顶点存入predecessor数组，以便在找到目标顶点时，输出完整的最短路径节点。","like_count":1},{"had_liked":false,"id":284063,"user_name":"划船一哥","can_delete":false,"product_type":"c1","uid":1811010,"ip_address":"","ucode":"61539E491E86F5","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a2/42/4948f2b9.jpg","comment_is_top":false,"comment_ctime":1616054659,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5911021955","product_id":100017301,"comment_content":"翻译的例子得不到最优解：例如：a（9,8,1），b（3，2，1），c（2,1）","like_count":1},{"had_liked":false,"id":281300,"user_name":"邵帅","can_delete":false,"product_type":"c1","uid":1207488,"ip_address":"","ucode":"EB662C972CC248","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/gLC1Z8lYdWPHquZbJCf5FfIDgOJKiapygoyNrl4b5fkibyV2LBnCKV5BjRAYOhPGJxL425rIdSVnibTMEg012S9Pg/132","comment_is_top":false,"comment_ctime":1614681166,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5909648462","product_id":100017301,"comment_content":"我感觉这个算法的思想是，当前的最短路径可能产生最终的最短路径，所以每次都从当前的最短路径开始。","like_count":1},{"had_liked":false,"id":173157,"user_name":"注定非凡","can_delete":false,"product_type":"c1","uid":1113597,"ip_address":"","ucode":"80673056E131B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","comment_is_top":false,"comment_ctime":1579440918,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5874408214","product_id":100017301,"comment_content":"图的两种搜索算法，深度优先搜素和广度优先搜索。这两种算法主要是针对无权图的搜索算法。针对有权图，也就是图中的每条边都有一个权重，该如何计算两点之间的最短路径？最短路径算法（Shortest Path Algorithm）。<br><br>一：算法解析<br>\t最优问题包含三个：最短路线，最少用时，最少红绿灯。<br>\t1，解诀软件开发中的实际问题，最重要的一点就是建模，也就是将复杂的场景抽象成具体的数据结构。<br>\t2，图的表达能力强，可以将求解的最短路径问题转化为：在一个有向有权图中，求两个顶点间的最短路径。<br>\t3，要解决这个问题，有个非常经典的算法，最短路径算法，更准确的叫：单源最短路径算法（一个顶点到一个顶点）。提到最短路径算法，最出名的莫过于DijKstra算法。<br> <br><br>\t4，Dijkstra算法的时间复杂度：<br>\t\tO(E*log V)，E表示边的个数，V表示元素个数不会超过顶点的个数<br>\t5,Dijkstra最短路径算法，实际上最短路径算法还有很多，比如Bellford算法，Floyd算法等。<br>","like_count":1},{"had_liked":false,"id":129635,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1567177499,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5862144795","product_id":100017301,"comment_content":"说实话没感觉到dijkstra算法使用优先级队列的用处，，，","like_count":1,"discussions":[{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":88852,"discussion_content":"em 看老师的图 很生动了。。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576735344,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1939316,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/97/74/a933d664.jpg","nickname":"莜戏","note":"","ucode":"C3488A2BB44359","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345940,"discussion_content":"看图，栩栩如生","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611818981,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1030657,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ba/01/5ce8ce0b.jpg","nickname":"Leoorz","note":"","ucode":"8912628AD6ADE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295756,"discussion_content":"我认为优先级队列的用处在于，保证了某个点在出队之后，不会再出现另外一条到达该点的路径且路径长更短","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596334236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96371,"user_name":"小刚z","can_delete":false,"product_type":"c1","uid":1109323,"ip_address":"","ucode":"7453F096F6631C","user_header":"https://static001.geekbang.org/account/avatar/00/10/ed/4b/0ddfa9ad.jpg","comment_is_top":false,"comment_ctime":1558404936,"is_pvip":false,"replies":[{"id":"34674","content":"a0b0c0   -》 a1b0c0： a0-&gt;a1 其他的不变；<br>a0b0c0   -》 a0b1c0： b0-&gt;b1 其他的不变；<br>a0b0c0   -》 a0b0c1： c0-&gt;c1 其他的不变.<br><br>比a0b0c0第二小的数据肯定出现在这三个候选中。 <br>","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1558569425,"ip_address":"","comment_id":96371,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5853372232","product_id":100017301,"comment_content":"a0b0c0扩展后可以得到之后会得到三个组合,a1b0c0,a0b1c0,a0,b0,c1，请问一下这三个组合是怎么推导出来的","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450852,"discussion_content":"a0b0c0   -》 a1b0c0： a0-&amp;gt;a1 其他的不变；\na0b0c0   -》 a0b1c0： b0-&amp;gt;b1 其他的不变；\na0b0c0   -》 a0b0c1： c0-&amp;gt;c1 其他的不变.\n\n比a0b0c0第二小的数据肯定出现在这三个候选中。 \n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558569425,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":58799,"user_name":"zixuan","can_delete":false,"product_type":"c1","uid":1131300,"ip_address":"","ucode":"C72920DD05B074","user_header":"https://static001.geekbang.org/account/avatar/00/11/43/24/3f9f7c70.jpg","comment_is_top":false,"comment_ctime":1547195255,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5842162551","product_id":100017301,"comment_content":"想到个口水证明，不过首先需要说明下dijkstra不能用于负权图或正负混合权重的图，例如由a、b、c三个顶点构成的图：{Edge(a, b, -1), Edge(a, c, -2), Edge(b, c, -10)}, 按dijkstra算法会得出a到c的最短距离是-2，但实际是-11. 换句话说，通过把正权重取负来求最长路径是行不通的，最长路径(or 负权图的最短路径)似乎并没有高效的解法. 所以大的前提是所有权重&gt;=0.<br><br>接下来证明: PriorityQueue出队列的顶点顺序是所有顶点到单源点的最短路径按路径总权重从小到大排列的顺序. Base Case: 第1个出队列的是源点本身, 最短路径总权重=0为最小（这里就要求所有权重&gt;=0，否则base都不成立）. 假设第1, 2, ...n次出队列的顶点分别对应最短路径总权重最小的前n个顶点，那么第n+1个最短路径顶点自然就是在前n个顶点的所有邻接顶点集合中取更新后总距离离源点最小的那个，即堆顶元素. 假如排第n+1的顶点t不是堆顶元素的话，其最短路径的前驱顶点s必然不在已出队列顶点集合中(否则通过s找到的t就是对顶元素)，但又由于权重(s, t)&gt;0, 源点到s的最短距离必然是排前n+1的，则t必须是其前驱节点s，矛盾.  老师最后举的打分的例子初看上去和最短距离没太大关系，可能是指在这个基于历史状态下的单步迭代策略(DP?)使得全局最优上有点类似吧. ","like_count":1},{"had_liked":false,"id":57586,"user_name":"Geek_dddebb","can_delete":false,"product_type":"c1","uid":1252151,"ip_address":"","ucode":"50EFF36FC56D6E","user_header":"","comment_is_top":false,"comment_ctime":1546842604,"is_pvip":false,"replies":[{"id":"21851","content":"代码已经改正，你再看下？；）","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1547708854,"ip_address":"","comment_id":57586,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5841809900","product_id":100017301,"comment_content":"亲测更新vertex后对象在队列中的位置不变","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435654,"discussion_content":"代码已经改正，你再看下？；）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547708854,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1504705,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f5/c1/b92153c6.jpg","nickname":"Pisces","note":"","ucode":"B1E98AC36BDD0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284967,"discussion_content":"列出代码时，作者都不验证吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592702492,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57494,"user_name":"魏全运","can_delete":false,"product_type":"c1","uid":1090798,"ip_address":"","ucode":"3FED702C724E2A","user_header":"https://static001.geekbang.org/account/avatar/00/10/a4/ee/cffd8ee6.jpg","comment_is_top":false,"comment_ctime":1546822826,"is_pvip":false,"replies":[{"id":"20707","content":"有也可以 没有也可以的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1546825154,"ip_address":"","comment_id":57494,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5841790122","product_id":100017301,"comment_content":"vertex compareTo有问题吧，怎么没有相等的分支呀？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435605,"discussion_content":"有也可以 没有也可以的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546825154,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":355142,"user_name":"Shelter🐏","can_delete":false,"product_type":"c1","uid":1444484,"ip_address":"广东","ucode":"51CF7ABF62F243","user_header":"https://static001.geekbang.org/account/avatar/00/16/0a/84/12698aff.jpg","comment_is_top":false,"comment_ctime":1661134476,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661134476","product_id":100017301,"comment_content":"为什么每次拿最小的，这样最后就能得到最短路径：<br>-   有数学公式推导，比较复杂，可以自己看。http:&#47;&#47;www-quic.zhihu.com&#47;question&#47;57206374<br>-   交换论证 ：可以理解为，假设有多条可抵达路线，逐条论证，每条走一步，然后就看看哪条比较短，拿最短的那一条出来再走一步，如此类推。","like_count":0},{"had_liked":false,"id":344318,"user_name":"陌兮","can_delete":false,"product_type":"c1","uid":1415619,"ip_address":"","ucode":"00CE47CAECD5CD","user_header":"https://static001.geekbang.org/account/avatar/00/15/99/c3/e4f408d4.jpg","comment_is_top":false,"comment_ctime":1651465565,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1651465565","product_id":100017301,"comment_content":"以前也以为dijkstra是贪心算法，只晓得每次决策选择的是最优选择。现在才发现是动态规划，每次决策都是从以前最优的结果中选择的。","like_count":0},{"had_liked":false,"id":336860,"user_name":"Geek_0386e5","can_delete":false,"product_type":"c1","uid":2261626,"ip_address":"","ucode":"40AF296ED8CC3D","user_header":"","comment_is_top":false,"comment_ctime":1646403407,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1646403407","product_id":100017301,"comment_content":"Merge k Sorted Lists","like_count":0},{"had_liked":false,"id":335424,"user_name":"i_chase","can_delete":false,"product_type":"c1","uid":1795511,"ip_address":"","ucode":"09C41C863F4EA3","user_header":"https://static001.geekbang.org/account/avatar/00/1b/65/b7/058276dc.jpg","comment_is_top":false,"comment_ctime":1645514262,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1645514262","product_id":100017301,"comment_content":"优先队列的update操作怎么实现呢？","like_count":0},{"had_liked":false,"id":335147,"user_name":"恬毅","can_delete":false,"product_type":"c1","uid":1015240,"ip_address":"","ucode":"914ED16F3BE714","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/c8/e4727683.jpg","comment_is_top":false,"comment_ctime":1645360273,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645360273","product_id":100017301,"comment_content":"PriorityQueue没有update方法，要实现Dijkstra 算法，Java需要自己实现堆算法","like_count":0},{"had_liked":false,"id":334139,"user_name":"Lihoo","can_delete":false,"product_type":"c1","uid":2746186,"ip_address":"","ucode":"54B8F26B6D63C5","user_header":"https://static001.geekbang.org/account/avatar/00/29/e7/4a/8990a97a.jpg","comment_is_top":false,"comment_ctime":1644761878,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644761878","product_id":100017301,"comment_content":"while (!queue.isEmpty()) {    <br>        Vertex minVertex= queue.poll(); &#47;&#47; 取堆顶元素并删除    <br>        if (minVertex.id == t) break; &#47;&#47; 最短路径产生了<br><br>这里出队以后，inqueue对应的项要设为false吧？","like_count":0},{"had_liked":false,"id":322808,"user_name":"WSZ","can_delete":false,"product_type":"c1","uid":2103542,"ip_address":"","ucode":"AB092B48C52D47","user_header":"https://static001.geekbang.org/account/avatar/00/20/18/f6/db57fef1.jpg","comment_is_top":false,"comment_ctime":1637595659,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637595659","product_id":100017301,"comment_content":"我记得之前在那本c++黑皮书里说这个算法是贪心算法，难道是我记错了，看了老师这个，感觉是dp，利用小顶堆，多阶段决策最优","like_count":0},{"had_liked":false,"id":322710,"user_name":"Geek_5b2ab1","can_delete":false,"product_type":"c1","uid":2628460,"ip_address":"","ucode":"C1AF841A9F0B6C","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK9Yvy5STDw874VEEuPehIcONR9kEq7knIicUNuINU0ovf2ViabhFqiabZiaoXC5FqL89YDCxp3tBnFzA/132","comment_is_top":false,"comment_ctime":1637562130,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1637562130","product_id":100017301,"comment_content":"弱弱说一句，算法导论上，dijkstra算法时间复杂度是O(VlogV+E), 使用了斐波那契堆实现最小优先队列，每次 extract-min操作的摊还代价为O(logV)，每次 decrease-key操作的摊还代价为O(1)","like_count":0},{"had_liked":false,"id":317775,"user_name":"兔嘟嘟","can_delete":false,"product_type":"c1","uid":2028811,"ip_address":"","ucode":"5A9042B4C7670C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f5/0b/73628618.jpg","comment_is_top":false,"comment_ctime":1634958855,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634958855","product_id":100017301,"comment_content":"不知道老师这边有什么方法可以实现堆中的O(log n)更新，按照我的理解，堆由于并非完全有序结构，更新还是需要O(n)查找的，如果要实现所要求的复杂度，红黑树是个更好的选择:)。https:&#47;&#47;stackoverflow.com&#47;questions&#47;46996064&#47;how-to-update-elements-within-a-heap-priority-queue<br>在网上有另一种处理方式，就是不管重不重复，都加进去，然后出来一个顶点后，就将其标为取出过，那么后续相同顶点，都可以忽略掉，因为是重复的。","like_count":1},{"had_liked":false,"id":305610,"user_name":"Geek_842f07","can_delete":false,"product_type":"c1","uid":2698987,"ip_address":"","ucode":"ED772AF755FE7E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/WP4Ge8ABcINFkccKaNYKibicFnI0JAoojBBAUGrichNeRAgzm5RGbHG7GqYrFX3ELEzenuEbicQHJy2HZ72RxSOuMA/132","comment_is_top":false,"comment_ctime":1628069250,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628069250","product_id":100017301,"comment_content":"这里有使用c++ stl set来实现Dijkstra算法的代码https:&#47;&#47;www.geeksforgeeks.org&#47;dijkstras-shortest-path-algorithm-using-set-in-stl&#47;","like_count":0},{"had_liked":false,"id":304283,"user_name":"简单猫","can_delete":false,"product_type":"c1","uid":1866485,"ip_address":"","ucode":"EA027D4C344E25","user_header":"https://static001.geekbang.org/account/avatar/00/1c/7a/f5/54a5084b.jpg","comment_is_top":false,"comment_ctime":1627314123,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627314123","product_id":100017301,"comment_content":"课外题1。<br>首先一条路 a到b花费时间<br>距离  速度 红绿灯时间 堵车时间 这些来衡量权重<br>速度 距离 是常量 是不变的 可预估的<br>红绿灯时间-堵车时间 ，可以通过当前时间附近，通过该路的，其他车辆花费时间来做权重。<br>也就是说最开始可以我们可以默认每个红绿灯等待30秒，行车速度市区大概60公里每小时，就可以计算出最路线。<br>最开始的时候最短距离 和最快时间的解是固定的，随着大数据的统计 ，每天 某个时段 某条路，平均堵车多长时间， 平均时速多少。每条路的权重就会随之发生变化 最终获取最符合当地的最佳路线。<br><br>课外题2。<br>公交车 地铁 有固定的点。一样能转换成模型。先算出离目的地最近的站点。然后以这个站点为起点。街道也分为可驾车通过的有向边。还是只能步行的 有向边。分别根据对于权重算出策略性最优解","like_count":0},{"had_liked":false,"id":301729,"user_name":"han5i5j","can_delete":false,"product_type":"c1","uid":1338459,"ip_address":"","ucode":"9CBA2BE55A0983","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJDj05YqOKYPbKAxJvgDoOelKWDHISeoiaeGibkXbmVyyHMPGtz8EiauT9L7EI8nDzMzsn2hElNpcn8A/132","comment_is_top":false,"comment_ctime":1625823906,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1625823906","product_id":100017301,"comment_content":"扩展的策略是每个单词的翻译分别替换成下一个单词的翻译。比如 a0​b0​c0​ 扩展后，会得到三个组合，a1​b0​c0​、a0​b1​c0​、a0​b0​c1​。<br>请问一下，这个扩展规则没看懂，能不能举例说明一下，a0b1c0出列之后该怎么扩展？","like_count":0,"discussions":[{"author":{"id":1014665,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/89/34f2cbcc.jpg","nickname":"杨宇","note":"","ucode":"EB74DF6E269F03","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560526,"discussion_content":"图中有的，依然分别将每个单词替换为下一个翻译，即：a1b1c0, a0b2c0, a0b1c1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649381270,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294884,"user_name":"vv_test","can_delete":false,"product_type":"c1","uid":1685884,"ip_address":"","ucode":"1D164B2F034E2B","user_header":"https://static001.geekbang.org/account/avatar/00/19/b9/7c/afe6f1eb.jpg","comment_is_top":false,"comment_ctime":1622121689,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622121689","product_id":100017301,"comment_content":"感觉Floyd算法更容易用动态规则来理解(邻接矩阵)，跟 42 讲的 n 乘以 n 的矩阵 w[n][n] 相，只是有向图的走法并不一样。只要确定了矩阵的走法，就可以很容易的理解了。","like_count":0},{"had_liked":false,"id":292884,"user_name":"风","can_delete":false,"product_type":"c1","uid":1444483,"ip_address":"","ucode":"E1CE0825AAF805","user_header":"https://static001.geekbang.org/account/avatar/00/16/0a/83/f916f903.jpg","comment_is_top":false,"comment_ctime":1621052322,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621052322","product_id":100017301,"comment_content":"没有必要用inqueue数组，vertex数组里对应结点，如果dist值不为INT_MAX，那就说明 inqueue==true","like_count":0},{"had_liked":false,"id":289451,"user_name":"木木","can_delete":false,"product_type":"c1","uid":1486846,"ip_address":"","ucode":"2AD54B5B3F8298","user_header":"https://static001.geekbang.org/account/avatar/00/16/af/fe/e9127277.jpg","comment_is_top":false,"comment_ctime":1619016746,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619016746","product_id":100017301,"comment_content":"ip路由的问题和这个是一样的吧","like_count":0},{"had_liked":false,"id":280063,"user_name":"zt1106","can_delete":false,"product_type":"c1","uid":1120246,"ip_address":"","ucode":"8973D30EF9DE27","user_header":"https://static001.geekbang.org/account/avatar/00/11/17/f6/df7a9823.jpg","comment_is_top":false,"comment_ctime":1614068230,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614068230","product_id":100017301,"comment_content":"给的代码里，很多变量名一个字母，让人猜来猜去，浪费时间","like_count":0},{"had_liked":false,"id":279525,"user_name":"北极的大企鹅","can_delete":false,"product_type":"c1","uid":1045577,"ip_address":"","ucode":"8935346D08E109","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f4/49/2add4f6b.jpg","comment_is_top":false,"comment_ctime":1613811997,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613811997","product_id":100017301,"comment_content":"我的理解,先执行最大需要计算的,之后计算小量分支需要计算的.有种分治思想.<br>单词翻译的例子能看明白,就是说每个单词进行翻译后,是否符合这个句子原意,如果符合,则得分高,最终累计到一个句子中,分值最高的即最后翻译.","like_count":0},{"had_liked":false,"id":279059,"user_name":"king","can_delete":false,"product_type":"c1","uid":1100439,"ip_address":"","ucode":"FFC090D0EF1F80","user_header":"https://static001.geekbang.org/account/avatar/00/10/ca/97/5042c207.jpg","comment_is_top":false,"comment_ctime":1613578488,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613578488","product_id":100017301,"comment_content":"感觉这里关键要想清楚为啥使用优先级队列而不是普通队列。这里我说一下，假如不使用优先级队列的话，那么每次都要从它的前面可达顶点找到一个最小路径（不好实现），加上本身就是这个顶点的最短路径。另外看评论有说是动态规划，其实它不符合无后效性呀，一个顶点的最短距离会被后面改变的，如老师代码里面有update更新了","like_count":0},{"had_liked":false,"id":267017,"user_name":"云之崖","can_delete":false,"product_type":"c1","uid":1003366,"ip_address":"","ucode":"724C0614F40EC1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4f/66/1f8fccfb.jpg","comment_is_top":false,"comment_ctime":1607569884,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607569884","product_id":100017301,"comment_content":"翻译系统的问题，通过回溯算法实现了一遍，又通过大顶堆的方式实现了一遍，Dijkstra算法也通过自己实现小顶堆算法实现了一遍。现在别的不说，至少手写一个堆没啥难度了。","like_count":0},{"had_liked":false,"id":265793,"user_name":"hpyang","can_delete":false,"product_type":"c1","uid":1132808,"ip_address":"","ucode":"C64AC79566F7A6","user_header":"https://static001.geekbang.org/account/avatar/00/11/49/08/c4ff2dbf.jpg","comment_is_top":false,"comment_ctime":1607032546,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607032546","product_id":100017301,"comment_content":"请教老师，本文讲了最短路径规划，那么对于地图场景下，有两条出行轨迹，即都是由间隔记录的坐标点组成的一条轨迹，有什么好的方式能高效的计算两条轨迹相似度吗？","like_count":0},{"had_liked":false,"id":264578,"user_name":"拉布拉多","can_delete":false,"product_type":"c1","uid":1204353,"ip_address":"","ucode":"637A88D9F29F57","user_header":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","comment_is_top":false,"comment_ctime":1606529623,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606529623","product_id":100017301,"comment_content":"课后翻译题，能想到dijkstra算法基本成功一半。然后验证此算法确实能解决这个问题就已经成了60%。剩下的只是编码。","like_count":0},{"had_liked":false,"id":246799,"user_name":"Be_Young","can_delete":false,"product_type":"c1","uid":2044188,"ip_address":"","ucode":"ACDBB2DD99738A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bNQ1xdysiatMnMYpibXw70cpWPkuA2JXiaR0eDq7dia9oBic2z3SqFY84aRnEPH3QMgSklE6JSMZAPfKYukX6kPLoZQ/132","comment_is_top":false,"comment_ctime":1599479818,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1599479818","product_id":100017301,"comment_content":"太强了，能想到用小顶堆简直是天才，膜拜前辈d(ŐдŐ๑)。","like_count":0,"discussions":[{"author":{"id":2694205,"avatar":"https://static001.geekbang.org/account/avatar/00/29/1c/3d/76465ee4.jpg","nickname":"摘星","note":"","ucode":"55D8CAFC938F91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551259,"discussion_content":"这个还好吧..因为要找最小值 但寻找过程中不停加入新的值，很容易就想到了堆,不过老师数据结构肯定是很牛逼了，不然也不会是谷歌大佬","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644941567,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329914,"discussion_content":"同感觉。感觉王老师已经融汇贯通的感觉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606480933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230044,"user_name":"萤火之森","can_delete":false,"product_type":"c1","uid":1183966,"ip_address":"","ucode":"26791DC3000F3B","user_header":"https://static001.geekbang.org/account/avatar/00/12/10/de/dbf2abde.jpg","comment_is_top":false,"comment_ctime":1593246869,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1593246869","product_id":100017301,"comment_content":"想获取获取到达终点的所有路径，遇到如下问题：<br>路径中的一条路下面存在许多岔路节点（如2^32）,而且该路还不是正确路径，如何过滤掉无用的深度遍历，除了用距离估值（路径很短的情况下 估值差别不大）","like_count":0},{"had_liked":false,"id":224067,"user_name":"cool","can_delete":false,"product_type":"c1","uid":1383620,"ip_address":"","ucode":"254220D6E2DAE8","user_header":"https://static001.geekbang.org/account/avatar/00/15/1c/c4/3e593863.jpg","comment_is_top":false,"comment_ctime":1591264523,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591264523","product_id":100017301,"comment_content":"上面的代码有问题吗？<br>if (inqueue[nextVertex.id] == true) <br>{ queue.update(nextVertex); &#47;&#47; 更新队列中的dist值 } <br>else <br>{ queue.add(nextVertex); inqueue[nextVertex.id] = true; }","like_count":0},{"had_liked":false,"id":222721,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1590899091,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1590899091","product_id":100017301,"comment_content":"最短路径，或者说是 Dijkstra 算法，应该算是熟悉的陌生人了。熟悉是因为在大学阶段就曾经学过，陌生是因为我自己没有办法完整的写出来整个算法。<br><br>用于 Dijkstra 算法的数据结构比较容易理解，有向带权图，用 LinkedList 来存储邻接表，每条边都有起点、终点和权值，用 Vertex 数组来存储最短路径，每个 Vertex 顶点都存有有最短距离。<br><br>算法里面比较麻烦的部分应该还是 PriorityQueue 的实现（小顶堆）和根据当时的最短路径不断更新。<br><br>简单的写了一下文中代码“留给读者实现的部分”，也不知道对不对。<br><br>其实 Dijkstra 算法的图示还是比较容易看懂的。如果考虑到最少时间和最少红绿灯，那么就需要改变权重值的算法，其中最少红绿灯是比较容易算的（如果不考虑无红绿灯的路口），而最少时间需要考虑的因素就要多一些，包括红绿灯、限速和拥堵状况等。<br><br>导航 APP 中的算法，应该更加复杂，一方面要定时更新（1分钟？），另一方面还要考虑如果把分流平衡问题。<br><br>总结引申里面提到的翻译系统，算是最短路径算法的一个引申应用，比较开眼界。但是现在的翻译系统似乎又不是这样实现的，更多的依靠机器学习之类的。<br><br>顺着留言去看了 LeetCode 743 Network Delay Time，不过也就是看看而已。","like_count":0},{"had_liked":false,"id":222203,"user_name":"爱吃胡萝卜","can_delete":false,"product_type":"c1","uid":1459413,"ip_address":"","ucode":"35FCF84D1E04C5","user_header":"https://static001.geekbang.org/account/avatar/00/16/44/d5/ca522e83.jpg","comment_is_top":false,"comment_ctime":1590716070,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1590716070","product_id":100017301,"comment_content":"Dijkstra 看起来像是贪心算法 ，貌似无法求解出最优解","like_count":0,"discussions":[{"author":{"id":2694205,"avatar":"https://static001.geekbang.org/account/avatar/00/29/1c/3d/76465ee4.jpg","nickname":"摘星","note":"","ucode":"55D8CAFC938F91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551260,"discussion_content":"是动态规划哦，他不是选择了最小值就一直走下去，它还要考虑额外的权值。他可以求得最优解，不然怎么可能叫做最短路径呢 对吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644941630,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":201975,"user_name":"蜗牛","can_delete":false,"product_type":"c1","uid":1086220,"ip_address":"","ucode":"01CC18F12E556D","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/0c/0a6a0d5e.jpg","comment_is_top":false,"comment_ctime":1585883775,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585883775","product_id":100017301,"comment_content":"不同的交通工具，不同的一套数据。只是他们共享很多顶点，是否可行","like_count":0},{"had_liked":false,"id":198528,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1585455348,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585455348","product_id":100017301,"comment_content":"思考题1，通过某条路的时间，理论计算，路的长度&#47;所用交通工具的平均速度，如果有实时跟踪的话，可以跟踪每种交通工具，计算交通工具从进入该路段时间到离开该路段时间的差值，来得到通过的时间，然后通过大量的跟踪，来获得该交通工具通过该路段的平均时间。<br>思考题2，混合地铁、公交、步行后，可以在地图的每条路段中，对这三种工具依据其快捷程度以及是否可通行等特征标注不同的权重，运用最短路径算法时，用权重来代替路径的长度，在判断边的权重时，就取这三者中权重最小（或最大）的作为边的权重，同时记录下该权重所对应的交通工具。这样就能得到混合三种交通工具后的最短路径。<br>","like_count":0},{"had_liked":false,"id":192738,"user_name":"yuan","can_delete":false,"product_type":"c1","uid":1207302,"ip_address":"","ucode":"EA3D0573478EC7","user_header":"https://static001.geekbang.org/account/avatar/00/12/6c/06/2ac17d5a.jpg","comment_is_top":false,"comment_ctime":1584870352,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1584870352","product_id":100017301,"comment_content":"请问时间复杂度为什么不是  O(V*E*logV)？","like_count":0,"discussions":[{"author":{"id":1268797,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5c/3d/e8325811.jpg","nickname":"对白","note":"","ucode":"3183E5ADBC794B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300390,"discussion_content":"因为E(0)xlogV+E(1)xlogV+E(2)xlogV+...E(v-1)xlogv=ElogV，相当于while循环已经执行过了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598077677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263977,"discussion_content":"每条边只访问一次，就是E。 对于每条边修改dist的时间复杂度是logV。所以就是O(ElogV)，Dij算法优秀的地方就是它的最差时间复杂度能保证O(ElogV)，稀疏图采用临adjlist表示，最短路径算法效率还不错。但限制是不能使用到具有负权重的图中。对此可以采用bellman ford算法（不能有负环）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589275324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180132,"user_name":"czriven","can_delete":false,"product_type":"c1","uid":1116737,"ip_address":"","ucode":"112CDBF6D0219A","user_header":"https://static001.geekbang.org/account/avatar/00/11/0a/41/19018754.jpg","comment_is_top":false,"comment_ctime":1582194374,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582194374","product_id":100017301,"comment_content":"在计算最短时间的出行路线中，如何获得通过某条路的时间呢？这个题目很有意思，我之前面试的时候也被问到过，你可以思考看看。----这题有个巧妙地思路，还请看完给予点评是否可行，1  首先获得总的起点终点的时间（a0---b0）time1;   2  这条路线的的起点和终点暂定为（a1 ----b1）,然后算出a0-----b1的时间time2；3   算出a1----b0这条路线的时间time3； 4  最后这条路线的时间就是： time2+time3-time1","like_count":0},{"had_liked":false,"id":177968,"user_name":"Merlin","can_delete":false,"product_type":"c1","uid":1804229,"ip_address":"","ucode":"5D21F59EC5C9DA","user_header":"","comment_is_top":false,"comment_ctime":1581563569,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581563569","product_id":100017301,"comment_content":"我觉得“举个例子”，是让我这种小菜鸡最容易理解的方法","like_count":0},{"had_liked":false,"id":176715,"user_name":"短迪大魔王","can_delete":false,"product_type":"c1","uid":1236079,"ip_address":"","ucode":"37E8117E0495B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/dc/6f/5d86dbe9.jpg","comment_is_top":false,"comment_ctime":1581147617,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581147617","product_id":100017301,"comment_content":"老师说的这个翻译问题，现在的不管是lstm还是transormer系列的模型的编码整个句子都用到了beamsearch，这个就是考虑了工程上给出的迪杰斯特拉算法，beam一般设置2到4，每一次的结果都是这样，然后取得最后的最优结果，只不过概率是连乘，避免了贪心造成局部最优，翻译效果显著提升","like_count":0},{"had_liked":false,"id":168033,"user_name":"book尾汁","can_delete":false,"product_type":"c1","uid":1446375,"ip_address":"","ucode":"AE2B8DFC643ACC","user_header":"https://static001.geekbang.org/account/avatar/00/16/11/e7/044a9a6c.jpg","comment_is_top":false,"comment_ctime":1577981293,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1577981293","product_id":100017301,"comment_content":"课后思考题，计算最短时间要根据红绿灯、路况、限速等因素算出时间，感觉这个需要ai来算吧,历史上某条路某个时间的堵车几率，是否有突发时间，平均通行时间等。<br>2.如果是公交出行的话，公交路过的站点就是有限的，可以找出这些的顶点之间的最短路径。如果多种出行方式，可以以时间为权重，找出时间比较少的几种方式，然后根据是否少换乘、步行距离、价格等推荐给用户","like_count":0},{"had_liked":false,"id":166754,"user_name":"子夜2104","can_delete":false,"product_type":"c1","uid":1070286,"ip_address":"","ucode":"C4FF54AEA6002F","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/ce/92029d2f.jpg","comment_is_top":false,"comment_ctime":1577587798,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577587798","product_id":100017301,"comment_content":"文中的优先队列，没有实现更新操作，我自己写了一个，供大家参考：<br><br>        &#47;&#47;存储顶点的索引<br>        int[] indexs;<br><br>&#47;&#47;只有出现了更小的值，才会更新，所以只需要从当前位置向上堆化即可<br>        public void update(Vertex vertex) {<br><br>            &#47;&#47;根据顶点id获取索引<br>            int i = indexs[vertex.id];<br>            while (i &#47; 2 &gt; 0 &amp;&amp; cmp(nodes[i], nodes[i &#47; 2]) &lt; 0) {<br>                swap(nodes, i &#47; 2, i);<br>                &#47;&#47;更新索引<br>                indexs[nodes[i].id] = i;<br>                indexs[nodes[i &#47; 2].id] = i &#47; 2;<br>                i = i &#47; 2;<br>            }<br><br>        }<br><br><br>在poll()操作和add()操作中也同理跟新indexs","like_count":0},{"had_liked":false,"id":153272,"user_name":"标签","can_delete":false,"product_type":"c1","uid":1235287,"ip_address":"","ucode":"38441CF5571B82","user_header":"https://static001.geekbang.org/account/avatar/00/12/d9/57/7848fd65.jpg","comment_is_top":false,"comment_ctime":1574210138,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574210138","product_id":100017301,"comment_content":"老师，思考题第二题有没有解题思路啊？  我看了全部评论，没有满意的答案","like_count":0},{"had_liked":false,"id":145013,"user_name":"三年过后","can_delete":false,"product_type":"c1","uid":1283157,"ip_address":"","ucode":"5E9106C5F11BED","user_header":"https://static001.geekbang.org/account/avatar/00/13/94/55/afc64956.jpg","comment_is_top":false,"comment_ctime":1572160072,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572160072","product_id":100017301,"comment_content":"public Vertex poll(){<br>\t\t\t--count;<br>\t\t\treturn nodes[1];&#47;&#47;返回堆顶最小元素<br>\t\t}<br>\t\tpublic void add(Vertex v){<br>\t\t\t++count;<br>\t\t\tnodes[count] = v;<br>\t\t\theapify(count);&#47;&#47;堆化<br>\t\t}<br>\t\t&#47;&#47;更新dist后，并且从下往上堆化，重新符合堆的定义。时间复杂度O(logn)。<br>\t\tpublic void update(Vertex v){<br>\t\t\tVertex vertex = nodes[v.id];<br>\t\t\tvertex.dist = v.dist;&#47;&#47;更新值<br>\t\t\theapify(v.id);&#47;&#47;堆化，自下而上，维护小顶堆<br>\t\t}<br>\t\tpublic boolean isEmpty(){<br>\t\t\tif(count ==0) return true;<br>\t\t\treturn false;<br>\t\t}<br>\t\tprivate void heapify(int i) {<br>\t\t\twhile(true){<br>\t\t\t\tif(i&#47;2 &gt; 0){<br>\t\t\t\t\tVertex vertex = nodes[i];<br>\t\t\t\t\tVertex parent = nodes[i&#47;2];&#47;&#47;父节点<br>\t\t\t\t\tif(vertex.dist &lt; parent.dist){&#47;&#47;交换节点<br>\t\t\t\t\t\tVertex tmp = nodes[i];<br>\t\t\t\t\t\tnodes[i] = nodes[i&#47;2];<br>\t\t\t\t\t\tnodes[i&#47;2] = tmp;<br>\t\t\t\t\t}<br>\t\t\t\t\ti = i&#47;2;&#47;&#47;节点指向父类节点<br>\t\t\t\t}<br>\t\t\t}<br>\t\t}","like_count":0},{"had_liked":false,"id":130662,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1567503490,"is_pvip":false,"replies":[{"id":"48963","content":"好像有讲到","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1567549646,"ip_address":"","comment_id":130662,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1567503490","product_id":100017301,"comment_content":"在图的搜索算法那一节只是提到一句广度优先搜索算法的结果是最短路径，并没有说原因😂","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466054,"discussion_content":"好像有讲到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567549646,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":88851,"discussion_content":"em，bfs算法 对于 权重为1的 、可以视为无权图的操作 而得的确实是最短路径；\n你考虑下 visited 数组的作用？\n因为是 由近及远 、层层向外的搜索，所以某顶点 最先被访问的肯定是最小的啊。。visited 就是为了防止 被错误修改 而生的。。。\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576735293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1004092,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","nickname":"张三","note":"","ucode":"1155528FAE1546","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7529,"discussion_content":"我知道广度优先是层层往外推进的，可是不能说明这个是最短路径吧。如果结合权重的话，会更新到达某个已经访问过的顶点的最小距离，这种确实是最短路径。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567557753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1004092,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","nickname":"张三","note":"","ucode":"1155528FAE1546","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7527,"discussion_content":"只提到一句：“实际上，这样求得的路径就是从s到t的最短路径”。但是没有解释","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567557451,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129776,"user_name":"i 星星","can_delete":false,"product_type":"c1","uid":1178850,"ip_address":"","ucode":"59611338A751E3","user_header":"https://static001.geekbang.org/account/avatar/00/11/fc/e2/3d2c57aa.jpg","comment_is_top":false,"comment_ctime":1567246906,"is_pvip":false,"replies":[{"id":"48496","content":"😅，这个需求就不是最短路径问题了","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1567379101,"ip_address":"","comment_id":129776,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1567246906","product_id":100017301,"comment_content":"老师，如果这个要是取权重最大该怎么设计呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465642,"discussion_content":"😅，这个需求就不是最短路径问题了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567379101,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2760780,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKghO4kJwQ5ccuBA2Yox1WlZmq0JUICpNAsgYlOHX0wHGv48xVRKSvF9a6Eic5l2UOjFjnvTnsibibiaw/132","nickname":"Geek_94045a","note":"","ucode":"B8F23BA9D1411B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530931,"discussion_content":"灵魂拷问 哈哈 写个文章真不容易 这十八般刁难 哈哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637169854,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128310,"user_name":"美美","can_delete":false,"product_type":"c1","uid":1148422,"ip_address":"","ucode":"44CC95C45AF345","user_header":"https://static001.geekbang.org/account/avatar/00/11/86/06/72b01bb7.jpg","comment_is_top":false,"comment_ctime":1566870173,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1566870173","product_id":100017301,"comment_content":"思考题中，计算最短时间的，如果考虑道路情况时动态变化的话，就不能使用Dijkstra算法了，Dijkstra可以看做是动态规划，但是道路情况时动态变换的（根据时间），该问题是不满足无后效性的，所以不能单纯的使用Dijkstra算法。","like_count":0,"discussions":[{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":88857,"discussion_content":"无后效性 和 这个没关系吧。。\n不过 做决策时，因为 每个后续阶段的不确定性，确实不好做","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576735587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119258,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1564544678,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564544678","product_id":100017301,"comment_content":"思考题2<br>地铁，公交和步行，就是三类边，这三类边的类型不同，步行可以从任一点到任一点，只是效率有点低，地铁和公交都是指定点到指定点有效而且有时间限制。最短路径就以这三类边消耗的时间和等待时间来找。","like_count":0},{"had_liked":false,"id":119255,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1564544392,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564544392","product_id":100017301,"comment_content":"思考题1 通过某条路的时间和距离有关，车流量和路的宽度有关。距离和路宽是一个固定的变量，假设可以查到，动态的因素就只有车流量了，车流量又和物理位置和时间有关，所以可以以距离，路宽，位置和时间建立一个简单线性模型来估算。","like_count":0},{"had_liked":false,"id":119199,"user_name":"若海","can_delete":false,"product_type":"c1","uid":1160841,"ip_address":"","ucode":"FDE85E407C3A40","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83epkkPP8hRHUliaqb5p1TyYZFVQlKVKrgmDO86TVjVZzL9OTCSEIwceG21jqJcib3bOjDjAkG2nvqiceA/132","comment_is_top":false,"comment_ctime":1564536599,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564536599","product_id":100017301,"comment_content":"通过某条路的时间必然是动态变化的，这个变化来自当前时刻的一段时间内，正在或已经通过该路线的车辆通行平均时间（或某种算法时间），当然还会结合一些其他因素。","like_count":0},{"had_liked":false,"id":118605,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1564395058,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564395058","product_id":100017301,"comment_content":"Dijkstar这个算法实现我觉得就是贪心算法，怎么说成了动态规划呢，每一次取小顶堆的最小路径，每一次都是达到局部最优解。那就是贪心了","like_count":0},{"had_liked":false,"id":111734,"user_name":"mike","can_delete":false,"product_type":"c1","uid":1326662,"ip_address":"","ucode":"AB330E7B88EF1C","user_header":"https://static001.geekbang.org/account/avatar/00/14/3e/46/0b888d5a.jpg","comment_is_top":false,"comment_ctime":1562591816,"is_pvip":false,"replies":[{"id":"40679","content":"已经出队的，就不会被重新update了的。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1562631910,"ip_address":"","comment_id":111734,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562591816","product_id":100017301,"comment_content":"如果构造的图中有环，是否存在inqueue标记已入队的顶点需要update dist时，其实该顶点已经被弹出过队列了？此时不就没法重新update了吗，而只能重新入队？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457431,"discussion_content":"已经出队的，就不会被重新update了的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562631910,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109663,"user_name":"jm3640","can_delete":false,"product_type":"c1","uid":1558393,"ip_address":"","ucode":"ED2E78AC6F669B","user_header":"https://static001.geekbang.org/account/avatar/00/17/c7/79/657c05e7.jpg","comment_is_top":false,"comment_ctime":1562073708,"is_pvip":false,"replies":[{"id":"39744","content":"你这个a b是啥啊","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1562112479,"ip_address":"","comment_id":109663,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562073708","product_id":100017301,"comment_content":"独立事件概率想不明白.假如样本总数是2，一个同时包含A和B 另一个不包含A和B 那直接算样本同时包含A和B的概率是1&#47;2。独立概率相乘就是1&#47;2 * 1&#47;2 = 1&#47;4。请问我哪里理解错了","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456502,"discussion_content":"你这个a b是啥啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562112479,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104522,"user_name":"王楚然","can_delete":false,"product_type":"c1","uid":1238608,"ip_address":"","ucode":"E0C8184C34908E","user_header":"https://static001.geekbang.org/account/avatar/00/12/e6/50/656a0012.jpg","comment_is_top":false,"comment_ctime":1560772198,"is_pvip":false,"replies":[{"id":"38004","content":"你的感觉是没错的！👍","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1560899997,"ip_address":"","comment_id":104522,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560772198","product_id":100017301,"comment_content":"总感觉最短路径好像很符合动态规划的问题模型呢？跟djkstra算法有什么联系吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454307,"discussion_content":"你的感觉是没错的！👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560899997,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99300,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1559188231,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559188231","product_id":100017301,"comment_content":"思考题1：通过某条路的时间应该和该条道路上的流量、当前车辆数有关，当前车辆数&#47;流量就是通过时间<br>思考题2：混合出行，就是两个顶点之间有多条边，每条边的权重不一样","like_count":0},{"had_liked":false,"id":99284,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1559186272,"is_pvip":false,"replies":[{"id":"36273","content":"没有的，但是会重复计算啊","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1559612717,"ip_address":"","comment_id":99284,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1559186272","product_id":100017301,"comment_content":"“inqueue 数组是为了避免将一个顶点多次添加到优先级队列”，如果将一个顶点多次添加到优先级队列中，对最后的结果也应该没有吧？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452048,"discussion_content":"没有的，但是会重复计算啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559612717,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1326662,"avatar":"https://static001.geekbang.org/account/avatar/00/14/3e/46/0b888d5a.jpg","nickname":"mike","note":"","ucode":"AB330E7B88EF1C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1380,"discussion_content":"如果图中有环，有可能存在inqueue标记已入队，但实际已经被弹出的情况吧，这种情况要重新入队？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1562591476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98345,"user_name":"任重道远","can_delete":false,"product_type":"c1","uid":1325715,"ip_address":"","ucode":"BDA98B670E70D7","user_header":"https://static001.geekbang.org/account/avatar/00/14/3a/93/2d4f2988.jpg","comment_is_top":false,"comment_ctime":1558963563,"is_pvip":false,"replies":[{"id":"35857","content":"可以看下我的这篇文章：<br>https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;t8z4KQMrTrR3NljtWJm2zg","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1559352333,"ip_address":"","comment_id":98345,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1558963563","product_id":100017301,"comment_content":"学习算法有什么技巧吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451651,"discussion_content":"可以看下我的这篇文章：\nhttps://mp.weixin.qq.com/s/t8z4KQMrTrR3NljtWJm2zg","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559352333,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83849,"user_name":"waycon","can_delete":false,"product_type":"c1","uid":1243136,"ip_address":"","ucode":"01275A96932171","user_header":"https://static001.geekbang.org/account/avatar/00/12/f8/00/3ab82a1d.jpg","comment_is_top":false,"comment_ctime":1554724121,"is_pvip":false,"replies":[{"id":"31019","content":"可以去看下堆那节课的代码实现，因为我们从下标1开始存数据的。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1555381625,"ip_address":"","comment_id":83849,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1554724121","product_id":100017301,"comment_content":"老师，请问优先级队列中的代码第6行为什么nodes数组大小要v+1个","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446162,"discussion_content":"可以去看下堆那节课的代码实现，因为我们从下标1开始存数据的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555381625,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1206187,"avatar":"https://static001.geekbang.org/account/avatar/00/12/67/ab/fcf0cec4.jpg","nickname":"寒光","note":"","ucode":"061BE413595F21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301930,"discussion_content":"从一开始，比较方便，否则计算父节点非常麻烦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598710094,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78866,"user_name":"juguya","can_delete":false,"product_type":"c1","uid":1046407,"ip_address":"","ucode":"4879A160C424E8","user_header":"","comment_is_top":false,"comment_ctime":1553263828,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1553263828","product_id":100017301,"comment_content":"我理解，这里使用小顶堆是为了快速退出。使用队列也可以达到目标，但是会走完整个while循环","like_count":0,"discussions":[{"author":{"id":1206187,"avatar":"https://static001.geekbang.org/account/avatar/00/12/67/ab/fcf0cec4.jpg","nickname":"寒光","note":"","ucode":"061BE413595F21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301927,"discussion_content":"用小顶堆也会走完所有的，看你的图怎么构建。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598710017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64586,"user_name":"Geek_fbe6fe","can_delete":false,"product_type":"c1","uid":1250069,"ip_address":"","ucode":"E69AD55364C93E","user_header":"https://static001.geekbang.org/account/avatar/00/13/13/15/5dabb390.jpg","comment_is_top":false,"comment_ctime":1548830315,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548830315","product_id":100017301,"comment_content":"老师，我按照您的代码尝试了，发现predecessor 好像不正确是不是应该这样判断<br>\t\t\t\tif inqueue[nextVertex.Id] == true {<br>\t\t\t\t\tqueue.AdjustHeap(queue.count)<br>\t\t\t\t} else {<br>\t\t\t\t\tpredecessor[nextVertex.Id] = minVertex.Id<br>\t\t\t\t\tqueue.InsertHeap(nextVertex)<br>\t\t\t\t\tinqueue[nextVertex.Id] = true<br>\t\t\t\t}<br>应该不能走回头路吧，回头路的不能进predecessor吧？","like_count":0},{"had_liked":false,"id":64569,"user_name":"左瞳","can_delete":false,"product_type":"c1","uid":1206589,"ip_address":"","ucode":"B262A3E99C8605","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/3d/3cfb9b87.jpg","comment_is_top":false,"comment_ctime":1548825558,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548825558","product_id":100017301,"comment_content":"我怎么感觉得到的不是最优解？","like_count":0},{"had_liked":false,"id":64541,"user_name":"ZX","can_delete":false,"product_type":"c1","uid":1235583,"ip_address":"","ucode":"0D2622FE6D1774","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/7f/8069035d.jpg","comment_is_top":false,"comment_ctime":1548817642,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548817642","product_id":100017301,"comment_content":"我用js写了一次<br><br>&#47;**<br> * dijkstra是单源最短路径搜索，就是一个点到另一个点的路径<br> * 1.维护一个2维数组-邻接矩阵，来表示点与点之间的关系<br> * 2.维护一个数组，是一个点到其余几个点的最短路径<br> * 3.每次找当前可达的最短路径，确定相邻的最短长度，然后将值更新到最短路径数组里面<br> *&#47;<br><br>&#47;**<br> * 直接输出第一个点到后面所有点的最短路径<br> * @param {邻接矩阵} arr <br> *&#47;<br>function dijkstra (arr) {<br>  const dist = arr[0]<br>  const predecessor = [0]<br>  const queue = [{ value: dist, index: 0 }]<br><br>  while (queue.length) {<br>    const temp = queue.pop()<br>    const p = temp.value<br>    const curIndex = temp.index<br>    let min = { value: Infinity, index: -1 }<br><br>    p.forEach((value, index) =&gt; {<br>      if (typeof value !== &#39;undefined&#39;) {<br>        if (value &lt; min.value) min = { value, index }<br><br>        const curValue = dist[curIndex] + value<br>        if (curValue &lt; dist[index]) {<br>          dist[index] = curValue<br>          predecessor[index] = curIndex<br>        }<br>      }<br>    })<br><br>    if (min.index !== -1) queue.push({ value: arr[min.index], index: min.index })<br>  }<br><br>  return { dist, predecessor}<br>}<br>","like_count":0},{"had_liked":false,"id":63331,"user_name":"李建轰","can_delete":false,"product_type":"c1","uid":1139732,"ip_address":"","ucode":"E5A68028AA29CD","user_header":"https://static001.geekbang.org/account/avatar/00/11/64/14/c696ff63.jpg","comment_is_top":false,"comment_ctime":1548325373,"is_pvip":false,"replies":[{"id":"22472","content":"可以这么理解的：）","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1548404534,"ip_address":"","comment_id":63331,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1548325373","product_id":100017301,"comment_content":" 老师～请教一下，用小顶堆是因为贪心吗？<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437552,"discussion_content":"可以这么理解的：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548404534,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1206187,"avatar":"https://static001.geekbang.org/account/avatar/00/12/67/ab/fcf0cec4.jpg","nickname":"寒光","note":"","ucode":"061BE413595F21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301925,"discussion_content":"我没有觉得用小顶堆有什么好处，即便当前最优，也不能保证接下来最优，还是要考察完所有的可达路径，最后才能得到结果。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598709846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":59328,"user_name":"Alexis何春光","can_delete":false,"product_type":"c1","uid":1181149,"ip_address":"","ucode":"614570FAE3B56A","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/dd/b201cf13.jpg","comment_is_top":false,"comment_ctime":1547351585,"is_pvip":false,"replies":[{"id":"21865","content":"也可以这么说：）","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1547710331,"ip_address":"","comment_id":59328,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1547351585","product_id":100017301,"comment_content":"Dijkstra算一种动态规划算法吗","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436328,"discussion_content":"也可以这么说：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547710331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":58397,"user_name":"想当上帝的司机","can_delete":false,"product_type":"c1","uid":1239378,"ip_address":"","ucode":"D8251388854911","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/52/f07e9001.jpg","comment_is_top":false,"comment_ctime":1547052337,"is_pvip":false,"replies":[{"id":"21056","content":"我测试过的 我再多找个数据测试一下","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1547085555,"ip_address":"","comment_id":58397,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1547052337","product_id":100017301,"comment_content":"if (inqueue[nextVertex.id]==false)&#47;&#47;加了这个判断的话，就不会走2了，因为在走1的时候2已经进入inqueue了，我在本地试的是去掉这个条件结果是对的，不知道是不是语言的原因，我是用gonlang写的，优先级队列是网上找的一个插件，老师你本地跑是成功的吗","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436046,"discussion_content":"我测试过的 我再多找个数据测试一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547085555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":58067,"user_name":"五岳寻仙","can_delete":false,"product_type":"c1","uid":1247467,"ip_address":"","ucode":"88A46A4E1832CE","user_header":"https://static001.geekbang.org/account/avatar/00/13/08/eb/594e9e6c.jpg","comment_is_top":false,"comment_ctime":1546989838,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1546989838","product_id":100017301,"comment_content":"@Liam 有问到 Dkijstra 算法是否是贪心算法，求得的解是否是全局最优解。<br><br>答案是：它不是贪心算法，事实上它是动态规划算法，求得的解全局最优解。<br><br>这个算法很有名，网上有很多帖子，具体可以百度或谷歌。","like_count":0,"discussions":[{"author":{"id":1336951,"avatar":"https://static001.geekbang.org/account/avatar/00/14/66/77/194ba21d.jpg","nickname":"lzh","note":"","ucode":"C3D83DF4230109","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":827,"discussion_content":"是贪心，算法导论有证明，说它可以理解为动态规划，是因为多源最短路径（Floyd算法）由动态规划解得，自然也包含了单源最短路径情况，即djkstra算法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562080229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57928,"user_name":"成楠Peter","can_delete":false,"product_type":"c1","uid":1252977,"ip_address":"","ucode":"4D13E7368D8CF2","user_header":"https://static001.geekbang.org/account/avatar/00/13/1e/71/9dcbe6c4.jpg","comment_is_top":false,"comment_ctime":1546943262,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1546943262","product_id":100017301,"comment_content":"翻译那个例子没看懂。。。","like_count":0,"discussions":[{"author":{"id":1811010,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a2/42/4948f2b9.jpg","nickname":"划船一哥","note":"","ucode":"61539E491E86F5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358813,"discussion_content":"那个例子得不到最优解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616054698,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57718,"user_name":"纯洁的憎恶","can_delete":false,"product_type":"c1","uid":1130512,"ip_address":"","ucode":"5E9757DE6F45DF","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/10/b6bf3c3c.jpg","comment_is_top":false,"comment_ctime":1546874446,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1546874446","product_id":100017301,"comment_content":"思考题好发散啊…我也开开脑洞吧。<br><br>1.可考虑的因素有很多，在此补充一点：如果使用我的导航app用户很多，那么就有可能掌握每条道路通行车辆的实时速度、汽车数量，于是就可以结合道路长度比较精确的计算出当前通行时间。<br><br>2.公交和地铁都有固定线路，与开车、步行情境下的路线有很大不同。如果只考虑公交，可以简化问题为只保留公交车站为顶点，站与站之间为边的有向图即可。但如果把公交和步行混合起来就复杂了，也行可以考虑公交线路覆盖区域，以车站为顶点、站与站连线为边、边的通勤时间为权重，覆盖不到的区域以岔路为顶点、道路为边、步行通勤时间为权重，构建有向图。","like_count":0},{"had_liked":false,"id":57643,"user_name":"纯洁的憎恶","can_delete":false,"product_type":"c1","uid":1130512,"ip_address":"","ucode":"5E9757DE6F45DF","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/10/b6bf3c3c.jpg","comment_is_top":false,"comment_ctime":1546857237,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1546857237","product_id":100017301,"comment_content":"回顾了一下31讲，广度优先算法的过程不难理解，但是广度优先算法遍历无权图中一点s到另一点t的路径，就是它的最短路径，是如何证明的呢？","like_count":0},{"had_liked":false,"id":57555,"user_name":"你有资格吗？","can_delete":false,"product_type":"c1","uid":1233534,"ip_address":"","ucode":"4758C5A190BABB","user_header":"https://static001.geekbang.org/account/avatar/00/12/d2/7e/bd8c372a.jpg","comment_is_top":false,"comment_ctime":1546832698,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546832698","product_id":100017301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":57535,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1546830406,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546830406","product_id":100017301,"comment_content":"1. 代码中inqueue声明是 inQueue<br>2. 感觉有点类似 暴力搜索判断,起始点和截止点的之间的所有结点都考察一遍","like_count":0},{"had_liked":false,"id":57513,"user_name":"slvher","can_delete":false,"product_type":"c1","uid":1018964,"ip_address":"","ucode":"F4ED6980C8248B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/54/deb19880.jpg","comment_is_top":false,"comment_ctime":1546826203,"is_pvip":false,"replies":[{"id":"21852","content":"👍  beam search算法不怎么懂，我抽空研究下：）<br><br>不过，我的那个算法是可以得到最优解的。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1547708918,"ip_address":"","comment_id":57513,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546826203","product_id":100017301,"comment_content":"机器翻译的例子，用于解码的启发式剪枝是 beam search 算法吧？在 NLP 领域序列解码场合有广泛应用，不保证最优解，但通过调整 beam width 参数能得到工程上可接受的结果","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435617,"discussion_content":"👍  beam search算法不怎么懂，我抽空研究下：）\n\n不过，我的那个算法是可以得到最优解的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547708918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57505,"user_name":"P@tricK","can_delete":false,"product_type":"c1","uid":1233716,"ip_address":"","ucode":"293B2B3261A793","user_header":"https://static001.geekbang.org/account/avatar/00/12/d3/34/5dee4f70.jpg","comment_is_top":false,"comment_ctime":1546824314,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546824314","product_id":100017301,"comment_content":"课后思考：<br><br>1. 想到一个简单粗暴的，用道路长度&#47;限速作为权重。（实际上算上交通拥堵的话感觉复杂好多，需要去根据当前交通状况判断……）<br><br>2. 分别取离起点和终点最近的地铁站为s和t，地铁每个站权重为1（也就是无权），类似Dijkstra算法，从s开始搜索，维护一个优先级队列，遇到换乘点则添加分支。（公交车的如果也用这个想法，每个站都会是换乘点，而且每个换乘点有n个线路…… 会想用上分区的办法）","like_count":0}]}