{"id":528692,"title":"06｜打破次元壁：容器该如何与外界互联互通","content":"<p>你好，我是Chrono。</p><p>在前面的几节课里，我们已经学习了容器、镜像、镜像仓库的概念和用法，也知道了应该如何创建镜像，再以容器的形式启动应用。</p><p>不过，用容器来运行“busybox”“hello world”这样比较简单的应用还好，如果是Nginx、Redis、MySQL这样的后台服务应用，因为它们运行在容器的“沙盒”里，完全与外界隔离，无法对外提供服务，也就失去了价值。这个时候，容器的隔离环境反而成为了一种负面特性。</p><p>所以，容器的这个“小板房”不应该是一个完全密闭的铁屋子，而是应该给它开几扇门窗，让应用在“足不出户”的情况下，也能够与外界交换数据、互通有无，这样“有限的隔离”才是我们真正所需要的运行环境。</p><p>那么今天，我就以Docker为例，来讲讲有哪些手段能够在容器与外部系统之间沟通交流。</p><h2>如何拷贝容器内的数据</h2><p>我们首先来看看Docker提供的 <code>cp</code> 命令，它可以在宿主机和容器之间拷贝文件，是最基本的一种数据交换功能。</p><p>试验这个命令需要先用 <code>docker run</code> 启动一个容器，就用Redis吧：</p><pre><code class=\"language-plain\">docker run -d --rm redis\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/b1/3d/b1783d59c7a8d9caca91f0fa67d01e3d.png?wh=1692x306\" alt=\"图片\"></p><p>注意这里使用了 <code>-d</code>、<code>--rm</code> 两个参数，表示运行在后台，容器结束后自动删除，然后使用 <code>docker ps</code> 命令可以看到Redis容器正在运行，容器ID是“062”。</p><!-- [[[read_end]]] --><p><code>docker cp</code> 的用法很简单，很类似Linux的“cp”“scp”，指定源路径（src path）和目标路径（dest path）就可以了。如果源路径是宿主机那么就是把文件拷贝进容器，如果源路径是容器那么就是把文件拷贝出容器，注意需要用<strong>容器名或者容器ID</strong>来指明是哪个容器的路径。</p><p>假设当前目录下有一个“a.txt”的文件，现在我们要把它拷贝进Redis容器的“/tmp”目录，如果使用容器ID，命令就会是这样：</p><pre><code class=\"language-plain\">docker cp a.txt 062:/tmp\n</code></pre><p>接下来我们可以使用 <code>docker exec</code> 命令，进入容器看看文件是否已经正确拷贝了：</p><pre><code class=\"language-plain\">docker exec -it 062 sh\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/77/45/774ea51e56cac8b9aefb6d326b1f1145.png?wh=990x182\" alt=\"图片\"></p><p>可以看到，在“/tmp”目录下，确实已经有了一个“a.txt”。</p><p>现在让我们再来试验一下从容器拷贝出文件，只需要把 <code>docker cp</code> 后面的两个路径调换一下位置：</p><pre><code class=\"language-plain\">docker cp 062:/tmp/a.txt ./b.txt\n</code></pre><p>这样，在宿主机的当前目录里，就会多出一个新的“b.txt”，也就是从容器里拿到的文件。</p><h2>如何共享主机上的文件</h2><p><code>docker cp</code> 的用法模仿了操作系统的拷贝命令，偶尔一两次的文件共享还可以应付，如果容器运行时经常有文件来往互通，这样反复地拷来拷去就显得很麻烦，也很容易出错。</p><p>你也许会联想到虚拟机有一种“共享目录”的功能。它可以在宿主机上开一个目录，然后把这个目录“挂载”进虚拟机，这样就实现了两者共享同一个目录，一边对目录里文件的操作另一边立刻就能看到，没有了数据拷贝，效率自然也会高很多。</p><p>沿用这个思路，容器也提供了这样的共享宿主机目录的功能，效果也和虚拟机几乎一样，用起来很方便，只需要在 <code>docker run</code> 命令启动容器的时候使用 <code>-v</code> 参数就行，具体的格式是“<strong>宿主机路径:容器内路径</strong>”。</p><p>我还是以Redis为例，启动容器，使用 <code>-v</code> 参数把本机的“/tmp”目录挂载到容器里的“/tmp”目录，也就是说让容器共享宿主机的“/tmp”目录：</p><pre><code class=\"language-plain\">docker run -d --rm -v /tmp:/tmp redis\n</code></pre><p>然后我们再用 <code>docker exec</code> 进入容器，查看一下容器内的“/tmp”目录，应该就可以看到文件与宿主机是完全一致的。</p><pre><code class=\"language-plain\">docker exec -it b5a sh    # b5a是容器ID\n</code></pre><p>你也可以在容器里的“/tmp”目录下随便做一些操作，比如删除文件、建立新目录等等，再回头观察一下宿主机，会发现修改会即时同步，这就表明容器和宿主机确实已经共享了这个目录。</p><p><code>-v</code> 参数挂载宿主机目录的这个功能，对于我们日常开发测试工作来说非常有用，我们可以在不变动本机环境的前提下，使用镜像安装任意的应用，然后直接以容器来运行我们本地的源码、脚本，非常方便。</p><p>这里我举一个简单的例子。比如我本机上只有Python 2.7，但我想用Python 3开发，如果同时安装Python 2和Python 3很容易就会把系统搞乱，所以我就可以这么做：</p><ol>\n<li>先使用 <code>docker pull</code> 拉取一个Python 3的镜像，因为它打包了完整的运行环境，运行时有隔离，所以不会对现有系统的Python 2.7产生任何影响。</li>\n<li>在本地的某个目录编写Python代码，然后用 <code>-v</code> 参数让容器共享这个目录。</li>\n<li>现在就可以在容器里以Python 3来安装各种包，再运行脚本做开发了。</li>\n</ol><pre><code class=\"language-plain\">docker pull python:alpine\ndocker run -it --rm -v `pwd`:/tmp python:alpine sh\n</code></pre><p>显然，这种方式比把文件打包到镜像或者 <code>docker cp</code> 会更加灵活，非常适合有频繁修改的开发测试工作。</p><h2>如何实现网络互通</h2><p>现在我们使用 <code>docker cp</code> 和 <code>docker run -v</code> 可以解决容器与外界的文件互通问题，但对于Nginx、Redis这些服务器来说，网络互通才是更要紧的问题。</p><p>网络互通的关键在于“打通”容器内外的网络，而处理网络通信无疑是计算机系统里最棘手的工作之一，有许许多多的名词、协议、工具，在这里我也没有办法一下子就把它都完全说清楚，所以只能从“宏观”层面讲个大概，帮助你快速理解。</p><p>Docker提供了三种网络模式，分别是<strong>null</strong>、<strong>host</strong>和<strong>bridge</strong>。</p><p><strong>null</strong>是最简单的模式，也就是没有网络，但允许其他的网络插件来自定义网络连接，这里就不多做介绍了。</p><p><strong>host</strong>的意思是直接使用宿主机网络，相当于去掉了容器的网络隔离（其他隔离依然保留），所有的容器会共享宿主机的IP地址和网卡。这种模式没有中间层，自然通信效率高，但缺少了隔离，运行太多的容器也容易导致端口冲突。</p><p>host模式需要在 <code>docker run</code> 时使用 <code>--net=host</code> 参数，下面我就用这个参数启动Nginx：</p><pre><code class=\"language-plain\">docker run -d --rm --net=host nginx:alpine\n</code></pre><p>为了验证效果，我们可以在本机和容器里分别执行 <code>ip addr</code> 命令，查看网卡信息：</p><pre><code class=\"language-plain\">ip addr                    # 本机查看网卡\ndocker exec xxx ip addr    # 容器查看网卡\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/51/41/512a1522f75e3b67a313b17d17e88d41.png?wh=1920x607\" alt=\"图片\" title=\"本机查看网卡\"></p><p><img src=\"https://static001.geekbang.org/resource/image/d3/f4/d34785c0a0be3yybf0d44231d2b7c6f4.png?wh=1920x657\" alt=\"图片\" title=\"容器查看网卡\"></p><p>可以看到这两个 <code>ip addr</code> 命令的输出信息是完全一样的，比如都是一个网卡ens160，IP地址是“192.168.10.208”，这就证明Nginx容器确实与本机共享了网络栈。</p><p>第三种<strong>bridge</strong>，也就是桥接模式，它有点类似现实世界里的交换机、路由器，只不过是由软件虚拟出来的，容器和宿主机再通过虚拟网卡接入这个网桥（图中的docker0），那么它们之间也就可以正常的收发网络数据包了。不过和host模式相比，bridge模式多了虚拟网桥和网卡，通信效率会低一些。</p><p><img src=\"https://static001.geekbang.org/resource/image/6e/60/6e0d05cf19720f44ca68f88238627460.jpg?wh=1920x1407\" alt=\"图片\"></p><p>和host模式一样，我们也可以用 <code>--net=bridge</code> 来启用桥接模式，但其实并没有这个必要，因为Docker默认的网络模式就是bridge，所以一般不需要显式指定。</p><p>下面我们启动两个容器Nginx和Redis，就像刚才说的，没有特殊指定就会使用bridge模式：</p><pre><code class=\"language-plain\">docker run -d --rm nginx:alpine    # 默认使用桥接模式\ndocker run -d --rm redis           # 默认使用桥接模式\n</code></pre><p>然后我们还是在本机和容器里执行 <code>ip addr</code> 命令（Redis容器里没有ip命令，所以只能在Nginx容器里执行）：</p><p><img src=\"https://static001.geekbang.org/resource/image/67/07/6738ac4730b15bc6f6760088bef13607.png?wh=1920x455\" alt=\"图片\"></p><p>对比一下刚才host模式的输出，就可以发现容器里的网卡设置与宿主机完全不同，eth0是一个虚拟网卡，IP地址是B类私有地址“172.17.0.2”。</p><p>我们还可以用 <code>docker inspect</code> 直接查看容器的ip地址：</p><pre><code class=\"language-plain\">docker inspect xxx |grep IPAddress\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/10/d6/10c86aecyy6c61ff8fdbd6333e7e00d6.png?wh=1328x490\" alt=\"图片\"></p><p>这显示出两个容器的IP地址分别是“172.17.0.2”和“172.17.0.3”，而宿主机的IP地址则是“172.17.0.1”，所以它们都在“172.17.0.0/16”这个Docker的默认网段，彼此之间就能够使用IP地址来实现网络通信了。</p><h2>如何分配服务端口号</h2><p>使用host模式或者bridge模式，我们的容器就有了IP地址，建立了与外部世界的网络连接，接下来要解决的就是网络服务的端口号问题。</p><p>你一定知道，服务器应用都必须要有端口号才能对外提供服务，比如HTTP协议用80、HTTPS用443、Redis是6379、MySQL是3306。<a href=\"hhttps://time.geekbang.org/column/article/528660\">第4讲</a>我们在学习编写Dockerfile的时候也看到过，可以用 <code>EXPOSE</code> 指令声明容器对外的端口号。</p><p>一台主机上的端口号数量是有限的，而且多个服务之间还不能够冲突，但我们打包镜像应用的时候通常都使用的是默认端口，容器实际运行起来就很容易因为端口号被占用而无法启动。</p><p>解决这个问题的方法就是加入一个“中间层”，由容器环境例如Docker来统一管理分配端口号，在本机端口和容器端口之间做一个“映射”操作，容器内部还是用自己的端口号，但外界看到的却是另外一个端口号，这样就很好地避免了冲突。</p><p><strong>端口号映射需要使用bridge模式，并且在 <code>docker run</code> 启动容器时使用 <code>-p</code> 参数，形式和共享目录的 <code>-v</code> 参数很类似，用 <code>:</code> 分隔本机端口和容器端口</strong>。比如，如果要启动两个Nginx容器，分别跑在80和8080端口上：</p><pre><code class=\"language-plain\">docker run -d -p 80:80 --rm nginx:alpine\ndocker run -d -p 8080:80 --rm nginx:alpine\n</code></pre><p>这样就把本机的80和8080端口分别“映射”到了两个容器里的80端口，不会发生冲突，我们可以用curl再验证一下：</p><p><img src=\"https://static001.geekbang.org/resource/image/f1/d8/f16b0d1a02af7fecd84fdb7c24bf12d8.png?wh=1692x1510\" alt=\"图片\"></p><p>使用 <code>docker ps</code> 命令能够在“PORTS”栏里更直观地看到端口的映射情况：</p><p><img src=\"https://static001.geekbang.org/resource/image/63/ed/63e151b4246feef89b9c7befd88f95ed.png?wh=1920x145\" alt=\"图片\"></p><h2>小结</h2><p>好了，今天我们一起学习了容器与外部系统之间沟通交流的几种方法。</p><p>你会发现，这些方法几乎消除了容器化的应用和本地应用因为隔离特性而产生的差异，而因为镜像独特的打包机制，容器技术显然能够比apt/yum更方便地安装各种应用，绝不会“污染”已有的系统。</p><p>今天的课里我列举了Python、Nginx等例子，你还可以举一反三，借鉴它们把本地配置文件加载到容器里适当的位置，再映射端口号，把Redis、MySQL、Node.js都运行起来，让容器成为我们工作中的得力助手。</p><p>照例简单小结一下这次的要点：</p><ol>\n<li><code>docker cp</code> 命令可以在容器和主机之间互相拷贝文件，适合简单的数据交换。</li>\n<li><code>docker run -v</code> 命令可以让容器和主机共享本地目录，免去了拷贝操作，提升工作效率。</li>\n<li>host网络模式让容器与主机共享网络栈，效率高但容易导致端口冲突。</li>\n<li>bridge网络模式实现了一个虚拟网桥，容器和主机都在一个私有网段内互联互通。</li>\n<li><code>docker run -p</code> 命令可以把主机的端口号映射到容器的内部端口号，解决了潜在的端口冲突问题。</li>\n</ol><h2>课下作业</h2><p>最后是课下作业时间，给你留两个思考题：</p><ol>\n<li>你能说出今天学的 <code>docker cp</code> 命令和第4讲Dockerfile里的COPY指令有什么区别吗？</li>\n<li>你觉得host模式和bridge模式各有什么优缺点，在什么场景下应用最合适？</li>\n</ol><p>欢迎积极留言讨论，我会第一时间给你回复，如果有收获也欢迎你转发给身边的朋友一起学习。</p><p>下节课是实战演练，下节课见。</p><p><img src=\"https://static001.geekbang.org/resource/image/46/bb/46ccb8yy8d265f4fcc8ea3e88f7565bb.jpg?wh=1920x2237\" alt=\"\"></p>","neighbors":{"left":{"article_title":"05｜镜像仓库：该怎样用好Docker Hub这个宝藏","id":528677},"right":{"article_title":"07｜实战演练：玩转Docker","id":528740}},"comments":[]}