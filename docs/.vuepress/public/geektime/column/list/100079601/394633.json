{"id":394633,"title":"21 | 日志处理（下）：手把手教你从 0 编写一个日志包","content":"<p>你好，我是孔令飞。</p><p>上一讲我介绍了如何设计日志包，今天是实战环节，我会手把手教你从0编写一个日志包。</p><p>在实际开发中，我们可以选择一些优秀的开源日志包，不加修改直接拿来使用。但更多时候，是基于一个或某几个优秀的开源日志包进行二次开发。想要开发或者二次开发一个日志包，就要掌握日志包的实现方式。那么这一讲中，我来带你从0到1，实现一个具备基本功能的日志包，让你从中一窥日志包的实现原理和实现方法。</p><p>在开始实战之前，我们先来看下目前业界有哪些优秀的开源日志包。</p><h2>有哪些优秀的开源日志包？</h2><p>在Go项目开发中，我们可以通过修改一些优秀的开源日志包，来实现项目的日志包。Go生态中有很多优秀的开源日志包，例如标准库log包、glog、logrus、zap、seelog、zerolog、log15、apex/log、go-logging等。其中，用得比较多的是标准库log包、glog、logrus和zap。</p><p>为了使你了解开源日志包的现状，接下来我会简单介绍下这几个常用的日志包。至于它们的具体使用方法，你可以参考我整理的一篇文章：<a href=\"https://github.com/marmotedu/geekbang-go/blob/master/%E4%BC%98%E7%A7%80%E5%BC%80%E6%BA%90%E6%97%A5%E5%BF%97%E5%8C%85%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.md\">优秀开源日志包使用教程</a>。</p><h3>标准库log包</h3><p>标准库log包的功能非常简单，只提供了Print、Panic和Fatal三类函数用于日志输出。因为是标准库自带的，所以不需要我们下载安装，使用起来非常方便。</p><!-- [[[read_end]]] --><p>标准库log包只有不到400行的代码量，如果你想研究如何实现一个日志包，阅读标准库log包是一个不错的开始。Go的标准库大量使用了log包，例如<code>net/http</code> 、 <code>net/rpc</code> 等。</p><h3>glog</h3><p><a href=\"https://github.com/golang/glog\">glog</a>是Google推出的日志包，跟标准库log包一样，它是一个轻量级的日志包，使用起来简单方便。但glog比标准库log包提供了更多的功能，它具有如下特性：</p><ul>\n<li>支持4种日志级别：Info、Warning、Error、Fatal。</li>\n<li>支持命令行选项，例如<code>-alsologtostderr</code>、<code>-log_backtrace_at</code>、<code>-log_dir</code>、<code>-logtostderr</code>、<code>-v</code>等，每个参数实现某种功能。</li>\n<li>支持根据文件大小切割日志文件。</li>\n<li>支持日志按级别分类输出。</li>\n<li>支持V level。V level特性可以使开发者自定义日志级别。</li>\n<li>支持vmodule。vmodule可以使开发者对不同的文件使用不同的日志级别。</li>\n<li>支持traceLocation。traceLocation可以打印出指定位置的栈信息。</li>\n</ul><p>Kubernetes项目就使用了基于glog封装的klog，作为其日志库。</p><h3>logrus</h3><p><a href=\"https://github.com/sirupsen/logrus\">logrus</a>是目前GitHub上star数量最多的日志包，它的优点是功能强大、性能高效、高度灵活，还提供了自定义插件的功能。很多优秀的开源项目，例如Docker、Prometheus等，都使用了logrus。除了具有日志的基本功能外，logrus还具有如下特性：</p><ul>\n<li>支持常用的日志级别。logrus支持Debug、Info、Warn、Error、Fatal和Panic这些日志级别。</li>\n<li>可扩展。logrus的Hook机制允许使用者通过Hook的方式，将日志分发到任意地方，例如本地文件、标准输出、Elasticsearch、Logstash、Kafka等。</li>\n<li>支持自定义日志格式。logrus内置了JSONFormatter和TextFormatter两种格式。除此之外，logrus还允许使用者通过实现Formatter接口，来自定义日志格式。</li>\n<li>结构化日志记录。logrus的Field机制允许使用者自定义日志字段，而不是通过冗长的消息来记录日志。</li>\n<li>预设日志字段。logrus的Default Fields机制，可以给一部分或者全部日志统一添加共同的日志字段，例如给某次HTTP请求的所有日志添加X-Request-ID字段。</li>\n<li>Fatal handlers。logrus允许注册一个或多个handler，当产生Fatal级别的日志时调用。当我们的程序需要优雅关闭时，这个特性会非常有用。</li>\n</ul><h3>zap</h3><p><a href=\"https://github.com/uber-go/zap\">zap</a>是uber开源的日志包，以高性能著称，很多公司的日志包都是基于zap改造而来。除了具有日志基本的功能之外，zap还具有很多强大的特性：</p><ul>\n<li>支持常用的日志级别，例如：Debug、Info、Warn、Error、DPanic、Panic、Fatal。</li>\n<li>性能非常高。zap具有非常高的性能，适合对性能要求比较高的场景。</li>\n<li>支持针对特定的日志级别，输出调用堆栈。</li>\n<li>像logrus一样，zap也支持结构化的目录日志、预设日志字段，也因为支持Hook而具有可扩展性。</li>\n</ul><h3>开源日志包选择</h3><p>上面我介绍了很多日志包，每种日志包使用的场景不同，你可以根据自己的需求，结合日志包的特性进行选择：</p><ul>\n<li><strong>标准库log包：</strong> 标准库log包不支持日志级别、日志分割、日志格式等功能，所以在大型项目中很少直接使用，通常用于一些短小的程序，比如用于生成JWT Token的main.go文件中。标准库日志包也很适合一些简短的代码，用于快速调试和验证。</li>\n<li><strong>glog：</strong> glog实现了日志包的基本功能，非常适合一些对日志功能要求不多的小型项目。</li>\n<li><strong>logrus：</strong> logrus功能强大，不仅实现了日志包的基本功能，还有很多高级特性，适合一些大型项目，尤其是需要结构化日志记录的项目。</li>\n<li><strong>zap：</strong> zap提供了很强大的日志功能，性能高，内存分配次数少，适合对日志性能要求很高的项目。另外，zap包中的子包zapcore，提供了很多底层的日志接口，适合用来做二次封装。</li>\n</ul><p>举个我自己选择日志包来进行二次开发的例子：我在做容器云平台开发时，发现Kubernetes源码中大量使用了glog，这时就需要日志包能够兼容glog。于是，我基于zap和zapcore封装了<a href=\"https://github.com/marmotedu/iam/tree/master/pkg/log\">github.com/marmotedu/iam/pkg/log</a>日志包，这个日志包可以很好地兼容glog。</p><p>在实际项目开发中，你可以根据项目需要，从上面几个日志包中进行选择，直接使用，但更多时候，你还需要基于这些包来进行定制开发。为了使你更深入地掌握日志包的设计和开发，接下来，我会从0到1带你开发一个日志包。</p><h2>从0编写一个日志包</h2><p>接下来，我会向你展示如何快速编写一个具备基本功能的日志包，让你通过这个简短的日志包实现掌握日志包的核心设计思路。该日志包主要实现以下几个功能：</p><ul>\n<li>支持自定义配置。</li>\n<li>支持文件名和行号。</li>\n<li>支持日志级别  Debug、Info、Warn、Error、Panic、Fatal。</li>\n<li>支持输出到本地文件和标准输出。</li>\n<li>支持JSON和TEXT格式的日志输出，支持自定义日志格式。</li>\n<li>支持选项模式。</li>\n</ul><p>日志包名称为<code>cuslog</code>，示例项目完整代码存放在  <a href=\"https://github.com/marmotedu/gopractise-demo/tree/main/log/cuslog\">cuslog</a>。</p><p>具体实现分为以下四个步骤：</p><ol>\n<li>定义：定义日志级别和日志选项。</li>\n<li>创建：创建Logger及各级别日志打印方法。</li>\n<li>写入：将日志输出到支持的输出中。</li>\n<li>自定义：自定义日志输出格式。</li>\n</ol><h3>定义日志级别和日志选项</h3><p>一个基本的日志包，首先需要定义好日志级别和日志选项。本示例将定义代码保存在<a href=\"https://github.com/marmotedu/gopractise-demo/blob/main/log/cuslog/options.go\">options.go</a>文件中。</p><p>可以通过如下方式定义日志级别：</p><pre><code>type Level uint8\n\nconst (\n    DebugLevel Level = iota\n    InfoLevel\n    WarnLevel\n    ErrorLevel\n    PanicLevel\n    FatalLevel\n)\n\nvar LevelNameMapping = map[Level]string{\n    DebugLevel: &quot;DEBUG&quot;,\n    InfoLevel:  &quot;INFO&quot;,\n    WarnLevel:  &quot;WARN&quot;,\n    ErrorLevel: &quot;ERROR&quot;,\n    PanicLevel: &quot;PANIC&quot;,\n    FatalLevel: &quot;FATAL&quot;,\n}\n</code></pre><p>在日志输出时，要通过对比开关级别和输出级别的大小，来决定是否输出，所以日志级别Level要定义成方便比较的数值类型。几乎所有的日志包都是用常量计数器iota来定义日志级别。</p><p>另外，因为要在日志输出中，输出可读的日志级别（例如输出INFO而不是1），所以需要有Level到Level Name的映射LevelNameMapping，LevelNameMapping会在格式化时用到。</p><p>接下来看定义日志选项。日志需要是可配置的，方便开发者根据不同的环境设置不同的日志行为，比较常见的配置选项为：</p><ul>\n<li>日志级别。</li>\n<li>输出位置，例如标准输出或者文件。</li>\n<li>输出格式，例如JSON或者Text。</li>\n<li>是否开启文件名和行号。</li>\n</ul><p>本示例的日志选项定义如下：</p><pre><code>type options struct {\n    output        io.Writer\n    level         Level\n    stdLevel      Level\n    formatter     Formatter\n    disableCaller bool\n}\n</code></pre><p>为了灵活地设置日志的选项，你可以通过选项模式，来对日志选项进行设置：</p><pre><code>type Option func(*options)\n\nfunc initOptions(opts ...Option) (o *options) {\n    o = &amp;options{}\n    for _, opt := range opts {\n        opt(o)\n    }\n\n    if o.output == nil {\n        o.output = os.Stderr\n    }\n\n    if o.formatter == nil {\n        o.formatter = &amp;TextFormatter{}\n    }\n\n    return\n}\n\nfunc WithLevel(level Level) Option {\n    return func(o *options) {\n        o.level = level\n    }\n}\n...\nfunc SetOptions(opts ...Option) {\n    std.SetOptions(opts...)\n}\n\nfunc (l *logger) SetOptions(opts ...Option) {\n    l.mu.Lock()\n    defer l.mu.Unlock()\n\n    for _, opt := range opts {\n        opt(l.opt)\n    }\n}\n</code></pre><p>具有选项模式的日志包，可通过以下方式，来动态地修改日志的选项：</p><pre><code>cuslog.SetOptions(cuslog.WithLevel(cuslog.DebugLevel))\n</code></pre><p>你可以根据需要，对每一个日志选项创建设置函数 <code>WithXXXX</code>  。这个示例日志包支持如下选项设置函数：</p><ul>\n<li>WithOutput（output io.Writer）：设置输出位置。</li>\n<li>WithLevel（level Level）：设置输出级别。</li>\n<li>WithFormatter（formatter Formatter）：设置输出格式。</li>\n<li>WithDisableCaller（caller bool）：设置是否打印文件名和行号。</li>\n</ul><h3>创建Logger及各级别日志打印方法</h3><p>为了打印日志，我们需要根据日志配置，创建一个Logger，然后通过调用Logger的日志打印方法，完成各级别日志的输出。本示例将创建代码保存在<a href=\"https://github.com/marmotedu/gopractise-demo/blob/main/log/cuslog/logger.go\">logger.go</a>文件中。</p><p>可以通过如下方式创建Logger：</p><pre><code>var std = New()\n\ntype logger struct {\n    opt       *options\n    mu        sync.Mutex\n    entryPool *sync.Pool\n}\n\nfunc New(opts ...Option) *logger {\n    logger := &amp;logger{opt: initOptions(opts...)}\n    logger.entryPool = &amp;sync.Pool{New: func() interface{} { return entry(logger) }}\n    return logger\n}\n</code></pre><p>上述代码中，定义了一个Logger，并实现了创建Logger的New函数。日志包都会有一个默认的全局Logger，本示例通过 <code>var std = New()</code> 创建了一个全局的默认Logger。cuslog.Debug、cuslog.Info和cuslog.Warnf等函数，则是通过调用std Logger所提供的方法来打印日志的。</p><p>定义了一个Logger之后，还需要给该Logger添加最核心的日志打印方法，要提供所有支持级别的日志打印方法。</p><p>如果日志级别是Xyz，则通常需要提供两类方法，分别是非格式化方法<code>Xyz(args ...interface{})</code>和格式化方法<code>Xyzf(format string, args ...interface{})</code>，例如：</p><pre><code>func (l *logger) Debug(args ...interface{}) {\n    l.entry().write(DebugLevel, FmtEmptySeparate, args...)\n}\nfunc (l *logger) Debugf(format string, args ...interface{}) {\n    l.entry().write(DebugLevel, format, args...)\n}\n</code></pre><p>本示例实现了如下方法：Debug、Debugf、Info、Infof、Warn、Warnf、Error、Errorf、Panic、Panicf、Fatal、Fatalf。更详细的实现，你可以参考 <a href=\"https://github.com/marmotedu/gopractise-demo/blob/main/log/cuslog/logger.go\">cuslog/logger.go</a>。</p><p>这里要注意，Panic、Panicf要调用panic()函数，Fatal、Fatalf函数要调用 <code>os.Exit(1)</code> 函数。</p><h3>将日志输出到支持的输出中</h3><p>调用日志打印函数之后，还需要将这些日志输出到支持的输出中，所以需要实现write函数，它的写入逻辑保存在<a href=\"https://github.com/marmotedu/gopractise-demo/blob/main/log/cuslog/entry.go\">entry.go</a>文件中。实现方式如下：</p><pre><code>type Entry struct {\n    logger *logger\n    Buffer *bytes.Buffer\n    Map    map[string]interface{}\n    Level  Level\n    Time   time.Time\n    File   string\n    Line   int\n    Func   string\n    Format string\n    Args   []interface{}\n}\n\nfunc (e *Entry) write(level Level, format string, args ...interface{}) {\n    if e.logger.opt.level &gt; level {\n        return\n    }\n    e.Time = time.Now()\n    e.Level = level\n    e.Format = format\n    e.Args = args\n    if !e.logger.opt.disableCaller {\n        if pc, file, line, ok := runtime.Caller(2); !ok {\n            e.File = &quot;???&quot;\n            e.Func = &quot;???&quot;\n        } else {\n            e.File, e.Line, e.Func = file, line, runtime.FuncForPC(pc).Name()\n            e.Func = e.Func[strings.LastIndex(e.Func, &quot;/&quot;)+1:]\n        }\n    }\n    e.format()\n    e.writer()\n    e.release()\n}\n\nfunc (e *Entry) format() {\n    _ = e.logger.opt.formatter.Format(e)\n}\n\nfunc (e *Entry) writer() {\n    e.logger.mu.Lock()\n    _, _ = e.logger.opt.output.Write(e.Buffer.Bytes())\n    e.logger.mu.Unlock()\n}\n\nfunc (e *Entry) release() {\n    e.Args, e.Line, e.File, e.Format, e.Func = nil, 0, &quot;&quot;, &quot;&quot;, &quot;&quot;\n    e.Buffer.Reset()\n    e.logger.entryPool.Put(e)\n}\n</code></pre><p>上述代码，首先定义了一个Entry结构体类型，该类型用来保存所有的日志信息，即日志配置和日志内容。写入逻辑都是围绕Entry类型的实例来完成的。</p><p>用Entry的write方法来完成日志的写入，在write方法中，会首先判断日志的输出级别和开关级别，如果输出级别小于开关级别，则直接返回，不做任何记录。</p><p>在write中，还会判断是否需要记录文件名和行号，如果需要则调用 <code>runtime.Caller()</code> 来获取文件名和行号，调用 <code>runtime.Caller()</code> 时，要注意传入正确的栈深度。</p><p>write函数中调用 <code>e.format</code> 来格式化日志，调用 <code>e.writer</code> 来写入日志，在创建Logger传入的日志配置中，指定了输出位置 <code>output io.Writer</code> ，output类型为 <code>io.Writer</code>  ，示例如下：</p><pre><code>type Writer interface {\n    Write(p []byte) (n int, err error)\n}\n</code></pre><p>io.Writer实现了Write方法可供写入，所以只需要调用<code>e.logger.opt.output.Write(e.Buffer.Bytes())</code>即可将日志写入到指定的位置中。最后，会调用release()方法来清空缓存和对象池。至此，我们就完成了日志的记录和写入。</p><h3>自定义日志输出格式</h3><p>cuslog包支持自定义输出格式，并且内置了JSON和Text格式的Formatter。Formatter接口定义为：</p><pre><code>type Formatter interface {\n    Format(entry *Entry) error\n}\n</code></pre><p>cuslog内置的Formatter有两个：<a href=\"https://github.com/marmotedu/gopractise-demo/blob/main/log/cuslog/formatter_json.go\">JSON</a>和<a href=\"https://github.com/marmotedu/gopractise-demo/blob/main/log/cuslog/formatter_text.go\">TEXT</a>。</p><h3>测试日志包</h3><p>cuslog日志包开发完成之后，可以编写测试代码，调用cuslog包来测试cuslog包，代码如下：</p><pre><code>package main\n\nimport (\n    &quot;log&quot;\n    &quot;os&quot;\n\n    &quot;github.com/marmotedu/gopractise-demo/log/cuslog&quot;\n)\n\nfunc main() {\n    cuslog.Info(&quot;std log&quot;)\n    cuslog.SetOptions(cuslog.WithLevel(cuslog.DebugLevel))\n    cuslog.Debug(&quot;change std log to debug level&quot;)\n    cuslog.SetOptions(cuslog.WithFormatter(&amp;cuslog.JsonFormatter{IgnoreBasicFields: false}))\n    cuslog.Debug(&quot;log in json format&quot;)\n    cuslog.Info(&quot;another log in json format&quot;)\n\n    // 输出到文件\n    fd, err := os.OpenFile(&quot;test.log&quot;, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)\n    if err != nil {\n        log.Fatalln(&quot;create file test.log failed&quot;)\n    }\n    defer fd.Close()\n\n    l := cuslog.New(cuslog.WithLevel(cuslog.InfoLevel),\n        cuslog.WithOutput(fd),\n        cuslog.WithFormatter(&amp;cuslog.JsonFormatter{IgnoreBasicFields: false}),\n    )\n    l.Info(&quot;custom log with json formatter&quot;)\n}\n</code></pre><p>将上述代码保存在main.go文件中，运行：</p><pre><code>$ go run example.go\n2020-12-04T10:32:12+08:00 INFO example.go:11 std log\n2020-12-04T10:32:12+08:00 DEBUG example.go:13 change std log to debug level\n{&quot;file&quot;:&quot;/home/colin/workspace/golang/src/github.com/marmotedu/gopractise-demo/log/cuslog/example/example.go:15&quot;,&quot;func&quot;:&quot;main.main&quot;,&quot;message&quot;:&quot;log in json format&quot;,&quot;level&quot;:&quot;DEBUG&quot;,&quot;time&quot;:&quot;2020-12-04T10:32:12+08:00&quot;}\n{&quot;level&quot;:&quot;INFO&quot;,&quot;time&quot;:&quot;2020-12-04T10:32:12+08:00&quot;,&quot;file&quot;:&quot;/home/colin/workspace/golang/src/github.com/marmotedu/gopractise-demo/log/cuslog/example/example.go:16&quot;,&quot;func&quot;:&quot;main.main&quot;,&quot;message&quot;:&quot;another log in json format&quot;}\n</code></pre><p>到这里日志包就开发完成了，完整包见  <a href=\"https://github.com/marmotedu/gopractise-demo/tree/main/log/cuslog\">log/cuslog</a>。</p><h2>IAM项目日志包设计</h2><p>这一讲的最后，我们再来看下我们的IAM项目中，日志包是怎么设计的。</p><p>先来看一下IAM项目log包的存放位置：<a href=\"https://github.com/marmotedu/iam/tree/v1.0.0/pkg/log\">pkg/log</a>。放在这个位置，主要有两个原因：第一个，log包属于IAM项目，有定制开发的内容；第二个，log包功能完备、成熟，外部项目也可以使用。</p><p>该log包是基于 <code>go.uber.org/zap</code> 包封装而来的，根据需要添加了更丰富的功能。接下来，我们通过log包的<a href=\"https://github.com/marmotedu/iam/blob/master/pkg/log/options.go#L47\">Options</a>，来看下log包所实现的功能：</p><pre><code>type Options struct {\n    OutputPaths       []string `json:&quot;output-paths&quot;       mapstructure:&quot;output-paths&quot;`\n    ErrorOutputPaths  []string `json:&quot;error-output-paths&quot; mapstructure:&quot;error-output-paths&quot;`\n    Level             string   `json:&quot;level&quot;              mapstructure:&quot;level&quot;`\n    Format            string   `json:&quot;format&quot;             mapstructure:&quot;format&quot;`\n    DisableCaller     bool     `json:&quot;disable-caller&quot;     mapstructure:&quot;disable-caller&quot;`\n    DisableStacktrace bool     `json:&quot;disable-stacktrace&quot; mapstructure:&quot;disable-stacktrace&quot;`\n    EnableColor       bool     `json:&quot;enable-color&quot;       mapstructure:&quot;enable-color&quot;`\n    Development       bool     `json:&quot;development&quot;        mapstructure:&quot;development&quot;`\n    Name              string   `json:&quot;name&quot;               mapstructure:&quot;name&quot;`\n}\n</code></pre><p>Options各配置项含义如下：</p><ul>\n<li>development：是否是开发模式。如果是开发模式，会对DPanicLevel进行堆栈跟踪。</li>\n<li>name：Logger的名字。</li>\n<li>disable-caller：是否开启 caller，如果开启会在日志中显示调用日志所在的文件、函数和行号。</li>\n<li>disable-stacktrace：是否在Panic及以上级别禁止打印堆栈信息。</li>\n<li>enable-color：是否开启颜色输出，true，是；false，否。</li>\n<li>level：日志级别，优先级从低到高依次为：Debug, Info, Warn, Error, Dpanic, Panic, Fatal。</li>\n<li>format：支持的日志输出格式，目前支持Console和JSON两种。Console其实就是Text格式。</li>\n<li>output-paths：支持输出到多个输出，用逗号分开。支持输出到标准输出（stdout）和文件。</li>\n<li>error-output-paths：zap内部(非业务)错误日志输出路径，多个输出，用逗号分开。</li>\n</ul><p>log包的Options结构体支持以下3个方法：</p><ul>\n<li>Build方法。Build方法可以根据Options构建一个全局的Logger。</li>\n<li>AddFlags方法。AddFlags方法可以将Options的各个字段追加到传入的pflag.FlagSet变量中。</li>\n<li>String方法。String方法可以将Options的值以JSON格式字符串返回。</li>\n</ul><p>log包实现了以下3种日志记录方法：</p><pre><code>log.Info(&quot;This is a info message&quot;, log.Int32(&quot;int_key&quot;, 10))\nlog.Infof(&quot;This is a formatted %s message&quot;, &quot;info&quot;)\nlog.Infow(&quot;Message printed with Infow&quot;, &quot;X-Request-ID&quot;, &quot;fbf54504-64da-4088-9b86-67824a7fb508&quot;)\n</code></pre><p><code>Info</code> 使用指定的key/value记录日志。<code>Infof</code> 格式化记录日志。 <code>Infow</code> 也是使用指定的key/value记录日志，跟 <code>Info</code> 的区别是：使用 <code>Info</code> 需要指定值的类型，通过指定值的日志类型，日志库底层不需要进行反射操作，所以使用 <code>Info</code> 记录日志性能最高。</p><p>log包支持非常丰富的类型，具体你可以参考  <a href=\"https://github.com/marmotedu/iam/blob/master/pkg/log/types.go#L56\">types.go</a>。</p><p>上述日志输出为：</p><pre><code>2021-07-06 14:02:07.070 INFO This is a info message {&quot;int_key&quot;: 10}\n2021-07-06 14:02:07.071 INFO This is a formatted info message\n2021-07-06 14:02:07.071 INFO Message printed with Infow {&quot;X-Request-ID&quot;: &quot;fbf54504-64da-4088-9b86-67824a7fb508&quot;}\n</code></pre><p>log包为每种级别的日志都提供了3种日志记录方式，举个例子：假设日志格式为 <code>Xyz</code> ，则分别提供了 <code>Xyz(msg string, fields ...Field)</code> ，<code>Xyzf(format string, v ...interface{})</code> ，<code>Xyzw(msg string, keysAndValues ...interface{})</code> 3种日志记录方法。</p><p>另外，log包相较于一般的日志包，还提供了众多记录日志的方法。</p><p><strong>第一个方法，</strong> log包支持V Level，可以通过整型数值来灵活指定日志级别，数值越大，优先级越低。例如：</p><pre><code>// V level使用\nlog.V(1).Info(&quot;This is a V level message&quot;)\nlog.V(1).Infof(&quot;This is a %s V level message&quot;, &quot;formatted&quot;)\nlog.V(1).Infow(&quot;This is a V level message with fields&quot;, &quot;X-Request-ID&quot;, &quot;7a7b9f24-4cae-4b2a-9464-69088b45b904&quot;)\n</code></pre><p>这里要注意，Log.V只支持 <code>Info</code> 、<code>Infof</code> 、<code>Infow</code>三种日志记录方法。</p><p><strong>第二个方法，</strong> log包支持WithValues函数，例如：</p><pre><code>// WithValues使用\nlv := log.WithValues(&quot;X-Request-ID&quot;, &quot;7a7b9f24-4cae-4b2a-9464-69088b45b904&quot;)\nlv.Infow(&quot;Info message printed with [WithValues] logger&quot;)\nlv.Infow(&quot;Debug message printed with [WithValues] logger&quot;)\n</code></pre><p>上述日志输出如下：</p><pre><code>2021-07-06 14:15:28.555 INFO Info message printed with [WithValues] logger {&quot;X-Request-ID&quot;: &quot;7a7b9f24-4cae-4b2a-9464-69088b45b904&quot;}\n2021-07-06 14:15:28.556 INFO Debug message printed with [WithValues] logger {&quot;X-Request-ID&quot;: &quot;7a7b9f24-4cae-4b2a-9464-69088b45b904&quot;}\n</code></pre><p><code>WithValues</code> 可以返回一个携带指定key-value的Logger，供后面使用。</p><p><strong>第三个方法，</strong> log包提供 <code>WithContext</code> 和 <code>FromContext</code> 用来将指定的Logger添加到某个Context中，以及从某个Context中获取Logger，例如：</p><pre><code>// Context使用\nctx := lv.WithContext(context.Background())\nlc := log.FromContext(ctx)\nlc.Info(&quot;Message printed with [WithContext] logger&quot;)\n</code></pre><p><code>WithContext</code>和<code>FromContext</code>非常适合用在以<code>context.Context</code>传递的函数中，例如：</p><pre><code>func main() {\n \n    ...\n \n    // WithValues使用\n    lv := log.WithValues(&quot;X-Request-ID&quot;, &quot;7a7b9f24-4cae-4b2a-9464-69088b45b904&quot;)\n     \n    // Context使用\n    lv.Infof(&quot;Start to call pirntString&quot;)\n    ctx := lv.WithContext(context.Background())\n    pirntString(ctx, &quot;World&quot;)  \n}\n \nfunc pirntString(ctx context.Context, str string) {\n    lc := log.FromContext(ctx)\n    lc.Infof(&quot;Hello %s&quot;, str)\n}\n</code></pre><p>上述代码输出如下：</p><pre><code>2021-07-06 14:38:02.050 INFO Start to call pirntString {&quot;X-Request-ID&quot;: &quot;7a7b9f24-4cae-4b2a-9464-69088b45b904&quot;}\n2021-07-06 14:38:02.050 INFO Hello World {&quot;X-Request-ID&quot;: &quot;7a7b9f24-4cae-4b2a-9464-69088b45b904&quot;}\n</code></pre><p>将Logger添加到Context中，并通过Context在不同函数间传递，可以使key-value在不同函数间传递。例如上述代码中， <code>X-Request-ID</code> 在main函数、printString函数中的日志输出中均有记录，从而实现了一种调用链的效果。</p><p><strong>第四个方法，</strong> 可以很方便地从Context中提取出指定的key-value，作为上下文添加到日志输出中，例如  <a href=\"https://github.com/marmotedu/iam/blob/v1.0.0/internal/apiserver/api/v1/user/create.go#L20\">internal/apiserver/api/v1/user/create.go</a>文件中的日志调用：</p><pre><code>log.L(c).Info(&quot;user create function called.&quot;)\n</code></pre><p>通过调用 <code>Log.L()</code> 函数，实现如下：</p><pre><code>// L method output with specified context value.\nfunc L(ctx context.Context) *zapLogger {\n    return std.L(ctx)\n}\n \nfunc (l *zapLogger) L(ctx context.Context) *zapLogger {\n    lg := l.clone()\n \n    requestID, _ := ctx.Value(KeyRequestID).(string)\n    username, _ := ctx.Value(KeyUsername).(string)\n    lg.zapLogger = lg.zapLogger.With(zap.String(KeyRequestID, requestID), zap.String(KeyUsername, username))\n \n    return lg\n}\n</code></pre><p><code>L()</code> 方法会从传入的Context中提取出 <code>requestID</code> 和 <code>username</code> ，追加到Logger中，并返回Logger。这时候调用该Logger的Info、Infof、Infow等方法记录日志，输出的日志中均包含 <code>requestID</code> 和 <code>username</code> 字段，例如：</p><pre><code>2021-07-06 14:46:00.743 INFO    apiserver       secret/create.go:23     create secret function called.  {&quot;requestID&quot;: &quot;73144bed-534d-4f68-8e8d-dc8a8ed48507&quot;, &quot;username&quot;: &quot;admin&quot;}\n</code></pre><p>通过将Context在函数间传递，很容易就能实现调用链效果，例如：</p><pre><code>// Create add new secret key pairs to the storage.\nfunc (s *SecretHandler) Create(c *gin.Context) {\n    log.L(c).Info(&quot;create secret function called.&quot;)\n     \n    ...\n     \n    secrets, err := s.srv.Secrets().List(c, username, metav1.ListOptions{    \n        Offset: pointer.ToInt64(0),\n        Limit:  pointer.ToInt64(-1),\n    })\n     \n    ...\n     \n     if err := s.srv.Secrets().Create(c, &amp;r, metav1.CreateOptions{}); err != nil {\n        core.WriteResponse(c, err, nil)\n\n        return\n    }\n \n    core.WriteResponse(c, nil, r)\n}\n</code></pre><p>上述代码输出为：</p><pre><code>2021-07-06 14:46:00.743 INFO    apiserver       secret/create.go:23     create secret function called.  {&quot;requestID&quot;: &quot;73144bed-534d-4f68-8e8d-dc8a8ed48507&quot;, &quot;username&quot;: &quot;admin&quot;}\n2021-07-06 14:46:00.744 INFO    apiserver       secret/create.go:23     list secret from storage.  {&quot;requestID&quot;: &quot;73144bed-534d-4f68-8e8d-dc8a8ed48507&quot;, &quot;username&quot;: &quot;admin&quot;}\n2021-07-06 14:46:00.745 INFO    apiserver       secret/create.go:23     insert secret to storage.  {&quot;requestID&quot;: &quot;73144bed-534d-4f68-8e8d-dc8a8ed48507&quot;, &quot;username&quot;: &quot;admin&quot;}\n</code></pre><p>这里要注意， <code>log.L</code> 函数默认会从Context中取 <code>requestID</code> 和 <code>username</code> 键，这跟IAM项目有耦合度，但这不影响log包供第三方项目使用。这也是我建议你自己封装日志包的原因。</p><h2>总结</h2><p>开发一个日志包，我们很多时候需要基于一些业界优秀的开源日志包进行二次开发。当前很多项目的日志包都是基于zap日志包来封装的，如果你有封装的需要，我建议你优先选择zap日志包。</p><p>这一讲中，我先给你介绍了标准库log包、glog、logrus和zap这四种常用的日志包，然后向你展现了开发一个日志包的四个步骤，步骤如下：</p><ol>\n<li>定义日志级别和日志选项。</li>\n<li>创建Logger及各级别日志打印方法。</li>\n<li>将日志输出到支持的输出中。</li>\n<li>自定义日志输出格式。</li>\n</ol><p>最后，我介绍了IAM项目封装的log包的设计和使用方式。log包基于 <code>go.uber.org/zap</code>封装，并提供了以下强大特性：</p><ul>\n<li>log包支持V Level，可以灵活的通过整型数值来指定日志级别。</li>\n<li>log包支持 <code>WithValues</code> 函数， <code>WithValues</code> 可以返回一个携带指定key-value对的Logger，供后面使用。</li>\n<li>log包提供 <code>WithContext</code> 和 <code>FromContext</code> 用来将指定的Logger添加到某个Context中和从某个Context中获取Logger。</li>\n<li>log包提供了 <code>Log.L()</code> 函数，可以很方便的从Context中提取出指定的key-value对，作为上下文添加到日志输出中。</li>\n</ul><h2>课后练习</h2><ol>\n<li>\n<p>尝试实现一个新的Formatter，可以使不同日志级别以不同颜色输出（例如：Error级别的日志输出中 <code>Error</code> 字符串用红色字体输出， <code>Info</code> 字符串用白色字体输出）。</p>\n</li>\n<li>\n<p>尝试将<a href=\"https://github.com/marmotedu/gopractise-demo/blob/master/log/cuslog/entry.go#L36\">runtime.Caller(2)</a>函数调用中的 <code>2</code> 改成 <code>1</code> ，看看日志输出是否跟修改前有差异，如果有差异，思考差异产生的原因。</p>\n</li>\n</ol><p>欢迎你在留言区与我交流讨论，我们下一讲见。</p>","comments":[{"had_liked":false,"id":305522,"user_name":"ppd0705","can_delete":false,"product_type":"c1","uid":1155646,"ip_address":"","ucode":"EB63D4E3FD1E9A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKotsBr2icbYNYlRSlicGUD1H7lulSTQUAiclsEz9gnG5kCW9qeDwdYtlRMXic3V6sj9UrfKLPJnQojag/132","comment_is_top":false,"comment_ctime":1628008350,"is_pvip":false,"replies":[{"id":"110633","content":"回答满分！","user_name":"作者回复","user_name_real":"CK1.0","uid":"1167883","ctime":1628165491,"ip_address":"","comment_id":305522,"utype":1}],"discussion_count":1,"race_medal":0,"score":"53167615902","product_id":100079601,"comment_content":"Caller(skip int) 0代表当前层， 1代表上一次调用者，一次类推。 对于log包由于封装了2层（Entry.write --&gt; Debug），所以Caller(2)能得到用户函数的调用栈信息","like_count":11,"discussions":[{"author":{"id":1167883,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d2/0b/cdd0787a.jpg","nickname":"孔令飞","note":"","ucode":"8363EA4BD0AAF0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524415,"discussion_content":"回答满分！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628165491,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":349542,"user_name":"一念之间","can_delete":false,"product_type":"c1","uid":1562957,"ip_address":"","ucode":"25C6317C111F93","user_header":"https://static001.geekbang.org/account/avatar/00/17/d9/4d/def385e9.jpg","comment_is_top":false,"comment_ctime":1656055526,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10245990118","product_id":100079601,"comment_content":"没啥用，最重要的写入kafak,logstash只字未提，呵呵了","like_count":2},{"had_liked":false,"id":307234,"user_name":"Geek_399957","can_delete":false,"product_type":"c1","uid":2676396,"ip_address":"","ucode":"A121DE94B6EC6E","user_header":"","comment_is_top":false,"comment_ctime":1628956197,"is_pvip":false,"replies":[{"id":"111388","content":"是的哈，并发场景下没有问题","user_name":"作者回复","user_name_real":"CK1.0","uid":"1167883","ctime":1629242959,"ip_address":"","comment_id":307234,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10218890789","product_id":100079601,"comment_content":"如果我需要根据不同的场景输出到不同文件，是否每次都需要新建一个 log 呢，这样做并发情况下是否有问题呢","like_count":2,"discussions":[{"author":{"id":1167883,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d2/0b/cdd0787a.jpg","nickname":"孔令飞","note":"","ucode":"8363EA4BD0AAF0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525088,"discussion_content":"是的哈，并发场景下没有问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629242959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":304679,"user_name":"徐海浪","can_delete":false,"product_type":"c1","uid":1078528,"ip_address":"","ucode":"21801C420D0610","user_header":"https://static001.geekbang.org/account/avatar/00/10/75/00/618b20da.jpg","comment_is_top":false,"comment_ctime":1627547829,"is_pvip":false,"replies":[{"id":"110211","content":"老哥理解的很到位，1&#47;2是文件栈的深度。","user_name":"作者回复","user_name_real":"CK1.0","uid":"1167883","ctime":1627597425,"ip_address":"","comment_id":304679,"utype":1}],"discussion_count":1,"race_medal":1,"score":"10217482421","product_id":100079601,"comment_content":"尝试将runtime.Caller(2)函数调用中的 2 改成 1 ，看看日志输出是否跟修改前有差异，如果有差异，思考差异产生的原因。<br>------<br>*Entry.write:0 -&gt; cuslog.Info:1 -&gt; main.main:2 -&gt; ...<br>所以2是打印main函数的文件和行号，1打印的则是Info的文件和行号<br>还拓展了解到runtime.Caller(n)对日志组件性能的影响及其取舍","like_count":2,"discussions":[{"author":{"id":1167883,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d2/0b/cdd0787a.jpg","nickname":"孔令飞","note":"","ucode":"8363EA4BD0AAF0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524117,"discussion_content":"老哥理解的很到位，1/2是文件栈的深度。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627597425,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":302330,"user_name":"Nio","can_delete":false,"product_type":"c1","uid":1529642,"ip_address":"","ucode":"A1B8D3C01FB937","user_header":"https://static001.geekbang.org/account/avatar/00/17/57/2a/c6c95f37.jpg","comment_is_top":false,"comment_ctime":1626167817,"is_pvip":true,"replies":[{"id":"109490","content":"性能跟github.com&#47;pkg&#47;log性能接近一致。github.com&#47;pkg&#47;log这个包很多生产环境在用，所以iam的log包应用在生产环境完全没问题。<br><br>你要感兴趣，可以跟其它包对比下，比如：logrus，zap，glog等。也欢迎在留言区分享对比结果。","user_name":"作者回复","user_name_real":"CK1.0","uid":"1167883","ctime":1626280360,"ip_address":"","comment_id":302330,"utype":1}],"discussion_count":1,"race_medal":4,"score":"10216102409","product_id":100079601,"comment_content":"IAM 项目 log 包的性能比较大概是什么样子呢","like_count":2,"discussions":[{"author":{"id":1167883,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d2/0b/cdd0787a.jpg","nickname":"孔令飞","note":"","ucode":"8363EA4BD0AAF0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523263,"discussion_content":"性能跟github.com/pkg/log性能接近一致。github.com/pkg/log这个包很多生产环境在用，所以iam的log包应用在生产环境完全没问题。\n\n你要感兴趣，可以跟其它包对比下，比如：logrus，zap，glog等。也欢迎在留言区分享对比结果。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626280360,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":306888,"user_name":"Fan","can_delete":false,"product_type":"c1","uid":1115232,"ip_address":"","ucode":"3BF28670FD9407","user_header":"https://static001.geekbang.org/account/avatar/00/11/04/60/64d166b6.jpg","comment_is_top":false,"comment_ctime":1628764081,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5923731377","product_id":100079601,"comment_content":"这篇写得不错。","like_count":1},{"had_liked":false,"id":306776,"user_name":"Sch0ng","can_delete":false,"product_type":"c1","uid":1145554,"ip_address":"","ucode":"73F6113931B1AC","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/d2/4ba67c0c.jpg","comment_is_top":false,"comment_ctime":1628697242,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5923664538","product_id":100079601,"comment_content":"对log包有更全面的认识。<br>可以根据项目需要，对开源zap包进行二次封装。","like_count":1},{"had_liked":false,"id":304038,"user_name":"Alery","can_delete":false,"product_type":"c1","uid":1156557,"ip_address":"","ucode":"08F3F49181E67B","user_header":"https://static001.geekbang.org/account/avatar/00/11/a5/cd/3aff5d57.jpg","comment_is_top":false,"comment_ctime":1627202445,"is_pvip":false,"replies":[{"id":"110226","content":"你们的日志包兼容klog，这样k8s的日志，就会通过你们的日志包来打印了。格式的话，你们需要自己魔改适配","user_name":"作者回复","user_name_real":"CK1.0","uid":"1167883","ctime":1627598599,"ip_address":"","comment_id":304038,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5922169741","product_id":100079601,"comment_content":"你好，请教一个问题，k8s的库都是使用klog，我们工程需要引用k8s的库，但是我们自己工程使用的不是klog，这会导致打印出来的日志包含多种格式(我们自己工程的日志和k8s库打印的日志)。请问你们有什么好的解决办法吗？","like_count":1,"discussions":[{"author":{"id":1167883,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d2/0b/cdd0787a.jpg","nickname":"孔令飞","note":"","ucode":"8363EA4BD0AAF0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523909,"discussion_content":"你们的日志包兼容klog，这样k8s的日志，就会通过你们的日志包来打印了。格式的话，你们需要自己魔改适配","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627598599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":302183,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1105161,"ip_address":"","ucode":"1EECCA0F43E278","user_header":"https://static001.geekbang.org/account/avatar/00/10/dd/09/feca820a.jpg","comment_is_top":false,"comment_ctime":1626111946,"is_pvip":false,"replies":[{"id":"109334","content":"log.Int32直接指定了字段类型，log不需要再做反射，这种疾苦方式可以提高性能。<br><br><br>V Level可以允许指定任意优先级的日志级别。你可以参考glog的用法来理解V level。<br><br>有时候日志包预定义的日志级别可能不够用，这时候可以试试V Level","user_name":"作者回复","user_name_real":"CK1.0","uid":"1167883","ctime":1626142813,"ip_address":"","comment_id":302183,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5921079242","product_id":100079601,"comment_content":" log.Int32(&quot;int_key&quot;, 10)还有V Level这两处没有get到是干啥用的","like_count":1,"discussions":[{"author":{"id":1167883,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d2/0b/cdd0787a.jpg","nickname":"孔令飞","note":"","ucode":"8363EA4BD0AAF0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523211,"discussion_content":"log.Int32直接指定了字段类型，log不需要再做反射，这种疾苦方式可以提高性能。\n\n\nV Level可以允许指定任意优先级的日志级别。你可以参考glog的用法来理解V level。\n\n有时候日志包预定义的日志级别可能不够用，这时候可以试试V Level","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626142813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360039,"user_name":"tiny🌾","can_delete":false,"product_type":"c1","uid":1119851,"ip_address":"湖北","ucode":"7A4DE00381D1F3","user_header":"https://static001.geekbang.org/account/avatar/00/11/16/6b/af7c7745.jpg","comment_is_top":false,"comment_ctime":1666148306,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1666148306","product_id":100079601,"comment_content":"log输出文件不存在，会报出panic","like_count":0},{"had_liked":false,"id":349567,"user_name":"工程师_Eric","can_delete":false,"product_type":"c1","uid":1272568,"ip_address":"","ucode":"4440A1F187BEDA","user_header":"https://static001.geekbang.org/account/avatar/00/13/6a/f8/5d980054.jpg","comment_is_top":false,"comment_ctime":1656070203,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1656070203","product_id":100079601,"comment_content":"wow","like_count":0},{"had_liked":false,"id":348944,"user_name":"czy","can_delete":false,"product_type":"c1","uid":2398831,"ip_address":"","ucode":"660826F2ABA3E4","user_header":"https://static001.geekbang.org/account/avatar/00/24/9a/6f/c4490cf2.jpg","comment_is_top":false,"comment_ctime":1655605380,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655605380","product_id":100079601,"comment_content":"options的formatter字段并不是指针类型，在赋值的时候使用的是&amp;TextFormatter{}, 这不会报错吗？明显类型不匹配呀！","like_count":0},{"had_liked":false,"id":346018,"user_name":"Geek_6bdb4e","can_delete":false,"product_type":"c1","uid":2720810,"ip_address":"","ucode":"2953D400AA5385","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/xfclWEPQ7szTZnKqnX9icSbgDWV0VAib3Cyo8Vg0OG3Usby88ic7ZgO2ho5lj0icOWI4JeJ70zUBiaTW1xh1UCFRPqA/132","comment_is_top":false,"comment_ctime":1652770803,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1652770803","product_id":100079601,"comment_content":"如何实现在不同环境以不同的格式（prod: json, dev: console, local:console+enableColor）输出日志呢","like_count":0},{"had_liked":false,"id":346009,"user_name":"Geek_6bdb4e","can_delete":false,"product_type":"c1","uid":2720810,"ip_address":"","ucode":"2953D400AA5385","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/xfclWEPQ7szTZnKqnX9icSbgDWV0VAib3Cyo8Vg0OG3Usby88ic7ZgO2ho5lj0icOWI4JeJ70zUBiaTW1xh1UCFRPqA/132","comment_is_top":false,"comment_ctime":1652764818,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1652764818","product_id":100079601,"comment_content":"如果服务是部署在docker里面，该如何利用logrotate这个工具实现日志轮转呢","like_count":0},{"had_liked":false,"id":346001,"user_name":"Geek_6bdb4e","can_delete":false,"product_type":"c1","uid":2720810,"ip_address":"","ucode":"2953D400AA5385","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/xfclWEPQ7szTZnKqnX9icSbgDWV0VAib3Cyo8Vg0OG3Usby88ic7ZgO2ho5lj0icOWI4JeJ70zUBiaTW1xh1UCFRPqA/132","comment_is_top":false,"comment_ctime":1652760007,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1652760007","product_id":100079601,"comment_content":"我看了一下iam项目里面的log的使用方法，发现WIthValues这个方法使用的并不是很多，想问一下这个方法在项目里面的使用场景是什么呢？你看我这种使用场景的打开方式对不对，就是在internal目录里包含apiserver、authzserver等等，其下又分controller、service、store等模块，是不是可以在每个模块都利用lv := log.WithValues(&quot;module&quot;, &quot;apiserver&#47;controller&quot;)创建类似的一个logger供本模块使用？","like_count":0},{"had_liked":false,"id":341274,"user_name":"张浩轩","can_delete":false,"product_type":"c1","uid":1628040,"ip_address":"","ucode":"6CB5A6F6FA209B","user_header":"https://static001.geekbang.org/account/avatar/00/18/d7/88/6f6b245c.jpg","comment_is_top":false,"comment_ctime":1649493102,"is_pvip":true,"replies":[{"id":"125543","content":"可能需要切换一个支持error, info分别存放的日志包，例如：glog","user_name":"作者回复","user_name_real":"编辑","uid":"1167883","ctime":1651079310,"ip_address":"","comment_id":341274,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1649493102","product_id":100079601,"comment_content":"请问老师业务需要记录的错误日志怎么放到errorOutputPath中? 我看了example的示例，无法实现info error日志区分存放的功能。","like_count":0,"discussions":[{"author":{"id":1167883,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d2/0b/cdd0787a.jpg","nickname":"孔令飞","note":"","ucode":"8363EA4BD0AAF0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568237,"discussion_content":"可能需要切换一个支持error, info分别存放的日志包，例如：glog","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651079311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329448,"user_name":"爱学习的W","can_delete":false,"product_type":"c1","uid":2641096,"ip_address":"","ucode":"C66BFF0D54E57F","user_header":"https://static001.geekbang.org/account/avatar/00/28/4c/c8/77e4d78b.jpg","comment_is_top":false,"comment_ctime":1641352803,"is_pvip":false,"replies":[{"id":"120959","content":"2个是不同的模式，场景不同","user_name":"作者回复","user_name_real":"编辑","uid":"1167883","ctime":1642434964,"ip_address":"","comment_id":329448,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1641352803","product_id":100079601,"comment_content":"我想的是：用选项模式？ 为什么不用责任链模式","like_count":0,"discussions":[{"author":{"id":1167883,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d2/0b/cdd0787a.jpg","nickname":"孔令飞","note":"","ucode":"8363EA4BD0AAF0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546862,"discussion_content":"2个是不同的模式，场景不同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642434964,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327621,"user_name":"Geek_6bf2d9","can_delete":false,"product_type":"c1","uid":2475424,"ip_address":"","ucode":"46E03737E48456","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/c9xpiakQ3OC1AlfCeW03lLj3NuUjoLiaWD8DicQoibBgicM5icM936iaRMEJtjKqQgTGpmJALg6J56LXibjSib8e0UaRIJg/132","comment_is_top":false,"comment_ctime":1640195374,"is_pvip":false,"replies":[{"id":"119709","content":"可以参考这篇文章：https:&#47;&#47;www.jianshu.com&#47;p&#47;8fbbf6c012b2","user_name":"作者回复","user_name_real":"编辑","uid":"1167883","ctime":1640825967,"ip_address":"","comment_id":327621,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1640195374","product_id":100079601,"comment_content":"老师能不能大概指一下cuslog包里的logger结构体设计，为什么要加一个sync.Pool呢？这里是处于什么考虑？","like_count":0,"discussions":[{"author":{"id":1167883,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d2/0b/cdd0787a.jpg","nickname":"孔令飞","note":"","ucode":"8363EA4BD0AAF0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542655,"discussion_content":"可以参考这篇文章：https://www.jianshu.com/p/8fbbf6c012b2","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1640825967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":326078,"user_name":"Dpp的小跟班儿","can_delete":false,"product_type":"c1","uid":1566294,"ip_address":"","ucode":"4AF5F9892C575E","user_header":"https://static001.geekbang.org/account/avatar/00/17/e6/56/020f2209.jpg","comment_is_top":false,"comment_ctime":1639366498,"is_pvip":false,"replies":[{"id":"118316","content":"不支持。rotate建议通过旁路服务来实现。比如Linux自带的logrotate服务。<br><br>不建议日志包集成太复杂的功能。","user_name":"作者回复","user_name_real":"编辑","uid":"1167883","ctime":1639397399,"ip_address":"","comment_id":326078,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1639366498","product_id":100079601,"comment_content":"老师，该log包支持rotate功能吗？实际项目中是运维使用脚本控制日志大小呢，还是最好开发选用的log包就直接支持才是最佳解决方案呢？","like_count":0,"discussions":[{"author":{"id":1167883,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d2/0b/cdd0787a.jpg","nickname":"孔令飞","note":"","ucode":"8363EA4BD0AAF0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538303,"discussion_content":"不支持。rotate建议通过旁路服务来实现。比如Linux自带的logrotate服务。\n\n不建议日志包集成太复杂的功能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639397399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324598,"user_name":"liaomars","can_delete":false,"product_type":"c1","uid":2104856,"ip_address":"","ucode":"4FCA97EE9FB57D","user_header":"https://static001.geekbang.org/account/avatar/00/20/1e/18/9d1f1439.jpg","comment_is_top":false,"comment_ctime":1638514566,"is_pvip":false,"replies":[{"id":"118349","content":"加老师微信：nightskong，拉你入群，不会的话群里随时问，群里没反馈，可以直接@老师。<br><br>慢慢啃，总能学会的","user_name":"作者回复","user_name_real":"编辑","uid":"1167883","ctime":1639400145,"ip_address":"","comment_id":324598,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1638514566","product_id":100079601,"comment_content":"小白表示完全没看明白，手把手也不知道这个手从哪里下 捂脸","like_count":0,"discussions":[{"author":{"id":1167883,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d2/0b/cdd0787a.jpg","nickname":"孔令飞","note":"","ucode":"8363EA4BD0AAF0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538346,"discussion_content":"加老师微信：nightskong，拉你入群，不会的话群里随时问，群里没反馈，可以直接@老师。\n\n慢慢啃，总能学会的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639400145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319930,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1105161,"ip_address":"","ucode":"1EECCA0F43E278","user_header":"https://static001.geekbang.org/account/avatar/00/10/dd/09/feca820a.jpg","comment_is_top":false,"comment_ctime":1636011965,"is_pvip":false,"replies":[{"id":"116893","content":"这个地方的日志，主要是debug的时候用的，没有标准答案。<br>可以根据自己的需要记录日志。如果后期需要根据path、status等来过滤日志，是可以将这些记录成key&amp;#47;value的形式。","user_name":"作者回复","user_name_real":"编辑","uid":"1167883","ctime":1637079203,"ip_address":"","comment_id":319930,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1636011965","product_id":100079601,"comment_content":"关于中间件logger, 当启用json模式记录日志后的心态如下:<br><br>{&quot;level&quot;:&quot;INFO&quot;,&quot;timestamp&quot;:&quot;2021-11-04 15:20:07.638&quot;,&quot;caller&quot;:&quot;middleware&#47;logger.go:129&quot;,&quot;message&quot;:&quot;500 - [10.2.14.14] \\&quot;1.745536ms GET &#47;v1&#47;users&#47;levin\\&quot; &quot;,&quot;x-request-id&quot;:&quot;0103dc05-f652-4b8c-bdcb-b20280da9936&quot;,&quot;username&quot;:&quot;&quot;}<br><br>我发现logger中间件将http状态码、请求method、请求耗时、请求path等都塞在了message字段中, 这样后期进行日志分析时, 是否不利于根据状态码等信息进行日志过滤, 这些请求与响应信息是否应该按key&#47;value独立之短的形式输出呢? 当然这样做也有缺点, 就是中间件logger产生的访问日志的字段数量就没办法和其他地方打印的日志字段统一了.  不知道应该如何权衡呢<br>","like_count":0,"discussions":[{"author":{"id":1167883,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d2/0b/cdd0787a.jpg","nickname":"孔令飞","note":"","ucode":"8363EA4BD0AAF0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530531,"discussion_content":"这个地方的日志，主要是debug的时候用的，没有标准答案。\n可以根据自己的需要记录日志。如果后期需要根据path、status等来过滤日志，是可以将这些记录成key/value的形式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637079203,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":318727,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1105161,"ip_address":"","ucode":"1EECCA0F43E278","user_header":"https://static001.geekbang.org/account/avatar/00/10/dd/09/feca820a.jpg","comment_is_top":false,"comment_ctime":1635404450,"is_pvip":false,"replies":[{"id":"116902","content":"github.com&amp;#47;marmotedu&amp;#47;iam&amp;#47;pkg&amp;#47;log 这个包没有bug。<br><br>之所以打印了299条，是因为里面有很多log内容是完全重复的，包括时间戳，msg等等，zap会对这些完全一样的log去重。在实际开发中，时间戳，日志内容完全一致概率几乎为0.","user_name":"作者回复","user_name_real":"编辑","uid":"1167883","ctime":1637102514,"ip_address":"","comment_id":318727,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1635404450","product_id":100079601,"comment_content":"发现iam项目的log包有个严重的bug, 测试大批量写日志到文件, 只能成功写入一小部分, 比如:<br>        defer log.Flush()<br>\tfor i := 0; i &lt;= 20000; i++ {<br>\t\tlog.Info(&quot;hello world&quot;)<br>\t}<br> 只能成功写入299条日志, 预期应该是2万条日志.<br><br>log包: github.com&#47;marmotedu&#47;iam&#47;pkg&#47;log<br>","like_count":0,"discussions":[{"author":{"id":1167883,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d2/0b/cdd0787a.jpg","nickname":"孔令飞","note":"","ucode":"8363EA4BD0AAF0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530553,"discussion_content":"github.com/marmotedu/iam/pkg/log 这个包没有bug。\n\n之所以打印了299条，是因为里面有很多log内容是完全重复的，包括时间戳，msg等等，zap会对这些完全一样的log去重。在实际开发中，时间戳，日志内容完全一致概率几乎为0.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637102514,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1105161,"avatar":"https://static001.geekbang.org/account/avatar/00/10/dd/09/feca820a.jpg","nickname":"helloworld","note":"","ucode":"1EECCA0F43E278","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411786,"discussion_content":"貌似也不是bug，打印循环变量就可以打全部的日志了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636005471,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":318382,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1105161,"ip_address":"","ucode":"1EECCA0F43E278","user_header":"https://static001.geekbang.org/account/avatar/00/10/dd/09/feca820a.jpg","comment_is_top":false,"comment_ctime":1635262885,"is_pvip":false,"replies":[{"id":"115977","content":"好建议，我记录下，后面优化下。<br><br>之前在开发的时候，也有纠结放哪里。当时放在pkg&#47;log下，能提供外部程序这么用。但其实，这2个功能相对来说还是偏定制化。","user_name":"作者回复","user_name_real":"孔令飞","uid":"1167883","ctime":1636005018,"ip_address":"","comment_id":318382,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1635262885","product_id":100079601,"comment_content":"个人感觉pkg&#47;log包的Options结构体的Addflags方法和validate方法放到internal&#47;pkg&#47;options&#47;log.go文件中更优雅和一致一些.","like_count":0,"discussions":[{"author":{"id":1167883,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d2/0b/cdd0787a.jpg","nickname":"孔令飞","note":"","ucode":"8363EA4BD0AAF0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529214,"discussion_content":"好建议，我记录下，后面优化下。\n\n之前在开发的时候，也有纠结放哪里。当时放在pkg/log下，能提供外部程序这么用。但其实，这2个功能相对来说还是偏定制化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636005018,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":316372,"user_name":"授人以🐟，不如授人以渔","can_delete":false,"product_type":"c1","uid":1193874,"ip_address":"","ucode":"BD53829E924B66","user_header":"https://static001.geekbang.org/account/avatar/00/12/37/92/961ba560.jpg","comment_is_top":false,"comment_ctime":1634289873,"is_pvip":true,"replies":[{"id":"114924","content":"正常，哈哈，我之前在写的时候也是这种感觉。后来开发项目的时候，自己动手去设计了一个errors包，才变得熟悉起来。<br><br>你看是否能根据自己当前的工作需求，设计一个errors包？","user_name":"作者回复","user_name_real":"孔令飞","uid":"1167883","ctime":1634737813,"ip_address":"","comment_id":316372,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1634289873","product_id":100079601,"comment_content":"孔老师，看了 errors 包的代码，仍然觉得手生，怎么办？是写少了吗？","like_count":0,"discussions":[{"author":{"id":1167883,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d2/0b/cdd0787a.jpg","nickname":"孔令飞","note":"","ucode":"8363EA4BD0AAF0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528372,"discussion_content":"正常，哈哈，我之前在写的时候也是这种感觉。后来开发项目的时候，自己动手去设计了一个errors包，才变得熟悉起来。\n\n你看是否能根据自己当前的工作需求，设计一个errors包？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634737813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":315758,"user_name":"lesserror","can_delete":false,"product_type":"c1","uid":1351076,"ip_address":"","ucode":"25A54D1165FCF6","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","comment_is_top":false,"comment_ctime":1633966009,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633966009","product_id":100079601,"comment_content":"这节干货挺多。<br><br>源码只读了部分，感觉封装的复杂度还是很高的，尤其是 iam 项目的这个 log包。","like_count":0}]}