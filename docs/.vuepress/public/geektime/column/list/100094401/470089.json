{"id":470089,"title":"28｜响应式：万能的面试题，怎么手写响应式系统","content":"<p>你好，我是大圣。</p><p>经过前面课程的学习，相信你对Vue3的实战和组件有了新的认识，也掌握了很多实战秘籍，从今天开始，我将带你进入Vue框架的内部世界，探究一下Vue框架的原理，让你能知其然，也知其所以然。</p><p>我们将手写一个迷你的Vue框架，实现Vue3的主要渲染和更新逻辑，项目就叫weiyouyi，你可以在 <a href=\"https://github.com/shengxinjing/weiyouyi\">GitHub上</a>看到所有的核心代码。</p><h2>响应式</h2><p>在第三讲的Vue3新特性中，我们剖析了Vue3的功能结构，就是下图所示的Vue核心模块，可以看到，Vue3的组件之间是通过响应式机制来通知的，响应式机制可以自动收集系统中数据的依赖，并且在修改数据之后自动执行更新，极大提高开发的效率。</p><p>我们今天就要自己做一个迷你的响应式原型，希望你能通过自己手写，搞清楚响应式的实现原理。</p><p><img src=\"https://static001.geekbang.org/resource/image/7e/9e/7e68a41ef94a39eda9cf211ed479e39e.png?wh=1920x939\" alt=\"图片\"></p><p>根据响应式组件通知效果可以知道，<strong>响应式机制的主要功能就是，可以把普通的JavaScript对象封装成为响应式对象，拦截数据的获取和修改操作，实现依赖数据的自动化更新</strong>。</p><p>所以，一个最简单的响应式模型，我们可以通过reactive或者ref函数，把数据包裹成响应式对象，并且通过effect函数注册回调函数，然后在数据修改之后，响应式地通知effect去执行回调函数即可。</p><!-- [[[read_end]]] --><p>整个流程这么概括地说，你估计不太理解，我们先通过一个简单的小例子直观感受一下响应式的效果。</p><p>Vue的响应式是可以独立在其他平台使用的。比如你可以新建test.js，使用下面的代码在node环境中使用Vue响应。以reactive为例，我们使用reactive包裹JavaScript对象之后，每一次对响应式对象counter的修改，都会执行effect内部注册的函数：</p><pre><code class=\"language-javascript\">const {effect, reactive} = require('@vue/reactivity')\n\nlet dummy\nconst counter = reactive({ num1: 1, num2: 2 })\neffect(() =&gt; {\n  dummy = counter.num1 + counter.num2\n  console.log(dummy)// 每次counter.num1修改都会打印日志\n})\nsetInterval(()=&gt;{\n  counter.num1++\n},1000)\n</code></pre><p>执行node test.js之后，你就可以看到effect内部的函数会一直调用，每次count.value修改之后都会执行。<br>\n看到这个API估计你有点疑惑，effect内部的函数式如何知道count已经变化了呢？</p><p>我们先来看一下响应式整体的流程图，上面的代码中我们使用reactive把普通的JavaScript对象包裹成响应式数据了。</p><p>所以，在effect中获取counter.num1和counter.num2的时候，就会触发counter的get拦截函数；<strong>get函数，会把当前的effect函数注册到一个全局的依赖地图中去</strong>。这样counter.num1在修改的时候，<strong>就会触发set拦截函数，去依赖地图中找到注册的effect函数，然后执行</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/0a/d0/0a3f06629751988996e1f863e0973cd0.jpg?wh=2012x796\" alt=\"\"><br>\n具体是怎么实现的呢？我们从第一步把数据包裹成响应式对象开始。先看reactive的实现。</p><h2>reactive</h2><p>我们进入到src/reactivity目录中，新建reactive.spec.js，使用下面代码测试reactive的功能，能够在响应式数据ret更新之后，执行effect中注册的函数：</p><pre><code class=\"language-javascript\">import { effect } from '../effect'\nimport { reactive } from '../reactive'\n\ndescribe('测试响应式', () =&gt; {\n  test('reactive基本使用', () =&gt; {\n    const ret = reactive({ num: 0 })\n    let val\n    effect(() =&gt; {\n      val = ret.num\n    })\n    expect(val).toBe(0)\n    ret.num++\n    expect(val).toBe(1)\n    ret.num = 10\n    expect(val).toBe(10)\n  })\n})\n</code></pre><p>之前讲过在Vue3中，reactive是通过ES6中的Proxy特性实现的属性拦截，所以，在reactive函数中我们直接返回newProxy即可：</p><pre><code class=\"language-javascript\">export function reactive(target) {\n  if (typeof target!=='object') {\n    console.warn(`reactive  ${target} 必须是一个对象`);\n    return target\n  }\n\n  return new Proxy(target, mutableHandlers);\n}\n</code></pre><p>可以看到，<strong>下一步我们需要实现的就是Proxy中的处理方法mutableHandles</strong>。</p><p>这里会把Proxy的代理配置抽离出来单独维护，是因为，其实Vue3中除了reactive还有很多别的函数需要实现，比如只读的响应式数据、浅层代理的响应式数据等，并且reactive中针对ES6的代理也需要单独的处理。</p><p>这里我们只处理js中对象的代理设置：</p><pre><code class=\"language-javascript\">  const proxy = new Proxy(target, mutableHandlers)\n</code></pre><h3>mutableHandles</h3><p>好，看回来，我们剖析mutableHandles。它要做的事就是配置Proxy的拦截函数，这里我们只拦截get和set操作，进入到baseHandlers.js文件中。</p><p>我们使用createGetter和createSetters来创建set和get函数，mutableHandles就是配置了set和get的对象返回。</p><ul>\n<li>get中直接返回读取的数据，这里的Reflect.get和target[key]实现的结果是一致的；并且返回值是对象的话，还会嵌套执行reactive，并且调用track函数收集依赖。</li>\n<li>set中调用trigger函数，执行track收集的依赖。</li>\n</ul><pre><code class=\"language-javascript\">const get = createGetter();\nconst set = createSetter();\n\nfunction createGetter(shallow = false) {\n  return function get(target, key, receiver) {\n    const res = Reflect.get(target, key, receiver)\n    track(target, \"get\", key)\n    if (isObject(res)) {\n      // 值也是对象的话，需要嵌套调用reactive\n      // res就是target[key]\n      // 浅层代理，不需要嵌套\n      return shallow ? res : reactive(res)\n    }\n    return res\n  }\n}\n\nfunction createSetter() {\n  return function set(target, key, value, receiver) {\n    const result = Reflect.set(target, key, value, receiver)\n    // 在触发 set 的时候进行触发依赖\n    trigger(target, \"set\", key)\n    return result\n  }\n}\nexport const mutableHandles = {\n  get,\n  set,\n};\n</code></pre><p>我们先看get的关键部分，track函数是怎么完成依赖收集的。</p><h3>track</h3><p>具体写代码之前，把依赖收集和执行的原理我们梳理清楚，看下面的示意图：</p><p><img src=\"https://static001.geekbang.org/resource/image/83/a9/836a798f28824fcf54c0fc280b8afca9.jpg?wh=1945x1500\" alt=\"\"></p><p>在track函数中，我们可以使用一个巨大的tragetMap去存储依赖关系。<strong>map的key是我们要代理的target对象，值还是一个depsMap</strong>，存储这每一个key依赖的函数，每一个key都可以依赖多个effect。上面的代码执行完成，depsMap中就有了num1和num2两个依赖。</p><p>而依赖地图的格式，用代码描述如下：</p><pre><code class=\"language-javascript\">targetMap = {\n target： {\n   key1: [回调函数1，回调函数2],\n   key2: [回调函数3，回调函数4],\n }  ,\n  target1： {\n   key3: [回调函数5]\n }  \n\n}\n</code></pre><p>好，有了大的设计思路，我们来进行具体的实现，在reactive下新建effect.js。</p><p>由于target是对象，所以必须得用map才可以把target作为key来管理数据，每次操作之前需要做非空的判断。最终把activeEffect存储在集合之中：</p><pre><code class=\"language-javascript\">const targetMap = new WeakMap()\n\nexport function track(target, type, key) {\n\n  // console.log(`触发 track -&gt; target: ${target} type:${type} key:${key}`)\n\n  // 1. 先基于 target 找到对应的 dep\n  // 如果是第一次的话，那么就需要初始化\n  // {\n  //   target1: {//depsmap\n  //     key:[effect1,effect2]\n  //   }\n  // }\n  let depsMap = targetMap.get(target)\n  if (!depsMap) {\n    // 初始化 depsMap 的逻辑\n    // depsMap = new Map()\n    // targetMap.set(target, depsMap)\n    // 上面两行可以简写成下面的\n    targetMap.set(target, (depsMap = new Map()))\n  }\n  let deps = depsMap.get(key)\n  if (!deps) {\n    deps = new Set()\n  }\n  if (!deps.has(activeEffect) &amp;&amp; activeEffect) {\n    // 防止重复注册\n    deps.add(activeEffect)\n  }\n  depsMap.set(key, deps)\n}\n</code></pre><p>get中关键的收集依赖的track函数我们已经讲完了，继续看set中关键的trigger函数。</p><h3>trigger</h3><p>有了上面targetMap的实现机制，<strong>trigger函数实现的思路就是从targetMap中，根据target和key找到对应的依赖函数集合deps，然后遍历deps执行依赖函数</strong>。</p><p>看实现的代码：</p><pre><code>export function trigger(target, type, key) {\n  // console.log(`触发 trigger -&gt; target:  type:${type} key:${key}`)\n  // 从targetMap中找到触发的函数，执行他\n  const depsMap = targetMap.get(target)\n  if (!depsMap) {\n    // 没找到依赖\n    return\n  }\n  const deps = depsMap.get(key)\n  if (!deps) {\n    return\n  }\n  deps.forEach((effectFn) =&gt; {\n\n    if (effectFn.scheduler) {\n      effectFn.scheduler()\n    } else {\n      effectFn()\n    }\n  })\n  \n}\n</code></pre><p>可以看到执行的是effect的scheduler或者run函数，这是因为我们需要在effect函数中把依赖函数进行包装，并对依赖函数的执行时机进行控制，这是一个小的设计点。</p><h3>effect</h3><p>然后我们来实现effect函数。</p><p>下面的代码中，我们把传递进来的fn函数通过effectFn函数包裹执行，在effectFn函数内部，把函数赋值给全局变量activeEffect；然后执行fn()的时候，就会触发响应式对象的get函数，get函数内部就会把activeEffect存储到依赖地图中，完成依赖的收集：</p><pre><code class=\"language-javascript\">export function effect(fn, options = {}) {\n  // effect嵌套，通过队列管理\n  const effectFn = () =&gt; {\n    try {\n      activeEffect = effectFn\n      //fn执行的时候，内部读取响应式数据的时候，就能在get配置里读取到activeEffect\n      return fn()\n    } finally {\n      activeEffect = null\n    }\n  }\n  if (!options.lazy) {\n    //没有配置lazy 直接执行\n    effectFn()\n  }\n  effectFn.scheduler = options.scheduler // 调度时机 watchEffect回用到\n  return effectFn\n  \n}\n</code></pre><p>effect传递的函数，比如可以通过传递lazy和scheduler来控制函数执行的时机，默认是同步执行。</p><p>scheduler存在的意义就是我们可以手动控制函数执行的时机，方便应对一些性能优化的场景，比如数据在一次交互中可能会被修改很多次，我们不想每次修改都重新执行依次effect函数，而是合并最终的状态之后，最后统一修改一次。</p><p>scheduler怎么用你可以看下面的代码，我们使用数组管理传递的执行任务，最后使用Promise.resolve只执行最后一次，这也是Vue中watchEffect函数的大致原理。</p><pre><code class=\"language-javascript\">const obj = reactive({ count: 1 })\neffect(() =&gt; {\n  console.log(obj.count)\n}, {\n  // 指定调度器为 queueJob\n  scheduler: queueJob\n})\n// 调度器实现\nconst queue: Function[] = []\nlet isFlushing = false\nfunction queueJob(job: () =&gt; void) {\n  if (!isFlushing) {\n    isFlushing = true\n    Promise.resolve().then(() =&gt; {\n      let fn\n      while(fn = queue.shift()) {\n        fn()\n      }\n    })\n  }\n}\n</code></pre><p>好了，绕了这么一大圈终于执行完了函数，估计你也看出来了封装了很多层。</p><p><strong>之所以封装这么多层就是因为，Vue的响应式本身有很多的横向扩展</strong>，除了响应式的封装，还有只读的拦截、浅层数据的拦截等等，这样，响应式系统本身也变得更加灵活和易于扩展，我们自己在设计公用函数的时候也可以借鉴类似的思路。</p><h2>另一个选择ref函数</h2><p>有了track和trigger的逻辑之后，我们用ref函数实现就变得非常简单了。</p><p>ref的执行逻辑要比reactive要简单一些，不需要使用Proxy代理语法，直接使用对象语法的getter和setter配置，监听value属性即可。</p><p>看下面的实现，在ref函数返回的对象中，对象的get value方法，使用track函数去收集依赖，set value方法中使用trigger函数去触发函数的执行。</p><pre><code class=\"language-javascript\">export function ref(val) {\n  if (isRef(val)) {\n    return val\n  }\n  return new RefImpl(val)\n}\nexport function isRef(val) {\n  return !!(val &amp;&amp; val.__isRef)\n}\n\n// ref就是利用面向对象的getter和setters进行track和trigget\nclass RefImpl {\n  constructor(val) {\n    this.__isRef = true\n    this._val = convert(val)\n  }\n  get value() {\n    track(this, 'value')\n    return this._val\n  }\n\n  set value(val) {\n    if (val !== this._val) {\n      this._val = convert(val)\n      trigger(this, 'value')\n    }\n  }\n}\n\n// ref也可以支持复杂数据结构\nfunction convert(val) {\n  return isObject(val) ? reactive(val) : val\n}\n</code></pre><p>你能很直观地看到，ref函数实现的相对简单很多，只是利用面向对象的getter和setter拦截了value属性的读写，这也是为什么我们需要操作ref对象的value属性的原因。</p><p><strong>值得一提的是，ref也可以包裹复杂的数据结构，内部会直接调用reactive来实现</strong>，这也解决了大部分同学对ref和reactive使用时机的疑惑，现在你可以全部都用ref函数，ref内部会帮你调用reactive。</p><h2>computed</h2><p>Vue中的computed计算属性也是一种特殊的effect函数，我们可以新建computed.spec.js来测试computed函数的功能，<strong>computed可以传递一个函数或者对象，实现计算属性的读取和修改</strong>。比如说可以这么用：</p><pre><code class=\"language-javascript\">mport {  ref } from '../ref'\nimport {  reactive } from '../reactive'\nimport { computed } from '../computed'\n\n\n\ndescribe('computed测试',()=&gt;{\n  it('computed基本使用',()=&gt;{\n    const ret = reactive({ count: 1 })\n    const num = ref(2)\n    const sum = computed(() =&gt; num.value + ret.count)\n    expect(sum.value).toBe(3)\n\n    ret.count++\n    expect(sum.value).toBe(4)\n    num.value = 10\n    expect(sum.value).toBe(12)\n  })\n  it('computed属性修改',()=&gt;{\n    const author = ref('大圣')\n    const course = ref('玩转Vue3')\n    const title = computed({\n      get(){\n        return author.value+\":\"+course.value\n      },\n      set(val){\n        [author.value,course.value] = val.split(':')\n      }\n    })\n    expect(title.value).toBe('大圣:玩转Vue3')\n\n    author.value=\"winter\"\n    course.value=\"重学前端\"\n    expect(title.value).toBe('winter:重学前端')\n    //计算属性赋值\n    title.value = '王争:数据结构与算法之美'\n    expect(author.value).toBe('王争')\n    expect(course.value).toBe('数据结构与算法之美')\n\n  })\n})\n</code></pre><p>怎么实现呢？我们新建computed函数，看下面的代码，我们拦截computed的value属性，并且定制了effect的lazy和scheduler配置，computed注册的函数就不会直接执行，而是要通过scheduler函数中对_dirty属性决定是否执行。</p><pre><code class=\"language-javascript\">export function computed(getterOrOptions) {\n  // getterOrOptions可以是函数，也可以是一个对象，支持get和set\n  // 还记得清单应用里的全选checkbox就是一个对象配置的computed\n  let getter, setter\n  if (typeof getterOrOptions === 'function') {\n    getter = getterOrOptions\n    setter = () =&gt; {\n      console.warn('计算属性不能修改')\n    }\n  } else {\n    getter = getterOrOptions.get\n    setter = getterOrOptions.set\n  }\n  return new ComputedRefImpl(getter, setter)\n}\nclass ComputedRefImpl {\n  constructor(getter, setter) {\n    this._setter = setter\n    this._val = undefined\n    this._dirty = true\n    // computed就是一个特殊的effect，设置lazy和执行时机\n    this.effect = effect(getter, {\n      lazy: true,\n      scheduler: () =&gt; {\n        if (!this._dirty) {\n          this._dirty = true\n          trigger(this, 'value')\n        }\n      },\n    })\n  }\n  get value() {\n    track(this, 'value')\n    if (this._dirty) {\n      this._dirty = false\n      this._val = this.effect()\n    }\n    return this._val\n  }\n  set value(val) {\n    this._setter(val)\n  }\n}\n</code></pre><h2>总结</h2><p>最后我们来回顾一下今天学到的内容。通过手写迷你的响应式原型，我们学习了Vue中响应式的地位和架构。</p><p>响应式的主要功能就是可以把普通的JavaScript对象封装成为响应式对象，<strong>在读取数据的时候通过track收集函数的依赖关系，把整个对象和effect注册函数的依赖关系全部存储在一个依赖图中</strong>。</p><p>定义的dependsMap是一个巨大的Map数据，effect函数内部读取的数据都会存储在dependsMap中，数据在修改的时候，通过查询dependsMap，获得需要执行的函数，再去执行即可。</p><p>dependsMap中存储的也不是直接存储effect中传递的函数，而是包装了一层对象对这个函数的执行实际进行管理，内部可以通过active管理执行状态，还可以通过全局变量shouldTrack控制监听状态，并且执行的方式也是判断scheduler和run方法，实现了对性能的提升。</p><p>我们在日常项目开发中也可以<strong>借鉴响应式的处理思路，使用通知的机制，来调用具体数据的操作和更新逻辑</strong>，灵活使用effect、ref、reactive等函数把常见的操作全部变成响应式数据处理，会极大的提高我们开发的体验和效率。</p><h2>思考题</h2><p>最后留一个思考题，Vue3.2对响应式有一个性能的进一步提升，你都了解到有哪些呢？欢迎你在评论区分享自己的思考，我们下一讲再见。</p>","neighbors":{"left":{"article_title":"27｜自定义渲染器：如何实现Vue的跨端渲染 ？","id":470087},"right":{"article_title":"29｜运行时：Vue在浏览器里是怎么跑起来的？","id":471006}},"comments":[{"had_liked":false,"id":327834,"user_name":"润培","can_delete":false,"product_type":"c1","uid":1334652,"ip_address":"","ucode":"1CC2CD568CECC5","user_header":"https://static001.geekbang.org/account/avatar/00/14/5d/7c/3cfece5e.jpg","comment_is_top":false,"comment_ctime":1640321252,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"48884961508","product_id":100094401,"comment_content":"相比于 Vue2 使用的 Object.defineProperty，Vue3 不需要提前递归收集依赖，初始化的速度更快；<br>Vue2 收集依赖的过程中会产生很多的 Dep 对象，Vue3 可以节省这部分的内存开销；<br>Vue2 无法监听数组、对象的动态添加、删除，需要通过 $set、$delete，增加学习成本；<br>Vue2 无法监听 Set、Map，只能处理普通对象。","like_count":12},{"had_liked":false,"id":331572,"user_name":"Geek_13e539","can_delete":false,"product_type":"c1","uid":2287908,"ip_address":"","ucode":"2A702A53CFFC2B","user_header":"https://static001.geekbang.org/account/avatar/00/22/e9/24/d9ee5e61.jpg","comment_is_top":false,"comment_ctime":1642659775,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"27412463551","product_id":100094401,"comment_content":"computed的讲解还能再详细一点么？看了几次 也还是没太理解","like_count":7},{"had_liked":false,"id":327828,"user_name":"润培","can_delete":false,"product_type":"c1","uid":1334652,"ip_address":"","ucode":"1CC2CD568CECC5","user_header":"https://static001.geekbang.org/account/avatar/00/14/5d/7c/3cfece5e.jpg","comment_is_top":false,"comment_ctime":1640318209,"is_pvip":false,"replies":[{"id":"119365","content":"给力给力","user_name":"作者回复","comment_id":327828,"uid":"1003715","ip_address":"","utype":1,"ctime":1640328577,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"23115154689","product_id":100094401,"comment_content":"刚刚提了一个PR","like_count":5,"discussions":[{"author":{"id":1003715,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/50/c3/0aa50246.jpg","nickname":"花果山大圣","note":"","ucode":"25C0A36D628037","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541311,"discussion_content":"给力给力","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640328577,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327833,"user_name":"小胖","can_delete":false,"product_type":"c1","uid":1098584,"ip_address":"","ucode":"B1C0EFDD821630","user_header":"https://static001.geekbang.org/account/avatar/00/10/c3/58/ba171e09.jpg","comment_is_top":false,"comment_ctime":1640319396,"is_pvip":false,"replies":[{"id":"119366","content":"已经支持这个测试案例了，把deps.add移到！dep的判断外层","user_name":"作者回复","comment_id":327833,"uid":"1003715","ip_address":"","utype":1,"ctime":1640328613,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"14525221284","product_id":100094401,"comment_content":"track函数哪里，依赖的添加，最后老师的判断是有问题的，那样写的话对于一个key就只能添加一次依赖。<br>&#47;&#47; 测试用例改成下面这样，就过不了了<br>    let val<br>    let val2 <br>    effect(()=&gt;{<br>      val = ret.num<br>    })<br>    effect(()=&gt;{<br>      val2 = ret.num<br>    })<br>    expect(val).toBe(0)<br>    expect(val2).toBe(0)<br>","like_count":3,"discussions":[{"author":{"id":1003715,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/50/c3/0aa50246.jpg","nickname":"花果山大圣","note":"","ucode":"25C0A36D628037","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541312,"discussion_content":"已经支持这个测试案例了，把deps.add移到！dep的判断外层","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640328613,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339138,"user_name":"Hector","can_delete":false,"product_type":"c1","uid":1496889,"ip_address":"","ucode":"110CAF87ADDC01","user_header":"https://static001.geekbang.org/account/avatar/00/16/d7/39/6698b6a9.jpg","comment_is_top":false,"comment_ctime":1647936742,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10237871334","product_id":100094401,"comment_content":"这一篇搭配《vue.js的设计与实现》真是相得益彰。","like_count":2},{"had_liked":false,"id":327825,"user_name":"Kim Yin","can_delete":false,"product_type":"c1","uid":1051165,"ip_address":"","ucode":"9BBD367E6F0569","user_header":"https://static001.geekbang.org/account/avatar/00/10/0a/1d/269a15c3.jpg","comment_is_top":false,"comment_ctime":1640317701,"is_pvip":true,"replies":[{"id":"119369","content":"已经加上了这个test，deps.has判断移动到if外面了，灰常感谢提出bug","user_name":"作者回复","comment_id":327825,"uid":"1003715","ip_address":"","utype":1,"ctime":1640329323,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"10230252293","product_id":100094401,"comment_content":"track 函数的 20~27 行好像有点问题，感觉应该把 22~26 行移到 if (!deps) 外面，不然 deps = new Set() 以后，if (!deps.has(activeEffect) &amp;&amp; activeEffect) 这句判断就没意思了 —— deps.has(activeEffect) 永远为 false<br>","like_count":2,"discussions":[{"author":{"id":1003715,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/50/c3/0aa50246.jpg","nickname":"花果山大圣","note":"","ucode":"25C0A36D628037","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541315,"discussion_content":"已经加上了这个test，deps.has判断移动到if外面了，灰常感谢提出bug","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640329323,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358244,"user_name":"Soffio","can_delete":false,"product_type":"c1","uid":3167662,"ip_address":"广东","ucode":"386C0963A7D356","user_header":"https://static001.geekbang.org/account/avatar/00/30/55/ae/de8cf97c.jpg","comment_is_top":false,"comment_ctime":1664111535,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664111535","product_id":100094401,"comment_content":"思考题：新增v-memo，核心作用是复用vnode。","like_count":0},{"had_liked":false,"id":353717,"user_name":"Geek_39e094","can_delete":false,"product_type":"c1","uid":3086246,"ip_address":"广东","ucode":"8A39548E6A6EF8","user_header":"","comment_is_top":false,"comment_ctime":1659692173,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1659692173","product_id":100094401,"comment_content":"好像监听不到外层对象的变化，只能监听到具体值，","like_count":0},{"had_liked":false,"id":353172,"user_name":"xiao.pao","can_delete":false,"product_type":"c1","uid":2983501,"ip_address":"立陶宛","ucode":"03326858915EA8","user_header":"https://static001.geekbang.org/account/avatar/00/2d/86/4d/0c256171.jpg","comment_is_top":false,"comment_ctime":1659233713,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1659233713","product_id":100094401,"comment_content":"大佬，调度器是不是写的有问题？trigger() 中调用时直接effect.scheduler()，没有将job:()=&gt;void作为参数回传给调度器，那也就控制不了时机吧<br>","like_count":0},{"had_liked":false,"id":348350,"user_name":"来个offer","can_delete":false,"product_type":"c1","uid":1835816,"ip_address":"","ucode":"EDBBCF58602F47","user_header":"https://static001.geekbang.org/account/avatar/00/1c/03/28/af78a720.jpg","comment_is_top":false,"comment_ctime":1655014189,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655014189","product_id":100094401,"comment_content":"哪里来的activeEffect？没看到啊","like_count":0},{"had_liked":false,"id":345221,"user_name":"段帅帅","can_delete":false,"product_type":"c1","uid":1249969,"ip_address":"","ucode":"2675BC0BE154E8","user_header":"https://static001.geekbang.org/account/avatar/00/13/12/b1/3a112b27.jpg","comment_is_top":false,"comment_ctime":1652142422,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1652142422","product_id":100094401,"comment_content":"effect中存在调度器函数的情况下.除了初始化会执行fn，之后都会执行调度器函数？","like_count":0},{"had_liked":false,"id":344747,"user_name":"蓝衫黑裤白鞋","can_delete":false,"product_type":"c1","uid":2930080,"ip_address":"","ucode":"2DED1F14B8B3DD","user_header":"https://static001.geekbang.org/account/avatar/00/2c/b5/a0/32b462a2.jpg","comment_is_top":false,"comment_ctime":1651747782,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1651747782","product_id":100094401,"comment_content":"请问一下vue3是如何兼容不支持proxy的低版本安卓系统的","like_count":0},{"had_liked":false,"id":332660,"user_name":"resolve(false)","can_delete":false,"product_type":"c1","uid":2456159,"ip_address":"","ucode":"EB1B0C6599B5F3","user_header":"https://static001.geekbang.org/account/avatar/00/25/7a/5f/d0f95bfe.jpg","comment_is_top":false,"comment_ctime":1643443127,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643443127","product_id":100094401,"comment_content":"为啥总是跑test失败啊 .SyntaxError: Cannot use import statement outside a module","like_count":0},{"had_liked":false,"id":331060,"user_name":"子阳","can_delete":false,"product_type":"c1","uid":2748897,"ip_address":"","ucode":"F11EA19098BB74","user_header":"https://static001.geekbang.org/account/avatar/00/29/f1/e1/3b50288a.jpg","comment_is_top":false,"comment_ctime":1642404295,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642404295","product_id":100094401,"comment_content":"经过一个星期的学习，终于自己实现了。无比的高兴。继续挑战下一章","like_count":1},{"had_liked":false,"id":329535,"user_name":"openbilibili","can_delete":false,"product_type":"c1","uid":1354408,"ip_address":"","ucode":"57CF3971A268B9","user_header":"https://static001.geekbang.org/account/avatar/00/14/aa/a8/6ca767ca.jpg","comment_is_top":false,"comment_ctime":1641390560,"is_pvip":false,"replies":[{"id":"120851","content":"weiyouyi是简版的，我看的代码是3.2之前的版本，3.2之后的响应式会有位运算的优化","user_name":"作者回复","comment_id":329535,"uid":"1003715","ip_address":"","utype":1,"ctime":1642339526,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1641390560","product_id":100094401,"comment_content":"你好，问一下，你看的vue是哪个版本的？我对照一些 vue源代码 和 weiyouyi的代码，有些地方不太相同，但是又无法理解。","like_count":0,"discussions":[{"author":{"id":1003715,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/50/c3/0aa50246.jpg","nickname":"花果山大圣","note":"","ucode":"25C0A36D628037","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546556,"discussion_content":"weiyouyi是简版的，我看的代码是3.2之前的版本，3.2之后的响应式会有位运算的优化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642339526,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328747,"user_name":"james","can_delete":false,"product_type":"c1","uid":1232771,"ip_address":"","ucode":"AC42035106E5B9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/yyibGRYCArsUNBfCAEAibua09Yb9D5AdO8TkCmXymhAepibqmlz0hzg06ggBLxyvXicnjqFVGr7zYF0rQoZ0aXCBAg/132","comment_is_top":false,"comment_ctime":1640861388,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1640861388","product_id":100094401,"comment_content":"&lt;script&gt;console.log(&#39;aallal&#39;)&lt;&#47;script&gt;","like_count":0}]}