{"id":84344,"title":"03 | 互斥锁（上）：解决原子性问题","content":"<p>在<a href=\"https://time.geekbang.org/column/article/83682\">第一篇文章</a>中我们提到，一个或者多个操作在CPU执行的过程中不被中断的特性，称为“原子性”。理解这个特性有助于你分析并发编程Bug出现的原因，例如利用它可以分析出long型变量在32位机器上读写可能出现的诡异Bug，明明已经把变量成功写入内存，重新读出来却不是自己写入的。</p><p><strong>那原子性问题到底该如何解决呢？</strong></p><p>你已经知道，原子性问题的源头是<strong>线程切换</strong>，如果能够禁用线程切换那不就能解决这个问题了吗？而操作系统做线程切换是依赖CPU中断的，所以禁止CPU发生中断就能够禁止线程切换。</p><p>在早期单核CPU时代，这个方案的确是可行的，而且也有很多应用案例，但是并不适合多核场景。这里我们以32位CPU上执行long型变量的写操作为例来说明这个问题，long型变量是64位，在32位CPU上执行写操作会被拆分成两次写操作（写高32位和写低32位，如下图所示）。</p><p><img src=\"https://static001.geekbang.org/resource/image/38/28/381b657801c48b3399f19d946bad9e28.png?wh=868*315\" alt=\"\"></p><p>在单核CPU场景下，同一时刻只有一个线程执行，禁止CPU中断，意味着操作系统不会重新调度线程，也就是禁止了线程切换，获得CPU使用权的线程就可以不间断地执行，所以两次写操作一定是：要么都被执行，要么都没有被执行，具有原子性。</p><p>但是在多核场景下，同一时刻，有可能有两个线程同时在执行，一个线程执行在CPU-1上，一个线程执行在CPU-2上，此时禁止CPU中断，只能保证CPU上的线程连续执行，并不能保证同一时刻只有一个线程执行，如果这两个线程同时写long型变量高32位的话，那就有可能出现我们开头提及的诡异Bug了。</p><!-- [[[read_end]]] --><p>“<strong>同一时刻只有一个线程执行</strong>”这个条件非常重要，我们称之为<strong>互斥</strong>。如果我们能够保证对共享变量的修改是互斥的，那么，无论是单核CPU还是多核CPU，就都能保证原子性了。</p><h2>简易锁模型</h2><p>当谈到互斥，相信聪明的你一定想到了那个杀手级解决方案：锁。同时大脑中还会出现以下模型：</p><p><img src=\"https://static001.geekbang.org/resource/image/3d/a2/3df991e7de14a788b220468836cd48a2.png?wh=1142*640\" alt=\"\"></p><center><span class=\"reference\">简易锁模型</span></center><p>我们把一段需要互斥执行的代码称为<strong>临界区</strong>。线程在进入临界区之前，首先尝试加锁lock()，如果成功，则进入临界区，此时我们称这个线程持有锁；否则呢就等待，直到持有锁的线程解锁；持有锁的线程执行完临界区的代码后，执行解锁unlock()。</p><p>这个过程非常像办公室里高峰期抢占坑位，每个人都是进坑锁门（加锁），出坑开门（解锁），如厕这个事就是临界区。很长时间里，我也是这么理解的。这样理解本身没有问题，但却很容易让我们忽视两个非常非常重要的点：我们锁的是什么？我们保护的又是什么？</p><h2>改进后的锁模型</h2><p>我们知道在现实世界里，锁和锁要保护的资源是有对应关系的，比如你用你家的锁保护你家的东西，我用我家的锁保护我家的东西。在并发编程世界里，锁和资源也应该有这个关系，但这个关系在我们上面的模型中是没有体现的，所以我们需要完善一下我们的模型。</p><p><img src=\"https://static001.geekbang.org/resource/image/28/2f/287008c8137a43fa032e68a0c23c172f.png?wh=1142*640\" alt=\"\"></p><center><span class=\"reference\">改进后的锁模型</span></center><p>首先，我们要把临界区要保护的资源标注出来，如图中临界区里增加了一个元素：受保护的资源R；其次，我们要保护资源R就得为它创建一把锁LR；最后，针对这把锁LR，我们还需在进出临界区时添上加锁操作和解锁操作。另外，在锁LR和受保护资源之间，我特地用一条线做了关联，这个关联关系非常重要。很多并发Bug的出现都是因为把它忽略了，然后就出现了类似锁自家门来保护他家资产的事情，这样的Bug非常不好诊断，因为潜意识里我们认为已经正确加锁了。</p><h2>Java语言提供的锁技术：synchronized</h2><p>锁是一种通用的技术方案，Java语言提供的synchronized关键字，就是锁的一种实现。synchronized关键字可以用来修饰方法，也可以用来修饰代码块，它的使用示例基本上都是下面这个样子：</p><pre><code>class X {\n  // 修饰非静态方法\n  synchronized void foo() {\n    // 临界区\n  }\n  // 修饰静态方法\n  synchronized static void bar() {\n    // 临界区\n  }\n  // 修饰代码块\n  Object obj = new Object()；\n  void baz() {\n    synchronized(obj) {\n      // 临界区\n    }\n  }\n}  \n</code></pre><p>看完之后你可能会觉得有点奇怪，这个和我们上面提到的模型有点对不上号啊，加锁lock()和解锁unlock()在哪里呢？其实这两个操作都是有的，只是这两个操作是被Java默默加上的，Java编译器会在synchronized修饰的方法或代码块前后自动加上加锁lock()和解锁unlock()，这样做的好处就是加锁lock()和解锁unlock()一定是成对出现的，毕竟忘记解锁unlock()可是个致命的Bug（意味着其他线程只能死等下去了）。</p><p>那synchronized里的加锁lock()和解锁unlock()锁定的对象在哪里呢？上面的代码我们看到只有修饰代码块的时候，锁定了一个obj对象，那修饰方法的时候锁定的是什么呢？这个也是Java的一条隐式规则：</p><blockquote>\n<p>当修饰静态方法的时候，锁定的是当前类的Class对象，在上面的例子中就是Class X；<br>\n当修饰非静态方法的时候，锁定的是当前实例对象this。</p>\n</blockquote><p>对于上面的例子，synchronized修饰静态方法相当于:</p><pre><code>class X {\n  // 修饰静态方法\n  synchronized(X.class) static void bar() {\n    // 临界区\n  }\n}\n</code></pre><p>修饰非静态方法，相当于：</p><pre><code>class X {\n  // 修饰非静态方法\n  synchronized(this) void foo() {\n    // 临界区\n  }\n}\n</code></pre><h2>用synchronized解决count+=1问题</h2><p>相信你一定记得我们前面文章中提到过的count+=1存在的并发问题，现在我们可以尝试用synchronized来小试牛刀一把，代码如下所示。SafeCalc这个类有两个方法：一个是get()方法，用来获得value的值；另一个是addOne()方法，用来给value加1，并且addOne()方法我们用synchronized修饰。那么我们使用的这两个方法有没有并发问题呢？</p><pre><code>class SafeCalc {\n  long value = 0L;\n  long get() {\n    return value;\n  }\n  synchronized void addOne() {\n    value += 1;\n  }\n}\n</code></pre><p>我们先来看看addOne()方法，首先可以肯定，被synchronized修饰后，无论是单核CPU还是多核CPU，只有一个线程能够执行addOne()方法，所以一定能保证原子操作，那是否有可见性问题呢？要回答这问题，就要重温一下<a href=\"https://time.geekbang.org/column/article/84017\">上一篇文章</a>中提到的<strong>管程中锁的规则</strong>。</p><blockquote>\n<p>管程中锁的规则：对一个锁的解锁 Happens-Before 于后续对这个锁的加锁。</p>\n</blockquote><p>管程，就是我们这里的synchronized（至于为什么叫管程，我们后面介绍），我们知道synchronized修饰的临界区是互斥的，也就是说同一时刻只有一个线程执行临界区的代码；而所谓“对一个锁解锁  Happens-Before 后续对这个锁的加锁”，指的是前一个线程的解锁操作对后一个线程的加锁操作可见，综合Happens-Before的传递性原则，我们就能得出前一个线程在临界区修改的共享变量（该操作在解锁之前），对后续进入临界区（该操作在加锁之后）的线程是可见的。</p><p>按照这个规则，如果多个线程同时执行addOne()方法，可见性是可以保证的，也就说如果有1000个线程执行addOne()方法，最终结果一定是value的值增加了1000。看到这个结果，我们长出一口气，问题终于解决了。</p><p>但也许，你一不小心就忽视了get()方法。执行addOne()方法后，value的值对get()方法是可见的吗？这个可见性是没法保证的。管程中锁的规则，是只保证后续对这个锁的加锁的可见性，而get()方法并没有加锁操作，所以可见性没法保证。那如何解决呢？很简单，就是get()方法也synchronized一下，完整的代码如下所示。</p><pre><code>class SafeCalc {\n  long value = 0L;\n  synchronized long get() {\n    return value;\n  }\n  synchronized void addOne() {\n    value += 1;\n  }\n}\n</code></pre><p>上面的代码转换为我们提到的锁模型，就是下面图示这个样子。get()方法和addOne()方法都需要访问value这个受保护的资源，这个资源用this这把锁来保护。线程要进入临界区get()和addOne()，必须先获得this这把锁，这样get()和addOne()也是互斥的。</p><p><img src=\"https://static001.geekbang.org/resource/image/26/f6/26a84ffe2b4a6ae67c8093d29473e1f6.png?wh=1142*640\" alt=\"\"></p><center><span class=\"reference\">保护临界区get()和addOne()的示意图</span></center><p>这个模型更像现实世界里面球赛门票的管理，一个座位只允许一个人使用，这个座位就是“受保护资源”，球场的入口就是Java类里的方法，而门票就是用来保护资源的“锁”，Java里的检票工作是由synchronized解决的。</p><h2>锁和受保护资源的关系</h2><p>我们前面提到，受保护资源和锁之间的关联关系非常重要，他们的关系是怎样的呢？一个合理的关系是：<strong>受保护资源和锁之间的关联关系是N:1的关系</strong>。还拿前面球赛门票的管理来类比，就是一个座位，我们只能用一张票来保护，如果多发了重复的票，那就要打架了。现实世界里，我们可以用多把锁来保护同一个资源，但在并发领域是不行的，并发领域的锁和现实世界的锁不是完全匹配的。不过倒是可以用同一把锁来保护多个资源，这个对应到现实世界就是我们所谓的“包场”了。</p><p>上面那个例子我稍作改动，把value改成静态变量，把addOne()方法改成静态方法，此时get()方法和addOne()方法是否存在并发问题呢？</p><pre><code>class SafeCalc {\n  static long value = 0L;\n  synchronized long get() {\n    return value;\n  }\n  synchronized static void addOne() {\n    value += 1;\n  }\n}\n</code></pre><p>如果你仔细观察，就会发现改动后的代码是用两个锁保护一个资源。这个受保护的资源就是静态变量value，两个锁分别是this和SafeCalc.class。我们可以用下面这幅图来形象描述这个关系。由于临界区get()和addOne()是用两个锁保护的，因此这两个临界区没有互斥关系，临界区addOne()对value的修改对临界区get()也没有可见性保证，这就导致并发问题了。</p><p><img src=\"https://static001.geekbang.org/resource/image/60/be/60551e006fca96f581f3dc25424226be.png?wh=1142*640\" alt=\"\"></p><center><span class=\"reference\">两把锁保护一个资源的示意图</span></center><h2>总结</h2><p>互斥锁，在并发领域的知名度极高，只要有了并发问题，大家首先容易想到的就是加锁，因为大家都知道，加锁能够保证执行临界区代码的互斥性。这样理解虽然正确，但是却不能够指导你真正用好互斥锁。临界区的代码是操作受保护资源的路径，类似于球场的入口，入口一定要检票，也就是要加锁，但不是随便一把锁都能有效。所以必须深入分析锁定的对象和受保护资源的关系，综合考虑受保护资源的访问路径，多方面考量才能用好互斥锁。</p><p>synchronized是Java在语言层面提供的互斥原语，其实Java里面还有很多其他类型的锁，但作为互斥锁，原理都是相通的：锁，一定有一个要锁定的对象，至于这个锁定的对象要保护的资源以及在哪里加锁/解锁，就属于设计层面的事情了。</p><h2>课后思考</h2><p>下面的代码用synchronized修饰代码块来尝试解决并发问题，你觉得这个使用方式正确吗？有哪些问题呢？能解决可见性和原子性问题吗？</p><pre><code>class SafeCalc {\n  long value = 0L;\n  long get() {\n    synchronized (new Object()) {\n      return value;\n    }\n  }\n  void addOne() {\n    synchronized (new Object()) {\n      value += 1;\n    }\n  }\n}\n</code></pre><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p><p></p>","comments":[{"had_liked":false,"id":72841,"user_name":"好牙","can_delete":false,"product_type":"c1","uid":1117320,"ip_address":"","ucode":"F36A824C1AB19A","user_header":"","comment_is_top":false,"comment_ctime":1551747038,"is_pvip":false,"replies":[{"id":"26476","content":"synchronized的实现都知道了，厉害！","user_name":"作者回复","comment_id":72841,"uid":"1269969","ip_address":"","utype":1,"ctime":1551793643,"user_name_real":"王宝令"}],"discussion_count":20,"race_medal":0,"score":"2140445460446","product_id":100023901,"comment_content":"加锁本质就是在锁对象的对象头中写入当前线程id，但是new object每次在内存中都是新对象，所以加锁无效。","like_count":498,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441780,"discussion_content":"synchronized的实现都知道了，厉害！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551793643,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1507024,"avatar":"https://static001.geekbang.org/account/avatar/00/16/fe/d0/e80e4a7e.jpg","nickname":"zhangyi","note":"","ucode":"0C4CAE9DA878F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289853,"discussion_content":"麻烦各位指出一下我哪里错误了。我不完全赞同楼主。\n偏向锁时，锁的mardword存的才是线程的id。重量级锁，存的是monitor的指针。","likes_number":19,"is_delete":false,"is_hidden":false,"ctime":1594235338,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1508990,"avatar":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","nickname":"西门吹牛","note":"","ucode":"E5D3624DDE1E83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1507024,"avatar":"https://static001.geekbang.org/account/avatar/00/16/fe/d0/e80e4a7e.jpg","nickname":"zhangyi","note":"","ucode":"0C4CAE9DA878F3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302254,"discussion_content":"不错，这里要注意锁的升级，楼主描述的是偏向锁","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598860183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":289853,"ip_address":""},"score":302254,"extra":""},{"author":{"id":2268436,"avatar":"","nickname":"binf","note":"","ucode":"AE6D7CD6CAFE4D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1507024,"avatar":"https://static001.geekbang.org/account/avatar/00/16/fe/d0/e80e4a7e.jpg","nickname":"zhangyi","note":"","ucode":"0C4CAE9DA878F3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324626,"discussion_content":"不是，老师能不能仔细看下评论，好几次了，这种片面甚至错误的评论真的误导人，虽然我觉得文章写得不错，但是回复还是不要只注重数量","likes_number":16,"is_delete":false,"is_hidden":false,"ctime":1605145402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":289853,"ip_address":""},"score":324626,"extra":""},{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1507024,"avatar":"https://static001.geekbang.org/account/avatar/00/16/fe/d0/e80e4a7e.jpg","nickname":"zhangyi","note":"","ucode":"0C4CAE9DA878F3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378962,"discussion_content":"轻量级锁中，Mark Word的值都被存在了栈帧里的Lock Record里，Lock Record里存储锁对象目前的Mark Word的拷贝","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1623564235,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":289853,"ip_address":""},"score":378962,"extra":""}]},{"author":{"id":1437158,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ed/e6/75a32708.jpg","nickname":"日拱一兵","note":"","ucode":"D6386E5CD7C061","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5364,"discussion_content":"jdk不断在优化synchronized，有了在头加线程id，就形成了偏向锁，统一线程再次访问就减少了锁访问的开销","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1566204347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2124869,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/WZyEAvo4qPrQ1vhNTeMjjbO9G8A9s20Ka5icbcxxjIibWwPsjrl8OvXDFxpRxYRhibXe6gfNngHAa0BrGJW7kfovA/132","nickname":"长路漫漫","note":"","ucode":"5B3D83B81C9CFF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1437158,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ed/e6/75a32708.jpg","nickname":"日拱一兵","note":"","ucode":"D6386E5CD7C061","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545673,"discussion_content":"这也太巧合了，今天正好看到你的一篇微信公众号文章，结果立马在这看见你了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1642038439,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":5364,"ip_address":""},"score":545673,"extra":""}]},{"author":{"id":1631281,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er8ok3W1JuxlK1eHjfylzhBwkFm8lkIr4KibzLic5YjonIXj4t9RNkKV0PBUZv1wPM0fwdIwib6pickGA/132","nickname":"Geek_e08661","note":"","ucode":"DFD60339814CA6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5575,"discussion_content":"单cpu单核心，为什么会出现可见行问题？如下程序：\npublic class A implements Runnable {\n    public Integer id = 1;\n\n    A() {\n    }\n\n    public void run() {\n        System.out.println(&#34;A is begin!&#34;);\n        B b = new B();\n\n        do {\n//这里打印一次\n            b.error(this.id);       \n        } while(this.id != 2);\n//这里打印一次\n        b.error(this.id);\n\n        System.out.println(&#34;A is finish!&#34;);\n    }\n\n    public static void main(String[] args) {\n        A a = new A();\n        (new Thread(a)).start();\n        try {\n            Thread.sleep(5L);\n        } catch (InterruptedException var3) {\n            var3.printStackTrace();\n        }\n\n        a.id = 2;\n    }\n}\n\nclass B {\n    private int a;\n    private int b = 0;\n\n    B() {\n    }\n\n    public int error(int id) {\n        System.out.println(&#34;b=&#34;+b+&#34;#####&#34;+&#34;id=&#34;+id);\n        ++this.b;\n        return id;\n    }\n\n    public void setId(int a) {\n        this.a = a;\n    }\n\n    public int getId() {\n        return this.a;\n    }\n\n    public int getB() {\n        return this.b;\n    }\n}\n阿里学生机单cpu单核单线程，查看命令如下：\n # 总核数 = 物理CPU个数 X 每颗物理CPU的核数 \n       # 总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数\n       # 查看物理CPU个数\n       cat /proc/cpuinfo| grep &#34;physical id&#34;| sort| uniq| wc -l\n       # 查看每个物理CPU中core的个数(即核数)\n       cat /proc/cpuinfo| grep &#34;cpu cores&#34;| uniq\n       # 查看逻辑CPU的个数\n       cat /proc/cpuinfo| grep &#34;processor&#34;| wc -l\n      #查看线程数\n       grep &#39;processor&#39;        /proc/cpuinfo | sort -u | wc -l      \n\n运行结果只打印出一个2，如果两个线程共用一个cpu缓存，那么在main线程更改b=2时，对于线程A也应该是可见的，应该会打印两个2，但是实际情况会存在可见性，不是很明白，希望有人看见能指导一下，谢谢🙏","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1566358872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1018240,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/89/80/3666ced3.jpg","nickname":"黄浩特","note":"","ucode":"C3A4BBF4FB8519","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1631281,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er8ok3W1JuxlK1eHjfylzhBwkFm8lkIr4KibzLic5YjonIXj4t9RNkKV0PBUZv1wPM0fwdIwib6pickGA/132","nickname":"Geek_e08661","note":"","ucode":"DFD60339814CA6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":32670,"discussion_content":"打印两个2的情况是 主线程修改 a = 2 发生在 while 条件判断之后 打印 id 方法之前, 如果是在打印方法之后 , 下次while 条件判断之前, 就只有1个2","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1571056569,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":5575,"ip_address":""},"score":32670,"extra":""},{"author":{"id":1361746,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c7/52/c5adf218.jpg","nickname":"喜欢地球的阿培同学","note":"","ucode":"5F97037585F857","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1631281,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er8ok3W1JuxlK1eHjfylzhBwkFm8lkIr4KibzLic5YjonIXj4t9RNkKV0PBUZv1wPM0fwdIwib6pickGA/132","nickname":"Geek_e08661","note":"","ucode":"DFD60339814CA6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":89965,"discussion_content":"       do {\n            b.error(this.id);\n        } while(this.id != 2);\n你传递的是一个Integer值，该值是final型，因此A对象中的id及this.id在调用方法error(int id) 过后，值不会变的。所以根本就不会进入while循环，这个不是可见性问题，而是Java函数传值问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576765084,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":5575,"ip_address":""},"score":89965,"extra":""},{"author":{"id":1019506,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8e/72/63c94eee.jpg","nickname":"黄马","note":"","ucode":"93E391B4678EC2","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":1361746,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c7/52/c5adf218.jpg","nickname":"喜欢地球的阿培同学","note":"","ucode":"5F97037585F857","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":205563,"discussion_content":"要互斥需要争夺同一把锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584322381,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":89965,"ip_address":""},"score":205563,"extra":""}]},{"author":{"id":1983640,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/44/98/bb591ddf.jpg","nickname":"吞吃的河豚","note":"","ucode":"BE8BDBBF1D0FED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286490,"discussion_content":"这。。。 jvm创建对象  连起来了 真强","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1593185202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1581294,"avatar":"","nickname":"Geek_be4cec","note":"","ucode":"C87642D655EAC3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3425,"discussion_content":"看来读过synchronized的源码","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1564476033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1341612,"avatar":"https://static001.geekbang.org/account/avatar/00/14/78/ac/e5e6e7f3.jpg","nickname":"古夜","note":"","ucode":"0A82D3CFCEDF07","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1581294,"avatar":"","nickname":"Geek_be4cec","note":"","ucode":"C87642D655EAC3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3906,"discussion_content":"syn源码怎么读？看虚拟机的源码？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1564969245,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3425,"ip_address":""},"score":3906,"extra":""},{"author":{"id":1404537,"avatar":"https://static001.geekbang.org/account/avatar/00/15/6e/79/772d64f8.jpg","nickname":"富大海","note":"","ucode":"365FACE3567CEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1341612,"avatar":"https://static001.geekbang.org/account/avatar/00/14/78/ac/e5e6e7f3.jpg","nickname":"古夜","note":"","ucode":"0A82D3CFCEDF07","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":93584,"discussion_content":"可以用JOL工具查看对象头中的信息。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576932552,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3906,"ip_address":""},"score":93584,"extra":""},{"author":{"id":1341612,"avatar":"https://static001.geekbang.org/account/avatar/00/14/78/ac/e5e6e7f3.jpg","nickname":"古夜","note":"","ucode":"0A82D3CFCEDF07","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1404537,"avatar":"https://static001.geekbang.org/account/avatar/00/15/6e/79/772d64f8.jpg","nickname":"富大海","note":"","ucode":"365FACE3567CEF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286619,"discussion_content":"多谢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1593248171,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":93584,"ip_address":""},"score":286619,"extra":""}]},{"author":{"id":1125985,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2e/61/72a083ea.jpg","nickname":"小公司都不给我进就赖门口哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈","note":"","ucode":"10C8AF52F68A29","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2051,"discussion_content":"厉害","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1563204581,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111870,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK2Az5uTh9ZGVA7yQCj1BXtXuicPRkvJicA97AoN9xX3bnPcUYglTMXJeZeoVbPQeJA7ICvQhR3KQ0w/132","nickname":"日不落帝国","note":"","ucode":"6A11ABBD8AC438","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5499,"discussion_content":"学习学习","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566307603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1400962,"avatar":"https://static001.geekbang.org/account/avatar/00/15/60/82/9a43504b.jpg","nickname":"[耶]友超","note":"","ucode":"890572F77C3670","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2995,"discussion_content":"牛","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1564104153,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73098,"user_name":"w1sl1y","can_delete":false,"product_type":"c1","uid":1270958,"ip_address":"","ucode":"915073A14B17AB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erBkHFLUBpftqQlK5brd3EDaQFaEfYLfc9iaQrDNJv4eHeSRnSgE5vKnSibJvjUb5hJx5r5nOwa2bRw/132","comment_is_top":false,"comment_ctime":1551797702,"is_pvip":false,"replies":[{"id":"26578","content":"👍厉害<br>","user_name":"作者回复","comment_id":73098,"uid":"1269969","ip_address":"","utype":1,"ctime":1551830875,"user_name_real":"王宝令"}],"discussion_count":11,"race_medal":0,"score":"1092473490886","product_id":100023901,"comment_content":"经过JVM逃逸分析的优化后，这个sync代码直接会被优化掉，所以在运行时该代码块是无锁的","like_count":254,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441910,"discussion_content":"👍厉害\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551830875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378963,"discussion_content":"锁消除：如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1623564394,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1583588,"avatar":"https://static001.geekbang.org/account/avatar/00/18/29/e4/ade74d94.jpg","nickname":"hejun","note":"","ucode":"DCF01B4159178F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":29851,"discussion_content":"厉害👍","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1570787252,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1307080,"avatar":"https://static001.geekbang.org/account/avatar/00/13/f1/c8/8e6dc340.jpg","nickname":"potato00fa","note":"","ucode":"D179E68D87CC50","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":13069,"discussion_content":"牛批","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568638228,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1274495,"avatar":"https://static001.geekbang.org/account/avatar/00/13/72/7f/5da093c5.jpg","nickname":"水目沾","note":"","ucode":"FDD1D15C277D58","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550629,"discussion_content":"一语双关","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644647001,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1507024,"avatar":"https://static001.geekbang.org/account/avatar/00/16/fe/d0/e80e4a7e.jpg","nickname":"zhangyi","note":"","ucode":"0C4CAE9DA878F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289854,"discussion_content":"牛逼，确实直接优化了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594235444,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1182802,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0c/52/f25c3636.jpg","nickname":"长脖子树","note":"","ucode":"D9090EF67EEB1B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":229585,"discussion_content":"666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586667801,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005381,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/45/c418ea5c.jpg","nickname":"指尖流逝","note":"","ucode":"417009F674FAF1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220443,"discussion_content":"请问下，JVM逃逸分析的出处是哪里？Java虚拟机规范吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585877642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1239277,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e8/ed/f9347e5e.jpg","nickname":"我的腿腿","note":"","ucode":"2AAA36A7C3AD75","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1005381,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/45/c418ea5c.jpg","nickname":"指尖流逝","note":"","ucode":"417009F674FAF1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269641,"discussion_content":"请出门右转看java虚拟机那门课","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1589935521,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":220443,"ip_address":""},"score":269641,"extra":""}]},{"author":{"id":1111870,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK2Az5uTh9ZGVA7yQCj1BXtXuicPRkvJicA97AoN9xX3bnPcUYglTMXJeZeoVbPQeJA7ICvQhR3KQ0w/132","nickname":"日不落帝国","note":"","ucode":"6A11ABBD8AC438","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5500,"discussion_content":"学习学习","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566307632,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1400962,"avatar":"https://static001.geekbang.org/account/avatar/00/15/60/82/9a43504b.jpg","nickname":"[耶]友超","note":"","ucode":"890572F77C3670","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2999,"discussion_content":"厉害👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564104243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79180,"user_name":"sbwei🚴","can_delete":false,"product_type":"c1","uid":1203659,"ip_address":"","ucode":"A90E57298670A6","user_header":"https://static001.geekbang.org/account/avatar/00/12/5d/cb/3507f11c.jpg","comment_is_top":false,"comment_ctime":1553396261,"is_pvip":false,"discussion_count":14,"race_medal":0,"score":"650093457957","product_id":100023901,"comment_content":"最后的思考题: 多把锁保护同一个资源，就像一个厕所坑位，有N多门可以进去，没有丝毫保护效果，管理员一看，还不如把门都撤了，弄成开放式(编译器代码优化)😂。","like_count":151,"discussions":[{"author":{"id":1507024,"avatar":"https://static001.geekbang.org/account/avatar/00/16/fe/d0/e80e4a7e.jpg","nickname":"zhangyi","note":"","ucode":"0C4CAE9DA878F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289855,"discussion_content":"直接锁消除了，根本无锁，就没有是否是同一把锁这个说法了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594235574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1058131,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/gDdDyl6Txc6ictXNfx39XdB1zBzQWx4suEMDTXiaaJ0DK7AhVibbr3YBFNM0gTjeuicVp7unhEm6SRjlasicMKG01ww/132","nickname":"。","note":"","ucode":"8715892499F2B2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":30941,"discussion_content":"这个解释厉害","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1570871268,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1747184,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/a8/f0/529f15e9.jpg","nickname":"第四单元","note":"","ucode":"3ED9D553E1DE17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583880,"discussion_content":"这个形容666，通俗易懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660462526,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2076251,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/ae/5b/4bd42286.jpg","nickname":"宋计洋","note":"","ucode":"9A34E8F71C6CBD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":567563,"discussion_content":"防盗门：我就是两个门保护同一个资源 ^=^","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650943218,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1810995,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a2/33/493d4b5b.jpg","nickname":"@","note":"","ucode":"D278E14517F8A5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361162,"discussion_content":"我一下就看懂了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616599820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1047134,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fa/5e/d7331a3e.jpg","nickname":"小鱼干","note":"","ucode":"74C59DA5181880","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349353,"discussion_content":"解释厉害了👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613121137,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2268436,"avatar":"","nickname":"binf","note":"","ucode":"AE6D7CD6CAFE4D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324629,"discussion_content":"如果其中有一把锁有竞争，是不会被优化掉的吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605145707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1489957,"avatar":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","nickname":"tt","note":"","ucode":"7753B79AD5A9AC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298945,"discussion_content":"一下就懂了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597485914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1610259,"avatar":"https://static001.geekbang.org/account/avatar/00/18/92/13/655afbf5.jpg","nickname":"yoyoga","note":"","ucode":"9485213CE234B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298467,"discussion_content":"人才","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597305422,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1591405,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqqtFTbZcJcKq4icuCF8I3VoLMK3W8sx9askp6vrnY3DLtghI7svXpMIchn44ySY24ic4l8ADWFibLJA/132","nickname":"jack","note":"","ucode":"5EE763FEA7D755","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":230330,"discussion_content":"为什么不是一个门上有多把锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586740062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1107484,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e6/1c/9d3744ee.jpg","nickname":"小李讲源码","note":"","ucode":"2573037D7C82C8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1591405,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqqtFTbZcJcKq4icuCF8I3VoLMK3W8sx9askp6vrnY3DLtghI7svXpMIchn44ySY24ic4l8ADWFibLJA/132","nickname":"jack","note":"","ucode":"5EE763FEA7D755","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287967,"discussion_content":"new的对象不一样，肯定不是一个门啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593602089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":230330,"ip_address":""},"score":287967,"extra":""}]},{"author":{"id":1033425,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c4/d1/209abdd6.jpg","nickname":"小狼","note":"","ucode":"FEAC7864FC1D20","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":208831,"discussion_content":"精辟的解释","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584582820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1718222,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/37/ce/b15e3314.jpg","nickname":"牧毅","note":"","ucode":"F75615CB14B8FF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62392,"discussion_content":"清新脱俗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574839826,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1261326,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3f/0e/3a2fb9ff.jpg","nickname":"爽了个爽","note":"","ucode":"D5B10F75A02AB1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60996,"discussion_content":"通俗易懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574768734,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72865,"user_name":"老杨同志","can_delete":false,"product_type":"c1","uid":1246199,"ip_address":"","ucode":"3F334F0CFD3DE6","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/f7/3a493bec.jpg","comment_is_top":false,"comment_ctime":1551748614,"is_pvip":false,"replies":[{"id":"26481","content":"实在是太厉害了！！！","user_name":"作者回复","comment_id":72865,"uid":"1269969","ip_address":"","utype":1,"ctime":1551794265,"user_name_real":"王宝令"}],"discussion_count":8,"race_medal":0,"score":"448228347398","product_id":100023901,"comment_content":"两把不同的锁，不能保护临界资源。而且这种new出来只在一个地方使用的对象，其它线程不能对它解锁，这个锁会被编译器优化掉。和没有syncronized代码块效果是相同的","like_count":104,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441797,"discussion_content":"实在是太厉害了！！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551794265,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1874999,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/9c/37/253ea895.jpg","nickname":"我不是码农","note":"","ucode":"EB4BB711CC54B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":565746,"discussion_content":"MySQL的课大佬的留言就很多","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650533674,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1341612,"avatar":"https://static001.geekbang.org/account/avatar/00/14/78/ac/e5e6e7f3.jpg","nickname":"古夜","note":"","ucode":"0A82D3CFCEDF07","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271213,"discussion_content":"示例代码不是两处用到了吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590107486,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1341612,"avatar":"https://static001.geekbang.org/account/avatar/00/14/78/ac/e5e6e7f3.jpg","nickname":"古夜","note":"","ucode":"0A82D3CFCEDF07","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271212,"discussion_content":"而且这种new出来只在一个地方使用的对象，其它线程不能对它解锁，\n----————————————————\n请问这句话是什么意思啊，没看明白","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590107437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2343943,"avatar":"https://static001.geekbang.org/account/avatar/00/23/c4/07/6960f55a.jpg","nickname":"Register","note":"","ucode":"D8C42B059FF9BD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1341612,"avatar":"https://static001.geekbang.org/account/avatar/00/14/78/ac/e5e6e7f3.jpg","nickname":"古夜","note":"","ucode":"0A82D3CFCEDF07","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350522,"discussion_content":"new出来的对象是局部变量，不同线程new出来的对象不是同一个。加锁就没有了意义。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1613902597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":271212,"ip_address":""},"score":350522,"extra":""}]},{"author":{"id":1442497,"avatar":"https://static001.geekbang.org/account/avatar/00/16/02/c1/80e68043.jpg","nickname":"停三秒","note":"","ucode":"C9D8F39F24672E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":103829,"discussion_content":"往下拉这么多 唯一看懂的评论 👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577399865,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111870,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK2Az5uTh9ZGVA7yQCj1BXtXuicPRkvJicA97AoN9xX3bnPcUYglTMXJeZeoVbPQeJA7ICvQhR3KQ0w/132","nickname":"日不落帝国","note":"","ucode":"6A11ABBD8AC438","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5502,"discussion_content":"赞赞赞，学习了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566307698,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1125985,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2e/61/72a083ea.jpg","nickname":"小公司都不给我进就赖门口哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈","note":"","ucode":"10C8AF52F68A29","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2053,"discussion_content":"编译优化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563204680,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72943,"user_name":"zyl","can_delete":false,"product_type":"c1","uid":1100717,"ip_address":"","ucode":"2F872341AC8D7E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eq65BWyJb39rq0Qgx1fnELVSZGGuLY6oBmYcmFj2Oqy9iauAWfbqO5U63I22Uo1POrrTp7tFWXibxvg/132","comment_is_top":false,"comment_ctime":1551757955,"is_pvip":false,"replies":[{"id":"26492","content":"sync的优化都知道了，厉害啊","user_name":"作者回复","comment_id":72943,"uid":"1269969","ip_address":"","utype":1,"ctime":1551795080,"user_name_real":"王宝令"}],"discussion_count":9,"race_medal":0,"score":"435343454851","product_id":100023901,"comment_content":"sync锁的对象monitor指针指向一个ObjectMonitor对象，所有线程加入他的entrylist里面，去cas抢锁，更改state加1拿锁，执行完代码，释放锁state减1，和aqs机制差不多，只是所有线程不阻塞，cas抢锁，没有队列，属于非公平锁。<br>wait的时候，线程进waitset休眠，等待notify唤醒<br><br>","like_count":101,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441837,"discussion_content":"sync的优化都知道了，厉害啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551795080,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1581294,"avatar":"","nickname":"Geek_be4cec","note":"","ucode":"C87642D655EAC3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3426,"discussion_content":"说的不同俗易懂，和没说一样","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1564476094,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1107484,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e6/1c/9d3744ee.jpg","nickname":"小李讲源码","note":"","ucode":"2573037D7C82C8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1581294,"avatar":"","nickname":"Geek_be4cec","note":"","ucode":"C87642D655EAC3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287966,"discussion_content":"说的是synchronized的底层原理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593602026,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3426,"ip_address":""},"score":287966,"extra":""}]},{"author":{"id":1125985,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2e/61/72a083ea.jpg","nickname":"小公司都不给我进就赖门口哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈","note":"","ucode":"10C8AF52F68A29","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2052,"discussion_content":"一个比一个强","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1563204639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1508990,"avatar":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","nickname":"西门吹牛","note":"","ucode":"E5D3624DDE1E83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304737,"discussion_content":"CAS 抢锁，只是通过CAS 操作把 ObjectMonitor 对象中的 Owen 修改为当前线程地址，并不是你说的status 吧，另外ObjectMonitor 对象中有个计数器，记录重入次数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599650795,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1482026,"avatar":"https://static001.geekbang.org/account/avatar/00/16/9d/2a/3e57b54a.jpg","nickname":"地平线","note":"","ucode":"F50717D6244867","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292738,"discussion_content":"所以sync是重入锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595320599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1094597,"avatar":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","nickname":"Liam","note":"","ucode":"1D15D3B64F2606","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282581,"discussion_content":"没有队列是什么意思？entryList不是队列吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592019947,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1107484,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e6/1c/9d3744ee.jpg","nickname":"小李讲源码","note":"","ucode":"2573037D7C82C8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1094597,"avatar":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","nickname":"Liam","note":"","ucode":"1D15D3B64F2606","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287965,"discussion_content":"entrylist是存放竞争锁的线程。而竞争过程是通过cas进行抢锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593601978,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":282581,"ip_address":""},"score":287965,"extra":""}]},{"author":{"id":1702511,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKUVVjoibAO1cWoM0VcOcbibT0O9bbOvgjJmn6fWyKRNWgrZsOuj7mSMSubFXknOxRP3ozoicdwp1zibw/132","nickname":"衡山弟子","note":"","ucode":"5C635588688A88","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":216691,"discussion_content":"厉害","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585477700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94779,"user_name":"宝爸学学学","can_delete":false,"product_type":"c1","uid":1003364,"ip_address":"","ucode":"AF3F7E076FCFA3","user_header":"","comment_is_top":false,"comment_ctime":1557895225,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"392399919161","product_id":100023901,"comment_content":"我觉得评论区学到的更多啊，你们真的是来学习的吗 :D","like_count":91,"discussions":[{"author":{"id":1812970,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a9/ea/5bfce6c5.jpg","nickname":"mgs2002","note":"","ucode":"F5931108BD509B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":149424,"discussion_content":"被评论区的大神吊打","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1579751010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1543474,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8d/32/1ba05b8c.jpg","nickname":"阿伦桑","note":"","ucode":"DE9C7A62AAEB34","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55378,"discussion_content":"有评论区才让课程变得更完善呀哈哈","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574352326,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1607988,"avatar":"https://static001.geekbang.org/account/avatar/00/18/89/34/758bd3ab.jpg","nickname":"曉楓","note":"","ucode":"E2B4C10FC4DAB2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":95026,"discussion_content":"本来是看的第三方的资料，发现评论多大神后，果断买课程","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577007769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2836731,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/48/fb/ddaf3133.jpg","nickname":"买🍉 不买🍅","note":"","ucode":"EACC9C20807B94","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1607988,"avatar":"https://static001.geekbang.org/account/avatar/00/18/89/34/758bd3ab.jpg","nickname":"曉楓","note":"","ucode":"E2B4C10FC4DAB2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556279,"discussion_content":"正解了属于是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647274912,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":95026,"ip_address":""},"score":556279,"extra":""}]},{"author":{"id":1053955,"avatar":"https://static001.geekbang.org/account/avatar/00/10/15/03/c0fe1dbf.jpg","nickname":"考休","note":"","ucode":"968DFC00D6D0CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":21275,"discussion_content":"来指导的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1569461791,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2057627,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/c38aFXkgKzcaEnz56Zyib5yE88NvzKrnYpJFTe9aodn0cXR2CwA1vs1sP7luwFHeSXuoJlreBtkq3YAFPlmibdibw/132","nickname":"Geek_9ad555","note":"","ucode":"50852723A22788","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290651,"discussion_content":"评论区出人才","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594557464,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72874,"user_name":"王大王","can_delete":false,"product_type":"c1","uid":1442110,"ip_address":"","ucode":"BA520B50E97D34","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqjceGMS81zZibA9LECsgAUU1aHPKhfM4WyNgqPtmnxvtzhC3a44ows3g7FuD7ibESAAY0UWsicW0EjA/132","comment_is_top":false,"comment_ctime":1551749644,"is_pvip":false,"replies":[{"id":"26483","content":"是的，并发包里的原子类都是靠它实现的","user_name":"作者回复","comment_id":72874,"uid":"1269969","ip_address":"","utype":1,"ctime":1551794435,"user_name_real":"王宝令"}],"discussion_count":9,"race_medal":0,"score":"310789394956","product_id":100023901,"comment_content":"Get方法加锁不是为了解决原子性问题，这个读操作本身就是原子性的，是为了实现不能线程间addone方法的操作结果对get方法可见，那么value变量加volitile也可以实现同样效果吗？","like_count":72,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441803,"discussion_content":"是的，并发包里的原子类都是靠它实现的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551794435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1260141,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3a/6d/910b2445.jpg","nickname":"Wheat","note":"","ucode":"7D99EA149B6DE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6682,"discussion_content":"看评论总能解决专栏里不是特别明白的地方！","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1567049316,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1640517,"avatar":"https://static001.geekbang.org/account/avatar/00/19/08/45/62ff43de.jpg","nickname":"HooYa","note":"","ucode":"43F3577E7D939A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574789,"discussion_content":"还是觉得不要把原子性的场景理解错了，只理解成 操作不可分隔。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654340296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1640517,"avatar":"https://static001.geekbang.org/account/avatar/00/19/08/45/62ff43de.jpg","nickname":"HooYa","note":"","ucode":"43F3577E7D939A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574788,"discussion_content":"综合前几章来讲，原子性是单核时代提出来的，在那个时期 CPU只能同一时间运行一个线程。由于CPU会切换线程， 当时只要禁止中断即可。后来CPU多核,原子性问题又多出来个多个线程同时访问临界区的问题，get.加锁解决的是 原子性的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654340177,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1648334,"avatar":"https://static001.geekbang.org/account/avatar/00/19/26/ce/acb6c140.jpg","nickname":"祉幻","note":"","ucode":"ABE19FE8A6A15E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571116,"discussion_content":"确实加volatile可以，参考上一章节的几条happens-before规则，其中对volatile的写操作一定happens-before于他的读操作，还有传递性，这样就有一个更具体合理的解释，而不会停留在我在这里加volatile保证他的可见性这一层面","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652077385,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1171359,"avatar":"https://static001.geekbang.org/account/avatar/00/11/df/9f/6e3e1b77.jpg","nickname":"阿U","note":"","ucode":"161A8E74E0D612","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":103760,"discussion_content":"老师的回复什么意思 get方法加锁到底是不是为了解决原子性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577376673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1696883,"avatar":"https://static001.geekbang.org/account/avatar/00/19/e4/73/74dce191.jpg","nickname":"鼠里鼠气","note":"","ucode":"4793476BBDB202","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1171359,"avatar":"https://static001.geekbang.org/account/avatar/00/11/df/9f/6e3e1b77.jpg","nickname":"阿U","note":"","ucode":"161A8E74E0D612","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":141607,"discussion_content":"我觉得get加锁是为了保证可见性的","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1579434093,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":103760,"ip_address":""},"score":141607,"extra":""}]},{"author":{"id":1339022,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","nickname":"拯救地球好累","note":"","ucode":"7643439601EF4C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2426,"discussion_content":"“读操作是原子性的”似乎不太正确，32位系统对long类型的读取也是非原子的吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563595547,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1164531,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c4/f3/92f654f1.jpg","nickname":"Bug? Feature!","note":"","ucode":"F8FA8A0094FBA0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1339022,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","nickname":"拯救地球好累","note":"","ucode":"7643439601EF4C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4918,"discussion_content":"大家快来看，这有个老实人。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1565832028,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2426,"ip_address":""},"score":4918,"extra":""}]}]},{"had_liked":false,"id":72807,"user_name":"探索无止境","can_delete":false,"product_type":"c1","uid":1044178,"ip_address":"","ucode":"91D2A9907DFA79","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/d2/7024431c.jpg","comment_is_top":false,"comment_ctime":1551741677,"is_pvip":false,"replies":[{"id":"26463","content":"理解正确！","user_name":"作者回复","comment_id":72807,"uid":"1269969","ip_address":"","utype":1,"ctime":1551788517,"user_name_real":"王宝令"}],"discussion_count":4,"race_medal":0,"score":"250659844845","product_id":100023901,"comment_content":"不能，因为new了，所以不是同一把锁。老师您好，我对那 synchronized的理解是这样，它并不能改变CPU时间片切换的特点，只是当其他线程要访问这个资源时，发现锁还未释放，所以只能在外面等待，不知道理解是否正确","like_count":58,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441761,"discussion_content":"理解正确！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551788517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1542037,"avatar":"https://static001.geekbang.org/account/avatar/00/17/87/95/cba0a896.jpg","nickname":"卢","note":"","ucode":"B6A9F41AEE348C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292175,"discussion_content":"老哥厉害了。我也想明白了，时间片是改变不了的，但是发生线程切换后，后来的线程没有获取锁，还是会卡住\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595129887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1107484,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e6/1c/9d3744ee.jpg","nickname":"小李讲源码","note":"","ucode":"2573037D7C82C8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287968,"discussion_content":"优秀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593602124,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018620,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/fc/d1dd57dd.jpg","nickname":"ipofss","note":"","ucode":"DE3061C9259F9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":19583,"discussion_content":"“synchronized它并不能改变CPU时间片切换的特点，只是当其他线程要访问这个资源时，发现锁还未释放，所以只能在外面等待”，厉害了老哥，帮助我理解了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569208532,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74005,"user_name":"石头剪刀布","can_delete":false,"product_type":"c1","uid":1441361,"ip_address":"","ucode":"D0BBDBB6A26475","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/YibZAWyltDS6UaOwSGck6EicaEVxM4DxdGVs80GHH9kiclfFmOUMLyNuzIkQbRb1CmjX82PmEgWOtgWH2Cj2J27zA/132","comment_is_top":false,"comment_ctime":1552057582,"is_pvip":false,"replies":[{"id":"27035","content":"你这么优秀，我该怎么指导呢？你这不是用lock1 保护 lock2，lock2保护value吗？很符合我们的原则。我怎么没想到呢？<br>","user_name":"作者回复","comment_id":74005,"uid":"1269969","ip_address":"","utype":1,"ctime":1552091185,"user_name_real":"王宝令"}],"discussion_count":19,"race_medal":0,"score":"164760814830","product_id":100023901,"comment_content":"老师说：现实世界里，我们可以用多把锁来保护同一个资源，但在并发领域是不行的。<br>不能用两把锁锁定同一个资源吗？<br>如下代码：<br>public class X {<br>    private Object lock1 = new Object();<br>    private Object lock2 = new Object();<br>    private int value = 0;<br><br>    private void addOne() {<br>        synchronized (lock1) {<br>            synchronized (lock2) {<br>                value += 1;<br>            }<br>        }<br>    }<br><br>    private int get() {<br>        synchronized (lock1) {<br>            synchronized (lock2) {<br>                return value;<br>            }<br>        }<br>    }<br>}<br><br>虽然说这样做没有实际意义，但是也不会导致死锁或者其他不好的结果吧？请老师指导，谢谢。<br>","like_count":38,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442380,"discussion_content":"你这么优秀，我该怎么指导呢？你这不是用lock1 保护 lock2，lock2保护value吗？很符合我们的原则。我怎么没想到呢？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552091185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1484192,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/a0/e0cccf7e.jpg","nickname":"圆圆满满","note":"","ucode":"396E7A822014D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289352,"discussion_content":"理论上可以，但是第二把锁没啥用。因为第一把锁已经保证了同一时刻只有一个线程进来。我都已经进厕所了，再给马桶加把锁是不是有点闹心。","likes_number":27,"is_delete":false,"is_hidden":false,"ctime":1594080272,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":6,"child_discussions":[{"author":{"id":2057627,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/c38aFXkgKzcaEnz56Zyib5yE88NvzKrnYpJFTe9aodn0cXR2CwA1vs1sP7luwFHeSXuoJlreBtkq3YAFPlmibdibw/132","nickname":"Geek_9ad555","note":"","ucode":"50852723A22788","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1484192,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/a0/e0cccf7e.jpg","nickname":"圆圆满满","note":"","ucode":"396E7A822014D1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290652,"discussion_content":"我又瞬间明白了。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1594557526,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":289352,"ip_address":""},"score":290652,"extra":""},{"author":{"id":2013254,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/gqtlqgrVO9wcCDz4bFuoaYSQAXu7OyhKiczKn8LiaDtgsxlmCXAWMs99FQ1ggGqWFVRdVmzrrhUK4bkicDkkcZWVA/132","nickname":"陈斌","note":"","ucode":"E534DF6195A947","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1484192,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/a0/e0cccf7e.jpg","nickname":"圆圆满满","note":"","ucode":"396E7A822014D1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303919,"discussion_content":"牛逼的见解","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1599408153,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":289352,"ip_address":""},"score":303919,"extra":""},{"author":{"id":1367048,"avatar":"https://static001.geekbang.org/account/avatar/00/14/dc/08/64f5ab52.jpg","nickname":"陈斌","note":"","ucode":"B639AB5F6AA03D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2013254,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/gqtlqgrVO9wcCDz4bFuoaYSQAXu7OyhKiczKn8LiaDtgsxlmCXAWMs99FQ1ggGqWFVRdVmzrrhUK4bkicDkkcZWVA/132","nickname":"陈斌","note":"","ucode":"E534DF6195A947","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342240,"discussion_content":"我们俩同名","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1610623065,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":303919,"ip_address":""},"score":342240,"extra":""}]},{"author":{"id":2076251,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/ae/5b/4bd42286.jpg","nickname":"宋计洋","note":"","ucode":"9A34E8F71C6CBD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":567567,"discussion_content":"我觉得大家别笑，这个挺有意思，现实世界多把锁保护一个资源很多例子，比如保险柜，防盗门，为什么程序不用这样呢，因为程序里面没有小偷，不会把你的锁破坏了。也许以后程序会出现这种锁，普通线程需要等待使用，小偷线程可以直接使用，这时候你就需要两把锁了（脑洞大开）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650944417,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2630669,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqbzslP4D2y7zmIKGhbRxm9eIialForSiacZTHPxcc26icMrRvHTGFPCTj5fRCZicHwQiay3iaibHELdv59w/132","nickname":"叽叽喳喳","note":"","ucode":"55FE0DAAE6C361","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":565555,"discussion_content":"脱裤子放屁没毛病。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650498470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2616795,"avatar":"https://static001.geekbang.org/account/avatar/00/27/ed/db/7199150b.jpg","nickname":"比方","note":"","ucode":"8A0C41C9D2473E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540106,"discussion_content":"秀儿","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639963519,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1078849,"avatar":"https://static001.geekbang.org/account/avatar/00/10/76/41/7ff49c40.jpg","nickname":"E^cho","note":"","ucode":"23DE4B7AD6C23C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372321,"discussion_content":"锁嵌套，就需要一个个解锁，没啥实际的作用，哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620286453,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1341612,"avatar":"https://static001.geekbang.org/account/avatar/00/14/78/ac/e5e6e7f3.jpg","nickname":"古夜","note":"","ucode":"0A82D3CFCEDF07","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271222,"discussion_content":"请问这种锁成员变量的方式和老师说的三种请问这种锁成员变量的方式是不是和锁this的方式是一个意思？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590108240,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1512642,"avatar":"https://static001.geekbang.org/account/avatar/00/17/14/c2/46ebe3a0.jpg","nickname":"侧耳倾听","note":"","ucode":"5BF2A2440B54F0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":238575,"discussion_content":"在加锁之前会判断当前锁的对象是不是同一个，如果是同一个，你第二个加锁实际没有意义，还是一把锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587223531,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1702511,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKUVVjoibAO1cWoM0VcOcbibT0O9bbOvgjJmn6fWyKRNWgrZsOuj7mSMSubFXknOxRP3ozoicdwp1zibw/132","nickname":"衡山弟子","note":"","ucode":"5C635588688A88","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":216692,"discussion_content":"666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585477718,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1400703,"avatar":"https://static001.geekbang.org/account/avatar/00/15/5f/7f/3d005d61.jpg","nickname":"Tyrone","note":"","ucode":"DA6F289438A750","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":198015,"discussion_content":"这个脑回路很六哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583462600,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1812970,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a9/ea/5bfce6c5.jpg","nickname":"mgs2002","note":"","ucode":"F5931108BD509B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":149427,"discussion_content":"哈哈，这个有点意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579751117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1171359,"avatar":"https://static001.geekbang.org/account/avatar/00/11/df/9f/6e3e1b77.jpg","nickname":"阿U","note":"","ucode":"161A8E74E0D612","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":103763,"discussion_content":"牛批","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577376767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1309592,"avatar":"https://static001.geekbang.org/account/avatar/00/13/fb/98/6f238b8e.jpg","nickname":"半个柚子","note":"","ucode":"CF5D1190D970A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62393,"discussion_content":"哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574839926,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77001,"user_name":"别皱眉","can_delete":false,"product_type":"c1","uid":1177354,"ip_address":"","ucode":"D24F65EFF65586","user_header":"https://static001.geekbang.org/account/avatar/00/11/f7/0a/067537fc.jpg","comment_is_top":false,"comment_ctime":1552800237,"is_pvip":false,"replies":[{"id":"28089","content":"1. println的代码里锁的this指的是你的控制台，这个锁跟你的代码没关系，而且println里也没有写操作，所以println不会导致强刷缓存。<br><br>我觉得是因为println产生了IO，IO相对CPU来说，太慢，所以这个期间大概率的会把缓存的值写入内存。也有可能这个线程被调度到了其他的CPU上，压根没有缓存，所以只能从内存取数。你调用sleep，效果应该也差不多。<br><br>2. 线程切换显然不足以保证可见性，保证的可见性只能靠hb规则。<br><br>3. 线程结束后，不一定会强刷缓存。否则Join的规则就没必要了<br><br>并发问题本来就是小概率的事件，尤其有了IO操作之后，概率就更低了。","user_name":"作者回复","comment_id":77001,"uid":"1269969","ip_address":"","utype":1,"ctime":1552808626,"user_name_real":"王宝令"}],"discussion_count":7,"race_medal":0,"score":"126106851821","product_id":100023901,"comment_content":"相信很多人跟我一样会碰到这个问题,评论里也看到有人在问，内容有点长，辛苦老师帮忙大家分析下了 哈哈<br>  ---------------------------------------------------------<br>public class A implements Runnable {<br>    public Integer b = 1;<br> <br>    @Override<br>    public void run() {<br>       System.out.println(&quot;A is begin!&quot;);<br>       while (true) {<br>               System.out.println(&quot;a&quot;);<br>           &#47;&#47; System.out.println(b);<br>           if (b.equals(2))<br>              break;<br>       }<br> <br>       System.out.println(&quot;A is finish!&quot;);<br>    }<br> <br>    public static void main(String[] args) {<br>       A a = new A();<br>       &#47;&#47;线程A<br>       new Thread(a).start();<br>       try {<br>           Thread.sleep(1000);<br>       } catch (InterruptedException e) {<br>           e.printStackTrace();<br>       }<br>       a.b = 2;<br>    }<br>}<br> <br>我们知道这个程序会出现可见性问题。<br>但是在while内加上System.out.println(b)后 当主线程修改b的值后 线程A居然能够取得最新值 可见性问题得到解决<br>System.out.println(b)的实现如下<br>    public void println(String x) {<br>        synchronized (this) {<br>            print(x);<br>            newLine();<br>        }<br>    }<br> <br>Doug Lea大神的Concurrent Programming in Java一书中有这样一个片段来描述synchronized这个关键字：<br> <br>这里英文就不放出来了 字数超过两千……<br>这篇文章也有提及https:&#47;&#47;www.jianshu.com&#47;p&#47;3c06ffbf0d52<br> <br>简单翻译一下：从本质上来说，当线程释放一个锁时会强制性的将工作内存中之前所有的写操作都刷新到主内存中去，而获取一个锁则会强制性的加载可访问到的值到线程工作内存中来。虽然锁操作只对同步方法和同步代码块这一块起到作用，但是影响的却是线程执行操作所使用的所有字段。<br><br><br>也就是说当调用System.out.println(&quot;a&quot;)时当前线程的缓存会被重新刷新过，所以才能够读到这个值最新值<br> ---------------------------------------------------------<br>然后问题来了<br>问题1:<br>首先上面的说法不知道是不是真的是这样。<br>然后我在下面加了System.out.println(b) 结果打印出来的是旧值，但是下面的b.equals(2)却能通过 这里没弄明白 我觉得应该是编译器进行了优化?因为现在大三能力不够，还没学会看class文件 没法验证<br> <br>问题2:<br>网上找了一些文章<br>有些人的说法是：打印是IO操作，而IO操作会引起线程的切换，线程切换会导致线程原本的缓存失效，从而也会读取到修改后的值。<br> <br>我尝试着将打印换成File file = new File(&quot;D:&#47;&#47;1.txt&quot;);这句代码，程序也能够正常的结束。当然，在这里也可以尝试将将打印替换成synchronized(A.class){ }这句空同步代码块，发现程序也能够正常结束。<br> <br>这里有个问题就是 线程切换时会把之前操作的相关数据保存到内存里，切换回来后会把内存里的数据重新加载到寄存器里吗，这样说的话 就算切换也是获取不到修改后的值的,不知道是什么做到能够读到这个修改后的值的？<br> <br>问题3:<br>是不是<br>线程执行过程中，操作系统会随机性的把缓存刷到内存<br>线程结束后一定会把缓存里的数据刷到内存<br><br> ---------------------------------------------------------<br>在评论里好多大神 能学到好多东西😄😄","like_count":29,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443536,"discussion_content":"1. println的代码里锁的this指的是你的控制台，这个锁跟你的代码没关系，而且println里也没有写操作，所以println不会导致强刷缓存。\n\n我觉得是因为println产生了IO，IO相对CPU来说，太慢，所以这个期间大概率的会把缓存的值写入内存。也有可能这个线程被调度到了其他的CPU上，压根没有缓存，所以只能从内存取数。你调用sleep，效果应该也差不多。\n\n2. 线程切换显然不足以保证可见性，保证的可见性只能靠hb规则。\n\n3. 线程结束后，不一定会强刷缓存。否则Join的规则就没必要了\n\n并发问题本来就是小概率的事件，尤其有了IO操作之后，概率就更低了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1552808626,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1359968,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c0/60/fb98f941.jpg","nickname":"谭小仙","note":"","ucode":"29DCABA1578A09","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381631,"discussion_content":"去看看.class文件你就懂了，编译器帮你做了什么。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625148196,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1148174,"avatar":"https://static001.geekbang.org/account/avatar/00/11/85/0e/e6640576.jpg","nickname":"阿声","note":"","ucode":"EEA5F2E9D4FC9C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326817,"discussion_content":"这是 System.out.println(b) 的方法实现：\npublic void println(Object x) {\n    String s = String.valueOf(x);\n    synchronized (this) {\n        print(s);\n        newLine();\n    }\n}\n\n\n在这一行 String s = String.valueOf(x)，来了个狸猫换太子，String s 是一个新的对象（String是不可变类），s对象里面的value[]复制的是Object x里面的value。\n可以参考Integer的toString()实现：\npublic static String toString(int i) {\n    if (i == Integer.MIN_VALUE)\n        return &#34;-2147483648&#34;;\n    int size = (i < 0) ? stringSize(-i) + 1 : stringSize(i);\n    char[] buf = new char[size];\n    getChars(i, size, buf);\n    return new String(buf, true);\n}\n\n所以最终print(s) 打印的是一个全新的对象，Object x对象进入synchronized 临界区后刷新了主内存中的最终数据，对print(s)来说已经没关系了\n\n思考，至于为什么System.out.println(Object x)如此实现，进行大胆的猜测：\n1、从逻辑上给出的表现是所见即所得，我当前是什么值，那我往控制台打印的就应该是什么值，而不应该被其他线程影响到（本地缓存刷新了最新值）\n2、这个地方使用 synchronized修饰，那一定是里面的操作属于临界资源，需要保护，这是目的。Object 被动的做了一次本地内存副本的刷新，我觉得是顺带的。\n\n总结：\n1、System.out.println(b) 虽然对当前线程的缓存做了一次本地内存的刷新，但是可以当成一个调剂。\n2、真的想要实现可见性原则，还是要在业务代码层面 显示的 用volatile之类的机制来保证。\n\n不知道我理解是否正确，欢迎大家指正。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605682573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1345041,"avatar":"","nickname":"Geek_c3ecc7","note":"","ucode":"F21F3E270FB264","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":272528,"discussion_content":"MESI协议了解下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590320840,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1210890,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7a/0a/0ce5c232.jpg","nickname":"吕","note":"","ucode":"8F08E2CB81C4C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":201686,"discussion_content":"我也没搞明白这个结果，我试了下，感觉说不通，按理应该会存在可见性的问题啊，但运行正常","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583825015,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1631281,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er8ok3W1JuxlK1eHjfylzhBwkFm8lkIr4KibzLic5YjonIXj4t9RNkKV0PBUZv1wPM0fwdIwib6pickGA/132","nickname":"Geek_e08661","note":"","ucode":"DFD60339814CA6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5510,"discussion_content":"老师好，针对回复1，我还存在疑问，如果是说切换的cpu无缓存还可以理解，但是说主线程在线程2进行io操作时，将b=2刷新到主内存，线程2的cpu缓存还是b=1,那么他怎么知道主内存被更新了。再做一个假设，假如线程2可以知道主内存更新，那么怎么确保线程2在线程1更新完b到主内存之后再去主内存更新值，如果在线程1更新之前去主内存更新b，此时的b还是等于1，望解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566312450,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1107484,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e6/1c/9d3744ee.jpg","nickname":"小李讲源码","note":"","ucode":"2573037D7C82C8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1631281,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er8ok3W1JuxlK1eHjfylzhBwkFm8lkIr4KibzLic5YjonIXj4t9RNkKV0PBUZv1wPM0fwdIwib6pickGA/132","nickname":"Geek_e08661","note":"","ucode":"DFD60339814CA6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287972,"discussion_content":"第一，根据mesi缓存一致性协议和处理器对总线的嗅探机制，能知道主内存的更新。\n第二，通过volatile关键字，或者对该操作加锁，来保证可见性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593602413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":5510,"ip_address":""},"score":287972,"extra":""}]}]},{"had_liked":false,"id":105633,"user_name":"老焦","can_delete":false,"product_type":"c1","uid":1464949,"ip_address":"","ucode":"74DDCA99E5B626","user_header":"https://static001.geekbang.org/account/avatar/00/16/5a/75/a7e79c49.jpg","comment_is_top":false,"comment_ctime":1561045688,"is_pvip":false,"replies":[{"id":"38252","content":"👍","user_name":"作者回复","comment_id":105633,"uid":"1269969","ip_address":"","utype":1,"ctime":1561076633,"user_name_real":"王宝令"}],"discussion_count":5,"race_medal":0,"score":"108935228088","product_id":100023901,"comment_content":"有同学说get方法不用sync也能保证可见性，这是对的。但如果真的这么做了，原子性就可能会被打破。sync并不保证线程不被中断。如果在写高低两个双字的中间写线程被中断，而读线程被调度执行，因为读没有尝试加锁，所以可以读到写了一半的结果。这种情况都不用考虑多核，单核都会出现原子性问题。所以谨慎起见还是给get加上sync保险点。","like_count":25,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454746,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561076633,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2014196,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTICpYDicqYOnUicMGJVcVyg32UwXiaSlBtVU2V2UC4dts1ddsCC2HPMYYmcbhe8QS2QR02DcXezLZ24Q/132","nickname":"Qoney","note":"","ucode":"A3EB4F1EA02531","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":272625,"discussion_content":"别瞎说，误导人，不是volitel修饰的实际对象的变量在线程中不可见，所以为了可见性加了锁","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1590329100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1729855,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKeA6Awf2hRPJlRa4ZWo6fq3EQRlNowxjkJ48aicsHiapyCtgBy5e6t3DEiadMY92c46wwlrOibOcoNCw/132","nickname":"来焕明","note":"","ucode":"C9A71D22FAB7A4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288671,"discussion_content":"更直观的理解，如果addOne() 是对对象的操作：setName(&#34;张三&#34;);setAge(20);  那get()就有可能读到name是张三，但是age不是20，刚好在setAge之前，CPU切换时间片，另一个线程读取了不完整的对象；","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1593837133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2797783,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/b0/d7/cb391b61.jpg","nickname":"ChesterChai","note":"","ucode":"E8C896CEF2B1A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":403936,"discussion_content":"get方法不用sync怎么保证可见性的？用volitel吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634193236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378965,"discussion_content":"多线程下，get()在读，addOne在写，写的值还没刷到内存，此时是get()方法是读不到addOne修改的值，所以读写需要互斥，get()方法需要加上锁才行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623566106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75735,"user_name":"别皱眉","can_delete":false,"product_type":"c1","uid":1177354,"ip_address":"","ucode":"D24F65EFF65586","user_header":"https://static001.geekbang.org/account/avatar/00/11/f7/0a/067537fc.jpg","comment_is_top":false,"comment_ctime":1552461119,"is_pvip":false,"replies":[{"id":"27641","content":"我觉得你这个才是正道，并发问题小心还躲不过呢，哪里敢冒险啊！没想到还有学生看这个专栏，有前途👍<br><br>","user_name":"作者回复","comment_id":75735,"uid":"1269969","ip_address":"","utype":1,"ctime":1552479779,"user_name_real":"王宝令"}],"discussion_count":2,"race_medal":0,"score":"108926643519","product_id":100023901,"comment_content":"老师，我觉得get方法有必要用加锁来保证可见性的另一个理由如下:<br>class SafeCalc {<br>\tlong value = 0L;<br><br>\tsynchronized long get() {<br>\t\treturn value;<br>\t}<br><br>\tsynchronized void add(int i) {<br>\t\t&#47;&#47; 业务代码....假如这里比较耗时<br>\t\tvalue += i;<br>\t}<br>}<br><br>假如线程A执行add方法 当方法还没执行完<br>线程B执行get方法 <br>如果get方法没有加锁 因为此时A正在修改这个数据  B获取的数据不是最新的 <br><br>您看我说的对吗？还是说具体场景有不同的需求，有些还是允许这点延迟的？<br>本人大三，请前辈多指教😁😁谢谢<br>","like_count":25,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443007,"discussion_content":"我觉得你这个才是正道，并发问题小心还躲不过呢，哪里敢冒险啊！没想到还有学生看这个专栏，有前途👍\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552479779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645430,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiauonyMORA2s43W7mogGDH4WYjW0gBJtYmUa9icTB6aMPGqibicEKlLoQmLKLWEctwHzthbTZkKR20w/132","nickname":"Spring4J","note":"","ucode":"06F056085A2564","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544599,"discussion_content":"我倒是觉得有没有必要得看具体需求，在读的时候已经有线程在写，如果需求是想要get正在写的新值，那么就加sync，如果需求是允许get上次写的旧值，那么就不加","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641585290,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72781,"user_name":"大南瓜","can_delete":false,"product_type":"c1","uid":1302444,"ip_address":"","ucode":"8801F97AE9DB1B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/4QtlO84mT9kcRmeglzXJxM31KiboYG3lIiaYXqKODYH0iaHdQibrwiaAhyUxIedjOliaXOP8pq7k6XZWFeiamGa6u6IOw/132","comment_is_top":false,"comment_ctime":1551716023,"is_pvip":false,"replies":[{"id":"26454","content":"为快点赞","user_name":"作者回复","comment_id":72781,"uid":"1269969","ip_address":"","utype":1,"ctime":1551787897,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"78861127351","product_id":100023901,"comment_content":"沙发，并不能，不是同一把锁","like_count":18,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441742,"discussion_content":"为快点赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551787897,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75775,"user_name":"别皱眉","can_delete":false,"product_type":"c1","uid":1177354,"ip_address":"","ucode":"D24F65EFF65586","user_header":"https://static001.geekbang.org/account/avatar/00/11/f7/0a/067537fc.jpg","comment_is_top":false,"comment_ctime":1552467115,"is_pvip":false,"replies":[{"id":"27624","content":"按照规范是不能保证的，具体实现现在可以，这两个不矛盾，但是我们不能依赖没有承诺的实现，它可以随时改，规范就不可以随时改。<br>我们这里就采取遵循规范。","user_name":"作者回复","comment_id":75775,"uid":"1269969","ip_address":"","utype":1,"ctime":1552476208,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"57387041963","product_id":100023901,"comment_content":"老师，我对您对成华的回答有点疑问<br><br>------------------------------------------------------------<br>陈华:<br>我理解get方法不需要加synchroized关键字，也可以保证可见性。<br>因为 对 value的写有被 synchroized 修饰，addOne（）方法结束后，会强制其他CPU缓存失效，从新从内存读取最新值！<br> <br>class SafeCalc {<br>long value = 0L;<br>long get() {<br>return value;<br>}<br>synchronized void addOne() {<br>value += 1;<br>}<br>}<br>2019-03-07作者回复 说的对，从实现上看是这样。但是hb没有这样的要求<br><br>------------------------------------------------------------<br>会强制其他CPU缓存失效，从新从内存读取最新值？如果陈华说的是正确的，那get方法就不用加synchronized就可以保证可见性了？<br><br>但您文章里说的是get方法不加锁可见性是无法保证的<br><br><br>","like_count":13,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443028,"discussion_content":"按照规范是不能保证的，具体实现现在可以，这两个不矛盾，但是我们不能依赖没有承诺的实现，它可以随时改，规范就不可以随时改。\n我们这里就采取遵循规范。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552476208,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73085,"user_name":"小和尚笨南北","can_delete":false,"product_type":"c1","uid":1204628,"ip_address":"","ucode":"17C9BBB6DD25D2","user_header":"https://static001.geekbang.org/account/avatar/00/12/61/94/713b38ef.jpg","comment_is_top":false,"comment_ctime":1551794652,"is_pvip":false,"replies":[{"id":"26582","content":"比喻很生动","user_name":"作者回复","comment_id":73085,"uid":"1269969","ip_address":"","utype":1,"ctime":1551832227,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"53091402204","product_id":100023901,"comment_content":"不正确<br>使用锁保护资源时，对资源的所有操作应该使用同一个锁，这样才能起到保护的作用。<br>课后题中每个线程对资源的操作都是用的是各自的锁，不存在互斥和竞争的情况。<br>这就相当于有一个房间，每个人过来都安装一个门，每个人都有自己门的钥匙，大家都可以随意出入这个房间。<br>由于每个线程都可以随时进入方法，所以存在原子性问题；<br>但是因为每次都有加锁和解锁的操作，unlock操作会使其他缓存的变量失效，需要重新从主内存中加载变量的值，所以可以解决可见性问题。<br>如有错误，请老师指正。","like_count":12,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441906,"discussion_content":"比喻很生动","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551832227,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73664,"user_name":"陈华","can_delete":false,"product_type":"c1","uid":1082730,"ip_address":"","ucode":"3AF9E8EB39E507","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtS26SJpSF7JLu9pusGsy1Qln0NdQg1eV2YKOJxpX2QXaBuuyXMqZY3fm0rhzKwsqN5aa6CVNOQQ/132","comment_is_top":false,"comment_ctime":1551952766,"is_pvip":false,"replies":[{"id":"26907","content":"你说的对，从实现上看是这样。但是hb没有这样的要求<br>","user_name":"作者回复","comment_id":73664,"uid":"1269969","ip_address":"","utype":1,"ctime":1551962416,"user_name_real":"王宝令"}],"discussion_count":11,"race_medal":0,"score":"48796593022","product_id":100023901,"comment_content":"我理解get方法不需要加synchroized关键字，也可以保证可见性。<br>因为 对 value的写有被 synchroized 修饰，addOne（）方法结束后，会强制其他CPU缓存失效，从新从内存读取最新值！<br><br>class SafeCalc {<br>  long value = 0L;<br>  long get() {<br>    return value;<br>  }<br>  synchronized void addOne() {<br>    value += 1;<br>  }<br>}<br>","like_count":11,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442212,"discussion_content":"你说的对，从实现上看是这样。但是hb没有这样的要求\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551962416,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1747184,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/a8/f0/529f15e9.jpg","nickname":"第四单元","note":"","ucode":"3ED9D553E1DE17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371973,"discussion_content":"所以一次addOne运行结束后，调用get方法对value是可见的。但是在addOne方法修改了value，但方法还没有运行完的间隙，如果调用get方法，就有可见性问题了吧。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1620110128,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1230417,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c6/51/e39b5828.jpg","nickname":"刘鹏","note":"","ucode":"44F3D4DB3F5678","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":128122,"discussion_content":"我觉得解锁后应该强刷主存了，否则管程的happens-before怎么实现的。即使是对象锁，锁的的对象，但下个进锁的线程还可以看到上一个的操作","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578617367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1264392,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4b/08/52954cd7.jpg","nickname":"丁乐洪","note":"","ucode":"549CE57AB20B49","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352200,"discussion_content":"hb是啥？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614647614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1747184,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/a8/f0/529f15e9.jpg","nickname":"第四单元","note":"","ucode":"3ED9D553E1DE17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1264392,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4b/08/52954cd7.jpg","nickname":"丁乐洪","note":"","ucode":"549CE57AB20B49","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371971,"discussion_content":"happen before，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620109744,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":352200,"ip_address":""},"score":371971,"extra":""}]},{"author":{"id":1621470,"avatar":"https://static001.geekbang.org/account/avatar/00/18/bd/de/e0c994b3.jpg","nickname":"坐地铁的程序员","note":"","ucode":"A04A239D173E2A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4276,"discussion_content":"“因为 对 value的写有被 synchroized 修饰，addOne（）方法结束后，会强制其他CPU缓存失效”不对吧！执行下面这段代码试一下\npublic class ThreadDemo implements Runnable{\n\n    public Integer b = 1;\n\n    @Override\n    public void run() {\n        System.out.println(&#34;A is begin&#34;);\n        while (true){\n            System.out.println(get());\n            if(get() == 1L){\n                break;\n            }\n        }\n        System.out.println(&#34;A is end&#34;);\n    }\n\n    long value = 0L;\n    long get() {\n        return value;\n    }\n    void addOne() {\n        synchronized (new Object()) {\n            value += 1;\n        }\n    }\n\n\n    public static void main(String[] args) {\n\n        ThreadDemo threadDemo = new ThreadDemo();\n        new Thread(threadDemo).start();\n\n        try {\n            TimeUnit.MILLISECONDS.sleep(2000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(&#34;main sleep end&#34;);\n        threadDemo.addOne();\n        try {\n            TimeUnit.MILLISECONDS.sleep(2000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(&#34;main end&#34;);\n\n    }\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565266013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1284938,"avatar":"https://static001.geekbang.org/account/avatar/00/13/9b/4a/6faf0428.jpg","nickname":"sdyin","note":"","ucode":"7DA6F50117410E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1621470,"avatar":"https://static001.geekbang.org/account/avatar/00/18/bd/de/e0c994b3.jpg","nickname":"坐地铁的程序员","note":"","ucode":"A04A239D173E2A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":39144,"discussion_content":"System.out.println(get());  将这行改成 synchronized (this) {} 同样有效","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571896363,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4276,"ip_address":""},"score":39144,"extra":""},{"author":{"id":1521691,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/1b/5c1fefd9.jpg","nickname":"盛世半月","note":"","ucode":"D4B9ED91189BB4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1621470,"avatar":"https://static001.geekbang.org/account/avatar/00/18/bd/de/e0c994b3.jpg","nickname":"坐地铁的程序员","note":"","ucode":"A04A239D173E2A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378844,"discussion_content":"可能是指令重排序了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623462484,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4276,"ip_address":""},"score":378844,"extra":""}]},{"author":{"id":1430163,"avatar":"https://static001.geekbang.org/account/avatar/00/15/d2/93/9c58ce42.jpg","nickname":"HUANGKAIHANG","note":"","ucode":"F3871C5142AE52","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2830,"discussion_content":"当addOne方法加上synchronized关键字后，加锁时锁的是this对象，这时候其它线程不能调用this.get方法吧，这算不算间接达成了互斥？？如果是的话，那么这里的get方法不加锁也不会有可见性问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563959895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1179224,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fe/58/2cddaca4.jpg","nickname":"FH","note":"","ucode":"E47F6765CF1EEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1430163,"avatar":"https://static001.geekbang.org/account/avatar/00/15/d2/93/9c58ce42.jpg","nickname":"HUANGKAIHANG","note":"","ucode":"F3871C5142AE52","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":22046,"discussion_content":"加的是this锁, 不是class锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569569069,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2830,"ip_address":""},"score":22046,"extra":""},{"author":{"id":1077931,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Wy62w9wUM6hLpx7wSw0M1SPoT6pKr07yPHOib56CvtzIQ96t7eZkG4UHQ2kgp9jzBJzfxB1mlP8ibosdqxVwicQUw/132","nickname":"三良","note":"","ucode":"1AAAAED847D85E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1430163,"avatar":"https://static001.geekbang.org/account/avatar/00/15/d2/93/9c58ce42.jpg","nickname":"HUANGKAIHANG","note":"","ucode":"F3871C5142AE52","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":173000,"discussion_content":"“当addOne方法加上synchronized关键字后，加锁时锁的是this对象” 指的是当一个线程获取this对象锁后，其他线程如果想获取this对象锁则被阻塞，必须等待获取this对象锁的对象释放this对象锁后，再进行竞争。\n而如果get方法不通过synchronized加锁，那么调用get方法的线程并需要竞争this对象锁，也就不会被获取this对象锁的线程阻塞，也就跟通过synchronized修饰的方法不达成互斥关系。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1581822313,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2830,"ip_address":""},"score":173000,"extra":""}]}]},{"had_liked":false,"id":108040,"user_name":"空白","can_delete":false,"product_type":"c1","uid":1084378,"ip_address":"","ucode":"1E1E05CF8A7B1B","user_header":"https://static001.geekbang.org/account/avatar/00/10/8b/da/c3c2a324.jpg","comment_is_top":false,"comment_ctime":1561651607,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35921389975","product_id":100023901,"comment_content":"在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。<br><br>如果同步块所使用的锁对象通过这种分析被证实只能够被一个线程访问，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这个取消同步的过程就叫同步省略，也叫锁消除。","like_count":8},{"had_liked":false,"id":81758,"user_name":"彻头撤尾","can_delete":false,"product_type":"c1","uid":1421174,"ip_address":"","ucode":"7B120836359858","user_header":"https://static001.geekbang.org/account/avatar/00/15/af/76/feaffdea.jpg","comment_is_top":false,"comment_ctime":1554027034,"is_pvip":false,"replies":[{"id":"29625","content":"感谢热心同学的回复！！","user_name":"作者回复","comment_id":81758,"uid":"1269969","ip_address":"","utype":1,"ctime":1554030936,"user_name_real":"王宝令"}],"discussion_count":3,"race_medal":0,"score":"27323830810","product_id":100023901,"comment_content":"别皱眉同学,我特意把你的代码考下来了,run方法里什么都不加 就是死循环,加一个变量b==2作为循环出口,线程b也可以正常退出的啊!!!!线程可见性问题应该描述的是变量被修改的这一瞬间其他线程可见性问题吧?你加不加打印语句,加不加同步代码块都不会影响线程b的正常结束吧?只要变量最新值刷到主内存中,线程b 就可见然后就终止了.","like_count":6,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445333,"discussion_content":"感谢热心同学的回复！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554030936,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1442462,"avatar":"https://static001.geekbang.org/account/avatar/00/16/02/9e/ddd2d161.jpg","nickname":"天堂","note":"","ucode":"69144CAE0545E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":19110,"discussion_content":"我在我电脑上运行了一下，发现如果没有打印语句，只添加b==2作为循环退出条件的话，线程b是没法结束的。虽然主线程修改了b的值，主线程结束时，会把值写回内存。内存中的值虽然刷新了，但是此时b线程并没有再去内存中取b最新的值，所以还是一个死循环。\npublic class Demo3 implements Runnable{\n\n    private int b;\n\n    @Override\n    public void run() {\n        System.out.println(&#34;begin&#34;);\n       while(true){\n           if(b == 2){\n               break;\n           }\n       }\n        System.out.println(&#34;finish&#34;);\n    }\n\n    public static void main(String[] args) {\n        Demo3 demo3 = new Demo3();\n        new Thread(demo3).start();\n        try {\n            Thread.currentThread().sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        demo3.b = 2;\n    }\n\n\n}","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1569138686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1153455,"avatar":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","nickname":"饭粒","note":"","ucode":"4C3220B0D43997","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390793,"discussion_content":"循环体内加上那句sout打印能跳出循环，没有那句打印就死循环了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630048316,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81581,"user_name":"侯大虎","can_delete":false,"product_type":"c1","uid":1345219,"ip_address":"","ucode":"6450C75089FDB2","user_header":"","comment_is_top":false,"comment_ctime":1553952817,"is_pvip":false,"replies":[{"id":"29555","content":"没有包含关系，就像公交卡和单次票一样，都能坐车<br>","user_name":"作者回复","comment_id":81581,"uid":"1269969","ip_address":"","utype":1,"ctime":1553988700,"user_name_real":"王宝令"}],"discussion_count":4,"race_medal":0,"score":"27323756593","product_id":100023901,"comment_content":"老师，有个小问题  class锁锁的是该类的所有实例，和this不应该是同一把锁吗(this不就是这个类的实例吗)？","like_count":6,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445259,"discussion_content":"没有包含关系，就像公交卡和单次票一样，都能坐车\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553988700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1183424,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0e/c0/95fa2666.jpg","nickname":"山楂树","note":"","ucode":"1D59FC0C560BCD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5879,"discussion_content":"class锁是锁的这个类的字节码，不是所有实例吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566523343,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1102959,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d4/6f/8563b3ba.jpg","nickname":"Sunny","note":"","ucode":"6A57AA315EE4E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4434,"discussion_content":"同样疑惑，但是老师回答还是没明白","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565417657,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1535160,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/f0ibYgWiaKvSl0c7e0qhVgQE1z58EOauwFneXs6rh34a224w6LIbFYD8z8PF1K4ftSdeicJVcfPcPic1iaKBnPLMlGA/132","nickname":"Geek_kakaka","note":"","ucode":"FE20881B43C0C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1102959,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d4/6f/8563b3ba.jpg","nickname":"Sunny","note":"","ucode":"6A57AA315EE4E0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215853,"discussion_content":"class是用来唯一的描述这个类的，而this表示的是当前类的实例对象。举个例子就是，一个是模板（类的Class对象），一个是通过模板生成的对象，这两个对象是不一样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585390542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4434,"ip_address":""},"score":215853,"extra":""}]}]},{"had_liked":false,"id":76992,"user_name":"别皱眉","can_delete":false,"product_type":"c1","uid":1177354,"ip_address":"","ucode":"D24F65EFF65586","user_header":"https://static001.geekbang.org/account/avatar/00/11/f7/0a/067537fc.jpg","comment_is_top":false,"comment_ctime":1552797449,"is_pvip":false,"replies":[{"id":"28087","content":"1. synchronized 能保证互斥，所以操作1完成后刷入内存也没问题。如果你同步代码块里要操作10亿个共享变量，它不放内存放哪里呢？缓存早就爆表了。<br>2. 同意<br>3. 同意，另外volatile还会遵循hb规则。Synchronized解锁后会强刷缓存。","user_name":"作者回复","comment_id":76992,"uid":"1269969","ip_address":"","utype":1,"ctime":1552806635,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"23027633929","product_id":100023901,"comment_content":"老师，我有几个问题比较疑惑😄<br>---------------------------------------------<br>问题1: <br>synchronized void test() {<br>        &#47;&#47;操作1<br>        value = value + 1;<br>         &#47;&#47;业务方法....<br>        &#47;&#47;操作2<br>         value = value + 2;<br>  }<br>为保证原子性，也就是value中间状态对外不可见，我觉得操作1完成后不会将最新值刷回内存,而是到解锁后才会将在synchronized块中操作的数据刷回内存！<br> --------------------------------------------------<br>问题2：<br>有些同学说将value变量加volitile也可以实现同样效果.<br>我觉得不行，可见性保证了，原子性却会被破坏。理由如下:<br>基于问题1，假设操作1完成后不会将最新值刷回内存，那如果此时value变量加volitile上后，操作1完成后那岂不是会将这个中间值value存入内存?如果真是这样，原子性是保证不了的。<br> ----------------------------------------------------<br>问题3:<br>volatile int x = 0：告诉编译器，对这个变量的读写，不能使用 CPU 缓存，必须从内存中读取或者写入。<br> <br>Synchronized即保证可见性，又保证原子性。<br>那要保证可见性，在Synchronized块中是不是第一次读取到变量value时将直接从内存读，解锁时，将最新值刷回内存。<br><br><br>希望老师帮忙分析下 谢谢🙏🙏🙏","like_count":5,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443533,"discussion_content":"1. synchronized 能保证互斥，所以操作1完成后刷入内存也没问题。如果你同步代码块里要操作10亿个共享变量，它不放内存放哪里呢？缓存早就爆表了。\n2. 同意\n3. 同意，另外volatile还会遵循hb规则。Synchronized解锁后会强刷缓存。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552806635,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75790,"user_name":"虎虎❤️","can_delete":false,"product_type":"c1","uid":1086535,"ip_address":"","ucode":"157F261E80291A","user_header":"https://static001.geekbang.org/account/avatar/00/10/94/47/75875257.jpg","comment_is_top":false,"comment_ctime":1552469351,"is_pvip":false,"replies":[{"id":"27636","content":"总结的很对，👍👍👍<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552479163,"ip_address":"","comment_id":75790,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23027305831","product_id":100023901,"comment_content":"请老师对我的理解进行指正：<br><br>锁和被保护资源的关系？<br><br>互斥锁锁住了一个代码段 除非获得互斥锁，否则其他的线程不能访问这段代码。 代码段中包含了对被保护资源的操作。<br>但是 这把锁似乎可以是任何的对象。 这个锁对象可以和被保护资源有或者没有任何包含关系。有包含关系的就是用this，<br>没有包含关系的情况比如：<br>public class DemoClass<br>{<br>    private final Object lock = new Object();<br>    public void demoMethod(){<br>        synchronized (lock)<br>        {<br>            &#47;&#47;other thread safe code<br>        }<br>    }<br>}<br><br>对于class level的synchronized，我的理解是static变量属于类而被所有实例共用。所以用object.class这个对象作为锁非常合适。这也等价于<br>public class DemoClass<br>{<br>    private final static Object lock = new Object();<br> <br>    public void demoMethod()<br>    {<br>        &#47;&#47;Lock object is static<br>        synchronized (lock)<br>        {<br>            &#47;&#47;other thread safe code<br>        }<br>    }<br>}<br><br>然而用object.class作为锁来保护一个非静态资源就不太合适了。例如<br>class X {<br>  &#47;&#47; 修饰静态方法<br>  synchronized(X.class) void bar() {<br>    &#47;&#47; 临界区<br>  }<br>}<br>类的不同实例都可能来竞争这同一个锁，会导致并发程序非常低效。<br><br>另外，不要用String的字面量来作为锁，可能会被其他的对象引用，导致死锁。<br><br>不要用non-final的field来作为锁，non final的对象可能会随时被改变，而导致两个线程synchronize on different object。","like_count":5,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443034,"discussion_content":"总结的很对，👍👍👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552479163,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73416,"user_name":"churchchen","can_delete":false,"product_type":"c1","uid":1341972,"ip_address":"","ucode":"59DF322598870C","user_header":"https://static001.geekbang.org/account/avatar/00/14/7a/14/1aeddf3a.jpg","comment_is_top":false,"comment_ctime":1551881108,"is_pvip":false,"replies":[{"id":"26862","content":"get和addone锁的是一个对象，结合上一期的hb规则再想想<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551957820,"ip_address":"","comment_id":73416,"utype":1}],"discussion_count":4,"race_medal":0,"score":"23026717588","product_id":100023901,"comment_content":"class SafeCalc {<br>  static long value = 0L;<br>  synchronized long get() {<br>    return value;<br>  }<br>  synchronized static void addOne() {<br>    value += 1;<br>  }<br>}<br><br><br>get()方法的可见性不太理解为什么不能保证","like_count":5,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442075,"discussion_content":"get和addone锁的是一个对象，结合上一期的hb规则再想想\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551957820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2014196,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTICpYDicqYOnUicMGJVcVyg32UwXiaSlBtVU2V2UC4dts1ddsCC2HPMYYmcbhe8QS2QR02DcXezLZ24Q/132","nickname":"Qoney","note":"","ucode":"A3EB4F1EA02531","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":272633,"discussion_content":"他发的代码有问题，不是老师的代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590329857,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1641319,"avatar":"https://static001.geekbang.org/account/avatar/00/19/0b/67/dc49a1a8.jpg","nickname":"在路上","note":"","ucode":"E1184E76B14431","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":131287,"discussion_content":"首先get方法锁的对象是this,而addOne方法锁的对象是该类的Class对象。因为这两个方法锁的不是同一个对象，那就存在同一时间一个线程执行get方法一个线程执行addOne方法的可能。如果在A线程执行addOne方法是执行完了加以的操作，但是还没执行到锁的释放，然后此时切换到B线程执行get方法。因此B线程读取的还是旧值，因为A的所还没释放它的缓存就可能还没同步到主内存中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578836086,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2014196,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTICpYDicqYOnUicMGJVcVyg32UwXiaSlBtVU2V2UC4dts1ddsCC2HPMYYmcbhe8QS2QR02DcXezLZ24Q/132","nickname":"Qoney","note":"","ucode":"A3EB4F1EA02531","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1641319,"avatar":"https://static001.geekbang.org/account/avatar/00/19/0b/67/dc49a1a8.jpg","nickname":"在路上","note":"","ucode":"E1184E76B14431","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":272632,"discussion_content":"明明就是锁的同一个对象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590329791,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":131287,"ip_address":""},"score":272632,"extra":""}]}]},{"had_liked":false,"id":72878,"user_name":"程序员星星toC","can_delete":false,"product_type":"c1","uid":1218860,"ip_address":"","ucode":"2581BCBB3DC089","user_header":"https://static001.geekbang.org/account/avatar/00/12/99/2c/faadcfbc.jpg","comment_is_top":false,"comment_ctime":1551749821,"is_pvip":false,"replies":[{"id":"26484","content":"有兴趣的自己找资料看吧","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551794477,"ip_address":"","comment_id":72878,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23026586301","product_id":100023901,"comment_content":"synchronized的加锁解锁，具体是怎么实现的，没有讲","like_count":5,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441804,"discussion_content":"有兴趣的自己找资料看吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551794477,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2385122,"avatar":"","nickname":"Geek_a56085","note":"","ucode":"6E1E5A529E8F6E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337334,"discussion_content":"MySql实战45 和这个完全不能相比，原理都不讲，醉了？至少一次讲的明白?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608877768,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148596,"user_name":"贾静","can_delete":false,"product_type":"c1","uid":1059377,"ip_address":"","ucode":"081E70CC01F6B8","user_header":"https://static001.geekbang.org/account/avatar/00/10/2a/31/9edbf8a6.jpg","comment_is_top":false,"comment_ctime":1573035855,"is_pvip":true,"replies":[{"id":"57243","content":"是的，需要xxx.class来锁","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1573047841,"ip_address":"","comment_id":148596,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18752905039","product_id":100023901,"comment_content":"<br>class SafeCalc {<br>  static long value = 0L;<br>  synchronized long get() {<br>    return value;<br>  }<br>  synchronized void addOne() {<br>    value += 1;<br>  }<br>}<br>请问老师和留言区的同学，如果value是static，是不是用synchronized(this)就锁不住了？是不是要将get&#47;addOne方法也要加上static，这样是使用synchronized(xxx.class)来锁住value这个类中的临界资源","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473546,"discussion_content":"是的，需要xxx.class来锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573047841,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1367048,"avatar":"https://static001.geekbang.org/account/avatar/00/14/dc/08/64f5ab52.jpg","nickname":"陈斌","note":"","ucode":"B639AB5F6AA03D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342250,"discussion_content":"是否可以理解为：你用了锁，但是锁错资源了。你锁了this对象，实际上需要锁Class SafeCalc 。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610624556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":85883,"user_name":"Geek_9621ee","can_delete":false,"product_type":"c1","uid":1079138,"ip_address":"","ucode":"F136E7AC611A8B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLjrPm3HE2KwDa5zGK5N77KZwJEnPU5lgVhKuZicvQ1nL2iad92uetnCmdgIIxeCdu8lhoQ0w5uWEHA/132","comment_is_top":false,"comment_ctime":1555287974,"is_pvip":false,"replies":[{"id":"30892","content":"os的特权指令，可以关中断。但是普通的进程是做不到的。如果搞os可以，因为os是上帝。如果是普通人，想让自己长生不老，上帝不会答应的。所以看你站在哪个角度看待这个问题","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555295375,"ip_address":"","comment_id":85883,"utype":1}],"discussion_count":3,"race_medal":0,"score":"18735157158","product_id":100023901,"comment_content":"您好，我上次请教:synchronized 块中的代码为什么会发生线程切换，如果发生线程切换还如何保证原子性，您说 “原子性和线程切换没有什么关系，os想多会儿切换就多会切换”，但是我在今天的课中看到：“你已经知道，原子性问题的源头是线程切换，如果能够禁用线程切换那不就能解决这个问题了吗？而操作系统做线程切换是依赖 CPU 中断的，所以禁止 CPU 发生中断就能够禁止线程切换。”这是不是有点矛盾呢？","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446850,"discussion_content":"os的特权指令，可以关中断。但是普通的进程是做不到的。如果搞os可以，因为os是上帝。如果是普通人，想让自己长生不老，上帝不会答应的。所以看你站在哪个角度看待这个问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555295375,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1828913,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/e8/31/65efd664.jpg","nickname":"Tuzki","note":"","ucode":"C681B9EE5F7B2D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":194517,"discussion_content":"我是这样理解的，不知道对不对：\nOS规定每个线程只能在时间片内执行，时间片过后，OS会将资源分配给其他线程，只不过代码块上加了锁，OS没有将资源分配给别的线程，而是继续将时间片分配给原来的线程，知道他执行完，释放锁。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583227924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2573722,"avatar":"","nickname":"Geek_36e4bb","note":"","ucode":"90E84F8CC8A410","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370285,"discussion_content":"我理解,在单核cpu中原子性是因为线程切换造成的,但是在多核cpu中可能是线程切换也可能是多线程同时执行,所以有效的办法是保证临界区代码的互斥执行,这样既可以解决线程切换又可以解决多线程同时执行的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619356499,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74287,"user_name":"落落彩虹","can_delete":false,"product_type":"c1","uid":1264832,"ip_address":"","ucode":"F4CE1908DF149A","user_header":"https://static001.geekbang.org/account/avatar/00/13/4c/c0/73d52c05.jpg","comment_is_top":false,"comment_ctime":1552181492,"is_pvip":false,"replies":[{"id":"27168","content":"感谢不离不弃啊<br>测试的时候经常用sleep，实际项目还是用join吧。这个我感觉不能认为是join原则。规范里确实没有。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552190651,"ip_address":"","comment_id":74287,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18732050676","product_id":100023901,"comment_content":"老师的文章我都要看几遍.评论区也不敢放过.<br><br>评论区有些demo，注意关于join的hb原则；注意system.out.println对可见性的影响，该方法内部加锁了.<br>还有个问题，如果我不用join，而是sleep足够长时间以确保线程跑完了，也能保证可见性.因为线程结束了他的本地工作空间该释放了，数据要强制刷回内存了……这也可以认为是join的hb原则吗？我看网上说到hb都会把join的那个原则说成是线程终止规则.<br>","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442511,"discussion_content":"感谢不离不弃啊\n测试的时候经常用sleep，实际项目还是用join吧。这个我感觉不能认为是join原则。规范里确实没有。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552190651,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159330,"user_name":"yalio","can_delete":false,"product_type":"c1","uid":1131862,"ip_address":"","ucode":"FAB63813E4533A","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/56/60ee7623.jpg","comment_is_top":false,"comment_ctime":1575600287,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14460502175","product_id":100023901,"comment_content":"这个get方法加同步的，是需要的，因为另一个线程读取的时候，不一定是从主内存读，sync同步方法释放锁后也不会使得其他线程的缓存失效。","like_count":3},{"had_liked":false,"id":148256,"user_name":"苏暮沉觞","can_delete":false,"product_type":"c1","uid":1577580,"ip_address":"","ucode":"532B816D4EF47B","user_header":"https://static001.geekbang.org/account/avatar/00/18/12/6c/61a598e9.jpg","comment_is_top":false,"comment_ctime":1572964859,"is_pvip":false,"replies":[{"id":"57454","content":"1.理解是对的，没有共享就没有并发问题<br>2.单线程没有并发问题","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1573253143,"ip_address":"","comment_id":148256,"utype":1}],"discussion_count":3,"race_medal":0,"score":"14457866747","product_id":100023901,"comment_content":"老师，看完前文章和评论产生了几个问题，希望能解答一下：<br>1、文中说的多个线程调用synchronized的addOne()或者get()方法是针对同一个对象的方法。<br>例如 :对于类：<br>class SafeCalc { <br>static long value = 0L; <br>synchronized long get() { return value; } <br>synchronized void addOne() { value += 1; }<br>}<br>如果我们是：SafeCalc a = new SafeCalc();，两个线程同时调用a里的方法addOne()或get()，互斥锁才会生效。如果又SafeCalc b = new SafeCalc()，两个线程分别调用a,b里的方法addOne()或get(),互斥锁不会生效。这样理解对吗？<br>2、并发编程的是因为我们new多个线程执行同一块代码，然后CPU可能会同时运行到同一段代码，因此出现了可见性，原子性等并发问题。如果我们在程序中不创建多个线程，那么就算在多核CPU上运行，也不会出现并发问题？<br>","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473441,"discussion_content":"1.理解是对的，没有共享就没有并发问题\n2.单线程没有并发问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573253143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1577580,"avatar":"https://static001.geekbang.org/account/avatar/00/18/12/6c/61a598e9.jpg","nickname":"苏暮沉觞","note":"","ucode":"532B816D4EF47B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":44773,"discussion_content":"或者第一个问题理解为如果new两个对象，因为不同线程竞争的不是同一把锁，所以不会有互斥现象？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1572965141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378967,"discussion_content":"单线程没有并发问题？单线程下线程切换不是有原子性问题吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623567093,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81046,"user_name":"Monster!","can_delete":false,"product_type":"c1","uid":1179101,"ip_address":"","ucode":"74F1D3BB5E3915","user_header":"https://static001.geekbang.org/account/avatar/00/11/fd/dd/baeda83e.jpg","comment_is_top":false,"comment_ctime":1553784941,"is_pvip":false,"replies":[{"id":"29427","content":"那两个线程还没来得及跑，主线程执行到return threadCountTest.count;了","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553786052,"ip_address":"","comment_id":81046,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14438686829","product_id":100023901,"comment_content":" private volatile Long count = 0L;<br>    private  void add(){<br>        int add = 0;<br>        while (add++&lt;10000){<br>            count ++;<br>        }<br>    }<br>    public static Long calc() throws InterruptedException {<br>        ThreadCountTest threadCountTest = new ThreadCountTest();<br>        Thread thread1 = new Thread(()-&gt;{<br>            threadCountTest.add();<br>        });<br>        Thread thread2 = new Thread(() -&gt; {<br>            threadCountTest.add();<br>        });<br>        &#47;&#47;开启两个线程<br>        thread1.start();<br>        thread2.start();<br>        &#47;&#47;等待两个线程结束<br>        &#47;*thread1.join();<br>        thread2.join();*&#47;<br><br>        return threadCountTest.count;<br>    }<br>王老师，请教一下，根据上一节的思考题，如果要想让线程A对共享资源的修改对线程B可见其中一种方法就是在共享变量上加volatile关键字，如上述代码在注释掉两个方法的join()时得出的结果为0，放开两个join()方法后得出的结果又是随机的，这个问题出在哪里呢？","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445059,"discussion_content":"那两个线程还没来得及跑，主线程执行到return threadCountTest.count;了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553786052,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79503,"user_name":"Vincent","can_delete":false,"product_type":"c1","uid":1135159,"ip_address":"","ucode":"CD8B84A57A6A0C","user_header":"https://static001.geekbang.org/account/avatar/00/11/52/37/13b4c8aa.jpg","comment_is_top":false,"comment_ctime":1553499936,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14438401824","product_id":100023901,"comment_content":"synchronized 案例中锁是synchronized，锁定对象是this或者 XXX.class 这里来看，我们的锁结构是synchronized，锁定的资源是对应的this和 XXX.class，在文中作者特意区分锁结构和被保护的资源是很好的一点，但是行文中并没有特意去说明谁是锁结构，谁是被保护资源","like_count":3},{"had_liked":false,"id":73463,"user_name":"swx","can_delete":false,"product_type":"c1","uid":1236764,"ip_address":"","ucode":"EB677E52806C37","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1c/70d51b43.jpg","comment_is_top":false,"comment_ctime":1551890139,"is_pvip":false,"replies":[{"id":"26858","content":"你也会成为一尊大神的<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551957176,"ip_address":"","comment_id":73463,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14436792027","product_id":100023901,"comment_content":"线程每次调用方法锁的都是新new的一个对象。令哥讲解得透彻，让我这个菜鸟一看code就知道答案。此外，留言板潜伏一樽樽大神，有种豁然开朗的感觉。","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442100,"discussion_content":"你也会成为一尊大神的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551957176,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73041,"user_name":"jeeker","can_delete":false,"product_type":"c1","uid":1444583,"ip_address":"","ucode":"1E78795E7DF8E7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erS45sT36oSCibh8YMF9aD0IKltrdCoEicqUeEzbC2Hlr4UiahibfLvpib3LauzQxv6X3vyfCvrgz0m3dg/132","comment_is_top":false,"comment_ctime":1551782974,"is_pvip":false,"replies":[{"id":"26510","content":"是的，只要一把锁就行。但是工程上，这样容易出问题。因为这个锁是JVM全局唯一的。有可能别人也用这个","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551797279,"ip_address":"","comment_id":73041,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14436684862","product_id":100023901,"comment_content":"王老师,问个问题:<br>保护资源的时候是不是只要同一把锁就好了,而不是说必须得某一把锁是吗?<br>举个例子, 两个对象 A.class ,B.class 是不是可以这样操作<br>class A {<br> static int a ;<br> synchronized(B.class) static void add (){<br>     a+=1;<br>    }<br>} <br>这种情况下多线程是不是也是互斥的?","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441887,"discussion_content":"是的，只要一把锁就行。但是工程上，这样容易出问题。因为这个锁是JVM全局唯一的。有可能别人也用这个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551797279,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72839,"user_name":"Geek_c42505","can_delete":false,"product_type":"c1","uid":1232899,"ip_address":"","ucode":"6421EB85640C44","user_header":"https://static001.geekbang.org/account/avatar/00/12/d0/03/2e632d36.jpg","comment_is_top":false,"comment_ctime":1551746925,"is_pvip":false,"replies":[{"id":"26474","content":"实际上每次调用都创建新的锁，相当于没有锁。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551793555,"ip_address":"","comment_id":72839,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14436648813","product_id":100023901,"comment_content":"synchronized 作用于非静态方法上，加锁对象是当前对象，代码中new Object 作为锁，两个方法使用两个不同的锁保护同一个资源，是不能解决并发问题的","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441778,"discussion_content":"实际上每次调用都创建新的锁，相当于没有锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551793555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72816,"user_name":"Kaer","can_delete":false,"product_type":"c1","uid":1113558,"ip_address":"","ucode":"1BD233D3FAC2B1","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/d6/71e1cc29.jpg","comment_is_top":false,"comment_ctime":1551743277,"is_pvip":false,"replies":[{"id":"26472","content":"不是这样的。Safecalc.class是一个对象，this也是一个对象。他们是平级的。<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551793449,"ip_address":"","comment_id":72816,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14436645165","product_id":100023901,"comment_content":"老师，对于最后的锁定Safecalc.class和this不是一把锁有点疑问。都锁定了class了，在我理解这个时候this也应该是锁定的。这么说的话应该就是互斥的了。换一个角度理解：就是我把大门锁定了，房间肯定进不去，虽然不是一把锁，但是我觉得应该能保证互斥。","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441768,"discussion_content":"不是这样的。Safecalc.class是一个对象，this也是一个对象。他们是平级的。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551793449,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1061976,"avatar":"https://static001.geekbang.org/account/avatar/00/10/34/58/957ca791.jpg","nickname":"Alvin","note":"","ucode":"ECA64F2913024A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":353144,"discussion_content":"应该是get的synchronized去掉，加上static修饰就可以了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615031443,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72805,"user_name":"任鹏斌","can_delete":false,"product_type":"c1","uid":1104086,"ip_address":"","ucode":"34319B05EA6E74","user_header":"https://static001.geekbang.org/account/avatar/00/10/d8/d6/47da34bf.jpg","comment_is_top":false,"comment_ctime":1551741458,"is_pvip":false,"replies":[{"id":"26468","content":"每次调用都创建一把锁，其实相当于没有加锁。编译器优化后，就变成无锁了","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551793278,"ip_address":"","comment_id":72805,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14436643346","product_id":100023901,"comment_content":"锁定的是不同对象，相当于为不同的资源加锁，不能解决并发问题","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441759,"discussion_content":"每次调用都创建一把锁，其实相当于没有加锁。编译器优化后，就变成无锁了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551793278,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134495,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4f/9f/08b9eadf.jpg","nickname":"见贤思齐","note":"","ucode":"A5F586D8205745","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":128954,"discussion_content":"这个不是相当于锁不同的资源，上面有个同学的评论很形象，是相当于给一个房间开了多个门，房间里的东西就是资源，其中一个门锁了，并不能阻止从一个门去房间里的资源，不同的门之间没有互斥关系，所以这样的锁（门）是无效的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578668191,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245957,"user_name":"Can2","can_delete":false,"product_type":"c1","uid":1488987,"ip_address":"","ucode":"3177519C403EAB","user_header":"https://static001.geekbang.org/account/avatar/00/16/b8/5b/053d770f.jpg","comment_is_top":false,"comment_ctime":1599120902,"is_pvip":false,"replies":[{"id":"90433","content":"👍🏻","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1599175893,"ip_address":"","comment_id":245957,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10189055494","product_id":100023901,"comment_content":"加锁本质就是在锁对象的对象头中写入当前线程id，但是new object每次在内存中都是新对象，所以只有创建对象的线程可见，即不会发生逃逸。那么逃逸分析的优化结果就是同步消除，即发现某个对象只能从一个线程可访问，那么在这个对象上的操作可以不需要同步。总的来说，白加的锁。","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505019,"discussion_content":"👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599175893,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180357,"user_name":"褚","can_delete":false,"product_type":"c1","uid":1387363,"ip_address":"","ucode":"C2AA96A2E0F55F","user_header":"https://static001.geekbang.org/account/avatar/00/15/2b/63/ea02349c.jpg","comment_is_top":false,"comment_ctime":1582267012,"is_pvip":false,"replies":[{"id":"71267","content":"锁资源是形象说法，实际上就是锁定一个执行权限","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1583236778,"ip_address":"","comment_id":180357,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10172201604","product_id":100023901,"comment_content":"我感觉，锁并不是锁住资源，而是锁住代码块的执行权。对于锁资源这一块还是不能很好地理解，哪位大神能帮我解除一下疑惑","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484624,"discussion_content":"锁资源是形象说法，实际上就是锁定一个执行权限","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583236778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":111637,"user_name":"蒙面超人","can_delete":false,"product_type":"c1","uid":1107584,"ip_address":"","ucode":"9FE34EC44ABA78","user_header":"https://static001.geekbang.org/account/avatar/00/10/e6/80/c13098cc.jpg","comment_is_top":false,"comment_ctime":1562576740,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10152511332","product_id":100023901,"comment_content":"评论区的水平可以反映出作者的水平，很多大牛。哈哈哈，当然我这条不算","like_count":2,"discussions":[{"author":{"id":1103863,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d7/f7/e41209e0.jpg","nickname":"带刺的小黄瓜","note":"","ucode":"98C75CDC482C01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6374,"discussion_content":"搞的我都不想学了，这就跟我在读幼儿园，身边都是上了大学了同学！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1566873160,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":86241,"user_name":"Richard","can_delete":false,"product_type":"c1","uid":1302876,"ip_address":"","ucode":"C16AE7CE877DCA","user_header":"https://static001.geekbang.org/account/avatar/00/13/e1/5c/b32f00b1.jpg","comment_is_top":false,"comment_ctime":1555330291,"is_pvip":false,"replies":[{"id":"31150","content":"如果只需要可见性volatile就够了<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1555412672,"ip_address":"","comment_id":86241,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10145264883","product_id":100023901,"comment_content":"如果只是为了可见性的问题，是否可以在add方法上加锁，把value声明为volatile，而get方法不加锁。这样效率是不是会高一些啊。","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446934,"discussion_content":"如果只需要可见性volatile就够了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555412672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81762,"user_name":"彻头撤尾","can_delete":false,"product_type":"c1","uid":1421174,"ip_address":"","ucode":"7B120836359858","user_header":"https://static001.geekbang.org/account/avatar/00/15/af/76/feaffdea.jpg","comment_is_top":false,"comment_ctime":1554027820,"is_pvip":false,"replies":[{"id":"29626","content":"1. 只能保证锁住同一个实例的资源，不同的实例的锁不同,不存在互斥<br>2. 锁隐藏在对象内部，更安全。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554031089,"ip_address":"","comment_id":81762,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10143962412","product_id":100023901,"comment_content":"class X {<br>  &#47;&#47; 修饰代码块<br>  Object obj = new Object()；<br>  void baz() {<br>    synchronized(obj) {<br>      &#47;&#47; 临界区<br>    }<br>  }<br>}  <br>请问王老师,这种成员变量作为锁对象 是不是只能保证锁住同一个实例的资源,不同的实例的锁不同,不存在互斥关系?然后,这种成员变量作为锁对象和this关键字作为锁对象有什么区别么?","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445336,"discussion_content":"1. 只能保证锁住同一个实例的资源，不同的实例的锁不同,不存在互斥\n2. 锁隐藏在对象内部，更安全。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554031089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81675,"user_name":"Mr.Panda","can_delete":false,"product_type":"c1","uid":1238864,"ip_address":"","ucode":"655A3013B5E849","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/50/d476ed6c.jpg","comment_is_top":false,"comment_ctime":1554003377,"is_pvip":false,"replies":[{"id":"29619","content":"你说的是对的，而且更严谨。但是站在应用的角度，一般都忽略掉这些细节，这样在大脑里推演程序的执行会更容易。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554029522,"ip_address":"","comment_id":81675,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10143937969","product_id":100023901,"comment_content":"老师您好，望答疑<br>概念：“同一时刻只有一个线程执行”这个条件非常重要，我们称之为互斥<br>疑惑:  一段关注代码(多个操作指令)只能由个一个线程执行，就算中间发生线程切换，其他线程也不能执行这段代码，才叫互斥吧 <br>","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445294,"discussion_content":"你说的是对的，而且更严谨。但是站在应用的角度，一般都忽略掉这些细节，这样在大脑里推演程序的执行会更容易。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554029522,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73390,"user_name":"hxy","can_delete":false,"product_type":"c1","uid":1248553,"ip_address":"","ucode":"431327E8CA4364","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/29/18272af9.jpg","comment_is_top":false,"comment_ctime":1551876344,"is_pvip":true,"replies":[{"id":"26729","content":"这种简单情况，实际上出bug的概率还真是很低。但是低不意味着正确。<br>也不用奇怪，我们所说的都是可能。锁两个对象，编译器官方不保证可见性，私下里也许能保证。我们不能依赖于私下的方案。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551882492,"ip_address":"","comment_id":73390,"utype":1}],"discussion_count":1,"race_medal":4,"score":"10141810936","product_id":100023901,"comment_content":"老师请问synchronized修饰的临界区中，如果不是同一把锁，能保证共享变量的可见性吗？<br>    private final static int cnt = 10000;<br>    private static int tmp = 0;<br><br>    public static void main(String[] args) {<br><br>        Object lock1 = new Object();<br>        Object lock2 = new Object();<br><br>        Thread thread1 = new Thread(() -&gt; {<br>            synchronized (lock1) {<br>                for (int i = 0; i &lt; cnt; i++) {<br>                    tmp++;<br>                }<br>            }<br>        });<br>        Thread thread2 = new Thread(() -&gt; {<br>            Watch.slp(10L);<br>            synchronized (lock2) {<br>                System.out.println(&quot;tmp is: &quot; + tmp);<br>            }<br>        });<br><br>        thread2.start();<br>        thread1.start();<br>    }<br>我这样试了一下，thread2最后读的值是正确的，感觉有一点奇怪","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442059,"discussion_content":"这种简单情况，实际上出bug的概率还真是很低。但是低不意味着正确。\n也不用奇怪，我们所说的都是可能。锁两个对象，编译器官方不保证可见性，私下里也许能保证。我们不能依赖于私下的方案。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551882492,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73358,"user_name":"橘子","can_delete":false,"product_type":"c1","uid":1368522,"ip_address":"","ucode":"EDF6145878F897","user_header":"https://static001.geekbang.org/account/avatar/00/14/e1/ca/d8b0835f.jpg","comment_is_top":false,"comment_ctime":1551867475,"is_pvip":false,"replies":[{"id":"26725","content":"是的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551882203,"ip_address":"","comment_id":73358,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10141802067","product_id":100023901,"comment_content":"set和get都对同一个对象加锁，时候意味着，在并发情况下，get和set不能同时被调用，在同一时间只能调用一个？","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442039,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551882203,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378976,"discussion_content":"需要互斥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623571400,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72921,"user_name":"Geek_961eed","can_delete":false,"product_type":"c1","uid":1444566,"ip_address":"","ucode":"A62198D96379F5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erWxMXolPylQk8Z6V6yt2LtibksrksC4bHtmxkuCC4Wzw7trl6CfwmsSFMyHFItFnvl21RvQ8fyOBQ/132","comment_is_top":false,"comment_ctime":1551755367,"is_pvip":false,"replies":[{"id":"26489","content":"平行关系，中国和美国之间的关系。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551794866,"ip_address":"","comment_id":72921,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10141689959","product_id":100023901,"comment_content":"想问下作者，类锁和对象实例锁之间有什么联系？","like_count":2,"discussions":[{"author":{"id":1004192,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/52/a0/d308434e.jpg","nickname":"StarKing","note":"","ucode":"EB825CFA70AC1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":14985,"discussion_content":"还有区别的. 类锁在本地方法区域头头位置. 对象实例锁的堆中吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568793117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72870,"user_name":"波波","can_delete":false,"product_type":"c1","uid":1155827,"ip_address":"","ucode":"4344D9F4486D42","user_header":"https://static001.geekbang.org/account/avatar/00/11/a2/f3/aa504fa6.jpg","comment_is_top":false,"comment_ctime":1551748974,"is_pvip":false,"replies":[{"id":"26482","content":"我还是觉得内存模型讲的最好;)，以后的东西都很简单了","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551794331,"ip_address":"","comment_id":72870,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10141683566","product_id":100023901,"comment_content":"这一节锁讲的有新意，很少有书籍特地讲锁和锁定资源的关系，赞一个","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441801,"discussion_content":"我还是觉得内存模型讲的最好;)，以后的东西都很简单了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551794331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72848,"user_name":"小黄","can_delete":false,"product_type":"c1","uid":1049839,"ip_address":"","ucode":"519BF8191D3A6B","user_header":"https://static001.geekbang.org/account/avatar/00/10/04/ef/fea0fdbd.jpg","comment_is_top":false,"comment_ctime":1551747479,"is_pvip":false,"replies":[{"id":"26458","content":"👍<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551788251,"ip_address":"","comment_id":72848,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10141682071","product_id":100023901,"comment_content":"明显getOne 和 addOne 每次加锁在不同资源上，并没有形成互斥","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441784,"discussion_content":"👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551788251,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143881,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1571802745,"is_pvip":false,"replies":[{"id":"55683","content":"只是不允许两个线程同时进入临界区，没有其他约束","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1571925830,"ip_address":"","comment_id":143881,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5866770041","product_id":100023901,"comment_content":"”当修饰非静态方法的时候，锁定的是当前实例对象 this“<br>class X {<br>   public long var = 1;<br><br>  &#47;&#47; 修饰非静态方法<br>  synchronized void foo() {<br>    &#47;&#47; 临界区<br>  }<br>}<br>这种方式，如果说锁定的是当前对象的话，那是不是一个线程调用 foo 方法，然后持有锁。<br><br>那另一线程是不是不可以访问 var 这个 public 变量了？因为锁定了 X 整个对象？<br><br>","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471738,"discussion_content":"只是不允许两个线程同时进入临界区，没有其他约束","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571925830,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378968,"discussion_content":"只会锁临界资源，非临界资源不加锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623568363,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40472,"discussion_content":"明白了，我之前理解错误了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572220195,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137281,"user_name":"小氘","can_delete":false,"product_type":"c1","uid":1622109,"ip_address":"","ucode":"DA55B9A02D9EE0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erPMtAfnQdpx1yOZQ2ic7icqUs3tvibEjUXQMUXKiaakyuIho6k6vmdl46nrdWjXIjPIRg9Pmco00tR5w/132","comment_is_top":false,"comment_ctime":1569676527,"is_pvip":false,"replies":[{"id":"52755","content":"👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1569684507,"ip_address":"","comment_id":137281,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5864643823","product_id":100023901,"comment_content":"课后思考：不正确，两把不同的锁保护一个资源会出现线程a执行addOne方法拿锁la，线程b执行get方法拿锁lb，根本没有互斥，没有保证同一时刻只有一个线程可以操作。","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469017,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569684507,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129391,"user_name":"ly","can_delete":false,"product_type":"c1","uid":1221628,"ip_address":"","ucode":"5E2B85252DABF3","user_header":"https://static001.geekbang.org/account/avatar/00/12/a3/fc/379387a4.jpg","comment_is_top":false,"comment_ctime":1567125121,"is_pvip":false,"replies":[{"id":"48637","content":"能看到","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1567427875,"ip_address":"","comment_id":129391,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5862092417","product_id":100023901,"comment_content":"老师，对于前面那个addone方法加synchronize，但是get不加synchronize的例子，因为管程的规则，addone修改过的value只对加锁可见（也就是另一个synchronize方法），那如果我将value设置为volatile，那么这个没有synchronize的get方法应该能看到修改过的value值了吧？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465436,"discussion_content":"能看到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567427875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126712,"user_name":"王二宝","can_delete":false,"product_type":"c1","uid":1042241,"ip_address":"","ucode":"E147D6E597EF5B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e7/41/2ea1f5dc.jpg","comment_is_top":false,"comment_ctime":1566455913,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5861423209","product_id":100023901,"comment_content":"思考题：自家的锁，锁住了别家的财产，所以不能解决并发问题。","like_count":1,"discussions":[{"author":{"id":1004192,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/52/a0/d308434e.jpg","nickname":"StarKing","note":"","ucode":"EB825CFA70AC1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":14972,"discussion_content":"美其名约:掩耳盗铃","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568792159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117037,"user_name":"HUANGKAIHANG","can_delete":false,"product_type":"c1","uid":1430163,"ip_address":"","ucode":"F3871C5142AE52","user_header":"https://static001.geekbang.org/account/avatar/00/15/d2/93/9c58ce42.jpg","comment_is_top":false,"comment_ctime":1563958028,"is_pvip":false,"replies":[{"id":"43337","content":"要看this.get是不是也用的synchronized","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1564358466,"ip_address":"","comment_id":117037,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5858925324","product_id":100023901,"comment_content":"老师请问，给非静态方法addOne用synchronized修饰后，对应的锁是this这把锁，那么当一个线程执行addOne方法时，它是锁住了整个this，是不是意味着其它线程无法直接执行this.get方法？因为需要等到整个this解锁，那么这个时候，我是不是可以理解为没有线程能去执行get方法取值，也就保证了不会有并发问题？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459788,"discussion_content":"要看this.get是不是也用的synchronized","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564358466,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":111385,"user_name":"以梦为马","can_delete":false,"product_type":"c1","uid":1225455,"ip_address":"","ucode":"9995FC3FD620C6","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/ef/d969bf72.jpg","comment_is_top":false,"comment_ctime":1562549963,"is_pvip":false,"replies":[{"id":"40674","content":"原子操作一定能保证原子性，原子操作要分从哪个层面看，从CPU角度看和从程序角度看是不同的。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1562626366,"ip_address":"","comment_id":111385,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5857517259","product_id":100023901,"comment_content":"老师请问，原子性和原子操作是一回事情吗？加了synchronize后线程对addOne方法是原子操作，但是如果方法中有非原子性？有些疑惑","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457329,"discussion_content":"原子操作一定能保证原子性，原子操作要分从哪个层面看，从CPU角度看和从程序角度看是不同的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562626366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107310,"user_name":"000","can_delete":false,"product_type":"c1","uid":1052192,"ip_address":"","ucode":"98A810FA164106","user_header":"https://static001.geekbang.org/account/avatar/00/10/0e/20/4a8eb862.jpg","comment_is_top":false,"comment_ctime":1561513591,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5856480887","product_id":100023901,"comment_content":"不能解决问题，new是在堆创建对象实例，两个new是创建两个独立的实例，两个不同的内存块，锁两个独立的内存块达不到互斥的效果","like_count":1},{"had_liked":false,"id":107246,"user_name":"杨鹏程baci","can_delete":false,"product_type":"c1","uid":1205949,"ip_address":"","ucode":"3D22F6B74340A8","user_header":"https://static001.geekbang.org/account/avatar/00/12/66/bd/bd5d503e.jpg","comment_is_top":false,"comment_ctime":1561508130,"is_pvip":false,"replies":[{"id":"38945","content":"是的，但不仅仅因为可见性","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1561597237,"ip_address":"","comment_id":107246,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5856475426","product_id":100023901,"comment_content":"老师好，你说锁自家门保护他家资源的意思是不是说要保持锁的对象是一致的，否则无法遵循happens-before选择","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455436,"discussion_content":"是的，但不仅仅因为可见性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561597237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":102497,"user_name":"马哲富","can_delete":false,"product_type":"c1","uid":1107917,"ip_address":"","ucode":"D6BDDFE3CC07ED","user_header":"https://static001.geekbang.org/account/avatar/00/10/e7/cd/08088f14.jpg","comment_is_top":false,"comment_ctime":1560237804,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5855205100","product_id":100023901,"comment_content":"老师，怎么区分是同一把锁还是不同的所啊？","like_count":1,"discussions":[{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378969,"discussion_content":"类锁共享，对象锁私有","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623568523,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1577580,"avatar":"https://static001.geekbang.org/account/avatar/00/18/12/6c/61a598e9.jpg","nickname":"苏暮沉觞","note":"","ucode":"532B816D4EF47B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":44676,"discussion_content":"我觉得对于静态方法来说，看是不是同一个Class，非静态方法来说，看是否是同一个对象（new 出来的同一个对象）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572961049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98188,"user_name":"今夜秋风和","can_delete":false,"product_type":"c1","uid":1434066,"ip_address":"","ucode":"453C8197FFC81D","user_header":"https://static001.geekbang.org/account/avatar/00/15/e1/d2/42ad2c87.jpg","comment_is_top":false,"comment_ctime":1558927518,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5853894814","product_id":100023901,"comment_content":"老师您好，文中说的临界区资源方法之间的互斥，是不是一个线程在获得锁时候，只能执行其中一个方法，只能在该方法执行完毕，释放锁，另一个方法再次竞争获取锁执行方法，要是另一个方法执行还是之前的线程，应该是锁的可重入，锁的释放是变量值减为0释放？","like_count":1},{"had_liked":false,"id":98050,"user_name":"L.","can_delete":false,"product_type":"c1","uid":1181647,"ip_address":"","ucode":"46A2F679C094E8","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/cf/b0d6fe74.jpg","comment_is_top":false,"comment_ctime":1558883508,"is_pvip":false,"replies":[{"id":"35084","content":"你说的对，不同对象的方法可以并行","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558918444,"ip_address":"","comment_id":98050,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5853850804","product_id":100023901,"comment_content":"老师 您好 有个问题很困惑 ：<br>您在本文中说到addOne() 方法，被 synchronized 修饰后，无论是单核 CPU 还是多核 CPU，只有一个线程能够执行 addOne() 方法。<br>可是synchronized修饰非静态方法时，是对当前this对象加锁。但是在多核CPU多线程下，应该是不同的实例对象啊，为什么还只有一个线程才能执行addOne()方法呢？希望能得到老师的解答。非常感谢。","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451535,"discussion_content":"你说的对，不同对象的方法可以并行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558918444,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378970,"discussion_content":"多个实例调用同一个方法，没有影响","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623568594,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87405,"user_name":"xuery","can_delete":false,"product_type":"c1","uid":1027584,"ip_address":"","ucode":"F461B61BE06131","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/00/025f37e7.jpg","comment_is_top":false,"comment_ctime":1555585541,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5850552837","product_id":100023901,"comment_content":"这一节其实就是hb的规则4，通过这么一讲解，理解的更深刻了","like_count":1},{"had_liked":false,"id":82224,"user_name":"Vincent","can_delete":false,"product_type":"c1","uid":1135159,"ip_address":"","ucode":"CD8B84A57A6A0C","user_header":"https://static001.geekbang.org/account/avatar/00/11/52/37/13b4c8aa.jpg","comment_is_top":false,"comment_ctime":1554166206,"is_pvip":false,"replies":[{"id":"29860","content":"可以<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554217381,"ip_address":"","comment_id":82224,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5849133502","product_id":100023901,"comment_content":"get()方法为了可见性有必要给他加一把锁？用volatile关键字修饰变量也可以啊","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445515,"discussion_content":"可以\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554217381,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81673,"user_name":"Mr.Panda","can_delete":false,"product_type":"c1","uid":1238864,"ip_address":"","ucode":"655A3013B5E849","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/50/d476ed6c.jpg","comment_is_top":false,"comment_ctime":1554002717,"is_pvip":false,"replies":[{"id":"29621","content":"1. 互斥锁后，依然不能阻止CPU进行线程<br>2. 原子性有很多层面的理解，指令层面有，高级语言层面有，数据库层面还有。在不同的上下文中能领会到就可以，概念是为了解决问题的，所以也要看场景。更哲学的说法，下一章会介绍。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1554030621,"ip_address":"","comment_id":81673,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5848970013","product_id":100023901,"comment_content":"老师好，对这个概念有点疑惑，请指导。<br>概念：“一个或者多个操作在 CPU 执行的过程中不被中断的特性，称为原子性”<br>疑惑：<br>1.互斥锁后，临界区的代码执行过程中不是依然会发生cpu中断导致线程切换吗？<br>2.个人理解，原子性应该是保证相关代码的执行者由原来可以多个线程执行改为只能由一个线程执行且执行完，其他线程才有机会去执行。","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445293,"discussion_content":"1. 互斥锁后，依然不能阻止CPU进行线程\n2. 原子性有很多层面的理解，指令层面有，高级语言层面有，数据库层面还有。在不同的上下文中能领会到就可以，概念是为了解决问题的，所以也要看场景。更哲学的说法，下一章会介绍。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554030621,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76480,"user_name":"PK時頭髮不亂","can_delete":false,"product_type":"c1","uid":1207867,"ip_address":"","ucode":"08AAAC8F4DE71D","user_header":"https://static001.geekbang.org/account/avatar/00/12/6e/3b/88f14e2a.jpg","comment_is_top":false,"comment_ctime":1552617061,"is_pvip":false,"replies":[{"id":"27878","content":"没区别<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552621843,"ip_address":"","comment_id":76480,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847584357","product_id":100023901,"comment_content":"1. synchronized method(){....}<br>2. method(){<br>     synchronized(this){....}<br>  }<br>王老师, 没想明白, 这两个有什么区别呀？通常别人都是说粒度不一样, 可看了这篇后, 第1个所保护的资源是this 实例, 但2中也是保护 this 实例呀，请求解。。。谢谢","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443322,"discussion_content":"没区别\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552621843,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75858,"user_name":"别皱眉","can_delete":false,"product_type":"c1","uid":1177354,"ip_address":"","ucode":"D24F65EFF65586","user_header":"https://static001.geekbang.org/account/avatar/00/11/f7/0a/067537fc.jpg","comment_is_top":false,"comment_ctime":1552482712,"is_pvip":false,"replies":[{"id":"27664","content":"sleep两秒，相当于cpu休息了十万八千年。我猜测cpu的缓存不会存这么久吧。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552487215,"ip_address":"","comment_id":75858,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847450008","product_id":100023901,"comment_content":"老师 还有个问题 哈哈<br><br>------------------------------------------------------<br>class A{<br>\t&#47;*volatile*&#47; boolean running = true;<br>\tpublic synchronized void m() {<br>\t\tSystem.out.println(&quot;m start&quot;);<br>\t\twhile(running) {<br>\t\t\t&#47;&#47;为什么每次sleep的时候running不用   volatile关键字时被修改时其它线程就可以看见<br><br>\t\t\ttry {<br>\t\t\t\tThread.sleep(1000);<br>\t\t\t} catch (InterruptedException e) {<br>\t\t\t\te.printStackTrace();<br>\t\t\t}<br>\t\t}\t<br>\t\tSystem.out.println(&quot;m end&quot;);<br>\t}<br>}<br><br><br>public class Test12 {<br><br>\tpublic static void main(String[] args) {<br>\t\tA a = new A();<br>\t\t<br>   &#47;&#47;A线程<br>\t\tnew Thread(()-&gt;a.m()).start();<br>\t\t<br>\t\ttry {<br>\t\t\tThread.sleep(2000);<br>\t\t} catch (InterruptedException e) {<br>\t\t\te.printStackTrace();<br>\t\t}<br>\t\ta.running = false;<br>\t}<br>}<br>------------------------------------------------------<br>这里的running没有用volatile修饰<br>在线程A调用m方法时 在while循环内每次都sleep两秒 <br>主线程sleep一秒后修改running为false<br>线程A对这次修改为可见<br><br>当把while循环的sleep去掉时<br>线程A对这次修改不可见<br><br>这是为什么呢？sleep时间到会让当前线程重新到内存取值？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443060,"discussion_content":"sleep两秒，相当于cpu休息了十万八千年。我猜测cpu的缓存不会存这么久吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552487215,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74185,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1552137485,"is_pvip":false,"replies":[{"id":"27135","content":"除了内存模型外，其他的都简单易懂。所以内存模型一定要放前面讲。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552143107,"ip_address":"","comment_id":74185,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847104781","product_id":100023901,"comment_content":"每次new都是一个新对象，不是同一把锁！这节课简单易懂，哈","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442488,"discussion_content":"除了内存模型外，其他的都简单易懂。所以内存模型一定要放前面讲。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552143107,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74078,"user_name":"Joanfen","can_delete":false,"product_type":"c1","uid":1004260,"ip_address":"","ucode":"4CF1B92337B625","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/e4/50600574.jpg","comment_is_top":false,"comment_ctime":1552099612,"is_pvip":false,"replies":[{"id":"27087","content":"这么晦涩的东西大家都耐着性子看完了，很不容易😄","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552111328,"ip_address":"","comment_id":74078,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5847066908","product_id":100023901,"comment_content":"老师好可爱啊，认真回复大家的留言，不吝夸奖👍在评论区也学到很多，跟大神们学习","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442428,"discussion_content":"这么晦涩的东西大家都耐着性子看完了，很不容易😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552111328,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73769,"user_name":"Hour","can_delete":false,"product_type":"c1","uid":1448748,"ip_address":"","ucode":"AA1045ACABC0BB","user_header":"https://static001.geekbang.org/account/avatar/00/16/1b/2c/6b3c0911.jpg","comment_is_top":false,"comment_ctime":1551974475,"is_pvip":false,"replies":[{"id":"26958","content":"其实都是对对象加锁，只是静态方法要用静态对象。语法上用类加锁只是使用简单而已","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552019145,"ip_address":"","comment_id":73769,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846941771","product_id":100023901,"comment_content":"文末的case是存在并发问题的，评论区里回复的很细了，就不再赘述。<br><br>不过我有个疑问，望老师能指导下:<br><br>sync可以对&quot;变量&quot;加锁，也可以对&quot;对象&quot;加锁，还可以对&quot;类&quot;加锁，但一直没理解对&quot;类&quot;加锁的意义是什么，凡是可以用&quot;类&quot;加锁的地方，都可以用&quot;变量锁&quot;、&quot;对象锁&quot;替换，&quot;对象锁&quot;在对象维度加锁，而&quot;变量锁&quot;是在更细粒度加锁，但&quot;类锁&quot;却不是在更大维度加锁，那&quot;类锁&quot;的意义在哪里？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442269,"discussion_content":"其实都是对对象加锁，只是静态方法要用静态对象。语法上用类加锁只是使用简单而已","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552019145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73377,"user_name":"零","can_delete":false,"product_type":"c1","uid":1047949,"ip_address":"","ucode":"4FDC3FF9576032","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fd/8d/f66a0206.jpg","comment_is_top":false,"comment_ctime":1551873334,"is_pvip":false,"replies":[{"id":"26713","content":"坚持就有收货<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551880952,"ip_address":"","comment_id":73377,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846840630","product_id":100023901,"comment_content":"打卡第一天，以前系统学习了一次，没有很好的实战，很快就忘了，希望这次重新学习并应用于实际的项目。","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442051,"discussion_content":"坚持就有收货\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551880952,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73169,"user_name":"渔夫","can_delete":false,"product_type":"c1","uid":1019289,"ip_address":"","ucode":"6BF08FD8923E45","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/99/f886543d.jpg","comment_is_top":false,"comment_ctime":1551834962,"is_pvip":false,"replies":[{"id":"26627","content":"happens_before规则保证的，这个规则是jsr规范，虚拟机必须实现规范","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551846628,"ip_address":"","comment_id":73169,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846802258","product_id":100023901,"comment_content":"不理解的是，加🔒就能保证读的时候会从内存读，而不从缓存读？","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441946,"discussion_content":"happens_before规则保证的，这个规则是jsr规范，虚拟机必须实现规范","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551846628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73156,"user_name":"　　　　　　　　","can_delete":false,"product_type":"c1","uid":1441382,"ip_address":"","ucode":"F6119959854C21","user_header":"https://static001.geekbang.org/account/avatar/00/15/fe/66/1b8b8c09.jpg","comment_is_top":false,"comment_ctime":1551832944,"is_pvip":false,"replies":[{"id":"26590","content":"正确<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551834145,"ip_address":"","comment_id":73156,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846800240","product_id":100023901,"comment_content":"课后思考题：加锁方式不正确。首先是保护的资源是不对的，每次都是新对象；其次两个sync 锁住的资源也是不同的。原子性问题和可见性问题都没有办法解决。","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441937,"discussion_content":"正确\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551834145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73090,"user_name":"发条橙子 。","can_delete":false,"product_type":"c1","uid":1259218,"ip_address":"","ucode":"ED076F4534FFED","user_header":"https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg","comment_is_top":false,"comment_ctime":1551795340,"is_pvip":false,"replies":[{"id":"26577","content":"单核也不能保证原子性<br>单核没有缓存问题，有原子性问题。两个线程可以先后读到寄存器，这个时候还没有写，基于这个做＋法，就会出现前一个的写被后一个线程覆盖的问题<br><br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551830858,"ip_address":"","comment_id":73090,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846762636","product_id":100023901,"comment_content":"首先说答案： <br><br>因为该同步块 锁 是每次new新对象 ，所以每个线程都拥有一个锁 ，所以不能达到互斥目的 。 <br><br>解决： <br><br>在该类下创建一个成员变量 object ， 使用该对象作为锁可达到互斥效果<br><br>问题 ： <br><br>老师， count++ 是因为多核情况下 ，有可能多个线程同时访问共享资源导致原子性问题 。 <br><br>那么在单核情况下 ， 就不存在多个线程同时访问共享资源 ，就不会有原子性问题了呢 。这时候发生线程切换 ， 比如 从执行添加线程 切换到 执行get线程 ，只是存在可见性问题 ， 这个时候给资源加上 voltaile 关键字是不是就可以解决并发问题了 ？<br><br>这是我的理解，希望老师解答 😝","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441907,"discussion_content":"单核也不能保证原子性\n单核没有缓存问题，有原子性问题。两个线程可以先后读到寄存器，这个时候还没有写，基于这个做＋法，就会出现前一个的写被后一个线程覆盖的问题\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551830858,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72982,"user_name":"「」Resolution","can_delete":false,"product_type":"c1","uid":1439997,"ip_address":"","ucode":"662FB75718EA2D","user_header":"https://static001.geekbang.org/account/avatar/00/15/f8/fd/45b31832.jpg","comment_is_top":false,"comment_ctime":1551769732,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5846737028","product_id":100023901,"comment_content":"锁定不同的资源， 导致无法解决可见性的问题， 并且无法形成互斥关系，无法保证原子性问题","like_count":1},{"had_liked":false,"id":72961,"user_name":"刘志兵","can_delete":false,"product_type":"c1","uid":1441734,"ip_address":"","ucode":"A90C2FA49EDC23","user_header":"https://static001.geekbang.org/account/avatar/00/15/ff/c6/8b5cbe97.jpg","comment_is_top":false,"comment_ctime":1551763301,"is_pvip":false,"replies":[{"id":"26497","content":"不行！","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551795582,"ip_address":"","comment_id":72961,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5846730597","product_id":100023901,"comment_content":"老实，静态方法锁住的对象是静态类对象，那如果静态方法中有多个静态方法，给其中一个加上synchronize而且被一个线程锁住的话，是不是其他线程执行其他方法也不行","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441849,"discussion_content":"不行！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551795582,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378977,"discussion_content":"相当于锁粗化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623571511,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72906,"user_name":"Smile","can_delete":false,"product_type":"c1","uid":1125189,"ip_address":"","ucode":"0617032294DC43","user_header":"https://static001.geekbang.org/account/avatar/00/11/2b/45/e8f64725.jpg","comment_is_top":false,"comment_ctime":1551753265,"is_pvip":false,"replies":[{"id":"26486","content":"分析的很到位了！","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551794637,"ip_address":"","comment_id":72906,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846720561","product_id":100023901,"comment_content":"互斥性关注两个点：<br>  1. 锁是什么对象<br>  2. 锁住的内存是什么，临界区的内容<br>同一个锁只能一个线程占有，当一个线程抢占到锁时，其他线程只能等到释放后才可以抢到。<br>对于思考题，由于不是同一个锁，而且是每个线程创建一次，不存在锁的竞争，所以原子性不能保证。共享变量在多线程存在可见性问题，对一个锁解锁 Happens-Before 后续对这个锁的加锁，不是同一个锁，无法解决共享变量value的可见性问题，请老师，评判指正☺","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441819,"discussion_content":"分析的很到位了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551794637,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72880,"user_name":"王大王","can_delete":false,"product_type":"c1","uid":1442110,"ip_address":"","ucode":"BA520B50E97D34","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqjceGMS81zZibA9LECsgAUU1aHPKhfM4WyNgqPtmnxvtzhC3a44ows3g7FuD7ibESAAY0UWsicW0EjA/132","comment_is_top":false,"comment_ctime":1551749947,"is_pvip":false,"replies":[{"id":"26485","content":"所以后来c#,c++都开始搞内存模型了","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551794572,"ip_address":"","comment_id":72880,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846717243","product_id":100023901,"comment_content":"管程锁规则和连续性规则一结合，可以实现对同一个锁保护的资源间实现可见性，真是太奥妙了","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441806,"discussion_content":"所以后来c#,c++都开始搞内存模型了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551794572,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72846,"user_name":"黄朋飞","can_delete":false,"product_type":"c1","uid":1107062,"ip_address":"","ucode":"A1E7E0460A1BCC","user_header":"https://static001.geekbang.org/account/avatar/00/10/e4/76/a97242c0.jpg","comment_is_top":false,"comment_ctime":1551747332,"is_pvip":false,"replies":[{"id":"26459","content":"你可以想象成是缓存的原因<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551788355,"ip_address":"","comment_id":72846,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846714628","product_id":100023901,"comment_content":"老师你好，能解释下get方法不加锁为什么可见性没法保证吗？没看懂","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441782,"discussion_content":"你可以想象成是缓存的原因\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551788355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72842,"user_name":"DebugDog","can_delete":false,"product_type":"c1","uid":1027798,"ip_address":"","ucode":"1664D37CE03B9D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/d6/fbb8236d.jpg","comment_is_top":false,"comment_ctime":1551747038,"is_pvip":true,"replies":[{"id":"26477","content":"不仅仅这样，你也再想想","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551793663,"ip_address":"","comment_id":72842,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846714334","product_id":100023901,"comment_content":"锁定的不是同一个对象","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441781,"discussion_content":"不仅仅这样，你也再想想","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551793663,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72840,"user_name":"往事随风，顺其自然","can_delete":false,"product_type":"c1","uid":1235692,"ip_address":"","ucode":"F266EC6B143E38","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/ec/779c1a78.jpg","comment_is_top":false,"comment_ctime":1551746961,"is_pvip":false,"replies":[{"id":"26475","content":"不仅仅是这样。你也再想想","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551793606,"ip_address":"","comment_id":72840,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846714257","product_id":100023901,"comment_content":"两个方法都是new 出来的，是不同对象，读写不在同一把锁当中，并不能保证满足happen-before 原则，写发生在读操作之前，可以改为同一个对像的锁或者是同一个类锁","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441779,"discussion_content":"不仅仅是这样。你也再想想","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551793606,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72802,"user_name":"峰","can_delete":false,"product_type":"c1","uid":1056019,"ip_address":"","ucode":"C53CB64E8E7D19","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg","comment_is_top":false,"comment_ctime":1551735818,"is_pvip":true,"replies":[{"id":"26452","content":"应该不会慢，编译器会优化成无锁代码","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551787585,"ip_address":"","comment_id":72802,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846703114","product_id":100023901,"comment_content":"每次进入临界区，拿的锁都不一样，这和不加锁的代码是一样的，就是慢好多😄","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441756,"discussion_content":"应该不会慢，编译器会优化成无锁代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551787585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72792,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1551717484,"is_pvip":false,"replies":[{"id":"26453","content":"完全正确<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551787835,"ip_address":"","comment_id":72792,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846684780","product_id":100023901,"comment_content":"① class SafeCalc {<br>  long value = 0L;<br>  long get() {<br>    return value;<br>  }<br>  synchronized void addOne() {<br>    value += 1;<br>  }<br>}<br><br>多线程下 addOne() 原子可见均没问题 <br>多线程下 get() 可见性有问题 不遵循happens–before原则<br><br>② class SafeCalc {<br>  long value = 0L;<br>  long synchronized get() {<br>    return value;<br>  }<br>  synchronized void addOne() {<br>    value += 1;<br>  }<br>}<br><br>多线程下 get addOne 的 原子性 可见性都没问题 遵循happens–before原则<br><br>③ class SafeCalc {<br>  long value = 0L;<br> synchronized  long get() {<br>    return value;<br>  }<br>  synchronized void static addOne() {<br>    value += 1;<br>  }<br>}<br><br>多线程下 get addOne 都有问题 所对象不同<br><br><br>④ class SafeCalc {<br>  long value = 0L;<br>  long get() {<br>    synchronized (new Object()) {<br>      return value;<br>    }<br>  }<br>  void addOne() {<br>    synchronized (new Object()) {<br>      value += 1;<br>    }<br>  }<br>}<br><br> 这两个 new Object()，不是同一个锁对象，也就不满足happens–before原则对同一锁对象的要求，因此可见性和原子性都不能保证啦！<br><br>每次锁的对象不一样，任意一个线程都可以进来，都可能读到相同的值，就像读到都是0，然后又同时写了两次1一样，所以不是线程安全的啦!<br><br>有说不对的地方老师告知一下啊！","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441748,"discussion_content":"完全正确\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551787835,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358901,"user_name":"自在飞","can_delete":false,"product_type":"c1","uid":1167825,"ip_address":"北京","ucode":"A2712148DA06E0","user_header":"https://static001.geekbang.org/account/avatar/00/11/d1/d1/62f74aa7.jpg","comment_is_top":false,"comment_ctime":1664985363,"is_pvip":false,"replies":[{"id":"130862","content":"会，CPU只认识机器码，压根不care java里的 synchronized。线程A虽然会被切换（被CPU剥夺执行权力），但是不允许其他线程X进入synchronized块中，只能等待线程A切换回来（重新获得CPU执行权力）。","user_name":"作者回复","user_name_real":"编辑","uid":"1269969","ctime":1665837624,"ip_address":"北京","comment_id":358901,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1664985363","product_id":100023901,"comment_content":"老师您好，想请教个问题：<br><br>如果在一个时间片内synchronized块中的代码没执行完的话，CPU是否会进行线程切换？如果发生线程切换的话对共享资源进行的修改操作如何保证其原子性呢？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590526,"discussion_content":"会，CPU只认识机器码，压根不care java里的 synchronized。线程A虽然会被切换（被CPU剥夺执行权力），但是不允许其他线程X进入synchronized块中，只能等待线程A切换回来（重新获得CPU执行权力）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665837624,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358900,"user_name":"自在飞","can_delete":false,"product_type":"c1","uid":1167825,"ip_address":"北京","ucode":"A2712148DA06E0","user_header":"https://static001.geekbang.org/account/avatar/00/11/d1/d1/62f74aa7.jpg","comment_is_top":false,"comment_ctime":1664983953,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664983953","product_id":100023901,"comment_content":"能解决对共享资源进行的复合操作的原子性。<br>但是不能解决addOne写操作对共享变量的修改对get读操作的可见性，这是由于【使用不同锁来访问同一个共享变量，没有达到多线程之间互斥访问共享变量的目的】","like_count":0},{"had_liked":false,"id":356792,"user_name":"在路上","can_delete":false,"product_type":"c1","uid":1476245,"ip_address":"日本","ucode":"2668A965FA79F2","user_header":"https://static001.geekbang.org/account/avatar/00/16/86/95/b9d960d9.jpg","comment_is_top":false,"comment_ctime":1662599188,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662599188","product_id":100023901,"comment_content":"相应的get和set里面的资源位于两个不同的房间，一个人开门加锁到set房间里面做的操作对于另一个房间的get操作而言是不可见的，两个房间的操作是独立的。原子性和可见性都得不到保障","like_count":0},{"had_liked":false,"id":350613,"user_name":"Geek_d78c9f","can_delete":false,"product_type":"c1","uid":3044700,"ip_address":"","ucode":"50925C4A35DE2C","user_header":"","comment_is_top":false,"comment_ctime":1657038665,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657038665","product_id":100023901,"comment_content":"你好，我想问cpu的三级缓存什么时候同步到内存？比如我两个线程分别对count做+1，他们分别就是从内存中读取count=0，到cpu缓存，然后+1，然后什么时候写回内存呢？还有就是我第一次加完以后，第二次+1的时候，是从CPU的缓存里面取，还是从内存中取呢？如果从内存中取，那加缓存的意义是什么？如果从缓存中取，那两个线程执行完之后，就应该是等于10000，而不是10000～20000之间了","like_count":0},{"had_liked":false,"id":345736,"user_name":"学习学个屁","can_delete":false,"product_type":"c1","uid":1049017,"ip_address":"","ucode":"DF2D61E6FB2FCE","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","comment_is_top":false,"comment_ctime":1652535590,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652535590","product_id":100023901,"comment_content":"new Object()  肯定不行啊。加锁的lock要一个，锁只有一把，谁用完了，下一个人才能用，new Object() 多把锁，无用功。<br><br>另外synch 当前线程id 也不一样，相当于没加锁。","like_count":0},{"had_liked":false,"id":339942,"user_name":"rikey","can_delete":false,"product_type":"c1","uid":2874133,"ip_address":"","ucode":"87391F61E1F659","user_header":"https://static001.geekbang.org/account/avatar/00/2b/db/15/47cc6edf.jpg","comment_is_top":false,"comment_ctime":1648476752,"is_pvip":true,"replies":[{"id":"125429","content":"可见性在CPU层面，都是靠内存屏障指令解决的","user_name":"作者回复","user_name_real":"编辑","uid":"1269969","ctime":1650971033,"ip_address":"","comment_id":339942,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1648476752","product_id":100023901,"comment_content":"Monitor对象需要保证可见性吗？如何保证的呢","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":567665,"discussion_content":"可见性在CPU层面，都是靠内存屏障指令解决的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1650971033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":335190,"user_name":"sotondolphin","can_delete":false,"product_type":"c1","uid":2306394,"ip_address":"","ucode":"136444B47ACDC5","user_header":"","comment_is_top":false,"comment_ctime":1645380058,"is_pvip":true,"replies":[{"id":"123924","content":"两个锁，只要不是同一个对象就没关系","user_name":"作者回复","user_name_real":"编辑","uid":"1269969","ctime":1647913200,"ip_address":"","comment_id":335190,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1645380058","product_id":100023901,"comment_content":"我想再确认一下， 最后一个例子用类锁和实例锁去保护value资源，其实是一个错误的方法。 因为这两个锁没有互斥性，不能保证一致性和可见性。引申一个问题就是类锁和实例锁有么有作用范围的关系? 比如说一个线程拿到了这个类的锁，它的所有的实例锁都会被自动获得？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557632,"discussion_content":"两个锁，只要不是同一个对象就没关系","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647913200,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333972,"user_name":"水目沾","can_delete":false,"product_type":"c1","uid":1274495,"ip_address":"","ucode":"FDD1D15C277D58","user_header":"https://static001.geekbang.org/account/avatar/00/13/72/7f/5da093c5.jpg","comment_is_top":false,"comment_ctime":1644646678,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644646678","product_id":100023901,"comment_content":"锁，互斥，原子性三者之间的关系","like_count":0},{"had_liked":false,"id":330001,"user_name":"Geek_161af7","can_delete":false,"product_type":"c1","uid":2834804,"ip_address":"","ucode":"EF9B2C0B359855","user_header":"","comment_is_top":false,"comment_ctime":1641722532,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1641722532","product_id":100023901,"comment_content":"get() 和 addOne()方法都用synchronize修饰，并发性会比较低","like_count":0},{"had_liked":false,"id":327681,"user_name":"Geek_f0c13c","can_delete":false,"product_type":"c1","uid":2768260,"ip_address":"","ucode":"662EDB3B61AF26","user_header":"","comment_is_top":false,"comment_ctime":1640232921,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640232921","product_id":100023901,"comment_content":"最后一个问题，原子性和可见性都不能够保证。","like_count":0},{"had_liked":false,"id":319041,"user_name":"ฅSlekฅ","can_delete":false,"product_type":"c1","uid":2436755,"ip_address":"","ucode":"B732C672B3D301","user_header":"https://static001.geekbang.org/account/avatar/00/25/2e/93/81e3e4ca.jpg","comment_is_top":false,"comment_ctime":1635520293,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635520293","product_id":100023901,"comment_content":"看评论区比看教程高效多了，各个都是人才，说话也好听，我超喜欢这里的","like_count":0},{"had_liked":false,"id":314989,"user_name":"官宝儿","can_delete":false,"product_type":"c1","uid":2110827,"ip_address":"","ucode":"03B4312475A984","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI5eicXFWltiaF9ibsEh2nNC80OYoHibhhE0X1hPHZ5KuAtY4Yxp5dQ4LsciaDxUHFBPlJM7kgQwkspzsQ/132","comment_is_top":false,"comment_ctime":1633637977,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633637977","product_id":100023901,"comment_content":"new obj 是新对象锁，add和get不构成互斥","like_count":0},{"had_liked":false,"id":314022,"user_name":"peaceForce","can_delete":false,"product_type":"c1","uid":1999235,"ip_address":"","ucode":"98A318930DDC9A","user_header":"https://static001.geekbang.org/account/avatar/00/1e/81/83/f93b1e62.jpg","comment_is_top":false,"comment_ctime":1632809238,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1632809238","product_id":100023901,"comment_content":"对get()要加锁这点感觉很费解。这里只是读取，由于addOne的释放锁必须在加锁之前，所以同一时间的多个线程要么同时读到加锁前的值，要么同时读到释放锁之后的值。怎么会要加锁呢？","like_count":0,"discussions":[{"author":{"id":1987202,"avatar":"","nickname":"Geek_783cc7","note":"","ucode":"C43F76B1978FA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":401174,"discussion_content":"对，我也有这个疑惑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633588917,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":303719,"user_name":"Leon","can_delete":false,"product_type":"c1","uid":1051118,"ip_address":"","ucode":"782F7ECE08C0E5","user_header":"https://static001.geekbang.org/account/avatar/00/10/09/ee/288d878c.jpg","comment_is_top":false,"comment_ctime":1626944335,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626944335","product_id":100023901,"comment_content":"关于锁，这篇文章写得不错 https:&#47;&#47;tech.meituan.com&#47;2018&#47;11&#47;15&#47;java-lock.html","like_count":0},{"had_liked":false,"id":298236,"user_name":"201201718","can_delete":false,"product_type":"c1","uid":2372133,"ip_address":"","ucode":"CDCAE51039E3E1","user_header":"","comment_is_top":false,"comment_ctime":1623977410,"is_pvip":false,"replies":[{"id":"108799","content":"老板让统计访问量，有人创建了多个计数器，这个属于bug，和并发没关系","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1624967216,"ip_address":"","comment_id":298236,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1623977410","product_id":100023901,"comment_content":"请问一下，用 synchronized 解决 count+=1 问题，sync锁的是当前实例对象this，那如果创建了多个实例对象情况下，岂不是锁的对象不是同一个吗？就会出现和课后思考题一样的问题","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522067,"discussion_content":"老板让统计访问量，有人创建了多个计数器，这个属于bug，和并发没关系","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624967216,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":287242,"user_name":"RoccoLee","can_delete":false,"product_type":"c1","uid":2508667,"ip_address":"","ucode":"C55AD67FF8C2D7","user_header":"https://static001.geekbang.org/account/avatar/00/26/47/7b/c5ec018c.jpg","comment_is_top":false,"comment_ctime":1617851853,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1617851853","product_id":100023901,"comment_content":"课后思考：使用方式不正确。原因：new Object()会创建新对象，get方法与addOne方法分别使用的不同的锁，addOne临界区value的修改在解锁后对get不可见。","like_count":0},{"had_liked":false,"id":287214,"user_name":"ZEO","can_delete":false,"product_type":"c1","uid":1100027,"ip_address":"","ucode":"EFCB975C36307D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLl3Ye2UaHZaicq2a1YibSriaUTaxzZOMwajOR39dWKOHLGibkL2zcp6ee2I3Fibjobqjxq2G3piaYYLLZg/132","comment_is_top":false,"comment_ctime":1617843590,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617843590","product_id":100023901,"comment_content":"两个方法的锁不是同一个，不能保证可见性","like_count":0},{"had_liked":false,"id":286333,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1617259310,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617259310","product_id":100023901,"comment_content":"思考题：这样的加锁方式没用。因为没用同一把锁来控制资源的保护来增加多线程的之间的互斥。new Object()，相当于每次去加锁都重新生成一个锁对象。","like_count":0},{"had_liked":false,"id":284234,"user_name":"BELIEVE","can_delete":false,"product_type":"c1","uid":1127580,"ip_address":"","ucode":"0EE8E9A1A25E89","user_header":"https://static001.geekbang.org/account/avatar/00/11/34/9c/c2bae2ae.jpg","comment_is_top":false,"comment_ctime":1616131119,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616131119","product_id":100023901,"comment_content":"我怎么觉得评论区的这些牛人都是老师的马甲呢，哈哈哈","like_count":0},{"had_liked":false,"id":282071,"user_name":"zhunode","can_delete":false,"product_type":"c1","uid":1214421,"ip_address":"","ucode":"D60B6B28C5336C","user_header":"https://static001.geekbang.org/account/avatar/00/12/87/d5/4a6c6890.jpg","comment_is_top":false,"comment_ctime":1615043785,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615043785","product_id":100023901,"comment_content":"王老师好，synchronized关键字应该没有保证原子性（原子性指的是一条或多条指令在执行的时候不被打断）吧。因为synchronized关键字是加锁操作，若线程A拥有锁了，但在操作资源的时候因为时间片用完了而发生了线程切换，此时线程B上CPU，线程B因为拿不到A持有的锁，只能阻塞，待时间片用完后，A线程又上CPU继续操作锁住的资源，在执行后就释放锁了。而在这个过程中，A线程是被打断了，所以是没有保证原子性的吧。","like_count":0},{"had_liked":false,"id":282065,"user_name":"zhunode","can_delete":false,"product_type":"c1","uid":1214421,"ip_address":"","ucode":"D60B6B28C5336C","user_header":"https://static001.geekbang.org/account/avatar/00/12/87/d5/4a6c6890.jpg","comment_is_top":false,"comment_ctime":1615041705,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615041705","product_id":100023901,"comment_content":"不正确。按照评论区大佬说法，因new object()作锁，在编译器时会将synchronized优化去除，从而就存在可见性问题，且因为没有锁了，也就没有了原子性。","like_count":0},{"had_liked":false,"id":280523,"user_name":"二杠一","can_delete":false,"product_type":"c1","uid":1141324,"ip_address":"","ucode":"040C9A30E7ADF4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/dDk3WicuUbhvcb4R8PD0YiaFteqQvC4UpXHw4chKLDKB0qaOGeCxBJ3nfiaNZAyVQmAgesyE2MvABydxg6gic29j5w/132","comment_is_top":false,"comment_ctime":1614240938,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1614240938","product_id":100023901,"comment_content":"老师，同学们好，对于第01里面的单利，是不是对instance = new Singleton;这句代码加锁也让他具有原子性，就没有有序性问题呀？","like_count":0},{"had_liked":false,"id":275194,"user_name":"张滔","can_delete":false,"product_type":"c1","uid":1322636,"ip_address":"","ucode":"87ABAFF0E861E0","user_header":"https://static001.geekbang.org/account/avatar/00/14/2e/8c/b261e15a.jpg","comment_is_top":false,"comment_ctime":1611383510,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611383510","product_id":100023901,"comment_content":"是不是释放锁的时候强制刷新缓存中的数据到内存中，而获取锁的时候会强制从内存中加载数据到缓存？","like_count":0},{"had_liked":false,"id":272124,"user_name":"子杰","can_delete":false,"product_type":"c1","uid":1025250,"ip_address":"","ucode":"717D10394391BE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a4/e2/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1609940335,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1609940335","product_id":100023901,"comment_content":"这里需要加一个前置知识 AbstractQuenedSynchronizer ，这样整个模型就更完整了","like_count":0},{"had_liked":false,"id":263503,"user_name":"flying myself","can_delete":false,"product_type":"c1","uid":1992480,"ip_address":"","ucode":"69F26BE9B94B58","user_header":"https://static001.geekbang.org/account/avatar/00/1e/67/20/93b2e38e.jpg","comment_is_top":false,"comment_ctime":1606143888,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606143888","product_id":100023901,"comment_content":"锁是new Object()出来的不同对象，是不同的锁，不能保证互斥，无法保证对同一个锁的解锁对其加锁可见，即无法保证可见性；当写线程被切换，写操作终止，调度读线程，会无法保证原子性，所以还是get方法加锁，保证读操作是可见的；","like_count":0},{"had_liked":false,"id":262773,"user_name":"阿声","can_delete":false,"product_type":"c1","uid":1148174,"ip_address":"","ucode":"EEA5F2E9D4FC9C","user_header":"https://static001.geekbang.org/account/avatar/00/11/85/0e/e6640576.jpg","comment_is_top":false,"comment_ctime":1605840598,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605840598","product_id":100023901,"comment_content":"回答别皱眉的打印问题。<br>这是 System.out.println(b) 的方法实现：<br>public void println(Object x) {<br>    String s = String.valueOf(x);<br>    synchronized (this) {<br>        print(s);<br>        newLine();<br>    }<br>}<br><br><br>在这一行 String s = String.valueOf(x)，来了个狸猫换太子，String s 是一个新的对象（String是不可变类），s对象里面的value[]复制的是Object x里面的value。<br>可以参考Integer的toString()实现：<br>public static String toString(int i) {<br>    if (i == Integer.MIN_VALUE)<br>        return &quot;-2147483648&quot;;<br>    int size = (i &lt; 0) ? stringSize(-i) + 1 : stringSize(i);<br>    char[] buf = new char[size];<br>    getChars(i, size, buf);<br>    return new String(buf, true);<br>}<br><br>所以最终print(s) 打印的是一个全新的对象，Object x对象进入synchronized 临界区后刷新了主内存中的最终数据，对print(s)来说已经没关系了<br><br>思考，至于为什么System.out.println(Object x)如此实现，进行大胆的猜测：<br>1、从逻辑上给出的表现是所见即所得，我当前是什么值，那我往控制台打印的就应该是什么值，而不应该被其他线程影响到（本地缓存刷新了最新值）<br>2、这个地方使用 synchronized修饰，那一定是里面的操作属于临界资源，需要保护，这是目的。Object 被动的做了一次本地内存副本的刷新，我觉得是顺带的。<br><br>总结：<br>1、System.out.println(b) 虽然对当前线程的缓存做了一次本地内存的刷新，但是可以当成一个调剂。<br>2、真的想要实现可见性原则，还是要在业务代码层面 显示的 用volatile之类的机制来保证。<br><br>不知道我理解是否正确，欢迎大家指正。","like_count":0},{"had_liked":false,"id":261917,"user_name":"Geek_89e362","can_delete":false,"product_type":"c1","uid":2308075,"ip_address":"","ucode":"E596C2CFE1CFAF","user_header":"","comment_is_top":false,"comment_ctime":1605578333,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605578333","product_id":100023901,"comment_content":"思考题：<br>  结论：addOne不能保证原子性，addOne和get之间不能保证可见性。<br>  原因：<br>   1、addOne不能保证原子性<br>          由于synchronized 使用的是 new Object() 作为锁，每次调用都会创建一个新的对象，所有线程之间使用的不是同一把锁，无法保证线程之间的互斥操作，也就是说多个线程可以同时进入临界区，故不能保证原子性。<br>      2、addOne和get之间不能保证可见性<br>          由于两个方法中的synchronized代码块加锁都是使用的 new Object()，也不是一把锁，两个方法之间也不是互斥操作，故不能保证其可见性。","like_count":0},{"had_liked":false,"id":260963,"user_name":"Geek_c75d82","can_delete":false,"product_type":"c1","uid":2286012,"ip_address":"","ucode":"81202A016FC5D2","user_header":"","comment_is_top":false,"comment_ctime":1605162500,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605162500","product_id":100023901,"comment_content":"锁对象都是new出来的新对象，每个对象都是新，代码进入的时候，新对象上面还没有锁，所以锁不住","like_count":0},{"had_liked":false,"id":249934,"user_name":"monus","can_delete":false,"product_type":"c1","uid":2159455,"ip_address":"","ucode":"AC687844D03296","user_header":"","comment_is_top":false,"comment_ctime":1600858262,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600858262","product_id":100023901,"comment_content":"对资源的加锁和解锁操作，必须是同一把锁吧。就好比我锁了房间，你用你的锁还能打开，这想想都都害怕������。所以上述代码，采用new object，每次加锁和解锁都不是同一把锁，是不能保证的。","like_count":0},{"had_liked":false,"id":249763,"user_name":"夜涛","can_delete":false,"product_type":"c1","uid":1507783,"ip_address":"","ucode":"672CC53663710B","user_header":"https://static001.geekbang.org/account/avatar/00/17/01/c7/549b5616.jpg","comment_is_top":false,"comment_ctime":1600782590,"is_pvip":true,"replies":[{"id":"91644","content":"������","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1600956104,"ip_address":"","comment_id":249763,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1600782590","product_id":100023901,"comment_content":"new这样是不行的，每次new都相当于锁了一个新的实例，这个实例还没有地方使用。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506007,"discussion_content":"������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600956104,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":247291,"user_name":"西门吹牛","can_delete":false,"product_type":"c1","uid":1508990,"ip_address":"","ucode":"E5D3624DDE1E83","user_header":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","comment_is_top":false,"comment_ctime":1599650931,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599650931","product_id":100023901,"comment_content":"JVM对Synchronized的优化，简单来说解决三种场景：<br>只有一个线程进入临界区-----&gt;偏向锁，<br>多个线程交替进入临界区-----&gt;轻量级锁，<br>多线程同时进入临界区-----&gt;重量级锁","like_count":0},{"had_liked":false,"id":246236,"user_name":"西门吹牛","can_delete":false,"product_type":"c1","uid":1508990,"ip_address":"","ucode":"E5D3624DDE1E83","user_header":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","comment_is_top":false,"comment_ctime":1599216288,"is_pvip":false,"replies":[{"id":"91347","content":"优秀������","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1600347488,"ip_address":"","comment_id":246236,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1599216288","product_id":100023901,"comment_content":"说下加锁解锁大致流程吧：<br>根据对象头中的数据，可以看出，java对偏向锁，轻量级锁，重量级锁的加锁和解锁操作是不一样的。<br>重量级锁：从对象头中的数据，可以看出，当锁标志位为重量级锁时，那么对象头中就Mark word 的前几位就是指向 Monitor 的指针，Monitor就是管程，里面有等到队列，重入次数，指向获取锁线程的指针等信息，Monitor在HotSpot 中是基于C++实现的ObjectMonitor，每个对象都对应一个Monitor 监视器；<br>线程过来，先根据锁对象头中的指向ObjectMonitor 的指针，找到ObjectMonitor，然后把ObjectMonitor中的一个数据线程id 通过cas修改为自己的线程id，在这个过程中，有可能有多个线程拿到ObjectMonitor，当多个线程同时访问同步代码时，首先进入的就是ObjectMonitor中的EntryList队列 。当某个线程通过cas竞争到锁时，这里没人入队列，所以是非公平锁，也就是通过 cas 竞争成功把ObjectMonitor中的owner 设置为他的线程地址，那么加锁成功，计数器加1，释放锁时减1；<br>这里主要有个Monitor，管程，管程主要俩点，互斥和协同，互斥是通过获取对象锁来保证同步代码的互斥执行，协同靠的是notify 和 wait机制进行现场间的协同，这都是管程模型的精髓，等待唤醒机制。<br>轻量级锁和偏向锁的加锁解锁比较简单，网上文章也多。<br>可以看出，重量级锁，都涉及Monitor操作，而Monitor 操作都和底层内核相关，所以每次加锁解锁开销很大。当然具体细节还很多，有兴趣的来一起交流。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505094,"discussion_content":"优秀������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600347488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245742,"user_name":"西门吹牛","can_delete":false,"product_type":"c1","uid":1508990,"ip_address":"","ucode":"E5D3624DDE1E83","user_header":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","comment_is_top":false,"comment_ctime":1599038531,"is_pvip":false,"replies":[{"id":"90434","content":"👍🏻","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1599175931,"ip_address":"","comment_id":245742,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1599038531","product_id":100023901,"comment_content":"课后思考：<br>经过逃逸分析优化会导致锁消除<br>即时编译器只需证明锁对象会不会发生逃逸，也就是锁对象会不会被其他线程共享使用，如果当前锁对象只在当前线程使用，那么说明该锁对象不会发生逃逸，只在本线程使用，因此也无法基于该锁对象构造两个线程之间的 happens-before 规则，那么加锁解锁就没必要，会直接优化掉加锁解锁操作。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504975,"discussion_content":"👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599175931,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":242310,"user_name":"fightingD","can_delete":false,"product_type":"c1","uid":1443637,"ip_address":"","ucode":"AD2876CED5D5AC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKwViav94kcF50CxA0Jw7icicxociaVzut97iacy3b2ciacFqXuFWdiakVq304YcI8pt4HT5A1Yvp8EkYCpw/132","comment_is_top":false,"comment_ctime":1597666956,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597666956","product_id":100023901,"comment_content":"不能解决原子性问题，因为get(),和addone() 两个方法的锁不相同，所以无法互斥。<br>可见性也保障不了，因为addone(),get()方法的锁是变化的，相当于没有加锁。","like_count":0},{"had_liked":false,"id":241511,"user_name":"William","can_delete":false,"product_type":"c1","uid":1346215,"ip_address":"","ucode":"55F5D9DEE485B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","comment_is_top":false,"comment_ctime":1597315563,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1597315563","product_id":100023901,"comment_content":"课后题目： 没有作用，因为 synchronized 锁的是不同的对象。","like_count":0},{"had_liked":false,"id":234551,"user_name":"Geek_41d472","can_delete":false,"product_type":"c1","uid":1247965,"ip_address":"","ucode":"DEC2B6329460CF","user_header":"https://static001.geekbang.org/account/avatar/00/13/0a/dd/88fa7b52.jpg","comment_is_top":false,"comment_ctime":1594718312,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594718312","product_id":100023901,"comment_content":"“同一时刻只有一个线程执行”这个条件非常重要，我们称之为互斥。如果我们能够保证对共享变量的修改是互斥的，那么，无论是单核 CPU 还是多核 CPU，就都能保证原子性了。<br>-----------------------------------<br>老师,为啥互斥就能保证原子性呢,,实在理解不了,互斥,比如使用了sychonzed的方法,只是保证了同一时刻只有一个线程执行这方法,如果在执行这个方法过程中线程切换了,这不就中断了吗?既然中断了为什么,不就无法保证原子性了吗","like_count":0},{"had_liked":false,"id":232309,"user_name":"sibyl","can_delete":false,"product_type":"c1","uid":1323652,"ip_address":"","ucode":"0D142011860D69","user_header":"","comment_is_top":false,"comment_ctime":1593953009,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593953009","product_id":100023901,"comment_content":"synchronized 相比 volatile 多了互斥的作用，避免原子性问题。<br>比如文中value++代码如果能一定在64位机器上运行，那么直接使用volatile也是线程安全的，因为么有原子性问题啦，没有线程互斥，因此效率更高。","like_count":0},{"had_liked":false,"id":231176,"user_name":"小李讲源码","can_delete":false,"product_type":"c1","uid":1107484,"ip_address":"","ucode":"2573037D7C82C8","user_header":"https://static001.geekbang.org/account/avatar/00/10/e6/1c/9d3744ee.jpg","comment_is_top":false,"comment_ctime":1593601819,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1593601819","product_id":100023901,"comment_content":"总结：通过互斥锁可以保证原子性。但前提是对同一资源进行竞争。在代码中new了不同的对象，sychronized对不同的对象进行加锁，不能保证原子性。<br><br>而且这种对象只有一个线程，不存在锁的竞争，经过优化就锁消除了。","like_count":0},{"had_liked":false,"id":229150,"user_name":"杜总","can_delete":false,"product_type":"c1","uid":2046055,"ip_address":"","ucode":"C6600875A265E7","user_header":"","comment_is_top":false,"comment_ctime":1592908804,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1592908804","product_id":100023901,"comment_content":"🤣老师啊，只将了用法，期待的synchronized的实现，synchronized优化都没有讲到啊","like_count":0,"discussions":[{"author":{"id":1508990,"avatar":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","nickname":"西门吹牛","note":"","ucode":"E5D3624DDE1E83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303358,"discussion_content":"synchronized 的实现，是基于底层用C++实现的ObjectMonitor实现的，也就是后面将的管程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599216536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223492,"user_name":"olivia-byte","can_delete":false,"product_type":"c1","uid":1273891,"ip_address":"","ucode":"D54B3833995923","user_header":"https://static001.geekbang.org/account/avatar/00/13/70/23/92d188aa.jpg","comment_is_top":false,"comment_ctime":1591102055,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591102055","product_id":100023901,"comment_content":"get() 方法和 addOne() 方法都需要访问 value 这个受保护的资源，这个资源用 this 这把锁来保护。线程要进入临界区 get() 和 addOne()，必须先获得 this 这把锁，这样 get() 和 addOne() 也是互斥的。这是不是也就说明这两个操作任何一个拿到锁之后没有释放另一个操作会被阻塞住","like_count":0},{"had_liked":false,"id":215910,"user_name":"coldwalker","can_delete":false,"product_type":"c1","uid":1751378,"ip_address":"","ucode":"B86846C0B36DD7","user_header":"https://static001.geekbang.org/account/avatar/00/1a/b9/52/3f0251b9.jpg","comment_is_top":false,"comment_ctime":1589133910,"is_pvip":false,"replies":[{"id":"80121","content":"volatile比synchronized更快一些","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1589286490,"ip_address":"","comment_id":215910,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589133910","product_id":100023901,"comment_content":"老师请问，例如int a = 10; 为了保证get和addOne方法的线程安全，都对这两个方法加synchronized更快，还是改为volatile int a = 10;然后get不加锁，addOne加锁更快？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494609,"discussion_content":"volatile比synchronized更快一些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589286490,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205852,"user_name":"Eric W.Liu","can_delete":false,"product_type":"c1","uid":1960096,"ip_address":"","ucode":"8B394A3C1448BA","user_header":"https://static001.geekbang.org/account/avatar/00/1d/e8/a0/14de6984.jpg","comment_is_top":false,"comment_ctime":1586747127,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586747127","product_id":100023901,"comment_content":"课后思考不能保证可见性和原子性，因为get和addOne方法在加锁资源时使用了synchronized(new Object)，new Object()每次都是一个新的对象，所以每次加锁都是在不同的对象上加锁，并没有保护到临界资源","like_count":0},{"had_liked":false,"id":205041,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1586513793,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586513793","product_id":100023901,"comment_content":"总结：<br>并发问题三个关注点：<br>1.锁的是什么？<br>2.保护的是什么？<br>3.锁和资源的关系是一对多<br>","like_count":0},{"had_liked":false,"id":205039,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1586513377,"is_pvip":false,"replies":[{"id":"76652","content":"每个线程操作自己的对象不属于并发问题","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1586527643,"ip_address":"","comment_id":205039,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1586513377","product_id":100023901,"comment_content":"老师，讲的真好，是我见过讲并发课中最好的了。<br><br>看了这篇，有个疑问，我先把上面代码复制下<br><br>class SafeCalc {<br>  long value = 0L;<br>  long get() {<br>    return value;<br>  }<br>  synchronized void addOne() {<br>    value += 1;<br>  }<br>}<br>我的理解是：<br>addOne()方法是普通方法，锁对象是this，<br>如果这个SafeCalc类是单例，不会有并发问题；<br>如果这个SafeCalc类是多例，假设有两个线程，两个线程都创建了SafeCalc对象，那就不是同一把锁了，锁的是两个不同的对象了，这种应该会有并发问题的吧？<br><br>","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491362,"discussion_content":"每个线程操作自己的对象不属于并发问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586527643,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204577,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1586423767,"is_pvip":false,"replies":[{"id":"76485","content":"对的👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1586430132,"ip_address":"","comment_id":204577,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1586423767","product_id":100023901,"comment_content":"思考题：因为get()和addOne()方法锁的是不同的对象，每次不同线程进来都会创建一个新的对象加锁，在不同线程不同锁对象下锁是无效的，会产生并发问题，也会产生可见性问题。那不同线程同一锁对象应该是没有并发问题的吧？<br><br>老师，这样理解是对的么？求答复","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491219,"discussion_content":"对的👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586430132,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":192562,"user_name":"Zain Zhu","can_delete":false,"product_type":"c1","uid":1125986,"ip_address":"","ucode":"5402E6FF76333A","user_header":"https://static001.geekbang.org/account/avatar/00/11/2e/62/ea49480e.jpg","comment_is_top":false,"comment_ctime":1584860595,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584860595","product_id":100023901,"comment_content":"不能。每次都是新对象了。","like_count":0},{"had_liked":false,"id":185655,"user_name":"Daiver","can_delete":false,"product_type":"c1","uid":1466447,"ip_address":"","ucode":"9B1A03AFBC79BC","user_header":"https://static001.geekbang.org/account/avatar/00/16/60/4f/db0e62b3.jpg","comment_is_top":false,"comment_ctime":1583656817,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583656817","product_id":100023901,"comment_content":"都保证不了，两个方法每次都是一把新锁，不存在互斥，改成this就好了，或者object 用单例实现。","like_count":0},{"had_liked":false,"id":183701,"user_name":"HungerW","can_delete":false,"product_type":"c1","uid":1022091,"ip_address":"","ucode":"75689EDF0F8E7F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/98/8b/7a691d53.jpg","comment_is_top":false,"comment_ctime":1583118008,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583118008","product_id":100023901,"comment_content":"new Object()每次都创建一个新锁，起不到保护临界资源作用。可见性和原子性问题一个都不能解决。","like_count":0},{"had_liked":false,"id":180362,"user_name":"褚","can_delete":false,"product_type":"c1","uid":1387363,"ip_address":"","ucode":"C2AA96A2E0F55F","user_header":"https://static001.geekbang.org/account/avatar/00/15/2b/63/ea02349c.jpg","comment_is_top":false,"comment_ctime":1582267685,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582267685","product_id":100023901,"comment_content":"我对synchronized理解是：一个对象只有一把钥匙，同一时间，只能有一个线程获得这个钥匙，去执行被这个对象锁住的代码块（执行过程中用到的资源会直接从内存中获取，不会从cpu内存中获取）；执行完代码块后会释放钥匙（把执行结果强制刷到内存），进行下一轮线程对钥匙的抢占；不知对否？感觉锁锁住的是代码块并没有锁住资源？","like_count":0},{"had_liked":false,"id":170061,"user_name":"花子翁","can_delete":false,"product_type":"c1","uid":1073674,"ip_address":"","ucode":"A687441DC6894F","user_header":"https://static001.geekbang.org/account/avatar/00/10/62/0a/26d00cb9.jpg","comment_is_top":false,"comment_ctime":1578500214,"is_pvip":false,"replies":[{"id":"67116","content":"如果程序不对异常进行处理，那就没招了，互斥锁只是提供保证原子性的能力，用不好还是会有问题的。至于崩溃，就谈不上原子性了","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1579438257,"ip_address":"","comment_id":170061,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578500214","product_id":100023901,"comment_content":"老师有个疑问，麻烦帮忙解答一下：<br>互斥锁能够保证“同一时刻只有一个线程执行”，即在临界区内对共享变量的修改是互斥的，而互斥性如何能推导出原子性呢？<br>1 对共享变量的修改涉及多条指令(01文章已经说明)，如果在执行某条指令的过程中发生异常，<br>那如何能够保证对共享变量修改的原子性(一个或多个操作在CPU执行过程中不被中断的特性)<br><br>2 如果在临界区内对多个共享变量的修改，在修改完一个临时变量发生异常或崩溃，<br>如何能够保证对多个共享变量修改的原子性","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480826,"discussion_content":"如果程序不对异常进行处理，那就没招了，互斥锁只是提供保证原子性的能力，用不好还是会有问题的。至于崩溃，就谈不上原子性了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579438257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168838,"user_name":"Qualifor","can_delete":false,"product_type":"c1","uid":1658706,"ip_address":"","ucode":"8F42453286719C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJeQVzYNLVuOv8IuxydsXuVXEUoqLmN0vpkiceZuU26KPOt05xuxCSnsbkgBu4q9qmibRfTOvCiaPGJg/132","comment_is_top":false,"comment_ctime":1578196376,"is_pvip":false,"replies":[{"id":"65464","content":"原子性只保证addone方法自己是原子的，也就是说多个线程同时执行这个方法，能保证原子性，其他的保证不了。建议直接用hb规则来推导可见性，不要考虑刷缓存的思路，那个是jvm的实现，可能这个版本对，下个版本就改了。但是hb规则不会变，所有版本都遵守","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1578208183,"ip_address":"","comment_id":168838,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578196376","product_id":100023901,"comment_content":"老师，针对陈华同学的评论我想请教两个问题：<br>1：“对一个锁解锁  Happens-Before 后续对这个锁的加锁”这句话就是陈华同学提到的“synchronized解锁之后会强制其它CPU强制刷新缓存,然后从内存里读取最新的值”的依据吗？如果不是的话，那老师您支持他这种说法是基于什么呢？如果是我刚刚说的那个依据，那如果别的线程不调用 synchronized 方法，也就不进行加锁，就构不成“对一个锁解锁  Happens-Before 后续对这个锁的加锁”的条件，那还会刷新 CPU 缓存吗？<br>2：还有就是addOne()方法不是原子操作，value += 1，结合您之前课的内容它是有三步操作<br>    2.1：指令 1：首先，需要把变量 value 从内存加载到 CPU 的寄存器<br>    2.2：指令 2：之后，在寄存器中执行 +1 操作；<br>    2.3：指令 3：最后，将结果写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）<br>如果只进行到第二步或者哪怕进行到了第三步，它也只会写入当前 CPU 缓存，而如果此时当前 CPU 时间片就使用完了，就需要线程切换，那么此时解锁操作还没有完成，那么其它 CPU 就不会强制刷新缓存，如果此时其它 CPU 调用不加锁的  get 方法， 那这不是还是存在可见性的问题吗？<br>并发方面新手，如果提问的有问题还请见谅，希望老师抽时间能解答一下，非常感谢","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480350,"discussion_content":"原子性只保证addone方法自己是原子的，也就是说多个线程同时执行这个方法，能保证原子性，其他的保证不了。建议直接用hb规则来推导可见性，不要考虑刷缓存的思路，那个是jvm的实现，可能这个版本对，下个版本就改了。但是hb规则不会变，所有版本都遵守","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578208183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166030,"user_name":"阿U","can_delete":false,"product_type":"c1","uid":1171359,"ip_address":"","ucode":"161A8E74E0D612","user_header":"https://static001.geekbang.org/account/avatar/00/11/df/9f/6e3e1b77.jpg","comment_is_top":false,"comment_ctime":1577366825,"is_pvip":false,"replies":[{"id":"63413","content":"多把锁不能保护一个资源，不是所有情况都适用。不过工作中把它作为最佳实践业不错","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1577445229,"ip_address":"","comment_id":166030,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1577366825","product_id":100023901,"comment_content":"老师 这一章可以简单总结成 一把锁可以保护一个或多个资源，但多把锁不能保护一个资源，这样理解对不对。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479361,"discussion_content":"多把锁不能保护一个资源，不是所有情况都适用。不过工作中把它作为最佳实践业不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577445229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165968,"user_name":"遥遥无妻","can_delete":false,"product_type":"c1","uid":1251243,"ip_address":"","ucode":"30A765B411D059","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/ab/c0235b70.jpg","comment_is_top":false,"comment_ctime":1577352605,"is_pvip":false,"replies":[{"id":"63434","content":"是的，可重入","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1577454852,"ip_address":"","comment_id":165968,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1577352605","product_id":100023901,"comment_content":"老师问下，在这段代码中说是为了保证可见性，给get方法也加了syn。提到get() 和 addOne() 也是互斥的。这个互斥指的是不同线程中的吧，同一个线程A拿到锁调add方法，还能调get方法吧应该，syn是属于可重入的锁吧。<br>class SafeCalc {<br>  long value = 0L;<br>  synchronized long get() {<br>    return value;<br>  }<br>  synchronized void addOne() {<br>    value += 1;<br>  }<br>}","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479333,"discussion_content":"是的，可重入","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577454852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165216,"user_name":"乾坤瞬间","can_delete":false,"product_type":"c1","uid":1683130,"ip_address":"","ucode":"15BDCF29CBF8EB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","comment_is_top":false,"comment_ctime":1577180869,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577180869","product_id":100023901,"comment_content":"是有问题的，因为所的不是同一个对象","like_count":0},{"had_liked":false,"id":164489,"user_name":"曉楓","can_delete":false,"product_type":"c1","uid":1607988,"ip_address":"","ucode":"E2B4C10FC4DAB2","user_header":"https://static001.geekbang.org/account/avatar/00/18/89/34/758bd3ab.jpg","comment_is_top":false,"comment_ctime":1577007780,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577007780","product_id":100023901,"comment_content":"本来是看的第三方的资料，发现评论多大神后，果断买课程","like_count":0},{"had_liked":false,"id":163883,"user_name":"CalanceHao","can_delete":false,"product_type":"c1","uid":1401137,"ip_address":"","ucode":"068B4AC4D1D402","user_header":"https://static001.geekbang.org/account/avatar/00/15/61/31/211ac1a9.jpg","comment_is_top":false,"comment_ctime":1576818257,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576818257","product_id":100023901,"comment_content":"Hmm... 虽然还没实操搞懂究竟怎么回事 但应该是不行的 因为计数器的最佳实践不是AtomicInteger嘛😜投机取巧的抢答<br>等回头要认真操作一下，刷一刷留言区，随便一扫看起来都很高级啊👍🏻","like_count":0},{"had_liked":false,"id":157003,"user_name":"Fortune","can_delete":false,"product_type":"c1","uid":1508654,"ip_address":"","ucode":"6B9465AC996523","user_header":"https://static001.geekbang.org/account/avatar/00/17/05/2e/5a6b6b6e.jpg","comment_is_top":false,"comment_ctime":1575011446,"is_pvip":false,"replies":[{"id":"65940","content":"就应该是1，两个线程操作两个对象，两个对象里各有自己的value","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1578488879,"ip_address":"","comment_id":157003,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1575011446","product_id":100023901,"comment_content":"public class A implements Runnable {<br>    static A instance1 = new A;<br>    static A instance2 = new A;<br>    long value = 0L;<br><br>    @Override<br>    public void run() {<br>        addOne();<br>        getValue();<br>    }<br>    public  synchronized long addOne() {<br>        return value+=1;<br>    }<br>    public long getValue() {<br>        System.out.println(Thread.currentThread().getName()+&quot;:value=&quot;+value);<br>        return value;<br>    }<br><br>    public static void main(String[] args) {<br>        Thread t1 = new Thread(instance1);<br>        Thread t2 = new Thread(instance2);<br>        t1.start();<br>        t2.start();<br>这样写有问题吗？输出的value都是1，是不是哪里错了","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476300,"discussion_content":"就应该是1，两个线程操作两个对象，两个对象里各有自己的value","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578488879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152973,"user_name":"Eleven","can_delete":false,"product_type":"c1","uid":1168452,"ip_address":"","ucode":"FB4A0C8CA732BE","user_header":"https://static001.geekbang.org/account/avatar/00/11/d4/44/0ec958f4.jpg","comment_is_top":false,"comment_ctime":1574132195,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574132195","product_id":100023901,"comment_content":"我觉得不能，因为两个代码块中的synchronized使用了不对的锁对象，对于value的访问并不能形成互斥关系。","like_count":0},{"had_liked":false,"id":148872,"user_name":"朕爱吾妃","can_delete":false,"product_type":"c1","uid":1733692,"ip_address":"","ucode":"B10EB69934F9E2","user_header":"https://static001.geekbang.org/account/avatar/00/1a/74/3c/da79d2a1.jpg","comment_is_top":false,"comment_ctime":1573097973,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573097973","product_id":100023901,"comment_content":"对于思考题：<br>synchronized (new Object())，两个都是这样的操作，说明加锁的对象不是同一个对象，所以，会出现并发的问题","like_count":0},{"had_liked":false,"id":148871,"user_name":"Fortune","can_delete":false,"product_type":"c1","uid":1508654,"ip_address":"","ucode":"6B9465AC996523","user_header":"https://static001.geekbang.org/account/avatar/00/17/05/2e/5a6b6b6e.jpg","comment_is_top":false,"comment_ctime":1573097602,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573097602","product_id":100023901,"comment_content":"每次执行方法，都创建一个新的对象，加一把锁，所以加锁没什么作用了，老师讲的例子理解synchronized是很好的，但是感觉对知识点总结这块不是很清晰哈，有的需要在课后题中才能总结到哈，本人愚笨，想对知识点进行总结，但思路不够清晰。","like_count":0},{"had_liked":false,"id":146317,"user_name":"子非鱼","can_delete":false,"product_type":"c1","uid":1621660,"ip_address":"","ucode":"020DA0784E728C","user_header":"https://static001.geekbang.org/account/avatar/00/18/be/9c/d21b7e17.jpg","comment_is_top":false,"comment_ctime":1572495992,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1572495992","product_id":100023901,"comment_content":"使用sync加锁非静态方法，锁对象使用的是当前对象实例，那在多线程的时候每个线程都会产生不同的this，这样就不会存租锁竞争关系，那是怎么保证将并行线程改成串行的，求解。是不是就得看synx是怎么实现的？","like_count":0,"discussions":[{"author":{"id":1621660,"avatar":"https://static001.geekbang.org/account/avatar/00/18/be/9c/d21b7e17.jpg","nickname":"子非鱼","note":"","ucode":"020DA0784E728C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":43083,"discussion_content":"我晓得我的疑问了，this代表当前实例对象，只要保证不同的线程操作的是同一个this就行，不是每个线程创建一个this😁😁。然后这样多线程就会产生竞争关系，就是老师最后留的疑问，sync里面new 对象 是不行的，这样多线程下，每个线程持有自己的锁，不会存在竞争排斥关系。 ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1572852319,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1621660,"avatar":"https://static001.geekbang.org/account/avatar/00/18/be/9c/d21b7e17.jpg","nickname":"子非鱼","note":"","ucode":"020DA0784E728C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":43084,"discussion_content":"自问自答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572852330,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141942,"user_name":"无言的约定","can_delete":false,"product_type":"c1","uid":1128953,"ip_address":"","ucode":"5E8046EB6B7956","user_header":"https://static001.geekbang.org/account/avatar/00/11/39/f9/acfb9a48.jpg","comment_is_top":false,"comment_ctime":1571272866,"is_pvip":false,"replies":[{"id":"54823","content":"有区别，可以看看java语言基础","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1571284732,"ip_address":"","comment_id":141942,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571272866","product_id":100023901,"comment_content":"对于上面的例子，synchronized 修饰静态方法相当于:<br><br>\t<br>class X {<br><br><br>\t<br>  &#47;&#47; 修饰静态方法<br><br><br>\t<br>  synchronized(X.class) static void bar() {<br><br><br>\t<br>    &#47;&#47; 临界区<br><br><br>\t<br>  }<br><br><br>\t<br>}<br>复制代码<br><br>修饰非静态方法，相当于：<br><br>\t<br>class X {<br><br><br>\t<br>  &#47;&#47; 修饰非静态方法<br><br><br>\t<br>  synchronized(this) void foo() {<br><br><br>\t<br>    &#47;&#47; 临界区<br><br><br>\t<br>  }<br><br><br>\t<br>}<br><br><br>王老师，这个例子中的X.class和this有什么区别吗？this不就是X的对象吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470936,"discussion_content":"有区别，可以看看java语言基础","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571284732,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138697,"user_name":"orange0729","can_delete":false,"product_type":"c1","uid":1519642,"ip_address":"","ucode":"5CCB7AE53A7DDD","user_header":"https://static001.geekbang.org/account/avatar/00/17/30/1a/606e09a4.jpg","comment_is_top":false,"comment_ctime":1570424439,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570424439","product_id":100023901,"comment_content":"老师，get方法和addone方法分别加锁是什么意思呢？get方法没有必要加锁啊","like_count":0},{"had_liked":false,"id":138093,"user_name":"yc","can_delete":false,"product_type":"c1","uid":1670122,"ip_address":"","ucode":"2E01505284DC4E","user_header":"https://static001.geekbang.org/account/avatar/00/19/7b/ea/a64f7822.jpg","comment_is_top":false,"comment_ctime":1570019592,"is_pvip":false,"replies":[{"id":"53092","content":"我觉得对于初学者，没必要纠结评论的内容，内部怎么实现没必要深究，会用即可。等建立起知识体系后，看兴趣和工作需求看是否有必要研究实现。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1570023831,"ip_address":"","comment_id":138093,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1570019592","product_id":100023901,"comment_content":"看了评论区，发现对于sysn锁的对象这些不懂，这个课程是还需要什么先备课程吗，编译原理？jvm原理？请老师回答一下，谢谢。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469381,"discussion_content":"我觉得对于初学者，没必要纠结评论的内容，内部怎么实现没必要深究，会用即可。等建立起知识体系后，看兴趣和工作需求看是否有必要研究实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570023831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135641,"user_name":"B 612 星球来客","can_delete":false,"product_type":"c1","uid":1113469,"ip_address":"","ucode":"CBFB05B1F1B178","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/7d/a4bda9ce.jpg","comment_is_top":false,"comment_ctime":1569232875,"is_pvip":false,"replies":[{"id":"52035","content":"java提供了专门的原子操作工具类，可以专门解决这个问题，但是无锁方案难度太大","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1569245520,"ip_address":"","comment_id":135641,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569232875","product_id":100023901,"comment_content":"有个问题，老师，解决原子性问题不是还有CAS无锁操作么","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468284,"discussion_content":"java提供了专门的原子操作工具类，可以专门解决这个问题，但是无锁方案难度太大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569245520,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130064,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1567382078,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567382078","product_id":100023901,"comment_content":"每次都是一把新锁，不行的","like_count":0},{"had_liked":false,"id":128703,"user_name":"白小白","can_delete":false,"product_type":"c1","uid":1400416,"ip_address":"","ucode":"143F1C8294818A","user_header":"https://static001.geekbang.org/account/avatar/00/15/5e/60/1c13626b.jpg","comment_is_top":false,"comment_ctime":1566952787,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566952787","product_id":100023901,"comment_content":"思考题是不是把new object改成this就可以了？求大神们指教……","like_count":0},{"had_liked":false,"id":128613,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1566914105,"is_pvip":false,"replies":[{"id":"47882","content":"CPU有关中断的指令","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1566996270,"ip_address":"","comment_id":128613,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566914105","product_id":100023901,"comment_content":"如何禁止cpu中断","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465022,"discussion_content":"CPU有关中断的指令","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566996270,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127246,"user_name":" 臣馟飞扬","can_delete":false,"product_type":"c1","uid":1116188,"ip_address":"","ucode":"F2F882B7678055","user_header":"https://static001.geekbang.org/account/avatar/00/11/08/1c/ef15e661.jpg","comment_is_top":false,"comment_ctime":1566619029,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566619029","product_id":100023901,"comment_content":"使用synchronized加锁需要注意的点：<br>1、单核CPU禁止中断不会导致原子性问题，多核CPU禁止中断依然会有原子性问题；<br>2、要锁的对象是什么？要保护的是什么（共享变量）？<br>3、锁和要保护的共享变量是1：N的关系，也即一把锁可以保护多个共享变量，多个锁不能保护同一个共享变量。","like_count":0},{"had_liked":false,"id":127160,"user_name":"Thong2018","can_delete":false,"product_type":"c1","uid":1625515,"ip_address":"","ucode":"DA05A3B08D1DEA","user_header":"","comment_is_top":false,"comment_ctime":1566571008,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566571008","product_id":100023901,"comment_content":"锁和锁对象是什么关系？","like_count":0},{"had_liked":false,"id":127159,"user_name":"Thong2018","can_delete":false,"product_type":"c1","uid":1625515,"ip_address":"","ucode":"DA05A3B08D1DEA","user_header":"","comment_is_top":false,"comment_ctime":1566570922,"is_pvip":false,"replies":[{"id":"47060","content":"可以找看看jdk里lock的用法<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1566605177,"ip_address":"","comment_id":127159,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566570922","product_id":100023901,"comment_content":"对于课后思考题，有的人说是&quot;要锁同一个对象&quot;，有的人说是&quot;没有用同一把锁&quot;，有点懵，我就想知道到底是谁在锁谁呀？谁是动作的发出者？谁又是动作的承受者？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464348,"discussion_content":"可以找看看jdk里lock的用法\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566605177,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126096,"user_name":"Geek_e08661","can_delete":false,"product_type":"c1","uid":1631281,"ip_address":"","ucode":"DFD60339814CA6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er8ok3W1JuxlK1eHjfylzhBwkFm8lkIr4KibzLic5YjonIXj4t9RNkKV0PBUZv1wPM0fwdIwib6pickGA/132","comment_is_top":false,"comment_ctime":1566312696,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566312696","product_id":100023901,"comment_content":"作者回复: 1. println的代码里锁的this指的是你的控制台，这个锁跟你的代码没关系，而且println里也没有写操作，所以println不会导致强刷缓存。<br><br>我觉得是因为println产生了IO，IO相对CPU来说，太慢，所以这个期间大概率的会把缓存的值写入内存。也有可能这个线程被调度到了其他的CPU上，压根没有缓存，所以只能从内存取数。你调用sleep，效果应该也差不多。<br><br>2. 线程切换显然不足以保证可见性，保证的可见性只能靠hb规则。<br><br>3. 线程结束后，不一定会强刷缓存。否则Join的规则就没必要了<br><br>并发问题本来就是小概率的事件，尤其有了IO操作之后，概率就更低了。<br>======================================================<br>老师好，针对回复1，我还存在疑问，如果是说切换的cpu无缓存还可以理解，<br>1&gt;假如主线程在线程2进行io操作时，将b=2刷新到主内存，线程2的cpu缓存还是b=1,那么他怎么知道主内存被更新了。<br>2&gt;再做一个假设，假如线程2可以知道主内存更新，那么怎么确保线程2在线程1更新完b到主内存之后再去主内存更新值，如果在线程1更新之前去主内存更新b，此时的b还是等于1，那不就在线程2中没有b=2的情况，望解答","like_count":0},{"had_liked":false,"id":124311,"user_name":"给心来块冰块","can_delete":false,"product_type":"c1","uid":1063689,"ip_address":"","ucode":"7AFB56581782A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/09/2cf074a7.jpg","comment_is_top":false,"comment_ctime":1565857809,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1565857809","product_id":100023901,"comment_content":"看的好痛苦，不太好理解","like_count":0},{"had_liked":false,"id":117054,"user_name":"HUANGKAIHANG","can_delete":false,"product_type":"c1","uid":1430163,"ip_address":"","ucode":"F3871C5142AE52","user_header":"https://static001.geekbang.org/account/avatar/00/15/d2/93/9c58ce42.jpg","comment_is_top":false,"comment_ctime":1563960096,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563960096","product_id":100023901,"comment_content":"老师你好，我的理解有没有问题。当addOne方法加上synchronized关键字后，加锁时锁的是this对象，这时候其它线程不能调用this.get方法吧，这算不算间接达成了互斥？？如果是的话，那么这里的get方法不加锁也不会有并发问题。","like_count":0},{"had_liked":false,"id":116446,"user_name":"天上星多月不亮","can_delete":false,"product_type":"c1","uid":1283877,"ip_address":"","ucode":"A8CD6A7C094F0C","user_header":"https://static001.geekbang.org/account/avatar/00/13/97/25/8c35cc85.jpg","comment_is_top":false,"comment_ctime":1563851547,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563851547","product_id":100023901,"comment_content":"synchonize不是会在操作完毕后写回内存吗？在读取value的时候又会去内存中读，跟volatile有类似语义，为什么会出现不可见呢","like_count":0},{"had_liked":false,"id":115489,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1563602259,"is_pvip":false,"replies":[{"id":"53888","content":"CPU会在指令执行完会自动检测中断，时钟中断也是中断。锁的嵌套一定要慎重","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1570707918,"ip_address":"","comment_id":115489,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563602259","product_id":100023901,"comment_content":"---总结---<br>1. 锁是实现互斥的手段之一。<br>2. 加锁和解锁的过程就是建立某个锁和受保护资源的关联和确定临界区的过程，该受保护资源所在的一段或多段可能会被多线程访问的代码段即是需要加锁和解锁的一个或多个临界区。<br>3. 受保护资源和锁之间的关联关系是N:1的关系，即一把锁可以保护多个资源，但一个资源不能用多把锁来保护。<br>4. 锁要精心选择，比如String字面量不能作为锁，否则会出现大量死锁，非final的域不能作为锁，否则起不到效果等。<br><br>---启发---<br>1. 在思考并发问题时可以通过单核线程切换和多核线程并行并结合可见性、原子性、有序性角度思考可能存在的问题。<br><br>---问题---<br>1. 老师提到线程切换时依赖CPU中断的，我知道中断会引起线程切换，但是在CPU调度时，如采用时间片轮转算法时，也是依赖于中断来进行上下文切换的吗？或者说，在这种场景下，上下文切换的动作是在判断时间片达到后，通过中断指令，让当前指令运行到指令周期的中断周期时进行上下文切换的吗？<br>2. 老师提到一个资源不能用多把锁来保护，但我们在死锁的例程中经常会见到如嵌套sychronized的场景，这种场景下大的sychronized的锁似乎也锁住了小的sychronized中的共享资源，这种场景是否就是一种不会在实际中使用的Bad Practice呢？<br><br>老师可抽空回答，若有表达不正确之处，也烦请指出，谢谢！","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459131,"discussion_content":"CPU会在指令执行完会自动检测中断，时钟中断也是中断。锁的嵌套一定要慎重","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570707918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":113155,"user_name":"JM","can_delete":false,"product_type":"c1","uid":1444751,"ip_address":"","ucode":"940900318F4167","user_header":"https://static001.geekbang.org/account/avatar/00/16/0b/8f/9c27f3c6.jpg","comment_is_top":false,"comment_ctime":1562904058,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562904058","product_id":100023901,"comment_content":"这才明白，synchronized锁跟资源的关系","like_count":0},{"had_liked":false,"id":111621,"user_name":"邢宇超","can_delete":false,"product_type":"c1","uid":1105246,"ip_address":"","ucode":"3113F55E60ADE9","user_header":"https://static001.geekbang.org/account/avatar/00/10/dd/5e/ddbdde5a.jpg","comment_is_top":false,"comment_ctime":1562573893,"is_pvip":false,"replies":[{"id":"40629","content":"您客气了😂双核的CPU，两个核可以同时执行一条指令","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1562590304,"ip_address":"","comment_id":111621,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562573893","product_id":100023901,"comment_content":"同一时刻，有可能有两个线程同时在执行，一个线程执行在 CPU-1上，一个线程执行在 CPU-2 上，此时禁止 CPU 中断，只能保证 CPU 上的线程连续执行，并不能保证同一时刻只有一个线程执行，如果这两个线程同时写 long 型变量高 32位的话，那就有可能出现我们开头提及的诡异 Bug 了。<br>敬爱的老师   为什么写long型变量高32位会2个线程 同时写呢<br><br><br><br>","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457391,"discussion_content":"您客气了😂双核的CPU，两个核可以同时执行一条指令","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562590304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107903,"user_name":"Mr.钧👻","can_delete":false,"product_type":"c1","uid":1249939,"ip_address":"","ucode":"D781E030E79245","user_header":"https://static001.geekbang.org/account/avatar/00/13/12/93/3470fc43.jpg","comment_is_top":false,"comment_ctime":1561631584,"is_pvip":false,"replies":[{"id":"39044","content":"第二部分会介绍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1561633750,"ip_address":"","comment_id":107903,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561631584","product_id":100023901,"comment_content":"老师您好，想请教一个问题。在for循环中，使用线程池的execute方式开启10个线程。然后主线程调用join方法。但是在子线程都完成后，主线程并没有被唤醒。请问这是什么原因呢？要怎么解决呢？主线程能否监听子线程完成后，自动唤醒呢？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455737,"discussion_content":"第二部分会介绍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561633750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107475,"user_name":"a(๑≖ิټ≖ิ)✌","can_delete":false,"product_type":"c1","uid":1392431,"ip_address":"","ucode":"AEF9B5CA1605DF","user_header":"https://static001.geekbang.org/account/avatar/00/15/3f/2f/8513c4d3.jpg","comment_is_top":false,"comment_ctime":1561542091,"is_pvip":false,"replies":[{"id":"38896","content":"这样理解也对","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1561550097,"ip_address":"","comment_id":107475,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1561542091","product_id":100023901,"comment_content":"一开始我想不通为什么要在get方法加锁，后面看到一个静态方法加锁，一个实例方法加锁，就有点明白是因为有可能同一线程既有get又有set操作，需要保证这个变量前后一致，所以get方法也需要加锁，否则线程A前面set了1，后面线程B改成2，A再调用get获取的就是2了，是这样理解吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455524,"discussion_content":"这样理解也对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561550097,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":100188,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1559473646,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559473646","product_id":100023901,"comment_content":"老师我想问下对一个对象上锁的意义在哪里？是让一个时候只能有一个线程去修改对象的内容么，对于你文末的问题，在方法里给对象加锁，那资源区是哪里，对象本身还是方法里面呢","like_count":0},{"had_liked":false,"id":99467,"user_name":"轩辕豆豆","can_delete":false,"product_type":"c1","uid":1501713,"ip_address":"","ucode":"1FCFC608BD2B4A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eribUNj9ylC04DQdaM42AD0pLsVficcyTS3GdVBdibpnDrPSAo4ohNmBzRmiavOLuibCEj8wru0ibIJOZ1A/132","comment_is_top":false,"comment_ctime":1559223349,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559223349","product_id":100023901,"comment_content":"课后思考中sync修饰的代码块不可以用new Object，因为每次创建对象指针不同，多线程调用时这个锁就不是互斥的了","like_count":0},{"had_liked":false,"id":98615,"user_name":"cricket1981","can_delete":false,"product_type":"c1","uid":1001715,"ip_address":"","ucode":"758262F5958DA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/f3/f1034ffd.jpg","comment_is_top":false,"comment_ctime":1559042411,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559042411","product_id":100023901,"comment_content":"请问如何对基本类型对象加synchronized锁？例如Long userId, String userName等。","like_count":0},{"had_liked":false,"id":98497,"user_name":"今夜秋风和","can_delete":false,"product_type":"c1","uid":1434066,"ip_address":"","ucode":"453C8197FFC81D","user_header":"https://static001.geekbang.org/account/avatar/00/15/e1/d2/42ad2c87.jpg","comment_is_top":false,"comment_ctime":1559012056,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559012056","product_id":100023901,"comment_content":"老师好，<br>前面说的用voliate 变量可以达到内存的可见性,用个测试用例测试了一下，获取到的值是缓存的值，列子有点长，麻烦老师帮分析分析；<br>public class CountSumEntity {<br>    private   volatile int i;<br><br>    public synchronized  void  add (){<br>        i++;<br>        System.out.println(&quot;add-i=&quot;+i+&quot;-----threadid=&quot;+Thread.currentThread().getId());<br>    }<br><br>    public  int get(){<br>        System.out.println(&quot;i=&quot;+i+&quot;----threadid=&quot;+Thread.currentThread().getId());<br>        return i;<br>    }<br><br>    public static void main(String[] args) {<br>        CountSumEntity countSumEntity=new CountSumEntity();<br>        ExecutorService service =Executors.newFixedThreadPool(100);<br>        for (int i = 0; i &lt;1000 ; i++) {<br>            service.execute(new Runnable() {<br>                @Override<br>                public void run() {<br>                    countSumEntity.add();<br>                    countSumEntity.get();<br>                }<br>            });<br>        }<br>        service.shutdown();<br><br>    }<br><br>}<br>add-i=1-----threadid=11<br>add-i=2-----threadid=110<br>add-i=3-----threadid=109<br>i=1----threadid=11  &#47;&#47;这个理解应该读到的是3 ，打印出来读到的是1<br>add-i=4-----threadid=108<br>i=3----threadid=109<br>add-i=5-----threadid=107","like_count":0},{"had_liked":false,"id":94458,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1435138,"ip_address":"","ucode":"2817C6A41C2E53","user_header":"https://static001.geekbang.org/account/avatar/00/15/e6/02/65a764fe.jpg","comment_is_top":false,"comment_ctime":1557816904,"is_pvip":false,"replies":[{"id":"33802","content":"第一章说的双重检查的例子，也很难重现，但理论上还是会出问题。比较靠谱的方法是内存模型推断不出来的，就认为有问题。当然这个条件更严格，有些不符合的，也没问题。你这个例子用了join，属于可以推导出来没问题的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1557843638,"ip_address":"","comment_id":94458,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557816904","product_id":100023901,"comment_content":"老师，例子中说synchronized用于保证操作的原子性，如果get方法没有synchronized的话不能保证可见性，下面的代码模拟了多线程操作addOne方法，但是get方法上有没有synchronized结果都是正确的。为什么没有出现可见性问题呢？<br>public class Test {<br><br>  private long c = 0;<br><br>  &#47;&#47;getC方法有没有synchronized运行结果都一样<br>  public long getC() {<br>    return c;<br>  }<br><br>  public synchronized void addOne() {<br>    c += 1;<br>    &#47;&#47;为了模拟长时间处理<br>    long i = 0;<br>    while (i &lt; 100000000L) {<br>      i++;<br>    }<br>  }<br><br>  public static void main(String[] args) throws InterruptedException {<br>    Test test = new Test();<br><br>    &#47;&#47;每个线程都加10<br>    Thread t1 = new Thread(()-&gt;{<br>      for (int i = 0; i &lt; 10; i++) {<br>        test.addOne();<br>      }<br>    });<br>    Thread t2 = new Thread(()-&gt;{<br>      for (int i = 0; i &lt; 10; i++) {<br>        test.addOne();<br>      }<br>    });<br>    Thread t3 = new Thread(()-&gt;{<br>      for (int i = 0; i &lt; 10; i++) {<br>        test.addOne();<br>      }<br>    });<br>    t1.start();<br>    t2.start();<br>    t3.start();<br><br>    t1.join();<br>    t2.join();<br>    t3.join();<br><br>    System.out.println(test.getC());<br>  }<br>}<br>","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450072,"discussion_content":"第一章说的双重检查的例子，也很难重现，但理论上还是会出问题。比较靠谱的方法是内存模型推断不出来的，就认为有问题。当然这个条件更严格，有些不符合的，也没问题。你这个例子用了join，属于可以推导出来没问题的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557843638,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91845,"user_name":"Niuniu","can_delete":false,"product_type":"c1","uid":1103084,"ip_address":"","ucode":"0F4C2CE8C076A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/ec/804c3900.jpg","comment_is_top":false,"comment_ctime":1557119575,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557119575","product_id":100023901,"comment_content":"别皱眉同学的问题，关于是不是触发IO导致内存刷新，可以很容易验证。把class A里面所有上的System.out.println命令全部comment out，再run一遍，会发现程序进入死循环。没有system.out。println，没触发io，所以内存没有刷新。","like_count":0},{"had_liked":false,"id":89711,"user_name":"bro.","can_delete":false,"product_type":"c1","uid":1124948,"ip_address":"","ucode":"D65283CD869804","user_header":"https://static001.geekbang.org/account/avatar/00/11/2a/54/c9990105.jpg","comment_is_top":false,"comment_ctime":1556247925,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556247925","product_id":100023901,"comment_content":"不可以,相当于什么都没做,每次进来new object就相当于创建一把新锁,跟其他线程完全无关,所有锁都是一次性的,可以new object()作为全局变量引用即可","like_count":0},{"had_liked":false,"id":89030,"user_name":"旭东(Frank)","can_delete":false,"product_type":"c1","uid":1024486,"ip_address":"","ucode":"176FA629800062","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a1/e6/50da1b2d.jpg","comment_is_top":false,"comment_ctime":1556067270,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556067270","product_id":100023901,"comment_content":"互斥锁，一定要锁同一对象。否则形同虚设","like_count":0},{"had_liked":false,"id":88422,"user_name":"劉小强","can_delete":false,"product_type":"c1","uid":1178474,"ip_address":"","ucode":"07FC2F0CDED869","user_header":"https://static001.geekbang.org/account/avatar/00/11/fb/6a/be4956a3.jpg","comment_is_top":false,"comment_ctime":1555917649,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555917649","product_id":100023901,"comment_content":"为什么get方法要加synchronized修饰  一个线程执行add方法还没执行完的时候，调用get方法显示没有+1后的值不是应该是正确的么，加上这个synchronized的必要性是什么？没有理解","like_count":0},{"had_liked":false,"id":87401,"user_name":"xuery","can_delete":false,"product_type":"c1","uid":1027584,"ip_address":"","ucode":"F461B61BE06131","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/00/025f37e7.jpg","comment_is_top":false,"comment_ctime":1555584320,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1555584320","product_id":100023901,"comment_content":"不正确。每次加的都是不同的锁，起不到互斥的作用","like_count":0},{"had_liked":false,"id":87137,"user_name":"qzm","can_delete":false,"product_type":"c1","uid":1117169,"ip_address":"","ucode":"0BFAB84A257081","user_header":"https://static001.geekbang.org/account/avatar/00/11/0b/f1/042df911.jpg","comment_is_top":false,"comment_ctime":1555516112,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555516112","product_id":100023901,"comment_content":"回答下问题：无法解决可见性跟原子性。原因是synchronized的加锁的资源(即监视器)不是同一个！故就无法互斥。","like_count":0},{"had_liked":false,"id":85784,"user_name":"刘梦茹","can_delete":false,"product_type":"c1","uid":1048298,"ip_address":"","ucode":"A7E893EFC876CD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fe/ea/d8b1909e.jpg","comment_is_top":false,"comment_ctime":1555232392,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555232392","product_id":100023901,"comment_content":"两把锁保护同一个资源value，这两把锁，锁定的对象是两个不同的Object实例，临界区get()和addOne()不具有互斥性，因此不保证可见性。","like_count":0},{"had_liked":false,"id":85467,"user_name":"90飞","can_delete":false,"product_type":"c1","uid":1241944,"ip_address":"","ucode":"9F360D766FB606","user_header":"https://static001.geekbang.org/account/avatar/00/12/f3/58/1ef2fa55.jpg","comment_is_top":false,"comment_ctime":1555067359,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555067359","product_id":100023901,"comment_content":"为啥会被编译器优化掉？","like_count":0},{"had_liked":false,"id":85299,"user_name":"angel😇txy🤓","can_delete":false,"product_type":"c1","uid":1133702,"ip_address":"","ucode":"C0AEE0D8BAF7ED","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/86/3be94807.jpg","comment_is_top":false,"comment_ctime":1555031588,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1555031588","product_id":100023901,"comment_content":"高手太多","like_count":0},{"had_liked":false,"id":84893,"user_name":"Vincent","can_delete":false,"product_type":"c1","uid":1135159,"ip_address":"","ucode":"CD8B84A57A6A0C","user_header":"https://static001.geekbang.org/account/avatar/00/11/52/37/13b4c8aa.jpg","comment_is_top":false,"comment_ctime":1554943506,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554943506","product_id":100023901,"comment_content":"同一个时刻只有一个线程执行临界区代码，是互斥的唯一条件","like_count":0},{"had_liked":false,"id":82869,"user_name":"WP","can_delete":false,"product_type":"c1","uid":1105956,"ip_address":"","ucode":"4A24C6CAA70220","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/24/4529f2a4.jpg","comment_is_top":false,"comment_ctime":1554341533,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554341533","product_id":100023901,"comment_content":"每篇文章看完之后，再回来看融会贯通，很多都串起来了，哈哈，老师优秀","like_count":0},{"had_liked":false,"id":82521,"user_name":"Vincent","can_delete":false,"product_type":"c1","uid":1135159,"ip_address":"","ucode":"CD8B84A57A6A0C","user_header":"https://static001.geekbang.org/account/avatar/00/11/52/37/13b4c8aa.jpg","comment_is_top":false,"comment_ctime":1554248328,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554248328","product_id":100023901,"comment_content":"课后习题因为每个方法使用不同的锁，不能达到互斥的效果，不能解决原子性问题，sync同步关键字，线程对sync锁的解锁happen-before于后续线程对sync的加锁，可见性问题可以解决。<br><br>但是有一个小问题就是sync使用的是两个不同的锁，happen-before规则对于这种情况还有效？","like_count":0},{"had_liked":false,"id":82021,"user_name":"虎爷","can_delete":false,"product_type":"c1","uid":1024907,"ip_address":"","ucode":"42E8339F183055","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a3/8b/e7389cf5.jpg","comment_is_top":false,"comment_ctime":1554104796,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1554104796","product_id":100023901,"comment_content":"先给结果：get() 和andOne()这2个方法，都不能解决可见性和原子性问题。<br>再来具体分析：synchronized代码块中，加的锁是new的一个Object，这个锁本身和资源没啥关系，所以无法起到加锁的效果。而且每次都是new Object(),这样每次进入方法时，这个锁都不一样，更加不能起到任何作用。","like_count":0},{"had_liked":false,"id":81548,"user_name":"^_^","can_delete":false,"product_type":"c1","uid":1088001,"ip_address":"","ucode":"EE5DAC03CFC2EE","user_header":"https://static001.geekbang.org/account/avatar/00/10/9a/01/1489f98d.jpg","comment_is_top":false,"comment_ctime":1553940097,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553940097","product_id":100023901,"comment_content":"new Object()每次调用返回的是对象的引用，地址不一样，用在上面的代码中，就会出现两把锁锁同一个资源的问题，好比球场中同一个座位票重了","like_count":0},{"had_liked":false,"id":81054,"user_name":"Monster!","can_delete":false,"product_type":"c1","uid":1179101,"ip_address":"","ucode":"74F1D3BB5E3915","user_header":"https://static001.geekbang.org/account/avatar/00/11/fd/dd/baeda83e.jpg","comment_is_top":false,"comment_ctime":1553786455,"is_pvip":false,"replies":[{"id":"29456","content":"看不到你的源码了，应该是有并发问题了，你的期望需要正确的同步<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553833681,"ip_address":"","comment_id":81054,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553786455","product_id":100023901,"comment_content":"老师，您刚才给我回复说，两个线程还没来得及跑已经执行return语句了，但是我刚才试了下，在return前Thread.sleep(10000)然后结果不是0了，结果为一万多的随机数，还有就是我就算不用hread.sleep(10000)方法，而是用thread1.join();thread2.join()，讲道理应该是等两个线程都结束了再返回值，期望值是20000，但结果还是一万多的随机数，想不明白啊，老师求救","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445062,"discussion_content":"看不到你的源码了，应该是有并发问题了，你的期望需要正确的同步\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553833681,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79832,"user_name":"Vincent","can_delete":false,"product_type":"c1","uid":1135159,"ip_address":"","ucode":"CD8B84A57A6A0C","user_header":"https://static001.geekbang.org/account/avatar/00/11/52/37/13b4c8aa.jpg","comment_is_top":false,"comment_ctime":1553562209,"is_pvip":false,"replies":[{"id":"29100","content":"不可以，本质是竞态条件问题<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553563056,"ip_address":"","comment_id":79832,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553562209","product_id":100023901,"comment_content":"SafeCalc中get方法本质就是期望可见性，不用sync关键字用volatile关键字修饰变量可以吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444646,"discussion_content":"不可以，本质是竞态条件问题\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553563056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79684,"user_name":"Sunqc","can_delete":false,"product_type":"c1","uid":1473717,"ip_address":"","ucode":"2C54659635403F","user_header":"https://static001.geekbang.org/account/avatar/00/16/7c/b5/4a7a2bd4.jpg","comment_is_top":false,"comment_ctime":1553520546,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553520546","product_id":100023901,"comment_content":"老师总结的好啊，一针见血，很好理解","like_count":0},{"had_liked":false,"id":79184,"user_name":"乐凡","can_delete":false,"product_type":"c1","uid":1239260,"ip_address":"","ucode":"918C9997EB6537","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/dc/32e78f02.jpg","comment_is_top":false,"comment_ctime":1553396971,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553396971","product_id":100023901,"comment_content":"不能，两个方法的锁不是同一个对象。也就是不是同一把锁","like_count":0},{"had_liked":false,"id":78719,"user_name":"谢晓飞","can_delete":false,"product_type":"c1","uid":1114965,"ip_address":"","ucode":"AFC1656EC9B39D","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/55/b29961a8.jpg","comment_is_top":false,"comment_ctime":1553223787,"is_pvip":false,"replies":[{"id":"28628","content":"有些可以看汇编，有些看不到，虚拟机和cpu都会在运行时都会优化<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1553229005,"ip_address":"","comment_id":78719,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553223787","product_id":100023901,"comment_content":"老师你好，我想问下怎么看java优化后的代码","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444205,"discussion_content":"有些可以看汇编，有些看不到，虚拟机和cpu都会在运行时都会优化\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553229005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77524,"user_name":"松花皮蛋me","can_delete":false,"product_type":"c1","uid":1000054,"ip_address":"","ucode":"B0846CEEF6B0D1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/76/256bbd43.jpg","comment_is_top":false,"comment_ctime":1552959343,"is_pvip":false,"replies":[{"id":"28333","content":"正解<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552969312,"ip_address":"","comment_id":77524,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552959343","product_id":100023901,"comment_content":"逃逸分析后因为new object()其他线程永远访问不到，编译化优化成非锁了","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443760,"discussion_content":"正解\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552969312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77425,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1552922552,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1552922552","product_id":100023901,"comment_content":"不正确<br>1、每次创建的保护资源的锁都是一把新的锁，没有起到作用反而额外增加了加锁、解锁的开销<br>2、可见性没有保证，根据Happens-Before规则，get和set之间没有任何关系并且没有通过同一把锁串行化<br>3、原子性没有保证，对于value+=1操作是非原子性的，并且锁对象对于每个线程都是新的，也就是仍然会有多个线程同时执行value+=1操作<br>分析问题还是要尝试通过JMM和加锁规则来分析，用什么锁来保护什么","like_count":0},{"had_liked":false,"id":76577,"user_name":"o my love","can_delete":false,"product_type":"c1","uid":1243331,"ip_address":"","ucode":"307601ACAC5DCC","user_header":"https://static001.geekbang.org/account/avatar/00/12/f8/c3/1d557354.jpg","comment_is_top":false,"comment_ctime":1552634627,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552634627","product_id":100023901,"comment_content":"感觉好多大佬","like_count":0},{"had_liked":false,"id":76501,"user_name":"你只是看起来很努力","can_delete":false,"product_type":"c1","uid":1449173,"ip_address":"","ucode":"F9340A560D347C","user_header":"https://static001.geekbang.org/account/avatar/00/16/1c/d5/248a9c38.jpg","comment_is_top":false,"comment_ctime":1552620268,"is_pvip":false,"replies":[{"id":"27954","content":"可以用条件变量来搞定，后面有介绍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552659161,"ip_address":"","comment_id":76501,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552620268","product_id":100023901,"comment_content":"老师，我实现三个线程操作一个共享变量i，然后这个这个i做为循环条件去控制我在run()方法写的输出语句（并打印共享变量i的值），可是我这个地方i竟然可以打印到11，后来我发现是加了volatile的问题，请问除了在循环里面再加个判断还有别的方法来实现三个线程循环打印这条输出语句吗？<br>package com.cn.join;<br>&#47;**<br> * 继承Thread类实现多线程<br> * @author HP<br> *<br> *&#47;<br>public class MyThread extends Thread {<br>\tprivate volatile static int i = 0;<br>\tpublic MyThread() {<br>\t\tsuper();<br>\t}<br>\t@Override<br>\tpublic void run() {<br>\t\t&#47;&#47; TODO Auto-generated method stub<br>\t\tsuper.run();<br>\t\t&#47;*synchronized(MyThread.class){for(;i&lt;10;i++){<br>\t\t\tSystem.out.println(Thread.currentThread()+&quot;:&quot;+i);<br>\t\t}}*&#47;<br>\t\twhile(i&lt;10){<br>\t\t\tsynchronized(MyThread.class){<br>\t\t\t\tSystem.out.println(Thread.currentThread()+&quot;:&quot;+i);<br>\t\t\t\ti++;<br>\t\t\t}<br>\t\t}<br>\t}<br>\tpublic static void main(String[] args) {<br>\t\tMyThread myThread1= new MyThread();<br>\t\tMyThread myThread2= new MyThread();<br>\t\tMyThread myThread3= new MyThread();<br>\t\tmyThread1.start();<br>\t\tmyThread2.start();<br>\t\tmyThread3.start();<br>\t}<br>}<br>","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443331,"discussion_content":"可以用条件变量来搞定，后面有介绍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552659161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75630,"user_name":"何妨","can_delete":false,"product_type":"c1","uid":1385377,"ip_address":"","ucode":"EC3983BFF7992A","user_header":"https://static001.geekbang.org/account/avatar/00/15/23/a1/b08f3ee7.jpg","comment_is_top":false,"comment_ctime":1552441672,"is_pvip":false,"replies":[{"id":"27634","content":"正确<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552478888,"ip_address":"","comment_id":75630,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552441672","product_id":100023901,"comment_content":"class SafeCalc {<br>  static long value = 0L;<br>  synchronized static long get() {<br>    return value;<br>  }<br>  synchronized static void addOne() {<br>    value += 1;<br>  }<br>}<br>所以我在get方法上加static修饰这样是不是就是同一把锁了呢?(锁SafeCalc.Class),不知道这样理解是否正确","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442965,"discussion_content":"正确\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552478888,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75478,"user_name":"捞鱼的搬砖奇","can_delete":false,"product_type":"c1","uid":1021539,"ip_address":"","ucode":"2FD194C4DA26E5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/96/63/7eb32c9b.jpg","comment_is_top":false,"comment_ctime":1552402862,"is_pvip":false,"replies":[{"id":"27630","content":"没理解你的问题。互斥，不管几个cpu都只能一个线程执行<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552478345,"ip_address":"","comment_id":75478,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552402862","product_id":100023901,"comment_content":"文中说get() addOne() 俩个方法互斥，如果多核心CPU，一个运行get() 一个运行addOne()呢？ 您是指在同个核心上吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442909,"discussion_content":"没理解你的问题。互斥，不管几个cpu都只能一个线程执行\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552478345,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75305,"user_name":"龙哥","can_delete":false,"product_type":"c1","uid":1451669,"ip_address":"","ucode":"E7ED2E7DF759A1","user_header":"https://static001.geekbang.org/account/avatar/00/16/26/95/a4e0f7ab.jpg","comment_is_top":false,"comment_ctime":1552376396,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552376396","product_id":100023901,"comment_content":"共享资源是在SaftCalc内，需要对其加锁才能保证线程安全。所以这不是正确加锁","like_count":0},{"had_liked":false,"id":75281,"user_name":"Tristan","can_delete":false,"product_type":"c1","uid":1446426,"ip_address":"","ucode":"6CBB92D50C2929","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/15WXictKcv02AGs8PPBGvykHg3tYc7Xb33xs0iayGLMIYdFhlPoHe0ABw5F93yyInM9D5nDSAU7TWwROz4rTk0YA/132","comment_is_top":false,"comment_ctime":1552373012,"is_pvip":false,"replies":[{"id":"27493","content":"如果两个方法都执行在一个线程里，当然没问题。<br>如果都在主线程，那就是一个线程。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552401179,"ip_address":"","comment_id":75281,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552373012","product_id":100023901,"comment_content":"get() 方法。执行 addOne() 方法后，value 的值对 get() 方法是可见的吗？<br>疑问：可不可以根据Happens-Before的第一个规则，将get（）方法调整到addOne（）方法后面，value的值对get（）方法就可见了，这样理解是否正确？ 他们都在主线程中，属不属于在同一个线程中？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442846,"discussion_content":"如果两个方法都执行在一个线程里，当然没问题。\n如果都在主线程，那就是一个线程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552401179,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74741,"user_name":"zsh0103","can_delete":false,"product_type":"c1","uid":1326016,"ip_address":"","ucode":"3992AB4BD1A18A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epLhKkTgowm9PqUwP9k90DecpOU7HQ0IRuAp515kIonbfyqYm6ME7s2bmaPX0sSA14micZ2DAfLLibw/132","comment_is_top":false,"comment_ctime":1552290754,"is_pvip":false,"replies":[{"id":"27290","content":"是的，这种情况和没有锁是一样的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552310506,"ip_address":"","comment_id":74741,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552290754","product_id":100023901,"comment_content":"思考题中错误的使用了synchronzed，这里使用了两把锁，无法得到互拆的目的，因为new object() 为两个对，add方法的调用无法互拆get方法的调用，因此会出现读取旧值的情况。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442664,"discussion_content":"是的，这种情况和没有锁是一样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552310506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74305,"user_name":"the only Mia’s","can_delete":false,"product_type":"c1","uid":1271075,"ip_address":"","ucode":"8E2E1E71BF5B4F","user_header":"https://static001.geekbang.org/account/avatar/00/13/65/23/b42f102c.jpg","comment_is_top":false,"comment_ctime":1552185312,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552185312","product_id":100023901,"comment_content":"通过学习，明白了关于锁机制中很重要的一点是弄明白加锁的对象到底是什么，锁住的是同一个对象才会出现互斥的说法；","like_count":0},{"had_liked":false,"id":73939,"user_name":"suynan","can_delete":false,"product_type":"c1","uid":1023214,"ip_address":"","ucode":"0AAD1BA9D22D2C","user_header":"","comment_is_top":false,"comment_ctime":1552039069,"is_pvip":false,"replies":[{"id":"26973","content":"这个一言难尽，推荐你看 java并发编程的艺术吧，里面有详细介绍<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552047003,"ip_address":"","comment_id":73939,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552039069","product_id":100023901,"comment_content":"一直有个疑问，synchronized保证了只能有一个线程能进入临界区，这是结论。<br>但是在进入临界区前的竞争是怎么处理的？极端一点，假如2个线程AB在完全相同的时刻去竞争，那么会不会同时跨过那道门槛进入临界区？我们知道的结果是不能，只能有一个能进入，但是保证的手段是什么呢？unsafe?AQS?希望老师指点一下","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442349,"discussion_content":"这个一言难尽，推荐你看 java并发编程的艺术吧，里面有详细介绍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552047003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73921,"user_name":"秋天","can_delete":false,"product_type":"c1","uid":1057056,"ip_address":"","ucode":"A7E1D953EF7E17","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/20/1299e137.jpg","comment_is_top":false,"comment_ctime":1552034072,"is_pvip":true,"replies":[{"id":"27011","content":"正确","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552059085,"ip_address":"","comment_id":73921,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552034072","product_id":100023901,"comment_content":"每次枷锁进来都是一个新的对象，加锁和解锁面对的不是同一个对象，所以对于可见性和原子性问题没有保障作用","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442338,"discussion_content":"正确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552059085,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73903,"user_name":"小公司都不给我进就赖门口哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈","can_delete":false,"product_type":"c1","uid":1125985,"ip_address":"","ucode":"10C8AF52F68A29","user_header":"https://static001.geekbang.org/account/avatar/00/11/2e/61/72a083ea.jpg","comment_is_top":false,"comment_ctime":1552028832,"is_pvip":false,"replies":[{"id":"27000","content":"我也这样觉得","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552058128,"ip_address":"","comment_id":73903,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552028832","product_id":100023901,"comment_content":"感觉评论区的大神很多鸭","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442329,"discussion_content":"我也这样觉得","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552058128,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73888,"user_name":"Nevermore","can_delete":false,"product_type":"c1","uid":1228011,"ip_address":"","ucode":"06EBD2E6A9B436","user_header":"https://static001.geekbang.org/account/avatar/00/12/bc/eb/c22ef3a5.jpg","comment_is_top":false,"comment_ctime":1552025783,"is_pvip":false,"replies":[{"id":"26999","content":"理论高手","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552058109,"ip_address":"","comment_id":73888,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552025783","product_id":100023901,"comment_content":"针对同一个资源，必须使用同一把锁，才能实现原子性和可见性，即保证并发正确性。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442325,"discussion_content":"理论高手","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552058109,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73756,"user_name":"空知","can_delete":false,"product_type":"c1","uid":1013283,"ip_address":"","ucode":"C448E98238DD36","user_header":"https://static001.geekbang.org/account/avatar/00/0f/76/23/31e5e984.jpg","comment_is_top":false,"comment_ctime":1551970479,"is_pvip":false,"replies":[{"id":"26957","content":"你这么理解也可以，工程上很多概念都不是那么清晰，解决原子性需要用到hb原则<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1552018864,"ip_address":"","comment_id":73756,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551970479","product_id":100023901,"comment_content":"老师 Java内存模型包括synchronized关键字 不是说明Javanese内存模型可以解决原子性问题嘛？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442263,"discussion_content":"你这么理解也可以，工程上很多概念都不是那么清晰，解决原子性需要用到hb原则\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552018864,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73452,"user_name":"鲁班大师","can_delete":false,"product_type":"c1","uid":1179156,"ip_address":"","ucode":"4F9615DF87B031","user_header":"https://static001.geekbang.org/account/avatar/00/11/fe/14/f1532dec.jpg","comment_is_top":false,"comment_ctime":1551886660,"is_pvip":false,"replies":[{"id":"26864","content":"那就是执行完了，正常退出了<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551957890,"ip_address":"","comment_id":73452,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551886660","product_id":100023901,"comment_content":"我用visualvm监控consumer线程栈，过一会两个consumer线程栈就消失了","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442094,"discussion_content":"那就是执行完了，正常退出了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551957890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73446,"user_name":"HYH®侯博元","can_delete":false,"product_type":"c1","uid":1441938,"ip_address":"","ucode":"536D5CC3F9D20A","user_header":"https://static001.geekbang.org/account/avatar/00/16/00/92/0d378734.jpg","comment_is_top":false,"comment_ctime":1551885330,"is_pvip":false,"replies":[{"id":"26912","content":"重新看看第一期吧","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551964608,"ip_address":"","comment_id":73446,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551885330","product_id":100023901,"comment_content":"为什么双重判断的单例模式加了sncy还会有线程问题，而这期的案例加了sncy就不会有线程问题","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442091,"discussion_content":"重新看看第一期吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551964608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73388,"user_name":"aguan(^･ｪ･^)","can_delete":false,"product_type":"c1","uid":1107177,"ip_address":"","ucode":"04833EF2D18E1A","user_header":"https://static001.geekbang.org/account/avatar/00/10/e4/e9/0dd3829f.jpg","comment_is_top":false,"comment_ctime":1551875636,"is_pvip":false,"replies":[{"id":"26727","content":"中规中矩","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551882312,"ip_address":"","comment_id":73388,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551875636","product_id":100023901,"comment_content":"思考题<br>不能解决可见性和原子性的问题，因为每次加锁时都new object，都是不同的对象，也就相当于每次请求都是不同的锁🔒，违背了文中说的锁跟资源的1对N关系。锁和资源的关系变成了N对1的关系","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442058,"discussion_content":"中规中矩","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551882312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73369,"user_name":"wilburJiang","can_delete":false,"product_type":"c1","uid":1107836,"ip_address":"","ucode":"F83D474D692C06","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI5uDOruARAmFZr49ic2nib3ibj1TSBUKydMH2H3XHUniaR0FHeNVkOI9dfndxtJIOOrY2w5nhrHjX3UQ/132","comment_is_top":false,"comment_ctime":1551872292,"is_pvip":true,"replies":[{"id":"26712","content":"我是从操作系统里知道的，一定比java早<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551880916,"ip_address":"","comment_id":73369,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1551872292","product_id":100023901,"comment_content":"请问老师，临界区这个概念是来自操作系统吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442047,"discussion_content":"我是从操作系统里知道的，一定比java早\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551880916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73341,"user_name":"Michelle","can_delete":false,"product_type":"c1","uid":1224367,"ip_address":"","ucode":"82B82C067F98F3","user_header":"https://static001.geekbang.org/account/avatar/00/12/ae/af/985298a8.jpg","comment_is_top":false,"comment_ctime":1551863399,"is_pvip":false,"replies":[{"id":"26724","content":"是的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551882186,"ip_address":"","comment_id":73341,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551863399","product_id":100023901,"comment_content":"應該在一開始先new object<br>Sychronized才不會一直new新的出來","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442031,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551882186,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73282,"user_name":"Demter","can_delete":false,"product_type":"c1","uid":1158439,"ip_address":"","ucode":"BE3B6F726916CE","user_header":"https://static001.geekbang.org/account/avatar/00/11/ad/27/5556ae50.jpg","comment_is_top":false,"comment_ctime":1551850585,"is_pvip":false,"replies":[{"id":"26705","content":"有序性和可见性是一起解决的<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551880557,"ip_address":"","comment_id":73282,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551850585","product_id":100023901,"comment_content":"可见性和原子性都保证了，可是有序性为啥没有分析呢","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442002,"discussion_content":"有序性和可见性是一起解决的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551880557,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73279,"user_name":"轻歌赋","can_delete":false,"product_type":"c1","uid":1251574,"ip_address":"","ucode":"22F62446208805","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/f6/2ff7bc7a.jpg","comment_is_top":false,"comment_ctime":1551848778,"is_pvip":false,"replies":[{"id":"26722","content":"每次调用的锁都不是一个","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551882045,"ip_address":"","comment_id":73279,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551848778","product_id":100023901,"comment_content":"锁不住的，锁对象不是同一个","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442000,"discussion_content":"每次调用的锁都不是一个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551882045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73246,"user_name":"鲁班大师","can_delete":false,"product_type":"c1","uid":1179156,"ip_address":"","ucode":"4F9615DF87B031","user_header":"https://static001.geekbang.org/account/avatar/00/11/fe/14/f1532dec.jpg","comment_is_top":false,"comment_ctime":1551843992,"is_pvip":false,"replies":[{"id":"26731","content":"挂掉是什么意思？锁竞争一定不会导致线程被kill","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551882661,"ip_address":"","comment_id":73246,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551843992","product_id":100023901,"comment_content":"锁竞争会导致线程被kill吗？三个consumer线程，一个producer线程，运行一段时间后，有两个consumer线程挂掉了<br><br>public class Producer extends Thread {<br><br>    List&lt;Message&gt; msgList = new ArrayList&lt;&gt;();<br><br>    public Producer(){<br>        super(&quot;Producer1&quot;);<br>    }<br><br>    @Override public void run() {<br>        try {<br>            while (true) {<br>                Thread.sleep(3);<br>                Message msg = new Message();<br>                synchronized(msgList) {<br>                    msgList.add(msg);<br>                    msgList.notify(); &#47;&#47;这里只能是notify而不能是notifyAll，否则remove(0)会报java.lang.IndexOutOfBoundsException: Index: 0, Size: 0<br>                }<br>            }<br>        } catch (Exception e) {<br>            e.printStackTrace();<br>        }<br>    }<br><br>    public Message waitMsg() {<br>        synchronized(msgList) {<br>            if(msgList.size() == 0) {<br>                try {<br>                    msgList.wait();<br>                } catch(InterruptedException e) {<br>                    e.printStackTrace();<br>                }<br>            }<br>            return msgList.remove(0);<br>        }<br>    }<br>}","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441987,"discussion_content":"挂掉是什么意思？锁竞争一定不会导致线程被kill","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551882661,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73136,"user_name":"谢特","can_delete":false,"product_type":"c1","uid":1248684,"ip_address":"","ucode":"9C30DBFECFE649","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/ac/09678490.jpg","comment_is_top":false,"comment_ctime":1551830555,"is_pvip":false,"replies":[{"id":"26589","content":"cpu不响应中断信号<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551834118,"ip_address":"","comment_id":73136,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551830555","product_id":100023901,"comment_content":"禁止cpu中断什么意思","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441931,"discussion_content":"cpu不响应中断信号\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551834118,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73082,"user_name":"jmdxy","can_delete":false,"product_type":"c1","uid":1189626,"ip_address":"","ucode":"445505E9C52BBB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epHS3pkexn0ibNg8kWxywRVavX7UIBBZ4kwhcmNYccvrLaP4fe0wcuHx550fTmzQwEAnoq3Rgw61RQ/132","comment_is_top":false,"comment_ctime":1551793681,"is_pvip":false,"replies":[{"id":"26508","content":"对，就是为了互斥","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551797117,"ip_address":"","comment_id":73082,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551793681","product_id":100023901,"comment_content":"get方法加锁是为了确保读取long类型数据的时候 ，没有其他线程修改long类型数据的操作。 老师这样理解对吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441903,"discussion_content":"对，就是为了互斥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551797117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73081,"user_name":"小和尚笨南北","can_delete":false,"product_type":"c1","uid":1204628,"ip_address":"","ucode":"17C9BBB6DD25D2","user_header":"https://static001.geekbang.org/account/avatar/00/12/61/94/713b38ef.jpg","comment_is_top":false,"comment_ctime":1551793670,"is_pvip":false,"replies":[{"id":"26507","content":"生动","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551797085,"ip_address":"","comment_id":73081,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551793670","product_id":100023901,"comment_content":"这个相当于给门上加了一把锁，但是所有的钥匙都可以打开，也就等于没加锁。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441902,"discussion_content":"生动","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551797085,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73072,"user_name":"melon残剑","can_delete":false,"product_type":"c1","uid":1446459,"ip_address":"","ucode":"2A2831865ADF54","user_header":"https://static001.geekbang.org/account/avatar/00/16/12/3b/ea4f1c5d.jpg","comment_is_top":false,"comment_ctime":1551791170,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551791170","product_id":100023901,"comment_content":"getOne和addOne每次加锁在不同资源上，因为new,所以加锁不在同一个对象上，并没有形成互斥。","like_count":0},{"had_liked":false,"id":73070,"user_name":"常银玲","can_delete":false,"product_type":"c1","uid":1252109,"ip_address":"","ucode":"894A34D9AD8942","user_header":"https://static001.geekbang.org/account/avatar/00/13/1b/0d/9c3e2241.jpg","comment_is_top":false,"comment_ctime":1551790078,"is_pvip":false,"replies":[{"id":"26505","content":"没思考过，我觉得锁，本来就该是个对象","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551797034,"ip_address":"","comment_id":73070,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551790078","product_id":100023901,"comment_content":"老师您好，最后总结中说，锁一定要有一个锁定的对象，当new object的时候，就换了一个上锁的对象，锁住的不是同一个资源，所以没有办法保证资源的同步。其实应该去思考：为什么synchronized锁的是一个对象，而不是一个类，是不是和Java本身的设计有什么关系？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441897,"discussion_content":"没思考过，我觉得锁，本来就该是个对象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551797034,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73067,"user_name":"zhaozp","can_delete":false,"product_type":"c1","uid":1099706,"ip_address":"","ucode":"BF390F5ED762CD","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/ba/4c449be2.jpg","comment_is_top":false,"comment_ctime":1551789343,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551789343","product_id":100023901,"comment_content":"new 创建了不同的对象","like_count":0},{"had_liked":false,"id":73044,"user_name":"忠艾一生","can_delete":false,"product_type":"c1","uid":1445386,"ip_address":"","ucode":"DE8DF66F379054","user_header":"https://static001.geekbang.org/account/avatar/00/16/0e/0a/1564a5e1.jpg","comment_is_top":false,"comment_ctime":1551783609,"is_pvip":false,"replies":[{"id":"26509","content":"是很多锁","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551797143,"ip_address":"","comment_id":73044,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551783609","product_id":100023901,"comment_content":"这样并不能解决并发问题，相当于两把不同的锁来保护同一个资源了。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441889,"discussion_content":"是很多锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551797143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73006,"user_name":"Geek_ed5c7b","can_delete":false,"product_type":"c1","uid":1094805,"ip_address":"","ucode":"F60D2D502E5C1E","user_header":"https://static001.geekbang.org/account/avatar/00/10/b4/95/433d47eb.jpg","comment_is_top":false,"comment_ctime":1551775317,"is_pvip":false,"replies":[{"id":"26513","content":"volatile规则是说 写》读。其他的不保证。写完后读一定能读到。但是你同时读，谁也搞不定。这个要靠互斥搞定。<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551797679,"ip_address":"","comment_id":73006,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551775317","product_id":100023901,"comment_content":"关于可见性有点疑问，希望老师可以解答下。<br>在多核CPU中，例如两个线程同时将一个变量读入主存（volatile a=3）。当一个线程将a修改成4了，但是还没有来得急将其刷新至内存。这样对于另外一个线程来说这个a是不可见的吧？是不是哪怕用volatile修饰了变量也无法保证100%可见？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441873,"discussion_content":"volatile规则是说 写》读。其他的不保证。写完后读一定能读到。但是你同时读，谁也搞不定。这个要靠互斥搞定。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551797679,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73002,"user_name":"李可威","can_delete":false,"product_type":"c1","uid":1440757,"ip_address":"","ucode":"7BB0B44076A4F4","user_header":"https://static001.geekbang.org/account/avatar/00/15/fb/f5/6521cb02.jpg","comment_is_top":false,"comment_ctime":1551774802,"is_pvip":false,"replies":[{"id":"26502","content":"别急","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551796762,"ip_address":"","comment_id":73002,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1551774802","product_id":100023901,"comment_content":"大佬们Lock锁和synchronized有什么区别？另外可重入锁、可中断锁、公平锁都是什么意思","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441871,"discussion_content":"别急","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551796762,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1235692,"avatar":"https://static001.geekbang.org/account/avatar/00/12/da/ec/779c1a78.jpg","nickname":"往事随风，顺其自然","note":"","ucode":"F266EC6B143E38","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3030,"discussion_content":"一个是类锁，api的，一个是jdk内置的锁，一个可以自己控制超时时间，一个不能自己控制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564122098,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72995,"user_name":"龙猫","can_delete":false,"product_type":"c1","uid":1112490,"ip_address":"","ucode":"FD726CC969EF9C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/aa/3e80212e.jpg","comment_is_top":false,"comment_ctime":1551773203,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551773203","product_id":100023901,"comment_content":"不可以，不是互斥锁","like_count":0},{"had_liked":false,"id":72989,"user_name":"Junzi","can_delete":false,"product_type":"c1","uid":1004612,"ip_address":"","ucode":"4AC663769C1873","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/44/4e541a86.jpg","comment_is_top":false,"comment_ctime":1551771636,"is_pvip":false,"replies":[{"id":"26501","content":"YES","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551796731,"ip_address":"","comment_id":72989,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551771636","product_id":100023901,"comment_content":"new Object()使每次线程访问该对象方法都会生成一个新的锁，即每次的锁都不一样，不能保证原子性和可见性","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441864,"discussion_content":"YES","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551796731,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72983,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1551770200,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551770200","product_id":100023901,"comment_content":"很有收获，相同的锁才互斥，并不是随意加一个锁就行了。","like_count":0},{"had_liked":false,"id":72957,"user_name":"冰激凌的眼泪","can_delete":false,"product_type":"c1","uid":1087945,"ip_address":"","ucode":"5DCB974667E93A","user_header":"https://static001.geekbang.org/account/avatar/00/10/99/c9/a7c77746.jpg","comment_is_top":false,"comment_ctime":1551762241,"is_pvip":false,"replies":[{"id":"26496","content":"后面的章节还真问到这个问题了","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551795539,"ip_address":"","comment_id":72957,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551762241","product_id":100023901,"comment_content":"锁value是否有效果？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441846,"discussion_content":"后面的章节还真问到这个问题了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551795539,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72951,"user_name":"空空空空","can_delete":false,"product_type":"c1","uid":1082938,"ip_address":"","ucode":"A1A50E16E02803","user_header":"https://static001.geekbang.org/account/avatar/00/10/86/3a/76dbbd0e.jpg","comment_is_top":false,"comment_ctime":1551758563,"is_pvip":false,"replies":[{"id":"26495","content":"正确。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551795448,"ip_address":"","comment_id":72951,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551758563","product_id":100023901,"comment_content":"回答问题： 我觉得这样解决不了并发问题。该题目中每次锁的对象都是new出来的不同的对象，相当于每个线程获得的锁都是不一样的，并不会互斥。老师这样理解正确吗","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441843,"discussion_content":"正确。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551795448,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72946,"user_name":"CatTalk","can_delete":false,"product_type":"c1","uid":1057350,"ip_address":"","ucode":"353780AF4848D9","user_header":"https://static001.geekbang.org/account/avatar/00/10/22/46/df595e4a.jpg","comment_is_top":false,"comment_ctime":1551758013,"is_pvip":true,"replies":[{"id":"26493","content":"正确","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551795103,"ip_address":"","comment_id":72946,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551758013","product_id":100023901,"comment_content":"每个线程每次执行这两个方法时，每次都是对不同的对象（每次重新new）加锁（对象头中写入锁状态），并没有形成互斥锁。这样其实每次调用不同线程均可进入，无法保证可见性和原子性。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441840,"discussion_content":"正确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551795103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72924,"user_name":"影子传说","can_delete":false,"product_type":"c1","uid":1031636,"ip_address":"","ucode":"371B72BB5CCB5E","user_header":"","comment_is_top":false,"comment_ctime":1551755500,"is_pvip":false,"replies":[{"id":"26491","content":"不可以。<br>两个线程可以同时读到同一个值（这个违背任何HB），然后同时+=1，写入内存（这个违背任何HB）。结果是少加了一个1","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551794991,"ip_address":"","comment_id":72924,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551755500","product_id":100023901,"comment_content":"老师上面用java内置锁保证count++操作能用volatile代替吗？volatile可以保证多线程可见，在结合happen before规则似乎也可以的。请老师指导下","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441830,"discussion_content":"不可以。\n两个线程可以同时读到同一个值（这个违背任何HB），然后同时+=1，写入内存（这个违背任何HB）。结果是少加了一个1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551794991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72859,"user_name":"TaroYoVen","can_delete":false,"product_type":"c1","uid":1298166,"ip_address":"","ucode":"8419D0943A5098","user_header":"https://static001.geekbang.org/account/avatar/00/13/ce/f6/49bff405.jpg","comment_is_top":false,"comment_ctime":1551748146,"is_pvip":true,"replies":[{"id":"26480","content":"而且每次调用都不同","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551794242,"ip_address":"","comment_id":72859,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551748146","product_id":100023901,"comment_content":"不同锁，所以并没有互斥","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441793,"discussion_content":"而且每次调用都不同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551794242,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72858,"user_name":"王智","can_delete":false,"product_type":"c1","uid":1079657,"ip_address":"","ucode":"0335277F255F7A","user_header":"https://static001.geekbang.org/account/avatar/00/10/79/69/5960a2af.jpg","comment_is_top":false,"comment_ctime":1551748106,"is_pvip":false,"replies":[{"id":"26457","content":"正确<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551788223,"ip_address":"","comment_id":72858,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551748106","product_id":100023901,"comment_content":"不能，可以new一个object当做成员变量，应该就可以了。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441792,"discussion_content":"正确\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551788223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72850,"user_name":" JJ","can_delete":false,"product_type":"c1","uid":1250967,"ip_address":"","ucode":"45EC52EFFC49FB","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/97/9e342700.jpg","comment_is_top":false,"comment_ctime":1551747607,"is_pvip":false,"replies":[{"id":"26479","content":"你比我说的还抽象","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551794221,"ip_address":"","comment_id":72850,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551747607","product_id":100023901,"comment_content":"老师，受保护资源和锁的关系是1:N吧","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441786,"discussion_content":"你比我说的还抽象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551794221,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72849,"user_name":"新世界","can_delete":false,"product_type":"c1","uid":1079495,"ip_address":"","ucode":"4473DC1505F158","user_header":"https://static001.geekbang.org/account/avatar/00/10/78/c7/083a3a0b.jpg","comment_is_top":false,"comment_ctime":1551747568,"is_pvip":false,"replies":[{"id":"26478","content":"你可以这样理解。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551794131,"ip_address":"","comment_id":72849,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551747568","product_id":100023901,"comment_content":"对于get方法不加synchronized关键字会出现并发问题的场景，可以这样理解吗？CPU a加锁设置count值为1，同时从寄存器同步值1到主存，CPU b这时候执行get方法没有加同一把锁，不会从主存拿最新值更新到CPU b的寄存器，当CPU b执行get方法时，依然获取的时之前cpu b寄存器的值，不是主存中更新的最新值，可以这样理解吗？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441785,"discussion_content":"你可以这样理解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551794131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72829,"user_name":"Solitary_J","can_delete":false,"product_type":"c1","uid":1442034,"ip_address":"","ucode":"E1E0AE4A6231BF","user_header":"https://static001.geekbang.org/account/avatar/00/16/00/f2/66a1461d.jpg","comment_is_top":false,"comment_ctime":1551745980,"is_pvip":false,"replies":[{"id":"26473","content":"不仅仅是不可见","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551793495,"ip_address":"","comment_id":72829,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551745980","product_id":100023901,"comment_content":"两把锁不可见性","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441772,"discussion_content":"不仅仅是不可见","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551793495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72813,"user_name":"无庸","can_delete":false,"product_type":"c1","uid":1120675,"ip_address":"","ucode":"9F61D1BF0FB4BF","user_header":"https://static001.geekbang.org/account/avatar/00/11/19/a3/600bc13d.jpg","comment_is_top":false,"comment_ctime":1551743139,"is_pvip":true,"replies":[{"id":"26471","content":"可见。不保证原子性","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551793371,"ip_address":"","comment_id":72813,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551743139","product_id":100023901,"comment_content":"这个例子value 加 volatile 修饰之后。根据happen before 原则写之后，读也是可见的吧","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441766,"discussion_content":"可见。不保证原子性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551793371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72809,"user_name":"... ...","can_delete":false,"product_type":"c1","uid":1312354,"ip_address":"","ucode":"E214CAA6349A60","user_header":"https://static001.geekbang.org/account/avatar/00/14/06/62/898449d3.jpg","comment_is_top":false,"comment_ctime":1551742340,"is_pvip":false,"replies":[{"id":"26464","content":"原子性也有问题，因为相当于无锁","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551788599,"ip_address":"","comment_id":72809,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551742340","product_id":100023901,"comment_content":"加加操作原子性没问题！可见性没有&#39;","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441762,"discussion_content":"原子性也有问题，因为相当于无锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551788599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72806,"user_name":"Thomas","can_delete":false,"product_type":"c1","uid":1114851,"ip_address":"","ucode":"39FB49141AD03C","user_header":"https://static001.geekbang.org/account/avatar/00/11/02/e3/2a624978.jpg","comment_is_top":false,"comment_ctime":1551741645,"is_pvip":false,"replies":[{"id":"26470","content":"不仅仅不同","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551793295,"ip_address":"","comment_id":72806,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551741645","product_id":100023901,"comment_content":"加锁的对象不同","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441760,"discussion_content":"不仅仅不同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551793295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72799,"user_name":"Alan","can_delete":false,"product_type":"c1","uid":1198125,"ip_address":"","ucode":"9C66CBCFB3A109","user_header":"https://static001.geekbang.org/account/avatar/00/12/48/2d/7a3d42fb.jpg","comment_is_top":false,"comment_ctime":1551731442,"is_pvip":false,"replies":[{"id":"26451","content":"👍厉害<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551787522,"ip_address":"","comment_id":72799,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551731442","product_id":100023901,"comment_content":"首先回答下课后问题哈，使用方式是不正确的，每次都锁资源都是不一样的，导致等于没加锁，不能保证可见性。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441753,"discussion_content":"👍厉害\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551787522,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72797,"user_name":"Nevermore","can_delete":false,"product_type":"c1","uid":1228011,"ip_address":"","ucode":"06EBD2E6A9B436","user_header":"https://static001.geekbang.org/account/avatar/00/12/bc/eb/c22ef3a5.jpg","comment_is_top":false,"comment_ctime":1551725625,"is_pvip":false,"replies":[{"id":"26462","content":"每次调用都创建了新的，相当于无锁，编译器会优化掉同步关键字<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551788469,"ip_address":"","comment_id":72797,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551725625","product_id":100023901,"comment_content":"一个资源，使用了两把锁。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441752,"discussion_content":"每次调用都创建了新的，相当于无锁，编译器会优化掉同步关键字\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551788469,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72796,"user_name":"狂战俄洛伊","can_delete":false,"product_type":"c1","uid":1213269,"ip_address":"","ucode":"F6EACA321E6180","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJUzv6S9wroydkGP6m3OsQ8QuI4jAibv21tNkm7KVGPffJibj8Y29yIdKl4qkDGd3iaGJCSGVarfxoibQ/132","comment_is_top":false,"comment_ctime":1551721412,"is_pvip":false,"replies":[{"id":"26461","content":"👍<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551788397,"ip_address":"","comment_id":72796,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551721412","product_id":100023901,"comment_content":"嗯，有问题，两把锁锁的资源不一样，这两把锁并不是互斥的，所以存在并发问题😁","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441751,"discussion_content":"👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551788397,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72795,"user_name":"小小小丶盘子","can_delete":false,"product_type":"c1","uid":1308056,"ip_address":"","ucode":"FCD4520F1EF872","user_header":"https://static001.geekbang.org/account/avatar/00/13/f5/98/45374bb9.jpg","comment_is_top":false,"comment_ctime":1551719537,"is_pvip":true,"replies":[{"id":"26455","content":"是这样，没有任何互斥作用<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551787976,"ip_address":"","comment_id":72795,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551719537","product_id":100023901,"comment_content":"思考题中，每次访问都会加锁，但是每次锁不同(new object），老师在文中提到，一把锁可以对应N个资源，现在是多把锁对应一个资源，并不能起到互斥作用，加1操作并不是原子性。同时由于不是一把锁，可见性也无法实现。不符合Happen before 原则。我的个人理解，请老师批评指正。😄","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441750,"discussion_content":"是这样，没有任何互斥作用\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551787976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72794,"user_name":"笨拙的自由","can_delete":false,"product_type":"c1","uid":1309452,"ip_address":"","ucode":"BEDD613DEDD8ED","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLRwauvbuyKfib8Qm3NBNU908zhKS0WPnvTEN4EJYSJyKwMuSHTWgXqP5WrSexgQAhLSiblydA24EMg/132","comment_is_top":false,"comment_ctime":1551719298,"is_pvip":false,"replies":[{"id":"26460","content":"👍<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551788382,"ip_address":"","comment_id":72794,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551719298","product_id":100023901,"comment_content":"不正确，两个方法不是竞争同一把锁，对资源起不了保护作用","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441749,"discussion_content":"👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551788382,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72787,"user_name":"shen","can_delete":false,"product_type":"c1","uid":1215066,"ip_address":"","ucode":"AE5737B0C7DC4F","user_header":"https://static001.geekbang.org/account/avatar/00/12/8a/5a/b67a82e3.jpg","comment_is_top":false,"comment_ctime":1551716907,"is_pvip":false,"replies":[{"id":"26450","content":"👍厉害<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1551787452,"ip_address":"","comment_id":72787,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551716907","product_id":100023901,"comment_content":"题目中new Object() jvm会自动优化点的，所以他是无效的，可以声明一个成员变量Object lock=new Object()，使用lock这个锁","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441744,"discussion_content":"👍厉害\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551787452,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}