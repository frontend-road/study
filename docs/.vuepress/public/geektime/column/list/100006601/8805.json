{"id":8805,"title":"19 | 单服务器高性能模式：Reactor与Proactor","content":"<p><a href=\"http://time.geekbang.org/column/article/8697\">专栏上一期</a>我介绍了单服务器高性能的PPC和TPC模式，它们的优点是实现简单，缺点是都无法支撑高并发的场景，尤其是互联网发展到现在，各种海量用户业务的出现，PPC和TPC完全无能为力。今天我将介绍可以应对高并发场景的<span class=\"orange\">单服务器高性能架构模式：Reactor和Proactor。</span></p>\n<h2>Reactor</h2>\n<p>PPC模式最主要的问题就是每个连接都要创建进程（为了描述简洁，这里只以PPC和进程为例，实际上换成TPC和线程，原理是一样的），连接结束后进程就销毁了，这样做其实是很大的浪费。为了解决这个问题，一个自然而然的想法就是资源复用，即不再单独为每个连接创建进程，而是创建一个进程池，将连接分配给进程，一个进程可以处理多个连接的业务。</p>\n<p>引入资源池的处理方式后，会引出一个新的问题：进程如何才能高效地处理多个连接的业务？当一个连接一个进程时，进程可以采用“read -&gt; 业务处理 -&gt; write”的处理流程，如果当前连接没有数据可以读，则进程就阻塞在read操作上。这种阻塞的方式在一个连接一个进程的场景下没有问题，但如果一个进程处理多个连接，进程阻塞在某个连接的read操作上，此时即使其他连接有数据可读，进程也无法去处理，很显然这样是无法做到高性能的。</p>\n<p>解决这个问题的最简单的方式是将read操作改为非阻塞，然后进程不断地轮询多个连接。这种方式能够解决阻塞的问题，但解决的方式并不优雅。首先，轮询是要消耗CPU的；其次，如果一个进程处理几千上万的连接，则轮询的效率是很低的。</p>\n<p>为了能够更好地解决上述问题，很容易可以想到，只有当连接上有数据的时候进程才去处理，这就是I/O多路复用技术的来源。</p>\n<p>I/O多路复用技术归纳起来有两个关键实现点：</p>\n<!-- [[[read_end]]] -->\n<ul>\n<li>\n<p>当多条连接共用一个阻塞对象后，进程只需要在一个阻塞对象上等待，而无须再轮询所有连接，常见的实现方式有select、epoll、kqueue等。</p>\n</li>\n<li>\n<p>当某条连接有新的数据可以处理时，操作系统会通知进程，进程从阻塞状态返回，开始进行业务处理。</p>\n</li>\n</ul>\n<p>I/O多路复用结合线程池，完美地解决了PPC和TPC的问题，而且“大神们”给它取了一个很牛的名字：Reactor，中文是“反应堆”。联想到“核反应堆”，听起来就很吓人，实际上这里的“反应”不是聚变、裂变反应的意思，而是“<strong>事件反应</strong>”的意思，可以通俗地理解为“<strong>来了一个事件我就有相应的反应</strong>”，这里的“我”就是Reactor，具体的反应就是我们写的代码，Reactor会根据事件类型来调用相应的代码进行处理。Reactor模式也叫Dispatcher模式（在很多开源的系统里面会看到这个名称的类，其实就是实现Reactor模式的），更加贴近模式本身的含义，即I/O多路复用统一监听事件，收到事件后分配（Dispatch）给某个进程。</p>\n<p>Reactor模式的核心组成部分包括Reactor和处理资源池（进程池或线程池），其中Reactor负责监听和分配事件，处理资源池负责处理事件。初看Reactor的实现是比较简单的，但实际上结合不同的业务场景，Reactor模式的具体实现方案灵活多变，主要体现在：</p>\n<ul>\n<li>\n<p>Reactor的数量可以变化：可以是一个Reactor，也可以是多个Reactor。</p>\n</li>\n<li>\n<p>资源池的数量可以变化：以进程为例，可以是单个进程，也可以是多个进程（线程类似）。</p>\n</li>\n</ul>\n<p>将上面两个因素排列组合一下，理论上可以有4种选择，但由于“多Reactor单进程”实现方案相比“单Reactor单进程”方案，既复杂又没有性能优势，因此“多Reactor单进程”方案仅仅是一个理论上的方案，实际没有应用。</p>\n<p>最终Reactor模式有这三种典型的实现方案：</p>\n<ul>\n<li>\n<p>单Reactor单进程/线程。</p>\n</li>\n<li>\n<p>单Reactor多线程。</p>\n</li>\n<li>\n<p>多Reactor多进程/线程。</p>\n</li>\n</ul>\n<p>以上方案具体选择进程还是线程，更多地是和编程语言及平台相关。例如，Java语言一般使用线程（例如，Netty），C语言使用进程和线程都可以。例如，Nginx使用进程，Memcache使用线程。</p>\n<p>1.单Reactor单进程/线程</p>\n<p>单Reactor单进程/线程的方案示意图如下（以进程为例）：</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/c2/c0/c2fafab3yybd83e97027b3e3f987f9c0.jpg?wh=3789*2184\" alt=\"\" /></p>\n<p>注意，select、accept、read、send是标准的网络编程API，dispatch和“业务处理”是需要完成的操作，其他方案示意图类似。</p>\n<p>详细说明一下这个方案：</p>\n<ul>\n<li>\n<p>Reactor对象通过select监控连接事件，收到事件后通过dispatch进行分发。</p>\n</li>\n<li>\n<p>如果是连接建立的事件，则由Acceptor处理，Acceptor通过accept接受连接，并创建一个Handler来处理连接后续的各种事件。</p>\n</li>\n<li>\n<p>如果不是连接建立事件，则Reactor会调用连接对应的Handler（第2步中创建的Handler）来进行响应。</p>\n</li>\n<li>\n<p>Handler会完成read-&gt;业务处理-&gt;send的完整业务流程。</p>\n</li>\n</ul>\n<p>单Reactor单进程的模式优点就是很简单，没有进程间通信，没有进程竞争，全部都在同一个进程内完成。但其缺点也是非常明显，具体表现有：</p>\n<ul>\n<li>\n<p>只有一个进程，无法发挥多核CPU的性能；只能采取部署多个系统来利用多核CPU，但这样会带来运维复杂度，本来只要维护一个系统，用这种方式需要在一台机器上维护多套系统。</p>\n</li>\n<li>\n<p>Handler在处理某个连接上的业务时，整个进程无法处理其他连接的事件，很容易导致性能瓶颈。</p>\n</li>\n</ul>\n<p>因此，单Reactor单进程的方案在实践中应用场景不多，<strong>只适用于业务处理非常快速的场景</strong>，目前比较著名的开源软件中使用单Reactor单进程的是Redis。</p>\n<p>需要注意的是，C语言编写系统的一般使用单Reactor单进程，因为没有必要在进程中再创建线程；而Java语言编写的一般使用单Reactor单线程，因为Java虚拟机是一个进程，虚拟机中有很多线程，业务线程只是其中的一个线程而已。</p>\n<p>2.单Reactor多线程</p>\n<p>为了克服单Reactor单进程/线程方案的缺点，引入多进程/多线程是显而易见的，这就产生了第2个方案：单Reactor多线程。</p>\n<p>单Reactor多线程方案示意图是：</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/73/da/73a2d97c63c143a01b2e671942024fda.jpg?wh=4946*1993\" alt=\"\" /></p>\n<p>我来介绍一下这个方案：</p>\n<ul>\n<li>\n<p>主线程中，Reactor对象通过select监控连接事件，收到事件后通过dispatch进行分发。</p>\n</li>\n<li>\n<p>如果是连接建立的事件，则由Acceptor处理，Acceptor通过accept接受连接，并创建一个Handler来处理连接后续的各种事件。</p>\n</li>\n<li>\n<p>如果不是连接建立事件，则Reactor会调用连接对应的Handler（第2步中创建的Handler）来进行响应。</p>\n</li>\n<li>\n<p>Handler只负责响应事件，不进行业务处理；Handler通过read读取到数据后，会发给Processor进行业务处理。</p>\n</li>\n<li>\n<p>Processor会在独立的子线程中完成真正的业务处理，然后将响应结果发给主进程的Handler处理；Handler收到响应后通过send将响应结果返回给client。</p>\n</li>\n</ul>\n<p>单Reator多线程方案能够充分利用多核多CPU的处理能力，但同时也存在下面的问题：</p>\n<ul>\n<li>\n<p>多线程数据共享和访问比较复杂。例如，子线程完成业务处理后，要把结果传递给主线程的Reactor进行发送，这里涉及共享数据的互斥和保护机制。以Java的NIO为例，Selector是线程安全的，但是通过Selector.selectKeys()返回的键的集合是非线程安全的，对selected keys的处理必须单线程处理或者采取同步措施进行保护。</p>\n</li>\n<li>\n<p>Reactor承担所有事件的监听和响应，只在主线程中运行，瞬间高并发时会成为性能瓶颈。</p>\n</li>\n</ul>\n<p>你可能会发现，我只列出了“单Reactor多线程”方案，没有列出“单Reactor多进程”方案，这是什么原因呢？主要原因在于如果采用多进程，子进程完成业务处理后，将结果返回给父进程，并通知父进程发送给哪个client，这是很麻烦的事情。因为父进程只是通过Reactor监听各个连接上的事件然后进行分配，子进程与父进程通信时并不是一个连接。如果要将父进程和子进程之间的通信模拟为一个连接，并加入Reactor进行监听，则是比较复杂的。而采用多线程时，因为多线程是共享数据的，因此线程间通信是非常方便的。虽然要额外考虑线程间共享数据时的同步问题，但这个复杂度比进程间通信的复杂度要低很多。</p>\n<p>3.多Reactor多进程/线程</p>\n<p>为了解决单Reactor多线程的问题，最直观的方法就是将单Reactor改为多Reactor，这就产生了第3个方案：多Reactor多进程/线程。</p>\n<p>多Reactor多进程/线程方案示意图是（以进程为例）：</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/6c/ba/6cfe3c8785623f93da18ce3390e524ba.jpg?wh=4434*1860\" alt=\"\" /></p>\n<p>方案详细说明如下：</p>\n<ul>\n<li>\n<p>父进程中mainReactor对象通过select监控连接建立事件，收到事件后通过Acceptor接收，将新的连接分配给某个子进程。</p>\n</li>\n<li>\n<p>子进程的subReactor将mainReactor分配的连接加入连接队列进行监听，并创建一个Handler用于处理连接的各种事件。</p>\n</li>\n<li>\n<p>当有新的事件发生时，subReactor会调用连接对应的Handler（即第2步中创建的Handler）来进行响应。</p>\n</li>\n<li>\n<p>Handler完成read→业务处理→send的完整业务流程。</p>\n</li>\n</ul>\n<p>多Reactor多进程/线程的方案看起来比单Reactor多线程要复杂，但实际实现时反而更加简单，主要原因是：</p>\n<ul>\n<li>\n<p>父进程和子进程的职责非常明确，父进程只负责接收新连接，子进程负责完成后续的业务处理。</p>\n</li>\n<li>\n<p>父进程和子进程的交互很简单，父进程只需要把新连接传给子进程，子进程无须返回数据。</p>\n</li>\n<li>\n<p>子进程之间是互相独立的，无须同步共享之类的处理（这里仅限于网络模型相关的select、read、send等无须同步共享，“业务处理”还是有可能需要同步共享的）。</p>\n</li>\n</ul>\n<p>目前著名的开源系统Nginx采用的是多Reactor多进程，采用多Reactor多线程的实现有Memcache和Netty。</p>\n<p>我多说一句，Nginx采用的是多Reactor多进程的模式，但方案与标准的多Reactor多进程有差异。具体差异表现为主进程中仅仅创建了监听端口，并没有创建mainReactor来“accept”连接，而是由子进程的Reactor来“accept”连接，通过锁来控制一次只有一个子进程进行“accept”，子进程“accept”新连接后就放到自己的Reactor进行处理，不会再分配给其他子进程，更多细节请查阅相关资料或阅读Nginx源码。</p>\n<h2>Proactor</h2>\n<p>Reactor是非阻塞同步网络模型，因为真正的read和send操作都需要用户进程同步操作。这里的“同步”指用户进程在执行read和send这类I/O操作的时候是同步的，如果把I/O操作改为异步就能够进一步提升性能，这就是异步网络模型Proactor。</p>\n<p>Proactor中文翻译为“前摄器”比较难理解，与其类似的单词是proactive，含义为“主动的”，因此我们照猫画虎翻译为“主动器”反而更好理解。Reactor可以理解为“来了事件我通知你，你来处理”，而Proactor可以理解为“<strong>来了事件我来处理，处理完了我通知你</strong>”。这里的“我”就是操作系统内核，“事件”就是有新连接、有数据可读、有数据可写的这些I/O事件，“你”就是我们的程序代码。</p>\n<p>Proactor模型示意图是：</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/f4/fe/f431b2674eb0881df6a1d1f77a3729fe.jpg?wh=4374*1853\" alt=\"\" /></p>\n<p>详细介绍一下Proactor方案：</p>\n<ul>\n<li>\n<p>Proactor Initiator负责创建Proactor和Handler，并将Proactor和Handler都通过Asynchronous Operation Processor注册到内核。</p>\n</li>\n<li>\n<p>Asynchronous Operation Processor负责处理注册请求，并完成I/O操作。</p>\n</li>\n<li>\n<p>Asynchronous Operation Processor完成I/O操作后通知Proactor。</p>\n</li>\n<li>\n<p>Proactor根据不同的事件类型回调不同的Handler进行业务处理。</p>\n</li>\n<li>\n<p>Handler完成业务处理，Handler也可以注册新的Handler到内核进程。</p>\n</li>\n</ul>\n<p>理论上Proactor比Reactor效率要高一些，异步I/O能够充分利用DMA特性，让I/O操作与计算重叠，但要实现真正的异步I/O，操作系统需要做大量的工作。目前Windows下通过IOCP实现了真正的异步I/O，而在Linux系统下的AIO并不完善，因此在Linux下实现高并发网络编程时都是以Reactor模式为主。所以即使Boost.Asio号称实现了Proactor模型，其实它在Windows下采用IOCP，而在Linux下是用Reactor模式（采用epoll）模拟出来的异步模型。</p>\n<h2>小结</h2>\n<p>今天我为你讲了单服务器支持高并发的高性能架构模式Reactor和Proactor，希望对你有所帮助。</p>\n<p>这就是今天的全部内容，留一道思考题给你吧，针对“前浪微博”消息队列架构的案例，你觉得采用何种并发模式是比较合适的，为什么？</p>\n<p>欢迎你把答案写到留言区，和我一起讨论。相信经过深度思考的回答，也会让你对知识的理解更加深刻。（编辑乱入：精彩的留言有机会获得丰厚福利哦！）</p>\n","neighbors":{"left":{"article_title":"18 | 单服务器高性能模式：PPC与TPC","id":8697},"right":{"article_title":"20 | 高性能负载均衡：分类及架构","id":8942}},"comments":[{"had_liked":false,"id":12097,"user_name":"林","can_delete":false,"product_type":"c1","uid":1022243,"ip_address":"","ucode":"273F83CB3F9DF8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/23/3c3272bd.jpg","comment_is_top":false,"comment_ctime":1528589773,"is_pvip":false,"replies":[{"id":"3966","content":"解释很清楚👍👍","user_name":"作者回复","comment_id":12097,"uid":"1098920","ip_address":"","utype":1,"ctime":1528615743,"user_name_real":"华仔"}],"discussion_count":9,"race_medal":0,"score":"2101767597517","product_id":100006601,"comment_content":"IO操作分两个阶段\r1、等待数据准备好(读到内核缓存)\r2、将数据从内核读到用户空间(进程空间)\r一般来说1花费的时间远远大于2。\r1上阻塞2上也阻塞的是同步阻塞IO\r1上非阻塞2阻塞的是同步非阻塞IO，这讲说的Reactor就是这种模型 \r1上非阻塞2上非阻塞是异步非阻塞IO，这讲说的Proactor模型就是这种模型 ","like_count":490,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419112,"discussion_content":"解释很清楚👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528615743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2854129,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/8c/f1/1a55535d.jpg","nickname":"踏雪无痕","note":"","ucode":"BB426066431D4D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570808,"discussion_content":"程序发起IO调用时涉及两个阶段\n数据准备阶段：等待内核态将数据从外设读入内核态内存并准备好，进入就绪状态 (Waiting for the data to be ready)。这步是外设与内核态内存间的复制，是耗时操作！\n数据复制阶段：将数据从内核态复制到用户态即从内核态内存复制到用户态内存 (Copying the data from the kernel to the process)。这步是内存间的复制，比上步快很多。\n通常说的IO“阻塞”是指在上述步骤1过程中用户调用者线程是否阻塞。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1651916564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1059152,"avatar":"https://static001.geekbang.org/account/avatar/00/10/29/50/2b2e6875.jpg","nickname":"慕士塔格","note":"","ucode":"B30AA3F6EDC4BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212219,"discussion_content":"意思就是内核空间，我们用阻塞，非阻塞描述；用户空间我们用同步，非同步描述？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584947365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1187577,"avatar":"https://static001.geekbang.org/account/avatar/00/12/1e/f9/bfb54326.jpg","nickname":"狮锅艺","note":"","ucode":"1B4AD130F9D0CA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1059152,"avatar":"https://static001.geekbang.org/account/avatar/00/10/29/50/2b2e6875.jpg","nickname":"慕士塔格","note":"","ucode":"B30AA3F6EDC4BF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278382,"discussion_content":"我的理解是这样的：同步/异步关注的是消息通信机制，也就是当前进程调用返回后有没有拿到结果。阻塞/非阻塞关注的是程序在等待调用结果时的状态，也就是说当前线程/进程发起调用后是否要拿到结果才返回。","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1591179639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":212219,"ip_address":""},"score":278382,"extra":""}]},{"author":{"id":1161522,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b9/32/84346d4a.jpg","nickname":"雪碧心拔凉","note":"","ucode":"D13EEBAA0F443B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":410532,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635725717,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2045627,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/36/bb/67d689c5.jpg","nickname":"一颗小橘子🍊","note":"","ucode":"584557A3E26B33","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376519,"discussion_content":"Reactor 在select监听的时候1不也是阻塞的么？？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622172340,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338790,"discussion_content":"这条评论中的&#34;1上非阻塞2阻塞的是同步非阻塞IO&#34;和&#34;1上非阻塞2上非阻塞是异步非阻塞IO&#34;其实是错误的, 后半句是对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609382908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1127624,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKPmOyph1XeszC69tTLENkZFJqjJ7CqtxlSpNEiaonB9ebLnKEh8w7gk7TXQiay4JvA0fQtLYKw718Q/132","nickname":"雨落漂洋","note":"","ucode":"9D53DB4482AA24","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":147929,"discussion_content":"还有一个actor模型，和Proactor有什么关系吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579681648,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1009652,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","nickname":"钱","note":"","ucode":"2C92A243A463D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6555,"discussion_content":"1是操作系统将数据从网络读到内核缓存，2是内存到内存只是归属不同，由于网络带宽+解码+解压缩+解密，才使的1远远慢于2吗？\n或者换个问题，1比2慢在哪个环节？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566969545,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12212,"user_name":"林","can_delete":false,"product_type":"c1","uid":1022243,"ip_address":"","ucode":"273F83CB3F9DF8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/23/3c3272bd.jpg","comment_is_top":false,"comment_ctime":1528694074,"is_pvip":false,"replies":[{"id":"4032","content":"太形象了👍👍👍","user_name":"作者回复","comment_id":12212,"uid":"1098920","ip_address":"","utype":1,"ctime":1528715592,"user_name_real":"华仔"}],"discussion_count":16,"race_medal":0,"score":"1912789140794","product_id":100006601,"comment_content":"Reactor与Proactor能不能这样打个比方：<br>\r1、假如我们去饭店点餐，饭店人很多，如果我们付了钱后站在收银台等着饭端上来我们才离开，这就成了同步阻塞了。<br>\r2、如果我们付了钱后给你一个号就可以离开，饭好了老板会叫号，你过来取。这就是Reactor模型。<br>\r3、如果我们付了钱后给我一个号就可以坐到坐位上该干啥干啥，饭好了老板会把饭端上来送给你。这就是Proactor模型了。","like_count":446,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419160,"discussion_content":"太形象了👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528715592,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1098910,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/9e/d820b03c.jpg","nickname":"狩魔天使范海辛","note":"","ucode":"E0E8CF701D18BD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336269,"discussion_content":"1.是学校食堂  2.是银行柜台  3.是海底捞","likes_number":16,"is_delete":false,"is_hidden":false,"ctime":1608542987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1267924,"avatar":"https://static001.geekbang.org/account/avatar/00/13/58/d4/c1e67d7a.jpg","nickname":"GEEKBANG_4123791","note":"","ucode":"BCAE0B44F2999D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295282,"discussion_content":"感觉Proactor应该是，饭店老板，来到你身边，对你说“您好，饭好了，我帮你吃了，通知您一声！”\n😂","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1596156270,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1095857,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","nickname":"梦倚栏杆","note":"","ucode":"BDEB97F2822445","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1267924,"avatar":"https://static001.geekbang.org/account/avatar/00/13/58/d4/c1e67d7a.jpg","nickname":"GEEKBANG_4123791","note":"","ucode":"BCAE0B44F2999D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358629,"discussion_content":"66666，这个举例我没get到点.端上来和自己去端不是一样的吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616024215,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":295282,"ip_address":""},"score":358629,"extra":""}]},{"author":{"id":1009652,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","nickname":"钱","note":"","ucode":"2C92A243A463D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6553,"discussion_content":"感觉比华仔讲的好，读完专栏一脸懵逼，读完比喻豁然开朗","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1566969086,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338791,"discussion_content":"这个比喻好, 通俗易懂","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1609382967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1105513,"avatar":"https://static001.geekbang.org/account/avatar/00/10/de/69/113da382.jpg","nickname":"宇飞","note":"","ucode":"D64C53CD189164","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583593,"discussion_content":"收银台就是内核，客人是用户态线程，点餐是io事件。收银台点餐是非阻塞的，因为你不点其他人点餐，不能阻塞，客人一直等着取餐是同步操作，啥都干不了，只能等取餐，客人坐在座位上干其他事，餐来了就吃是异步操作","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1660221443,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1031271,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/bc/67/5b97ba24.jpg","nickname":"青见","note":"","ucode":"F6E0D3D6D1C5BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349046,"discussion_content":"有点 IO  BIO NIO 感觉","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1612858676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1475843,"avatar":"https://static001.geekbang.org/account/avatar/00/16/85/03/78275758.jpg","nickname":"清风徐徐","note":"","ucode":"098212AD349708","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581482,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658805723,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2707800,"avatar":"https://static001.geekbang.org/account/avatar/00/29/51/58/8f588819.jpg","nickname":"莫名其妙","note":"","ucode":"EDBDD2C2F106E9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555187,"discussion_content":"mark一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646806077,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1651441,"avatar":"https://static001.geekbang.org/account/avatar/00/19/32/f1/fd24d52b.jpg","nickname":"青禾qingh","note":"","ucode":"453FC435B03790","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":533149,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637804403,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2734734,"avatar":"https://static001.geekbang.org/account/avatar/00/29/ba/8e/4645afae.jpg","nickname":"Drake敏","note":"","ucode":"38366767EFDC90","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394021,"discussion_content":"这个说的狠容易懂，赞\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631690991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1129838,"avatar":"https://static001.geekbang.org/account/avatar/00/11/3d/6e/60680aa4.jpg","nickname":"Li Yao","note":"","ucode":"703E1E5505F70D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300254,"discussion_content":"为什么老板送饭比自己去取高效呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598000059,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1662994,"avatar":"https://static001.geekbang.org/account/avatar/00/19/60/12/d99027df.jpg","nickname":"Zhi","note":"","ucode":"47DB818B2FDF86","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1129838,"avatar":"https://static001.geekbang.org/account/avatar/00/11/3d/6e/60680aa4.jpg","nickname":"Li Yao","note":"","ucode":"703E1E5505F70D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":316624,"discussion_content":"对于自己来说是高效了...  对于老板来说就多花了送饭的时间啊...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603431918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":300254,"ip_address":""},"score":316624,"extra":""},{"author":{"id":1445744,"avatar":"https://static001.geekbang.org/account/avatar/00/16/0f/70/f59db672.jpg","nickname":"槑·先生","note":"","ucode":"897F0475592E3A","race_medal":2,"user_type":1,"is_pvip":true},"reply_author":{"id":1129838,"avatar":"https://static001.geekbang.org/account/avatar/00/11/3d/6e/60680aa4.jpg","nickname":"Li Yao","note":"","ucode":"703E1E5505F70D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":415149,"discussion_content":"因为老板送过来的时间你还可以坐在座位上玩手机(做别的任务)，你自己去端就没法玩了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636991910,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":300254,"ip_address":""},"score":415149,"extra":""}]},{"author":{"id":1008582,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/c6/d6ea3df3.jpg","nickname":"林肯","note":"","ucode":"D2C97220230DE5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":266524,"discussion_content":"一语胜千言","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589526138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12819,"user_name":"正是那朵玫瑰","can_delete":false,"product_type":"c1","uid":1048261,"ip_address":"","ucode":"73D630B654573F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fe/c5/3467cf94.jpg","comment_is_top":false,"comment_ctime":1529052959,"is_pvip":false,"replies":[{"id":"4257","content":"非常感谢，我明白了你说的情况，我再次验证了一下，写了一个独立线程处理业务的，确实如你所说，netty4两者都支持，并且做了线程安全处理，最终发送都是在io线程里面。<br><br>如果我们用这种模式，可以自己控制业务线程，因为netty4已经帮我们封装了复杂度，看来我孤陋寡闻了😂<br><br>不过我建议还是别无条件用这种模式，我们之前遇到的情况就是短时间内io确实很快，并发高，但如果业务处理慢，会积压请求数据，如果客户端请求是同步的，单个请求全流程时间不会减少；如果客户端请求是异步的，如果积压的时候宕机会丢较多数据。<br><br>其实这种情况我理解单纯加大线程数就够了，例如5个io线程加20个业务线程能达到最优性能的话，我理解25个融合线程性能也差不多。<br><br>我们之前有一个案例，http服务器业务处理线程配置了512个，后来发现其实配置128是最好的(48核)，所以说并不是线程分开或者线程数量多性能就一定高。<br><br>再次感谢你的认真钻研，我也学到了一个技术细节👍","user_name":"作者回复","comment_id":12819,"uid":"1098920","ip_address":"","utype":1,"ctime":1529058751,"user_name_real":"华仔"}],"discussion_count":1,"race_medal":0,"score":"366601273119","product_id":100006601,"comment_content":"感谢华仔，我也再实验了下netty4，其实handler的独立的线程池里面执行其实也没有问题，netty已经帮我们处理好了，当我们处理完业务，write数据的时候，会先放到一个队列里面，真正出站还是由io线程统一调度，这样就避免了netty3的问题！","like_count":86,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419424,"discussion_content":"非常感谢，我明白了你说的情况，我再次验证了一下，写了一个独立线程处理业务的，确实如你所说，netty4两者都支持，并且做了线程安全处理，最终发送都是在io线程里面。\n\n如果我们用这种模式，可以自己控制业务线程，因为netty4已经帮我们封装了复杂度，看来我孤陋寡闻了😂\n\n不过我建议还是别无条件用这种模式，我们之前遇到的情况就是短时间内io确实很快，并发高，但如果业务处理慢，会积压请求数据，如果客户端请求是同步的，单个请求全流程时间不会减少；如果客户端请求是异步的，如果积压的时候宕机会丢较多数据。\n\n其实这种情况我理解单纯加大线程数就够了，例如5个io线程加20个业务线程能达到最优性能的话，我理解25个融合线程性能也差不多。\n\n我们之前有一个案例，http服务器业务处理线程配置了512个，后来发现其实配置128是最好的(48核)，所以说并不是线程分开或者线程数量多性能就一定高。\n\n再次感谢你的认真钻研，我也学到了一个技术细节👍","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1529058751,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12028,"user_name":"正是那朵玫瑰","can_delete":false,"product_type":"c1","uid":1048261,"ip_address":"","ucode":"73D630B654573F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fe/c5/3467cf94.jpg","comment_is_top":false,"comment_ctime":1528523064,"is_pvip":false,"replies":[{"id":"3971","content":"1. 分析正确，redis不太适合有的key的value特别大，这种情况会导致整个redis变慢，这种场景mc更好<br>2. prethread确实可以，mysql就是这种模式<br>3. 多reactor多线程再拆分业务线程，性能没有提升，复杂度提升不少，我还没见过这种方式。","user_name":"作者回复","comment_id":12028,"uid":"1098920","ip_address":"","utype":1,"ctime":1528616431,"user_name_real":"华仔"}],"discussion_count":4,"race_medal":0,"score":"254931593528","product_id":100006601,"comment_content":"根据华仔之前对前浪微博消息中间件的分析，TPS定位在1380，QPS定位在13800，消息要高可靠（不能丢失消息），定位在常量连接海量请求的系统吧。基于此来分析下吧。<br><br>1、单Reactor单进程&#47;线程<br>redis采用这种模式，原因是redis是基于内存的数据库，在处理业务会非常快，所以不会对IO读写进行过长时间的阻塞，但是如果redis开启同步持久化后，业务处理会变慢，阻塞了IO线程，也就无法处理更多的连接了，而我们的消息中间件需要消息的高可靠，必定要同步持久化，如果异步的话，就看异步持久化的时间间隔了，假设500ms持久化一次，那就有可能会丢失500ms的消息。当然华仔分析的无法利用多核cpu的特性也是一大缺点；虽然我们要求的TPS不算很高，但是QPS很高了，所以我觉得这种模式不合适<br>2、单Reactor多进程&#47;线程<br>这种模式我觉得也不是和合适，虽然真正的业务处理在独立的线程了，IO线程并没有被阻塞，可以处理更多的连接和读写事件。我们的中间件可能不会面对海量的连接数，但是会面对大量的读请求，瓶颈是在处理读操作上，跟单Reactor单进程&#47;线程差别不大；我倒觉得前一讲说的TPC prethread 模式是合适的，有独立的线程负责read-业务处理-send。<br>3、多Reactor多进程&#47;线程<br>这种模式是最合适的了，不过华仔在讲解是read→业务处理→send，业务处理还是在IO线程上，如果业务处理的慢，还是会阻塞IO线程的，我觉得最好是业务处理放到独立的线程池里面去，这就变成了mainReactor负责监听连接，subReactor 负责IO读写，后面的业务线程池负责真正的业务处理，这样就既可以面对海量的连接，海量的请求也可以支撑。<br><br>不知理解的是否正确？","like_count":59,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419088,"discussion_content":"1. 分析正确，redis不太适合有的key的value特别大，这种情况会导致整个redis变慢，这种场景mc更好\n2. prethread确实可以，mysql就是这种模式\n3. 多reactor多线程再拆分业务线程，性能没有提升，复杂度提升不少，我还没见过这种方式。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1528616431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1094597,"avatar":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","nickname":"Liam","note":"","ucode":"1D15D3B64F2606","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556437,"discussion_content":"3的话有些业务操作是比较慢的，例如涉及到rpc或持久华等操作，用线程池避免阻塞io读写；另外多线程池可以实现一定程度的业务隔离。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647358534,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1105354,"avatar":"https://static001.geekbang.org/account/avatar/00/10/dd/ca/fe3f7f0e.jpg","nickname":"T.Y","note":"","ucode":"243C96604F1CAA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367476,"discussion_content":"netty里面也可以配置业务线程池","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618371763,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1228500,"avatar":"https://static001.geekbang.org/account/avatar/00/12/be/d4/ff1c1319.jpg","nickname":"金龟","note":"","ucode":"1C7D35C8AE8D9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342849,"discussion_content":"3里面dubbo 可以选择","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610852132,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12143,"user_name":"空档滑行","can_delete":false,"product_type":"c1","uid":1091611,"ip_address":"","ucode":"06A6A7F503FAA7","user_header":"https://static001.geekbang.org/account/avatar/00/10/a8/1b/ced1d171.jpg","comment_is_top":false,"comment_ctime":1528617645,"is_pvip":false,"replies":[{"id":"3992","content":"分析正确","user_name":"作者回复","comment_id":12143,"uid":"1098920","ip_address":"","utype":1,"ctime":1528624775,"user_name_real":"华仔"}],"discussion_count":1,"race_medal":0,"score":"164737374893","product_id":100006601,"comment_content":"消息队列系统属于中间件系统，连接数相对固定，长链接为主，所以把accept分离出来的意义是不大的。消息中间件要保证数据持久性，所以入库操作应该是耗时最大的操作。综合起来我觉得单reactor，多线程&#47;进程的方式比较合适。","like_count":39,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419136,"discussion_content":"分析正确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528624775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12172,"user_name":"赵正 Allen","can_delete":false,"product_type":"c1","uid":1109394,"ip_address":"","ucode":"892B98C996054A","user_header":"https://static001.geekbang.org/account/avatar/00/10/ed/92/9e58858c.jpg","comment_is_top":false,"comment_ctime":1528636658,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"121787720946","product_id":100006601,"comment_content":"一直做网络通讯相关的开发，用过ACE，boost asio。谈谈我的一些愚见，reactor pattern 主要解决io事件检测和事件分派，其中，事件检测一般都是通过封装OS提供API实现，在Linux下最常用epoll，事件分派是将检测到的事件委托给特定的方法，一般通过接口继承或函数指针实现。除此之外，定时器，信号量也会集成到reactor框架中。<br>多线程or多进程，实际工作中，基本多线程模型，可以单线程事件检测，多线程分派，也可以多线程轮流事件检测和分派。可以参考leader-follwers pattern。<br>io模式，一般都使用non-block。<br>与acceptor-connector模式结合使用，可进一步分离模块职责（即将 服务初始化与 服务逻辑分离. 由reactor统一进行事件驱动）<br><br>附一个自己开发的reactor框架<br><br>https:&#47;&#47;github.com&#47;zhaozhencn&#47;cute","like_count":28,"discussions":[{"author":{"id":2411196,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ca/bc/5d490954.jpg","nickname":"爱狗","note":"","ucode":"9D5A3153C82B62","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373111,"discussion_content":"老哥名字拼音是不是拼错了0.0","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620618003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12229,"user_name":"赵正 Allen","can_delete":false,"product_type":"c1","uid":1109394,"ip_address":"","ucode":"892B98C996054A","user_header":"https://static001.geekbang.org/account/avatar/00/10/ed/92/9e58858c.jpg","comment_is_top":false,"comment_ctime":1528704331,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"87428050251","product_id":100006601,"comment_content":"对于两组概念的理解，欢迎吐槽<br><br>阻塞&amp;非阻塞<br><br>这一组概念并偏向于系统底层的实现，常与OS进程调度相关。 以socket为例，在阻塞模式下线程A调用recv函数，若此时接收缓冲区有数据，则立即返回，否则将进入”阻塞状态“（主动释放CPU控制权，由OS CPU调度程序重新调度并运行其它进程），直到”等待条件”为真，再由OS将此进程调度并重新投入运行。非阻塞模式则另辟蹊径，无论有无数据均立即返回（有数据则返回数据，无数据则返回错误值）， 不会影响当前线程的状态。 从某种意义上讲，阻塞模式下，一个线程关联一个文件fd, 常引起线程切换与重新调度，对于高并发环境，这种代价太大。而非阻塞模式则解耦了“1线程关联1文件fd&quot;。<br><br><br><br>同步&amp;异步<br><br>调用与执行的分离即为异步，否则为同步。其实包括两个层面，其一为请求方（客户方），其二为执行方（服务方），抛开这两个概念单独讨论同步或异步是片面的。若请求方调用执行方的服务并等待服务结果，则为同步过程。但对于一些耗时或IO服务，服务执行时间往往较长或不可控，并可能导致降低整体服务质量，此时需要将调用与执行解耦。 有些经典设计模式常用于解决此问题： 1 command（命令模式）-- 将请求封装成命令对象，实现请求方对命令执行的透明化， 2 Active Object（主动对象）--  对象内部驻留一个线程或线程池，用于执行具体服务，同时，对象对外提供服务接口，供请求方发起调用（可能获得Future对象）。","like_count":20},{"had_liked":false,"id":12059,"user_name":"LinMoo","can_delete":false,"product_type":"c1","uid":1113782,"ip_address":"","ucode":"9C322810C0C04C","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/NicGuX4PVAEHDmodLO5n313OVn024K4D2kCsuorM11H5c4HJZDVzJ9KMj5auzgQW5YNl06edSypHAhpNs41zuEw/132","comment_is_top":false,"comment_ctime":1528542810,"is_pvip":false,"replies":[{"id":"3969","content":"你两个问题的理解都正确","user_name":"作者回复","comment_id":12059,"uid":"1098920","ip_address":"","utype":1,"ctime":1528615952,"user_name_real":"华仔"}],"discussion_count":1,"race_medal":0,"score":"83132921434","product_id":100006601,"comment_content":"请教两个问题 谢谢<br>之前学习NIO和AIO的时候是这么描述的：进程请求IO（无论是硬盘还是网络IO），先让内核读取数据到内核缓存，然后从内核缓存读取到进程。这里面就有2个IO等待时间，第一个是读取到内核缓存，第二个是读取到进程。前者花费的时间远远大于后者。在第一个时间中进程不做等待就是NIO，即非阻塞。第二个时间中进程也不需要等待就是AIO，即异步。<br>第一个问题：文章中说Reactor 是非阻塞同步网络模型，因为真正的 read 和 send 操作都需要用户进程同步操作。这里的read和send指的是我上面说的第二个时间吗？<br>第二个问题：因为我理解你的“来了事件我来处理，处理完了我通知你”。这里的我来处理就是包括第一和第二个时间吗？<br><br>感觉我之前被误解了，是我哪个地方理解不对吗？麻烦解答一下。","like_count":20,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419098,"discussion_content":"你两个问题的理解都正确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528615952,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12684,"user_name":"正是那朵玫瑰","can_delete":false,"product_type":"c1","uid":1048261,"ip_address":"","ucode":"73D630B654573F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fe/c5/3467cf94.jpg","comment_is_top":false,"comment_ctime":1528957764,"is_pvip":false,"replies":[{"id":"4238","content":"非常感谢你的认真研究和提问，我对netty的原理有一些研究，也用过netty3，也看过一些源码，但也还达不到非常熟悉的地步，所以不管是网上的资料，还是我说的内容，都不要无条件相信，自己都需要思考，这点你做的很好👍<br><br>回到问题本身，由于netty4线程模型和netty3相比做了改进，我拿netty4.1源码中的telnet样例，在handler和NioEventloop的processSelectedKey函数打了输出线程id的日志，从日志结果看，StringEncoder, StringDecoder, TelnetServerHandler都在NioEventLoop的线程里面处理的。<br><br>如果handler在独立的线程中运行，返回结果处理会比较麻烦，如果返回结果在业务线程中处理，会出现netty3存在的问题，channel需要做多线程同步，各种状态处理很麻烦；如果返回结果还是在io线程处理，那业务线程如何将结果发送给io线程也涉及线程间同步，所以最终其实还不如在一个线程里面处理。","user_name":"作者回复","comment_id":12684,"uid":"1098920","ip_address":"","utype":1,"ctime":1529045998,"user_name_real":"华仔"}],"discussion_count":3,"race_medal":0,"score":"65953467204","product_id":100006601,"comment_content":"感谢华仔的解答，我看到在针对多reactor多线程模型，也有同学留言有疑问，我想请教下华仔，多reactor多线程模型中IO线程与业务处理在同一线程中，如果业务处理很耗时，定会阻塞IO线程，所以留言同学“衣申人”也说要不要将IO线程跟业务处理分开，华仔的答案是性能没有提升，复杂度提升很多，我还没见过这种处理方式，华仔对netty应该是很熟悉的，我的疑问是：在netty中boss线程池就是mainReactor，work线程池就是subReactor，正常在ChannelPipeline中添加ChannelHandler是在work线程即IO线程中串行执行，但是如果pipeline.addLast(group, &quot;handler&quot;, new MyBusinessLogicHandler());这样的话，业务hangdle就会在group线程池里面执行了，这样不就是多reactor多线程模型中把IO线程和业务处理线程分开么？而且我在很多著名开源项目里面看到使用netty都是这样处理的，比如阿里的开源消息中间件rocketmq使用netty也是如此。华仔说没有见过这种处理方式，能否解答下？不知道是不是我理解错了","like_count":15,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419368,"discussion_content":"非常感谢你的认真研究和提问，我对netty的原理有一些研究，也用过netty3，也看过一些源码，但也还达不到非常熟悉的地步，所以不管是网上的资料，还是我说的内容，都不要无条件相信，自己都需要思考，这点你做的很好👍\n\n回到问题本身，由于netty4线程模型和netty3相比做了改进，我拿netty4.1源码中的telnet样例，在handler和NioEventloop的processSelectedKey函数打了输出线程id的日志，从日志结果看，StringEncoder, StringDecoder, TelnetServerHandler都在NioEventLoop的线程里面处理的。\n\n如果handler在独立的线程中运行，返回结果处理会比较麻烦，如果返回结果在业务线程中处理，会出现netty3存在的问题，channel需要做多线程同步，各种状态处理很麻烦；如果返回结果还是在io线程处理，那业务线程如何将结果发送给io线程也涉及线程间同步，所以最终其实还不如在一个线程里面处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529045998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1239881,"avatar":"https://static001.geekbang.org/account/avatar/00/12/eb/49/bd914b5f.jpg","nickname":"公号-彤哥读源码","note":"","ucode":"C0D16E1BA12DA0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351489,"discussion_content":"哈哈，评论很精彩，不过，这次我不站在老师这边了，原因有三点：\n1. Doug Lea在《Scalable IO in Java》中关于Reactor主从的讲解用的确实是这位同学说的业务线程池独立出来处理；\n2. Netty中的ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)方法是可以支持你的Handler定制一个线程池来处理的，Netty中的线程池就是这里的EventExecutorGroup；\n3. 实际场景中确实存在业务处理耗时的情况，比如写数据库，而Netty中是一个EventLoop（线程）监听多个连接的事件，如果业务处理跟IO放一块一个事件业务处理慢容易导致这个EventLoop监听的事件都阻塞住；\n\n关于Doug Lea的《Scalable IO in Java》我放在gitee上了，欢迎下载：https://gitee.com/alan-tang-tt/reactor","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1614304982,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1250922,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIzGGthScz54sECZJKX3lgyjCATkgrvSt5N3eOsYB34jibCr3SkAX88QaZ5IVmME9Ec7VdkQGwRSPw/132","nickname":"哈哈哈","note":"","ucode":"8AC20A1C9C7DF8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579156,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657203152,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":15968,"user_name":"沙亮亮","can_delete":false,"product_type":"c1","uid":1099492,"ip_address":"","ucode":"E6CF0D5B1E6691","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/e4/ec572f55.jpg","comment_is_top":false,"comment_ctime":1531700824,"is_pvip":false,"replies":[{"id":"5523","content":"两个轮询不是一个意思，select和poll是收到通知后轮询socket列表看看哪个socket可以读，普通的socket轮询是指重复调用read操作","user_name":"作者回复","comment_id":15968,"uid":"1098920","ip_address":"","utype":1,"ctime":1531720505,"user_name_real":"华仔"}],"discussion_count":1,"race_medal":0,"score":"44481373784","product_id":100006601,"comment_content":"根据unix网络编程上说的，select和poll都是轮询方式，epoll是注册方式。为什么您说select也不是轮询方式","like_count":11,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420619,"discussion_content":"两个轮询不是一个意思，select和poll是收到通知后轮询socket列表看看哪个socket可以读，普通的socket轮询是指重复调用read操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1531720505,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20351,"user_name":"潘宁","can_delete":false,"product_type":"c1","uid":1106291,"ip_address":"","ucode":"5B71ADD34F7517","user_header":"https://static001.geekbang.org/account/avatar/00/10/e1/73/512547e6.jpg","comment_is_top":false,"comment_ctime":1534390397,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"40189096061","product_id":100006601,"comment_content":"Reactor和proactor主要是用来解决高并发的问题（ppc和tpc不能应对高并发）<br>打个比方，我们去点心店吃碗面，首先先得去收银台点单付钱，同步阻塞的情况是：我点了碗辣酱加辣肉面，然后我就在收银台等着，等到面来了，我拿着面去吃了，后面所有的人都无法点单无法下单(即使后面的人点的是已经做好的大排面也不能付钱拿面，老子还没好 你们谁都不许动)，而reactor（同步非阻塞）的情况是我点了碗辣酱加辣肉面，钱付好以后我就拿着号去座位上坐下了，等面好了后，服务员会叫“XXX号，你的面好了，自己来取”（服务员帮你送上来的叫proactor），这里收银台就是reactor或者叫dispatcher，店里会有一个小二定时的轮询去看XXX号的XXX面有没有好，好了以后就通知XXX你可以来拿面了，没好你就等着呗。多reactor就是把收钱 下面 通知的事分成几个人 由不同的人来做","like_count":9},{"had_liked":false,"id":20716,"user_name":"文竹","can_delete":false,"product_type":"c1","uid":1103167,"ip_address":"","ucode":"74413B1975976B","user_header":"https://static001.geekbang.org/account/avatar/00/10/d5/3f/80bf4841.jpg","comment_is_top":false,"comment_ctime":1534688145,"is_pvip":false,"replies":[{"id":"7283","content":"分析正确👍","user_name":"作者回复","comment_id":20716,"uid":"1098920","ip_address":"","utype":1,"ctime":1534738293,"user_name_real":"华仔"}],"discussion_count":1,"race_medal":0,"score":"31599459217","product_id":100006601,"comment_content":"服务基本上都是部署在Linux上的，所以仅能使用reactor。前浪微博的写QPS在千级别，读在万级别，一般单台稍微好点配置好点的机器都能承受这两个QPS，再加上这两个QPS因任务分配器被分摊到了多态机器，最终单台机器上的QPS并不高。所以使用单reactor多线程模式足矣。","like_count":7,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422377,"discussion_content":"分析正确👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534738293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":45657,"user_name":"ban","can_delete":false,"product_type":"c1","uid":1034204,"ip_address":"","ucode":"E523CE97E48266","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c7/dc/9408c8c2.jpg","comment_is_top":false,"comment_ctime":1543739396,"is_pvip":false,"replies":[{"id":"16301","content":"对照Doug Lee讲异步io的PPT，将代码从头到尾亲自敲一遍，就比较容易理解了","user_name":"作者回复","comment_id":45657,"uid":"1098920","ip_address":"","utype":1,"ctime":1543795156,"user_name_real":"华仔"}],"discussion_count":1,"race_medal":0,"score":"27313543172","product_id":100006601,"comment_content":"这个Reactor Proactor好抽象，不太理解<br><br>","like_count":6,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431140,"discussion_content":"对照Doug Lee讲异步io的PPT，将代码从头到尾亲自敲一遍，就比较容易理解了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543795156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":15848,"user_name":"孙振超","can_delete":false,"product_type":"c1","uid":1101755,"ip_address":"","ucode":"0F9EABC6125350","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/bb/22af0e52.jpg","comment_is_top":false,"comment_ctime":1531554248,"is_pvip":false,"replies":[{"id":"5534","content":"功能是ok的，但复杂度不一样，参考架构设计的简单原则","user_name":"作者回复","comment_id":15848,"uid":"1098920","ip_address":"","utype":1,"ctime":1531721534,"user_name_real":"华仔"}],"discussion_count":1,"race_medal":0,"score":"23006390728","product_id":100006601,"comment_content":"ppc和tpc时是每一个连接创建一个进程或线程，处理完请求后将其销毁，这样的性能比较低，为提升性能，首先考虑是链接处理完后不再销毁进程或线程，将这一部分的成本给降下来。改进后存在的问题是如果当前的链接没有请求又把进程或线程都给占住的情况下，新进来的链接就没有处理资源了。对此的解决方法是把io处理从阻塞改为非阻塞，这样当链接没有请求的时候可以去其他有请求的链接，这样改完后存在的问题有两个：一是寻找有请求的链接需要轮询需要耗费cpu而是当请求特别多的时候轮询一遍也需要耗费很长时间。基于这种情况引出了io多路复用，在处理进程和链接这之间加了一个中间人，将所有的链接都汇总到一个地方，处理进程都阻塞在中间人上，当某一个链接有请求进来了，就通知一个进程去处理。在具体的实现方式上根据中间人reactor的个数和处理请求进程的个数上有四种组合，用的比较多的还是多reactor和多进程。<br>之前的留言中有一个类比成去餐厅吃饭的例子还是蛮恰当的，肯德基麦当劳里面是reactor模式，需要用户先领个号然后等叫号取餐；海底捞和大多数中餐厅就是paractor模式，下完单后服务员直接将食品送过来。<br><br><br>回到文章中的问题，消息中间件的场景是链接数少请求量大，采用多进程或多线程来处理会比较好，对应单reactor还是多reactor应该都可以。","like_count":5,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420571,"discussion_content":"功能是ok的，但复杂度不一样，参考架构设计的简单原则","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1531721534,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":299310,"user_name":"努力成为架构师的萌新","can_delete":false,"product_type":"c1","uid":2668958,"ip_address":"","ucode":"7966176CFF52B2","user_header":"https://static001.geekbang.org/account/avatar/00/28/b9/9e/7e801469.jpg","comment_is_top":false,"comment_ctime":1624573562,"is_pvip":false,"replies":[{"id":"108561","content":"你这个萌新有点强啊，总结的很到位 👍🏻<br><br>疑问解答：<br>1. 多Reactor多线程目前来说几乎是完美的方案，没有明显的缺点，唯一的缺点是实现比较复杂一些，但是目前都有开源方案，Java的Netty，C&#47;C++的libevent<br>2. 区别就是当一个线程没事可干的时候是如何阻塞的，多Reactor多线程里面的线程，一个线程可以处理几十上百个连接，没事做的时候就阻塞在select上，而PPC&#47;TPC一个线程只能处理一个连接，没事做的时候就阻塞在read上。","user_name":"作者回复","comment_id":299310,"uid":"1098920","ip_address":"","utype":1,"ctime":1624590373,"user_name_real":"华仔"}],"discussion_count":1,"race_medal":0,"score":"18804442746","product_id":100006601,"comment_content":"萌新，没有什么实践经验，理解和总结的可能不到位，也有些疑问希望得到解答<br><br>总结:<br>少连接，多请求 - PPC&#47;TPC<br>多连接，多请求<br>    - 单Rector 单线程 (无法充分利用内核，需要业务处理迅速)<br>    - 单Rector 多线程 (复杂度较高，应对瞬间高并发能力较差)<br>    - 多Rector 多线程 (复杂度比 单Rector多线程 低，强化应对高并发的能力)<br><br>疑问:<br>    1. 多Rector多线程 相比于其他Rector模式的缺点是什么， 既可以充分利用内核，复杂度不错，也有一定应对高并发的能力，岂不是万金油的选择？<br>    2. 多Rector多线程&#47;进程 的模式和PPC&#47;TPC很像，都是在请求连接的时候开始新线程&#47;进程 进行处理，这两者之间有什么区别？<br><br>后浪微博的场景会有多连接，多请求(访问量)，并且可能存在高并发的场合， 所以可以采用多Rector多线程(分析错的话希望指点)","like_count":5,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522398,"discussion_content":"你这个萌新有点强啊，总结的很到位 👍🏻\n\n疑问解答：\n1. 多Reactor多线程目前来说几乎是完美的方案，没有明显的缺点，唯一的缺点是实现比较复杂一些，但是目前都有开源方案，Java的Netty，C/C++的libevent\n2. 区别就是当一个线程没事可干的时候是如何阻塞的，多Reactor多线程里面的线程，一个线程可以处理几十上百个连接，没事做的时候就阻塞在select上，而PPC/TPC一个线程只能处理一个连接，没事做的时候就阻塞在read上。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624590373,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":15190,"user_name":"老北","can_delete":false,"product_type":"c1","uid":1024376,"ip_address":"","ucode":"89B9B6673F1705","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a1/78/71d37164.jpg","comment_is_top":false,"comment_ctime":1530973475,"is_pvip":false,"replies":[{"id":"5200","content":"很好的一个问题，这就是你去研究源码查看细节的最好时机了，参考特别放松“如何学习开源项目”。<br><br>","user_name":"作者回复","comment_id":15190,"uid":"1098920","ip_address":"","utype":1,"ctime":1531122603,"user_name_real":"华仔"}],"discussion_count":2,"race_medal":0,"score":"18710842659","product_id":100006601,"comment_content":"华仔，请教个问题。<br>redis是使用单reactor单进程模式。缺点是handler在处理某个连接上的业务时，整个进程无法处理其他连接的事件。<br>但是我做了个测试，在redis里面存放了一个1000w长度的list，然后使用lrange 0  -1全取出来，这会用很久。<br>这时候我新建个连接，继续其他key的读写操作都是可以的。不是应该阻塞吗？","like_count":5,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420278,"discussion_content":"很好的一个问题，这就是你去研究源码查看细节的最好时机了，参考特别放松“如何学习开源项目”。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1531122603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1683985,"avatar":"https://static001.geekbang.org/account/avatar/00/19/b2/11/7a3920ee.jpg","nickname":"stanley","note":"","ucode":"EEA7CF31B9B431","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212852,"discussion_content":"redis对事件的处理会尽量减少处理时间，并在有需要时主动让出执行权，避免造成事件饥饿的可能性。比如发送内容超过一个预定常量的时候，会主动退出此次事件处理，余下的数据留到下一次再写。所以在执行长时间的事件时，可以同时处理其他事件。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1585023296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":13527,"user_name":"luck bear","can_delete":false,"product_type":"c1","uid":1106583,"ip_address":"","ucode":"067313CE2A83C4","user_header":"https://static001.geekbang.org/account/avatar/00/10/e2/97/4ca1377c.jpg","comment_is_top":false,"comment_ctime":1529722504,"is_pvip":false,"replies":[{"id":"4535","content":"代码实现请参考Doug Lee关于NIO的PPT","user_name":"作者回复","comment_id":13527,"uid":"1098920","ip_address":"","utype":1,"ctime":1529725971,"user_name_real":"华仔"}],"discussion_count":1,"race_medal":0,"score":"18709591688","product_id":100006601,"comment_content":"你好，我是小白，针对单reactor,多线程的方式，负责处理业务的processor的子线程，是在什么时候创建，由谁创建，每来一个新链接，都要创建一个新的子线程吗？","like_count":4,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419678,"discussion_content":"代码实现请参考Doug Lee关于NIO的PPT","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529725971,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12165,"user_name":"Bayern","can_delete":false,"product_type":"c1","uid":1138274,"ip_address":"","ucode":"0513DCD192061D","user_header":"https://static001.geekbang.org/account/avatar/00/11/5e/62/7cfd82c5.jpg","comment_is_top":false,"comment_ctime":1528629669,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18708498853","product_id":100006601,"comment_content":"我能不能这样理解reactor，IO操作用一个连接池来获取连接，处理用线程池来处理任务。将IO和计算解耦开。这样就避免了在IO和计算不平衡时造成的浪费，导致性能低下。老师，我这样理解对吗","like_count":4},{"had_liked":false,"id":38944,"user_name":"FelixSun","can_delete":false,"product_type":"c1","uid":1289035,"ip_address":"","ucode":"C52A87C7F3D672","user_header":"https://static001.geekbang.org/account/avatar/00/13/ab/4b/01c56dda.jpg","comment_is_top":false,"comment_ctime":1542160957,"is_pvip":false,"replies":[{"id":"13957","content":"连接你理解为tcp连接，请求你理解为一次sql语句执行","user_name":"作者回复","comment_id":38944,"uid":"1098920","ip_address":"","utype":1,"ctime":1542195326,"user_name_real":"华仔"}],"discussion_count":1,"race_medal":0,"score":"14427062845","product_id":100006601,"comment_content":"小白有一个问题困扰了好几天，可能也是经验不足没接触过这方面，请问一下。这里反复说的连接和请求究竟是什么意思？我查了一些资料，用MySQL举例，是不是说，mysql的连接数就是指的连接，mysql在最大连接数下支持的一秒内的请求处理数量是指的请求？","like_count":3,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428856,"discussion_content":"连接你理解为tcp连接，请求你理解为一次sql语句执行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542195326,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":14980,"user_name":"周飞","can_delete":false,"product_type":"c1","uid":1073374,"ip_address":"","ucode":"F85FA236EB0C0D","user_header":"https://static001.geekbang.org/account/avatar/00/10/60/de/5c67895a.jpg","comment_is_top":false,"comment_ctime":1530780859,"is_pvip":false,"replies":[{"id":"5049","content":"我理解这就是Reactor模式","user_name":"作者回复","comment_id":14980,"uid":"1098920","ip_address":"","utype":1,"ctime":1530785075,"user_name_real":"华仔"}],"discussion_count":1,"race_medal":0,"score":"14415682747","product_id":100006601,"comment_content":"nodejs的异步模型是io线程池来监听io，然后通过管道通信来通知事件循环的线程。事件循环线程调用主线程注册的回调函数来实现的。不知道这种模式跟今天说的两种相比有什么优缺点啊","like_count":3,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420199,"discussion_content":"我理解这就是Reactor模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530785075,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12130,"user_name":"衣申人","can_delete":false,"product_type":"c1","uid":1115777,"ip_address":"","ucode":"887FE9109B97DE","user_header":"https://static001.geekbang.org/account/avatar/00/11/06/81/28418795.jpg","comment_is_top":false,"comment_ctime":1528604430,"is_pvip":false,"replies":[{"id":"3960","content":"1. 处理线程将返回结果包装成一个事件，触发write事件，详细可以看看Doug Lee的NIO PPT，处理线程和业务线程共享selector，key这些对象<br>2. io线程与业务线程分开就是单reactor多线程，多reactor如果再分开的话，性能没有提升，复杂度提升很多，我还没见过这种处理方式","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1528615351,"ip_address":"","comment_id":12130,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14413506318","product_id":100006601,"comment_content":"华仔，我有两个疑问:<br>1.单reactor多线程模式，业务处理之后，处理线程将结果传输给reactor线程去send，这个具体能怎么实现？reactor既要等待网络事件，又要等待业务线程的处理结果，然后作出响应，这个除了两边轮询还有更直接的方式吗？<br>2.多reactor多线程模型，现在你给出的方案是连接线程与io线程分开，但io线程与业务处理在一起的。而有的资料建议将io线程和业务线程分开，你认为有这个必要吗？<br>","like_count":3,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419132,"discussion_content":"1. 处理线程将返回结果包装成一个事件，触发write事件，详细可以看看Doug Lee的NIO PPT，处理线程和业务线程共享selector，key这些对象\n2. io线程与业务线程分开就是单reactor多线程，多reactor如果再分开的话，性能没有提升，复杂度提升很多，我还没见过这种处理方式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528615351,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11993,"user_name":"码钉","can_delete":false,"product_type":"c1","uid":1054988,"ip_address":"","ucode":"5C6946AC6453A4","user_header":"https://static001.geekbang.org/account/avatar/00/10/19/0c/0fb4a739.jpg","comment_is_top":false,"comment_ctime":1528506678,"is_pvip":true,"replies":[{"id":"3980","content":"包括从驱动读取到内核以及从内核读取到用户空间","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1528617732,"ip_address":"","comment_id":11993,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14413408566","product_id":100006601,"comment_content":"Proactor 可以理解为“来了事件我来处理，处理完了我通知你”。<br><br>请问一下这里的“处理”具体指什么? 把数据从内核层复制到应用层么?","like_count":3,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419073,"discussion_content":"包括从驱动读取到内核以及从内核读取到用户空间","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528617732,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179834,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1582107247,"is_pvip":false,"replies":[{"id":"69935","content":"你搜索一下Doug Lee NIO 这个PPT","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1582191455,"ip_address":"","comment_id":179834,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10172041839","product_id":100006601,"comment_content":"老师，可以发一下reactor编码实现的官方连接吗？","like_count":2,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484420,"discussion_content":"你搜索一下Doug Lee NIO 这个PPT","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582191455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1336475,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","nickname":"J.Smile","note":"","ucode":"C4D98DFDBF7584","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":178756,"discussion_content":"OK","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582194786,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":39996,"user_name":"志学","can_delete":false,"product_type":"c1","uid":1184561,"ip_address":"","ucode":"1D03847EC66A83","user_header":"https://static001.geekbang.org/account/avatar/00/12/13/31/2a44f119.jpg","comment_is_top":false,"comment_ctime":1542433059,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10132367651","product_id":100006601,"comment_content":"I&#47;O模型分为阻塞I&#47;O，非阻塞I&#47;O，I&#47;O多路复用，信号驱动I&#47;O，异步I&#47;O五种类型。本文提到的reactor模式应属于，I&#47;O多路复用；proactor模式应属于异步I&#47;O。","like_count":2},{"had_liked":false,"id":17045,"user_name":"21克","can_delete":false,"product_type":"c1","uid":1045053,"ip_address":"","ucode":"D22881BCE136BF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f2/3d/656b66f0.jpg","comment_is_top":false,"comment_ctime":1532395819,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10122330411","product_id":100006601,"comment_content":"佩服佩服","like_count":2},{"had_liked":false,"id":16104,"user_name":"沙亮亮","can_delete":false,"product_type":"c1","uid":1099492,"ip_address":"","ucode":"E6CF0D5B1E6691","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/e4/ec572f55.jpg","comment_is_top":false,"comment_ctime":1531788114,"is_pvip":false,"replies":[{"id":"5561","content":"1. 轮询理解OK<br>2. php-fpm我没有深入研究，你可以自己研究一下，这样学习效果会更好😄","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1531791681,"ip_address":"","comment_id":16104,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10121722706","product_id":100006601,"comment_content":"两个轮询不是一个意思，select和poll是收到通知后轮询socket列表看看哪个socket可以读，普通的socket轮询是指重复调用read操作<br><br>感谢大神回复，那对于select实现的I&#47;O多路复用技术，和普通的轮询区别在于，一个是socket上有数据时，系统通知select，然后select去轮询所有的socket，而普通的轮询就是一直不停的轮询所有socket。<br><br>还有一个有关真实应用场景中的问题，对于nginx+php-fpm这样一个场景，对于I&#47;O多路复用技术，在nginx处理外部请求的时候用到了Reactor模式。当nginx把请求转发给php-fpm，然后php通过读数据库，代码业务逻辑处理完后，再从php−fpm读取数据，返回给客户端请求过程中，有没有再使用Reactor模式了？","like_count":2,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420669,"discussion_content":"1. 轮询理解OK\n2. php-fpm我没有深入研究，你可以自己研究一下，这样学习效果会更好😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1531791681,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":292419,"user_name":"mxmkeep","can_delete":false,"product_type":"c1","uid":1309377,"ip_address":"","ucode":"7068125FE98AB1","user_header":"","comment_is_top":false,"comment_ctime":1620812952,"is_pvip":false,"replies":[{"id":"105909","content":"多谢提醒，Linux 3.9支持 reuseport，Nginx已经可以不用锁，而直接让内核来做负载均衡了。<br><br>官方文档：https:&#47;&#47;www.nginx.com&#47;blog&#47;socket-sharding-nginx-release-1-9-1&#47; ","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1620869475,"ip_address":"","comment_id":292419,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5915780248","product_id":100006601,"comment_content":"nginx已经默认废弃使用锁来均衡accept，而是使用设置socket reuse来让内核负载均衡到各进程","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519821,"discussion_content":"多谢提醒，Linux 3.9支持 reuseport，Nginx已经可以不用锁，而直接让内核来做负载均衡了。\n\n官方文档：https://www.nginx.com/blog/socket-sharding-nginx-release-1-9-1/ ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620869475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":280652,"user_name":"公号-彤哥读源码","can_delete":false,"product_type":"c1","uid":1239881,"ip_address":"","ucode":"C0D16E1BA12DA0","user_header":"https://static001.geekbang.org/account/avatar/00/12/eb/49/bd914b5f.jpg","comment_is_top":false,"comment_ctime":1614305601,"is_pvip":false,"replies":[{"id":"101887","content":"你说的我都看过，你具体是不同意哪句话，从你的答案看不出来。<br><br>针对第3点，你说的没错，我的意思是只要有某个事件业务处理慢，不管你是放在IO线程中，还是放在业务线程中，最后都会导致系统整体变慢，因为业务线程也是有一定数量的，单纯IO处理快，从全流程来看并没有很大作用。<br><br>Redis单进程都可以做到高性能，原因就是单个业务操作非常快，所以说用不用独立的业务线程，并不是高性能的关键，但是用独立的业务线程，复杂度肯定会变高的。","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1614309125,"ip_address":"","comment_id":280652,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5909272897","product_id":100006601,"comment_content":"关于下面同学说的Reactor主从模型中业务处理使用另外的线程池处理，我不同意老师的观点哈，原因有三点：<br>1. Doug Lea在《Scalable IO in Java》中关于Reactor主从的讲解用的确实是这位同学说的业务线程池独立出来处理；<br>2. Netty中的io.netty.channel.ChannelPipeline#addLast(io.netty.util.concurrent.EventExecutorGroup, java.lang.String, io.netty.channel.ChannelHandler)方法是可以支持你的Handler定制一个线程池来处理的，Netty中的线程池就是这里的EventExecutorGroup，Netty的Handler使用另外的线程池处理的时候一样使用ctx.write()操作写出数据，此时会判断在不在EventLoop中，如果不在就异步放到EventLoop中写出数据，老师可以看下这块的源码io.netty.channel.AbstractChannelHandlerContext#write(java.lang.Object, boolean, io.netty.channel.ChannelPromise)，简单点来说，就是我们不用关心read&#47;write操作与自定义线程池的交互，Netty都帮我们处理好了。<br>3. 实际场景中确实存在业务处理耗时的情况，比如写数据库，而Netty中是一个EventLoop（线程）监听多个连接的事件，如果业务处理跟IO放一块一个事件业务处理慢容易导致这个EventLoop监听的事件都阻塞住；<br><br>关于Doug Lea的《Scalable IO in Java》我放在gitee上了，欢迎下载：https:&#47;&#47;gitee.com&#47;alan-tang-tt&#47;reactor","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516167,"discussion_content":"你说的我都看过，你具体是不同意哪句话，从你的答案看不出来。\n\n针对第3点，你说的没错，我的意思是只要有某个事件业务处理慢，不管你是放在IO线程中，还是放在业务线程中，最后都会导致系统整体变慢，因为业务线程也是有一定数量的，单纯IO处理快，从全流程来看并没有很大作用。\n\nRedis单进程都可以做到高性能，原因就是单个业务操作非常快，所以说用不用独立的业务线程，并不是高性能的关键，但是用独立的业务线程，复杂度肯定会变高的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1614309125,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248425,"user_name":"🐗Jinx","can_delete":false,"product_type":"c1","uid":1711790,"ip_address":"","ucode":"B5C084F54BF66A","user_header":"https://static001.geekbang.org/account/avatar/00/1a/1e/ae/a6d5e24a.jpg","comment_is_top":false,"comment_ctime":1600159155,"is_pvip":false,"replies":[{"id":"91370","content":"每个reactor一定有一个epoll之类的多路复用对象","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1600394086,"ip_address":"","comment_id":248425,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5895126451","product_id":100006601,"comment_content":"老师我想问一下。在多Reactor多进程&#47;线程模式下，是不是需要为每一个Reactor创建一个epoll实例。例如，主Reactor需要一个监听epoll实例用于accept新的链接，然后需要为每一个从Reactor创建一个读写epoll实例。<br><br>因为如果多个Reactor共享同一个epoll实例，就会出现很多维护问题，例如某个Reactor可能会更改或者删除掉别的Reactor的关注文件描述符。","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505645,"discussion_content":"每个reactor一定有一个epoll之类的多路复用对象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600394086,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181863,"user_name":"有米","can_delete":false,"product_type":"c1","uid":1005042,"ip_address":"","ucode":"C9A10B7A67BC12","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/f2/ba68d931.jpg","comment_is_top":false,"comment_ctime":1582646981,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5877614277","product_id":100006601,"comment_content":"貌似tomcat 架构就是多 Reactor 多线程模式","like_count":1},{"had_liked":false,"id":21443,"user_name":"李继鹏","can_delete":false,"product_type":"c1","uid":1134510,"ip_address":"","ucode":"18522BEF3B70A4","user_header":"https://static001.geekbang.org/account/avatar/00/11/4f/ae/7614163c.jpg","comment_is_top":false,"comment_ctime":1535083596,"is_pvip":true,"replies":[{"id":"7595","content":"支持的，netty的NioDatagramChannel了解一下，直接用epoll也可以，epoll只管监听socket，tcp和udp都可以，差别在于udp只有一个socket描述符，因此只能用单Reactor","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1535092042,"ip_address":"","comment_id":21443,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5830050892","product_id":100006601,"comment_content":"李老师能讲一下udp服务是否能用reactor模型吗？网上这方面的资料甚少","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422678,"discussion_content":"支持的，netty的NioDatagramChannel了解一下，直接用epoll也可以，epoll只管监听socket，tcp和udp都可以，差别在于udp只有一个socket描述符，因此只能用单Reactor","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535092042,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12565,"user_name":"爱逃课的橡皮擦","can_delete":false,"product_type":"c1","uid":1102751,"ip_address":"","ucode":"C3E9971E48CAC8","user_header":"https://static001.geekbang.org/account/avatar/00/10/d3/9f/f3bcd2d0.jpg","comment_is_top":false,"comment_ctime":1528916667,"is_pvip":false,"replies":[{"id":"4149","content":"看看epoll的原理，一个epoll对象可以注册很多连接，不用轮询的原因在于epoll注册了一个回调函数到内核驱动","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1528941023,"ip_address":"","comment_id":12565,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5823883963","product_id":100006601,"comment_content":"“当多条连接共用一个阻塞对象后，进程只需要在一个阻塞对象上等待，而无须再轮询所有连接“ 华仔你好，这句话能详细解释下吗，多条连接怎么公用一个阻塞对象，为什么解决了轮训的问题，连接处于什么事件不去轮询怎么知道，是说自己不去轮询系统帮你轮询吗","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419297,"discussion_content":"看看epoll的原理，一个epoll对象可以注册很多连接，不用轮询的原因在于epoll注册了一个回调函数到内核驱动","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528941023,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12023,"user_name":"王磊","can_delete":false,"product_type":"c1","uid":1050085,"ip_address":"","ucode":"A4DE9804642A08","user_header":"https://static001.geekbang.org/account/avatar/00/10/05/e5/aa579968.jpg","comment_is_top":false,"comment_ctime":1528519869,"is_pvip":false,"replies":[{"id":"3972","content":"vert.x在linux平台应该是reactor的。<br>单reactor单进程&#47;线程是指reactor和handler都在同一进程&#47;线程中运行，不是reactor占一个线程，handler占一个线程，redis的模型就是这样的，redis业务处理是单进程的","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1528616608,"ip_address":"","comment_id":12023,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5823487165","product_id":100006601,"comment_content":"我们用的是Vertx, 我了解它是多Reactor, 多线程的模式，Reactor只负责消息的分发，耗时的操作都在专有的线程池内操作，也可以方便的指定新的线程池的名字在自己的线程池内运行。<br>问题，这里明确一个定义，说单Reactor单进程&#47;线程的时候，是否包含了Reactor的进程&#47;线程? 理解应该没有，所以&#39;单Reactor单进程&#47;线程&#39;应该有2个进程&#47;线程在工作?","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419086,"discussion_content":"vert.x在linux平台应该是reactor的。\n单reactor单进程/线程是指reactor和handler都在同一进程/线程中运行，不是reactor占一个线程，handler占一个线程，redis的模型就是这样的，redis业务处理是单进程的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528616608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12001,"user_name":"性能","can_delete":false,"product_type":"c1","uid":1137192,"ip_address":"","ucode":"BBFA2A31B02B8F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIyhbzdkFM64HvRATbWjc3hkic7icUszl9hU9hpIMZcibKH4wWam4SHfkcvM7MUoKjGDRrvYGXuvR91Q/132","comment_is_top":false,"comment_ctime":1528509355,"is_pvip":false,"replies":[{"id":"3978","content":"这也是一种方式，但性能就需要好好设计了","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1528617672,"ip_address":"","comment_id":12001,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5823476651","product_id":100006601,"comment_content":"如果为了保证消息入库的顺序性，最好采用单Reactor单线程的模式。","like_count":1,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419077,"discussion_content":"这也是一种方式，但性能就需要好好设计了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528617672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":354258,"user_name":"宇飞","can_delete":false,"product_type":"c1","uid":1105513,"ip_address":"广东","ucode":"D64C53CD189164","user_header":"https://static001.geekbang.org/account/avatar/00/10/de/69/113da382.jpg","comment_is_top":false,"comment_ctime":1660221539,"is_pvip":false,"replies":[{"id":"129487","content":"有一定道理，但是标准的解释关注的是IO准备和数据拷贝，详细参考《UNIX网络编程 卷1》第5章","user_name":"作者回复","user_name_real":"编辑","uid":"1098920","ctime":1661763319,"ip_address":"广东","comment_id":354258,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1660221539","product_id":100006601,"comment_content":"阻塞是对内核说的，同步异步对用户态而言","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585683,"discussion_content":"有一定道理，但是标准的解释关注的是IO准备和数据拷贝，详细参考《UNIX网络编程 卷1》第5章","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661763319,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":348207,"user_name":"王奎-kevin","can_delete":false,"product_type":"c1","uid":2642771,"ip_address":"","ucode":"20099AF686DB3F","user_header":"https://static001.geekbang.org/account/avatar/00/28/53/53/bf842662.jpg","comment_is_top":false,"comment_ctime":1654845859,"is_pvip":false,"replies":[{"id":"126941","content":"客户端要想升P8，具备一定的架构知识是必须的","user_name":"作者回复","user_name_real":"编辑","uid":"1098920","ctime":1655123398,"ip_address":"","comment_id":348207,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1654845859","product_id":100006601,"comment_content":"做客户端的路过，发现这些都是服务端的内容","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575821,"discussion_content":"客户端要想升P8，具备一定的架构知识是必须的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655123398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336361,"user_name":"delicate","can_delete":false,"product_type":"c1","uid":1187083,"ip_address":"","ucode":"AE262751C50CDD","user_header":"https://static001.geekbang.org/account/avatar/00/12/1d/0b/5f353b88.jpg","comment_is_top":false,"comment_ctime":1646112486,"is_pvip":false,"replies":[{"id":"123188","content":"是的，可以看看《UNIX网络编程 卷一》第6章","user_name":"作者回复","user_name_real":"编辑","uid":"1098920","ctime":1646642230,"ip_address":"","comment_id":336361,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1646112486","product_id":100006601,"comment_content":"可否理解为 Proactor 模型只是将 Reactor 模型中的 I&#47;O 操作转换成了异步，其他流程其实二者大同小异？从图中示意图看起来是这样🤔","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554853,"discussion_content":"是的，可以看看《UNIX网络编程 卷一》第6章","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646642230,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328562,"user_name":"Geek3443","can_delete":false,"product_type":"c1","uid":2028946,"ip_address":"","ucode":"C6351639FD0633","user_header":"","comment_is_top":false,"comment_ctime":1640773252,"is_pvip":false,"replies":[{"id":"119761","content":"1. 是的<br>2. 预先创建的线程池","user_name":"作者回复","user_name_real":"编辑","uid":"1098920","ctime":1640838775,"ip_address":"","comment_id":328562,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1640773252","product_id":100006601,"comment_content":"新人不懂，有点疑惑，辛苦老师解答，<br>1.单reator多线程，单reator是指一个reator线程，监听多个连接吗？无论来多少个连接，reator线程的thread_id一直是一个吗？<br>2.多线程（处理）的数量有限制吗，不能来一个连接，就弄一个新处理线程吧，有数量限制吗？<br>辛苦","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542768,"discussion_content":"1. 是的\n2. 预先创建的线程池","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640838775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1592279,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","nickname":"William Ning","note":"","ucode":"4DB8D05E69E5F3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570994,"discussion_content":"FYI：\n不论进程还是线程，都不可能做到无限制创建，因为受限于硬件资源～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652023764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322065,"user_name":"刘磊","can_delete":false,"product_type":"c1","uid":2231430,"ip_address":"","ucode":"B2222602633B76","user_header":"https://static001.geekbang.org/account/avatar/00/22/0c/86/2c64563f.jpg","comment_is_top":false,"comment_ctime":1637153583,"is_pvip":false,"replies":[{"id":"117030","content":"如果是用线程，那很好处理；如果是进程，可以用socketpair来传递文件描述符，不过nginx不是用文件描述符传递，而是稍微改了一下，用多进程来accept同一个listening socket","user_name":"作者回复","user_name_real":"编辑","uid":"1098920","ctime":1637310003,"ip_address":"","comment_id":322065,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1637153583","product_id":100006601,"comment_content":"父进程中 mainReactor 对象通过 select 监控连接建立事件，收到事件后通过 Acceptor 接收，将新的连接分配给某个子进程。<br>这里最后一句话我没太明白，我理解新的连接就是accept()返回的一个fd嘛，它怎么分配给子进程？每次都fork子进程吗？","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531427,"discussion_content":"如果是用线程，那很好处理；如果是进程，可以用socketpair来传递文件描述符，不过nginx不是用文件描述符传递，而是稍微改了一下，用多进程来accept同一个listening socket","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637310003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319693,"user_name":"L.","can_delete":false,"product_type":"c1","uid":1181647,"ip_address":"","ucode":"46A2F679C094E8","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/cf/b0d6fe74.jpg","comment_is_top":false,"comment_ctime":1635912164,"is_pvip":false,"replies":[{"id":"115930","content":"1万个连接也就1万个handler，1万个对象并不多哦","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1635947369,"ip_address":"","comment_id":319693,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1635912164","product_id":100006601,"comment_content":"老师您好，Acceptor 通过 accept 接受连接，并创建一个 Handler 来处理连接后续的各种事件。<br>是不是每来一个链接就会生成一个Handler啊？那岂不是会很多？不会用性能问题吗？","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529725,"discussion_content":"1万个连接也就1万个handler，1万个对象并不多哦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635947369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":291523,"user_name":"金尚","can_delete":false,"product_type":"c1","uid":1661060,"ip_address":"","ucode":"70C19FE3C984B0","user_header":"https://static001.geekbang.org/account/avatar/00/19/58/84/a8aac073.jpg","comment_is_top":false,"comment_ctime":1620347104,"is_pvip":true,"replies":[{"id":"105596","content":"你在Linux上用Netty就是用了Reactor，你在Window上用IOCP就是用了Proactor","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1620348402,"ip_address":"","comment_id":291523,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1620347104","product_id":100006601,"comment_content":"没看懂这两个模式具体实践中怎么使用呢。麻烦指导下。","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519493,"discussion_content":"你在Linux上用Netty就是用了Reactor，你在Window上用IOCP就是用了Proactor","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620348402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284878,"user_name":"GeekZY","can_delete":false,"product_type":"c1","uid":2432609,"ip_address":"","ucode":"791121B62AFCDB","user_header":"","comment_is_top":false,"comment_ctime":1616507982,"is_pvip":false,"replies":[{"id":"103354","content":"Spring Boot基于HTTP协议的，HTTP协议本身的解析非常耗性能，我们之前实测Hello world，16核或者32核的机器，单机TPS也就1.5万左右（核数增加对性能作用不大），所以如果你用Spring Boot + HTTP，单机性能不可能达到10万。<br><br>单机达到10万，目前有Nginx、Redis、Memcache，基本都是C&#47;C++语言编写，基于Reactor模式的。<br><br>因此，如果你想用Spring Boot达到10万，那就不能用HTTP协议，但是不用HTTP的话，用Spring Boot的优势就没有了。","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1616547396,"ip_address":"","comment_id":284878,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1616507982","product_id":100006601,"comment_content":"老师，在微服务架构，SpringBoot应用，单机性能要达到10万，用什么方案比较合适？","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517498,"discussion_content":"Spring Boot基于HTTP协议的，HTTP协议本身的解析非常耗性能，我们之前实测Hello world，16核或者32核的机器，单机TPS也就1.5万左右（核数增加对性能作用不大），所以如果你用Spring Boot + HTTP，单机性能不可能达到10万。\n\n单机达到10万，目前有Nginx、Redis、Memcache，基本都是C/C++语言编写，基于Reactor模式的。\n\n因此，如果你想用Spring Boot达到10万，那就不能用HTTP协议，但是不用HTTP的话，用Spring Boot的优势就没有了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616547396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2432609,"avatar":"","nickname":"GeekZY","note":"","ucode":"791121B62AFCDB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361008,"discussion_content":"哪阿里的秒杀系统是怎么做的？加大量机器，采用Docker，增加弹性伸缩性吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616578340,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284549,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1616331231,"is_pvip":true,"replies":[{"id":"103206","content":"1. Windows的IOCP就是Proactor模式，Linux的epoll就是Reactor，IOCP实测性能和epoll相差很小，但是IOCP的复杂度要高不少，有很多异常情况处理比较麻烦。<br><br>2. 参考TCP&#47;IP之类的协议，设计出你的任务的状态图，然后对照状态图来实现。","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1616389741,"ip_address":"","comment_id":284549,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1616331231","product_id":100006601,"comment_content":"简单总结下我理解的Reactor和Proactor吧，这两者本质上使用两种方式优化性能：复用等待线程和异步IO<br>1、整个程序处理流程是accept、等待请求到来、等待内核准备好所需数据(read)、业务处理、结果持久化或回传（write）。其中accept基本就是一锤子的买卖，重复请求导致的重复阻塞主要是等待请求、read、handler和write，reactor复用等待线程，一个线程处理多个请求到来(select)，read、handle和write再分别异步，或者select也异步分别组合成为文中的三种模式<br>2、Proactor在reactor基础之上把内核准备数据等待、结果回写这两个操作也异步了<br>到此，我有两个问题想请教下华仔：<br>1、Proactor相比与多reactor多线程模式，复杂度增加的真不是一星半点，有点感觉能异步就都异步，但这带来的收益较复杂度的增加，孰多孰少呀<br>2、这是不是有点像一个任务，把其中可以复用和异步的地方都单独处理了，那么若每个步骤之间存在关联关系，是不是需要一个类似统筹全局的角色来做一些异常分析、兜底操作之类的。因为工作中就有一个任务，步骤多，涉及到很多的IO，一开始这么设计，没考虑彼此之间的关联关系，现在异常处理就很麻烦，基本只能持久化+状态驱动，所以想请教下华仔，有没有啥好的建议？还是我这么设计有点过度的意思了","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517387,"discussion_content":"1. Windows的IOCP就是Proactor模式，Linux的epoll就是Reactor，IOCP实测性能和epoll相差很小，但是IOCP的复杂度要高不少，有很多异常情况处理比较麻烦。\n\n2. 参考TCP/IP之类的协议，设计出你的任务的状态图，然后对照状态图来实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616389741,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":283340,"user_name":"longslee","can_delete":false,"product_type":"c1","uid":1465986,"ip_address":"","ucode":"C24E32E5B1B6F5","user_header":"https://static001.geekbang.org/account/avatar/00/16/5e/82/438c8534.jpg","comment_is_top":false,"comment_ctime":1615715108,"is_pvip":false,"replies":[{"id":"102803","content":"后续所有的read、write操作都在子进程完成了，不会再回到主进程。","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1615769719,"ip_address":"","comment_id":283340,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1615715108","product_id":100006601,"comment_content":"“主要原因在于如果采用多进程，子进程完成业务处理后，将结果返回给父进程，并通知父进程发送给哪个 client，这是很麻烦的事情。”   老师，咨询一下， UNIX 的 socket 在收到一个连接的时候，就 fork 一个子进程，为什么就没这个问题呢？","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517001,"discussion_content":"后续所有的read、write操作都在子进程完成了，不会再回到主进程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615769719,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257081,"user_name":"Lee","can_delete":false,"product_type":"c1","uid":1085120,"ip_address":"","ucode":"158E29C62897CC","user_header":"https://static001.geekbang.org/account/avatar/00/10/8e/c0/7e70b689.jpg","comment_is_top":false,"comment_ctime":1603849166,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603849166","product_id":100006601,"comment_content":"IO一直是性能的关键瓶颈，主要取决于冯诺依曼的理论结构及计算机硬件技术本质上从未本质改变，比如内存IO消耗cpu时间单元比磁盘IO快约100万倍（具体看磁盘参数性能），引导了生态在广义架构、软件体系等等都在不同的环节增量优化，单机、集群、分布式、缓存、多进程多线程、服用异步就这么一步步地产生了，这种分析原理的文章是最值得读的，帮助从底层理解，架构师需要这种底层知识修炼，具体场景中具备了这种基础的认知设计架构那就是招式的变换问题，可以灵活应用","like_count":0},{"had_liked":false,"id":249551,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1600689843,"is_pvip":true,"replies":[{"id":"91873","content":"不需要啃完800页，多路复用也就第6章的内容，大概30页","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1601431817,"ip_address":"","comment_id":249551,"utype":1}],"discussion_count":1,"race_medal":2,"score":"1600689843","product_id":100006601,"comment_content":"没有接触过 Reactor 与 Proactor 模式，可能是之前处理过的业务都没有要求高性能。好在留言里面的接地气的“打比方”：排队交钱打饭的食堂模式就是同步阻塞，Reactor 是饭好了叫号，Proactor 是服务员送餐。<br><br>Redis 是单 Reactor 单进程。<br><br>Ngnix（C 语言） 是多 Reactor 多进程，Memcache（C 语言） 和 Netty（Java 语言） 是多 Reactor 多线程。<br><br>对于思考题，一开始我觉的“前浪微博”可以使用单 Reactor 单进程，主要是考虑和 Redis 类似，读多写少；后来看了一些留言（不明觉厉），可能单 Reactor 多线程是更好的方案。<br><br>不过想要搞明白的话，估计要去啃那本《Unix 网络编程》了，800 多页。","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505953,"discussion_content":"不需要啃完800页，多路复用也就第6章的内容，大概30页","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601431817,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244172,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1598417617,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1598417617","product_id":100006601,"comment_content":"accept可以多个进程用同一个socket<br>","like_count":0},{"had_liked":false,"id":244171,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1598417515,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1598417515","product_id":100006601,"comment_content":"nginx的acceptor","like_count":0},{"had_liked":false,"id":173768,"user_name":"雨落漂洋","can_delete":false,"product_type":"c1","uid":1127624,"ip_address":"","ucode":"9D53DB4482AA24","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKPmOyph1XeszC69tTLENkZFJqjJ7CqtxlSpNEiaonB9ebLnKEh8w7gk7TXQiay4JvA0fQtLYKw718Q/132","comment_is_top":false,"comment_ctime":1579681597,"is_pvip":false,"replies":[{"id":"69952","content":"Proactor是操作系统来发事件通知，actor是各个对象自己发通知，actor严格意义来说不是一种高并发网络编程模式，而是一个架构模式。","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1582192713,"ip_address":"","comment_id":173768,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1579681597","product_id":100006601,"comment_content":"actor框架模型是一种异步并发的模型，和Proactor是什么关系？","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482201,"discussion_content":"Proactor是操作系统来发事件通知，actor是各个对象自己发通知，actor严格意义来说不是一种高并发网络编程模式，而是一个架构模式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582192713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170980,"user_name":"CDz","can_delete":false,"product_type":"c1","uid":1114779,"ip_address":"","ucode":"A23BEE1C4A5922","user_header":"https://static001.geekbang.org/account/avatar/00/11/02/9b/b1a3c60d.jpg","comment_is_top":false,"comment_ctime":1578808438,"is_pvip":false,"replies":[{"id":"66695","content":"1. 理解正确<br>2. Redis是单Reactor单进程，处理的是网络编程的accept，read，write这些请求","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1579078853,"ip_address":"","comment_id":170980,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578808438","product_id":100006601,"comment_content":"你好，最近一直好奇Redis的IO多路复用是一个什么东西，查阅了比较多资料。<br><br>作者写的特别清晰明了，感谢作者。<br><br>因为很多讲述IO多路复用是从底层系统API讲起（select&#47;epoll）。<br><br>但还是有两个小问题想请教：<br><br>1.我理解的是IO多路复用是一个编程思想，通过系统提供API实现。不知道理解的对不对。<br><br>2.Redis的单Reactor单线程模型，处理的到底是网络请求IO，还是数据读写IO？还是这是通用设计，两者都会使用到呢？<br><br>","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481194,"discussion_content":"1. 理解正确\n2. Redis是单Reactor单进程，处理的是网络编程的accept，read，write这些请求","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579078853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169340,"user_name":"技术修行者","can_delete":false,"product_type":"c1","uid":1013147,"ip_address":"","ucode":"28CA41A1214D6B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/9b/611e74ab.jpg","comment_is_top":false,"comment_ctime":1578318621,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1578318621","product_id":100006601,"comment_content":"I&#47;O 多路复用技术归纳起来有两个关键实现点：<br>1. 当多条连接共用一个阻塞对象后，进程只需要在一个阻塞对象上等待，而无须再轮询所有连接，常见的实现方式有 select、epoll、kqueue 等。<br>2. 当某条连接有新的数据可以处理时，操作系统会通知进程，进程从阻塞状态返回，开始进行业务处理。<br><br> Reactor 模式有这三种典型的实现方案：<br>1. 单 Reactor 单进程 &#47; 线程。<br>2. 单 Reactor 多线程。<br>3. 多 Reactor 多进程 &#47; 线程。","like_count":0},{"had_liked":false,"id":155815,"user_name":"我有切糕","can_delete":false,"product_type":"c1","uid":1104447,"ip_address":"","ucode":"B02DB48B30ED47","user_header":"https://static001.geekbang.org/account/avatar/00/10/da/3f/155d81ef.jpg","comment_is_top":false,"comment_ctime":1574760687,"is_pvip":false,"replies":[{"id":"63235","content":"没有笔误，这里讨论的是选单进程还是单线程","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1577329631,"ip_address":"","comment_id":155815,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574760687","product_id":100006601,"comment_content":"“C 语言编写系统的一般使用单 Reactor 单进程，因为没有必要在进程中再创建线程；而 Java 语言编写的一般使用单 Reactor 单线程，因为 Java 虚拟机是一个进程，虚拟机中有很多线程，业务线程只是其中的一个线程而已。” 这里是笔误吗，Java语言一般使用的单Reactor多线程吧？","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475882,"discussion_content":"没有笔误，这里讨论的是选单进程还是单线程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577329631,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146926,"user_name":"阴建锋","can_delete":false,"product_type":"c1","uid":1484805,"ip_address":"","ucode":"C04E0C675C4ED2","user_header":"https://static001.geekbang.org/account/avatar/00/16/a8/05/90b5b097.jpg","comment_is_top":false,"comment_ctime":1572703368,"is_pvip":false,"replies":[{"id":"57777","content":"你可以自己查查，类似的资料很多，查了后有问题咱们基于问题交流","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1573474729,"ip_address":"","comment_id":146926,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572703368","product_id":100006601,"comment_content":"老师  tomcat是那种方式？一个请求一个线程？","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473058,"discussion_content":"你可以自己查查，类似的资料很多，查了后有问题咱们基于问题交流","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573474729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142261,"user_name":"shinee_x_X","can_delete":false,"product_type":"c1","uid":1605962,"ip_address":"","ucode":"98529C77B052AC","user_header":"https://static001.geekbang.org/account/avatar/00/18/81/4a/dcc563fb.jpg","comment_is_top":false,"comment_ctime":1571321888,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571321888","product_id":100006601,"comment_content":"看了这么多张关于reactor描述的文章，这篇是让我真正读懂的一章","like_count":0},{"had_liked":false,"id":138921,"user_name":"开心小毛","can_delete":false,"product_type":"c1","uid":1023762,"ip_address":"","ucode":"9D57A2773759F3","user_header":"","comment_is_top":false,"comment_ctime":1570507747,"is_pvip":false,"replies":[{"id":"53549","content":"不会，processor在独立的线程中完成任务，然后将结果直接返回或者通过队列等方式发给handler返回","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1570530436,"ip_address":"","comment_id":138921,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1570507747","product_id":100006601,"comment_content":"在单reactor多线程一段中提到：“Processor 会在独立的子线程中完成真正的业务处理，然后将响应结果发给主进程的 Handler 处理；”  是说Handler会阻塞在Processor的调用上么？","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469702,"discussion_content":"不会，processor在独立的线程中完成任务，然后将结果直接返回或者通过队列等方式发给handler返回","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570530436,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1023762,"avatar":"","nickname":"开心小毛","note":"","ucode":"9D57A2773759F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":25537,"discussion_content":"Handlers是以sessionId-to-handler字典形式存放在non-blocking socket所在的线程中的么？抑或是handler通过executor线程池异步调用Processor线程，在processor异步生成结果后handler的发送逻辑又被另一executor线程池被调用？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570537008,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":128839,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1566972614,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566972614","product_id":100006601,"comment_content":"先跳过，补上网络通信相关的知识再回头看一下，感觉有些晦涩。当然，主要是这块基础知识不够。<br>如果让我讲，我会从最简单的一次连接怎么建立的？一次最简单的请求怎么发送怎么处理怎么响应的？这么个过程都有那些关键环节？那些环节最耗时？我觉得，写这块牛逼代码的人员也是接到了一个性能优化的需求，然后他通过分析定位到性能瓶颈在哪里？然后通过思考提出优化方案，也经过了多个版本，我想这就是各种网络通信模式的发展喝演化史啦！估计这样我完全能能明白，这些玩意是啥东西啦！<br>看完本文后居然没明白哪里慢？怎么弄后就快了的原因？惭愧！发现自己对于比喻很容易理解，对于有些技术原理不很感冒！","like_count":0},{"had_liked":false,"id":128823,"user_name":"Geek_88604f","can_delete":false,"product_type":"c1","uid":1501234,"ip_address":"","ucode":"33DD1318E53814","user_header":"","comment_is_top":false,"comment_ctime":1566967888,"is_pvip":false,"replies":[{"id":"48294","content":"一般系统启动的时候创建的","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1567153224,"ip_address":"","comment_id":128823,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566967888","product_id":100006601,"comment_content":"单reactor单进程模式中是不是只有一个handler实例，这个实例是在系统接收到第一个连接的时候创建的？","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465120,"discussion_content":"一般系统启动的时候创建的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567153224,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":113182,"user_name":"涧底青松","can_delete":false,"product_type":"c1","uid":1587658,"ip_address":"","ucode":"C0251217515929","user_header":"https://static001.geekbang.org/account/avatar/00/18/39/ca/d4ba70ce.jpg","comment_is_top":false,"comment_ctime":1562909150,"is_pvip":false,"replies":[{"id":"41279","content":"不是，reactor都不是阻塞模型","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1562973080,"ip_address":"","comment_id":113182,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1562909150","product_id":100006601,"comment_content":"我理解的到单reactor单进程其实还是同步堵塞模型对吗？","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458096,"discussion_content":"不是，reactor都不是阻塞模型","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562973080,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1592279,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","nickname":"William Ning","note":"","ucode":"4DB8D05E69E5F3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571004,"discussion_content":"个人理解：\nreactor同步非阻塞，proactor异步非阻塞。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652024833,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":111087,"user_name":"飞翔","can_delete":false,"product_type":"c1","uid":1068571,"ip_address":"","ucode":"65AF6AF292DAD6","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/1b/f4b786b9.jpg","comment_is_top":false,"comment_ctime":1562469710,"is_pvip":true,"replies":[{"id":"40569","content":"网上搜，一大把资料","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1562555587,"ip_address":"","comment_id":111087,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562469710","product_id":100006601,"comment_content":"epoll比select更好 能解释下原因嘛","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457221,"discussion_content":"网上搜，一大把资料","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562555587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109907,"user_name":"咬尾巴的蛇","can_delete":false,"product_type":"c1","uid":1106193,"ip_address":"","ucode":"9DE74D4A7ABD08","user_header":"https://static001.geekbang.org/account/avatar/00/10/e1/11/8eac267f.jpg","comment_is_top":false,"comment_ctime":1562130216,"is_pvip":false,"replies":[{"id":"39885","content":"这是个很好的学习机会，你可以自己研究一下","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1562193531,"ip_address":"","comment_id":109907,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562130216","product_id":100006601,"comment_content":"你好，大致理解了，还有一点需要麻烦问下，就是Tomcat用的是什么模式，我们说并发都是说代码，数据库，就是Tomcat一般能支持多少请求进来，感谢","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456633,"discussion_content":"这是个很好的学习机会，你可以自己研究一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562193531,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106816,"user_name":"小飞哥 ‍超級會員","can_delete":false,"product_type":"c1","uid":1110049,"ip_address":"","ucode":"417F9563B3005B","user_header":"https://static001.geekbang.org/account/avatar/00/10/f0/21/104b9565.jpg","comment_is_top":false,"comment_ctime":1561389382,"is_pvip":false,"replies":[{"id":"38781","content":"1. 处理完可能返回结果，例如API调用；也可能不返回结果，例如数据上报，消息发送<br><br>2. 多Reactor多进程的模式，子进程处理连接数据读写，无需父进程参与","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1561483264,"ip_address":"","comment_id":106816,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561389382","product_id":100006601,"comment_content":"现在回复还有效吗？<br>1.我在看单Reactor单进程&#47;线程 和多Reactor 多进程&#47;线程时， 都没有讲处理完结果后应该怎么样。 是不返回给client，还是直接结束？ 还是怎么回事？<br><br>只有单Reactor多线程说到了 处理完后返回给client。<br><br>2. 单Reactor 多进程 提到 多进程会有父进程与子进程之间通信问题。 那么 多Reactor多进程 就没有父进程与子 进程之间通信问题吗？ 为什么？","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455234,"discussion_content":"1. 处理完可能返回结果，例如API调用；也可能不返回结果，例如数据上报，消息发送\n\n2. 多Reactor多进程的模式，子进程处理连接数据读写，无需父进程参与","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561483264,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97204,"user_name":"codelife","can_delete":false,"product_type":"c1","uid":1394053,"ip_address":"","ucode":"961973D6B94ED5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJibCJxeF0ibxdHcIKCg3ibFzJ2ibFL0ZpsoKN8FBwhZG5RlGBucVq68oxH2VNIicWcOo0Q0CGIfIdtG1g/132","comment_is_top":false,"comment_ctime":1558609223,"is_pvip":false,"replies":[{"id":"34825","content":"谢谢补充，最新的暂时没有研究，我推测由于大量Linux2.6内核继续存在，我估计Nginx应该是做了分支处理，根据不同OS来做不同处理","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1558666955,"ip_address":"","comment_id":97204,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1558609223","product_id":100006601,"comment_content":"好像nginx目前应该不会用锁处理accept了，高版本的内核好像目前支持解决accept惊群问题了","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451176,"discussion_content":"谢谢补充，最新的暂时没有研究，我推测由于大量Linux2.6内核继续存在，我估计Nginx应该是做了分支处理，根据不同OS来做不同处理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558666955,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84406,"user_name":"极客雷","can_delete":false,"product_type":"c1","uid":1041465,"ip_address":"","ucode":"0DBAC4CB9C7BCD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e4/39/a06ade33.jpg","comment_is_top":false,"comment_ctime":1554858489,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1554858489","product_id":100006601,"comment_content":"事实证明，单进程单线程多协程才是王道。","like_count":0,"discussions":[{"author":{"id":1673542,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epnSfvicmI26fkYiaI17q2M4gvqrchntJdq7E7KyB6gia6dww5SXibvDjgh3HiaNREZdkXy5WbJ0642BFQ/132","nickname":"大耳朵小松鼠","note":"","ucode":"B9F73DC92EE706","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":19116,"discussion_content":"协程底层用的也是reactor","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569139580,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81329,"user_name":"LiYanbin","can_delete":false,"product_type":"c1","uid":1129976,"ip_address":"","ucode":"2F50493F818909","user_header":"https://static001.geekbang.org/account/avatar/00/11/3d/f8/b13674e6.jpg","comment_is_top":false,"comment_ctime":1553863863,"is_pvip":false,"replies":[{"id":"30112","content":"实现起来有点麻烦，需要频繁的将连接从主线程的监听列表删除，放到子线程，子线程处理完成后又交回给主线程进行监听","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1554536924,"ip_address":"","comment_id":81329,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553863863","product_id":100006601,"comment_content":"华哥，你好。单reactor多线程，可以把read和write放到子线程中去做吗","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445157,"discussion_content":"实现起来有点麻烦，需要频繁的将连接从主线程的监听列表删除，放到子线程，子线程处理完成后又交回给主线程进行监听","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554536924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79440,"user_name":"@@fighting","can_delete":false,"product_type":"c1","uid":1236394,"ip_address":"","ucode":"7235C1E74549AE","user_header":"https://static001.geekbang.org/account/avatar/00/12/dd/aa/859544fd.jpg","comment_is_top":false,"comment_ctime":1553484039,"is_pvip":false,"replies":[{"id":"29074","content":"看用在什么地方，web编程有的地方有大量IO操作，不适合用node","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1553557712,"ip_address":"","comment_id":79440,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553484039","product_id":100006601,"comment_content":"nodejs 天生的异步IO在web编程方面是否是一个很大的优势呢","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444500,"discussion_content":"看用在什么地方，web编程有的地方有大量IO操作，不适合用node","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553557712,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":76143,"user_name":"刘涛","can_delete":false,"product_type":"c1","uid":1065522,"ip_address":"","ucode":"688680F96BD9E1","user_header":"https://static001.geekbang.org/account/avatar/00/10/42/32/6edba05d.jpg","comment_is_top":false,"comment_ctime":1552535447,"is_pvip":false,"replies":[{"id":"28714","content":"我理解node有点像Proactor，本质是Reactor。<br>Reactor的read之后的步骤也可以自己设计成异步的","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1553299914,"ip_address":"","comment_id":76143,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552535447","product_id":100006601,"comment_content":"node是属于Proactor吧？<br>Reator是只有accept到read是异步，从read-业务处理里面的io-send，整个过程都是同步的吗？","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443195,"discussion_content":"我理解node有点像Proactor，本质是Reactor。\nReactor的read之后的步骤也可以自己设计成异步的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553299914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73101,"user_name":"曹宇","can_delete":false,"product_type":"c1","uid":1354271,"ip_address":"","ucode":"0CDF9B3806FB32","user_header":"https://static001.geekbang.org/account/avatar/00/14/aa/1f/38b1bb9e.jpg","comment_is_top":false,"comment_ctime":1551798427,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1551798427","product_id":100006601,"comment_content":"这期真是精彩啊！","like_count":0},{"had_liked":false,"id":72496,"user_name":"行者","can_delete":false,"product_type":"c1","uid":1063734,"ip_address":"","ucode":"EA31201A7C5AE1","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/36/2d61e080.jpg","comment_is_top":false,"comment_ctime":1551660528,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551660528","product_id":100006601,"comment_content":"留言区卧虎藏龙，学习了。","like_count":0},{"had_liked":false,"id":64893,"user_name":"MJ","can_delete":false,"product_type":"c1","uid":1237145,"ip_address":"","ucode":"FCEC0C21444D2A","user_header":"https://static001.geekbang.org/account/avatar/00/12/e0/99/5d603697.jpg","comment_is_top":false,"comment_ctime":1548942979,"is_pvip":false,"replies":[{"id":"23089","content":"《UNIX网络编程 卷一》","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1549097844,"ip_address":"","comment_id":64893,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1548942979","product_id":100006601,"comment_content":"说实话，基础不太好，阻塞、同步、异步等概念不太明白，看的也是不太懂。老师，如何弥补基础？","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438222,"discussion_content":"《UNIX网络编程 卷一》","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549097844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":59526,"user_name":"蓓岑2015","can_delete":false,"product_type":"c1","uid":1105203,"ip_address":"","ucode":"9DDD5BA26324E6","user_header":"https://static001.geekbang.org/account/avatar/00/10/dd/33/4562472d.jpg","comment_is_top":false,"comment_ctime":1547382648,"is_pvip":false,"replies":[{"id":"21464","content":"计算机网络编程，可以看UNIX网络编程卷一的内容","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1547429774,"ip_address":"","comment_id":59526,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1547382648","product_id":100006601,"comment_content":"请问这是哪一方面的知识？我到这篇文章为止，已经看不懂了，一脸懵逼啊，求老师指点一下，对Reactor与Proactor根本就没有概念。","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436351,"discussion_content":"计算机网络编程，可以看UNIX网络编程卷一的内容","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547429774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":41968,"user_name":"冯宇","can_delete":false,"product_type":"c1","uid":1248481,"ip_address":"","ucode":"894A0951E776D7","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/e1/e54540b9.jpg","comment_is_top":false,"comment_ctime":1542883285,"is_pvip":false,"replies":[{"id":"15168","content":"你可以自己去研究一下，akka目前主要应用在一些平台中，例如Flink","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1542956599,"ip_address":"","comment_id":41968,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542883285","product_id":100006601,"comment_content":"讲解很到位。之前一直不理解为什么vert.x框架是reactor模型，这次就明白了。vert.x本身就是一个大型的反应堆，通过抽象出Handler接口实现一个reactor模型，这种设计是高性能异步非阻塞设计的。程序员只需要实现一个个Handler就可以了。另外想问下有没有akka的无锁设计原理讲解呢？之前看akka的原理设计也是云里雾里的","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429958,"discussion_content":"你可以自己去研究一下，akka目前主要应用在一些平台中，例如Flink","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542956599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":38088,"user_name":"YMF_WX1981","can_delete":false,"product_type":"c1","uid":1123051,"ip_address":"","ucode":"8891A4C343D9FD","user_header":"https://static001.geekbang.org/account/avatar/00/11/22/eb/b580b80f.jpg","comment_is_top":false,"comment_ctime":1541929965,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541929965","product_id":100006601,"comment_content":"学习...我是门外汉","like_count":0},{"had_liked":false,"id":30254,"user_name":"小喵喵","can_delete":false,"product_type":"c1","uid":1062444,"ip_address":"","ucode":"FDBBB2A59DB8B6","user_header":"https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg","comment_is_top":false,"comment_ctime":1538743475,"is_pvip":false,"replies":[{"id":"10984","content":"基础资料就是《UNIX网络编程》😄","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1538869575,"ip_address":"","comment_id":30254,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538743475","product_id":100006601,"comment_content":"感觉写两种模式好难啊，能给一些最基础的资料我学习吗","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425915,"discussion_content":"基础资料就是《UNIX网络编程》😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538869575,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":22805,"user_name":"呵呵","can_delete":false,"product_type":"c1","uid":1052862,"ip_address":"","ucode":"986CC73CFBBC67","user_header":"","comment_is_top":false,"comment_ctime":1535980212,"is_pvip":false,"replies":[{"id":"8273","content":"《Unix网络编程 卷一》多路复用章节详细看看","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1536052501,"ip_address":"","comment_id":22805,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1535980212","product_id":100006601,"comment_content":"大神，为什么reactor 为非阻塞同步模型，非阻塞体现在哪里？谢谢","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423273,"discussion_content":"《Unix网络编程 卷一》多路复用章节详细看看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1536052501,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":22273,"user_name":"邵帅","can_delete":false,"product_type":"c1","uid":1207488,"ip_address":"","ucode":"EB662C972CC248","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/gLC1Z8lYdWPHquZbJCf5FfIDgOJKiapygoyNrl4b5fkibyV2LBnCKV5BjRAYOhPGJxL425rIdSVnibTMEg012S9Pg/132","comment_is_top":false,"comment_ctime":1535590435,"is_pvip":false,"replies":[{"id":"7985","content":"线程间通信，数据库，文件，消息队列等都可以","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1535608640,"ip_address":"","comment_id":22273,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1535590435","product_id":100006601,"comment_content":" 多 Reactor 多进程 &#47; 线程方案，如果业务需要在两个连接之间传递数据，这两个连接可能不在一个线程，该如何处理呢？","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423056,"discussion_content":"线程间通信，数据库，文件，消息队列等都可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535608640,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20981,"user_name":"吃个橙子好不好","can_delete":false,"product_type":"c1","uid":1179460,"ip_address":"","ucode":"14DFECC8116867","user_header":"https://static001.geekbang.org/account/avatar/00/11/ff/44/80302cd4.jpg","comment_is_top":false,"comment_ctime":1534850565,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1534850565","product_id":100006601,"comment_content":"很多知识需反复阅读，结合其他评论效果理解得更好。","like_count":0},{"had_liked":false,"id":20274,"user_name":"咬尾巴的蛇","can_delete":false,"product_type":"c1","uid":1106193,"ip_address":"","ucode":"9DE74D4A7ABD08","user_header":"https://static001.geekbang.org/account/avatar/00/10/e1/11/8eac267f.jpg","comment_is_top":false,"comment_ctime":1534344711,"is_pvip":false,"replies":[{"id":"7125","content":"tcp是传输协议，reactor，ppc都是是架构模式，是基于tcp的","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1534387957,"ip_address":"","comment_id":20274,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1534344711","product_id":100006601,"comment_content":"很感谢老师的分享，结合前面的说的ppc和tcp，我还是有点不明白，reactor是在tcp上层做的处理还是直接没有tcp了，就是reactor和tcp或ppc之间是什么关系和联系，麻烦老师帮忙看下，在这块比较欠缺，非常感谢","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422183,"discussion_content":"tcp是传输协议，reactor，ppc都是是架构模式，是基于tcp的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534387957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":17379,"user_name":"Vincent","can_delete":false,"product_type":"c1","uid":1066781,"ip_address":"","ucode":"7700D59F187FEF","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/1d/673537d4.jpg","comment_is_top":false,"comment_ctime":1532605973,"is_pvip":true,"replies":[{"id":"6083","content":"应该是网卡驱动","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1532734340,"ip_address":"","comment_id":17379,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1532605973","product_id":100006601,"comment_content":"一个很基础的问题，谁在什么时候把网络io数据写进内核缓存的?","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421132,"discussion_content":"应该是网卡驱动","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1532734340,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":17037,"user_name":"沙亮亮","can_delete":false,"product_type":"c1","uid":1099492,"ip_address":"","ucode":"E6CF0D5B1E6691","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/e4/ec572f55.jpg","comment_is_top":false,"comment_ctime":1532393670,"is_pvip":false,"replies":[{"id":"5918","content":"Reactor模式支持读写操作，不是只简单的读操作","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1532423596,"ip_address":"","comment_id":17037,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1532393670","product_id":100006601,"comment_content":"感谢大神解惑，还有一个问题，对于nginx收到请求后，分发给应用服务器进行业务处理，然后应用服务器处理完后，再通过nginx把数据返回给用户请求。reactor模式首先是运用在收到请求这一块，那对于应用服务器处理完业务请求，通过nginx把数据返回给用户请求，这个过程reactor模式起作用了吗","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421017,"discussion_content":"Reactor模式支持读写操作，不是只简单的读操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1532423596,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":15994,"user_name":"Geek_b04b12","can_delete":false,"product_type":"c1","uid":1112139,"ip_address":"","ucode":"F8705A21FCDF09","user_header":"https://static001.geekbang.org/account/avatar/00/10/f8/4b/5ae62b10.jpg","comment_is_top":false,"comment_ctime":1531720060,"is_pvip":false,"replies":[{"id":"5544","content":"学习下php-fpm的实现","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1531733563,"ip_address":"","comment_id":15994,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1531720060","product_id":100006601,"comment_content":"发现这些对于我们这些学PHP开发的比较偏实现原理，在架构设计中，你说的这些貌似对于我们来说只是些软件配置的调优吧？或者说在以后得工作中遇到的问题的一种解决思路或者解决问题的思路？中间介绍的模型都了解过，那么作为PHPer不知道如何实现调试模拟？","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420628,"discussion_content":"学习下php-fpm的实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1531733563,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":15027,"user_name":"周飞","can_delete":false,"product_type":"c1","uid":1073374,"ip_address":"","ucode":"F85FA236EB0C0D","user_header":"https://static001.geekbang.org/account/avatar/00/10/60/de/5c67895a.jpg","comment_is_top":false,"comment_ctime":1530808014,"is_pvip":false,"replies":[{"id":"5063","content":"那还是Proactor，只是windows上的IOCP是标准的Proactor, linux上是用epoll模拟Proactor","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1530844531,"ip_address":"","comment_id":15027,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1530808014","product_id":100006601,"comment_content":"晚上看了朴灵写的 深入浅出nodejs和 unix网络编程，我认为node的异步模型其实是reactor 和proactor的结合。Windows下node用iocp，linux下用多线程和epoll来做多reactor。然后事件循环来执行主线程注册的回调函数，实现异步的io，这部分是proactor。","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420212,"discussion_content":"那还是Proactor，只是windows上的IOCP是标准的Proactor, linux上是用epoll模拟Proactor","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530844531,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":13592,"user_name":"tiger","can_delete":false,"product_type":"c1","uid":1047291,"ip_address":"","ucode":"C15AC14AA33F40","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fa/fb/ef99d6ca.jpg","comment_is_top":false,"comment_ctime":1529837235,"is_pvip":false,"replies":[{"id":"4574","content":"用户态线程也可以算作线程，因此这还是单线程单连接的","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1529892729,"ip_address":"","comment_id":13592,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1529837235","product_id":100006601,"comment_content":"老师，你好，你有说到单线程单连接的时候，线程会阻塞，。这种模型还可以通过协程(比如go语言的goroutine)方式解决，一个协程一个连接，因为协程属于用户态线程，轻量，所以同一时间可以产生大量的协程。这种方式就可以实现同步阻塞并发模型。<br><br>当然协程会增加额外的内存使用，另外也是通过线程轮询协程状态的方式驱动的","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419698,"discussion_content":"用户态线程也可以算作线程，因此这还是单线程单连接的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529892729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1631005,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/yoTG87qicuhbNacuWFF1MWxeCCA8bzWO9Tfk7CcM9Hl9o8e3PJp4qvXF250Y5gp5ibyR13xIbPia6qcicFv0PQINzA/132","nickname":"码力不足","note":"","ucode":"8319956D67F861","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":118276,"discussion_content":"协程是用户态的线程，协程的优点是把异步非阻塞的编程方式变成了同步阻塞的编程模式，更符合正常的思维的同时，又保留了异步非阻塞的高性能，协程使异步IO的过程对使用者透明，单线程上可以同时并行的处理多个连接。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578150963,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12880,"user_name":"成功","can_delete":false,"product_type":"c1","uid":1112099,"ip_address":"","ucode":"954B90AC92E8C3","user_header":"https://static001.geekbang.org/account/avatar/00/10/f8/23/165d2f0e.jpg","comment_is_top":false,"comment_ctime":1529111244,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1529111244","product_id":100006601,"comment_content":"Reactor多线程模式，比较合适。父进程管理监听和accept，子进程负责创建HandIe和处理","like_count":0},{"had_liked":false,"id":12779,"user_name":"大光头","can_delete":false,"product_type":"c1","uid":1041792,"ip_address":"","ucode":"8EF797AFD1E27C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo3DrWeV7ZwRLXrRZg4V3ic1LQYdZ3u1oicDhqPic47vMguvf5QS69roTiaJrwDr5Re3Sy2UyHDWwmsTA/132","comment_is_top":false,"comment_ctime":1529027702,"is_pvip":false,"replies":[{"id":"4241","content":"proactor没有明显好，理论上来说性能差异不会很大，更不用谈实际实现受各种因素影响了","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1529046324,"ip_address":"","comment_id":12779,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1529027702","product_id":100006601,"comment_content":"proactor明显比reactor更好，但是很多都没有实现，只能用reactor。对于前浪微博这么大吞吐量的业务，用多reactor多进程方式更好，因为业务比较复杂，同时要求稳定性，又高吞吐量。单reactor单进程和单reactor多线程都无法满足这个。","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419406,"discussion_content":"proactor没有明显好，理论上来说性能差异不会很大，更不用谈实际实现受各种因素影响了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529046324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12761,"user_name":"周龙亭","can_delete":false,"product_type":"c1","uid":1004577,"ip_address":"","ucode":"21BD0DD15CFCA3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/21/8c13a2b4.jpg","comment_is_top":false,"comment_ctime":1529022584,"is_pvip":false,"replies":[{"id":"4245","content":"可以的，独立线程处理业务，系统总吞吐量不会增加，因为瓶颈在业务处理部分，但复杂度增加很多，参考我另外一个回答，里面分析了netty4的实现","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1529046620,"ip_address":"","comment_id":12761,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1529022584","product_id":100006601,"comment_content":"多reactor多线程模式中，如果是阻塞的业务处理也需要放到独立线程池去处理，不能直接在reactor线程处理。","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419397,"discussion_content":"可以的，独立线程处理业务，系统总吞吐量不会增加，因为瓶颈在业务处理部分，但复杂度增加很多，参考我另外一个回答，里面分析了netty4的实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529046620,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12679,"user_name":"LouisLimTJ","can_delete":false,"product_type":"c1","uid":1149462,"ip_address":"","ucode":"E430BC6BE62C22","user_header":"https://static001.geekbang.org/account/avatar/00/11/8a/16/10420350.jpg","comment_is_top":false,"comment_ctime":1528953856,"is_pvip":false,"replies":[{"id":"4254","content":"可以认为目前开源系统对外宣称的性能都是TPS&#47;QPS上万，例如nginx, mc ,redis都是3～5万，mysql简单的k-v存储性能也能达到这个量级，kafka更高，10几万都有","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1529047332,"ip_address":"","comment_id":12679,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1528953856","product_id":100006601,"comment_content":"你好，老师，可不可以系统的整理出一个性能数据表？由于时间和经验的原因，当进行架构选择时，我不太可能每个选择都去做测试。我相信这样一张表格会给大家有帮助。我知道影响性能的因素和变量很复杂。我自己在总结云预算管理的时候，我会定义自己的一套标准的的硬件资源，然后不同的选型和业务给出一个数值。如果要更细致的话，在资源方面可以定义高中低配置表现。性能数据的话，可以通过一个基准业务，复杂业务是基准的多少倍或者几分之几。","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419364,"discussion_content":"可以认为目前开源系统对外宣称的性能都是TPS/QPS上万，例如nginx, mc ,redis都是3～5万，mysql简单的k-v存储性能也能达到这个量级，kafka更高，10几万都有","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529047332,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12553,"user_name":"正直D令狐勇","can_delete":false,"product_type":"c1","uid":1079581,"ip_address":"","ucode":"8FFE3489C1C04C","user_header":"https://static001.geekbang.org/account/avatar/00/10/79/1d/375d28c0.jpg","comment_is_top":false,"comment_ctime":1528905296,"is_pvip":false,"replies":[{"id":"4150","content":"这只是理论上的差异，实际上的性能取决很多因素，例如线程的并发处理就是性能容易出问题的地方","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1528941112,"ip_address":"","comment_id":12553,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1528905296","product_id":100006601,"comment_content":"“java用线程，c&#47;c++用进程多些”，指的开发效率嘛？性能上来说还是线程有优势吧","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419292,"discussion_content":"这只是理论上的差异，实际上的性能取决很多因素，例如线程的并发处理就是性能容易出问题的地方","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528941112,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12458,"user_name":"Tom","can_delete":false,"product_type":"c1","uid":1109832,"ip_address":"","ucode":"00EEDE4CB11776","user_header":"","comment_is_top":false,"comment_ctime":1528850047,"is_pvip":false,"replies":[{"id":"4095","content":"windows用tpc和Proactor, linux用ppc和reactor多些，java用线程，c&#47;c++用进程多些","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1528868408,"ip_address":"","comment_id":12458,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1528850047","product_id":100006601,"comment_content":"PPC、TPC、Reactor和Proactor这四种模式在linux下和windows 下都是适用的吗，两个平台下有没有什么区别？","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419266,"discussion_content":"windows用tpc和Proactor, linux用ppc和reactor多些，java用线程，c/c++用进程多些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528868408,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12244,"user_name":"hey","can_delete":false,"product_type":"c1","uid":1014997,"ip_address":"","ucode":"276BD331772A8A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7c/d5/5d6b3d34.jpg","comment_is_top":false,"comment_ctime":1528716607,"is_pvip":false,"replies":[{"id":"4041","content":"没有完美的方案，如果分开，io线程很快但写数据库慢的话，会积压请求数据，此时系统故障会丢很多数据","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1528762677,"ip_address":"","comment_id":12244,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1528716607","product_id":100006601,"comment_content":"业务处理假如是跟数据库打交道的一个线程同时处理io跟业务不会有问题吗","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419179,"discussion_content":"没有完美的方案，如果分开，io线程很快但写数据库慢的话，会积压请求数据，此时系统故障会丢很多数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528762677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12173,"user_name":"性能","can_delete":false,"product_type":"c1","uid":1137192,"ip_address":"","ucode":"BBFA2A31B02B8F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIyhbzdkFM64HvRATbWjc3hkic7icUszl9hU9hpIMZcibKH4wWam4SHfkcvM7MUoKjGDRrvYGXuvR91Q/132","comment_is_top":false,"comment_ctime":1528637114,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1528637114","product_id":100006601,"comment_content":"我理解nio框架Mina 就是多reactor多线程的模式","like_count":0},{"had_liked":false,"id":12171,"user_name":"古德","can_delete":false,"product_type":"c1","uid":1037755,"ip_address":"","ucode":"E3F646BB73F60E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d5/bb/98b93862.jpg","comment_is_top":false,"comment_ctime":1528634968,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1528634968","product_id":100006601,"comment_content":"无论nio还是aio，都是操作系统自生的机制，java只是对底层api的封装，其他语言都有类似的封装。这样理解没错吧","like_count":0},{"had_liked":false,"id":12140,"user_name":"星火燎原","can_delete":false,"product_type":"c1","uid":1101373,"ip_address":"","ucode":"15AD8E3006E107","user_header":"https://static001.geekbang.org/account/avatar/00/10/ce/3d/385b8263.jpg","comment_is_top":false,"comment_ctime":1528616078,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1528616078","product_id":100006601,"comment_content":"自然是多reactor模式啦","like_count":0},{"had_liked":false,"id":12129,"user_name":"咖飞","can_delete":false,"product_type":"c1","uid":1111226,"ip_address":"","ucode":"9F30A156C21B90","user_header":"https://static001.geekbang.org/account/avatar/00/10/f4/ba/8f4f0a8a.jpg","comment_is_top":false,"comment_ctime":1528604022,"is_pvip":false,"replies":[{"id":"3961","content":"改为非阻塞，没有数据可读就立刻返回了，那什么时候才有数据可读呢？只能循环调用read操作了","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1528615426,"ip_address":"","comment_id":12129,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1528604022","product_id":100006601,"comment_content":"解决线程池利用率，文中说:   解决这个问题的最简单的方式是将 read 操作改为非阻塞，然后进程不断地轮询多个连接。<br>请问只要将read操作改为非阻塞不就可以了吗？为啥还要轮询？","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419131,"discussion_content":"改为非阻塞，没有数据可读就立刻返回了，那什么时候才有数据可读呢？只能循环调用read操作了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528615426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12124,"user_name":"咖飞","can_delete":false,"product_type":"c1","uid":1111226,"ip_address":"","ucode":"9F30A156C21B90","user_header":"https://static001.geekbang.org/account/avatar/00/10/f4/ba/8f4f0a8a.jpg","comment_is_top":false,"comment_ctime":1528602864,"is_pvip":false,"replies":[{"id":"3962","content":"《unix网络编程 卷一》有详细的说明，包括阻塞非阻塞，同步异步等","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1528615497,"ip_address":"","comment_id":12124,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1528602864","product_id":100006601,"comment_content":"老师你好，IO多路复用的两个关键点能否说的更具体一点，实在是很难理解。","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419128,"discussion_content":"《unix网络编程 卷一》有详细的说明，包括阻塞非阻塞，同步异步等","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528615497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12121,"user_name":"谭斌","can_delete":false,"product_type":"c1","uid":1110881,"ip_address":"","ucode":"71468ABB7B9EBD","user_header":"https://static001.geekbang.org/account/avatar/00/10/f3/61/93ec928e.jpg","comment_is_top":false,"comment_ctime":1528602365,"is_pvip":false,"replies":[{"id":"3963","content":"参考Doug Lee的NIO PPT，亲手把里面的代码写一遍，测试一遍","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1528615555,"ip_address":"","comment_id":12121,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1528602365","product_id":100006601,"comment_content":"还是没有理解reactor中同步的意思...","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419126,"discussion_content":"参考Doug Lee的NIO PPT，亲手把里面的代码写一遍，测试一遍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528615555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12113,"user_name":"星火燎原","can_delete":false,"product_type":"c1","uid":1101373,"ip_address":"","ucode":"15AD8E3006E107","user_header":"https://static001.geekbang.org/account/avatar/00/10/ce/3d/385b8263.jpg","comment_is_top":false,"comment_ctime":1528595675,"is_pvip":false,"replies":[{"id":"3964","content":"那具体是哪种模式呢？单reactor多线程？","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1528615594,"ip_address":"","comment_id":12113,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1528595675","product_id":100006601,"comment_content":"我的理解是前浪微博适合于 用一个主线程去监听连接请求，然后把请求丢到业务线程池后立即返回 通过回调函数处理业务逻辑。","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419122,"discussion_content":"那具体是哪种模式呢？单reactor多线程？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528615594,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12101,"user_name":"feifei","can_delete":false,"product_type":"c1","uid":1105431,"ip_address":"","ucode":"B1F8AE3AD82C51","user_header":"https://static001.geekbang.org/account/avatar/00/10/de/17/75e2b624.jpg","comment_is_top":false,"comment_ctime":1528591280,"is_pvip":false,"replies":[{"id":"3991","content":"这个方案可以的","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1528624752,"ip_address":"","comment_id":12101,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1528591280","product_id":100006601,"comment_content":"我认为消息队列适合reactor单进程多线程方案，消息队列的连接不多，消息处理工作量大！这个特性与单进程多线程的方案特点匹配，连接在一个线程中完成，业务处理在其他线程中完成，这样能最大限度地利用资源","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419114,"discussion_content":"这个方案可以的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528624752,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12046,"user_name":"天天平安","can_delete":false,"product_type":"c1","uid":1119208,"ip_address":"","ucode":"C4850F9655F4DD","user_header":"https://static001.geekbang.org/account/avatar/00/11/13/e8/08b829a9.jpg","comment_is_top":false,"comment_ctime":1528534185,"is_pvip":false,"replies":[{"id":"3970","content":"感觉是标准的流式处理，如果实时性要求高，用storm，如果实时性要求没那么高，spark streaming可能也可以。<br>不过我理解发送短信的实时性要求不会很高，因此方案可以简单一些","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1528616123,"ip_address":"","comment_id":12046,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1528534185","product_id":100006601,"comment_content":"老师您好，一个短信计分析算平台的需求：一集大数据分析、数据挖掘、机器学习为一体的智能分析平台。比如一次一条或提交1万条短信，要根据如下七八个数据库（每个库的数据有的亿级别，并且每次对短信发送的结果来维护这些分析库）：客户数据库，<br>失败号码库，客户归属地市数据库，白名单库，黑名单库，买家信息，实号库和新号码库 等等分析出来这1万的短信哪些需要发送，哪些不需发送 做到客户的精细化运营。<br>这系统每天发送短信的量大概是5000万，短信的信息流程是：短信平台--&gt;短信分析计算平台--&gt;短信平台--&gt;发送到运营商 。请问短信分析计算平台的架构怎么设计？<br>","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419093,"discussion_content":"感觉是标准的流式处理，如果实时性要求高，用storm，如果实时性要求没那么高，spark streaming可能也可以。\n不过我理解发送短信的实时性要求不会很高，因此方案可以简单一些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528616123,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12016,"user_name":"云学","can_delete":false,"product_type":"c1","uid":1027233,"ip_address":"","ucode":"366AE90BA06356","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ac/a1/43d83698.jpg","comment_is_top":false,"comment_ctime":1528516036,"is_pvip":false,"replies":[{"id":"3974","content":"微博我不清楚呢，不过类似的库很多","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1528617461,"ip_address":"","comment_id":12016,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1528516036","product_id":100006601,"comment_content":"曾经用c++11实现了多reactor多线程网络库，微博应该用这种模式吧","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419084,"discussion_content":"微博我不清楚呢，不过类似的库很多","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528617461,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12015,"user_name":"刘岚乔月","can_delete":false,"product_type":"c1","uid":1095289,"ip_address":"","ucode":"99A9AB4E4E1111","user_header":"https://static001.geekbang.org/account/avatar/00/10/b6/79/22e582a5.jpg","comment_is_top":false,"comment_ctime":1528515802,"is_pvip":false,"replies":[{"id":"3975","content":"其实java都是基于操作系统来的呢，c&#47;c++一样可以实现这些模式","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1528617513,"ip_address":"","comment_id":12015,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1528515802","product_id":100006601,"comment_content":"感觉其根本都是从io nio nio2演变的<br>从同步阻塞到同步非阻塞(利用轮循机制 仅仅在select阻塞)在到异步非阻塞 (基于注册事件和回调机制 )都是基于java基础","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419083,"discussion_content":"其实java都是基于操作系统来的呢，c/c++一样可以实现这些模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528617513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12008,"user_name":"olaf","can_delete":false,"product_type":"c1","uid":1109076,"ip_address":"","ucode":"ED3405BE92C5DE","user_header":"https://static001.geekbang.org/account/avatar/00/10/ec/54/ab5e1cfa.jpg","comment_is_top":false,"comment_ctime":1528514495,"is_pvip":false,"replies":[{"id":"3977","content":"类似nginx，nginx模式与标准的多reactor多线程有点差别，nginx每个子进程都可以accept","user_name":"作者回复","user_name_real":"华仔","uid":"1098920","ctime":1528617638,"ip_address":"","comment_id":12008,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1528514495","product_id":100006601,"comment_content":"消息队列的业务的话，数据共享和同步应该设计很少所以主要发挥机器性能。采用nginx模式不错","like_count":0,"discussions":[{"author":{"id":1098920,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c4/a8/f2685e1b.jpg","nickname":"华仔","note":"","ucode":"851FF94CF5133A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419080,"discussion_content":"类似nginx，nginx模式与标准的多reactor多线程有点差别，nginx每个子进程都可以accept","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528617638,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}