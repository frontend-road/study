{"id":597664,"title":"03｜Token：如何降低用户身份鉴权的流量压力？","content":"<p>你好，我是徐长龙，这节课我们来看看如何用token算法降低用户中心的身份鉴权流量压力。</p><p>很多网站初期通常会用Session方式实现登录用户的用户鉴权，也就是在用户登录成功后，将这个用户的具体信息写在服务端的Session缓存中，并分配一个session_id保存在用户的Cookie中。该用户的每次请求时候都会带上这个ID，通过ID可以获取到登录时写入服务端Session缓存中的记录。</p><p>流程图如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/58/72/589d13f1d758a44a1af37efaf9dbdc72.jpg?wh=3330x2141\" alt=\"\" title=\"Session Cache实现的用户鉴权\"></p><p>这种方式的好处在于信息都在服务端储存，对客户端不暴露任何用户敏感的数据信息，并且每个登录用户都有共享的缓存空间（Session Cache）。</p><p>但是随着流量的增长，这个设计也暴露出很大的问题——用户中心的身份鉴权在大流量下很不稳定。因为用户中心需要维护的Session Cache空间很大，并且被各个业务频繁访问，那么缓存一旦出现故障，就会导致所有的子系统无法确认用户身份，进而无法正常对外服务。</p><p>这主要是由于Session Cache和各个子系统的耦合极高，<strong>全站的请求都会对这个缓存至少访问一次</strong>，这就导致缓存的内容长度和响应速度，直接决定了全站的QPS上限，让整个系统的隔离性很差，各子系统间极易相互影响。</p><p>那么，如何降低用户中心与各个子系统间的耦合度，提高系统的性能呢？我们一起来看看。</p><!-- [[[read_end]]] --><h2>JWT登陆和token校验</h2><p>常见方式是采用签名加密的token，这是登录的一个行业标准，即JWT（JSON Web Token）：<img src=\"https://static001.geekbang.org/resource/image/02/bf/02f2f3aff0f5db68ef952065da2721bf.jpg?wh=3330x2141\" alt=\"\" title=\"token流程\"></p><p>上图就是JWT的登陆流程，用户登录后会将用户信息放到一个加密签名的token中，每次请求都把这个串放到header或cookie内带到服务端，服务端直接将这个token解开即可直接获取到用户的信息，无需和用户中心做任何交互请求。</p><p>token生成代码如下：</p><pre><code class=\"language-go\">import \"github.com/dgrijalva/jwt-go\"\n\n//签名所需混淆密钥 不要太简单 容易被破解\n//也可以使用非对称加密，这样可以在客户端用公钥验签\nvar secretString = []byte(\"jwt secret string 137 rick\") \n\ntype TokenPayLoad struct {\n    UserId   uint64 `json:\"userId\"` //用户id\n    NickName string `json:\"nickname\"` //昵称\n    jwt.StandardClaims //私有部分\n}\n\n// 生成JWT token\nfunc GenToken(userId uint64, nickname string) (string, error) {\n    c := TokenPayLoad{\n        UserId: userId, //uid\n        NickName: nickname, //昵称\n        //这里可以追加一些其他加密的数据进来\n        //不要明文放敏感信息，如果需要放，必须再加密\n        \n        //私有部分\n        StandardClaims: jwt.StandardClaims{\n            //两小时后失效\n            ExpiresAt: time.Now().Add(2 * time.Hour).Unix(),\n            //颁发者\n            Issuer:    \"geekbang\",\n        },\n    }\n    //创建签名 使用hs256\n    token := jwt.NewWithClaims(jwt.SigningMethodHS256, c)\n    // 签名，获取token结果\n    return token.SignedString(secretString)\n}\n</code></pre><p>可以看到，这个token内部包含过期时间，快过期的token会在客户端自动和服务端通讯更换，这种方式可以大幅提高截取客户端token并伪造用户身份的难度。</p><p>同时，服务端也可以和用户中心解耦，业务服务端直接解析请求带来的token即可获取用户信息，无需每次请求都去用户中心获取。而token的刷新可以完全由App客户端主动请求用户中心来完成，而不再需要业务服务端业务请求用户中心去更换。</p><p>JWT是如何保证数据不会被篡改，并且保证数据的完整性呢，我们先看看它的组成。</p><p><img src=\"https://static001.geekbang.org/resource/image/24/f6/240a6a36f0fbcd177e990411abbb8df6.jpg?wh=1920x501\" alt=\"图片\"></p><p>如上图所示，加密签名的token分为三个部分，彼此之间用点来分割，其中，Header用来保存加密算法类型；PayLoad是我们自定义的内容；Signature是防篡改签名。</p><p>JWT token解密后的数据结构如下图所示：</p><pre><code class=\"language-json\">//header\n//加密头\n{\n&nbsp; \"alg\": \"HS256\", // 加密算法，注意检测个别攻击会在这里设置为none绕过签名\n&nbsp; \"typ\": \"JWT\" //协议类型\n}\n\n//PAYLOAD\n//负载部分，存在JWT标准字段及我们自定义的数据字段\n{\n&nbsp; \"userid\": \"9527\", //我们放的一些明文信息，如果涉及敏感信息，建议再次加密\n&nbsp; \"nickname\": \"Rick.Xu\", // 我们放的一些明文信息，如果涉及隐私，建议再次加密\n  \"iss\": \"geekbang\",\n&nbsp; \"iat\": 1516239022, //token发放时间\n  \"exp\": 1516246222, //token过期时间\n}\n\n//签名\n//签名用于鉴定上两段内容是否被篡改，如果篡改那么签名会发生变化\n//校验时会对不上\n</code></pre><p>JWT如何验证token是否有效，还有token是否过期、是否合法，具体方法如下：</p><pre><code class=\"language-go\">func DecodeToken(token string) (*TokenPayLoad, error) {\n    token, err := jwt.ParseWithClaims(token, &amp;TokenPayLoad{}, func(tk *jwt.Token) (interface{}, error) {\n        return secret, nil\n    })\n    if err != nil {\n        return nil, err\n    }\n    if decodeToken, ok := token.Claims.(*TokenPayLoad); ok &amp;&amp; token.Valid {\n        return decodeToken, nil\n    }\n    return nil, errors.New(\"token wrong\")\n}\n</code></pre><p>JWT的token解密很简单，第一段和第二段都是通过base64编码的。直接解开这两段数据就可以拿到payload中所有的数据，其中包括用户昵称、uid、用户权限和token过期时间。要验证token是否过期，只需将其中的过期时间和本地时间对比一下，就能确认当前token是不是有效。</p><p>而验证token是否合法则是通过签名验证完成的，任何信息修改都会无法通过签名验证。要是通过了签名验证，就表明token没有被篡改过，是一个合法的token，可以直接使用。</p><p>这个过程如下图所示：<br>\n<img src=\"https://static001.geekbang.org/resource/image/19/8a/19b6179e1ff8ef5a13f0cbf4527ce88a.jpg?wh=3330x2141\" alt=\"\"></p><p>我们可以看到，通过token方式，用户中心压力最大的接口可以下线了，每个业务的服务端只要解开token验证其合法性，就可以拿到用户信息。不过这种方式也有缺点，就是用户如果被拉黑，客户端最快也要在token过期后才能退出登陆，这让我们的管理存在一定的延迟。</p><p>如果我们希望对用户进行实时管理，可以把新生成的token在服务端暂存一份，每次用户请求就和缓存中的token对比一下，但这样很影响性能，极少数公司会这么做。同时，为了提高JWT系统的安全性，token一般会设置较短的过期时间，通常是十五分钟左右，过期后客户端会自动更换token。</p><h2>token的更换和离线</h2><p>那么如何对JWT的token进行更换和离线验签呢？</p><p>具体的服务端换签很简单，只要客户端检测到当前的token快过期了，就主动请求用户中心更换token接口，重新生成一个离当前还有十五分钟超时的token。</p><p>但是期间如果超过十五分钟还没换到，就会导致客户端登录失败。为了减少这类问题，同时保证客户端长时间离线仍能正常工作，行业内普遍使用双token方式，具体你可以看看后面的流程图：</p><p><img src=\"https://static001.geekbang.org/resource/image/de/7c/de29bd40ac360cb06ca6d3e75ac87a7c.jpg?wh=3330x2141\" alt=\"\"></p><p>可以看到，这个方案里有两种token：<strong>一种是refresh_token，用于更换access_token，有效期是30天；另一种是access_token，用于保存当前用户信息和权限信息，每隔15分钟更换一次</strong>。如果请求用户中心失败，并且App处于离线状态，只要检测到本地refresh_token没有过期，系统仍可以继续工作，直到refresh_token过期为止，然后提示用户重新登陆。这样即使用户中心坏掉了，业务也能正常运转一段时间。</p><p>用户中心检测更换token的实现如下：</p><pre><code class=\"language-go\">//如果还有五分钟token要过期，那么换token\nif decodeToken.StandardClaims.ExpiresAt &lt; TimestampNow() - 300 {\n  //请求下用户中心，问问这个人禁登陆没\n  //....略具体\n  \n  //重新发放token\n  token, err := GenToken(.....)\n  if err != nil {\n        return nil, err\n  }\n  //更新返回cookie中token\n  resp.setCookie(\"xxxx\", token)\n}\n</code></pre><p>这段代码只是对当前的token做了超时更换。JWT对离线App端十分友好，因为App可以将它保存在本地，在使用用户信息时直接从本地解析出来即可。</p><h2>安全建议</h2><p>最后我再啰嗦几句，除了上述代码中的注释外，在使用JWT方案的时候还有一些关键的注意事项，这里分享给你。</p><p>第一，通讯过程必须使用HTTPS协议，这样才可以降低被拦截的可能。</p><p>第二，要注意限制token的更换次数，并定期刷新token，比如用户的access_token每天只能更换50次，超过了就要求用户重新登陆，同时token每隔15分钟更换一次。这样可以降低token被盗取后给用户带来的影响。</p><p>第三，Web用户的token保存在cookie中时，建议加上httponly、SameSite=Strict限制，以防止cookie被一些特殊脚本偷走。</p><h2>总结</h2><p>传统的Session方式是把用户的登录信息通过SessionID统一缓存到服务端中，客户端和子系统每次请求都需要到用户中心去“提取”，这就会导致用户中心的流量很大，所有业务都很依赖用户中心。</p><p>为了降低用户中心的流量压力，同时让各个子系统与用户中心脱耦，我们采用信任“签名”的token，把用户信息加密发放到客户端，让客户端本地拥有这些信息。而子系统只需通过签名算法对token进行验证，就能获取到用户信息。</p><p>这种方式的核心是<strong>把用户信息放在服务端外做传递和维护，以此解决用户中心的流量性能瓶颈</strong>。此外，通过定期更换token，用户中心还拥有一定的用户控制能力，也加大了破解难度，可谓一举多得。</p><p>其实，还有很多类似的设计简化系统压力，比如文件crc32校验签名可以帮我们确认文件在传输过程中是否损坏；通过Bloom Filter可以确认某个key是否存在于某个数据集合文件中等等，这些都可以大大提高系统的工作效率，减少系统的交互压力。这些技巧在硬件能力腾飞的阶段，仍旧适用。</p><h2>思考题</h2><p>用户如果更换了昵称，如何快速更换token中保存的用户昵称呢？</p><p>欢迎你在留言区与我交流讨论，我们下节课见！</p>","neighbors":{"left":{"article_title":"02｜缓存一致：读多写少时，如何解决数据更新缓存不同步？","id":596644},"right":[]},"comments":[{"had_liked":false,"id":360874,"user_name":"徐曙辉","can_delete":false,"product_type":"c1","uid":1035885,"ip_address":"北京","ucode":"D8FA8A64FB7E33","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ce/6d/0c15c18a.jpg","comment_is_top":true,"comment_ctime":1666929490,"is_pvip":true,"replies":[{"id":"131282","content":"你好，徐曙辉，很高兴收到你的再次留言<br>对于session 方式来说，由于用户每次请求都会读取session cache，客户端本地是不会保存token，所以不存在token内用户头像更新不及时问题。可以说后台系统用session管理用户很方便，因为这个可以做到用户实时管理，当我们禁用用户的时候把session的缓存登陆标志删掉即可。不过这个方式适合少量用户，对于QPS超过10w QPS请求的API则不太适合。<br><br>所以使用token方式来签名发给客户端，客户端请求其他子系统的时候，会带上它，子系统只要验证这个token的签名就不需要再去用户中心问一句。所以token使用后，用户中心不会被其他子系统频繁请求，但是也导致token发出去没法再次更改，即使我们用户中心给他拉黑了，其他子系统只认印章，不会过来问问。<br><br>同时为了方便token内会保存当前用户一些基础信息，减少其他系统过来询问的次数，这导致，用户更新头像，token没更换，是不会同步更新的<br>第一个很暴力，但是很有趣～<br>第二个方式也很有趣，同时补一个技巧我们可以通过 设定 固定网址 user&#47;用户uid&#47;heaer.jpg方式直接获取用户头像，这样也不用考虑更新问题了<br><br>","user_name":"作者回复","comment_id":360874,"uid":"1004527","ip_address":"北京","utype":1,"ctime":1666940850,"user_name_real":"作者"}],"discussion_count":7,"race_medal":0,"score":"9.2233720385217004e+18","product_id":100309001,"comment_content":"Q1：在token过期很短的时候，通过refresh_token频繁更新token，怎么实现对用户实时管理？是不是还是跟用户人数相关，一般这种场景是后台系统，删除一个用户后该用户账号立刻不能登录，后台人数比C端人数少很多，所以管理起来代价比较小，更看重权限安全，放在缓存中进行管理。<br>A: 如果我来做快速更换昵称的功能，两种方式，<br>a.在用户修改昵称后，内存中加入个用户标识，解析token后读取该标识，有则返回特定code，让客户端重新拿token。甚至可以不用客户端参与，返回301重定向到获取新token的路由。<br>b. token里面不存用户信息，只存用户ID，需要用户信息的时候从缓存读。<br>","like_count":0,"discussions":[{"author":{"id":1004527,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/ef/5cdaa18b.jpg","nickname":"thinkpc","note":"","ucode":"0EBF75B8707584","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591932,"discussion_content":"你好，徐曙辉，很高兴收到你的再次留言\n对于session 方式来说，由于用户每次请求都会读取session cache，客户端本地是不会保存token，所以不存在token内用户头像更新不及时问题。可以说后台系统用session管理用户很方便，因为这个可以做到用户实时管理，当我们禁用用户的时候把session的缓存登陆标志删掉即可。不过这个方式适合少量用户，对于QPS超过10w QPS请求的API则不太适合。\n\n所以使用token方式来签名发给客户端，客户端请求其他子系统的时候，会带上它，子系统只要验证这个token的签名就不需要再去用户中心问一句。所以token使用后，用户中心不会被其他子系统频繁请求，但是也导致token发出去没法再次更改，即使我们用户中心给他拉黑了，其他子系统只认印章，不会过来问问。\n\n同时为了方便token内会保存当前用户一些基础信息，减少其他系统过来询问的次数，这导致，用户更新头像，token没更换，是不会同步更新的\n第一个很暴力，但是很有趣～\n第二个方式也很有趣，同时补一个技巧我们可以通过 设定 固定网址 user/用户uid/heaer.jpg方式直接获取用户头像，这样也不用考虑更新问题了\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666940850,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":4,"child_discussions":[{"author":{"id":2269341,"avatar":"","nickname":"不吃包子","note":"","ucode":"5E0661EC355ED9","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":1004527,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/ef/5cdaa18b.jpg","nickname":"thinkpc","note":"","ucode":"0EBF75B8707584","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":591949,"discussion_content":"你的意思是,针对你的提问,JWT不保存用户信息,只保存用户ID,用户信息存储是到缓存中,单独读取的?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666951037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":591932,"ip_address":"广东"},"score":591949,"extra":""},{"author":{"id":1004527,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/ef/5cdaa18b.jpg","nickname":"thinkpc","note":"","ucode":"0EBF75B8707584","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":2269341,"avatar":"","nickname":"不吃包子","note":"","ucode":"5E0661EC355ED9","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":591953,"discussion_content":"第二种是指，将容易改变的内容，通过其他方式获取，比如用户头像，用固定网址来获取，即使改了网址不会变，只是改变了网址里面的内容","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666953490,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":591949,"ip_address":"北京"},"score":591953,"extra":""},{"author":{"id":1035885,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ce/6d/0c15c18a.jpg","nickname":"徐曙辉","note":"","ucode":"D8FA8A64FB7E33","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1004527,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/ef/5cdaa18b.jpg","nickname":"thinkpc","note":"","ucode":"0EBF75B8707584","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":591972,"discussion_content":"学到了，之前没往这方面想过，按这样做，头像可以http://xx.com/user/用户ID/header.jpg，静态文件可以，因为反正都是远程http渲染，但是昵称和其他信息都这样处理，每一项都放到远程地址性能不是很好，是不是可以http://xxx.com/user/用户ID/info.json，再反序列化，这样确定是占了额外的存储空间，优点是不用查DB和缓存，减少她们的压力，在web应用中，用户信息读取挺频繁","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1666968192,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":591953,"ip_address":"湖南"},"score":591972,"extra":""}]},{"author":{"id":1392585,"avatar":"https://static001.geekbang.org/account/avatar/00/15/3f/c9/1ccefb9a.jpg","nickname":"Sky","note":"","ucode":"4C5A5AB73E8B90","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592000,"discussion_content":"这个技巧学到了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667023600,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1392585,"avatar":"https://static001.geekbang.org/account/avatar/00/15/3f/c9/1ccefb9a.jpg","nickname":"Sky","note":"","ucode":"4C5A5AB73E8B90","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591999,"discussion_content":"同时补一个技巧我们可以通过 设定 固定网址 user/用户uid/heaer.jpg方式直接获取用户头像，这样也不用考虑更新问题了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667023590,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360866,"user_name":"7S","can_delete":false,"product_type":"c1","uid":1199397,"ip_address":"北京","ucode":"A08EEF49BFB076","user_header":"https://static001.geekbang.org/account/avatar/00/12/4d/25/0920057c.jpg","comment_is_top":false,"comment_ctime":1666925335,"is_pvip":false,"replies":[{"id":"131273","content":"你好，7S，很高兴收到你的思考，关于这里有一些特殊的小技巧，如请求时带上一些客户端特征，如：请求更换access_token时，带上的refresh_token的请求 同时 需要特殊的签名，存储在本地的token不用明文保存，与服务端通讯时用特殊协议加密等～","user_name":"作者回复","comment_id":360866,"uid":"1004527","ip_address":"北京","utype":1,"ctime":1666927494,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":1,"score":"14551827223","product_id":100309001,"comment_content":"access_token由于安全问题设置过期的时间非常短，但是refresh_token有效时间非常长，如果refresh_token被泄漏掉，是不是能一直刷新access_token呢。。","like_count":3,"discussions":[{"author":{"id":1004527,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/ef/5cdaa18b.jpg","nickname":"thinkpc","note":"","ucode":"0EBF75B8707584","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591908,"discussion_content":"你好，7S，很高兴收到你的思考，关于这里有一些特殊的小技巧，如请求时带上一些客户端特征，如：请求更换access_token时，带上的refresh_token的请求 同时 需要特殊的签名，存储在本地的token不用明文保存，与服务端通讯时用特殊协议加密等～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666927494,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360895,"user_name":"极客","can_delete":false,"product_type":"c1","uid":1114999,"ip_address":"北京","ucode":"A4AAA6B4F40E66","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/77/3f6a76a9.jpg","comment_is_top":false,"comment_ctime":1666948549,"is_pvip":false,"replies":[{"id":"131287","content":"你好，极客，感谢你的留言，这个思路很有意思，是个方法，印象里这个技巧对于读多写多的服务的客户端也会做类似的事情","user_name":"作者回复","comment_id":360895,"uid":"1004527","ip_address":"北京","utype":1,"ctime":1666954168,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"10256883141","product_id":100309001,"comment_content":"客户端可以缓存修改后的昵称，直到更换了access token再清除缓存，类似弹幕本地先发送让用户自己认为发送成功了","like_count":2,"discussions":[{"author":{"id":1004527,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/ef/5cdaa18b.jpg","nickname":"thinkpc","note":"","ucode":"0EBF75B8707584","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591957,"discussion_content":"你好，极客，感谢你的留言，这个思路很有意思，是个方法，印象里这个技巧对于读多写多的服务的客户端也会做类似的事情","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666954168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360949,"user_name":"Sky","can_delete":false,"product_type":"c1","uid":1392585,"ip_address":"北京","ucode":"4C5A5AB73E8B90","user_header":"https://static001.geekbang.org/account/avatar/00/15/3f/c9/1ccefb9a.jpg","comment_is_top":false,"comment_ctime":1667023544,"is_pvip":false,"replies":[{"id":"131314","content":"你好，sky，很高兴收到你的留言，踢下线可以用网关黑名单方式，每个业务网关会解开token，发现redis中有这个uid以及低于指定版本，就会要求更换","user_name":"作者回复","comment_id":360949,"uid":"1004527","ip_address":"北京","utype":1,"ctime":1667043890,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1667023544","product_id":100309001,"comment_content":"token的方式是怎么处理多终端登录以及“踢下线”类似的功能的呢？","like_count":0,"discussions":[{"author":{"id":1004527,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/ef/5cdaa18b.jpg","nickname":"thinkpc","note":"","ucode":"0EBF75B8707584","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592044,"discussion_content":"你好，sky，很高兴收到你的留言，踢下线可以用网关黑名单方式，每个业务网关会解开token，发现redis中有这个uid以及低于指定版本，就会要求更换","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667043890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360930,"user_name":"Geek_00乐","can_delete":false,"product_type":"c1","uid":3012150,"ip_address":"北京","ucode":"30D3202B6D25DE","user_header":"https://static001.geekbang.org/account/avatar/00/2d/f6/36/a71438d8.jpg","comment_is_top":false,"comment_ctime":1667008207,"is_pvip":true,"replies":[{"id":"131300","content":"你好，Geek_00乐，很高兴你的心得分享，同时补充一句～子系统不会每次都问询用户中心～导致了这个问题","user_name":"作者回复","comment_id":360930,"uid":"1004527","ip_address":"北京","utype":1,"ctime":1667031762,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1667008207","product_id":100309001,"comment_content":"用户如果被拉黑，客户端最快也要在 token 过期后才能退出登陆，这让我们的管理存在一定的延迟。","like_count":0,"discussions":[{"author":{"id":1004527,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/ef/5cdaa18b.jpg","nickname":"thinkpc","note":"","ucode":"0EBF75B8707584","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592016,"discussion_content":"你好，Geek_00乐，很高兴你的心得分享，同时补充一句～子系统不会每次都问询用户中心～导致了这个问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667031762,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}