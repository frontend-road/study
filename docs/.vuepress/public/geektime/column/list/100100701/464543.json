{"id":464543,"title":"课前热身｜学习这门课前，你需要了解哪些知识？","content":"<p>你好，我是于航。</p><p>在我们正式进入到 C 语言课程的学习之前，为了帮助你更好地理解课程内容，我为你准备了一节基础知识讲解课。这是一节选学课，你可以根据自己的实际情况选择性学习。</p><p>在这一讲中，我会用通俗易懂的方式，为你介绍这门课中最常用的一些基础知识，分别是常见数据量单位、汇编语言，以及 CPU 指令集中涉及的不同类型的寄存器。如果你对这些内容还不太熟悉，那么通过这一讲，你可以对它们有一个大致的印象。我们后面的课程还会提到汇编指令或寄存器，我会视情况进行更加具体的讲解，帮你加深理解。</p><h2>数据量单位：位、字节和字</h2><p>位（bit）是计算机中最小的存储单位，每一个位可以存储一个二进制码值的 0 或 1。而字节（byte）则通常是由八个位组成的一个存储单元。在计算机中，字节是最小的可寻址单位，这意味着 CPU 在使用数据时，可以以字节为单位，为每一字节内存分配一个相应的独立地址。</p><p>位和字节是在我们的日常工作中最为常见的两个数据量概念，你应该很熟悉。不过，字（word）的概念就没有这么清晰了。字的大小并不固定，一个字的大小可能是 2 的幂次个位，比如 16 位、32 位，也有可能是 12 位、27 位等一些并不常见的大小。而这主要是因为字的概念与具体的处理器或硬件体系架构直接相关，它跟位、字节这种较为通用和统一的数据量概念并不相同。</p><!-- [[[read_end]]] --><p>字是处理器设计时使用的自然数据单位，通常，这个大小会反映在计算机结构和相关操作的多个方面中。比如，处理器中大多数寄存器的容量是与字同样大小的，处理器单个指令可以操作的最大内存块一般为一个字大小，而用于指定内存中某个具体位置的地址，一般也是以处理器的自然字为宽度的。</p><p>需要说明下，在这门课后面的内容中，<strong>所有给出的示例代码和相关分析，都是在平台类型为 x86-64 的实验机上进行的，而该平台的字长为 64 位。</strong></p><h2>汇编语言</h2><p>在计算机编程中，汇编语言（Assembly Language）是一种低级编程语言，语言使用的指令与具体平台紧密相关。这意味着，针对不同 CPU 体系架构设计的汇编语言无法共用，也不具备可移植性。</p><p>汇编代码可以经由汇编程序（如 as）进行转换，从而得到二进制的可执行代码。不同于高级编程语言，汇编语言在机器指令之上基本不具有任何抽象。因此，通过观察一个程序的汇编代码，我们可以详细了解到程序运行时的每一个具体步骤。所以，<strong>在这门课中，我们会通过汇编代码来观察 C 语法的实现细节，并同时探索程序运行时与操作系统交互的一些关键步骤。</strong></p><p>汇编语言使用助记符（Mnemonic）来表示每个低级的机器指令。助记符是一类带有自然语义的符号，比如 <code>mov</code> 指令，它是英文单词 “move” 的简写，这个指令用来将一个操作数从计算机中的某个位置移动到另一个位置。而 <code>add</code> 指令的语义就更加直观了，它用来将计算机中某个位置上的数据量累加到另一个数据量上。</p><p>不同的汇编指令可以使用不同的参数形式。比如，就 <code>mov</code> 指令来说，对于可以使用该指令来移动的数据，它们通常会位于计算机中三个不同的位置上：</p><ul>\n<li><em><strong>MOV r/m, r</strong></em></li>\n<li><em><strong>MOV r, r/m</strong></em></li>\n<li><em><strong>MOV r/m, imm</strong></em></li>\n</ul><p>在这些指令的参数中，r 表示 register，即寄存器；m 表示 memory，即内存中的某个具体位置；imm 表示 immediate，即直接书写在指令中的立即数。</p><p>为了跟这门课后续的内容保持一致，这里我们直接使用 x86-64 平台，并基于 Intel 指令集的方式来书写和解读汇编代码。因此，指令 <code>mov ebx, 1</code> 的正确含义是：将立即数 1 存放到寄存器 ebx 中（右侧参数为数据来源 src，左侧参数为移动的目的地 dest）。需要注意的是，在 x86 指令集中，受限于 CPU 实现的复杂度，不存在可以将两个内存地址同时作为 src 和 dest 参数的指令。</p><p>汇编指令由助记符组成，而汇编器则负责把这些助记符组成的有效语法格式转换成对应的二进制机器指令。比如就上面提到的汇编指令 <code>mov ebx, 1</code> 而言，它所对应的机器指令代码为二进制值 <code>bb 01 00 00 00</code> 。</p><p>与汇编代码不同的是，二进制机器指令代码的组成结构要复杂许多。上面的汇编指令对应的机器指令是由 OpCode 和 Immediate Data 两部分组成的。OpCode 在这里占用一个字节，这个字节是由指令对应的 0xb8 ，外加特定目的寄存器对应的寄存器域值 0x3 组成的。而紧跟着 OpCode 的，便是立即数 1 对应的部分。由于该指令用于传送 32 位数，因此立即数这里单独占用 4 个字节。需要注意的是，对于这段机器指令代码，最左侧的字节 0xbb 处在内存的低位（即小端序）。</p><p>在较为复杂的机器指令中，还可能包含有与 ModR/M、SIB、Displacement 以及 REX 等有关的信息。而这些信息有些并不会直接体现在上层的汇编代码中，它们大多仅与当前平台 CPU 的体系架构，或操作系统所处的模式有关。</p><h2>指令集中的寄存器</h2><p>在编写汇编语言代码时，我们经常会跟寄存器打交道。那么，什么是寄存器呢？</p><p>寄存器有时也被称为“寄存器文件（Register File）”，你可以把它简单理解为由 CPU 提供的一组位于芯片上的高速存储器硬件，可用于存储数据。通常来说，寄存器可以使用 SRAM 来实现。SRAM 是一种高速随机访问存储器，它将每个位的数据存放在一个对应的“双稳态”存储器中，从而保持较强的抗干扰能力和较快的数据访问速度。在整个计算机体系架构中，<strong>寄存器拥有最快的数据访问速度和最低的延迟</strong>。</p><p>通常来说，我们在汇编代码中使用的寄存器（比如之前提到的 ebx）可能并不与 CPU 上的物理寄存器完全一一对应，CPU 会使用额外的方式来保证它们之间的动态对应关系。这些参与到程序运行过程的寄存器，一般可以分为：通用目的寄存器、状态寄存器、系统寄存器，以及用于支持浮点数计算和 SIMD 的 AVX、SSE 寄存器等。</p><p>在这些寄存器中，通用目的寄存器一般用于存放程序运行过程中产生的临时数据，这些寄存器在大多数情况下都可以被当作普通寄存器使用。而在某些特殊情况下，它们可能会被用于存放指令计算结果、系统调用号，以及与栈帧相关的内存地址等信息。状态寄存器一般用于存放与指令执行结果相关的状态信息，比如指令执行是否引起进位、计算结果是否为 0 等。系统寄存器一般由操作系统使用，这些寄存器描述了与虚拟内存、中断、CPU 模式等有关的信息。</p><p>在 x86-64 架构下，CPU 指令集架构（ISA）中一共定义了 16 个通用目的寄存器。这些寄存器最大可以存放 4 个指令字，即 64 位长的数据。需要注意的是，<strong>这里我们提到的“指令字”与之前介绍的用于描述 CPU 硬件特征的“硬件字”有所不同</strong>（指令字与硬件字这两个叫法只是我用来区分这两种字概念的）。由于历史原因，在现代 x86 系列 CPU 的指令集文档中，你可能会看到对 WORD 一词的使用。虽然这个单词可以被翻译为“字”，但在这样的环境下，它实则代表着固定 16 位的长度。关于它的具体使用方式，我会在 <a href=\"https://time.geekbang.org/column/article/466203\">03 讲 </a>中详细介绍。</p><p>在汇编代码中，我们可以使用每个寄存器不同部分对应的别名，来针对性地访问它们的低 8 位、低 16 位、低 32 位，以及完整的 64 位数据。关于这些寄存器的具体名称，你可以参考下面这张图：</p><p><img src=\"https://static001.geekbang.org/resource/image/ed/0b/ed27329a1fb82df016d60a196yybb00b.jpg?wh=1920x2474\" alt=\"图片\"></p><p>这张图怎么看呢？这里以我们之前遇到的 ebx 寄存器为例：观察上图可以得知，通过 ebx，我们可以访问大小为 32 位的数据，该数据为寄存器 rbx 的低 32 位。因此，直接使用 rbx 便可访问该寄存器的全部 64 位数据。而使用 bx 与 bl ，便可相应访问该寄存器的低 16 位与低 8 位数据。</p><p>另外，还需注意的一点是：我们可以通过不同的寄存器别名来读写同一寄存器不同位置上的数据。当某个指令需要重写寄存器的低 16 位或低 8 位数据时，寄存器中其他位上的数据不会被修改。而当指令需要重写寄存器低 32 位的数据时，高 32 位的数据会被同时复位，即置零。</p><p>听到这里，你可能觉得理解起来有些困难，不用担心，在课程的后面我还会多次介绍有关寄存器的内容。你可以先试着在 x86-64 平台上使用 GNU GCC 编译和运行下面这段代码。这里注意，在编译时不要为编译器指定任何优化参数。</p><pre><code class=\"language-c++\">#include &lt;stdio.h&gt;\nint main(void) {\n  register long num asm(\"rax\") = 0x100000000;\n  asm(\"movl $0x1, %eax\");\n  // asm(\"movw $0x1, %ax\");\n  printf(\"%ld\\n\", num);\n  return 0;\n}\n</code></pre><p>这样，你就可以看到，当指令作用于寄存器的不同部分时，CPU 对寄存器其他部分的影响。这里我们将值 0x100000000 放入寄存器 rax 中，在该 64 位值（long）对应的二进制编码中，其第 32 位被置位。第一句汇编指令将值 0x1 通过 <code>movl</code> 移动到 rax 寄存器的低 32 位；而第二句汇编指令将值 0x1 通过 <code>movw</code> 移动到 rax 寄存器的低 16 位。那么，通过这两种方式分别处理后的变量 <code>num</code> 的值是否相同呢？你可以自己进行实践，并在评论区留下答案。</p><p>随着课程的学习，你会看到这门课给出的示例代码中，存在着大量对这些通用寄存器的使用过程。而如何高效、有序地分配和使用寄存器，是编译器的重要任务之一，你会在后面的课程中了解到编译器在使用不同优化等级时对待寄存器的区别。</p><h2>总结</h2><p>讲到这里，今天的内容也就基本结束了。最后我们来一起总结下吧。</p><p>今天我主要介绍了常见数据量单位、汇编语言，以及指令集中寄存器的相关知识，希望这些基础知识能够为你接下来的学习提供一些帮助。</p><p>常见数据量单位包括位、字节和字。其中，一个字节等于 8 位，而字的大小则与具体的 CPU 体系结构紧密相关，常见大小可以是 32 位与 64 位。</p><p>汇编语言是一种低级编程语言，它用助记符的形式来描述程序对应机器指令的基本逻辑。由于它直接对应于 CPU 指令集之上，因此不具有可移植性。</p><p>寄存器是位于 CPU 芯片上的高速数据存储单元，根据功能，它可以被分为通用目的寄存器、状态寄存器等多种类型。x86-64 一共提供了 16 个通用目的寄存器，通过在汇编代码中使用不同的寄存器别名，我们可以快速访问这些寄存器中存放的数据。</p><h2>思考题</h2><p>这里，我们来一起做个思考题，巩固下今天的学习内容吧。</p><p>阅读下面的汇编代码，并尝试分析：当所有指令执行完毕时，寄存器 eax 中的值是多少？</p><pre><code class=\"language-c++\">mov eax, 0x1\ninc eax\nsub eax, 10\nxor eax, eax\nadd eax, 1\nmul eax\n</code></pre><p>这节选学课到这里就结束了，希望可以帮助到你，也希望你在下方的留言区和我交流讨论。如果这节课对你有帮助，也欢迎你把它分享给你的朋友或者同事。</p>","neighbors":{"left":{"article_title":"开篇词｜时至今日，如何更好地拥抱现代 C 语言？","id":464540},"right":{"article_title":"01｜快速回顾：一个 C 程序的完整生命周期","id":464550}},"comments":[{"had_liked":false,"id":325167,"user_name":"ZR2021","can_delete":false,"product_type":"c1","uid":1707352,"ip_address":"","ucode":"4F685C7516F057","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKwGurTWOiaZ2O2oCdxK9kbF4PcwGg0ALqsWhNq87hWvwPy8ZU9cxRzmcGOgdIeJkTOoKfbxgEKqrg/132","comment_is_top":true,"comment_ctime":1638847180,"is_pvip":false,"replies":[{"id":"118006","content":"这又是一个好问题！其实这里我们在代码中使用的是 AT&amp;T 的写法，是一种默认被编译器广泛支持的内联汇编写法。当然，我们也可以做适当的调整来使用 Intel 写法，比如这样：<br><br>#include &lt;stdio.h&gt;<br>int main(void) {<br>  register long num asm(&quot;rax&quot;) = 0x100000000;<br>  asm(<br>    &quot;.intel_syntax noprefix \\n\\t&quot;<br>    &quot;mov eax, 1\\n\\t&quot;<br>    &#47;&#47; &quot;mov ax, 1\\n\\t&quot;<br>    &quot;.att_syntax&quot;<br>  );<br>  printf(&quot;%ld\\n&quot;, num);<br>  return 0;<br>}<br><br>但这种方式的问题在于，对于某些汇编器可能没有很好的兼容性。","user_name":"作者回复","comment_id":325167,"uid":"1005890","ip_address":"","utype":1,"ctime":1638864278,"user_name_real":"编辑"}],"discussion_count":2,"race_medal":0,"score":"9.223372124393001e+18","product_id":100100701,"comment_content":"于老师，为啥main函数里的asm(&quot;movl $0x1, %eax&quot;);是将1给eax的，src 跟dst反过来了好像","like_count":20,"discussions":[{"author":{"id":1707352,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKwGurTWOiaZ2O2oCdxK9kbF4PcwGg0ALqsWhNq87hWvwPy8ZU9cxRzmcGOgdIeJkTOoKfbxgEKqrg/132","nickname":"ZR2021","note":"","ucode":"4F685C7516F057","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536765,"discussion_content":"哦哦，难怪了，之前一直搞不清一些指令的arc跟dst，感觉好混乱，原来是这个原因，谢谢老师！！！","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1638864794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536762,"discussion_content":"这又是一个好问题！其实这里我们在代码中使用的是 AT&amp;T 的写法，是一种默认被编译器广泛支持的内联汇编写法。当然，我们也可以做适当的调整来使用 Intel 写法，比如这样：\n\n#include &lt;stdio.h&gt;\nint main(void) {\n  register long num asm(&#34;rax&#34;) = 0x100000000;\n  asm(\n    &#34;.intel_syntax noprefix \\n\\t&#34;\n    &#34;mov eax, 1\\n\\t&#34;\n    // &#34;mov ax, 1\\n\\t&#34;\n    &#34;.att_syntax&#34;\n  );\n  printf(&#34;%ld\\n&#34;, num);\n  return 0;\n}\n\n但这种方式的问题在于，对于某些汇编器可能没有很好的兼容性。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1638864278,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":326031,"user_name":"继业(Adrian)","can_delete":false,"product_type":"c1","uid":1021147,"ip_address":"","ucode":"D9BAF5F939A2B6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/94/db/4e658ce8.jpg","comment_is_top":false,"comment_ctime":1639320572,"is_pvip":true,"replies":[{"id":"118254","content":"完全正确！","user_name":"作者回复","comment_id":326031,"uid":"1005890","ip_address":"","utype":1,"ctime":1639325011,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"66063830012","product_id":100100701,"comment_content":"quizz:<br>```<br>mov eax, 0x1\t# 0b1<br>inc eax \t\t# 0b10<br>sub eax, 10\t\t# 0b10 - 0b1010 = 0xfffffff8<br>xor eax, eax\t# 0xfffffff8 xor 0xfffffff8 = 0x00000000<br>add eax, 1\t\t# 0x00000001<br>mul eax\t\t\t# 0x00000001 mul 0x00000001 = 0x00000001<br>```<br>answer: 0x00000001 = 1","like_count":15,"discussions":[{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538119,"discussion_content":"完全正确！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639325011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325233,"user_name":"糊糊","can_delete":false,"product_type":"c1","uid":1067825,"ip_address":"","ucode":"74875CB3A84E18","user_header":"https://static001.geekbang.org/account/avatar/00/10/4b/31/c1ce2abc.jpg","comment_is_top":false,"comment_ctime":1638871481,"is_pvip":false,"replies":[{"id":"118058","content":"很好的问题！<br><br>第一个问题：每一个汇编指令都有其对应的组成结构，汇编器会根据助记符的名称进行相应的转换。具体的转换细节可以参考官方手册。比如对于 x86-64：https:&#47;&#47;www.intel.com&#47;content&#47;www&#47;us&#47;en&#47;developer&#47;articles&#47;technical&#47;intel-sdm.html<br><br>第二个问题：二进制状态下的机器指令识别可以通过每个指令对应的 OpCode 字节进行切分，然后再根据相应的结构解析出整体指令的结构。","user_name":"作者回复","comment_id":325233,"uid":"1005890","ip_address":"","utype":1,"ctime":1638933481,"user_name_real":"编辑"}],"discussion_count":3,"race_medal":0,"score":"27408675257","product_id":100100701,"comment_content":"请教老师， 文中 mov ebx, 1 ，它所对应的机器指令代码为二进制值 bb 01 00 00 00 ，问题有两个：<br> 1、汇编助记符 mov 是如何被翻译为二进制的 ? 是通过在哪里查的表吗 ，如果是查的表，那表又存在哪里呢<br> 2、 那根据机器码二进制能否推导出汇编代码呢？bb 01 00 00 00  ==》mov ebx, 1 ","like_count":6,"discussions":[{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537006,"discussion_content":"很好的问题！\n\n第一个问题：每一个汇编指令都有其对应的组成结构，汇编器会根据助记符的名称进行相应的转换。具体的转换细节可以参考官方手册。比如对于 x86-64：https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html\n\n第二个问题：二进制状态下的机器指令识别可以通过每个指令对应的 OpCode 字节进行切分，然后再根据相应的结构解析出整体指令的结构。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1638933482,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1667175,"avatar":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","nickname":"qinsi","note":"","ucode":"090D9C4068FF12","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536903,"discussion_content":"https://www.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html 第1215页的表格，相关记号的解释在第576页的表格。祝好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638890421,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1067825,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4b/31/c1ce2abc.jpg","nickname":"糊糊","note":"","ucode":"74875CB3A84E18","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1667175,"avatar":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","nickname":"qinsi","note":"","ucode":"090D9C4068FF12","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":537004,"discussion_content":"感谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638932353,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":536903,"ip_address":""},"score":537004,"extra":""}]}]},{"had_liked":false,"id":325083,"user_name":"权","can_delete":false,"product_type":"c1","uid":1561548,"ip_address":"","ucode":"71D9AFCADBB510","user_header":"https://static001.geekbang.org/account/avatar/00/17/d3/cc/05c1fc28.jpg","comment_is_top":false,"comment_ctime":1638802412,"is_pvip":true,"replies":[{"id":"118014","content":"答案是正确的哈！","user_name":"作者回复","comment_id":325083,"uid":"1005890","ip_address":"","utype":1,"ctime":1638866734,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"23113638892","product_id":100100701,"comment_content":"验证重写64位寄存器低32位&#47;低16位&#47;低8位的代码中如果不是按照文中那样给寄存器赋值，而是任意赋值，建议大家将printf(&quot;%ld\\n&quot;, num);改为printf(&quot;%lx\\n&quot;, num);，输出16进制数，这样才能观察到正确的结果，否则输出10进制数，一开始没注意的话会发现结果很奇怪<br><br>思考题：<br>xor eax, eax是异或，eax自己与自己异或应该为0<br>add eax, 1，相当于0x0+0x1=0x1<br>mul eax之后eax的结果应该还是0x1，不知道理论分析是否正确，汇编还不是很熟","like_count":5,"discussions":[{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536779,"discussion_content":"答案是正确的哈！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638866734,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325112,"user_name":"jack123","can_delete":false,"product_type":"c1","uid":2718510,"ip_address":"","ucode":"873D0046EF39D6","user_header":"","comment_is_top":false,"comment_ctime":1638833665,"is_pvip":false,"replies":[{"id":"118016","content":"没错！","user_name":"作者回复","comment_id":325112,"uid":"1005890","ip_address":"","utype":1,"ctime":1638866969,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"14523735553","product_id":100100701,"comment_content":"xor eax，eax 相当于把eax置零了，最后+1，然后mul相乘 默认与eax相乘，最后还是为1","like_count":3,"discussions":[{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536782,"discussion_content":"没错！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638866969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":326116,"user_name":"琥珀·","can_delete":false,"product_type":"c1","uid":1162136,"ip_address":"","ucode":"7DB119EB3D4F8F","user_header":"https://static001.geekbang.org/account/avatar/00/11/bb/98/db72a54a.jpg","comment_is_top":false,"comment_ctime":1639385420,"is_pvip":false,"replies":[{"id":"118454","content":"理解正确哈！","user_name":"作者回复","comment_id":326116,"uid":"1005890","ip_address":"","utype":1,"ctime":1639448949,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"10229320012","product_id":100100701,"comment_content":"因为我的环境有 warning: overflow in conversion from &#39;long long int&#39; to &#39;long int&#39; 的告警，所以把<br>register long num 改成了 register long long num<br>#include &lt;stdio.h&gt;<br>int main(void) {<br>  register long long num asm(&quot;rax&quot;) = 0x100000000;<br>  asm(&quot;movl $0x1, %eax&quot;);<br>&#47;&#47;   asm(&quot;movw $0x1, %ax&quot;);<br>  printf(&quot;%llx\\n&quot;, num);<br>  return 0;<br>}<br><br>不知道这样理解对不对：<br><br>当某个指令需要重写寄存器的低 16 位或低 8 位数据时，寄存器中其他位上的数据不会被修改。所以asm(&quot;movw $0x1, %ax&quot;) 不会修改rax的值，这时num输出的值为0x100000001<br><br>而当指令需要重写寄存器低 32 位的数据时，高 32 位的数据会被同时复位，即置零。所以 asm(&quot;movl $0x1, %eax&quot;) 会将 rax 的结果置零后再写入1，这时num输出的值为0x1。","like_count":2,"discussions":[{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538575,"discussion_content":"理解正确哈！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639448949,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325857,"user_name":"傻猫周大福","can_delete":false,"product_type":"c1","uid":2088255,"ip_address":"","ucode":"C3975AD7E7CA2A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eriazqrbvq8h7B9JfjmKF9xMB2fSxc9adVGoveQP0IMkDib6k4Jyb931icAWBUFp6MB25Eqbe0O9bvLg/132","comment_is_top":false,"comment_ctime":1639201430,"is_pvip":true,"replies":[{"id":"118256","content":"这是一个很好的发现！","user_name":"作者回复","comment_id":325857,"uid":"1005890","ip_address":"","utype":1,"ctime":1639326642,"user_name_real":"编辑"}],"discussion_count":3,"race_medal":0,"score":"10229136022","product_id":100100701,"comment_content":"在clang下，rax寄存器虽然被置位，但在此之前会将rax寄存器的值拷贝到栈中，在输出时不会把被置位后的rax输出，而是从栈中重新取出num的值","like_count":2,"discussions":[{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538123,"discussion_content":"这是一个很好的发现！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639326643,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1004577,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/54/21/8c13a2b4.jpg","nickname":"周龙亭","note":"","ucode":"21BD0DD15CFCA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590451,"discussion_content":"可能 clang 并没有把 register 修饰的 num 变量放入寄存器，当成普通变量了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665750201,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1959822,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/e7/8e/318cfde0.jpg","nickname":"Spoon","note":"","ucode":"2FF9193AD482C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589377,"discussion_content":"所以在mac下面输出的还是原来的值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664783518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325489,"user_name":"cc","can_delete":false,"product_type":"c1","uid":1037891,"ip_address":"","ucode":"68E69205A7D5BC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d6/43/0704d7db.jpg","comment_is_top":false,"comment_ctime":1638975990,"is_pvip":false,"replies":[{"id":"118132","content":"这是一个很好的发现！我们修改了文章，稍后会更新。<br><br>简单来讲就是：字这个概念会在多个地方的多种不同场景下使用。而文中我们介绍的字实际上是指可以体现 CPU 硬件特征的那个字，我一般会称它为硬件字。而在 CPU 指令集中，字也被用来作为衡量数据大小的单位。x86 架构由于历史原因，会将指令集中出现的 WORD 定义为固定 16 位的大小。所以实际文中提到的 4 个字你可以理解为指令字，它的单位是 WORD，4 个字即对应 64 位大小。","user_name":"作者回复","comment_id":325489,"uid":"1005890","ip_address":"","utype":1,"ctime":1639051308,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"10228910582","product_id":100100701,"comment_content":"在 x86-64 架构下，CPU 指令集架构（ISA）中一共定义了 16 个通用目的寄存器，这些寄存器最大可以存放 4 个字，即 64 位长的数据。在汇编代码中<br>----<br><br>x86-64 下一个字长不就 64bit 了吗，为什么这里说 「4 个字，即 64 位长的数据」","like_count":2,"discussions":[{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537397,"discussion_content":"这是一个很好的发现！我们修改了文章，稍后会更新。\n\n简单来讲就是：字这个概念会在多个地方的多种不同场景下使用。而文中我们介绍的字实际上是指可以体现 CPU 硬件特征的那个字，我一般会称它为硬件字。而在 CPU 指令集中，字也被用来作为衡量数据大小的单位。x86 架构由于历史原因，会将指令集中出现的 WORD 定义为固定 16 位的大小。所以实际文中提到的 4 个字你可以理解为指令字，它的单位是 WORD，4 个字即对应 64 位大小。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639051308,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325150,"user_name":"dog_brother","can_delete":false,"product_type":"c1","uid":1619597,"ip_address":"","ucode":"9F64D3C6D815FB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er6OV33jHia3U9LYlZEx2HrpsELeh3KMlqFiaKpSAaaZeBttXRAVvDXUgcufpqJ60bJWGYGNpT7752w/132","comment_is_top":false,"comment_ctime":1638843693,"is_pvip":true,"replies":[{"id":"118010","content":"关于这个问题我可以先给点提示，然后你再思考下看看。第一个提示就是把第一行 printf 中的 “%d” 改成 “%ld” 就可以输出正确的结果；第二个提示是 printf 的调用会影响寄存器 rax 的值。","user_name":"作者回复","comment_id":325150,"uid":"1005890","ip_address":"","utype":1,"ctime":1638866071,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"10228778285","product_id":100100701,"comment_content":"按老师的程序去执行，第一种（asm(&quot;movl $0x1, %eax&quot;);）结果是1，第二种（asm(&quot;movw $0x1, %ax&quot;);）结果是4294967297。<br>==============================<br>```c<br>#include &lt;stdio.h&gt;<br>int main(void) {<br>  register long num asm(&quot;rax&quot;) = 0x100000000;<br>  asm(&quot;movl $0x1, %eax&quot;); &#47;&#47; 第一种<br>  &#47;&#47; asm(&quot;movw $0x1, %ax&quot;); &#47;&#47; 第二种<br>  printf(&quot;%d\\n&quot;, num);<br>  printf(&quot;%ld\\n&quot;, num);<br>  printf(&quot;%X\\n&quot;, num);<br>  return 0;<br>}<br>```<br>按我这段的代码去执行，第一种（movl）和第二种（movw）的执行结果都是<br>```shell<br>1<br>2<br>2<br>```","like_count":2,"discussions":[{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536773,"discussion_content":"关于这个问题我可以先给点提示，然后你再思考下看看。第一个提示就是把第一行 printf 中的 “%d” 改成 “%ld” 就可以输出正确的结果；第二个提示是 printf 的调用会影响寄存器 rax 的值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638866071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":326677,"user_name":"友","can_delete":false,"product_type":"c1","uid":2536820,"ip_address":"","ucode":"972A4333A8B101","user_header":"https://static001.geekbang.org/account/avatar/00/26/b5/74/cd80b9f4.jpg","comment_is_top":false,"comment_ctime":1639627292,"is_pvip":false,"replies":[{"id":"118763","content":"嗯嗯，加油！","user_name":"作者回复","comment_id":326677,"uid":"1005890","ip_address":"","utype":1,"ctime":1639756914,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"5934594588","product_id":100100701,"comment_content":"老师您这张寄存器的图让我想起来当时看csapp第三章的感觉 我一定要跟着你把c学好","like_count":1,"discussions":[{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539592,"discussion_content":"嗯嗯，加油！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1639756914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325992,"user_name":"墨","can_delete":false,"product_type":"c1","uid":2616644,"ip_address":"","ucode":"8198903D2029D2","user_header":"https://static001.geekbang.org/account/avatar/00/27/ed/44/4399a41a.jpg","comment_is_top":false,"comment_ctime":1639297446,"is_pvip":false,"replies":[{"id":"118250","content":"正解！","user_name":"作者回复","comment_id":325992,"uid":"1005890","ip_address":"","utype":1,"ctime":1639323439,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"5934264742","product_id":100100701,"comment_content":"eax = 1<br>eax = eax + 1<br>eax = eax - 10<br>异或操作令 eax = 0<br>eax = eax + 1<br>eax = eax * eax<br>最后eax = 1","like_count":1,"discussions":[{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538103,"discussion_content":"正解！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639323439,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358411,"user_name":"Geek1185","can_delete":false,"product_type":"c1","uid":2028954,"ip_address":"北京","ucode":"47BEE492EF4C1A","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f5/9a/63dc81a2.jpg","comment_is_top":false,"comment_ctime":1664277398,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664277398","product_id":100100701,"comment_content":"不太明白的是，文中例题，在Mac上输出结果都是100000000。<br>第一行汇编操作对低32位置位时不应该会把高位置零吗<br>第二行汇编操作对低16位置位时不会把高位置零，但结果应该也加一吧","like_count":0},{"had_liked":false,"id":357624,"user_name":"x","can_delete":false,"product_type":"c1","uid":3039249,"ip_address":"广东","ucode":"F67BCCFB611824","user_header":"https://static001.geekbang.org/account/avatar/00/2e/60/11/0980d268.jpg","comment_is_top":false,"comment_ctime":1663498376,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1663498376","product_id":100100701,"comment_content":"1","like_count":0},{"had_liked":false,"id":337870,"user_name":"尚广川","can_delete":false,"product_type":"c1","uid":1402147,"ip_address":"","ucode":"7B330FF7B3B4B0","user_header":"https://static001.geekbang.org/account/avatar/00/15/65/23/13a02bca.jpg","comment_is_top":false,"comment_ctime":1647098598,"is_pvip":false,"replies":[{"id":"123712","content":"我不太熟悉 CUDA，找到了一个 slide，不知道对你的问题有没有帮助：https:&#47;&#47;cilvr.cs.nyu.edu&#47;diglib&#47;lsml&#47;lecture05-cuda-02.pdf。NVIDIA 本身是有一套针对各个 GPU 的闭源机器指令的，在实际执行时 CUDA 程序中，device component 按我的理解应该是会被编译成这些特殊的机器指令的。nvcc 在处理代码时就会将源码分成普通 C&#47;C++ 代码和运行于 GPU 的 C&#47;C++ 代码，然后分别处理。<br><br>回到你的问题，实际上是没错的，只要计算机采用的是冯诺依曼体系，C 语言作为高级语言就可以被各类编译器转换成对应的机器语言，进而在这些体系上完成相应任务。","user_name":"作者回复","comment_id":337870,"uid":"1005890","ip_address":"","utype":1,"ctime":1647523918,"user_name_real":"作者"}],"discussion_count":1,"race_medal":0,"score":"1647098598","product_id":100100701,"comment_content":"请问老师使用c语言进行cuda编程是否可以理解为c语言被编译为了GPU的汇编指令，是否也就是说c语言只要有对应的编译器，就可以在任何处理器上进行编程呢？","like_count":0,"discussions":[{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556824,"discussion_content":"我不太熟悉 CUDA，找到了一个 slide，不知道对你的问题有没有帮助：https://cilvr.cs.nyu.edu/diglib/lsml/lecture05-cuda-02.pdf。NVIDIA 本身是有一套针对各个 GPU 的闭源机器指令的，在实际执行时 CUDA 程序中，device component 按我的理解应该是会被编译成这些特殊的机器指令的。nvcc 在处理代码时就会将源码分成普通 C/C++ 代码和运行于 GPU 的 C/C++ 代码，然后分别处理。\n\n回到你的问题，实际上是没错的，只要计算机采用的是冯诺依曼体系，C 语言作为高级语言就可以被各类编译器转换成对应的机器语言，进而在这些体系上完成相应任务。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647523918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328023,"user_name":"风清扬","can_delete":false,"product_type":"c1","uid":1047043,"ip_address":"","ucode":"651F1390B64953","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fa/03/619e3e48.jpg","comment_is_top":false,"comment_ctime":1640486129,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1640486129","product_id":100100701,"comment_content":"```<br><br>#include &lt;stdio.h&gt;<br>int main(void) {<br>  register long num asm(&quot;rax&quot;) = 0x100000000;<br>  &#47;&#47; 1 asm(&quot;movl $0x1, %eax&quot;);<br>  &#47;&#47; 2 asm(&quot;movw $0x1, %ax&quot;);<br>  printf(&quot;%ld\\n&quot;, num);<br>  return 0;<br>}<br>```<br>放开注释1，结果：1，注释1位置代码，放开位置2，结论2的32次方+1，原因是文章中提到的：当某个指令需要重写寄存器的低 16 位或低 8 位数据时，寄存器中其他位上的数据不会被修改。而当指令需要重写寄存器低 32 位的数据时，高 32 位的数据会被同时复位，即置零。","like_count":0},{"had_liked":false,"id":327637,"user_name":"梅哥","can_delete":false,"product_type":"c1","uid":1981736,"ip_address":"","ucode":"9B7712F0BEFEB8","user_header":"","comment_is_top":false,"comment_ctime":1640218582,"is_pvip":false,"replies":[{"id":"119430","content":"实际上，除基本的调用约定以及 asm 那句代码以外，其他具体实现都是 implementation-dependent 的，也就是说，编译器会保证在不违背上述两个必须满足的条件之下，用各种不同方式来实现这段代码（当然，外部可观测行为也不会发生变化是个大前提）。所以，这段代码并不会在所有编译器上都得到相同的效果。","user_name":"作者回复","comment_id":327637,"uid":"1005890","ip_address":"","utype":1,"ctime":1640482889,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1640218582","product_id":100100701,"comment_content":"请问clang与gcc编译内嵌asm的代码时，是需要做什么参数指定吗，文稿中的这段代码，用gcc编译是正常的，但用clang得到的是不同的结果<br><br>#include &lt;stdio.h&gt;<br>int main(void) {<br>  register long num asm(&quot;rax&quot;) = 0x100000000;<br>  asm(&quot;movl $0x1, %eax&quot;);<br>  &#47;&#47; asm(&quot;movw $0x1, %ax&quot;);<br>  printf(&quot;%ld\\n&quot;, num);<br>  return 0;<br>}","like_count":0,"discussions":[{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541603,"discussion_content":"实际上，除基本的调用约定以及 asm 那句代码以外，其他具体实现都是 implementation-dependent 的，也就是说，编译器会保证在不违背上述两个必须满足的条件之下，用各种不同方式来实现这段代码（当然，外部可观测行为也不会发生变化是个大前提）。所以，这段代码并不会在所有编译器上都得到相同的效果。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640482889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":326218,"user_name":"杰良","can_delete":false,"product_type":"c1","uid":2567349,"ip_address":"","ucode":"5DC1D1C58A4731","user_header":"https://static001.geekbang.org/account/avatar/00/27/2c/b5/10141329.jpg","comment_is_top":false,"comment_ctime":1639441994,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639441994","product_id":100100701,"comment_content":"因为有 asm 关键字，具体平台的汇编能力也就成为了 C 的能力，需要去学习了解。","like_count":0},{"had_liked":false,"id":325266,"user_name":"=","can_delete":false,"product_type":"c1","uid":2600127,"ip_address":"","ucode":"104232A8292220","user_header":"https://static001.geekbang.org/account/avatar/00/27/ac/bf/f549183e.jpg","comment_is_top":false,"comment_ctime":1638884240,"is_pvip":false,"replies":[{"id":"118050","content":"其他 Intel CPU 不太清楚诶，在 x86-64 上是小端序的。","user_name":"作者回复","comment_id":325266,"uid":"1005890","ip_address":"","utype":1,"ctime":1638924590,"user_name_real":"编辑"}],"discussion_count":2,"race_medal":0,"score":"1638884240","product_id":100100701,"comment_content":"老师好，请问Intel的寄存器在存储数据和读取数据时，也遵循小头优先吗？","like_count":0,"discussions":[{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536967,"discussion_content":"其他 Intel CPU 不太清楚诶，在 x86-64 上是小端序的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638924590,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2600127,"avatar":"https://static001.geekbang.org/account/avatar/00/27/ac/bf/f549183e.jpg","nickname":"=","note":"","ucode":"104232A8292220","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":537340,"discussion_content":"谢谢老师😍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639036815,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":536967,"ip_address":""},"score":537340,"extra":""}]}]},{"had_liked":false,"id":325260,"user_name":"=","can_delete":false,"product_type":"c1","uid":2600127,"ip_address":"","ucode":"104232A8292220","user_header":"https://static001.geekbang.org/account/avatar/00/27/ac/bf/f549183e.jpg","comment_is_top":false,"comment_ctime":1638883052,"is_pvip":false,"replies":[{"id":"118048","content":"正解！","user_name":"作者回复","comment_id":325260,"uid":"1005890","ip_address":"","utype":1,"ctime":1638921480,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1638883052","product_id":100100701,"comment_content":"eax异或后为0，然后再加1，因此eax中的内容变为1，最后与1相乘，结果仍然为1","like_count":0,"discussions":[{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536953,"discussion_content":"正解！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638921480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325157,"user_name":"Geek_828b39","can_delete":false,"product_type":"c1","uid":2729802,"ip_address":"","ucode":"DE2A5F215A3C1E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/D62JX0VEX0yhnWxgbiaXMUnEqdsVxc8JMxUBibVicbLSZ6zia606EG0zI9oosiceHsdiavDZGUyHzcvsEExFGxwP4mDg/132","comment_is_top":false,"comment_ctime":1638844766,"is_pvip":false,"replies":[{"id":"118012","content":"可以简单描述下你的执行环境和代码吗？","user_name":"作者回复","comment_id":325157,"uid":"1005890","ip_address":"","utype":1,"ctime":1638866206,"user_name_real":"编辑"}],"discussion_count":5,"race_medal":0,"score":"1638844766","product_id":100100701,"comment_content":"当某个指令需要重写寄存器的低 16 位或低 8 位数据时，寄存器中其他位上的数据不会被修改。而当指令需要重写寄存器低 32 位的数据时，高 32 位的数据会被同时复位，即置零。<br>按照文章的描述，当执行asm(&quot;movl $0x1, %eax&quot;);后，num应该输出是1。当执行asm(&quot;movw $0x1, %ax&quot;);后应该输出0x100000001。但是实际都是输出1。老师，这是文章描述有误还是环境不对？","like_count":0,"discussions":[{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536776,"discussion_content":"可以简单描述下你的执行环境和代码吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638866206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2729802,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/D62JX0VEX0yhnWxgbiaXMUnEqdsVxc8JMxUBibVicbLSZ6zia606EG0zI9oosiceHsdiavDZGUyHzcvsEExFGxwP4mDg/132","nickname":"Geek_828b39","note":"","ucode":"DE2A5F215A3C1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537074,"discussion_content":"老师不好意思，是代码问题。修改后就正常了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1638950186,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1644337,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLTJvY7yqHNtMZnOPEHLYlMLt8oF1G3StHRXhONLy9lxbKicSFUuLianbVpU6KP7ybHvwehDM7Zf4tw/132","nickname":"InfoQ_cd8b36336f8a","note":"","ucode":"EBDDDE2E869D97","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2729802,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/D62JX0VEX0yhnWxgbiaXMUnEqdsVxc8JMxUBibVicbLSZ6zia606EG0zI9oosiceHsdiavDZGUyHzcvsEExFGxwP4mDg/132","nickname":"Geek_828b39","note":"","ucode":"DE2A5F215A3C1E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537177,"discussion_content":"同学能说一下你怎么解决的吗？我也是都输出1，win64环境下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638977555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":537074,"ip_address":""},"score":537177,"extra":""},{"author":{"id":2729802,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/D62JX0VEX0yhnWxgbiaXMUnEqdsVxc8JMxUBibVicbLSZ6zia606EG0zI9oosiceHsdiavDZGUyHzcvsEExFGxwP4mDg/132","nickname":"Geek_828b39","note":"","ucode":"DE2A5F215A3C1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1644337,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLTJvY7yqHNtMZnOPEHLYlMLt8oF1G3StHRXhONLy9lxbKicSFUuLianbVpU6KP7ybHvwehDM7Zf4tw/132","nickname":"InfoQ_cd8b36336f8a","note":"","ucode":"EBDDDE2E869D97","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537461,"discussion_content":"我是加了打印信息。把那刚代码去掉就好了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639062624,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":537177,"ip_address":""},"score":537461,"extra":""}]},{"author":{"id":1644337,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLTJvY7yqHNtMZnOPEHLYlMLt8oF1G3StHRXhONLy9lxbKicSFUuLianbVpU6KP7ybHvwehDM7Zf4tw/132","nickname":"InfoQ_cd8b36336f8a","note":"","ucode":"EBDDDE2E869D97","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537624,"discussion_content":"发现问题了，windows下long是32位的，用__int64声明即可","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639123532,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325125,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1638838498,"is_pvip":true,"replies":[{"id":"118017","content":"每一类体系架构的 CPU 都有自己独立的 ISA，其中便描述了机器指令可以使用哪些寄存器。关于 M1 Max，你可以参考这里哈：https:&#47;&#47;developer.arm.com&#47;documentation&#47;ddi0487&#47;ga","user_name":"作者回复","user_name_real":"编辑","uid":"1005890","ctime":1638867270,"ip_address":"","comment_id":325125,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1638838498","product_id":100100701,"comment_content":"怎么知道不同 型号 CPU 寄存器的名称的？ 比如我是 M1 Max 芯片的 CPU 使用 rax 报错提示  unknown register name &#39;rax&#39; in asm","like_count":0,"discussions":[{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536784,"discussion_content":"每一类体系架构的 CPU 都有自己独立的 ISA，其中便描述了机器指令可以使用哪些寄存器。关于 M1 Max，你可以参考这里哈：https://developer.arm.com/documentation/ddi0487/ga","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638867270,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1667175,"avatar":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","nickname":"qinsi","note":"","ucode":"090D9C4068FF12","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536904,"discussion_content":"https://developer.arm.com/documentation/102374/0101/Registers-in-AArch64---general-purpose-registers","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638890524,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1218726,"avatar":"https://static001.geekbang.org/account/avatar/00/12/98/a6/e0e6c23d.jpg","nickname":"ChanShaw","note":"","ucode":"2DD2ED013E35D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536692,"discussion_content":"M1 是arm 架构 文中是Intel架构 汇编寄存器 指令还有调用约定都有区别","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638846680,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"一步","note":"","ucode":"73CEA468CE70C3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1218726,"avatar":"https://static001.geekbang.org/account/avatar/00/12/98/a6/e0e6c23d.jpg","nickname":"ChanShaw","note":"","ucode":"2DD2ED013E35D5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536722,"discussion_content":"这就是前面一段话需要问的问题，怎么去知道呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638856223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":536692,"ip_address":""},"score":536722,"extra":""}]}]},{"had_liked":false,"id":325111,"user_name":"jack123","can_delete":false,"product_type":"c1","uid":2718510,"ip_address":"","ucode":"873D0046EF39D6","user_header":"","comment_is_top":false,"comment_ctime":1638832679,"is_pvip":false,"replies":[{"id":"118003","content":"看了一下，应该没错的，是 1 后面 8 个 0 哈。","user_name":"作者回复","user_name_real":"编辑","uid":"1005890","ctime":1638853476,"ip_address":"","comment_id":325111,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1638832679","product_id":100100701,"comment_content":"第一个例子rax寄存器那里的置位0x100000000 是不是多了一个0 置到36位了","like_count":0,"discussions":[{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536716,"discussion_content":"看了一下，应该没错的，是 1 后面 8 个 0 哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638853476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1021147,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/94/db/4e658ce8.jpg","nickname":"继业(Adrian)","note":"","ucode":"D9BAF5F939A2B6","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537215,"discussion_content":"寄存器bit的下标从0开始的哦，所以1后面8个0，就是第32位置1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638984551,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325108,"user_name":"ROCKS","can_delete":false,"product_type":"c1","uid":1801213,"ip_address":"","ucode":"53174DFE85902C","user_header":"https://static001.geekbang.org/account/avatar/00/1b/7b/fd/94bcd8ea.jpg","comment_is_top":false,"comment_ctime":1638830716,"is_pvip":false,"replies":[{"id":"118001","content":"这个是由于第二行 printf 函数的调用导致的，更多内容我们会在第 12 讲中详细介绍。概括下来是由于 x86-64 ABI 中对可变长参数调用时的规定。在这里，寄存器 rax 会用于保存使用到的向量寄存器的个数。","user_name":"作者回复","user_name_real":"编辑","uid":"1005890","ctime":1638853191,"ip_address":"","comment_id":325108,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1638830716","product_id":100100701,"comment_content":"在给定的示例中我多加了一步，我在给rax寄存器赋值后将值打印出来，想要与mov后的结果做比较。得到的结果与给定的示例不一样, mov后打印出来的结果都是1。是因为print函数执行的过程会清空寄存器吗？<br>#include &lt;stdio.h&gt;<br>int main()<br>{<br>    register long num asm(&quot;rax&quot;) = 0x100000000;<br>    printf(&quot;%ld\\n&quot;, num);<br>    &#47;&#47;asm(&quot;movl $0x1, %eax&quot;);<br>    asm(&quot;movw $0x1, %ax&quot;);<br>    printf(&quot;%ld\\n&quot;, num);<br>    printf(&quot;has tested\\n&quot;);<br>    return 0;<br>}","like_count":0,"discussions":[{"author":{"id":1619597,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er6OV33jHia3U9LYlZEx2HrpsELeh3KMlqFiaKpSAaaZeBttXRAVvDXUgcufpqJ60bJWGYGNpT7752w/132","nickname":"dog_brother","note":"","ucode":"9F64D3C6D815FB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536702,"discussion_content":"看了下printf的汇编，解惑了\n```\n        mov     rsi, rax\n        mov     edi, OFFSET FLAT:.LC0\n        mov     eax, 0\n        call    printf\n```","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1638849777,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005890,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/42/e1757583.jpg","nickname":"Jason Yu 于航","note":"","ucode":"0731492F4BC77D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536713,"discussion_content":"这个是由于第二行 printf 函数的调用导致的，更多内容我们会在第 12 讲中详细介绍。概括下来是由于 x86-64 ABI 中对可变长参数调用时的规定。在这里，寄存器 rax 会用于保存使用到的向量寄存器的个数。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1638853191,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1619597,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er6OV33jHia3U9LYlZEx2HrpsELeh3KMlqFiaKpSAaaZeBttXRAVvDXUgcufpqJ60bJWGYGNpT7752w/132","nickname":"dog_brother","note":"","ucode":"9F64D3C6D815FB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536673,"discussion_content":"我也有同样的疑惑","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1638844004,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}