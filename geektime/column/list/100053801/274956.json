{"id":274956,"title":"25 | 如何用法线贴图模拟真实物体表面","content":"<p>你好，我是月影。</p><p>上节课，我们讲了光照的Phong反射模型，并使用它给几何体添加了光照效果。不过，我们使用的几何体表面都是平整的，没有凹凸感。而真实世界中，大部分物体的表面都是凹凸不平的，这肯定会影响光照的反射效果。</p><p>因此，只有处理好物体凹凸表面的光照效果，我们才能更加真实地模拟物体表面。在图形学中就有一种对应的技术，叫做<strong>法线贴图</strong>。今天，我们就一起来学习一下。</p><h2>如何使用法线贴图给几何体表面增加凹凸效果？</h2><p>那什么是法线贴图？我们直接通过一个例子来理解。</p><p>首先，我们用Phong反射模型绘制一个灰色的立方体，并给它添加两道平行光。具体的代码和效果如下：</p><pre><code>import {Phong, Material, vertex as v, fragment as f} from '../common/lib/phong.js';\n\nconst scene = new Transform();\n\nconst phong = new Phong();\nphong.addLight({\n  direction: [0, -3, -3],\n});\nphong.addLight({\n  direction: [0, 3, 3],\n});\nconst matrial = new Material(new Color('#808080'));\n\nconst program = new Program(gl, {\n  vertex: v,\n  fragment: f,\n  uniforms: {\n    ...phong.uniforms,\n    ...matrial.uniforms,\n  },\n});\n\nconst geometry = new Box(gl);\nconst cube = new Mesh(gl, {geometry, program});\ncube.setParent(scene);\ncube.rotation.x = -Math.PI / 2;\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/c0/1f/c0241f80436bd66bb9b2ee37912e6a1f.jpeg?wh=1920*1080\" alt=\"\"></p><p>现在这个立方体的表面是光滑的，如果我们想在立方体的表面贴上凹凸的花纹。我们可以加载一张<strong>法线纹理</strong>，这是一张偏蓝色调的纹理图片。</p><p><img src=\"https://static001.geekbang.org/resource/image/8c/f7/8c13477872b6bc541ab1f9ec8017bbf7.jpeg?wh=1920*1080\" alt=\"\"></p><pre><code>const normalMap = await loadTexture('../assets/normal_map.png');\n</code></pre><p>为什么这张纹理图片是偏蓝色调的呢？实际上，这张纹理图片保存的是几何体表面的每个像素的法向量数据。我们知道，正常情况下，光滑立方体每个面的法向量是固定的，如下图所示：</p><p><a href=\"http://www.mbsoftworks.sk/tutorials/opengl4/014-normals-diffuse-lighting/\"><img src=\"https://static001.geekbang.org/resource/image/13/e4/13f742cafbf21d5afe6bef06a65ae3e4.jpeg?wh=1920*782\" alt=\"\"></a></p><p>但如果表面有凹凸的花纹，那不同位置的法向量就会发生变化。在<strong>切线空间</strong>中，因为法线都偏向于z轴，也就是法向量偏向于(0,0,1)，所以转换成的法线纹理就偏向于蓝色。如果我们根据花纹将每个点的法向量都保存下来，就会得到上面那张法线纹理的图片。</p><!-- [[[read_end]]] --><h3>如何理解切线空间？</h3><p>我刚才提到了一个词，切线空间，那什么是切线空间呢？切线空间（Tangent Space）是一个特殊的坐标系，它是由几何体顶点所在平面的uv坐标和法线构成的。</p><p><a href=\"https://math.stackexchange.com/questions/342211/difference-between-tangent-space-and-tangent-plane\"><img src=\"https://static001.geekbang.org/resource/image/eb/91/ebaaafe6749e1ea9d47712d259f2c291.jpeg?wh=1920*884\" alt=\"\" title=\"切线空间\"></a></p><p>切线空间的三个轴，一般用 T (Tangent)、B (Bitangent)、N (Normal) 三个字母表示，所以切线空间也被称为TBN空间。其中T表示切线、B表示副切线、N表示法线。</p><p>对于大部分三维几何体来说，因为每个点的法线不同，所以它们各自的切线空间也不同。</p><p>接下来，我们来具体说说，切线空间中的TBN是怎么计算的。</p><p>首先，我们来回忆一下，怎么计算几何体三角形网格的法向量。假设一个三角形网格有三个点v1、v2、v3，我们把边v1v2记为e1，边v1v3记为e2，那三角形的法向量就是e1和e2的叉积表示的归一化向量。用JavaScript代码实现就是下面这样：</p><pre><code>function getNormal(v1, v2, v3) {\n  const e1 = Vec3.sub(v2, v1);\n  const e2 = Vec3.sub(v3, v1);\n  const normal = Vec3.cross(e1, e1).normalize();\n  return normal;\n}\n</code></pre><p>而计算切线和副切线，要比计算法线复杂得多，不过，因为<a href=\"https://learnopengl.com/Advanced-Lighting/Normal-Mapping\">数学推导过程</a>比较复杂，我们只要记住结论就可以了。</p><p><img src=\"https://static001.geekbang.org/resource/image/33/6b/336454df02a6f150eff17a0760c2616b.jpeg?wh=1920*1080\" alt=\"\"></p><p>如上图和公式，我们就可以通过UV坐标和点P1、P2、P3的坐标求出对应的T和B坐标了，对应的JavaScript函数如下：</p><pre><code>function createTB(geometry) {\n  const {position, index, uv} = geometry.attributes;\n  if(!uv) throw new Error('NO uv.');\n  function getTBNTriangle(p1, p2, p3, uv1, uv2, uv3) {\n    const edge1 = new Vec3().sub(p2, p1);\n    const edge2 = new Vec3().sub(p3, p1);\n    const deltaUV1 = new Vec2().sub(uv2, uv1);\n    const deltaUV2 = new Vec2().sub(uv3, uv1);\n\n    const tang = new Vec3();\n    const bitang = new Vec3();\n\n    const f = 1.0 / (deltaUV1.x * deltaUV2.y - deltaUV2.x * deltaUV1.y);\n\n    tang.x = f * (deltaUV2.y * edge1.x - deltaUV1.y * edge2.x);\n    tang.y = f * (deltaUV2.y * edge1.y - deltaUV1.y * edge2.y);\n    tang.z = f * (deltaUV2.y * edge1.z - deltaUV1.y * edge2.z);\n\n    tang.normalize();\n\n    bitang.x = f * (-deltaUV2.x * edge1.x + deltaUV1.x * edge2.x);\n    bitang.y = f * (-deltaUV2.x * edge1.y + deltaUV1.x * edge2.y);\n    bitang.z = f * (-deltaUV2.x * edge1.z + deltaUV1.x * edge2.z);\n\n    bitang.normalize();\n\n    return {tang, bitang};\n  }\n\n  const size = position.size;\n  if(size &lt; 3) throw new Error('Error dimension.');\n\n  const len = position.data.length / size;\n  const tang = new Float32Array(len * 3);\n  const bitang = new Float32Array(len * 3);\n\n  for(let i = 0; i &lt; index.data.length; i += 3) {\n    const i1 = index.data[i];\n    const i2 = index.data[i + 1];\n    const i3 = index.data[i + 2];\n\n    const p1 = [position.data[i1 * size], position.data[i1 * size + 1], position.data[i1 * size + 2]];\n    const p2 = [position.data[i2 * size], position.data[i2 * size + 1], position.data[i2 * size + 2]];\n    const p3 = [position.data[i3 * size], position.data[i3 * size + 1], position.data[i3 * size + 2]];\n\n    const u1 = [uv.data[i1 * 2], uv.data[i1 * 2 + 1]];\n    const u2 = [uv.data[i2 * 2], uv.data[i2 * 2 + 1]];\n    const u3 = [uv.data[i3 * 2], uv.data[i3 * 2 + 1]];\n\n    const {tang: t, bitang: b} = getTBNTriangle(p1, p2, p3, u1, u2, u3);\n    tang.set(t, i1 * 3);\n    tang.set(t, i2 * 3);\n    tang.set(t, i3 * 3);\n    bitang.set(b, i1 * 3);\n    bitang.set(b, i2 * 3);\n    bitang.set(b, i3 * 3);\n  }\n  geometry.addAttribute('tang', {data: tang, size: 3});\n  geometry.addAttribute('bitang', {data: bitang, size: 3});\n  return geometry;\n}\n\n</code></pre><p>虽然上面这段代码比较长，但并不复杂。具体的思路就是按照我给出的公式，先进行向量计算，然后将tang和bitang的值添加到geometry对象中去。</p><h3>构建TBN矩阵来计算法向量</h3><p>有了tang和bitang之后，我们就可以构建TBN矩阵来计算法线了。这里的TBN矩阵的作用，就是将法线贴图里面读取的法向量数据，转换为对应的切线空间中实际的法向量。这里的切线空间，实际上对应着我们观察者（相机）位置的坐标系。</p><p>接下来，我们对应顶点着色器和片元着色器来说说，怎么构建TBN矩阵得出法线方向。</p><p>先看顶点着色器，我们增加了tang和bitang这两个属性。注意，这里我们用了webgl2.0的写法，因为WebGL2.0对应OpenGL ES3.0，所以这段代码和我们之前看到的着色器代码略有不同。</p><p>首先它的第一行声明 #version 300 es 表示这段代码是OpenGL ES3.0的，然后我们用in和out对应变量的输入和输出，来取代WebGL2.0的attribute和varying，其他的地方基本和WebGL1.0一样。因为OGL默认支持WebGL2.0，所以在后续例子中你还会看到更多OpenGL ES3.0的着色器写法，不过因为两个版本差别不大，也不会妨碍我们理解代码。</p><pre><code>#version 300 es\nprecision highp float;\n\nin vec3 position;\nin vec3 normal;\nin vec2 uv;\nin vec3 tang;\nin vec3 bitang;\n\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\n\nout vec3 vNormal;\nout vec3 vPos;\nout vec2 vUv;\nout vec3 vCameraPos;\nout mat3 vTBN;\n\nvoid main() {\n  vec4 pos = modelViewMatrix * vec4(position, 1.0);\n  vPos = pos.xyz;\n  vUv = uv;\n  vCameraPos = (viewMatrix * vec4(cameraPosition, 1.0)).xyz;\n  vNormal = normalize(normalMatrix * normal);\n\n  vec3 N = vNormal;\n  vec3 T = normalize(normalMatrix * tang);\n  vec3 B = normalize(normalMatrix * bitang);\n\n  vTBN = mat3(T, B, N);\n  \n  gl_Position = projectionMatrix * pos;\n}\n\n</code></pre><p>接着来看代码，我们通过normal、tang和bitang建立TBN矩阵。注意，因为normal、tang和bitang都需要换到世界坐标中，所以我们要记得将它们左乘法向量矩阵normalMatrix，然后我们构建TBN矩阵(vTBN=mat(T,B,N))，将它传给片元着色器。</p><p>下面，我们接着来看片元着色器。</p><pre><code>#version 300 es\nprecision highp float;\n\n#define MAX_LIGHT_COUNT 16\nuniform mat4 viewMatrix;\n\nuniform vec3 ambientLight;\nuniform vec3 directionalLightDirection[MAX_LIGHT_COUNT];\nuniform vec3 directionalLightColor[MAX_LIGHT_COUNT];\nuniform vec3 pointLightColor[MAX_LIGHT_COUNT];\nuniform vec3 pointLightPosition[MAX_LIGHT_COUNT];\nuniform vec3 pointLightDecay[MAX_LIGHT_COUNT];\nuniform vec3 spotLightColor[MAX_LIGHT_COUNT];\nuniform vec3 spotLightDirection[MAX_LIGHT_COUNT];\nuniform vec3 spotLightPosition[MAX_LIGHT_COUNT];\nuniform vec3 spotLightDecay[MAX_LIGHT_COUNT];\nuniform float spotLightAngle[MAX_LIGHT_COUNT];\n\nuniform vec3 materialReflection;\nuniform float shininess;\nuniform float specularFactor;\n\nuniform sampler2D tNormal;\n\nin vec3 vNormal;\nin vec3 vPos;\nin vec2 vUv;\nin vec3 vCameraPos;\nin mat3 vTBN;\n\nout vec4 FragColor;\n\nfloat getSpecular(vec3 dir, vec3 normal, vec3 eye) {\n  vec3 reflectionLight = reflect(-dir, normal);\n  float eyeCos = max(dot(eye, reflectionLight), 0.0);\n  return specularFactor *  pow(eyeCos, shininess);\n}\n\nvec4 phongReflection(vec3 pos, vec3 normal, vec3 eye) {\n  float specular = 0.0;\n  vec3 diffuse = vec3(0);\n  \n  // 处理平行光\n  for(int i = 0; i &lt; MAX_LIGHT_COUNT; i++) {\n    vec3 dir = directionalLightDirection[i];\n    if(dir.x == 0.0 &amp;&amp; dir.y == 0.0 &amp;&amp; dir.z == 0.0) continue;\n    vec4 d = viewMatrix * vec4(dir, 0.0);\n    dir = normalize(-d.xyz);\n    float cos = max(dot(dir, normal), 0.0);\n    diffuse += cos * directionalLightColor[i];\n    specular += getSpecular(dir, normal, eye);\n  }\n\n  // 处理点光源\n  for(int i = 0; i &lt; MAX_LIGHT_COUNT; i++) {\n    vec3 decay = pointLightDecay[i];\n    if(decay.x == 0.0 &amp;&amp; decay.y == 0.0 &amp;&amp; decay.z == 0.0) continue;\n    vec3 dir = (viewMatrix * vec4(pointLightPosition[i], 1.0)).xyz - pos;\n    float dis = length(dir);\n    dir = normalize(dir);\n    float cos = max(dot(dir, normal), 0.0);\n    float d = min(1.0, 1.0 / (decay.x * pow(dis, 2.0) + decay.y * dis + decay.z));\n    diffuse += d * cos * pointLightColor[i];\n    specular += getSpecular(dir, normal, eye);\n  }\n\n  // 处理聚光灯\n  for(int i = 0; i &lt; MAX_LIGHT_COUNT; i++) {\n    vec3 decay = spotLightDecay[i];\n    if(decay.x == 0.0 &amp;&amp; decay.y == 0.0 &amp;&amp; decay.z == 0.0) continue;\n\n    vec3 dir = (viewMatrix * vec4(spotLightPosition[i], 1.0)).xyz - pos;\n    float dis = length(dir);\n    dir = normalize(dir);\n\n    // 聚光灯的朝向\n    vec3 spotDir = (viewMatrix * vec4(spotLightDirection[i], 0.0)).xyz;\n    // 通过余弦值判断夹角范围\n    float ang = cos(spotLightAngle[i]);\n    float r = step(ang, dot(dir, normalize(-spotDir)));\n\n    float cos = max(dot(dir, normal), 0.0);\n    float d = min(1.0, 1.0 / (decay.x * pow(dis, 2.0) + decay.y * dis + decay.z));\n    diffuse += r * d * cos * spotLightColor[i];\n    specular += r * getSpecular(dir, normal, eye);\n  }\n\n  return vec4(diffuse, specular);\n}\n\nvec3 getNormal() {\n  vec3 n = texture(tNormal, vUv).rgb * 2.0 - 1.0;\n  return normalize(vTBN * n);\n}\n\nvoid main() {\n  vec3 eyeDirection = normalize(vCameraPos - vPos);\n  vec3 normal = getNormal();\n  vec4 phong = phongReflection(vPos, normal, eyeDirection);\n\n  // 合成颜色\n  FragColor.rgb = phong.w + (phong.xyz + ambientLight) * materialReflection;\n  FragColor.a = 1.0;\n}\n\n</code></pre><p>片元着色器代码虽然也很长，但也并不复杂。因为其中的Phong反射模型，我们已经比较熟悉了。剩下的部分，我们重点理解，怎么从法线纹理中提取数据和TBN矩阵，来计算对应的法线就行了。具体的计算方法就是把法线纹理贴图中提取的数据转换到[-1，1]区间，然后左乘TBN矩阵并归一化。</p><p>然后，我们将经过处理之后的法向量传给phongReflection计算光照，就得到了法线贴图后的结果，效果如下图：</p><p><img src=\"https://static001.geekbang.org/resource/image/f6/b7/f669899196e94d06b101bb5eeea69db7.gif?wh=492*440\" alt=\"\"></p><p>到这里我们就实现了完整的法线贴图。法线贴图就是根据法线纹理中保存的法向量数据以及TBN矩阵，将实际的法线计算出来，然后用实际的法线来计算光照的反射。具体点来说，要实现法线贴图，我们需要通过顶点数据计算几何体的切线和副切线，然后得到TBN矩阵，用TBN矩阵和法线纹理数据来计算法向量，从而完成法线贴图。</p><h3>使用偏导数来实现法线贴图</h3><p>但是，构建TBN矩阵求法向量的方法还是有点麻烦。事实上，还有一种更巧妙的方法，不需要用顶点数据计算几何体的切线和副切线，而是直接用坐标插值和法线纹理来计算。</p><pre><code>vec3 getNormal() {\n  vec3 pos_dx = dFdx(vPos.xyz);\n  vec3 pos_dy = dFdy(vPos.xyz);\n  vec2 tex_dx = dFdx(vUv);\n  vec2 tex_dy = dFdy(vUv);\n\n  vec3 t = normalize(pos_dx * tex_dy.t - pos_dy * tex_dx.t);\n  vec3 b = normalize(-pos_dx * tex_dy.s + pos_dy * tex_dx.s);\n  mat3 tbn = mat3(t, b, normalize(vNormal));\n\n  vec3 n = texture(tNormal, vUv).rgb * 2.0 - 1.0;\n  return normalize(tbn * n);\n}\n</code></pre><p>如上面代码所示，dFdx、dFdy是GLSL内置函数，可以求插值的属性在x、y轴上的偏导数。那我们为什么要求偏导数呢？<strong>偏导数</strong>其实就代表插值的属性向量在x、y轴上的变化率，或者说曲面的切线。然后，我们再将顶点坐标曲面切线与uv坐标的切线求叉积，就能得到垂直于两条切线的法线。</p><p>那我们在x、y两个方向上求出的两条法线，就对应TBN空间的切线tang和副切线bitang。然后，我们使用偏导数构建TBN矩阵，同样也是把TBN矩阵左乘从法线纹理中提取出的值，就可以计算出对应的法向量了。</p><p>这样做的好处是，我们不需要预先计算几何体的tang和bitang了。不过在片元着色器中计算偏导数也有一定的性能开销，所以各有利弊，我们可以根据不同情况选择不同的方案。</p><h2>法线贴图的应用</h2><p>法线贴图的两种实现方式，我们都学会了。那法线贴图除了给几何体表面增加花纹以外，还可以用来增强物体细节，让物体看起来更加真实。比如说，在实现一个石块被变化的光源照亮效果的时候，我们就可以运用法线贴图技术，让石块的表面纹路细节显得非常的逼真。我把对应的片元着色器核心代码放在了下面，你可以利用今天学到的知识自己来实现一下。</p><p><img src=\"https://static001.geekbang.org/resource/image/b2/5b/b28f5b31af8af0708e77e47e584a845b.gif?wh=454*394\" alt=\"\"></p><pre><code>uniform float uTime;\n\nvoid main() {\n  vec3 eyeDirection = normalize(vCameraPos - vPos);\n  vec3 normal = getNormal();\n  vec4 phong = phongReflection(vPos, normal, eyeDirection);\n  // vec4 phong = phongReflection(vPos, vNormal, eyeDirection);\n\n  vec3 tex = texture(tMap, vUv).rgb;\n  vec3 light = normalize(vec3(sin(uTime), 1.0, cos(uTime)));\n  float shading = dot(normal, light) * 0.5;\n  \n  FragColor.rgb = tex + shading;\n  FragColor.a = 1.0;\n}\n</code></pre><h2>要点总结</h2><p>这节课，我们详细说了法线贴图这个技术。法线贴图是一种经典的图形学技术，可以用来给物体表面增加细节，让我们实现的效果更逼真。</p><p>具体来说，法线贴图是用一张图片来存储表面的法线数据。这张图片叫做法线纹理，它上面的每个像素对应一个坐标点的法线数据。</p><p>要想使用法线纹理的数据，我们还需要构建TBN矩阵。这个矩阵通过向量、矩阵乘法将法线数据转换到世界坐标中。</p><p>构建TBN矩阵我们有两个方法，一个是根据几何体顶点数据来计算切线（Tangent）、副切线（Bitangent），然后结合法向量一起构建TBN矩阵。另一个方法是使用偏导数来计算，这样我们就不用预先在顶点中计算Tangent和Bitangent了。两种方法各有利弊，我们可以根据实际情况来合理选择。</p><h2>小试牛刀</h2><p>这里，我给出了两张图片，一张是纹理图片，一张是法线纹理，你能用它们分别来绘制一面墙，并且引入Phong反射模型，来实现光照效果吗？你还可以思考一下，应用法线贴图和不应用法线贴图绘制出来的墙，有什么差别？</p><p><img src=\"https://static001.geekbang.org/resource/image/d1/3b/d107b4eeb30d46a37fa9ca85fa9b223b.jpeg?wh=1920*802\" alt=\"\"></p><p>欢迎在留言区和我讨论，分享你的答案和思考，也欢迎你把这节课分享给你的朋友，我们下节课再见！</p><hr><h2><span class=\"reference\">源码</span></h2><p><span class=\"reference\">课程中完整示例代码见<a href=\"https://github.com/akira-cn/graphics/tree/master/normal-maps\">GitHub仓库</a></span></p><h2><span class=\"reference\">推荐阅读</span></h2><p><span class=\"reference\"> <a href=\"https://learnopengl.com/Advanced-Lighting/Normal-Mapping\">Normal mapping</a></span></p>","comments":[{"had_liked":false,"id":269500,"user_name":"sh","can_delete":false,"product_type":"c1","uid":1428920,"ip_address":"","ucode":"720991D01D50D9","user_header":"https://static001.geekbang.org/account/avatar/00/15/cd/b8/14597b01.jpg","comment_is_top":false,"comment_ctime":1608687378,"is_pvip":false,"replies":[{"id":"101091","content":"不要急，循序渐进","user_name":"作者回复","user_name_real":"月影","uid":"1159792","ctime":1612875769,"ip_address":"","comment_id":269500,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5903654674","product_id":100053801,"comment_content":"感觉越看越难 是数学不好吗","like_count":1,"discussions":[{"author":{"id":1159792,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b2/70/ba9cecc6.jpg","nickname":"月影","note":"","ucode":"298582FA7DBF27","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512298,"discussion_content":"不要急，循序渐进","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612875769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":355390,"user_name":"阿不晕","can_delete":false,"product_type":"c1","uid":1285787,"ip_address":"浙江","ucode":"3C6EB050E82694","user_header":"https://static001.geekbang.org/account/avatar/00/13/9e/9b/a2fcb669.jpg","comment_is_top":false,"comment_ctime":1661331170,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661331170","product_id":100053801,"comment_content":"法线贴图包含颜色信息么。","like_count":0},{"had_liked":false,"id":289146,"user_name":"Geek_29c515","can_delete":false,"product_type":"c1","uid":2305238,"ip_address":"","ucode":"7CC5B39721A6E4","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/4vNosr1iajSiaw6M88QL8nGP7sUtDvSGz18zsKiaLA04ia3DojibC5KTic5tE66l7OSHDZjRx0caFJPdwiacQFic5tyhIg/132","comment_is_top":false,"comment_ctime":1618889368,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618889368","product_id":100053801,"comment_content":"老师，您好，看了这么案例特效都是基于图形或图片的，我想掌握glsl动态文字或艺术字相关的，有什么思路或建议吗？","like_count":0}]}