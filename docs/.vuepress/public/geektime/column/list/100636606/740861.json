{"id":740861,"title":"第 2 章 Spring Framework 中的 IoC 容器(1)","content":"<blockquote>\n<p><strong>本章内容</strong></p>\n<ul>\n<li>IoC 容器的基础知识</li>\n<li>Spring Bean 的基础知识</li>\n<li>如何感知并自定义一些行为</li>\n<li>环境与任务的抽象</li>\n</ul>\n</blockquote>\n<p><strong>控制反转</strong>（Inversion of Control，IoC）与<strong>面向切面编程</strong>（Aspect Oriented Programming，AOP）是 Spring Framework 中最重要的两个概念，本章会着重介绍前者，内容包括 IoC 容器以及容器中 Bean 的基础知识。容器为我们预留了不少扩展点，让我们能定制各种行为，本章的最后我会和大家一起了解一些容器提供的抽象机制。通过这些介绍，希望大家可以对 IoC 容器有个大概的认识。</p>\n<h2 id=\"nav_point_24\">2.1　IoC 容器基础知识</h2>\n<p>Spring Framework 为 Java 开发者提供了强大的支持，开发者可以把底层基础的杂事抛给 Spring Framework，自己则专心于业务逻辑。本节我们会聚焦在 Spring Framework 的核心能力上，着重了解 IoC 容器的基础知识。</p>\n<h3 id=\"nav_point_25\">2.1.1　什么是 IoC 容器</h3>\n<p>在介绍 Spring Framework 的 IoC 容器前，我们有必要先理解什么是“控制反转”。<strong>控制反转</strong>是一种决定容器如何装配组件的<strong>模式</strong>。只要遵循这种模式，按照一定的规则，容器就能将组件组装起来。这里所谓的<strong>容器</strong>，就是用来创建组件并对它们进行管理的地方。它牵扯到组件该如何定义、组件该何时创建、又该何时销毁、它们互相之间是什么关系等——这些本该在组件内部管理的东西，被从组件中剥离了出来。</p><!-- [[[read_end]]] -->\n<p>需要着重指出一点，组件之间的依赖关系原先是由组件自己定义的，并在其内部维护，而现在这些依赖被定义在容器中，由容器来统一管理，并据此将其依赖的内容注入组件中。在好莱坞，演艺公司具有极大的控制权，艺人将简历投递给演艺公司后就只能等待，被动接受演艺公司的安排。这就是知名的好莱坞原则，它可以总结为这样的一句话“不要给我们打电话，我们会打给你的”（Don't call us, we'll call you）。IoC 容器背后的思想正是好莱坞原则，即所有的组件都要被动接受容器的控制。</p>\n<p>Martin Fowler<span class=\"comment-number\">1</span> 那篇著名的“Inversion of Control Containers and the Dependency Injection pattern”<span class=\"comment-number\">2</span> 中提到“控制反转”不能很好地描述这个模式，“依赖注入”（Dependency Injection）能更好地描述它的特点。正因如此，我们经常会看到这两个词一同出现。</p>\n\n\n<p>Spring Framework、Google Guice、PicoContainer 都提供了这样的容器 <span class=\"comment-number\">3</span>，后文中我们也会把 Spring Framework 的 IoC 容器称为 <strong>Spring 容器</strong>。</p>\n\n<p>图 2-1 是 Spring Framework 的官方文档中的一幅图，它非常直观地表达了 Spring IoC 容器的作用，即将业务对象（也就是组件，在 Spring 中这些组件被称为 Bean，2.2 节会详细介绍 Bean 的内容）和关于组件的配置元数据（比如依赖关系）输入 Spring 容器中，容器就能为我们组装出一个可用的系统。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00756.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 2-1　Spring IoC 容器</strong></p>\n<p>Spring Framework 的模块按功能进行了拆分，spring-core 和 spring-beans 模块提供了最基础的功能，其中就包含了 IoC 容器。<code>BeanFactory</code> 是容器的基础接口，我们平时使用的各种容器都是它的实现，后文中会看到这些实现的具体用法与区别。</p>\n<h3 id=\"nav_point_26\">2.1.2　容器的初始化</h3>\n<p>从图 2-1 中可以看到，Spring 容器需要配置元数据和业务对象，因此在初始化容器时，我们需要提供这些信息。早期的配置元数据只能以 XML 配置文件的形式提供，从 2.5 版本开始，官方逐步提供了 XML 文件以外的配置方式，比如基于注解的配置和基于 Java 类的配置，本书中的大部分示例将采用后两种方式进行配置。</p>\n<p>容器初始化的大致步骤如下（在本章后续的几节中，我们会分别介绍其中涉及的内容）。</p>\n<p>(1) 从 XML 文件、Java 类或其他地方加载配置元数据。</p>\n<p>(2) 通过 <code>BeanFactoryPostProcessor</code> 对配置元数据进行一轮处理。</p>\n<p>(3) 初始化 Bean 实例，并根据给定的依赖关系组装对象。</p>\n<p>(4) 通过 <code>BeanPostProcessor</code> 对 Bean 进行处理，期间还会触发 Bean 被构造后的回调方法。</p>\n<p>比如，我们有一个如代码示例 2-1<span class=\"comment-number\">4</span> 所示的业务对象，它会返回一个字符串，可以看到它就是一个最普通的 Java 类。</p>\n\n<blockquote>\n<p><strong>代码示例 2-1</strong>　最基本的 <code>Hello</code> 类</p>\n</blockquote>\n<pre class=\"code-rows\"><code>package learning.spring.helloworld;\n\npublic class Hello {\n    public String hello() {\n        return \"Hello World!\";\n    }\n}</code></pre>\n<p>在没有 IoC 容器时，我们需要像代码示例 2-2 那样自己管理 <code>Hello</code> 实例的生命周期，通常是在代码中用 <code>new</code> 关键字新建一个实例，然后把它传给具体要调用它的对象，下面的代码只是个示意，所以就使用 <code>new</code> 关键字创建实例后直接调用方法了。</p>\n<blockquote>\n<p><strong>代码示例 2-2</strong>　手动创建并调用 <code>Hello.hello()</code> 方法</p>\n</blockquote>\n<pre class=\"code-rows\"><code>public class Application {\n    public static void main(String[] args) {\n        Hello hello = new Hello();\n        System.out.println(hello.hello());\n    }\n}</code></pre>\n<p>如果是把实例交给 Spring 容器托管，则可以将它配置到一个 XML 文件中，让容器来管理它的相关生命周期。可以看到代码示例 2-3 只是一个普通的 XML 文件，通过 <code>&lt;beans/&gt;</code> 这个 Schema 来配置 Spring 的 Bean（Bean 的配置会在 2.2.2 节详细展开）。为了使用 Spring 的容器，需要在 pom.xml 文件中引入 <code>org.springframework:spring-beans</code> 依赖。</p>\n<blockquote>\n<p><strong>代码示例 2-3</strong>　配置 hello Bean 的 beans.xml 文件</p>\n</blockquote>\n<pre class=\"code-rows\"><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;\n\n    &lt;bean id=\"hello\" class=\"learning.spring.helloworld.Hello\" /&gt;\n\n&lt;/beans&gt;</code></pre>\n<p>最后像代码示例 2-4 那样，将配置文件载入容器。<code>BeanFactory</code> 只是一个最基础的接口，我们需要选择一个合适的实现类——在实际工作中，更多情况下会用到 <code>ApplicationContext</code> 的各种实现。此处，我们使用 <code>DefaultListableBeanFactory</code> 这个实现类，它并不关心配置的方式，<code>XmlBeanDefinitionReader</code> 能读取 XML 文件中的元数据，我们通过它加载 CLASSPATH 中的 beans.xml 文件，将其保存到 <code>DefaultListableBeanFactory</code> 中，随后就可以通过 <code>BeanFactory</code> 的 <code>getBean()</code> 方法取得对应的 Bean 了。</p>\n<p><code>getBean()</code> 方法有很多不同的参数列表，例子里就有两种，一种是取出 <code>Object</code> 类型的 Bean，然后自己做类型转换；另一种则是在参数里指明返回 Bean 的类型，如果实际类型不同的话则会抛出 <code>BeansException</code>。</p>\n<blockquote>\n<p><strong>代码示例 2-4</strong>　加载配置文件并执行的 <code>Application</code> 类代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>public class Application {\n    private BeanFactory beanFactory;\n\n    public static void main(String[] args) {\n        Application application = new Application();\n        application.sayHello();\n    }\n\n    public Application() {\n        beanFactory = new DefaultListableBeanFactory();\n        XmlBeanDefinitionReader reader =\n                new XmlBeanDefinitionReader((DefaultListableBeanFactory) beanFactory);\n        reader.loadBeanDefinitions(\"beans.xml\");\n    }\n\n    public void sayHello() {\n        // Hello hello = (Hello) beanFactory.getBean(\"hello\");\n        Hello hello = beanFactory.getBean(\"hello\", Hello.class);\n        System.out.println(hello.hello());\n    }\n}</code></pre>\n<p>在这个例子的 <code>sayHello()</code> 方法中，我们完全不用关心 <code>Hello</code> 这个类的实例是如何创建的，只需获取实例对象然后使用即可。虽然看起来比代码示例 2-3 的行数要多，但当工程复杂度增加之后，IoC 托管 Bean 生命周期的优势就体现出来了。</p>\n<h3 id=\"nav_point_27\">2.1.3　<code>BeanFactory</code> 与 <code>ApplicationContext</code></h3>\n<p>spring-context 模块在 spring-core 和 spring-beans 的基础上提供了更丰富的功能，例如事件传播、资源加载、国际化支持等。前面说过，<code>BeanFactory</code> 是容器的基础接口，<code>ApplicationContext</code> 接口继承了 <code>BeanFactory</code>，在它的基础上增加了更多企业级应用所需要的特性，通过这个接口，我们可以最大化地发挥 Spring 上下文的能力。表 2-1 列举了常见的一些 <code>ApplicationContext</code> 实现。</p>\n<p><strong>表 2-1　常见的 <code>ApplicationContext</code> 实现</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>类名</p></th>\n<th><p>说明</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>ClassPathXmlApplicationContext</code></p></td>\n<td><p>从 CLASSPATH 中加载 XML 文件来配置 <code>ApplicationContext</code></p></td>\n</tr>\n<tr>\n<td><p><code>FileSystemXmlApplicationContext</code></p></td>\n<td><p>从文件系统中加载 XML 文件来配置 <code>ApplicationContext</code></p></td>\n</tr>\n<tr>\n<td><p><code>AnnotationConfigApplicationContext</code></p></td>\n<td><p>根据注解和 Java 类配置 <code>ApplicationContext</code></p></td>\n</tr>\n</tbody>\n</table>\n<p>相比 <code>BeanFactory</code>，使用 <code>ApplicationContext</code> 也会更加方便一些，因为我们无须自己去注册很多内容，例如 <code>AnnotationConfigApplicationContext</code> 把常用的一些后置处理器都直接注册好了，为我们省去了不少麻烦。所以，在绝大多数情况下，建议大家使用 <code>ApplicationContext</code> 的实现类。</p>\n<p>如果要将代码示例 <code>2-4</code> 中的 Application.java 从使用 BeanFactory 修改为使用 ApplicationContext，只需做两处改动：</p>\n<p>(1) 在 pom.xml 文件中 <span class=\"comment-number\">5</span>，把引入的 <code>org.springframework:spring-beans</code> 修改为 <code>org.springframework: spring-context</code>；</p>\n\n<p>(2) 在 <code>Application.java</code> 中，使用 <code>ClassPathXmlApplicationContext</code> 代替 <code>DefaultListableBeanFactory</code> 和 <code>XmlBeanDefinitionReader</code> 的组合，具体见代码示例 2-5。</p>\n<blockquote>\n<p><strong>代码示例 2-5</strong>　调整后的 <code>Application</code> 类代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>public class Application {\n    private ApplicationContext applicationContext;\n\n    public static void main(String[] args) {\n        Application application = new Application();\n        application.sayHello();\n    }\n\n    public Application() {\n        applicationContext = new ClassPathXmlApplicationContext(\"beans.xml\");\n    }\n\n    public void sayHello() {\n        Hello hello = applicationContext.getBean(\"hello\", Hello.class);\n        System.out.println(hello.hello());\n    }\n}</code></pre>\n<h3 id=\"nav_point_28\">2.1.4　容器的继承关系</h3>\n<p>Java 类之间有继承的关系，子类能够继承父类的属性和方法。同样地，Spring 的容器之间也存在类似的继承关系，子容器可以继承父容器中配置的组件。在使用 Spring MVC 时就会涉及容器的继承。</p>\n<p>先来看一个例子，如代码示例 2-6 所示 <span class=\"comment-number\">6</span>（修改自上一节的 HelloWorld），<code>Hello</code> 类在输出的字符串中加入一段注入的信息。</p>\n\n<blockquote>\n<p><strong>代码示例 2-6</strong>　可以输出特定信息的 <code>Hello</code> 类</p>\n</blockquote>\n<pre class=\"code-rows\"><code>package learning.spring.helloworld;\n\npublic class Hello {\n    private String name;\n\n    public String hello() {\n        return \"Hello World! by \" + name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}</code></pre>\n<p>随后，我们也要调整一下 XML 配置文件，父容器与子容器分别用不同的配置，ID 既有相同的，也有不同的，具体如代码示例 2-7 与代码示例 2-8 所示。</p>\n<blockquote>\n<p><strong>代码示例 2-7</strong>　父容器配置 parent-beans.xml 文件</p>\n</blockquote>\n<pre class=\"code-rows\"><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;\n\n    &lt;bean id=\"parentHello\" class=\"learning.spring.helloworld.Hello\"&gt;\n        &lt;property name=\"name\" value=\"PARENT\" /&gt;\n    &lt;/bean&gt;\n\n    &lt;bean id=\"hello\" class=\"learning.spring.helloworld.Hello\"&gt;\n        &lt;property name=\"name\" value=\"PARENT\" /&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;</code></pre>\n<blockquote>\n<p><strong>代码示例 2-8</strong>　子容器配置 child-beans.xml 文件</p>\n</blockquote>\n<pre class=\"code-rows\"><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;\n\n    &lt;bean id=\"childHello\" class=\"learning.spring.helloworld.Hello\"&gt;\n        &lt;property name=\"name\" value=\"CHILD\" /&gt;\n    &lt;/bean&gt;\n\n    &lt;bean id=\"hello\" class=\"learning.spring.helloworld.Hello\"&gt;\n        &lt;property name=\"name\" value=\"CHILD\" /&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;</code></pre>\n<p>在 <code>Application</code> 类中，我们尝试从不同的容器中获取不同的 Bean（关于 Bean 的内容，我们会在 2.2 节展开），以测试继承容器中 Bean 的可见性和覆盖情况，具体如代码示例 2-9 所示。</p>\n<blockquote>\n<p><strong>代码示例 2-9</strong>　修改后的 <code>Application</code> 类代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>public class Application {\n    private ClassPathXmlApplicationContext parentContext;\n    private ClassPathXmlApplicationContext childContext;\n\n    public static void main(String[] args) {\n        new Application().runTests();\n    }\n\n    public Application() {\n        parentContext = new ClassPathXmlApplicationContext(\"parent-beans.xml\");\n        childContext = new ClassPathXmlApplicationContext(\n                new String[] {\"child-beans.xml\"}, true, parentContext);\n        parentContext.setId(\"ParentContext\");\n        childContext.setId(\"ChildContext\");\n    }\n\n    public void runTests() {\n        testVisibility(parentContext, \"parentHello\");\n        testVisibility(childContext, \"parentHello\");\n        testVisibility(parentContext, \"childHello\");\n        testVisibility(childContext, \"childHello\");\n        testOverridden(parentContext, \"hello\");\n        testOverridden(childContext, \"hello\");\n    }\n\n    private void testVisibility(ApplicationContext context, String beanName) {\n        System.out.println(context.getId() + \" can see \" + beanName + \": \"\n                           + context.containsBean(beanName));\n    }\n\n    private void testOverridden(ApplicationContext context, String beanName) {\n        System.out.println(\"sayHello from \" + context.getId() +\": \"\n                           + context.getBean(beanName, Hello.class).hello());\n    }\n}</code></pre>\n<p>这段程序的运行结果如下：</p>\n<pre class=\"code-rows\"><code>ParentContext can see parentHello: true\nChildContext can see parentHello: true\nParentContext can see childHello: false\nChildContext can see childHello: true\nsayHello from ParentContext: Hello World! by PARENT\nsayHello from ChildContext: Hello World! by CHILD</code></pre>\n<p>通过这个示例，我们可以得出如下关于容器继承的通用结论——它们和 Java 类的继承非常相似，二者的对比如表 2-2 所示。</p>\n<p><strong>表 2-2　容器继承 vs.Java 类继承</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>容器继承</p></th>\n<th><p>Java 类继承</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>子上下文可以看到父上下文中定义的 Bean，反之则不行</p></td>\n<td><p>子类可以看到父类的 <code>protected</code> 和 <code>public</code> 属性和方法，父类看不到子类的</p></td>\n</tr>\n<tr>\n<td><p>子上下文中可以定义与父上下文同 ID 的 Bean，各自都能获取自己定义的 Bean</p></td>\n<td><p>子类可以覆盖父类定义的属性和方法</p></td>\n</tr>\n</tbody>\n</table>\n<p>关于同 ID 覆盖 Bean，有时也会引发一些意料之外的问题。如果希望关闭这个特性，也可以考虑禁止覆盖，通过容器的 <code>setAllowBeanDefinitionOverriding()</code> 方法可以控制这一行为。</p>\n<h2 id=\"nav_point_29\">2.2　Bean 基础知识</h2>\n<p>Bean 是 Spring 容器中的重要概念，这一节就让我们来着重了解一下 Bean 的概念、如何注入 Bean 的依赖，以及如何在容器中进行 Bean 的配置。</p>\n<h3 id=\"nav_point_30\">2.2.1　什么是 Bean</h3>\n<p>Java 中有个比较重要的概念叫做“JavaBeans”<span class=\"comment-number\">7</span>，维基百科 <span class=\"comment-number\">8</span> 中有如下描述：</p>\n\n\n<blockquote>\n<p>JavaBeans 是 Java 中一种特殊的类，可以将多个对象封装到一个对象（Bean）中。特点是可序列化，提供无参构造器，提供 <code>Getter</code> 方法和 <code>Setter</code> 方法访问对象的属性。名称中的 Bean 是用于 Java 的可重用软件组件的惯用叫法。</p>\n</blockquote>\n<p>从中可以看到：<strong>Bean</strong> 是指 Java 中的<strong>可重用软件组件</strong>，Spring 容器也<strong>遵循</strong>这一惯例，因此将容器中管理的可重用组件称为 Bean。容器会根据所提供的元数据来创建并管理这些 Bean，其中也包括它们之间的依赖关系。Spring 容器对 Bean 并没有太多的要求，无须实现特定接口或依赖特定库，只要是最普通的 Java 对象即可，这类对象也被称为 POJO（Plain Old Java Object）。</p>\n<p>一个 Bean 的定义中，会包含如下部分：</p>\n<ul>\n<li>Bean 的名称，一般是 Bean 的 <code>id</code>，也可以为 Bean 指定别名（alias）；</li>\n<li>Bean 的具体类信息，这是一个全限定类名；</li>\n<li>Bean 的作用域，是单例（singleton）还是原型（prototype）<span class=\"comment-number\">9</span>；</li>\n<li>依赖注入相关信息，构造方法参数、属性以及自动织入（autowire）方式；</li>\n<li>创建销毁相关信息，懒加载模式、初始化回调方法与销毁回调方法。</li>\n</ul>\n\n<p>我们可以自行设定 Bean 的名字，也可以让 Spring 容器帮我们设置名称。Spring 容器的命名方式为类名的首字母小写，搭配驼峰（camel-cased）规则。比如类型为 <code>HelloService</code> 的 Bean，自动生成的名称就为 <code>helloService</code>。</p>\n<h3 id=\"nav_point_31\">2.2.2　Bean 的依赖关系</h3>\n<p>所谓“依赖注入”，很重要的一块就是管理依赖。在 Spring 容器中，“管理依赖”主要就是管理 Bean 之间的依赖。有两种基本的注入方式——基于构造方法的注入和基于 <code>Setter</code> 方法的注入。</p>\n<p>所谓基于构造方法的注入，就是通过构造方法来注入依赖。仍旧以 HelloWorld 为例，如代码示例 2-10 所示 <span class=\"comment-number\">10</span>。</p>\n\n<blockquote>\n<p><strong>代码示例 2-10</strong>　通过构造方法传入字符串的 <code>Hello</code> 类</p>\n</blockquote>\n<pre class=\"code-rows\"><code>package learning.spring.helloworld;\n\npublic class Hello {\n    private String name;\n\n    public Hello(String name) {\n        this.name = name;\n    }\n\n    public String hello() {\n        return \"Hello World! by \" + name;\n    }\n}</code></pre>\n<p>对应的 XML 配置文件需要使用 <code>&lt;constructor-arg/&gt;</code> 传入构造方法所需的内容，如代码示例 2-11 所示。</p>\n<blockquote>\n<p><strong>代码示例 2-11</strong>　通过构造方法配置 Bean 的 XML 文件</p>\n</blockquote>\n<pre class=\"code-rows\"><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;\n\n    &lt;bean id=\"hello\" class=\"learning.spring.helloworld.Hello\"&gt;\n        &lt;constructor-arg value=\"Spring\"/&gt;\n    &lt;/bean&gt;\n\n&lt;/beans&gt;</code></pre>\n<p><code>&lt;constructor-arg&gt;</code> 中有不少属性可以配置，具体如表 2-3 所示。</p>\n<p><strong>表 2-3　<code>&lt;constructor-arg/&gt;</code> 的可配置属性</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>属性</p></th>\n<th><p>作用</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>value</code></p></td>\n<td><p>要传给构造方法参数的值</p></td>\n</tr>\n<tr>\n<td><p><code>ref</code></p></td>\n<td><p>要传给构造方法参数的 Bean ID</p></td>\n</tr>\n<tr>\n<td><p><code>type</code></p></td>\n<td><p>构造方法参数对应的类型</p></td>\n</tr>\n<tr>\n<td><p><code>index</code></p></td>\n<td><p>构造方法参数对应的位置，从 0 开始计算</p></td>\n</tr>\n<tr>\n<td><p><code>name</code></p></td>\n<td><p>构造方法参数对应的名称</p></td>\n</tr>\n</tbody>\n</table>\n<p>基于 <code>Setter</code> 方法的注入，顾名思义，就是通过 Bean 的 <code>Setter</code> 方法来注入依赖。我们在第 2.1.4 节已经看到了对应的例子，具体可以参考代码示例 2-6 与代码示例 2-7。<code>&lt;property/&gt;</code> 中的 <code>value</code> 属性是直接注入的值，用 <code>ref</code> 属性则可注入其他 Bean。也可以像代码示例 2-12 这样来为属性注入依赖 <span class=\"comment-number\">11</span>。</p>\n\n<blockquote>\n<p><strong>代码示例 2-12</strong>　<code>&lt;property/&gt;</code> 的用法演示</p>\n</blockquote>\n<pre class=\"code-rows\"><code>&lt;bean id=\"...\" class=\"...\"&gt;\n    &lt;property name=\"xxx\"&gt;\n        &lt;!-- 直接定义一个内部的Bean --&gt;\n        &lt;bean class=\"...\"/&gt;\n    &lt;/property&gt;\n\n    &lt;property name=\"yyy\"&gt;\n        &lt;!-- 定义依赖的Bean --&gt;\n        &lt;ref bean=\"...\"/&gt;\n    &lt;/property&gt;\n\n    &lt;property name=\"zzz\"&gt;\n        &lt;!-- 定义一个列表 --&gt;\n        &lt;list&gt;\n            &lt;value&gt;aaa&lt;/value&gt;\n            &lt;value&gt;bbb&lt;/value&gt;\n        &lt;/list&gt;\n    &lt;/property&gt;\n&lt;/bean&gt;</code></pre>\n<p>手动配置依赖在 Bean 少时还能接受，当 Bean 的数量变多后，这种配置就会变得非常繁琐。在合适的场合，可以让 Spring 容器替我们自动进行依赖注入，这种机制称为<strong>自动织入</strong>。自动织入有几种模式，具体见表 2-4。</p>\n<p><strong>表 2-4　自动织入的模式</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>名称</p></th>\n<th><p>说明</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>no</code></p></td>\n<td><p>不进行自动织入</p></td>\n</tr>\n<tr>\n<td><p><code>byName</code></p></td>\n<td><p>根据属性名查找对应的 Bean 进行自动织入</p></td>\n</tr>\n<tr>\n<td><p><code>byType</code></p></td>\n<td><p>根据属性类型查找对应的 Bean 进行自动织入</p></td>\n</tr>\n<tr>\n<td><p><code>constructor</code></p></td>\n<td><p>同 <code>byType</code>，但用于构造方法注入</p></td>\n</tr>\n</tbody>\n</table>\n<p>在 <code>&lt;bean/&gt;</code> 中可以通过 <code>autowire</code> 属性来设置使用何种自动织入方式，也可以在 <code>&lt;beans/&gt;</code> 中设置 <code>default-autowire</code> 属性指定默认的自动织入方式。在使用自动织入时，需要注意以下事项：</p>\n<ul>\n<li>开启自动织入后，仍可以手动设置依赖，手动设置的依赖优先级高于自动织入；</li>\n<li>自动织入无法注入基本类型和字符串；</li>\n<li>对于集合类型的属性，自动织入会把上下文里找到的 Bean 都放进去，但如果属性不是集合类型，有多个候选 Bean 就会有问题。</li>\n</ul>\n<p>为了避免第三点中说到的问题，可以将 <code>&lt;bean/&gt;</code> 的 <code>autowire-candidate</code> 属性设置为 <code>false</code>，也可以在你所期望的候选 Bean 的 <code>&lt;bean/&gt;</code> 中将 <code>primary</code> 设置为 <code>true</code>，这就表明在多个候选 Bean 中该 Bean 是主要的（如果使用基于 Java 类的配置方式，我们可以通过选择 <code>@Primary</code> 注解实现一样的功能）。</p>\n<p>最后，再简单提一下如何指定 Bean 的初始化顺序。一般情况下，Spring 容器会根据依赖情况自动调整 Bean 的初始化顺序。不过，有时 Bean 之间的依赖并不明显，容器可能无法按照我们的预期进行初始化，这时我们可以自己来指定 Bean 的依赖顺序。<code>&lt;bean/&gt;</code> 的 <code>depends-on</code> 属性可以指定当前 Bean 还要依赖哪些 Bean（如果使用基于 Java 类的配置方式，<code>@DependsOn</code> 注解也能实现一样的功能）。</p>\n<h3 id=\"nav_point_32\">2.2.3　Bean 的三种配置方式</h3>\n<p>Spring Framework 提供了多种不同风格的配置方式，早期仅支持 XML 配置文件的方式，Spring Framework 2.0 引入了基于注解的配置方式，到了 3.0 则又增加了基于 Java 类的配置方式。这几种方式没有明确的优劣之分，选择合适的或者喜欢的方式就好，很多时候我们也会混合使用这几种配置方式。</p>\n<p>鉴于 Spring 容器的元数据配置本质上就是配置 Bean（AOP 和事务的配置背后也是配置各种 Bean），因此我们会在本节中详细展开说明如何配置 Bean。</p>\n<ol>\n<li><p><strong>基于 XML 文件的配置</strong></p>\n<p>Spring Framework 提供了 <code>&lt;beans/&gt;</code> 这个 Schema<span class=\"comment-number\">12</span> 来配置 Bean，前文中已经用过了 XML 文件方式的配置，这里再简单回顾一下。</p>\n<p>我们通过 <code>&lt;bean/&gt;</code> 可以配置一个 Bean，<code>id</code> 指定 Bean 的标识，<code>class</code> 指定 Bean 的全限定类名，一般会通过类的构造方法来创建 Bean，但也可以使用一个静态的 <code>factory-method</code>，比如下面就使用了 <code>create()</code> 静态方法：</p>\n<pre class=\"code-rows\"><code>&lt;bean id=\"xxx\" class=\"learning.spring.Yyy\" factory-method=\"create\" /&gt;</code></pre>\n<p><code>&lt;constructor-arg/&gt;</code> 和 <code>&lt;property/&gt;</code> 用来注入所需的内容。如果是另一个 Bean 的依赖，一般会用 <code>ref</code> 属性，2.2.3 节中已经有过说明，此处就不再赘述了。</p>\n<p><code>&lt;bean/&gt;</code> 中还有几个重要的属性，<code>scope</code> 表明当前 Bean 是单例还是原型，<code>lazy-init</code> 是指当前 Bean 是否是懒加载的，<code>depends-on</code> 明确指定当前 Bean 的初始化顺序，就像下面这样：</p>\n<pre class=\"code-rows\"><code>&lt;bean id=\"...\" class=\"...\" scope=\"singleton\" lazy-init=\"true\" depends-on=\"xxx\"/&gt;</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>基于注解的配置</strong></p>\n<p>Spring Framework 2.0 引入了 <code>@Required</code> 注解 <span class=\"comment-number\">13</span>，Spring Framework 2.5 又引入了 <code>@Autowired</code>、<code>@Component</code>、<code>@Service</code> 和 <code>@Repository</code> 等重要的注解，使用这些注解能简化 Bean 的配置。我们可以像代码示例 2-13 那样开启对这些注解的支持 <span class=\"comment-number\">14</span>。</p>\n<blockquote>\n<p><strong>代码示例 2-13</strong>　启用基于注解的配置</p>\n</blockquote>\n<pre class=\"code-rows\"><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\"&gt;\n\n    &lt;context:component-scan base-package=\"learning.spring\"/&gt;\n\n&lt;/beans&gt;</code></pre>\n<p>上述配置会扫描 <code>learning.spring</code> 包内的类，在类上添加如下四个注解都能让 Spring 容器把它们配置为 Bean，如表 2-5 所示。</p>\n<p><strong>表 2-5　Bean 创建相关注解</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>注解</th><th>说明</th></tr><tr><td><code>@Component</code></td><td>将类标识为普通的组件，即一个 Bean</td></tr><tr><td><code>@Service</code></td><td>将类标识为服务层的服务</td></tr><tr><td><code>@Repository</code></td><td>将类标识为数据层的数据仓库，一般是 DAO（Data Access Object）</td></tr><tr><td><code>@Controller</code></td><td>将类标识为 Web 层的 Web 控制器（后来针对 REST 服务又增加了一个 <code>@RestController</code> 注解）</td></tr></table>\n\n<p>如果不指定 Bean 的名称，Spring 容器会自动生成一个名称，当然，也可以明确指定名称，比如：</p>\n<pre class=\"code-rows\"><code>@Component(\"helloBean\")\npublic class Hello {...}</code></pre>\n<p>如果要注入依赖，可以使用如下的注解，如表 2-6 所示。</p>\n<p><strong>表 2-6　可注入依赖的注解</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>注解</th><th>说明</th></tr><tr><td><code>@Autowired</code></td><td>根据类型注入依赖，可用于构造方法、<code>Setter</code> 方法和成员变量</td></tr><tr><td><code>@Resource</code><sup><b>15</b></sup></td><td>JSR-250 的注解，根据名称注入依赖</td></tr><tr><td><code>@Inject</code></td><td>JSR-330 的注解，同 <code>@Autowired</code></td></tr></table>\n\n<blockquote>\n<p><sup><b>15</b></sup>从 Spring Framework 6.0 开始，<code>@Resource</code>、<code>@PostConstruct</code> 和 <code>@PreDestroy</code> 注解都换了新的包名，建议使用 <code>jakarta</code>.annotation 包里的注解，但也兼容 javax.annotation 包中的注解；@Inject 注解则是建议使用 <code>jakarta</code>.inject 包里的，但也兼容 javax.inject 包中的。</p>\n</blockquote>\n<p><code>@Autowired</code> 注解比较常用，下面的例子中可以指定是否必须存在依赖项，并指定目标依赖的 Bean ID<span class=\"comment-number\">16</span>：</p>\n<pre class=\"code-rows\"><code>@Autowired(required = false)\n@Qualifier(\"helloBean\")\npublic void setHello(Hello hello) {...}</code></pre>\n<p>除此之外，还可以使用 <code>@Value</code> 注解注入环境变量、Properties 或 YAML 中配置的属性和 SpEL 表达式 <span class=\"comment-number\">17</span> 的计算结果。JSR-250 中还有 <code>@PostConstruct</code> 和 <code>@PreDestroy</code> 注解，把这两个注解加在方法上用来表示该方法要在初始化后调用或者是在销毁前调用，在聊到 Bean 的生命周期时我们还会看到它们。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>基于 Java 类的配置</strong></p>\n<p>从 Spring Framework 3.0 开始，我们可以使用 Java 类代替 XML 文件，使用 <code>@Configuration</code>、<code>@Bean</code> 和 <code>@ComponentScan</code> 等一系列注解，基本可以满足日常所需。</p>\n<p>通过 <code>AnnotationConfigApplicationContext</code> 可以构建一个支持基于注解和 Java 类的 Spring 上下文：</p>\n<pre class=\"code-rows\"><code>ApplicationContext ctx = new AnnotationConfigApplicationContext(Config.class);</code></pre>\n<p>其中的 <code>Config</code> 类就是一个加了 <code>@Configuration</code> 注解的 Java 类，它可以是代码示例 2-14 这样的。</p>\n<blockquote>\n<p><strong>代码示例 2-14</strong>　Java 配置类示例</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Configuration\n@ComponentScan(\"learning.spring\")\npublic class Config {\n    @Bean\n    @Lazy\n    @Scope(\"prototype\")\n    public Hello helloBean() {\n        return new Hello();\n    }\n}</code></pre>\n<p>类上的 <code>@Configuration</code> 注解表明这是一个 Java 配置类，<code>@ComponentScan</code> 注解指定了类扫描的包名，作用与 <code>&lt;context:component-scan/&gt;</code> 类似。在 <code>@ComponentScan</code> 中，<code>includeFilters</code> 和 <code>excludeFilters</code> 可以用来指定包含和排除的组件，例如官方文档中就有如下示例：</p>\n<pre class=\"code-rows\"><code>@Configuration\n@ComponentScan(basePackages = \"org.example\",\n        includeFilters = @Filter(type = FilterType.REGEX,\n                               pattern = \".*Stub.*Repository\"),\n        excludeFilters = @Filter(Repository.class))\npublic class AppConfig { ... }</code></pre>\n<p>如果 <code>@Configuration</code> 没有指定扫描的基础包路径或者类，默认就从该配置类的包开始扫描。</p>\n<p><code>Config</code> 类中的 <code>helloBean()</code> 方法上添加了 <code>@Bean</code> 注解，该方法的返回对象会被当做容器中的一个 Bean，<code>@Lazy</code> 注解说明这个 Bean 是延时加载的，<code>@Scope</code> 注解则指定了它是原型 Bean。<code>@Bean</code> 注解有如下属性，如表 2-7 所示。</p>\n<p><strong>表 2-7　<code>@Bean</code> 注解的属性</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>属性</th><th>默认值</th><th>说明</th></tr><tr><td><code>name</code></td><td><code>{}</code></td><td>Bean 的名称，默认同方法名</td></tr><tr><td><code>value</code></td><td><code>{}</code></td><td>同 <code>name</code></td></tr><tr><td><code>autowire</code></td><td><code>Autowire.NO</code></td><td>自动织入方式</td></tr><tr><td><code>autowireCandidate</code></td><td><code>true</code></td><td>是否是自动织入的候选 Bean</td></tr><tr><td><code>initMethod</code></td><td><code>\"\"</code></td><td>初始化方法名</td></tr><tr><td><code>destroyMethod</code></td><td><code>AbstractBeanDefinition.INFER_METHOD</code><sup><b>18</b></sup></td><td>销毁方法名</td></tr></table>\n\n<blockquote>\n<p><sup><b>18</b></sup>自动推测销毁 Bean 时该调用的方法，会自动去调用修饰符为 <code>public</code>、没有参数且方法名是 <code>close</code> 或 <code>shutdown</code> 的方法。如果类实现了 <code>java.lang.AutoCloseable</code> 或 <code>java.io.Closeable</code> 接口，也会调用其中的 <code>close()</code> 方法。</p>\n</blockquote>\n<p>在 Java 配置类中指定 Bean 之间的依赖关系有两种方式，通过方法的参数注入依赖，或者直接调用类中带有 <code>@Bean</code> 注解的方法。</p>\n<p>代码示例 2-15 中，<code>foo()</code> 创建了一个名为 <code>foo</code> 的 Bean，<code>bar()</code> 方法通过参数 <code>foo</code> 注入了 <code>foo</code> 这个 Bean，<code>baz()</code> 方法内则通过调用 <code>foo()</code> 获得了同一个 Bean。</p>\n<blockquote>\n<p><strong>代码示例 2-15</strong>　依赖示例</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Configuration\npublic class Config {\n    @Bean\n      public Foo foo() {\n        return new Foo();\n    }\n\n    @Bean\n    public Bar bar(Foo foo) {\n        return new Bar(foo);\n    }\n\n    @Bean\n    public Baz baz() {\n        return new Baz(foo());\n    }\n}</code></pre>\n<p>需要重点说明的是，Spring Framework 针对 <code>@Configuration</code> 类中带有 <code>@Bean</code> 注解的方法通过 CGLIB（Code Generation Library）做了特殊处理，针对返回单例类型 Bean 的方法，调用多次返回的结果是一样的，并不会真的执行多次。</p>\n<p>在配置类中也可以导入其他配置，例如，用 @Import 导入其他配置类，用 @ImportResource 导入配置文件，就像下面这样：</p>\n<pre class=\"code-rows\"><code>@Configuration\n@Import({ CongfigA.class, ConfigB.class })\n@ImportResource(\"classpath:/spring/*-applicationContext.xml\")\npublic class Config {}</code></pre>\n</li>\n</ol>\n\n\n\n\n\n","comments":[{"had_liked":false,"id":386610,"user_name":"、落叶为你舞","can_delete":false,"product_type":"c1","uid":1756562,"ip_address":"广东","ucode":"A196460774A33F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/cd/92/f75a00dd.jpg","comment_is_top":false,"comment_ctime":1705210284,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636606,"comment_content":"代码缩进问题可以修复一下吗","like_count":0}]}