{"id":8624,"title":"第14讲 | 谈谈你知道的设计模式？","content":"<p>设计模式是人们为软件开发中相同表征的问题，抽象出的可重复利用的解决方案。在某种程度上，设计模式已经代表了一些特定情况的最佳实践，同时也起到了软件工程师之间沟通的“行话”的作用。理解和掌握典型的设计模式，有利于我们提高沟通、设计的效率和质量。</p>\n<p>今天我要问你的问题是，<span class=\"orange\">谈谈你知道的设计模式？请手动实现单例模式，Spring等框架中使用了哪些模式？</span></p>\n<h2>典型回答</h2>\n<p>大致按照模式的应用目标分类，设计模式可以分为创建型模式、结构型模式和行为型模式。</p>\n<ul>\n<li>\n<p>创建型模式，是对对象创建过程的各种问题和解决方案的总结，包括各种工厂模式（Factory、Abstract Factory）、单例模式（Singleton）、构建器模式（Builder）、原型模式（ProtoType）。</p>\n</li>\n<li>\n<p>结构型模式，是针对软件设计结构的总结，关注于类、对象继承、组合方式的实践经验。常见的结构型模式，包括桥接模式（Bridge）、适配器模式（Adapter）、装饰者模式（Decorator）、代理模式（Proxy）、组合模式（Composite）、外观模式（Facade）、享元模式（Flyweight）等。</p>\n</li>\n<li>\n<p>行为型模式，是从类或对象之间交互、职责划分等角度总结的模式。比较常见的行为型模式有策略模式（Strategy）、解释器模式（Interpreter）、命令模式（Command）、观察者模式（Observer）、迭代器模式（Iterator）、模板方法模式（Template Method）、访问者模式（Visitor）。</p>\n</li>\n</ul>\n<h2>考点分析</h2>\n<p>这个问题主要是考察你对设计模式的了解和掌握程度，更多相关内容你可以参考：<a href=\"https://en.wikipedia.org/wiki/Design_Patterns\">https://en.wikipedia.org/wiki/Design_Patterns。</a></p>\n<p>我建议可以在回答时适当地举些例子，更加清晰地说明典型模式到底是什么样子，典型使用场景是怎样的。这里举个Java基础类库中的例子供你参考。</p>\n<!-- [[[read_end]]] -->\n<p>首先，<a href=\"http://time.geekbang.org/column/article/8369\">专栏第11讲</a>刚介绍过IO框架，我们知道InputStream是一个抽象类，标准类库中提供了FileInputStream、ByteArrayInputStream等各种不同的子类，分别从不同角度对InputStream进行了功能扩展，这是典型的装饰器模式应用案例。</p>\n<p>识别装饰器模式，可以通过<strong>识别类设计特征</strong>来进行判断，也就是其类构造函数以<strong>相同的</strong>抽象类或者接口为输入参数。</p>\n<p>因为装饰器模式本质上是包装同类型实例，我们对目标对象的调用，往往会通过包装类覆盖过的方法，迂回调用被包装的实例，这就可以很自然地实现增加额外逻辑的目的，也就是所谓的“装饰”。</p>\n<p>例如，BufferedInputStream经过包装，为输入流过程增加缓存，类似这种装饰器还可以多次嵌套，不断地增加不同层次的功能。</p>\n<pre><code>public BufferedInputStream(InputStream in)\n</code></pre>\n<p>我在下面的类图里，简单总结了InputStream的装饰模式实践。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/77/33/77ad2dc2513da8155a3781e8291fac33.png?wh=594*379\" alt=\"\" /></p>\n<p>接下来再看第二个例子。创建型模式尤其是工厂模式，在我们的代码中随处可见，我举个相对不同的API设计实践。比如，JDK最新版本中 HTTP/2 Client API，下面这个创建HttpRequest的过程，就是典型的构建器模式（Builder），通常会被实现成<a href=\"https://en.wikipedia.org/wiki/Fluent_interface\">fluent风格</a>的API，也有人叫它方法链。</p>\n<pre><code>HttpRequest request = HttpRequest.newBuilder(new URI(uri))\n                     .header(headerAlice, valueAlice)\n                     .headers(headerBob, value1Bob,\n                      headerCarl, valueCarl,\n                      headerBob, value2Bob)\n                     .GET()\n                     .build();\n</code></pre>\n<p>使用构建器模式，可以比较优雅地解决构建复杂对象的麻烦，这里的“复杂”是指类似需要输入的参数组合较多，如果用构造函数，我们往往需要为每一种可能的输入参数组合实现相应的构造函数，一系列复杂的构造函数会让代码阅读性和可维护性变得很差。</p>\n<p>上面的分析也进一步反映了创建型模式的初衷，即，将对象创建过程单独抽象出来，从结构上把对象使用逻辑和创建逻辑相互独立，隐藏对象实例的细节，进而为使用者实现了更加规范、统一的逻辑。</p>\n<p>更进一步进行设计模式考察，面试官可能会：</p>\n<ul>\n<li>\n<p>希望你写一个典型的设计模式实现。这虽然看似简单，但即使是最简单的单例，也能够综合考察代码基本功。</p>\n</li>\n<li>\n<p>考察典型的设计模式使用，尤其是结合标准库或者主流开源框架，考察你对业界良好实践的掌握程度。</p>\n</li>\n</ul>\n<p>在面试时如果恰好问到你不熟悉的模式，你可以稍微引导一下，比如介绍你在产品中使用了什么自己相对熟悉的模式，试图解决什么问题，它们的优点和缺点等。</p>\n<p>下面，我会针对前面两点，结合代码实例进行分析。</p>\n<h2>知识扩展</h2>\n<p>我们来实现一个日常非常熟悉的单例设计模式。看起来似乎很简单，那么下面这个样例符合基本需求吗？</p>\n<pre><code> public class Singleton {\n       private static Singleton instance = new Singleton();\n       public static Singleton getInstance() {\n          return instance;\n       }\n    }\n</code></pre>\n<p>是不是总感觉缺了点什么？原来，Java会自动为没有明确声明构造函数的类，定义一个public的无参数的构造函数，所以上面的例子并不能保证额外的对象不被创建出来，别人完全可以直接“new Singleton()”，那我们应该怎么处理呢？</p>\n<p>不错，可以为单例定义一个private的构造函数（也有建议声明为枚举，这是有争议的，我个人不建议选择相对复杂的枚举，毕竟日常开发不是学术研究）。这样还有什么改进的余地吗？</p>\n<p><a href=\"http://time.geekbang.org/column/article/8137\">专栏第10讲</a>介绍ConcurrentHashMap时，提到过标准类库中很多地方使用懒加载（lazy-load），改善初始内存开销，单例同样适用，下面是修正后的改进版本。</p>\n<pre><code>public class Singleton {\n        private static Singleton instance;\n        private Singleton() {\n        }\n        public static Singleton getInstance() {\n            if (instance == null) {\n            instance = new Singleton();\n            }\n        return instance;\n        }\n    }\n</code></pre>\n<p>这个实现在单线程环境不存在问题，但是如果处于并发场景，就需要考虑线程安全，最熟悉的就莫过于“双检锁”，其要点在于：</p>\n<ul>\n<li>\n<p>这里的volatile能够提供可见性，以及保证getInstance返回的是初始化<strong>完全</strong>的对象。</p>\n</li>\n<li>\n<p>在同步之前进行null检查，以尽量避免进入相对昂贵的同步块。</p>\n</li>\n<li>\n<p>直接在class级别进行同步，保证线程安全的类方法调用。</p>\n</li>\n</ul>\n<pre><code>public class Singleton {\n\tprivate static volatile Singleton singleton = null;\n\tprivate Singleton() {\n\t}\n\n\tpublic static Singleton getSingleton() {\n    \tif (singleton == null) { // 尽量避免重复进入同步块\n        \tsynchronized (Singleton.class) { // 同步.class，意味着对同步类方法调用\n            \tif (singleton == null) {\n                \tsingleton = new Singleton();\n            \t}\n        \t}\n    \t}\n    \treturn singleton;\n\t}\n}\n\n</code></pre>\n<p>在这段代码中，争论较多的是volatile修饰静态变量，当Singleton类本身有多个成员变量时，需要保证初始化过程完成后，才能被get到。</p>\n<p>在现代Java中，内存排序模型（JMM）已经非常完善，通过volatile的write或者read，能保证所谓的happen-before，也就是避免常被提到的指令重排。换句话说，构造对象的store指令能够被保证一定在volatile read之前。</p>\n<p>当然，也有一些人推荐利用内部类持有静态对象的方式实现，其理论依据是对象初始化过程中隐含的初始化锁（有兴趣的话你可以参考<a href=\"https://docs.oracle.com/javase/specs/jls/se7/html/jls-12.html#jls-12.4.2\">jls-12.4.2</a> 中对LC的说明），这种和前面的双检锁实现都能保证线程安全，不过语法稍显晦涩，未必有特别的优势。</p>\n<pre><code>public class Singleton {\n\tprivate Singleton(){}\n\tpublic static Singleton getSingleton(){\n    \treturn Holder.singleton;\n\t}\n\n\tprivate static class Holder {\n    \tprivate static Singleton singleton = new Singleton();\n\t}\n}\n</code></pre>\n<p>所以，可以看出，即使是看似最简单的单例模式，在增加各种高标准需求之后，同样需要非常多的实现考量。</p>\n<p>上面是比较学究的考察，其实实践中未必需要如此复杂，如果我们看Java核心类库自己的单例实现，比如<a href=\"http://hg.openjdk.java.net/jdk/jdk/file/18fba780c1d1/src/java.base/share/classes/java/lang/Runtime.java\">java.lang.Runtime</a>，你会发现：</p>\n<ul>\n<li>\n<p>它并没使用复杂的双检锁之类。</p>\n</li>\n<li>\n<p>静态实例被声明为final，这是被通常实践忽略的，一定程度保证了实例不被篡改（<a href=\"http://time.geekbang.org/column/article/7489\">专栏第6讲</a>介绍过，反射之类可以绕过私有访问限制），也有有限的保证执行顺序的语义。</p>\n</li>\n</ul>\n<pre><code>private static final Runtime currentRuntime = new Runtime();\nprivate static Version version;\n// …\npublic static Runtime getRuntime() {\n\treturn currentRuntime;\n}\n/** Don't let anyone else instantiate this class */\nprivate Runtime() {}\n</code></pre>\n<p>前面说了不少代码实践，下面一起来简要看看主流开源框架，如Spring等如何在API设计中使用设计模式。你至少要有个大体的印象，如：</p>\n<ul>\n<li>\n<p><a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-beans/src/main/java/org/springframework/beans/factory/BeanFactory.java\">BeanFactory</a>和<a href=\"https://github.com/spring-projects/spring-framework/blob/master/spring-context/src/main/java/org/springframework/context/ApplicationContext.java\">ApplicationContext</a>应用了工厂模式。</p>\n</li>\n<li>\n<p>在Bean的创建中，Spring也为不同scope定义的对象，提供了单例和原型等模式实现。</p>\n</li>\n<li>\n<p>我在<a href=\"http://time.geekbang.org/column/article/7489\">专栏第6讲</a>介绍的AOP领域则是使用了代理模式、装饰器模式、适配器模式等。</p>\n</li>\n<li>\n<p>各种事件监听器，是观察者模式的典型应用。</p>\n</li>\n<li>\n<p>类似JdbcTemplate等则是应用了模板模式。</p>\n</li>\n</ul>\n<p>今天，我与你回顾了设计模式的分类和主要类型，并从Java核心类库、开源框架等不同角度分析了其采用的模式，并结合单例的不同实现，分析了如何实现符合线程安全等需求的单例，希望可以对你的工程实践有所帮助。另外，我想最后补充的是，设计模式也不是银弹，要避免滥用或者过度设计。</p>\n<h2>一课一练</h2>\n<p>关于设计模式你做到心中有数了吗？你可以思考下，在业务代码中，经常发现大量XXFacade，外观模式是解决什么问题？适用于什么场景？</p>\n<p>请你在留言区写写你对这个问题的思考，我会选出经过认真思考的留言，送给你一份学习鼓励金，欢迎你与我一起讨论。</p>\n<p>你的朋友是不是也在准备面试呢？你可以“请朋友读”，把今天的题目分享给好友，或许你能帮到他。</p>\n<p></p>\n","comments":[{"had_liked":false,"id":11521,"user_name":"公号-技术夜未眠","can_delete":false,"product_type":"c1","uid":1013683,"ip_address":"","ucode":"83825B57CBD952","user_header":"https://static001.geekbang.org/account/avatar/00/0f/77/b3/991f3f9b.jpg","comment_is_top":false,"comment_ctime":1528174101,"is_pvip":true,"replies":[{"id":"3717","content":"不错","user_name":"作者回复","comment_id":11521,"uid":"1009360","ip_address":"","utype":1,"ctime":1528217614,"user_name_real":"杨晓峰"}],"discussion_count":2,"race_medal":0,"score":"366600394261","product_id":100006701,"comment_content":"门面模式形象上来讲就是在原系统之前放置了一个新的代理对象，只能通过该对象才能使用该系统，不再允许其它方式访问该系统。该代理对象封装了访问原系统的所有规则和接口方法，提供的API接口较之使用原系统会更加的简单。<br><br>举例:JUnitCore是JUnit类的 Facade模式的实现类，外部使用该代理对象与JUnit进行统一交互，驱动执行测试代码。<br><br>使用场景:当我们希望封装或隐藏原系统；当我们使用原系统的功能并希望增加一些新的功能；编写新类的成本远小于所有人学会使用或者未来维护原系统所需的成本；<br><br>缺点:违反了开闭原则。如有扩展，只能直接修改代理对象。","like_count":86,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418880,"discussion_content":"不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528217614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1129317,"avatar":"https://static001.geekbang.org/account/avatar/00/11/3b/65/203298ce.jpg","nickname":"小名叫大明","note":"","ucode":"4804D68A396B40","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":105727,"discussion_content":"厉害了，门面模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577465435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12024,"user_name":"云学","can_delete":false,"product_type":"c1","uid":1027233,"ip_address":"","ucode":"366AE90BA06356","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ac/a1/43d83698.jpg","comment_is_top":false,"comment_ctime":1528520415,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"134672506591","product_id":100006701,"comment_content":"最开始迷恋设计模式，后来眼中没有模式，其实那本经典的设计模式的书的第一章就非常明确的指出设计模式不是银弹，总感觉java语言写的程序比c++更重，很多代码都是无用的装饰","like_count":32,"discussions":[{"author":{"id":1344289,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLEYbNElGIxY6Le1rfiakWJecz8JIOp06Y9JQFR2YBn3T3gx3icI5CKxZNgxgqiaKbfVOicXquO3QBw9w/132","nickname":"july","note":"","ucode":"E081987929063A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":91464,"discussion_content":"这位仁兄，一开始我也是这种感觉，C++的const，java的final有啥用啊，我自己不去改他不就行了？ 后来随着经验丰富，这种想法慢慢的就改变了，软件是协作的，别人不一定知道我们的设计意图而不去改变它，而这些关键字、设计模式也一定程度上的传达我们的设计意图，如果懂某个设计模式的人看使用这个模式设计的代码，阅读成本也会低很多，很容易上手，并且不会胡乱修改代码；","likes_number":30,"is_delete":false,"is_hidden":false,"ctime":1576835367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1324314,"avatar":"https://static001.geekbang.org/account/avatar/00/14/35/1a/9fa38dc9.jpg","nickname":"子瞻","note":"","ucode":"5C26FF10934534","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1344289,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLEYbNElGIxY6Le1rfiakWJecz8JIOp06Y9JQFR2YBn3T3gx3icI5CKxZNgxgqiaKbfVOicXquO3QBw9w/132","nickname":"july","note":"","ucode":"E081987929063A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350940,"discussion_content":"点赞，换位思考","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614077729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":91464,"ip_address":""},"score":350940,"extra":""}]},{"author":{"id":2052476,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Qq6oLfOTgKzjiculoUDicdv7WoY1iabPfOTumibWeInVP2Mnod9XVPrNSClvIiaLbvtDlIjRnWUNaXcYwREGzlcaDog/132","nickname":"Geek_在下蟑螂王","note":"","ucode":"E1F5BBB5BC5962","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291438,"discussion_content":"不杠。你在第二层以为设计模式只有第一层，其实设计模式是第五层。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1594819500,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1052718,"avatar":"https://static001.geekbang.org/account/avatar/00/10/10/2e/1a0e7c59.jpg","nickname":"熊孩子马洛伊","note":"","ucode":"C907D62052FB4E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":233406,"discussion_content":"我是搞游戏开发的，其实除了特定的业务逻辑，还有一些通用的框架需要，没有必要一味的追求使用设计模式，许多设计模式是标准库或某些框架采用的。就像现在委托-事件被不分场合的滥用一样，还是要深入了解每种设计模式的应用场景，比对当前的业务需求，再决定是否使用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586923599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11810,"user_name":"Walter","can_delete":false,"product_type":"c1","uid":1142493,"ip_address":"","ucode":"2AE436899510D0","user_header":"https://static001.geekbang.org/account/avatar/00/11/6e/dd/9f6f3305.jpg","comment_is_top":false,"comment_ctime":1528371412,"is_pvip":false,"replies":[{"id":"3865","content":"不错，业务系统多见","user_name":"作者回复","comment_id":11810,"uid":"1009360","ip_address":"","utype":1,"ctime":1528380028,"user_name_real":"杨晓峰"}],"discussion_count":3,"race_medal":0,"score":"130377390292","product_id":100006701,"comment_content":"外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。它向现有的系统添加一个接口，来隐藏系统的复杂性。<br>这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。<br><br>意图：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。<br>主要解决：降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。<br>何时使用： 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个&quot;接待员&quot;即可。 2、定义系统的入口。<br>如何解决：客户端不与系统耦合，外观类与系统耦合。<br>关键代码：在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。<br>应用实例： 1、去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。 2、JAVA 的三层开发模式。<br>优点： 1、减少系统相互依赖。 2、提高灵活性。 3、提高了安全性。<br>缺点：不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。<br>使用场景： 1、为复杂的模块或子系统提供外界访问的模块。 2、子系统相对独立。 3、预防低水平人员带来的风险。<br>注意事项：在层次化结构中，可以使用外观模式定义系统中每一层的入口。","like_count":31,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419009,"discussion_content":"不错，业务系统多见","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528380028,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1587666,"avatar":"https://static001.geekbang.org/account/avatar/00/18/39/d2/845c0e39.jpg","nickname":"送过快递的码农","note":"","ucode":"66EA81B3BADC73","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214600,"discussion_content":"请教一下，比如支付宝，第三方调用支付宝的支付接口，算不算是门面！因为过多的支付逻辑不需关心，支付宝来处理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585213889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1144504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/b8/e4cd7997.jpg","nickname":"KAGEMUSHA","note":"","ucode":"DFC05BE62A9C10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1587666,"avatar":"https://static001.geekbang.org/account/avatar/00/18/39/d2/845c0e39.jpg","nickname":"送过快递的码农","note":"","ucode":"66EA81B3BADC73","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286728,"discussion_content":"肯定不算","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593268660,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":214600,"ip_address":""},"score":286728,"extra":""}]}]},{"had_liked":false,"id":11476,"user_name":"南北少卿","can_delete":false,"product_type":"c1","uid":1018958,"ip_address":"","ucode":"DFCC59F2BBD8CE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/4e/b81969fa.jpg","comment_is_top":false,"comment_ctime":1528161419,"is_pvip":false,"replies":[{"id":"3719","content":"什么版本？我这是最新的","user_name":"作者回复","comment_id":11476,"uid":"1009360","ip_address":"","utype":1,"ctime":1528217692,"user_name_real":"杨晓峰"}],"discussion_count":4,"race_medal":0,"score":"100312409227","product_id":100006701,"comment_content":"为什么我去查Runtime的源码，currentRuntime没有被final修饰呢？","like_count":23,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418858,"discussion_content":"什么版本？我这是最新的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528217692,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005630,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/58/3e/77c9b529.jpg","nickname":"Sanhong","note":"","ucode":"0B68D6EE423CA8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":216701,"discussion_content":"jdk1.8里面就不是","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1585478131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1339446,"avatar":"https://static001.geekbang.org/account/avatar/00/14/70/36/197927f5.jpg","nickname":"傲宇","note":"","ucode":"92BBE2C6494B26","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1005630,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/58/3e/77c9b529.jpg","nickname":"Sanhong","note":"","ucode":"0B68D6EE423CA8","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":275009,"discussion_content":"11是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590645105,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":216701,"ip_address":""},"score":275009,"extra":""}]},{"author":{"id":1059706,"avatar":"https://static001.geekbang.org/account/avatar/00/10/2b/7a/d9755a98.jpg","nickname":"学无止境","note":"","ucode":"B7E161D7A287B8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":317754,"discussion_content":"内部类的实现不需要final 修饰吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603597071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11644,"user_name":"田维俊","can_delete":false,"product_type":"c1","uid":1128209,"ip_address":"","ucode":"B76DA7759E7B6F","user_header":"https://static001.geekbang.org/account/avatar/00/11/37/11/24a29de4.jpg","comment_is_top":false,"comment_ctime":1528257744,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"70247734480","product_id":100006701,"comment_content":"公司项目是一个基于spingboot、mybatis开发的web后端管理项目。现在的问题是   不同角色登录到系统看到的模块和模块里面的数据是不一样的，有时虽然看到的模块一样，但是由于角色不一样，所以显示的数据是不一样，在这样的情况下，会经常在service层方法里面判断角色然后改变mapper的数据操作条件或调用mapper的不同方法。由于在service层频繁的判断角色感觉很不雅，新增角色就要加判断，哎，感觉可以用策略设计模式，可是不知道怎么具体设计。","like_count":16,"discussions":[{"author":{"id":2011492,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/b1/64/5570b054.jpg","nickname":"逍遥","note":"","ucode":"EDC322BAB83D67","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278954,"discussion_content":"使用权限控制。用户、角色、资源3张表，加两张中间表。前端使用vue中的路由控制访问跳转，后端通过判断用户所能访问的资源值得出它所能作出的操作","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591263555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2016786,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/c6/12/7c36aa3a.jpg","nickname":"Black船长","note":"","ucode":"B0B73E8DEB56C4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278957,"discussion_content":"策略模式是把方法抽象出来，实际调用的时候传入不同的方法实现，比如 stream.sort(传入一个比较两个对象的大小的方法)，你这个场景感觉不太适用这个，为每一个角色添加不同的方法不太可取，扩展性也差。推荐的的是 @逍遥 的做法，将角色的区分放到数据库，不同的角色有不同的资源。代码是统一的逻辑，有啥资源就能干啥事，不区分角色。角色框架可以参考开源的 shiro 还有个spring的啥权限组件","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591264093,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1344289,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLEYbNElGIxY6Le1rfiakWJecz8JIOp06Y9JQFR2YBn3T3gx3icI5CKxZNgxgqiaKbfVOicXquO3QBw9w/132","nickname":"july","note":"","ucode":"E081987929063A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":91468,"discussion_content":"你这问题不就跟例子一模一样吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576835430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1583833,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/E3XKbwTv6WTssolgqZjZCkiazHgl2IdBYfwVfAcB7Ff3krsIQeBIBFQLQE1Kw91LFbl3lic2EzgdfNiciaYDlJlELA/132","nickname":"rike","note":"","ucode":"920AAD0BD9245C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1344289,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLEYbNElGIxY6Le1rfiakWJecz8JIOp06Y9JQFR2YBn3T3gx3icI5CKxZNgxgqiaKbfVOicXquO3QBw9w/132","nickname":"july","note":"","ucode":"E081987929063A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":154922,"discussion_content":"哪个例子？我没看明白。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580199627,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":91468,"ip_address":""},"score":154922,"extra":""},{"author":{"id":1500288,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e4/80/9da16743.jpg","nickname":"梧桐","note":"","ucode":"CECEEABE6AD55A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1583833,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/E3XKbwTv6WTssolgqZjZCkiazHgl2IdBYfwVfAcB7Ff3krsIQeBIBFQLQE1Kw91LFbl3lic2EzgdfNiciaYDlJlELA/132","nickname":"rike","note":"","ucode":"920AAD0BD9245C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":191572,"discussion_content":"用户那个例子","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582999642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":154922,"ip_address":""},"score":191572,"extra":""}]}]},{"had_liked":false,"id":22155,"user_name":"So Leung","can_delete":false,"product_type":"c1","uid":1132303,"ip_address":"","ucode":"0366A1DC7B7766","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/0f/b75e839c.jpg","comment_is_top":false,"comment_ctime":1535513913,"is_pvip":false,"replies":[{"id":"8078","content":"很形象","user_name":"作者回复","comment_id":22155,"uid":"1009360","ip_address":"","utype":1,"ctime":1535722552,"user_name_real":"杨晓峰"}],"discussion_count":2,"race_medal":0,"score":"57370088761","product_id":100006701,"comment_content":"屏蔽掉复杂的系统，提供一个对外的简单的接口供别人调用，比如某个人想开一家商店可能要去很多的部门审批手续，比如税务、公司、卫生等等。但是有一天这些部门提供了一个统一的窗口，大家通过这个窗口可以办完所以的流程。这就是外观模式的一个现实抽象。","like_count":14,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423021,"discussion_content":"很形象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535722552,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1129317,"avatar":"https://static001.geekbang.org/account/avatar/00/11/3b/65/203298ce.jpg","nickname":"小名叫大明","note":"","ucode":"4804D68A396B40","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":105728,"discussion_content":"大佬","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577465504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11440,"user_name":"sunlight001","can_delete":false,"product_type":"c1","uid":1126975,"ip_address":"","ucode":"A72C4274D5DE8A","user_header":"https://static001.geekbang.org/account/avatar/00/11/32/3f/fa4ac035.jpg","comment_is_top":false,"comment_ctime":1528156223,"is_pvip":false,"replies":[{"id":"3721","content":"不必为了模式而用，优先解决开发、维护中的痛点","user_name":"作者回复","comment_id":11440,"uid":"1009360","ip_address":"","utype":1,"ctime":1528217777,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"53067763775","product_id":100006701,"comment_content":"结合流行的开源框架，或者自己的项目学设计模式是很好的办法，生学很容易看不懂学不下去，xxxfascade是门面模式，为复杂的逻辑提供简单的借口，设计模式学的时候还能明白，但是用的时候就不知道该怎么用了，我们怎么在项目中使用设计模式呢？","like_count":12,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418843,"discussion_content":"不必为了模式而用，优先解决开发、维护中的痛点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528217777,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11535,"user_name":"yearning","can_delete":false,"product_type":"c1","uid":1011455,"ip_address":"","ucode":"4C7522ADEAC837","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6e/ff/bcbfae67.jpg","comment_is_top":false,"comment_ctime":1528184497,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31592955569","product_id":100006701,"comment_content":"Facade（外观模式）<br>接口隔离模式。处理组件中外部客户程序和组件中各种复杂的子系统高耦合情况，定义一个高层接口，为子系统中的一组接口提供一个一致（稳定）的界面，使得更简单的使用。<br>facade简化整个组件系统的接口，同时子系统的任何变化都不会影响到facade接口。<br><br>有一个更简单的称呼，门面模式，打个比方说，你去商店，你只需要告诉店员，你需要什么，至于商店中复杂的采购系统，库存系统，收银系统一概对你不可见。<br><br>在经常使用的hibernate，当我们想插入一条用户信息，facade接口中insert(User user)，我们只要传递User对象，至于背后的操作对外部调用是不可见。<br><br>facade模式是从架构的层次去看整个系统，而是一两个类之间单纯解耦。","like_count":7},{"had_liked":false,"id":11500,"user_name":"星空","can_delete":false,"product_type":"c1","uid":1120068,"ip_address":"","ucode":"A5B24F4161F654","user_header":"https://static001.geekbang.org/account/avatar/00/11/17/44/05036367.jpg","comment_is_top":false,"comment_ctime":1528163544,"is_pvip":false,"replies":[{"id":"3718","content":"业务开发很普遍","user_name":"作者回复","comment_id":11500,"uid":"1009360","ip_address":"","utype":1,"ctime":1528217630,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"27297967320","product_id":100006701,"comment_content":"外观模式为子系统中一组接口提供一个统一访问的接口，降低了客户端与子系统之间的耦合，简化了系统复杂度。缺点是违反了开闭原则。适用于为一系列复杂的子系统提供一个友好简单的入口，将子系统与客户端解偶。公司基础paas平台用到了外观模式，具体是定义一个ServiceFacade，然后通过继承众多xxService,对外提供子xxService的服务。","like_count":5,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418871,"discussion_content":"业务开发很普遍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528217630,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11491,"user_name":"Sin0","can_delete":false,"product_type":"c1","uid":1057378,"ip_address":"","ucode":"C05F2F2CF103E1","user_header":"https://static001.geekbang.org/account/avatar/00/10/22/62/bcfa528f.jpg","comment_is_top":false,"comment_ctime":1528162647,"is_pvip":true,"replies":[{"id":"3722","content":"不冲突，sync也不是必然走到","user_name":"作者回复","comment_id":11491,"uid":"1009360","ip_address":"","utype":1,"ctime":1528217886,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"27297966423","product_id":100006701,"comment_content":"有一点理解不太一致，单例模式double check中synchronized就已经可以提供可见性，volatile的作用主要体现在禁指令重排！","like_count":6,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418868,"discussion_content":"不冲突，sync也不是必然走到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528217886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11481,"user_name":"李志博","can_delete":false,"product_type":"c1","uid":1009109,"ip_address":"","ucode":"F3C72573B3C112","user_header":"https://static001.geekbang.org/account/avatar/00/0f/65/d5/88beb15a.jpg","comment_is_top":false,"comment_ctime":1528161744,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27297965520","product_id":100006701,"comment_content":"Spring 内部的asm 模块 用到了访问者模式","like_count":6},{"had_liked":false,"id":160263,"user_name":"李永垒","can_delete":false,"product_type":"c1","uid":1683272,"ip_address":"","ucode":"BD8834B92F414A","user_header":"https://static001.geekbang.org/account/avatar/00/19/af/48/ffbb6f57.jpg","comment_is_top":false,"comment_ctime":1575900826,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"23050737306","product_id":100006701,"comment_content":"jdk1.8 java.lang.Runtime 中currentRuntime没有声明为final的","like_count":5,"discussions":[{"author":{"id":1898336,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/f7/60/4553c6e5.jpg","nickname":"奔跑","note":"","ucode":"4A98A8A1CA2540","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":228733,"discussion_content":"刚看了JDK11加了final","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586572357,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11469,"user_name":"润兹","can_delete":false,"product_type":"c1","uid":1114038,"ip_address":"","ucode":"049F7D91C9DB3A","user_header":"https://static001.geekbang.org/account/avatar/00/10/ff/b6/a997e075.jpg","comment_is_top":false,"comment_ctime":1528160534,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"23002997014","product_id":100006701,"comment_content":"在没用facade之前，为了完成某个功能需要调用各子系统的各方法进行组合才能完成，用了facade之后相当于把多个方法调用聚合成了一个方法，方便用户调用。","like_count":5,"discussions":[{"author":{"id":1264392,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4b/08/52954cd7.jpg","nickname":"丁乐洪","note":"","ucode":"549CE57AB20B49","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217442,"discussion_content":"有点像BFF中的facade服务","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585560150,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263540,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1606180084,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"18786049268","product_id":100006701,"comment_content":"一般被问到设计模式可能下意识的反应就是单例模式和工厂模式。<br><br>不过看完这篇文章，感觉对单例模式的理解还是要更深入了一些；看完留言，对于外观模式也能说上一二。<br><br>对于设计模式，我总是觉得很难记住各种模式的名称和示例代码（年龄大了），希望能够通过代码重构，逐步演进为符合设计模式的代码，但是一般工作中可能又没有那么多的时间（可能还是代码写的太少了）。<br><br>如果面试的时候被问到，那么至少应该先说设计模式分为创建、结构和行为三种类型，然后每个类型能说出一两个，应该就可以过关了。<br><br>设计模式的精髓在于对于多态的灵活应用。李智慧老师在隔壁专栏给了一个“标准答案”：除了单例和工厂，我更喜欢适配器和观察者，还有，组合模式在处理树形结构的时候也很有用。","like_count":5},{"had_liked":false,"id":57774,"user_name":"君莫惜","can_delete":false,"product_type":"c1","uid":1101408,"ip_address":"","ucode":"FD570371148000","user_header":"https://static001.geekbang.org/account/avatar/00/10/ce/60/7d17522d.jpg","comment_is_top":false,"comment_ctime":1546908505,"is_pvip":false,"replies":[{"id":"23315","content":"是的","user_name":"作者回复","comment_id":57774,"uid":"1009360","ip_address":"","utype":1,"ctime":1549806831,"user_name_real":"杨晓峰"}],"discussion_count":2,"race_medal":0,"score":"18726777689","product_id":100006701,"comment_content":"外观模式是定义一个高层接口来更方便的去调用低层接口，比如mvc，service的接口就是高层接口，而dao中就是低层接口","like_count":4,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435752,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549806831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1129317,"avatar":"https://static001.geekbang.org/account/avatar/00/11/3b/65/203298ce.jpg","nickname":"小名叫大明","note":"","ucode":"4804D68A396B40","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":105729,"discussion_content":"这个经常用，都会写，但是没想到这就是门面模式？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577465557,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":149698,"user_name":"王盛武","can_delete":false,"product_type":"c1","uid":1182516,"ip_address":"","ucode":"DE7EF246D3DCE8","user_header":"https://static001.geekbang.org/account/avatar/00/12/0b/34/f41d73a4.jpg","comment_is_top":false,"comment_ctime":1573347941,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14458249829","product_id":100006701,"comment_content":"不认同老师说的内部类实现单例不好。  双检索加volatile模式个人不看好，因为外部调用执行影响cpu缓存行和指令冲排序优化","like_count":2},{"had_liked":false,"id":11492,"user_name":"Geek_028e77","can_delete":false,"product_type":"c1","uid":1103955,"ip_address":"","ucode":"59BF55847AA367","user_header":"https://static001.geekbang.org/account/avatar/00/10/d8/53/ee22812a.jpg","comment_is_top":false,"comment_ctime":1528162658,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14413064546","product_id":100006701,"comment_content":"facade模式 主要屏蔽系统内部细节实现，通过facade模式封装统一的接口 提供给外部调用着.有一个优势 ，当内部系统做变更 优化时，这对外部调用者来说是透明的，一定程度上降低了系统间耦合性...个人理解","like_count":3},{"had_liked":false,"id":148748,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1573073104,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10163007696","product_id":100006701,"comment_content":"双检锁的存在为了减少锁调用的次数，进而提升效率。","like_count":2},{"had_liked":false,"id":11953,"user_name":"Miaozhe","can_delete":false,"product_type":"c1","uid":1113660,"ip_address":"","ucode":"62872E8C138B67","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","comment_is_top":false,"comment_ctime":1528456300,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10118390892","product_id":100006701,"comment_content":"我理解Facada模式，微服务应用场景，如：Nginx对系统子服务进行管理和IP反向代理，提供统一的服务，就是屏蔽外部系统对内部服务的具体实现，以及各微服务的部署虚拟机和URL。<br>再者，容器Docker技术，我认为这是Facada模式，通过镜像把应用相关的组件和配置都预置好，发布这个服务时，直接启动容器，用户不用关心里面的任何细节。<br><br>杨老师看看，我分析的对吗？<br>","like_count":2},{"had_liked":false,"id":11446,"user_name":"wutao","can_delete":false,"product_type":"c1","uid":1115558,"ip_address":"","ucode":"084D47DC718310","user_header":"https://static001.geekbang.org/account/avatar/00/11/05/a6/70e8fa55.jpg","comment_is_top":false,"comment_ctime":1528157892,"is_pvip":false,"replies":[{"id":"3720","content":"当然，列出的只是简要说明","user_name":"作者回复","comment_id":11446,"uid":"1009360","ip_address":"","utype":1,"ctime":1528217718,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"10118092484","product_id":100006701,"comment_content":"Spring中还用到了策略模式吧","like_count":2,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418846,"discussion_content":"当然，列出的只是简要说明","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528217718,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190474,"user_name":"时代先锋","can_delete":false,"product_type":"c1","uid":1856411,"ip_address":"","ucode":"956E3E6A6A4F30","user_header":"https://static001.geekbang.org/account/avatar/00/1c/53/9b/d0a21378.jpg","comment_is_top":false,"comment_ctime":1584663320,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879630616","product_id":100006701,"comment_content":"设计模式是开发的高效思维","like_count":1},{"had_liked":false,"id":148749,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1573073605,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5868040901","product_id":100006701,"comment_content":"facade是封装思想的具体实现，一个实现类或者一套已有系统，开放出来的接口可能庞杂，这个时候很可能需要一层来简化其操作，提供友好界面。facade就是在这种场景下使用。早期计算机操作系统，Unix在性能和可扩展等关键指标远胜Windows，但是就是提供的命令行界面有点复杂，对普通人不太友好，最后被Windows逆袭。","like_count":1},{"had_liked":false,"id":18525,"user_name":"clz1341521","can_delete":false,"product_type":"c1","uid":1179557,"ip_address":"","ucode":"3BDB4AB454C918","user_header":"https://static001.geekbang.org/account/avatar/00/11/ff/a5/eccc7653.jpg","comment_is_top":false,"comment_ctime":1533429890,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5828397186","product_id":100006701,"comment_content":"facade门面模式，为了减少对子线实现的依赖，将子类实现统一封装。实现调用封装类。达到所谓的“封装交互，简化调用”","like_count":1},{"had_liked":false,"id":11563,"user_name":"softpower2018","can_delete":false,"product_type":"c1","uid":1058373,"ip_address":"","ucode":"CF8056F81D2898","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiaqmp1PKvQCpDSK7953IEUHZ13uLgos97FwcYCqGrxMKs4arCZmZibSBoBrw6ibHp53jZ19haqw3fA/132","comment_is_top":false,"comment_ctime":1528202516,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5823169812","product_id":100006701,"comment_content":"通过封装的方式，对外屏蔽内部复杂业务逻辑，实现使用方与具体实现的分离。门面模式","like_count":1},{"had_liked":false,"id":337557,"user_name":"枫林血舞","can_delete":false,"product_type":"c1","uid":2809867,"ip_address":"","ucode":"EE7F6DA78D21EA","user_header":"https://static001.geekbang.org/account/avatar/00/2a/e0/0b/6f667b2c.jpg","comment_is_top":false,"comment_ctime":1646892445,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1646892445","product_id":100006701,"comment_content":"门面模式：对外隐藏系统的实现，提供统一的访问入口。最典型的我觉着就是日常常写的MVC的controller层那一个个接口。","like_count":0},{"had_liked":false,"id":286194,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1617183023,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1617183023","product_id":100006701,"comment_content":"杨老师，请教一个面试问题，<br>面试官让我说说设计模式，我按照上面的分类，都分别说了一两个自己使用过的。<br>然后面试官又问我：使用设计模式的时候需要遵循哪些原则？<br>我问指的是SOLID原则么，他没说话，然后我就简单讲了一下自己的理解：“设计模式只是招式，关键还在于对业务的解耦等等”。<br>所以咨询一下老师，您是怎么思考这个问题的。","like_count":0},{"had_liked":false,"id":280925,"user_name":"CharlieWong","can_delete":false,"product_type":"c1","uid":1393234,"ip_address":"","ucode":"0299043A439112","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Ko9aHAWDeYicZqElnJEoepIHLTpL8AkeicwQNsIFuZYpKAAkqkYgWmTMyqfQMSXlc5crCQWkpf8CrserhaT9mwsg/132","comment_is_top":false,"comment_ctime":1614486890,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614486890","product_id":100006701,"comment_content":"为什么没有提到责任链模式","like_count":0},{"had_liked":false,"id":279655,"user_name":"民工597","can_delete":false,"product_type":"c1","uid":1529858,"ip_address":"","ucode":"DB6857E21E9318","user_header":"https://static001.geekbang.org/account/avatar/00/17/58/02/2b7ccf09.jpg","comment_is_top":false,"comment_ctime":1613891078,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613891078","product_id":100006701,"comment_content":"微服务化之后，感觉设计模式没那么重要了","like_count":0},{"had_liked":false,"id":236115,"user_name":"looper","can_delete":false,"product_type":"c1","uid":1238396,"ip_address":"","ucode":"DA4BCE83836C04","user_header":"https://static001.geekbang.org/account/avatar/00/12/e5/7c/2a5a418b.jpg","comment_is_top":false,"comment_ctime":1595320304,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595320304","product_id":100006701,"comment_content":"门面模式解决的是系统调用者和系统子系统之间的耦合问题，调用方通过门面作为统一入口访问业务，不关注子系统的调用和实现，这样做到了解耦。在阅读mybatis源码的时候，我也看到了这样的设计模式，mybatis的configuration类，这一个all in one的facade，但是这种也带来一些缺点，子系统的任意改动都要小心翼翼，因为所有的东西都是all in one的","like_count":0},{"had_liked":false,"id":148747,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1573073013,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573073013","product_id":100006701,"comment_content":"创建型模式是构造函数的延伸，用于解决对象创建有关的几类问题，结构型模式是封装继承的常用套路，主要解决类与类的静态职责划分。行为型模式和结构型模式类似，更偏重于类与类互动的职责划分。<br><br>","like_count":0},{"had_liked":false,"id":131405,"user_name":"刘鑫","can_delete":false,"product_type":"c1","uid":1640009,"ip_address":"","ucode":"551B29E1F14F6F","user_header":"https://static001.geekbang.org/account/avatar/00/19/06/49/1a6da81a.jpg","comment_is_top":false,"comment_ctime":1567740783,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567740783","product_id":100006701,"comment_content":"JDK 1.8.0_91 中，Runtime 单例并没有被申明为final<br><br>public class Runtime {<br>  public static Runtime currentRuntime = new Runtime();<br>  public static Runtime getRuntime() {return currentRuntime};<br>  private Runtime() {}<br><br>} <br>","like_count":0},{"had_liked":false,"id":123535,"user_name":"windcaller","can_delete":false,"product_type":"c1","uid":1514157,"ip_address":"","ucode":"1CA3E849805770","user_header":"https://static001.geekbang.org/account/avatar/00/17/1a/ad/faf1bf19.jpg","comment_is_top":false,"comment_ctime":1565696533,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565696533","product_id":100006701,"comment_content":"我觉得静态类写法不晦涩啊。。。。","like_count":0},{"had_liked":false,"id":97003,"user_name":"jaryoung","can_delete":false,"product_type":"c1","uid":1077406,"ip_address":"","ucode":"6E72D107DB7E51","user_header":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","comment_is_top":false,"comment_ctime":1558571956,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558571956","product_id":100006701,"comment_content":"系统不同模块之间调用，模块负责人可以定义简单接口方法给其他模块使用，避免直接调用模块复杂的内部方法。","like_count":0},{"had_liked":false,"id":85466,"user_name":"送普选","can_delete":false,"product_type":"c1","uid":1220775,"ip_address":"","ucode":"AB2C98BB9C3A5D","user_header":"https://static001.geekbang.org/account/avatar/00/12/a0/a7/db7a7c50.jpg","comment_is_top":false,"comment_ctime":1555067231,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555067231","product_id":100006701,"comment_content":"查Runtime的源码，JDK 1.7.0_79, 1.8.0_161中, currentRuntime 都没有被final修饰。<br>public class Runtime {<br>    private static Runtime currentRuntime = new Runtime();<br>......","like_count":0},{"had_liked":false,"id":69722,"user_name":"天使梦泪","can_delete":false,"product_type":"c1","uid":1235750,"ip_address":"","ucode":"782991747DD424","user_header":"https://static001.geekbang.org/account/avatar/00/12/db/26/3c8d68fb.jpg","comment_is_top":false,"comment_ctime":1550818587,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550818587","product_id":100006701,"comment_content":"老师，可以给讲解下@Bean注解是怎么实现把一个类成为Spring管理的bean？","like_count":0},{"had_liked":false,"id":50095,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1544864886,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544864886","product_id":100006701,"comment_content":"设计模式-经验的复用，需要根据具体场景来选择已被普遍认可的最佳实践。<br>门面模式-各种日志框架的选择使用就比较经典。<br>如果峰哥能分析一下各种设计模式的具体使用场景就更好了，不过23种设计模式也可以后补一下。","like_count":0},{"had_liked":false,"id":48034,"user_name":"Geek_fb3db2","can_delete":false,"product_type":"c1","uid":1218254,"ip_address":"","ucode":"8089B8311B6C80","user_header":"https://static001.geekbang.org/account/avatar/00/12/96/ce/8c3bdbe5.jpg","comment_is_top":false,"comment_ctime":1544327239,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1544327239","product_id":100006701,"comment_content":"封装实现逻辑，对外调用简单。","like_count":0},{"had_liked":false,"id":36206,"user_name":"李","can_delete":false,"product_type":"c1","uid":1119312,"ip_address":"","ucode":"5C0FAA211F2E26","user_header":"https://static001.geekbang.org/account/avatar/00/11/14/50/c23cf47d.jpg","comment_is_top":false,"comment_ctime":1540977543,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1540977543","product_id":100006701,"comment_content":"门面设计模式的目的不是新增功能，而是通过在一个内部复杂的系统与客户之间增加一个代理层，让代理门面层封装这些内部复杂的逻辑提供给客户端简单调用，从而屏蔽了系统内部功能复杂性，提高了客户端调用的易用性。","like_count":0},{"had_liked":false,"id":22496,"user_name":"扬～","can_delete":false,"product_type":"c1","uid":1208163,"ip_address":"","ucode":"6FA7D8FE188341","user_header":"https://static001.geekbang.org/account/avatar/00/12/6f/63/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1535723920,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1535723920","product_id":100006701,"comment_content":"双检锁中的锁已经保证了创建对象操作的原子性，为什么会用volatile来避免别的线程get到未完全初始化的对象呢？如果带锁都不能保证对对象创建完毕，在平常开发中，除了单利模式，怎么没见人对这种情况用volatile呢。这个问题我想了好久，峰哥能解答一下吗","like_count":0},{"had_liked":false,"id":18942,"user_name":"July","can_delete":false,"product_type":"c1","uid":1005384,"ip_address":"","ucode":"553873BE26CDA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/48/3da605c6.jpg","comment_is_top":false,"comment_ctime":1533611661,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1533611661","product_id":100006701,"comment_content":"老师好，在双重锁检验的实现单例模式的方式中，类变量的声明有必要加上final 吗？我的jdk版本是jdk1.8.0_102，RunTime的声明是private static 的","like_count":0},{"had_liked":false,"id":18484,"user_name":"卡萨布兰卡","can_delete":false,"product_type":"c1","uid":1137379,"ip_address":"","ucode":"0A4C8E99BA6E83","user_header":"https://static001.geekbang.org/account/avatar/00/11/5a/e3/dec478ac.jpg","comment_is_top":false,"comment_ctime":1533362763,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1533362763","product_id":100006701,"comment_content":"角色登录的那个问题，感觉可以返回前端权限树，这样也不用担心新增角色每次都要判断的问题，不过这不是什么设计模式","like_count":0},{"had_liked":false,"id":15504,"user_name":"刘杰","can_delete":false,"product_type":"c1","uid":1106503,"ip_address":"","ucode":"4B91701B322624","user_header":"https://static001.geekbang.org/account/avatar/00/10/e2/47/e910afec.jpg","comment_is_top":false,"comment_ctime":1531240348,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1531240348","product_id":100006701,"comment_content":"老师，我有个疑问，单例那里可否不用volatile，初始化时<br>Singleton  temp=new Singleton();<br>this.singleton=temp;<br>这样能保证初始化完成才赋值吗？","like_count":0},{"had_liked":false,"id":11684,"user_name":"锐","can_delete":false,"product_type":"c1","uid":1110915,"ip_address":"","ucode":"A245BA96C9471F","user_header":"https://static001.geekbang.org/account/avatar/00/10/f3/83/e2612d81.jpg","comment_is_top":false,"comment_ctime":1528292268,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1528292268","product_id":100006701,"comment_content":"设计模式也不是银弹，要避免滥用或者过度设计。这句话深有体会，为了使用设计模式而使用，有时很头疼","like_count":0},{"had_liked":false,"id":11645,"user_name":"雷霹雳的爸爸","can_delete":false,"product_type":"c1","uid":1119490,"ip_address":"","ucode":"99BBA6D83DD11F","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/02/66f65388.jpg","comment_is_top":false,"comment_ctime":1528259610,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1528259610","product_id":100006701,"comment_content":"单态这里有一个问题问老师，如果不用double check的话，仅在声明静态成员的同时即实例化之，那么是否就不用volatile关键字修饰这个字段了？为什么？","like_count":0,"discussions":[{"author":{"id":1018801,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/b1/7733d636.jpg","nickname":"超百","note":"","ucode":"77FD8CB5C5F622","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":101818,"discussion_content":"应该是因为静态变量类加载的时候就初始化好了，不会出现像dck中有线程获取到空的引用的情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577292092,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}