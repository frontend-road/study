{"id":108512,"title":"20 | 多线程开发消费者实例","content":"<p>你好，我是胡夕。今天我们来聊聊Kafka Java Consumer端多线程消费的实现方案。</p><p>目前，计算机的硬件条件已经大大改善，即使是在普通的笔记本电脑上，多核都已经是标配了，更不用说专业的服务器了。如果跑在强劲服务器机器上的应用程序依然是单线程架构，那实在是有点暴殄天物了。不过，Kafka Java Consumer就是单线程的设计，你是不是感到很惊讶。所以，探究它的多线程消费方案，就显得非常必要了。</p><h2>Kafka Java Consumer设计原理</h2><p>在开始探究之前，我先简单阐述下Kafka Java Consumer为什么采用单线程的设计。了解了这一点，对我们后面制定多线程方案大有裨益。</p><p>谈到Java Consumer API，最重要的当属它的入口类KafkaConsumer了。我们说KafkaConsumer是单线程的设计，严格来说这是不准确的。因为，从Kafka 0.10.1.0版本开始，KafkaConsumer就变为了双线程的设计，即<strong>用户主线程和心跳线程</strong>。</p><p><strong>所谓用户主线程，就是你启动Consumer应用程序main方法的那个线程，而新引入的心跳线程（Heartbeat Thread）只负责定期给对应的Broker机器发送心跳请求，以标识消费者应用的存活性（liveness）</strong>。引入这个心跳线程还有一个目的，那就是期望它能将心跳频率与主线程调用KafkaConsumer.poll方法的频率分开，从而解耦真实的消息处理逻辑与消费者组成员存活性管理。</p><!-- [[[read_end]]] --><p>不过，虽然有心跳线程，但实际的消息获取逻辑依然是在用户主线程中完成的。因此，在消费消息的这个层面上，我们依然可以安全地认为KafkaConsumer是单线程的设计。</p><p>其实，在社区推出Java Consumer API之前，Kafka中存在着一组统称为Scala Consumer的API。这组API，或者说这个Consumer，也被称为老版本Consumer，目前在新版的Kafka代码中已经被完全移除了。</p><p>我之所以重提旧事，是想告诉你，老版本Consumer是多线程的架构，每个Consumer实例在内部为所有订阅的主题分区创建对应的消息获取线程，也称Fetcher线程。老版本Consumer同时也是阻塞式的（blocking），Consumer实例启动后，内部会创建很多阻塞式的消息获取迭代器。但在很多场景下，Consumer端是有非阻塞需求的，比如在流处理应用中执行过滤（filter）、连接（join）、分组（group by）等操作时就不能是阻塞式的。基于这个原因，社区为新版本Consumer设计了单线程+轮询的机制。这种设计能够较好地实现非阻塞式的消息获取。</p><p>除此之外，单线程的设计能够简化Consumer端的设计。Consumer获取到消息后，处理消息的逻辑是否采用多线程，完全由你决定。这样，你就拥有了把消息处理的多线程管理策略从Consumer端代码中剥离的权利。</p><p>另外，不论使用哪种编程语言，单线程的设计都比较容易实现。相反，并不是所有的编程语言都能够很好地支持多线程。从这一点上来说，单线程设计的Consumer更容易移植到其他语言上。毕竟，Kafka社区想要打造上下游生态的话，肯定是希望出现越来越多的客户端的。</p><h2>多线程方案</h2><p>了解了单线程的设计原理之后，我们来具体分析一下KafkaConsumer这个类的使用方法，以及如何推演出对应的多线程方案。</p><p>首先，我们要明确的是，KafkaConsumer类不是线程安全的(thread-safe)。所有的网络I/O处理都是发生在用户主线程中，因此，你在使用过程中必须要确保线程安全。简单来说，就是你不能在多个线程中共享同一个KafkaConsumer实例，否则程序会抛出ConcurrentModificationException异常。</p><p>当然了，这也不是绝对的。KafkaConsumer中有个方法是例外的，它就是<strong>wakeup()</strong>，你可以在其他线程中安全地调用<strong>KafkaConsumer.wakeup()</strong>来唤醒Consumer。</p><p>鉴于KafkaConsumer不是线程安全的事实，我们能够制定两套多线程方案。</p><p>1.<strong>消费者程序启动多个线程，每个线程维护专属的KafkaConsumer实例，负责完整的消息获取、消息处理流程</strong>。如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/d9/40/d921a79085ef214byy50d7f94cde7a40.jpg?wh=3778*1735\" alt=\"\"></p><p>2.<strong>消费者程序使用单或多线程获取消息，同时创建多个消费线程执行消息处理逻辑</strong>。获取消息的线程可以是一个，也可以是多个，每个线程维护专属的KafkaConsumer实例，处理消息则交由<strong>特定的线程池</strong>来做，从而实现消息获取与消息处理的真正解耦。具体架构如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/02/bb/02b7945cab3c2a574d8a49e1a9927dbb.jpg?wh=3872*2122\" alt=\"\"></p><p>总体来说，这两种方案都会创建多个线程，这些线程都会参与到消息的消费过程中，但各自的思路是不一样的。</p><p>我们来打个比方。比如一个完整的消费者应用程序要做的事情是1、2、3、4、5，那么方案1的思路是<strong>粗粒度化</strong>的工作划分，也就是说方案1会创建多个线程，每个线程完整地执行1、2、3、4、5，以实现并行处理的目标，它不会进一步分割具体的子任务；而方案2则更<strong>细粒度化</strong>，它会将1、2分割出来，用单线程（也可以是多线程）来做，对于3、4、5，则用另外的多个线程来做。</p><p>这两种方案孰优孰劣呢？应该说是各有千秋。我总结了一下这两种方案的优缺点，我们先来看看下面这张表格。</p><p><img src=\"https://static001.geekbang.org/resource/image/84/0c/84dc0edb73f203b55808b33ca004670c.jpg?wh=3927*1716\" alt=\"\"></p><p>接下来，我来具体解释一下表格中的内容。</p><p>我们先看方案1，它的优势有3点。</p><ol>\n<li>实现起来简单，因为它比较符合目前我们使用Consumer API的习惯。我们在写代码的时候，使用多个线程并在每个线程中创建专属的KafkaConsumer实例就可以了。</li>\n<li>多个线程之间彼此没有任何交互，省去了很多保障线程安全方面的开销。</li>\n<li>由于每个线程使用专属的KafkaConsumer实例来执行消息获取和消息处理逻辑，因此，Kafka主题中的每个分区都能保证只被一个线程处理，这样就很容易实现分区内的消息消费顺序。这对在乎事件先后顺序的应用场景来说，是非常重要的优势。</li>\n</ol><p>说完了方案1的优势，我们来看看这个方案的不足之处。</p><ol>\n<li>每个线程都维护自己的KafkaConsumer实例，必然会占用更多的系统资源，比如内存、TCP连接等。在资源紧张的系统环境中，方案1的这个劣势会表现得更加明显。</li>\n<li>这个方案能使用的线程数受限于Consumer订阅主题的总分区数。我们知道，在一个消费者组中，每个订阅分区都只能被组内的一个消费者实例所消费。假设一个消费者组订阅了100个分区，那么方案1最多只能扩展到100个线程，多余的线程无法分配到任何分区，只会白白消耗系统资源。当然了，这种扩展性方面的局限可以被多机架构所缓解。除了在一台机器上启用100个线程消费数据，我们也可以选择在100台机器上分别创建1个线程，效果是一样的。因此，如果你的机器资源很丰富，这个劣势就不足为虑了。</li>\n<li>每个线程完整地执行消息获取和消息处理逻辑。一旦消息处理逻辑很重，造成消息处理速度慢，就很容易出现不必要的Rebalance，从而引发整个消费者组的消费停滞。这个劣势你一定要注意。我们之前讨论过如何避免Rebalance，如果你不记得的话，可以回到专栏第17讲复习一下。</li>\n</ol><p>下面我们来说说方案2。</p><p>与方案1的粗粒度不同，方案2将任务切分成了<strong>消息获取</strong>和<strong>消息处理</strong>两个部分，分别由不同的线程处理它们。比起方案1，方案2的最大优势就在于它的<strong>高伸缩性</strong>，就是说我们可以独立地调节消息获取的线程数，以及消息处理的线程数，而不必考虑两者之间是否相互影响。如果你的消费获取速度慢，那么增加消费获取的线程数即可；如果是消息的处理速度慢，那么增加Worker线程池线程数即可。</p><p>不过，这种架构也有它的缺陷。</p><ol>\n<li>它的实现难度要比方案1大得多，毕竟它有两组线程，你需要分别管理它们。</li>\n<li>因为该方案将消息获取和消息处理分开了，也就是说获取某条消息的线程不是处理该消息的线程，因此无法保证分区内的消费顺序。举个例子，比如在某个分区中，消息1在消息2之前被保存，那么Consumer获取消息的顺序必然是消息1在前，消息2在后，但是，后面的Worker线程却有可能先处理消息2，再处理消息1，这就破坏了消息在分区中的顺序。还是那句话，如果你在意Kafka中消息的先后顺序，方案2的这个劣势是致命的。</li>\n<li>方案2引入了多组线程，使得整个消息消费链路被拉长，最终导致正确位移提交会变得异常困难，结果就是可能会出现消息的重复消费。如果你在意这一点，那么我不推荐你使用方案2。</li>\n</ol><h2>实现代码示例</h2><p>讲了这么多纯理论的东西，接下来，我们来看看实际的实现代码大概是什么样子。毕竟，就像Linus说的：“Talk is cheap, show me the code!”</p><p>我先跟你分享一段方案1的主体代码：</p><pre><code>public class KafkaConsumerRunner implements Runnable {\n     private final AtomicBoolean closed = new AtomicBoolean(false);\n     private final KafkaConsumer consumer;\n\n\n     public void run() {\n         try {\n             consumer.subscribe(Arrays.asList(&quot;topic&quot;));\n             while (!closed.get()) {\n\t\t\tConsumerRecords records = \n\t\t\t\tconsumer.poll(Duration.ofMillis(10000));\n                 //  执行消息处理逻辑\n             }\n         } catch (WakeupException e) {\n             // Ignore exception if closing\n             if (!closed.get()) throw e;\n         } finally {\n             consumer.close();\n         }\n     }\n\n\n     // Shutdown hook which can be called from a separate thread\n     public void shutdown() {\n         closed.set(true);\n         consumer.wakeup();\n     }\n</code></pre><p>这段代码创建了一个Runnable类，表示执行消费获取和消费处理的逻辑。每个KafkaConsumerRunner类都会创建一个专属的KafkaConsumer实例。在实际应用中，你可以创建多个KafkaConsumerRunner实例，并依次执行启动它们，以实现方案1的多线程架构。</p><p>对于方案2来说，核心的代码是这样的：</p><pre><code>private final KafkaConsumer&lt;String, String&gt; consumer;\nprivate ExecutorService executors;\n...\n\n\nprivate int workerNum = ...;\nexecutors = new ThreadPoolExecutor(\n\tworkerNum, workerNum, 0L, TimeUnit.MILLISECONDS,\n\tnew ArrayBlockingQueue&lt;&gt;(1000), \n\tnew ThreadPoolExecutor.CallerRunsPolicy());\n\n\n...\nwhile (true)  {\n\tConsumerRecords&lt;String, String&gt; records = \n\t\tconsumer.poll(Duration.ofSeconds(1));\n\tfor (final ConsumerRecord record : records) {\n\t\texecutors.submit(new Worker(record));\n\t}\n}\n..\n</code></pre><p>这段代码最重要的地方是最后一行：当Consumer的poll方法返回消息后，由专门的线程池来负责处理具体的消息。调用poll方法的主线程不负责消息处理逻辑，这样就实现了方案2的多线程架构。</p><h2>小结</h2><p>总结一下，今天我跟你分享了Kafka Java Consumer多线程消费的实现方案。我给出了比较通用的两种方案，并介绍了它们各自的优缺点以及代码示例。我希望你能根据这些内容，结合你的实际业务场景，实现适合你自己的多线程架构，真正做到举一反三、融会贯通，彻底掌握多线程消费的精髓，从而在日后实现更宏大的系统。</p><p><img src=\"https://static001.geekbang.org/resource/image/8e/b1/8e3ca3a977b7ee373878b732be6646b1.jpg?wh=2069*2569\" alt=\"\"></p><h2>开放讨论</h2><p>今天我们讨论的都是多线程的方案，可能有人会说，何必这么麻烦，我直接启动多个Consumer进程不就得了？那么，请你比较一下多线程方案和多进程方案，想一想它们各自的优劣之处。</p><p>欢迎写下你的思考和答案，我们一起讨论。如果你觉得有所收获，也欢迎把文章分享给你的朋友。</p>","comments":[{"had_liked":false,"id":114815,"user_name":"yhh","can_delete":false,"product_type":"c1","uid":1105102,"ip_address":"","ucode":"B566981788B6A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/dc/ce/a144dea1.jpg","comment_is_top":false,"comment_ctime":1563411796,"is_pvip":false,"discussion_count":18,"race_medal":0,"score":"319390991700","product_id":100029201,"comment_content":"希望老师能讲讲方案2下线程池怎么管理和提交位移！！","like_count":75,"discussions":[{"author":{"id":1101496,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ce/b8/92178ccd.jpg","nickname":"ECHO","note":"","ucode":"E78B3B557D469C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2410,"discussion_content":"老师说别为难我","likes_number":21,"is_delete":false,"is_hidden":false,"ctime":1563547441,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1144568,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/f8/66e25be4.jpg","nickname":"maslke","note":"","ucode":"16AF7647266C14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6962,"discussion_content":"感觉应该是需要利用类似latch这种组件，几个线程都处理完之后，一次提交","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1567223543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1009652,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","nickname":"钱","note":"","ucode":"2C92A243A463D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5190,"discussion_content":"能说说这个感觉才到核心上","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1566035625,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1139455,"avatar":"https://static001.geekbang.org/account/avatar/00/11/62/ff/f71034e9.jpg","nickname":"悟空WuKong","note":"","ucode":"49AFD2B048C1BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":198200,"discussion_content":"1、消息放在数据库或者redis这种不会丢失的队列中，多线程消费队列\n2、使用闭锁工具，多个线程处理完毕之后再提交位移。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1583487191,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1105102,"avatar":"https://static001.geekbang.org/account/avatar/00/10/dc/ce/a144dea1.jpg","nickname":"yhh","note":"","ucode":"B566981788B6A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1139455,"avatar":"https://static001.geekbang.org/account/avatar/00/11/62/ff/f71034e9.jpg","nickname":"悟空WuKong","note":"","ucode":"49AFD2B048C1BA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":198249,"discussion_content":"1、消息放在数据库、redis的话，感觉已经失去使用消息中间件的初衷了\n2、使用闭锁的话，一旦有一条消息消费慢，那整个线程池会卡住假死，而且线程等待的时间也是很浪费，吞吐能力不行\n其实，大家可以看下rocketmq的并发消费者客户端实现，已经提供了一种解决方案。","likes_number":12,"is_delete":false,"is_hidden":false,"ctime":1583493984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":198200,"ip_address":""},"score":198249,"extra":""},{"author":{"id":2165300,"avatar":"https://static001.geekbang.org/account/avatar/00/21/0a/34/3e29eb5a.jpg","nickname":"尚小树","note":"","ucode":"9BCB0DF0F3C8E4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1105102,"avatar":"https://static001.geekbang.org/account/avatar/00/10/dc/ce/a144dea1.jpg","nickname":"yhh","note":"","ucode":"B566981788B6A2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307917,"discussion_content":"我理解如果是方案二用多线程去消费，很难保证offset提交完全正确，那如果在这种情况下，我们要么认丢，要么认重，总要选一个。如果拉取完消息不管处理结果就提交那有可能会丢，如果处理一个提交一个那有可能会重复。悟空兄怎么看？","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1600786653,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":198249,"ip_address":""},"score":307917,"extra":""}]},{"author":{"id":1008582,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/c6/d6ea3df3.jpg","nickname":"林肯","note":"","ucode":"D2C97220230DE5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":25023,"discussion_content":"方案二可以这样第一个线程组poll消息并落地到db提交offset，第二个线程组读取db处理业务逻辑","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1570371398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1481811,"avatar":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","nickname":"ub8","note":"","ucode":"0D937C3EAEB781","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561950,"discussion_content":"这个课为啥这么多人订不明白了看了一遍感觉都是皮毛，讲的好多方案都是生产环境明令禁止的，真怕带沟里","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1649752472,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1525964,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/4q2nV7KcW4uf6VyzOqat7myHbX2dHnAUuCLDFsFLJE0QvtSxYMfIZ8n25yUWtqDIibeicBrvqA5dIhOYRXu98Qfg/132","nickname":"Geek_edef24","note":"","ucode":"DFB856EB9A761E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1481811,"avatar":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","nickname":"ub8","note":"","ucode":"0D937C3EAEB781","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583995,"discussion_content":"比如？刚学介绍介绍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660554133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":561950,"ip_address":"四川"},"score":583995,"extra":""}]},{"author":{"id":1764125,"avatar":"","nickname":"极客时间3","note":"","ucode":"81CCB385F27406","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":109233,"discussion_content":"自己想了一下，第二种方法是实现了数据消费和实现的解耦，数据消费完了直接提交offset就行。然后交给实现用多线程取处理，当然会导致数据顺序不一致。楼主是每次消费一批后，直接启用多线程直接处理。当然也可以把消费完的数据放到阻塞队列里，再起多线程处理。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577675616,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1277081,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7c/99/4dac6ce6.jpg","nickname":"lakeslove","note":"","ucode":"65E14D29D3C981","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1764125,"avatar":"","nickname":"极客时间3","note":"","ucode":"81CCB385F27406","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369848,"discussion_content":"消息多时，扔到线程池本身就是扔进线程池的阻塞队列","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1619172488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":109233,"ip_address":""},"score":369848,"extra":""}]},{"author":{"id":1180636,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/dc/32ef4590.jpg","nickname":"颛孙","note":"","ucode":"6ED330F5A4DBD2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585582,"discussion_content":"拉取消息的还是单线程（main线程），处理消息的是多线程（线程池），消息处理完之后，统一由main线程提交offset； 因为线程池处理消息的时候没有顺序性，所以不可能再线程池内部提交offset的；最后统一由main线程提交offset的话，可能会产生重复消息的情况，由消费端自己做幂等；","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661683388,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1030842,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ba/ba/83de3488.jpg","nickname":"Carter","note":"","ucode":"1FD476D8F2BE27","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":565764,"discussion_content":"自动提交","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650538941,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1572356,"avatar":"https://static001.geekbang.org/account/avatar/00/17/fe/04/bb427e47.jpg","nickname":"码哥字节","note":"","ucode":"362103AD52C8E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561318,"discussion_content":"老师说，差不多就行了，你就别为难我了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649599890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1271724,"avatar":"https://static001.geekbang.org/account/avatar/00/13/67/ac/af895343.jpg","nickname":"刘耳总","note":"","ucode":"6D157E6E960075","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":20117,"discussion_content":"同想问这个问题，异步处理怎么提交offset","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569278608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1263997,"avatar":"https://static001.geekbang.org/account/avatar/00/13/49/7d/7b9fd831.jpg","nickname":"Fever","note":"","ucode":"2595F13BC3ECAB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3989,"discussion_content":"下面有个兄弟好像说的不错，方案2多线程不能分批次提交，还是得等待所有的线程都处理完了再一次性提交。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565044865,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1802337,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/80/61/ae3bb67c.jpg","nickname":"毛毛虫大帝","note":"","ucode":"1EBB026121C060","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1263997,"avatar":"https://static001.geekbang.org/account/avatar/00/13/49/7d/7b9fd831.jpg","nickname":"Fever","note":"","ucode":"2595F13BC3ECAB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337824,"discussion_content":"多个批次消息做forkjoin或者latch控制整体消费 然后维护提交最新位点 或者采用维护单独位点信息 所有线程处理完会提交到这个位点信息上 然后根据最小并且连续的位点段进行提交 不连续就等待 当然会影响个别执行慢的线程阻塞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609080928,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3989,"ip_address":""},"score":337824,"extra":""}]},{"author":{"id":1263997,"avatar":"https://static001.geekbang.org/account/avatar/00/13/49/7d/7b9fd831.jpg","nickname":"Fever","note":"","ucode":"2595F13BC3ECAB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3987,"discussion_content":"hhh","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565044726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114919,"user_name":"小生向北","can_delete":false,"product_type":"c1","uid":1068933,"ip_address":"","ucode":"47DC72775B9A53","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/85/c92bcc6b.jpg","comment_is_top":false,"comment_ctime":1563433580,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"169067158124","product_id":100029201,"comment_content":"能够用多线程解决的就不要用多进程，毕竟资源有限。方案2的讲解还是太浅了，同希望老师能针对方案2详细讲解一下！方案2里面在异步线程里提交offset，每个线程自己提交自己的，如果中间有offset提交失败，后面的offset又提交成功了咋办呢？而且每个线程都自己提交consumer.commit()就意味着要在多个线程里面使用consumer，如文中所说，这种情况是要报CME错误的，那究竟该如何正确的提交呢，有没有最佳实践呀？","like_count":40,"discussions":[{"author":{"id":1181578,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/8a/4bef6202.jpg","nickname":"大叮当","note":"","ucode":"418EEFBD0C5A85","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378949,"discussion_content":"老师表示你们别为难我","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1623554934,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1881153,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/b4/41/82ac102c.jpg","nickname":"Geek","note":"","ucode":"740790D3686F8E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350818,"discussion_content":"对对，我现在就遇到使用方案二数据丢失的问题，希望老师解答最佳实践","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1614038981,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1277081,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7c/99/4dac6ce6.jpg","nickname":"lakeslove","note":"","ucode":"65E14D29D3C981","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369851,"discussion_content":"使用circleBarrier或者catdownLaunch(因为线程池的获取任务数量的方法返回的不是精确值，而且没有阻塞等待功能)，消息全部处理完毕后，主线程提交位移。\n其中在子线程里处理失败的消息扔进私信队列，防止消息丢失。\n每个消息的处理做成幂等性，防止消息重复消费（至于如何做幂等性，可以使用redis或数据库记录已经处理过的消息序号）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619173345,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1668117,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJLgibqHsl97Oq3nvnEVz7V3kaGKLmia0Ja8c4yXO7QeLKiakganRJomNGgYToW4RnFs60zibDTHicjE5w/132","nickname":"学而不思则惘","note":"","ucode":"8ED2B08AA5A755","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1277081,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7c/99/4dac6ce6.jpg","nickname":"lakeslove","note":"","ucode":"65E14D29D3C981","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379107,"discussion_content":"这种模式更适合CountDownLatch。CyclicBarrier要做这种同步的话那他内置的Condition会阻塞线程池里的线程，消息数量多了，可能线程池都不够用。用Latch的话只需要阻塞主线程，Latch的参数可以根据consumer的api来拿到，大小就为每次poll拿到消息的总条数，每次消费需要初始化一个latch。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1623685418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":369851,"ip_address":""},"score":379107,"extra":""}]}]},{"had_liked":false,"id":115041,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1563460131,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"104642675235","product_id":100029201,"comment_content":"老师能否加餐spring-kafka相关知识","like_count":25,"discussions":[{"author":{"id":1339409,"avatar":"https://static001.geekbang.org/account/avatar/00/14/70/11/42cf8f9d.jpg","nickname":"chenjia","note":"","ucode":"61983C29FF4987","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367232,"discussion_content":"超出了本课程的范畴了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618301401,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134861,"avatar":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","nickname":"James","note":"","ucode":"48B0F2A334D1C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":279858,"discussion_content":"百度应该有吧.java kafka客户端应该都是类似的吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591436063,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114796,"user_name":"james","can_delete":false,"product_type":"c1","uid":1049208,"ip_address":"","ucode":"5701899403917C","user_header":"https://static001.geekbang.org/account/avatar/00/10/02/78/23c56bce.jpg","comment_is_top":false,"comment_ctime":1563409664,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"104642624768","product_id":100029201,"comment_content":"方案2最核心的如何commit老师没有说，难道只能启用自动提交吗？我觉得可以用Cyclicbarrier来实现线程池执行完毕后，由consumer来commit，不用countdownlatch因为它只能记录一次，而cb可以反复用，或者用forkjoin方式，总之要等待多线程都处理完才能commit，风险就是某个消息处理太慢回导致整体都不能commit，而触发rebalance以及重复消费，而重复消费我用布隆过滤器来解决","like_count":24,"discussions":[{"author":{"id":1668117,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJLgibqHsl97Oq3nvnEVz7V3kaGKLmia0Ja8c4yXO7QeLKiakganRJomNGgYToW4RnFs60zibDTHicjE5w/132","nickname":"学而不思则惘","note":"","ucode":"8ED2B08AA5A755","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379110,"discussion_content":"理想化了，用CyclicBarrier的话，每次拉取消息的数量不同的话，那你barrier重复利用后阻塞的线程怎么办，就因为每次拉取消息的数量不同，只能每次拉取都初始化一个同步器，相对于barrier阻塞多条线程，我更倾向于latch只需要阻塞主线程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623685736,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1668117,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJLgibqHsl97Oq3nvnEVz7V3kaGKLmia0Ja8c4yXO7QeLKiakganRJomNGgYToW4RnFs60zibDTHicjE5w/132","nickname":"学而不思则惘","note":"","ucode":"8ED2B08AA5A755","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382742,"discussion_content":"用latch的话每次poll的数量不一样的话count怎么定？ 每次new 的CountDownLatch中count数量和poll的数量一样吗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1625710715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":379110,"ip_address":""},"score":382742,"extra":""},{"author":{"id":2642315,"avatar":"","nickname":"Geek_c695c1","note":"","ucode":"FC2AD53F54582D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388746,"discussion_content":"你俩说的同一个问题，但是Cyclicbarrier，CountDownLatch都没解决 哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628933406,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":382742,"ip_address":""},"score":388746,"extra":""},{"author":{"id":1668117,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJLgibqHsl97Oq3nvnEVz7V3kaGKLmia0Ja8c4yXO7QeLKiakganRJomNGgYToW4RnFs60zibDTHicjE5w/132","nickname":"学而不思则惘","note":"","ucode":"8ED2B08AA5A755","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390593,"discussion_content":"records的size是能获取到的，size的数量不就是latch的数量？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629906553,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":382742,"ip_address":""},"score":390593,"extra":""}]}]},{"had_liked":false,"id":148162,"user_name":"注定非凡","can_delete":false,"product_type":"c1","uid":1113597,"ip_address":"","ucode":"80673056E131B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","comment_is_top":false,"comment_ctime":1572953370,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"96062233882","product_id":100029201,"comment_content":"A ：Kafka Java Consumer是单线程设计原理。<br>\t（1）在Kafka从0.10.1.0版本开始，KafkaConsumer就变成双线程设计即：用户主线程和心跳线程。<br>\t（2）主线程是指：启动Consumer应用程序main方法的那个线程，而新引入的心跳线程只负责定期给对应的Broker机器发送心跳请求，以标识消费者应用的存活性。<br><br>\t（2）老版本中有Scala Consumer的API，是多线程架构的，每个Consumer实例在内部为所有订阅的主题分区创建对应消息获取线程，也称为Fetcher线程。老版本Consumer同时也是阻塞式的（blocking），Consumer实例启动后，内部会创建很多阻塞式的消息迭代器。<br>（3）在很多场景下，Consumer端是有非阻塞需求的，如流处理应用中执行过滤（filter），连接（join），分组（group by）等操作时就不能是阻塞式的。<br>\t所以，新版本Consumer设计了单线程+轮询的机制。这种设计能够较好的实现非阻塞式的消息获取。<br><br>B ：单线程设计优点<br>\t（1）单线程可以较好的实现如在流处理应用中执行过滤（filter），连接（join）,分组（group by）等操作。<br>\t（2）单线程能够简化Consumer端设计。Consumer端获取到消息后，处理消息的逻辑是否采用多线程，由自己决定。<br>\t（3）单线程设计在很多种编程中都比较易于实现，编译社区移植。<br><br>C ：多线程方案<br>\t（1）KafkaConsumer类不是线程安全的（thread-safe）。所有的网络I&#47;O处理都是发生在用户主线程中，所以不能在多线程中共享同一个KafkaConsumer实例，否则程序会抛ConcurrentModificationException异常。<br>\t<br>\t（2）方案一：<br>\t\t消费者程序启动多个线程，每个线程维护专属的KafkaConsumer实例，负责完整的消息获取，消息处理流程。<br>\t\t优点：<br>\t\t\t方便实现，速度快，无线程间交互开销，易于维护分区的消息顺序<br>\t\t缺点：<br>\t\t\t占用更多的系统资源，线程数受限于主题分区数，扩展性差。线程自己处理消息容易超时，进而引发Rebalance。<br>\t<br>\t（3）方案二：<br>\t\t消费者程序使用单或多线程获取消息，同时创建多个消费线程执行消息处理逻辑。获取消息的线程可以是多个，每个线程维护专属的KafkaConsumer实例，处理消息则交由特定的线程池来做。<br>\t\t优点：<br>\t\t\t可独立扩展消费获取线程数和worker线程数，伸缩性好<br>\t\t缺点：<br>\t\t\t难以维护分区内的消息消费顺序，处理链路拉长，不易于位移提交管理，实现难度高。<br>","like_count":21},{"had_liked":false,"id":114844,"user_name":"calljson","can_delete":false,"product_type":"c1","uid":1505262,"ip_address":"","ucode":"A5F81A6A5B4497","user_header":"https://static001.geekbang.org/account/avatar/00/16/f7/ee/6eeb58a3.jpg","comment_is_top":false,"comment_ctime":1563415453,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"91757728669","product_id":100029201,"comment_content":"希望老师能对比spring-kafka源码，关于多线程管理consumer谢谢","like_count":22},{"had_liked":false,"id":115564,"user_name":"千屿","can_delete":false,"product_type":"c1","uid":1339010,"ip_address":"","ucode":"825ABAA910EA82","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/82/b058eca5.jpg","comment_is_top":false,"comment_ctime":1563628741,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"87462974661","product_id":100029201,"comment_content":"最近用spring cloud做了一个kafka可靠消息微服务组件，有兴趣的朋友可以看看 ，消费端是多线程模型，消费线程和业务执行分离，使用了mongodb(分片+副本集) 存储消息发送的链路，对发送失败的消息做了补偿机制。https:&#47;&#47;gitee.com&#47;huacke&#47;mq-kafka，有问题可以联系我。","like_count":20},{"had_liked":false,"id":156096,"user_name":"寂静欢喜","can_delete":false,"product_type":"c1","uid":1191287,"ip_address":"","ucode":"6728A2BA364729","user_header":"https://static001.geekbang.org/account/avatar/00/12/2d/77/e5d4221b.jpg","comment_is_top":false,"comment_ctime":1574819128,"is_pvip":false,"replies":[{"id":"60091","content":"应该这么说，心跳线程会定期地检查前端线程是否卡住了，一旦发现卡住了，便会发起主动离组。","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1574903749,"ip_address":"","comment_id":156096,"utype":1}],"discussion_count":3,"race_medal":0,"score":"83179197752","product_id":100029201,"comment_content":"老师 想问下 心跳线程是和主线程分开的，那么 第一种方案中，主线程阻塞，又怎么会导致超时Rebalance呢？","like_count":19,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475983,"discussion_content":"应该这么说，心跳线程会定期地检查前端线程是否卡住了，一旦发现卡住了，便会发起主动离组。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574903749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1116807,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0a/87/56b07589.jpg","nickname":"nearzk","note":"","ucode":"CDEA6841E5F54C","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361655,"discussion_content":"这里很重要啊，为啥文章中不提呢？我就是专门来评论区找这个问题的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1616723620,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1736462,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/7f/0e/e3a8dbd9.jpg","nickname":"Liujun","note":"","ucode":"3DB1F3CA57B5B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390234,"discussion_content":"难怪了，终于解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629723543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114784,"user_name":"玉剑冰锋","can_delete":false,"product_type":"c1","uid":1214202,"ip_address":"","ucode":"8EA56A71BA5B22","user_header":"https://static001.geekbang.org/account/avatar/00/12/86/fa/4bcd7365.jpg","comment_is_top":false,"comment_ctime":1563407497,"is_pvip":false,"replies":[{"id":"42095","content":"有可能是要加载的日志段数据太多导致的，可以增加num.recovery.threads.per.data.dir的值","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1563517716,"ip_address":"","comment_id":114784,"utype":1}],"discussion_count":4,"race_medal":0,"score":"78872818825","product_id":100029201,"comment_content":"Kafka重启时间比较长，每次重启一台差不多四五十分钟，日志保存12个小时，每台数据量差不多几个T，想请教一下老师有什么可以优化的参数吗？","like_count":18,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458812,"discussion_content":"有可能是要加载的日志段数据太多导致的，可以增加num.recovery.threads.per.data.dir的值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563517716,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1006735,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5c/8f/551b5624.jpg","nickname":"小可","note":"","ucode":"8834AF621FA67D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2246,"discussion_content":"我之前工作有遇到过类似情况，不知道是不是相同原因\n查看kafka重启后的日志，是不是一直在扫描各个topic的分区offset。如果是的话，可能是你用的低版本，重启时先关闭的zookeeper，后关闭的kafka，低版本的offset在zookeeper上，重启后要重新扫描，正确的是：\n启动顺序，zookeeper、kafka\n关闭顺序，kafka、zookeeper\n\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1563410888,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1527666,"avatar":"","nickname":"wgcris","note":"","ucode":"842B76EB6B8320","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1006735,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5c/8f/551b5624.jpg","nickname":"小可","note":"","ucode":"8834AF621FA67D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56818,"discussion_content":"高版本也会遇到这个问题，如果broker是非正常关闭，在数据量很大的情况下重启会非常耗时，因为他会在启动的时候扫描所有的segment，时间相当长","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1574517468,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2246,"ip_address":""},"score":56818,"extra":""}]},{"author":{"id":1527666,"avatar":"","nickname":"wgcris","note":"","ucode":"842B76EB6B8320","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56816,"discussion_content":"这个问题我也遇到了，目前调整线程数大小这种方式不能很好的解决这个问题，你现在解决这个问题了吗？求指导","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574517336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":116153,"user_name":"来碗绿豆汤","can_delete":false,"product_type":"c1","uid":1070051,"ip_address":"","ucode":"B0AB63B8D9729F","user_header":"https://static001.geekbang.org/account/avatar/00/10/53/e3/39dcfb11.jpg","comment_is_top":false,"comment_ctime":1563794363,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"65988303803","product_id":100029201,"comment_content":"对于第二种方案，可以添加一个共享的队列，消费线程消费完一个记录，就写入队列，然后主线程可以读取这个队列，然后依次提交小号的offset","like_count":14,"discussions":[{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382745,"discussion_content":"这个主线程和poll的线程是一个线程吧，不然的队列线程是另一个线程提交不了吧，如果是这样的话那主线程串行poll数据和消费数据？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625710953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177756,"user_name":"yic","can_delete":false,"product_type":"c1","uid":1201577,"ip_address":"","ucode":"C8DC471B7C28B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/55/a9/5282a560.jpg","comment_is_top":false,"comment_ctime":1581491778,"is_pvip":false,"replies":[{"id":"69054","content":"最好的办法就是自己完全实现一套多线程+管理offset的方案，就像Spark Streaming和Flink做的那样。有兴趣的话可以阅读以下Flink中Kafka Connector的源代码：）","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1581560837,"ip_address":"","comment_id":177756,"utype":1}],"discussion_count":2,"race_medal":0,"score":"35941230146","product_id":100029201,"comment_content":"老师，关于方案2中的做法，位移提交是有重复消费消息和丢失数据的风险的，有没有什么好的实践呀？","like_count":8,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483524,"discussion_content":"最好的办法就是自己完全实现一套多线程+管理offset的方案，就像Spark Streaming和Flink做的那样。有兴趣的话可以阅读以下Flink中Kafka Connector的源代码：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581560837,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1201577,"avatar":"https://static001.geekbang.org/account/avatar/00/12/55/a9/5282a560.jpg","nickname":"yic","note":"","ucode":"C8DC471B7C28B8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":169638,"discussion_content":"好的，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581638446,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115558,"user_name":"z.l","can_delete":false,"product_type":"c1","uid":1181055,"ip_address":"","ucode":"805CC5784D3F76","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/7f/d35ab9a1.jpg","comment_is_top":false,"comment_ctime":1563624363,"is_pvip":false,"replies":[{"id":"42308","content":"理论上是48，但实际上这么多线程反而是开销，可以采用多进程的方式","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1563752657,"ip_address":"","comment_id":115558,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35923362731","product_id":100029201,"comment_content":"请教个问题，如果使用方案1，一个consumer group订阅了2个topic，每个topic都是24个分区，此时最大线程数可以设置为24还是48？","like_count":8,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459161,"discussion_content":"理论上是48，但实际上这么多线程反而是开销，可以采用多进程的方式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563752657,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115143,"user_name":"KEEPUP","can_delete":false,"product_type":"c1","uid":1436576,"ip_address":"","ucode":"D0B31031E2923F","user_header":"https://static001.geekbang.org/account/avatar/00/15/eb/a0/9d294a9a.jpg","comment_is_top":false,"comment_ctime":1563499748,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31628270820","product_id":100029201,"comment_content":"希望老师讲一下sparkstreaming 消费kafka 消息的情况","like_count":7},{"had_liked":false,"id":158529,"user_name":"飞翔","can_delete":false,"product_type":"c1","uid":1068571,"ip_address":"","ucode":"65AF6AF292DAD6","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/1b/f4b786b9.jpg","comment_is_top":false,"comment_ctime":1575398271,"is_pvip":true,"replies":[{"id":"60681","content":"“谁负责分配线程给每个partition呀” --- leader consumer负责分配。<br><br>会均匀分配的，这是kafka consumer代码保证的","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1575423759,"ip_address":"","comment_id":158529,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27345202047","product_id":100029201,"comment_content":"老师 想问一个方案1  谁负责分配线程给每个partition呀 我看您的code 只是没产生一个线程去消费一个主题 如果我有4个parition  那么我产生4个线程来消费这个主题，他会自动均匀分配嘛","like_count":6,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476758,"discussion_content":"“谁负责分配线程给每个partition呀” --- leader consumer负责分配。\n\n会均匀分配的，这是kafka consumer代码保证的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575423759,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218614,"user_name":"张洋","can_delete":false,"product_type":"c1","uid":1182914,"ip_address":"","ucode":"549BE5DEEF8417","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/c2/bad34a50.jpg","comment_is_top":false,"comment_ctime":1589845988,"is_pvip":true,"replies":[{"id":"80797","content":"取决于consumer instance是线程还是进程。通常情况下如果consumer instance是进程的话，还是可以使用多个线程来消费这个获取到的数据。","user_name":"作者回复","user_name_real":"胡夕","uid":"1288090","ctime":1589850265,"ip_address":"","comment_id":218614,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23064682468","product_id":100029201,"comment_content":"老师如果当前consumer group下的consumer instance 只分配了当前主题的一个分区是不是意味着 当前也只能是一个线程来消费消息了","like_count":5,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495526,"discussion_content":"取决于consumer instance是线程还是进程。通常情况下如果consumer instance是进程的话，还是可以使用多个线程来消费这个获取到的数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589850265,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165464,"user_name":"高志强","can_delete":false,"product_type":"c1","uid":1276563,"ip_address":"","ucode":"68737002043752","user_header":"https://static001.geekbang.org/account/avatar/00/13/7a/93/c9302518.jpg","comment_is_top":false,"comment_ctime":1577240787,"is_pvip":false,"replies":[{"id":"63191","content":"可以考虑单个进程下再开多线程的方式来增强消费能力，不必一味考虑多进程的方案","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1577322040,"ip_address":"","comment_id":165464,"utype":1}],"discussion_count":4,"race_medal":0,"score":"18757109971","product_id":100029201,"comment_content":"老师我现在用Php多进程消费，一个topic 130个分区，我是不是该启动130个进程去消费，目前启动64个进程，但消费能力上不去，消息积压量有几十万了，怎么才能提高消费能力呢","like_count":4,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479169,"discussion_content":"可以考虑单个进程下再开多线程的方式来增强消费能力，不必一味考虑多进程的方案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577322040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1064894,"avatar":"https://static001.geekbang.org/account/avatar/00/10/3f/be/c7141382.jpg","nickname":"是KK呀","note":"","ucode":"5DCEB53A13D049","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":113701,"discussion_content":"PHP多线程方式不好实现吧？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577928654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1276563,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7a/93/c9302518.jpg","nickname":"高志强","note":"","ucode":"68737002043752","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1064894,"avatar":"https://static001.geekbang.org/account/avatar/00/10/3f/be/c7141382.jpg","nickname":"是KK呀","note":"","ucode":"5DCEB53A13D049","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":114497,"discussion_content":"是的，php 线程难以实现，扩展支持不好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577973232,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":113701,"ip_address":""},"score":114497,"extra":""},{"author":{"id":1519269,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/2qHhibwFEiaNWNjCqTpe8kCHqWian0rBdkulmkvVXpkr4CSOpuibVHNVozHUERAmvMDMticfycjzgwYDv6Gfav1dZ3A/132","nickname":"Geek_58a455","note":"","ucode":"C20E856D38D338","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1276563,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7a/93/c9302518.jpg","nickname":"高志强","note":"","ucode":"68737002043752","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310119,"discussion_content":"可以考虑一下是不是下游消息逻辑处理耗费时间太久了，如果下游已经无法提高速度了，那么可以考虑增加消费者数量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601628093,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":114497,"ip_address":""},"score":310119,"extra":""}]}]},{"had_liked":false,"id":165102,"user_name":"Hale","can_delete":false,"product_type":"c1","uid":1129731,"ip_address":"","ucode":"1925955343FE94","user_header":"https://static001.geekbang.org/account/avatar/00/11/3d/03/b2d9a084.jpg","comment_is_top":false,"comment_ctime":1577161297,"is_pvip":true,"replies":[{"id":"63033","content":"消费者会自动重连的，如果重连失败，说明网络有问题","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1577235501,"ip_address":"","comment_id":165102,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18757030481","product_id":100029201,"comment_content":"如果只有一个broker,一个consumer 一个分区，上面的consumer 组成一个组，一个topic 当consumer 卡住时，协调器会将消费者踢出消费组，进行重新分区分配，但只有一个消费者，那消费者就不能接受到数据了，怎样实现消费者重连","like_count":4,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479027,"discussion_content":"消费者会自动重连的，如果重连失败，说明网络有问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577235501,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162411,"user_name":"YWH","can_delete":false,"product_type":"c1","uid":1145122,"ip_address":"","ucode":"B448CCF13F2BF2","user_header":"https://static001.geekbang.org/account/avatar/00/11/79/22/58981901.jpg","comment_is_top":false,"comment_ctime":1576510987,"is_pvip":false,"replies":[{"id":"61784","content":"持续消费一部分消息缓存到本地，http接口从本地读取消息。如果长时间不拉取，consumer先pause消费","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1576543942,"ip_address":"","comment_id":162411,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18756380171","product_id":100029201,"comment_content":"老师，想请教消费者的一个问题...<br>我们的业务场景是这样的：建立一个服务接收 http 请求、根据传入的参数（topic）从 Kafka 指定 topic 拉取一定数量的消息后返回。但 Kafka 的消费者是要保持轮询的，不然就只能每次建立消费者、获取分区&#47;加入群组、请求数据后关闭消费者（但这样效率很低）。<br>请问有什么比较好又可靠的实现方法吗？谢谢~","like_count":4,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478039,"discussion_content":"持续消费一部分消息缓存到本地，http接口从本地读取消息。如果长时间不拉取，consumer先pause消费","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576543942,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143798,"user_name":"胡家鹏","can_delete":false,"product_type":"c1","uid":1109940,"ip_address":"","ucode":"1636F84062948B","user_header":"https://static001.geekbang.org/account/avatar/00/10/ef/b4/61fb4dba.jpg","comment_is_top":false,"comment_ctime":1571793479,"is_pvip":true,"replies":[{"id":"55624","content":"1. 您指哪段代码？另外如果设置了enable.auto.commit=true或没有显式设置enable.auto.commit=false，就是自动提交<br>2. wakeup主要用于唤醒polling中的consumer实例。如果你使用了多线程（即把KafkaConsumer实例用于单独的线程），你需要有能力在另一个线程中“中断”KafkaConsumer所在实例的执行。wakeup就是用这个的","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1571877920,"ip_address":"","comment_id":143798,"utype":1}],"discussion_count":4,"race_medal":0,"score":"18751662663","product_id":100029201,"comment_content":"老师及各位朋友好，问下两个问题1.上面的代码怎么没有消费位移提交，难道是设置的自动提交位移吗？2.consumer.wakeup什么时候使用，来解决什么问题呢？","like_count":4,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471694,"discussion_content":"1. 您指哪段代码？另外如果设置了enable.auto.commit=true或没有显式设置enable.auto.commit=false，就是自动提交\n2. wakeup主要用于唤醒polling中的consumer实例。如果你使用了多线程（即把KafkaConsumer实例用于单独的线程），你需要有能力在另一个线程中“中断”KafkaConsumer所在实例的执行。wakeup就是用这个的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571877920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2915549,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/7c/dd/d6614fa4.jpg","nickname":"我爱学习我爱豆芽","note":"","ucode":"8FDDC4D24D2823","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":557578,"discussion_content":"多线程中其中一个线程退出，是否会引发rebalance?\n既然自动rebalance ，为什么还需要唤醒另外的线程？\n望解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647869335,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":471694,"ip_address":""},"score":557578,"extra":""}]},{"author":{"id":1132315,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/1b/64262861.jpg","nickname":"胡小禾","note":"","ucode":"1C23B7492C0C9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263632,"discussion_content":"什么情况下，需要 从一个线程去wakeUp 另一个线程呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589215765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1736462,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/7f/0e/e3a8dbd9.jpg","nickname":"Liujun","note":"","ucode":"3DB1F3CA57B5B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1132315,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/1b/64262861.jpg","nickname":"胡小禾","note":"","ucode":"1C23B7492C0C9E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390235,"discussion_content":"在你需要主动调整消费者实例个数的时候","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629724140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":263632,"ip_address":""},"score":390235,"extra":""}]}]},{"had_liked":false,"id":114816,"user_name":"Xiao","can_delete":false,"product_type":"c1","uid":1179212,"ip_address":"","ucode":"71FFCCEEDE09E1","user_header":"https://static001.geekbang.org/account/avatar/00/11/fe/4c/46eb517a.jpg","comment_is_top":false,"comment_ctime":1563411839,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"18743281023","product_id":100029201,"comment_content":"胡老师，第二种方案我觉得还有个问题就是如果是自动提交，那就会容易出现消息丢失，因为异步消费消息，如果worker线程有异常，主线程捕获不到异常，就会造成消息丢失，这个是不是还需要做补偿机制；如果是手动提交，那offer set也会有可能丢失，消息重复消费，消息重复还好处理，做幂等就行。","like_count":4},{"had_liked":false,"id":273839,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1610694254,"is_pvip":false,"replies":[{"id":"99667","content":"也是一种思路：）","user_name":"作者回复","user_name_real":"胡夕","uid":"1288090","ctime":1611108994,"ip_address":"","comment_id":273839,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14495596142","product_id":100029201,"comment_content":"方案二感觉没什么必要：这个要考虑的东西太多了，纯粹是给自己埋坑<br>如何保证任务不会被拒绝，底层的线程池中的队列设置多大才好？<br>如何异步提交位移？<br>如何保证分区中记录原来的顺序<br><br>我觉得分区实际上是并行的单位，对于生成者是这样，消费者也是这样。你想一个Topic快点，多点分区其实就可以了（但也要合理）<br><br><br>","like_count":3,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513828,"discussion_content":"也是一种思路：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611108994,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120451,"user_name":"王之刚","can_delete":false,"product_type":"c1","uid":1121474,"ip_address":"","ucode":"AB2C3BB1867745","user_header":"https://static001.geekbang.org/account/avatar/00/11/1c/c2/adba355c.jpg","comment_is_top":false,"comment_ctime":1564903494,"is_pvip":false,"replies":[{"id":"44241","content":"目前没办法。如果不放到单独的topic中，只能照单全收+过滤","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1564965661,"ip_address":"","comment_id":120451,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14449805382","product_id":100029201,"comment_content":"请问老师一个问题，之前对接过第三方业务kafka系统，他们是通过在一个topic里的key来区分业务的，我们想只消费他们的某个业务的消息，我们的kafka消费者可以只接收这个topic里的特定的key的信息吗？（我们当时的实现是接收了这个topic的所有的信息，然后过滤key，这样导致接收了很多的多余的信息），先谢谢了","like_count":3,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461338,"discussion_content":"目前没办法。如果不放到单独的topic中，只能照单全收+过滤","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564965661,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2515425,"avatar":"","nickname":"Geek_2b7e17","note":"","ucode":"8F778CE616A945","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374835,"discussion_content":"我也有这个问题，想只消费特殊业务的时间，是不是如果分开业务消费，就每个业务定义一个不同的topic就行了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621386294,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120370,"user_name":"ban","can_delete":false,"product_type":"c1","uid":1034204,"ip_address":"","ucode":"E523CE97E48266","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c7/dc/9408c8c2.jpg","comment_is_top":false,"comment_ctime":1564846263,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14449748151","product_id":100029201,"comment_content":"老师，针对方案2！方案2里面在异步线程里提交offset，每个线程自己提交自己的，如果中间有offset提交失败，后面的offset又提交成功了咋办呢，中间失败消息的不就是丢失了吗？该如何正确的提交呢，才不会，有没有最佳实践呀？","like_count":3,"discussions":[{"author":{"id":1386315,"avatar":"https://static001.geekbang.org/account/avatar/00/15/27/4b/e49c82d0.jpg","nickname":"Rover","note":"","ucode":"7575EC91F45B99","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":359546,"discussion_content":"方案2中，如果是自动提交，消息量过大，线程池容量有限情况下，可能会执行拒绝策略，增加编码难度。针对于方案2，目前我的实现方式是：改为手动提交，单次拉取批量消息，使用线程池执行，并使用CountDownLatch countDown和await，最后取该批次最大的offset手动commitSync。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1616224727,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":276808,"user_name":"归零","can_delete":false,"product_type":"c1","uid":1103208,"ip_address":"","ucode":"C99B8E93009A46","user_header":"https://static001.geekbang.org/account/avatar/00/10/d5/68/2201b6b9.jpg","comment_is_top":false,"comment_ctime":1612142969,"is_pvip":true,"replies":[{"id":"101024","content":"看这篇吧：https:&#47;&#47;www.cnblogs.com&#47;huxi2b&#47;p&#47;13668061.html<br><br>算是终极版，修正了前两篇中可能出现的消息丢失场景","user_name":"作者回复","user_name_real":"胡夕","uid":"1288090","ctime":1612833987,"ip_address":"","comment_id":276808,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10202077561","product_id":100029201,"comment_content":"看了作者之前写的帖子(https:&#47;&#47;www.cnblogs.com&#47;huxi2b&#47;p&#47;6124937.html)，有个问题请教下:<br>在多线程场景下，为什么自动提交位移不会丢消息呢？<br>比如thread1完成了offset1，3，5然后提交。thread2完成2，4失败了。主线程此时怎么提交呢？是上报1还是5？<br>这其中的原理是什么呢？希望解答下，谢谢！","like_count":2,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514824,"discussion_content":"看这篇吧：https://www.cnblogs.com/huxi2b/p/13668061.html\n\n算是终极版，修正了前两篇中可能出现的消息丢失场景","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612833987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2150233,"avatar":"","nickname":"Geek_51aae7","note":"","ucode":"96E879024A1F74","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373457,"discussion_content":"和上一篇相比，这次最大的不同在于每个Worker只处理相同分区下的消息，而不是向之前那样处理多个分区中的消息。这样做的好处在于一旦某个分区的消息分配给了这个Worker，我可以暂停这个分区的可消费状态，直到这个Worker全部处理完成\n\n\n老师牛逼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620734019,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132580,"user_name":"Geek_b809ff","can_delete":false,"product_type":"c1","uid":1288329,"ip_address":"","ucode":"F3F17E99F3AA0B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoPY23R9RRSfBeTJUlyc612VlodjAaWWBNiay9tPydkrd6b9NA8GNibdibnFibTsx94ItHE4jvQwprNzA/132","comment_is_top":false,"comment_ctime":1568168071,"is_pvip":false,"replies":[{"id":"50882","content":"同一个consumer实例是在多个线程间共享的吗？KafkaConsumer不是线程安全的，你应该不被允许这么做的","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1568250532,"ip_address":"","comment_id":132580,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10158102663","product_id":100029201,"comment_content":"胡老师，请教一个问题。用命令行消费是ok的，但是用API消费，在调用了consumer.poll(1000) 方法后就没任何反应了，请问有可能是什么问题？具体实现代码如下，用了线程池<br>public void start() {<br>        try {<br>            int threadCoreNumber = 5;<br>            int threadMaxNumber = 10;<br>            &#47;&#47;启用线程池<br>            executor = new ThreadPoolExecutor(threadCoreNumber, threadMaxNumber, 1L, TimeUnit.MINUTES,<br>                    new ArrayBlockingQueue&lt;Runnable&gt;(500), new ThreadPoolExecutor.CallerRunsPolicy());<br>            Thread thread = new Thread(new Runnable() {<br>                @Override<br>                public void run() {<br>                    try {<br>                        while (true) {<br>                            &#47;&#47;从kafka中读取消息<br>                            ConsumerRecords&lt;String, String&gt; records = consumer.poll(1000);<br>                            &#47;&#47;自动提交<br>                            for (ConsumerRecord&lt;String, String&gt; record : records) {<br>                                logger.info(String.format(&quot;[consumer][thread:%s] receive message from [Topic:%s -&gt; partition:%s -&gt; offset:%s], message key:%s ,value:%s&quot;,<br>                                        Thread.currentThread().getName(), record.topic(), record.partition(), record.offset(), record.key(), record.value()));<br>                                executor.submit(new SaleMngConsumer(record));<br>                            }<br>                        }<br>                    } catch (Exception e) {<br>                        logger.info(&quot;djfs&quot;,e);<br>                        &#47;&#47;ignore if shutdown<br>                    }finally {<br>                        logger.info(&quot;kafka consumer is close ......&quot;);<br>                        consumer.close();<br>                    }<br>                }<br>            });<br>            thread.start();<br>        } catch (Exception e) {<br>            executor.shutdown();<br>        }<br>    }","like_count":2,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467019,"discussion_content":"同一个consumer实例是在多个线程间共享的吗？KafkaConsumer不是线程安全的，你应该不被允许这么做的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568250532,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129974,"user_name":"Geek_b809ff","can_delete":false,"product_type":"c1","uid":1288329,"ip_address":"","ucode":"F3F17E99F3AA0B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoPY23R9RRSfBeTJUlyc612VlodjAaWWBNiay9tPydkrd6b9NA8GNibdibnFibTsx94ItHE4jvQwprNzA/132","comment_is_top":false,"comment_ctime":1567345621,"is_pvip":false,"replies":[{"id":"48507","content":"针对你的场景，可以先将数据缓存在Kafka中，然后对下游的consumer进行限流","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1567385888,"ip_address":"","comment_id":129974,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10157280213","product_id":100029201,"comment_content":"老师，我是Kafka小白，一直有一个疑问，就是Kafka为什么能实现削峰限流的效果。比如说，我现在有一个业务场景的并发是每秒1000，这个时候数据库已经处理不过来了，如果这时候选择加入Kafka，由于Kafka可以让更多的消息发过来，如果消费者端也开启多线程去处理的话， 那数据库岂不是更加处理不过来了吗。请老师解答，谢谢！","like_count":2,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465746,"discussion_content":"针对你的场景，可以先将数据缓存在Kafka中，然后对下游的consumer进行限流","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567385888,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115466,"user_name":"rm -rf 😊ི","can_delete":false,"product_type":"c1","uid":1070908,"ip_address":"","ucode":"BC448EC4206D95","user_header":"https://static001.geekbang.org/account/avatar/00/10/57/3c/081b89ec.jpg","comment_is_top":false,"comment_ctime":1563594091,"is_pvip":false,"replies":[{"id":"42309","content":"是的<br>","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1563752667,"ip_address":"","comment_id":115466,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10153528683","product_id":100029201,"comment_content":"思考：<br>多进程上下文切换成本比较大，没多线程好。<br><br>另外，老师我想问问，方案1这种是消费者组吗？启动了多个消费者线程，会自动进行分区分配进行消费吗？","like_count":2,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459121,"discussion_content":"是的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563752667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115307,"user_name":"开水","can_delete":false,"product_type":"c1","uid":1528555,"ip_address":"","ucode":"651491C38B925B","user_header":"https://static001.geekbang.org/account/avatar/00/17/52/eb/eec719f3.jpg","comment_is_top":false,"comment_ctime":1563528754,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10153463346","product_id":100029201,"comment_content":"方案一用在需要精确控制消费数量的方案里，比如访问量这种日志什么的。<br>方案二可以把后面处理通过数据库key做成幂等操作，用在实时处理需要随时增减消费能力的业务上面。","like_count":2},{"had_liked":false,"id":114813,"user_name":"cricket1981","can_delete":false,"product_type":"c1","uid":1001715,"ip_address":"","ucode":"758262F5958DA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/f3/f1034ffd.jpg","comment_is_top":false,"comment_ctime":1563411574,"is_pvip":false,"replies":[{"id":"42093","content":"可以尝试下：）","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1563517628,"ip_address":"","comment_id":114813,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10153346166","product_id":100029201,"comment_content":"据我了解方案2可以用滑动窗口提交offsets，以确保提交offset顺序性，但仍无法避免任务失败消息重复消费问题，对吗？","like_count":2,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458824,"discussion_content":"可以尝试下：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563517628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":290653,"user_name":"小熊","can_delete":false,"product_type":"c1","uid":1245833,"ip_address":"","ucode":"A7635ED68A8390","user_header":"https://static001.geekbang.org/account/avatar/00/13/02/89/f8331e9c.jpg","comment_is_top":false,"comment_ctime":1619677446,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5914644742","product_id":100029201,"comment_content":"方案二的consumer offset如何提交呢？","like_count":1},{"had_liked":false,"id":249765,"user_name":"尚小树","can_delete":false,"product_type":"c1","uid":2165300,"ip_address":"","ucode":"9BCB0DF0F3C8E4","user_header":"https://static001.geekbang.org/account/avatar/00/21/0a/34/3e29eb5a.jpg","comment_is_top":false,"comment_ctime":1600783107,"is_pvip":false,"replies":[{"id":"91600","content":"其实多线程的方案除去实现复杂之外，比单线程的要好。可以统一使用多线程方案即可","user_name":"作者回复","user_name_real":"胡夕","uid":"1288090","ctime":1600909318,"ip_address":"","comment_id":249765,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5895750403","product_id":100029201,"comment_content":"老师好，如果我的应用场景既满足一中的多线程方案条件，也满足二中的多线程方案条件。那我是否可以两个方案都使用呢？比如，用三台机器去消费三个分区的数据，每个机器上获取消息后使用多线程的去消费。这样有没有什么弊端，或者是不是一个提高消费吞吐量的一个好方案？","like_count":1,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506008,"discussion_content":"其实多线程的方案除去实现复杂之外，比单线程的要好。可以统一使用多线程方案即可","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600909318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":226749,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1592194757,"is_pvip":false,"replies":[{"id":"83668","content":"嗯嗯，有道理~","user_name":"作者回复","user_name_real":"胡夕","uid":"1288090","ctime":1592297158,"ip_address":"","comment_id":226749,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5887162053","product_id":100029201,"comment_content":"在业务中使用了第二种方案，获取消息和处理消息不是同一个线程。获取消息不是制约业务性能的点，只启一个线程拉消息。而再处理消息中是一个3线程得线程池。<br>但是为了保证消息的因果关系，两个线程间启动用了两个队列来保证。这种方案相对来说，在保证消息顺序的条件下，是非常难以实现的。","like_count":1,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498352,"discussion_content":"嗯嗯，有道理~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592297158,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161414,"user_name":"高志强","can_delete":false,"product_type":"c1","uid":1276563,"ip_address":"","ucode":"68737002043752","user_header":"https://static001.geekbang.org/account/avatar/00/13/7a/93/c9302518.jpg","comment_is_top":false,"comment_ctime":1576202906,"is_pvip":false,"replies":[{"id":"61586","content":"PHP客户端的设计方式不太了解。如果是Java Consumer API的话，你不需要指定分区，只需要要消费的topic就行。如果位移管理恰当的话，通常不会发生大面积的消息重新消费。","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1576302442,"ip_address":"","comment_id":161414,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5871170202","product_id":100029201,"comment_content":"在发布订阅模式下，我想使用php多进程消费方式，groupid相同，topic也不变，kafkaConsumer会是多个，那么我需要指定consumer对应消费的分区么，会不会出现重新消费的情况，该如何避免，kafka在这种情况下会自动分配分区么，希望老师给予解答","like_count":1,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477711,"discussion_content":"PHP客户端的设计方式不太了解。如果是Java Consumer API的话，你不需要指定分区，只需要要消费的topic就行。如果位移管理恰当的话，通常不会发生大面积的消息重新消费。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576302442,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1276563,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7a/93/c9302518.jpg","nickname":"高志强","note":"","ucode":"68737002043752","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":100181,"discussion_content":"老师我现在用Php多进程消费，一个topic 130个分区，我是不是该启动130个进程去消费，目前启动64个进程，但消费能力上不去，消息积压量有几十万了，怎么才能提高消费能力呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577240729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129464,"user_name":"stupidstan","can_delete":false,"product_type":"c1","uid":1543647,"ip_address":"","ucode":"C6C050E2378FE0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoXoqDLvF3l8P5HoAbCicudTV71ftdXibQ2IuJhuzzxnMoE9ftUsJrIIVicwBqtqyUAFpeAicFBhL6bMw/132","comment_is_top":false,"comment_ctime":1567133378,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5862100674","product_id":100029201,"comment_content":"kafka-stream 单consumer+多工作线程，且能保证一个分区只被分给一个工作线程—-消费者有序","like_count":1},{"had_liked":false,"id":118115,"user_name":"金hb.Ryan 冷空氣駕到","can_delete":false,"product_type":"c1","uid":1222233,"ip_address":"","ucode":"CAD363576696E4","user_header":"https://static001.geekbang.org/account/avatar/00/12/a6/59/1689ea0c.jpg","comment_is_top":false,"comment_ctime":1564246122,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5859213418","product_id":100029201,"comment_content":"一般来说单个partition的获取速度是远远大于单线程的处理速度，所以一个partition consumer是必要有多个线程来并行处理来提高处理速度。当然单线程如果能够跟上那也没什么差别了","like_count":1},{"had_liked":false,"id":115186,"user_name":"丘壑","can_delete":false,"product_type":"c1","uid":1118203,"ip_address":"","ucode":"ECFEDA5A93828D","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/fb/68196d4c.jpg","comment_is_top":false,"comment_ctime":1563504359,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5858471655","product_id":100029201,"comment_content":"对于老师说的第二种多线程处理的方案，我本人觉得在消息量很大的系统中比较常用，只是在使用的时候很担心出现异常后的数据问题，数据应该怎么找回，这块对消费异常设计难度较大，请老师可以考虑分享下这块的手动提交位移及异常处理的经验","like_count":1},{"had_liked":false,"id":114792,"user_name":"黑崽","can_delete":false,"product_type":"c1","uid":1024159,"ip_address":"","ucode":"F31A4102EE4DA8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a0/9f/71345740.jpg","comment_is_top":false,"comment_ctime":1563408930,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5858376226","product_id":100029201,"comment_content":"胡大大后面是不是结合手动提交offset和这一个实例啊","like_count":1},{"had_liked":false,"id":355073,"user_name":"Geek_06d12d","can_delete":false,"product_type":"c1","uid":1590623,"ip_address":"浙江","ucode":"1C5172C3BBAEC3","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqGaJsoQicG7Bp8cUjUkevAp5Sm8ZXy5vl5TVk4CDrq5UAoI9VicK5wwjCdk66FVRbGziaWXHgO52l1Q/132","comment_is_top":false,"comment_ctime":1661054415,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1661054415","product_id":100029201,"comment_content":"方案一应该不用说吧，难道多个主题多个分区还用一个线程处理","like_count":0},{"had_liked":false,"id":348464,"user_name":"梓荣","can_delete":false,"product_type":"c1","uid":1596112,"ip_address":"","ucode":"275809CCBF0807","user_header":"https://static001.geekbang.org/account/avatar/00/18/5a/d0/7e58f993.jpg","comment_is_top":false,"comment_ctime":1655119394,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655119394","product_id":100029201,"comment_content":"方案二最关键的位移提交居然没写","like_count":0},{"had_liked":false,"id":341650,"user_name":"ub8","can_delete":false,"product_type":"c1","uid":1481811,"ip_address":"","ucode":"0D937C3EAEB781","user_header":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","comment_is_top":false,"comment_ctime":1649752381,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649752381","product_id":100029201,"comment_content":"方案2还有个很大的问题是，可能会在消费线程组中出现丢消息的情况，具体原因很简单就是，如果消费任务已经进入执行具体逻辑的worker线程组的阻塞队列中，此时实例宕机，那保存在阻塞队列中的任务就丢失了？这个问题如何解呢？","like_count":0},{"had_liked":false,"id":326675,"user_name":"廉哲华","can_delete":false,"product_type":"c1","uid":1890762,"ip_address":"","ucode":"3CA016FBD638C8","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erOX2EfqXGHWO7uaU8jibAs25IjvZmwYqKEpmYb99JWskxysQP0EFnY3Yaup9YDQhSTvhveTej4FOQ/132","comment_is_top":false,"comment_ctime":1639626960,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639626960","product_id":100029201,"comment_content":"但在很多场景下，Consumer 端是有非阻塞需求的，比如在流处理应用中执行过滤（filter）、连接（join）、分组（group by）等操作时就不能是阻塞式的。<br><br>老师，请教一下这些操作中为什么不能是阻塞式的？","like_count":0},{"had_liked":false,"id":314038,"user_name":"凯文小猪","can_delete":false,"product_type":"c1","uid":1980201,"ip_address":"","ucode":"36D8AD0229547F","user_header":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","comment_is_top":false,"comment_ctime":1632815069,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632815069","product_id":100029201,"comment_content":"第一种方案不足点：<br>1. 对于带宽 和连接是倍数增长的，比方说我们开20个线程，而qps是2000，每条消息是1KB，那么带宽就达到 20 * 2000 * 1KB = 40MB 而这种场景其实对于二线场来说是常规场景，这种本身网卡会迅速吃掉<br>2.多线程还意味着同一个group.id下人为制造了大量消费者实例 那么对于协调者来说rebalance的时间是成倍的 目前就像老师说的rebalance算法是O(N)的<br><br>对于第二种来说 我们会将partition作为偏序的依据 也就是有因果关系的消息发往一个分区。但是取出来直接扔到线程池就又打散了 那么怎么解决呢？<br>一般来说这种场景都会有个msgKey 那么消费者也针对这个 msgKey做任务下发就是了。只不过此种场景下每个线程的任务数必定不是均等的 但现在硬件配置 可以接受<br><br><br>最后再谈下我认为的第三种方案 就是对第二种做翻版。poll线程作为master  线程池线程作为worker。worker一直处于await状态 每次下发任务后master做notify","like_count":0},{"had_liked":false,"id":300857,"user_name":"Geek_863b69","can_delete":false,"product_type":"c1","uid":1588653,"ip_address":"","ucode":"DAD05568516F07","user_header":"https://static001.geekbang.org/account/avatar/00/18/3d/ad/819a731a.jpg","comment_is_top":false,"comment_ctime":1625406299,"is_pvip":false,"replies":[{"id":"109455","content":"方案1采用了consumer group的机制，只是每个consumer下面单独创建了多个消费线程","user_name":"作者回复","user_name_real":"胡夕","uid":"1288090","ctime":1626242243,"ip_address":"","comment_id":300857,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1625406299","product_id":100029201,"comment_content":"老师 方案1和consumer group是一回事吗","like_count":0,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522836,"discussion_content":"方案1采用了consumer group的机制，只是每个consumer下面单独创建了多个消费线程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626242243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":291816,"user_name":"包子","can_delete":false,"product_type":"c1","uid":1503408,"ip_address":"","ucode":"3050ADC0DC827A","user_header":"https://static001.geekbang.org/account/avatar/00/16/f0/b0/f6a218c6.jpg","comment_is_top":false,"comment_ctime":1620529472,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620529472","product_id":100029201,"comment_content":"没明白多进程是怎么来的😂","like_count":0},{"had_liked":false,"id":291395,"user_name":"Zain","can_delete":false,"product_type":"c1","uid":1920896,"ip_address":"","ucode":"03EDF7B1BE9CF8","user_header":"https://static001.geekbang.org/account/avatar/00/1d/4f/80/19f946ba.jpg","comment_is_top":false,"comment_ctime":1620268659,"is_pvip":false,"replies":[{"id":"105694","content":"说的糙一点，机器多用多进程，单台机器性能高，用多线程","user_name":"作者回复","user_name_real":"胡夕","uid":"1288090","ctime":1620613853,"ip_address":"","comment_id":291395,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1620268659","product_id":100029201,"comment_content":"老师，看了评论还是不太清楚多线程和多进程怎么来权衡？能简单说一下吗，partition多的话是不是还是启动多进程，还是说根据核数，比如8核的，我就在单进程里设置8个线程，然后如果partition多的话，我再起几个这样的进程","like_count":0,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519459,"discussion_content":"说的糙一点，机器多用多进程，单台机器性能高，用多线程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620613853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":290821,"user_name":"Geek_9c6c3e","can_delete":false,"product_type":"c1","uid":2577451,"ip_address":"","ucode":"F3B71465B25BC6","user_header":"","comment_is_top":false,"comment_ctime":1619768963,"is_pvip":false,"replies":[{"id":"105700","content":"100个进程和100个线程启动consumer，对于kafka而言是一样的。","user_name":"作者回复","user_name_real":"胡夕","uid":"1288090","ctime":1620614351,"ip_address":"","comment_id":290821,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1619768963","product_id":100029201,"comment_content":"当然了，这种扩展性方面的局限可以被多机架构所缓解。除了在一台机器上启用 100 个线程消费数据，我们也可以选择在 100 台机器上分别创建 1 个线程，效果是一样的。因此，如果你的机器资源很丰富，这个劣势就不足为虑了。<br><br><br>这句话没懂，有谁能解答一下吗？","like_count":0,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519294,"discussion_content":"100个进程和100个线程启动consumer，对于kafka而言是一样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620614351,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":286904,"user_name":"tpbird","can_delete":false,"product_type":"c1","uid":1245847,"ip_address":"","ucode":"899DC873618180","user_header":"https://static001.geekbang.org/account/avatar/00/13/02/97/498d5f1e.jpg","comment_is_top":false,"comment_ctime":1617676324,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617676324","product_id":100029201,"comment_content":"对于方案2 ，如果业务上允许消费端数据丢失，是否可以在拉取数据之后马上手动提交offset,，然后再由线程池去处理后续的业务逻辑，这样是否就没有offset提交的问题了？如下面代码中这样<br>@KafkaListener(topics = &quot;#{&#39;${spring.kafka.consumer.topic}&#39;.split(&#39;,&#39;)}&quot;)<br>public void monitorDataListern(ConsumerRecords&lt;String, String&gt;  consumerRecords, Acknowledgment ack){<br>\tack.acknowledge(); &#47;&#47;手动提交offset<br>\t<br>\t&#47;&#47;线程池处理逻辑<br>\t.....\t\t<br>}","like_count":0},{"had_liked":false,"id":284062,"user_name":"杰","can_delete":false,"product_type":"c1","uid":1109562,"ip_address":"","ucode":"036B010A45070A","user_header":"https://static001.geekbang.org/account/avatar/00/10/ee/3a/c0ad9c43.jpg","comment_is_top":false,"comment_ctime":1616054335,"is_pvip":true,"replies":[{"id":"103536","content":"是的。独立消费者实际上用的非常多。很多大数据流式框架并没有使用consumer group，比如Flink、Spark streaming等<br>","user_name":"作者回复","user_name_real":"胡夕","uid":"1288090","ctime":1616721940,"ip_address":"","comment_id":284062,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1616054335","product_id":100029201,"comment_content":"胡老师你好，请问独立消费者和消费者组订阅的区别是不是一个assign、一个subscribe？<br>独立消费者有哪些使用场景呢？生产中用的多吗","like_count":0,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517219,"discussion_content":"是的。独立消费者实际上用的非常多。很多大数据流式框架并没有使用consumer group，比如Flink、Spark streaming等\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616721940,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":283083,"user_name":"warriorSL","can_delete":false,"product_type":"c1","uid":1597200,"ip_address":"","ucode":"902DA345FD2623","user_header":"https://static001.geekbang.org/account/avatar/00/18/5f/10/ed332d5a.jpg","comment_is_top":false,"comment_ctime":1615541510,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615541510","product_id":100029201,"comment_content":"其实方案2，如果要保证顺序性也很简单，搞个路由线程池，根据kafka key进行路由，就能保证单个线程中消费的消息顺序，又兼顾了消费者的处理能力","like_count":0},{"had_liked":false,"id":269816,"user_name":"undefined","can_delete":false,"product_type":"c1","uid":2275808,"ip_address":"","ucode":"953AF612BBF0F7","user_header":"https://static001.geekbang.org/account/avatar/00/22/b9/e0/47f8c89e.jpg","comment_is_top":false,"comment_ctime":1608795316,"is_pvip":false,"replies":[{"id":"98448","content":"实际上，方案2并不是任由各个线程提交位移，而是让每个worker线程提交位移到主线程，然后由主线程统一提交位移。这个方案的问题在于：每个线程没有在确认上一批消息被提交之后暂停，所以可能出现消息重复消费","user_name":"作者回复","user_name_real":"胡夕","uid":"1288090","ctime":1609724220,"ip_address":"","comment_id":269816,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1608795316","product_id":100029201,"comment_content":"方案2使用多线程处理任务，并在线程内提交移位。由于KafkaConsumer内有管理下一个位移值，所以即使多线程不按拉取顺序提交位移，也能保证顺序拉取。只有KafkaConsumer发生异常或Rebalance时，才可能出现消息重复消费或者丢失，这么理解对吗？","like_count":0,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512403,"discussion_content":"实际上，方案2并不是任由各个线程提交位移，而是让每个worker线程提交位移到主线程，然后由主线程统一提交位移。这个方案的问题在于：每个线程没有在确认上一批消息被提交之后暂停，所以可能出现消息重复消费","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609724220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263631,"user_name":"hunterlodge","can_delete":false,"product_type":"c1","uid":1069755,"ip_address":"","ucode":"5B83A79E784161","user_header":"https://static001.geekbang.org/account/avatar/00/10/52/bb/225e70a6.jpg","comment_is_top":false,"comment_ctime":1606202334,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606202334","product_id":100029201,"comment_content":"如果方案2中获取消息的线程也并行化的话，那么它很复杂，兼具两种方案的优缺点。","like_count":0},{"had_liked":false,"id":256063,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1603516875,"is_pvip":false,"replies":[{"id":"93382","content":"是的。默认就是单线程的处理方式（这里不考虑心跳线程）","user_name":"作者回复","user_name_real":"胡夕","uid":"1288090","ctime":1603675349,"ip_address":"","comment_id":256063,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1603516875","product_id":100029201,"comment_content":"<br>问一个比较弱智的问题，如果不使用多线程方案，难道每一个消费者组中的消费者是一个一个串行消费的？","like_count":0,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507920,"discussion_content":"是的。默认就是单线程的处理方式（这里不考虑心跳线程）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603675349,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":231876,"user_name":"蚂蚁","can_delete":false,"product_type":"c1","uid":1211429,"ip_address":"","ucode":"B3FEFB399536DF","user_header":"https://static001.geekbang.org/account/avatar/00/12/7c/25/7d9a2538.jpg","comment_is_top":false,"comment_ctime":1593795107,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593795107","product_id":100029201,"comment_content":"方案二，可以根据消息写入的规则哈希到对应的线程，这样可以保证每个工作线程的消息是有序的","like_count":0},{"had_liked":false,"id":224554,"user_name":"James","can_delete":false,"product_type":"c1","uid":1134861,"ip_address":"","ucode":"48B0F2A334D1C1","user_header":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","comment_is_top":false,"comment_ctime":1591441557,"is_pvip":false,"replies":[{"id":"82735","content":"我个人认为，如果不将消费线程与分区严格一一映射，很难保证位移提交不出问题","user_name":"作者回复","user_name_real":"胡夕","uid":"1288090","ctime":1591540128,"ip_address":"","comment_id":224554,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591441557","product_id":100029201,"comment_content":"方案二,项目是直接单线程拉取到队列,自动提交位移,然后由多线程处理消息集合,<br>这种手动位移提交好像很多难度;<br>这种情况下,消息可能因为程序处理有问题而被忽略执行是吧.","like_count":0,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497522,"discussion_content":"我个人认为，如果不将消费线程与分区严格一一映射，很难保证位移提交不出问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591540128,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224553,"user_name":"James","can_delete":false,"product_type":"c1","uid":1134861,"ip_address":"","ucode":"48B0F2A334D1C1","user_header":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","comment_is_top":false,"comment_ctime":1591441391,"is_pvip":false,"replies":[{"id":"82736","content":"嗯，严格来说，这两种方案都有瑕疵<br>","user_name":"作者回复","user_name_real":"胡夕","uid":"1288090","ctime":1591540147,"ip_address":"","comment_id":224553,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591441391","product_id":100029201,"comment_content":"第一种多线程无需交互的方案对于不同主题但是属于业务上同一个id的数据,可能会出现并发问题,导致同一个id的状态因为先后顺序被覆盖...","like_count":0,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497521,"discussion_content":"嗯，严格来说，这两种方案都有瑕疵\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591540147,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":189246,"user_name":"醇梨子","can_delete":false,"product_type":"c1","uid":1089040,"ip_address":"","ucode":"25D498248A855C","user_header":"https://static001.geekbang.org/account/avatar/00/10/9e/10/3cb10bf7.jpg","comment_is_top":false,"comment_ctime":1584492908,"is_pvip":true,"replies":[{"id":"73067","content":"目前不支持，只能自己实现","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1584579628,"ip_address":"","comment_id":189246,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1584492908","product_id":100029201,"comment_content":"你好，我请教一个问题，kafka单机或集群支持延迟消息或延迟队列嘛？我看官方好像没有明确的指出啊","like_count":0,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487645,"discussion_content":"目前不支持，只能自己实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584579628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187776,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1015754,"ip_address":"","ucode":"00DF2FEC58D2E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","comment_is_top":false,"comment_ctime":1584239637,"is_pvip":false,"replies":[{"id":"72590","content":"我有点没太懂，如果我使用standalone consumer，方案2为什么不可以使用多个consumer实例线程同时获取消息呢？？","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1584320676,"ip_address":"","comment_id":187776,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1584239637","product_id":100029201,"comment_content":"看到这里的代码后，其实和自己在看这些代码之前思路是一样的。但是需要指出的是，这里的第2种方案的代码与上面的第2种方案的示意图不吻合！第2种方案的代码也只能并且有且仅有一个Consumer实例，而上面对第2种方案说明的时候“方案 2 的最大优势就在于它的高伸缩性，就是说我们可以独立地调节消息获取的线程数”这样说显然是错误的！结合方案2的代码，目前想到提高方案2的性能的话只能增加“以及消息处理的线程数”","like_count":0,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487236,"discussion_content":"我有点没太懂，如果我使用standalone consumer，方案2为什么不可以使用多个consumer实例线程同时获取消息呢？？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584320676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":205770,"discussion_content":"网上查询了standalone consumer可以订阅任何分区，彼此之间也没有关系，即两个standalone consumer可以订阅并消费同一个主题店不同分区，这样的话就和老师的方案一致了。感谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584340414,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133604,"user_name":"miwucc","can_delete":false,"product_type":"c1","uid":1326429,"ip_address":"","ucode":"7935BD907119AE","user_header":"https://static001.geekbang.org/account/avatar/00/14/3d/5d/ac666969.jpg","comment_is_top":false,"comment_ctime":1568619848,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568619848","product_id":100029201,"comment_content":"方案2可以实现自己的分区线程池执行方法，不过对于位移管理还是存在风险，不能保证一定处理成功","like_count":0},{"had_liked":false,"id":129538,"user_name":"z.l","can_delete":false,"product_type":"c1","uid":1181055,"ip_address":"","ucode":"805CC5784D3F76","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/7f/d35ab9a1.jpg","comment_is_top":false,"comment_ctime":1567151522,"is_pvip":false,"replies":[{"id":"48309","content":"如果碰到异常你可以中断consumer消费，修复之后再重新上线","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1567154741,"ip_address":"","comment_id":129538,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567151522","product_id":100029201,"comment_content":"有个疑问请教下，使用批量消费+手动提交的方式，如果中间某一条消息由于代码bug抛出异常，导致没有提交消费位移，这种情况是不是这个分区的消费进度就一直停滞不前了？并且这个消费者实例一直在重复消费这一批消息？","like_count":0,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465529,"discussion_content":"如果碰到异常你可以中断consumer消费，修复之后再重新上线","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567154741,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129104,"user_name":"蛋炒番茄","can_delete":false,"product_type":"c1","uid":1095049,"ip_address":"","ucode":"3F963347C4A97C","user_header":"https://static001.geekbang.org/account/avatar/00/10/b5/89/9a1b4dee.jpg","comment_is_top":false,"comment_ctime":1567042878,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567042878","product_id":100029201,"comment_content":"可以试试在interceptor里面做过滤","like_count":0},{"had_liked":false,"id":124991,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1566036105,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566036105","product_id":100029201,"comment_content":"线程有叫轻量级进程，最大的区别在于切换进程时，必须切换程序的所有地址空间。线程的轻量级主要体现在，多个线程会共享部分地址空间，切换成本相对低一些。<br>1：多进程<br>优势——理解、实现更简单<br>劣势——消耗更多的计算机资源<br>2：多线程<br>优势——相对而言使计算机的资源得到了更充分的利用<br>劣势——理解、编程、维护成本高","like_count":0},{"had_liked":false,"id":119251,"user_name":"可以","can_delete":false,"product_type":"c1","uid":1564517,"ip_address":"","ucode":"3FEE197722C406","user_header":"https://static001.geekbang.org/account/avatar/00/17/df/65/c9dace3e.jpg","comment_is_top":false,"comment_ctime":1564543580,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564543580","product_id":100029201,"comment_content":"方案2会让我想到Reactor，同样是将拉取数据（上游）消费数据（下游），下游订阅上游的数据，调度器设置上游、下游的线程方式。所以想方案2的代码是否能用Reactor实现呢？还是我理解上有误？望指正","like_count":0},{"had_liked":false,"id":118116,"user_name":"金hb.Ryan 冷空氣駕到","can_delete":false,"product_type":"c1","uid":1222233,"ip_address":"","ucode":"CAD363576696E4","user_header":"https://static001.geekbang.org/account/avatar/00/12/a6/59/1689ea0c.jpg","comment_is_top":false,"comment_ctime":1564246381,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564246381","product_id":100029201,"comment_content":"我们方案2也是类似解决方案，主线程poll然后submit任务，多线程消费，如果消费延迟即队列满那么主线程仍然会wait，这样其实commit还是主线程commit逻辑。现在想到是不是可以一个partition一个线程池来保证可以异步➕同步commit？","like_count":0},{"had_liked":false,"id":115124,"user_name":"Aaron亚伦","can_delete":false,"product_type":"c1","uid":1102516,"ip_address":"","ucode":"135432A2E61563","user_header":"https://static001.geekbang.org/account/avatar/00/10/d2/b4/cf551416.jpg","comment_is_top":false,"comment_ctime":1563498013,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563498013","product_id":100029201,"comment_content":"我觉得方案2下管理和提交移位跟处理消息的线程池是没有关系的。所以不管是手动提交还是自动提交还是KafkaConsumer的实例完成的。","like_count":0},{"had_liked":false,"id":115094,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1563494196,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563494196","product_id":100029201,"comment_content":"其实方案12可以结合，即启动多个consumer，每个consumer也可以分离接收和业务处理","like_count":0},{"had_liked":false,"id":114922,"user_name":"nightmare","can_delete":false,"product_type":"c1","uid":1056314,"ip_address":"","ucode":"EF2E51C2122A86","user_header":"https://static001.geekbang.org/account/avatar/00/10/1e/3a/5b21c01c.jpg","comment_is_top":false,"comment_ctime":1563433982,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563433982","product_id":100029201,"comment_content":"方案1 位移提交好管理 方案2  位移提交不好环境 但是扩容更加方便  多进程消耗物理资源  ","like_count":0},{"had_liked":false,"id":114852,"user_name":"lmtoo","can_delete":false,"product_type":"c1","uid":1133918,"ip_address":"","ucode":"FCD5B9C941D448","user_header":"https://static001.geekbang.org/account/avatar/00/11/4d/5e/c5c62933.jpg","comment_is_top":false,"comment_ctime":1563417351,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563417351","product_id":100029201,"comment_content":"所以这里说的消费者组-&gt;消费者的关系，实际上就是消费者组-&gt;消费者线程的关系，一个消费者线程就认为是一个消费者，而不是一个消费者客户端一个消费者","like_count":0},{"had_liked":false,"id":114804,"user_name":"吴宇晨","can_delete":false,"product_type":"c1","uid":1199968,"ip_address":"","ucode":"F8F45B7067DF6D","user_header":"https://static001.geekbang.org/account/avatar/00/12/4f/60/049a20e9.jpg","comment_is_top":false,"comment_ctime":1563410535,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563410535","product_id":100029201,"comment_content":"目前用的方法一，因为消费顺序要考虑。多进程我觉得和方法一差不多吧，使用的资源更多了，进程比线程就是隔离程度更高了，然而还是避免不了一个consumer超时导致rebalance的问题，所以感觉多进程消费没啥优势","like_count":0},{"had_liked":false,"id":114797,"user_name":"开水","can_delete":false,"product_type":"c1","uid":1528555,"ip_address":"","ucode":"651491C38B925B","user_header":"https://static001.geekbang.org/account/avatar/00/17/52/eb/eec719f3.jpg","comment_is_top":false,"comment_ctime":1563409884,"is_pvip":false,"replies":[{"id":"42094","content":"嗯，如果唯一用来拉取消息不执行小处理逻辑，那么单线程已然很高效了。","user_name":"作者回复","user_name_real":"huxi_2b","uid":"1288090","ctime":1563517655,"ip_address":"","comment_id":114797,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563409884","product_id":100029201,"comment_content":"所以方案2的代码consumer实例也是单线程的？","like_count":0,"discussions":[{"author":{"id":1288090,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a7/9a/495cb99a.jpg","nickname":"胡夕","note":"","ucode":"5709A689B6683B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458817,"discussion_content":"嗯，如果唯一用来拉取消息不执行小处理逻辑，那么单线程已然很高效了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563517655,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}