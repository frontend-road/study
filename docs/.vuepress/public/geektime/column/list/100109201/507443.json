{"id":507443,"title":"12｜集成测试（一）：一条Happy Path扫天下","content":"<p>你好，我是柳胜。</p><p>上一讲，我们学习了单元测试，在验证业务逻辑方面，它的优势在于速度又快，阶段又早。既然单元测试看起来是一个完美的自动化测试方案，那为什么还需要集成测试呢？</p><p>我在<a href=\"https://time.geekbang.org/column/article/497405\">第二讲</a>的3KU原则说过，测试需求首先要找ROI最高的截面来验证。在金字塔模型里，ROI最高的就是单元测试，如果无法实现，才回退到ROI第二高的截面，一直到ROI最低的端到端测试。</p><p>那集成测试存在的价值，一定是做得了单元测试层面做不到的事，否则，集成测试这个概念就没必要存在。那这些事具体有哪些呢？你要是能找到这些事，就找到了集成测试省力又见效的窍门。今天咱们就一起寻找这个答案。</p><h2>集成测试和单元测试</h2><p>上一讲我们学过了代码四象限法则，产品的代码按照业务相关性和依赖程度，可以划分到下面四个象限里。</p><p><img src=\"https://static001.geekbang.org/resource/image/53/cb/538461c119ff8ac736750f27ea60a7cb.jpg?wh=1920x1501\" alt=\"图片\"></p><p>那集成测试和单元测试分别应该归到第几象限呢？</p><p>集成测试，顾名思义，是验证本服务代码和其他进程的服务能不能一起配合工作。在上面的四象限里，集成测试的活动领域就在“依赖代码”象限，而单元测试的活动领域是在“领域代码”象限。</p><p>我再用图解的方式划分一下地盘，你会看得更清楚。</p><p><img src=\"https://static001.geekbang.org/resource/image/3f/45/3f6fc585e1af8bc0a110c83776781045.jpg?wh=1920x1203\" alt=\"图片\"></p><p>这张图里的信息量很大，展示了单元测试和集成测试的各自战场，我来跟你细说一下。</p><p>单元测试掌管领域代码的测试，这些领域代码只是负责数据计算，并不会触及外部依赖。像上一讲的changeEmail方法，只是计算出一个新的餐馆数目，单元测试只需要验证这个计算逻辑是否正确就好了。</p><!-- [[[read_end]]] --><p>那什么是单元测试测不了的呢？ 那就是依赖代码。在FoodCome的代码设计里，这些外部的依赖管理交给一个独立的Controller Class去做，它负责读写数据库、发送消息等等。这块就是集成测试的领域。</p><p>看到这里，你脑袋里可能会冒出这样一个问题：不对呀！单元测试也可以测试外部依赖，我们在前面讲过可以Mock外部依赖，如果我把Database、MessageBus都Mock了，那不就也可以做单元测试了么？</p><p>你能想到这一层，说明你已经关注概念背后真正的事情了。是的，如果所有的外部服务都Mock了，集成测试就变成了单元测试，往另外一个方向，如果所有的外部服务都是真实的，集成测试又变成了端到端的测试。<strong>集成测试就是处在单元测试和端到端测试中间的一个状态。</strong></p><p><img src=\"https://static001.geekbang.org/resource/image/e0/cf/e06c78d1995fbba0af903da9001302cf.jpg?wh=1920x733\" alt=\"图片\"></p><p>在这里，我们要关注<strong>Mock和Real的优劣势，集成测试怎么能做得更聪明一些，用最少的工作量，获得最大的测试效果</strong>。下面我们就展开来说一说。</p><h2>集成测试测什么？</h2><p>相比单元测试，集成测试有2个特点。</p><p>第一，集成测试运行速度慢，这个时间主要花在2个地方，第一个是准备集成测试环境的时间，你要先把依赖的外部服务启动起来，让环境处在一个健康状态；第二个是运行集成测试的时间，因为集成测试不像单元测试是进程内工作，它是跨进程通讯，除了计算时间，还要加上网络通讯时间等等。</p><p>第二，执行集成测试，要运行的代码量比单元测试要多。因为它走过的路径更长，从网络请求，到处理请求，再到网络返回结果，中间需要经历过n个代码单元，还有框架代码，库代码等等。</p><p>这两个特征告诉我们，集成测试是有比较大的成本的，并且它测试的代码逻辑和单元测试是有重叠的。</p><p>本着追求整体最大ROI效益的目标，集成测试和单元测试需要协同作战，保持一个平衡，这个平衡的原则是：</p><p>1.在单元测试阶段验证尽可能多的业务逻辑，这样能让集成测试关注在外部依赖上。</p><p>2.集成测试至少覆盖一条长路径案例，叫“Happy Path”。</p><h3>怎么挑选Happy Path</h3><p>Happy Path是指一条正常业务的测试案例，走尽可能多的外部依赖服务。比如，一条案例，同时走了Database和MessageBus。</p><p>针对<a href=\"https://time.geekbang.org/column/article/506638\">上一讲</a>提到的用户修改邮箱功能，我们有几个案例：</p><p>1.修改邮箱名从 a@foodcome.com到b@foodcome.com<br>\n2.修改邮箱名从 a@example.com到a@foodcome.com<br>\n3.修改邮箱名从 a@example.com到b@example.com</p><p>哪个案例是Happy Path呢？再回头看一下代码：</p><pre><code class=\"language-java\">public class UserController\n{\n   .............\n    public void ChangeEmail(int userId, string newEmail)\n    {\n        .....................\n        user.ChangeEmail(newEmail, restaurant);\n        _database.SaveUser(user);\n        //如果restaurant数量有变化，就写数据库，发送通知信息\n        if(restaurant.numberChanged()){\n          _database.SaveRestaurant(restaurant);\n          _messageBus.SendEmailChangedMessage(userId, newEmail);\n         }\n    }\n}\n</code></pre><p>我们不难发现案例2符合Happy Path，因为它触发了多次与2个外部依赖的交互，更新了Databse的用户信息和餐馆信息，还触发了消息总线发送一条通知出去。</p><p>你可能还想到一个疑问，如果我们找不到一个能触发全部外部依赖交互点的Happy Path，那怎么办？很简单，那就再加一条Happy Path。</p><h2>集成测试用Mock还是Real测试？</h2><p>集成测试领域一个有争议的话题，就是外部依赖是用Mock还是用真实的实例。在前面我们讲单元测试是“孤立型”还是“社交型”的时候，提到了Mock和Real两种方法都有优劣，都有适用的场景（可以回看<a href=\"https://time.geekbang.org/column/article/505695\">第十讲</a>）。</p><p>今天我们详细说说，选择Mock还是Real的方法。</p><p>首先要看外部依赖的特征，我把它划分成2种类型。</p><p>1.完全可控依赖<br>\n2.不可控依赖</p><p>什么是完全可控依赖呢？ 这个外部的服务被你的应用独享，你也能够控制它的开发和运维，那这个服务就是完全可控依赖的。一个典型的例子，就是数据库，在微服务模式下，每一个服务独享一个自己的数据库Schema。</p><p>那什么又是不可控依赖？与可控依赖相反，这个外部的服务不止你的应用调用，大家都得遵守一个协议或规范，和这个公共的外部服务交互。典型的例子，就是外部的支付系统，SMTP邮件通知服务等等。</p><p>与这两种类型相对应的Mock策略如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/17/07/1766011df1c922a898004190c0681a07.jpg?wh=1920x654\" alt=\"图片\"></p><p>为什么是这样的？ 完全可控依赖的服务，虽然是在你的应用之外的一个进程，但你可以把跟它的交互当作是你开发的内部实现。你可以升级数据库版本、修改表格结构、增加数据库函数，只要跟着应用的代码一起修改即可。</p><p>这种情况下，你可以把这个数据库和你的应用当作一个整体，没必要花力气做Mock，如果你脑子一抽做了Mock，就还要维护Mock的变化，恭喜进坑。</p><p>而不可控依赖服务就不一样了，它是公共的，你控制不了它，而且你跟它的交互还要遵守一个规范的契约。在这种情况下，做Mock就划算了，原因有二：<strong>第一，基于契约的Mock的维护成本比较低；第二，使用Mock可以保证你的应用持续重构，向后兼容</strong>。</p><p>分析到这，我们就能梳理出FoodCome的Mock策略了。</p><p><img src=\"https://static001.geekbang.org/resource/image/26/98/26170c5b24f458f2ee3706f1a15a5f98.jpg?wh=1920x908\" alt=\"图片\"></p><h2>集成测试的实现</h2><p>找出了Happy Path，也定了Mock策略后，就可以动手写代码了。</p><p>根据2号案例，我们来创建一个测试方法，方法名为change_email_from_example_to_foodcome：</p><pre><code class=\"language-c#\">[Fact]\npublic void Changing_email_from_example_to_foodcome()\n{\n    // Arrange\n    var db = new Database(ConnectionString);                          \n    User user = CreateUser(                                           \n        \"a@example.com\", UserType.customer, db);                                              \n    var messageBusMock = new Mock&lt;IMessageBus&gt;();                     \n    var sut = new UserController(db, messageBusMock.Object);\n    // 调用changeEmail方法\n    string result = sut.ChangeEmail(user.UserId, \"b@foodcome.com\");\n    // 校验返回\n    Assert.Equal(\"OK\", result);\n    // 校验数据库里字段\n    object[] userData = db.GetUserById(user.UserId);                 \n    User userFromDb = UserFactory.Create(userData);                  \n    Assert.Equal(\"b@foodcome.com\", userFromDb.Email);                 \n    Assert.Equal(UserType.Restaurant, userFromDb.Type);                \n        messageBusMock.Verify(                                           \n        x =&gt; x.SendEmailChangedMessage(                              \n            user.UserId, \"b@foodcome.com\"),                           \n        Times.Once);                                                 \n}\n</code></pre><p>上面的代码完成了以下步骤，我特意分点列出来，方便你看清楚每一步。</p><p>1.创建真实的数据库连接对象；<br>\n2.创建MessageBus的Mock对象；<br>\n3.把2个依赖注入到被测UserController class里，调用changeEmail方法；<br>\n4.检验数据库里的User状态；<br>\n5.检验Mock的MessageBus里的消息。</p><h2>小结</h2><p>今天我们学习了和外部服务的集成测试的方法，在动手之前，我们要想明白测什么，用什么测，Mock还是Real。</p><p>测什么，怎么测，这就是集成测试方案要回答的问题，而且，这个方案的制定遵循3KU原则，也就是尽量不做重复的事，把精力和时间花在有价值的地方。</p><p>单元测试需要做好业务逻辑的验证，集成测试主要是测试与外部依赖的集成，集成又有2种策略，采用Mock还是Real真实的依赖，应该遵循<strong>能Real就Real的原则，不能Real的再采用Mock</strong>，如果一股脑Mock所有依赖，你会发现集成测试没测到什么有用的逻辑，都在Mock上，而真正集成时还是会遇到问题。</p><p>在集成测试案例的设计上，我提出了<strong>Happy Path</strong>，让你能用最少的工作量做最有效果的事情，这对于集成测试刚起步的项目来说，十分关键。在Mock策略上，也是遵循同样的原则，尽量把开发和维护Mock的工作量花在最有价值的外部依赖上。</p><h2>思考题</h2><p>在实际工作中，你有多个测试案例，怎么找出那条Happy Path？除了看代码，还有别的方法么？</p><p>欢迎你在留言区跟我交流互动，也推荐你把这讲内容分享给更多同事、朋友。</p>","neighbors":{"left":{"article_title":"11｜单元测试（二）：四象限法让你的单测火力全开","id":506638},"right":{"article_title":"13｜集成测试（二）：携手开发，集测省力又省心","id":508574}},"comments":[{"had_liked":false,"id":342063,"user_name":"朝如青丝暮成雪","can_delete":false,"product_type":"c1","uid":1164201,"ip_address":"","ucode":"95C98ECFBC1662","user_header":"https://static001.geekbang.org/account/avatar/00/11/c3/a9/aa5a5d8b.jpg","comment_is_top":false,"comment_ctime":1649996203,"is_pvip":false,"replies":[{"id":"125259","content":"是的。一讲的内容篇幅主要讲的是单元测试在整体中的位置，方向和关注点，相当于建立起一个架子。至于血肉的细节，可以参照我为本专栏创建的Github Repository，https:&#47;&#47;github.com&#47;sheng-geek-zhuanlan&#47;awesome-test-automation，这里搜集了一些很好的素材资料！","user_name":"作者回复","user_name_real":"编辑","uid":"1877634","ctime":1650547514,"ip_address":"","comment_id":342063,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10239930795","product_id":100109201,"comment_content":"老师有推荐的单元测试练手的项目嘛？看完文档觉得自己好像会了，但是实际上手可能差点意思","like_count":3,"discussions":[{"author":{"id":1877634,"avatar":"","nickname":"sunshinelius","note":"","ucode":"50F35834586E4A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":565826,"discussion_content":"是的。一讲的内容篇幅主要讲的是单元测试在整体中的位置，方向和关注点，相当于建立起一个架子。至于血肉的细节，可以参照我为本专栏创建的Github Repository，https://github.com/sheng-geek-zhuanlan/awesome-test-automation，这里搜集了一些很好的素材资料！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650547514,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":356489,"user_name":"Geek_2f2844","can_delete":false,"product_type":"c1","uid":3160604,"ip_address":"中国香港","ucode":"69E4E05A096747","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqE0GaxHXGoJbWk2F2cYoClmwyulCzUgqMj9u3xzBfEkqLRfvd08o1Fd9WMAfJFHUKU6hhjEDSCGQ/132","comment_is_top":false,"comment_ctime":1662363197,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662363197","product_id":100109201,"comment_content":"老师您本章只讲了单元测试、集成测试和UI测试，没有讲到接口测试，是因为这块对测试来说最熟悉么。不过我理解集成测试也算是接口测试的一种吧，主要关注与外部服务交互的接口测试","like_count":0},{"had_liked":false,"id":353005,"user_name":"羊羊","can_delete":false,"product_type":"c1","uid":1162597,"ip_address":"日本","ucode":"B220CE8D1CA5DA","user_header":"https://static001.geekbang.org/account/avatar/00/11/bd/65/fbdf4fc1.jpg","comment_is_top":false,"comment_ctime":1659075252,"is_pvip":false,"replies":[{"id":"128648","content":"| client                               | service<br>sendEmailChangeMessage.  |.   recieveEmailChangeMessage<br><br>Mock的是MessageBus的service，SendEmailChangeMessage是Message Bus的client。Mock MessageBus Service只需返回期望结果。","user_name":"作者回复","user_name_real":"编辑","uid":"1877634","ctime":1659880000,"ip_address":"日本","comment_id":353005,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1659075252","product_id":100109201,"comment_content":"想问下老师，为什么测试用例需要“5. 检验 Mock 的 MessageBus 里的消息”？Moke 的 MessageBus 需要实现SendEmailChangedMessage的功能么？还是只需要按照 IMessageBus 中的定义返回期望结果？","like_count":0,"discussions":[{"author":{"id":1877634,"avatar":"","nickname":"sunshinelius","note":"","ucode":"50F35834586E4A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583034,"discussion_content":"| client                               | service\nsendEmailChangeMessage.  |.   recieveEmailChangeMessage\n\nMock的是MessageBus的service，SendEmailChangeMessage是Message Bus的client。Mock MessageBus Service只需返回期望结果。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659880000,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"日本"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345689,"user_name":"swordman","can_delete":false,"product_type":"c1","uid":1002980,"ip_address":"","ucode":"F6719BD5E20B37","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/e4/94b543c3.jpg","comment_is_top":false,"comment_ctime":1652511892,"is_pvip":false,"replies":[{"id":"126309","content":"是的，黑盒方法，白盒方法，条条大路通罗马！","user_name":"作者回复","user_name_real":"编辑","uid":"1877634","ctime":1652882509,"ip_address":"","comment_id":345689,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1652511892","product_id":100109201,"comment_content":"找到Happy Path，除了看代码以外，我想到的一个办法，是通过覆盖率把Happy path找出来。把这些测试案例都执行一遍，看依赖代码类的覆盖情况，如果能一个或几个的组合，能覆盖到所有的外部依赖交互点，就找到了Happy path。","like_count":0,"discussions":[{"author":{"id":1877634,"avatar":"","nickname":"sunshinelius","note":"","ucode":"50F35834586E4A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572647,"discussion_content":"是的，黑盒方法，白盒方法，条条大路通罗马！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652882510,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342363,"user_name":"lisa","can_delete":false,"product_type":"c1","uid":1508049,"ip_address":"","ucode":"62CB6333CBF7B6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLw3jpao45frZibQIAicWBfc7ofgrm5gJLiaFQSj5u2DDvkjy3ia5goicJLJlgVtZ0HryiaXb2VqpTSQT5Q/132","comment_is_top":false,"comment_ctime":1650206657,"is_pvip":false,"replies":[{"id":"125262","content":"没错。可控还是不可控，是一个没有明确的分界线。可以加进技术，项目，团队的因素来综合考虑。","user_name":"作者回复","user_name_real":"编辑","uid":"1877634","ctime":1650547903,"ip_address":"","comment_id":342363,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1650206657","product_id":100109201,"comment_content":"我理解完全可控依赖和不完全可控依赖不是一个推荐策略或者二选一策略，他是一个组合策略。这个组合也是有技巧的，需要建立在对不完全可控依赖的对象的逻辑理解上吧？","like_count":0,"discussions":[{"author":{"id":1877634,"avatar":"","nickname":"sunshinelius","note":"","ucode":"50F35834586E4A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":565833,"discussion_content":"没错。可控还是不可控，是一个没有明确的分界线。可以加进技术，项目，团队的因素来综合考虑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650547903,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}