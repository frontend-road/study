{"id":80311,"title":"浏览器：一个浏览器是如何工作的（阶段三）","content":"<p>你好，我是winter。</p><p>在上一节课中，我已经讲了浏览器的DOM构建过程，但是这个构建的DOM，实际上信息是不全的，它只有节点和属性，不包含任何的样式信息。</p><p>我们这一节课就来讲讲：浏览器是如何把CSS规则应用到节点上，并给这棵朴素的DOM树添加上CSS属性的。</p><h2>整体过程</h2><p>首先我们还是要感性地理解一下这个过程。</p><p>首先CSS选择器这个名称，可能会给你带来一定的误解，觉得好像CSS规则是DOM树构建好了以后，再进行选择并给它添加样式的。实际上，这个过程并不是这样的。</p><p>我们回忆一下我们在浏览器第一节课讲的内容，浏览器会尽量流式处理整个过程。我们上一节课构建DOM的过程是：从父到子，从先到后，一个一个节点构造，并且挂载到DOM树上的，那么这个过程中，我们是否能同步把CSS属性计算出来呢？</p><p>答案是肯定的。</p><p>在这个过程中，我们依次拿到上一步构造好的元素，去检查它匹配到了哪些规则，再根据规则的优先级，做覆盖和调整。所以，从这个角度看，所谓的选择器，应该被理解成“匹配器”才更合适。</p><p>我在CSS语法部分，已经总结了选择器的各种符号，这里再把它列出来，我们回顾一下。</p><ul>\n<li>空格: 后代，选中它的子节点和所有子节点的后代节点。</li>\n<li>&gt;: 子代，选中它的子节点。</li>\n<li>+：直接后继选择器，选中它的下一个相邻节点。</li>\n<li>~：后继，选中它之后所有的相邻节点。</li>\n<li>||：列，选中表格中的一列。</li>\n</ul><!-- [[[read_end]]] --><p>关于选择器的知识，我会在CSS的部分继续讲解。这里我们主要介绍浏览器是如何实现这些规则的。</p><p>不知道你有没有发现，这里的选择器有个特点，那就是选择器的出现顺序，必定跟构建DOM树的顺序一致。这是一个CSS设计的原则，即保证选择器在DOM树构建到当前节点时，已经可以准确判断是否匹配，不需要后续节点信息。</p><p>也就是说，未来也不可能会出现“父元素选择器”这种东西，因为父元素选择器要求根据当前节点的子节点，来判断当前节点是否被选中，而父节点会先于子节点构建。</p><p>理解了CSS构建的大概过程，我们下面来看看具体的操作。</p><p>首先，我们必须把CSS规则做一下处理。作为一门语言，CSS需要先经过词法分析和语法分析，变成计算机能够理解的结构。</p><p>这部分具体的做法属于编译原理的内容，这里就不做赘述了。我们这里假设CSS已经被解析成了一棵可用的抽象语法树。</p><p>我们在之前的CSS课程中已经介绍过 compound-selector 的概念，一个 compound-selector 是检查一个元素的规则，而一个复合型选择器，则是由数个 compound-selector 通过前面讲的符号连接起来的。</p><h2>后代选择器 “空格”</h2><p>我们先来分析一下后代选择器，我们来一起看一个例子：</p><pre><code>a#b .cls {\n    width: 100px;\n}\n</code></pre><p>可以把一个CSS选择器按照 compound-selector 来拆成数段，每当满足一段条件的时候，就前进一段。</p><p>比如，在上面的例子中，当我们找到了匹配a#b的元素时，我们才会开始检查它所有的子代是否匹配 .cls。</p><p>除了前进一段的情况，我们还需要处理后退的情况，比如，我们这样一段代码：</p><pre><code>&lt;a id=b&gt;\n    &lt;span&gt;1&lt;span&gt;\n    &lt;span class=cls&gt;2&lt;span&gt;\n&lt;/a&gt;\n&lt;span class=cls&gt;3&lt;span&gt;\n</code></pre><p>当遇到 &lt;/a&gt;时，必须使得规则 a#b .cls 回退一步，这样第三个 span 才不会被选中。后代选择器的作用范围是父节点的所有子节点，因此规则是在匹配到本标签的结束标签时回退。</p><h2>后继选择器“ ~ ”</h2><p>接下来我们看下后继选择器，跟后代选择器不同的地方是，后继选择器只作用于一层，我们来看一个例子：</p><pre><code>.cls~* {\n    border:solid 1px green;\n}\n&lt;div&gt;\n&lt;span&gt;1&lt;span&gt;\n&lt;span class=cls&gt;2&lt;span&gt;\n&lt;span&gt;\n    3\n    &lt;span&gt;4&lt;/span&gt;\n&lt;span&gt;\n&lt;span&gt;5&lt;/span&gt;\n&lt;/div&gt;\n</code></pre><p>这里 .cls 选中了 span 2 然后 span 3 是它的后继，但是span 3的子节点 span 4 并不应该被选中，而span 5也是它的后继，因此应该被选中。</p><p>按照DOM树的构造顺序，4在3和5中间，我们就没有办法像前面讲的后代选择器一样通过激活或者关闭规则来实现匹配。</p><p>但是这里有个非常方便的思路，就是给选择器的激活，带上一个条件：父元素。</p><p>注意，这里后继选择器，当前半段的 .cls 匹配成功时，后续 * 所匹配的所有元素的父元素都已经确定了（后继节点和当前节点父元素相同是充分必要条件）。在我们的例子中，那个div就是后继节点的父元素。</p><h2>子代选择器“ &gt;”</h2><p>我们继续看，子代选择器是如何实现的。</p><p>实际上，有了前面讲的父元素这个约束思路，我们很容易实现子代选择器。区别仅仅是拿当前节点作为父元素，还是拿当前节点的父元素作为父元素。</p><pre><code>div&gt;.cls {\n    border:solid 1px green;\n}\n&lt;div&gt;\n&lt;span&gt;1&lt;span&gt;\n&lt;span class=cls&gt;2&lt;span&gt;\n&lt;span&gt;\n    3\n    &lt;span&gt;4&lt;/span&gt;\n&lt;span&gt;\n&lt;span&gt;5&lt;/span&gt;\n&lt;/div&gt;\n</code></pre><p>我们看这段代码，当DOM树构造到div时，匹配了CSS规则的第一段，因为是子代选择器，我们激活后面的 .cls选择条件，并且指定父元素必须是当前div。于是后续的构建DOM树构建过程中，span 2 就被选中了。</p><h2>直接后继选择器“ +”</h2><p>直接后继选择器的实现是上述中最为简单的了，因为它只对唯一一个元素生效，所以不需要像前面几种一样反复激活和关闭规则。</p><p>一个最简单的思路是，我们可以把它当作检查元素自身的选择器来处理。即我们把#id+.cls都当做检查某一个元素的选择器。</p><p>另外的一种思路是：给后继选择器加上一个flag，使它匹配一次后失效。你可以尝试一下，告诉我结果。</p><h2>列选择器“ || ”</h2><p>列选择器比较特别，它是专门针对表格的选择器，跟表格的模型建立相关，我们这里不详细讲了。</p><h2>其它</h2><p>我们不要忘记，CSS选择器还支持逗号分隔，表示“或”的关系。这里最简单的实现是把逗号视为两条规则的一种简易写法。</p><p>比如：</p><pre><code>a#b, .cls {\n\n}\n</code></pre><p>我们当作两条规则来处理：</p><pre><code>a#b {\n\n}\n</code></pre><pre><code>.cls {\n\n}\n</code></pre><p>还有一个情况，就是选择器可能有重合，这样，我们可以使用树形结构来进行一些合并，来提高效率：</p><pre><code>#a .cls {\n\n}\n\n#a span {\n\n}\n#a&gt;span {\n\n}\n</code></pre><p>这里实际上可以把选择器构造成一棵树：</p><ul>\n<li>#a\n<ul>\n<li>&lt;空格&gt;.cls</li>\n<li>&lt;空格&gt;span</li>\n<li>&gt;span</li>\n</ul>\n</li>\n</ul><p>需要注意的是，这里的树，必须要带上连接符。</p><h2>结语</h2><p>这一节我们讲解了CSS计算的过程。CSS计算是把CSS规则应用到DOM树上，为DOM结构添加显示相关属性的过程。在这一节中，我们主要介绍了选择器的几种复合结构应该如何实现。</p><p>在这一步骤之后，我们得到了一棵带有CSS属性的树，为我们后续打下了基础。</p><p>最后留一个问题，你认为CSS语法解析成什么结构，最适合我们进行CSS计算。</p><p><img src=\"https://static001.geekbang.org/resource/image/a1/9d/a1fa9a462fb96ae3a70ff4751203d79d.jpg?wh=1110*549\" alt=\"\"></p>","neighbors":{"left":{"article_title":"浏览器：一个浏览器是如何工作的？（阶段二）","id":80260},"right":{"article_title":"浏览器：一个浏览器是如何工作的？（阶段四）","id":81730}},"comments":[{"had_liked":false,"id":67240,"user_name":"coma","can_delete":false,"product_type":"c1","uid":1385887,"ip_address":"","ucode":"06111226BCC6BE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Fcx276V5ZyrYtGuWiaWQugKMX4aicY8cibicQISyiaAEKZKVmdz8apIhKzCfIZolyetSFXbl2gHSK9qZT5moJkk7DYg/132","comment_is_top":false,"comment_ctime":1550114435,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"340852530819","product_id":100023201,"comment_content":"之前选择器是从右往左匹配，好像跟这里的说法不一致，是理解错了吗？","like_count":79,"discussions":[{"author":{"id":2131769,"avatar":"","nickname":"Ivan7285","note":"","ucode":"33B2F5D919A9B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352031,"discussion_content":"css构建顺序是和dom一致的-也就是从根节点开始深度遍历，【计算】出每个节点最后的css规则；选择器从右往左匹配 其实描述的是【计算】的步骤，说的是对于每个节点，在做选择器层级解析时，是从右边往左读，从而减少回溯时间。 所以这两句话是描述不同过程的，并不冲突。 举个例子，假设有以下代码：\n```\n.test p{\n   color: red;\n}\n\n<body>\n  <div class=&#34;test&#34;>\n     <p>\n       demo \n     </p>\n   </div>\n</body>\n```\n在这个例子中 我们构建dom树以及计算css的顺序是 body > div > p ... ， 但是在计算css规则的过程， 例如计算到p节点时，先去寻找所有的rule(题设中就一条)， 然后匹配选择器时， 顺序是：\n   1. 先判断当前是否是p节点， 符合条件 所以继续比对；\n   2. 判断当前节点的父节点class是否为test； 符合条件\n   3....\n所以构建css规则的顺序是与dom一致的； 而css匹配器的选择器就是从右到左的","likes_number":12,"is_delete":false,"is_hidden":false,"ctime":1614580016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1374445,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f8/ed/60fb8fba.jpg","nickname":"陈小渣👻","note":"","ucode":"6B968B06C76C63","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":265730,"discussion_content":"具体请看下面 老师回答flow 的问题。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589431738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1156074,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a3/ea/53333dd5.jpg","nickname":"HoSalt","note":"","ucode":"610B03E2A002D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":241758,"discussion_content":"+1","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587438472,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1634746,"avatar":"","nickname":"laor狼","note":"","ucode":"DFA22F4AEA02BD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286954,"discussion_content":"+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593332434,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1698735,"avatar":"https://static001.geekbang.org/account/avatar/00/19/eb/af/e49af9a8.jpg","nickname":"JC.彦","note":"","ucode":"E87C1420B140F4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261886,"discussion_content":"同样疑惑，望解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589019254,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1028395,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b1/2b/79b81df8.jpg","nickname":"iamcxc","note":"","ucode":"C519F51552DC12","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215099,"discussion_content":"是啊，我读到这里也感觉很疑惑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585285544,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":67156,"user_name":"以勒","can_delete":false,"product_type":"c1","uid":1380700,"ip_address":"","ucode":"A03A1FD784A5B1","user_header":"https://static001.geekbang.org/account/avatar/00/15/11/5c/9f6827cc.jpg","comment_is_top":false,"comment_ctime":1550105306,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"138989058778","product_id":100023201,"comment_content":"css的渲染过程：<br>1. 流式渲染，每生成一个dom节点，便立刻去匹配相应的css规则<br><br>2. dom节点的生成顺序是 从父-&gt; 子。 css的渲染顺序也是   从 父节点-》子节点<br><br>3.混合选择器 在激活的时候父元素已经确定好了 。 后代选择器，所有元素都是父元素，并 选中自己的子元素。  子元素 选择器，只有父元素为当前节点的 dom  元素会被选中。 在父元素 结束标签时，关闭 选择器。<br><br>","like_count":32},{"had_liked":false,"id":67205,"user_name":"啊柴","can_delete":false,"product_type":"c1","uid":1377252,"ip_address":"","ucode":"D8EC8C6BB38F84","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/0clFBGW3KxGFmV1dNxjoA5nQkdNW6QoiaNMPdrnYB5eNPpMypRy078fZRE8ysXRte27Lt1lkErm0DIqb5xf88ibw/132","comment_is_top":false,"comment_ctime":1550110252,"is_pvip":false,"replies":[{"id":"23840","content":"浏览器编写本身有不同的思路，但是按关键选择器这个思路，据我所知还没有实现。","user_name":"作者回复","user_name_real":"winter","uid":"1268524","ctime":1550148317,"ip_address":"","comment_id":67205,"utype":1}],"discussion_count":1,"race_medal":0,"score":"74564554284","product_id":100023201,"comment_content":"老师好，文中后代选择器是说先检查父级，匹配后再检查子级，以前学习看到比较多的一种说法是从关键选择器开始匹配，然后左移查找选择器的祖先元素，实践中也一直把最后一个选择器权重加高。请问这是从开始就学错了，还是我对两种说法理解有偏差呢？","like_count":17,"discussions":[{"author":{"id":1268524,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5b/2c/12bfd3cd.jpg","nickname":"winter","note":"","ucode":"2B068EDEAFEB56","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439094,"discussion_content":"浏览器编写本身有不同的思路，但是按关键选择器这个思路，据我所知还没有实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550148317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":67331,"user_name":"南半边翅膀","can_delete":false,"product_type":"c1","uid":1383624,"ip_address":"","ucode":"6914E43AFA55D6","user_header":"https://static001.geekbang.org/account/avatar/00/15/1c/c8/c3f867c6.jpg","comment_is_top":false,"comment_ctime":1550130784,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"70269607520","product_id":100023201,"comment_content":"dom树构建与cssom构建有先后关系吗？css计算与dom树流式构建同步进行是不是意味着dom树流式构建之前cssom已经构建完成呢？","like_count":16},{"had_liked":false,"id":71598,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1551399455,"is_pvip":true,"replies":[{"id":"25934","content":"我这里说的确实有点歧义，cssom是有rule部分和view部分的，rule部分是在dom开始之前就构件完成的，而view部分是跟着dom同步构建的。","user_name":"作者回复","user_name_real":"winter","uid":"1268524","ctime":1551433394,"ip_address":"","comment_id":71598,"utype":1}],"discussion_count":1,"race_medal":1,"score":"61680941599","product_id":100023201,"comment_content":"老师，对于这个问题，我也有疑问：<br>dom树构建与cssom构建有先后关系吗？css计算与dom树流式构建同步进行是不是意味着dom树流式构建之前cssom已经构建完成呢？","like_count":15,"discussions":[{"author":{"id":1268524,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5b/2c/12bfd3cd.jpg","nickname":"winter","note":"","ucode":"2B068EDEAFEB56","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441226,"discussion_content":"我这里说的确实有点歧义，cssom是有rule部分和view部分的，rule部分是在dom开始之前就构件完成的，而view部分是跟着dom同步构建的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551433394,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":67823,"user_name":"flow","can_delete":false,"product_type":"c1","uid":1270302,"ip_address":"","ucode":"B482ACF0E413C7","user_header":"https://static001.geekbang.org/account/avatar/00/13/62/1e/ad721e61.jpg","comment_is_top":false,"comment_ctime":1550286809,"is_pvip":true,"replies":[{"id":"24329","content":"head中的css是要下载完的，body中放CSS的话，会重新计算。","user_name":"作者回复","user_name_real":"winter","uid":"1268524","ctime":1550552048,"ip_address":"","comment_id":67823,"utype":1}],"discussion_count":3,"race_medal":0,"score":"61679828953","product_id":100023201,"comment_content":"请问DOM去匹配css rule的时候是不是必须先等页面的css都下载完成后才会去匹配的？否则如果DOM匹配的时候对应的css还没下载完，后面怎么得到正确的css？","like_count":14,"discussions":[{"author":{"id":1268524,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5b/2c/12bfd3cd.jpg","nickname":"winter","note":"","ucode":"2B068EDEAFEB56","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439387,"discussion_content":"head中的css是要下载完的，body中放CSS的话，会重新计算。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1550552048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1167046,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ce/c6/958212b5.jpg","nickname":"sugar","note":"","ucode":"454538FF253B5F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":28429,"discussion_content":"那么如果head中没有link或style标签，但是body里第一行就用一个script去动态往head中插一条link，此时是否要等这个link加载完再去匹配呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570696896,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1073923,"avatar":"https://static001.geekbang.org/account/avatar/00/10/63/03/a7d2bf8b.jpg","nickname":"王晴","note":"","ucode":"22ED1993101732","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4807,"discussion_content":"正想问这个问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565748967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":67203,"user_name":"嗯喊我杰哥","can_delete":false,"product_type":"c1","uid":1384041,"ip_address":"","ucode":"7B7025FE7EC954","user_header":"https://static001.geekbang.org/account/avatar/00/15/1e/69/ddb4f98c.jpg","comment_is_top":false,"comment_ctime":1550110185,"is_pvip":false,"replies":[{"id":"23841","content":"意思是DOM树构造到父节点的时候，还不知道它有没有子节点，所以算不出来CSS。","user_name":"作者回复","user_name_real":"winter","uid":"1268524","ctime":1550148368,"ip_address":"","comment_id":67203,"utype":1}],"discussion_count":1,"race_medal":0,"score":"44499783145","product_id":100023201,"comment_content":"&lt;也就是说，未来也不可能会出现“父元素选择器”这种东西，<br>因为父元素选择器要求根据当前节点的子节点，来判断当前节点是否被选中，而父节点会先于子节点构建。&gt;<br><br>这句话后半句好难理解，有大神能通俗地解释一下吗<br>","like_count":10,"discussions":[{"author":{"id":1268524,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5b/2c/12bfd3cd.jpg","nickname":"winter","note":"","ucode":"2B068EDEAFEB56","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439093,"discussion_content":"意思是DOM树构造到父节点的时候，还不知道它有没有子节点，所以算不出来CSS。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550148368,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":70710,"user_name":"乃乎","can_delete":false,"product_type":"c1","uid":1393061,"ip_address":"","ucode":"03F587A06051AC","user_header":"https://static001.geekbang.org/account/avatar/00/15/41/a5/16c615cc.jpg","comment_is_top":false,"comment_ctime":1551168092,"is_pvip":false,"replies":[{"id":"25921","content":"其实Selector Level 4里面已经打破这个规则了，现在还是draft，也不知道最后能不能过。<br><br>要是真过了 webkit这块差不多得重写……","user_name":"作者回复","user_name_real":"winter","uid":"1268524","ctime":1551432321,"ip_address":"","comment_id":70710,"utype":1}],"discussion_count":2,"race_medal":0,"score":"31615939164","product_id":100023201,"comment_content":"CSS 没有父选择器那里讲得太好了，这个原因不能更合理","like_count":7,"discussions":[{"author":{"id":1268524,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5b/2c/12bfd3cd.jpg","nickname":"winter","note":"","ucode":"2B068EDEAFEB56","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440787,"discussion_content":"其实Selector Level 4里面已经打破这个规则了，现在还是draft，也不知道最后能不能过。\n\n要是真过了 webkit这块差不多得重写……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551432321,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1444483,"avatar":"https://static001.geekbang.org/account/avatar/00/16/0a/83/f916f903.jpg","nickname":"风","note":"","ucode":"E1CE0825AAF805","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1268524,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5b/2c/12bfd3cd.jpg","nickname":"winter","note":"","ucode":"2B068EDEAFEB56","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":543221,"discussion_content":"感觉现在流式处理html和css的收益不大了，打破就打破呗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641007111,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":440787,"ip_address":""},"score":543221,"extra":""}]}]},{"had_liked":false,"id":67125,"user_name":"CC","can_delete":false,"product_type":"c1","uid":1021014,"ip_address":"","ucode":"2B732860C4231B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/94/56/4b8395f6.jpg","comment_is_top":false,"comment_ctime":1550084165,"is_pvip":true,"replies":[{"id":"23845","content":"哈哈 CSSOM不是这样子的，CSSOM主要是DOM结构上的盒的描述，它基本上是依附于DOM树的。<br><br>你说的这个东西，比较接近的是CSS的语法树。","user_name":"作者回复","user_name_real":"winter","uid":"1268524","ctime":1550148636,"ip_address":"","comment_id":67125,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31614855237","product_id":100023201,"comment_content":"第一反应猜测 CSS 语法应该解析成对象（Object），然后根据 DOM 的树形结构，CSS 也会生成自己的树形结构。<br><br>查找验证后发现，这被称为 CSSOM（CSS Object Model）。<br><br>举个 CSSOM 的例子：<br><br>body {font-size: 16px;}<br>h1 {font-size: 2rem;}<br>.orange {color: orange;}<br>div {margin: 1rem 0;}<br>div p {padding-bottom: 1rem;}<br><br>从根结点 body 开始，树形结构如下：<br><br>* body {font-size: 16px;}<br>    * h1 {font-size: 2rem;}<br>    * .orange {color: orange;}<br>    * div {margin: 1rem 0;}<br>        * div p {padding-bottom: 1rem;}<br><br>不知道这样理解是否准确？<br>","like_count":7,"discussions":[{"author":{"id":1268524,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5b/2c/12bfd3cd.jpg","nickname":"winter","note":"","ucode":"2B068EDEAFEB56","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439068,"discussion_content":"哈哈 CSSOM不是这样子的，CSSOM主要是DOM结构上的盒的描述，它基本上是依附于DOM树的。\n\n你说的这个东西，比较接近的是CSS的语法树。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550148636,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":67831,"user_name":"flow","can_delete":false,"product_type":"c1","uid":1270302,"ip_address":"","ucode":"B482ACF0E413C7","user_header":"https://static001.geekbang.org/account/avatar/00/13/62/1e/ad721e61.jpg","comment_is_top":false,"comment_ctime":1550289123,"is_pvip":true,"replies":[{"id":"24330","content":"哈哈，是这样的没错，但是你看，新加了这么多运算符，所以思路也会有不一样。<br><br>其实浏览器实现是比较懒的，直接每条规则都检查了，没做合并优化。","user_name":"作者回复","user_name_real":"winter","uid":"1268524","ctime":1550552137,"ip_address":"","comment_id":67831,"utype":1}],"discussion_count":2,"race_medal":0,"score":"27320092899","product_id":100023201,"comment_content":"看到老师一个分享会的视频，说到DOM匹配css rule的时候是从右往左匹配的，为什么跟文章提到的后代选择器的匹配顺序相反呢？","like_count":6,"discussions":[{"author":{"id":1268524,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5b/2c/12bfd3cd.jpg","nickname":"winter","note":"","ucode":"2B068EDEAFEB56","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439389,"discussion_content":"哈哈，是这样的没错，但是你看，新加了这么多运算符，所以思路也会有不一样。\n\n其实浏览器实现是比较懒的，直接每条规则都检查了，没做合并优化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550552137,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1317034,"avatar":"https://static001.geekbang.org/account/avatar/00/14/18/aa/b1dacb64.jpg","nickname":"Rainnut","note":"","ucode":"4BB3DDC637C9C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333623,"discussion_content":"同学你好，我之前也看了那个视频，但是忘记网址了，方便提供一下吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607581457,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130820,"user_name":"胡永","can_delete":false,"product_type":"c1","uid":1200543,"ip_address":"","ucode":"6C8BA1E0BED9C0","user_header":"https://static001.geekbang.org/account/avatar/00/12/51/9f/1840385e.jpg","comment_is_top":false,"comment_ctime":1567556924,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14452458812","product_id":100023201,"comment_content":"css选择器这里面最重要的一条规则就是没有父选择器，根据流式处理的dom规则，这样就节省了很多的重新计算","like_count":3},{"had_liked":false,"id":73606,"user_name":"🐻🔫🐸","can_delete":false,"product_type":"c1","uid":1308880,"ip_address":"","ucode":"40BABFD9D358BF","user_header":"https://static001.geekbang.org/account/avatar/00/13/f8/d0/ecc68a4f.jpg","comment_is_top":false,"comment_ctime":1551938915,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14436840803","product_id":100023201,"comment_content":"我发现关于CSS选择从右到左开始匹配的理论网上还是有很多相关资料的，https:&#47;&#47;www.sitepoint.com&#47;optimizing-css-id-selectors-and-other-myths&#47;<br>看起来应该还是有点道理？不过这个东西浏览器引擎应该也会不断优化，不同版本不同引擎都可能有差异","like_count":3},{"had_liked":false,"id":75665,"user_name":"Young！","can_delete":false,"product_type":"c1","uid":1025221,"ip_address":"","ucode":"2A658CEFD26011","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a4/c5/a53f8bbc.jpg","comment_is_top":false,"comment_ctime":1552446126,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10142380718","product_id":100023201,"comment_content":"老师，请问一下您说的「后退，前进」的含义，不太理解<br><br>a#b .cls 这个选择器中，分成 a#b 和 .cls ，当 DOM 树构造到 &lt;a id=b&gt; 这个节点时，css 匹配 a#b，并且「前进」看是否自带是否有 class=&quot;cls&quot; 的元素，这里可能会有指针这个抽象，指向 .cls，当 DOM 树构建到 &lt;&#47;a&gt; 这里时，css 选择器指针「后退」到 a#b 这里，然后继续构造 DOM 树，而且这个选择器已经被构造所谓的 css 树之类的，只是指针会有回退和前进的时候<br><br>可以这样理解吗<br><br>","like_count":2},{"had_liked":false,"id":68929,"user_name":"Dylan-Tseng","can_delete":false,"product_type":"c1","uid":1394866,"ip_address":"","ucode":"7AE86CFAD0B7E1","user_header":"","comment_is_top":false,"comment_ctime":1550629031,"is_pvip":false,"replies":[{"id":"25792","content":"并不管有没有子元素，只是让这条规则前进一格。","user_name":"作者回复","user_name_real":"winter","uid":"1268524","ctime":1551423218,"ip_address":"","comment_id":68929,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10140563623","product_id":100023201,"comment_content":"请问老师，有一点不是很明白，如果是在构建dom树的同时，就开始构建css，带空格选择子元素的时候，css怎么知道dom树有没有构建完成，是否有没有子元素，是怎么做匹配的？","like_count":2,"discussions":[{"author":{"id":1268524,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5b/2c/12bfd3cd.jpg","nickname":"winter","note":"","ucode":"2B068EDEAFEB56","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439875,"discussion_content":"并不管有没有子元素，只是让这条规则前进一格。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551423218,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105239,"user_name":"Jaykey","can_delete":false,"product_type":"c1","uid":1167992,"ip_address":"","ucode":"535FEA1292D290","user_header":"https://static001.geekbang.org/account/avatar/00/11/d2/78/1f1b45f9.jpg","comment_is_top":false,"comment_ctime":1560943768,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5855911064","product_id":100023201,"comment_content":"空格，和后代选择器有什么不一样吗？","like_count":1,"discussions":[{"author":{"id":1640865,"avatar":"https://static001.geekbang.org/account/avatar/00/19/09/a1/2cc5f83a.jpg","nickname":"禾+米","note":"","ucode":"2B718466BD0841","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294208,"discussion_content":"空格，后代选择器，子孙都是后代\n>，子代选择器，需要匹配的元素之间是严格的父子关系，不包括爷孙...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595828901,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1520355,"avatar":"https://static001.geekbang.org/account/avatar/00/17/32/e3/20676888.jpg","nickname":"涂涂","note":"","ucode":"A36AE853DD0A30","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3502,"discussion_content":"是一样的，换种称呼而已，好比马铃薯和土豆有什么不一样，番茄和西红柿有什么不一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564540209,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92377,"user_name":"KB24_钱昊","can_delete":false,"product_type":"c1","uid":1384876,"ip_address":"","ucode":"9E59A432CABFF2","user_header":"https://static001.geekbang.org/account/avatar/00/15/21/ac/71453cf7.jpg","comment_is_top":false,"comment_ctime":1557241289,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5852208585","product_id":100023201,"comment_content":"程老师你好。我在很多地方看到的说法是：CSS会阻塞dom渲染，但不会阻塞dom的解析，且CSS文件的请求是异步请求。<br>那么如果按照上面文章中所说，DOM的构建和CSS属性的计算是同步的话，head中CSS文件的下载以及CSSOM的rule部分的构建应该会阻塞HTML的解析和DOM的构建。<br>好像这两种说法之间就有了冲突。。麻烦程老师有空的时候可以帮忙解释一下，万分感谢～","like_count":1,"discussions":[{"author":{"id":1100750,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cb/ce/d9e00eb5.jpg","nickname":"undefined","note":"","ucode":"768098DBDBE333","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363387,"discussion_content":"专注搞培训了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1617185246,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91989,"user_name":"超人","can_delete":false,"product_type":"c1","uid":1375737,"ip_address":"","ucode":"6E057AC7137781","user_header":"https://static001.geekbang.org/account/avatar/00/14/fd/f9/3662c371.jpg","comment_is_top":false,"comment_ctime":1557149824,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5852117120","product_id":100023201,"comment_content":"div&gt;.cls {<br>    border:solid 1px green;<br>}<br>&lt;div&gt;<br>&lt;span&gt;1&lt;&#47;span&gt;<br>&lt;span class=cls&gt;2&lt;&#47;span&gt;<br>&lt;span&gt;<br>    3<br>    &lt;span&gt;4&lt;&#47;span&gt;<br>&lt;&#47;span&gt;<br>&lt;span&gt;5&lt;&#47;span&gt;<br>&lt;&#47;div&gt;<br>Span的闭合是这样的吗？这里我有点不确定","like_count":1},{"had_liked":false,"id":69803,"user_name":"啊咩","can_delete":false,"product_type":"c1","uid":1376521,"ip_address":"","ucode":"D6CEFFFA27F10B","user_header":"https://static001.geekbang.org/account/avatar/00/15/01/09/a35710f0.jpg","comment_is_top":false,"comment_ctime":1550847628,"is_pvip":false,"replies":[{"id":"25828","content":"Selector Level 3里的，不过不太重要，不用太在意。","user_name":"作者回复","user_name_real":"winter","uid":"1268524","ctime":1551424906,"ip_address":"","comment_id":69803,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5845814924","product_id":100023201,"comment_content":"|| 列选择器  是最新的标准出的吗？ 我在w3school和 菜鸟教程 都找不到这个选择器","like_count":1,"discussions":[{"author":{"id":1268524,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5b/2c/12bfd3cd.jpg","nickname":"winter","note":"","ucode":"2B068EDEAFEB56","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440291,"discussion_content":"Selector Level 3里的，不过不太重要，不用太在意。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551424906,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":68576,"user_name":"么么","can_delete":false,"product_type":"c1","uid":1391251,"ip_address":"","ucode":"1424F9F71F2452","user_header":"https://static001.geekbang.org/account/avatar/00/15/3a/93/56a99549.jpg","comment_is_top":false,"comment_ctime":1550547365,"is_pvip":false,"replies":[{"id":"24351","content":"是没错，浏览器多数实现是从右往左匹配的，这个说法早年我还设计过实验，但是现在我觉得这是比较偷懒的做法，实际上关于”实现“并没有一定的规定，我这里讲的也仅仅是一种思路。","user_name":"作者回复","user_name_real":"winter","uid":"1268524","ctime":1550553560,"ip_address":"","comment_id":68576,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5845514661","product_id":100023201,"comment_content":"按照文章的描述，css的匹配好像是从左到右匹配的，但是网上有很多文章说的是从右往左进行匹配的，这样的规则可以优化重复选择计算。那这种说法与文章上的是否右冲突？","like_count":1,"discussions":[{"author":{"id":1268524,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5b/2c/12bfd3cd.jpg","nickname":"winter","note":"","ucode":"2B068EDEAFEB56","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439738,"discussion_content":"是没错，浏览器多数实现是从右往左匹配的，这个说法早年我还设计过实验，但是现在我觉得这是比较偷懒的做法，实际上关于”实现“并没有一定的规定，我这里讲的也仅仅是一种思路。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550553560,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339594,"user_name":"*","can_delete":false,"product_type":"c1","uid":1710685,"ip_address":"","ucode":"DB5BA86B4D7E5C","user_header":"https://static001.geekbang.org/account/avatar/00/1a/1a/5d/3c8004c6.jpg","comment_is_top":false,"comment_ctime":1648210117,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648210117","product_id":100023201,"comment_content":"因为DOM是树形的，CSS依附于DOM树计算出样式属性，所以CSS语法也要用树的结构表示吧","like_count":0},{"had_liked":false,"id":295478,"user_name":"zgy","can_delete":false,"product_type":"c1","uid":1387798,"ip_address":"","ucode":"05EA6845199250","user_header":"https://static001.geekbang.org/account/avatar/00/15/2d/16/b525a71d.jpg","comment_is_top":false,"comment_ctime":1622444340,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622444340","product_id":100023201,"comment_content":"选择器嵌套层级过多会影响css计算时间吗？匹配结束会会回退到父元素。","like_count":0},{"had_liked":false,"id":99385,"user_name":"令狐洋葱","can_delete":false,"product_type":"c1","uid":1549519,"ip_address":"","ucode":"8AFD005B62E020","user_header":"https://static001.geekbang.org/account/avatar/00/17/a4/cf/a082eae7.jpg","comment_is_top":false,"comment_ctime":1559204015,"is_pvip":false,"replies":[{"id":"58955","content":"不是分批的，也跟JS无关。","user_name":"作者回复","user_name_real":"winter","uid":"1268524","ctime":1574227203,"ip_address":"","comment_id":99385,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559204015","product_id":100023201,"comment_content":"老师，DOM 和 CSSOM 都是流式构建的，按照您的讲解，我理解是 CSSOM 必须先解析好，才能和 DOM 做样式上的融合，然后流式绘制已经解析好的 DOM，单纯HTML的解析我认为时间是可以忽略不计的，遇到 script 标签才会导致 DOM 解析有停顿，这时候页面才会做渲染，所以我理解上的流式渲染是分批的，遇到 js 就立即渲染之前融合好的布局，不知道这样理解流式渲染是否正确？<br>还望老师指正，谢谢。","like_count":0,"discussions":[{"author":{"id":1268524,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5b/2c/12bfd3cd.jpg","nickname":"winter","note":"","ucode":"2B068EDEAFEB56","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452089,"discussion_content":"不是分批的，也跟JS无关。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574227203,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92652,"user_name":"小王","can_delete":false,"product_type":"c1","uid":1518743,"ip_address":"","ucode":"E6A4A243D83568","user_header":"https://static001.geekbang.org/account/avatar/00/17/2c/97/462a2c7f.jpg","comment_is_top":false,"comment_ctime":1557309356,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557309356","product_id":100023201,"comment_content":"处理后退的情况那里没太理解，当找到匹配了a#b的元素才开始检查它的所有子代是否匹配.cls。那第三个span节点不是a#b元素的子节点，它本身就不会被选中的。为什么文中提到“必须使得规则a#b .cls回退一步，这样第三个span才不会被选中”","like_count":0},{"had_liked":false,"id":92451,"user_name":"关山楂","can_delete":false,"product_type":"c1","uid":1499244,"ip_address":"","ucode":"C32E201FA33045","user_header":"https://static001.geekbang.org/account/avatar/00/16/e0/6c/ef405cc1.jpg","comment_is_top":false,"comment_ctime":1557276878,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557276878","product_id":100023201,"comment_content":"我还是比较认同，从左往右匹配的规则，这样就像老师讲的可以在构建dom树的同时来进行匹配css规则，相当于同时构建渲染树了，而不必等到dom构建完毕在进行css的规则匹配，进行构建渲染树，虽然从右向左匹配对于复杂的选择器更优，但是这里面浪费了等待dom构建完毕才能使用的css匹配规则。而且相对于同为id等单一选择器而言，明显从左向右更具有优势！这是我的一点想法，望老师指正！","like_count":0},{"had_liked":false,"id":92289,"user_name":"KB24_钱昊","can_delete":false,"product_type":"c1","uid":1384876,"ip_address":"","ucode":"9E59A432CABFF2","user_header":"https://static001.geekbang.org/account/avatar/00/15/21/ac/71453cf7.jpg","comment_is_top":false,"comment_ctime":1557221520,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557221520","product_id":100023201,"comment_content":"老师好。按照我自己的理解，head中css的下载以及cssom的rule部分的构建会阻塞HTML的解析和DOM的构建，不知道这样理解对不对。。","like_count":0},{"had_liked":false,"id":89076,"user_name":"Geek_c11e90","can_delete":false,"product_type":"c1","uid":1510252,"ip_address":"","ucode":"297417E0700558","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKVaNK1CMOiaJRzu8Srpkxic98vNo56hPU6a7RiacnnicPPicibxRQE7mqcE2F0NF39XDBIQPiazbjhcCpcg/132","comment_is_top":false,"comment_ctime":1556072008,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556072008","product_id":100023201,"comment_content":"老师 如果我想更深入的了解移动端的兼容问题，有没有好的学习路线呢","like_count":0},{"had_liked":false,"id":88334,"user_name":"young","can_delete":false,"product_type":"c1","uid":1472571,"ip_address":"","ucode":"4B5285A404E637","user_header":"https://static001.geekbang.org/account/avatar/00/16/78/3b/19ef632a.jpg","comment_is_top":false,"comment_ctime":1555906864,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555906864","product_id":100023201,"comment_content":"老师，CSS是如何依附在DOM树上的?是通过前面讲得Node实例来实现的?","like_count":0},{"had_liked":false,"id":87792,"user_name":"科瑞软件","can_delete":false,"product_type":"c1","uid":1383952,"ip_address":"","ucode":"153CBB2E77EB91","user_header":"","comment_is_top":false,"comment_ctime":1555710918,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1555710918","product_id":100023201,"comment_content":"老师，你在课程里面提到了3个词，叫文法，词法，语法，请问有什么区别吗？","like_count":0,"discussions":[{"author":{"id":1936087,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8a/d7/daabec34.jpg","nickname":"tequ1lAneio","note":"","ucode":"41336E87FF2E1A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":402766,"discussion_content":"词法就是文法，比如规定了哪些是关键字，哪些是变量，哪些是值；语法是让这些东西运行起来的规则。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633945623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1905171,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/12/13/e103a6e3.jpg","nickname":"扩散性百万咸面包","note":"","ucode":"6D703D51553B42","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":240104,"discussion_content":"这个推荐去看一下编译原理之美，补充一下知识","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587340106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79960,"user_name":"水木","can_delete":false,"product_type":"c1","uid":1342160,"ip_address":"","ucode":"3F063FB56E6ADA","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLetObiaicw0oSXWFdyg48hnaTXc2Fxc8JjwCgje3UybJH2UooK3K0oNRiah29iaIGcMNGVf3kWpajQiaQ/132","comment_is_top":false,"comment_ctime":1553583825,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553583825","product_id":100023201,"comment_content":"现在浏览器多数实现是从右往左匹配的，那么无法保证选择器在 DOM 树构建到当前节点时，已经可以准确判断当前节点是否被选中。问题来了， 那么现在浏览器又是怎么实现在生成dom树，同时进行css属性计算？","like_count":0},{"had_liked":false,"id":79911,"user_name":"Marvin","can_delete":false,"product_type":"c1","uid":1378026,"ip_address":"","ucode":"985D6CA5B9AD73","user_header":"https://static001.geekbang.org/account/avatar/00/15/06/ea/79f6671a.jpg","comment_is_top":false,"comment_ctime":1553572528,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553572528","product_id":100023201,"comment_content":"天呐，好细致啊~","like_count":0},{"had_liked":false,"id":77996,"user_name":"Geek_f121ae","can_delete":false,"product_type":"c1","uid":1465526,"ip_address":"","ucode":"3C8987D0D137FF","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLI6ibAJRoCG6nSwTq0XhkcrSjbEywn0b0p9PMOLXleKfuv1rzSib9w34VcqYfM3ibf7ll7BYy5pIR7Q/132","comment_is_top":false,"comment_ctime":1553051357,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553051357","product_id":100023201,"comment_content":"后代选择器和子代选择器有区别吗<br>","like_count":0},{"had_liked":false,"id":72366,"user_name":"大粒仔","can_delete":false,"product_type":"c1","uid":1383448,"ip_address":"","ucode":"8AF47367EC9F67","user_header":"https://static001.geekbang.org/account/avatar/00/15/1c/18/9b6a1f85.jpg","comment_is_top":false,"comment_ctime":1551598806,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551598806","product_id":100023201,"comment_content":"请问老师，developers.google上给出的树形结构的CSSOM是否就是解析css后得到的抽象语法树，DOM和CSSOM合并成的渲染树是不是相当于本文中添加了样式属性的DOM树","like_count":0},{"had_liked":false,"id":69580,"user_name":"liu志远","can_delete":false,"product_type":"c1","uid":1075249,"ip_address":"","ucode":"5C2A3DC5293408","user_header":"https://static001.geekbang.org/account/avatar/00/10/68/31/6212db56.jpg","comment_is_top":false,"comment_ctime":1550793838,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550793838","product_id":100023201,"comment_content":"这章没有dom解析好理解，老师提供些辅助资料吗","like_count":0},{"had_liked":false,"id":69558,"user_name":"渡松","can_delete":false,"product_type":"c1","uid":1385297,"ip_address":"","ucode":"372616783DFBA4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ereXO67Tb71gRRXOuMWaiaDkHq33d0KCfLmm0Vh0zkU1MRR6YHia6rZN4nRUPPjUZwLz5RLAg5mQ4RA/132","comment_is_top":false,"comment_ctime":1550765711,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550765711","product_id":100023201,"comment_content":"这一章好像大家都很困惑，能提供一下这个思路的一手资料么？","like_count":0},{"had_liked":false,"id":69271,"user_name":"薛定谔的🐶","can_delete":false,"product_type":"c1","uid":1384370,"ip_address":"","ucode":"83DAB9BDFFD267","user_header":"https://static001.geekbang.org/account/avatar/00/15/1f/b2/ff97d549.jpg","comment_is_top":false,"comment_ctime":1550710417,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550710417","product_id":100023201,"comment_content":"这里的选择器有个特点，那就是选择器的出现顺序，必定跟构建 DOM 树的顺序一致。这是一个 CSS 设计的原则，即保证选择器在 DOM 树构建到当前节点时，已经可以准确判断是否匹配，不需要后续节点信息。这句选择器出现的顺序是指什么呢？<br>为什么选择器的出现顺序和dom顺序一致","like_count":0},{"had_liked":false,"id":68758,"user_name":"noone","can_delete":false,"product_type":"c1","uid":1361044,"ip_address":"","ucode":"9920878DA538F6","user_header":"https://static001.geekbang.org/account/avatar/00/14/c4/94/f618d9a6.jpg","comment_is_top":false,"comment_ctime":1550593691,"is_pvip":true,"replies":[{"id":"25790","content":"哈哈，这个非标呀，而且是个伪元素，这个机制会比较复杂，但是其实选中根元素跟选中父元素是两码事。<br><br>不过Selector Level 4里面确实出现了违背这个原则的选择器了，不知道会不会正式通过。","user_name":"作者回复","user_name_real":"winter","uid":"1268524","ctime":1551423138,"ip_address":"","comment_id":68758,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1550593691","product_id":100023201,"comment_content":"“父元素” 选择器目前是有的，:-webkit-full-screen-ancestor","like_count":0,"discussions":[{"author":{"id":1268524,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5b/2c/12bfd3cd.jpg","nickname":"winter","note":"","ucode":"2B068EDEAFEB56","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439834,"discussion_content":"哈哈，这个非标呀，而且是个伪元素，这个机制会比较复杂，但是其实选中根元素跟选中父元素是两码事。\n\n不过Selector Level 4里面确实出现了违背这个原则的选择器了，不知道会不会正式通过。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551423138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}