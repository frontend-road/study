{"id":165248,"title":"13 | 代码模型（上）：如何使用DDD设计微服务代码模型？","content":"<p>你好，我是欧创新。</p><p>上一讲我们完成了领域模型的设计，接下来我们就要开始微服务的设计和落地了。那<span class=\"orange\">微服务落地时首先要确定的就是微服务的代码结构</span>，也就是我今天要讲的微服务代码模型。</p><p>只有建立了标准的微服务代码模型和代码规范后，我们才可以将领域对象所对应的代码对象放在合适的软件包的目录结构中。标准的代码模型可以让项目团队成员更好地理解代码，根据代码规范实现团队协作；还可以让微服务各层的逻辑互不干扰、分工协作、各据其位、各司其职，避免不必要的代码混淆。另外，标准的代码模型还可以让你在微服务架构演进时，轻松完成代码重构。</p><p>那在DDD里，微服务的代码结构长什么样子呢？我们又是依据什么来建立微服务代码模型？这就是我们今天重点要解决的两个问题。</p><h2>DDD分层架构与微服务代码模型</h2><p>我们参考DDD分层架构模型来设计微服务代码模型。没错！微服务代码模型就是依据DDD分层架构模型设计出来的。那为什么是DDD分层架构模型呢？</p><p><img src=\"https://static001.geekbang.org/resource/image/a3/01/a308123994f87a5ce99adc85dd9b4d01.jpg?wh=1106*996\" alt=\"\"></p><p>我们先简单回顾一下 <a href=\"https://time.geekbang.org/column/article/156849\">[第 07 讲]</a> 介绍过的DDD分层架构模型。它包括用户接口层、应用层、领域层和基础层，分层架构各层的职责边界非常清晰，又能有条不紊地分层协作。</p><ul>\n<li>用户接口层：面向前端提供服务适配，面向资源层提供资源适配。这一层聚集了接口适配相关的功能。</li>\n<li>应用层职责：实现服务组合和编排，适应业务流程快速变化的需求。这一层聚集了应用服务和事件相关的功能。</li>\n<li>领域层：实现领域的核心业务逻辑。这一层聚集了领域模型的聚合、聚合根、实体、值对象、领域服务和事件等领域对象，以及它们组合所形成的业务能力。</li>\n<li>基础层：贯穿所有层，为各层提供基础资源服务。这一层聚集了各种底层资源相关的服务和能力。</li>\n</ul><!-- [[[read_end]]] --><p>业务逻辑从领域层、应用层到用户接口层逐层封装和协作，对外提供灵活的服务，既实现了各层的分工，又实现了各层的协作。因此，毋庸置疑，DDD分层架构模型就是设计微服务代码模型的最佳依据。</p><h2>微服务代码模型</h2><p>现在，我们来看一下，按照DDD分层架构模型设计出来的微服务代码模型到底长什么样子呢？</p><p>其实，<span class=\"orange\">DDD并没有给出标准的代码模型</span>，不同的人可能会有不同理解。下面要说的这个微服务代码模型是我经过思考和实践后建立起来的，主要考虑的是微服务的边界、分层以及架构演进。</p><h3>微服务一级目录结构</h3><p>微服务一级目录是按照DDD分层架构的分层职责来定义的。从下面这张图中，我们可以看到，在代码模型里分别为用户接口层、应用层、领域层和基础层，建立了 interfaces、application、domain 和 infrastructure 四个一级代码目录。</p><p><img src=\"https://static001.geekbang.org/resource/image/d1/71/d1bea7dc6bd93f3bd30ced821f36bb71.jpg?wh=1136*336\" alt=\"\"></p><p>这些目录的职能和代码形态是这样的。</p><p><strong>Interfaces（用户接口层）：</strong>它主要存放用户接口层与前端交互、展现数据相关的代码。前端应用通过这一层的接口，向应用服务获取展现所需的数据。这一层主要用来处理用户发送的Restful请求，解析用户输入的配置文件，并将数据传递给Application层。数据的组装、数据传输格式以及Facade接口等代码都会放在这一层目录里。</p><p><strong>Application（应用层）：</strong>它主要存放应用层服务组合和编排相关的代码。应用服务向下基于微服务内的领域服务或外部微服务的应用服务完成服务的编排和组合，向上为用户接口层提供各种应用数据展现支持服务。应用服务和事件等代码会放在这一层目录里。</p><p><strong>Domain（领域层）：</strong>它主要存放领域层核心业务逻辑相关的代码。领域层可以包含多个聚合代码包，它们共同实现领域模型的核心业务逻辑。聚合以及聚合内的实体、方法、领域服务和事件等代码会放在这一层目录里。</p><p><strong>Infrastructure（基础层）：</strong>它主要存放基础资源服务相关的代码，为其它各层提供的通用技术能力、三方软件包、数据库服务、配置和基础资源服务的代码都会放在这一层目录里。</p><h3>各层目录结构</h3><p><strong>1. 用户接口层</strong></p><p>Interfaces 的代码目录结构有：assembler、dto 和 façade 三类。</p><p><img src=\"https://static001.geekbang.org/resource/image/c6/ef/c6ea040a520c91dfe6400f206ff36fef.jpg?wh=958*262\" alt=\"\"></p><p><strong>Assembler：</strong>实现DTO与领域对象之间的相互转换和数据交换。一般来说Assembler与DTO总是一同出现。</p><p><strong>Dto：</strong>它是数据传输的载体，内部不存在任何业务逻辑，我们可以通过DTO把内部的领域对象与外界隔离。</p><p><strong>Facade：</strong>提供较粗粒度的调用接口，将用户请求委派给一个或多个应用服务进行处理。</p><p><strong>2. 应用层</strong></p><p>Application 的代码目录结构有：event 和 service。</p><p><img src=\"https://static001.geekbang.org/resource/image/30/61/30caee3ceaf1085b7aa2cc388f996e61.jpg?wh=1060*328\" alt=\"\"></p><p><strong>Event（事件）：</strong>这层目录主要存放事件相关的代码。它包括两个子目录：publish 和 subscribe。前者主要存放事件发布相关代码，后者主要存放事件订阅相关代码（事件处理相关的核心业务逻辑在领域层实现）。</p><p>这里提示一下：虽然应用层和领域层都可以进行事件的发布和处理，但为了实现事件的统一管理，我建议你将微服务内所有事件的发布和订阅的处理都统一放到应用层，事件相关的核心业务逻辑实现放在领域层。通过应用层调用领域层服务，来实现完整的事件发布和订阅处理流程。</p><p><strong>Service（应用服务）：</strong>这层的服务是应用服务。应用服务会对多个领域服务或外部应用服务进行封装、编排和组合，对外提供粗粒度的服务。应用服务主要实现服务组合和编排，是一段独立的业务逻辑。你可以将所有应用服务放在一个应用服务类里，也可以把一个应用服务设计为一个应用服务类，以防应用服务类代码量过大。</p><p><strong>3. 领域层</strong></p><p>Domain 是由一个或多个聚合包构成，共同实现领域模型的核心业务逻辑。聚合内的代码模型是标准和统一的，包括：entity、event、repository 和 service 四个子目录。</p><p><img src=\"https://static001.geekbang.org/resource/image/68/2c/688dd55b8399779baff8fc5b7c124c2c.jpg?wh=1208*860\" alt=\"\"></p><p>而领域层聚合内部的代码目录结构是这样的。</p><p><strong>Aggregate（聚合）：</strong>它是聚合软件包的根目录，可以根据实际项目的聚合名称命名，比如权限聚合。在聚合内定义聚合根、实体和值对象以及领域服务之间的关系和边界。聚合内实现高内聚的业务逻辑，它的代码可以独立拆分为微服务。</p><p>以聚合为单位的代码放在一个包里的主要目的是为了业务内聚，而更大的目的是为了以后微服务之间聚合的重组。聚合之间清晰的代码边界，可以让你轻松地实现以聚合为单位的微服务重组，在微服务架构演进中有着很重要的作用。</p><p><strong>Entity（实体）：</strong>它存放聚合根、实体、值对象以及工厂模式（Factory）相关代码。实体类采用充血模型，同一实体相关的业务逻辑都在实体类代码中实现。跨实体的业务逻辑代码在领域服务中实现。</p><p><strong>Event（事件）：</strong>它存放事件实体以及与事件活动相关的业务逻辑代码。</p><p><strong>Service（领域服务）：</strong>它存放领域服务代码。一个领域服务是多个实体组合出来的一段业务逻辑。你可以将聚合内所有领域服务都放在一个领域服务类中，你也可以把每一个领域服务设计为一个类。如果领域服务内的业务逻辑相对复杂，我建议你将一个领域服务设计为一个领域服务类，避免由于所有领域服务代码都放在一个领域服务类中，而出现代码臃肿的问题。领域服务封装多个实体或方法后向上层提供应用服务调用。</p><p><strong>Repository（仓储）：</strong>它存放所在聚合的查询或持久化领域对象的代码，通常包括仓储接口和仓储实现方法。为了方便聚合的拆分和组合，我们设定了一个原则：一个聚合对应一个仓储。</p><p>特别说明：按照DDD分层架构，仓储实现本应该属于基础层代码，但为了在微服务架构演进时，保证代码拆分和重组的便利性，我是把聚合仓储实现的代码放到了聚合包内。这样，如果需求或者设计发生变化导致聚合需要拆分或重组时，我们就可以将包括核心业务逻辑和仓储代码的聚合包整体迁移，轻松实现微服务架构演进。</p><p><strong>4. 基础层</strong></p><p>Infrastructure 的代码目录结构有：config 和 util 两个子目录。</p><p><img src=\"https://static001.geekbang.org/resource/image/5b/5a/5bbe3454e2ecf4ff4770e887a4967b5a.jpg?wh=1142*440\" alt=\"\"></p><p><strong>Config：</strong>主要存放配置相关代码。</p><p><strong>Util：</strong>主要存放平台、开发框架、消息、数据库、缓存、文件、总线、网关、第三方类库、通用算法等基础代码，你可以为不同的资源类别建立不同的子目录。</p><h3>代码模型总目录结构</h3><p>在完成一级和二级代码模型设计后，你就可以看到下图这样的微服务代码模型的总目录结构了。</p><p><img src=\"https://static001.geekbang.org/resource/image/91/b8/915ad8d830d925a893cd09ff6cbdadb8.jpg?wh=982*1378\" alt=\"\"></p><h2>总结</h2><p>今天我们根据DDD分层架构模型建立了标准的微服务代码模型，在代码模型里面，各代码对象各据其位、各司其职，共同协作完成微服务的业务逻辑。</p><p>那关于代码模型我还需要强调两点内容。</p><p><span class=\"orange\">第一点：聚合之间的代码边界一定要清晰。</span>聚合之间的服务调用和数据关联应该是尽可能的松耦合和低关联，聚合之间的服务调用应该通过上层的应用层组合实现调用，原则上不允许聚合之间直接调用领域服务。这种松耦合的代码关联，在以后业务发展和需求变更时，可以很方便地实现业务功能和聚合代码的重组，在微服务架构演进中将会起到非常重要的作用。</p><p><span class=\"orange\">第二点：你一定要有代码分层的概念。</span>写代码时一定要搞清楚代码的职责，将它放在职责对应的代码目录内。应用层代码主要完成服务组合和编排，以及聚合之间的协作，它是很薄的一层，不应该有核心领域逻辑代码。领域层是业务的核心，领域模型的核心逻辑代码一定要在领域层实现。如果将核心领域逻辑代码放到应用层，你的基于DDD分层架构模型的微服务慢慢就会演变成传统的三层架构模型了。</p><h2>思考题</h2><p>对比一下DDD分层架构和三层架构的代码结构的差异？</p><p>期待你的分享，我们一同交流！</p><p></p>","comments":[{"had_liked":false,"id":150801,"user_name":"陈 争","can_delete":false,"product_type":"c1","uid":1207155,"ip_address":"","ucode":"A2A1FAC8E32F03","user_header":"https://static001.geekbang.org/account/avatar/00/12/6b/73/fbff84b5.jpg","comment_is_top":false,"comment_ctime":1573611701,"is_pvip":false,"replies":[{"id":"58017","content":"是的，就是这样的。理解的很到位。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573622674,"ip_address":"","comment_id":150801,"utype":1}],"discussion_count":14,"race_medal":0,"score":"375235766453","product_id":100037301,"comment_content":"不知道我这样理解的对不对<br>比如执行一个创建用户的命令，<br>1.用户接口层：<br>  1.1)Assembler-&gt;将CustomerDTO转换为CustomerEntity<br>  1.2)Dto-&gt;接收请求传入的数据CustomerDTO<br>  1.3)Facade-&gt;调用应用层创建用户方法<br>2.应用层<br>  2.1)Event-&gt;发布用户创建事件给其它微服务<br>  2.2)Service:<br>    内部服务-&gt;创建用户<br>    外部服务-&gt;创建日志<br>3. 领域层<br>  3.1)Aggregate-&gt;进入用户聚合目录下(如：CustomerAggregate)<br>  3.2)Entity-&gt;用户聚合跟<br>  3.3)Event-&gt;创建用户事件<br>  3.4)Service-&gt;具体的创建用户逻辑，比如用户是否重复校验，分配初始密码等<br>  3.5)Repository-&gt;将用户信息保存到数据库","like_count":87,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474271,"discussion_content":"是的，就是这样的。理解的很到位。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573622674,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1108505,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ea/19/14018371.jpg","nickname":"瓜瓜","note":"","ucode":"F90A5135A9BB4B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50043,"discussion_content":"首先感谢提问者陈争，还有再想问下，这里没有体现出基础层的逻辑，另外如果领域用户和基础层用户，不能完全对应，需要转换，也就是do与po的转换，这个转换放在哪里？基础层对外暴露的接口参数是do还是po？","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1573658378,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1142335,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","nickname":"楞伽山人","note":"","ucode":"5859C06DAC790D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1108505,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ea/19/14018371.jpg","nickname":"瓜瓜","note":"","ucode":"F90A5135A9BB4B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543548,"discussion_content":"是的 我也有同样疑问 如果按照用户接口层转换的话 那么这里就是在基础层转换 不知道这么理解对不对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641200689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":50043,"ip_address":""},"score":543548,"extra":""},{"author":{"id":1253652,"avatar":"https://static001.geekbang.org/account/avatar/00/13/21/14/423a821f.jpg","nickname":"Steven","note":"","ucode":"3FE64459842015","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1108505,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ea/19/14018371.jpg","nickname":"瓜瓜","note":"","ucode":"F90A5135A9BB4B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":564285,"discussion_content":"这个代码结构里，把仓储实现放在领域层了，所以DO和PO的转换当然是在领域层了。\n按照之前的，仓储实现放在基础资源层，则DO和PO的转换应该是放在基础资源层。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650205944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":50043,"ip_address":""},"score":564285,"extra":""}]},{"author":{"id":2035850,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/10/8a/f69402a7.jpg","nickname":"Young z","note":"","ucode":"7BE08C40C8726C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298487,"discussion_content":"应用层的发布事件和领域层的发布事件有什么区别？如果发布事件是通过mq的方式，那么是在应用层发还是领域层发mq？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1597309791,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1142335,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","nickname":"楞伽山人","note":"","ucode":"5859C06DAC790D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2035850,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/10/8a/f69402a7.jpg","nickname":"Young z","note":"","ucode":"7BE08C40C8726C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543549,"discussion_content":"我也有同样的疑问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641200748,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":298487,"ip_address":""},"score":543549,"extra":""},{"author":{"id":1627053,"avatar":"","nickname":"Geek_deb7fc","note":"","ucode":"6C4B8542C6BF3E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2035850,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/10/8a/f69402a7.jpg","nickname":"Young z","note":"","ucode":"7BE08C40C8726C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585704,"discussion_content":"我理解发布事件是在应用层，而领域层的事件是创建具体的事件对象，应用层负责发送到内部还是外部（mq）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661765618,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":298487,"ip_address":"陕西"},"score":585704,"extra":""}]},{"author":{"id":1375699,"avatar":"","nickname":"九","note":"","ucode":"DE98E4E0444C7D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372261,"discussion_content":"1)Assembler->将CustomerDTO转换为CustomerEntity，既然这样，接口层可以引用到实体，就变成了接口层依赖领域层了，文中说，上层只依赖下层，不能隔层依赖","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1620262080,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50283,"discussion_content":"DO和PO的转换在仓储实现里面，可以由mapper来做。基础层对外通过仓储暴露的是DO对象。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573699119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3009726,"avatar":"","nickname":"凌晨写Bug","note":"","ucode":"7345C0A982B6BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573628,"discussion_content":"我也会基本赞同。不过有点疑惑，事件应该是 用户创建完成事件(UserCreated)，发布到事件总线让其他订阅方感知到用户已经创建成功。因为用户在领域层已经完成了创建。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653555509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1366546,"avatar":"https://static001.geekbang.org/account/avatar/00/14/da/12/bdba4a3e.jpg","nickname":"jerry.mei","note":"","ucode":"8CEEA2F450CBC0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554940,"discussion_content":"领域服务是必须的吗？在《实现领域驱动设计》这本书里写到某个操作不适合放到实体和值对象上才使用，那么我直接在实体里访问仓储吗。所以这个实体能用ORM来做吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646668165,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1023729,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9e/f1/abb7bfe3.jpg","nickname":"szs","note":"","ucode":"1EA8129BC61EFB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381480,"discussion_content":"通过事件创建对象，怎么通知UI创建成功的，会不会有明显延时","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625095424,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":3009726,"avatar":"","nickname":"凌晨写Bug","note":"","ucode":"7345C0A982B6BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1023729,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9e/f1/abb7bfe3.jpg","nickname":"szs","note":"","ucode":"1EA8129BC61EFB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573629,"discussion_content":"是在领域服务完成创建对象，通知是通过 事件(事件完成, ObjectCreated)去通知。相关方接收到对象创建完成通知后，通知UI的。 这里延迟多了一个事件总线的发布+传输+接受处理。肯定是会增减延时的。不过根据我们项目经验，这个延时很低，即使是数据量大的时候，单个服务承载不了那么多消息，可以多开几个订阅者分别消费事件，也能轻松解决。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653555796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":381480,"ip_address":""},"score":573629,"extra":""}]},{"author":{"id":1985301,"avatar":"","nickname":"InfoQ_e9479e115e4f","note":"","ucode":"669967F1463BAC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336282,"discussion_content":"不应该是repository.save 完再发布领域事件？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608544318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":269553,"user_name":"HuAng","can_delete":false,"product_type":"c1","uid":1206021,"ip_address":"","ucode":"9C35E1C0AA05C2","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/05/2e601469.jpg","comment_is_top":false,"comment_ctime":1608700252,"is_pvip":false,"replies":[{"id":"97813","content":"分层架构大多是通过前端或后端适配，逐层控制外部变化向领域层传导，从而降低外部变化对领域模型的影响。比如在前端应用中可以消化掉页面逻辑和页面流程类需求；在用户接口层可以完成前端应用接口和数据适配，避免将接口和数据适配类需求传导到应用层；在应用层通过服务组合和编排，可以避免用例或服务组合类需求向领域层传导；在基础设施层通过依赖倒置设计，可以隔离技术组件变化对领域逻辑的影响。<br>这样由外向里逐层消化和隔离外部变化对领域模型的影响，从而可以最大限度保持领域模型原子性和长期稳定。<br>一个稳定的领域模型可以给我们带来非常多的好处。<br>首先，领域模型的构建过程是项目团队通用语言建立的过程，领域模型就是团队的通用语言，它会贯穿项目的所有过程。<br>其次，领域模型的业务逻辑大多是可复用的原子逻辑，不易受外部变化的影响。将这些核心逻辑沉淀到领域层，让核心逻辑更聚焦，核心代码更内聚。然后在应用层通过应用服务对领域层服务完成组合和编排，可以大量复用领域层的核心业务逻辑代码，从而提升代码复用率。<br>第三，领域模型的核心代码可交由专门的资深开发人员维护，从而提升代码质量，也能够保证应用关键核心业务逻辑的长期稳定运行。<br>第四，领域模型内聚合边界更加清晰，可方便微服务以聚合为单位的功能和代码的拆分和重组，让微服务具有更强的演进能力。<br>","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1608774550,"ip_address":"","comment_id":269553,"utype":1}],"discussion_count":2,"race_medal":0,"score":"87508046172","product_id":100037301,"comment_content":"老师，这种代码分层的优势在哪里？不知道你还看不看留言。","like_count":21,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512320,"discussion_content":"分层架构大多是通过前端或后端适配，逐层控制外部变化向领域层传导，从而降低外部变化对领域模型的影响。比如在前端应用中可以消化掉页面逻辑和页面流程类需求；在用户接口层可以完成前端应用接口和数据适配，避免将接口和数据适配类需求传导到应用层；在应用层通过服务组合和编排，可以避免用例或服务组合类需求向领域层传导；在基础设施层通过依赖倒置设计，可以隔离技术组件变化对领域逻辑的影响。\n这样由外向里逐层消化和隔离外部变化对领域模型的影响，从而可以最大限度保持领域模型原子性和长期稳定。\n一个稳定的领域模型可以给我们带来非常多的好处。\n首先，领域模型的构建过程是项目团队通用语言建立的过程，领域模型就是团队的通用语言，它会贯穿项目的所有过程。\n其次，领域模型的业务逻辑大多是可复用的原子逻辑，不易受外部变化的影响。将这些核心逻辑沉淀到领域层，让核心逻辑更聚焦，核心代码更内聚。然后在应用层通过应用服务对领域层服务完成组合和编排，可以大量复用领域层的核心业务逻辑代码，从而提升代码复用率。\n第三，领域模型的核心代码可交由专门的资深开发人员维护，从而提升代码质量，也能够保证应用关键核心业务逻辑的长期稳定运行。\n第四，领域模型内聚合边界更加清晰，可方便微服务以聚合为单位的功能和代码的拆分和重组，让微服务具有更强的演进能力。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608774550,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1517457,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKkzrezV2dOBAgickt9DLzabz3dNFYyDEVXENMQ5ibrWhFbFqXIOia3ZaR21pozvB7UfoxJx4Ar688sA/132","nickname":"开心","note":"","ucode":"C8E08E8724C7CE","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549609,"discussion_content":"学到了～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644131120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152489,"user_name":"xj_zh","can_delete":false,"product_type":"c1","uid":1214755,"ip_address":"","ucode":"190609F7AE67CC","user_header":"https://static001.geekbang.org/account/avatar/00/12/89/23/73569bd7.jpg","comment_is_top":false,"comment_ctime":1574035557,"is_pvip":false,"replies":[{"id":"58597","content":"代码样例还没准备好，后面我找时间整理一下吧。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574039704,"ip_address":"","comment_id":152489,"utype":1}],"discussion_count":9,"race_medal":0,"score":"61703577701","product_id":100037301,"comment_content":"老师，求DDD的系统样例代码。","like_count":14,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474832,"discussion_content":"代码样例还没准备好，后面我找时间整理一下吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574039704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1110437,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f1/a5/6cc9f728.jpg","nickname":"秋天的透明雨🌧️","note":"","ucode":"9363B49BFA6C14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377480,"discussion_content":"后边的加餐里已经有了示例代码，https://github.com/ouchuangxin/leave-sample","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1622683563,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1570088,"avatar":"https://static001.geekbang.org/account/avatar/00/17/f5/28/898a6947.jpg","nickname":"deepz","note":"","ucode":"4BD23A44CDB384","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1110437,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f1/a5/6cc9f728.jpg","nickname":"秋天的透明雨🌧️","note":"","ucode":"9363B49BFA6C14","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382661,"discussion_content":"还特地回来评论，可以的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625662534,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":377480,"ip_address":""},"score":382661,"extra":""}]},{"author":{"id":1046702,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f8/ae/abb7bfe3.jpg","nickname":"翌日兄弟","note":"","ucode":"E21127485C7CE3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":225306,"discussion_content":"这个代码目录，没真正落地吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586354987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1284730,"avatar":"https://static001.geekbang.org/account/avatar/00/13/9a/7a/dd08bc09.jpg","nickname":"姬","note":"","ucode":"968079E564FD2F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584709,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661055485,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1110437,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f1/a5/6cc9f728.jpg","nickname":"秋天的透明雨🌧️","note":"","ucode":"9363B49BFA6C14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377191,"discussion_content":"同求代码样例，或是推荐个好的基于DDD分层设计的代码样例","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622542052,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1364616,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/88/d22bab98.jpg","nickname":"夜风","note":"","ucode":"5B87D47B79398D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367778,"discussion_content":"有还是没有呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618468127,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1880716,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKRO8Yjv39zqMGXniaicNoYEq4mWHSD4ePCd1pIUf1epO3Zo7dC5aKC78IYAwSvuAA31D53tBuIWAhg/132","nickname":"VGeek","note":"","ucode":"C84387A1670957","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":353669,"discussion_content":"是不是已经有了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615187240,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1129632,"avatar":"https://static001.geekbang.org/account/avatar/00/11/3c/a0/8b9d5aca.jpg","nickname":"eagle","note":"","ucode":"D7601A2AFC1D17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350508,"discussion_content":"然后就没有然后了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613898434,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151272,"user_name":"FIGNT","can_delete":false,"product_type":"c1","uid":1540988,"ip_address":"","ucode":"D9DB185AE9E67C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKZ16iaIia0029oI1Qh5NicibpbTiaBAaCOPYXoLplKHr6uQ2rSVxPZanBvpMcL2NuhwKQYCFnaHP5tedQ/132","comment_is_top":false,"comment_ctime":1573693419,"is_pvip":false,"replies":[{"id":"58206","content":"1、个人感觉批量大数据量的查询用仓储有点勉强，你可以用传统的方式来做。如果不涉及到领域逻辑的话，可以放应用层。<br>2、一个微服务的聚合内部应该不会有太多的实体和值对象吧。在目录结构里面是一个聚合一个代码目录。当然如果实在太多，你是可以再分目录的。<br>3、聚合内的实体数据维护是通过聚合根通过仓储来统一维护的。<br>4、一个微服务一个库，微服务内的多个聚合可以共用一个库，但是尽量避免聚合之间的表关联，聚合之间的数据要做到松耦合。<br>5、不清楚你说的单个和批处理是什么意思？聚合是具有一个完整业务功能的单位，就看你业务的粒度大小。多个不同功能的聚合是可以构成一个比较大的业务模块。<br>","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573696748,"ip_address":"","comment_id":151272,"utype":1}],"discussion_count":1,"race_medal":0,"score":"57408268267","product_id":100037301,"comment_content":"我们在设计领域模型时，遇到一些问题<br>1. 查询聚合的操作应该放在哪一层？<br>2. entity的实体和值对象太多需要分目录吗？<br>3. 针对实体的维护，需要通过聚合去维护吗？可以直接修改实体吗？<br>4. 一个聚合保存在一个库里，还是多个聚合都在一个库里？一个实体需要单独放一个库吗？如果一个实体被修改了。用到这个实体的聚合需要更新吗？<br>5. 聚合是设计成单个的还是批处理的？比如一棵树，业务上是以一片叶子为单位的，那么是以树为聚合还是以叶子为聚合？","like_count":13,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474422,"discussion_content":"1、个人感觉批量大数据量的查询用仓储有点勉强，你可以用传统的方式来做。如果不涉及到领域逻辑的话，可以放应用层。\n2、一个微服务的聚合内部应该不会有太多的实体和值对象吧。在目录结构里面是一个聚合一个代码目录。当然如果实在太多，你是可以再分目录的。\n3、聚合内的实体数据维护是通过聚合根通过仓储来统一维护的。\n4、一个微服务一个库，微服务内的多个聚合可以共用一个库，但是尽量避免聚合之间的表关联，聚合之间的数据要做到松耦合。\n5、不清楚你说的单个和批处理是什么意思？聚合是具有一个完整业务功能的单位，就看你业务的粒度大小。多个不同功能的聚合是可以构成一个比较大的业务模块。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573696748,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150999,"user_name":"Farewell丶","can_delete":false,"product_type":"c1","uid":1179565,"ip_address":"","ucode":"A0D69893C5375C","user_header":"https://static001.geekbang.org/account/avatar/00/11/ff/ad/5020a8c5.jpg","comment_is_top":false,"comment_ctime":1573640100,"is_pvip":false,"replies":[{"id":"58158","content":"1、如果是应用服务直接调用文件或者缓存之类的，应用服务是可以之间调用仓储的。但如果中间有领域实体和数据库，则需通过领域服务，然后通过聚合根来调用仓储。<br>2、用户接口层大多是DTO，应用层和领域层大多是DO，基础层则是PO，在不同层之间是需要进行数据转换的。我有一节专门讲这个。<br>3、如果是这样的话，确实领域层与数据库层会有耦合。领域事件其实放领域层也是可以的，放应用层主要是为了统一管理。如果领域事件放在实体内部，查找和运维起来就不是太方便，而且这个实体还需要对领域事件的实体进行操作。目录结构的设计主要是从边界、分层和便利性考虑的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573653851,"ip_address":"","comment_id":150999,"utype":1}],"discussion_count":3,"race_medal":0,"score":"40228345764","product_id":100037301,"comment_content":"1.应用服务只能调用领域服务和实体的方法，能调用仓储接口的方法么？<br>按理说应该隔离，也就是说应用服务应该调用领域服务的方法，再让领域服务调用仓储接口的方法吧？<br><br>2.实体的转换只有从用户接口层到应用服务层一次是么？也就是说，到应用服务层之后，以及之后的仓储接口都是可以直接对领域实体进行操作的？<br><br>3.参考了Spring Data Jdbc项目，里边也采用了DDD的设计思路，但是发现会需要在实体中配置一些和底层存储相关的注解，这样会不会不能把领域层可仓储实现进行隔离？如果是这样的化，那么Spring Data Jdbc是不是没有严格遵守DDD的一些设计？而且它提供的领域事件的发布机制实现，是在对应的实体中产生的，例如在某一个实体中定义产生领域事件的源头，当对应的实体保存或更新时，就会发出这样一个领域事件。按照咱们文章中讲解的事件的发布是在应用层，那么如果要这样做的话，是不是就需要在应用层重新转发领域层实体内产生的领域事件呢？<br>因为看到Spring Data这样比较广泛的项目实现和咱们文章的描述有一些我理解上的区别，所以比较困惑和疑问。","like_count":9,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474335,"discussion_content":"1、如果是应用服务直接调用文件或者缓存之类的，应用服务是可以之间调用仓储的。但如果中间有领域实体和数据库，则需通过领域服务，然后通过聚合根来调用仓储。\n2、用户接口层大多是DTO，应用层和领域层大多是DO，基础层则是PO，在不同层之间是需要进行数据转换的。我有一节专门讲这个。\n3、如果是这样的话，确实领域层与数据库层会有耦合。领域事件其实放领域层也是可以的，放应用层主要是为了统一管理。如果领域事件放在实体内部，查找和运维起来就不是太方便，而且这个实体还需要对领域事件的实体进行操作。目录结构的设计主要是从边界、分层和便利性考虑的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573653851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1142335,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","nickname":"楞伽山人","note":"","ucode":"5859C06DAC790D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":543550,"discussion_content":"老师 3这个问题 如果放在应用层是怎么去调用的呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641201074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":474335,"ip_address":""},"score":543550,"extra":""}]},{"author":{"id":1257422,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2f/ce/c72d4c67.jpg","nickname":"movesan","note":"","ucode":"29CDF0F2B604C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271814,"discussion_content":"你好Farewell丶，请问 Spring Data JDBC项目怎么看出来是DDD的设计思路呢，查看github 上的源代码并没有看到有类似文中的分层结构","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590198121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":258384,"user_name":"小明","can_delete":false,"product_type":"c1","uid":2062378,"ip_address":"","ucode":"8B7AD174BB18AE","user_header":"https://static001.geekbang.org/account/avatar/00/1f/78/2a/ce302437.jpg","comment_is_top":false,"comment_ctime":1604404903,"is_pvip":false,"replies":[{"id":"94115","content":"在用DDD设计时，这种复杂的查询逻辑一般不放到领域模型的领域逻辑中，而是采用CQRS模式，也就是一种读写分离的设计模型，在CQRS模型中读业务模型和写业务模型（领域模型）是分离的。<br>第一种方案，如果读模型和写模型在同一个微服务中，这种复杂查询模型可以共享同一个数据库的不同聚合的数据库表，用传统的SQL查询就可以实现复杂的跨聚合查询。<br>第二种方案，你也可以将读模型独立为查询库和查询微服务，汇集多个源头数据后，重构多个微服务或者聚合的读数据模型，然后提供独立的查询服务。<br>具体选用哪种方案，需要结合你的技术和业务场景来设计。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1604457638,"ip_address":"","comment_id":258384,"utype":1}],"discussion_count":3,"race_medal":0,"score":"27374208679","product_id":100037301,"comment_content":"欧阳老师，看回复收获很多，我也想请教一个问题，比如一个查询商品详情接口，包含查询商品信息、店铺信息、促销信息，可能跨多个域，那么结合DDD分层设计，应该怎么做呢，谢谢","like_count":6,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508636,"discussion_content":"在用DDD设计时，这种复杂的查询逻辑一般不放到领域模型的领域逻辑中，而是采用CQRS模式，也就是一种读写分离的设计模型，在CQRS模型中读业务模型和写业务模型（领域模型）是分离的。\n第一种方案，如果读模型和写模型在同一个微服务中，这种复杂查询模型可以共享同一个数据库的不同聚合的数据库表，用传统的SQL查询就可以实现复杂的跨聚合查询。\n第二种方案，你也可以将读模型独立为查询库和查询微服务，汇集多个源头数据后，重构多个微服务或者聚合的读数据模型，然后提供独立的查询服务。\n具体选用哪种方案，需要结合你的技术和业务场景来设计。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604457638,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1204885,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJ2Z2icQkTpLVcgjUyQ26iasP9awociawqR25wI8FNFnQqWduD17kjtQKWtc9xnH4vXH8fFtbFkO3JZA/132","nickname":"Geek_c8ca1d","note":"","ucode":"70347E01214474","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552073,"discussion_content":"这种应该放在bff层做","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1645274134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1213325,"avatar":"https://static001.geekbang.org/account/avatar/00/12/83/8d/03cac826.jpg","nickname":"徐李","note":"","ucode":"41550F6CA1E112","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539261,"discussion_content":"这样感觉更复杂了不是？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639649931,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220776,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1590323237,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"23065159717","product_id":100037301,"comment_content":"传统三层：用户接口层，业务层，基础层<br>领域DDD分层：用户接口层，应用层，领域层，基础层<br>两者差异，DDD分层将业务领域核心逻辑聚焦在领域层，而跨聚合的组合编排在应用层<br>这在传统三层中实现跨域的操作需要在用户接口层或者业务层加个组合方法，导致分层不清","like_count":5,"discussions":[{"author":{"id":1213325,"avatar":"https://static001.geekbang.org/account/avatar/00/12/83/8d/03cac826.jpg","nickname":"徐李","note":"","ucode":"41550F6CA1E112","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539260,"discussion_content":"传统的三层基本是能满足需求的\nDDD有它的优势，不管是说从外到内的传导，还是领域的更加清晰，但是要让DDD替代传统三层需要更有力的说服力。\n1.基础层封装的数据库变更后，传统三层需要修改 基础层，现在也是改基础层\n2.业务变更时候，传统三层就是修改业务层，所有业务都在业务层，接口处理与前端，第三方的交互，基础层只处理数据库的应用，只有业务层互相依赖，调用基础层，为用户接口层提供接口。\n\n好像梳理下传统三层，相对于DDD的四层，并没有什么不足。\nDDD的四层：用户接口层，应用层，领域层，基础层，各个有各个的分工，最核心的就是领域层，而不是应用层，这里应用层只是领域层的业务组合，编排。领域层的聚合相当于做了传统三层中业务层的功能。\n这种分层模式的优点还需要更深入的理解，目前倒是还没有理解透？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639649862,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":202654,"user_name":"刘小龙","can_delete":false,"product_type":"c1","uid":1063124,"ip_address":"","ucode":"E2887ADCAD1F2E","user_header":"https://static001.geekbang.org/account/avatar/00/10/38/d4/f15ab4a3.jpg","comment_is_top":false,"comment_ctime":1586046158,"is_pvip":false,"replies":[{"id":"76067","content":"聚合在领域建模的时候是要坚持职责单一性原则的，一个聚合的功能在企业内应该是唯一的。而一个仓储只对应一个聚合，所以这个仓储应该不会共享给其它的领域模型，不会在基础层被其它的聚合复用的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1586224371,"ip_address":"","comment_id":202654,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23060882638","product_id":100037301,"comment_content":"Repository，放在领域层，如果一个对象出现在领域，多个领域对其进行操作，会不会太多重复的操作数据库？【将包括核心业务逻辑和仓储代码的聚合包整体迁移，轻松实现微服务架构演进】这个是为了将各个领域的代码进行隔离，进行了竖向划分，达到目标。如果系统过大，将基础层划分出来，接口层划分出来，也就横向划分，是不是也行？","like_count":5,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490646,"discussion_content":"聚合在领域建模的时候是要坚持职责单一性原则的，一个聚合的功能在企业内应该是唯一的。而一个仓储只对应一个聚合，所以这个仓储应该不会共享给其它的领域模型，不会在基础层被其它的聚合复用的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586224371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":276068,"user_name":"Tony","can_delete":false,"product_type":"c1","uid":1107878,"ip_address":"","ucode":"23BBBD1E0FCD26","user_header":"https://static001.geekbang.org/account/avatar/00/10/e7/a6/9a2d7708.jpg","comment_is_top":false,"comment_ctime":1611761542,"is_pvip":false,"replies":[{"id":"101042","content":"充血模型才是真正的面向对象设计方式。<br>在一个聚合中，除了聚合根和领域服务外，一般的实体不会调用仓储接口的。为了保证聚合内数据的一致性和符合聚合的业务规则，聚合新增或修改的数据通常都是通过聚合根或领域服务一次提交到持久层，不允许直接去修改某一个普通实体的持久化数据的。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1612852917,"ip_address":"","comment_id":276068,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18791630726","product_id":100037301,"comment_content":"实体自身的业务逻辑放在实体里面，会不会让实体对象很庞大，假如实体里面的业务逻辑设计仓储层的调用会不会有点奇怪了？求解","like_count":4,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514590,"discussion_content":"充血模型才是真正的面向对象设计方式。\n在一个聚合中，除了聚合根和领域服务外，一般的实体不会调用仓储接口的。为了保证聚合内数据的一致性和符合聚合的业务规则，聚合新增或修改的数据通常都是通过聚合根或领域服务一次提交到持久层，不允许直接去修改某一个普通实体的持久化数据的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1612852917,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":238215,"user_name":"甲小蛙","can_delete":false,"product_type":"c1","uid":1475627,"ip_address":"","ucode":"B611FDDE514C9F","user_header":"https://static001.geekbang.org/account/avatar/00/16/84/2b/ba495eea.jpg","comment_is_top":false,"comment_ctime":1596096607,"is_pvip":false,"replies":[{"id":"88056","content":"加餐里面有一个完整的示例代码分析。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1596150938,"ip_address":"","comment_id":238215,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18775965791","product_id":100037301,"comment_content":"感觉老师有点纸上谈兵的意思呢，只讲理论，连示例代码库都没有，感觉谁都可以照着书来一个这样的课程了，总是浅尝辄止，不免有点失望","like_count":4,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502675,"discussion_content":"加餐里面有一个完整的示例代码分析。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596150938,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168170,"user_name":"燕羽阳","can_delete":false,"product_type":"c1","uid":1015063,"ip_address":"","ucode":"AF9430187F66EE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/17/179b24f4.jpg","comment_is_top":false,"comment_ctime":1578024715,"is_pvip":false,"replies":[{"id":"65309","content":"是的，我感觉对应复杂的聚合在领域服务中调用repository比较顺手。第三方接口我建议放在应用服务中处理，应用服务主要对服务进行组合和编排。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1578035643,"ip_address":"","comment_id":168170,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18757893899","product_id":100037301,"comment_content":"在《实现领域驱动设计》这本书中，Demo(https:&#47;&#47;github.com&#47;VaughnVernon&#47;IDDD_Samples)。<br>会倾向于：在application中调用repository, 领域实体和领域服务是不应当调用repository的，这样领域层会保持独立。在实际写代码的过程中，发现这样代码写比较麻烦。<br>老师能在详细对比讲讲，对repository和第三方接口依赖的情况，在哪一层处理么？","like_count":4,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480161,"discussion_content":"是的，我感觉对应复杂的聚合在领域服务中调用repository比较顺手。第三方接口我建议放在应用服务中处理，应用服务主要对服务进行组合和编排。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578035643,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215424,"user_name":"开心小毛","can_delete":false,"product_type":"c1","uid":1023762,"ip_address":"","ucode":"9D57A2773759F3","user_header":"","comment_is_top":false,"comment_ctime":1588989165,"is_pvip":false,"replies":[{"id":"80279","content":"是这样的。<br>在微服务面向不同前端应用时，同样的一段业务逻辑，可能由于渠道不同，而在前端展示的页面要素不同，因此要求后端微服务返回的数据结果会不同。比如在面向内部员工的PC端应用时，可能要求返回全部数据。而面向外部客户的移动端应用，可能只需要返回几个关键数据就可以了。<br>为了避免暴露微服务的核心业务逻辑，防止数据外泄，你不能将后端所有的数据，不加区分的传递给前端应用。你更不能仅仅因为前端应用不同的数据展示需求，而开发出多个不同的后端服务，面向前端应用提供不同的服务。<br>这时用户接口层的Facade服务和数据组装器Assembler就可以发挥作用了。Facade服务可以封装应用服务，数据组装器Assembler可以根据不同前端应用的数据需求，完成前端DTO和后端DO对象的组装和转换等操作。面向不同前端应用提供不同的Facade接口和DTO数据服务。这样，我们不需要调整任何后端服务，就可以面向不同的前端应用，提供灵活的接口定制和数据适配服务了。<br>","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1589424768,"ip_address":"","comment_id":215424,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14473891053","product_id":100037301,"comment_content":"接口层的facade是不是用来解析REST URL的: 调用URL对应的应用层服务，并传入URL变量作为调用参数。这样理解对么？谢谢老师。","like_count":3,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494430,"discussion_content":"是这样的。\n在微服务面向不同前端应用时，同样的一段业务逻辑，可能由于渠道不同，而在前端展示的页面要素不同，因此要求后端微服务返回的数据结果会不同。比如在面向内部员工的PC端应用时，可能要求返回全部数据。而面向外部客户的移动端应用，可能只需要返回几个关键数据就可以了。\n为了避免暴露微服务的核心业务逻辑，防止数据外泄，你不能将后端所有的数据，不加区分的传递给前端应用。你更不能仅仅因为前端应用不同的数据展示需求，而开发出多个不同的后端服务，面向前端应用提供不同的服务。\n这时用户接口层的Facade服务和数据组装器Assembler就可以发挥作用了。Facade服务可以封装应用服务，数据组装器Assembler可以根据不同前端应用的数据需求，完成前端DTO和后端DO对象的组装和转换等操作。面向不同前端应用提供不同的Facade接口和DTO数据服务。这样，我们不需要调整任何后端服务，就可以面向不同的前端应用，提供灵活的接口定制和数据适配服务了。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589424768,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166987,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1577664576,"is_pvip":false,"replies":[{"id":"64831","content":"这里的基础层应该与基础层的技术组件有些差异。比如数据库、api网关之类的基础组件是单独部署而且可能是很多微服务共享的。这里的基础层更多的是偏向于应用与这些基础组件的交互相关的内容，比如组件驱动以及适配相关的代码等内容。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1577666531,"ip_address":"","comment_id":166987,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14462566464","product_id":100037301,"comment_content":"我的理解是各个不同的微服务应该是共享一套infrastructure的吧？如果是的话，代码结构是不是不应该这样？<br>","like_count":3,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479702,"discussion_content":"这里的基础层应该与基础层的技术组件有些差异。比如数据库、api网关之类的基础组件是单独部署而且可能是很多微服务共享的。这里的基础层更多的是偏向于应用与这些基础组件的交互相关的内容，比如组件驱动以及适配相关的代码等内容。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577666531,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008404,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","nickname":"Jerry银银","note":"","ucode":"80DA1172A2360A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":109058,"discussion_content":"谢谢🙏","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577666576,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152599,"user_name":"杨杰","can_delete":false,"product_type":"c1","uid":1131823,"ip_address":"","ucode":"74817EA9499843","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/2f/b0b0dd74.jpg","comment_is_top":false,"comment_ctime":1574048111,"is_pvip":false,"replies":[{"id":"58670","content":"你可以这样定位。微服务内的应用层主要处理自己的逻辑编排，bff主要处理微服务之间的逻辑。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574073038,"ip_address":"","comment_id":152599,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14458949999","product_id":100037301,"comment_content":"关于微服务的用户接口层和应用层有点儿疑问。在整个微服务架构里面一般微服务上层还有BFF层、聚合服务层，一般BFF层或聚合服务层用来协调多个微服务或者做数据转换。那么对于某个具体的微服务是否还需要用户接口层和应用层的区分呢？如果DTO是在用户接口层，那么这些数据如何传入到应用服务层呢？","like_count":3,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474871,"discussion_content":"你可以这样定位。微服务内的应用层主要处理自己的逻辑编排，bff主要处理微服务之间的逻辑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574073038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":260744,"user_name":"Doctor Lau","can_delete":false,"product_type":"c1","uid":1018266,"ip_address":"","ucode":"4B685CF1582BC4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/89/9a/51e87979.jpg","comment_is_top":false,"comment_ctime":1605093101,"is_pvip":false,"replies":[{"id":"95271","content":"基础资源层可以面向所有层提供服务。放在领域层主要是考虑一个聚合对应一个仓储，方便以后以聚合为维度的代码拆分。如果在同一个微服务工程里面，个人感觉放在领域层与放在基础层的依赖关系不会有多大的改变吧。不清楚您说的循环依赖是什么样的场景？能否举一个案例？感谢！","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1605764798,"ip_address":"","comment_id":260744,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10195027693","product_id":100037301,"comment_content":"个人理解repository的实现应该放到infra，才能起到隔离持久层的作用，但这样按目前的工程结构会出现循环依赖，除非将领域模型提出到单独工程，请问这个问题怎么考虑的？","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509280,"discussion_content":"基础资源层可以面向所有层提供服务。放在领域层主要是考虑一个聚合对应一个仓储，方便以后以聚合为维度的代码拆分。如果在同一个微服务工程里面，个人感觉放在领域层与放在基础层的依赖关系不会有多大的改变吧。不清楚您说的循环依赖是什么样的场景？能否举一个案例？感谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605764798,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218584,"user_name":"z","can_delete":false,"product_type":"c1","uid":1107666,"ip_address":"","ucode":"CDB0BE8562ECB6","user_header":"https://static001.geekbang.org/account/avatar/00/10/e6/d2/638ca831.jpg","comment_is_top":false,"comment_ctime":1589821517,"is_pvip":false,"replies":[{"id":"81089","content":"一般来说是这样的，前端页面逻辑的数据校验在前端应用完成。应用服务中进行安全认证、权限校验、事务控制、领域事件发布或订阅等。业务规则的校验一般在领域层完成。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1590051069,"ip_address":"","comment_id":218584,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10179756109","product_id":100037301,"comment_content":"业务相关的校验是放到应用层还是领域层呢？放在应用层的话应用层有了业务逻辑。放在领域层，面向web的和面向微服务间的调用校验规则不同又不够灵活难以实现。","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495513,"discussion_content":"一般来说是这样的，前端页面逻辑的数据校验在前端应用完成。应用服务中进行安全认证、权限校验、事务控制、领域事件发布或订阅等。业务规则的校验一般在领域层完成。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590051069,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206269,"user_name":"苗","can_delete":false,"product_type":"c1","uid":1088710,"ip_address":"","ucode":"5ECCC6C855E541","user_header":"https://static001.geekbang.org/account/avatar/00/10/9c/c6/05a6798f.jpg","comment_is_top":false,"comment_ctime":1586831445,"is_pvip":false,"replies":[{"id":"77362","content":"大概看了一下他的文章，可能理解上有些差异，这篇文章中的用户界面层应该是前端应用的概念，而网关应该就是API网关。<br>你说的这个情况其实在DDD用户接口层很好解决，应用服务可以拿到订单相关的所有数据，然后用户接口层在组织Facade服务的时候，可以调用应用服务获取DO数据，然后根据外部不同接口的数据要求，将DO数据进行重新组装成不同的DTO，比如面向C端DTO是包含了下单时间、商品名称、金额。而面向报表DTO则包含了更全的订单数据。这样一个应用服务可以经过Facade封装成两个面向不同前端并提供不同数据的用户接口层的服务了，这个服务可以发布在API网关中，供前端应用调用。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1587007442,"ip_address":"","comment_id":206269,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10176766037","product_id":100037301,"comment_content":"老师，请教一下大家，业务数据网关如果实现？一个order-service提供了一个queryOrder的接口，输入起始日期查询对应的订单列表，其有2个消费者：C端网站应用服务 和 报表应用服务 ，C端网站应用服务 只需要知道订单的基本信息如下单时间、商品名称、金额就可以了，而报表应用服务是给管理者看的，需要的订单数据很全，除了C端网站应用服务需要的之外，还需要看平台与商家的结算金额。另外看到一篇类似的微服务分层方面的文章和课程中相比多了一个网关层，http:&#47;&#47;tbwork.org&#47;2018&#47;10&#47;25&#47;layed-dev-arch&#47;#4%E9%A2%86%E5%9F%9F%E5%88%92%E5%88%86%E5%92%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8C%96 请老师看看，然后讲解下这个网关层和api gateway是一样的吗？老师有微信交流群吗？","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491733,"discussion_content":"大概看了一下他的文章，可能理解上有些差异，这篇文章中的用户界面层应该是前端应用的概念，而网关应该就是API网关。\n你说的这个情况其实在DDD用户接口层很好解决，应用服务可以拿到订单相关的所有数据，然后用户接口层在组织Facade服务的时候，可以调用应用服务获取DO数据，然后根据外部不同接口的数据要求，将DO数据进行重新组装成不同的DTO，比如面向C端DTO是包含了下单时间、商品名称、金额。而面向报表DTO则包含了更全的订单数据。这样一个应用服务可以经过Facade封装成两个面向不同前端并提供不同数据的用户接口层的服务了，这个服务可以发布在API网关中，供前端应用调用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587007442,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":196422,"user_name":"码弓手","can_delete":false,"product_type":"c1","uid":1740639,"ip_address":"","ucode":"B5D1EC8424B5D5","user_header":"https://static001.geekbang.org/account/avatar/00/1a/8f/5f/c6d10aa8.jpg","comment_is_top":false,"comment_ctime":1585280320,"is_pvip":false,"replies":[{"id":"74427","content":"你可以看一下第十八章，里面有一个服务调用关系图，在加餐里面也有代码示例，希望能帮你加深理解。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1585283539,"ip_address":"","comment_id":196422,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10175214912","product_id":100037301,"comment_content":"文章看完，还是又一些关于调用过程的疑问，Application层使用的是Domain层中聚合的entity对象对象呢还是repository对象，repository不是更应该放在基础层吗，repository理解起来还有一些困惑，希望大佬以一个下单为例子解说一下每个层的调用链路，谢谢！","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489294,"discussion_content":"你可以看一下第十八章，里面有一个服务调用关系图，在加餐里面也有代码示例，希望能帮你加深理解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585283539,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":192896,"user_name":"何磊","can_delete":false,"product_type":"c1","uid":1047604,"ip_address":"","ucode":"78934C3ED4A342","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fc/34/c733b116.jpg","comment_is_top":false,"comment_ctime":1584877862,"is_pvip":false,"replies":[{"id":"73728","content":"第一个问题，我在分层架构时讲到了，分层架构包括严格分层架构和松散分层架构，在严格分层架构中只能上层调下层，在松散分层架构中上层可以调任意下层。如果你采用严格分层架构，那就需要封装成领域服务，如果采用松散分层架构，应用层可以直接调实体方法。我一般建议采用严格分层架构。<br>第二问题，是这样的。这就是应用服务的职责，负责微服务内不同聚合领域服务和微服务之间的应用服务的组合和编排。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1584930376,"ip_address":"","comment_id":192896,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10174812454","product_id":100037301,"comment_content":"老师好，有两个个疑问：<br>1. 如果在一个聚合中，只有一个 Entity，它已经实现了所有的业务逻辑，那么是否在聚合中还需要领域服务？<br><br>如果Entity跟Service都有业务逻辑的实现，在应用层调用的时候能否直接调用Entity呢？还是说不管如何。Service都要封装一下Entity的业务逻辑，方便应用层调用？<br><br>2. 这里困扰我的第二个问题，如果我的A微服务，需要先从自己的存储中获取数据的id（比如商品id），然后调用B服务获取id具体的信息，再进行其它处理。那么我是否这个逻辑是，A服务提供了一个查询id的方法，以及获取数据后对数据处理的方法；然后再A服务的应用层先调用查询id的方法，然后调用B服务获取到数据后，再调用另外一个方法来处理吗？","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488480,"discussion_content":"第一个问题，我在分层架构时讲到了，分层架构包括严格分层架构和松散分层架构，在严格分层架构中只能上层调下层，在松散分层架构中上层可以调任意下层。如果你采用严格分层架构，那就需要封装成领域服务，如果采用松散分层架构，应用层可以直接调实体方法。我一般建议采用严格分层架构。\n第二问题，是这样的。这就是应用服务的职责，负责微服务内不同聚合领域服务和微服务之间的应用服务的组合和编排。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584930376,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1341318,"avatar":"https://static001.geekbang.org/account/avatar/00/14/77/86/27d4cc0a.jpg","nickname":"王洋洋","note":"","ucode":"8071BB3A0EE2C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343673,"discussion_content":"实体不是也分在领域层吗？应用层调用领域层不违法分层原则呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611132255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2089155,"avatar":"","nickname":"昌南一枝花","note":"","ucode":"66118BEFFDC9BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298874,"discussion_content":"关于第二个问题，是不是用微服务之间的bff来处理更好？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597457370,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166984,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1577664448,"is_pvip":false,"replies":[{"id":"64827","content":"微服务架构下前后端分离，前端会有自己的工程的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1577666237,"ip_address":"","comment_id":166984,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10167599040","product_id":100037301,"comment_content":"请教一下老师：客户端开发中，存在着UI层，那UI层的代码也放在哪儿呢？","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479701,"discussion_content":"微服务架构下前后端分离，前端会有自己的工程的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577666237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1438475,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f3/0b/4560079e.jpg","nickname":"王宇","note":"","ucode":"0E9BC3AD99C8E5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":199297,"discussion_content":"我们前后端一起发直接打脸…","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583581116,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008404,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","nickname":"Jerry银银","note":"","ucode":"80DA1172A2360A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":109053,"discussion_content":"谢谢老师的回答。我想问的是在前端的工程里面，UI层的代码应该放哪儿，是放在一个单独的服务内吗？😊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577666410,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162380,"user_name":"东方奇骥","can_delete":false,"product_type":"c1","uid":1354850,"ip_address":"","ucode":"DEE7085F7E55A4","user_header":"https://static001.geekbang.org/account/avatar/00/14/ac/62/37912d51.jpg","comment_is_top":false,"comment_ctime":1576506853,"is_pvip":true,"replies":[{"id":"61766","content":"是这样的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1576539352,"ip_address":"","comment_id":162380,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10166441445","product_id":100037301,"comment_content":"Controller, Service, Repository。Controller相当于用户接口层里的Facade？？？由于采用了充血模型，之前三层模型中的Service的业务逻辑被封装在了domain的各个聚合下的实体之中。如果需要使用到多个实体来完成某个操作，就要使用聚合中的service.","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478035,"discussion_content":"是这样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576539352,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153882,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1574325050,"is_pvip":false,"replies":[{"id":"59184","content":"可以这样设计的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574392004,"ip_address":"","comment_id":153882,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10164259642","product_id":100037301,"comment_content":"请教一个问题，考虑这样一个场景，主播账户作为一个聚合，优惠券模块作为一个聚合。那主播选券这个命令是不是应该属于主播账户这个聚合里。然后主播账户里的优惠券是不是就是这个聚合里的值对象了","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475309,"discussion_content":"可以这样设计的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574392004,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1100064,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","nickname":"zj","note":"","ucode":"E3329CCF694AC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55748,"discussion_content":"其实产品设计的时候，在优惠券编辑页面中，还有选择哪些主播可以使用这个券。这个时候用应用层服务来包装优惠券领域服务和主播选券领域服务感觉不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574394310,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":323606,"user_name":"golem","can_delete":false,"product_type":"c1","uid":1253276,"ip_address":"","ucode":"B2D9A9AE624747","user_header":"https://static001.geekbang.org/account/avatar/00/13/1f/9c/da2265cf.jpg","comment_is_top":false,"comment_ctime":1638016940,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5932984236","product_id":100037301,"comment_content":"感觉有些实现和DDD框架相违背，一般涉及多个领域实体的时候才会使用领域服务，但是在示例代码中，getLeaveInfo也放到了leaveDomainService中，领域中的概念都是针对领域模型操作的，repository返回的不是领域实体，repository的实现也放倒了领域层，这和基础实现依赖领域层是相违背的。","like_count":1},{"had_liked":false,"id":323260,"user_name":"埋葬","can_delete":false,"product_type":"c1","uid":1306646,"ip_address":"","ucode":"72BA350F06DAD0","user_header":"https://static001.geekbang.org/account/avatar/00/13/f0/16/3689aa6d.jpg","comment_is_top":false,"comment_ctime":1637805792,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5932773088","product_id":100037301,"comment_content":"应用层里有多个聚合的代码，在做服务拆分时，多个聚合之间的代码可以很容易分离开，但是应用层的代码都耦合在一起，拆分时是不是也会很难受？","like_count":1,"discussions":[{"author":{"id":1142335,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","nickname":"楞伽山人","note":"","ucode":"5859C06DAC790D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543552,"discussion_content":"这个时候通过id会好一点 到时候拆分的时候要替换成DTO","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641201656,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":293458,"user_name":"Lever","can_delete":false,"product_type":"c1","uid":1071921,"ip_address":"","ucode":"20C0D381677E1D","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/31/b26b56bf.jpg","comment_is_top":false,"comment_ctime":1621393992,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5916361288","product_id":100037301,"comment_content":"您好，有几个问题想请教下：<br>1. 有个聚合根可能涉及到多次数据库 io 操作，比如读取单个表的多行数据（每行都是一个实体，需要在一次请求中初始化多个实体），这种为了减少 io 次数，是不是需要 repository 层统一做处理，而聚合层不需要考虑 io 问题？举个具体的场景：「文件夹」是个聚合根，文件夹这个实体有父文件夹，有子文件，我在操作实体时，需要通过「文件夹」访问该「文件夹」的父文件夹和子文件。按照我的理解，对聚合根而言，只需要当成数据都在内存里，不需要关心产生的 io 情况，所以 repository 在产生实体时就要把这些相关联的数据也构造好，来达到减少 io 的目的。<br><br>2. 聚合是不是不需要关注底层数据如何存储，有些业务场景我们会使用读扩散或者写扩散的方式来实现，比如每个文件都会有权限设置，文件树上的权限会逐层继承，继承可以用读扩散实现也可以用写扩散实现，当我们在聚合中获取文件的权限设置时，是不是不需要关注用了哪种方案，repository 提供的权限设置应该是该文件最终的权限设置（经过一系列权限继承计算）。<br><br>不知道我的理解和划分是否合理，对 repository 的定位还是有些模糊。","like_count":1},{"had_liked":false,"id":249847,"user_name":"伊来温","can_delete":false,"product_type":"c1","uid":2044174,"ip_address":"","ucode":"137E3A8258206B","user_header":"https://static001.geekbang.org/account/avatar/00/1f/31/0e/cbcada9b.jpg","comment_is_top":false,"comment_ctime":1600829779,"is_pvip":false,"replies":[{"id":"91629","content":"你是说应用服务对不同聚合的领域服务进行编排后，产生的新的实体吧。在应用层应该是DO对象，如果这个对象需要传输到前端应用，则需要在用户接口层转换为DTO。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1600933895,"ip_address":"","comment_id":249847,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5895797075","product_id":100037301,"comment_content":"请教一下欧老师，应用层编排领域服务之后的结果可能是另外的数据模型，这个模型是DTO吗？那这个DTO应该属于用户接口层还是应用层呢？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506033,"discussion_content":"你是说应用服务对不同聚合的领域服务进行编排后，产生的新的实体吧。在应用层应该是DO对象，如果这个对象需要传输到前端应用，则需要在用户接口层转换为DTO。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600933895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212711,"user_name":"有生之年","can_delete":false,"product_type":"c1","uid":1020719,"ip_address":"","ucode":"B713335DE9D37F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/93/2f/1e193dcc.jpg","comment_is_top":false,"comment_ctime":1588180871,"is_pvip":false,"replies":[{"id":"79539","content":"是这样的。应用服务主要是服务的组合和编排。主要的实现逻辑是在领域层。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1588836855,"ip_address":"","comment_id":212711,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5883148167","product_id":100037301,"comment_content":"老师，你好. 比如一个用户下单的场景： 需要校验用户是否合法、商品是否存在并且上架、库存是否足够等等校验，我的理解是：在应用服务会有一个方法是下单方法，这个方法内会调用用户的领域服务userValidateService，商品的领域服务productValidateService等等.  如果存在有数据不合法的情况，在应用服务中抛出异常，那这样在应用服务中的判断是否合法，算不算业务逻辑？ 会不会不符合“薄”的定义？ 不知我这样理解对不对？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493589,"discussion_content":"是这样的。应用服务主要是服务的组合和编排。主要的实现逻辑是在领域层。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588836855,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1507024,"avatar":"https://static001.geekbang.org/account/avatar/00/16/fe/d0/e80e4a7e.jpg","nickname":"zhangyi","note":"","ucode":"0C4CAE9DA878F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391465,"discussion_content":"作者总是提到,应用层是做微服务间的编排组合的. 但这类编码组合,他也是业务逻辑啊.\n\n 就像[有生之年]提的一样,应用层此时就有一堆校验了,他已经不薄了啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630476760,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170099,"user_name":"包子","can_delete":false,"product_type":"c1","uid":1089345,"ip_address":"","ucode":"6CC4EBB8CD3924","user_header":"https://static001.geekbang.org/account/avatar/00/10/9f/41/82306dfe.jpg","comment_is_top":false,"comment_ctime":1578531500,"is_pvip":false,"replies":[{"id":"65996","content":"数据是水平切分吧，是不是这样切分后就会跨业务单元调用或者说跨中心调用？<br>这样的业务单元实际是不同的微服务了，你需要在应用层去做分布式事务控制，或者不同的业务单元之间用消息机制也可以。不知道我对你的场景理解的对不对？","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1578536743,"ip_address":"","comment_id":170099,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5873498796","product_id":100037301,"comment_content":"您好老师，有个疑问。<br><br>聚合如果做了数据切片，比如账户的聚合acc001和acc002的数据库做客分库分表。那么在应用层发起一个转账请求就会出现分布事务问题，这种情况怎么解决呢？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480840,"discussion_content":"数据是水平切分吧，是不是这样切分后就会跨业务单元调用或者说跨中心调用？\n这样的业务单元实际是不同的微服务了，你需要在应用层去做分布式事务控制，或者不同的业务单元之间用消息机制也可以。不知道我对你的场景理解的对不对？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578536743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1089345,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9f/41/82306dfe.jpg","nickname":"包子","note":"","ucode":"6CC4EBB8CD3924","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":132660,"discussion_content":"应该是垂直切分，可能我上表达有问题。\n其实就比如一个钱包的账户001是一个实体，那002也是一个实体，现在有一个转钱的命令001向002转10元。\n但是这个001和002实体背后的数据存储是在两个库上的，这就出现了分布式事务。请问这种分布式事务，实在聚合根里面解决，还是在领域服务这一层，还是在应用层呢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578922031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1253652,"avatar":"https://static001.geekbang.org/account/avatar/00/13/21/14/423a821f.jpg","nickname":"Steven","note":"","ucode":"3FE64459842015","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1089345,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9f/41/82306dfe.jpg","nickname":"包子","note":"","ucode":"6CC4EBB8CD3924","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543851,"discussion_content":"是水平切分，分布式事务放在应用层","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641311363,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":132660,"ip_address":""},"score":543851,"extra":""}]}]},{"had_liked":false,"id":151159,"user_name":"瓜瓜","can_delete":false,"product_type":"c1","uid":1108505,"ip_address":"","ucode":"F90A5135A9BB4B","user_header":"https://static001.geekbang.org/account/avatar/00/10/ea/19/14018371.jpg","comment_is_top":false,"comment_ctime":1573658995,"is_pvip":false,"replies":[{"id":"58210","content":"我在你的上个问题回复了，不知道解答你的问题了没有。不知道你的疑问在哪里?如果没解答清楚，麻烦告诉一下你的疑惑在哪里哈。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573698095,"ip_address":"","comment_id":151159,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5868626291","product_id":100037301,"comment_content":"还有这个依赖倒置，一开始感觉很清晰，现在感觉越看越懵，老师能给再解答下吗？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474386,"discussion_content":"我在你的上个问题回复了，不知道解答你的问题了没有。不知道你的疑问在哪里?如果没解答清楚，麻烦告诉一下你的疑惑在哪里哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573698095,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1108505,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ea/19/14018371.jpg","nickname":"瓜瓜","note":"","ucode":"F90A5135A9BB4B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50292,"discussion_content":"看完懂了，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573699907,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360475,"user_name":"A$APRocky","can_delete":false,"product_type":"c1","uid":1405947,"ip_address":"广东","ucode":"D1B5C2F8B1B67C","user_header":"https://static001.geekbang.org/account/avatar/00/15/73/fb/40164b5d.jpg","comment_is_top":false,"comment_ctime":1666587645,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1666587645","product_id":100037301,"comment_content":"aassembler数据转换应该放在dto类里面，他属于类的行为","like_count":0},{"had_liked":false,"id":355819,"user_name":"Geek_deb7fc","can_delete":false,"product_type":"c1","uid":1627053,"ip_address":"陕西","ucode":"6C4B8542C6BF3E","user_header":"","comment_is_top":false,"comment_ctime":1661765706,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661765706","product_id":100037301,"comment_content":"我理解DDD这样的分层设计，是将核心的业务逻辑收敛到了领域层，而传统三层架构是在service层。领域层按照领域模型将领域内逻辑高内聚，防止在应用层扩散","like_count":0},{"had_liked":false,"id":353860,"user_name":"Thomas Yang","can_delete":false,"product_type":"c1","uid":1612933,"ip_address":"上海","ucode":"29249144F708D7","user_header":"","comment_is_top":false,"comment_ctime":1659871852,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1659871852","product_id":100037301,"comment_content":"老师请教一个聚合的设计问题，我们电商系统，订单下单的时候就会拆单，我们叫一个预订单和拆完的一堆子订单，这时候是专门设计个预订单聚合还是普通订单聚合在领域服务里面用List&lt;普通订单&gt;这样处理好一些？","like_count":0},{"had_liked":false,"id":346637,"user_name":"潇洒的毅小峰","can_delete":false,"product_type":"c1","uid":1118141,"ip_address":"","ucode":"24638DAED92F08","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/bd/7a9b2a0c.jpg","comment_is_top":false,"comment_ctime":1653308094,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653308094","product_id":100037301,"comment_content":"老师如果有对外开放的RPC接口，接口层又该如何进行设计呢？<br>","like_count":0},{"had_liked":false,"id":338798,"user_name":"dahai","can_delete":false,"product_type":"c1","uid":1762705,"ip_address":"","ucode":"9F866FC42DF9A8","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIVR2wY9icec2CGzZ4VKPdwK2icytM5k1tHm08qSEysFOgl1y7lk2ccDqSCvzibHufo2Cb9c2hjr0LIg/132","comment_is_top":false,"comment_ctime":1647745698,"is_pvip":false,"discussion_count":0,"race_medal":3,"score":"1647745698","product_id":100037301,"comment_content":"这一套目录结构非常清晰，应该是基于java 语言开发的。想请问一下有没有基于golang的一套目录结构？ 谢谢！","like_count":0},{"had_liked":false,"id":336065,"user_name":"小八哥","can_delete":false,"product_type":"c1","uid":2062472,"ip_address":"","ucode":"CE08853995218E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXGKRyFDH2ia15hV4PeRfgibgb1djXGNibmU4LlMUK5hlHkWpqBpwmEXJ0HBZ2nAN0doQiaGROA5GIhg/132","comment_is_top":false,"comment_ctime":1645877344,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645877344","product_id":100037301,"comment_content":"欧老师，可以举一个facade将用户请求委派给多个应用服务进行处理的例子吗？样例中的业务场景比较简单，三个facade类都只委托了一个应用服务处理","like_count":0},{"had_liked":false,"id":335053,"user_name":"Geek_c8ca1d","can_delete":false,"product_type":"c1","uid":1204885,"ip_address":"","ucode":"70347E01214474","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJ2Z2icQkTpLVcgjUyQ26iasP9awociawqR25wI8FNFnQqWduD17kjtQKWtc9xnH4vXH8fFtbFkO3JZA/132","comment_is_top":false,"comment_ctime":1645275341,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1645275341","product_id":100037301,"comment_content":"我们有个工单系统，有各类工单，没类工单有自己的业务逻辑，又有查询和作废所有工单这类不区分工单的操作，这种场景下工单是属于单个聚合，还是每类工单一类聚合？","like_count":0},{"had_liked":false,"id":333612,"user_name":"JeyChan","can_delete":false,"product_type":"c1","uid":2057835,"ip_address":"","ucode":"344EA9D0ED7A41","user_header":"","comment_is_top":false,"comment_ctime":1644423451,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644423451","product_id":100037301,"comment_content":"充血模型优先。DDD是建议把业务逻辑封装在领域对象中，这里的业务逻辑是包含与db交互这一层面吗？还是说与db交互应该放到仓储层做处理呢？谢谢老师~","like_count":0},{"had_liked":false,"id":330471,"user_name":"Zz","can_delete":false,"product_type":"c1","uid":1296301,"ip_address":"","ucode":"958A5938569EAB","user_header":"https://static001.geekbang.org/account/avatar/00/13/c7/ad/ecb2b27a.jpg","comment_is_top":false,"comment_ctime":1641989336,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641989336","product_id":100037301,"comment_content":"最近一直在想微服务代码工程结构的问题，到底一个模块的代码是分别按照分层放在不同目录好(就是上面老师的工程代码方式)，还是一个模块一个目录，然后目录分不同子目录放对应分层代码代码好？老师，能给点意见吗？","like_count":0},{"had_liked":false,"id":326734,"user_name":"徐李","can_delete":false,"product_type":"c1","uid":1213325,"ip_address":"","ucode":"41550F6CA1E112","user_header":"https://static001.geekbang.org/account/avatar/00/12/83/8d/03cac826.jpg","comment_is_top":false,"comment_ctime":1639649265,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1639649265","product_id":100037301,"comment_content":"这一章结合前面的理论，清晰多了，期待下一章","like_count":0},{"had_liked":false,"id":324879,"user_name":"Geek_ee3fe8","can_delete":false,"product_type":"c1","uid":2854845,"ip_address":"","ucode":"4FF8A113699909","user_header":"","comment_is_top":false,"comment_ctime":1638698915,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638698915","product_id":100037301,"comment_content":"代码案例整理好了吗","like_count":0},{"had_liked":false,"id":323926,"user_name":"ZWeking","can_delete":false,"product_type":"c1","uid":1131048,"ip_address":"","ucode":"81315783ADE8AC","user_header":"https://static001.geekbang.org/account/avatar/00/11/42/28/1603f0f7.jpg","comment_is_top":false,"comment_ctime":1638233769,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638233769","product_id":100037301,"comment_content":"老师，问一下领域服务是操作多个实体和值对象，那么这些实体和值对象是聚合内部的还是其他聚合的，如果本聚合有个逻辑需要查询到外部聚合的信息做计算，是不是也是放在领域服务中，这时领域服务又依赖了外部聚合。","like_count":0},{"had_liked":false,"id":323666,"user_name":"摔跤吧楚钦","can_delete":false,"product_type":"c1","uid":1192627,"ip_address":"","ucode":"2233D34EF7B691","user_header":"https://static001.geekbang.org/account/avatar/00/12/32/b3/a544888a.jpg","comment_is_top":false,"comment_ctime":1638079700,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638079700","product_id":100037301,"comment_content":"config是不是需要分两种，一种是系统配置（例如：DB链接配置），一种是业务配置（理赔结案不超过N天）。业务配置是不是放在聚合包里面，这样更加内聚？","like_count":0},{"had_liked":false,"id":320069,"user_name":"星巴克男孩","can_delete":false,"product_type":"c1","uid":1119692,"ip_address":"","ucode":"D08A72378EC15E","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/cc/82818295.jpg","comment_is_top":false,"comment_ctime":1636075130,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636075130","product_id":100037301,"comment_content":"老师 问下 实体里面可以调仓储的代码吗 实现查询、更新等","like_count":0},{"had_liked":false,"id":315820,"user_name":"Mark Cai","can_delete":false,"product_type":"c1","uid":1941491,"ip_address":"","ucode":"C761ACD418F46F","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/ib7ymR5sdB4HVzia5GNIJ4FAFZEKxgmZxQHIk3ibXB90iaoicq3pId8NcTicA9TmAuTeEFGxLa0HU6bOLPeqIvhy1lcw/132","comment_is_top":false,"comment_ctime":1634009573,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1634009573","product_id":100037301,"comment_content":"老师，不同层次之间的相互调用产生的中间对象需要放在那一层呢，比如DTO,PO，DO这些对象","like_count":0,"discussions":[{"author":{"id":1810606,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a0/ae/8c2bec53.jpg","nickname":"心有我动","note":"","ucode":"ED1451224904F9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547160,"discussion_content":"如果是多个Module，DTO放的位置会影响是否循环依赖的问题，我也想问这个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642560870,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312762,"user_name":"jackms","can_delete":false,"product_type":"c1","uid":2765828,"ip_address":"","ucode":"B3500D1DE9C67D","user_header":"https://static001.geekbang.org/account/avatar/00/2a/34/04/d3f986d5.jpg","comment_is_top":false,"comment_ctime":1631972496,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631972496","product_id":100037301,"comment_content":"值对象呢，放在哪个包下面啊","like_count":0},{"had_liked":false,"id":312610,"user_name":"歪头儿在帝都","can_delete":false,"product_type":"c1","uid":1220330,"ip_address":"","ucode":"ADF272E86CDDDB","user_header":"https://static001.geekbang.org/account/avatar/00/12/9e/ea/f556db9a.jpg","comment_is_top":false,"comment_ctime":1631889645,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631889645","product_id":100037301,"comment_content":"老师，Domian这块的事件publish和subscribe你推荐什么技术实现呢，或者用什么组件实现呢，谢谢","like_count":0},{"had_liked":false,"id":310457,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1630660821,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630660821","product_id":100037301,"comment_content":"    public void create(Person person) {<br>        PersonPO personPO = personRepository.findById(person.getPersonId());<br>&#47;&#47;这里应该是null != personPO吧<br>        if (null == personPO) {<br>            throw new RuntimeException(&quot;Person already exists&quot;);<br>        }<br>        person.create();<br>        personRepository.insert(personFactory.createPersonPO(person));<br>    }","like_count":0},{"had_liked":false,"id":309337,"user_name":"花生","can_delete":false,"product_type":"c1","uid":1266634,"ip_address":"","ucode":"5397C08BD51DD4","user_header":"https://static001.geekbang.org/account/avatar/00/13/53/ca/44088dd0.jpg","comment_is_top":false,"comment_ctime":1630052494,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630052494","product_id":100037301,"comment_content":"请问ddd有没有专门的设计工具","like_count":0},{"had_liked":false,"id":304467,"user_name":"e^x","can_delete":false,"product_type":"c1","uid":1054108,"ip_address":"","ucode":"29B56E0DF4EF48","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/9c/310c902c.jpg","comment_is_top":false,"comment_ctime":1627439558,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627439558","product_id":100037301,"comment_content":"老师你好，有个困惑：<br>比如：在电商的“用户”领域内，“用户”聚合包含“收货地址”值对象，收货地址的查询需要依赖二方提供的基础服务。<br>那么，在构建“用户”这个聚合的“收货地址”值对象的时候，需要调用二方的服务，这个服务的调用应该放在domain&#47;aggregate&#47;service里吗？因为上面的文章里说调用外部服务一般都放在应用层去封装和编排，所以有点困惑。","like_count":0},{"had_liked":false,"id":302026,"user_name":"独孤九剑","can_delete":false,"product_type":"c1","uid":2230909,"ip_address":"","ucode":"6C1253E2B8C1D4","user_header":"https://static001.geekbang.org/account/avatar/00/22/0a/7d/ac715471.jpg","comment_is_top":false,"comment_ctime":1626048984,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626048984","product_id":100037301,"comment_content":"“边界”是关键，“领域”的本质就是“边界”","like_count":0},{"had_liked":false,"id":297618,"user_name":"唐江","can_delete":false,"product_type":"c1","uid":1878120,"ip_address":"","ucode":"867C9808CF7760","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJpJXWFP3dNle88WnTkRTsEQkPJmOhepibiaTfhEtMRrbdg5EAWm4EzurA61oKxvCK2ZjMmy1QvmChw/132","comment_is_top":false,"comment_ctime":1623672977,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623672977","product_id":100037301,"comment_content":"应用服务层 调用其他微服务接口返回的DTO，如何这个DTO转换成可以调用本微服务内的某个领域服务需要的参数类型？ 或者这个转换的代码应该放在哪里？ 我看代码模型里面没有考虑这种情况的转换呢？","like_count":0},{"had_liked":false,"id":290295,"user_name":"Black","can_delete":false,"product_type":"c1","uid":1643106,"ip_address":"","ucode":"617BF7CFB2C97B","user_header":"https://static001.geekbang.org/account/avatar/00/19/12/62/b965c3f8.jpg","comment_is_top":false,"comment_ctime":1619489222,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619489222","product_id":100037301,"comment_content":"订单有个发货状态的属性， 实际在场景种都是批量发货的，所以批量修改发货状态，是有个订单的实体列表，然后循环设置实体的发货状态，循环修改持久层，还是实体修改属性值之后，拿到列表实体的一个map，一次性修改持久层","like_count":0},{"had_liked":false,"id":288513,"user_name":"Keith","can_delete":false,"product_type":"c1","uid":1193337,"ip_address":"","ucode":"B40774090714D1","user_header":"https://static001.geekbang.org/account/avatar/00/12/35/79/21647da2.jpg","comment_is_top":false,"comment_ctime":1618500258,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618500258","product_id":100037301,"comment_content":"关于领域层仓储的设计, 把本该属于基础层的功能放到聚合内, 理由是&quot;需求或者设计发生变化导致聚合需要拆分或重组时&quot;好迁移, 但把功能放到基础层不是更好迁移吗? 这样领域层的仓储只是依赖于仓储抽象, 完全屏蔽了基础层实现的具体仓储细节, 不是更好吗?","like_count":0},{"had_liked":false,"id":288057,"user_name":"Geek_6d0848","can_delete":false,"product_type":"c1","uid":1662147,"ip_address":"","ucode":"E64613EE4727CB","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/LmPLSkl3NG3gjvL4vSszZvLzv6eWt4XV2oQzvWHjGJtNNkIYYbAfxON6LRt8EII0qduBiaCUMhQEmDKcSkFFb1A/132","comment_is_top":false,"comment_ctime":1618283073,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618283073","product_id":100037301,"comment_content":"对于单体初期的DDD是否可用将Application层接口给其他模块调用 您的建议是什么","like_count":0},{"had_liked":false,"id":274685,"user_name":"谢作作的男人","can_delete":false,"product_type":"c1","uid":1909094,"ip_address":"","ucode":"4F220EA8AEBFB9","user_header":"https://static001.geekbang.org/account/avatar/00/1d/21/66/85f247e2.jpg","comment_is_top":false,"comment_ctime":1611124735,"is_pvip":false,"replies":[{"id":"101047","content":"不同微服务之间应用服务可以通过API网关调用其他微服务的用户接口层的服务，然后调用领域服务。微服务之间一般不直接调用领域层的业务逻辑。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1612855976,"ip_address":"","comment_id":274685,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1611124735","product_id":100037301,"comment_content":"老师，关于服务之间的调用，是在application层调用其他微服务的application层的服务还是领域层服务，可以直接依赖其他服务的domain吗","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514085,"discussion_content":"不同微服务之间应用服务可以通过API网关调用其他微服务的用户接口层的服务，然后调用领域服务。微服务之间一般不直接调用领域层的业务逻辑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612855976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":271142,"user_name":"Geek_857d5d","can_delete":false,"product_type":"c1","uid":2350608,"ip_address":"","ucode":"0991A1F3B69A1E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/icLicfovLhuA0ico15MCRibfxGWVJI9xTNiapMoicnwwZlHiaM6LkhyGpYXzcEobicbwbx01oDoYDtiamvZJLbwibCLK5GuQ/132","comment_is_top":false,"comment_ctime":1609410560,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609410560","product_id":100037301,"comment_content":"domain 中 event 中 interface 的存在吗 service去实现他","like_count":0},{"had_liked":false,"id":230329,"user_name":"bornli(李磊)","can_delete":false,"product_type":"c1","uid":1160888,"ip_address":"","ucode":"06D46CFE87DC7F","user_header":"https://static001.geekbang.org/account/avatar/00/11/b6/b8/b0c7486a.jpg","comment_is_top":false,"comment_ctime":1593348468,"is_pvip":false,"replies":[{"id":"85216","content":"DDD分层架构有一个重要的依赖原则：“每层只能与位于其下方的层发生耦合”。<br>根据耦合的紧密程度可以分为两种架构模式：严格分层架构和松散分层架构。<br>严格分层架构任何层只能对位于其直接下方的层产生依赖，而松散分层架构则允许某层与其任意下方的层发生依赖。<br>那在设计时，我们应该选择什么样的架构模式呢？<br>为了服务调用的可管理，我建议你采用严格分层架构。<br>这是因为在严格分层架构中，实体方法只能被领域服务封装，领域服务只能被应用服务调用，而应用服务只能被用户接口层封装，服务是逐层对外封装或组合的，这种服务之间的依赖关系和职责边界非常清晰。<br>而在松散分层架构中，实体的方法和领域服务可以跨层同时被应用层或用户接口层调用，服务的依赖关系比较复杂且难管理，而且容易暴露底层核心业务逻辑的实现机制。<br>","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1593497614,"ip_address":"","comment_id":230329,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1593348468","product_id":100037301,"comment_content":"老师，我看有的领域层拆分，聚合和领域服务分离的，一个聚合里面，有些方法不属于实体的时候，才会放到领域服务里面，也就是说上层应用层可以调实体、可以调领域服务，和老师这里说的应用层，统一调领域服务不太一样","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499841,"discussion_content":"DDD分层架构有一个重要的依赖原则：“每层只能与位于其下方的层发生耦合”。\n根据耦合的紧密程度可以分为两种架构模式：严格分层架构和松散分层架构。\n严格分层架构任何层只能对位于其直接下方的层产生依赖，而松散分层架构则允许某层与其任意下方的层发生依赖。\n那在设计时，我们应该选择什么样的架构模式呢？\n为了服务调用的可管理，我建议你采用严格分层架构。\n这是因为在严格分层架构中，实体方法只能被领域服务封装，领域服务只能被应用服务调用，而应用服务只能被用户接口层封装，服务是逐层对外封装或组合的，这种服务之间的依赖关系和职责边界非常清晰。\n而在松散分层架构中，实体的方法和领域服务可以跨层同时被应用层或用户接口层调用，服务的依赖关系比较复杂且难管理，而且容易暴露底层核心业务逻辑的实现机制。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593497614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219434,"user_name":"润！","can_delete":false,"product_type":"c1","uid":1237696,"ip_address":"","ucode":"13B7C23B5F6B24","user_header":"https://static001.geekbang.org/account/avatar/00/12/e2/c0/09cef977.jpg","comment_is_top":false,"comment_ctime":1590025634,"is_pvip":false,"replies":[{"id":"81073","content":"是的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1590041250,"ip_address":"","comment_id":219434,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590025634","product_id":100037301,"comment_content":"分布式的时候，是一个微服务一个源代码？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495807,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590041250,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":213496,"user_name":"StopLiu","can_delete":false,"product_type":"c1","uid":1007344,"ip_address":"","ucode":"1553FA4E3A285D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/f0/fab69114.jpg","comment_is_top":false,"comment_ctime":1588433053,"is_pvip":false,"replies":[{"id":"79534","content":"不清楚阿里的代码规范是什么样的哈。<br>是不是可以稍微调整一下，做好领域模型与其它层的边界，然后确保聚合的边界，也是可以的。其它层大多是用于实现转换和适配的作用。<br>总之先要处理好领域模型，聚合与聚合的边界。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1588835864,"ip_address":"","comment_id":213496,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1588433053","product_id":100037301,"comment_content":"老师，公司java开发是按照阿里的代码规范，没办法用ddd推荐的代码结构，是不是就意味着没法用ddd了？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493798,"discussion_content":"不清楚阿里的代码规范是什么样的哈。\n是不是可以稍微调整一下，做好领域模型与其它层的边界，然后确保聚合的边界，也是可以的。其它层大多是用于实现转换和适配的作用。\n总之先要处理好领域模型，聚合与聚合的边界。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588835864,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1941491,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/ib7ymR5sdB4HVzia5GNIJ4FAFZEKxgmZxQHIk3ibXB90iaoicq3pId8NcTicA9TmAuTeEFGxLa0HU6bOLPeqIvhy1lcw/132","nickname":"Mark Cai","note":"","ucode":"C761ACD418F46F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":403113,"discussion_content":"代码规范和DDD实践不冲突，两个可以一起用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634009713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1067814,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4b/26/9f5f94f5.jpg","nickname":"Charlie","note":"","ucode":"E4930E17311C60","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306583,"discussion_content":"阿里的BO相当于DDD中的DO","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600323727,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":201282,"user_name":"HUNTER","can_delete":false,"product_type":"c1","uid":1114579,"ip_address":"","ucode":"184725E9ED0E2C","user_header":"https://static001.geekbang.org/account/avatar/00/11/01/d3/5cbaeb95.jpg","comment_is_top":false,"comment_ctime":1585745124,"is_pvip":false,"replies":[{"id":"75259","content":"其实事件发布在应用层、领域层都是可以的。但是一般产生事件的时候，往往会生成某一个比较关键的实体对象，而这个操作往往会跟save或者update相关，所以事件的发布一般会在领域层的event中。<br>应用层也有事件，我们可以用应用层的event去订阅外部的事件，在接收到事件后，可以调用领域层的领域服务完成后续的业务逻辑处理。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1585748670,"ip_address":"","comment_id":201282,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585745124","product_id":100037301,"comment_content":"老师，领域层的Event和应用层的Event区别是什么呢？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490290,"discussion_content":"其实事件发布在应用层、领域层都是可以的。但是一般产生事件的时候，往往会生成某一个比较关键的实体对象，而这个操作往往会跟save或者update相关，所以事件的发布一般会在领域层的event中。\n应用层也有事件，我们可以用应用层的event去订阅外部的事件，在接收到事件后，可以调用领域层的领域服务完成后续的业务逻辑处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585748670,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183882,"user_name":"see","can_delete":false,"product_type":"c1","uid":1644634,"ip_address":"","ucode":"F1F1CD1D85DDB5","user_header":"https://static001.geekbang.org/account/avatar/00/19/18/5a/a49a9353.jpg","comment_is_top":false,"comment_ctime":1583153482,"is_pvip":false,"replies":[{"id":"71221","content":"建议你结合DDD的分层架构模型那一节，了解一下DDD的分层架构的好处，将领域层单独放在一起，然后应用层来组合和编排领域服务，可以保持领域模型的稳定，同时又可以实现灵活的编排，这种方式是跟传统的三层架构不一样的，这也是微服务为什么要采用端口适配器模式的原因。<br>一个微服务是包含了领域层、应用层、用户接口层和基础层，每层有相关的代码逻辑，定位是不一样的。<br>相关的代码实现建议你看一下加餐中的内容。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1583201132,"ip_address":"","comment_id":183882,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1583153482","product_id":100037301,"comment_content":"老师你好，我看你这些目录结构所有领域层都放在domain目录下，我在搭建系统的时候会把一个框架当成一个领域层，然后应用层利用rpc访问领域层，请问：<br>1.用一个框架当成一个领域层是否太臃肿。<br>2.领域层是否不需要rpc调用<br>3.是否一个微服务就是一个框架","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485807,"discussion_content":"建议你结合DDD的分层架构模型那一节，了解一下DDD的分层架构的好处，将领域层单独放在一起，然后应用层来组合和编排领域服务，可以保持领域模型的稳定，同时又可以实现灵活的编排，这种方式是跟传统的三层架构不一样的，这也是微服务为什么要采用端口适配器模式的原因。\n一个微服务是包含了领域层、应用层、用户接口层和基础层，每层有相关的代码逻辑，定位是不一样的。\n相关的代码实现建议你看一下加餐中的内容。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583201132,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182513,"user_name":"Tesla","can_delete":false,"product_type":"c1","uid":1500742,"ip_address":"","ucode":"98629AFD9861EE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKUcSLVV6ia3dibe7qvTu8Vic1PVs2EibxoUdx930MC7j2Q9A6s4eibMDZlcicMFY0D0icd3RrDorMChu0zw/132","comment_is_top":false,"comment_ctime":1582799417,"is_pvip":false,"replies":[{"id":"70639","content":"理论上它应该在基础层的，放这里主要是以后聚合代码随着微服务架构演进时，可以直接将聚合目录所在的所有代码一次拆分打包走。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1582800548,"ip_address":"","comment_id":182513,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1582799417","product_id":100037301,"comment_content":"老师，数据库在基础层里，为什么持久化的仓储在领域层里啊","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485362,"discussion_content":"理论上它应该在基础层的，放这里主要是以后聚合代码随着微服务架构演进时，可以直接将聚合目录所在的所有代码一次拆分打包走。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582800548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182499,"user_name":"Tesla","can_delete":false,"product_type":"c1","uid":1500742,"ip_address":"","ucode":"98629AFD9861EE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKUcSLVV6ia3dibe7qvTu8Vic1PVs2EibxoUdx930MC7j2Q9A6s4eibMDZlcicMFY0D0icd3RrDorMChu0zw/132","comment_is_top":false,"comment_ctime":1582796806,"is_pvip":false,"replies":[{"id":"70638","content":"是的，又叫门面模式。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1582800418,"ip_address":"","comment_id":182499,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1582796806","product_id":100037301,"comment_content":"老师，Facade放在Interface层。这里的Facade是外观模式的Facade吗？是因为一个接口会调用多个应用服务吗？应用服务再调用多个领域服务。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485356,"discussion_content":"是的，又叫门面模式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582800418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167802,"user_name":"Jack.Chen","can_delete":false,"product_type":"c1","uid":1233590,"ip_address":"","ucode":"3A321C759AA0AC","user_header":"https://static001.geekbang.org/account/avatar/00/12/d2/b6/31837c65.jpg","comment_is_top":false,"comment_ctime":1577937137,"is_pvip":false,"replies":[{"id":"65135","content":"都可以实现。但建议放在领域服务或者实体方法中。由于聚合的持久化是将所以聚合内对象作为一个整体操作，建议采用工厂和仓储模式，在领域服务中实现。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1577947274,"ip_address":"","comment_id":167802,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1577937137","product_id":100037301,"comment_content":"一个聚合的实体，他的持久化在实体内部完成，还是在领域服务完成，还是应用服务完成","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480001,"discussion_content":"都可以实现。但建议放在领域服务或者实体方法中。由于聚合的持久化是将所以聚合内对象作为一个整体操作，建议采用工厂和仓储模式，在领域服务中实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577947274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159626,"user_name":"嘉嘉☕","can_delete":false,"product_type":"c1","uid":1059771,"ip_address":"","ucode":"632A5CC4B53BB1","user_header":"https://static001.geekbang.org/account/avatar/00/10/2b/bb/5cf70df8.jpg","comment_is_top":false,"comment_ctime":1575708420,"is_pvip":false,"replies":[{"id":"60995","content":"是从应用层发起的。方法是逐层封装，一直到应用服务。微服务内应尽量避免领域服务在不同聚合之间的调用，这样聚合之间耦合度会比较高。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1575725609,"ip_address":"","comment_id":159626,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1575708420","product_id":100037301,"comment_content":"老师好!<br>请问, <br>同一个微服务内, 跨领域的方法调用, 我们可以在应用层进行组合和编排, <br>那么, <br>微服务间的领域方法调用是怎样的呢 ?<br>被调用者, 方法是从哪一层暴露出去的 ?<br>调用者, 是从哪一层发起调用请求的 ?<br>谢谢!","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477123,"discussion_content":"是从应用层发起的。方法是逐层封装，一直到应用服务。微服务内应尽量避免领域服务在不同聚合之间的调用，这样聚合之间耦合度会比较高。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575725609,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159520,"user_name":"OTM","can_delete":false,"product_type":"c1","uid":1074017,"ip_address":"","ucode":"D96E9A661F122B","user_header":"https://static001.geekbang.org/account/avatar/00/10/63/61/d259f7a9.jpg","comment_is_top":false,"comment_ctime":1575645663,"is_pvip":false,"replies":[{"id":"60967","content":"在接口层定义DTO对象。数据可能来源于多个DO对象。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1575673479,"ip_address":"","comment_id":159520,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1575645663","product_id":100037301,"comment_content":"如果在接口层需要返回：用户名称，积分数，卡券数，向后续应用层传递的不一定是领域对象 返回的业不一定是具体领域，可能是一个聚合服务，那这里返回的对象应该再那里定义，应用层，还是接口曾","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477084,"discussion_content":"在接口层定义DTO对象。数据可能来源于多个DO对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575673479,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1074017,"avatar":"https://static001.geekbang.org/account/avatar/00/10/63/61/d259f7a9.jpg","nickname":"OTM","note":"","ucode":"D96E9A661F122B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74696,"discussion_content":"还是有一些疑惑\n用户接口层：\n    Assembler 实现dto 与Do的转换(应用层返回的是Do)\n应用层\n      实现服务的编排与组装.,多个服务的调用在这里，多个领域的数据应该在这里进行组合，返回的又是dto ,是否与接口层接受Do不一致","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575675109,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159044,"user_name":"Geek_aa8017","can_delete":false,"product_type":"c1","uid":1748911,"ip_address":"","ucode":"286195887103C2","user_header":"","comment_is_top":false,"comment_ctime":1575522692,"is_pvip":false,"replies":[{"id":"60843","content":"用户接口层就是用来封装应用服务和对外暴露接口的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1575528692,"ip_address":"","comment_id":159044,"utype":1}],"discussion_count":6,"race_medal":0,"score":"1575522692","product_id":100037301,"comment_content":"老师，跨微服务调用用的是dubbo, dubbo暴露的接口应该定义在哪里","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476929,"discussion_content":"用户接口层就是用来封装应用服务和对外暴露接口的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575528692,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1070136,"avatar":"https://static001.geekbang.org/account/avatar/00/10/54/38/f43c925e.jpg","nickname":"青青子衿","note":"","ucode":"8DA45FC6A94306","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":203300,"discussion_content":"dubbo接口实现应该是在应用层吧，应用层调用领域层的service方法。用户接口层应该是controller，转换协议，封装现实信息。不知道理解的是否对？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584021709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1100064,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","nickname":"zj","note":"","ucode":"E3329CCF694AC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73419,"discussion_content":"我理解api网关是接口层，应用服务就是dubbo暴露的接口吧？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575559169,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1748911,"avatar":"","nickname":"Geek_aa8017","note":"","ucode":"286195887103C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1100064,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","nickname":"zj","note":"","ucode":"E3329CCF694AC2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73649,"discussion_content":"dubbo调用需要耦合api的，这个api是定义在哪里呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575565389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":73419,"ip_address":""},"score":73649,"extra":""},{"author":{"id":1100064,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","nickname":"zj","note":"","ucode":"E3329CCF694AC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1748911,"avatar":"","nickname":"Geek_aa8017","note":"","ucode":"286195887103C2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73750,"discussion_content":"不明白的意思，你可以写一个dubbo服务将它作为api暴露给网关，我们公司是在发布的时候通过识别api注解来完成api网关注册的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575593923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":73649,"ip_address":""},"score":73750,"extra":""},{"author":{"id":1748911,"avatar":"","nickname":"Geek_aa8017","note":"","ucode":"286195887103C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1100064,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","nickname":"zj","note":"","ucode":"E3329CCF694AC2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73930,"discussion_content":"比如说本服务有一个dubbo接口IOrderService，这个接口需要在另一个服务被调用，那就要引用到这个IOrderService，dubbo的效果就是让你觉得调远程服务像调本地方法一样啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575611763,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":73750,"ip_address":""},"score":73930,"extra":""}]}]},{"had_liked":false,"id":158150,"user_name":"瓜瓜","can_delete":false,"product_type":"c1","uid":1108505,"ip_address":"","ucode":"F90A5135A9BB4B","user_header":"https://static001.geekbang.org/account/avatar/00/10/ea/19/14018371.jpg","comment_is_top":false,"comment_ctime":1575338929,"is_pvip":false,"replies":[{"id":"60594","content":"工厂模式主要是实现复杂聚合的实体的数据初始化。如果实体太多，聚合根处理起来会很复杂，通过工厂一次初始化。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1575343737,"ip_address":"","comment_id":158150,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1575338929","product_id":100037301,"comment_content":"Entity（实体）：它存放聚合根、实体、值对象以及工厂模式（Factory）相关代码；此处的工厂模式，主要是来实现实体吗？？这块理解的不是很清晰，望老师帮忙解答。感谢！","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476642,"discussion_content":"工厂模式主要是实现复杂聚合的实体的数据初始化。如果实体太多，聚合根处理起来会很复杂，通过工厂一次初始化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575343737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155676,"user_name":"vivi","can_delete":false,"product_type":"c1","uid":1357983,"ip_address":"","ucode":"360A81D2003C99","user_header":"https://static001.geekbang.org/account/avatar/00/14/b8/9f/c64f0896.jpg","comment_is_top":false,"comment_ctime":1574735253,"is_pvip":false,"replies":[{"id":"59781","content":"大量复杂查询的场景下使用。DDD不擅长大量数据查询。其实CQRS查询也可以在同一个微服务内。数据分库也可以，但数据实时性不好保证。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574747803,"ip_address":"","comment_id":155676,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574735253","product_id":100037301,"comment_content":"老师，像COMMAND，QUERY 层这种CQRS的什么场景下使用呢？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475827,"discussion_content":"大量复杂查询的场景下使用。DDD不擅长大量数据查询。其实CQRS查询也可以在同一个微服务内。数据分库也可以，但数据实时性不好保证。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574747803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152309,"user_name":"Geek_435a60","can_delete":false,"product_type":"c1","uid":1263925,"ip_address":"","ucode":"4FF6B2EB9F1BFA","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/35/191c9db1.jpg","comment_is_top":false,"comment_ctime":1573967926,"is_pvip":true,"replies":[{"id":"58546","content":"不同的对象在不同的层转换。用户接口层DTO和DO转换，应用层主要是DO，调外部微服务的服务的时候应用层有dto和do的转换。领域层与基础层之间，在基础层有DO和PO的转换。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573986659,"ip_address":"","comment_id":152309,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573967926","product_id":100037301,"comment_content":"有一个细节，想问下是如何处理的，接口层接收到的DTO对象,里面的字段跨多个DO，你没办法将一个DTO 完全转成一个DO，这里可能一个DTO的一些字段压根DO里就没有，这个时候 如果 从接口层 传到应用层，再传到 领域层？再封装一个VO对象？然后这个VO对象 是属于领域层？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474780,"discussion_content":"不同的对象在不同的层转换。用户接口层DTO和DO转换，应用层主要是DO，调外部微服务的服务的时候应用层有dto和do的转换。领域层与基础层之间，在基础层有DO和PO的转换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573986659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151733,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1573782752,"is_pvip":false,"replies":[{"id":"58338","content":"对外还是尽量靠应用服务来实现。<br>领域服务也不是不能做，要考虑耦合和对核心逻辑的影响，综合考虑成本吧。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573785653,"ip_address":"","comment_id":151733,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573782752","product_id":100037301,"comment_content":"今天的文章中写到应用层编排领域服务和外部服务。领域服务可以直接调用外部服务吗？比如一项业务是先根据实体组装调用参数，然后调用外部服务，再根据结果更新前面实体的状态，那这项业务是由领域服务整体实现？还是由应用层来编排，调实体获取参数，调外部服务，调实体更新状态？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474593,"discussion_content":"对外还是尽量靠应用服务来实现。\n领域服务也不是不能做，要考虑耦合和对核心逻辑的影响，综合考虑成本吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573785653,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151596,"user_name":"美美","can_delete":false,"product_type":"c1","uid":1148422,"ip_address":"","ucode":"44CC95C45AF345","user_header":"https://static001.geekbang.org/account/avatar/00/11/86/06/72b01bb7.jpg","comment_is_top":false,"comment_ctime":1573747026,"is_pvip":false,"replies":[{"id":"58281","content":"是在一个部署单元，它们合在一起就是一个微服务。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573773933,"ip_address":"","comment_id":151596,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573747026","product_id":100037301,"comment_content":"请问下接口层，应用层，领域层，基础层是一个部署单元还是4个部署单元，老师可以截一个真实项目的maven项目结构吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474548,"discussion_content":"是在一个部署单元，它们合在一起就是一个微服务。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573773933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151538,"user_name":"Todd  BD","can_delete":false,"product_type":"c1","uid":1015267,"ip_address":"","ucode":"21F27169916949","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/e3/ad6a4758.jpg","comment_is_top":false,"comment_ctime":1573737703,"is_pvip":false,"replies":[{"id":"58265","content":"松散分层架构是可以的。严格分层架构只能调用它的紧邻的下层。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573741859,"ip_address":"","comment_id":151538,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573737703","product_id":100037301,"comment_content":"只有应用层的方法才允许暴露给接口层吗？ 比如聚合的service已经能很好的表达业务的诉求，而且并不需要在应用层进行编排，是否在接口层可以直接调用聚合的service？ 还是需要在应用层代理一次供接口层调用？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474522,"discussion_content":"松散分层架构是可以的。严格分层架构只能调用它的紧邻的下层。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573741859,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151477,"user_name":"Todd  BD","can_delete":false,"product_type":"c1","uid":1015267,"ip_address":"","ucode":"21F27169916949","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/e3/ad6a4758.jpg","comment_is_top":false,"comment_ctime":1573727875,"is_pvip":false,"replies":[{"id":"58262","content":"你可以分别调两个聚合的领域服务，然后将两个聚合根的DO对象转换为一个DTO，就可以给前端提供包含两个聚合数据的数据服务了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573736641,"ip_address":"","comment_id":151477,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1573727875","product_id":100037301,"comment_content":"如果我有多个聚合， 比如聚合根A和聚合根B， 从业务的角度讲，可以接受AB间数据的最终一致性，但从数据展示的角度考虑， A和B是有强关联性的，也就是说在页面上，他们总是一起在页面的某部分出现， 那么在应用层是否要在query 接口中把这两个聚合根封装成一个新的对象再返回？ <br>还是我想的太多了， application层应该以增 删 改这种业务诉求为导向设计， 而query这种诉求应该用类似CQRS中的query model去实现？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474488,"discussion_content":"你可以分别调两个聚合的领域服务，然后将两个聚合根的DO对象转换为一个DTO，就可以给前端提供包含两个聚合数据的数据服务了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573736641,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50593,"discussion_content":"可以是一个，也可以不是一个。看你怎么设计。到仓储的时候，DO还要转换成PO的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573738008,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015267,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7d/e3/ad6a4758.jpg","nickname":"Todd  BD","note":"","ucode":"21F27169916949","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50587,"discussion_content":"如果这样的话 查询使用的DTO和对于聚合AB保存修改业务的DTO就是不同的DTO了， 我的认知对吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573737121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151332,"user_name":"瓜瓜","can_delete":false,"product_type":"c1","uid":1108505,"ip_address":"","ucode":"F90A5135A9BB4B","user_header":"https://static001.geekbang.org/account/avatar/00/10/ea/19/14018371.jpg","comment_is_top":false,"comment_ctime":1573700892,"is_pvip":false,"replies":[{"id":"58230","content":"😄","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573716112,"ip_address":"","comment_id":151332,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573700892","product_id":100037301,"comment_content":"Repository（仓储）：它存放所在聚合的查询或持久化领域对象的代码，通常包括仓储接口和仓储实现方法。为了方便聚合的拆分和组合，我们设定了一个原则：一个聚合对应一个仓储。特别说明：按照 DDD 分层架构，仓储实现本应该属于基础层代码，但为了在微服务架构演进时，保证代码拆分和重组的便利性，我是把聚合仓储实现的代码放到了聚合包内。这样，如果需求或者设计发生变化导致聚合需要拆分或重组时，我们就可以将包括核心业务逻辑和仓储代码的聚合包整体迁移，轻松实现微服务架构演进。<br><br>给老师点赞","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474440,"discussion_content":"😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573716112,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151251,"user_name":"Harvey","can_delete":false,"product_type":"c1","uid":1254112,"ip_address":"","ucode":"164D1178DA091A","user_header":"https://static001.geekbang.org/account/avatar/00/13/22/e0/6295a753.jpg","comment_is_top":false,"comment_ctime":1573691769,"is_pvip":true,"replies":[{"id":"58264","content":"这些是基础层的组件吧。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573739576,"ip_address":"","comment_id":151251,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573691769","product_id":100037301,"comment_content":"spring-mvc的Controller和Intercepter应该放在哪个目录下呢？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474416,"discussion_content":"这些是基础层的组件吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573739576,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151156,"user_name":"ZIxuAN","can_delete":false,"product_type":"c1","uid":1256455,"ip_address":"","ucode":"C04260E5E384A7","user_header":"https://static001.geekbang.org/account/avatar/00/13/2c/07/06460a88.jpg","comment_is_top":false,"comment_ctime":1573658951,"is_pvip":false,"replies":[{"id":"58181","content":"批量的查询我不太建议走聚合根，不走聚合根，用传统方法也行。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573685757,"ip_address":"","comment_id":151156,"utype":1}],"discussion_count":5,"race_medal":0,"score":"1573658951","product_id":100037301,"comment_content":"每次通过聚合执行一些操作之前都要先查询聚合，如果这个聚合要从很多表中查数据组装的话性能就很低，请问这里是不是要针对整个聚合根加缓存呢？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474384,"discussion_content":"批量的查询我不太建议走聚合根，不走聚合根，用传统方法也行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573685757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1256455,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2c/07/06460a88.jpg","nickname":"ZIxuAN","note":"","ucode":"C04260E5E384A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51185,"discussion_content":"额，我说的不是专门针对查询的业务，比如说社区的帖子有一个编辑功能，那么假设帖子是实体，实体中有一个行为方法编辑，传统的话只要一个update一条sql，而现在需要先查询出实体才能调用它的行为，也就是多查询了一次。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573821281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50596,"discussion_content":"SQL之类的。不通过聚合根。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573738068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015267,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7d/e3/ad6a4758.jpg","nickname":"Todd  BD","note":"","ucode":"21F27169916949","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50590,"discussion_content":"回复中的传统模式是指什么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573737358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1084233,"avatar":"https://static001.geekbang.org/account/avatar/00/10/8b/49/4680be57.jpg","nickname":"大汤圆","note":"","ucode":"D1601F99834955","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1015267,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7d/e3/ad6a4758.jpg","nickname":"Todd  BD","note":"","ucode":"21F27169916949","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50718,"discussion_content":"读的操作，其实可以在应用层直接调用仓储，做VO的封装。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573746543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":50590,"ip_address":""},"score":50718,"extra":""}]}]},{"had_liked":false,"id":151138,"user_name":"墨名次","can_delete":false,"product_type":"c1","uid":1330267,"ip_address":"","ucode":"926EDC57291C09","user_header":"https://static001.geekbang.org/account/avatar/00/14/4c/5b/5499d6e6.jpg","comment_is_top":false,"comment_ctime":1573657329,"is_pvip":false,"replies":[{"id":"58184","content":"你可以理解为一个领域服务就是一个方法，一个方法设计为一个类，而不是将所有的方法放在一个类里，这样当领域服务业务逻辑很复杂的时候，一个类的代码量就不会太大了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573687867,"ip_address":"","comment_id":151138,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573657329","product_id":100037301,"comment_content":"“我建议你将一个领域服务设计为一个领域服务类，避免由于所有领域服务代码都放在一个领域服务类中，而出现代码臃肿的问题。”…这句话好矛盾啊，不应该是一个领域服务设计多个领域服务类，才能避免所有领域服务代码都放在一个领域服务类里面吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474376,"discussion_content":"你可以理解为一个领域服务就是一个方法，一个方法设计为一个类，而不是将所有的方法放在一个类里，这样当领域服务业务逻辑很复杂的时候，一个类的代码量就不会太大了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573687867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151077,"user_name":"瓜瓜","can_delete":false,"product_type":"c1","uid":1053853,"ip_address":"","ucode":"2E98377E48399E","user_header":"https://static001.geekbang.org/account/avatar/00/10/14/9d/19dcdd42.jpg","comment_is_top":false,"comment_ctime":1573651042,"is_pvip":false,"replies":[{"id":"58164","content":"概念确实有点多哈。今天讲的就是微服务内的代码结构。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573655260,"ip_address":"","comment_id":151077,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573651042","product_id":100037301,"comment_content":"通用语言，我感觉我们在学习这个课程的时候，就需要通用语言，很过名词和概念到现在已经开始有点混淆了。好像需要重头再看一遍了。<br>今天我们讲的这个是一个微服务内的代码结构是吧？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474356,"discussion_content":"概念确实有点多哈。今天讲的就是微服务内的代码结构。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573655260,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151072,"user_name":"瓜瓜","can_delete":false,"product_type":"c1","uid":1053853,"ip_address":"","ucode":"2E98377E48399E","user_header":"https://static001.geekbang.org/account/avatar/00/10/14/9d/19dcdd42.jpg","comment_is_top":false,"comment_ctime":1573650689,"is_pvip":false,"replies":[{"id":"58157","content":"是这样的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573653278,"ip_address":"","comment_id":151072,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573650689","product_id":100037301,"comment_content":"差异我想是因人而异的，如果能把业务理解透彻，业务模型划分清楚，代码职责能很明确。<br>这种差异我想不会太大。DDD这种设计思想，我想就是一种工具化的方法，帮助我们能实现以上目标的一种途径。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474354,"discussion_content":"是这样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573653278,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150923,"user_name":"何沛","can_delete":false,"product_type":"c1","uid":1477145,"ip_address":"","ucode":"5673C580982710","user_header":"https://static001.geekbang.org/account/avatar/00/16/8a/19/a54761af.jpg","comment_is_top":false,"comment_ctime":1573628789,"is_pvip":false,"replies":[{"id":"58042","content":"是的。<br>微服务架构下要考虑新的设计方法。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573633893,"ip_address":"","comment_id":150923,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573628789","product_id":100037301,"comment_content":"三层架构在微服务系统是不合时宜的。因为应用层和领域层耦合在一起，会导致你的领域层被频繁的需求变更，变得越来越不可复用。<br>我的服务改造前经常会遇到提供给服务甲和服务乙因为一个参数不兼容，或者编排服务的顺序不能兼容，就得重新提供一个新的服务出来。<br><br>四层架构，应用层负责编排，领域层会慢慢沉淀，经过需求的变更让领域层的服务更丰富更专业。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474312,"discussion_content":"是的。\n微服务架构下要考虑新的设计方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573633893,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150891,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1573622423,"is_pvip":false,"replies":[{"id":"58026","content":"1、我这样设计的主要出发点就是为了聚合之间的解耦，避免以后微服务架构演进时，聚合之间耦合度过高而带来解耦的成本。而应用层是跨多聚合的，相对来说对聚合之间的协调就比较容易了。<br>2、放基础层其实也是没有问题的，但是要保证不同聚合之间的代码隔离和业务逻辑的解耦。将来如果以聚合为单位进行微服务之间代码的重组，实现微服务的架构演进，很容易实现代码和业务逻辑剥离。<br>设计的时候只要聚合之间逻辑是解耦的，代码是隔离的，并且按照分层原则把代码放在合适的层，把握好这个原则，可以按照自己熟悉的方式去做，不必受限于这个目录结构，能实现微服务架构的轻松演进就可以了。<br>","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573624016,"ip_address":"","comment_id":150891,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573622423","product_id":100037301,"comment_content":"回答问题：<br>1.传统三层和面向过程编程没有什么区别。而ddd的分层给予了领域模型行为，脱离了贫血模型的处境，更贴合面向对象设计的理念。<br>2.充血领域模型在代码复用上会比传统三层更简洁。力度更小，语义更强，依赖更清晰。<br><br>提问：<br>1.rpc调用的外部接口（相当于其他聚合了），也应该放在应用层对吗？但如果这样做，代码实现上个别场景就会变的复杂。我们需要将领域层中该聚合的所有外部依赖抽到应用层中来解决。这样设计上会增加复杂度，性能上也会有所影响，请问老师这又该如何去权衡？<br><br>2.我个人喜欢对基础层各聚合独有部分根据聚合做包拆分，与通用部分分离开，而非将基础层写到领域层里面，这样满足分层易理解易迁移的前提下，还坚守了ddd原有的分层概念，老师觉得这样操作如何？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474302,"discussion_content":"1、我这样设计的主要出发点就是为了聚合之间的解耦，避免以后微服务架构演进时，聚合之间耦合度过高而带来解耦的成本。而应用层是跨多聚合的，相对来说对聚合之间的协调就比较容易了。\n2、放基础层其实也是没有问题的，但是要保证不同聚合之间的代码隔离和业务逻辑的解耦。将来如果以聚合为单位进行微服务之间代码的重组，实现微服务的架构演进，很容易实现代码和业务逻辑剥离。\n设计的时候只要聚合之间逻辑是解耦的，代码是隔离的，并且按照分层原则把代码放在合适的层，把握好这个原则，可以按照自己熟悉的方式去做，不必受限于这个目录结构，能实现微服务架构的轻松演进就可以了。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573624016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150879,"user_name":"atom992","can_delete":false,"product_type":"c1","uid":1009507,"ip_address":"","ucode":"79492A3E5D36CA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/63/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1573620259,"is_pvip":false,"replies":[{"id":"58019","content":"后面有一节专门讲服务依赖和数据转换。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573622775,"ip_address":"","comment_id":150879,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573620259","product_id":100037301,"comment_content":"要是能再有一个调用依赖关系的图就好了。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474297,"discussion_content":"后面有一节专门讲服务依赖和数据转换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573622775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150840,"user_name":"lyw","can_delete":false,"product_type":"c1","uid":1346119,"ip_address":"","ucode":"5C4622FD945CD6","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/47/32163da8.jpg","comment_is_top":false,"comment_ctime":1573615599,"is_pvip":true,"replies":[{"id":"58021","content":"不好意思哈，没用过golang呢。能否参考帮忙设计一个呢？^_^。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573622847,"ip_address":"","comment_id":150840,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573615599","product_id":100037301,"comment_content":"java目录这样建，golang 的工程呢？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474285,"discussion_content":"不好意思哈，没用过golang呢。能否参考帮忙设计一个呢？^_^。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573622847,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150776,"user_name":"时间总漫不经心","can_delete":false,"product_type":"c1","uid":1017829,"ip_address":"","ucode":"1D184BB0D564E9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/e5/67495b10.jpg","comment_is_top":false,"comment_ctime":1573609486,"is_pvip":false,"replies":[{"id":"57983","content":"贫血模型是在实体类内部只有一些属性以及简单的get和set等方法，业务逻辑放在三层架构的业务逻辑处理部分。<br>充血模型是除了贫血模型的这些内容外，将实体相关的所有业务逻辑实现都在实体类的方法中实现。这样实体的属性和业务行为都与实体相关。可以更好的体现领域模型中实体的行为，也更有利于领域能力的下沉。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573611383,"ip_address":"","comment_id":150776,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573609486","product_id":100037301,"comment_content":"实体类是充血模型能具体讲讲吗","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474266,"discussion_content":"贫血模型是在实体类内部只有一些属性以及简单的get和set等方法，业务逻辑放在三层架构的业务逻辑处理部分。\n充血模型是除了贫血模型的这些内容外，将实体相关的所有业务逻辑实现都在实体类的方法中实现。这样实体的属性和业务行为都与实体相关。可以更好的体现领域模型中实体的行为，也更有利于领域能力的下沉。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573611383,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150754,"user_name":"mgxian","can_delete":false,"product_type":"c1","uid":1014806,"ip_address":"","ucode":"7B7E77E6A83B87","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7c/16/4d1e5cc1.jpg","comment_is_top":false,"comment_ctime":1573607128,"is_pvip":false,"replies":[{"id":"57966","content":"这个目录本身就是一个通用目录哈，项目不同可以根据自己的情况来裁剪。但要坚持好分层和边界的原则。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573609744,"ip_address":"","comment_id":150754,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573607128","product_id":100037301,"comment_content":"看到这个目录让我想起来了 架构整洁之道里说的 你的代码目录 要让别人一眼就哪看出来你的应用是做什么的？如果按照这个说法，老师介绍的目录就太通用了，看不出来是这个应用是干什么的，不管是电商，保险还是其他业务目录基本一样","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474261,"discussion_content":"这个目录本身就是一个通用目录哈，项目不同可以根据自己的情况来裁剪。但要坚持好分层和边界的原则。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573609744,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150751,"user_name":"Jade","can_delete":false,"product_type":"c1","uid":1085638,"ip_address":"","ucode":"E07CCF10497AD3","user_header":"https://wx.qlogo.cn/mmopen/vi_32/icRpVCFkicVnBiatPIZy4uiaoiba8ZODxclF00R6Tphsn55kdMtBYJtialcokIu3f4qJzx7QQR98ibVH4ndZ48E2o9vRQ/132","comment_is_top":false,"comment_ctime":1573606941,"is_pvip":false,"replies":[{"id":"57968","content":"下一节会讲。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573609774,"ip_address":"","comment_id":150751,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573606941","product_id":100037301,"comment_content":"有没有完整例子可以学习的？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474260,"discussion_content":"下一节会讲。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573609774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150742,"user_name":"渊虹","can_delete":false,"product_type":"c1","uid":1197459,"ip_address":"","ucode":"A041AD241B8E3F","user_header":"https://static001.geekbang.org/account/avatar/00/12/45/93/6ad60b12.jpg","comment_is_top":false,"comment_ctime":1573606314,"is_pvip":false,"replies":[{"id":"57969","content":"下一节会讲客户中台从领域模型到代码模型的实现案例。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573609827,"ip_address":"","comment_id":150742,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573606314","product_id":100037301,"comment_content":"老师，有没有相关代码。我们可以对照一起看，理解起来更深刻。谢谢","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474256,"discussion_content":"下一节会讲客户中台从领域模型到代码模型的实现案例。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573609827,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150737,"user_name":"William.加","can_delete":false,"product_type":"c1","uid":1211450,"ip_address":"","ucode":"300FFC09DEE243","user_header":"https://static001.geekbang.org/account/avatar/00/12/7c/3a/5140a8b9.jpg","comment_is_top":false,"comment_ctime":1573606059,"is_pvip":false,"replies":[{"id":"57970","content":"1、领域服务是在聚合内部呢。<br>2、应用服务是在应用层的service目录里面，它的业务实现是在领域层的实体方法和领域服务内。<br>","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573609920,"ip_address":"","comment_id":150737,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573606059","product_id":100037301,"comment_content":"老师，我有几个问题<br>1.DDD分层架构图中领域服务是不是应该画在聚合内呢？<br>2.应用层处理的也是领域层中的实体吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474254,"discussion_content":"1、领域服务是在聚合内部呢。\n2、应用服务是在应用层的service目录里面，它的业务实现是在领域层的实体方法和领域服务内。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573609920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150736,"user_name":"ANYI","can_delete":false,"product_type":"c1","uid":1084773,"ip_address":"","ucode":"B010B0FB10E0C5","user_header":"https://static001.geekbang.org/account/avatar/00/10/8d/65/633a7478.jpg","comment_is_top":false,"comment_ctime":1573605914,"is_pvip":false,"replies":[{"id":"57971","content":"因为微服务的代码和部署都是独立的，如果是公共包的话，需要在多个微服务基础层目录中引入这个包。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573610029,"ip_address":"","comment_id":150736,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573605914","product_id":100037301,"comment_content":"简单来说，感受就是做好代码分层；但对于多个微服务依赖的公共包（专门的一个公共工程）呢？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474253,"discussion_content":"因为微服务的代码和部署都是独立的，如果是公共包的话，需要在多个微服务基础层目录中引入这个包。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573610029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150701,"user_name":"六维","can_delete":false,"product_type":"c1","uid":1022887,"ip_address":"","ucode":"EB1C15AC06A8DF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/a7/440aff07.jpg","comment_is_top":false,"comment_ctime":1573603440,"is_pvip":false,"replies":[{"id":"57953","content":"开发的时候在同一个微服务下的不同目录中，运行在同一个微服务内。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573606697,"ip_address":"","comment_id":150701,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573603440","product_id":100037301,"comment_content":"如果是以java为例，各层是为不同的项目吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474248,"discussion_content":"开发的时候在同一个微服务下的不同目录中，运行在同一个微服务内。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573606697,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150695,"user_name":"密码123456","can_delete":false,"product_type":"c1","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1573603031,"is_pvip":false,"replies":[{"id":"57954","content":"1、可以用一些传统的设计方法，但还是尽量用DDD的分层方式来写。<br>2、他们是在同一个微服务内，分层的目的是为了清晰，仓储在领域层也是可以读到基础层的配置数据的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573606828,"ip_address":"","comment_id":150695,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573603031","product_id":100037301,"comment_content":"有这么几个问题<br>1，代码模型，分层后还使用mvc的方式吗？<br>2，仓储在领域层，不在基础层。怎么对应到基础层具体的数据源？<br>","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474246,"discussion_content":"1、可以用一些传统的设计方法，但还是尽量用DDD的分层方式来写。\n2、他们是在同一个微服务内，分层的目的是为了清晰，仓储在领域层也是可以读到基础层的配置数据的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573606828,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150694,"user_name":"阿玛铭","can_delete":false,"product_type":"c1","uid":1100703,"ip_address":"","ucode":"DBF948D82ACBE3","user_header":"https://static001.geekbang.org/account/avatar/00/10/cb/9f/ee68858c.jpg","comment_is_top":false,"comment_ctime":1573603026,"is_pvip":false,"replies":[{"id":"57955","content":"这个目录结构只是一个整体模型，可以根据具体项目来做一些细节的调整。边界和职责别错就行了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573606965,"ip_address":"","comment_id":150694,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1573603026","product_id":100037301,"comment_content":"最明显的区别是安层次分四个包。三层架构的目录结构除了mvc相关的包，一般会有common,config,utils等包。这些在四层架构中都可以放到infrastructure层。但是有一些框架（springboot,mybatis等）相关的配置可以根据实际情况可否放到application层，按聚合分目录？这个目录规范最重要的是作为知识库让每个接手系统的开发人员理解各个包的职责。其次如果有余力，可以做一些脚手架（如spring initializer）来辅助后续的规范的执行，理解目录职责即可，手动建目录这种活太low。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474245,"discussion_content":"这个目录结构只是一个整体模型，可以根据具体项目来做一些细节的调整。边界和职责别错就行了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573606965,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1720904,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/42/48/a9e7cdc2.jpg","nickname":"LOL","note":"","ucode":"991649DC6AA4C5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50307,"discussion_content":"init的前提是得理解如何分层和严格执行，不然只是省了几分钟时间而已","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573702431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150682,"user_name":"被秒","can_delete":false,"product_type":"c1","uid":1684432,"ip_address":"","ucode":"712BFB465D29A9","user_header":"https://static001.geekbang.org/account/avatar/00/19/b3/d0/ac3a1227.jpg","comment_is_top":false,"comment_ctime":1573601249,"is_pvip":true,"replies":[{"id":"57957","content":"如果按照DDD的领域建模的方法来做的话，一般不会出现在同一个微服务中，出现一个实体同时出现在多个聚合的情况。你说的这种情况，可能会在一个聚合中是聚合根或实体，而在另外一个聚合是值对象或者实体的情况。一般来说会在一个聚合维护实体的数据，而在另外的聚合只是引用这个实体的数据值。如果出现在不同的聚合内，我建议在不同的聚合定义同样实体或者值对象。这样设计的时候要注意的，创建和修改只能在一个聚合修改，其它只能引用，要不就违反了高内聚低耦合的原则。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573607595,"ip_address":"","comment_id":150682,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1573601249","product_id":100037301,"comment_content":"如果出现一个实体在多个聚合中的情况，是建议在2个聚合中重复定义还是将聚合合并成一个聚会呢？ 因为有时候一个超大的聚合，聚合根就不明确了","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474240,"discussion_content":"如果按照DDD的领域建模的方法来做的话，一般不会出现在同一个微服务中，出现一个实体同时出现在多个聚合的情况。你说的这种情况，可能会在一个聚合中是聚合根或实体，而在另外一个聚合是值对象或者实体的情况。一般来说会在一个聚合维护实体的数据，而在另外的聚合只是引用这个实体的数据值。如果出现在不同的聚合内，我建议在不同的聚合定义同样实体或者值对象。这样设计的时候要注意的，创建和修改只能在一个聚合修改，其它只能引用，要不就违反了高内聚低耦合的原则。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573607595,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1714824,"avatar":"","nickname":"Barret","note":"","ucode":"FF95094EC3604E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215726,"discussion_content":"欧创新老师，github上代码不全啊？src/main/java/ddd/leave/application/没有Event","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585375880,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}