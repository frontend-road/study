{"id":228968,"title":"22 | 接口设计：系统间对话的语言，一定要统一","content":"<p>你好，我是朱晔。今天，我要和你分享的主题是，在做接口设计时一定要确保系统之间对话的语言是统一的。</p><p>我们知道，开发一个服务的第一步就是设计接口。接口的设计需要考虑的点非常多，比如接口的命名、参数列表、包装结构体、接口粒度、版本策略、幂等性实现、同步异步处理方式等。</p><p>这其中，和接口设计相关比较重要的点有三个，分别是包装结构体、版本策略、同步异步处理方式。今天，我就通过我遇到的实际案例，和你一起看看因为接口设计思路和调用方理解不一致所导致的问题，以及相关的实践经验。</p><h2>接口的响应要明确表示接口的处理结果</h2><p>我曾遇到过一个处理收单的收单中心项目，下单接口返回的响应体中，包含了success、code、info、message等属性，以及二级嵌套对象data结构体。在对项目进行重构的时候，我们发现真的是无从入手，接口缺少文档，代码一有改动就出错。</p><p>有时候，下单操作的响应结果是这样的：success是true、message是OK，貌似代表下单成功了；但info里却提示订单存在风险，code是一个5001的错误码，data中能看到订单状态是Cancelled，订单ID是-1，好像又说明没有下单成功。</p><pre><code>{\n\t&quot;success&quot;: true,\n\t&quot;code&quot;: 5001,\n\t&quot;info&quot;: &quot;Risk order detected&quot;,\n\t&quot;message&quot;: &quot;OK&quot;,\n\t&quot;data&quot;: {\n\t\t&quot;orderStatus&quot;: &quot;Cancelled&quot;,\n\t\t&quot;orderId&quot;: -1\n\t}\n}\n</code></pre><!-- [[[read_end]]] --><p>有些时候，这个下单接口又会返回这样的结果：success是false，message提示非法用户ID，看上去下单失败；但data里的orderStatus是Created、info是空、code是0。那么，这次下单到底是成功还是失败呢？</p><pre><code>{\n\t&quot;success&quot;: false,\n\t&quot;code&quot;: 0,\n\t&quot;info&quot;: &quot;&quot;,\n\t&quot;message&quot;: &quot;Illegal userId&quot;,\n\t&quot;data&quot;: {\n\t\t&quot;orderStatus&quot;: &quot;Created&quot;,\n\t\t&quot;orderId&quot;: 0\n\t}\n}\n</code></pre><p>这样的结果，让我们非常疑惑：</p><ul>\n<li>结构体的code和HTTP响应状态码，是什么关系？</li>\n<li>success到底代表下单成功还是失败？</li>\n<li>info和message的区别是什么？</li>\n<li>data中永远都有数据吗？什么时候应该去查询data？</li>\n</ul><p>造成如此混乱的原因是：这个收单服务本身并不真正处理下单操作，只是做一些预校验和预处理；真正的下单操作，需要在收单服务内部调用另一个订单服务来处理；订单服务处理完成后，会返回订单状态和ID。</p><p>在一切正常的情况下，下单后的订单状态就是已创建Created，订单ID是一个大于0的数字。而结构体中的message和success，其实是收单服务的处理异常信息和处理成功与否的结果，code、info是调用订单服务的结果。</p><p>对于第一次调用，收单服务自己没问题，success是true，message是OK，但调用订单服务时却因为订单风险问题被拒绝，所以code是5001，info是Risk order detected，data中的信息是订单服务返回的，所以最终订单状态是Cancelled。</p><p>对于第二次调用，因为用户ID非法，所以收单服务在校验了参数后直接就返回了success是false，message是Illegal userId。因为请求没有到订单服务，所以info、code、data都是默认值，订单状态的默认值是Created。因此，第二次下单肯定失败了，但订单状态却是已创建。</p><p>可以看到，如此混乱的接口定义和实现方式，是无法让调用者分清到底应该怎么处理的。<strong>为了将接口设计得更合理，我们需要考虑如下两个原则：</strong></p><ul>\n<li>对外隐藏内部实现。虽然说收单服务调用订单服务进行真正的下单操作，但是直接接口其实是收单服务提供的，收单服务不应该“直接”暴露其背后订单服务的状态码、错误描述。</li>\n<li>设计接口结构时，明确每个字段的含义，以及客户端的处理方式。</li>\n</ul><p>基于这两个原则，我们调整一下返回结构体，去掉外层的info，即不再把订单服务的调用结果告知客户端：</p><pre><code>@Data\npublic class APIResponse&lt;T&gt; {\n    private boolean success;\n    private T data;\n    private int code;\n    private String message;\n}\n</code></pre><p>并明确接口的设计逻辑：</p><ul>\n<li>如果出现非200的HTTP响应状态码，就代表请求没有到收单服务，可能是网络出问题、网络超时，或者网络配置的问题。这时，肯定无法拿到服务端的响应体，客户端可以给予友好提示，比如让用户重试，不需要继续解析响应结构体。</li>\n<li>如果HTTP响应码是200，解析响应体查看success，为false代表下单请求处理失败，可能是因为收单服务参数验证错误，也可能是因为订单服务下单操作失败。这时，根据收单服务定义的错误码表和code，做不同处理。比如友好提示，或是让用户重新填写相关信息，其中友好提示的文字内容可以从message中获取。</li>\n<li>success为true的情况下，才需要继续解析响应体中的data结构体。data结构体代表了业务数据，通常会有下面两种情况。\n<ul>\n<li>通常情况下，success为true时订单状态是Created，获取orderId属性可以拿到订单号。</li>\n<li>特殊情况下，比如收单服务内部处理不当，或是订单服务出现了额外的状态，虽然success为true，但订单实际状态不是Created，这时可以给予友好的错误提示。</li>\n</ul>\n</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/cd/ed/cd799f2bdb407bcb9ff5ad452376a6ed.jpg?wh=3400*2577\" alt=\"\"></p><p>明确了接口的设计逻辑，我们就是可以实现收单服务的服务端和客户端来模拟这些情况了。</p><p>首先，实现服务端的逻辑：</p><pre><code>@GetMapping(&quot;server&quot;)\npublic APIResponse&lt;OrderInfo&gt; server(@RequestParam(&quot;userId&quot;) Long userId) {\n    APIResponse&lt;OrderInfo&gt; response = new APIResponse&lt;&gt;();\n    if (userId == null) {\n        //对于userId为空的情况，收单服务直接处理失败，给予相应的错误码和错误提示\n        response.setSuccess(false);\n        response.setCode(3001);\n        response.setMessage(&quot;Illegal userId&quot;);\n    } else if (userId == 1) {\n        //对于userId=1的用户，模拟订单服务对于风险用户的情况\n        response.setSuccess(false);\n        //把订单服务返回的错误码转换为收单服务错误码\n        response.setCode(3002);\n        response.setMessage(&quot;Internal Error, order is cancelled&quot;);\n        //同时日志记录内部错误\n        log.warn(&quot;用户 {} 调用订单服务失败，原因是 Risk order detected&quot;, userId);\n    } else {\n        //其他用户，下单成功\n        response.setSuccess(true);\n        response.setCode(2000);\n        response.setMessage(&quot;OK&quot;);\n        response.setData(new OrderInfo(&quot;Created&quot;, 2L));\n    }\n    return response;\n}\n</code></pre><p>客户端代码，则可以按照流程图上的逻辑来实现，同样模拟三种出错情况和正常下单的情况：</p><ul>\n<li>error==1的用例模拟一个不存在的URL，请求无法到收单服务，会得到404的HTTP状态码，直接进行友好提示，这是第一层处理。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/c1/36/c1ddea0ebf6d86956d68efb0424a6b36.png?wh=1032*232\" alt=\"\"></p><ul>\n<li>error==2的用例模拟userId参数为空的情况，收单服务会因为缺少userId参数提示非法用户。这时，可以把响应体中的message展示给用户，这是第二层处理。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/f3/47/f36d21beb95ce0e7ea96dfde96f21847.png?wh=1348*208\" alt=\"\"></p><ul>\n<li>error==3的用例模拟userId为1的情况，因为用户有风险，收单服务调用订单服务出错。处理方式和之前没有任何区别，因为收单服务会屏蔽订单服务的内部错误。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/41/2c/412c64e66a574d8252ac8dd59b4cfe2c.png?wh=1716*208\" alt=\"\"></p><p>但在服务端可以看到如下错误信息：</p><pre><code>[14:13:13.951] [http-nio-45678-exec-8] [WARN ] [.c.a.d.APIThreeLevelStatusController:36  ] - 用户 1 调用订单服务失败，原因是 Risk order detected\n</code></pre><ul>\n<li>error==0的用例模拟正常用户，下单成功。这时可以解析data结构体提取业务结果，作为兜底，需要判断订单状态，如果不是Created则给予友好提示，否则查询orderId获得下单的订单号，这是第三层处理。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/f5/48/f57ae156de7592de167bd09aaadb8348.png?wh=1234*222\" alt=\"\"></p><p>客户端的实现代码如下：</p><pre><code>@GetMapping(&quot;client&quot;)\npublic String client(@RequestParam(value = &quot;error&quot;, defaultValue = &quot;0&quot;) int error) {\n   String url = Arrays.asList(&quot;http://localhost:45678/apiresposne/server?userId=2&quot;,\n        &quot;http://localhost:45678/apiresposne/server2&quot;,\n        &quot;http://localhost:45678/apiresposne/server?userId=&quot;,\n        &quot;http://localhost:45678/apiresposne/server?userId=1&quot;).get(error);\n\n    //第一层，先看状态码，如果状态码不是200，不处理响应体\n    String response = &quot;&quot;;\n    try {\n        response = Request.Get(url).execute().returnContent().asString();\n    } catch (HttpResponseException e) {\n        log.warn(&quot;请求服务端出现返回非200&quot;, e);\n        return &quot;服务器忙，请稍后再试！&quot;;\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n\n    //状态码为200的情况下处理响应体\n    if (!response.equals(&quot;&quot;)) {\n        try {\n            APIResponse&lt;OrderInfo&gt; apiResponse = objectMapper.readValue(response, new TypeReference&lt;APIResponse&lt;OrderInfo&gt;&gt;() {\n            });\n            //第二层，success是false直接提示用户\n            if (!apiResponse.isSuccess()) {\n                return String.format(&quot;创建订单失败，请稍后再试，错误代码： %s 错误原因：%s&quot;, apiResponse.getCode(), apiResponse.getMessage());\n            } else {\n                //第三层，往下解析OrderInfo\n                OrderInfo orderInfo = apiResponse.getData();\n                if (&quot;Created&quot;.equals(orderInfo.getStatus()))\n                    return String.format(&quot;创建订单成功，订单号是：%s，状态是：%s&quot;, orderInfo.getOrderId(), orderInfo.getStatus());\n                else\n                    return String.format(&quot;创建订单失败，请联系客服处理&quot;);\n            }\n        } catch (JsonProcessingException e) {\n            e.printStackTrace();\n        }\n    }\n    return &quot;&quot;;\n}\n</code></pre><p><strong>相比原来混乱的接口定义和处理逻辑，改造后的代码，明确了接口每一个字段的含义，以及对于各种情况服务端的输出和客户端的处理步骤，对齐了客户端和服务端的处理逻辑</strong>。那么现在，你能回答前面那4个让人疑惑的问题了吗？</p><p>最后分享一个小技巧。为了简化服务端代码，我们可以把包装API响应体APIResponse的工作交由框架自动完成，这样直接返回DTO OrderInfo即可。对于业务逻辑错误，可以抛出一个自定义异常：</p><pre><code>@GetMapping(&quot;server&quot;)\npublic OrderInfo server(@RequestParam(&quot;userId&quot;) Long userId) {\n    if (userId == null) {\n        throw new APIException(3001, &quot;Illegal userId&quot;);\n    }\n\n    if (userId == 1) {\n        ...\n        //直接抛出异常\n        throw new APIException(3002, &quot;Internal Error, order is cancelled&quot;);\n    }\n    //直接返回DTO\n    return new OrderInfo(&quot;Created&quot;, 2L);\n}\n</code></pre><p>在APIException中包含错误码和错误消息：</p><pre><code>public class APIException extends RuntimeException {\n    @Getter\n    private int errorCode;\n    @Getter\n    private String errorMessage;\n\n    public APIException(int errorCode, String errorMessage) {\n        super(errorMessage);\n        this.errorCode = errorCode;\n        this.errorMessage = errorMessage;\n    }\n\n    public APIException(Throwable cause, int errorCode, String errorMessage) {\n        super(errorMessage, cause);\n        this.errorCode = errorCode;\n        this.errorMessage = errorMessage;\n    }\n}\n</code></pre><p>然后，定义一个@RestControllerAdvice来完成自动包装响应体的工作：</p><ol>\n<li>通过实现ResponseBodyAdvice接口的beforeBodyWrite方法，来处理成功请求的响应体转换。</li>\n<li>实现一个@ExceptionHandler来处理业务异常时，APIException到APIResponse的转换。</li>\n</ol><pre><code>//此段代码只是Demo，生产级应用还需要扩展很多细节\n@RestControllerAdvice\n@Slf4j\npublic class APIResponseAdvice implements ResponseBodyAdvice&lt;Object&gt; {\n\n    //自动处理APIException，包装为APIResponse\n    @ExceptionHandler(APIException.class)\n    public APIResponse handleApiException(HttpServletRequest request, APIException ex) {\n        log.error(&quot;process url {} failed&quot;, request.getRequestURL().toString(), ex);\n        APIResponse apiResponse = new APIResponse();\n        apiResponse.setSuccess(false);\n        apiResponse.setCode(ex.getErrorCode());\n        apiResponse.setMessage(ex.getErrorMessage());\n        return apiResponse;\n    }\n\n    //仅当方法或类没有标记@NoAPIResponse才自动包装\n    @Override\n    public boolean supports(MethodParameter returnType, Class converterType) {\n        return returnType.getParameterType() != APIResponse.class\n                &amp;&amp; AnnotationUtils.findAnnotation(returnType.getMethod(), NoAPIResponse.class) == null\n                &amp;&amp; AnnotationUtils.findAnnotation(returnType.getDeclaringClass(), NoAPIResponse.class) == null;\n    }\n\n    //自动包装外层APIResposne响应\n    @Override\n    public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) {\n        APIResponse apiResponse = new APIResponse();\n        apiResponse.setSuccess(true);\n        apiResponse.setMessage(&quot;OK&quot;);\n        apiResponse.setCode(2000);\n        apiResponse.setData(body);\n        return apiResponse;\n    }\n}\n</code></pre><p>在这里，我们实现了一个@NoAPIResponse自定义注解。如果某些@RestController的接口不希望实现自动包装的话，可以标记这个注解：</p><pre><code>@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface NoAPIResponse {\n}\n</code></pre><p>在ResponseBodyAdvice的support方法中，我们排除了标记有这个注解的方法或类的自动响应体包装。比如，对于刚才我们实现的测试客户端client方法不需要包装为APIResponse，就可以标记上这个注解：</p><pre><code>@GetMapping(&quot;client&quot;)\n@NoAPIResponse\npublic String client(@RequestParam(value = &quot;error&quot;, defaultValue = &quot;0&quot;) int error)\n</code></pre><p>这样我们的业务逻辑中就不需要考虑响应体的包装，代码会更简洁。</p><h2>要考虑接口变迁的版本控制策略</h2><p>接口不可能一成不变，需要根据业务需求不断增加内部逻辑。如果做大的功能调整或重构，涉及参数定义的变化或是参数废弃，导致接口无法向前兼容，这时接口就需要有版本的概念。在考虑接口版本策略设计时，我们需要注意的是，最好一开始就明确版本策略，并考虑在整个服务端统一版本策略。</p><p><strong>第一，版本策略最好一开始就考虑。</strong></p><p>既然接口总是要变迁的，那么最好一开始就确定版本策略。比如，确定是通过URL Path实现，是通过QueryString实现，还是通过HTTP头实现。这三种实现方式的代码如下：</p><pre><code>//通过URL Path实现版本控制\n@GetMapping(&quot;/v1/api/user&quot;)\npublic int right1(){\n    return 1;\n}\n//通过QueryString中的version参数实现版本控制\n@GetMapping(value = &quot;/api/user&quot;, params = &quot;version=2&quot;)\npublic int right2(@RequestParam(&quot;version&quot;) int version) {\n    return 2;\n}\n//通过请求头中的X-API-VERSION参数实现版本控制\n@GetMapping(value = &quot;/api/user&quot;, headers = &quot;X-API-VERSION=3&quot;)\npublic int right3(@RequestHeader(&quot;X-API-VERSION&quot;) int version) {\n    return 3;\n}\n</code></pre><p>这样，客户端就可以在配置中处理相关版本控制的参数，有可能实现版本的动态切换。</p><p>这三种方式中，URL Path的方式最直观也最不容易出错；QueryString不易携带，不太推荐作为公开API的版本策略；HTTP头的方式比较没有侵入性，如果仅仅是部分接口需要进行版本控制，可以考虑这种方式。</p><p><strong>第二，版本实现方式要统一。</strong></p><p>之前，我就遇到过一个O2O项目，需要针对商品、商店和用户实现REST接口。虽然大家约定通过URL Path方式实现API版本控制，但实现方式不统一，有的是/api/item/v1，有的是/api/v1/shop，还有的是/v1/api/merchant：</p><pre><code>@GetMapping(&quot;/api/item/v1&quot;)\npublic void wrong1(){\n}\n\n\n@GetMapping(&quot;/api/v1/shop&quot;)\npublic void wrong2(){\n}\n\n\n@GetMapping(&quot;/v1/api/merchant&quot;)\npublic void wrong3(){\n}\n</code></pre><p>显然，商品、商店和商户的接口开发同学，没有按照一致的URL格式来实现接口的版本控制。更要命的是，我们可能开发出两个URL类似接口，比如一个是/api/v1/user，另一个是/api/user/v1，这到底是一个接口还是两个接口呢？</p><p>相比于在每一个接口的URL Path中设置版本号，更理想的方式是在框架层面实现统一。如果你使用Spring框架的话，可以按照下面的方式自定义RequestMappingHandlerMapping来实现。</p><p>首先，创建一个注解来定义接口的版本。@APIVersion自定义注解可以应用于方法或Controller上：</p><pre><code>@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface APIVersion {\n    String[] value();\n}\n</code></pre><p>然后，定义一个APIVersionHandlerMapping类继承RequestMappingHandlerMapping。</p><p>RequestMappingHandlerMapping的作用，是根据类或方法上的@RequestMapping来生成RequestMappingInfo的实例。我们覆盖registerHandlerMethod方法的实现，从@APIVersion自定义注解中读取版本信息，拼接上原有的、不带版本号的URL Pattern，构成新的RequestMappingInfo，来通过注解的方式为接口增加基于URL的版本号：</p><pre><code>public class APIVersionHandlerMapping extends RequestMappingHandlerMapping {\n    @Override\n    protected boolean isHandler(Class&lt;?&gt; beanType) {\n        return AnnotatedElementUtils.hasAnnotation(beanType, Controller.class);\n    }\n\n\n    @Override\n    protected void registerHandlerMethod(Object handler, Method method, RequestMappingInfo mapping) {\n        Class&lt;?&gt; controllerClass = method.getDeclaringClass();\n        //类上的APIVersion注解\n        APIVersion apiVersion = AnnotationUtils.findAnnotation(controllerClass, APIVersion.class);\n        //方法上的APIVersion注解\n        APIVersion methodAnnotation = AnnotationUtils.findAnnotation(method, APIVersion.class);\n        //以方法上的注解优先\n        if (methodAnnotation != null) {\n            apiVersion = methodAnnotation;\n        }\n\n        String[] urlPatterns = apiVersion == null ? new String[0] : apiVersion.value();\n       \n        PatternsRequestCondition apiPattern = new PatternsRequestCondition(urlPatterns);\n        PatternsRequestCondition oldPattern = mapping.getPatternsCondition();\n        PatternsRequestCondition updatedFinalPattern = apiPattern.combine(oldPattern);\n        //重新构建RequestMappingInfo\n        mapping = new RequestMappingInfo(mapping.getName(), updatedFinalPattern, mapping.getMethodsCondition(),\n                mapping.getParamsCondition(), mapping.getHeadersCondition(), mapping.getConsumesCondition(),\n                mapping.getProducesCondition(), mapping.getCustomCondition());\n        super.registerHandlerMethod(handler, method, mapping);\n    }\n}\n</code></pre><p>最后，也是特别容易忽略的一点，要通过实现WebMvcRegistrations接口，来生效自定义的APIVersionHandlerMapping：</p><pre><code>@SpringBootApplication\npublic class CommonMistakesApplication implements WebMvcRegistrations {\n...\n    @Override\n    public RequestMappingHandlerMapping getRequestMappingHandlerMapping() {\n        return new APIVersionHandlerMapping();\n    }\n}\n</code></pre><p>这样，就实现了在Controller上或接口方法上通过注解，来实现以统一的Pattern进行版本号控制：</p><pre><code>@GetMapping(value = &quot;/api/user&quot;)\n@APIVersion(&quot;v4&quot;)\npublic int right4() {\n    return 4;\n}\n</code></pre><p>加上注解后，访问浏览器查看效果：</p><p><img src=\"https://static001.geekbang.org/resource/image/f8/02/f8fae105eae532e93e329ae2d3253502.png?wh=952*184\" alt=\"\"></p><p>使用框架来明确API版本的指定策略，不仅实现了标准化，更实现了强制的API版本控制。对上面代码略做修改，我们就可以实现不设置@APIVersion接口就给予报错提示。</p><h2>接口处理方式要明确同步还是异步</h2><p>看到这个标题，你可能感觉不太好理解，我们直接看一个实际案例吧。</p><p>有一个文件上传服务FileService，其中一个upload文件上传接口特别慢，原因是这个上传接口在内部需要进行两步操作，首先上传原图，然后压缩后上传缩略图。如果每一步都耗时5秒的话，那么这个接口返回至少需要10秒的时间。</p><p>于是，开发同学把接口改为了异步处理，每一步操作都限定了超时时间，也就是分别把上传原文件和上传缩略图的操作提交到线程池，然后等待一定的时间：</p><pre><code>private ExecutorService threadPool = Executors.newFixedThreadPool(2);\n\n//我没有贴出两个文件上传方法uploadFile和uploadThumbnailFile的实现，它们在内部只是随机进行休眠然后返回文件名，对于本例来说不是很重要\n\npublic UploadResponse upload(UploadRequest request) {\n    UploadResponse response = new UploadResponse();\n    //上传原始文件任务提交到线程池处理\n    Future&lt;String&gt; uploadFile = threadPool.submit(() -&gt; uploadFile(request.getFile()));\n    //上传缩略图任务提交到线程池处理\n    Future&lt;String&gt; uploadThumbnailFile = threadPool.submit(() -&gt; uploadThumbnailFile(request.getFile()));\n    //等待上传原始文件任务完成，最多等待1秒\n    try {\n        response.setDownloadUrl(uploadFile.get(1, TimeUnit.SECONDS));\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    //等待上传缩略图任务完成，最多等待1秒\n    try {\n        response.setThumbnailDownloadUrl(uploadThumbnailFile.get(1, TimeUnit.SECONDS));\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return response;\n}\n</code></pre><p>上传接口的请求和响应比较简单，传入二进制文件，传出原文件和缩略图下载地址：</p><pre><code>@Data\npublic class UploadRequest {\n    private byte[] file;\n}\n\n@Data\npublic class UploadResponse {\n    private String downloadUrl;\n    private String thumbnailDownloadUrl;\n}\n</code></pre><p>到这里，你能看出这种实现方式的问题是什么吗？</p><p>从接口命名上看虽然是同步上传操作，但其内部通过线程池进行异步上传，并因为设置了较短超时所以接口整体响应挺快。但是，<strong>一旦遇到超时，接口就不能返回完整的数据，不是无法拿到原文件下载地址，就是无法拿到缩略图下载地址，接口的行为变得不可预测</strong>：</p><p><img src=\"https://static001.geekbang.org/resource/image/8e/78/8e75863413fd7a01514b47804f0c4a78.png?wh=1962*330\" alt=\"\"></p><p>所以，这种优化接口响应速度的方式并不可取，<strong>更合理的方式是，让上传接口要么是彻底的同步处理，要么是彻底的异步处理</strong>：</p><ul>\n<li>所谓同步处理，接口一定是同步上传原文件和缩略图的，调用方可以自己选择调用超时，如果来得及可以一直等到上传完成，如果等不及可以结束等待，下一次再重试；</li>\n<li>所谓异步处理，接口是两段式的，上传接口本身只是返回一个任务ID，然后异步做上传操作，上传接口响应很快，客户端需要之后再拿着任务ID调用任务查询接口查询上传的文件URL。</li>\n</ul><p>同步上传接口的实现代码如下，把超时的选择留给客户端：</p><pre><code>public SyncUploadResponse syncUpload(SyncUploadRequest request) {\n    SyncUploadResponse response = new SyncUploadResponse();\n    response.setDownloadUrl(uploadFile(request.getFile()));\n    response.setThumbnailDownloadUrl(uploadThumbnailFile(request.getFile()));\n    return response;\n}\n</code></pre><p>这里的SyncUploadRequest和SyncUploadResponse类，与之前定义的UploadRequest和UploadResponse是一致的。对于接口的入参和出参DTO的命名，我比较建议的方式是，使用接口名+Request和Response后缀。</p><p>接下来，我们看看异步的上传文件接口如何实现。异步上传接口在出参上有点区别，不再返回文件URL，而是返回一个任务ID：</p><pre><code>@Data\npublic class AsyncUploadRequest {\n    private byte[] file;\n}\n\n@Data\npublic class AsyncUploadResponse {\n    private String taskId;\n}\n</code></pre><p>在接口实现上，我们同样把上传任务提交到线程池处理，但是并不会同步等待任务完成，而是完成后把结果写入一个HashMap，任务查询接口通过查询这个HashMap来获得文件的URL：</p><pre><code>//计数器，作为上传任务的ID\nprivate AtomicInteger atomicInteger = new AtomicInteger(0);\n//暂存上传操作的结果，生产代码需要考虑数据持久化\nprivate ConcurrentHashMap&lt;String, SyncQueryUploadTaskResponse&gt; downloadUrl = new ConcurrentHashMap&lt;&gt;();\n//异步上传操作\npublic AsyncUploadResponse asyncUpload(AsyncUploadRequest request) {\n    AsyncUploadResponse response = new AsyncUploadResponse();\n    //生成唯一的上传任务ID\n    String taskId = &quot;upload&quot; + atomicInteger.incrementAndGet();\n    //异步上传操作只返回任务ID\n    response.setTaskId(taskId);\n    //提交上传原始文件操作到线程池异步处理\n    threadPool.execute(() -&gt; {\n        String url = uploadFile(request.getFile());\n        //如果ConcurrentHashMap不包含Key，则初始化一个SyncQueryUploadTaskResponse，然后设置DownloadUrl\n        downloadUrl.computeIfAbsent(taskId, id -&gt; new SyncQueryUploadTaskResponse(id)).setDownloadUrl(url);\n    });\n    //提交上传缩略图操作到线程池异步处理\n    threadPool.execute(() -&gt; {\n        String url = uploadThumbnailFile(request.getFile());\n        downloadUrl.computeIfAbsent(taskId, id -&gt; new SyncQueryUploadTaskResponse(id)).setThumbnailDownloadUrl(url);\n    });\n    return response;\n}\n</code></pre><p>文件上传查询接口则以任务ID作为入参，返回两个文件的下载地址，因为文件上传查询接口是同步的，所以直接命名为syncQueryUploadTask：</p><pre><code>//syncQueryUploadTask接口入参\n@Data\n@RequiredArgsConstructor\npublic class SyncQueryUploadTaskRequest {\n    private final String taskId;//使用上传文件任务ID查询上传结果 \n}\n//syncQueryUploadTask接口出参\n@Data\n@RequiredArgsConstructor\npublic class SyncQueryUploadTaskResponse {\n    private final String taskId; //任务ID\n    private String downloadUrl; //原始文件下载URL\n    private String thumbnailDownloadUrl; //缩略图下载URL\n}\n\npublic SyncQueryUploadTaskResponse syncQueryUploadTask(SyncQueryUploadTaskRequest request) {\n    SyncQueryUploadTaskResponse response = new SyncQueryUploadTaskResponse(request.getTaskId());\n     //从之前定义的downloadUrl ConcurrentHashMap查询结果\nresponse.setDownloadUrl(downloadUrl.getOrDefault(request.getTaskId(), response).getDownloadUrl());\n    response.setThumbnailDownloadUrl(downloadUrl.getOrDefault(request.getTaskId(), response).getThumbnailDownloadUrl());\n    return response;\n}\n</code></pre><p>经过改造的FileService不再提供一个看起来是同步上传，内部却是异步上传的upload方法，改为提供很明确的：</p><ul>\n<li>同步上传接口syncUpload；</li>\n<li>异步上传接口asyncUpload，搭配syncQueryUploadTask查询上传结果。</li>\n</ul><p>使用方可以根据业务性质选择合适的方法：如果是后端批处理使用，那么可以使用同步上传，多等待一些时间问题不大；如果是面向用户的接口，那么接口响应时间不宜过长，可以调用异步上传接口，然后定时轮询上传结果，拿到结果再显示。</p><h2>重点回顾</h2><p>今天，我针对接口设计，和你深入探讨了三个方面的问题。</p><p>第一，针对响应体的设计混乱、响应结果的不明确问题，服务端需要明确响应体每一个字段的意义，以一致的方式进行处理，并确保不透传下游服务的错误。</p><p>第二，针对接口版本控制问题，主要就是在开发接口之前明确版本控制策略，以及尽量使用统一的版本控制策略两方面。</p><p>第三，针对接口的处理方式，我认为需要明确要么是同步要么是异步。如果API列表中既有同步接口也有异步接口，那么最好直接在接口名中明确。</p><p>一个良好的接口文档不仅仅需要说明如何调用接口，更需要补充接口使用的最佳实践以及接口的SLA标准。我看到的大部分接口文档只给出了参数定义，但诸如幂等性、同步异步、缓存策略等看似内部实现相关的一些设计，其实也会影响调用方对接口的使用策略，最好也可以体现在接口文档中。</p><p>最后，我再额外提一下，对于服务端出错的时候是否返回200响应码的问题，其实一直有争论。从RESTful设计原则来看，我们应该尽量利用HTTP状态码来表达错误，但也不是这么绝对。</p><p>如果我们认为HTTP 状态码是协议层面的履约，那么当这个错误已经不涉及HTTP协议时（换句话说，服务端已经收到请求进入服务端业务处理后产生的错误），不一定需要硬套协议本身的错误码。但涉及非法URL、非法参数、没有权限等无法处理请求的情况，还是应该使用正确的响应码来应对。</p><p>今天用到的代码，我都放在了GitHub上，你可以点击<a href=\"https://github.com/JosephZhu1983/java-common-mistakes\">这个链接</a>查看。</p><h2>思考与讨论</h2><ol>\n<li>在第一节的例子中，接口响应结构体中的code字段代表执行结果的错误码，对于业务特别复杂的接口，可能会有很多错误情况，code可能会有几十甚至几百个。客户端开发人员需要根据每一种错误情况逐一写if-else进行不同交互处理，会非常麻烦，你觉得有什么办法来改进吗？作为服务端，是否有必要告知客户端接口执行的错误码呢？</li>\n<li>在第二节的例子中，我们在类或方法上标记@APIVersion自定义注解，实现了URL方式统一的接口版本定义。你可以用类似的方式（也就是自定义RequestMappingHandlerMapping），来实现一套统一的基于请求头方式的版本控制吗？</li>\n</ol><p>关于接口设计，你还遇到过其他问题吗？我是朱晔，欢迎在评论区与我留言分享你的想法，也欢迎你把今天的内容分享给你的朋友或同事，一起交流。</p>","neighbors":{"left":{"article_title":"21 |  代码重复：搞定代码重复的三个绝招","id":228964},"right":{"article_title":"23 | 缓存设计：缓存可以锦上添花也可以落井下石","id":231501}},"comments":[{"had_liked":false,"id":216295,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1589222402,"is_pvip":false,"replies":[{"id":"80039","content":"服务端需要做错误码归类收敛，特别是应该转换下游服务多少异常，否则客户端会不知所措。我们之前尝试过服务端驱动的方式，让服务端告知客户端如何处理，说白了客户端只需要照做即可，不需要感知错误码的含义，即便客户端显示错误码也只是用于排错，下面是相关介绍：<br><br>说白了这种模式，就是在API的返回结果中包含驱动客户端去怎么做的信息，两个层次：<br><br>1、交互驱动：比如包含actionType和actionInfo，actionType可以是toast、alert、redirectView、redirectWebView等，actionInfo就是toast的信息、alert的信息、redirect的URL等。由服务端来明确客户端在请求API后的交互行为的好处是：<br>灵活：在紧急的时候还可以通过redirect方式进行救急，比如遇到特殊情况需要紧急进行逻辑修改可以直接在不发版的情况下切换到H5实现，甚至我们可以提供后台让产品或运营来配置交互的方式和信息<br>统一：有的时候会遇到不同的客户端，iOS、Android、前端对于交互的实现不统一的情况，如果API结果可以规定这部分内容可以彻底避免这个问题<br>2、行为驱动：更深一层的服务端驱动，可以实现一套API作为入口，让客户端进行调用，然后通过约定一套DSL告知客户端应该呈现什么，干什么。<br>之前有两个这样的项目采用了类似的API设计方式：<br><br>贷款审核：我们知道贷款的信用审核逻辑往往会变动比较大，还涉及到客户端的一些授权（比如运营商爬虫），而且App的发布更新往往比较困难（苹果App Store以及安卓各大应用商店的审核问题）。如果采用服务端驱动的架构来告知客户端接下去应该呈现什么界面做什么，那么会有很大的灵活性。<br>客户端爬虫：我们知道如果采用服务端做爬虫很多时候因为IP的问题会被封，所以需要找很多代理。某项目我们想出了客户端共享代理的概念，使用手机客户端来做分布式代理，由服务端驱动调度所有的客户端，那么这个时候客户端需要听从服务端的指示来做请求然后上报响应。<br>一般而言，对外的Web API是不会采用这种服务端驱动客户端的方式来设计API的。对于某些特殊类型的项目，我们可以考虑采用这种服务端驱动的方式来设计API，让客户端变为一个不含逻辑的执行者，执行的是UI和交互。","user_name":"作者回复","comment_id":216295,"uid":"1001470","ip_address":"","utype":1,"ctime":1589241725,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"78898633730","product_id":100047701,"comment_content":"第一个问题我的解决是控制为更少的错误代码<br>调用数据库是一种，调用服务失败是一种，业务层错误是一种<br>返回到客户端的时候，客户端之判断错误类型是哪一类，从而做相应的处理。并不告知客户端详细的错误内容。详细的错误内容应该由后端工程师来把控。","like_count":19,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494757,"discussion_content":"服务端需要做错误码归类收敛，特别是应该转换下游服务多少异常，否则客户端会不知所措。我们之前尝试过服务端驱动的方式，让服务端告知客户端如何处理，说白了客户端只需要照做即可，不需要感知错误码的含义，即便客户端显示错误码也只是用于排错，下面是相关介绍：\n\n说白了这种模式，就是在API的返回结果中包含驱动客户端去怎么做的信息，两个层次：\n\n1、交互驱动：比如包含actionType和actionInfo，actionType可以是toast、alert、redirectView、redirectWebView等，actionInfo就是toast的信息、alert的信息、redirect的URL等。由服务端来明确客户端在请求API后的交互行为的好处是：\n灵活：在紧急的时候还可以通过redirect方式进行救急，比如遇到特殊情况需要紧急进行逻辑修改可以直接在不发版的情况下切换到H5实现，甚至我们可以提供后台让产品或运营来配置交互的方式和信息\n统一：有的时候会遇到不同的客户端，iOS、Android、前端对于交互的实现不统一的情况，如果API结果可以规定这部分内容可以彻底避免这个问题\n2、行为驱动：更深一层的服务端驱动，可以实现一套API作为入口，让客户端进行调用，然后通过约定一套DSL告知客户端应该呈现什么，干什么。\n之前有两个这样的项目采用了类似的API设计方式：\n\n贷款审核：我们知道贷款的信用审核逻辑往往会变动比较大，还涉及到客户端的一些授权（比如运营商爬虫），而且App的发布更新往往比较困难（苹果App Store以及安卓各大应用商店的审核问题）。如果采用服务端驱动的架构来告知客户端接下去应该呈现什么界面做什么，那么会有很大的灵活性。\n客户端爬虫：我们知道如果采用服务端做爬虫很多时候因为IP的问题会被封，所以需要找很多代理。某项目我们想出了客户端共享代理的概念，使用手机客户端来做分布式代理，由服务端驱动调度所有的客户端，那么这个时候客户端需要听从服务端的指示来做请求然后上报响应。\n一般而言，对外的Web API是不会采用这种服务端驱动客户端的方式来设计API的。对于某些特殊类型的项目，我们可以考虑采用这种服务端驱动的方式来设计API，让客户端变为一个不含逻辑的执行者，执行的是UI和交互。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589241725,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214306,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1588717044,"is_pvip":false,"replies":[{"id":"79338","content":"1. 可以开发一个独立的错误码服务，实现转码、分类、收敛逻辑，甚至可以开发后台，让产品来录入需要的错误码提示消息。阿里的Java开发手册中也有提到相关错误码的一些推荐的最佳实践。<br>2. 这确实是一个问题，所以框架如果做的好的话不仅仅要扩展功能部分还要打通文档，比如如果使用springdoc来什生成OpenAPI文档，那么直接把那部分生成URL的逻辑也改了","user_name":"作者回复","comment_id":214306,"uid":"1001470","ip_address":"","utype":1,"ctime":1588724482,"user_name_real":"朱晔"}],"discussion_count":6,"race_medal":0,"score":"53128324596","product_id":100047701,"comment_content":"1.第一个问题：可以参考http状态码的实现方式，一类错误以相同的数字前缀开头。我们实践的并不好(业务系统)：透传上游错误码；或者是改编一下调用哪个服务哪个接口失败；理由：不管哪出了问题，都是端上的同学的先排查问题，为了节省时间，从错误信息可以方便的定位到底是哪出了问题。<br>2.第二个问题：可维护性怎么办。我们当前使用的是spring MVC 或者jersey框架开发接口，IDEA都有现成的插件可以直接看接口。这种方式想知道完整的接口还需要了解apiVersion实现逻辑。可能会有人说看文档，但是文档和代码的一致性怎么保证呢","like_count":13,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494020,"discussion_content":"1. 可以开发一个独立的错误码服务，实现转码、分类、收敛逻辑，甚至可以开发后台，让产品来录入需要的错误码提示消息。阿里的Java开发手册中也有提到相关错误码的一些推荐的最佳实践。\n2. 这确实是一个问题，所以框架如果做的好的话不仅仅要扩展功能部分还要打通文档，比如如果使用springdoc来什生成OpenAPI文档，那么直接把那部分生成URL的逻辑也改了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588724482,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1596049,"avatar":"https://static001.geekbang.org/account/avatar/00/18/5a/91/f26d17d4.jpg","nickname":"∫1/(x^4*√(1+x^2))dx","note":"","ucode":"E300E20E5AF0FD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290535,"discussion_content":"我觉得如果有这方面需求，不从注解层面来强制版本规范，只能从开发约定层面来统一url的定义格式，避免出现乱七八糟的url，定义的路径使用文档维护起来，然后去评审合理性","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594526611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1095857,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","nickname":"梦倚栏杆","note":"","ucode":"BDEB97F2822445","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1596049,"avatar":"https://static001.geekbang.org/account/avatar/00/18/5a/91/f26d17d4.jpg","nickname":"∫1/(x^4*√(1+x^2))dx","note":"","ucode":"E300E20E5AF0FD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290774,"discussion_content":"你的昵称很个性啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594603436,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":290535,"ip_address":""},"score":290774,"extra":""}]},{"author":{"id":1139455,"avatar":"https://static001.geekbang.org/account/avatar/00/11/62/ff/f71034e9.jpg","nickname":"悟空WuKong","note":"","ucode":"49AFD2B048C1BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544428,"discussion_content":"没有必要把错误码传给客户端，只传错误信息，客户端只需要展示错误信息即可","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641520487,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383330,"discussion_content":"对于 说的 保准返回，再提议额外多2个字段\n1）、traceId  \n全链路跟踪字段。极大的速度提升整个问题排查的速度\n2）、detailErrorInfo\n详细的错误提示。例如 参数错误，那么到底哪个参数错误，烦请尽量直接说明","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626059999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1237874,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e3/72/754314c2.jpg","nickname":"Jackson","note":"","ucode":"A76BC6A4EE13A1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":268758,"discussion_content":"我们会使用swagger来生成文档，如果这样的话，我理解的生成的swagger文件其实也是缺少版本号的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589815952,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284547,"user_name":"x-ray","can_delete":false,"product_type":"c1","uid":1140175,"ip_address":"","ucode":"8363F0C4D0AC0B","user_header":"https://static001.geekbang.org/account/avatar/00/11/65/cf/326c0eea.jpg","comment_is_top":false,"comment_ctime":1616330220,"is_pvip":false,"replies":[{"id":"103287","content":"哈哈","user_name":"作者回复","comment_id":284547,"uid":"1001470","ip_address":"","utype":1,"ctime":1616457554,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"44566003180","product_id":100047701,"comment_content":"@APIVersion那段太牛了，翻看过SpringMVC的代码，也知道RequestMappingHandlerMapping是干什么用的。但从来没想过，可以这样玩，可以给业务代码增加生产力。","like_count":11,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517386,"discussion_content":"哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616457554,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216099,"user_name":"Seven.Lin澤耿","can_delete":false,"product_type":"c1","uid":1181192,"ip_address":"","ucode":"4CAB732CD6F149","user_header":"https://static001.geekbang.org/account/avatar/00/12/06/08/855abb02.jpg","comment_is_top":false,"comment_ctime":1589190004,"is_pvip":false,"replies":[{"id":"79973","content":"引用自《阿里Java开发手册泰山版》<br>12.【参考】错误码尽量有利于不同文化背景的开发者进行交流与代码协作。<br>说明：英文单词形式的错误码不利于非英语母语国家（如阿拉伯语、希伯来语、俄罗斯语等）之间的开发<br>者互相协作。","user_name":"作者回复","comment_id":216099,"uid":"1001470","ip_address":"","utype":1,"ctime":1589190735,"user_name_real":"朱晔"}],"discussion_count":4,"race_medal":0,"score":"35948928372","product_id":100047701,"comment_content":"其实，我不是很认同用数字作为错误码，为何不用单词来做呢？就跟单元测试test1、test2一样，没什么意义，直接用类似`USER_NOT_EXIST`类似的不可以吗？","like_count":9,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494668,"discussion_content":"引用自《阿里Java开发手册泰山版》\n12.【参考】错误码尽量有利于不同文化背景的开发者进行交流与代码协作。\n说明：英文单词形式的错误码不利于非英语母语国家（如阿拉伯语、希伯来语、俄罗斯语等）之间的开发\n者互相协作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589190735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1488356,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b5/e4/e6faf686.jpg","nickname":"握了个大蚂蚱","note":"","ucode":"AD34AD4FA37371","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342179,"discussion_content":"用单词了不就是message信息吗，之所以有code+message我觉得也是个解耦，方便message改变code不变的情况，并且message和code可以维护成多对一的关系，减轻客户端耦合，客户端可以一直以简洁稳定的code来判断走分支","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1610607711,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1542987,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","nickname":"行则将至","note":"","ucode":"DB972F2DF059C4","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400780,"discussion_content":"我司目前部分业务系统的错误码确实不是数字而是字符串，就是楼主说的这种“USER_NOT_EXISTS”形式。实际上，如果不是老师说的这种情况。目前用着没发现啥问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633426016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181192,"avatar":"https://static001.geekbang.org/account/avatar/00/12/06/08/855abb02.jpg","nickname":"Seven.Lin澤耿","note":"","ucode":"4CAB732CD6F149","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263864,"discussion_content":"学习了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589257724,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224268,"user_name":"&#47;&#47;null","can_delete":false,"product_type":"c1","uid":1025045,"ip_address":"","ucode":"E24D976F201030","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a4/15/faee7f27.jpg","comment_is_top":false,"comment_ctime":1591328892,"is_pvip":false,"replies":[{"id":"82566","content":"是的，把MappingJackson2HttpMessageConverter放在最前面即可，或者在ResponseBodyAdvice里面判断类型，特殊处理","user_name":"作者回复","comment_id":224268,"uid":"1001470","ip_address":"","utype":1,"ctime":1591329461,"user_name_real":"朱晔"}],"discussion_count":2,"race_medal":0,"score":"27361132668","product_id":100047701,"comment_content":"自动包装外层APIResposne响应的那边有一个问题，刚好我在做的时候遇到了，如果控制器返回的是String类型，那么返回APIResponse 对象会出现转换错误，因为我们在控制器返回的是String类型 springmvc会使用 StringHttpMessageConverter 转换器，这时候会报转换错误。","like_count":7,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497423,"discussion_content":"是的，把MappingJackson2HttpMessageConverter放在最前面即可，或者在ResponseBodyAdvice里面判断类型，特殊处理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591329461,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2016089,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/c3/59/5d0906ca.jpg","nickname":"庞","note":"","ucode":"126E89B3EB007C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394206,"discussion_content":"可以在APIResposne类里面去实现数据的封装，接口统一返回APIResposne对象，返回数据的时候使用APIResposne.ok();APIResposne.error(&#34;errorMsg&#34;);这样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631785163,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214637,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":false,"comment_ctime":1588776083,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"27358579859","product_id":100047701,"comment_content":"一、其实有一定的作用，其实可以根据不同分类，前端其实在处理的时候，可以维护一个map，key时错误码的前1位或者2位，根据具体的业务，value时该状态码对应的处理器，就是工厂模式，这样的话其实不用处理if else的问题。<br>二、第二个问题回答下“梦倚栏杆”童鞋的问题吧，其实自定义RequestMappingHandlerMapping的时候，可以把之前的也注册到registerHandlerMethod中，也就是说如果不写@APIVersion注解的话，不带版本号和带v1版本都是可以的匹配到的，若是真的有一天某个接口需要支持多版本，那么开发童鞋也就不得不看@APIVersion的说明文档了，其实也不算解决方式，算是稍规避了下吧；我们之前在使用swagger2的时候，好像swagger2生成的接口是默认带服务民称的，但是本地测试的时候其实是不需要的，导致请求不到，我们就自定义RequestMappingHandlerMapping，把带服务名和不带服务名的都加到mapping中。","like_count":7},{"had_liked":false,"id":214199,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1588674602,"is_pvip":false,"replies":[{"id":"79321","content":"特殊情况下，比如收单服务内部处理不当，或是订单服务出现了额外的状态，虽然 success 为 true，但订单实际状态不是 Created，这时可以给予友好的错误提示。》》这段我是指客户端的处理逻辑，客户端需要考虑到各种服务端响应的可能。<br><br>","user_name":"作者回复","comment_id":214199,"uid":"1001470","ip_address":"","utype":1,"ctime":1588680068,"user_name_real":"朱晔"}],"discussion_count":2,"race_medal":1,"score":"14473576490","product_id":100047701,"comment_content":"1. 我们有一个code的字典表，就是excel中列出来，每新增一个，就在里面加一个，前端根据这个表格在代码中实现字典表查询，然后用友好的提示展示给用户。<br>2. 回头补代码。<br><br>有个疑问， “特殊情况下，比如收单服务内部处理不当，或是订单服务出现了额外的状态，虽然 success 为 true，但订单实际状态不是 Created，这时可以给予友好的错误提示。”<br>-------我们没有这么干，我一时也有点接受不了，只要有错误，success肯定是false，所以想问问老师，有具体的案例可以分享下么，谢谢。其他小伙伴，你们呢，也是这么干么。","like_count":4,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493981,"discussion_content":"特殊情况下，比如收单服务内部处理不当，或是订单服务出现了额外的状态，虽然 success 为 true，但订单实际状态不是 Created，这时可以给予友好的错误提示。》》这段我是指客户端的处理逻辑，客户端需要考虑到各种服务端响应的可能。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588680068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1183090,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0d/72/38c62a8f.jpg","nickname":"slowly","note":"","ucode":"D8F1FB2B9E7534","race_medal":2,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260478,"discussion_content":"男：让我们手牵手。。。？？？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588864840,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284482,"user_name":"x-ray","can_delete":false,"product_type":"c1","uid":1140175,"ip_address":"","ucode":"8363F0C4D0AC0B","user_header":"https://static001.geekbang.org/account/avatar/00/11/65/cf/326c0eea.jpg","comment_is_top":false,"comment_ctime":1616298571,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10206233163","product_id":100047701,"comment_content":"APIResponseAdvice这个方式我试过，很不错，但就像老师说的，需要进行更多处理，其中我自己发现的两个坑是：<br>1.方法返回类型如果是String，需要自己实现json串的处理，因为此时类型转换优先使用StringHttpMessageConverter，而不是MappingJackson2HttpMessageConverter<br>2.方法返回类型如果是Object，不能返回null。如果为Object，且实际返回null，会跳过MediaType的预判处理","like_count":2,"discussions":[{"author":{"id":1169313,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJkeOAC8k7aPMfQZ4ickiavpfR9mTQs1wGhGtIicotzAoszE5qkLfFTabkDU2E39ovSgoibJ1IiaLXtGicg/132","nickname":"bigben","note":"","ucode":"DBD15A6C8E2590","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569142,"discussion_content":"怎么解决的呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651331317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":273511,"user_name":"冉野","can_delete":false,"product_type":"c1","uid":1137353,"ip_address":"","ucode":"2CAEA424996876","user_header":"https://static001.geekbang.org/account/avatar/00/11/5a/c9/933ee0a8.jpg","comment_is_top":false,"comment_ctime":1610617790,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10200552382","product_id":100047701,"comment_content":"刚上线这次的业务也有一个需要导出清算订单数据，使用的方式跟老师差不多，起了一个新线程异步完成导出操作，返回了taskId并实例化到数据库，前端通过taskId会一直在轮询导出结果，如果完成后会更新taskId所在记录，返回文件链接，完全实现了纯异步，内存消耗很小，CPU占用也小，尤其是导入，百万级的数量导入并清算完成，也只用了40秒。","like_count":2},{"had_liked":false,"id":301949,"user_name":"Geek_c5e36a","can_delete":false,"product_type":"c1","uid":2508111,"ip_address":"","ucode":"1700357E7071DC","user_header":"","comment_is_top":false,"comment_ctime":1625992974,"is_pvip":false,"replies":[{"id":"109287","content":"中台系统也应该尽量抽象&amp;屏蔽背后具体的服务，错误码可以提供统一的后台查询","user_name":"作者回复","comment_id":301949,"uid":"1001470","ip_address":"","utype":1,"ctime":1626057402,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"5920960270","product_id":100047701,"comment_content":"“虽然说收单服务调用订单服务进行真正的下单操作，但是直接接口其实是收单服务提供的，收单服务不应该“直接”暴露其背后订单服务的状态码、错误描述。”，老师，这里我有个疑问，如果是作为一种中台系统，如果不把下游的错误描述返回给上游，这样的话，每次上游出问题都得找你查状态码，错误描述，然后在找下游系统解决，这样会给系统运维带来很大的压力吧？","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523132,"discussion_content":"中台系统也应该尽量抽象&amp;amp;屏蔽背后具体的服务，错误码可以提供统一的后台查询","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626057402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":292122,"user_name":"阿清","can_delete":false,"product_type":"c1","uid":2015606,"ip_address":"","ucode":"29E19FF183938F","user_header":"https://static001.geekbang.org/account/avatar/00/1e/c1/76/788da264.jpg","comment_is_top":false,"comment_ctime":1620697616,"is_pvip":false,"replies":[{"id":"105780","content":"本地事务+MQ事务性消息&#47;或事务性MQ作为整体事务，由MQ确保数据最终可以发给另一个接口<br>当然也可以本地保存后比较粗暴通过状态位实现远程接口调用的补偿，通过Job补偿失败的接口调用","user_name":"作者回复","comment_id":292122,"uid":"1001470","ip_address":"","utype":1,"ctime":1620715889,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"5915664912","product_id":100047701,"comment_content":"大腿，请教一个问题。系统是一个单体SSH项目，有一个业务场景，比如：系统中有一个用户录入或修改单据操作，用户录入或修改完成后，不仅要保存在本系统中，同时还有调用另外一个系统接口，把数据传给他们。问题是如何做到类似事务统一？","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519687,"discussion_content":"本地事务+MQ事务性消息/或事务性MQ作为整体事务，由MQ确保数据最终可以发给另一个接口\n当然也可以本地保存后比较粗暴通过状态位实现远程接口调用的补偿，通过Job补偿失败的接口调用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620715889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":291478,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1620301610,"is_pvip":false,"replies":[{"id":"105635","content":"感谢","user_name":"作者回复","comment_id":291478,"uid":"1001470","ip_address":"","utype":1,"ctime":1620439503,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":4,"score":"5915268906","product_id":100047701,"comment_content":"很实用","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519481,"discussion_content":"感谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620439503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":278648,"user_name":"君子意如何","can_delete":false,"product_type":"c1","uid":1096699,"ip_address":"","ucode":"B87E94BA680469","user_header":"https://static001.geekbang.org/account/avatar/00/10/bb/fb/7d02b84e.jpg","comment_is_top":false,"comment_ctime":1613176711,"is_pvip":true,"replies":[{"id":"101364","content":"新年快乐","user_name":"作者回复","comment_id":278648,"uid":"1001470","ip_address":"","utype":1,"ctime":1613459485,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"5908144007","product_id":100047701,"comment_content":"今天本课第二刷，朱老师新年快乐","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515458,"discussion_content":"新年快乐","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613459485,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239032,"user_name":"昵称而已，何必执着","can_delete":false,"product_type":"c1","uid":1057139,"ip_address":"","ucode":"D8F0D534D7450F","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/73/2da558bb.jpg","comment_is_top":false,"comment_ctime":1596419203,"is_pvip":false,"replies":[{"id":"88297","content":"swagger可以同步修改","user_name":"作者回复","comment_id":239032,"uid":"1001470","ip_address":"","utype":1,"ctime":1596427666,"user_name_real":"朱晔"}],"discussion_count":1,"race_medal":0,"score":"5891386499","product_id":100047701,"comment_content":"@APIVersion 这种的控制版本，swagger怎么办？","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502946,"discussion_content":"swagger可以同步修改","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596427666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":233008,"user_name":"Asha","can_delete":false,"product_type":"c1","uid":1796527,"ip_address":"","ucode":"69F227707A9EDD","user_header":"https://static001.geekbang.org/account/avatar/00/1b/69/af/ceb4450c.jpg","comment_is_top":false,"comment_ctime":1594190863,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5889158159","product_id":100047701,"comment_content":"老师和同学们，对于api接口的异常来说，可以使用老师的@RestControllerAdvice和@ExceptionHandler 和ResponseBodyAdvice的结合节省很多工作，那对于基于servlet filter的这种里面的异常比如token过期如何处理呢？多谢。","like_count":1},{"had_liked":false,"id":216418,"user_name":"FelixFly","can_delete":false,"product_type":"c1","uid":1160461,"ip_address":"","ucode":"1D39A7C3D0E31F","user_header":"https://static001.geekbang.org/account/avatar/00/11/b5/0d/0e65dee6.jpg","comment_is_top":false,"comment_ctime":1589255606,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5884222902","product_id":100047701,"comment_content":"1. 错误代码是需要的，方便快速定位问题以及有可能需要根据错误码进行相应的业务处理，若是给前端的话，一般有个错误类型，前端用于怎么展示这个信息，这个错误信息弄个统一的维护界面，数据放到缓存。<br>2. 这个统一的配置是个好的方法，我们还是用最原始的方法，在每个url上进行定义，这样会出现配置错误的可能","like_count":1},{"had_liked":false,"id":346603,"user_name":"计算机小白","can_delete":false,"product_type":"c1","uid":2175868,"ip_address":"","ucode":"CB09BD7DE559F2","user_header":"https://static001.geekbang.org/account/avatar/00/21/33/7c/53e0eecb.jpg","comment_is_top":false,"comment_ctime":1653275498,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653275498","product_id":100047701,"comment_content":"想问下作者  @RestControllerAdvice定义的代码好像没帖出来呢 该怎么写呢？","like_count":0},{"had_liked":false,"id":246023,"user_name":"小胡子","can_delete":false,"product_type":"c1","uid":1018182,"ip_address":"","ucode":"79FEC6400D25DA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/89/46/0b7828a1.jpg","comment_is_top":false,"comment_ctime":1599137232,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1599137232","product_id":100047701,"comment_content":"版本控制最大的问题应该是如何做到版本兼容，不论路径还是请求头都都遇到这个问题","like_count":0,"discussions":[{"author":{"id":1225974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b4/f6/e39d5af1.jpg","nickname":"钱米","note":"","ucode":"07AA44C6A40D34","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391152,"discussion_content":"所以怎么解决版本不兼容才是麻烦事，兼容代码逻辑、新写代码、改表加字段、新加表历史代码逻辑怎么处理。相对来说，接口的版本处理算是锦上添花","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630317128,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1030842,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ba/ba/83de3488.jpg","nickname":"Carter","note":"","ucode":"1FD476D8F2BE27","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311006,"discussion_content":"就是版本不兼容才需要版本控制吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602168783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241894,"user_name":"随便看看","can_delete":false,"product_type":"c1","uid":2067951,"ip_address":"","ucode":"FFECD089472002","user_header":"https://static001.geekbang.org/account/avatar/00/1f/8d/ef/b03e910d.jpg","comment_is_top":false,"comment_ctime":1597490563,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597490563","product_id":100047701,"comment_content":"老师，我在自己的项目中添加APIVersionHandlerMapping，调用接口的时候，报错：java.lang.IllegalStateException: getInputStream() has already been called for this request。项目中有一个重写了HttpServletRequestWrapper的类，用来解决body不可重复读的问题。但是在使用ApiVersionHandlerMapping，Controller类上加上@APIVeriosn之后，发现不走重写的HttpServletRequestWrapper了，然后报了上面的错误，这是什么原因吗","like_count":0},{"had_liked":false,"id":237321,"user_name":"星夜","can_delete":false,"product_type":"c1","uid":1128491,"ip_address":"","ucode":"3B46C09D994CEB","user_header":"https://static001.geekbang.org/account/avatar/00/11/38/2b/9db9406b.jpg","comment_is_top":false,"comment_ctime":1595778361,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595778361","product_id":100047701,"comment_content":"错误码方面，其实大部分错误是提示性错误，需要后端收敛起来，将提示信息传给客户端展示即可。少部分的例如用户登录，用户重试，跳转要和提示性错误区分，说白了还是分类处理，减少客户端对于错误码的关注。","like_count":0},{"had_liked":false,"id":235115,"user_name":"mickey","can_delete":false,"product_type":"c1","uid":1051663,"ip_address":"","ucode":"8B490C2DDE4010","user_header":"https://static001.geekbang.org/account/avatar/00/10/0c/0f/93d1c8eb.jpg","comment_is_top":false,"comment_ctime":1594895890,"is_pvip":false,"replies":[{"id":"86775","content":"可以访问到，又不是ThreadLocal的","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1594897324,"ip_address":"","comment_id":235115,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1594895890","product_id":100047701,"comment_content":"请问老师，异步处理的结果应该不能保存在私有的HashMap里吧？因为后续的状态查询接口是新的一个线程，访问不到这个hashmap啊。<br><br>private ConcurrentHashMap&lt;String, SyncQueryUploadTaskResponse&gt; downloadUrl","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501605,"discussion_content":"可以访问到，又不是ThreadLocal的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594897324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1217874,"avatar":"https://static001.geekbang.org/account/avatar/00/12/95/52/ad190682.jpg","nickname":"Mr wind","note":"","ucode":"484F02D1962239","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":315284,"discussion_content":"私有的属性，但是提供了公共的查询方法啊，兄弟，外部又不可能改变得了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603260400,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1051663,"avatar":"https://static001.geekbang.org/account/avatar/00/10/0c/0f/93d1c8eb.jpg","nickname":"mickey","note":"","ucode":"8B490C2DDE4010","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291646,"discussion_content":"如果能访问是内存泄漏啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594898116,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214859,"user_name":"Wiggle Wiggle","can_delete":false,"product_type":"c1","uid":1036052,"ip_address":"","ucode":"EFE746551BA998","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cf/14/384258ba.jpg","comment_is_top":false,"comment_ctime":1588835624,"is_pvip":false,"replies":[{"id":"79555","content":"断开链接后，会出异常，比如对于文件上传可能就是<br><br>java.io.EOFException: Unexpected EOF read on the socket<br><br>在servlet层面就已经出错，不会进入业务逻辑处理，也不会存在废文件，对于tomcat可以把文件临时目录配置为一个固定目录，即便存在残留文件也可以定期清除","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1588843088,"ip_address":"","comment_id":214859,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1588835624","product_id":100047701,"comment_content":"对于同步接口，以文中的图片上传为例，假设实际上传需要较长时间，如果前端等待一定时间后断开连接（想取消上传），那么后端如何处理比较好？在 spring 框架下如何感知前端断开了连接？如何避免一条废数据上传到服务器呢？","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494222,"discussion_content":"断开链接后，会出异常，比如对于文件上传可能就是\n\njava.io.EOFException: Unexpected EOF read on the socket\n\n在servlet层面就已经出错，不会进入业务逻辑处理，也不会存在废文件，对于tomcat可以把文件临时目录配置为一个固定目录，即便存在残留文件也可以定期清除","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588843088,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214805,"user_name":"殿小二","can_delete":false,"product_type":"c1","uid":1284986,"ip_address":"","ucode":"E979673B257C24","user_header":"https://static001.geekbang.org/account/avatar/00/13/9b/7a/58327b6d.jpg","comment_is_top":false,"comment_ctime":1588822220,"is_pvip":false,"replies":[{"id":"79523","content":"新老接口总有公用逻辑的吧，把其中重复的部分提取出来","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1588826908,"ip_address":"","comment_id":214805,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1588822220","product_id":100047701,"comment_content":"老师 你好,问一下,针对非强制升级时,为了兼容老接口,只能复制一份,这类代码太重复了,有没有比较优化的解决方案","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494205,"discussion_content":"新老接口总有公用逻辑的吧，把其中重复的部分提取出来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588826908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214378,"user_name":"Geek_3b1096","can_delete":false,"product_type":"c1","uid":1549364,"ip_address":"","ucode":"A6BD92B79B3632","user_header":"","comment_is_top":false,"comment_ctime":1588733843,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588733843","product_id":100047701,"comment_content":"谢谢老师分享接口设计思维","like_count":0},{"had_liked":false,"id":214361,"user_name":"刘大明","can_delete":false,"product_type":"c1","uid":1035081,"ip_address":"","ucode":"83C063FBD9BF2B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cb/49/0b9ffc8e.jpg","comment_is_top":false,"comment_ctime":1588731006,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588731006","product_id":100047701,"comment_content":"目前我们系统中是直接抛出自定义异常来去做异常提示信息.中途改造过一版,直接将code码和message提示信息写到配置管理中心里面.或者放到redis缓存里面.<br>作为服务端我觉得有必要给出code错误码,方便问题排查<br>","like_count":0}]}