{"id":638234,"title":"02｜扩展Bean：如何配置constructor、property和init-method？","content":"<p>你好，我是郭屹。</p><p>上节课，我们初步实现了一个MiniSpring框架，它很原始也很简单。我们实现了一个BeanFactory，作为一个容器对Bean进行管理，我们还定义了数据源接口Resource，可以将多种数据源注入Bean。</p><p>这节课，我们继续增强IoC容器，我们要做的主要有3点。</p><ol>\n<li>增加单例Bean的接口定义，然后把所有的Bean默认为单例模式。</li>\n<li>预留事件监听的接口，方便后续进一步解耦代码逻辑。</li>\n<li>扩展BeanDefinition，添加一些属性，现在它只有id和class两个属性，我们要进一步地丰富它。</li>\n</ol><h2>构建单例的Bean</h2><p>首先我们来看看如何构建单例的Bean，并对该Bean进行管理。</p><p>单例（Singleton）是指某个类在整个系统内只有唯一的对象实例。只要能达到这个目的，采用什么技术手段都是可以的。常用的实现单例的方式有不下五种，因为我们构建单例的目的是深入理解Spring框架，所以我们会按照Spring的实现方式来做。</p><p>为了和Spring框架内的方法名保持一致，我们把BeanFactory接口中定义的registryBeanDefinition方法修改为registryBean，参数修改为beanName与obj。其中，obj为Object类，指代与beanName对应的Bean的信息。你可以看下修改后的BeanFactory。</p><!-- [[[read_end]]] --><pre><code class=\"language-java\">public interface BeanFactory {\n&nbsp; &nbsp; Object getBean(String beanName) throws BeansException;\n&nbsp; &nbsp; Boolean containsBean(String name);\n&nbsp; &nbsp; void registerBean(String beanName, Object obj);\n}\n</code></pre><p>既然要管理单例Bean，接下来我们就定义一下SingletonBeanRegistry，将管理单例Bean的方法规范好。</p><pre><code class=\"language-java\">public interface SingletonBeanRegistry {\n&nbsp; &nbsp; void registerSingleton(String beanName, Object singletonObject);\n&nbsp; &nbsp; Object getSingleton(String beanName);\n&nbsp; &nbsp; boolean containsSingleton(String beanName);\n&nbsp; &nbsp; String[] getSingletonNames();\n}\n</code></pre><p>你看这个类的名称上带有Registry字样，所以让人一眼就能知道这里面存储的就是Bean。从代码可以看到里面的方法 名称简单直接，分别对应单例的注册、获取、判断是否存在，以及获取所有的单例Bean等操作。</p><p>接口已经定义好了，接下来我们定义一个默认的实现类。这也是从Spring里学的方法，它作为一个框架并不会把代码写死，所以这里面的很多实现类都是默认的，默认是什么意思呢？就是我们可以去替换，不用这些默认的类也是可以的。我们就按照同样的方法，来为我们的默认实现类取个名字DefaultSingletonBeanRegistry。</p><pre><code class=\"language-java\">public class DefaultSingletonBeanRegistry implements SingletonBeanRegistry {\n    //容器中存放所有bean的名称的列表\n    protected List&lt;String&gt; beanNames = new ArrayList&lt;&gt;();\n    //容器中存放所有bean实例的map\n    protected Map&lt;String, Object&gt; singletons = new ConcurrentHashMap&lt;&gt;(256);\n\n    public void registerSingleton(String beanName, Object singletonObject) {\n        synchronized (this.singletons) {\n            this.singletons.put(beanName, singletonObject);\n            this.beanNames.add(beanName);\n        }\n    }\n    public Object getSingleton(String beanName) {\n        return this.singletons.get(beanName);\n    }\n    public boolean containsSingleton(String beanName) {\n        return this.singletons.containsKey(beanName);\n    }\n    public String[] getSingletonNames() {\n        return (String[]) this.beanNames.toArray();\n    }\n    protected void removeSingleton(String beanName) {\n        synchronized (this.singletons) {\n            this.beanNames.remove(beanName);\n            this.singletons.remove(beanName);\n        }\n    }\n}\n</code></pre><p>我们在默认的这个类中，定义了beanNames列表和singletons的映射关系，beanNames用于存储所有单例Bean的别名，singletons则存储Bean名称和实现类的映射关系。</p><p>这段代码中要留意的是，我们将 singletons 定义为了一个ConcurrentHashMap，而且在实现 registrySingleton 时前面加了一个关键字synchronized。这一切都是为了确保在多线程并发的情况下，我们仍然能安全地实现对单例Bean的管理，无论是单线程还是多线程，我们整个系统里面这个Bean总是唯一的、单例的。</p><p>还记得我们有SimpleBeanFactory这样一个简单的BeanFactory实现类吗？接下来我们修改这个类，让它继承上一步创建的DefaultSingletonBeanRegistry，确保我们通过SimpleBeanFactory创建的Bean默认就是单例的，这也和Spring本身的处理方式一致。</p><pre><code class=\"language-java\">public class SimpleBeanFactory extends DefaultSingletonBeanRegistry implements BeanFactory{\n    private Map&lt;String, BeanDefinition&gt; beanDefinitions = new ConcurrentHashMap&lt;&gt;(256);\n    public SimpleBeanFactory() {\n    }\n\n    //getBean，容器的核心方法\n    public Object getBean(String beanName) throws BeansException {\n        //先尝试直接拿bean实例\n        Object singleton = this.getSingleton(beanName);\n        //如果此时还没有这个bean的实例，则获取它的定义来创建实例\n        if (singleton == null) {\n            //获取bean的定义\n            BeanDefinition beanDefinition = beanDefinitions.get(beanName);\n            if (beanDefinition == null) {\n                throw new BeansException(\"No bean.\");\n            }\n            try {\n                singleton = Class.forName(beanDefinition.getClassName()).newInstance();\n            } \n            //新注册这个bean实例\n            this.registerSingleton(beanName, singleton);\n        }\n        return singleton;\n    }\n    public void registerBeanDefinition(BeanDefinition beanDefinition) {\n        this.beanDefinitions.put(beanDefinition.getId(), beanDefinition);\n    }\n    public Boolean containsBean(String name) {\n        return containsSingleton(name);\n    }\n    public void registerBean(String beanName, Object obj) {\n        this.registerSingleton(beanName, obj);\n    }\n}\n\n</code></pre><p>我们对 SimpleBeanFactory 的主要改动是增加了对containsBean和registerBean的实现。通过代码可以看出，这两处实现都是对单例Bean的操作。</p><p>这部分还有两个类需要调整：ClassPathXmlApplicationContext和XmlBeanDefinitionReader。其中ClassPathXmlApplicationContext里增加了对containsBean和registerBean的实现。</p><pre><code class=\"language-java\">public Boolean containsBean(String name) {\n    return this.beanFactory.containsBean(name);\n}\npublic void registerBean(String beanName, Object obj) {\n    this.beanFactory.registerBean(beanName, obj);\n}\n</code></pre><p>XmlBeanDefinitionReader调整后如下：</p><pre><code class=\"language-java\">public class XmlBeanDefinitionReader {\n    SimpleBeanFactory simpleBeanFactory;\n    public XmlBeanDefinitionReader(SimpleBeanFactory simpleBeanFactory) {\n        this.simpleBeanFactory = simpleBeanFactory;\n    }\n    public void loadBeanDefinitions(Resource resource) {\n        while (resource.hasNext()) {\n            Element element = (Element) resource.next();\n            String beanID = element.attributeValue(\"id\");\n            String beanClassName = element.attributeValue(\"class\");\n            BeanDefinition beanDefinition = new BeanDefinition(beanID, beanClassName);\n            this.simpleBeanFactory.registerBeanDefinition(beanDefinition);\n        }\n    }\n}\n\n</code></pre><h2>增加事件监听</h2><p>构建好单例Bean之后，为了监控容器的启动状态，我们要增加事件监听。</p><p>我们先定义一下ApplicationEvent和ApplicationEventPublisher。通过名字可以看出，一个是用于监听应用的事件，另一个则是发布事件。</p><ul>\n<li>ApplicationEventPublisher的实现</li>\n</ul><pre><code class=\"language-java\">public interface ApplicationEventPublisher {\n    void publishEvent(ApplicationEvent event);\n}\n</code></pre><ul>\n<li>ApplicationEvent的实现</li>\n</ul><pre><code class=\"language-java\">public class ApplicationEvent  extends EventObject {\n    private static final long serialVersionUID = 1L;\n    public ApplicationEvent(Object arg0) {\n        super(arg0);\n    }\n}\n</code></pre><p>可以看出，ApplicationEvent继承了Java工具包内的EventObject，我们是在Java的事件监听的基础上进行了简单的封装。虽然目前还没有任何实现，但这为我们后续使用观察者模式解耦代码提供了入口。</p><p>到此为止，我们进一步增强了IoC容器，还引入了两个新概念：<strong>单例Bean和事件监听。</strong>其中，事件监听这部分目前只预留了入口，方便我们后续扩展。而单例Bean则是Spring框架默认的实现，我们提供了相关实现方法，并考虑到多线程高并发的场景，引入了ConcurrentHashMap来存储Bean信息。</p><p>到这一步，我们容器就变成了管理单例Bean的容器了。下面我们做一点准备工作，为后面对这些Bean注入属性值做铺垫。</p><h2>注入</h2><p>Spring中有三种属性注入的方式，分别是<strong>Field注入、Setter注入和构造器（Constructor）注入。</strong>Field注入是指我们给Bean里面某个变量赋值。Setter注入是提供了一个setter方法，调用setXXX()来注入值。constructor就是在构造器/构造函数里传入参数来进行注入。Field注入我们后面会实现，这节课我们先探讨Setter注入和构造器注入两种方式。</p><h3>配置Setter注入</h3><p>首先我们来看下配置，在XML文件中我们是怎么声明使用Setter注入方式的。</p><pre><code class=\"language-xml\">&lt;beans&gt;\n    &lt;bean id=\"aservice\" class=\"com.minis.test.AServiceImpl\"&gt;\n        &lt;property type=\"String\" name=\"property1\" value=\"Hello World!\"/&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;\n</code></pre><p>由上面的示例可以看出，我们在 <code>&lt;bean&gt;</code> 标签下引入了 <code>&lt;property&gt;</code> 标签，它又包含了type、name和value，分别对应属性类型、属性名称以及赋值。你可以看一下这个Bean的代码。</p><pre><code class=\"language-java\">public class AServiceImpl {\n  private String property1;\n\n  public void setProperty1(String property1) {\n    this.property1 = property1;\n  }\n}\n</code></pre><h3>配置构造器注入</h3><p>接下来我们再看看怎么声明构造器注入，同样是在XML里配置。</p><pre><code class=\"language-xml\">&lt;beans&gt;\n    &lt;bean id=\"aservice\" class=\"com.minis.test.AServiceImpl\"&gt;\n      &lt;constructor-arg type=\"String\" name=\"name\" value=\"abc\"/&gt;\n      &lt;constructor-arg type=\"int\" name=\"level\" value=\"3\"/&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;\n</code></pre><p>可以看到，与Setter注入类似，我们只是把 <code>&lt;property&gt;</code> 标签换成了 <code>&lt;constructor-args&gt;</code> 标签。</p><pre><code class=\"language-java\">public class AServiceImpl {\n  \n  private String name;\n  private int level;\n\n  public AServiceImpl(String name, int level) {\n    this.name = name;\n    this.level = level;\n  }\n}\n</code></pre><p>由上述两种方式可以看出，<strong>注入操作的本质，就是给Bean的各个属性进行赋值。</strong>具体方式取决于实际情况，哪一种更便捷就可以选择哪一种。如果采用构造器注入的方式满足不了对域的赋值，也可以将构造器注入和Setter注入搭配使用。</p><pre><code class=\"language-xml\">&lt;beans&gt;\n    &lt;bean id=\"aservice\" class=\"com.minis.test.AServiceImpl\"&gt;\n        &lt;constructor-arg type=\"String\" name=\"name\" value=\"abc\"/&gt;\n        &lt;constructor-arg type=\"int\" name=\"level\" value=\"3\"/&gt;\n        &lt;property type=\"String\" name=\"property1\" value=\"Someone says\"/&gt;\n        &lt;property type=\"String\" name=\"property2\" value=\"Hello World!\"/&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;\n</code></pre><p>现在我们已经明确了 <code>&lt;property&gt;</code> 和 <code>&lt;constructor-args&gt;</code> 标签的定义，但是只有外部的XML文件配置定义肯定是不行的，还要去实现。这就是我们接下来需要完成的工作。</p><h2>实现属性类</h2><p>与这个定义相关，我们要配置对应的属性类，分别命名为ArgumentValue和PropertyValue。</p><pre><code class=\"language-java\">public class ArgumentValue {\n    private Object value;\n    private String type;\n    private String name;\n    public ArgumentValue(Object value, String type) {\n        this.value = value;\n        this.type = type;\n    }\n    public ArgumentValue(Object value, String type, String name) {\n        this.value = value;\n        this.type = type;\n        this.name = name;\n    }\n    //省略getter和setter\n}\n</code></pre><pre><code class=\"language-java\">public class PropertyValue {\n    private final String name;\n    private final Object value;\n    public PropertyValue(String name, Object value) {\n        this.name = name;\n        this.value = value;\n    }\n    //省略getter\n}\n</code></pre><p>我们看Value这个词，后面不带“s”就表示他只是针对的某一个属性或者某一个参数，但一个Bean里面有很多属性、很多参数，所以我们就需要一个带“s”的集合类。 在Spring中也是这样的，所以我们参考Spring的方法，提供了ArgumentValues和PropertyValues两个类，封装、 增加、获取、判断等操作方法，简化调用。既给外面提供单个的参数/属性的对象，也提供集合对象。</p><ul>\n<li>ArgumentValues类</li>\n</ul><pre><code class=\"language-java\">public class ArgumentValues {\n    private final Map&lt;Integer, ArgumentValue&gt; indexedArgumentValues = new HashMap&lt;&gt;(0);\n    private final List&lt;ArgumentValue&gt; genericArgumentValues = new LinkedList&lt;&gt;();\n    public ArgumentValues() {\n    }\n    private void addArgumentValue(Integer key, ArgumentValue newValue) {\n        this.indexedArgumentValues.put(key, newValue);\n    }\n    public boolean hasIndexedArgumentValue(int index) {\n        return this.indexedArgumentValues.containsKey(index);\n    }\n    public ArgumentValue getIndexedArgumentValue(int index) {\n        return this.indexedArgumentValues.get(index);\n    }\n    public void addGenericArgumentValue(Object value, String type) {\n        this.genericArgumentValues.add(new ArgumentValue(value, type));\n    }\n    private void addGenericArgumentValue(ArgumentValue newValue) {\n        if (newValue.getName() != null) {\n            for (Iterator&lt;ArgumentValue&gt; it =\n                 this.genericArgumentValues.iterator(); it.hasNext(); ) {\n                ArgumentValue currentValue = it.next();\n                if (newValue.getName().equals(currentValue.getName())) {\n                    it.remove();\n                }\n            }\n        }\n        this.genericArgumentValues.add(newValue);\n    }\n    public ArgumentValue getGenericArgumentValue(String requiredName) {\n        for (ArgumentValue valueHolder : this.genericArgumentValues) {\n            if (valueHolder.getName() != null &amp;&amp; (requiredName == null || !valueHolder.getName().equals(requiredName))) {\n                continue;\n            }\n            return valueHolder;\n        }\n        return null;\n    }\n    public int getArgumentCount() {\n        return this.genericArgumentValues.size();\n    }\n    public boolean isEmpty() {\n        return this.genericArgumentValues.isEmpty();\n    }\n}\n</code></pre><ul>\n<li>PropertyValues类</li>\n</ul><pre><code class=\"language-java\">public class PropertyValues {\n    private final List&lt;PropertyValue&gt; propertyValueList;\n    public PropertyValues() {\n        this.propertyValueList = new ArrayList&lt;&gt;(0);\n    }\n    public List&lt;PropertyValue&gt; getPropertyValueList() {\n        return this.propertyValueList;\n    }\n    public int size() {\n        return this.propertyValueList.size();\n    }\n    public void addPropertyValue(PropertyValue pv) {\n        this.propertyValueList.add(pv);\n    }\n    public void addPropertyValue(String propertyName, Object propertyValue) {\n        addPropertyValue(new PropertyValue(propertyName, propertyValue));\n    }\n    public void removePropertyValue(PropertyValue pv) {\n        this.propertyValueList.remove(pv);\n    }\n    public void removePropertyValue(String propertyName) {\n        this.propertyValueList.remove(getPropertyValue(propertyName));\n    }\n    public PropertyValue[] getPropertyValues() {\n        return this.propertyValueList.toArray(new PropertyValue[this.propertyValueList.size()]);\n    }\n    public PropertyValue getPropertyValue(String propertyName) {\n        for (PropertyValue pv : this.propertyValueList) {\n            if (pv.getName().equals(propertyName)) {\n                return pv;\n            }\n        }\n        return null;\n    }\n    public Object get(String propertyName) {\n        PropertyValue pv = getPropertyValue(propertyName);\n        return pv != null ? pv.getValue() : null;\n    }\n    public boolean contains(String propertyName) {\n        return getPropertyValue(propertyName) != null;\n    }\n    public boolean isEmpty() {\n        return this.propertyValueList.isEmpty();\n    }\n}\n</code></pre><p>上面这些代码整体还是比较简单的，根据各个封装方法的名称，也基本能明确它们的用途，这里就不再赘述了。对于构造器注入和Setter注入两种方式，这里我们只是初步定义相关类，做一点准备，后面我们将实现具体解析以及注入的过程。</p><p>接下来，我们还要做两件事。</p><ol>\n<li>扩展BeanDefinition的属性，在原有id与name两个属性的基础上，新增lazyInit、dependsOn、initMethodName等属性。</li>\n<li>继续扩展BeanFactory接口，增强对Bean的处理能力。</li>\n</ol><h2>扩展BeanDefinition</h2><p>我们先给BeanDefinition和BeanFactory增加新的接口，新增接口基本上是适配BeanDefinition新增属性的。</p><p>我们给BeanDefinition类添加了哪些属性呢？一起来看下。</p><pre><code class=\"language-java\">public class BeanDefinition {\n    String SCOPE_SINGLETON = \"singleton\";\n    String SCOPE_PROTOTYPE = \"prototype\";\n    private boolean lazyInit = false;\n    private String[] dependsOn;\n    private ArgumentValues constructorArgumentValues;\n    private PropertyValues propertyValues;\n    private String initMethodName;\n    private volatile Object beanClass;\n    private String id;\n    private String className;\n    private String scope = SCOPE_SINGLETON;\n    public BeanDefinition(String id, String className) {\n        this.id = id;\n        this.className = className;\n    }\n    //省略getter和setter\n}\n</code></pre><p>从上面代码可以看出，之前我们只有id和className属性，现在增加了scope属性，表示bean是单例模式还是原型模式，还增加了lazyInit属性，表示Bean要不要在加载的时候初始化，以及初始化方法initMethodName的声明，当一个Bean构造好并实例化之后是否要让框架调用初始化方法。还有dependsOn属性记录Bean之间的依赖关系，最后还有构造器参数和property列表。</p><h2>集中存放BeanDefinition</h2><p>接下来，我们新增BeanDefinitionRegistry接口。它类似于一个存放BeanDefinition的仓库，可以存放、移除、获取及判断BeanDefinition对象。所以，我们初步定义四个接口对应这四个功能，分别是register、remove、get、contains。</p><pre><code class=\"language-java\">public interface BeanDefinitionRegistry {\n&nbsp; &nbsp; void registerBeanDefinition(String name, BeanDefinition bd);\n&nbsp; &nbsp; void removeBeanDefinition(String name);\n&nbsp; &nbsp; BeanDefinition getBeanDefinition(String name);\n&nbsp; &nbsp; boolean containsBeanDefinition(String name);\n}\n</code></pre><p>随后调整BeanFactory，新增Singleton、Prototype的判断，获取Bean的类型。</p><pre><code class=\"language-java\">public interface BeanFactory {\n&nbsp; &nbsp; Object getBean(String name) throws BeansException;\n&nbsp; &nbsp; boolean containsBean(String name);\n&nbsp; &nbsp; boolean isSingleton(String name);\n&nbsp; &nbsp; boolean isPrototype(String name);\n&nbsp; &nbsp; Class&lt;?&gt; getType(String name);\n}\n</code></pre><p>通过代码可以看到，我们让SimpleBeanFactory实现了BeanDefinitionRegistry，这样SimpleBeanFactory既是一个工厂同时也是一个仓库，你可以看下调整后的部分代码。</p><pre><code class=\"language-java\">public class SimpleBeanFactory extends DefaultSingletonBeanRegistry implements BeanFactory, BeanDefinitionRegistry{\n    private Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256);\n    private List&lt;String&gt; beanDefinitionNames = new ArrayList&lt;&gt;();\n\n    public void registerBeanDefinition(String name, BeanDefinition beanDefinition) {\n        this.beanDefinitionMap.put(name, beanDefinition);\n        this.beanDefinitionNames.add(name);\n        if (!beanDefinition.isLazyInit()) {\n            try {\n                getBean(name);\n            } catch (BeansException e) {\n            }\n        }\n    }\n    public void removeBeanDefinition(String name) {\n        this.beanDefinitionMap.remove(name);\n        this.beanDefinitionNames.remove(name);\n        this.removeSingleton(name);\n    }\n    public BeanDefinition getBeanDefinition(String name) {\n        return this.beanDefinitionMap.get(name);\n    }\n    public boolean containsBeanDefinition(String name) {\n        return this.beanDefinitionMap.containsKey(name);\n    }\n    public boolean isSingleton(String name) {\n        return this.beanDefinitionMap.get(name).isSingleton();\n    }\n    public boolean isPrototype(String name) {\n        return this.beanDefinitionMap.get(name).isPrototype();\n    }\n    public Class&lt;?&gt; getType(String name) {\n        return this.beanDefinitionMap.get(name).getClass();\n    }\n}\n</code></pre><p>修改完BeanFactory这个核心之后，上层对应的 ClassPathXmlApplicationContext部分作为外部集成包装也需要修改。</p><pre><code class=\"language-java\">public class ClassPathXmlApplicationContext implements BeanFactory,&nbsp;\nApplicationEventPublisher{\n&nbsp; &nbsp; public void publishEvent(ApplicationEvent event) {\n&nbsp; &nbsp; }\n&nbsp; &nbsp; public boolean isSingleton(String name) {\n&nbsp; &nbsp; &nbsp; &nbsp; return false;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; public boolean isPrototype(String name) {\n&nbsp; &nbsp; &nbsp; &nbsp; return false;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; public Class&lt;?&gt; getType(String name) {\n&nbsp; &nbsp; &nbsp; &nbsp; return null;\n&nbsp; &nbsp; }\n}\n</code></pre><h2>小结</h2><p><img src=\"https://static001.geekbang.org/resource/image/48/8d/4868fb2cc4f11bd1e578c9c68430d58d.jpg?wh=3736x2085\" alt=\"\"></p><p>这节课，我们模仿Spring构造了单例Bean，还增加了容器事件监听处理，完善了BeanDefinition的属性。此外，参照Spring的实现，我们增加了一些有用的特性，例如lazyInit，initMethodName等等，BeanFactory也做了相应的修改。同时，我们还提前为构造器注入、Setter注入提供了基本的实例类，这为后面实现上述两种依赖注入方式提供了基础。</p><p>通过对上一节课原始IoC容器的扩展和丰富，它已经越来越像Spring框架了。</p><p>完整源代码参见 <a href=\"https://github.com/YaleGuo/minis\">https://github.com/YaleGuo/minis</a></p><h2>课后题</h2><p>学完这节课，我也给你留一道思考题。你认为构造器注入和Setter注入有什么异同？它们各自的优缺点是什么？欢迎你在留言区与我交流讨论，也欢迎你把这节课分享给需要的朋友。我们下节课见！</p>","neighbors":{"left":{"article_title":"01｜原始IoC：如何通过BeanFactory实现原始版本的IoC容器？","id":638222},"right":{"article_title":"03｜依赖注入：如何给Bean注入值并解决循环依赖问题？","id":640085}},"comments":[{"had_liked":false,"id":371126,"user_name":"姐姐","can_delete":false,"product_type":"c1","uid":3021628,"ip_address":"浙江","ucode":"1A615FA9B453DE","user_header":"https://static001.geekbang.org/account/avatar/00/2e/1b/3c/9c5fc55f.jpg","comment_is_top":false,"comment_ctime":1679561661,"is_pvip":false,"replies":[{"id":135401,"content":"赞！你的笔记好好整理，可以对大家分享了。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679607201,"ip_address":"澳大利亚","comment_id":371126,"utype":1}],"discussion_count":5,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"这节课的类开始爆炸了，一开始看得很没头绪，但是俗话说“书读百遍，其义自见”，俗话很有道理，最后决定从simpleBeanFactory和ClassPathXmlApplicationContext两个角度，总结一下自己的理解和感悟，当做是自己的笔记：1. 从SimpleBeanFactory的角度看，首先理理三个接口BeanFactory、BeanDefinitionRegistry、SingletonBeanRegistry，对于这三个接口，其中BeanFactory、BeanDefinitionRegistry是由SimpleBeanFactory直接实现的，而对于SingletonBeanRegistry，SimpleBeanFactory继承了它的实现类DefaultSingletonBeanRegistry，起初我很疑惑，为什么SimpleBeanFactory不同时声明实现SingletonBeanRegistry并且继承它的默认实现类呢，但是后来想想也许SimpleBeanFactory对外只希望外界知道自己是一个beanFactory和beanDefinitionRegistry，至于singletonBeanRegistry，它只希望作为一种内部的能力来使用，所以继承一个已经实现的类来拥有能力，但是声明接口的时候不声明这个接口。理清了这三个以后，再来看看内部的细节逻辑，SimpleBeanFactory的registerBeanDefinition方法中每注册一个beanDefinition，如果不是懒加载的就立刻调用getBean，而getBean方法会从SimpleBeanFactory继承的DefaultSingletonBeanRegistry能力中判断bean是否存，不存在创建并注册进DefaultSingletonBeanRegistry。2.ClassPathXmlApplicationContext  它的组装逻辑和上一节一样，但是现在XmlBeanDefinitionReader在遍历resource向simplebeanfactory注册的时候，由于simplebeanfactory注册时候会创建非懒bean,所以现在applicationContext启动的时候就会创建所有非懒加载bean，上一节课的容器创建完并不会创建bean,要到获取bean的时候才创建bean，对getBean方法的调用提前到注册beanDefinition的时候了；ClassPathXmlApplicationContext实现了ApplicationEventPublisher，所以可以猜测以后容器不仅是容器，还兼具发布事件的功能。 这节课最大收获是加深了对实现接口和继承类的理解，如果一个类声明它实现了某个接口，那么它偏向于告诉外部它是那个接口，你可以把它当成那个接口来用，如果一个类继承了某个实现类，这时候也可以把它当成这个实现类来用，但是我想它更偏向于获得该实现类的能力，如果它既想获得能力又想对外提供能力，那么它可以同时声明实现接口和继承接口的某些实现类，再自己修改增强某些方法。","like_count":36,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":610533,"discussion_content":"赞！你的笔记好好整理，可以对大家分享了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679607202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1155275,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","nickname":"张三丰","note":"","ucode":"3A6215A40B3B21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":614739,"discussion_content":"其实SimpleBeanFactory完全没必要告诉外界它也是BeanDefinitionRegistry“仓库”，它应该告诉外界它就是一个BeanFactory“工厂”就足够了，然后再将BeanDefinitionRegistry作为SimpleBeanFactory中的一个属性，利用组合关系，放弃继承关系，这样从结构上更容易让人接受，纯属个人理解。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1681892124,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1080653,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7d/4d/d98865b2.jpg","nickname":"老实人Honey","note":"","ucode":"EA4AB5C0C33090","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1155275,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","nickname":"张三丰","note":"","ucode":"3A6215A40B3B21","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":625739,"discussion_content":"组合优于继承——在其他语言中就是推崇这样子的方式的。看了好几遍Spring的源码，被他的继承体系搞到心累了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1692118991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":614739,"ip_address":"广东","group_id":0},"score":625739,"extra":""}]},{"author":{"id":3187242,"avatar":"","nickname":"Geek_2493f9","note":"","ucode":"C577130194DCFA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":650464,"discussion_content":"优秀呀我的哥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1725039225,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1190060,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/ac/37a2a265.jpg","nickname":"弱水穿云天","note":"","ucode":"80DC528A23ED7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":613305,"discussion_content":"每次看评论收获很大！这也是鞭策自己的方式，自己也顺着去总结这些依赖关系，能力等等！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681262758,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370596,"user_name":"咕噜咕噜","can_delete":false,"product_type":"c1","uid":2822832,"ip_address":"上海","ucode":"852A797378EEED","user_header":"https://static001.geekbang.org/account/avatar/00/2b/12/b0/63f71163.jpg","comment_is_top":false,"comment_ctime":1679016606,"is_pvip":false,"replies":[{"id":135238,"content":"赞一个","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679047564,"ip_address":"澳大利亚","comment_id":370596,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"构造器注入：适合于强制依赖，适合在创建对象的同时必须要初始化的变量。但是要注入的依赖多了可能构造器会相对臃肿；循环依赖问题无法有效解决，会在启动的时候报错。\nsetter注入：适合于可选依赖，当没有提供它们时，类应该能够正常工作。相对更加灵活，可以多次调用，循环依赖问题spring可以通过三级缓存解决。","like_count":10,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609604,"discussion_content":"赞一个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679047564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370579,"user_name":"聪聪不匆匆","can_delete":false,"product_type":"c1","uid":1360095,"ip_address":"上海","ucode":"86CD1D2D85B8CA","user_header":"https://static001.geekbang.org/account/avatar/00/14/c0/df/d52e7244.jpg","comment_is_top":false,"comment_ctime":1678976534,"is_pvip":false,"replies":[{"id":135214,"content":"好建议。课程发布完之后，我们增强一下。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679005365,"ip_address":"澳大利亚","comment_id":370579,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"老师可以将每一章的各个类之间UML关系提供一下吗 方便学习缕清楚创建过程 和 各个组件依赖关系 谢谢老师","like_count":8,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609509,"discussion_content":"好建议。课程发布完之后，我们增强一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679005365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1032755,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c2/33/ccbf2045.jpg","nickname":"sta","note":"","ucode":"D840070850EA5B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":610716,"discussion_content":"自己捋一下可能比直接提供的更清晰","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1679707070,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370715,"user_name":"陈小远","can_delete":false,"product_type":"c1","uid":2393550,"ip_address":"四川","ucode":"8C348A5FA8F539","user_header":"https://static001.geekbang.org/account/avatar/00/24/85/ce/df1c7a91.jpg","comment_is_top":false,"comment_ctime":1679127799,"is_pvip":false,"replies":[{"id":135274,"content":"Github上有十几个分支，差不多是跟每一节可以对上的。你不要只看master分支，那个是最终的样子。具体到你这一部分，可以看ioc分支。好多人不注意Github上有多个分支，我很意外。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679222722,"ip_address":"澳大利亚","comment_id":370715,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"这节课在内容上能看懂，但是在编码实操的时候有些难受——老师的源码都是完成品，而课件中并没有给出满足当前进度的可运行代码，一些迭代性的改动也并没有顾及会对其它部分实现的影响，比如BeanFactory中registerBean突然没有了，导致跟进课程实操方面有点打脑壳","like_count":6,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609810,"discussion_content":"Github上有十几个分支，差不多是跟每一节可以对上的。你不要只看master分支，那个是最终的样子。具体到你这一部分，可以看ioc分支。好多人不注意Github上有多个分支，我很意外。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1679222722,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3216356,"avatar":"https://static001.geekbang.org/account/avatar/00/31/13/e4/68e481a0.jpg","nickname":"郭新宇","note":"","ucode":"9EFFCDE90D6095","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609787,"discussion_content":"https://www.github.com/YaleGuo/minis。\n可以配合老师github😁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679212555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"山东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":375736,"user_name":"爱学习的王呱呱","can_delete":false,"product_type":"c1","uid":2962972,"ip_address":"北京","ucode":"F6703C9B1FE6DF","user_header":"https://static001.geekbang.org/account/avatar/00/2d/36/1c/adfeb6c4.jpg","comment_is_top":false,"comment_ctime":1685933677,"is_pvip":false,"replies":[{"id":137132,"content":"这个问题好也难，我试着说一下我的思考。\nJava并发容器ConcurrentHashMap，它只是保证容器本身的并发控制，对同一个bucket，会保证存取时的原子性和并发控制。但是，它只是这个容器层面的，扩大到业务逻辑，可能由多个操作组成，业务操作上对同一个key值的业务数据在同时读写，这个业务逻辑层面的并发控制仍然还是要由我们自己来控制的。\n最简单的控制就是直接在业务操作上加上synchronized，这样只有一个维护线程，SpringCache的sync属性也是这么处理的。但是这样并发性又降低了，相当于整个操作都排他了。用ReentrantReadWriteLock也不行，这只是读写分开了，整个锁的范围仍然是整个数据而不是某个key值。\n所以实际工程中需要考虑颗粒度更加精细的加锁：只对同一个key加锁，key之间互不影响。可以这么考虑：\n除了ConcurrentHashMap存储数据之外，再用一个ConcurrentHashMap单独存储锁，如&lt;key, Object&gt;,(注意：Java中的锁时所在对象上的，所以我们随便用一个Object就可以当锁)。进行业务操作的时候，从locl map中先拿锁，然后用synchronized(lock){}将业务操作包起来保证并发安全和原子性。\n分布式事务Seata的一段代码可以借鉴：\n在NettyClientChannelManager类中，定义了数据及锁的map：\nprivate final ConcurrentMap&lt;String, Object&gt; channelLocks = new ConcurrentHashMap&lt;&gt;();\n    private final ConcurrentMap&lt;String, Channel&gt; channels = new ConcurrentHashMap&lt;&gt;();\n\n然后有一个方法这么写的：\n    void releaseChannel(Channel channel, String serverAddress) {\n        if (channel == null || serverAddress == null) { return; }\n        try {\n            synchronized (channelLocks.get(serverAddress)) {\n                Channel ch = channels.get(serverAddress);\n                if (ch == null) {\n                    nettyClientKeyPool.returnObject(poolKeyMap.get(serverAddress), channel);\n                    return;\n                }\n                if (ch.compareTo(channel) == 0) {\n                    if (LOGGER.isInfoEnabled()) {\n                        LOGGER.info(&quot;return to pool, rm channel:{}&quot;, channel);\n                    }\n                    destroyChannel(serverAddress, channel);\n                } else {\n                    nettyClientKeyPool.returnObject(poolKeyMap.get(serverAddress), channel);\n                }\n            }\n        } catch (Exception exx) {\n            LOGGER.error(exx.getMessage());\n        }\n    }\n\n关键是注意这两行：\n            synchronized (channelLocks.get(serverAddress)) {\n                Channel ch = channels.get(serverAddress);\n先从锁map中获取锁，在这个细对象上synchronized，然后再获取数据。\n这样的控制就精细了。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1685949998,"ip_address":"澳大利亚","comment_id":375736,"utype":1}],"discussion_count":7,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"老师好，有点没理解 synchronized + ConcurrentHashMap 同时使用的意义。\n我理解HashMap在多线程下的问题有两个 1. 不同key但是相同hashcode会造成元素覆盖；2. 死循环。但是ConcurrentHashMap不存在这个问题了，为什么还需要synchronized呢。","like_count":5,"discussions":[{"author":{"id":2962972,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/36/1c/adfeb6c4.jpg","nickname":"爱学习的王呱呱","note":"","ucode":"F6703C9B1FE6DF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":620387,"discussion_content":"老师，我想我理解一些了。我觉得原因在于是才操作两个collection:\n\nprotected List beanNames = new ArrayList&lt;&gt;(); \nprotected Map singletons = new ConcurrentHashMap&lt;&gt;(256);\n...\nsynchronized (this.singletons) { \n    this.beanNames.remove(beanName); \n    this.singletons.remove(beanName); \n}\n\n即使 beanNames 和 singletons 都是线程安全的数据结构，这个操作只能保证线程安全，但是不能保证原子性，因为毕竟是两个操作，所以可以用synchronized。\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1686127001,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":2962972,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/36/1c/adfeb6c4.jpg","nickname":"爱学习的王呱呱","note":"","ucode":"F6703C9B1FE6DF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":620419,"discussion_content":"是你理解的这样的。 miniSpring不是工业级的，是讲解结构原理，这一块简化了，不对单独的key加锁，而是直接加到整个map上了，这么写简化了，或者说偷懒了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1686144020,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":620387,"ip_address":"澳大利亚","group_id":0},"score":620419,"extra":""}]},{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":620211,"discussion_content":"这个问题好也难，我试着说一下我的思考。\nJava并发容器ConcurrentHashMap，它只是保证容器本身的并发控制，对同一个bucket，会保证存取时的原子性和并发控制。但是，它只是这个容器层面的，扩大到业务逻辑，可能由多个操作组成，业务操作上对同一个key值的业务数据在同时读写，这个业务逻辑层面的并发控制仍然还是要由我们自己来控制的。\n最简单的控制就是直接在业务操作上加上synchronized，这样只有一个维护线程，SpringCache的sync属性也是这么处理的。但是这样并发性又降低了，相当于整个操作都排他了。用ReentrantReadWriteLock也不行，这只是读写分开了，整个锁的范围仍然是整个数据而不是某个key值。\n所以实际工程中需要考虑颗粒度更加精细的加锁：只对同一个key加锁，key之间互不影响。可以这么考虑：\n除了ConcurrentHashMap存储数据之外，再用一个ConcurrentHashMap单独存储锁，如&lt;key, Object&gt;,(注意：Java中的锁时所在对象上的，所以我们随便用一个Object就可以当锁)。进行业务操作的时候，从locl map中先拿锁，然后用synchronized(lock){}将业务操作包起来保证并发安全和原子性。\n分布式事务Seata的一段代码可以借鉴：\n在NettyClientChannelManager类中，定义了数据及锁的map：\nprivate final ConcurrentMap&lt;String, Object&gt; channelLocks = new ConcurrentHashMap&lt;&gt;();\n    private final ConcurrentMap&lt;String, Channel&gt; channels = new ConcurrentHashMap&lt;&gt;();\n\n然后有一个方法这么写的：\n    void releaseChannel(Channel channel, String serverAddress) {\n        if (channel == null || serverAddress == null) { return; }\n        try {\n            synchronized (channelLocks.get(serverAddress)) {\n                Channel ch = channels.get(serverAddress);\n                if (ch == null) {\n                    nettyClientKeyPool.returnObject(poolKeyMap.get(serverAddress), channel);\n                    return;\n                }\n                if (ch.compareTo(channel) == 0) {\n                    if (LOGGER.isInfoEnabled()) {\n                        LOGGER.info(&#34;return to pool, rm channel:{}&#34;, channel);\n                    }\n                    destroyChannel(serverAddress, channel);\n                } else {\n                    nettyClientKeyPool.returnObject(poolKeyMap.get(serverAddress), channel);\n                }\n            }\n        } catch (Exception exx) {\n            LOGGER.error(exx.getMessage());\n        }\n    }\n\n关键是注意这两行：\n            synchronized (channelLocks.get(serverAddress)) {\n                Channel ch = channels.get(serverAddress);\n先从锁map中获取锁，在这个细对象上synchronized，然后再获取数据。\n这样的控制就精细了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1685949998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2962972,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/36/1c/adfeb6c4.jpg","nickname":"爱学习的王呱呱","note":"","ucode":"F6703C9B1FE6DF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":620385,"discussion_content":"感谢老师百忙之中的详尽回答。我也谈谈我的看法哈。\n\n1）文稿中的 synchronized 直接锁在 this.singletons 上感觉还是全部排他了，是不是应该和Seata中的那种方，把锁放在单个key的对象上，比如 this.singletons.getOrDefault(beanName, defaultMutex)，其中 defaultMutex 是提前声明的一个Object对象用于放锁。\n\n2）假设确实1）中的方法可行，那么是不是不需要用ConcurrentHashMap，因为synchronize + hashMap就已经能保证操作安全了。\n\n3）如果 2）成立，那么是不是等同于用HashSet或Collections#SynchronizedMap这样的数据结构了（当然也是整个读、写操作全部排他，并不是相同的key排他，性能上会有降低）。\n\n4）如果 3）成立，那既然HashSet能保证操作安全，为什么单独使用ConcurrentHashMap就不能保证了呢。\n\n当然我的观点还是，不管业务操作如何触发，既然ConcurrentHashMap在底层上保证了线程安全，那么就一定不会有问题。当然以上是我粗浅的观点，希望老师可以继续探讨和指教。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1686126088,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":620211,"ip_address":"新加坡","group_id":0},"score":620385,"extra":""}]},{"author":{"id":1102490,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d2/9a/d56bb650.jpg","nickname":"多多","note":"","ucode":"DA5AF8146AEF82","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631774,"discussion_content":"老师好，为什么用了synchronized之后，不用HashMap，而是用ConcurrentHashMap呢？包括我看spring源码，没上锁的操作只有get，为什么不用HashMap呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699949692,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1747803,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/ab/5b/eb3983f0.jpg","nickname":"liuchao90h","note":"","ucode":"30A89E766EED2B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":620409,"discussion_content":"我一开始还以为是不是我漏了什么细节，看完老师的例子之后，我确定那个synchronized加了是没有意义和作用的，老师的例子是因为需要释放来源于两个map的值，存在判断，为避免误判而导致的错误释放而存在的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1686138138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1747803,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/ab/5b/eb3983f0.jpg","nickname":"liuchao90h","note":"","ucode":"30A89E766EED2B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":620422,"discussion_content":"你的确定并不正确。两个map中，一个locks map并不是数据，而是专用于将锁控制到每一个key值的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1686144626,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":620409,"ip_address":"澳大利亚","group_id":0},"score":620422,"extra":""}]}]},{"had_liked":false,"id":371870,"user_name":"Geek_e298ce","can_delete":false,"product_type":"c1","uid":2028431,"ip_address":"北京","ucode":"ABD83935F43A5B","user_header":"","comment_is_top":false,"comment_ctime":1680449800,"is_pvip":false,"replies":[{"id":135653,"content":"角色分离。一个是工厂，另一个是仓库。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1680499747,"ip_address":"澳大利亚","comment_id":371870,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"有一个问题不太明白, 为什么要有BeanFactory和SingletonBeanRegistry这两个接口呢","like_count":4,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612040,"discussion_content":"角色分离。一个是工厂，另一个是仓库。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1680499747,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1190060,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/ac/37a2a265.jpg","nickname":"弱水穿云天","note":"","ucode":"80DC528A23ED7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":615428,"discussion_content":"精髓","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1682258146,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":612040,"ip_address":"上海","group_id":0},"score":615428,"extra":""}]},{"author":{"id":1318633,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJhxtIyXX4icMNAq5zEvchKYS3q7fwZXA3h7yV80iaibCRXniaLW95OnPC8PM2h5Ja5ibpkJ1VJowicqKZA/132","nickname":"Geek_7jwpfc","note":"","ucode":"CBCEA76E9EF33B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":616586,"discussion_content":"可以理解为是按接口编程, BeanFactory接口负责Bean的获取，SingletonBeanRegistry接口负责Bean的存储，一个类同时实现这两个接口，就有完整的IOC实现，例如Spring中的DefaultListableBeanFactory；","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1682961092,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"湖南","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":377245,"user_name":"故作","can_delete":false,"product_type":"c1","uid":2629208,"ip_address":"浙江","ucode":"F0E0238DED7AF9","user_header":"https://static001.geekbang.org/account/avatar/00/28/1e/58/2bfb3da0.jpg","comment_is_top":false,"comment_ctime":1688124458,"is_pvip":true,"replies":[{"id":137488,"content":"感谢指教。github的docs目录下有一个readme文件，里面有说明29天里一天天的演变，说的每一小步都能运行是指这个。后来出这个专栏的时候，因为有篇幅的硬性要求，强行合并了章节，为了外在形式确实造成了文本，逻辑和代码有某些对不上的地方。建议仔细看github代码，坚持一下，看完的人大多数反馈还是觉得很有收获的，当年线下给合肥工大和中南大学本科生研究生讲课的时候，大家也是觉得收获蛮大的。“牢骚太盛防肠断，风物长宜放眼量。莫道昆明池水浅，观鱼胜过富春江。”","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1688249764,"ip_address":"澳大利亚","comment_id":377245,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"感觉代码真的贴的不是很用心，看专栏里的代码，会觉得有些东西莫名其妙，以至于一头雾水，然后去看git上的代码，发现是没有这一看不懂的内容的。蛮气愤的，明明开篇词里说每一小步都是可运行的，结果，从这一章开始，就不行了。能理解无法把所有代码都放里边，但是，因为开篇词里的这句话，导致白白浪费了很多时间。这一章，质量真的很低，很不用心","like_count":3,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":622415,"discussion_content":"感谢指教。github的docs目录下有一个readme文件，里面有说明29天里一天天的演变，说的每一小步都能运行是指这个。后来出这个专栏的时候，因为有篇幅的硬性要求，强行合并了章节，为了外在形式确实造成了文本，逻辑和代码有某些对不上的地方。建议仔细看github代码，坚持一下，看完的人大多数反馈还是觉得很有收获的，当年线下给合肥工大和中南大学本科生研究生讲课的时候，大家也是觉得收获蛮大的。“牢骚太盛防肠断，风物长宜放眼量。莫道昆明池水浅，观鱼胜过富春江。”","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1688249764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1786951,"avatar":"","nickname":"Geek_50a5cc","note":"","ucode":"0F6C1C2552261F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634010,"discussion_content":"我觉得还是需要自己主动去梳理代码的思路，运行的形式不是重要的；其实如果遇到了一些困惑，只是说明理解的有一些而偏差，再多看两遍，实际梳理下代码，自然都是可以运行的，不过这本身可能就需要一些编程经验","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702894247,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370455,"user_name":"浅行","can_delete":false,"product_type":"c1","uid":3567438,"ip_address":"山东","ucode":"E46560808902FC","user_header":"https://static001.geekbang.org/account/avatar/00/36/6f/4e/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1678845677,"is_pvip":false,"replies":[{"id":135115,"content":"你提前想到了，很专业，赞！\n后面一步步演变了，最后是：\n\tpublic XmlBeanDefinitionReader(AbstractBeanFactory bf) {\n\t\tthis.bf = bf;\n\t}","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1678854446,"ip_address":"澳大利亚","comment_id":370455,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"郭老师，有个地方不太理解，经过前面的一些设计，XmlBeanDefinitionReader构造方法不得不将BeanFactory改为实现类SimpleBeanFactory，这样可扩展性是否就变差了呢？如果实际开发中遇到这种情况有什么好的解决思路吗？请郭老师指点一下，谢谢","like_count":3,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609167,"discussion_content":"你提前想到了，很专业，赞！\n后面一步步演变了，最后是：\n\tpublic XmlBeanDefinitionReader(AbstractBeanFactory bf) {\n\t\tthis.bf = bf;\n\t}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678854446,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":374344,"user_name":"__@Wong","can_delete":false,"product_type":"c1","uid":1422756,"ip_address":"广东","ucode":"A54A5FC672F23D","user_header":"https://static001.geekbang.org/account/avatar/00/15/b5/a4/67d6e3cb.jpg","comment_is_top":false,"comment_ctime":1683967781,"is_pvip":false,"replies":[{"id":136693,"content":"是这样的。就是这个定位。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1684020728,"ip_address":"澳大利亚","comment_id":374344,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"看了两节，这个课程对于缺少基础的人来说有一定的难度。本课程对学习者来说需要对Spring, 设计模式准则以及常用设计模式有一定的基础，并有一定代码设计功底。如果想要通过本课程学习企业Spring开发，不太建议，不如看Spring的书籍更来得有效。如果想要学习下Spring的设计，本课程非常适用。","like_count":2,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":618005,"discussion_content":"是这样的。就是这个定位。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1684020728,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370870,"user_name":"未聞花名","can_delete":false,"product_type":"c1","uid":2142672,"ip_address":"北京","ucode":"8BE87AC2CEA286","user_header":"https://static001.geekbang.org/account/avatar/00/20/b1/d0/8c94d49e.jpg","comment_is_top":false,"comment_ctime":1679325734,"is_pvip":false,"replies":[{"id":135316,"content":"后面会加上的。感谢建议。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679370062,"ip_address":"澳大利亚","comment_id":370870,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"老师贴代码可以保留下包名，或者脑图里的类可以带上包名，这样可以按着思路写，不用去翻github的代码了","like_count":2,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":610061,"discussion_content":"后面会加上的。感谢建议。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679370062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":375069,"user_name":"KernelStone","can_delete":false,"product_type":"c1","uid":2736140,"ip_address":"广东","ucode":"B75C0100AD52B8","user_header":"https://static001.geekbang.org/account/avatar/00/29/c0/0c/f726d4d0.jpg","comment_is_top":false,"comment_ctime":1684857778,"is_pvip":false,"replies":[{"id":136890,"content":"用心了！","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1684905827,"ip_address":"澳大利亚","comment_id":375069,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"我找到的一条主线是这样的。beans.xml -&gt; AServiceImpl -&gt; ArgumentValue &amp; PropertyValue -&gt; ArgumentValues &amp; PropertyValues -&gt; BeanDefinition -&gt; BeanDefinitionRegistry -&gt; XmlBeanDefinitionReader -&gt; BeanFactory -&gt; SingletonBeanRegistry -&gt; DefaultSingletonBeanRegistry -&gt; SimpleBeanFactory。主要还是围绕着扩充Bean定义，属性注入去完成的，这个顺序看下来比较好理解。其余的就是ApplicationEvent +ApplicationEventPublisher预留事件监听机制的扩展点、和重新组装ClassPathXmlApplicationContext。\n\n当然同学们评论很精彩，学到了一些代码细节。再次感谢。\n\n","like_count":1,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":619231,"discussion_content":"用心了！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1684905827,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":372947,"user_name":"Fiftten2001","can_delete":false,"product_type":"c1","uid":3586465,"ip_address":"浙江","ucode":"FE50A84B4C79ED","user_header":"https://static001.geekbang.org/account/avatar/00/36/b9/a1/cf741eca.jpg","comment_is_top":false,"comment_ctime":1681835199,"is_pvip":false,"replies":[{"id":136292,"content":"单例肯定是指每次拿的singleton是同一份，这点确定无疑的。你说的多线程的时候new instance会有多个对象是正确的，这个地方要加上同步。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1681908272,"ip_address":"澳大利亚","comment_id":372947,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"更改一下我的问题，singleton = Class.forName(beanDefinition.getClassName()).newInstance();这行代码在多线程情况下还是会生成多个对象的吧，这样的话单例是指单例了什么，如果是说get的时候每次都拿到的是同一个singleton，synchronized和concurrent保证了不会在多线程情况下，put或者remove发生导致的运行时崩溃，但是前后两次访问返回的singleton可能并不是同一个吧，这时候是不是应该在synchronized代码块中再次判断是否已经有了beanName对应的singletonObject然后再执行put和add","like_count":1,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":614794,"discussion_content":"单例肯定是指每次拿的singleton是同一份，这点确定无疑的。你说的多线程的时候new instance会有多个对象是正确的，这个地方要加上同步。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681908272,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":372946,"user_name":"Fiftten2001","can_delete":false,"product_type":"c1","uid":3586465,"ip_address":"浙江","ucode":"FE50A84B4C79ED","user_header":"https://static001.geekbang.org/account/avatar/00/36/b9/a1/cf741eca.jpg","comment_is_top":false,"comment_ctime":1681833927,"is_pvip":false,"replies":[{"id":136291,"content":"初始化的时候，没有并发的问题。但是考虑今后有refresh，可以在运行时再刷新，可能是多线程的，需要考虑并发。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1681908100,"ip_address":"澳大利亚","comment_id":372946,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"疑惑的是上一讲中，Bean实例本就是注册进hashMap的，即BeanFactory的singletons中本就由beanDefinition的id和classpath构成key和value，无论加不加synchronized不都是只有一个么...（菜鸡大学生，如果问题太蠢，请轻点嘲笑，望解惑）","like_count":1,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":614793,"discussion_content":"初始化的时候，没有并发的问题。但是考虑今后有refresh，可以在运行时再刷新，可能是多线程的，需要考虑并发。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681908100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1422756,"avatar":"https://static001.geekbang.org/account/avatar/00/15/b5/a4/67d6e3cb.jpg","nickname":"__@Wong","note":"","ucode":"A54A5FC672F23D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":617888,"discussion_content":"Spring不只有单例模式，还有多例模式。我觉得是想要两种模式的实现分开，BeanFactory剥离职责，使用专门的实现Registry。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1683966646,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370865,"user_name":"瓜瓜王几","can_delete":false,"product_type":"c1","uid":1621553,"ip_address":"广东","ucode":"93447D86C450D6","user_header":"https://static001.geekbang.org/account/avatar/00/18/be/31/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1679322424,"is_pvip":false,"replies":[{"id":135315,"content":"用心了。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679370028,"ip_address":"澳大利亚","comment_id":370865,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"第二章代码看了3天，终于这一波算是看懂理解了，DefaultSingletonBeanRegistry将第一章中SimpleBeanFactory里面保存的singletons拆分出来管理了，用于存储真正的Bean对象(beanName,Object)，SimpleBeanFactory仅保存createBean，containsBean等和Bean操作相关的内容，其余相比第一章就是多了setter注入和构造器注入的内容，老师的代码并不复杂，自己还是要多多努力，认真看还是能看懂滴~~~开心.jpg","like_count":1,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":610060,"discussion_content":"用心了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679370028,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370459,"user_name":"浅行","can_delete":false,"product_type":"c1","uid":3567438,"ip_address":"山东","ucode":"E46560808902FC","user_header":"https://static001.geekbang.org/account/avatar/00/36/6f/4e/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1678847362,"is_pvip":false,"replies":[{"id":135105,"content":"是少了东西，估计是修改文稿过程中手误删掉了，就是把property换成constructor-arg。感谢指出。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1678853459,"ip_address":"澳大利亚","comment_id":370459,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"发现了个小问题，配置构造器注入章节下：\n与 Setter 注入类似，我们只是把标签换成了标签\n这里好像少了点什么","like_count":1,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609157,"discussion_content":"是少了东西，估计是修改文稿过程中手误删掉了，就是把property换成constructor-arg。感谢指出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678853459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2843479,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/63/57/cba4c68b.jpg","nickname":"小虎子🐯","note":"","ucode":"4C9530B3FB407B","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609208,"discussion_content":"感谢浅行同学反馈，查看了下原因，有&lt;&gt;符号时，后台就不显示符号里的内容了，刚刚已手动手动添加，多谢提醒哦^_^","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678871922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"河北","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":388643,"user_name":"且将新火试新茶～","can_delete":false,"product_type":"c1","uid":1547839,"ip_address":"北京","ucode":"F8FD956CF07B14","user_header":"https://static001.geekbang.org/account/avatar/00/17/9e/3f/00109670.jpg","comment_is_top":false,"comment_ctime":1710568286,"is_pvip":false,"replies":[{"id":141498,"content":"是要结合代码。课程文本不会将每一个细节讲出来。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1710751548,"ip_address":"澳大利亚","comment_id":388643,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"确实在敲代码过层中遇到了很多阻塞点，要结合作者的代码来看，另外按照作者的步骤来敲，最好是一段就运行一下，缩小问题范围，保证程序能正常运行。不然最后敲完完全没有头绪，不知道从哪里去排查。","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":639530,"discussion_content":"是要结合代码。课程文本不会将每一个细节讲出来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1710751548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":388642,"user_name":"且将新火试新茶～","can_delete":false,"product_type":"c1","uid":1547839,"ip_address":"北京","ucode":"F8FD956CF07B14","user_header":"https://static001.geekbang.org/account/avatar/00/17/9e/3f/00109670.jpg","comment_is_top":false,"comment_ctime":1710568189,"is_pvip":false,"replies":[{"id":141499,"content":"自己总结的很好","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1710751582,"ip_address":"澳大利亚","comment_id":388642,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"这节主要是：\n1. 新增了单例模式。registerBeanDefinition 这个方法把实例放入beanDefinitionMap中，第一次get是从这个map中拿出来的，然后放入单例的map中进行管理了。个人理解SingletonBeanRegistry只是帮我们管理单例的仓库，初始化的时候这个里面是没有值的，感觉它类似于一个缓存\n2.BeanDefinition的类属性做了扩展\n3. 为构造方法和setter注入属性做了一些准备工作\n\n这节代码敲完之后，应该保证：\n1. 程序能正常启动\n2.aService.sayHello(); 方法调用结果是null,null","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":639531,"discussion_content":"自己总结的很好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1710751582,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":388614,"user_name":"jhren","can_delete":false,"product_type":"c1","uid":1596987,"ip_address":"美国","ucode":"60F7CCEA1E2C88","user_header":"https://static001.geekbang.org/account/avatar/00/18/5e/3b/845fb641.jpg","comment_is_top":false,"comment_ctime":1710483252,"is_pvip":false,"replies":[{"id":141497,"content":"用心了","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1710751501,"ip_address":"澳大利亚","comment_id":388614,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"仔细研究了下，Bean的property是没有type的，通过setter的参数推断出类型。\n这段代码没有type跟Spring是一致的。\npublic class PropertyValue {\n    private final String name;\n    private final Object value;\n}\nXML里面的type在Spring里是不合法的\n&lt;beans&gt;\n    &lt;bean id=&quot;aservice&quot; class=&quot;com.minis.test.AServiceImpl&quot;&gt;\n        &lt;property type=&quot;String&quot; name=&quot;property1&quot; value=&quot;Hello World!&quot;&#47;&gt;\n    &lt;&#47;bean&gt;\n&lt;&#47;beans&gt;","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":639529,"discussion_content":"用心了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1710751501,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386382,"user_name":"1184507801","can_delete":false,"product_type":"c1","uid":1141923,"ip_address":"广东","ucode":"930E2F79C5582A","user_header":"https://static001.geekbang.org/account/avatar/00/11/6c/a3/7d60e2a0.jpg","comment_is_top":false,"comment_ctime":1704722607,"is_pvip":false,"replies":[{"id":140892,"content":"你多试几次，国内访问Github不稳定。我后面的MiniTomcat课程让助手搬到国内的Gitee了","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1705023724,"ip_address":"澳大利亚","comment_id":386382,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"老师源码地址进不了","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635648,"discussion_content":"你多试几次，国内访问Github不稳定。我后面的MiniTomcat课程让助手搬到国内的Gitee了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705023724,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":375056,"user_name":"我想我是海","can_delete":false,"product_type":"c1","uid":1901695,"ip_address":"福建","ucode":"8FB2E63ABE1D15","user_header":"https://static001.geekbang.org/account/avatar/00/1d/04/7f/c4ce690c.jpg","comment_is_top":false,"comment_ctime":1684848196,"is_pvip":false,"replies":[{"id":136892,"content":"你说的对。后面会改掉，Simple不再用了，你慢慢往后看。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1684905924,"ip_address":"澳大利亚","comment_id":375056,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"老师你好我有一个疑问，此时的DefaultSingletonBeanRegistry中不是有 beanNames 来存储所有bean的名称了吗？ 它被SimpleBeanFactory继承了。 但这节的代码中 SimpleBeanFactory 又自己声明了一个 beanDefinitionNames 也是来存放bean的所有的名称的。 这两个是继承关系，这属性列表功能不重复了吗？","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":619233,"discussion_content":"你说的对。后面会改掉，Simple不再用了，你慢慢往后看。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1684905924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":374514,"user_name":"Geek_7jwpfc","can_delete":false,"product_type":"c1","uid":1318633,"ip_address":"湖南","ucode":"CBCEA76E9EF33B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJhxtIyXX4icMNAq5zEvchKYS3q7fwZXA3h7yV80iaibCRXniaLW95OnPC8PM2h5Ja5ibpkJ1VJowicqKZA/132","comment_is_top":false,"comment_ctime":1684150108,"is_pvip":false,"replies":[{"id":136720,"content":"后续有说明。线下班是学生自己当练习补上的。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1684154029,"ip_address":"澳大利亚","comment_id":374514,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100536701,"comment_content":"看了这节课的代码，设计的构造器和property注入，是不是只设计基本类型，后续会有改动！","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":618235,"discussion_content":"后续有说明。线下班是学生自己当练习补上的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1684154029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":374306,"user_name":"Geek_7jwpfc","can_delete":false,"product_type":"c1","uid":1318633,"ip_address":"湖南","ucode":"CBCEA76E9EF33B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJhxtIyXX4icMNAq5zEvchKYS3q7fwZXA3h7yV80iaibCRXniaLW95OnPC8PM2h5Ja5ibpkJ1VJowicqKZA/132","comment_is_top":false,"comment_ctime":1683878491,"is_pvip":false,"replies":[{"id":136691,"content":"以github为准。最后都是一致的。","user_name":"作者回复","user_name_real":"作者","uid":1864890,"ctime":1684020658,"ip_address":"澳大利亚","comment_id":374306,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100536701,"comment_content":"文稿中ArgumentValues和github上面的不一致，我到底应该相信谁的","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":618003,"discussion_content":"以github为准。最后都是一致的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1684020658,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":374305,"user_name":"Geek_7jwpfc","can_delete":false,"product_type":"c1","uid":1318633,"ip_address":"湖南","ucode":"CBCEA76E9EF33B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJhxtIyXX4icMNAq5zEvchKYS3q7fwZXA3h7yV80iaibCRXniaLW95OnPC8PM2h5Ja5ibpkJ1VJowicqKZA/132","comment_is_top":false,"comment_ctime":1683878234,"is_pvip":false,"replies":[{"id":136722,"content":"对","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1684154077,"ip_address":"澳大利亚","comment_id":374305,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100536701,"comment_content":"ArgumentValue有两个构造器，第一个是#ArgumentValue(Object value, String type)，第二个是#ArgumentValue(Object value, String type, String name)，name字段不是必须的？","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":618238,"discussion_content":"对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1684154077,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":372986,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"北京","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1681892292,"is_pvip":false,"replies":[{"id":136290,"content":"这个是不同的做法，我觉得都可以。不过我做MiniSpring的目的是引导学生去理解Spring框架，所以就按照Spring的来的，这样以后读Spring框架源代码的时候，就跟熟悉了。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1681895194,"ip_address":"澳大利亚","comment_id":372986,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100536701,"comment_content":"老师请教个问题，\n其实SimpleBeanFactory完全没必要告诉外界它也是BeanDefinitionRegistry“仓库”，也就是没必要实现这个接口，它应该告诉外界它就只是一个BeanFactory“工厂”就足够了，然后再将BeanDefinitionRegistry作为SimpleBeanFactory中的一个属性，利用组合关系，放弃继承关系，这样从结构上更容易让人接受，纯属个人理解。","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":614752,"discussion_content":"这个是不同的做法，我觉得都可以。不过我做MiniSpring的目的是引导学生去理解Spring框架，所以就按照Spring的来的，这样以后读Spring框架源代码的时候，就跟熟悉了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681895194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":372038,"user_name":"天敌","can_delete":false,"product_type":"c1","uid":1059944,"ip_address":"四川","ucode":"CD29A622197197","user_header":"https://static001.geekbang.org/account/avatar/00/10/2c/68/c299bc71.jpg","comment_is_top":false,"comment_ctime":1680620897,"is_pvip":false,"replies":[{"id":135794,"content":"暂时没有。这一部分是从Spring节选的。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1680675805,"ip_address":"澳大利亚","comment_id":372038,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100536701,"comment_content":"Arguments#addArgumentValue(Integer key,ArgumentValue newValue) 这个方法是私有方法但是现在没有地方调用吗？","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612426,"discussion_content":"暂时没有。这一部分是从Spring节选的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680675805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371598,"user_name":"哇!猪!!","can_delete":false,"product_type":"c1","uid":2181929,"ip_address":"四川","ucode":"42EC42CA7D50F1","user_header":"https://static001.geekbang.org/account/avatar/00/21/4b/29/9e5d963b.jpg","comment_is_top":false,"comment_ctime":1680084584,"is_pvip":false,"replies":[{"id":135580,"content":"没有错。是你写的更好，赞！","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1680087453,"ip_address":"澳大利亚","comment_id":371598,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100536701,"comment_content":"public Class getType(String name) { return this.beanDefinitionMap.get(name).getClass(); }这里貌似写错了？应该是 public Class&lt;?&gt; getType(String name) {\n        return (Class&lt;?&gt;) this.beanDefinitionMap.get(name).getBeanClass();\n    }","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":611440,"discussion_content":"没有错。是你写的更好，赞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680087453,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2342711,"avatar":"https://static001.geekbang.org/account/avatar/00/23/bf/37/10f71592.jpg","nickname":"开车疾如风","note":"","ucode":"84B17E8FC5B0DF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":618635,"discussion_content":"老师，这里应该是有问题的this.beanDefinitionMap.get(name)得到的是BeanDefinition对象，再调用的getClass()方法是Object类的方法，得到的是BeanDefinition类，debug结果也是如此。   \n\n我猜BeanDefinition里面的beanClass是用来存储bean实例化之后的饮用？所以感觉应该是getBeanClass()后再getClass()。 还没看过Spring的实现，感觉后面的课程会解答我这个疑问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1684400834,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":611440,"ip_address":"广东","group_id":0},"score":618635,"extra":""}]}]},{"had_liked":false,"id":371128,"user_name":"姐姐","can_delete":false,"product_type":"c1","uid":3021628,"ip_address":"浙江","ucode":"1A615FA9B453DE","user_header":"https://static001.geekbang.org/account/avatar/00/2e/1b/3c/9c5fc55f.jpg","comment_is_top":false,"comment_ctime":1679562006,"is_pvip":false,"replies":[{"id":135402,"content":"感谢感谢。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679607221,"ip_address":"澳大利亚","comment_id":371128,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100536701,"comment_content":"感谢老师，这个课太用心了，展现了spring从一颗种子成长为大树的过程，才看了两节，已经感觉收获颇多，会继续追下去。","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":610534,"discussion_content":"感谢感谢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679607221,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370843,"user_name":"啊良梓是我","can_delete":false,"product_type":"c1","uid":1655117,"ip_address":"广东","ucode":"E42FC1A60D331C","user_header":"https://static001.geekbang.org/account/avatar/00/19/41/4d/f6d6d13a.jpg","comment_is_top":false,"comment_ctime":1679313717,"is_pvip":false,"replies":[{"id":135312,"content":"文稿里面的代码不完整，你看Github上的ioc相关分支","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679369628,"ip_address":"澳大利亚","comment_id":370843,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100536701,"comment_content":"public boolean isSingleton(String beanName) {\n        return beanDefinitionMap.get(beanName).isSingleton();\n    } \n这里好像BeanDefinition 没有定义这个isSingleton()方法吧？哪来的","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":610055,"discussion_content":"文稿里面的代码不完整，你看Github上的ioc相关分支","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679369629,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370766,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"北京","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1679229798,"is_pvip":true,"replies":[{"id":135287,"content":"赞你！\n其实我觉得不必要纠结beanNames和singletons，MiniSpring的主要目的是为了解析Spring框架的结构，代码不是工业级的，方便理解就好。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679282713,"ip_address":"澳大利亚","comment_id":370766,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100536701,"comment_content":"继续闷头抄代码，不明觉厉。\n\nhttps:&#47;&#47;github.com&#47;escray&#47;miniSpring&#47;tree&#47;IoC02\n\n对于思考题，构造器注入是不是相对更死板一些，而 Setter 注入更灵活，可以从配置文件读取。\n\n看到留言里面大家都在纠结 beanNames 和 singletons 的重叠，一方面是实现风格，另外我觉得，提供 beanNames 的情况下是不是可以做到更好的性能？特别是在与只需要判断名字的时候，感觉上 singletons 有可能会变的比较庞大。\n\n另外就是关于代码的 UML 图，在 IDEA 里面可以直接生成项目的 UML 图，虽然不怎么美观，但是该有的要素都是有的。","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609891,"discussion_content":"赞你！\n其实我觉得不必要纠结beanNames和singletons，MiniSpring的主要目的是为了解析Spring框架的结构，代码不是工业级的，方便理解就好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679282713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370581,"user_name":"李小江","can_delete":false,"product_type":"c1","uid":1319192,"ip_address":"广东","ucode":"F3F30C814866CA","user_header":"https://static001.geekbang.org/account/avatar/00/14/21/18/dde59ef9.jpg","comment_is_top":false,"comment_ctime":1678977879,"is_pvip":false,"replies":[{"id":135215,"content":"读得细致。我的习惯一般是所有的方法先弄成private，然后用到一个放开一个。这个类后面会改造的，你往后学。 MiniSpring的重点是演示Spring这个框架的结构怎么一步步搭建的，具体代码细节不是重点。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679006180,"ip_address":"澳大利亚","comment_id":370581,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100536701,"comment_content":"ArgumentValues中addArgumentValue方法为什么是私有的，也没有调用到。是后面会用到的还是什么设计","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609510,"discussion_content":"读得细致。我的习惯一般是所有的方法先弄成private，然后用到一个放开一个。这个类后面会改造的，你往后学。 MiniSpring的重点是演示Spring这个框架的结构怎么一步步搭建的，具体代码细节不是重点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679006180,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370557,"user_name":"睿智的仓鼠","can_delete":false,"product_type":"c1","uid":2781305,"ip_address":"湖北","ucode":"914D56E47B01F2","user_header":"https://static001.geekbang.org/account/avatar/00/2a/70/79/bb591140.jpg","comment_is_top":false,"comment_ctime":1678954271,"is_pvip":false,"replies":[{"id":135218,"content":"好几个人问这个问题，大家都很用心，赞！\n其实不用也可以，没有问题。风格不同，不同的人设计的范式和感觉不同，我习惯于把主体与关系分开。Spring框架本身也有一个类似的set，叫registeredSingletons，里面就是beanNames。另外，MiniSpring的主要目的是便于学习Spring本身，所以，简化了很多，不是那么严格。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679007039,"ip_address":"澳大利亚","comment_id":370557,"utype":1}],"discussion_count":4,"race_medal":0,"score":5,"product_id":100536701,"comment_content":"请问郭老师，在SimpleBeanFactory和之前的DefaultSingletonBeanRegistry中，为什么要额外维护一个names的List？目前来看如果用来判断contains的话，存储映射关系的map也可以做到，list在后面是有什么妙用吗？","like_count":0,"discussions":[{"author":{"id":2431311,"avatar":"https://static001.geekbang.org/account/avatar/00/25/19/4f/a0757e5f.jpg","nickname":"江宁XYZ","note":"","ucode":"D2D1C3DF0809F8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609482,"discussion_content":"可以看小马哥讲的spring 核心编程思想 因为这里的map是无序的,List的是有顺序的,当你去获取所有的Bean的时候,会遍历这个list,然后再根据name从map中拿出来展示,保证顺序","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1678982012,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2781305,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/70/79/bb591140.jpg","nickname":"睿智的仓鼠","note":"","ucode":"914D56E47B01F2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2431311,"avatar":"https://static001.geekbang.org/account/avatar/00/25/19/4f/a0757e5f.jpg","nickname":"江宁XYZ","note":"","ucode":"D2D1C3DF0809F8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609826,"discussion_content":"你说得很对，文中没有提及所以忽略这个点了，悟了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679230534,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":609482,"ip_address":"湖北","group_id":0},"score":609826,"extra":""},{"author":{"id":2419502,"avatar":"https://static001.geekbang.org/account/avatar/00/24/eb/2e/90fea784.jpg","nickname":"柒","note":"","ucode":"D41241629321A1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2431311,"avatar":"https://static001.geekbang.org/account/avatar/00/25/19/4f/a0757e5f.jpg","nickname":"江宁XYZ","note":"","ucode":"D2D1C3DF0809F8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":610223,"discussion_content":"这样一说，要保证顺序，最后的效果相当于一个LinkedHashMap()","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679463707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":609482,"ip_address":"上海","group_id":0},"score":610223,"extra":""}]},{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609514,"discussion_content":"好几个人问这个问题，大家都很用心，赞！\n其实不用也可以，没有问题。风格不同，不同的人设计的范式和感觉不同，我习惯于把主体与关系分开。Spring框架本身也有一个类似的set，叫registeredSingletons，里面就是beanNames。另外，MiniSpring的主要目的是便于学习Spring本身，所以，简化了很多，不是那么严格。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1679007039,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370549,"user_name":"Geek_09b0c3","can_delete":false,"product_type":"c1","uid":1647169,"ip_address":"广东","ucode":"BD53D4B2C9201D","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/uUNsibxx9EvpiaeG5VVd6slEia0QGFsIdOPwxxz7NmulA1dpSDktTmcV9pa6DPiaj1aj8T9eafVfDSYq8TiaKVxw8sg/132","comment_is_top":false,"comment_ctime":1678945838,"is_pvip":false,"replies":[{"id":135217,"content":"再回复：\n其实不用也可以，没有问题。风格不同，不同的人设计的范式和感觉不同，我习惯于把主体与关系分开。Spring框架本身也有一个类似的set，叫registeredSingletons，里面就是beanNames。另外，MiniSpring的主要目的是便于学习Spring本身，所以，简化了很多，不是那么严格。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679007008,"ip_address":"澳大利亚","comment_id":370549,"utype":1}],"discussion_count":2,"race_medal":0,"score":5,"product_id":100536701,"comment_content":"老师 有个疑问\n代码：\n&#47;&#47;容器中存放所有bean的名称的列表 protected List beanNames = new ArrayList&lt;&gt;(); &#47;&#47;容器中存放所有bean实例的map protected Map singletons = new ConcurrentHashMap&lt;&gt;(256);\n\n\n我们在默认的这个类中，定义了 beanNames 列表和 singletons 的映射关系，beanNames 用于存储所有单例 Bean 的别名，singletons 则存储 Bean 名称和实现类的映射关系。\nsingletons存储的key就是bean的别名 那为什么还要特地用一个list做存储呢？似乎一个map就能搞定问题了","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609513,"discussion_content":"再回复：\n其实不用也可以，没有问题。风格不同，不同的人设计的范式和感觉不同，我习惯于把主体与关系分开。Spring框架本身也有一个类似的set，叫registeredSingletons，里面就是beanNames。另外，MiniSpring的主要目的是便于学习Spring本身，所以，简化了很多，不是那么严格。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1679007008,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2431311,"avatar":"https://static001.geekbang.org/account/avatar/00/25/19/4f/a0757e5f.jpg","nickname":"江宁XYZ","note":"","ucode":"D2D1C3DF0809F8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609483,"discussion_content":"我回复到楼上了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1678982062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370548,"user_name":"Geek_09b0c3","can_delete":false,"product_type":"c1","uid":1647169,"ip_address":"广东","ucode":"BD53D4B2C9201D","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/uUNsibxx9EvpiaeG5VVd6slEia0QGFsIdOPwxxz7NmulA1dpSDktTmcV9pa6DPiaj1aj8T9eafVfDSYq8TiaKVxw8sg/132","comment_is_top":false,"comment_ctime":1678945683,"is_pvip":false,"replies":[{"id":135216,"content":"其实不用也可以，没有问题。风格不同，不同的人设计的范式和感觉不同，我习惯于把主体与关系分开。Spring框架本身也有一个类似的set，叫registeredSingletons，里面就是beanNames。另外，MiniSpring的主要目的是便于学习Spring本身，所以，简化了很多，不是那么严格。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679006928,"ip_address":"澳大利亚","comment_id":370548,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100536701,"comment_content":"老师 有个疑问：\n我们在默认的这个类中，定义了 beanNames 列表和 singletons 的映射关系，beanNames 用于存储所有单例 Bean 的别名，singletons 则存储 Bean 名称和实现类的映射关系。","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609512,"discussion_content":"其实不用也可以，没有问题。风格不同，不同的人设计的范式和感觉不同，我习惯于把主体与关系分开。Spring框架本身也有一个类似的set，叫registeredSingletons，里面就是beanNames。另外，MiniSpring的主要目的是便于学习Spring本身，所以，简化了很多，不是那么严格。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679006928,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370527,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1678928179,"is_pvip":false,"replies":[{"id":135142,"content":"ni你看得细，留言很有价值。第一个问题，与Spring的对外协议有关，api中这么说的:requiredName - the name to match (can be null to not match argument values by name, or empty String to match any name)，为null是有特殊用处的，所以不能放在函数开头直接跳过。\n问题二，应该是笔误，是实体类，即定义属性和构造函数参数的那两个类，为后面的章节预留的。\n问题三，一个是仓库，一个是工厂，仓库的管理内容更少一点。这么做主要是进行角色分解，一个类只做一件事情。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1678968243,"ip_address":"澳大利亚","comment_id":370527,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100536701,"comment_content":"请教老师几个问题：\nQ1：ArgumentValues 类的getGenericArgumentValue方法中，\nfor中的if判断“requiredName == null”，感觉应该放在函数开始的地方。\nQ2：“实例类”是什么意思？\n文中最后部分有一句“我们还提前为构造器注入、Setter 注入提供了基本的实例类”，其中的“实例类”是指什么？\nQ3：BeanDefinitionRegistry 和BeanFactory 都是接口。\n而且感觉功能比较类似，这两个有什么区别？","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609383,"discussion_content":"ni你看得细，留言很有价值。第一个问题，与Spring的对外协议有关，api中这么说的:requiredName - the name to match (can be null to not match argument values by name, or empty String to match any name)，为null是有特殊用处的，所以不能放在函数开头直接跳过。\n问题二，应该是笔误，是实体类，即定义属性和构造函数参数的那两个类，为后面的章节预留的。\n问题三，一个是仓库，一个是工厂，仓库的管理内容更少一点。这么做主要是进行角色分解，一个类只做一件事情。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678968244,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370451,"user_name":"adelyn","can_delete":false,"product_type":"c1","uid":2981014,"ip_address":"北京","ucode":"E7DD2F47EBD6DA","user_header":"https://static001.geekbang.org/account/avatar/00/2d/7c/96/079a158d.jpg","comment_is_top":false,"comment_ctime":1678843886,"is_pvip":false,"replies":[{"id":135113,"content":"你说的对。SimpleBeanFactory的getBean线程不安全。Spring本身也没有重点解决多线程的问题，这些是交给应用程序的。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1678854259,"ip_address":"澳大利亚","comment_id":370451,"utype":1}],"discussion_count":3,"race_medal":0,"score":5,"product_id":100536701,"comment_content":"老师，发现一点问题\n1.DefaultSingletonBeanRegistry中registerSingleton已经加了锁，singletons可以保证写安全，故不用加锁\n2.这个不太确定，SimpleBeanFactory的getBean方法，线程不安全，我不太了解spring是否为单线程加载，如果是，需要加双重锁","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609165,"discussion_content":"你说的对。SimpleBeanFactory的getBean线程不安全。Spring本身也没有重点解决多线程的问题，这些是交给应用程序的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678854259,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":2981014,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/7c/96/079a158d.jpg","nickname":"adelyn","note":"","ucode":"E7DD2F47EBD6DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":609172,"discussion_content":"第一点我写错了，应为: 锁可以保证singletons写安全，故不需要用cocurrentHashmap","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678856352,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":609165,"ip_address":"北京","group_id":0},"score":609172,"extra":""},{"author":{"id":2393550,"avatar":"https://static001.geekbang.org/account/avatar/00/24/85/ce/df1c7a91.jpg","nickname":"陈小远","note":"","ucode":"8C348A5FA8F539","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2981014,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/7c/96/079a158d.jpg","nickname":"adelyn","note":"","ucode":"E7DD2F47EBD6DA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609698,"discussion_content":"这点感觉应该是为了保持和Spring相关类实现的一致性。在Spring的源码中也是一样，虽然用了同步原语，但是还是使用了并发容器。在更完备的源码实现里面，该bean容器的引用是被方法暴露出去了的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679125293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":609172,"ip_address":"四川","group_id":0},"score":609698,"extra":""}]}]},{"had_liked":false,"id":392430,"user_name":"刘建港","can_delete":false,"product_type":"c1","uid":3252324,"ip_address":"北京","ucode":"F9FDF28CAE185C","user_header":"https://static001.geekbang.org/account/avatar/00/31/a0/64/203feff7.jpg","comment_is_top":false,"comment_ctime":1720932549,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100536701,"comment_content":"老师这个项目的github代码在哪里\n","like_count":0},{"had_liked":false,"id":388965,"user_name":"绘世浮夸 つ","can_delete":false,"product_type":"c1","uid":1763933,"ip_address":"江苏","ucode":"6A3960195753BA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ea/5d/ccb4c205.jpg","comment_is_top":false,"comment_ctime":1711289897,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100536701,"comment_content":"BeanDefinition中beanclass属性为什么要用volatile修饰","like_count":0},{"had_liked":false,"id":385790,"user_name":"Howard","can_delete":false,"product_type":"c1","uid":1070123,"ip_address":"广东","ucode":"0872DB9ACEB5D2","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/2b/c8acb384.jpg","comment_is_top":false,"comment_ctime":1703389611,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100536701,"comment_content":"为啥git上很多文件夹都是空的呢？","like_count":0},{"had_liked":false,"id":382467,"user_name":"小麦","can_delete":false,"product_type":"c1","uid":1216881,"ip_address":"广东","ucode":"55C7199A0D5659","user_header":"https://static001.geekbang.org/account/avatar/00/12/91/71/0b16655d.jpg","comment_is_top":false,"comment_ctime":1697428053,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100536701,"comment_content":"&quot;public class SimpleBeanFactory extends DefaultSingletonBeanRegistry implements BeanFactory&quot;\n看到这里有个疑惑，为什么要用继承，而不是组合。","like_count":0},{"had_liked":false,"id":379574,"user_name":"老实人Honey","can_delete":false,"product_type":"c1","uid":1080653,"ip_address":"广东","ucode":"EA4AB5C0C33090","user_header":"https://static001.geekbang.org/account/avatar/00/10/7d/4d/d98865b2.jpg","comment_is_top":false,"comment_ctime":1692118773,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":5,"product_id":100536701,"comment_content":"这一节课的内容属实有点多，还有点跳跃。如果可以补充UML类图那就更好了。","like_count":0},{"had_liked":false,"id":378928,"user_name":"Geek_f7230c","can_delete":false,"product_type":"c1","uid":3684313,"ip_address":"江苏","ucode":"A0FF2CE8514905","user_header":"","comment_is_top":false,"comment_ctime":1690984922,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":6,"product_id":100536701,"comment_content":"太快了，好难理解为什么这么设计","like_count":0}]}