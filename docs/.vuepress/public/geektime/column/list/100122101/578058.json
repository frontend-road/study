{"id":578058,"title":"08｜深入理解继承、Delegation和组合","content":"<p>你好，我是石川。</p><p>关于面向对象编程，最著名的一本书就数<a href=\"https://zh.wikipedia.org/zh-cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%9F%BA%E7%A1%80\">GoF</a>（Gang of Four）写的<a href=\"https://book.douban.com/subject/34262305/\">《设计模式：可复用面向对象软件的基础》</a>了。这本书里一共提供了23种不同的设计模式，不过今天我们不会去展开了解这些细节，而是会把重点放在其中一个面向对象的核心思想上，也就是<strong>组合优于继承</strong>。</p><p>在JS圈，有不少继承和组合的争论。其实无论是继承还是组合，我们都不能忘了要批判性地思考。批判性思考的核心不是批判，而是通过深度思考核心问题，让我们对事物能有自己的判断。</p><p>所以，无论是继承还是组合，都只是方式、方法，它们要解决的核心问题就是<strong>如何让代码更加容易复用</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/e3/ff/e32437db6ecda3149a4422a540ffc2ff.jpeg?wh=1920x1080\" alt=\"图片\"></p><p>那么接下来，我们就根据这个思路，看看JavaScript中是通过哪些方法来解决代码复用这个问题的，以及在使用不同的方法时它们各自解决了什么问题、又引起了什么问题。这样我们在实际的业务场景中，就知道如何判断和选择最适合的解决方式了。</p><h2>继承</h2><p>在传统的OOP里面，我们通常会提到继承（Inheritance）和多态（Polymorphism）。继承是用来在父类的基础上创建一个子类，来继承父类的属性和方法。多态则允许我们在子类里面调用父类的构建者，并且覆盖父类里的方法。</p><p>那么下面，我们就先来看下在JavaScript里，要如何通过构建函数来做继承。</p><!-- [[[read_end]]] --><h3>如何通过继承多态重用？</h3><p>实际上，从ES6开始，我们就可以通过extends的方式来做继承。具体如下所示：</p><pre><code class=\"language-javascript\">class Widget {\n  appName = \"核心微件\";\n  getName () {\n    return this.appName;\n  }\n}\n\nclass Calendar extends Widget {}\n\nvar calendar = new Calendar();\nconsole.log(calendar.hasOwnProperty(\"appName\")); // 返回 true\nconsole.log(calendar.getName()); // 返回 \"核心微件\"\n\ncalendar.appName = \"日历应用\"\nconsole.log(typeof calendar.getName); // 返回 function\nconsole.log(calendar.getName()); // 返回 “日历应用”\n</code></pre><p>接着来看多态。从ES6开始，我们可以通过super在子类构建者里面调用父类的构建者，并且覆盖父类里的属性。可以看到在下面的例子里，我们是通过super将Calendar的appName属性从“核心微件”改成了“日历应用”。</p><pre><code class=\"language-javascript\">class Widget {\n  constructor() {\n    this.appName = \"核心微件\";\n  }\n  \n  getName () {\n    return this.appName;\n  }\n}\n\nclass Calendar extends Widget {\n  constructor(){\n    super();\n    this.appName = \"日历应用\";\n  }\n}\n\nvar calendar = new Calendar();\nconsole.log(calendar.hasOwnProperty(\"appName\")); // 返回 true\nconsole.log(calendar.getName()); // 返回 \"日历应用\"\nconsole.log(typeof calendar.getName); // 返回 function\nconsole.log(calendar.getName()); // 返回 “日历应用”\n</code></pre><p>在一些实际的例子，如React这样的三方库里，我们也经常可以看到一些继承的例子，比如我们可以通过继承React.Component来创建一个WelcomeMessage的子类。</p><pre><code class=\"language-typescript\">class WelcomeMessage extends React.Component {\n  render() {\n    return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;;\n  }\n}\n</code></pre><h2>授权</h2><p>说完了继承，我们再来看授权这个方法。</p><p><strong>什么是授权（Delegation）呢？</strong>我打个比方，这里的授权不是我们理解的作为领导（父类）给下属（子类）授权，而是作为个体对象可以授权给一个平台或者他人来一起做一件事。</p><p>就好像我和极客时间合作，我的个人精力和专业能力只允许我尽量做好内容，但是我没有精力和经验去做编辑、后期和推广等等，这时就授权给极客时间相关的老师来一起做，我在这件事、这个过程中只是专心把内容的部分做好。</p><h3>如何通过授权做到重用？</h3><p>在前面的例子中，结合我们在<a href=\"https://time.geekbang.org/column/article/572260\">第1讲</a>里提到的基于原型链的继承，我们会发现使用JavaScript无论是通过函数构建也好，还是加了语法糖的类也好，来模拟一般的面向对象语言，比如Java的类和继承，对于有些开发者来说是比较<strong>反直觉</strong>的。在使用的时候需要大量的思想转换，才能把JavaScript的底层逻辑转换成实际呈现出来的实现。</p><p>那么有没有一种方式可以让代码更直观呢？这种方式其实就是<strong>通过原型本身来做授权会更符合直觉</strong>。从ES5开始，JavaScript就支持了Object.create()的方法。下面我们来看一个例子：</p><pre><code class=\"language-javascript\">var Widget = {\n  setCity : function(City) {this.city = City; },\n  outputCity : function() {return this.city;}\n};\n\nvar Weather = Object.create(Widget);\n\nWeather.setWeather = function (City, Tempreture) {\n  this.setCity(City);\n  this.tempreture = Tempreture;\n};\n\nWeather.outputWeather = function() {\n  console.log(this.outputCity()+ \", \" + this.tempreture);\n}\n\nvar weatherApp1 = Object.create(Weather);\nvar weatherApp2 = Object.create(Weather);\n\nweatherApp1.setWeather(\"北京\",\"26度\");\nweatherApp2.setWeather(\"南京\",\"28度\");\n\nweatherApp1.outputWeather(); // 北京, 26度\nweatherApp2.outputWeather(); // 南京, 28度\n</code></pre><p>可见，我们创建的Weather天气预报这个对象，授权给了Widget，让Widget在得到授权的情况下，帮助Weather来设定城市和返回城市。Widget对象在这里更像是一个平台，它在得到Weather的授权后为Weather赋能。而Weather对象可以在这个基础上，专注于实现自己的属性和方法，并且产出weatherApp1和weatherApp2的实例。</p><p>当然也有开发者认为class的方式没有什么反直觉的，那授权同样可以通过class来实现。比如我们如果想在上一讲提到过的集合（Set）和字典（Map）的基础上，加上计数的功能，可以通过继承Set来实现。但是我们也可以反之，在把部分功能授权给Map的基础上，自己专注实现一些类似Set的API接口。</p><pre><code class=\"language-typescript\">class SetLikeMap {\n    // 初始化字典\n    constructor() { this.map = new Map(); }\n    // 自定义集合接口\n    count(key) { /*...*/ }\n    add(key) { /*...*/ }\n    delete(key) { /*...*/ }\n    // 迭代返回字典中的键\n    [Symbol.iterator]() { return this.map.keys(); }\n    // 部分功能授权给字典\n    keys() { return this.map.keys(); }\n    values() { return this.map.values(); }\n    entries() { return this.map.entries(); }\n}\n</code></pre><h2>组合</h2><p>说完了授权，我们再来看看组合。当然上面我们说的授权，广义上其实就是一种组合。但是这种组合更像是“个体和平台的合作”；而另一种组合更像是“团队内部的合作”，它也有很多的应用和实现方式，我们可以来了解一下。</p><p><img src=\"https://static001.geekbang.org/resource/image/14/16/1484acce439171d493f3efbff42b8716.jpeg?wh=1920x1080\" alt=\"图片\"></p><h3>如何通过借用做到重用？</h3><p>在JavaScript中，函数有自带的apply和call功能。我们可以通过apply或call来“借用”一个功能。这种方式，也叫<strong>隐性混入</strong>（Implicit mixin）。比如在数组中，有一个原生的slice的方法，我们就可以通过call来借用这个原生方法。</p><p>如下代码示例，我们就是通过借用这个功能，把函数的实参当做数组来slice。</p><pre><code class=\"language-javascript\">function argumentSlice() {\n&nbsp; &nbsp; var args = [].slice.call(arguments, 1, 3);\n&nbsp; &nbsp; return args;\n}\n// example\nargumentSlice(1, 2, 3, 4, 5, 6); // returns [2,3]\n</code></pre><h3>如何通过拷贝赋予重用？</h3><p>除了“借力”以外，我们还能通过什么组合方式来替代继承呢？这就要说到“拷贝”了。这个方法顾名思义，就是把别人的属性和方法拷贝到自己的身上。这种方式也叫<strong>显性混入</strong>（Explicit mixin）。</p><p>在ES6之前，人们通常要偷偷摸摸地“抄袭”。在ES6之后，JavaScript里才增加了“赋予”，也就是Object.assign()的功能，从而可以名正言顺地当做是某个对象“赋予”给另外一个对象它的“特质和能力”。</p><p>那么下面，我们就先看看在ES6之后，JavaScript是如何名正言顺地来做拷贝的。</p><p>首先，通过对象自带的assign()，我们可以把Widget的属性赋予calendar，当然在calendar里，我们也可以保存自己本身的属性。和借用一样，借用和赋予都不会产生原型链。如以下代码所示：</p><pre><code class=\"language-javascript\">var widget = {\n  appName : \"核心微件\"\n}\n\nvar calendar = Object.assign({\n  appVersion: \"1.0.9\"\n}, widget);\n\nconsole.log(calendar.hasOwnProperty(\"appName\")); // 返回 true\nconsole.log(calendar.appName); // 返回 “核心微件”\nconsole.log(calendar.hasOwnProperty(\"appVersion\")); // 返回 true\nconsole.log(calendar.appVersion); // 返回 “1.0.9”\n</code></pre><p>好，接着我们再来看看在ES6之前，人们是怎么通过“抄袭”来拷贝的。</p><p>这里实际上分为“浅度拷贝”和“深度拷贝”两个概念。“浅度拷贝”类似于上面提到的赋予assign这个方法，它所做的就是遍历父类里面的属性，然后拷贝到子类。我们可以通过JavaScript中专有的for in循环，来遍历对象中的属性。</p><p>细心的同学可能会发现，我们在<a href=\"https://time.geekbang.org/column/article/573307\">第2讲</a>中说到用拷贝来做到不可变时，就了解过通过延展操作符来实现浅拷贝的方法了。</p><pre><code class=\"language-typescript\">// 数组浅拷贝\nvar a = [ 1, 2 ];\nvar b = [ ...a ];\nb.push( 3 );\na;  // [1,2]\nb;  // [1,2,3]\n\n// 对象浅拷贝\nvar o = {\n    x: 1,\n    y: 2\n};\nvar p = { ...o };\np.y = 3; \no.y;  // 2\np.y;  // 3\n</code></pre><p>而在延展操作符出现之前，人们大概可以通过这样一个for in循环做到类似的浅拷贝。</p><pre><code class=\"language-javascript\">function shallowCopy(parent, child) {\n  var i;\n  child = child || {};\n  for (i in parent) {\n    if (parent.hasOwnProperty(i)) {\n      child[i] = parent[i];\n    }\n  }\n  return child;\n}\n</code></pre><p>至于深度拷贝，是指当一个对象里面存在嵌入的对象就会深入遍历。但这样会引起一个问题：<strong>如果这个对象有多层嵌套的话，是每一层都要遍历吗？究竟多深算深？还有就是如果一个对象也引用了其它对象的属性，我们要不要也拷贝过来？</strong></p><p>所以相对于深度拷贝，浅度拷贝的问题会少一些。但是在<a href=\"https://time.geekbang.org/column/article/573307\">第2讲</a>的留言互动区，我们也说过，如果我们想要保证一个对象的深度不可变，还是需要深度拷贝的。深度拷贝的一个相对简单的实现方案是用JSON.stringify。当然这个方案的前提是这个对象必须是JSON-safe的。</p><pre><code class=\"language-typescript\">function deepCopy(o) { return JSON.parse(JSON.stringify(o)); }\n</code></pre><p>同时，在<a href=\"https://time.geekbang.org/column/article/573307\">第2讲</a>的留言区中，也有同学提到过另外一种递归的实现方式，所以我们也大致可以通过这样一个递归来实现：</p><pre><code class=\"language-javascript\">function deepCopy(parent, child) {\n  var i,\n  toStr = Object.prototype.toString,\n  astr = \"[object Array]\";\n  child = child || {};\n&nbsp; &nbsp; for (i in parent) {\n      if (parent.hasOwnProperty(i)) {\n        if (typeof parent[i] === \"object\") {\n          child[i] = (toStr.call(parent[i]) === astr) ? [] : {};\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deepCopy(parent[i], child[i]);\n&nbsp; &nbsp; &nbsp; &nbsp; } else {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child[i] = parent[i];\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; }\n&nbsp; }\n&nbsp; return child;\n}\n</code></pre><h3>如何通过组合做到重用？</h3><p>上面我们说的无论是借用、赋予，深度还是浅度拷贝，都是一对一的关系。最后我们再来看看，如何通过ES6当中的assign来做到组合混入，也就是说把几个对象的属性都混入在一起。其实方法很简单，以下是参考：</p><pre><code class=\"language-javascript\">var touchScreen = {\n  hasTouchScreen : () =&gt; true\n};\n\nvar button = {\n  hasButton: () =&gt; true\n};\nvar speaker = {\n  hasSpeaker: () =&gt; true\n};\n\nconst Phone = Object.assign({}, touchScreen, button, speaker);\n\nconsole.log(\n  hasTouchScreen: ${ Phone.hasChocolate() }\n  hasButton: ${ Phone.hasCaramelSwirl() }\n  hasSpeaker: ${ Phone.hasPecans() }\n );\n</code></pre><h3>React中的组合优于继承</h3><p>在React当中，我们也可以看到<a href=\"https://reactjs.org/docs/composition-vs-inheritance.html\">组合优于继承的无处不在</a>，并且它同样体现在我们前面讲过的两个方面，一个是“团队内部的合作”，另一个是“个体与平台合作”。下面，我们先看看“团队内部的合作”的例子，在下面的例子里，WelcomeDialog就是嵌入在FancyBorder中的一个团队成员。</p><pre><code class=\"language-typescript\">function FancyBorder(props) {\n  return (\n    &lt;div className={'FancyBorder FancyBorder-' + props.color}&gt;\n      {props.children}\n    &lt;/div&gt;\n  );\n}\n\nfunction WelcomeDialog() {\n  return (\n    &lt;FancyBorder color=\"blue\"&gt;\n      &lt;h1 className=\"Dialog-title\"&gt;\n        Welcome\n      &lt;/h1&gt;\n      &lt;p className=\"Dialog-message\"&gt;\n        Thank you for visiting our spacecraft!\n      &lt;/p&gt;\n    &lt;/FancyBorder&gt;\n  );\n}\n</code></pre><p>另外，我们也可以看到“个体与平台合作”的影子。在这里，WelcomeDialog是一个“专业”的Dialog，它授权给Dialog这个平台，借助平台的功能，实现自己的title和message。这里就是用到了组合。</p><pre><code class=\"language-typescript\">function Dialog(props) {\n  return (\n    &lt;FancyBorder color=\"blue\"&gt;\n      &lt;h1 className=\"Dialog-title\"&gt;\n        {props.title}\n      &lt;/h1&gt;\n      &lt;p className=\"Dialog-message\"&gt;\n        {props.message}\n      &lt;/p&gt;\n    &lt;/FancyBorder&gt;\n  );\n}\nfunction WelcomeDialog() {\n  return (\n    &lt;Dialog\n      title=\"Welcome\"\n      message=\"Thank you for visiting our spacecraft!\" /&gt;\n  );\n}\n</code></pre><h2>总结</h2><p>这节课，我们了解了通过JavaScript做到代码复用的几种核心思想和方法，从传统的继承，到JavaScript特色的授权以及组合等方式都有分析。虽然我说授权和组合优于继承，但实际上它们之间的关系不是非黑即白的。</p><p>我们看到在前端圈，有很多大佬比如道格拉斯·克罗克福德（Douglas Crockford）和凯尔·辛普森（Kyle Simpson），都是基于授权的对象创建的积极拥护者；而像阿克塞尔·劳施迈尔博士（Dr. Axel Rauschmayer）则是基于类的对象构建的捍卫者。</p><p>我们作为程序员，如果对对象和面向对象的理解不深入，可能很容易在<a href=\"https://2ality.com/2013/07/defending-constructors.html\">不同的论战和观点</a>面前左摇右摆。而实际的情况是，真理本来就不止一个。我们要的“真理”，只不过是通过一个观察角度，形成的一个观点。这样，才能分析哪种方式适合我们当下要解决的问题。这个方式，只有在当下，才是“真理”。而我们通过这个单元整理的方法，目的就是帮助我们做到这样的观测。</p><p><img src=\"https://static001.geekbang.org/resource/image/bd/c7/bd3327234293ccc9e1f7d42f7f4947c7.jpeg?wh=1920x1080\" alt=\"图片\"></p><h2>思考题</h2><p>在前面一讲中，我们试着通过去掉对象私有属性的语法糖，来看如何用更底层的语言能力来实现类似的功能。那么，今天你能尝试着实现下JS中的类和继承中的super，以及原型和授权中的Object.create()吗？</p><p>欢迎在留言区分享你的答案、交流学习心得或者提出问题，如果觉得有收获，也欢迎你把今天的内容分享给更多的朋友。我们下节课见！</p>","comments":[{"had_liked":false,"id":359775,"user_name":"laoergege","can_delete":false,"product_type":"c1","uid":1288733,"ip_address":"北京","ucode":"559CCF36805A04","user_header":"https://static001.geekbang.org/account/avatar/00/13/aa/1d/b8fdd622.jpg","comment_is_top":false,"comment_ctime":1665854145,"is_pvip":false,"replies":[{"id":131008,"content":"这个比喻挺好，很多时候是这样的。","user_name":"作者回复","user_name_real":"编辑","uid":2785919,"ctime":1666280311,"ip_address":"北京","comment_id":359775,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100122101,"comment_content":"组合优于继承，是不是更加适用于平时业务开发？做为基础设施给用户使用的场景，继承更加简洁方便？比如 react 框架下，提供的 Component 类。","like_count":3,"discussions":[{"author":{"id":2785919,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/82/7f/c22de3a3.jpg","nickname":"石川","note":"","ucode":"99E480A265E25F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591107,"discussion_content":"这个比喻挺好，很多时候是这样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666280311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359542,"user_name":"Change","can_delete":false,"product_type":"c1","uid":1161260,"ip_address":"河北","ucode":"FB60D2378C9F02","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/2c/0f7baf3a.jpg","comment_is_top":false,"comment_ctime":1665631476,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100122101,"comment_content":" &#47;********* JS 中的类和继承中的 super **************** *&#47;\n  function Widget() {\n    this.appName = &quot;核心微件&quot;;\n  }\n\n  Widget.prototype.getAppName = function () {\n    return this.appName;\n  };\n\n  function Calendar() {\n    &#47;&#47; 调用super\n    let widget = new Widget();\n    this.__proto__.__proto__ = widget.__proto__; &#47;&#47; Calendar.prototype.__proto__ = Widget.prototype;\n    for (let key in widget) {\n      if (widget.hasOwnProperty(key)) {\n        this[key] = widget[key];\n      }\n    }\n\n    this.name = &quot;Calendar&quot;;\n  }\n\n  Calendar.prototype.getName = function () {\n    return this.name;\n  };\n\n  &#47;**********Object.create************** *&#47;\n  function Person() {\n    this.name = &quot;Person&quot;;\n  }\n\n  &#47;&#47; Object.Create\n  function ObjectCreate(o) {\n    let obj = {};\n    obj.__proto__ = o;\n    return obj;\n  }\n\n  let o = ObjectCreate(new Person());","like_count":1},{"had_liked":false,"id":359314,"user_name":"褚琛","can_delete":false,"product_type":"c1","uid":1160498,"ip_address":"海南","ucode":"E08926DFC44973","user_header":"https://static001.geekbang.org/account/avatar/00/11/b5/32/43b46132.jpg","comment_is_top":false,"comment_ctime":1665408681,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100122101,"comment_content":"&#47;&#47;js中的类和继承\nfunction Widget (appName) {\n  this.appName = appName\n}\n\nWidget.prototype.getName = function() {\n  return this.appName;\n}\n\nfunction Calendar (appName) {\n  Widget.call(this, appName);\n}\n\nCalendar.prototype = { ...Widget.prototype };\n\nvar calendar = new Calendar(&#39;日历应用&#39;);\nconsole.log(calendar.hasOwnProperty(&quot;appName&quot;)); &#47;&#47; 返回 true\nconsole.log(calendar.getName()); &#47;&#47; 返回 &quot;日历应用&quot;\nconsole.log(typeof calendar.getName); &#47;&#47; 返回 function\nconsole.log(calendar.getName()); &#47;&#47; 返回 “日历应用”\n\n&#47;&#47;Object.create()\nfunction create(o) {\n  let Cls = function() {};\n  let obj = new Cls();\n  obj.prototype = o;\n  return obj;\n}","like_count":1},{"had_liked":false,"id":370316,"user_name":"荷兰小猪8813","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"广东","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/66bf4bc4.jpg","comment_is_top":false,"comment_ctime":1678709787,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100122101,"comment_content":"ES6 当中的 assign 来做到组合混入，我看下和 java 的组合有很大的区别，java 是通过持有其他对象的引用来实现组合，js 是直接拷贝属性，差异很大","like_count":0},{"had_liked":false,"id":370315,"user_name":"荷兰小猪8813","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"广东","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/66bf4bc4.jpg","comment_is_top":false,"comment_ctime":1678709582,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100122101,"comment_content":"作为一个 Android 工程师，我怎么感觉授权就是继承呢？？就是基于原型链的继承？？","like_count":0,"discussions":[{"author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/66bf4bc4.jpg","nickname":"荷兰小猪8813","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608941,"discussion_content":"只是把通用的方法放到父类，this 动态绑定。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678754307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}