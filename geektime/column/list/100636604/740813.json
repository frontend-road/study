{"id":740813,"title":"第 12 章 运算符重载","content":"\n<p>在第 2 章展示的曼德博集绘图器中，我们使用了 <code>num</code> crate 的 <code>Complex</code> 类型来表示复平面上的数值：</p>\n<pre class=\"code-rows\"><code>#[derive(Clone, Copy, Debug)]\nstruct Complex&lt;T&gt; {\n    /// 复数的实部\n    re: T,\n\n    /// 复数的虚部\n    im: T,\n}</code></pre>\n<p>使用 Rust 的 <code>+</code> 运算符和 <code>*</code> 运算符，可以像对任何内置数值类型一样对 <code>Complex</code> 进行加法运算和乘法运算：</p>\n<pre class=\"code-rows\"><code>z = z * z + c;</code></pre>\n<p>你也可以让自己的类型支持算术运算符和其他运算符，只要实现一些内置特型即可。这叫作<strong>运算符重载</strong>，其效果跟 C++、C#、Python 和 Ruby 中的运算符重载很相似。</p>\n<p>运算符重载的特型可以根据其支持的语言特性分为几类，如表 12-1 所示。本章将逐一介绍每个类别。我们不仅要帮你把自己的类型很好地集成到语言中，而且要让你更好地了解如何编写泛型函数，比如 11.1.2 节讲过的 <code>dot_product</code> 函数，该函数能使用运算符自然而然地对自定义类型进行运算。本章还会深入讲解语言本身的某些特性是如何实现的。</p>\n<p><strong>表 12-1：运算符重载的特型汇总表</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>类别</p></th>\n<th><p>特型</p></th>\n<th><p>运算符</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>一元运算符</p></td>\n<td><p><code>std::ops::Neg</code><br /><code>std::ops::Not</code></p></td>\n<td><p><code>-x</code><br /><code>!x</code></p></td>\n</tr>\n<tr>\n<td><p>算术运算符</p></td>\n<td><p><code>std::ops::Add</code><br /><code>std::ops::Sub</code><br /><code>std::ops::Mul</code><br /><code>std::ops::Div</code><br /><code>std::ops::Rem</code></p></td>\n<td><p><code>x + y</code><br /><code>x - y</code><br /><code>x * y</code><br /><code>x / y</code><br /><code>x % y</code></p></td>\n</tr>\n<tr>\n<td><p>按位运算符</p></td>\n<td><p><code>std::ops::BitAnd</code><br /><code>std::ops::BitOr</code><br /><code>std::ops::BitXor</code><br /><code>std::ops::Shl</code><br /><code>std::ops::Shr</code></p></td>\n<td><p><code>x &amp; y</code><br /><code>x | y</code><br /><code>x ^ y</code><br /><code>x &lt;&lt; y</code><br /><code>x &gt;&gt; y</code></p></td>\n</tr>\n<tr>\n<td><p>复合赋值算术运算符</p></td>\n<td><p><code>std::ops::AddAssign</code><br /><code>std::ops::SubAssign</code><br /><code>std::ops::MulAssign</code><br /><code>std::ops::DivAssign</code><br /><code>std::ops::RemAssign</code></p></td>\n<td><p><code>x += y</code><br /><code>x -= y</code><br /><code>x *= y</code><br /><code>x /= y</code><br /><code>x %= y</code></p></td>\n</tr>\n<tr>\n<td><p>复合赋值按位运算符</p></td>\n<td><p><code>std::ops::BitAndAssign</code><br /><code>std::ops::BitOrAssign</code><br /><code>std::ops::BitXorAssign</code><br /><code>std::ops::ShlAssign</code><br /><code>std::ops::ShrAssign</code></p></td>\n<td><p><code>x &amp;= y</code><br /><code>x |= y</code><br /><code>x ^= y</code><br /><code>x &lt;&lt;= y</code><br /><code>x &gt;&gt;= y</code></p></td>\n</tr>\n<tr>\n<td><p>比较</p></td>\n<td><p><code>std::cmp::PartialEq</code><br /><code>std::cmp::PartialOrd</code></p></td>\n<td><p><code>x == y</code>、<code>x != y</code><br /><code>x &lt; y</code>、<code>x &lt;= y</code>、<code>x &gt; y</code>、<code>x &gt;= y</code></p></td>\n</tr>\n<tr>\n<td><p>索引</p></td>\n<td><p><code>std::ops::Index</code><br /><code>std::ops::IndexMut</code></p></td>\n<td><p><code>x[y]</code>、<code>&amp;x[y]</code><br /><code>x[y] = z</code>、<code>&amp;mut x[y]</code></p></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"nav_point_203\">12.1　算术运算符与按位运算符</h2>\n<p>在 Rust 中，表达式 <code>a + b</code> 实际上是 <code>a.add(b)</code> 的简写形式，也就是对标准库中 <code>std::ops::Add</code> 特型的 <code>add</code> 方法的调用。Rust 的标准数值类型都实现了 <code>std::ops::Add</code>。为了使表达式 <code>a + b</code> 适用于 <code>Complex</code> 值，<code>num</code> crate 也为 <code>Complex</code> 实现了这个特型。还有一些类似的特型覆盖了其他运算符：<code>a * b</code> 是 <code>a.mul(b)</code> 的简写形式，也就是对 <code>std::ops::Mul</code> 特型的 <code>mul</code> 方法的调用，<code>std::ops::Neg</code> 实现了前缀取负运算符 <code>-</code>，等等。</p><!-- [[[read_end]]] -->\n<p>如果试图写出 <code>z.add(c)</code>，就要将 <code>Add</code> 特型引入作用域，以便它的方法在此可见。做完这些，就可以将所有算术运算视为函数调用了：<span class=\"comment-number\">1</span></p>\n\n<pre class=\"code-rows\"><code>use std::ops::Add;\n\nassert_eq!(4.125f32.add(5.75), 9.875);\nassert_eq!(10.add(20), 10 + 20);</code></pre>\n<p>这是 <code>std::ops::Add</code> 的定义：</p>\n<pre class=\"code-rows\"><code>trait Add&lt;Rhs = Self&gt; {\n    type Output;\n    fn add(self, rhs: Rhs) -&gt; Self::Output;\n}</code></pre>\n<p>也就是说，<code>Add&lt;T&gt;</code> 特型代表给自己的类型加上一个 <code>T</code> 值的能力。如果希望把 <code>i32</code> 和 <code>u32</code> 型的值加到你的类型上，就必须同时实现 <code>Add&lt;i32&gt;</code> 和 <code>Add&lt;u32&gt;</code>。特型的类型参数 <code>Rhs</code> 默认为 <code>Self</code>，因此如果想在两个相同类型的值之间实现加法，那么可以仅为这种情况编写 <code>Add</code>。关联类型 <code>Output</code> 描述了加法结果的类型。</p>\n<p>例如，为了能把两个 <code>Complex&lt;i32&gt;</code> 值加到一起，<code>Complex&lt;i32&gt;</code> 就必须实现 <code>Add&lt;Complex&lt;i32&gt;&gt;</code>。由于我们想为自身加上同类型的值，因此只需像下面这样编写 <code>Add</code> 即可：</p>\n<pre class=\"code-rows\"><code>use std::ops::Add;\n\nimpl Add for Complex&lt;i32&gt; {\n    type Output = Complex&lt;i32&gt;;\n    fn add(self, rhs: Self) -&gt; Self {\n        Complex {\n            re: self.re + rhs.re,\n            im: self.im + rhs.im,\n        }\n    }\n}</code></pre>\n<p>当然，不必为 <code>Complex&lt;i32&gt;</code>、<code>Complex&lt;f32&gt;</code>、<code>Complex&lt;f64&gt;</code> 等逐个实现 <code>Add</code>。除了所涉及的类型不一样，所有定义看起来都完全相同，因此我们可以写一个涵盖所有这些定义的泛型实现，只要复数的各个组件本身的类型都支持加法就可以：</p>\n<pre class=\"code-rows\"><code>use std::ops::Add;\n\nimpl&lt;T&gt; Add for Complex&lt;T&gt;\nwhere\n    T: Add&lt;Output = T&gt;,\n{\n    type Output = Self;\n    fn add(self, rhs: Self) -&gt; Self {\n        Complex {\n            re: self.re + rhs.re,\n            im: self.im + rhs.im,\n        }\n    }\n}</code></pre>\n<p>通过编写 <code>where T: Add&lt;Output=T&gt;</code>，我们将 <code>T</code> 限界到能与自身相加并产生另一个 <code>T</code> 值的类型。虽然这是一个合理的限制，但还可以将条件进一步放宽，因为 <code>Add</code> 特型不要求 <code>+</code> 的两个操作数具有相同的类型，也不限制结果类型。因此，一个尽可能泛化的实现可以让左右操作数独立变化，并生成加法所能生成的任何组件类型的 <code>Complex</code> 值：</p>\n<pre class=\"code-rows\"><code>use std::ops::Add;\n\nimpl&lt;L, R&gt; Add&lt;Complex&lt;R&gt;&gt; for Complex&lt;L&gt;\nwhere\n    L: Add&lt;R&gt;,\n{\n    type Output = Complex&lt;L::Output&gt;;\n    fn add(self, rhs: Complex&lt;R&gt;) -&gt; Self::Output {\n        Complex {\n            re: self.re + rhs.re,\n            im: self.im + rhs.im,\n        }\n    }\n}</code></pre>\n<p>然而，在实践中，Rust 更倾向于避免混合类型运算。由于我们的类型参数 <code>L</code> 必须实现 <code>Add&lt;R&gt;</code>，因此通常情况下 <code>L</code> 和 <code>R</code> 将是相同的类型。这是因为对 <code>L</code> 而言，该限制太严格了，不大可能实现其他类型的 <code>Add</code>。最终，这个尽可能泛化版本的泛型定义，其实并不比之前的简单版本有用多少。</p>\n<p>Rust 的算术运算符和按位运算符的内置特型分为 3 组：一元运算符、二元运算符和复合赋值运算符。在每一组中，特型及其方法都具有相同的形式，因此接下来我们将各举一例。</p>\n<h3 id=\"nav_point_204\">12.1.1　一元运算符</h3>\n<p>除了我们将在 13.5 节单独介绍的解引用运算符 <code>*</code>，Rust 还有两个可以自定义的一元运算符，如表 12-2 所示。</p>\n<p><strong>表 12-2：一元运算符的内置特型</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>特型名称</p></th>\n<th><p>表达式</p></th>\n<th><p>等效表达式</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>std::ops::Neg</code></p></td>\n<td><p><code>-x</code></p></td>\n<td><p><code>x.neg()</code></p></td>\n</tr>\n<tr>\n<td><p><code>std::ops::Not</code></p></td>\n<td><p><code>!x</code></p></td>\n<td><p><code>x.not()</code></p></td>\n</tr>\n</tbody>\n</table>\n<p>Rust 的所有带符号数值类型都实现了 <code>std::ops::Neg</code>，以支持一元取负运算符 <code>-</code>；整数类型和 <code>bool</code> 实现了 <code>std::ops::Not</code>，以支持一元取反运算符 <code>!</code>。还有一些是针对这些类型的引用的实现。</p>\n<p>请注意，<code>!</code> 运算符会对 <code>bool</code> 值进行取反，而对整数执行按位取反，它同时扮演着 C 和 C++ 中的 <code>!</code> 运算符和 <code>~</code> 运算符的角色。</p>\n<p>这些特型的定义很简单：</p>\n<pre class=\"code-rows\"><code>trait Neg {\n    type Output;\n    fn neg(self) -&gt; Self::Output;\n}\n\ntrait Not {\n    type Output;\n    fn not(self) -&gt; Self::Output;\n}</code></pre>\n<p>对一个复数取负就是对它的每个组件取负。以下是对 <code>Complex</code> 值进行取负的泛型实现。</p>\n<pre class=\"code-rows\"><code>use std::ops::Neg;\n\nimpl&lt;T&gt; Neg for Complex&lt;T&gt;\nwhere\n    T: Neg&lt;Output = T&gt;,\n{\n    type Output = Complex&lt;T&gt;;\n    fn neg(self) -&gt; Complex&lt;T&gt; {\n        Complex {\n            re: -self.re,\n            im: -self.im,\n        }\n    }\n}</code></pre>\n<h3 id=\"nav_point_205\">12.1.2　二元运算符</h3>\n<p>Rust 的二元算术运算符和二元按位运算符及它们对应的内置特型参见表 12-3。</p>\n<p><strong>表 12-3：二元运算符的内置特型</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>类别</p></th>\n<th><p>特型名称</p></th>\n<th><p>表达式</p></th>\n<th><p>等效表达式</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>算术运算符</p></td>\n<td><p><code>std::ops::Add</code><br /><code>std::ops::Sub</code><br /><code>std::ops::Mul</code><br /><code>std::ops::Div</code><br /><code>std::ops::Rem</code></p></td>\n<td><p><code>x + y</code><br /><code>x - y</code><br /><code>x * y</code><br /><code>x / y</code><br /><code>x % y</code></p></td>\n<td><p><code>x.add(y)</code><br /><code>x.sub(y)</code><br /><code>x.mul(y)</code><br /><code>x.div(y)</code><br /><code>x.rem(y)</code></p></td>\n</tr>\n<tr>\n<td><p>按位运算符</p></td>\n<td><p><code>std::ops::BitAnd</code><br /><code>std::ops::BitOr</code><br /><code>std::ops::BitXor</code><br /><code>std::ops::Shl</code><br /><code>std::ops::Shr</code></p></td>\n<td><p><code>x &amp; y</code><br /><code>x | y</code><br /><code>x ^ y</code><br /><code>x &lt;&lt; y</code><br /><code>x &gt;&gt; y</code></p></td>\n<td><p><code>x.bitand(y)</code><br /><code>x.bitor(y)</code><br /><code>x.bitxor(y)</code><br /><code>x.shl(y)</code><br /><code>x.shr(y)</code></p></td>\n</tr>\n</tbody>\n</table>\n<p>Rust 的所有数值类型都实现了算术运算符。Rust 的整数类型和 <code>bool</code> 类型都实现了按位运算符。此外，还有一些运算符能接受“对这些类型的引用”作为一个或两个操作数。</p>\n<p>这里的所有特型，其一般化形式都是一样的。例如，对于 <code>^</code> 运算符，<code>std::ops::BitXor</code> 的定义如下所示：</p>\n<pre class=\"code-rows\"><code>trait BitXor&lt;Rhs = Self&gt; {\n    type Output;\n    fn bitxor(self, rhs: Rhs) -&gt; Self::Output;\n}</code></pre>\n<p>本章开头还展示过此类别中的另一个特型 <code>std::ops::Add</code>，以及几个范例实现。</p>\n<p>你可以使用 <code>+</code> 运算符将 <code>String</code> 与 <code>&amp;str</code> 切片或另一个 <code>String</code> 连接起来。但是，Rust 不允许 <code>+</code> 的左操作数是 <code>&amp;str</code> 类型，以防止通过在左侧重复接入小型片段来构建长字符串。（这种方式性能不佳，其时间复杂度是字符串最终长度的平方。）一般来说，<code>write!</code> 宏更适合从小型片段构建出字符串，17.3.3 节会展示如何执行此操作。</p>\n<h3 id=\"nav_point_206\">12.1.3　复合赋值运算符</h3>\n<p>复合赋值表达式形如 <code>x += y</code> 或 <code>x &amp;= y</code>：它接受两个操作数，先对它们执行加法或按位与等操作，然后再将结果写回左操作数。在 Rust 中，复合赋值表达式自身的值总是 <code>()</code>，而不是所存入的值。</p>\n<p>许多语言有这样的运算符，并且通常会将它们定义为 <code>x = x + y</code> 或 <code>x = x &amp; y</code> 等表达式的简写形式。但是，Rust 没有采用这种方式。在 Rust 中，<code>x += y</code> 是方法调用 <code>x.add_assign(y)</code> 的简写形式，其中 <code>add_assign</code> 是 <code>std::ops::AddAssign</code> 特型的唯一方法：</p>\n<pre class=\"code-rows\"><code>trait AddAssign&lt;Rhs = Self&gt; {\n    fn add_assign(&amp;mut self, rhs: Rhs);\n}</code></pre>\n<p>表 12-4 展示了 Rust 的所有复合赋值运算符和实现了它们的内置特型。</p>\n<p><strong>表 12-4：复合赋值运算符的内置特型</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>类别</p></th>\n<th><p>特型名称</p></th>\n<th><p>表达式</p></th>\n<th><p>等效表达式</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>算术运算符</p></td>\n<td><p><code>std::ops::AddAssign</code><br /><code>std::ops::SubAssign</code><br /><code>std::ops::MulAssign</code><br /><code>std::ops::DivAssign</code><br /><code>std::ops::RemAssign</code></p></td>\n<td><p><code>x += y</code><br /><code>x -= y</code><br /><code>x \\*= y</code><br /><code>x /= y</code><br /><code>x %= y</code></p></td>\n<td><p><code>x.add_assign(y)</code><br /><code>x.sub_assign(y)</code><br /><code>x.mul_assign(y)</code><br /><code>x.div_assign(y)</code><br /><code>x.rem_assign(y)</code></p></td>\n</tr>\n<tr>\n<td><p>按位运算符</p></td>\n<td><p><code>std::ops::BitAndAssign</code><br /><code>std::ops::BitOrAssign</code><br /><code>std::ops::BitXorAssign</code><br /><code>std::ops::ShlAssign</code><br /><code>std::ops::ShrAssign</code></p></td>\n<td><p><code>x &amp;= y</code><br /><code>x |= y</code><br /><code>x ^= y</code><br /><code>x &lt;&lt;= y</code><br /><code>x &gt;&gt;= y</code></p></td>\n<td><p><code>x.bitand_assign(y)</code><br /><code>x.bitor_assign(y)</code><br /><code>x.bitxor_assign(y)</code><br /><code>x.shl_assign(y)</code><br /><code>x.shr_assign(y)</code></p></td>\n</tr>\n</tbody>\n</table>\n<p>Rust 的所有数值类型都实现了算术复合赋值运算符。Rust 的整数类型和 <code>bool</code> 类型都实现了按位复合赋值运算符。</p>\n<p>为 <code>Complex</code> 类型实现 <code>AddAssign</code> 的泛型代码一目了然：</p>\n<pre class=\"code-rows\"><code>use std::ops::AddAssign;\n\nimpl&lt;T&gt; AddAssign for Complex&lt;T&gt;\nwhere\n    T: AddAssign&lt;T&gt;,\n{\n    fn add_assign(&amp;mut self, rhs: Complex&lt;T&gt;) {\n        self.re += rhs.re;\n        self.im += rhs.im;\n    }\n}</code></pre>\n<p>复合赋值运算符的内置特型完全独立于相应二元运算符的内置特型。实现 <code>std::ops::Add</code> 并不会自动实现 <code>std::ops::AddAssign</code>，如果想让 Rust 允许你的类型作为 <code>+=</code> 运算符的左操作数，就必须自行实现 <code>AddAssign</code>。</p>\n<h2 id=\"nav_point_207\">12.2　相等性比较</h2>\n<p>Rust 的相等性运算符 <code>==</code> 和 <code>!=</code> 是对调用 <code>std::cmp::PartialEq</code> 特型的 <code>eq</code> 和 <code>ne</code> 这两个方法的简写：</p>\n<pre class=\"code-rows\"><code>assert_eq!(x == y, x.eq(&amp;y));\nassert_eq!(x != y, x.ne(&amp;y));</code></pre>\n<p>下面是 <code>std::cmp::PartialEq</code> 的定义：</p>\n<pre class=\"code-rows\"><code>trait PartialEq&lt;Rhs = Self&gt;\nwhere\n    Rhs: ?Sized,\n{\n    fn eq(&amp;self, other: &amp;Rhs) -&gt; bool;\n    fn ne(&amp;self, other: &amp;Rhs) -&gt; bool {\n        !self.eq(other)\n    }\n}</code></pre>\n<p>由于 <code>ne</code> 方法有一个默认定义，因此你只需定义 <code>eq</code> 来实现 <code>PartialEq</code> 特型即可。下面是 <code>Complex</code> 的完整实现：</p>\n<pre class=\"code-rows\"><code>impl&lt;T: PartialEq&gt; PartialEq for Complex&lt;T&gt; {\n    fn eq(&amp;self, other: &amp;Complex&lt;T&gt;) -&gt; bool {\n        self.re == other.re &amp;&amp; self.im == other.im\n    }\n}</code></pre>\n<p>换句话说，对于自身可以做相等性比较的任意组件类型 <code>T</code>，这个实现就能为 <code>Complex&lt;T&gt;</code> 提供比较功能。假设我们还在某处为 <code>Complex</code> 实现了 <code>std::ops::Mul</code>，那么现在就可以这样写了：</p>\n<pre class=\"code-rows\"><code>let x = Complex { re: 5, im: 2 };\nlet y = Complex { re: 2, im: 5 };\nassert_eq!(x * y, Complex { re: 0, im: 29 });</code></pre>\n<p><code>PartialEq</code> 的实现几乎就是这里展示的形式，即将左操作数的每个字段与右操作数的相应字段进行比较。手写这些代码很枯燥，而相等性是一个常见的支持性操作，所以只要提出要求，Rust 就会自动为你生成一个 <code>PartialEq</code> 的实现。只需把 <code>PartialEq</code> 添加到类型定义的 <code>derive</code> 属性中即可，如下所示：</p>\n<pre class=\"code-rows\"><code>#[derive(Clone, Copy, Debug, PartialEq)]\nstruct Complex&lt;T&gt; {\n    ...\n}</code></pre>\n<p>Rust 自动生成的实现与手写的代码本质上是一样的，都会依次比较每个字段或类型的元素。Rust 还可以为 <code>enum</code> 类型派生出 <code>PartialEq</code> 实现。同样，该类型含有（对于 <code>enum</code> 则是所有可能含有）的每个值本身必须实现 <code>PartialEq</code>。</p>\n<p>与按值获取操作数的算术特型和按位运算特型不同，<code>PartialEq</code> 会通过引用获取其操作数。这意味着在比较诸如 <code>String</code>、<code>Vec</code> 或 <code>HashMap</code> 之类的非 <code>Copy</code> 值时并不会导致它们被移动，否则就会很麻烦：</p>\n<pre class=\"code-rows\"><code>let s = \"d\\x6fv\\x65t\\x61i\\x6c\".to_string();\nlet t = \"\\x64o\\x76e\\x74a\\x69l\".to_string();\nassert!(s == t);  // s和t都是借用来的……\n\n// ……所以，在这里它们仍然拥有自己的值\nassert_eq!(format!(\"{} {}\", s, t), \"dovetail dovetail\");</code></pre>\n<p>注意 <code>Rhs</code> 类型参数上的特型限界，这是一种我们从未见过的类型：</p>\n<pre class=\"code-rows\"><code>where\n    Rhs: ?Sized,</code></pre>\n<p>这放宽了 Rust 对类型参数必须有固定大小的常规要求，能让我们写出像 <code>PartialEq&lt;str&gt;</code> 或 <code>PartialEq&lt;[T]&gt;</code> 这样的特型。<code>eq</code> 方法和 <code>ne</code> 方法会接受 <code>&amp;Rhs</code> 类型的参数，因为将某些类型的值与 <code>&amp;str</code> 或 <code>&amp;[T]</code> 进行比较是完全合理的。由于 <code>str</code> 实现了 <code>PartialEq&lt;str&gt;</code>，因此以下断言是等效的：</p>\n<pre class=\"code-rows\"><code>assert!(\"ungula\" != \"ungulate\");\nassert!(\"ungula\".ne(\"ungulate\"));</code></pre>\n<p>在这里，<code>Self</code> 和 <code>Rhs</code> 都是无固定大小类型 <code>str</code>，这就令 <code>ne</code> 的 <code>self</code> 参数和 <code>rhs</code> 参数都是 <code>&amp;str</code> 值。13.2 节会详细讨论固定大小类型、无固定大小类型和 <code>Sized</code> 特型。</p>\n<p>为什么这个特型叫作 <code>PartialEq</code>？这是因为<strong>等价关系</strong>（相等就是其中之一）的传统数学定义提出了 3 个要求。对于任意值 <code>x</code> 和 <code>y</code>，需满足以下条件。</p>\n<ul>\n<li>如果 <code>x == y</code> 为真，则 <code>y == x</code> 也必然为真。换句话说，交换相等性比较的两个操作数不会影响比较结果。</li>\n<li>如果 <code>x == y</code> 且 <code>y == z</code>，则 <code>x == z</code> 一定成立。给定任何值组成的链，其中的每个值必然等于下一个值，链中的每个值都直接等于其他值。相等性是可传递的。</li>\n<li><code>x == x</code> 必须始终为真。</li>\n</ul>\n<p>最后一个要求可能看起来过于显而易见而不值一提，但这正是容易出错的地方。Rust 的 <code>f32</code> 和 <code>f64</code> 是 IEEE 标准浮点值。根据该标准，像 <code>0.0/0.0</code> 和其他没有适当值的表达式必须生成特殊的<strong>非数值</strong>，通常叫作 NaN 值。该标准进一步要求将 NaN 值视为与包括其自身在内的所有其他值都不相等。例如，标准要求以下所有断言都成立：</p>\n<pre class=\"code-rows\"><code>assert!(f64::is_nan(0.0 / 0.0));\nassert_eq!(0.0 / 0.0 == 0.0 / 0.0, false);\nassert_eq!(0.0 / 0.0 != 0.0 / 0.0, true);</code></pre>\n<p>此外，任何值与 NaN 值进行有序比较都必须返回 <code>false</code>：</p>\n<pre class=\"code-rows\"><code>assert_eq!(0.0 / 0.0 &lt; 0.0 / 0.0, false);\nassert_eq!(0.0 / 0.0 &gt; 0.0 / 0.0, false);\nassert_eq!(0.0 / 0.0 &lt;= 0.0 / 0.0, false);\nassert_eq!(0.0 / 0.0 &gt;= 0.0 / 0.0, false);</code></pre>\n<p>因此，虽然 Rust 的 <code>==</code> 运算符满足等价关系的前两个要求，但当用于 IEEE 浮点值时，它显然不满足第三个要求。这称为<strong>部分相等关系</strong>，因此 Rust 使用名称 <code>PartialEq</code> 作为 <code>==</code> 运算符的内置特型。如果要用仅支持 <code>PartialEq</code> 类型的参数编写泛型代码，那么可以假设前两个要求一定成立，但不应假设任何值一定等于它自身。</p>\n<p>这有点儿反直觉，如果不提高警惕，就可能带来 bug。如果你的泛型代码想要“完全相等”关系，那么可以改用 <code>std::cmp::Eq</code> 特型作为限界，它表示完全相等关系：如果类型实现了 <code>Eq</code>，则对于该类型的每个值 <code>x</code>，<code>x == x</code> 都必须为 <code>true</code>。实际上，几乎所有实现了 <code>PartialEq</code> 的类型都实现了 <code>Eq</code>，而 <code>f32</code> 和 <code>f64</code> 是标准库中仅有的两个属于 <code>PartialEq</code> 却不属于 <code>Eq</code> 的类型。</p>\n<p>标准库将 <code>Eq</code> 定义为 <code>PartialEq</code> 的扩展，而且未添加新方法：</p>\n<pre class=\"code-rows\"><code>trait Eq: PartialEq&lt;Self&gt; {}</code></pre>\n<p>如果你的类型是 <code>PartialEq</code> 并且希望它也是 <code>Eq</code>，就必须显式实现 <code>Eq</code>，不过你并不需要实际为此定义任何新函数或类型。所以要为 <code>Complex</code> 类型实现 <code>Eq</code> 很简单：</p>\n<pre class=\"code-rows\"><code>impl&lt;T: Eq&gt; Eq for Complex&lt;T&gt; {}</code></pre>\n<p>甚至可以通过在 <code>Complex</code> 类型定义的 <code>derive</code> 属性中包含 <code>Eq</code> 来更简洁地实现它：</p>\n<pre class=\"code-rows\"><code>#[derive(Clone, Copy, Debug, Eq, PartialEq)]\nstruct Complex&lt;T&gt; {\n    ...\n}</code></pre>\n<p>泛型类型的派生实现可能取决于类型参数。使用 <code>derive</code> 属性，<code>Complex&lt;i32&gt;</code> 将实现 <code>Eq</code>，因为 <code>i32</code> 实现了它，但 <code>Complex&lt;f32&gt;</code> 只能实现 <code>PartialEq</code>，因为 <code>f32</code> 没有实现 <code>Eq</code>。</p>\n<p>当你自己实现 <code>std::cmp::PartialEq</code> 时，Rust 无法检查你对 <code>eq</code> 方法和 <code>ne</code> 方法的定义是否真的符合部分相等或完全相等的要求。你的实现可以“为所欲为”。Rust 只会接受你给出的结果，因为它假设你已经以满足特型用户期望的方式实现了相等性。</p>\n<p>尽管 <code>PartialEq</code> 已经为 <code>ne</code> 提供了默认定义，但你也可以根据需要提供自己的实现。不过，你必须确保 <code>ne</code> 和 <code>eq</code> 彼此精确互补，因为 <code>PartialEq</code> 特型的用户会认为理当如此。</p>\n<h2 id=\"nav_point_208\">12.3　有序比较</h2>\n<p>Rust 会根据单个特型 <code>std::cmp::PartialOrd</code> 来定义全部的有序比较运算符 <code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code> 和 <code>&gt;=</code> 的行为：</p>\n<pre class=\"code-rows\"><code>trait PartialOrd&lt;Rhs = Self&gt;: PartialEq&lt;Rhs&gt;\nwhere\n    Rhs: ?Sized,\n{\n    fn partial_cmp(&amp;self, other: &amp;Rhs) -&gt; Option&lt;Ordering&gt;;\n    fn lt(&amp;self, other: &amp;Rhs) -&gt; bool { ... }\n    fn le(&amp;self, other: &amp;Rhs) -&gt; bool { ... }\n    fn gt(&amp;self, other: &amp;Rhs) -&gt; bool { ... }\n    fn ge(&amp;self, other: &amp;Rhs) -&gt; bool { ... }\n}</code></pre>\n<p>请注意，<code>PartialOrd&lt;Rhs&gt;</code> 扩展了 <code>PartialEq&lt;Rhs&gt;</code>：只有可以比较相等性的类型才能比较顺序性。</p>\n<p><code>PartialOrd</code> 中必须自行实现的唯一方法是 <code>partial_cmp</code>。当 <code>partial_cmp</code> 返回 <code>Some(o)</code> 时，<code>o</code> 应该指出 <code>self</code> 与 <code>other</code> 之间的关系：</p>\n<pre class=\"code-rows\"><code>enum Ordering {\n    Less,       // self &lt; other\n    Equal,      // self == other\n    Greater,    // self &gt; other\n}</code></pre>\n<p>但是如果 <code>partial_cmp</code> 返回 <code>None</code>，那么就意味着 <code>self</code> 和 <code>other</code> 相对于彼此是无序的，即两者都不大于对方，但也不相等。在 Rust 的所有原始类型中，只有浮点值之间的比较会返回 <code>None</code>：具体来说，将 NaN 值与任何其他值进行比较都会返回 <code>None</code>。有关 NaN 值的更多背景知识，请参见 12.2 节。</p>\n<p>和其他二元运算符一样，如果要比较 <code>Left</code> 和 <code>Right</code> 这两种类型的值，那么 <code>Left</code> 就必须实现 <code>PartialOrd&lt;Right&gt;</code>。像 <code>x &lt; y</code> 或 <code>x &gt;= y</code> 这样的表达式都是调用 <code>PartialOrd</code> 方法的简写形式，如表 12-5 所示。</p>\n<p><strong>表 12-5：有序比较运算符和 <code>PartialOrd</code> 方法</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>表达式</p></th>\n<th><p>相等性方法调用</p></th>\n<th><p>默认定义</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>x &lt; y</code></p></td>\n<td><p><code>x.lt(y)</code></p></td>\n<td><p><code>x.partial_cmp(&amp;y) == Some(Less)</code></p></td>\n</tr>\n<tr>\n<td><p><code>x &gt; y</code></p></td>\n<td><p><code>x.gt(y)</code></p></td>\n<td><p><code>x.partial_cmp(&amp;y) == Some(Greater)</code></p></td>\n</tr>\n<tr>\n<td><p><code>x &lt;= y</code></p></td>\n<td><p><code>x.le(y)</code></p></td>\n<td><p><code>matches!(x.partial_cmp(&amp;y), Some(Less | Equal))</code></p></td>\n</tr>\n<tr>\n<td><p><code>x &gt;= y</code></p></td>\n<td><p><code>x.ge(y)</code></p></td>\n<td><p><code>matches!(x.partial_cmp(&amp;y), Some(Greater | Equal))</code></p></td>\n</tr>\n</tbody>\n</table>\n<p>与前面的示例一样，这里的相等性方法调用代码也假定当前作用域中已经引入了 <code>std::cmp::PartialOrd</code> 和 <code>std::cmp::Ordering</code>。</p>\n<p>如果你知道两种类型的值总能确定相对于彼此的顺序，那么就可以实现更严格的 <code>std::cmp::Ord</code> 特型：</p>\n<pre class=\"code-rows\"><code>trait Ord: Eq + PartialOrd&lt;Self&gt; {\n    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering;\n}</code></pre>\n<p>这里的 <code>cmp</code> 方法只会返回 <code>Ordering</code>，而不会像 <code>partial_cmp</code> 那样返回 <code>Option&lt;Ordering&gt;</code>：<code>cmp</code> 总会声明它的两个参数相等或指出它们的相对顺序。几乎所有实现了 <code>PartialOrd</code> 的类型都应该实现 <code>Ord</code>。在标准库中，<code>f32</code> 和 <code>f64</code> 是该规则的例外情况。</p>\n<p>由于复数没有自然顺序，因此我们无法使用前几节中的 <code>Complex</code> 类型来展示 <code>PartialOrd</code> 的示例实现。相反，假设你正在使用以下类型表示落在给定左闭右开区间内的一组数值：</p>\n<pre class=\"code-rows\"><code>#[derive(Debug, PartialEq)]\nstruct Interval&lt;T&gt; {\n    lower: T, // 闭区间\n    upper: T, // 开区间\n}</code></pre>\n<p>你希望对这种类型的值进行部分排序，即如果一个区间完全落在另一个区间之前，并且没有重叠，则认为这个区间小于另一个区间。如果两个不相等的区间有重叠（每一侧都有某些元素小于另一侧的某些元素），则认为它们是无序的。而两个相等的区间必然是完全相等的。以下 <code>PartialOrd</code> 代码实现了这些规则：</p>\n<pre class=\"code-rows\"><code>use std::cmp::;\n\nimpl&lt;T: PartialOrd&gt; PartialOrd&lt;Interval&lt;T&gt;&gt; for Interval&lt;T&gt; {\n    fn partial_cmp(&amp;self, other: &amp;Interval&lt;T&gt;) -&gt; Option&lt;Ordering&gt; {\n        if self == other {\n            Some(Ordering::Equal)\n        } else if self.lower &gt;= other.upper {\n            Some(Ordering::Greater)\n        } else if self.upper &lt;= other.lower {\n            Some(Ordering::Less)\n        } else {\n            None\n        }\n    }\n}</code></pre>\n<p>有了这个实现，你就可以写出如下代码了：</p>\n<pre class=\"code-rows\"><code>assert!(Interval { lower: 10, upper: 20 } &lt;  Interval { lower: 20, upper: 40 });\nassert!(Interval { lower: 7,  upper: 8  } &gt;= Interval { lower: 0,  upper: 1  });\nassert!(Interval { lower: 7,  upper: 8  } &lt;= Interval { lower: 7,  upper: 8  });\n\n// 两个存在重叠的区间相对彼此没有顺序可言\nlet left  = Interval { lower: 10, upper: 30 };\nlet right = Interval { lower: 20, upper: 40 };\nassert!(!(left &lt; right));\nassert!(!(left &gt;= right));</code></pre>\n<p>虽然通常我们会使用 <code>PartialOrd</code>，但在某些情况下，用 <code>Ord</code> 定义的完全排序也是有必要的，比如在标准库中实现的那些排序方法。但不可能仅通过 <code>PartialOrd</code> 来对区间进行排序。如果你确实想对它们进行排序，则必须想办法填补这些无法确定顺序的情况。如果你希望按上限排序，那么很容易用 <code>sort_by_key</code> 来实现：</p>\n<pre class=\"code-rows\"><code>intervals.sort_by_key(|i| i.upper);</code></pre>\n<p>包装器类型 <code>Reverse</code> 就利用了这一点，借助一个简单的逆转任何顺序的方法来实现 <code>Ord</code>。对于任何实现了 <code>Ord</code> 的类型 <code>T</code>，<code>std::cmp::Reverse&lt;T&gt;</code> 也会实现 <code>Ord</code>，只是顺序相反。例如，可以简单地按下限从高到低对这些区间进行排序。</p>\n<pre class=\"code-rows\"><code>use std::cmp::Reverse;\nintervals.sort_by_key(|i| Reverse(i.lower));</code></pre>\n<h2 id=\"nav_point_209\">12.4　<code>Index</code> 与 <code>IndexMut</code></h2>\n<p>通过实现 <code>std::ops::Index</code> 特型和 <code>std::ops::IndexMut</code> 特型，你可以规定像 <code>a[i]</code> 这样的索引表达式该如何作用于你的类型。数组可以直接支持 <code>[]</code> 运算符，但对其他类型来说，表达式 <code>a[i]</code> 通常是 <code>*a.index(i)</code> 的简写形式，其中 <code>index</code> 是 <code>std::ops::Index</code> 特型的方法。但是，如果表达式被赋值或借用成了可变形式，那么 <code>a[i]</code> 就是对调用 <code>std::ops::IndexMut</code> 特型方法的 <code>*a.index_mut(i)</code> 的简写。</p>\n<p>以下是 <code>Index</code> 和 <code>IndexMut</code> 这两个特型的定义：</p>\n<pre class=\"code-rows\"><code>trait Index&lt;Idx&gt; {\n    type Output: ?Sized;\n    fn index(&amp;self, index: Idx) -&gt; &amp;Self::Output;\n}\n\ntrait IndexMut&lt;Idx&gt;: Index&lt;Idx&gt; {\n    fn index_mut(&amp;mut self, index: Idx) -&gt; &amp;mut Self::Output;\n}</code></pre>\n<p>请注意，这些特型会以索引表达式的类型作为参数。你可以使用单个 <code>usize</code> 对切片进行索引，以引用单个元素，因为切片实现了 <code>Index&lt;usize&gt;</code>。还可以使用像 <code>a[i..j]</code> 这样的表达式来引用子切片，因为切片也实现了 <code>Index&lt;Range&lt;usize&gt;&gt;</code>。该表达式是以下内容的简写形式：</p>\n<pre class=\"code-rows\"><code>*a.index(std::ops::Range { start: i, end: j })</code></pre>\n<p>Rust 的 <code>HashMap</code> 集合和 <code>BTreeMap</code> 集合允许使用任何可哈希类型或有序类型作为索引。以下代码之所以能运行，是因为 <code>HashMap&lt;&amp;str, i32&gt;</code> 实现了 <code>Index&lt;&amp;str&gt;</code>：</p>\n<pre class=\"code-rows\"><code>use std::collections::HashMap;\nlet mut m = HashMap::new();\nm.insert(\"十\", 10);\nm.insert(\"百\", 100);\nm.insert(\"千\", 1000);\nm.insert(\"万\", 1_0000);\nm.insert(\"億\", 1_0000_0000);\n\nassert_eq!(m[\"十\"], 10);\nassert_eq!(m[\"千\"], 1000);</code></pre>\n<p>这些索引表达式等效于如下内容：</p>\n<pre class=\"code-rows\"><code>use std::ops::Index;\nassert_eq!(*m.index(\"十\"), 10);\nassert_eq!(*m.index(\"千\"), 1000);</code></pre>\n<p><code>Index</code> 特型的关联类型 <code>Output</code> 指定了索引表达式要生成的类型：对这个 <code>HashMap</code> 而言，<code>Index</code> 实现的 <code>Output</code> 类型是 <code>i32</code>。</p>\n<p><code>IndexMut</code> 特型使用 <code>index_mut</code> 方法（该方法接受对 <code>self</code> 的可变引用）扩展了 <code>Index</code>，并返回了对 <code>Output</code> 值的可变引用。当索引表达式出现在需要可变引用的上下文中时，Rust 会自动选择 <code>index_mut</code>。假设我们编写了如下代码：</p>\n<pre class=\"code-rows\"><code>let mut desserts =\n    vec![\"Howalon\".to_string(), \"Soan papdi\".to_string()];\ndesserts[0].push_str(\" (fictional)\");\ndesserts[1].push_str(\" (real)\");</code></pre>\n<p>因为 <code>push_str</code> 方法要对 <code>&amp;mut self</code> 进行操作，所以最后两行代码等效于如下内容：</p>\n<pre class=\"code-rows\"><code>use std::ops::IndexMut;\n(*desserts.index_mut(0)).push_str(\" (fictional)\");\n(*desserts.index_mut(1)).push_str(\" (real)\");</code></pre>\n<p><code>IndexMut</code> 有一个限制，即根据设计，它必须返回对某个值的可变引用。这就是不能使用像 <code>m[\" 十 \"] = 10;</code> 这样的表达式来将值插入 <code>m</code> 这个 <code>HashMap</code> 中的原因：该表需要先为 <code>\" 十 \"</code> 创建一个带有默认值的条目，然后再返回一个对它的可变引用。但并不是所有的类型都有开销很低的默认值，有些可能开销很高，创建这么一个马上就会因赋值而被丢弃的值是一种浪费。（Rust 计划在更高版本中对此进行改进。）</p>\n<p>索引最常用于各种集合。假设我们要处理第 2 章中曼德博集绘图器那样的位图图像。当时我们的程序中包含如下代码：</p>\n<pre class=\"code-rows\"><code>pixels[row * bounds.0 + column] = ...;</code></pre>\n<p>如果有一个像二维数组一样的 <code>Image&lt;u8&gt;</code> 类型肯定会更好，这样就可以访问像素而不必写出所有的算法了：</p>\n<pre class=\"code-rows\"><code>image[row][column] = ...;</code></pre>\n<p>为此，需要声明一个结构体：</p>\n<pre class=\"code-rows\"><code>struct Image&lt;P&gt; {\n    width: usize,\n    pixels: Vec&lt;P&gt;,\n}\n\nimpl&lt;P: Default + Copy&gt; Image&lt;P&gt; {\n    /// 创建一个给定大小的新图像\n    fn new(width: usize, height: usize) -&gt; Image&lt;P&gt; {\n        Image {\n            width,\n            pixels: vec![P::default(); width * height],\n        }\n    }\n}</code></pre>\n<p>以下是符合要求的 <code>Index</code> 和 <code>IndexMut</code> 的实现：</p>\n<pre class=\"code-rows\"><code>impl&lt;P&gt; std::ops::Index&lt;usize&gt; for Image&lt;P&gt; {\n    type Output = [P];\n    fn index(&amp;self, row: usize) -&gt; &amp;[P] {\n        let start = row * self.width;\n        &amp;self.pixels[start..start + self.width]\n    }\n}\n\nimpl&lt;P&gt; std::ops::IndexMut&lt;usize&gt; for Image&lt;P&gt; {\n    fn index_mut(&amp;mut self, row: usize) -&gt; &amp;mut [P] {\n        let start = row * self.width;\n        &amp;mut self.pixels[start..start + self.width]\n    }\n}</code></pre>\n<p>对 <code>Image</code> 进行索引时，你会得到一些像素的切片，再索引此切片会返回一个单独的像素。</p>\n<p>请注意，在编写 <code>image[row][column]</code> 时，如果 <code>row</code> 超出范围，那么 <code>.index()</code> 方法在试图索引 <code>self.pixels</code> 时也会超出范围，从而引发 panic。这就是 <code>Index</code> 实现和 <code>IndexMut</code> 实现的行为方式：检测到越界访问并导致 panic，就像索引数组、切片或向量时越界一样。</p>\n<h2 id=\"nav_point_210\">12.5　其他运算符</h2>\n<p>并非所有运算符都可以在 Rust 中重载。从 Rust 1.50 开始，错误检查运算符 <code>?</code> 仅适用于 <code>Result</code> 值和 <code>Option</code> 值，不过 Rust 也在努力将其扩展到用户定义类型。同样，逻辑运算符 <code>&amp;&amp;</code> 和 <code>||</code> 仅限于 <code>bool</code> 值。<code>..</code> 运算符和 <code>..=</code> 运算符总会创建一个表示范围边界的结构体，<code>&amp;</code> 运算符总是会借用引用，<code>=</code> 运算符总是会移动值或复制值。它们都不能重载。</p>\n<p>解引用运算符 <code>*val</code> 和用于访问字段和调用方法的点运算符（如 <code>val.field</code> 和 <code>val.method()</code>）可以用 <code>Deref</code> 特型和 <code>DerefMut</code> 特型进行重载，这将在第 13 章中介绍。（之所以本章没有包含它们，是因为这两个特型不仅仅是重载几个运算符那么简单。）</p>\n<p>Rust 不支持重载函数调用运算符 <code>f(x)</code>。当你需要一个可调用的值时，通常只需编写一个闭包即可。第 14 章将解释它是如何工作的，同时会涵盖 <code>Fn</code>、<code>FnMut</code> 和 <code>FnOnce</code> 这几个特殊特型。</p>\n\n<br style=\"page-break-after:always\" />","comments":[]}