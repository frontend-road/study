{"id":145472,"title":"20 | 高效运行：编译器的后端技术","content":"<p>前18节课，我们主要探讨了编译器的前端技术，它的重点，是让编译器能够读懂程序。无结构的代码文本，经过前端的处理以后，就变成了Token、AST和语义属性、符号表等结构化的信息。基于这些信息，我们可以实现简单的脚本解释器，这也从另一个角度证明了我们的前端处理工作确实理解了程序代码，否则程序不可能正确执行嘛。</p><p>实际上，学完前端技术以后，我们已经能做很多事情了，比如让软件有自定义功能，就像我们在<a href=\"https://time.geekbang.org/column/article/136557\">15讲</a>中提到的报表系统，这时，不需要涉及编译器后端技术。</p><p>但很多情况下，我们需要继续把程序编译成机器能读懂的代码，并高效运行。<strong>这时，我们就面临了三个问题：</strong></p><p>1.我们必须了解计算机运行一个程序的原理（也就是运行期机制），只有这样，才知道如何生成这样的程序。<br>\n2.要能利用前端生成的AST和属性信息，将其正确翻译成目标代码。<br>\n3.需要对程序做尽可能多的优化，比如让程序执行效率更高，占空间更少等等。</p><p>弄清这三个问题，是顺利完成编译器后端工作的关键，本节课，我会让你对程序运行机制、生成代码和优化代码有个直观的了解，然后再在接下来的课程中，将这些问题逐一击破。</p><h2>弄清程序的运行机制</h2><p>总的来说，编译器后端要解决的问题是：现在给你一台计算机，你怎么生成一个可以运行的程序，然后还能让这个程序在计算机上正确和高效地运行？</p><!-- [[[read_end]]] --><p>我画了一个模型：</p><p><img src=\"https://static001.geekbang.org/resource/image/0a/40/0ab606233923bd3904950acf39f6a440.jpg?wh=1142*363\" alt=\"\"></p><p>基本上，我们需要面对的是两个硬件：</p><ul>\n<li>\n<p><strong>一个是CPU，它能接受机器指令和数据，并进行计算。</strong>它里面有寄存器、高速缓存和运算单元，充分利用寄存器和高速缓存会让系统的性能大大提升。</p>\n</li>\n<li>\n<p><strong>另一个是内存。</strong>我们要在内存里保存编译好的代码和数据，还要设计一套机制，让程序最高效地利用这些内存。</p>\n</li>\n</ul><p>通常情况下，我们的程序要受某个操作系统的管理，所以也要符合操作系统的一些约定。但有时候我们的程序也可能直接跑在硬件上，单片机和很多物联网设备采用这样的结构，甚至一些服务端系统，也可以不跑在操作系统上。</p><p>你可以看出，编译器后端技术跟计算机体系结构的关系很密切。我们必须清楚地理解计算机程序是怎么运行的，有了这个基础，才能探讨如何编译生成这样的程序。</p><p>所以，我会在下一节课，也就是<strong>21讲</strong>，将运行期的机制讲清楚，比如内存空间如何划分和组织；程序是如何启动、跳转和退出的；执行过程中指令和数据如何传递到CPU；整个过程中需要如何跟操作系统配合，等等。</p><p>也有的时候，我们的面对的机器是虚拟机，Java的运行环境就是一个虚拟机（JVM），那我们需要就了解这个虚拟机的特点，以便生成可以在这个虚拟机上运行的代码，比如Java的字节码。同时，字节码有时仍然需要编译成机器码。</p><p>在对运行期机制有了一定的了解之后，我们就有底气来进行下一步了，生成符合运行期机制的代码。</p><h2>生成代码</h2><p>编译器后端的最终结果，就是生成目标代码。如果目标是在计算机上直接运行，就像C语言程序那样，那这个目标代码指的是汇编代码。而如果运行目标是Java虚拟机，那这个目标代码就是指JVM的字节码。</p><p>基于我们在编译器前端所生成的成果，我们其实可以直接生成汇编代码，在后面的课程中，我会带你做一个这样的尝试。</p><p>你可能惧怕汇编代码，觉得它肯定很难，能写汇编的人一定很牛。在我看来，这是一个偏见，因为汇编代码并不难写，为什么呢？</p><p>其实汇编没有类型，也没有那么多的语法结构，它要做的通常就是把数据拷贝到寄存器，处理一下，再保存回内存。所以，从汇编语言的特性看，就决定了它不可能复杂到哪儿去。</p><p>你如果问问硬件工程师就知道了，因为他们经常拿汇编语言操作寄存器、调用中断，也没多难。但另一方面，正是因为汇编的基础机制太简单，而且不太安全，用它编写程序的效率太低，所以现在直接用汇编写的程序，都是处理很小、很单一的问题，我们不会再像阿波罗登月计划那样，用汇编写整个系统，这个项目的代码最近已经开源了，如果现在用高级语言去做这项工作，会容易得多，还可以像现在的汽车自动驾驶系统一样实现更多的功能。</p><p>所以，<strong>在22和23讲</strong>，我会带你从AST直接翻译成汇编代码，并编译成可执行文件，这样你就会看到这个过程没有你想象的那么困难，你对汇编代码的恐惧感，也会就此消失了。</p><p>当然，写汇编跟使用高级语言有很多不同，<strong>其中一点就是要关心CPU和内存这样具体的硬件。</strong>比如，你需要了解不同的CPU指令集的差别，你还需要知道CPU是64位的还是32位的，有几个寄存器，每个寄存器可以用于什么指令，等等。但这样导致的问题是，每种语言，针对每种不同的硬件，都要生成不同的汇编代码。你想想看，一般我们设计一门语言要支持尽可能多的硬件平台，这样的工作量是不是很庞大？</p><p>所以，为了降低后端工作量，提高软件复用度，就需要引入<strong>中间代码（Intermediate Representation，IR）的机制</strong>，它是独立于具体硬件的一种代码格式。各个语言的前端可以先翻译成IR，然后再从IR翻译成不同硬件架构的汇编代码。如果有n个前端语言，m个后端架构，本来需要做m*n个翻译程序，现在只需要m+n个了。这就大大降低了总体的工作量。</p><p><img src=\"https://static001.geekbang.org/resource/image/23/ea/23578fc6e348e79876bdeb90f0ee30ea.jpg?wh=1142*366\" alt=\"\"></p><p>甚至，很多语言主要做好前端就行了，后端可以尽量重用已有的库和工具，这也是现在推出新语言越来越快的原因之一。像Rust就充分利用了LLVM，GCC的各种语言，如C、C++、Object C等，也是充分共享了后端技术。</p><p>IR可以有多种格式，在第24讲，我们会介绍三地址代码、静态单赋值码等不同的IR。比如，“x + y * z”翻译成三地址代码是下面的样子，每行代码最多涉及三个地址，其中t1和t2是临时变量：</p><pre><code>t1 := y * z\nt2 := x + t1\n</code></pre><p>Java语言生成的字节码也是一种IR，我们还会介绍LLVM的IR，并且基于LLVM这个工具来加速我们后端的开发。</p><p>其实，IR这个词直译成中文，是“中间表示方式”的意思，不一定非是像汇编代码那样的一条条的指令。所以，AST其实也可以看做一种IR。我们在前端部分实现的脚本语言，就是基于AST这个IR来运行的。</p><p>每种IR的目的和用途是不一样的：</p><ul>\n<li>AST主要用于前端的工作。</li>\n<li>Java的字节码，是设计用来在虚拟机上运行的。</li>\n<li>LLVM的中间代码，主要是用于做代码翻译和编译优化的。</li>\n<li>……</li>\n</ul><p>总的来说，我们可以把各种语言翻译成中间代码，再针对每一种目标架构，通过一个程序将中间代码翻译成相应的汇编代码就可以了。然而事情真的这么简单吗？答案是否定的，因为我们还必须对代码进行优化。</p><h2>代码分析和优化</h2><p>生成正确的、能够执行的代码比较简单，可这样的代码执行效率很低，因为直接翻译生成的代码往往不够简洁，比如会生成大量的临时变量，指令数量也较多。因为翻译程序首先照顾的是正确性，很难同时兼顾是否足够优化，这是一方面。另一方面，由于高级语言本身的限制和程序员的编程习惯，也会导致代码不够优化，不能充分发挥计算机的性能。所以我们一定要对代码做优化。程序员在比较各种语言的时候，一定会比较它们的性能差异。一个语言的性能太差，就会影响它的使用和普及。</p><p>实际上，就算是现在常见的脚本语言，如Python和JavaScript，也做了很多后端优化的工作，包括编译成字节码、支持即时编译等，这些都是为了进一步提高性能。从谷歌支持的开源项目V8开始，JavaScript的性能获得了巨大的提高，这才导致了JavaScript再一次的繁荣，包括支持体验更好的前端应用和基于Node.js的后端应用。</p><p>优化工作又分为<strong>“独立于机器的优化”和“依赖于机器的优化”</strong>两种。</p><p>独立于机器的优化，是基于IR进行的。它可以通过对代码的分析，用更加高效的代码代替原来的代码。比如下面这段代码中的foo()函数，里面有多个地方可以优化。甚至，我们连整个对foo()函数的调用，也可以省略，因为foo()的值一定是101。这些优化工作在编译期都可以去做。</p><pre><code>int foo(){\n    int a = 10*10;  //这里在编译时可以直接计算出100这个值\n    int b = 20;     //这个变量没有用到，可以在代码中删除\n\n    if (a&gt;0){       //因为a一定大于0，所以判断条件和else语句都可以去掉\n        return a+1; //这里可以在编译器就计算出是101\n    }\n    else{\n        return a-1;\n    }\n}\nint a = foo();      //这里可以直接地换成 a=101;\n</code></pre><p>上面的代码，通过优化，可以消除很多冗余的逻辑。这就好比你正在旅行，先从北京飞到了上海，然后又飞到厦门，最后飞回北京。然后你朋友问你现在在哪时，你告诉他在北京。那么他虽然知道你在北京，但并没有意识到你已经在几个城市折腾了一圈，因为他只关心你现在在哪儿，并不关心你的中间过程。 我们在给a赋值的时候，只需要知道这个值是101就行了。完全不需要在运行时去兜一大圈来计算。</p><p>计算机代码里有很多这种需要优化的情形。我们在27和28讲会介绍多种优化技术，比如局部优化和全局优化，常数折叠、拷贝传播、删除公共子表达式等，其中数据流分析方法比较重要，会重点介绍。</p><p><strong>依赖于机器的优化，则是依赖于硬件的特征。</strong>现代的计算机硬件设计了很多特性，以便提供更高的处理能力，比如并行计算能力，多层次内存结构（使用多个级别的高速缓存）等等。编译器要能够充分利用硬件提供的性能，比如 ：</p><ul>\n<li>\n<p><strong>寄存器优化。</strong>对于频繁访问的变量，最好放在寄存器中，并且尽量最大限度地利用寄存器，不让其中一些空着，有不少算法是解决这个问题的，教材上一般提到的是染色算法；</p>\n</li>\n<li>\n<p><strong>充分利用高速缓存。</strong>高速缓存的访问速度可以比内存快几十倍上百倍，所以我们要尽量利用高速缓存。比如，某段代码操作的数据，在内存里尽量放在一起，这样CPU读入数据时，会一起都放到高速缓存中，不用一遍一遍地重新到内存取。</p>\n</li>\n<li>\n<p><strong>并行性。</strong>现代计算机都有多个内核，可以并行计算。我们的编译器要尽可能把充分利用多个内核的计算能力。 这在编译技术中是一个专门的领域。</p>\n</li>\n<li>\n<p><strong>流水线。</strong>CPU在处理不同的指令的时候，需要等待的时间周期是不一样的，在等待某些指令做完的过程中其实还可以执行其他指令。就比如在星巴克买咖啡，交了钱就可以去等了，收银员可以先去处理下一个顾客，而不是要等到前一个顾客拿到咖啡才开始处理下一个顾客。</p>\n</li>\n<li>\n<p><strong>指令选择。</strong>有的时候，CPU完成一个功能，有多个指令可供选择。而针对某个特定的需求，采用A指令可能比B指令效率高百倍。比如X86架构的CPU提供SIMD功能，也就是一条指令可以处理多条数据，而不是像传统指令那样一条指令只能处理一条数据。在内存计算领域，SIMD也可以大大提升性能，我们在第30讲的应用篇，会针对SIMD做一个实验。</p>\n</li>\n<li>\n<p><strong>其他优化。</strong>比如可以针对专用的AI芯片和GPU做优化，提供AI计算能力，等等。</p>\n</li>\n</ul><p>可以看出来，做好依赖于机器的优化要对目标机器的体系结构有清晰的理解，如果能做好这些工作，那么开发一些系统级的软件也会更加得心应手。实际上，数据库系统、大数据系统等等，都是要融合编译技术的。</p><p>总结起来，在编译器中需要对代码进行的优化非常多。因此，这部分工作也是编译过程中耗时最长、最体现某个编译器的功力的一类工作，所以更值得引起你的重视。</p><h2>课程小结</h2><p>本节课，我们对编译器的后端技术做了概述。你了解到要做好后端工作，必须熟悉计算机体系结构和程序的运行时机制；还要从前端生成中间代码，然后基于中间代码生成针对不同平台的目标代码；最后，需要对代码做各种优化工作，包括独立于机器的优化和依赖于机器的优化。</p><p>刚接触编译技术的时候，你可能会把视线停留在前端技术上，以为能做Lexer、Parser就是懂编译了。实际上，词法分析和语法分析比较成熟，有成熟的工具来支撑。<strong>相对来说，后端的工作量更大，挑战更多，研究的热点也更多。</strong>比如，人工智能领域又出现了一些专用的AI芯片和指令集，就需要去适配。</p><p>编译器的后端，要把高级语言翻译成计算机能够理解的目标语言。它跟前端相比，关注点是不同的。前端关注的是正确反映了代码含义的静态结构，而后端关注的是让代码良好运行的动态结构。它们之间的差别，从我讲解“作用域”和“生存期”两个概念时就能看出来。作用域是前端的概念，而生存期是后端的概念。</p><p>其实在前面的课程中，我们已经涉及了少量的后端技术的概念，比如生存期、栈桢，因为我们要让脚本语言运行起来。但这个运行环境比较简单，脚本的执行也是简单的基于AST，所以性能是比较低的。但在后端部分，我们会实现一门静态编译型的语言，因此会对对运行期机制做更加深入的解读和实现。</p><p>如果能把后端技术学好，你对计算机底层运行机制的理解会更上一层楼，也会成为一名底子更加扎实的软件工程师。</p><h2>一课一思</h2><p>我们说编译器后端的任务是让程序适配硬件、高效运行。对于你所熟悉的程序语言，它的后端技术有什么特点呢？比如它采用了哪些技术使得性能更高，或者代码尺寸更小，或者能更好地兼容硬件？欢迎在留言区分享你的经验和观点。</p><p>最后，感谢你的阅读，如果这篇文章让你有所收获，也欢迎你将它分享给更多的朋友。</p><p></p>","neighbors":{"left":{"article_title":"期中考试 |  来赴一场100分的约定吧！","id":143135},"right":{"article_title":"21 | 运行时机制：突破现象看本质，透过语法看运行时","id":146635}},"comments":[{"had_liked":false,"id":139153,"user_name":"阿鼎","can_delete":false,"product_type":"c1","uid":1042634,"ip_address":"","ucode":"EE763513563F50","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e8/ca/2a7cc193.jpg","comment_is_top":false,"comment_ctime":1570576218,"is_pvip":false,"replies":[{"id":"53811","content":"我认为有三方面：<br>1.如果要写一门真实使用的计算机语言，或者参与类似数据库软件之类的基础软件的开发，还是要把代码编译成字节码或机器码的，所以就需要后端技术。<br>2.有助于你做系统的深层优化和性能调优。淘宝的底层技术团队就曾关注Java即时编译功能，甚至还给Oracle提交了补丁。<br>3.从知识方面，会帮你更加理解软件运行的机制，从而对于你设计任何软件、以及设计大型系统的架构都有好处。<br>","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1570675498,"ip_address":"","comment_id":139153,"utype":1}],"discussion_count":1,"race_medal":0,"score":"57405151066","product_id":100034101,"comment_content":"老师，后段技术在实际的项目中，有什么应用？","like_count":14,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469815,"discussion_content":"我认为有三方面：\n1.如果要写一门真实使用的计算机语言，或者参与类似数据库软件之类的基础软件的开发，还是要把代码编译成字节码或机器码的，所以就需要后端技术。\n2.有助于你做系统的深层优化和性能调优。淘宝的底层技术团队就曾关注Java即时编译功能，甚至还给Oracle提交了补丁。\n3.从知识方面，会帮你更加理解软件运行的机制，从而对于你设计任何软件、以及设计大型系统的架构都有好处。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570675498,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144847,"user_name":"nil","can_delete":false,"product_type":"c1","uid":1507193,"ip_address":"","ucode":"0F5D298C1CBB74","user_header":"https://static001.geekbang.org/account/avatar/00/16/ff/79/3b38c9e1.jpg","comment_is_top":false,"comment_ctime":1572073157,"is_pvip":false,"replies":[{"id":"57531","content":"是的，没错。感谢分享你的感受。<br><br>计算机架构里，经常出现这种中间层。中间件起这个作用，JVM也起这个作用。还有很多这种异曲同工的东西。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1573302602,"ip_address":"","comment_id":144847,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35931811525","product_id":100034101,"comment_content":"把前端的ast转化成中间形式确是个漂亮的做法，可以隔离前后端之间的耦合。后端可以面向ir实现。针对不同的硬件平台，实现不同的后端编译程序。这让我想到网络协议中的ip协议。ip协议被设计成沙漏，或者说细腰结构，就是为了减少上下游之间的耦合，应用层和数据链路层中的协议多种多样，但是网络层协议基本是稳定的，ip协议和ir我感觉有着异曲同工之妙！","like_count":9,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472134,"discussion_content":"是的，没错。感谢分享你的感受。\n\n计算机架构里，经常出现这种中间层。中间件起这个作用，JVM也起这个作用。还有很多这种异曲同工的东西。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573302602,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":275067,"user_name":"A君","can_delete":false,"product_type":"c1","uid":1940105,"ip_address":"","ucode":"FE96F089C2312C","user_header":"https://static001.geekbang.org/account/avatar/00/1d/9a/89/babe8b52.jpg","comment_is_top":false,"comment_ctime":1611296276,"is_pvip":true,"replies":[{"id":"102121","content":"总结得简单清晰！","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1614651315,"ip_address":"","comment_id":275067,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18791165460","product_id":100034101,"comment_content":"前端的任务是生成AST，后端的任务有两个，一个是优化AST，剔除掉冗余操作；第二个是生成充分利用机器特性的目标代码。","like_count":4,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514204,"discussion_content":"总结得简单清晰！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614651315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":193464,"user_name":"Xylitol","can_delete":false,"product_type":"c1","uid":1008853,"ip_address":"","ucode":"B870615547C78A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/64/d5/bfb24dbb.jpg","comment_is_top":false,"comment_ctime":1584895734,"is_pvip":false,"replies":[{"id":"74120","content":"确实，我这几年是潜伏在厦门东坪山~~~<br>你可以搜我的微博（虽然我很少更新），发信息约起~~~","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1585125665,"ip_address":"","comment_id":193464,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14469797622","product_id":100034101,"comment_content":"博主是厦门人？可以交个朋友～","like_count":4,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488562,"discussion_content":"确实，我这几年是潜伏在厦门东坪山~~~\n你可以搜我的微博（虽然我很少更新），发信息约起~~~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585125665,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217354,"user_name":"刘桢","can_delete":false,"product_type":"c1","uid":1482815,"ip_address":"","ucode":"3BFAB1C9772EB4","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/3f/06b690ba.jpg","comment_is_top":false,"comment_ctime":1589468650,"is_pvip":false,"replies":[{"id":"80936","content":"好在我们不会拿考试压迫同学们:-)<br>学好后端，可以结合你之前学过的组原、操作系统、汇编的知识，基本上就把计算机的运行原理都搞透了。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1589941231,"ip_address":"","comment_id":217354,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10179403242","product_id":100034101,"comment_content":"后端还是难的呀，考研学组原脑袋都大了","like_count":3,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495119,"discussion_content":"好在我们不会拿考试压迫同学们:-)\n学好后端，可以结合你之前学过的组原、操作系统、汇编的知识，基本上就把计算机的运行原理都搞透了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589941231,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":272158,"user_name":"。","can_delete":false,"product_type":"c1","uid":2239834,"ip_address":"","ucode":"9B7C71BBEF7C14","user_header":"https://static001.geekbang.org/account/avatar/00/22/2d/5a/380efdec.jpg","comment_is_top":false,"comment_ctime":1609951221,"is_pvip":false,"replies":[{"id":"98901","content":"在支持并发的时候，像C语言这样的语言，是不太需要编译器支持的。但对很多现代语言，都需要编译器和运行时配合才行。<br>1.并发中的同步互斥<br>像Java这样的语言，提供了像synchronized、volatile这样的关键字，在多个线程之间实现同步互斥。这个时候，编译器要生成相应的汇编代码。<br>2.对协程、Actor等并发模式的支持<br>除了线程之外，还有其他的并发模式，比如协程、Actor等。这个时候，编译器要生成一些代码，跟运行时协作，来进行并发调度。<br>在《编译原理实战课》中，专门有关于并发的内容，有三讲的内容讲解并发中的编译技术，会说得比较细。你可以去看一下。在介绍Go语言等编译器的时候，也介绍了这门语言的编译器是如何支持并发的。<br>总的来说，现代语言的内存管理（含垃圾收集）、并发等特性，都需要编译器的密切参与才可以。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1610333325,"ip_address":"","comment_id":272158,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5904918517","product_id":100034101,"comment_content":"老师，一般我们都是在代码中实现多线程（也就是多核心的控制？），那么此处编译器后端所提到的并行性中的多个核心又具体是怎样的呢？","like_count":1,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513182,"discussion_content":"在支持并发的时候，像C语言这样的语言，是不太需要编译器支持的。但对很多现代语言，都需要编译器和运行时配合才行。\n1.并发中的同步互斥\n像Java这样的语言，提供了像synchronized、volatile这样的关键字，在多个线程之间实现同步互斥。这个时候，编译器要生成相应的汇编代码。\n2.对协程、Actor等并发模式的支持\n除了线程之外，还有其他的并发模式，比如协程、Actor等。这个时候，编译器要生成一些代码，跟运行时协作，来进行并发调度。\n在《编译原理实战课》中，专门有关于并发的内容，有三讲的内容讲解并发中的编译技术，会说得比较细。你可以去看一下。在介绍Go语言等编译器的时候，也介绍了这门语言的编译器是如何支持并发的。\n总的来说，现代语言的内存管理（含垃圾收集）、并发等特性，都需要编译器的密切参与才可以。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610333325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1042842,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e9/9a/1d9e1d9a.jpg","nickname":"北极点","note":"","ucode":"476820AE0AAA6E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352947,"discussion_content":"老师最近还在回复大家的评论。。。 赞赞赞👍","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1614918754,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190832,"user_name":"Dylan","can_delete":false,"product_type":"c1","uid":1040236,"ip_address":"","ucode":"58064D0C9F9F5F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/df/6c/5af32271.jpg","comment_is_top":false,"comment_ctime":1584697193,"is_pvip":false,"replies":[{"id":"74129","content":"值得庆祝，应该喝一杯！","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1585126663,"ip_address":"","comment_id":190832,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5879664489","product_id":100034101,"comment_content":"熬过最不熟悉的前端，突然感觉一身轻松","like_count":1,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488064,"discussion_content":"值得庆祝，应该喝一杯！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585126663,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166942,"user_name":"非洲小白领","can_delete":false,"product_type":"c1","uid":1121873,"ip_address":"","ucode":"50B2B99B1D7ADD","user_header":"https://static001.geekbang.org/account/avatar/00/11/1e/51/f54dca29.jpg","comment_is_top":false,"comment_ctime":1577634386,"is_pvip":false,"replies":[{"id":"64918","content":"看来你是偏向于搞底层编码的？","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1577710719,"ip_address":"","comment_id":166942,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5872601682","product_id":100034101,"comment_content":"前端算法部分看得一脸懵逼，后端就熟悉多了","like_count":1,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479687,"discussion_content":"看来你是偏向于搞底层编码的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577710719,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166079,"user_name":"Geek_103f3f","can_delete":false,"product_type":"c1","uid":1724657,"ip_address":"","ucode":"BD4E0A2606B11F","user_header":"","comment_is_top":false,"comment_ctime":1577375924,"is_pvip":false,"replies":[{"id":"63352","content":"后端跟前端是相对独立的，是可以单独学的。<br>你可以认为前端反正已经生成AST了。现在你就想办法如何把它变成IR，再变成机器码就好了。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1577430524,"ip_address":"","comment_id":166079,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5872343220","product_id":100034101,"comment_content":"老师，直接从这开始学可以吗，前端实在听不懂，对我的工作也没什么用","like_count":1,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479388,"discussion_content":"后端跟前端是相对独立的，是可以单独学的。\n你可以认为前端反正已经生成AST了。现在你就想办法如何把它变成IR，再变成机器码就好了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577430524,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1050269,"avatar":"","nickname":"minghu6","note":"","ucode":"F44058E21B14C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376170,"discussion_content":"不过一般前端的工作应该还包括AST=>IR, 后端是直接从IR开始的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622000555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1724657,"avatar":"","nickname":"Geek_103f3f","note":"","ucode":"BD4E0A2606B11F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":104700,"discussion_content":"谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577447733,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142643,"user_name":"风","can_delete":false,"product_type":"c1","uid":1444483,"ip_address":"","ucode":"E1CE0825AAF805","user_header":"https://static001.geekbang.org/account/avatar/00/16/0a/83/f916f903.jpg","comment_is_top":false,"comment_ctime":1571444392,"is_pvip":false,"replies":[{"id":"57541","content":"我希望前端部分的代码，也用c++写一遍，等我时间更充足会补上。<br>第二，后端部分有的地方仍然是用java写的，比如32讲生成字节码:)","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1573309772,"ip_address":"","comment_id":142643,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5866411688","product_id":100034101,"comment_content":"从这一节开始，内容就十分熟悉了，终于不用看JAVA代码了，哈哈😄","like_count":1,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471207,"discussion_content":"我希望前端部分的代码，也用c++写一遍，等我时间更充足会补上。\n第二，后端部分有的地方仍然是用java写的，比如32讲生成字节码:)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573309772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":348373,"user_name":"...","can_delete":false,"product_type":"c1","uid":1020427,"ip_address":"","ucode":"35C881D8AA1C5E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/0b/2ccf7908.jpg","comment_is_top":false,"comment_ctime":1655028575,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655028575","product_id":100034101,"comment_content":"感觉java编译后的字节码不能认为是一种IR(而应该认为是和汇编代码一样的存在)，这里应该并没有做机器指令的兼容，而是因为使用C在写java虚拟机时利用C语言帮助完成机器指令的兼容，所以并不是java字节码class适配了多平台，而是虚拟机适配了多平台","like_count":0},{"had_liked":false,"id":228324,"user_name":"lizhaochao","can_delete":false,"product_type":"c1","uid":1170705,"ip_address":"","ucode":"1357C60BB567B7","user_header":"https://static001.geekbang.org/account/avatar/00/11/dd/11/04ebee55.jpg","comment_is_top":false,"comment_ctime":1592641758,"is_pvip":false,"replies":[{"id":"84188","content":"没错！","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1592653314,"ip_address":"","comment_id":228324,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1592641758","product_id":100034101,"comment_content":"高速缓存指的是 L1 \bL2 这些缓存吗","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499000,"discussion_content":"没错！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592653314,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219122,"user_name":"westfall","can_delete":false,"product_type":"c1","uid":1632773,"ip_address":"","ucode":"F3F5CB7DF695FC","user_header":"https://static001.geekbang.org/account/avatar/00/18/ea/05/b164dc15.jpg","comment_is_top":false,"comment_ctime":1589949726,"is_pvip":false,"replies":[{"id":"82314","content":"不可以。<br>是要转成二进制目标文件，然后再做链接，才能执行。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1591081571,"ip_address":"","comment_id":219122,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1589949726","product_id":100034101,"comment_content":"汇编代码可以直接运行吗？难道不用再转为二进制代码？","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495691,"discussion_content":"不可以。\n是要转成二进制目标文件，然后再做链接，才能执行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591081571,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1030550,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b9/96/a2ddca59.jpg","nickname":"发发科技","note":"","ucode":"B49C89E7C7BF2C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275676,"discussion_content":"作者只是省略了，肯定要二进制化：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590753143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217734,"user_name":"方","can_delete":false,"product_type":"c1","uid":1167527,"ip_address":"","ucode":"A38B0FCAFBF8C4","user_header":"https://static001.geekbang.org/account/avatar/00/11/d0/a7/7bb34c67.jpg","comment_is_top":false,"comment_ctime":1589598878,"is_pvip":false,"replies":[{"id":"82315","content":"递归相当于调用另一个函数。所有的参数、本地变量，要再来一份，也就是要创建一个新的活动记录（栈帧）。<br>不过，对于递归调用中的尾递归，编译器是可以做优化的，也就是不用再进行一次新的函数调用，从而节省了系统资源的开销。","user_name":"作者回复","user_name_real":"宫文学Richard","uid":"1543380","ctime":1591081681,"ip_address":"","comment_id":217734,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589598878","product_id":100034101,"comment_content":"函数里面的基本块不能跳转到函数入口，那递归怎么办？","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495244,"discussion_content":"递归相当于调用另一个函数。所有的参数、本地变量，要再来一份，也就是要创建一个新的活动记录（栈帧）。\n不过，对于递归调用中的尾递归，编译器是可以做优化的，也就是不用再进行一次新的函数调用，从而节省了系统资源的开销。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591081681,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}