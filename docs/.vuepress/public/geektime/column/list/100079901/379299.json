{"id":379299,"title":"03｜内置 Hooks（1）：如何保存组件状态和使用生命周期？","content":"<p>你好，我是王沛。这节课我们一起来学习基本 Hooks 的用法。</p><p>如果你用过基于类的组件，那么对组件的生命周期函数一定不会陌生，例如 componentDidMount, componentDidUpdate，等等。如果没有使用过，那也没关系，因为在今天这节课里，你会看到基于 Hooks 去考虑组件的实现，这会是一个非常不同的思路，你完全不用去关心一个组件的生命周期是怎样的。</p><p>特别是如果你已经习惯了类组件的开发，那么要做的，甚至是彻底忘掉那些生命周期方法。不要遇到一个需求，就映射到这个功能该在哪个生命周期中去做，然后又要去想原来的声明周期方法在函数组件中应该怎么用 Hooks 去实现。</p><p>正确的思路应该是<strong>遇到需求时，直接考虑在 Hooks 中去如何实现</strong>。</p><p>React 提供的 Hooks 其实非常少，一共只有10个，比如 useState、useEffect、useCallback、useMemo、useRef、useContext等等。这一讲我们会先学习 useState 和 useEffect 这两个最为核心的 Hooks。下一讲则会介绍另外四个常用的 Hooks。掌握了这些Hooks，你就能进行90%的React 开发了。</p><p>不过在讲之前我想强调一点，这些 Hooks 的功能其实非常简单，多看看官方文档就可以了。因为这节课的目的，其实是让你学会如何用 Hooks 的思路去进行功能的实现。</p><!-- [[[read_end]]] --><h1>useState：让函数组件具有维持状态的能力</h1><p>在第一讲中，你已经知道了 state 是 React 组件的一个核心机制，那么 useState 这个 Hook 就是用来管理 state 的，它可以<strong>让函数组件具有维持状态的能力</strong>。也就是说，在一个函数组件的多次渲染之间，这个 state 是共享的。下面这个例子就显示了 useState 的用法：</p><pre><code>import React, { useState } from 'react';\n\nfunction Example() {\n  // 创建一个保存 count 的 state，并给初始值 0\n  const [count, setCount] = useState(0);\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;{count}&lt;/p&gt;\n      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;\n        +\n      &lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre><p>在这个例子中，我们声明了一个名为 count 的 state，并得到了设置这个 count 值的函数 setCount。当调用 setCount 时，count 这个 state 就会被更新，并触发组件的刷新。那么 useState 这个 Hook 的用法总结出来就是这样的：</p><ol>\n<li>useState(initialState) 的参数 initialState 是创建 state 的初始值，它可以是任意类型，比如数字、对象、数组等等。</li>\n<li>useState() 的返回值是一个有着两个元素的数组。第一个数组元素用来读取 state 的值，第二个则是用来设置这个 state 的值。在这里要注意的是，state 的变量（例子中的 count）是只读的，所以我们必须通过第二个数组元素 setCount 来设置它的值。</li>\n<li>如果要创建多个 state，那么我们就需要多次调用 useState。比如要创建多个 state，使用的代码如下：</li>\n</ol><pre><code>// 定义一个年龄的 state，初始值是 42\nconst [age, setAge] = useState(42);\n// 定义一个水果的 state，初始值是 banana\nconst [fruit, setFruit] = useState('banana');\n// 定一个一个数组 state，初始值是包含一个 todo 的数组\nconst [todos, setTodos] = useState([{ text: 'Learn Hooks' }]);\n</code></pre><p>从这段代码可以看到，useState 是一个非常简单的 Hook，它让你很方便地去创建一个状态，并提供一个特定的方法（比如 setAge ）来设置这个状态。</p><p>如果你之前用过类组件，那么这里的 useState 就和类组件中的 setState非常类似。不过两者最大的区别就在于，类组件中的 state 只能有一个。所以我们一般都是把一个对象作为 一个state，然后再通过不同的属性来表示不同的状态。而函数组件中用 useState 则可以很容易地创建多个 state，所以它更加语义化。</p><p>可以说，state 是 React 组件非常重要的一个机制，那么什么样的值应该保存在 state 中呢？这是日常开发中需要经常思考的问题。通常来说，我们要遵循的一个原则就是：<strong>state 中永远不要保存可以通过计算得到的值</strong>。比如说：</p><ol>\n<li>从 props 传递过来的值。有时候 props 传递过来的值无法直接使用，而是要通过一定的计算后再在 UI 上展示，比如说排序。那么我们要做的就是每次用的时候，都重新排序一下，或者利用某些 cache 机制，而不是将结果直接放到 state 里。</li>\n<li>从 URL 中读到的值。比如有时需要读取 URL 中的参数，把它作为组件的一部分状态。那么我们可以在每次需要用的时候从 URL 中读取，而不是读出来直接放到 state 里。</li>\n<li>从 cookie、localStorage 中读取的值。通常来说，也是每次要用的时候直接去读取，而不是读出来后放到 state 里。</li>\n</ol><p>不过，state虽然便于维护状态，但也有自己的弊端。<strong>一旦组件有自己状态，意味着组件如果重新创建，就需要有恢复状态的过程，这通常会让组件变得更复杂</strong>。</p><p>比如一个组件想在服务器端请求获取一个用户列表并显示，如果把读取到的数据放到本地的 state 里，那么每个用到这个组件的地方，就都需要重新获取一遍。</p><p>而如果通过一些状态管理框架，去管理所有组件的 state 的话，比如我在第7讲会介绍的 Redux，那么组件本身就可以是无状态的。无状态组件可以成为更纯粹的表现层，没有太多的业务逻辑，从而更易于使用、测试和维护。</p><h1>useEffect：执行副作用</h1><p>useEffect ，顾名思义，用于执行一段副作用。</p><p>什么是副作用呢？通常来说，副作用是指<strong>一段和当前执行结果无关的代码。</strong>比如说要修改函数外部的某个变量，要发起一个请求，等等。也就是说，在函数组件的当次执行过程中，useEffect 中代码的执行是不影响渲染出来的 UI 的。</p><p>我们先来看一下它的具体用法。useEffect 可以接收两个参数，函数签名如下：</p><pre><code>useEffect(callback, dependencies)\n</code></pre><p>第一个为要执行的函数callback，第二个是可选的依赖项数组dependencies。其中依赖项是可选的，如果不指定，那么 callback 就会在每次函数组件执行完后都执行；如果指定了，那么只有依赖项中的值发生变化的时候，它才会执行。</p><p>对应到 Class 组件，那么 useEffect 就涵盖了 ComponentDidMount、componentDidUpdate和componentWillUnmount 三个生命周期方法。不过如果你习惯了使用Class 组件，那千万不要按照把 useEffect 对应到某个或者某几个生命周期的方法。你只要记住，<strong>useEffect 是每次组件 render 完后判断依赖并执行</strong>就可以了。</p><p>举个例子，某个组件用于显示一篇 Blog 文章，那么这个组件会接收一个参数来表示 Blog 的 ID。而当 ID 发生变化时，组件需要发起请求来获取文章内容并展示：</p><pre><code>import React, { useState, useEffect } from &quot;react&quot;;\n\nfunction BlogView({ id }) {\n  // 设置一个本地 state 用于保存 blog 内容\n  const [blogContent, setBlogContent] = useState(null);\n\n  useEffect(() =&gt; {\n    // useEffect 的 callback 要避免直接的 async 函数，需要封装一下\n    const doAsync = async () =&gt; {\n      // 当 id 发生变化时，将当前内容清楚以保持一致性\n      setBlogContent(null);\n      // 发起请求获取数据\n      const res = await fetch(`/blog-content/${id}`);\n      // 将获取的数据放入 state\n      setBlogContent(await res.text());\n    };\n    doAsync();\n  }, [id]); // 使用 id 作为依赖项，变化时则执行副作用\n\n  // 如果没有 blogContent 则认为是在 loading 状态\n  const isLoading = !blogContent;\n  return &lt;div&gt;{isLoading ? &quot;Loading...&quot; : blogContent}&lt;/div&gt;;\n}\n</code></pre><p>这样，我们就利用 useEffect 完成了一个简单的数据请求的需求。在这段代码中，我们把 ID 作为依赖项参数，这样就很自然地在 ID发生变化时，利用useEffect执行副作用去获取数据。如果在之前的类组件中要完成类似的需求，我们就需要在 componentDidUpdate 这个方法里，自己去判断两次ID是否发生了变化。如果变了，才去发起请求。这样的话，逻辑上就不如 useEffect 来得直观。</p><p>useEffect 还有两个特殊的用法：<strong>没有依赖项，以及依赖项作为空数组</strong>。我们来具体分析下。</p><ol>\n<li>没有依赖项，则每次 render 后都会重新执行。例如：</li>\n</ol><pre><code>useEffect(() =&gt; {\n  // 每次 render 完一定执行\n  console.log('re-rendered');\n});\n\n</code></pre><ol start=\"2\">\n<li>空数组作为依赖项，则只在首次执行时触发，对应到 Class 组件就是 componentDidMount。例如：</li>\n</ol><pre><code>useEffect(() =&gt; {\n  // 组件首次渲染时执行，等价于 class 组件中的 componentDidMount\n  console.log('did mount');\n}, [])\n</code></pre><p>除了这些机制之外，useEffect 还<strong>允许你返回一个函数，用于在组件销毁的时候做一些清理的操作</strong>。比如移除事件的监听。这个机制就几乎等价于类组件中的 componentWillUnmount。举个例子，在组件中，我们需要监听窗口的大小变化，以便做一些布局上的调整：</p><pre><code>// 设置一个 size 的 state 用于保存当前窗口尺寸\nconst [size, setSize] = useState({});\nuseEffect(() =&gt; {\n  // 窗口大小变化事件处理函数\n  const handler = () =&gt; {\n    setSize(getSize());\n  };\n  // 监听 resize 事件\n  window.addEventListener('resize', handler);\n  \n  // 返回一个 callback 在组件销毁时调用\n  return () =&gt; {\n    // 移除 resize 事件\n    window.removeEventListener('resize', handler);\n  };\n}, []);\n</code></pre><p>通过这样一个简单的机制，我们能够更好地管理副作用，从而确保组件和副作用的一致性。</p><p>总结一下，useEffect 让我们能够在下面四种时机去执行一个回调函数产生副作用：</p><ol>\n<li>每次 render 后执行：不提供第二个依赖项参数。比如<br>\nuseEffect(() =&gt; {})。</li>\n<li>仅第一次render 后执行：提供一个空数组作为依赖项。比如<br>\nuseEffect(() =&gt; {}, [])。</li>\n<li>第一次以及依赖项发生变化后执行：提供依赖项数组。比如<br>\nuseEffect(() =&gt; {}, [deps])。</li>\n<li>组件 unmount 后执行：返回一个回调函数。比如<br>\nuseEffect() =&gt; { return () =&gt; {} }, [])。</li>\n</ol><h1>理解 Hooks 的依赖</h1><p>在 useEffect Hook 中你已经看到了依赖项的概念。其实除了在 useEffect 中会用到外，在第5讲的 useCallback 和 useMemo 中也会用到。所以接下来我们就先透彻了解它的工作机制，帮助你在实际开发中能够正确地使用。</p><p>正如在第2讲中介绍的，Hooks 提供了让你监听某个数据变化的能力。这个变化可能会触发组件的刷新，也可能是去创建一个副作用，又或者是刷新一个缓存。那么定义要监听哪些数据变化的机制，其实就是指定 Hooks 的依赖项。</p><p>不过需要注意的是，依赖项并不是内置 Hooks 的一个特殊机制，而可以认为是一种设计模式。有类似需求的 Hooks 都可以用这种模式去实现。</p><p>那么在定义依赖项时，我们需要注意以下三点：</p><ol>\n<li>依赖项中定义的变量一定是会在回调函数中用到的，否则声明依赖项其实是没有意义的。</li>\n<li>依赖项一般是一个常量数组，而不是一个变量。因为一般在创建 callback 的时候，你其实非常清楚其中要用到哪些依赖项了。</li>\n<li>React 会使用浅比较来对比依赖项是否发生了变化，所以要特别注意数组或者对象类型。如果你是每次创建一个新对象，即使和之前的值是等价的，也会被认为是依赖项发生了变化。这是一个刚开始使用 Hooks时很容易导致 Bug 的地方。例如下面的代码：</li>\n</ol><pre><code>function Sample() {\n  // 这里在每次组件执行时创建了一个新数组\n  const todos = [{ text: 'Learn hooks.'}];\n  useEffect(() =&gt; {\n    console.log('Todos changed.');\n  }, [todos]);\n}\n</code></pre><p>代码的原意可能是在 todos 变化的时候去产生一些副作用，但是这里的 todos 变量是在函数内创建的，实际上每次都产生了一个新数组。所以在作为依赖项的时候进行引用的比较，实际上被认为是发生了变化的。</p><h1>掌握 Hooks 的使用规则</h1><p>Hooks 本身作为纯粹的 JavaScript 函数，不是通过某个特殊的 API 去创建的，而是直接定义一个函数。它需要在降低学习和使用成本的同时，还需要遵循一定的规则才能正常工作。因而Hooks的使用规则包括以下两个：<strong>只能在函数组件的顶级作用域使用；只能在函数组件或者其他Hooks中使用。</strong></p><h2>Hooks 只能在函数组件的顶级作用域使用</h2><p>所谓<strong>顶层作用域</strong>，就是 <strong>Hooks 不能在循环、条件判断或者嵌套函数内执行，而必须是在顶层</strong>。同时 <strong>Hooks 在组件的多次渲染之间，必须按顺序被执行</strong>。因为在 React 组件内部，其实是维护了一个对应组件的固定 Hooks 执行列表的，以便在多次渲染之间保持 Hooks 的状态，并做对比。</p><p>比如说下面的代码是可行的，因为 Hooks 一定会被执行到：</p><pre><code>function MyComp() {\n  const [count, setCount] = useState(0);\n  // ...\n  return &lt;div&gt;{count}&lt;/div&gt;;\n}\n\n</code></pre><p>而下面的代码是错误的，因为在某些条件下 Hooks 是不会被执行到的：</p><pre><code>function MyComp() {\n  const [count, setCount] = useState(0);\n  if (count &gt; 10) {\n    // 错误：不能将 Hook 用在条件判断里\n    useEffect(() =&gt; {\n      // ...\n    }, [count])\n  }\n  \n  // 这里可能提前返回组件渲染结果，后面就不能再用 Hooks 了\n  if (count === 0) {\n    return 'No content';\n  }\n\n  // 错误：不能将 Hook 放在可能的 return 之后\n  const [loading, setLoading] = useState(false);\n  \n  //...\n  return &lt;div&gt;{count}&lt;/div&gt;\n}\n</code></pre><p>所以 Hooks 的这个规则可以总结为两点：<strong>第一，所有 Hook 必须要被执行到。第二，必须按顺序执行。</strong></p><h2>Hooks 只能在函数组件或者其它 Hooks 中使用</h2><p>Hooks 作为专门为函数组件设计的机制，使用的情况只有两种，<strong>一种是在函数组件内，另外一种则是在自定义的 Hooks 里面</strong>。</p><p>这个规则在函数组件和类组件同时存在的项目中，可能会造成一定的困扰，因为 Hooks 简洁、直观，我们可能都倾向于用 Hooks 来实现逻辑的重用，但是如果一定要在 Class 组件中使用，那应该如何做呢？其实有一个通用的机制，那就是<strong>利用高阶组件的模式，将 Hooks 封装成高阶组件，从而让类组件使用。</strong></p><p>举个例子。我们已经定义了监听窗口大小变化的一个 Hook：useWindowSize。那么很容易就可以将其转换为高阶组件：</p><pre><code>import React from 'react';\nimport { useWindowSize } from '../hooks/useWindowSize';\n\nexport const withWindowSize = (Comp) =&gt; {\n  return props =&gt; {\n    const windowSize = useWindowSize();\n    return &lt;Comp windowSize={windowSize} {...props} /&gt;;\n  };\n};\n</code></pre><p>那么我们就可以通过如下代码来使用这个高阶组件：</p><pre><code>import React from 'react';\nimport { withWindowSize } from './withWindowSize';\n\nclass MyComp {\n  render() {\n    const { windowSize } = this.props;\n    // ...\n  }\n}\n\n// 通过 withWindowSize 高阶组件给 MyComp 添加 windowSize 属性\nexport default withWindowSize(MyComp);\n\n</code></pre><p>这样，通过 withWindowSize 这样一个高阶组件模式，你就可以把 useWindowSize 的结果作为属性，传递给需要使用窗口大小的类组件，这样就可以实现在 Class 组件中复用 Hooks 的逻辑了。</p><h1>使用 ESLint 插件帮助检查 Hooks 的使用</h1><p>刚才你已经看到了使用 Hooks 的一些特性和要遵循的规则，那么应用到日常的开发中，就必须时刻注意不能写错。我总结了一下，包括这么三点：</p><ol>\n<li>在 useEffect 的回调函数中使用的变量，都必须在依赖项中声明；</li>\n<li>Hooks 不能出现在条件语句或者循环中，也不能出现在 return 之后；</li>\n<li>Hooks 只能在函数组件或者自定义 Hooks 中使用。</li>\n</ol><p>那么你可能要问，要保证完全遵循规则，看上去好像挺困难的，必须得非常小心，不知道有什么好办法可以帮助掌握吗？贴心的 React 官方为我们提供了一个 ESLint 的插件，<strong>专门用来检查 Hooks 是否正确被使用，它就是</strong> <a href=\"https://www.npmjs.com/package/eslint-plugin-react-hooks\"><strong>eslint-plugin-react-hooks</strong></a> 。</p><p>通过这个插件，如果发现缺少依赖项定义这样违反规则的情况，就会报一个错误提示（类似于语法错误的提示），方便进行修改，从而避免 Hooks 的错误使用。</p><p>使用的方法也很简单。首先，我们通过 npm 或者 yarn 安装这个插件：</p><pre><code>npm install eslint-plugin-react-hooks --save-dev\n</code></pre><p>然后在你的 ESLint 配置文件中加入两个规则：<strong>rules-of-hooks 和 exhaustive-deps</strong>。如下：</p><pre><code>{\n  &quot;plugins&quot;: [\n    // ...\n    &quot;react-hooks&quot;\n  ],\n  &quot;rules&quot;: {\n    // ...\n    // 检查 Hooks 的使用规则\n    &quot;react-hooks/rules-of-hooks&quot;: &quot;error&quot;, \n    // 检查依赖项的声明\n    &quot;react-hooks/exhaustive-deps&quot;: &quot;warn&quot;\n  }\n}\n</code></pre><p>要知道，这个插件几乎是 React 函数组件开发必备的工具，能够避免很多可能看上去很奇怪的错误。所以作为开始开发的第一步，一定要安装并配置好这个插件。</p><h1>小结</h1><p>在这节课，我们学习了 useState 和 useEffect 这两个核心 Hooks 的用法，一个用于保存状态，一个用于执行副作用。可以说，<strong>掌握了这两个 Hooks，几乎就能完成大部分的 React 的开发了</strong>。</p><p>同时，根据这两个 Hooks 的用法实例，我们还进一步学习了 Hooks 依赖项的含义，以及使用规则。通过定义不同类型的依赖项，你就可以在组件的不同生命周期中去执行不同的逻辑。</p><p>要知道，理解了这些机制是一劳永逸的，因为无论是其它的内置 Hooks，还是自定义 Hooks，都是一样的，这将有助于后面 Hooks 的学习。</p><h1>思考题</h1><ol>\n<li>在 useEffect 中如果使用了某些变量，却没有在依赖项中指定，会发生什么呢？</li>\n<li>对于这节课中显示的 Blog 文章的例子，我们在 useEffect 中使用了 setBlogContent 这样一个函数，本质上它也是一个局部变量，那么这个函数需要被作为依赖项吗？为什么？</li>\n</ol><p>欢迎在评论区分享你的想法和思考，我会和你一起交流讨论！我们下节课再见！</p>","neighbors":{"left":{"article_title":"02｜理解 Hooks：React 为什么要发明 Hooks？","id":378311},"right":{"article_title":"04｜内置 Hooks（2）：为什么要避免重复定义回调函数？","id":380210}},"comments":[[{"had_liked":false,"id":296863,"user_name":"独白","can_delete":false,"product_type":"c1","uid":1700211,"ip_address":"","ucode":"EDC477BD20B032","user_header":"https://static001.geekbang.org/account/avatar/00/19/f1/73/6f7e3b35.jpg","comment_is_top":true,"comment_ctime":1623206300,"is_pvip":false,"replies":[{"id":"107979","content":"👍🏻","user_name":"作者回复","comment_id":296863,"uid":"1018676","ip_address":"","utype":1,"ctime":1623470716,"user_name_real":"Nate"}],"discussion_count":2,"race_medal":0,"score":"9.2233721029024993e+18","product_id":100079901,"comment_content":"1. 1）依赖那里没有传任何参数的话，会每次render都执行。2）依赖项有传值但是，有部分依赖没有传，那么没有传的那部分，数据即使变化也不会执行副作用。<br>2.函数应该是不会变化的，所以不需要监听。","like_count":15,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521618,"discussion_content":"👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623470716,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1369514,"avatar":"https://static001.geekbang.org/account/avatar/00/14/e5/aa/57926594.jpg","nickname":"Ppei","note":"","ucode":"C354F8EF0C5814","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380006,"discussion_content":"setBlogContent每次render返回的都是同一个句柄，类似于useCallback的效果","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1624279483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295234,"user_name":"Condor Hero","can_delete":false,"product_type":"c1","uid":1528334,"ip_address":"","ucode":"BD850FE812D22F","user_header":"https://static001.geekbang.org/account/avatar/00/17/52/0e/c5ff46d2.jpg","comment_is_top":false,"comment_ctime":1622310747,"is_pvip":true,"replies":[{"id":"107182","content":"你好，学习的很认真哈，官方文档通常是最好的掌握好基础概念最全面的方式。eslint 插件的目的主要是帮助你发现可能的错误。但是 deps 的本质在于确保callback 里需要用到的变量在变化时保证重新执行。所以这个逻辑只要你自己非常确定不出错就可以了。eslint 只是起一个辅助判断的作用。对于这种情况，你完全可以加一个注释：<br>&#47;&#47; eslint-disable-line <br>让 eslint 忽略这个检查。你自己来决定这个代码是不是正确的逻辑。因为本质上，无论怎么写，语法上都是正确的。","user_name":"作者回复","comment_id":295234,"uid":"1018676","ip_address":"","utype":1,"ctime":1622362382,"user_name_real":"Nate"}],"discussion_count":2,"race_medal":1,"score":"48866951003","product_id":100079901,"comment_content":"老师你好，我看到 redux 官网实现 useActions 函数，让我很困惑：<br><br>地址：https:&#47;&#47;react-redux.js.org&#47;api&#47;hooks#recipe-useactions<br><br>摘录源码，它的依赖数组是动态的，这肯定是不对的，但是如何在 eslint-plugin-react-hooks 规则下写这个函数的呢？：<br><br>```react<br>import { bindActionCreators } from &#39;redux&#39;<br>import { useDispatch } from &#39;react-redux&#39;<br>import { useMemo } from &#39;react&#39;<br><br>export function useActions(actions, deps) {<br>    const dispatch = useDispatch()<br>    return useMemo(<br>        () =&gt; {<br>            if (Array.isArray(actions)) {<br>                return actions.map(a =&gt; bindActionCreators(a, dispatch))<br>            }<br>            return bindActionCreators(actions, dispatch)<br>        },<br>        &#47;&#47; 这个依赖数组不是常量的<br>        deps ? [dispatch, ...deps] : [dispatch]<br>    )<br>}<br>```<br><br>","like_count":12,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521000,"discussion_content":"你好，学习的很认真哈，官方文档通常是最好的掌握好基础概念最全面的方式。eslint 插件的目的主要是帮助你发现可能的错误。但是 deps 的本质在于确保callback 里需要用到的变量在变化时保证重新执行。所以这个逻辑只要你自己非常确定不出错就可以了。eslint 只是起一个辅助判断的作用。对于这种情况，你完全可以加一个注释：\n// eslint-disable-line \n让 eslint 忽略这个检查。你自己来决定这个代码是不是正确的逻辑。因为本质上，无论怎么写，语法上都是正确的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622362382,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1528334,"avatar":"https://static001.geekbang.org/account/avatar/00/17/52/0e/c5ff46d2.jpg","nickname":"Condor Hero","note":"","ucode":"BD850FE812D22F","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376757,"discussion_content":"老师我发现不止 Redux 使用了动态的依赖数组，alibaba 的开源项目也用了，比如它们封装的 useUpdateEffect hook：\n\n参考地址：https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useUpdateEffect/index.ts\n\n```ts\nimport { useEffect, useRef } from &#39;react&#39;;\n\nconst useUpdateEffect: typeof useEffect = (effect, deps) => {\n\tconst isMounted = useRef(false);\n\n\tuseEffect(() => {\n\t\tif (!isMounted.current) {\n\t\t\tisMounted.current = true;\n\t\t} else {\n\t\t\treturn effect();\n\t\t}\n\t// deps 是个变量\n\t}, deps);\n};\n\nexport default useUpdateEffect;\n```\n\n老师，我的疑问：\n\n1. hooks 的依赖数组，到底能不能用表达式或变量来替代字面量数组\n2. 如果依赖数组不能使用动态的，只能指定字面量依赖数组，那么这种需求 hook 如何封装？\n3. 还有就是用阿里巴巴或 Redux 的 useActions ，我该如何配合 eslint-plugin-react-hooks 使用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622312007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295235,"user_name":"William","can_delete":false,"product_type":"c1","uid":1241365,"ip_address":"","ucode":"4499F99B180102","user_header":"https://static001.geekbang.org/account/avatar/00/12/f1/15/8fcf8038.jpg","comment_is_top":false,"comment_ctime":1622312089,"is_pvip":true,"replies":[{"id":"107184","content":"1. 正确<br>2. 没必要的原因在于 React 知道 setBlogContent 是永远不会变的，因为是 useState 中返回的。所以可以忽略。<br>3. 是的，很好的提示。如果在 useEffect 中要使用，可以用函数作为 set 方法的参数，比如 setSomeState(prevState =&gt; newState) ","user_name":"作者回复","comment_id":295235,"uid":"1018676","ip_address":"","utype":1,"ctime":1622362537,"user_name_real":"Nate"}],"discussion_count":6,"race_medal":1,"score":"27392115865","product_id":100079901,"comment_content":"思考题：<br>1. 未在依赖项中指定变量X，当X发生变化时，不会触发 useEffect 指定的回调函数。<br>2. setBlogContent可以作为依赖项，但是没必要。因为他只是用来 setState。<br>3. blogContent不可以作为依赖项，会引起死循环。因为在useEffect中修改了blogContent，会引起新一轮“副作用”回调。<br><br>https:&#47;&#47;github.com&#47;Si3ver&#47;react-hooks-demos&#47;blob&#47;main&#47;src&#47;03&#47;BlogView.js","like_count":6,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521001,"discussion_content":"1. 正确\n2. 没必要的原因在于 React 知道 setBlogContent 是永远不会变的，因为是 useState 中返回的。所以可以忽略。\n3. 是的，很好的提示。如果在 useEffect 中要使用，可以用函数作为 set 方法的参数，比如 setSomeState(prevState =&amp;gt; newState) ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622362537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1374957,"avatar":"https://static001.geekbang.org/account/avatar/00/14/fa/ed/0742b854.jpg","nickname":"Jeffrey Ma","note":"","ucode":"0C5E2AB51E6A83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579420,"discussion_content":"或者说 不会循环吗？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657441121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1374957,"avatar":"https://static001.geekbang.org/account/avatar/00/14/fa/ed/0742b854.jpg","nickname":"Jeffrey Ma","note":"","ucode":"0C5E2AB51E6A83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579419,"discussion_content":"想请问一下， 这个异步函数里面的 setContent的值第一次被赋值为 null, 那么引起视图的更新，会再执行一次useEffect的话，不会发起两次请求吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657441098,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2645928,"avatar":"https://static001.geekbang.org/account/avatar/00/28/5f/a8/4a6c6d9b.jpg","nickname":"Afan","note":"","ucode":"A5FA23706A387A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377305,"discussion_content":"是不是场景不同，希望老师分析下场景。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622597060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2645928,"avatar":"https://static001.geekbang.org/account/avatar/00/28/5f/a8/4a6c6d9b.jpg","nickname":"Afan","note":"","ucode":"A5FA23706A387A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377304,"discussion_content":"这块我有一些疑问，设置了依赖项blogContent，不会引起死循环的。 hooks本身有一种机制bailing out ps：https://reactjs.org/docs/hooks-reference.html#bailing-out-of-a-dispatch\n\nIf you return the same value from a Reducer Hook as the current state, React will bail out without rendering the children or firing effects. ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622596989,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2885242,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLCEsLNSXFBaT1s1tRU0bVmWc0ekGvMpicFmZdiaSM5IdpibltMh4BvFaYM9rtq8sRafLX1kJCZcjNSg/132","nickname":"zyzxrj","note":"","ucode":"44C9B0F43A43C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2645928,"avatar":"https://static001.geekbang.org/account/avatar/00/28/5f/a8/4a6c6d9b.jpg","nickname":"Afan","note":"","ucode":"A5FA23706A387A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552213,"discussion_content":"可是从代码层面来说这样写逻辑是不合理的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645348995,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":377304,"ip_address":""},"score":552213,"extra":""}]}]},{"had_liked":false,"id":295184,"user_name":"逍遥一生","can_delete":false,"product_type":"c1","uid":1467212,"ip_address":"","ucode":"B0F879BE34E4A1","user_header":"https://static001.geekbang.org/account/avatar/00/16/63/4c/09fe3f7a.jpg","comment_is_top":false,"comment_ctime":1622288528,"is_pvip":false,"replies":[{"id":"107180","content":"1. 不指定依赖的话，就每次执行。不只是性能问题，有可能会产生 bug，比如不停的产生副作用发请求给后端。第二点对的，漏掉的话会导致依赖变化时副作用不执行。<br>2. 不需要的原因在于 React 知道 setBlogContent 确定是不会变的。这是 useState 的机制决定的，React 和 ESLint 插件都知道，所以写不写都是一样的，可以忽略。<br>","user_name":"作者回复","comment_id":295184,"uid":"1018676","ip_address":"","utype":1,"ctime":1622360700,"user_name_real":"Nate"}],"discussion_count":2,"race_medal":0,"score":"27392092304","product_id":100079901,"comment_content":"1. 分两种情况，1）如果依赖为空，则每次都会执行，性能有损耗  2）依赖为数组，且漏掉了部分的依赖，会导致该依赖发生变化的时候useEffect内部的逻辑不执行<br><br>2. 不需要，因为我们希望的仅仅是在id变化的时候触发更新","like_count":6,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520977,"discussion_content":"1. 不指定依赖的话，就每次执行。不只是性能问题，有可能会产生 bug，比如不停的产生副作用发请求给后端。第二点对的，漏掉的话会导致依赖变化时副作用不执行。\n2. 不需要的原因在于 React 知道 setBlogContent 确定是不会变的。这是 useState 的机制决定的，React 和 ESLint 插件都知道，所以写不写都是一样的，可以忽略。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622360700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1742144,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJPXN6tO1ka2YhSEnzFLocuXCY9ibrTP8yczqymEGXKwJsDE276MaVBXHSibYiaOl8Z6XOoRTpAbyUnA/132","nickname":"Geek_97af74","note":"","ucode":"73D8823A964877","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376753,"discussion_content":"第二题，不需要是因为react保证了setXXX函数始终是稳定的，所以不需要加入依赖，所以就算不加入lint工具也不会有warning。\n这个文档里有写的。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1622310877,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":297541,"user_name":"健牌哥.","can_delete":false,"product_type":"c1","uid":1374132,"ip_address":"","ucode":"671B0247FFF223","user_header":"https://static001.geekbang.org/account/avatar/00/14/f7/b4/d0a6c7d2.jpg","comment_is_top":false,"comment_ctime":1623607448,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10213542040","product_id":100079901,"comment_content":"老师能详细讲一下hooks为什么只能在函数顶层调用吗？","like_count":2,"discussions":[{"author":{"id":2652102,"avatar":"","nickname":"Geek_d221bc","note":"","ucode":"DB6B2581688624","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535526,"discussion_content":"所谓顶层作用域，就是 Hooks 不能在循环、条件判断或者嵌套函数内执行，而必须是在顶层。同时 Hooks 在组件的多次渲染之间，必须按顺序被执行。因为在 React 组件内部，其实是维护了一个对应组件的固定 Hooks 执行列表的，以便在多次渲染之间保持 Hooks 的状态，并做对比。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1638457761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2819061,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/03/f5/ed243c62.jpg","nickname":"搁浅","note":"","ucode":"351D5C13345B5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582986,"discussion_content":"因为在更新过程中，如果通过 if 条件语句，增加或者删除 hooks，在复用 hooks 过程中，会产生复用 hooks 状态和当前 hooks 不一致的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659861875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"福建"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295555,"user_name":"闲闲","can_delete":false,"product_type":"c1","uid":1637571,"ip_address":"","ucode":"B2099BDCFF6191","user_header":"https://static001.geekbang.org/account/avatar/00/18/fc/c3/0991edfc.jpg","comment_is_top":false,"comment_ctime":1622474462,"is_pvip":false,"replies":[{"id":"107372","content":"setState 时内部是通过引用比较两次值是否发生了变化，所以一定要用 immutable 的方式，也就是每次创建新对象来修改值，比如 setState({...oldState, aa: 2})。","user_name":"作者回复","comment_id":295555,"uid":"1018676","ip_address":"","utype":1,"ctime":1622558628,"user_name_real":"Nate"}],"discussion_count":2,"race_medal":0,"score":"10212409054","product_id":100079901,"comment_content":"老师我有个疑问，<br>我们项目里面用到hook，但是有个问题，一般情况下，state会很多，不可能一两个，所以会把sate组合成对象，但是有时候对象发生了改变，例如{aa:1}--&gt;{aa:2},useEffect 监听函数没有进，需要手动的将两次对象Obeject.assgin一下才能触发监听，不知道老师有没有遇到过？","like_count":2,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521126,"discussion_content":"setState 时内部是通过引用比较两次值是否发生了变化，所以一定要用 immutable 的方式，也就是每次创建新对象来修改值，比如 setState({...oldState, aa: 2})。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622558628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1044036,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ee/44/26ac883e.jpg","nickname":"桃翁","note":"","ucode":"CB438AF450DC00","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377103,"discussion_content":"这是正常的，另外你也可以把对象的属性用来做依赖，比如 [obj.aa] 作为依赖","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622509295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308653,"user_name":"Geek_6b7a3b","can_delete":false,"product_type":"c1","uid":2649052,"ip_address":"","ucode":"A53B5DD6A828A0","user_header":"","comment_is_top":false,"comment_ctime":1629719818,"is_pvip":false,"replies":[{"id":"111728","content":"在函数内部的变量都是局部变量。只是这个变量每次被赋予的值来自的 hook 保证它的值每次都不变。","user_name":"作者回复","comment_id":308653,"uid":"1018676","ip_address":"","utype":1,"ctime":1629726011,"user_name_real":"Nate"}],"discussion_count":1,"race_medal":0,"score":"5924687114","product_id":100079901,"comment_content":"老师，第二个问题为什么说setBlogContent是一个局部变量，这个难道不是全局的吗？","like_count":1},{"had_liked":false,"id":305462,"user_name":"Hottou","can_delete":false,"product_type":"c1","uid":1435166,"ip_address":"","ucode":"0EEC47D9D2968A","user_header":"https://static001.geekbang.org/account/avatar/00/15/e6/1e/ab237ae4.jpg","comment_is_top":false,"comment_ctime":1627982057,"is_pvip":false,"replies":[{"id":"110626","content":"useState 能够保证 setBlogContent 每次都是同一个函数，所以无需作为依赖项。","user_name":"作者回复","comment_id":305462,"uid":"1018676","ip_address":"","utype":1,"ctime":1628154758,"user_name_real":"Nate"}],"discussion_count":1,"race_medal":0,"score":"5922949353","product_id":100079901,"comment_content":"王老师，对于第二个问题，因为无论调用多少次setBlogContent函数，它的指向地址是不变的，所以即使把它作为依赖项，那么它永远也不会发生改变，是这样子吗？","like_count":1},{"had_liked":false,"id":299878,"user_name":"我要的飞翔","can_delete":false,"product_type":"c1","uid":1200447,"ip_address":"","ucode":"41C51DBC8372BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/51/3f/41c68054.jpg","comment_is_top":false,"comment_ctime":1624891827,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5919859123","product_id":100079901,"comment_content":"老师好，想问一个问题～<br>在用useEffect处理副作用的时候，如果只想在依赖项变化的时候执行，但是第一次不执行，<br>类似于只需要class组件中的componentDidUpdate应该怎么写呢","like_count":1,"discussions":[{"author":{"id":1200447,"avatar":"https://static001.geekbang.org/account/avatar/00/12/51/3f/41c68054.jpg","nickname":"我要的飞翔","note":"","ucode":"41C51DBC8372BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381422,"discussion_content":"嘿嘿 老师还没回  说一下我的思路～\n可能需要借助useRef来实现一下，声明一个变量来记录是否“执行过“副作用\n然后再useEffect执行副作用的时候根据这边变量判断执行过，如果没执行过就中断并且执行过置true，否则才执行真正的副作用函数。\nconst didMountRef = useRef(false);\nuseEffect(() => {\n  if (!didMountRef.current) {\n    didMountRef.current = true;\n    return;\n  } else {\n    func();\n  }\n}, deps)","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1625046106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2759225,"avatar":"","nickname":"dreamarts","note":"","ucode":"962C170E013FEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392993,"discussion_content":"我觉得你这样写没毛病，我理解useRef()就是一个标记变量，可以标记render的次数什么的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631198048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2632198,"avatar":"https://static001.geekbang.org/account/avatar/00/28/2a/06/da417908.jpg","nickname":"清风月明","note":"","ucode":"54C98300A9F4DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381171,"discussion_content":"观战中 ~ ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624936563,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295806,"user_name":"Dark I","can_delete":false,"product_type":"c1","uid":1398772,"ip_address":"","ucode":"B19417BA2ED7A1","user_header":"https://static001.geekbang.org/account/avatar/00/15/57/f4/63c3c5ae.jpg","comment_is_top":false,"comment_ctime":1622604214,"is_pvip":true,"replies":[{"id":"107457","content":"useEffect 是副作用，一定要记住语义，副作用的逻辑才需要用在 useEffect 中。而且 useEffect 是在 render 后执行。函数体是和当前 render 结果相关的逻辑。","user_name":"作者回复","comment_id":295806,"uid":"1018676","ip_address":"","utype":1,"ctime":1622727510,"user_name_real":"Nate"}],"discussion_count":1,"race_medal":0,"score":"5917571510","product_id":100079901,"comment_content":"函数体也是每次render都会执行 那么需要每次都会render执行的语句是放在 无依赖的useEffect中还是直接放在函数体中比较好呢","like_count":1},{"had_liked":false,"id":295729,"user_name":"陈威严","can_delete":false,"product_type":"c1","uid":1026142,"ip_address":"","ucode":"BE5F6BC588CE17","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a8/5e/e5307db8.jpg","comment_is_top":false,"comment_ctime":1622562482,"is_pvip":false,"replies":[{"id":"107453","content":"没有，JS 此类函数的垃圾收集效率是非常高的，可以忽略。","user_name":"作者回复","comment_id":295729,"uid":"1018676","ip_address":"","utype":1,"ctime":1622727363,"user_name_real":"Nate"}],"discussion_count":1,"race_medal":1,"score":"5917529778","product_id":100079901,"comment_content":"将函数定义在 useEffect 的 callback 中，每次执行 useEffect 时都会重新创建函数，这样对性能会有影响吗？","like_count":1},{"had_liked":false,"id":295612,"user_name":"cyh41","can_delete":false,"product_type":"c1","uid":1387620,"ip_address":"","ucode":"8B342968050F93","user_header":"https://static001.geekbang.org/account/avatar/00/15/2c/64/2a185538.jpg","comment_is_top":false,"comment_ctime":1622513907,"is_pvip":false,"replies":[{"id":"107374","content":"由语义决定，一般在函数组件，一个值就是一个 state。在 class 组件是不得不将所有值都放到一个 state 里。","user_name":"作者回复","comment_id":295612,"uid":"1018676","ip_address":"","utype":1,"ctime":1622558783,"user_name_real":"Nate"}],"discussion_count":1,"race_medal":0,"score":"5917481203","product_id":100079901,"comment_content":"建议分开用多个值多个useState，还是多个值合成一个useState呢？","like_count":1},{"had_liked":false,"id":351523,"user_name":"Andrew","can_delete":false,"product_type":"c1","uid":1856849,"ip_address":"","ucode":"B1598E1E447EC6","user_header":"https://static001.geekbang.org/account/avatar/00/1c/55/51/c7bffc64.jpg","comment_is_top":false,"comment_ctime":1657864108,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1657864108","product_id":100079901,"comment_content":"老师，不是很理解hooks必须按顺序执行这句话。本来不就是按顺序逐条执行的吗？是不是指带有callback的hook，他们的callback是按顺序执行的？","like_count":0},{"had_liked":false,"id":341986,"user_name":"何以解忧","can_delete":false,"product_type":"c1","uid":1915533,"ip_address":"","ucode":"4DFE2BDBAF4919","user_header":"https://static001.geekbang.org/account/avatar/00/1d/3a/8d/f5e7a20d.jpg","comment_is_top":false,"comment_ctime":1649942492,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1649942492","product_id":100079901,"comment_content":"useEffect 依赖项是空数组的时候，动态挂载的时候为什么会执行两次","like_count":0},{"had_liked":false,"id":339202,"user_name":"官锭AL","can_delete":false,"product_type":"c1","uid":1345325,"ip_address":"","ucode":"793901C6577895","user_header":"https://static001.geekbang.org/account/avatar/00/14/87/2d/dc5fe99f.jpg","comment_is_top":false,"comment_ctime":1647972990,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647972990","product_id":100079901,"comment_content":"useEffect使用async函数直接作为cb，有啥问题嘛","like_count":0},{"had_liked":false,"id":337217,"user_name":"Geek_202275","can_delete":false,"product_type":"c1","uid":2924362,"ip_address":"","ucode":"B5D2B3F713F461","user_header":"","comment_is_top":false,"comment_ctime":1646704440,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646704440","product_id":100079901,"comment_content":"在 useEffect 中如果使用了某些变量，却没有在依赖项中指定，会发生什么呢？","like_count":0},{"had_liked":false,"id":335914,"user_name":"刘一峰","can_delete":false,"product_type":"c1","uid":2784231,"ip_address":"","ucode":"2A59F4325DA5F7","user_header":"","comment_is_top":false,"comment_ctime":1645768780,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645768780","product_id":100079901,"comment_content":"useEffect的callback函数中如何return一个函数，它应该是在组件被卸载之前执行，而不是卸载之后执行。","like_count":0},{"had_liked":false,"id":334133,"user_name":"Geek_5ae50a","can_delete":false,"product_type":"c1","uid":2909669,"ip_address":"","ucode":"DBAECA446E5BB4","user_header":"","comment_is_top":false,"comment_ctime":1644758839,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644758839","product_id":100079901,"comment_content":"老师，请问文中这句话【因为在 React 组件内部，其实是维护了一个对应组件的固定 Hooks 执行列表的，以便在多次渲染之间保持 Hooks 的状态，并做对比。】对比的目的是什么呢？","like_count":0},{"had_liked":false,"id":327993,"user_name":"Light 胖虎","can_delete":false,"product_type":"c1","uid":2876591,"ip_address":"","ucode":"D5FCFE14172D31","user_header":"https://static001.geekbang.org/account/avatar/00/2b/e4/af/f8cf4bc2.jpg","comment_is_top":false,"comment_ctime":1640440560,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640440560","product_id":100079901,"comment_content":"如果整个项目都适用hooks是不是很少会用到高阶组件，高阶组件在hooks的什么场景会用到呢","like_count":0},{"had_liked":false,"id":321207,"user_name":"Osmond","can_delete":false,"product_type":"c1","uid":2836830,"ip_address":"","ucode":"7D04C6D7B0DDCB","user_header":"https://static001.geekbang.org/account/avatar/00/2b/49/5e/f430ff83.jpg","comment_is_top":false,"comment_ctime":1636708051,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636708051","product_id":100079901,"comment_content":"老师，之前被问到一个问题 class和function的react中state分别存在哪里","like_count":0},{"had_liked":false,"id":315899,"user_name":"Geek_6b7a3b","can_delete":false,"product_type":"c1","uid":2649052,"ip_address":"","ucode":"A53B5DD6A828A0","user_header":"","comment_is_top":false,"comment_ctime":1634036758,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634036758","product_id":100079901,"comment_content":"老师，我想问下，被useCallback包裹的函数在依赖没有变的时候会重新生成吗","like_count":0},{"had_liked":false,"id":313498,"user_name":"arronK","can_delete":false,"product_type":"c1","uid":1192961,"ip_address":"","ucode":"58DC6FBF2CF0C1","user_header":"https://static001.geekbang.org/account/avatar/00/12/34/01/30ca98e6.jpg","comment_is_top":false,"comment_ctime":1632466241,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1632466241","product_id":100079901,"comment_content":"对于第一个问题来说，在 useEffect 中使用了变量，但在其依赖项中没有指定（假设指定了其它的依赖项），那就会导致这个变量变化的时候不会触发 useEffect 的执行。<br><br>第二个问题，setBlogContent 是 useState 返回的设置 state 值的函数，这个函数是不变的，在每次 render 的时候，useState 返回的 setBlogContent 都是同一个函数值。所以没有放入依赖项的必要","like_count":0},{"had_liked":false,"id":310251,"user_name":"半夏","can_delete":false,"product_type":"c1","uid":1232197,"ip_address":"","ucode":"2E06D5323096C8","user_header":"https://static001.geekbang.org/account/avatar/00/12/cd/45/15d2f59e.jpg","comment_is_top":false,"comment_ctime":1630568877,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630568877","product_id":100079901,"comment_content":"问题1：<br>- 无依赖项，每次都执行副作用；<br>- 依赖项为空数组，执行一次；<br>- 少写了部分的依赖，在这些依赖变化的时候不能正确触发副作用执行，且在副作用执行过程中，少写的这部分依赖值可能不是最新的值；<br><br>问题2：<br>- 可以不写，因为setBlogContent不变，不会影响到副作用的执行，但是装了依赖检查的话会有提示；","like_count":0},{"had_liked":false,"id":310168,"user_name":"Geek_6b7a3b","can_delete":false,"product_type":"c1","uid":2649052,"ip_address":"","ucode":"A53B5DD6A828A0","user_header":"","comment_is_top":false,"comment_ctime":1630509684,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630509684","product_id":100079901,"comment_content":"老师，我想知道setCount是不是会把连续的两次调用合并成一次？就比如一开始count为1，然后在一个事件里写了两遍setCount(count + 1)，那么最终count是2，而不是3","like_count":0},{"had_liked":false,"id":308774,"user_name":"赵天天","can_delete":false,"product_type":"c1","uid":2181781,"ip_address":"","ucode":"456924B8A0763F","user_header":"","comment_is_top":false,"comment_ctime":1629794080,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1629794080","product_id":100079901,"comment_content":"老师，请问一下，如果一个变量，更改后不涉及UI的变化，这种变量应该怎么做处理呢，生命为一个普通变量还是用useState呢","like_count":0},{"had_liked":false,"id":306275,"user_name":"Geek_d9bc76","can_delete":false,"product_type":"c1","uid":2728834,"ip_address":"","ucode":"7D5DEDC3C04CB9","user_header":"","comment_is_top":false,"comment_ctime":1628482271,"is_pvip":false,"replies":[{"id":"111737","content":"在什么时机计算？clientWidth 可以作为 state，但计算得到的item 个数不要放到 state，用的时候去计算。","user_name":"作者回复","comment_id":306275,"uid":"1018676","ip_address":"","utype":1,"ctime":1629726795,"user_name_real":"Nate"}],"discussion_count":1,"race_medal":0,"score":"1628482271","product_id":100079901,"comment_content":"“state中永远不要保存可以通过计算得到的值”，不太明白，我视图需要根据clineWidth计算出的值决定渲染item的个数，如果不通过useState，我要怎么触发界面更新呢？？","like_count":0},{"had_liked":false,"id":304582,"user_name":"Tristan","can_delete":false,"product_type":"c1","uid":1359476,"ip_address":"","ucode":"DC454E16AAA66A","user_header":"https://static001.geekbang.org/account/avatar/00/14/be/74/0d900ed9.jpg","comment_is_top":false,"comment_ctime":1627484676,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1627484676","product_id":100079901,"comment_content":"老师开一门react+hooks+ts从零开发一个数据分析平台的最佳实践课程吗，肯定大火。ps：我们老板让我搞一个。","like_count":0,"discussions":[{"author":{"id":2923979,"avatar":"","nickname":"Geek_e51667","note":"","ucode":"C7B1B1B87A5DAA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553270,"discussion_content":"达芬奇了解一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645799395,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2752761,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTItAXhe4SUU9uDhVOibDkp44QURM157wMmIUpTzfjBdQITzttsADHLXdXGHz5odxyXk7URZsn1lyzw/132","nickname":"杜亭","note":"","ucode":"3658A350F755BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":403448,"discussion_content":"你直接让老师帮你写一个得了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634085923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1923987,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/5b/93/c55ed4bf.jpg","nickname":"天才球员郭敬明","note":"","ucode":"858ADEE7A07AB0","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390177,"discussion_content":"明目张胆的偷懒😂😂😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629704100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300642,"user_name":"little","can_delete":false,"product_type":"c1","uid":2657169,"ip_address":"","ucode":"C6E0939DCE832A","user_header":"https://static001.geekbang.org/account/avatar/00/28/8b/91/c5c53ee4.jpg","comment_is_top":false,"comment_ctime":1625283089,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625283089","product_id":100079901,"comment_content":"<br>.....<br>const PostDetails = () =&gt; {<br>const {post, posts , isLoading} = useSelector((state) =&gt; state.posts);<br>const dispatch = useDispatch();<br>const history = useHistory();<br>const classes = useStyles();<br>const{ id } = useParams();<br><br>useEffect(() =&gt; {<br>  dispatch(getPost(id));<br>},[id, dispatch]);<br><br>useEffect(() =&gt; {<br>  if(post) {<br>    dispatch(getPostsBySearch({ search: &#39;none&#39;, tags:post?.tags.join(&#39;,&#39;)}));<br>  }<br>}, [post, dispatch]);<br><br> return (<br>        &lt;Paper ......&gt;<br>        ......<br>            <br>            &lt;Typography gutterBottom variant=&quot;h6&quot; color=&quot;textSecondary&quot; component=&quot;h2&quot;&gt;{post.tags.map((tag) =&gt; `#${tag}`)}&lt;&#47;Typography&gt;<br>         ......<br>            &lt;Divider style={{ margin: &#39;20px 0&#39; }} &#47;&gt;<br>            &lt;Typography variant=&quot;body1&quot;&gt;&lt;strong&gt;Realtime Chat - coming soon!&lt;&#47;strong&gt;&lt;&#47;Typography&gt;<br>            &lt;Divider style={{ margin: &#39;20px 0&#39; }} &#47;&gt;<br>            <br>          &lt;div className={classes.imageSection}&gt;<br>            &lt;img className={classes.media} src={post.selectedFile} alt={post.title} &#47;&gt;<br>          &lt;&#47;div&gt;<br>          &lt;&#47;div&gt;  <br>问题：<br>两个useEffect里面按照项目要求，依赖数组只需要id,不需要dispatch，终端就显示 React Hook useEffect has a missing dependency: &#39;dispatch&#39;. Either include it or remove the dependency array  react-hooks&#47;exhaustive-deps。输入dispatch，这个问题解决了。但是，后面return的内容无法render.。老师，这样的情况该怎么办？","like_count":0},{"had_liked":false,"id":300424,"user_name":"Zi莱卷","can_delete":false,"product_type":"c1","uid":1187484,"ip_address":"","ucode":"6E568629E9F847","user_header":"https://static001.geekbang.org/account/avatar/00/12/1e/9c/6208483e.jpg","comment_is_top":false,"comment_ctime":1625150624,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1625150624","product_id":100079901,"comment_content":"为什么 useState 在接受一个 函数式组件 作为参数时，会返回这个组件渲染后的Node信息，而不是一个 function 呢？","like_count":0},{"had_liked":false,"id":300423,"user_name":"Zi莱卷","can_delete":false,"product_type":"c1","uid":1187484,"ip_address":"","ucode":"6E568629E9F847","user_header":"https://static001.geekbang.org/account/avatar/00/12/1e/9c/6208483e.jpg","comment_is_top":false,"comment_ctime":1625150603,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625150603","product_id":100079901,"comment_content":"为什么 useState 在接受一个 函数式组件 作为参数时，会返回这个组件渲染后的Node信息，而不是一个 function 呢？","like_count":0},{"had_liked":false,"id":299430,"user_name":"zzz","can_delete":false,"product_type":"c1","uid":2672273,"ip_address":"","ucode":"7CE7975DF49558","user_header":"","comment_is_top":false,"comment_ctime":1624623258,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624623258","product_id":100079901,"comment_content":"1.没有在依赖项中指定，会每次渲染都执行<br>2.不需要，局部变量不能作为依赖项","like_count":0},{"had_liked":false,"id":296216,"user_name":"寇云","can_delete":false,"product_type":"c1","uid":1001332,"ip_address":"","ucode":"87181F16F83543","user_header":"https://static001.geekbang.org/account/avatar/00/0f/47/74/5e292ded.jpg","comment_is_top":false,"comment_ctime":1622810822,"is_pvip":false,"replies":[{"id":"107742","content":"问题2是不是看错问题了~","user_name":"作者回复","comment_id":296216,"uid":"1018676","ip_address":"","utype":1,"ctime":1623081409,"user_name_real":"Nate"}],"discussion_count":1,"race_medal":0,"score":"1622810822","product_id":100079901,"comment_content":"思考题1:大部分同学回答的挺好了 <br>问题2： 可以把 content  和 loading  封装成一个hooks,  const [loading, content] =  useBolgContent(id)","like_count":0},{"had_liked":false,"id":295797,"user_name":"雅丽丽","can_delete":false,"product_type":"c1","uid":2642535,"ip_address":"","ucode":"C601E4CC285AEF","user_header":"https://static001.geekbang.org/account/avatar/00/28/52/67/f4e1d20a.jpg","comment_is_top":false,"comment_ctime":1622601146,"is_pvip":false,"replies":[{"id":"107456","content":"因为这样就需要维护源state 和目标 state 的一致性，会带来各种复杂度，后面课程有介绍","user_name":"作者回复","comment_id":295797,"uid":"1018676","ip_address":"","utype":1,"ctime":1622727457,"user_name_real":"Nate"}],"discussion_count":1,"race_medal":0,"score":"1622601146","product_id":100079901,"comment_content":"state 中永远不要保存可以通过计算得到的值。这是为什么呢？","like_count":0},{"had_liked":false,"id":295777,"user_name":"Afan","can_delete":false,"product_type":"c1","uid":2645928,"ip_address":"","ucode":"A5FA23706A387A","user_header":"https://static001.geekbang.org/account/avatar/00/28/5f/a8/4a6c6d9b.jpg","comment_is_top":false,"comment_ctime":1622597794,"is_pvip":false,"replies":[{"id":"107468","content":"嗯，下面的有两个依赖，id 和 blogContent 是两次异步变化，不是一起变的，所以两次 1","user_name":"作者回复","comment_id":295777,"uid":"1018676","ip_address":"","utype":1,"ctime":1622728223,"user_name_real":"Nate"}],"discussion_count":2,"race_medal":0,"score":"1622597794","product_id":100079901,"comment_content":"import React, { useState, useEffect } from &quot;react&quot;;<br><br>export default  function BlogView() {<br>    &#47;&#47; 设置一个本地 state 用于保存 blog 内容<br>    const [blogContent, setBlogContent] = useState(&#39;&#39;);<br>    const id = 100;<br><br>    &#47;&#47; useEffect 的 callback 要避免直接的 async 函数，需要封装一下<br>    const doAsync =  () =&gt; {<br>        setBlogContent(&#39;demo&#39;);<br>    };<br><br>    useEffect(() =&gt; {<br>        console.log(1);<br>        doAsync();<br>    }, [id]); &#47;&#47; 使用 id 作为依赖项，变化时则执行副作用<br><br>    &#47;&#47; 如果没有 blogContent 则认为是在 loading 状态<br>    const isLoading = !blogContent;<br>    return &lt;div&gt;{isLoading ? &quot;Loading...&quot; : blogContent}&lt;&#47;div&gt;;<br>}<br>打印一次1<br><br><br>import React, { useState, useEffect } from &quot;react&quot;;<br><br>export default  function BlogView() {<br>    &#47;&#47; 设置一个本地 state 用于保存 blog 内容<br>    const [blogContent, setBlogContent] = useState(&#39;&#39;);<br>    const id = 100;<br><br>    &#47;&#47; useEffect 的 callback 要避免直接的 async 函数，需要封装一下<br>    const doAsync =  () =&gt; {<br>        setBlogContent(&#39;demo&#39;);<br>    };<br><br>    useEffect(() =&gt; {<br>        console.log(1);<br>        doAsync();<br>    }, [id, blogContent]); &#47;&#47; 使用 id 作为依赖项，变化时则执行副作用<br><br>    &#47;&#47; 如果没有 blogContent 则认为是在 loading 状态<br>    const isLoading = !blogContent;<br>    return &lt;div&gt;{isLoading ? &quot;Loading...&quot; : blogContent}&lt;&#47;div&gt;;<br>}<br>打印2次1","like_count":0,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521213,"discussion_content":"嗯，下面的有两个依赖，id 和 blogContent 是两次异步变化，不是一起变的，所以两次 1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622728223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1707743,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/0e/df/a64b3146.jpg","nickname":"Forest","note":"","ucode":"B75CB4919FF25A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377332,"discussion_content":"为什么会把blogContent添加进依赖项？我得理解是当id发生改变时，useEffect执行了一次，且在执行过程中执行了doAsync方法从而改变了blogContent，blogContent改变之后又执行了一次useEffect，所以打印了两次1，若有不对还望指正。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622605286,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295236,"user_name":"William","can_delete":false,"product_type":"c1","uid":1241365,"ip_address":"","ucode":"4499F99B180102","user_header":"https://static001.geekbang.org/account/avatar/00/12/f1/15/8fcf8038.jpg","comment_is_top":false,"comment_ctime":1622312528,"is_pvip":true,"replies":[{"id":"107185","content":"很不错，把实际代码写出来可以更好的理解整个流程~","user_name":"作者回复","comment_id":295236,"uid":"1018676","ip_address":"","utype":1,"ctime":1622362657,"user_name_real":"Nate"}],"discussion_count":1,"race_medal":1,"score":"1622312528","product_id":100079901,"comment_content":"思考题：<br>1. 不放在依赖数组中，则无法触发 useEffect 回调；<br>2. 不需要，setBlogContent 仅仅是用来更新博客内容的函数；<br><br>写了个demo: https:&#47;&#47;github.com&#47;Si3ver&#47;react-hooks-demos&#47;blob&#47;main&#47;src&#47;03&#47;BlogView.js","like_count":0},{"had_liked":false,"id":295179,"user_name":"阳少宇","can_delete":false,"product_type":"c1","uid":1308648,"ip_address":"","ucode":"977CA6F42C7DB6","user_header":"","comment_is_top":false,"comment_ctime":1622286106,"is_pvip":false,"replies":[{"id":"107167","content":"1. 正确。<br>2. 本质上来说它是一个依赖，写到依赖项也是没问题的。因为 useState 的机制能保证 setBlogContent 永远不会变化，所以不变化的值是可以不用写到依赖项 的。所以为了方便我们一般都不写。React 提供的 ESLint 插件也对此做了特殊处理，即使不写也不会报错。","user_name":"作者回复","comment_id":295179,"uid":"1018676","ip_address":"","utype":1,"ctime":1622353419,"user_name_real":"Nate"}],"discussion_count":1,"race_medal":0,"score":"1622286106","product_id":100079901,"comment_content":"1.当变量发生改变时，useEffect不会去执行<br>2. 不能，如果被作为依赖项会发生死循环。因为useEffect使用setBlogContent会触发状态的更新，状态更新会导致函数组件重新render，这样setBlogContent也会被更新","like_count":0},{"had_liked":false,"id":295123,"user_name":"aloha66","can_delete":false,"product_type":"c1","uid":1469820,"ip_address":"","ucode":"60AF4685BF38A2","user_header":"https://static001.geekbang.org/account/avatar/00/16/6d/7c/e91866cf.jpg","comment_is_top":false,"comment_ctime":1622255287,"is_pvip":true,"replies":[{"id":"107164","content":"当然，这边的 todos 只是个常量，实际情况可能会通过某些传入的 props 去创建，比如 initialTodos。那么应该用 下一课讲到的 useMemo 去缓存这个 todos:<br>const todos = useMemo(() =&gt; {<br>  return [{ text: &#39;Learn hooks.&#39;}];<br>}, []);<br><br>所以这边更多的是一个示意，要特别主要两个Object 即使完全相同，但是因为是引用比较，还是会被认为不一样的。","user_name":"作者回复","comment_id":295123,"uid":"1018676","ip_address":"","utype":1,"ctime":1622352924,"user_name_real":"Nate"}],"discussion_count":6,"race_medal":0,"score":"1622255287","product_id":100079901,"comment_content":"代码的原意可能是在 todos 变化的时候去产生一些副作用<br>const todos = [{ text: &#39;Learn hooks.&#39;}];  useEffect(() =&gt; {    console.log(&#39;Todos changed.&#39;);  }, [todos]);<br>如果真的是需要监听todos变化做一些操作应该怎么实践了？","like_count":0,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520954,"discussion_content":"当然，这边的 todos 只是个常量，实际情况可能会通过某些传入的 props 去创建，比如 initialTodos。那么应该用 下一课讲到的 useMemo 去缓存这个 todos:\nconst todos = useMemo(() =&amp;gt; {\n  return [{ text: &amp;#39;Learn hooks.&amp;#39;}];\n}, []);\n\n所以这边更多的是一个示意，要特别主要两个Object 即使完全相同，但是因为是引用比较，还是会被认为不一样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622352924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1241365,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f1/15/8fcf8038.jpg","nickname":"William","note":"","ucode":"4499F99B180102","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376755,"discussion_content":"写了个例子可以参考下：\nhttps://github.com/Si3ver/react-hooks-demos/blob/main/src/03/UseEffect.js","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622310971,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1742144,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJPXN6tO1ka2YhSEnzFLocuXCY9ibrTP8yczqymEGXKwJsDE276MaVBXHSibYiaOl8Z6XOoRTpAbyUnA/132","nickname":"Geek_97af74","note":"","ucode":"73D8823A964877","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376754,"discussion_content":"useMemo即可。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622310958,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1469820,"avatar":"https://static001.geekbang.org/account/avatar/00/16/6d/7c/e91866cf.jpg","nickname":"aloha66","note":"","ucode":"60AF4685BF38A2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1742144,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJPXN6tO1ka2YhSEnzFLocuXCY9ibrTP8yczqymEGXKwJsDE276MaVBXHSibYiaOl8Z6XOoRTpAbyUnA/132","nickname":"Geek_97af74","note":"","ucode":"73D8823A964877","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376776,"discussion_content":"用useMemo返回的值放进useEffect依赖数组？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622340075,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":376754,"ip_address":""},"score":376776,"extra":""},{"author":{"id":1742144,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJPXN6tO1ka2YhSEnzFLocuXCY9ibrTP8yczqymEGXKwJsDE276MaVBXHSibYiaOl8Z6XOoRTpAbyUnA/132","nickname":"Geek_97af74","note":"","ucode":"73D8823A964877","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1469820,"avatar":"https://static001.geekbang.org/account/avatar/00/16/6d/7c/e91866cf.jpg","nickname":"aloha66","note":"","ucode":"60AF4685BF38A2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":376786,"discussion_content":"对，依赖项中如果有复合类型，且该复合类型不是其他state，那么基本都要用useMemo做封装再添加到依赖里。如果是基本类型就没关系。\n\n同样的，对于一个函数，因为函数也是复合类型，所以如果要将函数添加到依赖中，就是用useCallback包装，然后放入。\n\nuseMemo(() => () => {}, []) 等价于 useCallback(() => {}, [])","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1622344285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":376776,"ip_address":""},"score":376786,"extra":""}]},{"author":{"id":1334751,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/qzPPBIl5ydsxKfSEgrjo8FxO4sMYgxyxTlOiakNI4bDz2cgdsqYias3wAndrriahztr0TcVUqeJZ8asj9PA22ZXaA/132","nickname":"Lucas","note":"","ucode":"677EEA40E973B5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376667,"discussion_content":"自定义深比较的hooks","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622266587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]]}