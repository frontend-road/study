{"id":608231,"title":"05｜响应式开发操作：如何理解和使用Vue 3的响应式数据？","content":"<p>你好，我是杨文坚。</p><p>你应该经常在一些技术文章或者博客听到Vue.js的“响应式编程”，那究竟什么是“响应式”？</p><p>“响应式”这个词放在不同技术场景下有不同含义，Vue.js一开始就是一个“响应式”的前端模板库，简单来讲，这个语境里的“响应式”就是“页面的模板内容能随着数据变化而重新渲染”。Vue.js最开始的响应式实现是基于ES6的一个 Object.defineProperty的特性拦截监听数据变化，一旦监听到数据变化就触发对应依赖数据的模板重新渲染。</p><p>到了Vue.js的3.x版本，响应式就换成<strong>基于ES6的Proxy特性</strong>来实现的，Proxy能监听一个对象的“读数据”和“写数据”的操作。最大的问题是因为Vue.js 1.x到2.x版本都是用的 &nbsp;Object.defineProperty 在监听数组变化时候，监听不到Array.push等数组变化操作，需要实现很多代码逻辑才能做好兼容。但用Proxy就能比较完美地直接监听数组的变化。</p><p>响应式开发是Vue.js框架的核心内容，开发者可以通过Vue.js的响应式的能力，直接用数据来驱动视图的变化，不需要写繁琐的DOM操作代码来处理视图的变化，可以让开发者能更加关注“如何设计数据来管理视图”，进而可以更加专注如何“根据业务逻辑来设计数据”，提升实现功能的开发效率。</p><!-- [[[read_end]]] --><p>那么既然Vue.js的响应式特性如此重要，学起来难不难呢？只要你跟着我的步骤由浅入深来进行学习，一节课下来就能掌握大致的使用方法啦。我现在就从响应式数据的基本操作来讲起。</p><h2>响应式数据的基本操作</h2><p>还记得我上节课一直演示的一个Vue.js的代码例子吗？这里再给你展示一下我们之前实现过的一个“计数器”，就是点击按钮，数字不断加1的计数器功能。</p><p>注意了，我这里用的是Vue.js推荐的组合式API的开发方式，<code>&lt;script&gt;</code> 标签需要加上setup属性。具体代码如下：</p><pre><code class=\"language-xml\">&lt;template&gt;\n&nbsp; &lt;div class=\"app\"&gt;\n&nbsp; &nbsp; &lt;div class=\"text\"&gt;Count: {{state.count}}&lt;/div&gt;\n&nbsp; &nbsp; &lt;button class=\"btn\" @click=\"onClick\"&gt;Add&lt;/button&gt;\n&nbsp; &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\n&nbsp; import { reactive } from 'vue';\n&nbsp; const state = reactive({\n&nbsp; &nbsp; count: 0\n&nbsp; });\n&nbsp; const onClick = () =&gt; {\n&nbsp; &nbsp; state.count ++;\n&nbsp; }\n&lt;/script&gt;\n</code></pre><p>在这段Vue.js 3的代码中，reactive就是Vue.js 3官方提供的响应式API，state就是通过响应式API声明的响应式数据。state这个数据可以直接在模板里使用，例如上述代码中我们使用了对象state里的count数据进行显示。</p><p>那么响应式体现在哪呢？你看，上述代码里其实还实现了一个点击事件的函数onClick，这个函数实现了对state.count数值的自增操作。每当触发这个onClick事件，state.count就会自动加1，对应使用到state.count的模板也会随之重新渲染展示最新的数据内容。</p><p><strong>上述功能代码里的这种视图随着数据的变化，就是响应式的特征。</strong>基于Vue.js 3的响应式API reactive生成的数据，就是Vue.js 3的响应式数据。在Vue.js 3运行环境中，如果响应式数据的发生了变化，那么依赖了数据的视图也会跟着变化。</p><p>这里的响应式API reactive必须接受一个对象数据，通过内部封装返回一个Proxy类型的数据对象，这个Proxy数据就是响应式的核心。可以监听对象里每个属性的“读写”操作，通过“监听”或“劫持”属性的“读”和“写”的数据变化，触发依赖对应数据的模板视图进行重新渲染展示最新的数据值。</p><p>我们可以通过以下代码验证一下reactive 返回的数据类型：</p><pre><code class=\"language-xml\">&lt;template&gt;&lt;/template&gt;\n\n&lt;script setup&gt;\nimport { reactive } from 'vue';\nconst state = reactive({\n  count: 0\n});\n\n// 答应响应式数据内容\nconsole.log(state)\n&lt;/script&gt;\n</code></pre><p>执行这个Vue.js 3代码，在浏览器控制台打印的结果如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/4d/57/4d245081011bf38cd5bb61612fa08457.png?wh=1824x614\" alt=\"图片\"></p><p>我们可以看到，reactive生成的响应式数据是一个Proxy数据。那么问题来了，什么是Proxy?</p><p>Proxy是ES6的一个新语法，功能与其英文字面意思一样，就是提供“代理”的功能，可以让对象数据实现属性的读和写操作的代理拦截处理，具体的使用方法你可以参考<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\">MDN技术文档对Proxy的介绍</a> 。</p><p>通过上述内容，我们可以知道 Vue.js 3的响应式API reactive是把对象数据转成Proxy类型数据进行数据的“代理”和“监听”，那么是不是所有响应式数据都必须转成Proxy数据类型呢？</p><p>不一定。其实我们将上述计数器的代码换成另外一个响应式API，也能实现类似响应式功能的效果，代码如下所示：</p><pre><code class=\"language-xml\">&lt;template&gt;\n  &lt;div class=\"app\"&gt;\n    &lt;div class=\"text\"&gt;Count: {{count}}&lt;/div&gt;\n    &lt;button class=\"btn\" @click=\"onClick\"&gt;Add&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\n  import { ref } from 'vue';\n  const count = ref(0);\n  const onClick = () =&gt; {\n    count.value ++;\n  }\n&lt;/script&gt;\n</code></pre><p>你可以看到，在这个修改过的Vue.js 3的代码里，ref就是Vue.js 3官方提供的另一个响应式API，count就是通过响应式API声明的响应式数据。如果我们要修改这个count数据，就需要借助 count.value 属性来“间接”修改这个响应数据。但如果你只是想在模板中使用这个数据，就不需要执行value属性访问，直接使用这个数据名称就行了。</p><p><strong>这里的 ref可以接收一个基础数据类型或者对象数据类型，最后根据不同数据类型返回不同的响应式数据。</strong></p><p>如果ref 接收的是基础类型，例如Number、String、Boolean、Null、Undefined等，返回的响应式数据类型就是Vue.js 3定义的响应式数据类型 RefImpl。如果想在JavaScript读写基础类型的响应式数据，需要通过 .value这个属性来进行操作，但是在模板template中就不需要这个value属性了。</p><p>如果ref 接收的是对象的数据类型，例如JSON、Array数据，那么返回的响应式数据类型也是RefImpl 数据类型。基于Proxy封装的数据是放在RefImpl数据中的value属性里，如果你想在JavaScript操作这个对象的响应式数据，也是需要执行value属性，value属性是用Proxy封装的对象数据，但是在模板template中就不需要这个value属性。</p><p>我们来做个代码实验，例如实现以下的代码片段，同样也是之前实现功能，是一个计数器操作。</p><pre><code class=\"language-xml\">&lt;template&gt;\n  &lt;div&gt;{{count}}&lt;/div&gt;\n  &lt;div&gt;{{state.count}}&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport { ref } from 'vue';\nconst count = ref(1);\nconst state = ref({\n  count: 2\n});\n\n// ref 传入基本类型Number后 响应式数据内容\nconsole.log(count)\n\n// ref 传入对象数据后 响应式数据内容\nconsole.log(state)\n&lt;/script&gt;\n\n</code></pre><p>以上代码通过Vue.js 3编译在浏览器上运行后，在控制台打印结果如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/46/82/460739c87643dbdb3408c1ddc3992582.png?wh=1818x1318\" alt=\"图片\"></p><p>看到这里，你是不是有个疑问，为什么ref需要返回一个RefImpl类型，而不是直接返回Proxy类型呢？</p><p>这是因为Proxy只能代理监听对象类型的数据，例如JSON和Array数据，但是监听不了单纯的基础类型数据，例如Number、String之类。这个时候我们就需要设置一个 value属性的对象来处理对基础类型数据的代理监听操作，下面举一个简单的例子：</p><pre><code class=\"language-javascript\">const data = {\n  _value: 1,\n  get value() {\n    console.log('我代理监听到 “读” Number数据操作，即将返回1')\n    return this._value;\n  },\n  set value(val) {\n    console.log('我代理监听到 “写” Number数据操作，即将设置新数据' + val)\n    this._value = val;\n  }\n}\n\n// 读数据时，会打印出监听的日志 '我代理监听到 “读” Number数据操作，即将返回1'\ndata.value;\n// 写数据时，会打印出监听的日志 '我代理监听到 “写” Number数据操作，即将设置新数据2'\ndata.value = 2;\n</code></pre><p>从上述例子可以看出，因为Proxy监听不了基础类型数据（Number、String、Boolean、Undefined、Null、BigInt等这些基础类型），我们就需要构造出一个对象可以监听基础数据变化，实现响应式操作。</p><p>我们可以把基础类型数据（例如Number类型的数据）封装成一个对象，设置将基础类型读写操作转成对象属性value的get和set操作。这个时候，我们读写这个基础数据value，就可以基于对象的get和set的内置方法来拦截监听数据变化，实现基础数据类型的响应式能力。</p><p>到了这里，你应该会发现，Vue.js 3提供了两个重要的响应式API，reactive和ref，他们都可以生成响应式数据，<strong>而且ref可以接收基础类型和对象类型数据，但是reactive只能接收对象类型数据</strong>。</p><p>那么，这里就有一个问题了，在项目开发中，我们应该如何选择这两种API呢？</p><h2>ref和reactive如何选择使用？</h2><p>我们从上述内容可以知道，ref和reactive最大的区别就是ref可以接收所有数据类型，根据不同数据类型返回对应的RefImpl响应式数据，但是操作数据需要访问value属性。而reactive只能接收对象数据类型，返回一个Proxy的响应式数据，可以访问数据属性来操作数据内容。</p><p>这个时候我们可以根据能力差异来做选择。<strong>如果是要定义对象类型的响应式数据，那么我们可以优先选择 reactive 来定义</strong>，这样子在JavaScript里可以直接操作对象响应式数据，就不需要多写一个value属性来操作了。而且，我们还可以避免对象本身带有value属性容易导致的理解上的属性混淆问题，例如下面代码所示：</p><pre><code class=\"language-xml\">&lt;template&gt;\n  &lt;h2&gt;data.value: {{refData.value}}&lt;/h2&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport { ref } from 'vue';\n// 如果有对象数据刚好是有value属性\nconst refData = ref({\n  value: 2,\n  count: 3\n});\n\n// 实际操作 value:2 数据需要这么操作\n// 这里就会容易混淆 value 属性含义\nrefData.value.value += 1;\n\n// 操作 count:3 这个数据\nrefData.value.count += 1;\n&lt;/script&gt;\n</code></pre><p>从上述代码可以看出，对象数据还是少用ref来声明响应式数据，value操作容易带来团队合作开发过程中理解和沟通成本。</p><p><strong>如果要定义基础类型的响应式数据，就用ref来定义</strong>，通过访问基础类型的响应式数据的value属性来进行读写操作。</p><p>除了常用的 reactive和ref之外，Vue.js 3还有其他功能定义不同的响应式API，你需要在特定场景下进行选择，相关的响应式API信息你可以查看<a href=\"https://cn.vuejs.org/api/\">Vue.js 3的官方文档</a> 。</p><p>下面，我就根据企业中的开发习惯，结合官方对响应式API的建议，再挑几个响应式的API给你举例说明下它们的适用场景。</p><h2>如何选择合适使用其它响应式API？</h2><p>我们先来讲讲<strong>“去除响应式”的响应式API toRaw</strong>，也就是把响应式的关系解除。</p><p>平时在开发过程中，可能会将有些数据渲染在模板里的表单中，我们可以在表单中更改数据内容，但是又不希望表单里每次数据变化都触发响应式作用，这个时候就需要用到 toRaw 来解除掉数据的响应式。具体案例代码如下述源码所示：</p><pre><code class=\"language-xml\">&lt;template&gt;\n  &lt;form&gt;\n    &lt;input v-model=\"data.name\" placeholder=\"用户名称\" /&gt;\n    &lt;br/&gt;\n    &lt;textarea v-model=\"data.info\" placeholder=\"用户信息\" /&gt;\n    &lt;div&gt;名称: {{data.name}}&lt;/div&gt;\n    &lt;div&gt;信息: {{data.info}}&lt;/div&gt;\n  &lt;/form&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport { reactive, toRaw } from 'vue';\nimport VUser from './user.vue';\nconst state = reactive({\n  name: '张三',\n  info: '某某公司前端开发工程师，有3年前端工作经验',\n});\nconst data = toRaw(state);\n&lt;/script&gt;\n</code></pre><p>上述代码中，我先基于 reactive创建了一个响应式数据state，里面存放了用户数据，再用toRaw进行解除掉响应式关系，返回一个原始的JSON数据 data，最后将其放在模板里的表单进行渲染。这样，当我们在表单的<code>&lt;input&gt;</code>和<code>&lt;textarea&gt;</code> 组件中编辑这个原始数据data时，就不会触发响应式关系，也不会触发内容的重新渲染。</p><p>接下来我们要讲的<strong>响应式API watch</strong>，这是监听响应式数据源变化的API，也就是监听指定响应式数据变化，触发对应的回调函数，常用于处理数据变化的副作用操作，例如输入框经常需要用到监听数据变化做字数统计的操作、统计一些中文文字个数等，如下述代码所示：</p><pre><code class=\"language-xml\">&lt;template&gt;\n  &lt;form&gt;\n    &lt;textarea v-model=\"state.text\" placeholder=\"信息\" /&gt;\n    &lt;div&gt;中文字数：{{state.zhCount}}&lt;/div&gt;\n  &lt;/form&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport { reactive, watch } from 'vue';\n\n// 计算文本中文个数函数\nfunction countZhText(txt) {\n  const zhRegExp = /[\\u4e00-\\u9fa5]{1,}/g;\n  const zhList = txt.match(zhRegExp);\n  let count = 0;\n  zhList.forEach((item) =&gt; {\n    count += item.length;\n  });\n  return count;\n} \nconst defaultText = '今天是2022年01月01日'\nconst state = reactive({\n  text: defaultText,\n  zhCount: countZhText(defaultText),\n});\n\nwatch(\n  // 监听 state.text 的变化\n  [() =&gt; state.text ],\n  ([ text ], [ prevText ]) =&gt; {\n    // 当监听到state.text 变化，就会触发这个回调函数\n    state.zhCount = countZhText(text);\n  }\n)\n&lt;/script&gt;\n</code></pre><p>上述代码运行后，watch会监听 state.text 单独的数据变化，然后在<code>&lt;textarea&gt;</code>里编辑数据时，触发 watch 的回调函数，来计算state.text 里的中文个数，计算完之后会修改state.zhCount单独触发视图显示最新的中文个数。更多watch的使用方法，你可以查看<a href=\"https://cn.vuejs.org/api/reactivity-core.html#watch\">官方文档</a>。</p><p>通过我们前面对这两个响应式API，以及reactive和ref这两个设置响应式数据的API的讲解，你应该能体会到，<strong>响应式API基本上可以设置响应式数据、解除响应式状态和监听响应式数据这基本三种类型</strong>。</p><p>那么我们在日常开发中，应该如何根据开发场景进行选择合适响应式API呢？</p><p>答案就是要先理清楚我们需要什么响应式操作，判断到底是设置、解除，还是监听响应式数据，然后在官方的API文档中  <a href=\"https://cn.vuejs.org/api/\">https://cn.vuejs.org/api/</a>  找到自己合适的响应式处理场景。</p><p>不过，当你知道如何在合适场景中选择合适的响应式API进行开发的时候，并不能代表你已经掌握了Vue.js 3的响应式开发，你还需要知道在响应式开发中可能会遇到什么“坑”。那么，为了避免遇到这类“坑”，在做响应式开发时我们需要注意什么呢？</p><h2>Vue.js 3的响应式开发有什么需要注意的?</h2><p>这里主要有下面这三个注意点：</p><ul>\n<li>响应式数据解构或者属性赋值后，可能会丢失响应式联系；</li>\n<li>慎用浅层响应式作用API；</li>\n<li>慎用副作用API。</li>\n</ul><p><strong>第一个注意点就是“响应式数据解构或者属性赋值后，可能会丢失响应式联系</strong>”。怎么讲呢？我先给你展示一个代码例子：</p><pre><code class=\"language-xml\">&lt;template&gt;\n  &lt;textarea v-model=\"text\" placeholder=\"文本信息\" /&gt;\n  &lt;div&gt;文本信息：{{text}}&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport { reactive } from 'vue';\nconst state = reactive({\n  text: '今天是2022年01月01日',\n});\nconst { text } = state;\n&lt;/script&gt;\n</code></pre><p>你可以看到，上述代码中，text的响应式联系并不会生效，<code>&lt;textarea&gt;</code>修改text内容后，都不会触发页面的展示文本text的视图更新渲染。这是为什么呢？</p><p>我来一一分析一下。这里，我们用reactive定义了一个state响应式JSON数据，但是在之后又把其中的 state.text 解构赋值给了变量text，这就会“断掉”了响应式的联系，导致再怎么更新text都不会触发视图重新更新渲染。</p><p>所以你在使用响应式数据时，要注意属性解构出来或者赋值出去，可能会带来“响应式联系的断开”，尽量避免相关的操作。</p><p><strong>第二个注意点就是“慎用浅层响应式作用API”，例如shallowReactive和shallowReadonly。</strong>为什么呢？</p><p>因为shallowReactive这类响应式API生成的响应式对象数据，只作用对象数据的下一级属性，至于对象的下下一级属性就作用不到了。如果没什么特殊的需求，我们就尽量少用这类API，这个Vue.js 3官方在API文档说明也提到过。</p><p><strong>第三个注意点就是“慎用副作用API”。</strong>为什么呢？我来把刚刚的一个代码例子改一下：</p><pre><code class=\"language-xml\">&lt;template&gt;\n  &lt;form&gt;\n    &lt;textarea v-model=\"state.text\" placeholder=\"信息\" /&gt;\n    &lt;div&gt;中文字数：{{state.zhCount}}&lt;/div&gt;\n  &lt;/form&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport { reactive, watch } from 'vue';\n\n// 计算文本中文个数函数\nfunction countZhText(txt) {\n  const zhRegExp = /[\\u4e00-\\u9fa5]{1,}/g;\n  const zhList = txt.match(zhRegExp);\n  let count = 0;\n  zhList.forEach((item) =&gt; {\n    count += item.length;\n  });\n  return count;\n} \nconst defaultText = '今天是2022年01月01日'\nconst state = reactive({\n  text: defaultText,\n  zhCount: countZhText(defaultText),\n});\n\nwatch(\n  // 监听 state.text 的变化\n  [() =&gt; state.text, () =&gt; state.zhCount ],\n  ([ text ], [ prevText ]) =&gt; {\n    // 每当 state.text 变化，这个打印会触发两次\n    console.log('正在监听变化...')\n    // 当监听到state.text 变化，就会触发这个回调函数\n    state.zhCount = countZhText(text);\n  }\n)\n&lt;/script&gt;\n</code></pre><p>你看，上述代码中，每当 state.text 变化，打印代码 console.log(‘正在监听变化…’) 就会触发两次，这是为什么呢？因为监听修改state.text变化，回调函数里会修改state.zhCount数据，但是state.zhCount也被watch函数监听，这个时候会再次触发回调函数，所以就会触发两次。</p><p>现在上述代码在执行过程中，只是修改一个数据，连锁反应触发两次回调。如果监听控制不好，可能会陷入监听回调函数的死循环执行，所以在使用监听副作用的API时候，要注意回调内部的操作和依赖之间的关系，尽可能谨慎使用。</p><h2>总结</h2><p>通过今天的讲解，你应该能理解Vue.js 3的响应式开发操作了，正是由于Vue.js的响应式特性，开发者才可以很方便地实现自己想要的页面功能。</p><p>我在此总结一下Vue.js 3 的响应式开发操作的注意点，具体如下：</p><ul>\n<li>根据不同数据类型选择合适的响应式API，例如基础数据用ref，对象数据用reactive；</li>\n<li>如果想消除数据的响应式特性，可以通过toRaw来进行消除，将响应式数据变成普通数据；</li>\n<li>不要随便解构响应式数据的属性，把属性赋值给其他变量的时候，赋值出去的数据容易“断开”响应式的联系；</li>\n<li>监听响应式数据变化的其它副作用操作，可以通过watch来监听处理事件；</li>\n<li>以上几点如果不能满足你的开发需要，再去看官方的其它响应式API，但是要慎用其它响应式API。</li>\n</ul><p>为什么要“慎用”其它响应式API呢？这是因为凡事都有两面性的，Vue.js 3提供了这么多的响应式能力，运用不当可能带来的不是方便，而是问题，甚至是故障。我在文稿里也提到一些响应式操作使用不恰当时，会带来的其他意想不到的问题。</p><p>所以在使用Vue.js 3的响应式API时候，要注意<strong>响应式的作用范围以及官方对个别API的“慎用提醒”</strong>，一般我们开发过程中尽可能做到“<strong>最小可用</strong>”原则就好，没必要用的技术特性或者API就尽量慎用或者少用，避免带来不必要的问题。</p><h2>思考</h2><p>我们这节课内容都是基于组合式API（Composition API）的开发方式来进行响应式操作，那么如果换成选项式API（Options API）的开发方式，功能的实现应该怎么操作？</p><h3><a href=\"https://github.com/FE-star/vue3-course/tree/main/chapter/05\">完整的代码在这里</a></h3>","neighbors":{"left":{"article_title":"04｜模版语法和JSX语法：你知道Vue可以用JSX写吗？","id":607308},"right":{"article_title":"06｜跨组件数据通信：常见的组件间数据通信方式有哪些？","id":609407}},"comments":[{"had_liked":false,"id":365159,"user_name":"趙學躍","can_delete":false,"product_type":"c1","uid":2644103,"ip_address":"北京","ucode":"DB0FA399EB8385","user_header":"https://static001.geekbang.org/account/avatar/00/28/58/87/7a5ceb07.jpg","comment_is_top":false,"comment_ctime":1672203693,"is_pvip":false,"replies":[{"id":134979,"content":"您好， 谢谢指正，纯属笔误，是ES5就有的。这里顺便补充一下tc39官方对Object.defineProperty 描述 https:&#47;&#47;tc39.es&#47;ecma262&#47;multipage&#47;fundamental-objects.html#sec-object.defineproperty ","user_name":"作者回复","user_name_real":"编辑","uid":3217031,"ctime":1678613698,"ip_address":"浙江","comment_id":365159,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311101,"comment_content":"“Vue.js 最开始的响应式实现是基于 ES6 的一个 Object.defineProperty 的特性拦截监听数据变化”，Object.defineProperty是ES5提供的吧","like_count":3,"discussions":[{"author":{"id":3217031,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/TZnA0PlXExlp9byxOxCeOG6ia0ykwfpxqAq2vslTzL1z5ibTBsgf1nYx0bUXgrOTnSOnmdXQZZibYx9tRSPHFjibPQ/132","nickname":"文坚老师","note":"","ucode":"4E0C838B2A3725","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608696,"discussion_content":"您好， 谢谢指正，纯属笔误，是ES5就有的。这里顺便补充一下tc39官方对Object.defineProperty 描述 https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.defineproperty ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678613699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":364024,"user_name":"文艺理科生","can_delete":false,"product_type":"c1","uid":1625271,"ip_address":"北京","ucode":"ECEBE56833156D","user_header":"https://static001.geekbang.org/account/avatar/00/18/cc/b7/c9ec5b8c.jpg","comment_is_top":false,"comment_ctime":1670460472,"is_pvip":false,"replies":[{"id":135004,"content":"您好，你的理解非常不错， Vue.js 1.x 和 2.x，在数据绑定中，对数组类型的监听做了很多额外的工作，原理是对Array原生一些方法做了特殊处理，才能使得数组变化能监听到。 ","user_name":"作者回复","user_name_real":"编辑","uid":3217031,"ctime":1678626110,"ip_address":"浙江","comment_id":364024,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311101,"comment_content":"最大的问题是因为 Vue.js 1.x 到 2.x 版本都是用的  Object.defineProperty 在监听数组变化时候，监听不到 Array.push 等数组变化操作\n——》通常都是用的push操作，应该是监听不到数组的索引相关操作吧","like_count":1,"discussions":[{"author":{"id":3217031,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/TZnA0PlXExlp9byxOxCeOG6ia0ykwfpxqAq2vslTzL1z5ibTBsgf1nYx0bUXgrOTnSOnmdXQZZibYx9tRSPHFjibPQ/132","nickname":"文坚老师","note":"","ucode":"4E0C838B2A3725","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608737,"discussion_content":"您好，你的理解非常不错， Vue.js 1.x 和 2.x，在数据绑定中，对数组类型的监听做了很多额外的工作，原理是对Array原生一些方法做了特殊处理，才能使得数组变化能监听到。 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678626110,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":363616,"user_name":"都市夜归人","can_delete":false,"product_type":"c1","uid":1071909,"ip_address":"江苏","ucode":"DFF59BE3D80B42","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/25/d78cc1fe.jpg","comment_is_top":false,"comment_ctime":1669881514,"is_pvip":false,"replies":[{"id":135014,"content":"您好，这个数组的写法是Vue.js 3的API定义的。\n“watch当侦听多个来源时，回调函数接受两个数组，分别对应来源数组中的新值和旧值”。\n\n具体可以参考官方文档 https:&#47;&#47;cn.vuejs.org&#47;api&#47;reactivity-core.html#watch ","user_name":"作者回复","user_name_real":"编辑","uid":3217031,"ctime":1678627140,"ip_address":"浙江","comment_id":363616,"utype":1}],"discussion_count":5,"race_medal":0,"score":2,"product_id":100311101,"comment_content":"watch(\n  &#47;&#47; 监听 state.text 的变化\n  [() =&gt; state.text ],\n  ([ text ], [ prevText ]) =&gt; {\n    &#47;&#47; 当监听到state.text 变化，就会触发这个回调函数\n    state.zhCount = countZhText(text);\n  }\n)\n这段语法不太理解，请问为何要将被监听的变量放到数组里？谢谢！","like_count":0,"discussions":[{"author":{"id":3217031,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/TZnA0PlXExlp9byxOxCeOG6ia0ykwfpxqAq2vslTzL1z5ibTBsgf1nYx0bUXgrOTnSOnmdXQZZibYx9tRSPHFjibPQ/132","nickname":"文坚老师","note":"","ucode":"4E0C838B2A3725","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608749,"discussion_content":"您好，这个数组的写法是Vue.js 3的API定义的。\n“watch当侦听多个来源时，回调函数接受两个数组，分别对应来源数组中的新值和旧值”。\n\n具体可以参考官方文档 https://cn.vuejs.org/api/reactivity-core.html#watch ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678627140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3217031,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/TZnA0PlXExlp9byxOxCeOG6ia0ykwfpxqAq2vslTzL1z5ibTBsgf1nYx0bUXgrOTnSOnmdXQZZibYx9tRSPHFjibPQ/132","nickname":"文坚老师","note":"","ucode":"4E0C838B2A3725","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":595518,"discussion_content":"只是为了表示可以监听多个值而已，没有什么特殊含义。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1670177533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2076199,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/ae/27/74828c37.jpg","nickname":"ZR-rd","note":"","ucode":"427E69255F30D8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":595361,"discussion_content":"因为 watch 可以监听多个数据源，下文中作者就监听了 state.text 和 state.zhCount 两个数据，为了上下文统一吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1669971611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1607957,"avatar":"https://static001.geekbang.org/account/avatar/00/18/89/15/381ce65f.jpg","nickname":"不曾相识","note":"","ucode":"0BEDA6BDCA5F56","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":606985,"discussion_content":"因为,watch,第一个参数,监听是用数组,可以监听多个数据\n在回到会调用 两个参数可以是  ( [新值数组],[旧值素组] ] )\n加括号是解构出来两个变量,直接用数组调用不行,你打印下就知道了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1677544724,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江西","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3069180,"avatar":"https://static001.geekbang.org/account/avatar/00/2e/d4/fc/e28388fa.jpg","nickname":"不识石务","note":"","ucode":"6A31D67A9F5667","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":599834,"discussion_content":"监听多个值的时候语法就是这么规定\nwatch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) =&gt; {\n  /* ... */\n})","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673838332,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"中国香港","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":363542,"user_name":"风太大太大","can_delete":false,"product_type":"c1","uid":1368376,"ip_address":"湖北","ucode":"E0221487898D62","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/dCfVz7wIUT4fM7zQO3gIwXo3BGodP5FJuCdMxobZ5dXpzBeTXiaB3icoFqj22EbIGCu1xxd1FLo9xic0a2pGnunibg/132","comment_is_top":false,"comment_ctime":1669800433,"is_pvip":false,"replies":[{"id":135015,"content":"您好，你的回答非常好。","user_name":"作者回复","user_name_real":"编辑","uid":3217031,"ctime":1678627280,"ip_address":"浙江","comment_id":363542,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100311101,"comment_content":"那么如果换成组合式 API（Options API）的开发方式，响应式功能的实现应该怎么操作？\n1. 使用原vue2的写法，把响应的数据放在data函数的返回值中。只要后续直接this.xxx 修改这个值就是响应式。\n2. 利用vue3的写法.使用setUp函数，照样可以使用reactive函数和ref函数。","like_count":0,"discussions":[{"author":{"id":3217031,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/TZnA0PlXExlp9byxOxCeOG6ia0ykwfpxqAq2vslTzL1z5ibTBsgf1nYx0bUXgrOTnSOnmdXQZZibYx9tRSPHFjibPQ/132","nickname":"文坚老师","note":"","ucode":"4E0C838B2A3725","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608750,"discussion_content":"您好，你的回答非常好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678627280,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2076199,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/ae/27/74828c37.jpg","nickname":"ZR-rd","note":"","ucode":"427E69255F30D8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":595358,"discussion_content":"Options API 是选项式哦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1669971201,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":363642,"user_name":"01","can_delete":false,"product_type":"c1","uid":1120612,"ip_address":"福建","ucode":"3229D8F060AFEC","user_header":"https://static001.geekbang.org/account/avatar/00/11/19/64/6f2b7b86.jpg","comment_is_top":false,"comment_ctime":1669906751,"is_pvip":false,"replies":null,"discussion_count":2,"race_medal":0,"score":2,"product_id":100311101,"comment_content":"全文提到好几次JSON 数据。 但是对象并不是JSON","like_count":5,"discussions":[{"author":{"id":2076199,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/ae/27/74828c37.jpg","nickname":"ZR-rd","note":"","ucode":"427E69255F30D8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":595362,"discussion_content":"确实，JSON 都是字符串，这里应该是 JS 对象","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1669971865,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3217031,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/TZnA0PlXExlp9byxOxCeOG6ia0ykwfpxqAq2vslTzL1z5ibTBsgf1nYx0bUXgrOTnSOnmdXQZZibYx9tRSPHFjibPQ/132","nickname":"文坚老师","note":"","ucode":"4E0C838B2A3725","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":595515,"discussion_content":"英文应该叫：JSON Object Literals，如果准确的翻译应该叫“JSON 对象字面量”，应该说我偷懒了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1670173640,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":363544,"user_name":"风太大太大","can_delete":false,"product_type":"c1","uid":1368376,"ip_address":"湖北","ucode":"E0221487898D62","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/dCfVz7wIUT4fM7zQO3gIwXo3BGodP5FJuCdMxobZ5dXpzBeTXiaB3icoFqj22EbIGCu1xxd1FLo9xic0a2pGnunibg/132","comment_is_top":false,"comment_ctime":1669800651,"is_pvip":false,"replies":null,"discussion_count":2,"race_medal":0,"score":2,"product_id":100311101,"comment_content":"个人觉得文中有句话说的不是很合理，怕引起误会。“简单来讲，这个语境里的“响应式”就是“页面的模板内容能随着数据变化而重新渲染”。\n\n这样是否合理，常规来看，这里这个语境里的“响应式”就是“页面的模板内容 及其他数据 能随着数据变化而重新渲染”。而实际响应式就是：当依赖的数据变化了，会更新使用这个数据相关的函数，内容模板是依赖数据试用的函数的一种，还有compute函数，watch函数等.\n","like_count":3,"discussions":[{"author":{"id":3217031,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/TZnA0PlXExlp9byxOxCeOG6ia0ykwfpxqAq2vslTzL1z5ibTBsgf1nYx0bUXgrOTnSOnmdXQZZibYx9tRSPHFjibPQ/132","nickname":"文坚老师","note":"","ucode":"4E0C838B2A3725","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":595517,"discussion_content":"我觉得要讲清楚响应式在目前阶段比较困难，比如至少要从观察者模式开始，然后讲响应式编程，继而再讲 Vue 中的响应式模型。可能后面会想办法补充这些内容。但目前不太适合。所以大家可以先用最简单的方式理解就好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1670177242,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2076199,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/ae/27/74828c37.jpg","nickname":"ZR-rd","note":"","ucode":"427E69255F30D8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":595359,"discussion_content":"确实不是很严谨，作者主要是为了初学者理解方便吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1669971247,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":393869,"user_name":"ifelse","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"浙江","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1725168968,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":3,"score":2,"product_id":100311101,"comment_content":"学习打卡","like_count":0}]}