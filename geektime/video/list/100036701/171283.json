{"id":171283,"title":"43 | 优化使用：用好自带注解省点心","content":"<p><strong>课件和Demo地址</strong><br>\n<a href=\"https://gitee.com/geektime-geekbang/geek_netty\">https://gitee.com/geektime-geekbang/geek_netty</a></p>","comments":[{"had_liked":false,"id":180104,"user_name":"Sonny721","can_delete":false,"product_type":"c3","uid":1104291,"ip_address":"","ucode":"C95DD306BFBE54","user_header":"https://static001.geekbang.org/account/avatar/00/10/d9/a3/2856b5b5.jpg","comment_is_top":false,"comment_ctime":1582187553,"is_pvip":false,"replies":[{"id":79280,"content":"是的，所以也是一种保护。","user_name":"作者回复","user_name_real":"stroller","uid":1638649,"ctime":1588641800,"ip_address":"","comment_id":180104,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"结合上面的提问，翻阅源码有了了解，如果在pipeline上添加Handler的时候，如果是pipeline.addLast(&quot;Handler&quot;,new Handler())方式，无论是否添加注解@Sharable都是不生效的，因为每个Socket通道都是新的Handler实例；如果pipeline.addLast()添加的Handler是在前面代码实例化好的Handler，即pipeline.addLast(&quot;Handler&quot;,handler)方式，则该Handler必须添加@Sharable注解，因为就一个实例，否则会报错。","like_count":5,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484526,"discussion_content":"是的，所以也是一种保护。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588641800,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160626,"user_name":"可爱的小奶狗","can_delete":false,"product_type":"c3","uid":1178236,"ip_address":"","ucode":"DC810503571DD2","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/7c/f8f38ad0.jpg","comment_is_top":false,"comment_ctime":1575988614,"is_pvip":false,"replies":[{"id":61361,"content":"对于共享的handler就不是一个socket channel一个了，是共享的，所以第一个socket初始化完成后，handler的.added就变成true了，所以演示的时候搞两个客户端做连接，第一个不报错，第二个报错，你再好好体会下，有问题再留言即可，谢谢","user_name":"作者回复","user_name_real":"傅健","uid":1638649,"ctime":1576064926,"ip_address":"","comment_id":160626,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"老师，为啥h.added在第一次访问后就是true了？对于不同的niosocketchannel的不同的handler，应该不会是true啊","like_count":0,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477436,"discussion_content":"对于共享的handler就不是一个socket channel一个了，是共享的，所以第一个socket初始化完成后，handler的.added就变成true了，所以演示的时候搞两个客户端做连接，第一个不报错，第二个报错，你再好好体会下，有问题再留言即可，谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576064926,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1178236,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fa/7c/f8f38ad0.jpg","nickname":"可爱的小奶狗","note":"","ucode":"DC810503571DD2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79399,"discussion_content":"原来这个added是和handler绑定的(是handler的成员变量)，如果handler是共享或者说&#34;全局&#34;的，那么第一个socket channel 初始化后，就变成了true了。是这样的吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576074903,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":396063,"user_name":"Geek_159e2d","can_delete":false,"product_type":"c3","uid":3231519,"ip_address":"浙江","ucode":"8353F32D38C371","user_header":"https://static001.geekbang.org/account/avatar/00/31/4f/1f/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1732871202,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"为什么我无论在是注释或者不注释 @ChannelHandler.Sharable 的情况下，启动多个 Client 都不会报错？我的版本是 4.1.36.Final","like_count":0},{"had_liked":false,"id":180085,"user_name":"Sonny721","can_delete":false,"product_type":"c3","uid":1104291,"ip_address":"","ucode":"C95DD306BFBE54","user_header":"https://static001.geekbang.org/account/avatar/00/10/d9/a3/2856b5b5.jpg","comment_is_top":false,"comment_ctime":1582184629,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"老师您好，那么有这么一个Handler，它是不能共享的，即存在线程安全，也就不能添加标注@Sharable，那怎么办？按照您的代码演示会报错？","like_count":0}]}