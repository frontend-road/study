{"id":13530,"title":"14 | Java虚拟机是怎么实现synchronized的？","content":"<p>在Java程序中，我们可以利用synchronized关键字来对程序进行加锁。它既可以用来声明一个synchronized代码块，也可以直接标记静态方法或者实例方法。</p>\n<p>当声明synchronized代码块时，编译而成的字节码将包含monitorenter和monitorexit指令。这两种指令均会消耗操作数栈上的一个引用类型的元素（也就是synchronized关键字括号里的引用），作为所要加锁解锁的锁对象。</p>\n<pre><code>  public void foo(Object lock) {\n    synchronized (lock) {\n      lock.hashCode();\n    }\n  }\n  // 上面的Java代码将编译为下面的字节码\n  public void foo(java.lang.Object);\n    Code:\n       0: aload_1\n       1: dup\n       2: astore_2\n       3: monitorenter\n       4: aload_1\n       5: invokevirtual java/lang/Object.hashCode:()I\n       8: pop\n       9: aload_2\n      10: monitorexit\n      11: goto          19\n      14: astore_3\n      15: aload_2\n      16: monitorexit\n      17: aload_3\n      18: athrow\n      19: return\n    Exception table:\n       from    to  target type\n           4    11    14   any\n          14    17    14   any\n\n</code></pre>\n<p>我在文稿中贴了一段包含synchronized代码块的Java代码，以及它所编译而成的字节码。你可能会留意到，上面的字节码中包含一个monitorenter指令以及多个monitorexit指令。这是因为Java虚拟机需要确保所获得的锁在正常执行路径，以及异常执行路径上都能够被解锁。</p>\n<p><span class=\"reference\">你可以根据我在介绍异常处理时介绍过的知识，对照字节码和异常处理表来构造所有可能的执行路径，看看在执行了monitorenter指令之后，是否都有执行monitorexit指令。</span></p>\n<p>当用synchronized标记方法时，你会看到字节码中方法的访问标记包括ACC_SYNCHRONIZED。该标记表示在进入该方法时，Java虚拟机需要进行monitorenter操作。而在退出该方法时，不管是正常返回，还是向调用者抛异常，Java虚拟机均需要进行monitorexit操作。</p><!-- [[[read_end]]] -->\n<pre><code>  public synchronized void foo(Object lock) {\n    lock.hashCode();\n  }\n  // 上面的Java代码将编译为下面的字节码\n  public synchronized void foo(java.lang.Object);\n    descriptor: (Ljava/lang/Object;)V\n    flags: (0x0021) ACC_PUBLIC, ACC_SYNCHRONIZED\n    Code:\n      stack=1, locals=2, args_size=2\n         0: aload_1\n         1: invokevirtual java/lang/Object.hashCode:()I\n         4: pop\n         5: return\n</code></pre>\n<p>这里monitorenter和monitorexit操作所对应的锁对象是隐式的。对于实例方法来说，这两个操作对应的锁对象是this；对于静态方法来说，这两个操作对应的锁对象则是所在类的Class实例。</p>\n<p>关于monitorenter和monitorexit的作用，我们可以抽象地理解为每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针。</p>\n<p>当执行monitorenter时，如果目标锁对象的计数器为0，那么说明它没有被其他线程所持有。在这个情况下，Java虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器加1。</p>\n<p>在目标锁对象的计数器不为0的情况下，如果锁对象的持有线程是当前线程，那么Java虚拟机可以将其计数器加1，否则需要等待，直至持有线程释放该锁。</p>\n<p>当执行monitorexit时，Java虚拟机则需将锁对象的计数器减1。当计数器减为0时，那便代表该锁已经被释放掉了。</p>\n<p>之所以采用这种计数器的方式，是为了允许同一个线程重复获取同一把锁。举个例子，如果一个Java类中拥有多个synchronized方法，那么这些方法之间的相互调用，不管是直接的还是间接的，都会涉及对同一把锁的重复加锁操作。因此，我们需要设计这么一个可重入的特性，来避免编程里的隐式约束。</p>\n<p>说完抽象的锁算法，下面我们便来介绍HotSpot虚拟机中具体的锁实现。</p>\n<h2>重量级锁</h2>\n<p>重量级锁是Java虚拟机中最为基础的锁实现。在这种状态下，Java虚拟机会阻塞加锁失败的线程，并且在目标锁被释放的时候，唤醒这些线程。</p>\n<p>Java线程的阻塞以及唤醒，都是依靠操作系统来完成的。举例来说，对于符合posix接口的操作系统（如macOS和绝大部分的Linux），上述操作是通过pthread的互斥锁（mutex）来实现的。此外，这些操作将涉及系统调用，需要从操作系统的用户态切换至内核态，其开销非常之大。</p>\n<p>为了尽量避免昂贵的线程阻塞、唤醒操作，Java虚拟机会在线程进入阻塞状态之前，以及被唤醒后竞争不到锁的情况下，进入自旋状态，在处理器上空跑并且轮询锁是否被释放。如果此时锁恰好被释放了，那么当前线程便无须进入阻塞状态，而是直接获得这把锁。</p>\n<p>与线程阻塞相比，自旋状态可能会浪费大量的处理器资源。这是因为当前线程仍处于运行状况，只不过跑的是无用指令。它期望在运行无用指令的过程中，锁能够被释放出来。</p>\n<p>我们可以用等红绿灯作为例子。Java线程的阻塞相当于熄火停车，而自旋状态相当于怠速停车。如果红灯的等待时间非常长，那么熄火停车相对省油一些；如果红灯的等待时间非常短，比如说我们在synchronized代码块里只做了一个整型加法，那么在短时间内锁肯定会被释放出来，因此怠速停车更加合适。</p>\n<p>然而，对于Java虚拟机来说，它并不能看到红灯的剩余时间，也就没办法根据等待时间的长短来选择自旋还是阻塞。Java虚拟机给出的方案是自适应自旋，根据以往自旋等待时是否能够获得锁，来动态调整自旋的时间（循环数目）。</p>\n<p>就我们的例子来说，如果之前不熄火等到了绿灯，那么这次不熄火的时间就长一点；如果之前不熄火没等到绿灯，那么这次不熄火的时间就短一点。</p>\n<p>自旋状态还带来另外一个副作用，那便是不公平的锁机制。处于阻塞状态的线程，并没有办法立刻竞争被释放的锁。然而，处于自旋状态的线程，则很有可能优先获得这把锁。</p>\n<h2>轻量级锁</h2>\n<p>你可能见到过深夜的十字路口，四个方向都闪黄灯的情况。由于深夜十字路口的车辆来往可能比较少，如果还设置红绿灯交替，那么很有可能出现四个方向仅有一辆车在等红灯的情况。</p>\n<p>因此，红绿灯可能被设置为闪黄灯的情况，代表车辆可以自由通过，但是司机需要注意观察（个人理解，实际意义请咨询交警部门）。</p>\n<p>Java虚拟机也存在着类似的情形：多个线程在不同的时间段请求同一把锁，也就是说没有锁竞争。针对这种情形，Java虚拟机采用了轻量级锁，来避免重量级锁的阻塞以及唤醒。</p>\n<p>在介绍轻量级锁的原理之前，我们先来了解一下Java虚拟机是怎么区分轻量级锁和重量级锁的。</p>\n<p>（你可以参照<a href=\"https://wiki.openjdk.java.net/display/HotSpot/Synchronization\">HotSpot Wiki</a>里这张图阅读。）</p>\n<p>在对象内存布局那一篇中我曾经介绍了对象头中的标记字段（mark word）。它的最后两位便被用来表示该对象的锁状态。其中，00代表轻量级锁，01代表无锁（或偏向锁），10代表重量级锁，11则跟垃圾回收算法的标记有关。</p>\n<p>当进行加锁操作时，Java虚拟机会判断是否已经是重量级锁。如果不是，它会在当前线程的当前栈桢中划出一块空间，作为该锁的锁记录，并且将锁对象的标记字段复制到该锁记录中。</p>\n<p>然后，Java虚拟机会尝试用CAS（compare-and-swap）操作替换锁对象的标记字段。这里解释一下，CAS是一个原子操作，它会比较目标地址的值是否和期望值相等，如果相等，则替换为一个新的值。</p>\n<p>假设当前锁对象的标记字段为X…XYZ，Java虚拟机会比较该字段是否为X…X01。如果是，则替换为刚才分配的锁记录的地址。由于内存对齐的缘故，它的最后两位为00。此时，该线程已成功获得这把锁，可以继续执行了。</p>\n<p>如果不是X…X01，那么有两种可能。第一，该线程重复获取同一把锁。此时，Java虚拟机会将锁记录清零，以代表该锁被重复获取。第二，其他线程持有该锁。此时，Java虚拟机会将这把锁膨胀为重量级锁，并且阻塞当前线程。</p>\n<p>当进行解锁操作时，如果当前锁记录（你可以将一个线程的所有锁记录想象成一个栈结构，每次加锁压入一条锁记录，解锁弹出一条锁记录，当前锁记录指的便是栈顶的锁记录）的值为0，则代表重复进入同一把锁，直接返回即可。</p>\n<p>否则，Java虚拟机会尝试用CAS操作，比较锁对象的标记字段的值是否为当前锁记录的地址。如果是，则替换为锁记录中的值，也就是锁对象原本的标记字段。此时，该线程已经成功释放这把锁。</p>\n<p>如果不是，则意味着这把锁已经被膨胀为重量级锁。此时，Java虚拟机会进入重量级锁的释放过程，唤醒因竞争该锁而被阻塞了的线程。</p>\n<h2>偏向锁</h2>\n<p>如果说轻量级锁针对的情况很乐观，那么接下来的偏向锁针对的情况则更加乐观：从始至终只有一个线程请求某一把锁。</p>\n<p>这就好比你在私家庄园里装了个红绿灯，并且庄园里只有你在开车。偏向锁的做法便是在红绿灯处识别来车的车牌号。如果匹配到你的车牌号，那么直接亮绿灯。</p>\n<p>具体来说，在线程进行加锁时，如果该锁对象支持偏向锁，那么Java虚拟机会通过CAS操作，将当前线程的地址记录在锁对象的标记字段之中，并且将标记字段的最后三位设置为101。</p>\n<p>在接下来的运行过程中，每当有线程请求这把锁，Java虚拟机只需判断锁对象标记字段中：最后三位是否为101，是否包含当前线程的地址，以及epoch值是否和锁对象的类的epoch值相同。如果都满足，那么当前线程持有该偏向锁，可以直接返回。</p>\n<p>这里的epoch值是一个什么概念呢？</p>\n<p>我们先从偏向锁的撤销讲起。当请求加锁的线程和锁对象标记字段保持的线程地址不匹配时（而且epoch值相等，如若不等，那么当前线程可以将该锁重偏向至自己），Java虚拟机需要撤销该偏向锁。这个撤销过程非常麻烦，它要求持有偏向锁的线程到达安全点，再将偏向锁替换成轻量级锁。</p>\n<p>如果某一类锁对象的总撤销数超过了一个阈值（对应Java虚拟机参数-XX:BiasedLockingBulkRebiasThreshold，默认为20），那么Java虚拟机会宣布这个类的偏向锁失效。</p>\n<p>具体的做法便是在每个类中维护一个epoch值，你可以理解为第几代偏向锁。当设置偏向锁时，Java虚拟机需要将该epoch值复制到锁对象的标记字段中。</p>\n<p>在宣布某个类的偏向锁失效时，Java虚拟机实则将该类的epoch值加1，表示之前那一代的偏向锁已经失效。而新设置的偏向锁则需要复制新的epoch值。</p>\n<p>为了保证当前持有偏向锁并且已加锁的线程不至于因此丢锁，Java虚拟机需要遍历所有线程的Java栈，找出该类已加锁的实例，并且将它们标记字段中的epoch值加1。该操作需要所有线程处于安全点状态。</p>\n<p>如果总撤销数超过另一个阈值（对应Java虚拟机参数 -XX:BiasedLockingBulkRevokeThreshold，默认值为40），那么Java虚拟机会认为这个类已经不再适合偏向锁。此时，Java虚拟机会撤销该类实例的偏向锁，并且在之后的加锁过程中直接为该类实例设置轻量级锁。</p>\n<h2>总结与实践</h2>\n<p>今天我介绍了Java虚拟机中synchronized关键字的实现，按照代价由高至低可分为重量级锁、轻量级锁和偏向锁三种。</p>\n<p>重量级锁会阻塞、唤醒请求加锁的线程。它针对的是多个线程同时竞争同一把锁的情况。Java虚拟机采取了自适应自旋，来避免线程在面对非常小的synchronized代码块时，仍会被阻塞、唤醒的情况。</p>\n<p>轻量级锁采用CAS操作，将锁对象的标记字段替换为一个指针，指向当前线程栈上的一块空间，存储着锁对象原本的标记字段。它针对的是多个线程在不同时间段申请同一把锁的情况。</p>\n<p>偏向锁只会在第一次请求时采用CAS操作，在锁对象的标记字段中记录下当前线程的地址。在之后的运行过程中，持有该偏向锁的线程的加锁操作将直接返回。它针对的是锁仅会被同一线程持有的情况。</p>\n<p>今天的实践环节，我们来验证一个坊间传闻：调用Object.hashCode()会关闭该对象的偏向锁[1]。</p>\n<p>你可以采用参数-XX:+PrintBiasedLockingStatistics来打印各类锁的个数。由于C2使用的是另外一个参数-XX:+PrintPreciseBiasedLockingStatistics，因此你可以限制Java虚拟机仅使用C1来即时编译（对应参数-XX:TieredStopAtLevel=1）。</p>\n<ol>\n<li>通过参数-XX:+UseBiasedLocking，比较开关偏向锁时的输出结果。</li>\n<li>在main方法的循环前添加lock.hashCode调用，并查看输出结果。</li>\n<li>在Lock类中复写hashCode方法，并查看输出结果。</li>\n<li>在main方法的循环前添加System.identityHashCode调用，并查看输出结果。</li>\n</ol>\n<pre><code>// Run with -XX:+UnlockDiagnosticVMOptions -XX:+PrintBiasedLockingStatistics -XX:TieredStopAtLevel=1\npublic class SynchronizedTest {\n\n  static Lock lock = new Lock();\n  static int counter = 0;\n\n  public static void foo() {\n    synchronized (lock) {\n      counter++;\n    }\n  }\n\n  public static void main(String[] args) throws InterruptedException {\n    // lock.hashCode(); // Step 2\n    // System.identityHashCode(lock); // Step 4\n    for (int i = 0; i &lt; 1_000_000; i++) {\n      foo();\n    }\n  }\n\n  static class Lock {\n    // @Override public int hashCode() { return 0; } // Step 3\n  }\n}\n</code></pre>\n<p>[1] <a href=\"https://blogs.oracle.com/dave/biased-locking-in-hotspot\">https://blogs.oracle.com/dave/biased-locking-in-hotspot</a></p>\n<p></p>\n","neighbors":{"left":{"article_title":"13 | Java内存模型","id":13484},"right":{"article_title":"15 | Java语法糖与Java编译器","id":13781}},"comments":[{"had_liked":false,"id":22585,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1535806920,"is_pvip":false,"replies":[{"id":"8204","content":"多谢建议！<br><br>本文的讲解流程是从通用锁算法到针对特殊情况的锁算法来的。一开始monitorenter是用重型锁的，然后为了针对没有竞争锁的情况有了轻型锁，再然后为了针对只有一个线程持有某个锁的情况有了偏向锁。","user_name":"作者回复","comment_id":22585,"uid":"1176688","ip_address":"","utype":1,"ctime":1535967191,"user_name_real":"郑雨迪"}],"discussion_count":4,"race_medal":0,"score":"121794891208","product_id":100010301,"comment_content":"恩，今天才补上小结，因为听不明白了，后来反复听以及补上锁的相关知识才有点明白。<br>我认为雨迪确实应该补上点图，这样才更容易理解，否则确实抽象，另外，我觉得讲解的次序有点小问题。<br>如果这样讲就更容易理解了（个人见解）<br>1:讲解一下锁的本质，锁到底是个什么东西？锁的特点容易理解，毕竟都见过摸过用过<br><br>2:讲解一下锁的分类和特点，什么表锁、行锁、自旋锁、可重用锁、轻量锁、重量锁、阻塞锁、线程锁、进程锁、分布式锁、偏向锁等等吧！都是站在不同的角度或层级根据锁的特点，为了好区分给锁起的名字<br><br>3:讲解一下JVM中的各种锁，讲解一下他们的特点和实现，然后讲解一下咱们本节的主角是属于哪一种或哪几种锁<br><br>4:我的理解，锁的本质-在程序世界里是一种保证资源正确竞争的机制，如果没有对同一资源竞争也就没有了锁存在的意义，在计算世界中资源引起竞争的核心基本是空间，有其是计算机的内存空间，当然数据肯定也是一种引起激烈竞争的资源，不过往往会体现到空间上去，因为计算机中的数据必定存于某空间地址之中的<br><br>5:感觉明白可重用锁的实现原理了，这个也是雨迪讲的最细致的一种实现方式，恩，非常感谢🙏","like_count":29,"discussions":[{"author":{"id":1166966,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ce/76/a344ccad.jpg","nickname":"放羊的村长","note":"","ucode":"AF948FCE8079B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337276,"discussion_content":"作者是站在研究人员的角度，一步步的从重量级的锁发展到现在的轻量级的锁和偏向锁，外面的论坛的文章都是弟弟，这才是一个技术发展应该有的流程","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1608860379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423175,"discussion_content":"多谢建议！\n\n本文的讲解流程是从通用锁算法到针对特殊情况的锁算法来的。一开始monitorenter是用重型锁的，然后为了针对没有竞争锁的情况有了轻型锁，再然后为了针对只有一个线程持有某个锁的情况有了偏向锁。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1535967191,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1048366,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ff/2e/ca3960b0.jpg","nickname":"在野","note":"","ucode":"A700B41D34F58C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261953,"discussion_content":"这块内容看多了后再回来看，感觉讲得没头没尾美筋没骨，哎。。。。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589028115,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1297630,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","nickname":"剑八","note":"","ucode":"0A09F41DB8A4E7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282748,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592062555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21044,"user_name":"爪哇夜未眠","can_delete":false,"product_type":"c1","uid":1006025,"ip_address":"","ucode":"BBEB80EB670770","user_header":"https://static001.geekbang.org/account/avatar/00/0f/59/c9/f44cb7f3.jpg","comment_is_top":false,"comment_ctime":1534898066,"is_pvip":false,"replies":[{"id":"7427","content":"不好意思哈，因为网上有很多图，忘了放个链接了。<br><br>你可以参考wiki.openjdk.java.net&#47;display&#47;HotSpot&#47;Synchronization中的图。","user_name":"作者回复","comment_id":21044,"uid":"1176688","ip_address":"","utype":1,"ctime":1534931605,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"96024178578","product_id":100010301,"comment_content":"太抽象了，老师能画点儿图吗……","like_count":22,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422510,"discussion_content":"不好意思哈，因为网上有很多图，忘了放个链接了。\n\n你可以参考wiki.openjdk.java.net/display/HotSpot/Synchronization中的图。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534931605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":41528,"user_name":"QlDoors","can_delete":false,"product_type":"c1","uid":1005911,"ip_address":"","ucode":"394F3E6CE39392","user_header":"https://static001.geekbang.org/account/avatar/00/0f/59/57/449e76fb.jpg","comment_is_top":false,"comment_ctime":1542801590,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"83147180214","product_id":100010301,"comment_content":"练习试了无数遍，都没有偏向锁，后来上网查才发现需要加-XX:BiasedLockingStartupDelay=0。<br><br>http:&#47;&#47;zhizus.com&#47;2018-09-03-%E5%81%8F%E5%90%91%E9%94%81.html<br><br>注意：Hotspot虚拟机在开机启动后有个延迟（4s），经过延迟后才会对每个创建的对象开启偏向锁。我们可以通过设置下面的参数来修改这个延迟，或者直接sleep一段时间-XX:BiasedLockingStartupDelay=0","like_count":20,"discussions":[{"author":{"id":1179184,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fe/30/c9b568c3.jpg","nickname":"NullPointer","note":"","ucode":"83B7DA926A0411","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297048,"discussion_content":"刚启动JVM内部有很多线程跑，所以开始并没有使用。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596760120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21221,"user_name":"谢阳","can_delete":false,"product_type":"c1","uid":1019623,"ip_address":"","ucode":"A9ABD36885E7AA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/e7/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1534983429,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"78844394757","product_id":100010301,"comment_content":"如果不是 X…X01，那么有两种可能。第一，该线程重复获取同一把锁。此时，Java 虚拟机会将锁记录清零，以代表该锁被重复获取。第二，其他线程持有该锁。此时，Java 虚拟机会将这把锁膨胀为重量级锁，并且阻塞当前线程。<br><br>老师这段不太明白。1 锁记录清零怎么理解？改变锁对象的标记字段吗？2 锁膨胀的时候其他线程还持有锁对象吧，这个时候膨胀会具体做什么操作？如果操作了锁对象的标记字段会影响稍后释放锁的cas吗","like_count":18,"discussions":[{"author":{"id":1508990,"avatar":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","nickname":"西门吹牛","note":"","ucode":"E5D3624DDE1E83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291161,"discussion_content":"其实不是清0，而是把0入栈，0就代表是重复的进入一把锁，这样解锁的时候，好判断，直接弹出0就可","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1594720922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1128491,"avatar":"https://static001.geekbang.org/account/avatar/00/11/38/2b/9db9406b.jpg","nickname":"星夜","note":"","ucode":"3B46C09D994CEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310044,"discussion_content":"应该就是一种标识位或者说的锁状态00，毕竟此时只有两种状态，一种为当前线程持有则继续保持轻量级锁，另一种不是当前线程则膨胀为重量级锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601567900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21738,"user_name":"Shine","can_delete":false,"product_type":"c1","uid":1022568,"ip_address":"","ucode":"C8C617B87C63C7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9a/68/92caeed6.jpg","comment_is_top":false,"comment_ctime":1535290311,"is_pvip":false,"replies":[{"id":"8014","content":"对的！赞","user_name":"作者回复","comment_id":21738,"uid":"1176688","ip_address":"","utype":1,"ctime":1535620835,"user_name_real":"郑雨迪"}],"discussion_count":2,"race_medal":0,"score":"65959799751","product_id":100010301,"comment_content":"“当进行解锁操作时，如果当前锁记录（你可以将一个线程的所有锁记录想象成一个栈结构，每次加锁压入一条锁记录，解锁弹出一条锁记录，当前锁记录指的便是栈顶的锁记录）的值为 0，则代表重复进入同一把锁，直接返回即可。”<br>这种情况也需要弹出当前锁记录的吧？ 不然锁记录一直是0不变了。 如果是我这样理解的话，重复获取同一把锁的话，不是简单地清零，而应该是把0作为一条新的锁记录压入栈顶。<br>不知道我这样理解对不？请老师指点","like_count":16,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422835,"discussion_content":"对的！赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535620835,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1261360,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3f/30/23f6b413.jpg","nickname":"五十九秒","note":"","ucode":"1F34F62193CFF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":264653,"discussion_content":"还是没懂，如果线程持有多把锁呢？为什么是栈顶的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589341261,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":234355,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1594652763,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"53134260315","product_id":100010301,"comment_content":"听了N次，仔细读了一遍，还是不够。有同样情况的，赞起","like_count":12},{"had_liked":false,"id":21071,"user_name":"NEO🍋","can_delete":false,"product_type":"c1","uid":1166817,"ip_address":"","ucode":"802C34758A5185","user_header":"https://static001.geekbang.org/account/avatar/00/11/cd/e1/368f872c.jpg","comment_is_top":false,"comment_ctime":1534901436,"is_pvip":false,"replies":[{"id":"7416","content":"哈，这个属于应用程序的问题，JVM只是观察到这种情况，并尝试做出优化。<br><br>有一种可能，就是很长一段时间内，只有一个线程频繁加锁，后面换成另外的线程，这样前面那段时间可以用偏向锁。","user_name":"作者回复","comment_id":21071,"uid":"1176688","ip_address":"","utype":1,"ctime":1534929002,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"48779541692","product_id":100010301,"comment_content":"老师关于偏向锁有个疑问 “它针对的是锁仅会被同一线程持有的情况。” 如果只有一个线程持有锁 还有必要加锁吗？","like_count":11,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422519,"discussion_content":"哈，这个属于应用程序的问题，JVM只是观察到这种情况，并尝试做出优化。\n\n有一种可能，就是很长一段时间内，只有一个线程频繁加锁，后面换成另外的线程，这样前面那段时间可以用偏向锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534929002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33690,"user_name":"Geek_987169","can_delete":false,"product_type":"c1","uid":1180853,"ip_address":"","ucode":"4B2955A044805D","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/b5/8bc4790b.jpg","comment_is_top":false,"comment_ctime":1539854266,"is_pvip":false,"replies":[{"id":"12757","content":"1. 单向不可逆 针对一个对象的整个生命周期。<br><br>epoch+1发生在多次同一类型的实例的偏向锁撤销之后，存放在类型(Class)那里的。<br><br>2. 当频繁检测到某个类的实例出现撤销偏向锁的，就代表这个类不适合用来搞偏向锁。","user_name":"作者回复","comment_id":33690,"uid":"1176688","ip_address":"","utype":1,"ctime":1540821406,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"31604625338","product_id":100010301,"comment_content":"老师请教个问题：<br>1：锁从偏向一直到重量级的过程是&quot;单向不可逆&quot;的，这个&quot;单向不可逆&quot;是限制在对象的整个生命周期，还是在对象到达了某个状态后再次有线程使用其作为锁对象还会继续重复这个过程？从每撤销一次对象的epoch值就会+1，而这个+1代表的就是偏向锁升级为轻量级锁，而每个对象又维护了一个epoch值代表对象撤销次数（偏向锁-&gt;轻量级锁次数），是不是就代表这个锁升级的过程会在不同的时间段重复发生n词？<br>2：为什么要设置一个最大的撤销次数（epoch值），意义在哪里？","like_count":7,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427029,"discussion_content":"1. 单向不可逆 针对一个对象的整个生命周期。\n\nepoch+1发生在多次同一类型的实例的偏向锁撤销之后，存放在类型(Class)那里的。\n\n2. 当频繁检测到某个类的实例出现撤销偏向锁的，就代表这个类不适合用来搞偏向锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540821406,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21176,"user_name":"贾智文","can_delete":false,"product_type":"c1","uid":1100235,"ip_address":"","ucode":"600CF0AB215D1A","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/cb/7b6802cc.jpg","comment_is_top":false,"comment_ctime":1534951584,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"27304755360","product_id":100010301,"comment_content":"文中说轻量级锁因为内存对齐所以标识位是00，那么为什么重量级锁的时候，存储内容也是指针，却没有内存对齐呢？","like_count":6,"discussions":[{"author":{"id":1768152,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/fa/d8/7c2b6c0b.jpg","nickname":"闲人","note":"","ucode":"9A8F33260A44E1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":135354,"discussion_content":"我的理解是:重量级锁也是对齐的，只是把lock占的两位改为了10，轻量级锁没做变更为00,节省了cpu操作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579088174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":57985,"user_name":"第9根烟","can_delete":false,"product_type":"c1","uid":1117723,"ip_address":"","ucode":"7EBDF6E695855A","user_header":"https://static001.geekbang.org/account/avatar/00/11/0e/1b/1902d6fa.jpg","comment_is_top":false,"comment_ctime":1546956693,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23021793173","product_id":100010301,"comment_content":"这边验证了Object.hashCode() 不会关闭该对象的偏向锁。。不知道最后答案是什么？哪里有全篇的课后作业的答案？","like_count":4},{"had_liked":false,"id":156734,"user_name":"木心","can_delete":false,"product_type":"c1","uid":1043293,"ip_address":"","ucode":"538A3B9B214BF7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/eb/5d/2467ad6c.jpg","comment_is_top":false,"comment_ctime":1574944007,"is_pvip":false,"replies":[{"id":"60615","content":"自旋本质是空转cpu等待，只有在别人拿着锁，自己请求锁的情况下发生。偏向锁无需此步骤，栈锁别人没有持有锁，也不需要自旋","user_name":"作者回复","comment_id":156734,"uid":"1176688","ip_address":"","utype":1,"ctime":1575365885,"user_name_real":"郑雨迪"}],"discussion_count":6,"race_medal":0,"score":"18754813191","product_id":100010301,"comment_content":"很多文章说 自旋 是在轻量级锁中发生的 《Java并发编程的艺术》<br>但是在这里 自旋 是在重量级锁中<br>这个怎么解释呢?<br>https:&#47;&#47;www.aimoon.site&#47;blog&#47;2018&#47;05&#47;21&#47;biased-locking&#47;<br>","like_count":4,"discussions":[{"author":{"id":1397031,"avatar":"https://static001.geekbang.org/account/avatar/00/15/51/27/f0dd6f19.jpg","nickname":"老白","note":"","ucode":"39881175152D49","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":93380,"discussion_content":"看了下源码更新一下，重量级锁获取过程中也有自旋操作，降低系统调用引起的开销。","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1576924264,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476216,"discussion_content":"自旋本质是空转cpu等待，只有在别人拿着锁，自己请求锁的情况下发生。偏向锁无需此步骤，栈锁别人没有持有锁，也不需要自旋","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575365885,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1818343,"avatar":"","nickname":"刘同青","note":"","ucode":"84B62DF8BC61FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278761,"discussion_content":"mark,  这点我也有疑问，现在不清楚自旋到底发生在哪里了😂😂😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591232910,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1043293,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/eb/5d/2467ad6c.jpg","nickname":"木心","note":"","ucode":"538A3B9B214BF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70549,"discussion_content":"偏向锁是不需要的，但是轻量级锁呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575366884,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1397031,"avatar":"https://static001.geekbang.org/account/avatar/00/15/51/27/f0dd6f19.jpg","nickname":"老白","note":"","ucode":"39881175152D49","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1043293,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/eb/5d/2467ad6c.jpg","nickname":"木心","note":"","ucode":"538A3B9B214BF7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":93212,"discussion_content":"synchronized 里面的自旋就是在轻量级锁获取过程中，偏向和重量级没有。重量级锁是直接用了底层的mutex了，判断是重量级锁后就去系统调用加锁，会阻塞。轻量级锁引入自旋是因为尽量不让线程进入系统调用。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576914770,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":70549,"ip_address":""},"score":93212,"extra":""},{"author":{"id":1397031,"avatar":"https://static001.geekbang.org/account/avatar/00/15/51/27/f0dd6f19.jpg","nickname":"老白","note":"","ucode":"39881175152D49","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1043293,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/eb/5d/2467ad6c.jpg","nickname":"木心","note":"","ucode":"538A3B9B214BF7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":93213,"discussion_content":"而偏向锁检查一次失败后就要检测是否需要升级为轻量级锁了，所以也没有自旋。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576914816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":70549,"ip_address":""},"score":93213,"extra":""}]}]},{"had_liked":false,"id":21164,"user_name":"唯一","can_delete":false,"product_type":"c1","uid":1191310,"ip_address":"","ucode":"FB9145E02E976B","user_header":"https://static001.geekbang.org/account/avatar/00/12/2d/8e/f9a22b2e.jpg","comment_is_top":false,"comment_ctime":1534946396,"is_pvip":false,"replies":[{"id":"7621","content":"这个说法有点歧义。<br><br>按我的理解，你应该在问是否为当前线程获得这把锁？那么答案是对的，一直是当前线程获得这把锁。<br><br>另外，锁是加在目标锁对象上的。","user_name":"作者回复","comment_id":21164,"uid":"1176688","ip_address":"","utype":1,"ctime":1535117285,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"18714815580","product_id":100010301,"comment_content":"老师，问一下加锁实际上都是加在当前线程吗","like_count":4,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422559,"discussion_content":"这个说法有点歧义。\n\n按我的理解，你应该在问是否为当前线程获得这把锁？那么答案是对的，一直是当前线程获得这把锁。\n\n另外，锁是加在目标锁对象上的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535117285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21036,"user_name":"何yuan","can_delete":false,"product_type":"c1","uid":1117873,"ip_address":"","ucode":"9515496270D013","user_header":"https://static001.geekbang.org/account/avatar/00/11/0e/b1/aab3759b.jpg","comment_is_top":false,"comment_ctime":1534896469,"is_pvip":false,"replies":[{"id":"7418","content":"默认情况下是的。以前有个延缓毫秒数-XX:BiasedLockingStartupDelay，一开始用轻量级锁，在启动四秒之后才开始用偏向锁。我记得Java 9还是10默认值改为0了。","user_name":"作者回复","comment_id":21036,"uid":"1176688","ip_address":"","utype":1,"ctime":1534929953,"user_name_real":"郑雨迪"}],"discussion_count":2,"race_medal":0,"score":"18714765653","product_id":100010301,"comment_content":"一直认为synchronized是重量锁，是否也不一定？jvm处理的时候是先将当偏向锁处理，然后慢慢膨胀为重量级锁的是吗？","like_count":4,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422507,"discussion_content":"默认情况下是的。以前有个延缓毫秒数-XX:BiasedLockingStartupDelay，一开始用轻量级锁，在启动四秒之后才开始用偏向锁。我记得Java 9还是10默认值改为0了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534929953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1064902,"avatar":"https://static001.geekbang.org/account/avatar/00/10/3f/c6/c2bf55bd.jpg","nickname":"devilyaos","note":"","ucode":"5FE075608F03F7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":238878,"discussion_content":"mark...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587258104,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":70639,"user_name":"加载中……","can_delete":false,"product_type":"c1","uid":1366948,"ip_address":"","ucode":"3E59A0A0784D0A","user_header":"https://static001.geekbang.org/account/avatar/00/14/db/a4/191be6ad.jpg","comment_is_top":false,"comment_ctime":1551151485,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14436053373","product_id":100010301,"comment_content":"您好，文章写的挺好，读完有个问题想请教下：<br>当t1线程获取了某个对象锁（lock1）的偏向锁，还没执行完的时候，另外一个线程t2也尝试获取这个对象锁(lock1)，我看文章上说需要撤销偏向锁，等到达安全点的时候，再将偏向锁替换成轻量级锁。<br>我有个问题：两个线程同时竞争同一把锁的情况，轻量级锁也解决不了吧，只能用重量级锁解决吧？为什么还要替换成轻量级锁呢？","like_count":3},{"had_liked":false,"id":24590,"user_name":"Leon Wong","can_delete":false,"product_type":"c1","uid":1073650,"ip_address":"","ucode":"B49B327367CF9E","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/f2/ca989d6f.jpg","comment_is_top":false,"comment_ctime":1537157169,"is_pvip":false,"replies":[{"id":"9027","content":"我印象中不会自旋，直接膨胀。<br><br>轻量级锁的假设是，不同线程拿同一把锁的时间没有overlap。一旦有了overlap，即需要竞争锁的情况，那么假设失效，需要膨胀为重量锁。<br><br>如果乐观点的话，猜测只有这一次假设失效，那也可以自旋一会再膨胀。不过我记得没有这么乐观。<br><br>你可以自己读hotspot的源代码，share&#47;runtime&#47;synchronizer.cpp ObjectSynchronizer:fast_enter","user_name":"作者回复","comment_id":24590,"uid":"1176688","ip_address":"","utype":1,"ctime":1537177142,"user_name_real":"郑雨迪"}],"discussion_count":3,"race_medal":0,"score":"14422059057","product_id":100010301,"comment_content":"老师你好，本课程在介绍轻量级锁的时候，没提及轻量级锁在其他线程占用改锁的的时候，是否会进入自旋状态，我先前的理解是，轻量级锁在被其他线程占用的时候，会进入短暂的自旋状态，当自旋达到一定的阈值后，膨胀为重量级锁，阻塞当前线程，不知道我这么理解是否正确？","like_count":3,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424047,"discussion_content":"我印象中不会自旋，直接膨胀。\n\n轻量级锁的假设是，不同线程拿同一把锁的时间没有overlap。一旦有了overlap，即需要竞争锁的情况，那么假设失效，需要膨胀为重量锁。\n\n如果乐观点的话，猜测只有这一次假设失效，那也可以自旋一会再膨胀。不过我记得没有这么乐观。\n\n你可以自己读hotspot的源代码，share/runtime/synchronizer.cpp ObjectSynchronizer:fast_enter","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537177142,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1818343,"avatar":"","nickname":"刘同青","note":"","ucode":"84B62DF8BC61FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278781,"discussion_content":"这个博主准备工作不够啊。。。回答问题各种&#34;印象中&#34;&#34;我感觉&#34;的😂😂😂","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591233725,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383587,"discussion_content":"8的版本是不会自旋的，轻量锁就是轻量锁当标志位从偏向取消或者说摘除 那么就要将其膨胀为轻量级锁。\n而轻量级锁实际上是cas竞争 做个标记位而已，如果此时还有竞争那么就会膨胀。再膨胀后做用户态自旋。代码：ObjectMonitor::TrySpin_VaryDuration (Thread * Self) \n另外一说的是JDK11做了重写 JDK18做了偏向锁摘除","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626171082,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21076,"user_name":"贾智文","can_delete":false,"product_type":"c1","uid":1100235,"ip_address":"","ucode":"600CF0AB215D1A","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/cb/7b6802cc.jpg","comment_is_top":false,"comment_ctime":1534902733,"is_pvip":false,"replies":[{"id":"7425","content":"这里可能没写清楚。我指的是标记字段的bits是否为X..X01，其中X..X是从原本的标记字段拷过来的。","user_name":"作者回复","comment_id":21076,"uid":"1176688","ip_address":"","utype":1,"ctime":1534931179,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"14419804621","product_id":100010301,"comment_content":"假设当前锁对象的标记字段为 X…XYZ，Java 虚拟机会比较该字段是否为 X…X01。   老师请问这个x……x01是什么，根据什么来的呢？","like_count":3,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422523,"discussion_content":"这里可能没写清楚。我指的是标记字段的bits是否为X..X01，其中X..X是从原本的标记字段拷过来的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534931179,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83793,"user_name":"ゞ、今生绝恋丶","can_delete":false,"product_type":"c1","uid":1107054,"ip_address":"","ucode":"6F64B4BD0ED847","user_header":"https://static001.geekbang.org/account/avatar/00/10/e4/6e/ef9aece4.jpg","comment_is_top":false,"comment_ctime":1554716432,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"10144651024","product_id":100010301,"comment_content":"雨迪老师，我有个疑问：假设线程A加锁，CAS将锁对象对象头替换成指向线程A的Lock Record的地址，在这里，原值：对象mark word中的内容，也就是hashcode，期望值：本线程Lock Record地址，对象：锁对象，在替换成功后我们说线程A获得了锁，OK，线程A开始执行同步代码块，在它执行完之前，线程B来获取锁，发现属于轻量级锁标志，于是CAS替换mark word，此时CAS的原值仍然为为锁对象的mark word吧，而此时锁对象mark word中记录的不再是hashcode而是指向线程A的Lock Record的地址，但是对于CAS它管你对象头存的是什么，现在获取到什么，什么就是原值，于是：原值：对象头中指向线程A中LR的地址，期望值：线程B中LR（目前对他来说，是将锁对象中指向线程A中LR的地址存入本线程LR）的地址，目标对象：锁对象，怎么会CAS不成功？于是现在线程B也获取到锁，两个线程都会在执行同步代码块！我觉得我理解的哪块不对？","like_count":3,"discussions":[{"author":{"id":1191290,"avatar":"https://static001.geekbang.org/account/avatar/00/12/2d/7a/6d5157d9.jpg","nickname":"旋转跳跃俺闭着眼","note":"","ucode":"F92B7246A9CDBD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2765,"discussion_content":"我这有同样的疑问","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1563927657,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1397031,"avatar":"https://static001.geekbang.org/account/avatar/00/15/51/27/f0dd6f19.jpg","nickname":"老白","note":"","ucode":"39881175152D49","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":93379,"discussion_content":"看了源码，轻量锁获取过程有：THREAD->is_lock_owned((address)mark->locker())这么个过程，会检查lock record 的地址是不是本线程栈空间","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576924215,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2351949,"avatar":"https://static001.geekbang.org/account/avatar/00/23/e3/4d/8a26dbb2.jpg","nickname":"枫中浪子","note":"","ucode":"860BEA32059B37","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1397031,"avatar":"https://static001.geekbang.org/account/avatar/00/15/51/27/f0dd6f19.jpg","nickname":"老白","note":"","ucode":"39881175152D49","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":372656,"discussion_content":"不对吧，这个是判断是否是锁重入的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620401119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":93379,"ip_address":""},"score":372656,"extra":""}]}]},{"had_liked":false,"id":21445,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1535085193,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10125019785","product_id":100010301,"comment_content":"你好，例子运行了，没看出啥不同，只有“fast path lock entries”这个对应的数值不同，slow path lock entries一直是2，其他的都是0。<br><br>建议作者给出自己的实验截图，方便我们对比","like_count":2},{"had_liked":false,"id":21121,"user_name":"(^o^)","can_delete":false,"product_type":"c1","uid":1142842,"ip_address":"","ucode":"AAD9EC32A590E2","user_header":"https://static001.geekbang.org/account/avatar/00/11/70/3a/6b82e940.jpg","comment_is_top":false,"comment_ctime":1534928969,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10124863561","product_id":100010301,"comment_content":"Synchronized某个对象时，这个对象的锁先是偏向锁，后根据具体竞争情况先升级为轻量级锁再升级为重量级锁吗？","like_count":2,"discussions":[{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366078,"discussion_content":"是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617955025,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21097,"user_name":"林QC","can_delete":false,"product_type":"c1","uid":1180579,"ip_address":"","ucode":"7F2A36543505DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/03/a3/fa04ae05.jpg","comment_is_top":false,"comment_ctime":1534912415,"is_pvip":false,"replies":[{"id":"7424","content":"没有，方法有ACC_SYNCHRONIZED标志符","user_name":"作者回复","comment_id":21097,"uid":"1176688","ip_address":"","utype":1,"ctime":1534931063,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"10124847007","product_id":100010301,"comment_content":"当声明 synchronized 代码块时，编译而成的字节码将包含 monitorenter 和 monitorexit 指令。～～老师，标记在方法上也有这两个指令吗？","like_count":2,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422533,"discussion_content":"没有，方法有ACC_SYNCHRONIZED标志符","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534931063,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132390,"user_name":"nidafg","can_delete":false,"product_type":"c1","uid":1146092,"ip_address":"","ucode":"2D57A65FAD46CF","user_header":"https://static001.geekbang.org/account/avatar/00/11/7c/ec/c5a414dd.jpg","comment_is_top":false,"comment_ctime":1568105718,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5863073014","product_id":100010301,"comment_content":"感觉老师讲的很学院派，如果能有图文或者更多比喻就好了","like_count":1},{"had_liked":false,"id":33609,"user_name":"Geek_987169","can_delete":false,"product_type":"c1","uid":1180853,"ip_address":"","ucode":"4B2955A044805D","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/b5/8bc4790b.jpg","comment_is_top":false,"comment_ctime":1539834520,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5834801816","product_id":100010301,"comment_content":"重复获取同一把锁，锁记录清零是什么意思？如果将锁记录理解为栈结构，那么如果一个线程重复获取同一把锁这个此时锁记录有几条，是什么结构呢？","like_count":1},{"had_liked":false,"id":21151,"user_name":"Scott","can_delete":false,"product_type":"c1","uid":1014800,"ip_address":"","ucode":"7E57FDCB5E5D49","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7c/10/165cb374.jpg","comment_is_top":false,"comment_ctime":1534940941,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5829908237","product_id":100010301,"comment_content":"请教一下，不是很明白epoch的作用，偏向锁默认被撤销20次使偏向锁失效才更新这个字段，没有想明白epoch的必要性","like_count":1,"discussions":[{"author":{"id":1785016,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/3c/b8/9489387c.jpg","nickname":"鱼丸粗面","note":"","ucode":"B2F3F75B0D1422","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284743,"discussion_content":"epoch是用来标记这个锁对象的类是否还适合偏向锁用的，epoch的值存在class里，而锁对象里的epoch只是一份拷贝\n每次更新class里的epoch时，还会检查持有该类自旋锁的线程的栈，并且更新锁对象的epoch值，也就是说会保证锁对象里的epoch时最新的，如果不是最新的那么可以被下一个来加锁的线程重偏向；\n如果epoch值过大说明这个类的对象都不适合偏向锁了，会直接上轻量级锁","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1592623922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1261360,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3f/30/23f6b413.jpg","nickname":"五十九秒","note":"","ucode":"1F34F62193CFF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1785016,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/3c/b8/9489387c.jpg","nickname":"鱼丸粗面","note":"","ucode":"B2F3F75B0D1422","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320686,"discussion_content":"关于epoch值我还是有些不太明白，如果每次更新class里的epoch时，都会更新栈中锁对象的epoch，这么操作是JVM做的，是不是可以认为肯定是不会失败的，不然这就是JVM的一个bug了，如果只是为了记录撤销次数，直接在class理记录次数就可以了，再引入epoch的意义，确实没有想明白。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604452550,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":284743,"ip_address":""},"score":320686,"extra":""}]},{"author":{"id":1785016,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/3c/b8/9489387c.jpg","nickname":"鱼丸粗面","note":"","ucode":"B2F3F75B0D1422","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284746,"discussion_content":"说错了不是epoch值过大，而是撤销次数过多时表示这个类的对象都不适合偏向锁了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592624087,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21123,"user_name":"(^o^)","can_delete":false,"product_type":"c1","uid":1142842,"ip_address":"","ucode":"AAD9EC32A590E2","user_header":"https://static001.geekbang.org/account/avatar/00/11/70/3a/6b82e940.jpg","comment_is_top":false,"comment_ctime":1534929245,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5829896541","product_id":100010301,"comment_content":"“否则，Java 虚拟机会尝试用 CAS 操作，比较锁对象的标记字段的值是否为当前锁记录的地址。如果是，则替换为锁记录中的值，也就是锁对象原本的标记字段。此时，该线程已经成功释放这把锁。<br><br>如果不是，则意味着这把锁已经被膨胀为重量级锁。”升级为重量级锁的过程，会改变锁对象的什么信息呢？","like_count":1},{"had_liked":false,"id":350992,"user_name":"小鳄鱼","can_delete":false,"product_type":"c1","uid":1178888,"ip_address":"","ucode":"9C30CAFB41A263","user_header":"https://static001.geekbang.org/account/avatar/00/11/fd/08/c039f840.jpg","comment_is_top":false,"comment_ctime":1657441722,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657441722","product_id":100010301,"comment_content":"CAS失败，意味着原来的值发生改变了。例如，预期是01，CAS失败了，则表示该值被修改了，不为01了","like_count":0},{"had_liked":false,"id":350986,"user_name":"小鳄鱼","can_delete":false,"product_type":"c1","uid":1178888,"ip_address":"","ucode":"9C30CAFB41A263","user_header":"https://static001.geekbang.org/account/avatar/00/11/fd/08/c039f840.jpg","comment_is_top":false,"comment_ctime":1657439394,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657439394","product_id":100010301,"comment_content":"个人觉得有一点：强行翻译最为致命。一个“标记字段”硬生生阻碍我对文章的理解。看了N遍，参考了其他博客，翻找了《深入理解Java虚拟机》，才知道原来就是MarkWord。。。内容总体的编排，看起来跟书里差别不大。但是在每个小的知识点上感觉相对混乱。且对于没有一些概念性的术语对于没有相关知识的同学容易造成理解困难","like_count":0},{"had_liked":false,"id":348000,"user_name":"懵逼猴","can_delete":false,"product_type":"c1","uid":1204947,"ip_address":"","ucode":"BDC748A96AC316","user_header":"https://static001.geekbang.org/account/avatar/00/12/62/d3/663de972.jpg","comment_is_top":false,"comment_ctime":1654657505,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654657505","product_id":100010301,"comment_content":"引用的文章失效了。。","like_count":0},{"had_liked":false,"id":347457,"user_name":"大排泡饭","can_delete":false,"product_type":"c1","uid":3013303,"ip_address":"","ucode":"30B882AAB67CC5","user_header":"https://static001.geekbang.org/account/avatar/00/2d/fa/b7/0342db08.jpg","comment_is_top":false,"comment_ctime":1654053868,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1654053868","product_id":100010301,"comment_content":"比JCIP难懂，看到大家都不太看得懂，我就不焦虑了哈哈。<br>要是和ReentrantLock 对比起来讲就好了，JCIP里做了对比和预测，但是没有讲实现。","like_count":0},{"had_liked":false,"id":346377,"user_name":"程浩乾","can_delete":false,"product_type":"c1","uid":2996782,"ip_address":"","ucode":"A41850498D5828","user_header":"https://static001.geekbang.org/account/avatar/00/2d/ba/2e/08585f22.jpg","comment_is_top":false,"comment_ctime":1653067491,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653067491","product_id":100010301,"comment_content":"我的理解：Synchronized锁优化时有三种状态：<br>1.偏向锁(无锁，乐观地认为只有一个线程)，具体实现：<br>（1）每个类的标记头中都有个epoch值(代表第几代偏向锁)，初次加锁时将锁对象类中的epoch值复制到创建的锁对象中，并将本线程地址写入锁对象标记字段，且设置标记字段最后三位为101(偏向锁)。<br>（2）当新线程加锁时，若锁对象标记字段的线程地址非本线程，且epoch值相等，会导致偏向锁撤销，便升级该锁对象为轻量级锁。若epoch值不等，可直接使锁对象偏向自己(写入本线程地址)。<br>（3）若该类锁对象的总撤销次数超过20次(JVM参数-XX:BiasedLockingBulkRebiasThreshold)，就会使偏向锁失效，会将锁对象类的epoch值加1，并在安全点时赋值到其下所有的锁对象中。<br>（4）若该类锁对象的总撤销次数超过40次(JVM参数-XX:BiasedLockingBulkRevokeThreshold)，就会认为该类锁对象已经不再适合偏向锁，会撤销掉该类实例的偏向锁，并在下次加锁时直接使用轻量级锁。<br><br>2.轻量级锁(乐观地认为多个线程不会同时执行)，具体实现：<br>（1）加锁时，在当前线程的当前栈帧中划出一块空间作为线程锁记录，将锁对象的标记字段(01结尾的偏向锁)复制到线程锁记录中，并把线程锁记录地址通过CAS操作赋值到锁对象的标记字段内，由于内存对齐的缘故，锁对象的标记字段将会以00(轻量级锁)标记来结尾。<br>（2）当新线程加锁时，若锁对象标记字段内的线程地址是指向自己，便会将当前栈帧的锁记录清零，以代表该锁被重复获取；若不是指向自己，便直接会膨胀为重量级锁。<br>（3）解锁时，若当前栈帧的锁记录为0(代表重复获取锁)，就会直接返回；若不是0，便会将当前栈帧的锁记录(01结尾的偏向锁状态)通过CAS操作赋值到锁对象中。(一个线程的所有锁记录是栈结构，加锁时压入一条锁记录，解锁时弹出一条锁记录)<br><br>3.重量级锁(多个线程会同时执行)，具体实现：<br>（1）依靠操作系统来对Java线程进行阻塞和唤醒，涉及系统调用，需从用户态切换到内核态，开销非常大。<br>（2）为避免昂贵的阻塞和唤醒，在阻塞前会进入短暂的自适应自旋来避免非常短的加锁代码块(在处理器上空跑并且轮询锁是否被释放)，自适应自旋会根据以往的自旋时能否获得锁，来动态调整自旋的时间(数目)。(自适应自旋是不公平的锁竞争，不利于已阻塞的线程获得锁)","like_count":0},{"had_liked":false,"id":320834,"user_name":"Eric","can_delete":false,"product_type":"c1","uid":1575571,"ip_address":"","ucode":"7EB511C384BD7B","user_header":"https://static001.geekbang.org/account/avatar/00/18/0a/93/a189ec16.jpg","comment_is_top":false,"comment_ctime":1636526541,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636526541","product_id":100010301,"comment_content":"https:&#47;&#47;tech.meituan.com&#47;2018&#47;11&#47;15&#47;java-lock.html","like_count":1},{"had_liked":false,"id":316040,"user_name":"漂泊者及其影子","can_delete":false,"product_type":"c1","uid":1119979,"ip_address":"","ucode":"13FE760FE8B111","user_header":"https://static001.geekbang.org/account/avatar/00/11/16/eb/30864e40.jpg","comment_is_top":false,"comment_ctime":1634114444,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634114444","product_id":100010301,"comment_content":"问个问题：所以轻量级锁的对象头信息存储的是持有锁的线程创建的锁记录(Lock Record)的指针吗？然后JVM是通过锁记录指针来判断持有轻量级锁的线程的，这样理解多吗？","like_count":0},{"had_liked":false,"id":308749,"user_name":"ppyh","can_delete":false,"product_type":"c1","uid":1351148,"ip_address":"","ucode":"14022ADEC9B53F","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/ec/235b74c0.jpg","comment_is_top":false,"comment_ctime":1629781275,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629781275","product_id":100010301,"comment_content":"我认为epoch值的意义在于当获取偏向锁的线程发现epoch的值不相等时，可以直接重新偏向到自己，不需要再撤销偏向，不需要撤销偏向的过程走以下逻辑：<br>      使之前持有锁的线程到达安全点，再去判断是否退出同步块，这样开销比较大。<br>因为老师没有讲判断是否已经退出同步块的逻辑，可能大家比较懵。https:&#47;&#47;www.zhihu.com&#47;question&#47;57774162看一下这张图就知道了","like_count":0},{"had_liked":false,"id":308745,"user_name":"ppyh","can_delete":false,"product_type":"c1","uid":1351148,"ip_address":"","ucode":"14022ADEC9B53F","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/ec/235b74c0.jpg","comment_is_top":false,"comment_ctime":1629780281,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629780281","product_id":100010301,"comment_content":"老师 有个疑问，我们先从偏向锁的撤销讲起。当请求加锁的线程和锁对象标记字段保持的线程地址不匹配时（而且 epoch 值相等，如若不等，那么当前线程可以将该锁重偏向至自己），Java 虚拟机需要撤销该偏向锁。这个撤销过程非常麻烦，它要求持有偏向锁的线程到达安全点，再将偏向锁替换成轻量级锁。<br><br><br>这句话替换成轻量级锁的意思应该是请求加锁的线程已轻量级锁的方式去获取锁吧，对于原来持有偏向锁的线程不止需要等待到安全点，而且还需要走出了释放锁的代码块。","like_count":0},{"had_liked":false,"id":305151,"user_name":"zhmacn","can_delete":false,"product_type":"c1","uid":2561868,"ip_address":"","ucode":"91FA8535808CA0","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqJrZ9ic5vHOVfzqcA3Y454gicI2z7L1Ujp5hzFr9CbfTu6goHE7fUlbl3QjpEvXJj5qlvRAVcGRomw/132","comment_is_top":false,"comment_ctime":1627863691,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627863691","product_id":100010301,"comment_content":"就我们的例子来说，如果之前不熄火等到了绿灯，那么这次不熄火的时间就长一点；如果之前不熄火没等到绿灯，那么这次不熄火的时间就短一点。<br><br>老师，这个自旋等待时长自适应调整的逻辑也会被在JIT编译在机器码中吗","like_count":0},{"had_liked":false,"id":302342,"user_name":"凯文小猪","can_delete":false,"product_type":"c1","uid":1980201,"ip_address":"","ucode":"36D8AD0229547F","user_header":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","comment_is_top":false,"comment_ctime":1626171093,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626171093","product_id":100010301,"comment_content":"8的版本是不会自旋的，轻量锁就是轻量锁当标志位从偏向取消或者说摘除 那么就要将其膨胀为轻量级锁。<br>而轻量级锁实际上是cas竞争 做个标记位而已，如果此时还有竞争那么就会膨胀。再膨胀后做用户态自旋。代码：ObjectMonitor::TrySpin_VaryDuration (Thread * Self)<br>另外一说的是JDK11做了重写 JDK18做了偏向锁摘除","like_count":0},{"had_liked":false,"id":287448,"user_name":"下个目标45k","can_delete":false,"product_type":"c1","uid":1066508,"ip_address":"","ucode":"193BA8C3AA9A61","user_header":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","comment_is_top":false,"comment_ctime":1617955123,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617955123","product_id":100010301,"comment_content":"举个例子<br>1. 只有一个线程时，只是设置一下标志位（cas设置），告诉别人我已经在里面了<br>2.两个线程时，那就开始通过cas抢<br>3.三个以上线程时，那就开始真正上把锁，大家都排队吧","like_count":0},{"had_liked":false,"id":286286,"user_name":"xzy","can_delete":false,"product_type":"c1","uid":1002095,"ip_address":"","ucode":"1A44368083A19E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/6f/e36b3908.jpg","comment_is_top":false,"comment_ctime":1617240146,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617240146","product_id":100010301,"comment_content":"当一个对象已经计算过identity hash code，它就无法进入偏向锁状态","like_count":0},{"had_liked":false,"id":285277,"user_name":"Codesman","can_delete":false,"product_type":"c1","uid":1172087,"ip_address":"","ucode":"6B058C26D303F0","user_header":"https://static001.geekbang.org/account/avatar/00/11/e2/77/6ff9d70c.jpg","comment_is_top":false,"comment_ctime":1616721509,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1616721509","product_id":100010301,"comment_content":"锁升级的过程是逐步升级的，为什么要倒过来讲？<br>","like_count":0},{"had_liked":false,"id":280877,"user_name":"寒三石","can_delete":false,"product_type":"c1","uid":1376404,"ip_address":"","ucode":"A25BD34DE8610B","user_header":"https://static001.geekbang.org/account/avatar/00/15/00/94/91bd7001.jpg","comment_is_top":false,"comment_ctime":1614434140,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614434140","product_id":100010301,"comment_content":"竞争偏向锁失败的线程会被阻塞还是自旋还是其他","like_count":0},{"had_liked":false,"id":251018,"user_name":"易水寒","can_delete":false,"product_type":"c1","uid":1238961,"ip_address":"","ucode":"F5D8127ED4754E","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/b1/5c63be67.jpg","comment_is_top":false,"comment_ctime":1601308673,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601308673","product_id":100010301,"comment_content":"jdk8测试结果为，锁对象未重写hashCode方法，调用的话，偏向锁不生效，重写的话，偏向锁不受影响。调用System. identityCode方法，偏向锁失效","like_count":0},{"had_liked":false,"id":243700,"user_name":"longslee","can_delete":false,"product_type":"c1","uid":1465986,"ip_address":"","ucode":"C24E32E5B1B6F5","user_header":"https://static001.geekbang.org/account/avatar/00/16/5e/82/438c8534.jpg","comment_is_top":false,"comment_ctime":1598252574,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598252574","product_id":100010301,"comment_content":"感谢在老师这儿终于看懂了3种锁的场景，以前在各个系统性书上看到的都是具体的算法多，不怎么明白应用场景。","like_count":0},{"had_liked":false,"id":234621,"user_name":"西门吹牛","can_delete":false,"product_type":"c1","uid":1508990,"ip_address":"","ucode":"E5D3624DDE1E83","user_header":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","comment_is_top":false,"comment_ctime":1594736192,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1594736192","product_id":100010301,"comment_content":"对epoch的理解：epoch用来表明偏向锁的合法性<br>因为偏向锁的撤销开销很大，偏向几次需要撤销几次，当一个锁对象被撤销数超过一定的阈值，那么就认为该偏向锁撤销失败，其实就是把撤销的过程直接以失败强制结束来代替偏向锁的撤销，因为完全撤销确实开销很大。这个时候虽然撤销失败，但是锁对象头中的标记字段还包含指向该线程的引用，也就是说对象头中的偏向锁状态失效了，这个时候用另一种方式来判断偏向锁是否有效。<br>那就是通过比较epoch值来判断偏向锁是否失效，因为偏向锁撤销失败时，所有类中的epoch值加1，这时候和锁对象头中的epoch值就不一样，就认为对象头中的偏向锁标记是失效的，如果此时，别的线程来获取偏向锁，判断锁对象头中虽然不包含指向自己线程的引用，但是因为epoch值不同，那就认为此时的锁对象中的偏向锁是失效的，可以重新获取偏向锁，这时候只需要将锁对象头中的记录地址指向该线程，并将类中的epoch也复制到对象头中。这时候新的偏向锁就生效了。<br>所以，每次偏向锁失效，jvm 都需要遍历所有线程的 Java 栈，找出该类已加锁的实例，并且将它们标记字段中的 epoch 值加 1。该操作需要所有线程处于安全点状态。偏向锁升级轻量级锁的条件，必须是偏向锁撤销失败的总次数超过设置的某个阀值，才会升级为轻量级锁。<br>这种设计思想真的很巧妙，用epoch就把偏向锁的撤销带来的开销给节省了，偏向锁的出现是为了节约线程切换带来的开销，但是偏向锁的撤销，又带来新的开销，这时候，epoch的出现又竟可能避免了偏向锁撤销带来的开销，用空间换时间。","like_count":0,"discussions":[{"author":{"id":1238961,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e7/b1/5c63be67.jpg","nickname":"易水寒","note":"","ucode":"F5D8127ED4754E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309508,"discussion_content":"实际测试后发现，你的说法有点问题。在未达到偏向锁撤销次数的阀值时，未持有偏向锁的线程来获取偏向锁，必然失败，就会发生锁升级，变为轻量级锁，且此后都会是从轻量级开始（针对的是该类型的同一个锁对象），直到该类型的锁撤销次数达到阀值（涉及多个锁对象），偏向锁会失效，此时才会去更新epoch，过程如你所说。偏向锁针对的场景就是只有一个线程会获取锁，一旦出现竞争就不再使用偏向锁，因为撤销偏向锁是需要等待持有偏向锁的线程到达安全点，这个开销还是有的。在未更新epoch前，不会出现偏向锁的重偏向。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601308503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2012721,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/b6/31/c801c289.jpg","nickname":"清蒸结尾鱼","note":"","ucode":"371AA2E17DB89C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304797,"discussion_content":"你好，我对偏向锁还有有点疑惑。你说的偏几次撤销几次，我的疑问是什么情况下会偏几次呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599664139,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1508990,"avatar":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","nickname":"西门吹牛","note":"","ucode":"E5D3624DDE1E83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2012721,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/b6/31/c801c289.jpg","nickname":"清蒸结尾鱼","note":"","ucode":"371AA2E17DB89C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304892,"discussion_content":"类似重入锁，重入次数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599707270,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":304797,"ip_address":""},"score":304892,"extra":""}]}]},{"had_liked":false,"id":234568,"user_name":"西门吹牛","can_delete":false,"product_type":"c1","uid":1508990,"ip_address":"","ucode":"E5D3624DDE1E83","user_header":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","comment_is_top":false,"comment_ctime":1594721736,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594721736","product_id":100010301,"comment_content":"这篇文章，虽然不好理解，但是讲的很细，所有的点都涉及了，如果对java的锁，没有一定的基础；了解，很难读懂，必须细扣老师的每一句话，说没图的，自己可以去网上找图，java并发编程的艺术，这本书对偏向，轻量，重量锁的介绍，虽然有图，但是感觉没有老师这篇文章介绍的好，一定要多读，多想，没图可以根据老师的思路画图，收货满满啊","like_count":0},{"had_liked":false,"id":229973,"user_name":"西门吹牛","can_delete":false,"product_type":"c1","uid":1508990,"ip_address":"","ucode":"E5D3624DDE1E83","user_header":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","comment_is_top":false,"comment_ctime":1593229330,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593229330","product_id":100010301,"comment_content":"一直不明白一个问题，大多数情况下，锁不仅不存在竞争，而且总是由同一线程多次获得，所以在1.6为了让线程获取锁的代价更低引入偏向锁；但是，在没有偏向锁之前，为什么大多数情况下，锁不仅不存在竞争，而且总是由同一线程多次获得？求老师解答","like_count":0},{"had_liked":false,"id":226397,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1592062514,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1592062514","product_id":100010301,"comment_content":"synchronized锁<br>目的：保证可见性，原子性，有序性<br>锁分类：<br>无锁，偏向锁，轻量级锁，重量级锁<br>java对象头有个标记标记是偏向锁，轻量级锁等状态<br>当有线程进入syncronized区块时，这时如果当前无锁且偏向锁开关是开的则进入到偏向锁，会将对象头的锁标记为偏向锁及对应的锁引用为当前线程id。","like_count":0},{"had_liked":false,"id":226082,"user_name":"YU","can_delete":false,"product_type":"c1","uid":1274464,"ip_address":"","ucode":"4EE45D6FC2862F","user_header":"https://static001.geekbang.org/account/avatar/00/13/72/60/288023be.jpg","comment_is_top":false,"comment_ctime":1591948406,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591948406","product_id":100010301,"comment_content":"调用hashcode应该不是关闭偏向锁，应该是有可能导致锁升级，因为无锁情况下mark word中的hashcode就是对象调用hashcode方法才会生成设置进去。因此如果当前对象是偏向锁情况下，偏向锁没有位置存储hashcode，因此需要升级或者无偏向。不知道描述的对不对，还请老师指教","like_count":0},{"had_liked":false,"id":223387,"user_name":"肖某某","can_delete":false,"product_type":"c1","uid":1136927,"ip_address":"","ucode":"A1D06FAD40FB33","user_header":"https://static001.geekbang.org/account/avatar/00/11/59/1f/a3679b09.jpg","comment_is_top":false,"comment_ctime":1591079429,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591079429","product_id":100010301,"comment_content":"&quot;具体的做法便是在每个类中维护一个 epoch 值，你可以理解为第几代偏向锁。当设置偏向锁时，Java 虚拟机需要将该 epoch 值复制到锁对象的标记字段中。&quot;<br>每个类是什么概念？所有的类？Synchronization可以加在方法上，也可以加在代码块，还可以加在类上，只class上维护这个epoc值，是怎么维护的呢？<br><br><br>&quot;新设置的偏向锁则需要复制新的 epoch 值。为了保证当前持有偏向锁并且已加锁的线程不至于因此丢锁，Java 虚拟机需要遍历所有线程的 Java 栈，找出该类已加锁的实例，并且将它们标记字段中的 epoch 值加 1&quot;<br>A线程新设置偏向锁复制到epoch值到对象，这个锁不就是A线程独有了吗，为什么java虚拟机还有遍历其他所有的线程栈，保证该类已加锁的实例的锁继续有效？","like_count":0},{"had_liked":false,"id":203871,"user_name":"有米","can_delete":false,"product_type":"c1","uid":1005042,"ip_address":"","ucode":"C9A10B7A67BC12","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/f2/ba68d931.jpg","comment_is_top":false,"comment_ctime":1586278468,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586278468","product_id":100010301,"comment_content":"嗯记一下相关知识点：可重入锁、公平锁、自旋锁、乐观锁、偏向锁。<br>CAS是实现乐观锁的一种方式，平时开发处理高并发的场景，也会使用CAS。具体说就是update table set status=1 where id=1 and status=0;返回1就是拿到锁啦~~~","like_count":0},{"had_liked":false,"id":200194,"user_name":"Sundnd","can_delete":false,"product_type":"c1","uid":1131316,"ip_address":"","ucode":"BA60F74AD42F9A","user_header":"https://static001.geekbang.org/account/avatar/00/11/43/34/5684e180.jpg","comment_is_top":false,"comment_ctime":1585555712,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1585555712","product_id":100010301,"comment_content":"&gt;Java 线程的阻塞以及唤醒，都是依靠操作系统来完成的。举例来说，对于符合 posix 接口的操作系统（如 macOS 和绝大部分的 Linux），上述操作是通过 pthread 的互斥锁（mutex）来实现的。此外，这些操作将涉及系统调用，需要从操作系统的用户态切换至内核态，其开销非常之大。<br><br>真的是使用内核提供的互斥锁吗？ 内置锁和reentranglock都是直接使用硬件指令比较交互和自己构建同步队列实现的吧?  <br><br>另外就是调用内核可能特权级切换附带的操作，开销之大无法理解。<br><br>最后就是重量级这个词，这个只是和自己的偏向和轻量比吧?  排它锁的实现我理解都一个套路，至少和reentranglock不会有什么差异。<br><br>以上，雨迪同学看到帮忙解答下。这是我最近的理解，不对还请帮忙纠正，谢谢。<br><br>","like_count":0,"discussions":[{"author":{"id":1131316,"avatar":"https://static001.geekbang.org/account/avatar/00/11/43/34/5684e180.jpg","nickname":"Sundnd","note":"","ucode":"BA60F74AD42F9A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217417,"discussion_content":"手机码字，单词打错，ReentrantLock ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585556476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188903,"user_name":"静心","can_delete":false,"product_type":"c1","uid":1335457,"ip_address":"","ucode":"EB264FA6519FDA","user_header":"https://static001.geekbang.org/account/avatar/00/14/60/a1/8f003697.jpg","comment_is_top":false,"comment_ctime":1584432469,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1584432469","product_id":100010301,"comment_content":"请问老师：<br>1、第一个线程刚启动时，拿到的锁是哪种锁？偏向锁，轻量级锁，还是重量级锁？<br>2、偏向锁和无锁是同一个概念吗？","like_count":0},{"had_liked":false,"id":184056,"user_name":"家庆","can_delete":false,"product_type":"c1","uid":1184982,"ip_address":"","ucode":"D77A489C78EF0D","user_header":"https://static001.geekbang.org/account/avatar/00/12/14/d6/e79204be.jpg","comment_is_top":false,"comment_ctime":1583213813,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583213813","product_id":100010301,"comment_content":"老师好，我这边有两个问题。1、设置偏向锁后，hashCode存放在那里。2、重量级锁释放后是直接变成无锁状态吗？还是该锁就一直是重量级锁。","like_count":0},{"had_liked":false,"id":178364,"user_name":"大俊stan","can_delete":false,"product_type":"c1","uid":1125370,"ip_address":"","ucode":"BD0CB5FC790DDB","user_header":"https://static001.geekbang.org/account/avatar/00/11/2b/fa/1cde88d4.jpg","comment_is_top":false,"comment_ctime":1581669770,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581669770","product_id":100010301,"comment_content":"这篇文章不懂得可以看看java性能调优实战的第12章节讲的清楚一些。","like_count":0},{"had_liked":false,"id":165253,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1577189197,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577189197","product_id":100010301,"comment_content":"如果不是 X…X01，那么有两种可能。第一，该线程重复获取同一把锁。此时，Java 虚拟机会将锁记录清零，以代表该锁被重复获取。第二，其他线程持有该锁。此时，Java 虚拟机会将这把锁膨胀为重量级锁，并且阻塞当前线程。<br><br><br>这个为啥阻塞当前线程呢？不应该是其他线程吗？","like_count":0},{"had_liked":false,"id":165182,"user_name":"猫的脚步声","can_delete":false,"product_type":"c1","uid":1103789,"ip_address":"","ucode":"D708841347B9DB","user_header":"https://static001.geekbang.org/account/avatar/00/10/d7/ad/434d320e.jpg","comment_is_top":false,"comment_ctime":1577176653,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1577176653","product_id":100010301,"comment_content":"不知道老师还看不看啊？我有个问题，在偏向锁撤销的过程中“epoch ”字段我从网上找的Mack Word结构图来看，它只有2个bit，但根据您的文章类中的“epoch ”有可能达到20和40，请问是怎么判断他们是否相等的呢？原文“最后三位是否为 101，是否包含当前线程的地址，以及 epoch 值是否和锁对象的类的 epoch 值相同”","like_count":0,"discussions":[{"author":{"id":1338767,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6d/8f/ce03dd1a.jpg","nickname":"seng man","note":"","ucode":"72E536B99DEF03","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366437,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618061821,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162609,"user_name":"砖瓦工","can_delete":false,"product_type":"c1","uid":1021194,"ip_address":"","ucode":"A0AAF93973D6A8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/95/0a/817c4356.jpg","comment_is_top":false,"comment_ctime":1576564740,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576564740","product_id":100010301,"comment_content":"隐式约束，这是值得什么情况，能大概说明一下吗？ 十分感谢！！","like_count":0},{"had_liked":false,"id":151307,"user_name":"长脖子树","can_delete":false,"product_type":"c1","uid":1182802,"ip_address":"","ucode":"D9090EF67EEB1B","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/52/f25c3636.jpg","comment_is_top":false,"comment_ctime":1573698011,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1573698011","product_id":100010301,"comment_content":"关于 monitorenter &#47; monitorexit 两种指令均会消耗操作数栈上的一个引用类型的元素  我解释下<br>这两个指令在执行前均需要将锁的对象引用推至栈顶<br>顺便分享下本节的思维导图哈哈<br>https:&#47;&#47;www.processon.com&#47;view&#47;link&#47;5dccb8a1e4b071befcc7edb7","like_count":0},{"had_liked":false,"id":138628,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1570376947,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570376947","product_id":100010301,"comment_content":"老师好有个问题。调用notify all时。锁还是被调用线程持有着的，只有出了临界区才会释放锁。被唤醒的那些线程会从等待队列进入锁池队列。在notify all 和出临界区这段时间内，被唤醒的线程，会去竞争锁么?还是只有除了临界区释放锁后才会触发锁竞争。我看有本书上说notify all写在临界区末尾，可减少锁竞争。","like_count":0},{"had_liked":false,"id":134835,"user_name":"码农Kevin亮","can_delete":false,"product_type":"c1","uid":1116630,"ip_address":"","ucode":"D34562461CA0A1","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/d6/5f366427.jpg","comment_is_top":false,"comment_ctime":1568941144,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568941144","product_id":100010301,"comment_content":"请问老师，如何分析什么情况下是哪种锁？以及如何验证分析结论呢","like_count":0},{"had_liked":false,"id":131037,"user_name":"rong","can_delete":false,"product_type":"c1","uid":1128740,"ip_address":"","ucode":"637A27C532D817","user_header":"https://static001.geekbang.org/account/avatar/00/11/39/24/ab14f6cf.jpg","comment_is_top":false,"comment_ctime":1567606346,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567606346","product_id":100010301,"comment_content":"老师，有个问题不明白，就是锁代码块的时候，只有一个monitorenter指令，那怎么知道这个锁绑定的是哪个对象呢？比如我自定义了Person类，他的实例person，@synchronized（person），我看到字节码中只有monitorenter，没看到他和person对象的绑定关系啊？","like_count":0},{"had_liked":false,"id":128048,"user_name":"neohope","can_delete":false,"product_type":"c1","uid":1043475,"ip_address":"","ucode":"C0268F6E7E2B6E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","comment_is_top":false,"comment_ctime":1566824676,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566824676","product_id":100010301,"comment_content":"建议先讲解一下mark word的结构，然后很多问题就清晰了。","like_count":0},{"had_liked":false,"id":97727,"user_name":"马上到","can_delete":false,"product_type":"c1","uid":1147414,"ip_address":"","ucode":"9FAA3E39B653BE","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/16/937c6906.jpg","comment_is_top":false,"comment_ctime":1558756717,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558756717","product_id":100010301,"comment_content":"迪迪老师真棒","like_count":0},{"had_liked":false,"id":84608,"user_name":"李亮亮","can_delete":false,"product_type":"c1","uid":1116508,"ip_address":"","ucode":"290907F930B261","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/5c/b5d79d20.jpg","comment_is_top":false,"comment_ctime":1554884815,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554884815","product_id":100010301,"comment_content":"一个撤销阀值为40，一个撤销阀值为20 ，20这个表示超过这个次数那个这个偏向锁就换代了。epoch的值加1，如果撤销次数超过40就证明这个类不适合使用偏向锁。照这个数据来讲是不是意味着差不多换2代就表示该类不适合偏向锁了，不知道我理解的对不？","like_count":0},{"had_liked":false,"id":73521,"user_name":"王肖武","can_delete":false,"product_type":"c1","uid":1282385,"ip_address":"","ucode":"561AF05284EBE2","user_header":"https://static001.geekbang.org/account/avatar/00/13/91/51/234f9a73.jpg","comment_is_top":false,"comment_ctime":1551919719,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551919719","product_id":100010301,"comment_content":"“当进行加锁操作时，Java 虚拟机会判断是否已经是重量级锁。如果不是，它会在当前线程的当前栈桢中划出一块空间，作为该锁的锁记录，并且将锁对象的标记字段复制到该锁记录中。”<br>有个疑问麻烦老师帮解答一下：栈帧不是一遍连续的空间吗？大小不是固定的吗？划出的空间是从哪里分配出来的呢？","like_count":0},{"had_liked":false,"id":67672,"user_name":"LINEZH","can_delete":false,"product_type":"c1","uid":1182000,"ip_address":"","ucode":"094B2E673AC570","user_header":"https://static001.geekbang.org/account/avatar/00/12/09/30/ff83622b.jpg","comment_is_top":false,"comment_ctime":1550220897,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550220897","product_id":100010301,"comment_content":"有一个疑问, JVM是如何选择使用重量锁&#47;轻量锁&#47;自旋锁呢? 是在执行的时候根据锁和线程的情况决定吗, 能不能说的具体一点?","like_count":0},{"had_liked":false,"id":57248,"user_name":"fangxuan","can_delete":false,"product_type":"c1","uid":1073369,"ip_address":"","ucode":"3870F2BF5679A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/60/d9/829ac53b.jpg","comment_is_top":false,"comment_ctime":1546698039,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1546698039","product_id":100010301,"comment_content":"单线程情况下，开启偏向锁和不开启偏向锁，性能上有什么差别吗？差别在哪儿？","like_count":0},{"had_liked":false,"id":54594,"user_name":"yihang","can_delete":false,"product_type":"c1","uid":1012361,"ip_address":"","ucode":"A5506F085D1793","user_header":"https://static001.geekbang.org/account/avatar/00/0f/72/89/1a83120a.jpg","comment_is_top":false,"comment_ctime":1545908933,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545908933","product_id":100010301,"comment_content":"老师您好，我是这几天才开始学习这个专栏。有这么几个问题，觉得读完文章也未能找到答案，请老师解答：<br>1） 如果轻量级锁已经发现有竞争，膨胀为重量级锁，那么之前拥有锁的线程，解锁时会唤醒该对象上的阻塞线程。这句话我理解了，但这时对象上的Mark Word 还是重量级锁的指针（状态10）吗？直到最后一个线程释放了锁，对象上的Mark Word 仍然保持状态 10 还是会恢复到无锁的状态（01）？还是从这往后就始终保持重量级锁的状态了？<br><br>2）偏向锁中的 Rebias 和 revoke bias 应该是不同的概念吧，字面意思，后者应该是撤销偏向，而前者似乎是重用偏向。【如果某一类锁对象的总撤销数超过了一个阈值（对应 Java 虚拟机参数 -XX:BiasedLockingBulkRebiasThreshold，默认为 20），那么 Java 虚拟机会宣布这个类的偏向锁失效。】说实话这句话真没看懂，什么叫【这个类的偏向锁失效】，感觉这个参数是为了优化偏向锁，能够让偏向锁得以重用<br>我在 stackoverflow上找了一篇解释：<br>subsequent bulk rebias is possible if and only if number of revokes more than BiasedLockingBulkRebiasThreshold and less than BiasedLockingBulkRevokeThreshold and the latest revoke was not later than BiasedLockingDecayTime, where all escaped variables are JVM properties.<br>不知道他说的是否在理？请指教，地址：https:&#47;&#47;stackoverflow.com&#47;questions&#47;46312817&#47;does-java-ever-rebias-an-individual-lock<br>","like_count":0},{"had_liked":false,"id":54365,"user_name":"shawn","can_delete":false,"product_type":"c1","uid":1010221,"ip_address":"","ucode":"8F6A8C7920996E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6a/2d/ec4ed8ce.jpg","comment_is_top":false,"comment_ctime":1545835491,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545835491","product_id":100010301,"comment_content":"老师对于轻量级锁可以这样理解么？如下： “轻量级锁，b线程在锁竞争时，发现锁已经被a线程占用，则b线程不进入内核态，让b线程自旋，执行空循环，等待a线程释放锁。如果，完成自旋策略还是发现a线程没有释放锁，或者让c线程占用了。则b线程试图将轻量级锁升级为重量级锁。”","like_count":0},{"had_liked":false,"id":26167,"user_name":"更远的以后","can_delete":false,"product_type":"c1","uid":1059973,"ip_address":"","ucode":"213F4A12AEE895","user_header":"https://static001.geekbang.org/account/avatar/00/10/2c/85/fc2a568b.jpg","comment_is_top":false,"comment_ctime":1537509602,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1537509602","product_id":100010301,"comment_content":"这篇文章的比喻举得很棒。帮助理解。","like_count":0},{"had_liked":false,"id":23406,"user_name":"志远","can_delete":false,"product_type":"c1","uid":1108762,"ip_address":"","ucode":"11015D14034130","user_header":"https://static001.geekbang.org/account/avatar/00/10/eb/1a/579c941e.jpg","comment_is_top":false,"comment_ctime":1536331478,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1536331478","product_id":100010301,"comment_content":"如果不是，它会在当前线程的当前栈桢中划出一块空间，作为该锁的锁记录，并且将锁对象的标记字段复制到该锁记录中。请问锁记录是一块栈空间吗？锁记录到底是个什么东西？标记字段复制到空间中吗？老师，提个建议，感觉还有文章很多的代词，状语之类，缺否足够的定语来丰富描述。","like_count":0},{"had_liked":false,"id":22081,"user_name":"licht","can_delete":false,"product_type":"c1","uid":1064030,"ip_address":"","ucode":"467270E57A7BF8","user_header":"https://static001.geekbang.org/account/avatar/00/10/3c/5e/6a26a8c4.jpg","comment_is_top":false,"comment_ctime":1535472862,"is_pvip":false,"replies":[{"id":"8013","content":"内存屏障相当于定义了一个禁止重排序的规则，然后即时编译器和CPU需要遵守这个规则。","user_name":"作者回复","comment_id":22081,"uid":"1176688","ip_address":"","utype":1,"ctime":1535620751,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"1535472862","product_id":100010301,"comment_content":"2-2:内存屏障，这是什么意思？它怎么就能禁止重排序啦？还有有其引申出的各种屏蔽是怎么回事呢？也没完全明白。  因为不明白内存屏障，对于空指令的内存屏障很迷惑？希望老师帮忙解答一下，谢谢了。","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422992,"discussion_content":"内存屏障相当于定义了一个禁止重排序的规则，然后即时编译器和CPU需要遵守这个规则。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535620751,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21614,"user_name":"永烁星光","can_delete":false,"product_type":"c1","uid":1119617,"ip_address":"","ucode":"D26A9097F9D24C","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/81/2c31cf79.jpg","comment_is_top":false,"comment_ctime":1535196525,"is_pvip":false,"replies":[{"id":"7903","content":"前面这句是写栈上锁记录中的displaced mark word，后面这句是CAS 锁对象的mark word","user_name":"作者回复","comment_id":21614,"uid":"1176688","ip_address":"","utype":1,"ctime":1535465465,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"1535196525","product_id":100010301,"comment_content":"“假设当前锁对象的标记字段为 X…XYZ，Java 虚拟机会比较该字段是否为 X…X01。如果是，则替换为刚才分配的锁记录的地址。  ”<br>这个描述上面的 “加锁操作时，如果不是重量级锁，则在栈上分配一个空间存储锁记录，并将锁对象的标记字段复制到栈记录中” 矛盾啊，还是我没有看懂？","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422766,"discussion_content":"前面这句是写栈上锁记录中的displaced mark word，后面这句是CAS 锁对象的mark word","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535465465,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21476,"user_name":"顺子","can_delete":false,"product_type":"c1","uid":1089301,"ip_address":"","ucode":"0EA7710EC71814","user_header":"https://static001.geekbang.org/account/avatar/00/10/9f/15/05d3ade0.jpg","comment_is_top":false,"comment_ctime":1535105366,"is_pvip":false,"replies":[{"id":"7623","content":"在64位Java虚拟机里，地址都是64位，而且都有内存对齐，也就是最后几位是0。markword里的最后两位是用 按位或 操作并进去的。<br><br>(链接的图对应的应该是32位虚拟机，所以地址是32位)","user_name":"作者回复","comment_id":21476,"uid":"1176688","ip_address":"","utype":1,"ctime":1535117700,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"1535105366","product_id":100010301,"comment_content":"对于轻量级锁，markword本质是一个32位的bit，无锁情况下，末尾是01<br>加锁过程只是通过CAS把这32位的bit替换为lockrecord的地址，由于lockrecord地址只有30位，所以末尾补齐32后，末尾是00<br>不知道理解是否正确<br><br>然后有一个疑问，升级为重量级锁的时候，10是什么时候修改的?看到的文档都只说把指针修改为mutex，没提到10是怎么来的，是mutex30位地址加上10后CAS替换进去的吗","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422693,"discussion_content":"在64位Java虚拟机里，地址都是64位，而且都有内存对齐，也就是最后几位是0。markword里的最后两位是用 按位或 操作并进去的。\n\n(链接的图对应的应该是32位虚拟机，所以地址是32位)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535117700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21468,"user_name":"梦想启动的蜗牛","can_delete":false,"product_type":"c1","uid":1111602,"ip_address":"","ucode":"781F2A6DA6FEB3","user_header":"https://static001.geekbang.org/account/avatar/00/10/f6/32/358f9411.jpg","comment_is_top":false,"comment_ctime":1535100399,"is_pvip":false,"replies":[{"id":"7619","content":"都可以的。在Graal里是先复制再CAS的，可以减少一些临界区里的代码。","user_name":"作者回复","comment_id":21468,"uid":"1176688","ip_address":"","utype":1,"ctime":1535116860,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"1535100399","product_id":100010301,"comment_content":"轻量级锁应该是先通过cas替换锁的标记字段，然后再把标记字段复制到栈中对应的锁记录中把？","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422691,"discussion_content":"都可以的。在Graal里是先复制再CAS的，可以减少一些临界区里的代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535116860,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21106,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1534919149,"is_pvip":true,"replies":[{"id":"7415","content":"前几篇的invokedynamic(下)有讲","user_name":"作者回复","comment_id":21106,"uid":"1176688","ip_address":"","utype":1,"ctime":1534928794,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"1534919149","product_id":100010301,"comment_content":"想看下jvm是怎么实现stream和lambda表达式的","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422539,"discussion_content":"前几篇的invokedynamic(下)有讲","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534928794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21077,"user_name":"贾智文","can_delete":false,"product_type":"c1","uid":1100235,"ip_address":"","ucode":"600CF0AB215D1A","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/cb/7b6802cc.jpg","comment_is_top":false,"comment_ctime":1534902789,"is_pvip":false,"replies":[{"id":"7426","content":"看标记字段所指向的轻量级锁锁纪录是否在自己栈上。","user_name":"作者回复","comment_id":21077,"uid":"1176688","ip_address":"","utype":1,"ctime":1534931321,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"1534902789","product_id":100010301,"comment_content":"果不是 X…X01，那么有两种可能。第一，该线程重复获取同一把锁。此时，Java 虚拟机会将锁记录清零，以代表该锁被重复获取。第二，其他线程持有该锁。此时，Java 虚拟机会将这把锁膨胀为重量级锁，并且阻塞当前线程。<br>这两个情况怎么区分呢？","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422524,"discussion_content":"看标记字段所指向的轻量级锁锁纪录是否在自己栈上。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1534931321,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}