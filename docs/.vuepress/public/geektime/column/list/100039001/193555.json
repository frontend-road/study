{"id":193555,"title":"40 | 运用学过的设计原则和思想完善之前讲的性能计数器项目（下）","content":"<p>上一节课中，我们针对版本1存在的问题（特别是Aggregator类、ConsoleReporter和EmailReporter类）进行了重构优化。经过重构之后，代码结构更加清晰、合理、有逻辑性。不过，在细节方面还是存在一些问题，比如ConsoleReporter、EmailReporter类仍然存在代码重复、可测试性差的问题。今天，我们就在版本3中持续重构这部分代码。</p><p>除此之外，在版本3中，我们还会继续完善框架的功能和非功能需求。比如，让原始数据的采集和存储异步执行，解决聚合统计在数据量大的情况下会导致内存吃紧问题，以及提高框架的易用性等，让它成为一个能用且好用的框架。</p><p>话不多说，让我们正式开始版本3的设计与实现吧！</p><h2>代码重构优化</h2><p>我们知道，继承能解决代码重复的问题。我们可以将ConsoleReporter和EmailReporter中的相同代码逻辑，提取到父类ScheduledReporter中，以解决代码重复问题。按照这个思路，重构之后的代码如下所示：</p><pre><code>public abstract class ScheduledReporter {\n  protected MetricsStorage metricsStorage;\n  protected Aggregator aggregator;\n  protected StatViewer viewer;\n\n  public ScheduledReporter(MetricsStorage metricsStorage, Aggregator aggregator, StatViewer viewer) {\n    this.metricsStorage = metricsStorage;\n    this.aggregator = aggregator;\n    this.viewer = viewer;\n  }\n\n  protected void doStatAndReport(long startTimeInMillis, long endTimeInMillis) {\n    long durationInMillis = endTimeInMillis -  startTimeInMillis;\n    Map&lt;String, List&lt;RequestInfo&gt;&gt; requestInfos =\n            metricsStorage.getRequestInfos(startTimeInMillis, endTimeInMillis);\n    Map&lt;String, RequestStat&gt; requestStats = aggregator.aggregate(requestInfos, durationInMillis);\n    viewer.output(requestStats, startTimeInMillis, endTimeInMillis);\n  }\n\n}\n</code></pre><p>ConsoleReporter和EmailReporter代码重复的问题解决了，那我们再来看一下代码的可测试性问题。因为ConsoleReporter和EmailReporter的代码比较相似，且EmailReporter的代码更复杂些，所以，关于如何重构来提高其可测试性，我们拿EmailReporter来举例说明。将重复代码提取到父类ScheduledReporter之后，EmailReporter代码如下所示：</p><!-- [[[read_end]]] --><pre><code>public class EmailReporter extends ScheduledReporter {\n  private static final Long DAY_HOURS_IN_SECONDS = 86400L;\n\n  private MetricsStorage metricsStorage;\n  private Aggregator aggregator;\n  private StatViewer viewer;\n\n  public EmailReporter(MetricsStorage metricsStorage, Aggregator aggregator, StatViewer viewer) {\n    this.metricsStorage = metricsStorage;\n    this.aggregator = aggregator;\n    this.viewer = viewer;\n  }\n\n  public void startDailyReport() {\n    Calendar calendar = Calendar.getInstance();\n    calendar.add(Calendar.DATE, 1);\n    calendar.set(Calendar.HOUR_OF_DAY, 0);\n    calendar.set(Calendar.MINUTE, 0);\n    calendar.set(Calendar.SECOND, 0);\n    calendar.set(Calendar.MILLISECOND, 0);\n    Date firstTime = calendar.getTime();\n\n    Timer timer = new Timer();\n    timer.schedule(new TimerTask() {\n      @Override\n      public void run() {\n        long durationInMillis = DAY_HOURS_IN_SECONDS * 1000;\n        long endTimeInMillis = System.currentTimeMillis();\n        long startTimeInMillis = endTimeInMillis - durationInMillis;\n        doStatAndReport(startTimeInMillis, endTimeInMillis);\n      }\n    }, firstTime, DAY_HOURS_IN_SECONDS * 1000);\n  }\n}\n</code></pre><p>前面提到，之所以EmailReporter可测试性不好，一方面是因为用到了线程（定时器也相当于多线程），另一方面是因为涉及时间的计算逻辑。</p><p>实际上，在经过上一步的重构之后，EmailReporter中的startDailyReport()函数的核心逻辑已经被抽离出去了，较复杂的、容易出bug的就只剩下计算firstTime的那部分代码了。我们可以将这部分代码继续抽离出来，封装成一个函数，然后，单独针对这个函数写单元测试。重构之后的代码如下所示：</p><pre><code>public class EmailReporter extends ScheduledReporter {\n  // 省略其他代码...\n  public void startDailyReport() {\n    Date firstTime = trimTimeFieldsToZeroOfNextDay();\n    Timer timer = new Timer();\n    timer.schedule(new TimerTask() {\n      @Override\n      public void run() {\n        // 省略其他代码...\n      }\n    }, firstTime, DAY_HOURS_IN_SECONDS * 1000);\n  }\n\n  // 设置成protected而非private是为了方便写单元测试\n  @VisibleForTesting\n  protected Date trimTimeFieldsToZeroOfNextDay() {\n    Calendar calendar = Calendar.getInstance(); // 这里可以获取当前时间\n    calendar.add(Calendar.DATE, 1);\n    calendar.set(Calendar.HOUR_OF_DAY, 0);\n    calendar.set(Calendar.MINUTE, 0);\n    calendar.set(Calendar.SECOND, 0);\n    calendar.set(Calendar.MILLISECOND, 0);\n    return calendar.getTime();\n  }\n}\n</code></pre><p>简单的代码抽离成trimTimeFieldsToZeroOfNextDay()函数之后，虽然代码更加清晰了，一眼就能从名字上知道这段代码的意图（获取当前时间的下一天的0点时间），但我们发现这个函数的可测试性仍然不好，因为它强依赖当前的系统时间。实际上，这个问题挺普遍的。一般的解决方法是，将强依赖的部分通过参数传递进来，这有点类似我们之前讲的依赖注入。按照这个思路，我们再对trimTimeFieldsToZeroOfNextDay()函数进行重构。重构之后的代码如下所示：</p><pre><code>public class EmailReporter extends ScheduledReporter {\n  // 省略其他代码...\n  public void startDailyReport() {\n    // new Date()可以获取当前时间\n    Date firstTime = trimTimeFieldsToZeroOfNextDay(new Date());\n    Timer timer = new Timer();\n    timer.schedule(new TimerTask() {\n      @Override\n      public void run() {\n        // 省略其他代码...\n      }\n    }, firstTime, DAY_HOURS_IN_SECONDS * 1000);\n  }\n\n  protected Date trimTimeFieldsToZeroOfNextDay(Date date) {\n    Calendar calendar = Calendar.getInstance(); // 这里可以获取当前时间\n    calendar.setTime(date); // 重新设置时间\n    calendar.add(Calendar.DATE, 1);\n    calendar.set(Calendar.HOUR_OF_DAY, 0);\n    calendar.set(Calendar.MINUTE, 0);\n    calendar.set(Calendar.SECOND, 0);\n    calendar.set(Calendar.MILLISECOND, 0);\n    return calendar.getTime();\n  }\n}\n</code></pre><p>经过这次重构之后，trimTimeFieldsToZeroOfNextDay()函数不再强依赖当前的系统时间，所以非常容易对其编写单元测试。你可以把它作为练习，写一下这个函数的单元测试。</p><p>不过，EmailReporter类中startDailyReport()还是涉及多线程，针对这个函数该如何写单元测试呢？我的看法是，这个函数不需要写单元测试。为什么这么说呢？我们可以回到写单元测试的初衷来分析这个问题。单元测试是为了提高代码质量，减少bug。如果代码足够简单，简单到bug无处隐藏，那我们就没必要为了写单元测试而写单元测试，或者为了追求单元测试覆盖率而写单元测试。经过多次代码重构之后，startDailyReport()函数里面已经没有多少代码逻辑了，所以，完全没必要对它写单元测试了。</p><h2>功能需求完善</h2><p>经过了多个版本的迭代、重构，我们现在来重新Review一下，目前的设计与实现是否已经完全满足第25讲中最初的功能需求了。</p><p>最初的功能需求描述是下面这个样子的，我们来重新看一下。</p><blockquote>\n<p>我们希望设计开发一个小的框架，能够获取接口调用的各种统计信息，比如响应时间的最大值（max）、最小值（min）、平均值（avg）、百分位值（percentile），接口调用次数（count）、频率（tps） 等，并且支持将统计结果以各种显示格式（比如：JSON格式、网页格式、自定义显示格式等）输出到各种终端（Console命令行、HTTP网页、Email、日志文件、自定义输出终端等），以方便查看。</p>\n</blockquote><p>经过整理拆解之后的需求列表如下所示：</p><blockquote>\n<p>接口统计信息：包括接口响应时间的统计信息，以及接口调用次数的统计信息等。<br>\n统计信息的类型：max、min、avg、percentile、count、tps等。<br>\n统计信息显示格式：JSON、HTML、自定义显示格式。<br>\n统计信息显示终端：Console、Email、HTTP网页、日志、自定义显示终端。</p>\n</blockquote><p>经过挖掘，我们还得到一些隐藏的需求，如下所示：</p><blockquote>\n<p>统计触发方式：包括主动和被动两种。主动表示以一定的频率定时统计数据，并主动推送到显示终端，比如邮件推送。被动表示用户触发统计，比如用户在网页中选择要统计的时间区间，触发统计，并将结果显示给用户。</p>\n</blockquote><blockquote>\n<p>统计时间区间：框架需要支持自定义统计时间区间，比如统计最近10分钟的某接口的tps、访问次数，或者统计12月11日00点到12月12日00点之间某接口响应时间的最大值、最小值、平均值等。</p>\n</blockquote><blockquote>\n<p>统计时间间隔：对于主动触发统计，我们还要支持指定统计时间间隔，也就是多久触发一次统计显示。比如，每间隔10s统计一次接口信息并显示到命令行中，每间隔24小时发送一封统计信息邮件。</p>\n</blockquote><p>版本3已经实现了大部分的功能，还有以下几个小的功能点没有实现。你可以将这些还没有实现的功能，自己实现一下，继续迭代出框架的第4个版本。</p><ul>\n<li>被动触发统计的方式，也就是需求中提到的通过网页展示统计信息。实际上，这部分代码的实现也并不难。我们可以复用框架现在的代码，编写一些展示页面和提供获取统计数据的接口即可。</li>\n<li>对于自定义显示终端，比如显示数据到自己开发的监控平台，这就有点类似通过网页来显示数据，不过更加简单些，只需要提供一些获取统计数据的接口，监控平台通过这些接口拉取数据来显示即可。</li>\n<li>自定义显示格式。在框架现在的代码实现中，显示格式和显示终端（比如Console、Email）是紧密耦合在一起的，比如，Console只能通过JSON格式来显示统计数据，Email只能通过某种固定的HTML格式显示数据，这样的设计还不够灵活。我们可以将显示格式设计成独立的类，将显示终端和显示格式的代码分离，让显示终端支持配置不同的显示格式。具体的代码实现留给你自己思考，我这里就不多说了。</li>\n</ul><h2>非功能需求完善</h2><p>Review完了功能需求的完善程度，现在，我们再来看，版本3的非功能性需求的完善程度。在第25讲中，我们提到，针对这个框架的开发，我们需要考虑的非功能性需求包括：易用性、性能、扩展性、容错性、通用性。我们现在就依次来看一下这几个方面。</p><h3>1.易用性</h3><p>所谓的易用性，顾名思义，就是框架是否好用。框架的使用者将框架集成到自己的系统中时，主要用到MetricsCollector和EmailReporter、ConsoleReporter这几个类。通过MetricsCollector类来采集数据，通过EmailReporter、ConsoleReporter类来触发主动统计数据、显示统计结果。示例代码如下所示：</p><pre><code>public class PerfCounterTest {\n  public static void main(String[] args) {\n    MetricsStorage storage = new RedisMetricsStorage();\n    Aggregator aggregator = new Aggregator();\n\n    // 定时触发统计并将结果显示到终端\n    ConsoleViewer consoleViewer = new ConsoleViewer();\n    ConsoleReporter consoleReporter = new ConsoleReporter(storage, aggregator, consoleViewer);\n    consoleReporter.startRepeatedReport(60, 60);\n    \n    // 定时触发统计并将结果输出到邮件\n    EmailViewer emailViewer = new EmailViewer();\n    emailViewer.addToAddress(&quot;wangzheng@xzg.com&quot;);\n    EmailReporter emailReporter = new EmailReporter(storage, aggregator, emailViewer);\n    emailReporter.startDailyReport();\n\n    // 收集接口访问数据\n    MetricsCollector collector = new MetricsCollector(storage);\n    collector.recordRequest(new RequestInfo(&quot;register&quot;, 123, 10234));\n    collector.recordRequest(new RequestInfo(&quot;register&quot;, 223, 11234));\n    collector.recordRequest(new RequestInfo(&quot;register&quot;, 323, 12334));\n    collector.recordRequest(new RequestInfo(&quot;login&quot;, 23, 12434));\n    collector.recordRequest(new RequestInfo(&quot;login&quot;, 1223, 14234));\n\n    try {\n      Thread.sleep(100000);\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n  }\n}\n</code></pre><p>从上面的使用示例中，我们可以看出，框架用起来还是稍微有些复杂的，需要组装各种类，比如需要创建MetricsStorage对象、Aggregator对象、ConsoleViewer对象，然后注入到ConsoleReporter中，才能使用ConsoleReporter。除此之外，还有可能存在误用的情况，比如把EmailViewer传递进了ConsoleReporter中。总体上来讲，框架的使用方式暴露了太多细节给用户，过于灵活也带来了易用性的降低。</p><p>为了让框架用起来更加简单（能将组装的细节封装在框架中，不暴露给框架使用者），又不失灵活性（可以自由组装不同的MetricsStorage实现类、StatViewer实现类到ConsoleReporter或EmailReporter），也不降低代码的可测试性（通过依赖注入来组装类，方便在单元测试中mock），我们可以额外地提供一些封装了默认依赖的构造函数，让使用者自主选择使用哪种构造函数来构造对象。这段话理解起来有点复杂，我把按照这个思路重构之后的代码放到了下面，你可以结合着一块看一下。</p><pre><code>public class MetricsCollector {\n  private MetricsStorage metricsStorage;\n\n  // 兼顾代码的易用性，新增一个封装了默认依赖的构造函数\n  public MetricsCollectorB() {\n    this(new RedisMetricsStorage());\n  }\n\n  // 兼顾灵活性和代码的可测试性，这个构造函数继续保留\n  public MetricsCollectorB(MetricsStorage metricsStorage) {\n    this.metricsStorage = metricsStorage;\n  }\n  // 省略其他代码...\n}\n\npublic class ConsoleReporter extends ScheduledReporter {\n  private ScheduledExecutorService executor;\n  \n  // 兼顾代码的易用性，新增一个封装了默认依赖的构造函数\n  public ConsoleReporter() {\n    this(new RedisMetricsStorage(), new Aggregator(), new ConsoleViewer());\n  }\n\n  // 兼顾灵活性和代码的可测试性，这个构造函数继续保留\n  public ConsoleReporter(MetricsStorage metricsStorage, Aggregator aggregator, StatViewer viewer) {\n    super(metricsStorage, aggregator, viewer);\n    this.executor = Executors.newSingleThreadScheduledExecutor();\n  }\n  // 省略其他代码...\n}\n\npublic class EmailReporter extends ScheduledReporter {\n  private static final Long DAY_HOURS_IN_SECONDS = 86400L;\n\n  // 兼顾代码的易用性，新增一个封装了默认依赖的构造函数\n  public EmailReporter(List&lt;String&gt; emailToAddresses) {\n    this(new RedisMetricsStorage(), new Aggregator(), new EmailViewer(emailToAddresses));\n  }\n  \n  // 兼顾灵活性和代码的可测试性，这个构造函数继续保留\n  public EmailReporter(MetricsStorage metricsStorage, Aggregator aggregator, StatViewer viewer) {\n    super(metricsStorage, aggregator, viewer);\n  }\n  // 省略其他代码...\n}\n</code></pre><p>现在，我们再来看下框架如何来使用。具体使用示例如下所示。看起来是不是简单多了呢？</p><pre><code>public class PerfCounterTest {\n  public static void main(String[] args) {\n    ConsoleReporter consoleReporter = new ConsoleReporter();\n    consoleReporter.startRepeatedReport(60, 60);\n\n    List&lt;String&gt; emailToAddresses = new ArrayList&lt;&gt;();\n    emailToAddresses.add(&quot;wangzheng@xzg.com&quot;);\n    EmailReporter emailReporter = new EmailReporter(emailToAddresses);\n    emailReporter.startDailyReport();\n\n    MetricsCollector collector = new MetricsCollector();\n    collector.recordRequest(new RequestInfo(&quot;register&quot;, 123, 10234));\n    collector.recordRequest(new RequestInfo(&quot;register&quot;, 223, 11234));\n    collector.recordRequest(new RequestInfo(&quot;register&quot;, 323, 12334));\n    collector.recordRequest(new RequestInfo(&quot;login&quot;, 23, 12434));\n    collector.recordRequest(new RequestInfo(&quot;login&quot;, 1223, 14234));\n\n    try {\n      Thread.sleep(100000);\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n  }\n}\n</code></pre><p>如果你足够细心，可能已经发现，RedisMeticsStorage和EmailViewer还需要另外一些配置信息才能构建成功，比如Redis的地址，Email邮箱的POP3服务器地址、发送地址。这些配置并没有在刚刚代码中体现到，那我们该如何获取呢？</p><p>我们可以将这些配置信息放到配置文件中，在框架启动的时候，读取配置文件中的配置信息到一个Configuration单例类。RedisMetricsStorage类和EmailViewer类都可以从这个Configuration类中获取需要的配置信息来构建自己。</p><h3>2.性能</h3><p>对于需要集成到业务系统的框架来说，我们不希望框架本身代码的执行效率，对业务系统有太多性能上的影响。对于性能计数器这个框架来说，一方面，我们希望它是低延迟的，也就是说，统计代码不影响或很少影响接口本身的响应时间；另一方面，我们希望框架本身对内存的消耗不能太大。</p><p>对于性能这一点，落实到具体的代码层面，需要解决两个问题，也是我们之前提到过的，一个是采集和存储要异步来执行，因为存储基于外部存储（比如Redis），会比较慢，异步存储可以降低对接口响应时间的影响。另一个是当需要聚合统计的数据量比较大的时候，一次性加载太多的数据到内存，有可能会导致内存吃紧，甚至内存溢出，这样整个系统都会瘫痪掉。</p><p>针对第一个问题，我们通过在MetricsCollector中引入Google Guava EventBus来解决。实际上，我们可以把EventBus看作一个“生产者-消费者”模型或者“发布-订阅”模型，采集的数据先放入内存共享队列中，另一个线程读取共享队列中的数据，写入到外部存储（比如Redis）中。具体的代码实现如下所示：</p><pre><code>public class MetricsCollector {\n  private static final int DEFAULT_STORAGE_THREAD_POOL_SIZE = 20;\n\n  private MetricsStorage metricsStorage;\n  private EventBus eventBus;\n\n  public MetricsCollector(MetricsStorage metricsStorage) {\n    this(metricsStorage, DEFAULT_STORAGE_THREAD_POOL_SIZE);\n  }\n\n  public MetricsCollector(MetricsStorage metricsStorage, int threadNumToSaveData) {\n    this.metricsStorage = metricsStorage;\n    this.eventBus = new AsyncEventBus(Executors.newFixedThreadPool(threadNumToSaveData));\n    this.eventBus.register(new EventListener());\n  }\n\n  public void recordRequest(RequestInfo requestInfo) {\n    if (requestInfo == null || StringUtils.isBlank(requestInfo.getApiName())) {\n      return;\n    }\n    eventBus.post(requestInfo);\n  }\n\n  public class EventListener {\n    @Subscribe\n    public void saveRequestInfo(RequestInfo requestInfo) {\n      metricsStorage.saveRequestInfo(requestInfo);\n    }\n  }\n}\n</code></pre><p>针对第二个问题，解决的思路比较简单，但代码实现稍微有点复杂。当统计的时间间隔较大的时候，需要统计的数据量就会比较大。我们可以将其划分为一些小的时间区间（比如10分钟作为一个统计单元），针对每个小的时间区间分别进行统计，然后将统计得到的结果再进行聚合，得到最终整个时间区间的统计结果。不过，这个思路只适合响应时间的max、min、avg，及其接口请求count、tps的统计，对于响应时间的percentile的统计并不适用。</p><p>对于percentile的统计要稍微复杂一些，具体的解决思路是这样子的：我们分批从Redis中读取数据，然后存储到文件中，再根据响应时间从小到大利用外部排序算法来进行排序（具体的实现方式可以看一下《数据结构与算法之美》专栏）。排序完成之后，再从文件中读取第count*percentile（count表示总的数据个数，percentile就是百分比，99百分位就是0.99）个数据，就是对应的percentile响应时间。</p><p>这里我只给出了除了percentile之外的统计信息的计算代码，如下所示。对于percentile的计算，因为代码量比较大，留给你自己实现。</p><pre><code>public class ScheduleReporter {\n  private static final long MAX_STAT_DURATION_IN_MILLIS = 10 * 60 * 1000; // 10minutes\n\n  protected MetricsStorage metricsStorage;\n  protected Aggregator aggregator;\n  protected StatViewer viewer;\n\n  public ScheduleReporter(MetricsStorage metricsStorage, Aggregator aggregator, StatViewer viewer) {\n    this.metricsStorage = metricsStorage;\n    this.aggregator = aggregator;\n    this.viewer = viewer;\n  }\n\n  protected void doStatAndReport(long startTimeInMillis, long endTimeInMillis) {\n    Map&lt;String, RequestStat&gt; stats = doStat(startTimeInMillis, endTimeInMillis);\n    viewer.output(stats, startTimeInMillis, endTimeInMillis);\n  }\n\n  private Map&lt;String, RequestStat&gt; doStat(long startTimeInMillis, long endTimeInMillis) {\n    Map&lt;String, List&lt;RequestStat&gt;&gt; segmentStats = new HashMap&lt;&gt;();\n    long segmentStartTimeMillis = startTimeInMillis;\n    while (segmentStartTimeMillis &lt; endTimeInMillis) {\n      long segmentEndTimeMillis = segmentStartTimeMillis + MAX_STAT_DURATION_IN_MILLIS;\n      if (segmentEndTimeMillis &gt; endTimeInMillis) {\n        segmentEndTimeMillis = endTimeInMillis;\n      }\n      Map&lt;String, List&lt;RequestInfo&gt;&gt; requestInfos =\n              metricsStorage.getRequestInfos(segmentStartTimeMillis, segmentEndTimeMillis);\n      if (requestInfos == null || requestInfos.isEmpty()) {\n        continue;\n      }\n      Map&lt;String, RequestStat&gt; segmentStat = aggregator.aggregate(\n              requestInfos, segmentEndTimeMillis - segmentStartTimeMillis);\n      addStat(segmentStats, segmentStat);\n      segmentStartTimeMillis += MAX_STAT_DURATION_IN_MILLIS;\n    }\n\n    long durationInMillis = endTimeInMillis - startTimeInMillis;\n    Map&lt;String, RequestStat&gt; aggregatedStats = aggregateStats(segmentStats, durationInMillis);\n    return aggregatedStats;\n  }\n\n  private void addStat(Map&lt;String, List&lt;RequestStat&gt;&gt; segmentStats,\n                       Map&lt;String, RequestStat&gt; segmentStat) {\n    for (Map.Entry&lt;String, RequestStat&gt; entry : segmentStat.entrySet()) {\n      String apiName = entry.getKey();\n      RequestStat stat = entry.getValue();\n      List&lt;RequestStat&gt; statList = segmentStats.putIfAbsent(apiName, new ArrayList&lt;&gt;());\n      statList.add(stat);\n    }\n  }\n\n  private Map&lt;String, RequestStat&gt; aggregateStats(Map&lt;String, List&lt;RequestStat&gt;&gt; segmentStats,\n                                                  long durationInMillis) {\n    Map&lt;String, RequestStat&gt; aggregatedStats = new HashMap&lt;&gt;();\n    for (Map.Entry&lt;String, List&lt;RequestStat&gt;&gt; entry : segmentStats.entrySet()) {\n      String apiName = entry.getKey();\n      List&lt;RequestStat&gt; apiStats = entry.getValue();\n      double maxRespTime = Double.MIN_VALUE;\n      double minRespTime = Double.MAX_VALUE;\n      long count = 0;\n      double sumRespTime = 0;\n      for (RequestStat stat : apiStats) {\n        if (stat.getMaxResponseTime() &gt; maxRespTime) maxRespTime = stat.getMaxResponseTime();\n        if (stat.getMinResponseTime() &lt; minRespTime) minRespTime = stat.getMinResponseTime();\n        count += stat.getCount();\n        sumRespTime += (stat.getCount() * stat.getAvgResponseTime());\n      }\n      RequestStat aggregatedStat = new RequestStat();\n      aggregatedStat.setMaxResponseTime(maxRespTime);\n      aggregatedStat.setMinResponseTime(minRespTime);\n      aggregatedStat.setAvgResponseTime(sumRespTime / count);\n      aggregatedStat.setCount(count);\n      aggregatedStat.setTps(count / durationInMillis * 1000);\n      aggregatedStats.put(apiName, aggregatedStat);\n    }\n    return aggregatedStats;\n  }\n}\n</code></pre><h3>3.扩展性</h3><p>前面我们提到，框架的扩展性有别于代码的扩展性，是从使用者的角度来讲的，特指使用者可以在不修改框架源码，甚至不拿到框架源码的情况下，为框架扩展新的功能。</p><p>在刚刚讲到框架的易用性的时候，我们给出了框架如何使用的代码示例。从示例中，我们可以发现，框架在兼顾易用性的同时，也可以灵活地替换各种类对象，比如MetricsStorage、StatViewer。举个例子来说，如果我们要让框架基于HBase来存储原始数据而非Redis，那我们只需要设计一个实现MetricsStorage接口的HBaseMetricsStorage类，传递给MetricsCollector和ConsoleReporter、EmailReporter类即可。</p><h3>4.容错性</h3><p>容错性这一点也非常重要。对于这个框架来说，不能因为框架本身的异常导致接口请求出错。所以，对框架可能存在的各种异常情况，我们都要考虑全面。</p><p>在现在的框架设计与实现中，采集和存储是异步执行，即便Redis挂掉或者写入超时，也不会影响到接口的正常响应。除此之外，Redis异常，可能会影响到数据统计显示（也就是ConsoleReporter、EmailReporter负责的工作），但并不会影响到接口的正常响应。</p><h3>5.通用性</h3><p>为了提高框架的复用性，能够灵活应用到各种场景中，框架在设计的时候，要尽可能通用。我们要多去思考一下，除了接口统计这样一个需求，这个框架还可以适用到其他哪些场景中。比如是否还可以处理其他事件的统计信息，比如SQL请求时间的统计、业务统计（比如支付成功率）等。关于这一点，我们在现在的版本3中暂时没有考虑到，你可以自己思考一下。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要掌握的重点内容。</p><p>还记得吗？在第25、26讲中，我们提到，针对性能计数器这个框架的开发，要想一下子实现我们罗列的所有功能，对任何人来说都是比较有挑战的。而经过这几个版本的迭代之后，我们不知不觉地就完成了几乎所有的需求，包括功能性和非功能性的需求。</p><p>在第25讲中，我们实现了一个最小原型，虽然非常简陋，所有的代码都塞在一个类中，但它帮我们梳理清楚了需求。在第26讲中，我们实现了框架的第1个版本，这个版本只包含最基本的功能，并且初步利用面向对象的设计方法，把不同功能的代码划分到了不同的类中。</p><p>在第39讲中，我们实现了框架的第2个版本，这个版本对第1个版本的代码结构进行了比较大的调整，让整体代码结构更加合理、清晰、有逻辑性。</p><p>在第40讲中，我们实现了框架的第3个版本，对第2个版本遗留的细节问题进行了重构，并且重点解决了框架的易用性和性能问题。</p><p>从上面的迭代过程，我们可以发现，大部分情况下，我们都是针对问题解决问题，每个版本都聚焦一小部分问题，所以整个过程也没有感觉到有太大难度。尽管我们迭代了3个版本，但目前的设计和实现还有很多值得进一步优化和完善的地方，但限于专栏的篇幅，继续优化的工作留给你自己来完成。</p><p>最后，我希望你不仅仅关注这个框架本身的设计和实现，更重要的是学会这个逐步优化的方法，以及其中涉及的一些编程技巧、设计思路，能够举一反三地用在其他项目中。</p><h2>课堂讨论</h2><p>最后，还是给你留一道课堂讨论题。</p><p>正常情况下，ConsoleReporter的startRepeatedReport()函数只会被调用一次。但是，如果被多次调用，那就会存在问题。具体会有什么问题呢？又该如何解决呢？</p><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p><p><a href=\"https://jinshuju.net/f/cZuRmd\"><img src=\"https://static001.geekbang.org/resource/image/8b/43/8b7e755ddb44e490848a052c5dc11043.jpg?wh=1142*640\" alt=\"\"></a></p>","neighbors":{"left":{"article_title":"39 | 运用学过的设计原则和思想完善之前讲的性能计数器项目（上）","id":193221},"right":{"article_title":"41 | 单例模式（上）：为什么说支持懒加载的双重检测不比饿汉式更优？","id":194035}},"comments":[{"had_liked":false,"id":180657,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1582359745,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"315114972353","product_id":100039001,"comment_content":"设计模式_40:<br># 作业<br><br>导致多个线程的重复统计。<br>办法：加入进程内的全局变量(注意多线程同步问题)。<br><br># 感想<br><br>我个人是Android工程师，客户端的开发默认就要思考一个问题：方法重复调用时(如多次点击某个按钮等)逻辑是否还正常。<br><br>25，26，39，40这四节课边听边读反复了好几遍了，因为目的是掌握该掌握的东西，而不是简单地打个卡，所以整个春节期间就卡在这四节课的重复中了，不停地循环听。。。<br><br>也有好处：我反倒对这几节内容非常熟悉了，有两点感受较深：<br>1&gt; 方法论：分清楚 *功能性需求* 与 *非功能型需求*<br>\t之前是想到什么注意什么，往往做不到穷举。<br><br>2&gt; 一步一步地重构，其实解决的是自信问题：<br>\t做事要先解决思想问题，也就是心理问题：<br>\t- 没有人能够一步到位地完美解决问题，优秀的代码是演进的，也就是说，代码结构不完美的状态是跳不过去的。<br>\t- 我们始终聚焦在解决问题上，代码有问题非常正常。<br>\t- 我们要带着成就感不断重构代码，而不是带着对自己否定的愧疚感，这非常重要。<br>\t- 成就感让你追求卓越，愧疚感只是让你不想犯错(而这是做不到的)。","like_count":74,"discussions":[{"author":{"id":1948762,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/bc/5a/855160ca.jpg","nickname":"锋","note":"","ucode":"61A3ACB1D14CAF","race_medal":2,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373499,"discussion_content":"好难理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620745585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1131128,"avatar":"https://static001.geekbang.org/account/avatar/00/11/42/78/7ba89c75.jpg","nickname":"RedDevil","note":"","ucode":"F8F5DC209BB3B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312339,"discussion_content":"兄弟，同道中人","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602667165,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175485,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1580732797,"is_pvip":true,"discussion_count":4,"race_medal":0,"score":"70300209533","product_id":100039001,"comment_content":"思考题：startRepeatedReport()多次调用，会启动多个线程，每个线程都会执行统计和输出工作。<br>想了一种简单的实现方式，将runnable做为成员变量，第一次调用startRepeatedReport()时初始化，若多次调用，判空，返回。<br>  public void startRepeatedReport(long periodInSeconds, long durationInSeconds) {<br>    if (runnable != null) {<br>      System.out.println(&quot;duplicate calls!&quot;);<br>      return;<br>    }<br>    runnable = () -&gt; {<br>      long durationInMillis = durationInSeconds * 1000;<br>      long endTimeInMillis = System.currentTimeMillis();<br>      long startTimeInMillis = endTimeInMillis - durationInMillis;<br>      doReport(startTimeInMillis, endTimeInMillis);<br>    };<br>    executor.scheduleAtFixedRate(runnable, 0, periodInSeconds, TimeUnit.SECONDS);<br>  }<br>代码放在了：https:&#47;&#47;github.com&#47;gdhucoder&#47;Algorithms4&#47;tree&#47;master&#47;designpattern&#47;u40","like_count":16,"discussions":[{"author":{"id":1330141,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4b/dd/41614582.jpg","nickname":"HomeyLiu","note":"","ucode":"EF4CCB92C369B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536015,"discussion_content":"你这有问题, 多线程,还是多次打印,简单直接的就用 信号量,数量只有1, ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638630165,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296068,"discussion_content":"增加一个成员变量，同步控制，最轻量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596443935,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1396741,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/05/90f1a14e.jpg","nickname":"JUNLONG","note":"","ucode":"15C3E0B27E081C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283828,"discussion_content":"这个应该用单例模式吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592379013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181055,"avatar":"https://static001.geekbang.org/account/avatar/00/12/05/7f/d35ab9a1.jpg","nickname":"z.l","note":"","ucode":"805CC5784D3F76","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":169882,"discussion_content":"还是有问题，多线程不安全","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581652064,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175617,"user_name":"Andy","can_delete":false,"product_type":"c1","uid":1615348,"ip_address":"","ucode":"7414B2E60C4AD5","user_header":"https://static001.geekbang.org/account/avatar/00/18/a5/f4/de2d074e.jpg","comment_is_top":false,"comment_ctime":1580783258,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"61710325402","product_id":100039001,"comment_content":"老师能提供课程代码吗？","like_count":14},{"had_liked":false,"id":175554,"user_name":"平风造雨","can_delete":false,"product_type":"c1","uid":1014349,"ip_address":"","ucode":"F9EE4704F31E22","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/4d/b0228a1a.jpg","comment_is_top":false,"comment_ctime":1580742564,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"48825382820","product_id":100039001,"comment_content":"调用多次可以通过多线程共享的状态变量来解决，CAS或者加锁进行状态的变更。","like_count":12},{"had_liked":false,"id":175397,"user_name":"undefined","can_delete":false,"product_type":"c1","uid":1587803,"ip_address":"","ucode":"867405CA5A9FB7","user_header":"https://static001.geekbang.org/account/avatar/00/18/3a/5b/ce1724ca.jpg","comment_is_top":false,"comment_ctime":1580705263,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31645476335","product_id":100039001,"comment_content":"深入浅出，过瘾。","like_count":7},{"had_liked":false,"id":175396,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1580705249,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"27350509025","product_id":100039001,"comment_content":"先回答问题：<br>1.会导致多余线程做多余的统计和展示。因为每次调用都会起一个异步线程输出统计数据到控制台。这样既会带来额外的性能开销，又会导致统计信息不易阅读。<br><br>2.在ConsoleReporter内部维护一个可视字段 started。然后在方法执行时，优先判断该字段是否已经变为true。如果是则不再往下执行。也算是保证该函数的幂等性。<br><br>个人疑问：<br>1.怎么做到这样分步展示重构过程的？我现在写，基本一边写就一边重构，停手也就差不多到合适的质量了。刻意要展示重构手法，展示的知识点会有很多疏漏，并无法做到这样一步一步的展示（下意识一步到位，并不知道怎么退到不好的代码结构）。<br><br>2.能理解栏主尽量不依赖任何框架的初衷。但对于java，spring其实才是标准，感觉是不是基于spring框架来写demo还好点？ 我现在比较喜欢让代码依赖spring框架来实现，感觉这样会显得优雅一些。栏主怎么看？<br><br>","like_count":6,"discussions":[{"author":{"id":1457464,"avatar":"https://static001.geekbang.org/account/avatar/00/16/3d/38/6f02a4b9.jpg","nickname":"your problem？","note":"","ucode":"6E096E7958CFD7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":160383,"discussion_content":"我个人觉得还是不要依赖于Spring好，虽然我曾经是后台，也能看懂，但是这个设计模式专栏本身就是跟侧重程序设计的方法，本身使用Java语言就已经对不同的风格程序员存在一定的偏差，还用Spring的话非常不合适的","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1580797675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1337598,"avatar":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","nickname":"岁月","note":"","ucode":"29A2A2BC3C4FE4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1457464,"avatar":"https://static001.geekbang.org/account/avatar/00/16/3d/38/6f02a4b9.jpg","nickname":"your problem？","note":"","ucode":"6E096E7958CFD7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":176021,"discussion_content":"说的非常好, 我本身就不是写java的...再弄个spring的话, 这真是不合适了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582015447,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":160383,"ip_address":""},"score":176021,"extra":""}]},{"author":{"id":1133947,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIaOAxRlZjFkGfRBn420LuAcyWkMrpq5iafGdqthX5icJPjql0ibZOAdafaqbfvw4ZpVzDmsaYglVXDw/132","nickname":"唐朝农民","note":"","ucode":"6F8F43C6652225","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":159656,"discussion_content":"要我等非Java系怎么办","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1580721236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1179565,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ff/ad/5020a8c5.jpg","nickname":"Farewell丶","note":"","ucode":"A0D69893C5375C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":160338,"discussion_content":"Spring本身现在依赖很多，最后的执行包会比较大如果依赖的话。对于一个类库包，而不是一个应用程序，对自己类库最后形成的依赖程序包的大小也要做一个考量。另外如果使用了spring，那么可能造成应用程序使用的同依赖版本兼容问题，考虑的事情也就更多了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1580790283,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188222,"avatar":"https://static001.geekbang.org/account/avatar/00/12/21/7e/fb725950.jpg","nickname":"罗 乾 林","note":"","ucode":"D0406F95176ABA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":160838,"discussion_content":"利用框架，而不迷信框架，原理和思想重要。框架也许还会限制我们进步","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580829644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175356,"user_name":"高源","can_delete":false,"product_type":"c1","uid":1048887,"ip_address":"","ucode":"751B41FD38EF7D","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/37/12e4c9c9.jpg","comment_is_top":false,"comment_ctime":1580689164,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"27350492940","product_id":100039001,"comment_content":"老师39,40课完整源代码可以提供下吗，我准备好好研究学习下","like_count":6,"discussions":[{"author":{"id":3178447,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Pw2K9YovHNA4UddNibv42gwtJTiabiaVwEZ7fmrb2IyhF5k0nXMiaTpWUc1uib49XaKsKc7CVvnPcHvE7d0FE5F28dw/132","nickname":"Geek_17f801","note":"","ucode":"5EB01D36BB2C18","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588808,"discussion_content":"哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664118482,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2789067,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/8e/cb/1efcaf20.jpg","nickname":"Justway","note":"","ucode":"75966B5533C872","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586190,"discussion_content":"真想好好研究学习就自己敲吧老弟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662026680,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"重庆"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":177813,"discussion_content":"老师都是手敲代码，你居然懒的写","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582122071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184418,"user_name":"请叫我和尚","can_delete":false,"product_type":"c1","uid":1703256,"ip_address":"","ucode":"33A8A1CDA103F9","user_header":"https://static001.geekbang.org/account/avatar/00/19/fd/58/1af629c7.jpg","comment_is_top":false,"comment_ctime":1583311327,"is_pvip":false,"discussion_count":1,"race_medal":1,"score":"23058147807","product_id":100039001,"comment_content":"这两篇实战对自己的感觉就是越来越懵，可能还需要多读读，也不知道是不是跟自己的项目做的很少有原因，前面的理论都还能消化","like_count":5,"discussions":[{"author":{"id":3015503,"avatar":"","nickname":"Geek_08a0f7","note":"","ucode":"C2D78F6B714B88","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578048,"discussion_content":"同上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656487647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":189578,"user_name":"Q罗","can_delete":false,"product_type":"c1","uid":1792098,"ip_address":"","ucode":"E797378F4DA1F4","user_header":"https://static001.geekbang.org/account/avatar/00/1b/58/62/346dd248.jpg","comment_is_top":false,"comment_ctime":1584530785,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18764399969","product_id":100039001,"comment_content":"终于进去到期待已久的设计模式了","like_count":4},{"had_liked":false,"id":175562,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1580743727,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"18760612911","product_id":100039001,"comment_content":"课堂讨论，使用一个标记flag作为该函数被调用国的标记，并给这个函数加锁，解决并发问题","like_count":4},{"had_liked":false,"id":175375,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1580699022,"is_pvip":false,"discussion_count":1,"race_medal":1,"score":"18760568206","product_id":100039001,"comment_content":"课后思考：如果 startRepeatedReport()被多次调用，那么会生成多个线程以fixed rate去请求然后输出结果到console上，一方面导致输出结果混乱，另一方面增加了系统的负担。<br>要解决该问题有个办法是再重构一下代码，示意如下（未测试），<br>```<br>private Future&lt;?&gt; future; <br>&#47;&#47;避免创建多个线程，也可以放在其他地方，如构造函数里<br>private Runnable runnable = new Runnable () {<br>       @Override      <br>       public void run() {        <br>           ....      <br>        } <br>};<br><br>public void startRepeatedReport(long periodInSeconds, long durationInSeconds) { <br>    future.cancel(true); &#47;&#47;每次调用就取消上一次的调用<br>    future = service.scheduleAtFixedRate(runnable, 0L, periodInSeconds, TimeUnit.SECONDS); &#47;&#47;重新开始<br>}<br>```","like_count":4,"discussions":[{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296069,"discussion_content":"不是取消，是就不该执行吧\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596443991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175668,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1580795934,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14465697822","product_id":100039001,"comment_content":"课堂讨论:<br><br><br><br>正常情况下，ConsoleReporter 的 startRepeatedReport() 函数只会被调用一次。但是，如果被多次调用，那就会存在问题。具体会有什么问题呢？又该如何解决呢？<br><br><br><br>startRepeatedReport()多次调用会导致SingleThreadExecutor排队执行任务.  从性能上, 浪费系统资源, 从需求上, 不符合方法设计的初衷. 解决方案之一是使用免锁容器存储唯一值, 作为任务已开始调度的flag, 在startRepeatedReport()方法判断: 如果任务已开始调度, 则直接return.","like_count":3},{"had_liked":false,"id":283162,"user_name":"Chloe","can_delete":false,"product_type":"c1","uid":1004953,"ip_address":"","ucode":"C4848ED5B35752","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/99/4bdadfd3.jpg","comment_is_top":false,"comment_ctime":1615601743,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10205536335","product_id":100039001,"comment_content":"我对“提供一些封装了默认依赖的构造函数” 的感受比较深刻，之前看一些源码，心里就打问号，为什么要一个封装了默认依赖的构造函数，原来是为了易用，灵活，扩展性还有易于测试。这回理解深刻了。","like_count":2},{"had_liked":false,"id":269985,"user_name":"ub8","can_delete":false,"product_type":"c1","uid":1481811,"ip_address":"","ucode":"0D937C3EAEB781","user_header":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","comment_is_top":false,"comment_ctime":1608867433,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10198802025","product_id":100039001,"comment_content":"要代码的小伙伴一看就是没仔细看过 王争 老师的其他课程，王争老师明确表示过不会提供课件代码 哈哈哈","like_count":2},{"had_liked":false,"id":204875,"user_name":"面向百度编程","can_delete":false,"product_type":"c1","uid":1732780,"ip_address":"","ucode":"8FE04A019D71D1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","comment_is_top":false,"comment_ctime":1586485845,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10176420437","product_id":100039001,"comment_content":"正常情况下，ConsoleReporter 的 startRepeatedReport() 函数只会被调用一次。但是，如果被多次调用，那就会存在问题。具体会有什么问题呢？又该如何解决呢？<br>答：因为没有加锁，所有线程都共享，如果多次调用，肯定会开辟多个线程去执行逻辑，这时会浪费cpu的性能。如果不是特别的具有实时行，我们可以用syschronized加把锁（毕竟性能也可以），或者可以用valitile flag = true;<br>if(占有资源) flag = false； 然后继续执行操作，执行完后 将 flag 又设置为true，这样就只能一个线程执行了<br>","like_count":2},{"had_liked":false,"id":187882,"user_name":"空白昵称","can_delete":false,"product_type":"c1","uid":1433815,"ip_address":"","ucode":"91F50CA25102AB","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/d7/744bd8c3.jpg","comment_is_top":false,"comment_ctime":1584264836,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10174199428","product_id":100039001,"comment_content":"关于大量数据读取到内存导致性能下降等问题，应该就是算法之美那里讲的堆排吧…… 两个课程举例有相关性，点个赞👍","like_count":2,"discussions":[{"author":{"id":2101988,"avatar":"https://static001.geekbang.org/account/avatar/00/20/12/e4/57ade29a.jpg","nickname":"dva","note":"","ucode":"EE27DAFCBF198D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393700,"discussion_content":"堆排序不太行，因为不知道总数量是多少","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631549280,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185767,"user_name":"饭粒","can_delete":false,"product_type":"c1","uid":1153455,"ip_address":"","ucode":"4C3220B0D43997","user_header":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","comment_is_top":false,"comment_ctime":1583677164,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10173611756","product_id":100039001,"comment_content":"这个案例很赞，要找时间手敲一遍。","like_count":2},{"had_liked":false,"id":175351,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1580685862,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10170620454","product_id":100039001,"comment_content":"沙发，打卡！一路跟进！","like_count":2},{"had_liked":false,"id":325037,"user_name":"....","can_delete":false,"product_type":"c1","uid":2859716,"ip_address":"","ucode":"A3D57E87F15227","user_header":"https://static001.geekbang.org/account/avatar/00/2b/a2/c4/11cf22de.jpg","comment_is_top":false,"comment_ctime":1638783968,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5933751264","product_id":100039001,"comment_content":"ScheduleReporter 类的 49行 会NPE吧<br>            List&lt;RequestStat&gt; statList = segmentStats.putIfAbsent(apiName, new ArrayList&lt;&gt;());<br>            statList.add(stat);","like_count":1},{"had_liked":false,"id":189763,"user_name":"Jessica","can_delete":false,"product_type":"c1","uid":1084877,"ip_address":"","ucode":"9FC7E9BD3FE9F1","user_header":"https://static001.geekbang.org/account/avatar/00/10/8d/cd/b6bdc1b2.jpg","comment_is_top":false,"comment_ctime":1584546695,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879513991","product_id":100039001,"comment_content":"今天解决生产问题到现在，明天补课","like_count":1},{"had_liked":false,"id":178291,"user_name":"z.l","can_delete":false,"product_type":"c1","uid":1181055,"ip_address":"","ucode":"805CC5784D3F76","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/7f/d35ab9a1.jpg","comment_is_top":false,"comment_ctime":1581652248,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5876619544","product_id":100039001,"comment_content":"思考题：用状态模式解决，实现方式有很多，volatile，原子类等等都可以","like_count":1},{"had_liked":false,"id":177679,"user_name":"L🚲🐱","can_delete":false,"product_type":"c1","uid":1577856,"ip_address":"","ucode":"08A012739614DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","comment_is_top":false,"comment_ctime":1581472747,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5876440043","product_id":100039001,"comment_content":"一路跟过来, 感觉吸收不是很好, 准备多花点时间好好研究下","like_count":1},{"had_liked":false,"id":356482,"user_name":"cccccc","can_delete":false,"product_type":"c1","uid":1205724,"ip_address":"广东","ucode":"BDEFB01B75EBC1","user_header":"https://static001.geekbang.org/account/avatar/00/12/65/dc/d0c58ce5.jpg","comment_is_top":false,"comment_ctime":1662359864,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1662359864","product_id":100039001,"comment_content":"分片统计的逻辑放在ScheduleReporter中是否不妥，可否增加一个专门处理分片统计逻辑的类","like_count":0},{"had_liked":false,"id":344537,"user_name":"Geek_7e0e83","can_delete":false,"product_type":"c1","uid":2142423,"ip_address":"","ucode":"554DEE2AAAE33C","user_header":"","comment_is_top":false,"comment_ctime":1651636667,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651636667","product_id":100039001,"comment_content":"在业务表现上会发生 重复更新统计。比如在A时间触发了一次 然后在B时间又触发一次函数调用。再经过periodSeconds之后 就会发生 A B 两次的统计更新 间隔缩短了。<br><br>可以通过volatile变量进行控制 轻量级的锁","like_count":0},{"had_liked":false,"id":300610,"user_name":"小川","can_delete":false,"product_type":"c1","uid":1242573,"ip_address":"","ucode":"D462222DDBB978","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/cd/3890be04.jpg","comment_is_top":false,"comment_ctime":1625244098,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625244098","product_id":100039001,"comment_content":"总结：<br><br>先从最基本的面向对象的思想，讲代码拆分到合适的类中。<br>依靠的是高内聚松耦合，单一职责等原则去评判类拆分是否合理。<br><br>做完第一部以后，开始考虑代码重复的问题，自下而上考虑是否可以抽象出公共流程，从而定义一个抽象类解决代码复用问题。<br><br>最后一部呢，开始抠细节，代码命名、注释、单元测试等等，完善好最终的代码。<br><br>个人认为，其中最重要一点就是《面向对象思维》，先把最简版的类建出来，可以先把功能都写到一个类或者方法中（只适用于非业务场景，因为这样可以避免无从下手的窘境），然后在基础面相对象，把里面的代码片段抽到方法中，继续抽象和提炼，从而提炼出一个新的类出来（View），这样不断的优化。","like_count":0},{"had_liked":false,"id":297767,"user_name":"李金鹏","can_delete":false,"product_type":"c1","uid":1445362,"ip_address":"","ucode":"8FCCA5B8BD8DDD","user_header":"https://static001.geekbang.org/account/avatar/00/16/0d/f2/3865fe28.jpg","comment_is_top":false,"comment_ctime":1623766775,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623766775","product_id":100039001,"comment_content":"占用内存过多","like_count":0},{"had_liked":false,"id":285143,"user_name":"渊จุ๊บ","can_delete":false,"product_type":"c1","uid":1530295,"ip_address":"","ucode":"E3A2C1E89EB576","user_header":"https://static001.geekbang.org/account/avatar/00/17/59/b7/9db9c657.jpg","comment_is_top":false,"comment_ctime":1616640901,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616640901","product_id":100039001,"comment_content":"ConsoleReporter 的 startRepeatedReport()函数调用，多次调用会运行多次数据查询和计算以及会在终端重复输出，会导致显示输出紊乱，内存开销过大等。我用的是golang语音编写的，找了一个线程池的包，将report任务丢给池后台执行，第二次调用ConsoleReporter 的 startRepeatedReport()时，先释放池中任务，重新定义report任务到池中，避免多个report任务执行","like_count":0},{"had_liked":false,"id":281018,"user_name":"沈康","can_delete":false,"product_type":"c1","uid":1611025,"ip_address":"","ucode":"02AFA50738AB8E","user_header":"https://static001.geekbang.org/account/avatar/00/18/95/11/eb431e52.jpg","comment_is_top":false,"comment_ctime":1614527072,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614527072","product_id":100039001,"comment_content":"ScheduleReporter 的30行好像缺少循环结束条件，<br>segmentStartTimeMillis += MAX_STAT_DURATION_IN_MILLIS;","like_count":0},{"had_liked":false,"id":274692,"user_name":"Gabriel","can_delete":false,"product_type":"c1","uid":1437358,"ip_address":"","ucode":"714772A93E93DC","user_header":"https://static001.geekbang.org/account/avatar/00/15/ee/ae/855b7e6e.jpg","comment_is_top":false,"comment_ctime":1611126784,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611126784","product_id":100039001,"comment_content":"nice，坚持","like_count":0},{"had_liked":false,"id":260011,"user_name":"林自","can_delete":false,"product_type":"c1","uid":2291119,"ip_address":"","ucode":"7E75C1BC9BEB7E","user_header":"","comment_is_top":false,"comment_ctime":1604907880,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1604907880","product_id":100039001,"comment_content":"如果是基于spring开发，在使用具体的reporter时，MetricsStorage，Aggregator，StatViewer这些参数如何注入呢","like_count":0},{"had_liked":false,"id":203674,"user_name":"learning","can_delete":false,"product_type":"c1","uid":1236953,"ip_address":"","ucode":"14CE94C24F9C87","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/d9/a90b2488.jpg","comment_is_top":false,"comment_ctime":1586253643,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1586253643","product_id":100039001,"comment_content":"重构后的EmailReporter应该不需要成员变量声明和构造函数那段代码了吧","like_count":0,"discussions":[{"author":{"id":1314724,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0f/a4/0b49469f.jpg","nickname":"木子00","note":"","ucode":"8F78CA722EB29B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278141,"discussion_content":"是的。可能是笔误吧。\n成员变量，父类已经有了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591154161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203086,"user_name":"咸鱼","can_delete":false,"product_type":"c1","uid":1179028,"ip_address":"","ucode":"5E79636DE48155","user_header":"https://static001.geekbang.org/account/avatar/00/11/fd/94/0247f945.jpg","comment_is_top":false,"comment_ctime":1586138111,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586138111","product_id":100039001,"comment_content":"应该可以看下无法多次启动一个线程之类的解决方式，一个私有成员变量 ，初始值为true，在第一启动后修改成false","like_count":0},{"had_liked":false,"id":187878,"user_name":"空白昵称","can_delete":false,"product_type":"c1","uid":1433815,"ip_address":"","ucode":"91F50CA25102AB","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/d7/744bd8c3.jpg","comment_is_top":false,"comment_ctime":1584264655,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584264655","product_id":100039001,"comment_content":"我有一个疑问：这里将两个reporter类继承一个基类，解决了代码复用问题。那么这个同样是否可以采用抽象接口来解决呢？哪一个更好一些？","like_count":0},{"had_liked":false,"id":185477,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1583590134,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1583590134","product_id":100039001,"comment_content":"java实现的话，可以使用volatile关键字加synchronized的来实现，下面是示范代码：<br>public class ThreadDuplicateTask implements Runnable {<br><br>    private static volatile boolean done = false;<br><br>    @SneakyThrows<br>    @Override<br>    public void run() {<br>        int time = new Random().nextInt(1000);<br>        Thread.sleep(time);<br>        if (!done) {<br>            synchronized (ThreadDuplicateTask.class) {<br>                System.out.println(Thread.currentThread().getName() + &quot;执行startRepeatedReport...&quot;);<br>                setDone();<br>            }<br>        } else {<br>            System.out.println(&quot;任务已执行&quot; + Thread.currentThread().getName() + &quot;略过&quot;);<br>        }<br>    }<br><br>    private static void setDone() {<br>        done = true;<br>    }<br><br>    public static void main(String[] args) {<br>        ThreadDuplicateTask threadDuplicateTask = new ThreadDuplicateTask();<br>        Thread threadOne = new Thread(threadDuplicateTask);<br>        Thread threadTwo = new Thread(threadDuplicateTask);<br>        threadOne.start();<br>        threadTwo.start();<br>    }<br>}<br>","like_count":0,"discussions":[{"author":{"id":2446981,"avatar":"https://static001.geekbang.org/account/avatar/00/25/56/85/6da913fa.jpg","nickname":"LIFE l=new LIFE()","note":"","ucode":"729BACA3B7FD42","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544004,"discussion_content":"if判断写在同步代码块里面就不需要声明volatile了，因为同步关键字会保证去总线取数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641378321,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184800,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1583407954,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583407954","product_id":100039001,"comment_content":"对于这个问题,显而易见的第一点就是会造成多次的大量计算,造成硬件资源压力增大,而且一般的大厂项目开发过程,是不会让直接new一个线程出来的,而是利用线程池去管理线程,从而限制在一个可控的范围内,所以非要异步的话,还是改为线程池吧","like_count":0},{"had_liked":false,"id":181500,"user_name":"jaryoung","can_delete":false,"product_type":"c1","uid":1077406,"ip_address":"","ucode":"6E72D107DB7E51","user_header":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","comment_is_top":false,"comment_ctime":1582552537,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582552537","product_id":100039001,"comment_content":"解决思路，增加锁：<br>  public void startRepeatedReport(long periodInSeconds, long durationInSeconds) {<br>    synchronized (runStatus){<br>      if (runStatus) {<br>        return;<br>      }<br>    }<br>....","like_count":0},{"had_liked":false,"id":181488,"user_name":"高源","can_delete":false,"product_type":"c1","uid":1048887,"ip_address":"","ucode":"751B41FD38EF7D","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/37/12e4c9c9.jpg","comment_is_top":false,"comment_ctime":1582551363,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582551363","product_id":100039001,"comment_content":"老师你举的例子非常棒，以前说有时间整理本课所有的讲课源代码，我去你的github上还是没有呢，我慢慢等待，讲的好我的记住要学会灵活运用","like_count":0},{"had_liked":false,"id":180853,"user_name":"DullBird","can_delete":false,"product_type":"c1","uid":1110494,"ip_address":"","ucode":"80E2FD5F9687CB","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/de/3ebcbb3f.jpg","comment_is_top":false,"comment_ctime":1582429030,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582429030","product_id":100039001,"comment_content":"多次调用会启动多余的线程，可以判断是否已经启动线程来决定是否直接跳过逻辑。","like_count":0},{"had_liked":false,"id":179796,"user_name":"刘大宇","can_delete":false,"product_type":"c1","uid":1200804,"ip_address":"","ucode":"A004F00DABBA62","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/a4/e9c39177.jpg","comment_is_top":false,"comment_ctime":1582101592,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582101592","product_id":100039001,"comment_content":"doStat()函数只是分批查出数据后，最后还是合并成一个大的List再求max或min。<br>不是应该分批求求max和min吗？","like_count":0},{"had_liked":false,"id":177689,"user_name":"Ken张云忠","can_delete":false,"product_type":"c1","uid":1134288,"ip_address":"","ucode":"D0BAC9FC17DE2B","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","comment_is_top":false,"comment_ctime":1581474665,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581474665","product_id":100039001,"comment_content":"正常情况下，ConsoleReporter 的 startRepeatedReport() 函数只会被调用一次。但是，如果被多次调用，那就会存在问题。具体会有什么问题呢？又该如何解决呢？<br>存在问题:一个线程内会有多个任务被提交顺序执行.<br>解决方式:在ConsoleReporter中添加ScheduledFuture&lt;?&gt; scheduledFuture属性,再在startRepeatedReport中添加一个非空逻辑处理,如果scheduledFuture非空就取消之前的任务.<br>代码:<br>if (scheduledFuture != null) {<br>    scheduledFuture.cancel(true);<br>}<br>scheduledFuture = executor.scheduleAtFixedRate(...);","like_count":0},{"had_liked":false,"id":177405,"user_name":"，","can_delete":false,"product_type":"c1","uid":1701867,"ip_address":"","ucode":"A5543C8DFEB198","user_header":"https://static001.geekbang.org/account/avatar/00/19/f7/eb/e7127bb8.jpg","comment_is_top":false,"comment_ctime":1581388821,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1581388821","product_id":100039001,"comment_content":"思考题:可以用定时任务框架+容器的方式来实现,EmailReporter,ConsoleReporter里只负责创建一个定时任务对象,存到一个Set容器里,定时任务的逻辑是轮询这个Set容器,并根据一定逻辑去展示,这样做的好处有三:<br>1.应该可以避免重复的统计和展示<br>2.避免了多线程不易管理的问题<br>3.定时任务与展示逻辑解耦,可以通过容器中的对象数量来判断运行情况,更方便测试<br>坏处是如果展示逻辑很复杂,或者容器里有很多对象,耗费很多时间去计算,那么有一些展示会有延迟","like_count":0,"discussions":[{"author":{"id":1629094,"avatar":"https://static001.geekbang.org/account/avatar/00/18/db/a6/60bf0220.jpg","nickname":"背道而驰","note":"","ucode":"953CFFE377E176","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219557,"discussion_content":"可以参考时间轮的设计 还能减少不必要的轮询","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585778690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177390,"user_name":"一名小学生","can_delete":false,"product_type":"c1","uid":1137292,"ip_address":"","ucode":"5C73082E6B6370","user_header":"https://static001.geekbang.org/account/avatar/00/11/5a/8c/1fec5fa2.jpg","comment_is_top":false,"comment_ctime":1581386720,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581386720","product_id":100039001,"comment_content":"打卡，跟着课程从最小型一步步完善这个小框架，这一模块终于结束了，感觉吸收的还不错，棒～","like_count":0,"discussions":[{"author":{"id":1220713,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a0/69/e42348a8.jpg","nickname":"李奇锋","note":"","ucode":"1A0A359D0530C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":355842,"discussion_content":"我倒是觉得降低复杂度才是关键目的，其他性质都是为其服务。\n\n只要代码不复杂，你就能理解它的逻辑，自然而然就能够维护好。\n\n以复用性为例，只要代码能复用，就意味着你需要记忆的内容/概念就减少，复杂度自然就低。\n\n以可扩展性为例，好的扩展自然不应该增加过多的复杂度。如果扩展功能需要添加过多的复杂度，那么就证明这个系统本身的可扩展性不佳。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1615479412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1264707,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4c/43/150c70c2.jpg","nickname":"陈松Plus","note":"","ucode":"0074BDECFA3D1D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363056,"discussion_content":"每个专栏总有课代表","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1617105267,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005574,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/58/06/6a9c089b.jpg","nickname":"Lee大树","note":"","ucode":"3C2012F6D21698","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325068,"discussion_content":"赞","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1605231174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1283461,"avatar":"https://static001.geekbang.org/account/avatar/00/13/95/85/15cd21c2.jpg","nickname":"杨锋","note":"","ucode":"85A7828A538FB0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284848,"discussion_content":"你就是那个科代表","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1592659765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1272047,"avatar":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","nickname":"Magic","note":"","ucode":"FD9CEDAA419EB0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308067,"discussion_content":"3why还有个高大上的名字-黄金圈法则","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600837049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1921287,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/51/07/b5a945b6.jpg","nickname":"Nick","note":"","ucode":"64BBE005890845","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":209255,"discussion_content":"总结的非常棒，关键是Why","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584623690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1203255,"avatar":"https://static001.geekbang.org/account/avatar/00/12/5c/37/de2649c3.jpg","nickname":"麦田守望者","note":"","ucode":"F4F0CCB787A420","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576824,"discussion_content":"高手","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655799818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2870321,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLE9hv64CEabxt76tQQcWDicx0sucpAApFvYoM8eXBViaJgz06EjcfJjiamSFWY9aAuxjILaPoiaa0lNw/132","nickname":"Soil","note":"","ucode":"3B353BC858B5AE","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557447,"discussion_content":"总结的很不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647825198,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2550743,"avatar":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","nickname":"if...else...","note":"","ucode":"D0565908C99695","race_medal":4,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376948,"discussion_content":"总结的很好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622435427,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2242904,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIHxTg3tYriaCXiccCf7xUl9QHibAhCMBKQ2oCicvgcuHCo4ULSguISXeHzxM9a8fFD7icfy3OgXibvUNxw/132","nickname":"Geek_9dbc25","note":"","ucode":"6CB31893173165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368843,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618843210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1098624,"avatar":"","nickname":"dream7519","note":"","ucode":"55E229FA55E15C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339468,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609682056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2400676,"avatar":"https://static001.geekbang.org/account/avatar/00/24/a1/a4/4def335a.jpg","nickname":"刘玉琪","note":"","ucode":"9CAFC96E725F12","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339186,"discussion_content":"棒，我抄个作业。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609557198,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2347137,"avatar":"https://static001.geekbang.org/account/avatar/00/23/d0/81/d5c8e46e.jpg","nickname":"snake","note":"","ucode":"47BFFE4D048156","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330878,"discussion_content":"已经收藏，总结的很好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606725819,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2347137,"avatar":"https://static001.geekbang.org/account/avatar/00/23/d0/81/d5c8e46e.jpg","nickname":"snake","note":"","ucode":"47BFFE4D048156","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330875,"discussion_content":"人才","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606724996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2323679,"avatar":"https://static001.geekbang.org/account/avatar/00/23/74/df/6c4c970c.jpg","nickname":"刘胜","note":"","ucode":"2ED796A94E1C8B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327557,"discussion_content":"课代表。总结真的很赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605861088,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1509295,"avatar":"https://static001.geekbang.org/account/avatar/00/17/07/af/d6215ca0.jpg","nickname":"智昊","note":"","ucode":"3F263C553B34F1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308105,"discussion_content":"课代表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600846920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1792214,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoiaP1gptuBzj3AXMpY8yLTIkpuarouOVzLde4636UJ7zAgnOEZibiaAIRVAicFaO64ftH45YOn1pD3VA/132","nickname":"Geek_35cfdd","note":"","ucode":"AD9615ABB4CA25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301179,"discussion_content":"关于封装是降低接口的复杂度么？我咋么感觉是降低使用者的复杂度。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598433777,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1272047,"avatar":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","nickname":"Magic","note":"","ucode":"FD9CEDAA419EB0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1792214,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoiaP1gptuBzj3AXMpY8yLTIkpuarouOVzLde4636UJ7zAgnOEZibiaAIRVAicFaO64ftH45YOn1pD3VA/132","nickname":"Geek_35cfdd","note":"","ucode":"AD9615ABB4CA25","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308068,"discussion_content":"应该是控制代码的复杂度","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600837070,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301179,"ip_address":""},"score":308068,"extra":""}]},{"author":{"id":1731082,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/6a/0a/45562844.jpg","nickname":"小玉家的猫","note":"","ucode":"ACA36922F22B69","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297820,"discussion_content":"封装，抽象，继承，多态为了代码可维护性！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597067412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1118111,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","nickname":"见南山","note":"","ucode":"6A8BB82B7573CA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285190,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592757308,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1398824,"avatar":"https://static001.geekbang.org/account/avatar/00/15/58/28/c86340ca.jpg","nickname":"达文西","note":"","ucode":"01C1063F23D634","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263990,"discussion_content":"666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589276902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1582951,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqrSGol9ss3nzh6Hqj2BYxBTlYbhSe72Og6Vx5CSb5iboibL9xZdWdYOpZzmN2ibj9EpboNDdRBSXSZw/132","nickname":"张张先生","note":"","ucode":"91B0E84B47AF05","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":246869,"discussion_content":"总结的好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587783367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1311947,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/xysT7OH4SrD4sv944ndDv5tnJOk5na37Gxd5owGWsE7ON7AVW0ibnYGNRoZd0ibLWhFVXLLjOB5QFxwjo0EGIkoQ/132","nickname":"雨下不停","note":"","ucode":"0893B9C249E48A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":229763,"discussion_content":"说得好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586688883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1104310,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d9/b6/4c498c17.jpg","nickname":"1620","note":"","ucode":"C9222A5CE4723C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":224687,"discussion_content":"留爪👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586323237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1096261,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ba/45/6722444c.jpg","nickname":"D","note":"","ucode":"248B90F19469A8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":216559,"discussion_content":"赞啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585464038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1622209,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c0/c1/414d5d1b.jpg","nickname":"_yh葱","note":"","ucode":"FA899711E91113","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":190258,"discussion_content":"总结的真好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582910572,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1037667,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d5/63/c4e2e579.jpg","nickname":"醉流年","note":"","ucode":"B8788E1B335322","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":181279,"discussion_content":"真的很赞👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582353784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1073216,"avatar":"https://static001.geekbang.org/account/avatar/00/10/60/40/d7e2e5b9.jpg","nickname":"宋江超","note":"","ucode":"565622DD8E36DF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":180540,"discussion_content":"黄金思维圈在面向对象的案例👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582296552,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1400962,"avatar":"https://static001.geekbang.org/account/avatar/00/15/60/82/9a43504b.jpg","nickname":"[耶]友超","note":"","ucode":"890572F77C3670","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":108030,"discussion_content":"大佬，收下我的👍👍👍👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577622195,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1310798,"avatar":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","nickname":"吴小智","note":"","ucode":"C7C9F58B5C9F7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84561,"discussion_content":"强了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576501113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1156383,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/OokHAy1fSOhBwwbbzud7seB5MEk4JezcGCS4Tzia7iaLOibCKgrj6PCN2b17bVAb224ygdLgjWVMnZsH18ibNoSTVA/132","nickname":"澜奏","note":"","ucode":"8682168E18B068","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":61018,"discussion_content":"这个总结真棒棒👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574769784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1199982,"avatar":"https://static001.geekbang.org/account/avatar/00/12/4f/6e/c8862883.jpg","nickname":"水雕歌","note":"","ucode":"280FAE14574299","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":58430,"discussion_content":"总结的很好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574675351,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1698258,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIx7FdRzUuQf4Fopr7DOXEHZyCFfH4GQViaqo7bymf1qaANcOvuEhHyTNwOOUFW7psxEeSQ5k9uXWw/132","nickname":"阿顺","note":"","ucode":"36F2AD6F980B11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55737,"discussion_content":"tql","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574393081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1429627,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJN64OCUT0Jp0h2Wiau9Os0o1WbwUeoq2QL0U2vZpib8ozPxo0XDiaPM9xcKfbkoBL24ztEHelxPIMVg/132","nickname":"Kevin","note":"","ucode":"9DFFD6E3960CF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53102,"discussion_content":"人均大师水平","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574132754,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1443365,"avatar":"https://static001.geekbang.org/account/avatar/00/16/06/25/5461385f.jpg","nickname":"学无止境0033","note":"","ucode":"6332DA0B9FF989","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52394,"discussion_content":"很赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574047011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015483,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","nickname":"程序员小跃","note":"","ucode":"25BB96E0791A60","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51541,"discussion_content":"总结的很赞，我要把这个收藏起来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573894918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180657,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1582359745,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"315114972353","product_id":100039001,"comment_content":"设计模式_40:<br># 作业<br><br>导致多个线程的重复统计。<br>办法：加入进程内的全局变量(注意多线程同步问题)。<br><br># 感想<br><br>我个人是Android工程师，客户端的开发默认就要思考一个问题：方法重复调用时(如多次点击某个按钮等)逻辑是否还正常。<br><br>25，26，39，40这四节课边听边读反复了好几遍了，因为目的是掌握该掌握的东西，而不是简单地打个卡，所以整个春节期间就卡在这四节课的重复中了，不停地循环听。。。<br><br>也有好处：我反倒对这几节内容非常熟悉了，有两点感受较深：<br>1&gt; 方法论：分清楚 *功能性需求* 与 *非功能型需求*<br>\t之前是想到什么注意什么，往往做不到穷举。<br><br>2&gt; 一步一步地重构，其实解决的是自信问题：<br>\t做事要先解决思想问题，也就是心理问题：<br>\t- 没有人能够一步到位地完美解决问题，优秀的代码是演进的，也就是说，代码结构不完美的状态是跳不过去的。<br>\t- 我们始终聚焦在解决问题上，代码有问题非常正常。<br>\t- 我们要带着成就感不断重构代码，而不是带着对自己否定的愧疚感，这非常重要。<br>\t- 成就感让你追求卓越，愧疚感只是让你不想犯错(而这是做不到的)。","like_count":74,"discussions":[{"author":{"id":1948762,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/bc/5a/855160ca.jpg","nickname":"锋","note":"","ucode":"61A3ACB1D14CAF","race_medal":2,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373499,"discussion_content":"好难理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620745585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1131128,"avatar":"https://static001.geekbang.org/account/avatar/00/11/42/78/7ba89c75.jpg","nickname":"RedDevil","note":"","ucode":"F8F5DC209BB3B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312339,"discussion_content":"兄弟，同道中人","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602667165,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175485,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1580732797,"is_pvip":true,"discussion_count":4,"race_medal":0,"score":"70300209533","product_id":100039001,"comment_content":"思考题：startRepeatedReport()多次调用，会启动多个线程，每个线程都会执行统计和输出工作。<br>想了一种简单的实现方式，将runnable做为成员变量，第一次调用startRepeatedReport()时初始化，若多次调用，判空，返回。<br>  public void startRepeatedReport(long periodInSeconds, long durationInSeconds) {<br>    if (runnable != null) {<br>      System.out.println(&quot;duplicate calls!&quot;);<br>      return;<br>    }<br>    runnable = () -&gt; {<br>      long durationInMillis = durationInSeconds * 1000;<br>      long endTimeInMillis = System.currentTimeMillis();<br>      long startTimeInMillis = endTimeInMillis - durationInMillis;<br>      doReport(startTimeInMillis, endTimeInMillis);<br>    };<br>    executor.scheduleAtFixedRate(runnable, 0, periodInSeconds, TimeUnit.SECONDS);<br>  }<br>代码放在了：https:&#47;&#47;github.com&#47;gdhucoder&#47;Algorithms4&#47;tree&#47;master&#47;designpattern&#47;u40","like_count":16,"discussions":[{"author":{"id":1330141,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4b/dd/41614582.jpg","nickname":"HomeyLiu","note":"","ucode":"EF4CCB92C369B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536015,"discussion_content":"你这有问题, 多线程,还是多次打印,简单直接的就用 信号量,数量只有1, ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638630165,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296068,"discussion_content":"增加一个成员变量，同步控制，最轻量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596443935,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1396741,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/05/90f1a14e.jpg","nickname":"JUNLONG","note":"","ucode":"15C3E0B27E081C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283828,"discussion_content":"这个应该用单例模式吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592379013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181055,"avatar":"https://static001.geekbang.org/account/avatar/00/12/05/7f/d35ab9a1.jpg","nickname":"z.l","note":"","ucode":"805CC5784D3F76","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":169882,"discussion_content":"还是有问题，多线程不安全","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581652064,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175617,"user_name":"Andy","can_delete":false,"product_type":"c1","uid":1615348,"ip_address":"","ucode":"7414B2E60C4AD5","user_header":"https://static001.geekbang.org/account/avatar/00/18/a5/f4/de2d074e.jpg","comment_is_top":false,"comment_ctime":1580783258,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"61710325402","product_id":100039001,"comment_content":"老师能提供课程代码吗？","like_count":14},{"had_liked":false,"id":175554,"user_name":"平风造雨","can_delete":false,"product_type":"c1","uid":1014349,"ip_address":"","ucode":"F9EE4704F31E22","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/4d/b0228a1a.jpg","comment_is_top":false,"comment_ctime":1580742564,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"48825382820","product_id":100039001,"comment_content":"调用多次可以通过多线程共享的状态变量来解决，CAS或者加锁进行状态的变更。","like_count":12},{"had_liked":false,"id":175397,"user_name":"undefined","can_delete":false,"product_type":"c1","uid":1587803,"ip_address":"","ucode":"867405CA5A9FB7","user_header":"https://static001.geekbang.org/account/avatar/00/18/3a/5b/ce1724ca.jpg","comment_is_top":false,"comment_ctime":1580705263,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31645476335","product_id":100039001,"comment_content":"深入浅出，过瘾。","like_count":7},{"had_liked":false,"id":175396,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1580705249,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"27350509025","product_id":100039001,"comment_content":"先回答问题：<br>1.会导致多余线程做多余的统计和展示。因为每次调用都会起一个异步线程输出统计数据到控制台。这样既会带来额外的性能开销，又会导致统计信息不易阅读。<br><br>2.在ConsoleReporter内部维护一个可视字段 started。然后在方法执行时，优先判断该字段是否已经变为true。如果是则不再往下执行。也算是保证该函数的幂等性。<br><br>个人疑问：<br>1.怎么做到这样分步展示重构过程的？我现在写，基本一边写就一边重构，停手也就差不多到合适的质量了。刻意要展示重构手法，展示的知识点会有很多疏漏，并无法做到这样一步一步的展示（下意识一步到位，并不知道怎么退到不好的代码结构）。<br><br>2.能理解栏主尽量不依赖任何框架的初衷。但对于java，spring其实才是标准，感觉是不是基于spring框架来写demo还好点？ 我现在比较喜欢让代码依赖spring框架来实现，感觉这样会显得优雅一些。栏主怎么看？<br><br>","like_count":6,"discussions":[{"author":{"id":1457464,"avatar":"https://static001.geekbang.org/account/avatar/00/16/3d/38/6f02a4b9.jpg","nickname":"your problem？","note":"","ucode":"6E096E7958CFD7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":160383,"discussion_content":"我个人觉得还是不要依赖于Spring好，虽然我曾经是后台，也能看懂，但是这个设计模式专栏本身就是跟侧重程序设计的方法，本身使用Java语言就已经对不同的风格程序员存在一定的偏差，还用Spring的话非常不合适的","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1580797675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1337598,"avatar":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","nickname":"岁月","note":"","ucode":"29A2A2BC3C4FE4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1457464,"avatar":"https://static001.geekbang.org/account/avatar/00/16/3d/38/6f02a4b9.jpg","nickname":"your problem？","note":"","ucode":"6E096E7958CFD7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":176021,"discussion_content":"说的非常好, 我本身就不是写java的...再弄个spring的话, 这真是不合适了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582015447,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":160383,"ip_address":""},"score":176021,"extra":""}]},{"author":{"id":1133947,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIaOAxRlZjFkGfRBn420LuAcyWkMrpq5iafGdqthX5icJPjql0ibZOAdafaqbfvw4ZpVzDmsaYglVXDw/132","nickname":"唐朝农民","note":"","ucode":"6F8F43C6652225","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":159656,"discussion_content":"要我等非Java系怎么办","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1580721236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1179565,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ff/ad/5020a8c5.jpg","nickname":"Farewell丶","note":"","ucode":"A0D69893C5375C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":160338,"discussion_content":"Spring本身现在依赖很多，最后的执行包会比较大如果依赖的话。对于一个类库包，而不是一个应用程序，对自己类库最后形成的依赖程序包的大小也要做一个考量。另外如果使用了spring，那么可能造成应用程序使用的同依赖版本兼容问题，考虑的事情也就更多了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1580790283,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188222,"avatar":"https://static001.geekbang.org/account/avatar/00/12/21/7e/fb725950.jpg","nickname":"罗 乾 林","note":"","ucode":"D0406F95176ABA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":160838,"discussion_content":"利用框架，而不迷信框架，原理和思想重要。框架也许还会限制我们进步","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580829644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175356,"user_name":"高源","can_delete":false,"product_type":"c1","uid":1048887,"ip_address":"","ucode":"751B41FD38EF7D","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/37/12e4c9c9.jpg","comment_is_top":false,"comment_ctime":1580689164,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"27350492940","product_id":100039001,"comment_content":"老师39,40课完整源代码可以提供下吗，我准备好好研究学习下","like_count":6,"discussions":[{"author":{"id":3178447,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Pw2K9YovHNA4UddNibv42gwtJTiabiaVwEZ7fmrb2IyhF5k0nXMiaTpWUc1uib49XaKsKc7CVvnPcHvE7d0FE5F28dw/132","nickname":"Geek_17f801","note":"","ucode":"5EB01D36BB2C18","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588808,"discussion_content":"哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664118482,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2789067,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/8e/cb/1efcaf20.jpg","nickname":"Justway","note":"","ucode":"75966B5533C872","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586190,"discussion_content":"真想好好研究学习就自己敲吧老弟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662026680,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"重庆"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":177813,"discussion_content":"老师都是手敲代码，你居然懒的写","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582122071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184418,"user_name":"请叫我和尚","can_delete":false,"product_type":"c1","uid":1703256,"ip_address":"","ucode":"33A8A1CDA103F9","user_header":"https://static001.geekbang.org/account/avatar/00/19/fd/58/1af629c7.jpg","comment_is_top":false,"comment_ctime":1583311327,"is_pvip":false,"discussion_count":1,"race_medal":1,"score":"23058147807","product_id":100039001,"comment_content":"这两篇实战对自己的感觉就是越来越懵，可能还需要多读读，也不知道是不是跟自己的项目做的很少有原因，前面的理论都还能消化","like_count":5,"discussions":[{"author":{"id":3015503,"avatar":"","nickname":"Geek_08a0f7","note":"","ucode":"C2D78F6B714B88","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578048,"discussion_content":"同上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656487647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":189578,"user_name":"Q罗","can_delete":false,"product_type":"c1","uid":1792098,"ip_address":"","ucode":"E797378F4DA1F4","user_header":"https://static001.geekbang.org/account/avatar/00/1b/58/62/346dd248.jpg","comment_is_top":false,"comment_ctime":1584530785,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18764399969","product_id":100039001,"comment_content":"终于进去到期待已久的设计模式了","like_count":4},{"had_liked":false,"id":175562,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1580743727,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"18760612911","product_id":100039001,"comment_content":"课堂讨论，使用一个标记flag作为该函数被调用国的标记，并给这个函数加锁，解决并发问题","like_count":4},{"had_liked":false,"id":175375,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1580699022,"is_pvip":false,"discussion_count":1,"race_medal":1,"score":"18760568206","product_id":100039001,"comment_content":"课后思考：如果 startRepeatedReport()被多次调用，那么会生成多个线程以fixed rate去请求然后输出结果到console上，一方面导致输出结果混乱，另一方面增加了系统的负担。<br>要解决该问题有个办法是再重构一下代码，示意如下（未测试），<br>```<br>private Future&lt;?&gt; future; <br>&#47;&#47;避免创建多个线程，也可以放在其他地方，如构造函数里<br>private Runnable runnable = new Runnable () {<br>       @Override      <br>       public void run() {        <br>           ....      <br>        } <br>};<br><br>public void startRepeatedReport(long periodInSeconds, long durationInSeconds) { <br>    future.cancel(true); &#47;&#47;每次调用就取消上一次的调用<br>    future = service.scheduleAtFixedRate(runnable, 0L, periodInSeconds, TimeUnit.SECONDS); &#47;&#47;重新开始<br>}<br>```","like_count":4,"discussions":[{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296069,"discussion_content":"不是取消，是就不该执行吧\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596443991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175668,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1580795934,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14465697822","product_id":100039001,"comment_content":"课堂讨论:<br><br><br><br>正常情况下，ConsoleReporter 的 startRepeatedReport() 函数只会被调用一次。但是，如果被多次调用，那就会存在问题。具体会有什么问题呢？又该如何解决呢？<br><br><br><br>startRepeatedReport()多次调用会导致SingleThreadExecutor排队执行任务.  从性能上, 浪费系统资源, 从需求上, 不符合方法设计的初衷. 解决方案之一是使用免锁容器存储唯一值, 作为任务已开始调度的flag, 在startRepeatedReport()方法判断: 如果任务已开始调度, 则直接return.","like_count":3},{"had_liked":false,"id":283162,"user_name":"Chloe","can_delete":false,"product_type":"c1","uid":1004953,"ip_address":"","ucode":"C4848ED5B35752","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/99/4bdadfd3.jpg","comment_is_top":false,"comment_ctime":1615601743,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10205536335","product_id":100039001,"comment_content":"我对“提供一些封装了默认依赖的构造函数” 的感受比较深刻，之前看一些源码，心里就打问号，为什么要一个封装了默认依赖的构造函数，原来是为了易用，灵活，扩展性还有易于测试。这回理解深刻了。","like_count":2},{"had_liked":false,"id":269985,"user_name":"ub8","can_delete":false,"product_type":"c1","uid":1481811,"ip_address":"","ucode":"0D937C3EAEB781","user_header":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","comment_is_top":false,"comment_ctime":1608867433,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10198802025","product_id":100039001,"comment_content":"要代码的小伙伴一看就是没仔细看过 王争 老师的其他课程，王争老师明确表示过不会提供课件代码 哈哈哈","like_count":2},{"had_liked":false,"id":204875,"user_name":"面向百度编程","can_delete":false,"product_type":"c1","uid":1732780,"ip_address":"","ucode":"8FE04A019D71D1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","comment_is_top":false,"comment_ctime":1586485845,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10176420437","product_id":100039001,"comment_content":"正常情况下，ConsoleReporter 的 startRepeatedReport() 函数只会被调用一次。但是，如果被多次调用，那就会存在问题。具体会有什么问题呢？又该如何解决呢？<br>答：因为没有加锁，所有线程都共享，如果多次调用，肯定会开辟多个线程去执行逻辑，这时会浪费cpu的性能。如果不是特别的具有实时行，我们可以用syschronized加把锁（毕竟性能也可以），或者可以用valitile flag = true;<br>if(占有资源) flag = false； 然后继续执行操作，执行完后 将 flag 又设置为true，这样就只能一个线程执行了<br>","like_count":2},{"had_liked":false,"id":187882,"user_name":"空白昵称","can_delete":false,"product_type":"c1","uid":1433815,"ip_address":"","ucode":"91F50CA25102AB","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/d7/744bd8c3.jpg","comment_is_top":false,"comment_ctime":1584264836,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10174199428","product_id":100039001,"comment_content":"关于大量数据读取到内存导致性能下降等问题，应该就是算法之美那里讲的堆排吧…… 两个课程举例有相关性，点个赞👍","like_count":2,"discussions":[{"author":{"id":2101988,"avatar":"https://static001.geekbang.org/account/avatar/00/20/12/e4/57ade29a.jpg","nickname":"dva","note":"","ucode":"EE27DAFCBF198D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393700,"discussion_content":"堆排序不太行，因为不知道总数量是多少","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631549280,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185767,"user_name":"饭粒","can_delete":false,"product_type":"c1","uid":1153455,"ip_address":"","ucode":"4C3220B0D43997","user_header":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","comment_is_top":false,"comment_ctime":1583677164,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10173611756","product_id":100039001,"comment_content":"这个案例很赞，要找时间手敲一遍。","like_count":2},{"had_liked":false,"id":175351,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1580685862,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10170620454","product_id":100039001,"comment_content":"沙发，打卡！一路跟进！","like_count":2},{"had_liked":false,"id":325037,"user_name":"....","can_delete":false,"product_type":"c1","uid":2859716,"ip_address":"","ucode":"A3D57E87F15227","user_header":"https://static001.geekbang.org/account/avatar/00/2b/a2/c4/11cf22de.jpg","comment_is_top":false,"comment_ctime":1638783968,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5933751264","product_id":100039001,"comment_content":"ScheduleReporter 类的 49行 会NPE吧<br>            List&lt;RequestStat&gt; statList = segmentStats.putIfAbsent(apiName, new ArrayList&lt;&gt;());<br>            statList.add(stat);","like_count":1},{"had_liked":false,"id":189763,"user_name":"Jessica","can_delete":false,"product_type":"c1","uid":1084877,"ip_address":"","ucode":"9FC7E9BD3FE9F1","user_header":"https://static001.geekbang.org/account/avatar/00/10/8d/cd/b6bdc1b2.jpg","comment_is_top":false,"comment_ctime":1584546695,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879513991","product_id":100039001,"comment_content":"今天解决生产问题到现在，明天补课","like_count":1},{"had_liked":false,"id":178291,"user_name":"z.l","can_delete":false,"product_type":"c1","uid":1181055,"ip_address":"","ucode":"805CC5784D3F76","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/7f/d35ab9a1.jpg","comment_is_top":false,"comment_ctime":1581652248,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5876619544","product_id":100039001,"comment_content":"思考题：用状态模式解决，实现方式有很多，volatile，原子类等等都可以","like_count":1},{"had_liked":false,"id":177679,"user_name":"L🚲🐱","can_delete":false,"product_type":"c1","uid":1577856,"ip_address":"","ucode":"08A012739614DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","comment_is_top":false,"comment_ctime":1581472747,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5876440043","product_id":100039001,"comment_content":"一路跟过来, 感觉吸收不是很好, 准备多花点时间好好研究下","like_count":1},{"had_liked":false,"id":356482,"user_name":"cccccc","can_delete":false,"product_type":"c1","uid":1205724,"ip_address":"广东","ucode":"BDEFB01B75EBC1","user_header":"https://static001.geekbang.org/account/avatar/00/12/65/dc/d0c58ce5.jpg","comment_is_top":false,"comment_ctime":1662359864,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1662359864","product_id":100039001,"comment_content":"分片统计的逻辑放在ScheduleReporter中是否不妥，可否增加一个专门处理分片统计逻辑的类","like_count":0},{"had_liked":false,"id":344537,"user_name":"Geek_7e0e83","can_delete":false,"product_type":"c1","uid":2142423,"ip_address":"","ucode":"554DEE2AAAE33C","user_header":"","comment_is_top":false,"comment_ctime":1651636667,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651636667","product_id":100039001,"comment_content":"在业务表现上会发生 重复更新统计。比如在A时间触发了一次 然后在B时间又触发一次函数调用。再经过periodSeconds之后 就会发生 A B 两次的统计更新 间隔缩短了。<br><br>可以通过volatile变量进行控制 轻量级的锁","like_count":0},{"had_liked":false,"id":300610,"user_name":"小川","can_delete":false,"product_type":"c1","uid":1242573,"ip_address":"","ucode":"D462222DDBB978","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/cd/3890be04.jpg","comment_is_top":false,"comment_ctime":1625244098,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625244098","product_id":100039001,"comment_content":"总结：<br><br>先从最基本的面向对象的思想，讲代码拆分到合适的类中。<br>依靠的是高内聚松耦合，单一职责等原则去评判类拆分是否合理。<br><br>做完第一部以后，开始考虑代码重复的问题，自下而上考虑是否可以抽象出公共流程，从而定义一个抽象类解决代码复用问题。<br><br>最后一部呢，开始抠细节，代码命名、注释、单元测试等等，完善好最终的代码。<br><br>个人认为，其中最重要一点就是《面向对象思维》，先把最简版的类建出来，可以先把功能都写到一个类或者方法中（只适用于非业务场景，因为这样可以避免无从下手的窘境），然后在基础面相对象，把里面的代码片段抽到方法中，继续抽象和提炼，从而提炼出一个新的类出来（View），这样不断的优化。","like_count":0},{"had_liked":false,"id":297767,"user_name":"李金鹏","can_delete":false,"product_type":"c1","uid":1445362,"ip_address":"","ucode":"8FCCA5B8BD8DDD","user_header":"https://static001.geekbang.org/account/avatar/00/16/0d/f2/3865fe28.jpg","comment_is_top":false,"comment_ctime":1623766775,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623766775","product_id":100039001,"comment_content":"占用内存过多","like_count":0},{"had_liked":false,"id":285143,"user_name":"渊จุ๊บ","can_delete":false,"product_type":"c1","uid":1530295,"ip_address":"","ucode":"E3A2C1E89EB576","user_header":"https://static001.geekbang.org/account/avatar/00/17/59/b7/9db9c657.jpg","comment_is_top":false,"comment_ctime":1616640901,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616640901","product_id":100039001,"comment_content":"ConsoleReporter 的 startRepeatedReport()函数调用，多次调用会运行多次数据查询和计算以及会在终端重复输出，会导致显示输出紊乱，内存开销过大等。我用的是golang语音编写的，找了一个线程池的包，将report任务丢给池后台执行，第二次调用ConsoleReporter 的 startRepeatedReport()时，先释放池中任务，重新定义report任务到池中，避免多个report任务执行","like_count":0},{"had_liked":false,"id":281018,"user_name":"沈康","can_delete":false,"product_type":"c1","uid":1611025,"ip_address":"","ucode":"02AFA50738AB8E","user_header":"https://static001.geekbang.org/account/avatar/00/18/95/11/eb431e52.jpg","comment_is_top":false,"comment_ctime":1614527072,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614527072","product_id":100039001,"comment_content":"ScheduleReporter 的30行好像缺少循环结束条件，<br>segmentStartTimeMillis += MAX_STAT_DURATION_IN_MILLIS;","like_count":0},{"had_liked":false,"id":274692,"user_name":"Gabriel","can_delete":false,"product_type":"c1","uid":1437358,"ip_address":"","ucode":"714772A93E93DC","user_header":"https://static001.geekbang.org/account/avatar/00/15/ee/ae/855b7e6e.jpg","comment_is_top":false,"comment_ctime":1611126784,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611126784","product_id":100039001,"comment_content":"nice，坚持","like_count":0},{"had_liked":false,"id":260011,"user_name":"林自","can_delete":false,"product_type":"c1","uid":2291119,"ip_address":"","ucode":"7E75C1BC9BEB7E","user_header":"","comment_is_top":false,"comment_ctime":1604907880,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1604907880","product_id":100039001,"comment_content":"如果是基于spring开发，在使用具体的reporter时，MetricsStorage，Aggregator，StatViewer这些参数如何注入呢","like_count":0,"discussions":[{"author":{"id":2558083,"avatar":"","nickname":"Geek_d131e9","note":"","ucode":"AB158FF9703F7F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367822,"discussion_content":"我也很想知道...老哥 你现在会了吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618476093,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203674,"user_name":"learning","can_delete":false,"product_type":"c1","uid":1236953,"ip_address":"","ucode":"14CE94C24F9C87","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/d9/a90b2488.jpg","comment_is_top":false,"comment_ctime":1586253643,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1586253643","product_id":100039001,"comment_content":"重构后的EmailReporter应该不需要成员变量声明和构造函数那段代码了吧","like_count":0,"discussions":[{"author":{"id":1314724,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0f/a4/0b49469f.jpg","nickname":"木子00","note":"","ucode":"8F78CA722EB29B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278141,"discussion_content":"是的。可能是笔误吧。\n成员变量，父类已经有了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591154161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203086,"user_name":"咸鱼","can_delete":false,"product_type":"c1","uid":1179028,"ip_address":"","ucode":"5E79636DE48155","user_header":"https://static001.geekbang.org/account/avatar/00/11/fd/94/0247f945.jpg","comment_is_top":false,"comment_ctime":1586138111,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586138111","product_id":100039001,"comment_content":"应该可以看下无法多次启动一个线程之类的解决方式，一个私有成员变量 ，初始值为true，在第一启动后修改成false","like_count":0},{"had_liked":false,"id":187878,"user_name":"空白昵称","can_delete":false,"product_type":"c1","uid":1433815,"ip_address":"","ucode":"91F50CA25102AB","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/d7/744bd8c3.jpg","comment_is_top":false,"comment_ctime":1584264655,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584264655","product_id":100039001,"comment_content":"我有一个疑问：这里将两个reporter类继承一个基类，解决了代码复用问题。那么这个同样是否可以采用抽象接口来解决呢？哪一个更好一些？","like_count":0},{"had_liked":false,"id":185477,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1583590134,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1583590134","product_id":100039001,"comment_content":"java实现的话，可以使用volatile关键字加synchronized的来实现，下面是示范代码：<br>public class ThreadDuplicateTask implements Runnable {<br><br>    private static volatile boolean done = false;<br><br>    @SneakyThrows<br>    @Override<br>    public void run() {<br>        int time = new Random().nextInt(1000);<br>        Thread.sleep(time);<br>        if (!done) {<br>            synchronized (ThreadDuplicateTask.class) {<br>                System.out.println(Thread.currentThread().getName() + &quot;执行startRepeatedReport...&quot;);<br>                setDone();<br>            }<br>        } else {<br>            System.out.println(&quot;任务已执行&quot; + Thread.currentThread().getName() + &quot;略过&quot;);<br>        }<br>    }<br><br>    private static void setDone() {<br>        done = true;<br>    }<br><br>    public static void main(String[] args) {<br>        ThreadDuplicateTask threadDuplicateTask = new ThreadDuplicateTask();<br>        Thread threadOne = new Thread(threadDuplicateTask);<br>        Thread threadTwo = new Thread(threadDuplicateTask);<br>        threadOne.start();<br>        threadTwo.start();<br>    }<br>}<br>","like_count":0,"discussions":[{"author":{"id":2446981,"avatar":"https://static001.geekbang.org/account/avatar/00/25/56/85/6da913fa.jpg","nickname":"LIFE l=new LIFE()","note":"","ucode":"729BACA3B7FD42","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544004,"discussion_content":"if判断写在同步代码块里面就不需要声明volatile了，因为同步关键字会保证去总线取数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641378321,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184800,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1583407954,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583407954","product_id":100039001,"comment_content":"对于这个问题,显而易见的第一点就是会造成多次的大量计算,造成硬件资源压力增大,而且一般的大厂项目开发过程,是不会让直接new一个线程出来的,而是利用线程池去管理线程,从而限制在一个可控的范围内,所以非要异步的话,还是改为线程池吧","like_count":0},{"had_liked":false,"id":181500,"user_name":"jaryoung","can_delete":false,"product_type":"c1","uid":1077406,"ip_address":"","ucode":"6E72D107DB7E51","user_header":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","comment_is_top":false,"comment_ctime":1582552537,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582552537","product_id":100039001,"comment_content":"解决思路，增加锁：<br>  public void startRepeatedReport(long periodInSeconds, long durationInSeconds) {<br>    synchronized (runStatus){<br>      if (runStatus) {<br>        return;<br>      }<br>    }<br>....","like_count":0},{"had_liked":false,"id":181488,"user_name":"高源","can_delete":false,"product_type":"c1","uid":1048887,"ip_address":"","ucode":"751B41FD38EF7D","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/37/12e4c9c9.jpg","comment_is_top":false,"comment_ctime":1582551363,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582551363","product_id":100039001,"comment_content":"老师你举的例子非常棒，以前说有时间整理本课所有的讲课源代码，我去你的github上还是没有呢，我慢慢等待，讲的好我的记住要学会灵活运用","like_count":0},{"had_liked":false,"id":180853,"user_name":"DullBird","can_delete":false,"product_type":"c1","uid":1110494,"ip_address":"","ucode":"80E2FD5F9687CB","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/de/3ebcbb3f.jpg","comment_is_top":false,"comment_ctime":1582429030,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582429030","product_id":100039001,"comment_content":"多次调用会启动多余的线程，可以判断是否已经启动线程来决定是否直接跳过逻辑。","like_count":0},{"had_liked":false,"id":179796,"user_name":"刘大宇","can_delete":false,"product_type":"c1","uid":1200804,"ip_address":"","ucode":"A004F00DABBA62","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/a4/e9c39177.jpg","comment_is_top":false,"comment_ctime":1582101592,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582101592","product_id":100039001,"comment_content":"doStat()函数只是分批查出数据后，最后还是合并成一个大的List再求max或min。<br>不是应该分批求求max和min吗？","like_count":0},{"had_liked":false,"id":177689,"user_name":"Ken张云忠","can_delete":false,"product_type":"c1","uid":1134288,"ip_address":"","ucode":"D0BAC9FC17DE2B","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","comment_is_top":false,"comment_ctime":1581474665,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581474665","product_id":100039001,"comment_content":"正常情况下，ConsoleReporter 的 startRepeatedReport() 函数只会被调用一次。但是，如果被多次调用，那就会存在问题。具体会有什么问题呢？又该如何解决呢？<br>存在问题:一个线程内会有多个任务被提交顺序执行.<br>解决方式:在ConsoleReporter中添加ScheduledFuture&lt;?&gt; scheduledFuture属性,再在startRepeatedReport中添加一个非空逻辑处理,如果scheduledFuture非空就取消之前的任务.<br>代码:<br>if (scheduledFuture != null) {<br>    scheduledFuture.cancel(true);<br>}<br>scheduledFuture = executor.scheduleAtFixedRate(...);","like_count":0},{"had_liked":false,"id":177405,"user_name":"，","can_delete":false,"product_type":"c1","uid":1701867,"ip_address":"","ucode":"A5543C8DFEB198","user_header":"https://static001.geekbang.org/account/avatar/00/19/f7/eb/e7127bb8.jpg","comment_is_top":false,"comment_ctime":1581388821,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1581388821","product_id":100039001,"comment_content":"思考题:可以用定时任务框架+容器的方式来实现,EmailReporter,ConsoleReporter里只负责创建一个定时任务对象,存到一个Set容器里,定时任务的逻辑是轮询这个Set容器,并根据一定逻辑去展示,这样做的好处有三:<br>1.应该可以避免重复的统计和展示<br>2.避免了多线程不易管理的问题<br>3.定时任务与展示逻辑解耦,可以通过容器中的对象数量来判断运行情况,更方便测试<br>坏处是如果展示逻辑很复杂,或者容器里有很多对象,耗费很多时间去计算,那么有一些展示会有延迟","like_count":0},{"had_liked":false,"id":177390,"user_name":"一名小学生","can_delete":false,"product_type":"c1","uid":1137292,"ip_address":"","ucode":"5C73082E6B6370","user_header":"https://static001.geekbang.org/account/avatar/00/11/5a/8c/1fec5fa2.jpg","comment_is_top":false,"comment_ctime":1581386720,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581386720","product_id":100039001,"comment_content":"打卡，跟着课程从最小型一步步完善这个小框架，这一模块终于结束了，感觉吸收的还不错，棒～","like_count":0}]}