{"id":185899,"title":"18 | 应用可变模板和tuple的编译期技巧","content":"<p>你好，我是吴咏炜。</p><p>今天我们讲一个特殊的专题，如何使用可变模板和 tuple 来完成一些常见的功能，尤其是编译期计算。</p><h2>可变模板</h2><p>可变模板 <span class=\"orange\">[1]</span> 是 C++11 引入的一项新功能，使我们可以在模板参数里表达不定个数和类型的参数。从实际的角度，它有两个明显的用途：</p><ul>\n<li>用于在通用工具模板中转发参数到另外一个函数</li>\n<li>用于在递归的模板中表达通用的情况（另外会有至少一个模板特化来表达边界情况）</li>\n</ul><p>我们下面就来分开讨论一下。</p><h3>转发用法</h3><p>以标准库里的 <code>make_unique</code> 为例，它的定义差不多是下面这个样子：</p><pre><code class=\"language-c++\">template &lt;typename T,\n          typename... Args&gt;\ninline unique_ptr&lt;T&gt;\nmake_unique(Args&amp;&amp;... args)\n{\n  return unique_ptr&lt;T&gt;(\n    new T(forward&lt;Args&gt;(args)...));\n}\n</code></pre><p>这样，它就可以把传递给自己的全部参数转发到模板参数类的构造函数上去。注意，在这种情况下，我们通常会使用 <code>std::forward</code>，确保参数转发时仍然保持正确的左值或右值引用类型。</p><p>稍微解释一下上面三处出现的 <code>...</code>：</p><ul>\n<li><code>typename... Args</code> 声明了一系列的类型——<code>class...</code> 或 <code>typename...</code> 表示后面的标识符代表了一系列的类型。</li>\n<li><code>Args&amp;&amp;... args</code> 声明了一系列的形参 <code>args</code>，其类型是 <code>Args&amp;&amp;</code>。</li>\n<li><code>forward&lt;Args&gt;(args)...</code> 会在编译时实际逐项展开 <code>Args</code> 和 <code>args</code> ，参数有多少项，展开后就是多少项。</li>\n</ul><!-- [[[read_end]]] --><p>举一个例子，如果我们需要在堆上传递一个 <code>vector&lt;int&gt;</code>，假设我们希望初始构造的大小为 100，每个元素都是 <code>1</code>，那我们可以这样写：</p><pre><code class=\"language-c++\">make_unique&lt;vector&lt;int&gt;&gt;(100, 1)\n</code></pre><p>模板实例化之后，会得到相当于下面的代码：</p><pre><code class=\"language-c++\">template &lt;&gt;\ninline unique_ptr&lt;vector&lt;int&gt;&gt;\nmake_unique(int&amp;&amp; arg1, int&amp;&amp; arg2)\n{\n  return unique_ptr&lt;vector&lt;int&gt;&gt;(\n    new vector&lt;int&gt;(\n      forward&lt;int&gt;(arg1),\n      forward&lt;int&gt;(arg2)));\n}\n</code></pre><p>如前所述，<code>forward&lt;Args&gt;(args)...</code> 为每一项可变模板参数都以同样的形式展开。项数也允许为零，那样，我们在调用构造函数时也同样没有任何参数。</p><h3>递归用法</h3><p>我们也可以用可变模板来实现编译期递归。下面就是个小例子：</p><pre><code class=\"language-c++\">template &lt;typename T&gt;\nconstexpr auto sum(T x)\n{\n  return x;\n}\n\ntemplate &lt;typename T1, typename T2,\n          typename... Targ&gt;\nconstexpr auto sum(T1 x, T2 y,\n                   Targ... args)\n{\n  return sum(x + y, args...);\n}\n</code></pre><p>在上面的定义里，如果 <code>sum</code> 得到的参数只有一个，会走到上面那个重载。如果有两个或更多参数，编译器就会选择下面那个重载，执行一次加法，随后你的参数数量就少了一个，因而递归总会终止到上面那个重载，结束计算。</p><p>要使用上面这个模板，我们就可以写出像下面这样的函数调用：</p><pre><code class=\"language-c++\">auto result = sum(1, 2, 3.5, x);\n</code></pre><p>模板会这样依次展开：</p><pre><code class=\"language-c++\">sum(1 + 2, 3.5, x)\nsum(3 + 3.5, x)\nsum(6.5 + x)\n6.5 + x\n</code></pre><p>注意我们都不必使用相同的数据类型：只要这些数据之间可以应用 <code>+</code>，它们的类型无关紧要……</p><p>再看另一个复杂些的例子，函数的组合 <span class=\"orange\">[2]</span>。如果我们有函数 $f$ 和 函数 $g$，要得到函数的联用 $g \\circ f$，其满足：</p><p>$$<br>\n(g \\circ f)(x) = g(f(x))<br>\n$$</p><p>我们能不能用一种非常简单的方式，写不包含变量 $x$ 的表达式来表示函数组合呢？答案是肯定的。</p><p>跟上面类似，我们需要写出递归的终结情况，单个函数的“组合”：</p><pre><code class=\"language-c++\">template &lt;typename F&gt;\nauto compose(F f)\n{\n  return [f](auto&amp;&amp;... x) {\n    return f(\n      forward&lt;decltype(x)&gt;(x)...);\n  };\n}\n</code></pre><p>上面我们仅返回一个泛型 lambda 表达式，保证参数可以转发到 <code>f</code>。记得我们在<a href=\"https://time.geekbang.org/column/article/184018\">[第 16 讲]</a> 讲过泛型 lambda 表达式，本质上就是一个模板，所以我们按转发用法的可变模板来理解上面的 <code>...</code> 部分就对了。</p><p>下面是正常有组合的情况：</p><pre><code class=\"language-c++\">template &lt;typename F,\n          typename... Args&gt;\nauto compose(F f, Args... other)\n{\n  return [f,\n          other...](auto&amp;&amp;... x) {\n    return f(compose(other...)(\n      forward&lt;decltype(x)&gt;(x)...));\n  };\n}\n</code></pre><p>在这个模板里，我们返回一个 lambda 表达式，然后用 <code>f</code> 捕捉第一个函数对象，用 <code>args...</code> 捕捉后面的函数对象。我们用 <code>args...</code> 继续组合后面的部分，然后把结果传到 <code>f</code> 里面。</p><p>上面的模板定义我实际上已经有所简化，没有保持值类别。完整的包含完美转发的版本，请看参考资料 <span class=\"orange\">[3]</span> 中的 functional.h 实现。</p><p>下面我们来试验一下使用这个 <code>compose</code> 函数。我们先写一个对输入范围中每一项都进行平方的函数对象：</p><pre><code class=\"language-c++\">auto square_list =\n  [](auto&amp;&amp; container) {\n    return fmap(\n      [](int x) { return x * x; },\n      container);\n  };\n</code></pre><p>我们使用了<a href=\"https://time.geekbang.org/column/article/181608\">[第 13 讲]</a> 中给出的 <code>fmap</code>，而不是标准库里的 <code>transform</code>，是因为后者接口非函数式，无法组合——它要求参数给出输出位置的迭代器，会修改迭代器指向的内容，返回结果也只是单个的迭代器；函数式的接口则期望不修改参数的内容，结果完全在返回值中。</p><p>我们这儿用了泛型 lambda 表达式，是因为组合的时候不能使用模板，只能是函数对象或函数（指针）——如果我们定义一个 <code>square_list</code> 模板的话，组合时还得显式实例化才行（写成 <code>square_list&lt;const vector&lt;int&gt;&amp;&gt;</code> 的样子），很不方便。</p><p>我们再写一个求和的函数对象：</p><pre><code class=\"language-c++\">auto sum_list =\n  [](auto&amp;&amp; container) {\n    return accumulate(\n      container.begin(),\n      container.end(), 0);\n  };\n</code></pre><p>那先平方再求和，就可以这样简单定义了：</p><pre><code class=\"language-c++\">auto squared_sum =\n  compose(sum_list, square_list);\n</code></pre><p>我们可以验证这个定义是可以工作的：</p><pre><code class=\"language-c++\">vector v{1, 2, 3, 4, 5};\ncout &lt;&lt; squared_sum(v) &lt;&lt; endl;\n</code></pre><p>我们会得到：</p><blockquote>\n<p><code>55</code></p>\n</blockquote><h2>tuple</h2><p>上面的写法虽然看起来还不错，但实际上有个缺陷：被 compose 的函数除了第一个（最右边的），其他的函数只能接收一个参数。要想进一步推进类似的技巧，我们得首先解决这个问题。</p><p>在 C++ 里，要通用地用一个变量来表达多个值，那就得看多元组——<code>tuple</code> 模板了 <span class=\"orange\">[4]</span>。<code>tuple</code> 算是 C++98 里的 <code>pair</code> 类型的一般化，可以表达任意多个固定数量、固定类型的值的组合。下面这段代码约略地展示了其基本用法：</p><pre><code class=\"language-c++\">#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;tuple&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\n// 整数、字符串、字符串的三元组\nusing num_tuple =\n  tuple&lt;int, string, string&gt;;\n\nostream&amp;\noperator&lt;&lt;(ostream&amp; os,\n           const num_tuple&amp; value)\n{\n  os &lt;&lt; get&lt;0&gt;(value) &lt;&lt; ','\n     &lt;&lt; get&lt;1&gt;(value) &lt;&lt; ','\n     &lt;&lt; get&lt;2&gt;(value);\n  return os;\n}\n\nint main()\n{\n  // 阿拉伯数字、英文、法文\n  vector&lt;num_tuple&gt; vn{\n    {1, \"one\",   \"un\"},\n    {2, \"two\",   \"deux\"},\n    {3, \"three\", \"trois\"},\n    {4, \"four\",  \"quatre\"}};\n  // 修改第 0 项的法文\n  get&lt;2&gt;(vn[0]) = \"une\";\n  // 按法文进行排序\n  sort(vn.begin(), vn.end(),\n       [](auto&amp;&amp; x, auto&amp;&amp; y) {\n         return get&lt;2&gt;(x) &lt;\n                get&lt;2&gt;(y);\n       });\n  // 输出内容\n  for (auto&amp;&amp; value : vn) {\n    cout &lt;&lt; value &lt;&lt; endl;\n  }\n  // 输出多元组项数\n  constexpr auto size = \\\n    tuple_size_v&lt;num_tuple&gt;;\n  cout &lt;&lt; \"Tuple size is \" &lt;&lt; size &lt;&lt; endl;\n}\n</code></pre><p>输出是：</p><blockquote>\n<p><code>2,two,deux</code><br>\n<code>4,four,quatre</code><br>\n<code>3,three,trois</code><br>\n<code>1,one,une</code><br>\n<code>Tuple size is 3</code></p>\n</blockquote><p>我们可以看到：</p><ul>\n<li><code>tuple</code> 的成员数量由尖括号里写的类型数量决定。</li>\n<li>可以使用 <code>get</code> 函数对 <code>tuple</code> 的内容进行读和写。（当一个类型在 <code>tuple</code> 中出现正好一次时，我们也可以传类型取内容，即，对我们上面的三元组，<code>get&lt;int&gt;</code> 是合法的，<code>get&lt;string&gt;</code> 则不是。）</li>\n<li>可以用 <code>tuple_size_v</code> （在编译期）取得多元组里面的项数。</li>\n</ul><p>如果我们要用一个三项的 <code>tuple</code> 去调用一个函数，我们可以写类似这样的代码：</p><pre><code class=\"language-c++\">template &lt;class F, class Tuple&gt;\nconstexpr decltype(auto) apply(\n  F&amp;&amp; f, Tuple&amp;&amp; t)\n{\n  return f(\n    get&lt;0&gt;(forward&lt;Tuple&gt;(t)),\n    get&lt;1&gt;(forward&lt;Tuple&gt;(t)),\n    get&lt;2&gt;(forward&lt;Tuple&gt;(t)));\n}\n</code></pre><p>这似乎已经挺接近我们需要的形式了，但实际调用函数的参数项数会变啊……</p><p>我们已经有了参数的项数（使用 <code>tuple_size_v</code>），所以我们下面要做的是生成从 0 到项数减一之间的整数序列。标准库里已经定义了相关的工具，我们需要的就是其中的 <code>make_index_sequence</code> <span class=\"orange\">[5]</span>，其简化实现如下所示：</p><pre><code class=\"language-c++\">template &lt;class T, T... Ints&gt;\nstruct integer_sequence {};\n\ntemplate &lt;size_t... Ints&gt;\nusing index_sequence =\n  integer_sequence&lt;size_t, Ints...&gt;;\n\ntemplate &lt;size_t N, size_t... Ints&gt;\nstruct index_sequence_helper {\n  typedef\n    typename index_sequence_helper&lt;\n      N - 1, N - 1, Ints...&gt;::type\n      type;\n};\n\ntemplate &lt;size_t... Ints&gt;\nstruct index_sequence_helper&lt;\n  0, Ints...&gt; {\n  typedef index_sequence&lt;Ints...&gt;\n    type;\n};\n\ntemplate &lt;size_t N&gt;\nusing make_index_sequence =\n  typename index_sequence_helper&lt;\n    N&gt;::type;\n</code></pre><p>正如一般的模板代码，它看起来还是有点绕的。其要点是，如果我们给出 <code>make_index_sequence&lt;N&gt;</code>，则结果是 <code>integer_sequence&lt;size_t, 0, 1, 2, …, N - 1&gt;</code>（一下子想不清楚的话，可以拿纸笔来模拟一下模板的展开过程）。而有了这样一个模板的帮助之后，我们就可以写出下面这样的函数（同样，这是标准库里的 <code>apply</code> 函数模板 <span class=\"orange\">[6]</span> 的简化版本）：</p><pre><code class=\"language-c++\">template &lt;class F, class Tuple,\n          size_t... I&gt;\nconstexpr decltype(auto)\napply_impl(F&amp;&amp; f, Tuple&amp;&amp; t,\n           index_sequence&lt;I...&gt;)\n{\n  return f(\n    get&lt;I&gt;(forward&lt;Tuple&gt;(t))...);\n}\n\ntemplate &lt;class F, class Tuple&gt;\nconstexpr decltype(auto)\napply(F&amp;&amp; f, Tuple&amp;&amp; t)\n{\n  return apply_impl(\n    forward&lt;F&gt;(f),\n    forward&lt;Tuple&gt;(t),\n    make_index_sequence&lt;\n      tuple_size_v&lt;\n        remove_reference_t&lt;\n          Tuple&gt;&gt;&gt;{});\n}\n</code></pre><p>我们如果有一个三元组 <code>t</code>，类型为 <code>tuple&lt;int, string, string&gt;</code>，去 <code>apply</code> 到一个函数 <code>f</code>，展开后我们得到 <code>apply_impl(f, t, index_sequence&lt;0, 1, 2&gt;{})</code>，再展开后我们就得到了上面那个有 <code>get&lt;0&gt;</code>、<code>get&lt;1&gt;</code>、<code>get&lt;2&gt;</code> 的函数调用形式。换句话说，我们利用一个计数序列的类型，可以在编译时展开 <code>tuple</code> 里的各个成员，并用来调用函数。</p><h2>数值预算</h2><p>上面的代码有点复杂，而且似乎并没有完成什么很重要的功能。我们下面看一个源自实际项目的例子。需求是，我们希望快速地计算一串二进制数中 1 比特的数量。举个例子，如果我们有十进制的 31 和 254，转换成二进制是 00011111 和 11111110，那我们应该得到 5 + 7 = 12。</p><p>显然，每个数字临时去数肯定会慢，我们应该预先把每个字节的 256 种情况记录下来。因而，如何得到这些计数值是个问题。在没有编译期编程时，我们似乎只能用另外一个程序先行计算，然后把结果填进去——这就很不方便很不灵活了。有了编译期编程，我们就不用写死，而让编译器在编译时帮我们计算数值。</p><p>利用 constexpr 函数，我们计算单个数值完全没有问题。快速定义如下：</p><pre><code class=\"language-c++\">constexpr int\ncount_bits(unsigned char value)\n{\n  if (value == 0) {\n    return 0;\n  } else {\n    return (value &amp; 1) +\n           count_bits(value &gt;&gt; 1);\n  }\n}\n</code></pre><p>可 256 个，总不见得把计算语句写上 256 遍吧？这就需要用到我们上面讲到的 <code>index_sequence</code> 了。我们定义一个模板，它的参数是一个序列，在初始化时这个模板会对参数里的每一项计算比特数，并放到数组成员里。</p><pre><code class=\"language-c++\">template &lt;size_t... V&gt;\nstruct bit_count_t {\n  unsigned char\n    count[sizeof...(V)] = {\n      static_cast&lt;unsigned char&gt;(\n        count_bits(V))...};\n};\n</code></pre><p>注意上面用 <code>sizeof...(V)</code> 可以获得参数的个数（在 <code>tuple_size_v</code> 的实现里实际也用到它了）。如果我们模板参数传 <code>0, 1, 2, 3</code>，结果里面就会有个含 4 项元素的数组，数值分别是对 0、1、2、3 的比特计数。</p><p>然后，我们当然就可以利用 <code>make_index_sequence</code> 来展开计算了，想产生几项就可以产生几项。不过，要注意到 <code>make_index_sequence</code> 的结果是个类型，不能直接用在 <code>bit_count_t</code> 的构造中。我们需要用模板匹配来中转一下：</p><pre><code class=\"language-c++\">template &lt;size_t... V&gt;\nconstexpr bit_count_t&lt;V...&gt;\nget_bit_count(index_sequence&lt;V...&gt;)\n{\n  return bit_count_t&lt;V...&gt;();\n}\n\nauto bit_count = get_bit_count(\n  make_index_sequence&lt;256&gt;());\n</code></pre><p>得到 <code>bit_count</code> 后，我们要计算一个序列里的比特数就只是轻松查表相加了，此处不再赘述。</p><h2>内容小结</h2><p>今天我们讨论了在编译期处理不确定数量的参数和类型的基本语言特性，可变模板，以及可以操控可变模板的重要工具——<code>tuple</code> 和 <code>index_sequence</code>。用好这些工具，可以让我们轻松地完成一些编译期计算的工作。</p><h2>课后思考</h2><p>请考虑一下：</p><ol>\n<li>我展示了 <code>compose</code> 带一个或更多参数的情况。你觉得 <code>compose</code> 不带任何参数该如何定义？它有意义吗？</li>\n<li>有没有可能不用 <code>index_sequence</code> 来初始化 <code>bit_count</code>？如果行，应该如何实现？</li>\n<li>作为一个挑战，你能自行实现出 <code>make_integer_sequence</code> 吗？</li>\n</ol><p>期待你的答案。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] cppreference.com, “Parameter pack”. <a href=\"https://en.cppreference.com/w/cpp/language/parameter_pack\">https://en.cppreference.com/w/cpp/language/parameter_pack</a> </span></p><p><span class=\"reference\">[1a] cppreference.com, “形参包”. <a href=\"https://zh.cppreference.com/w/cpp/language/parameter_pack\">https://zh.cppreference.com/w/cpp/language/parameter_pack</a> </span></p><p><span class=\"reference\">[2] Wikipedia, “Function composition”. <a href=\"https://en.wikipedia.org/wiki/Function_composition\">https://en.wikipedia.org/wiki/Function_composition</a> </span></p><p><span class=\"reference\">[2a] 维基百科, “复合函数”. <a href=\"https://zh.wikipedia.org/zh-cn/%E5%A4%8D%E5%90%88%E5%87%BD%E6%95%B0\">https://zh.wikipedia.org/zh-cn/复合函数</a> </span></p><p><span class=\"reference\">[3] 吴咏炜, nvwa. <a href=\"https://github.com/adah1972/nvwa\">https://github.com/adah1972/nvwa</a> </span></p><p><span class=\"reference\">[4] cppreference.com, “std::tuple”. <a href=\"https://en.cppreference.com/w/cpp/utility/tuple\">https://en.cppreference.com/w/cpp/utility/tuple</a> </span></p><p><span class=\"reference\">[4a] cppreference.com, “std::tuple”. <a href=\"https://zh.cppreference.com/w/cpp/utility/tuple\">https://zh.cppreference.com/w/cpp/utility/tuple</a> </span></p><p><span class=\"reference\">[5] cppreference.com, “std::integer_sequence”. <a href=\"https://en.cppreference.com/w/cpp/utility/integer_sequence\">https://en.cppreference.com/w/cpp/utility/integer_sequence</a> </span></p><p><span class=\"reference\">[5a] cppreference.com, “std::integer_sequence”. <a href=\"https://zh.cppreference.com/w/cpp/utility/integer_sequence\">https://zh.cppreference.com/w/cpp/utility/integer_sequence</a> </span></p><p><span class=\"reference\">[6] cppreference.com, “std::apply”. <a href=\"https://en.cppreference.com/w/cpp/utility/apply\">https://en.cppreference.com/w/cpp/utility/apply</a> </span></p><p><span class=\"reference\">[6a] cppreference.com, “std::apply”. <a href=\"https://zh.cppreference.com/w/cpp/utility/apply\">https://zh.cppreference.com/w/cpp/utility/apply</a> </span></p>","neighbors":{"left":{"article_title":"17 | 函数式编程：一种越来越流行的编程范式","id":185189},"right":{"article_title":"19 | thread和future：领略异步中的未来","id":186689}},"comments":[{"had_liked":false,"id":169329,"user_name":"李亮亮","can_delete":false,"product_type":"c1","uid":1116508,"ip_address":"","ucode":"290907F930B261","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/5c/b5d79d20.jpg","comment_is_top":false,"comment_ctime":1578315479,"is_pvip":false,"replies":[{"id":65678,"content":"😁 学得挺快。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578325434,"ip_address":"","comment_id":169329,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"N--&gt;(N-1, N-1)--&gt;(N-2, N-2, N-1)--&gt;(1, 1 , 2 ....N-1)--&gt;(0, 0, 1, 2...N-1)","like_count":7},{"had_liked":false,"id":170084,"user_name":"泰伦卢","can_delete":false,"product_type":"c1","uid":1141994,"ip_address":"","ucode":"FEA6B43C8D4FF9","user_header":"https://static001.geekbang.org/account/avatar/00/11/6c/ea/e03fec22.jpg","comment_is_top":false,"comment_ctime":1578526837,"is_pvip":false,"replies":[{"id":65994,"content":"给个提示，到下面这个网站上看看模板是如何展开的：\n\nhttps:&#47;&#47;cppinsights.io&#47;","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578534290,"ip_address":"","comment_id":170084,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"compose那是完全没看懂唉，还有sequence那... ","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480835,"discussion_content":"给个提示，到下面这个网站上看看模板是如何展开的：\n\nhttps://cppinsights.io/","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578534290,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":269858,"user_name":"Geek_845be1","can_delete":false,"product_type":"c1","uid":1644657,"ip_address":"","ucode":"2B83B62C9D9C5D","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLDH0RbXvDGVoyRtxs3kLmwSmibqqic4EYYwSH12KqsrrKgpGic7cZXfsicpDMShFTAIT6p3jTJ3ypKzg/132","comment_is_top":false,"comment_ctime":1608813990,"is_pvip":false,"replies":[{"id":97886,"content":"很好。\n\n两个细节注意一下。\n\n1. consteval 是 C++20 的语法。在 C++17 里，我们仍然只能用 constexpr。\n\n2. 在 C++20 里，tbl{} 是可以写成 tbl 的。但在 C++17 里不可以，标准要求所有的 constexpr 对象必须在构造时完成初始化。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1608911240,"ip_address":"","comment_id":269858,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"不用 index_sequence 来初始化 bit_count：\n\n```\nconsteval int count_bits(unsigned char val)\n{\n    if (val == 0)\n        return 0;\n    return (val &amp; 1) + count_bits(val &gt;&gt; 1);\n}\n\ntemplate &lt;std::size_t N&gt;\nconsteval std::array&lt;unsigned char, N&gt; get_bit_count()\n{\n    std::array&lt;unsigned char, N&gt; tbl{};\n    for (auto i = 0; i != N; ++i)\n        tbl[i] = count_bits(i);\n    return tbl;\n}\n```","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512416,"discussion_content":"很好。\n\n两个细节注意一下。\n\n1. consteval 是 C++20 的语法。在 C++17 里，我们仍然只能用 constexpr。\n\n2. 在 C++20 里，tbl{} 是可以写成 tbl 的。但在 C++17 里不可以，标准要求所有的 constexpr 对象必须在构造时完成初始化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608911240,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245636,"user_name":"Geek_a16bbc","can_delete":false,"product_type":"c1","uid":2008721,"ip_address":"","ucode":"6F12AFEF638413","user_header":"","comment_is_top":false,"comment_ctime":1599013884,"is_pvip":false,"replies":[{"id":90412,"content":"没什么一定。这是一个功能，是不是需要用取决于你的具体项目需求。文中只是个例子而已。\n\n如果这个计算时间有点长，超过零点几秒，可能会影响程序启动的体验，也许你就需要预算。\n\n如果其他静态初始化的对象需要用到用到这些数据，那预算也是最简单的方式。因为如果没有额外的代码的话，静态初始化的顺序在不同文件是没有保证的。\n\n……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1599112197,"ip_address":"","comment_id":245636,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"用for loop來計算那２５６個count_bit()有什麼問題嗎？為什麼一定要在編譯期算好呢？","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504937,"discussion_content":"没什么一定。这是一个功能，是不是需要用取决于你的具体项目需求。文中只是个例子而已。\n\n如果这个计算时间有点长，超过零点几秒，可能会影响程序启动的体验，也许你就需要预算。\n\n如果其他静态初始化的对象需要用到用到这些数据，那预算也是最简单的方式。因为如果没有额外的代码的话，静态初始化的顺序在不同文件是没有保证的。\n\n……","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599112197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":382898,"user_name":"李云龙","can_delete":false,"product_type":"c1","uid":3201926,"ip_address":"北京","ucode":"785924B16BE788","user_header":"https://static001.geekbang.org/account/avatar/00/30/db/86/51ec4c41.jpg","comment_is_top":false,"comment_ctime":1698159743,"is_pvip":false,"replies":[{"id":139532,"content":"你这边取巧了一下，用 size_t N 这种写法，规避了一个技术问题，不过，似乎也算是一种解决方案。（思考题答案里用的是 T N，写起来就更麻烦了。）\n\n代码本身基本没问题。不过，在我测试的时候，我的环境里你的 apply 和标准库的 std::apply 发生了冲突，测你的代码要把 apply 改成 ::apply 才行。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1698388009,"ip_address":"上海","comment_id":382898,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，我尝试写了make_integer_sequence，没有看专栏末尾的答案，您看下这段代码满足您思考题的要求吗？有不正确的地方，烦请老师指正。\n#include &lt;iostream&gt;\n#include &lt;utility&gt;\n#include &lt;tuple&gt;\n#include &lt;type_traits&gt;\n\ntemplate &lt;class T, T... Ints&gt;\nstruct integer_sequence {};\n\ntemplate &lt;size_t N, class T, T... Ints&gt;\nstruct integer_sequence_helper {\n    typedef typename integer_sequence_helper&lt;N - 1, T, N - 1, Ints...&gt;::type type;\n};\n\ntemplate &lt;class T, T... Ints&gt;\nstruct integer_sequence_helper&lt;0, T, Ints...&gt; {\n    typedef integer_sequence&lt;T, Ints...&gt; type;\n};\n\ntemplate &lt;size_t N, class T&gt;\nusing make_integer_sequence = typename integer_sequence_helper&lt;N, T&gt;::type;\n\ntemplate &lt;class F, class Tuple, class T, T... I&gt;\nconstexpr decltype(auto)\napply_impl(F&amp;&amp; f, Tuple&amp;&amp; t, integer_sequence&lt;T, I...&gt;)\n{\n    return f(std::get&lt;I&gt;(std::forward&lt;Tuple&gt;(t))...);\n}\n\ntemplate &lt;class F, class Tuple&gt;\nconstexpr decltype(auto) apply(F&amp;&amp; f, Tuple&amp;&amp; t)\n{\n    return apply_impl(std::forward&lt;F&gt;(f), std::forward&lt;Tuple&gt;(t),\n        make_integer_sequence&lt;std::tuple_size_v&lt;std::remove_reference_t&lt;Tuple&gt;&gt;, size_t&gt;{});\n}\n\nint main()\n{\n    auto func = [](int x, int y, int z) {\n        std::cout &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;, &quot; &lt;&lt; z &lt;&lt; std::endl;\n    };\n\n    std::tuple&lt;int, int, int&gt; t{ 1,2,3 };\n\n    apply(func, t);\n\n    return 0;\n}","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630396,"discussion_content":"你这边取巧了一下，用 size_t N 这种写法，规避了一个技术问题，不过，似乎也算是一种解决方案。（思考题答案里用的是 T N，写起来就更麻烦了。）\n\n代码本身基本没问题。不过，在我测试的时候，我的环境里你的 apply 和标准库的 std::apply 发生了冲突，测你的代码要把 apply 改成 ::apply 才行。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1698388009,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296921,"user_name":"chang","can_delete":false,"product_type":"c1","uid":2596026,"ip_address":"","ucode":"594EF8CB4477BD","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/2ibrq71Y5Ww3KDRibDxF1gt9YDEPuZkv4ITHEP1u4vvjpPDukkLoK4ngQy1hKKzccnsicLkUAda7sPpibR6Kyb0cfQ/132","comment_is_top":false,"comment_ctime":1623225239,"is_pvip":false,"replies":[{"id":107930,"content":"可读性也取决于读者的眼睛。这个例子确实运行时计算也没什么大不了，但类似的技巧还是有很多适用场合的。\n\n我目前在项目的公用代码里大量使用此类技巧。不要求大部分开发者来读此类代码，他们会用就行了。\n\n记住，C++的很多功能是给库开发者提供的，不是给应用开发者提供的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1623370518,"ip_address":"","comment_id":296921,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"反复看着教程才把make_integer_sequence写出来（应该是半抄半写）。感觉这节已经把模板用得很偏了。个人认为若在现实项目中，最后一个bit_count的例子还是不要用模板好，为了节省运行时时间，却大大降低了代码的可读性及可维护性，不值当。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630396,"discussion_content":"你这边取巧了一下，用 size_t N 这种写法，规避了一个技术问题，不过，似乎也算是一种解决方案。（思考题答案里用的是 T N，写起来就更麻烦了。）\n\n代码本身基本没问题。不过，在我测试的时候，我的环境里你的 apply 和标准库的 std::apply 发生了冲突，测你的代码要把 apply 改成 ::apply 才行。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1698388009,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":246281,"user_name":"Geek_a16bbc","can_delete":false,"product_type":"c1","uid":2008721,"ip_address":"","ucode":"6F12AFEF638413","user_header":"","comment_is_top":false,"comment_ctime":1599250487,"is_pvip":false,"replies":[{"id":90519,"content":"第一种写法，不可以。你不可以在不声明 T 的情况下，突然蹦出来一个 T。\n\n第二种写法，也不可以，因为这是 integer_sequence 定义的模板形式。不过，你确实可以独立定义一个类似下面形式的模板，不使用 integer_sequence：\n\ntemplate &lt;size_t... Ints&gt;\nstruct index_sequence {};","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1599272052,"ip_address":"","comment_id":246281,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"template &lt;class T, T... Ints&gt;\nstruct integer_sequence {};\n為什麼需要class T?不能template&lt;T... Ints&gt;?\n\ntemplate &lt;size_t... Ints&gt;\nusing index_sequence =  integer_sequence&lt;size_t, Ints...&gt;;\n同樣的，這裡可以寫成integer_sequence&lt;Ints...&gt;?","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521648,"discussion_content":"可读性也取决于读者的眼睛。这个例子确实运行时计算也没什么大不了，但类似的技巧还是有很多适用场合的。\n\n我目前在项目的公用代码里大量使用此类技巧。不要求大部分开发者来读此类代码，他们会用就行了。\n\n记住，C++的很多功能是给库开发者提供的，不是给应用开发者提供的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623370518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":233477,"user_name":"中山浪子","can_delete":false,"product_type":"c1","uid":1055296,"ip_address":"","ucode":"25D0F8462473D3","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/40/f10493ef.jpg","comment_is_top":false,"comment_ctime":1594341287,"is_pvip":false,"replies":[{"id":86230,"content":"模板有简单的用法，也有复杂的用法。简单的用法有时更加实用，也比较容易维护，不容易出问题。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1594377827,"ip_address":"","comment_id":233477,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"写过一些模版，公司代码也涉及到模版，看了老师的模版代码以后，才发现自己还是不懂模版","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505099,"discussion_content":"第一种写法，不可以。你不可以在不声明 T 的情况下，突然蹦出来一个 T。\n\n第二种写法，也不可以，因为这是 integer_sequence 定义的模板形式。不过，你确实可以独立定义一个类似下面形式的模板，不使用 integer_sequence：\n\ntemplate &amp;lt;size_t... Ints&amp;gt;\nstruct index_sequence {};","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599272052,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188065,"user_name":"宋强","can_delete":false,"product_type":"c1","uid":1564605,"ip_address":"","ucode":"119A0B00ABDA7B","user_header":"","comment_is_top":false,"comment_ctime":1584319707,"is_pvip":false,"replies":[{"id":72671,"content":"这儿是返回一个函数对象啊。x是这个函数对象的参数。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1584329096,"ip_address":"","comment_id":188065,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"\ntemplate &lt;typename F&gt;\nauto compose(F f)\n{\n  return [f](auto&amp;&amp;... x) {\n    return f(\n      forward&lt;decltype(x)&gt;(x)...);\n  };\n}\n老师，请问下auto&amp;&amp;... x没有出现在入参里，这个怎么产生呢？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501054,"discussion_content":"模板有简单的用法，也有复杂的用法。简单的用法有时更加实用，也比较容易维护，不容易出问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594377827,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169501,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1578366432,"is_pvip":false,"replies":[{"id":65796,"content":"--- 更新 ---\n\n我费了九牛二虎之力，终于把例子改得能在 gcc 4.8 下工作了。我觉得你不想维护这样的代码的。\n\n这儿空间不够。我放在这里：\n\nhttp:&#47;&#47;wyw.dcweb.cn&#47;download.asp?path=&amp;file=jike_18_gcc48.cpp\n\n我觉得升级 GCC 绝对是更好的主意。\n\n--- 原回复 ---\n没啥好办法……泛型lambda至少要求gcc 4.9。只能不用这类功能了。\n\n手写一个函数对象模板也许可以完成这个功能（让 f 成为其数据成员）。你可以试试看。我暂时没时间试验。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578393383,"ip_address":"","comment_id":169501,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"template &lt;typename F&gt;\nauto compose(F f)\n{\n    return [f](auto&amp;&amp;... x) {\n        return f(x...);\n    };\n}\n\n貌似用compiler(gcc version 4.8.5 20150623) 就会遇到下面编译错误\n&#47;&#47; In function ‘auto compose(F)’: \n&#47;&#47; error: expansion pattern ‘auto&amp;&amp;’ contains no argument packs\n&#47;&#47; return [f](auto&amp;&amp;... x) {\n\n用compiler(gcc version 8.3.1 20190311)就不会有问题。\n\n如果公司目前只允许用(gcc version 4.8.5 20150623)，请问有什么workaround?\n\n谢谢！\n","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487332,"discussion_content":"这儿是返回一个函数对象啊。x是这个函数对象的参数。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584329096,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169329,"user_name":"李亮亮","can_delete":false,"product_type":"c1","uid":1116508,"ip_address":"","ucode":"290907F930B261","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/5c/b5d79d20.jpg","comment_is_top":false,"comment_ctime":1578315479,"is_pvip":false,"replies":[{"id":65678,"content":"😁 学得挺快。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578325434,"ip_address":"","comment_id":169329,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"N--&gt;(N-1, N-1)--&gt;(N-2, N-2, N-1)--&gt;(1, 1 , 2 ....N-1)--&gt;(0, 0, 1, 2...N-1)","like_count":7,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480511,"discussion_content":"😁 学得挺快。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578325434,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170084,"user_name":"泰伦卢","can_delete":false,"product_type":"c1","uid":1141994,"ip_address":"","ucode":"FEA6B43C8D4FF9","user_header":"https://static001.geekbang.org/account/avatar/00/11/6c/ea/e03fec22.jpg","comment_is_top":false,"comment_ctime":1578526837,"is_pvip":false,"replies":[{"id":65994,"content":"给个提示，到下面这个网站上看看模板是如何展开的：\n\nhttps:&#47;&#47;cppinsights.io&#47;","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578534290,"ip_address":"","comment_id":170084,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"compose那是完全没看懂唉，还有sequence那... ","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480511,"discussion_content":"😁 学得挺快。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578325434,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":269858,"user_name":"Geek_845be1","can_delete":false,"product_type":"c1","uid":1644657,"ip_address":"","ucode":"2B83B62C9D9C5D","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLDH0RbXvDGVoyRtxs3kLmwSmibqqic4EYYwSH12KqsrrKgpGic7cZXfsicpDMShFTAIT6p3jTJ3ypKzg/132","comment_is_top":false,"comment_ctime":1608813990,"is_pvip":false,"replies":[{"id":97886,"content":"很好。\n\n两个细节注意一下。\n\n1. consteval 是 C++20 的语法。在 C++17 里，我们仍然只能用 constexpr。\n\n2. 在 C++20 里，tbl{} 是可以写成 tbl 的。但在 C++17 里不可以，标准要求所有的 constexpr 对象必须在构造时完成初始化。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1608911240,"ip_address":"","comment_id":269858,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"不用 index_sequence 来初始化 bit_count：\n\n```\nconsteval int count_bits(unsigned char val)\n{\n    if (val == 0)\n        return 0;\n    return (val &amp; 1) + count_bits(val &gt;&gt; 1);\n}\n\ntemplate &lt;std::size_t N&gt;\nconsteval std::array&lt;unsigned char, N&gt; get_bit_count()\n{\n    std::array&lt;unsigned char, N&gt; tbl{};\n    for (auto i = 0; i != N; ++i)\n        tbl[i] = count_bits(i);\n    return tbl;\n}\n```","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480835,"discussion_content":"给个提示，到下面这个网站上看看模板是如何展开的：\n\nhttps://cppinsights.io/","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578534290,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245636,"user_name":"Geek_a16bbc","can_delete":false,"product_type":"c1","uid":2008721,"ip_address":"","ucode":"6F12AFEF638413","user_header":"","comment_is_top":false,"comment_ctime":1599013884,"is_pvip":false,"replies":[{"id":90412,"content":"没什么一定。这是一个功能，是不是需要用取决于你的具体项目需求。文中只是个例子而已。\n\n如果这个计算时间有点长，超过零点几秒，可能会影响程序启动的体验，也许你就需要预算。\n\n如果其他静态初始化的对象需要用到用到这些数据，那预算也是最简单的方式。因为如果没有额外的代码的话，静态初始化的顺序在不同文件是没有保证的。\n\n……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1599112197,"ip_address":"","comment_id":245636,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"用for loop來計算那２５６個count_bit()有什麼問題嗎？為什麼一定要在編譯期算好呢？","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512416,"discussion_content":"很好。\n\n两个细节注意一下。\n\n1. consteval 是 C++20 的语法。在 C++17 里，我们仍然只能用 constexpr。\n\n2. 在 C++20 里，tbl{} 是可以写成 tbl 的。但在 C++17 里不可以，标准要求所有的 constexpr 对象必须在构造时完成初始化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608911240,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":382898,"user_name":"李云龙","can_delete":false,"product_type":"c1","uid":3201926,"ip_address":"北京","ucode":"785924B16BE788","user_header":"https://static001.geekbang.org/account/avatar/00/30/db/86/51ec4c41.jpg","comment_is_top":false,"comment_ctime":1698159743,"is_pvip":false,"replies":[{"id":139532,"content":"你这边取巧了一下，用 size_t N 这种写法，规避了一个技术问题，不过，似乎也算是一种解决方案。（思考题答案里用的是 T N，写起来就更麻烦了。）\n\n代码本身基本没问题。不过，在我测试的时候，我的环境里你的 apply 和标准库的 std::apply 发生了冲突，测你的代码要把 apply 改成 ::apply 才行。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1698388009,"ip_address":"上海","comment_id":382898,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师，我尝试写了make_integer_sequence，没有看专栏末尾的答案，您看下这段代码满足您思考题的要求吗？有不正确的地方，烦请老师指正。\n#include &lt;iostream&gt;\n#include &lt;utility&gt;\n#include &lt;tuple&gt;\n#include &lt;type_traits&gt;\n\ntemplate &lt;class T, T... Ints&gt;\nstruct integer_sequence {};\n\ntemplate &lt;size_t N, class T, T... Ints&gt;\nstruct integer_sequence_helper {\n    typedef typename integer_sequence_helper&lt;N - 1, T, N - 1, Ints...&gt;::type type;\n};\n\ntemplate &lt;class T, T... Ints&gt;\nstruct integer_sequence_helper&lt;0, T, Ints...&gt; {\n    typedef integer_sequence&lt;T, Ints...&gt; type;\n};\n\ntemplate &lt;size_t N, class T&gt;\nusing make_integer_sequence = typename integer_sequence_helper&lt;N, T&gt;::type;\n\ntemplate &lt;class F, class Tuple, class T, T... I&gt;\nconstexpr decltype(auto)\napply_impl(F&amp;&amp; f, Tuple&amp;&amp; t, integer_sequence&lt;T, I...&gt;)\n{\n    return f(std::get&lt;I&gt;(std::forward&lt;Tuple&gt;(t))...);\n}\n\ntemplate &lt;class F, class Tuple&gt;\nconstexpr decltype(auto) apply(F&amp;&amp; f, Tuple&amp;&amp; t)\n{\n    return apply_impl(std::forward&lt;F&gt;(f), std::forward&lt;Tuple&gt;(t),\n        make_integer_sequence&lt;std::tuple_size_v&lt;std::remove_reference_t&lt;Tuple&gt;&gt;, size_t&gt;{});\n}\n\nint main()\n{\n    auto func = [](int x, int y, int z) {\n        std::cout &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;, &quot; &lt;&lt; z &lt;&lt; std::endl;\n    };\n\n    std::tuple&lt;int, int, int&gt; t{ 1,2,3 };\n\n    apply(func, t);\n\n    return 0;\n}","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504937,"discussion_content":"没什么一定。这是一个功能，是不是需要用取决于你的具体项目需求。文中只是个例子而已。\n\n如果这个计算时间有点长，超过零点几秒，可能会影响程序启动的体验，也许你就需要预算。\n\n如果其他静态初始化的对象需要用到用到这些数据，那预算也是最简单的方式。因为如果没有额外的代码的话，静态初始化的顺序在不同文件是没有保证的。\n\n……","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599112197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296921,"user_name":"chang","can_delete":false,"product_type":"c1","uid":2596026,"ip_address":"","ucode":"594EF8CB4477BD","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/2ibrq71Y5Ww3KDRibDxF1gt9YDEPuZkv4ITHEP1u4vvjpPDukkLoK4ngQy1hKKzccnsicLkUAda7sPpibR6Kyb0cfQ/132","comment_is_top":false,"comment_ctime":1623225239,"is_pvip":false,"replies":[{"id":107930,"content":"可读性也取决于读者的眼睛。这个例子确实运行时计算也没什么大不了，但类似的技巧还是有很多适用场合的。\n\n我目前在项目的公用代码里大量使用此类技巧。不要求大部分开发者来读此类代码，他们会用就行了。\n\n记住，C++的很多功能是给库开发者提供的，不是给应用开发者提供的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1623370518,"ip_address":"","comment_id":296921,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"反复看着教程才把make_integer_sequence写出来（应该是半抄半写）。感觉这节已经把模板用得很偏了。个人认为若在现实项目中，最后一个bit_count的例子还是不要用模板好，为了节省运行时时间，却大大降低了代码的可读性及可维护性，不值当。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521648,"discussion_content":"可读性也取决于读者的眼睛。这个例子确实运行时计算也没什么大不了，但类似的技巧还是有很多适用场合的。\n\n我目前在项目的公用代码里大量使用此类技巧。不要求大部分开发者来读此类代码，他们会用就行了。\n\n记住，C++的很多功能是给库开发者提供的，不是给应用开发者提供的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623370518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":246281,"user_name":"Geek_a16bbc","can_delete":false,"product_type":"c1","uid":2008721,"ip_address":"","ucode":"6F12AFEF638413","user_header":"","comment_is_top":false,"comment_ctime":1599250487,"is_pvip":false,"replies":[{"id":90519,"content":"第一种写法，不可以。你不可以在不声明 T 的情况下，突然蹦出来一个 T。\n\n第二种写法，也不可以，因为这是 integer_sequence 定义的模板形式。不过，你确实可以独立定义一个类似下面形式的模板，不使用 integer_sequence：\n\ntemplate &lt;size_t... Ints&gt;\nstruct index_sequence {};","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1599272052,"ip_address":"","comment_id":246281,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"template &lt;class T, T... Ints&gt;\nstruct integer_sequence {};\n為什麼需要class T?不能template&lt;T... Ints&gt;?\n\ntemplate &lt;size_t... Ints&gt;\nusing index_sequence =  integer_sequence&lt;size_t, Ints...&gt;;\n同樣的，這裡可以寫成integer_sequence&lt;Ints...&gt;?","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505099,"discussion_content":"第一种写法，不可以。你不可以在不声明 T 的情况下，突然蹦出来一个 T。\n\n第二种写法，也不可以，因为这是 integer_sequence 定义的模板形式。不过，你确实可以独立定义一个类似下面形式的模板，不使用 integer_sequence：\n\ntemplate &amp;lt;size_t... Ints&amp;gt;\nstruct index_sequence {};","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599272052,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":233477,"user_name":"中山浪子","can_delete":false,"product_type":"c1","uid":1055296,"ip_address":"","ucode":"25D0F8462473D3","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/40/f10493ef.jpg","comment_is_top":false,"comment_ctime":1594341287,"is_pvip":false,"replies":[{"id":86230,"content":"模板有简单的用法，也有复杂的用法。简单的用法有时更加实用，也比较容易维护，不容易出问题。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1594377827,"ip_address":"","comment_id":233477,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"写过一些模版，公司代码也涉及到模版，看了老师的模版代码以后，才发现自己还是不懂模版","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501054,"discussion_content":"模板有简单的用法，也有复杂的用法。简单的用法有时更加实用，也比较容易维护，不容易出问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594377827,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":188065,"user_name":"宋强","can_delete":false,"product_type":"c1","uid":1564605,"ip_address":"","ucode":"119A0B00ABDA7B","user_header":"","comment_is_top":false,"comment_ctime":1584319707,"is_pvip":false,"replies":[{"id":72671,"content":"这儿是返回一个函数对象啊。x是这个函数对象的参数。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1584329096,"ip_address":"","comment_id":188065,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"\ntemplate &lt;typename F&gt;\nauto compose(F f)\n{\n  return [f](auto&amp;&amp;... x) {\n    return f(\n      forward&lt;decltype(x)&gt;(x)...);\n  };\n}\n老师，请问下auto&amp;&amp;... x没有出现在入参里，这个怎么产生呢？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487332,"discussion_content":"这儿是返回一个函数对象啊。x是这个函数对象的参数。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584329096,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169501,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1578366432,"is_pvip":false,"replies":[{"id":65796,"content":"--- 更新 ---\n\n我费了九牛二虎之力，终于把例子改得能在 gcc 4.8 下工作了。我觉得你不想维护这样的代码的。\n\n这儿空间不够。我放在这里：\n\nhttp:&#47;&#47;wyw.dcweb.cn&#47;download.asp?path=&amp;file=jike_18_gcc48.cpp\n\n我觉得升级 GCC 绝对是更好的主意。\n\n--- 原回复 ---\n没啥好办法……泛型lambda至少要求gcc 4.9。只能不用这类功能了。\n\n手写一个函数对象模板也许可以完成这个功能（让 f 成为其数据成员）。你可以试试看。我暂时没时间试验。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578393383,"ip_address":"","comment_id":169501,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"template &lt;typename F&gt;\nauto compose(F f)\n{\n    return [f](auto&amp;&amp;... x) {\n        return f(x...);\n    };\n}\n\n貌似用compiler(gcc version 4.8.5 20150623) 就会遇到下面编译错误\n&#47;&#47; In function ‘auto compose(F)’: \n&#47;&#47; error: expansion pattern ‘auto&amp;&amp;’ contains no argument packs\n&#47;&#47; return [f](auto&amp;&amp;... x) {\n\n用compiler(gcc version 8.3.1 20190311)就不会有问题。\n\n如果公司目前只允许用(gcc version 4.8.5 20150623)，请问有什么workaround?\n\n谢谢！\n","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480586,"discussion_content":"--- 更新 ---\n\n我费了九牛二虎之力，终于把例子改得能在 gcc 4.8 下工作了。我觉得你不想维护这样的代码的。\n\n这儿空间不够。我放在这里：\n\nhttp://wyw.dcweb.cn/download.asp?path=&amp;amp;file=jike_18_gcc48.cpp\n\n我觉得升级 GCC 绝对是更好的主意。\n\n--- 原回复 ---\n没啥好办法……泛型lambda至少要求gcc 4.9。只能不用这类功能了。\n\n手写一个函数对象模板也许可以完成这个功能（让 f 成为其数据成员）。你可以试试看。我暂时没时间试验。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578393383,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":388322,"user_name":"小一日一","can_delete":false,"product_type":"c1","uid":1301097,"ip_address":"北京","ucode":"0A506C2B918C14","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtVXiaJbfkpeXH4udkPUIlFte7z3HWMebdogk8jFpgFEkJ0ruGiawUMUcZj9RLpLkIWxV7QOzbHoSg/132","comment_is_top":false,"comment_ctime":1709886237,"is_pvip":false,"replies":[{"id":141509,"content":"你打算从 0 写到 255 吗？……再想想。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1710822374,"ip_address":"上海","comment_id":388322,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"2：auto bit_count = bit_count_t&lt;0, 1, 2, 3, 4, 5, 6, 7&gt;{};\n手动包参数展开","like_count":0},{"had_liked":false,"id":337815,"user_name":"Marc Chan","can_delete":false,"product_type":"c1","uid":2353732,"ip_address":"","ucode":"D365D6793F304B","user_header":"https://static001.geekbang.org/account/avatar/00/23/ea/44/cf0b2541.jpg","comment_is_top":false,"comment_ctime":1647075580,"is_pvip":false,"replies":[{"id":123579,"content":"最开始学 C++ 的，就找一本好的教材（如《C++ Primer 中文版》）。做练习，确保自己理解。\n\n每一种高级技巧都有应用的场景，但有些应用需要有一定的实际的项目经验。模板是一种抽象机制，主要用在写库、搭框架这样的场景。相信随着项目经验的增加和架构能力的拓展，你会看到它们的用武之地。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1647234056,"ip_address":"","comment_id":337815,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"吴老师，因为我的工作年限比较短，刚满一年。看到第18讲，觉得这么复杂的模板，好像在工作中也没碰到过，就感觉有点离自己太远了的感觉。虽说慢慢看也能够看懂，但是就是会感觉到看完以后也没地方用。\n请教一下这些内容往往会在什么地方用的多呢？或者说有没有一些更加适合初级C++ er 看的内容推荐呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":639671,"discussion_content":"你打算从 0 写到 255 吗？……再想想。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1710822375,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":323923,"user_name":"Peter","can_delete":false,"product_type":"c1","uid":2425556,"ip_address":"","ucode":"5E57A0FE948966","user_header":"https://static001.geekbang.org/account/avatar/00/25/02/d4/1e0bb504.jpg","comment_is_top":false,"comment_ctime":1638232824,"is_pvip":false,"replies":[{"id":117728,"content":"看汇编是最终确认方式。不是反汇编。用命令行选项来产生汇编文件。\n\nGCC&#47;Clang 下用 -S，MSVC 下用 &#47;Fa。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1638423829,"ip_address":"","comment_id":323923,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"怎么证明确实已经在编译期间已经计算过了呢？看反汇编吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556152,"discussion_content":"最开始学 C++ 的，就找一本好的教材（如《C++ Primer 中文版》）。做练习，确保自己理解。\n\n每一种高级技巧都有应用的场景，但有些应用需要有一定的实际的项目经验。模板是一种抽象机制，主要用在写库、搭框架这样的场景。相信随着项目经验的增加和架构能力的拓展，你会看到它们的用武之地。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647234057,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":316725,"user_name":"常振华","can_delete":false,"product_type":"c1","uid":2062252,"ip_address":"","ucode":"D61B40E1CCEFD5","user_header":"","comment_is_top":false,"comment_ctime":1634527285,"is_pvip":false,"replies":[{"id":115160,"content":"make_index_sequence&lt;256&gt; 是一个类型，你不能用类型（比如 int）去调用一个函数的。必须生成一个对象。make_index_sequence&lt;256&gt;() 也可以写成 make_index_sequence&lt;256&gt;{}，代表一个默认构造的该类型的对象。\n\n如果换更“普通”的代码为例，那 foo(int) 这样函数原型，你是不能用 foo(int) 这样的写法去调用的。你可以用 foo(42)，也可以用 foo(int{})——后者实际相当于 foo(int(0))，也相当于 foo(0)。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1634909204,"ip_address":"","comment_id":316725,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"auto bit_count = get_bit_count(make_index_sequence&lt;256&gt;());\n&lt;256&gt;后面是不是多了一对圆括号()？\nmake_index_sequence&lt;256&gt;展开之后，代入get_bit_count(index_sequence&lt;V...&gt;)模板，并没有一对圆括号()啊？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535385,"discussion_content":"看汇编是最终确认方式。不是反汇编。用命令行选项来产生汇编文件。\n\nGCC/Clang 下用 -S，MSVC 下用 /Fa。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638423829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":316717,"user_name":"常振华","can_delete":false,"product_type":"c1","uid":2062252,"ip_address":"","ucode":"D61B40E1CCEFD5","user_header":"","comment_is_top":false,"comment_ctime":1634523884,"is_pvip":false,"replies":[{"id":115159,"content":"大写的 Tuple 不是小写的 tuple。\n\n大写的 Tuple 代表一个抽象的类名称，你可以把它替换成为任何一个名称，比如全部改成 Tup 或者 T。但因为意图是 tuple，所以采用这种拼法。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1634908990,"ip_address":"","comment_id":316717,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"为什么一会儿是大写的Tuple，一会儿又是小写的tuple，C++库里的模板不是小写tuple吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528471,"discussion_content":"大写的 Tuple 不是小写的 tuple。\n\n大写的 Tuple 代表一个抽象的类名称，你可以把它替换成为任何一个名称，比如全部改成 Tup 或者 T。但因为意图是 tuple，所以采用这种拼法。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1634908990,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296930,"user_name":"chang","can_delete":false,"product_type":"c1","uid":2596026,"ip_address":"","ucode":"594EF8CB4477BD","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/2ibrq71Y5Ww3KDRibDxF1gt9YDEPuZkv4ITHEP1u4vvjpPDukkLoK4ngQy1hKKzccnsicLkUAda7sPpibR6Kyb0cfQ/132","comment_is_top":false,"comment_ctime":1623227933,"is_pvip":false,"replies":[{"id":107931,"content":"最靠谱的方案是看汇编。另外，如果变量是 constexpr，那就只有编译时能求值编译才能过了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1623370665,"ip_address":"","comment_id":296930,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"吴老师，请问怎么查看某些代码是否在编译时计算的？比如以下代码（剽窃了Geek_845be1同学的），怎么确定get_bit_count&lt;8&gt;()是否在编译时计算的？\n\n#include &lt;array&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nconstexpr std::size_t count_bits(std::size_t val) {\n  if (!val) {\n    return 0;\n  }\n  return 1 + count_bits(val &amp; (val - 1));\n}\n\ntemplate &lt;std::size_t N&gt; constexpr std::array&lt;std::size_t, N&gt; get_bit_count() {\n  std::array&lt;std::size_t, N&gt; counts{};\n  for (std::size_t i = 0; i &lt; N; ++i) {\n    counts[i] = count_bits(i);\n  }\n  return counts;\n}\n\nint main() {\n  auto counts = get_bit_count&lt;8&gt;();\n  for (auto n : counts) {\n    cout &lt;&lt; n &lt;&lt; &quot; &quot;;\n  }\n  cout &lt;&lt; endl;\n}","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521653,"discussion_content":"最靠谱的方案是看汇编。另外，如果变量是 constexpr，那就只有编译时能求值编译才能过了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623370665,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":288162,"user_name":"林林","can_delete":false,"product_type":"c1","uid":1613227,"ip_address":"","ucode":"7B6318B971E430","user_header":"https://static001.geekbang.org/account/avatar/00/18/9d/ab/6589d91a.jpg","comment_is_top":false,"comment_ctime":1618325770,"is_pvip":false,"replies":[{"id":104662,"content":"试试GCC？GCC的错误信息就会告诉你一个修改编译期递归深度的选项。其他就只能通过搜索引擎去找了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1618445521,"ip_address":"","comment_id":288162,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，我写了一个能在编译器计算出N以内的素数列表的代码，但在编译时提示“C1202 递归类型或函数依赖项上下文太复杂” (N=1000) ， 尝试过N=100时是可以编译成功的。 不知道有没有可以让N=1000也通过的办法（比如让编译器能递归更深的层）？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518534,"discussion_content":"试试GCC？GCC的错误信息就会告诉你一个修改编译期递归深度的选项。其他就只能通过搜索引擎去找了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618445521,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1613227,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9d/ab/6589d91a.jpg","nickname":"林林","note":"","ucode":"7B6318B971E430","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367900,"discussion_content":"GCC修改 -ftemplate-backtrace-limit 和 -ftemplate-depth参数可以使得编译器计算更深层的模板。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618492473,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1613227,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9d/ab/6589d91a.jpg","nickname":"林林","note":"","ucode":"7B6318B971E430","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368116,"discussion_content":"对。这种错误信息就比较友好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618572707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":367900,"ip_address":"","group_id":0},"score":368116,"extra":""}]}]},{"had_liked":false,"id":276633,"user_name":"某某某","can_delete":false,"product_type":"c1","uid":2426508,"ip_address":"","ucode":"179788267EE07D","user_header":"https://static001.geekbang.org/account/avatar/00/25/06/8c/6b1f88ec.jpg","comment_is_top":false,"comment_ctime":1612059391,"is_pvip":false,"replies":[{"id":100589,"content":"你可以自己看一下工具展开的结果：\n\nhttps:&#47;&#47;cppinsights.io&#47;s&#47;704e8a55","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1612327228,"ip_address":"","comment_id":276633,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"Tuple一下让我回到了vc6下写typelist的时代。但是现在的新代码反倒是看不太懂了，bit_count_t里面最后调用count_bits后的...是如何展开的。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514778,"discussion_content":"你可以自己看一下工具展开的结果：\n\nhttps://cppinsights.io/s/704e8a55","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612327228,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":238518,"user_name":"闲着也是贤者","can_delete":false,"product_type":"c1","uid":1451837,"ip_address":"","ucode":"DFADE250BA8E16","user_header":"https://static001.geekbang.org/account/avatar/00/16/27/3d/48340c0b.jpg","comment_is_top":false,"comment_ctime":1596187307,"is_pvip":false,"replies":[{"id":88135,"content":"sum_list 返回单一数值，不满足 square_list 的参数要求。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1596211682,"ip_address":"","comment_id":238518,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师， auto squared_sum = compose(sum_list, square_list);将这两个实参的位置替换后就不能工作呢，这是为什么呢？应该能正常工作，但是却出错了？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502773,"discussion_content":"sum_list 返回单一数值，不满足 square_list 的参数要求。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596211682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223853,"user_name":"吃鱼","can_delete":false,"product_type":"c1","uid":2005742,"ip_address":"","ucode":"CB7AC741E0E4B7","user_header":"https://static001.geekbang.org/account/avatar/00/1e/9a/ee/f996f864.jpg","comment_is_top":false,"comment_ctime":1591196902,"is_pvip":false,"replies":[{"id":82521,"content":"什么编译器，什么错误？按我要求的编译器和选项，都是可以通过的……\n\n另外，如果自己输入的话，也有出现小错误的可能。可以看一下我放在 GitHub 上的完整示例：\n\nhttps:&#47;&#47;github.com&#47;adah1972&#47;geek_time_cpp&#47;tree&#47;master&#47;18","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1591283841,"ip_address":"","comment_id":223853,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"只能大概看懂，最后的例子想尝试编译一下，结果 auto bit_count = get_bit_count(make_index_sequence&lt;256&gt;()); 这一句报错了 匹配不到模板，读到这么晚好伤心。。。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497263,"discussion_content":"什么编译器，什么错误？按我要求的编译器和选项，都是可以通过的……\n\n另外，如果自己输入的话，也有出现小错误的可能。可以看一下我放在 GitHub 上的完整示例：\n\nhttps://github.com/adah1972/geek_time_cpp/tree/master/18","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591283841,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":388322,"user_name":"小一日一","can_delete":false,"product_type":"c1","uid":1301097,"ip_address":"北京","ucode":"0A506C2B918C14","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtVXiaJbfkpeXH4udkPUIlFte7z3HWMebdogk8jFpgFEkJ0ruGiawUMUcZj9RLpLkIWxV7QOzbHoSg/132","comment_is_top":false,"comment_ctime":1709886237,"is_pvip":false,"replies":[{"id":141509,"content":"你打算从 0 写到 255 吗？……再想想。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1710822374,"ip_address":"上海","comment_id":388322,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"2：auto bit_count = bit_count_t&lt;0, 1, 2, 3, 4, 5, 6, 7&gt;{};\n手动包参数展开","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":639671,"discussion_content":"你打算从 0 写到 255 吗？……再想想。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1710822375,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":337815,"user_name":"Marc Chan","can_delete":false,"product_type":"c1","uid":2353732,"ip_address":"","ucode":"D365D6793F304B","user_header":"https://static001.geekbang.org/account/avatar/00/23/ea/44/cf0b2541.jpg","comment_is_top":false,"comment_ctime":1647075580,"is_pvip":false,"replies":[{"id":123579,"content":"最开始学 C++ 的，就找一本好的教材（如《C++ Primer 中文版》）。做练习，确保自己理解。\n\n每一种高级技巧都有应用的场景，但有些应用需要有一定的实际的项目经验。模板是一种抽象机制，主要用在写库、搭框架这样的场景。相信随着项目经验的增加和架构能力的拓展，你会看到它们的用武之地。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1647234056,"ip_address":"","comment_id":337815,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"吴老师，因为我的工作年限比较短，刚满一年。看到第18讲，觉得这么复杂的模板，好像在工作中也没碰到过，就感觉有点离自己太远了的感觉。虽说慢慢看也能够看懂，但是就是会感觉到看完以后也没地方用。\n请教一下这些内容往往会在什么地方用的多呢？或者说有没有一些更加适合初级C++ er 看的内容推荐呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556152,"discussion_content":"最开始学 C++ 的，就找一本好的教材（如《C++ Primer 中文版》）。做练习，确保自己理解。\n\n每一种高级技巧都有应用的场景，但有些应用需要有一定的实际的项目经验。模板是一种抽象机制，主要用在写库、搭框架这样的场景。相信随着项目经验的增加和架构能力的拓展，你会看到它们的用武之地。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647234057,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":323923,"user_name":"Peter","can_delete":false,"product_type":"c1","uid":2425556,"ip_address":"","ucode":"5E57A0FE948966","user_header":"https://static001.geekbang.org/account/avatar/00/25/02/d4/1e0bb504.jpg","comment_is_top":false,"comment_ctime":1638232824,"is_pvip":false,"replies":[{"id":117728,"content":"看汇编是最终确认方式。不是反汇编。用命令行选项来产生汇编文件。\n\nGCC&#47;Clang 下用 -S，MSVC 下用 &#47;Fa。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1638423829,"ip_address":"","comment_id":323923,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"怎么证明确实已经在编译期间已经计算过了呢？看反汇编吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535385,"discussion_content":"看汇编是最终确认方式。不是反汇编。用命令行选项来产生汇编文件。\n\nGCC/Clang 下用 -S，MSVC 下用 /Fa。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638423829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":316725,"user_name":"常振华","can_delete":false,"product_type":"c1","uid":2062252,"ip_address":"","ucode":"D61B40E1CCEFD5","user_header":"","comment_is_top":false,"comment_ctime":1634527285,"is_pvip":false,"replies":[{"id":115160,"content":"make_index_sequence&lt;256&gt; 是一个类型，你不能用类型（比如 int）去调用一个函数的。必须生成一个对象。make_index_sequence&lt;256&gt;() 也可以写成 make_index_sequence&lt;256&gt;{}，代表一个默认构造的该类型的对象。\n\n如果换更“普通”的代码为例，那 foo(int) 这样函数原型，你是不能用 foo(int) 这样的写法去调用的。你可以用 foo(42)，也可以用 foo(int{})——后者实际相当于 foo(int(0))，也相当于 foo(0)。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1634909204,"ip_address":"","comment_id":316725,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"auto bit_count = get_bit_count(make_index_sequence&lt;256&gt;());\n&lt;256&gt;后面是不是多了一对圆括号()？\nmake_index_sequence&lt;256&gt;展开之后，代入get_bit_count(index_sequence&lt;V...&gt;)模板，并没有一对圆括号()啊？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528475,"discussion_content":"make_index_sequence&amp;lt;256&amp;gt; 是一个类型，你不能用类型（比如 int）去调用一个函数的。必须生成一个对象。make_index_sequence&amp;lt;256&amp;gt;() 也可以写成 make_index_sequence&amp;lt;256&amp;gt;{}，代表一个默认构造的该类型的对象。\n\n如果换更“普通”的代码为例，那 foo(int) 这样函数原型，你是不能用 foo(int) 这样的写法去调用的。你可以用 foo(42)，也可以用 foo(int{})——后者实际相当于 foo(int(0))，也相当于 foo(0)。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1634909204,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":316717,"user_name":"常振华","can_delete":false,"product_type":"c1","uid":2062252,"ip_address":"","ucode":"D61B40E1CCEFD5","user_header":"","comment_is_top":false,"comment_ctime":1634523884,"is_pvip":false,"replies":[{"id":115159,"content":"大写的 Tuple 不是小写的 tuple。\n\n大写的 Tuple 代表一个抽象的类名称，你可以把它替换成为任何一个名称，比如全部改成 Tup 或者 T。但因为意图是 tuple，所以采用这种拼法。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1634908990,"ip_address":"","comment_id":316717,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"为什么一会儿是大写的Tuple，一会儿又是小写的tuple，C++库里的模板不是小写tuple吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528475,"discussion_content":"make_index_sequence&amp;lt;256&amp;gt; 是一个类型，你不能用类型（比如 int）去调用一个函数的。必须生成一个对象。make_index_sequence&amp;lt;256&amp;gt;() 也可以写成 make_index_sequence&amp;lt;256&amp;gt;{}，代表一个默认构造的该类型的对象。\n\n如果换更“普通”的代码为例，那 foo(int) 这样函数原型，你是不能用 foo(int) 这样的写法去调用的。你可以用 foo(42)，也可以用 foo(int{})——后者实际相当于 foo(int(0))，也相当于 foo(0)。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1634909204,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296930,"user_name":"chang","can_delete":false,"product_type":"c1","uid":2596026,"ip_address":"","ucode":"594EF8CB4477BD","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/2ibrq71Y5Ww3KDRibDxF1gt9YDEPuZkv4ITHEP1u4vvjpPDukkLoK4ngQy1hKKzccnsicLkUAda7sPpibR6Kyb0cfQ/132","comment_is_top":false,"comment_ctime":1623227933,"is_pvip":false,"replies":[{"id":107931,"content":"最靠谱的方案是看汇编。另外，如果变量是 constexpr，那就只有编译时能求值编译才能过了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1623370665,"ip_address":"","comment_id":296930,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"吴老师，请问怎么查看某些代码是否在编译时计算的？比如以下代码（剽窃了Geek_845be1同学的），怎么确定get_bit_count&lt;8&gt;()是否在编译时计算的？\n\n#include &lt;array&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nconstexpr std::size_t count_bits(std::size_t val) {\n  if (!val) {\n    return 0;\n  }\n  return 1 + count_bits(val &amp; (val - 1));\n}\n\ntemplate &lt;std::size_t N&gt; constexpr std::array&lt;std::size_t, N&gt; get_bit_count() {\n  std::array&lt;std::size_t, N&gt; counts{};\n  for (std::size_t i = 0; i &lt; N; ++i) {\n    counts[i] = count_bits(i);\n  }\n  return counts;\n}\n\nint main() {\n  auto counts = get_bit_count&lt;8&gt;();\n  for (auto n : counts) {\n    cout &lt;&lt; n &lt;&lt; &quot; &quot;;\n  }\n  cout &lt;&lt; endl;\n}","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528471,"discussion_content":"大写的 Tuple 不是小写的 tuple。\n\n大写的 Tuple 代表一个抽象的类名称，你可以把它替换成为任何一个名称，比如全部改成 Tup 或者 T。但因为意图是 tuple，所以采用这种拼法。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1634908990,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":288162,"user_name":"林林","can_delete":false,"product_type":"c1","uid":1613227,"ip_address":"","ucode":"7B6318B971E430","user_header":"https://static001.geekbang.org/account/avatar/00/18/9d/ab/6589d91a.jpg","comment_is_top":false,"comment_ctime":1618325770,"is_pvip":false,"replies":[{"id":104662,"content":"试试GCC？GCC的错误信息就会告诉你一个修改编译期递归深度的选项。其他就只能通过搜索引擎去找了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1618445521,"ip_address":"","comment_id":288162,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，我写了一个能在编译器计算出N以内的素数列表的代码，但在编译时提示“C1202 递归类型或函数依赖项上下文太复杂” (N=1000) ， 尝试过N=100时是可以编译成功的。 不知道有没有可以让N=1000也通过的办法（比如让编译器能递归更深的层）？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521653,"discussion_content":"最靠谱的方案是看汇编。另外，如果变量是 constexpr，那就只有编译时能求值编译才能过了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623370665,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":276633,"user_name":"某某某","can_delete":false,"product_type":"c1","uid":2426508,"ip_address":"","ucode":"179788267EE07D","user_header":"https://static001.geekbang.org/account/avatar/00/25/06/8c/6b1f88ec.jpg","comment_is_top":false,"comment_ctime":1612059391,"is_pvip":false,"replies":[{"id":100589,"content":"你可以自己看一下工具展开的结果：\n\nhttps:&#47;&#47;cppinsights.io&#47;s&#47;704e8a55","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1612327228,"ip_address":"","comment_id":276633,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"Tuple一下让我回到了vc6下写typelist的时代。但是现在的新代码反倒是看不太懂了，bit_count_t里面最后调用count_bits后的...是如何展开的。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518534,"discussion_content":"试试GCC？GCC的错误信息就会告诉你一个修改编译期递归深度的选项。其他就只能通过搜索引擎去找了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618445521,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1613227,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9d/ab/6589d91a.jpg","nickname":"林林","note":"","ucode":"7B6318B971E430","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367900,"discussion_content":"GCC修改 -ftemplate-backtrace-limit 和 -ftemplate-depth参数可以使得编译器计算更深层的模板。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618492473,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1613227,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9d/ab/6589d91a.jpg","nickname":"林林","note":"","ucode":"7B6318B971E430","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368116,"discussion_content":"对。这种错误信息就比较友好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618572707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":367900,"ip_address":"","group_id":0},"score":368116,"extra":""}]}]},{"had_liked":false,"id":238518,"user_name":"闲着也是贤者","can_delete":false,"product_type":"c1","uid":1451837,"ip_address":"","ucode":"DFADE250BA8E16","user_header":"https://static001.geekbang.org/account/avatar/00/16/27/3d/48340c0b.jpg","comment_is_top":false,"comment_ctime":1596187307,"is_pvip":false,"replies":[{"id":88135,"content":"sum_list 返回单一数值，不满足 square_list 的参数要求。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1596211682,"ip_address":"","comment_id":238518,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师， auto squared_sum = compose(sum_list, square_list);将这两个实参的位置替换后就不能工作呢，这是为什么呢？应该能正常工作，但是却出错了？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514778,"discussion_content":"你可以自己看一下工具展开的结果：\n\nhttps://cppinsights.io/s/704e8a55","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612327228,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223853,"user_name":"吃鱼","can_delete":false,"product_type":"c1","uid":2005742,"ip_address":"","ucode":"CB7AC741E0E4B7","user_header":"https://static001.geekbang.org/account/avatar/00/1e/9a/ee/f996f864.jpg","comment_is_top":false,"comment_ctime":1591196902,"is_pvip":false,"replies":[{"id":82521,"content":"什么编译器，什么错误？按我要求的编译器和选项，都是可以通过的……\n\n另外，如果自己输入的话，也有出现小错误的可能。可以看一下我放在 GitHub 上的完整示例：\n\nhttps:&#47;&#47;github.com&#47;adah1972&#47;geek_time_cpp&#47;tree&#47;master&#47;18","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1591283841,"ip_address":"","comment_id":223853,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"只能大概看懂，最后的例子想尝试编译一下，结果 auto bit_count = get_bit_count(make_index_sequence&lt;256&gt;()); 这一句报错了 匹配不到模板，读到这么晚好伤心。。。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502773,"discussion_content":"sum_list 返回单一数值，不满足 square_list 的参数要求。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596211682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217911,"user_name":"西加加","can_delete":false,"product_type":"c1","uid":1144416,"ip_address":"","ucode":"727238758A7F3D","user_header":"https://static001.geekbang.org/account/avatar/00/11/76/60/8ea658a9.jpg","comment_is_top":false,"comment_ctime":1589645001,"is_pvip":false,"replies":[{"id":80761,"content":"少了点东西，代码编译不过。你也没有展示如何使用你的这个模板。\n\n此外，第三问里有一些特殊的困难的。这就是为什么我在课中实现了 make_index_sequence，而不是更通用的 make_integer_sequence。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1589807498,"ip_address":"","comment_id":217911,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"当时学习模板的时候，试着写了一个玩耍性质的定义并初始化 array 为0...N， 正好和第三问的思路应该是一致的，也是一种展开 0...N 的写法吧。\ntemplate &lt;typename T&gt;\nstruct DefineArray&lt;T, true&gt; {\n    static constexpr auto m_res_arr = DefineArray&lt;typename T::next_type, T::cond_val&gt;::m_res_arr;\n};\n\ntemplate &lt;typename T&gt;\nstruct DefineArray&lt;T, false&gt; {\n    static constexpr auto m_res_arr = T::m_expand_arr;\n};\n\ntemplate &lt;typename T, T N, T... ELES&gt;\nstruct ExpandArray {\n    static constexpr array&lt;T, sizeof...(ELES)+1&gt; m_expand_arr = {N, ELES...};\n    static constexpr bool cond_val = (N-1 != 0);\n    using next_type = ExpandArray&lt;T, N-1, N, ELES...&gt;;\n};\n\n主要利用递归，不停的在前面加数就好了。\n","like_count":0},{"had_liked":false,"id":170611,"user_name":"三味","can_delete":false,"product_type":"c1","uid":1362403,"ip_address":"","ucode":"A580F715D1CC96","user_header":"https://static001.geekbang.org/account/avatar/00/14/c9/e3/28c16afa.jpg","comment_is_top":false,"comment_ctime":1578643876,"is_pvip":false,"replies":[{"id":66134,"content":"如果极客时间要支持留言用 Markdown，恐怕也得是可选的，否则有些不用 Markdown 的就要晕菜了……倒是长度限制有点妨碍贴代码。\n\n1. 代码对。\n\n意义回头我再说。别人的代码我就不评价了。反正这个最后我会贴个参考答案。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578667330,"ip_address":"","comment_id":170611,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"17和18讲可以说，真是劝退不少非c++读者吧。。。\n个人认为，如果不是需要写库，这两节的内容应该用得也不多吧。\n作为一名图形工作者，我看这些东西，其实是因为好多图形库（说的就是你，CGAL）都是模板代码，看得眼疼。。。\n实用更优先。当然，理解这些这几讲的内容还是很有帮助的。\n顺便说一句，留言区贴代码实在是太费劲了。。。极客时间不好好搞搞Markdown回复格式么？好多问题还要贴代码的，有的就是挺长的。。\n试着回答一下问题：\n1. compose不带任何参数，\ntemplate&lt;class... Args&gt;\nauto compose() {\n\treturn [](auto&amp;&amp;... args) { return compose&lt;Args...&gt;(); };\n}\n关于不带参数的意义，我理解的是，没有参数，那么就没有要执行的操作，那么就什么都不执行，返回个空。再深挖掘我就想不到了。。。这里我是为了形式上的统一，返回了一个依然什么都不做的自身。\n\n2. 想不到其他方法。。要再预编译阶段就展开256个数值。。我还是等等答案吧。。\n\n3. 自己实现是不可能的。这辈子都不可能。之前我看别人的代码，有通过借助写了一个辅助的PushBack操作来实现。这个自然不是我原创，拿来主义：\ntemplate &lt;class T, T... Ints&gt;\nstruct integer_sequence {};\n\ntemplate &lt;size_t... Ints&gt;\nusing index_sequence = integer_sequence&lt;size_t, Ints...&gt;;\n\ntemplate &lt;size_t, typename T&gt;\nstruct push_back{};\n\ntemplate &lt;size_t N, size_t... Ints&gt;\nstruct push_back&lt;N, index_sequence&lt;Ints...&gt;&gt; {\n\tusing type = index_sequence&lt;Ints..., N&gt;;\n};\n\ntemplate &lt;size_t N&gt;\nstruct index_sequence_helper {\n\tusing type = typename push_back&lt;N-1, typename index_sequence_helper&lt;N-1&gt;::type&gt;::type;\n};\n\ntemplate &lt;&gt;\nstruct index_sequence_helper&lt;1&gt; {\n\tusing type = index_sequence&lt;0&gt;;\n};\n\ntemplate &lt;size_t N&gt;\nusing make_index_sequence = typename index_sequence_helper&lt;N&gt;::type;","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481040,"discussion_content":"如果极客时间要支持留言用 Markdown，恐怕也得是可选的，否则有些不用 Markdown 的就要晕菜了……倒是长度限制有点妨碍贴代码。\n\n1. 代码对。\n\n意义回头我再说。别人的代码我就不评价了。反正这个最后我会贴个参考答案。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578667330,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169508,"user_name":"罗 乾 林","can_delete":false,"product_type":"c1","uid":1188222,"ip_address":"","ucode":"D0406F95176ABA","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/7e/fb725950.jpg","comment_is_top":false,"comment_ctime":1578366963,"is_pvip":false,"replies":[{"id":65786,"content":"呃，compose() 返回的正是 identity（C++20 才有）啊。😉\n\n这讲的题目都会有个参考答案的。我会最后公布。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578392219,"ip_address":"","comment_id":169508,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"1、看了老师的nvwa：\ninline auto compose()\n{\n    return [](auto&amp;&amp; x) -&gt; decltype(auto)\n    {\n        return std::forward&lt;decltype(x)&gt;(x);\n    };\n}\n\n感觉还是为了使用方便，真的需要还可以这样：compose(std::identity{})\n\n第3题在网上查了些资料，发现很复杂。\n\n本节的思考题都好难，求老师解答。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480589,"discussion_content":"呃，compose() 返回的正是 identity（C++20 才有）啊。😉\n\n这讲的题目都会有个参考答案的。我会最后公布。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578392219,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169429,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1578355527,"is_pvip":false,"replies":[{"id":65801,"content":"你这个compose带参数了呀……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578393569,"ip_address":"","comment_id":169429,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"#1\ntemplate &lt;typename F,\n          typename... Args&gt;\nauto compose(F f, Args... args)\n{\n  return [f, args...]() {\n    return f(\n      compose(args...)());\n  };\n}\n\n\ntemplate &lt;typename F&gt;\nauto compose(F f)\n{\n    return f；\n}\n\n如果这些函数都在函数体内操作一个公用的数据，而且这些函数依次执行的顺序反应了一定的工程需求，那么就是有意义的吧。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480553,"discussion_content":"你这个compose带参数了呀……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578393569,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183163,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1582964518,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"回过头来看这一课，才发现在make_index_sequence的例子中，最终的目标竟然是实例化后的模板的非类型实参而不是实例化后的模板对象本身。然后把这些非类型实参包用get&lt;&gt;模板展开。\n\n仔细想想，这当然是可以的，因为可变参数模板处理的就是参数包啊，而参数包可以是非类型相关的","like_count":1},{"had_liked":false,"id":361391,"user_name":"布拉姆","can_delete":false,"product_type":"c1","uid":1311125,"ip_address":"日本","ucode":"479FF27D73BCAD","user_header":"https://static001.geekbang.org/account/avatar/00/14/01/95/fd09e8a8.jpg","comment_is_top":false,"comment_ctime":1667461670,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"template&lt;class F, class Tuple, size_t ...I&gt;\ninline constexpr decltype(auto) apply_impl(F &amp;&amp; f, Tuple &amp;&amp; t, index_sequence&lt;I...&gt;)\n{\n  return f( get&lt;I&gt;(forward&lt;Tuple&gt;(t)) ... );\n}\n这里对于index_sequence&lt;I...&gt;里面 I 有多少项目, 就展开多少项. 假如tuple一共2项, 则展开为:\nreturn f(std::get&lt;0UL&gt;(std::forward&lt;std::pair&lt;int, int&gt; &gt;(t)), std::get&lt;1UL&gt;(std::forward&lt;std::pair&lt;int, int&gt; &gt;(t)));\n\n\n和下面原理一样:\ntemplate &lt;typename T, typename... Args&gt;\ninline unique_ptr&lt;T&gt; make_unique(Args&amp;&amp;... args)\n{\n  return unique_ptr&lt;T&gt;(new T(forward&lt;Args&gt;(args)...));\n}\nforward&lt;Args&gt;(args)... 会在编译时实际逐项展开 Args 和 args ，参数有多少项，展开后就是多少项。","like_count":0},{"had_liked":false,"id":299839,"user_name":"宵练2233","can_delete":false,"product_type":"c1","uid":2662996,"ip_address":"","ucode":"3EBDF8195040DA","user_header":"https://static001.geekbang.org/account/avatar/00/28/a2/54/49dfb810.jpg","comment_is_top":false,"comment_ctime":1624881331,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"贴一个也用到sequence的std::string enum编译期互转的例子\nhttps:&#47;&#47;tao-fu.gitee.io&#47;2020&#47;11&#47;09&#47;C++%E6%9D%82%E8%B0%88&#47;EnumStringConversion&#47;","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480553,"discussion_content":"你这个compose带参数了呀……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578393569,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217911,"user_name":"西加加","can_delete":false,"product_type":"c1","uid":1144416,"ip_address":"","ucode":"727238758A7F3D","user_header":"https://static001.geekbang.org/account/avatar/00/11/76/60/8ea658a9.jpg","comment_is_top":false,"comment_ctime":1589645001,"is_pvip":false,"replies":[{"id":80761,"content":"少了点东西，代码编译不过。你也没有展示如何使用你的这个模板。\n\n此外，第三问里有一些特殊的困难的。这就是为什么我在课中实现了 make_index_sequence，而不是更通用的 make_integer_sequence。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1589807498,"ip_address":"","comment_id":217911,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"当时学习模板的时候，试着写了一个玩耍性质的定义并初始化 array 为0...N， 正好和第三问的思路应该是一致的，也是一种展开 0...N 的写法吧。\ntemplate &lt;typename T&gt;\nstruct DefineArray&lt;T, true&gt; {\n    static constexpr auto m_res_arr = DefineArray&lt;typename T::next_type, T::cond_val&gt;::m_res_arr;\n};\n\ntemplate &lt;typename T&gt;\nstruct DefineArray&lt;T, false&gt; {\n    static constexpr auto m_res_arr = T::m_expand_arr;\n};\n\ntemplate &lt;typename T, T N, T... ELES&gt;\nstruct ExpandArray {\n    static constexpr array&lt;T, sizeof...(ELES)+1&gt; m_expand_arr = {N, ELES...};\n    static constexpr bool cond_val = (N-1 != 0);\n    using next_type = ExpandArray&lt;T, N-1, N, ELES...&gt;;\n};\n\n主要利用递归，不停的在前面加数就好了。\n","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495288,"discussion_content":"少了点东西，代码编译不过。你也没有展示如何使用你的这个模板。\n\n此外，第三问里有一些特殊的困难的。这就是为什么我在课中实现了 make_index_sequence，而不是更通用的 make_integer_sequence。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589807498,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170611,"user_name":"三味","can_delete":false,"product_type":"c1","uid":1362403,"ip_address":"","ucode":"A580F715D1CC96","user_header":"https://static001.geekbang.org/account/avatar/00/14/c9/e3/28c16afa.jpg","comment_is_top":false,"comment_ctime":1578643876,"is_pvip":false,"replies":[{"id":66134,"content":"如果极客时间要支持留言用 Markdown，恐怕也得是可选的，否则有些不用 Markdown 的就要晕菜了……倒是长度限制有点妨碍贴代码。\n\n1. 代码对。\n\n意义回头我再说。别人的代码我就不评价了。反正这个最后我会贴个参考答案。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578667330,"ip_address":"","comment_id":170611,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"17和18讲可以说，真是劝退不少非c++读者吧。。。\n个人认为，如果不是需要写库，这两节的内容应该用得也不多吧。\n作为一名图形工作者，我看这些东西，其实是因为好多图形库（说的就是你，CGAL）都是模板代码，看得眼疼。。。\n实用更优先。当然，理解这些这几讲的内容还是很有帮助的。\n顺便说一句，留言区贴代码实在是太费劲了。。。极客时间不好好搞搞Markdown回复格式么？好多问题还要贴代码的，有的就是挺长的。。\n试着回答一下问题：\n1. compose不带任何参数，\ntemplate&lt;class... Args&gt;\nauto compose() {\n\treturn [](auto&amp;&amp;... args) { return compose&lt;Args...&gt;(); };\n}\n关于不带参数的意义，我理解的是，没有参数，那么就没有要执行的操作，那么就什么都不执行，返回个空。再深挖掘我就想不到了。。。这里我是为了形式上的统一，返回了一个依然什么都不做的自身。\n\n2. 想不到其他方法。。要再预编译阶段就展开256个数值。。我还是等等答案吧。。\n\n3. 自己实现是不可能的。这辈子都不可能。之前我看别人的代码，有通过借助写了一个辅助的PushBack操作来实现。这个自然不是我原创，拿来主义：\ntemplate &lt;class T, T... Ints&gt;\nstruct integer_sequence {};\n\ntemplate &lt;size_t... Ints&gt;\nusing index_sequence = integer_sequence&lt;size_t, Ints...&gt;;\n\ntemplate &lt;size_t, typename T&gt;\nstruct push_back{};\n\ntemplate &lt;size_t N, size_t... Ints&gt;\nstruct push_back&lt;N, index_sequence&lt;Ints...&gt;&gt; {\n\tusing type = index_sequence&lt;Ints..., N&gt;;\n};\n\ntemplate &lt;size_t N&gt;\nstruct index_sequence_helper {\n\tusing type = typename push_back&lt;N-1, typename index_sequence_helper&lt;N-1&gt;::type&gt;::type;\n};\n\ntemplate &lt;&gt;\nstruct index_sequence_helper&lt;1&gt; {\n\tusing type = index_sequence&lt;0&gt;;\n};\n\ntemplate &lt;size_t N&gt;\nusing make_index_sequence = typename index_sequence_helper&lt;N&gt;::type;","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495288,"discussion_content":"少了点东西，代码编译不过。你也没有展示如何使用你的这个模板。\n\n此外，第三问里有一些特殊的困难的。这就是为什么我在课中实现了 make_index_sequence，而不是更通用的 make_integer_sequence。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589807498,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169508,"user_name":"罗 乾 林","can_delete":false,"product_type":"c1","uid":1188222,"ip_address":"","ucode":"D0406F95176ABA","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/7e/fb725950.jpg","comment_is_top":false,"comment_ctime":1578366963,"is_pvip":false,"replies":[{"id":65786,"content":"呃，compose() 返回的正是 identity（C++20 才有）啊。😉\n\n这讲的题目都会有个参考答案的。我会最后公布。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578392219,"ip_address":"","comment_id":169508,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"1、看了老师的nvwa：\ninline auto compose()\n{\n    return [](auto&amp;&amp; x) -&gt; decltype(auto)\n    {\n        return std::forward&lt;decltype(x)&gt;(x);\n    };\n}\n\n感觉还是为了使用方便，真的需要还可以这样：compose(std::identity{})\n\n第3题在网上查了些资料，发现很复杂。\n\n本节的思考题都好难，求老师解答。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481040,"discussion_content":"如果极客时间要支持留言用 Markdown，恐怕也得是可选的，否则有些不用 Markdown 的就要晕菜了……倒是长度限制有点妨碍贴代码。\n\n1. 代码对。\n\n意义回头我再说。别人的代码我就不评价了。反正这个最后我会贴个参考答案。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578667330,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169429,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1578355527,"is_pvip":false,"replies":[{"id":65801,"content":"你这个compose带参数了呀……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578393569,"ip_address":"","comment_id":169429,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"#1\ntemplate &lt;typename F,\n          typename... Args&gt;\nauto compose(F f, Args... args)\n{\n  return [f, args...]() {\n    return f(\n      compose(args...)());\n  };\n}\n\n\ntemplate &lt;typename F&gt;\nauto compose(F f)\n{\n    return f；\n}\n\n如果这些函数都在函数体内操作一个公用的数据，而且这些函数依次执行的顺序反应了一定的工程需求，那么就是有意义的吧。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480589,"discussion_content":"呃，compose() 返回的正是 identity（C++20 才有）啊。😉\n\n这讲的题目都会有个参考答案的。我会最后公布。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578392219,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183163,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1582964518,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"回过头来看这一课，才发现在make_index_sequence的例子中，最终的目标竟然是实例化后的模板的非类型实参而不是实例化后的模板对象本身。然后把这些非类型实参包用get&lt;&gt;模板展开。\n\n仔细想想，这当然是可以的，因为可变参数模板处理的就是参数包啊，而参数包可以是非类型相关的","like_count":1},{"had_liked":false,"id":361391,"user_name":"布拉姆","can_delete":false,"product_type":"c1","uid":1311125,"ip_address":"日本","ucode":"479FF27D73BCAD","user_header":"https://static001.geekbang.org/account/avatar/00/14/01/95/fd09e8a8.jpg","comment_is_top":false,"comment_ctime":1667461670,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"template&lt;class F, class Tuple, size_t ...I&gt;\ninline constexpr decltype(auto) apply_impl(F &amp;&amp; f, Tuple &amp;&amp; t, index_sequence&lt;I...&gt;)\n{\n  return f( get&lt;I&gt;(forward&lt;Tuple&gt;(t)) ... );\n}\n这里对于index_sequence&lt;I...&gt;里面 I 有多少项目, 就展开多少项. 假如tuple一共2项, 则展开为:\nreturn f(std::get&lt;0UL&gt;(std::forward&lt;std::pair&lt;int, int&gt; &gt;(t)), std::get&lt;1UL&gt;(std::forward&lt;std::pair&lt;int, int&gt; &gt;(t)));\n\n\n和下面原理一样:\ntemplate &lt;typename T, typename... Args&gt;\ninline unique_ptr&lt;T&gt; make_unique(Args&amp;&amp;... args)\n{\n  return unique_ptr&lt;T&gt;(new T(forward&lt;Args&gt;(args)...));\n}\nforward&lt;Args&gt;(args)... 会在编译时实际逐项展开 Args 和 args ，参数有多少项，展开后就是多少项。","like_count":0},{"had_liked":false,"id":299839,"user_name":"宵练2233","can_delete":false,"product_type":"c1","uid":2662996,"ip_address":"","ucode":"3EBDF8195040DA","user_header":"https://static001.geekbang.org/account/avatar/00/28/a2/54/49dfb810.jpg","comment_is_top":false,"comment_ctime":1624881331,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"贴一个也用到sequence的std::string enum编译期互转的例子\nhttps:&#47;&#47;tao-fu.gitee.io&#47;2020&#47;11&#47;09&#47;C++%E6%9D%82%E8%B0%88&#47;EnumStringConversion&#47;","like_count":0}]}