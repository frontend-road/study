{"id":73368,"title":"阿忠伯的特别放送 | 答疑解惑02","content":"<p>你好，我是胡忠想。今天我继续来给同学们做答疑，第二期答疑主要涉及微服务架构、注册中心和负载均衡算法，需要一定的基础，如果对这些内容不了解，可以先返回<a href=\"http://time.geekbang.org/column/article/39809\">专栏第14期</a>、<a href=\"http://time.geekbang.org/column/article/40684\">第17期</a>和<a href=\"http://time.geekbang.org/column/article/40883\">第18期</a>复习一下。</p><p><img src=\"https://static001.geekbang.org/resource/image/93/d0/93d4e17e36d4a31c7d44507aa84bb9d0.png?wh=750*756\" alt=\"\"></p><p>专栏里我主要讲的是基于RPC通信的微服务架构，除此之外还有一种微服务架构是基于MQ消息队列通信的，下面我就从这两种架构不同的适用场景来给你讲讲它们的区别。</p><p>基于RPC通信的微服务架构，其特点是一个服务依赖于其他服务返回的结果，只有依赖服务执行成功并返回后，这个服务才算调用成功。这种架构适用于用户请求是读请求的情况，就像下图所描述的那样，比如微博用户的一次Feed API请求，会调用Feed RPC获取关注人微博，调用Card RPC获取微博中的视频、文章等多媒体卡片信息，还会调用User RPC获取关注人的昵称和粉丝数等个人详细信息，只有在这些信息都获取成功后，这次用户的Feed API请求才算调用成功。</p><p><img src=\"https://static001.geekbang.org/resource/image/5d/d4/5d4b66935a2887ad9d79e55cebe3a0d4.png?wh=923*493\" alt=\"\"></p><p>而基于MQ消息队列通信的架构，其特点是服务之间的交互是通过消息发布与订阅的方式来完成的，一个服务往MQ消息队列发布消息，其他服务从MQ消息队列订阅消息并处理，发布消息的服务并不等待订阅消息服务处理的结果，而是直接返回调用成功。这种架构适用于用户请求是写请求的情况，就像下图所描述的那样，比如用户的写请求，无论是发博、评论还是赞都会首先调用Feed API，然后Feed API将用户的写请求消息发布到MQ中，然后就返回给用户请求成功。如果是发博请求，发博服务就会从MQ中订阅到这条消息，然后更新用户发博列表的缓存和数据库；如果是评论请求，评论服务就会从MQ中订阅到这条消息，然后更新用户发出评论的缓存和数据库，以及评论对象收到评论的缓存和数据库；如果是赞请求，赞服务就会从MQ中订阅到这条消息，然后更新用户发出赞的缓存和数据库，以及赞对象收到的赞的缓存和数据库。这样设计的话，就把写请求的返回与具体执行请求的服务进行解耦，给用户的体验是写请求已经执行成功，不需要等待具体业务逻辑执行完成。</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/ce/7e/ce4f9ddfb2f6bb6d9238c6be9fa6a77e.png?wh=1110*688\" alt=\"\"></p><p>总结一下就是，基于RPC通信和基于MQ消息队列通信的方式都可以实现微服务的拆分，两者的使用场景不同，RPC主要用于用户读请求的情况，MQ主要用于用户写请求的情况。对于大部分互联网业务来说，读请求要远远大于写请求，所以针对读请求的基于RPC通信的微服务架构的讨论也更多一些，但并不代表基于MQ消息队列不能实现，而是要区分开它们不同的应用场景。</p><p><img src=\"https://static001.geekbang.org/resource/image/42/5b/420ee09db55e76e380a8f9dbc47a6a5b.png?wh=750*2174\" alt=\"\"></p><p>要回答上面这三个问题，需要我来详细讲讲微博在使用注册中心时遇到的各种问题以及解决方案，主要包括三部分内容。</p><p><strong>1. 心跳开关保护机制</strong>。在专栏第17期，我讲过心跳开关保护机制是为了防止网络频繁抖动时，引起服务提供者节点心跳上报失败，从而导致注册中心中可用节点不断变化，使得大量服务消费者同时去请求注册中心获取最新的服务提供者节点列表，把注册中心的带宽占满。为了减缓注册中心带宽的占用，一个解决方案是，只给其中1/10的服务消费者返回最新的服务提供者节点列表信息，这样注册中心带宽就能减少到原来的1/10。在具体实践时，我们每次随机取10%，所以对于任意服务消费者来说，获取到最新服务提供者节点列表信息的时刻都是不固定的。在我的实践过程中，对于一个拥有上千个服务消费者的服务来说，某个服务消费者可能长达半小时后仍然没有获取到最新的服务提供者节点列表信息。所以说这种机制是有一定缺陷的，尤其是在服务正常情况下，心跳开关应该是关闭的，只有在网络频繁抖动时才打开。当网络频繁抖动时，注册中心的带宽就会暴涨，可以轻松把千兆网卡的前端机带宽打满，此时监控到带宽被打满时，就应该立即开启心跳开关保护机制。</p><p><strong>2. 服务节点摘除保护机制</strong>。设计心跳开关保护机制的目的，就是为了应对网络频繁抖动时引起的服务提供者节点心跳上报失败的情况。这个时候，注册中心会大量摘除服务提供者节点，从而引起服务提供者节点信息的变化。但其实大部分服务提供者节点本来是正常的，注册中心大量摘除服务提供者节点的情况是不应该发生的，所以可以设置一个服务节点摘除的保护机制，比如设置一个上限20%，正常情况下也不会有20%的服务节点被摘除，这样的话即使网络频繁抖动，也不会有大量节点信息变更，此时就不会出现大量服务消费者同时请求注册中心获取最新的服务提供者节点列表，进而把注册中心的带宽给占满。但这个机制也有一个缺陷，就是一些异常的节点即使心跳汇报异常应该被摘除，但也会因为摘除保护机制的原因没有从服务的可用节点列表中去掉，因此可能会影响线上服务。</p><p><strong>3. 静态注册中心机制</strong>。心跳开关保护机制和服务节点摘除保护机制都是治标不治本的权宜之计，不能根本解决网络频繁抖动情况下，引起的注册中心可用服务节点列表不准确的问题。所以我们提出了静态注册中心的机制，也就是注册中心中保存的服务节点列表只作为服务消费者的参考依据，在每个服务消费者这一端都维护着各自的可用服务节点列表，是否把某个服务节点标记为不可用，完全取决于每个服务消费者自身调用某个服务节点是否正常。如果连续调用超过一定的次数都不正常，就可以把这个服务节点在内存中标记为不可用状态，从可用服务节点列表中剔除。同时每个服务消费者还都有一个异步线程，始终在探测不可用的服务节点列表中的节点是否恢复正常，如果恢复正常的话就可以把这个节点重新加入到可用服务节点列表中去。</p><p>当然服务消费者也不是完全不与注册中心打交道，在服务启动时，服务消费者还是需要去注册中心中拉取所订阅的服务提供者节点列表信息，并且服务消费者还有一个异步线程，每隔一段时间都会去请求注册中心以查询服务提供者节点列表信息是否有变更，如果有变更就会请求注册中心获取最新的服务提供者节点列表信息。所以在有节点需要上下线时，服务消费者仍然能够拿到最新的服务提供者节点列表信息，只不过这个节点上下线的操作，一般是由开发或者运维人员人工操作，而不是像动态注册中心那样，可以通过心跳机制自动操作。</p><p><img src=\"https://static001.geekbang.org/resource/image/d2/4a/d22ad01d93c6ba1d791ee8cc4d5a604a.png?wh=750*1016\" alt=\"\"></p><p>关于最少活跃连接算法和自适应最优选择算法，它们的含义你可以返回<a href=\"http://time.geekbang.org/column/article/40883\">专栏第18期</a>回顾一下，本质上这两种算法都可以理解为局部最优解。</p><p>首先来看最少活跃连接算法，当客户端的请求发往某个服务端节点时，就给客户端同这个服务端节点的连接数加一；当某个服务端节点返回请求结果后，就给客户端同这个服务端节点的连接数减一，客户端会在本地内存中维护着同服务端每个节点的连接计数。从理论上讲，服务端节点性能越好，处理请求就快，同一时刻客户端同服务端节点之间保持的连接就越少，所以客户端每次请求选择服务端节点时，都会选择与客户端保持连接数最少的服务端节点，所以叫作“最少活跃连接算法”。但最少活跃连接算法会导致服务端节点的请求分布不均，我曾经在实践中见过一种极端情况，当服务端节点性能差异较大时，性能较好的节点的请求数量甚至达到了性能较差的节点请求数量的两倍。出现这种情况，一方面会导致某些服务端节点不能被充分利用，另一方面可能会导致请求量过高的服务端节点无法应对突发增长的流量而被压垮。</p><p>再来看下自适应最优选择算法，一方面客户端发往服务端节点每一次调用的耗时都会被记录到本地内存中，并且每隔一分钟计算客户端同服务端每个节点之间调用的平均响应时间，并在下一次调用的时候选择平均响应时间最快的节点。显然这样是收益最大的，尤其是服务跨多个数据中心部署的时候，同一个数据中心内的调用性能往往要优于跨数据中心的调用；另一方面客户端并不是每一次都选择平均响应时间最快的节点发起调用，为了防止出现类似最少活跃连接算法中服务端节点请求量差异太大的情况发生，把服务端节点按照平均响应时间进行排序，找出最差的20%的节点并适当降低调用权重，从而达到有效减少长尾请求的目的。</p><p>欢迎你在留言区写下自己学习、实践微服务的心得和体会，与我和其他同学一起讨论。你也可以点击“请朋友读”，把今天的内容分享给好友，或许这篇文章可以帮到他。</p><p></p>","neighbors":{"left":{"article_title":"阿忠伯的特别放送 | 答疑解惑01","id":72090},"right":{"article_title":"微博技术解密（上） | 微博信息流是如何实现的？","id":79602}},"comments":[{"had_liked":false,"id":198651,"user_name":"0xTang","can_delete":false,"product_type":"c1","uid":1019659,"ip_address":"","ucode":"82F5282EF3044B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8f/0b/a438de52.jpg","comment_is_top":false,"comment_ctime":1585462271,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14470364159","product_id":100014401,"comment_content":"Rpc同步，mq异步，使用场景不一样。","like_count":3},{"had_liked":false,"id":133208,"user_name":"Jarvis","can_delete":false,"product_type":"c1","uid":1087106,"ip_address":"","ucode":"4D780F9FD13F93","user_header":"https://static001.geekbang.org/account/avatar/00/10/96/82/8ac1e909.jpg","comment_is_top":false,"comment_ctime":1568443799,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10158378391","product_id":100014401,"comment_content":"最后一个问题，最少连接算法里面，客户端是只根据自己和服务端的连接数来算的吧？不需要知道服务端同所有客户端的连接数","like_count":2,"discussions":[{"author":{"id":1103511,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d6/97/0bdd1d8b.jpg","nickname":"lcc","note":"","ucode":"C57D0540367728","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312875,"discussion_content":"客户端记录自身的连接数就可以了，如果还需要记录其他客户端节点和服务端的关系的话过于复杂","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602841028,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71737,"user_name":"。","can_delete":false,"product_type":"c1","uid":1222200,"ip_address":"","ucode":"75B163F01F20F3","user_header":"https://static001.geekbang.org/account/avatar/00/12/a6/38/55483b8c.jpg","comment_is_top":false,"comment_ctime":1551423474,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10141358066","product_id":100014401,"comment_content":"老师你好，对于MQ的架构方案有一些疑问。<br><br>       以您说的“如果是赞请求，赞服务就会从 MQ 中订阅到这条消息，然后更新用户发出赞的缓存和数据库，以及赞对象收到的赞的缓存和数据库”为例，如果是这种异步的方式，当用户在点赞的时候，恰巧碰到作者删除了文章。用户认为点赞成功（发送完请求就显示成功），但其实&quot;点赞服务&quot;是执行失败的。对于写请求引入MQ的方案又会带来补偿、回滚的问题，该如何权衡？<br><br>实际方案中，对于写请求，采用接口同步调用是否真的会带来很大的性能影响。<br><br><br>","like_count":2,"discussions":[{"author":{"id":1177289,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f6/c9/4da2a82a.jpg","nickname":"黄大仙","note":"","ucode":"337B6E811CF47D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3492,"discussion_content":"策略一：强一致，可以做成事务，点赞失败进行回滚。策略二：不处理，删除文章，只是修改一下状态，并不物理删除，点赞执行成功，对后面业务并没有影响，用户刷新后这篇文章会被过滤掉。写请求，异步调用，理论上看，耗时肯定会上升，但吞吐量会变大。具体可以做下压力测试。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1564537708,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":276391,"user_name":"惘 闻","can_delete":false,"product_type":"c1","uid":1181650,"ip_address":"","ucode":"C5909F034BF072","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","comment_is_top":false,"comment_ctime":1611909032,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5906876328","product_id":100014401,"comment_content":"所以在有节点需要上下线时，服务消费者仍然能够拿到最新的服务提供者节点列表信息，只不过这个节点上下线的操作，一般是由开发或者运维人员人工操作，而不是像动态注册中心那样，可以通过心跳机制自动操作。<br>文中这最后一句话代表什么含义呀,难道通过心跳机制导致的注册中心节点上下线,服务消费者就拿不到最新列表了吗? 应该和手工操作一样都可以拿到吧.. 那为什么加个转折..看的我好郁闷","like_count":1},{"had_liked":false,"id":54322,"user_name":"arebya","can_delete":false,"product_type":"c1","uid":1142802,"ip_address":"","ucode":"074ECE8D6C1874","user_header":"https://static001.geekbang.org/account/avatar/00/11/70/12/aa74da82.jpg","comment_is_top":false,"comment_ctime":1545828545,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5840795841","product_id":100014401,"comment_content":"自适应最优选择算法就是所谓的WeightedResponseTimeRule","like_count":1},{"had_liked":false,"id":360333,"user_name":"小杨","can_delete":false,"product_type":"c1","uid":1252598,"ip_address":"北京","ucode":"C7C07AF005507C","user_header":"https://static001.geekbang.org/account/avatar/00/13/1c/f6/b5394713.jpg","comment_is_top":false,"comment_ctime":1666435163,"is_pvip":false,"discussion_count":0,"race_medal":3,"score":"1666435163","product_id":100014401,"comment_content":"这篇评论这么少","like_count":0},{"had_liked":false,"id":224818,"user_name":"信信","can_delete":false,"product_type":"c1","uid":1303865,"ip_address":"","ucode":"8DF0EC045579FD","user_header":"https://static001.geekbang.org/account/avatar/00/13/e5/39/951f89c8.jpg","comment_is_top":false,"comment_ctime":1591545590,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591545590","product_id":100014401,"comment_content":"请求量分布不匀，会引起长尾效应？耗时分布不匀才会引起长尾效应啊。。。<br>请求分布在上一段描述是由连接数决定的，是为了平衡响应时间吧？","like_count":0},{"had_liked":false,"id":104246,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1560697368,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560697368","product_id":100014401,"comment_content":"嗯，赞👍","like_count":0}]}