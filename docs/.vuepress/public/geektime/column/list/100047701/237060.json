{"id":237060,"title":"28 | 安全兜底：涉及钱时，必须考虑防刷、限量和防重","content":"<p>你好，我是朱晔。今天，我要和你分享的主题是，任何涉及钱的代码必须要考虑防刷、限量和防重，要做好安全兜底。</p><p>涉及钱的代码，主要有以下三类。</p><p>第一，代码本身涉及有偿使用的三方服务。如果因为代码本身缺少授权、用量控制而被利用导致大量调用，势必会消耗大量的钱，给公司造成损失。有些三方服务可能采用后付款方式的结算，出现问题后如果没及时发现，下个月结算时就会收到一笔数额巨大的账单。</p><p>第二，代码涉及虚拟资产的发放，比如积分、优惠券等。虽然说虚拟资产不直接对应货币，但一般可以在平台兑换具有真实价值的资产。比如，优惠券可以在下单时使用，积分可以兑换积分商城的商品。所以从某种意义上说，虚拟资产就是具有一定价值的钱，但因为不直接涉及钱和外部资金通道，所以容易产生随意性发放而导致漏洞。</p><p>第三，代码涉及真实钱的进出。比如，对用户扣款，如果出现非正常的多次重复扣款，小则用户投诉、用户流失，大则被相关管理机构要求停业整改，影响业务。又比如，给用户发放返现的付款功能，如果出现漏洞造成重复付款，涉及B端的可能还好，但涉及C端用户的重复付款可能永远无法追回。</p><p>前段时间拼多多一夜之间被刷了大量100元无门槛优惠券的事情，就是限量和防刷出了问题。</p><!-- [[[read_end]]] --><p>今天，我们就通过三个例子，和你说明如何在代码层面做好安全兜底。</p><h2>开放平台资源的使用需要考虑防刷</h2><p>我以真实遇到的短信服务被刷案例，和你说说防刷。</p><p>有次短信账单月结时发现，之前每个月是几千元的短信费用，这个月突然变为了几万元。查数据库记录发现，之前是每天发送几千条短信验证码，从某天开始突然变为了每天几万条，但注册用户数并没有激增。显然，这是短信接口被刷了。</p><p>我们知道，短信验证码服务属于开放性服务，由用户侧触发，且因为是注册验证码所以不需要登录就可以使用。如果我们的发短信接口像这样没有任何防刷的防护，直接调用三方短信通道，就相当于“裸奔”，很容易被短信轰炸平台利用：</p><pre><code>@GetMapping(&quot;wrong&quot;)\npublic void wrong() {\n    sendSMSCaptcha(&quot;13600000000&quot;);\n}\n\nprivate void sendSMSCaptcha(String mobile) {\n\t//调用短信通道\n}\n</code></pre><p>对于短信验证码这种开放接口，程序逻辑内需要有防刷逻辑。好的防刷逻辑是，对正常使用的用户毫无影响，只有疑似异常使用的用户才会感受到。对于短信验证码，有如下4种可行的方式来防刷。</p><p>第一种方式，<strong>只有固定的请求头才能发送验证码。</strong></p><p>也就是说，我们通过请求头中网页或App客户端传给服务端的一些额外参数，来判断请求是不是App发起的。其实，这种方式“防君子不防小人”。</p><p>比如，判断是否存在浏览器或手机型号、设备分辨率请求头。对于那些使用爬虫来抓取短信接口地址的程序来说，往往只能抓取到URL，而难以分析出请求发送短信还需要的额外请求头，可以看作第一道基本防御。</p><p>第二种方式，<strong>只有先到过注册页面才能发送验证码。</strong></p><p>对于普通用户来说，不管是通过App注册还是H5页面注册，一定是先进入注册页面才能看到发送验证码按钮，再点击发送。我们可以在页面或界面打开时请求固定的前置接口，为这个设备开启允许发送验证码的窗口，之后的请求发送验证码才是有效请求。</p><p>这种方式可以防御直接绕开固定流程，通过接口直接调用的发送验证码请求，并不会干扰普通用户。</p><p>第三种方式，<strong>控制相同手机号的发送次数和发送频次。</strong></p><p>除非是短信无法收到，否则用户不太会请求了验证码后不完成注册流程，再重新请求。因此，我们可以限制同一手机号每天的最大请求次数。验证码的到达需要时间，太短的发送间隔没有意义，所以我们还可以控制发送的最短间隔。比如，我们可以控制相同手机号一天只能发送10次验证码，最短发送间隔1分钟。</p><p>第四种方式，<strong>增加前置图形验证码。</strong></p><p>短信轰炸平台一般会收集很多免费短信接口，一个接口只会给一个用户发一次短信，所以控制相同手机号发送次数和间隔的方式不够有效。这时，我们可以考虑对用户体验稍微有影响，但也是最有效的方式作为保底，即将弹出图形验证码作为前置。</p><p>除了图形验证码，我们还可以使用其他更友好的人机验证手段（比如滑动、点击验证码等），甚至是引入比较新潮的无感知验证码方案（比如，通过判断用户输入手机号的打字节奏，来判断是用户还是机器），来改善用户体验。</p><p>此外，我们也可以考虑在监测到异常的情况下再弹出人机检测。比如，短时间内大量相同远端IP发送验证码的时候，才会触发人机检测。</p><p>总之，我们要确保，只有正常用户经过正常的流程才能使用开放平台资源，并且资源的用量在业务需求合理范围内。此外，还需要考虑做好短信发送量的实时监控，遇到发送量激增要及时报警。</p><p>接下来，我们一起看看限量的问题。</p><h2>虚拟资产并不能凭空产生无限使用</h2><p>虚拟资产虽然是平台方自己生产和控制，但如果生产出来可以立即使用就有立即变现的可能性。比如，因为平台Bug有大量用户领取高额优惠券，并立即下单使用。</p><p>在商家看来，这很可能只是一个用户支付的订单，并不会感知到用户使用平台方优惠券的情况；同时，因为平台和商家是事后结算的，所以会马上安排发货。而发货后基本就不可逆了，一夜之间造成了大量资金损失。</p><p>我们从代码层面模拟一个优惠券被刷的例子。</p><p>假设有一个CouponCenter类负责优惠券的产生和发放。如下是错误做法，只要调用方需要，就可以凭空产生无限的优惠券：</p><pre><code>@Slf4j\npublic class CouponCenter {\n    //用于统计发了多少优惠券\n    AtomicInteger totalSent = new AtomicInteger(0);\n    public void sendCoupon(Coupon coupon) {\n        if (coupon != null)\n            totalSent.incrementAndGet();\n    }\n\n    public int getTotalSentCoupon() {\n        return totalSent.get();\n    }\n\n    //没有任何限制，来多少请求生成多少优惠券\n    public Coupon generateCouponWrong(long userId, BigDecimal amount)              {\n        return new Coupon(userId, amount);\n    }\n}\n</code></pre><p>这样一来，使用CouponCenter的generateCouponWrong方法，想发多少优惠券就可以发多少：</p><pre><code>@GetMapping(&quot;wrong&quot;)\npublic int wrong() {\n    CouponCenter couponCenter = new CouponCenter();\n    //发送10000个优惠券\n    IntStream.rangeClosed(1, 10000).forEach(i -&gt; {\n        Coupon coupon = couponCenter.generateCouponWrong(1L, new BigDecimal(&quot;100&quot;));\n        couponCenter.sendCoupon(coupon);\n    });\n    return couponCenter.getTotalSentCoupon();\n}\n</code></pre><p><strong>更合适的做法是，把优惠券看作一种资源，其生产不是凭空的，而是需要事先申请</strong>，理由是：</p><ul>\n<li>虚拟资产如果最终可以对应到真实金钱上的优惠，那么，能发多少取决于运营和财务的核算，应该是有计划、有上限的。引言提到的无门槛优惠券，需要特别小心。有门槛优惠券的大量使用至少会带来大量真实的消费，而使用无门槛优惠券下的订单，可能用户一分钱都没有支付。</li>\n<li>即使虚拟资产不值钱，大量不合常规的虚拟资产流入市场，也会冲垮虚拟资产的经济体系，造成虚拟货币的极速贬值。有量的控制才有价值。</li>\n<li>资产的申请需要理由，甚至需要走流程，这样才可以追溯是什么活动需要、谁提出的申请，程序依据申请批次来发放。</li>\n</ul><p>接下来，我们按照这个思路改进一下程序。</p><p>首先，定义一个CouponBatch类，要产生优惠券必须先向运营申请优惠券批次，批次中包含了固定张数的优惠券、申请原因等信息：</p><pre><code>//优惠券批次\n@Data\npublic class CouponBatch {\n    private long id;\n    private AtomicInteger totalCount;\n    private AtomicInteger remainCount;\n    private BigDecimal amount;\n    private String reason;\n}\n</code></pre><p>在业务需要发放优惠券的时候，先申请批次，然后再通过批次发放优惠券：</p><pre><code>@GetMapping(&quot;right&quot;)\npublic int right() {\n    CouponCenter couponCenter = new CouponCenter();\n    //申请批次    \n    CouponBatch couponBatch = couponCenter.generateCouponBatch();\n    IntStream.rangeClosed(1, 10000).forEach(i -&gt; {\n        Coupon coupon = couponCenter.generateCouponRight(1L, couponBatch);\n        //发放优惠券\n        couponCenter.sendCoupon(coupon);\n    });\n    return couponCenter.getTotalSentCoupon();\n}\n</code></pre><p>可以看到，generateCouponBatch方法申请批次时，设定了这个批次包含100张优惠券。在通过generateCouponRight方法发放优惠券时，每发一次都会从批次中扣除一张优惠券，发完了就没有了：</p><pre><code>public Coupon generateCouponRight(long userId, CouponBatch couponBatch) {\n    if (couponBatch.getRemainCount().decrementAndGet() &gt;= 0) {\n        return new Coupon(userId, couponBatch.getAmount());\n    } else {\n        log.info(&quot;优惠券批次 {} 剩余优惠券不足&quot;, couponBatch.getId());\n        return null;\n    }\n}\n\n\npublic CouponBatch generateCouponBatch() {\n    CouponBatch couponBatch = new CouponBatch();\n    couponBatch.setAmount(new BigDecimal(&quot;100&quot;));\n    couponBatch.setId(1L);\n    couponBatch.setTotalCount(new AtomicInteger(100));\n    couponBatch.setRemainCount(couponBatch.getTotalCount());\n    couponBatch.setReason(&quot;XXX活动&quot;);\n    return couponBatch;\n}\n</code></pre><p>这样改进后的程序，一个批次最多只能发放100张优惠券：<br>\n<img src=\"https://static001.geekbang.org/resource/image/c9/cb/c971894532afd5f5150a6ab2fc0833cb.png?wh=976*230\" alt=\"\"></p><p>因为是Demo，所以我们只是凭空new出来一个Coupon。在真实的生产级代码中，一定是根据CouponBatch在数据库中插入一定量的Coupon记录，每一个优惠券都有唯一的ID，可跟踪、可注销。</p><p>最后，我们再看看防重。</p><h2>钱的进出一定要和订单挂钩并且实现幂等</h2><p>涉及钱的进出，需要做好以下两点。</p><p>第一，<strong>任何资金操作都需要在平台侧生成业务属性的订单，可以是优惠券发放订单，可以是返现订单，也可以是借款订单，一定是先有订单再去做资金操作</strong>。同时，订单的产生需要有业务属性。业务属性是指，订单不是凭空产生的，否则就没有控制的意义。比如，返现发放订单必须关联到原先的商品订单产生；再比如，借款订单必须关联到同一个借款合同产生。</p><p>第二，<strong>一定要做好防重，也就是实现幂等处理，并且幂等处理必须是全链路的</strong>。这里的全链路是指，从前到后都需要有相同的业务订单号来贯穿，实现最终的支付防重。</p><p>关于这两点，你可以参考下面的代码示例：</p><pre><code>//错误：每次使用UUID作为订单号\n@GetMapping(&quot;wrong&quot;)\npublic void wrong(@RequestParam(&quot;orderId&quot;) String orderId) {\n    PayChannel.pay(UUID.randomUUID().toString(), &quot;123&quot;, new BigDecimal(&quot;100&quot;));\n}\n\n//正确：使用相同的业务订单号\n@GetMapping(&quot;right&quot;)\npublic void right(@RequestParam(&quot;orderId&quot;) String orderId) {\n    PayChannel.pay(orderId, &quot;123&quot;, new BigDecimal(&quot;100&quot;));\n}\n//三方支付通道\npublic class PayChannel {\n    public static void pay(String orderId, String account, BigDecimal amount) {\n        ...\n    }\n}\n</code></pre><p>对于支付操作，我们一定是调用三方支付公司的接口或银行接口进行处理的。一般而言，这些接口都会有商户订单号的概念，对于相同的商户订单号，无法进行重复的资金处理，所以三方公司的接口可以实现唯一订单号的幂等处理。</p><p>但是，业务系统在实现资金操作时容易犯的错是，没有自始至终地使用一个订单号作为商户订单号，透传给三方支付接口。出现这个问题的原因是，比较大的互联网公司一般会把支付独立一个部门。支付部门可能会针对支付做聚合操作，内部会维护一个支付订单号，然后使用支付订单号和三方支付接口交互。最终虽然商品订单是一个，但支付订单是多个，相同的商品订单因为产生多个支付订单导致多次支付。</p><p>如果说，支付出现了重复扣款，我们可以给用户进行退款操作，但给用户付款的操作一旦出现重复付款，就很难把钱追回来了，所以更要小心。</p><p>这，就是全链路的意义，从一开始就需要先有业务订单产生，然后使用相同的业务订单号一直贯穿到最后的资金通路，才能真正避免重复资金操作。</p><h2>重点回顾</h2><p>今天，我从安全兜底聊起，和你分享了涉及钱的业务最需要做的三方面工作，防刷、限量和防重。</p><p>第一，使用开放的、面向用户的平台资源要考虑防刷，主要包括正常使用流程识别、人机识别、单人限量和全局限量等手段。</p><p>第二，虚拟资产不能凭空产生，一定是先有发放计划、申请批次，然后通过批次来生产资产。这样才能达到限量、有审计、能追溯的目的。</p><p>第三，真实钱的进出操作要额外小心，做好防重处理。不能凭空去操作用户的账户，每次操作以真实的订单作为依据，通过业务订单号实现全链路的幂等控制。</p><p>如果程序逻辑涉及有价值的资源或是真实的钱，我们必须有敬畏之心。程序上线后，人是有休息时间的，但程序是一直运行着的，如果产生安全漏洞，就很可能在一夜之间爆发，被大量人利用导致大量的金钱损失。</p><p>除了在流程上做好防刷、限量和防重控制之外，我们还需要做好三方平台调用量、虚拟资产使用量、交易量、交易金额等重要数据的监控报警，这样即使出现问题也能第一时间发现。</p><p>今天用到的代码，我都放在了GitHub上，你可以点击<a href=\"https://github.com/JosephZhu1983/java-common-mistakes\">这个链接</a>查看。</p><h2>思考与讨论</h2><ol>\n<li>防重、防刷都是事前手段，如果我们的系统正在被攻击或利用，你有什么办法及时发现问题吗？</li>\n<li>任何三方资源的使用一般都会定期对账，如果在对账中发现我们系统记录的调用量低于对方系统记录的使用量，你觉得一般是什么问题引起的呢？</li>\n</ol><p>有关安全兜底，你还有什么心得吗？我是朱晔，欢迎在评论区与我留言分享你的想法，也欢迎你把今天的内容分享给你的朋友或同事，一起交流。</p>","neighbors":{"left":{"article_title":"27 | 数据源头：任何客户端的东西都不可信任","id":235700},"right":{"article_title":"29 | 数据和代码：数据就是数据，代码就是代码","id":237139}},"comments":[{"had_liked":false,"id":219360,"user_name":"那时刻","can_delete":false,"product_type":"c1","uid":1150927,"ip_address":"","ucode":"B0D150856C3A4A","user_header":"https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg","comment_is_top":false,"comment_ctime":1590017312,"is_pvip":false,"replies":[{"id":"81045","content":"问题二，之前遇到的情况是，在事务内调用外部接口，调用超时后事务回滚本地就没有留下数据，对账的时候要对两边，不管哪方数据缺失都可能是因为有bug需要重视","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1590025067,"ip_address":"","comment_id":219360,"utype":1}],"discussion_count":4,"race_medal":1,"score":"87489363232","product_id":100047701,"comment_content":"1.对于防重，防刷。可以通过数据监控来实现类似熔断机制，比如数据监控某个功能在被刷，触发报警，同时熔断，暂时把该功能禁掉，减少损失。<br>2.想到一种情况，我们系统对于第三方调用返回值处理不当，导致有重复调用，也就是我们系统防重没有做好。","like_count":21,"discussions":[{"author":{"id":1079495,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/c7/083a3a0b.jpg","nickname":"新世界","note":"","ucode":"4473DC1505F158","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549681,"discussion_content":"是的，原则是事务内是不允许调用http的，一个http请求200毫秒，事务处理一条简单sql 1-2毫米，不是一个量级，直接调用会拖慢数据库","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1644204521,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495783,"discussion_content":"问题二，之前遇到的情况是，在事务内调用外部接口，调用超时后事务回滚本地就没有留下数据，对账的时候要对两边，不管哪方数据缺失都可能是因为有bug需要重视","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590025067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1162714,"avatar":"https://static001.geekbang.org/account/avatar/00/11/bd/da/3d76ea74.jpg","nickname":"看不到de颜色","note":"","ucode":"88348CCAE81931","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286591,"discussion_content":"这种场景下把调用外部接口放到事务内处理是否合适呢？有没有别的措施","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1593238275,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2378309,"avatar":"https://static001.geekbang.org/account/avatar/00/24/4a/45/e048531a.jpg","nickname":"迪米乌格斯","note":"","ucode":"1D4393746DCBCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374271,"discussion_content":"之前遇到的情况就是, 对账发现对方记录的api请求次数明显高于本地记录次数, 确实是因为api调用报错导致的事务回滚","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621088745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220970,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1590369240,"is_pvip":false,"replies":[{"id":"81473","content":"分析的不错","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1590370751,"ip_address":"","comment_id":220970,"utype":1}],"discussion_count":2,"race_medal":0,"score":"61719911384","product_id":100047701,"comment_content":"安全兜底 的问题，我的理解是分级别。<br>我的初步分级是 1，无限额涉及钱的问题（类似于退款），2，限额设计钱的问题（为用户提供的红包奖励等，这部分钱通常有限额） 3，无门槛虚拟货币（无门槛优惠券，无门槛积分等，因为这部分基本与货币可以等值，但是由于存在可以追回的机会，所以尚存一些容错） 4，有门槛虚拟货币（这部分，基本上，因为其目的就是促销，并不会带来实质上的经济损失，所以就并没有那么敏感了）<br><br>分级之后，再进一步划分处理的级别。因为人力和时间都是有限的，很难将所有的安全兜底都控制的那么完美，那就优先保证一些损失影响可能较大的业务上。<br><br>权重更高的业务，可以予以更严谨的测试，以及附加的人工审核机制，更频繁的监控等。相对权重较低的，就可能重视程度不那么高，仅保留较低限度的兜底。","like_count":15,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496283,"discussion_content":"分析的不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590370751,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2378309,"avatar":"https://static001.geekbang.org/account/avatar/00/24/4a/45/e048531a.jpg","nickname":"迪米乌格斯","note":"","ucode":"1D4393746DCBCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374272,"discussion_content":"老哥对分级的思想说的很到位, 确实真正生产环境下不可能一视同仁,必须分清楚级别.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621088824,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220968,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1590368723,"is_pvip":false,"replies":[{"id":"81478","content":"所有涉及到三方服务的交互，我建议request和response全部记录到（NOSQL）数据库中","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1590373584,"ip_address":"","comment_id":220968,"utype":1}],"discussion_count":2,"race_medal":0,"score":"44540041683","product_id":100047701,"comment_content":"对于，我方调用记录和对方调用记录不符，个人认知，假设，对方系统记录是正确的。<br>我猜测的点：我调用对方，对方存了，我没存。或者请求重发了，但是我方仅保存了一次。<br>首先需要通过日志来看。调用前日志，调用后结果日志，以及重发日志。综合来看自己请求是否存在问题。<br>甚至，中间部分时候，己方的服务器挂掉了，也会形成记录不一致的问题。<br>个人思路，以日志为切入点解决问题。","like_count":11,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496281,"discussion_content":"所有涉及到三方服务的交互，我建议request和response全部记录到（NOSQL）数据库中","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590373584,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2015438,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/c0/ce/eb1b4ae1.jpg","nickname":"可圈可丶","note":"","ucode":"EB527E176EDE91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":583407,"discussion_content":"这里的Nosql用ES好还是mongo好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660103529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":496281,"ip_address":"广东"},"score":583407,"extra":""}]}]},{"had_liked":false,"id":244655,"user_name":"2019","can_delete":false,"product_type":"c1","uid":1025580,"ip_address":"","ucode":"6514258263FC00","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a6/2c/b73b9dfe.jpg","comment_is_top":false,"comment_ctime":1598605416,"is_pvip":false,"replies":[{"id":"90025","content":"没错，先落地，再调三方","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1598611073,"ip_address":"","comment_id":244655,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27368409192","product_id":100047701,"comment_content":"调用第三方服务进行支付金币，我们的做法是不管支付成不成功都把数据放入本方数据库，只不过增加一个状态字段来判断是否支付成功。如果支付成功一定是接口三方返回成功，如果失败有可能三方服务有问题或者网络问题。支付失败的情况，给用户友好提示，让用户再次支付，由于三方支付是幂等的，用上次调用的业务号直接支付，支付成功就修改状态。这样两方进行对账不会产生重复入账的情况。","like_count":7,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504656,"discussion_content":"没错，先落地，再调三方","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598611073,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219373,"user_name":"大胖子呀、","can_delete":false,"product_type":"c1","uid":1258251,"ip_address":"","ucode":"4BADF8096254BE","user_header":"https://static001.geekbang.org/account/avatar/00/13/33/0b/fd18c8ab.jpg","comment_is_top":false,"comment_ctime":1590020187,"is_pvip":false,"replies":[{"id":"81044","content":"问题一，的确监控是较好的手段，关键在于报警阈值怎么设置，我觉得可以对比昨天同时，上周同时的量，发现差异达到一定百分比报警。此外，对于活动可以申请单独的活动监控标签，单独呈现曲线，做好量的预估，超量报警，有的时候大盘很大的话活动给整个大盘带来的变化不明显。","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1590024883,"ip_address":"","comment_id":219373,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18769889371","product_id":100047701,"comment_content":"最近正好要做小程序发放红包的功能，学习了，后面实施的时候一定要注意。<br><br>第一次回答下问题，经验不足，有错误之处还请指出。<br><br>问题一：如果系统正在被攻击的话，应该会出现几种异常情况，比如短时间内会有大量资金流出（涉及金额实时扣除的）、同一个用户短时间内有大量的数据重复，等等。系统可以根据具体业务情况，针对可能出现的异常情况进行监控，如果出现的话及时预警。<br><br>问题二：可能是因为调用第三方接口成功了，但是存入自己系统数据库出现错误，没有及时发现处理，造成了数据丢失，有可能就会导致这种情况。","like_count":5,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495786,"discussion_content":"问题一，的确监控是较好的手段，关键在于报警阈值怎么设置，我觉得可以对比昨天同时，上周同时的量，发现差异达到一定百分比报警。此外，对于活动可以申请单独的活动监控标签，单独呈现曲线，做好量的预估，超量报警，有的时候大盘很大的话活动给整个大盘带来的变化不明显。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590024883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":269161,"user_name":"郑思雨","can_delete":false,"product_type":"c1","uid":1474579,"ip_address":"","ucode":"F1F4B08FC94E7D","user_header":"https://static001.geekbang.org/account/avatar/00/16/80/13/df2a0ced.jpg","comment_is_top":false,"comment_ctime":1608542072,"is_pvip":false,"replies":[{"id":"97624","content":"安全方面设计上的确可以考虑很多：双向对账、多步流程整体考虑安全校验、兜底策略、防止外部猜测业务逻辑、不但在内部校验通过外部再实现一套业务逻辑实现校验、设定业务策略常识作为底线","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1608549768,"ip_address":"","comment_id":269161,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5903509368","product_id":100047701,"comment_content":"说到安全手段，最先想到的是校验+对账。<br><br>校验要注意的一点是 对业务case的穷举，在业务流程比较复杂的情况，需要多考虑边界情况，比如两条指令共同决定一个行为，那么两条指令的先后顺序、两条指令同时到达的校验有很大的差异。<br><br>而对账更多的是及时发现问题，及时止损。公司内部可以做准实时对账，与外部平台有对接时，只能做成T+1的，实时性差，发现问题也就更晚。<br><br>举2个例子：<br>用户提现时需要传递 token 和 账户ID，这时我们就可以做一个 token 和 账户ID关系的校验，看看token对应的User 和 账户ID 是否能对应上，防止攻击者用一个token 提现多个账户的余额。毕竟获取多个token比获取多个账户ID要困难很多。（这个例子是一个用户可以有多个账户的设计）<br><br>账户出金的安全性：可以通过设计来规避问题，比如 设计 冻结、解冻 等功能。","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512170,"discussion_content":"安全方面设计上的确可以考虑很多：双向对账、多步流程整体考虑安全校验、兜底策略、防止外部猜测业务逻辑、不但在内部校验通过外部再实现一套业务逻辑实现校验、设定业务策略常识作为底线","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608549768,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222242,"user_name":"睁眼看世界","can_delete":false,"product_type":"c1","uid":1206388,"ip_address":"","ucode":"F94CF34BC5B2AC","user_header":"https://static001.geekbang.org/account/avatar/00/12/68/74/461b202d.jpg","comment_is_top":false,"comment_ctime":1590724288,"is_pvip":false,"replies":[{"id":"81969","content":"其实幂等考虑2方面：<br>1、幂等依据，可以是每次交互生成的token，可以是客户端的序列号，可以是有意义的业务订单号<br>2、根据幂等依据进行防重处理：<br>1）限制：比如锁方式、状态机控制<br>2）去重方式","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1590744140,"ip_address":"","comment_id":222242,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590724288","product_id":100047701,"comment_content":"老师，请教下，全链路幂等处理的话，如果是web请求，除了前端防抖的话，后端可以如何处理？","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496725,"discussion_content":"其实幂等考虑2方面：\n1、幂等依据，可以是每次交互生成的token，可以是客户端的序列号，可以是有意义的业务订单号\n2、根据幂等依据进行防重处理：\n1）限制：比如锁方式、状态机控制\n2）去重方式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590744140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}