{"id":332605,"title":"110 | Go编程模式：委托和反转控制","content":"<p>你好，我是陈皓，网名左耳朵耗子。</p><p>控制反转（<a href=\"https://en.wikipedia.org/wiki/Inversion_of_control\">Inversion of Control</a><a href=\"https://en.wikipedia.org/wiki/Inversion_of_control\">，loC</a>  ）是一种软件设计的方法，它的主要思想是把控制逻辑与业务逻辑分开，不要在业务逻辑里写控制逻辑，因为这样会让控制逻辑依赖于业务逻辑，而是反过来，让业务逻辑依赖控制逻辑。</p><p>我之前在《<a href=\"https://coolshell.cn/articles/9949.html\">IoC/DIP其实是一种管理思想</a>》这篇文章中，举过一个开关和电灯的例子。其实，这里的开关就是控制逻辑，电器是业务逻辑。我们不要在电器中实现开关，而是要把开关抽象成一种协议，让电器都依赖它。这样的编程方式可以有效降低程序复杂度，并提升代码重用度。</p><p>面向对象的设计模式我就不提了，我们来看看Go语言使用Embed结构的一个示例。</p><h2>嵌入和委托</h2><h3>结构体嵌入</h3><p>在Go语言中，我们可以很轻松地把一个结构体嵌到另一个结构体中，如下所示：</p><pre><code>type Widget struct {\n    X, Y int\n}\ntype Label struct {\n    Widget        // Embedding (delegation)\n    Text   string // Aggregation\n}\n</code></pre><p>在这个示例中，我们把 <code>Widget</code>嵌入到了 <code>Label</code> 中，于是，我们可以这样使用：</p><pre><code>label := Label{Widget{10, 10}, &quot;State:&quot;}\n\nlabel.X = 11\nlabel.Y = 12\n</code></pre><p>如果在<code>Label</code> 结构体里出现了重名，就需要解决重名问题，例如，如果成员 <code>X</code> 重名，我们就要用 <code>label.X</code>表明是自己的<code>X</code> ，用 <code>label.Wedget.X</code> 表明是嵌入过来的。</p><p>有了这样的嵌入，我们就可以像UI组件一样，在结构的设计上进行层层分解了。比如，我可以新写出两个结构体 <code>Button</code> 和 <code>ListBox</code>：</p><!-- [[[read_end]]] --><pre><code>type Button struct {\n    Label // Embedding (delegation)\n}\n\ntype ListBox struct {\n    Widget          // Embedding (delegation)\n    Texts  []string // Aggregation\n    Index  int      // Aggregation\n}\n</code></pre><h3>方法重写</h3><p>然后，我们需要两个接口：用Painter把组件画出来；Clicker 用于表明点击事件。</p><pre><code>type Painter interface {\n    Paint()\n}\n \ntype Clicker interface {\n    Click()\n}\n</code></pre><p>当然，对于 <code>Lable</code> 来说，只有 <code>Painter</code> ，没有<code>Clicker</code>；对于 <code>Button</code> 和 <code>ListBox</code>来说，<code>Painter</code> 和<code>Clicker</code>都有。</p><p>我们来看一些实现：</p><pre><code>func (label Label) Paint() {\n  fmt.Printf(&quot;%p:Label.Paint(%q)\\n&quot;, &amp;label, label.Text)\n}\n\n//因为这个接口可以通过 Label 的嵌入带到新的结构体，\n//所以，可以在 Button 中重载这个接口方法\nfunc (button Button) Paint() { // Override\n    fmt.Printf(&quot;Button.Paint(%s)\\n&quot;, button.Text)\n}\nfunc (button Button) Click() {\n    fmt.Printf(&quot;Button.Click(%s)\\n&quot;, button.Text)\n}\n\n\nfunc (listBox ListBox) Paint() {\n    fmt.Printf(&quot;ListBox.Paint(%q)\\n&quot;, listBox.Texts)\n}\nfunc (listBox ListBox) Click() {\n    fmt.Printf(&quot;ListBox.Click(%q)\\n&quot;, listBox.Texts)\n}\n</code></pre><p>说到这儿，我要重点提醒你一下，<code>Button.Paint()</code> 接口可以通过 Label 的嵌入带到新的结构体，如果 <code>Button.Paint()</code> 不实现的话，会调用 <code>Label.Paint()</code> ，所以，在 <code>Button</code> 中声明 <code>Paint()</code> 方法，相当于Override。</p><h3>嵌入结构多态</h3><p>从下面的程序中，我们可以看到整个多态是怎么执行的。</p><pre><code>button1 := Button{Label{Widget{10, 70}, &quot;OK&quot;}}\nbutton2 := NewButton(50, 70, &quot;Cancel&quot;)\nlistBox := ListBox{Widget{10, 40}, \n    []string{&quot;AL&quot;, &quot;AK&quot;, &quot;AZ&quot;, &quot;AR&quot;}, 0}\n\nfor _, painter := range []Painter{label, listBox, button1, button2} {\n    painter.Paint()\n}\n \nfor _, widget := range []interface{}{label, listBox, button1, button2} {\n  widget.(Painter).Paint()\n  if clicker, ok := widget.(Clicker); ok {\n    clicker.Click()\n  }\n  fmt.Println() // print a empty line \n}\n</code></pre><p>我们可以使用接口来多态，也可以使用泛型的 <code>interface{}</code> 来多态，但是需要有一个类型转换。</p><h2>反转控制</h2><p>我们再来看一个示例。</p><p>我们有一个存放整数的数据结构，如下所示：</p><pre><code>type IntSet struct {\n    data map[int]bool\n}\nfunc NewIntSet() IntSet {\n    return IntSet{make(map[int]bool)}\n}\nfunc (set *IntSet) Add(x int) {\n    set.data[x] = true\n}\nfunc (set *IntSet) Delete(x int) {\n    delete(set.data, x)\n}\nfunc (set *IntSet) Contains(x int) bool {\n    return set.data[x]\n}\n</code></pre><p>其中实现了 <code>Add()</code> 、<code>Delete()</code> 和 <code>Contains()</code> 三个操作，前两个是写操作，后一个是读操作。</p><h3>实现Undo功能</h3><p>现在，我们想实现一个 Undo 的功能。我们可以再包装一下  <code>IntSet</code>  ，变成 <code>UndoableIntSet</code>  ，代码如下所示：</p><pre><code>type UndoableIntSet struct { // Poor style\n    IntSet    // Embedding (delegation)\n    functions []func()\n}\n \nfunc NewUndoableIntSet() UndoableIntSet {\n    return UndoableIntSet{NewIntSet(), nil}\n}\n \n\nfunc (set *UndoableIntSet) Add(x int) { // Override\n    if !set.Contains(x) {\n        set.data[x] = true\n        set.functions = append(set.functions, func() { set.Delete(x) })\n    } else {\n        set.functions = append(set.functions, nil)\n    }\n}\n\n\nfunc (set *UndoableIntSet) Delete(x int) { // Override\n    if set.Contains(x) {\n        delete(set.data, x)\n        set.functions = append(set.functions, func() { set.Add(x) })\n    } else {\n        set.functions = append(set.functions, nil)\n    }\n}\n\nfunc (set *UndoableIntSet) Undo() error {\n    if len(set.functions) == 0 {\n        return errors.New(&quot;No functions to undo&quot;)\n    }\n    index := len(set.functions) - 1\n    if function := set.functions[index]; function != nil {\n        function()\n        set.functions[index] = nil // For garbage collection\n    }\n    set.functions = set.functions[:index]\n    return nil\n}\n</code></pre><p>我来解释下这段代码。</p><ul>\n<li>我们在 <code>UndoableIntSet</code> 中嵌入了<code>IntSet</code> ，然后Override了 它的 <code>Add()</code>和 <code>Delete()</code> 方法；</li>\n<li><code>Contains()</code> 方法没有Override，所以，就被带到 <code>UndoableInSet</code> 中来了。</li>\n<li>在Override的 <code>Add()</code>中，记录 <code>Delete</code> 操作；</li>\n<li>在Override的 <code>Delete()</code> 中，记录 <code>Add</code> 操作；</li>\n<li>在新加入的  <code>Undo()</code> 中进行Undo操作。</li>\n</ul><p>用这样的方式为已有的代码扩展新的功能是一个很好的选择。这样，就可以在重用原有代码功能和新的功能中达到一个平衡。但是，这种方式最大的问题是，Undo操作其实是一种控制逻辑，并不是业务逻辑，所以，在复用 Undo这个功能时，是有问题的，因为其中加入了大量跟 <code>IntSet</code> 相关的业务逻辑。</p><h3>反转依赖</h3><p>现在我们来看另一种方法。</p><p>我们先声明一种函数接口，表示我们的Undo控制可以接受的函数签名是什么样的：</p><pre><code>type Undo []func()\n</code></pre><p>有了这个协议之后，我们的Undo控制逻辑就可以写成下面这样：</p><pre><code>func (undo *Undo) Add(function func()) {\n  *undo = append(*undo, function)\n}\n\nfunc (undo *Undo) Undo() error {\n  functions := *undo\n  if len(functions) == 0 {\n    return errors.New(&quot;No functions to undo&quot;)\n  }\n  index := len(functions) - 1\n  if function := functions[index]; function != nil {\n    function()\n    functions[index] = nil // For garbage collection\n  }\n  *undo = functions[:index]\n  return nil\n}\n</code></pre><p>看到这里，你不必觉得奇怪， <code>Undo</code> 本来就是一个类型，不必是一个结构体，是一个函数数组也没有什么问题。</p><p>然后，我们在IntSet里嵌入 Undo，接着在 <code>Add()</code> 和 <code>Delete()</code> 里使用刚刚的方法，就可以完成功能了。</p><pre><code>type IntSet struct {\n    data map[int]bool\n    undo Undo\n}\n \nfunc NewIntSet() IntSet {\n    return IntSet{data: make(map[int]bool)}\n}\n\nfunc (set *IntSet) Undo() error {\n    return set.undo.Undo()\n}\n \nfunc (set *IntSet) Contains(x int) bool {\n    return set.data[x]\n}\n\nfunc (set *IntSet) Add(x int) {\n    if !set.Contains(x) {\n        set.data[x] = true\n        set.undo.Add(func() { set.Delete(x) })\n    } else {\n        set.undo.Add(nil)\n    }\n}\n \nfunc (set *IntSet) Delete(x int) {\n    if set.Contains(x) {\n        delete(set.data, x)\n        set.undo.Add(func() { set.Add(x) })\n    } else {\n        set.undo.Add(nil)\n    }\n}\n</code></pre><p>这个就是控制反转，不是由控制逻辑 <code>Undo</code>  来依赖业务逻辑 <code>IntSet</code>，而是由业务逻辑 <code>IntSet</code> 依赖 <code>Undo</code> 。这里依赖的是其实是一个协议，<strong>这个协议是一个没有参数的函数数组。</strong>可以看到，这样一来，我们 Undo 的代码就可以复用了。</p><p>好了，这节课就到这里。如果你觉得今天的内容对你有所帮助，欢迎你帮我分享给更多人。</p>","neighbors":{"left":{"article_title":"109 | Go 编程模式：Functional Options","id":332603},"right":{"article_title":"111 | Go 编程模式：Map-Reduce","id":332606}},"comments":[{"had_liked":false,"id":297361,"user_name":"debugtalk","can_delete":false,"product_type":"c1","uid":1005452,"ip_address":"","ucode":"D6F0E57E79808C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/8c/8fba0bdd.jpg","comment_is_top":false,"comment_ctime":1623483644,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14508385532","product_id":100002201,"comment_content":"手动点赞","like_count":4},{"had_liked":false,"id":356673,"user_name":"limix","can_delete":false,"product_type":"c1","uid":1166614,"ip_address":"安徽","ucode":"76401FF54AE0D8","user_header":"https://static001.geekbang.org/account/avatar/00/11/cd/16/981cc4f8.jpg","comment_is_top":false,"comment_ctime":1662497687,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662497687","product_id":100002201,"comment_content":"控制逻辑的特征是可复用性比较高，多场景可用，而业务逻辑的特征是专用性，控制逻辑，应该复用控制逻辑，而不是复用也许逻辑","like_count":1},{"had_liked":false,"id":355611,"user_name":"cvvz","can_delete":false,"product_type":"c1","uid":1943722,"ip_address":"日本","ucode":"FC55B0D628B266","user_header":"https://static001.geekbang.org/account/avatar/00/1d/a8/aa/de5e7d26.jpg","comment_is_top":false,"comment_ctime":1661563079,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661563079","product_id":100002201,"comment_content":"反转控制：<br>第一种改写方法——继承，好处是原有代码可以复用，控制逻辑和业务逻辑解耦，坏处是通用的控制逻辑无法复用<br>第二种改写方法——反转控制，好处是复用通用的控制逻辑，坏处是要修改原有代码的逻辑，把控制逻辑嵌入到了业务逻辑中","like_count":0},{"had_liked":false,"id":331468,"user_name":"Geek_ce6971","can_delete":false,"product_type":"c1","uid":2016458,"ip_address":"","ucode":"8826A1C6BF8355","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLAHCRt6dBUDTFX4EotyV5NDbYiaUXH109SOdRprLky1PUc9jm2K7QvoCpkZuCyqMCNSogUpdFzMJw/132","comment_is_top":false,"comment_ctime":1642595481,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1642595481","product_id":100002201,"comment_content":"实现undo功能，有个地方是写反了吗<br>在 Override 的 Add()中，记录 Delete 操作；在 Override 的 Delete() 中，记录 Add 操作；","like_count":0,"discussions":[{"author":{"id":2941058,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/e0/82/17d214df.jpg","nickname":"李海洋","note":"","ucode":"5D642B3F9BF09B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570927,"discussion_content":"记录的是undo要做的事","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651996807,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327152,"user_name":"方勇(gopher)","can_delete":false,"product_type":"c1","uid":1290625,"ip_address":"","ucode":"D199911C4CFEF5","user_header":"https://static001.geekbang.org/account/avatar/00/13/b1/81/13f23d1e.jpg","comment_is_top":false,"comment_ctime":1639963018,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639963018","product_id":100002201,"comment_content":"日常中有些装饰器其实可以用这种方式替换","like_count":0},{"had_liked":false,"id":323972,"user_name":"衡子","can_delete":false,"product_type":"c1","uid":1109433,"ip_address":"","ucode":"0AED79FC9D14BB","user_header":"https://static001.geekbang.org/account/avatar/00/10/ed/b9/825b2411.jpg","comment_is_top":false,"comment_ctime":1638244298,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638244298","product_id":100002201,"comment_content":"厉害了👍","like_count":0},{"had_liked":false,"id":306751,"user_name":"一光年","can_delete":false,"product_type":"c1","uid":1576620,"ip_address":"","ucode":"779FEC7C42C1F7","user_header":"https://static001.geekbang.org/account/avatar/00/18/0e/ac/198a5c0c.jpg","comment_is_top":false,"comment_ctime":1628690628,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628690628","product_id":100002201,"comment_content":"控制逻辑依赖业务逻辑，不如让业务容器依赖控制逻辑","like_count":0},{"had_liked":false,"id":304262,"user_name":"Geek_46da16","can_delete":false,"product_type":"c1","uid":2707429,"ip_address":"","ucode":"C9A677461A979B","user_header":"","comment_is_top":false,"comment_ctime":1627309338,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627309338","product_id":100002201,"comment_content":"会玩，","like_count":0}]}