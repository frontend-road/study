{"id":627909,"title":"11｜Ranges（一）：数据序列处理的新工具","content":"<p>你好，我是卢誉声。</p><p>第一章，我们详细了解了C++20支持的三大核心语言特性变更——Modules、Concepts和Coroutines。但是通常意义上所讲的C++，其实是由核心语言特性和标准库（C++ Standard Library）共同构成的。</p><p>对标准库来说，标准模板库STL（Standard Template Library）作为标准库的子集，是标准库的重要组成部分，是C++中存储数据、访问数据和执行计算的重要基础设施。我们可以通过它简化代码编写，避免重新造轮子。</p><p>不过标准模板库不是完美的，它也在不断演进。原本的标准模板库，并没有给大规模、复杂数据的处理方面提供很好的支持。这是因为，C++在语言和库的设计上，让C++函数式编程变得复杂且冗长。为了解决这个问题，从C++20开始支持了Ranges——这是C++支持函数式编程的一个巨大飞跃。</p><p>特别是C++在运行时性能方面的绝对优势，Ranges让C++逐渐成为了处理大规模复杂数据的新贵。所以，我们更有必要掌握它，我相信在学完Ranges后，你会爱上这种便利的数据处理方式！</p><p>好了，话不多说，就让我们从C++函数式编程开始今天的学习吧（项目的完整代码，你可以<a href=\"https://github.com/samblg/cpp20-plus-indepth\">这里</a>获取）。</p><!-- [[[read_end]]] --><h2>前置知识</h2><p>如果你对函数式编程并没有清晰的概念，建议先简单了解一下后面的前置知识，如果已经清楚了，可以直接跳过，从“函数式编程之困”开始看。</p><p>我们先说说函数式编程的主要思路——把所有的运算过程尽量写成z=f(g(x))这种嵌套函数的形式，而最简化的形式自然就是y=f(x)。这里函数嵌套可以不只有一层，每个函数的参数数量也能灵活调整，甚至可以完全使用“数学函数”来描述整个计算过程。</p><p>函数式编程众多特性中，最重要的就是“数据不可变性”与“高阶函数”。</p><p>数据不可变性也叫“无副作用”，也就是在计算过程中永远不会修改参数，也不会产生不必要的外部状态变化。我们都知道数学中函数参数不可修改，且具有幂等性，函数式编程自然也就要保持这些性质。</p><p>并行计算的性能瓶颈往往在于“竞争”，而竞争的原因就是程序执行中产生的“副作用”，无副作用的程序往往才能将并行计算的优势最大化。我们熟知的MapReduce，正是函数式编程思路在分布式计算中的一种实现。</p><p>再来说说“高阶函数”的意思。函数式编程的参数可以是另一个函数表达式，在函数的实现中可以通过调用参数来调用函数，假设f(x,g)的定义为g(x)，那么g就是一个高阶函数。函数式编程中将函数作为“一等公民”，所以这种特性自然也就不足为奇。</p><h2>函数式编程之困</h2><p>了解了函数式编程的含义，我们讨论一下在C++20之前，在C++中实现函数式编程到底遇到了什么困境？</p><p>事实上，STL从一开始就为函数式编程提供了支持。首先，STL中最重要的三个概念是容器、迭代器和算法，分别用于解决数据存储、访问和计算问题。我们可以通过模板参数来指定它们的数据元素类型。</p><p>STL要求数据元素类型具备“可拷贝”性（copyable）。也就是说，STL中的所有操作（包括数据的赋值和计算）都需要数据类型支持拷贝，这种可拷贝性自然也就从设计上保证了函数式编程的“不可变性”。</p><p>STL的算法函数都可以使用函数指针或仿函数（functor）来处理迭代器指向的数据元素，其本质也就是函数式编程中的高阶函数。同时，在C++11引入Lambda表达式之后，使用高阶函数变得方便一些。</p><p>不过，使用STL进行函数式编程仍然非常痛苦，我们经常需要将数据的处理流程拆分成多个计算步骤，而这些计算步骤之间是相互依赖的（也就是前一步的输出都是后一步的输入）。</p><p>为了让你更直观地感受这点，我们来看一个采用C++ STL的传统函数式编程案例。</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;cstdint&gt;\n\nint main() {\n&nbsp;&nbsp;&nbsp; std::vector&lt;int32_t&gt; numbers{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1, 2, 3, 4, 5\n&nbsp;&nbsp;&nbsp; };\n\n&nbsp;&nbsp;&nbsp; std::vector&lt;int32_t&gt; doubledNumbers;\n&nbsp;&nbsp;&nbsp; std::transform(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; numbers.begin(), numbers.end(), std::back_inserter(doubledNumbers),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](int32_t number) { return number * 2; }\n&nbsp;&nbsp;&nbsp; );\n\n&nbsp;&nbsp;&nbsp; std::vector&lt;int32_t&gt; filteredNumbers;\n&nbsp;&nbsp;&nbsp; std::copy_if(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doubledNumbers.begin(), doubledNumbers.end(), std::back_inserter(filteredNumbers),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](int32_t number) { return number &lt; 5; }\n&nbsp;&nbsp;&nbsp; );\n\n&nbsp;&nbsp;&nbsp; std::for_each(filteredNumbers.begin(), filteredNumbers.end(), [](int32_t number) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; number &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp; });\n\n&nbsp;&nbsp;&nbsp; return 0;\n}\n</code></pre><p>看过代码我们不难发现，在C++中，我们需要定义大量变量，来存储每一步的计算结果，然后将其作为下一步计算的输入。而且C++算法函数需要使用“迭代器”作为参数，每次调用C++算法时，都需要指定容器的begin和end。STL也不会检查迭代器的合法性，我们不得不编写很多错误处理代码，所以使用STL的代码变得更加复杂冗长。</p><p>为了彻底解决C++中函数式编程的障碍，从C++20开始提出了Ranges——这是一套可扩展且泛用的算法与迭代接口，开发者可以更方便地组合这些接口。相比传统STL算法，Ranges更健壮，不易引发错误。</p><p>我们用Ranges把上面的案例改写一下。</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;cstdint&gt;\n#include &lt;ranges&gt;\n\nint main() {\n&nbsp;&nbsp;&nbsp; namespace ranges = std::ranges;\n&nbsp;&nbsp;&nbsp; namespace views = std::views;\n\n&nbsp;&nbsp;&nbsp; std::vector&lt;int32_t&gt; numbers{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1, 2, 3, 4, 5\n&nbsp;&nbsp;&nbsp; };\n\n&nbsp;&nbsp;&nbsp; ranges::for_each(numbers |\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; views::transform([](int32_t number) { return number * 2; }) |\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; views::filter([](int32_t number) { return number &lt; 5; }),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [](int32_t number) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; number &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp; );\n\n&nbsp;&nbsp;&nbsp; return 0;\n}\n</code></pre><p>这段代码的具体含义我先卖个关子，等后面学习完Ranges后，你可以回顾一下这段代码，到时候就能理解了。但无论如何，你都能发现采用Ranges改写后代码明显变得简洁清晰了。</p><p>接下来，就让我们继续探索，看看Ranges是如何实现这种变化的吧！</p><h2>Ranges</h2><p>Ranges的核心概念就是range。Ranges库将range定义为一个concept，你可以把range简单理解成一个具备begin迭代器和end迭代器的对象，相当于是传统STL容器对象的一种泛化。</p><p>Ranges提供了一些工具函数，用于访问传统STL容器和Ranges视图的数据。接下来，我们就来详细介绍Ranges的这些工具函数。</p><h3>获取迭代器</h3><p>首先，range本身是一个concept。因此，Ranges提供了通用函数，来获取range对象的迭代器，包括所有满足range约束的对象的迭代器。为了帮你更好地理解，我们结合一段示例代码看一看。</p><pre><code class=\"language-c++\">#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;ranges&gt;\n#include &lt;iostream&gt;\n \nint main() {\n    namespace ranges = std::ranges;\n \n    // 首先，调用ranges::begin和ranges::end函数获取容器的迭代器\n    // 接着，通过迭代器访问数据中的元素\n    std::vector&lt;int&gt; v = { 3, 1, 4, 1, 5, 9, 2, 6 };\n    auto start = ranges::begin(v);\n    std::cout &lt;&lt; \"[0]: \" &lt;&lt; *start &lt;&lt; std::endl;\n \n    auto curr = start;\n    curr++;\n    std::cout &lt;&lt; \"[1]: \" &lt;&lt; *curr &lt;&lt; std::endl;\n \n    std::cout &lt;&lt; \"[4]: \" &lt;&lt; *(curr + 3) &lt;&lt; std::endl;\n \n    auto stop = ranges::end(v);\n    std::sort(start, stop);\n \n    // 最后，调用ranges::cbegin和ranges::cend循环输出排序后的数据\n    for (auto it = ranges::cbegin(v);\n        it != ranges::cend(v);\n        ++it\n    ) {\n        std::cout &lt;&lt; *it &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n \n    return 0;\n}\n</code></pre><p>从这段代码中可以看出，ranges迭代器的操作和STL的标准迭代器操作是一样的。我在这里列出Ranges中的所有迭代器函数。你可以发现，这些迭代器跟传统STL中的迭代器并无二致。</p><p><img src=\"https://static001.geekbang.org/resource/image/a4/13/a49b2bb66958a588a3632784148dcc13.jpg?wh=3500x1520\" alt=\"\"></p><h3>获取长度</h3><p>Ranges也提供了获取range长度的函数——ranges::size和ranges::ssize。它们都可以获取某个range的长度，不过前者返回值是无符号整数，后者返回值是有符号整数。</p><p>我写了一段简单的示例代码，供你参考。</p><pre><code class=\"language-c++\">#include &lt;vector&gt;\n#include &lt;ranges&gt;\n#include &lt;iostream&gt;\n&nbsp;\nint main() {\n&nbsp;&nbsp;&nbsp; namespace ranges = std::ranges;\n&nbsp;\n&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; v = { 3, 1, 4, 1, 5, 9, 2, 6 };\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; ranges::size(v) &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; ranges::ssize(v) &lt;&lt; std::endl;\n&nbsp;\n&nbsp;&nbsp;&nbsp; return 0;\n}\n</code></pre><h3>获取数据指针</h3><p>事实上，我们在使用range时会发现，有些range是支持获取内部数据缓冲区的，这在操纵std::vector这样的容器时非常有帮助。针对这类range，Ranges提供了下列函数用于获取其内部数据缓冲区指针。</p><ul>\n<li>ranges::data：获取某个range的连续数据缓冲区。</li>\n<li>ranges::cdata：上述函数的只读版本。</li>\n</ul><p>我同样附上了示例代码。</p><pre><code class=\"language-c++\">#include &lt;vector&gt;\n#include &lt;ranges&gt;\n#include &lt;iostream&gt;\n&nbsp;\nint main() {\n&nbsp;&nbsp;&nbsp; namespace ranges = std::ranges;\n&nbsp;\n&nbsp;&nbsp;&nbsp; std::vector&lt;int&gt; v = { 3, 1, 4, 1, 5, 9, 2, 6 };\n&nbsp;\n&nbsp;&nbsp;&nbsp; auto data = ranges::data(v);\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"[1]\" &lt;&lt; data[1] &lt;&lt; std::endl;\n&nbsp;&nbsp;&nbsp; data[2] = 10;\n&nbsp;\n&nbsp;&nbsp;&nbsp; auto cdata = ranges::cdata(v);\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; \"[2]\" &lt;&lt; cdata[2] &lt;&lt; std::endl;\n&nbsp;\n&nbsp;&nbsp;&nbsp; return 0;\n}\n</code></pre><p>在这段代码中，我们通过ranges::data获取了内部缓冲区，并通过data修改了数据。最后，通过cdata获取只读缓冲区并输出了修改后的数据。</p><h3>悬空迭代器</h3><p>不同于传统STL，ranges为了保证代码的健壮性，特意提供了编译时对悬空迭代器的检测，主要的工具就是ranges::dangling这一类型。</p><p>那么什么是悬空迭代器呢？我们来看一下这段代码。你可以暂停一下，自己推测一下这段代码能不能成功编译。</p><pre><code class=\"language-c++\">#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;ranges&gt;\n#include &lt;iostream&gt;\n&nbsp;\nint main() {\n&nbsp;&nbsp;&nbsp; namespace ranges = std::ranges;\n&nbsp;\n&nbsp;&nbsp;&nbsp; auto getArray = [] { return std::vector{ 0, 1, 0, 1 }; };\n&nbsp;\n&nbsp;&nbsp;&nbsp; // 编译成功\n&nbsp;&nbsp;&nbsp; auto start = std::find(getArray().begin(), getArray().end(), 1);\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; *start &lt;&lt; std::endl;\n&nbsp;\n&nbsp;&nbsp;&nbsp; // 编译失败\n&nbsp;&nbsp;&nbsp; auto rangeStart = ranges::find(getArray(), 1);\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; *rangeStart &lt;&lt; std::endl;\n&nbsp;\n&nbsp;&nbsp;&nbsp; return 0;\n}\n</code></pre><p>这段代码最终会编译失败。原因是调用getArray()返回的vector对象是函数调用返回的右值（rvalue），我们没有将它赋值给任何一个变量，也没有通过引用来延长它的生命周期。</p><p>因此，vector对象在ranges::find函数执行后，生命周期就已经结束了。此时find函数返回的迭代器指向的数据区域其实已经被释放，导致迭代器变成了“悬空”状态——类似于指向被释放缓冲区的悬空指针。</p><p>但是，通过传统的find算法访问迭代器是不会报编译错误的。不过运行时会出问题，毕竟数据已经被释放了。</p><p>这就是Ranges的独特之处，<strong>可以在编译时提前检查可能出现悬空引用的问题，提高代码的健壮性</strong>。</p><p>那么，<strong>错误检测的原理到底是什么呢？</strong></p><p>这得益于从C++20开始支持的concepts。所有Ranges的算法针对不满足borrowed_range约束的对象，会直接返回ranges::dangling——该类型是一个空对象，表示悬空迭代器。</p><p>所以说，下面的代码可以用于主动检测range的悬空迭代器。</p><pre><code class=\"language-c++\">#include &lt;vector&gt;\n#include &lt;ranges&gt;\n#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n&nbsp;\nint main() {\n&nbsp;&nbsp;&nbsp; namespace ranges = std::ranges;\n&nbsp;\n&nbsp;&nbsp;&nbsp; auto getArray = [] { return std::vector{ 0, 1, 0, 1 }; };\n&nbsp;\n&nbsp;&nbsp;&nbsp; auto rangeStart = ranges::find(getArray(), 1);\n&nbsp;&nbsp;&nbsp; // 通过type_traits在运行时检测返回的迭代器是否为悬空迭代器（不会引发编译错误）\n&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; std::is_same_v&lt;ranges::dangling, decltype(rangeStart)&gt; &lt;&lt; std::endl;\n\n&nbsp;&nbsp;&nbsp; // 通过static_assert主动提供容易理解的编译期错误（会引发编译错误！！！）\n&nbsp;&nbsp;&nbsp; static_assert(!std::is_same_v&lt;ranges::dangling, decltype(rangeStart)&gt;, \"rangeStart is dangling!!!!\");\n&nbsp;\n&nbsp;&nbsp;&nbsp; return 0;\n}\n</code></pre><p>在这段代码中，我们通过is_same_v来检测返回迭代器的类型，查看它是否为悬空迭代器。同时，这段代码还演示了怎么使用static_assert来实现编译时错误检测，我们可以借助于它来提供易于理解的编译时错误信息。</p><h2>总结</h2><p>在Ranges出现之前，C++里用STL进行函数式编程非常痛苦，主要原因是代码复杂冗长。为了彻底解决这种障碍，从C++20开始提出了Ranges。</p><p>Ranges库提供了range这个新的concept，作为传统容器的一种泛化。在这个基础上，Ranges库为range提供了传统迭代器和算法的支持，让开发者可以像传统容器一样使用range，甚至在使用为range提供的constraint algorithm时，比传统算法更加方便。</p><p>Ranges本质上是一套可扩展且泛用的算法与迭代接口，它更加健壮，不容易引发错误。Ranges库充分利用了C++20提供的concepts，用于描述不同类型的range的约束。你可以参考后面的表格详细了解。</p><p><img src=\"https://static001.geekbang.org/resource/image/35/e0/35dcc8ec3258f406a3b1d4058e6621e0.jpg?wh=3500x2773\" alt=\"\"></p><p>这些concepts对我们的后续讨论非常重要。下一讲，我们还会讨论具体约束，到时你不妨再看看这份表格，回顾一下里面对各种约束表达式的解释，加深记忆和理解。</p><h2>思考题</h2><p>Ranges提供了以往C++中不存在的数据迭代特性，特别是越界这种错误检测。那么在你平时的工作中使用C++时，会采用哪些实践方法来避免越界？</p><p>另外，我们提到了range是一个concept，那么这个concept要如何定义呢？你可以参考以下提示，根据我们之前所讲的C++ Concepts来实现一下你的版本。</p><p>1.可以通过std::ranges::begin获取到该类型对象的begin迭代器。</p><p>2.可以通过std::ranges::end获取到该类型对象的end迭代器。</p><p>欢迎说出你的看法，与大家一起分享。我们一同交流。下一讲见！</p>","neighbors":{"left":{"article_title":"期中周｜期中测试题，你做对了么？","id":631120},"right":{"article_title":"12｜Ranges（二）：用“视图”破除函数式编程之困","id":627920}},"comments":[{"had_liked":false,"id":386303,"user_name":"李云龙","can_delete":false,"product_type":"c1","uid":3201926,"ip_address":"北京","ucode":"785924B16BE788","user_header":"https://static001.geekbang.org/account/avatar/00/30/db/86/51ec4c41.jpg","comment_is_top":false,"comment_ctime":1704513371,"is_pvip":false,"replies":[{"id":140884,"content":"赞","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1704988754,"ip_address":"上海","comment_id":386303,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"工作中防止越界访问一般是在访问前进行if条件判断，如果没有越界才会进行访问操作。而且在代码中也会增加捕获越界访问异常的代码。\n下面是我根据老师的提示写的一个Range概念：template &lt;typename T&gt;\nconcept Range = requires(T container){\n    {std::ranges::begin(container)};\n    {std::ranges::end(container)};\n};\n","like_count":1,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635629,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704988755,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368104,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1675907845,"is_pvip":false,"replies":[{"id":134082,"content":"Q1：这里的意思是f(x,g)=g(x)，函数f包含两个参数，x是一个普通参数，g是另一个函数。函数g的定义是g(x)=…（定义未知），所以根据函数f的定义会调用g，并将x作为参数传递给g。这里f就是一个高阶函数了。\n\nQ2：auto是编译时自动类型推断，虽然可以减少开发者定义变量的代码量，但和弱类型语言的动态类型天差地别。弱类型语言更多的是动态类型，也就是在运行时执行后才能判断这个变量的类型（比如一个弱类型语言的函数的返回值类型可能是两个不相关的类型），而C++是强类型语言，auto的作用是在编译时根据函数的定义自动推断出类型，也就是必须要求C++编译器能够根据代码在编译时静态确定类型，C++的普通函数也不可能返回两个不相干类型，这一点在C++里是通过模板实现的，但是模板的原理也是编译时实例化模板函数实现的，这样才能编译时静态确定类型，所以auto和弱类型的动态类型是完全不同的。\n\nQ3：迭代器的只读指的是是否能够通过迭代器去修改迭代器指向的数据，迭代器就是一个泛化的“指针”，所谓的只读迭代器就类似于const T *，可以修改迭代器，但是不能修改迭代器指向的数据。所谓的逆向迭代器就是会将序列的最后一个元素指针作为begin，这种迭代器会将对迭代器的累加操作转换为对迭代器内部指针的累减操作，实现逆向迭代。\n\nQ4：代码的运行环境推荐Windows下的Visual C++ 2022，对C++20已有标准的兼容性是比较好的。\n\nQ5：因为getArray返回的是一个临时对象，然后begin和end是在getArray返回的临时对象上执行的，所以begin和end执行结束后相应的临时对象都会被自动销毁，所以调用后begin和end返回的迭代器就变成了悬空的迭代器（包含悬空指针）。\n如果用伪代码解释，这个过程就是：\na1 = getArray();\nb = a1.begin();\narg1 = b;\n\na2 = getArray();\ne = a2.begin();\narg2 = e;\n\nDESTROY(a1);\nDESTROY(a2);\nDESTROY(b);\nDESTROY(e);\n\nstart = std::find(REF(arg1), REF(arg2), 1);\n\n所以真的调用find的时候a1和a2都已经被销毁了，自然arg1和arg2两个迭代器就“悬空”了。\n","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1676030623,"ip_address":"上海","comment_id":368104,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"请教老师几个问题：\nQ1：“假设 f(x,g) 的定义为 g(x)”，这句话表面上理解是：g(x)=f(x,g)。但好像说不通啊。f(x,g)的参数g的定义为g(x)，是不是这样啊。\nQ2：auto是由编译器来自动判断类型吗？（类似于弱类型语言了）\nQ3：迭代器与只读迭代器有什么区别？难道迭代器除了“读”还可以“写”吗？ 另外，逆向迭代器，比如begin，正常是从第一个向后面遍历，那“逆向”难道会向前遍历？（已经是第一个，不可能向前遍历啊）\nQ3：代码的运行环境是什么样的？\n对于实例代码，想运行一下看看，IDE是什么啊，包括设置编译器版本为c++20等。\nQ4：“start = std::find(getArray().begin(), getArray().end(), 1);”调用后为什么会变成悬空指针？能否再详细说明一下？","like_count":1,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":603253,"discussion_content":"Q1：这里的意思是f(x,g)=g(x)，函数f包含两个参数，x是一个普通参数，g是另一个函数。函数g的定义是g(x)=…（定义未知），所以根据函数f的定义会调用g，并将x作为参数传递给g。这里f就是一个高阶函数了。\n\nQ2：auto是编译时自动类型推断，虽然可以减少开发者定义变量的代码量，但和弱类型语言的动态类型天差地别。弱类型语言更多的是动态类型，也就是在运行时执行后才能判断这个变量的类型（比如一个弱类型语言的函数的返回值类型可能是两个不相关的类型），而C++是强类型语言，auto的作用是在编译时根据函数的定义自动推断出类型，也就是必须要求C++编译器能够根据代码在编译时静态确定类型，C++的普通函数也不可能返回两个不相干类型，这一点在C++里是通过模板实现的，但是模板的原理也是编译时实例化模板函数实现的，这样才能编译时静态确定类型，所以auto和弱类型的动态类型是完全不同的。\n\nQ3：迭代器的只读指的是是否能够通过迭代器去修改迭代器指向的数据，迭代器就是一个泛化的“指针”，所谓的只读迭代器就类似于const T *，可以修改迭代器，但是不能修改迭代器指向的数据。所谓的逆向迭代器就是会将序列的最后一个元素指针作为begin，这种迭代器会将对迭代器的累加操作转换为对迭代器内部指针的累减操作，实现逆向迭代。\n\nQ4：代码的运行环境推荐Windows下的Visual C++ 2022，对C++20已有标准的兼容性是比较好的。\n\nQ5：因为getArray返回的是一个临时对象，然后begin和end是在getArray返回的临时对象上执行的，所以begin和end执行结束后相应的临时对象都会被自动销毁，所以调用后begin和end返回的迭代器就变成了悬空的迭代器（包含悬空指针）。\n如果用伪代码解释，这个过程就是：\na1 = getArray();\nb = a1.begin();\narg1 = b;\n\na2 = getArray();\ne = a2.begin();\narg2 = e;\n\nDESTROY(a1);\nDESTROY(a2);\nDESTROY(b);\nDESTROY(e);\n\nstart = std::find(REF(arg1), REF(arg2), 1);\n\n所以真的调用find的时候a1和a2都已经被销毁了，自然arg1和arg2两个迭代器就“悬空”了。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676030623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385323,"user_name":"Family mission","can_delete":false,"product_type":"c1","uid":2710729,"ip_address":"上海","ucode":"10D4D65520FE0D","user_header":"https://static001.geekbang.org/account/avatar/00/29/5c/c9/f1b053f2.jpg","comment_is_top":false,"comment_ctime":1702448091,"is_pvip":false,"replies":[{"id":140536,"content":"提供下一下使用的编译器和具体版本～","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1703004849,"ip_address":"上海","comment_id":385323,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;ranges&gt;\n#include &lt;iostream&gt;\n \nint main() {\n    namespace ranges = std::ranges;\n \n    auto getArray = [] { return std::vector{ 0, 1, 0, 1 }; };\n \n    &#47;&#47; 编译成功\n    auto start = std::find(getArray().begin(), getArray().end(), 1);\n    std::cout &lt;&lt; *start &lt;&lt; std::endl;\n \n    &#47;&#47; 编译失败\n    auto rangeStart = ranges::find(getArray(), 1);\n    std::cout &lt;&lt; *rangeStart &lt;&lt; std::endl;\n \n    return 0;\n}\n这个代码块中auto getArray = [] { return std::vector{ 0, 1, 0, 1 }; };编译器会报错，需要改成 auto getArray = [] { \n        \n        return std::vector&lt;int&gt;{ 0, 1, 0, 1 };\n        \n    };才可以","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634124,"discussion_content":"提供下一下使用的编译器和具体版本～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1703004850,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":369056,"user_name":"努力学习不准懈怠","can_delete":false,"product_type":"c1","uid":2898675,"ip_address":"安徽","ucode":"60D2C77230655F","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJo05FofKFWYN3joX4OyCfVrU2kK7xvKdZ4Ho7bof893fE0jXk1OcB5sKLk4C1SviaNlibAiaCtp8aww/132","comment_is_top":false,"comment_ctime":1677048572,"is_pvip":true,"replies":[{"id":134887,"content":"恩，这里应该改成[4]。\n已修正。","user_name":"作者回复","user_name_real":"编辑","uid":1006976,"ctime":1678249421,"ip_address":"上海","comment_id":369056,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100523801,"comment_content":"\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;ranges&gt;\n#include &lt;iostream&gt;\n \nint main() {\n    namespace ranges = std::ranges;\n \n    &#47;&#47; 首先，调用ranges::begin和ranges::end函数获取容器的迭代器\n    &#47;&#47; 接着，通过迭代器访问数据中的元素\n    std::vector&lt;int&gt; v = { 3, 1, 4, 1, 5, 9, 2, 6 };\n    auto start = ranges::begin(v);\n    std::cout &lt;&lt; &quot;[0]: &quot; &lt;&lt; *start &lt;&lt; std::endl;\n \n    auto curr = start;\n    curr++;\n    std::cout &lt;&lt; &quot;[1]: &quot; &lt;&lt; *curr &lt;&lt; std::endl;\n \n    std::cout &lt;&lt; &quot;[5]: &quot; &lt;&lt; *(curr + 3) &lt;&lt; std::endl;\n \n    auto stop = ranges::end(v);\n    std::sort(start, stop);\n \n    &#47;&#47; 最后，调用ranges::cbegin和ranges::cend循环输出排序后的数据\n    for (auto it = ranges::cbegin(v);\n        it != ranges::cend(v);\n        ++it\n    ) {\n        std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    }\n    std::cout &lt;&lt; std::endl;\n \n    return 0;\n}\n这段代码第19行应该是std::cout &lt;&lt; &quot;[4]: &quot; &lt;&lt; *(curr + 3) &lt;&lt; std::endl;","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608069,"discussion_content":"恩，这里应该改成[4]。\n已修正。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678249421,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}