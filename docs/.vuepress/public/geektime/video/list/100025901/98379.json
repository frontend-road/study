{"id":98379,"title":"50 | 缓存新闻列表数据及已读状态","content":"<p><strong>PDF 课件和源代码下载地址：</strong></p><p><a href=\"https://gitee.com/geektime-geekbang/geektime-ios-course\">https://gitee.com/geektime-geekbang/geektime-ios-course</a></p>","comments":[{"had_liked":false,"id":133267,"user_name":"Geek_baozi","can_delete":false,"product_type":"c3","uid":1505815,"ip_address":"","ucode":"516056866F51AD","user_header":"","comment_is_top":false,"comment_ctime":1568471684,"is_pvip":false,"replies":[{"id":51662,"content":"是的，只要有刷新的操作就可以。首先刷新的时机有几个，比如点击之后，或者重新在屏幕展示时，这两个区别也比较明显，能直观的观察到不同。当然在刷新的时候也要尽量避免使用reloadData，而使用reload相应的indexpath，以此提高性能，并且减少一些由于cell重用带来的UI bug风险","user_name":"作者回复","user_name_real":"朱德权","uid":1041455,"ctime":1568897631,"ip_address":"","comment_id":133267,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100025901,"comment_content":"老师好，请问一下处理已读状态那块为什么不在willLoadView或者别的地方刷新一下页面呢reloadData？从详情页面返回就可以变灰了吧","like_count":3,"discussions":[{"author":{"id":1041455,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKJ3dLlYr6tznfnZXJNsD7Jw48BVnFSib3RO3VWEN0pgebRY1jaR8YXLQ6iaAjTsFiamOWSA3UPAa37A/132","nickname":"Geek_e7jq8k","note":"","ucode":"352964E5D793DA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467326,"discussion_content":"是的，只要有刷新的操作就可以。首先刷新的时机有几个，比如点击之后，或者重新在屏幕展示时，这两个区别也比较明显，能直观的观察到不同。当然在刷新的时候也要尽量避免使用reloadData，而使用reload相应的indexpath，以此提高性能，并且减少一些由于cell重用带来的UI bug风险","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568897631,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136394,"user_name":"Mason","can_delete":false,"product_type":"c3","uid":1453662,"ip_address":"","ucode":"AA2E37FDF9D313","user_header":"https://static001.geekbang.org/account/avatar/00/16/2e/5e/d42c79bb.jpg","comment_is_top":false,"comment_ctime":1569422380,"is_pvip":false,"replies":[{"id":52972,"content":"两个都是时序的问题哈\n第一个问题：cell.news = model;这句代码应该在if (!cell)这个判断之后，因为初始化的时候没有cell，只有初始化alloc之后才会有cell，之后的布局才是有效的。对应的滚动之后能出现，因为使用的是重用的cell，所以这句代码可以被有效的执行。\n\n第二个问题，同样是时序的问题    [self.listload addObserver:self forKeyPath:@&quot;dataSource&quot; options:NSKeyValueObservingOptionNew context:nil];这句话应该在    [self.listload loadListData];之前，因为有缓存的时候调用loadListData之后dataSource就已经赋值，之后添加addObserver是无效的，第一次有效是因为异步的有网络请求，所以真正赋值dataSource的时候addObserver已经执行。","user_name":"作者回复","user_name_real":"朱德权","uid":1041455,"ctime":1569895199,"ip_address":"","comment_id":136394,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100025901,"comment_content":"老师你好,我跟着敲的代码运行出现了两个BUG找了好久实在不知道是什么原因,导致我没法继续了,请帮我看下代码https:&#47;&#47;github.com&#47;Fresh-C&#47;sampAPP\n(1)运行后第一屏的cell空白,非要滑动列表才能显示,但点击能进入详情页\n(2)不能有数据存储,如果有就会连自定义的cell都不会展示\n(请帮忙修改后加上注释把道理告诉我下,可压缩发我邮箱:caotingnian@163.com)\n谢谢!","like_count":2,"discussions":[{"author":{"id":1041455,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKJ3dLlYr6tznfnZXJNsD7Jw48BVnFSib3RO3VWEN0pgebRY1jaR8YXLQ6iaAjTsFiamOWSA3UPAa37A/132","nickname":"Geek_e7jq8k","note":"","ucode":"352964E5D793DA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468609,"discussion_content":"两个都是时序的问题哈\n第一个问题：cell.news = model;这句代码应该在if (!cell)这个判断之后，因为初始化的时候没有cell，只有初始化alloc之后才会有cell，之后的布局才是有效的。对应的滚动之后能出现，因为使用的是重用的cell，所以这句代码可以被有效的执行。\n\n第二个问题，同样是时序的问题    [self.listload addObserver:self forKeyPath:@&amp;quot;dataSource&amp;quot; options:NSKeyValueObservingOptionNew context:nil];这句话应该在    [self.listload loadListData];之前，因为有缓存的时候调用loadListData之后dataSource就已经赋值，之后添加addObserver是无效的，第一次有效是因为异步的有网络请求，所以真正赋值dataSource的时候addObserver已经执行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569895199,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1453662,"avatar":"https://static001.geekbang.org/account/avatar/00/16/2e/5e/d42c79bb.jpg","nickname":"Mason","note":"","ucode":"AA2E37FDF9D313","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":26898,"discussion_content":"明白了,感谢老师指点!","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570623889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":232963,"user_name":"左手指月","can_delete":false,"product_type":"c3","uid":2004938,"ip_address":"","ucode":"216A4CE1CC8FEC","user_header":"https://static001.geekbang.org/account/avatar/00/1e/97/ca/1297b401.jpg","comment_is_top":false,"comment_ctime":1594178295,"is_pvip":false,"replies":[{"id":88781,"content":"页面卡顿，说明有比较重的逻辑占用了主线程，也就是UI线程。那么从问题的描述上看，已经确认了是由于加载图片导致的，简单的就可以将图片的下载逻辑、存储逻辑、甚至裁剪逻辑放到非主线程来运行，之后再回到主线程进行UI渲染。当然对于复杂页面的卡顿是个系统话的工程，除了以上简单的修改，还可以通过instrument看下具体的耗时，有针对性的进行优化","user_name":"作者回复","user_name_real":"zzz","uid":1041455,"ctime":1596973503,"ip_address":"","comment_id":232963,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100025901,"comment_content":"ajax数据相应后，加载图片会导致页面卡顿怎么解决","like_count":1,"discussions":[{"author":{"id":1041455,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKJ3dLlYr6tznfnZXJNsD7Jw48BVnFSib3RO3VWEN0pgebRY1jaR8YXLQ6iaAjTsFiamOWSA3UPAa37A/132","nickname":"Geek_e7jq8k","note":"","ucode":"352964E5D793DA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500829,"discussion_content":"页面卡顿，说明有比较重的逻辑占用了主线程，也就是UI线程。那么从问题的描述上看，已经确认了是由于加载图片导致的，简单的就可以将图片的下载逻辑、存储逻辑、甚至裁剪逻辑放到非主线程来运行，之后再回到主线程进行UI渲染。当然对于复杂页面的卡顿是个系统话的工程，除了以上简单的修改，还可以通过instrument看下具体的耗时，有针对性的进行优化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596973503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236210,"user_name":"sk.tree","can_delete":false,"product_type":"c3","uid":1142887,"ip_address":"","ucode":"6BBA529FBD09B9","user_header":"https://static001.geekbang.org/account/avatar/00/11/70/67/1c6874cc.jpg","comment_is_top":false,"comment_ctime":1595345603,"is_pvip":false,"replies":[{"id":88783,"content":"回顾了下视频，保存文章是否已读用的是setObject:forKey ,以Key-Value形式存储的哈。当然在视频里也提到了只是简单的演示，实际的项目中直接使用userDefaults，并且用id存储会导致语义不明不好维护，需要结合项目的kv存储框架进行业务层面的封装和设计。同时其实用数组存储也没有什么问题，每次取出全部的已读id，在判断是否有当前id即可，只是操作上因为维护全量列表会麻烦一些，低效一些。当然以我们目前场景的使用频率来讲也不需要过早的考虑性能问题，在保证历史逻辑、接口设计、稳定可维护即可。","user_name":"作者回复","user_name_real":"zzz","uid":1041455,"ctime":1596974261,"ip_address":"","comment_id":236210,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100025901,"comment_content":"已读列表为什么是用数组保存？","like_count":0,"discussions":[{"author":{"id":1041455,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKJ3dLlYr6tznfnZXJNsD7Jw48BVnFSib3RO3VWEN0pgebRY1jaR8YXLQ6iaAjTsFiamOWSA3UPAa37A/132","nickname":"Geek_e7jq8k","note":"","ucode":"352964E5D793DA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501984,"discussion_content":"回顾了下视频，保存文章是否已读用的是setObject:forKey ,以Key-Value形式存储的哈。当然在视频里也提到了只是简单的演示，实际的项目中直接使用userDefaults，并且用id存储会导致语义不明不好维护，需要结合项目的kv存储框架进行业务层面的封装和设计。同时其实用数组存储也没有什么问题，每次取出全部的已读id，在判断是否有当前id即可，只是操作上因为维护全量列表会麻烦一些，低效一些。当然以我们目前场景的使用频率来讲也不需要过早的考虑性能问题，在保证历史逻辑、接口设计、稳定可维护即可。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596974261,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308055,"user_name":"高亮","can_delete":false,"product_type":"c3","uid":2731035,"ip_address":"","ucode":"414D1CFDE112ED","user_header":"","comment_is_top":false,"comment_ctime":1629369681,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100025901,"comment_content":"《50 | 缓存新闻列表数据及已读状态》中，已读文章变灰，如何在点击返回也实现？而不是现在只能从新启动app","like_count":0},{"had_liked":false,"id":303565,"user_name":"Geek_98wavm","can_delete":false,"product_type":"c3","uid":2621085,"ip_address":"","ucode":"F8994CE6184B49","user_header":"","comment_is_top":false,"comment_ctime":1626857991,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100025901,"comment_content":"原来如此，学到了学到了，我们小公司做东西不太规范，这种资讯类，还是缓存到本地好一点。我们都是全靠网络请求","like_count":0}]}