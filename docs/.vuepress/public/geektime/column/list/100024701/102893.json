{"id":102893,"title":"38 | 信号（下）：项目组A完成了，如何及时通知项目组B？","content":"<p>信号处理最常见的流程主要是两步，第一步是注册信号处理函数，第二步是发送信号和处理信号。上一节，我们讲了注册信号处理函数，那一般什么情况下会产生信号呢？我们这一节就来看一看。</p><h2>信号的发送</h2><p>有时候，我们在终端输入某些组合键的时候，会给进程发送信号，例如，Ctrl+C产生SIGINT信号，Ctrl+Z产生SIGTSTP信号。</p><p>有的时候，硬件异常也会产生信号。比如，执行了除以0的指令，CPU就会产生异常，然后把SIGFPE信号发送给进程。再如，进程访问了非法内存，内存管理模块就会产生异常，然后把信号SIGSEGV发送给进程。</p><p>这里同样是硬件产生的，对于中断和信号还是要加以区别。咱们前面讲过，中断要注册中断处理函数，但是中断处理函数是在内核驱动里面的，信号也要注册信号处理函数，信号处理函数是在用户态进程里面的。</p><p>对于硬件触发的，无论是中断，还是信号，肯定是先到内核的，然后内核对于中断和信号处理方式不同。一个是完全在内核里面处理完毕，一个是将信号放在对应的进程task_struct里信号相关的数据结构里面，然后等待进程在用户态去处理。当然有些严重的信号，内核会把进程干掉。但是，这也能看出来，中断和信号的严重程度不一样，信号影响的往往是某一个进程，处理慢了，甚至错了，也不过这个进程被干掉，而中断影响的是整个系统。一旦中断处理中有了bug，可能整个Linux都挂了。</p><!-- [[[read_end]]] --><p>有时候，内核在某些情况下，也会给进程发送信号。例如，向读端已关闭的管道写数据时产生SIGPIPE信号，当子进程退出时，我们要给父进程发送SIG_CHLD信号等。</p><p>最直接的发送信号的方法就是，通过命令kill来发送信号了。例如，我们都知道的kill -9 pid可以发送信号给一个进程，杀死它。</p><p>另外，我们还可以通过kill或者sigqueue系统调用，发送信号给某个进程，也可以通过tkill或者tgkill发送信号给某个线程。虽然方式多种多样，但是最终都是调用了do_send_sig_info函数，将信号放在相应的task_struct的信号数据结构中。</p><ul>\n<li>kill-&gt;kill_something_info-&gt;kill_pid_info-&gt;group_send_sig_info-&gt;do_send_sig_info</li>\n<li>tkill-&gt;do_tkill-&gt;do_send_specific-&gt;do_send_sig_info</li>\n<li>tgkill-&gt;do_tkill-&gt;do_send_specific-&gt;do_send_sig_info</li>\n<li>rt_sigqueueinfo-&gt;do_rt_sigqueueinfo-&gt;kill_proc_info-&gt;kill_pid_info-&gt;group_send_sig_info-&gt;do_send_sig_info</li>\n</ul><p>do_send_sig_info会调用send_signal，进而调用__send_signal。</p><pre><code>SYSCALL_DEFINE2(kill, pid_t, pid, int, sig)\n{\n\tstruct siginfo info;\n\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_USER;\n\tinfo.si_pid = task_tgid_vnr(current);\n\tinfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\n\treturn kill_something_info(sig, &amp;info, pid);\n}\n\n\nstatic int __send_signal(int sig, struct siginfo *info, struct task_struct *t,\n\t\t\tint group, int from_ancestor_ns)\n{\n\tstruct sigpending *pending;\n\tstruct sigqueue *q;\n\tint override_rlimit;\n\tint ret = 0, result;\n......\n\tpending = group ? &amp;t-&gt;signal-&gt;shared_pending : &amp;t-&gt;pending;\n......\n\tif (legacy_queue(pending, sig))\n\t\tgoto ret;\n\n\tif (sig &lt; SIGRTMIN)\n\t\toverride_rlimit = (is_si_special(info) || info-&gt;si_code &gt;= 0);\n\telse\n\t\toverride_rlimit = 0;\n\n\tq = __sigqueue_alloc(sig, t, GFP_ATOMIC | __GFP_NOTRACK_FALSE_POSITIVE,\n\t\toverride_rlimit);\n\tif (q) {\n\t\tlist_add_tail(&amp;q-&gt;list, &amp;pending-&gt;list);\n\t\tswitch ((unsigned long) info) {\n\t\tcase (unsigned long) SEND_SIG_NOINFO:\n\t\t\tq-&gt;info.si_signo = sig;\n\t\t\tq-&gt;info.si_errno = 0;\n\t\t\tq-&gt;info.si_code = SI_USER;\n\t\t\tq-&gt;info.si_pid = task_tgid_nr_ns(current,\n\t\t\t\t\t\t\ttask_active_pid_ns(t));\n\t\t\tq-&gt;info.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\t\t\tbreak;\n\t\tcase (unsigned long) SEND_SIG_PRIV:\n\t\t\tq-&gt;info.si_signo = sig;\n\t\t\tq-&gt;info.si_errno = 0;\n\t\t\tq-&gt;info.si_code = SI_KERNEL;\n\t\t\tq-&gt;info.si_pid = 0;\n\t\t\tq-&gt;info.si_uid = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcopy_siginfo(&amp;q-&gt;info, info);\n\t\t\tif (from_ancestor_ns)\n\t\t\t\tq-&gt;info.si_pid = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tuserns_fixup_signal_uid(&amp;q-&gt;info, t);\n\n\t} \n......\nout_set:\n\tsignalfd_notify(t, sig);\n\tsigaddset(&amp;pending-&gt;signal, sig);\n\tcomplete_signal(sig, t, group);\nret:\n\treturn ret;\n}\n</code></pre><p>在这里，我们看到，在学习进程数据结构中task_struct里面的sigpending。在上面的代码里面，我们先是要决定应该用哪个sigpending。这就要看我们发送的信号，是给进程的还是线程的。如果是kill发送的，也就是发送给整个进程的，就应该发送给t-&gt;signal-&gt;shared_pending。这里面是整个进程所有线程共享的信号；如果是tkill发送的，也就是发给某个线程的，就应该发给t-&gt;pending。这里面是这个线程的task_struct独享的。</p><p>struct sigpending里面有两个成员，一个是一个集合sigset_t，表示都收到了哪些信号，还有一个链表，也表示收到了哪些信号。它的结构如下：</p><pre><code>struct sigpending {\n\tstruct list_head list;\n\tsigset_t signal;\n};\n</code></pre><p>如果都表示收到了信号，这两者有什么区别呢？我们接着往下看__send_signal里面的代码。接下来，我们要调用legacy_queue。如果满足条件，那就直接退出。那legacy_queue里面判断的是什么条件呢？我们来看它的代码。</p><pre><code>static inline int legacy_queue(struct sigpending *signals, int sig)\n{\n\treturn (sig &lt; SIGRTMIN) &amp;&amp; sigismember(&amp;signals-&gt;signal, sig);\n}\n\n\n#define SIGRTMIN\t32\n#define SIGRTMAX\t_NSIG\n#define _NSIG\t\t64\n</code></pre><p>当信号小于SIGRTMIN，也即32的时候，如果我们发现这个信号已经在集合里面了，就直接退出了。这样会造成什么现象呢？就是信号的丢失。例如，我们发送给进程100个SIGUSR1（对应的信号为10），那最终能够被我们的信号处理函数处理的信号有多少呢？这就不好说了，比如总共5个SIGUSR1，分别是A、B、C、D、E。</p><p>如果这五个信号来得太密。A来了，但是信号处理函数还没来得及处理，B、C、D、E就都来了。根据上面的逻辑，因为A已经将SIGUSR1放在sigset_t集合中了，因而后面四个都要丢失。 如果是另一种情况，A来了已经被信号处理函数处理了，内核在调用信号处理函数之前，我们会将集合中的标志位清除，这个时候B再来，B还是会进入集合，还是会被处理，也就不会丢。</p><p>这样信号能够处理多少，和信号处理函数什么时候被调用，信号多大频率被发送，都有关系，而且从后面的分析，我们可以知道，信号处理函数的调用时间也是不确定的。看小于32的信号如此不靠谱，我们就称它为<strong>不可靠信号</strong>。</p><p>如果大于32的信号是什么情况呢？我们接着看。接下来，__sigqueue_alloc会分配一个struct sigqueue对象，然后通过list_add_tail挂在struct sigpending里面的链表上。这样就靠谱多了是不是？如果发送过来100个信号，变成链表上的100项，都不会丢，哪怕相同的信号发送多遍，也处理多遍。因此，大于32的信号我们称为<strong>可靠信号</strong>。当然，队列的长度也是有限制的，如果我们执行ulimit命令，可以看到，这个限制pending signals (-i) 15408。</p><p>当信号挂到了task_struct结构之后，最后我们需要调用complete_signal。这里面的逻辑也很简单，就是说，既然这个进程有了一个新的信号，赶紧找一个线程处理一下吧。</p><pre><code>static void complete_signal(int sig, struct task_struct *p, int group)\n{\n\tstruct signal_struct *signal = p-&gt;signal;\n\tstruct task_struct *t;\n\n\t/*\n\t * Now find a thread we can wake up to take the signal off the queue.\n\t *\n\t * If the main thread wants the signal, it gets first crack.\n\t * Probably the least surprising to the average bear.\n\t */\n\tif (wants_signal(sig, p))\n\t\tt = p;\n\telse if (!group || thread_group_empty(p))\n\t\t/*\n\t\t * There is just one thread and it does not need to be woken.\n\t\t * It will dequeue unblocked signals before it runs again.\n\t\t */\n\t\treturn;\n\telse {\n\t\t/*\n\t\t * Otherwise try to find a suitable thread.\n\t\t */\n\t\tt = signal-&gt;curr_target;\n\t\twhile (!wants_signal(sig, t)) {\n\t\t\tt = next_thread(t);\n\t\t\tif (t == signal-&gt;curr_target)\n\t\t\t\treturn;\n\t\t}\n\t\tsignal-&gt;curr_target = t;\n\t}\n......\n\t/*\n\t * The signal is already in the shared-pending queue.\n\t * Tell the chosen thread to wake up and dequeue it.\n\t */\n\tsignal_wake_up(t, sig == SIGKILL);\n\treturn;\n}\n</code></pre><p>在找到了一个进程或者线程的task_struct之后，我们要调用signal_wake_up，来企图唤醒它，signal_wake_up会调用signal_wake_up_state。</p><pre><code>void signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\n\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}\n</code></pre><p>signal_wake_up_state里面主要做了两件事情。第一，就是给这个线程设置TIF_SIGPENDING，这就说明其实信号的处理和进程的调度是采取这样一种类似的机制。还记得咱们调度的时候是怎么操作的吗？</p><p>当发现一个进程应该被调度的时候，我们并不直接把它赶下来，而是设置一个标识位TIF_NEED_RESCHED，表示等待调度，然后等待系统调用结束或者中断处理结束，从内核态返回用户态的时候，调用schedule函数进行调度。信号也是类似的，当信号来的时候，我们并不直接处理这个信号，而是设置一个标识位TIF_SIGPENDING，来表示已经有信号等待处理。同样等待系统调用结束，或者中断处理结束，从内核态返回用户态的时候，再进行信号的处理。</p><p>signal_wake_up_state的第二件事情，就是试图唤醒这个进程或者线程。wake_up_state会调用try_to_wake_up方法。这个函数我们讲进程的时候讲过，就是将这个进程或者线程设置为TASK_RUNNING，然后放在运行队列中，这个时候，当随着时钟不断的滴答，迟早会被调用。如果wake_up_state返回0，说明进程或者线程已经是TASK_RUNNING状态了，如果它在另外一个CPU上运行，则调用kick_process发送一个处理器间中断，强制那个进程或者线程重新调度，重新调度完毕后，会返回用户态运行。这是一个时机会检查TIF_SIGPENDING标识位。</p><h2>信号的处理</h2><p>好了，信号已经发送到位了，什么时候真正处理它呢？</p><p>就是在从系统调用或者中断返回的时候，咱们讲调度的时候讲过，无论是从系统调用返回还是从中断返回，都会调用exit_to_usermode_loop，只不过我们上次主要关注了_TIF_NEED_RESCHED这个标识位，这次我们重点关注<strong>_TIF_SIGPENDING标识位</strong>。</p><pre><code>static void exit_to_usermode_loop(struct pt_regs *regs, u32 cached_flags)\n{\n\twhile (true) {\n......\n\t\tif (cached_flags &amp; _TIF_NEED_RESCHED)\n\t\t\tschedule();\n......\n\t\t/* deal with pending signal delivery */\n\t\tif (cached_flags &amp; _TIF_SIGPENDING)\n\t\t\tdo_signal(regs);\n......\n\t\tif (!(cached_flags &amp; EXIT_TO_USERMODE_LOOP_FLAGS))\n\t\t\tbreak;\n\t}\n}\n</code></pre><p>如果在前一个环节中，已经设置了_TIF_SIGPENDING，我们就调用do_signal进行处理。</p><pre><code>void do_signal(struct pt_regs *regs)\n{\n\tstruct ksignal ksig;\n\n\tif (get_signal(&amp;ksig)) {\n\t\t/* Whee! Actually deliver the signal.  */\n\t\thandle_signal(&amp;ksig, regs);\n\t\treturn;\n\t}\n\n\t/* Did we come from a system call? */\n\tif (syscall_get_nr(current, regs) &gt;= 0) {\n\t\t/* Restart the system call - no handlers present */\n\t\tswitch (syscall_get_error(current, regs)) {\n\t\tcase -ERESTARTNOHAND:\n\t\tcase -ERESTARTSYS:\n\t\tcase -ERESTARTNOINTR:\n\t\t\tregs-&gt;ax = regs-&gt;orig_ax;\n\t\t\tregs-&gt;ip -= 2;\n\t\t\tbreak;\n\n\t\tcase -ERESTART_RESTARTBLOCK:\n\t\t\tregs-&gt;ax = get_nr_restart_syscall(regs);\n\t\t\tregs-&gt;ip -= 2;\n\t\t\tbreak;\n\t\t}\n\t}\n\trestore_saved_sigmask();\n}\n</code></pre><p>do_signal会调用handle_signal。按说，信号处理就是调用用户提供的信号处理函数，但是这事儿没有看起来这么简单，因为信号处理函数是在用户态的。</p><p>咱们又要来回忆系统调用的过程了。这个进程当时在用户态执行到某一行Line A，调用了一个系统调用，在进入内核的那一刻，在内核pt_regs里面保存了用户态执行到了Line A。现在我们从系统调用返回用户态了，按说应该从pt_regs拿出Line A，然后接着Line A执行下去，但是为了响应信号，我们不能回到用户态的时候返回Line A了，而是应该返回信号处理函数的起始地址。</p><pre><code>static void\nhandle_signal(struct ksignal *ksig, struct pt_regs *regs)\n{\n\tbool stepping, failed;\n......\n\t/* Are we from a system call? */\n\tif (syscall_get_nr(current, regs) &gt;= 0) {\n\t\t/* If so, check system call restarting.. */\n\t\tswitch (syscall_get_error(current, regs)) {\n\t\tcase -ERESTART_RESTARTBLOCK:\n\t\tcase -ERESTARTNOHAND:\n\t\t\tregs-&gt;ax = -EINTR;\n\t\t\tbreak;\n\t\tcase -ERESTARTSYS:\n\t\t\tif (!(ksig-&gt;ka.sa.sa_flags &amp; SA_RESTART)) {\n\t\t\t\tregs-&gt;ax = -EINTR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t/* fallthrough */\n\t\tcase -ERESTARTNOINTR:\n\t\t\tregs-&gt;ax = regs-&gt;orig_ax;\n\t\t\tregs-&gt;ip -= 2;\n\t\t\tbreak;\n\t\t}\n\t}\n......\n\tfailed = (setup_rt_frame(ksig, regs) &lt; 0);\n......\n\tsignal_setup_done(failed, ksig, stepping);\n}\n</code></pre><p>这个时候，我们就需要干预和自己来定制pt_regs了。这个时候，我们要看，是否从系统调用中返回。如果是从系统调用返回的话，还要区分我们是从系统调用中正常返回，还是在一个非运行状态的系统调用中，因为会被信号中断而返回。</p><p>我们这里解析一个最复杂的场景。还记得咱们解析进程调度的时候，我们举的一个例子，就是从一个tap网卡中读取数据。当时我们主要关注schedule那一行，也即如果当发现没有数据的时候，就调用schedule，自己进入等待状态，然后将CPU让给其他进程。具体的代码如下：</p><pre><code>static ssize_t tap_do_read(struct tap_queue *q,\n\t\t\t   struct iov_iter *to,\n\t\t\t   int noblock, struct sk_buff *skb)\n{\n......\n\twhile (1) {\n\t\tif (!noblock)\n\t\t\tprepare_to_wait(sk_sleep(&amp;q-&gt;sk), &amp;wait,\n\t\t\t\t\tTASK_INTERRUPTIBLE);\n\n\t\t/* Read frames from the queue */\n\t\tskb = skb_array_consume(&amp;q-&gt;skb_array);\n\t\tif (skb)\n\t\t\tbreak;\n\t\tif (noblock) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\t/* Nothing to read, let's sleep */\n\t\tschedule();\n\t}\n......\n}\n</code></pre><p>这里我们关注和信号相关的部分。这其实是一个信号中断系统调用的典型逻辑。</p><p>首先，我们把当前进程或者线程的状态设置为TASK_INTERRUPTIBLE，这样才能使这个系统调用可以被中断。</p><p>其次，可以被中断的系统调用往往是比较慢的调用，并且会因为数据不就绪而通过schedule让出CPU进入等待状态。在发送信号的时候，我们除了设置这个进程和线程的_TIF_SIGPENDING标识位之外，还试图唤醒这个进程或者线程，也就是将它从等待状态中设置为TASK_RUNNING。</p><p>当这个进程或者线程再次运行的时候，我们根据进程调度第一定律，从schedule函数中返回，然后再次进入while循环。由于这个进程或者线程是由信号唤醒的，而不是因为数据来了而唤醒的，因而是读不到数据的，但是在signal_pending函数中，我们检测到了_TIF_SIGPENDING标识位，这说明系统调用没有真的做完，于是返回一个错误ERESTARTSYS，然后带着这个错误从系统调用返回。</p><p>然后，我们到了exit_to_usermode_loop-&gt;do_signal-&gt;handle_signal。在这里面，当发现出现错误ERESTARTSYS的时候，我们就知道这是从一个没有调用完的系统调用返回的，设置系统调用错误码EINTR。</p><p>接下来，我们就开始折腾pt_regs了，主要通过调用setup_rt_frame-&gt;__setup_rt_frame。</p><pre><code>static int __setup_rt_frame(int sig, struct ksignal *ksig,\n\t\t\t    sigset_t *set, struct pt_regs *regs)\n{\n\tstruct rt_sigframe __user *frame;\n\tvoid __user *fp = NULL;\n\tint err = 0;\n\n\tframe = get_sigframe(&amp;ksig-&gt;ka, regs, sizeof(struct rt_sigframe), &amp;fp);\n......\n\tput_user_try {\n......\n\t\t/* Set up to return from userspace.  If provided, use a stub\n\t\t   already in userspace.  */\n\t\t/* x86-64 should always use SA_RESTORER. */\n\t\tif (ksig-&gt;ka.sa.sa_flags &amp; SA_RESTORER) {\n\t\t\tput_user_ex(ksig-&gt;ka.sa.sa_restorer, &amp;frame-&gt;pretcode);\n\t\t} \n\t} put_user_catch(err);\n\n\terr |= setup_sigcontext(&amp;frame-&gt;uc.uc_mcontext, fp, regs, set-&gt;sig[0]);\n\terr |= __copy_to_user(&amp;frame-&gt;uc.uc_sigmask, set, sizeof(*set));\n\n\t/* Set up registers for signal handler */\n\tregs-&gt;di = sig;\n\t/* In case the signal handler was declared without prototypes */\n\tregs-&gt;ax = 0;\n\n\tregs-&gt;si = (unsigned long)&amp;frame-&gt;info;\n\tregs-&gt;dx = (unsigned long)&amp;frame-&gt;uc;\n\tregs-&gt;ip = (unsigned long) ksig-&gt;ka.sa.sa_handler;\n\n\tregs-&gt;sp = (unsigned long)frame;\n\tregs-&gt;cs = __USER_CS;\n......\n\treturn 0;\n}\n</code></pre><p>frame的类型是rt_sigframe。frame的意思是帧。我们只有在学习栈的时候，提到过栈帧的概念。对的，这个frame就是一个栈帧。</p><p>我们在get_sigframe中会得到pt_regs的sp变量，也就是原来这个程序在用户态的栈顶指针，然后get_sigframe中，我们会将sp减去sizeof(struct rt_sigframe)，也就是把这个栈帧塞到了栈里面，然后我们又在__setup_rt_frame中把regs-&gt;sp设置成等于frame。这就相当于强行在程序原来的用户态的栈里面插入了一个栈帧，并在最后将regs-&gt;ip设置为用户定义的信号处理函数sa_handler。这意味着，本来返回用户态应该接着原来的代码执行的，现在不了，要执行sa_handler了。那执行完了以后呢？按照函数栈的规则，弹出上一个栈帧来，也就是弹出了frame。</p><p>那如果我们假设sa_handler成功返回了，怎么回到程序原来在用户态运行的地方呢？玄机就在frame里面。要想恢复原来运行的地方，首先，原来的pt_regs不能丢，这个没问题，是在setup_sigcontext里面，将原来的pt_regs保存在了frame中的uc_mcontext里面。</p><p>另外，很重要的一点，程序如何跳过去呢？在__setup_rt_frame中，还有一个不引起重视的操作，那就是通过put_user_ex，将sa_restorer放到了frame-&gt;pretcode里面，而且还是按照函数栈的规则。函数栈里面包含了函数执行完跳回去的地址。当sa_handler执行完之后，弹出的函数栈是frame，也就应该跳到sa_restorer的地址。这是什么地址呢？</p><p>咱们在sigaction介绍的时候就没有介绍它，在Glibc的__libc_sigaction函数中也没有注意到，它被赋值成了restore_rt。这其实就是sa_handler执行完毕之后，马上要执行的函数。从名字我们就能感觉到，它将恢复原来程序运行的地方。</p><p>在Glibc中，我们可以找到它的定义，它竟然调用了一个系统调用，系统调用号为__NR_rt_sigreturn。</p><pre><code>RESTORE (restore_rt, __NR_rt_sigreturn)\n\n#define RESTORE(name, syscall) RESTORE2 (name, syscall)\n# define RESTORE2(name, syscall) \\\nasm                                     \\\n  (                                     \\\n   &quot;.LSTART_&quot; #name &quot;:\\n&quot;               \\\n   &quot;    .type __&quot; #name &quot;,@function\\n&quot;  \\\n   &quot;__&quot; #name &quot;:\\n&quot;                     \\\n   &quot;    movq $&quot; #syscall &quot;, %rax\\n&quot;     \\\n   &quot;    syscall\\n&quot;                      \\\n......\n</code></pre><p>我们可以在内核里面找到__NR_rt_sigreturn对应的系统调用。</p><pre><code>asmlinkage long sys_rt_sigreturn(void)\n{\n\tstruct pt_regs *regs = current_pt_regs();\n\tstruct rt_sigframe __user *frame;\n\tsigset_t set;\n\tunsigned long uc_flags;\n\n\tframe = (struct rt_sigframe __user *)(regs-&gt;sp - sizeof(long));\n\tif (__copy_from_user(&amp;set, &amp;frame-&gt;uc.uc_sigmask, sizeof(set)))\n\t\tgoto badframe;\n\tif (__get_user(uc_flags, &amp;frame-&gt;uc.uc_flags))\n\t\tgoto badframe;\n\n\tset_current_blocked(&amp;set);\n\n\tif (restore_sigcontext(regs, &amp;frame-&gt;uc.uc_mcontext, uc_flags))\n\t\tgoto badframe;\n......\n\treturn regs-&gt;ax;\n......\n}\n</code></pre><p>在这里面，我们把上次填充的那个rt_sigframe拿出来，然后restore_sigcontext将pt_regs恢复成为原来用户态的样子。从这个系统调用返回的时候，应用还误以为从上次的系统调用返回的呢。</p><p>至此，整个信号处理过程才全部结束。</p><h2>总结时刻</h2><p>信号的发送与处理是一个复杂的过程，这里来总结一下。</p><ol>\n<li>假设我们有一个进程A，main函数里面调用系统调用进入内核。</li>\n<li>按照系统调用的原理，会将用户态栈的信息保存在pt_regs里面，也即记住原来用户态是运行到了line A的地方。</li>\n<li>在内核中执行系统调用读取数据。</li>\n<li>当发现没有什么数据可读取的时候，只好进入睡眠状态，并且调用schedule让出CPU，这是进程调度第一定律。</li>\n<li>将进程状态设置为TASK_INTERRUPTIBLE，可中断的睡眠状态，也即如果有信号来的话，是可以唤醒它的。</li>\n<li>其他的进程或者shell发送一个信号，有四个函数可以调用kill、tkill、tgkill、rt_sigqueueinfo。</li>\n<li>四个发送信号的函数，在内核中最终都是调用do_send_sig_info。</li>\n<li>do_send_sig_info调用send_signal给进程A发送一个信号，其实就是找到进程A的task_struct，或者加入信号集合，为不可靠信号，或者加入信号链表，为可靠信号。</li>\n<li>do_send_sig_info调用signal_wake_up唤醒进程A。</li>\n<li>进程A重新进入运行状态TASK_RUNNING，根据进程调度第一定律，一定会接着schedule运行。</li>\n<li>进程A被唤醒后，检查是否有信号到来，如果没有，重新循环到一开始，尝试再次读取数据，如果还是没有数据，再次进入TASK_INTERRUPTIBLE，即可中断的睡眠状态。</li>\n<li>当发现有信号到来的时候，就返回当前正在执行的系统调用，并返回一个错误表示系统调用被中断了。</li>\n<li>系统调用返回的时候，会调用exit_to_usermode_loop。这是一个处理信号的时机。</li>\n<li>调用do_signal开始处理信号。</li>\n<li>根据信号，得到信号处理函数sa_handler，然后修改pt_regs中的用户态栈的信息，让pt_regs指向sa_handler。同时修改用户态的栈，插入一个栈帧sa_restorer，里面保存了原来的指向line A的pt_regs，并且设置让sa_handler运行完毕后，跳到sa_restorer运行。</li>\n<li>返回用户态，由于pt_regs已经设置为sa_handler，则返回用户态执行sa_handler。</li>\n<li>sa_handler执行完毕后，信号处理函数就执行完了，接着根据第15步对于用户态栈帧的修改，会跳到sa_restorer运行。</li>\n<li>sa_restorer会调用系统调用rt_sigreturn再次进入内核。</li>\n<li>在内核中，rt_sigreturn恢复原来的pt_regs，重新指向line A。</li>\n<li>从rt_sigreturn返回用户态，还是调用exit_to_usermode_loop。</li>\n<li>这次因为pt_regs已经指向line A了，于是就到了进程A中，接着系统调用之后运行，当然这个系统调用返回的是它被中断了，没有执行完的错误。</li>\n</ol><p><img src=\"https://static001.geekbang.org/resource/image/3d/fb/3dcb3366b11a3594b00805896b7731fb.png?wh=5908*3052\" alt=\"\"></p><h2>课堂练习</h2><p>在Linux内核里面，很多地方都存在信号和信号处理，所以signal_pending这个函数也随处可见，这样我们就能判断是否有信号发生。请你在内核代码中找到signal_pending出现的一些地方，看有什么规律，我们后面的章节会经常遇到它。</p><p>欢迎留言和我分享你的疑惑和见解 ，也欢迎可以收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习和进步。</p><p><img src=\"https://static001.geekbang.org/resource/image/8c/37/8c0a95fa07a8b9a1abfd394479bdd637.jpg?wh=1110*659\" alt=\"\"></p>","neighbors":{"left":{"article_title":"37 | 信号（上）：项目组A完成了，如何及时通知项目组B？","id":102281},"right":{"article_title":"39 | 管道：项目组A完成了，如何交接给项目组B？","id":103426}},"comments":[{"had_liked":false,"id":106458,"user_name":"安排","can_delete":false,"product_type":"c1","uid":1260026,"ip_address":"","ucode":"F78CFA9624CAEF","user_header":"https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg","comment_is_top":false,"comment_ctime":1561309790,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"207719739998","product_id":100024701,"comment_content":"能把这个流程串起来，老师功力深厚啊","like_count":48,"discussions":[{"author":{"id":1744776,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIiao0orF0gDeDCwnAEicrCgY6NickyOJ8ialw0GiavInZL0DMctRYlZicj4bLMNTtBmFtH4eIiaVfr8DPVw/132","nickname":"Geek_84971a","note":"","ucode":"5F79D841FE6F61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295095,"discussion_content":"真的太厉害了。我佛了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596088661,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124380,"user_name":"江山未","can_delete":false,"product_type":"c1","uid":1090196,"ip_address":"","ucode":"5293DD9482717F","user_header":"https://static001.geekbang.org/account/avatar/00/10/a2/94/ae0a60d8.jpg","comment_is_top":false,"comment_ctime":1565872552,"is_pvip":false,"replies":[{"id":"46270","content":"赞，很生动，加油","user_name":"作者回复","comment_id":124380,"uid":"1001590","ip_address":"","utype":1,"ctime":1566280634,"user_name_real":"刘超@网易云"}],"discussion_count":3,"race_medal":0,"score":"130414891432","product_id":100024701,"comment_content":"感觉看的过程中，我的大脑不断的发出&quot;我看不懂&quot;的中断，让我不断的的从&quot;认真态&quot;返回到&quot;涣散态&quot;。随后执行启动时注册的看不懂处理函数&quot;逼自己看&quot;后，才重新进入&quot;认真态&quot;(并不能)。","like_count":30,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463146,"discussion_content":"赞，很生动，加油","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566280634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1496577,"avatar":"https://static001.geekbang.org/account/avatar/00/16/d6/01/2448b4a9.jpg","nickname":"py","note":"","ucode":"2372522D715419","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545400,"discussion_content":"感觉死机了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641951165,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1317847,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1b/d7/868d26ce.jpg","nickname":"songhyunmin","note":"","ucode":"D5A98668CD8532","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541364,"discussion_content":"两种态来回的切换","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640341974,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106622,"user_name":"Sharry","can_delete":false,"product_type":"c1","uid":1239293,"ip_address":"","ucode":"045DDB864659F6","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/fd/035f4c94.jpg","comment_is_top":false,"comment_ctime":1561357865,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"44511030825","product_id":100024701,"comment_content":"Linux 信号通信主要由如下几个步骤组成<br>- 信号处理函数的注册<br>  - 信号处理函数的注册, 定义在用户空间 <br>  - 注册最终通过 rt_sigaction 系统调用发起<br>  - 将用户空间定义的信号处理函数保存到 task_struct 中 sighand 的 action 数组中<br>- 信号的发送<br>  - 信号的发送通过 kill&#47;tkill&#47;tgkill&#47;rt_sigqueueinfo 函数执行<br>  - 最终通过 __send_signal, 将这个信号添加到对应 进程&#47;线程 的信号待处理链表中<br>    - &lt; 32 为不可靠信号, 待处理列表中存在该信号, 则会自动忽略<br>    - &gt;= 32 为可靠信号, 同一个信号会被添加到信号队列中<br>- 信号的处理<br>  - 信号的处理会在系统调用或中断处理结束返回用户空间的时机通过 exit_to_usermode_loop 中的 do_signal 执行<br>  - 修改用户函数栈, 插入我们构建的信号处理函数的栈帧 rt_sigframe, 并且将原来的函数栈信息保存在 uc_mcontext 中<br>  - 信号处理函数执行结束之后, 会通过系统调用 rt_sigreturn 恢复之前用户态栈","like_count":10},{"had_liked":false,"id":106513,"user_name":"小龙的城堡","can_delete":false,"product_type":"c1","uid":1005727,"ip_address":"","ucode":"7F1F9704548E2D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/58/9f/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1561338469,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"23036174949","product_id":100024701,"comment_content":"这一章讲得非常棒！很清晰！感谢老师！","like_count":5,"discussions":[{"author":{"id":1876423,"avatar":"","nickname":"Geek_951678","note":"","ucode":"C4182D3AE7A533","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":279484,"discussion_content":"认同，这一章特别清晰，对着最后的总结图，自己也能大致疏理出流程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591353858,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312348,"user_name":"徐少文","can_delete":false,"product_type":"c1","uid":1670331,"ip_address":"","ucode":"8E35B10DA44EE3","user_header":"https://static001.geekbang.org/account/avatar/00/19/7c/bb/635a2710.jpg","comment_is_top":false,"comment_ctime":1631762587,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14516664475","product_id":100024701,"comment_content":"看了后面的图一下子就茅塞顿开了，一边感叹Linux内核设计的精妙，一边觉得老师功力深厚","like_count":3},{"had_liked":false,"id":226139,"user_name":"韩俊臣","can_delete":false,"product_type":"c1","uid":1475340,"ip_address":"","ucode":"D6A15C025570D5","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/0c/b9e39db4.jpg","comment_is_top":false,"comment_ctime":1591960010,"is_pvip":false,"replies":[{"id":"83459","content":"谢谢","user_name":"作者回复","comment_id":226139,"uid":"1001590","ip_address":"","utype":1,"ctime":1592185957,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"14476861898","product_id":100024701,"comment_content":"能把这么复杂的调用链讲的这么生动，大写的服","like_count":3,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498120,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592185957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107082,"user_name":"chengzise","can_delete":false,"product_type":"c1","uid":1006070,"ip_address":"","ucode":"1C27D216359894","user_header":"https://static001.geekbang.org/account/avatar/00/0f/59/f6/ed66d1c1.jpg","comment_is_top":false,"comment_ctime":1561455813,"is_pvip":false,"replies":[{"id":"48863","content":"差不多的","user_name":"作者回复","comment_id":107082,"uid":"1001590","ip_address":"","utype":1,"ctime":1567501522,"user_name_real":"刘超@网易云"}],"discussion_count":2,"race_medal":0,"score":"10151390405","product_id":100024701,"comment_content":"老师好，文章的信号处理流程是在程序进入系统调用后接收到信号的情况。希望老师补充一下，程序没有进入系统调用（一个简单的死循环程序），此时接收到系统信号会走什么样的流程。谢谢。","like_count":2,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455358,"discussion_content":"差不多的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567501522,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1101226,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cd/aa/33d48789.jpg","nickname":"卫江","note":"","ucode":"DE2F7A6916F1A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2823,"discussion_content":"信号处理的时机和调度的时机基本一致，都是当需要的时候，设置标签位，然后等下一次从系统调用返回或中断返回的时候进行判断进而处理，当发生用户态死循环的时候，不会调用系统调用，但是不代表不会处理中断（尤其是时间中断，这样一来才能保证当进程执行的cpu时间太长就需要强制让出了cpu），当从中断处理返回的时候，同样是从内核态到用户态，同样会进行判断是不是收到信号进而进行处理。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1563957093,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322096,"user_name":"当你的世界里有风吹过","can_delete":false,"product_type":"c1","uid":2051946,"ip_address":"","ucode":"42712891366309","user_header":"https://static001.geekbang.org/account/avatar/00/1f/4f/6a/0a6b437e.jpg","comment_is_top":false,"comment_ctime":1637163039,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5932130335","product_id":100024701,"comment_content":"老师有一点，没有想明白。信号处理函数处理完成之后，系统设计的时候，为啥不直接返回用户态LineA的地方？ 这样不是省事了吗？","like_count":1,"discussions":[{"author":{"id":1035612,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cd/5c/e09eac13.jpg","nickname":"刘強","note":"","ucode":"B2E41BB894A727","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535587,"discussion_content":"不行的。你想想用户态LINEA的所有用于恢复的东西还在内核数据结构里面，包括寄存器什么的。返回不止要返回到正确的地址，还要有各种寄存器的恢复，那如何进内核呢？只能再执行一个系统调用，然后把用户态的场景恢复，完。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1638492374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":256988,"user_name":"莫名","can_delete":false,"product_type":"c1","uid":1007254,"ip_address":"","ucode":"E28F2602BA25DD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/96/a03175bc.jpg","comment_is_top":false,"comment_ctime":1603805868,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5898773164","product_id":100024701,"comment_content":"最后一张图很棒。","like_count":2,"discussions":[{"author":{"id":2058258,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/68/12/031a05c3.jpg","nickname":"A免帅叫哥","note":"","ucode":"76D2522E602AEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":395244,"discussion_content":"大佬，这是几刷了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632273816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":228609,"user_name":"蹦哒","can_delete":false,"product_type":"c1","uid":1458931,"ip_address":"","ucode":"56591A657DE7C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epcs6PibsP9vEXv4EibUw3bhQPUK04zRTOvfrvF08TwM67xPb1LBh2uRENHQwo2VqYfC5GhJmM7icxHA/132","comment_is_top":false,"comment_ctime":1592752200,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5887719496","product_id":100024701,"comment_content":"请问老师：<br>1.如果系统调用和信号处理不是在同一个线程，那么处理逻辑也是差不多的吗，也就是会保存用户态栈到sa_resstore - 系统处理函数插入用户态栈中 - 恢复sa_resstore - 返回系统调用位置？<br>2.debug也是基于信号的，那么触发了断点后，在调试过程中，同一线程中原来的系统调用（比如Socket请求）的处理函数一直得不到处理吗？","like_count":1},{"had_liked":false,"id":140499,"user_name":"Helios","can_delete":false,"product_type":"c1","uid":1380758,"ip_address":"","ucode":"BE6B98EE8F0D09","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKJrOl63enWXCRxN0SoucliclBme0qrRb19ATrWIOIvibKIz8UAuVgicBMibIVUznerHnjotI4dm6ibODA/132","comment_is_top":false,"comment_ctime":1570967586,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5865934882","product_id":100024701,"comment_content":"我们在 get_sigframe 中会得到 pt_regs 的 sp 变量，也就是原来这个程序在用户态的栈顶指针，然后 get_sigframe 中，我们会将 sp 减去 sizeof(struct rt_sigframe)，也就是把这个栈帧塞到了栈里面，然后我们又在 __setup_rt_frame 中把 regs-&gt;sp 设置成等于 frame。这就相当于强行在程序原来的用户态的栈里面插入了一个栈帧，并在最后将 regs-&gt;ip 设置为用户定义的信号处理函数 sa_handler。这意味着，本来返回用户态应该接着原来的代码执行的，现在不了，要执行 sa_handler 了。那执行完了以后呢？按照函数栈的规则，弹出上一个栈帧来，也就是弹出了 frame。<br><br><br>------------------------<br><br>**我们会将 sp 减去 sizeof(struct rt_sigframe)，也就是把这个栈帧塞到了栈里面**<br>老师，请问这句话怎么理解呢，为什么把sp减去sizeof(struct rt_sigframe)就是把帧放到栈里面呢？<br><br>**我们又在 __setup_rt_frame 中把 regs-&gt;sp 设置成等于 frame。这就相当于强行在程序原来的用户态的栈里面插入了一个栈帧**<br>为什么要把sp先减掉一部分，在换指向呢，直接换指向不行么<br>","like_count":1,"discussions":[{"author":{"id":1452167,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJcwXucibksEYRSYg6icjibzGa7efcMrCsGec2UwibjTd57icqDz0zzkEEOM2pXVju60dibzcnQKPfRkN9g/132","nickname":"Geek_93970d","note":"","ucode":"52AC308BEC7737","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574091,"discussion_content":"栈是向下增长的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653831766,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106584,"user_name":"刘強","can_delete":false,"product_type":"c1","uid":1035612,"ip_address":"","ucode":"B2E41BB894A727","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cd/5c/e09eac13.jpg","comment_is_top":false,"comment_ctime":1561349770,"is_pvip":false,"replies":[{"id":"38642","content":"不能，调试也是靠信号","user_name":"作者回复","comment_id":106584,"uid":"1001590","ip_address":"","utype":1,"ctime":1561419950,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"5856317066","product_id":100024701,"comment_content":"老师，既然内核态对用户态的栈随意操作（果然是内核，权利就是大），但返回的时候还是保持系统调用前的样子，丝毫没有察觉背后发生了这么多事情，就好像调用了一个普通用户态的函数一样，那么我在用户态调试程序的时候，能否看到这种内核对用户栈的修改？","like_count":1,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455146,"discussion_content":"不能，调试也是靠信号","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561419950,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":350336,"user_name":"cellphone峰","can_delete":false,"product_type":"c1","uid":1477273,"ip_address":"","ucode":"F09214B4F37161","user_header":"https://static001.geekbang.org/account/avatar/00/16/8a/99/f50df019.jpg","comment_is_top":false,"comment_ctime":1656829536,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1656829536","product_id":100024701,"comment_content":"返回- ERESTARTSYS而不是EINRT用户态需要自己重启系统调用吗？还是内核会自动重启？","like_count":0},{"had_liked":false,"id":348938,"user_name":"Geek_964a1d","can_delete":false,"product_type":"c1","uid":2776720,"ip_address":"","ucode":"C2653552516662","user_header":"","comment_is_top":false,"comment_ctime":1655592083,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655592083","product_id":100024701,"comment_content":"如果进程一直在用户态，是不是就不会处理信号了？","like_count":0},{"had_liked":false,"id":327333,"user_name":"Run","can_delete":false,"product_type":"c1","uid":1371941,"ip_address":"","ucode":"6738D2F36ACFF6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLMDBq7lqg9ZasC4f21R0axKJRVCBImPKlQF8yOicLLXIsNgsZxsVyN1mbvFOL6eVPluTNgJofwZeA/132","comment_is_top":false,"comment_ctime":1640069926,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640069926","product_id":100024701,"comment_content":"受益良多啊","like_count":0},{"had_liked":false,"id":321820,"user_name":"Run","can_delete":false,"product_type":"c1","uid":1371941,"ip_address":"","ucode":"6738D2F36ACFF6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLMDBq7lqg9ZasC4f21R0axKJRVCBImPKlQF8yOicLLXIsNgsZxsVyN1mbvFOL6eVPluTNgJofwZeA/132","comment_is_top":false,"comment_ctime":1637054164,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637054164","product_id":100024701,"comment_content":"配合最后的总结加图片过一下流程,让我顿时有种醍醐灌顶的感觉,爽歪歪啊","like_count":0},{"had_liked":false,"id":313064,"user_name":"xmeng","can_delete":false,"product_type":"c1","uid":1731543,"ip_address":"","ucode":"C0CA2182BA3B4B","user_header":"https://static001.geekbang.org/account/avatar/00/1a/6b/d7/8872624a.jpg","comment_is_top":false,"comment_ctime":1632238062,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1632238062","product_id":100024701,"comment_content":"最后一张总结图画得真心好，niubility","like_count":0},{"had_liked":false,"id":302321,"user_name":"mouse","can_delete":false,"product_type":"c1","uid":2403653,"ip_address":"","ucode":"3522B61845F46B","user_header":"https://static001.geekbang.org/account/avatar/00/24/ad/45/beab1b3f.jpg","comment_is_top":false,"comment_ctime":1626164947,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626164947","product_id":100024701,"comment_content":"我只能自己封装下了。<br>信号处理不是中断，在调度的时候折腾栈帧在用户栈里执行信号处理函数，然后继续折腾栈帧返回。","like_count":0},{"had_liked":false,"id":298273,"user_name":"阿虎","can_delete":false,"product_type":"c1","uid":1689796,"ip_address":"","ucode":"007B09EA91B73E","user_header":"https://static001.geekbang.org/account/avatar/00/19/c8/c4/6e50a16b.jpg","comment_is_top":false,"comment_ctime":1623992698,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623992698","product_id":100024701,"comment_content":"这个图是画的真的好","like_count":0},{"had_liked":false,"id":274352,"user_name":"AlexS","can_delete":false,"product_type":"c1","uid":1472051,"ip_address":"","ucode":"3DA81A613CE645","user_header":"https://static001.geekbang.org/account/avatar/00/16/76/33/928ffd21.jpg","comment_is_top":false,"comment_ctime":1610975489,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610975489","product_id":100024701,"comment_content":"哇，这一段分析可太秀了。佩服。","like_count":0},{"had_liked":false,"id":246237,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1599216329,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1599216329","product_id":100024701,"comment_content":"所以只有在调用系统调用的时候才能处理收到的信号吗？","like_count":0,"discussions":[{"author":{"id":1203671,"avatar":"","nickname":"风逐残叶_c","note":"","ucode":"9BB90C99B09691","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369617,"discussion_content":"应该是从内核态返回用户态的时候都行吧。比如被调度器调度走了，再回来的时候。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1619097494,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239989,"user_name":"Geek_Mason","can_delete":false,"product_type":"c1","uid":2051737,"ip_address":"","ucode":"466AEC19B30AF6","user_header":"https://static001.geekbang.org/account/avatar/00/1f/4e/99/3e095dd0.jpg","comment_is_top":false,"comment_ctime":1596707316,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596707316","product_id":100024701,"comment_content":"这可比自己看书通透好多","like_count":0},{"had_liked":false,"id":237991,"user_name":"xuanyuan","can_delete":false,"product_type":"c1","uid":1113737,"ip_address":"","ucode":"1EC79B9372868F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2icbib62icXtibTkThtyRksbuJLoTLMts7zook2S30MiaBtbz0f5JskwYicwqXkhpYfvCpuYkcvPTibEaQ/132","comment_is_top":false,"comment_ctime":1596023315,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596023315","product_id":100024701,"comment_content":"讲得很清楚","like_count":0},{"had_liked":false,"id":190349,"user_name":"CycleGAN","can_delete":false,"product_type":"c1","uid":1679661,"ip_address":"","ucode":"9FD04813911A02","user_header":"https://static001.geekbang.org/account/avatar/00/19/a1/2d/599e9051.jpg","comment_is_top":false,"comment_ctime":1584631296,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584631296","product_id":100024701,"comment_content":"老师的这个图是真的清晰","like_count":0},{"had_liked":false,"id":164425,"user_name":"shangyu","can_delete":false,"product_type":"c1","uid":1011389,"ip_address":"","ucode":"13A26E53508D75","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6e/bd/b83ad32d.jpg","comment_is_top":false,"comment_ctime":1576986559,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576986559","product_id":100024701,"comment_content":"最后的图一目了然 👍","like_count":0},{"had_liked":false,"id":123163,"user_name":"嘉木","can_delete":false,"product_type":"c1","uid":1317999,"ip_address":"","ucode":"AF4877693782C0","user_header":"https://static001.geekbang.org/account/avatar/00/14/1c/6f/3ea2a599.jpg","comment_is_top":false,"comment_ctime":1565618450,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565618450","product_id":100024701,"comment_content":"21.这次因为 pt_regs 已经指向 line A 了，于是就到了进程 A 中，接着系统调用之后运行，然这个系统调用返回的是它被中断了，没有执行完的错误。<br><br>清除SA_RESTART标志位的话会返回没有执行完的错误，但如果设置了SA_RESTART，系统调用会在哪一步重试呢？","like_count":0},{"had_liked":false,"id":121011,"user_name":"饭粒","can_delete":false,"product_type":"c1","uid":1153455,"ip_address":"","ucode":"4C3220B0D43997","user_header":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","comment_is_top":false,"comment_ctime":1565050031,"is_pvip":false,"replies":[{"id":"46355","content":"谢谢啦","user_name":"作者回复","comment_id":121011,"uid":"1001590","ip_address":"","utype":1,"ctime":1566296903,"user_name_real":"刘超@网易云"}],"discussion_count":1,"race_medal":0,"score":"1565050031","product_id":100024701,"comment_content":"梳理的真清楚。","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461574,"discussion_content":"谢谢啦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566296903,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107069,"user_name":"humor","can_delete":false,"product_type":"c1","uid":1181867,"ip_address":"","ucode":"9B48C4C7BEC92C","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/ab/caec7bca.jpg","comment_is_top":false,"comment_ctime":1561452935,"is_pvip":false,"replies":[{"id":"48865","content":"有安全硬件，还有安全操作系统的，不过还是要相信linux","user_name":"作者回复","comment_id":107069,"uid":"1001590","ip_address":"","utype":1,"ctime":1567501726,"user_name_real":"刘超@网易云"}],"discussion_count":3,"race_medal":0,"score":"1561452935","product_id":100024701,"comment_content":"老师，我突然想到了一个稍微无关的问题想请教一下。就是linux的安全问题，现在基本服务器上使用的操作系统都是linux，而安装linux只是下载一个系统镜像就可以安装了，但是，我们怎么能相信我们下载的linux镜像肯定没有安全问题呢，比如发布方安装了恶意程序或者开了一个后门之类的。我想了解一下一般的云服务厂商是怎么检测这类操作系统或者更加底层的硬件的安全问题的呢？","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455353,"discussion_content":"有安全硬件，还有安全操作系统的，不过还是要相信linux","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567501726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1475683,"avatar":"https://static001.geekbang.org/account/avatar/00/16/84/63/7645ecee.jpg","nickname":"Simple","note":"","ucode":"765D1AB2CCE39B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1621,"discussion_content":"md5啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1562742530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1476675,"avatar":"https://static001.geekbang.org/account/avatar/00/16/88/43/31641bf0.jpg","nickname":"布朗老熊","note":"","ucode":"A8AF82550AFF9C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6144,"discussion_content":"一般企业用的都是红帽系列吧，付费的东西，他们厂家会保证安全无风险，不然还怎么赚钱。不过，真要对别人的操作系统有顾虑，或者自己开发的操作系统，对于内核和端口都有相应的检测工具，有形式化、模糊测试和符号执行之类的技术，这方面的研究挺多的，计算机安全顶会有相关论文，可以下载下来看看。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566724686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106646,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1561364182,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561364182","product_id":100024701,"comment_content":"讲得太好了，真是深入浅出啊！","like_count":0}]}