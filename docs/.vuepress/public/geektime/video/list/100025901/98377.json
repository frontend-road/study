{"id":98377,"title":"49 | 开源存储方案对比与分析","content":"<p><strong>PDF 课件和源代码下载地址：</strong></p><p><a href=\"https://gitee.com/geektime-geekbang/geektime-ios-course\">https://gitee.com/geektime-geekbang/geektime-ios-course</a></p>","comments":[{"had_liked":false,"id":140009,"user_name":"BabyT1ger","can_delete":false,"product_type":"c3","uid":1141146,"ip_address":"","ucode":"3F260B6B6C0260","user_header":"https://static001.geekbang.org/account/avatar/00/11/69/9a/6eb47718.jpg","comment_is_top":false,"comment_ctime":1570785292,"is_pvip":false,"replies":[{"id":54392,"content":"如果数据库泛指database，那么NSUserDefault当然是数据库，同时这个维度上的数据库也不需要考虑具体的数据存储方式。比如在官方文档上的定义（An interface to the user’s defaults database ...）。那么如果数据库指的是关系型的数据库，就是遵循SQL标准的，那么NSUserDefault是存储key-value的，不是关系型的数据库。课程中在最后也提到了iOS中常用的关系型数据库（SQLite&#47;FMDB&#47;WCDB）等。那么你提到的问题我理解是想区别于关系型的数据库，也正是由于底层实现的不同，在使用上NSUserDefault一般是存储一些配置信息（每次完整读取&#47;数据量小），而对于需要部分读取的、数据量较大或者符合关系型数据库存储的，我们采用SQLite等等其他的存储方式。","user_name":"作者回复","user_name_real":"zzz","uid":1041455,"ctime":1571034961,"ip_address":"","comment_id":140009,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100025901,"comment_content":"Nsuserdefault是基于plist文件封装的，不属于数据库吧","like_count":1,"discussions":[{"author":{"id":1041455,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKJ3dLlYr6tznfnZXJNsD7Jw48BVnFSib3RO3VWEN0pgebRY1jaR8YXLQ6iaAjTsFiamOWSA3UPAa37A/132","nickname":"Geek_e7jq8k","note":"","ucode":"352964E5D793DA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470211,"discussion_content":"如果数据库泛指database，那么NSUserDefault当然是数据库，同时这个维度上的数据库也不需要考虑具体的数据存储方式。比如在官方文档上的定义（An interface to the user’s defaults database ...）。那么如果数据库指的是关系型的数据库，就是遵循SQL标准的，那么NSUserDefault是存储key-value的，不是关系型的数据库。课程中在最后也提到了iOS中常用的关系型数据库（SQLite/FMDB/WCDB）等。那么你提到的问题我理解是想区别于关系型的数据库，也正是由于底层实现的不同，在使用上NSUserDefault一般是存储一些配置信息（每次完整读取/数据量小），而对于需要部分读取的、数据量较大或者符合关系型数据库存储的，我们采用SQLite等等其他的存储方式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571034961,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":285689,"user_name":"Geek__2099","can_delete":false,"product_type":"c3","uid":1457784,"ip_address":"","ucode":"01444B60F18A66","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep8unibCib9rdHib0D6Rf6TjecPQu1yic0G9sjzriczlTcwGHP6DaxtEmHyN7pCrD9zV7OSegyf7EUBvaA/132","comment_is_top":false,"comment_ctime":1616979782,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100025901,"comment_content":"Nsuserdefault，与之前的存文件都属于文件数据库，与关系型数据库并列，是存储阶段的不同方案。\n序列化，是发生在存储之前的阶段。\n数据在进入存储之前，不分基本类型还是对象，都要序列化成二进制。\n基本类型的数据，其值作为一个整体，类型又确定，因此系统知道如何将其二进制，所以有具体的方法对应。\n对象类型的数据，其内部有复杂结构，细节类型只有对象知道，因此系统只能提供抽象序列化方案，实现由用户定义。\n对比之前的写文件与plist方案：前者二进制化在写文件方法之前已经完成；后者对于对象类型在setobject之前也要完成序列化，区别是不需要再选择文件，而对于基本类型，除了不需要再选择文件，序列化和写入plist动作是在同一方法中完成的。\n对比plist与关系数据库，后者无疑是针对有复杂关系的数据模型。前者针对的，是相互独立，没有关系的数据集，并且单独一条数据，总是作为一个整体同入同出。\n猜想，keychain介乎两者之间？","like_count":4},{"had_liked":false,"id":353875,"user_name":"Bo","can_delete":false,"product_type":"c3","uid":2076600,"ip_address":"广东","ucode":"D5DD3300310C02","user_header":"https://static001.geekbang.org/account/avatar/00/1f/af/b8/458866d3.jpg","comment_is_top":false,"comment_ctime":1659880859,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100025901,"comment_content":"请问keychain在哪一节呢？好像没有找到","like_count":0}]}