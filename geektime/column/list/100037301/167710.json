{"id":167710,"title":"16 | 视图：如何实现服务和数据在微服务各层的协作？","content":"<p>你好，我是欧创新。</p><p>在DDD分层架构和微服务代码模型里，我们根据领域对象的属性和依赖关系，将领域对象进行分层，定义了与之对应的代码对象和代码目录结构。分层架构确定了微服务的总体架构，微服务内的主要对象有服务和实体等，它们一起协作完成业务逻辑。</p><p>那在运行过程中，这些服务和实体在微服务各层是如何协作的呢？今天我们就来解剖一下基于DDD分层架构的微服务，看看它的内部结构到底是什么样的。</p><h2>服务的协作</h2><h3>1. 服务的类型</h3><p>我们先来回顾一下分层架构中的服务。按照分层架构设计出来的微服务，其内部有Facade服务、应用服务、领域服务和基础服务。各层服务的主要功能和职责如下。</p><p><strong>Facade服务：</strong>位于用户接口层，包括接口和实现两部分。用于处理用户发送的Restful请求和解析用户输入的配置文件等，并将数据传递给应用层。或者在获取到应用层数据后，将DO组装成DTO，将数据传输到前端应用。</p><p><strong>应用服务：</strong>位于应用层。用来表述应用和用户行为，负责服务的组合、编排和转发，负责处理业务用例的执行顺序以及结果拼装，对外提供粗粒度的服务。</p><p><strong>领域服务：</strong>位于领域层。领域服务封装核心的业务逻辑，实现需要多个实体协作的核心领域逻辑。它对多个实体或方法的业务逻辑进行组合或编排，或者在严格分层架构中对实体方法进行封装，以领域服务的方式供应用层调用。</p><!-- [[[read_end]]] --><p><strong>基础服务：</strong>位于基础层。提供基础资源服务（比如数据库、缓存等），实现各层的解耦，降低外部资源变化对业务应用逻辑的影响。基础服务主要为仓储服务，通过依赖倒置提供基础资源服务。领域服务和应用服务都可以调用仓储服务接口，通过仓储服务实现数据持久化。</p><h3>2. 服务的调用</h3><p>我们看一下下面这张图。微服务的服务调用包括三类主要场景：微服务内跨层服务调用，微服务之间服务调用和领域事件驱动。</p><p><img src=\"https://static001.geekbang.org/resource/image/e5/db/e5d025a6fd69d1f2cf2a1af53253abdb.png?wh=2036*998\" alt=\"\"></p><p><strong>微服务内跨层服务调用</strong></p><p>微服务架构下往往采用前后端分离的设计模式，前端应用独立部署。前端应用调用发布在API网关上的Facade服务，Facade定向到应用服务。应用服务作为服务组织和编排者，它的服务调用有这样两种路径：</p><ul>\n<li>第一种是应用服务调用并组装领域服务。此时领域服务会组装实体和实体方法，实现核心领域逻辑。领域服务通过仓储服务获取持久化数据对象，完成实体数据初始化。</li>\n<li>第二种是应用服务直接调用仓储服务。这种方式主要针对像缓存、文件等类型的基础层数据访问。这类数据主要是查询操作，没有太多的领域逻辑，不经过领域层，不涉及数据库持久化对象。</li>\n</ul><p><strong>微服务之间的服务调用</strong></p><p>微服务之间的应用服务可以直接访问，也可以通过API网关访问。由于跨微服务操作，在进行数据新增和修改操作时，你需关注分布式事务，保证数据的一致性。</p><p><strong>领域事件驱动</strong></p><p>领域事件驱动包括微服务内和微服务之间的事件（详见 <a href=\"https://time.geekbang.org/column/article/155444\">[第 06 讲]</a>）。微服务内通过事件总线（EventBus）完成聚合之间的异步处理。微服务之间通过消息中间件完成。异步化的领域事件驱动机制是一种间接的服务访问方式。</p><p>当应用服务业务逻辑处理完成后，如果发生领域事件，可调用事件发布服务，完成事件发布。</p><p>当接收到订阅的主题数据时，事件订阅服务会调用事件处理领域服务，完成进一步的业务操作。</p><h3>3. 服务的封装与组合</h3><p>我们看一下下面这张图。微服务的服务是从领域层逐级向上封装、组合和暴露的。</p><p><img src=\"https://static001.geekbang.org/resource/image/2d/1d/2d6a328a9fd8b4b3906bb9f59435ca1d.png?wh=2076*1019\" alt=\"\"></p><p><strong>基础层</strong></p><p>基础层的服务形态主要是仓储服务。仓储服务包括接口和实现两部分。仓储接口服务供应用层或者领域层服务调用，仓储实现服务，完成领域对象的持久化或数据初始化。</p><p><strong>领域层</strong></p><p>领域层实现核心业务逻辑，负责表达领域模型业务概念、业务状态和业务规则。主要的服务形态有实体方法和领域服务。</p><p>实体采用充血模型，在实体类内部实现实体相关的所有业务逻辑，实现的形式是实体类中的方法。实体是微服务的原子业务逻辑单元。在设计时我们主要考虑实体自身的属性和业务行为，实现领域模型的核心基础能力。不必过多考虑外部操作和业务流程，这样才能保证领域模型的稳定性。</p><p>DDD提倡富领域模型，尽量将业务逻辑归属到实体对象上，实在无法归属的部分则设计成领域服务。领域服务会对多个实体或实体方法进行组装和编排，实现跨多个实体的复杂核心业务逻辑。</p><p>对于严格分层架构，如果单个实体的方法需要对应用层暴露，则需要通过领域服务封装后才能暴露给应用服务。</p><p><strong>应用层</strong></p><p>应用层用来表述应用和用户行为，负责服务的组合、编排和转发，负责处理业务用例的执行顺序以及结果的拼装，负责不同聚合之间的服务和数据协调，负责微服务之间的事件发布和订阅。</p><p>通过应用服务对外暴露微服务的内部功能，这样就可以隐藏领域层核心业务逻辑的复杂性以及内部实现机制。应用层的主要服务形态有：应用服务、事件发布和订阅服务。</p><p>应用服务内用于组合和编排的服务，主要来源于领域服务，也可以是外部微服务的应用服务。除了完成服务的组合和编排外，应用服务内还可以完成安全认证、权限校验、初步的数据校验和分布式事务控制等功能。</p><p>为了实现微服务内聚合之间的解耦，聚合之间的服务调用和数据交互应通过应用服务来完成。原则上我们应该禁止聚合之间的领域服务直接调用和聚合之间的数据表关联。</p><p><strong>用户接口层</strong></p><p>用户接口层是前端应用和微服务之间服务访问和数据交换的桥梁。它处理前端发送的Restful请求和解析用户输入的配置文件等，将数据传递给应用层。或获取应用服务的数据后，进行数据组装，向前端提供数据服务。主要服务形态是Facade服务。</p><p>Facade服务分为接口和实现两个部分。完成服务定向，DO与DTO数据的转换和组装，实现前端与应用层数据的转换和交换。</p><h3>4. 两种分层架构的服务依赖关系</h3><p>现在我们回顾一下DDD分层架构，分层架构有一个重要的原则就是：每层只能与位于其下方的层发生耦合。</p><p>那根据耦合的紧密程度，分层架构可以分为两种：严格分层架构和松散分层架构。在严格分层架构中，任何层只能与位于其直接下方的层发生依赖。在松散分层架构中，任何层可以与其任意下方的层发生依赖。</p><p>下面我们来详细分析和比较一下这两种分层架构。</p><p><strong>松散分层架构的服务依赖</strong></p><p>我们看一下下面这张图，在松散分层架构中，领域层的实体方法和领域服务可以直接暴露给应用层和用户接口层。松散分层架构的服务依赖关系，无需逐级封装，可以快速暴露给上层。</p><p>但它存在一些问题，第一个是容易暴露领域层核心业务的实现逻辑；第二个是当实体方法或领域服务发生服务变更时，由于服务同时被多层服务调用和组合，不容易找出哪些上层服务调用和组合了它，不方便通知到所有的服务调用方。</p><p><img src=\"https://static001.geekbang.org/resource/image/5e/a1/5e901b4f7fa964b349e4d6f344786ea1.png?wh=1123*462\" alt=\"\"></p><p>我们再来看一张图，在松散分层架构中，实体A的方法在应用层组合后，暴露给用户接口层aFacade。abDomainService领域服务直接越过应用层，暴露给用户接口层abFacade服务。松散分层架构中任意下层服务都可以暴露给上层服务。</p><p><img src=\"https://static001.geekbang.org/resource/image/b3/a0/b35d6fed54e26423c0d61de040ab04a0.jpeg?wh=1672*1402\" alt=\"\"></p><p><strong>严格分层架构的服务依赖</strong></p><p>我们看一下下面这张图，在严格分层架构中，每一层服务只能向紧邻的上一层提供服务。虽然实体、实体方法和领域服务都在领域层，但实体和实体方法只能暴露给领域服务，领域服务只能暴露给应用服务。</p><p>在严格分层架构中，服务如果需要跨层调用，下层服务需要在上层封装后，才可以提供跨层服务。比如实体方法需要向应用服务提供服务，它需要封装成领域服务。</p><p>这是因为通过封装你可以避免将核心业务逻辑的实现暴露给外部，将实体和方法封装成领域服务，也可以避免在应用层沉淀过多的本该属于领域层的核心业务逻辑，避免应用层变得臃肿。还有就是当服务发生变更时，由于服务只被紧邻上层的服务调用和组合，你只需要逐级告知紧邻上层就可以了，服务可管理性比松散分层架构要好是一定的。</p><p><img src=\"https://static001.geekbang.org/resource/image/ab/07/ab304d69ee174b5e69cb63d79864ca07.png?wh=1124*445\" alt=\"\"></p><p>我们还是看图，A实体方法需封装成领域服务aDomainService才能暴露给应用服务aAppService。abDomainService领域服务组合和封装A和B实体的方法后，暴露给应用服务abAppService。</p><p><img src=\"https://static001.geekbang.org/resource/image/34/f9/348d60eac28c9dbf7d120d1b7159cdf9.png?wh=2158*1431\" alt=\"\"></p><h2>数据对象视图</h2><p>在DDD中有很多的数据对象，这些对象分布在不同的层里。它们在不同的阶段有不同的形态。你可以再回顾一下 <a href=\"https://time.geekbang.org/column/article/152677\">[第 04 讲]</a>，这一讲有详细的讲解。</p><p>我们先来看一下微服务内有哪些类型的数据对象？它们是如何协作和转换的？</p><ul>\n<li>数据持久化对象PO(Persistent Object)，与数据库结构一一映射，是数据持久化过程中的数据载体。</li>\n<li>领域对象DO（Domain Object），微服务运行时的实体，是核心业务的载体。</li>\n<li>数据传输对象DTO（Data Transfer Object），用于前端与应用层或者微服务之间的数据组装和传输，是应用之间数据传输的载体。</li>\n<li>视图对象VO（View Object），用于封装展示层指定页面或组件的数据。</li>\n</ul><p>我们结合下面这张图，看看微服务各层数据对象的职责和转换过程。</p><p><img src=\"https://static001.geekbang.org/resource/image/26/13/26dec215ba4359bdc30a1e2cc6007213.png?wh=2038*962\" alt=\"\"></p><p><strong>基础层</strong></p><p>基础层的主要对象是PO对象。我们需要先建立DO和PO的映射关系。当DO数据需要持久化时，仓储服务会将DO转换为PO对象，完成数据库持久化操作。当DO数据需要初始化时，仓储服务从数据库获取数据形成PO对象，并将PO转换为DO，完成数据初始化。</p><p>大多数情况下PO和DO是一一对应的。但也有DO和PO多对多的情况，在DO和PO数据转换时，需要进行数据重组。</p><p><strong>领域层</strong></p><p>领域层的主要对象是DO对象。DO是实体和值对象的数据和业务行为载体，承载着基础的核心业务逻辑。通过DO和PO转换，我们可以完成数据持久化和初始化。</p><p><strong>应用层</strong></p><p>应用层的主要对象是DO对象。如果需要调用其它微服务的应用服务，DO会转换为DTO，完成跨微服务的数据组装和传输。用户接口层先完成DTO到DO的转换，然后应用服务接收DO进行业务处理。如果DTO与DO是一对多的关系，这时就需要进行DO数据重组。</p><p><strong>用户接口层</strong></p><p>用户接口层会完成DO和DTO的互转，完成微服务与前端应用数据交互及转换。Facade服务会对多个DO对象进行组装，转换为DTO对象，向前端应用完成数据转换和传输。</p><p><strong>前端应用</strong></p><p>前端应用主要是VO对象。展现层使用VO进行界面展示，通过用户接口层与应用层采用DTO对象进行数据交互。</p><h2>总结</h2><p>今天我们分析了DDD分层架构下微服务的服务和数据的协作关系。为了实现聚合之间以及微服务各层之间的解耦，我们在每层定义了不同职责的服务和数据对象。在软件开发过程中，我们需要严格遵守各层服务和数据的职责要求，各据其位，各司其职。这样才能保证核心领域模型的稳定，同时也可以灵活应对外部需求的快速变化。</p><h2>思考题</h2><p>你知道在微服务内为什么要设计不同的服务和不同的数据对象吗？它体现的是一种什么样的设计思想？</p><p>欢迎留言和我分享你的思考，你也可以把今天所学分享给身边的朋友，邀请他加入探讨，共同进步。</p><p><img src=\"https://static001.geekbang.org/resource/image/7b/33/7b1a917aff0ec923b78a54e81ed90733.jpg?wh=1110*659\" alt=\"unpreview\"></p>","comments":[{"had_liked":false,"id":153333,"user_name":"瓜瓜","can_delete":false,"product_type":"c1","uid":1108505,"ip_address":"","ucode":"F90A5135A9BB4B","user_header":"https://static001.geekbang.org/account/avatar/00/10/ea/19/14018371.jpg","comment_is_top":false,"comment_ctime":1574219677,"is_pvip":false,"replies":[{"id":"58952","content":"理解的非常好。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574225568,"ip_address":"","comment_id":153333,"utype":1}],"discussion_count":2,"race_medal":0,"score":"78883631005","product_id":100037301,"comment_content":"各种数据对象的转换放在那一层，很重要，比如vo与dto的转换放在前端应用，dto与do的转换放在用户接口层或者是应用层（根据用户接口层与应用层发生调用，还是微服务之间应用层发生调用而定），领域层只有DO，DO与PO的转换放在仓储实现里面，基础层只操作PO，至于仓储层的实现是放在领域层还是基础层，可以根据具体情况而定，放在基础层则为严格分层，放在领域层，则方便微服务的拆分和组合。望老师指正","like_count":18,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475125,"discussion_content":"理解的非常好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574225568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1432755,"avatar":"https://static001.geekbang.org/account/avatar/00/15/dc/b3/1e09c2d5.jpg","nickname":"Homto","note":"","ucode":"EBA8CDB9FC4AFD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":564138,"discussion_content":"有指导意义，棒👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650166926,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157044,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1575017821,"is_pvip":false,"replies":[{"id":"60263","content":"如果是你说的这种情况，也是可以的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1575024156,"ip_address":"","comment_id":157044,"utype":1}],"discussion_count":8,"race_medal":0,"score":"61704559965","product_id":100037301,"comment_content":"应用层其实我觉得入参数是DTO比较好，因为应用层是要暴漏给其他微服务调用的。然后在应用层将DTO转为DO来调用领域服务。如果调用其他微服务，则构造对方服务需要的DTO来调用。","like_count":14,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476313,"discussion_content":"如果是你说的这种情况，也是可以的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575024156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1401837,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIG3L8ToibAiaHqWmMP9uuHpAhMJcScSwibpUW0IichAr2vsgymwsMWvVnwo8IH2OYdq62eMVpSM374iaQ/132","nickname":"极客","note":"","ucode":"478628BE35AEE3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288930,"discussion_content":"老师讲的应该是,接口层把DTO转为DO传给应用层，如果应用层需要调用外部微服务则需要把DO转为DTO，这2个DTO本来就不是同一个DTO，没问题","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1593935000,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1931692,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/VjomKNzfFiaIttqYMxbjAWTG7NL7P2UqC5fbSvg0JW80SLnoR2oH1G4U2eibmxbR4wPpoqZdDnjC8GqgShDOBRzA/132","nickname":"秦伟","note":"","ucode":"D47C1F57500FE1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219439,"discussion_content":"老师的意思是，没有原则，就是最好的原则","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585755042,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2740535,"avatar":"https://static001.geekbang.org/account/avatar/00/29/d1/37/24c8cdfc.jpg","nickname":"阿灿","note":"","ucode":"222DCB1BCA1B03","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":409805,"discussion_content":"DTO不能在应用层调用吧，dto是属于API层，不能从上到下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635515937,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2043294,"avatar":"","nickname":"0084","note":"","ucode":"EC5085EEEB1E12","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302284,"discussion_content":"应用层之间的跨微服务调用，是不是应该先过被调微服务的用户接口再到应用服务？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598867791,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2056642,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/61/c2/acd6036d.jpg","nickname":"free","note":"","ucode":"A2E9DDBA71827A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294454,"discussion_content":"范围查询怎么用DO","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595897869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1100064,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","nickname":"zj","note":"","ucode":"E3329CCF694AC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2056642,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/61/c2/acd6036d.jpg","nickname":"free","note":"","ucode":"A2E9DDBA71827A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295420,"discussion_content":"用CQRS","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596190564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":294454,"ip_address":""},"score":295420,"extra":""}]},{"author":{"id":1094726,"avatar":"https://static001.geekbang.org/account/avatar/00/10/b4/46/686f5abe.jpg","nickname":"SnoWalker","note":"","ucode":"826A3DE7E3AEC9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":264632,"discussion_content":"但是我觉得老师讲解的本来就是DTO穿透到应用层，再装换为DO到领域层，你可以看看图","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589339173,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153440,"user_name":"。","can_delete":false,"product_type":"c1","uid":1222200,"ip_address":"","ucode":"75B163F01F20F3","user_header":"https://static001.geekbang.org/account/avatar/00/12/a6/38/55483b8c.jpg","comment_is_top":false,"comment_ctime":1574236018,"is_pvip":false,"replies":[{"id":"59044","content":"1、可以的。<br>2、是否要做数据转换？主要是考虑解耦，这样各层不必受其它层的数据限制，它类似齿轮，通过数据转换来做适配。如果从前端到后端数据对象都是一样的，用一个对象其实也是可以的。要结合自己的场景来分析。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574300049,"ip_address":"","comment_id":153440,"utype":1}],"discussion_count":9,"race_medal":0,"score":"61703778162","product_id":100037301,"comment_content":"欧老师你好<br><br>用户接口层：入参是DTO，内部将DTO转化为DO后调用应用层，将应用层的结果转化为VO后返回给前台<br>应用层：入参是DO，返回值是DO<br>领域层：入参是DO，返回值是DO<br>基础层：入参是DO，内部将DO转化成PO进行数据库的增删改查，执行结果用PO去映射，再转化为DO作为基础层的返回值<br><br>问题1：时间范围查询时，会有辅助字段，如：beginTime和endTime，PO这怎么处理？我们的处理方式是增删改用PO，查询时候用QueryPO，QueryPO继承了PO并额外增加用于查询的辅助字段（比如时间、集合、模糊查询等），这样可以么？<br><br>问题2：有的查询功能，比如按照名称查询，查询条件就是name，DTO、DO和PO是一样的，也需要在每一层都去转化一下么？我们把查询时的对象命名为QueryPO，从用户接口层到基础层的入参都是这一个，这样可以么？","like_count":14,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475165,"discussion_content":"1、可以的。\n2、是否要做数据转换？主要是考虑解耦，这样各层不必受其它层的数据限制，它类似齿轮，通过数据转换来做适配。如果从前端到后端数据对象都是一样的，用一个对象其实也是可以的。要结合自己的场景来分析。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574300049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1463119,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJKmAmR8d7LkJy7fGg5dS9p7YjGcuXdjMb5aBmXoXLmU1Ws1KicZL43jAYMEsodO3Rj6GciabMuCT6g/132","nickname":"wlzjdx","note":"","ucode":"C5DACA9C1D5EA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":574219,"discussion_content":"所谓的标准不是这样也可以，那样也可以。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653907012,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":475165,"ip_address":""},"score":574219,"extra":""}]},{"author":{"id":1100064,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","nickname":"zj","note":"","ucode":"E3329CCF694AC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":221312,"discussion_content":"基础层用DO作为入参数，个人觉得不太好，我觉得用PO来比较好，如果是较复杂的PO可以考虑用Wrapper对象组合PO。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586002469,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1721221,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/43/85/a529c1ff.jpg","nickname":"Aries","note":"","ucode":"1F5E4CCFA5F38E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78051,"discussion_content":"查询可以直接在应用层调用数据层，可减少转换过程。根据CQRS，可以将Query 单独建立对象，Mapper文件进行分离。也可以使用共享模型，这个看实际情况。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575971822,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1038415,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d8/4f/65abc6f0.jpg","nickname":"KaitoShy","note":"","ucode":"E2E2E9BD3F5048","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1721221,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/43/85/a529c1ff.jpg","nickname":"Aries","note":"","ucode":"1F5E4CCFA5F38E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":240461,"discussion_content":"是直接从 Mapper 读取 PO，直接转成 DTO 么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587366439,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":78051,"ip_address":""},"score":240461,"extra":""},{"author":{"id":1096652,"avatar":"https://static001.geekbang.org/account/avatar/00/10/bb/cc/fac12364.jpg","nickname":"xxx","note":"","ucode":"E79CEA70430449","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1038415,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d8/4f/65abc6f0.jpg","nickname":"KaitoShy","note":"","ucode":"E2E2E9BD3F5048","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385628,"discussion_content":"俺就是这么做的。CRUD做2次转换实在是太累了。。做一次转换都觉得好累。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627185002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":240461,"ip_address":""},"score":385628,"extra":""},{"author":{"id":1627053,"avatar":"","nickname":"Geek_deb7fc","note":"","ucode":"6C4B8542C6BF3E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1038415,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d8/4f/65abc6f0.jpg","nickname":"KaitoShy","note":"","ucode":"E2E2E9BD3F5048","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590059,"discussion_content":"我们就是这样做的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665493050,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":240461,"ip_address":"陕西"},"score":590059,"extra":""}]},{"author":{"id":1100064,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","nickname":"zj","note":"","ucode":"E3329CCF694AC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":65641,"discussion_content":"应用层：入参是DO，返回值是DO\n这一点我觉得不太对，入参最好是DTO比较好，因为应用层服务一般是要暴漏给其他服务使用的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575017903,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1560281,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ce/d9/e3fc735c.jpg","nickname":"leo","note":"","ucode":"AAF0F90D8A2481","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1100064,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","nickname":"zj","note":"","ucode":"E3329CCF694AC2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":221278,"discussion_content":"应用层应该只是暴露给内部的用户接口层服务的吧？如果要调用其他服务的应用层，应该会先经过其他服务的用户接口层，然后转化成DO后进行调用。不应该存在直接调用其他服务的应用层这种情况吧？当然这自己我的想法。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1585997960,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":65641,"ip_address":""},"score":221278,"extra":""}]}]},{"had_liked":false,"id":165473,"user_name":"胖大蟲","can_delete":false,"product_type":"c1","uid":1300072,"ip_address":"","ucode":"04FDFFD273A695","user_header":"https://static001.geekbang.org/account/avatar/00/13/d6/68/3855df56.jpg","comment_is_top":false,"comment_ctime":1577242154,"is_pvip":false,"replies":[{"id":"64860","content":"DTO放应用层或者用户接口层都是可以的，保证外层依赖内层的原则就可以了，这些对象都在同一个微服务内。当应用服务调用其它微服务的应用服务的时候，DO和DTO的转换就在应用层。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1577672812,"ip_address":"","comment_id":165473,"utype":1}],"discussion_count":5,"race_medal":0,"score":"31642013226","product_id":100037301,"comment_content":"用户接口层会完成 DO 和 DTO 的互转，那不就等于将DO暴露给用户接口层了？按我的理解，DO从领域服务出来的时候就应该转换为DTO给应用层，从应用层开始往上（包括应用层）都不知道DO的存在；DO和DTO的互转，由领域服务负责，接收上层（应用层）传递的DTO，转换为DO，进而调用DO的方法完成业务逻辑，再将需要返回的数据转换为DTO返回给上层","like_count":7,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479175,"discussion_content":"DTO放应用层或者用户接口层都是可以的，保证外层依赖内层的原则就可以了，这些对象都在同一个微服务内。当应用服务调用其它微服务的应用服务的时候，DO和DTO的转换就在应用层。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577672812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1169474,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d8/42/d4e7a136.jpg","nickname":"有思想的芦苇","note":"","ucode":"AA0B96363B1587","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":410293,"discussion_content":"我也认为应该应用层负责DO和DTO的转换，DO暴露到用户接口层很明显违背了严格分层模式,用户接口层感觉就是BFF，也不应该直接操作DO","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1635652100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1288786,"avatar":"https://static001.geekbang.org/account/avatar/00/13/aa/52/8a623dde.jpg","nickname":"张秋明","note":"","ucode":"F1F0A06EFC772E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1169474,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d8/42/d4e7a136.jpg","nickname":"有思想的芦苇","note":"","ucode":"AA0B96363B1587","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549289,"discussion_content":"同一个应用层 可能对应多个接口，每个接口DTO可能不一样。如果放在应用层做转换，意味着应用层要根据不同的接口场景维护多种DTO，似乎又让应用层过重了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643811802,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":410293,"ip_address":""},"score":549289,"extra":""},{"author":{"id":1288786,"avatar":"https://static001.geekbang.org/account/avatar/00/13/aa/52/8a623dde.jpg","nickname":"张秋明","note":"","ucode":"F1F0A06EFC772E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1169474,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d8/42/d4e7a136.jpg","nickname":"有思想的芦苇","note":"","ucode":"AA0B96363B1587","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549290,"discussion_content":"也许将DTO的实现放在接口层，但是传递给应用层去完成转换更合适。DO不暴露给接口层","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643811902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":410293,"ip_address":""},"score":549290,"extra":""}]},{"author":{"id":1253652,"avatar":"https://static001.geekbang.org/account/avatar/00/13/21/14/423a821f.jpg","nickname":"Steven","note":"","ucode":"3FE64459842015","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545073,"discussion_content":"DTO的转换放在用户接口层，那DTO的定义肯定也是在用户接口层了。如果这样，应用服务在访问其它微服务的时候，又涉及到其它微服务的DTO对象的定义了，这个DTO对象的定义是放在应用层吗？\n\n即微服务A的用户接口层里定义了一些DTO对象，然后在应用层又定义了其它微服务，比如B的一些DTO对象，稍稍有点怪。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641819689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153519,"user_name":"张迪","can_delete":false,"product_type":"c1","uid":1104835,"ip_address":"","ucode":"6A5D44999A0FEA","user_header":"https://static001.geekbang.org/account/avatar/00/10/db/c3/e11adfe8.jpg","comment_is_top":false,"comment_ctime":1574252182,"is_pvip":false,"replies":[{"id":"58999","content":"前端可以做简单格式校验，稍微复杂数据的校验在应用层。业务规则和逻辑校验在领域层。<br>你说的这两个前端就可以校验。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574258474,"ip_address":"","comment_id":153519,"utype":1}],"discussion_count":7,"race_medal":0,"score":"31639023254","product_id":100037301,"comment_content":"传入数据的格式校验放在哪层做？例如手机号格式校验、姓名长度校验等","like_count":7,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475196,"discussion_content":"前端可以做简单格式校验，稍微复杂数据的校验在应用层。业务规则和逻辑校验在领域层。\n你说的这两个前端就可以校验。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574258474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1618328,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b1/98/11b22d79.jpg","nickname":"絆","note":"","ucode":"52D965461314DB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379422,"discussion_content":"在微服务中,保证微服的稳定性,服务端做好校验会更好,这样系统会更稳定.前端校验更多是体验上的校验,即客户端调用服务端.客户端和服务端最好不要相互信任,做好自己的校验保证服务的稳定性.","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1623899985,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1104835,"avatar":"https://static001.geekbang.org/account/avatar/00/10/db/c3/e11adfe8.jpg","nickname":"张迪","note":"","ucode":"6A5D44999A0FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54094,"discussion_content":"光前端做检验，不太安全吧，我们一般后端也检验","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574258543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1683548,"avatar":"https://static001.geekbang.org/account/avatar/00/19/b0/5c/b85b0748.jpg","nickname":"他们都叫我雷哥","note":"","ucode":"C24F920C28A93D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575939,"discussion_content":"我理解一般非空校验等比较简单的校验在controller层通过注解直接做掉。需求文档中描述的校验在对应的实体中完成:领域模型从某种意义上说就是对需求文档的翻译","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655198064,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1792636,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/5a/7c/9966dd95.jpg","nickname":"7654321","note":"","ucode":"7A50254446D49D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336481,"discussion_content":"后端不做校验，别人调接口就炸了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608606119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54373,"discussion_content":"都可以的。如果接入的前端比较多，微服务内校验也是必需的，主要还是应用层来做。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574297133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1104835,"avatar":"https://static001.geekbang.org/account/avatar/00/10/db/c3/e11adfe8.jpg","nickname":"张迪","note":"","ucode":"6A5D44999A0FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54096,"discussion_content":"例如身份证格式，后端接口也需要检验吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574258591,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":288758,"user_name":"Keith","can_delete":false,"product_type":"c1","uid":1193337,"ip_address":"","ucode":"B40774090714D1","user_header":"https://static001.geekbang.org/account/avatar/00/12/35/79/21647da2.jpg","comment_is_top":false,"comment_ctime":1618655890,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23093492370","product_id":100037301,"comment_content":"DO-PO转换为什么要放在基础层? 这样的话基础层岂不是要理解领域层的逻辑, 进而对上层形成了依赖?","like_count":5},{"had_liked":false,"id":208589,"user_name":"阿信","can_delete":false,"product_type":"c1","uid":1399663,"ip_address":"","ucode":"CC7B15CE63264B","user_header":"https://static001.geekbang.org/account/avatar/00/15/5b/6f/113e24e6.jpg","comment_is_top":false,"comment_ctime":1587387544,"is_pvip":false,"replies":[{"id":"78009","content":"DTO在应用层和用户接口层都是可以的，因为在应用服务调用其他微服务的应用服务的时候，就需要完成在应用层完成DO到DTO的转换。至于DO与DTO的转换在应用层还是接口层，个人感觉两层都可以，根据具体场景选择。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1587438204,"ip_address":"","comment_id":208589,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23062224024","product_id":100037301,"comment_content":"关于数据对象视图定义，这块的想法和老师稍微有点区别<br>我的想法：<br>https:&#47;&#47;www.processon.com&#47;view&#47;link&#47;5e85bc85e4b0412013f87eb6<br>应用层对外是DTO，DO层不暴露到Facade层。<br>","like_count":5,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492527,"discussion_content":"DTO在应用层和用户接口层都是可以的，因为在应用服务调用其他微服务的应用服务的时候，就需要完成在应用层完成DO到DTO的转换。至于DO与DTO的转换在应用层还是接口层，个人感觉两层都可以，根据具体场景选择。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587438204,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221360,"user_name":"lamthun","can_delete":false,"product_type":"c1","uid":1076769,"ip_address":"","ucode":"6DD51D3986E110","user_header":"https://static001.geekbang.org/account/avatar/00/10/6e/21/149a04f9.jpg","comment_is_top":false,"comment_ctime":1590481487,"is_pvip":false,"replies":[{"id":"81663","content":"一般来说查询类型的操作不具有太多的领域逻辑，所以这类服务一般不放在领域层，领域层主要是基于聚合根ID的简单查询和聚合数据的变更操作。所以在DDD里面出现了读写分离模式，将复杂查询操作单独拿出来。或者你也可以直接在应用服务中实现复杂查询。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1590504357,"ip_address":"","comment_id":221360,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18770350671","product_id":100037301,"comment_content":"老师, 你好, 按照上图中的服务调用与数据组合的思路.<br>看图示领域层只关心repository, 不关心缓存, 缓存还是由业务层进行封装, 是这样吗?<br><br>如果是这样子的话, 在大部分应用系统中, 领域层会不会又变成薄薄的增删查改这样的一层.","like_count":4,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496438,"discussion_content":"一般来说查询类型的操作不具有太多的领域逻辑，所以这类服务一般不放在领域层，领域层主要是基于聚合根ID的简单查询和聚合数据的变更操作。所以在DDD里面出现了读写分离模式，将复杂查询操作单独拿出来。或者你也可以直接在应用服务中实现复杂查询。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590504357,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1116410,"avatar":"https://static001.geekbang.org/account/avatar/00/11/08/fa/91c66193.jpg","nickname":"Tenz","note":"","ucode":"D5D5DC0A8C9D13","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":547965,"discussion_content":"CQRS👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642959516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":496438,"ip_address":""},"score":547965,"extra":""}]}]},{"had_liked":false,"id":163584,"user_name":"okjesse","can_delete":false,"product_type":"c1","uid":1050510,"ip_address":"","ucode":"1CD3B09D5C1F11","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8e/307098e4.jpg","comment_is_top":false,"comment_ctime":1576749322,"is_pvip":false,"replies":[{"id":"62250","content":"repository返回的一般都是DO。<br>复杂查询可以采用CQRS读写分离的模式。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1576762172,"ip_address":"","comment_id":163584,"utype":1}],"discussion_count":3,"race_medal":0,"score":"18756618506","product_id":100037301,"comment_content":"请问应用层需要访问repository层返回一些查询数据时，repository是只能返回DO，还是说也可以返回为DTO呢，谢谢。","like_count":4,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478463,"discussion_content":"repository返回的一般都是DO。\n复杂查询可以采用CQRS读写分离的模式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576762172,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1246639,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIvrwfqAuRkaK8Pl2apHKFZxd5mjnFhROMNcg5qXUT4AxE2ZTTia5Hg6pmFM1vozq3vZiagJoaJ4Pyg/132","nickname":"zhangwei","note":"","ucode":"B71CBA5311846F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":398923,"discussion_content":"repository层应该是通过注入的方式被领域层依赖的，如果repository返回DO，岂不是要依赖领域层？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632876791,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1050510,"avatar":"https://static001.geekbang.org/account/avatar/00/10/07/8e/307098e4.jpg","nickname":"okjesse","note":"","ucode":"1CD3B09D5C1F11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":91417,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576832951,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":304021,"user_name":"xxx","can_delete":false,"product_type":"c1","uid":1096652,"ip_address":"","ucode":"E79CEA70430449","user_header":"https://static001.geekbang.org/account/avatar/00/10/bb/cc/fac12364.jpg","comment_is_top":false,"comment_ctime":1627186494,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"14512088382","product_id":100037301,"comment_content":"说说实战下来的感受：严格按照DTO -&gt; DO -&gt; PO，服务再分成 controller -&gt; application -&gt; domain -&gt; repository 确实是职责划分的很清晰，是很好的设计。规定上层只能调用下层，不能跨层调用，确实是很严的规则，也确实能够实现上层只是基于下层在做编排，写起来代码很短很优雅。<br><br>另外，各层的数据对象往往是通过注解来完成其职责的。比如DTO中要加上验证的注解、Json的注解，PO中要加上JPA或者MyBatis的注解。把这些注解都堆到一个对象里，确实是职责不清，逻辑很混乱；并且这些对象或多或少在字段上有些差异（更不要说DO还有业务方法了），放到一个对象中要考虑各种trick才能解决，所以分开是势在必行的。但是对象转来转去也确实是心累……<br><br>不过这么分层，实际是对原来的 controller -&gt; service -&gt; dao 加了一个 domain层，所谓贫血模型到充血模型，本质上就是把service里面的逻辑移到领域对象中。层层这么调下去的话，就要再加一层的模板代码，写起来好累啊……<br><br>因此在实践中，如果当前的逻辑就是CRUD，我会简化一点：应用层就直接调用repository，DTO和PO直接互转，不需要创建DO。当需要DO来处理业务逻辑时，再正经地创建DO。背后的思考如下：在简单CRUD场景中，CRUD它就是业务逻辑（查询往往会有一些花样）！所以在应用层编写一些JPA查询逻辑，也不是特别不能接受。。。<br><br>这么来看，原来的DDD的分层调用图中，可以跨层调用，也是有合理性的。<br>","like_count":3,"discussions":[{"author":{"id":1707838,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/AcJM5WNhE062TQAsIE8KTxTsZMTHJHCm4LCfsjBPibZ6iaGRamfZqIRFcLXLVfAQobeCIgA9o5wiaRCKa0dNbic1iag/132","nickname":"paulmin","note":"","ucode":"6AAB20AB369E90","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400549,"discussion_content":"DDD的核心还是领域建模，实现高内聚低耦合，在简单的业务逻辑上，确实这样区分会额外增加一些编码工作量。有没同学有能实现自动生成DDD模板代码的git分享下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633318136,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223989,"user_name":"珅珅君","can_delete":false,"product_type":"c1","uid":1069646,"ip_address":"","ucode":"3700048634C565","user_header":"https://static001.geekbang.org/account/avatar/00/10/52/4e/5150a2ee.jpg","comment_is_top":false,"comment_ctime":1591251369,"is_pvip":false,"replies":[{"id":"82506","content":"微服务之间的服务调用一般放在应用层通过应用服务来进行服务组合和编排。服务调用的关系图里面有微服务调用微服务外的应用服务的路线的。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1591273802,"ip_address":"","comment_id":223989,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14476153257","product_id":100037301,"comment_content":"如果需要依赖第三方的接口，应该放在哪，领域服务还是应用服务","like_count":3,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497326,"discussion_content":"微服务之间的服务调用一般放在应用层通过应用服务来进行服务组合和编排。服务调用的关系图里面有微服务调用微服务外的应用服务的路线的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591273802,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1152887,"avatar":"https://static001.geekbang.org/account/avatar/00/11/97/77/a01ebefc.jpg","nickname":"Wei_强","note":"","ucode":"B0E40FB6636F9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375617,"discussion_content":"建议第三方依赖的生命放在基础层，我理解第三方接口依赖类似于数据库的依赖，如果放在应用层的话，相当于强依赖对方的模型，一旦对方接口升级，所有用到的地方，应用服务就需要改。因此放在基础层，并且通过依赖倒置来实现","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1621773640,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153591,"user_name":"墨名次","can_delete":false,"product_type":"c1","uid":1330267,"ip_address":"","ucode":"926EDC57291C09","user_header":"https://static001.geekbang.org/account/avatar/00/14/4c/5b/5499d6e6.jpg","comment_is_top":false,"comment_ctime":1574263862,"is_pvip":false,"replies":[{"id":"59039","content":"是的，但是有的时候不一定是一对一的关系。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574299024,"ip_address":"","comment_id":153591,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14459165750","product_id":100037301,"comment_content":"在数据试图这里，如果有用户User，那么在后端代码中是不是会有：<br>com.xxx.xxx.po.User<br>com.xxx.xxx.do.User<br>com.xxx.xxx.dto.User<br>或者为了方便区分则可以：<br>com.xxx.UserPO<br>com.xxx.User<br>com.xxx.UserDTO<br><br>？","like_count":3,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475220,"discussion_content":"是的，但是有的时候不一定是一对一的关系。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574299024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":252506,"user_name":"iMARS","can_delete":false,"product_type":"c1","uid":1113733,"ip_address":"","ucode":"10C5C31908AA09","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/85/9ab352a7.jpg","comment_is_top":false,"comment_ctime":1602322510,"is_pvip":true,"replies":[{"id":"92302","content":"没错。这些操作主要是为了实现各层的解耦，保证领域模型的稳定，能够快速适配前端应用和后端资源逻辑的变化。所以你需要根据具体的业务场景以及性能等要求来平衡是否要做这些对象的转换，其实某些业务需求和逻辑不容易变化的业务场景是可以不做转换的。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1602473970,"ip_address":"","comment_id":252506,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10192257102","product_id":100037301,"comment_content":"看完这一节有一个感觉，如果系统的业务不复杂，或者属于从0到1发展阶段的，DDD的设计方式会拖慢开发的速度，增加系统的复杂度，不适合用DDD的方式。仅仅是VO-DTO-DO-PO之间的转换就存在效能的损耗，并增加了开发工作量。而对于业务复杂，又需要规模化弹性扩展的，需要引入DDD的方式对已有系统采用自下而上的方式进行重构，以便做到业务敏捷。","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506791,"discussion_content":"没错。这些操作主要是为了实现各层的解耦，保证领域模型的稳定，能够快速适配前端应用和后端资源逻辑的变化。所以你需要根据具体的业务场景以及性能等要求来平衡是否要做这些对象的转换，其实某些业务需求和逻辑不容易变化的业务场景是可以不做转换的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602473970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241456,"user_name":"小孩","can_delete":false,"product_type":"c1","uid":1112367,"ip_address":"","ucode":"A7F587FC641E63","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/2f/01b32495.jpg","comment_is_top":false,"comment_ctime":1597300449,"is_pvip":false,"replies":[{"id":"89382","content":"VO主要用于前端展示。如果有多个前端应用的话，我们可以通过DTO去进行前端应用的接口和数据适配。用户接口层的Facade接口和DTO的作用主要如下：<br>在微服务面向不同前端应用时，同样的一段业务逻辑，可能由于渠道不同，而在前端展示的页面要素不同，因此要求后端微服务返回的数据结果会不同。比如在面向内部员工的PC端应用时，可能要求返回某些对象的全部属性的数据。而面向外部客户的移动端应用，可能只需要返回几个关键属性的数据就可以了。<br>为了避免暴露微服务的核心业务逻辑，防止数据外泄，你不能将后端对象的所有属性数据，不加区分的暴露给所有前端应用。你更不能仅仅因为前端应用不同的数据展示需求，而在后端定制开发出多个不同的应用服务或领域服务，面向前端应用提供不同的服务适配。这样容易产生大量重复代码，也容易导致业务逻辑混乱，代码可维护性变差。<br>这时用户接口层的Facade服务和数据组装器Assembler就可以发挥作用了。Facade服务可以封装应用服务，适配不同前端应用的集成技术体系，提供不同类型的服务接口适配，而数据组装器Assembler可以根据不同前端应用的数据需求，完成前端DTO和后端DO对象的组装和转换等操作，按需提供数据适配。我们基本不需要调整领域模型的核心领域逻辑，就可以面向不同前端应用提供灵活的接口定制和数据适配。<br>","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1597633533,"ip_address":"","comment_id":241456,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10187235041","product_id":100037301,"comment_content":"没太看懂这里vo跟dto区别，我的用法一般是前段传vo过来转换成do处理然后po持久化，如果中间需要模型转换一个中间过程会创建dto","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503742,"discussion_content":"VO主要用于前端展示。如果有多个前端应用的话，我们可以通过DTO去进行前端应用的接口和数据适配。用户接口层的Facade接口和DTO的作用主要如下：\n在微服务面向不同前端应用时，同样的一段业务逻辑，可能由于渠道不同，而在前端展示的页面要素不同，因此要求后端微服务返回的数据结果会不同。比如在面向内部员工的PC端应用时，可能要求返回某些对象的全部属性的数据。而面向外部客户的移动端应用，可能只需要返回几个关键属性的数据就可以了。\n为了避免暴露微服务的核心业务逻辑，防止数据外泄，你不能将后端对象的所有属性数据，不加区分的暴露给所有前端应用。你更不能仅仅因为前端应用不同的数据展示需求，而在后端定制开发出多个不同的应用服务或领域服务，面向前端应用提供不同的服务适配。这样容易产生大量重复代码，也容易导致业务逻辑混乱，代码可维护性变差。\n这时用户接口层的Facade服务和数据组装器Assembler就可以发挥作用了。Facade服务可以封装应用服务，适配不同前端应用的集成技术体系，提供不同类型的服务接口适配，而数据组装器Assembler可以根据不同前端应用的数据需求，完成前端DTO和后端DO对象的组装和转换等操作，按需提供数据适配。我们基本不需要调整领域模型的核心领域逻辑，就可以面向不同前端应用提供灵活的接口定制和数据适配。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597633533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1253652,"avatar":"https://static001.geekbang.org/account/avatar/00/13/21/14/423a821f.jpg","nickname":"Steven","note":"","ucode":"3FE64459842015","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545088,"discussion_content":"前端提交访问后端传的是DTO；前端访问后端返回的是DTO，前端转换成VO再用于显示","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641822380,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1965699,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/fe/83/df562574.jpg","nickname":"慎独明强","note":"","ucode":"DC2F7F2C0C8F60","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344887,"discussion_content":"还是不太明白这区别在哪，不同前端应用需要不同的参数，那么我们应该转化为不同的VO对象给前端作为返回值，通过DTO来进行适配。  VO这个对象是定义在前端服务，还是后端服务？因为我公司，返回给前端对象都叫VO","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611621097,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183124,"user_name":"发飙的蜗牛","can_delete":false,"product_type":"c1","uid":1800868,"ip_address":"","ucode":"B2D96A2D0B6BA4","user_header":"https://static001.geekbang.org/account/avatar/00/1b/7a/a4/79ffe77c.jpg","comment_is_top":false,"comment_ctime":1582956773,"is_pvip":false,"replies":[{"id":"70847","content":"仓储服务应该返回的是PO，然后通过工厂将PO转成DO。跨聚合的事务控制放在应用层。理论上领域层不会有事务，如果避免不了，也可以在领域层增加事务，比如在进行业务数据和事件数据同时写入的时候。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1582965524,"ip_address":"","comment_id":183124,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10172891365","product_id":100037301,"comment_content":"老师，仓储服务返回值应该是DO还是PO呢？如果是PO，那么实体方法去调用就要自己去将PO转为DO，如果是DO的话就需要在仓储实现里面转，但是像spring data JPA这些框架，实现我们是不用去管的，我们只需要泛型化将PO传进去就可以了，但是只能返回PO <br>另一个问题想问下，对于DDD封层架构，事务控制应该放到那一层去做呢？如果不是放到一层，应该怎么去设计事务控制？","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485564,"discussion_content":"仓储服务应该返回的是PO，然后通过工厂将PO转成DO。跨聚合的事务控制放在应用层。理论上领域层不会有事务，如果避免不了，也可以在领域层增加事务，比如在进行业务数据和事件数据同时写入的时候。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582965524,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170631,"user_name":"梦终结","can_delete":false,"product_type":"c1","uid":1033924,"ip_address":"","ucode":"237498181A84C0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c6/c4/22191e34.jpg","comment_is_top":false,"comment_ctime":1578646590,"is_pvip":false,"replies":[{"id":"66121","content":"除了增删改查，还有实体的业务行为，具体表现为实体的方法。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1578659136,"ip_address":"","comment_id":170631,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10168581182","product_id":100037301,"comment_content":"老师你好，我想问下：<br>1、DO里面是充血模型是么？<br>2、如果要是充血模型，那对DO的最基础的增删改查都写在DO里面是么？","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481047,"discussion_content":"除了增删改查，还有实体的业务行为，具体表现为实体的方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578659136,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1017257,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/85/a9/6d4d3ae8.jpg","nickname":"绍棠","note":"","ucode":"706CC78D47F1A4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":209135,"discussion_content":"老师您好，如果DO包含了crud等，那它就得注入仓储服务了，这样是不是与领域层的服务重叠呢？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1584613441,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161412,"user_name":"胡杨","can_delete":false,"product_type":"c1","uid":1025786,"ip_address":"","ucode":"B8EE0E3DDFCCB1","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLTX00Cv4JWPAkQ9IVwicRAZYcT9TdCvlapylOy0TZhbm60V3Npr5wS8lfSI7VVyqj6NLVk2kB9QeA/132","comment_is_top":false,"comment_ctime":1576202730,"is_pvip":false,"replies":[{"id":"61533","content":"是的，实体就是DO。<br>PO与DO的互转，Java大部分都需要自己写代码转换。<br>.net倒是有一些框架可以自动去做映射，比如你说的EF。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1576214996,"ip_address":"","comment_id":161412,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10166137322","product_id":100037301,"comment_content":"领域实体是entity，领域对象是do，那Do就是entity么？<br>是的话，那po到do的转换一般是EF等框架自己做的了吧？","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477710,"discussion_content":"是的，实体就是DO。\nPO与DO的互转，Java大部分都需要自己写代码转换。\n.net倒是有一些框架可以自动去做映射，比如你说的EF。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576214996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1169474,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d8/42/d4e7a136.jpg","nickname":"有思想的芦苇","note":"","ucode":"AA0B96363B1587","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":410295,"discussion_content":"EF不是自动映射po和do，它是将数据库映射到po或do，可以认为po=do，对象之间映射是用到automapper或mapster之类框架","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635652517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159876,"user_name":"沐风","can_delete":false,"product_type":"c1","uid":1026863,"ip_address":"","ucode":"E986B28875B5AA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ab/2f/8231f5a4.jpg","comment_is_top":false,"comment_ctime":1575815969,"is_pvip":true,"replies":[{"id":"61073","content":"现在看主要的重复性工作是在对象映射关系的建立。目前似乎还没有好的工具来辅助。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1575860813,"ip_address":"","comment_id":159876,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10165750561","product_id":100037301,"comment_content":"各层之间不断转换object 对象，从实现上看还是显得繁琐，欧老师，有简化的实现或实践么？","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477195,"discussion_content":"现在看主要的重复性工作是在对象映射关系的建立。目前似乎还没有好的工具来辅助。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575860813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1369756,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIopdUJmtgpsr9GibAibcZgS7h23P4FrgBfed3WveI4b4f8Vl2JjibhCzib9Y8Vs2M1PGQr7cwoKADxZQ/132","nickname":"秦道","note":"","ucode":"BE195C09BD14A5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537435,"discussion_content":"mapstruct了解一下😊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639059480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1169474,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d8/42/d4e7a136.jpg","nickname":"有思想的芦苇","note":"","ucode":"AA0B96363B1587","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":410296,"discussion_content":".net有各种自动映射工具可用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635652574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153953,"user_name":"xj_zh","can_delete":false,"product_type":"c1","uid":1214755,"ip_address":"","ucode":"190609F7AE67CC","user_header":"https://static001.geekbang.org/account/avatar/00/12/89/23/73569bd7.jpg","comment_is_top":false,"comment_ctime":1574336821,"is_pvip":false,"replies":[{"id":"59223","content":"先说一下贫血模型吧，贫血模型是指使用的领域对象中只有自己的属性以及setter和getter方法，业务逻辑都不包含在领域对象中而是放在业务逻辑层。<br>而充血模型则是将实体相关的业务逻辑都放在实体的方法中实现，实体包含了自身的属性和业务行为，它在领域模型中就是一个具有业务行为和逻辑的实体。充血模型的实体更能体现领域模型的对象行为。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574404852,"ip_address":"","comment_id":153953,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10164271413","product_id":100037301,"comment_content":"欧老师，时间允许，麻烦讲一下充血模型。","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475335,"discussion_content":"先说一下贫血模型吧，贫血模型是指使用的领域对象中只有自己的属性以及setter和getter方法，业务逻辑都不包含在领域对象中而是放在业务逻辑层。\n而充血模型则是将实体相关的业务逻辑都放在实体的方法中实现，实体包含了自身的属性和业务行为，它在领域模型中就是一个具有业务行为和逻辑的实体。充血模型的实体更能体现领域模型的对象行为。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574404852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1214755,"avatar":"https://static001.geekbang.org/account/avatar/00/12/89/23/73569bd7.jpg","nickname":"xj_zh","note":"","ucode":"190609F7AE67CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56033,"discussion_content":"谢谢欧老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574425863,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153442,"user_name":"。","can_delete":false,"product_type":"c1","uid":1222200,"ip_address":"","ucode":"75B163F01F20F3","user_header":"https://static001.geekbang.org/account/avatar/00/12/a6/38/55483b8c.jpg","comment_is_top":false,"comment_ctime":1574236386,"is_pvip":false,"replies":[{"id":"59042","content":"我们前端用JWT实现单点登录。后端微服务的服务调用通过API鉴权来控制。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574299521,"ip_address":"","comment_id":153442,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10164170978","product_id":100037301,"comment_content":"欧老师，微服务之后，前后端分离。前端和后端的登陆认证用什么来做呢？基于token的方式，“退出登录”是假的退出吧？是不是只在前端应用删除了保存的key，对于后端应用，这个key还是生效的","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475167,"discussion_content":"我们前端用JWT实现单点登录。后端微服务的服务调用通过API鉴权来控制。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574299521,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1744195,"avatar":"","nickname":"summer","note":"","ucode":"A568BC55C8FB89","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54054,"discussion_content":"后端提供退出接口，把token主动设置失效","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574255460,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1560281,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ce/d9/e3fc735c.jpg","nickname":"leo","note":"","ucode":"AAF0F90D8A2481","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1744195,"avatar":"","nickname":"summer","note":"","ucode":"A568BC55C8FB89","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":221281,"discussion_content":"你好，token主动失效如何实现呢？\ntoken虽然可以设置有效期，但在有效期之前一直都是生效的。是通过白名单或黑名单失效的？那这部分数据需要持久化吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585998277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":54054,"ip_address":""},"score":221281,"extra":""}]}]},{"had_liked":false,"id":153292,"user_name":"William.加","can_delete":false,"product_type":"c1","uid":1211450,"ip_address":"","ucode":"300FFC09DEE243","user_header":"https://static001.geekbang.org/account/avatar/00/12/7c/3a/5140a8b9.jpg","comment_is_top":false,"comment_ctime":1574211789,"is_pvip":false,"replies":[{"id":"58862","content":"根据你的业务来取舍吧，如果数据不一致没关系，或者数据不重要，部分数据丢了也可以，就可以不用。<br>如果是核心业务数据或者涉及到钱的业务数据，分布式事务就必不可少了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574212742,"ip_address":"","comment_id":153292,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10164146381","product_id":100037301,"comment_content":"老师，微服务之间分布式事务，是有修改就用，还是应该根据具体业务做取舍？","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475110,"discussion_content":"根据你的业务来取舍吧，如果数据不一致没关系，或者数据不重要，部分数据丢了也可以，就可以不用。\n如果是核心业务数据或者涉及到钱的业务数据，分布式事务就必不可少了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574212742,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153254,"user_name":"密码123456","can_delete":false,"product_type":"c1","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1574208529,"is_pvip":false,"replies":[{"id":"58859","content":"是的。除非带来业务逻辑变化了，才去做变更。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574211209,"ip_address":"","comment_id":153254,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10164143121","product_id":100037301,"comment_content":"设计不同的对象，能够保证。当基于下层业务变化时。只需要更改，对象的转化即可。不需要对业务逻辑进行变更。对吗？","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475096,"discussion_content":"是的。除非带来业务逻辑变化了，才去做变更。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574211209,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":270762,"user_name":"平平淡淡财是真","can_delete":false,"product_type":"c1","uid":2033476,"ip_address":"","ucode":"BC23C8A194DDA3","user_header":"https://static001.geekbang.org/account/avatar/00/1f/07/44/1df0e4cd.jpg","comment_is_top":false,"comment_ctime":1609243043,"is_pvip":false,"replies":[{"id":"98288","content":"1、你说的这个问题确实存在，如果各层之间的模型差异不大，是可以不做转换的。转换的主要目的是通过对象之间的转换，保持各层模型的稳定和独立。<br>2、为了保证各个领域模型的独立性，避免不同聚合之间的耦合，建议尽量避免聚合之间的服务、实体和数据之间产生耦合。这是因为如果耦合度高的聚合需要在不同微服务之间进行重组，聚合之间的解耦需要花费很多的时间和代码重构的工作。聚合之间的访问一般有两种方法：采用事件总线的最终一致性模式和在应用层增加事务的模式。两种方法都有不足，事件总线的方式会增加开发的复杂度，事务的方式会产生性能损失。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1609383143,"ip_address":"","comment_id":270762,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5904210339","product_id":100037301,"comment_content":"欧老师你好，有两个问题需要您帮忙解答一下：<br>1.每一层都有自己的持有对象，VO、DTO、DO、PO，这么多对象在进行操作时，需要各种转换，对开发耗时和运行效率都有很大的影响，特别是 DO到PO之间的互转；<br>2.在同一个微服务内，领域层之间的调用必须放在应用层来处理，这样就会经常涉及到事务问题（在不使用事件异步处理的情况下，甚至要使用分布式事务），如果在应用层开启事务，那么事务内要处理的业务逻辑较复杂时，对数据库的压力就比较大，这样还适合交易量较大的互联网项目吗？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512742,"discussion_content":"1、你说的这个问题确实存在，如果各层之间的模型差异不大，是可以不做转换的。转换的主要目的是通过对象之间的转换，保持各层模型的稳定和独立。\n2、为了保证各个领域模型的独立性，避免不同聚合之间的耦合，建议尽量避免聚合之间的服务、实体和数据之间产生耦合。这是因为如果耦合度高的聚合需要在不同微服务之间进行重组，聚合之间的解耦需要花费很多的时间和代码重构的工作。聚合之间的访问一般有两种方法：采用事件总线的最终一致性模式和在应用层增加事务的模式。两种方法都有不足，事件总线的方式会增加开发的复杂度，事务的方式会产生性能损失。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609383143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159447,"user_name":"周桃春","can_delete":false,"product_type":"c1","uid":1235433,"ip_address":"","ucode":"57937C6C01D9FB","user_header":"https://static001.geekbang.org/account/avatar/00/12/d9/e9/9a428aa5.jpg","comment_is_top":false,"comment_ctime":1575625575,"is_pvip":false,"replies":[{"id":"60946","content":"每层都有不同的对象的，不建议都用DO对象，正如你说的，这样耦合太高了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1575628578,"ip_address":"","comment_id":159447,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5870592871","product_id":100037301,"comment_content":"欧老师，那是不是意味着，接口层、应用层、领域层都用同一个DO，这样存在着一个问题，各层都耦合着领域层的DO对象。","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477064,"discussion_content":"每层都有不同的对象的，不建议都用DO对象，正如你说的，这样耦合太高了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575628578,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79978,"discussion_content":"这里的DO不是阿里的DO，这里的DO是domain object。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576131992,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1235433,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d9/e9/9a428aa5.jpg","nickname":"周桃春","note":"","ucode":"57937C6C01D9FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74917,"discussion_content":"在阿里的代码规范中，数据库对象对应的是DO（dataobject）,老师这边定义的是po，请问老师每层的这些对象该怎么命名？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575705980,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154005,"user_name":"美美","can_delete":false,"product_type":"c1","uid":1148422,"ip_address":"","ucode":"44CC95C45AF345","user_header":"https://static001.geekbang.org/account/avatar/00/11/86/06/72b01bb7.jpg","comment_is_top":false,"comment_ctime":1574345988,"is_pvip":false,"replies":[{"id":"59180","content":"在应用层一个聚合的应用服务你可以放在一个类里面，拆分的时候直接跟领域层聚合代码一起拿走就可以了。<br>如果应用服务的服务组合跨了多个聚合，这个拆分就相对复杂一些。你需要将原来的微服务内的应用服务，从基于DO的数据调用，转换为基于DTO的跨微服务的调用。代码改动量应该也不算太大。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574391529,"ip_address":"","comment_id":154005,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5869313284","product_id":100037301,"comment_content":"请教一下，后续架构演进过程中，领域层理解是比较好拆分的，但是应用层的逻辑理解是不太好拆分的，因为涉及了多个聚合","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475349,"discussion_content":"在应用层一个聚合的应用服务你可以放在一个类里面，拆分的时候直接跟领域层聚合代码一起拿走就可以了。\n如果应用服务的服务组合跨了多个聚合，这个拆分就相对复杂一些。你需要将原来的微服务内的应用服务，从基于DO的数据调用，转换为基于DTO的跨微服务的调用。代码改动量应该也不算太大。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574391529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153525,"user_name":"张迪","can_delete":false,"product_type":"c1","uid":1104835,"ip_address":"","ucode":"6A5D44999A0FEA","user_header":"https://static001.geekbang.org/account/avatar/00/10/db/c3/e11adfe8.jpg","comment_is_top":false,"comment_ctime":1574253349,"is_pvip":false,"replies":[{"id":"58997","content":"为了解耦，尽量不要设计成一个。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574258021,"ip_address":"","comment_id":153525,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5869220645","product_id":100037301,"comment_content":"DO 和 PO 不能设计成一个吗？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475199,"discussion_content":"为了解耦，尽量不要设计成一个。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574258021,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153523,"user_name":"张迪","can_delete":false,"product_type":"c1","uid":1104835,"ip_address":"","ucode":"6A5D44999A0FEA","user_header":"https://static001.geekbang.org/account/avatar/00/10/db/c3/e11adfe8.jpg","comment_is_top":false,"comment_ctime":1574252750,"is_pvip":false,"replies":[{"id":"58998","content":"聚合根的有些多个实体方法就是领域服务。<br>所有的领域服务在一起就是一个领域服务类。<br>其实这个没关系，不用太纠结。 保证实体自己业务逻辑在自己的方法里实现就可以。至于领域服务是聚合根的方法还是在领域服务类里面，影响不大，都可以的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574258304,"ip_address":"","comment_id":153523,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5869220046","product_id":100037301,"comment_content":"还是不明白聚合根和领域服务之前的区别，聚合根和领域服务都是 实现需要多个实体协作的核心领域逻辑","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475198,"discussion_content":"聚合根的有些多个实体方法就是领域服务。\n所有的领域服务在一起就是一个领域服务类。\n其实这个没关系，不用太纠结。 保证实体自己业务逻辑在自己的方法里实现就可以。至于领域服务是聚合根的方法还是在领域服务类里面，影响不大，都可以的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574258304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153467,"user_name":"郭嵩阳","can_delete":false,"product_type":"c1","uid":1080998,"ip_address":"","ucode":"9DC42C7B73F580","user_header":"https://static001.geekbang.org/account/avatar/00/10/7e/a6/188817b6.jpg","comment_is_top":false,"comment_ctime":1574239703,"is_pvip":true,"replies":[{"id":"59040","content":"1、你说的这种情况，这部分应用服务的功能可能可以沉淀到领域层了。应用服务调应用服务肯定是可以调用的。<br>2、你这里业务逻辑和基础服务逻辑混在一起了，可以考虑用仓储服务来实现依赖倒置，将业务逻辑和数据库逻辑解耦。<br>这是一个例子，有Person聚合根，Person仓储接口和仓储实现。<br><br>&#47;**<br> * Person聚合根<br> *&#47;<br>public class Person{<br>  private String id;<br>  private String name;<br>  private int age;   <br>  private boolean gender；<br>}<br><br>&#47;**<br> * Person仓储接口<br> *&#47;<br>public interface  PersonRepositoryInterface {<br>  void save(Person person);  <br>  void delete(String id);  <br> }<br><br>&#47;**<br> *Person仓储实现<br> *&#47;<br>@Repository<br>public class PersonRepositoryImp implements PersonRepositoryInterface {<br>  private PersonMapper mapper;    <br>  public void save( Person person) {<br>      mapper.create(person);<br>  }<br>  public void delete((String  id) {<br>    mapper.delete(id);<br>  }<br> }","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574299424,"ip_address":"","comment_id":153467,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5869206999","product_id":100037301,"comment_content":"1.应用层是否可以调用应用层，也就是同级委托调用，因为在写代码时候，其他同级类可能已经实现了部分业务<br>2.充血模型中调用数据存储一般代码怎样写，一般我们跟数据库操作是mybatis，mybatis的mapper 声明后是单例的 这个代码结构没考虑清楚.例如<br>@Component<br>Order{<br>\tprivate int id;<br>\tprivate int orderNo;<br>\t<br>\t@Autowired<br>\tOrderMapper orderMapper <br>\tint save(Order order){<br>\t\torderMapper.save(order);<br>\t}<br>}<br>也就是Order使用spring容器进行了管理，不知道充血模型是不是这样子。请老师帮忙梳理下","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475177,"discussion_content":"1、你说的这种情况，这部分应用服务的功能可能可以沉淀到领域层了。应用服务调应用服务肯定是可以调用的。\n2、你这里业务逻辑和基础服务逻辑混在一起了，可以考虑用仓储服务来实现依赖倒置，将业务逻辑和数据库逻辑解耦。\n这是一个例子，有Person聚合根，Person仓储接口和仓储实现。\n\n/**\n * Person聚合根\n */\npublic class Person{\n  private String id;\n  private String name;\n  private int age;   \n  private boolean gender；\n}\n\n/**\n * Person仓储接口\n */\npublic interface  PersonRepositoryInterface {\n  void save(Person person);  \n  void delete(String id);  \n }\n\n/**\n *Person仓储实现\n */\n@Repository\npublic class PersonRepositoryImp implements PersonRepositoryInterface {\n  private PersonMapper mapper;    \n  public void save( Person person) {\n      mapper.create(person);\n  }\n  public void delete((String  id) {\n    mapper.delete(id);\n  }\n }","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574299424,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54531,"discussion_content":"我这里面没有写person的方法，只是为了说明仓储哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574302057,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1080998,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7e/a6/188817b6.jpg","nickname":"郭嵩阳","note":"","ucode":"9DC42C7B73F580","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54522,"discussion_content":"Person 其实还是一个贫血模型对吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574301638,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360558,"user_name":"A$APRocky","can_delete":false,"product_type":"c1","uid":1405947,"ip_address":"广东","ucode":"D1B5C2F8B1B67C","user_header":"https://static001.geekbang.org/account/avatar/00/15/73/fb/40164b5d.jpg","comment_is_top":false,"comment_ctime":1666660412,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1666660412","product_id":100037301,"comment_content":"facade应该是把entity转成dto，do的生命周期应该在领域层","like_count":0},{"had_liked":false,"id":359934,"user_name":"赫赫","can_delete":false,"product_type":"c1","uid":1662930,"ip_address":"北京","ucode":"EAEC133D26C39E","user_header":"https://static001.geekbang.org/account/avatar/00/19/5f/d2/4acc8edd.jpg","comment_is_top":false,"comment_ctime":1666075181,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1666075181","product_id":100037301,"comment_content":"老师打扰，我有两个问题：<br>1. 请问领域层之内的服务是可以互相调用的吗？<br>2. 同种实体或者同种聚合，可以同时存在于两个不容的领域层微服务吗？","like_count":0},{"had_liked":false,"id":355540,"user_name":"李志坡","can_delete":false,"product_type":"c1","uid":1445320,"ip_address":"江苏","ucode":"CCABC7E5CC5421","user_header":"https://static001.geekbang.org/account/avatar/00/16/0d/c8/fdfd768b.jpg","comment_is_top":false,"comment_ctime":1661481815,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1661481815","product_id":100037301,"comment_content":"欧老师，前端应用app调用接口的时候，还需要传入一个来自前端的输入参数，这个参数会有特殊的约定定义吗？我们在项目中具体时间中，把这些参数都定义为：xxxParam","like_count":0},{"had_liked":false,"id":354977,"user_name":"H·H","can_delete":false,"product_type":"c1","uid":2108194,"ip_address":"上海","ucode":"113E95BA6B6F51","user_header":"https://static001.geekbang.org/account/avatar/00/20/2b/22/79d183db.jpg","comment_is_top":false,"comment_ctime":1660928155,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1660928155","product_id":100037301,"comment_content":"为啥感觉这集内容有点重复","like_count":0},{"had_liked":false,"id":348811,"user_name":"hzecool","can_delete":false,"product_type":"c1","uid":1670714,"ip_address":"","ucode":"03D764F717852A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJkOBhbBYIlfyo8oibrrJPjz4BJIdR2DPVxfXSOlfcg8icAKRwtibj0W1gJ1C3HT2GLs7zWQjLBdhz3A/132","comment_is_top":false,"comment_ctime":1655428912,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655428912","product_id":100037301,"comment_content":"老师，上面服务调用图中，领域层里的“实体值对象”，应该是“实体和值对象”吧？","like_count":0},{"had_liked":false,"id":338257,"user_name":"无名","can_delete":false,"product_type":"c1","uid":1315541,"ip_address":"","ucode":"346EC4B30294F6","user_header":"https://static001.geekbang.org/account/avatar/00/14/12/d5/38764102.jpg","comment_is_top":false,"comment_ctime":1647396902,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647396902","product_id":100037301,"comment_content":"老师事件总线在哪一层？用什么实现的？","like_count":0},{"had_liked":false,"id":337340,"user_name":"Geek_2e92d2","can_delete":false,"product_type":"c1","uid":1626311,"ip_address":"","ucode":"6419E5FFF1666F","user_header":"","comment_is_top":false,"comment_ctime":1646784186,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646784186","product_id":100037301,"comment_content":"老师好，我想问下什么是仓储，就是把所有数据库的操作封装起来吗，感觉有点像三层架构的数据访问层","like_count":0},{"had_liked":false,"id":335157,"user_name":"怒啄的菜鸡","can_delete":false,"product_type":"c1","uid":1812756,"ip_address":"","ucode":"31948AD15C7A46","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/14/e2533432.jpg","comment_is_top":false,"comment_ctime":1645365061,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645365061","product_id":100037301,"comment_content":"老师好，看了前几篇文章感觉收获不小。但是有一个疑惑，关于微服务间的调用，我看一直在强调调用需要发生在应用服务层。<br>有没有一种可能，领域能力中的某一个关键环节是需要调用其他微服务完成的，会发生领域服务调用其他微服务的场景呢？","like_count":0},{"had_liked":false,"id":335154,"user_name":"小八哥","can_delete":false,"product_type":"c1","uid":2062472,"ip_address":"","ucode":"CE08853995218E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXGKRyFDH2ia15hV4PeRfgibgb1djXGNibmU4LlMUK5hlHkWpqBpwmEXJ0HBZ2nAN0doQiaGROA5GIhg/132","comment_is_top":false,"comment_ctime":1645363395,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645363395","product_id":100037301,"comment_content":"视图这节对很多概念进行了讲解，是重点啦，需要重点关注","like_count":0},{"had_liked":false,"id":329271,"user_name":"楞伽山人","can_delete":false,"product_type":"c1","uid":1142335,"ip_address":"","ucode":"5859C06DAC790D","user_header":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","comment_is_top":false,"comment_ctime":1641264054,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641264054","product_id":100037301,"comment_content":"老师 数据的流入放入在当前层来完成转换以适配下层的要求 数据的流程放在下层来完成来满足上层要求","like_count":0},{"had_liked":false,"id":329260,"user_name":"楞伽山人","can_delete":false,"product_type":"c1","uid":1142335,"ip_address":"","ucode":"5859C06DAC790D","user_header":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","comment_is_top":false,"comment_ctime":1641261104,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641261104","product_id":100037301,"comment_content":"老师 同一个微服务 应用层服务能够调应用层服务吗？ 比如说有些功能在一个应用服务里面调用领域服务组装好了 但是另外一个应用服务也要用到相同的功能时 如果不能调用的话就会重新组装一次 如果不这样的话可能要下沉的领域服务了 ","like_count":0},{"had_liked":false,"id":327245,"user_name":"徐李","can_delete":false,"product_type":"c1","uid":1213325,"ip_address":"","ucode":"41550F6CA1E112","user_header":"https://static001.geekbang.org/account/avatar/00/12/83/8d/03cac826.jpg","comment_is_top":false,"comment_ctime":1640005152,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1640005152","product_id":100037301,"comment_content":"难道所有的对象，都必要经过这些VO ,DTO,DO,PO 的转换吗？如果一个对象的这些实体恰好是一样的能直接复用吗？不然是类数量就爆炸了吗？<br><br>设计不同的服务，是职责明确，各司其职，结构清晰明了。设计不通的数据对象，则是有安全性的考虑，不让数据泄露，需要用到哪些数据就展示哪些数据吧。","like_count":0},{"had_liked":false,"id":312154,"user_name":"Geek_4c7dcc","can_delete":false,"product_type":"c1","uid":1185244,"ip_address":"","ucode":"A147BEACD2F5BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/15/dc/b1c5b50e.jpg","comment_is_top":false,"comment_ctime":1631667776,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631667776","product_id":100037301,"comment_content":"欧老师好，专栏里基础设施层主要是DB仓储，对于第三方服务的封装有没有什么最佳实践，基础层定义接口由应用层还是领域层去组合编排？","like_count":0},{"had_liked":false,"id":311679,"user_name":"王智洋","can_delete":false,"product_type":"c1","uid":1666517,"ip_address":"","ucode":"B38934EA504663","user_header":"https://static001.geekbang.org/account/avatar/00/19/6d/d5/81e72368.jpg","comment_is_top":false,"comment_ctime":1631386099,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631386099","product_id":100037301,"comment_content":"折中一下<br>领域层不允许暴露给接口层<br>应用层可以调用实体方法<br>可以吗？","like_count":0},{"had_liked":false,"id":309646,"user_name":"花生","can_delete":false,"product_type":"c1","uid":1266634,"ip_address":"","ucode":"5397C08BD51DD4","user_header":"https://static001.geekbang.org/account/avatar/00/13/53/ca/44088dd0.jpg","comment_is_top":false,"comment_ctime":1630288690,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630288690","product_id":100037301,"comment_content":"老师，您提到说，应用服务内还可以完成安全认证、权限校验、初步的数据校验和分布式事务控制等功能。这部分功能是否应该在api网关实现","like_count":0},{"had_liked":false,"id":308631,"user_name":"BMX","can_delete":false,"product_type":"c1","uid":1160849,"ip_address":"","ucode":"DB01EAE73B7D24","user_header":"https://static001.geekbang.org/account/avatar/00/11/b6/91/e7df4173.jpg","comment_is_top":false,"comment_ctime":1629710399,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629710399","product_id":100037301,"comment_content":"老师可以举个实际的例子说明实体对象中如何调用仓储接口的，比如接口定义和实现基于Spring Bean来实现，那么实体中如何引用和依赖这些接口？","like_count":0},{"had_liked":false,"id":294118,"user_name":"Wei_强","can_delete":false,"product_type":"c1","uid":1152887,"ip_address":"","ucode":"B0E40FB6636F9D","user_header":"https://static001.geekbang.org/account/avatar/00/11/97/77/a01ebefc.jpg","comment_is_top":false,"comment_ctime":1621773962,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621773962","product_id":100037301,"comment_content":"消息队列的监听是不是放在网关层更好呢。本质上都是在和外部系统之间交互的协议","like_count":0},{"had_liked":false,"id":291043,"user_name":"晴天哥","can_delete":false,"product_type":"c1","uid":1053350,"ip_address":"","ucode":"AD656A539697C0","user_header":"https://static001.geekbang.org/account/avatar/00/10/12/a6/a55960ff.jpg","comment_is_top":false,"comment_ctime":1619961559,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619961559","product_id":100037301,"comment_content":"其实想咨询下作者，DO&#47;VO&#47;PO&#47;DTO的定义具体是放在哪层的，因为没有划分好这几个对象的定义的情况下会导致工程的相互依赖。","like_count":0},{"had_liked":false,"id":289292,"user_name":"Vae、腾少","can_delete":false,"product_type":"c1","uid":1947806,"ip_address":"","ucode":"CE4306FE441A7D","user_header":"https://static001.geekbang.org/account/avatar/00/1d/b8/9e/958ff12c.jpg","comment_is_top":false,"comment_ctime":1618970834,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618970834","product_id":100037301,"comment_content":"事物一般是加在app层。如果在Facade 做 DO与DTO的转换：对于这种情况怎么处理呢： 聚合根里面有一对多，jpa 的fetch 策略是lazy。当 do 传递到 facade 层时，事物结束，去get多的对象，会报错的。","like_count":0},{"had_liked":false,"id":288759,"user_name":"Keith","can_delete":false,"product_type":"c1","uid":1193337,"ip_address":"","ucode":"B40774090714D1","user_header":"https://static001.geekbang.org/account/avatar/00/12/35/79/21647da2.jpg","comment_is_top":false,"comment_ctime":1618656731,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618656731","product_id":100037301,"comment_content":"本质上是每一层都有一个专属对象(Object), 如存储层的PO, 领域层的DO, 前端应用的VO, DTO我觉得就是应用层的对象, 也可以称为AO, 接口层由于只是起到简单的转发作用, 因此可以不专门设置一个对象 ","like_count":0},{"had_liked":false,"id":287696,"user_name":"郭嵩阳","can_delete":false,"product_type":"c1","uid":1080998,"ip_address":"","ucode":"9DC42C7B73F580","user_header":"https://static001.geekbang.org/account/avatar/00/10/7e/a6/188817b6.jpg","comment_is_top":false,"comment_ctime":1618111798,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1618111798","product_id":100037301,"comment_content":"老师想问下，一般我们的领域数据都会有后台管理和服务api两个地方对一个领域的数据操作但是角色场景是不一样的，这种有数据共享的操作，你们是怎样划分服务或者应用的，admin和api是采用共享jar的数据方式，还是有两套操作领域数据的模型，两个项目各引用各的数据模型，还是抽象出一个基础领域服务作为单独的处理","like_count":0},{"had_liked":false,"id":285020,"user_name":"def","can_delete":false,"product_type":"c1","uid":1263977,"ip_address":"","ucode":"39BDBEA0560C13","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/69/c0fcf4e8.jpg","comment_is_top":false,"comment_ctime":1616581170,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616581170","product_id":100037301,"comment_content":"老师你好，请问一下，结合最后一张图，我理解VO是否就是DTO在经过网关之后转化而成的最终写到response entity中的响应数据？","like_count":0},{"had_liked":false,"id":279489,"user_name":"浩","can_delete":false,"product_type":"c1","uid":2372470,"ip_address":"","ucode":"B1A08AE574DA67","user_header":"https://static001.geekbang.org/account/avatar/00/24/33/76/9582bf05.jpg","comment_is_top":false,"comment_ctime":1613803442,"is_pvip":true,"replies":[{"id":"101560","content":"现在微服务架构基本都是前后端分离，不会将前后端逻辑放在一个微服务里面。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1613834336,"ip_address":"","comment_id":279489,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1613803442","product_id":100037301,"comment_content":"我们公司代码是分前台（客户使用）和后台管理，就是很多代码是重复，一些实体类需要在两个端都要写一遍，这样有时候会出先同一实体但是属性不一致的问题。在事件风暴时，是否可以把同一个聚合的前后台写在同一个微服务里面？这样就不会出现一个实体写两遍以上的问题了。不知道这样合不合适？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515754,"discussion_content":"现在微服务架构基本都是前后端分离，不会将前后端逻辑放在一个微服务里面。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613834336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":279163,"user_name":"尼古拉斯·開","can_delete":false,"product_type":"c1","uid":1113266,"ip_address":"","ucode":"AC196408D3A625","user_header":"https://static001.geekbang.org/account/avatar/00/10/fc/b2/7c6c164a.jpg","comment_is_top":false,"comment_ctime":1613641327,"is_pvip":false,"replies":[{"id":"101440","content":"是的，DTO和DO转换可以在应用层也可以在用户接口层完成。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1613654033,"ip_address":"","comment_id":279163,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1613641327","product_id":100037301,"comment_content":"用户接口层知道了DO，就知道了核心业务方法，充血模型和严格分层怎么玩？所以是不是：<br>1. 用户接口层：完成VO和DTO转换<br>2. 应用层：完成DTO和DO转换<br>3. 领域层：无转换，做好DO内原子业务逻辑封装和领域服务封装<br>4. 基础层：完成DO和PO转换","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515643,"discussion_content":"是的，DTO和DO转换可以在应用层也可以在用户接口层完成。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613654033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":275310,"user_name":"尽海","can_delete":false,"product_type":"c1","uid":1401330,"ip_address":"","ucode":"DF6613FB231356","user_header":"https://static001.geekbang.org/account/avatar/00/15/61/f2/bf08bb0a.jpg","comment_is_top":false,"comment_ctime":1611462945,"is_pvip":false,"replies":[{"id":"101046","content":"印象中，分层架构中好像只定义了上层依赖下层，没有归到同层服务的依赖问题。<br>个人感觉可以根据场景灵活考虑，如果存在服务粒度大小的场景，应该也可以依赖，比如应用服务1是外部必须的服务，同时应用服务2需要组合多个服务来对外提供服务，而这时刚好就有应用服务1，所以建议根据自己的场景来设计。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1612853970,"ip_address":"","comment_id":275310,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1611462945","product_id":100037301,"comment_content":"咨询一下，DDD原则上，只能上层依赖下层么？<br>同层可以相互依赖么？比如：应用层接口1依赖应用层接口2，这样做，是不是不利于微服务拆分？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514305,"discussion_content":"印象中，分层架构中好像只定义了上层依赖下层，没有归到同层服务的依赖问题。\n个人感觉可以根据场景灵活考虑，如果存在服务粒度大小的场景，应该也可以依赖，比如应用服务1是外部必须的服务，同时应用服务2需要组合多个服务来对外提供服务，而这时刚好就有应用服务1，所以建议根据自己的场景来设计。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612853970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1142335,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","nickname":"楞伽山人","note":"","ucode":"5859C06DAC790D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":543668,"discussion_content":"老师 你好 也就是说同一个应用层之间的服务是可以相互调用的吧 也就是应该服务之间的编排是可以放在应用服务来做 是这样的吗？ ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641265077,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":514305,"ip_address":""},"score":543668,"extra":""}]}]},{"had_liked":false,"id":264382,"user_name":"Peter Yu","can_delete":false,"product_type":"c1","uid":1077598,"ip_address":"","ucode":"D56786A6E85321","user_header":"https://static001.geekbang.org/account/avatar/00/10/71/5e/5393a76d.jpg","comment_is_top":false,"comment_ctime":1606451981,"is_pvip":true,"replies":[{"id":"96480","content":"如果不需要在微服务各层中进行对象的解耦，你这样做也是可以的。毕竟转换也需要代价。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1606897387,"ip_address":"","comment_id":264382,"utype":1}],"discussion_count":1,"race_medal":4,"score":"1606451981","product_id":100037301,"comment_content":"老师好，如果DTO、DO、PO有大量字段重合，可以一同继承一个基类么，或者干脆吧PO作为基类？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510546,"discussion_content":"如果不需要在微服务各层中进行对象的解耦，你这样做也是可以的。毕竟转换也需要代价。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606897387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263172,"user_name":"Eternal","can_delete":false,"product_type":"c1","uid":1188023,"ip_address":"","ucode":"EA6FE7CC98F740","user_header":"https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg","comment_is_top":false,"comment_ctime":1606032080,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606032080","product_id":100037301,"comment_content":"每一层至做自己关心得事情，层得入参和出参都要单独封装，屏蔽内部得逻辑","like_count":0},{"had_liked":false,"id":262347,"user_name":"abcd","can_delete":false,"product_type":"c1","uid":1027664,"ip_address":"","ucode":"E705C638850A7D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/50/c79cc705.jpg","comment_is_top":false,"comment_ctime":1605696669,"is_pvip":false,"replies":[{"id":"95254","content":"首先不建议将外部服务访问放在domain service。如果涉及到微服务之间的事务，对时效性要求不是特高的业务场景，可以采用领域事件驱动的异步机制。如果要求高，这样就无法避免分布式事务了，这样代价可能会有点高。在不影响业务的情况，尽量采用数据最终一致性方式。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1605756100,"ip_address":"","comment_id":262347,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605696669","product_id":100037301,"comment_content":"老师，您好！我最近在做DDD的实践，在事务控制方面有一些疑惑：您的建议是在应用层控制事务，实际上应用层service方法在流程编排时可能会调用外部的rpc接口，但是在事务中调用rpc应该是要避免的，所以这种情况下，事务控制就要下沉到domain service了。请老师指导一下，谢谢","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509793,"discussion_content":"首先不建议将外部服务访问放在domain service。如果涉及到微服务之间的事务，对时效性要求不是特高的业务场景，可以采用领域事件驱动的异步机制。如果要求高，这样就无法避免分布式事务了，这样代价可能会有点高。在不影响业务的情况，尽量采用数据最终一致性方式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605756100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261971,"user_name":"Sun Fei","can_delete":false,"product_type":"c1","uid":1032631,"ip_address":"","ucode":"092EC0992050BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c1/b7/57f153f6.jpg","comment_is_top":false,"comment_ctime":1605594213,"is_pvip":false,"replies":[{"id":"95256","content":"我们主要关注服务之间跨层的依赖关系。而对于DO对象之间的依赖虽然建议尽量解耦，但是对象的转换也会带来代价，所以这方面并没有严格要求。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1605756463,"ip_address":"","comment_id":261971,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605594213","product_id":100037301,"comment_content":"老师，看了数据转化图，有个疑问。 DO 是定义在领域层里，而图中的Facade层对 DO 有依赖，是不是不符合严格分层架构？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509677,"discussion_content":"我们主要关注服务之间跨层的依赖关系。而对于DO对象之间的依赖虽然建议尽量解耦，但是对象的转换也会带来代价，所以这方面并没有严格要求。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605756463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257192,"user_name":"trier","can_delete":false,"product_type":"c1","uid":1285659,"ip_address":"","ucode":"498137BC5667AD","user_header":"https://static001.geekbang.org/account/avatar/00/13/9e/1b/9cb138f0.jpg","comment_is_top":false,"comment_ctime":1603877243,"is_pvip":false,"replies":[{"id":"93638","content":"A聚合内的实体不可以直接被B聚合领域服务调用的！<br>A和B聚合的领域服务可以在应用层通过应用服务编排和组合。应严格避免聚合之间对象或数据产生依赖和耦合。最佳途径就是上移一层，通过应用服务来组织。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1603895933,"ip_address":"","comment_id":257192,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1603877243","product_id":100037301,"comment_content":"A领域下的实体对象能被B领域的领域服务所调用吗？按照老师的说话好像是可以的，但是如果允许的话是不是代表领域间已经存在耦合关系了？<br><br>是不是应该是A领域下的服务才能调用本领域下的实体对象比较合适？但是如果是这样的话，实际领域划分时常常会出现领域间实体对象交叉的问题。请问老师这该如何界定？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508251,"discussion_content":"A聚合内的实体不可以直接被B聚合领域服务调用的！\nA和B聚合的领域服务可以在应用层通过应用服务编排和组合。应严格避免聚合之间对象或数据产生依赖和耦合。最佳途径就是上移一层，通过应用服务来组织。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603895933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":249478,"user_name":"伊来温","can_delete":false,"product_type":"c1","uid":2044174,"ip_address":"","ucode":"137E3A8258206B","user_header":"https://static001.geekbang.org/account/avatar/00/1f/31/0e/cbcada9b.jpg","comment_is_top":false,"comment_ctime":1600669625,"is_pvip":false,"replies":[{"id":"91630","content":"应用层和领域层都是DO。如果应用层需要调用其他微服务的服务，则DO需要转换成DTO，而从其他微服务返回的DTO数据则需要转换为DO。在应用层和领域层参与领域逻辑的对象应该都是DO。DTO主要完成数据传输和转换，PO只参与基础层的数据存储逻辑。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1600934049,"ip_address":"","comment_id":249478,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1600669625","product_id":100037301,"comment_content":"问一下每一层编排的结果是数据应该怎么定位呢？比如应用层编排组合领域层的结果，是一个新的DTO还是PO呢？这个新的数据结构应该属于哪一层？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505936,"discussion_content":"应用层和领域层都是DO。如果应用层需要调用其他微服务的服务，则DO需要转换成DTO，而从其他微服务返回的DTO数据则需要转换为DO。在应用层和领域层参与领域逻辑的对象应该都是DO。DTO主要完成数据传输和转换，PO只参与基础层的数据存储逻辑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600934049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1142335,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","nickname":"楞伽山人","note":"","ucode":"5859C06DAC790D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":543671,"discussion_content":"老师 他的意思是应用层编排的结果是以DTO还是以DO的结果返回 如果是DO的话就需要在应用层创建一个DO 到用户接口层进行转换 是这样的理解吗 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641265837,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":505936,"ip_address":""},"score":543671,"extra":""}]}]},{"had_liked":false,"id":243939,"user_name":"好孩子","can_delete":false,"product_type":"c1","uid":1422749,"ip_address":"","ucode":"2C647B97141057","user_header":"https://static001.geekbang.org/account/avatar/00/15/b5/9d/88ff91ec.jpg","comment_is_top":false,"comment_ctime":1598334410,"is_pvip":false,"replies":[{"id":"89872","content":"VO是用于前端页面展示的数据对象，DTO是用于前端应用与微服务之间进行数据传输的对象，它可以以JSON串的方式。如果两者格式统一的话，两者直接统一对象成一个对象也可以，如果不一致的话，就需要在前端应用进行DTO到VO的数据转换。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1598407686,"ip_address":"","comment_id":243939,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1598334410","product_id":100037301,"comment_content":"老师你好，用户接口层给前端返回的是dto，也就是说restful接口返回的是dto而不是vo吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504438,"discussion_content":"VO是用于前端页面展示的数据对象，DTO是用于前端应用与微服务之间进行数据传输的对象，它可以以JSON串的方式。如果两者格式统一的话，两者直接统一对象成一个对象也可以，如果不一致的话，就需要在前端应用进行DTO到VO的数据转换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598407686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241274,"user_name":"haijian.yang","can_delete":false,"product_type":"c1","uid":1162081,"ip_address":"","ucode":"E3D13ABA2CA347","user_header":"https://static001.geekbang.org/account/avatar/00/11/bb/61/2c2f5024.jpg","comment_is_top":false,"comment_ctime":1597234066,"is_pvip":false,"replies":[{"id":"89383","content":"1、不同聚合的DO不可以直接引用的，具体原因如下：<br>聚合之间是通过引用聚合根ID的方式，而不是通过直接对象引用的方式。外部聚合的对象放在聚合边界内管理，容易导致聚合的边界不清晰，也会增加聚合之间的耦合度。<br>为什么聚合根之间不采用对象引用的方式呢？<br>其实这样设计也是为了聚合的解耦。当领域模型随着业务需求发生变化，微服务内需要进行聚合拆分时，原来领域模型和微服务内聚合根之间对象引用的方式，就会变成跨微服务的调用，跨微服务后这种对象引用就会失效，在微服务架构演进时就需要比较大的代码调整。<br>采用聚合根ID引用的方式，则可以将聚合根ID作为服务参数，进行跨聚合的领域服务调用。在微服务拆分时，如果聚合被分别拆分到了两个不同的微服务中，这种代码的改动量就会小很多，聚合的边界也会清晰很多。<br>2、应用服务的DO可以定义在应用层。如果调用其他微服务的服务，当然还少不了DTO的定义，它们也可以放在应用层。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1597633814,"ip_address":"","comment_id":241274,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1597234066","product_id":100037301,"comment_content":"欧老师，<br>1. 不同聚合根的 DO 可以相互引用吗？<br>2. 如果在应用服务调用其他微服务的接口，那么这个应用服务的 DO 定义在哪里呢？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503691,"discussion_content":"1、不同聚合的DO不可以直接引用的，具体原因如下：\n聚合之间是通过引用聚合根ID的方式，而不是通过直接对象引用的方式。外部聚合的对象放在聚合边界内管理，容易导致聚合的边界不清晰，也会增加聚合之间的耦合度。\n为什么聚合根之间不采用对象引用的方式呢？\n其实这样设计也是为了聚合的解耦。当领域模型随着业务需求发生变化，微服务内需要进行聚合拆分时，原来领域模型和微服务内聚合根之间对象引用的方式，就会变成跨微服务的调用，跨微服务后这种对象引用就会失效，在微服务架构演进时就需要比较大的代码调整。\n采用聚合根ID引用的方式，则可以将聚合根ID作为服务参数，进行跨聚合的领域服务调用。在微服务拆分时，如果聚合被分别拆分到了两个不同的微服务中，这种代码的改动量就会小很多，聚合的边界也会清晰很多。\n2、应用服务的DO可以定义在应用层。如果调用其他微服务的服务，当然还少不了DTO的定义，它们也可以放在应用层。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597633814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1253652,"avatar":"https://static001.geekbang.org/account/avatar/00/13/21/14/423a821f.jpg","nickname":"Steven","note":"","ucode":"3FE64459842015","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545096,"discussion_content":"晕了，应用层怎么也有DO？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641823309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236822,"user_name":"渔樵耕读","can_delete":false,"product_type":"c1","uid":1042735,"ip_address":"","ucode":"2C4E141C59381F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e9/2f/c5e5b809.jpg","comment_is_top":false,"comment_ctime":1595557747,"is_pvip":false,"replies":[{"id":"87566","content":"是这样的。当前微服务调用的是目标微服务发布在API网关上的服务，然后再到目标微服务的用户接口层。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1595643053,"ip_address":"","comment_id":236822,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1595557747","product_id":100037301,"comment_content":"欧老师，请问应用层如果调用其他微服务的应用层？我理解，当前微服务需要集成其他微服务时，集成工作是放在当前微服务的应用层没错，但当前微服务应用层调用的应该是目标微服务的用户接口层，因为只有用户接口层才对外公开的接口（API），外部程序不应该访问到程序的应用层的。<br>","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502224,"discussion_content":"是这样的。当前微服务调用的是目标微服务发布在API网关上的服务，然后再到目标微服务的用户接口层。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595643053,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220186,"user_name":"金陵一只猪","can_delete":false,"product_type":"c1","uid":1903965,"ip_address":"","ucode":"C1C90B557842B6","user_header":"https://static001.geekbang.org/account/avatar/00/1d/0d/5d/e5010de2.jpg","comment_is_top":false,"comment_ctime":1590198707,"is_pvip":false,"replies":[{"id":"81299","content":"在面向前端应用提供数据时需要将多个do转成一个dto的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1590214477,"ip_address":"","comment_id":220186,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590198707","product_id":100037301,"comment_content":"应用服务 使用领域服务或者领域对象时，需要传递大量的数据，例如有几十个字段，此时是否应该将这些信息组装成一个对象（例如DTO或ParameterObject）？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496073,"discussion_content":"在面向前端应用提供数据时需要将多个do转成一个dto的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590214477,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214164,"user_name":"Beson","can_delete":false,"product_type":"c1","uid":1576655,"ip_address":"","ucode":"F4F1EBE64EBC06","user_header":"https://static001.geekbang.org/account/avatar/00/18/0e/cf/a97a9cd4.jpg","comment_is_top":false,"comment_ctime":1588669513,"is_pvip":false,"replies":[{"id":"79533","content":"不建议你在仓储实现中转换。<br>如果DO和PO之间的转换复杂的话通常会放在工厂里面去实现，而工厂通常都在聚合内部。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1588835657,"ip_address":"","comment_id":214164,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1588669513","product_id":100037301,"comment_content":"欧老师，你好！po转化成do可以在仓储实现的时候转吗，换句话说就是基础设施层可以调用do吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493971,"discussion_content":"不建议你在仓储实现中转换。\n如果DO和PO之间的转换复杂的话通常会放在工厂里面去实现，而工厂通常都在聚合内部。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588835657,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203267,"user_name":"leo","can_delete":false,"product_type":"c1","uid":1560281,"ip_address":"","ucode":"AAF0F90D8A2481","user_header":"https://static001.geekbang.org/account/avatar/00/17/ce/d9/e3fc735c.jpg","comment_is_top":false,"comment_ctime":1586163450,"is_pvip":false,"replies":[{"id":"76062","content":"如果能将DO控制在领域层，那是最好的了。但是要考虑开发的复杂性和性能考虑，不同层之间数据转换也会消耗性能的。将DO控制在领域层不难实现，还需要你整体权衡。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1586223898,"ip_address":"","comment_id":203267,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1586163450","product_id":100037301,"comment_content":"欧老师，你好。<br>示例代码中，从用户接口层开始，将DTO转化为DO，在应用层直接使用DO来进行传递，包括调用领域服务和领域服务返回，从结果来看，领域层的DO已经穿透到用户接口层了。<br><br>这样如果开发人员没有足够的认知，直接使用实体的逻辑，那DO的封装就被破坏了，逻辑又变成了散落在各处。<br><br>所以有没有必要增加BO（Business Data）业务对象，使用贫血模型，只向外传输数据，而DO隔离在领域层内，不对外暴露实现，这样会不会更好一些？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490812,"discussion_content":"如果能将DO控制在领域层，那是最好的了。但是要考虑开发的复杂性和性能考虑，不同层之间数据转换也会消耗性能的。将DO控制在领域层不难实现，还需要你整体权衡。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586223898,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182845,"user_name":"Sonny721","can_delete":false,"product_type":"c1","uid":1104291,"ip_address":"","ucode":"C95DD306BFBE54","user_header":"https://static001.geekbang.org/account/avatar/00/10/d9/a3/2856b5b5.jpg","comment_is_top":false,"comment_ctime":1582874543,"is_pvip":false,"replies":[{"id":"70722","content":"数据对象的组装和初始化在领域层和基础层之间有工厂模式，在应用层和用户接口层之间有assembler。<br>复杂的查询服务按照传统设计方式就可以了，冗余数据的模式也是常用的设计方法。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1582886255,"ip_address":"","comment_id":182845,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1582874543","product_id":100037301,"comment_content":"老师您好。两个问题，1：各个层之间有独立的数据对象，层与层之间进行数据的传输，各对象之间的转换有哪些可选方案？常见思维各通过种GET、SET来转化，想了解一下各个大厂的做法；2：根据DDD领域建模，如果需要跨领域数据表关联取结果，这个怎么办，在应用层调用多个领域服务查询数据进行组合？还是在其中某个领域模型中进行数据冗余？感谢老师解答。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485471,"discussion_content":"数据对象的组装和初始化在领域层和基础层之间有工厂模式，在应用层和用户接口层之间有assembler。\n复杂的查询服务按照传统设计方式就可以了，冗余数据的模式也是常用的设计方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582886255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182410,"user_name":"钱晟龙🐲龍🐉","can_delete":false,"product_type":"c1","uid":1125387,"ip_address":"","ucode":"C602E06A3B6BBD","user_header":"https://static001.geekbang.org/account/avatar/00/11/2c/0b/ad939ef7.jpg","comment_is_top":false,"comment_ctime":1582782104,"is_pvip":false,"replies":[{"id":"70637","content":"是的，主要在应用层控制。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1582800305,"ip_address":"","comment_id":182410,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1582782104","product_id":100037301,"comment_content":"从图中可以看到应用层会去触发一些外部的事件通知，<br>老师，所以照这样理解的话，微服务内部的事务应该在应用层来控制么？ <br>这个问题的目的，是为了保证 应用层 ---&gt; 领域层这里的信息丢失或者断掉之后事件的完整性..","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485329,"discussion_content":"是的，主要在应用层控制。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582800305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169704,"user_name":"杨杰","can_delete":false,"product_type":"c1","uid":1131823,"ip_address":"","ucode":"74817EA9499843","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/2f/b0b0dd74.jpg","comment_is_top":false,"comment_ctime":1578408628,"is_pvip":false,"replies":[{"id":"65866","content":"A和B可以分别返回两个DO，然后将它们组装成你需要的前端展现的DTO就可以了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1578439831,"ip_address":"","comment_id":169704,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1578408628","product_id":100037301,"comment_content":"有这样一种情况：假设一个DTO对象是前端展示需要的，包含20个属性（假设是field1到field2）；后端有两个领域层的接口A和B。A需要更新这个DTO对象的field1到field5，B接口需要更新field3到field8。这种情况需要怎么处理比较好？针对A和B接口分别在内部定义一个对象作为参数，然后和DTO互相转换么？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480680,"discussion_content":"A和B可以分别返回两个DO，然后将它们组装成你需要的前端展现的DTO就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578439831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1142335,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","nickname":"楞伽山人","note":"","ucode":"5859C06DAC790D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":543673,"discussion_content":"可以在应用层组装成一个DO在到用户接口层进行转换么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641266316,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":480680,"ip_address":""},"score":543673,"extra":""}]}]},{"had_liked":false,"id":166697,"user_name":"wmm","can_delete":false,"product_type":"c1","uid":1104540,"ip_address":"","ucode":"318700E8ED3A5D","user_header":"https://static001.geekbang.org/account/avatar/00/10/da/9c/69df2411.jpg","comment_is_top":false,"comment_ctime":1577546705,"is_pvip":false,"replies":[{"id":"64812","content":"建立这么多O主要是为了解耦，如果系统不够复杂，业务和需求不会经常变动，可以根据自己的需要来定。其实用起来也还可以，你可以用工厂模式。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1577662707,"ip_address":"","comment_id":166697,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1577546705","product_id":100037301,"comment_content":"曾经定义过这么多o，结果发现使用起来很不方便，感觉要把自己玩死😂 。最后还是觉得怎么用方便怎么定义，理论要结合实际。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479594,"discussion_content":"建立这么多O主要是为了解耦，如果系统不够复杂，业务和需求不会经常变动，可以根据自己的需要来定。其实用起来也还可以，你可以用工厂模式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577662707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161557,"user_name":"电商小能手","can_delete":false,"product_type":"c1","uid":1781338,"ip_address":"","ucode":"FCBBF7463F7B97","user_header":"https://static001.geekbang.org/account/avatar/00/1b/2e/5a/b9e5d2ec.jpg","comment_is_top":false,"comment_ctime":1576230702,"is_pvip":false,"replies":[{"id":"61544","content":"是的，但是一般聚合根用的少，很多情况聚合根要作为对象传到基础层。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1576239671,"ip_address":"","comment_id":161557,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1576230702","product_id":100037301,"comment_content":"老师，“领域服务和应用服务都可以调用仓储服务接口，通过仓储服务实现数据持久化。” 聚合根里也可以调用仓储服务接口吧？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477762,"discussion_content":"是的，但是一般聚合根用的少，很多情况聚合根要作为对象传到基础层。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576239671,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160908,"user_name":"OTM","can_delete":false,"product_type":"c1","uid":1074017,"ip_address":"","ucode":"D96E9A661F122B","user_header":"https://static001.geekbang.org/account/avatar/00/10/63/61/d259f7a9.jpg","comment_is_top":false,"comment_ctime":1576058999,"is_pvip":false,"replies":[{"id":"61388","content":"都可以的，在应用层更统一。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1576107982,"ip_address":"","comment_id":160908,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1576058999","product_id":100037301,"comment_content":"用户接口层对客户端提供接口访问，应用层提供服务之间的访问，建议dto统一在应用层进行检验；而且应用层的服务也需要注册成rpc或者restful的，同时访问路径与访问权限不一样","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477527,"discussion_content":"都可以的，在应用层更统一。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576107982,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160890,"user_name":"Geek_aa8017","can_delete":false,"product_type":"c1","uid":1748911,"ip_address":"","ucode":"286195887103C2","user_header":"","comment_is_top":false,"comment_ctime":1576054843,"is_pvip":false,"replies":[{"id":"61386","content":"PO只在基础设施层。它与应用层和领域层的DO互转。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1576107890,"ip_address":"","comment_id":160890,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1576054843","product_id":100037301,"comment_content":"应用层和服务层都有各自的po？对照着老师的结合自己的项目来做一遍发现有好多问题都不知道怎么下手啊","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477519,"discussion_content":"PO只在基础设施层。它与应用层和领域层的DO互转。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576107890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1748911,"avatar":"","nickname":"Geek_aa8017","note":"","ucode":"286195887103C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79968,"discussion_content":"打错字了，应该是do，不是po","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576130164,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160161,"user_name":"番茄炒西红柿","can_delete":false,"product_type":"c1","uid":1690242,"ip_address":"","ucode":"13F47BABAB2110","user_header":"https://static001.geekbang.org/account/avatar/00/19/ca/82/85f6a1a2.jpg","comment_is_top":false,"comment_ctime":1575882742,"is_pvip":false,"replies":[{"id":"61110","content":"仓储接口可以被领域服务和应用服务调用，在仓储接口中传入实体ID或者实体对象都可以。<br>public class OrderService {<br>private OrderRepository orderRepository;<br>public Order updateOrder(order) {<br>***；<br>orderRepository.save(order);<br>***；<br>}<br>}","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1575886452,"ip_address":"","comment_id":160161,"utype":1}],"discussion_count":5,"race_medal":0,"score":"1575882742","product_id":100037301,"comment_content":"想问一下领域层，实体想要调用仓储接口的时候，参数接口的注入放在实体中吗，还是放在领域服务里面","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477276,"discussion_content":"仓储接口可以被领域服务和应用服务调用，在仓储接口中传入实体ID或者实体对象都可以。\npublic class OrderService {\nprivate OrderRepository orderRepository;\npublic Order updateOrder(order) {\n***；\norderRepository.save(order);\n***；\n}\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575886452,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1690242,"avatar":"https://static001.geekbang.org/account/avatar/00/19/ca/82/85f6a1a2.jpg","nickname":"番茄炒西红柿","note":"","ucode":"13F47BABAB2110","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77094,"discussion_content":"还有假如一个聚合根a生成的逻辑同时也会生成实体b，那么是否要把生成b的逻辑写在a的实体里面，还是通过领域服务聚合。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575888510,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1721221,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/43/85/a529c1ff.jpg","nickname":"Aries","note":"","ucode":"1F5E4CCFA5F38E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1690242,"avatar":"https://static001.geekbang.org/account/avatar/00/19/ca/82/85f6a1a2.jpg","nickname":"番茄炒西红柿","note":"","ucode":"13F47BABAB2110","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78054,"discussion_content":"不需要，b中有逻辑，为什么要在a中重复写，ab不是一个领域的对象？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575972118,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":77094,"ip_address":""},"score":78054,"extra":""}]},{"author":{"id":1690242,"avatar":"https://static001.geekbang.org/account/avatar/00/19/ca/82/85f6a1a2.jpg","nickname":"番茄炒西红柿","note":"","ucode":"13F47BABAB2110","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77086,"discussion_content":"那这样假如实体里面有必要的逻辑调用仓储接口（比如说验证唯一性），那是不是先在领域服务注入仓储接口，然后实体必须调用仓储接口的方法，仓储接口作为该方法的参数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575887959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1721221,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/43/85/a529c1ff.jpg","nickname":"Aries","note":"","ucode":"1F5E4CCFA5F38E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1690242,"avatar":"https://static001.geekbang.org/account/avatar/00/19/ca/82/85f6a1a2.jpg","nickname":"番茄炒西红柿","note":"","ucode":"13F47BABAB2110","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78052,"discussion_content":"这类操作在领域服务中提供接口进行验证，不要在实体对象里面注入仓储。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575972030,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":77086,"ip_address":""},"score":78052,"extra":""}]}]},{"had_liked":false,"id":159101,"user_name":"Geek_aa8017","can_delete":false,"product_type":"c1","uid":1748911,"ip_address":"","ucode":"286195887103C2","user_header":"","comment_is_top":false,"comment_ctime":1575538209,"is_pvip":false,"replies":[{"id":"60866","content":"是的。DO在领域层和应用层都有。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1575547397,"ip_address":"","comment_id":159101,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1575538209","product_id":100037301,"comment_content":"do放在领域层，po放在基础层吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476948,"discussion_content":"是的。DO在领域层和应用层都有。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575547397,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158885,"user_name":"冷たい風","can_delete":false,"product_type":"c1","uid":1218363,"ip_address":"","ucode":"4D73962B51DD2F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJGKX8kPDkrL7oPeBAv4WpqOmEg3KtsLs1vmundm9huEXMuIP3Ql0DZ0c2ZXMr0tVSiaQ7gV2T5GXA/132","comment_is_top":false,"comment_ctime":1575470241,"is_pvip":false,"replies":[{"id":"60808","content":"如果数据是跟聚合实体相关的数据库复杂查询，你可以放在聚合的目录下。如果跟聚合无关，只是对缓存文件等的数据查询，放基础层是可以的。<br>我把仓储放在聚合目录下，主要是考虑以后聚合的代码重组方便。<br>你说的领域对象是不是聚合？不知道理解的对不对？","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1575501245,"ip_address":"","comment_id":158885,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1575470241","product_id":100037301,"comment_content":"《再问一次》老师请问一个问题呢：<br>应用层可以直接调用不涉及领域对象的仓储服务，那这种仓储服务应该放在哪个领域对象下面呢？<br>我的问题是这种仓储服务应该放在哪个领域下面？（而不是之前老师回答的问题）","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476882,"discussion_content":"如果数据是跟聚合实体相关的数据库复杂查询，你可以放在聚合的目录下。如果跟聚合无关，只是对缓存文件等的数据查询，放基础层是可以的。\n我把仓储放在聚合目录下，主要是考虑以后聚合的代码重组方便。\n你说的领域对象是不是聚合？不知道理解的对不对？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575501245,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158731,"user_name":"冷たい風","can_delete":false,"product_type":"c1","uid":1218363,"ip_address":"","ucode":"4D73962B51DD2F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJGKX8kPDkrL7oPeBAv4WpqOmEg3KtsLs1vmundm9huEXMuIP3Ql0DZ0c2ZXMr0tVSiaQ7gV2T5GXA/132","comment_is_top":false,"comment_ctime":1575443202,"is_pvip":false,"replies":[{"id":"60768","content":"应用层直接调仓储一般是缓存或其它数据组件，或者大批量的数据库查询服务。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1575465688,"ip_address":"","comment_id":158731,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1575443202","product_id":100037301,"comment_content":"老师请问一个问题呢：<br>应用层可以直接调用不涉及领域对象的仓储服务，那这种仓储服务应该放在哪个领域对象下面呢？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476832,"discussion_content":"应用层直接调仓储一般是缓存或其它数据组件，或者大批量的数据库查询服务。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575465688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1218363,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJGKX8kPDkrL7oPeBAv4WpqOmEg3KtsLs1vmundm9huEXMuIP3Ql0DZ0c2ZXMr0tVSiaQ7gV2T5GXA/132","nickname":"冷たい風","note":"","ucode":"4D73962B51DD2F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72098,"discussion_content":"我的问题是放在哪里？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575470090,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156009,"user_name":"鲲哥","can_delete":false,"product_type":"c1","uid":1230812,"ip_address":"","ucode":"D9582DF7806900","user_header":"https://static001.geekbang.org/account/avatar/00/12/c7/dc/1268c9f9.jpg","comment_is_top":false,"comment_ctime":1574812149,"is_pvip":false,"replies":[{"id":"60006","content":"同一个聚合内的实体一般都是通过聚合根或者实体之间的引用来调用。<br>这几个模型没说同级能不能调，但我个人觉得从代码实现来看，同层调用应该也是可以的。但是要尽量将同层可复用的逻辑往下层去沉淀，然后再提供给上层。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574845102,"ip_address":"","comment_id":156009,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574812149","product_id":100037301,"comment_content":"欧老师你好<br>文中你主要讲了跨层的调用，那同级的服务能互相调用吗？比如，领域内或领域间的实体能互相调用吗？领域服务能否互相调用？还是说遇到同级调用调用的，都向上层提取，由上层服务进行编排?","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475955,"discussion_content":"同一个聚合内的实体一般都是通过聚合根或者实体之间的引用来调用。\n这几个模型没说同级能不能调，但我个人觉得从代码实现来看，同层调用应该也是可以的。但是要尽量将同层可复用的逻辑往下层去沉淀，然后再提供给上层。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574845102,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154507,"user_name":"FIGNT","can_delete":false,"product_type":"c1","uid":1540988,"ip_address":"","ucode":"D9DB185AE9E67C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKZ16iaIia0029oI1Qh5NicibpbTiaBAaCOPYXoLplKHr6uQ2rSVxPZanBvpMcL2NuhwKQYCFnaHP5tedQ/132","comment_is_top":false,"comment_ctime":1574470089,"is_pvip":false,"replies":[{"id":"59318","content":"1，可以的，松散分层架构就是这样的。严格分层架构需要封装后给应用层。<br>2，实体方法需要通过聚合根来调用。<br>3，是的。<br>4，你可以将小聚合实体设计为大聚合实体的值对象。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574496332,"ip_address":"","comment_id":154507,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574470089","product_id":100037301,"comment_content":"1.应用层可以直接调用领域聚合的方法吗，还是说要通过领域服务去调用？<br>2.实体的方法一定要聚合封装一下吗？能不能先取出实体再调用方法呢？<br>3.多个聚合之间访问只能在应用层调用通过聚合id访问？<br>4. 一个聚合一个仓储，聚合之间有相同的内容怎么处理？比如一个大聚合做主流程业务，包含了大部分的实体，小聚合只是维护性的增删改，小聚合完成增删改之后，大聚合需要同步数据吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475489,"discussion_content":"1，可以的，松散分层架构就是这样的。严格分层架构需要封装后给应用层。\n2，实体方法需要通过聚合根来调用。\n3，是的。\n4，你可以将小聚合实体设计为大聚合实体的值对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574496332,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154467,"user_name":"二两豆腐","can_delete":false,"product_type":"c1","uid":1178313,"ip_address":"","ucode":"24E16A3C2AD28C","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/c9/c75664e9.jpg","comment_is_top":false,"comment_ctime":1574436585,"is_pvip":false,"replies":[{"id":"59300","content":"你说的没错。复杂查询选择自己最熟悉和方便的技术即可。聚合根根据ID查询可以在仓储实现。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574473875,"ip_address":"","comment_id":154467,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1574436585","product_id":100037301,"comment_content":"DDD 本身是查无关性的，只关注于写。针对查询的花可以采用QCRS的方式进行查询。老师的讲解中，查询也在仓储中实现，仓储中的查询返回的PO，然后会被转化为DO。在很多应用场景中，前端的查询中是多样化的，也许很多字段并没有在DO中。请问老师这种情况应该怎么处理","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475479,"discussion_content":"你说的没错。复杂查询选择自己最熟悉和方便的技术即可。聚合根根据ID查询可以在仓储实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574473875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1275494,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/66/cbd6013c.jpg","nickname":"Lambor","note":"","ucode":"0E3C3C39A22495","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293839,"discussion_content":"我也很想知道这个问题，老是能否详细说一下你们在DDD中的做法。毕竟我们所熟悉的技术都不是采用DDD架构模式。不同的接口查询条件不一，返回的数据可能也不一样，就算是在领域服务中，有些时候查询数据也是条件不一样的，而SQL大多是条件不一样，结构一致，总不能每个查询单独写个SQL吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595685602,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154455,"user_name":"你的美","can_delete":false,"product_type":"c1","uid":1529298,"ip_address":"","ucode":"71B97BDBA3CDC3","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/iacfiaRC2Vze9eEaVibAFkngm4nmA0DwoibC3kHj6pCOQ87VDa955kK3kavnrDnibmfeIFd4G6Ab2fDkNrbUapL8ibAQ/132","comment_is_top":false,"comment_ctime":1574434296,"is_pvip":false,"replies":[{"id":"59321","content":"聚合的领域层通过仓储接口来调用基础层的仓储实现。将DO转为PO，然后基础层将PO持久化到数据库。<br>你所说的微服务是不是我前面讲的类似小单体微服务？它也是可以采用仓储的方式的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574497246,"ip_address":"","comment_id":154455,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574434296","product_id":100037301,"comment_content":"没问明白，就是一个聚合对应一个仓储，问：聚合对应的仓储在领域层只是接口吗，实质的存储地还是在基础层是这样吗？<br>还有我们一个微服务也要对应一个仓储，同样的问题：微服务在领域层只是一个接口吗，实质存储地也是在基础层？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475475,"discussion_content":"聚合的领域层通过仓储接口来调用基础层的仓储实现。将DO转为PO，然后基础层将PO持久化到数据库。\n你所说的微服务是不是我前面讲的类似小单体微服务？它也是可以采用仓储的方式的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574497246,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154006,"user_name":"川杰","can_delete":false,"product_type":"c1","uid":1099750,"ip_address":"","ucode":"815211E1D698E6","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/e6/11f21cb4.jpg","comment_is_top":false,"comment_ctime":1574346064,"is_pvip":false,"replies":[{"id":"59185","content":"在领域服务或者应用服务中完成业务逻辑处理后。构建领域事件实体，直接调用事件发布的服务就可以了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574392378,"ip_address":"","comment_id":154006,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574346064","product_id":100037301,"comment_content":"请教一个问题，领域服务和领域事件的关系；<br>我理解领域服务说白了就是包裹处理某个业务模块的方法的类，领域事件也是用来处理业务的（主要是针对业务流程的关键节点）；<br>以用户举例：领域服务可以包括，对于用户实体的，增删改查方法；领域事件可以用来维护（用户新增完成事件、用户积分增加事件等）；<br>那么二者应该如何编排？是把领域事件也做一层封装到领域服务里么？<br>假设应用层要去订阅 用户注册完成事件，是否是调用 领域服务的 RegisterUserAddedEvent方法来订阅么？还是应用层直接调用事件的注册方法绕过领域服务？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475350,"discussion_content":"在领域服务或者应用服务中完成业务逻辑处理后。构建领域事件实体，直接调用事件发布的服务就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574392378,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153848,"user_name":"杨杰","can_delete":false,"product_type":"c1","uid":1131823,"ip_address":"","ucode":"74817EA9499843","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/2f/b0b0dd74.jpg","comment_is_top":false,"comment_ctime":1574317669,"is_pvip":false,"replies":[{"id":"59130","content":"其实放哪里都没关系的。你可以在一个聚合里单独建一个领域服务类，里面实现所有的领域服务，也可以直接在聚合根里用方法实现，毕竟聚合根可以引用所有的实体，对实体进行生命周期管理。<br>我建议你单独建立一个领域服务类，里面实现所有的领域服务，聚合根类只实现自己相关的业务逻辑。这样就相对清晰了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574323824,"ip_address":"","comment_id":153848,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1574317669","product_id":100037301,"comment_content":"在第15章的例子里面讲逻辑边界的时候，有一张图有leave和person两个代码目录，表示两个逻辑边界。对于这个一直有疑问：这个逻辑边界（如图里面的leave和person）和聚合根是一对一还是一对多的关系？如果是一对一的关系，那么领域服务本身和聚合根封装的方法是不是有点儿重复了？<br>","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475295,"discussion_content":"其实放哪里都没关系的。你可以在一个聚合里单独建一个领域服务类，里面实现所有的领域服务，也可以直接在聚合根里用方法实现，毕竟聚合根可以引用所有的实体，对实体进行生命周期管理。\n我建议你单独建立一个领域服务类，里面实现所有的领域服务，聚合根类只实现自己相关的业务逻辑。这样就相对清晰了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574323824,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55034,"discussion_content":"领域服务不要跨聚合哦，这样聚合之间耦合就高了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574334122,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1131823,"avatar":"https://static001.geekbang.org/account/avatar/00/11/45/2f/b0b0dd74.jpg","nickname":"杨杰","note":"","ucode":"74817EA9499843","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55011,"discussion_content":"我个人也比较倾向于领域服务分出来，一个领域服务可能会跨越多个聚合。但是呢，这样在理论上又引出了另外一个问题，在对某个微服务进行再次拆分的时候，领域服务又变成不好拆分了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574332081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153688,"user_name":"宝宝太喜欢极客时间了","can_delete":false,"product_type":"c1","uid":1215152,"ip_address":"","ucode":"9CDB679C257612","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoOGZ6lbHiboIZMN9USbeutnmCWBahVLtSlKlIENKvrZQCUQzpzeZQOxTntIkBUeDk6qZUPdqmfKrQ/132","comment_is_top":false,"comment_ctime":1574297412,"is_pvip":false,"replies":[{"id":"59084","content":"是的，用于前端展示的数据。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574306500,"ip_address":"","comment_id":153688,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574297412","product_id":100037301,"comment_content":"老师，对VO不是很理解，是不是前端请求的返回封装成VO?","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475247,"discussion_content":"是的，用于前端展示的数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574306500,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153658,"user_name":"北天魔狼","can_delete":false,"product_type":"c1","uid":1188144,"ip_address":"","ucode":"C22623ECEB8DBA","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/30/8ecce1e1.jpg","comment_is_top":false,"comment_ctime":1574294781,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574294781","product_id":100037301,"comment_content":"回复 涤生：<br>代码目录，包名，类名，方法名，事件名，理论解释，我认为已经够清晰了，有啥不懂可以讨论，不知道为啥你那么激动？送你一句：心中有花，看人即花","like_count":0},{"had_liked":false,"id":153651,"user_name":"Kian.Lee","can_delete":false,"product_type":"c1","uid":1086568,"ip_address":"","ucode":"3FB08A00F2DFD7","user_header":"https://static001.geekbang.org/account/avatar/00/10/94/68/56794ea3.jpg","comment_is_top":false,"comment_ctime":1574293973,"is_pvip":false,"replies":[{"id":"59032","content":"是的，就是这样的。理解后灵活运用。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574296983,"ip_address":"","comment_id":153651,"utype":1}],"discussion_count":1,"race_medal":5,"score":"1574293973","product_id":100037301,"comment_content":"从学习的角度这类数据对象要分清楚和理解它存在的意义，但从实际项目要根据项目自身特性和团队自身情况灵活应用，否则可能会本末倒置，DDD 是为了应对软件复杂性，而不是增加软件复杂性，哪些是核心的、哪些对当前项目是可以合并的、哪些是没有必要的都是架构时要思考的，当前团队成员的专业水准也是要考虑的，这么多概念架构师能深刻理解，开发人员是否也能理解，如何降低开发人员心智负担，如何实现常规业务零代码或低代码可能也是架构师也要思考，总之要牢记什么是“手段”，什么是“目的”。纯粹个人浅见😜","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475237,"discussion_content":"是的，就是这样的。理解后灵活运用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574296983,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153527,"user_name":"张迪","can_delete":false,"product_type":"c1","uid":1104835,"ip_address":"","ucode":"6A5D44999A0FEA","user_header":"https://static001.geekbang.org/account/avatar/00/10/db/c3/e11adfe8.jpg","comment_is_top":false,"comment_ctime":1574253565,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574253565","product_id":100037301,"comment_content":"你知道在微服务内为什么要设计不同的服务和不同的数据对象吗？它体现的是一种什么样的设计思想？<br>解耦层与层之间的关系，减少层之间的依赖。","like_count":0},{"had_liked":false,"id":153379,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1574226859,"is_pvip":false,"replies":[{"id":"58972","content":"<br>第一个问题，如果你的前端场景不复杂，你这样做也是可以的。<br>总的来说，主要看你的微服务应用场景。如果是项目级应用的话，可以根据自己的习惯灵活处理，但是需要记住边界和分层这个大原则。<br>如果是企业级的中台项目的话，建议按照统一的规则来处理，保证职责单一和领域逻辑的稳定。<br>","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574234604,"ip_address":"","comment_id":153379,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1574226859","product_id":100037301,"comment_content":"回答：<br>1.目的是代码解耦。思想是高内聚低耦合。<br><br>提问：<br>1.我个人接口层和应用层是耦合在一起的。请问老师这样单独为数据转换分一层有必要吗？<br><br>2.应用层的代码有时会抽取到bff层（紧保留灵活可复用接口）。以保证不同web间功能的灵活组合。老师觉得这样提炼代码进一步细分的做法如何？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475143,"discussion_content":"\n第一个问题，如果你的前端场景不复杂，你这样做也是可以的。\n总的来说，主要看你的微服务应用场景。如果是项目级应用的话，可以根据自己的习惯灵活处理，但是需要记住边界和分层这个大原则。\n如果是企业级的中台项目的话，建议按照统一的规则来处理，保证职责单一和领域逻辑的稳定。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574234604,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54504,"discussion_content":"建议微服务内的编排放在应用层，微服务之间的放在BFF。尽可能将可复用的能力往下层沉淀。以后如果要做跨中心或者多中心多活时，也是能带来很多好处的，可以避免很多的跨中心的服务调用。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574301250,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53939,"discussion_content":"我这里是复杂的前端逻辑上升到各自bff层去处理。老师是将复杂逻辑放到用户接口层处理。我的方式可以分担请求压力，但有多一跳的问题。  而站在业务划分角度，我也说不准哪种更合理。所以希望老师站自己角度给个分析。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574238513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153319,"user_name":"时间总漫不经心","can_delete":false,"product_type":"c1","uid":1017829,"ip_address":"","ucode":"1D184BB0D564E9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/e5/67495b10.jpg","comment_is_top":false,"comment_ctime":1574215145,"is_pvip":false,"replies":[{"id":"58964","content":"这种数据访问没有太多的模型的概念。用应用服务相对比较轻量化。这也算是一种特殊的跨层调用。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574231900,"ip_address":"","comment_id":153319,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574215145","product_id":100037301,"comment_content":"应用层调用仓储接口，主要是缓存和文件，为什么不把这些放到由实体或者领域服务来调用呢？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475119,"discussion_content":"这种数据访问没有太多的模型的概念。用应用服务相对比较轻量化。这也算是一种特殊的跨层调用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574231900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153309,"user_name":"何沛","can_delete":false,"product_type":"c1","uid":1477145,"ip_address":"","ucode":"5673C580982710","user_header":"https://static001.geekbang.org/account/avatar/00/16/8a/19/a54761af.jpg","comment_is_top":false,"comment_ctime":1574213803,"is_pvip":false,"replies":[{"id":"58882","content":"是的，主要是数据适配。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574216847,"ip_address":"","comment_id":153309,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574213803","product_id":100037301,"comment_content":"微服务之间的调用，肯定会出现不同限界上下文内的通用语言不一致，那就需要对数据对象进行翻译。<br>","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475116,"discussion_content":"是的，主要是数据适配。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574216847,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153220,"user_name":"北天魔狼","can_delete":false,"product_type":"c1","uid":1188144,"ip_address":"","ucode":"C22623ECEB8DBA","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/30/8ecce1e1.jpg","comment_is_top":false,"comment_ctime":1574200537,"is_pvip":true,"replies":[{"id":"58845","content":"严格分层架构应用服务与领域服务一对一情况会稍微多一些。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574206059,"ip_address":"","comment_id":153220,"utype":1}],"discussion_count":0,"race_medal":0,"score":"1574200537","product_id":100037301,"comment_content":"接口层传达用户行为给应用层，应用层组合领域服务完成用户调用，领域服务协调聚合具体类和方法，基础层主要负责数据实现和数据库解耦。<br>老师我有个疑问：如果没有微服务，应用层是不是会产生1对1映射领域服务的情况？","like_count":0}]}