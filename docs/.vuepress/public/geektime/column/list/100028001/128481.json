{"id":128481,"title":"43 | 如何使用缓存优化系统性能？","content":"<p>你好，我是刘超。</p><p>缓存是我们提高系统性能的一项必不可少的技术，无论是前端、还是后端，都应用到了缓存技术。前端使用缓存，可以降低多次请求服务的压力；后端使用缓存，可以降低数据库操作的压力，提升读取数据的性能。</p><p>今天我们将从前端到服务端，系统了解下各个层级的缓存实现，并分别了解下各类缓存的优缺点以及应用场景。</p><h2>前端缓存技术</h2><p>如果你是一位Java开发工程师，你可能会想，我们有必要去了解前端的技术吗？</p><p>不想当将军的士兵不是好士兵，作为一个技术人员，不想做架构师的开发不是好开发。作为架构工程师的话，我们就很有必要去了解前端的知识点了，这样有助于我们设计和优化系统。前端做缓存，可以缓解服务端的压力，减少带宽的占用，同时也可以提升前端的查询性能。</p><h3>1. 本地缓存</h3><p>平时使用拦截器（例如Fiddler）或浏览器Debug时，我们经常会发现一些接口返回304状态码+ Not Modified字符串，如下图中的极客时间Web首页。</p><p><img src=\"https://static001.geekbang.org/resource/image/5a/7b/5ae757f7c5b12901d4422b5722c0647b.png?wh=1093*356\" alt=\"\"></p><p>如果我们对前端缓存技术不了解，就很容易对此感到困惑。浏览器常用的一种缓存就是这种基于304响应状态实现的本地缓存了，通常这种缓存被称为协商缓存。</p><p><span class=\"orange\">协商缓存，顾名思义就是与服务端协商之后，通过协商结果来判断是否使用本地缓存。</span></p><!-- [[[read_end]]] --><p>一般协商缓存可以基于请求头部中的If-Modified-Since字段与返回头部中的Last-Modified字段实现，也可以基于请求头部中的If-None-Match字段与返回头部中的ETag字段来实现。</p><p>两种方式的实现原理是一样的，前者是基于时间实现的，后者是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。下面我们再来了解下整个缓存的实现流程：</p><ul>\n<li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在Response头部加上ETag唯一标识，这个唯一标识的值是根据当前请求的资源生成的；</li>\n<li>当浏览器再次请求访问服务器中的该资源时，会在Request头部加上If-None-Match字段，该字段的值就是Response头部加上ETag唯一标识；</li>\n<li>服务器再次收到请求后，会根据请求中的If-None-Match值与当前请求的资源生成的唯一标识进行比较，如果值相等，则返回304 Not Modified，如果不相等，则在Response头部加上新的ETag唯一标识，并返回资源；</li>\n<li>如果浏览器收到304的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。</li>\n</ul><p>本地缓存中除了这种协商缓存，还有一种就是强缓存的实现。</p><p><span class=\"orange\">强缓存指的是只要判断缓存没有过期，则直接使用浏览器的本地缓存。</span>如下图中，返回的是200状态码，但在size项中标识的是memory cache。</p><p><img src=\"https://static001.geekbang.org/resource/image/0a/48/0a169df1141f31326b4b6ab331ab3748.png?wh=1096*430\" alt=\"\"></p><p>强缓存是利用Expires或者Cache-Control这两个HTTP  Response Header实现的，它们都用来表示资源在客户端缓存的有效期。</p><p>Expires是一个绝对时间，而Cache-Control是一个相对时间，即一个过期时间大小，与协商缓存一样，基于Expires实现的强缓存也会因为时间问题导致缓存管理出现问题。我建议使用Cache-Control来实现强缓存。具体的实现流程如下：</p><ul>\n<li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在Response头部加上Cache-Control，Cache-Control中设置了过期时间大小；</li>\n<li>浏览器再次请求访问服务器中的该资源时，会先通过请求资源的时间与Cache-Control中设置的过期时间大小，来计算出该资源是否过期，如果没有，则使用该缓存，否则请求服务器；</li>\n<li>服务器再次收到请求后，会再次更新Response头部的Cache-Control。</li>\n</ul><h3>2. 网关缓存</h3><p>除了以上本地缓存，我们还可以在网关中设置缓存，也就是我们熟悉的CDN。</p><p>CDN缓存是通过不同地点的缓存节点缓存资源副本，当用户访问相应的资源时，会调用最近的CDN节点返回请求资源，这种方式常用于视频资源的缓存。</p><h2>服务层缓存技术</h2><p>前端缓存一般用于缓存一些不常修改的常量数据或一些资源文件，大部分接口请求的数据都缓存在了服务端，方便统一管理缓存数据。</p><p>服务端缓存的初衷是为了提升系统性能。例如，数据库由于并发查询压力过大，可以使用缓存减轻数据库压力；在后台管理中的一些报表计算类数据，每次请求都需要大量计算，消耗系统CPU资源，我们可以使用缓存来保存计算结果。</p><p>服务端的缓存也分为进程缓存和分布式缓存，在Java中进程缓存就是JVM实现的缓存，常见的有我们经常使用的容器类，ArrayList、ConcurrentHashMap等，分布式缓存则是基于Redis实现的缓存。</p><h3>1. 进程缓存</h3><p>对于进程缓存，虽然数据的存取会更加高效，但JVM的堆内存数量是有限的，且在分布式环境下很难同步各个服务间的缓存更新，所以<span class=\"orange\">我们一般缓存一些数据量不大、更新频率较低的数据。</span>常见的实现方式如下：</p><pre><code>//静态常量\npublic final staticS String url = &quot;https://time.geekbang.org&quot;;\n//list容器\npublic static List&lt;String&gt; cacheList = new Vector&lt;String&gt;();\n //map容器   \nprivate static final Map&lt;String, Object&gt; cacheMap= new ConcurrentHashMap&lt;String, Object&gt;();\n</code></pre><p>除了Java自带的容器可以实现进程缓存，我们还可以基于Google实现的一套内存缓存组件Guava Cache来实现。</p><p>Guava Cache适用于高并发的多线程缓存，它和ConcurrentHashMap一样，都是基于分段锁实现的并发缓存。</p><p>Guava Cache同时也实现了数据淘汰机制，当我们设置了缓存的最大值后，当存储的数据超过了最大值时，它就会使用LRU算法淘汰数据。我们可以通过以下代码了解下Guava Cache的实现：</p><pre><code>public class GuavaCacheDemo {\n    public static void main(String[] args) {\n        Cache&lt;String,String&gt; cache = CacheBuilder.newBuilder()\n                .maximumSize(2)\n                .build();\n        cache.put(&quot;key1&quot;,&quot;value1&quot;);\n        cache.put(&quot;key2&quot;,&quot;value2&quot;);\n        cache.put(&quot;key3&quot;,&quot;value3&quot;);\n        System.out.println(&quot;第一个值：&quot; + cache.getIfPresent(&quot;key1&quot;));\n        System.out.println(&quot;第二个值：&quot; + cache.getIfPresent(&quot;key2&quot;));\n        System.out.println(&quot;第三个值：&quot; + cache.getIfPresent(&quot;key3&quot;));\n    }\n}\n</code></pre><p>运行结果：</p><pre><code>第一个值：null\n第二个值：value2\n第三个值：value3\n</code></pre><p>那如果我们的数据量比较大，且数据更新频繁，又是在分布式部署的情况下，想要使用JVM堆内存作为缓存，这时我们又该如何去实现呢？</p><p>Ehcache是一个不错的选择，Ehcache经常在Hibernate中出现，主要用来缓存查询数据结果。Ehcache是Apache开源的一套缓存管理类库，是基于JVM堆内存实现的缓存，同时具备多种缓存失效策略，支持磁盘持久化以及分布式缓存机制。</p><h3>2. 分布式缓存</h3><p>由于高并发对数据一致性的要求比较严格，我一般不建议使用Ehcache缓存有一致性要求的数据。对于分布式缓存，我们建议使用Redis来实现，Redis相当于一个内存数据库，由于是纯内存操作，又是基于单线程串行实现，查询性能极高，读速度超过了10W次/秒。</p><p>Redis除了高性能的特点之外，还支持不同类型的数据结构，常见的有string、list、set、hash等，还支持数据淘汰策略、数据持久化以及事务等。</p><p>两种缓存讲完了，接下来我们看看其中可能出现的问题。</p><h3>数据库与缓存数据一致性问题</h3><p>在查询缓存数据时，我们会先读取缓存，如果缓存中没有该数据，则会去数据库中查询，之后再放入到缓存中。</p><p>当我们的数据被缓存之后，一旦数据被修改（修改时也是删除缓存中的数据）或删除，我们就需要同时操作缓存和数据库。这时，就会存在一个数据不一致的问题。</p><p>例如，在并发情况下，当A操作使得数据发生删除变更，那么该操作会先删除缓存中的数据，之后再去删除数据库中的数据，此时若是还没有删除成功，另外一个请求查询操作B进来了，发现缓存中已经没有了数据，则会去数据库中查询，此时发现有数据，B操作获取之后又将数据存放在了缓存中，随后数据库的数据又被删除了。此时就出现了数据不一致的情况。</p><p>那如果先删除数据库，再删除缓存呢？</p><p>我们可以试一试。在并发情况下，当A操作使得数据发生删除变更，那么该操作会先删除了数据库的操作，接下来删除缓存，失败了，那么缓存中的数据没有被删除，而数据库的数据已经被删除了，同样会存在数据不一致的问题。</p><p>所以，我们还是需要先做缓存删除操作，再去完成数据库操作。那我们又该如何避免高并发下，数据更新删除操作所带来的数据不一致的问题呢？</p><p>通常的解决方案是，如果我们需要使用一个线程安全队列来缓存更新或删除的数据，当A操作变更数据时，会先删除一个缓存数据，此时通过线程安全的方式将缓存数据放入到队列中，并通过一个线程进行数据库的数据删除操作。</p><p>当有另一个查询请求B进来时，如果发现缓存中没有该值，则会先去队列中查看该数据是否正在被更新或删除，如果队列中有该数据，则阻塞等待，直到A操作数据库成功之后，唤醒该阻塞线程，再去数据库中查询该数据。</p><p>但其实这种实现也存在很多缺陷，例如，可能存在读请求被长时间阻塞，高并发时低吞吐量等问题。所以<span class=\"orange\">我们在考虑缓存时，如果数据更新比较频繁且对数据有一定的一致性要求，我通常不建议使用缓存。</span></p><h3>缓存穿透、缓存击穿、缓存雪崩</h3><p>对于分布式缓存实现大数据的存储，除了数据不一致的问题以外，还有缓存穿透、缓存击穿、缓存雪崩等问题，我们平时实现缓存代码时，应该充分、全面地考虑这些问题。</p><p>缓存穿透是指大量查询没有命中缓存，直接去到数据库中查询，如果查询量比较大，会导致数据库的查询流量大，对数据库造成压力。</p><p>通常有两种解决方案，一种是将第一次查询的空值缓存起来，同时设置一个比较短的过期时间。但这种解决方案存在一个安全漏洞，就是当黑客利用大量没有缓存的key攻击系统时，缓存的内存会被占满溢出。</p><p>另一种则是使用布隆过滤算法（BloomFilter），该算法可以用于检查一个元素是否存在，返回结果有两种：可能存在或一定不存在。这种情况很适合用来解决故意攻击系统的缓存穿透问题，在最初缓存数据时也将key值缓存在布隆过滤器的BitArray中，当有key值查询时，对于一定不存在的key值，我们可以直接返回空值，对于可能存在的key值，我们会去缓存中查询，如果没有值，再去数据库中查询。</p><p>BloomFilter的实现原理与Redis中的BitMap类似，首先初始化一个m长度的数组，并且每个bit初始化值都是0，当插入一个元素时，会使用n个hash函数来计算出n个不同的值，分别代表所在数组的位置，然后再将这些位置的值设置为1。</p><p>假设我们插入两个key值分别为20,28的元素，通过两次哈希函数取模后的值分别为4,9以及14,19，因此4,9以及14,19都被设置为1。</p><p><img src=\"https://static001.geekbang.org/resource/image/d9/a3/d939bf92331838da581c4b500e7473a3.jpg?wh=2366*698\" alt=\"\"></p><p>那为什么说BloomFilter返回的结果是可能存在和一定不存在呢？</p><p>假设我们查找一个元素25，通过n次哈希函数取模后的值为1,9,14。此时在BitArray中肯定是不存在的。而当我们查找一个元素21的时候，n次哈希函数取模后的值为9,14，此时会返回可能存在的结果，但实际上是不存在的。</p><p>BloomFilter不允许删除任何元素的，为什么？假设以上20,25,28三个元素都存在于BitArray中，取模的位置值分别为4,9、1,9,14以及14,19，如果我们要删除元素25，此时需要将1,9,14的位置都置回0，这样就影响20,28元素了。</p><p>因此，BloomFilter是不允许删除任何元素的，这样会导致已经删除的元素依然返回可能存在的结果，也会影响BloomFilter判断的准确率，解决的方法则是重建一个BitArray。</p><p>那什么缓存击穿呢？在高并发情况下，同时查询一个key时，key值由于某种原因突然失效（设置过期时间或缓存服务宕机），就会导致同一时间，这些请求都去查询数据库了。这种情况经常出现在查询热点数据的场景中。通常我们会在查询数据库时，使用排斥锁来实现有序地请求数据库，减少数据库的并发压力。</p><p>缓存雪崩则与缓存击穿差不多，区别就是失效缓存的规模。雪崩一般是指发生大规模的缓存失效情况，例如，缓存的过期时间同一时间过期了，缓存服务宕机了。对于大量缓存的过期时间同一时间过期的问题，我们可以采用分散过期时间来解决；而针对缓存服务宕机的情况，我们可以采用分布式集群来实现缓存服务。</p><h2>总结</h2><p>从前端到后端，对于一些不常变化的数据，我们都可以将其缓存起来，这样既可以提高查询效率，又可以降低请求后端的压力。对于前端来说，一些静态资源文件都是会被缓存在浏览器端，除了静态资源文件，我们还可以缓存一些常量数据，例如商品信息。</p><p>服务端的缓存，包括了JVM的堆内存作为缓存以及Redis实现的分布式缓存。如果是一些不常修改的数据，数据量小，且对缓存数据没有严格的一致性要求，我们就可以使用堆内存缓存数据，这样既实现简单，查询也非常高效。如果数据量比较大，且是经常被修改的数据，或对缓存数据有严格的一致性要求，我们就可以使用分布式缓存来存储。</p><p>在使用后端缓存时，我们应该注意数据库和缓存数据的修改导致的数据不一致问题，如果对缓存与数据库数据有非常严格的一致性要求，我就不建议使用缓存了。</p><p>同时，我们应该针对大量请求缓存的接口做好预防工作，防止查询缓存的接口出现缓存穿透、缓存击穿和缓存雪崩等问题。</p><h2>思考题</h2><p>在基于Redis实现的分布式缓存中，我们更新数据时，为什么建议直接将缓存中的数据删除，而不是更新缓存中的数据呢？</p><p>期待在留言区看到你的答案。也欢迎你点击“请朋友读”，把今天的内容分享给身边的朋友，邀请他一起讨论。</p><p><span class=\"reference\"></span></p>","comments":[{"had_liked":false,"id":129330,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1567089367,"is_pvip":false,"replies":[{"id":"48177","content":"👍🏻 对的，两个并发写去更新还存在一致性的问题。不过，在删除缓存后，记得读取数据需要加锁或延时等待，防止读取脏数据。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1567128010,"ip_address":"","comment_id":129330,"utype":1}],"discussion_count":1,"race_medal":0,"score":"91761402583","product_id":100028001,"comment_content":"学到了很多，挺收益的，思考题：更新效率太低，代价很大，且不一定被访问的频率高，不高则没必要缓存，还不如直接删掉，而且还容易出现数据不一致问题","like_count":22,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465405,"discussion_content":"👍🏻 对的，两个并发写去更新还存在一致性的问题。不过，在删除缓存后，记得读取数据需要加锁或延时等待，防止读取脏数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567128010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129189,"user_name":"Loubobooo","can_delete":false,"product_type":"c1","uid":1108306,"ip_address":"","ucode":"7B2543A80EBDEF","user_header":"https://static001.geekbang.org/account/avatar/00/10/e9/52/aa3be800.jpg","comment_is_top":false,"comment_ctime":1567059554,"is_pvip":false,"replies":[{"id":"48184","content":"👍🏻 回答很全面","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1567129207,"ip_address":"","comment_id":129189,"utype":1}],"discussion_count":2,"race_medal":0,"score":"44516732514","product_id":100028001,"comment_content":"课后题：原因很简单<br>1. 很多时候，在复杂点的缓存场景，缓存不单单是数据库中直接取出来的值。比如可能更新了某个表的一个字段，然后其对应的缓存，是需要查询另外两个表的数据并进行运算，才能计算出缓存最新的值的。<br>另外更新缓存的代价有时候是很高的。每次修改数据库的时候，都一定要将其对应的缓存更新一份，这样做的代价较高。如果遇到复杂的缓存数据计算的场景，缓存频繁更新，但这个缓存到底会不会被频繁访问到？如果没有，这个缓存的效率就很低了","like_count":10,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465323,"discussion_content":"👍🏻 回答很全面","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567129207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181650,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","nickname":"惘 闻","note":"","ucode":"C5909F034BF072","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338597,"discussion_content":"复杂的计算的话无论是在数据库更新还是两方都更新,只需要计算一次不就够了嘛?比如更新数据库字段,进行了运算后更新字段值,然后直接拿着这个值更新到缓存中不就可以吗,不需要再次计算吧?不是很理解这种场景啊,可以讲解一下吗?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609320068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129049,"user_name":"giserway","can_delete":false,"product_type":"c1","uid":1067304,"ip_address":"","ucode":"139D579F323383","user_header":"https://static001.geekbang.org/account/avatar/00/10/49/28/4dcfa376.jpg","comment_is_top":false,"comment_ctime":1567035151,"is_pvip":true,"replies":[{"id":"48187","content":"对的，这也是一种情况","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1567130253,"ip_address":"","comment_id":129049,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31631806223","product_id":100028001,"comment_content":"还有就是更新缓存代价大。如果缓存里的数据不是把数据库里的数据直接存下来，而是需要经过某种复杂的运算，那么这种不必要的更新会带来更大的浪费。","like_count":8,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465243,"discussion_content":"对的，这也是一种情况","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567130253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244789,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1598677358,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27368481134","product_id":100028001,"comment_content":"缓存的三种问题<br>- 缓存穿透：大批量请求不存在的key，导致数据库压力增大。【解决方案】：布隆过滤器。<br>- 缓存击穿：同一时间大批量请求一个过期的key，导致这些请求在同一时间访问数据库。【解决方案】：获取数据库后回写这个过程申请分布式锁，只有一个请求能获取后回写，其他一直重试等待。<br>- 缓存雪崩：同一时间大批量key过期。【解决方案】：设置expire time的时候随机加1~5分钟的超时。<br><br>数据库和缓存一致性解决：<br>【Cache Aside Pattern】因为更新数据库后删除缓存的话，如果缓存删除失败，则会存在不一致的问题，所以需要先删除缓存后更新数据库。但是这里可能存在删除缓存后有**其他请求**判断缓存没有数据则从数据库中读取后回写导致的不一致问题，所以需要再进一步：删除缓存后，把缓存数据放到一个队列，其他请求到来的时候判断缓存里面没数据，再去队列里面查看，如果队列里面有这个缓存数据，则一直阻塞等待，知道前一个请求把数据库更新完毕后再唤醒。","like_count":6},{"had_liked":false,"id":129046,"user_name":"yungoo","can_delete":false,"product_type":"c1","uid":1060805,"ip_address":"","ucode":"D9BB84A75047CB","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/c5/aaacb98f.jpg","comment_is_top":false,"comment_ctime":1567033093,"is_pvip":false,"replies":[{"id":"48188","content":"👍🏻 存在并发更新时数据不一致问题","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1567130319,"ip_address":"","comment_id":129046,"utype":1}],"discussion_count":2,"race_medal":0,"score":"27336836869","product_id":100028001,"comment_content":"基于redis集中缓存更新数据采用删除而不是直接更新缓存的原因之一：避免二类更新丢失问题。<br><br>分布式系统中当存在并发数据更新时，因无法保证更新操作顺序的时间一致性，从而导致旧值覆盖新值。<br><br>如：<br>t1时间点，A进程发起更新key1为1的P1操作。<br>t1+x时间点，B进程发起更新key1为2的P2操作。<br>其中P1 -&gt; P2，数据库中值为2。<br><br>而redis收到的指令，可能因网络抖动或者STW，实际为P2 -&gt; P1，缓存的值为1，造成数据不一致。","like_count":6,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465241,"discussion_content":"👍🏻 存在并发更新时数据不一致问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567130319,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1094597,"avatar":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","nickname":"Liam","note":"","ucode":"1D15D3B64F2606","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7703,"discussion_content":"那么先更新缓存，再更新数据库就好了吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567646226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133005,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1568301280,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18748170464","product_id":100028001,"comment_content":"我觉得看场景，我们是电商的核心系统，计算全部依赖缓存，我们的缓存是经过复杂计算的结构数据，每天定时任务刷新，更新是全部是先添加有效数据后删除无效数据。添加有效数据时，如果数据存在就是更新操作了啦！我觉得挺OK的","like_count":5},{"had_liked":false,"id":129048,"user_name":"giserway","can_delete":false,"product_type":"c1","uid":1067304,"ip_address":"","ucode":"139D579F323383","user_header":"https://static001.geekbang.org/account/avatar/00/10/49/28/4dcfa376.jpg","comment_is_top":false,"comment_ctime":1567035062,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"14451936950","product_id":100028001,"comment_content":"如果是更新数据库再操作缓存的话，此时更新缓存的操作不是必须的。可能缓存里的数据并没有被读到，就会被下一次更新MySQL操作带来Redis更新操作覆盖，那么本次更新操作就是无意义的。","like_count":3,"discussions":[{"author":{"id":1372119,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ef/d7/2f700986.jpg","nickname":"calvin sheng","note":"","ucode":"D992BDA50DACC7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":16964,"discussion_content":"说的对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568938213,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129455,"user_name":"victoriest","can_delete":false,"product_type":"c1","uid":1023394,"ip_address":"","ucode":"7B4232B0FB88F6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9d/a2/d8a708cc.jpg","comment_is_top":false,"comment_ctime":1567132113,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10157066705","product_id":100028001,"comment_content":"只看 模块七 值回票价","like_count":2,"discussions":[{"author":{"id":2238635,"avatar":"https://static001.geekbang.org/account/avatar/00/22/28/ab/b8905658.jpg","nickname":"AsYouWish99","note":"","ucode":"A5CE38DAD56115","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578329,"discussion_content":"啊对对对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656661079,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129092,"user_name":"Maxwell","can_delete":false,"product_type":"c1","uid":1211320,"ip_address":"","ucode":"D28CC11C99F0CE","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/b8/6f47ba1b.jpg","comment_is_top":false,"comment_ctime":1567041536,"is_pvip":false,"replies":[{"id":"48185","content":"最常用的就是使用同步锁或Lock锁实现。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1567129820,"ip_address":"","comment_id":129092,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10156976128","product_id":100028001,"comment_content":"老师您说的：通常我们会在查询数据库时，使用排斥锁来实现有序地请求数据库，减少数据库的并发压力。这个通常哪些方案？","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465270,"discussion_content":"最常用的就是使用同步锁或Lock锁实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567129820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1542745,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8a/59/d5aec34a.jpg","nickname":"胜","note":"","ucode":"3D813DC2EFE032","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":37823,"discussion_content":"在查询中使用锁会不会降低查询性能","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1571669672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1024294,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","nickname":"null","note":"","ucode":"F9039EFED6B55D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372878,"discussion_content":"老师回复的，解决不了分布式环境的读取。比如机器A和机器B同时执行该流程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620487358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":227511,"user_name":"耿嘉艺","can_delete":false,"product_type":"c1","uid":2023401,"ip_address":"","ucode":"727A22BD41E8AF","user_header":"","comment_is_top":false,"comment_ctime":1592397073,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5887364369","product_id":100028001,"comment_content":"更新缓存的时候，加锁保证一致性，不行吗？毕竟redis执行还是单线程的","like_count":1,"discussions":[{"author":{"id":1134861,"avatar":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","nickname":"James","note":"","ucode":"48B0F2A334D1C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350933,"discussion_content":"分布式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614076767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1260141,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3a/6d/910b2445.jpg","nickname":"Wheat","note":"","ucode":"7D99EA149B6DE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327249,"discussion_content":"加分布式锁性能会不会更低，又得改缓存又得改数据库还得改锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605775403,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146460,"user_name":"ty_young","can_delete":false,"product_type":"c1","uid":1284337,"ip_address":"","ucode":"EB1D5DB0AE7B33","user_header":"","comment_is_top":false,"comment_ctime":1572528336,"is_pvip":false,"replies":[{"id":"72195","content":"强制缓存只有两种情况，要么访问服务端，要么用本地缓存，所以加上协商缓存意义不大","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1584017273,"ip_address":"","comment_id":146460,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5867495632","product_id":100028001,"comment_content":"老师您好，请问协商缓存和强制缓存没有关联么，不会先走强制缓存，然后在强制缓存的基础上走协商缓存","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472871,"discussion_content":"强制缓存只有两种情况，要么访问服务端，要么用本地缓存，所以加上协商缓存意义不大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584017273,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129312,"user_name":"Better me","can_delete":false,"product_type":"c1","uid":1261959,"ip_address":"","ucode":"CADF08D357489A","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","comment_is_top":false,"comment_ctime":1567085697,"is_pvip":true,"replies":[{"id":"48178","content":"这是为了计算不同的位置，通过不同位置置1，得出一个数值。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1567128100,"ip_address":"","comment_id":129312,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5862052993","product_id":100028001,"comment_content":"布隆过滤器为什么要经过n个hash函数散列，有什么特别的考虑吗","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465394,"discussion_content":"这是为了计算不同的位置，通过不同位置置1，得出一个数值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567128100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1447569,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/WtHCCMoLJ2DvzqQwPYZyj2RlN7eibTLMHDMTSO4xIKjfKR1Eh9L98AMkkZY7FmegWyGLahRQJ5ibPzeeFtfpeSow/132","nickname":"脱缰的野马__","note":"","ucode":"D5F993E7232C61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":259223,"discussion_content":"大佬应该是帮别人问的吧？学习记录也是惊人！简单来说是为了提高数据准确度，一个hash函数容易冲突那多个一起来计算的话得出不同的位置，整体冲突的可能性就更低了，另外一种降低冲突的方式就是增大数组的大小","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588769475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1261959,"avatar":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","nickname":"Better me","note":"","ucode":"CADF08D357489A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1447569,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/WtHCCMoLJ2DvzqQwPYZyj2RlN7eibTLMHDMTSO4xIKjfKR1Eh9L98AMkkZY7FmegWyGLahRQJ5ibPzeeFtfpeSow/132","nickname":"脱缰的野马__","note":"","ucode":"D5F993E7232C61","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":259603,"discussion_content":"那会是真不懂😂，增大数组大小未必是一个好方法，哈希冲突产生的原因是因为鸽巢原理。由于数据规模是不断增大的，数组再大也是可能被占满空间并产生冲突的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588782440,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":259223,"ip_address":""},"score":259603,"extra":""}]}]},{"had_liked":false,"id":129196,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1567060834,"is_pvip":false,"replies":[{"id":"48183","content":"对的，如果两个并发写去更新还存在一致性的问题，还不如直接删除，等下次读取的时候再次写入缓存中。不过，在删除缓存后，记得读取数据需要加锁或延时等待，防止读取脏数据。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1567129093,"ip_address":"","comment_id":129196,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5862028130","product_id":100028001,"comment_content":"直接更新缓存中的数据，因为请求到达的顺序无法保证，有可能后请求的数据覆盖前请求的数据。直接将数据删除，就是一种幂等的操作，删除后，再去数据库拉数据，就不会有覆写的问题。","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465327,"discussion_content":"对的，如果两个并发写去更新还存在一致性的问题，还不如直接删除，等下次读取的时候再次写入缓存中。不过，在删除缓存后，记得读取数据需要加锁或延时等待，防止读取脏数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567129093,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129060,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1567037433,"is_pvip":false,"replies":[{"id":"48186","content":"通常我们是会指定一些静态资源文件上传到CDN上去，并且通过版本号来更新。例如，我们的js资源文件是 xxx001.js，如果我们更新了该资源文件，则将xxx002.js推送到CDN上，同时前端的访问路径也更新访问资源路径。<br>","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1567130235,"ip_address":"","comment_id":129060,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5862004729","product_id":100028001,"comment_content":" 老师真棒，全能。<br>CDN的缓存策略是copy服务端的，协商缓存和强缓存?如果有些静态资源，服务端开发没做缓存策略，CDN还会缓存么?实际开发中用过一次CDN。是在资源路径前，拼接一段CDN路径。具体不知<br>课后习题，如果并发操作时，虽然redis是单线程的但是没法保证网络延时下，先更新数据库。也先更新缓存。个人感觉失效一个key比写一个key开销小。网络传输上看，update还得传一个value的值，redis更新还得写缓存感觉也是失效慢。并发情况写两次(除开正确性)有一次的写完全浪费。","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465252,"discussion_content":"通常我们是会指定一些静态资源文件上传到CDN上去，并且通过版本号来更新。例如，我们的js资源文件是 xxx001.js，如果我们更新了该资源文件，则将xxx002.js推送到CDN上，同时前端的访问路径也更新访问资源路径。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567130235,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":354046,"user_name":"防腐基","can_delete":false,"product_type":"c1","uid":2696605,"ip_address":"湖北","ucode":"0FF3BF30631995","user_header":"https://static001.geekbang.org/account/avatar/00/29/25/9d/d612cbf8.jpg","comment_is_top":false,"comment_ctime":1660039718,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1660039718","product_id":100028001,"comment_content":"缓存击穿的解决方案作者说的是使用排斥锁，我这里提供另一个更简单的方案。<br>直接设置成永不过期即可，原因很简单，达到缓存击穿这个量级的公司凤毛麟角，绝大部分程序员可能整个职业生涯都遇不到。<br>所以，对于可能出现这种情况的极少数的热点key，直接设置永不过期即可，一劳永逸，也省得动脑了。","like_count":0},{"had_liked":false,"id":301928,"user_name":"平民人之助","can_delete":false,"product_type":"c1","uid":2658705,"ip_address":"","ucode":"5CCEC0BAC08AEC","user_header":"https://static001.geekbang.org/account/avatar/00/28/91/91/428a27a3.jpg","comment_is_top":false,"comment_ctime":1625977732,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625977732","product_id":100028001,"comment_content":"更新不是用redisson的getandset操作吗","like_count":0},{"had_liked":false,"id":291793,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1620485746,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620485746","product_id":100028001,"comment_content":"原文：<br>当 A 操作变更数据时，会先删除一个缓存数据，此时通过线程安全的方式将缓存数据放入到队列中，并通过一个线程进行数据库的数据删除操作。<br>当有另一个查询请求 B 进来时，…，如果队列中有该数据，则阻塞等待，直到 A 操作数据库成功之后，唤醒该阻塞线程，再去数据库中查询该数据。<br><br>问题：<br>老师好，原文的这段话，有点不太明白。<br>1. 线程安全的队列，不能是 JVM 中的队列吧。分布式环境，用 redis 队列？<br>2. 为什么要通过另一个线程去更新数据库，此时 A 线程不就空闲了么？<br>3. 分布式环境下，A 线程如何阻塞和唤醒 B 线程？<br><br>谢谢老师！","like_count":0},{"had_liked":false,"id":291769,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1620470321,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620470321","product_id":100028001,"comment_content":"Cache-Control: max-age=60天<br>不能依赖本地时间，浏览器怎么去维护是否过期吖？<br><br>谢谢老师！","like_count":0},{"had_liked":false,"id":280094,"user_name":"James","can_delete":false,"product_type":"c1","uid":1134861,"ip_address":"","ucode":"48B0F2A334D1C1","user_header":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","comment_is_top":false,"comment_ctime":1614078721,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614078721","product_id":100028001,"comment_content":"你好。问答题。<br><br>两个并发写去更新还存在一致性的问题。不过，在删除缓存后，记得读取数据需要加锁或延时等待，防止读取脏数据。<br><br>一致性问题理解了，<br>后面读取数据是另外一个查询接口加锁？<br>原先接口删除缓存，读取数据库更新缓存时候加锁？","like_count":0},{"had_liked":false,"id":272461,"user_name":"放不下荣华富贵","can_delete":false,"product_type":"c1","uid":2053679,"ip_address":"","ucode":"9FE29C22B9ABE3","user_header":"https://static001.geekbang.org/account/avatar/00/1f/56/2f/4518f8e1.jpg","comment_is_top":false,"comment_ctime":1610094520,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1610094520","product_id":100028001,"comment_content":"“在并发情况下，当 A 操作使得数据发生删除变更，那么该操作会先删除了数据库的操作，接下来删除缓存，失败了”<br>===========================<br>删除缓存失败几率很小的吧？大概什么情况会出现失败呢？除了网络原因","like_count":0},{"had_liked":false,"id":270927,"user_name":"惘 闻","can_delete":false,"product_type":"c1","uid":1181650,"ip_address":"","ucode":"C5909F034BF072","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","comment_is_top":false,"comment_ctime":1609320071,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609320071","product_id":100028001,"comment_content":"复杂的计算的话无论是在数据库更新还是两方都更新,只需要计算一次不就够了嘛?比如更新数据库字段,进行了运算后更新字段值,然后直接拿着这个值更新到缓存中不就可以吗,不需要再次计算吧?不是很理解这种场景啊,可以讲解一下吗?","like_count":0},{"had_liked":false,"id":262593,"user_name":"Wheat","can_delete":false,"product_type":"c1","uid":1260141,"ip_address":"","ucode":"7D99EA149B6DE8","user_header":"https://static001.geekbang.org/account/avatar/00/13/3a/6d/910b2445.jpg","comment_is_top":false,"comment_ctime":1605775521,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605775521","product_id":100028001,"comment_content":"老师我想问一下，像缓存穿透和雪崩这种瞬时流量大的问题，无法通过MQ解决吗","like_count":0},{"had_liked":false,"id":253223,"user_name":"Wang","can_delete":false,"product_type":"c1","uid":1052957,"ip_address":"","ucode":"9BEFA46433F86B","user_header":"https://static001.geekbang.org/account/avatar/00/10/11/1d/6ad7eb3c.jpg","comment_is_top":false,"comment_ctime":1602655734,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1602655734","product_id":100028001,"comment_content":"老师，协商缓存中，提到的服务器，也就是服务端返回Etag唯一标识。那这个服务器是nginx服务器。还是应用程序服务器中应用给加的呢？","like_count":0},{"had_liked":false,"id":166216,"user_name":"insist","can_delete":false,"product_type":"c1","uid":1054536,"ip_address":"","ucode":"1EE2800A900BA7","user_header":"https://static001.geekbang.org/account/avatar/00/10/17/48/3ab39c86.jpg","comment_is_top":false,"comment_ctime":1577417465,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577417465","product_id":100028001,"comment_content":"工作中都有涉及到  但是自己缺乏总结，这篇文章很好","like_count":0},{"had_liked":false,"id":142908,"user_name":"绿里奇迹","can_delete":false,"product_type":"c1","uid":1173341,"ip_address":"","ucode":"E1E7BC3AAEC86A","user_header":"https://static001.geekbang.org/account/avatar/00/11/e7/5d/a99d32d5.jpg","comment_is_top":false,"comment_ctime":1571580001,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1571580001","product_id":100028001,"comment_content":"“当黑客利用大量没有缓存的 key 攻击系统时，缓存的内存会被占满溢出”。但是即使使用bloom filter，这些不存在的key也会被判断为不存在，于是继续在缓存中创建该key，直到缓存被占满请问使用bloom filter为什么能解决这类故意攻击的问题？","like_count":0,"discussions":[{"author":{"id":1186115,"avatar":"https://static001.geekbang.org/account/avatar/00/12/19/43/226ca347.jpg","nickname":"Michael 🛡YZY","note":"","ucode":"F1D2BF8489A7D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":48163,"discussion_content":"我来试着解答一下 BFilter应该是初步过滤可能存在的key 如果没有就直接返回null","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573455502,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134861,"avatar":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","nickname":"James","note":"","ucode":"48B0F2A334D1C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350934,"discussion_content":"过滤器查询不存在直接返回空，不会在缓存中加缓存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614076929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1476000,"avatar":"https://static001.geekbang.org/account/avatar/00/16/85/a0/59213754.jpg","nickname":"小猪🐷","note":"","ucode":"50AC5D20D81C01","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338695,"discussion_content":"布隆过滤器判断不存在后直接返回默认值或null，不会再在缓存中set 值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609340587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137539,"user_name":"💢 星星💢","can_delete":false,"product_type":"c1","uid":1254392,"ip_address":"","ucode":"A402B765222C35","user_header":"https://static001.geekbang.org/account/avatar/00/13/23/f8/24fcccea.jpg","comment_is_top":false,"comment_ctime":1569769207,"is_pvip":false,"replies":[{"id":"52883","content":"没有理解错，锁和我文中提到的队列都是解决redis缓存数据一致性问题的方案，这种解决方案会带来一定的性能损耗","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1569813599,"ip_address":"","comment_id":137539,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1569769207","product_id":100028001,"comment_content":"老师，我有个问题，分布式更新或者删除缓存的时候，为啥不对这个操作加锁呢，例如a线程更新或者删除缓存，并更新数据库，然后解锁。此时b线程在争夺锁。并且持有锁。是不是性能问题，所以不这样，还是我理解错了？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469142,"discussion_content":"没有理解错，锁和我文中提到的队列都是解决redis缓存数据一致性问题的方案，这种解决方案会带来一定的性能损耗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569813599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1542745,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8a/59/d5aec34a.jpg","nickname":"胜","note":"","ucode":"3D813DC2EFE032","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":37829,"discussion_content":"如果是集群部署lock锁还生效吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571669804,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1254392,"avatar":"https://static001.geekbang.org/account/avatar/00/13/23/f8/24fcccea.jpg","nickname":"💢 星星💢","note":"","ucode":"A402B765222C35","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1542745,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8a/59/d5aec34a.jpg","nickname":"胜","note":"","ucode":"3D813DC2EFE032","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51331,"discussion_content":"不生效，我说的是分布式锁的情况，例如基于zookeeper做分布式的情况，lock锁只在应用级别才有用，跨应用，获取锁资源需要一个协调者维护。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573833875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":37829,"ip_address":""},"score":51331,"extra":""}]}]},{"had_liked":false,"id":131118,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1567646392,"is_pvip":false,"replies":[{"id":"50231","content":"是的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1567827391,"ip_address":"","comment_id":131118,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567646392","product_id":100028001,"comment_content":"把数据库的数据全部加载到bitmap?","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466294,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567827391,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131117,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1567646362,"is_pvip":false,"replies":[{"id":"50235","content":"初始化时将数据加载到bit array中","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1567827470,"ip_address":"","comment_id":131117,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567646362","product_id":100028001,"comment_content":"bloom filter怎么初始化呢？刚开始bit array都是0吧，不可能直接拒绝掉呀？难道是把数据库的","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466293,"discussion_content":"初始化时将数据加载到bit array中","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567827470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129644,"user_name":"Maxwell","can_delete":false,"product_type":"c1","uid":1211320,"ip_address":"","ucode":"D28CC11C99F0CE","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/b8/6f47ba1b.jpg","comment_is_top":false,"comment_ctime":1567179683,"is_pvip":false,"replies":[{"id":"50264","content":"使用队列来异步更新数据，没有压力","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1567828517,"ip_address":"","comment_id":129644,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567179683","product_id":100028001,"comment_content":"老师高并发时会不会卡？影响吞吐量，涉及到要更改公用数据如消费积分总量、每天的消费积分额度，现在没加锁，靠数据库的事务更新，担心以后qps上来了数据库扛不住","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465581,"discussion_content":"使用队列来异步更新数据，没有压力","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567828517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129352,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1567093739,"is_pvip":false,"replies":[{"id":"48194","content":"对的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1567130741,"ip_address":"","comment_id":129352,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567093739","product_id":100028001,"comment_content":"浏览器缓存就是常说的http缓存么？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465412,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567130741,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129096,"user_name":"撒旦的堕落","can_delete":false,"product_type":"c1","uid":1116864,"ip_address":"","ucode":"15F6AA41EE556F","user_header":"https://static001.geekbang.org/account/avatar/00/11/0a/c0/401c240e.jpg","comment_is_top":false,"comment_ctime":1567042224,"is_pvip":false,"replies":[{"id":"48190","content":"暂时没有想到更好的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1567130567,"ip_address":"","comment_id":129096,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1567042224","product_id":100028001,"comment_content":"老师说 缓存数据库一致性问题时 当一个线程缓存删除 而数据库中没有来得及删除时 另一个线程来请求数据  发现缓存中数据不存在去队列中判断 如果数据在更新中 则等待 然后唤醒  不过如果是不同进程中的线程呢 怎么唤醒？感觉这种方式要维护的数据更多了 要把删除的缓存取出来放到队列中  然后更新完成后 还要删除队列中的数据 为了应对分布式的情况  还要使用的是分布式队列  效率变低了  有木有更好的办法呢","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465274,"discussion_content":"暂时没有想到更好的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567130567,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1307497,"avatar":"https://static001.geekbang.org/account/avatar/00/13/f3/69/7039d03f.jpg","nickname":"书策稠浊","note":"","ucode":"A29875CE15FDA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392624,"discussion_content":"一致性要求高，且更新并发高的场景不适用缓存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631076728,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}