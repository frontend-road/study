{"id":425015,"title":"加餐｜期中测试：参考实现讲解","content":"<p>你好，我是陈天。</p><p>上一讲给你布置了一份简单的期中考试习题，不知道你完成的怎么样。今天我们来简单讲一讲实现，供你参考。</p><p>支持 grep 并不是一件复杂的事情，相信你在使用了 clap、glob、rayon 和 regex 后，都能写出类似的代码（伪代码）：</p><pre><code class=\"language-rust\">/// Yet another simplified grep built with Rust.\n#[derive(Clap, Debug)]\n#[clap(version = \"1.0\", author = \"Tyr Chen &lt;tyr@chen.com&gt;\")]\n#[clap(setting = AppSettings::ColoredHelp)]\npub struct GrepConfig {\n    /// regex pattern to match against file contents\n    pattern: String,\n    /// Glob of file pattern\n    glob: String,\n}\n\nimpl GrepConfig {\n    pub fn matches(&amp;self) -&gt; Result&lt;()&gt; {\n        let regex = Regex::new(&amp;self.pattern)?;\n        let files: Vec&lt;_&gt; = glob::glob(&amp;self.glob)?.collect();\n        files.into_par_iter().for_each(|v| {\n            if let Ok(filename) = v {\n                if let Ok(file) = File::open(&amp;filename) {\n                    let reader = BufReader::new(file);\n                    |-\tfor (lineno, line) in reader.lines().enumerate() {\n                    |       if let Ok(line) = line {\n                    |           if let Some(_) = pattern.find(&amp;line) {\n                    |               println!(\"{}: {}\", lineno + 1, &amp;line);\n                    |           }\n                    |       }\n                    |-  }\n                }\n            }\n        });\n        Ok(())\n    }\n}\n</code></pre><!-- [[[read_end]]] --><p>这个代码撰写的感觉和 Python 差不多，除了阅读几个依赖花些时间外，几乎没有难度。</p><p>不过，这个代码不具备可测试性，会给以后的维护和扩展带来麻烦。我们来看看如何优化，使这段代码更加容易测试。</p><h2>如何写出好实现</h2><p>首先，我们要剥离主要逻辑。</p><p>主要逻辑是什么？自然是对于单个文件的 grep，也就是代码中标记的部分。我们可以将它抽离成一个函数：</p><pre><code class=\"language-rust\">fn process(reader: BufReader&lt;File&gt;)\n</code></pre><p>当然，从接口的角度来说，这个 process 函数定义得太死，如果不是从 File 中取数据，改天需求变了，也需要支持从 stdio 中取数据呢？就需要改动这个接口了。</p><p>所以可以<strong>使用泛型</strong>：</p><pre><code class=\"language-rust\">fn process&lt;R: Read&gt;(reader: BufReader&lt;R&gt;)\n</code></pre><p>泛型参数 R 只需要满足 std::io::Read trait 就可以。</p><p>这个接口虽然抽取出来了，但它依旧不可测，因为它内部直接 println!，把找到的数据直接打印出来了。我们当然可以把要打印的行放入一个 Vec&lt;String&gt; 返回，这样就可以测试了。</p><p>不过，这是为了测试而测试，<strong>更好的方式是把输出的对象从 Stdout 抽象成 Write</strong>。现在 process 的接口变为：</p><pre><code class=\"language-rust\">fn process&lt;R: Read, W: Write&gt;(reader: BufReader&lt;R&gt;, writer: &amp;mut Writer)\n</code></pre><p>这样，我们就可以使用实现了 Read trait 的 &amp;[u8] 作为输入，以及使用实现了 Write trait 的 Vec&lt;u8&gt;作为输出，进行测试了。而在 rgrep 的实现时，我们用 File 作为输入，Stdout 作为输出。这样既满足了需求，让核心逻辑可测，还让接口足够灵活，可以适配任何实现了 Read 的输入以及实现了 Write 的输出。</p><p>好，有了这个思路，来看看我是怎么写这个 rgrep 的，供你参考。</p><p>首先 <code>cargo new rgrep</code> 创建一个新的项目。在 Cargo.toml 中，添加如下依赖：</p><pre><code class=\"language-rust\">[dependencies]\nanyhow = \"1\"\nclap = \"3.0.0-beta.4\" # 我们需要使用最新的 3.0.0-beta.4 或者更高版本\ncolored = \"2\"\nglob = \"0.3\"\nitertools = \"0.10\"\nrayon = \"1\"\nregex = \"1\"\nthiserror = \"1\"\n</code></pre><p>对于处理命令行的 clap，我们需要 3.0 的版本。不要在意 VS Code 插件提示你最新版本是 2.33，那是因为 beta 不算正式版本。</p><p>然后创建 src/lib.rs 和 src/error.rs，在 <a href=\"http://error.rs\">error.rs</a> 中添加一些错误定义：</p><pre><code class=\"language-rust\">use thiserror::Error;\n\n#[derive(Error, Debug)]\npub enum GrepError {\n    #[error(\"Glob pattern error\")]\n    GlobPatternError(#[from] glob::PatternError),\n    #[error(\"Regex pattern error\")]\n    RegexPatternError(#[from] regex::Error),\n    #[error(\"I/O error\")]\n    IoError(#[from] std::io::Error),\n}\n</code></pre><p>它们都是需要进行转换的错误。thiserror 能够通过宏帮我们完成错误类型的转换。</p><p>在 src/lib.rs 中，添入如下代码：</p><pre><code class=\"language-rust\">use clap::{AppSettings, Clap};\nuse colored::*;\nuse itertools::Itertools;\nuse rayon::iter::{IntoParallelIterator, ParallelIterator};\nuse regex::Regex;\nuse std::{\n    fs::File,\n    io::{self, BufRead, BufReader, Read, Stdout, Write},\n    ops::Range,\n    path::Path,\n};\n\nmod error;\npub use error::GrepError;\n\n/// 定义类型，这样，在使用时可以简化复杂类型的书写\npub type StrategyFn&lt;W, R&gt; = fn(&amp;Path, BufReader&lt;R&gt;, &amp;Regex, &amp;mut W) -&gt; Result&lt;(), GrepError&gt;;\n\n/// 简化版本的 grep，支持正则表达式和文件通配符\n#[derive(Clap, Debug)]\n#[clap(version = \"1.0\", author = \"Tyr Chen &lt;tyr@chen.com&gt;\")]\n#[clap(setting = AppSettings::ColoredHelp)]\npub struct GrepConfig {\n    /// 用于查找的正则表达式\n    pattern: String,\n    /// 文件通配符\n    glob: String,\n}\n\nimpl GrepConfig {\n    /// 使用缺省策略来查找匹配\n    pub fn match_with_default_strategy(&amp;self) -&gt; Result&lt;(), GrepError&gt; {\n        self.match_with(default_strategy)\n    }\n\n    /// 使用某个策略函数来查找匹配\n    pub fn match_with(&amp;self, strategy: StrategyFn&lt;Stdout, File&gt;) -&gt; Result&lt;(), GrepError&gt; {\n        let regex = Regex::new(&amp;self.pattern)?;\n        // 生成所有符合通配符的文件列表\n        let files: Vec&lt;_&gt; = glob::glob(&amp;self.glob)?.collect();\n        // 并行处理所有文件\n        files.into_par_iter().for_each(|v| {\n            if let Ok(filename) = v {\n                if let Ok(file) = File::open(&amp;filename) {\n                    let reader = BufReader::new(file);\n                    let mut stdout = io::stdout();\n\n                    if let Err(e) = strategy(filename.as_path(), reader, &amp;regex, &amp;mut stdout) {\n                        println!(\"Internal error: {:?}\", e);\n                    }\n                }\n            }\n        });\n        Ok(())\n    }\n}\n\n/// 缺省策略，从头到尾串行查找，最后输出到 writer\npub fn default_strategy&lt;W: Write, R: Read&gt;(\n    path: &amp;Path,\n    reader: BufReader&lt;R&gt;,\n    pattern: &amp;Regex,\n    writer: &amp;mut W,\n) -&gt; Result&lt;(), GrepError&gt; {\n    let matches: String = reader\n        .lines()\n        .enumerate()\n        .map(|(lineno, line)| {\n            line.ok()\n                .map(|line| {\n                    pattern\n                        .find(&amp;line)\n                        .map(|m| format_line(&amp;line, lineno + 1, m.range()))\n                })\n                .flatten()\n        })\n        .filter_map(|v| v.ok_or(()).ok())\n        .join(\"\\n\");\n\n    if !matches.is_empty() {\n        writer.write(path.display().to_string().green().as_bytes())?;\n        writer.write(b\"\\n\")?;\n        writer.write(matches.as_bytes())?;\n        writer.write(b\"\\n\")?;\n    }\n\n    Ok(())\n}\n\n/// 格式化输出匹配的行，包含行号、列号和带有高亮的第一个匹配项\npub fn format_line(line: &amp;str, lineno: usize, range: Range&lt;usize&gt;) -&gt; String {\n    let Range { start, end } = range;\n    let prefix = &amp;line[..start];\n    format!(\n        \"{0: &gt;6}:{1: &lt;3} {2}{3}{4}\",\n        lineno.to_string().blue(),\n        // 找到匹配项的起始位置，注意对汉字等非 ascii 字符，我们不能使用 prefix.len()\n        // 这是一个 O(n) 的操作，会拖累效率，这里只是为了演示的效果\n        (prefix.chars().count() + 1).to_string().cyan(),\n        prefix,\n        &amp;line[start..end].red(),\n        &amp;line[end..]\n    )\n}\n</code></pre><p>和刚才的思路稍有不同的是，process 函数叫 default_strategy()。另外我们<strong>为 GrepConfig 提供了两个方法</strong>，一个是 match_with_default_strategy()，另一个是 match_with()，调用者可以自己传入一个函数或者闭包，对给定的 BufReader 进行处理。这是一种常用的解耦的处理方法。</p><p>在 src/lib.rs 里，继续撰写单元测试：</p><pre><code class=\"language-rust\">#[cfg(test)]\nmod tests {\n\n    use super::*;\n\n    #[test]\n    fn format_line_should_work() {\n        let result = format_line(\"Hello, Tyr~\", 1000, 7..10);\n        let expected = format!(\n            \"{0: &gt;6}:{1: &lt;3} Hello, {2}~\",\n            \"1000\".blue(),\n            \"7\".cyan(),\n            \"Tyr\".red()\n        );\n        assert_eq!(result, expected);\n    }\n\n    #[test]\n    fn default_strategy_should_work() {\n        let path = Path::new(\"src/main.rs\");\n        let input = b\"hello world!\\nhey Tyr!\";\n        let reader = BufReader::new(&amp;input[..]);\n        let pattern = Regex::new(r\"he\\\\w+\").unwrap();\n        let mut writer = Vec::new();\n        default_strategy(path, reader, &amp;pattern, &amp;mut writer).unwrap();\n        let result = String::from_utf8(writer).unwrap();\n        let expected = [\n            String::from(\"src/main.rs\"),\n            format_line(\"hello world!\", 1, 0..5),\n            format_line(\"hey Tyr!\\n\", 2, 0..3),\n        ];\n\n        assert_eq!(result, expected.join(\"\\n\"));\n    }\n}\n</code></pre><p>你可以重点关注测试是如何使用 default_strategy() 函数，而 match_with() 方法又是如何使用它的。运行 <code>cargo test</code>，两个测试都能通过。</p><p>最后，在 src/main.rs 中添加命令行处理逻辑：</p><pre><code class=\"language-rust\">use anyhow::Result;\nuse clap::Clap;\nuse rgrep::*;\n\nfn main() -&gt; Result&lt;()&gt; {\n    let config: GrepConfig = GrepConfig::parse();\n    config.match_with_default_strategy()?;\n\n    Ok(())\n}\n</code></pre><p>在命令行下运行：<code>cargo run --quiet -- \"Re[^\\\\s]+\" \"src/*.rs\"</code> ，会得到类似如下输出。注意，文件输出的顺序可能不完全一样，因为 rayon 是多个线程并行执行的。<br>\n<img src=\"https://static001.geekbang.org/resource/image/79/aa/79c56964b55dede4ce0ec7c5c4cfe9aa.png?wh=1920x797\" alt=\"图片\"></p><h2>小结</h2><p>rgrep 是一个简单的命令行工具，仅仅写了上百行代码，就完成了一个性能相当不错的简化版 grep。在不做复杂的接口设计时，我们可以不用生命周期，不用泛型，甚至不用太关心所有权，就可以写出非常类似脚本语言的代码。</p><p>从这个意义上讲，<strong>Rust 用来做一次性的、即用即抛型的代码，或者说，写个快速原型，也有用武之地</strong>；当我们需要更好的代码质量、更高的抽象度、更灵活的设计时，Rust 提供了足够多的工具，让我们将原型进化成更成熟的代码。</p><p>相信在做 rgrep 的过程中，你能感受到用 Rust 开发软件的愉悦。</p><p>今天我们就不布置思考题了，你可以多多体会KV server和rgrep工具的实现。恭喜你完成了Rust基础篇的学习，进度条过半，我们下节课进阶篇见。</p><p>欢迎你分享给身边的朋友，邀他一起讨论。</p><h3>延伸阅读</h3><p>在 YouTube 上，有一个新鲜出炉的视频：<a href=\"https://www.youtube.com/watch?v=rDoqT-a6UFg\">Visualizing memory layout of Rust’s data types</a>，用 40 分钟的时间，总结了我们前面基础篇二十讲里提到的主要数据结构的内存布局。我个人非常喜欢这个视频，因为它和我一直倡导的“厘清数据是如何在堆和栈上存储”的思路不谋而合，在这里也推荐给你。如果你想快速复习一下，查漏补缺，那么非常建议你花上一个小时时间仔细看一下这个视频。</p>","neighbors":{"left":{"article_title":"加餐｜期中测试：来写一个简单的grep命令行","id":425013},"right":{"article_title":"23｜类型系统：如何在实战中使用泛型编程？","id":427082}},"comments":[]}