{"id":111288,"title":"30 | 生产者消费者模式：电商库存设计优化","content":"<p>你好，我是刘超。</p><p>生产者消费者模式，在之前的一些案例中，我们是有使用过的，相信你有一定的了解。这个模式是一个十分经典的多线程并发协作模式，生产者与消费者是通过一个中间容器来解决强耦合关系，并以此来实现不同的生产与消费速度，从而达到缓冲的效果。</p><p>使用生产者消费者模式，可以提高系统的性能和吞吐量，今天我们就来看看该模式的几种实现方式，还有其在电商库存中的应用。</p><h2>Object的wait/notify/notifyAll实现生产者消费者</h2><p>在<a href=\"https://time.geekbang.org/column/article/102974\">第16讲</a>中，我就曾介绍过使用Object的wait/notify/notifyAll实现生产者消费者模式，这种方式是基于Object的wait/notify/notifyAll与对象监视器（Monitor）实现线程间的等待和通知。</p><p>还有，在<a href=\"https://time.geekbang.org/column/article/101244\">第12讲</a>中我也详细讲解过Monitor的工作原理，借此我们可以得知，这种方式实现的生产者消费者模式是基于内核来实现的，有可能会导致大量的上下文切换，所以性能并不是最理想的。</p><h2>Lock中Condition的await/signal/signalAll实现生产者消费者</h2><p>相对Object类提供的wait/notify/notifyAll方法实现的生产者消费者模式，我更推荐使用java.util.concurrent包提供的Lock &amp;&amp; Condition实现的生产者消费者模式。</p><!-- [[[read_end]]] --><p>在接口Condition类中定义了await/signal/signalAll 方法，其作用与Object的wait/notify/notifyAll方法类似，该接口类与显示锁Lock配合，实现对线程的阻塞和唤醒操作。</p><p>我在<a href=\"https://time.geekbang.org/column/article/101651\">第13讲</a>中详细讲到了显示锁，显示锁ReentrantLock或ReentrantReadWriteLock都是基于AQS实现的，而在AQS中有一个内部类ConditionObject实现了Condition接口。</p><p>我们知道AQS中存在一个同步队列（CLH队列），当一个线程没有获取到锁时就会进入到同步队列中进行阻塞，如果被唤醒后获取到锁，则移除同步队列。</p><p>除此之外，AQS中还存在一个条件队列，通过addWaiter方法，可以将await()方法调用的线程放入到条件队列中，线程进入等待状态。当调用signal以及signalAll 方法后，线程将会被唤醒，并从条件队列中删除，之后进入到同步队列中。条件队列是通过一个单向链表实现的，所以Condition支持多个等待队列。</p><p>由上可知，Lock中Condition的await/signal/signalAll实现的生产者消费者模式，是基于Java代码层实现的，所以在性能和扩展性方面都更有优势。</p><p>下面来看一个案例，我们通过一段代码来实现一个商品库存的生产和消费。</p><pre><code>public class LockConditionTest {\n\n\tprivate LinkedList&lt;String&gt; product = new LinkedList&lt;String&gt;();\n\n\tprivate int maxInventory = 10; // 最大库存\n\n\tprivate Lock lock = new ReentrantLock();// 资源锁\n\n\tprivate Condition condition = lock.newCondition();// 库存非满和非空条件\n\n\t/**\n\t * 新增商品库存\n\t * @param e\n\t */\n\tpublic void produce(String e) {\n\t\tlock.lock();\n\t\ttry {\n\t\t\twhile (product.size() == maxInventory) {\n\t\t\t\tcondition.await();\n\t\t\t}\n\n\t\t\tproduct.add(e);\n\t\t\tSystem.out.println(&quot;放入一个商品库存，总库存为：&quot; + product.size());\n\t\t\tcondition.signalAll();\n\n\t\t} catch (Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t} finally {\n\t\t\tlock.unlock();\n\t\t}\n\t}\n\n\t/**\n\t * 消费商品\n\t * @return\n\t */\n\tpublic String consume() {\n\t\tString result = null;\n\t\tlock.lock();\n\t\ttry {\n\t\t\twhile (product.size() == 0) {\n\t\t\t\tcondition.await();\n\t\t\t}\n\n\t\t\tresult = product.removeLast();\n\t\t\tSystem.out.println(&quot;消费一个商品，总库存为：&quot; + product.size());\n\t\t\tcondition.signalAll();\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tlock.unlock();\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * 生产者\n\t * @author admin\n\t *\n\t */\n\tprivate class Producer implements Runnable {\n\n\t\tpublic void run() {\n\t\t\tfor (int i = 0; i &lt; 20; i++) {\n\t\t\t\tproduce(&quot;商品&quot; + i);\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * 消费者\n\t * @author admin\n\t *\n\t */\n\tprivate class Customer implements Runnable {\n\n\t\tpublic void run() {\n\t\t\tfor (int i = 0; i &lt; 20; i++) {\n\t\t\t\tconsume();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\tLockConditionTest lc = new LockConditionTest();\n\t\tnew Thread(lc.new Producer()).start();\n\t\tnew Thread(lc.new Customer()).start();\n\t\tnew Thread(lc.new Producer()).start();\n\t\tnew Thread(lc.new Customer()).start();\n\n\t}\n}\n</code></pre><p>看完案例，请你思考下，我们对此还有优化的空间吗？</p><p>从代码中应该不难发现，生产者和消费者都在竞争同一把锁，而实际上两者没有同步关系，由于Condition能够支持多个等待队列以及不响应中断， 所以我们可以将生产者和消费者的等待条件和锁资源分离，从而进一步优化系统并发性能，代码如下：</p><pre><code>\tprivate LinkedList&lt;String&gt; product = new LinkedList&lt;String&gt;();\n\tprivate AtomicInteger inventory = new AtomicInteger(0);//实时库存\n\n\tprivate int maxInventory = 10; // 最大库存\n\n\tprivate Lock consumerLock = new ReentrantLock();// 资源锁\n\tprivate Lock productLock = new ReentrantLock();// 资源锁\n\n\tprivate Condition notEmptyCondition = consumerLock.newCondition();// 库存满和空条件\n\tprivate Condition notFullCondition = productLock.newCondition();// 库存满和空条件\n\n\t/**\n\t * 新增商品库存\n\t * @param e\n\t */\n\tpublic void produce(String e) {\n\t\tproductLock.lock();\n\t\ttry {\n\t\t\twhile (inventory.get() == maxInventory) {\n\t\t\t\tnotFullCondition.await();\n\t\t\t}\n\n\t\t\tproduct.add(e);\n\t\t\t\n\t\t\tSystem.out.println(&quot;放入一个商品库存，总库存为：&quot; + inventory.incrementAndGet());\n\t\t\t\n\t\t\tif(inventory.get()&lt;maxInventory) {\n\t\t\t\tnotFullCondition.signalAll();\n\t\t\t}\n\n\t\t} catch (Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t} finally {\n\t\t\tproductLock.unlock();\n\t\t}\n\t\t\n\t\tif(inventory.get()&gt;0) {\n\t\t\ttry {\n\t\t\t\tconsumerLock.lockInterruptibly();\n\t\t\t\tnotEmptyCondition.signalAll();\n\t\t\t} catch (InterruptedException e1) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te1.printStackTrace();\n\t\t\t}finally {\n\t\t\t\tconsumerLock.unlock();\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\t/**\n\t * 消费商品\n\t * @return\n\t */\n\tpublic String consume() {\n\t\tString result = null;\n\t\tconsumerLock.lock();\n\t\ttry {\n\t\t\twhile (inventory.get() == 0) {\n\t\t\t\tnotEmptyCondition.await();\n\t\t\t}\n\n\t\t\tresult = product.removeLast();\n\t\t\tSystem.out.println(&quot;消费一个商品，总库存为：&quot; + inventory.decrementAndGet());\n\t\t\t\n\t\t\tif(inventory.get()&gt;0) {\n\t\t\t\tnotEmptyCondition.signalAll();\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tconsumerLock.unlock();\n\t\t}\n\t\t\n\t\tif(inventory.get()&lt;maxInventory) {\n\t\t\t\n\t\t\ttry {\n\t\t\t\tproductLock.lockInterruptibly();\n\t\t\t\tnotFullCondition.signalAll();\n\t\t\t} catch (InterruptedException e1) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te1.printStackTrace();\n\t\t\t}finally {\n\t\t\t\tproductLock.unlock();\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\t/**\n\t * 生产者\n\t * @author admin\n\t *\n\t */\n\tprivate class Producer implements Runnable {\n\n\t\tpublic void run() {\n\t\t\tfor (int i = 0; i &lt; 20; i++) {\n\t\t\t\tproduce(&quot;商品&quot; + i);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * 消费者\n\t * @author admin\n\t *\n\t */\n\tprivate class Customer implements Runnable {\n\n\t\tpublic void run() {\n\t\t\tfor (int i = 0; i &lt; 20; i++) {\n\t\t\t\tconsume();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\tLockConditionTest2 lc = new LockConditionTest2();\n\t\tnew Thread(lc.new Producer()).start();\n\t\tnew Thread(lc.new Customer()).start();\n\n\t}\n}\n</code></pre><p>我们分别创建  productLock 以及  consumerLock  两个锁资源，前者控制生产者线程并行操作，后者控制消费者线程并发运行；同时也设置两个条件变量，一个是notEmptyCondition，负责控制消费者线程状态，一个是notFullCondition，负责控制生产者线程状态。这样优化后，可以减少消费者与生产者的竞争，实现两者并发执行。</p><p>我们这里是基于LinkedList来存取库存的，虽然LinkedList是非线程安全，但我们新增是操作头部，而消费是操作队列的尾部，理论上来说没有线程安全问题。而库存的实际数量inventory是基于AtomicInteger（CAS锁）线程安全类实现的，既可以保证原子性，也可以保证消费者和生产者之间是可见的。</p><h2>BlockingQueue实现生产者消费者</h2><p>相对前两种实现方式，BlockingQueue实现是最简单明了的，也是最容易理解的。</p><p>因为BlockingQueue是线程安全的，且从队列中获取或者移除元素时，如果队列为空，获取或移除操作则需要等待，直到队列不为空；同时，如果向队列中添加元素，假设此时队列无可用空间，添加操作也需要等待。所以BlockingQueue非常适合用来实现生产者消费者模式。还是以一个案例来看下它的优化，代码如下：</p><pre><code>public class BlockingQueueTest {\n\n\tprivate int maxInventory = 10; // 最大库存\n\n\tprivate BlockingQueue&lt;String&gt; product = new LinkedBlockingQueue&lt;&gt;(maxInventory);//缓存队列\n\n\t/**\n\t * 新增商品库存\n\t * @param e\n\t */\n\tpublic void produce(String e) {\n\t\ttry {\n\t\t\tproduct.put(e);\n\t\t\tSystem.out.println(&quot;放入一个商品库存，总库存为：&quot; + product.size());\n\t\t} catch (InterruptedException e1) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te1.printStackTrace();\n\t\t}\n\t}\n\n\t/**\n\t * 消费商品\n\t * @return\n\t */\n\tpublic String consume() {\n\t\tString result = null;\n\t\ttry {\n\t\t\tresult = product.take();\n\t\t\tSystem.out.println(&quot;消费一个商品，总库存为：&quot; + product.size());\n\t\t} catch (InterruptedException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * 生产者\n\t * @author admin\n\t *\n\t */\n\tprivate class Producer implements Runnable {\n\n\t\tpublic void run() {\n\t\t\tfor (int i = 0; i &lt; 20; i++) {\n\t\t\t\tproduce(&quot;商品&quot; + i);\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * 消费者\n\t * @author admin\n\t *\n\t */\n\tprivate class Customer implements Runnable {\n\n\t\tpublic void run() {\n\t\t\tfor (int i = 0; i &lt; 20; i++) {\n\t\t\t\tconsume();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\tBlockingQueueTest lc = new BlockingQueueTest();\n\t\tnew Thread(lc.new Producer()).start();\n\t\tnew Thread(lc.new Customer()).start();\n\t\tnew Thread(lc.new Producer()).start();\n\t\tnew Thread(lc.new Customer()).start();\n\n\t}\n}\n</code></pre><p>在这个案例中，我们创建了一个LinkedBlockingQueue，并设置队列大小。之后我们创建一个消费方法consume()，方法里面调用LinkedBlockingQueue中的take()方法，消费者通过该方法获取商品，当队列中商品数量为零时，消费者将进入等待状态；我们再创建一个生产方法produce()，方法里面调用LinkedBlockingQueue中的put()方法，生产方通过该方法往队列中放商品，如果队列满了，生产者就将进入等待状态。</p><h2>生产者消费者优化电商库存设计</h2><p>了解完生产者消费者模式的几种常见实现方式，接下来我们就具体看看该模式是如何优化电商库存设计的。</p><p>电商系统中经常会有抢购活动，在这类促销活动中，抢购商品的库存实际是存在库存表中的。为了提高抢购性能，我们通常会将库存存放在缓存中，通过缓存中的库存来实现库存的精确扣减。在提交订单并付款之后，我们还需要再去扣除数据库中的库存。如果遇到瞬时高并发，我们还都去操作数据库的话，那么在单表单库的情况下，数据库就很可能会出现性能瓶颈。</p><p>而我们库存表如果要实现分库分表，势必会增加业务的复杂度。试想一个商品的库存分别在不同库的表中，我们在扣除库存时，又该如何判断去哪个库中扣除呢？</p><p>如果随意扣除表中库存，那么就会出现有些表已经扣完了，有些表中还有库存的情况，这样的操作显然是不合理的，此时就需要额外增加逻辑判断来解决问题。</p><p>在不分库分表的情况下，为了提高订单中扣除库存业务的性能以及吞吐量，我们就可以采用生产者消费者模式来实现系统的性能优化。</p><p>创建订单等于生产者，存放订单的队列则是缓冲容器，而从队列中消费订单则是数据库扣除库存操作。其中存放订单的队列可以极大限度地缓冲高并发给数据库带来的压力。</p><p>我们还可以基于消息队列来实现生产者消费者模式，如今RabbitMQ、RocketMQ都实现了事务，我们只需要将订单通过事务提交到MQ中，扣除库存的消费方只需要通过消费MQ来逐步操作数据库即可。</p><h2>总结</h2><p>使用生产者消费者模式来缓冲高并发数据库扣除库存压力，类似这样的例子其实还有很多。</p><p>例如，我们平时使用消息队列来做高并发流量削峰，也是基于这个原理。抢购商品时，如果所有的抢购请求都直接进入判断是否有库存和冻结缓存库存等逻辑业务中，由于这些逻辑业务操作会增加资源消耗，就可能会压垮应用服务。此时，为了保证系统资源使用的合理性，我们可以通过一个消息队列来缓冲瞬时的高并发请求。</p><p>生产者消费者模式除了可以做缓冲优化系统性能之外，它还可以应用在处理一些执行任务时间比较长的场景中。</p><p>例如导出报表业务，用户在导出一种比较大的报表时，通常需要等待很长时间，这样的用户体验是非常差的。通常我们可以固定一些报表内容，比如用户经常需要在今天导出昨天的销量报表，或者在月初导出上个月的报表，我们就可以提前将报表导出到本地或内存中，这样用户就可以在很短的时间内直接下载报表了。</p><h2>思考题</h2><p>我们可以用生产者消费者模式来实现瞬时高并发的流量削峰，然而这样做虽然缓解了消费方的压力，但生产方则会因为瞬时高并发，而发生大量线程阻塞。面对这样的情况，你知道有什么方式可以优化线程阻塞所带来的性能问题吗？</p><p>期待在留言区看到你的见解。也欢迎你点击“请朋友读”，把今天的内容分享给身边的朋友，邀请他一起讨论。</p><p></p>","comments":[{"had_liked":false,"id":119210,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1564537569,"is_pvip":false,"replies":[{"id":"44000","content":"看来有实战经验👍🏻","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564713010,"ip_address":"","comment_id":119210,"utype":1}],"discussion_count":3,"race_medal":0,"score":"104643752673","product_id":100028001,"comment_content":"1.生产消费模式用信号量也能玩。<br>2.生产者这边的优化思路应该是提高响应速度和增加资源。提高响应速度就是尽量降低生产逻辑的耗时，增加资源就是根据业务量为该生产者单独线程池并调整线程数。至于限流和令牌桶感觉都是降级处理，属于规避阻塞场景而非解决阻塞场景，应该不在答案范围内吧。<br>3.对于进程内生产消费模式，大规模，量大的数据本身就不适合，毕竟内存空间有限，消息堆积有限，所以量级达到一定指标就采用跨进程方式，比如kafka和rocketmq。同时，进程内生产消费模式，异常要处理好，不然可能会出现消息堆积和脏数据，毕竟mq的消费确认和重试机制都是开箱即用，而我们得自己实现和把关。","like_count":24,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460788,"discussion_content":"看来有实战经验👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564713010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134861,"avatar":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","nickname":"James","note":"","ucode":"48B0F2A334D1C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350458,"discussion_content":"6","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613882521,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015483,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","nickname":"程序员小跃","note":"","ucode":"25BB96E0791A60","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":323251,"discussion_content":"每次评论区看到老哥的留言，就很享受啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604907256,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118779,"user_name":"杨俊","can_delete":false,"product_type":"c1","uid":1158214,"ip_address":"","ucode":"3CAE634618D924","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/46/7e24bad6.jpg","comment_is_top":false,"comment_ctime":1564447140,"is_pvip":true,"replies":[{"id":"43740","content":"对的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564542177,"ip_address":"","comment_id":118779,"utype":1}],"discussion_count":2,"race_medal":0,"score":"74578891172","product_id":100028001,"comment_content":"我的理解是库存放缓存，用户提交订单在缓存扣减库存，用户端能够快速返回显示订单提交成功并支付，然后只有支付成功之后才会利用队列实际的扣减数据库库存是吗？要是不支付会在缓存补回库存吧，应该会限时支付吧","like_count":17,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460572,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564542177,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2410612,"avatar":"","nickname":"Geek_abe867","note":"","ucode":"4F562F79520464","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342800,"discussion_content":"这样如何控制超卖呢？数据库的缓存没有扣除","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610815368,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119036,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1564492062,"is_pvip":false,"replies":[{"id":"43733","content":"大家都一致想到了限流，限流是非常必要的，无论我们的程序优化的如何，还是有上限的，限流则是一种兜底策略。<br><br>除了这个，我们还可以使用协程来优化线程由于阻塞等待带来的上下文切换性能问题，可以回顾第19讲，我们也用协程实现过生产者消费者模式。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564541134,"ip_address":"","comment_id":119036,"utype":1}],"discussion_count":5,"race_medal":0,"score":"40219197726","product_id":100028001,"comment_content":"在网关层中把请求放入到mq中，后端服务从消费队列中消费消息并处理；或者用有固定容量的消费队列的令牌桶，令牌发生器预估预计的处理能力，匀速生产放入令牌队列中，满了直接丢弃，网关收到请求之后消费一个令牌，获得令牌的请求才能进行后端秒杀请求，反之直接返回秒杀失败","like_count":9,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460720,"discussion_content":"大家都一致想到了限流，限流是非常必要的，无论我们的程序优化的如何，还是有上限的，限流则是一种兜底策略。\n\n除了这个，我们还可以使用协程来优化线程由于阻塞等待带来的上下文切换性能问题，可以回顾第19讲，我们也用协程实现过生产者消费者模式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564541134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1211223,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","nickname":"QQ怪","note":"","ucode":"1A39B8433D9208","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3505,"discussion_content":"学以致用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564541184,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1364034,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d0/42/6fd01fb9.jpg","nickname":"我已经设置了昵称","note":"","ucode":"ED672C5EBDBDC4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3485,"discussion_content":"哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564533489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1259218,"avatar":"https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg","nickname":"发条橙子 。","note":"","ucode":"ED076F4534FFED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3476,"discussion_content":"老哥 你这是把mq老师的专栏内容直接搬过来了吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564527774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1157430,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a9/36/972f7abf.jpg","nickname":"木刻","note":"","ucode":"0A3226FEE3983B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1259218,"avatar":"https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg","nickname":"发条橙子 。","note":"","ucode":"ED076F4534FFED","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3545,"discussion_content":"哈哈哈，我说怎么看着这么眼熟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564566054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3476,"ip_address":""},"score":3545,"extra":""}]}]},{"had_liked":false,"id":265821,"user_name":"水浴清风","can_delete":false,"product_type":"c1","uid":1133926,"ip_address":"","ucode":"36EF5179E6F952","user_header":"https://static001.geekbang.org/account/avatar/00/11/4d/66/28742ad4.jpg","comment_is_top":false,"comment_ctime":1607043965,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14491945853","product_id":100028001,"comment_content":"生产者端的优化：<br>1、减少处理逻辑，加快响应速度<br>2、对队列增加分片<br>3、增加限流<br>4、协程","like_count":3},{"had_liked":false,"id":119304,"user_name":"JasonK","can_delete":false,"product_type":"c1","uid":1184135,"ip_address":"","ucode":"14BB7522FAECE7","user_header":"https://static001.geekbang.org/account/avatar/00/12/11/87/43744994.jpg","comment_is_top":false,"comment_ctime":1564555323,"is_pvip":false,"replies":[{"id":"44488","content":"导致CPU飙升只是一个性能的直接表现，是不是有对象一直在创建，所以导致一直在GC。建议打开dump日志查看具体的内存使用情况以及对象的创建分布情况。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1565056905,"ip_address":"","comment_id":119304,"utype":1}],"discussion_count":3,"race_medal":0,"score":"14449457211","product_id":100028001,"comment_content":"你好，刘老师，最近生产上一个服务，老是半夜cpu飙升，导致服务死掉，排查问题看了下，都是GC task thread#15 (ParallelGC） 线程占用CPU资源，这是为什么？而且同样的服务我布了两台机器，一台服务会死掉，一台不会。请老师解惑。","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460836,"discussion_content":"导致CPU飙升只是一个性能的直接表现，是不是有对象一直在创建，所以导致一直在GC。建议打开dump日志查看具体的内存使用情况以及对象的创建分布情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565056905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1542987,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","nickname":"行则将至","note":"","ucode":"DB972F2DF059C4","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":12619,"discussion_content":"按照老师说的做就行。把GC日志dump下来，然后使用Eclipse的MAT工具查看，基本上就定位个差不多","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568556085,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1116864,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0a/c0/401c240e.jpg","nickname":"撒旦的堕落","note":"","ucode":"15F6AA41EE556F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3546,"discussion_content":"会不会是定时任务的原因","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564566085,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119044,"user_name":"明翼","can_delete":false,"product_type":"c1","uid":1068361,"ip_address":"","ucode":"E77F86BEB3D5C1","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/49/28e73b9c.jpg","comment_is_top":false,"comment_ctime":1564492981,"is_pvip":false,"replies":[{"id":"43731","content":"这里同步更新下，新增了以下代码作为实时库存：<br>private AtomicInteger inventory = new AtomicInteger(0);<br><br>我们这里是基于LinkedList来存取库存的，虽然LinkedList是非线程安全，但我们新增是操作头部，而消费则是操作队列的尾部，理论上来说没有线程安全问题。而库存的实际数量inventory是基于AtomicInteger（CAS锁）线程安全类实现，即可以保证原子性，也可以保证消费者和生产者之间是可见的。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564540568,"ip_address":"","comment_id":119044,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14449394869","product_id":100028001,"comment_content":"老师，生产者和消费者的锁分开没问题吗？都是用的同一个队列？","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460723,"discussion_content":"这里同步更新下，新增了以下代码作为实时库存：\nprivate AtomicInteger inventory = new AtomicInteger(0);\n\n我们这里是基于LinkedList来存取库存的，虽然LinkedList是非线程安全，但我们新增是操作头部，而消费则是操作队列的尾部，理论上来说没有线程安全问题。而库存的实际数量inventory是基于AtomicInteger（CAS锁）线程安全类实现，即可以保证原子性，也可以保证消费者和生产者之间是可见的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564540568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304082,"discussion_content":"相当于是俩队列","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599464302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118768,"user_name":"罗洲","can_delete":false,"product_type":"c1","uid":1263417,"ip_address":"","ucode":"68133E38A25C17","user_header":"https://static001.geekbang.org/account/avatar/00/13/47/39/0ce1aa62.jpg","comment_is_top":false,"comment_ctime":1564446496,"is_pvip":false,"replies":[{"id":"43741","content":"赞，很好的参考例子","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564542235,"ip_address":"","comment_id":118768,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14449348384","product_id":100028001,"comment_content":"生产方的高并发优化，我们可以参考下tomcat的设计，tomcat设计了线程池来进行请求接收，有最小线程数，最大线程数，同时还有一个有界的工作队列，来接收超过线程数的请求，当工作队列满了后可以选择拒绝或者丢弃处理。","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460565,"discussion_content":"赞，很好的参考例子","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564542235,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1259218,"avatar":"https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg","nickname":"发条橙子 。","note":"","ucode":"ED076F4534FFED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3477,"discussion_content":"结合了tomcat专栏的知识 是个好方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564527982,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118826,"user_name":"撒旦的堕落","can_delete":false,"product_type":"c1","uid":1116864,"ip_address":"","ucode":"15F6AA41EE556F","user_header":"https://static001.geekbang.org/account/avatar/00/11/0a/c0/401c240e.jpg","comment_is_top":false,"comment_ctime":1564450118,"is_pvip":false,"replies":[{"id":"43739","content":"可以的，很通用的一种解决方案","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564541676,"ip_address":"","comment_id":118826,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10154384710","product_id":100028001,"comment_content":"网关与服务之间增加令牌桶  或者mq 以保护秒杀服务不会被大的流量压垮 可以么","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460600,"discussion_content":"可以的，很通用的一种解决方案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564541676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341312,"user_name":"姬","can_delete":false,"product_type":"c1","uid":1284730,"ip_address":"","ucode":"968079E564FD2F","user_header":"https://static001.geekbang.org/account/avatar/00/13/9a/7a/dd08bc09.jpg","comment_is_top":false,"comment_ctime":1649515920,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5944483216","product_id":100028001,"comment_content":"removeFirst()，给有缘人。","like_count":1},{"had_liked":false,"id":270811,"user_name":"惘 闻","can_delete":false,"product_type":"c1","uid":1181650,"ip_address":"","ucode":"C5909F034BF072","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","comment_is_top":false,"comment_ctime":1609288003,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5904255299","product_id":100028001,"comment_content":"我们会把多个报表任务都一并放到缓冲队列中由消费者程序异步完成,这样不会同时执行占用系统大量性能.也不需要操作人逐个等待.","like_count":1},{"had_liked":false,"id":142688,"user_name":"2102","can_delete":false,"product_type":"c1","uid":1070298,"ip_address":"","ucode":"A67068F2A3157E","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/da/e2e5ddf7.jpg","comment_is_top":false,"comment_ctime":1571458867,"is_pvip":false,"replies":[{"id":"55136","content":"增加消费者是一种方式","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1571471611,"ip_address":"","comment_id":142688,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5866426163","product_id":100028001,"comment_content":"增加消费者","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471228,"discussion_content":"增加消费者是一种方式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571471611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132940,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1568279882,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5863247178","product_id":100028001,"comment_content":"课后思考及问题<br>我们可以用生产者消费者模式来实现瞬时高并发的流量削峰，然而这样做虽然缓解了消费方的压力，但生产方则会因为瞬时高并发，而发生大量线程阻塞。面对这样的情况，你知道有什么方式可以优化线程阻塞所带来的性能问题吗？<br>1：减少生产者的流量压力——限流<br>2：视业务场景而定判断是否可以拒绝部分多余流量<br>3：使用工业级消息队列中间件<br>4：加缓存<br>5：加机器","like_count":1},{"had_liked":false,"id":122196,"user_name":"怎☞劰☜叻","can_delete":false,"product_type":"c1","uid":1221562,"ip_address":"","ucode":"1941131ECD1A15","user_header":"https://static001.geekbang.org/account/avatar/00/12/a3/ba/89adac9b.jpg","comment_is_top":false,"comment_ctime":1565315141,"is_pvip":false,"replies":[{"id":"50398","content":"建议再等等官方的协成组件，或改用go实现，目前Java的一些第三方开源组件的生产环境的实践以及性能验证有待考验，如果不介意当小白鼠，也可以试试这些第三方协成组件。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1567948176,"ip_address":"","comment_id":122196,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5860282437","product_id":100028001,"comment_content":"老师，我看到你上面说用协程来优化！我们这边有个服务属于业务网关，要聚合多个下有的数据，涉及大量的网络io，之前是使用多线程并行调用多个下有，现在发现线程越来越多，遇到了瓶颈！希望用协程来改进方案～但是我在网上找到的一些java协程开源组件，文档和生态都不是很健全，希望老师能给出一些建议～ 非常感谢","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462143,"discussion_content":"建议再等等官方的协成组件，或改用go实现，目前Java的一些第三方开源组件的生产环境的实践以及性能验证有待考验，如果不介意当小白鼠，也可以试试这些第三方协成组件。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567948176,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120107,"user_name":"一个卖火柴的老男人","can_delete":false,"product_type":"c1","uid":1181265,"ip_address":"","ucode":"1227638C457F49","user_header":"https://static001.geekbang.org/account/avatar/00/12/06/51/1d24ead6.jpg","comment_is_top":false,"comment_ctime":1564793127,"is_pvip":false,"replies":[{"id":"71182","content":"可行","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1583158171,"ip_address":"","comment_id":120107,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5859760423","product_id":100028001,"comment_content":"商品从数据库压入redis<br>缓存。<br>同时库存压入redis，用商品ID作为key，用list模拟队列【1001，1001，1001】用商品🆔做队列元素，100件库存，那就存100个🆔在队列中，扣库存的时候，判断队列大小，可以防止超卖。所有都是靠redis的单线程原子操作保证，可行不","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461201,"discussion_content":"可行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583158171,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1014665,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/89/34f2cbcc.jpg","nickname":"杨宇","note":"","ucode":"EB74DF6E269F03","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":36665,"discussion_content":"Redis自带减一的方法，用数字岂不是更好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571401285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119047,"user_name":"nightmare","can_delete":false,"product_type":"c1","uid":1056314,"ip_address":"","ucode":"EF2E51C2122A86","user_header":"https://static001.geekbang.org/account/avatar/00/10/1e/3a/5b21c01c.jpg","comment_is_top":false,"comment_ctime":1564493131,"is_pvip":false,"replies":[{"id":"43732","content":"限流是一种方式，线程池其实也是一种限流手段。我们在之前协程这一讲中，其实也用协程代替线程实现了生产者消费者模式，这也不乏是一种优化方式。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564540877,"ip_address":"","comment_id":119047,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5859460427","product_id":100028001,"comment_content":"可以在网关通过令牌桶算法限流，真正执行的生产者一方使用线程池来优化","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460726,"discussion_content":"限流是一种方式，线程池其实也是一种限流手段。我们在之前协程这一讲中，其实也用协程代替线程实现了生产者消费者模式，这也不乏是一种优化方式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564540877,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":356926,"user_name":"吟游雪人","can_delete":false,"product_type":"c1","uid":1063805,"ip_address":"上海","ucode":"C432C9577B420C","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/7d/6376926b.jpg","comment_is_top":false,"comment_ctime":1662708442,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662708442","product_id":100028001,"comment_content":"在不满也不空的情况下，2把锁相当于是并行操作LinkedList，确定不会抛出ConcurrentModificationException么？<br><br>加上private AtomicInteger inventory = new AtomicInteger(0);可以看出作者是想用这个来保证多线程的可见性，但是这不能保证并发条件下的竞争问题。比如生产者里的if(inventory.get()&gt;0) 这个判断，就有可能因为消费者在消费导致判断后，实际上inventory.get() 会等于0<br><br>感觉示例代码有很大的线程安全隐患。正确的做法应该是用一个锁，多个condition的方式实现。","like_count":0},{"had_liked":false,"id":301895,"user_name":"平民人之助","can_delete":false,"product_type":"c1","uid":2658705,"ip_address":"","ucode":"5CCEC0BAC08AEC","user_header":"https://static001.geekbang.org/account/avatar/00/28/91/91/428a27a3.jpg","comment_is_top":false,"comment_ctime":1625964436,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625964436","product_id":100028001,"comment_content":"用Asyn和线程池做资源把控，实际上入口应该就做好限流操作，任何系统都不可能对付所有的洪峰流量做反应。","like_count":0},{"had_liked":false,"id":270809,"user_name":"惘 闻","can_delete":false,"product_type":"c1","uid":1181650,"ip_address":"","ucode":"C5909F034BF072","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","comment_is_top":false,"comment_ctime":1609287819,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609287819","product_id":100028001,"comment_content":"通常我们可以固定一些报表内容，比如用户经常需要在今天导出昨天的销量报表，或者在月初导出上个月的报表，我们就可以提前将报表导出到本地或内存中，这样用户就可以在很短的时间内直接下载报表了。<br>老师这里说的这个案例和生产者消费者有联系吗?看起来只需要提前生成就可以了.做一个定时任务,不就可以在用户查看之前固定实现完成吗.为什么这里会用到生产者和消费者呢","like_count":0},{"had_liked":false,"id":189276,"user_name":"冬风向左吹","can_delete":false,"product_type":"c1","uid":1066928,"ip_address":"","ucode":"376C45C5134F93","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/b0/a9b77a1e.jpg","comment_is_top":false,"comment_ctime":1584494782,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584494782","product_id":100028001,"comment_content":"老师，生产者和消费者的等待条件和锁资源分离的那个例子中，生产者放入一个元素后，为什么不是执行notEmptyCondition.signaAll通知消费者呢？？？","like_count":0},{"had_liked":false,"id":158657,"user_name":"奋斗的小白鼠","can_delete":false,"product_type":"c1","uid":1743483,"ip_address":"","ucode":"752BB901FFB7CE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/icHicAP9M4M4DIjAvlj5FDdFxIeA0pR3J15QdvVjXQXbznwunDN8OvrYqnsFchtBTNrZCCfGTE2RpPzIxjkvFAKg/132","comment_is_top":false,"comment_ctime":1575428585,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575428585","product_id":100028001,"comment_content":"老师，您那个第二个生产者消费者模式实现我运行了会出现线程安全问题的，而且线程还一直阻塞停止不了运行，我感觉您的本意是想实现和LinkedBlockingQueue一样的模式，两把锁，您测试时没出现问题过吗？","like_count":0},{"had_liked":false,"id":154915,"user_name":"neohope","can_delete":false,"product_type":"c1","uid":1043475,"ip_address":"","ucode":"C0268F6E7E2B6E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","comment_is_top":false,"comment_ctime":1574596059,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574596059","product_id":100028001,"comment_content":"看大家都提到了用令牌筒和MQ做限流和熔断。其实当并发量更大时，还有一种方式，但要牺牲一定的公平性。首先根据一些相对公平的规则，事先做一次资源分配。也就是对用户分组，预先分配一部分资源，每组用户抢夺组内资源。","like_count":0},{"had_liked":false,"id":151020,"user_name":"考休","can_delete":false,"product_type":"c1","uid":1053955,"ip_address":"","ucode":"968DFC00D6D0CF","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/03/c0fe1dbf.jpg","comment_is_top":false,"comment_ctime":1573643831,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573643831","product_id":100028001,"comment_content":"请问老师，电商库存的并发问题是否可以使用CountDownLatch来实现呢，感觉实现起来更简单，毕竟库存只是一个数量，不必用一个数组来表示。","like_count":0},{"had_liked":false,"id":135524,"user_name":"白中白","can_delete":false,"product_type":"c1","uid":1616954,"ip_address":"","ucode":"95F9DABEBEFAAA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ODqoBdTKsL1jW4m72BZ0ibECEtWPq0N1tAIlbzjsq6mcJiavT2CKtx0ejpIqQdHbRXdMWH0I1jpI2ZiawFIkF1icsQ/132","comment_is_top":false,"comment_ctime":1569203386,"is_pvip":false,"replies":[{"id":"53074","content":"LinkedList是非线程安全容器，存在线程安全问题的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1569981587,"ip_address":"","comment_id":135524,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569203386","product_id":100028001,"comment_content":"LinkedList 的 add 和 removeLast 方法都有可能操作 first 引用，存在线程安全问题吧？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468230,"discussion_content":"LinkedList是非线程安全容器，存在线程安全问题的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569981587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133404,"user_name":"行则将至","can_delete":false,"product_type":"c1","uid":1542987,"ip_address":"","ucode":"DB972F2DF059C4","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","comment_is_top":false,"comment_ctime":1568553192,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1568553192","product_id":100028001,"comment_content":"lockInterruptibly()。老师，为啥要用这个API，不用lock。我查了一下，两者的区别是：前者侧重于中断，后者侧重于获取锁。这个地方，您是怎么考虑的呢?","like_count":0},{"had_liked":false,"id":123147,"user_name":"十大杰出青年","can_delete":false,"product_type":"c1","uid":1559178,"ip_address":"","ucode":"BAB4AA12604CF6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/a5U0nqaicLy5ZJkESxBd5lMicNQcTTDK8vURyyWiabHxic7vS1VVk7HWTZg6ltyWJ3n9jb3Gq554ibfjsf7bv1v1Sdw/132","comment_is_top":false,"comment_ctime":1565615315,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1565615315","product_id":100028001,"comment_content":"老师，优化ReentrantLock那里是不是有问题呢，product的修改放在两个不同的锁下，就是说可能会同时有两个线程会修改product这个list，这样是否违反了有序性。<br>而且我尝试无限循环运行生产者消费者线程，发现运行久了会出错的，希望老师讲解一下。","like_count":0,"discussions":[{"author":{"id":1445320,"avatar":"https://static001.geekbang.org/account/avatar/00/16/0d/c8/fdfd768b.jpg","nickname":"李志坡","note":"","ucode":"CCABC7E5CC5421","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329348,"discussion_content":"我也遇到了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606369745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122764,"user_name":"K","can_delete":false,"product_type":"c1","uid":1118374,"ip_address":"","ucode":"69831D1EFC083C","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/a6/4d2c933e.jpg","comment_is_top":false,"comment_ctime":1565515255,"is_pvip":false,"replies":[{"id":"45087","content":"这有一个lock锁，不会同时进来两个线程。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1565573346,"ip_address":"","comment_id":122764,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565515255","product_id":100028001,"comment_content":"老师好，我有个问题，就是实际的inventory会不会超过maxInventory啊？<br><br>productLock.lock();\t<br>try {\t<br>\twhile (inventory.get() == maxInventory){ &#47;&#47;3<br>\t\tnotFullCondition.await();<br>\t}<br>\tproduct.add(e);\t&#47;&#47;1<br><br>\t&#47;&#47;producer被唤醒了以后，执行完1，还没执行2，这个时候时间片用完了，所以先停止了。<br>\t&#47;&#47;然后另外的线程被唤醒了，在3处的判断逻辑，（上一个线程并没有inventory.incr()，所以while条件不满足，不循环）<br>\t&#47;&#47;线程2号执行完代码1，2。<br>\t&#47;&#47;当之前一个线程1号醒过来，他也会继续执行代码2。这不是相当于，实际的inventory 肯定超过了maxInventory吗？<br><br>\tSystem.out.println(&quot; 放入一个商品库存，总库存为：&quot; + inventory.incrementAndGet());\t&#47;&#47;2<br><br>\t&#47;&#47;后面的逻辑<br>\t...","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462394,"discussion_content":"这有一个lock锁，不会同时进来两个线程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565573346,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119398,"user_name":"晓杰","can_delete":false,"product_type":"c1","uid":1441546,"ip_address":"","ucode":"1174C88EEBF8A6","user_header":"https://static001.geekbang.org/account/avatar/00/15/ff/0a/12faa44e.jpg","comment_is_top":false,"comment_ctime":1564578581,"is_pvip":false,"replies":[{"id":"44009","content":"是的，可以基于消息队列或redis缓存来实现。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564714931,"ip_address":"","comment_id":119398,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1564578581","product_id":100028001,"comment_content":"请问老师在分布式架构中，使用lock和blockqueue实现生产者消费者是不是不适用了","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460887,"discussion_content":"是的，可以基于消息队列或redis缓存来实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564714931,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119162,"user_name":"我已经设置了昵称","can_delete":false,"product_type":"c1","uid":1364034,"ip_address":"","ucode":"ED672C5EBDBDC4","user_header":"https://static001.geekbang.org/account/avatar/00/14/d0/42/6fd01fb9.jpg","comment_is_top":false,"comment_ctime":1564533277,"is_pvip":false,"replies":[{"id":"43998","content":"是的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564712930,"ip_address":"","comment_id":119162,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1564533277","product_id":100028001,"comment_content":"kafka也有事务消息","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460769,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564712930,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1542987,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","nickname":"行则将至","note":"","ucode":"DB972F2DF059C4","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":12621,"discussion_content":"隔壁的胡夕大神说：kafka的0.11版本开始支持事务了，但是不太好控制呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568556233,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118899,"user_name":"正在减肥的胖籽。","can_delete":false,"product_type":"c1","uid":1033728,"ip_address":"","ucode":"99E2E4DF599236","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c6/00/683bb4f0.jpg","comment_is_top":false,"comment_ctime":1564460974,"is_pvip":false,"replies":[{"id":"43736","content":"比较常用的手段就是使用分布式锁来实现，在40讲中我们会详细介绍。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564541249,"ip_address":"","comment_id":118899,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1564460974","product_id":100028001,"comment_content":"1.如果把库存放到缓存中，下订单去缓存扣减库存数量，如何是保证数据一致性？希望老师能详细讲解下？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460648,"discussion_content":"比较常用的手段就是使用分布式锁来实现，在40讲中我们会详细介绍。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564541249,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018623,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/ff/1d283c53.jpg","nickname":"hawk","note":"","ucode":"996900C53B90F7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":10235,"discussion_content":"40讲中，这个问题有提到吗，“如果把库存放到缓存中，下订单去缓存扣减库存数量，如何是保证数据一致性”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568278439,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118828,"user_name":"一道阳光","can_delete":false,"product_type":"c1","uid":1239557,"ip_address":"","ucode":"F35207CCCEC6E2","user_header":"https://static001.geekbang.org/account/avatar/00/12/ea/05/c0d8014d.jpg","comment_is_top":false,"comment_ctime":1564450207,"is_pvip":false,"replies":[{"id":"43738","content":"嗯，可以通过超时来避免长时间阻塞等待。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564541598,"ip_address":"","comment_id":118828,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1564450207","product_id":100028001,"comment_content":"对于文中的案例，可以用tryLock方法，给定一个超时时间，超过时间还未获取到锁，就返回一个错误提示信息。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460601,"discussion_content":"嗯，可以通过超时来避免长时间阻塞等待。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564541598,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118772,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1564446733,"is_pvip":false,"replies":[{"id":"43744","content":"思考的很全面","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564542445,"ip_address":"","comment_id":118772,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1564446733","product_id":100028001,"comment_content":"课后习题:生产者也用MQ缓冲，在接入层做限流控制流量。客户端增加验证码等操作，防刷。服务器的计算能力，最大吞吐量是有限的。真要一直那么大量就只能加服务器了，只是瞬时就用MQ做流量削峰，或者提高用户门槛客户端限制减少无效请求(各种纬度进行控制)。只能想到这么点了<br>生产者消费者模型作用:<br>1.生产者和消费者解耦<br>2.通过缓冲，削峰，<br>3.生产者和消费吞吐量分别调控(生产者少只加生产者就好)<br>4....","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460567,"discussion_content":"思考的很全面","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564542445,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118761,"user_name":"undifined","can_delete":false,"product_type":"c1","uid":1068920,"ip_address":"","ucode":"449CB4CD2DC089","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/78/c3d8ecb0.jpg","comment_is_top":false,"comment_ctime":1564446265,"is_pvip":false,"replies":[{"id":"44486","content":"我理解的这个应该是库存的对实时性要求不高吧。如果对库存的实时性要求不高，可以建议第三方平台开放批量更新库存接口，并且固定一个更新周期。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1565056528,"ip_address":"","comment_id":118761,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1564446265","product_id":100028001,"comment_content":"生产方可以使用异步的方式，收到请求后直接发出 MQ，同时应当添加限流熔断等保护措施<br><br>老师我还有一个问题，我们需要向第三方平台同步库存，但是第三方有限流，而且 API 收费，目前是将商品 ID放到一个延时队列，如果有相同的 ID，一分钟内只会同步一次，老师有更好的办法吗，谢谢老师","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460563,"discussion_content":"我理解的这个应该是库存的对实时性要求不高吧。如果对库存的实时性要求不高，可以建议第三方平台开放批量更新库存接口，并且固定一个更新周期。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565056528,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118758,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1564445862,"is_pvip":false,"replies":[{"id":"43730","content":"这里同步更新下，新增了以下代码作为实时库存：<br>private AtomicInteger inventory = new AtomicInteger(0);<br><br>我们这里是基于LinkedList来存取库存的，虽然LinkedList是非线程安全，但我们新增是操作头部，而消费则是操作队列的尾部，理论上来说没有线程安全问题。而库存的实际数量inventory是基于AtomicInteger（CAS锁）线程安全类实现，即可以保证原子性，也可以保证消费者和生产者之间是可见的。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564540525,"ip_address":"","comment_id":118758,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1564445862","product_id":100028001,"comment_content":"老师好，生产者消费者模型里面，分开两个锁的时候 贡献变量private LinkedList&lt;String&gt; product = new LinkedList&lt;String&gt;();需要＋volatile保证可见性么?，条件判断等值判断好还是范围判断好?","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460561,"discussion_content":"这里同步更新下，新增了以下代码作为实时库存：\nprivate AtomicInteger inventory = new AtomicInteger(0);\n\n我们这里是基于LinkedList来存取库存的，虽然LinkedList是非线程安全，但我们新增是操作头部，而消费则是操作队列的尾部，理论上来说没有线程安全问题。而库存的实际数量inventory是基于AtomicInteger（CAS锁）线程安全类实现，即可以保证原子性，也可以保证消费者和生产者之间是可见的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564540525,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1259218,"avatar":"https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg","nickname":"发条橙子 。","note":"","ucode":"ED076F4534FFED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3478,"discussion_content":"可见行不能保证原子性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564528044,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118732,"user_name":"Zed","can_delete":false,"product_type":"c1","uid":1184951,"ip_address":"","ucode":"09947C76F55A46","user_header":"https://static001.geekbang.org/account/avatar/00/12/14/b7/bb6a1fd4.jpg","comment_is_top":false,"comment_ctime":1564443465,"is_pvip":false,"replies":[{"id":"43696","content":"是的，限流是一种优化方式","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564536367,"ip_address":"","comment_id":118732,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1564443465","product_id":100028001,"comment_content":"我觉得可以通过线程池控制限流。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460549,"discussion_content":"是的，限流是一种优化方式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564536367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}