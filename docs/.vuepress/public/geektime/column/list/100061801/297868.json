{"id":297868,"title":"05｜ RWMutex：读写锁的实现原理及避坑指南","content":"<p>你好，我是鸟窝。</p><p>在前面的四节课中，我们学习了第一个同步原语，即Mutex，我们使用它来保证读写共享资源的安全性。不管是读还是写，我们都通过Mutex来保证只有一个goroutine访问共享资源，这在某些情况下有点“浪费”。比如说，在写少读多的情况下，即使一段时间内没有写操作，大量并发的读访问也不得不在Mutex的保护下变成了串行访问，这个时候，使用Mutex，对性能的影响就比较大。</p><p>怎么办呢？你是不是已经有思路了，对，就是区分读写操作。</p><p>我来具体解释一下。如果某个读操作的goroutine持有了锁，在这种情况下，其它读操作的goroutine就不必一直傻傻地等待了，而是可以并发地访问共享变量，这样我们就可以<strong>将串行的读变成并行读</strong>，提高读操作的性能。当写操作的goroutine持有锁的时候，它就是一个排外锁，其它的写操作和读操作的goroutine，需要阻塞等待持有这个锁的goroutine释放锁。</p><p>这一类并发读写问题叫作<a href=\"https://en.wikipedia.org/wiki/Readers%E2%80%93writers_problem\">readers-writers问题</a>，意思就是，同时可能有多个读或者多个写，但是只要有一个线程在执行写操作，其它的线程都不能执行读写操作。</p><p><strong>Go标准库中的RWMutex（读写锁）就是用来解决这类readers-writers问题的</strong>。所以，这节课，我们就一起来学习RWMutex。我会给你介绍读写锁的使用场景、实现原理以及容易掉入的坑，你一定要记住这些陷阱，避免在实际的开发中犯相同的错误。</p><!-- [[[read_end]]] --><h1>什么是RWMutex？</h1><p>我先简单解释一下读写锁RWMutex。标准库中的RWMutex是一个 reader/writer 互斥锁。RWMutex在某一时刻只能由任意数量的reader持有，或者是只被单个的writer持有。</p><p>RWMutex的方法也很少，总共有5个。</p><ul>\n<li><strong>Lock/Unlock：写操作时调用的方法</strong>。如果锁已经被reader或者writer持有，那么，Lock方法会一直阻塞，直到能获取到锁；Unlock则是配对的释放锁的方法。</li>\n<li><strong>RLock/RUnlock：读操作时调用的方法</strong>。如果锁已经被writer持有的话，RLock方法会一直阻塞，直到能获取到锁，否则就直接返回；而RUnlock是reader释放锁的方法。</li>\n<li><strong>RLocker</strong>：这个方法的作用是为读操作返回一个Locker接口的对象。它的Lock方法会调用RWMutex的RLock方法，它的Unlock方法会调用RWMutex的RUnlock方法。</li>\n</ul><p>RWMutex的零值是未加锁的状态，所以，当你使用RWMutex的时候，无论是声明变量，还是嵌入到其它struct中，都不必显式地初始化。</p><p>我以计数器为例，来说明一下，如何使用RWMutex保护共享资源。计数器的<strong>count++<strong>操作是</strong>写</strong>操作，而获取count的值是<strong>读</strong>操作，这个场景非常适合读写锁，因为读操作可以并行执行，写操作时只允许一个线程执行，这正是readers-writers问题。</p><p>在这个例子中，使用10个goroutine进行读操作，每读取一次，sleep 1毫秒，同时，还有一个gorotine进行写操作，每一秒写一次，这是一个 <strong>1</strong> writer-<strong>n</strong> reader 的读写场景，而且写操作还不是很频繁（一秒一次）：</p><pre><code>func main() {\n    var counter Counter\n    for i := 0; i &lt; 10; i++ { // 10个reader\n        go func() {\n            for {\n                counter.Count() // 计数器读操作\n                time.Sleep(time.Millisecond)\n            }\n        }()\n    }\n\n    for { // 一个writer\n        counter.Incr() // 计数器写操作\n        time.Sleep(time.Second)\n    }\n}\n// 一个线程安全的计数器\ntype Counter struct {\n    mu    sync.RWMutex\n    count uint64\n}\n\n// 使用写锁保护\nfunc (c *Counter) Incr() {\n    c.mu.Lock()\n    c.count++\n    c.mu.Unlock()\n}\n\n// 使用读锁保护\nfunc (c *Counter) Count() uint64 {\n    c.mu.RLock()\n    defer c.mu.RUnlock()\n    return c.count\n}\n</code></pre><p>可以看到，Incr方法会修改计数器的值，是一个写操作，我们使用Lock/Unlock进行保护。Count方法会读取当前计数器的值，是一个读操作，我们使用RLock/RUnlock方法进行保护。</p><p>Incr方法每秒才调用一次，所以，writer竞争锁的频次是比较低的，而10个goroutine每毫秒都要执行一次查询，通过读写锁，可以极大提升计数器的性能，因为在读取的时候，可以并发进行。如果使用Mutex，性能就不会像读写锁这么好。因为多个reader并发读的时候，使用互斥锁导致了reader要排队读的情况，没有RWMutex并发读的性能好。</p><p><strong>如果你遇到可以明确区分reader和writer goroutine的场景，且有大量的并发读、少量的并发写，并且有强烈的性能需求，你就可以考虑使用读写锁RWMutex替换Mutex。</strong></p><p>在实际使用RWMutex的时候，如果我们在struct中使用RWMutex保护某个字段，一般会把它和这个字段放在一起，用来指示两个字段是一组字段。除此之外，我们还可以采用匿名字段的方式嵌入struct，这样，在使用这个struct时，我们就可以直接调用Lock/Unlock、RLock/RUnlock方法了，这和我们前面在<a href=\"https://time.geekbang.org/column/article/294905\">01讲</a>中介绍Mutex的使用方法很类似，你可以回去复习一下。</p><h1>RWMutex的实现原理</h1><p>RWMutex是很常见的并发原语，很多编程语言的库都提供了类似的并发类型。RWMutex一般都是基于互斥锁、条件变量（condition variables）或者信号量（semaphores）等并发原语来实现。<strong>Go标准库中的RWMutex是基于Mutex实现的。</strong></p><p>readers-writers问题一般有三类，基于对读和写操作的优先级，读写锁的设计和实现也分成三类。</p><ul>\n<li><strong>Read-preferring</strong>：读优先的设计可以提供很高的并发性，但是，在竞争激烈的情况下可能会导致写饥饿。这是因为，如果有大量的读，这种设计会导致只有所有的读都释放了锁之后，写才可能获取到锁。</li>\n<li><strong>Write-preferring</strong>：写优先的设计意味着，如果已经有一个writer在等待请求锁的话，它会阻止新来的请求锁的reader获取到锁，所以优先保障writer。当然，如果有一些reader已经请求了锁的话，新请求的writer也会等待已经存在的reader都释放锁之后才能获取。所以，写优先级设计中的优先权是针对新来的请求而言的。这种设计主要避免了writer的饥饿问题。</li>\n<li><strong>不指定优先级</strong>：这种设计比较简单，不区分reader和writer优先级，某些场景下这种不指定优先级的设计反而更有效，因为第一类优先级会导致写饥饿，第二类优先级可能会导致读饥饿，这种不指定优先级的访问不再区分读写，大家都是同一个优先级，解决了饥饿的问题。</li>\n</ul><p><strong>Go标准库中的RWMutex设计是Write-preferring方案。一个正在阻塞的Lock调用会排除新的reader请求到锁。</strong></p><p>RWMutex包含一个Mutex，以及四个辅助字段writerSem、readerSem、readerCount和readerWait：</p><pre><code>type RWMutex struct {\n\tw           Mutex   // 互斥锁解决多个writer的竞争\n\twriterSem   uint32  // writer信号量\n\treaderSem   uint32  // reader信号量\n\treaderCount int32   // reader的数量\n\treaderWait  int32   // writer等待完成的reader的数量\n}\n\nconst rwmutexMaxReaders = 1 &lt;&lt; 30\n</code></pre><p>我来简单解释一下这几个字段。</p><ul>\n<li>字段w：为writer的竞争锁而设计；</li>\n<li>字段readerCount：记录当前reader的数量（以及是否有writer竞争锁）；</li>\n<li>readerWait：记录writer请求锁时需要等待read完成的reader的数量；</li>\n<li>writerSem 和readerSem：都是为了阻塞设计的信号量。</li>\n</ul><p>这里的常量rwmutexMaxReaders，定义了最大的reader数量。</p><p>好了，知道了RWMutex的设计方案和具体字段，下面我来解释一下具体的方法实现。</p><h2>RLock/RUnlock的实现</h2><p>首先，我们看一下移除了race等无关紧要的代码后的RLock和RUnlock方法：</p><pre><code>func (rw *RWMutex) RLock() {\n    if atomic.AddInt32(&amp;rw.readerCount, 1) &lt; 0 {\n            // rw.readerCount是负值的时候，意味着此时有writer等待请求锁，因为writer优先级高，所以把后来的reader阻塞休眠\n        runtime_SemacquireMutex(&amp;rw.readerSem, false, 0)\n    }\n}\nfunc (rw *RWMutex) RUnlock() {\n    if r := atomic.AddInt32(&amp;rw.readerCount, -1); r &lt; 0 {\n        rw.rUnlockSlow(r) // 有等待的writer\n    }\n}\nfunc (rw *RWMutex) rUnlockSlow(r int32) {\n    if atomic.AddInt32(&amp;rw.readerWait, -1) == 0 {\n        // 最后一个reader了，writer终于有机会获得锁了\n        runtime_Semrelease(&amp;rw.writerSem, false, 1)\n    }\n}\n</code></pre><p>第2行是对reader计数加1。你可能比较困惑的是，readerCount怎么还可能为负数呢？其实，这是因为，readerCount这个字段有双重含义：</p><ul>\n<li>没有writer竞争或持有锁时，readerCount和我们正常理解的reader的计数是一样的；</li>\n<li>但是，如果有writer竞争锁或者持有锁时，那么，readerCount不仅仅承担着reader的计数功能，还能够标识当前是否有writer竞争或持有锁，在这种情况下，请求锁的reader的处理进入第4行，阻塞等待锁的释放。</li>\n</ul><p>调用RUnlock的时候，我们需要将Reader的计数减去1（第8行），因为reader的数量减少了一个。但是，第8行的AddInt32的返回值还有另外一个含义。如果它是负值，就表示当前有writer竞争锁，在这种情况下，还会调用rUnlockSlow方法，检查是不是reader都释放读锁了，如果读锁都释放了，那么可以唤醒请求写锁的writer了。</p><p>当一个或者多个reader持有锁的时候，竞争锁的writer会等待这些reader释放完，才可能持有这把锁。打个比方，在房地产行业中有条规矩叫做“<strong>买卖不破租赁</strong>”，意思是说，就算房东把房子卖了，新业主也不能把当前的租户赶走，而是要等到租约结束后，才能接管房子。这和RWMutex的设计是一样的。当writer请求锁的时候，是无法改变既有的reader持有锁的现实的，也不会强制这些reader释放锁，它的优先权只是限定后来的reader不要和它抢。</p><p>所以，rUnlockSlow将持有锁的reader计数减少1的时候，会检查既有的reader是不是都已经释放了锁，如果都释放了锁，就会唤醒writer，让writer持有锁。</p><h2>Lock</h2><p>RWMutex是一个多writer多reader的读写锁，所以同时可能有多个writer和reader。那么，为了避免writer之间的竞争，RWMutex就会使用一个Mutex来保证writer的互斥。</p><p>一旦一个writer获得了内部的互斥锁，就会反转readerCount字段，把它从原来的正整数readerCount(&gt;=0)修改为负数（readerCount-rwmutexMaxReaders），让这个字段保持两个含义（既保存了reader的数量，又表示当前有writer）。</p><p>我们来看下下面的代码。第5行，还会记录当前活跃的reader数量，所谓活跃的reader，就是指持有读锁还没有释放的那些reader。</p><pre><code>func (rw *RWMutex) Lock() {\n    // 首先解决其他writer竞争问题\n    rw.w.Lock()\n    // 反转readerCount，告诉reader有writer竞争锁\n    r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders\n    // 如果当前有reader持有锁，那么需要等待\n    if r != 0 &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != 0 {\n        runtime_SemacquireMutex(&amp;rw.writerSem, false, 0)\n    }\n}\n</code></pre><p>如果readerCount不是0，就说明当前有持有读锁的reader，RWMutex需要把这个当前readerCount赋值给readerWait字段保存下来（第7行）， 同时，这个writer进入阻塞等待状态（第8行）。</p><p>每当一个reader释放读锁的时候（调用RUnlock方法时），readerWait字段就减1，直到所有的活跃的reader都释放了读锁，才会唤醒这个writer。</p><h2>Unlock</h2><p>当一个writer释放锁的时候，它会再次反转readerCount字段。可以肯定的是，因为当前锁由writer持有，所以，readerCount字段是反转过的，并且减去了rwmutexMaxReaders这个常数，变成了负数。所以，这里的反转方法就是给它增加rwmutexMaxReaders这个常数值。</p><p>既然writer要释放锁了，那么就需要唤醒之后新来的reader，不必再阻塞它们了，让它们开开心心地继续执行就好了。</p><p>在RWMutex的Unlock返回之前，需要把内部的互斥锁释放。释放完毕后，其他的writer才可以继续竞争这把锁。</p><pre><code>func (rw *RWMutex) Unlock() {\n    // 告诉reader没有活跃的writer了\n    r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)\n    \n    // 唤醒阻塞的reader们\n    for i := 0; i &lt; int(r); i++ {\n        runtime_Semrelease(&amp;rw.readerSem, false, 0)\n    }\n    // 释放内部的互斥锁\n    rw.w.Unlock()\n}\n</code></pre><p>在这段代码中，我删除了race的处理和异常情况的检查，总体看来还是比较简单的。这里有几个重点，我要再提醒你一下。首先，你要理解readerCount这个字段的含义以及反转方式。其次，你还要注意字段的更改和内部互斥锁的顺序关系。在Lock方法中，是先获取内部互斥锁，才会修改的其他字段；而在Unlock方法中，是先修改的其他字段，才会释放内部互斥锁，这样才能保证字段的修改也受到互斥锁的保护。</p><p>好了，到这里我们就完整学习了RWMutex的概念和实现原理。RWMutex的应用场景非常明确，就是解决readers-writers问题。学完了今天的内容，之后当你遇到这类问题时，要优先想到RWMutex。另外，Go并发原语代码实现的质量都很高，非常精炼和高效，所以，你可以通过看它们的实现原理，学习一些编程的技巧。当然，还有非常重要的一点就是要知道reader或者writer请求锁的时候，既有的reader/writer和后续请求锁的reader/writer之间的（释放锁/请求锁）顺序关系。</p><p>有个很有意思的事儿，就是官方的文档对RWMutex介绍是错误的，或者说是<a href=\"https://github.com/golang/go/issues/41555\">不明确的</a>，在下一个版本（Go 1.16）中，官方会更改对RWMutex的介绍，具体是这样的：</p><blockquote>\n<p>A RWMutex is a reader/writer mutual exclusion lock.</p>\n</blockquote><blockquote>\n<p>The lock can be held by any number of readers or a single writer, and</p>\n</blockquote><blockquote>\n<p>a blocked writer also blocks new readers from acquiring the lock.</p>\n</blockquote><p>这个描述是相当精确的，它指出了RWMutex可以被谁持有，以及writer比后续的reader有获取锁的优先级。</p><p>虽然RWMutex暴露的API也很简单，使用起来也没有复杂的逻辑，但是和Mutex一样，在实际使用的时候，也会很容易踩到一些坑。接下来，我给你重点介绍3个常见的踩坑点。</p><h1>RWMutex的3个踩坑点</h1><h2>坑点1：不可复制</h2><p>前面刚刚说过，RWMutex是由一个互斥锁和四个辅助字段组成的。我们很容易想到，互斥锁是不可复制的，再加上四个有状态的字段，RWMutex就更加不能复制使用了。</p><p>不能复制的原因和互斥锁一样。一旦读写锁被使用，它的字段就会记录它当前的一些状态。这个时候你去复制这把锁，就会把它的状态也给复制过来。但是，原来的锁在释放的时候，并不会修改你复制出来的这个读写锁，这就会导致复制出来的读写锁的状态不对，可能永远无法释放锁。</p><p>那该怎么办呢？其实，解决方案也和互斥锁一样。你可以借助vet工具，在变量赋值、函数传参、函数返回值、遍历数据、struct初始化等时，检查是否有读写锁隐式复制的情景。</p><h2>坑点2：重入导致死锁</h2><p>读写锁因为重入（或递归调用）导致死锁的情况更多。</p><p>我先介绍第一种情况。因为读写锁内部基于互斥锁实现对writer的并发访问，而互斥锁本身是有重入问题的，所以，writer重入调用Lock的时候，就会出现死锁的现象，这个问题，我们在学习互斥锁的时候已经了解过了。</p><pre><code>func foo(l *sync.RWMutex) {\n    fmt.Println(&quot;in foo&quot;)\n    l.Lock()\n    bar(l)\n    l.Unlock()\n}\n\nfunc bar(l *sync.RWMutex) {\n    l.Lock()\n    fmt.Println(&quot;in bar&quot;)\n    l.Unlock()\n}\n\nfunc main() {\n    l := &amp;sync.RWMutex{}\n    foo(l)\n}\n</code></pre><p>运行这个程序，你就会得到死锁的错误输出，在Go运行的时候，很容易就能检测出来。</p><p>第二种死锁的场景有点隐蔽。我们知道，有活跃reader的时候，writer会等待，如果我们在reader的读操作时调用writer的写操作（它会调用Lock方法），那么，这个reader和writer就会形成互相依赖的死锁状态。Reader想等待writer完成后再释放锁，而writer需要这个reader释放锁之后，才能不阻塞地继续执行。这是一个读写锁常见的死锁场景。</p><p>第三种死锁的场景更加隐蔽。</p><p>当一个writer请求锁的时候，如果已经有一些活跃的reader，它会等待这些活跃的reader完成，才有可能获取到锁，但是，如果之后活跃的reader再依赖新的reader的话，这些新的reader就会等待writer释放锁之后才能继续执行，这就形成了一个环形依赖： <strong>writer依赖活跃的reader -&gt; 活跃的reader依赖新来的reader -&gt; 新来的reader依赖writer</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/c1/35/c18e897967d29e2d5273b88afe626035.jpg?wh=2089*1666\" alt=\"\"></p><p>这个死锁相当隐蔽，原因在于它和RWMutex的设计和实现有关。啥意思呢？我们来看一个计算阶乘(n!)的例子：</p><pre><code>func main() {\n    var mu sync.RWMutex\n\n    // writer,稍微等待，然后制造一个调用Lock的场景\n    go func() {\n        time.Sleep(200 * time.Millisecond)\n        mu.Lock()\n        fmt.Println(&quot;Lock&quot;)\n        time.Sleep(100 * time.Millisecond)\n        mu.Unlock()\n        fmt.Println(&quot;Unlock&quot;)\n    }()\n\n    go func() {\n        factorial(&amp;mu, 10) // 计算10的阶乘, 10!\n    }()\n    \n    select {}\n}\n\n// 递归调用计算阶乘\nfunc factorial(m *sync.RWMutex, n int) int {\n    if n &lt; 1 { // 阶乘退出条件 \n        return 0\n    }\n    fmt.Println(&quot;RLock&quot;)\n    m.RLock()\n    defer func() {\n        fmt.Println(&quot;RUnlock&quot;)\n        m.RUnlock()\n    }()\n    time.Sleep(100 * time.Millisecond)\n    return factorial(m, n-1) * n // 递归调用\n}\n</code></pre><p>factoria方法是一个递归计算阶乘的方法，我们用它来模拟reader。为了更容易地制造出死锁场景，我在这里加上了sleep的调用，延缓逻辑的执行。这个方法会调用读锁（第27行），在第33行递归地调用此方法，每次调用都会产生一次读锁的调用，所以可以不断地产生读锁的调用，而且必须等到新请求的读锁释放，这个读锁才能释放。</p><p>同时，我们使用另一个goroutine去调用Lock方法，来实现writer，这个writer会等待200毫秒后才会调用Lock，这样在调用Lock的时候，factoria方法还在执行中不断调用RLock。</p><p>这两个goroutine互相持有锁并等待，谁也不会退让一步，满足了“writer依赖活跃的reader -&gt; 活跃的reader依赖新来的reader -&gt; 新来的reader依赖writer”的死锁条件，所以就导致了死锁的产生。</p><p>所以，使用读写锁最需要注意的一点就是尽量避免重入，重入带来的死锁非常隐蔽，而且难以诊断。</p><h2>坑点3：释放未加锁的RWMutex</h2><p>和互斥锁一样，Lock和Unlock的调用总是成对出现的，RLock和RUnlock的调用也必须成对出现。Lock和RLock多余的调用会导致锁没有被释放，可能会出现死锁，而Unlock和RUnlock多余的调用会导致panic。在生产环境中出现panic是大忌，你总不希望半夜爬起来处理生产环境程序崩溃的问题吧？所以，在使用读写锁的时候，一定要注意，<strong>不遗漏不多余</strong>。</p><h1>流行的Go开发项目中的坑</h1><p>好了，又到了泡一杯宁夏枸杞加新疆大滩枣的养生茶，静静地欣赏知名项目出现Bug的时候了，这次被拉出来的是RWMutex的Bug。</p><h2>Docker</h2><h3>issue 36840</h3><p><a href=\"https://github.com/moby/moby/pull/36840/files\">issue 36840</a>修复的是错误地把writer当成reader的Bug。 这个地方本来需要修改数据，需要调用的是写锁，结果用的却是读锁。或许是被它紧挨着的findNode方法调用迷惑了，认为这只是一个读操作。可实际上，代码后面还会有changeNodeState方法的调用，这是一个写操作。修复办法也很简单，只需要改成Lock/Unlock即可。</p><p><img src=\"https://static001.geekbang.org/resource/image/e4/4b/e4d153cb5f81873a726b09bc436b8a4b.png?wh=1642*554\" alt=\"\"></p><h2>Kubernetes</h2><h3>issue 62464</h3><p><a href=\"https://github.com/kubernetes/kubernetes/pull/62464\">issue 62464</a>就是读写锁第二种死锁的场景，这是一个典型的reader导致的死锁的例子。知道墨菲定律吧？“凡是可能出错的事，必定会出错”。你可能觉得我前面讲的RWMutex的坑绝对不会被人踩的，因为道理大家都懂，但是你看，Kubernetes就踩了这个重入的坑。</p><p>这个issue在移除pod的时候可能会发生，原因就在于，GetCPUSetOrDefault方法会请求读锁，同时，它还会调用GetCPUSet或GetDefaultCPUSet方法，这时又会请求读锁。如果期间有其它goroutine请求写锁的话，GetCPUSetOrDefault方法调用GetCPUSet或GetDefaultCPUSet方法时就不会返回了，请求写锁的goroutine也不会返回，这就会形成死锁。</p><p><img src=\"https://static001.geekbang.org/resource/image/06/c2/062ae5d2a6190f86cb7bf57db643d8c2.png?wh=2126*986\" alt=\"\"></p><h1>总结</h1><p>在开发过程中，一开始考虑共享资源并发访问问题的时候，我们就会想到互斥锁Mutex。因为刚开始的时候，我们还并不太了解并发的情况，所以，就会使用最简单的同步原语来解决问题。等到系统成熟，真正到了需要性能优化的时候，我们就能静下心来分析并发场景的可能性，这个时候，我们就要考虑将Mutex修改为RWMutex，来压榨系统的性能。</p><p>当然，如果一开始你的场景就非常明确了，比如我就要实现一个线程安全的map，那么，一开始你就可以考虑使用读写锁。</p><p>正如我在前面提到的，如果你能意识到你要解决的问题是一个readers-writers问题，那么你就可以毫不犹豫地选择RWMutex，不用考虑其它选择。那在使用RWMutex时，最需要注意的一点就是尽量避免重入，重入带来的死锁非常隐蔽，而且难以诊断。</p><p>另外我们也可以扩展RWMutex，不过实现方法和互斥锁Mutex差不多，在技术上是一样的，都是通过unsafe来实现，我就不再具体讲了。课下你可以参照我们<a href=\"https://time.geekbang.org/column/article/296793\">上节课</a>学习的方法，实现一个扩展的RWMutex。</p><p>这一讲我们系统学习了读写锁的相关知识，这里提供给你一个知识地图，帮助你复习本节课的知识。</p><p><img src=\"https://static001.geekbang.org/resource/image/69/42/695b9aa6027b5d3a61e92cbcbba10042.jpg?wh=2250*2019\" alt=\"\"></p><h1>思考题</h1><p>请你写一个扩展的读写锁，比如提供TryLock，查询当前是否有writer、reader的数量等方法。</p><p>欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得有所收获，也欢迎你把今天的内容分享给你的朋友或同事。</p>","neighbors":{"left":{"article_title":"04｜ Mutex：骇客编程，如何拓展额外功能？","id":296793},"right":{"article_title":"06 | WaitGroup：协同等待，任务编排利器","id":298516}},"comments":[{"had_liked":false,"id":254999,"user_name":"Junes","can_delete":false,"product_type":"c1","uid":1354665,"ip_address":"","ucode":"CD2E829C868970","user_header":"https://static001.geekbang.org/account/avatar/00/14/ab/a9/590d6f02.jpg","comment_is_top":false,"comment_ctime":1603247834,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"130452266714","product_id":100061801,"comment_content":"交一下作业，我就不贴完整代码了，分享一下核心思路：<br><br>获取两个关键变量，大致思路是根据 起始地址+偏移量，<br>&#47;&#47; readerCount 这个成员变量前有1个mutex+2个uint32<br>readerCount := atomic.LoadInt32((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;m)) + unsafe.Sizeof(sync.Mutex{}) + 2*unsafe.Sizeof(uint32(0)))))<br><br>&#47;&#47; readerWait 这个成员变量前有1个mutex+2个uint32+1个int32<br>readerWait := atomic.LoadInt32((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;m)) + unsafe.Sizeof(sync.Mutex{}) + 2*unsafe.Sizeof(uint32(0)) + unsafe.Sizeof(int32(0)))))<br><br>剩下的，大量借鉴Mutex那块TryLock的实现了，大量地使用atomic原子操作：<br><br>TryLock: 读取readerCount，小于0则返回false，否则尝试Lock<br>是否有writer：读取readerCount，小于0则有writer，否则没有。<br>reader的数量：读取readerCount，小于0则加上rwmutexMaxReaders，结果即为reader数量。<br><br>另外还可以通过readerWait，查询当前Lock被多少个RLock阻塞着。<br><br>再谈一个感受，RWMutex的实现依赖于Mutex，这最大的好处是简化了代码，但同时，在读少写多的情况下，由于额外维护了4个变量，性能不如直接调用Mutex。这个读写比例的临界值，找个时间自己测试测试。 :)","like_count":31,"discussions":[{"author":{"id":2197943,"avatar":"","nickname":"代码看不懂篮球打不好","note":"","ucode":"7C5D1D36207F41","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339995,"discussion_content":" 老哥我重新认真看了下，你这个考虑内存对齐了吗，我怎么感觉如果不考虑内存对齐是没问题的，但是考虑的话，这个偏移量不一定就是size的大小","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1609857326,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1140986,"avatar":"https://static001.geekbang.org/account/avatar/00/11/68/fa/446da332.jpg","nickname":"似水流年","note":"","ucode":"B9A035B0CDA7E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2197943,"avatar":"","nickname":"代码看不懂篮球打不好","note":"","ucode":"7C5D1D36207F41","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367744,"discussion_content":"这个确实有问题，unsafe.Sizeof 改为 unsafe.Alignof 即可","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1618457534,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":339995,"ip_address":""},"score":367744,"extra":""}]}]},{"had_liked":false,"id":259215,"user_name":"端贺","can_delete":false,"product_type":"c1","uid":1121588,"ip_address":"","ucode":"80F1400B138055","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/34/8201baab.jpg","comment_is_top":false,"comment_ctime":1604654637,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"113273804333","product_id":100061801,"comment_content":"简单梳理面试题:<br>    1. 读写锁用过吗，读写锁用在什么样的场景？（或读写锁主要用来解决什么问题，说说对读写锁的理解？）<br>    2.说说RWMutex的实现原理？说说RWMutex与Mutex的区别？<br>    3.RWMutex源码看过吗？如果使用Mutex来设计一个RWMutex你有什么思路？<br>    4.在执行Lock，Unlock，Rlock，RUnlock时需要考虑什么问题？<br>    5.使用读写锁时如何规避死锁问题？<br>    6.如何监控读写锁的等待情况？你有什么思路？","like_count":27,"discussions":[{"author":{"id":1310798,"avatar":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","nickname":"吴小智","note":"","ucode":"C7C9F58B5C9F7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382538,"discussion_content":"看文章，然后梳理面试题，也是总结文章要点的好方法呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625626795,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":265806,"user_name":"DigDeeply","can_delete":false,"product_type":"c1","uid":1239008,"ip_address":"","ucode":"113F4D755A1FEC","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/e0/33521e13.jpg","comment_is_top":false,"comment_ctime":1607041153,"is_pvip":false,"replies":[{"id":"96622","content":"这是对作者很高的褒奖，谢谢。此留言应该置顶啊","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1607069401,"ip_address":"","comment_id":265806,"utype":1}],"discussion_count":1,"race_medal":0,"score":"87506387073","product_id":100061801,"comment_content":"这门课的质量真高啊，看的酣畅淋漓👍","like_count":21,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511053,"discussion_content":"这是对作者很高的褒奖，谢谢。此留言应该置顶啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607069401,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":255642,"user_name":"那时刻","can_delete":false,"product_type":"c1","uid":1150927,"ip_address":"","ucode":"B0D150856C3A4A","user_header":"https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg","comment_is_top":false,"comment_ctime":1603385568,"is_pvip":false,"replies":[{"id":"93153","content":"现在版本的go运行时过于智能了，会把这个场景“误报”成死锁，其实我们的本意是让程序hang在这里。<br>可以改成sleep，waitgroup或者从命令行读取数据等的方式阻塞主goroutine","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1603413935,"ip_address":"","comment_id":255642,"utype":1}],"discussion_count":1,"race_medal":1,"score":"35963123936","product_id":100061801,"comment_content":"请问老师一个关于select{}问题，<br><br>func foo() {<br>\tfmt.Println(&quot;in foo&quot;)<br>}<br><br>func goo() {<br>\tvar i int<br>\tfmt.Println(&quot;in goo&quot;, i)<br>}<br><br>func main() {<br>\tgo goo()<br>\tgo foo()<br>\tselect {}<br>}<br><br>这个代码会报all goroutines are asleep - deadlock，是不是select{}这种写法不推荐么？<br><br>","like_count":8,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507778,"discussion_content":"现在版本的go运行时过于智能了，会把这个场景“误报”成死锁，其实我们的本意是让程序hang在这里。\n可以改成sleep，waitgroup或者从命令行读取数据等的方式阻塞主goroutine","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603413935,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":274065,"user_name":"Varphp","can_delete":false,"product_type":"c1","uid":1590892,"ip_address":"","ucode":"889550391E3F75","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTImmLJCKerl9CI4sTpPDNCUgswp04ybsJ4J6mpJmMlHh43Iibp1RPOLam5PpOv2ZDGcjvGrY94lNRw/132","comment_is_top":false,"comment_ctime":1610808094,"is_pvip":false,"replies":[{"id":"99564","content":"第一个问题 对。第二个问题太过笼统所以没法回答，当然文章中已经介绍读写锁的功能，适合写少读多的场景","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1610947449,"ip_address":"","comment_id":274065,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5905775390","product_id":100061801,"comment_content":"原谅我的小白 请教个问题<br><br>RWMutex是读写锁，Mutex就是锁吗？区别在于一个精确到读写 一个只能精确到协程对吗","like_count":1,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513905,"discussion_content":"第一个问题 对。第二个问题太过笼统所以没法回答，当然文章中已经介绍读写锁的功能，适合写少读多的场景","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610947449,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":271668,"user_name":"David","can_delete":false,"product_type":"c1","uid":1136236,"ip_address":"","ucode":"8277D3CE881053","user_header":"https://static001.geekbang.org/account/avatar/00/11/56/6c/042a2e41.jpg","comment_is_top":false,"comment_ctime":1609751979,"is_pvip":false,"replies":[{"id":"98549","content":"在readers已占有锁的情况下，后续只要有writer存在，会优先writer执行锁，后续的reader需要writer释放锁才可以获取","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1609804780,"ip_address":"","comment_id":271668,"utype":1}],"discussion_count":4,"race_medal":0,"score":"5904719275","product_id":100061801,"comment_content":"func (rw *RWMutex) RLock() {<br>    if atomic.AddInt32(&amp;rw.readerCount, 1) &lt; 0 {<br>            &#47;&#47; rw.readerCount是负值的时候，意味着此时有writer等待请求锁，因为writer优先级高，所以把后来的reader阻塞休眠<br>        runtime_SemacquireMutex(&amp;rw.readerSem, false, 0)<br>    }<br>}<br>这个代码， rw.readerCount 为负数，表示有writer，正在等待，则reader要进行休眠。<br><br><br>func (rw *RWMutex) Lock() {<br>    &#47;&#47; 首先解决其他writer竞争问题<br>    rw.w.Lock()<br>    &#47;&#47; 反转readerCount，告诉reader有writer竞争锁<br>    r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders<br>    &#47;&#47; 如果当前有reader持有锁，那么需要等待<br>    if r != 0 &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != 0 {<br>        runtime_SemacquireMutex(&amp;rw.writerSem, false, 0)<br>    }<br>}<br>这里是先获取到了锁，才去修改 rw.readerCount 的值，也就是说 每个writer 只有在获取到锁的情况下，才去把 rw.readerCount改成负数，而读锁是否休眠，也是根据这个值来判断。<br><br><br>func (rw *RWMutex) Unlock() {<br>    &#47;&#47; 告诉reader没有活跃的writer了<br>    r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)<br>    <br>    &#47;&#47; 唤醒阻塞的reader们<br>    for i := 0; i &lt; int(r); i++ {<br>        runtime_Semrelease(&amp;rw.readerSem, false, 0)<br>    }<br>    &#47;&#47; 释放内部的互斥锁<br>    rw.w.Unlock()<br>}<br><br>而这个地方 先去释放了 reader，再去释放阻塞的writer<br><br>假设一种情况，在lock的时候，先后有a,b两个writer 进来，发现还有其他的reader正在使用，那么a，b进行阻塞，当reader 使用完了后，唤醒了a，a获取到了锁，在a使用期间，也有多个reader 进来，进行的休眠。当a使用完成后，调用unlock方法，先是修改了rw.readerCount（根据rlock的方法，rw.readerCount是唯一判断，是否阻塞的条件，那么，当这个时候，有新的reader进来，就可以无条件使用了）；再去唤醒被阻塞的reader（这个情况下，唤醒的reader 也可以进行无条件使用了），最后去释放锁，唤醒了b，b去获取锁的时候，发现有reader在使用，修改rw.readerCount的值（标示有等待的writer），然后进行休眠，当最后一个reader使用完成后，唤醒b，这个时候b才正在获取到了锁。<br><br>按照以上逻辑，多个writer的情况下，并没有造成reader出现饥饿状态，反而在释放写锁的那一刹那，新的reader 占了先机，这种情况怎么叫 Write-preferring 方案。我理解的Write-preferring 方案：是只有在没有writer的情况下，才轮到reader执行，多个writer的情况，是一个writer一个writer执行完，才会执行reader。我从代码中看出了不明白的地方，希望老师 帮忙解答一下","like_count":1,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512999,"discussion_content":"在readers已占有锁的情况下，后续只要有writer存在，会优先writer执行锁，后续的reader需要writer释放锁才可以获取","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609804780,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1058856,"avatar":"https://static001.geekbang.org/account/avatar/00/10/28/28/5ffdd123.jpg","nickname":"漫游者","note":"","ucode":"7402D9068413D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373522,"discussion_content":"看了两遍，理解的也是一样的。没看懂老师评论的由来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620775753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1136236,"avatar":"https://static001.geekbang.org/account/avatar/00/11/56/6c/042a2e41.jpg","nickname":"David","note":"","ucode":"8277D3CE881053","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339802,"discussion_content":"从代码中，只能看出活跃的writer 优先级高，但是对于已经阻塞等待的writer 并没什么优势，可能比后来的reader 还要晚执行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609809725,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1136236,"avatar":"https://static001.geekbang.org/account/avatar/00/11/56/6c/042a2e41.jpg","nickname":"David","note":"","ucode":"8277D3CE881053","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339800,"discussion_content":"老师，对于那种本身就已经有多个writer阻塞等待的情况下，在Unlock中先修改readerCount的值，唤醒reader，再去唤醒writer，而且不是handoff移交，那么怎么来确保，阻塞的writer 抢得过活跃的reader，如果抢不过，又会继续睡眠，等到已占有锁的reader执行完，才能进行执行。我从代码中，可以看出writer有一定的优先级，但是我觉得这不算纯粹的Write-preferring 。mysql的写优先，就会在写多读少的情况下，造成读饥饿，而go这个，不会，这还叫Write-preferring 吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609809603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":259374,"user_name":"50%","can_delete":false,"product_type":"c1","uid":1674992,"ip_address":"","ucode":"3E4247B5844B5B","user_header":"https://static001.geekbang.org/account/avatar/00/19/8e/f0/18720510.jpg","comment_is_top":false,"comment_ctime":1604715177,"is_pvip":false,"replies":[{"id":"94317","content":"对","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1604735978,"ip_address":"","comment_id":259374,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5899682473","product_id":100061801,"comment_content":"r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders<br>这句老师看我理解的对么。首先前一步反转操作是用原子操作实现的，此时其他的reader可能会改变readerCount字段的状态。虽然看起来加减同一个rwmutexMaxReaders看似结果相等，但在并发的场景下，其他reader读到的readerCount的状态为负值，表示有写锁的情况存在。","like_count":1,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508919,"discussion_content":"对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604735978,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":255665,"user_name":"Gopher","can_delete":false,"product_type":"c1","uid":1206229,"ip_address":"","ucode":"3C1F9012BB486D","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/d5/1b26b725.jpg","comment_is_top":false,"comment_ctime":1603409046,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5898376342","product_id":100061801,"comment_content":"作业思路<br>和mutex的扩展思路一样，通过unsafe获取指针，在进行偏移获取到reader数量，不等于0直接返回，否则尝试lock","like_count":1},{"had_liked":false,"id":255194,"user_name":"Panda","can_delete":false,"product_type":"c1","uid":1095740,"ip_address":"","ucode":"911A200C7B18BE","user_header":"https://static001.geekbang.org/account/avatar/00/10/b8/3c/1a294619.jpg","comment_is_top":false,"comment_ctime":1603278816,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5898246112","product_id":100061801,"comment_content":"RWMutex 是 Mutex 的增强版本  也是分而治之的思想体现","like_count":1},{"had_liked":false,"id":254995,"user_name":"Ethan Liu","can_delete":false,"product_type":"c1","uid":1070043,"ip_address":"","ucode":"231F944F7CD56A","user_header":"https://static001.geekbang.org/account/avatar/00/10/53/db/858337e3.jpg","comment_is_top":false,"comment_ctime":1603246792,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5898214088","product_id":100061801,"comment_content":"区分reader和writer的场景，可不可以用channel来实现？如果可以的话，与使用RWMutex有什么区别？","like_count":1},{"had_liked":false,"id":342610,"user_name":"极客酱酱","can_delete":false,"product_type":"c1","uid":2934665,"ip_address":"","ucode":"18CDC1DB754D58","user_header":"https://static001.geekbang.org/account/avatar/00/2c/c7/89/16437396.jpg","comment_is_top":false,"comment_ctime":1650363469,"is_pvip":true,"replies":[{"id":"125222","content":"processon","user_name":"作者回复","user_name_real":"编辑","uid":"1066613","ctime":1650469750,"ip_address":"","comment_id":342610,"utype":1}],"discussion_count":1,"race_medal":2,"score":"1650363469","product_id":100061801,"comment_content":"鸟窝老师，麻烦问一下您这边使用的脑图工具是哪个，我正在学习这种用脑图梳理知识点的方法，手头的工具不太友好，手动狗头。","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":565507,"discussion_content":"processon","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650469750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338269,"user_name":"50%","can_delete":false,"product_type":"c1","uid":1674992,"ip_address":"","ucode":"3E4247B5844B5B","user_header":"https://static001.geekbang.org/account/avatar/00/19/8e/f0/18720510.jpg","comment_is_top":false,"comment_ctime":1647400369,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647400369","product_id":100061801,"comment_content":"r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders<br><br>再看一遍又有新的理解呀。这句话实际上仅有前半部分保证了对readerCounter的原子性操作。那么在并发的情况下，持有读锁的goroutine就被阻塞。","like_count":0},{"had_liked":false,"id":323552,"user_name":"8.13.3.27.30","can_delete":false,"product_type":"c1","uid":1556358,"ip_address":"","ucode":"2DE3CE3E338BAB","user_header":"https://static001.geekbang.org/account/avatar/00/17/bf/86/c0cb35f0.jpg","comment_is_top":false,"comment_ctime":1637985564,"is_pvip":false,"replies":[{"id":"118194","content":"很好的发现，你说的对","user_name":"作者回复","user_name_real":"编辑","uid":"1066613","ctime":1639209881,"ip_address":"","comment_id":323552,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1637985564","product_id":100061801,"comment_content":"有一个问题、写错unlock逻辑中、解锁之前会唤醒所有等待读的锁、但是再锁的过程当中并可能会继续来读和写的操作、这些操作这里貌似并不能保证写锁的优先，因为写锁解锁的过程会把后来的读锁也唤醒、而这个时候后来的写锁（但是它先于后来的读锁操作锁）没有办法优先后来的读锁获取到锁，不知道理解是否正确，另外读写锁的实现看上去在极限情况下会导致写饥饿、当然也可能是读饥饿（理论上这种情况不应该使用读写锁）、请教老师我的理解是否正确，如果正确怎么解决写饥饿的问题","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537824,"discussion_content":"很好的发现，你说的对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639209882,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":305904,"user_name":"🐭","can_delete":false,"product_type":"c1","uid":2384580,"ip_address":"","ucode":"E5CA01ACAEDFC1","user_header":"https://static001.geekbang.org/account/avatar/00/24/62/c4/be92518b.jpg","comment_is_top":false,"comment_ctime":1628226375,"is_pvip":false,"replies":[{"id":"110978","content":" 嗯，这个例子不太好，应该用两个writer更好理解","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1628604139,"ip_address":"","comment_id":305904,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1628226375","product_id":100061801,"comment_content":"第一个例子中，写操作在主携程里，为什么还要加锁","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524555,"discussion_content":" 嗯，这个例子不太好，应该用两个writer更好理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628604139,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":304631,"user_name":"GoGoGo","can_delete":false,"product_type":"c1","uid":1622305,"ip_address":"","ucode":"8004C39DD29BA9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIk8csm2UvibqAOdiaZ9fZ4tBI727gpdnwVSmH9dfkY9dSBpPQbibTBc2mm4ONdQj1lYWyZxKTZyFxpQ/132","comment_is_top":false,"comment_ctime":1627526726,"is_pvip":false,"replies":[{"id":"110317","content":"确保happenbefore关系，读的时候能知道所以发生在它之前的写","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1627730489,"ip_address":"","comment_id":304631,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1627526726","product_id":100061801,"comment_content":"<br>func main() {<br>    var counter Counter<br>    for i := 0; i &lt; 10; i++ { &#47;&#47; 10个reader<br>        go func() {<br>            for {<br>                counter.Count() &#47;&#47; 计数器读操作<br>                time.Sleep(time.Millisecond)<br>            }<br>        }()<br>    }<br><br>    for { &#47;&#47; 一个writer<br>        counter.Incr() &#47;&#47; 计数器写操作<br>        time.Sleep(time.Second)<br>    }<br>}<br>&#47;&#47; 一个线程安全的计数器<br>type Counter struct {<br>    mu    sync.RWMutex<br>    count uint64<br>}<br><br>&#47;&#47; 使用写锁保护<br>func (c *Counter) Incr() {<br>    c.mu.Lock()<br>    c.count++<br>    c.mu.Unlock()<br>}<br><br>&#47;&#47; 使用读锁保护<br>func (c *Counter) Count() uint64 {<br>    c.mu.RLock()<br>    defer c.mu.RUnlock()<br>    return c.count<br>}<br><br>当能明确的区分 读写操作时  为什么读还要加锁 这段代码里 加读锁和不加读锁有什么区别吗？","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524106,"discussion_content":"确保happenbefore关系，读的时候能知道所以发生在它之前的写","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627730489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":304116,"user_name":"ChuanBing จุ๊บ","can_delete":false,"product_type":"c1","uid":1628736,"ip_address":"","ucode":"4482E852FC147A","user_header":"https://static001.geekbang.org/account/avatar/00/18/da/40/bda5ad2b.jpg","comment_is_top":false,"comment_ctime":1627262033,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627262033","product_id":100061801,"comment_content":"func (rw *RWMutex) Unlock() {<br>\tif race.Enabled {<br>\t\t_ = rw.w.state<br>\t\trace.Release(unsafe.Pointer(&amp;rw.readerSem))<br>\t\trace.Disable()<br>\t}<br>&#47;&#47; ..........<br>}<br><br>请问 其中的  _ = rw.w.state  作用是什么?","like_count":0},{"had_liked":false,"id":293228,"user_name":"小虾米","can_delete":false,"product_type":"c1","uid":1005528,"ip_address":"","ucode":"F543987A7FAB20","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/d8/425e1b0a.jpg","comment_is_top":false,"comment_ctime":1621297872,"is_pvip":false,"replies":[{"id":"106132","content":"共用一个state变量","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1621306562,"ip_address":"","comment_id":293228,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1621297872","product_id":100061801,"comment_content":"rwmutexMaxReaders 为何不能用满32位呢","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520125,"discussion_content":"共用一个state变量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621306562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284508,"user_name":"Terence孫","can_delete":false,"product_type":"c1","uid":1157674,"ip_address":"","ucode":"8C3A89C18A2182","user_header":"https://static001.geekbang.org/account/avatar/00/11/aa/2a/ce7c487d.jpg","comment_is_top":false,"comment_ctime":1616311500,"is_pvip":false,"replies":[{"id":"103216","content":"赞，到位","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1616415991,"ip_address":"","comment_id":284508,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1616311500","product_id":100061801,"comment_content":"读写锁中读写锁Lock的总结：<br>当前锁和新锁类型不同，新锁阻塞等待<br>当前锁和新锁类型相同，读锁不阻塞，写锁阻塞","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517372,"discussion_content":"赞，到位","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616415991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":259270,"user_name":"Yimmy","can_delete":false,"product_type":"c1","uid":1177248,"ip_address":"","ucode":"E66EAF7050C74A","user_header":"https://static001.geekbang.org/account/avatar/00/11/f6/a0/8ea0bfba.jpg","comment_is_top":false,"comment_ctime":1604666665,"is_pvip":false,"replies":[{"id":"94518","content":"是的，这个方法是读锁。重入问题。������������","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1604989265,"ip_address":"","comment_id":259270,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1604666665","product_id":100061801,"comment_content":"老师好，“同时，它还会调用 GetCPUSet 或 GetDefaultCPUSet 方法。当这两个方法都请求写锁时，是获取不到的，因为 GetCPUSetOrDefault 方法还没有执行完，不会释放读锁，这就形成了死锁。”<br><br>看了这个issue, GetCPUSet 或 GetDefaultCPUSet 这2个方法中调用的是读锁，不是写锁，这个issuse的问题，我理解是重入锁，而不是reader和writer相互等待的死锁<br><br>补充源码（https:&#47;&#47;github.com&#47;kubernetes&#47;kubernetes&#47;pull&#47;62464&#47;files ）<br>func (s *stateMemory) GetCPUSet(containerID string) (cpuset.CPUSet, bool) {<br>\ts.RLock()<br>\tdefer s.RUnlock()<br>\tres, ok := s.assignments[containerID]<br>\treturn res.Clone(), ok<br>}<br>func (s *stateMemory) GetDefaultCPUSet() cpuset.CPUSet {<br>\ts.RLock()<br>\tdefer s.RUnlock()<br>\treturn s.defaultCPUSet.Clone()<br>}","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508891,"discussion_content":"是的，这个方法是读锁。重入问题。������������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604989265,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":258855,"user_name":"出卖灵魂的教练Kerry","can_delete":false,"product_type":"c1","uid":1807943,"ip_address":"","ucode":"8C64517DA556FE","user_header":"https://static001.geekbang.org/account/avatar/00/1b/96/47/93838ff7.jpg","comment_is_top":false,"comment_ctime":1604568130,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1604568130","product_id":100061801,"comment_content":"涨知识了","like_count":0},{"had_liked":false,"id":258444,"user_name":"syuan","can_delete":false,"product_type":"c1","uid":1215879,"ip_address":"","ucode":"D9BBC2ADAB5F2E","user_header":"https://static001.geekbang.org/account/avatar/00/12/8d/87/47d95f4a.jpg","comment_is_top":false,"comment_ctime":1604448744,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604448744","product_id":100061801,"comment_content":"干货满满","like_count":0},{"had_liked":false,"id":255697,"user_name":"Yayu","can_delete":false,"product_type":"c1","uid":1058015,"ip_address":"","ucode":"5E7842458D8229","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/df/645f8087.jpg","comment_is_top":false,"comment_ctime":1603415863,"is_pvip":false,"replies":[{"id":"93156","content":"基础性数据结构，英语是primitive,不是原子性语句哈","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1603416977,"ip_address":"","comment_id":255697,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1603415863","product_id":100061801,"comment_content":"老师好，请问“原语”的意思是什么？原子性语句吗？","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507803,"discussion_content":"基础性数据结构，英语是primitive,不是原子性语句哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603416977,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":255572,"user_name":"Linuxer","can_delete":false,"product_type":"c1","uid":1153978,"ip_address":"","ucode":"272D9D8089C3D6","user_header":"https://static001.geekbang.org/account/avatar/00/11/9b/ba/333b59e5.jpg","comment_is_top":false,"comment_ctime":1603374808,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1603374808","product_id":100061801,"comment_content":"试着回答一下课后题，初学GO，请各位大佬指点<br>const {<br>   READ = 0 <br>   WRITE = 1<br>}<br><br>func (rw **RWMutex) TryLock(mode int32)  bool {<br>   n := atomic.LoadInt32(&amp;rw.readerCount)<br>   if n &lt; 0 {<br>      return false <br>   }   <br>   if mod == 0 &amp;&amp; atomic.CompareAndSwapInt32(n, n+1) == n{<br>      return true ;<br>   }else if mod == 1 &amp;&amp; atomic.CompareAndSwapInt32(0, -rwmutexMaxReaders) == 0 {<br>      rw.w.Lock()<br>      return true<br>   }else{<br>      return false<br>   }<br>}<br>func (rw *RWMutex) ExistWriter() bool {<br>     return atomic.LoadInt32(&amp;rw.readerCount) &lt; 0<br>}<br><br>func (rw *RWMutex) GetReaderNum() int32 {<br>   n := atomic.LoadInt32(&amp;rw.readerCount) ;<br>   if n &lt; 0 {<br>       return atomic.LoadInt32(&amp;rw.readerWait)<br>   }else{<br>      return n <br>   }<br>}","like_count":0,"discussions":[{"author":{"id":1289318,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ac/66/a256008b.jpg","nickname":"SuperDai","note":"","ucode":"0CA86D253754CA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319528,"discussion_content":"老哥 你这代码能编译过吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604044124,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":255184,"user_name":"pdf","can_delete":false,"product_type":"c1","uid":1649662,"ip_address":"","ucode":"A44250955878BB","user_header":"https://static001.geekbang.org/account/avatar/00/19/2b/fe/7925eb7e.jpg","comment_is_top":false,"comment_ctime":1603277193,"is_pvip":true,"discussion_count":6,"race_medal":0,"score":"1603277193","product_id":100061801,"comment_content":"Go 1.15<br>main函数结尾 select {} 直接报死锁","like_count":0,"discussions":[{"author":{"id":1150927,"avatar":"https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg","nickname":"那时刻","note":"","ucode":"B0D150856C3A4A","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":316337,"discussion_content":"我测试了，在1.12也是会deadlock的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603385200,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1649662,"avatar":"https://static001.geekbang.org/account/avatar/00/19/2b/fe/7925eb7e.jpg","nickname":"pdf","note":"","ucode":"A44250955878BB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1150927,"avatar":"https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg","nickname":"那时刻","note":"","ucode":"B0D150856C3A4A","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":316495,"discussion_content":"难道是1.11？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603417416,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":316337,"ip_address":""},"score":316495,"extra":""}]},{"author":{"id":2227527,"avatar":"https://static001.geekbang.org/account/avatar/00/21/fd/47/499339d1.jpg","nickname":"新味道","note":"","ucode":"979E3574082CE7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":315906,"discussion_content":"select {} 永久阻塞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603335686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1649662,"avatar":"https://static001.geekbang.org/account/avatar/00/19/2b/fe/7925eb7e.jpg","nickname":"pdf","note":"","ucode":"A44250955878BB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2227527,"avatar":"https://static001.geekbang.org/account/avatar/00/21/fd/47/499339d1.jpg","nickname":"新味道","note":"","ucode":"979E3574082CE7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":316216,"discussion_content":"你要先去实践一下…\n1.13是可以的  1.15不行  直接死锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603375966,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":315906,"ip_address":""},"score":316216,"extra":""},{"author":{"id":1024364,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a1/6c/241758d1.jpg","nickname":"Meng小羽","note":"","ucode":"C5E322F5DDCF12","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1649662,"avatar":"https://static001.geekbang.org/account/avatar/00/19/2b/fe/7925eb7e.jpg","nickname":"pdf","note":"","ucode":"A44250955878BB","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":318359,"discussion_content":"sleep 设置时间长一点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603717687,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":316216,"ip_address":""},"score":318359,"extra":""},{"author":{"id":1649662,"avatar":"https://static001.geekbang.org/account/avatar/00/19/2b/fe/7925eb7e.jpg","nickname":"pdf","note":"","ucode":"A44250955878BB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1024364,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a1/6c/241758d1.jpg","nickname":"Meng小羽","note":"","ucode":"C5E322F5DDCF12","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318378,"discussion_content":"chan waitgroup","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603720273,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":318359,"ip_address":""},"score":318378,"extra":""}]}]},{"had_liked":false,"id":255154,"user_name":"橙子888","can_delete":false,"product_type":"c1","uid":1447790,"ip_address":"","ucode":"8FB8A9AAE526E3","user_header":"https://static001.geekbang.org/account/avatar/00/16/17/6e/76b4aa3d.jpg","comment_is_top":false,"comment_ctime":1603274555,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603274555","product_id":100061801,"comment_content":"又是一个需要花时间消化的章节，理解读写锁的原理之后，再参考之前 Mutex 章节扩展的实现，写一个扩展的读写锁应该不难，惊讶地发现已经有大佬给出答案了……","like_count":0}]}