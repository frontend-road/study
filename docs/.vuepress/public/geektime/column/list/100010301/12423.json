{"id":12423,"title":"【工具篇】 常用工具介绍","content":"<p>在前面的文章中，我曾使用了不少工具来辅助讲解，也收到了不少同学留言，说不了解这些工具，不知道都有什么用，应该怎么用。那么今天我便统一做一次具体的介绍。本篇代码较多，你可以点击文稿查看。</p>\n<h2>javap：查阅Java字节码</h2>\n<p>javap是一个能够将class文件反汇编成人类可读格式的工具。在本专栏中，我们经常借助这个工具来查阅Java字节码。</p>\n<p>举个例子，在讲解异常处理那一篇中，我曾经展示过这么一段代码。</p>\n<pre><code>public class Foo {\n  private int tryBlock;\n  private int catchBlock;\n  private int finallyBlock;\n  private int methodExit;\n\n  public void test() {\n    try {\n      tryBlock = 0;\n    } catch (Exception e) {\n      catchBlock = 1;\n    } finally {\n      finallyBlock = 2;\n    }\n    methodExit = 3;\n  }\n}\n</code></pre>\n<p>编译过后，我们便可以使用javap来查阅Foo.test方法的字节码。</p>\n<pre><code>$ javac Foo.java\n$ javap -p -v Foo\nClassfile ../Foo.class\n  Last modified ..; size 541 bytes\n  MD5 checksum 3828cdfbba56fea1da6c8d94fd13b20d\n  Compiled from &quot;Foo.java&quot;\npublic class Foo\n  minor version: 0\n  major version: 54\n  flags: (0x0021) ACC_PUBLIC, ACC_SUPER\n  this_class: #7                          // Foo\n  super_class: #8                         // java/lang/Object\n  interfaces: 0, fields: 4, methods: 2, attributes: 1\nConstant pool:\n   #1 = Methodref          #8.#23         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V\n   #2 = Fieldref           #7.#24         // Foo.tryBlock:I\n   #3 = Fieldref           #7.#25         // Foo.finallyBlock:I\n   #4 = Class              #26            // java/lang/Exception\n   #5 = Fieldref           #7.#27         // Foo.catchBlock:I\n   #6 = Fieldref           #7.#28         // Foo.methodExit:I\n   #7 = Class              #29            // Foo\n   #8 = Class              #30            // java/lang/Object\n   #9 = Utf8               tryBlock\n  #10 = Utf8               I\n  #11 = Utf8               catchBlock\n  #12 = Utf8               finallyBlock\n  #13 = Utf8               methodExit\n  #14 = Utf8               &lt;init&gt;\n  #15 = Utf8               ()V\n  #16 = Utf8               Code\n  #17 = Utf8               LineNumberTable\n  #18 = Utf8               test\n  #19 = Utf8               StackMapTable\n  #20 = Class              #31            // java/lang/Throwable\n  #21 = Utf8               SourceFile\n  #22 = Utf8               Foo.java\n  #23 = NameAndType        #14:#15        // &quot;&lt;init&gt;&quot;:()V\n  #24 = NameAndType        #9:#10         // tryBlock:I\n  #25 = NameAndType        #12:#10        // finallyBlock:I\n  #26 = Utf8               java/lang/Exception\n  #27 = NameAndType        #11:#10        // catchBlock:I\n  #28 = NameAndType        #13:#10        // methodExit:I\n  #29 = Utf8               Foo\n  #30 = Utf8               java/lang/Object\n  #31 = Utf8               java/lang/Throwable\n{\n  private int tryBlock;\n    descriptor: I\n    flags: (0x0002) ACC_PRIVATE\n\n  private int catchBlock;\n    descriptor: I\n    flags: (0x0002) ACC_PRIVATE\n\n  private int finallyBlock;\n    descriptor: I\n    flags: (0x0002) ACC_PRIVATE\n\n  private int methodExit;\n    descriptor: I\n    flags: (0x0002) ACC_PRIVATE\n\n  public Foo();\n    descriptor: ()V\n    flags: (0x0001) ACC_PUBLIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V\n         4: return\n      LineNumberTable:\n        line 1: 0\n\n  public void test();\n    descriptor: ()V\n    flags: (0x0001) ACC_PUBLIC\n    Code:\n      stack=2, locals=3, args_size=1\n         0: aload_0\n         1: iconst_0\n         2: putfield      #2                  // Field tryBlock:I\n         5: aload_0\n         6: iconst_2\n         7: putfield      #3                  // Field finallyBlock:I\n        10: goto          35\n        13: astore_1\n        14: aload_0\n        15: iconst_1\n        16: putfield      #5                  // Field catchBlock:I\n        19: aload_0\n        20: iconst_2\n        21: putfield      #3                  // Field finallyBlock:I\n        24: goto          35\n        27: astore_2\n        28: aload_0\n        29: iconst_2\n        30: putfield      #3                  // Field finallyBlock:I\n        33: aload_2\n        34: athrow\n        35: aload_0\n        36: iconst_3\n        37: putfield      #6                  // Field methodExit:I\n        40: return\n      Exception table:\n         from    to  target type\n             0     5    13   Class java/lang<!-- [[[read_end]]] -->/Exception\n             0     5    27   any\n            13    19    27   any\n      LineNumberTable:\n        line 9: 0\n        line 13: 5\n        line 14: 10\n        line 10: 13\n        line 11: 14\n        line 13: 19\n        line 14: 24\n        line 13: 27\n        line 14: 33\n        line 15: 35\n        line 16: 40\n      StackMapTable: number_of_entries = 3\n        frame_type = 77 /* same_locals_1_stack_item */\n          stack = [ class java/lang/Exception ]\n        frame_type = 77 /* same_locals_1_stack_item */\n          stack = [ class java/lang/Throwable ]\n        frame_type = 7 /* same */\n}\nSourceFile: &quot;Foo.java&quot;\n</code></pre>\n<p>这里面我用到了两个选项。第一个选项是-p。默认情况下javap会打印所有非私有的字段和方法，当加了-p选项后，它还将打印私有的字段和方法。第二个选项是-v。它尽可能地打印所有信息。如果你只需要查阅方法对应的字节码，那么可以用-c选项来替换-v。</p>\n<p>javap的-v选项的输出分为几大块。</p>\n<p>1.基本信息，涵盖了原class文件的相关信息。</p>\n<p>class文件的版本号（minor version: 0，major version: 54），该类的访问权限（flags: (0x0021) ACC_PUBLIC, ACC_SUPER），该类（this_class: #7）以及父类（super_class: #8）的名字，所实现接口（interfaces: 0）、字段（fields: 4）、方法（methods: 2）以及属性（attributes: 1）的数目。</p>\n<p>这里属性指的是class文件所携带的辅助信息，比如该class文件的源文件的名称。这类信息通常被用于Java虚拟机的验证和运行，以及Java程序的调试，一般无须深入了解。</p>\n<pre><code>Classfile ../Foo.class\n  Last modified ..; size 541 bytes\n  MD5 checksum 3828cdfbba56fea1da6c8d94fd13b20d\n  Compiled from &quot;Foo.java&quot;\npublic class Foo\n  minor version: 0\n  major version: 54\n  flags: (0x0021) ACC_PUBLIC, ACC_SUPER\n  this_class: #7                          // Foo\n  super_class: #8                         // java/lang/Object\n  interfaces: 0, fields: 4, methods: 2, attributes: 1\n</code></pre>\n<p>class文件的版本号指的是编译生成该class文件时所用的JRE版本。由较新的JRE版本中的javac编译而成的class文件，不能在旧版本的JRE上跑，否则，会出现如下异常信息。（Java 8对应的版本号为52，Java 10对应的版本号为54。）</p>\n<pre><code>Exception in thread &quot;main&quot; java.lang.UnsupportedClassVersionError: Foo has been compiled by a more recent version of the Java Runtime (class file version 54.0), this version of the Java Runtime only recognizes class file versions up to 52.0\n</code></pre>\n<p>类的访问权限通常为ACC_开头的常量。具体每个常量的意义可以查阅Java虚拟机规范4.1小节[1]。</p>\n<p>2.常量池，用来存放各种常量以及符号引用。</p>\n<p>常量池中的每一项都有一个对应的索引（如#1），并且可能引用其他的常量池项（#1 = Methodref #8.#23）。</p>\n<pre><code>Constant pool:\n   #1 = Methodref          #8.#23         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V\n... \n   #8 = Class              #30            // java/lang/Object\n...\n  #14 = Utf8               &lt;init&gt;\n  #15 = Utf8               ()V\n...\n  #23 = NameAndType        #14:#15        // &quot;&lt;init&gt;&quot;:()V\n...\n  #30 = Utf8               java/lang/Object\n</code></pre>\n<p>举例来说，上图中的1号常量池项是一个指向Object类构造器的符号引用。它是由另外两个常量池项所构成。如果将它看成一个树结构的话，那么它的叶节点会是字符串常量，如下图所示。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/f8/8c/f87469e321c52b21b0d2abb88e7b288c.png?wh=1732*670\" alt=\"\" /></p>\n<p>3.字段区域，用来列举该类中的各个字段。</p>\n<p>这里最主要的信息便是该字段的类型（descriptor: I）以及访问权限（flags: (0x0002) ACC_PRIVATE）。对于声明为final的静态字段而言，如果它是基本类型或者字符串类型，那么字段区域还将包括它的常量值。</p>\n<pre><code>  private int tryBlock;\n    descriptor: I\n    flags: (0x0002) ACC_PRIVATE\n\n</code></pre>\n<p>另外，Java虚拟机同样使用了“描述符”（descriptor）来描述字段的类型。具体的对照如下表所示。其中比较特殊的，我已经高亮显示。</p>\n<p>4.方法区域，用来列举该类中的各个方法。</p>\n<p>除了方法描述符以及访问权限之外，每个方法还包括最为重要的代码区域（Code:)。</p>\n<pre><code>  public void test();\n    descriptor: ()V\n    flags: (0x0001) ACC_PUBLIC\n    Code:\n      stack=2, locals=3, args_size=1\n         0: aload_0\n...\n        10: goto          35\n...\n        34: athrow\n        35: aload_0\n...\n        40: return\n      Exception table:\n         from    to  target type\n             0     5    13   Class java/lang/Exception\n             0     5    27   any\n            13    19    27   any\n      LineNumberTable:\n        line 9: 0\n...\n        line 16: 40\n      StackMapTable: number_of_entries = 3\n        frame_type = 77 /* same_locals_1_stack_item */\n          stack = [ class java/lang/Exception ]\n...\n</code></pre>\n<p>代码区域一开始会声明该方法中的操作数栈（stack=2）和局部变量数目（locals=3）的最大值，以及该方法接收参数的个数（args_size=1）。注意这里局部变量指的是字节码中的局部变量，而非Java程序中的局部变量。</p>\n<p>接下来则是该方法的字节码。每条字节码均标注了对应的偏移量（bytecode index，BCI），这是用来定位字节码的。比如说偏移量为10的跳转字节码10: goto 35，将跳转至偏移量为35的字节码35: aload_0。</p>\n<p>紧跟着的异常表（Exception table:）也会使用偏移量来定位每个异常处理器所监控的范围（由from到to的代码区域），以及异常处理器的起始位置（target）。除此之外，它还会声明所捕获的异常类型（type）。其中，any指代任意异常类型。</p>\n<p>再接下来的行数表（LineNumberTable:）则是Java源程序到字节码偏移量的映射。如果你在编译时使用了-g参数（javac -g Foo.java），那么这里还将出现局部变量表（LocalVariableTable:），展示Java程序中每个局部变量的名字、类型以及作用域。</p>\n<p>行数表和局部变量表均属于调试信息。Java虚拟机并不要求class文件必备这些信息。</p>\n<pre><code>      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n           14       5     1     e   Ljava/lang/Exception;\n            0      41     0  this   LFoo;\n</code></pre>\n<p>最后则是字节码操作数栈的映射表（StackMapTable: number_of_entries = 3）。该表描述的是字节码跳转后操作数栈的分布情况，一般被Java虚拟机用于验证所加载的类，以及即时编译相关的一些操作，正常情况下，你无须深入了解。</p>\n<h2>2.OpenJDK项目Code Tools：实用小工具集</h2>\n<p>OpenJDK的Code Tools项目[2]包含了好几个实用的小工具。</p>\n<p>在第一篇的实践环节中，我们使用了其中的字节码汇编器反汇编器ASMTools[3]，当前6.0版本的下载地址位于[4]。ASMTools的反汇编以及汇编操作所对应的命令分别为：</p>\n<pre><code>$ java -cp /path/to/asmtools.jar org.openjdk.asmtools.jdis.Main Foo.class &gt; Foo.jasm\n</code></pre>\n<p>和</p>\n<pre><code>$ java -cp /path/to/asmtools.jar org.openjdk.asmtools.jasm.Main Foo.jasm\n</code></pre>\n<p>该反汇编器的输出格式和javap的不尽相同。一般我只使用它来进行一些简单的字节码修改，以此生成无法直接由Java编译器生成的类，它在HotSpot虚拟机自身的测试中比较常见。</p>\n<p>在第一篇的实践环节中，我们需要将整数2赋值到一个声明为boolean类型的局部变量中。我采取的做法是将编译生成的class文件反汇编至一个文本文件中，然后找到boolean flag = true对应的字节码序列，也就是下面的两个。</p>\n<pre><code>iconst_1;\nistore_1;\n</code></pre>\n<p>将这里的iconst_1改为iconst_2[5]，保存后再汇编至class文件即可完成第一篇实践环节的需求。</p>\n<p>除此之外，你还可以利用这一套工具来验证我之前文章中的一些结论。比如我说过class文件允许出现参数类型相同、而返回类型不同的方法，并且，在作为库文件时Java编译器将使用先定义的那一个，来决定具体的返回类型。</p>\n<p>具体的验证方法便是在反汇编之后，利用文本编辑工具复制某一方法，并且更改该方法的描述符，保存后再汇编至class文件。</p>\n<p>Code Tools项目还包含另一个实用的小工具JOL[6]，当前0.9版本的下载地址位于[7]。JOL可用于查阅Java虚拟机中对象的内存分布，具体可通过如下两条指令来实现。</p>\n<pre><code>$ java -jar /path/to/jol-cli-0.9-full.jar internals java.util.HashMap\n$ java -jar /path/to/jol-cli-0.9-full.jar estimates java.util.HashMap\n</code></pre>\n<h2>3.ASM：Java字节码框架</h2>\n<p>ASM[8]是一个字节码分析及修改框架。它被广泛应用于许多项目之中，例如Groovy、Kotlin的编译器，代码覆盖测试工具Cobertura、JaCoCo，以及各式各样通过字节码注入实现的程序行为监控工具。甚至是Java 8中Lambda表达式的适配器类，也是借助ASM来动态生成的。</p>\n<p>ASM既可以生成新的class文件，也可以修改已有的class文件。前者相对比较简单一些。ASM甚至还提供了一个辅助类ASMifier，它将接收一个class文件并且输出一段生成该class文件原始字节数组的代码。如果你想快速上手ASM的话，那么你可以借助ASMifier生成的代码来探索各个API的用法。</p>\n<p>下面我将借助ASMifier，来生成第一篇实践环节所用到的类。（你可以通过该地址[9]下载6.0-beta版。）</p>\n<pre><code>$ echo '\npublic class Foo {\n public static void main(String[] args) {\n  boolean flag = true;\n  if (flag) System.out.println(&quot;Hello, Java!&quot;);\n  if (flag == true) System.out.println(&quot;Hello, JVM!&quot;);\n }\n}' &gt; Foo.java\n# 这里的javac我使用的是Java 8版本的。ASM 6.0可能暂不支持新版本的javac编译出来的class文件\n$ javac Foo.java\n$ java -cp /PATH/TO/asm-all-6.0_BETA.jar org.objectweb.asm.util.ASMifier Foo.class | tee FooDump.java\n...\npublic class FooDump implements Opcodes {\n\npublic static byte[] dump () throws Exception {\n\nClassWriter cw = new ClassWriter(0);\nFieldVisitor fv;\nMethodVisitor mv;\nAnnotationVisitor av0;\n\ncw.visit(V1_8, ACC_PUBLIC + ACC_SUPER, &quot;Foo&quot;, null, &quot;java/lang/Object&quot;, null);\n\n...\n\n{\nmv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, &quot;main&quot;, &quot;([Ljava/lang/String;)V&quot;, null, null);\nmv.visitCode();\nmv.visitInsn(ICONST_1);\nmv.visitVarInsn(ISTORE, 1);\nmv.visitVarInsn(ILOAD, 1);\n...\nmv.visitInsn(RETURN);\nmv.visitMaxs(2, 2);\nmv.visitEnd();\n}\n...\n</code></pre>\n<p>可以看到，ASMifier生成的代码中包含一个名为FooDump的类，其中定义了一个名为dump的方法。该方法将返回一个byte数组，其值为生成类的原始字节。</p>\n<p>在dump方法中，我们新建了功能类ClassWriter的一个实例，并通过它来访问不同的成员，例如方法、字段等等。</p>\n<p>每当访问一种成员，我们便会得到另一个访问者。在上面这段代码中，当我们访问方法时（即visitMethod），便会得到一个MethodVisitor。在接下来的代码中，我们会用这个MethodVisitor来访问（这里等同于生成）具体的指令。</p>\n<p>这便是ASM所使用的访问者模式。当然，这段代码仅包含ClassWriter这一个访问者，因此看不出具体有什么好处。</p>\n<p>我们暂且不管这个访问者模式，先来看看如何实现第一篇课后实践的要求。首先，main方法中的boolean flag = true;语句对应的代码是：</p>\n<pre><code>mv.visitInsn(ICONST_1);\nmv.visitVarInsn(ISTORE, 1);\n</code></pre>\n<p>也就是说，我们只需将这里的ICONST_1更改为ICONST_2，便可以满足要求。下面我用另一个类Wrapper，来调用修改过后的FooDump.dump方法。</p>\n<pre><code>$ echo 'import java.nio.file.*;\n\npublic class Wrapper {\n  public static void main(String[] args) throws Exception {\n    Files.write(Paths.get(&quot;Foo.class&quot;), FooDump.dump());\n  }\n}' &gt; Wrapper.java\n$ javac -cp /PATH/TO/asm-all-6.0_BETA.jar FooDump.java Wrapper.java\n$ java -cp /PATH/TO/asm-all-6.0_BETA.jar:. Wrapper\n$ java Foo\n</code></pre>\n<p>这里的输出结果应和通过ASMTools修改的结果一致。</p>\n<p>通过ASM来修改已有class文件则相对复杂一些。不过我们可以从下面这段简单的代码来开始学起：</p>\n<pre><code>  public static void main(String[] args) throws Exception {\n    ClassReader cr = new ClassReader(&quot;Foo&quot;);\n    ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);\n    cr.accept(cw, ClassReader.SKIP_FRAMES);\n    Files.write(Paths.get(&quot;Foo.class&quot;), cw.toByteArray());\n  }\n</code></pre>\n<p>这段代码的功能便是读取一个class文件，将之转换为ASM的数据结构，然后再转换为原始字节数组。其中，我使用了两个功能类。除了已经介绍过的ClassWriter外，还有一个ClassReader。</p>\n<p>ClassReader将读取“Foo”类的原始字节，并且翻译成对应的访问请求。也就是说，在上面ASMifier生成的代码中的各个访问操作，现在都交给ClassReader.accept这一方法来发出了。</p>\n<p>那么，如何修改这个class文件的字节码呢？原理很简单，就是将ClassReader的访问请求发给另外一个访问者，再由这个访问者委派给ClassWriter。</p>\n<p>这样一来，新增操作可以通过在某一需要转发的请求后面附带新的请求来实现；删除操作可以通过不转发请求来实现；修改操作可以通过忽略原请求，新建并发出另外的请求来实现。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/2a/ce/2a5d6813e32b8f88abae2b9f7b151fce.png?wh=1822*610\" alt=\"\" /></p>\n<pre><code>import java.nio.file.*;\nimport org.objectweb.asm.*;\n\npublic class ASMHelper implements Opcodes {\n\n  static class MyMethodVisitor extends MethodVisitor {\n    private MethodVisitor mv;\n    public MyMethodVisitor(int api, MethodVisitor mv) {\n      super(api, null);\n      this.mv = mv;\n    }\n\n    @Override\n    public void visitCode() {\n      mv.visitCode();\n      mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);\n      mv.visitLdcInsn(&quot;Hello, World!&quot;);\n      mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false);\n      mv.visitInsn(RETURN);\n      mv.visitMaxs(2, 1);\n      mv.visitEnd();\n    }\n  }\n\n  static class MyClassVisitor extends ClassVisitor {\n\n    public MyClassVisitor(int api, ClassVisitor cv) {\n      super(api, cv);\n    }\n\n    @Override\n    public MethodVisitor visitMethod(int access, String name, String descriptor, String signature,\n        String[] exceptions) {\n      MethodVisitor visitor = super.visitMethod(access, name, descriptor, signature, exceptions);\n      if (&quot;main&quot;.equals(name)) {\n        return new MyMethodVisitor(ASM6, visitor);\n      }\n      return visitor;\n    }\n  }\n\n  public static void main(String[] args) throws Exception {\n    ClassReader cr = new ClassReader(&quot;Foo&quot;);\n    ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);\n    ClassVisitor cv = new MyClassVisitor(ASM6, cw);\n    cr.accept(cv, ClassReader.SKIP_FRAMES);\n    Files.write(Paths.get(&quot;Foo.class&quot;), cw.toByteArray());\n  }\n}\n</code></pre>\n<p>这里我贴了一段代码，在ClassReader和ClassWriter中间插入了一个自定义的访问者MyClassVisitor。它将截获由ClassReader发出的对名字为“main”的方法的访问请求，并且替换为另一个自定义的MethodVisitor。</p>\n<p>这个MethodVisitor会忽略由ClassReader发出的任何请求，仅在遇到visitCode请求时，生成一句“System.out.println(“Hello World!”);”。</p>\n<p>由于篇幅的限制，我就不继续深入介绍下去了。如果你对ASM有浓厚的兴趣，可以参考这篇教程[10]。</p>\n<p>你对这些常用工具还有哪些问题呢？可以给我留言，我们一起讨论。感谢你的收听，我们下期再见。</p>\n<p>[1]<br />\n<a href=\"https://docs.oracle.com/javase/specs/jvms/se10/html/jvms-4.html#jvms-4.1\">https://docs.oracle.com/javase/specs/jvms/se10/html/jvms-4.html#jvms-4.1</a><br />\n[2]<br />\n<a href=\"http://openjdk.java.net/projects/code-tools/\">http://openjdk.java.net/projects/code-tools/</a><br />\n[3]<br />\n<a href=\"https://wiki.openjdk.java.net/display/CodeTools/asmtools\">https://wiki.openjdk.java.net/display/CodeTools/asmtools</a><br />\n[4]<br />\n<a href=\"https://adopt-openjdk.ci.cloudbees.com/view/OpenJDK/job/asmtools/lastSuccessfulBuild/artifact/asmtools-6.0.tar.gz\">https://adopt-openjdk.ci.cloudbees.com/view/OpenJDK/job/asmtools/lastSuccessfulBuild/artifact/asmtools-6.0.tar.gz</a><br />\n[5]<br />\n<a href=\"https://cs.au.dk/~mis/dOvs/jvmspec/ref--21.html\">https://cs.au.dk/~mis/dOvs/jvmspec/ref--21.html</a><br />\n[6]<br />\n<a href=\"http://openjdk.java.net/projects/code-tools/jol/\">http://openjdk.java.net/projects/code-tools/jol/</a><br />\n[7]<br />\n<a href=\"http://central.maven.org/maven2/org/openjdk/jol/jol-cli/0.9/jol-cli-0.9-full.jar\">http://central.maven.org/maven2/org/openjdk/jol/jol-cli/0.9/jol-cli-0.9-full.jar</a><br />\n[8]<br />\n<a href=\"https://asm.ow2.io/\">https://asm.ow2.io/</a><br />\n[9]<br />\n<a href=\"https://repository.ow2.org/nexus/content/repositories/releases/org/ow2/asm/asm-all/6.0_BETA/asm-all-6.0_BETA.jar\">https://repository.ow2.org/nexus/content/repositories/releases/org/ow2/asm/asm-all/6.0_BETA/asm-all-6.0_BETA.jar</a><br />\n[10]<br />\n<a href=\"http://web.cs.ucla.edu/~msb/cs239-tutorial/\">http://web.cs.ucla.edu/~msb/cs239-tutorial/</a></p>\n<p></p>\n","neighbors":{"left":{"article_title":"12 | 垃圾回收（下）","id":13137},"right":{"article_title":"13 | Java内存模型","id":13484}},"comments":[{"had_liked":false,"id":18462,"user_name":"刹那间的永恒","can_delete":false,"product_type":"c1","uid":1114738,"ip_address":"","ucode":"DAB8A1BE22C4EC","user_header":"https://static001.geekbang.org/account/avatar/00/11/02/72/6933412b.jpg","comment_is_top":false,"comment_ctime":1533343933,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"242051512509","product_id":100010301,"comment_content":"果然还是一点都看不懂，老师，什么阶段适合接触虚拟机？","like_count":57,"discussions":[{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":178632,"discussion_content":"找工作、性能调优的时候需要","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1582183512,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1549032,"avatar":"","nickname":"Zzz","note":"","ucode":"9323254354868B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":243985,"discussion_content":"先把java用熟，要有一定的编码经验，理解常用的源码原理吧，我觉得","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1587566401,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1161271,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","nickname":"不似旧日","note":"","ucode":"DF4C5E3AB9570C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":227590,"discussion_content":"我也是没看懂, 就知道javap了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586504724,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1881153,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/b4/41/82ac102c.jpg","nickname":"Geek","note":"","ucode":"740790D3686F8E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1161271,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","nickname":"不似旧日","note":"","ucode":"DF4C5E3AB9570C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299610,"discussion_content":"一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597749208,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":227590,"ip_address":""},"score":299610,"extra":""}]},{"author":{"id":2436106,"avatar":"https://static001.geekbang.org/account/avatar/00/25/2c/0a/61f4a0c3.jpg","nickname":"汪彬英","note":"","ucode":"6E8B21E39BFE6D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581360,"discussion_content":"没看懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658741916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20833,"user_name":"xiaobang","can_delete":false,"product_type":"c1","uid":1157508,"ip_address":"","ucode":"1735BDCFD61655","user_header":"https://static001.geekbang.org/account/avatar/00/11/a9/84/c87b51ce.jpg","comment_is_top":false,"comment_ctime":1534767592,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"35894505960","product_id":100010301,"comment_content":"能系统的介绍下Java字节码吗，每次看到都是靠猜","like_count":9,"discussions":[{"author":{"id":1451728,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKDfy7icjzBBUwQDA3ovYUqSX4gT27UryDic79Dj9lrbRibt8DCbz8xb4EvSMmACiaI2xkIdvgwByW1GQ/132","nickname":"Geek_3a0800","note":"","ucode":"F4F5C8E1FD917F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347708,"discussion_content":"字节码相关的知识点太多了 我现在也在学 可以看看jvm标准文档","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612314405,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":18435,"user_name":"Thomas","can_delete":false,"product_type":"c1","uid":1178585,"ip_address":"","ucode":"36950010DB3D29","user_header":"https://static001.geekbang.org/account/avatar/00/11/fb/d9/055e5383.jpg","comment_is_top":false,"comment_ctime":1533305208,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31598076280","product_id":100010301,"comment_content":"老师后面讲下反射跟动态代理～很期待专门写一篇JAVA特性的原理。","like_count":8},{"had_liked":false,"id":148063,"user_name":"男朋友","can_delete":false,"product_type":"c1","uid":1401707,"ip_address":"","ucode":"9818176E0BBD31","user_header":"https://static001.geekbang.org/account/avatar/00/15/63/6b/34b89fae.jpg","comment_is_top":false,"comment_ctime":1572935307,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14457837195","product_id":100010301,"comment_content":"描述符的那个表我怎么看不见<br>","like_count":4,"discussions":[{"author":{"id":1245468,"avatar":"https://static001.geekbang.org/account/avatar/00/13/01/1c/d638d46e.jpg","nickname":"宋世通","note":"","ucode":"C7AA3F0E6930F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390319,"discussion_content":"https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html jvm规范可以找到\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629775672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":18419,"user_name":"雨亦奇","can_delete":false,"product_type":"c1","uid":1182553,"ip_address":"","ucode":"90E2182C70B99A","user_header":"https://static001.geekbang.org/account/avatar/00/12/0b/59/08065309.jpg","comment_is_top":false,"comment_ctime":1533297963,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14418199851","product_id":100010301,"comment_content":"666<br>","like_count":4},{"had_liked":false,"id":67438,"user_name":"王浩","can_delete":false,"product_type":"c1","uid":1229190,"ip_address":"","ucode":"EF4CFD45533803","user_header":"https://static001.geekbang.org/account/avatar/00/12/c1/86/afd6e862.jpg","comment_is_top":false,"comment_ctime":1550146923,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10140081515","product_id":100010301,"comment_content":"看了一遍没看没白,建议多讲些细节,比如如何使用javap查看字节码,说详细些,各种工具的特点是什么,最常用的工具是哪个,在什么场景下使用。","like_count":3},{"had_liked":false,"id":20832,"user_name":"xiaobang","can_delete":false,"product_type":"c1","uid":1157508,"ip_address":"","ucode":"1735BDCFD61655","user_header":"https://static001.geekbang.org/account/avatar/00/11/a9/84/c87b51ce.jpg","comment_is_top":false,"comment_ctime":1534767470,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10124702062","product_id":100010301,"comment_content":"能系统介绍下Java字节码吗？每次都是靠猜","like_count":2,"discussions":[{"author":{"id":1227107,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b9/63/a3b11794.jpg","nickname":"麦抠","note":"","ucode":"875DEA26F38BAB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":246949,"discussion_content":"自己搜索呗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587789726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":18395,"user_name":"hey,吕布","can_delete":false,"product_type":"c1","uid":1021211,"ip_address":"","ucode":"DC045CD01597D3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/95/1b/ca2023e6.jpg","comment_is_top":false,"comment_ctime":1533289769,"is_pvip":false,"replies":[{"id":"6443","content":"这么诡异，我反馈一下","user_name":"作者回复","comment_id":18395,"uid":"1176688","ip_address":"","utype":1,"ctime":1533310270,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"10123224361","product_id":100010301,"comment_content":"老师，文中代码格式异常了，早上打开还好的","like_count":2,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421507,"discussion_content":"这么诡异，我反馈一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1533310270,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140708,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1571035722,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5866003018","product_id":100010301,"comment_content":"java -cp &#47;PATH&#47;TO&#47;asm-all-6.0_BETA.jar:. Wrapper <br>在windows需要将冒号换为分号，虽然很基础，我给忘了。。。<br>https:&#47;&#47;www.programcreek.com&#47;2014&#47;01&#47;compile-and-run-java-in-command-line-with-external-jars&#47;","like_count":1},{"had_liked":false,"id":140707,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1571035287,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5866002583","product_id":100010301,"comment_content":"我觉得看完周志明老师的深入理解Java虚拟机，再来看郑老师的专栏是比较合适的。","like_count":1},{"had_liked":false,"id":20688,"user_name":"曲东方","can_delete":false,"product_type":"c1","uid":1177819,"ip_address":"","ucode":"6C3EA2F47A0B98","user_header":"https://static001.geekbang.org/account/avatar/00/11/f8/db/c4edf697.jpg","comment_is_top":false,"comment_ctime":1534671166,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5829638462","product_id":100010301,"comment_content":"ClassWriter继承并实现了虚基类ClassVisitor，实现了一系列的vist*方法(读取class信息至内存)<br><br><br>MyClassVisitor继承ClassWriter，只复写(Override)了visitMethod方法，当且仅当方法名称等于main时，才替换用自定义内容替换<br><br><br>整个逻辑等于说，读Foo.class到内存中，重新写一个Foo.class文件，main方法替换为&quot;新内容&quot;，其他保持不变<br><br><br><br>","like_count":1},{"had_liked":false,"id":19105,"user_name":"郑童文","can_delete":false,"product_type":"c1","uid":1030733,"ip_address":"","ucode":"3D193715CB8549","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/4d/7ba09ff0.jpg","comment_is_top":false,"comment_ctime":1533685864,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5828653160","product_id":100010301,"comment_content":"我不太明白 用ASM反汇编class 文件 之后不就改得到java源文件吗？为什么还有java 之外的关键字?","like_count":1},{"had_liked":false,"id":18378,"user_name":"倔强","can_delete":false,"product_type":"c1","uid":1177878,"ip_address":"","ucode":"849B0BA1AC7E29","user_header":"https://static001.geekbang.org/account/avatar/00/11/f9/16/99a7045d.jpg","comment_is_top":false,"comment_ctime":1533278178,"is_pvip":false,"replies":[{"id":"6397","content":"多谢指出！应该是Wrapper，而且cp也需要添加当前目录，即-cp &#47;path&#47;to&#47;ASM.jar:. Wrapper<br><br>","user_name":"作者回复","comment_id":18378,"uid":"1176688","ip_address":"","utype":1,"ctime":1533286402,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"5828245474","product_id":100010301,"comment_content":"为什么我允许F oo Dump报无法加载主类?是因为没有main方法?","like_count":1,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421496,"discussion_content":"多谢指出！应该是Wrapper，而且cp也需要添加当前目录，即-cp /path/to/ASM.jar:. Wrapper\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1533286402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":18291,"user_name":"xianhai","can_delete":false,"product_type":"c1","uid":1073505,"ip_address":"","ucode":"906578663CEB3E","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/61/677e8f92.jpg","comment_is_top":false,"comment_ctime":1533247588,"is_pvip":false,"replies":[{"id":"6433","content":"在第三部分我会介绍一些常用的分析工具。看Metaspace的话可以试试通过jmap -clstats 来查看各个类的情况。我个人用的比较多的是flight recorder，不过我记得只能查看总的Metaspace使用量。","user_name":"作者回复","comment_id":18291,"uid":"1176688","ip_address":"","utype":1,"ctime":1533302131,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"5828214884","product_id":100010301,"comment_content":"能不能介绍一下metaspace的tracing 工具？怎样看metaspace里的内存分布？<br>","like_count":2,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421461,"discussion_content":"在第三部分我会介绍一些常用的分析工具。看Metaspace的话可以试试通过jmap -clstats 来查看各个类的情况。我个人用的比较多的是flight recorder，不过我记得只能查看总的Metaspace使用量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1533302131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222110,"user_name":"李飞","can_delete":false,"product_type":"c1","uid":1555180,"ip_address":"","ucode":"930458850AA05B","user_header":"https://static001.geekbang.org/account/avatar/00/17/ba/ec/2b1c6afc.jpg","comment_is_top":false,"comment_ctime":1590678244,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590678244","product_id":100010301,"comment_content":"很底层的东西，只能自己通过实践加深认识了","like_count":1},{"had_liked":false,"id":173658,"user_name":"若罹","can_delete":false,"product_type":"c1","uid":1514257,"ip_address":"","ucode":"E2209CC33F714A","user_header":"https://static001.geekbang.org/account/avatar/00/17/1b/11/9d7bcbf7.jpg","comment_is_top":false,"comment_ctime":1579654749,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1579654749","product_id":100010301,"comment_content":"另外，Java 虚拟机同样使用了“描述符”（descriptor）来描述字段的类型。具体的对照如下表所示。其中比较特殊的，我已经高亮显示。<br>老师，这里没有看到您说的表，是不是漏了","like_count":0,"discussions":[{"author":{"id":1245468,"avatar":"https://static001.geekbang.org/account/avatar/00/13/01/1c/d638d46e.jpg","nickname":"宋世通","note":"","ucode":"C7AA3F0E6930F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390318,"discussion_content":"https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html  jvm规范可以找到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629775655,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101902,"user_name":"我家门前有只猪","can_delete":false,"product_type":"c1","uid":1488035,"ip_address":"","ucode":"F8CF618CF4681E","user_header":"https://static001.geekbang.org/account/avatar/00/16/b4/a3/a159ca86.jpg","comment_is_top":false,"comment_ctime":1560044812,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560044812","product_id":100010301,"comment_content":"请问一下老师学这个需要先回Linus系统吗？","like_count":0},{"had_liked":false,"id":89406,"user_name":"capo","can_delete":false,"product_type":"c1","uid":1178016,"ip_address":"","ucode":"6FD72DA5DBC220","user_header":"https://static001.geekbang.org/account/avatar/00/11/f9/a0/2240fb2c.jpg","comment_is_top":false,"comment_ctime":1556165647,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556165647","product_id":100010301,"comment_content":"你好,代码ASMHelper.java中 MethodVisitor ClassVIsitor 应该都是Interface吧？super.visitMethod怎么调用的？","like_count":0},{"had_liked":false,"id":77083,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1552830963,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552830963","product_id":100010301,"comment_content":"这里有点隐晦难懂","like_count":0},{"had_liked":false,"id":43850,"user_name":"xuery","can_delete":false,"product_type":"c1","uid":1027584,"ip_address":"","ucode":"F461B61BE06131","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/00/025f37e7.jpg","comment_is_top":false,"comment_ctime":1543309338,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1543309338","product_id":100010301,"comment_content":"仔细看了下教程[10], 更加深刻的理解了如何通过修改字节码文件来达到修改类的效果，感谢，坚持深挖下去","like_count":0},{"had_liked":false,"id":36538,"user_name":"bgmall","can_delete":false,"product_type":"c1","uid":1068926,"ip_address":"","ucode":"F07665E471CF1E","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/7e/4a053154.jpg","comment_is_top":false,"comment_ctime":1541144640,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541144640","product_id":100010301,"comment_content":"javap 查看class文件<br><br>基础md5 jdk版本<br><br>常量池<br><br>字段描述 访问权限<br><br>方法代码栈<br><br>异常表(有异常捕获的才有)","like_count":0},{"had_liked":false,"id":34168,"user_name":"sgl","can_delete":false,"product_type":"c1","uid":1252243,"ip_address":"","ucode":"D73875BA22954F","user_header":"https://static001.geekbang.org/account/avatar/00/13/1b/93/e3b44969.jpg","comment_is_top":false,"comment_ctime":1540027635,"is_pvip":false,"replies":[{"id":"12759","content":"putfield 可以想成 出栈再消耗数据","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1540821735,"ip_address":"","comment_id":34168,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540027635","product_id":100010301,"comment_content":"为什么方法里用的指令只有入栈，没有出栈？难道putfield这类指令，用了操作数栈上的数据以后，会自己调用出栈指令？","like_count":1,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427141,"discussion_content":"putfield 可以想成 出栈再消耗数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540821735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":23949,"user_name":"猎羽","can_delete":false,"product_type":"c1","uid":1209802,"ip_address":"","ucode":"98A1B456871250","user_header":"https://static001.geekbang.org/account/avatar/00/12/75/ca/15b32bc5.jpg","comment_is_top":false,"comment_ctime":1536728832,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1536728832","product_id":100010301,"comment_content":"写的不错，支持一下","like_count":0},{"had_liked":false,"id":23948,"user_name":"猎羽","can_delete":false,"product_type":"c1","uid":1209802,"ip_address":"","ucode":"98A1B456871250","user_header":"https://static001.geekbang.org/account/avatar/00/12/75/ca/15b32bc5.jpg","comment_is_top":false,"comment_ctime":1536728825,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1536728825","product_id":100010301,"comment_content":"写的不错，支持一下。","like_count":0},{"had_liked":false,"id":18452,"user_name":"xianhai","can_delete":false,"product_type":"c1","uid":1073505,"ip_address":"","ucode":"906578663CEB3E","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/61/677e8f92.jpg","comment_is_top":false,"comment_ctime":1533328862,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1533328862","product_id":100010301,"comment_content":"我的问题是reflection inflation后，jdk会生成字节码和相应的delegation classloader，这部分objects会在metaspace占据一定空间，似乎jvm没办法很好的管理这一部分内存？所以在java7里有个开关关掉这个优化，Dsun.reflect.inflationThreshold=2147483647。这个问题在java8中存在吗？老师熟悉这一点的话就讲讲吧。","like_count":1},{"had_liked":false,"id":18366,"user_name":"志远","can_delete":false,"product_type":"c1","uid":1108762,"ip_address":"","ucode":"11015D14034130","user_header":"https://static001.geekbang.org/account/avatar/00/10/eb/1a/579c941e.jpg","comment_is_top":false,"comment_ctime":1533271587,"is_pvip":false,"replies":[{"id":"6398","content":"1. 你可以通过ASMTools反汇编class文件，再将输出的文本汇编回class文件<br><br>2. 字节码中的局部变量会更多一些，Java编译器会根据需要存储一些非Java程序中的局部变量","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1533287469,"ip_address":"","comment_id":18366,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1533271587","product_id":100010301,"comment_content":"1.如何汇编至class文件啊？用什么工具？<br>2.字节码的局部变量和java程序中的局部变量有什么区别？","like_count":1,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421490,"discussion_content":"1. 你可以通过ASMTools反汇编class文件，再将输出的文本汇编回class文件\n\n2. 字节码中的局部变量会更多一些，Java编译器会根据需要存储一些非Java程序中的局部变量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1533287469,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":18344,"user_name":"xianhai","can_delete":false,"product_type":"c1","uid":1073505,"ip_address":"","ucode":"906578663CEB3E","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/61/677e8f92.jpg","comment_is_top":false,"comment_ctime":1533263379,"is_pvip":false,"replies":[{"id":"6399","content":"Reflection inflation会生成新的类，理论上是会导致你说的这个错误的。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1533287678,"ip_address":"","comment_id":18344,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1533263379","product_id":100010301,"comment_content":"reflection inflation 会不会造成java 8 metaspace： Outofmemory","like_count":1,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421480,"discussion_content":"Reflection inflation会生成新的类，理论上是会导致你说的这个错误的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1533287678,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":18324,"user_name":"Ivan","can_delete":false,"product_type":"c1","uid":1107171,"ip_address":"","ucode":"1D914D64D3D6C2","user_header":"https://static001.geekbang.org/account/avatar/00/10/e4/e3/b56b31f5.jpg","comment_is_top":false,"comment_ctime":1533257801,"is_pvip":false,"replies":[{"id":"6400","content":"一个是在加载时用javaagent或者JVMTI截获，另外一个是用一些调试器。关于后者，你可以试试JDK中的HotSpot Debugger(HSDB)，在lib&#47;sa-jdi.jar里。","user_name":"作者回复","user_name_real":"郑雨迪","uid":"1176688","ctime":1533288393,"ip_address":"","comment_id":18324,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1533257801","product_id":100010301,"comment_content":"可以在运行时通过class的实例，获取到这个类的源代码或者汇编代码么？或者说怎么查看动态代理生成的类的源代码？","like_count":1,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":421474,"discussion_content":"一个是在加载时用javaagent或者JVMTI截获，另外一个是用一些调试器。关于后者，你可以试试JDK中的HotSpot Debugger(HSDB)，在lib/sa-jdi.jar里。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1533288393,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":18292,"user_name":"kyll","can_delete":false,"product_type":"c1","uid":1103329,"ip_address":"","ucode":"2425DCF5753786","user_header":"https://static001.geekbang.org/account/avatar/00/10/d5/e1/a05a9e22.jpg","comment_is_top":false,"comment_ctime":1533252097,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1533252097","product_id":100010301,"comment_content":"对字节码感兴趣源于Lombok的使用，所以一直有个想法，通过jsr269替换原来需要泛型基类实现的实体增删改查操作。","like_count":0}]}