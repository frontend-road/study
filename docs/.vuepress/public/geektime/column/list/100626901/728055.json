{"id":728055,"title":"15｜tokio编程：在多任务之间操作同一片数据","content":"<p>你好，我是Mike。今天我们一起来学习如何在tokio的多个任务之间共享同一片数据。</p><p>并发任务之间如何共享数据是一个非常重要的课题，在所有语言中都会碰到。不同的语言提供的方案支持不尽相同，比如 Erlang 语言默认只提供消息模型，Golang 也推荐使用 channel 来在并发任务之间进行同步。</p><p>Rust语言考虑到其应用领域的广泛性和多样性，提供了多种机制来达到这一目的，需要我们根据不同的场景自行选择最合适的机制。所以相对来说，Rust在这方面要学的知识点要多一些，好处是它在几乎所有场景中都能做到最好。</p><h2>任务目标</h2><p>定义一个内存数据库db，在不同的子任务中，并发地向这个内存数据库更新数据。</p><h2>潜在问题</h2><p>为了简化问题，我们把 <code>Vec&lt;u32&gt;</code> 当作db。比如这个db中现在有10个数据。</p><pre><code class=\"language-plain\">let mut db: Vec&lt;u32&gt; = vec![1,2,3,4,5,6,7,8,9,10];\n</code></pre><p>现在有两个任务 task_a 和 task_b，它们都想更新db里的第5个元素的数据 db[4]。</p><p>task_a 想把它更新成 50，task_b 想把它更新成 100。这两个任务之间是没有协同机制的，也就是互相不知道对方的存在，更不知道对方要干嘛。于是就可能出现这样的情况，两个任务几乎同时发起更新请求，假如 task_a 领先一点点时间，先把 db[4] 更新成 50 了，但是它得校验一下更新正确了没有，所以它得发起一个索引请求，把 db[4] 的数据取出来看看是不是 50。</p><!-- [[[read_end]]] --><p>但是在task_a去检查 db[4] 的值之前极小的一个时间片段里面，task_b 对db[4]更新操作也发生了，于是db[4] 被更新成了 100。然后 task_a 取回值之后，发现值是 100。很奇怪，并且判断自己没有更新成功这个数据，有可能会再更新一次，再次把 db[4] 置为 50。这又可能对 task_b 的校验机制造成干扰。于是整个系统就开始紊乱了。</p><p>这就是多个任务操作共享数据可能会发生的问题。下面我们看看在Rust中怎么去解决这个问题。</p><h2>方案尝试</h2><p>我们可以先从最简单的思路开始，设计如下方案。</p><h3>方案一：全局变量</h3><p>如果你有其他语言编程经验的话，应该很容易就能想到一个方案，就是利用全局变量来实现多个任务的数据共享。假如我们有一个全局变量 DB，为 <code>Vec&lt;u32&gt;</code> 类型，每个任务都可以访问到这个DB，并可以向里面push数据。</p><p>我们先来试试直接在main函数里对这个DB全局变量进行操作。</p><pre><code class=\"language-plain\">static DB: Vec&lt;u32&gt; = Vec::new();\n\nfn main() {\n&nbsp; &nbsp; DB.push(10);\n}\n</code></pre><p>发现不行，编译会报错：</p><pre><code class=\"language-plain\">error[E0596]: cannot borrow immutable static item `DB` as mutable\n --&gt; src/main.rs:4:5\n  |\n4 |     DB.push(10);\n  |     ^^^^^^^^^^^ cannot borrow as mutable\n</code></pre><p>可能是没加 mut？加上试一试。</p><pre><code class=\"language-plain\">static mut DB: Vec&lt;u32&gt; = Vec::new();\n\nfn main() {\n&nbsp; &nbsp; DB.push(10);\n}\n</code></pre><p>还是出错：</p><pre><code class=\"language-plain\">error[E0133]: use of mutable static is unsafe and requires unsafe function or block\n --&gt; src/main.rs:4:5\n  |\n4 |     DB.push(10);\n  |     ^^^^^^^^^^^ use of mutable static\n  |\n  = note: mutable statics can be mutated by multiple threads: aliasing violations or data races will cause undefined behavior\n</code></pre><p>Rust编译器报错说，要使用可变的静态全局变量是不安全的，需要用到unsafe功能。unsafe功能我们还没讲，而且不是这节课的重点，所以这里不展开。总之，<strong>Rust不推荐我们使用全局（静态）变量</strong>。因为全局变量不是一个好的方案，特别是对于多任务并发程序来说，应该尽可能避免。</p><p>那既然全局变量不能用了，有一个可行的选择是，在 main 函数中创建一个对象实例，把这个实例传给各个任务。因为这个实例是在main函数中创建的，它的生命期跟main函数一样长，所以也相当于全局变量了。</p><h3>方案二：main函数中的对象</h3><p>稍微改一下上面的代码，这下可以了。</p><pre><code class=\"language-plain\">fn main() {\n&nbsp; &nbsp; let mut db: Vec&lt;u32&gt; = vec![1,2,3,4,5,6,7,8,9,10];\n&nbsp; &nbsp; db[4] = 50;\n}\n</code></pre><p>下面我们尝试在main函数中创建一个tokio任务。</p><pre><code class=\"language-plain\">#[tokio::main]\nasync fn main() {\n&nbsp; &nbsp; let mut db: Vec&lt;u32&gt; = vec![1,2,3,4,5,6,7,8,9,10];\n\n&nbsp; &nbsp; let task_a = tokio::task::spawn(async {\n&nbsp; &nbsp; &nbsp; &nbsp; db[4] = 50;\n&nbsp; &nbsp; });\n&nbsp; &nbsp; _ = task_a.await.unwrap();\n\n&nbsp; &nbsp; println!(\"{:?}\", db);\n}\n</code></pre><p>这是一段稀松平常的代码，目的就是起一个task，更新一下Vec里的元素，然后等待这个任务结束，打印这个Vec的值。但是，在Rust中，这段代码无法通过，Rust编译器会报错。</p><pre><code class=\"language-plain\">error[E0373]: async block may outlive the current function, but it borrows `db`, which is owned by the current function\n&nbsp;--&gt; src/main.rs:5:37\n&nbsp; |\n5 |&nbsp; &nbsp; &nbsp; &nbsp;let task_a = tokio::task::spawn(async {\n&nbsp; |&nbsp; _____________________________________^\n6 | |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db[4] = 50;\n&nbsp; | |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-- `db` is borrowed here\n7 | |&nbsp; &nbsp; &nbsp;});\n&nbsp; | |_____^ may outlive borrowed value `db`\n&nbsp; |\n&nbsp; = note: async blocks are not executed immediately and must either take a reference or ownership of outside variables they use\nhelp: to force the async block to take ownership of `db` (and any other referenced variables), use the `move` keyword\n&nbsp; |\n5 |&nbsp; &nbsp; &nbsp;let task_a = tokio::task::spawn(async move {\n&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;++++\n</code></pre><p>我们来分析一下这个错误提示，错误提示第1行说，任何异步块都有可能超出当前函数的生存期，但是它里面依赖的db是在当前函数定义的，因此在异步块执行的时候，db指向的对象有可能会消失，从而出错。你可能已经猜到了，错误原因跟所有权相关。原因是这个task_a运行的生存时间段，有可能超过main task生存的时间段，所以task_a里的async块中直接借用main函数中的局部变量db会有所有权相关风险。</p><p>不过这里还有一点疑问，我们不是在main中手动 <code>.await</code> 了吗？会等待这个子task的返回结果，但是Rust并没有分析到这一点。它可能会觉得你在 <code>task_a.await</code> 这一句之前其实是有机会将db给弄消失的，比如手动 <code>drop()</code> 掉这个db，或者说调用了什么别的函数，把db的所有权在那里给消耗了。</p><p>它在错误信息第12行建议我们在 async 后加 move 修饰符，这样指明强制将 db 的所有权移动进task_里去。我们按照建议修改一下。</p><pre><code class=\"language-plain\">#[tokio::main]\nasync fn main() {\n&nbsp; &nbsp; let mut db: Vec&lt;u32&gt; = vec![1,2,3,4,5,6,7,8,9,10];\n\n&nbsp; &nbsp; let task_a = tokio::task::spawn(async move {\n&nbsp; &nbsp; &nbsp; &nbsp; db[4] = 50;\n&nbsp; &nbsp; });\n&nbsp; &nbsp; _ = task_a.await.unwrap();\n\n&nbsp; &nbsp; println!(\"{:?}\", db);\n}\n</code></pre><p>仍然编译出错，报错信息换了。</p><pre><code class=\"language-plain\">error[E0382]: borrow of moved value: `db`\n&nbsp; --&gt; src/main.rs:10:22\n&nbsp; &nbsp;|\n3&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp;let mut db: Vec&lt;u32&gt; = vec![1,2,3,4,5,6,7,8,9,10];\n&nbsp; &nbsp;|&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;------ move occurs because `db` has type `Vec&lt;u32&gt;`, which does not implement the `Copy` trait\n4&nbsp; |\n5&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp;let task_a = tokio::task::spawn(async move {\n&nbsp; &nbsp;|&nbsp; _____________________________________-\n6&nbsp; | |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db[4] = 50;\n&nbsp; &nbsp;| |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-- variable moved due to use in generator\n7&nbsp; | |&nbsp; &nbsp; &nbsp;});\n&nbsp; &nbsp;| |_____- value moved here\n...\n10 |&nbsp; &nbsp; &nbsp; &nbsp;println!(\"{:?}\", db);\n&nbsp; &nbsp;|&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^^ value borrowed here after move\n</code></pre><p>它说，db已经被移动到了task_a里了，所以在main函数中访问不到。这种严苛性，对于从其他语言过来的新手来说，确实令人崩溃。不过反过来想想Rust确实把细节抠得很死，这也是它比其他语言安全的原因。</p><p>那么我们就听小助手的话，不在main函数中打印了。这样确实能编译通过。</p><pre><code class=\"language-plain\">#[tokio::main]\nasync fn main() {\n    let mut db: Vec&lt;u32&gt; = vec![1,2,3,4,5,6,7,8,9,10];\n\n    let task_a = tokio::task::spawn(async move {\n        db[4] = 50;\n    });\n    _ = task_a.await.unwrap();\n}\n</code></pre><p>第一步走通了，下一步我们要测试多任务并发的情况，所以我们需要再增加一个任务。</p><pre><code class=\"language-plain\">use tokio::task;\n\n#[tokio::main]\nasync fn main() {\n    let mut db: Vec&lt;u32&gt; = vec![1,2,3,4,5,6,7,8,9,10];\n    \n    let task_a = task::spawn(async move {\n        db[4] = 50;\n    });\n    let task_b = task::spawn(async move {\n        db[4] = 100;\n    });\n    _ = task_a.await.unwrap();\n    _ = task_b.await.unwrap();\n}\n</code></pre><p>这种写法明显会有问题，我们甚至不需要编译就可以知道，因为出现了两次 async move 块。如果你是一步步学过来的话，应该知道，db在第一个async move时已经被移动进 task_a 了，后面不可能再移动进 task_b。</p><p>编译验证后，确实如此。</p><pre><code class=\"language-plain\">error[E0382]: use of moved value: `db`\n&nbsp; --&gt; src/main.rs:10:30\n&nbsp; &nbsp;|\n5&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp;let mut db: Vec&lt;u32&gt; = vec![1,2,3,4,5,6,7,8,9,10];\n&nbsp; &nbsp;|&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;------ move occurs because `db` has type `Vec&lt;u32&gt;`, which does not implement the `Copy` trait\n6&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp;\n7&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp;let task_a = task::spawn(async move {\n&nbsp; &nbsp;|&nbsp; ______________________________-\n8&nbsp; | |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db[4] = 50;\n&nbsp; &nbsp;| |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-- variable moved due to use in generator\n9&nbsp; | |&nbsp; &nbsp; &nbsp;});\n&nbsp; &nbsp;| |_____- value moved here\n10 |&nbsp; &nbsp; &nbsp; &nbsp;let task_b = task::spawn(async move {\n&nbsp; &nbsp;|&nbsp; ______________________________^\n11 | |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db[4] = 100;\n&nbsp; &nbsp;| |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-- use occurs due to use in generator\n12 | |&nbsp; &nbsp; &nbsp;});\n&nbsp; &nbsp;| |_____^ value used here after move\n</code></pre><p>那应该怎么办呢？</p><h3>方案三：利用 Arc</h3><p>回想一下<a href=\"https://time.geekbang.org/column/article/725815\">第 12 讲</a>我们讲到过的Arc这个智能指针，它可以让多个持有者共享对同一资源的所有权。但是Arc也有一个巨大的限制，就是它无法修改被包裹的值。但不管怎样，我们还是碰碰运气，改动一下。</p><pre><code class=\"language-plain\">use std::sync::Arc;\n\n#[tokio::main]\nasync fn main() {\n&nbsp; &nbsp; let mut db: Vec&lt;u32&gt; = vec![1,2,3,4,5,6,7,8,9,10];\n&nbsp; &nbsp; let arc_db = Arc::new(db);\n&nbsp; &nbsp; let arc_db2 = arc_db.clone();\n\n&nbsp; &nbsp; let task_a = tokio::task::spawn(async move {\n&nbsp; &nbsp; &nbsp; &nbsp; arc_db[4] = 50;\n&nbsp; &nbsp; });\n&nbsp; &nbsp; let task_b = tokio::task::spawn(async move {\n&nbsp; &nbsp; &nbsp; &nbsp; arc_db2[4] = 100;\n&nbsp; &nbsp; });\n&nbsp; &nbsp; _ = task_a.await.unwrap();\n&nbsp; &nbsp; _ = task_b.await.unwrap();\n\n&nbsp; &nbsp; // println!(\"{:?}\", db);\n}\n</code></pre><p>不出所料，Rust编译不通过，这说明通过 <code>Arc&lt;T&gt;</code> 没办法修改里面的值。</p><pre><code class=\"language-plain\">error[E0596]: cannot borrow data in an `Arc` as mutable\n&nbsp; --&gt; src/main.rs:10:9\n&nbsp; &nbsp;|\n10 |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;arc_db[4] = 50;\n&nbsp; &nbsp;|&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^^^^^^ cannot borrow as mutable\n&nbsp; &nbsp;|\n&nbsp; &nbsp;= help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `Arc&lt;Vec&lt;u32&gt;&gt;`\n\nerror[E0596]: cannot borrow data in an `Arc` as mutable\n&nbsp; --&gt; src/main.rs:13:9\n&nbsp; &nbsp;|\n13 |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;arc_db2[4] = 100;\n&nbsp; &nbsp;|&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;^^^^^^^ cannot borrow as mutable\n&nbsp; &nbsp;|\n&nbsp; &nbsp;= help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `Arc&lt;Vec&lt;u32&gt;&gt;`\n</code></pre><p>虽然现在我们的代码还是没有编译通过，但是思路是没问题的：要在并发的多个任务中，访问同一个资源，那么必然涉及到多所有权，所以使用Arc是完全没有问题的。现在的问题是，<strong>有没有办法更改被Arc包裹起来的值</strong>。</p><p>答案是有的，利用 Mutex 就可以。</p><h3>方案四：Arc+Mutex</h3><p>一个多任务并发编程要修改同一个值，那必然要防止修改冲突，这就不得不用到计算机领域里一个常见的工具——锁。</p><p>Mutex是一种互斥锁，被Mutex包裹住的对象，同时只能存在一个reader或一个writer。使用的时候，要先获得Mutex锁，成功后，才能读或写这个锁里面的值。多个任务不能同时获得同一个Mutex锁，当一个任务持有Mutex锁时，其他任务会处于等待状态，直到那个任务用完了Mutex锁，并自动释放了它。</p><pre><code class=\"language-plain\">use std::sync::Arc;\nuse tokio::sync::Mutex;\n\n#[tokio::main]\nasync fn main() {\n&nbsp; &nbsp; let db: Vec&lt;u32&gt; = vec![1,2,3,4,5,6,7,8,9,10];\n&nbsp; &nbsp; let arc_db = Arc::new(Mutex::new(db));  // 加锁\n&nbsp; &nbsp; let arc_db2 = arc_db.clone();\n&nbsp; &nbsp; let arc_db3 = arc_db.clone();\n\n&nbsp; &nbsp; let task_a = tokio::task::spawn(async move {\n&nbsp; &nbsp; &nbsp; &nbsp; let mut db = arc_db.lock().await;  // 获取锁\n&nbsp; &nbsp; &nbsp; &nbsp; db[4] = 50;\n        assert_eq!(db[4], 50);             // 校验值\n&nbsp; &nbsp; });\n&nbsp; &nbsp; let task_b = tokio::task::spawn(async move {\n&nbsp; &nbsp; &nbsp; &nbsp; let mut db = arc_db2.lock().await;  // 获取锁\n&nbsp; &nbsp; &nbsp; &nbsp; db[4] = 100;\n        assert_eq!(db[4], 100);            // 校验值\n&nbsp; &nbsp; });\n&nbsp; &nbsp; _ = task_a.await.unwrap();\n&nbsp; &nbsp; _ = task_b.await.unwrap();\n\n&nbsp; &nbsp; println!(\"{:?}\", arc_db3.lock().await);  // 获取锁\n}\n// 输出\n[1, 2, 3, 4, 100, 6, 7, 8, 9, 10]\n</code></pre><p>加上Mutex，这个例子就能顺利编译并运行通过了。</p><p>这个例子里的第7行，我们使用 <code>Arc::new(Mutex::new())</code> 组合把db包了两层，外层是Arc，里层是Mutex。然后，我们把arc_db克隆了两次，这种克隆只是增加Arc的引用计数，代价非常低。</p><p>然后在每次使用的时候，先通过 <code>arc_db.lock().await</code> 这种方式获得锁，再等待取出锁中对象的引用，这里也就是Vec的引用，然后通过这个引用去更新db的值。</p><p>利用Arc与Mutex的组合，我们还顺便解决了在main task不能打印这个db的问题。实际上，在Rust中，<code>Arc&lt;Mutex&lt;T&gt;&gt;</code> 是一对很常见的组合，利用它们的组合技术，基本上可以满足绝大部分的并发编程场景。</p><p>有了这两兄弟的加持，我们用Rust写业务代码就变得像Java一样高效、便捷。相对于Go、Python或JavaScript来说，Rust的异步并发编程代码稍微有些繁琐，但是它的模式是非常固定的，最后这个示例里的模式可以无脑使用。正因为如此，Arc、Mutex和clone() 一起，被社区叫做“Rust三板斧”，就是因为它们简单粗暴，方便好用。</p><p>到这里为止，我们已经解决了这节课开头提出的问题。</p><h2>其他锁</h2><p>除了Mutex，tokio里还提供了一些锁，我们来看一看。</p><h3>tokio::sync::RwLock</h3><p>RwLock是读写锁。它和Mutex的区别是，Mutex不论是读还是写，同时只有一个能拿到锁。比如，一个task在读，而另一个task也想读的时候，仍然需要等待第一个task先释放锁。所以在读比较多的情况下，Mutex的运行效率不是太理想。</p><p>而RwLock的设计是，当一个任务拿的是读锁时，其他任务也能再拿到读锁，多个读锁之间可以同时存在。当一个任务想拿写锁的时候，必须等待其他所有读锁或写锁释放后才能拿到。</p><p>当一个任务拿到了写锁时，其他任务只能等待它完成后才能继续操作，不管其他任务是要写还是读。因此对于写来讲，RwLock是排斥型访问；对于读来讲，RwLock提供了共享访问。这一点与不可变引用和可变引用的关系特别像。</p><p>我们来看下面的示例：</p><pre><code class=\"language-plain\">use tokio::sync::RwLock;\n#[tokio::main]\nasync fn main() {\n    let lock = RwLock::new(5);\n    // 多个读锁可以同时存在\n    {\n        let r1 = lock.read().await;\n        let r2 = lock.read().await;\n        assert_eq!(*r1, 5);\n        assert_eq!(*r2, 5);\n    } // 在这一句结束时，两个读锁都释放掉了\n    \n    // 同时只能存在一个写锁\n    {\n        let mut w = lock.write().await;\n        *w += 1;\n        assert_eq!(*w, 6);\n    } // 在这一句结束时，写锁释放掉了\n}\n</code></pre><p>可以看到，RwLock的使用非常简单，在读操作比写操作多很多的情况下，RwLock的性能会比Mutex好很多。</p><p>Rust标准库中还有一些用于简单类型的原子锁。</p><h3>std::sync::atomic</h3><p>如果共享数据的只是一些简单的类型，比如 bool、i32、u8、usize等等，就不需要使用Mutex或RwLock把这些类型包起来，比如像这样 <code>Arc&lt;Mutex&lt;u32&gt;&gt;</code>，可以直接用Rust标准库里提供的原子类型。<code>std::sync::atomic</code> 这个模块下面提供了很多原子类型，比如AtomicBool、AtomicI8、AtomicI16等等。</p><p><code>Mutex&lt;u32&gt;</code> 对应的原子类型是 <code>std::sync::atomic::AtomicU32</code>。</p><p>像下面这样使用：</p><pre><code class=\"language-plain\">use std::sync::atomic::AtomicU32;\n\nfn main() {\n    // 创建\n    let atomic_forty_two = AtomicU32::new(42);\n    let arc_data = Arc::new(atomic_forty_two);\n    \n    let mut some_var = AtomicU32::new(10);\n    // 更新\n    *some_var.get_mut() = 5;\n    assert_eq!(*some_var.get_mut(), 5);\n}\n</code></pre><p>其他类型按类似的方式使用就可以了。原子类型之所以会单独提出来，是因为它是锁的基础，其他的锁会建立在这些基础原子类型之上，这些原子类型也可以充分利用硬件提供的关于原子操作的支持，从而提高应用的性能。</p><blockquote>\n<p>注：在多核CPU中，常见的硬件支持原子操作的方法包括CPU中的缓存一致性协议、总线锁定等机制，可以使多个线程或进程同时对同一变量进行原子操作时，不会出现数据竞争和线程同步的问题。</p>\n</blockquote><p>锁（lock）和无锁（lock-free）是计算机科学领域一个非常大的课题，Rust有本书 <a href=\"https://marabos.nl/atomics/\">《Rust Atomics and&nbsp;Locks》</a>专门讲这个，有兴趣的话你可以看一看。</p><h2>小结</h2><p>这节课我们通过一步步验证的方式，学习了在Rust和tokio中如何在多个任务中操作共享数据，经过多次被编译器拒绝的痛苦，最后我们得到了一个相当舒服的方案。这个方案可以供我们以后在做并发编程时使用，使用时的模式非常固定，没有什么心智负担。整个探索过程虽然比较辛苦，但是结果却是比较美好的。这也许就是Rust的学习过程吧，先苦后甜。</p><p>在整个探索过程中，我们也能深切体会Rust所有权模型在并发场景下发挥的重要作用。如果你想让程序编译通过，那么必须严格遵守Rust的所有权模型；一旦你在Rust的所有权指导下捣鼓出了并发代码，那么<strong>你的并发代码就一定不会产生由于竞争条件而导致的概率性Bug</strong>。</p><p>如果你有这方面的经验教训，你一定会特别憎恶这种概率性的Bug，因为有可能仅仅是重现Bug现场就要花一个月的时间。同时，你会爱上Rust，因为它从语言层面就帮我们杜绝了这种情况，让我们的线上服务特别稳定，晚上可以安心睡觉了。</p><h2>思考题</h2><p>这节课代码里下面这两句的意义是什么，第一行会阻塞第二句吗？</p><pre><code class=\"language-plain\">    _ = task_a.await.unwrap();\n    _ = task_b.await.unwrap();\n</code></pre><p>希望你可以开动脑筋，认真思考，把你的答案分享到评论区，也欢迎你把这节课的内容分享给其他朋友，邀他们一起学习Rust。好了，我们下节课再见吧！</p>","neighbors":{"left":{"article_title":"14｜tokio实战：编写一个网络命令行程序","id":726207},"right":{"article_title":"16｜tokio编程：使用channel在不同任务间通信？","id":728107}},"comments":[{"had_liked":false,"id":384322,"user_name":"lilp","can_delete":false,"product_type":"c1","uid":2014371,"ip_address":"广东","ucode":"CA4695BD25565B","user_header":"https://static001.geekbang.org/account/avatar/00/1e/bc/a3/7f753d36.jpg","comment_is_top":false,"comment_ctime":1700692138,"is_pvip":false,"replies":[{"id":140231,"content":"1 是的。 2 spawn后就立即执行。后面这两句只是等待任务返回。在执行第二句之前有可能第二个任务已经执行完了，第二句只是把其任务的返回值取回来。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700708354,"ip_address":"重庆","comment_id":384322,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"1. 应该是防止这两个任务还没走完，主线程就结束了？\n2. 不会阻塞。我理解的是这两个任务 同时启动，顺序完成。不管他俩怎么去抢这个锁 最后的完成顺序应该还是和main中写的.await() 顺序一样。","like_count":6,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632359,"discussion_content":"1 是的。 2 spawn后就立即执行。后面这两句只是等待任务返回。在执行第二句之前有可能第二个任务已经执行完了，第二句只是把其任务的返回值取回来。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1700708355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2014371,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/bc/a3/7f753d36.jpg","nickname":"lilp","note":"","ucode":"CA4695BD25565B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632486,"discussion_content":"好嘞 明白了 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700826569,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384334,"user_name":"PEtFiSh","can_delete":false,"product_type":"c1","uid":1765926,"ip_address":"上海","ucode":"C4922398A92E05","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLO6XvxfFPMGcVSSX8uIZY2yib29qlyat178pU4QM3gIic5GXZ8PC0tzRiazP3FiajXbTj19SE4ZhV0gQ/132","comment_is_top":false,"comment_ctime":1700706811,"is_pvip":false,"replies":[{"id":140236,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700729356,"ip_address":"重庆","comment_id":384334,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"await代码会持续等待直到任务结束，因此在main thread里第一行会阻塞第二行。但这不会让task_a阻塞task_b。加入await可以使最后的println!打印两个任务执行完以后被修改的db值，如果不加入await。有一定几率最后println!打印的还是原始的db","like_count":4,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632394,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700729356,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384271,"user_name":"-","can_delete":false,"product_type":"c1","uid":1546505,"ip_address":"北京","ucode":"7B34258D346793","user_header":"https://static001.geekbang.org/account/avatar/00/17/99/09/29c46a7b.jpg","comment_is_top":false,"comment_ctime":1700618619,"is_pvip":false,"replies":[{"id":140223,"content":"思考得很棒，前后联系起来了。arc mutex 其实是拿到了对象所有权，有所有权了当然修改值就方便了。跟前面并不冲突，当然如果还想深入下去，可以看看 内部可变性 这个概念。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700707595,"ip_address":"重庆","comment_id":384271,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"有个疑问，Arc::new(Mutex::new(db))后可以将一个不可变的变量变成可变变量？这个是什么原因","like_count":4,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632350,"discussion_content":"思考得很棒，前后联系起来了。arc mutex 其实是拿到了对象所有权，有所有权了当然修改值就方便了。跟前面并不冲突，当然如果还想深入下去，可以看看 内部可变性 这个概念。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700707595,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1979955,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/36/33/3411df0d.jpg","nickname":"seven9t","note":"","ucode":"B7CA7D62C56938","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635783,"discussion_content":"底层用了unsafe绕过","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1705199067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3779530,"avatar":"https://static001.geekbang.org/account/avatar/00/39/ab/ca/32d6c05d.jpg","nickname":"哄哄","note":"","ucode":"F75FB23BEDC60A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632286,"discussion_content":"db的所有权最后给了Arc，Mutex上锁之后就可以读写，具体怎么实现的没看源码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700631403,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386598,"user_name":"seven9t","can_delete":false,"product_type":"c1","uid":1979955,"ip_address":"广东","ucode":"B7CA7D62C56938","user_header":"https://static001.geekbang.org/account/avatar/00/1e/36/33/3411df0d.jpg","comment_is_top":false,"comment_ctime":1705199249,"is_pvip":false,"replies":[{"id":140981,"content":"关于这个话题，可以看下tokio官网的一个说明：https:&#47;&#47;tokio.rs&#47;tokio&#47;tutorial&#47;shared-state\n区别就是要不要跨 await 边界。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1705414881,"ip_address":"重庆","comment_id":386598,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"可以说下如果用rust自带的Mutex而不是tokio的会有什么问题 （是否必须配套","like_count":2,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635973,"discussion_content":"关于这个话题，可以看下tokio官网的一个说明：https://tokio.rs/tokio/tutorial/shared-state\n区别就是要不要跨 await 边界。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705414881,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384377,"user_name":"下雨天","can_delete":false,"product_type":"c1","uid":1008315,"ip_address":"湖北","ucode":"816B3792ECC50A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/62/bb/323a3133.jpg","comment_is_top":false,"comment_ctime":1700736678,"is_pvip":false,"replies":[{"id":140243,"content":"spawn比较特殊，特殊处理的","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700792851,"ip_address":"重庆","comment_id":384377,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"看实现，就当前例子而言task_a不会阻塞task_b。 如果task_a中loop{}下就可以阻塞了。\n\n有个疑问，为啥task::spawn后面会自动执行呢？ 我理解只有.await了才会加到调度器里面执行。","like_count":2,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632455,"discussion_content":"spawn比较特殊，特殊处理的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700792851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":1008315,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/bb/323a3133.jpg","nickname":"下雨天","note":"","ucode":"816B3792ECC50A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":632466,"discussion_content":"😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700801238,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":632455,"ip_address":"湖北","group_id":0},"score":632466,"extra":""},{"author":{"id":2186188,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/cc/be5c5b75.jpg","nickname":"云游","note":"","ucode":"28048E54740904","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":649919,"discussion_content":"为啥spawn要做特殊处理啊？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1724143042,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":632455,"ip_address":"浙江","group_id":0},"score":649919,"extra":""}]},{"author":{"id":1979955,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/36/33/3411df0d.jpg","nickname":"seven9t","note":"","ucode":"B7CA7D62C56938","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635784,"discussion_content":"spawn是创建并启动，await是等执行结果","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705199159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384284,"user_name":"Geek_72807e","can_delete":false,"product_type":"c1","uid":3570665,"ip_address":"山西","ucode":"9E9A6277605048","user_header":"","comment_is_top":false,"comment_ctime":1700624465,"is_pvip":false,"replies":[{"id":140229,"content":"很棒的思考👍，有可能出现。看哪个任务后执行完成，后抢到锁。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700708051,"ip_address":"重庆","comment_id":384284,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"请问老师，方案四中，会不会出现两次修改操作顺序不确定的问题，最终结构可以是40，也会是100？","like_count":2,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632356,"discussion_content":"很棒的思考👍，有可能出现。看哪个任务后执行完成，后抢到锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700708051,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3737491,"avatar":"https://static001.geekbang.org/account/avatar/00/39/07/93/710c7ee2.jpg","nickname":"不忘初心","note":"","ucode":"8262D42405F4E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632328,"discussion_content":"同问, 最终结果, 是不是50, 和100两种可能都存在?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700655509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386546,"user_name":"yunyi","can_delete":false,"product_type":"c1","uid":1139000,"ip_address":"广东","ucode":"A3A66C4ACE2591","user_header":"https://static001.geekbang.org/account/avatar/00/11/61/38/d586a684.jpg","comment_is_top":false,"comment_ctime":1705050670,"is_pvip":false,"replies":[{"id":140979,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1705411054,"ip_address":"重庆","comment_id":386546,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"1、为了等待任务完成\n2、不会阻塞，两个任务是并行运行的，结果也有可能是被改成50，taskb先完成，再执行taska。","like_count":1,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635970,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705411054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384258,"user_name":"雍和","can_delete":false,"product_type":"c1","uid":2695785,"ip_address":"广东","ucode":"C703A7FDCAD58C","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/qUHuge7oea6mA4bUTyJ4rpTP7Havj5m2WEqKvrARDbe8HYnu52vQ8DfAWNkLEfQbic83ibDhnUZYRTwut5Dl8icDA/132","comment_is_top":false,"comment_ctime":1700611272,"is_pvip":false,"replies":[{"id":140225,"content":"不会，你执行就知道了。原因在下一讲有讲。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700707897,"ip_address":"重庆","comment_id":384258,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"会，因为要获取mutex","like_count":1,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632352,"discussion_content":"不会，你执行就知道了。原因在下一讲有讲。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700707897,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386684,"user_name":"Geek_3b58b9","can_delete":false,"product_type":"c1","uid":3196265,"ip_address":"江苏","ucode":"E9DE52FD0B5E29","user_header":"","comment_is_top":false,"comment_ctime":1705328308,"is_pvip":false,"replies":[{"id":140980,"content":"智能指针不是传统意义上的c那种指针。 锁的实现就需要用到指令集层面的原子指令来优化。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1705411188,"ip_address":"重庆","comment_id":386684,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"对原子变量的读写访问可以用指针？还是说应该用专门的API？我记得原子类型有特定的CPU指令的","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635971,"discussion_content":"智能指针不是传统意义上的c那种指针。 锁的实现就需要用到指令集层面的原子指令来优化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705411189,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386540,"user_name":"yunyi","can_delete":false,"product_type":"c1","uid":1139000,"ip_address":"广东","ucode":"A3A66C4ACE2591","user_header":"https://static001.geekbang.org/account/avatar/00/11/61/38/d586a684.jpg","comment_is_top":false,"comment_ctime":1705045034,"is_pvip":false,"replies":[{"id":140910,"content":"幸会幸会","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1705068291,"ip_address":"重庆","comment_id":386540,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"哇 ，居然看到了Erlang的字眼，我一直是用erlang做为主力语言的后端开发，最近在学rust，找了很多资料，最后买了老师的教程，如获至宝","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635715,"discussion_content":"幸会幸会","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705068291,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385721,"user_name":"superggn","can_delete":false,"product_type":"c1","uid":3623568,"ip_address":"北京","ucode":"831CCD98B393FE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/7Q403U68Oy4lXG5sFBPVKLrfwaRzBqpBZibpEBXcPf9UOO3qrnh7RELoByTLzBZLkN9Nukfsj7DibynbZjKAKgag/132","comment_is_top":false,"comment_ctime":1703156490,"is_pvip":false,"replies":[{"id":140589,"content":"1. Arc::clone(arc_db) 和 arc_db.clone()  是一样的。\n2. 教程里面用 tokio 的 Arc，Mutex，主要是不给同学引入额外的理解负担。不然要学的东西又多了。\n\n关于它们的差别，可以看这里：https:&#47;&#47;tokio.rs&#47;tokio&#47;tutorial&#47;shared-state   On using std::sync::Mutex","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1703232734,"ip_address":"重庆","comment_id":385721,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"问个事儿， Arc::clone(arc_db) 和 arc_db.clone() 一样吗？\n\n为啥 不用 `std::sync::{Arc, Mutex}` 而是 `tokio::sync::{Arc, Mutex}`\n\n如果是因为在 tokio runtime 里头要用 tokio 的东西的话， 那么在啥情况下会用 std 的几板斧呢？\n\n同步场景都用 std::sync 底下的东西吗？","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634339,"discussion_content":"1. Arc::clone(arc_db) 和 arc_db.clone()  是一样的。\n2. 教程里面用 tokio 的 Arc，Mutex，主要是不给同学引入额外的理解负担。不然要学的东西又多了。\n\n关于它们的差别，可以看这里：https://tokio.rs/tokio/tutorial/shared-state   On using std::sync::Mutex","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1703232735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":1,"child_discussions":[{"author":{"id":3623568,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/7Q403U68Oy4lXG5sFBPVKLrfwaRzBqpBZibpEBXcPf9UOO3qrnh7RELoByTLzBZLkN9Nukfsj7DibynbZjKAKgag/132","nickname":"superggn","note":"","ucode":"831CCD98B393FE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":634353,"discussion_content":"感谢猛男","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1703273697,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":634339,"ip_address":"北京","group_id":0},"score":634353,"extra":""}]},{"author":{"id":3623568,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/7Q403U68Oy4lXG5sFBPVKLrfwaRzBqpBZibpEBXcPf9UOO3qrnh7RELoByTLzBZLkN9Nukfsj7DibynbZjKAKgag/132","nickname":"superggn","note":"","ucode":"831CCD98B393FE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634329,"discussion_content":"- Arc::clone 和 arc_db.clone 功能一致， 只是格式的区别\n- Arc 在 std tokio 里是通用的， tokio::sync 里没有 Arc\n- Mutex 区分 std 和 tokio, 这是功能需要， 是必须区分的\n- 同步用 std::sync::Mutex, 异步 tokio::sync::Mutex 加了一些特性从而能适应异步场景， 所以异步必须用 tokio::sync::Mutex, 不能用 std 的东西","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1703223700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385720,"user_name":"superggn","can_delete":false,"product_type":"c1","uid":3623568,"ip_address":"北京","ucode":"831CCD98B393FE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/7Q403U68Oy4lXG5sFBPVKLrfwaRzBqpBZibpEBXcPf9UOO3qrnh7RELoByTLzBZLkN9Nukfsj7DibynbZjKAKgag/132","comment_is_top":false,"comment_ctime":1703156284,"is_pvip":false,"replies":[{"id":140634,"content":"很棒","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1703577919,"ip_address":"重庆","comment_id":385720,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"思考题\n意义： 等执行完了再打印， 对齐一下子， 别任务没跑完主进程就完事儿了\n到 await 这块儿就是同步了， 这俩 await 是顺序执行， \n如果 task_a 没执行完， task_b 已经执行完了， 就会卡在 task_a 这里， task_a 这行完事儿了在执行 task_b 的 await, 这会儿 task_b 因为已经完事儿了， 所以第2个 await 不会卡\n","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634500,"discussion_content":"很棒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1703577919,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385670,"user_name":"-Hedon🍭","can_delete":false,"product_type":"c1","uid":3176234,"ip_address":"湖北","ucode":"FAE541E7A2B88F","user_header":"https://static001.geekbang.org/account/avatar/00/30/77/2a/0cd4c373.jpg","comment_is_top":false,"comment_ctime":1703073940,"is_pvip":false,"replies":[{"id":140555,"content":"对的。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1703122482,"ip_address":"重庆","comment_id":385670,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"task_a.await.unwrap() 是阻塞等待任务结果，所以 task_a.await.unwrap() 会阻塞 task_b.await.unwrap() ，但是 task_a 不会阻塞 task_b，spwan 并发执行的。","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634230,"discussion_content":"对的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1703122482,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385447,"user_name":"Geek_e5eb33","can_delete":false,"product_type":"c1","uid":1934555,"ip_address":"安徽","ucode":"296CC5358A4788","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/axiaxUndY1I8iaOu5qZOwFiaKgicR1AlWsSUyyYIMdEnibuhhzuQnicvXibaOxSakMNAQIPmgicsTfPvUnWJ5WCFzmdHDw/132","comment_is_top":false,"comment_ctime":1702629541,"is_pvip":false,"replies":[{"id":140471,"content":"通过函数参数传递进来。生成的所有权对象通过函数值返回。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1702701878,"ip_address":"重庆","comment_id":385447,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"请问老师，rust 中不建议使用全局变量。那如果我想进行模块化开发，在 A 模块中定义的变量(比如缓存了用户信息)，怎么供其他模块使用呢，目前能想到的是都定义到 main 里。","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633874,"discussion_content":"通过函数参数传递进来。生成的所有权对象通过函数值返回。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702701878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384293,"user_name":"Taozi","can_delete":false,"product_type":"c1","uid":1021926,"ip_address":"上海","ucode":"DD6567A31B3E33","user_header":"","comment_is_top":false,"comment_ctime":1700636397,"is_pvip":false,"replies":[{"id":140230,"content":"👍很棒的分析，赞","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700708139,"ip_address":"重庆","comment_id":384293,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"关于arc里面为何需要套lock才能修改值，当然是为了在运行时保证内存安全。为什么说在运行时，因为还有对应的在静态时。还记得最开始我们说rust中每个值都有一个owner，这是为了保证ower在其作用域结束时释放值，这是可以通过代码静态分析出来的。对于所有权不能静态确定的情况，就需要arc来这个第三方来持有所有权，然后动态的决定何时释放值。原理也很简单，就是引用计数。同样最开始我们也说一个值只能同时存在一个可变借用或者多个不可变借用，这也是可以通过静态分析保证的，但是在arc这里只能通过加锁在运行时保证这点。","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632357,"discussion_content":"👍很棒的分析，赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700708139,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384278,"user_name":"Geek_6fjt20","can_delete":false,"product_type":"c1","uid":1672482,"ip_address":"北京","ucode":"B7EB9B061E2C06","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqrbHib1v0wPRVHxrFK2CPQQX8Wg3rRMPiaZ5teMKu5klT48yns6yo4krZsIqHskwdEsibVvQ3QB7CUQ/132","comment_is_top":false,"comment_ctime":1700623036,"is_pvip":false,"replies":[{"id":140228,"content":"不错👌","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700707950,"ip_address":"重庆","comment_id":384278,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"太方便了，不像java，即使有各种同步锁也要考虑多种情况下的不一致","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632355,"discussion_content":"不错👌","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700707950,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384272,"user_name":"哄哄","can_delete":false,"product_type":"c1","uid":3779530,"ip_address":"北京","ucode":"F75FB23BEDC60A","user_header":"https://static001.geekbang.org/account/avatar/00/39/ab/ca/32d6c05d.jpg","comment_is_top":false,"comment_ctime":1700619193,"is_pvip":false,"replies":[{"id":140222,"content":"对，关键点在于spawn，下一节会专门提到这个。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700707448,"ip_address":"重庆","comment_id":384272,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"看命名是否规范，有些人会将future命名为task。如果task_a和task_b都是task，那么他们都会在各自执行，task_b不需要等待task_a完成才开始执行，而是在spawn之后就开始执行。如果如果task_a和task_b都是future，那么就是按照顺序执行，task_b必须等待task_a完成才能执行。","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632348,"discussion_content":"对，关键点在于spawn，下一节会专门提到这个。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700707448,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384259,"user_name":"哄哄","can_delete":false,"product_type":"c1","uid":3779530,"ip_address":"北京","ucode":"F75FB23BEDC60A","user_header":"https://static001.geekbang.org/account/avatar/00/39/ab/ca/32d6c05d.jpg","comment_is_top":false,"comment_ctime":1700612238,"is_pvip":false,"replies":[{"id":140224,"content":"对的，可以参考一下这个例子 https:&#47;&#47;github.com&#47;Amanieu&#47;parking_lot&#47;issues&#47;212 。关于rust中的deadlock我后面会在这个课程之外单独写专题分析。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700707841,"ip_address":"重庆","comment_id":384259,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"Rwlock：请问怎么理解：Each read and write should be run in its own task.Otherwise ,they can cause a deadlock.","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632351,"discussion_content":"对的，可以参考一下这个例子 https://github.com/Amanieu/parking_lot/issues/212 。关于rust中的deadlock我后面会在这个课程之外单独写专题分析。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700707842,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":3779530,"avatar":"https://static001.geekbang.org/account/avatar/00/39/ab/ca/32d6c05d.jpg","nickname":"哄哄","note":"","ucode":"F75FB23BEDC60A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":632390,"discussion_content":"老师，rust的编译器生成执行代码时，是不是对代码执行进行了优化？因为rust规则中，一个scop内的&amp;和&amp;mut为了避免data race的不共存限制机制，如果一个线程完全按照代码顺序执行，我怎么想也是不会发生数据竞争的呀。同理，Rwlock也有这样的使用限制疑问。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700726256,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":632351,"ip_address":"北京","group_id":0},"score":632390,"extra":""}]}]},{"had_liked":false,"id":384257,"user_name":"伯阳","can_delete":false,"product_type":"c1","uid":1596631,"ip_address":"北京","ucode":"DBDC8735AA54AD","user_header":"https://static001.geekbang.org/account/avatar/00/18/5c/d7/3b92bb0d.jpg","comment_is_top":false,"comment_ctime":1700603438,"is_pvip":false,"replies":[{"id":140226,"content":"666","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700707907,"ip_address":"重庆","comment_id":384257,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"确实比其他语言方便多一些","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632353,"discussion_content":"666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700707907,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}