{"id":740769,"title":"第 7 章 渲染器的设计","content":"<p>在第 3 章中，我们初步讨论了虚拟 DOM 和渲染器的工作原理，并尝试编写了一个微型的渲染器。从本章开始，我们将详细讨论渲染器的实现细节。在这个过程中，你将认识到渲染器是 Vue.js 中非常重要的一部分。在 Vue.js 中，很多功能依赖渲染器来实现，例如 Transition 组件、Teleport 组件、Suspense 组件，以及 template <code>ref</code> 和自定义指令等。</p>\n<p>另外，渲染器也是框架性能的核心，渲染器的实现直接影响框架的性能。Vue.js 3 的渲染器不仅仅包含传统的 Diff 算法，它还独创了快捷路径的更新方式，能够充分利用编译器提供的信息，大大提升了更新性能。</p>\n<p>渲染器的代码量非常庞大，需要合理的架构设计来保证可维护性，不过它的实现思路并不复杂。接下来，我们就从讨论渲染器如何与响应系统结合开始，逐步实现一个完整的渲染器。</p>\n<h2 id=\"nav_point_71\">7.1　渲染器与响应系统的结合</h2>\n<p>顾名思义，渲染器是用来执行渲染任务的。在浏览器平台上，用它来渲染其中的真实 DOM 元素。渲染器不仅能够渲染真实 DOM 元素，它还是框架跨平台能力的关键。因此，在设计渲染器的时候一定要考虑好可自定义的能力。</p>\n<p>本节，我们暂时将渲染器限定在 DOM 平台。既然渲染器用来渲染真实 DOM 元素，那么严格来说，下面的函数就是一个合格的渲染器：</p><!-- [[[read_end]]] -->\n<pre class=\"code-rows\"><code> function renderer(domString, container) {\n   container.innerHTML = domString\n }\n</code></pre>\n<p>我们可以如下所示使用它：</p>\n<pre class=\"code-rows\"><code> renderer('&lt;h1&gt;Hello&lt;/h1&gt;', document.getElementById('app'))\n</code></pre>\n<p>如果页面中存在 <code>id</code> 为 <code>app</code> 的 DOM 元素，那么上面的代码就会将 <code>&lt;h1&gt;hello&lt;/h1&gt;</code> 插入到该 DOM 元素内。</p>\n<p>当然，我们不仅可以渲染静态的字符串，还可以渲染动态拼接的 HTML 内容，如下所示：</p>\n<pre class=\"code-rows\"><code> let count = 1\n renderer(`&lt;h1&gt;$&lt;/h1&gt;`, document.getElementById('app'))\n</code></pre>\n<p>这样，最终渲染出来的内容将会是 <code>&lt;h1&gt;1&lt;/h1&gt;</code>。注意上面这段代码中的变量 <code>count</code>，如果它是一个响应式数据，会怎么样呢？这让我们联想到副作用函数和响应式数据。利用响应系统，我们可以让整个渲染过程自动化：</p>\n<pre class=\"code-rows\"><code> const count = ref(1)\n<p>effect(() =&gt; {<br />\nrenderer(<code>&amp;lt;h1&amp;gt;$&amp;lt;/h1&amp;gt;</code>, document.getElementById(‘app’))<br />\n})</p>\n<p>count.value++<br />\n</code></pre></p>\n<p>在这段代码中，我们首先定义了一个响应式数据 <code>count</code>，它是一个 <code>ref</code>，然后在副作用函数内调用 <code>renderer</code> 函数执行渲染。副作用函数执行完毕后，会与响应式数据建立响应联系。当我们修改 <code>count.value</code> 的值时，副作用函数会重新执行，完成重新渲染。所以上面的代码运行完毕后，最终渲染到页面的内容是 <code>&lt;h1&gt;2&lt;/h1&gt;</code>。</p>\n<p>这就是响应系统和渲染器之间的关系。我们利用响应系统的能力，自动调用渲染器完成页面的渲染和更新。这个过程与渲染器的具体实现无关，在上面给出的渲染器的实现中，仅仅设置了元素的 <code>innerHTML</code> 内容。</p>\n<p>从本章开始，我们将使用 <code>@vue/reactivity</code> 包提供的响应式 API 进行讲解。关于 <code>@vue/reactivity</code> 的实现原理，第二篇已有讲解。<code>@vue/reactivity</code> 提供了 IIFE 模块格式，因此我们可以直接通过 <code>&lt;script&gt;</code> 标签引用到页面中使用：</p>\n<pre class=\"code-rows\"><code> &lt;script src=\"https://unpkg.com/@vue/reactivity@3.0.5/dist/reactivity.global.js\"&gt;&lt;/script&gt;\n</code></pre>\n<p>它暴露的全局 API 名叫 <code>VueReactivity</code>，因此上述内容的完整代码如下：</p>\n<pre class=\"code-rows\"><code> const { effect, ref } = VueReactivity\n<p>function renderer(domString, container) {<br />\ncontainer.innerHTML = domString<br />\n}</p>\n<p>const count = ref(1)</p>\n<p>effect(() =&gt; {<br />\nrenderer(<code>&amp;lt;h1&amp;gt;$&amp;lt;/h1&amp;gt;</code>, document.getElementById(‘app’))<br />\n})</p>\n<p>count.value++<br />\n</code></pre></p>\n<p>可以看到，我们通过 <code>VueReactivity</code> 得到了 <code>effect</code> 和 <code>ref</code> 这两个 API。</p>\n<h2 id=\"nav_point_72\">7.2　渲染器的基本概念</h2>\n<p>理解渲染器所涉及的基本概念，有利于理解后续内容。因此，本节我们会介绍渲染器所涉及的术语及其含义，并通过代码来举例说明。</p>\n<p>我们通常使用英文 renderer 来表达“渲染器”。千万不要把 renderer 和 render 弄混了，前者代表渲染器，而后者是动词，表示“渲染”。渲染器的作用是把虚拟 DOM 渲染为特定平台上的真实元素。在浏览器平台上，渲染器会把虚拟 DOM 渲染为真实 DOM 元素。</p>\n<p>虚拟 DOM 通常用英文 virtual DOM 来表达，有时会简写成 <code>vdom</code>。虚拟 DOM 和真实 DOM 的结构一样，都是由一个个节点组成的树型结构。所以，我们经常能听到“虚拟节点”这样的词，即 virtual node，有时会简写成 <code>vnode</code>。虚拟 DOM 是树型结构，这棵树中的任何一个 <code>vnode</code> 节点都可以是一棵子树，因此 <code>vnode</code> 和 <code>vdom</code> 有时可以替换使用。为了避免造成困惑，在本书中将统一使用 <code>vnode</code>。</p>\n<p>渲染器把虚拟 DOM 节点渲染为真实 DOM 节点的过程叫作<strong>挂载</strong>，通常用英文 mount 来表达。例如 Vue.js 组件中的 <code>mounted</code> 钩子就会在挂载完成时触发。这就意味着，在 <code>mounted</code> 钩子中可以访问真实 DOM 元素。理解这些名词有助于我们更好地理解框架的 API 设计。</p>\n<p>那么，渲染器把真实 DOM 挂载到哪里呢？其实渲染器并不知道应该把真实 DOM 挂载到哪里。因此，渲染器通常需要接收一个挂载点作为参数，用来指定具体的挂载位置。这里的“挂载点”其实就是一个 DOM 元素，渲染器会把该 DOM 元素作为容器元素，并把内容渲染到其中。我们通常用英文 container 来表达容器。</p>\n<p>上文分别阐述了渲染器、虚拟 DOM（或虚拟节点）、挂载以及容器等概念。为了便于理解，下面举例说明：</p>\n<pre class=\"code-rows\"><code> function createRenderer() {\n   function render(vnode, container) {\n     // ...\n   }\n<p>return render<br />\n}<br />\n</code></pre></p>\n<p>如上面的代码所示，其中 <code>createRenderer</code> 函数用来创建一个渲染器。调用 <code>createRenderer</code> 函数会得到一个 <code>render</code> 函数，该 <code>render</code> 函数会以 <code>container</code> 为挂载点，将 <code>vnode</code> 渲染为真实 DOM 并添加到该挂载点下。</p>\n<p>你可能会对这段代码产生疑惑，如为什么需要 <code>createRenderer</code> 函数？直接定义 <code>render</code> 不就好了吗？其实不然，正如上文提到的，渲染器与渲染是不同的。渲染器是更加宽泛的概念，它包含渲染。渲染器不仅可以用来渲染，还可以用来激活已有的 DOM 元素，这个过程通常发生在同构渲染的情况下，如以下代码所示：</p>\n<pre class=\"code-rows\"><code> function createRenderer() {\n   function render(vnode, container) {\n     // ...\n   }\n<p>function hydrate(vnode, container) {<br />\n// …<br />\n}</p>\n<p>return {<br />\nrender,<br />\nhydrate<br />\n}<br />\n}<br />\n</code></pre></p>\n<p>可以看到，当调用 <code>createRenderer</code> 函数创建渲染器时，渲染器不仅包含 <code>render</code> 函数，还包含 <code>hydrate</code> 函数。关于 <code>hydrate</code> 函数，介绍服务端渲染时会详细讲解。这个例子说明，渲染器的内容非常广泛，而用来把 <code>vnode</code> 渲染为真实 DOM 的 <code>render</code> 函数只是其中一部分。实际上，在 Vue.js 3 中，甚至连创建应用的 <code>createApp</code> 函数也是渲染器的一部分。</p>\n<p>有了渲染器，我们就可以用它来执行渲染任务了，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> const renderer = createRenderer()\n // 首次渲染\n renderer.render(vnode, document.querySelector('#app'))\n</code></pre>\n<p>在上面这段代码中，我们首先调用 <code>createRenderer</code> 函数创建一个渲染器，接着调用渲染器的 <code>renderer.render</code> 函数执行渲染。当首次调用 <code>renderer.render</code> 函数时，只需要创建新的 DOM 元素即可，这个过程只涉及挂载。</p>\n<p>而当多次在同一个 <code>container</code> 上调用 <code>renderer.render</code> 函数进行渲染时，渲染器除了要执行挂载动作外，还要执行更新动作。例如：</p>\n<pre class=\"code-rows\"><code> const renderer = createRenderer()\n // 首次渲染\n renderer.render(oldVNode, document.querySelector('#app'))\n // 第二次渲染\n renderer.render(newVNode, document.querySelector('#app'))\n</code></pre>\n<p>如上面的代码所示，由于首次渲染时已经把 <code>oldVNode</code> 渲染到 <code>container</code> 内了，所以当再次调用 <code>renderer.render</code> 函数并尝试渲染 <code>newVNode</code> 时，就不能简单地执行挂载动作了。在这种情况下，渲染器会使用 <code>newVNode</code> 与上一次渲染的 <code>oldVNode</code> 进行比较，试图找到并更新变更点。这个过程叫作“打补丁”（或更新），英文通常用 patch 来表达。但实际上，挂载动作本身也可以看作一种特殊的打补丁，它的特殊之处在于旧的 <code>vnode</code> 是不存在的。所以我们不必过于纠结“挂载”和“打补丁”这两个概念。代码示例如下：</p>\n<pre class=\"code-rows\"><code> function createRenderer() {\n   function render(vnode, container) {\n     if (vnode) {\n       // 新 vnode 存在，将其与旧 vnode 一起传递给 patch 函数，进行打补丁\n       patch(container._vnode, vnode, container)\n     } else {\n       if (container._vnode) {\n         // 旧 vnode 存在，且新 vnode 不存在，说明是卸载（unmount）操作\n         // 只需要将 container 内的 DOM 清空即可\n         container.innerHTML = ''\n       }\n     }\n     // 把 vnode 存储到 container._vnode 下，即后续渲染中的旧 vnode\n     container._vnode = vnode\n   }\n<p>return {<br />\nrender<br />\n}<br />\n}<br />\n</code></pre></p>\n<p>上面这段代码给出了 <code>render</code> 函数的基本实现。我们可以配合下面的代码分析其执行流程，从而更好地理解 <code>render</code> 函数的实现思路。假设我们连续三次调用 <code>renderer.render</code> 函数来执行渲染：</p>\n<pre class=\"code-rows\"><code> const renderer = createRenderer()\n<p>// 首次渲染<br />\nrenderer.render(vnode1, document.querySelector(‘#app’))<br />\n// 第二次渲染<br />\nrenderer.render(vnode2, document.querySelector(‘#app’))<br />\n// 第三次渲染<br />\nrenderer.render(null, document.querySelector(‘#app’))<br />\n</code></pre></p>\n<ul>\n<li>在首次渲染时，渲染器会将 <code>vnode1</code> 渲染为真实 DOM。渲染完成后，<code>vnode1</code> 会存储到容器元素的 <code>container._vnode</code> 属性中，它会在后续渲染中作为旧 <code>vnode</code> 使用。</li>\n<li>在第二次渲染时，旧 <code>vnode</code> 存在，此时渲染器会把 <code>vnode2</code> 作为新 <code>vnode</code>，并将新旧 <code>vnode</code> 一同传递给 <code>patch</code> 函数进行打补丁。</li>\n<li>在第三次渲染时，新 <code>vnode</code> 的值为 <code>null</code>，即什么都不渲染。但此时容器中渲染的是 <code>vnode2</code> 所描述的内容，所以渲染器需要清空容器。从上面的代码中可以看出，我们使用 <code>container.innerHTML = ''</code> 来清空容器。需要注意的是，这样清空容器是有问题的，不过这里我们暂时使用它来达到目的。</li>\n</ul>\n<p>另外，在上面给出的代码中，我们注意到 <code>patch</code> 函数的签名，如下：</p>\n<pre class=\"code-rows\"><code> patch(container._vnode, vnode, container)\n</code></pre>\n<p>我们并没有给出 <code>patch</code> 的具体实现，但从上面的代码中，仍然可以窥探 <code>patch</code> 函数的部分细节。实际上，<code>patch</code> 函数是整个渲染器的核心入口，它承载了最重要的渲染逻辑，我们会花费大量篇幅来详细讲解它，但这里仍有必要对它做一些初步的解释。<code>patch</code> 函数至少接收三个参数：</p>\n<pre class=\"code-rows\"><code> function patch(n1, n2, container) {\n   // ...\n }\n</code></pre>\n<ul>\n<li>第一个参数 <code>n1</code>：旧 <code>vnode</code>。</li>\n<li>第二个参数 <code>n2</code>：新 <code>vnode</code>。</li>\n<li>第三个参数 <code>container</code>：容器。</li>\n</ul>\n<p>在首次渲染时，容器元素的 <code>container._vnode</code> 属性是不存在的，即 <code>undefined</code>。这意味着，在首次渲染时传递给 <code>patch</code> 函数的第一个参数 <code>n1</code> 也是 <code>undefined</code>。这时，<code>patch</code> 函数会执行挂载动作，它会忽略 <code>n1</code>，并直接将 <code>n2</code> 所描述的内容渲染到容器中。从这一点可以看出，<code>patch</code> 函数不仅可以用来完成打补丁，也可以用来执行挂载。</p>\n<h2 id=\"nav_point_73\">7.3　自定义渲染器</h2>\n<p>正如我们一直强调的，渲染器不仅能够把虚拟 DOM 渲染为浏览器平台上的真实 DOM。通过将渲染器设计为可配置的“通用”渲染器，即可实现渲染到任意目标平台上。本节我们将以浏览器作为渲染的目标平台，编写一个渲染器，在这个过程中，看看哪些内容是可以抽象的，然后通过抽象，将浏览器特定的 API 抽离，这样就可以使得渲染器的核心不依赖于浏览器。在此基础上，我们再为那些被抽离的 API 提供可配置的接口，即可实现渲染器的跨平台能力。</p>\n<p>我们从渲染一个普通的 <code>&lt;h1&gt;</code> 标签开始。可以使用如下 <code>vnode</code> 对象来描述一个 <code>&lt;h1&gt;</code> 标签：</p>\n<pre class=\"code-rows\"><code> const vnode = {\n   type: 'h1',\n   children: 'hello'\n }\n</code></pre>\n<p>观察上面的 <code>vnode</code> 对象。我们使用 <code>type</code> 属性来描述一个 <code>vnode</code> 的类型，不同类型的 <code>type</code> 属性值可以描述多种类型的 <code>vnode</code>。当 <code>type</code> 属性是字符串类型值时，可以认为它描述的是普通标签，并使用该 <code>type</code> 属性的字符串值作为标签的名称。对于这样一个 <code>vnode</code>，我们可以使用 <code>render</code> 函数渲染它，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> const vnode = {\n   type: 'h1',\n   children: 'hello'\n }\n // 创建一个渲染器\n const renderer = createRenderer()\n // 调用 render 函数渲染该 vnode\n renderer.render(vnode, document.querySelector('#app'))\n</code></pre>\n<p>为了完成渲染工作，我们需要补充 <code>patch</code> 函数：</p>\n<pre class=\"code-rows\"><code> function createRenderer() {\n   function patch(n1, n2, container) {\n     // 在这里编写渲染逻辑\n   }\n<p>function render(vnode, container) {<br />\nif (vnode) {<br />\npatch(container._vnode, vnode, container)<br />\n} else {<br />\nif (container._vnode) {<br />\ncontainer.innerHTML = ‘’<br />\n}<br />\n}<br />\ncontainer._vnode = vnode<br />\n}</p>\n<p>return {<br />\nrender<br />\n}<br />\n}<br />\n</code></pre></p>\n<p>如上面的代码所示，我们将 <code>patch</code> 函数也编写在 <code>createRenderer</code> 函数内。在后续的讲解中，如果没有特殊声明，我们编写的函数都定义在 <code>createRenderer</code> 函数内。</p>\n<p><code>patch</code> 函数的代码如下：</p>\n<pre class=\"code-rows\"><code> function patch(n1, n2, container) {\n   // 如果 n1 不存在，意味着挂载，则调用 mountElement 函数完成挂载\n   if (!n1) {\n     mountElement(n2, container)\n   } else {\n     // n1 存在，意味着打补丁，暂时省略\n   }\n }\n</code></pre>\n<p>在上面这段代码中，第一个参数 <code>n1</code> 代表旧 <code>vnode</code>，第二个参数 <code>n2</code> 代表新 <code>vnode</code>。当 <code>n1</code> 不存在时，意味着没有旧 <code>vnode</code>，此时只需要执行挂载即可。这里我们调用 <code>mountElement</code> 完成挂载，它的实现如下：</p>\n<pre class=\"code-rows\"><code> function mountElement(vnode, container) {\n   // 创建 DOM 元素\n   const el = document.createElement(vnode.type)\n   // 处理子节点，如果子节点是字符串，代表元素具有文本节点\n   if (typeof vnode.children === 'string') {\n     // 因此只需要设置元素的 textContent 属性即可\n     el.textContent = vnode.children\n   }\n   // 将元素添加到容器中\n   container.appendChild(el)\n }\n</code></pre>\n<p>上面这段代码我们并不陌生，第 3 章曾初步讲解过渲染器的相关内容。首先调用 <code>document.createElement</code> 函数，以 <code>vnode.type</code> 的值作为标签名称创建新的 DOM 元素。接着处理 <code>vnode.children</code>，如果它的值是字符串类型，则代表该元素具有文本子节点，这时只需要设置元素的 <code>textContent</code> 即可。最后调用 <code>appendChild</code> 函数将新创建的 DOM 元素添加到容器元素内。这样，我们就完成了一个 <code>vnode</code> 的挂载。</p>\n<p>挂载一个普通标签元素的工作已经完成。接下来，我们分析这段代码存在的问题。我们的目标是设计一个不依赖于浏览器平台的通用渲染器，但很明显，<code>mountElement</code> 函数内调用了大量依赖于浏览器的 API，例如 <code>document.createElement</code>、<code>el.textContent</code> 以及 <code>appendChild</code> 等。想要设计通用渲染器，第一步要做的就是将这些浏览器特有的 API 抽离。怎么做呢？我们可以将这些操作 DOM 的 API 作为配置项，该配置项可以作为 <code>createRenderer</code> 函数的参数，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> // 在创建 renderer 时传入配置项\n const renderer = createRenderer({\n   // 用于创建元素\n   createElement(tag) {\n     return document.createElement(tag)\n   },\n   // 用于设置元素的文本节点\n   setElementText(el, text) {\n     el.textContent = text\n   },\n   // 用于在给定的 parent 下添加指定元素\n   insert(el, parent, anchor = null) {\n     parent.insertBefore(el, anchor)\n   }\n })\n</code></pre>\n<p>可以看到，我们把用于操作 DOM 的 API 封装为一个对象，并把它传递给 <code>createRenderer</code> 函数。这样，在 <code>mountElement</code> 等函数内就可以通过配置项来取得操作 DOM 的 API 了：</p>\n<pre class=\"code-rows\"><code> function createRenderer(options) {\n<p>// 通过 options 得到操作 DOM 的 API<br />\nconst {<br />\ncreateElement,<br />\ninsert,<br />\nsetElementText<br />\n} = options</p>\n<p>// 在这个作用域内定义的函数都可以访问那些 API<br />\nfunction mountElement(vnode, container) {<br />\n// …<br />\n}</p>\n<p>function patch(n1, n2, container) {<br />\n// …<br />\n}</p>\n<p>function render(vnode, container) {<br />\n// …<br />\n}</p>\n<p>return {<br />\nrender<br />\n}<br />\n}<br />\n</code></pre></p>\n<p>接着，我们就可以使用从配置项中取得的 API 重新实现 <code>mountElement</code> 函数：</p>\n<pre class=\"code-rows\"><code> function mountElement(vnode, container) {\n   // 调用 createElement 函数创建元素\n   const el = createElement(vnode.type)\n   if (typeof vnode.children === 'string') {\n     // 调用 setElementText 设置元素的文本节点\n     setElementText(el, vnode.children)\n   }\n   // 调用 insert 函数将元素插入到容器内\n   insert(el, container)\n }\n</code></pre>\n<p>如上面的代码所示，重构后的 <code>mountElement</code> 函数在功能上没有任何变化。不同的是，它不再直接依赖于浏览器的特有 API 了。这意味着，只要传入不同的配置项，就能够完成非浏览器环境下的渲染工作。为了展示这一点，我们可以实现一个用来打印渲染器操作流程的自定义渲染器，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> const renderer = createRenderer({\n   createElement(tag) {\n     console.log(`创建元素 $`)\n     return { tag }\n   },\n   setElementText(el, text) {\n     console.log(`设置 $ 的文本内容：$`)\n     el.textContent = text\n   },\n   insert(el, parent, anchor = null) {\n     console.log(`将 $ 添加到 $ 下`)\n     parent.children = el\n   }\n })\n</code></pre>\n<p>观察上面的代码，在调用 <code>createRenderer</code> 函数创建 <code>renderer</code> 时，传入了不同的配置项。在 <code>createElement</code> 内，我们不再调用浏览器的 API，而是仅仅返回一个对象 <code>{ tag }</code>，并将其作为创建出来的“DOM 元素”。同样，在 <code>setElementText</code> 以及 <code>insert</code> 函数内，我们也没有调用浏览器相关的 API，而是自定义了一些逻辑，并打印信息到控制台。这样，我们就实现了一个自定义渲染器，可以用下面这段代码来检测它的能力：</p>\n<pre class=\"code-rows\"><code> const vnode = {\n   type: 'h1',\n   children: 'hello'\n }\n // 使用一个对象模拟挂载点\n const container = { type: 'root' }\n renderer2.render(vnode, container)\n</code></pre>\n<p>需要指出的是，由于上面实现的自定义渲染器不依赖浏览器特有的 API，所以这段代码不仅可以在浏览器中运行，还可以在 Node.js 中运行。图 7-1 给出了在浏览器中的运行结果。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00522.jpeg\" alt=\"\" width=\"85%\" style=\"width: 85%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 7-1　渲染器的运行结果</strong></p>\n<p>现在，我们对自定义渲染器有了更深刻的认识了。自定义渲染器并不是“黑魔法”，它只是通过抽象的手段，让核心代码不再依赖平台特有的 API，再通过支持个性化配置的能力来实现跨平台。</p>\n<h2 id=\"nav_point_74\">7.4　总结</h2>\n<p>在本章中，我们首先介绍了渲染器与响应系统的关系。利用响应系统的能力，我们可以做到，当响应式数据变化时自动完成页面更新（或重新渲染）。同时我们注意到，这与渲染器的具体实现无关。我们实现了一个极简的渲染器，它只能利用 <code>innerHTML</code> 属性将给定的 HTML 字符串内容设置到容器中。</p>\n<p>接着，我们讨论了与渲染器相关的基本名词和概念。渲染器的作用是把虚拟 DOM 渲染为特定平台上的真实元素，我们用英文 renderer 来表达渲染器。虚拟 DOM 通常用英文 virtual DOM 来表达，有时会简写成 <code>vdom</code> 或 <code>vnode</code>。渲染器会执行挂载和打补丁操作，对于新的元素，渲染器会将它挂载到容器内；对于新旧 <code>vnode</code> 都存在的情况，渲染器则会执行打补丁操作，即对比新旧 <code>vnode</code>，只更新变化的内容。</p>\n<p>最后，我们讨论了自定义渲染器的实现。在浏览器平台上，渲染器可以利用 DOM API 完成 DOM 元素的创建、修改和删除。为了让渲染器不直接依赖浏览器平台特有的 API，我们将这些用来创建、修改和删除元素的操作抽象成可配置的对象。用户可以在调用 <code>createRenderer</code> 函数创建渲染器的时候指定自定义的配置对象，从而实现自定义的行为。我们还实现了一个用来打印渲染器操作流程的自定义渲染器，它不仅可以在浏览器中运行，还可以在 Node.js 中运行。</p>\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"第 6 章 原始值的响应式方案","id":740768},"right":{"article_title":"第 8 章 挂载与更新(1)","id":740770}},"comments":[{"had_liked":false,"id":394495,"user_name":"若川","can_delete":false,"product_type":"c1","uid":1230852,"ip_address":"浙江","ucode":"B8C3DD4B38CC6F","user_header":"https://static001.geekbang.org/account/avatar/00/12/c8/04/fed4c1ad.jpg","comment_is_top":false,"comment_ctime":1726973470,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636603,"comment_content":"`&lt;h1&gt;$&lt;&#47;h1&gt;` 应该是 `&lt;h1&gt;${count}&lt;&#47;h1&gt;` ，还有一些代码被转义了，格式错乱了，应该是极客时间对代码块支持不够友好。","like_count":0}]}