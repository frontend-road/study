{"id":728107,"title":"16｜tokio编程：使用channel在不同任务间通信？","content":"<p>你好，我是Mike。今天我们来了解并发编程的另一种范式——使用channel在不同的任务间进行通信。</p><p>channel翻译成中文就是通道或管道，用来在task之间传递消息。这个概念本身并不难。我们回忆一下上节课的目标：要在多个任务中同时对一个内存数据库进行更新。其实我们也可以用channel的思路来解决这个问题。</p><p>我们先来分解一下任务。</p><ol>\n<li>创建三个子任务，task_a、task_b 和另一个起代理作用的 task_c。</li>\n<li>在 task_a 和 task_b 中，不直接操作db本身，而是向 task_c 发一个消息。</li>\n<li>task_c 里面会拿到 db 的所有权，收到从 task_a 和 task_b 来的消息后，对db进行操作。</li>\n</ol><p>基于这个思路，我们来重写上一节课的示例。</p><h2>MPSC Channel</h2><p>我们使用tokio中的MPSC Channel来实现。MPSC Channel是多生产者，单消费者通道（Multi-Producers Single Consumer）。</p><p>MPSC的基本用法如下：</p><pre><code class=\"language-plain\">let (tx, mut rx) = mpsc::channel(100);\n</code></pre><p>使用MPSC模块的 <code>channel()</code> 函数创建一个通道对，tx表示发送端，rx表示接收端，rx前面要加mut修饰符，因为rx在接收数据的时候使用了可变借用。channel使用的时候要给一个整数参数，表示这个通道容量多大。tokio的这个 <code>mpsc::channel</code> 是带背压功能的，也就是说，如果发送端发得太快，接收端来不及消耗导致通道堵塞了的话，这个channel会让发送端阻塞等待，直到通道里面的数据包被消耗到留出空位为止。</p><!-- [[[read_end]]] --><p>MPSC的特点就是可以有多个生产者，但只有一个消费者。因此，tx可以被随意clone多份，但是rx只能有一个。</p><p>前面的例子，我们用channel来实现。</p><pre><code class=\"language-plain\">use tokio::sync::mpsc;\n\n#[tokio::main]\nasync fn main() {\n&nbsp; &nbsp; let mut db: Vec&lt;u32&gt; = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n&nbsp; &nbsp; let (tx, mut rx) = mpsc::channel::&lt;u32&gt;(100);  // 创建channel\n\n&nbsp; &nbsp; let tx1 = tx.clone();  // 拷贝两份arc\n&nbsp; &nbsp; let tx2 = tx.clone();\n\n&nbsp; &nbsp; let task_a = tokio::task::spawn(async move {\n&nbsp; &nbsp; &nbsp; &nbsp; if let Err(_) = tx1.send(50).await {  // 发送端标准写法\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; println!(\"receiver dropped\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; });\n&nbsp; &nbsp; let task_b = tokio::task::spawn(async move {\n&nbsp; &nbsp; &nbsp; &nbsp; if let Err(_) = tx2.send(100).await {  // 发送端标准写法\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; println!(\"receiver dropped\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; });\n\n&nbsp; &nbsp; let task_c = tokio::task::spawn(async move {\n&nbsp; &nbsp; &nbsp; &nbsp; while let Some(i) = rx.recv().await {  // 接收端标准写法\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; println!(\"got = {}\", i);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; db[4] = i;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; println!(\"{:?}\", db);\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; });\n&nbsp; &nbsp; _ = task_a.await.unwrap();\n&nbsp; &nbsp; _ = task_b.await.unwrap();\n&nbsp; &nbsp; _ = task_c.await.unwrap();\n}\n//输出\ngot = 50\n[1, 2, 3, 4, 50, 6, 7, 8, 9, 10]\ngot = 100\n[1, 2, 3, 4, 100, 6, 7, 8, 9, 10]\n^C\n</code></pre><p>代码第6行，我们使用 <code>let (tx, mut rx) = mpsc::channel::&lt;u32&gt;(100);</code> 创建一个channel，注意，这一句使用 <code>::&lt;u32&gt;</code> 指定了这个channel中要传输的消息类型，也就是传u32类型的整数，通道容量为100个消息。<br>\n第8行和第9行，clone了两份tx。因为tx本质上实现为一个Arc对象，因此clone它也就只增加了引用计数，没有多余的性能消耗。</p><p>第11行和第17行，创建了两个工作者任务，在里面我们用 <code>if let Err(_) = tx1.send(50).await</code> 这种写法来向 channel 中发送信息，因为向 MPSC Channel 中灌数据时，是有可能会出错的，比如channel的另一端 rx 已经关闭了（被释放了），那么这时候再用 tx 发数据就会产生一个错误，所以这里需要用 <code>if let Err(_)</code> 这种形式来处理错误。</p><p>第24行，创建一个代理任务 task_c，使用这种写法 <code>while let Some(i) = rx.recv().await</code> 来接收消息。这里 <code>rx.recv().await</code> 获取回来的是一个 <code>Option&lt;u32&gt;</code> 类型，因此要用 <code>while let Some(i)</code> 这种模式匹配语法来写，i 就是收到的消息。然后在while内部处理具体的业务就行了。当 rx 收到一个 None 值（channel关闭产生的）的时候，会退出这个循环。</p><p>可以看到，当业务正常进行时，这个程序不会自动终止，而是会一直处于工作状态，最后我们得用 Ctrl-C 在终端终止它的运行。为什么呢？因为 while let 没有退出。<code>rx.recv().await</code> 一直在等待下一个msg的到来，但是前面两个发消息的任务 task_a、task_b 的工作已经完成，退出了，于是没有角色给rx发消息了，它就会一直等下去。这里的 <code>.await</code> 是一种不消耗资源的等待，tokio保证这种等待不会让一个CPU忙空转。</p><p>第31行～第33行的顺序在这里并不是很重要，你可以试试改变 task_a、task_b、task_c 的 await 的顺序，看看输出结果的变化。</p><p>花几分钟理解了这个过程后，你会发现这个方案的思维方式和前面使用锁的方式完全不同。这其实是一种常见的设计模式：代理模式。</p><h3>真正的并发执行</h3><p><code>tokio::task::spawn()</code> 这个API有个特点，就是通过它创建的异步任务，一旦创建好，就会立即扔到tokio runtime 里执行，不需要对其返回的 JoinHandler 进行 await 才驱动执行，这个特性很重要。</p><p>我们使用这个特性分析一下前面的示例：task_a、task_b、task_c 创建好之后，实际就已经开始执行了。task_c 已经在等待channel数据的到来了。第31到33行JoinHandler的await只是在等待任务本身结束而已。我们试着修改一下上面的示例。</p><pre><code class=\"language-plain\">use std::time::Duration;\nuse tokio::sync::mpsc;\nuse tokio::task;\nuse tokio::time;\n\n#[tokio::main]\nasync fn main() {\n&nbsp; &nbsp; let mut db: Vec&lt;u32&gt; = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n&nbsp; &nbsp; let (tx, mut rx) = mpsc::channel::&lt;u32&gt;(100);\n\n&nbsp; &nbsp; let tx1 = tx.clone();\n&nbsp; &nbsp; let tx2 = tx.clone();\n\n&nbsp; &nbsp; let task_a = task::spawn(async move {\n&nbsp; &nbsp; &nbsp; &nbsp; println!(\"in task_a 1\");\n&nbsp; &nbsp; &nbsp; &nbsp; time::sleep(Duration::from_secs(3)).await;  // 等待3s\n&nbsp; &nbsp; &nbsp; &nbsp; println!(\"in task_a 2\");\n&nbsp; &nbsp; &nbsp; &nbsp; if let Err(_) = tx1.send(50).await {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; println!(\"receiver dropped\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; });\n&nbsp; &nbsp; let task_b = task::spawn(async move {\n&nbsp; &nbsp; &nbsp; &nbsp; println!(\"in task_b\");\n&nbsp; &nbsp; &nbsp; &nbsp; if let Err(_) = tx2.send(100).await {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; println!(\"receiver dropped\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; });\n\n&nbsp; &nbsp; let task_c = task::spawn(async move {\n&nbsp; &nbsp; &nbsp; &nbsp; while let Some(i) = rx.recv().await {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; println!(\"got = {}\", i);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; db[4] = i;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; println!(\"{:?}\", db);\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; });\n\n&nbsp; &nbsp; _ = task_c.await.unwrap();  // task_c 放在前面来await\n&nbsp; &nbsp; _ = task_a.await.unwrap();\n&nbsp; &nbsp; _ = task_b.await.unwrap();\n}\n// 输出 \nin task_a 1\nin task_b\ngot = 100\n[1, 2, 3, 4, 100, 6, 7, 8, 9, 10]\nin task_a 2\ngot = 50\n[1, 2, 3, 4, 50, 6, 7, 8, 9, 10]\n^C\n</code></pre><p>在这个示例里，我们在task_a中sleep了3秒（第16行）。同时把 task_c 放到最前面去 await 了（第39行）。可以看到，task_b发来的数据先打印，3秒后，task_a发来的数据打印了。</p><p>实际对于main 函数这个 task 来讲，它其实被阻塞在了第39行，因为 task_c 一直在 await，并没有结束。task_a 和 task_b 虽然已经结束了，但是并没有执行到第 40 行和第 41 行去。对整个程序的输出来讲，没有执行到第 40 行和第 41 行并不影响最终效果。你仔细体会一下。</p><p>所以使用 <code>task::spawn()</code> 创建的多个任务之间，本身就是并发执行的关系。你可以对比一下这两个示例。</p><h3>unbounded channel</h3><p>tokio::mpsc模块里还有一个函数 <code>mpsc::unbounded_channel()</code>，可以用来创建没有容量上限的通道，也就意味着，它不具有背压功能。这个通道里面能存多少数据，就看机器的内存多大，极端情况下，可能会撑爆你的服务器。而在使用方法上，这两种channel区别不大，因此不再举例说明。如果你感兴趣的话可以看一下我给出的<a href=\"https://docs.rs/tokio/1.33.0/tokio/sync/mpsc/fn.unbounded_channel.html\">链接</a>。</p><h2>Oneshot Channel</h2><p>如果现在我们要在前面示例的基础上增加一个需求：我在task_c中将db更新完成，想给 task_a 和 task_b 返回一个事件通知说，我已经完成了，应该怎么做？</p><p>这个问题当然不止一种解法，比如外部增加一个消息队列，将这两个消息抛进消息队列里面，让task_a和task_b监听这个队列。然而这个方案会增加对外部服务的依赖，可能是一个订阅-发布服务；task_a和task_b 里需要订阅外部消息队列，并过滤对应的消息进行处理。</p><p>tokio其实内置了另外一个好用的东西 Oneshot channel，它可以配合 MPSC Channel 完成我们的任务。Oneshot定义了这样一个模型，这个通道只能用一次，也就是说只能发送一条数据，发送完之后就关闭了，对应的tx和rx就无法再次使用了。这个很适合等待计算结果返回的场景。我们试着用这个新设施来实现一下我们的需求。</p><pre><code class=\"language-plain\">use std::time::Duration;\nuse tokio::sync::{mpsc, oneshot};\nuse tokio::task;\nuse tokio::time;\n\n#[tokio::main]\nasync fn main() {\n&nbsp; &nbsp; let mut db: Vec&lt;u32&gt; = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n&nbsp; &nbsp; let (tx, mut rx) = mpsc::channel::&lt;(u32, oneshot::Sender&lt;bool&gt;)&gt;(100);\n\n&nbsp; &nbsp; let tx1 = tx.clone();\n&nbsp; &nbsp; let tx2 = tx.clone();\n\n&nbsp; &nbsp; let task_a = task::spawn(async move {\n&nbsp; &nbsp; &nbsp; &nbsp; time::sleep(Duration::from_secs(3)).await;\n&nbsp; &nbsp; &nbsp; &nbsp; let (resp_tx, resp_rx) = oneshot::channel();\n&nbsp; &nbsp; &nbsp; &nbsp; if let Err(_) = tx1.send((50, resp_tx)).await {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; println!(\"receiver dropped\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; if let Ok(ret) = resp_rx.await {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ret {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; println!(\"task_a finished with success.\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; println!(\"task_a finished with failure.\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; } else {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; println!(\"oneshot sender dropped\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; });\n&nbsp; &nbsp; let task_b = task::spawn(async move {\n&nbsp; &nbsp; &nbsp; &nbsp; let (resp_tx, resp_rx) = oneshot::channel();\n&nbsp; &nbsp; &nbsp; &nbsp; if let Err(_) = tx2.send((100, resp_tx)).await {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; println!(\"receiver dropped\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; if let Ok(ret) = resp_rx.await {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ret {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; println!(\"task_b finished with success.\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; println!(\"task_b finished with failure.\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; } else {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; println!(\"oneshot sender dropped\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; });\n\n&nbsp; &nbsp; let task_c = task::spawn(async move {\n&nbsp; &nbsp; &nbsp; &nbsp; while let Some((i, resp_tx)) = rx.recv().await {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; println!(\"got = {}\", i);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; db[4] = i;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; println!(\"{:?}\", db);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resp_tx.send(true).unwrap();\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; });\n\n&nbsp; &nbsp; _ = task_a.await.unwrap();\n&nbsp; &nbsp; _ = task_b.await.unwrap();\n&nbsp; &nbsp; _ = task_c.await.unwrap();\n}\n// 输出\ngot = 100\n[1, 2, 3, 4, 100, 6, 7, 8, 9, 10]\ntask_b finished with success.\ngot = 50\n[1, 2, 3, 4, 50, 6, 7, 8, 9, 10]\ntask_a finished with success.\n^C\n</code></pre><p>解释一下这个例子，这个例子里的第9行，把消息类型定义成了 <code>(u32, oneshot::Sender&lt;bool&gt;)</code>。对，你没看错，是一个元组，元组的第二个元素为oneshot channel 的发送端类型。</p><p>然后第16行，在task_a中创建了一个 Oneshot channel，两个端为 resp_tx和resp_rx。然后在第17行，把resp_tx实例直接放在消息中，随着MPSC Channel一起发送给 task_c了。然后在 task_a 里用 resp_rx 等待 oneshot 通道的值传过来。这点很关键。task_b也是类似的处理。</p><p>在task_c里，第51行收到的消息是 <code>Some((i, resp_tx))</code>，task_c 拿到了 task_a 和 task_b 里创建的 Oneshot channel 的发送端 resp_tx，就可以用它在第55行把计算的结果发送回去: <code>resp_tx.send(true).unwrap();</code>。</p><p>这个例子非常精彩，也是一种比较固定的模式。因为通道两个端本身就是类型的实例，当然可以被其他通道传输。这里我们 MPSC + Oneshot 两种通道成功实现了 Request/Response 模式。</p><h2>tokio中的其他channel类型</h2><p>接下来我们再介绍一下tokio中的其他channel类型。tokio中还有两个内置通道类型，用得不是那么多，但功能非常强大，你可以在遇到合适的场景时再去具体研究。</p><h3>broadcast channel</h3><p>广播模式，实现了MPMC模型，也就是多生产者多消费者模式，可以用来实现发布-订阅模式。每个消费者都会收到每个生产者发出的同样的消息副本。你可以查看<a href=\"https://docs.rs/tokio/1.33.0/tokio/sync/broadcast/index.html\">链接</a>了解学习。</p><p>broadcast通道实际已覆盖SPMC模型，所以不用再单独定义SPMC了。</p><h3>watch channel</h3><p>watch通道实际是一个特定化版本的broadcast通道，它有2个特性。</p><ol>\n<li>只有一个生产者，多个消费者。</li>\n<li>只关心最后一个值。</li>\n</ol><p>它适用于一些特定的场景，比如配置更新需要通知工作任务重新加载，平滑关闭任务等等。你可以通过我给出的<a href=\"https://docs.rs/tokio/1.33.0/tokio/sync/watch/index.html\">链接</a>进一步学习。</p><h2>补充知识：任务管理的2种常见模式</h2><h3>等待所有任务一起返回</h3><p>前面示例中task_c很关键。为什么呢？因为它不但起到了搜集数据执行操作的作用，它还把整个程序阻塞住了，保证了程序的持续运行。那如果一个程序里面没有负责这个任务的角色，应该怎么去搜集其他任务返回的结果呢？我们在<a href=\"https://time.geekbang.org/column/article/725837\">第 13 讲</a>中已经提到了一种方式。</p><pre><code class=\"language-plain\">use tokio::task;\n\nasync fn my_background_op(id: i32) -&gt; String {\n    let s = format!(\"Starting background task {}.\", id);\n    println!(\"{}\", s);\n    s\n}\n\n#[tokio::main]\nasync fn main() {\n    let ops = vec![1, 2, 3];\n    let mut tasks = Vec::with_capacity(ops.len());\n    for op in ops {\n        // 任务创建后，立即开始运行，我们用一个Vec来持有各个任务的handler\n        tasks.push(tokio::spawn(my_background_op(op)));\n    }\n    let mut outputs = Vec::with_capacity(tasks.len());\n    for task in tasks {\n        // 在这里依次等待任务完成\n        outputs.push(task.await.unwrap());\n    }\n    println!(\"{:?}\", outputs);\n}\n</code></pre><p>上面的代码有两个关键要点。</p><ol>\n<li>在第15行用一个Vec来存放所有任务的handler。</li>\n<li>在第20行依次对 task 进行 await，获取任务的返回值。</li>\n</ol><p>这代表了一种模式。这个模式有个特点，就是要等待前面任务结束，才能拿到后面任务的返回结果。如果前面某个任务执行的时间比较长，即使后面的任务实际已经执行完了，在最后搜集结果的时候，还是需要等前面那个任务结束了后，我们才能搜集到后面任务的结果。比如：</p><pre><code class=\"language-plain\">use std::time::Duration;\nuse tokio::task;\nuse tokio::time;\n\n#[tokio::main]\nasync fn main() {\n&nbsp; &nbsp; let task_a = task::spawn(async move {\n&nbsp; &nbsp; &nbsp; &nbsp; println!(\"in task_a\");\n&nbsp; &nbsp; &nbsp; &nbsp; time::sleep(Duration::from_secs(3)).await; // 等待3s\n&nbsp; &nbsp; &nbsp; &nbsp; 1\n&nbsp; &nbsp; });\n&nbsp; &nbsp; let task_b = task::spawn(async move {\n&nbsp; &nbsp; &nbsp; &nbsp; println!(\"in task_b\");\n&nbsp; &nbsp; &nbsp; &nbsp; 2\n&nbsp; &nbsp; });\n&nbsp; &nbsp; let task_c = task::spawn(async move {\n&nbsp; &nbsp; &nbsp; &nbsp; println!(\"in task_c\");\n&nbsp; &nbsp; &nbsp; &nbsp; 3\n&nbsp; &nbsp; });\n\n&nbsp; &nbsp; let mut tasks = Vec::with_capacity(3);\n&nbsp; &nbsp; tasks.push(task_a);\n&nbsp; &nbsp; tasks.push(task_b);\n&nbsp; &nbsp; tasks.push(task_c);\n\n&nbsp; &nbsp; let mut outputs = Vec::with_capacity(tasks.len());\n&nbsp; &nbsp; for task in tasks {\n&nbsp; &nbsp; &nbsp; &nbsp; println!(\"iterate task result..\");\n&nbsp; &nbsp; &nbsp; &nbsp; // 在这里依次等待任务完成\n&nbsp; &nbsp; &nbsp; &nbsp; outputs.push(task.await.unwrap());\n&nbsp; &nbsp; }\n&nbsp; &nbsp; println!(\"{:?}\", outputs);\n}\n// 输出 \niterate task result..\nin task_a\nin task_b\nin task_c   // 在这之后会等待 3 秒，然后继续打印 \niterate task result..\niterate task result..\n[1, 2, 3]\n</code></pre><p>上面的示例创建了三个任务 task_a、task_b、task_c，在task_a里等待3秒返回，task_b和task_c都是立即返回。执行的时候，当打印出 <code>\"in task_c\"</code> 后，会停止3秒左右，然后继续打印剩下的，印证了我们前面的分析。</p><p>tokio提供了一个宏 <code>tokio::join!()</code>，用来简化上面代码的写法，表示等待所有任务完成后，一起返回一个结果。用法如下：</p><pre><code class=\"language-plain\">use std::time::Duration;\nuse tokio::task;\nuse tokio::time;\n\n#[tokio::main]\nasync fn main() {\n&nbsp; &nbsp; let task_a = task::spawn(async move {\n&nbsp; &nbsp; &nbsp; &nbsp; println!(\"in task_a\");\n&nbsp; &nbsp; &nbsp; &nbsp; time::sleep(Duration::from_secs(3)).await; // 等待3s\n&nbsp; &nbsp; &nbsp; &nbsp; 1\n&nbsp; &nbsp; });\n&nbsp; &nbsp; let task_b = task::spawn(async move {\n&nbsp; &nbsp; &nbsp; &nbsp; println!(\"in task_b\");\n&nbsp; &nbsp; &nbsp; &nbsp; 2\n&nbsp; &nbsp; });\n&nbsp; &nbsp; let task_c = task::spawn(async move {\n&nbsp; &nbsp; &nbsp; &nbsp; println!(\"in task_c\");\n&nbsp; &nbsp; &nbsp; &nbsp; 3\n&nbsp; &nbsp; });\n\n&nbsp; &nbsp; let (r1, r2, r3) = tokio::join!(task_a, task_b, task_c);\n\n&nbsp; &nbsp; println!(\"{}, {}, {}\", r1.unwrap(), r2.unwrap(), r3.unwrap());\n}\n// 输出\nin task_a\nin task_b\nin task_c\n1, 2, 3\n</code></pre><p>这两个示例基本等价，都是在所有任务中等待最长的那个任务执行完成后，统一返回。你可以想想为什么它们差不多。</p><h3>等待其中一个任务先返回</h3><p>在实际场景中，还有另外一大类需求，就是在一批任务中，哪个任务先执行完，就马上返回那个任务的结果。剩下的任务，要么是不关心它们的执行结果，要么是直接取消它们继续执行。</p><p>针对这种场景，tokio提供了 <code>tokio::select!()</code> 宏。用法如下：</p><pre><code class=\"language-plain\">use std::time::Duration;\nuse tokio::task;\nuse tokio::time;\n\n#[tokio::main]\nasync fn main() {\n&nbsp; &nbsp; let task_a = task::spawn(async move {\n&nbsp; &nbsp; &nbsp; &nbsp; println!(\"in task_a\");\n&nbsp; &nbsp; &nbsp; &nbsp; time::sleep(Duration::from_secs(3)).await; // 等待3s\n&nbsp; &nbsp; &nbsp; &nbsp; 1\n&nbsp; &nbsp; });\n&nbsp; &nbsp; let task_b = task::spawn(async move {\n&nbsp; &nbsp; &nbsp; &nbsp; println!(\"in task_b\");\n&nbsp; &nbsp; &nbsp; &nbsp; 2\n&nbsp; &nbsp; });\n&nbsp; &nbsp; let task_c = task::spawn(async move {\n&nbsp; &nbsp; &nbsp; &nbsp; println!(\"in task_c\");\n&nbsp; &nbsp; &nbsp; &nbsp; 3\n&nbsp; &nbsp; });\n\n&nbsp; &nbsp; let ret = tokio::select! {\n&nbsp; &nbsp; &nbsp; &nbsp; r = task_a =&gt; r.unwrap(),\n&nbsp; &nbsp; &nbsp; &nbsp; r = task_b =&gt; r.unwrap(),\n&nbsp; &nbsp; &nbsp; &nbsp; r = task_c =&gt; r.unwrap(),\n&nbsp; &nbsp; };\n\n&nbsp; &nbsp; println!(\"{}\", ret);\n}\n// 输出\n// 第一次\nin task_b\nin task_a\n2\nin task_c\n// 第二次\nin task_a\nin task_c\nin task_b\n2\n// 第n次\nin task_a\nin task_c\nin task_b\n3\n</code></pre><p>请注意示例里第21行到第25行的写法，这是 <code>tokio::select!</code> 宏定义的语法，不是Rust标准语法。变量r表示任务的返回值。当你多次执行上面代码后，你会发现，输出结果并不固定，你可以想一下为什么会这样。</p><h2>小结</h2><p>这节课我们讨论了在Rust中如何应用channel这种编程范式，在并发编程中避免使用锁。Rust的tokio库提供了常用的通道模型基础设施。</p><ol>\n<li>MPSC 多生产者，单消费者 channel</li>\n<li>Oneshot 一次性 channel</li>\n<li>broadcast 广播模式</li>\n<li>watch 观察者模式</li>\n</ol><p>每种通道都有各自的用途，适用于不同的场景需求。这一讲我们重点讲解了前两种通道，只要你掌握了它们，另外两种使用方式也是差不多的。这节课讨论的这些模式相当固定，只要照搬套用就可以了。</p><p>本讲代码链接：<a href=\"https://github.com/miketang84/jikeshijian/tree/master/16-channel\">https://github.com/miketang84/jikeshijian/tree/master/16-channel</a></p><h2>思考题</h2><p>你可以说一说从任务中搜集返回结果有几种方式吗？欢迎你把你对课程的思考和疑问留在评论区，我会和你一起交流探讨，如果你觉得这节课的内容对你有帮助的话，也欢迎你分享给其他朋友，我们下节课再见！</p>","neighbors":{"left":{"article_title":"15｜tokio编程：在多任务之间操作同一片数据","id":728055},"right":{"article_title":"17｜tokio编程： Rust异步编程还有哪些需要注意的点？","id":728198}},"comments":[{"had_liked":false,"id":384389,"user_name":"刘丹","can_delete":false,"product_type":"c1","uid":1081922,"ip_address":"广东","ucode":"66594D1C957E15","user_header":"https://static001.geekbang.org/account/avatar/00/10/82/42/8b04d489.jpg","comment_is_top":false,"comment_ctime":1700787756,"is_pvip":false,"replies":[{"id":140247,"content":"这是tokio那个宏里面的特殊语法，不是标准的rust语法。就是一个语法而已。既不是闭包，也不是匿名函数","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700793571,"ip_address":"重庆","comment_id":384389,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"请问老师： r = task_a =&gt; r.unwrap() 这是闭包，还是匿名函数？\n\n","like_count":3,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632460,"discussion_content":"这是tokio那个宏里面的特殊语法，不是标准的rust语法。就是一个语法而已。既不是闭包，也不是匿名函数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700793571,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1508755,"avatar":"https://static001.geekbang.org/account/avatar/00/17/05/93/3c3f2a6d.jpg","nickname":"安石","note":"","ucode":"185AD0046CF1C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":646784,"discussion_content":"为什么rust这么多不是标准的语法，怎么通过编译的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1718719385,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":387042,"user_name":"superggn","can_delete":false,"product_type":"c1","uid":3623568,"ip_address":"北京","ucode":"831CCD98B393FE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/7Q403U68Oy4lXG5sFBPVKLrfwaRzBqpBZibpEBXcPf9UOO3qrnh7RELoByTLzBZLkN9Nukfsj7DibynbZjKAKgag/132","comment_is_top":false,"comment_ctime":1706254174,"is_pvip":false,"replies":[{"id":141117,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1706673547,"ip_address":"重庆","comment_id":387042,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"背压 - back pressure\n\n带背压的 channel\ntokio::mpsc::channel(n)\nstd::mpsc::sync_channel(n)\n\n不带背压的 channel\ntokio::mpsc::unbounded_channel();\nstd::mpsc::channel();","like_count":1,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636660,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1706673547,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":387036,"user_name":"Aaaaaaaaaaayou","can_delete":false,"product_type":"c1","uid":1073601,"ip_address":"广东","ucode":"67BA315B87587D","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/c1/93031a2a.jpg","comment_is_top":false,"comment_ctime":1706237925,"is_pvip":false,"replies":[{"id":141095,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1706240456,"ip_address":"重庆","comment_id":387036,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"join 和 select 类似于 JavaScript 中的 Promise.all 和 Promise.race","like_count":1,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636498,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1706240456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385830,"user_name":"superggn","can_delete":false,"product_type":"c1","uid":3623568,"ip_address":"北京","ucode":"831CCD98B393FE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/7Q403U68Oy4lXG5sFBPVKLrfwaRzBqpBZibpEBXcPf9UOO3qrnh7RELoByTLzBZLkN9Nukfsj7DibynbZjKAKgag/132","comment_is_top":false,"comment_ctime":1703483764,"is_pvip":false,"replies":[{"id":140629,"content":"棒棒哒","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1703577611,"ip_address":"重庆","comment_id":385830,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"思考题\n- Arc::new(Mutex::new(target_var));\n- res = join_handler.await.unwrap();\n- channel\n","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634495,"discussion_content":"棒棒哒","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1703577612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385827,"user_name":"superggn","can_delete":false,"product_type":"c1","uid":3623568,"ip_address":"北京","ucode":"831CCD98B393FE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/7Q403U68Oy4lXG5sFBPVKLrfwaRzBqpBZibpEBXcPf9UOO3qrnh7RELoByTLzBZLkN9Nukfsj7DibynbZjKAKgag/132","comment_is_top":false,"comment_ctime":1703476295,"is_pvip":false,"replies":[{"id":140628,"content":"哈哈，感谢指出，可能编辑的时候漏了。尽快处理","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1703577533,"ip_address":"重庆","comment_id":385827,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"捉虫： `等待所有任务一起返回`  main 前面少个 fn","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634494,"discussion_content":"哈哈，感谢指出，可能编辑的时候漏了。尽快处理","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1703577533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384539,"user_name":"刘永臣","can_delete":false,"product_type":"c1","uid":2033098,"ip_address":"北京","ucode":"31426CE31CA514","user_header":"https://static001.geekbang.org/account/avatar/00/1f/05/ca/eefef69b.jpg","comment_is_top":false,"comment_ctime":1701130367,"is_pvip":false,"replies":[{"id":140280,"content":"await是单个任务。rust中waitgroup实现也很简单。四种模式对应起来了，可能tokio就是借鉴的go channel。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1701158381,"ip_address":"重庆","comment_id":384539,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":".await()类似于等待组吧？ channel的四种模式也是go channel常用的四种场景。","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632663,"discussion_content":"await是单个任务。rust中waitgroup实现也很简单。四种模式对应起来了，可能tokio就是借鉴的go channel。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1701158382,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384428,"user_name":"学水","can_delete":false,"product_type":"c1","uid":2557688,"ip_address":"加拿大","ucode":"F8B27FD11187EC","user_header":"https://static001.geekbang.org/account/avatar/00/27/06/f8/09ad484b.jpg","comment_is_top":false,"comment_ctime":1700851703,"is_pvip":false,"replies":[{"id":140252,"content":"rx.await就是在task层面阻塞住。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700888937,"ip_address":"重庆","comment_id":384428,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"如果通道都没有任何生产者消息，select语句中的消费者是堵塞在那里还是会之间进入下一个语句呢","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632503,"discussion_content":"rx.await就是在task层面阻塞住。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700888937,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384409,"user_name":"老大","can_delete":false,"product_type":"c1","uid":1109637,"ip_address":"河南","ucode":"1134808B441F74","user_header":"https://static001.geekbang.org/account/avatar/00/10/ee/85/c0cf6544.jpg","comment_is_top":false,"comment_ctime":1700817008,"is_pvip":false,"replies":[{"id":140250,"content":"你可以帖一下代码。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700837390,"ip_address":"重庆","comment_id":384409,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"为啥我按照你写的，运行不起来呢？","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632492,"discussion_content":"你可以帖一下代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700837390,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384408,"user_name":"PEtFiSh","can_delete":false,"product_type":"c1","uid":1765926,"ip_address":"上海","ucode":"C4922398A92E05","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLO6XvxfFPMGcVSSX8uIZY2yib29qlyat178pU4QM3gIic5GXZ8PC0tzRiazP3FiajXbTj19SE4ZhV0gQ/132","comment_is_top":false,"comment_ctime":1700816941,"is_pvip":false,"replies":[{"id":140249,"content":"👍，很棒。mpsc 和 oneshot 都可以派上用场。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700837371,"ip_address":"重庆","comment_id":384408,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"从任务收集返回结果的方式有：\n1、任务直接返回值，然后通过handler取回，比如：a = task_a.await.unwrap();\n2、通过锁的方式直接写在目标位置\n3、通过channel的形式传递结果\n4、似乎也可以unsafe来写全局变量。","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632491,"discussion_content":"👍，很棒。mpsc 和 oneshot 都可以派上用场。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700837371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384384,"user_name":"伯阳","can_delete":false,"product_type":"c1","uid":1596631,"ip_address":"北京","ucode":"DBDC8735AA54AD","user_header":"https://static001.geekbang.org/account/avatar/00/18/5c/d7/3b92bb0d.jpg","comment_is_top":false,"comment_ctime":1700777887,"is_pvip":false,"replies":[{"id":140246,"content":"打满了就阻塞了。打不进去了，就等吧，消耗一个就能打进去一个。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700793524,"ip_address":"重庆","comment_id":384384,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"这种无锁并发，快是快了点，但是如果给通道打满了，怎么处理呢","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632459,"discussion_content":"打满了就阻塞了。打不进去了，就等吧，消耗一个就能打进去一个。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700793524,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":389979,"user_name":"BBJB","can_delete":false,"product_type":"c1","uid":1179528,"ip_address":"上海","ucode":"AE1717150476A3","user_header":"https://static001.geekbang.org/account/avatar/00/11/ff/88/36fb189f.jpg","comment_is_top":false,"comment_ctime":1714025446,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"MPSC Channel模式，如果在send的异步线程中，套一层循环 for i in 0..100{tx1.send(50).await}\n为什么接受线程需要等循环完才开始执行recv。而不是send一个，recv一个。","like_count":0},{"had_liked":false,"id":387043,"user_name":"superggn","can_delete":false,"product_type":"c1","uid":3623568,"ip_address":"北京","ucode":"831CCD98B393FE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/7Q403U68Oy4lXG5sFBPVKLrfwaRzBqpBZibpEBXcPf9UOO3qrnh7RELoByTLzBZLkN9Nukfsj7DibynbZjKAKgag/132","comment_is_top":false,"comment_ctime":1706254182,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"背压 - back pressure\n\n带背压的 channel\ntokio::mpsc::channel(n)\nstd::mpsc::sync_channel(n)\n\n不带背压的 channel\ntokio::mpsc::unbounded_channel();\nstd::mpsc::channel();","like_count":0}]}