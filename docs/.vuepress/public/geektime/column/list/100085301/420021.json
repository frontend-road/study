{"id":420021,"title":"12｜类型系统：Rust的类型系统有什么特点？","content":"<p>你好，我是陈天。今天我们就开始类型系统的学习。</p><p>如果你用 C/Golang 这样不支持泛型的静态语言，或者用 Python/Ruby/JavaScript 这样的动态语言，这个部分可能是个难点，希望你做好要转换思维的准备；如果你用 C++/Java/Swift 等支持泛型的静态语言，可以比较一下 Rust 和它们的异同。</p><p>其实在之前的课程中，我们已经写了不少 Rust 代码，使用了各种各样的数据结构，相信你对 Rust 的类型系统已经有了一个非常粗浅的印象。那类型系统到底是什么？能用来干什么？什么时候用呢？今天就来一探究竟。</p><p>作为一门语言的核心要素，类型系统很大程度上塑造了语言的用户体验以及程序的安全性。为什么这么说？因为，在机器码的世界中，没有类型而言，指令仅仅和立即数或者内存打交道，内存中存放的数据都是字节流。</p><p>所以，可以说<strong>类型系统完全是一种工具</strong>，编译器在编译时对数据做静态检查，或者语言在运行时对数据做动态检查的时候，来保证某个操作处理的数据是开发者期望的数据类型。</p><p>现在你是不是能理解，为什么Rust类型系统对类型问题的检查格外严格（总是报错）。</p><h2>类型系统基本概念与分类</h2><p>在具体讲 Rust 的类型系统之前，我们先来澄清一些类型系统的概念，在基本理解上达成一致。</p><!-- [[[read_end]]] --><p>在<a href=\"https://time.geekbang.org/column/article/410038\">第二讲</a>提到过，类型，是对值的区分，它包含了值在内存中的长度、对齐以及值可以进行的操作等信息。</p><p>比如 u32 类型，它是一个无符号 32 位整数，长度是 4 个字节，对齐也是 4 个字节，取值范围在 0～4G 之间；u32 类型实现了加减乘除、大小比较等接口，所以可以做类似 1 + 2、i &lt;= 3 这样的操作。</p><p><strong>类型系统其实就是，对类型进行定义、检查和处理的系统</strong>。所以，按对类型的操作阶段不同，就有了不同的划分标准，也对应有不同分类，我们一个一个看。</p><p>按定义后类型是否可以隐式转换，可以分为强类型和弱类型。Rust 不同类型间不能自动转换，所以是强类型语言，而 C / C++ / JavaScript 会自动转换，是弱类型语言。</p><p>按类型检查的时机，在编译时检查还是运行时检查，可以分为静态类型系统和动态类型系统。对于静态类型系统，还可以进一步分为显式静态和隐式静态，Rust / Java / Swift 等语言都是显式静态语言，而 Haskell 是隐式静态语言。</p><p>在类型系统中，多态是一个非常重要的思想，它是指<strong>在使用相同的接口时，不同类型的对象，会采用不同的实现</strong>。</p><p>对于动态类型系统，多态通过<a href=\"https://en.wikipedia.org/wiki/Duck_typing\">鸭子类型（duck typing）</a>实现；而对于静态类型系统，多态可以通过<a href=\"https://en.wikipedia.org/wiki/Parametric_polymorphism\">参数多态（parametric polymorphism）</a>、<a href=\"https://en.wikipedia.org/wiki/Ad_hoc_polymorphism\">特设多态（adhoc polymorphism）</a>和<a href=\"https://en.wikipedia.org/wiki/Subtyping\">子类型多态（subtype polymorphism）</a>实现。</p><ul>\n<li>参数多态是指，代码操作的类型是一个满足某些约束的参数，而非具体的类型。</li>\n<li>特设多态是指同一种行为有多个不同实现的多态。比如加法，可以 1+1，也可以是 “abc” + “cde”、matrix1 + matrix2、甚至 matrix1 + vector1。在面向对象编程语言中，特设多态一般指函数的重载。</li>\n<li>子类型多态是指，在运行时，子类型可以被当成父类型使用。</li>\n</ul><p>在 Rust 中，参数多态通过泛型来支持、特设多态通过 trait 来支持、子类型多态可以用 trait object 来支持，我们待会讲参数多态，下节课再详细讲另外两个。</p><p>你可以看下图来更好地厘清这些概念之间的关系：<img src=\"https://static001.geekbang.org/resource/image/09/15/09ea90a4df9fb7652389f611412c1715.jpg?wh=3175x1490\" alt=\"\"></p><h2>Rust 类型系统</h2><p>好，掌握了类型系统的基本概念和分类，再看 Rust 的类型系统。</p><p>按刚才不同阶段的分类，在定义时， Rust 不允许类型的隐式转换，也就是说，Rust 是强类型语言；同时在检查时，Rust 使用了静态类型系统，在编译期保证类型的正确。强类型加静态类型，使得 Rust 是一门类型安全的语言。</p><p>其实说到“类型安全”，我们经常听到这个术语，但是你真的清楚它是什么涵义吗？</p><p>从内存的角度看，<strong>类型安全是指代码，只能按照被允许的方法，访问它被授权访问的内存</strong>。</p><p>以一个长度为 4，存放 u64 数据的数组为例，访问这个数组的代码，只能在这个数组的起始地址到数组的结束地址之间这片 32 个字节的内存中访问，而且访问是按照 8 字节来对齐的，另外，数组中的每个元素，只能做 u64 类型允许的操作。对此，编译器会对代码进行严格检查来保证这个行为。我们看下图：<img src=\"https://static001.geekbang.org/resource/image/6c/ae/6ca5689ac928a05993faa9714e2ba5ae.jpg?wh=2382x1225\" alt=\"\"></p><p>所以 C/C++ 这样，定义后数据可以隐式转换类型的弱类型语言，不是内存安全的，而 Rust 这样的强类型语言，是类型安全的，不会出现开发者不小心引入了一个隐式转换，导致读取不正确的数据，甚至内存访问越界的问题。</p><p>在此基础上，Rust 还进一步对内存的访问进行了读/写分开的授权。所以，<strong>Rust 下的内存安全更严格：代码只能按照被允许的方法和被允许的权限，访问它被授权访问的内存</strong>。</p><p>为了做到这么严格的类型安全，Rust 中除了 let / fn / static / const 这些定义性语句外，都是表达式，而一切表达式都有类型，所以可以说在 Rust 中，类型无处不在。</p><p>你也许会有疑问，那类似这样的代码，它的类型是什么？</p><pre><code class=\"language-bash\">if has_work {\n    do_something();\n}\n</code></pre><p>在Rust中，对于一个作用域，无论是 if / else / for 循环，还是函数，最后一个表达式的返回值就是作用域的返回值，如果表达式或者函数不返回任何值，那么它返回一个 unit<code>()</code> 。unit 是只有一个值的类型，它的值和类型都是  <code>()</code> 。</p><p>像上面这个 if 块，它的类型和返回值是<code>()</code> ，所以当它被放在一个没有返回值的函数中，如下所示：</p><pre><code class=\"language-bash\">fn work(has_work: bool) {\n    if has_work {\n        do_something();\n    }\n}\n</code></pre><p>Rust 类型无处不在这个逻辑还是自洽的。</p><p>unit 的应用非常广泛，除了作为返回值，它还被大量使用在数据结构中，比如  <code>Result&lt;(), Error&gt;</code> 表示返回的错误类型中，我们只关心错误，不关心成功的值，再比如  <code>HashSet</code> 实际上是 <code>HashMap&lt;K, ()&gt;</code> 的一个类型别名。</p><p>到这里简单总结一下，我们了解到 Rust 是强类型/静态类型语言，并且在代码中，类型无处不在。</p><p>作为静态类型语言，Rust 提供了大量的数据类型，但是在使用的过程中，进行类型标注是很费劲的，所以Rust 类型系统贴心地提供了<strong>类型推导</strong>。</p><p>而对比动态类型系统，静态类型系统还比较麻烦的是，同一个算法，对应输入的数据结构不同，需要有不同的实现，哪怕这些实现没有什么逻辑上的差异。对此，Rust 给出的答案是<strong>泛型（参数多态）</strong>。</p><p>所以接下来，我们先看 Rust 有哪些基本的数据类型，然后了解一下类型推导是如何完成的，最后看 Rust 是如何支持泛型的。</p><h3>数据类型</h3><p>在第二讲中介绍了原生类型和组合类型的定义，今天就详细介绍一下这两种类型在 Rust 中的设计。</p><p>Rust 的原生类型包括字符、整数、浮点数、布尔值、数组（array）、元组（tuple）、切片（slice）、指针、引用、函数等，见下表（<a href=\"https://doc.rust-lang.org/std/index.html#primitives\">参考链接</a>）：<br>\n<img src=\"https://static001.geekbang.org/resource/image/71/d0/719040f24323c50b40724d4efb9211d0.jpg?wh=5000x5506\" alt=\"\"></p><p>在原生类型的基础上，Rust 标准库还支持非常丰富的组合类型，看看已经遇到的：<br>\n<img src=\"https://static001.geekbang.org/resource/image/33/c3/337088350e42836cb3372e7c5c460ec3.jpg?wh=2280x1777\" alt=\"\"></p><p>之后我们不断会遇到新的数据类型，推荐你有意识地记录一下，相信到最后，你的这个列表会积累得很长很长。</p><p>另外在 Rust 已有数据类型的基础上，你也可以使用结构体（struct）和标签联合（enum）定义自己的组合类型，之前已经有过详细的介绍，这里就不再赘述，你可以看下图回顾：<img src=\"https://static001.geekbang.org/resource/image/44/fb/44bfd66581deb983fc6eb227a6aa3afb.jpg?wh=3170x1829\" alt=\"\"></p><h3>类型推导</h3><p>作为静态类型系统的语言，虽然能够在编译期保证类型的安全，但一个很大的不便是，代码撰写起来很繁杂，到处都要进行类型的声明。尤其刚刚讲了 Rust 的数据类型相当多，所以，为了减轻开发者的负担，Rust 支持局部的类型推导。</p><p><strong>在一个作用域之内，Rust 可以根据变量使用的上下文，推导出变量的类型</strong>，这样我们就不需要显式地进行类型标注了。比如这段<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=ac740f4abf3db98cc0113dca94bac851\">代码</a>，创建一个 BTreeMap 后，往这个 map 里添加了 key 为 “hello”、value 为 “world” 的值：</p><pre><code class=\"language-rust\">use std::collections::BTreeMap;\n\nfn main() {\n&nbsp; &nbsp; let mut map = BTreeMap::new();\n&nbsp; &nbsp; map.insert(\"hello\", \"world\");\n&nbsp; &nbsp; println!(\"map: {:?}\", map);\n}\n</code></pre><p>此时， Rust 编译器可以从上下文中推导出， BTreeMap&lt;K, V&gt; 的类型 K 和 V 都是字符串引用 &amp;str，所以这段代码可以编译通过，然而，如果你把第 5 行这个作用域内的 insert 语句注释去掉，Rust 编译器就会报错：“cannot infer type for type parameter <code>K</code>”。</p><p>很明显，<strong>Rust 编译器需要足够的上下文来进行类型推导</strong>，所以有些情况下，编译器无法推导出合适的类型，比如下面的代码尝试把一个列表中的偶数过滤出来，生成一个新的列表（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=ef557a933b2c8af89d8084ca4148708e\">代码</a>）：</p><pre><code class=\"language-rust\">fn main() {\n    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n    let even_numbers = numbers\n        .into_iter()\n        .filter(|n| n % 2 == 0)\n        .collect();\n\n    println!(\"{:?}\", even_numbers);\n}\n</code></pre><p><code>collect</code> 是 <a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect\">Iterator trait 的方法</a>，它把一个 iterator 转换成一个集合。因为很多集合类型，如 Vec&lt;T&gt;、HashMap&lt;K, V&gt; 等都实现了 Iterator，所以这里的  <code>collect</code> 究竟要返回什么类型，编译器是无法从上下文中推断的。</p><p>所以这段代码无法编译，它会给出如下错误：“consider giving <code>even_numbers</code> a type”。</p><p>这种情况，就无法依赖类型推导来简化代码了，必须让 even_numbers 有一个明确的类型。所以，我们可以使用类型声明（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=b57f31c7959dce99e0e711e775a09111\">代码</a>）：</p><pre><code class=\"language-rust\">fn main() {\n&nbsp; &nbsp; let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n&nbsp; &nbsp; let even_numbers: Vec&lt;_&gt; = numbers\n&nbsp; &nbsp; &nbsp; &nbsp; .into_iter()\n&nbsp; &nbsp; &nbsp; &nbsp; .filter(|n| n % 2 == 0)\n&nbsp; &nbsp; &nbsp; &nbsp; .collect();\n\n&nbsp; &nbsp; println!(\"{:?}\", even_numbers);\n}\n</code></pre><p>注意这里编译器只是无法推断出集合类型，但集合类型内部元素的类型，还是可以根据上下文得出，所以我们可以简写成  <code>Vec&lt;_&gt;</code> 。</p><p>除了给变量一个显式的类型外，我们也可以让 collect 返回一个明确的类型（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=6e458e1ffbedea33eb67513c6e1cfe1a\">代码</a>）：</p><pre><code class=\"language-rust\">fn main() {\n&nbsp; &nbsp; let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n&nbsp; &nbsp; let even_numbers = numbers\n&nbsp; &nbsp; &nbsp; &nbsp; .into_iter()\n&nbsp; &nbsp; &nbsp; &nbsp; .filter(|n| n % 2 == 0)\n&nbsp; &nbsp; &nbsp; &nbsp; .collect::&lt;Vec&lt;_&gt;&gt;();\n\n&nbsp; &nbsp; println!(\"{:?}\", even_numbers);\n}\n</code></pre><p>你可以看到，在泛型函数后使用  <code>::&lt;T&gt;</code> 来强制使用类型 T，这种写法被称为 turbofish。我们再看一个对 IP 地址和端口转换的例子（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c199841389faf50ea3da7076b8d55999\">代码</a>）：</p><pre><code class=\"language-rust\">use std::net::SocketAddr;\n\nfn main() {\n    let addr = \"127.0.0.1:8080\".parse::&lt;SocketAddr&gt;().unwrap();\n    println!(\"addr: {:?}, port: {:?}\", addr.ip(), addr.port());\n}\n</code></pre><p>turbofish 的写法在很多场景都有优势，因为在某些上下文中，你想直接把一个表达式传递给一个函数或者当成一个作用域的返回值，比如：</p><pre><code class=\"language-bash\">match data {\n    Some(s) =&gt; v.parse::&lt;User&gt;()?,\n    _ =&gt; return Err(...),\n}\n</code></pre><p>如果 User 类型在上下文无法被推导出来，又没有 turbofish  的写法，我们就不得不先给一个局部变量赋值时声明类型，然后再返回，这样代码就变得冗余了。</p><p>有些情况下，<strong>即使上下文中含有类型的信息，也需要开发者为变量提供类型，比如常量和静态变量的定义</strong>。看一个例子（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=747b4ad1e512a1761e0b8279bec40c20\">代码</a>）：</p><pre><code class=\"language-rust\">const PI: f64 = 3.1415926;\nstatic E: f32 = 2.71828;\n\nfn main() {\n&nbsp; &nbsp; const V: u32 = 10;\n&nbsp; &nbsp; static V1: &amp;str = \"hello\";\n&nbsp; &nbsp; println!(\"PI: {}, E: {}, V {}, V1: {}\", PI, E, V, V1);\n}\n</code></pre><p>这可能是因为 const / static 主要用于定义全局变量，它们可以在不同的上下文中使用，所以为了代码的可读性，需要明确的类型声明。</p><h2>用泛型实现参数多态</h2><p>类型的定义和使用就讲到这里，刚才说过 Rust 通过泛型，来避免开发者为不同的类型提供不同的算法。一门静态类型语言不支持泛型，用起来是很痛苦的，比如我们熟悉的 Vec&lt;T&gt;，你能想像不支持泛型时，每一个类型 T，都要实现一遍 Vec&lt;T&gt; 么？太麻烦了。</p><p>所以我们现在来看看 Rust 对泛型的支持如何。今天先讲参数多态，它包括泛型数据结构和泛型函数，下一讲介绍特设多态和子类型多态。</p><h3>泛型数据结构</h3><p>Rust 对数据结构的泛型，或者说参数化类型，有着完整的支持。</p><p>在过去的学习中，其实你已经接触到了很多带有参数的数据类型，这些参数化类型可以极大地增强代码的复用性，减少代码的冗余。几乎所有支持静态类型系统的现代编程语言，都支持参数化类型，不过 <a href=\"https://blog.golang.org/generics-proposal\">Golang 目前是个例外</a>。</p><p>我们从一个最简单的泛型例子 Option&lt;T&gt;开始回顾：</p><pre><code class=\"language-rust\">enum Option&lt;T&gt; {\n  Some(T),\n  None,\n}\n</code></pre><p>这个数据结构你应该很熟悉了，T 代表任意类型，当 Option 有值时是 Some(T)，否则是 None。</p><p>在定义刚才这个泛型数据结构的时候，你有没有这样的感觉，有点像在定义函数：</p><ul>\n<li>函数，<strong>是把重复代码中的参数抽取出来</strong>，使其更加通用，调用函数的时候，根据参数的不同，我们得到不同的结果；</li>\n<li>而泛型，<strong>是把重复数据结构中的参数抽取出来</strong>，在使用泛型类型时，根据不同的参数，我们会得到不同的具体类型。</li>\n</ul><p>再来看一个复杂一点的泛型结构 Vec&lt;T&gt; 的例子，验证一下这个想法：</p><pre><code class=\"language-rust\">pub struct Vec&lt;T, A: Allocator = Global&gt; {\n    buf: RawVec&lt;T, A&gt;,\n    len: usize,\n}\n\npub struct RawVec&lt;T, A: Allocator = Global&gt; {\n    ptr: Unique&lt;T&gt;,\n    cap: usize,\n    alloc: A,\n}\n</code></pre><p>Vec<t> 有两个参数，一个是 T，是列表里的每个数据的类型，另一个是 A，它有进一步的限制  <code>A: Allocator</code> ，也就是说 A 需要满足 Allocator trait。</t></p><p>A 这个参数有默认值 <a href=\"https://doc.rust-lang.org/std/alloc/struct.Global.html\">Global</a>，它是 <a href=\"https://github.com/gnzlbg/jemallocator\">Rust 默认的全局分配器</a>，这也是为什么 Vec&lt;T&gt; 虽然有两个参数，使用时都只需要用 T。</p><p>在讲生命周期标注的时候，我们讲过，数据类型内部如果有借用的数据，需要显式地标注生命周期。其实在 Rust 里，<strong>生命周期标注也是泛型的一部分</strong>，一个生命周期 'a 代表任意的生命周期，和 T 代表任意类型是一样的。</p><p>来看一个枚举类型 Cow&lt;T&gt; 的例子：</p><pre><code class=\"language-rust\">pub enum Cow&lt;'a, B: ?Sized + 'a&gt; where B: ToOwned,\n{\n    // 借用的数据\n    Borrowed(&amp;'a B),\n    // 拥有的数据\n    Owned(&lt;B as ToOwned&gt;::Owned),\n}\n</code></pre><p>Cow（Clone-on-Write）是Rust中一个很有意思且很重要的数据结构。它就像 Option 一样，在返回数据的时候，提供了一种可能：要么返回一个借用的数据（只读），要么返回一个拥有所有权的数据（可写）。</p><p>这里你搞清楚泛型参数的约束就可以了，未来还会遇到 Cow，届时再详细讲它的用法。</p><p><strong>对于拥有所有权的数据 B ，第一个是生命周期约束</strong>。这里 B 的生命周期是 'a，所以 B 需要满足 'a，这里和泛型约束一样，也是用  <code>B: 'a</code> 来表示。当 Cow 内部的类型 B 生命周期为 'a 时，Cow 自己的生命周期也是 'a。</p><p>B 还有两个约束：?Sized 和 “where B: ToOwned”。</p><p>在表述泛型参数的约束时，Rust 允许两种方式，一种类似函数参数的类型声明，用 “:” 来表明约束，多个约束之间用 + 来表示；另一种是使用 where 子句，在定义的结尾来表明参数的约束。两种方法都可以，且可以共存。</p><p>?Sized 是一种特殊的约束写法，? 代表可以放松问号之后的约束。由于 Rust 默认的泛型参数都需要是 Sized，也就是固定大小的类型，所以这里 <strong>?Sized 代表用可变大小的类型</strong>。</p><p><a href=\"https://doc.rust-lang.org/std/borrow/trait.ToOwned.html\">ToOwned</a> 是一个 trait，它可以把借用的数据克隆出一个拥有所有权的数据。</p><p>所以这里对 B 的三个约束分别是：</p><ul>\n<li>生命周期 'a</li>\n<li>长度可变 ?Sized</li>\n<li>符合 ToOwned trait</li>\n</ul><p>最后我解释一下 Cow 这个 enum 里  <code>&lt;B as ToOwned&gt;::Owned</code> 的含义：它对 B 做了一个强制类型转换，转成 ToOwned trait，然后访问 ToOwned trait 内部的 Owned 类型。</p><p>因为在 Rust 里，子类型可以强制转换成父类型，B 可以用 ToOwned 约束，所以它是 ToOwned trait 的子类型，因而 B 可以安全地强制转换成 ToOwned。这里 B as ToOwned 是成立的。</p><p>上面 Vec 和 Cow 的例子中，泛型参数的约束都发生在开头 struct 或者 enum 的定义中，其实，很多时候，我们也可以<strong>在不同的实现下逐步添加约束</strong>，比如下面这个例子（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=e6c3da48aec24d54b17896c777cc7d3b\">代码</a>）：</p><pre><code class=\"language-rust\">use std::fs::File;\nuse std::io::{BufReader, Read, Result};\n\n// 定义一个带有泛型参数 R 的 reader，此处我们不限制 R\nstruct MyReader&lt;R&gt; {\n    reader: R,\n    buf: String,\n}\n\n// 实现 new 函数时，我们不需要限制 R\nimpl&lt;R&gt; MyReader&lt;R&gt; {\n    pub fn new(reader: R) -&gt; Self {\n        Self {\n            reader,\n            buf: String::with_capacity(1024),\n        }\n    }\n}\n\n// 定义 process 时，我们需要用到 R 的方法，此时我们限制 R 必须实现 Read trait\nimpl&lt;R&gt; MyReader&lt;R&gt;\nwhere\n    R: Read,\n{\n    pub fn process(&amp;mut self) -&gt; Result&lt;usize&gt; {\n        self.reader.read_to_string(&amp;mut self.buf)\n    }\n}\n\nfn main() {\n    // 在 windows 下，你需要换个文件读取，否则会出错\n    let f = File::open(\"/etc/hosts\").unwrap();\n    let mut reader = MyReader::new(BufReader::new(f));\n\n    let size = reader.process().unwrap();\n    println!(\"total size read: {}\", size);\n}\n\n</code></pre><p>逐步添加约束，可以让约束只出现在它不得不出现的地方，这样代码的灵活性最大。</p><h3>泛型函数</h3><p>了解了泛型数据结构是如何定义和使用的，再来看泛型函数，它们的思想类似。<strong>在声明一个函数的时候，我们还可以不指定具体的参数或返回值的类型，而是由泛型参数来代替</strong>。对函数而言，这是更高阶的抽象。</p><p>一个简单的例子（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=800e7aa804761567763f2bfe6881e956\">代码</a>）：</p><pre><code class=\"language-rust\">fn id&lt;T&gt;(x: T) -&gt; T {\n    return x;\n}\n\nfn main() {\n    let int = id(10);\n    let string = id(\"Tyr\");\n    println!(\"{}, {}\", int, string);\n}\n</code></pre><p>这里，id() 是一个泛型函数，它接受一个带有泛型类型的参数，返回一个泛型类型。</p><p>对于泛型函数，Rust 会进行<a href=\"https://en.wikipedia.org/wiki/Monomorphization\">单态化（Monomorphization）</a>处理，也就是在编译时，把所有用到的泛型函数的泛型参数展开，生成若干个函数。所以，刚才的 id() 编译后会得到一个处理后的多个版本（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=ab78a235d7bc5706281b43ac046ea149\">代码</a>）：</p><pre><code class=\"language-rust\">fn id_i32(x: i32) -&gt; i32 {\n    return x;\n}\nfn id_str(x: &amp;str) -&gt; &amp;str {\n    return x;\n}\nfn main() {\n    let int = id_i32(42);\n    let string = id_str(\"Tyr\");\n    println!(\"{}, {}\", int, string);\n}\n</code></pre><p><strong>单态化的好处是，泛型函数的调用是静态分派</strong>（static dispatch），在编译时就一一对应，既保有多态的灵活性，又没有任何效率的损失，和普通函数调用一样高效。</p><p>但是对比刚才编译会展开的代码也能很清楚看出来，单态化有很明显的坏处，就是编译速度很慢，<strong>一个泛型函数，编译器需要找到所有用到的不同类型，一个个编译</strong>，所以 Rust 编译代码的速度总被人吐槽，这和单态化脱不开干系（另一个重要因素是宏）。</p><p>同时，这样编出来的二进制会比较大，因为泛型函数的二进制代码实际存在 N 份。</p><p>还有一个可能你不怎么注意的问题：<strong>因为单态化，代码以二进制分发会损失泛型的信息</strong>。如果我写了一个库，提供了如上的 id() 函数，使用这个库的开发者如果拿到的是二进制，那么这个二进制中必须带有原始的泛型函数，才能正确调用。但单态化之后，原本的泛型信息就被丢弃了。</p><h2>小结</h2><p>今天我们介绍了类型系统的一些基本概念以及 Rust 的类型系统。</p><p>用一张图描述了 Rust 类型系统的主要特征，包括其属性、数据结构、类型推导和泛型编程：<br>\n<img src=\"https://static001.geekbang.org/resource/image/41/7c/41faf5451f7490640e8529b0c7a1627c.jpg?wh=2382x1544\" alt=\"\"></p><p>按类型定义、检查以及检查时能否被推导出来，Rust 是<strong>强类型+静态类型+显式类型</strong>。</p><p>因为是静态类型，那么在写代码时常用的类型你需要牢牢掌握。为了避免静态类型要到处做类型标注的繁琐，Rust提供了类型推导。</p><p>在少数情况下，Rust 无法通过上下文进行类型推导，我们需要为变量显式地标注类型，或者通过 turbofish 语法，为泛型函数提供一个确定的类型。有个例外是在 Rust 代码中定义常量或者静态变量时，即使上下文中类型信息非常明确，也需要显式地进行类型标注。</p><p>在参数多态上，Rust 提供有完善支持的泛型。你可以使用和定义<strong>泛型数据结构</strong>，在声明一个函数的时候，也可以不指定具体的参数或返回值的类型，而是由泛型参数来代替，也就是<strong>泛型函数</strong>。它们的思想其实差不多，因为当数据结构可以泛型时，函数自然也就需要支持泛型。</p><p>另外，生命周期标注其实也是泛型的一部分，而对于泛型函数，在编译时会被单态化，导致编译速度慢。</p><p>下一讲我们接着介绍特设多态和子类型多态……</p><h3>思考题</h3><p>下面这段<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=7d397b891bfbbf13dab9a9011c3b0a41\">代码</a>为什么不能编译通过？你可以修改它使其正常工作么？</p><pre><code class=\"language-rust\">use std::io::{BufWriter, Write};\nuse std::net::TcpStream;\n\n#[derive(Debug)]\nstruct MyWriter&lt;W&gt; {\n&nbsp; &nbsp; writer: W,\n}\n\nimpl&lt;W: Write&gt; MyWriter&lt;W&gt; {\n&nbsp; &nbsp; pub fn new(addr: &amp;str) -&gt; Self {\n&nbsp; &nbsp; &nbsp; &nbsp; let stream = TcpStream::connect(\"127.0.0.1:8080\").unwrap();\n&nbsp; &nbsp; &nbsp; &nbsp; Self {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; writer: BufWriter::new(stream),\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; pub fn write(&amp;mut self, buf: &amp;str) -&gt; std::io::Result&lt;()&gt; {\n&nbsp; &nbsp; &nbsp; &nbsp; self.writer.write_all(buf.as_bytes())\n&nbsp; &nbsp; }\n}\n\nfn main() {\n&nbsp; &nbsp; let writer = MyWriter::new(\"127.0.0.1:8080\");\n&nbsp; &nbsp; writer.write(\"hello world!\");\n}\n</code></pre><p>欢迎在留言区答题交流，你已经完成Rust学习的第12次打卡，我们下节课见！</p><h2>参考资料</h2><p>1.绝大多数支持静态类型系统的语言同时也会支持动态类型系统，因为单纯靠静态类型无法支持运行时的类型转换，比如<a href=\"https://en.wikipedia.org/wiki/Liskov_substitution_principle\">里氏替换原则</a>。</p><p>里氏替换原则简单说就是子类型对象可以在程序中代替父类型对象。它是运行时多态的基础。所以如果要支持运行时多态，以及动态分派、后期绑定、反射等功能，编程语言需要支持动态类型系统。</p><p>2.动态类型系统的缺点是没有编译期的类型检查，程序不够安全，只能通过大量的单元测试来保证代码的健壮性。但使用动态类型系统的程序容易撰写，不用花费大量的时间来抠数据结构或者函数的类型。</p><p>所以一般用在脚本语言中，如 JavaScript / Python / Elixir。不过因为这些脚本语言越来越被用在大型项目中，所以它们也都有各自的类型标注的方法，来提供编译时的额外检查。</p><p>3.为了语言的简单易懂，编译高效，Golang 在设计之初没有支持泛型，但未来在 <a href=\"https://blog.golang.org/generics-proposal\">Golang 2 中也许会添加泛型</a>。</p><p>4.当我们在堆上分配内存的时候，我们通过分配器来进行内存的分配，以及管理已分配的内存，包括增大（grow）、缩小（shrink）等。在处理某些情况下，默认的分配器也许不够高效，我们<a href=\"https://github.com/gnzlbg/jemallocator\">可以使用 jemalloc 来分配内存</a>。</p><p>5.如果你对各个语言是如何实现和处理泛型比较感兴趣的话，可以参考下图（<a href=\"https://thume.ca/2019/07/14/a-tour-of-metaprogramming-models-for-generics/\">来源</a>）：<img src=\"https://static001.geekbang.org/resource/image/3f/82/3fc003544b098d275e194fd4004e7a82.png?wh=1646x3136\" alt=\"\"></p>","neighbors":{"left":{"article_title":"加餐｜愚昧之巅：你的Rust学习常见问题汇总","id":418778},"right":{"article_title":"13｜类型系统：如何使用trait来定义接口？","id":420028}},"comments":[{"had_liked":false,"id":312958,"user_name":"lisiur","can_delete":false,"product_type":"c1","uid":1201350,"ip_address":"","ucode":"CEB2DBCE29CAA7","user_header":"https://static001.geekbang.org/account/avatar/00/12/54/c6/c2481790.jpg","comment_is_top":false,"comment_ctime":1632147540,"is_pvip":false,"replies":[{"id":"113401","content":"非常棒！最佳答案！","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632239859,"ip_address":"","comment_id":312958,"utype":1}],"discussion_count":15,"race_medal":0,"score":"263625152596","product_id":100085301,"comment_content":"思考题代码报错的主要原因是，实现 new 方法时，对泛型的约束要求要满足 W: Write，而 new 的声明返回值是 Self，也就是说 self.wirter 必须是 W: Write 类型(泛型)，但实际返回值是一个确定的类型 BufWriter&lt;TcpStream&gt;，这不满足要求。<br><br>修改方法有这么几个思路<br><br>1. 修改 new 方法的返回值<br><br>```rust<br>impl&lt;W: Write&gt; MyWriter&lt;W&gt; {<br>    pub fn new(addr: &amp;str) -&gt; MyWriter&lt;BufWriter&lt;TcpStream&gt;&gt; {<br>        let stream = TcpStream::connect(addr).unwrap();<br>        MyWriter {<br>            writer: BufWriter::new(stream),<br>        }<br>    }<br>}<br><br>fn main() {<br>    let mut writer = MyWriter::&lt;BufWriter&lt;TcpStream&gt;&gt;::new(&quot;127.0.0.1:8080&quot;);<br>    writer.write(&quot;hello world!&quot;);<br>}<br>```<br><br>2. 对确定的类型 MyWriter&lt;BufWriter&lt;TcpStream&gt;&gt;实现 new 方法：<br><br>```rust<br>impl MyWriter&lt;BufWriter&lt;TcpStream&gt;&gt; {<br>    pub fn new(addr: &amp;str) -&gt; Self {<br>        let stream = TcpStream::connect(addr).unwrap();<br>        Self {<br>            writer: BufWriter::new(stream),<br>        }<br>    }<br>}<br><br>fn main() {<br>    let mut writer = MyWriter::new(&quot;127.0.0.1:8080&quot;);<br>    writer.write(&quot;hello world!&quot;);<br>}<br>```<br><br>3. 修改 new 方法的实现，使用依赖注入<br><br>```rust<br>impl&lt;W: Write&gt; MyWriter&lt;W&gt; {<br>    pub fn new(writer: W) -&gt; Self {<br>        Self {<br>            writer,<br>        }<br>    }<br>}<br><br>fn main() {<br>    let stream = TcpStream::connect(&quot;127.0.0.1:8080&quot;).unwrap();<br>    let mut writer = MyWriter::new(BufWriter::new(stream));<br>    writer.write(&quot;hello world!&quot;);<br>}<br>```<br><br>PS：第2种解法还可以对不同具体类型实现多个new方法：<br><br>```rust<br>impl MyWriter&lt;BufWriter&lt;TcpStream&gt;&gt; {<br>    pub fn new(addr: &amp;str) -&gt; Self {<br>        let stream = TcpStream::connect(addr).unwrap();<br>        Self {<br>            writer: BufWriter::new(stream),<br>        }<br>    }<br>}<br><br>impl MyWriter&lt;File&gt; {<br>    pub fn new(addr: &amp;str) -&gt; Self {<br>        let file = File::open(addr).unwrap();<br>        Self { writer: file }<br>    }<br>}<br><br>fn main() {<br>    let mut writer = MyWriter::&lt;BufWriter&lt;TcpStream&gt;&gt;::new(&quot;127.0.0.1:8080&quot;);<br>    writer.write(&quot;hello world!&quot;);<br><br>    let mut writer = MyWriter::&lt;File&gt;::new(&quot;&#47;etc&#47;hosts&quot;);<br>    writer.write(&quot;127.0.0.1 localhost&quot;);<br>}<br>```","like_count":62,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527181,"discussion_content":"非常棒！最佳答案！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632239859,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1448126,"avatar":"https://static001.geekbang.org/account/avatar/00/16/18/be/ad3127e0.jpg","nickname":"慕高迪","note":"","ucode":"EB1CB5EA4E3A90","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544669,"discussion_content":"泛型算是被楼主玩明白了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1641632389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1390032,"avatar":"https://static001.geekbang.org/account/avatar/00/15/35/d0/f2ac6d91.jpg","nickname":"阿成","note":"","ucode":"CEC3CD65FB9333","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532157,"discussion_content":"就这个题目来说，第三种是最正确的解法","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1637546694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2818644,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/02/54/9d76eee7.jpg","nickname":"*时间箭头*","note":"","ucode":"B8A2383680D956","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":410805,"discussion_content":"初学者表示看完一脸懵逼","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1635778090,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2394662,"avatar":"https://static001.geekbang.org/account/avatar/00/24/8a/26/2e2f9cfc.jpg","nickname":"Koco","note":"","ucode":"AEBF53EFBA8BE5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589516,"discussion_content":"课代表牛逼！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665058106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1159530,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b1/6a/b1e05143.jpg","nickname":"inmo","note":"","ucode":"A9590E563C93CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578595,"discussion_content":"请教下，Self 不就是 MyWriter 么，按楼主意思，Self 仅代表某个 impl  块是吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656914046,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2181012,"avatar":"https://static001.geekbang.org/account/avatar/00/21/47/94/46d6a079.jpg","nickname":"Siact","note":"","ucode":"0C294F4614D48C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1159530,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b1/6a/b1e05143.jpg","nickname":"inmo","note":"","ucode":"A9590E563C93CC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586668,"discussion_content":"函数的单态化来源于函数调用，如果调用的过程中，Self 没有确定下来，就是Self.writer 没有确定下来。并且函数无法返回不确定的类型。\n\n3种方法都是为了让new的函数体返回时，Self已经确定下来，函数体的逻辑千变万化，不可能通过函数体来决定Self的类型，编译器当前只能通过参数调用来单态化的过程来决定函数返回值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662427945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":578595,"ip_address":"湖北"},"score":586668,"extra":""}]},{"author":{"id":1046714,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","nickname":"约书亚","note":"","ucode":"81EA27ADD9EC1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576415,"discussion_content":"想了半天只想到第三种，佩服啊佩服。初学者还是不了解Self","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655532829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1786915,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/44/23/ebe7bd0f.jpg","nickname":"啊啊啊啊","note":"","ucode":"090E3983DD41A6","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558038,"discussion_content":"这是不是就是最开始说的，结构泛型化之后，要求代码也泛型化的 Case。之前写 Go，没怎么深入过泛型。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648051069,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2699840,"avatar":"https://static001.geekbang.org/account/avatar/00/29/32/40/d56f476c.jpg","nickname":"ibin","note":"","ucode":"766942C36B8E27","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548597,"discussion_content":"楼主学多久，看到你的答案都是正确的，应该有其他的编程经验吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643273194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1079876,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL9hlAIKQ1sGDu16oWLOHyCSicr18XibygQSMLMjuDvKk73deDlH9aMphFsj41WYJh121aniaqBLiaMNg/132","nickname":"腾达","note":"","ucode":"72F9CFBA44FDEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547745,"discussion_content":"3. 修改 new 方法的实现，使用依赖注入  这样做为什么能成功啊？ 不理解啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642849718,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1403021,"avatar":"https://static001.geekbang.org/account/avatar/00/15/68/8d/55c14209.jpg","nickname":"麓湖","note":"","ucode":"9FDBA9928B7E20","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":395770,"discussion_content":"还有为什么第三种情况就不需要类型明确类型了呢，因为入参是W，编译器有什么方式感知吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632333711,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1201350,"avatar":"https://static001.geekbang.org/account/avatar/00/12/54/c6/c2481790.jpg","nickname":"lisiur","note":"","ucode":"CEB2DBCE29CAA7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1403021,"avatar":"https://static001.geekbang.org/account/avatar/00/15/68/8d/55c14209.jpg","nickname":"麓湖","note":"","ucode":"9FDBA9928B7E20","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":396014,"discussion_content":"定义方法的时候编译器并不知道具体类型，只是知道返回值和入参有联系而已；在调用new方法时，使用具体的类型来实例化这个范型参数，此时范型就被收缩成具体类型了，编译器自然就知道了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1632381519,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":395770,"ip_address":""},"score":396014,"extra":""}]},{"author":{"id":1403021,"avatar":"https://static001.geekbang.org/account/avatar/00/15/68/8d/55c14209.jpg","nickname":"麓湖","note":"","ucode":"9FDBA9928B7E20","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":395769,"discussion_content":"第二种解法main中 MyWriter::<BufWriter<TcpStream>>::new(&#34;127.0.0.1:8080&#34;)需要明确类型, 是因为函数new无法推导出W的类型吗，我试了下其实换成<BufWriter<File>>但返回的是<BufWriter<TcpStream>>也是能编译的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632333657,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1201350,"avatar":"https://static001.geekbang.org/account/avatar/00/12/54/c6/c2481790.jpg","nickname":"lisiur","note":"","ucode":"CEB2DBCE29CAA7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1403021,"avatar":"https://static001.geekbang.org/account/avatar/00/15/68/8d/55c14209.jpg","nickname":"麓湖","note":"","ucode":"9FDBA9928B7E20","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":396015,"discussion_content":"因为MyWriter针对两个不同的类型都实现了new方法，调用的时候需要指定类型来告诉编译器你想使用哪个new方法；如果只有一个实现的话就不需要指定类型了\n\n第二句话没看明白，方便的话可以贴下代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632381578,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":395769,"ip_address":""},"score":396015,"extra":""}]}]},{"had_liked":false,"id":313184,"user_name":"核桃","can_delete":false,"product_type":"c1","uid":1385204,"ip_address":"","ucode":"7AB05270CBCCCB","user_header":"https://static001.geekbang.org/account/avatar/00/15/22/f4/9fd6f8f0.jpg","comment_is_top":false,"comment_ctime":1632303064,"is_pvip":false,"replies":[{"id":"113482","content":"你的代码有四个问题:<br>1. 应该是 Vec&lt;* const [u8]&gt;，而不是 Vec&lt;* const u8&gt;，你的指针是指向一个 slice 的，而非一个 u8。<br>2. as_ptr() 拿到的是栈上的指针，你应该需要堆上指向实际内容的指针。所以应该用 Vec::into_boxed_slice(), 然后再用 Box::into_raw 拿到裸指针。<br>3. 不要乱用 unsafe。这里没有需要 unsafe 的地方。<br>4. 循环的变量虽然没有用到，但不应该用同一个，很容易导致误用。<br><br>至于你的问题，你可以想象一下，栈上数据是如何存取的。每次循环结束，num 的作用域就结束了，它这 24 个字节的栈内存就可以重新使用，所以你拿到的都是同一个地址（而且作为裸指针是没有用处的地址）。<br><br>更新的代码：<br><br>```rust<br>use rand::Rng;<br><br>fn main() {<br>    let mut data :Vec&lt;* const [u8]&gt; = Vec::new();<br><br>    for _i in 0..5 {<br>        let mut num: Vec&lt;u8&gt;= Vec::new();<br>        for _j in 0..16 {<br>            let rand_num :u8 = rand::thread_rng().gen();<br>            num.push(rand_num);<br>        }<br>        println!(&quot;num({:p}) is : {:?}&quot;, &amp;*num, num);<br>        let boxed = num.into_boxed_slice();<br>        data.push(Box::into_raw(boxed) as _);<br>    }<br>    println!(&quot;data is: {:?}&quot;,data);<br>}<br>```<br><br>playground: https:&#47;&#47;play.rust-lang.org&#47;?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=8c353b42610dd3610ab944b4a02fd572","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632364657,"ip_address":"","comment_id":313184,"utype":1}],"discussion_count":4,"race_medal":0,"score":"61761845208","product_id":100085301,"comment_content":"老师你好，这里遇到一个需求，就是想实现一个类似二维动态数组的，然后数组里面的元素是一个指针，指向另外一个随机数组，因为这里是同事强制要求的，后面调用了一个封装第三方的C库接口，因此这里我的代码实现思路如下所示:<br><br><br>代码:<br><br>let mut data :Vec&lt;* const u8&gt; = Vec::new();<br><br>for i in 0..5{<br>    let mut num: Vec&lt;u8&gt;= Vec::new();<br>    for i in 0..16 {<br>        unsafe{<br>            let rand_num :u8 = rand::thread_rng().gen();<br>            num.push(rand_num)<br>        }<br>    }<br>    println!(&quot;num is : {:?},num.as_ptr(): {:?}&quot;,num,num.as_ptr());<br>    data.push(num.as_ptr());<br>}<br><br>println!(&quot;data is: {:?}&quot;,data);<br><br><br>结果:<br>num is : [248, 69, 170, 238, 134, 89, 77, 32, 116, 106, 68, 213, 113, 19, 213, 231],num.as_ptr(): 0x7ff6ec000bc0<br>num is : [138, 101, 105, 192, 81, 32, 133, 80, 94, 6, 205, 164, 178, 95, 60, 45],num.as_ptr(): 0x7ff6ec000bc0<br>num is : [204, 173, 46, 246, 72, 25, 171, 186, 167, 175, 154, 4, 219, 78, 78, 227],num.as_ptr(): 0x7ff6ec000bc0<br>num is : [252, 123, 170, 107, 232, 186, 203, 91, 130, 11, 92, 48, 39, 36, 10, 193],num.as_ptr(): 0x7ff6ec000bc0<br>num is : [143, 52, 155, 135, 50, 50, 133, 105, 143, 62, 120, 125, 88, 58, 99, 19],num.as_ptr(): 0x7ff6ec000bc0<br>data is: [0x7ff6ec000bc0, 0x7ff6ec000bc0, 0x7ff6ec000bc0, 0x7ff6ec000bc0, 0x7ff6ec000bc0]<br><br>搞不明白的是，这里为什么new了之后，还是会导致地址不变，有没有办法强制让变量num每次new之后就是会改变的？多谢了","like_count":15,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527265,"discussion_content":"你的代码有四个问题:\n1. 应该是 Vec&amp;lt;* const [u8]&amp;gt;，而不是 Vec&amp;lt;* const u8&amp;gt;，你的指针是指向一个 slice 的，而非一个 u8。\n2. as_ptr() 拿到的是栈上的指针，你应该需要堆上指向实际内容的指针。所以应该用 Vec::into_boxed_slice(), 然后再用 Box::into_raw 拿到裸指针。\n3. 不要乱用 unsafe。这里没有需要 unsafe 的地方。\n4. 循环的变量虽然没有用到，但不应该用同一个，很容易导致误用。\n\n至于你的问题，你可以想象一下，栈上数据是如何存取的。每次循环结束，num 的作用域就结束了，它这 24 个字节的栈内存就可以重新使用，所以你拿到的都是同一个地址（而且作为裸指针是没有用处的地址）。\n\n更新的代码：\n\n```rust\nuse rand::Rng;\n\nfn main() {\n    let mut data :Vec&amp;lt;* const [u8]&amp;gt; = Vec::new();\n\n    for _i in 0..5 {\n        let mut num: Vec&amp;lt;u8&amp;gt;= Vec::new();\n        for _j in 0..16 {\n            let rand_num :u8 = rand::thread_rng().gen();\n            num.push(rand_num);\n        }\n        println!(&amp;quot;num({:p}) is : {:?}&amp;quot;, &amp;amp;*num, num);\n        let boxed = num.into_boxed_slice();\n        data.push(Box::into_raw(boxed) as _);\n    }\n    println!(&amp;quot;data is: {:?}&amp;quot;,data);\n}\n```\n\nplayground: https://play.rust-lang.org/?version=stable&amp;amp;mode=debug&amp;amp;edition=2018&amp;amp;gist=8c353b42610dd3610ab944b4a02fd572","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1632364657,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539902,"discussion_content":"这里我看错了，我以为你用的是 as_ref()，as_ptr() 是堆上的数据。之前代码的问题是每次 num array 都被回收了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639854876,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2365229,"avatar":"https://static001.geekbang.org/account/avatar/00/24/17/2d/b7614553.jpg","nickname":"Bruce","note":"","ucode":"2A48A313481754","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":396528,"discussion_content":"又多了一些奇怪的知识，谢谢老师😀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632447957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1385204,"avatar":"https://static001.geekbang.org/account/avatar/00/15/22/f4/9fd6f8f0.jpg","nickname":"核桃","note":"","ucode":"7AB05270CBCCCB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":396001,"discussion_content":"这里我还想到了另外一种写法，使用Vec<Vec<u8>>,而如果最后要获取到Vec<* const u8>的话，使用Vec::with_capacity(data.len())的写法就可以了.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632379884,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314106,"user_name":"荒野林克","can_delete":false,"product_type":"c1","uid":2051117,"ip_address":"","ucode":"8A5F0F03FD901B","user_header":"https://static001.geekbang.org/account/avatar/00/1f/4c/2d/a0d6a610.jpg","comment_is_top":false,"comment_ctime":1632840247,"is_pvip":false,"replies":[{"id":"113985","content":"因为 impl&lt;W&gt; 相当于声明了一个泛型参数， MyWriter&lt;W&gt; 是使用这个泛型参数","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1633322294,"ip_address":"","comment_id":314106,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31697611319","product_id":100085301,"comment_content":"老师，这里有一个疑惑：<br>```impl&lt;W: Write&gt; MyWriter&lt;W&gt;``` <br>里，impl 后面以及指明约束，为什么 MyWriter 后面还要单独写一次呢？","like_count":8,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527570,"discussion_content":"因为 impl&amp;lt;W&amp;gt; 相当于声明了一个泛型参数， MyWriter&amp;lt;W&amp;gt; 是使用这个泛型参数","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1633322294,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312960,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1320487,"ip_address":"","ucode":"96BAFAA147341F","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","comment_is_top":false,"comment_ctime":1632148427,"is_pvip":false,"replies":[{"id":"113400","content":"哈哈，感谢支持！","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632239794,"ip_address":"","comment_id":312960,"utype":1}],"discussion_count":3,"race_medal":2,"score":"10222083019","product_id":100085301,"comment_content":"追老师的更新比追剧有趣多了，配合张老师的视频课，还有陈老师 B 站的 Rust 培训视频，真的很舒服。","like_count":2,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527183,"discussion_content":"哈哈，感谢支持！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632239794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018724,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/64/d8bf2f6f.jpg","nickname":"旻言","note":"","ucode":"563E6A83A50EC9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":407821,"discussion_content":"老师的B站视频是指极客时间在B站上的视频吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635126933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2699840,"avatar":"https://static001.geekbang.org/account/avatar/00/29/32/40/d56f476c.jpg","nickname":"ibin","note":"","ucode":"766942C36B8E27","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":1018724,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/64/d8bf2f6f.jpg","nickname":"旻言","note":"","ucode":"563E6A83A50EC9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586352,"discussion_content":"【喜欢历史的程序君的个人空间-哔哩哔哩】 https://b23.tv/Wfyn5lG","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662126079,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":407821,"ip_address":"江苏"},"score":586352,"extra":""}]}]},{"had_liked":false,"id":312909,"user_name":"Marvichov","can_delete":false,"product_type":"c1","uid":1111835,"ip_address":"","ucode":"7482099415C41C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f7/1b/db7a0edc.jpg","comment_is_top":false,"comment_ctime":1632114499,"is_pvip":false,"replies":[{"id":"113366","content":"正确！<br><br>至于声明 struct 和 impl 时为何要重复声明，我觉得有两个原因：1. 文中谈到声明 struct 时的约束和实现时的约束可以不一样。2. 这样编译和类型声明代码和实现代码以及 类型对 trait 的实现代码可以彼此独立。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632153646,"ip_address":"","comment_id":312909,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10222049091","product_id":100085301,"comment_content":"W会被resolve成一个实际类型, 也就是`BufferWriter::new(stream)`的类型. 而rust要求W是一个泛型. 我的下面的改动有点多...<br><br>有一点我就有点不明白了, 声明的时候都说了W: Write, 为啥impl的时候还要说一遍呢 (不说不让编译)? <br><br>```<br>use std::io::{BufWriter, Write};<br>use std::net::TcpStream;<br><br>#[derive(Debug)]<br>struct MyWriter&lt;W&gt;<br>where<br>    W: Write,<br>{<br>    writer: BufWriter&lt;W&gt;,<br>}<br><br>impl&lt;W: Write&gt; MyWriter&lt;W&gt; {<br>    pub fn new(stream: W) -&gt; Self {<br>        Self {<br>            writer: BufWriter::new(stream),<br>        }<br>    }<br><br>    pub fn write(&amp;mut self, buf: &amp;str) -&gt; std::io::Result&lt;()&gt; {<br>        self.writer.write_all(buf.as_bytes())<br>    }<br>}<br><br>fn main() {<br>    let addr = &quot;127.0.0.1:8080&quot;;<br>    let stream = TcpStream::connect(addr).unwrap();<br>    let mut writer = MyWriter::new(stream);<br>    writer.write(&quot;hello world!&quot;).unwrap();<br>}<br>```","like_count":2,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527155,"discussion_content":"正确！\n\n至于声明 struct 和 impl 时为何要重复声明，我觉得有两个原因：1. 文中谈到声明 struct 时的约束和实现时的约束可以不一样。2. 这样编译和类型声明代码和实现代码以及 类型对 trait 的实现代码可以彼此独立。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632153646,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322061,"user_name":"核桃","can_delete":false,"product_type":"c1","uid":1385204,"ip_address":"","ucode":"7AB05270CBCCCB","user_header":"https://static001.geekbang.org/account/avatar/00/15/22/f4/9fd6f8f0.jpg","comment_is_top":false,"comment_ctime":1637150951,"is_pvip":false,"replies":[{"id":"116955","content":"为啥知道 collect() 必定 collect 出 Vec 呢？你也可以 collect 出 VecDeque 啊？<br><br>```<br>use std::collections::VecDeque;<br>fn main() {<br>    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; <br>    let even_numbers: VecDeque&amp;lt;_&amp;gt;  = numbers .into_iter() .filter(|n| n % 2 == 0) .collect(); <br>    println!(&amp;quot;{:?}&amp;quot;, even_numbers); <br>}<br>```<br><br>playground: https:&amp;#47;&amp;#47;play.rust-lang.org&amp;#47;?version=stable&amp;amp;mode=debug&amp;amp;edition=2021&amp;amp;gist=b8b8ca784dbd379c599bee79ddd72482","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1637161226,"ip_address":"","comment_id":322061,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5932118247","product_id":100085301,"comment_content":"fn main() {<br>    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];<br>    let even_numbers = numbers<br>        .into_iter()<br>        .filter(|n| n % 2 == 0)<br>        .collect();<br>    println!(&quot;{:?}&quot;, even_numbers);<br>}<br><br><br>请教一下这段代码为什么就无法推导类型呢？对于编译器来说，应该是知道number是vec的呀。不太懂，这里可能是我对编译原理理解不够扎实。","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530876,"discussion_content":"为啥知道 collect() 必定 collect 出 Vec 呢？你也可以 collect 出 VecDeque 啊？\n\n```\nuse std::collections::VecDeque;\nfn main() {\n    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; \n    let even_numbers: VecDeque&amp;lt;_&amp;gt;  = numbers .into_iter() .filter(|n| n % 2 == 0) .collect(); \n    println!(&amp;quot;{:?}&amp;quot;, even_numbers); \n}\n```\n\nplayground: https:&amp;#47;&amp;#47;play.rust-lang.org&amp;#47;?version=stable&amp;amp;mode=debug&amp;amp;edition=2021&amp;amp;gist=b8b8ca784dbd379c599bee79ddd72482","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637161226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312954,"user_name":"qinsi","can_delete":false,"product_type":"c1","uid":1667175,"ip_address":"","ucode":"090D9C4068FF12","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","comment_is_top":false,"comment_ctime":1632144059,"is_pvip":true,"replies":[{"id":"113413","content":"👍 非常好！","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632241601,"ip_address":"","comment_id":312954,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5927111355","product_id":100085301,"comment_content":"不确定最后的代码里为什么要用泛型，改了几个不同的版本：<br><br>https:&#47;&#47;play.rust-lang.org&#47;?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=f21447a10eac4e3b77d39aefbd93ab6b<br><br>https:&#47;&#47;play.rust-lang.org&#47;?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=2d8037d4059efe15c3d15cfa2267bb70<br><br>https:&#47;&#47;play.rust-lang.org&#47;?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c57f2abe9756bf021241c63e1b944af8","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527178,"discussion_content":"👍 非常好！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632241601,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312899,"user_name":"c4f","can_delete":false,"product_type":"c1","uid":2637246,"ip_address":"","ucode":"F0F542BBABCB37","user_header":"https://static001.geekbang.org/account/avatar/00/28/3d/be/98bebd57.jpg","comment_is_top":false,"comment_ctime":1632109741,"is_pvip":false,"replies":[{"id":"113368","content":"这么改是可以的！原代码的接口本身就有问题，所以需要动接口。对泛型的限制，用 : 限制和 where 是等价的，where 更灵活一些，表述更优雅一些。一般短小的限制，我们用 : 就足够，但对多个参数的复杂的限制，用 where 可读性会更强。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632154213,"ip_address":"","comment_id":312899,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5927077037","product_id":100085301,"comment_content":"不能编译是因为第 14 行 writer 期待的值的类型也是 W，但收到的却是 BufWriter&lt;TcpStream&gt; 因此不匹配。<br>参考 MyReader 进行了修改，不过这种方法修改了 MyWriter 对外提供的接口（new），应该还有别的方法，不过没找出来 hh<br><br>```<br><br>use std::io::{BufWriter, Write};<br>use std::net::TcpStream;<br><br>#[derive(Debug)]<br>struct MyWriter&lt;W&gt; {<br>    writer: W,<br>}<br><br>impl&lt;W&gt; MyWriter&lt;W&gt; {<br>    pub fn new(writer: W) -&gt; Self {<br>        Self {<br>            writer<br>        }<br>    }<br>}<br><br>impl&lt;W: Write&gt; MyWriter&lt;W&gt; {<br>    pub fn write(&amp;mut self, buf: &amp;str) -&gt; std::io::Result&lt;()&gt; {<br>        self.writer.write_all(buf.as_bytes())<br>    }<br>}<br><br>fn main() {<br>    let mut writer = MyWriter::new(<br>        BufWriter::new(TcpStream::connect(&quot;127.0.0.1:8080&quot;).unwrap())<br>    );<br>    writer.write(&quot;hello world!&quot;).unwrap();<br>}<br>```<br><br>另外还有一个问题想请教老师：通过在冒号后面对范型进行限制和使用 where 对范型进行限制是否是等价的。比如下面的例子<br><br>```<br>impl&lt;W: Write&gt; MyWriter&lt;W&gt; {<br>    ...<br>}<br><br>impl&lt;W&gt; MyWriter&lt;W&gt;<br>where<br>    W: Write<br>{<br>    ...<br>}<br>```<br>","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527151,"discussion_content":"这么改是可以的！原代码的接口本身就有问题，所以需要动接口。对泛型的限制，用 : 限制和 where 是等价的，where 更灵活一些，表述更优雅一些。一般短小的限制，我们用 : 就足够，但对多个参数的复杂的限制，用 where 可读性会更强。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632154213,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351291,"user_name":"Freedom","can_delete":false,"product_type":"c1","uid":2746926,"ip_address":"","ucode":"C0DD70210D0693","user_header":"https://static001.geekbang.org/account/avatar/00/29/ea/2e/814b2d61.jpg","comment_is_top":false,"comment_ctime":1657679909,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657679909","product_id":100085301,"comment_content":"fn te&lt;T:Copy&gt;(t: T) -&gt; T {<br>    return 2;<br>}<br><br>fn main() {<br><br>    let b = te::&lt;&amp;str&gt;(&quot;hello&quot;);<br>}<br><br>类似于这种情况，应该还是单态化的问题","like_count":0},{"had_liked":false,"id":343596,"user_name":"菅田","can_delete":false,"product_type":"c1","uid":1228201,"ip_address":"","ucode":"75668DE75FF7BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/bd/a9/688b9bc6.jpg","comment_is_top":false,"comment_ctime":1650945262,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650945262","product_id":100085301,"comment_content":"思考题代码报错，为什么实际返回值类型 BufferWrite&lt;TcpStream&gt; 不会被自动推导成泛型 W: Write 呢？","like_count":0},{"had_liked":false,"id":337950,"user_name":"星海","can_delete":false,"product_type":"c1","uid":2905625,"ip_address":"","ucode":"3B6728A146B314","user_header":"https://static001.geekbang.org/account/avatar/00/2c/56/19/d2c65c01.jpg","comment_is_top":false,"comment_ctime":1647175554,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1647175554","product_id":100085301,"comment_content":"Result&lt;_,Error&gt;和Result&lt;(),Error&gt;等价吗？","like_count":0},{"had_liked":false,"id":336050,"user_name":"恒量","can_delete":false,"product_type":"c1","uid":1064380,"ip_address":"","ucode":"D9245C4D0996A0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ajNVdqHZLLB2a77iaQHVR9icIvG9lNz23U47O9VqEyZW9czglUSmmxQ4dkuJX923lVAcBo89dbKbSAjQWwtVQribw/132","comment_is_top":false,"comment_ctime":1645868652,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645868652","product_id":100085301,"comment_content":"C和C++也是强类型语言吧，只是在某些场景下会发生隐式的转换，比如浮点数赋值给整型，整型赋值给布尔值。","like_count":0},{"had_liked":false,"id":331660,"user_name":"吧唧喵","can_delete":false,"product_type":"c1","uid":2629795,"ip_address":"","ucode":"0FC40BF8EEE7D4","user_header":"https://static001.geekbang.org/account/avatar/00/28/20/a3/d321893e.jpg","comment_is_top":false,"comment_ctime":1642690284,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642690284","product_id":100085301,"comment_content":"思考题：因为BufWriter::new(stream)是一个具体的结构体类型BufWriter&lt;TcpStream&gt;，Self里要求是一个Trait Write。虽然BufWriter&lt;TcpStream&gt;实现了Write，但是不能直接这样赋值，不然W这个泛型参数就没意义了，就确定了W = BufWriter&lt;TcpStream&gt;。<br>解决方法一：<br>给具体的BufWriter&lt;TcpStream&gt;类型实现方法。<br><br>impl MyWriter&lt;BufWriter&lt;TcpStream&gt;&gt; {<br>    pub fn new(addr: &amp;str) -&gt; Self {<br>        let stream = TcpStream::connect(addr).unwrap();<br>        Self {<br>            writer: BufWriter::new(stream),<br>        }<br>    }<br>    ...... <br>},<br><br>方法二：给Write trait实现方法，并且在调用时，让调用者显式的指定类型(上面陈老师讲的turbofish)<br><br>impl&lt;W: Write&gt; MyWriter&lt;W&gt; {<br>    pub fn new(writer: W) -&gt; Self {<br>        Self {<br>            writer,<br>        }<br>    }<br>}<br><br>fn main() {<br>    let stream = TcpStream::connect(&quot;127.0.0.1:8080&quot;).unwrap();<br>    let mut writer = MyWriter::new(BufWriter::new(stream));<br>    writer.write(&quot;hello world!&quot;);<br>}<br><br>老师，我的理解对吗","like_count":0},{"had_liked":false,"id":331120,"user_name":"bestgopher","can_delete":false,"product_type":"c1","uid":2254917,"ip_address":"","ucode":"D89735C8CA9C6E","user_header":"https://static001.geekbang.org/account/avatar/00/22/68/45/ddf89612.jpg","comment_is_top":false,"comment_ctime":1642431491,"is_pvip":false,"discussion_count":1,"race_medal":1,"score":"1642431491","product_id":100085301,"comment_content":"还有一个可能你不怎么注意的问题：因为单态化，代码以二进制分发会损失泛型的信息。如果我写了一个库，提供了如上的 id() 函数，使用这个库的开发者如果拿到的是二进制，那么这个二进制中必须带有原始的泛型函数，才能正确调用。但单态化之后，原本的泛型信息就被丢弃了。 这段话咋理解？","like_count":0,"discussions":[{"author":{"id":2888176,"avatar":"","nickname":"无下限HENTAI","note":"","ucode":"8D45A12C25861A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547902,"discussion_content":"我的理解是，如果库用了泛型，但用了二进制分发，那么举个例子，假如二进制库中真正使用一个泛型函数的只有i32这个数据类型，你拿到这个二进制库后想把这个泛型函数用在f64上，那你就失败了，因为二进制库不会保存泛型信息，只会保存单态化之后的信息，也就是只有i32可用。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1642926655,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331119,"user_name":"bestgopher","can_delete":false,"product_type":"c1","uid":2254917,"ip_address":"","ucode":"D89735C8CA9C6E","user_header":"https://static001.geekbang.org/account/avatar/00/22/68/45/ddf89612.jpg","comment_is_top":false,"comment_ctime":1642431476,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1642431476","product_id":100085301,"comment_content":"还有一个可能你不怎么注意的问题：因为单态化，代码以二进制分发会损失泛型的信息。如果我写了一个库，提供了如上的 id() 函数，使用这个库的开发者如果拿到的是二进制，那么这个二进制中必须带有原始的泛型函数，才能正确调用。但单态化之后，原本的泛型信息就被丢弃了。 ","like_count":0},{"had_liked":false,"id":331118,"user_name":"bestgopher","can_delete":false,"product_type":"c1","uid":2254917,"ip_address":"","ucode":"D89735C8CA9C6E","user_header":"https://static001.geekbang.org/account/avatar/00/22/68/45/ddf89612.jpg","comment_is_top":false,"comment_ctime":1642431470,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1642431470","product_id":100085301,"comment_content":"还有一个可能你不怎么注意的问题：因为单态化，代码以二进制分发会损失泛型的信息。如果我写了一个库，提供了如上的 id() 函数，使用这个库的开发者如果拿到的是二进制，那么这个二进制中必须带有原始的泛型函数，才能正确调用。但单态化之后，原本的泛型信息就被丢弃了。","like_count":0},{"had_liked":false,"id":328722,"user_name":"随风wli","can_delete":false,"product_type":"c1","uid":1932930,"ip_address":"","ucode":"655BD9182D7570","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/OEZQyDeZd2oCPZiak19FKQOZI4I21WjLlwUgJzVFxyXsVKbIlpEEEYZcHbA4lYVzFbd3CtmDfZuUictW3ujvKnUQ/132","comment_is_top":false,"comment_ctime":1640853086,"is_pvip":false,"replies":[{"id":"120747","content":"对，Rust 编译成二进制库","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1642307859,"ip_address":"","comment_id":328722,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1640853086","product_id":100085301,"comment_content":"老师，因为单态化，代码以二进制分发会损失泛型的信息，这里以二进制分发是指库代码编译成了类似可执行文件，然后rust直接调用吗","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546385,"discussion_content":"对，Rust 编译成二进制库","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642307860,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327576,"user_name":"Geek_2b06a7","can_delete":false,"product_type":"c1","uid":1500330,"ip_address":"","ucode":"22AA448549B129","user_header":"https://static001.geekbang.org/account/avatar/00/16/e4/aa/811ff4d7.jpg","comment_is_top":false,"comment_ctime":1640176832,"is_pvip":false,"replies":[{"id":"120792","content":"Haskell 一切类型都能帮你推断出来，所以它是隐式静态类型","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1642310079,"ip_address":"","comment_id":327576,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1640176832","product_id":100085301,"comment_content":"文中说 Rust 是显式静态类型，支持作用域内的类型推导，而 ML 和 Haskell 是隐式类型。<br>这其中的差异提现在什么地方？我没有明白他们类型系统的差异。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546432,"discussion_content":"Haskell 一切类型都能帮你推断出来，所以它是隐式静态类型","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642310079,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322692,"user_name":"阿成","can_delete":false,"product_type":"c1","uid":1390032,"ip_address":"","ucode":"CEC3CD65FB9333","user_header":"https://static001.geekbang.org/account/avatar/00/15/35/d0/f2ac6d91.jpg","comment_is_top":false,"comment_ctime":1637552164,"is_pvip":false,"replies":[{"id":"118940","content":"哈，多谢提醒。之前我回复的时候把 as_ptr() 看成了 as_ref()，所以认为是栈上的地址。as_ptr() 返回堆地址。这里的问题是 num 是个局部变量，每次循环完都会被回收，所以一直得到相同的堆地址。我的写法用了 Box::into_raw(boxed)，避免了内存被自动回收（https:&#47;&#47;doc.rust-lang.org&#47;std&#47;boxed&#47;struct.Box.html#method.into_raw）。","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1639855045,"ip_address":"","comment_id":322692,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1637552164","product_id":100085301,"comment_content":"老师你在对“核桃”的解答中说：<br>“as_ptr() 拿到的是栈上的指针，你应该需要堆上指向实际内容的指针。所以应该用 Vec::into_boxed_slice(), 然后再用 Box::into_raw 拿到裸指针。”<br>1. 没看明白啊，as_ptr() 怎么就是栈上的指针了？看下面的代码，打印出来明明都是同一个地址啊...<br>https:&#47;&#47;play.rust-lang.org&#47;?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=5b74ccf59b05b507d588e5e0297f9448<br>那你所说的5个地址相同的原因就不成立了，那么到底是怎么回事儿呢？<br><br>我发现在你的代码中真正起作用的是 `Box::into_raw(boxed)` 这个表达式……<br><br>2. 还有 Vec&lt;*const u8&gt; 可以理解为指向数组的首元素啊……为啥不行呢……","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539903,"discussion_content":"哈，多谢提醒。之前我回复的时候把 as_ptr() 看成了 as_ref()，所以认为是栈上的地址。as_ptr() 返回堆地址。这里的问题是 num 是个局部变量，每次循环完都会被回收，所以一直得到相同的堆地址。我的写法用了 Box::into_raw(boxed)，避免了内存被自动回收（https://doc.rust-lang.org/std/boxed/struct.Box.html#method.into_raw）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639855045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1390032,"avatar":"https://static001.geekbang.org/account/avatar/00/15/35/d0/f2ac6d91.jpg","nickname":"阿成","note":"","ucode":"CEC3CD65FB9333","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532255,"discussion_content":"原代码不工作的真正原因是 vec 被回收了，所以 data 数组里的那些指针都已经失效了。而老师的写法其实是借助 Box::leak 的力量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637564396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313286,"user_name":"noisyes","can_delete":false,"product_type":"c1","uid":2538540,"ip_address":"","ucode":"94EC310B284AD2","user_header":"https://static001.geekbang.org/account/avatar/00/26/bc/2c/963688bb.jpg","comment_is_top":false,"comment_ctime":1632364285,"is_pvip":false,"replies":[{"id":"113526","content":"对","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632464540,"ip_address":"","comment_id":313286,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1632364285","product_id":100085301,"comment_content":"代码不以二进制分发就没问题吧","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527303,"discussion_content":"对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632464540,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2905523,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIDqHQQByGiaXcAk94MdDn3ftupZLXyR6bAKibxOzMxy5h3uBwZ7QiaCiaIfbCMK0cIQfGNax8iawoiaQAg/132","nickname":"nuan","note":"","ucode":"55FF98EB85404D","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555878,"discussion_content":"除了二进制分发，还能使用源码分发吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647090308,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313179,"user_name":"芥末小龙","can_delete":false,"product_type":"c1","uid":1176417,"ip_address":"","ucode":"387D01880867AC","user_header":"https://static001.geekbang.org/account/avatar/00/11/f3/61/8f7fca5b.jpg","comment_is_top":false,"comment_ctime":1632302853,"is_pvip":false,"replies":[{"id":"113472","content":"这个改法可行，但不是最好的改法。这个代码 new() 的接口有问题，参数不应该是 &amp;str，其实应该穿入 W。你可以看看其它人的回答。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632358202,"ip_address":"","comment_id":313179,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1632302853","product_id":100085301,"comment_content":"有点要跟不上节奏了，改了半天，跟榜一大佬差不多。<br>use std::io::{BufWriter, Write};<br>use std::net::TcpStream;<br><br>#[derive(Debug)]<br>struct MyWriter&lt;W&gt; {<br>    writer: W,<br>}<br><br>impl&lt;W: Write&gt; MyWriter&lt;W&gt; {<br>    pub fn new(addr: &amp;str) -&gt; MyWriter&lt;BufWriter&lt;TcpStream&gt;&gt; {<br>        let stream = TcpStream::connect(addr).unwrap();<br>        MyWriter {<br>            writer: BufWriter::new(stream),<br>        }<br>    }<br><br>    pub fn write(&amp;mut self, buf: &amp;str) -&gt; std::io::Result&lt;()&gt; {<br>        self.writer.write_all(buf.as_bytes())<br>    }<br>}<br><br>fn main() {<br>    let mut writer = MyWriter::&lt;BufWriter&lt;TcpStream&gt;&gt;::new(&quot;127.0.0.1:8080&quot;);<br>    writer.write(&quot;hello world!&quot;).unwrap();<br>}","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527262,"discussion_content":"这个改法可行，但不是最好的改法。这个代码 new() 的接口有问题，参数不应该是 &amp;amp;str，其实应该穿入 W。你可以看看其它人的回答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632358202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312991,"user_name":"记事本","can_delete":false,"product_type":"c1","uid":1401568,"ip_address":"","ucode":"FA942636EE0CC8","user_header":"https://static001.geekbang.org/account/avatar/00/15/62/e0/d2ff52da.jpg","comment_is_top":false,"comment_ctime":1632190169,"is_pvip":false,"replies":[{"id":"113398","content":"👍 正确","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632239622,"ip_address":"","comment_id":312991,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1632190169","product_id":100085301,"comment_content":"改进了看符不符合要求，记事本写的<br>use std::io::{BufWriter,Write};<br>use std::net::TcpStream;<br><br>#[derive(Debug)]<br>struct MyWriter&lt;W:Write&gt;{<br>    writer:BufWriter&lt;W&gt;<br>}<br><br>impl &lt;W:Write&gt;  MyWriter&lt;W&gt; {<br>    pub fn new(stram:W) -&gt;Self {<br>        Self { <br>            writer: BufWriter::new(stram)<br>        }<br>    }<br><br>    pub fn write(&amp;mut self,s:&amp;str) -&gt;std::io::Result&lt;()&gt; {<br>        self.writer.write_all(s.as_bytes())   <br>    }<br>}<br>fn main() {<br><br>    let addr = &quot;127.0.0.1:8001&quot;;<br>    let stream = TcpStream::connect(addr).unwrap();<br>    let mut s =  MyWriter::new(stream);<br>    s.write(&quot;hello world&quot;);<br><br>}<br>","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527192,"discussion_content":"👍 正确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632239622,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1079876,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL9hlAIKQ1sGDu16oWLOHyCSicr18XibygQSMLMjuDvKk73deDlH9aMphFsj41WYJh121aniaqBLiaMNg/132","nickname":"腾达","note":"","ucode":"72F9CFBA44FDEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547737,"discussion_content":"不行吧，编译还是报错：writer: BufWriter::new(stram) 这样代码还是报错： expected type parameter `W`, found struct `BufWriter`","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642845410,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312979,"user_name":"Fenix","can_delete":false,"product_type":"c1","uid":1074098,"ip_address":"","ucode":"AA8C1EECDFD405","user_header":"https://static001.geekbang.org/account/avatar/00/10/63/b2/9223bc53.jpg","comment_is_top":false,"comment_ctime":1632184824,"is_pvip":true,"replies":[{"id":"113399","content":"我文中没有说 python 是弱类型啊。强类型和弱类型的划分并没有严格的标准，其中一个标准是看会不会自动发生隐式转换。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632239777,"ip_address":"","comment_id":312979,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1632184824","product_id":100085301,"comment_content":"想问下，看到各种文章都说python是强类型的语言呀","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527188,"discussion_content":"我文中没有说 python 是弱类型啊。强类型和弱类型的划分并没有严格的标准，其中一个标准是看会不会自动发生隐式转换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632239777,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312939,"user_name":"qinsi","can_delete":false,"product_type":"c1","uid":1667175,"ip_address":"","ucode":"090D9C4068FF12","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","comment_is_top":false,"comment_ctime":1632131692,"is_pvip":true,"replies":[{"id":"113412","content":"嗯，谢谢指正。这个图需要改一下。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632241578,"ip_address":"","comment_id":312939,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1632131692","product_id":100085301,"comment_content":"为什么中间的图上写着Haskell&#47;ML不能自动推导...类型推导可是ML系语言的标配","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527171,"discussion_content":"嗯，谢谢指正。这个图需要改一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632241578,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}