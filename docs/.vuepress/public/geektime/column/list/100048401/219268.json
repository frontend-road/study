{"id":219268,"title":"05 | 倒排索引：如何从海量数据中查询同时带有“极”和“客”的唐诗？","content":"<p>你好，我是陈东。</p><p>试想这样一个场景：假设你已经熟读唐诗300首了。这个时候，如果我给你一首诗的题目，你可以马上背出这首诗的内容吗？相信你一定可以的。但是如果我问你，有哪些诗中同时包含了“极”字和“客”字？你就不见得能立刻回答出来了。你需要在头脑中一首诗一首诗地回忆，并判断每一首诗的内容是否同时包含了“极”字和“客”字。很显然，第二个问题的难度比第一个问题大得多。</p><p>那从程序设计的角度来看，这两个问题对应的检索过程又有什么不同呢？今天，我们就一起来聊一聊，两个非常常见又非常重要的检索技术：正排索引和倒排索引。</p><h2>什么是倒排索引？</h2><p>我们先来看比较简单的那个问题：给出一首诗的题目，马上背出内容。这其实就是一个典型的键值查询场景。针对这个场景，我们可以给每首诗一个唯一的编号作为ID，然后使用哈希表将诗的ID作为键（Key），把诗的内容作为键对应的值（Value）。这样，我们就能在O(1)的时间代价内，完成对指定key的检索。这样一个以对象的唯一ID为key的哈希索引结构，叫作<strong>正排索引</strong>（Forward Index）。<br>\n<img src=\"https://static001.geekbang.org/resource/image/4b/f1/4b5e88addf89120aba176671c53d25f1.jpeg?wh=1920*1080\" alt=\"\"></p><center><span class=\"reference\">哈希表存储所有诗</span></center><p>一般来说，我们会遍历哈希表，遍历的时间代价是O(n)。在遍历过程中，对于遇到的每一个元素也就是每一首诗，我们需要遍历这首诗中的每一个字符，才能判断是否包含“极”字和“客”字。假设每首诗的平均长度是k，那遍历一首诗的时间代价就是O(k)。从这个分析中我们可以发现，这个检索过程全部都是遍历，因此时间代价非常高。对此，有什么优化方法吗？</p><!-- [[[read_end]]] --><p>我们先来分析一下这两个场景。我们会发现，“根据题目查找内容”和“根据关键字查找题目”，这两个问题其实是完全相反的。既然完全相反，那我们能否“反着”建立一个哈希表来帮助我们查找呢？也就是说，如果我们以关键字作为key建立哈希表，是不是问题就解决了呢？接下来，我们就试着操作一下。</p><p>我们将每个关键字当作key，将包含了这个关键字的诗的列表当作存储的内容。这样，我们就建立了一个哈希表，根据关键字来查询这个哈希表，在O(1)的时间内，我们就能得到包含该关键字的文档列表。这种根据具体内容或属性反过来索引文档标题的结构，我们就叫它<strong>倒排索引</strong>（Inverted Index）。在倒排索引中，key的集合叫作<strong>字典</strong>（Dictionary），一个key后面对应的记录集合叫作<strong>记录列表</strong>（Posting List）。<br>\n<img src=\"https://static001.geekbang.org/resource/image/8e/8b/8e602ab79d98380c8c258a30a1e2108b.jpg?wh=1920*959\" alt=\"\"></p><center><span class=\"reference\">倒排索引</span></center><h2>如何创建倒排索索引？</h2><p>前面我们介绍了倒排索引的概念，那创建一个倒排索引的过程究竟是怎样的呢？我把这个过程总结成了以下步骤。</p><ol>\n<li>给每个文档编号，作为其唯一的标识，并且排好序，然后开始遍历文档（为什么要先排序，然后再遍历文档呢？你可以先想一下，后面我们会解释）。</li>\n<li>解析当前文档中的每个关键字，生成&lt;关键字，文档ID，关键字位置&gt;这样的数据对。为什么要记录关键字位置这个信息呢？因为在许多检索场景中，都需要显示关键字前后的内容，比如，在组合查询时，我们要判断多个关键字之间是否足够近。所以我们需要记录位置信息，以方便提取相应关键字的位置。</li>\n<li>将关键字作为key插入哈希表。如果哈希表中已经有这个key了，我们就在对应的posting list后面追加节点，记录该文档ID（关键字的位置信息如果需要，也可以一并记录在节点中）；如果哈希表中还没有这个key，我们就直接插入该key，并创建posting list和对应节点。</li>\n<li>重复第2步和第3步，处理完所有文档，完成倒排索引的创建。<br>\n<img src=\"https://static001.geekbang.org/resource/image/2c/0d/2ccc78df6ebbd4d716318d5113fa090d.jpg?wh=1920*679\" alt=\"\"></li>\n</ol><center><span class=\"reference\">将一个文档解析并加入倒排索引</span></center><h2>如何查询同时含有“极”字和“客”字两个key的文档？</h2><p>如果只是查询包含“极”或者“客”这样单个字的文档，我们直接以查询的字作为key去倒排索引表中检索，得到的posting list就是结果了。但是，如果我们的目的是要查询同时包含“极”和“客”这两个字的文档，那我们该如何操作呢？</p><p>我们可以先分别用两个key去倒排索引中检索，这样会得到两个不同的posting list：A和B。A中的文档都包含了“极”字，B中文档都包含了“客”字。那么，如果一个文档既出现在A中，又出现在B中，它是不是就同时包含了这两个字呢？按照这个思路，我们只需查找出A和B的公共元素即可。</p><p>那么问题来了，我们该如何在A和B这两个链表中查找出公共元素呢？如果A和B都是无序链表，那我们只能将A链表和B链表中的每个元素分别比对一次，这个时间代价是O(m*n)。但是，如果两个链表都是有序的，我们就可以用归并排序的方法来遍历A和B两个链表，时间代价会降低为O(m + n)，其中m是链表A的长度，n是链表B的长度。</p><p>我把链表归并的过程总结成了3个步骤，你可以看一看。</p><p>第1步，使用指针p1和p2分别指向有序链表A和B的第一个元素。</p><p>第2步，对比p1和p2指向的节点是否相同，这时会出现3种情况：</p><ul>\n<li>两者的id相同，说明该节点为公共元素，直接将该节点加入归并结果。然后，p1和p2要同时后移，指向下一个元素；</li>\n<li>p1元素的id小于p2元素的id，p1后移，指向A链表中下一个元素；</li>\n<li>p1元素的id大于p2元素的id，p2后移，指向B链表中下一个元素。</li>\n</ul><p>第3步，重复第2步，直到p1或p2移动到链表尾为止。</p><p>为了帮助你理解，我把一个链表归并的完整例子画在了一张图中，你可以结合这张图进一步理解上面的3个步骤。</p><p><img src=\"https://static001.geekbang.org/resource/image/a3/5f/a377f626bbfc1de2f98f199ed0ad585f.jpg?wh=2127*2954\" alt=\"\"></p><center><span class=\"reference\">链表归并提取公共元素例子</span></center><p>那对于<strong>两个key</strong>的联合查询来说，除了有“同时存在”这样的场景以外，其实还有很多联合查询的实际例子。比如说，我们可以查询包含“极”<strong>或</strong>“客”字的诗，也可以查询包含“极”<strong>且不包含</strong>“客”的诗。这些场景分别对应着集合合并中的交集、并集和差集问题。它们的具体实现方法和“同时存在”的实现方法差不多，也是通过遍历链表对比的方式来完成的。如果感兴趣的话，你可以自己来实现看看，这里我就不再多做阐述了。</p><p>此外，在实际应用中，我们可能还需要对<strong>多个key</strong>进行联合查询。比如说，要查询同时包含“极”“客”“时”“间”四个字的诗。这个时候，我们利用多路归并的方法，同时遍历这四个关键词对应的posting list即可。实现过程如下图所示。<img src=\"https://static001.geekbang.org/resource/image/c9/96/c91ce2f3cff16b20b0cca52a57336b96.jpeg?wh=2600*1200\" alt=\"\"></p><center><span class=\"reference\">多路归并</span></center><h2>重点回顾</h2><p>好了，今天的内容就先讲到这里。你会发现，倒排索引的核心其实并不复杂，它的具体实现其实是哈希表，只是它不是将文档ID或者题目作为key，而是反过来，通过将内容或者属性作为key来存储对应的文档列表，使得我们能在O(1)的时间代价内完成查询。</p><p>尽管原理并不复杂，但是倒排索引是许多检索引擎的核心。比如说，数据库的全文索引功能、搜索引擎的索引、广告引擎和推荐引擎，都使用了倒排索引技术来实现检索功能。因此，这一讲的内容我也希望你能好好理解消化，打好扎实的基础。</p><h2>课堂讨论</h2><p>今天的内容实践性比较强，你可以结合下面这道课堂讨论题，动手试一试，加深理解。</p><p>对于一个检索系统而言，除了根据关键字查询文档，还可能有其他的查询需求。比如说，我们希望查询李白都写了哪些诗。也就是说，如何在“根据内容查询”的基础上，同时支持“根据作者查询”，我们该怎么做呢？</p><p>欢迎在留言区畅所欲言，说出你的思考过程和最终答案。如果有收获，也欢迎把这篇文章分享给你的朋友。</p>","comments":[{"had_liked":false,"id":201284,"user_name":"无形","can_delete":false,"product_type":"c1","uid":1016889,"ip_address":"","ucode":"B740E2A68A17A5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/84/39/c8772466.jpg","comment_is_top":false,"comment_ctime":1585745361,"is_pvip":true,"replies":[{"id":"75282","content":"非常棒！用不同的key进行区分的确是一个方案。另一个方案是可以在posting list中加域，标明是作者还是内容。<br>还有，倒排索引的检索效率优化是一个很重要的问题。你说的压缩位图是roaring bitmap，这的确是最近几年很火的一个应用。剧透一下，加餐会讲到。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1585751830,"ip_address":"","comment_id":201284,"utype":1}],"discussion_count":3,"race_medal":0,"score":"147614633425","product_id":100048401,"comment_content":"根据作者查询可以给每首诗打一个作者的标签，再把标签作为关键字，标签对应的文档集合即为这位诗人写的诗的集合，如这种格式<br>key=array<br>&quot;作者_李白&quot;=[&quot;将进酒&quot;，&quot;凤求凰&quot;，&quot;静夜思&quot;]<br>这里加的前缀&quot;作者_&quot;可以避免有的诗里面有&quot;李白&quot;这两个字，造成检索结果不准确，实际中key可能把key映射成ID，集合里保存的也是诗的ID，这是一种主动打标签的方式，如果还需要按照朝代查询，再打朝代的标签<br>对于检索效率的问题，当数据量很大的时候，显然不可能用链表，查询效率太低了，位图相比查询效率就非常高了，每个byte就能表示一个诗的ID，1表示有，0表示没有，因此非常省内存，而且位运算取交集、差集效率非常高，不过普通位图有一个缺点，如果数据稀疏的话比较浪费空间，因此有人研究出了压缩位图，压缩位图的主要思想是把一个int划分为高16位低16位，高16位对应int存储的容器，把低6位放到对应的容器中，容器有三种，有序集合、位图、还有一种忘了名字，会随着数据量的变化选择合适的容器来存储数据，比较节省内存，倒排索引+压缩位图是一个非常强的组合，搜索性能非常高，合适的场景下甚至可以替换ES，提升几十倍搜索性能。快手、华为千亿级用户标签检索系统中也有类似的应用","like_count":35,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490291,"discussion_content":"非常棒！用不同的key进行区分的确是一个方案。另一个方案是可以在posting list中加域，标明是作者还是内容。\n还有，倒排索引的检索效率优化是一个很重要的问题。你说的压缩位图是roaring bitmap，这的确是最近几年很火的一个应用。剧透一下，加餐会讲到。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585751830,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":237855,"discussion_content":"搜索的世界这么强大！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587191942,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1016889,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/39/c8772466.jpg","nickname":"无形","note":"","ucode":"B740E2A68A17A5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219375,"discussion_content":"学到了，期待加餐୧((〃•̀ꇴ•〃))૭⁺✧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585752977,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207669,"user_name":"阿斯蒂芬","can_delete":false,"product_type":"c1","uid":1024164,"ip_address":"","ucode":"61D5E3BDA4EBC5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a0/a4/b060c723.jpg","comment_is_top":false,"comment_ctime":1587133629,"is_pvip":false,"replies":[{"id":"77552","content":"工业社会的一个特点就是追求效率，如何能更快地完成事情是我们一直在追求的一个目标。检索技术可以说是我们在信息时代的加速器，它能帮助我们更快地获取信息，以及让系统更高速地运作。我相信它会持续地演化和影响我们的未来。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1587138896,"ip_address":"","comment_id":207669,"utype":1}],"discussion_count":2,"race_medal":0,"score":"35946871997","product_id":100048401,"comment_content":"想起了之前看《改变未来的九大算法》（书名比较夸张，但书是好书啊各位），开篇讲到了搜索引擎的「把戏」，就是从单词分词构建单词到网页的链接集合，来实现最「粗糙」的互联网检索冲浪。随后再考虑同时检索到多个满足条件的结果时，如何确定哪一个才更接近我们所需要的。于是在单纯记录单词出现的网页的基础上，加上了单词在这个网页的位置，理论上可以简单认为位置越近，就越符合我们检索条件的输入。<br>以上两个知识点其实跟老师讲的倒排索引思路类似。思考题的李白，其实也算是一种：假设作者和内容都命中，我们如何能区分哪个才是更接近我们想要的答案。解决这类问题的思路也是相似的，像单词增多一个在网页出现的位置记录一样，也可以考虑让“李白”多增加一个信息，来让计算机知道它是「出现在什么位置」的，当然这里的位置可能就变成了：内容、作者这样的标签或者类型。<br><br>人类想借助计算机快算处理结构化数据的特点，将人类知识从小条目到全文的检索关系结构化存储到计算机，实现了「正向索引」，但是贪婪的人类并不满足，调皮大脑还有一个特性就是，全文记不住，全文的这一小段那一小段倒是可能记得溜，所以人类又聪明地让计算机以类似的存储结构但是不同的关系方向来实现全文内容到全文方向的查找，于是出来了「倒排索引」。这个角度来看，说检索技术真是是被人类特征的需求来驱动进展的不为过。","like_count":9,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492202,"discussion_content":"工业社会的一个特点就是追求效率，如何能更快地完成事情是我们一直在追求的一个目标。检索技术可以说是我们在信息时代的加速器，它能帮助我们更快地获取信息，以及让系统更高速地运作。我相信它会持续地演化和影响我们的未来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587138896,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":237865,"discussion_content":"《改变未来的九大算法》看书名就很厉害，谢谢分享","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587193480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":201104,"user_name":"明翼","can_delete":false,"product_type":"c1","uid":1068361,"ip_address":"","ucode":"E77F86BEB3D5C1","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/49/28e73b9c.jpg","comment_is_top":false,"comment_ctime":1585716027,"is_pvip":false,"replies":[{"id":"75226","content":"就像你说的，邮件只需要检测一次，因此对邮件做倒排索引并不适用。而且倒排索引也解决不了近义词问题。<br>邮件敏感词检测一般是这样的思路:<br>1.准备一个敏感词字典。<br>2.遍历邮件，提取关键词，去敏感词字典中查找，找到了就说明邮件有敏感词。<br>这里的核心问题是如何提取关键词和如何在敏感词字典中查询。<br>一种方式是用哈希表存敏感词字典，然后用分词工具从邮件中提取关键字，然后去字典中查。<br>另一种方式是trie树来实现敏感词字典，然后逐字扫描邮件，用当前字符在trie树中查找。<br>不过，这两种方式都无法解决近义词，或者各种刻意替换字符的场景。要想解决这种问题，要么提供近义词字典，要么得使用大量数据进行训练和学习，用机器学习进行打分，将可疑的高分词找出来。<br>其实这种近义词处理方案，和搜索引擎解决近义词和查询纠错的过程很像。我在搜索引擎那篇里面会介绍。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1585721345,"ip_address":"","comment_id":201104,"utype":1}],"discussion_count":3,"race_medal":0,"score":"35945454395","product_id":100048401,"comment_content":"老师对于邮件中敏感词检测适不适合用倒排索引那，用的话可能每个邮件都只要检测一次，不用直接搜索可能又找不到近义词","like_count":9,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490240,"discussion_content":"就像你说的，邮件只需要检测一次，因此对邮件做倒排索引并不适用。而且倒排索引也解决不了近义词问题。\n邮件敏感词检测一般是这样的思路:\n1.准备一个敏感词字典。\n2.遍历邮件，提取关键词，去敏感词字典中查找，找到了就说明邮件有敏感词。\n这里的核心问题是如何提取关键词和如何在敏感词字典中查询。\n一种方式是用哈希表存敏感词字典，然后用分词工具从邮件中提取关键字，然后去字典中查。\n另一种方式是trie树来实现敏感词字典，然后逐字扫描邮件，用当前字符在trie树中查找。\n不过，这两种方式都无法解决近义词，或者各种刻意替换字符的场景。要想解决这种问题，要么提供近义词字典，要么得使用大量数据进行训练和学习，用机器学习进行打分，将可疑的高分词找出来。\n其实这种近义词处理方案，和搜索引擎解决近义词和查询纠错的过程很像。我在搜索引擎那篇里面会介绍。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585721345,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2343516,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/mmTEibMibic5ibsVpNZkR3HBlpPpZYt0gHGdIqOduLGxRHZpTWRG3q56CT1eejoLgNsdaW5aQGWXfyibN4vm9CicYb3w/132","nickname":"Geek_7347cf","note":"","ucode":"2E25574FAB1B3B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344327,"discussion_content":"为什么不把字典存在bloomfilter里","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611408120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1068361,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4d/49/28e73b9c.jpg","nickname":"明翼","note":"","ucode":"E77F86BEB3D5C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220449,"discussion_content":"谢谢老师回答的太详细了，赞赞赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585878239,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204768,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1586454151,"is_pvip":false,"replies":[{"id":"76534","content":"posting list分域，就是一个元素里加上域标识。举个例子，一篇文章有标题，作者，内容三个域，而“李白”这两个字，可能出现在这三个位置。因此，key和posting list可以这么写:<br>key =“李白” －&gt;  [id1，标题域:0，作者域:1，内容域:0]，[id2，标题域:1，作者域:0，内容域:1]","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1586482868,"ip_address":"","comment_id":204768,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27356257927","product_id":100048401,"comment_content":"加餐是6号出的，倒排是1号出的，所以我先把1号的补完哈～<br><br>你可以再思考一些细节:如果有一些诗的内容里也有“李白”这个关键词，比如杜甫的诗。<br>那么作者“李白”对应的posting list，和内容中的“李白”对应的posting list是否会冲突？可以怎么处理？<br><br>key_李白 = posting list;  内容中的关键字作为倒排索引<br>author_李白 = posting list;  作者的名字作为倒排索引<br>为避免 关键字 或 名字 或 朝代 相同时，查询出错，通过给索引加 前缀 或 后缀的形式 来区分内容相同类型不同的索引。<br><br>老师说的给posting list分域有点想不明白？ <br><br>看到老师提到进阶会有：压缩位图、磁盘存储、分布式存储。期待老师的进阶篇文章！<br><br>ps: 终于补到6号的了，马上可以去享受加餐课了！<br>(✪▽✪)","like_count":7,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491281,"discussion_content":"posting list分域，就是一个元素里加上域标识。举个例子，一篇文章有标题，作者，内容三个域，而“李白”这两个字，可能出现在这三个位置。因此，key和posting list可以这么写:\nkey =“李白” －&amp;gt;  [id1，标题域:0，作者域:1，内容域:0]，[id2，标题域:1，作者域:0，内容域:1]","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586482868,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205467,"user_name":"fengyi","can_delete":false,"product_type":"c1","uid":1258324,"ip_address":"","ucode":"C6FA77BE015F5A","user_header":"https://static001.geekbang.org/account/avatar/00/13/33/54/595be268.jpg","comment_is_top":false,"comment_ctime":1586623181,"is_pvip":false,"replies":[{"id":"76743","content":"将“极客”作为一个单独的key进行索引是比较高效的。因为它只在检索时只需要直接将posting list取出即可。<br>当然，在分词不work的情况下，我们也可以单独对“极”和“客”进行检索，然后在对两个posting list归并时，判断这两个字的位置是否紧邻(在posting list中的每个元素，可以用pos数组记录key出现的所有位置)，这样就能判断是否存在“极客”的组合了。这就是搜索引擎会使用的短语查询的方案。你会发现，这种方法会相对耗时一些。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1586657235,"ip_address":"","comment_id":205467,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23061459661","product_id":100048401,"comment_content":"有个问题想请教。如果要搜寻‘极客’这个单词的话。有方法可以重复利用‘极’和‘客’的索引吗。还是要对‘极客’单独作索引","like_count":6,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491489,"discussion_content":"将“极客”作为一个单独的key进行索引是比较高效的。因为它只在检索时只需要直接将posting list取出即可。\n当然，在分词不work的情况下，我们也可以单独对“极”和“客”进行检索，然后在对两个posting list归并时，判断这两个字的位置是否紧邻(在posting list中的每个元素，可以用pos数组记录key出现的所有位置)，这样就能判断是否存在“极客”的组合了。这就是搜索引擎会使用的短语查询的方案。你会发现，这种方法会相对耗时一些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586657235,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":268544,"user_name":"Bachue Zhou","can_delete":false,"product_type":"c1","uid":1494491,"ip_address":"","ucode":"3175754775CA32","user_header":"https://static001.geekbang.org/account/avatar/00/16/cd/db/7467ad23.jpg","comment_is_top":false,"comment_ctime":1608253665,"is_pvip":false,"replies":[{"id":"97572","content":"说得很好，这是更高效的检索方法，在后面加餐篇里我们就会提到这种哈希表法。<br>在这篇文章中，我想表述的意思是不借助其他的数据结构，单凭原始的链表本身，有序链表会比无序链表更便于查找。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1608478907,"ip_address":"","comment_id":268544,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18788122849","product_id":100048401,"comment_content":"“那么问题来了，我们该如何在 A 和 B 这两个链表中查找出公共元素呢？如果 A 和 B 都是无序链表，那我们只能将 A 链表和 B 链表中的每个元素分别比对一次，这个时间代价是 O(m*n)。”不需要这么麻烦，对A建立Hash表，对B搜索Hash表即可，时间代价是O（m+n）","like_count":5,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511965,"discussion_content":"说得很好，这是更高效的检索方法，在后面加餐篇里我们就会提到这种哈希表法。\n在这篇文章中，我想表述的意思是不借助其他的数据结构，单凭原始的链表本身，有序链表会比无序链表更便于查找。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608478907,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":226499,"user_name":"大头爸爸","can_delete":false,"product_type":"c1","uid":1276613,"ip_address":"","ucode":"131E25DB04D222","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/gmP4Yh00MZPwNvr4UQdLeXaX3TVyZEEp195S3vD3Sfl1xz5jBr1474Mt6w5OPr0KsrnQObfLRy5PkKNFjSBiasA/132","comment_is_top":false,"comment_ctime":1592123313,"is_pvip":false,"replies":[{"id":"83413","content":"这样下定论会有一点过于绝对。<br>实际上，倒排索引是一种“根据属性&#47;关键词来查询文章”的技术，只要有这个需要的场景都可以使用倒排索引。搜索引擎只是正好可以大规模使用这个技术的一个应用场景，但这并不意味着MySQL或者nosql不能使用倒排索引技术。实际上在MySQL中就是支持倒排索引的。并且，即使在搜索引擎中，微软的bing也开源了他们的向量检索技术，是基于树的检索技术，而不是倒排索引。<br>另一方面，列存储更多是一种减少磁盘io和节省存储空间的存储技术(而不是检索技术)。它也没有被明确限定只能在nosql中使用，实际上，关系型数据库也可以使用列存储。至于搜索引擎，它其实是更高层的一个业务应用，它会依赖一定的底层存储，比如说网页存取，索引存取等。这里面其实是可以用到nosql的存储技术的，也就是可以使用列存储的。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1592143527,"ip_address":"","comment_id":226499,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18771992497","product_id":100048401,"comment_content":"是不是倒排索引主要应用在搜索引擎这一块？跟数据库SQL&#47;NOSQL关系不大？<br>另外，还有一个概念是列式存储，那个是不是主要用在NOSQL，跟搜索引擎关系不大?","like_count":5,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498265,"discussion_content":"这样下定论会有一点过于绝对。\n实际上，倒排索引是一种“根据属性/关键词来查询文章”的技术，只要有这个需要的场景都可以使用倒排索引。搜索引擎只是正好可以大规模使用这个技术的一个应用场景，但这并不意味着MySQL或者nosql不能使用倒排索引技术。实际上在MySQL中就是支持倒排索引的。并且，即使在搜索引擎中，微软的bing也开源了他们的向量检索技术，是基于树的检索技术，而不是倒排索引。\n另一方面，列存储更多是一种减少磁盘io和节省存储空间的存储技术(而不是检索技术)。它也没有被明确限定只能在nosql中使用，实际上，关系型数据库也可以使用列存储。至于搜索引擎，它其实是更高层的一个业务应用，它会依赖一定的底层存储，比如说网页存取，索引存取等。这里面其实是可以用到nosql的存储技术的，也就是可以使用列存储的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592143527,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":201019,"user_name":"李恒达","can_delete":false,"product_type":"c1","uid":1120147,"ip_address":"","ucode":"E9F1AC9E74CA16","user_header":"https://static001.geekbang.org/account/avatar/00/11/17/93/981dc959.jpg","comment_is_top":false,"comment_ctime":1585706053,"is_pvip":true,"replies":[{"id":"75215","content":"你的思考很好！的确是这样的。你可以回到开头背唐诗的场景。如果只要求给题目背内容，那么是只需要正排索引就好。不需要倒排索引。<br>倒排索引是用在需要根据部分信息或者属性去反查出数据主体的场景中。搜索引擎就是典型的应用场景，因为我们只知道我们想找什么关键字，而不知道哪些网页有这些关键字，因此需要倒排索引。数据库也一样，很多时候，我们去数据库中查找，也不是直接找id，而是用where去限定一些属性和字段。因此，你会发现，根据我们关心的属性去寻找主体，这种需求其实很常见，这些场景就可以用倒排索引了。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1585718904,"ip_address":"","comment_id":201019,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18765575237","product_id":100048401,"comment_content":"老师，我有个疑问，为了实现根据关键词获取数据的功能，是不是需要在正常的表存储的基础上，再额外维护这样一个倒排索引？那这种在关键词不明确的情况下是不是就不会有这个东西了？","like_count":5,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490211,"discussion_content":"你的思考很好！的确是这样的。你可以回到开头背唐诗的场景。如果只要求给题目背内容，那么是只需要正排索引就好。不需要倒排索引。\n倒排索引是用在需要根据部分信息或者属性去反查出数据主体的场景中。搜索引擎就是典型的应用场景，因为我们只知道我们想找什么关键字，而不知道哪些网页有这些关键字，因此需要倒排索引。数据库也一样，很多时候，我们去数据库中查找，也不是直接找id，而是用where去限定一些属性和字段。因此，你会发现，根据我们关心的属性去寻找主体，这种需求其实很常见，这些场景就可以用倒排索引了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585718904,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200962,"user_name":"范闲","can_delete":false,"product_type":"c1","uid":1073125,"ip_address":"","ucode":"F21FD7DF6BA53C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","comment_is_top":false,"comment_ctime":1585699811,"is_pvip":false,"replies":[{"id":"75199","content":"你的问题我理解有两点:<br>1.检索效率问题。<br>2.存储空间问题。<br>关于检索效率问题，马上会出来两篇热腾腾的加餐，和你聊聊怎么进行倒排索引的检索加速。<br>关于存储空间问题，我接下来在进阶篇会开始介绍解决方案。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1585703513,"ip_address":"","comment_id":200962,"utype":1}],"discussion_count":5,"race_medal":0,"score":"14470601699","product_id":100048401,"comment_content":"拉链的是倒排索引在数据量不大的情况下应该很好？如果数量上去了，要改成跳表了吧？如果跳表也支撑不下去了呢？","like_count":4,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490196,"discussion_content":"你的问题我理解有两点:\n1.检索效率问题。\n2.存储空间问题。\n关于检索效率问题，马上会出来两篇热腾腾的加餐，和你聊聊怎么进行倒排索引的检索加速。\n关于存储空间问题，我接下来在进阶篇会开始介绍解决方案。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585703513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1276613,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/gmP4Yh00MZPwNvr4UQdLeXaX3TVyZEEp195S3vD3Sfl1xz5jBr1474Mt6w5OPr0KsrnQObfLRy5PkKNFjSBiasA/132","nickname":"大头爸爸","note":"","ucode":"131E25DB04D222","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283558,"discussion_content":"请问拉链是指什么啊？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592296803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1073125,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","nickname":"范闲","note":"","ucode":"F21FD7DF6BA53C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1276613,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/gmP4Yh00MZPwNvr4UQdLeXaX3TVyZEEp195S3vD3Sfl1xz5jBr1474Mt6w5OPr0KsrnQObfLRy5PkKNFjSBiasA/132","nickname":"大头爸爸","note":"","ucode":"131E25DB04D222","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283641,"discussion_content":"是字典里存链表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592316957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":283558,"ip_address":""},"score":283641,"extra":""}]},{"author":{"id":1073125,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","nickname":"范闲","note":"","ucode":"F21FD7DF6BA53C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":218831,"discussion_content":"是的，就是空间和时间的问题。自己做项目的时候，小数据的情况（几十万）直接用拉链的就行。所以想知道大数据量应该如何做？同时倒排的增删改是不是需要存在，也好奇？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585703999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":1073125,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","nickname":"范闲","note":"","ucode":"F21FD7DF6BA53C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":222329,"discussion_content":"加餐更新了两篇，就是在讲大数据量下的方案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586135445,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":218831,"ip_address":""},"score":222329,"extra":""}]}]},{"had_liked":false,"id":214171,"user_name":"时隐时现","can_delete":false,"product_type":"c1","uid":1111899,"ip_address":"","ucode":"DA4D622FF84920","user_header":"https://static001.geekbang.org/account/avatar/00/10/f7/5b/d2e7c2c4.jpg","comment_is_top":false,"comment_ctime":1588670481,"is_pvip":false,"replies":[{"id":"79325","content":"讨论区其实是一个思维碰撞的地方。毕竟文章篇幅有限，不可能事无巨细都说一遍。<br>因此，如果有什么不清楚的，或者想延展讨论的，都可以在这里交流，相信通过这样的交流，能让更多的人更深入地理解这些知识点。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1588683377,"ip_address":"","comment_id":214171,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10178605073","product_id":100048401,"comment_content":"每个留言问的到位，作者回复的也耐心，支持","like_count":3,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493973,"discussion_content":"讨论区其实是一个思维碰撞的地方。毕竟文章篇幅有限，不可能事无巨细都说一遍。\n因此，如果有什么不清楚的，或者想延展讨论的，都可以在这里交流，相信通过这样的交流，能让更多的人更深入地理解这些知识点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588683377,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":201051,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1585709630,"is_pvip":true,"replies":[{"id":"75217","content":"分词是第一步，这样就有了倒排索引的key。至于有了倒排索引以后，如何提高检索效率，马上会有加餐为你揭晓","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1585719372,"ip_address":"","comment_id":201051,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10175644222","product_id":100048401,"comment_content":"倒排索引的核心就是关键词的提取，也就是如何合理的对内容进行分词","like_count":3,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490226,"discussion_content":"分词是第一步，这样就有了倒排索引的key。至于有了倒排索引以后，如何提高检索效率，马上会有加餐为你揭晓","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585719372,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200974,"user_name":"与你一起学算法","can_delete":false,"product_type":"c1","uid":1318001,"ip_address":"","ucode":"A7E03B3E41828E","user_header":"https://static001.geekbang.org/account/avatar/00/14/1c/71/f7a7f70f.jpg","comment_is_top":false,"comment_ctime":1585701207,"is_pvip":false,"replies":[{"id":"75200","content":"很好，你关注到了“李白”的分词问题了！<br>对于如何确定一个词，常见的做法是使用分词技术，将“李白”作为一个整体处理。这样检索性能也最好。<br>而你提的这个方案，是在分词技术无效的情况下，搜索引擎会采用的方案，它会根据位置信息进行短语查询，查出来的“李”和“白”是有序相邻的，优先级最高，位置越远的，优先级越低。通过描述，你也能体会到这样的效率的确没有直接处理一个整体高。因此，分词也是很重要的技术。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1585703891,"ip_address":"","comment_id":200974,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10175635799","product_id":100048401,"comment_content":"老师在文章中提到了在构建倒排索引过程中要记录位置信息，我想可不可以同时检索 李  字和 白  字，然后判断二者的位置是否相邻？希望老师解答。","like_count":3,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490197,"discussion_content":"很好，你关注到了“李白”的分词问题了！\n对于如何确定一个词，常见的做法是使用分词技术，将“李白”作为一个整体处理。这样检索性能也最好。\n而你提的这个方案，是在分词技术无效的情况下，搜索引擎会采用的方案，它会根据位置信息进行短语查询，查出来的“李”和“白”是有序相邻的，优先级最高，位置越远的，优先级越低。通过描述，你也能体会到这样的效率的确没有直接处理一个整体高。因此，分词也是很重要的技术。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585703891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200940,"user_name":"峰","can_delete":false,"product_type":"c1","uid":1056019,"ip_address":"","ucode":"C53CB64E8E7D19","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg","comment_is_top":false,"comment_ctime":1585695827,"is_pvip":true,"replies":[{"id":"75172","content":"哈哈，用“口音牛逼”作为我的属性，就可以通过这个标签将我检索出来了。😁<br>明显的答案水到渠成，那我们来加入一点细节吧。许多诗的内容里都有李白的名字，比如杜甫就写了许多思念李白的诗。那我们用作者“李白”构建倒排索引，和用内容中的“李白”做倒排索引，会不会有冲突?会不会直接把杜甫的诗给召回了?<br>ps:机器学习构建索引就是我们现在在做的事情","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1585699411,"ip_address":"","comment_id":200940,"utype":1}],"discussion_count":4,"race_medal":0,"score":"10175630419","product_id":100048401,"comment_content":"感觉老师这个问题有点水到渠成的感觉，既然讲了倒排，一个很明显的答案就是把作者也当检索内容一样处理构建索引，对这种类似kv m 查的问题，这应该是最优的一个手段，具体的方案应该考虑如何压缩表示的问题，不明显的答案想不到哈哈哈。<br><br>既然提到索引给大家分享一个观点，索引是什么，从机器学习的角度上看，它其实是检索信息(比如这边的关键字，作者等等)到数据本身位置信息的一个映射关系，pos ＝f(x)。这就转变成一个机器学习怎么输入x 预测pos 的问题了！(观点来自jeaf dean组的一篇论文)<br><br>最后老师的口音真牛逼！！！哈哈哈😂","like_count":3,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490188,"discussion_content":"哈哈，用“口音牛逼”作为我的属性，就可以通过这个标签将我检索出来了。😁\n明显的答案水到渠成，那我们来加入一点细节吧。许多诗的内容里都有李白的名字，比如杜甫就写了许多思念李白的诗。那我们用作者“李白”构建倒排索引，和用内容中的“李白”做倒排索引，会不会有冲突?会不会直接把杜甫的诗给召回了?\nps:机器学习构建索引就是我们现在在做的事情","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585699411,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1276613,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/gmP4Yh00MZPwNvr4UQdLeXaX3TVyZEEp195S3vD3Sfl1xz5jBr1474Mt6w5OPr0KsrnQObfLRy5PkKNFjSBiasA/132","nickname":"大头爸爸","note":"","ucode":"131E25DB04D222","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283568,"discussion_content":"我还是没搞明白为什么作者“李白”构建的倒排索引和用内容中的“李白”构建的倒排索引会冲突。我们要是查李白写了哪些诗，直接就用作者“李白”构建的倒排索引不就可以了吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592298169,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1056019,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg","nickname":"峰","note":"","ucode":"C53CB64E8E7D19","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":218853,"discussion_content":"作者这个当然是作为与内容并列的两个维度去描述文档，所以感觉这个问题不是很成立，成立的话可能就要上nlp做抽取了。\n \n哇⊙∀⊙！看到那篇论文的时候就惊为天人，过拟合竟然可以这么用，但觉得和工程实践还有一定距离，我一直比较感兴趣的领域就是人工智能在数据库这类平台性软件上的应用，希望有机会能加入像老师组这样的团队😁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585706493,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":1056019,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg","nickname":"峰","note":"","ucode":"C53CB64E8E7D19","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":222330,"discussion_content":"欢迎欢迎，我们一直在招聘","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586135518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":218853,"ip_address":""},"score":222330,"extra":""}]}]},{"had_liked":false,"id":201745,"user_name":"Chaos","can_delete":false,"product_type":"c1","uid":1534916,"ip_address":"","ucode":"096D84B0DECEDB","user_header":"https://static001.geekbang.org/account/avatar/00/17/6b/c4/9ed6b91d.jpg","comment_is_top":false,"comment_ctime":1585831813,"is_pvip":false,"replies":[{"id":"75414","content":"你这个想法很棒！的确有这样的方案，用位图来代替链表。我在加餐里会介绍。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1585834981,"ip_address":"","comment_id":201745,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5880799109","product_id":100048401,"comment_content":"在A和B两个链表中查找公共元素，也可以看作判断A中的元素在B中是否存在。那么是不是可以使用上一讲中讲到的布隆过滤器，这样就不需要链表是有序的了。","like_count":2,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490408,"discussion_content":"你这个想法很棒！的确有这样的方案，用位图来代替链表。我在加餐里会介绍。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585834981,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200959,"user_name":"范闲","can_delete":false,"product_type":"c1","uid":1073125,"ip_address":"","ucode":"F21FD7DF6BA53C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","comment_is_top":false,"comment_ctime":1585699518,"is_pvip":false,"replies":[{"id":"75197","content":"很正确！posting list是可以根据需要放更多复杂的信息的，从而帮助我们解决更多复杂的需求。<br>不过也要注意一个度，如果把所有信息都放posting list中，依赖于集合检查，那就变成了遍历查找的效率了。因此，在合适的场景下，有时候也可以为author独立建一个新索引。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1585703354,"ip_address":"","comment_id":200959,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5880666814","product_id":100048401,"comment_content":"posting list里面可以增加一个author的信息，word,author,pos,id。这样查完以后只需要做个集合检查即可。","like_count":2,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490194,"discussion_content":"很正确！posting list是可以根据需要放更多复杂的信息的，从而帮助我们解决更多复杂的需求。\n不过也要注意一个度，如果把所有信息都放posting list中，依赖于集合检查，那就变成了遍历查找的效率了。因此，在合适的场景下，有时候也可以为author独立建一个新索引。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585703354,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200919,"user_name":"西西弗与卡夫卡","can_delete":false,"product_type":"c1","uid":1001710,"ip_address":"","ucode":"B4C27B8335B76A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/ee/872ad07e.jpg","comment_is_top":false,"comment_ctime":1585674209,"is_pvip":true,"replies":[{"id":"75191","content":"很好，你提到了“以关键字为key”和“以作者名为key”，我们是可以用两个不同的key来区分作者“李白”和内容中的“李白”。<br>这样就能解决“明明想搜的是李白写的诗，结果出来了杜甫写李白的诗”这样的问题","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1585702832,"ip_address":"","comment_id":200919,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5880641505","product_id":100048401,"comment_content":"在关键字为key所在文档为posting list的基础上，再加以作者名为key，posting list为作者诗集的索引","like_count":2,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490179,"discussion_content":"很好，你提到了“以关键字为key”和“以作者名为key”，我们是可以用两个不同的key来区分作者“李白”和内容中的“李白”。\n这样就能解决“明明想搜的是李白写的诗，结果出来了杜甫写李白的诗”这样的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585702832,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200915,"user_name":"李跃爱学习","can_delete":false,"product_type":"c1","uid":1347792,"ip_address":"","ucode":"F25C038C86324A","user_header":"https://static001.geekbang.org/account/avatar/00/14/90/d0/48037ba6.jpg","comment_is_top":false,"comment_ctime":1585672420,"is_pvip":false,"replies":[{"id":"75188","content":"很好。对于属性建立倒排索引是正确的。<br>你可以再思考一些细节:如果有一些诗的内容里也有“李白”这个关键词，比如杜甫的诗。<br>那么作者“李白”对应的posting list，和内容中的“李白”对应的posting list是否会冲突？可以怎么处理？","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1585702090,"ip_address":"","comment_id":200915,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5880639716","product_id":100048401,"comment_content":"作者看做是文档的一个属性，建立属性倒排索引","like_count":1,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490177,"discussion_content":"很好。对于属性建立倒排索引是正确的。\n你可以再思考一些细节:如果有一些诗的内容里也有“李白”这个关键词，比如杜甫的诗。\n那么作者“李白”对应的posting list，和内容中的“李白”对应的posting list是否会冲突？可以怎么处理？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585702090,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":302498,"user_name":"Arnold","can_delete":false,"product_type":"c1","uid":1668412,"ip_address":"","ucode":"BD8CEF62A611EE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eppdzFnpQ6vvtzALzsMEzvcxR6c9mn7TQUWBUKhY5h4gJj1Jy09xcia07zdRRDAJVDq5P0YBGxfAMg/132","comment_is_top":false,"comment_ctime":1626240754,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626240754","product_id":100048401,"comment_content":"将作者信息也构建倒排，作为一个结构话的字段。查询时相当于在&quot;极&quot; and &quot;客&quot; 后加一个 and &quot;李白&quot;，只不过这个&quot;李白&quot;不是在内容的posting list，而是作者的倒排中。 同理朝代、时间、类型也一样。","like_count":0},{"had_liked":false,"id":250010,"user_name":"大头","can_delete":false,"product_type":"c1","uid":1140787,"ip_address":"","ucode":"3B85B468E09255","user_header":"https://static001.geekbang.org/account/avatar/00/11/68/33/e69b7ca8.jpg","comment_is_top":false,"comment_ctime":1600903369,"is_pvip":true,"replies":[{"id":"91848","content":"那你还是可以根据posting list合并的思路来完成这个检索功能。<br>1.先检索出包含“极”的posting list A，posting list中的每个元素都包含了(页id，图书id)。可以根据图书id将元素去重。<br>2.再检索出包含“客”的posting list B，posting list中的每个元素都包含了(页id，图书id)。可以根据图书id将元素去重。<br>3.将posting list A和posting list B合并，取出图书id相同的元素，就是同时包含了“极”和“客”字的图书了。<br>","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1601391618,"ip_address":"","comment_id":250010,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1600903369","product_id":100048401,"comment_content":"老师，有个电子书的搜索场景，电子书的每一页内容都存储在数据库中(表字段:图书id，页id，页内容)。我想搜索同时含有&quot;极&quot;和“客”的图书id，要如何高效搜索。把每页当成一个document导入es中的话，只能搜索同时含有&quot;极&quot;和“客”的页，没办法搜索同时含有&quot;极&quot;和“客”的图书id？老师有没有些思路分享下？","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506100,"discussion_content":"那你还是可以根据posting list合并的思路来完成这个检索功能。\n1.先检索出包含“极”的posting list A，posting list中的每个元素都包含了(页id，图书id)。可以根据图书id将元素去重。\n2.再检索出包含“客”的posting list B，posting list中的每个元素都包含了(页id，图书id)。可以根据图书id将元素去重。\n3.将posting list A和posting list B合并，取出图书id相同的元素，就是同时包含了“极”和“客”字的图书了。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601391618,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229339,"user_name":"mickey","can_delete":false,"product_type":"c1","uid":1051663,"ip_address":"","ucode":"8B490C2DDE4010","user_header":"https://static001.geekbang.org/account/avatar/00/10/0c/0f/93d1c8eb.jpg","comment_is_top":false,"comment_ctime":1592968931,"is_pvip":false,"replies":[{"id":"84638","content":"同时包含 “极”和“客”是取交集<br>包含“极”或者“客”是取并集<br>包含“极”且不包含“客”是取差集<br> 我看了一下文稿，的确是这样写的。不知道你说的讲反的地方是哪里？方便的话可以把原文发给我。谢谢。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1592979312,"ip_address":"","comment_id":229339,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1592968931","product_id":100048401,"comment_content":"老师，您好像讲反了。同时包含“极”和“客”是取交集，“极”或“客”才是取归并。","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499446,"discussion_content":"同时包含 “极”和“客”是取交集\n包含“极”或者“客”是取并集\n包含“极”且不包含“客”是取差集\n 我看了一下文稿，的确是这样写的。不知道你说的讲反的地方是哪里？方便的话可以把原文发给我。谢谢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592979312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218694,"user_name":"牛牛","can_delete":false,"product_type":"c1","uid":1194626,"ip_address":"","ucode":"CFCE68B4F92209","user_header":"https://static001.geekbang.org/account/avatar/00/12/3a/82/1ff83a38.jpg","comment_is_top":false,"comment_ctime":1589855748,"is_pvip":false,"replies":[{"id":"80831","content":"是的。你找到答案了，这个就是为什么要提前排序的原因。一个有序的posting list，会加快求交集和并集的过程。包括在后面第十二讲中，你也会看到我们是要如何保证posting list有序来加快检索的。<br>当然，回到这一讲的这个问题，我也补充一点，要保证posting list有序，我们有许多方法。比如说我们也可以先不对文档排序，而是等所有的posting list都生成了以后，再对每一个posting list都单独排序。只是这样排序代价会比在最开始的时候对文档进行排序要更大。因此我们才使用提前对文档排序的方法。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1589865965,"ip_address":"","comment_id":218694,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1589855748","product_id":100048401,"comment_content":"在创建倒排索引的过程中、作者留下一个小问题: 为什么要先排序文档 ?<br>我想下边的内容: 在查找两个集合公共元素的过程中, 若是无序链表, 需要遍历两个集合, 时间复杂度O(m*n); 若是有序链表, 可以归并, 时间复杂度降为 O(m+n) 就是答案了 ？<br><br>课程果然是需要反复读的, 上次看的时候、这篇好像没有很明白~~~","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495546,"discussion_content":"是的。你找到答案了，这个就是为什么要提前排序的原因。一个有序的posting list，会加快求交集和并集的过程。包括在后面第十二讲中，你也会看到我们是要如何保证posting list有序来加快检索的。\n当然，回到这一讲的这个问题，我也补充一点，要保证posting list有序，我们有许多方法。比如说我们也可以先不对文档排序，而是等所有的posting list都生成了以后，再对每一个posting list都单独排序。只是这样排序代价会比在最开始的时候对文档进行排序要更大。因此我们才使用提前对文档排序的方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589865965,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1068361,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4d/49/28e73b9c.jpg","nickname":"明翼","note":"","ucode":"E77F86BEB3D5C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335854,"discussion_content":"问下老师，我们直接给每个文档顺序编号不行嘛，比如1，2，3 ，这样按照顺序遍历文档也是生成的post list也是有序的啊，再说文档排序，这个不是很麻烦嘛，文档这么多词语按照字符顺序排序，也没多少意义啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608353892,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207835,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1587193954,"is_pvip":false,"replies":[{"id":"77580","content":"你指的是加餐二中的多个有序链表的查找算法么？配图的确画了挺久，不过如果对理解内容有帮助就是值得的。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1587197743,"ip_address":"","comment_id":207835,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1587193954","product_id":100048401,"comment_content":"明白了在多个“有序”链表中查找公共元素的算法，感谢老师通俗易懂的配图！","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492258,"discussion_content":"你指的是加餐二中的多个有序链表的查找算法么？配图的确画了挺久，不过如果对理解内容有帮助就是值得的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587197743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":238120,"discussion_content":"就是这篇文章的配图","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587211744,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":201426,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1585787387,"is_pvip":false,"replies":[{"id":"75353","content":"听你的描述，你们应该是两种查询需求:标签查询和关键词查询。<br>对于“标签查询”，就如你所说的，以标签为key建立倒排索引即可。查询时是直接查询标签。（不过你的问题中说的是“用原始查询词去命中标签”，我的理解是你们有一个“原始查询词转为标签”的功能?）<br>而“关键词查询”，就是你说的“商品名分词”了。这种情况，其实就和我们今天文章中介绍的场景很像。你把商品名看做是一首唐诗就好了。具体做法是:将商品名分词，以每个词为key建立倒排索引。查询时，对于查询词分词，然后拿着每个词作为key去查询这个倒排索引，这样就能把对应的商品找出来了。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1585790570,"ip_address":"","comment_id":201426,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585787387","product_id":100048401,"comment_content":"老师有个当前业务上的疑问，我们有很多商品，从两个维度建立倒排索引：把商品名进行的分词  和  给商品打很多不同的标签。<br>检索的时候，将用户查询词进行分词去命中商品名分词，用原始查询词去命中不同的标签，这种情况一般如何设计？<br>我的理解每一种标签可以单独建立倒排索引，查询后把多个倒排链做归并，那商品名分词如何建索引？","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490329,"discussion_content":"听你的描述，你们应该是两种查询需求:标签查询和关键词查询。\n对于“标签查询”，就如你所说的，以标签为key建立倒排索引即可。查询时是直接查询标签。（不过你的问题中说的是“用原始查询词去命中标签”，我的理解是你们有一个“原始查询词转为标签”的功能?）\n而“关键词查询”，就是你说的“商品名分词”了。这种情况，其实就和我们今天文章中介绍的场景很像。你把商品名看做是一首唐诗就好了。具体做法是:将商品名分词，以每个词为key建立倒排索引。查询时，对于查询词分词，然后拿着每个词作为key去查询这个倒排索引，这样就能把对应的商品找出来了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585790570,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":201285,"user_name":"无形","can_delete":false,"product_type":"c1","uid":1016889,"ip_address":"","ucode":"B740E2A68A17A5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/84/39/c8772466.jpg","comment_is_top":false,"comment_ctime":1585745416,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585745416","product_id":100048401,"comment_content":"期待老师热腾腾的加餐😃","like_count":0},{"had_liked":false,"id":201118,"user_name":"刘凯","can_delete":false,"product_type":"c1","uid":1350608,"ip_address":"","ucode":"EFDC932CAE61A6","user_header":"https://static001.geekbang.org/account/avatar/00/14/9b/d0/86aee34c.jpg","comment_is_top":false,"comment_ctime":1585719161,"is_pvip":false,"replies":[{"id":"75231","content":"其实你已经渐渐掌握了核心原理了！如果你能用数据库那就简单了，因为数据库中的全文索引功能，就是倒排索引的具体实现！<br>你只需要建立一张表，一列是文章id，一列是文章内容，然后指定对文章内容这一列建立全文索引，那接下来就可以用sql语句直接检索了。<br>","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1585721916,"ip_address":"","comment_id":201118,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1585719161","product_id":100048401,"comment_content":"我能想到的方案是在数据库中建两张表，一张保存唯一索引的分词表，一张保存对应分词的文章id，这样是不是弱爆了。这样变成关系型数据库的查找了，而且外键表行数会暴增。脱离了老师说的hash. 老师你说的hash加链表我也看懂了，但持久话如何实现呢","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490245,"discussion_content":"其实你已经渐渐掌握了核心原理了！如果你能用数据库那就简单了，因为数据库中的全文索引功能，就是倒排索引的具体实现！\n你只需要建立一张表，一列是文章id，一列是文章内容，然后指定对文章内容这一列建立全文索引，那接下来就可以用sql语句直接检索了。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585721916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1016889,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/39/c8772466.jpg","nickname":"无形","note":"","ucode":"B740E2A68A17A5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219405,"discussion_content":"用表来存储确实比较大，查询效率也不高\n我之前尝试用文件保存，按\nid|length|value\n的格式来存储分词和文章ID之间的对应关系\nid是分词映射的ID，length是后面value的长度，value也是文章ID按逗号分割的集合\n文件按分词ID排好序，检索时可以根据value跳过大段不必要的查询，效率不错，这个还可以优化，对这个文件再做一层索引，通过二分查找就能快速查到对应的文档集合，性能更高","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585753743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200993,"user_name":"刘凯","can_delete":false,"product_type":"c1","uid":1350608,"ip_address":"","ucode":"EFDC932CAE61A6","user_header":"https://static001.geekbang.org/account/avatar/00/14/9b/d0/86aee34c.jpg","comment_is_top":false,"comment_ctime":1585703647,"is_pvip":false,"replies":[{"id":"75202","content":"“倒排索引”本身不是一个工具，它更多是一种检索思想和技术。因此许多编程语言中没有现成的“倒排索引”，不过我们可以自己实现它:用一个哈希表进行key的查找，然后哈希表中的value存一个数组或链表作为posting list，这样你就可以用任何语言实现倒排索引了。<br>然后，你提到的“盘古分词”，那个是分词工具，类似的分词工具还有许多，比如说jieba，pkuseg，thulac等。<br>你完全可以找一个分词器，然后利用我文章中介绍的构建倒排索引的思路，自己做出来一个倒排索引。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1585705911,"ip_address":"","comment_id":200993,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585703647","product_id":100048401,"comment_content":"老师，这样的倒排索引能介绍一些语言的工具名称吗？我见过的有. net中使用的盘古分词，其他语言有没有","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490203,"discussion_content":"“倒排索引”本身不是一个工具，它更多是一种检索思想和技术。因此许多编程语言中没有现成的“倒排索引”，不过我们可以自己实现它:用一个哈希表进行key的查找，然后哈希表中的value存一个数组或链表作为posting list，这样你就可以用任何语言实现倒排索引了。\n然后，你提到的“盘古分词”，那个是分词工具，类似的分词工具还有许多，比如说jieba，pkuseg，thulac等。\n你完全可以找一个分词器，然后利用我文章中介绍的构建倒排索引的思路，自己做出来一个倒排索引。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585705911,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200954,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1585698982,"is_pvip":false,"replies":[{"id":"75189","content":"1.新建一个倒排索引是不错的方案。除了新建索引，还可以在posting list的记录中加域区分。比如用两个比特位，第一个表示是否是作者，第二个表示是否是内容。你所提到的按作者和内容权重进行打分的方案，用这个方法更容易实现。<br>2.内存放不下，有三个思路:1.通过压缩，全塞进内存；2.放磁盘上，用b+树或分层跳表处理；3.分布式，分片后全放内存。进阶篇中我会介绍这些方案。","user_name":"作者回复","user_name_real":"陈东","uid":"1165703","ctime":1585702603,"ip_address":"","comment_id":200954,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585698982","product_id":100048401,"comment_content":"回答一下问题，支持作者查询其实就和查询内容一样，但是觉得新建哈希表比较合适，这样内容和作者查询在不同的posting list中，分别进行归并，查询完毕后，再根据作者和内容的权重进行打分，将分数最高放在结果首位。<br>我自己也有个问题，如果倒排索引非常大，内存不可能全部载入所有索引，那么如何边取部分索引再归并了？😏","like_count":0,"discussions":[{"author":{"id":1165703,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/87/7a96366d.jpg","nickname":"陈东","note":"","ucode":"97CF7C67D83851","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490193,"discussion_content":"1.新建一个倒排索引是不错的方案。除了新建索引，还可以在posting list的记录中加域区分。比如用两个比特位，第一个表示是否是作者，第二个表示是否是内容。你所提到的按作者和内容权重进行打分的方案，用这个方法更容易实现。\n2.内存放不下，有三个思路:1.通过压缩，全塞进内存；2.放磁盘上，用b+树或分层跳表处理；3.分布式，分片后全放内存。进阶篇中我会介绍这些方案。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585702603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}