{"id":622338,"title":"17｜聚合的实现（下）：怎样用事务保护聚合？","content":"<p>你好，我是钟敬。</p><p><a href=\"https://time.geekbang.org/column/article/621713\">上节课</a>我们完成了<strong>添加员工</strong>的功能，并且实现了关于<strong>技能</strong>和<strong>工作经验</strong>的<strong>不变规则</strong>。今天我们重点要做两件事。第一，是继续完成<strong>修改员工</strong>的功能。</p><p>另外，假如不考虑并发的情况，上节课的逻辑已经足以保证不变规则了。但是正如我们在<a href=\"https://time.geekbang.org/column/article/620047\">第14节课</a>讲聚合概念的时候讨论的，在并发环境下，这些规则仍然可能被破坏。所以今天的第二件事就是用事务来解决这一问题。</p><h2>修改聚合对象</h2><p>上节课，我们在<strong>员工</strong>实体（Emp）里只实现了<strong>添加技能【<strong>addSkill()】的方法。如果要修改员工聚合，我们还要编写</strong>修改技能</strong>和<strong>删除技能</strong>的方法。对于<strong>工作经验</strong>和<strong>岗位</strong>也是一样的。</p><p>我们先看看在领域层实现这些逻辑的代码。</p><pre><code class=\"language-java\">package chapter17.unjuanable.domain.orgmng.emp;\n// imports\n\npublic class Emp extends AuditableEntity {\n    //属性、构造器、其他方法 ...\n\n    public Optional&lt;Skill&gt; getSkill(Long skillTypeId) {\n        return skills.stream()\n                .filter(s -&gt; s.getSkillTypeId() == skillTypeId)\n                .findAny();\n    }\n\n    public void addSkill(Long skillTypeId, SkillLevel level\n                        , int duration, Long userId) {\n        // 上节课已经实现...\n    }\n\n    public Emp updateSkill(Long skillTypeId, SkillLevel level\n                           , int duration, Long userId) {\n        Skill theSkill = this.getSkill(skillTypeId)\n                .orElseThrow(() -&gt; \n                new BusinessException(\"不存在要修改的skillTypeId!\"));\n\n        if (theSkill.getLevel() != level\n            || theSkill.getDuration() != duration) {\n  \n            theSkill.setLevel(level)\n                    .setDuration(duration)\n                    .setLastUpdatedBy(userId)\n                    .setLastUpdatedAt(LocalDateTime.now())\n                    .toUpdate(); //设置修改状态\n        }\n        return this;\n    }\n\n    public Emp deleteSkill(Long skillTypeId) {\n        this.getSkill(skillTypeId)\n                .orElseThrow(() -&gt; new BusinessException(\n                            \"不存在要删除的skillTypeId!\"))\n                .toDelete(); //设置修改状态\n        return this;\n    }\n   \n    public void addExperience(LocalDate startDate, LocalDate endDate, String company, Long userId) {\n        durationShouldNotOverlap(startDate, endDate);\n        // 与Skill的处理类似...\n    }\n\n    public Emp updateExperience(LocalDate startDate, LocalDate endDate, String company, Long userId) {\n        // 与Skill的处理类似...\n    }\n\n    public Emp deleteExperience(LocalDate startDate, LocalDate endDate) {\n        // 与Skill的处理类似...\n    }\n\n    public Emp addEmpPost(String postCode, Long userId) {\n        // 与Skill的处理类似...\n    }\n\n    public Emp deleteEmpPost(String postCode, Long useId) {\n        // 与Skill的处理类似...\n    }\n    \n}\n</code></pre><!-- [[[read_end]]] --><p>我们看一下 updateSkill() 方法。之前说过，我们把<strong>技能类型ID</strong>（SkillTypeId）当作<strong>技能</strong>的局部标识，所以程序里先通过这个ID找到相应的<strong>技能</strong>。</p><p>然后，我们会比较当前<strong>技能</strong>和输入参数中的各个属性值。如果都相同，证明事实上不需要改变，所以什么都不需要做。只有当至少一个值不同时，才对<strong>技能</strong>对象进行修改。修改属性值后，要用上节课写的 toUpdate() 方法来改变<strong>修改状态</strong>(ChangingStatus)。</p><h2>用于修改聚合的应用服务</h2><p>修改完领域对象，我们来完成应用服务。</p><pre><code class=\"language-java\">package chapter17.unjuanable.application.orgmng.empservice;\n// imports ...\n\n@Service\npublic class EmpService {\n    private final EmpRepository empRepository;\n    private final EmpAssembler assembler;\n    private final EmpUpdator updator; //用于修改Emp聚合\n    // 构造器、其他方法...\n\n    @Transactional\n    public EmpResponse updateEmp(Long empId, UpdateEmpRequest request\n                                , User user) {\n        Emp emp = empRepository.findById(request.getTenantId(), empId)\n                .orElseThrow(() -&gt; new BusinessException(\n                        \"Emp id(\" + empId + \") 不正确！\"));\n\n        updator.update(emp, request, user);\n\n        empRepository.save(emp);\n        return assembler.toResponse(emp);\n    }\n\n}\n</code></pre><p>在应用服务里，我们增加了updateEmp()方法，用来修改<strong>员工</strong>聚合。这个方法本身比较简单。首先从数据库中查出当前要修改的<strong>员工</strong>（Emp）, 然后调用updator来对聚合进行更新，最后调用仓库（empRepository）把聚合保存到数据库。</p><p>Updator是我们新写的一个类，在地位上和Assembler是类似的，都是应用服务的Helper。本来Updator的逻辑也可以写在Assembler里，但这样 Assembler就过于庞大了，所以基于关注点分离的原则，我们单独写一个 Updator来完成修改功能。</p><p>下面看看 Updator 的代码。</p><pre><code class=\"language-java\">package chapter17.unjuanable.application.orgmng.empservice;\n// imports ...\n\n@Component\npublic class EmpUpdator {\n    public void update(Emp emp, UpdateEmpRequest request, User user) {\n        emp.setNum(request.getNum())\n                .setIdNum(request.getIdNum())\n                .setDob(request.getDob())\n                .setGender(Gender.ofCode(request.getGenderCode()))\n                .setLastUpdatedAt(LocalDateTime.now())\n                .setLastUpdatedBy(user.getId())\n                .toUpdate();         // 设置修改状态\n\n        updateSkills(emp, request, user.getId());\n        updateExperiences(emp, request, user.getId());\n    }\n\n    //对技能的增删改\n    private void updateSkills(Emp emp, UpdateEmpRequest request\n                              , Long userId) {\n        deleteAbsentSkills(emp, request);\n        operatePresentSkills(emp, request, userId);\n    }\n\n    //删除目前聚合里有，但请求参数里没有的技能\n    private void deleteAbsentSkills(Emp emp, UpdateEmpRequest request) {\n        emp.getSkills().forEach(presentSkill -&gt; {\n            if (request.isSkillAbsent(presentSkill)) {\n                emp.deleteSkill(presentSkill.getSkillTypeId());\n            }\n        });\n    }\n\n    //增加或修改技能\n    private void operatePresentSkills(Emp emp\n                          , UpdateEmpRequest request, Long userId) {\n        for (SkillDto skill : request.getSkills()) {\n            Optional&lt;Skill&gt; skillMaybe = emp.getSkill(\n                                            skill.getSkillTypeId());\n            if(skillMaybe.isPresent()) {\n                emp.updateSkill(skill.getSkillTypeId()\n                        , SkillLevel.ofCode(skill.getLevelCode())\n                        , skill.getDuration()\n                        , userId);\n            } else {\n                emp.addSkill(skill.getSkillTypeId()\n                        , SkillLevel.ofCode(skill.getLevelCode())\n                        , skill.getDuration()\n                        , userId);\n            }\n        }\n\n    }\n    \n    private void updateExperiences(Emp emp, UpdateEmpRequest request\n                                    , Long userId) {\n        // 与updateSkilL()类似...\n    }\n\n}\n</code></pre><p>这里，程序逻辑的起点是update() 方法。它首先修改员工对象的值，并调用 toUpdate()方法设置<strong>修改状态，</strong>然后分别调用另外两个私有方法updateSkills()和updateExperiences()来修改技能和工作经验。我们假定按照业务需求，更改员工的岗位是单独的服务，所以这里没有修改岗位。</p><p>updateSkills() 方法用于修改技能，它包括两步。</p><p><strong>首先是调用 deleteAbsentSkills() 来删除不存在的技能。</strong>逻辑是，比较请求参数（request）和当前员工聚合里的技能。</p><p>如果当前聚合有某个技能，但请求参数里没有，就认为用户希望删除这条技能，所以会调用 emp.deleteSkill() 方法来删除。这时并没有真的在内存里删除，只是修改了技能的修改状态，以便在持久化时在数据库里删除。对于技能是否存在，我们也是通过局部ID （skillTypeId）来判断的。</p><p><strong>第二步，调用operatePresentSkills() 方法来处理请求参数里存在的技能。</strong>如果请求参数里的技能在当前聚合里存在，就更改，否则就增加。由于既可能是更改，也可能是增加，所以方法名用了 operate (操作）。</p><p>对于<strong>工作经验</strong>的修改是类似的，你可以参考前面的讲解自己试试。</p><h2>聚合的查询</h2><p>接下来我们来完成持久层。在EmpService里，有两处调用empRepository和持久层交互。一处是调用empRepository.findById() 根据租户和员工ID查找要修改的员工，另一处是调用empRepository.save()来保存员工聚合。</p><p>咱们先看查询。由于聚合在逻辑上是一个整体，并且我们采用了在聚合内部用对象导航的策略，所以我们会把<strong>员工</strong>实体和从属于它的<strong>技能</strong>、<strong>工作经验</strong>和<strong>岗位</strong>都一次性取到内存。</p><p>乍一看，应该不太复杂，但这里会遇到一个问题。从数据库重建<strong>员工</strong>（Emp）聚合的过程中，当我们调用Emp的一些方法赋值的时候，会触发业务规则的校验。比如说，调用addSkill()增加技能的时候，会触发“技能类型不允许重复”的校验。</p><p>那么重建聚合的时候，是否应该进行这种校验呢？</p><p>这取决于数据的“干净程度”。如果数据库中的数据比较“脏”，也就是说数据库里很多数据已经违反了业务规则，那么，可能在重建聚合时再校验一遍业务规则是可取的，这样可以找出脏数据错误。</p><p>不过多数情况下，数据库是比较干净的。这时候，如果每次从数据库取数据都要校验一遍，就会无谓地影响性能。</p><p>那么怎样绕过这些规则呢？有多种方法。我们的例子里采用这样的技巧：先把 Emp 中的属性都改成 protected 的，然后写一个 Emp 的子类，这个子类中的方法也可以设置 Emp 的值，但是不调用业务规则，这样就达到了绕过业务规则的目的。</p><p>下面是这个子类的代码。</p><pre><code class=\"language-java\">//这个类位于适配器包\npackage chapter17.unjuanable.adapter.driven.persistence.orgmng;\n//imports...\n\npublic class RebuiltEmp extends Emp {\n    RebuiltEmp(Long tenantId, Long id, LocalDateTime create_at, long created_by) {\n        super(tenantId, id, create_at, created_by);\n        //由于是从数据库重建，所以状态默认为\"不变\"\n        this.changingStatus = ChangingStatus.UNCHANGED; \n    }\n\n    //包级权限，并且用 resetXxx 命名\n    RebuiltEmp resetOrgId(Long orgId) {\n        this.orgId = orgId;\n        return this;\n    }\n\n    RebuiltEmp resetNum(String num) {\n        this.num = num;\n        return this;\n    }\n\n    RebuiltEmp resetIdNum(String idNum) {\n        this.idNum = idNum;\n        return this;\n    }\n\n    RebuiltEmp resetName(String name) {\n        this.name = name;\n        return this;\n    }\n\n    RebuiltEmp resetGender(Gender gender) {\n        this.gender = gender;\n        return this;\n    }\n\n    RebuiltEmp resetDob(LocalDate dob) {\n        this.dob = dob;\n        return this;\n    }\n\n    RebuiltEmp resetStatus(EmpStatus status) {\n        this.status = status;\n        return this;\n    }\n\n    // 用 reAddXxx 命名\n    public RebuiltEmp reAddSkill(Long id, Long skillTypeId, SkillLevel level, int duration, Long createdBy) {\n\n        RebuiltSkill newSkill = new RebuiltSkill(tenantId, id, skillTypeId, createdBy)\n                .resetLevel(level)\n                .resetDuration(duration);\n\n        skills.add(newSkill);\n        return this;\n    }\n\n    public RebuiltEmp reAddExperience(LocalDate startDate, LocalDate endDate, String company, Long userId) {\n        // ...\n    }\n\n    public RebuiltEmp reAddEmpPost(String postCode, Long userId) {\n        // ...\n    }\n\n}\n</code></pre><p>首先，这个子类和<strong>员工仓库</strong>的实现（EmpRepositoryJdbc）放在同一个包，类中的方法都是包级私有的，也就是说，只有<strong>员工仓库</strong>的实现类可以访问，从而避免了这个包外部的其他类绕过业务规则。</p><p>这个类的名字是RebuiltEmp，也就是“重建的”<strong>员工</strong>。对应于父类（Emp）里的 setXxx() 方法，这里我们setter用resetXxx() 来命名，以示区别。类似地，我们也用reAddXxx()来增加<strong>技能</strong>、<strong>工作经验</strong>和<strong>岗位</strong>。另外，这些方法都返回 RebuildEmp 对象本身，以便对这个对象进行链式操作。</p><p>有了这个子类，我们就可以实现仓库了。</p><pre><code class=\"language-java\">package chapter17.unjuanable.adapter.driven.persistence.orgmng;\n// imports...\n\n\n@Repository\npublic class EmpRepositoryJdbc implements EmpRepository {\n   //声明 JdbcTemplate 和各个 SimpleJdbcInsert ...\n   // 构造器、其他方法 ...\n\n    @Override\n    public Optional&lt;Emp&gt; findById(Long tenantId, Long id) {\n        Optional&lt;RebuiltEmp&gt; empMaybe = retrieveEmp(tenantId, id);\n        if (empMaybe.isPresent()) {\n            RebuiltEmp emp = empMaybe.get();\n            retrieveSkills(emp);\n            retrieveExperiences(emp);\n            retrievePosts(emp);\n            return Optional.of(emp);\n        } else {\n            return Optional.empty();\n        }\n    }\n\n    private Optional&lt;RebuiltEmp&gt; retrieveEmp(Long tenantId, Long id) {\n        String sql = \" select org_id, num, id_num, name \"\n                + \" , gender_code, dob, status_code \"\n                + \" from emp \"\n                + \" where id = ? and tenant_id = ? \";\n\n        RebuiltEmp emp = jdbc.queryForObject(sql,\n                (rs, rowNum) -&gt; {\n                    RebuiltEmp newEmp = new RebuiltEmp(tenantId\n                            , id\n                            , rs.getTimestamp(\"create_at\").toLocalDateTime()\n                            , rs.getLong(\"created_by\"));\n\n                    newEmp.resetOrgId(rs.getLong(\"org_id\"))\n                          .resetNum(rs.getString(\"num\"))\n                          .resetIdNum(rs.getString(\"id_num\"))\n                          .resetName(rs.getString(\"name\"))\n                          .resetGender(Gender.ofCode(\n                                    rs.getString(\"gender_code\")))\n                          .resetDob(rs.getDate(\"dob\").toLocalDate())\n                          .resetStatus(EmpStatus.ofCode(\n                                      rs.getString(\"status_code\")));\n                    return newEmp;\n                },\n                id, tenantId);\n                \n        return Optional.ofNullable(emp);\n    }\n\n    private void retrieveSkills(RebuiltEmp emp) {\n        String sql = \" select id, tenant_id, skill_type_id, level, duration \"\n                + \" from skill \"\n                + \" where tenant_id = ? and emp_id = ? \";\n\n        List&lt;Map&lt;String, Object&gt;&gt; skills = jdbc.queryForList(\n                                sql, emp.getTenantId(), emp.getId());\n\n        skills.forEach(skill -&gt; emp.reAddSkill(\n                    (Long) skill.get(\"id\")\n                    , (Long) skill.get(\"skill_type_id\")\n                    , SkillLevel.ofCode((String) skill.get(\"level_code\"))\n                    , (Integer) skill.get(\"duration\")\n                    , (Long) skill.get(\"created_by\")\n        });\n\n    }\n\n    private void retrieveExperiences(RebuiltEmp emp) {\n        //与retrieveSkill 类似 ...\n    }\n\n    private void retrievePosts(RebuiltEmp emp) {\n        //与retrieveSkill 类似 ...\n    }\n}\n</code></pre><p>FindById() 方法首先会从数据库重建 Emp 对象本身，然后分别重建<strong>技能</strong>、<strong>工作经验</strong>和<strong>岗位</strong>。与数据库直接打交道的方法，用 retrieveXxx() 来命名，以便和更上层的 FindByXxx() 相区别。</p><h2>对修改的聚合进行持久化</h2><p>完成了查询功能，我们来看怎样把修改后的聚合存入数据库。无论新增还是修改聚合，我们都可以用同一个empRepository.save()方法 ，所以我们要修改之前课程中的这个方法。</p><pre><code class=\"language-java\">package chapter17.unjuanable.adapter.driven.persistence.orgmng;\n// imports ...\n\n@Repository\npublic class EmpRepositoryJdbc implements EmpRepository {\n\n    final JdbcTemplate jdbc;\n    final SimpleJdbcInsert empInsert;\n    final SimpleJdbcInsert skillInsert;\n    final SimpleJdbcInsert WorkExperienceInsert;\n    final SimpleJdbcInsert empPostInsert;\n\n    @Autowired\n    public EmpRepositoryJdbc(JdbcTemplate jdbc) {\n        this.jdbc = jdbc;\n        this.empInsert = new SimpleJdbcInsert(jdbc)\n                .withTableName(\"emp\")\n                .usingGeneratedKeyColumns(\"id\");\n        //初始化其他 SimpleJdbcInsert ...\n    }\n\n    @Override\n    public void save(Emp emp) {\n        saveEmp(emp);\n        emp.getSkills().forEach(s -&gt; saveSkill(emp, s));\n        emp.getExperiences().forEach(e -&gt; saveWorkExperience(emp, e));\n        emp.getEmpPosts().forEach(p -&gt; saveEmpPost(emp, p));\n    }\n\n    private void saveEmp(Emp emp) {\n        switch (emp.getChangingStatus()) {\n            case NEW:\n                insertEmpRecord(emp);\n                break;\n            case UPDATED:\n                updateEmpRecord(emp);\n                break;\n        }\n    }\n\n    private void insertEmpRecord(Emp emp) {\n        Map&lt;String, Object&gt; parms = Map.of(\n                \"tenant_id\", emp.getTenantId()\n                , \"org_id\", emp.getOrgId()\n                , \"num\", emp.getNum()\n                , \"id_num\", emp.getIdNum()\n                , \"name\", emp.getName()\n                , \"gender\", emp.getGender().code()\n                , \"dob\", emp.getDob()\n                , \"status\", emp.getStatus().code()\n                , \"created_at\", emp.getCreatedAt()\n                , \"created_by\", emp.getCreatedBy()\n        );\n\n        Number createdId = empInsert.executeAndReturnKey(parms);\n\n        forceSet(emp, \"id\", createdId.longValue());\n    }\n\n    private void updateEmpRecord(Emp emp) {\n        String sql = \"update emp \" +\n                \" set org_id = ?\" +\n                \", num = ?\" +\n                \", id_num =? \" +\n                \", name = ?\" +\n                \", gender =?\" +\n                \", dob = ?\" +\n                \", status =?\" +\n                \", last_updated_at =?\" +\n                \", last_updated_by =? \" +\n                \" where tenant_id = ? and id = ? \";\n        this.jdbc.update(sql\n                , emp.getOrgId()\n                , emp.getNum()\n                , emp.getIdNum()\n                , emp.getName()\n                , emp.getGender().code()\n                , emp.getDob()\n                , emp.getStatus()\n                , emp.getLastUpdatedAt()\n                , emp.getLastUpdatedBy()\n                , emp.getTenantId()\n                , emp.getId());\n    }\n\n    private void saveSkill(Emp emp, Skill skill) {\n        switch (skill.getChangingStatus()) {\n            case NEW:\n                insertSkillRecord(skill, emp.getId());\n                break;\n            case UPDATED:\n                updateSkillRecord(skill);\n                break;\n            case DELETED:\n                deleteSkillRecord(skill);\n                break;\n\n        }\n    }\n\n    private void insertSkillRecord(Skill skill, Long empId) {\n        Map&lt;String, Object&gt; parms = Map.of(\n            \"emp_id\", empId,\n            \"tenant_id\", skill.getTenantId(),\n            \"skill_type_id\", skill.getSkillTypeId(),\n            \"level_code\", skill.getLevel().code(),\n            \"duration\", skill.getDuration(),\n            \"created_at\", skill.getCreatedAt(),\n            \"created_by\", skill.getCreatedBy()\n            );\n\n        Number createdId = skillInsert.executeAndReturnKey(parms);\n\n        forceSet(skill, \"id\", createdId.longValue());\n    }\n\n    private void updateSkillRecord(Skill skill) {\n        String sql = \"update skill \" \n                    + \" set level_code = ?\" \n                    + \", duration = ?\" \n                    + \", last_updated_at = ?\" \n                    + \", last_updated_by = ?\" \n                    + \" where tenant_id = ? and id = ? \";\n        this.jdbc.update(sql\n                , skill.getSkillTypeId()\n                , skill.getDuration()\n                , skill.getLastUpdatedAt()\n                , skill.getLastUpdatedBy()\n                , skill.getTenantId()\n                , skill.getId());\n    }\n\n\n    private void deleteSkillRecord(Skill skill) {\n        this.jdbc.update(\"delete from skll where tenant_id = ? \"\n                       + \" and id = ?\"\n                , skill.getTenantId()\n                , skill.getId());\n    }\n\n    private void saveWorkExperience(Emp emp, WorkExperience e) {\n        // 与 saveSkill( ) 类似...\n    }\n\n    private void saveEmpPostRecord(Emp emp, EmpPost p) {\n        // 与 saveSkill( ) 类似...\n    }\n\n}\n</code></pre><p>save()方法先调用saveEmp()方法，根据<strong>员工</strong>对象的修改状态（changingStatus），来插入或更新emp表，然后用同样的逻辑循环处理<strong>技能</strong>、<strong>工作经验</strong>和<strong>岗位</strong>。</p><p>我们假定将来会写专门的removeEmp()方法删除整个聚合，所以目前的 saveEmp()中没有处理删除的情况。另外，对于直接操作数据库的类，我们用 insertXxxRecord()的方式的命名，与更上一层的saveXxx()方法相区别。</p><h2>用事务保证固定规则</h2><p>完成了修改聚合的基本功能后，我们来考虑避免并发情况下破坏不变规则的问题。我们在第14节课已经讲过，需要把对聚合的修改封装到一个事务中去，这样，一个人修改完以后，另一个人才能修改，从而避免并发修改的问题。那么具体怎么做呢？</p><p>首先，我们要考虑一个问题，仅仅靠数据库事务，是无法完成这一任务的，需要自己编写一些代码来完成。这种比数据库事务“高一级”的事务，我们可以称为“业务事务”（Business Transaction）。业务事务一般要使用乐观锁或者悲观锁的机制。</p><p>悲观锁指的是，只要一个人开始修改操作，就为数据加锁，其他人根本不可能同步修改。乐观锁指的是，两个人可以同时操作，但最后保存到数据库的时候，先保存的那个人成功，后保存的那个人失败，只能重新进行操作。</p><p>我们这里选择乐观锁。对于聚合的情况而言，实际上是通过锁聚合根，来把整个聚合锁住。我们一步一步地看一看做法。</p><p>第一步，要在聚合根的代码和数据表里增加一个<strong>版本</strong>（version）字段，类型可以是长整型。由于多数聚合都要考虑加锁，所以我们为聚合根写一个父类，这个类又是AuditableEntity的子类。后面是具体代码。</p><pre><code class=\"language-plain\">package chapter17.unjuanable.common.framework.domain;\n\nimport java.time.LocalDateTime;\n\npublic class AggregateRoot extends AuditableEntity {\n    protected Long version;\n\n    public AggregateRoot(LocalDateTime createdAt, Long createdBy) {\n        super(createdAt, createdBy);\n    }\n\n    public Long getVersion() {\n        return version;\n    }\n}\n</code></pre><p>Emp原来继承的是AuditableEntity, 现在改为继承AggregateRoot，其他部分不需要修改。这样，Emp就有了version属性。</p><pre><code class=\"language-plain\">public class Emp extends AggregateRoot {\n  //...\n}\n</code></pre><p>第二步，修改EmpRepository中的 findById() 方法，在取数据的时候，把Emp 的verion值也取出来。逻辑比较简单，这里就不列代码了。</p><p>第三步，是在update Emp表的时候，修改SQL语句，这一步是最关键的，我们先看代码。</p><pre><code class=\"language-plain\">package chapter17.unjuanable.adapter.driven.persistence.orgmng;\n// imports ...\n\n@Repository\npublic class EmpRepositoryJdbc implements EmpRepository {\n\n    // 声明 JdbcTemplate, SimpleJdbcInsert empInsert ...\n    // 构造器，其他方法不变 ...\n   \n    @Override\n    public boolean save(Emp emp) {\n        if (saveEmp(emp)) {\n            emp.getSkills().forEach(s -&gt; saveSkill(emp, s));\n            emp.getExperiences().forEach(e -&gt; saveWorkExperience(emp, e));\n            emp.getEmpPosts().forEach(p -&gt; saveEmpPost(emp, p));\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    private boolean saveEmp(Emp emp) {\n        switch (emp.getChangingStatus()) {\n            case NEW:\n                insertEmpRecord(emp);\n                break;\n            case UPDATED:\n                if(!updateEmpRecord(emp)) {\n                    return false;\n                }\n                break;\n        }\n        return true;\n    }\n\n    private void insertEmpRecord(Emp emp) {\n       // 代码不变 ...\n    }\n\n    // 注意：SQL语句中增加了两处关于 version 的修改\n    private boolean updateEmpRecord(Emp emp) {\n        String sql = \"update emp \" +\n                \" set version = version + 1 \" +\n                \", org_id = ?\" +\n                \", num = ?\" +\n                \", id_num =? \" +\n                \", name = ?\" +\n                \", gender =?\" +\n                \", dob = ?\" +\n                \", status =?\" +\n                \", last_updated_at =?\" +\n                \", last_updated_by =? \" +\n                \" where tenant_id = ? and id = ? and version = ?\";\n        int affected = this.jdbc.update(sql\n                , emp.getOrgId()\n                , emp.getNum()\n                , emp.getIdNum()\n                , emp.getName()\n                , emp.getGender().code()\n                , emp.getDob()\n                , emp.getStatus()\n                , emp.getLastUpdatedAt()\n                , emp.getLastUpdatedBy()\n                , emp.getTenantId()\n                , emp.getId()\n                , emp.getVersion());\n\n        return affected == 1 ? true : false;\n    }\n\n    // 其他方法不变 ...\n}\n</code></pre><p>这里重点是updateEmpRecord() 方法里SQL语句的变化。SQL语句里增加了两处关于version的修改，其他部分不变。</p><pre><code class=\"language-plain\"> update emp set version = version + 1 \n ...\n where  version = &lt;当前Emp中的version值&gt;\n</code></pre><p>也就是说，根据当前Emp里的version值，找到记录，然后把version值加 1 。</p><p>我们想象一下，两个人几乎同时修改<strong>员工</strong>，但最后 update 语句的执行总有一个先后。</p><p>先update的人是可以根据原来的version值取到记录的，因为这时 version 值还没变。而后update的人，由于数据库里的version值已经被刚才的人加1了，所以无法通过原来的version找到记录，会导致更新失败，也就不会破坏业务规则。这就是乐观锁的诀窍。</p><p>我们再看回updateEmpRecord()方法，它的返回值由原来的void改成了 boolean，表示修改是否成功。update语句执行后，会返回被update的记录数量。如果返回为1，证明修改成功，则这个方法返回true；如果返回0 ，说明修改失败，也就是已经被别人抢先修改了，这时返回false。</p><p>调用updateEmpRecord()的saveEmp()和再上层的save()的返回值也都改成了 boolean。updateEmpRecord()的成功状态经由saveEmp()返回给save() 。save()方法只有在保存<strong>员工</strong> 成功的时候才进一步保存<strong>技能</strong>、<strong>工作经验</strong>和<strong>岗位</strong>，否则，不会继续操作，而是返回false。</p><p>而save()方法又是由应用服务EmpService()调用的。EmpService()的代码如下。</p><pre><code class=\"language-plain\">package chapter17.unjuanable.application.orgmng.empservice;\n// imports ...\n\n@Service\npublic class EmpService {\n    // 依赖注入、构造器、其他方法 ...\n\n    @Transactional\n    public EmpResponse updateEmp(Long empId, UpdateEmpRequest request\n                              , User user) {\n        Emp emp = empRepository.findById(request.getTenantId(), empId)\n                .orElseThrow(() -&gt; new BusinessException(\n                        \"Emp id(\" + empId + \") 不正确！\"));\n\n        updator.update(emp, request, user);\n\n        // 这里增加了判断\n        if(!empRepository.save(emp)) {\n            throw new BusinessException(\n                          \"这个员工已经被其他人同时修改了，请重新修改！\");\n        };\n        return assembler.toResponse(emp);\n    }\n\n}\n</code></pre><p>EmpService 的updateEmp() 方法会判断保存是否成功，如果不成功，则可推断出是其他人抢先修改了，于是抛出异常，提示当前用户重新修改。</p><h2>单实体聚合</h2><p>现在，我们已经完成了聚合代码的编写。最后再讨论一个问题：有些实体，既不是聚合根，也不从属于任何聚合，例如上个迭代讲过的组织（Org）实体，对于这些实体该怎么处理呢？</p><p>我们建议，把这种“游离”的实体看做一种“退化”的聚合，也就是说，它们也是聚合，只不过只有聚合根，没有“儿子”，可以称为“单实体聚合”。</p><p>比如说，<strong>组织</strong>实体就构成了一个单实体聚合，它本身就是聚合根，在代码层面可以和普通聚合一样处理。也就是说，这些实体也在自己单独的包内，这个包里面通常包括仓库的接口，有时还包括工厂和领域服务。事实上，上个迭代对<strong>组织</strong>的处理，就是这么做的。</p><p>但是在领域模型图里，如果把每个单实体聚合外面都套一个“包”的话，模型图就显得太凌乱了，所以在模型图上就没有必要为单独的实体加上包了。这时，模型和代码稍微有些不一致，算是一种妥协吧。</p><h2>总结</h2><p>好，这节课的主要内容就讲完了，下面我们来总结一下。今天主要解决的是聚合的修改，以及在并发环境下保护聚合不变规则的问题。</p><p>对于聚合的修改，有以下要点。</p><p>第一，在修改之前，要把聚合从数据库里取出来。为了这个目的，仓库要把聚合的数据整体装入内存，并重建聚合。这里我们还用了一个技巧，在仓库包里建立了聚合根的一个子类，从而绕过校验规则，避免不必要的性能损耗。</p><p>第二，要在领域层的聚合根里增加对技能、工作经验和岗位的更改和删除代码，并为这些对象设置合适的修改状态，从而把非聚合根对象的修改逻辑封装起来。</p><p>第三，在应用层把当前聚合与请求参数进行对比，确定对聚合里的各个对象应该进行增、删、改，还是保持不变。然后，调用聚合根来进行相应的操作。</p><p>最后，为了把聚合存入数据库，仓库要遍历聚合中的各个对象，根据对象的更改状态进行合适的数据库操作。</p><p>完成了聚合的修改以后，我们展示了怎样用乐观锁保护聚合的事务边界，避免并发操作对不变规则的破坏。此外，我们还讨论了单实体聚合的处理。</p><p>在介绍聚合概念的那节课里，我们讲了聚合的两大特征：一个是<strong>概念上的整体性</strong>；另一个是<strong>维护不变规则的要求</strong>。在这三节课，你应该能体会到怎样从代码层面实现这些聚合的特征了吧。</p><p>还有一点要注意，尽管我们目前选择的是偏过程式的编码风格，但是也会尽量实现封装、继承等面向对象编程的特征，这一点也是要着重体会的。</p><h2>思考题</h2><p>1.我们在重建聚合时，采用了编写聚合子类的方式绕过业务规则的校验，你还能想到其他方法吗？</p><p>2.如果用悲观锁的话，应该怎样实现？</p><p>好，今天的课程结束了，有什么问题欢迎在评论区留言，下节课，我们开始讲解值对象和其他一些建模技巧。</p>","comments":[{"had_liked":false,"id":372659,"user_name":"Hesher","can_delete":false,"product_type":"c1","uid":1026832,"ip_address":"北京","ucode":"99AB8B1704CB7E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ab/10/b812ff3e.jpg","comment_is_top":false,"comment_ctime":1681426595,"is_pvip":false,"replies":[{"id":136132,"content":"1、是个办法。此外还可以做一个专用于重建的Builder，或者用反射，\n2、这个没错","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1681633255,"ip_address":"广东","comment_id":372659,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"回答下课后问题：\n1. 业务校验可以加一个标志位判断是否是重建，重建就跳过校验；\n2. 悲观锁就是分布式锁或者数据库select for update，建议用分布式锁。","like_count":5,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":614014,"discussion_content":"1、是个办法。此外还可以做一个专用于重建的Builder，或者用反射，\n2、这个没错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681633255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2275516,"avatar":"https://static001.geekbang.org/account/avatar/00/22/b8/bc/5f4c9cb2.jpg","nickname":"掂过碌蔗","note":"","ucode":"6D9080A2B225AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":641169,"discussion_content":"分布式锁要放哪呢？通过一个领域服务封装分布式锁的逻辑，然后应用逻辑里面调用领域服务获取分布式锁的逻辑吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1712291808,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":614014,"ip_address":"广东","group_id":0},"score":641169,"extra":""}]}]},{"had_liked":false,"id":371949,"user_name":"杰","can_delete":false,"product_type":"c1","uid":1109562,"ip_address":"广东","ucode":"036B010A45070A","user_header":"https://static001.geekbang.org/account/avatar/00/10/ee/3a/c0ad9c43.jpg","comment_is_top":false,"comment_ctime":1680536677,"is_pvip":false,"replies":[{"id":135706,"content":"员工和组织不存在“强”的整体部分关系。比如，一个员工，可能属于多个组织，一个组织删除了，不代表下面的员工也会被删除。相反，订单和订单项是聚合。你可以体会一下。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1680573754,"ip_address":"广东","comment_id":371949,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"老师，组织Org里面包含了多个员工Emp，为什么不可以理解为组合和员工构成一个聚合，组织是聚合根，而员工是实体呢？","like_count":5,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612187,"discussion_content":"员工和组织不存在“强”的整体部分关系。比如，一个员工，可能属于多个组织，一个组织删除了，不代表下面的员工也会被删除。相反，订单和订单项是聚合。你可以体会一下。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1680573754,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1004357,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/45/8c0eb589.jpg","nickname":"D调的暖冬","note":"","ucode":"A7DE4F80470970","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":639661,"discussion_content":"准确的说员工和组织在业务上只是一种丛属关系或者说逻辑关系，组织不负责对员工生命周期的管理，当一个人加入组织成为员工后，就具有不一样的职责了。其次组织其实和员工并没有很强的变更一致性问题，只有组织删除情况下员工可能要删除这种极少且业务上基本不会这样做的逻辑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1710816998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2755603,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/FyiaSFQ7wBCswIyD36Tu0RrlmeibDonxzd6czxGack8EjGEwws3uwH5QkrUQJq0AgK2a0mjyziblVZ9aVMr674Saw/132","nickname":"Geek_31faab","note":"","ucode":"DCCA43626506A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":617148,"discussion_content":"同理，记录和记录快照也不存在“强”的整体部门关系对吗？一个记录删掉，不代表他的历史记录也会被删掉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1683348620,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366252,"user_name":"张逃逃","can_delete":false,"product_type":"c1","uid":1435550,"ip_address":"北京","ucode":"DBF3A573CDF7DB","user_header":"https://static001.geekbang.org/account/avatar/00/15/e7/9e/5853da22.jpg","comment_is_top":false,"comment_ctime":1673511397,"is_pvip":false,"replies":[{"id":133674,"content":"你说的也是一种可行的做法。Evans认为，如果构造器太复杂，就掩盖了对象的主要职责，所以这时候倾向于把构造的职责抽出来。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1674451583,"ip_address":"广东","comment_id":366252,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"有个疑问想请教老师，为什么EmpRepository在查找Emp的时候不把对应Emp的所有状态(包括技能，工作经验...)全部查出来，然后通过Emp的构造参数来实例化对象，而是先实例化对象再调用addSkill()等方法来初始化，如果用构造方法来实例化对象，好像就不需要RebuiltEmp了。","like_count":4,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600501,"discussion_content":"你说的也是一种可行的做法。Evans认为，如果构造器太复杂，就掩盖了对象的主要职责，所以这时候倾向于把构造的职责抽出来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674451584,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1336475,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/9b/d1ab239e.jpg","nickname":"J.Smile","note":"","ucode":"C4D98DFDBF7584","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":646493,"discussion_content":"小伙子你很优秀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1718109222,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1588683,"avatar":"https://static001.geekbang.org/account/avatar/00/18/3d/cb/791d0f5e.jpg","nickname":"猴哥","note":"","ucode":"63A1BFDF13D85D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1336475,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/9b/d1ab239e.jpg","nickname":"J.Smile","note":"","ucode":"C4D98DFDBF7584","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":649894,"discussion_content":"你小子也不错！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1724120186,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":646493,"ip_address":"浙江","group_id":0},"score":649894,"extra":""}]}]},{"had_liked":false,"id":370980,"user_name":"远天","can_delete":false,"product_type":"c1","uid":1235735,"ip_address":"浙江","ucode":"406E3D19A945C9","user_header":"https://static001.geekbang.org/account/avatar/00/12/db/17/aee5d35a.jpg","comment_is_top":false,"comment_ctime":1679419498,"is_pvip":false,"replies":[{"id":135342,"content":"好问题。\n关于分页查询，参考迭代三的CQRS。\n关于成百上千个技能，这时候建议不把员工和技能作为同一个聚合，而是把每个技能作为单独的聚合。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1679456508,"ip_address":"广东","comment_id":370980,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"老师您好，这里的查询是只查询一个员工，如果分页查询多个员工，先查询出员工，再组装每个员工的技能和经验吗？还有一种极端情况，假如员工的技能有很多，成百上千个，也要一次性查出吗，是否有性能问题？","like_count":2,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":610212,"discussion_content":"好问题。\n关于分页查询，参考迭代三的CQRS。\n关于成百上千个技能，这时候建议不把员工和技能作为同一个聚合，而是把每个技能作为单独的聚合。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679456508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1042953,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/HibtYWgbgTKZPTkqEGvB0pIyFfrhiaKrEkWTgPa9EYFsH7VV2an6oXPCvLzqOb1KfsNN8flQuRUWo0WntI5M1iapw/132","nickname":"tony","note":"","ucode":"41DB69A6D93D26","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":613645,"discussion_content":"如果把技能单独作为聚合，不就违背你前面讲的整体部分与不可变规则了么？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1681438702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":610212,"ip_address":"重庆","group_id":0},"score":613645,"extra":""}]}]},{"had_liked":false,"id":387810,"user_name":"Spoon","can_delete":false,"product_type":"c1","uid":1959822,"ip_address":"浙江","ucode":"2FF9193AD482C2","user_header":"https://static001.geekbang.org/account/avatar/00/1d/e7/8e/318cfde0.jpg","comment_is_top":false,"comment_ctime":1708607486,"is_pvip":false,"replies":[{"id":141257,"content":"有道理","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1708760260,"ip_address":"广东","comment_id":387810,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"select for update不是一种很好的悲观锁方式，当A事务执行时，其他事务都在等待，占用数据库链接，数据库链接是一个很宝贵的资源，而且等待对于用户来说也是一种很不好的体验，还可能会有死锁的风险","like_count":1,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":637655,"discussion_content":"有道理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1708760260,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":380083,"user_name":"Felix","can_delete":false,"product_type":"c1","uid":1204355,"ip_address":"广东","ucode":"70F807E954C20D","user_header":"https://static001.geekbang.org/account/avatar/00/12/60/83/1b3f3056.jpg","comment_is_top":false,"comment_ctime":1692936812,"is_pvip":false,"replies":[{"id":138434,"content":"在 application service 层有 @Transactional 注释，所以是在同一个事务。难道我在代码中漏了？","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1693058307,"ip_address":"广东","comment_id":380083,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"saveEmp(emp); \nemp.getSkills().forEach(s -&gt; saveSkill(emp, s)); \nemp.getExperiences().forEach(e -&gt; saveWorkExperience(emp, e)); \nemp.getEmpPosts().forEach(p -&gt; saveEmpPost(emp, p));\n有个疑问，这几个save执行的sql都在一个数据库事务里的吗？没看见有显式声明，不清楚有没有","like_count":1,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":626529,"discussion_content":"在 application service 层有 @Transactional 注释，所以是在同一个事务。难道我在代码中漏了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1693058307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":377774,"user_name":"Johar","can_delete":false,"product_type":"c1","uid":1101969,"ip_address":"重庆","ucode":"834136A6F64CDC","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/91/89123507.jpg","comment_is_top":false,"comment_ctime":1689171041,"is_pvip":false,"replies":[{"id":137725,"content":"3. 可以拆开。目前实际上共享了Emp中的一把锁（version字段），如果拆开，需要用多把锁。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1689501916,"ip_address":"","comment_id":377774,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"1. 我们在重建聚合时，采用了编写聚合子类的方式绕过业务规则的校验，你还能想到其他方法吗？\n直接在mybatis sql中将关联的实体查询出来，就不需要再单独实现了\n2. 如果用悲观锁的话，应该怎样实现？\n一般场景使用select *** for update，若是微服务要考虑使用分布式锁。\n3.请教一下老师，目前在更新技能，工作经验，员工信息都在一起，要是更新场景频繁，是不是可以拆开单独更新，减小锁的范围？此外更新逻辑里面没有检验更新人的权限","like_count":1,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":623457,"discussion_content":"3. 可以拆开。目前实际上共享了Emp中的一把锁（version字段），如果拆开，需要用多把锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1689501916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":377320,"user_name":"苏籍","can_delete":false,"product_type":"c1","uid":1396252,"ip_address":"浙江","ucode":"4FA289E084B789","user_header":"https://static001.geekbang.org/account/avatar/00/15/4e/1c/e08a3d9e.jpg","comment_is_top":false,"comment_ctime":1688344403,"is_pvip":false,"replies":[{"id":137721,"content":"1 之所以总是更新Emp，是因为乐观锁（version字段）放在了 Emp 上。如果不想更新Emp，可以另外找一个地方放乐观锁。\n2. 目前EmpUpdator用到了DTO，如果直接放到领域层，分层架构的依赖关系就错了，如果一定要放到领域层，那么可以在领域层再定义一层DTO。另外，EmpUpdator 并不是典型的领域逻辑，课程里应该说过，需要和领域专家聊的逻辑才是领域逻辑。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1689501679,"ip_address":"","comment_id":377320,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"老师好，有几个困惑，想请教一下\n1. 关于聚合中有多个实体，比如Emp 中有 skill 和 经验， 在实际场景中，业务场景上只需要更新 skill，在操作数据库时候，有必要Emp也更新吗（我看示例代码上 写的 保存完Emp 再去保存skill），我只更新skill 是否可行呢 或者我能够在领域层提供一个修改skill的领域服务。\n2. 我看前面UpdateEmp方法执行之前，进行变更Emp和skill 属性的操作的 EmpUpdator 是放在应用层的，我理解是不是应该放在领域层呢，首先因为实体属性的变更 本身应该是某个业务规则触发的，在某个业务规则下才能修改某些属性以及联动修改skill 这种应该属于领域逻辑吧。 另外聚合本身后续可能会拆解成微服务，如果这种写到应用层，不利于后续拆分","like_count":1,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":623453,"discussion_content":"1 之所以总是更新Emp，是因为乐观锁（version字段）放在了 Emp 上。如果不想更新Emp，可以另外找一个地方放乐观锁。\n2. 目前EmpUpdator用到了DTO，如果直接放到领域层，分层架构的依赖关系就错了，如果一定要放到领域层，那么可以在领域层再定义一层DTO。另外，EmpUpdator 并不是典型的领域逻辑，课程里应该说过，需要和领域专家聊的逻辑才是领域逻辑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1689501679,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1588683,"avatar":"https://static001.geekbang.org/account/avatar/00/18/3d/cb/791d0f5e.jpg","nickname":"猴哥","note":"","ucode":"63A1BFDF13D85D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":649897,"discussion_content":"**mark**：“需要和领域专家聊的逻辑才是领域逻辑”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1724120864,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":373616,"user_name":"许勇","can_delete":false,"product_type":"c1","uid":1527200,"ip_address":"北京","ucode":"20A6EA5A539DC3","user_header":"https://static001.geekbang.org/account/avatar/00/17/4d/a0/e547b7a1.jpg","comment_is_top":false,"comment_ctime":1682785368,"is_pvip":false,"replies":[{"id":136594,"content":"保存emp后，Skill前，emp表里的version号已经变了，所以，另一个操作是无法去修改emp的","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1683295954,"ip_address":"广东","comment_id":373616,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"感觉用乐观锁还是会有问题的，比如保存emp后，skill前，有另一个操作去修改emp，这时数据库里的skill还不是最新的，这会导致skill数据不一致。","like_count":1,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":617076,"discussion_content":"保存emp后，Skill前，emp表里的version号已经变了，所以，另一个操作是无法去修改emp的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1683295955,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1304009,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e5/c9/36fdec8e.jpg","nickname":"liuq","note":"","ucode":"88437D66C547C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":652775,"discussion_content":"原来如此","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1729608144,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366885,"user_name":"iam593","can_delete":false,"product_type":"c1","uid":1127763,"ip_address":"湖南","ucode":"D787F695AF4056","user_header":"https://static001.geekbang.org/account/avatar/00/11/35/53/24b8c826.jpg","comment_is_top":false,"comment_ctime":1674530215,"is_pvip":false,"replies":[{"id":134795,"content":"是的，都有这些字段。至于要不要这么做，取决于你的权衡。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1677939008,"ip_address":"广东","comment_id":366885,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"继承于AuditableEntity的对象，在数据库中对应的表都有创建者、创建时间、修改者、修改时间等字段？从数据库层面看，这样会不会有点繁琐？","like_count":1,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":607557,"discussion_content":"是的，都有这些字段。至于要不要这么做，取决于你的权衡。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1677939008,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366233,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"江苏","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1673495254,"is_pvip":false,"replies":[{"id":133661,"content":"第一点，关键是从数据库查到值以后，怎么构建领域对象。第二点，确实是悲观锁的可行做法。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1674447795,"ip_address":"广东","comment_id":366233,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"1.能直接从数据库中查询值构造聚合对象，不做任何检查或者校验可行吗？\n2.查询emp就加写锁，语句使用forUpdate\n\nPS：这种方式的修改聚合很有启发性","like_count":1,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600486,"discussion_content":"第一点，关键是从数据库查到值以后，怎么构建领域对象。第二点，确实是悲观锁的可行做法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674447795,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":373922,"user_name":"Geek_31faab","can_delete":false,"product_type":"c1","uid":2755603,"ip_address":"上海","ucode":"DCCA43626506A3","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/FyiaSFQ7wBCswIyD36Tu0RrlmeibDonxzd6czxGack8EjGEwws3uwH5QkrUQJq0AgK2a0mjyziblVZ9aVMr674Saw/132","comment_is_top":false,"comment_ctime":1683349076,"is_pvip":false,"replies":[{"id":136602,"content":"一般不代表","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1683372784,"ip_address":"广东","comment_id":373922,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"记录和记录快照也不存在“强”的整体部门关系对吗？一个记录删掉，不代表他的历史记录也会被删掉","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":617193,"discussion_content":"一般不代表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1683372784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368006,"user_name":"sqnv_geek","can_delete":false,"product_type":"c1","uid":2179895,"ip_address":"广东","ucode":"B23265E1862E4F","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/a4nwicfbEpwqfm8En9iapFqGoOpVg0p0N4ZjIFAdWQMiaxT0JT9OpYrM5ud1OliaLAUhhiaHDjY8mxmNfSbgBNAAGTQ/132","comment_is_top":false,"comment_ctime":1675818062,"is_pvip":false,"replies":[{"id":133992,"content":"这两者不矛盾，您为什么觉得无效呢？","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1675829433,"ip_address":"广东","comment_id":368006,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"transactuonal注解下再去弄乐观锁，有效吗？请教","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":602641,"discussion_content":"这两者不矛盾，您为什么觉得无效呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675829433,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1336475,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/9b/d1ab239e.jpg","nickname":"J.Smile","note":"","ucode":"C4D98DFDBF7584","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":646495,"discussion_content":"事务只是保证ACID，锁是对共享资源的并发控制。所以，全局保证业务规则不变性，需要对添加这个动作加分布式锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1718110366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1588683,"avatar":"https://static001.geekbang.org/account/avatar/00/18/3d/cb/791d0f5e.jpg","nickname":"猴哥","note":"","ucode":"63A1BFDF13D85D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1336475,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/9b/d1ab239e.jpg","nickname":"J.Smile","note":"","ucode":"C4D98DFDBF7584","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":649899,"discussion_content":"不一定非要正规的分布式锁（比如redis），因为这种场景下数据库锁相当于“分布式锁”了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1724121440,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":646495,"ip_address":"浙江","group_id":0},"score":649899,"extra":""}]}]},{"had_liked":false,"id":367786,"user_name":"Ice","can_delete":false,"product_type":"c1","uid":1082095,"ip_address":"四川","ucode":"B2C0AD8F970981","user_header":"https://static001.geekbang.org/account/avatar/00/10/82/ef/0badf9dc.jpg","comment_is_top":false,"comment_ctime":1675606297,"is_pvip":false,"replies":[{"id":133945,"content":"具体说一下，你觉得哪个逻辑在应用层，造成了领域逻辑泄露？","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1675641440,"ip_address":"广东","comment_id":367786,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"保证并发场景下的不可变规则实现放到了应用层，是不是也算是一种领域逻辑的泄漏呢？","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":602039,"discussion_content":"具体说一下，你觉得哪个逻辑在应用层，造成了领域逻辑泄露？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675641440,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1082095,"avatar":"https://static001.geekbang.org/account/avatar/00/10/82/ef/0badf9dc.jpg","nickname":"Ice","note":"","ucode":"B2C0AD8F970981","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":602060,"discussion_content":"EmpService中的事物控制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675649054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":367269,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"北京","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1675085118,"is_pvip":true,"replies":[{"id":135193,"content":"UpdateEmpRequest 是保存请求参数的DTO。\n没记错的话，myBatis可以通过反射直接给属性赋值，因此可以绕过规则校验，如果是这样的话，就可以代替本文中的做法。\n悲观锁是在select 的时候就上锁。您在网上搜一下，有很多文章介绍具体做法。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1678978444,"ip_address":"广东","comment_id":367269,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"UpdateEmpRequest 这个类的代码似乎之前没有出现过，感觉类似一个记录员工属性的”值对象“？\n\n对于聚合的查询，本文使用了”重建“的方式，但是我的印象里面似乎 myBatis 里面自带了查询语句的生成？\n\n对于思考题，\n\n1. 在重建聚合的时候，是否可以使用类似于 myBatis 的默认方式？或者把所有的验证都抽取到独立的一个 empValidator 方法里面去，可以在查询的时候不调用。\n2. 悲观锁应该就是在 update 的时候加锁，修改聚合根（员工）的 Update SQL 语句。","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609459,"discussion_content":"UpdateEmpRequest 是保存请求参数的DTO。\n没记错的话，myBatis可以通过反射直接给属性赋值，因此可以绕过规则校验，如果是这样的话，就可以代替本文中的做法。\n悲观锁是在select 的时候就上锁。您在网上搜一下，有很多文章介绍具体做法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678978444,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366950,"user_name":"Johar","can_delete":false,"product_type":"c1","uid":1101969,"ip_address":"重庆","ucode":"834136A6F64CDC","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/91/89123507.jpg","comment_is_top":false,"comment_ctime":1674655404,"is_pvip":false,"replies":[{"id":135206,"content":"1 数据库的方式可能只适用于某些特定的逻辑。通用一点的话，可以考虑为重建聚合单独做一个特殊的builder\n\n2 全局锁是一种可行的方案","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1678983334,"ip_address":"广东","comment_id":366950,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"1. 我们在重建聚合时，采用了编写聚合子类的方式绕过业务规则的校验，你还能想到其他方法吗？\n重建聚合时，主要是查重的逻辑和新建聚合校验逻辑不一致，可以考虑把校验放在db层，设置唯一所以来解决，查询数据的方式，在高并发下，还是有可能重复。\n2. 如果用悲观锁的话，应该怎样实现？\n一种，可以使用redis的全局锁，A进入某员工编辑界面，就不允许其他人进入该员工编辑页面；另外一种，也是使用全局锁，后端收到更新用户信息的请求时，使用key+租户id+员工id作为key锁定资源。","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609493,"discussion_content":"1 数据库的方式可能只适用于某些特定的逻辑。通用一点的话，可以考虑为重建聚合单独做一个特殊的builder\n\n2 全局锁是一种可行的方案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678983334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366567,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"浙江","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1673931114,"is_pvip":false,"replies":[{"id":134779,"content":"第1题，你的意思是专门做一个用于重建的工厂是吧，这个思路是对的\n第2题，你指的是专门做一个用于悲观锁的表是吧，这样也行。另一中做法是在实体表里加一个字段来锁。不论哪种方法，都要想办法定时清理没有正常释放的锁。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1677931115,"ip_address":"广东","comment_id":366567,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"思考题\n1. 将之前创建聚合对象的方法提取到新的类中（例如 EmpCreater)，这里只负责创建工作，不进行规则校验。提取后的方法可以被有规则校验与无规则校验的方法共同使用。\n2. 编辑的一开始，在数据库里插入一条记录（例如使用“员工 id”做唯一标识，设置为唯一索引），插入成功后再进行修改操作，否则就拒绝编辑；当编辑完成后，再删除使用“员工 id”做唯一标识的这条数据。\n\n读后感\n\n1. Updator 单独写一个类挺好\n2. RebuiltEmp，从数据库加载数据，不调用业务规则，绕过业务规则创建对象的方式对性能提升确实有帮助\n3. 当读到下列 3 段代码时，已经不记得是如何实现的，不能完全理解代码，感觉是时候跟着钟老师实现一遍代码了。\n\nemp.deleteSkill(presentSkill.getSkillTypeId());\nemp.updateSkill(skill.getSkillTypeId() , SkillLevel.ofCode(skill.getLevelCode()) , skill.getDuration() , userId);\nemp.addSkill(skill.getSkillTypeId() , SkillLevel.ofCode(skill.getLevelCode()) , skill.getDuration() , userId);","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":607536,"discussion_content":"第1题，你的意思是专门做一个用于重建的工厂是吧，这个思路是对的\n第2题，你指的是专门做一个用于悲观锁的表是吧，这样也行。另一中做法是在实体表里加一个字段来锁。不论哪种方法，都要想办法定时清理没有正常释放的锁。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1677931115,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366291,"user_name":"张强","can_delete":false,"product_type":"c1","uid":1273361,"ip_address":"北京","ucode":"A017F014BABD30","user_header":"https://static001.geekbang.org/account/avatar/00/13/6e/11/65e668c0.jpg","comment_is_top":false,"comment_ctime":1673568302,"is_pvip":false,"replies":[{"id":133671,"content":"你好呀，假定我们用的数据库隔离方式是常见的read commited,在新增整个聚合时，saveemp成功后，由于事务没有提交，所以其他线程无法读到新的emp,也就不会发生并发修改错误。对于修改聚合的情况，在乐观锁的保护下，也不会出错。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1674451189,"ip_address":"广东","comment_id":366291,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"老师您好：针对以下代码有个疑问？\n    @Override\n    public boolean save(Emp emp) {\n        if (saveEmp(emp)) {\n            emp.getSkills().forEach(s -&gt; saveSkill(emp, s));\n            emp.getExperiences().forEach(e -&gt; saveWorkExperience(emp, e));\n            emp.getEmpPosts().forEach(p -&gt; saveEmpPost(emp, p));\n            return true;\n        } else {\n            return false;\n        }\n    }\n1. 如果saveEmp 成功了， 在保存saveEmpPost 时，saveEmpPost 方法有没有可能被其他并发修改？\n改成以下 是否能解决1问题？也就后保存聚合根。\n\n    @Override\n    public boolean save(Emp emp) {\n\n emp.getSkills().forEach(s -&gt; saveSkill(emp, s));\n            emp.getExperiences().forEach(e -&gt; saveWorkExperience(emp, e));\n            emp.getEmpPosts().forEach(p -&gt; saveEmpPost(emp, p));\n\n        if (saveEmp(emp)) ｛\n            return true;\n        } else {\n            return false;\n        }\n    }","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600498,"discussion_content":"你好呀，假定我们用的数据库隔离方式是常见的read commited,在新增整个聚合时，saveemp成功后，由于事务没有提交，所以其他线程无法读到新的emp,也就不会发生并发修改错误。对于修改聚合的情况，在乐观锁的保护下，也不会出错。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674451189,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366208,"user_name":"Karson","can_delete":false,"product_type":"c1","uid":1008100,"ip_address":"辽宁","ucode":"E0286BF6CA7281","user_header":"https://static001.geekbang.org/account/avatar/00/0f/61/e4/db3f783b.jpg","comment_is_top":false,"comment_ctime":1673486308,"is_pvip":false,"replies":[{"id":133455,"content":"有，不过要等课程结束后整理一下再放出来","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1673537535,"ip_address":"广东","comment_id":366208,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100311801,"comment_content":"是否有课程源码呢？","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":599479,"discussion_content":"有，不过要等课程结束后整理一下再放出来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673537535,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}