{"id":446032,"title":"16｜复合数据类型：原生map类型的实现机制是怎样的？","content":"<p>你好，我是Tony Bai。</p><p>上一节课，我们学习了Go语言中最常用的两个复合类型：数组与切片。它们代表<strong>一组连续存储的同构类型元素集合。</strong>不同的是，数组的长度是确定的，而切片，我们可以理解为一种“动态数组”，它的长度在运行时是可变的。</p><p>这一节课，我们会继续前面的脉络，学习另外一种日常Go编码中比较常用的复合类型，这种类型可以让你将一个值（Value）唯一关联到一个特定的键（Key）上，可以用于实现特定键值的快速查找与更新，这个复合数据类型就是<strong>map</strong>。很多中文Go编程语言类技术书籍都会将它翻译为映射、哈希表或字典，但在我的课程中，<strong>为了保持原汁原味，我就直接使用它的英文名，map</strong>。</p><p>map是我们既切片之后，学到的第二个由Go编译器与运行时联合实现的复合数据类型，它有着复杂的内部实现，但却提供了十分简单友好的开发者使用接口。这一节课，我将从map类型的定义，到它的使用，再到map内部实现机制，由浅到深地让你吃透map类型。</p><h2>什么是map类型？</h2><p>map是Go语言提供的一种抽象数据类型，它表示一组无序的键值对。在后面的讲解中，我们会直接使用key和value分别代表map的键和值。而且，map集合中每个key都是唯一的：</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/f6/28/f6ac7392831455d3cf85f189a9dc9528.jpg?wh=1920x1047\" alt=\"图片\"></p><p>和切片类似，作为复合类型的map，它在Go中的类型表示也是由key类型与value类型组成的，就像下面代码：</p><pre><code class=\"language-plain\">map[key_type]value_type\n</code></pre><p>key与value的类型可以相同，也可以不同：</p><pre><code class=\"language-plain\">map[string]string // key与value元素的类型相同\nmap[int]string    // key与value元素的类型不同\n</code></pre><p>如果两个map类型的key元素类型相同，value元素类型也相同，那么我们可以说它们是同一个map类型，否则就是不同的map类型。</p><p>这里，我们要注意，map类型对value的类型没有限制，但是对key的类型却有严格要求，因为map类型要保证key的唯一性。Go语言中要求，<strong>key的类型必须支持“==”和“!=”两种比较操作符</strong>。</p><p>但是，在Go语言中，函数类型、map类型自身，以及切片只支持与nil的比较，而不支持同类型两个变量的比较。如果像下面代码这样，进行这些类型的比较，Go编译器将会报错：</p><pre><code class=\"language-plain\">s1 := make([]int, 1)\ns2 := make([]int, 2)\nf1 := func() {}\nf2 := func() {}\nm1 := make(map[int]string)\nm2 := make(map[int]string)\nprintln(s1 == s2) // 错误：invalid operation: s1 == s2 (slice can only be compared to nil)\nprintln(f1 == f2) // 错误：invalid operation: f1 == f2 (func can only be compared to nil)\nprintln(m1 == m2) // 错误：invalid operation: m1 == m2 (map can only be compared to nil)\n</code></pre><p>因此在这里，你一定要注意：<strong>函数类型、map类型自身，以及切片类型是不能作为map的key类型的</strong>。</p><p>知道如何表示一个map类型后，接下来，我们来看看如何声明和初始化一个map类型的变量。</p><h2>map变量的声明和初始化</h2><p>我们可以这样声明一个map变量：</p><pre><code class=\"language-plain\">var m map[string]int // 一个map[string]int类型的变量\n</code></pre><p>和切片类型变量一样，如果我们没有显式地赋予map变量初值，map类型变量的默认值为nil。</p><p>不过切片变量和map变量在这里也有些不同。初值为零值nil的切片类型变量，可以借助内置的append的函数进行操作，这种在Go语言中被称为“<strong>零值可用</strong>”。定义“零值可用”的类型，可以提升我们开发者的使用体验，我们不用再担心变量的初始状态是否有效。</p><p><strong>但map类型，因为它内部实现的复杂性，无法“零值可用”</strong>。所以，如果我们对处于零值状态的map变量直接进行操作，就会导致运行时异常（panic），从而导致程序进程异常退出：</p><pre><code class=\"language-plain\">var m map[string]int // m = nil\nm[\"key\"] = 1         // 发生运行时异常：panic: assignment to entry in nil map\n</code></pre><p>所以，我们必须对map类型变量进行显式初始化后才能使用。那我们怎样对map类型变量进行初始化呢？</p><p>和切片一样，为map类型变量显式赋值有两种方式：一种是使用复合字面值；另外一种是使用make这个预声明的内置函数。</p><p><strong>方法一：使用复合字面值初始化map类型变量。</strong></p><p>我们先来看这句代码：</p><pre><code class=\"language-plain\">m := map[int]string{}\n</code></pre><p>这里，我们显式初始化了map类型变量m。不过，你要注意，虽然此时map类型变量m中没有任何键值对，但变量m也不等同于初值为nil的map变量。这个时候，我们对m进行键值对的插入操作，不会引发运行时异常。</p><p>这里我们再看看怎么通过稍微复杂一些的复合字面值，对map类型变量进行初始化：</p><pre><code class=\"language-plain\">m1 := map[int][]string{\n    1: []string{\"val1_1\", \"val1_2\"},\n    3: []string{\"val3_1\", \"val3_2\", \"val3_3\"},\n    7: []string{\"val7_1\"},\n}\n\ntype Position struct { \n    x float64 \n    y float64\n}\n\nm2 := map[Position]string{\n    Position{29.935523, 52.568915}: \"school\",\n    Position{25.352594, 113.304361}: \"shopping-mall\",\n    Position{73.224455, 111.804306}: \"hospital\",\n}\n</code></pre><p>我们看到，上面代码虽然完成了对两个map类型变量m1和m2的显式初始化，但不知道你有没有发现一个问题，作为初值的字面值似乎有些“臃肿”。你看，作为初值的字面值采用了复合类型的元素类型，而且在编写字面值时还带上了各自的元素类型，比如作为map[int] []string值类型的[]string，以及作为map[Position]string的key类型的Position。</p><p>别急！针对这种情况，Go提供了“语法糖”。这种情况下，<strong>Go允许省略字面值中的元素类型</strong>。因为map类型表示中包含了key和value的元素类型，Go编译器已经有足够的信息，来推导出字面值中各个值的类型了。我们以m2为例，这里的显式初始化代码和上面变量m2的初始化代码是等价的：</p><pre><code class=\"language-plain\">m2 := map[Position]string{\n    {29.935523, 52.568915}: \"school\",\n    {25.352594, 113.304361}: \"shopping-mall\",\n    {73.224455, 111.804306}: \"hospital\",\n}\n</code></pre><p>以后在无特殊说明的情况下，我们都将使用这种简化后的字面值初始化方式。</p><p><strong>方法二：使用make为map类型变量进行显式初始化。</strong></p><p>和切片通过make进行初始化一样，通过make的初始化方式，我们可以为map类型变量指定键值对的初始容量，但无法进行具体的键值对赋值，就像下面代码这样：</p><pre><code class=\"language-plain\">m1 := make(map[int]string) // 未指定初始容量\nm2 := make(map[int]string, 8) // 指定初始容量为8\n</code></pre><p>不过，map类型的容量不会受限于它的初始容量值，当其中的键值对数量超过初始容量后，Go运行时会自动增加map类型的容量，保证后续键值对的正常插入。</p><p>了解完map类型变量的声明与初始化后，我们就来看看，在日常开发中，map类型都有哪些基本操作和注意事项。</p><h2>map的基本操作</h2><p>针对一个map类型变量，我们可以进行诸如插入新键值对、获取当前键值对数量、查找特定键和读取对应值、删除键值对，以及遍历键值等操作。我们一个个来学习。</p><p><strong>操作一：插入新键值对。</strong></p><p>面对一个非nil的map类型变量，我们可以在其中插入符合map类型定义的任意新键值对。插入新键值对的方式很简单，我们只需要把value赋值给map中对应的key就可以了：</p><pre><code class=\"language-plain\">m := make(map[int]string)\nm[1] = \"value1\"\nm[2] = \"value2\"\nm[3] = \"value3\"\n</code></pre><p>而且，我们不需要自己判断数据有没有插入成功，因为Go会保证插入总是成功的。这里，Go运行时会负责map变量内部的内存管理，因此除非是系统内存耗尽，我们可以不用担心向map中插入新数据的数量和执行结果。</p><p>不过，如果我们插入新键值对的时候，某个key已经存在于map中了，那我们的插入操作就会用新值覆盖旧值：</p><pre><code class=\"language-plain\">m := map[string]int {\n\t\"key1\" : 1,\n\t\"key2\" : 2,\n}\n\nm[\"key1\"] = 11 // 11会覆盖掉\"key1\"对应的旧值1\nm[\"key3\"] = 3  // 此时m为map[key1:11 key2:2 key3:3]\n</code></pre><p>从这段代码中你可以看到，map类型变量m在声明的同时就做了初始化，它的内部建立了两个键值对，其中就包含键key1。所以后面我们再给键key1进行赋值时，Go不会重新创建key1键，而是会用新值(11)把key1键对应的旧值(1)替换掉。</p><p><strong>操作二：获取键值对数量。</strong></p><p>如果我们在编码中，想知道当前map类型变量中已经建立了多少个键值对，那我们可以怎么做呢？和切片一样，map类型也可以通过内置函数<strong>len</strong>，获取当前变量已经存储的键值对数量：</p><pre><code class=\"language-plain\">m := map[string]int {\n\t\"key1\" : 1,\n\t\"key2\" : 2,\n}\n\nfmt.Println(len(m)) // 2\nm[\"key3\"] = 3  \nfmt.Println(len(m)) // 3\n</code></pre><p>不过，这里要注意的是<strong>我们不能对map类型变量调用cap，来获取当前容量</strong>，这是map类型与切片类型的一个不同点。</p><p><strong>操作三：查找和数据读取</strong></p><p>和写入相比，map类型更多用在查找和数据读取场合。所谓查找，就是判断某个key是否存在于某个map中。有了前面向map插入键值对的基础，我们可能自然而然地想到，可以用下面代码去查找一个键并获得该键对应的值：</p><pre><code class=\"language-plain\">m := make(map[string]int)\nv := m[\"key1\"]\n</code></pre><p>乍一看，第二行代码在语法上好像并没有什么不当之处，但其实通过这行语句，我们还是无法确定键key1是否真实存在于map中。这是因为，当我们尝试去获取一个键对应的值的时候，如果这个键在map中并不存在，我们也会得到一个值，这个值是value元素类型的<strong>零值</strong>。</p><p>我们以上面这个代码为例，如果键key1在map中并不存在，那么v的值就会被赋予value元素类型int的零值，也就是0。所以我们无法通过v值判断出，究竟是因为key1不存在返回的零值，还是因为key1本身对应的value就是0。</p><p>那么在map中查找key的正确姿势是什么呢？Go语言的map类型支持通过用一种名为“<strong>comma ok</strong>”的惯用法，进行对某个key的查询。接下来我们就用“comma ok”惯用法改造一下上面的代码：</p><pre><code class=\"language-plain\">m := make(map[string]int)\nv, ok := m[\"key1\"]\nif !ok {\n    // \"key1\"不在map中\n}\n\n// \"key1\"在map中，v将被赋予\"key1\"键对应的value\n</code></pre><p>我们看到，这里我们通过了一个布尔类型变量ok，来判断键“key1”是否存在于map中。如果存在，变量v就会被正确地赋值为键“key1”对应的value。</p><p>不过，如果我们并不关心某个键对应的value，而只关心某个键是否在于map中，我们可以使用空标识符替代变量v，忽略可能返回的value：</p><pre><code class=\"language-plain\">m := make(map[string]int)\n_, ok := m[\"key1\"]\n... ...\n</code></pre><p>因此，你一定要记住：<strong>在Go语言中，请使用“comma ok”惯用法对map进行键查找和键值读取操作。</strong></p><p><strong>操作四：删除数据。</strong></p><p>接下来，我们再看看看如何从map中删除某个键值对。在Go中，我们需要借助<strong>内置函数delete</strong>来从map中删除数据。使用delete函数的情况下，传入的第一个参数是我们的map类型变量，第二个参数就是我们想要删除的键。我们可以看看这个代码示例：</p><pre><code class=\"language-plain\">m := map[string]int {\n\t\"key1\" : 1,\n\t\"key2\" : 2,\n}\n\nfmt.Println(m) // map[key1:1 key2:2]\ndelete(m, \"key2\") // 删除\"key2\"\nfmt.Println(m) // map[key1:1]\n</code></pre><p>这里要注意的是，<strong>delete函数是从map中删除键的唯一方法</strong>。即便传给delete的键在map中并不存在，delete函数的执行也不会失败，更不会抛出运行时的异常。</p><p><strong>操作五：遍历map中的键值数据</strong></p><p>最后，我们来说一下如何遍历map中的键值数据。这一点虽然不像查询和读取操作那么常见，但日常开发中我们还是有这个需求的。在Go中，遍历map的键值对只有一种方法，那就是<strong>像对待切片那样通过for range语句对map数据进行遍历</strong>。我们看一个例子：</p><pre><code class=\"language-plain\">package main\n  \nimport \"fmt\"\n\nfunc main() {\n    m := map[int]int{\n        1: 11,\n        2: 12,\n        3: 13,\n    }\n\n    fmt.Printf(\"{ \")\n    for k, v := range m {\n        fmt.Printf(\"[%d, %d] \", k, v)\n    }\n    fmt.Printf(\"}\\n\")\n}\n</code></pre><p>你看，通过for range遍历map变量m，每次迭代都会返回一个键值对，其中键存在于变量k中，它对应的值存储在变量v中。我们可以运行一下这段代码，可以得到符合我们预期的结果：</p><pre><code class=\"language-plain\">{ [1, 11] [2, 12] [3, 13] }\n</code></pre><p>如果我们只关心每次迭代的键，我们可以使用下面的方式对map进行遍历：</p><pre><code class=\"language-plain\">for k, _ := range m { \n\t// 使用k\n}\n</code></pre><p>当然更地道的方式是这样的：</p><pre><code class=\"language-plain\">for k := range m {\n\t// 使用k\n}\n</code></pre><p>如果我们只关心每次迭代返回的键所对应的value，我们同样可以通过空标识符替代变量k，就像下面这样：</p><pre><code class=\"language-plain\">for _, v := range m {\n\t// 使用v\n}\n</code></pre><p>不过，前面map遍历的输出结果都非常理想，给我们的表象好像是迭代器按照map中元素的插入次序逐一遍历。那事实是不是这样呢？我们再来试试，多遍历几次这个map看看。</p><p>我们先来改造一下代码：</p><pre><code class=\"language-plain\">package main\n  \nimport \"fmt\"\n\nfunc doIteration(m map[int]int) {\n    fmt.Printf(\"{ \")\n    for k, v := range m {\n        fmt.Printf(\"[%d, %d] \", k, v)\n    }\n    fmt.Printf(\"}\\n\")\n}\n\nfunc main() {\n    m := map[int]int{\n        1: 11,\n        2: 12,\n        3: 13,\n    }\n\n    for i := 0; i &lt; 3; i++ {\n        doIteration(m)\n    }\n}\n</code></pre><p>运行一下上述代码，我们可以得到这样结果：</p><pre><code class=\"language-plain\">{ [3, 13] [1, 11] [2, 12] }\n{ [1, 11] [2, 12] [3, 13] }\n{ [3, 13] [1, 11] [2, 12] }\n</code></pre><p>我们可以看到，<strong>对同一map做多次遍历的时候，每次遍历元素的次序都不相同</strong>。这是Go语言map类型的一个重要特点，也是很容易让Go初学者掉入坑中的一个地方。所以这里你一定要记住：<strong>程序逻辑千万不要依赖遍历map所得到的的元素次序</strong>。</p><p>从我们前面的讲解，你应该也感受到了，map类型非常好用，那么，我们在各个函数方法间传递map变量会不会有很大开销呢？</p><h2>map变量的传递开销</h2><p>其实你不用担心开销的问题。</p><p>和切片类型一样，map也是引用类型。这就意味着map类型变量作为参数被传递给函数或方法的时候，实质上传递的只是一个<strong>“描述符”</strong>（后面我们再讲这个描述符究竟是什么)，而不是整个map的数据拷贝，所以这个传递的开销是固定的，而且也很小。</p><p>并且，当map变量被传递到函数或方法内部后，我们在函数内部对map类型参数的修改在函数外部也是可见的。比如你从这个示例中就可以看到，函数foo中对map类型变量m进行了修改，而这些修改在foo函数外也可见。</p><pre><code class=\"language-plain\">package main\n  \nimport \"fmt\"\n\nfunc foo(m map[string]int) {\n    m[\"key1\"] = 11\n    m[\"key2\"] = 12\n}\n\nfunc main() {\n    m := map[string]int{\n        \"key1\": 1,\n        \"key2\": 2,\n    }\n\n    fmt.Println(m) // map[key1:1 key2:2]  \n    foo(m)\n    fmt.Println(m) // map[key1:11 key2:12] \n}\n</code></pre><h2>map的内部实现</h2><p>和切片相比，map类型的内部实现要更加复杂。Go运行时使用一张哈希表来实现抽象的map类型。运行时实现了map类型操作的所有功能，包括查找、插入、删除等。在编译阶段，Go编译器会将Go语法层面的map操作，重写成运行时对应的函数调用。大致的对应关系是这样的：</p><pre><code class=\"language-plain\">// 创建map类型变量实例\nm := make(map[keyType]valType, capacityhint) → m := runtime.makemap(maptype, capacityhint, m)\n\n// 插入新键值对或给键重新赋值\nm[\"key\"] = \"value\" → v := runtime.mapassign(maptype, m, \"key\") v是用于后续存储value的空间的地址\n\n// 获取某键的值 \nv := m[\"key\"]      → v := runtime.mapaccess1(maptype, m, \"key\")\nv, ok := m[\"key\"]  → v, ok := runtime.mapaccess2(maptype, m, \"key\")\n\n// 删除某键\ndelete(m, \"key\")   → runtime.mapdelete(maptype, m, “key”)\n</code></pre><p>这是map类型在Go运行时层实现的示意图：</p><p><img src=\"https://static001.geekbang.org/resource/image/c9/1f/c9b2d05ffcb3yyd3b7da06763ee46a1f.jpg?wh=1980x1080\" alt=\"\"></p><p>我们可以看到，和切片的运行时表示图相比，map的实现示意图显然要复杂得多。接下来，我们结合这张图来简要描述一下map在运行时层的实现原理。我们重点讲解一下一个map变量在初始状态、进行键值对操作后，以及在并发场景下的Go运行时层的实现原理。</p><h3>初始状态</h3><p>从图中我们可以看到，与语法层面 map 类型变量（m）一一对应的是*runtime.hmap 的实例，即runtime.hmap类型的指针，也就是我们前面在讲解 map 类型变量传递开销时提到的 <strong>map 类型的描述符</strong>。hmap 类型是 map 类型的头部结构（header），它存储了后续 map 类型操作所需的所有信息，包括：</p><p><img src=\"https://static001.geekbang.org/resource/image/2f/04/2f5ff72fbdb17cf0cb0b8da102c3e604.jpg?wh=1920x1047\" alt=\"图片\"></p><p>真正用来存储键值对数据的是桶，也就是bucket，每个bucket中存储的是Hash值低bit位数值相同的元素，默认的元素个数为 BUCKETSIZE（值为 8，Go 1.17版本中在$GOROOT/src/cmd/compile/internal/reflectdata/reflect.go中定义，与 runtime/map.go 中常量 bucketCnt 保持一致）。</p><p>当某个bucket（比如buckets[0])的8个空槽slot）都填满了，且map尚未达到扩容的条件的情况下，运行时会建立overflow bucket，并将这个overflow bucket挂在上面bucket（如buckets[0]）末尾的overflow指针上，这样两个buckets形成了一个链表结构，直到下一次map扩容之前，这个结构都会一直存在。</p><p>从图中我们可以看到，每个bucket由三部分组成，从上到下分别是tophash区域、key存储区域和value存储区域。</p><ul>\n<li><strong>tophash区域</strong></li>\n</ul><p>当我们向map插入一条数据，或者是从map按key查询数据的时候，运行时都会使用哈希函数对key做哈希运算，并获得一个哈希值（hashcode）。这个hashcode非常关键，运行时会把hashcode“一分为二”来看待，其中低位区的值用于选定bucket，高位区的值用于在某个bucket中确定key的位置。我把这一过程整理成了下面这张示意图，你理解起来可以更直观：</p><p><img src=\"https://static001.geekbang.org/resource/image/ef/08/ef729c06cd8fa19f29f89df212c7ea08.jpg?wh=1920x1047\" alt=\"图片\"></p><p>因此，每个bucket的tophash区域其实是用来快速定位key位置的，这样就避免了逐个key进行比较这种代价较大的操作。尤其是当key是size较大的字符串类型时，好处就更突出了。这是一种以空间换时间的思路。</p><ul>\n<li><strong>key存储区域</strong></li>\n</ul><p>接着，我们看tophash区域下面是一块连续的内存区域，存储的是这个bucket承载的所有key数据。运行时在分配bucket的时候需要知道key的Size。那么运行时是如何知道key的size的呢？</p><p>当我们声明一个map类型变量，比如var m map[string]int时，Go运行时就会为这个变量对应的特定map类型，生成一个runtime.maptype实例。如果这个实例已经存在，就会直接复用。maptype实例的结构是这样的：</p><pre><code class=\"language-plain\">type maptype struct {\n    typ        _type\n    key        *_type\n    elem       *_type\n    bucket     *_type // internal type representing a hash bucket\n    keysize    uint8  // size of key slot\n    elemsize   uint8  // size of elem slot\n    bucketsize uint16 // size of bucket\n    flags      uint32\n} \n</code></pre><p>我们可以看到，这个实例包含了我们需要的map类型中的所有\"元信息\"。我们前面提到过，编译器会把语法层面的map操作重写成运行时对应的函数调用，这些运行时函数都有一个共同的特点，那就是第一个参数都是maptype指针类型的参数。</p><p><strong>Go运行时就是利用maptype参数中的信息确定key的类型和大小的。</strong>map所用的hash函数也存放在maptype.key.alg.hash(key, hmap.hash0)中。同时maptype的存在也让Go中所有map类型都共享一套运行时map操作函数，而不是像C++那样为每种map类型创建一套map操作函数，这样就节省了对最终二进制文件空间的占用。</p><ul>\n<li><strong>value存储区域</strong></li>\n</ul><p>我们再接着看key存储区域下方的另外一块连续的内存区域，这个区域存储的是key对应的value。和key一样，这个区域的创建也是得到了maptype中信息的帮助。Go运行时采用了把key和value分开存储的方式，而不是采用一个kv接着一个kv的kv紧邻方式存储，这带来的其实是算法上的复杂性，但却减少了因内存对齐带来的内存浪费。</p><p>我们以map[int8]int64为例，看看下面的存储空间利用率对比图：</p><p><img src=\"https://static001.geekbang.org/resource/image/5b/5a/5bce9aaebc78bdea7d2999606891325a.jpg?wh=1920x1047\" alt=\"图片\"></p><p>你会看到，当前Go运行时使用的方案内存利用效率很高，而kv紧邻存储的方案在map[int8]int64这样的例子中内存浪费十分严重，它的内存利用率是72/128=56.25%，有近一半的空间都浪费掉了。</p><p>另外，还有一点我要跟你强调一下，如果key或value的数据长度大于一定数值，那么运行时不会在bucket中直接存储数据，而是会存储key或value数据的指针。目前Go运行时定义的最大key和value的长度是这样的：</p><pre><code class=\"language-plain\">// $GOROOT/src/runtime/map.go\nconst (\n    maxKeySize  = 128\n    maxElemSize = 128\n)\n</code></pre><h3>map扩容</h3><p>我们前面提到过，map会对底层使用的内存进行自动管理。因此，在使用过程中，当插入元素个数超出一定数值后，map一定会存在自动扩容的问题，也就是怎么扩充bucket的数量，并重新在bucket间均衡分配数据的问题。</p><p>那么map在什么情况下会进行扩容呢？Go运行时的map实现中引入了一个LoadFactor（负载因子），当<strong>count &gt; LoadFactor * 2^B</strong>或overflow bucket过多时，运行时会自动对map进行扩容。目前Go最新1.17版本LoadFactor设置为6.5（loadFactorNum/loadFactorDen）。这里是Go中与map扩容相关的部分源码：</p><pre><code class=\"language-plain\">// $GOROOT/src/runtime/map.go\nconst (\n\t... ...\n\n\tloadFactorNum = 13\n\tloadFactorDen = 2\n\t... ...\n)\n\nfunc mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {\n\t... ...\n\tif !h.growing() &amp;&amp; (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {\n\t\thashGrow(t, h)\n\t\tgoto again // Growing the table invalidates everything, so try again\n\t}\n\t... ...\n}\n</code></pre><p>这两方面原因导致的扩容，在运行时的操作其实是不一样的。如果是因为overflow bucket过多导致的“扩容”，实际上运行时会新建一个和现有规模一样的bucket数组，然后在assign和delete时做排空和迁移。</p><p>如果是因为当前数据数量超出LoadFactor指定水位而进行的扩容，那么运行时会建立一个<strong>两倍于现有规模的bucket数组</strong>，但真正的排空和迁移工作也是在assign和delete时逐步进行的。原bucket数组会挂在hmap的oldbuckets指针下面，直到原buckets数组中所有数据都迁移到新数组后，原buckets数组才会被释放。你可以结合下面的map扩容示意图来理解这个过程，这会让你理解得更深刻一些：</p><p><img src=\"https://static001.geekbang.org/resource/image/6e/29/6e94c7ee51a01fcf2267a7e2145d6929.jpg?wh=1920x1047\" alt=\"图片\"></p><h3>map与并发</h3><p>接着我们来看一下map和并发。从上面的实现原理来看，充当map描述符角色的hmap实例自身是有状态的（hmap.flags），而且对状态的读写是没有并发保护的。所以说map实例不是并发写安全的，也不支持并发读写。如果我们对map实例进行并发读写，程序运行时就会抛出异常。你可以看看下面这个并发读写map的例子：</p><pre><code class=\"language-plain\">package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc doIteration(m map[int]int) {\n    for k, v := range m {\n        _ = fmt.Sprintf(\"[%d, %d] \", k, v)\n    }\n}\n\nfunc doWrite(m map[int]int) {\n    for k, v := range m {\n        m[k] = v + 1\n    }\n}\n\nfunc main() {\n    m := map[int]int{\n        1: 11,\n        2: 12,\n        3: 13,\n    }\n\n    go func() {\n        for i := 0; i &lt; 1000; i++ {\n            doIteration(m)\n        }\n    }()\n\n    go func() {\n        for i := 0; i &lt; 1000; i++ {\n            doWrite(m)\n        }\n    }()\n\n    time.Sleep(5 * time.Second)\n}\n</code></pre><p>运行这个示例程序，我们会得到下面的执行错误结果：</p><pre><code class=\"language-plain\">fatal error: concurrent map iteration and map write\n</code></pre><p>不过，如果我们仅仅是进行并发读，map是没有问题的。而且，Go 1.9版本中引入了支持并发写安全的sync.Map类型，可以在并发读写的场景下替换掉map。如果你有这方面的需求，可以查看一下<a href=\"https://pkg.go.dev/sync#Map\">sync.Map的手册</a>。</p><p>另外，你要注意，考虑到map可以自动扩容，map中数据元素的value位置可能在这一过程中发生变化，所以<strong>Go不允许获取map中value的地址，这个约束是在编译期间就生效的</strong>。下面这段代码就展示了Go编译器识别出获取map中value地址的语句后，给出的编译错误：</p><pre><code class=\"language-plain\">p := &amp;m[key]  // cannot take the address of m[key]\nfmt.Println(p)\n</code></pre><h2>小结</h2><p>好了，今天的课讲到这里就结束了。这一节课，我们讲解了Go语言的另一类十分常用的复合数据类型：map。</p><p>在Go语言中，map类型是一个无序的键值对的集合。它有两种类型元素，一类是键（key），另一类是值（value）。在一个map中，键是唯一的，在集合中不能有两个相同的键。Go也是通过这两种元素类型来表示一个map类型，你要记得这个通用的map类型表示：“map[key_type]value_type”。</p><p>map类型对key元素的类型是有约束的，它要求key元素的类型必须支持\"==“和”!=\"两个比较操作符。value元素的类型可以是任意的。</p><p>不过，map类型变量声明后必须对它进行初始化后才能操作。map类型支持插入新键值对、查找和数据读取、删除键值对、遍历map中的键值数据等操作，Go为开发者提供了十分简单的操作接口。这里要你重点记住的是，我们在查找和数据读取时一定要使用“comma ok”惯用法。此外，map变量在函数与方法间传递的开销很小，并且在函数内部通过map描述符对map的修改会对函数外部可见。</p><p>另外，map的内部实现要比切片复杂得多，它是由Go编译器与运行时联合实现的。Go编译器在编译阶段会将语法层面的map操作，重写为运行时对应的函数调用。Go运行时则采用了高效的算法实现了map类型的各类操作，这里我建议你要结合Go项目源码来理解map的具体实现。</p><p>和切片一样，map是Go语言提供的重要数据类型，也是Gopher日常Go编码是最常使用的类型之一。我们在日常使用map的场合要把握住下面几个要点，不要走弯路：</p><ul>\n<li>不要依赖map的元素遍历顺序；</li>\n<li>map不是线程安全的，不支持并发读写；</li>\n<li>不要尝试获取map中元素（value）的地址。</li>\n</ul><h2>思考题</h2><p>通过上面的学习，我们知道对map类型进行遍历所得到的键的次序是随机的，那么我想请你思考并实现一个方法，让我们能对map的进行稳定次序遍历？期待在留言区看到你的想法。</p><p>欢迎你把这节课分享给更多对Go语言map类型感兴趣的朋友。我是Tony Bai，我们下节课见。</p>","neighbors":{"left":{"article_title":"15｜同构复合类型：从定长数组到变长切片","id":444348},"right":{"article_title":"17｜复合数据类型：用结构体建立对真实世界的抽象","id":446840}},"comments":[{"had_liked":false,"id":321982,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1320487,"ip_address":"","ucode":"96BAFAA147341F","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","comment_is_top":false,"comment_ctime":1637126423,"is_pvip":false,"discussion_count":8,"race_medal":2,"score":"130486145303","product_id":100093501,"comment_content":"还想深入研究 map 的小伙伴，可以去研究这些博客：<br>https:&#47;&#47;www.qcrao.com&#47;2019&#47;05&#47;22&#47;dive-into-go-map&#47;   <br>https:&#47;&#47;qcrao.com&#47;2020&#47;05&#47;06&#47;dive-into-go-sync-map&#47;<br>https:&#47;&#47;draveness.me&#47;golang&#47;docs&#47;part2-foundation&#47;ch03-datastructure&#47;golang-hashmap&#47;","like_count":30,"discussions":[{"author":{"id":2720810,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/xfclWEPQ7szTZnKqnX9icSbgDWV0VAib3Cyo8Vg0OG3Usby88ic7ZgO2ho5lj0icOWI4JeJ70zUBiaTW1xh1UCFRPqA/132","nickname":"Geek_6bdb4e","note":"","ucode":"2953D400AA5385","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582655,"discussion_content":"第一篇换了这个地址了https://golang.design/go-questions/map/principal/","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1659579263,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1473123,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJiartmgOY37cwbdbsX7j6EGic3SMfDLqCVBFS9HEs7IA1icVovzMtSiaxiaic6GOpl4cyvDdrqgK3rU4icA/132","nickname":"Geek_097a1e","note":"","ucode":"ED0A3C047E1B98","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586974,"discussion_content":"M","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662635764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"安徽"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111176,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f4/88/133bc14b.jpg","nickname":"c340","note":"","ucode":"D64CC3DDD09A0F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585769,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661819291,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"福建"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1637228,"avatar":"https://static001.geekbang.org/account/avatar/00/18/fb/6c/12fdc372.jpg","nickname":"迈向架构师","note":"","ucode":"2476594CF76001","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578660,"discussion_content":"前2篇404了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656927690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1156153,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a4/39/a3e452cd.jpg","nickname":"a115","note":"","ucode":"0C733004371E29","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575845,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655135834,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1886796,"avatar":"","nickname":"张毅","note":"","ucode":"0707311786C079","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573121,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653211221,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1519200,"avatar":"https://static001.geekbang.org/account/avatar/00/17/2e/60/4fa1f3bd.jpg","nickname":"rs勿忘初心","note":"","ucode":"557D1ECD757195","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546492,"discussion_content":"深入研究 map的笔记，mark一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642318582,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1936087,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8a/d7/daabec34.jpg","nickname":"tequ1lAneio","note":"","ucode":"41336E87FF2E1A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531581,"discussion_content":"看了第一篇，真的棒，赞一个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637335591,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321964,"user_name":"用0和1改变自己","can_delete":false,"product_type":"c1","uid":1527530,"ip_address":"","ucode":"42B8F6ECF6BDD0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/lfMbV8RibrhFxjILg4550cZiaay64mTh5Zibon64TiaicC8jDMEK7VaXOkllHSpS582Jl1SUHm6Jib2AticVlHibiaBvUOA/132","comment_is_top":false,"comment_ctime":1637118799,"is_pvip":false,"replies":[{"id":"117136","content":"✅","user_name":"作者回复","comment_id":321964,"uid":"1026224","ip_address":"","utype":1,"ctime":1637555989,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"104716333903","product_id":100093501,"comment_content":"可以用一个有序结构存储key,如slice,然后for这个slice,用key获取值。资料来源至：https:&#47;&#47;go.dev&#47;blog&#47;maps","like_count":24,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532204,"discussion_content":"✅","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637555989,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343494,"user_name":"ddh","can_delete":false,"product_type":"c1","uid":2806043,"ip_address":"","ucode":"8E852375365F16","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLBFkSq1oiaEMRjtyyv4ZpCI0OuaSsqs04ODm0OkZF6QhsAh3SvqhxibS2n7PLAVZE3QRSn5Hic0DyXg/132","comment_is_top":false,"comment_ctime":1650875111,"is_pvip":false,"replies":[{"id":"125434","content":"好问题！<br><br>关于这个问题，官方没有明确说明。<br><br>我觉得之所以map element是不可寻址的，还是复杂性和安全性的考虑。<br><br>Go slice和map都是复合数据类型，但两者的内部实现复杂度却远远不同。map要远复杂于slice。<br><br>slice的元素的地址要么在要么在原底层数组中，要么在扩容后的新数组中。并且slice扩容是一次完成的。<br>但map扩容是“蚂蚁搬家”，element位置复杂一些，可能在原bucket中、可能在overflow bucket中，也可能在新扩容的bucket中。<br><br>此外，一旦暴露map element的地址，比如我们用一个栈上的指针变量引用了该地址，当发生element移动时，go就要考虑连带变更这些栈上指针变量的指向，这些变更操作在每个map操作中都会导致运行时消耗的增加。<br>           <br>至于安全性，map有着一个复杂内部结构，这个结构环环相扣。一旦map element地址被暴露，通过该地址不仅可以修改value值，还可能会对map内部结构造成破坏，这种破坏将导致整个map工作不正常。而slice的element即便被hack，改掉的也只是元素值。","user_name":"作者回复","comment_id":343494,"uid":"1026224","ip_address":"","utype":1,"ctime":1651010354,"user_name_real":"编辑"}],"discussion_count":3,"race_medal":0,"score":"36010613479","product_id":100093501,"comment_content":"请问一下老师， map 元素不能寻址， 是因为动态扩容， 那么切片不也有动态扩容吗。 为什么切片元素可以寻址呢？  难道切片动态扩容之后， 它的元素地址不会变吗","like_count":8,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":567813,"discussion_content":"好问题！\n\n关于这个问题，官方没有明确说明。\n\n我觉得之所以map element是不可寻址的，还是复杂性和安全性的考虑。\n\nGo slice和map都是复合数据类型，但两者的内部实现复杂度却远远不同。map要远复杂于slice。\n\nslice的元素的地址要么在要么在原底层数组中，要么在扩容后的新数组中。并且slice扩容是一次完成的。\n但map扩容是“蚂蚁搬家”，element位置复杂一些，可能在原bucket中、可能在overflow bucket中，也可能在新扩容的bucket中。\n\n此外，一旦暴露map element的地址，比如我们用一个栈上的指针变量引用了该地址，当发生element移动时，go就要考虑连带变更这些栈上指针变量的指向，这些变更操作在每个map操作中都会导致运行时消耗的增加。\n           \n至于安全性，map有着一个复杂内部结构，这个结构环环相扣。一旦map element地址被暴露，通过该地址不仅可以修改value值，还可能会对map内部结构造成破坏，这种破坏将导致整个map工作不正常。而slice的element即便被hack，改掉的也只是元素值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651010354,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2806043,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLBFkSq1oiaEMRjtyyv4ZpCI0OuaSsqs04ODm0OkZF6QhsAh3SvqhxibS2n7PLAVZE3QRSn5Hic0DyXg/132","nickname":"ddh","note":"","ucode":"8E852375365F16","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":568120,"discussion_content":"谢谢老师的讲解，我已经是二刷啦，还是收获满满，哈哈","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1651067699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":567813,"ip_address":""},"score":568120,"extra":""}]},{"author":{"id":1098505,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c3/09/dc368335.jpg","nickname":"杰sir","note":"","ucode":"80BB56B3BFB71A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582345,"discussion_content":"安全性更有说服力一些，sliece扩容后，原先引用slice元素的指针还是指向老的地址\n    v := []int{1}\n    fmt.Printf(&#34;v: cap: %d\\n&#34;, cap(v)) //v: cap: 1\n    p := &amp;v[0]\n    v = append(v, 2)\n    v = append(v, 3)\n    *p = 2\n    fmt.Printf(&#34;v: %v, cap: %d, %d\\n&#34;, v, cap(v), *p) //v: [1 2 3], cap: 4, 2","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659405031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341590,"user_name":"thomas","can_delete":false,"product_type":"c1","uid":1016777,"ip_address":"","ucode":"9AB945308F1B50","user_header":"https://static001.geekbang.org/account/avatar/00/0f/83/c9/5d03981a.jpg","comment_is_top":false,"comment_ctime":1649727478,"is_pvip":true,"replies":[{"id":"124887","content":"这一话题要追溯到Go 1.0版本发布的时候，从Go 1.0版本的发布文档- https:&#47;&#47;go.dev&#47;doc&#47;go1中，我们能找到如下内容：<br><br><br>The old language specification did not define the order of iteration for maps, and in practice it differed across hardware platforms. This caused tests that iterated over maps to be fragile and non-portable, with the unpleasant property that a test might always pass on one machine but break on another.<br>                         <br>In Go 1, the order in which elements are visited when iterating over a map using a for range statement is defined to be unpredictable, even if the same loop is run multiple times with the same map. Code should not assume that the elements are visited in any particular order.<br>                         <br>This change means that code that depends on iteration order is very likely to break early and be fixed long before it becomes a problem. Just as important, it allows the map implementation to ensure better map balancing even when programs are using range loops to select an element from a map.                                <br>                                            <br>                                                                             <br>翻译过来，大致意思就是：1.0版本之前的语言规范中没有规定map的迭代次序，从而导致在实践中的一些糟糕的开发运行体验。于是Go团队选<br>择故意在map中加入随机迭代功能，这样一旦出现开发人员依赖key迭代顺序的错误行为，这一行为导致的问题在开发和测试早期就能被及时发现，而不会出现在生产运行环境中导致更大的危害。","user_name":"作者回复","comment_id":341590,"uid":"1026224","ip_address":"","utype":1,"ctime":1649905658,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"27419531254","product_id":100093501,"comment_content":"go团队为什么要故意把map的遍历设置为随机？","like_count":6,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":562902,"discussion_content":"这一话题要追溯到Go 1.0版本发布的时候，从Go 1.0版本的发布文档- https://go.dev/doc/go1中，我们能找到如下内容：\n\n\nThe old language specification did not define the order of iteration for maps, and in practice it differed across hardware platforms. This caused tests that iterated over maps to be fragile and non-portable, with the unpleasant property that a test might always pass on one machine but break on another.\n                         \nIn Go 1, the order in which elements are visited when iterating over a map using a for range statement is defined to be unpredictable, even if the same loop is run multiple times with the same map. Code should not assume that the elements are visited in any particular order.\n                         \nThis change means that code that depends on iteration order is very likely to break early and be fixed long before it becomes a problem. Just as important, it allows the map implementation to ensure better map balancing even when programs are using range loops to select an element from a map.                                \n                                            \n                                                                             \n翻译过来，大致意思就是：1.0版本之前的语言规范中没有规定map的迭代次序，从而导致在实践中的一些糟糕的开发运行体验。于是Go团队选\n择故意在map中加入随机迭代功能，这样一旦出现开发人员依赖key迭代顺序的错误行为，这一行为导致的问题在开发和测试早期就能被及时发现，而不会出现在生产运行环境中导致更大的危害。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649905658,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322090,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":false,"comment_ctime":1637161765,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"27406965541","product_id":100093501,"comment_content":"可以参考java的LinkedHashMap,能实现插入有序或者访问有序，就是使用额外的链表来保存顺序。<br>go 中可以基于container&#47;list来实现。github上现成的功能。<br>https:&#47;&#47;github.com&#47;elliotchance&#47;orderedmap","like_count":6},{"had_liked":false,"id":342942,"user_name":"flexiver","can_delete":false,"product_type":"c1","uid":2889691,"ip_address":"","ucode":"5D83DFA90826E1","user_header":"","comment_is_top":false,"comment_ctime":1650542814,"is_pvip":false,"replies":[{"id":"125300","content":"在Go项目源码(Go 1.17版本)的 src&#47;cmd&#47;compile&#47;internal&#47;reflectdata&#47;reflect.go中，func MapBucketType(t *types.Type) *types.Type&gt;这个函数实现中，我们可以勾勒出一个bucket桶的结构：<br><br>tophash<br>keys<br>values<br>overflow pointer<br><br>不过这个overflow pointer有两种情况：<br><br>      &#47;&#47; If keys and elems have no pointers, the map implementation<br>      &#47;&#47; can keep a list of overflow pointers on the side so that<br>      &#47;&#47; buckets can be marked as having no pointers.<br>      &#47;&#47; Arrange for the bucket to have no pointers by changing<br>      &#47;&#47; the type of the overflow field to uintptr in this case.<br>      &#47;&#47; See comment on hmap.overflow in runtime&#47;map.go.<br>      otyp := types.Types[types.TUNSAFEPTR]<br>      if !elemtype.HasPointers() &amp;&amp; !keytype.HasPointers() {<br>          otyp = types.Types[types.TUINTPTR]<br>      }<br><br>当key和value中都没有指针时，比如map[int]int。此时考虑到gc优化，编译器将overflow的类型设置为uintptr。<br><br>uintptr是一个整型，无法被GC识别，这样一来uintptr指向的overflow bucket就没有指向它的指针，这样gc就会将overflow bucket视为unrea<br>chable的mem块而将其释放掉。为了避免这种情况，hmap中的extra此时就会指向上面这类bucket的overflow bucket，保证key和value中都不含指针时，overflow bucket依旧可以不被gc。","user_name":"作者回复","comment_id":342942,"uid":"1026224","ip_address":"","utype":1,"ctime":1650608890,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"14535444702","product_id":100093501,"comment_content":"老师，想请问一下，hmap这个结构中的extra字段， 在key和value都不是指针的情况下，会存储所有的overflow bucket的指针，里面有提到一个内联，这个内联是什么意思？以及为什么当key和value都不是指针的情况下，会将bucket中的overflow指针全部放到extra字段存储","like_count":3,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":566130,"discussion_content":"在Go项目源码(Go 1.17版本)的 src/cmd/compile/internal/reflectdata/reflect.go中，func MapBucketType(t *types.Type) *types.Type&gt;这个函数实现中，我们可以勾勒出一个bucket桶的结构：\n\ntophash\nkeys\nvalues\noverflow pointer\n\n不过这个overflow pointer有两种情况：\n\n      // If keys and elems have no pointers, the map implementation\n      // can keep a list of overflow pointers on the side so that\n      // buckets can be marked as having no pointers.\n      // Arrange for the bucket to have no pointers by changing\n      // the type of the overflow field to uintptr in this case.\n      // See comment on hmap.overflow in runtime/map.go.\n      otyp := types.Types[types.TUNSAFEPTR]\n      if !elemtype.HasPointers() &amp;&amp; !keytype.HasPointers() {\n          otyp = types.Types[types.TUINTPTR]\n      }\n\n当key和value中都没有指针时，比如map[int]int。此时考虑到gc优化，编译器将overflow的类型设置为uintptr。\n\nuintptr是一个整型，无法被GC识别，这样一来uintptr指向的overflow bucket就没有指向它的指针，这样gc就会将overflow bucket视为unrea\nchable的mem块而将其释放掉。为了避免这种情况，hmap中的extra此时就会指向上面这类bucket的overflow bucket，保证key和value中都不含指针时，overflow bucket依旧可以不被gc。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650608891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321942,"user_name":"ddh","can_delete":false,"product_type":"c1","uid":2806043,"ip_address":"","ucode":"8E852375365F16","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLBFkSq1oiaEMRjtyyv4ZpCI0OuaSsqs04ODm0OkZF6QhsAh3SvqhxibS2n7PLAVZE3QRSn5Hic0DyXg/132","comment_is_top":false,"comment_ctime":1637114125,"is_pvip":false,"replies":[{"id":"117134","content":"是一个可行方法。","user_name":"作者回复","comment_id":321942,"uid":"1026224","ip_address":"","utype":1,"ctime":1637555959,"user_name_real":"编辑"}],"discussion_count":2,"race_medal":0,"score":"14522016013","product_id":100093501,"comment_content":"把key存到有序切片中，用切片遍历","like_count":4,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532202,"discussion_content":"是一个可行方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637555959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1351076,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","nickname":"lesserror","note":"","ucode":"25A54D1165FCF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531101,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637230154,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329484,"user_name":"文经","can_delete":false,"product_type":"c1","uid":1072346,"ip_address":"","ucode":"2C059BD2A4276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/5c/da/0a8bc27b.jpg","comment_is_top":false,"comment_ctime":1641365885,"is_pvip":true,"replies":[{"id":"120037","content":"过奖。其实原理这东西最终还是要落到代码上。而且不同版本实现也有差异。要想真正把原理吃透，还得自己多过几遍代码","user_name":"作者回复","comment_id":329484,"uid":"1026224","ip_address":"","utype":1,"ctime":1641435032,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"10231300477","product_id":100093501,"comment_content":"我看了《Go语言实践》，《Go专家编程》，《Go语言底层原理剖析》这几本书对map的描述，对比才发现白老师讲得最清晰，在封装和细节方面拿捏得最好，大大地赞👍 剩下不清楚的地方就只能自己看源码了。","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544178,"discussion_content":"过奖。其实原理这东西最终还是要落到代码上。而且不同版本实现也有差异。要想真正把原理吃透，还得自己多过几遍代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641435033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322686,"user_name":"多选参数","can_delete":false,"product_type":"c1","uid":1248326,"ip_address":"","ucode":"B2294D80AB075F","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/46/dfe32cf4.jpg","comment_is_top":false,"comment_ctime":1637550794,"is_pvip":false,"replies":[{"id":"117149","content":"读操作得到的是值的一个copy","user_name":"作者回复","comment_id":322686,"uid":"1026224","ip_address":"","utype":1,"ctime":1637560387,"user_name_real":"编辑"}],"discussion_count":2,"race_medal":0,"score":"10227485386","product_id":100093501,"comment_content":"突然想到之前碰到的一个问题，就是golang 结构体作为map的元素时，不能够直接赋值给结构体的某个字段。这个也有“Go 不允许获取 map 中 value 的地址”的原因在嘛？假如这样的话，那么为什么读结构体中的某个字段是可以的？","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532228,"discussion_content":"读操作得到的是值的一个copy","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637560387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1248326,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0c/46/dfe32cf4.jpg","nickname":"多选参数","note":"","ucode":"B2294D80AB075F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":532520,"discussion_content":"但是读这个操作也是需要涉及到地址的访问吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637634339,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":532228,"ip_address":""},"score":532520,"extra":"{\"user_type\":1}"}]}]},{"had_liked":false,"id":322384,"user_name":"不负青春不负己🤘","can_delete":false,"product_type":"c1","uid":1363671,"ip_address":"","ucode":"A6DD8E8B20EA6E","user_header":"https://static001.geekbang.org/account/avatar/00/14/ce/d7/5315f6ce.jpg","comment_is_top":false,"comment_ctime":1637334390,"is_pvip":true,"replies":[{"id":"117172","content":"✅","user_name":"作者回复","comment_id":322384,"uid":"1026224","ip_address":"","utype":1,"ctime":1637565982,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"10227268982","product_id":100093501,"comment_content":"可以把key 赋值到变量，使用sort 排序，在遍历","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532277,"discussion_content":"✅","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637565982,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346967,"user_name":"Geek_244c46","can_delete":false,"product_type":"c1","uid":2034469,"ip_address":"","ucode":"419D97DA9F1F9B","user_header":"","comment_is_top":false,"comment_ctime":1653565585,"is_pvip":false,"replies":[{"id":"126525","content":"用代码回答你的问题：）<br><br>&#47;&#47; testnilasmapkey.go<br>package main<br><br>func main() {<br>\tvar m = make(map[*int]*int)<br>\tm[nil] = nil<br><br>\tprintln(m)<br>\tprintln(len(m))<br><br>\tvar b = 5<br>\tm[nil] = &amp;b<br>\tp := m[nil]<br>\tprintln(*p)<br><br>}<br><br>0xc0000466b0<br>1<br>5<br><br>nil作为value不新鲜。但nil可作为key可是很多人都不知道的。","user_name":"作者回复","comment_id":346967,"uid":"1026224","ip_address":"","utype":1,"ctime":1653626868,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"5948532881","product_id":100093501,"comment_content":"map的key和value的值，是否可以为null","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573747,"discussion_content":"用代码回答你的问题：）\n\n// testnilasmapkey.go\npackage main\n\nfunc main() {\n\tvar m = make(map[*int]*int)\n\tm[nil] = nil\n\n\tprintln(m)\n\tprintln(len(m))\n\n\tvar b = 5\n\tm[nil] = &amp;b\n\tp := m[nil]\n\tprintln(*p)\n\n}\n\n0xc0000466b0\n1\n5\n\nnil作为value不新鲜。但nil可作为key可是很多人都不知道的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653626868,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":335895,"user_name":"Geek_f654de","can_delete":false,"product_type":"c1","uid":2424712,"ip_address":"","ucode":"252C9BE5989D88","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/QPLkhJ3CoNt0j4ccGovE8tp7ma097vMrKbEq3jefQZNxI6psShxXxqMWTtI4T7oV0Jqq2KnWREnsJwkkZwnJ8Q/132","comment_is_top":false,"comment_ctime":1645759348,"is_pvip":false,"replies":[{"id":"122777","content":"✅","user_name":"作者回复","comment_id":335895,"uid":"1026224","ip_address":"","utype":1,"ctime":1645837734,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"5940726644","product_id":100093501,"comment_content":"思考题：<br>1.把map的key拿出来，放到切片里<br>2.对切片进行排序<br>3.取出切片中元素对应的value","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553300,"discussion_content":"✅","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645837734,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324432,"user_name":"Casper","can_delete":false,"product_type":"c1","uid":1022129,"ip_address":"","ucode":"69282EB175B48E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/98/b1/f89a84d0.jpg","comment_is_top":false,"comment_ctime":1638431723,"is_pvip":true,"replies":[{"id":"117975","content":"go map底层的hash函数要考虑通用性。谁也不能预测用户会使用什么样的key数据。","user_name":"作者回复","comment_id":324432,"uid":"1026224","ip_address":"","utype":1,"ctime":1638829832,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":5,"score":"5933399019","product_id":100093501,"comment_content":"老师，请问一下如果是因为overflow bucket过多导致的&quot;扩容&quot;, 是否可以理解为这个hash函数的算法不太合理，导致大部分的key都分配到了一个bucket中，是否可以通过修改hash算法来重新hash一遍呢？","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536602,"discussion_content":"go map底层的hash函数要考虑通用性。谁也不能预测用户会使用什么样的key数据。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1638829832,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322348,"user_name":"lesserror","can_delete":false,"product_type":"c1","uid":1351076,"ip_address":"","ucode":"25A54D1165FCF6","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","comment_is_top":false,"comment_ctime":1637312553,"is_pvip":false,"replies":[{"id":"117173","content":"1. 引用层次太深，所以用了伪代码形式的简写。就是说hash函数存放在maptype类型中的key字段的alg字段中的hash字段中，key是hash函数的第一个参数，是待hash的字段。第二个参数是种子(hmap.hash0就是种子)。go 1.17中这块的组成发生了一些变化。这个hash函数直接放在maptype的hasher字段中了。但原理应该没有变。<br><br>2. var m map[string]int &amp;#47;&amp;#47; m = nil  你说的是这里么？这里后面注释中不是打印输出，而是指 m为nil。","user_name":"作者回复","comment_id":322348,"uid":"1026224","ip_address":"","utype":1,"ctime":1637566820,"user_name_real":"编辑"}],"discussion_count":4,"race_medal":0,"score":"5932279849","product_id":100093501,"comment_content":"Tony Bai 老师，麻烦有时间回复一下以下几个问题：<br><br>1. 文中说： “map 所用的 hash 函数也存放在 maptype.key.alg.hash(key, hmap.hash0) 中。” 后面的这一串：“maptype.key.alg.hash(key, hmap.hash0) ” 是什么？ 看的有点懵。<br><br>2. 不管是使用字面值 还是用 make函数初始化 map类型变量，打印变量名，都是输出的 map[] 而不是 nil ，这个输出是正常的吗？","like_count":1,"discussions":[{"author":{"id":1896658,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/f0/d2/771a5dca.jpg","nickname":"奔跑的咸鱼","note":"","ucode":"28C2B95415BBF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531971,"discussion_content":"第二个问题感觉是Go语言中不能打印nil出来，我试了一下slice也是直接打印一个[]，而不是nil，可以使用if语句来判别是不是nil","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1637486049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":1,"child_discussions":[{"author":{"id":1351076,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","nickname":"lesserror","note":"","ucode":"25A54D1165FCF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1896658,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/f0/d2/771a5dca.jpg","nickname":"奔跑的咸鱼","note":"","ucode":"28C2B95415BBF7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532061,"discussion_content":"感觉是这样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637507055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":531971,"ip_address":""},"score":532061,"extra":"{\"user_type\":1}"}]},{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532282,"discussion_content":"1. 引用层次太深，所以用了伪代码形式的简写。就是说hash函数存放在maptype类型中的key字段的alg字段中的hash字段中，key是hash函数的第一个参数，是待hash的字段。第二个参数是种子(hmap.hash0就是种子)。go 1.17中这块的组成发生了一些变化。这个hash函数直接放在maptype的hasher字段中了。但原理应该没有变。\n\n2. var m map[string]int &amp;#47;&amp;#47; m = nil  你说的是这里么？这里后面注释中不是打印输出，而是指 m为nil。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1637566820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/e24e181e.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532094,"discussion_content":"第一个问题，我在 go 1.17.3 中发现是多了一个属性 hasher，不是老师这里说的这样了，看文章中笔记","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637512309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322198,"user_name":"AlexWillBeGood","can_delete":false,"product_type":"c1","uid":1505492,"ip_address":"","ucode":"6D7BB91781E38C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/exfIUlVdCpicQPc7fOI6XezUuXd7rayRia7sB2GGHGP7IEBibI6TJbQS2R0bMNejzR1odAIDFP05cWjujrmbIzzwg/132","comment_is_top":false,"comment_ctime":1637230060,"is_pvip":false,"replies":[{"id":"117162","content":"看完第17讲，你就有思路了。","user_name":"作者回复","comment_id":322198,"uid":"1026224","ip_address":"","utype":1,"ctime":1637564760,"user_name_real":"编辑"}],"discussion_count":4,"race_medal":0,"score":"5932197356","product_id":100093501,"comment_content":"老师，有一点我不明白，为什么kv 紧邻存储的时候一定需要Padding？","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532262,"discussion_content":"看完第17讲，你就有思路了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637564760,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1263587,"avatar":"","nickname":"Celebi","note":"","ucode":"443499E71435E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531210,"discussion_content":"看CSAPP这本书。cpu是按字长读数据的，内存对齐cpu效率高","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1637247790,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2119325,"avatar":"https://static001.geekbang.org/account/avatar/00/20/56/9d/4b2a7d29.jpg","nickname":"ryanxw","note":"","ucode":"0B91EAC8D06EED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":563798,"discussion_content":"cpu对齐原则","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650079949,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1505492,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/exfIUlVdCpicQPc7fOI6XezUuXd7rayRia7sB2GGHGP7IEBibI6TJbQS2R0bMNejzR1odAIDFP05cWjujrmbIzzwg/132","nickname":"AlexWillBeGood","note":"","ucode":"6D7BB91781E38C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531340,"discussion_content":"多谢 下一课好像给出了答案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637289302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322024,"user_name":"高雪斌","can_delete":false,"product_type":"c1","uid":2827964,"ip_address":"","ucode":"75E9F13CB7C66D","user_header":"https://static001.geekbang.org/account/avatar/00/2b/26/bc/18314557.jpg","comment_is_top":false,"comment_ctime":1637140079,"is_pvip":false,"replies":[{"id":"117141","content":"不错的思路。","user_name":"作者回复","comment_id":322024,"uid":"1026224","ip_address":"","utype":1,"ctime":1637556678,"user_name_real":"编辑"}],"discussion_count":2,"race_medal":0,"score":"5932107375","product_id":100093501,"comment_content":"func doIteration(m map[int]int) {<br>\tmu.RLock()<br>\tdefer mu.RUnlock()<br><br>\tkeys := []int{}<br><br>\tfor k := range m {<br>\t\tkeys = append(keys, k)<br>\t}<br><br>\tsort.SliceStable(keys, func(x, y int) bool {<br>\t\treturn x &lt; y<br>\t})<br><br>\tfor _, k := range keys {<br>\t\tfmt.Printf(&quot;[%d, %d] &quot;, k, m[k])<br>\t}<br><br>\tfmt.Println()<br>}<br><br>func doWrite(m map[int]int) {<br>\tmu.Lock()<br>\tdefer mu.Unlock()<br><br>\tfor k, v := range m {<br>\t\tm[k] = v + 1<br>\t}<br>}<br><br>==&gt; 对并发示例代码的稳定排序输出 (原例1000次输出太多，输出前10个作为说明)：<br>[1, 11] [2, 12] [3, 13] <br>[1, 12] [2, 13] [3, 14] <br>[1, 13] [2, 14] [3, 15] <br>[1, 14] [2, 15] [3, 16] <br>[1, 15] [2, 16] [3, 17] <br>[1, 16] [2, 17] [3, 18] <br>[1, 17] [2, 18] [3, 19] <br>[1, 18] [2, 19] [3, 20] <br>[1, 19] [2, 20] [3, 21] <br>[1, 20] [2, 21] [3, 22] <br>。。。","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532211,"discussion_content":"不错的思路。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637556678,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2827964,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/26/bc/18314557.jpg","nickname":"高雪斌","note":"","ucode":"75E9F13CB7C66D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530774,"discussion_content":"不好意思，稳定排序勘误：\n\tsort.SliceStable(keys, func(x, y int) bool {\n\t\treturn keys[x] &lt; keys[y]\n\t})","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1637145244,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322001,"user_name":"Geek_0b92d9","can_delete":false,"product_type":"c1","uid":2835237,"ip_address":"","ucode":"9212443F63B64B","user_header":"","comment_is_top":false,"comment_ctime":1637133341,"is_pvip":true,"replies":[{"id":"117139","content":"var m map[string]int &amp;#47;&amp;#47; m = nil 注释中的m = nil 是提示m的值为nil，不是打印输出。","user_name":"作者回复","comment_id":322001,"uid":"1026224","ip_address":"","utype":1,"ctime":1637556310,"user_name_real":"编辑"}],"discussion_count":2,"race_medal":0,"score":"5932100637","product_id":100093501,"comment_content":"老师好。我是 go1.16.2 版本<br><br>var m map[string]int 定义后， 打印 m , 是 map[]，不是 nil","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532208,"discussion_content":"var m map[string]int &amp;#47;&amp;#47; m = nil 注释中的m = nil 是提示m的值为nil，不是打印输出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637556310,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2049562,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/aQmhiahazRFUA4W3r1hdxxreSB5Pl54IwAJ8bwN6j02lzicydWAfPFbWx1LSFtzXH8MkI0jUKjlpUtmQBoZ4kReA/132","nickname":"Geek_99b47c","note":"","ucode":"D25E22C1D84E09","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530738,"discussion_content":"fmt.Println(m == nil)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637136426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321999,"user_name":"return","can_delete":false,"product_type":"c1","uid":1135528,"ip_address":"","ucode":"42B8A3380DF04B","user_header":"https://static001.geekbang.org/account/avatar/00/11/53/a8/abc96f70.jpg","comment_is_top":false,"comment_ctime":1637132794,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5932100090","product_id":100093501,"comment_content":"老师讲的太好了，","like_count":1},{"had_liked":false,"id":321975,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1637123280,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5932090576","product_id":100093501,"comment_content":"使用链表存储可以得到有序的Map。有了描述符，再也不用担心传递性能问题了！原来多个bucket是为了降低Hash冲突，虽然一个bucket和多个bucket在查找Key时时间复杂度都是O(1)，但一个Bucket遇到Hash冲突的可能性要比多个高出很多。","like_count":1},{"had_liked":false,"id":360170,"user_name":"不说话装糕手","can_delete":false,"product_type":"c1","uid":2922271,"ip_address":"北京","ucode":"6465E83F4E6F58","user_header":"https://static001.geekbang.org/account/avatar/00/2c/97/1f/2a68c980.jpg","comment_is_top":false,"comment_ctime":1666252089,"is_pvip":false,"replies":[{"id":"131025","content":"看了一下你改后的代码，你把doIteration这个goroutine注释掉了，只保留了doWrite这个goroutine，这样就没有了并发，就剩下执行doWrite这一个goroutine访问map了。","user_name":"作者回复","comment_id":360170,"uid":"1026224","ip_address":"北京","utype":1,"ctime":1666335447,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1666252089","product_id":100093501,"comment_content":"关于老师并发读写map的示例，做了如下修改<br>\t&#47;&#47;go func() {<br>\t&#47;&#47;\tfor i := 0; i &lt; 1000; i++ {<br>\t&#47;&#47;\t\tdoIteration(m)<br>\t&#47;&#47;\t}<br>\t&#47;&#47;}()<br><br>\tgo func() {<br>\t\tfor i := 0; i &lt; 10000; i++ {<br>\t\t\tdoWrite(m)<br>\t\t}<br>\t}()<br><br>\ttime.Sleep(5 * time.Second)<br>\tfmt.Println(m)<br>\t<br>output:<br>map[1:10011 2:10012 3:10013]<br>进程 已完成，退出代码为 0<br><br>我本地是1.16版本，看起来是可以并发写的？","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591159,"discussion_content":"看了一下你改后的代码，你把doIteration这个goroutine注释掉了，只保留了doWrite这个goroutine，这样就没有了并发，就剩下执行doWrite这一个goroutine访问map了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666335447,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359173,"user_name":"pythonbug","can_delete":false,"product_type":"c1","uid":1487274,"ip_address":"辽宁","ucode":"1A70CA92FFF8EB","user_header":"https://wx.qlogo.cn/mmopen/vi_32/wgMMrp1hvSB3E30KqZvMsj3KQdAI3T1uQM77LT7hZ65nVSjPGRg3AbUOyiahnssA6AIT5PAkyHFmlTBzUH9gdyQ/132","comment_is_top":false,"comment_ctime":1665305666,"is_pvip":true,"replies":[{"id":"130656","content":"✅","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1665378297,"ip_address":"辽宁","comment_id":359173,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1665305666","product_id":100093501,"comment_content":"func sortMap(m map[string]int) {<br>\t&#47;&#47; 存key<br>\tvar s []string<br>\tfor k, _ := range m {<br>\t\ts = append(s, k)<br>\t}<br><br>\t&#47;&#47; 对s进行排序<br>\tsort.Strings(s)<br><br>\t&#47;&#47; 遍历输出<br>\tfor _, v := range s {<br>\t\tfmt.Println(v, m[v])<br>\t}<br>}","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589870,"discussion_content":"✅","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665378297,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":357183,"user_name":"微微超级丹💫","can_delete":false,"product_type":"c1","uid":2996016,"ip_address":"辽宁","ucode":"ABEFC2FA673BE4","user_header":"https://static001.geekbang.org/account/avatar/00/2d/b7/30/c1e4f5b5.jpg","comment_is_top":false,"comment_ctime":1663047552,"is_pvip":false,"replies":[{"id":"130006","content":"maptype代表的是类型信息，比如声明两个相同类型的map变量：<br><br>var m map[string]int<br>var m1 map[string]int<br><br>当首次声明类型为map[string]int类型的m时，go运行时会创建对应map[string]int类型的maptype实例。<br><br>当再次声明类型为map[string]int类型的m1时，go运行时会复用上面的maptype。因为类型一致。<br><br>元素个数与map类型信息没有直接关系，元素个数属于map类型的变量的“属性”范畴，不是类型范畴。<br>","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1663099232,"ip_address":"辽宁","comment_id":357183,"utype":1}],"discussion_count":1,"race_medal":3,"score":"1663047552","product_id":100093501,"comment_content":"麻烦问下老师：<br>&quot;当我们声明一个 map 类型变量，比如 var m map[string]int 时，Go 运行时就会为这个变量对应的特定 map 类型，生成一个 runtime.maptype 实例。如果这个实例已经存在，就会直接复用&quot;<br>这个直接复用没有理解？每个实例怎么能复用呢？他们的原信息是不能共享的呀？每个map不是都有自己的原信息吗？比如元素个数之类的都是不一样的呀","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587491,"discussion_content":"maptype代表的是类型信息，比如声明两个相同类型的map变量：\n\nvar m map[string]int\nvar m1 map[string]int\n\n当首次声明类型为map[string]int类型的m时，go运行时会创建对应map[string]int类型的maptype实例。\n\n当再次声明类型为map[string]int类型的m1时，go运行时会复用上面的maptype。因为类型一致。\n\n元素个数与map类型信息没有直接关系，元素个数属于map类型的变量的“属性”范畴，不是类型范畴。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663099232,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":354658,"user_name":"Geek_d86547","can_delete":false,"product_type":"c1","uid":2969563,"ip_address":"北京","ucode":"AD9AE8FEF6B307","user_header":"","comment_is_top":false,"comment_ctime":1660643265,"is_pvip":false,"replies":[{"id":"129071","content":"你看看https:&#47;&#47;tonybai.com&#47;go-course-faq中的补充是否满足你的需求。","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1660789226,"ip_address":"北京","comment_id":354658,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1660643265","product_id":100093501,"comment_content":"老师 map遍历的随机性可以再详细说明一些嘛？","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584364,"discussion_content":"你看看https://tonybai.com/go-course-faq中的补充是否满足你的需求。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660789226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":353617,"user_name":"白小白","can_delete":false,"product_type":"c1","uid":1031680,"ip_address":"北京","ucode":"2CCB878DA2E93D","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/pESfAX6YVRnVg3HpOX44bTa64bHTbhsnlHJqqDjicBeELxCs5rwwIXibFibd0fua3VyVExypnqnfgTSUp8WoYmc9g/132","comment_is_top":false,"comment_ctime":1659605086,"is_pvip":false,"replies":[{"id":"128701","content":"map的实现原理决定了我们无法做到。除非在map之外在自行包一层。","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1659925029,"ip_address":"北京","comment_id":353617,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1659605086","product_id":100093501,"comment_content":"如何保证每次读取map的值是有序的？","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583128,"discussion_content":"map的实现原理决定了我们无法做到。除非在map之外在自行包一层。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659925029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":353163,"user_name":"功夫熊猫","can_delete":false,"product_type":"c1","uid":2732243,"ip_address":"江苏","ucode":"D124F4FA4E816F","user_header":"https://static001.geekbang.org/account/avatar/00/29/b0/d3/200e82ff.jpg","comment_is_top":false,"comment_ctime":1659205131,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1659205131","product_id":100093501,"comment_content":"其实就是LRU类似的事情，用链表或者切片来办","like_count":0},{"had_liked":false,"id":351317,"user_name":"zzy","can_delete":false,"product_type":"c1","uid":1805408,"ip_address":"","ucode":"3D7EC623EB8204","user_header":"https://static001.geekbang.org/account/avatar/00/1b/8c/60/58b6c39e.jpg","comment_is_top":false,"comment_ctime":1657696721,"is_pvip":true,"replies":[{"id":"127789","content":"关于你提到的go内置类型map的实现的选型问题，我还真不清楚。我在公开资料里搜了一下，也没查到。不过我觉得，go team当初应该不单单是从性能这一个维度考虑的。毕竟是runtime层的实现，而不是一个单独的标准库包。","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1657709981,"ip_address":"","comment_id":351317,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1657696721","product_id":100093501,"comment_content":"想问下golang为何不像java那样，在底层使用红黑树，性能应该是更好的","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579834,"discussion_content":"关于你提到的go内置类型map的实现的选型问题，我还真不清楚。我在公开资料里搜了一下，也没查到。不过我觉得，go team当初应该不单单是从性能这一个维度考虑的。毕竟是runtime层的实现，而不是一个单独的标准库包。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657709981,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351301,"user_name":"菠萝吹雪—Code","can_delete":false,"product_type":"c1","uid":1650378,"ip_address":"","ucode":"A5B2FC661EE17D","user_header":"https://static001.geekbang.org/account/avatar/00/19/2e/ca/469f7266.jpg","comment_is_top":false,"comment_ctime":1657683928,"is_pvip":true,"replies":[{"id":"127784","content":"✅","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1657699933,"ip_address":"","comment_id":351301,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1657683928","product_id":100093501,"comment_content":"彩！只要key是有序的并且访问顺序是固定的，value也就可以确定顺序了，通过切片、数组可以实现","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579813,"discussion_content":"✅","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657699933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":349269,"user_name":"W-T","can_delete":false,"product_type":"c1","uid":1088973,"ip_address":"","ucode":"834869DA80D95B","user_header":"https://static001.geekbang.org/account/avatar/00/10/9d/cd/c21a01dd.jpg","comment_is_top":false,"comment_ctime":1655860607,"is_pvip":true,"replies":[{"id":"127149","content":"不需要实现什么接口。只要自定义数据类型的底层类型(underlying type)是支持for range即可，比如切片、channel、数组、map等。<br><br>比如：<br><br>type Rangable []int<br><br>func main() {<br>\tvar r = Rangable{1, 2, 3, 4, 5, 6}<br>\tfor _, n := range r {<br>\t\tprintln(n)<br>\t}<br>}","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1655905733,"ip_address":"","comment_id":349269,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1655860607","product_id":100093501,"comment_content":"老师，自定义数据类型能否支持for range语句，支持的话需要实现什么接口","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577060,"discussion_content":"不需要实现什么接口。只要自定义数据类型的底层类型(underlying type)是支持for range即可，比如切片、channel、数组、map等。\n\n比如：\n\ntype Rangable []int\n\nfunc main() {\n\tvar r = Rangable{1, 2, 3, 4, 5, 6}\n\tfor _, n := range r {\n\t\tprintln(n)\n\t}\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655905734,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":349034,"user_name":"撇撇","can_delete":false,"product_type":"c1","uid":1010786,"ip_address":"","ucode":"938305F9F3F19C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6c/62/cbb91635.jpg","comment_is_top":false,"comment_ctime":1655660557,"is_pvip":false,"replies":[{"id":"127032","content":"hmap是描述map整体的，唯一代表一个map实例。而maptype则是用来描述一个map中的key和value的信息的，包括类型、大小等。用于辅助针对hmap的各种操作。","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1655705629,"ip_address":"","comment_id":349034,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1655660557","product_id":100093501,"comment_content":"maptype和hmap都是元信息，为什么需要两个？","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576618,"discussion_content":"hmap是描述map整体的，唯一代表一个map实例。而maptype则是用来描述一个map中的key和value的信息的，包括类型、大小等。用于辅助针对hmap的各种操作。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1655705629,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1010786,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/6c/62/cbb91635.jpg","nickname":"撇撇","note":"","ucode":"938305F9F3F19C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":577650,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656262120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":576618,"ip_address":""},"score":577650,"extra":""}]}]},{"had_liked":false,"id":347956,"user_name":"Geek_25f93f","can_delete":false,"product_type":"c1","uid":2917509,"ip_address":"","ucode":"D5932373E8EEA2","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/5JKZO1Ziax3Ky03noshpVNyEvZw0pUwjLcHrHRo1XNPKXdmCE88homb6ltA15CdVRnjzjgGs3Ex42CaDbeYzNuQ/132","comment_is_top":false,"comment_ctime":1654607140,"is_pvip":true,"replies":[{"id":"126851","content":"map的key的类型不一，使用的hash函数可能不同。这个由编译器和运行时决定。但hash算法都在runtime包的alg.go中，可以自己看一下。","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1654762502,"ip_address":"","comment_id":347956,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1654607140","product_id":100093501,"comment_content":"想问下go map使用什么哈希算法算出哈希值的吗？","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575344,"discussion_content":"map的key的类型不一，使用的hash函数可能不同。这个由编译器和运行时决定。但hash算法都在runtime包的alg.go中，可以自己看一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654762503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343375,"user_name":"Geek_as","can_delete":false,"product_type":"c1","uid":1534500,"ip_address":"","ucode":"AB7B70DBC2B5F8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/qhonwcQle1RBufvLdTm4MgSNl554GBXUZtNNH65oYajbbRLxKsZX4hM9vFtrLLpDM0H93ZNWRFAZSrIZC7yAsQ/132","comment_is_top":false,"comment_ctime":1650805633,"is_pvip":true,"replies":[{"id":"125441","content":"✅","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1651011627,"ip_address":"","comment_id":343375,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1650805633","product_id":100093501,"comment_content":"弄一个链表元素是key类型，记录key插入的顺序，遍历的时候按这个key顺序去取就行了","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":567822,"discussion_content":"✅","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651011627,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342974,"user_name":"mikewoo","can_delete":false,"product_type":"c1","uid":1118888,"ip_address":"","ucode":"9AE90E05048DE1","user_header":"https://static001.geekbang.org/account/avatar/00/11/12/a8/8aaf13e0.jpg","comment_is_top":false,"comment_ctime":1650556765,"is_pvip":true,"replies":[{"id":"125294","content":"✅","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1650601609,"ip_address":"","comment_id":342974,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1650556765","product_id":100093501,"comment_content":"单独对map中的key进行有序存储，然后再依据key的次序依次获取map中key对应的value.","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":566097,"discussion_content":"✅","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650601609,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342852,"user_name":"莫得办法","can_delete":false,"product_type":"c1","uid":1073958,"ip_address":"","ucode":"D3E07A4CFD1AAA","user_header":"https://static001.geekbang.org/account/avatar/00/10/63/26/8c8be018.jpg","comment_is_top":false,"comment_ctime":1650507310,"is_pvip":false,"replies":[{"id":"125290","content":"无论查询还是写入，都是先选桶，再在桶内匹配。如果出现碰撞，是要比较key的。从原理上看，一个桶内是可能存在tophash一样的key。","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1650596617,"ip_address":"","comment_id":342852,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1650507310","product_id":100093501,"comment_content":"想问一下如果出现哈希碰撞，存储过程和查询过程是咋样的呢？","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":566083,"discussion_content":"无论查询还是写入，都是先选桶，再在桶内匹配。如果出现碰撞，是要比较key的。从原理上看，一个桶内是可能存在tophash一样的key。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650596617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342168,"user_name":"ryanxw","can_delete":false,"product_type":"c1","uid":2119325,"ip_address":"","ucode":"0B91EAC8D06EED","user_header":"https://static001.geekbang.org/account/avatar/00/20/56/9d/4b2a7d29.jpg","comment_is_top":false,"comment_ctime":1650079817,"is_pvip":false,"replies":[{"id":"125045","content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1650108704,"ip_address":"","comment_id":342168,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1650079817","product_id":100093501,"comment_content":"把key存到arr中，按照顺序根据key去map中取value","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":563899,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650108704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":340974,"user_name":"大帅哥","can_delete":false,"product_type":"c1","uid":1439523,"ip_address":"","ucode":"E6AE4804D9F337","user_header":"","comment_is_top":false,"comment_ctime":1649251038,"is_pvip":false,"replies":[{"id":"124705","content":"如果在扩容过程中，那么新插入数据会触发迁移过程。如果key原先没有，则会直接在新buckets中，如果有，则会重新计算它在新buckets中的位置，然后写入新buckets中。原bucket标记为已迁移。<br><br> 迁移过程的比较繁琐，要想真正理解，还得自己read一下 runtime.mapassign的代码。","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1649393835,"ip_address":"","comment_id":340974,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1649251038","product_id":100093501,"comment_content":"想问一下，当map扩容后，有新的数据插入是，如果此时数据还没有迁移到新的bucket中，那么runtime是怎么知道这个可以是在olderbuckets和buckets的具体位置的，是不是计算规则不一样，但是这个规则具体是怎么样的？","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560571,"discussion_content":"如果在扩容过程中，那么新插入数据会触发迁移过程。如果key原先没有，则会直接在新buckets中，如果有，则会重新计算它在新buckets中的位置，然后写入新buckets中。原bucket标记为已迁移。\n\n 迁移过程的比较繁琐，要想真正理解，还得自己read一下 runtime.mapassign的代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649393835,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":337533,"user_name":"随风wli","can_delete":false,"product_type":"c1","uid":1932930,"ip_address":"","ucode":"655BD9182D7570","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/OEZQyDeZd2oCPZiak19FKQOZI4I21WjLlwUgJzVFxyXsVKbIlpEEEYZcHbA4lYVzFbd3CtmDfZuUictW3ujvKnUQ/132","comment_is_top":false,"comment_ctime":1646881660,"is_pvip":false,"replies":[{"id":"123365","content":"切片的引用是slice的runtime结构体(三元组)实例，map的引用是hmap类型的指针。文中后续我让编辑老师再修改一下，明确说明是hmap的指针。","user_name":"作者回复","user_name_real":"作者","uid":"1026224","ctime":1646950225,"ip_address":"","comment_id":337533,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1646881660","product_id":100093501,"comment_content":"老师，go map 和 slice make返回都是引用，这个是指hmap和slice结构体的指针吗？这块一直有点困惑，希望解答一下","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555512,"discussion_content":"切片的引用是slice的runtime结构体(三元组)实例，map的引用是hmap类型的指针。文中后续我让编辑老师再修改一下，明确说明是hmap的指针。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646950225,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":337105,"user_name":"Rayjun","can_delete":false,"product_type":"c1","uid":1002514,"ip_address":"","ucode":"61A3D1A3D03569","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4c/12/f0c145d4.jpg","comment_is_top":false,"comment_ctime":1646624838,"is_pvip":true,"replies":[{"id":"123245","content":"在runtime实现层面，hmap结构体中的buckets是一个unsafe.Pointer，它是一个指向bucket“数组”的指针。这个“数组”不是go语法层面的数组，是一个组合体。每个数组元素是由bmap、keys数组、values数组和overflow指针组成（看图）。go runtime是知道每个key、value的类型的，也就知道了每个key和value的size，runtime只要按size分配对应的内存块即可，其操作并不是通过数组语法进行的，而是通过指针运算得到的偏移值。","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1646724496,"ip_address":"","comment_id":337105,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1646624838","product_id":100093501,"comment_content":" 老师，问一下关于 bucket 的问题，既然 bucket 是数组，如果 key 和 value 的类型不一样，要怎么存储呢？而且下面还需要存储 overflow bucket 的指针","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555029,"discussion_content":"在runtime实现层面，hmap结构体中的buckets是一个unsafe.Pointer，它是一个指向bucket“数组”的指针。这个“数组”不是go语法层面的数组，是一个组合体。每个数组元素是由bmap、keys数组、values数组和overflow指针组成（看图）。go runtime是知道每个key、value的类型的，也就知道了每个key和value的size，runtime只要按size分配对应的内存块即可，其操作并不是通过数组语法进行的，而是通过指针运算得到的偏移值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646724496,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":337016,"user_name":"simple_孙","can_delete":false,"product_type":"c1","uid":1873629,"ip_address":"","ucode":"A77203E242D652","user_header":"https://static001.geekbang.org/account/avatar/00/1c/96/dd/1620a744.jpg","comment_is_top":false,"comment_ctime":1646553557,"is_pvip":false,"replies":[{"id":"123238","content":"随机的设定是go团队故意而为之。<br>go在标准库中增加了一个sync.Map，支持并发写。","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1646722608,"ip_address":"","comment_id":337016,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1646553557","product_id":100093501,"comment_content":"为啥map的遍历顺序是随机的呢<br>现在有并发安全的map用吗","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555019,"discussion_content":"随机的设定是go团队故意而为之。\ngo在标准库中增加了一个sync.Map，支持并发写。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646722608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":335259,"user_name":"1⃣️","can_delete":false,"product_type":"c1","uid":1375706,"ip_address":"","ucode":"DDD1B98F90281C","user_header":"https://static001.geekbang.org/account/avatar/00/14/fd/da/7e0f0a02.jpg","comment_is_top":false,"comment_ctime":1645430498,"is_pvip":true,"replies":[{"id":"122614","content":"受goroutine并发调度影响。遍历次数越多，出现并发写导致抛panic的概率越大。","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1645605549,"ip_address":"","comment_id":335259,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1645430498","product_id":100093501,"comment_content":"请问一下，为啥需要例子中需要遍历1000次才能出现并发读写的错误，但遍历100次不会？","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552828,"discussion_content":"受goroutine并发调度影响。遍历次数越多，出现并发写导致抛panic的概率越大。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645605550,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":334370,"user_name":"郭纯","can_delete":false,"product_type":"c1","uid":1314521,"ip_address":"","ucode":"2613860B4642C4","user_header":"https://static001.geekbang.org/account/avatar/00/14/0e/d9/e61ce097.jpg","comment_is_top":false,"comment_ctime":1644904100,"is_pvip":false,"replies":[{"id":"122145","content":"正确✅","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1644916006,"ip_address":"","comment_id":334370,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1644904100","product_id":100093501,"comment_content":"可以通过 slice 或者 数组 配合 map 实现。","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551169,"discussion_content":"正确✅","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644916006,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332952,"user_name":"Geek_2337af","can_delete":false,"product_type":"c1","uid":2847330,"ip_address":"","ucode":"54B135EB7E70F1","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep7c7UKsjRiclaAqD9vMHSUXayzrvRhvic3Lm6ibX82L3DibJnCCtDmB3OfxbuVjetpT6Qa8IuwqZCWlw/132","comment_is_top":false,"comment_ctime":1643876873,"is_pvip":false,"replies":[{"id":"121804","content":"不支持的。","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1644290895,"ip_address":"","comment_id":332952,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1643876873","product_id":100093501,"comment_content":"go是否支持利用自定义的哈希函数创建map呢","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549906,"discussion_content":"不支持的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644290895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332436,"user_name":"Niverkk","can_delete":false,"product_type":"c1","uid":2179875,"ip_address":"","ucode":"F9220C10107E44","user_header":"https://static001.geekbang.org/account/avatar/00/21/43/23/d98fb8f7.jpg","comment_is_top":false,"comment_ctime":1643250525,"is_pvip":true,"replies":[{"id":"121620","content":"1. 是的<br>2. 记得讲结构体类型那一讲有说过内存对齐的意义<br>3. 一次性迁移 会导致map操作的延迟较大，所以要逐步迁移，有点像蚂蚁搬家，一点点弄，将较大的消耗分担到多次操作中。一旦开始迁移，不论是assign还是delete都会进行分担部分迁移操作，这和assign还是delete的语义无关。","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1643544134,"ip_address":"","comment_id":332436,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1643250525","product_id":100093501,"comment_content":"老师好，有几个问题请教下<br>问题1：<br>1.v := m[&quot;key&quot;] → v := runtime.mapaccess1(maptype, m, &quot;key&quot;)<br>2.v, ok := m[&quot;key&quot;] → v, ok := runtime.mapaccess2(maptype, m, &quot;key&quot;)<br>其实这两种写法调用的底层方法是不一样的，2他会返回两个值，v是对应的value， ok代表key是否存在于map中？<br><br>问题2：<br>value存储区域kv格式为什么需要对齐？<br><br>问题3：<br>如果是因为当前数据数量超出 LoadFactor 指定水位而进行的扩容，那么运行时会建立一个两倍于现有规模的 bucket 数组，但真正的排空和迁移工作也是在 assign 和 delete 时逐步进行的。<br><br>对于这段话，逐步迁移是什么意思？assign代表增加吗？删除跟扩容有关系吗，删除应该是影响缩容吧？","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549082,"discussion_content":"1. 是的\n2. 记得讲结构体类型那一讲有说过内存对齐的意义\n3. 一次性迁移 会导致map操作的延迟较大，所以要逐步迁移，有点像蚂蚁搬家，一点点弄，将较大的消耗分担到多次操作中。一旦开始迁移，不论是assign还是delete都会进行分担部分迁移操作，这和assign还是delete的语义无关。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643544134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331918,"user_name":"天敌","can_delete":false,"product_type":"c1","uid":1059944,"ip_address":"","ucode":"CD29A622197197","user_header":"https://static001.geekbang.org/account/avatar/00/10/2c/68/c299bc71.jpg","comment_is_top":false,"comment_ctime":1642882511,"is_pvip":false,"replies":[{"id":"121614","content":"tophash [bucketCnt]uint8  &#47;&#47; tophash存储了一组偏移值<br><br>如果两个key的hashcode完全一样，那么这两个key会分配到一个bucket中。","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1643542590,"ip_address":"","comment_id":331918,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1642882511","product_id":100093501,"comment_content":"老师, tophash区域存的是指针吗？当两个key的hashcode完全一样又是如何处理的？","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549074,"discussion_content":"tophash [bucketCnt]uint8  // tophash存储了一组偏移值\n\n如果两个key的hashcode完全一样，那么这两个key会分配到一个bucket中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643542590,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325537,"user_name":"张申傲","can_delete":false,"product_type":"c1","uid":1182372,"ip_address":"","ucode":"22D46BC529BA8A","user_header":"https://static001.geekbang.org/account/avatar/00/12/0a/a4/828a431f.jpg","comment_is_top":false,"comment_ctime":1639017510,"is_pvip":true,"replies":[{"id":"118606","content":"没迁移完肯定不会释放。但我记得迁移好像也不是只迁移命中的key。命中的key肯定会迁移，但在一次迁移过程中，还会迁移其他key。具体你看一下源码确认一下吧。","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1639564153,"ip_address":"","comment_id":325537,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1639017510","product_id":100093501,"comment_content":"老师好，请教个问题：在 map 进行自动扩容时，真正的元素迁移是在 assign 和 delete 时逐步进行的，这个我理解是将数据迁移的开销分摊到多次读写操作中，以减少扩容时的性能损耗。但是如果某些 key 一直没有被访问到，那么 oldbuckets 是一直不会释放吗？","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538960,"discussion_content":"没迁移完肯定不会释放。但我记得迁移好像也不是只迁移命中的key。命中的key肯定会迁移，但在一次迁移过程中，还会迁移其他key。具体你看一下源码确认一下吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639564153,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325261,"user_name":"lemon","can_delete":false,"product_type":"c1","uid":2323716,"ip_address":"","ucode":"47626025C55E5E","user_header":"https://static001.geekbang.org/account/avatar/00/23/75/04/d26cd437.jpg","comment_is_top":false,"comment_ctime":1638883526,"is_pvip":false,"replies":[{"id":"118591","content":"从源码中看是这样：m := bucketMask(h.B)","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1639560275,"ip_address":"","comment_id":325261,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1638883526","product_id":100093501,"comment_content":"老师，“每个 bucket 中存储的是 Hash 值低 bit 位数值相同的元素”这里，应该是Hash 值低 B bit 位吧?【B是指hmap中的B】，也就落在哪个bucket里是由Hash值的低 B bit 位决定的，bucket的数量也正好是2^B个，比如B=3，那么Hash为...011的key就落在011=3也就是索引为3的bucket内，另外有张图那里Hash值也不是就分为了高位区和低位区，实际上高位区是8位，低位区是B位，中间可能还有别的位，不知道理解的对不对","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538939,"discussion_content":"从源码中看是这样：m := bucketMask(h.B)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639560276,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":323779,"user_name":"文经","can_delete":false,"product_type":"c1","uid":1072346,"ip_address":"","ucode":"2C059BD2A4276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/5c/da/0a8bc27b.jpg","comment_is_top":false,"comment_ctime":1638158532,"is_pvip":true,"replies":[{"id":"117583","content":"这种方式不是函数，这就是go的语法。go编译器会处理这种语法，翻译为对应的处理代码。你只需要知道其语义是啥就可以了，然后用就ok了。","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1638262768,"ip_address":"","comment_id":323779,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1638158532","product_id":100093501,"comment_content":"v, ok := m[&quot;key1&quot;]<br>v := m[&quot;key1&quot;]<br>白老师，这两种方式都可以，请问comma，OK， 这种方式是函数实现的吗？如果是函数的话，怎么一个函数可以同时返回一个值，或者两个值？ channel也有类似的用法，不太理解。<br>","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534722,"discussion_content":"这种方式不是函数，这就是go的语法。go编译器会处理这种语法，翻译为对应的处理代码。你只需要知道其语义是啥就可以了，然后用就ok了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638262768,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":323776,"user_name":"文经","can_delete":false,"product_type":"c1","uid":1072346,"ip_address":"","ucode":"2C059BD2A4276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/5c/da/0a8bc27b.jpg","comment_is_top":false,"comment_ctime":1638158050,"is_pvip":true,"replies":[{"id":"117587","content":"切片类型也不是在所有场景下都是零值可用的啊。<br><br>var sl []int<br>sl[0] = 13 &#47;&#47; panic<br><br>sl = append(sl, 13) &#47;&#47; ok<br><br>但map没有append，只有m[k]=v，这样当map变量没有初始化的时候，只能panic。<br><br>所谓它内部实现的复杂性，就是go没有提供类似append的内置函数来支持零值的map。<br><br>","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1638265255,"ip_address":"","comment_id":323776,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1638158050","product_id":100093501,"comment_content":"&quot;但 map 类型，因为它内部实现的复杂性，无法“零值可用”。所以，如果我们对处于零值状态的 map 变量直接进行操作，就会导致运行时异常（panic），从而导致程序进程异常退出。&quot;<br><br>白老师，我理解零值可用，既可以把变量当做nil来使用，又可以当做一个初始化好的对象来使用。这样对吗？有两个进一步的疑问<br>1. slice 的零值初始化是怎么实现的，编译器和运行时分别扮演了什么角色。<br>2. map的零值初始化难在哪里，按照我的理解，只要在编译的时候判断是否为nil，运行的时候发现它是nil，给它分配一个对象就可以了。肯定是我遗漏了哪些重要的信息，请白老师解惑。","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534733,"discussion_content":"切片类型也不是在所有场景下都是零值可用的啊。\n\nvar sl []int\nsl[0] = 13 // panic\n\nsl = append(sl, 13) // ok\n\n但map没有append，只有m[k]=v，这样当map变量没有初始化的时候，只能panic。\n\n所谓它内部实现的复杂性，就是go没有提供类似append的内置函数来支持零值的map。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638265255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322857,"user_name":"多选参数","can_delete":false,"product_type":"c1","uid":1248326,"ip_address":"","ucode":"B2294D80AB075F","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/46/dfe32cf4.jpg","comment_is_top":false,"comment_ctime":1637635327,"is_pvip":false,"replies":[{"id":"117552","content":"其实就是go map的设计决定了既不能获取value的地址，也不能并发写。","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1638256132,"ip_address":"","comment_id":322857,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1637635327","product_id":100093501,"comment_content":"问题再问：golang 结构体作为 map 的元素时，不能够直接赋值给结构体的某个字段。这个也有“Go 不允许获取 map 中 value 的地址”的原因在嘛？假如这样的话，那么为什么读结构体中的某个字段是可以的？因为读和写结构体中某个字段的时候都会涉及到获取 map 中 value 的地址，而此时读操作是允许的，而写操作是不允许的。有没有可能是因为 map 不支持并发，假如是写操作的话，会存在一些并发带来的问题，而读操作不存在这些问题？","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534674,"discussion_content":"其实就是go map的设计决定了既不能获取value的地址，也不能并发写。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638256132,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2323716,"avatar":"https://static001.geekbang.org/account/avatar/00/23/75/04/d26cd437.jpg","nickname":"lemon","note":"","ucode":"47626025C55E5E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536866,"discussion_content":"&#34;不能获取value的地址&#34;会不会是因为设计者不想让我们用这个地址值去进行运算之类的动作啊，这样的话，之后扩容的时候value的值变了，就会影响到代码的结果","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638883016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1248326,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0c/46/dfe32cf4.jpg","nickname":"多选参数","note":"","ucode":"B2294D80AB075F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2323716,"avatar":"https://static001.geekbang.org/account/avatar/00/23/75/04/d26cd437.jpg","nickname":"lemon","note":"","ucode":"47626025C55E5E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537120,"discussion_content":"但是读取的话不也是拿到了那个地址，然后取值的嘛？我觉得是并发的原因","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638961570,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":536866,"ip_address":""},"score":537120,"extra":""}]}]},{"had_liked":false,"id":322750,"user_name":"布凡","can_delete":false,"product_type":"c1","uid":1202465,"ip_address":"","ucode":"346FCD332F8BFA","user_header":"https://static001.geekbang.org/account/avatar/00/12/59/21/d2efde18.jpg","comment_is_top":false,"comment_ctime":1637573810,"is_pvip":false,"replies":[{"id":"117599","content":"1. 文中的表里有 2^B=bucket数量<br>2. 差不多。细节还得去阅读代码。","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1638281530,"ip_address":"","comment_id":322750,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1637573810","product_id":100093501,"comment_content":"<br>map.go 源码地址<br>https:&#47;&#47;github.com&#47;golang&#47;go&#47;blob&#47;master&#47;src&#47;runtime&#47;map.go<br> <br> 老师请问，<br> 1、buckets[2^B-1]对应B的取值范围是不是[0,1,2……n),n的值应该是多少呢？<br> 2、buckets[0]对应的是key[0…7]， 当buckets[0]容量不够时 bucket 是不是一直根据2倍速度增涨，即 buckets[1]对应的就是key[0…15]，buckets[2]对应的key[0…31]。<br> 一直到count&gt;LoadFactor时应该就是6.5*前一个bucket的容量，是这样吗？","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534803,"discussion_content":"1. 文中的表里有 2^B=bucket数量\n2. 差不多。细节还得去阅读代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638281530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322619,"user_name":"Calvin","can_delete":false,"product_type":"c1","uid":1603004,"ip_address":"","ucode":"0EEF5B207623B5","user_header":"https://static001.geekbang.org/account/avatar/00/18/75/bc/e24e181e.jpg","comment_is_top":false,"comment_ctime":1637501917,"is_pvip":false,"replies":[{"id":"117159","content":"你是对的，感谢提醒。","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1637563080,"ip_address":"","comment_id":322619,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1637501917","product_id":100093501,"comment_content":"老师，“默认的元素个数为 BUCKETSIZE” 的值应该是在 $GOROOT&#47;src&#47;cmd&#47;compile&#47;internal&#47;reflectdata&#47;reflect.go 中定义。<br>PS：我的 go 版本是 1.17.3 (mac intel)。","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532251,"discussion_content":"你是对的，感谢提醒。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637563080,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322588,"user_name":"多选参数","can_delete":false,"product_type":"c1","uid":1248326,"ip_address":"","ucode":"B2294D80AB075F","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/46/dfe32cf4.jpg","comment_is_top":false,"comment_ctime":1637490083,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1637490083","product_id":100093501,"comment_content":"针对 overflow bucket 的移动来说，其实也有两种情况？一种是 bucket 中的元素不多，那么这个时候将 overflow bucket 中的元素移到 bucket 中是有效的？另一种是 bucket 本身就满了，这个时候创建新的，其实 overfow bucket 压根不会移动？","like_count":0,"discussions":[{"author":{"id":2323716,"avatar":"https://static001.geekbang.org/account/avatar/00/23/75/04/d26cd437.jpg","nickname":"lemon","note":"","ucode":"47626025C55E5E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536867,"discussion_content":"我感觉是这样的哎，就是说这种扩容有的时候是不起作用的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638883111,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322387,"user_name":"不负青春不负己🤘","can_delete":false,"product_type":"c1","uid":1363671,"ip_address":"","ucode":"A6DD8E8B20EA6E","user_header":"https://static001.geekbang.org/account/avatar/00/14/ce/d7/5315f6ce.jpg","comment_is_top":false,"comment_ctime":1637334773,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1637334773","product_id":100093501,"comment_content":"var kindex []int<br>\tfor k := range m {<br>\t\tkindex = append(kindex, k)<br>\t}<br>\t&#47;&#47;for k1,m1:=range m {<br>\t&#47;&#47;\tfmt.Printf(&quot;k1 %d,m1 %d\\n&quot;, k1, m1)<br>\t&#47;&#47;}<br>\tsort.Ints(kindex)<br><br>\tfor i:=0;i&lt;len(m);i++{<br>\t\tfmt.Println(kindex[i],m[kindex[i]])<br>\t}","like_count":0},{"had_liked":false,"id":322370,"user_name":"进化菌","can_delete":false,"product_type":"c1","uid":1276861,"ip_address":"","ucode":"B30A5F78BB4171","user_header":"https://static001.geekbang.org/account/avatar/00/13/7b/bd/ccb37425.jpg","comment_is_top":false,"comment_ctime":1637322328,"is_pvip":true,"discussion_count":2,"race_medal":5,"score":"1637322328","product_id":100093501,"comment_content":"没太明白，为啥map默认nil不能被直接操作？","like_count":0,"discussions":[{"author":{"id":1896658,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/f0/d2/771a5dca.jpg","nickname":"奔跑的咸鱼","note":"","ucode":"28C2B95415BBF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531970,"discussion_content":"应该是还没有开辟存储内存，slice是通过append函数来添加的，函数内部可以判断后开辟，而map是通过[]来添加的，没有判断过程","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1637485768,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":1,"child_discussions":[{"author":{"id":1276861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7b/bd/ccb37425.jpg","nickname":"进化菌","note":"","ucode":"B30A5F78BB4171","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":1896658,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/f0/d2/771a5dca.jpg","nickname":"奔跑的咸鱼","note":"","ucode":"28C2B95415BBF7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532243,"discussion_content":"谢谢你的解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637562686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":531970,"ip_address":""},"score":532243,"extra":"{\"user_type\":1}"}]}]},{"had_liked":false,"id":322066,"user_name":"酥宝话不多","can_delete":false,"product_type":"c1","uid":2564698,"ip_address":"","ucode":"3B9BF256682504","user_header":"https://static001.geekbang.org/account/avatar/00/27/22/5a/873ac981.jpg","comment_is_top":false,"comment_ctime":1637154321,"is_pvip":false,"replies":[{"id":"117144","content":"笔误，已改。","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1637558269,"ip_address":"","comment_id":322066,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1637154321","product_id":100093501,"comment_content":"这里 p 拿到的不是地址，而是 key 对应的 value ","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532218,"discussion_content":"笔误，已改。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637558269,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1351076,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","nickname":"lesserror","note":"","ucode":"25A54D1165FCF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531435,"discussion_content":"嗯？ 没懂你的意思，老师表述有问题么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637311319,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321965,"user_name":"liaomars","can_delete":false,"product_type":"c1","uid":2104856,"ip_address":"","ucode":"4FCA97EE9FB57D","user_header":"https://static001.geekbang.org/account/avatar/00/20/1e/18/9d1f1439.jpg","comment_is_top":false,"comment_ctime":1637119071,"is_pvip":false,"replies":[{"id":"117137","content":"是的。","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1637556007,"ip_address":"","comment_id":321965,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1637119071","product_id":100093501,"comment_content":"老师：函数类型、map 类型自身，以及切片类型是不能作为 map 的 key 类型的。<br>这个是不是可以理解成：函数类型，map类型，切片类型是不能做为key的？","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532205,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637556007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530675,"discussion_content":"正常人也不会拿这些数据结构做Key呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637123351,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":2,"child_discussions":[{"author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/e24e181e.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532095,"discussion_content":"如果我想实现类似 java 的 Map&lt;Map&lt;String, Object&gt;&gt; 类型呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637512411,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":530675,"ip_address":""},"score":532095,"extra":"{\"user_type\":1}"},{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/e24e181e.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532098,"discussion_content":"你这个外面是Set吧？计算机中任何问题都可以通过一个中间层解决，试试看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637512989,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":532095,"ip_address":""},"score":532098,"extra":"{\"user_type\":1}"}]}]},{"had_liked":false,"id":321939,"user_name":"Badb0y","can_delete":false,"product_type":"c1","uid":1022861,"ip_address":"","ucode":"7CF859100B53F8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/8d/784ca17e.jpg","comment_is_top":false,"comment_ctime":1637113749,"is_pvip":false,"replies":[{"id":"117135","content":"✅","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1637555971,"ip_address":"","comment_id":321939,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1637113749","product_id":100093501,"comment_content":"可以对KEY排序后再遍历","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532203,"discussion_content":"✅","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637555971,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}