{"id":484369,"title":"春节刷题计划（四）| 一题三解，搞定分式加减法","content":"<p>你好，我是朱涛。今天是初四了，在过年的节日氛围里你还能来坚持学习，这里也跟优秀的你说声感谢。</p><p>在上节课里呢，我给你留了一个作业：用Kotlin来完成 <a href=\"https://leetcode-cn.com/problems/fraction-addition-and-subtraction/\">LeetCode的592号题《分数加减运算》</a>。那么今天这节课，我们就一起来看看它的解题思路吧。</p><p>这其实也是一道典型的模拟题，分式的加减法这样的题目，我们小学就知道怎么做了，核心解题思路主要是这几步：</p><ul>\n<li>第一步，求出分母的<strong>最小公倍数</strong>。比如，2和3的最小公倍数就是6。</li>\n<li>第二步，根据计算出来的最小公倍数，将分数进行<strong>通分</strong>。举个例子：“1/2-1/6”，如果把它们两个通分，就会变成“3/6-1/6”。</li>\n<li>第三步，将<strong>分子进行加减法</strong>，计算出分子的结果。比如，“3/6-1/6”计算过后，就会变成“2/6”。</li>\n<li>最后一步，将计算结果转换成“<strong>最简分数</strong>”，比如“2/6”化成最简分数以后，应该是“1/3”。</li>\n</ul><p>经过这四个步骤，我们就可以计算出“1/2-1/6=1/3”。不过呢，这道题里，我们除了要计算分数的加减法以外，还要先完成分数的解析。程序的输入是字符串“1/2-1/6”，但它是不会帮我们自动解析的，所以，解析这一步也需要我们来做。</p><p>所以，自然而然地，我们就会定义一个分数的<strong>数据类Expression</strong>。</p><!-- [[[read_end]]] --><pre><code class=\"language-plain\">data class Expression(val numerator: Int, val denominator: Int) {\n    override fun toString(): String {\n        return \"$numerator/$denominator\"\n    }\n}\n</code></pre><p>在这个数据类Expression当中，一共有两个属性，<strong>numerator</strong>代表了分子，<strong>denominator</strong>代表了分母，它们的类型都是Int。另外，分数都是带有符号的，这里我们按照约定俗成来处理：分子可能是正数或负数，分母则一定是正整数。比如“1/2”，我们就用Expression(1,2)来表示；而“-1/2”，我们就用Expression(-1,2)来表示，而不会使用Expression(1,-2)表示。</p><p>另外在正式开始做题之前，还有一些额外的条件是需要我们弄清楚的：</p><ul>\n<li>第一，只需要支持分数的加减法，乘除法不需要考虑；</li>\n<li>第二，输入的式子中间不会有空格，且式子也一定是正确的，这就意味着，我们的输入只会包含“0-9”、“/”，“+”、“-”这些字符，不会出现其他的字符；</li>\n<li>第三，整数也会用分数来表示，比如说“2”，会用“2/1”来表示；</li>\n<li>第四，计算结果保证不会整型溢出。</li>\n</ul><p>好，问题的细节我们弄清楚了，大致思路也有了，接下来，我们就用三种解法来搞定这道题。</p><h2>解法一：命令式</h2><p>命令式的代码是最符合编程直觉的，我们的思路大致如下：</p><ul>\n<li>第一步，将式子当中的“-”统一替换成“<code>+-</code>”，然后再用<code>split(\"+\")</code>将式子分割成一个个独立分数。这种技巧我们在上节课就已经用过了。</li>\n<li>第二步，解析出独立的分数以后，我们就要将每一个分数解析成对应的Expression了。这里具体做法也很简单，我们可以用“/”来分割分数，前面的就是分子，后面的就是分母。比如“-1/2”，我们就可以解析出Expression(-1,2)。</li>\n<li>第三步，就是根据解析出来的所有分母，计算出所有分母的最小公倍数。比如，“1/2+1/3+1/4”，我们就把分母都提取出来“2，3，4”，而它们的最小公倍数应该是12。</li>\n<li>第四步，就是将所有的分数都通分。比如“1/2+1/3+1/4”，就会变成“6/12+4/12+3/12”。</li>\n<li>后面的步骤就简单了，我们只需要将分子都相加起来，确保结果是“最简分数”即可。</li>\n</ul><p>整个过程如下图：</p><p><img src=\"https://static001.geekbang.org/resource/image/8d/75/8d56a2f3f4c07946417863810cf16275.gif?wh=1080x608\" alt=\"图片\"></p><p>所以，我们就可以把代码分为以下几个步骤：</p><pre><code class=\"language-plain\">fun fractionAddition(expression: String): String {\n    // ①，分割式子\n    // ②，解析分数成Expression\n    // ③，计算所有分母的最小公倍数\n    // ④，将所有的分数都通分\n    // ⑤，将所有分子加起来进行计算，得到结果\n    // ⑥，将结果化为“最简分数”\n    // ⑦，最后，返回toString()的结果\n}\n</code></pre><p>把编码步骤梳理清楚了以后，其实我们每一个步骤都不难实现了：</p><pre><code class=\"language-plain\">fun fractionAddition(expression: String): String {\n    // ①，分割式子\n    val list = expression.replace(\"-\", \"+-\")\n    val fractionList = list.split(\"+\")\n    val expressionList = mutableListOf&lt;Expression&gt;()\n\n    // ②，解析分数成Expression\n    for (item in fractionList) {\n        if (item.trim() != \"\") {\n            expressionList.add(parseExpression(item))\n        }\n    }\n\n    // ③，计算所有分母的最小公倍数\n    var lcm = 1\n    for (exp in expressionList) {\n        lcm = lcm(lcm, exp.denominator)\n    }\n\n    // ④，将所有的分数都通分\n    val commonDenominatorFractions = mutableListOf&lt;Expression&gt;()\n    for (exp in expressionList) {\n        commonDenominatorFractions.add(toCommonDenominatorExp(exp, lcm))\n    }\n\n    // ⑤，将所有分子加起来进行计算，得到结果\n    var numerator = 0\n    for (fraction in commonDenominatorFractions) {\n        numerator += fraction.numerator\n\n    }\n\n    // ⑥，将结果化为“最简分数”\n    val result = Expression(numerator, lcm)\n    val reducedFraction = result.reducedFraction()\n\n    // ⑦，最后，返回toString()的结果\n    return reducedFraction.toString()\n}\n</code></pre><p>在上面的代码当中，还涉及到几个辅助函数，它们的实现也很简单。</p><pre><code class=\"language-plain\">// 解析分数，“1/2” -&gt; Expression(1,2)\nprivate fun parseExpression(expression: String): Expression {\n    val list = expression.trim().split(\"/\")\n\n    if (list.size != 2) {\n        throw IllegalArgumentException()\n    }\n\n    return Expression(list[0].toInt(), list[1].toInt())\n}\n\n// 通分\nprivate fun toCommonDenominatorExp(expression: Expression, lcm: Int): Expression {\n    return Expression(\n        numerator = expression.numerator * lcm / expression.denominator,\n        denominator = lcm\n    )\n}\n\n// 最简化分数\nprivate fun Expression.reducedFraction(): Expression {\n    val gcd = gcd(Math.abs(numerator), denominator)\n    return Expression(numerator / gcd, denominator / gcd)\n}\n\n// 求两个数的最小公倍数，Least Common Multiple\nprivate fun lcm(a: Int, b: Int) = a * b / gcd(a, b)\n\n// 求两个数的最大公约数，Greatest Common Divisor\nprivate fun gcd(a: Int, b: Int): Int {\n    var (big, small) = if (a &gt; b) a to b else b to a\n\n    while (small != 0) {\n        val temp = small\n        small = big % small\n        big = temp\n    }\n    return big\n}\n</code></pre><p>这几个辅助函数，需要注意的是 <strong>reducedFraction()</strong>，它的作用是计算最简分数，计算过程，其实就是计算出分子、分母的最大公约数，然后同时除以最大公约数。而最大公约数 <strong>gcd()</strong> 这个方法，本质上就是我们小学学过的<a href=\"https://zh.wikipedia.org/wiki/%E8%BC%BE%E8%BD%89%E7%9B%B8%E9%99%A4%E6%B3%95\">辗转相除法</a>。而最小公倍数 <strong>lcm()</strong> 这个方法，则是通过两数相乘，然后除以最大公约数求出来的。</p><p>至此，我们的第一种解法就完成了。</p><h2>解法二：函数式</h2><p>其实，利用同样的思想，我们还可以写出函数式的解法。如果你足够细心的话，你会发现解法一的代码可读性并不是很好，而如果用函数式思想重构上面的代码的话，可读性将会得到很大改善。</p><pre><code class=\"language-plain\">fun fractionAddition(expression: String): String {\n    var lcm: Int\n    return expression\n        .replace(\"-\", \"+-\")\n        .split(\"+\")\n        .filter { it.trim() != \"\" }\n        .map(::parseExpression)\n        .also { lcm = getCommonDenominator(it) }\n        .map { toCommonDenominatorExp(it, lcm) }\n        .reduce(::calculateExp)\n        .reducedFraction()\n        .toString()\n}\n</code></pre><p>这段代码，我们从上读到下，就跟读英语文本一样：</p><ul>\n<li>首先，使用“<code>+-</code>”替代“-”；</li>\n<li>接着，将其用“+”分割；</li>\n<li>之后，过滤无效的字符；</li>\n<li>然后，将字符串解析成Expression；</li>\n<li>这时候，我们根据所有的分母，计算出所有分母的最小公倍数；</li>\n<li>接着，我们就可以对所有的分数进行通分；</li>\n<li>然后，就可以将所有的分子相加，得到计算结果；</li>\n<li>最后，就是将结果化为“最简分数”，再返回toString()的结果。</li>\n</ul><p>那么，要写出上面这样的代码，我们仍然是需要一些辅助函数的，它们的逻辑跟解法一是一样的，只是换了种写法。</p><pre><code class=\"language-plain\">private fun parseExpression(expression: String) =\n    expression.trim()\n        .split(\"/\")\n        .takeIf { it.size == 2 }\n        ?.let { Expression(it[0].toInt(), it[1].toInt()) }\n        ?: throw IllegalArgumentException()\n\nprivate fun getCommonDenominator(list: List&lt;Expression&gt;) =\n    list.map { it.denominator }.reduce(::lcm)\n\nprivate fun toCommonDenominatorExp(expression: Expression, lcm: Int): Expression =\n    expression.let {\n        Expression(numerator = it.numerator * lcm / it.denominator, denominator = lcm)\n    }\n\nprivate fun calculateExp(acc: Expression, expression: Expression): Expression =\n    Expression(acc.numerator + expression.numerator, acc.denominator)\n\nprivate fun Expression.reducedFraction(): Expression =\n    gcd(Math.abs(numerator), denominator)\n        .let { Expression(numerator / it, denominator / it) }\n\n// Least Common Multiple\nprivate fun lcm(a: Int, b: Int) = a * b / gcd(a, b)\n\n// Greatest Common Divisor\nprivate fun gcd(a: Int, b: Int): Int {\n    var (big, small) = if (a &gt; b) a to b else b to a\n\n    while (small != 0) {\n        val temp = small\n        small = big % small\n        big = temp\n    }\n    return big\n}\n</code></pre><p>可以发现，对于复杂一些的方法来说，如果以函数式的思路来重构的话，可读性会有比较明显的提升。而对于原本就很简单的方法，重构之后，可读性反而会下降。所以，<strong>我们在写Kotlin的时候，不能一味追求所谓的范式正确，哪种范式更合适，我们就应该用哪个。</strong></p><h2>解法三：稳定性优化</h2><p>好，前面的这两种解法的思路都是一样的，不过这两种解法其实还是会有一个问题，那就是当分数很多，并且分母很大的情况下，我们一次性计算所有分母的最小公倍数时，是可能导致溢出的（当然，我们前面已经明确讲过不需要考虑溢出）。</p><p>所以，前面两种解法的思路还可以再进一步优化，同时也可以避免溢出的问题。它整体的思路没有什么大的变化，只是在计算的时候不会采取一次性将所有分数通分的策略，而是选择一次计算两个相邻的分数，得到结果以后再计算下一个。</p><p>这里我制作了一个动图，方便你理解它的整体过程：</p><p><img src=\"https://static001.geekbang.org/resource/image/8e/a7/8e30b6e8f7c196f0068f2835ec8e51a7.gif?wh=1080x608\" alt=\"图片\"></p><p>可以看到，这种思路的唯一区别就在于，它会先计算“1/3-1/2”的结果，将结果化为最简分数以后，再拿结果进行下一步计算“-1/6+1/4”，最终才会得到结果“1/12”。</p><p>这样，我们在解法二的基础上，稍作改动就能实现：</p><pre><code class=\"language-plain\">fun fractionAddition(expression: String): String =\n    expression\n        .replace(\"-\", \"+-\")\n        .split(\"+\")\n        .filter { it.trim() != \"\" }\n        .map(::parseExpression)\n        .reduce(::calculateExp)\n        .reducedFraction()\n        .toString()\n</code></pre><p>其实，我们也就是通过reduce(::calculateExp)这行代码，来计算相邻的分数的。</p><p>下面，我们具体来看看calculateExp()这个方法。</p><pre><code class=\"language-plain\">private fun calculateExp(acc: Expression, expression: Expression): Expression {\n    val lcm = lcm(acc.denominator, expression.denominator)\n    val exp1 = toCommonDenominatorExp(acc, lcm)\n    val exp2 = toCommonDenominatorExp(expression, lcm)\n    return Expression(exp1.numerator + exp2.numerator, lcm).reducedFraction()\n}\n</code></pre><p>calculateExp()方法的实现也很简单，它的作用是计算两个分数的结果。总体流程就是：</p><ul>\n<li>第一步，计算两个分数分母的最小公倍数lcm；</li>\n<li>第二步，根据lcm，将两个分数都通分；</li>\n<li>第三步，将分数的分子都相加，然后化简为“最简分数”。</li>\n</ul><p>至此，解法三的代码就完成了，除了calculateExp()这个方法的实现之外，其他代码跟解法二是一样的。我们来看看它整体的代码吧。</p><pre><code class=\"language-plain\">fun fractionAddition(expression: String): String =\n    expression\n        .replace(\"-\", \"+-\")\n        .split(\"+\")\n        .filter { it.trim() != \"\" }\n        .map(::parseExpression)\n        .reduce(::calculateExp)\n        .reducedFraction()\n        .toString()\n\n\nprivate fun parseExpression(expression: String) =\n    expression.trim()\n        .split(\"/\")\n        .takeIf { it.size == 2 }\n        ?.let { Expression(it[0].toInt(), it[1].toInt()) }\n        ?: throw IllegalArgumentException()\n\nprivate fun toCommonDenominatorExp(expression: Expression, lcm: Int): Expression =\n    expression.let {\n        Expression(numerator = it.numerator * lcm / it.denominator, denominator = lcm)\n    }\n\nprivate fun calculateExp(acc: Expression, expression: Expression): Expression {\n    val lcm = lcm(acc.denominator, expression.denominator)\n    val exp1 = toCommonDenominatorExp(acc, lcm)\n    val exp2 = toCommonDenominatorExp(expression, lcm)\n    return Expression(exp1.numerator + exp2.numerator, lcm).reducedFraction()\n}\n\nprivate fun Expression.reducedFraction(): Expression =\n    gcd(Math.abs(numerator), denominator)\n        .let { Expression(numerator / it, denominator / it) }\n\n// Least Common Multiple\nprivate fun lcm(a: Int, b: Int) = a * b / gcd(a, b)\n\n// Greatest Common Divisor\nprivate fun gcd(a: Int, b: Int): Int {\n    var (big, small) = if (a &gt; b) a to b else b to a\n\n    while (small != 0) {\n        val temp = small\n        small = big % small\n        big = temp\n    }\n    return big\n}\n</code></pre><h2>小结</h2><p>这节课，我们一共用了三种解法来实现 <a href=\"https://leetcode-cn.com/problems/fraction-addition-and-subtraction/\">LeetCode的592号题《分数加减运算》</a>这道题。解法一和二，它们的思路是一致的，只是前者是命令式，后者是函数式。而解法三，则是在解法二的基础上做的优化。我们可以来对比一下这三种解法。</p><ul>\n<li>解法一，可读性差，时间复杂度、空间复杂度稍差，复杂的情况下可能会出现溢出。</li>\n<li>解法二，类似解法一，只是可读性要好很多。</li>\n<li>解法三，类似解法二，优势在于不容易出现溢出。</li>\n</ul><p>不知不觉，春节假期就快要过去了。在这一周里，我们体验了一把用Kotlin刷题的感觉。总体来说，用Kotlin来刷算法题还是比较愉快的，对比起Java，它能提供丰富API的同时，还能提供多样的编程范式。对于不同的问题，我们可以灵活选择编程范式来解决。</p><p>在这一周里，我故意在使用多种范式来刷题，目的就是让你可以体会到Kotlin在面对不同问题的时候，它在不同编程范式上的不同表现。</p><ul>\n<li>比如，对于“版本号判断”这个题目来说，命令式的代码明显会更加的简洁，而函数式的代码则有些丑陋。</li>\n<li>比如，对于“求解方程”这个题目来说，函数式与命令式之间各有优劣。</li>\n<li>而对于今天这个“分数加减法”的题目来说，函数式的解法则是在各方面都要优于命令式的。</li>\n</ul><p>那么，在最后，我希望你不要把这节课当作Kotlin刷题的终点，而是要把这节课当作一个起点。因为，用Kotlin刷算法题，真的是个一举多得的好办法！我们何乐而不为呢？</p><h2>小作业</h2><p>好，还是给你留一个小作业吧，请你写出“解法三”对应的命令式代码吧。</p><blockquote>\n<p>提示：在解法一的基础上做一些修改就能轻松实现了。</p>\n</blockquote>","comments":[{"had_liked":false,"id":336939,"user_name":"白乾涛","can_delete":false,"product_type":"c1","uid":1339841,"ip_address":"","ucode":"0C704B0B90C8D7","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/c1/cbc55e06.jpg","comment_is_top":false,"comment_ctime":1646482784,"is_pvip":false,"replies":[{"id":"123152","content":"很妙，init代码段用的挺好~<br><br>PS：作为算法题解很好，生产环境还是不推荐这么写数据类哈。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1646580961,"ip_address":"","comment_id":336939,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1646482784","product_id":100103401,"comment_content":"老师好，我对方法二又做了一些修改，主要是将一堆临时方法去掉了，老师帮忙看看这种思维合不合适<br><br>fun fractionAddition(expression: String): String {<br>    var lcm: Int &#47;&#47; 分母的最小公倍数<br>    val addValue = expression.replace(&quot;-&quot;, &quot;+-&quot;) &#47;&#47; 分子加减运算的结果<br>        .split(&quot;+&quot;)<br>        .filter { it.trim() != &quot;&quot; }<br>        .map { Expression(it) } &#47;&#47; 将 String 集合转换为 Expression 集合<br>        .also { list -&gt; lcm = list.map { it.denominator }.reduce(::lcm) } &#47;&#47; 最小公倍数 ①<br>        .map { it.numerator * lcm &#47; it.denominator } &#47;&#47; 分子通分<br>        .reduce { a, b -&gt; a + b } &#47;&#47;将所有的分子相加<br>    val gcd = gcd(abs(addValue), lcm) &#47;&#47; 分子和分母的最大公约数<br><br>    println(&quot;$lcm $addValue $gcd&quot;)<br>    return &quot;${addValue &#47; gcd}&#47;${lcm &#47; gcd}&quot; &#47;&#47; 简化分数<br>}<br><br>data class Expression(val exp: String, var numerator: Int = 0, var denominator: Int = 1) {<br>    init {<br>        exp.trim()<br>            .split(&quot;&#47;&quot;)<br>            .takeIf { it.size == 2 }<br>            ?.let { numerator = it[0].toInt(); denominator = it[1].toInt() }<br>    }<br>}","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554755,"discussion_content":"很妙，init代码段用的挺好~\n\nPS：作为算法题解很好，生产环境还是不推荐这么写数据类哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646580962,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336614,"user_name":"白乾涛","can_delete":false,"product_type":"c1","uid":1339841,"ip_address":"","ucode":"0C704B0B90C8D7","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/c1/cbc55e06.jpg","comment_is_top":false,"comment_ctime":1646241480,"is_pvip":false,"replies":[{"id":"123026","content":"当我们必须刷题的时候，我会更喜欢Kotlin，而不是Java，它能帮我们熟悉Kotlin的基础语法、集合API，其实这就够了。<br><br>其实，你说的也很对，要灵活运用Kotlin的特性，刷题是不够的，刷题只能打基础。丰富的语言特性，只能去实战项目当中去运用。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1646275553,"ip_address":"","comment_id":336614,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1646241480","product_id":100103401,"comment_content":"感觉用kotlin刷题意义不大，因为kotlin新增的那么多语法、特性，以及协程，都用不上，这样子的kotlin没啥优势","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554230,"discussion_content":"当我们必须刷题的时候，我会更喜欢Kotlin，而不是Java，它能帮我们熟悉Kotlin的基础语法、集合API，其实这就够了。\n\n其实，你说的也很对，要灵活运用Kotlin的特性，刷题是不够的，刷题只能打基础。丰富的语言特性，只能去实战项目当中去运用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646275553,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333192,"user_name":"jim","can_delete":false,"product_type":"c1","uid":1491946,"ip_address":"","ucode":"C12DB0F2B570F6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Urc67zDC8R6dh9U1ZFTF36icXewM1seehvOUYUs4hyWSsFzS5WQc2RcrE1Mzs8qtgib5SM5wFrVh22QcQd0JUUBw/132","comment_is_top":false,"comment_ctime":1644201073,"is_pvip":false,"replies":[{"id":"121772","content":"感谢你的认可，将来有机会的话，我会考虑写点相关的博客出来的。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1644250431,"ip_address":"","comment_id":333192,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1644201073","product_id":100103401,"comment_content":"朱涛老师，这个系列可以单独开一个课程，非常期待","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549835,"discussion_content":"感谢你的认可，将来有机会的话，我会考虑写点相关的博客出来的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644250431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}