{"id":79700,"title":"34 | 到底可不可以使用join？","content":"<p>在实际生产中，关于join语句使用的问题，一般会集中在以下两类：</p><ol>\n<li>\n<p>我们DBA不让使用join，使用join有什么问题呢？</p>\n</li>\n<li>\n<p>如果有两个大小不同的表做join，应该用哪个表做驱动表呢？</p>\n</li>\n</ol><p>今天这篇文章，我就先跟你说说join语句到底是怎么执行的，然后再来回答这两个问题。</p><p>为了便于量化分析，我还是创建两个表t1和t2来和你说明。</p><pre><code>CREATE TABLE `t2` (\n  `id` int(11) NOT NULL,\n  `a` int(11) DEFAULT NULL,\n  `b` int(11) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `a` (`a`)\n) ENGINE=InnoDB;\n\ndrop procedure idata;\ndelimiter ;;\ncreate procedure idata()\nbegin\n  declare i int;\n  set i=1;\n  while(i&lt;=1000)do\n    insert into t2 values(i, i, i);\n    set i=i+1;\n  end while;\nend;;\ndelimiter ;\ncall idata();\n\ncreate table t1 like t2;\ninsert into t1 (select * from t2 where id&lt;=100)\n</code></pre><p>可以看到，这两个表都有一个主键索引id和一个索引a，字段b上无索引。存储过程idata()往表t2里插入了1000行数据，在表t1里插入的是100行数据。</p><h1>Index Nested-Loop Join</h1><p>我们来看一下这个语句：</p><pre><code>select * from t1 straight_join t2 on (t1.a=t2.a);\n</code></pre><p>如果直接使用join语句，MySQL优化器可能会选择表t1或t2作为驱动表，这样会影响我们分析SQL语句的执行过程。所以，为了便于分析执行过程中的性能问题，我改用straight_join让MySQL使用固定的连接方式执行查询，这样优化器只会按照我们指定的方式去join。在这个语句里，t1 是驱动表，t2是被驱动表。</p><p>现在，我们来看一下这条语句的explain结果。</p><p><img src=\"https://static001.geekbang.org/resource/image/4b/90/4b9cb0e0b83618e01c9bfde44a0ea990.png?wh=1394*163\" alt=\"\"></p><center><span class=\"reference\">图1 使用索引字段join的 explain结果</span></center><p>可以看到，在这条语句里，被驱动表t2的字段a上有索引，join过程用上了这个索引，因此这个语句的执行流程是这样的：</p><!-- [[[read_end]]] --><ol>\n<li>\n<p>从表t1中读入一行数据 R；</p>\n</li>\n<li>\n<p>从数据行R中，取出a字段到表t2里去查找；</p>\n</li>\n<li>\n<p>取出表t2中满足条件的行，跟R组成一行，作为结果集的一部分；</p>\n</li>\n<li>\n<p>重复执行步骤1到3，直到表t1的末尾循环结束。</p>\n</li>\n</ol><p>这个过程是先遍历表t1，然后根据从表t1中取出的每行数据中的a值，去表t2中查找满足条件的记录。在形式上，这个过程就跟我们写程序时的嵌套查询类似，并且可以用上被驱动表的索引，所以我们称之为“Index Nested-Loop Join”，简称NLJ。</p><p>它对应的流程图如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/d8/f6/d83ad1cbd6118603be795b26d38f8df6.jpg?wh=1142*880\" alt=\"\"></p><center><span class=\"reference\">图2 Index Nested-Loop Join算法的执行流程</span></center><p>在这个流程里：</p><ol>\n<li>\n<p>对驱动表t1做了全表扫描，这个过程需要扫描100行；</p>\n</li>\n<li>\n<p>而对于每一行R，根据a字段去表t2查找，走的是树搜索过程。由于我们构造的数据都是一一对应的，因此每次的搜索过程都只扫描一行，也是总共扫描100行；</p>\n</li>\n<li>\n<p>所以，整个执行流程，总扫描行数是200。</p>\n</li>\n</ol><p>现在我们知道了这个过程，再试着回答一下文章开头的两个问题。</p><p>先看第一个问题：<strong>能不能使用join?</strong></p><p>假设不使用join，那我们就只能用单表查询。我们看看上面这条语句的需求，用单表查询怎么实现。</p><ol>\n<li>\n<p>执行<code>select * from t1</code>，查出表t1的所有数据，这里有100行；</p>\n</li>\n<li>\n<p>循环遍历这100行数据：</p>\n<ul>\n<li>从每一行R取出字段a的值$R.a；</li>\n<li>执行<code>select * from t2 where a=$R.a</code>；</li>\n<li>把返回的结果和R构成结果集的一行。</li>\n</ul>\n</li>\n</ol><p>可以看到，在这个查询过程，也是扫描了200行，但是总共执行了101条语句，比直接join多了100次交互。除此之外，客户端还要自己拼接SQL语句和结果。</p><p>显然，这么做还不如直接join好。</p><p>我们再来看看第二个问题：<strong>怎么选择驱动表？</strong></p><p>在这个join语句执行过程中，驱动表是走全表扫描，而被驱动表是走树搜索。</p><p>假设被驱动表的行数是M。每次在被驱动表查一行数据，要先搜索索引a，再搜索主键索引。每次搜索一棵树近似复杂度是以2为底的M的对数，记为log<sub>2</sub>M，所以在被驱动表上查一行的时间复杂度是 2*log<sub>2</sub>M。</p><p>假设驱动表的行数是N，执行过程就要扫描驱动表N行，然后对于每一行，到被驱动表上匹配一次。</p><p>因此整个执行过程，近似复杂度是 N + N*2*log<sub>2</sub>M。</p><p>显然，N对扫描行数的影响更大，因此应该让小表来做驱动表。</p><blockquote>\n<p>如果你没觉得这个影响有那么“显然”， 可以这么理解：N扩大1000倍的话，扫描行数就会扩大1000倍；而M扩大1000倍，扫描行数扩大不到10倍。</p>\n</blockquote><p>到这里小结一下，通过上面的分析我们得到了两个结论：</p><ol>\n<li>\n<p>使用join语句，性能比强行拆成多个单表执行SQL语句的性能要好；</p>\n</li>\n<li>\n<p>如果使用join语句的话，需要让小表做驱动表。</p>\n</li>\n</ol><p>但是，你需要注意，这个结论的前提是“可以使用被驱动表的索引”。</p><p>接下来，我们再看看被驱动表用不上索引的情况。</p><h1>Simple Nested-Loop Join</h1><p>现在，我们把SQL语句改成这样：</p><pre><code>select * from t1 straight_join t2 on (t1.a=t2.b);\n</code></pre><p>由于表t2的字段b上没有索引，因此再用图2的执行流程时，每次到t2去匹配的时候，就要做一次全表扫描。</p><p>你可以先设想一下这个问题，继续使用图2的算法，是不是可以得到正确的结果呢？如果只看结果的话，这个算法是正确的，而且这个算法也有一个名字，叫做“Simple Nested-Loop Join”。</p><p>但是，这样算来，这个SQL请求就要扫描表t2多达100次，总共扫描100*1000=10万行。</p><p>这还只是两个小表，如果t1和t2都是10万行的表（当然了，这也还是属于小表的范围），就要扫描100亿行，这个算法看上去太“笨重”了。</p><p>当然，MySQL也没有使用这个Simple Nested-Loop Join算法，而是使用了另一个叫作“Block Nested-Loop Join”的算法，简称BNL。</p><h1>Block Nested-Loop Join</h1><p>这时候，被驱动表上没有可用的索引，算法的流程是这样的：</p><ol>\n<li>\n<p>把表t1的数据读入线程内存join_buffer中，由于我们这个语句中写的是select *，因此是把整个表t1放入了内存；</p>\n</li>\n<li>\n<p>扫描表t2，把表t2中的每一行取出来，跟join_buffer中的数据做对比，满足join条件的，作为结果集的一部分返回。</p>\n</li>\n</ol><p>这个过程的流程图如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/15/73/15ae4f17c46bf71e8349a8f2ef70d573.jpg?wh=1142*880\" alt=\"\"></p><center><span class=\"reference\">图3 Block Nested-Loop Join 算法的执行流程</span></center><p>对应地，这条SQL语句的explain结果如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/67/e1/676921fa0883e9463dd34fb2bc5e87e1.png?wh=1763*164\" alt=\"\"></p><center><span class=\"reference\">图4 不使用索引字段join的 explain结果</span></center><p>可以看到，在这个过程中，对表t1和t2都做了一次全表扫描，因此总的扫描行数是1100。由于join_buffer是以无序数组的方式组织的，因此对表t2中的每一行，都要做100次判断，总共需要在内存中做的判断次数是：100*1000=10万次。</p><p>前面我们说过，如果使用Simple Nested-Loop Join算法进行查询，扫描行数也是10万行。因此，从时间复杂度上来说，这两个算法是一样的。但是，Block Nested-Loop Join算法的这10万次判断是内存操作，速度上会快很多，性能也更好。</p><p>接下来，我们来看一下，在这种情况下，应该选择哪个表做驱动表。</p><p>假设小表的行数是N，大表的行数是M，那么在这个算法里：</p><ol>\n<li>\n<p>两个表都做一次全表扫描，所以总的扫描行数是M+N；</p>\n</li>\n<li>\n<p>内存中的判断次数是M*N。</p>\n</li>\n</ol><p>可以看到，调换这两个算式中的M和N没差别，因此这时候选择大表还是小表做驱动表，执行耗时是一样的。</p><p>然后，你可能马上就会问了，这个例子里表t1才100行，要是表t1是一个大表，join_buffer放不下怎么办呢？</p><p>join_buffer的大小是由参数join_buffer_size设定的，默认值是256k。<strong>如果放不下表t1的所有数据话，策略很简单，就是分段放。</strong>我把join_buffer_size改成1200，再执行：</p><pre><code>select * from t1 straight_join t2 on (t1.a=t2.b);\n</code></pre><p>执行过程就变成了：</p><ol>\n<li>\n<p>扫描表t1，顺序读取数据行放入join_buffer中，放完第88行join_buffer满了，继续第2步；</p>\n</li>\n<li>\n<p>扫描表t2，把t2中的每一行取出来，跟join_buffer中的数据做对比，满足join条件的，作为结果集的一部分返回；</p>\n</li>\n<li>\n<p>清空join_buffer；</p>\n</li>\n<li>\n<p>继续扫描表t1，顺序读取最后的12行数据放入join_buffer中，继续执行第2步。</p>\n</li>\n</ol><p>执行流程图也就变成这样：</p><p><img src=\"https://static001.geekbang.org/resource/image/69/c4/695adf810fcdb07e393467bcfd2f6ac4.jpg?wh=1142*880\" alt=\"\"></p><center><span class=\"reference\">图5 Block Nested-Loop Join -- 两段</span></center><p>图中的步骤4和5，表示清空join_buffer再复用。</p><p>这个流程才体现出了这个算法名字中“Block”的由来，表示“分块去join”。</p><p>可以看到，这时候由于表t1被分成了两次放入join_buffer中，导致表t2会被扫描两次。虽然分成两次放入join_buffer，但是判断等值条件的次数还是不变的，依然是(88+12)*1000=10万次。</p><p>我们再来看下，在这种情况下驱动表的选择问题。</p><p>假设，驱动表的数据行数是N，需要分K段才能完成算法流程，被驱动表的数据行数是M。</p><p>注意，这里的K不是常数，N越大K就会越大，因此把K表示为λ*N，显然λ的取值范围是(0,1)。</p><p>所以，在这个算法的执行过程中：</p><ol>\n<li>\n<p>扫描行数是 N+λ*N*M；</p>\n</li>\n<li>\n<p>内存判断 N*M次。</p>\n</li>\n</ol><p>显然，内存判断次数是不受选择哪个表作为驱动表影响的。而考虑到扫描行数，在M和N大小确定的情况下，N小一些，整个算式的结果会更小。</p><p>所以结论是，应该让小表当驱动表。</p><p>当然，你会发现，在N+λ*N*M这个式子里，λ才是影响扫描行数的关键因素，这个值越小越好。</p><p>刚刚我们说了N越大，分段数K越大。那么，N固定的时候，什么参数会影响K的大小呢？（也就是λ的大小）答案是join_buffer_size。join_buffer_size越大，一次可以放入的行越多，分成的段数也就越少，对被驱动表的全表扫描次数就越少。</p><p>这就是为什么，你可能会看到一些建议告诉你，如果你的join语句很慢，就把join_buffer_size改大。</p><p>理解了MySQL执行join的两种算法，现在我们再来试着<strong>回答文章开头的两个问题</strong>。</p><p>第一个问题：能不能使用join语句？</p><ol>\n<li>\n<p>如果可以使用Index Nested-Loop Join算法，也就是说可以用上被驱动表上的索引，其实是没问题的；</p>\n</li>\n<li>\n<p>如果使用Block Nested-Loop Join算法，扫描行数就会过多。尤其是在大表上的join操作，这样可能要扫描被驱动表很多次，会占用大量的系统资源。所以这种join尽量不要用。</p>\n</li>\n</ol><p>所以你在判断要不要使用join语句时，就是看explain结果里面，Extra字段里面有没有出现“Block Nested Loop”字样。</p><p>第二个问题是：如果要使用join，应该选择大表做驱动表还是选择小表做驱动表？</p><ol>\n<li>\n<p>如果是Index Nested-Loop Join算法，应该选择小表做驱动表；</p>\n</li>\n<li>\n<p>如果是Block Nested-Loop Join算法：</p>\n<ul>\n<li>在join_buffer_size足够大的时候，是一样的；</li>\n<li>在join_buffer_size不够大的时候（这种情况更常见），应该选择小表做驱动表。</li>\n</ul>\n</li>\n</ol><p>所以，这个问题的结论就是，总是应该使用小表做驱动表。</p><p>当然了，这里我需要说明下，<strong>什么叫作“小表”</strong>。</p><p>我们前面的例子是没有加条件的。如果我在语句的where条件加上 t2.id&lt;=50这个限定条件，再来看下这两条语句：</p><pre><code>select * from t1 straight_join t2 on (t1.b=t2.b) where t2.id&lt;=50;\nselect * from t2 straight_join t1 on (t1.b=t2.b) where t2.id&lt;=50;\n</code></pre><p>注意，为了让两条语句的被驱动表都用不上索引，所以join字段都使用了没有索引的字段b。</p><p>但如果是用第二个语句的话，join_buffer只需要放入t2的前50行，显然是更好的。所以这里，“t2的前50行”是那个相对小的表，也就是“小表”。</p><p>我们再来看另外一组例子：</p><pre><code>select t1.b,t2.* from  t1  straight_join t2 on (t1.b=t2.b) where t2.id&lt;=100;\nselect t1.b,t2.* from  t2  straight_join t1 on (t1.b=t2.b) where t2.id&lt;=100;\n</code></pre><p>这个例子里，表t1 和 t2都是只有100行参加join。但是，这两条语句每次查询放入join_buffer中的数据是不一样的：</p><ul>\n<li>表t1只查字段b，因此如果把t1放到join_buffer中，则join_buffer中只需要放入b的值；</li>\n<li>表t2需要查所有的字段，因此如果把表t2放到join_buffer中的话，就需要放入三个字段id、a和b。</li>\n</ul><p>这里，我们应该选择表t1作为驱动表。也就是说在这个例子里，“只需要一列参与join的表t1”是那个相对小的表。</p><p>所以，更准确地说，<strong>在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与join的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表。</strong></p><h1>小结</h1><p>今天，我和你介绍了MySQL执行join语句的两种可能算法，这两种算法是由能否使用被驱动表的索引决定的。而能否用上被驱动表的索引，对join语句的性能影响很大。</p><p>通过对Index Nested-Loop Join和Block Nested-Loop Join两个算法执行过程的分析，我们也得到了文章开头两个问题的答案：</p><ol>\n<li>\n<p>如果可以使用被驱动表的索引，join语句还是有其优势的；</p>\n</li>\n<li>\n<p>不能使用被驱动表的索引，只能使用Block Nested-Loop Join算法，这样的语句就尽量不要使用；</p>\n</li>\n<li>\n<p>在使用join的时候，应该让小表做驱动表。</p>\n</li>\n</ol><p>最后，又到了今天的问题时间。</p><p>我们在上文说到，使用Block Nested-Loop Join算法，可能会因为join_buffer不够大，需要对被驱动表做多次全表扫描。</p><p>我的问题是，如果被驱动表是一个大表，并且是一个冷数据表，除了查询过程中可能会导致IO压力大以外，你觉得对这个MySQL服务还有什么更严重的影响吗？（这个问题需要结合上一篇文章的知识点）</p><p>你可以把你的结论和分析写在留言区，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p><h1>上期问题时间</h1><p>我在上一篇文章最后留下的问题是，如果客户端由于压力过大，迟迟不能接收数据，会对服务端造成什么严重的影响。</p><p>这个问题的核心是，造成了“长事务”。</p><p>至于长事务的影响，就要结合我们前面文章中提到的锁、MVCC的知识点了。</p><ul>\n<li>如果前面的语句有更新，意味着它们在占用着行锁，会导致别的语句更新被锁住；</li>\n<li>当然读的事务也有问题，就是会导致undo log不能被回收，导致回滚段空间膨胀。</li>\n</ul><p>评论区留言点赞板：</p><blockquote>\n<p>@老杨同志 提到了更新之间会互相等锁的问题。同一个事务，更新之后要尽快提交，不要做没必要的查询，尤其是不要执行需要返回大量数据的查询；<br>\n@长杰 同学提到了undo表空间变大，db服务堵塞，服务端磁盘空间不足的例子。</p>\n</blockquote><p></p>","comments":[{"had_liked":false,"id":64558,"user_name":"没时间了ngu","can_delete":false,"product_type":"c1","uid":1311334,"ip_address":"","ucode":"9629BB85E8BB5D","user_header":"https://static001.geekbang.org/account/avatar/00/14/02/66/4ab9225e.jpg","comment_is_top":true,"comment_ctime":1548820712,"is_pvip":false,"replies":[{"id":"22869","content":"嗯嗯，因为其实每个同学的只是背景不一样。<br>这45讲里，每个同学都能从部分文章感觉到有收获，我觉得也很好了😆<br><br>不过 锁其实用得也多的。。<br>我以前负责业务库的时候，被开发同学问最多的问题之一就是，为啥死锁了^_^","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548828713,"ip_address":"","comment_id":64558,"utype":1}],"discussion_count":6,"race_medal":0,"score":"9.2233724464254996e+18","product_id":100020801,"comment_content":"join这种用的多的，看完还是有很大收获的。像之前讲的锁之类，感觉好抽象，老是记不住，唉。","like_count":96,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438070,"discussion_content":"嗯嗯，因为其实每个同学的只是背景不一样。\n这45讲里，每个同学都能从部分文章感觉到有收获，我觉得也很好了😆\n\n不过 锁其实用得也多的。。\n我以前负责业务库的时候，被开发同学问最多的问题之一就是，为啥死锁了^_^","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548828713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2112092,"avatar":"https://static001.geekbang.org/account/avatar/00/20/3a/5c/60fdf8e2.jpg","nickname":"wtdd","note":"","ucode":"26C64BF9CCA061","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":401234,"discussion_content":"何止是有收获，简直是太特么有收获了！！！！","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1633609909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2760691,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/1f/f3/791d0f5e.jpg","nickname":"xgt132","note":"","ucode":"A5023547E8D490","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590210,"discussion_content":"看大家没全记住 我就放心了0.0","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665623004,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2723576,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epxppZUun6eqepI5hGHjU3fP8yVIicUq7gYRZfR3PoDCMQqd2ia8CmCSa1mIIf6OYGFjbW28RCXmrJQ/132","nickname":"Geek_aef4be","note":"","ucode":"F1C3F2AE3CCA0F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585167,"discussion_content":"对于join的两张表，除了被驱动表的on字段有索引外，驱动表上的on字段加索引没有对性能有提升呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661357643,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1780797,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/2c/3d/0bd58aa4.jpg","nickname":"Em","note":"","ucode":"32012A5C603C8A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578257,"discussion_content":"相反我更理解锁...   没用过join   但锁的概念在计算机比较广泛","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656606485,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1811277,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a3/4d/59390ba9.jpg","nickname":"排骨","note":"","ucode":"A413CF46211E1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574240,"discussion_content":"真的很有收获，看完虽然很多记不住，但是感觉mysql的理解已经超过了很多程序员了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653919774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64554,"user_name":"信信","can_delete":false,"product_type":"c1","uid":1303865,"ip_address":"","ucode":"8DF0EC045579FD","user_header":"https://static001.geekbang.org/account/avatar/00/13/e5/39/951f89c8.jpg","comment_is_top":false,"comment_ctime":1548820034,"is_pvip":false,"replies":[{"id":"22866","content":"👍","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548823013,"ip_address":"","comment_id":64554,"utype":1}],"discussion_count":19,"race_medal":0,"score":"1444657831490","product_id":100020801,"comment_content":"老师好，回答本期问题：如果驱动表分段，那么被驱动表就被多次读，而被驱动表又是大表，循环读取的间隔肯定得超1秒，这就会导致上篇文章提到的：“数据页在LRU_old的存在时间超过1秒，就会移到young区”。最终结果就是把大部分热点数据都淘汰了，导致“Buffer pool hit rate”命中率极低，其他请求需要读磁盘，因此系统响应变慢，大部分请求阻塞。","like_count":337,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438067,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548823013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1887586,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLhicDSmL4vicPADhxxzOzukMar8nV5Tc3ic2dz4FQIxMX3WmX5a2V3sdD121eWpvfQI8NXIkkDZoDFw/132","nickname":"Geek_536b54","note":"","ucode":"F62BC7781D9212","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336809,"discussion_content":"你就是班里认真听讲的同学\n","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1608707353,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1290245,"avatar":"https://static001.geekbang.org/account/avatar/00/13/b0/05/48e3f940.jpg","nickname":"无心","note":"","ucode":"2AD84413DB4A72","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":132447,"discussion_content":"那这张大表还不够大，只要要扫描的数据页大小超过innodb buffer pool的3/8，下一次读的时候缓存已经被淘汰掉了","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1578909012,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1254493,"avatar":"https://static001.geekbang.org/account/avatar/00/13/24/5d/65e61dcb.jpg","nickname":"听雨","note":"","ucode":"252754F9FCFF0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1290245,"avatar":"https://static001.geekbang.org/account/avatar/00/13/b0/05/48e3f940.jpg","nickname":"无心","note":"","ucode":"2AD84413DB4A72","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":313256,"discussion_content":"冷数据在1s后被再次访问是会移到热数据区域头部，这样冷数据就不会被淘汰了，会淘汰热数据区域尾部的数据。一般大表join 1秒是结束不了的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603013426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":132447,"ip_address":""},"score":313256,"extra":""}]},{"author":{"id":1440429,"avatar":"https://static001.geekbang.org/account/avatar/00/15/fa/ad/3fa02ac7.jpg","nickname":"星期八","note":"","ucode":"D8C66E7F61B0D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":273437,"discussion_content":"流弊~","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1590456754,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2764938,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/30/8a/41a1fd6a.jpg","nickname":"大大的沙包","note":"","ucode":"0A2CB16F90ECF8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":395983,"discussion_content":"前提条件是buffer pool的old区时能够放下这个大表的时候吧，如果放不下的话就不会进入young区，但是大表的每一轮遍历都需要磁盘读取，理论上会特别的慢。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1632376289,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1155275,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","nickname":"张三丰","note":"","ucode":"3A6215A40B3B21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383486,"discussion_content":"这就有点矛盾了，数据页不是存的数据吗？为何扫描到的也会放数据页？全表扫描不等于全表匹配啊，实际只是匹配了一条数据而已。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626113704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2649276,"avatar":"https://static001.geekbang.org/account/avatar/00/28/6c/bc/f751786b.jpg","nickname":"Leo","note":"","ucode":"CEBAD9CDCFC2A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1155275,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","nickname":"张三丰","note":"","ucode":"3A6215A40B3B21","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386642,"discussion_content":"扫描到的数据会被读取到buffer pool的old区间","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627705534,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":383486,"ip_address":""},"score":386642,"extra":""}]},{"author":{"id":1124075,"avatar":"https://static001.geekbang.org/account/avatar/00/11/26/eb/24e0ac9c.jpg","nickname":"嬴梦川","note":"","ucode":"104CDFD26A1711","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375115,"discussion_content":"应该置顶，并附上“好问题”！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621487962,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2031146,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/W8eOmaCRP3hfROWPSdbfqcXnPtGwFXTaIicXtFic3ic3LibS6OydnKg2A3o8WqemQkRhNSmS9kSud6QyS4JRIOFbkA/132","nickname":"Geek_9c1ca6","note":"","ucode":"C426FDED75B3F8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363783,"discussion_content":"为什么是大表，循环读取的间隔肯定得超1秒啊？上一章还说间隔超不过1秒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617282426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1657561,"avatar":"https://static001.geekbang.org/account/avatar/00/19/4a/d9/b8046b4b.jpg","nickname":"zhangm365","note":"","ucode":"60E7DEFB3F5840","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2031146,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/W8eOmaCRP3hfROWPSdbfqcXnPtGwFXTaIicXtFic3ic3LibS6OydnKg2A3o8WqemQkRhNSmS9kSud6QyS4JRIOFbkA/132","nickname":"Geek_9c1ca6","note":"","ucode":"C426FDED75B3F8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386905,"discussion_content":"因为驱动表分了k段的话，被驱动表的数据就会被读取k次，这样间隔超过1s","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627888410,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":363783,"ip_address":""},"score":386905,"extra":""}]},{"author":{"id":1292330,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VX0ib4CV0m7fwxB2xFcIJaYYWXXpfxxYbfBErqBej9395hgZszqS3dz9bThCxOuFfJ8Xibx9HbdNmZJwL5m33wIw/132","nickname":"chaoxifuchen","note":"","ucode":"95DCC5C4994F68","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358791,"discussion_content":"我没想到，回答到点子上了，牛逼！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616051019,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2440448,"avatar":"https://static001.geekbang.org/account/avatar/00/25/3d/00/4f6c4d61.jpg","nickname":"当山水深入繁华。","note":"","ucode":"C72C326D1FD72D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":355996,"discussion_content":"连锁反应了就","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615515763,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1541014,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/96/73ff13a0.jpg","nickname":"天亮前说晚安","note":"","ucode":"1D82EE562A7C71","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284618,"discussion_content":"你的意思是驱动表的数据是放在join buffer中，被驱动表是放在pool buffer中吗？然后做比较","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592570601,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1254493,"avatar":"https://static001.geekbang.org/account/avatar/00/13/24/5d/65e61dcb.jpg","nickname":"听雨","note":"","ucode":"252754F9FCFF0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1541014,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/96/73ff13a0.jpg","nickname":"天亮前说晚安","note":"","ucode":"1D82EE562A7C71","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":313255,"discussion_content":"InnoDB读取数据时会放到buffer pool中，然后返回server层需要的那条数据给server做比较","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1603013134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":284618,"ip_address":""},"score":313255,"extra":""}]},{"author":{"id":1438035,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f1/53/31d92c97.jpg","nickname":"菜小猫","note":"","ucode":"ED1F5F70E02725","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281018,"discussion_content":"学习了，谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591663575,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181505,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/41/2d477385.jpg","nickname":"柠檬C","note":"","ucode":"BC0EE704D952A4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":153052,"discussion_content":"牛逼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580019024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1019332,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","nickname":"长期规划","note":"","ucode":"5EF65E9115834B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56482,"discussion_content":"牛👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574487093,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1026219,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/ab/5d25cd32.jpg","nickname":"客舟听雨来coding","note":"","ucode":"753F4B779CC416","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52289,"discussion_content":"学习","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574035562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64780,"user_name":"斜面镜子 Bill","can_delete":false,"product_type":"c1","uid":1305242,"ip_address":"","ucode":"B5505F94540D52","user_header":"https://static001.geekbang.org/account/avatar/00/13/ea/9a/02d589f9.jpg","comment_is_top":false,"comment_ctime":1548906408,"is_pvip":false,"replies":[{"id":"22937","content":"👍很赞<br>之前知识点的也都加进来啦","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548923054,"ip_address":"","comment_id":64780,"utype":1}],"discussion_count":5,"race_medal":0,"score":"864837332904","product_id":100020801,"comment_content":"因为 join_buffer 不够大，需要对被驱动表做多次全表扫描，也就造成了“长事务”。除了老师上节课提到的导致undo log 不能被回收，导致回滚段空间膨胀问题，还会出现：1. 长期占用DML锁，引发DDL拿不到锁堵慢连接池； 2. SQL执行socket_timeout超时后业务接口重复发起，导致实例IO负载上升出现雪崩；3. 实例异常后，DBA kill SQL因繁杂的回滚执行时间过长，不能快速恢复可用；4. 如果业务采用select *作为结果集返回，极大可能出现网络拥堵，整体拖慢服务端的处理；5. 冷数据污染buffer pool，block nested-loop多次扫描，其中间隔很有可能超过1s，从而污染到lru 头部，影响整体的查询体验。","like_count":202,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438175,"discussion_content":"👍很赞\n之前知识点的也都加进来啦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548923054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1890006,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/d6/d6/5fbb6e00.jpg","nickname":"再忙也要充充电","note":"","ucode":"098F2D9D280D60","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380820,"discussion_content":"我靠，为啥我前面学的知识串不起来！！！！我头上长的是脑袋吗？？？","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1624713454,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1890006,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/d6/d6/5fbb6e00.jpg","nickname":"再忙也要充充电","note":"","ucode":"098F2D9D280D60","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380821,"discussion_content":"错了 我脖子上长的是脑袋吗？？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1624713483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1124075,"avatar":"https://static001.geekbang.org/account/avatar/00/11/26/eb/24e0ac9c.jpg","nickname":"嬴梦川","note":"","ucode":"104CDFD26A1711","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375116,"discussion_content":"精辟，比楼上的分析更全面","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1621488155,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1020492,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/4c/40783447.jpg","nickname":"何骧","note":"","ucode":"11DCC74CE2F300","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301875,"discussion_content":"你怎么如此优秀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598691699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64518,"user_name":"老杨同志","can_delete":false,"product_type":"c1","uid":1246199,"ip_address":"","ucode":"3F334F0CFD3DE6","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/f7/3a493bec.jpg","comment_is_top":false,"comment_ctime":1548814650,"is_pvip":false,"replies":[{"id":"22840","content":"漂亮👍","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548818033,"ip_address":"","comment_id":64518,"utype":1}],"discussion_count":1,"race_medal":0,"score":"254951885114","product_id":100020801,"comment_content":"对被驱动表进行全表扫描，会把冷数据的page加入到buffer pool.,并且block nested-loop要扫描多次，两次扫描的时间可能会超过1秒，使lru的那个优化失效，把热点数据从buffer pool中淘汰掉，影响正常业务的查询效率","like_count":60,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438043,"discussion_content":"漂亮👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548818033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64605,"user_name":"Zzz","can_delete":false,"product_type":"c1","uid":1116272,"ip_address":"","ucode":"4AA47797F48315","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIu1n1DhUGGKTjelrQaLYOSVK2rsFeia0G8ASTIftib5PTOx4pTqdnfwb0NiaEFGRgS661nINyZx9sUg/132","comment_is_top":false,"comment_ctime":1548834098,"is_pvip":false,"replies":[{"id":"22880","content":"你说得对，分两类情况，<br>小于bp 3&#47;8的情况会跑到young，<br>大于3&#47;8的会影响young部分的更新","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548839684,"ip_address":"","comment_id":64605,"utype":1}],"discussion_count":4,"race_medal":0,"score":"164757591346","product_id":100020801,"comment_content":"林老师，我没想清楚为什么会进入young区域。假设大表t大小是M页&gt;old区域N页，由于Block Nested-Loop Join需要对t进行k次全表扫描。第一次扫描时，1~N页依次被放入old区域，访问N+1页时淘汰1页，放入N+1页，以此类推，第一次扫描结束后old区域存放的是M-N+1~M页。第二次扫描开始，访问1页，淘汰M-N+1页，放入1页。可以把M页想象成一个环，N页想象成在这个环上滑动的窗口，由于M&gt;N，不管是哪次扫描，需要访问的页都不会在滑动窗口上，所以不会存在“被访问的时候数据页在 LRU 链表中存在的时间超过了 1 秒“而被放入young的情况。我能想到的会被放入young区域的情况是，在当次扫描中，由于一页上有多行数据，需要对该页访问多次，超过了1s，不管这种情况就和t大小没关系了，而是由于page size太大，而一行数据太少。","like_count":39,"discussions":[{"author":{"id":1263932,"avatar":"https://static001.geekbang.org/account/avatar/00/13/49/3c/5d54c510.jpg","nickname":"静静聆听","note":"","ucode":"0A8600CB928EFE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291867,"discussion_content":"大佬，说的太对了，这样只有驱动表特别大，被驱动表的总数据小于old区，这样循环读取被驱动表的数据，才会超过1s","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1594980518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438095,"discussion_content":"你说得对，分两类情况，\n小于bp 3/8的情况会跑到young，\n大于3/8的会影响young部分的更新","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1548839684,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1019302,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8d/a6/22c37c91.jpg","nickname":"楊_宵夜","note":"","ucode":"7BA0CADC5F23BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384664,"discussion_content":"你很优秀你知道吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626694792,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1652836,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epKJlW7sqts2ZbPuhMbseTAdvHWnrc4ficAeSZyKibkvn6qyxflPrkKKU3mH6XCNmYvDg11tB6y0pxg/132","nickname":"pc","note":"","ucode":"1AD538B9A900B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":138509,"discussion_content":"驱动表分段读，被驱动表要多次循环读","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579249067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64539,"user_name":"清风浊酒","can_delete":false,"product_type":"c1","uid":1302407,"ip_address":"","ucode":"4BB111C61A40C4","user_header":"https://static001.geekbang.org/account/avatar/00/13/df/87/0e05dadd.jpg","comment_is_top":false,"comment_ctime":1548817220,"is_pvip":false,"replies":[{"id":"22864","content":"不会强制，但是由于语义的关系，大概率上是按照语句上写的关系去驱动，效率是比较高的","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548822912,"ip_address":"","comment_id":64539,"utype":1}],"discussion_count":2,"race_medal":0,"score":"156167639876","product_id":100020801,"comment_content":"老师您好，left join 和 right join 会固定驱动表吗？","like_count":36,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438058,"discussion_content":"不会强制，但是由于语义的关系，大概率上是按照语句上写的关系去驱动，效率是比较高的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548822912,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3007210,"avatar":"","nickname":"Geek_a1699c","note":"","ucode":"CF7DB00BE36B77","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577214,"discussion_content":"正好想问这个问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655973141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64864,"user_name":"泡泡爱dota","can_delete":false,"product_type":"c1","uid":1306894,"ip_address":"","ucode":"9C718109D16B06","user_header":"https://static001.geekbang.org/account/avatar/00/13/f1/0e/e9b57b9b.jpg","comment_is_top":false,"comment_ctime":1548928824,"is_pvip":false,"replies":[{"id":"22945","content":"如果数据量不够多，并且满足a&lt;50的行，占比比较高的话，优化器有可能会认为“还要回表，还不如直接扫主键id”","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548936644,"ip_address":"","comment_id":64864,"utype":1}],"discussion_count":4,"race_medal":0,"score":"147577816888","product_id":100020801,"comment_content":"explain select * from t1 straight_join t2 on (t1.a=t2.a) where t1.a &lt; 50; <br>老师, 这条sql为什么t1.a的索引没有用上, t1还是走全表<br>","like_count":35,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438211,"discussion_content":"如果数据量不够多，并且满足a&amp;lt;50的行，占比比较高的话，优化器有可能会认为“还要回表，还不如直接扫主键id”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548936644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1692320,"avatar":"https://static001.geekbang.org/account/avatar/00/19/d2/a0/c8714628.jpg","nickname":"独一无二","note":"","ucode":"A7DE0EA2BD8FE3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":71776,"discussion_content":"查询的结果集大于等于总数据行的25%，就会直接回表查询。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1575457317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1986739,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/50/b3/9269cd59.jpg","nickname":"LWD","note":"","ucode":"DDA444DB113C01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588140,"discussion_content":"因为是select *；走a的索引还需要回表","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1663573731,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1213254,"avatar":"https://static001.geekbang.org/account/avatar/00/12/83/46/528d842e.jpg","nickname":"zhouHao","note":"","ucode":"2F38631785CFC8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297067,"discussion_content":"生产上碰到了这个情况，新上线的表数据为空，一张已有20W条数据的表left join新表，没有走索引，全表扫描了，差点酿成事故","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596765437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64703,"user_name":"郝攀刚จุ๊บ","can_delete":false,"product_type":"c1","uid":1206745,"ip_address":"","ucode":"8AE7A85093E51A","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/d9/968df259.jpg","comment_is_top":false,"comment_ctime":1548861869,"is_pvip":false,"replies":[{"id":"22911","content":"😓<br>Explain下，没用用index nested-loop 的全要优化","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548908087,"ip_address":"","comment_id":64703,"utype":1}],"discussion_count":7,"race_medal":0,"score":"104628076973","product_id":100020801,"comment_content":"业务逻辑关系，一个SQL中left join7，8个表。这我该怎么优化。每次看到这些脑壳就大！","like_count":25,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438141,"discussion_content":"😓\nExplain下，没用用index nested-loop 的全要优化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548908087,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296708,"discussion_content":"说说我自己的经验，很早之前做报表数据的时候，页面展示的爆表大部分都是分页查询，但是查询的时候并没有考虑，每次都是算全部，计算结果也非常多，当时有个几百行的sql，看着头都大了，后来拆分，咋拆分来，先计算好分页，然后每一列的数据，都是一个小的sql语句计算，多列就开多线程【一主多从】，业务自己在计算一层，对于分页展示的爆表，速度从分钟级别提高到了秒级别。\n再优化，对于计算结果可以存储的直接存储到缓存，命中级别提高到了毫秒级别。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1596628223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2350230,"avatar":"https://static001.geekbang.org/account/avatar/00/23/dc/96/9501cd87.jpg","nickname":"无痕之意","note":"","ucode":"8AF05C8C813352","race_medal":3,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530353,"discussion_content":"回去试验看看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637060009,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1447569,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/WtHCCMoLJ2DvzqQwPYZyj2RlN7eibTLMHDMTSO4xIKjfKR1Eh9L98AMkkZY7FmegWyGLahRQJ5ibPzeeFtfpeSow/132","nickname":"脱缰的野马__","note":"","ucode":"D5F993E7232C61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":316653,"discussion_content":"牛逼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603434683,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1214582,"avatar":"https://static001.geekbang.org/account/avatar/00/12/88/76/c69b7fe5.jpg","nickname":"youngitachi","note":"","ucode":"88717CA8B8ED64","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":209472,"discussion_content":"就是啊，多个表join，想想就头疼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584632198,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1745179,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/j0gBKF8EKfRMTnBOqXR3xcqquJdzYUibXOIb32HejppBPo644p6JB3Et08Su4TUaDRWt8DzPxYtm8iabEJN2uJKw/132","nickname":"一个顶三","note":"","ucode":"165596847783D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":133788,"discussion_content":"兄弟， 我这边不止join7，8个表， 还带上那种case when语句，explain出来全是dirived， 光想想就脑阔疼。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578989257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2014285,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKNv880TlsNuKaWcKbxiaAZTQIBWfJAddC8wfOROnwRPRwJXaEGSTBH2sic4jK7IGpxZn79tTDcREjw/132","nickname":"Geek_7482f6","note":"","ucode":"F3565F78525D30","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1745179,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/j0gBKF8EKfRMTnBOqXR3xcqquJdzYUibXOIb32HejppBPo644p6JB3Et08Su4TUaDRWt8DzPxYtm8iabEJN2uJKw/132","nickname":"一个顶三","note":"","ucode":"165596847783D9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":410413,"discussion_content":"从我的经验来看，这么复杂的计算应该考虑采用实时计算或离线计算的方案，不应该用mysql的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635689269,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":133788,"ip_address":""},"score":410413,"extra":""}]}]},{"had_liked":false,"id":64477,"user_name":"萤火虫","can_delete":false,"product_type":"c1","uid":1333142,"ip_address":"","ucode":"FA4AB9636C53C4","user_header":"https://static001.geekbang.org/account/avatar/00/14/57/96/b65bdf43.jpg","comment_is_top":false,"comment_ctime":1548809447,"is_pvip":false,"replies":[{"id":"22826","content":"今年这情况还是要先克制一下^_^ <br>先把内功练起来😆","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548810223,"ip_address":"","comment_id":64477,"utype":1}],"discussion_count":3,"race_medal":0,"score":"104628024551","product_id":100020801,"comment_content":"年底了有一种想跳槽的冲动 身在武汉的我想出去看看 可一想到自身的能力和学历 又不敢去了 苦恼... ","like_count":24,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438018,"discussion_content":"今年这情况还是要先克制一下^_^ \n先把内功练起来😆","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548810223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1194853,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3b/65/3a4fc8cf.jpg","nickname":"prepared","note":"","ucode":"00E54A5C7CDCBE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337963,"discussion_content":"感觉 试试没坏处，别裸辞就行","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1609138040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1056982,"avatar":"https://static001.geekbang.org/account/avatar/00/10/20/d6/b9513db0.jpg","nickname":"kingcall","note":"","ucode":"508884DC684B5B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589943,"discussion_content":"19 年不行 20年不行 21年不行 22年不行","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1665409080,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"重庆"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64571,"user_name":"amazon1011","can_delete":false,"product_type":"c1","uid":1001032,"ip_address":"","ucode":"BD745BDCBD7059","user_header":"https://static001.geekbang.org/account/avatar/00/0f/46/48/e959b1e0.jpg","comment_is_top":false,"comment_ctime":1548826793,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"65973336233","product_id":100020801,"comment_content":"这个专栏受益匪浅，老师再搞个内核源码专栏：）","like_count":15,"discussions":[{"author":{"id":2014285,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKNv880TlsNuKaWcKbxiaAZTQIBWfJAddC8wfOROnwRPRwJXaEGSTBH2sic4jK7IGpxZn79tTDcREjw/132","nickname":"Geek_7482f6","note":"","ucode":"F3565F78525D30","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":410414,"discussion_content":"内核比mysql的又高一个难度等级了~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635689300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1618704,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b3/10/123b345f.jpg","nickname":"俊杰锅","note":"","ucode":"94B1AB400433FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333487,"discussion_content":"期待","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607528551,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64456,"user_name":"抽离の❤️","can_delete":false,"product_type":"c1","uid":1099436,"ip_address":"","ucode":"6CBCE2610CF768","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/ac/60d1fd42.jpg","comment_is_top":false,"comment_ctime":1548807685,"is_pvip":false,"replies":[{"id":"22823","content":"好早呀🤝","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548809986,"ip_address":"","comment_id":64456,"utype":1}],"discussion_count":1,"race_medal":0,"score":"61678349829","product_id":100020801,"comment_content":"早上听老师一节课感觉获益匪浅","like_count":14,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438008,"discussion_content":"好早呀🤝","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548809986,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72329,"user_name":"思考特～","can_delete":false,"product_type":"c1","uid":1301824,"ip_address":"","ucode":"B9B4E64962BAD2","user_header":"https://static001.geekbang.org/account/avatar/00/13/dd/40/a185dfcb.jpg","comment_is_top":false,"comment_ctime":1551588139,"is_pvip":false,"replies":[{"id":"26215","content":"我的建议就是用好NLJ和BKA算法😆","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1551607940,"ip_address":"","comment_id":72329,"utype":1}],"discussion_count":5,"race_medal":0,"score":"53091195691","product_id":100020801,"comment_content":"老师，这边想请教一个困扰很久的问题，用mysql经常会制定这么一个规则，不允许多表join。从实际情况看，几乎不太可能遵守这个规则，有个交易的业务场景涉及 用户表 300W、订单表 900W、支付表 900W，每次需要查一个用户下面的订单信息可能就有点慢了，但是还能接受，如果是查询一个团体的订单信息，这个量就非常可观了,查询有时候根本返回不了结果。根本无法避免多表Join，所以想问问老师，在这种需要多表Join业务场景下，如何设计表，来提升性能？或者有这方面推荐的资料可以参考的","like_count":12,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441544,"discussion_content":"我的建议就是用好NLJ和BKA算法😆","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551607940,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2009461,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/a9/75/dbccd12d.jpg","nickname":"稻草人","note":"","ucode":"6694EE2CD36B8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":356895,"discussion_content":"可以在业务层做数据merge啊。先根据条件过滤出每个表需要找的数据，然后拿到业务代码层面做整合，相比于多表join友好多了，后续优化也容易点。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1615701023,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1441643,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo8szvJib6nEGAqloXibINcVquibUtiaEU1TEITIeH7119micVn8HF4Y3T0gMDyfFIAUqnhMia4o2fWe6Nw/132","nickname":"WUYG","note":"","ucode":"E198E33B064E0B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2009461,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/a9/75/dbccd12d.jpg","nickname":"稻草人","note":"","ucode":"6694EE2CD36B8C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383035,"discussion_content":"请教一下 那分页怎么处理呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1625838140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":356895,"ip_address":""},"score":383035,"extra":""},{"author":{"id":1209939,"avatar":"https://static001.geekbang.org/account/avatar/00/12/76/53/21d62a23.jpg","nickname":"鲁·本","note":"","ucode":"F1DEB30C21B48E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1441643,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo8szvJib6nEGAqloXibINcVquibUtiaEU1TEITIeH7119micVn8HF4Y3T0gMDyfFIAUqnhMia4o2fWe6Nw/132","nickname":"WUYG","note":"","ucode":"E198E33B064E0B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574814,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654358869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":383035,"ip_address":""},"score":574814,"extra":""},{"author":{"id":1986739,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/50/b3/9269cd59.jpg","nickname":"LWD","note":"","ucode":"DDA444DB113C01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1441643,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo8szvJib6nEGAqloXibINcVquibUtiaEU1TEITIeH7119micVn8HF4Y3T0gMDyfFIAUqnhMia4o2fWe6Nw/132","nickname":"WUYG","note":"","ucode":"E198E33B064E0B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588141,"discussion_content":"这种只能从业务入手，比如设计成前10页可以跳页，后面就只能一页一页翻；","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663574016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":383035,"ip_address":"广东"},"score":588141,"extra":""}]}]},{"had_liked":false,"id":66015,"user_name":"呵呵","can_delete":false,"product_type":"c1","uid":1253836,"ip_address":"","ucode":"6783A42717C666","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Nic2zzpAuiadVibETy3Um3IcjOa4O9gr8zVagG6tCbMlFF8O3tNmwMJicEEsA9pibcxgibtyKhl1ZicXYX8kLfXs6AMmg/132","comment_is_top":false,"comment_ctime":1549851908,"is_pvip":false,"replies":[{"id":"23401","content":"新年好<br><br>嗯优化器大部分时候会选对，如果选不对，我们就得自己强行指定了哈<br><br>其实了解这个原理主要还是指导我们根据最优的join顺序，来创建被驱动表字段上的索引<br>","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1549873580,"ip_address":"","comment_id":66015,"utype":1}],"discussion_count":1,"race_medal":0,"score":"53089459460","product_id":100020801,"comment_content":"老师，新年好！<br>优化器会自动选择小表作为驱动表，那么我们人为把小表写成驱动表还有意义吗？ ","like_count":12,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438679,"discussion_content":"新年好\n\n嗯优化器大部分时候会选对，如果选不对，我们就得自己强行指定了哈\n\n其实了解这个原理主要还是指导我们根据最优的join顺序，来创建被驱动表字段上的索引\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549873580,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250852,"user_name":"张旭","can_delete":false,"product_type":"c1","uid":1256155,"ip_address":"","ucode":"8029AFFC0AF9D4","user_header":"https://static001.geekbang.org/account/avatar/00/13/2a/db/86437192.jpg","comment_is_top":false,"comment_ctime":1601261569,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"48845901825","product_id":100020801,"comment_content":"NLJ：驱动表选出一行行数据到被驱动表中查找  <br>BNL：把驱动表的数据分段读入join buffer中，然后和被驱动表join<br>MRR：针对回表操作做的优化，把索引上的主键排序，然后再回表，这样就可以随机读变为顺序读<br>BKA：是针对NLJ的优化，不是像NLJ一行行取出数据去被驱动表查找，而是一次取出一批到join buffer中然后到被驱动表中查找，获得关联的记录，再使用MRR优化获取最终结果","like_count":12},{"had_liked":false,"id":64482,"user_name":"柚子","can_delete":false,"product_type":"c1","uid":1002136,"ip_address":"","ucode":"7641A699DA0CFD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/NhbRicjvf8v3K6D3v1FtOicxOciaPZQsCjCmuGCqea4vJeRVaLicKLpAcFQlcTgLvczBWY7SYDkeOtibxXj1PGl7Nug/132","comment_is_top":false,"comment_ctime":1548810379,"is_pvip":true,"replies":[{"id":"22839","content":"join也是普通查询，都不需要加锁哦，参考下MVCC那篇；<br><br>就是我们文中说的，“分两步查询，先查驱动表，然后查多个in”，如果可以用上被驱动表的索引，我觉得可以用上Index Nested-Loop Join算法，其实效果是跟拆开写类似的","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548816978,"ip_address":"","comment_id":64482,"utype":1}],"discussion_count":4,"race_medal":0,"score":"48793450635","product_id":100020801,"comment_content":"join在热点表操作中，join查询是一次给两张表同时加锁吧，会不会增大锁冲突的几率？<br>业务中肯定要使用被驱动表的索引，通常我们是先在驱动表查出结果集，然后再通过in被驱动表索引字段，分两步查询，这样是否比直接join委托点？","like_count":11,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438020,"discussion_content":"join也是普通查询，都不需要加锁哦，参考下MVCC那篇；\n\n就是我们文中说的，“分两步查询，先查驱动表，然后查多个in”，如果可以用上被驱动表的索引，我觉得可以用上Index Nested-Loop Join算法，其实效果是跟拆开写类似的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548816978,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1986739,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/50/b3/9269cd59.jpg","nickname":"LWD","note":"","ucode":"DDA444DB113C01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573082,"discussion_content":"还是代码层面合并比较好。一般都不太建议用join,因为代码不好复用,后续重构和优化也不太好处理\n","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1653196296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2086624,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/d6/e0/3ccaaa7b.jpg","nickname":"领子","note":"","ucode":"64AC4E6AB74E68","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295150,"discussion_content":"实在不想用mysql的Index Nested-Loop Join，可以在代码层实现合并扫描连接","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596103850,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1310798,"avatar":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","nickname":"吴小智","note":"","ucode":"C7C9F58B5C9F7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4692,"discussion_content":"分两步查，in 接收的参数是有限制的，如果从驱动表查出的结果集很多，很容易就出 bug  了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565664477,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81792,"user_name":"啊啊啊哦哦","can_delete":false,"product_type":"c1","uid":1309877,"ip_address":"","ucode":"68C7153ECAAC57","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/RNO4yZyBvic914hewmNNE8iblYDcfv5yGHZ9OnKuCuZXNmGR0F5qV3icKLT2xpMt66GyEpicZVvrmz8A6TIqt92MQg/132","comment_is_top":false,"comment_ctime":1554036983,"is_pvip":false,"replies":[{"id":"30223","content":"不是的<br><br>如果是NLJ，就是遍历过程中直接到被驱动表去匹配，匹配满足条件的行，就直接作为结果集发出去了，不需要临时内存","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1554653406,"ip_address":"","comment_id":81792,"utype":1}],"discussion_count":1,"race_medal":0,"score":"44503709943","product_id":100020801,"comment_content":"NLJ join算法下。  驱动表假设全表先扫描。  这个全表扫描的数据存放在哪。 buffer bool中还是。全表扫描到单独的read buffer中？ 我的理解是。 驱动表全表扫描的数据。是从buffer bool中找驱动表的数据到 read buffer中。如果buffer bool 没有。那么从磁盘。到buffer bool 然后在到read buffer 中。 我的理解对吗。 ","like_count":10,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445346,"discussion_content":"不是的\n\n如果是NLJ，就是遍历过程中直接到被驱动表去匹配，匹配满足条件的行，就直接作为结果集发出去了，不需要临时内存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554653406,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":65885,"user_name":"403","can_delete":false,"product_type":"c1","uid":1001867,"ip_address":"","ucode":"D9360256DFEF5D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/8b/3596a3e2.jpg","comment_is_top":false,"comment_ctime":1549723863,"is_pvip":false,"replies":[{"id":"23279","content":"会的","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1549740281,"ip_address":"","comment_id":65885,"utype":1}],"discussion_count":1,"race_medal":0,"score":"44499396823","product_id":100020801,"comment_content":"用那个作为驱动表，mysql会自己优化么？","like_count":10,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438628,"discussion_content":"会的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549740281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64752,"user_name":"Ryoma","can_delete":false,"product_type":"c1","uid":1130590,"ip_address":"","ucode":"7F692369239692","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/5e/b8fada94.jpg","comment_is_top":false,"comment_ctime":1548899970,"is_pvip":true,"replies":[{"id":"22906","content":"是的，不过在MySQL 里面，这样算“扫描一行”，实际上确实做了两次树搜索","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548906354,"ip_address":"","comment_id":64752,"utype":1}],"discussion_count":1,"race_medal":2,"score":"40203605634","product_id":100020801,"comment_content":"上文中使用索引时扫描行数为200，但是根据字段a去做树搜索时，由于字段a是普通索引，在找到匹配值后还会继续匹配，实际上每个循环都做了至少两次的行扫描。<br>老师，这么理解对么？","like_count":9,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438161,"discussion_content":"是的，不过在MySQL 里面，这样算“扫描一行”，实际上确实做了两次树搜索","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548906354,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64745,"user_name":"felix","can_delete":false,"product_type":"c1","uid":1086157,"ip_address":"","ucode":"DF514D0BB9B508","user_header":"https://static001.geekbang.org/account/avatar/00/10/92/cd/d39e568c.jpg","comment_is_top":false,"comment_ctime":1548898938,"is_pvip":false,"replies":[{"id":"22907","content":"逗号分隔两表还是join 😄<br>下一篇会讲到优化，主要思路就是用上被驱动表索引哈","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548906531,"ip_address":"","comment_id":64745,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35908637306","product_id":100020801,"comment_content":"不让用join，那用什么呢，用逗号分隔两表？<br>join有多个条件的话，写在on后面和where后面有什么区别吗？","like_count":9,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438157,"discussion_content":"逗号分隔两表还是join 😄\n下一篇会讲到优化，主要思路就是用上被驱动表索引哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548906531,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72362,"user_name":"Franis","can_delete":false,"product_type":"c1","uid":1314217,"ip_address":"","ucode":"01861E7349173F","user_header":"https://static001.geekbang.org/account/avatar/00/14/0d/a9/8ddbfcd9.jpg","comment_is_top":false,"comment_ctime":1551597659,"is_pvip":false,"replies":[{"id":"26212","content":"如果有严格的一对多，而且要join够快一般都会在join 字段上创建索引，<br>这时候应该选“一”为驱动表","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1551604984,"ip_address":"","comment_id":72362,"utype":1}],"discussion_count":2,"race_medal":0,"score":"31616368731","product_id":100020801,"comment_content":"老师，想问一下，如果是“一对多”的多个表进行join的话，应该选择“多”的表作为驱动表，还是选择“一”的表作为驱动表呢？","like_count":7,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441558,"discussion_content":"如果有严格的一对多，而且要join够快一般都会在join 字段上创建索引，\n这时候应该选“一”为驱动表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551604984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2086624,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/d6/e0/3ccaaa7b.jpg","nickname":"领子","note":"","ucode":"64AC4E6AB74E68","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295154,"discussion_content":"这个情况要看where条件","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596104270,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":68607,"user_name":"1024","can_delete":false,"product_type":"c1","uid":1086407,"ip_address":"","ucode":"DCC31F6EC54F43","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/c7/86352ccc.jpg","comment_is_top":false,"comment_ctime":1550556332,"is_pvip":false,"replies":[{"id":"24359","content":"这个我在答疑文章中展开哈，其实还是“内存数据是从哪里来的”的问题。<br><br>我们这里说的是BNL比Simple nested loop 快哈","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1550562157,"ip_address":"","comment_id":68607,"utype":1}],"discussion_count":4,"race_medal":0,"score":"31615327404","product_id":100020801,"comment_content":"文中解释NLJ和BNL时间复杂度相同，都是M*N。但是对于BNL性能好于NLJ的原因只是提到:&quot;BNL的判断是在内存中操作，速度上会快很多，性能也更好&quot;。请问老师？这句话的言外之意是: NLJ的判断不是在内存中操作吗？不将数据加载到内存，CPU如何进行判断呢?","like_count":8,"discussions":[{"author":{"id":2254917,"avatar":"https://static001.geekbang.org/account/avatar/00/22/68/45/ddf89612.jpg","nickname":"bestgopher","note":"","ucode":"D89735C8CA9C6E","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555420,"discussion_content":"什么时候说block nested-loop 比 index nested-loop 快了？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1646897672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439753,"discussion_content":"这个我在答疑文章中展开哈，其实还是“内存数据是从哪里来的”的问题。\n\n我们这里说的是BNL比Simple nested loop 快哈","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1550562157,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1986739,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/50/b3/9269cd59.jpg","nickname":"LWD","note":"","ucode":"DDA444DB113C01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588142,"discussion_content":"一个是局部变量，一个是走引擎接口，引擎接口的数据可能在内存也可能在磁盘","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663574300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1088853,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9d/55/9d240eef.jpg","nickname":"冰魄","note":"","ucode":"D152C0BEA3074D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1231,"discussion_content":"我也有这个疑问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562420304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64538,"user_name":"asdf100","can_delete":false,"product_type":"c1","uid":1043738,"ip_address":"","ucode":"39D8D71453E575","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/1a/ce7f7d54.jpg","comment_is_top":false,"comment_ctime":1548816868,"is_pvip":false,"replies":[{"id":"22847","content":"“则采用存放 到 join buffer 里的字段数量来决定”<br>改成 “字段长度总和” 就更准确啦 🤝","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548818886,"ip_address":"","comment_id":64538,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31613587940","product_id":100020801,"comment_content":"explain select * from t1 straight_join t2 on (t1.b=t2.b) where t2.id&lt;=50;<br>explain select * from t2 straight_join t1 on (t1.b=t2.b) where t2.id&lt;=50;<br>看两个sql的分析结果的 rows列数量，数量小的作为驱动表。而对于记录个数一样的，则采用存放 到 join buffer 里的字段数量来决定。<br>这样理解对么？","like_count":7,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438057,"discussion_content":"“则采用存放 到 join buffer 里的字段数量来决定”\n改成 “字段长度总和” 就更准确啦 🤝","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548818886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64483,"user_name":"书策稠浊","can_delete":false,"product_type":"c1","uid":1307497,"ip_address":"","ucode":"A29875CE15FDA3","user_header":"https://static001.geekbang.org/account/avatar/00/13/f3/69/7039d03f.jpg","comment_is_top":false,"comment_ctime":1548810735,"is_pvip":false,"replies":[{"id":"22835","content":"早^_^<br>Simple的是每次都去全表扫描，全表扫描可就不保证在内存里了，Buffer Pool会淘汰，有可能在磁盘的","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548816404,"ip_address":"","comment_id":64483,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27318614511","product_id":100020801,"comment_content":"但是，Block Nested-Loop Join 算法的这 10 万次判断是内存操作，速度上会快很多，性能也更好。<br>那Simple那种是直接在引擎里面计算吗？但是计算不都应该在内存吗？所以不理解为什么这里会更快，难得一次抢到这么早的留言，请老师指教，谢谢。","like_count":7,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438021,"discussion_content":"早^_^\nSimple的是每次都去全表扫描，全表扫描可就不保证在内存里了，Buffer Pool会淘汰，有可能在磁盘的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548816404,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":116690,"user_name":"长期规划","can_delete":false,"product_type":"c1","uid":1019332,"ip_address":"","ucode":"5EF65E9115834B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","comment_is_top":false,"comment_ctime":1563891162,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"23038727642","product_id":100020801,"comment_content":"老师，既然MySQL会自己优化使用哪个表当驱动表，那程序员在写jion语句时就不用纠结该写A jion B还是B jion A了吧","like_count":5,"discussions":[{"author":{"id":2086624,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/d6/e0/3ccaaa7b.jpg","nickname":"领子","note":"","ucode":"64AC4E6AB74E68","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295152,"discussion_content":"完全不用纠结，优化器会根据你创建的已有索引/where条件去选择表的访问顺序,如果优化器选错了访问顺序，可以通过改写sql，或者强制指定连接顺序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596104017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135593,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/e9/f244988e.jpg","nickname":"NIRVANA","note":"","ucode":"F3A979679AA44E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291113,"discussion_content":"但是mysql可能会错误判断","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594710279,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":74949,"user_name":"Cy190622","can_delete":false,"product_type":"c1","uid":1381528,"ip_address":"","ucode":"578D804C29248E","user_header":"https://static001.geekbang.org/account/avatar/00/15/14/98/0251b8fd.jpg","comment_is_top":false,"comment_ctime":1552320229,"is_pvip":false,"replies":[{"id":"30024","content":"1. 对，explai<br>2. 如果你写了STRAIGHT_JOIN，那没得选啦，就是t1做驱动表。<br>   这种情况，如果你改用join，应该会选t2做驱动表","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1554432859,"ip_address":"","comment_id":74949,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23027156709","product_id":100020801,"comment_content":"专栏已经更新完毕，首先谢谢老师；有以下几个小问题，希望老师有时间能够看到。<br>1.普通的join查询是被执行器优化执行过的吧？但是优化执行是否做到最好呢？怎么验证一下优化过程用的是那种方式呢？是用两个表互换explain一下吗？<br>2.这种查询优化在Mysql哪个版本中做了较大的加强。<br>3.SELECT * FROM t1 STRAIGHT_JOIN t2 ON (t1.a=t2.b);  （t1是以a为索引的100行数据，t2中b非索引1000条数据）t1做了驱动表，属于BNL情形；如果用t2作为驱动表，t1的a索引就可以用，属于NLJ情形，选择哪个表作为驱动表更好呢？<br>","like_count":5,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442752,"discussion_content":"1. 对，explai\n2. 如果你写了STRAIGHT_JOIN，那没得选啦，就是t1做驱动表。\n   这种情况，如果你改用join，应该会选t2做驱动表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554432859,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72694,"user_name":"Franis","can_delete":false,"product_type":"c1","uid":1314217,"ip_address":"","ucode":"01861E7349173F","user_header":"https://static001.geekbang.org/account/avatar/00/14/0d/a9/8ddbfcd9.jpg","comment_is_top":false,"comment_ctime":1551696240,"is_pvip":false,"replies":[{"id":"27063","content":"要看索引😓","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1552103765,"ip_address":"","comment_id":72694,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23026532720","product_id":100020801,"comment_content":"如果我产品表有十条数据，订单表有一万条数据。<br>为什么我用订单表作为驱动表会比用产品表作为驱动表速度快呢？","like_count":5,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441690,"discussion_content":"要看索引😓","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552103765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1986739,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/50/b3/9269cd59.jpg","nickname":"LWD","note":"","ucode":"DDA444DB113C01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573084,"discussion_content":"很好奇。就这么点数据怎么看出快不快呢。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653196657,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64758,"user_name":"有铭","can_delete":false,"product_type":"c1","uid":1046302,"ip_address":"","ucode":"2C7CB36CA5C04C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/3XbCueYYVWTiclv8T5tFpwiblOxLphvSZxL4ujMdqVMibZnOiaFK2C5nKRGv407iaAsrI0CDICYVQJtiaITzkjfjbvrQ/132","comment_is_top":false,"comment_ctime":1548901297,"is_pvip":false,"replies":[{"id":"22905","content":"👍🏿 看的同学有收获我最开心啦","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548906303,"ip_address":"","comment_id":64758,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23023737777","product_id":100020801,"comment_content":"今天这篇看了犹如醍醐灌顶一般，以前一直没搞明白当表数据比较大的时候join_buf是如何工作的，原来是分段载入的","like_count":6,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438163,"discussion_content":"👍🏿 看的同学有收获我最开心啦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548906303,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64583,"user_name":"Zzz","can_delete":false,"product_type":"c1","uid":1116272,"ip_address":"","ucode":"4AA47797F48315","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIu1n1DhUGGKTjelrQaLYOSVK2rsFeia0G8ASTIftib5PTOx4pTqdnfwb0NiaEFGRgS661nINyZx9sUg/132","comment_is_top":false,"comment_ctime":1548829312,"is_pvip":false,"replies":[{"id":"22874","content":"这是很好的思考<br>不够要考虑下，不止扫描一次哦，每次扫描放一部分到young区域，命中率就少一些","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548832276,"ip_address":"","comment_id":64583,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23023665792","product_id":100020801,"comment_content":"林老师，关于课后问题，很多留言都提到大表数据会进入LRU young区域，这个是一定发生的吗？如果大表数据少于LRU old区域的大小，那所有大表数据都会进入young区域没问题。如果大表数据多于old区域的大小，下次扫描的时候早进入old区域的page都已经被淘汰出去，所以不会因为超过1s而进入young区域，导致的结果就是old区域hit很低，读取新一页都需要从磁盘读取到内存。","like_count":5,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438086,"discussion_content":"这是很好的思考\n不够要考虑下，不止扫描一次哦，每次扫描放一部分到young区域，命中率就少一些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548832276,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64527,"user_name":"长杰","can_delete":false,"product_type":"c1","uid":1312212,"ip_address":"","ucode":"DD52C9494005F7","user_header":"https://static001.geekbang.org/account/avatar/00/14/05/d4/e06bf86d.jpg","comment_is_top":false,"comment_ctime":1548815496,"is_pvip":false,"replies":[{"id":"22842","content":"我看到这样的答复真的是很开心，表示你这两篇都get了👍","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548818537,"ip_address":"","comment_id":64527,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23023651976","product_id":100020801,"comment_content":"我们在上文说到，使用 Block Nested-Loop Join 算法，可能会因为 join_buffer 不够大，需要对被驱动表做多次全表扫描。<br>在这个情况下，由于被驱动表是冷表，被多次全表扫描，LRU算法虽然做了优化分为yong区和old区，但是join_buffer不够大，驱动表被分成多个block，被驱动表要查多次，会占用young区，导致bp命中率下降。","like_count":5,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438049,"discussion_content":"我看到这样的答复真的是很开心，表示你这两篇都get了👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548818537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1637789,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/4PvDe2mRia2vdMGyickA40y2libhpf8ibmIEQquLUZFMXUMqqDjfVb96Y69p7bS6USgxicOKCCHxQHczHBnNb5L9nfA/132","nickname":"Geek_eb2e49","note":"","ucode":"21671F0C4E7872","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":147874,"discussion_content":"老师，想请教下，join_buffer和buffer pool是什么关系？为什么 join_buffer 不够大会影响到LRU算法中的Yong区和OLD区？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579679049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64809,"user_name":"一大只😴","can_delete":false,"product_type":"c1","uid":1310960,"ip_address":"","ucode":"92F3D2B7F63568","user_header":"https://static001.geekbang.org/account/avatar/00/14/00/f0/08409e78.jpg","comment_is_top":false,"comment_ctime":1548916588,"is_pvip":false,"replies":[{"id":"22934","content":"是的，Index Nested-Loop Join没有用到join buffer<br><br>不过35篇马上会介绍到一个优化，把join buffer用上，晚上关注下哦😆","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548922604,"ip_address":"","comment_id":64809,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18728785772","product_id":100020801,"comment_content":"老师，我想问下，如果使用的是Index Nested-Loop Join，是不是就不会使用join_buffer了？直接将循环结果放到net_buffer_length中，边读边发哈？","like_count":4,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438189,"discussion_content":"是的，Index Nested-Loop Join没有用到join buffer\n\n不过35篇马上会介绍到一个优化，把join buffer用上，晚上关注下哦😆","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548922604,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64521,"user_name":"XD","can_delete":false,"product_type":"c1","uid":1079293,"ip_address":"","ucode":"DC9DCFB3841A4E","user_header":"https://static001.geekbang.org/account/avatar/00/10/77/fd/c6619535.jpg","comment_is_top":false,"comment_ctime":1548815002,"is_pvip":false,"replies":[{"id":"22843","content":"其实就是怕出事儿，需要精确的控制，如果是两个Index Nested-Loop join 其实还好啦<br><br>只是作成规范，用join次数限制，规范比较好执行😆","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548818600,"ip_address":"","comment_id":64521,"utype":1}],"discussion_count":3,"race_medal":0,"score":"18728684186","product_id":100020801,"comment_content":"老师，三个表关联的执行流程也是一样的吗？记得阿里的mysql规范里有一条不允许3个及以上表进行join操作，这个原因是？","like_count":4,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438045,"discussion_content":"其实就是怕出事儿，需要精确的控制，如果是两个Index Nested-Loop join 其实还好啦\n\n只是作成规范，用join次数限制，规范比较好执行😆","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548818600,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1363230,"avatar":"https://static001.geekbang.org/account/avatar/00/14/cd/1e/692c3313.jpg","nickname":"复兴","note":"","ucode":"C172A87873001A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376696,"discussion_content":"希望老师做出回答@林晓斌","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622280331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1363230,"avatar":"https://static001.geekbang.org/account/avatar/00/14/cd/1e/692c3313.jpg","nickname":"复兴","note":"","ucode":"C172A87873001A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376695,"discussion_content":"额  你非要问第二个问题，害得老师不回答第一个问题了，老师第一个问题是怎样的呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622280249,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64589,"user_name":"700","can_delete":false,"product_type":"c1","uid":1072896,"ip_address":"","ucode":"E4BD0CBADAF951","user_header":"","comment_is_top":false,"comment_ctime":1548830729,"is_pvip":false,"replies":[{"id":"22875","content":"1. 用 in，但是不建议语句太长<br>2. 看一下前面我们介绍索引的文章哈<br>3. 因为是在叶子索引上直接顺序扫描，是一个大致值哈<br>4. 不是呀，因为表t2是1000行哦","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548832370,"ip_address":"","comment_id":64589,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14433732617","product_id":100020801,"comment_content":"老师，您好。看完文章后有如下问题请教：<br>1）文章内容「可以看到，在这个查询过程，也是扫描了 200 行，但是总共执行了 101 条语句，比直接 join 多了 100 次交互。除此之外，客户端还要自己拼接 SQL 语句和结果。」<br>这个有没有啥方法来仅通过1次交互就将这101条语句发到服务端执行？<br><br>2）文章内容「每次搜索一棵树近似复杂度是以 2 为底的 M 的对数，记为 log2M，所以在被驱动表上查一行的时间复杂度是 2*log2M。」<br>这个复杂度的计算难理解，为什么是这么计算？<br>假设 M = 256，则搜索树的复杂度为8？<br><br>3）文章内容「因此整个执行过程，近似复杂度是 N + N*2*log2M。」<br>驱动表的复杂度直接记为 N？<br><br>4）文中提到索引扫描需扫1行数据，全表扫描需扫1000行数据。这是由统计信息决定的？<br><br>提前感谢老师！","like_count":3,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438087,"discussion_content":"1. 用 in，但是不建议语句太长\n2. 看一下前面我们介绍索引的文章哈\n3. 因为是在叶子索引上直接顺序扫描，是一个大致值哈\n4. 不是呀，因为表t2是1000行哦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548832370,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64536,"user_name":"undifined","can_delete":false,"product_type":"c1","uid":1068920,"ip_address":"","ucode":"449CB4CD2DC089","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/78/c3d8ecb0.jpg","comment_is_top":false,"comment_ctime":1548816482,"is_pvip":false,"replies":[{"id":"22849","content":"1. 没有，但是如果业务真的需要，还是建议写“select 所有字段”<br>2. 下一篇会说哈，“现在的办法是给用到的没有索引的列加索引” 这个方法是可以的<br>","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548818970,"ip_address":"","comment_id":64536,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14433718370","product_id":100020801,"comment_content":"老师有几个问题：<br>1. select * 和 select 所有字段会有性能差异吗<br>2. 我们的业务有很多查询需要 join 很多个表，附带有动态的查询条件，几百万数据的表，查起来很慢，分多次查询聚合又要费很大功夫，现在的办法是给用到的没有索引的列加索引，像这种 SQL 该怎么优化呢<br><br>思考题：<br>因为要扫描大量的的数据，会长时间使用 Buffer Pool Old 区域，导致其他的查询可能会变慢；如果要返回的数据很多的话，还要长时间使用 net_buffer，这样理解对吗<br><br>辛苦老师解答一下，谢谢老师","like_count":3,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438056,"discussion_content":"1. 没有，但是如果业务真的需要，还是建议写“select 所有字段”\n2. 下一篇会说哈，“现在的办法是给用到的没有索引的列加索引” 这个方法是可以的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548818970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103753,"user_name":"天使梦泪","can_delete":false,"product_type":"c1","uid":1235750,"ip_address":"","ucode":"782991747DD424","user_header":"https://static001.geekbang.org/account/avatar/00/12/db/26/3c8d68fb.jpg","comment_is_top":false,"comment_ctime":1560503213,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"10150437805","product_id":100020801,"comment_content":"老师好，对于大数据量的多表使用join连接查询，有好多and条件，and是来自不同的表，查询80万的数据量需要0.4s，怎么优化下呢？<br>Using union(PRIMARY,idx_secoo_order_id); Using where; Using filesort<br><br>我的sql语句最后都使用order by id了，但是为啥Extra还会出现Using filesort","like_count":2,"discussions":[{"author":{"id":1986739,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/50/b3/9269cd59.jpg","nickname":"LWD","note":"","ucode":"DDA444DB113C01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573094,"discussion_content":"说明走索引的时候无法直接满足排序呗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653204194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2086624,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/d6/e0/3ccaaa7b.jpg","nickname":"领子","note":"","ucode":"64AC4E6AB74E68","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295155,"discussion_content":"如果你的排序字段，不是外表的字段，就会出现Using filesort","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596104391,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135593,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/e9/f244988e.jpg","nickname":"NIRVANA","note":"","ucode":"F3A979679AA44E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291133,"discussion_content":"这没法回答，啥都没有","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594714241,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":69393,"user_name":"Sinyo","can_delete":false,"product_type":"c1","uid":1307297,"ip_address":"","ucode":"57B243E7AB86A5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJAibnPX9jW8kqLcIfibjic8GbkQkEUYyFKJkc39hZhibVlNrqwTjdLozkqibI2IwACd5YzofYickNxFnZg/132","comment_is_top":false,"comment_ctime":1550733525,"is_pvip":false,"replies":[{"id":"24989","content":"1. 是内存操作<br>2. 实际上是一次扫描被驱动表，但是对于每一行，在判断的时候，都把sort buffer扫了一遍","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1550996756,"ip_address":"","comment_id":69393,"utype":1}],"discussion_count":4,"race_medal":0,"score":"10140668117","product_id":100020801,"comment_content":"老师，关于扫描行数概念我有点不太理解；<br>BNL算法的被驱动表并没有放到join_buffer中，此时被驱动表(物理表)和驱动表(内存中的数据)关联应该是算内存操作把？那内存中驱动表的一条记录关联一遍被驱动表中所有数据都只算作一次扫描行数吗？<br><br>原文：<br>“两个表都做一次全表扫描，所以总的扫描行数是 M+N；内存中的判断次数是 M*N。”","like_count":2,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440095,"discussion_content":"1. 是内存操作\n2. 实际上是一次扫描被驱动表，但是对于每一行，在判断的时候，都把sort buffer扫了一遍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550996756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1250907,"avatar":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","nickname":"Monday","note":"","ucode":"77B9BACC783598","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4691,"discussion_content":"这也是我的问题。看了老师的回复，终于明白了。在BNL中，被驱动表更像是外层循环。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565663366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1135593,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/e9/f244988e.jpg","nickname":"NIRVANA","note":"","ucode":"F3A979679AA44E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1250907,"avatar":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","nickname":"Monday","note":"","ucode":"77B9BACC783598","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291134,"discussion_content":"这儿是join buffer还是sort buffer啊?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594715293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4691,"ip_address":""},"score":291134,"extra":""},{"author":{"id":1261360,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3f/30/23f6b413.jpg","nickname":"五十九秒","note":"","ucode":"1F34F62193CFF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1135593,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/e9/f244988e.jpg","nickname":"NIRVANA","note":"","ucode":"F3A979679AA44E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308873,"discussion_content":"join_buffer","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601106427,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":291134,"ip_address":""},"score":308873,"extra":""}]}]},{"had_liked":false,"id":69319,"user_name":"几近虚年","can_delete":false,"product_type":"c1","uid":1355831,"ip_address":"","ucode":"28CD6486EED8E2","user_header":"https://static001.geekbang.org/account/avatar/00/14/b0/37/d654fbac.jpg","comment_is_top":false,"comment_ctime":1550717268,"is_pvip":false,"replies":[{"id":"24642","content":"👍<br>边学边练","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1550728379,"ip_address":"","comment_id":69319,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10140651860","product_id":100020801,"comment_content":"    看了老师的课程，现在看到34讲，前面的锁、索引等基础常用的东西，因为我是Java开发嘛，有普通的SQL操作经验，所以看了以后很有收获。 但是到了分库分表、读写分离的课程，看着就很吃力了，之前没有做过类似的东西。<br>    但是总的来说，收获超级大，这是我进极客时间买的第一个课程，也是现在最有价值的课程，真的非常感谢老师的辛苦码字和把技术表达。<br>    看完这个课程，然后继续看老师推荐的书籍《高性能MySQL》。等跳槽后，把现在所学的基础类型的知识都应用一遍，然后分库那些再看有环境的话实践实践，最后再回过头，反复看老师中间段课程的知识点，到时候相信收获肯定也很大。<br>    感谢老师。","like_count":2,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440057,"discussion_content":"👍\n边学边练","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550728379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64768,"user_name":"inrtyx","can_delete":false,"product_type":"c1","uid":1246178,"ip_address":"","ucode":"81CD18FF34ABAB","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/e2/5768d26e.jpg","comment_is_top":false,"comment_ctime":1548903368,"is_pvip":true,"replies":[{"id":"22936","content":"要看你怎么加密的<br>如果是在客户端加密，就是写入数据之前加密是可以的；<br>还有MySQL 5.7就支持表空间加密，这种也是可以的；<br><br>但是如果是写入之前调用md5(), 然后查询的时候用md5(filed)=&#39;XXXX&#39;，这样就用不上索引了","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548922995,"ip_address":"","comment_id":64768,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10138837960","product_id":100020801,"comment_content":"老师，问个问题！mysql有没有办法支持加密数据可搜索","like_count":2,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438167,"discussion_content":"要看你怎么加密的\n如果是在客户端加密，就是写入数据之前加密是可以的；\n还有MySQL 5.7就支持表空间加密，这种也是可以的；\n\n但是如果是写入之前调用md5(), 然后查询的时候用md5(filed)=&amp;#39;XXXX&amp;#39;，这样就用不上索引了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548922995,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64686,"user_name":"封建的风","can_delete":false,"product_type":"c1","uid":1302600,"ip_address":"","ucode":"811C24F093AF0F","user_header":"https://static001.geekbang.org/account/avatar/00/13/e0/48/3d72e81c.jpg","comment_is_top":false,"comment_ctime":1548858713,"is_pvip":false,"replies":[{"id":"22894","content":"嗯嗯，我们这次45讲😆<br><br>这些内容确实没在这个专栏的范围内<br>crash后调试，基本上就是看errorlog，如果有配置生成core文件，就用gdb这样。。","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548869690,"ip_address":"","comment_id":64686,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10138793305","product_id":100020801,"comment_content":"老师，看大纲课程似乎快接近尾声了，不知老师能否分享一下怎么进行进行mysql的源码分析，以及mysql在crash后怎么调试的内容哦","like_count":2,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438133,"discussion_content":"嗯嗯，我们这次45讲😆\n\n这些内容确实没在这个专栏的范围内\ncrash后调试，基本上就是看errorlog，如果有配置生成core文件，就用gdb这样。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548869690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64581,"user_name":"夹心面包","can_delete":false,"product_type":"c1","uid":1301957,"ip_address":"","ucode":"002BBA49D83D17","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJCscgdVibmoPyRLRaicvk6rjTJxePZ6VFHvGjUQvtfhCS6kO4OZ1AVibbhNGKlWZmpEFf2yA6ptsqHw/132","comment_is_top":false,"comment_ctime":1548828813,"is_pvip":false,"replies":[{"id":"22872","content":"是的 👍","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548829652,"ip_address":"","comment_id":64581,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10138763405","product_id":100020801,"comment_content":"对于多表join优化,我最先explain关注的就是BNL优化,一旦出现,就会提示研发进行连接字段的索引添加,这是最先可以被优化的,也是提高效率的","like_count":2,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438084,"discussion_content":"是的 👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548829652,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64572,"user_name":"没时间了ngu","can_delete":false,"product_type":"c1","uid":1311334,"ip_address":"","ucode":"9629BB85E8BB5D","user_header":"https://static001.geekbang.org/account/avatar/00/14/02/66/4ab9225e.jpg","comment_is_top":false,"comment_ctime":1548826804,"is_pvip":false,"replies":[{"id":"22870","content":"主要是参数的设置，如果没有配合说原理，就有点浅。。。<br>这样，你把你不理解的参数列出来，我们来讨论下","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548828757,"ip_address":"","comment_id":64572,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10138761396","product_id":100020801,"comment_content":"老师，后面答疑可以讲一下 常用的参数优化，比如my.cnf 这里面的设置吗，您讲的这些理论挺深的，对小白来说，吸收还是要靠一些实践的。","like_count":2,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438080,"discussion_content":"主要是参数的设置，如果没有配合说原理，就有点浅。。。\n这样，你把你不理解的参数列出来，我们来讨论下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548828757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64493,"user_name":"锅子","can_delete":false,"product_type":"c1","uid":1323048,"ip_address":"","ucode":"4A9143AFB07FF2","user_header":"https://static001.geekbang.org/account/avatar/00/14/30/28/6e019a7a.jpg","comment_is_top":false,"comment_ctime":1548811902,"is_pvip":false,"replies":[{"id":"22838","content":"多谢你的鼓励<br><br>需要先休息一段哈 ^_^<br>不过评论区一直开放哦~","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548816612,"ip_address":"","comment_id":64493,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10138746494","product_id":100020801,"comment_content":"以前对join总是很模糊，听完老师这节课感觉清晰了好多，这个专栏真得很值。<br>老师，这个专栏结束了，后续还会有其他专栏吗？","like_count":2,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438028,"discussion_content":"多谢你的鼓励\n\n需要先休息一段哈 ^_^\n不过评论区一直开放哦~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548816612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64492,"user_name":"D白菜","can_delete":false,"product_type":"c1","uid":1304391,"ip_address":"","ucode":"8DC343172AB781","user_header":"https://static001.geekbang.org/account/avatar/00/13/e7/47/d0715205.jpg","comment_is_top":false,"comment_ctime":1548811896,"is_pvip":false,"replies":[{"id":"22837","content":"“小的结果集” 这个说得很好<br>文章里面我们有一段，也是专门描述了这个逻辑","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548816462,"ip_address":"","comment_id":64492,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10138746488","product_id":100020801,"comment_content":"驱动表的选择，Oracle有个比较严谨的说法，叫做小的结果集作为driver table(外部表).学到这里发现nested loop的原理oracle和MySQL有些近似的地方。","like_count":2,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438027,"discussion_content":"“小的结果集” 这个说得很好\n文章里面我们有一段，也是专门描述了这个逻辑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548816462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64484,"user_name":"liao xueqiang","can_delete":false,"product_type":"c1","uid":1310325,"ip_address":"","ucode":"68713441579F6B","user_header":"https://static001.geekbang.org/account/avatar/00/13/fe/75/46742f12.jpg","comment_is_top":false,"comment_ctime":1548810994,"is_pvip":false,"replies":[{"id":"22836","content":"对，优化器不就是做这个的<br>当然优化器有时候会犯错误，所以还是explain看看保险哈","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548816429,"ip_address":"","comment_id":64484,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10138745586","product_id":100020801,"comment_content":"也就是说自己不用担心语句怎么写的，join的时候不管小表在前还是大表在前，mysql优化器会自动选择小表作为驱动表，是这样理解吗","like_count":2,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438022,"discussion_content":"对，优化器不就是做这个的\n当然优化器有时候会犯错误，所以还是explain看看保险哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548816429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64475,"user_name":"liao xueqiang","can_delete":false,"product_type":"c1","uid":1310325,"ip_address":"","ucode":"68713441579F6B","user_header":"https://static001.geekbang.org/account/avatar/00/13/fe/75/46742f12.jpg","comment_is_top":false,"comment_ctime":1548809185,"is_pvip":false,"replies":[{"id":"22825","content":"是的呀，就是我们文中说的，选“小表”<br><br><br>驱动表的选择，用explain可以看的","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548810167,"ip_address":"","comment_id":64475,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10138743777","product_id":100020801,"comment_content":"最后一个例子，关于驱动表的选择，怎么知道是选了t1表还是t2表?会不会像oracle一样，优化器自动选择结果集少的行源作为驱动表？","like_count":2,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438017,"discussion_content":"是的呀，就是我们文中说的，选“小表”\n\n\n驱动表的选择，用explain可以看的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548810167,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157199,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1575079953,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5870047249","product_id":100020801,"comment_content":"原以为驱动表（M条）读入内存，再每次取一条扫描被驱动表（N条），这样扫描行数是M+M*N。<br>仔细一看mysql机智了。读入驱动表，然后扫描从被驱动表，每次取一条和驱动表做匹配。厉害了","like_count":1},{"had_liked":false,"id":154589,"user_name":"长期规划","can_delete":false,"product_type":"c1","uid":1019332,"ip_address":"","ucode":"5EF65E9115834B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","comment_is_top":false,"comment_ctime":1574487401,"is_pvip":false,"replies":[{"id":"59457","content":"会，这个就是优化器的工作","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1574588648,"ip_address":"","comment_id":154589,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5869454697","product_id":100020801,"comment_content":"老师，MySQL自己会决定选哪个表当驱动表吗？","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475516,"discussion_content":"会，这个就是优化器的工作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574588648,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103265,"user_name":"连边","can_delete":false,"product_type":"c1","uid":1391748,"ip_address":"","ucode":"54B5DA38449728","user_header":"https://static001.geekbang.org/account/avatar/00/15/3c/84/608f679b.jpg","comment_is_top":false,"comment_ctime":1560406341,"is_pvip":false,"replies":[{"id":"37376","content":"开心😆🤝","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1560422069,"ip_address":"","comment_id":103265,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5855373637","product_id":100020801,"comment_content":"现在很多时候，都不用jion查询，但是也说不个所以然来，今天补习了这篇文章，能从理论出发了，开心。","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453813,"discussion_content":"开心😆🤝","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560422069,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79063,"user_name":"阿邱","can_delete":false,"product_type":"c1","uid":1281762,"ip_address":"","ucode":"A3D1A90E01D83D","user_header":"https://static001.geekbang.org/account/avatar/00/13/8e/e2/1e70c61d.jpg","comment_is_top":false,"comment_ctime":1553336219,"is_pvip":false,"replies":[{"id":"28795","content":"咱们俩对“知识点”的理解不太一样😆<br><br>各表参数代表的意义是哪里都能找到的。。<br><br>可能是你基础比较好吧，我是看了源码后才搞清楚BNL的执行流程，之前并猜不到","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1553339612,"ip_address":"","comment_id":79063,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5848303515","product_id":100020801,"comment_content":"难道不是重点讲explain下各表参数代表的意义吗？或说为什么显示这样的参数？你说的那个表连接过程不怎么学过mysql的人都能猜到，有意义吗？","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444343,"discussion_content":"咱们俩对“知识点”的理解不太一样😆\n\n各表参数代表的意义是哪里都能找到的。。\n\n可能是你基础比较好吧，我是看了源码后才搞清楚BNL的执行流程，之前并猜不到","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1553339612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1170925,"avatar":"https://static001.geekbang.org/account/avatar/00/11/dd/ed/e6eed95e.jpg","nickname":"Flying","note":"","ucode":"CA3DCE897F2013","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387419,"discussion_content":"原来你分析怎么连表都是猜的呀，那还有必要明白explain吗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1628158060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1043325,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/c9xpiakQ3OC1AlfCeW03lLnnb7mj5v35Hib8YDs66zpnVib2n2qFichFmFp2Ec4QDPR0dKh38MkBBLyD3bE4NiaanZQ/132","nickname":"龙晓","note":"","ucode":"FAF34F1C65D103","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358863,"discussion_content":"支持林老师","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1616066653,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72648,"user_name":"小徐","can_delete":false,"product_type":"c1","uid":1303757,"ip_address":"","ucode":"522B5CD3732313","user_header":"https://static001.geekbang.org/account/avatar/00/13/e4/cd/fc140973.jpg","comment_is_top":false,"comment_ctime":1551685332,"is_pvip":false,"replies":[{"id":"28004","content":"&quot;还是说也可以理解为从驱动表一条一条取出数据与从被驱动表取出的记录对比&quot;<br><br>我觉得不能，因为这样并不是实际情况，而且如果这么实现，性能会很慢哦<br>","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1552723787,"ip_address":"","comment_id":72648,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5846652628","product_id":100020801,"comment_content":"老师好:<br>   对于NLJ的驱动表与被动表能够理解，从驱动表取出数据去访问被驱动表，<br>  但是BNL方式的 驱动表与被动表能够不理解，驱动表放入join buffer,然后从被驱动表拿出记录去访问驱动表，这个是不是<br>驱动表与被驱动表存在歧义,还是说也可以理解为从驱动表一条一条取出数据与从被驱动表取出的记录对比？<br>","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441672,"discussion_content":"&amp;quot;还是说也可以理解为从驱动表一条一条取出数据与从被驱动表取出的记录对比&amp;quot;\n\n我觉得不能，因为这样并不是实际情况，而且如果这么实现，性能会很慢哦\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552723787,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":69536,"user_name":"小志","can_delete":false,"product_type":"c1","uid":1037841,"ip_address":"","ucode":"11C9EAB9746D8B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d6/11/808eb5f8.jpg","comment_is_top":false,"comment_ctime":1550761539,"is_pvip":false,"replies":[{"id":"24693","content":"my.cnf 里，或者 set join_buffer_size=M","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1550798548,"ip_address":"","comment_id":69536,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5845728835","product_id":100020801,"comment_content":"老师您好，join_buffer_size这个值在哪里设置？","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440160,"discussion_content":"my.cnf 里，或者 set join_buffer_size=M","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550798548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":68567,"user_name":"思考特～","can_delete":false,"product_type":"c1","uid":1301824,"ip_address":"","ucode":"B9B4E64962BAD2","user_header":"https://static001.geekbang.org/account/avatar/00/13/dd/40/a185dfcb.jpg","comment_is_top":false,"comment_ctime":1550545265,"is_pvip":false,"replies":[{"id":"24321","content":"没有存，就是按顺序读一行，然后跟join buffer中对比以后这个内存就复用了，又读下一行","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1550551344,"ip_address":"","comment_id":68567,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5845512561","product_id":100020801,"comment_content":"老师，下面的sql<br>select * from t1 straight_join t2 on (t1.a=t2.b);<br>使用BNL进行连接，t1表的记录存放到join buffer中去，t2表是要做全表扫描的，它是将所有记录取出来，这个记录应该也很大，那么存放到什么地方？","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439734,"discussion_content":"没有存，就是按顺序读一行，然后跟join buffer中对比以后这个内存就复用了，又读下一行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550551344,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1652836,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epKJlW7sqts2ZbPuhMbseTAdvHWnrc4ficAeSZyKibkvn6qyxflPrkKKU3mH6XCNmYvDg11tB6y0pxg/132","nickname":"pc","note":"","ucode":"1AD538B9A900B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":138728,"discussion_content":"不是很懂，那对于无序的字段，是不能按照顺序去判断的啊？）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579262786,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":65042,"user_name":"库淘淘","can_delete":false,"product_type":"c1","uid":1310240,"ip_address":"","ucode":"90813B0C46E978","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqibSwKPg7hiapc49qoM4dibhM3fYANPjfltF2ibBZ3dHX2hibjg5EIIcziahrmjO5R2XrcRibvU39TQS7jg/132","comment_is_top":false,"comment_ctime":1549010295,"is_pvip":false,"replies":[{"id":"23189","content":"“2.已t2 作为驱动表，一方面考虑其他两表都有关联,t2表放入join buffer后关联t1后，再关联t2 得出结果 再各回t2,t3表取出 得到结果集”<br><br>即使是用t1做驱动表，也是可能可以都用上BKA的哈<br><br>新春快乐~","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1549270849,"ip_address":"","comment_id":65042,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5843977591","product_id":100020801,"comment_content":"set optimizer_switch=&#39;mrr=on,mrr_cost_based=off,batched_key_access=on&#39;;<br>create index idx_c on t2(c);<br>create index idx_a_c on t1(a,c);<br>create index idx_b_c on t3(b,c);<br>mysql&gt; explain select * from t2 <br>    -&gt; straight_join t1 on(t1.a=t2.a)<br>    -&gt; straight_join t3 on(t2.b=t3.b)   <br>    -&gt; where t1.c&gt; 800 and t2.c&gt;=600 and t3.c&gt;=500;<br>+----+-------------+-------+------------+-------+---------------+---------+---------+-----------+------+----------+---------------------------------------------------------------+<br>| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |<br>+----+-------------+-------+------------+-------+---------------+---------+---------+-----------+------+----------+---------------------------------------------------------------+<br>| 1 | SIMPLE | t2 | NULL | range | idx_c | idx_c | 5 | NULL | 401 | 100.00 | Using index condition; Using where; Using MRR |<br>| 1 | SIMPLE | t1 | NULL | ref | idx_a_c | idx_a_c | 5 | test.t2.a | 1 | 33.33 | Using index condition; Using join buffer (Batched Key Access) |<br>| 1 | SIMPLE | t3 | NULL | ref | idx_b_c | idx_b_c | 5 | test.t2.b | 1 | 33.33 | Using index condition; Using join buffer (Batched Key Access) |<br>+----+-------------+-------+------------+-------+---------------+---------+---------+-----------+------+----------+---------------------------------------------------------------+<br>3 rows in set, 1 warning (0.00 sec)<br>以自己理解考虑如下，有问题请老师能够指出<br>1.根据查询因是select * 肯定回表的，其中在表t2创建索引idx_c,为了能够使用ICP,MRR，如果c字段重复率高或取值行数多，可以考虑不建索引<br>2.已t2 作为驱动表，一方面考虑其他两表都有关联,t2表放入join buffer后关联t1后，再关联t2 得出结果 再各回t2,t3表取出 得到结果集（之前理解都是t1和t2join得结果集再与t3join，本次理解太确定）<br>3.t2、t3表建立联合查询目的能够使用ICP","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438292,"discussion_content":"“2.已t2 作为驱动表，一方面考虑其他两表都有关联,t2表放入join buffer后关联t1后，再关联t2 得出结果 再各回t2,t3表取出 得到结果集”\n\n即使是用t1做驱动表，也是可能可以都用上BKA的哈\n\n新春快乐~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549270849,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64927,"user_name":"郭健","can_delete":false,"product_type":"c1","uid":1102204,"ip_address":"","ucode":"169645EBF3B46C","user_header":"https://static001.geekbang.org/account/avatar/00/10/d1/7c/4639f22c.jpg","comment_is_top":false,"comment_ctime":1548980191,"is_pvip":false,"replies":[{"id":"23010","content":"👍","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548987126,"ip_address":"","comment_id":64927,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5843947487","product_id":100020801,"comment_content":"老师，太棒了！！终于讲join了！！！作为一个实际开发人员，索引了解是必须得，单表索引有所掌握，始终对join没法理解，这节课对我的帮助是最大的。谢谢老师","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438238,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548987126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64902,"user_name":"辣椒","can_delete":false,"product_type":"c1","uid":1330376,"ip_address":"","ucode":"85C62DE976C6A5","user_header":"https://static001.geekbang.org/account/avatar/00/14/4c/c8/bed1e08a.jpg","comment_is_top":false,"comment_ctime":1548947387,"is_pvip":false,"replies":[{"id":"23005","content":"👍，如果有有趣的经验也放到这里跟大家分享哦","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548980521,"ip_address":"","comment_id":64902,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5843914683","product_id":100020801,"comment_content":"我是开发，但是看了老师的专栏，对怎么写数据库应用更有心得了","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438228,"discussion_content":"👍，如果有有趣的经验也放到这里跟大家分享哦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548980521,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64813,"user_name":"马若飞","can_delete":false,"product_type":"c1","uid":1046394,"ip_address":"","ucode":"3D0327329A10AE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/7a/55618020.jpg","comment_is_top":false,"comment_ctime":1548917293,"is_pvip":false,"replies":[{"id":"22933","content":"是的，只是获取数据的时候，不会去读整行。<br><br>但是没有索引就也只能用BNL，可以explain看看","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548922555,"ip_address":"","comment_id":64813,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5843884589","product_id":100020801,"comment_content":"我们某个业务使用infobright这种列式存储，字段没用索引。我在想这种引擎在join的时候是否也会遵守类似的规则？但列式存储并不是按行扫描，所以有点困惑。","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438192,"discussion_content":"是的，只是获取数据的时候，不会去读整行。\n\n但是没有索引就也只能用BNL，可以explain看看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548922555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64731,"user_name":"埋葬","can_delete":false,"product_type":"c1","uid":1306646,"ip_address":"","ucode":"72BA350F06DAD0","user_header":"https://static001.geekbang.org/account/avatar/00/13/f0/16/3689aa6d.jpg","comment_is_top":false,"comment_ctime":1548894076,"is_pvip":false,"replies":[{"id":"22949","content":"这45篇里面没有安排专门篇幅介绍的了<br>如果有问题提一下，后面还有一期答疑文章可以看看把问题展开说明哈","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548936980,"ip_address":"","comment_id":64731,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5843861372","product_id":100020801,"comment_content":"老师，想问下，后面的课程中会不会介绍到分库分表的知识？很期待。","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438151,"discussion_content":"这45篇里面没有安排专门篇幅介绍的了\n如果有问题提一下，后面还有一期答疑文章可以看看把问题展开说明哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548936980,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64645,"user_name":"☞","can_delete":false,"product_type":"c1","uid":1302793,"ip_address":"","ucode":"6FAEF05F234D2A","user_header":"https://static001.geekbang.org/account/avatar/00/13/e1/09/9483f537.jpg","comment_is_top":false,"comment_ctime":1548840790,"is_pvip":false,"replies":[{"id":"22890","content":"对的","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548864036,"ip_address":"","comment_id":64645,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5843808086","product_id":100020801,"comment_content":"老师您好：<br>        您最后那个例子如果关联列是有索引的呢？就是使用Index Nested-Loop Join时，如何对比相对来说哪个是大表，哪个是小表，是对比两个表通过where条件筛选后的行数，哪个行数多哪个就是大表了？","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438117,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548864036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64553,"user_name":"库淘淘","can_delete":false,"product_type":"c1","uid":1310240,"ip_address":"","ucode":"90813B0C46E978","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqibSwKPg7hiapc49qoM4dibhM3fYANPjfltF2ibBZ3dHX2hibjg5EIIcziahrmjO5R2XrcRibvU39TQS7jg/132","comment_is_top":false,"comment_ctime":1548819558,"is_pvip":false,"replies":[{"id":"23193","content":"cardinality只是一个输入之一哈<br><br>嗯嗯，MySQL的优化器还不是很完善<br><br>新春快乐~","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1549277001,"ip_address":"","comment_id":64553,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5843786854","product_id":100020801,"comment_content":"join 关于mysql本身自动优化问题，测试两个表都为2万行一样数据，进行join<br>select t1.*,t2.b from t1 join t2 on(t1.b=t2.b); 设置join_buffer_size 不同值并不能保证执行计划安照t2为驱动表<br>alter table t1 MODIFY id varchar(1000);<br>这样会直接导致统计信息中cardinality 信息估算变动大于20000，这样mysql驱动表选为t2 为最优，<br>当两个表cardinality 都一样时 会选用join 在前的表作为驱动表，<br>得到结果 mysql本身不会通过去判断join_buffer_size 大小来判断小表，需要自己去判断优化。之前理解还以为mysql能有所判断看来想多了","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438066,"discussion_content":"cardinality只是一个输入之一哈\n\n嗯嗯，MySQL的优化器还不是很完善\n\n新春快乐~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549277001,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64532,"user_name":"Ryoma","can_delete":false,"product_type":"c1","uid":1130590,"ip_address":"","ucode":"7F692369239692","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/5e/b8fada94.jpg","comment_is_top":false,"comment_ctime":1548816124,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"5843783420","product_id":100020801,"comment_content":"前提：冷数据表 &amp; 大表<br><br>buffer pool 中的old区会被持续刷新，并且基本没有升级到young区的可能性。<br>一定程度上会降低hit rate","like_count":1},{"had_liked":false,"id":64524,"user_name":"Dovelol","can_delete":false,"product_type":"c1","uid":1253384,"ip_address":"","ucode":"9B5DDF7720F307","user_header":"https://static001.geekbang.org/account/avatar/00/13/20/08/bc06bc69.jpg","comment_is_top":false,"comment_ctime":1548815342,"is_pvip":false,"replies":[{"id":"22841","content":"我们文中说的，Block Nested-Loop Join就尽量不要用；<br><br>下一篇文章还是关于join优化的，保持关注哈","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548818460,"ip_address":"","comment_id":64524,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5843782638","product_id":100020801,"comment_content":"老师，想问一下，无论哪种查询，先从小表中查到固定记录，然后根据这些数据循环用多线程去join表中查询，这种利用多线程循环嵌套查询的方法和mysql直接join一条语句查询在上面几种sql情况下对比如何呢？什么时候用多线程循环查询效率会更高呢？","like_count":1,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438047,"discussion_content":"我们文中说的，Block Nested-Loop Join就尽量不要用；\n\n下一篇文章还是关于join优化的，保持关注哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548818460,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351155,"user_name":"Fan","can_delete":false,"product_type":"c1","uid":1115232,"ip_address":"","ucode":"3BF28670FD9407","user_header":"https://static001.geekbang.org/account/avatar/00/11/04/60/64d166b6.jpg","comment_is_top":false,"comment_ctime":1657558016,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657558016","product_id":100020801,"comment_content":"Left join on where条件 多对多情况的执行流程是怎样的呢？","like_count":1},{"had_liked":false,"id":350223,"user_name":"东泽","can_delete":false,"product_type":"c1","uid":2770660,"ip_address":"","ucode":"7B621B43909E07","user_header":"https://static001.geekbang.org/account/avatar/00/2a/46/e4/0860c82f.jpg","comment_is_top":false,"comment_ctime":1656670165,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1656670165","product_id":100020801,"comment_content":"老师，如果join的被驱动表是一个子查询，这种情况怎么分析。","like_count":0},{"had_liked":false,"id":348109,"user_name":"powerful","can_delete":false,"product_type":"c1","uid":3003648,"ip_address":"","ucode":"621D21D2FC5D21","user_header":"https://static001.geekbang.org/account/avatar/00/2d/d5/00/5f328909.jpg","comment_is_top":false,"comment_ctime":1654747601,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1654747601","product_id":100020801,"comment_content":"您好老师，我想请教一个问题，我在网上了解到MySQL8.0.20版本以后就废除了Block Nested-Loop Join算法，所有被驱动表不能使用索引的join都使用HASH Join算法。<br>并且我还了解到HASH Join也是依赖join_buffer的也是将驱动表的数据加载到join_buffer如果，join_buffer不能一次性存储所有的驱动表中的数据进行分批加载，然后被驱动表进行多次join。<br>不知道我以上的理解是否正确。<br>我疑惑的点在于HASH Join 比 Block Nested-Loop Join优秀在哪些地方。<br>希望老师能抽时间指点一下。","like_count":0},{"had_liked":false,"id":348015,"user_name":"prader26","can_delete":false,"product_type":"c1","uid":1433707,"ip_address":"","ucode":"5EFFFC374ADECE","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/6b/f61d7466.jpg","comment_is_top":false,"comment_ctime":1654667834,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654667834","product_id":100020801,"comment_content":"join尽量使用小表做驱动表。","like_count":0},{"had_liked":false,"id":346113,"user_name":"LIU","can_delete":false,"product_type":"c1","uid":1324845,"ip_address":"","ucode":"CB8BAB022F5B9F","user_header":"","comment_is_top":false,"comment_ctime":1652844505,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652844505","product_id":100020801,"comment_content":"有收获","like_count":0},{"had_liked":false,"id":344704,"user_name":"亚林","can_delete":false,"product_type":"c1","uid":1018972,"ip_address":"","ucode":"4A5A6D24314B79","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/5c/3f164f66.jpg","comment_is_top":false,"comment_ctime":1651731741,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651731741","product_id":100020801,"comment_content":"explain select * from t1 straight_join t2 on (t1.a=t2.b);<br>语句在MySQL8中变成了hash join","like_count":0},{"had_liked":false,"id":342198,"user_name":"将心比心","can_delete":false,"product_type":"c1","uid":2867136,"ip_address":"","ucode":"B58A65CBD875CD","user_header":"","comment_is_top":false,"comment_ctime":1650098536,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650098536","product_id":100020801,"comment_content":"老师，我将join_buffer_size 改小以后explain出来的结果被驱动表扫描的行数没有变多呢？<br>难道去被驱动表找的时候不是进行的全表扫描吗？","like_count":0},{"had_liked":false,"id":341477,"user_name":"Geek_82640c","can_delete":false,"product_type":"c1","uid":1933794,"ip_address":"","ucode":"A69C2D502A27D0","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJjiaBHJyfAKK3lAdX62MveJHoPb4V6zE6jhPa3cjdBv7owc53aBHbNf3pibOsbciccSwichwiaR4m5nAQ/132","comment_is_top":false,"comment_ctime":1649652001,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649652001","product_id":100020801,"comment_content":"老师您好，如果不用join改为用in查询，是否就不会多100次交互，而只是多了一次查询交互","like_count":0},{"had_liked":false,"id":341189,"user_name":"ub8","can_delete":false,"product_type":"c1","uid":1481811,"ip_address":"","ucode":"0D937C3EAEB781","user_header":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","comment_is_top":false,"comment_ctime":1649410311,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649410311","product_id":100020801,"comment_content":"总结下： 数据库操作查询中为什么不能用join操作 <br>情况1 ： a表b表的 join 链接条件都有索引，在索引内存中进行比较操作，用小表查询大表的索引所在的行做关联，生成结果数据。<br>情况2：a表b表的join 连接条件中存在没有索引的字段， 需要在内存中拷贝驱动表（a&#47;b）然后通过 内存中的表 与另一张表进行扫表搜索操作。<br>两种情况都会将压力释放到数据库中，在业务系统中是一定要杜绝join操作的。","like_count":0},{"had_liked":false,"id":335805,"user_name":"Geek_73f003","can_delete":false,"product_type":"c1","uid":2291422,"ip_address":"","ucode":"60EFB4F211B777","user_header":"","comment_is_top":false,"comment_ctime":1645695399,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645695399","product_id":100020801,"comment_content":"老师，对于相对小的表这里我有疑问<br>select * from t1 straight_join t2 on (t1.b=t2.b) where t2.id&lt;=50;<br>之前了解过on和where的区别：<br>- on 条件是在生成临时表时使用的条件；<br>- where 条件是在临时表生成好后，再对临时表进行过滤的条件；<br>所以我自己的理解就是where的条件限制不会影响join过程中的行数吧，因为执行where的时候，join已经完成了吧，老师怎么看吖？","like_count":0},{"had_liked":false,"id":334773,"user_name":"数学汤家凤","can_delete":false,"product_type":"c1","uid":2029485,"ip_address":"","ucode":"DE84E777C384AD","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f7/ad/4fd4d867.jpg","comment_is_top":false,"comment_ctime":1645108178,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1645108178","product_id":100020801,"comment_content":"设 A 驱动表，B 被驱动表<br>则有：<br>1. A 走全表扫描，此时是 N 级复杂度<br>2. B 有索引时，走索引，此时是 logN 级复杂度<br>3. B 无索引时，走全表扫描。<br>4. join buff 够，A 全部进入内存<br>5.  join buff 不够，则 A 分批读入内存。<br>由 1、2 可得，A 比 B 小时收益更明显。<br>因为表小，所以分批从磁盘进内存的 IO 次数少，开销更低，所以可由 4、5 得 A 越小越好。<br>综上，选小表作为驱动表会更优。","like_count":0},{"had_liked":false,"id":333576,"user_name":"小妖","can_delete":false,"product_type":"c1","uid":1730626,"ip_address":"","ucode":"49C01DBFADF101","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJvm1JYIDcS74s4cEYxA1PXMqjortVXEjUKyGQcPvibNJ4EAuksIa6uoHgr6G1yRqAM2KtP3yicKgTA/132","comment_is_top":false,"comment_ctime":1644410043,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644410043","product_id":100020801,"comment_content":"老师，我们的mysql使用规范是要求不允许在程序调用中使用join等多表查询语句的，我能想到原因如下：<br>1.防止某个sql长时间占用数据库连接；<br>2.数据库连接池对于高频率查询建立连接的成本大大降低；<br>3.防止使用不规范导致的长时间锁占用","like_count":0},{"had_liked":false,"id":330335,"user_name":"Geek_a0b00e","can_delete":false,"product_type":"c1","uid":2849772,"ip_address":"","ucode":"6509CABE634F40","user_header":"","comment_is_top":false,"comment_ctime":1641916173,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641916173","product_id":100020801,"comment_content":"老师，扫描行数的概念是指的把每行数据读入内存的次数吗","like_count":0},{"had_liked":false,"id":327472,"user_name":"小强","can_delete":false,"product_type":"c1","uid":1115935,"ip_address":"","ucode":"FA0F0EFBCF0E87","user_header":"https://static001.geekbang.org/account/avatar/00/11/07/1f/a8ba292c.jpg","comment_is_top":false,"comment_ctime":1640142358,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640142358","product_id":100020801,"comment_content":"为什么我使用explain select * from t1 straight_join t2 on (t1.a=t2.a); 之后看到的结果t2表的rows是500 而文稿中是1","like_count":0},{"had_liked":false,"id":324041,"user_name":"SoLonG","can_delete":false,"product_type":"c1","uid":2084247,"ip_address":"","ucode":"337021FABE4D3B","user_header":"","comment_is_top":false,"comment_ctime":1638269463,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638269463","product_id":100020801,"comment_content":"老师好，类似这种多个查询结果间做join查询，这些中间查询结果，都是在join_buffer上的吗？这种情况能怎么优化呢？<br>select from a  left join (select b.id from b ) as table1 <br>on a.id=table1.id <br>left join <br>(select c.id from c) as table2 on a.id=table2.id<br><br>","like_count":0},{"had_liked":false,"id":322279,"user_name":"逗你玩😄","can_delete":false,"product_type":"c1","uid":1030242,"ip_address":"","ucode":"2E6309586B0363","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b8/62/60937bbd.jpg","comment_is_top":false,"comment_ctime":1637287579,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637287579","product_id":100020801,"comment_content":"感谢老师的这篇文章，差点迈不过这个坎。改了join_buffer的值，查询之前竟然超过了500s","like_count":0},{"had_liked":false,"id":321295,"user_name":"张大局","can_delete":false,"product_type":"c1","uid":2760501,"ip_address":"","ucode":"9F83EB9606EAEB","user_header":"https://static001.geekbang.org/account/avatar/00/2a/1f/35/569e02f8.jpg","comment_is_top":false,"comment_ctime":1636766492,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"1636766492","product_id":100020801,"comment_content":"文章内容：join_buffer_size 越大，一次可以放入的行越多，分成的段数也就越少，对被驱动表的全表扫描次数就越少。<br>请问：为什么“对被驱动表的全表扫描次数就越少”。","like_count":0,"discussions":[{"author":{"id":3007210,"avatar":"","nickname":"Geek_a1699c","note":"","ucode":"CF7DB00BE36B77","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577345,"discussion_content":"join_buffer只存放了驱动表的数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656042657,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3007210,"avatar":"","nickname":"Geek_a1699c","note":"","ucode":"CF7DB00BE36B77","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577344,"discussion_content":"因为它会将驱动表的每一段去和被驱动表的所有数据进行对比，驱动表的段数越少，自然被驱动表的全表扫描次数就越少了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656042631,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320596,"user_name":"克里斯","can_delete":false,"product_type":"c1","uid":1181844,"ip_address":"","ucode":"00B755C10AC1C3","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/94/2c22bd4e.jpg","comment_is_top":false,"comment_ctime":1636417900,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1636417900","product_id":100020801,"comment_content":"join 语句的优势核心是计算向数据移动.<br>使用join的优势增加了本客户端的吞吐量,每次连接的传输数据变多了,<br>但是对mysql服务器来说,可不是优势,当我们说优化时,一般指的优化mysql服务器<br>而不是客户端,因此join的确应该避免","like_count":0},{"had_liked":false,"id":320368,"user_name":"陈斌","can_delete":false,"product_type":"c1","uid":1367048,"ip_address":"","ucode":"B639AB5F6AA03D","user_header":"https://static001.geekbang.org/account/avatar/00/14/dc/08/64f5ab52.jpg","comment_is_top":false,"comment_ctime":1636278852,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1636278852","product_id":100020801,"comment_content":"通过 Left Join ON 联合多个表 与 where 的方式直接联合多个表有什么区别吗，如果联合的表太多了，什么方法优化它吗？<br><br>下面两个语句，Mysql执行起来有什么差别吗，会不会存在那个性能更好的情况？<br>select * from t1 left join t2 on t1.id=t2.id left join t3 on t2.id=t3.id;<br>select * from t1,t2,t3 where t1.id=t2.id and t2.id=t3.id","like_count":0},{"had_liked":false,"id":320364,"user_name":"陈斌","can_delete":false,"product_type":"c1","uid":1367048,"ip_address":"","ucode":"B639AB5F6AA03D","user_header":"https://static001.geekbang.org/account/avatar/00/14/dc/08/64f5ab52.jpg","comment_is_top":false,"comment_ctime":1636277768,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1636277768","product_id":100020801,"comment_content":"EXPLAIN SELECT<br>\tD.team_id &#39;团队账号&#39;,<br>\tA.product_id &#39;项目ID&#39;,<br>\tA.data_view_id &#39;app_id&#39;,<br>\tF.NAME &#39;应用名称&#39;,<br>\tE.`value` &#39;应用包名&#39;,<br>\tG.product_param_value &#39;是否开启数据共享开关&#39; <br>FROM<br>\tr_openness_product_dataview_spec A,<br>\tt_product_queue B,<br>\tt_resource_properties_spec C,<br>\tt_product_protocol D,<br>\tt_dataview_param_spec E,<br>\tt_dataview_spec F,<br>\tt_openness_product_param_spec G <br>WHERE\t<br>    A.product_id = B.product_id <br>\tAND B.property_id = C.resource_id <br>\tAND C.resource_name = D.team_id <br>\tAND D.controller_protocol_flag = &#39;true&#39; <br>\tAND D.team_id NOT IN ( &#39;70086000336323333&#39;, &#39;70086000329262562&#39;, &#39;2850086000375935591&#39; ) <br>\tAND E.dataview_id = A.data_view_id <br>\tAND E.param_key = &#39;packageName&#39; <br>\tAND E.dataview_id = F.id <br>\tAND A.product_id = G.product_id <br>\tAND G.product_param_key = &#39;dataControlFlag&#39;;<br><br>我这个语句怎么优化，现网执行超过1分钟。<br><br>1\tSIMPLE\tD\t\tALL\t\t\t\t\t179\t7.00\tUsing where<br>1\tSIMPLE\tC\t\tALL\t\t\t\t\t211\t10.00\tUsing where; Using join buffer (Block Nested Loop)<br>1\tSIMPLE\tA\t\tALL\tuk_dataviewid_status\t\t\t\t5254\t100.00\tUsing where; Using join buffer (Block Nested Loop)<br>1\tSIMPLE\tB\t\teq_ref\tuk_productid\tuk_productid\t768\tmacaw_openness.A.product_id\t1\t10.00\tUsing index condition; Using where<br>1\tSIMPLE\tE\t\tref\tidx_appid\tidx_appid\t768\tmacaw_openness.A.data_view_id\t6\t10.00\tUsing where<br>1\tSIMPLE\tF\t\teq_ref\tPRIMARY\tPRIMARY\t767\tmacaw_openness.A.data_view_id\t1\t100.00\t<br>1\tSIMPLE\tG\t\tref\tuk_productid,ind_productid\tind_productid\t768\tmacaw_openness.A.product_id\t11\t10.00\tUsing where","like_count":0},{"had_liked":false,"id":312138,"user_name":"Carter","can_delete":false,"product_type":"c1","uid":1030842,"ip_address":"","ucode":"1FD476D8F2BE27","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/ba/83de3488.jpg","comment_is_top":false,"comment_ctime":1631638424,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631638424","product_id":100020801,"comment_content":"我觉得，BNL中，放入join_buffer的数据，可以用hashtable优化，时间复杂度可以降低到O(m+n)。","like_count":0},{"had_liked":false,"id":309560,"user_name":"zhaozhenghao","can_delete":false,"product_type":"c1","uid":2147986,"ip_address":"","ucode":"C5BE62E1564C2A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoCiaPAJnEO3PYLSR6nw5jCSic0tjSfL73OtJh7zOqmL2QewkIeERL6cyYtynQDB8l6ueGBlibH2WYvA/132","comment_is_top":false,"comment_ctime":1630231512,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630231512","product_id":100020801,"comment_content":"老师您好，想问下join语句里面有 on 和 where，where条件是什么时刻执行的","like_count":0},{"had_liked":false,"id":309286,"user_name":"松","can_delete":false,"product_type":"c1","uid":1938214,"ip_address":"","ucode":"327DF555AB9E7B","user_header":"https://static001.geekbang.org/account/avatar/00/1d/93/26/df549718.jpg","comment_is_top":false,"comment_ctime":1630031952,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630031952","product_id":100020801,"comment_content":"还有我们不能用join 语句的时候是对从表 用IN  语句 。再在业务从进行拼接。这样查询的次数就只有两次。","like_count":0},{"had_liked":false,"id":309283,"user_name":"松","can_delete":false,"product_type":"c1","uid":1938214,"ip_address":"","ucode":"327DF555AB9E7B","user_header":"https://static001.geekbang.org/account/avatar/00/1d/93/26/df549718.jpg","comment_is_top":false,"comment_ctime":1630031588,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630031588","product_id":100020801,"comment_content":"我的理解是查询出来符合条件少的表做主表。即使表2 行数比较多10万行，符合条件的 比较少是100 行。表1 行数比较少1w行，符合条件的比较多1000 行。 这样N和M 的大小就互换了。","like_count":0},{"had_liked":false,"id":308923,"user_name":"Leo","can_delete":false,"product_type":"c1","uid":2649276,"ip_address":"","ucode":"CEBAD9CDCFC2A3","user_header":"https://static001.geekbang.org/account/avatar/00/28/6c/bc/f751786b.jpg","comment_is_top":false,"comment_ctime":1629862657,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629862657","product_id":100020801,"comment_content":"看到评论中：left join &#47; right join 不一定会固定驱动表，但更倾向于语义的逻辑来确定驱动表，这点我记下来了；<br><br>问题： BNL算法中，一定是驱动表入join buffer吗？ 有没有可能是被驱动表进join buffer呢？","like_count":0},{"had_liked":false,"id":306990,"user_name":"曾祥金","can_delete":false,"product_type":"c1","uid":2362279,"ip_address":"","ucode":"CBBB7FC1EA00D6","user_header":"","comment_is_top":false,"comment_ctime":1628819398,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628819398","product_id":100020801,"comment_content":"连接查询on条件和where后面的条件执行顺序是怎样的？是先用on后面的条件连接表，然后再用where过滤结果吗？碰到过一个面试题：select * from a inner join b on a.id = b.id 和 select * from a,b where a.id = b.id 有什么区别，哪个更优？","like_count":0},{"had_liked":false,"id":305194,"user_name":"尘","can_delete":false,"product_type":"c1","uid":1244251,"ip_address":"","ucode":"2C71FBCED5BFE6","user_header":"https://static001.geekbang.org/account/avatar/00/12/fc/5b/caa6a2a6.jpg","comment_is_top":false,"comment_ctime":1627873430,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1627873430","product_id":100020801,"comment_content":"老师，join的时候，如果有where条件，是先join，然后再根据where条件从join结果中筛选出数据，还是两个表各自根据where条件先筛选出数据再join的？","like_count":0},{"had_liked":false,"id":301378,"user_name":"青雘","can_delete":false,"product_type":"c1","uid":2687278,"ip_address":"","ucode":"29D71967CA90F0","user_header":"https://static001.geekbang.org/account/avatar/00/29/01/2e/5d3d4b86.jpg","comment_is_top":false,"comment_ctime":1625651453,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625651453","product_id":100020801,"comment_content":"课程真是太硬核了 目前确定自己真的只会一些简单的增删改查","like_count":0},{"had_liked":false,"id":299232,"user_name":"spuryin","can_delete":false,"product_type":"c1","uid":1221753,"ip_address":"","ucode":"17474DCB7D293D","user_header":"https://static001.geekbang.org/account/avatar/00/12/a4/79/35ab3a19.jpg","comment_is_top":false,"comment_ctime":1624520925,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624520925","product_id":100020801,"comment_content":"select * from t1 straight_join t2 on (t1.a=t2.b); 这里直接扫描t2的数据去t1查询不行吗，为什么还需要把t1的数据写入join_buffer?<br><br>如果是select * from t1 straight_join t2 on (t1.b=t2.a),好像就不需要join_buffer了？<br><br>本质上还是先确定驱动表，如果被驱动表走索引就是INL,如果没有索引就是NJL,不管驱动表走不走索引?","like_count":0},{"had_liked":false,"id":291933,"user_name":"阿甘","can_delete":false,"product_type":"c1","uid":1057843,"ip_address":"","ucode":"BC93175B70E05D","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/33/bcf37f50.jpg","comment_is_top":false,"comment_ctime":1620614991,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1620614991","product_id":100020801,"comment_content":"光是这篇文章就值这个课程价格了","like_count":0},{"had_liked":false,"id":288352,"user_name":"二姐","can_delete":false,"product_type":"c1","uid":2290089,"ip_address":"","ucode":"3451748DE3895F","user_header":"","comment_is_top":false,"comment_ctime":1618418119,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618418119","product_id":100020801,"comment_content":"这个系列文章写的真的好","like_count":0},{"had_liked":false,"id":287811,"user_name":"magicpill充实自己","can_delete":false,"product_type":"c1","uid":2095397,"ip_address":"","ucode":"F768CE6C41A3E4","user_header":"https://static001.geekbang.org/account/avatar/00/1f/f9/25/0db8975f.jpg","comment_is_top":false,"comment_ctime":1618155804,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1618155804","product_id":100020801,"comment_content":"时刻充实自己","like_count":0},{"had_liked":false,"id":287035,"user_name":"平凡之路","can_delete":false,"product_type":"c1","uid":1669273,"ip_address":"","ucode":"96CE12339BD5FD","user_header":"https://static001.geekbang.org/account/avatar/00/19/78/99/6060eb2d.jpg","comment_is_top":false,"comment_ctime":1617754189,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617754189","product_id":100020801,"comment_content":"老师，您好，您讲的非常好，能讲下多表join的逻辑吗？期待。","like_count":0},{"had_liked":false,"id":285917,"user_name":"孤傲的虎王","can_delete":false,"product_type":"c1","uid":2536451,"ip_address":"","ucode":"FE9B90D6EEBAFB","user_header":"https://static001.geekbang.org/account/avatar/00/26/b4/03/677fd301.jpg","comment_is_top":false,"comment_ctime":1617073978,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617073978","product_id":100020801,"comment_content":"老师您好，我现在实习期间接受的代码总是有四五个join连用的情况，请问这种情况有什么优化的思路吗？","like_count":0},{"had_liked":false,"id":285503,"user_name":"廖湘浩","can_delete":false,"product_type":"c1","uid":2398705,"ip_address":"","ucode":"F418D8195E08A3","user_header":"https://static001.geekbang.org/account/avatar/00/24/99/f1/1fcea152.jpg","comment_is_top":false,"comment_ctime":1616848506,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616848506","product_id":100020801,"comment_content":"Block Nested-Loop Join 为什么不考虑hash 的方式join呢，甚至这样的开关都没有提供，如果用hash，负载度能从n * m优化到n + m","like_count":0},{"had_liked":false,"id":284975,"user_name":"三丫","can_delete":false,"product_type":"c1","uid":2326623,"ip_address":"","ucode":"41DF6B80EDF634","user_header":"https://static001.geekbang.org/account/avatar/00/23/80/5f/a1767d6c.jpg","comment_is_top":false,"comment_ctime":1616567235,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616567235","product_id":100020801,"comment_content":"mysql&gt; explain select * from t1 STRAIGHT_JOIN t2 on t1.a = t2.b;<br>+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+<br>| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                      |<br>+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+<br>|  1 | SIMPLE      | t1    | NULL       | ALL  | a             | NULL | NULL    | NULL |  100 |   100.00 | NULL                                       |<br>|  1 | SIMPLE      | t2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 1000 |    10.00 | Using where; Using join buffer (hash join) |<br>+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+<br>2 rows in set (0.00 sec)<br><br>为什么扫描t2表的时候，没有用到Block Nested-Loop Join，而是hash join的方式呢？","like_count":0},{"had_liked":false,"id":283484,"user_name":"平凡之路","can_delete":false,"product_type":"c1","uid":1669273,"ip_address":"","ucode":"96CE12339BD5FD","user_header":"https://static001.geekbang.org/account/avatar/00/19/78/99/6060eb2d.jpg","comment_is_top":false,"comment_ctime":1615796494,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615796494","product_id":100020801,"comment_content":"老师，您好，如果驱动表上没索引，是什么流程呢","like_count":0},{"had_liked":false,"id":283453,"user_name":"桀","can_delete":false,"product_type":"c1","uid":1204584,"ip_address":"","ucode":"939C1EEFCFC08E","user_header":"https://static001.geekbang.org/account/avatar/00/12/61/68/e5f0ba39.jpg","comment_is_top":false,"comment_ctime":1615789025,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615789025","product_id":100020801,"comment_content":"老师，文章提到的都是基于单个字段条件的join，那如果基于多个字段join，该怎么分析呢？","like_count":0},{"had_liked":false,"id":282702,"user_name":"超级蛋蛋饭","can_delete":false,"product_type":"c1","uid":1249616,"ip_address":"","ucode":"AD2BECE789B365","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/wiaQmkQdIh84RibSLrDkIA3HtibAR4IibpnP3VEmiaLzvpiaibXJQEb2LLUrCD4dM7DjvOFD65IbdZm2Mn68O71FxiaAow/132","comment_is_top":false,"comment_ctime":1615368797,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615368797","product_id":100020801,"comment_content":"老师，不能使用被驱动表的索引的情况下，怎么查能提高性能呢","like_count":0},{"had_liked":false,"id":276681,"user_name":"silent","can_delete":false,"product_type":"c1","uid":1162450,"ip_address":"","ucode":"575366953E6F30","user_header":"https://static001.geekbang.org/account/avatar/00/11/bc/d2/2e73a3cb.jpg","comment_is_top":false,"comment_ctime":1612076066,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612076066","product_id":100020801,"comment_content":"你好  总的比对次数不变我能理解  但为什么被驱动表是会被扫描k次呢，这k次被驱动表都是一样的数据入join buffer吗  为什么不只入一次呢  望解答🤔","like_count":0},{"had_liked":false,"id":275975,"user_name":"枫中浪子","can_delete":false,"product_type":"c1","uid":2351949,"ip_address":"","ucode":"860BEA32059B37","user_header":"https://static001.geekbang.org/account/avatar/00/23/e3/4d/8a26dbb2.jpg","comment_is_top":false,"comment_ctime":1611734420,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611734420","product_id":100020801,"comment_content":"Block Nested-Loop Join 算法 不能使用join，那业务层写循环然后拼接会比join性能好吗？如果不好，该怎么解决？","like_count":0},{"had_liked":false,"id":270039,"user_name":"meow","can_delete":false,"product_type":"c1","uid":1246785,"ip_address":"","ucode":"BB7FBD681B5EFC","user_header":"https://static001.geekbang.org/account/avatar/00/13/06/41/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1608884986,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608884986","product_id":100020801,"comment_content":"我有个问题：https:&#47;&#47;static001.geekbang.org&#47;resource&#47;image&#47;4b&#47;90&#47;4b9cb0e0b83618e01c9bfde44a0ea990.png<br>从表 t1 中读入一行数据 R；<br>从数据行 R 中，取出 a 字段到表 t2 里去查找；<br>取出表 t2 中满足条件的行，跟 R 组成一行，作为结果集的一部分；<br>重复执行步骤 1 到 3，直到表 t1 的末尾循环结束。<br><br>网上说表的执行顺序是 按照id 从大到小，但是你这里先执行表1，我有点懵<br>","like_count":0},{"had_liked":false,"id":267964,"user_name":"不懂","can_delete":false,"product_type":"c1","uid":1541612,"ip_address":"","ucode":"CA512A7EC3A27F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epQoq244hPvZBpvAd1q6uFQgVgVtgoJe90CaoNkrhjicJtibpBQCfujvgGEJ17nrC2sNNYqtqaKwBuA/132","comment_is_top":false,"comment_ctime":1608011513,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608011513","product_id":100020801,"comment_content":"MySQL 8.0版本对第二种情况有优化。<br>mysql&gt; explain select * from t1 straight_join t2 on (t1.a = t2.b);<br>+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+<br>| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                      |<br>+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+<br>|  1 | SIMPLE      | t1    | NULL       | ALL  | a             | NULL | NULL    | NULL |  100 |   100.00 | NULL                                       |<br>|  1 | SIMPLE      | t2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 1000 |    10.00 | Using where; Using join buffer (hash join) |<br>+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+<br>","like_count":0},{"had_liked":false,"id":262993,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1756181,"ip_address":"","ucode":"B2765DD1D90B0C","user_header":"https://static001.geekbang.org/account/avatar/00/1a/cc/15/35622b02.jpg","comment_is_top":false,"comment_ctime":1605936220,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605936220","product_id":100020801,"comment_content":"在 join on 和 where 同时存在的情况下，是先执行 join on 的条件还是先执行 where 的条件？ join on 后边跟的也可能是 id&gt;1000 这样的过滤条件，而不仅仅是关联关系条件。","like_count":0},{"had_liked":false,"id":262432,"user_name":"贺子","can_delete":false,"product_type":"c1","uid":2076283,"ip_address":"","ucode":"A64DC9D9CF7CCD","user_header":"https://static001.geekbang.org/account/avatar/00/1f/ae/7b/47200692.jpg","comment_is_top":false,"comment_ctime":1605718497,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605718497","product_id":100020801,"comment_content":"请问老师，如果被驱动表有索引，那么在新版本数据中已经把bnl优化成了先对驱动表在join buffer中排序的策略了吧，也就是bka，","like_count":0},{"had_liked":false,"id":261131,"user_name":"密码123456","can_delete":false,"product_type":"c1","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1605225916,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605225916","product_id":100020801,"comment_content":"有个问题，我们这边经常性的会有一张大表数据表，作为主要结果输出的。小表是对应把大表的编码转化为中文。可是我感觉这种情况下，大表作为驱动表会好一点。","like_count":0},{"had_liked":false,"id":258293,"user_name":"陈刚","can_delete":false,"product_type":"c1","uid":1548798,"ip_address":"","ucode":"080E69D3687E73","user_header":"https://static001.geekbang.org/account/avatar/00/17/a1/fe/250e64d7.jpg","comment_is_top":false,"comment_ctime":1604372958,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604372958","product_id":100020801,"comment_content":"而对于每一行 R，根据 a 字段去表 t2 查找，走的是树搜索过程。由于我们构造的数据都是一一对应的，因此每次的搜索过程都只扫描一行，也是总共扫描 100 行；  <br>老师 这里应该对T2表的扫描不应该是100行啊。因为a字段是普通非唯一索引，那么每次查找都会往右多扫描一次吧。","like_count":0},{"had_liked":false,"id":257664,"user_name":"陈金龙","can_delete":false,"product_type":"c1","uid":1571152,"ip_address":"","ucode":"684F1C733A6C27","user_header":"https://static001.geekbang.org/account/avatar/00/17/f9/50/d0ea075b.jpg","comment_is_top":false,"comment_ctime":1604050750,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604050750","product_id":100020801,"comment_content":"老师，扫描和交互应该怎么理解？一个SQL就是一次交互，如果没有缓存的情况下，是不是肯定会去读一次硬盘？一次扫描，可以理解成由CPU在内存中对数据做一次逻辑运算吗？","like_count":0},{"had_liked":false,"id":255215,"user_name":"蜉蝣","can_delete":false,"product_type":"c1","uid":1229070,"ip_address":"","ucode":"77CF92496855D4","user_header":"https://static001.geekbang.org/account/avatar/00/12/c1/0e/2b987d54.jpg","comment_is_top":false,"comment_ctime":1603283750,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603283750","product_id":100020801,"comment_content":"老师好！如何理解 BNL 小节中 “两个表都做一次全表扫描，所以总的扫描行数是 M+N；”？因为 t1 取出数据到了 join_buffer，这是一次全表扫描 。然后从 t2 读数据与 t1 匹配，我的理解是首先 t1 中的第一条和 t2 中的每一条都比一下，然后是 t1 中的第二条和 t2 中的每一条都比一下…… 这个时候 t2 应该是扫描了 N 次？","like_count":0},{"had_liked":false,"id":248552,"user_name":"梦朝思夕","can_delete":false,"product_type":"c1","uid":1067533,"ip_address":"","ucode":"F35EEBA74A739D","user_header":"https://static001.geekbang.org/account/avatar/00/10/4a/0d/da36e9ce.jpg","comment_is_top":false,"comment_ctime":1600220639,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1600220639","product_id":100020801,"comment_content":"单表查询时候使用in还会有n多次查询吗","like_count":0},{"had_liked":false,"id":246007,"user_name":"Rainbow","can_delete":false,"product_type":"c1","uid":1106658,"ip_address":"","ucode":"B680613F07E368","user_header":"https://static001.geekbang.org/account/avatar/00/10/e2/e2/9efdb522.jpg","comment_is_top":false,"comment_ctime":1599130928,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599130928","product_id":100020801,"comment_content":"我是B端订单组的，看了这篇，突然想起了之前的一个慢SQL，订单表400w行，订单明细明细表3000w行，就是用订单明细表当了驱动表，换成订单主表果然快了很多，还有个问题想咨询一下，订单明细表现在4千万行，有些join查询还是很慢，一般到达什么量级开始做归档啊，不过公司现在准备用es方案来查询","like_count":0},{"had_liked":false,"id":245153,"user_name":"xiaozeng","can_delete":false,"product_type":"c1","uid":1806081,"ip_address":"","ucode":"C517E55357315C","user_header":"https://static001.geekbang.org/account/avatar/00/1b/8f/01/2fbc5cc9.jpg","comment_is_top":false,"comment_ctime":1598846743,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598846743","product_id":100020801,"comment_content":"学完这节有收获，特别是join 原理分析还有如何判断是否是小表这里，而且例子举的都挺典型的。谢谢老师！","like_count":0},{"had_liked":false,"id":239996,"user_name":"🍋🥬🐟","can_delete":false,"product_type":"c1","uid":1484273,"ip_address":"","ucode":"4191D6E6CB6D3B","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/f1/8e3ce0e4.jpg","comment_is_top":false,"comment_ctime":1596708137,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596708137","product_id":100020801,"comment_content":"这个过程是先遍历表 t1，然后根据从表 t1 中取出的每行数据中的 a 值，去表 t2 中查找满足条件的记录<br><br>老师您好，我对 NLJ 的过程有些疑惑，t1表一次只查询一行，所以查询 100 行要访问 100 次磁盘吗，还是其他方式。会不会把所有数据，比如一个磁盘页都加载到内存中了，然后去一行一行比较的。<br><br>如果不放内存的话，数据应该放在哪呢？<br><br>既然 BNL 是把驱动表中数据放入缓存区中，那么 INLJ 不使用缓存区呢，我理解的放入缓存区再加上索引查应该更快了。<br><br>对这块有点钻进牛角尖了，希望老师能解答一下，非常感谢。","like_count":0},{"had_liked":false,"id":237251,"user_name":"jian","can_delete":false,"product_type":"c1","uid":1185102,"ip_address":"","ucode":"21CDBBB8000F0C","user_header":"https://static001.geekbang.org/account/avatar/00/12/15/4e/4636a81d.jpg","comment_is_top":false,"comment_ctime":1595755568,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595755568","product_id":100020801,"comment_content":"请问一下老师，“假设被驱动表的行数是 M。每次在被驱动表查一行数据，要先搜索索引 a，再搜索主键索引。每次搜索一棵树近似复杂度是以 2 为底的 M 的对数，记为 log2M，所以在被驱动表上查一行的时间复杂度是 2*log2M。假设驱动表的行数是 N，执行过程就要扫描驱动表 N 行，然后对于每一行，到被驱动表上匹配一次。因此整个执行过程，近似复杂度是 N + N*2*log2M。”，为什么这里的复杂度是N + N*2*log2M，而不是N + N*log2M？ ","like_count":0},{"had_liked":false,"id":235074,"user_name":"Yayu","can_delete":false,"product_type":"c1","uid":1058015,"ip_address":"","ucode":"5E7842458D8229","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/df/645f8087.jpg","comment_is_top":false,"comment_ctime":1594884992,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594884992","product_id":100020801,"comment_content":"驱动表 t1 (1000条) 与 被驱动表 t2 (100条) <br>执行 explain select * from t1 straight_join t2 on (t1.a = t2.b) &#47;&#47; t1.a 为索引，t2.b 不是索引<br>为什么我这里用的 并不是 block nested-loop join 而是 hash join ?<br>何时使用 block nested-loop join 何时使用 hash join 呢？","like_count":0},{"had_liked":false,"id":232552,"user_name":"Damo","can_delete":false,"product_type":"c1","uid":1599197,"ip_address":"","ucode":"F332EA67F5A40C","user_header":"https://static001.geekbang.org/account/avatar/00/18/66/dd/c9f17139.jpg","comment_is_top":false,"comment_ctime":1594035479,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1594035479","product_id":100020801,"comment_content":"老师为什么我用你的例子使用 “ straight_join” 得到的是 BNL, 我的 mysql 版本是 5.7.30。<br><br>mysql&gt; explain select * from t1 straight_join t2 on (t1.a=t2.a);<br>+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+<br>| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                              |<br>+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+<br>|  1 | SIMPLE      | t1    | NULL       | ALL  | a             | NULL | NULL    | NULL |  100 |   100.00 | NULL                                               |<br>|  1 | SIMPLE      | t2    | NULL       | ALL  | a             | NULL | NULL    | NULL |    1 |   100.00 | Using where; Using join buffer (Block Nested Loop) |<br>+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+<br>2 rows in set, 1 warning (0.00 sec)<br><br>请问这个是为什么？","like_count":0,"discussions":[{"author":{"id":1599197,"avatar":"https://static001.geekbang.org/account/avatar/00/18/66/dd/c9f17139.jpg","nickname":"Damo","note":"","ucode":"F332EA67F5A40C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289247,"discussion_content":"我使用 “alter table A engine=InnoDB” 命令，重建表t1，t2 ，居然好了。😂\n就这么点数据 mysql 也会选错了索引嘛","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594039409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":231757,"user_name":"WolvesLeader","can_delete":false,"product_type":"c1","uid":1103839,"ip_address":"","ucode":"33610E19CA2E96","user_header":"https://static001.geekbang.org/account/avatar/00/10/d7/df/fc0a6709.jpg","comment_is_top":false,"comment_ctime":1593765290,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593765290","product_id":100020801,"comment_content":"老师 on 和 where 哪个先执行，如果on先执行<br>这个大表和小表的判断还相同吗？<br>select t1.b,t2.* from  t1  straight_join t2 on (t1.b=t2.b) where t2.id&lt;=100;<br>select t1.b,t2.* from  t2  straight_join t1 on (t1.b=t2.b) where t2.id&lt;=100;","like_count":0},{"had_liked":false,"id":230026,"user_name":"hhhh","can_delete":false,"product_type":"c1","uid":1256101,"ip_address":"","ucode":"9E87017424B382","user_header":"https://static001.geekbang.org/account/avatar/00/13/2a/a5/625c0a2e.jpg","comment_is_top":false,"comment_ctime":1593244072,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1593244072","product_id":100020801,"comment_content":"8.0.20以后，hash join 算法替代了 block nested loop 算法, 参考https:&#47;&#47;mysqlserverteam.com&#47;hash-join-in-mysql-8&#47;，2019年12月才发布，估计目前实际用到的不多。","like_count":0,"discussions":[{"author":{"id":2086624,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/d6/e0/3ccaaa7b.jpg","nickname":"领子","note":"","ucode":"64AC4E6AB74E68","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295294,"discussion_content":"oracle 使用的就是hash连接","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596158463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":228663,"user_name":"9527","can_delete":false,"product_type":"c1","uid":2037018,"ip_address":"","ucode":"AE0D3C530E8DF9","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/VnUiaownBAJZv1x9nn21pxkY8b5DoYfLv2wPTq5uVOCiaEpIfNPpdAOZsdy7CbvvcaU3icxZnicROhrLyae45am11g/132","comment_is_top":false,"comment_ctime":1592785615,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1592785615","product_id":100020801,"comment_content":"我看到有的查询，过滤条件放到join on后面，跟放到where里面，有什么差别吗","like_count":0,"discussions":[{"author":{"id":1135593,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/e9/f244988e.jpg","nickname":"NIRVANA","note":"","ucode":"F3A979679AA44E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291136,"discussion_content":"如果是join的话其实是没有差别的，老师在答疑文章讲过，可能你也已经知道了，我是三刷的时候看到的，希望不要打扰到你","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594715758,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224328,"user_name":"程辉","can_delete":false,"product_type":"c1","uid":1395334,"ip_address":"","ucode":"A8AE3BFE6EE59C","user_header":"https://static001.geekbang.org/account/avatar/00/15/4a/86/c7bd910e.jpg","comment_is_top":false,"comment_ctime":1591345934,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591345934","product_id":100020801,"comment_content":"select t1.b,t2.* from  t1  straight_join t2 on (t1.b=t2.b) where t2.id&lt;=100;<br>这条语句的执行流程应该是先用on条件连表之后生成了临时表，然后再用where条件过滤吧？这样的话不管t1是不是只需要b字段它其实都是小表。","like_count":0},{"had_liked":false,"id":223200,"user_name":"broken_open","can_delete":false,"product_type":"c1","uid":1313347,"ip_address":"","ucode":"764CF5EEACC4AD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJjTz6oOKAXefgCNHTuTmwibBPJX9a4c407GHYmFPdMRgX67nZiavj2KhbiczicaaeSGxOxiaibnqH7icnVw/132","comment_is_top":false,"comment_ctime":1591019997,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591019997","product_id":100020801,"comment_content":"Join的时候，被驱动表上的join字段如果可以用到索引，是Index  Nested-Loop Join ，这种情况使用join没关系;如果用不到索引可能是Simple Nested-Loop Join ，也可能是Block Nested-Loop Join 【数据量很大的时候】，此时被驱动表全表扫描的次数可能会很多次，所以explain的时候如果是Block Nested-Loop Join，这种join尽量不要用，尤其是join大表,消耗系统资源会很高。 ","like_count":0},{"had_liked":false,"id":222059,"user_name":"明石","can_delete":false,"product_type":"c1","uid":1226978,"ip_address":"","ucode":"42ACCC9445CD33","user_header":"https://static001.geekbang.org/account/avatar/00/12/b8/e2/9bf25e0a.jpg","comment_is_top":false,"comment_ctime":1590666464,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590666464","product_id":100020801,"comment_content":"这样算来，这个 SQL 请求就要扫描表 t2 多达 100 次，总共扫描 100*1000=10 万行。<br>----------------------------------------------------------------<br>为啥是“100 * 1000”？1000 是哪来的？不是应该是“100 * 100 = 10000”吗？","like_count":0},{"had_liked":false,"id":220233,"user_name":"雪の雫·雨の音","can_delete":false,"product_type":"c1","uid":1997293,"ip_address":"","ucode":"0693DA3939A321","user_header":"https://static001.geekbang.org/account/avatar/00/1e/79/ed/4737a49b.jpg","comment_is_top":false,"comment_ctime":1590210185,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590210185","product_id":100020801,"comment_content":"老师您好！我有一个疑问<br>当被驱动表不能使用索引时，您在文中提到了采用BNL算法会导致被驱动表扫描很多次，不建议使用join<br>但是我的疑问是，如果采用的是单表查询的话，对于t1中的每一行，都要取出b字段和t2中的每一行比较：select * from t2 where b=$R.b，在这比较的过程，对于t1的每一行，t2也要进行全表扫描，这样总扫描行数就变成N+N*M了，我觉得这样单表查询效率不是应该更低吗？为什么说不建议使用join呢？","like_count":0},{"had_liked":false,"id":219206,"user_name":"湮汐","can_delete":false,"product_type":"c1","uid":1106268,"ip_address":"","ucode":"FB6185621891E5","user_header":"https://static001.geekbang.org/account/avatar/00/10/e1/5c/86606d9c.jpg","comment_is_top":false,"comment_ctime":1589966585,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1589966585","product_id":100020801,"comment_content":"其实关于不用Join查询，我们可以先查出第一张表的数据，获得全部的关联字段，第二张表用In查询，这样速度也会更快！","like_count":0},{"had_liked":false,"id":207360,"user_name":"Ryan","can_delete":false,"product_type":"c1","uid":1667987,"ip_address":"","ucode":"95BBBEE5B23878","user_header":"https://static001.geekbang.org/account/avatar/00/19/73/93/0a3a1e5b.jpg","comment_is_top":false,"comment_ctime":1587054628,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587054628","product_id":100020801,"comment_content":"以前dba只是告诉我们join查询的时候要用小表作为驱动表，今天终于知道为什么了","like_count":0},{"had_liked":false,"id":204306,"user_name":"Demter","can_delete":false,"product_type":"c1","uid":1158439,"ip_address":"","ucode":"BE3B6F726916CE","user_header":"https://static001.geekbang.org/account/avatar/00/11/ad/27/5556ae50.jpg","comment_is_top":false,"comment_ctime":1586361778,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586361778","product_id":100020801,"comment_content":"还是不太懂，对被驱动表全表扫描一次加载到内存中重复使用就可以了，为什么要每次都扫描呢？","like_count":0},{"had_liked":false,"id":198299,"user_name":"喻茂","can_delete":false,"product_type":"c1","uid":1318661,"ip_address":"","ucode":"C8BD8086A17365","user_header":"https://static001.geekbang.org/account/avatar/00/14/1f/05/8a06692e.jpg","comment_is_top":false,"comment_ctime":1585442832,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585442832","product_id":100020801,"comment_content":"多次查询被驱动表的相同数据会导致Buffer Pool的young区域被这次被驱动表的数据占用，后面查询更新的内存命中率降低","like_count":0},{"had_liked":false,"id":192942,"user_name":"复兴","can_delete":false,"product_type":"c1","uid":1363230,"ip_address":"","ucode":"C172A87873001A","user_header":"https://static001.geekbang.org/account/avatar/00/14/cd/1e/692c3313.jpg","comment_is_top":false,"comment_ctime":1584879390,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584879390","product_id":100020801,"comment_content":"在小表的判断那里有一个疑问：连接的时候就判断 where 嘛，不是连接之后获取结果集 然后根据where进行筛选嘛。。","like_count":0},{"had_liked":false,"id":186110,"user_name":"小予","can_delete":false,"product_type":"c1","uid":1442580,"ip_address":"","ucode":"3F5EAEE1746074","user_header":"https://static001.geekbang.org/account/avatar/00/16/03/14/e9ca2d09.jpg","comment_is_top":false,"comment_ctime":1583759113,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583759113","product_id":100020801,"comment_content":"回答问题<br>如果被驱动表是数据量很大的冷数据表，当使用BNL算法时，有可能连续多次扫描一个大冷数据表，可能会导致缓存全部失效，MySQL性能急剧下降。","like_count":0},{"had_liked":false,"id":186105,"user_name":"天亮前说晚安","can_delete":false,"product_type":"c1","uid":1541014,"ip_address":"","ucode":"1D82EE562A7C71","user_header":"https://static001.geekbang.org/account/avatar/00/17/83/96/73ff13a0.jpg","comment_is_top":false,"comment_ctime":1583758601,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583758601","product_id":100020801,"comment_content":"如果被驱动表数据很大，在内存中放不下的情况，怎么办？","like_count":0},{"had_liked":false,"id":180343,"user_name":"与狼共舞","can_delete":false,"product_type":"c1","uid":1391144,"ip_address":"","ucode":"02AC04B43F0194","user_header":"https://static001.geekbang.org/account/avatar/00/15/3a/28/cf707831.jpg","comment_is_top":false,"comment_ctime":1582262249,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582262249","product_id":100020801,"comment_content":"get到了","like_count":0},{"had_liked":false,"id":180205,"user_name":"陈大头","can_delete":false,"product_type":"c1","uid":1335400,"ip_address":"","ucode":"F1CA8837BF1E5C","user_header":"https://static001.geekbang.org/account/avatar/00/14/60/68/626cb455.jpg","comment_is_top":false,"comment_ctime":1582208962,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582208962","product_id":100020801,"comment_content":"请问老师，join和多表查询，在选择上的区别大吗？之前我同事说没什么区别，我个人是习惯用多表查询","like_count":0},{"had_liked":false,"id":180056,"user_name":"SuperSnow","can_delete":false,"product_type":"c1","uid":1065351,"ip_address":"","ucode":"84C89AA8083E6A","user_header":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","comment_is_top":false,"comment_ctime":1582175088,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582175088","product_id":100020801,"comment_content":"对于文章中，index nested_loop join算法中，在这个查询过程，也是扫描了 200 行，但是总共执行了 101 条语句，比直接 join 多了 100 次交互。除此之外，客户端还要自己拼接 SQL 语句和结果。<br>对于此类业务场景，其实可以将where条件构造成in的形式，这样也就是2条语句。不过麻烦就麻烦在需要客户端自己进行拼接结果。实际业务当中，保持拒绝join的态度，其实一方面为了以后分库分表场景的出现，这是一个层面的解耦；另外一个就是将数据库服务器的内存计算压力进行前移，将内存那部分计算提到应用服务器层面，以减轻数据库层面的压力。所以，拒绝join的做法，其实是让数据库回归到它的本原，就是用来简单的查询和处理数据的。当然，如果表的数量少的话怎么做怎么好，但高应用场景，还是要拿捏考虑全局设计。","like_count":0},{"had_liked":false,"id":176514,"user_name":"torres","can_delete":false,"product_type":"c1","uid":1108761,"ip_address":"","ucode":"34DABCFC7B74EA","user_header":"https://static001.geekbang.org/account/avatar/00/10/eb/19/76b0b98c.jpg","comment_is_top":false,"comment_ctime":1581078049,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1581078049","product_id":100020801,"comment_content":"老师，我有一个问题困扰很久。就是join和where的执行顺序。mysql在执行的时候，到底是先过滤再关联，还是先关联再过滤？ 我看您讲义中的描述，感觉应该是先做的过滤，然后关联的。","like_count":0,"discussions":[{"author":{"id":1077579,"avatar":"https://static001.geekbang.org/account/avatar/00/10/71/4b/2e1f2041.jpg","nickname":"happiren","note":"","ucode":"C8379873562C64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212980,"discussion_content":"可以看一下mysql官方的文档结合老师的课程理解，\n其实join对应于伪代码就是\nfor each row in t1 matching range {\n  for each row in t2 matching reference key {   \n      if row satisfies join conditions, send to client\n  }\n}\n所以，所以是可以理解为先执行驱动表t1的where满足的语句（但是如何确定哪个表是驱动表，其实是两个表的WHERE语句都会各自去评估来决定选择哪个表为小表驱动），然后内部的for循环t2表则会筛选同时满足ON和t2的WHERE语句的记录。\n官方文档地址：\nhttps://dev.mysql.com/doc/refman/5.7/en/nested-loop-joins.html#nested-loop-join-algorithm","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585039156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174384,"user_name":"Zhaoyang","can_delete":false,"product_type":"c1","uid":1037190,"ip_address":"","ucode":"131D83AC2566D2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d3/86/b5d72c87.jpg","comment_is_top":false,"comment_ctime":1580186447,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580186447","product_id":100020801,"comment_content":"尽量使用小表做驱动表，join的优势还是很明显的。","like_count":0},{"had_liked":false,"id":171081,"user_name":"复兴","can_delete":false,"product_type":"c1","uid":1363230,"ip_address":"","ucode":"C172A87873001A","user_header":"https://static001.geekbang.org/account/avatar/00/14/cd/1e/692c3313.jpg","comment_is_top":false,"comment_ctime":1578840886,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578840886","product_id":100020801,"comment_content":"select * from t2 straight_join t1 on (t1.b=t2.b) where t2.id&lt;=50;  到底是t2和t1连接之后 再判断 id &lt;=50 还是 先判断 id &lt;=50 再决定是否和 t1连接呢","like_count":0},{"had_liked":false,"id":169982,"user_name":"莫名","can_delete":false,"product_type":"c1","uid":1487905,"ip_address":"","ucode":"852C2321C45EE3","user_header":"https://static001.geekbang.org/account/avatar/00/16/b4/21/17a88779.jpg","comment_is_top":false,"comment_ctime":1578487391,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578487391","product_id":100020801,"comment_content":"select t1.b,t2.* from  t1  straight_join t2 on (t1.b=t2.b) where t2.id&lt;=100;<br>select t1.b,t2.* from  t2  straight_join t1 on (t1.b=t2.b) where t2.id&lt;=100;<br><br>老师，如果，没有t2.*，哪个表做驱动表好？如果是t2表驱动，放入缓冲里的数据是什么？谢谢","like_count":0},{"had_liked":false,"id":165831,"user_name":"赵威","can_delete":false,"product_type":"c1","uid":1299252,"ip_address":"","ucode":"6EB9425D9ED5B0","user_header":"https://static001.geekbang.org/account/avatar/00/13/d3/34/711b2fc1.jpg","comment_is_top":false,"comment_ctime":1577329089,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577329089","product_id":100020801,"comment_content":"大神，咨询个问题，多表left jiin,比如，a left join b left join c,  a,b  关联的时候可以取到a 表和b表的值，在left join c表的时候，b,c表取到的都是空了，比较奇怪，left join c 表不是不应该影响前序结果吗","like_count":0},{"had_liked":false,"id":162783,"user_name":"再见孙悟空","can_delete":false,"product_type":"c1","uid":1025518,"ip_address":"","ucode":"57E12A2F9CD915","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a5/ee/6bbac848.jpg","comment_is_top":false,"comment_ctime":1576588933,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576588933","product_id":100020801,"comment_content":"今天的学习很有收获，一直没有养成 explain sql 的习惯，看来以后要记得。<br><br>今天讲了两个问题:<br>1. 该不该用 join<br>2. 如果使用了 join ，怎么进行优化<br><br>解答:<br><br>1. 当被驱动表在 join 时能用上索引，则可以使用 join。<br>2. 当被驱动表用不上索引时，就会变为 BNJ ，此时表的总扫描行数会很大，这时候需要将小表作为驱动表，以减少扫描行数。<br><br>如何确定小表: 应该根据 where 条件过滤以后的行数和查询的字段大小来决定，不能光看数据表的行数。","like_count":0},{"had_liked":false,"id":161181,"user_name":"遇见","can_delete":false,"product_type":"c1","uid":1624590,"ip_address":"","ucode":"FAF53CD4C28494","user_header":"https://static001.geekbang.org/account/avatar/00/18/ca/0e/5009c5ff.jpg","comment_is_top":false,"comment_ctime":1576138633,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576138633","product_id":100020801,"comment_content":"如果不用straight_join, MySQL是怎么选择驱动表的呢? 是会先找小表然后用这个小表做驱动表吗?","like_count":0},{"had_liked":false,"id":156178,"user_name":"ClaireToffler","can_delete":false,"product_type":"c1","uid":1738030,"ip_address":"","ucode":"0C537F129F4EAF","user_header":"https://static001.geekbang.org/account/avatar/00/1a/85/2e/92c506ce.jpg","comment_is_top":false,"comment_ctime":1574829171,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574829171","product_id":100020801,"comment_content":"老师讲的很好,但是对于我这个刚入行的小白来说 ,看了这么多文章,的确是有点懵懂,都感觉是一知半解,不能深刻的理解,请老师指点指点,如何能改变现状? 谢谢老师<br>","like_count":0},{"had_liked":false,"id":151892,"user_name":"Gavin","can_delete":false,"product_type":"c1","uid":1641609,"ip_address":"","ucode":"59E2C6A74EE183","user_header":"https://static001.geekbang.org/account/avatar/00/19/0c/89/44e33be0.jpg","comment_is_top":false,"comment_ctime":1573807357,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573807357","product_id":100020801,"comment_content":"老师好，请教个问题，就是NLJ跟BLJ 比较过程，数据是存在哪块内存上的。<br>BLJ 的驱动表数据是保存在join_buffer里，被驱动表在比较时是检查innodb_buffer_pool是否存在数据，如果有就拿去比较，没有就从磁盘上拉到innodb_buffer_pool吗？如果是这样的话，假设被驱动表比较大，innodb_buffer_pool放不下，那么这个公式：N+λ*N*M 的后半部分是不是存在多次从磁盘读取的情况。如果被驱动表比较小，innodb_buffer_pool可以放下，那么λ*N*M 大部分读取都是从innodb_buffer_pool上读取的？","like_count":0},{"had_liked":false,"id":151506,"user_name":"Geek_WBL","can_delete":false,"product_type":"c1","uid":1473803,"ip_address":"","ucode":"1768A03CEF4CCE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epcLktmsepiaUn9Y45Rsibhqc8t0EvISvrpoKx9ahG7sV1KU7DLbgEIKdTgIpm2GSd9ulsSUiawj4fjg/132","comment_is_top":false,"comment_ctime":1573732333,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573732333","product_id":100020801,"comment_content":"前面我们说过，如果使用 Simple Nested-Loop Join 算法进行查询，扫描行数也是 10 万行。<br>这个地方是不是有问题，应该是判断次数也是10万次","like_count":0},{"had_liked":false,"id":148976,"user_name":"清音Susunma~🍀","can_delete":false,"product_type":"c1","uid":1710369,"ip_address":"","ucode":"63AF68C6F8EFF6","user_header":"https://static001.geekbang.org/account/avatar/00/1a/19/21/d585475b.jpg","comment_is_top":false,"comment_ctime":1573120417,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573120417","product_id":100020801,"comment_content":"老师，有两个问题：1. 是不是只要被驱动表上没有使用索引，就会用到Block Nested Loop算法?<br>2. 我发现，当两个表都在a字段有索引，使用left join，会出现表一做驱动表，会用上表二的索引，但是表二做驱动表的时候，就不会用上表一的索引，从而出现了BNL算法，下面是对应的例子：<br>create table a1(id int, item_id varchar, index(item_id))engine=innodb;<br>create table b1(id int, item_id varchar, type int, index(item_id))engine=innodb;<br>语句一：select a1.id, a1.item_id, b1.type from a1 left join b1 on a1.item_id  = b1.item_id;  <br>语句二：select a1.id, a1.item_id, b1.type from b1 left join a1 on a1.item_id  = b1.item_id;<br>结果显示，语句二中，被驱动表a1没能用上索引item_Id，所以用了BNT算法，但是语句一却用上了索引，这是为什么呢？","like_count":0},{"had_liked":false,"id":147738,"user_name":"lzh","can_delete":false,"product_type":"c1","uid":1336951,"ip_address":"","ucode":"C3D83DF4230109","user_header":"https://static001.geekbang.org/account/avatar/00/14/66/77/194ba21d.jpg","comment_is_top":false,"comment_ctime":1572882194,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572882194","product_id":100020801,"comment_content":"老师搞个源码专栏多好啊，至少有人领着入门，自己看源码说不定门都找不到在哪","like_count":0},{"had_liked":false,"id":143869,"user_name":"饭粒","can_delete":false,"product_type":"c1","uid":1153455,"ip_address":"","ucode":"4C3220B0D43997","user_header":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","comment_is_top":false,"comment_ctime":1571801166,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571801166","product_id":100020801,"comment_content":"收获颇多。👍","like_count":0},{"had_liked":false,"id":142044,"user_name":"hyzhaolt","can_delete":false,"product_type":"c1","uid":1509080,"ip_address":"","ucode":"9D901B26E285CA","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epe7nx104LWFd7MHQVKCJeVwlr6pXmJClpEYic2Pw1ARhAbeqJicBpvL4XN9Xpbqr6icblqkeahibuwHw/132","comment_is_top":false,"comment_ctime":1571282934,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571282934","product_id":100020801,"comment_content":"老师你好 请问在实际项目中碰到过类似一个问题咨询一下您 问题：<br> 1  a 表 join b 表 on 相关字段 相关字段在两个表中都有索引也就是可以用到 NJL 但是 在最后的语句中 limit 4000时还是很快的 但是 limit 400000,4000 就很慢了要 10几秒 所以请问老师这种情况下导致慢的根本原因是什么呢 ，有什么更好的解决方案嘛 还是直接不用join ；<br> <br>2 请问老师 join出来的结果集是放在了内存还是 磁盘空间呢 是不是会形成一个view呢<br>麻烦老师解答一下 谢谢<br>","like_count":0},{"had_liked":false,"id":140764,"user_name":"change","can_delete":false,"product_type":"c1","uid":1110876,"ip_address":"","ucode":"D78B4B3752B6FE","user_header":"https://static001.geekbang.org/account/avatar/00/10/f3/5c/8704e784.jpg","comment_is_top":false,"comment_ctime":1571044946,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1571044946","product_id":100020801,"comment_content":"mysql&gt; select @@version;<br>+-----------+<br>| @@version |<br>+-----------+<br>| 5.7.24    |<br>+-----------+<br>1 row in set (0.00 sec)<br><br>mysql&gt; show variables like &#39;%join_buffer_size%&#39;;<br>+------------------+-------+<br>| Variable_name    | Value |<br>+------------------+-------+<br>| join_buffer_size | 128   |<br>+------------------+-------+<br>1 row in set (0.01 sec)<br>mysql&gt; use test<br>Reading table information for completion of table and column names<br>You can turn off this feature to get a quicker startup with -A<br><br>Database changed<br>mysql&gt; explain select t1.*, t2.b from t1 inner join t2 on (t1.b=t2.b) where t2.id&lt;=100;<br>+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+<br>| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra                                              |<br>+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+<br>|  1 | SIMPLE      | t1    | NULL       | ALL   | NULL          | NULL    | NULL    | NULL |  100 |   100.00 | NULL                                               |<br>|  1 | SIMPLE      | t2    | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |  100 |    10.00 | Using where; Using join buffer (Block Nested Loop) |<br>+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------------------+<br>2 rows in set, 1 warning (0.01 sec)<br>-------------------<br>straight_join是限定左边的表为驱动表,右边的表是被驱动表,优化器不能结合两个表中的行数和内容两个因素来决定哪个表是驱动表,我这里用的是inner join,两个表都是100行,t2中只需要查出b字段,按照中讲的应该选择t2驱动表的,但是执行计划还是以t1为驱动表,麻烦各位大神帮忙解惑","like_count":0},{"had_liked":false,"id":137728,"user_name":"陈春","can_delete":false,"product_type":"c1","uid":1310177,"ip_address":"","ucode":"A73CF1E7CF7AF2","user_header":"https://static001.geekbang.org/account/avatar/00/13/fd/e1/dc971f5b.jpg","comment_is_top":false,"comment_ctime":1569831868,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569831868","product_id":100020801,"comment_content":"问个提我话，我看到很多MySQL规范都不建议使用存储过程和视图，请问这个是合理的吗？如果合理，是为什么，谢谢！","like_count":0},{"had_liked":false,"id":136717,"user_name":"夏目","can_delete":false,"product_type":"c1","uid":1212750,"ip_address":"","ucode":"67C075A01CF4D2","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/4e/d71092f4.jpg","comment_is_top":false,"comment_ctime":1569497395,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569497395","product_id":100020801,"comment_content":"老师 想请教下inner join之后原语句驱动表顺序改变了 除了用straight_join强制驱动顺序外还有其他的办法吗","like_count":0},{"had_liked":false,"id":131157,"user_name":"huolang","can_delete":false,"product_type":"c1","uid":1346708,"ip_address":"","ucode":"FDC4A6B6151C5E","user_header":"https://static001.geekbang.org/account/avatar/00/14/8c/94/5282994c.jpg","comment_is_top":false,"comment_ctime":1567654855,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567654855","product_id":100020801,"comment_content":"老师，使用join的时候，on和where的区别是什么？<br>老师能不能详细说一下join的执行细节，on和where的条件是在什么之后执行的。<br>我看网上有种说法是，join的where的条件过滤是在两个表根据on的条件join完再执行过滤的，也就是说两个表连接完以后再根据where条件过滤数据，这样的话，where的条件不能起到减少表连接时的数量。","like_count":0},{"had_liked":false,"id":130313,"user_name":"MrVito","can_delete":false,"product_type":"c1","uid":1252169,"ip_address":"","ucode":"716FF6F8871706","user_header":"https://static001.geekbang.org/account/avatar/00/13/1b/49/ddefc656.jpg","comment_is_top":false,"comment_ctime":1567423733,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567423733","product_id":100020801,"comment_content":"根据上一篇文章的讲述，整个查询在LRU缓存策略，buffer pool里面的数据就会超过1秒，这样就会放在了young数据里面，整个LRU就会乱套了，这是查询热数据也会性能过慢，buffer pool hit rate过低","like_count":0},{"had_liked":false,"id":129941,"user_name":"szc","can_delete":false,"product_type":"c1","uid":1202730,"ip_address":"","ucode":"869C227F5D2513","user_header":"https://static001.geekbang.org/account/avatar/00/12/5a/2a/5ab880b0.jpg","comment_is_top":false,"comment_ctime":1567331103,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567331103","product_id":100020801,"comment_content":"select t1.b,t2.* from  t1  straight_join t2 on (t1.b=t2.b) where t2.id&lt;=100;<br>select t1.b,t2.* from  t2  straight_join t1 on (t1.b=t2.b) where t2.id&lt;=100;<br>这个为什么 t1参与join的是100行呢？","like_count":0},{"had_liked":false,"id":123377,"user_name":"吴小智","can_delete":false,"product_type":"c1","uid":1310798,"ip_address":"","ucode":"C7C9F58B5C9F7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","comment_is_top":false,"comment_ctime":1565664279,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565664279","product_id":100020801,"comment_content":"收益匪浅，在极客时间买的第一门课，超值超赞","like_count":0},{"had_liked":false,"id":123372,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1565662778,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565662778","product_id":100020801,"comment_content":"对于图3的BNL过程，t1和t2都会读入join buffer吗？否则t2扫描的次数也将是M*N次，总的扫描次数应该是N+M*N次。","like_count":0},{"had_liked":false,"id":122624,"user_name":"zz240","can_delete":false,"product_type":"c1","uid":1582722,"ip_address":"","ucode":"20B68B942C4B07","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLAZhhRRQRdNgZlHialyPRU3fMK4tnCwHic4z292Aibo8UicyqAeljibv1WzhomegqGlMica0Uibsr1SLljw/132","comment_is_top":false,"comment_ctime":1565443401,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565443401","product_id":100020801,"comment_content":"老师您好，我想问一下最后的总结说两个表按照各自的条件过滤，是指在where条件中的过滤吗，我以前的理解是驱动表和被驱动表，首先在on条件里面过滤然后再执行连接得到一个连接表，最后再根据where条件筛选掉连接表里的数据返回结果集，有些矛盾因为之前做过一些测试让我得出了这个结论，还有在经过了on条件之后驱动表和被驱动表就无法使用索引连接了，望老师解答。。w(ﾟДﾟ)w","like_count":0},{"had_liked":false,"id":120634,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1564964333,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564964333","product_id":100020801,"comment_content":"高频知识点，前几天还写了一堆相关的SQL语句呢!<br>既然MySQL提供了，用一定是能用的，只是想用好还是要补充点使用原则的知识的。几乎所有工具的正常使用都是要求性能最大化的，join也一样，数据查询能用到索引速度就会快，搜索的范围小速度就会快，所以，用小结果集作为驱动表，用explain看是否用到了索引，基本就用不错啦！<br>感谢，老师这篇很实用!","like_count":0},{"had_liked":false,"id":116143,"user_name":"topsion","can_delete":false,"product_type":"c1","uid":1158152,"ip_address":"","ucode":"01366517C6F564","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/08/8b99367c.jpg","comment_is_top":false,"comment_ctime":1563793283,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563793283","product_id":100020801,"comment_content":"老师，数据记录读取到join buffer 也是按页读取吧？单位不是记录","like_count":0},{"had_liked":false,"id":115179,"user_name":"ZHANG","can_delete":false,"product_type":"c1","uid":1442437,"ip_address":"","ucode":"BAFD110AE33328","user_header":"https://static001.geekbang.org/account/avatar/00/16/02/85/9a81a973.jpg","comment_is_top":false,"comment_ctime":1563503964,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563503964","product_id":100020801,"comment_content":"老师好，读了几遍我有个问题不太明白<br>Block Nested-Loop Join，驱动表可能会被分段放到join_buffer中，放到join_buffer的数据是从哪儿来的呢，也是从buffer pool来的吗？如果buffer pool没有就会读盘。","like_count":0},{"had_liked":false,"id":112881,"user_name":"Ryoma","can_delete":false,"product_type":"c1","uid":1130590,"ip_address":"","ucode":"7F692369239692","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/5e/b8fada94.jpg","comment_is_top":false,"comment_ctime":1562836791,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1562836791","product_id":100020801,"comment_content":"但是，这样算来，这个 SQL 请求就要扫描表 t2 多达 100 次。。。<br><br>这里应该是 1000 次，t2 是1000行数据的 ","like_count":0},{"had_liked":false,"id":103543,"user_name":"jacy","can_delete":false,"product_type":"c1","uid":1103456,"ip_address":"","ucode":"0022A8759DDCE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/60/f21b2164.jpg","comment_is_top":false,"comment_ctime":1560472302,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1560472302","product_id":100020801,"comment_content":"如果把innodedb缓存old区占满，而重复扫描且时间在一秒内的话无法被最近最少使用算法唤出，从而挤占其他热点数据。导致内存命中率下降，增加io压力,降低处理性能等连锁反应就来了。<br>","like_count":0},{"had_liked":false,"id":93394,"user_name":"菜鸟起飞🛫","can_delete":false,"product_type":"c1","uid":1091783,"ip_address":"","ucode":"6B78994D10755B","user_header":"https://static001.geekbang.org/account/avatar/00/10/a8/c7/c2ccb449.jpg","comment_is_top":false,"comment_ctime":1557463365,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557463365","product_id":100020801,"comment_content":"老师您好，图 4 不使用索引字段 join 的 explain 结果rows为1000，我的显示出来的rows是829，这是为啥呀<br>?","like_count":0},{"had_liked":false,"id":93092,"user_name":"不似旧日","can_delete":false,"product_type":"c1","uid":1161271,"ip_address":"","ucode":"DF4C5E3AB9570C","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","comment_is_top":false,"comment_ctime":1557396512,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557396512","product_id":100020801,"comment_content":"使用join语句不是会产生笛卡儿积么？ 这样效率是不是不高？<br>","like_count":0},{"had_liked":false,"id":90644,"user_name":"不似旧日","can_delete":false,"product_type":"c1","uid":1161271,"ip_address":"","ucode":"DF4C5E3AB9570C","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","comment_is_top":false,"comment_ctime":1556594549,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556594549","product_id":100020801,"comment_content":"select * from t1 straight_join t2 on (t1.a=t2.a);<br>与<br>select * from t1 , t2 where  t1.a=t2.a; <br>有什么区别?<br>","like_count":0},{"had_liked":false,"id":85891,"user_name":"bluefantasy3","can_delete":false,"product_type":"c1","uid":1299930,"ip_address":"","ucode":"9D6FF2811F7465","user_header":"","comment_is_top":false,"comment_ctime":1555288745,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555288745","product_id":100020801,"comment_content":"请教一个问题，如下是原文：<br>&quot;前面我们说过，如果使用 Simple Nested-Loop Join 算法进行查询，扫描行数也是 10 万行。因此，从时间复杂度上来说，这两个算法是一样的。但是，Block Nested-Loop Join 算法的这 10 万次判断是内存操作，速度上会快很多，性能也更好。&quot;<br><br>我的问题：我理解即使是simple nested-loop join也是内存操作呀，数据库的读应该是以页为单位读到内存的。假如A表有m页，读入内存需要m次io，B表有n页，读入内存需要n次io。这两种join算法的io次数都是m*n次。 其他都是内存操作。性能应该一样呀？ 请老师指正。。谢谢。。<br><br>","like_count":0},{"had_liked":false,"id":77701,"user_name":"未完成","can_delete":false,"product_type":"c1","uid":1303231,"ip_address":"","ucode":"2697C7E7B15655","user_header":"https://static001.geekbang.org/account/avatar/00/13/e2/bf/574d4ac9.jpg","comment_is_top":false,"comment_ctime":1552984618,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552984618","product_id":100020801,"comment_content":"select p.id,u.product_id,u.ua from product p join user u on p.id=u.id INTO OUTFILE &quot;&#47;tmp&#47;a.txt&quot; fields terminated by &#39;|&#39; enclosed by &#39;&quot;&#39; lines terminated by &#39;\\n&#39;;<br>+----+-------------+-------+--------+--------------------------+---------+---------+-----------+--------+-------+<br>| id | select_type | table | type   | possible_keys            | key     | key_len | ref       | rows   | Extra |<br>+----+-------------+-------+--------+--------------------------+---------+---------+-----------+--------+-------+<br>|  1 | SIMPLE      | p     | ALL    | NULL                     | NULL    | NULL    | NULL      | 904579 | NULL  |<br>|  1 | SIMPLE      | u     | eq_ref | PRIMARY,id_product_index | PRIMARY | 4       | test.p.id |      1 | NULL  |<br>+----+-------------+-------+--------+--------------------------+---------+---------+-----------+--------+-------+<br>表 product 没有索引，user id 是主键表比较大千万级，这个按照我的理解应该是用的nlj，user的表大小对这个请求速度应该影响不会太大 ，我的&#47;tmp&#47;a.txt 这个文件是每到16m才会写入一次，应该对应的是nlj算法图中结果集的部分，请问一下是不是结果集到某个值的时候才会写入到a.txt文件如果是的话这个值对应的配置是什么啊？","like_count":0},{"had_liked":false,"id":72244,"user_name":"delete is create","can_delete":false,"product_type":"c1","uid":1147979,"ip_address":"","ucode":"A8C751219A7746","user_header":"https://static001.geekbang.org/account/avatar/00/11/84/4b/e4738ba8.jpg","comment_is_top":false,"comment_ctime":1551539258,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1551539258","product_id":100020801,"comment_content":"今天在实际中遇到一个问题  left join了一张表后主表的条件筛选就不起作用了  除非把left join  变为inner  join","like_count":0},{"had_liked":false,"id":66770,"user_name":"马儿快跑","can_delete":false,"product_type":"c1","uid":1031022,"ip_address":"","ucode":"58FD8AE933D4F9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bb/6e/44c74b05.jpg","comment_is_top":false,"comment_ctime":1550018800,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550018800","product_id":100020801,"comment_content":"值得反复看","like_count":0},{"had_liked":false,"id":66274,"user_name":"松花皮蛋me","can_delete":false,"product_type":"c1","uid":1000054,"ip_address":"","ucode":"B0846CEEF6B0D1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/76/256bbd43.jpg","comment_is_top":false,"comment_ctime":1549901414,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549901414","product_id":100020801,"comment_content":"left join和right join，MySQL优化器可能会选择正确的表作为驱动表?","like_count":0},{"had_liked":false,"id":65139,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1549074269,"is_pvip":true,"replies":[{"id":"23093","content":"这个是实际跑出来的效果<br><br>如果说计算的话，每一行固定长度，你用1024除一下😆","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1549098023,"ip_address":"","comment_id":65139,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1549074269","product_id":100020801,"comment_content":"老师，放完88行就满了，88是怎么计算得来的呢？","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438332,"discussion_content":"这个是实际跑出来的效果\n\n如果说计算的话，每一行固定长度，你用1024除一下😆","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549098023,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64637,"user_name":"天王","can_delete":false,"product_type":"c1","uid":1239337,"ip_address":"","ucode":"C074B2F9A5F007","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/29/629d9bb0.jpg","comment_is_top":false,"comment_ctime":1548839237,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548839237","product_id":100020801,"comment_content":"在选择驱动表的时候，会先用条件过滤掉各自表的数据以后，数据量小的做为驱动表。Block nested-Loop join ，使用这种算法，扫描行数过多，如果发现这种，就尽量不要使用join。","like_count":0},{"had_liked":false,"id":64635,"user_name":"天王","can_delete":false,"product_type":"c1","uid":1239337,"ip_address":"","ucode":"C074B2F9A5F007","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/29/629d9bb0.jpg","comment_is_top":false,"comment_ctime":1548838914,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548838914","product_id":100020801,"comment_content":"join的时候，join的2个表，一个是驱动表表1，一个是被驱动表表2，选择驱动表，应该找小表做驱动表。根据join的2个字段是否有索引分为几种情况，1如果被驱动表字段有索引，执行顺序，会先找小表做驱动表，过滤出小表的数据，再拿出小表的join字段一条条去被驱动表找数据。2 如果被驱动表没有索引，如果内存足够大，会先把驱动表放在内存里，然后全表扫描被驱动表，一条条的和驱动表的数据比对，比对成功的，则把数据返回。如果内存放不下，则分成几批，分批把驱动表的数据分成几份，分几份，则被驱动表会扫描几遍。如果内存够大，能一次放入，扫描的行数是驱动表行数和被驱动表行数之后，比较次数是积，如果内存不够，选择小表做驱动表扫描行数会减小。","like_count":0},{"had_liked":false,"id":64574,"user_name":"夹心面包","can_delete":false,"product_type":"c1","uid":1301957,"ip_address":"","ucode":"002BBA49D83D17","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJCscgdVibmoPyRLRaicvk6rjTJxePZ6VFHvGjUQvtfhCS6kO4OZ1AVibbhNGKlWZmpEFf2yA6ptsqHw/132","comment_is_top":false,"comment_ctime":1548827293,"is_pvip":false,"replies":[{"id":"22873","content":"驱动表就把条件过滤以后的结果集记为N吧 😆","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548829686,"ip_address":"","comment_id":64574,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1548827293","product_id":100020801,"comment_content":"如果驱动表也有条件过滤的话,那么复杂度是不是可以看作  2*log2N+N*2*log2M。<br>","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438082,"discussion_content":"驱动表就把条件过滤以后的结果集记为N吧 😆","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548829686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64556,"user_name":"岁月安然","can_delete":false,"product_type":"c1","uid":1258557,"ip_address":"","ucode":"4538C24B67B513","user_header":"https://static001.geekbang.org/account/avatar/00/13/34/3d/51762e76.jpg","comment_is_top":false,"comment_ctime":1548820425,"is_pvip":false,"replies":[{"id":"22867","content":"这个是下一篇的课后问题😆，后面我们会分析哈","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548823041,"ip_address":"","comment_id":64556,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1548820425","product_id":100020801,"comment_content":"想问下老师当出现多级join关联时，比如：<br>select * from t1 <br>inner join t2 on t2.a = t1.a<br>inner join t3 on t3.a = t1.a<br>这种情况下，我理解应该还是小表做驱动表。后续的表 join 顺序会对查询性能造成影响嘛？怎么样才是最优的查询语句？","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438068,"discussion_content":"这个是下一篇的课后问题😆，后面我们会分析哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548823041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64514,"user_name":"supertizzy","can_delete":false,"product_type":"c1","uid":1071488,"ip_address":"","ucode":"6A042C5AF76428","user_header":"https://static001.geekbang.org/account/avatar/00/10/59/80/dc4a799f.jpg","comment_is_top":false,"comment_ctime":1548814410,"is_pvip":false,"replies":[{"id":"22844","content":"不会专门一篇介绍哈，说下你的问题😆","user_name":"作者回复","user_name_real":"林晓斌","uid":"1264162","ctime":1548818616,"ip_address":"","comment_id":64514,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1548814410","product_id":100020801,"comment_content":"老师之后会介绍分库分表吗？","like_count":0,"discussions":[{"author":{"id":1264162,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4a/22/2681d602.jpg","nickname":"林晓斌","note":"","ucode":"CDE42D44F26240","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438039,"discussion_content":"不会专门一篇介绍哈，说下你的问题😆","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548818616,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}