{"id":740872,"title":"第 7 章 对象关系映射(2)","content":"<h2 id=\"nav_point_114\">7.2　通过 MyBatis 操作数据库</h2>\n<p>MyBatis 是一款优秀的持久化框架，它支持自定义 SQL、存储过程和高级映射。与 Hibernate 一样，我们几乎不再需要手写 JDBC 代码，就能完成常见的数据库操作。表 7-8 对两种对象关系映射框架做了一个简单的对比。</p>\n<p><strong>表 7-8　MyBatis 与 Hibernate 的简单对比 <sup><b>10</b> <b>11</b></sup></strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>&nbsp;</p></th>\n<th><p>MyBatis</p></th>\n<th><p>Hibernate</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>XML 方式配置映射</p></td>\n<td><p>支持</p></td>\n<td><p>支持</p></td>\n</tr>\n<tr>\n<td><p>注解方式配置映射</p></td>\n<td><p>支持</p></td>\n<td><p>支持</p></td>\n</tr>\n<tr>\n<td><p>自动生成目标 SQL</p></td>\n<td><p>不支持 <span class=\"comment-number\">10</span></p></td>\n<td><p>支持</p></td>\n</tr>\n<tr>\n<td><p>复杂的 SQL 操作</p></td>\n<td><p>支持</p></td>\n<td><p>部分支持 <span class=\"comment-number\">11</span></p></td>\n</tr>\n<tr>\n<td><p>SQL 优化难易程度</p></td>\n<td><p>方便</p></td>\n<td><p>不方便</p></td>\n</tr>\n<tr>\n<td><p>底层数据库的可移植性</p></td>\n<td><p>映射 SQL 与数据库绑定</p></td>\n<td><p>有灵活的“方言”支持</p></td>\n</tr>\n</tbody>\n</table>\n\n\n<p>通过 Google Trends，我们可以看到一个有趣的现象：过去 5 年里 <span class=\"comment-number\">12</span>，在全球范围内，Hibernate 的搜索热度是 MyBatis 的 5.7 倍；而在中国，情况恰恰相反，MyBatis 的搜索热度是 Hibernate 的 2.7 倍左右。按照对 MyBatis 关键词的关注度排序的话，前 5 个城市分别是杭州、北京、深圳、上海和广州。</p><!-- [[[read_end]]] -->\n\n<p>其实，这个现象还是比较容易解释的，在中国，互联网大厂普遍更喜欢使用 MyBatis。在阿里，绝大多数 Java 项目都使用 MyBatis 而非 Hibernate，若配合一些工具，MyBatis 的方便程度不亚于 Hibernate，而且专业的 DBA 可以对 SQL 做各种优化，灵活度很高。</p>\n<p>因此，这一节，我们会一起来简单看一下如何在 Spring 项目中使用 MyBatis。更多详细的内容，感兴趣的同学可以查阅官方文档。官方也有比较详细的中文版本。</p>\n<h3 id=\"nav_point_115\">7.2.1　定义 MyBatis 映射</h3>\n<p>MyBatis 支持通过 XML 和注解两种方式来配置映射。从早期的 iBatis 开始，XML 的功能就已经很齐全了，注解的方式是后来才出现的。因为在介绍 JPA 时我们就使用了注解的方式，所以这里我们也通过注解来做映射。</p>\n<ol>\n<li><p><strong>通过注解定义常用操作映射</strong></p>\n<p>在使用 JPA 时，我们的映射关系是定义在实体类上的；但在 MyBatis 中，我们对实体类没有什么要求，也无须添加特定的注解，各种映射都是通过 <code>Mapper</code> 接口来定义的。代码示例 7-19<span class=\"comment-number\">13</span> 是与代码示例 7-3 对应的实体类，只保留了 Lombok 注解，没有其他额外的内容，其他几个实体类的改动是一样的，就不再说明了。</p>\n<blockquote>\n<p><strong>代码示例 7-19</strong>　MyBatis 中使用的部分实体类定义</p>\n</blockquote>\n<pre class=\"code-rows\"><code>public enum Size {\n    SMALL, MEDIUM, LARGE\n}\n\n@Builder\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\n    public class MenuItem {\n    private Long id;\n    private String name;\n    private Size size;\n    private Money price;\n    private Date createTime;\n    private Date updateTime;\n}</code></pre>\n<p>与之匹配的 <code>Mapper</code> 接口如代码示例 7-20 所示，其中包含了常用的增删改查方法，两种实现方式下它们的功能是基本类似的。</p>\n<blockquote>\n<p><strong>代码示例 7-20</strong>　添加了 MyBatis 注解的 <code>Mapper</code> 接口</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Mapper\npublic interface MenuItemMapper {\n    @Select(\"select count(*) from t_menu\")\n    long count();\n\n    @Insert(\"insert into t_menu (name, price, size, create_time, update_time) \" +\n            \"values (#, #, #, now(), now())\")\n    @Options(useGeneratedKeys = true, keyProperty = \"id\")\n    int save(MenuItem menuItem);\n\n    @Update(\"update t_menu set name = #, price = #, size = #, update_time = now() \" +\n            \"where id = #\")\n    int update(MenuItem menuItem);\n\n    @Select(\"select * from t_menu where id = #\")\n        @Results(id = \"menuItem\", value = {\n        @Result(column = \"id\", property = \"id\", id = true),\n        @Result(column = \"size\", property = \"size\", typeHandler = EnumTypeHandler.class),\n        @Result(column = \"price\", property = \"price\", typeHandler = MoneyTypeHandler.class),\n        @Result(column = \"create_time\", property = \"createTime\"),\n        @Result(column = \"update_time\", property = \"updateTime\")\n    })\n    MenuItem findById(@Param(\"id\") Long id);\n\n    @Delete(\"delete from t_menu where id = #\")\n    int deleteById(@Param(\"id\") Long id);\n\n    @Select(\"select * from t_menu\")\n    List&lt;MenuItem&gt; findAll();\n\n    @Select(\"select m.* from t_menu m, t_order_item i where m.id = i.item_id and i.order_id = #\")\n    List&lt;MenuItem&gt; findByOrderId(Long orderId);\n}</code></pre>\n<p>接下来，让我们详细地了解一下上述代码中用到的注解，具体如表 7-9 所示。</p>\n<p><strong>表 7-9　MyBatis 中的常用注解</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>注解</th><th>作用</th><th>重点属性说明</th></tr><tr><td><code>@Insert</code></td><td>定义插入操作</td><td><code>value</code> 为具体使用的 SQL 语句</td></tr><tr><td><code>@Delete</code></td><td>定义删除操作</td><td>同上</td></tr><tr><td><code>@Update</code></td><td>定义更新操作</td><td>同上</td></tr><tr><td><code>@Select</code></td><td>定义查询操作</td><td>同上</td></tr><tr><td><code>@Param</code></td><td>指定参数名称，方便在 SQL 中使用对应参数（一般不用指定）</td><td></td></tr><tr><td><code>@Results</code></td><td>指定返回对象的映射方式，具体内容通过 <code>@Result</code> 注解设置</td><td><code>id</code> 用来设置结果映射的 ID，以便复用</td></tr><tr><td><code>@Result</code></td><td>指定具体字段、属性的映射关系</td><td></td></tr><tr><td><code>@ResultMap</code></td><td>引用其他地方已事先定义好的映射关系</td><td></td></tr><tr><td><code>@Options</code></td><td>设置开关和配置选项</td><td><code>useGeneratedKeys</code>——使用生成的主键，<code>keyProperty</code>——主键属性名，<code>fetchSize</code>——获取结果集的条数，<code>timeout</code>——超时时间</td></tr><tr><td><code>@One</code></td><td>指定复杂的单个属性映射</td><td><code>Select</code>——指定查询使用的 Java 方法</td></tr><tr><td><code>@Many</code></td><td>指定复杂的集合属性映射</td><td>同上</td></tr></table>\n\n<p>&nbsp;</p>\n</li>\n<li><p><strong>自定义类型映射</strong></p>\n<p>MyBatis 是通过 <code>TypeHandler</code> 来实现特殊类型的处理的。在代码示例 7-17 中，有一段代码定义了特殊类型的映射，具体代码如下：</p>\n<pre class=\"code-rows\"><code>@Result(column = \"size\", property = \"size\", typeHandler = EnumTypeHandler.class),\n@Result(column = \"price\", property = \"price\", typeHandler = MoneyTypeHandler.class),</code></pre>\n<p><code>size</code> 属性是一个枚举，通常枚举在数据库中有两种保存方式，一种是保存枚举名，用的就是 <code>EnumTypeHandler</code>，例如，<code>size</code> 枚举的 <code>SMALL</code>、<code>MEDIUM</code> 和 <code>LARGE</code>；另一种是保存枚举的顺序，用的是 <code>EnumOrdinalTypeHandler</code>，例如，<code>0</code>、<code>1</code> 和 <code>2</code> 分别对应了前面 <code>size</code> 枚举的 <code>SMALL</code>、<code>MEDIUM</code> 和 <code>LARGE</code>。MyBatis 中默认使用 <code>EnumTypeHandler</code> 来处理枚举类型。</p>\n<p><code>price</code> 属性的类型是 <code>Money</code>，这个类 MyBatis 没有提供内置的 <code>TypeHandler</code>，因此需要我们自己来实现一个针对 <code>Money</code> 类型的处理器。MyBatis 提供了 <code>BaseTypeHandler</code> 抽象类，通过它可以方便地实现 <code>TypeHandler</code>。<code>MoneyTypeHandler</code> 的代码如代码示例 7-21 所示，它的作用是将金额按分为单位，转换为 <code>Long</code> 类型保存到数据库中，在取出时则以人民币为币种还原为 <code>Money</code>。</p>\n<blockquote>\n<p><strong>代码示例 7-21</strong>　处理 <code>Money</code> 类型的 <code>MoneyTypeHandler</code> 代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>public class MoneyTypeHandler extends BaseTypeHandler&lt;Money&gt; {\n    @Override\n    public void setNonNullParameter(PreparedStatement ps, int i,\n                                    Money parameter, JdbcType jdbcType) throws SQLException {\n        ps.setLong(i, parameter.getAmountMinorLong());\n    }\n\n    @Override\n    public Money getNullableResult(ResultSet rs, String columnName) throws SQLException {\n        return parseMoney(rs.getLong(columnName));\n    }\n\n    @Override\n    public Money getNullableResult(ResultSet rs, int columnIndex) throws SQLException {\n        return parseMoney(rs.getLong(columnIndex));\n    }\n\n    @Override\n    public Money getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {\n        return parseMoney(cs.getLong(columnIndex));\n    }\n\n    private Money parseMoney(Long value) {\n        return Money.ofMinor(CurrencyUnit.of(\"CNY\"), value);\n    }\n}</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>一对多与多对多关系</strong></p>\n<p>在处理对象时，我们还有一对一、一对多和多对多这样的关系，在 JPA 中有对应的注解可以进行配置，在 MyBatis 中也有类似的功能。表 7-9 中已经介绍过了 <code>@One</code> 和 <code>@Many</code> 注解，现在就让我们一起来看一下它们的具体使用方法。</p>\n<p><code>TeaMaker</code> 中的 <code>orders</code> 列表保存的是这位调茶师所负责的订单信息，在 <code>Order</code> 中则通过 <code>maker</code> 属性保存了订单所对应的调茶师信息。这是一个典型的一对多映射，这个关系在数据库中是由 <code>t_order</code> 表的 <code>maker_id</code> 字段来做持久化的。代码示例 7-22 演示了如何定义 <code>TeaMaker</code> 以及该如何加载 <code>orders</code> 集合。可以看到 <code>@Many</code> 中给定的是具体获取方法的全限定类名加方法名，方法的参数就是指定的字段内容。</p>\n<blockquote>\n<p><strong>代码示例 7-22</strong>　在 <code>TeaMakerMapper</code> 中定义一对多的一方</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Mapper\npublic interface TeaMakerMapper {\n    @Select(\"select * from t_tea_maker where id = #\")\n    @Results(id = \"teaMakerMap\", value = {\n        @Result(column = \"id\", property = \"id\"),\n        @Result(column = \"id\", property = \"orders\",\n                many = @Many(select = \"learning.spring.binarytea.repository.OrderMapper.findByMakerId\"))\n    })\n    TeaMaker findById(Long id);\n    // 省略其他方法\n}</code></pre>\n<p>代码示例 7-23 演示了在 <code>Order</code> 中如何根据 <code>maker_id</code> 加载 <code>TeaMaker</code>，<code>@One</code> 中同样提供了具体的查询方法。此外，订单的具体条目和订单之间是一个多对多关系，即 <code>Order</code> 对象和 <code>MenuItem</code> 对象之间存在多对多关系，具体的关系保存在 <code>t_order_item</code> 表中。我们可以看到 <code>Order</code> 的 <code>items</code> 列表使用了 <code>@Many</code> 来指定查询 <code>MenuItem</code> 集合的方法，这个 <code>MenuItemMapper.findByOrderId()</code> 已经在代码示例 7-20 中提供了。代码示例 7-23 的 <code>findByMakerId()</code> 方法还演示了 <code>@ResultMap</code> 注解的用法。</p>\n<blockquote>\n<p><strong>代码示例 7-23</strong>　在 <code>OrderMapper</code> 中定义多对一和多对多关系</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Mapper\npublic interface OrderMapper {\n    @Select(\"select * from t_order where id = #\")\n    @Results(id = \"orderMap\", value = {\n        @Result(column = \"status\", property = \"status\", typeHandler = EnumOrdinalTypeHandler.class),\n        @Result(column = \"amount_discount\", property = \"amount.discount\"),\n        @Result(column = \"amount_total\", property = \"amount.totalAmount\"),\n        @Result(column = \"amount_pay\", property = \"amount.payAmount\"),\n        @Result(column = \"maker_id\", property = \"maker\",\n                one = @One(select = \"learning.spring.binarytea.repository.TeaMakerMapper.findById\")),\n        @Result(column = \"id\", property = \"items\",\n                many = @Many(select = \"learning.spring.binarytea.repository.MenuItemMapper.findByOrderId\"))\n    })\n    Order findById(Long id);\n\n    @Select(\"select * from t_order where maker_id = #\")\n    @ResultMap(\"orderMap\")\n    List&lt;Order&gt; findByMakerId(Long makerId);\n    // 省略其他方法\n}</code></pre>\n<p>除了查询，多对多关系的保存也需要特殊处理，代码示例 7-24 就是具体的内容。<code>OrderMapper</code> 的 <code>save()</code> 方法可以直接保存大部分的订单信息，包括其中与 <code>TeaMaker</code> 的关系。<code>t_order</code> 表在保存 <code>status</code> 时就是使用的 <code>EnumOrdinalTypeHandler</code> 类型处理器，它能够保存序号。<code>addOrderItem()</code> 方法用来添加订单中的具体条目，具体的 SQL 则是向 <code>t_order_item</code> 表中插入记录 <span class=\"comment-number\">14</span>。</p>\n<blockquote>\n<p><strong>代码示例 7-24</strong>　在 <code>OrderRepository</code> 中保存订单及对应内容</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Mapper\npublic interface OrderMapper {\n    @Insert(\"insert into t_order \" +\n            \"(maker_id, status, amount_discount, amount_pay, amount_total, create_time, update_time) \" +\n            \"values (#, #, \" +\n            \"#, #, #, now(), now())\")\n    @Options(useGeneratedKeys = true, keyProperty = \"id\")\n    int save(Order order);\n\n    @Insert(\"insert into t_order_item (order_id, item_id) values (#, #)\")\n    int addOrderItem(Long orderId, MenuItem item);\n    // 省略其他方法\n}</code></pre>\n</li>\n</ol>\n\n\n<h3 id=\"nav_point_116\">7.2.2　在 Spring 中配置并使用 MyBatis</h3>\n<p>定义好了映射关系，接下来的问题就是如何在工程中使用它们。MyBatis-Spring 为 MyBatis 提供了与 Spring Framework 无缝集成的能力，其中包括：</p>\n<ul>\n<li>与 Spring 事务的集成，主要靠 <code>SpringManagedTransaction</code> 与 <code>SpringManagedTransactionFactory</code> 来实现；</li>\n<li><code>SqlSession</code> 的构建，主要靠 <code>SqlSessionFactoryBean</code> 实现；</li>\n<li><code>Mapper</code> 的构建，手动构建靠 <code>MapperFactoryBean</code>，也可以通过 <code>MapperScannerConfigurer</code> 来自动扫描；</li>\n<li>异常的解析与转换，由 <code>MyBatisExceptionTranslator</code> 实现。</li>\n</ul>\n<p>在实际使用时，我们只需要在 Spring Framework 的上下文中配置几个 Bean 就可以了，例如：</p>\n<pre class=\"code-rows\"><code>&lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt;\n    &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt;\n&lt;/bean&gt;\n\n&lt;!-- 按需定义Mapper Bean --&gt;\n&lt;bean id=\"menuItemMapper\" class=\"org.mybatis.spring.mapper.MapperFactoryBean\"&gt;\n    &lt;property name=\"mapperInterface\" value=\"learning.spring.binarytea.repository.MenuItemMapper\" /&gt;\n    &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\" /&gt;\n&lt;/bean&gt;</code></pre>\n<p>在 <code>Mapper</code> 多的时候，可以直接通过扫描来实现 <code>Mapper</code> 的自动注册：</p>\n<pre class=\"code-rows\"><code>&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n        xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xmlns:mybatis=\"http://mybatis.org/schema/mybatis-spring\"\n        xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://mybatis.org/schema/mybatis-spring http://mybatis.org/schema/mybatis-spring.xsd\"&gt;\n\n    &lt;mybatis:scan base-package=\"learning.spring.binarytea.repository\" /&gt;\n\n    &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt;\n        &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt;\n    &lt;/bean&gt;\n\n    &lt;!-- 其他Bean配置 --&gt;\n&lt;/beans&gt;</code></pre>\n<p>当然，还有更方便的注解，可以用来指定扫描范围：</p>\n<pre class=\"code-rows\"><code>@MapperScan(\"learning.spring.binarytea.repository\")\npublic class Config {}</code></pre>\n<p>关于 MyBatis-Spring 的更多配置细节就留给大家慢慢去官方文档 <span class=\"comment-number\">15</span> 中探索吧。其实这样的配置已经十分简单了，但是在 Spring Boot 的加持下，配置还可以进一步简化。于是就该 MyBatis-Spring-Boot-Starter 登场了，它可以帮助我们几乎消除模板式的代码和 XML 配置文件。而我们需要做的只是在 pom.xml 文件中增加相关的依赖，剩下的就交给 <code>MybatisAutoConfiguration</code> 和 <code>MybatisLanguageDriverAutoConfiguration</code> 来做自动配置即可：</p>\n\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;\n    &lt;version&gt;2.2.2&lt;/version&gt;\n&lt;/dependency&gt;</code></pre>\n<p>我们可以通过 <code>application.properties</code> 来定制一些配置，例如表 7-10 中罗列的这些。</p>\n<p><strong>表 7-10　MyBatis-Spring-Boot-AutoConfigure 支持的一些配置项</strong><span class=\"comment-number\">16</span></p>\n\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>配置项</p></th>\n<th><p>说明</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>mybatis.type-aliases-package</code></p></td>\n<td><p>映射的 POJO 类型放置的包路径</p></td>\n</tr>\n<tr>\n<td><p><code>mybatis.type-handlers-package</code></p></td>\n<td><p>类型映射所需的 <code>TypeHandler</code> 放置的包路径</p></td>\n</tr>\n<tr>\n<td><p><code>mybatis.config-location</code></p></td>\n<td><p>MyBatis 配置文件的位置</p></td>\n</tr>\n<tr>\n<td><p><code>mybaits.mapper-locations</code></p></td>\n<td><p>映射文件的位置</p></td>\n</tr>\n<tr>\n<td><p><code>mybatis.configuration.*</code></p></td>\n<td><p>MyBatis 核心配置，例如下面两个，不能和 <code>mybatis.config-location</code> 一起使用</p></td>\n</tr>\n<tr>\n<td><p><code>mybatis.configuration.map-underscore-to-camel-case</code></p></td>\n<td><p>是否将下划线映射为驼峰规则 11</p></td>\n</tr>\n<tr>\n<td><p><code>mybatis.configuration.default-statement-timeout</code></p></td>\n<td><p>默认语句超时时间</p></td>\n</tr>\n</tbody>\n</table>\n<p>例如，在我们的 <code>application.properties</code> 配置文件里就可以像下面这样做配置，再结合带有 <code>@MapperScan</code> 注解的配置类：</p>\n<pre class=\"code-rows\"><code>mybatis.type-handlers-package=learning.spring.binarytea.support.handler\nmybatis.type-aliases-package=learning.spring.binarytea.model\nmybatis.configuration.map-underscore-to-camel-case=true</code></pre>\n<p>为了让程序能够顺利执行，我们还需要事先新建好对应的表，插入几条测试数据。既然使用了 H2 内嵌数据库，自然就可以依赖 6.1.2 节中的内嵌数据库初始化逻辑。schema.sql 中的表结构是根据 7.1 节 Hibernate 自动创建的表结构简单修改而来的，如代码示例 7-25 所示。</p>\n<blockquote>\n<p><strong>代码示例 7-25</strong>　用于 MyBatis 演示的 src/main/resources/schema.sql 文件</p>\n</blockquote>\n<pre class=\"code-rows\"><code>drop table if exists t_menu;\ndrop table if exists t_order;\ndrop table if exists t_order_item;\ndrop table if exists t_tea_maker;\n\ncreate table t_menu (\n    id bigint not null auto_increment, name varchar(255), price bigint, size varchar(255),\n    create_time timestamp, update_time timestamp, primary key (id)\n);\n\ncreate table t_order (\n    id bigint not null auto_increment, amount_discount integer, amount_pay bigint, amount_total bigint,\n    status integer, maker_id bigint, create_time timestamp, update_time timestamp, primary key (id)\n);\n\ncreate table t_order_item (\n    item_id bigint not null, order_id bigint not null\n);\n\ncreate table t_tea_maker (\n    id bigint not null auto_increment, name varchar(255), create_time timestamp, update_time timestamp,\n    primary key (id)\n);</code></pre>\n<p>而初始化的数据则放在 data.sql 中，具体如代码示例 7-26 所示。</p>\n<blockquote>\n<p><strong>代码示例 7-26</strong>　用于 MyBatis 演示的 src/main/resources/data.sql 文件</p>\n</blockquote>\n<pre class=\"code-rows\"><code>insert into t_menu (name, size, price, create_time, update_time) values ('Java咖啡', 'MEDIUM', 1200, now(), now());\ninsert into t_menu (name, size, price, create_time, update_time) values ('Java咖啡', 'LARGE', 1500, now(), now());\n\ninsert into t_tea_maker (name, create_time, update_time) values ('LiLei', now(), now());\ninsert into t_tea_maker (name, create_time, update_time) values ('HanMeimei', now(), now());\n\ninsert into t_order (maker_id, status, amount_discount, amount_pay, amount_total, create_time, update_time) values (1, 0, 100, 1200, 1200, now(), now());\n\ninsert into t_order_item (order_id, item_id) values (1, 1);</code></pre>\n<p>和之前一样，我们使用一段单元测试来验证我们的代码。代码示例 7-27 的逻辑是这样的：</p>\n<p>(1) 构建并保存一个订单对象 <code>Order</code>；</p>\n<p>(2) 插入对应的订单内容；</p>\n<p>(3) 根据第 (1) 步返回的订单 ID，重新查询获得订单对象，验证对应的值是否正确。</p>\n<blockquote>\n<p><strong>代码示例 7-27</strong>　用于测试 <code>OrderMapper</code> 的单元测试片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootTest\nclass OrderMapperTest {\n    @Autowired\n    private OrderMapper orderMapper;\n    @Autowired\n    private TeaMakerMapper makerRepository;\n    @Autowired\n    private MenuItemMapper menuItemMapper;\n\n    @Test\n    @Transactional\n    @Rollback\n    public void testSaveAndFind() {\n        TeaMaker maker = makerRepository.findById(2L);\n        Order order = Order.builder()\n                .status(OrderStatus.ORDERED)\n                .maker(maker)\n                .amount(Amount.builder()\n                        .discount(90)\n                        .totalAmount(Money.ofMinor(CurrencyUnit.of(\"CNY\"), 1200))\n                        .payAmount(Money.ofMinor(CurrencyUnit.of(\"CNY\"), 1080))\n                        .build())\n                .build();\n        assertEquals(1, orderMapper.save(order));\n\n        Long orderId = order.getId();\n        assertNotNull(orderId);\n        assertEquals(1, orderMapper.addOrderItem(orderId, menuItemMapper.findById(2L)));\n\n        order = orderMapper.findById(orderId);\n        assertEquals(OrderStatus.ORDERED, order.getStatus());\n        assertEquals(90, order.getAmount().getDiscount());\n        assertEquals(maker.getId(), order.getMaker().getId());\n        assertEquals(1, order.getItems().size());\n        assertEquals(2L, order.getItems().get(0).getId());\n    }\n    // 省略其他测试\n}</code></pre>\n<p>在上面的代码中，需要特别说明一下加在 <code>testSaveAndFind()</code> 上的 <code>@Rollback</code> 注解。Spring Framework 为测试提供了强大的支持，在涉及数据库操作的时候，为了保证每个测试的运行不会给别的测试带来影响，它直接可以回滚测试中的操作，而且这也是默认的逻辑，也就是说我们不用添加 <code>@Rollback</code> 也是一样的效果。如果希望能够让测试代码的变动被提交到数据库中，可以使用 <code>@Commit</code> 或者 <code>@Rollback(false)</code>。当然，这里一切的前提是先有事务，这也就是为什么会在 <code>testSaveAndFind()</code> 上添加 <code>@Transactional</code> 的原因。</p>\n<h3 id=\"nav_point_117\">7.2.3　提升 MyBatis 的开发效率</h3>\n<p>通过前面的内容，相信大家也隐约感觉到了，相比 JPA，MyBatis 需要自己实现的内容多了一点点。但其实在一些开源工具的帮助下，MyBatis 的开发效率也不亚于 JPA。有些工具是官方提供的，也有一些是非官方的社区提供的，大家的目的都是让开发体验“如丝般顺滑”。</p>\n<ol>\n<li><p><strong>MyBatis 映射生成工具</strong></p>\n<p>MyBatis 的使用离不开大量的配置，尤其是 XML 或注解形式都需要手写 SQL。那么是否有什么办法能让这个过程不那么繁琐呢？答案是肯定的。MyBatis 官方为此提供了一套生成工具—— MyBatis Generator<span class=\"comment-number\">17</span>。</p>\n<p>这套工具可以根据数据库的元数据和配置文件，为我们生成如下内容。</p>\n<ul>\n<li>与数据表对应的 POJO 类。</li>\n<li>Mapper 接口，如果用注解或混合方式配置映射，接口上会有对应的注解。</li>\n<li>SQLMap 映射 XML 文件（仅在 XML 方式或混合方式时生成）。</li>\n</ul>\n<p>其中会包含各种常用的操作，从某种程度上能减少开发的工作量。该工具在使用时需要提供一个 XML 配置文件，与代码示例 7-28 类似。</p>\n<blockquote>\n<p><strong>代码示例 7-28</strong>　MyBatis Generator 配置示例</p>\n</blockquote>\n<pre class=\"code-rows\"><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;\n\n&lt;generatorConfiguration&gt;\n    &lt;context id=\"H2Tables\" targetRuntime=\"MyBatis3\"&gt;\n        &lt;plugin type=\"org.mybatis.generator.plugins.FluentBuilderMethodsPlugin\" /&gt;\n        &lt;plugin type=\"org.mybatis.generator.plugins.ToStringPlugin\" /&gt;\n        &lt;plugin type=\"org.mybatis.generator.plugins.SerializablePlugin\" /&gt;\n        &lt;plugin type=\"org.mybatis.generator.plugins.RowBoundsPlugin\" /&gt;\n\n        &lt;jdbcConnection driverClass=\"org.h2.Driver\" connectionURL=\"jdbc:h2:mem:testdb\" userId=\"sa\" password=\"\"&gt;\n        &lt;/jdbcConnection&gt;\n\n        &lt;javaModelGenerator targetPackage=\"learning.spring.binarytea.model\" targetProject=\"./src/main/java\"&gt;\n            &lt;property name=\"enableSubPackages\" value=\"true\" /&gt;\n            &lt;property name=\"trimStrings\" value=\"true\" /&gt;\n        &lt;/javaModelGenerator&gt;\n\n        &lt;sqlMapGenerator targetPackage=\"learning.spring.binarytea.repository\"\n                         targetProject=\"./src/main/resources/mapper\"&gt;\n            &lt;property name=\"enableSubPackages\" value=\"true\" /&gt;\n        &lt;/sqlMapGenerator&gt;\n\n        &lt;javaClientGenerator type=\"MIXEDMAPPER\" targetPackage=\"learning.spring.binarytea.repository\"\n                             targetProject=\"./src/main/java\"&gt;\n            &lt;property name=\"enableSubPackages\" value=\"true\" /&gt;\n        &lt;/javaClientGenerator&gt;\n\n        &lt;table tableName=\"t_menu\" domainObjectName=\"MenuItem\" &gt;\n            &lt;generatedKey column=\"id\" sqlStatement=\"CALL IDENTITY()\" identity=\"true\" /&gt;\n            &lt;columnOverride column=\"price\" javaType=\"org.joda.money.Money\" jdbcType=\"BIGINT\"\n                            typeHandler=\"learning.spring.binarytea.support.handler.MoneyTypeHandler\"/&gt;\n        &lt;/table&gt;\n    &lt;/context&gt;\n&lt;/generatorConfiguration&gt;</code></pre>\n<p><code>&lt;context/&gt;</code> 中的内容需要按照顺序配置，从上往下分别为：</p>\n<p>(1) <code>&lt;plugin/&gt;</code>，插件配置，例子中配置了生成构建器的插件（类似 Lombok 的 <code>@Builder</code>）、生成 <code>toString()</code> 方法的插件、分页插件等；</p>\n<p>(2) <code>&lt;jdbcConnection/&gt;</code>，JDBC 连接信息；</p>\n<p>(3) <code>&lt;javaModelGenerator/&gt;</code>，POJO 对象生成信息；</p>\n<p>(4) <code>&lt;sqlMapGenerator/&gt;</code>，SQLMap 生成信息；</p>\n<p>(5) <code>&lt;javaClientGenerator/&gt;</code>，Java 客户端，即 Mapper 接口的生成信息；</p>\n<p>(6) <code>&lt;table/&gt;</code>，要生成的数据表配置。</p>\n<p>值得注意的是配置中的目标位置既可以是绝对路径，也可以是相对当前执行目录的相对路径，而且<strong>在生成前需要先确保目录存在</strong>。</p>\n<p>MyBatis Generator 支持多种运行方式，例如，命令行工具、Maven 插件、ANT 任务、Eclipse 插件等。在命令行里可以运行如下命令，JAR 包需要为具体版本的包，同时提供配置文件：</p>\n<pre class=\"code-rows\"><code>java -jar mybatis-generator-core-x.x.x.jar -configfile generatorConfig.xml</code></pre>\n<p>关于这个工具的更多详细内容，大家可以通过官方文档进一步了解，本书就不展开了。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>MyBatis 分页插件</strong></p>\n<p>分页查询是一个很常见的需求，在 MyBatis 里的分页自然也不会很困难，它依托于插件机制，可以通过分页插件来实现分页查询。这里就要介绍一个国人编写的 MyBatis 分页插件 PageHelper<span class=\"comment-number\">18</span>，它支持 3.1.0 以上的 MyBatis 版本，支持十余种数据库的物理分页，还有对应的 Spring Boot Starter，仅需简单几个配置就能直接使用。</p>\n<p>首先，在 pom.xml 中添加对应的依赖，例如：</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;\n    &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;\n    &lt;version&gt;1.4.1&lt;/version&gt;\n&lt;/dependency&gt;</code></pre>\n<p>接下来，在 <code>application.properties</code> 中添加一些设置，常用的设置如表 7-11 所示 <span class=\"comment-number\">19</span>，表中属性的默认值均为 <code>false</code>。我们无须手动设置分页要用到的语法，因为 PageHelper 会自动进行侦测。</p>\n<p><strong>表 7-11　PageHelper 在 Spring Boot 中的一些设置</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>配置项</th><th>说明</th></tr><tr><td><code>pagehelper.offsetAsPageNum</code></td><td>在使用 <code>RowBounds</code> 作为分页参数时，将 <code>offset</code> 作为页码</td></tr><tr><td><code>pagehelper.rowBoundsWithCount</code></td><td>在使用 <code>RowBounds</code> 作为分页参数时，也会执行 <code>count</code> 操作</td></tr><tr><td><code>pagehelper.pageSizeZero</code></td><td>如果分页大小为 <code>0</code>，则返回所有结果</td></tr><tr><td><code>pagehelper.reasonable</code></td><td>合理化分页，传入的页码小于等于 <code>0</code> 时返回第一页，大于最大页时返回最后一页</td></tr><tr><td><code>pagehelper.supportMethodsArguments</code></td><td>从方法的参数中获取分页所需的信息</td></tr></table>\n\n<p>下面我们通过几个测试来了解一下 PageHelper 的具体用法。可以通过静态方法 <code>PageHelper.startPage()</code> 设置分页信息，该信息是保存在 <code>ThreadLocal</code> 变量中的，因此操作需要在一个线程中，例如像代码示例 7-29 的单元测试那样，查询第 1 页，每页 1 条记录。</p>\n<blockquote>\n<p><strong>代码示例 7-29</strong>　针对分页功能测试的 <code>MenuItemMapperTest</code> 代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootTest\npublic class MenuItemMapperTest {\n    @Autowired\n    private MenuItemMapper menuItemMapper;\n\n    @Test\n    public void testPagination() {\n        // 不分页\n        List&lt;MenuItem&gt; list = menuItemMapper.findAll();\n        assertEquals(2, list.size());\n\n        // 分页\n        PageHelper.startPage(1, 1);\n        list = menuItemMapper.findAll();\n        assertEquals(1, list.size());\n        assertTrue(list instanceof Page);\n        PageInfo&lt;MenuItem&gt; pageInfo = new PageInfo&lt;&gt;(list);\n        assertEquals(2, pageInfo.getPages()); // 总页数\n        assertEquals(1, pageInfo.getPageSize()); // 每页大小\n        assertEquals(1, pageInfo.getPageNum()); // 当前页码\n        assertEquals(2, pageInfo.getNextPage()); // 下页页码\n    }\n}</code></pre>\n<p>也可以换种用法，通过 <code>RowBounds</code> 对象或者直接在方法参数中指定分页信息。代码示例 7-30 是修改后的 <code>TeaMakerMapper</code> 的部分相关代码，在代码示例 7-31 中则是对应的使用方法，也是通过单元测试的形式来演示的。</p>\n<blockquote>\n<p><strong>代码示例 7-30</strong>　包含分页逻辑的 <code>TeaMakerMapper</code> 代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Mapper\npublic interface TeaMakerMapper {\n    @Select(\"select * from t_tea_maker\")\n    @ResultMap(\"teaMakerMap\")\n    List&lt;TeaMaker&gt; findAllWithRowBounds(RowBounds rowBounds);\n\n    @Select(\"select * from t_tea_maker\")\n    @ResultMap(\"teaMakerMap\")\n    List&lt;TeaMaker&gt; findAllWithPage(int pageSize, int pageNum);\n\n    // 省略其他方法\n}</code></pre>\n<p>如果 <code>findAllWithPage()</code> 中的参数使用其他名称，也可以用类似 <code>@Param(\"pageNum\") int pageNum</code> 的方式来指定。</p>\n<blockquote>\n<p><strong>代码示例 7-31</strong>　针对 <code>TeaMakerMapper</code> 中分页逻辑的测试代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootTest\npublic class TeaMakerMapperTest {\n    @Autowired\n    private TeaMakerMapper teaMakerMapper;\n\n    @Test\n    public void testPagination() {\n        List&lt;TeaMaker&gt; list = teaMakerMapper.findAllWithRowBounds(new RowBounds(1, 1));\n        PageInfo&lt;TeaMaker&gt; pageInfo = new PageInfo&lt;&gt;(list);\n        assertEquals(1, list.size());\n        assertEquals(1, pageInfo.getPageNum());\n        assertEquals(1, pageInfo.getPageSize());\n        assertEquals(2, pageInfo.getPages());\n\n        list = teaMakerMapper.findAllWithPage(1, 2);\n        pageInfo = new PageInfo&lt;&gt;(list);\n        assertEquals(2, pageInfo.getPageNum());\n        assertEquals(1, pageInfo.getPrePage());\n        assertEquals(0, pageInfo.getNextPage()); // 没有下一页\n    }\n}</code></pre>\n<p>为了能够正确地运行上面的程序，还需要在 <code>application.properties</code> 文件中增加如下的一些配置：</p>\n<pre class=\"code-rows\"><code>pagehelper.offsetAsPageNum=true\npagehelper.rowBoundsWithCount=true\npagehelper.supportMethodsArguments=true</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>一站式的 MyBatis Plus</strong></p>\n<p>如果觉得又是生成器又是插件，写个东西要好几个工具配合特别麻烦，MyBatis 社区里也有一站式工具提供给大家。以国人开发的 MyBatis Plus 为例，它在 MyBatis 的基础上又增加了一些额外的功能，原生功能可以和扩展功能一起使用，例如：</p>\n<ul>\n<li>提供支持通用增删改查功能的 <code>Mapper</code>；</li>\n<li>内置代码生成器；</li>\n<li>内置分页插件；</li>\n<li>支持 ActiveRecord<span class=\"comment-number\">20</span> 形式的操作。</li>\n</ul>\n<p>在 MyBatis Plus 的帮助下，MyBatis 的开发体验可以接近于 Spring Data JPA，即只需要定义 POJO 类，再定义一个扩展了 <code>BaseMapper&lt;T&gt;</code> 的接口就能执行常规操作了，但还不能直接通过定义方法然后根据方法名进行扩展操作。</p>\n<p>MyBatis Plus 也提供了自己的 Spring Boot Starter，只需在工程的 pom.xml 中增加如下依赖，就能引入 MyBatis Plus、MyBatis 和 MyBatis Spring 的依赖。</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;\n    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;\n    &lt;version&gt;3.5.1&lt;/version&gt;\n&lt;/dependency&gt;</code></pre>\n<p>这个 Starter 中的部分类是从 MyBatis Spring Boot Starter 里复制过来的，同时稍作调整，例如将配置项的前缀调整为 <code>mybatis-plus</code>，像下面这样：</p>\n<pre class=\"code-rows\"><code>mybatis-plus.type-handlers-package=learning.spring.binarytea.support.handler\nmybatis-plus.type-aliases-package=learning.spring.binarytea.model\nmybatis-plus.configuration.map-underscore-to-camel-case=true</code></pre>\n<p>对于像 <code>MenuItem</code> 这样的简单对象，只需代码示例 7-33 中的接口就可以完成基本操作的映射。但由于我们的类名和表名不相同，所以还是需要在模型类上添加 <code>@TableName(\"t_menu\")</code> 注解来声明一下，就像代码示例 7-32<span class=\"comment-number\">21</span> 那样。</p>\n<blockquote>\n<p><strong>代码示例 7-32</strong>　<code>MenuItem</code> 类的定义</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Builder\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\n@TableName(\"t_menu\")\npublic class MenuItem {...}</code></pre>\n<p>代码示例 7-33 的接口包含了一个自定义的方法，映射关系的写法就是原生的方式。</p>\n<blockquote>\n<p><strong>代码示例 7-33</strong>　<code>MenuItemMapper</code> 接口的定义</p>\n</blockquote>\n<pre class=\"code-rows\"><code>public interface MenuItemMapper extends BaseMapper&lt;MenuItem&gt; {\n    @Select(\"select m.* from t_menu m, t_order_item i where m.id = i.item_id and i.order_id = #\")\n    List&lt;MenuItem&gt; findByOrderId(Long orderId);\n}</code></pre>\n<p>接下来，我们仍然通过一个简单的单元测试来演示 <code>MenuItemMapper</code> 的用法。具体如代码示例 7-34 所示，其中包含统计数量、根据主键查找以及全量加载的演示。</p>\n<blockquote>\n<p><strong>代码示例 7-34</strong>　基本的查询方法测试用例</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootTest\npublic class MenuItemMapperTest {\n    @Autowired\n    private MenuItemMapper menuItemMapper;\n\n    @Test\n    public void testSelect() {\n        assertEquals(2, menuItemMapper.selectCount(null));\n\n        MenuItem item = menuItemMapper.selectById(1L);\n        assertEquals(1L, item.getId());\n        assertEquals(\"Java咖啡\", item.getName());\n        assertEquals(Size.MEDIUM, item.getSize());\n        assertEquals(Money.ofMinor(CurrencyUnit.of(\"CNY\"), 1200), item.getPrice());\n\n        List&lt;MenuItem&gt; list = menuItemMapper.selectList(null);\n        assertEquals(2, list.size());\n    }\n    // 省略其他方法\n}</code></pre>\n<p>MyBatis Plus 的 <code>BaseMapper&lt;T&gt;</code> 中带有分页的查询方法，但还需要配置分页插件才能完全发挥它的功能。在 Spring Boot 的配置类中增加如下 Bean，其中的 <code>PaginationInnerInterceptor</code> 就是分页插件，在早期的版本中也可以通过配置独立的 <code>PaginationInterceptor</code> 实现相同的功能：</p>\n<pre class=\"code-rows\"><code>@Bean\npublic MybatisPlusInterceptor mybatisPlusInterceptor() {\n    MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();\n    mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());\n    return mybatisPlusInterceptor;\n}</code></pre>\n<p>对应的测试代码如代码示例 7-35 所示，其中指定了按照 <code>id</code> 升序，每页 1 条记录，查询第 1 页。</p>\n<blockquote>\n<p><strong>代码示例 7-35</strong>　分页测试代码</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Test\npublic void testPagination() {\n    Page&lt;MenuItem&gt; page = menuItemMapper.selectPage(new Page&lt;MenuItem&gt;(1, 1).addOrder(OrderItem.asc(\"id\")), null);\n    assertEquals(1, page.getCurrent());\n    assertEquals(1L, page.getRecords().get(0).getId());\n    assertEquals(1, page.getRecords().size());\n    assertEquals(2, page.getTotal());\n}</code></pre>\n</li>\n</ol>\n\n\n\n\n\n<h2 id=\"nav_point_118\">7.3　小结</h2>\n<p>数据库操作是大家日常工作中一定会遇到的操作，本章我们一同学习了流行的 Hibernate 和 MyBatis 在 Spring 项目中的用法。在介绍 Hibernate 时，除了讲解它本身如何与 Spring 结合，我们还说明了 Spring Data JPA 的 <code>Repository</code> 接口该如何使用，它那种通过方法名称就能定义操作的方式着实让人眼前一亮。在 MyBatis 的部分，也是一样的，除了其本身的用法，还介绍了几个让 MyBatis 如虎添翼的工具。</p>\n<p>下一章，我们将一起了解一些与数据操作相关的进阶内容，有与连接池相关的点，也有与缓存相关的点，非常贴近实战需要。</p>\n<blockquote>\n<p style=\"text-align: center\"><strong>二进制奶茶店项目开发小结</strong></p>\n<p>本章我们为二进制奶茶店完善了订单相关的操作，主要是定义了调茶师与订单的模型类，并添加了对应的增删改查操作。这从功能上来说并不复杂，但是在实现方式上，我们先后尝试使用了四种不同的方式，分别是 Hibernate 原生方式、Spring Data JPA Repository 接口、MyBatis 原生方式与 MyBatis Plus 扩展。</p>\n</blockquote>\n\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"第 7 章 对象关系映射(1)","id":740871},"right":{"article_title":"第 8 章 数据访问进阶(1)","id":740873}},"comments":[]}