{"id":396896,"title":"31 | 瞧一瞧Linux：如何获取所有设备信息？","content":"<p>你好，我是LMOS。</p><p>前面我们已经完成了Cosmos的驱动设备的建立，还写好了一个真实的设备驱动。</p><p>今天，我们就来看看Linux是如何管理设备的。我们将从Linux如何组织设备开始，然后研究设备驱动相关的数据结构，最后我们还是要一起写一个Linux设备驱动实例，这样才能真正理解它。</p><h2>感受一下Linux下的设备信息</h2><p>Linux的设计哲学就是一切皆文件，各种设备在Linux系统下自然也是一个个文件。不过这个文件并不对应磁盘上的数据文件，而是对应着存在内存当中的设备文件。实际上，我们对设备文件进行操作，就等同于操作具体的设备。</p><p>既然我们了解万事万物，都是从最直观的感受开始的，想要理解Linux对设备的管理，自然也是同样的道理。那么Linux设备文件在哪个目录下呢？其实现在我们在/sys/bus目录下，就可以查看所有的设备了。</p><p>Linux用BUS（总线）组织设备和驱动，我们在/sys/bus目录下输入tree命令，就可以看到所有总线下的所有设备了，如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/56/28/567588d1ca461ed56c4cd3447d9dff28.jpg?wh=990x1047\" alt=\"\" title=\"Linux设备文件\"></p><p>上图中，显示了部分Linux设备文件，有些设备文件是链接到其它目录下文件，这不是重点，重点是你要在心中有这个目录层次结构，即<strong>总线目录下有设备目录，设备目录下是设备文件</strong>。</p><!-- [[[read_end]]] --><h2>数据结构</h2><p>我们接着刚才的图往下说，我们能感觉到Linux的驱动模型至少有三个核心数据结构，分别是总线、设备和驱动，但是要像上图那样有层次化地组织它们，只有总线、设备、驱动这三个数据结构是不够的，还得有两个数据结构来组织它们，那就是kobject和kset，下面我们就去研究它们。</p><h3>kobject与kset</h3><p>kobject和kset是构成/sys目录下的目录节点和文件节点的核心，也是层次化组织总线、设备、驱动的核心数据结构，kobject、kset数据结构都能表示一个目录或者文件节点。下面我们先来研究一下kobject数据结构，代码如下所示。</p><pre><code>struct kobject {\n    const char      *name;           //名称，反映在sysfs中\n    struct list_head    entry;       //挂入kset结构的链表\n    struct kobject      *parent;     //指向父结构 \n    struct kset     *kset;           //指向所属的kset\n    struct kobj_type    *ktype;\n    struct kernfs_node  *sd;         //指向sysfs文件系统目录项 \n    struct kref     kref;            //引用计数器结构\n    unsigned int state_initialized:1;//初始化状态\n    unsigned int state_in_sysfs:1;   //是否在sysfs中\n    unsigned int state_add_uevent_sent:1;\n    unsigned int state_remove_uevent_sent:1;\n    unsigned int uevent_suppress:1;\n};\n</code></pre><p>每一个 kobject，都对应着 /sys目录下（其实是sysfs文件系统挂载在/sys目录下） 的一个目录或者文件，目录或者文件的名字就是kobject结构中的name。</p><p>我们从kobject结构中可以看出，它挂载在kset下，并且指向了kset，那kset是什么呢？我们来分析分析，它是kobject结构的容器吗？</p><p>其实是也不是，因为kset结构中本身又包含一个kobject结构，所以它既是kobject的容器，同时本身还是一个kobject。kset结构代码如下所示。</p><pre><code>struct kset {\n    struct list_head list; //挂载kobject结构的链表\n    spinlock_t list_lock; //自旋锁\n    struct kobject kobj;//自身包含一个kobject结构\n    const struct kset_uevent_ops *uevent_ops;//暂时不关注\n} __randomize_layout;\n</code></pre><p>看到这里你应该知道了，kset不仅仅自己是个kobject，还能挂载多个kobject，这说明kset是kobject的集合容器。在Linux内核中，至少有两个顶层kset，代码如下所示。</p><pre><code>struct kset *devices_kset;//管理所有设备\nstatic struct kset *bus_kset;//管理所有总线\nstatic struct kset *system_kset;\nint __init devices_init(void)\n{\n    devices_kset = kset_create_and_add(&quot;devices&quot;, &amp;device_uevent_ops, NULL);//建立设备kset\n    return 0;\n}\nint __init buses_init(void)\n{\n    bus_kset = kset_create_and_add(&quot;bus&quot;, &amp;bus_uevent_ops, NULL);//建立总线kset\n    if (!bus_kset)\n        return -ENOMEM;\n    system_kset = kset_create_and_add(&quot;system&quot;, NULL, &amp;devices_kset-&gt;kobj);//在设备kset之下建立system的kset\n    if (!system_kset)\n        return -ENOMEM;\n    return 0;\n}\n</code></pre><p>我知道，你可能很难想象许多个kset和kobject在逻辑上形成的层次结构，所以我为你画了一幅图，你可以结合这张示意图理解这个结构。</p><p><img src=\"https://static001.geekbang.org/resource/image/bc/da/bcd9216d04b1f2ec6yy67ddf18052fda.jpg?wh=5039x4605\" alt=\"\" title=\"kset与kobject\"></p><p>上图中展示了一个类似文件目录的结构，这正是kset与kobject设计的目标之一。kset与kobject结构只是基础数据结构，但是仅仅只有它的话，也就只能实现这个层次结构，其它的什么也不能干，根据我们以往的经验可以猜出，kset与kobject结构肯定是嵌入到更高级的数据结构之中使用，下面我们继续探索。</p><h3>总线</h3><p>kset、kobject结构只是开胃菜，这个基础了解了，我们还要回到研究Linux设备与驱动的正题上。我们之前说过了，Linux用总线组织设备和驱动，由此可见总线是Linux设备的基础，它可以表示CPU与设备的连接，那么总线的数据结构是什么样呢？我们一起来看看。</p><p>Linux把总线抽象成bus_type结构，代码如下所示。</p><pre><code>struct bus_type {\n    const char      *name;//总线名称\n    const char      *dev_name;//用于列举设备，如（&quot;foo%u&quot;, dev-&gt;id）\n    struct device       *dev_root;//父设备\n    const struct attribute_group **bus_groups;//总线的默认属性\n    const struct attribute_group **dev_groups;//总线上设备的默认属性\n    const struct attribute_group **drv_groups;//总线上驱动的默认属性\n    //每当有新的设备或驱动程序被添加到这个总线上时调用\n    int (*match)(struct device *dev, struct device_driver *drv);\n    //当一个设备被添加、移除或其他一些事情时被调用产生uevent来添加环境变量。\n    int (*uevent)(struct device *dev, struct kobj_uevent_env *env);\n    //当一个新的设备或驱动程序添加到这个总线时被调用，并回调特定驱动程序探查函数，以初始化匹配的设备\n    int (*probe)(struct device *dev);\n    //将设备状态同步到软件状态时调用\n    void (*sync_state)(struct device *dev);\n    //当一个设备从这个总线上删除时被调用\n    int (*remove)(struct device *dev);\n    //当系统关闭时被调用\n    void (*shutdown)(struct device *dev);\n    //调用以使设备重新上线（在下线后）\n    int (*online)(struct device *dev);\n    //调用以使设备离线，以便热移除。可能会失败。\n    int (*offline)(struct device *dev);\n    //当这个总线上的设备想进入睡眠模式时调用\n    int (*suspend)(struct device *dev, pm_message_t state);\n    //调用以使该总线上的一个设备脱离睡眠模式\n    int (*resume)(struct device *dev);\n    //调用以找出该总线上的一个设备支持多少个虚拟设备功能\n    int (*num_vf)(struct device *dev);\n    //调用以在该总线上的设备配置DMA\n    int (*dma_configure)(struct device *dev);\n    //该总线的电源管理操作，回调特定的设备驱动的pm-ops\n    const struct dev_pm_ops *pm;\n    //此总线的IOMMU具体操作，用于将IOMMU驱动程序实现到总线上\n    const struct iommu_ops *iommu_ops;\n    //驱动核心的私有数据，只有驱动核心能够接触这个\n    struct subsys_private *p;\n    struct lock_class_key lock_key;\n    //当探测或移除该总线上的一个设备时，设备驱动核心应该锁定该设备\n    bool need_parent_lock;\n};\n</code></pre><p>可以看出，上面代码的bus_type结构中，包括总线名字、总线属性，还有操作该总线下所有设备通用操作函数的指针，其各个函数的功能我在代码注释中已经写清楚了。</p><p>从这一点可以发现，<strong>总线不仅仅是组织设备和驱动的容器，还是同类设备的共有功能的抽象层。</strong>下面我们来看看subsys_private，它是总线的驱动核心的私有数据，其中有我们想知道的秘密，代码如下所示。</p><pre><code>//通过kobject找到对应的subsys_private\n#define to_subsys_private(obj) container_of(obj, struct subsys_private, subsys.kobj)\nstruct subsys_private {\n    struct kset subsys;//定义这个子系统结构的kset\n    struct kset *devices_kset;//该总线的&quot;设备&quot;目录，包含所有的设备\n    struct list_head interfaces;//总线相关接口的列表\n    struct mutex mutex;//保护设备，和接口列表\n    struct kset *drivers_kset;//该总线的&quot;驱动&quot;目录，包含所有的驱动\n    struct klist klist_devices;//挂载总线上所有设备的可迭代链表\n    struct klist klist_drivers;//挂载总线上所有驱动的可迭代链表\n    struct blocking_notifier_head bus_notifier;\n    unsigned int drivers_autoprobe:1;\n    struct bus_type *bus;   //指向所属总线\n    struct kset glue_dirs;\n    struct class *class;//指向这个结构所关联类结构的指针\n};\n</code></pre><p>看到这里，你应该明白kset的作用了，我们通过bus_kset可以找到所有的kset，通过kset又能找到subsys_private，再通过subsys_private就可以找到总线了，也可以找到该总线上所有的设备与驱动。</p><h3>设备</h3><p>虽然Linux抽象出了总线结构，但是Linux还需要表示一个设备，下面我们来探索Linux是如何表示一个设备的。</p><p>其实，在Linux系统中设备也是一个数据结构，里面包含了一个设备的所有信息。代码如下所示。</p><pre><code>struct device {\n    struct kobject kobj;\n    struct device       *parent;//指向父设备\n    struct device_private   *p;//设备的私有数据\n    const char      *init_name; //设备初始化名字\n    const struct device_type *type;//设备类型\n    struct bus_type *bus;  //指向设备所属总线\n    struct device_driver *driver;//指向设备的驱动\n    void        *platform_data;//设备平台数据\n    void        *driver_data;//设备驱动的私有数据\n    struct dev_links_info   links;//设备供应商链接\n    struct dev_pm_info  power;//用于设备的电源管理\n    struct dev_pm_domain    *pm_domain;//提供在系统暂停时执行调用\n#ifdef CONFIG_GENERIC_MSI_IRQ\n    struct list_head    msi_list;//主机的MSI描述符链表\n#endif\n    struct dev_archdata archdata;\n    struct device_node  *of_node; //用访问设备树节点\n    struct fwnode_handle    *fwnode; //设备固件节点\n    dev_t           devt;   //用于创建sysfs &quot;dev&quot;\n    u32         id; //设备实例id\n    spinlock_t      devres_lock;//设备资源链表锁\n    struct list_head    devres_head;//设备资源链表\n    struct class        *class;//设备的类\n    const struct attribute_group **groups;  //可选的属性组\n    void    (*release)(struct device *dev);//在所有引用结束后释放设备\n    struct iommu_group  *iommu_group;//该设备属于的IOMMU组\n    struct dev_iommu    *iommu;//每个设备的通用IOMMU运行时数据\n};\n</code></pre><p>device结构很大，这里删除了我们不需要关心的内容。另外，我们看到device结构中同样包含了kobject结构，这使得设备可以加入kset和kobject组建的层次结构中。device结构中有总线和驱动指针，这能帮助设备找到自己的驱动程序和总线。</p><h3>驱动</h3><p>有了设备结构，还需要有设备对应的驱动，Linux是如何表示一个驱动的呢？同样也是一个数据结构，其中包含了驱动程序的相关信息。其实在device结构中我们就看到了，就是device_driver结构，代码如下。</p><pre><code>struct device_driver {\n    const char      *name;//驱动名称\n    struct bus_type     *bus;//指向总线\n    struct module       *owner;//模块持有者\n    const char      *mod_name;//用于内置模块\n    bool suppress_bind_attrs;//禁用通过sysfs的绑定/解绑\n    enum probe_type probe_type;//要使用的探查类型（同步或异步）\n    const struct of_device_id   *of_match_table;//开放固件表\n    const struct acpi_device_id *acpi_match_table;//ACPI匹配表\n    //被调用来查询一个特定设备的存在\n    int (*probe) (struct device *dev);\n    //将设备状态同步到软件状态时调用\n    void (*sync_state)(struct device *dev);\n    //当设备被从系统中移除时被调用，以便解除设备与该驱动的绑定\n    int (*remove) (struct device *dev);\n    //关机时调用，使设备停止\n    void (*shutdown) (struct device *dev);\n    //调用以使设备进入睡眠模式，通常是进入一个低功率状态\n    int (*suspend) (struct device *dev, pm_message_t state);\n    //调用以使设备从睡眠模式中恢复\n    int (*resume) (struct device *dev);\n    //默认属性\n    const struct attribute_group **groups;\n    //绑定设备的属性\n    const struct attribute_group **dev_groups;\n    //设备电源操作\n    const struct dev_pm_ops *pm;\n    //当sysfs目录被写入时被调用\n    void (*coredump) (struct device *dev);\n    //驱动程序私有数据\n    struct driver_private *p;\n};\nstruct driver_private {\n    struct kobject kobj;\n    struct klist klist_devices;//驱动管理的所有设备的链表\n    struct klist_node knode_bus;//加入bus链表的节点\n    struct module_kobject *mkobj;//指向用kobject管理模块节点\n    struct device_driver *driver;//指向驱动本身\n};\n</code></pre><p>在device_driver结构中，包含了驱动程序的名字、驱动程序所在模块、设备探查和电源相关的回调函数的指针。在driver_private结构中同样包含了kobject结构，用于组织所有的驱动，还指向了驱动本身，你发现没有，bus_type中的subsys_private结构的机制如出一辙。</p><h3>文件操作函数</h3><p>前面我们学习的都是Linux驱动程序的核心数据结构，我们很少用到，只是为了让你了解最基础的原理。</p><p>其实，在Linux系统中提供了更为高级的封装，Linux将设备分成几类分别是：字符设备、块设备、网络设备以及杂项设备。具体情况你可以参考我后面梳理的图表。</p><p><img src=\"https://static001.geekbang.org/resource/image/a4/79/a4104a41c67d94f6c9a7de94a05c6a79.jpg?wh=1554x683\" alt=\"\" title=\"设备类型一览表\"></p><p>这些类型的设备的数据结构，都会直接或者间接包含基础的device结构，我们以杂项设备为例子研究一下，Linux用miscdevice结构表示一个杂项设备，代码如下。</p><pre><code>struct miscdevice  {\n    int minor;//设备号\n    const char *name;//设备名称\n    const struct file_operations *fops;//文件操作函数结构\n    struct list_head list;//链表\n    struct device *parent;//指向父设备的device结构\n    struct device *this_device;//指向本设备的device结构\n    const struct attribute_group **groups;\n    const char *nodename;//节点名字\n    umode_t mode;//访问权限\n};\n</code></pre><p>miscdevice结构就是一个杂项设备，它一般在驱动程序代码文件中静态定义。我们清楚地看见有个this_device指针，它指向下层的、属于这个杂项设备的device结构。</p><p>但是这里重点是<strong>file_operations结构</strong>，设备一经注册，就会在sys相关的目录下建立设备对应的文件结点，对这个文件结点打开、读写等操作，最终会调用到驱动程序对应的函数，而对应的函数指针就保存在file_operations结构中，我们现在来看看这个结构。</p><pre><code>struct file_operations {\n    struct module *owner;//所在的模块\n    loff_t (*llseek) (struct file *, loff_t, int);//调整读写偏移\n    ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);//读\n    ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);//写\n    int (*mmap) (struct file *, struct vm_area_struct *);//映射\n    int (*open) (struct inode *, struct file *);//打开\n    int (*flush) (struct file *, fl_owner_t id);//刷新\n    int (*release) (struct inode *, struct file *);//关闭\n} __randomize_layout;\n</code></pre><p>file_operations结构中的函数指针有31个，我删除了我们不熟悉的函数指针，我们了解原理，不需要搞清楚所有函数指针的功能。</p><p>那么，Linux如何调用到这个file_operations结构中的函数呢？我以打开操作为例给你讲讲，Linux的打开系统调用接口会调用filp_open函数，filp_open函数的调用路径如下所示。</p><pre><code>//filp_open\n//file_open_name\n//do_filp_open\n//path_openat\nstatic int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)\n{\n    struct path path;\n    int error = path_lookupat(nd, flags, &amp;path);//解析文件路径得到文件inode节点\n    if (!error) {\n        audit_inode(nd-&gt;name, path.dentry, 0);\n        error = vfs_open(&amp;path, file);//vfs层打开文件接口\n        path_put(&amp;path);\n    }\n    return error;\n}\nint vfs_open(const struct path *path, struct file *file)\n{\n    file-&gt;f_path = *path;\n    return do_dentry_open(file, d_backing_inode(path-&gt;dentry), NULL);\n}\nstatic int do_dentry_open(struct file *f, struct inode *inode,int (*open)(struct inode *, struct file *))\n{\n    //略过我们不想看的代码\n    f-&gt;f_op = fops_get(inode-&gt;i_fop);//获取文件节点的file_operations\n    if (!open)//如果open为空则调用file_operations结构中的open函数\n        open = f-&gt;f_op-&gt;open;\n    if (open) {\n        error = open(inode, f);\n    }\n    //略过我们不想看的代码\n    return 0;\n}\n</code></pre><p>看到这里，我们就知道了，file_operations结构的地址存在一个文件的inode结构中。在Linux系统中，都是用inode结构表示一个文件，不管它是数据文件还是设备文件。</p><p>到这里，我们已经清楚了文件操作函数以及它的调用流程。</p><h2>驱动程序实例</h2><p>我们想要真正理解Linux设备驱动，最好的方案就是写一个真实的驱动程序实例。下面我们一起应用前面的基础，结合Linux提供的驱动程序开发接口，一起实现一个真实驱动程序。</p><p>这个驱动程序的主要工作，就是获取所有总线和其下所有设备的名字。为此我们需要先了解驱动程序的整体框架，接着建立我们总线和设备，然后实现驱动程序的打开、关闭，读写操作函数，最后我们写个应用程序，来测试我们的驱动程序。</p><h3>驱动程序框架</h3><p>Linux内核的驱动程序是在一个可加载的内核模块中实现，可加载的内核模块只需要两个函数和模块信息就行，但是我们要在模块中实现总线和设备驱动，所以需要更多的函数和数据结构，它们的代码如下。</p><pre><code>#define DEV_NAME  &quot;devicesinfo&quot;\n#define BUS_DEV_NAME  &quot;devicesinfobus&quot;\n\nstatic int misc_find_match(struct device *dev, void *data)\n{\n    printk(KERN_EMERG &quot;device name is:%s\\n&quot;, dev-&gt;kobj.name);\n    return 0;\n}\n//对应于设备文件的读操作函数\nstatic ssize_t misc_read (struct file *pfile, char __user *buff, size_t size, loff_t *off)\n{\n    printk(KERN_EMERG &quot;line:%d,%s is call\\n&quot;,__LINE__,__FUNCTION__);\n    return 0;\n}\n//对应于设备文件的写操作函数\nstatic ssize_t misc_write(struct file *pfile, const char __user *buff, size_t size, loff_t *off)\n{\n    printk(KERN_EMERG &quot;line:%d,%s is call\\n&quot;,__LINE__,__FUNCTION__);    \n    return 0;\n}\n//对应于设备文件的打开操作函数\nstatic int  misc_open(struct inode *pinode, struct file *pfile)\n{\n    printk(KERN_EMERG &quot;line:%d,%s is call\\n&quot;,__LINE__,__FUNCTION__);\n    return 0;\n} \n//对应于设备文件的关闭操作函数\nstatic int misc_release(struct inode *pinode, struct file *pfile)\n{\n    printk(KERN_EMERG &quot;line:%d,%s is call\\n&quot;,__LINE__,__FUNCTION__);\n    return 0;\n}\n\nstatic int devicesinfo_bus_match(struct device *dev, struct device_driver *driver)\n{\n        return !strncmp(dev-&gt;kobj.name, driver-&gt;name, strlen(driver-&gt;name));\n}\n//对应于设备文件的操作函数结构\nstatic const  struct file_operations misc_fops = {\n    .read     = misc_read,\n    .write    = misc_write,\n    .release  = misc_release,\n    .open     = misc_open,\n};\n//misc设备的结构\nstatic struct miscdevice  misc_dev =  {\n    .fops  =  &amp;misc_fops,         //设备文件操作方法\n    .minor =  255,                //次设备号\n    .name  =  DEV_NAME,           //设备名/dev/下的设备节点名\n};\n//总线结构\nstruct bus_type devicesinfo_bus = {\n        .name = BUS_DEV_NAME, //总线名字\n        .match = devicesinfo_bus_match, //总线match函数指针\n};\n//内核模块入口函数\nstatic int __init miscdrv_init(void)\n{\n    printk(KERN_EMERG &quot;INIT misc\\n&quot;)；\n    return 0;\n}\n//内核模块退出函数\nstatic void  __exit miscdrv_exit(void)\n{\n    printk(KERN_EMERG &quot;EXIT,misc\\n&quot;);\n}\nmodule_init(miscdrv_init);//申明内核模块入口函数\nmodule_exit(miscdrv_exit);//申明内核模块退出函数\nMODULE_LICENSE(&quot;GPL&quot;);//模块许可\nMODULE_AUTHOR(&quot;LMOS&quot;);//模块开发者\n</code></pre><p>一个最简单的驱动程序框架的内核模块就写好了，该有的函数和数据结构都有了，那些数据结构都是静态定义的，它们的内部字段我们在前面也已经了解了。这个模块一旦加载就会执行miscdrv_init函数，卸载时就会执行miscdrv_exit函数。</p><h3>建立设备</h3><p>Linux系统也提供了很多专用接口函数，用来建立总线和设备。下面我们先来建立一个总线，然后在总线下建立一个设备。</p><p>首先来说说建立一个总线，Linux系统提供了一个bus_register函数向内核注册一个总线，相当于建立了一个总线，我们需要在miscdrv_init函数中调用它，代码如下所示。</p><pre><code>static int __init miscdrv_init(void)\n{\n    printk(KERN_EMERG &quot;INIT misc\\n&quot;);\n    busok = bus_register(&amp;devicesinfo_bus);//注册总线\n    return 0;\n}\n</code></pre><p>bus_register函数会在系统中注册一个总线，所需参数就是总线结构的地址(&amp;devicesinfo_bus)，返回非0表示注册失败。现在我们来看看，在bus_register函数中都做了些什么事情，代码如下所示。</p><pre><code>int bus_register(struct bus_type *bus)\n{\n    int retval;\n    struct subsys_private *priv;\n    //分配一个subsys_private结构\n    priv = kzalloc(sizeof(struct subsys_private), GFP_KERNEL);\n    //bus_type和subsys_private结构互相指向\n    priv-&gt;bus = bus;\n    bus-&gt;p = priv;\n    //把总线的名称加入subsys_private的kobject中\n    retval = kobject_set_name(&amp;priv-&gt;subsys.kobj, &quot;%s&quot;, bus-&gt;name);\n    priv-&gt;subsys.kobj.kset = bus_kset;//指向bus_kset\n    //把subsys_private中的kset注册到系统中\n    retval = kset_register(&amp;priv-&gt;subsys);\n    //建立总线的文件结构在sysfs中\n    retval = bus_create_file(bus, &amp;bus_attr_uevent);\n    //建立subsys_private中的devices和drivers的kset\n    priv-&gt;devices_kset = kset_create_and_add(&quot;devices&quot;, NULL,\n                         &amp;priv-&gt;subsys.kobj);\n    priv-&gt;drivers_kset = kset_create_and_add(&quot;drivers&quot;, NULL,\n                         &amp;priv-&gt;subsys.kobj);\n    //建立subsys_private中的devices和drivers链表，用于属于总线的设备和驱动\n    klist_init(&amp;priv-&gt;klist_devices, klist_devices_get, klist_devices_put);\n    klist_init(&amp;priv-&gt;klist_drivers, NULL, NULL);\n    return 0;\n}\n</code></pre><p>我删除了很多你不用关注的代码，看到这里，你应该知道总线是怎么通过subsys_private把设备和驱动关联起来的（通过bus_type和subsys_private结构互相指向），下面我们看看怎么建立设备。我们这里建立一个misc杂项设备。misc杂项设备需要定一个数据结构，然后调用misc杂项设备注册接口函数，代码如下。</p><pre><code>#define DEV_NAME  &quot;devicesinfo&quot;\nstatic const  struct file_operations misc_fops = {\n    .read     = misc_read,\n    .write    = misc_write,\n    .release  = misc_release,\n    .open     = misc_open,\n};\nstatic struct miscdevice  misc_dev =  {\n    .fops  =  &amp;misc_fops,         //设备文件操作方法\n    .minor =  255,                //次设备号\n    .name  =  DEV_NAME,           //设备名/dev/下的设备节点名\n};\nstatic int __init miscdrv_init(void)\n{\n    misc_register(&amp;misc_dev);//注册misc杂项设备\n    printk(KERN_EMERG &quot;INIT misc busok\\n&quot;);\n    busok = bus_register(&amp;devicesinfo_bus);//注册总线\n    return 0;\n}\n</code></pre><p>上面的代码中，静态定义了miscdevice结构的变量misc_dev，miscdevice结构我们在前面已经了解过了，最后调用misc_register函数注册了misc杂项设备。</p><p>misc_register函数到底做了什么，我们一起来看看，代码如下所示。</p><pre><code>int misc_register(struct miscdevice *misc)\n{\n    dev_t dev;\n    int err = 0;\n    bool is_dynamic = (misc-&gt;minor == MISC_DYNAMIC_MINOR);\n    INIT_LIST_HEAD(&amp;misc-&gt;list);\n    mutex_lock(&amp;misc_mtx);\n    if (is_dynamic) {//minor次设备号如果等于255就自动分配次设备\n        int i = find_first_zero_bit(misc_minors, DYNAMIC_MINORS);\n        if (i &gt;= DYNAMIC_MINORS) {\n            err = -EBUSY;\n            goto out;\n        }\n        misc-&gt;minor = DYNAMIC_MINORS - i - 1;\n        set_bit(i, misc_minors);\n    } else {//否则检查次设备号是否已经被占有\n        struct miscdevice *c;\n        list_for_each_entry(c, &amp;misc_list, list) {\n            if (c-&gt;minor == misc-&gt;minor) {\n                err = -EBUSY;\n                goto out;\n            }\n        }\n    }\n    dev = MKDEV(MISC_MAJOR, misc-&gt;minor);//合并主、次设备号\n    //建立设备\n    misc-&gt;this_device =\n        device_create_with_groups(misc_class, misc-&gt;parent, dev,\n                      misc, misc-&gt;groups, &quot;%s&quot;, misc-&gt;name);\n    //把这个misc加入到全局misc_list链表\n    list_add(&amp;misc-&gt;list, &amp;misc_list);\n out:\n    mutex_unlock(&amp;misc_mtx);\n    return err;\n}\n</code></pre><p>可以看出，misc_register函数只是负责分配设备号，以及把miscdev加入链表，真正的核心工作由device_create_with_groups函数来完成，代码如下所示。</p><pre><code>struct device *device_create_with_groups(struct class *class,\n                     struct device *parent, dev_t devt,void *drvdata,const struct attribute_group **groups,const char *fmt, ...)\n{\n    va_list vargs;\n    struct device *dev;\n    va_start(vargs, fmt);\n    dev = device_create_groups_vargs(class, parent, devt, drvdata, groups,fmt, vargs);\n    va_end(vargs);\n    return dev;\n}\nstruct device *device_create_groups_vargs(struct class *class, struct device *parent, dev_t devt, void *drvdata,const struct attribute_group **groups,const char *fmt, va_list args)\n{\n    struct device *dev = NULL;\n    int retval = -ENODEV;\n    dev = kzalloc(sizeof(*dev), GFP_KERNEL);//分配设备结构的内存空间\n    device_initialize(dev);//初始化设备结构\n    dev-&gt;devt = devt;//设置设备号\n    dev-&gt;class = class;//设置设备类\n    dev-&gt;parent = parent;//设置设备的父设备\n    dev-&gt;groups = groups;////设置设备属性\n    dev-&gt;release = device_create_release;\n    dev_set_drvdata(dev, drvdata);//设置miscdev的地址到设备结构中\n    retval = kobject_set_name_vargs(&amp;dev-&gt;kobj, fmt, args);//把名称设置到设备的kobjext中去\n    retval = device_add(dev);//把设备加入到系统中\n    if (retval)\n        goto error;\n    return dev;//返回设备\nerror:\n    put_device(dev);\n    return ERR_PTR(retval);\n}\n</code></pre><p>到这里，misc设备的注册就搞清楚了，下面我们来测试一下看看结果，看看Linux系统是不是多了一个总线和设备。</p><p>你可以在本课程的代码目录中，执行make指令，就会产生一个miscdvrv.ko内核模块文件，我们把这个模块文件加载到Linux系统中就行了。</p><p>为了看到效果，我们还必须要做另一件事情。 在终端中用sudo cat /proc/kmsg 指令读取/proc/kmsg文件，该文件是内核prink函数输出信息的文件。指令如下所示。</p><pre><code>#第一步在终端中执行如下指令\nsudo cat /proc/kmsg\n#第二步在另一个终端中执行如下指令\nmake\nsudo insmod miscdrv.ko\n#不用这个模块了可以用以下指令卸载\nsudo rmmod miscdrv.ko\n</code></pre><p>insmod指令是加载一个内核模块，一旦加载成功就会执行miscdrv_init函数。如果不出意外，你在终端中会看到如下图所示的情况。</p><p><img src=\"https://static001.geekbang.org/resource/image/93/3b/93a929ea1218c7f934713fbf03ba643b.jpg?wh=846x449\" alt=\"\" title=\"驱动测试\"></p><p>这说明我们设备已经建立了，你应该可以在/dev目录看到一个devicesinfo文件，同时你在/sys/bus/目录下也可以看到一个devicesinfobus文件。这就是我们建立的设备和总线的文件节点的名称。</p><h3>打开、关闭、读写函数</h3><p>建立了设备和总线，有了设备文件节点，应用程序就可以打开、关闭以及读写这个设备文件了。</p><p>虽然现在确实可以操作设备文件了，只不过还不能完成任何实际功能，因为我们只是写好了框架函数，所以我们下面就去写好并填充这些框架函数，代码如下所示。</p><pre><code>//打开\nstatic int  misc_open(struct inode *pinode, struct file *pfile)\n{\n    printk(KERN_EMERG &quot;line:%d,%s is call\\n&quot;,__LINE__,__FUNCTION__);//打印这个函数所在文件的行号和名称\n    return 0;\n}\n//关闭 \nstatic int misc_release(struct inode *pinode, struct file *pfile)\n{\n    printk(KERN_EMERG &quot;line:%d,%s is call\\n&quot;,__LINE__,__FUNCTION__);//打印这个函数所在文件的行号和名称\n    return 0;\n}\n//写\nstatic ssize_t misc_write(struct file *pfile, const char __user *buff, size_t size, loff_t *off)\n{\n    printk(KERN_EMERG &quot;line:%d,%s is call\\n&quot;,__LINE__,__FUNCTION__);//打印这个函数所在文件的行号和名称    \n    return 0;\n}\n</code></pre><p>以上三个函数，仍然没干什么实际工作，就是打印该函数所在文件的行号和名称，然后返回0就完事了。回到前面，我们的目的是要获取Linux中所有总线上的所有设备，所以在读函数中来实现是合理的。</p><p>具体实现的代码如下所示。</p><pre><code>#define to_subsys_private(obj) container_of(obj, struct subsys_private, subsys.kobj)//从kobject上获取subsys_private的地址\nstruct kset *ret_buskset(void)\n{\n    struct subsys_private *p;\n    if(busok)\n        return NULL;\n    if(!devicesinfo_bus.p)\n        return NULL;\n    p = devicesinfo_bus.p;\n    if(!p-&gt;subsys.kobj.kset)\n        return NULL;\n    //返回devicesinfo_bus总线上的kset，正是bus_kset\n    return p-&gt;subsys.kobj.kset;\n}\nstatic int misc_find_match(struct device *dev, void *data)\n{\n    struct bus_type* b = (struct bus_type*)data;\n    printk(KERN_EMERG &quot;%s----&gt;device name is:%s\\n&quot;, b-&gt;name, dev-&gt;kobj.name);//打印总线名称和设备名称\n    return 0;\n}\nstatic ssize_t misc_read (struct file *pfile, char __user *buff, size_t size, loff_t *off)\n{\n    struct kobject* kobj;\n    struct kset* kset;\n    struct subsys_private* p;\n    kset = ret_buskset();//获取bus_kset的地址\n    if(!kset)\n        return 0;\n    printk(KERN_EMERG &quot;line:%d,%s is call\\n&quot;,__LINE__,__FUNCTION__);//打印这个函数所在文件的行号和名称\n    //扫描所有总线的kobject\n    list_for_each_entry(kobj, &amp;kset-&gt;list, entry)\n    {\n        p = to_subsys_private(kobj);\n        printk(KERN_EMERG &quot;Bus name is:%s\\n&quot;,p-&gt;bus-&gt;name);\n        //遍历具体总线上的所有设备\n        bus_for_each_dev(p-&gt;bus, NULL, p-&gt;bus, misc_find_match);\n    }\n    return 0;\n}\n</code></pre><p>正常情况下，我们是不能获取bus_kset地址的，它是所有总线的根，包含了所有总线的kobject，Linux为了保护bus_kset，并没有在bus_type结构中直接包含kobject，而是让总线指向一个subsys_private结构，在其中包含了kobject结构。</p><p>所以，我们要注册一个总线，这样就能拔出萝卜带出泥，得到bus_kset，根据它又能找到所有subsys_private结构中的kobject，接着找到subsys_private结构，反向查询到bus_type结构的地址。</p><p>然后调用Linux提供的bus_for_each_dev函数，就可以遍历一个总线上的所有设备，它每遍历到一个设备，就调用一个函数，这个函数是用参数的方式传给它的，在我们代码中就是misc_find_match函数。</p><p>在调用misc_find_match函数时，会把一个设备结构的地址和另一个指针作为参数传递进来。最后就能打印每个设备的名称了。</p><h3>测试驱动</h3><p>驱动程序已经写好，加载之后会自动建立设备文件，但是驱动程序不会主动工作，我们还需要写一个应用程序，对设备文件进行读写，才能测试驱动。我们这里这个驱动对打开、关闭、写操作没有什么实际的响应，但是只要一读就会打印所有设备的信息了。</p><p>下面我们来写好这个应用，代码如下所示。</p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;fcntl.h&gt;\n#define DEV_NAME &quot;/dev/devicesinfo&quot;\nint main(void)\n{\n    char buf[] = {0, 0, 0, 0};\n    int fd;\n    //打开设备文件\n    fd = open(DEV_NAME, O_RDWR);\n    if (fd &lt; 0) {\n        printf(&quot;打开 :%s 失败!\\n&quot;, DEV_NAME);\n    }\n    //写数据到内核空间\n    write(fd, buf, 4);\n    //从内核空间中读取数据\n    read(fd, buf, 4);\n    //关闭设备,也可以不调用，程序关闭时系统自动调用\n    close(fd);\n    return 0;\n}\n</code></pre><p>你可以这样操作：切换到本课程的代码目录make一下，然后加载miscdrv.ko模块，最后在终端中执行sudo ./app，就能在另一个已经执行了sudo cat /proc/kmsg的终端中，看到后面图片这样形式的数据。</p><p><img src=\"https://static001.geekbang.org/resource/image/29/1c/29e4b5f1a05d114423b3e69b796ccc1c.jpg?wh=990x1047\" alt=\"\" title=\"获取设备名称\"></p><p>上图是我系统中总线名和设备名，你的计算机上可能略有差异，因为我们的计算机硬件可能不同，所以有差异是正常的，不必奇怪。</p><h2>重点回顾</h2><p>尽管Linux驱动模型异常复杂，我们还是以最小的成本，领会了Linux驱动模型设计的要点，还动手写了个小小的驱动程序。现在我来为你梳理一下这节课的重点。</p><p>首先，我们通过查看sys目录下的文件层次结构，直观感受了一下Linux系统的总线、设备、驱动是什么情况。</p><p>然后，我们了解一些重要的数据结构，它们分别是总线、驱动、设备、文件操作函数结构，还有非常关键的<strong>kset和kobject</strong>，这两个结构一起组织了总线、设备、驱动，最终形成了类目录文件这样的层次结构。</p><p>最后，我们建立一个驱动程序实例，从驱动程序框架开始，我们了解如何建立一个总线和设备，编写了对应的文件操作函数，在读操作函数中实现扫描了所有总线上的所有设备，并打印总线名称和设备名称，还写了个应用程序进行了测试，检查有没有达到预期的功能。</p><p>如果你对Linux是怎么在总线上注册设备和驱动，又对驱动和设备怎么进行匹配感兴趣的话，也可以自己阅读Linux内核代码，其中有很多驱动实例，你可以研究和实验，动手和动脑相结合，我相信你一定可以搞清楚的。</p><h2>思考题</h2><p>为什么无论是我们加载miscdrv.ko内核模块，还是运行app测试，都要在前面加上sudo呢？</p><p>欢迎你在留言区记录你的学习收获，也欢迎你把这节课分享给你身边的小伙伴，一起拿下Linux设备驱动的内容。</p><p>我是LMOS，我们下节课见！</p>","comments":[{"had_liked":false,"id":305999,"user_name":"neohope","can_delete":false,"product_type":"c1","uid":1043475,"ip_address":"","ucode":"C0268F6E7E2B6E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","comment_is_top":true,"comment_ctime":1628264968,"is_pvip":false,"replies":[{"id":"110846","content":"老铁 可谓 学习能力爆表","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1628478391,"ip_address":"","comment_id":305999,"utype":1}],"discussion_count":1,"race_medal":0,"score":"9.223372068547799e+18","product_id":100078401,"comment_content":"<br>关于驱动程序Demo<br>一、miscdrv是一个内核模块<br>1、四个操作函数，封装在file_operations结构中，包括：<br>misc_open在打开设备文件时执行<br>misc_release在关闭设备文件时执行<br>misc_read在读取设备时执行<br>misc_write在写入设备时执行<br>file_operations又被封装在miscdevice中，在注册设备时传入<br><br>2、devicesinfo_bus_match函数用于总线设备的过滤，被封装在bus_type结构中<br>bus_type描述了总线结构，在总线注册时传入<br><br>3、module_init和module_exit声明入口和出口函数：<br>miscdrv_init注册设备和总线，在安装内核模块时执行<br>miscdrv_exit反注册设备和总线，在卸载内核模块时执行<br><br>4、只有misc_read比较复杂：<br>A、通过注册时的devicesinfo_bus获取kset，枚举kset中的每一个kobj<br>B、对于每个kobj，通过container_of转换为subsys_private<br>C、对于每个subsys_private，枚举其bus中每个设备，并通过misc_find_match函数进行处理<br>D、misc_find_match会在kmsg中输出设备名称<br><br>二、app.c<br>就是打开设备，写一下，读一下，关闭设备，主要是触发设备输出<br><br>三、执行顺序，需要两个Terminal，T1和T2<br>1、T1：make<br>2、T1：sudo insmod miscdrv.ko<br>3、T2：sudo cat &#47;proc&#47;kmsg<br>4、T1：sudo .&#47;app<br>5、T2：ctrl+c<br>6、T1：sudo rmmod miscdrv.ko","like_count":8,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524589,"discussion_content":"老铁 可谓 学习能力爆表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628478391,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":305998,"user_name":"neohope","can_delete":false,"product_type":"c1","uid":1043475,"ip_address":"","ucode":"C0268F6E7E2B6E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","comment_is_top":true,"comment_ctime":1628264522,"is_pvip":false,"replies":[{"id":"110857","content":"是的 哈哈","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1628482488,"ip_address":"","comment_id":305998,"utype":1}],"discussion_count":1,"race_medal":0,"score":"9.223372064252801e+18","product_id":100078401,"comment_content":"关于数据结构<br>一、目录组织相关结构<br>kobject结构表示sysfs一个目录或者文件节点，同时提供了引用计数或生命周期管理相关功能；<br>kset结构，可以看作一类特殊的kobject，可以作为kobject的集合；同时承担了发送用户消息的功能；<br><br>Linux通过kobject和 kset来组织sysfs下的目录结构。但两者之间关系，却并非简单的文件和目录的关系。每个kobject的父节点，需要通过parent和kset两个属性来决定：<br>A、无parent、无kset，则将在sysfs的根目录（即&#47;sys&#47;）下创建目录；<br>B、无parent、有kset，则将在kset下创建目录；并将kobj加入kset.list；<br>C、有parent、无kset，则将在parent下创建目录；<br>D、有parent、有kset，则将在parent下创建目录，并将kobj加入kset.list；<br><br>kobject和kset并不会单独被使用，而是嵌入到其他结构中发挥作用。<br><br>二、总线与设备结构<br>bus_type结构，表示一个总线，其中 subsys_private中包括了kset；<br>device结构，表示一个设备，包括驱动指针、总线指针和kobject；<br>device_driver结构，表示一个驱动，其中 driver_private包括了kobject；<br>上面说的kset和kobject的目录组织关系，起始就是存在于这些数据结构中的；<br>通过kset和kobject就可以实现总线查找、设备查找等功能；<br><br>三、初始化<br>全局kset指针devices_kset管理所有设备<br>全局kset指针bus_kset管理所有总线<br><br>初始化调用链路：<br>kernel_init-&gt;kernel_init_freeable-&gt;do_basic_setup-&gt;driver_init<br>-&gt;devices_init设备初始化<br>-&gt;buses_init总线初始化<br><br>四、设备功能函数调用<br>miscdevice结构，表示一个杂项设备；<br>其中 file_operations包含了全部功能函数指针；<br><br>以打开一个设备文件为例，其调用链路为：<br>filp_open-&gt;file_open_name-&gt;do_filp_open-&gt;path_openat-&gt;do_o_path-&gt;vfs_open-&gt;do_dentry_open<br>通过file_operations获取了open函数指针，并进行了调用","like_count":7,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524588,"discussion_content":"是的 哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628482488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345164,"user_name":"艾恩凝","can_delete":false,"product_type":"c1","uid":2950704,"ip_address":"","ucode":"F2B81BF4F0106A","user_header":"https://static001.geekbang.org/account/avatar/00/2d/06/30/c26ea06a.jpg","comment_is_top":true,"comment_ctime":1652084579,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"9.2233720385068995e+18","product_id":100078401,"comment_content":"以前作为使用者去写驱动，现在以提供者的角度去分析驱动，又来到了熟悉的file_operations结构了，写过简单的内核2.6 和 3.4版本的驱动，每个版本都稍有区别，盲猜这个是5版本的，毕竟有些陌生的函数，刚才看到了一个评论驱动是如何操作硬件的，来个最简单的按键驱动就知道了，这还没谈谈设备树，设备树也应该谈谈，到底是哪个大聪明想到的设备树","like_count":0},{"had_liked":false,"id":303186,"user_name":"青玉白露","can_delete":false,"product_type":"c1","uid":2619436,"ip_address":"","ucode":"96FE2D4D2B94A0","user_header":"https://static001.geekbang.org/account/avatar/00/27/f8/2c/92969c48.jpg","comment_is_top":false,"comment_ctime":1626657797,"is_pvip":false,"replies":[{"id":"109725","content":"是的 ","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1626660238,"ip_address":"","comment_id":303186,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23101494277","product_id":100078401,"comment_content":"在Linux系统中，sudo可以获取超级用户的权利，它之后的命令可以在内核态下进行工作。<br>而加载miscdrv.ko模块和app测试都需要在内核态下进行。","like_count":5,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523581,"discussion_content":"是的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626660238,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":303182,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1626656217,"is_pvip":false,"replies":[{"id":"109726","content":"哈哈 这问题又太简单了","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1626660263,"ip_address":"","comment_id":303182,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10216590809","product_id":100078401,"comment_content":"加载内核模块，使用内核驱动，得 sudo 权限","like_count":2,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523580,"discussion_content":"哈哈 这问题又太简单了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626660263,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":349625,"user_name":"Zhang","can_delete":false,"product_type":"c1","uid":2693267,"ip_address":"","ucode":"FDA5F929585F61","user_header":"https://static001.geekbang.org/account/avatar/00/29/18/93/a1bbda42.jpg","comment_is_top":false,"comment_ctime":1656154514,"is_pvip":false,"replies":[{"id":"127387","content":"6666，进展很快嘛，继续加油！","user_name":"编辑回复","user_name_real":"编辑","uid":"1501385","ctime":1656569370,"ip_address":"","comment_id":349625,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1656154514","product_id":100078401,"comment_content":"终于看到这了，看到曙光了感觉，打个卡，感觉今天课后作业简单了","like_count":0,"discussions":[{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578198,"discussion_content":"6666，进展很快嘛，继续加油！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656569370,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":8}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332679,"user_name":"Geek_Lawrence","can_delete":false,"product_type":"c1","uid":1578549,"ip_address":"","ucode":"B4EF5B124AF082","user_header":"","comment_is_top":false,"comment_ctime":1643462348,"is_pvip":false,"replies":[{"id":"121790","content":"那你需要了解每一种设备的编程细节 ，这通常需要熟读每一种设备的编程数据手册","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1644286858,"ip_address":"","comment_id":332679,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1643462348","product_id":100078401,"comment_content":"驱动程序仍然是“软件”部分，“软件”如何驱动“硬件”，这部分能否更细致点，想了解下驱动程序是如何连接硬件并且驱动硬件工作的，其更加底层的工作原理是什么呢？","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549878,"discussion_content":"那你需要了解每一种设备的编程细节 ，这通常需要熟读每一种设备的编程数据手册","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644286858,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":323702,"user_name":"Mingjie","can_delete":false,"product_type":"c1","uid":1356943,"ip_address":"","ucode":"0B83CD820E5F61","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLwVgXx5UCmXuUJIibytjfxlfia7XJBX6ricaVuGpAREA9fm8mK7WwKXEzictLQRIicvrIgRCGtrwfsS9g/132","comment_is_top":false,"comment_ctime":1638107807,"is_pvip":false,"replies":[{"id":"117625","content":"属于是MISC","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1638323235,"ip_address":"","comment_id":323702,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1638107807","product_id":100078401,"comment_content":"老师，HDMI驱动是属于哪类驱动设备？我觉得是块类型设备，不是有显存这个说法嘛，我想的对吗","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534950,"discussion_content":"属于是MISC","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638323235,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":309861,"user_name":"驰往","can_delete":false,"product_type":"c1","uid":2617338,"ip_address":"","ucode":"859DAB36735F00","user_header":"https://static001.geekbang.org/account/avatar/00/27/ef/fa/5e9f3dc9.jpg","comment_is_top":false,"comment_ctime":1630376240,"is_pvip":false,"replies":[{"id":"112443","content":"哈哈  程序员的三大浪漫之一","user_name":"作者回复","user_name_real":"LMOS","uid":"1345199","ctime":1630632220,"ip_address":"","comment_id":309861,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1630376240","product_id":100078401,"comment_content":"既陌生又熟悉的代码。曾几何时，大学的时候就是从platform device入手，深入学习驱动设备模型，然而由于工作环境，越工作越上层，最终没有踏入内核这片圣地。如今再学操作系统，希望能够借此机会，了却当年的初心😄。","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526043,"discussion_content":"哈哈  程序员的三大浪漫之一","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630632220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}