{"id":295850,"title":"02 | Mutex：庖丁解牛看实现","content":"<p>你好，我是鸟窝。</p><p>上一讲我们一起体验了Mutex的使用，竟是那么简单，只有简简单单两个方法，Lock和Unlock，进入临界区之前调用Lock方法，退出临界区的时候调用Unlock方法。这个时候，你一定会有一丝好奇：“它的实现是不是也很简单呢？”</p><p>其实不是的。如果你阅读Go标准库里Mutex的源代码，并且追溯Mutex的演进历史，你会发现，从一个简单易于理解的互斥锁的实现，到一个非常复杂的数据结构，这是一个逐步完善的过程。Go开发者们做了种种努力，精心设计。我自己每次看，都会被这种匠心和精益求精的精神打动。</p><p>所以，今天我就想带着你一起去探索Mutex的实现及演进之路，希望你能和我一样体验到这种技术追求的美妙。我们从Mutex的一个简单实现开始，看看它是怎样逐步提升性能和公平性的。在这个过程中，我们可以学习如何逐步设计一个完善的同步原语，并能对复杂度、性能、结构设计的权衡考量有新的认识。经过这样一个学习，我们不仅能通透掌握Mutex，更好地使用这个工具，同时，对我们自己设计并发数据接口也非常有帮助。</p><p>那具体怎么来讲呢？我把Mutex的架构演进分成了四个阶段，下面给你画了一张图来说明。</p><p>“<strong>初版</strong>”的Mutex使用一个flag来表示锁是否被持有，实现比较简单；后来照顾到新来的goroutine，所以会让新的goroutine也尽可能地先获取到锁，这是第二个阶段，我把它叫作“<strong>给新人机会</strong>”；那么，接下来就是第三阶段“<strong>多给些机会</strong>”，照顾新来的和被唤醒的goroutine；但是这样会带来饥饿问题，所以目前又加入了饥饿的解决方案，也就是第四阶段“<strong>解决饥饿</strong>”。</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/c2/35/c28531b47ff7f220d5bc3c9650180835.jpg?wh=4000*2250\" alt=\"\"></p><p>有了这四个阶段，我们学习的路径就清晰了，那接下来我会从代码层面带你领略Go开发者这些大牛们是如何逐步解决这些问题的。</p><h1>初版的互斥锁</h1><p>我们先来看怎么实现一个最简单的互斥锁。在开始之前，你可以先想一想，如果是你，你会怎么设计呢？</p><p>你可能会想到，可以通过一个flag变量，标记当前的锁是否被某个goroutine持有。如果这个flag的值是1，就代表锁已经被持有，那么，其它竞争的goroutine只能等待；如果这个flag的值是0，就可以通过CAS（compare-and-swap，或者compare-and-set）将这个flag设置为1，标识锁被当前的这个goroutine持有了。</p><p>实际上，Russ Cox在2008年提交的第一版Mutex就是这样实现的。</p><pre><code>   // CAS操作，当时还没有抽象出atomic包\n    func cas(val *int32, old, new int32) bool\n    func semacquire(*int32)\n    func semrelease(*int32)\n    // 互斥锁的结构，包含两个字段\n    type Mutex struct {\n        key  int32 // 锁是否被持有的标识\n        sema int32 // 信号量专用，用以阻塞/唤醒goroutine\n    }\n    \n    // 保证成功在val上增加delta的值\n    func xadd(val *int32, delta int32) (new int32) {\n        for {\n            v := *val\n            if cas(val, v, v+delta) {\n                return v + delta\n            }\n        }\n        panic(&quot;unreached&quot;)\n    }\n    \n    // 请求锁\n    func (m *Mutex) Lock() {\n        if xadd(&amp;m.key, 1) == 1 { //标识加1，如果等于1，成功获取到锁\n            return\n        }\n        semacquire(&amp;m.sema) // 否则阻塞等待\n    }\n    \n    func (m *Mutex) Unlock() {\n        if xadd(&amp;m.key, -1) == 0 { // 将标识减去1，如果等于0，则没有其它等待者\n            return\n        }\n        semrelease(&amp;m.sema) // 唤醒其它阻塞的goroutine\n    }    \n</code></pre><p>这里呢，我先简单补充介绍下刚刚提到的CAS。</p><p>CAS指令将<strong>给定的值</strong>和<strong>一个内存地址中的值</strong>进行比较，如果它们是同一个值，就使用新值替换内存地址中的值，这个操作是原子性的。那啥是原子性呢？如果你还不太理解这个概念，那么在这里只需要明确一点就行了，那就是<strong>原子性保证这个指令总是基于最新的值进行计算，如果同时有其它线程已经修改了这个值，那么，CAS会返回失败</strong>。</p><p>CAS是实现互斥锁和同步原语的基础，我们很有必要掌握它。</p><p>好了，我们继续来分析下刚才的这段代码。</p><p>虽然当时的Go语法和现在的稍微有些不同，而且标准库的布局、实现和现在的也有很大的差异，但是，这些差异不会影响我们对代码的理解，因为最核心的结构体（struct）和函数、方法的定义几乎是一样的。</p><p>Mutex 结构体包含两个字段：</p><ul>\n<li><strong>字段key：</strong>是一个flag，用来标识这个排外锁是否被某个goroutine所持有，如果key大于等于1，说明这个排外锁已经被持有；</li>\n<li><strong>字段sema：</strong>是个信号量变量，用来控制等待goroutine的阻塞休眠和唤醒。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/82/25/825e23e1af96e78f3773e0b45de38e25.jpg?wh=3032*2199\" alt=\"\"></p><p>调用Lock请求锁的时候，通过xadd方法进行CAS操作（第24行），xadd方法通过循环执行CAS操作直到成功，保证对key加1的操作成功完成。如果比较幸运，锁没有被别的goroutine持有，那么，Lock方法成功地将key设置为1，这个goroutine就持有了这个锁；如果锁已经被别的goroutine持有了，那么，当前的goroutine会把key加1，而且还会调用semacquire方法（第27行），使用信号量将自己休眠，等锁释放的时候，信号量会将它唤醒。</p><p>持有锁的goroutine调用Unlock释放锁时，它会将key减1（第31行）。如果当前没有其它等待这个锁的goroutine，这个方法就返回了。但是，如果还有等待此锁的其它goroutine，那么，它会调用semrelease方法（第34行），利用信号量唤醒等待锁的其它goroutine中的一个。</p><p>所以，到这里，我们就知道了，初版的Mutex利用CAS原子操作，对key这个标志量进行设置。key不仅仅标识了锁是否被goroutine所持有，还记录了当前持有和等待获取锁的goroutine的数量。</p><p>Mutex的整体设计非常简洁，学习起来一点也没有障碍。但是，注意，我要划重点了。</p><p><strong>Unlock方法可以被任意的goroutine调用释放锁，即使是没持有这个互斥锁的goroutine，也可以进行这个操作。这是因为，Mutex本身并没有包含持有这把锁的goroutine的信息，所以，Unlock也不会对此进行检查。Mutex的这个设计一直保持至今。</strong></p><p>这就带来了一个有趣而危险的功能。为什么这么说呢？</p><p>你看，其它goroutine可以强制释放锁，这是一个非常危险的操作，因为在临界区的goroutine可能不知道锁已经被释放了，还会继续执行临界区的业务操作，这可能会带来意想不到的结果，因为这个goroutine还以为自己持有锁呢，有可能导致data race问题。</p><p>所以，我们在使用Mutex的时候，必须要保证goroutine尽可能不去释放自己未持有的锁，一定要遵循“<strong>谁申请，谁释放</strong>”的原则。在真实的实践中，我们使用互斥锁的时候，很少在一个方法中单独申请锁，而在另外一个方法中单独释放锁，一般都会在同一个方法中获取锁和释放锁。</p><p>如果你接触过其它语言（比如Java语言）的互斥锁的实现，就会发现这一点和其它语言的互斥锁不同，所以，如果是从其它语言转到Go语言开发的同学，一定要注意。</p><p>以前，我们经常会基于性能的考虑，及时释放掉锁，所以在一些if-else分支中加上释放锁的代码，代码看起来很臃肿。而且，在重构的时候，也很容易因为误删或者是漏掉而出现死锁的现象。</p><pre><code>type Foo struct {\n    mu    sync.Mutex\n    count int\n}\n\nfunc (f *Foo) Bar() {\n    f.mu.Lock()\n\n    if f.count &lt; 1000 {\n        f.count += 3\n        f.mu.Unlock() // 此处释放锁\n        return\n    }\n\n    f.count++\n    f.mu.Unlock() // 此处释放锁\n    return\n}\n</code></pre><p>从1.14版本起，Go对defer做了优化，采用更有效的内联方式，取代之前的生成defer对象到defer chain中，defer对耗时的影响微乎其微了，所以基本上修改成下面简洁的写法也没问题：</p><pre><code>func (f *Foo) Bar() {\n    f.mu.Lock()\n    defer f.mu.Unlock()\n\n\n    if f.count &lt; 1000 {\n        f.count += 3\n        return\n    }\n\n\n    f.count++\n    return\n}\n</code></pre><p>这样做的好处就是Lock/Unlock总是成对紧凑出现，不会遗漏或者多调用，代码更少。</p><p>但是，如果临界区只是方法中的一部分，为了尽快释放锁，还是应该第一时间调用Unlock，而不是一直等到方法返回时才释放。</p><p>初版的Mutex实现之后，Go开发组又对Mutex做了一些微调，比如把字段类型变成了uint32类型；调用Unlock方法会做检查；使用atomic包的同步原语执行原子操作等等，这些小的改动，都不是核心功能，你简单知道就行了，我就不详细介绍了。</p><p>但是，初版的Mutex实现有一个问题：请求锁的goroutine会排队等待获取互斥锁。虽然这貌似很公平，但是从性能上来看，却不是最优的。因为如果我们能够把锁交给正在占用CPU时间片的goroutine的话，那就不需要做上下文的切换，在高并发的情况下，可能会有更好的性能。</p><p>接下来，我们就继续探索Go开发者是怎么解决这个问题的。</p><h1>给新人机会</h1><p>Go开发者在2011年6月30日的commit中对Mutex做了一次大的调整，调整后的Mutex实现如下：</p><pre><code>   type Mutex struct {\n        state int32\n        sema  uint32\n    }\n\n\n    const (\n        mutexLocked = 1 &lt;&lt; iota // mutex is locked\n        mutexWoken\n        mutexWaiterShift = iota\n    )\n</code></pre><p>虽然Mutex结构体还是包含两个字段，但是第一个字段已经改成了state，它的含义也不一样了。</p><p><img src=\"https://static001.geekbang.org/resource/image/4c/15/4c4a3dd2310059821f41af7b84925615.jpg?wh=2978*1756\" alt=\"\"></p><p>state是一个复合型的字段，一个字段包含多个意义，这样可以通过尽可能少的内存来实现互斥锁。这个字段的第一位（最小的一位）来表示这个锁是否被持有，第二位代表是否有唤醒的goroutine，剩余的位数代表的是等待此锁的goroutine数。所以，state这一个字段被分成了三部分，代表三个数据。</p><p>请求锁的方法Lock也变得复杂了。复杂之处不仅仅在于对字段state的操作难以理解，而且代码逻辑也变得相当复杂。</p><pre><code>   func (m *Mutex) Lock() {\n        // Fast path: 幸运case，能够直接获取到锁\n        if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) {\n            return\n        }\n\n        awoke := false\n        for {\n            old := m.state\n            new := old | mutexLocked // 新状态加锁\n            if old&amp;mutexLocked != 0 {\n                new = old + 1&lt;&lt;mutexWaiterShift //等待者数量加一\n            }\n            if awoke {\n                // goroutine是被唤醒的，\n                // 新状态清除唤醒标志\n                new &amp;^= mutexWoken\n            }\n            if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {//设置新状态\n                if old&amp;mutexLocked == 0 { // 锁原状态未加锁\n                    break\n                }\n                runtime.Semacquire(&amp;m.sema) // 请求信号量\n                awoke = true\n            }\n        }\n    }\n</code></pre><p>首先是通过CAS检测state字段中的标志（第3行），如果没有goroutine持有锁，也没有等待持有锁的gorutine，那么，当前的goroutine就很幸运，可以直接获得锁，这也是注释中的Fast path的意思。</p><p>如果不够幸运，state不是零值，那么就通过一个循环进行检查。接下来的第7行到第26行这段代码虽然只有几行，但是理解起来却要费一番功夫，因为涉及到对state不同标志位的操作。这里的位操作以及操作后的结果和数值比较，并没有明确的解释，有时候你需要根据后续的处理进行推断。所以说，如果你充分理解了这段代码，那么对最新版的Mutex也会比较容易掌握了，因为你已经清楚了这些位操作的含义。</p><p>我们先前知道，如果想要获取锁的goroutine没有机会获取到锁，就会进行休眠，但是在锁释放唤醒之后，它并不能像先前一样直接获取到锁，还是要和正在请求锁的goroutine进行竞争。这会给后来请求锁的goroutine一个机会，也让CPU中正在执行的goroutine有更多的机会获取到锁，在一定程度上提高了程序的性能。</p><p>for循环是不断尝试获取锁，如果获取不到，就通过runtime.Semacquire(&amp;m.sema)休眠，休眠醒来之后awoke置为true，尝试争抢锁。</p><p>代码中的第10行将当前的flag设置为加锁状态，如果能成功地通过CAS把这个新值赋予state（第19行和第20行），就代表抢夺锁的操作成功了。</p><p>不过，需要注意的是，如果成功地设置了state的值，但是之前的state是有锁的状态，那么，state只是清除mutexWoken标志或者增加一个waiter而已。</p><p>请求锁的goroutine有两类，一类是新来请求锁的goroutine，另一类是被唤醒的等待请求锁的goroutine。锁的状态也有两种：加锁和未加锁。我用一张表格，来说明一下goroutine不同来源不同状态下的处理逻辑。</p><p><img src=\"https://static001.geekbang.org/resource/image/de/ac/de281d2a9e022b2e026bb6126f28c9ac.jpg?wh=1690x620\" alt=\"\"></p><p>刚刚说的都是获取锁，接下来，我们再来看看释放锁。释放锁的Unlock方法也有些复杂，我们来看一下。</p><pre><code>   func (m *Mutex) Unlock() {\n        // Fast path: drop lock bit.\n        new := atomic.AddInt32(&amp;m.state, -mutexLocked) //去掉锁标志\n        if (new+mutexLocked)&amp;mutexLocked == 0 { //本来就没有加锁\n            panic(&quot;sync: unlock of unlocked mutex&quot;)\n        }\n    \n        old := new\n        for {\n            if old&gt;&gt;mutexWaiterShift == 0 || old&amp;(mutexLocked|mutexWoken) != 0 { // 没有等待者，或者有唤醒的waiter，或者锁原来已加锁\n                return\n            }\n            new = (old - 1&lt;&lt;mutexWaiterShift) | mutexWoken // 新状态，准备唤醒goroutine，并设置唤醒标志\n            if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {\n                runtime.Semrelease(&amp;m.sema)\n                return\n            }\n            old = m.state\n        }\n    }\n</code></pre><p>下面我来给你解释一下这个方法。</p><p>第3行是尝试将持有锁的标识设置为未加锁的状态，这是通过减1而不是将标志位置零的方式实现。第4到6行还会检测原来锁的状态是否已经未加锁的状态，如果是Unlock一个未加锁的Mutex会直接panic。</p><p>不过，即使将加锁置为未加锁的状态，这个方法也不能直接返回，还需要一些额外的操作，因为还可能有一些等待这个锁的goroutine（有时候我也把它们称之为waiter）需要通过信号量的方式唤醒它们中的一个。所以接下来的逻辑有两种情况。</p><p>第一种情况，如果没有其它的waiter，说明对这个锁的竞争的goroutine只有一个，那就可以直接返回了；如果这个时候有唤醒的goroutine，或者是又被别人加了锁，那么，无需我们操劳，其它goroutine自己干得都很好，当前的这个goroutine就可以放心返回了。</p><p>第二种情况，如果有等待者，并且没有唤醒的waiter，那就需要唤醒一个等待的waiter。在唤醒之前，需要将waiter数量减1，并且将mutexWoken标志设置上，这样，Unlock就可以返回了。</p><p>通过这样复杂的检查、判断和设置，我们就可以安全地将一把互斥锁释放了。</p><p><strong>相对于初版的设计，这次的改动主要就是，新来的goroutine也有机会先获取到锁，甚至一个goroutine可能连续获取到锁，打破了先来先得的逻辑。但是，代码复杂度也显而易见。</strong></p><p>虽然这一版的Mutex已经给新来请求锁的goroutine一些机会，让它参与竞争，没有空闲的锁或者竞争失败才加入到等待队列中。但是其实还可以进一步优化。我们接着往下看。</p><h1>多给些机会</h1><p>在2015年2月的改动中，如果新来的goroutine或者是被唤醒的goroutine首次获取不到锁，它们就会通过自旋（spin，通过循环不断尝试，spin的逻辑是在<a href=\"https://github.com/golang/go/blob/846dce9d05f19a1f53465e62a304dea21b99f910/src/runtime/proc.go#L5580\">runtime实现</a>的）的方式，尝试检查锁是否被释放。在尝试一定的自旋次数后，再执行原来的逻辑。</p><pre><code>   func (m *Mutex) Lock() {\n        // Fast path: 幸运之路，正好获取到锁\n        if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) {\n            return\n        }\n\n        awoke := false\n        iter := 0\n        for { // 不管是新来的请求锁的goroutine, 还是被唤醒的goroutine，都不断尝试请求锁\n            old := m.state // 先保存当前锁的状态\n            new := old | mutexLocked // 新状态设置加锁标志\n            if old&amp;mutexLocked != 0 { // 锁还没被释放\n                if runtime_canSpin(iter) { // 还可以自旋\n                    if !awoke &amp;&amp; old&amp;mutexWoken == 0 &amp;&amp; old&gt;&gt;mutexWaiterShift != 0 &amp;&amp;\n                        atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) {\n                        awoke = true\n                    }\n                    runtime_doSpin()\n                    iter++\n                    continue // 自旋，再次尝试请求锁\n                }\n                new = old + 1&lt;&lt;mutexWaiterShift\n            }\n            if awoke { // 唤醒状态\n                if new&amp;mutexWoken == 0 {\n                    panic(&quot;sync: inconsistent mutex state&quot;)\n                }\n                new &amp;^= mutexWoken // 新状态清除唤醒标记\n            }\n            if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {\n                if old&amp;mutexLocked == 0 { // 旧状态锁已释放，新状态成功持有了锁，直接返回\n                    break\n                }\n                runtime_Semacquire(&amp;m.sema) // 阻塞等待\n                awoke = true // 被唤醒\n                iter = 0\n            }\n        }\n    }\n</code></pre><p>这次的优化，增加了第13行到21行、第25行到第27行以及第36行。我来解释一下主要的逻辑，也就是第13行到21行。</p><p>如果可以spin的话，第9行的for循环会重新检查锁是否释放。对于临界区代码执行非常短的场景来说，这是一个非常好的优化。因为临界区的代码耗时很短，锁很快就能释放，而抢夺锁的goroutine不用通过休眠唤醒方式等待调度，直接spin几次，可能就获得了锁。</p><h1>解决饥饿</h1><p>经过几次优化，Mutex的代码越来越复杂，应对高并发争抢锁的场景也更加公平。但是你有没有想过，因为新来的goroutine也参与竞争，有可能每次都会被新来的goroutine抢到获取锁的机会，在极端情况下，等待中的goroutine可能会一直获取不到锁，这就是<strong>饥饿问题</strong>。</p><p>说到这儿，我突然想到了最近看到的一种叫做鹳的鸟。如果鹳妈妈寻找食物很艰难，找到的食物只够一个幼鸟吃的，鹳妈妈就会把食物给最强壮的一只，这样一来，饥饿弱小的幼鸟总是得不到食物吃，最后就会被啄出巢去。</p><p>先前版本的Mutex遇到的也是同样的困境，“悲惨”的goroutine总是得不到锁。</p><p>Mutex不能容忍这种事情发生。所以，2016年Go 1.9中Mutex增加了饥饿模式，让锁变得更公平，不公平的等待时间限制在1毫秒，并且修复了一个大Bug：总是把唤醒的goroutine放在等待队列的尾部，会导致更加不公平的等待时间。</p><p>之后，2018年，Go开发者将fast path和slow path拆成独立的方法，以便内联，提高性能。2019年也有一个Mutex的优化，虽然没有对Mutex做修改，但是，对于Mutex唤醒后持有锁的那个waiter，调度器可以有更高的优先级去执行，这已经是很细致的性能优化了。</p><p>为了避免代码过多，这里只列出当前的Mutex实现。想要理解当前的Mutex，我们需要好好泡一杯茶，仔细地品一品了。</p><p>当然，现在的Mutex代码已经复杂得接近不可读的状态了，而且代码也非常长，删减后占了几乎三页纸。但是，作为第一个要详细介绍的同步原语，我还是希望能更清楚地剖析Mutex的实现，向你展示它的演化和为了一个貌似很小的feature不得不将代码变得非常复杂的原因。</p><p><img src=\"https://static001.geekbang.org/resource/image/e0/76/e0c23794c8a1d355a7a183400c036276.jpg?wh=3096*1644\" alt=\"\"></p><p>当然，你也可以暂时略过这一段，以后慢慢品，<strong>只需要记住，Mutex绝不容忍一个goroutine被落下，永远没有机会获取锁。不抛弃不放弃是它的宗旨，而且它也尽可能地让等待较长的goroutine更有机会获取到锁</strong>。</p><pre><code>   type Mutex struct {\n        state int32\n        sema  uint32\n    }\n    \n    const (\n        mutexLocked = 1 &lt;&lt; iota // mutex is locked\n        mutexWoken\n        mutexStarving // 从state字段中分出一个饥饿标记\n        mutexWaiterShift = iota\n    \n        starvationThresholdNs = 1e6\n    )\n    \n    func (m *Mutex) Lock() {\n        // Fast path: 幸运之路，一下就获取到了锁\n        if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) {\n            return\n        }\n        // Slow path：缓慢之路，尝试自旋竞争或饥饿状态下饥饿goroutine竞争\n        m.lockSlow()\n    }\n    \n    func (m *Mutex) lockSlow() {\n        var waitStartTime int64\n        starving := false // 此goroutine的饥饿标记\n        awoke := false // 唤醒标记\n        iter := 0 // 自旋次数\n        old := m.state // 当前的锁的状态\n        for {\n            // 锁是非饥饿状态，锁还没被释放，尝试自旋\n            if old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) {\n                if !awoke &amp;&amp; old&amp;mutexWoken == 0 &amp;&amp; old&gt;&gt;mutexWaiterShift != 0 &amp;&amp;\n                    atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) {\n                    awoke = true\n                }\n                runtime_doSpin()\n                iter++\n                old = m.state // 再次获取锁的状态，之后会检查是否锁被释放了\n                continue\n            }\n            new := old\n            if old&amp;mutexStarving == 0 {\n                new |= mutexLocked // 非饥饿状态，加锁\n            }\n            if old&amp;(mutexLocked|mutexStarving) != 0 {\n                new += 1 &lt;&lt; mutexWaiterShift // waiter数量加1\n            }\n            if starving &amp;&amp; old&amp;mutexLocked != 0 {\n                new |= mutexStarving // 设置饥饿状态\n            }\n            if awoke {\n                if new&amp;mutexWoken == 0 {\n                    throw(&quot;sync: inconsistent mutex state&quot;)\n                }\n                new &amp;^= mutexWoken // 新状态清除唤醒标记\n            }\n            // 成功设置新状态\n            if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {\n                // 原来锁的状态已释放，并且不是饥饿状态，正常请求到了锁，返回\n                if old&amp;(mutexLocked|mutexStarving) == 0 {\n                    break // locked the mutex with CAS\n                }\n                // 处理饥饿状态\n\n                // 如果以前就在队列里面，加入到队列头\n                queueLifo := waitStartTime != 0\n                if waitStartTime == 0 {\n                    waitStartTime = runtime_nanotime()\n                }\n                // 阻塞等待\n                runtime_SemacquireMutex(&amp;m.sema, queueLifo, 1)\n                // 唤醒之后检查锁是否应该处于饥饿状态\n                starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs\n                old = m.state\n                // 如果锁已经处于饥饿状态，直接抢到锁，返回\n                if old&amp;mutexStarving != 0 {\n                    if old&amp;(mutexLocked|mutexWoken) != 0 || old&gt;&gt;mutexWaiterShift == 0 {\n                        throw(&quot;sync: inconsistent mutex state&quot;)\n                    }\n                    // 有点绕，加锁并且将waiter数减1\n                    delta := int32(mutexLocked - 1&lt;&lt;mutexWaiterShift)\n                    if !starving || old&gt;&gt;mutexWaiterShift == 1 {\n                        delta -= mutexStarving // 最后一个waiter或者已经不饥饿了，清除饥饿标记\n                    }\n                    atomic.AddInt32(&amp;m.state, delta)\n                    break\n                }\n                awoke = true\n                iter = 0\n            } else {\n                old = m.state\n            }\n        }\n    }\n    \n    func (m *Mutex) Unlock() {\n        // Fast path: drop lock bit.\n        new := atomic.AddInt32(&amp;m.state, -mutexLocked)\n        if new != 0 {\n            m.unlockSlow(new)\n        }\n    }\n    \n    func (m *Mutex) unlockSlow(new int32) {\n        if (new+mutexLocked)&amp;mutexLocked == 0 {\n            throw(&quot;sync: unlock of unlocked mutex&quot;)\n        }\n        if new&amp;mutexStarving == 0 {\n            old := new\n            for {\n                if old&gt;&gt;mutexWaiterShift == 0 || old&amp;(mutexLocked|mutexWoken|mutexStarving) != 0 {\n                    return\n                }\n                new = (old - 1&lt;&lt;mutexWaiterShift) | mutexWoken\n                if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {\n                    runtime_Semrelease(&amp;m.sema, false, 1)\n                    return\n                }\n                old = m.state\n            }\n        } else {\n            runtime_Semrelease(&amp;m.sema, true, 1)\n        }\n    }\n</code></pre><p>跟之前的实现相比，当前的Mutex最重要的变化，就是增加饥饿模式。第12行将饥饿模式的最大等待时间阈值设置成了1毫秒，这就意味着，一旦等待者等待的时间超过了这个阈值，Mutex的处理就有可能进入饥饿模式，优先让等待者先获取到锁，新来的同学主动谦让一下，给老同志一些机会。</p><p>通过加入饥饿模式，可以避免把机会全都留给新来的goroutine，保证了请求锁的goroutine获取锁的公平性，对于我们使用锁的业务代码来说，不会有业务一直等待锁不被处理。</p><p>那么，接下来的部分就是选学内容了。如果你还有精力，并且对饥饿模式很感兴趣，那就跟着我一起继续来挑战吧。如果你现在理解起来觉得有困难，也没关系，后面可以随时回来复习。</p><h2>饥饿模式和正常模式</h2><p>Mutex可能处于两种操作模式下：<strong>正常模式</strong>和<strong>饥饿模式</strong>。</p><p>接下来我们分析一下Mutex对饥饿模式和正常模式的处理。</p><p>请求锁时调用的Lock方法中一开始是fast path，这是一个幸运的场景，当前的goroutine幸运地获得了锁，没有竞争，直接返回，否则就进入了lockSlow方法。这样的设计，方便编译器对Lock方法进行内联，你也可以在程序开发中应用这个技巧。</p><p>正常模式下，waiter都是进入先入先出队列，被唤醒的waiter并不会直接持有锁，而是要和新来的goroutine进行竞争。新来的goroutine有先天的优势，它们正在CPU中运行，可能它们的数量还不少，所以，在高并发情况下，被唤醒的waiter可能比较悲剧地获取不到锁，这时，它会被插入到队列的前面。如果waiter获取不到锁的时间超过阈值1毫秒，那么，这个Mutex就进入到了饥饿模式。</p><p>在饥饿模式下，Mutex的拥有者将直接把锁交给队列最前面的waiter。新来的goroutine不会尝试获取锁，即使看起来锁没有被持有，它也不会去抢，也不会spin，它会乖乖地加入到等待队列的尾部。</p><p>如果拥有Mutex的waiter发现下面两种情况的其中之一，它就会把这个Mutex转换成正常模式:</p><ul>\n<li>此waiter已经是队列中的最后一个waiter了，没有其它的等待锁的goroutine了；</li>\n<li>此waiter的等待时间小于1毫秒。</li>\n</ul><p>正常模式拥有更好的性能，因为即使有等待抢锁的waiter，goroutine也可以连续多次获取到锁。</p><p>饥饿模式是对公平性和性能的一种平衡，它避免了某些goroutine长时间的等待锁。在饥饿模式下，优先对待的是那些一直在等待的waiter。</p><p>接下来，<strong>我们逐步分析下Mutex代码的关键行，彻底搞清楚饥饿模式的细节</strong>。</p><p>我们从请求锁（lockSlow）的逻辑看起。</p><p>第9行对state字段又分出了一位，用来标记锁是否处于饥饿状态。现在一个state的字段被划分成了阻塞等待的waiter数量、饥饿标记、唤醒标记和持有锁的标记四个部分。</p><p>第25行记录此goroutine请求锁的初始时间，第26行标记是否处于饥饿状态，第27行标记是否是唤醒的，第28行记录spin的次数。</p><p>第31行到第40行和以前的逻辑类似，只不过加了一个不能是饥饿状态的逻辑。它会对正常状态抢夺锁的goroutine尝试spin，和以前的目的一样，就是在临界区耗时很短的情况下提高性能。</p><p>第42行到第44行，非饥饿状态下抢锁。怎么抢？就是要把state的锁的那一位，置为加锁状态，后续CAS如果成功就可能获取到了锁。</p><p>第46行到第48行，如果锁已经被持有或者锁处于饥饿状态，我们最好的归宿就是等待，所以waiter的数量加1。</p><p>第49行到第51行，如果此goroutine已经处在饥饿状态，并且锁还被持有，那么，我们需要把此Mutex设置为饥饿状态。</p><p>第52行到第57行，是清除mutexWoken标记，因为不管是获得了锁还是进入休眠，我们都需要清除mutexWoken标记。</p><p>第59行就是尝试使用CAS设置state。如果成功，第61行到第63行是检查原来的锁的状态是未加锁状态，并且也不是饥饿状态的话就成功获取了锁，返回。</p><p>第67行判断是否第一次加入到waiter队列。到这里，你应该就能明白第25行为什么不对waitStartTime进行初始化了，我们需要利用它在这里进行条件判断。</p><p>第72行将此waiter加入到队列，如果是首次，加入到队尾，先进先出。如果不是首次，那么加入到队首，这样等待最久的goroutine优先能够获取到锁。此goroutine会进行休眠。</p><p>第74行判断此goroutine是否处于饥饿状态。注意，执行这一句的时候，它已经被唤醒了。</p><p>第77行到第88行是对锁处于饥饿状态下的一些处理。</p><p>第82行设置一个标志，这个标志稍后会用来加锁，而且还会将waiter数减1。</p><p>第84行，设置标志，在没有其它的waiter或者此goroutine等待还没超过1毫秒，则会将Mutex转为正常状态。</p><p>第86行则是将这个标识应用到state字段上。</p><p>释放锁（Unlock）时调用的Unlock的fast path不用多少，所以我们主要看unlockSlow方法就行。</p><p>如果Mutex处于饥饿状态，第123行直接唤醒等待队列中的waiter。</p><p>如果Mutex处于正常状态，如果没有waiter，或者已经有在处理的情况了，那么释放就好，不做额外的处理（第112行到第114行）。</p><p>否则，waiter数减1，mutexWoken标志设置上，通过CAS更新state的值（第115行到第119行）。</p><h1>总结</h1><p>“罗马不是一天建成的”，Mutex的设计也是从简单设计到复杂处理逐渐演变的。初版的Mutex设计非常简洁，充分展示了Go创始者的简单、简洁的设计哲学。但是，随着大家的使用，逐渐暴露出一些缺陷，为了弥补这些缺陷，Mutex不得不越来越复杂。</p><p>有一点值得我们学习的，同时也体现了Go创始者的哲学，就是他们强调Go语言和标准库的稳定性，新版本要向下兼容，用新的版本总能编译老的代码。Go语言从出生到现在已经10多年了，这个Mutex对外的接口却没有变化，依然向下兼容，即使现在Go出了两个版本，每个版本也会向下兼容，保持Go语言的稳定性，你也能领悟他们软件开发和设计的思想。</p><p>还有一点，你也可以观察到，为了一个程序20%的特性，你可能需要添加80%的代码，这也是程序越来越复杂的原因。所以，最开始的时候，如果能够有一个清晰而且易于扩展的设计，未来增加新特性时，也会更加方便。</p><h1>思考题</h1><p>最后，给你留两个小问题：</p><ol>\n<li>目前Mutex的state字段有几个意义，这几个意义分别是由哪些字段表示的？</li>\n<li>等待一个Mutex的goroutine数最大是多少？是否能满足现实的需求？</li>\n</ol><p>欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得有所收获，也欢迎你把今天的内容分享给你的朋友或同事。</p>","neighbors":{"left":{"article_title":"01 | Mutex：如何解决资源并发访问问题？","id":294905},"right":{"article_title":"03｜Mutex：4种易错场景大盘点","id":296541}},"comments":[{"had_liked":false,"id":253203,"user_name":"Junes","can_delete":false,"product_type":"c1","uid":1354665,"ip_address":"","ucode":"CD2E829C868970","user_header":"https://static001.geekbang.org/account/avatar/00/14/ab/a9/590d6f02.jpg","comment_is_top":false,"comment_ctime":1602648777,"is_pvip":false,"replies":[{"id":"92521","content":"赞学习态度，赞作业","user_name":"作者回复","comment_id":253203,"uid":"1066613","ip_address":"","utype":1,"ctime":1602649955,"user_name_real":"鸟窝"}],"discussion_count":7,"race_medal":0,"score":"401034607305","product_id":100061801,"comment_content":"老师讲得太棒了，我自己看Mutex源码时，没有前因后果，知识不成体系。交个作业：<br><br>1. 目前 Mutex 的 state 字段有几个意义，这几个意义分别是由哪些字段表示的？<br>和第四个阶段的讲解基本一致：前三个bit分别为mutexLocked、mutexWoken、mutexStarving，剩余bit表示mutexWaiter<br><br>2. 等待一个 Mutex 的 goroutine 数最大是多少？是否能满足现实的需求？<br>单从程序来看，可以支持 1&lt;&lt;(32-3) -1 ，约 0.5 Billion个<br>    其中32为state的类型int32，3位waiter字段的shift<br>考虑到实际goroutine初始化的空间为2K，0.5Billin*2K达到了1TB，单从内存空间来说已经要求极高了，当前的设计肯定可以满足了。","like_count":93,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507004,"discussion_content":"赞学习态度，赞作业","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602649955,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1298380,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cf/cc/8de5007b.jpg","nickname":"徐改","note":"","ucode":"82276A584AC602","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":401940,"discussion_content":"你好，我不太明白为什么1 << (32 - 3) 之后还需要再减一？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633769939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2650754,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/pEsmmPPRZictCKpQM8ZzzWSYeWPGUloGoYLP2vjRkMY0WicxZ71avFCNZiahRCn8yxibJ3t5buoNVqL7QKHVSHD5Qg/132","nickname":"Geek_a0bef1","note":"","ucode":"A2B99F30C570DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385217,"discussion_content":"老师有个问题哈，我看state的类型是uint32，应该是有符号的，所以是不是应该去掉一个符号位，所以是不是 1<<(32-1-3) - 1 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626944435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1599394,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM5FGbnvY7OJP0SWp6Wqe2odpRUpdSiaOuzAzEic08CCIDwzyp3MrB7LOWQJ3fn1gZYstQxJ4CszFJNw/132","nickname":"InfoQ_9bcd7e2833b5","note":"","ucode":"0EA8E960C5A2BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320088,"discussion_content":"为什么不用uint32？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604239328,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1508329,"avatar":"https://static001.geekbang.org/account/avatar/00/17/03/e9/6358059c.jpg","nickname":"GalaxyCreater","note":"","ucode":"C79E8A088D57CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1599394,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM5FGbnvY7OJP0SWp6Wqe2odpRUpdSiaOuzAzEic08CCIDwzyp3MrB7LOWQJ3fn1gZYstQxJ4CszFJNw/132","nickname":"InfoQ_9bcd7e2833b5","note":"","ucode":"0EA8E960C5A2BA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324357,"discussion_content":"用什么类型都可以，重点在数据保存的字节位","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605095636,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":320088,"ip_address":""},"score":324357,"extra":""},{"author":{"id":1105387,"avatar":"https://static001.geekbang.org/account/avatar/00/10/dd/eb/80f9d212.jpg","nickname":"lttzzlll","note":"","ucode":"FA160F7C02ABAA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1599394,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM5FGbnvY7OJP0SWp6Wqe2odpRUpdSiaOuzAzEic08CCIDwzyp3MrB7LOWQJ3fn1gZYstQxJ4CszFJNw/132","nickname":"InfoQ_9bcd7e2833b5","note":"","ucode":"0EA8E960C5A2BA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343496,"discussion_content":"类似于char[4]","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611063829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":320088,"ip_address":""},"score":343496,"extra":""},{"author":{"id":2628969,"avatar":"https://static001.geekbang.org/account/avatar/00/28/1d/69/c21d2644.jpg","nickname":"josephzxy","note":"","ucode":"71E8006733420D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1599394,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM5FGbnvY7OJP0SWp6Wqe2odpRUpdSiaOuzAzEic08CCIDwzyp3MrB7LOWQJ3fn1gZYstQxJ4CszFJNw/132","nickname":"InfoQ_9bcd7e2833b5","note":"","ucode":"0EA8E960C5A2BA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390641,"discussion_content":"可能也有方便检测溢出的考虑，就像rune是int32的别名而不是uint32\nhttps://stackoverflow.com/a/24714789","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629948599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":320088,"ip_address":""},"score":390641,"extra":""}]}]},{"had_liked":false,"id":253195,"user_name":"buckwheat","can_delete":false,"product_type":"c1","uid":1466067,"ip_address":"","ucode":"3FE4251F6BD2B9","user_header":"https://static001.geekbang.org/account/avatar/00/16/5e/d3/e4d2ae68.jpg","comment_is_top":false,"comment_ctime":1602646379,"is_pvip":false,"replies":[{"id":"92519","content":"Mutex和channel实现代码实现非常复杂，第一遍看不懂没关系，第二遍看不懂也没关系......,永远看不懂也不影响你使用它。你可以每次只尝试理解一个知识点。我的经验是多看几遍，每一个if分支都理解它的意思，在纸上画一画state的值的变化","user_name":"作者回复","comment_id":253195,"uid":"1066613","ip_address":"","utype":1,"ctime":1602649834,"user_name_real":"鸟窝"}],"discussion_count":1,"race_medal":1,"score":"130451665259","product_id":100061801,"comment_content":"这源码看的感觉好难啊，尤其是这种并发的源码，老师有什么好的建议吗？","like_count":31,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507000,"discussion_content":"Mutex和channel实现代码实现非常复杂，第一遍看不懂没关系，第二遍看不懂也没关系......,永远看不懂也不影响你使用它。你可以每次只尝试理解一个知识点。我的经验是多看几遍，每一个if分支都理解它的意思，在纸上画一画state的值的变化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602649834,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":256470,"user_name":"Dragon Frog","can_delete":false,"product_type":"c1","uid":1510621,"ip_address":"","ucode":"6B4A2ECFA818E2","user_header":"https://static001.geekbang.org/account/avatar/00/17/0c/dd/1b12d77d.jpg","comment_is_top":false,"comment_ctime":1603631421,"is_pvip":true,"replies":[{"id":"93366","content":"标记是否有“通过unlock唤醒”的waiter在竞争锁","user_name":"作者回复","comment_id":256470,"uid":"1066613","ip_address":"","utype":1,"ctime":1603670245,"user_name_real":"鸟窝"}],"discussion_count":1,"race_medal":0,"score":"48848271677","product_id":100061801,"comment_content":"老师，你好我有个疑问。在第二版中的 mutexWoken 这个含义到底该怎么理解。没办法很好的理解这个字段的作用","like_count":12,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508024,"discussion_content":"标记是否有“通过unlock唤醒”的waiter在竞争锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603670245,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253266,"user_name":"锋","can_delete":false,"product_type":"c1","uid":1807836,"ip_address":"","ucode":"F26BC1F14AB0D7","user_header":"https://static001.geekbang.org/account/avatar/00/1b/95/dc/07195a63.jpg","comment_is_top":false,"comment_ctime":1602666668,"is_pvip":false,"replies":[{"id":"92531","content":"是的。你可以看runtime中的实现https:&#47;&#47;github.com&#47;golang&#47;go&#47;blob&#47;0a820007e70fdd038950f28254c6269cd9588c02&#47;src&#47;runtime&#47;sema.go#L321","user_name":"作者回复","comment_id":253266,"uid":"1066613","ip_address":"","utype":1,"ctime":1602669652,"user_name_real":"鸟窝"}],"discussion_count":2,"race_medal":0,"score":"31667437740","product_id":100061801,"comment_content":"老师您好，有个疑问。<br>runtime_Semrelease 信号唤起的总队queue中的第一个吗？<br>争抢锁在非饥饿模式下，是不是只有队首的waiter和新的goroutine之间发生？<br>谢谢","like_count":7,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507025,"discussion_content":"是的。你可以看runtime中的实现https://github.com/golang/go/blob/0a820007e70fdd038950f28254c6269cd9588c02/src/runtime/sema.go#L321","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602669652,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1439947,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f8/cb/506edc3c.jpg","nickname":"可可","note":"","ucode":"DAEF22B24A6317","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334962,"discussion_content":"所以也就不会产生惊群效应了吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608036585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257261,"user_name":"圣煮","can_delete":false,"product_type":"c1","uid":1223136,"ip_address":"","ucode":"2B15CB6D4A07E0","user_header":"https://static001.geekbang.org/account/avatar/00/12/a9/e0/f226bb80.jpg","comment_is_top":false,"comment_ctime":1603897012,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"23078733492","product_id":100061801,"comment_content":"看了 5 遍, 把源码打印了一份, 终于有一些眉目了, 交作业:<br>1. 目前 Mutex 的 state 字段有几个意义，这几个意义分别是由哪些字段表示的？<br>从目前来看, state转移为二进制, 最后三位分别标记mutexLocked、mutexWoken、mutexStarving;, 剩余的为mutexWaiter, 所以 waiters 增加一个, 除去标记位值的变化外, 对应的 state值会增加 1&lt;&lt;mutexWaiterShift<br><br>2. 等待一个 Mutex 的 goroutine 数最大是多少？是否能满足现实的需求？<br>除去标记位, 可以支持1&lt;&lt;(32-3) -1个goroutine; ","like_count":5,"discussions":[{"author":{"id":2673963,"avatar":"https://static001.geekbang.org/account/avatar/00/28/cd/2b/2a640e56.jpg","nickname":"nil","note":"","ucode":"3E10F284D95475","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537099,"discussion_content":"我也是看了好几遍才有些懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638956138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319654,"user_name":"授人以🐟，不如授人以渔","can_delete":false,"product_type":"c1","uid":1193874,"ip_address":"","ucode":"BD53829E924B66","user_header":"https://static001.geekbang.org/account/avatar/00/12/37/92/961ba560.jpg","comment_is_top":false,"comment_ctime":1635903135,"is_pvip":true,"replies":[{"id":"118195","content":"一点建议<br><br>一个是多学习并发的知识，充分了解并发的复杂性和场景。<br>二是实现并发原语的时候，要便利各种可能性","user_name":"作者回复","comment_id":319654,"uid":"1066613","ip_address":"","utype":1,"ctime":1639210007,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"14520805023","product_id":100061801,"comment_content":"老师，有一个关于编程的疑惑，很难解决：我以后可能也会写一些复杂的逻辑，特别是并发的逻辑，但如何用逻辑思维去证明代码是没有问题的？比如第二版本的 Mutex 代码，就写的很好。","like_count":3,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537825,"discussion_content":"一点建议\n\n一个是多学习并发的知识，充分了解并发的复杂性和场景。\n二是实现并发原语的时候，要便利各种可能性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639210007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":256043,"user_name":"🍀柠檬鱼也是鱼","can_delete":false,"product_type":"c1","uid":2178501,"ip_address":"","ucode":"DCF033636465F3","user_header":"https://static001.geekbang.org/account/avatar/00/21/3d/c5/f43fa619.jpg","comment_is_top":false,"comment_ctime":1603511525,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14488413413","product_id":100061801,"comment_content":"感觉自己只能看看大概思路，有收获就行","like_count":3},{"had_liked":false,"id":253188,"user_name":"Gojustforfun","can_delete":false,"product_type":"c1","uid":1187021,"ip_address":"","ucode":"7513A40F27344F","user_header":"https://static001.geekbang.org/account/avatar/00/12/1c/cd/8d552516.jpg","comment_is_top":false,"comment_ctime":1602644991,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"14487546879","product_id":100061801,"comment_content":"1. 现在一个 state 的字段被划分成了阻塞等待的 waiter 数量（右移mutexWaiterShift位得到）、饥饿标记（mutexStarving）、唤醒标记（mutexWoken）和持有锁的标记（mutexLocked）四个部分<br>2. 最大2^29-1个goroutine等待mutex，约为5.37*10^8个，够用了。","like_count":3},{"had_liked":false,"id":299915,"user_name":"Leo","can_delete":false,"product_type":"c1","uid":2401541,"ip_address":"","ucode":"607F53F1B71D9D","user_header":"https://static001.geekbang.org/account/avatar/00/24/a5/05/8254e9e1.jpg","comment_is_top":false,"comment_ctime":1624903372,"is_pvip":false,"replies":[{"id":"108844","content":"👍🏻","user_name":"作者回复","comment_id":299915,"uid":"1066613","ip_address":"","utype":1,"ctime":1625098426,"user_name_real":"鸟窝"}],"discussion_count":1,"race_medal":0,"score":"10214837964","product_id":100061801,"comment_content":"看第一遍的时候真的一脸懵，所以想起了老师开篇讲的很重要的一句“先建立体系”，所以我第二遍没有去关注源码，而是去理解老师文档中对锁实现过程的描述找到大体脉络。也就是先理解思路，再去逐个追究源码的细节。所以第三遍就能很顺利理解Mutex第一个版本的实现，第二个版本因为涉及到位运算，所以需要先把go的位运算基础搞清楚再继续分析。虽然还没有完全弄懂整个Mutex的实现，但现在也收获良多，因为从源码以及老师的文档描述中包含了程序的策略，而这些策略也可以用于我们开发中解决其他问题。","like_count":2,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522584,"discussion_content":"👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625098426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":279364,"user_name":"阿牛","can_delete":false,"product_type":"c1","uid":1073236,"ip_address":"","ucode":"DC8C189FCF3289","user_header":"https://static001.geekbang.org/account/avatar/00/10/60/54/b3eb605b.jpg","comment_is_top":false,"comment_ctime":1613731121,"is_pvip":true,"replies":[{"id":"101501","content":"加油","user_name":"作者回复","comment_id":279364,"uid":"1066613","ip_address":"","utype":1,"ctime":1613743335,"user_name_real":"鸟窝"}],"discussion_count":1,"race_medal":0,"score":"10203665713","product_id":100061801,"comment_content":"交作业<br>1、目前 Mutex 的 state 字段有几个意义，这几个意义分别是由哪些字段表示的？<br>state有四个字段：<br>• mutexLocked 占1bit，持有锁标记<br>• mutexWoken  占1bit，唤醒标记<br>• mutexStarving 占1bit，饥饿标记<br>• mutexWaiters  阻塞等待的waiter数量<br>2、等待一个 Mutex 的 goroutine 数最大是多少？是否能满足现实的需求？<br>32-3=29位=2^29=536 870 912","like_count":2,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515710,"discussion_content":"加油","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613743335,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263453,"user_name":"果酱","can_delete":false,"product_type":"c1","uid":1410642,"ip_address":"","ucode":"087EF822507201","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJQyP4WVaRJVX6j5k8ZblWHo2BicmehWWSz571L8Lou2QWOSxPOg6ib0fuibfic6q6dS3ficLGNibIEo4uw/132","comment_is_top":false,"comment_ctime":1606137669,"is_pvip":false,"replies":[{"id":"95591","content":"waiter数从第4个bit开始","user_name":"作者回复","comment_id":263453,"uid":"1066613","ip_address":"","utype":1,"ctime":1606145400,"user_name_real":"鸟窝"}],"discussion_count":2,"race_medal":0,"score":"10196072261","product_id":100061801,"comment_content":"new = old + 1&lt;&lt;mutexWaiterShift.    1&lt;&lt;mutexWaiterShift这个结果是4 为啥大佬注释说的是加1啊 求解","like_count":2,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510199,"discussion_content":"waiter数从第4个bit开始","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606145400,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1073236,"avatar":"https://static001.geekbang.org/account/avatar/00/10/60/54/b3eb605b.jpg","nickname":"阿牛","note":"","ucode":"DC8C189FCF3289","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350170,"discussion_content":"mutexWaiterShift是3,加1需要偏移3位。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613731720,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253200,"user_name":"消逝文字","can_delete":false,"product_type":"c1","uid":2070541,"ip_address":"","ucode":"F6722D8AF38F52","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/vRoYUplibtKY2YFg7icP8A7SBSicAuhxz2mxgY6kibzaKRO8c1PXpNskGJB2Z3WfFoRaX5nh8oztib0NOr5qNdibCyaw/132","comment_is_top":false,"comment_ctime":1602648079,"is_pvip":false,"replies":[{"id":"92520","content":"没错，多来几遍，每次都有收获","user_name":"作者回复","comment_id":253200,"uid":"1066613","ip_address":"","utype":1,"ctime":1602649891,"user_name_real":"鸟窝"}],"discussion_count":1,"race_medal":0,"score":"10192582671","product_id":100061801,"comment_content":"底层实现的代码和业务代码果然有很大不同，理解起来也更加困难，光是上面那一堆位运算就已经够让人头疼的了，全程懵逼的看完了这一篇，还需要好好消化一下","like_count":2,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507003,"discussion_content":"没错，多来几遍，每次都有收获","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602649891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253174,"user_name":"星亦辰","can_delete":false,"product_type":"c1","uid":1284592,"ip_address":"","ucode":"B0388FBFFDEE7E","user_header":"https://static001.geekbang.org/account/avatar/00/13/99/f0/d9343049.jpg","comment_is_top":false,"comment_ctime":1602641896,"is_pvip":true,"replies":[{"id":"92508","content":"是的，这一讲需要慢慢品，以后还可以翻过来回味一下","user_name":"作者回复","comment_id":253174,"uid":"1066613","ip_address":"","utype":1,"ctime":1602644559,"user_name_real":"鸟窝"}],"discussion_count":1,"race_medal":0,"score":"10192576488","product_id":100061801,"comment_content":"这一讲有点儿烧脑了 , 需要仔细看看","like_count":2,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506994,"discussion_content":"是的，这一讲需要慢慢品，以后还可以翻过来回味一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602644559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":299732,"user_name":"Felix","can_delete":false,"product_type":"c1","uid":1317899,"ip_address":"","ucode":"9318688F3C5419","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJAWUhO0xSjD6wbGScY5WOujAE94vNYWlWmsVdibb0IWbXzSSNXJHp0lqfWVq8ZicKBsEY1EuAWArew/132","comment_is_top":false,"comment_ctime":1624839214,"is_pvip":true,"replies":[{"id":"108846","content":"对，所有的goroutine看到的都是一样的","user_name":"作者回复","comment_id":299732,"uid":"1066613","ip_address":"","utype":1,"ctime":1625098508,"user_name_real":"鸟窝"}],"discussion_count":1,"race_medal":0,"score":"5919806510","product_id":100061801,"comment_content":"我有一件事想不明白，如果大家用的是同一个s<br>ync.Mutex,那么在每个goroutine中的sema数值不都是一样的，如果其中一个goroutine中的mutexLocked变为1,所有goroutine中mutexLocked不都是变为1吗，我的理解是mutex没有用值传递，应该指向同一块内存区域啊。","like_count":1,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522524,"discussion_content":"对，所有的goroutine看到的都是一样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625098508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":269313,"user_name":"DukeAnn","can_delete":false,"product_type":"c1","uid":1298323,"ip_address":"","ucode":"F018FF60F29844","user_header":"https://static001.geekbang.org/account/avatar/00/13/cf/93/d31d1938.jpg","comment_is_top":false,"comment_ctime":1608608304,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5903575600","product_id":100061801,"comment_content":"推荐与 http:&#47;&#47;legendtkl.com&#47;2016&#47;10&#47;23&#47;golang-mutex&#47; 一起食用","like_count":1,"discussions":[{"author":{"id":2554951,"avatar":"https://static001.geekbang.org/account/avatar/00/26/fc/47/5fb0d905.jpg","nickname":"张健华","note":"","ucode":"577452129C885A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392890,"discussion_content":"这个可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631169995,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":254740,"user_name":"愚者","can_delete":false,"product_type":"c1","uid":1255037,"ip_address":"","ucode":"83ACD91BA29789","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/7d/94a476ee.jpg","comment_is_top":false,"comment_ctime":1603178859,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5898146155","product_id":100061801,"comment_content":"if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {<br>\t\t\truntime.Semrelease(&amp;m.sema) &#47;&#47; 唤醒<br>\t\t\treturn<br>}<br><br> 如果m.state 没赋上值，说明在执行unlock 期间又有新的goroutine争抢锁，因为上面的代码中有去掉锁标志的操作， 该goroutine能顺利的抢到锁。在下次循环中直接return 就好，想问下这么理解对不对<br>","like_count":1},{"had_liked":false,"id":254037,"user_name":"hiyanxu","can_delete":false,"product_type":"c1","uid":1221750,"ip_address":"","ucode":"FA46A318154812","user_header":"https://static001.geekbang.org/account/avatar/00/12/a4/76/585dc6b3.jpg","comment_is_top":false,"comment_ctime":1603025407,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5897992703","product_id":100061801,"comment_content":"这个位运算真的好复杂啊，代码到是简洁，逻辑真的好复杂","like_count":1},{"had_liked":false,"id":253683,"user_name":"( ･᷄ὢ･᷅ )","can_delete":false,"product_type":"c1","uid":2234129,"ip_address":"","ucode":"E5F5EDEBB74C46","user_header":"https://static001.geekbang.org/account/avatar/00/22/17/11/a63acc6a.jpg","comment_is_top":false,"comment_ctime":1602831250,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5897798546","product_id":100061801,"comment_content":"打卡 课后题：1：4个：mutexLocked代表是否被锁上 mutexWoken代表唤醒标记 mutexStarving代表是否处于饥饿 mutexWaiterShift 代表有多少go程在等待这个锁<br>2：int32  2^(32-3)-1  大约这么多 满足得了需求，每个go程2k 2k*2^29-1=1073741822k ≈ 1048575M≈1024G 我不信哪的内存能打到1T","like_count":1},{"had_liked":false,"id":253270,"user_name":"小龙虾","can_delete":false,"product_type":"c1","uid":1141385,"ip_address":"","ucode":"A6DFC7DD17E297","user_header":"https://static001.geekbang.org/account/avatar/00/11/6a/89/3cac9f83.jpg","comment_is_top":false,"comment_ctime":1602667471,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5897634767","product_id":100061801,"comment_content":"打卡","like_count":1},{"had_liked":false,"id":253213,"user_name":"那时刻","can_delete":false,"product_type":"c1","uid":1150927,"ip_address":"","ucode":"B0D150856C3A4A","user_header":"https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg","comment_is_top":false,"comment_ctime":1602651998,"is_pvip":false,"replies":[{"id":"92522","content":"应该说1.14中才采用了内敛的方式，官方专门有文档介绍这个，国内也有一些介绍，比如https:&#47;&#47;pengrl.com&#47;p&#47;20023&#47;?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io","user_name":"作者回复","comment_id":253213,"uid":"1066613","ip_address":"","utype":1,"ctime":1602659373,"user_name_real":"鸟窝"}],"discussion_count":1,"race_medal":1,"score":"5897619294","product_id":100061801,"comment_content":"老师对于mutex讲的很仔细，之前看过mutex源码，有些地方看的不是明白，看了老师的讲解后，清晰了很多。<br><br>请问老师一个问题，从 1.14 版本起，Go 对 defer 做了优化，采用更有效的内联方式，这种内联方式和lock里slowlock内联方式一样么？<br><br>另外，go里的内联和C++内联有什么区别吗？","like_count":1,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507007,"discussion_content":"应该说1.14中才采用了内敛的方式，官方专门有文档介绍这个，国内也有一些介绍，比如https://pengrl.com/p/20023/?hmsr=toutiao.io&amp;amp;utm_medium=toutiao.io&amp;amp;utm_source=toutiao.io","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602659373,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253129,"user_name":"橙子888","can_delete":false,"product_type":"c1","uid":1447790,"ip_address":"","ucode":"8FB8A9AAE526E3","user_header":"https://static001.geekbang.org/account/avatar/00/16/17/6e/76b4aa3d.jpg","comment_is_top":false,"comment_ctime":1602605669,"is_pvip":false,"replies":[{"id":"92484","content":"你第三讲打卡了，加油","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1602635367,"ip_address":"","comment_id":253129,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5897572965","product_id":100061801,"comment_content":"熬夜学习01课时后发现02课时也出来了，先来抢个沙发。","like_count":1,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506981,"discussion_content":"你第三讲打卡了，加油","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602635367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":357139,"user_name":"无笔秀才","can_delete":false,"product_type":"c1","uid":1123152,"ip_address":"北京","ucode":"DCFA10866A8E5B","user_header":"https://static001.geekbang.org/account/avatar/00/11/23/50/1f5154fe.jpg","comment_is_top":false,"comment_ctime":1662988302,"is_pvip":true,"discussion_count":0,"race_medal":3,"score":"1662988302","product_id":100061801,"comment_content":"老师，semacquire1 这个函数的逻辑 能具体讲讲吗？","like_count":0},{"had_liked":false,"id":356605,"user_name":"Eden","can_delete":false,"product_type":"c1","uid":1910698,"ip_address":"四川","ucode":"1A03D9F9D5A17A","user_header":"https://static001.geekbang.org/account/avatar/00/1d/27/aa/5e65bd19.jpg","comment_is_top":false,"comment_ctime":1662448150,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1662448150","product_id":100061801,"comment_content":"推荐一个今天无意之中看到的博客，个人觉得讲解的非常详细https:&#47;&#47;boilingfrog.github.io&#47;2021&#47;03&#47;14&#47;sync.Mutex&#47;","like_count":0},{"had_liked":false,"id":354413,"user_name":"菠萝吹雪—Code","can_delete":false,"product_type":"c1","uid":1650378,"ip_address":"河南","ucode":"A5B2FC661EE17D","user_header":"https://static001.geekbang.org/account/avatar/00/19/2e/ca/469f7266.jpg","comment_is_top":false,"comment_ctime":1660376548,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1660376548","product_id":100061801,"comment_content":"没完全理解，先过一遍，后面再刷","like_count":0},{"had_liked":false,"id":351651,"user_name":"echo","can_delete":false,"product_type":"c1","uid":2794917,"ip_address":"","ucode":"50D1D6B0ECD803","user_header":"https://static001.geekbang.org/account/avatar/00/2a/a5/a5/ad715d22.jpg","comment_is_top":false,"comment_ctime":1658051293,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658051293","product_id":100061801,"comment_content":"再次打卡第二节","like_count":0},{"had_liked":false,"id":347275,"user_name":"鲁迅原名周树人","can_delete":false,"product_type":"c1","uid":2337877,"ip_address":"","ucode":"45D5F91AB0F5BB","user_header":"https://static001.geekbang.org/account/avatar/00/23/ac/55/80dc6b48.jpg","comment_is_top":false,"comment_ctime":1653893909,"is_pvip":false,"replies":[{"id":"126754","content":"unlock的时候会设置它，标记有唤醒的等待者。lock的时候检查这个项。可以直接获取锁或者和新来的竞争","user_name":"作者回复","user_name_real":"编辑","uid":"1066613","ctime":1654312729,"ip_address":"","comment_id":347275,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1653893909","product_id":100061801,"comment_content":"有个疑问：mutexWoken做什么用的，为什么要设置它？","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574748,"discussion_content":"unlock的时候会设置它，标记有唤醒的等待者。lock的时候检查这个项。可以直接获取锁或者和新来的竞争","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654312729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345016,"user_name":"三生","can_delete":false,"product_type":"c1","uid":1606669,"ip_address":"","ucode":"1DE1A2693A5E33","user_header":"https://static001.geekbang.org/account/avatar/00/18/84/0d/4e289b94.jpg","comment_is_top":false,"comment_ctime":1651936090,"is_pvip":false,"replies":[{"id":"126057","content":"不清楚你的问题，哪一个字段？","user_name":"作者回复","user_name_real":"编辑","uid":"1066613","ctime":1652230216,"ip_address":"","comment_id":345016,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1651936090","product_id":100061801,"comment_content":"为什么mutex从int换成了uint","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571437,"discussion_content":"不清楚你的问题，哪一个字段？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652230217,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341503,"user_name":"taro","can_delete":false,"product_type":"c1","uid":2658985,"ip_address":"","ucode":"69971AF9FE4857","user_header":"","comment_is_top":false,"comment_ctime":1649665151,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1649665151","product_id":100061801,"comment_content":" 无mutexWoken字段，会影响第二版的mutex运行的正确性吗？感觉mutexWoken就是一个优化呢","like_count":0,"discussions":[{"author":{"id":1273082,"avatar":"https://static001.geekbang.org/account/avatar/00/13/6c/fa/56e9f147.jpg","nickname":"我就是那一把火","note":"","ucode":"A62A13211409E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570271,"discussion_content":"我感觉也是这样，没看出来它的作用\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651721288,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":337498,"user_name":"7oty","can_delete":false,"product_type":"c1","uid":1434864,"ip_address":"","ucode":"6E00D586B7FF75","user_header":"","comment_is_top":false,"comment_ctime":1646871547,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646871547","product_id":100061801,"comment_content":"实现的源码都放在哪些目录下","like_count":0},{"had_liked":false,"id":334679,"user_name":"ttty","can_delete":false,"product_type":"c1","uid":2562833,"ip_address":"","ucode":"8A643F417C3EF8","user_header":"https://static001.geekbang.org/account/avatar/00/27/1b/11/1b4e53e5.jpg","comment_is_top":false,"comment_ctime":1645072907,"is_pvip":false,"replies":[{"id":"122343","content":"首先你得有一个功能完备的semaphore.<br>其实mutex内部也有一个sema管理waiter","user_name":"作者回复","user_name_real":"编辑","uid":"1066613","ctime":1645249164,"ip_address":"","comment_id":334679,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1645072907","product_id":100061801,"comment_content":"请问为什么不直接使用对信号量的PV操作实现mutex呢？为什么还要维护这个key呢？","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552042,"discussion_content":"首先你得有一个功能完备的semaphore.\n其实mutex内部也有一个sema管理waiter","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645249164,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333725,"user_name":"我就是那一把火","can_delete":false,"product_type":"c1","uid":1273082,"ip_address":"","ucode":"A62A13211409E5","user_header":"https://static001.geekbang.org/account/avatar/00/13/6c/fa/56e9f147.jpg","comment_is_top":false,"comment_ctime":1644486321,"is_pvip":false,"replies":[{"id":"121903","content":"Unlock会唤醒一个gotoutine","user_name":"作者回复","user_name_real":"编辑","uid":"1066613","ctime":1644500249,"ip_address":"","comment_id":333725,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1644486321","product_id":100061801,"comment_content":"老师您好，我有个疑问，第一个版本和第二个版本，在我看来，都是使用信号量唤醒在Lock方法中成功CAS但被阻塞住的goroutine，至于第二个版本能唤醒有CPU时间片的goroutine体现在哪里呢","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550374,"discussion_content":"Unlock会唤醒一个gotoutine","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644500249,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333358,"user_name":"xl666","can_delete":false,"product_type":"c1","uid":2046604,"ip_address":"","ucode":"CF9A8086F91053","user_header":"https://static001.geekbang.org/account/avatar/00/1f/3a/8c/fc2c3e5c.jpg","comment_is_top":false,"comment_ctime":1644309700,"is_pvip":false,"replies":[{"id":"121848","content":"不是死循环，xadd只是保证成功加1","user_name":"作者回复","user_name_real":"编辑","uid":"1066613","ctime":1644369520,"ip_address":"","comment_id":333358,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1644309700","product_id":100061801,"comment_content":"func (m *Mutex) Lock() { if xadd(&amp;m.key, 1) == 1 { &#47;&#47;标识加1，如果等于1，成功获取到锁 return } semacquire(&amp;m.sema) &#47;&#47; 否则阻塞等待 }<br>这个xadd不是死循环吗 不应该是卡在xadd(&amp;m.key, 1) == 1这块吗。  semacquire(&amp;m.sema)是不是不会走到","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550043,"discussion_content":"不是死循环，xadd只是保证成功加1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644369520,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2046604,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/3a/8c/fc2c3e5c.jpg","nickname":"xl666","note":"","ucode":"CF9A8086F91053","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":550050,"discussion_content":"文稿里代码我看着是呀老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644371166,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":550043,"ip_address":""},"score":550050,"extra":""}]}]},{"had_liked":false,"id":331609,"user_name":"i_chase","can_delete":false,"product_type":"c1","uid":1795511,"ip_address":"","ucode":"09C41C863F4EA3","user_header":"https://static001.geekbang.org/account/avatar/00/1b/65/b7/058276dc.jpg","comment_is_top":false,"comment_ctime":1642669469,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1642669469","product_id":100061801,"comment_content":"当前go routine获取的锁可以被其他go routine释放。mutex没有关注加锁的go routine是谁","like_count":0},{"had_liked":false,"id":330792,"user_name":"成长比成功更重要","can_delete":false,"product_type":"c1","uid":2049063,"ip_address":"","ucode":"090BE5A97E7A8A","user_header":"https://static001.geekbang.org/account/avatar/00/1f/44/27/71bed926.jpg","comment_is_top":false,"comment_ctime":1642164834,"is_pvip":false,"replies":[{"id":"120659","content":"加油加油","user_name":"作者回复","user_name_real":"编辑","uid":"1066613","ctime":1642223104,"ip_address":"","comment_id":330792,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1642164834","product_id":100061801,"comment_content":"第一遍听懂很懵，第二次切底明白啦，第二个问题：取决于 state 的类型，因为 int32，由于3个字节代表了状态，还有： 2^(32 – 3) – 1 等于 536870911，一个 goroutine 初始化的为 2kb，约等于 1024 GB 即 1TB，目前内存体量那么大的服务还是少有的，可以满足现在的使用。","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546196,"discussion_content":"加油加油","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642223104,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328100,"user_name":"丶","can_delete":false,"product_type":"c1","uid":2455772,"ip_address":"","ucode":"F045BF2D3F408A","user_header":"https://static001.geekbang.org/account/avatar/00/25/78/dc/bcdb3287.jpg","comment_is_top":false,"comment_ctime":1640530122,"is_pvip":false,"replies":[{"id":"119489","content":"谢谢","user_name":"作者回复","user_name_real":"编辑","uid":"1066613","ctime":1640595433,"ip_address":"","comment_id":328100,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1640530122","product_id":100061801,"comment_content":"干活满满，看的特别爽，谢谢老师","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541890,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640595433,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322463,"user_name":"8.13.3.27.30","can_delete":false,"product_type":"c1","uid":1556358,"ip_address":"","ucode":"2DE3CE3E338BAB","user_header":"https://static001.geekbang.org/account/avatar/00/17/bf/86/c0cb35f0.jpg","comment_is_top":false,"comment_ctime":1637401590,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637401590","product_id":100061801,"comment_content":"看了很多版本的解析、看到这个版本之后终于搞明白了，如果能把unlock那块为什么要循环在那做解释一下就更好了，我自己看了半天才明白","like_count":0},{"had_liked":false,"id":319502,"user_name":"授人以🐟，不如授人以渔","can_delete":false,"product_type":"c1","uid":1193874,"ip_address":"","ucode":"BD53829E924B66","user_header":"https://static001.geekbang.org/account/avatar/00/12/37/92/961ba560.jpg","comment_is_top":false,"comment_ctime":1635837928,"is_pvip":true,"replies":[{"id":"118199","content":"因为后面有atomic操作保证可见性。<br>如果有goroutine修改了，atomic操作失败，还有for循环保证重试","user_name":"作者回复","user_name_real":"编辑","uid":"1066613","ctime":1639211019,"ip_address":"","comment_id":319502,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1635837928","product_id":100061801,"comment_content":"老师，上面所有 4 个版本，为什么在 old := m.state 不加锁？能保证可见性吗？如果其他 goroutine 修改了 m.state 是否会造成影响？","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537829,"discussion_content":"因为后面有atomic操作保证可见性。\n如果有goroutine修改了，atomic操作失败，还有for循环保证重试","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639211019,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1556358,"avatar":"https://static001.geekbang.org/account/avatar/00/17/bf/86/c0cb35f0.jpg","nickname":"8.13.3.27.30","note":"","ucode":"2DE3CE3E338BAB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531736,"discussion_content":"我理解不会、后面有swap判断、如果变了就拿不到锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637401300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":319456,"user_name":"Geek8956","can_delete":false,"product_type":"c1","uid":2689403,"ip_address":"","ucode":"BF7EF77F174B79","user_header":"","comment_is_top":false,"comment_ctime":1635820027,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635820027","product_id":100061801,"comment_content":"if old&amp;mutexStarving != 0 {                    if old&amp;(mutexLocked|mutexWoken) != 0 || old&gt;&gt;mutexWaiterShift == 0 {                        throw(&quot;sync: inconsistent mutex state&quot;)                    }                    &#47;&#47; 有点绕，加锁并且将waiter数减1                    delta := int32(mutexLocked - 1&lt;&lt;mutexWaiterShift)                    if !starving || old&gt;&gt;mutexWaiterShift == 1 {                        delta -= mutexStarving &#47;&#47; 最后一个waiter或者已经不饥饿了，清除饥饿标记                    }                    atomic.AddInt32(&amp;m.state, delta)                    break                }<br>这一段没看懂，哪位专家帮忙分析一下？谢谢","like_count":0},{"had_liked":false,"id":315157,"user_name":"1234","can_delete":false,"product_type":"c1","uid":2785837,"ip_address":"","ucode":"8AD77DB4D5E426","user_header":"https://static001.geekbang.org/account/avatar/00/2a/82/2d/5f7e75cf.jpg","comment_is_top":false,"comment_ctime":1633708371,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633708371","product_id":100061801,"comment_content":"四个含义：等待go程数，是否饥饿，是否被唤醒，是否锁🔒<br>2^（29）","like_count":0},{"had_liked":false,"id":314876,"user_name":"战斗机二虎🐯","can_delete":false,"product_type":"c1","uid":1157201,"ip_address":"","ucode":"8AB69AD2D76784","user_header":"https://static001.geekbang.org/account/avatar/00/11/a8/51/46a788b1.jpg","comment_is_top":false,"comment_ctime":1633524221,"is_pvip":false,"replies":[{"id":"114026","content":"唤醒的goroutine并不直接拿到锁","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1633568639,"ip_address":"","comment_id":314876,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1633524221","product_id":100061801,"comment_content":"第一种方式，如果unlock的时候做完cas操作，刚好有一个goroutine过来抢锁，是不是也能先于被唤醒的groutine拿到锁，这时候被唤醒的进程再继续执行，不就两个goroutine都进入临界区了？","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527825,"discussion_content":"唤醒的goroutine并不直接拿到锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633568639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1273082,"avatar":"https://static001.geekbang.org/account/avatar/00/13/6c/fa/56e9f147.jpg","nickname":"我就是那一把火","note":"","ucode":"A62A13211409E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":550326,"discussion_content":"第一版的mutex代码看上去好像只有改变了key的goroutine(也就是CAS成功的)才能被unlock方法唤醒的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644485380,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":527825,"ip_address":""},"score":550326,"extra":""}]},{"author":{"id":1157201,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a8/51/46a788b1.jpg","nickname":"战斗机二虎🐯","note":"","ucode":"8AB69AD2D76784","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":401116,"discussion_content":"第一版的代码，lock方法被唤醒后看上去是直接就返回了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633569574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311477,"user_name":"神经蛙","can_delete":false,"product_type":"c1","uid":2622182,"ip_address":"","ucode":"E5F574EAE3DAE4","user_header":"https://static001.geekbang.org/account/avatar/00/28/02/e6/a6932fd8.jpg","comment_is_top":false,"comment_ctime":1631249298,"is_pvip":false,"replies":[{"id":"118197","content":"非饥饿状态下，代码设计是新的gotoutine和唤醒的goroutine抢锁，而不是新的gotoutine优先霸占锁。","user_name":"作者回复","user_name_real":"编辑","uid":"1066613","ctime":1639210438,"ip_address":"","comment_id":311477,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1631249298","product_id":100061801,"comment_content":"队列中的groutine中，在没唤醒之前，有个新的goroutine来申请锁，此时通过自旋把woken标记挂起，同时获得到锁的那个goroutine开始解锁，因为woken标志导致没释放信号量，新的goroutine直接获取到了锁，如果一直发生这种情况，是否就无法进入饥饿模式。 作者大大请帮忙解答下。 ","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537827,"discussion_content":"非饥饿状态下，代码设计是新的gotoutine和唤醒的goroutine抢锁，而不是新的gotoutine优先霸占锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639210438,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311161,"user_name":"张健华","can_delete":false,"product_type":"c1","uid":2554951,"ip_address":"","ucode":"577452129C885A","user_header":"https://static001.geekbang.org/account/avatar/00/26/fc/47/5fb0d905.jpg","comment_is_top":false,"comment_ctime":1631091397,"is_pvip":false,"replies":[{"id":"118198","content":"它总会释放锁的，或者下一个新的goroutine标记为锁处于饥饿状态。处于饥饿状态时是会强制唤醒的。<br>如果goroutine不释放锁，那么就不是饥饿问题了，而是锁使用的问题","user_name":"作者回复","user_name_real":"编辑","uid":"1066613","ctime":1639210811,"ip_address":"","comment_id":311161,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1631091397","product_id":100061801,"comment_content":"有个疑问，在最终版本中，如果一直有新goroutine到来且自旋的执行去执行Lock()操作，此时一个goroutine执行UnLcok()时，由于有自旋的goroutine将Woken位置为1，它是否就不会执行唤醒操作了？而不唤醒goroutine，也就无法计算它等待的时间差，怎么能进入饥饿模式呢？","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537828,"discussion_content":"它总会释放锁的，或者下一个新的goroutine标记为锁处于饥饿状态。处于饥饿状态时是会强制唤醒的。\n如果goroutine不释放锁，那么就不是饥饿问题了，而是锁使用的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639210811,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2554951,"avatar":"https://static001.geekbang.org/account/avatar/00/26/fc/47/5fb0d905.jpg","nickname":"张健华","note":"","ucode":"577452129C885A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392899,"discussion_content":"其实也是有自旋的版本产生的疑问，如果每次Unlock时都有在自旋的goroutine，那么每次的Unlock就不会执行唤醒，那陷入休眠的goroutine将永远不会被唤醒？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631172003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308900,"user_name":"magina","can_delete":false,"product_type":"c1","uid":1138499,"ip_address":"","ucode":"9546701896A09F","user_header":"https://static001.geekbang.org/account/avatar/00/11/5f/43/3799a0f3.jpg","comment_is_top":false,"comment_ctime":1629856138,"is_pvip":false,"replies":[{"id":"113878","content":"go官方不建议使用gotoutine id,这个有相关的问题介绍.<br>这个课程后面介绍了自己如何实现goroutine相关的mutex","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1633054041,"ip_address":"","comment_id":308900,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1629856138","product_id":100061801,"comment_content":"针对初级版本的一个问题：为什么不能在Mutex中增加持有锁的goroutine信息? 这样Unlock不就可以检查了吗？Lock的时候如能直接lock上那么获取当前goroutine信息写入Mutex中，如果是信号量唤醒，唤醒后进行同样的操作，这样在Unlock的时候不是可以检查吗？","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525672,"discussion_content":"go官方不建议使用gotoutine id,这个有相关的问题介绍.\n这个课程后面介绍了自己如何实现goroutine相关的mutex","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633054041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307590,"user_name":"Geek_e2cf4f","can_delete":false,"product_type":"c1","uid":2617036,"ip_address":"","ucode":"269E145AEB3AB7","user_header":"","comment_is_top":false,"comment_ctime":1629167786,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1629167786","product_id":100061801,"comment_content":"我想问下第三阶段， 他是先自旋， 自旋完成之后不进入休眠直接开始下一次抢锁， 那他这个自旋是在干什么呢？ 我理解的忙等待是一直查看锁是否可抢， 可以的话马上开始抢锁， 但是这里是自旋完才开始查看锁并抢锁。","like_count":0,"discussions":[{"author":{"id":2554951,"avatar":"https://static001.geekbang.org/account/avatar/00/26/fc/47/5fb0d905.jpg","nickname":"张健华","note":"","ucode":"577452129C885A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392901,"discussion_content":"自旋就是空转cpu，它的函数实现：\nfunc sync_runtime_doSpin() {\n procyield(active_spin_cnt) // active_spin_cnt默认30\n}\nprocyield函数是汇编语言实现。函数内部循环调用PAUSE指令。PAUSE指令什么都不做，但是会消耗CPU时间，在执行PAUSE指令时，CPU不会对它做不必要的优化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631172237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":303954,"user_name":"ChuanBing จุ๊บ","can_delete":false,"product_type":"c1","uid":1628736,"ip_address":"","ucode":"4482E852FC147A","user_header":"https://static001.geekbang.org/account/avatar/00/18/da/40/bda5ad2b.jpg","comment_is_top":false,"comment_ctime":1627121105,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627121105","product_id":100061801,"comment_content":"key 记录等待锁的goroutine数量, sema等待唤醒队列,unlock时调用, 所有锁按次序获取<br>新的goroutine 和唤醒的goroutine 一起竞争锁, 因为新来的goroutine是正在使用cpu的,可以减少goroutine的切换<br>问了进一步减少goroutine切换, 新的goroutine,自旋一定次数都没有获取到锁,才加入等待队列(通过信号量)<br>为了提高等待获取锁的队列里面的goroutine获取锁的机会,加入饥饿模式: 等待队列直接获得锁, 新goroutine直接加入等待队列","like_count":0},{"had_liked":false,"id":303645,"user_name":"惘 闻","can_delete":false,"product_type":"c1","uid":1181650,"ip_address":"","ucode":"C5909F034BF072","user_header":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","comment_is_top":false,"comment_ctime":1626913485,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1626913485","product_id":100061801,"comment_content":"第一个版本的锁，当有多个纤程排队时。如果此时key为10也就是一个纤程持有锁，9个纤程在排队。那么持有锁的纤程释放后对key减一，可是现在key还是等于9，被唤醒的纤程也无法获取到这把锁吧。","like_count":0,"discussions":[{"author":{"id":2536820,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b5/74/cd80b9f4.jpg","nickname":"友","note":"","ucode":"972A4333A8B101","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385850,"discussion_content":"这里我就想问了，如果没有抢锁也不合理呀，如果flag可以=10 那么是如何unlock的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627299035,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181650,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","nickname":"惘 闻","note":"","ucode":"C5909F034BF072","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385256,"discussion_content":"懂了，第一个版本没有直接争抢锁的纤程。锁直接就给队列首部的纤程持有了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626956726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2536820,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b5/74/cd80b9f4.jpg","nickname":"友","note":"","ucode":"972A4333A8B101","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1181650,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","nickname":"惘 闻","note":"","ucode":"C5909F034BF072","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385414,"discussion_content":"看到后面就发现 第一版是顺序的 就第一次会抢 后面都是排队","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627031422,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":385256,"ip_address":""},"score":385414,"extra":""}]}]},{"had_liked":false,"id":288683,"user_name":"文武","can_delete":false,"product_type":"c1","uid":1115734,"ip_address":"","ucode":"B4F03A6280EB12","user_header":"https://static001.geekbang.org/account/avatar/00/11/06/56/fea40b3b.jpg","comment_is_top":false,"comment_ctime":1618624867,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618624867","product_id":100061801,"comment_content":"都是硬菜啊。 需要啃一段时间啊","like_count":0},{"had_liked":false,"id":284323,"user_name":"asdf100","can_delete":false,"product_type":"c1","uid":1043738,"ip_address":"","ucode":"39D8D71453E575","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/1a/ce7f7d54.jpg","comment_is_top":false,"comment_ctime":1616167565,"is_pvip":false,"replies":[{"id":"103182","content":"请求锁但是还没有获得锁的调用者","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1616301841,"ip_address":"","comment_id":284323,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1616167565","product_id":100061801,"comment_content":"什么叫waiter，应该如何理解？","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517309,"discussion_content":"请求锁但是还没有获得锁的调用者","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616301841,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284291,"user_name":"冰糕不冰","can_delete":false,"product_type":"c1","uid":1134761,"ip_address":"","ucode":"B754FE464BA426","user_header":"https://static001.geekbang.org/account/avatar/00/11/50/a9/3f8c7418.jpg","comment_is_top":false,"comment_ctime":1616151961,"is_pvip":false,"replies":[{"id":"103180","content":"对于简单的复杂度低的方法,go编译器会进行优化，把它内联","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1616301774,"ip_address":"","comment_id":284291,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1616151961","product_id":100061801,"comment_content":"这里为什么把slowpath逻辑提取成方法了就内联优化了？","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517302,"discussion_content":"对于简单的复杂度低的方法,go编译器会进行优化，把它内联","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616301774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134761,"avatar":"https://static001.geekbang.org/account/avatar/00/11/50/a9/3f8c7418.jpg","nickname":"冰糕不冰","note":"","ucode":"B754FE464BA426","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360103,"discussion_content":"明白了，感谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616373601,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284207,"user_name":"asdf100","can_delete":false,"product_type":"c1","uid":1043738,"ip_address":"","ucode":"39D8D71453E575","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/1a/ce7f7d54.jpg","comment_is_top":false,"comment_ctime":1616122381,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616122381","product_id":100061801,"comment_content":"正常模式下，waiter 都是进入先入先出队列，被唤醒的 waiter 并不会直接持有锁，而是要和新来的 goroutine 进行竞争。<br>---------<br>在锁未被持有的情况下，新来的goroutine是直接获取锁，还是先进入waiter队列里再获取出来竞锁？还是直接竞争一次锁，失败的话，再进入队列？","like_count":0},{"had_liked":false,"id":279363,"user_name":"阿牛","can_delete":false,"product_type":"c1","uid":1073236,"ip_address":"","ucode":"DC8C189FCF3289","user_header":"https://static001.geekbang.org/account/avatar/00/10/60/54/b3eb605b.jpg","comment_is_top":false,"comment_ctime":1613731103,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1613731103","product_id":100061801,"comment_content":"交作业。","like_count":0},{"had_liked":false,"id":276548,"user_name":"InfoQ_c52d919fc8a0","can_delete":false,"product_type":"c1","uid":2006890,"ip_address":"","ucode":"D8DDD4C9FC46AF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIhmCBvXm9Ht0qHn3RxwlfH2MAsCJZibDSdu98PQa405rPWmIc6DLz7zHJY1EhtlAeWwmvDJuWfvZw/132","comment_is_top":false,"comment_ctime":1611997986,"is_pvip":false,"replies":[{"id":"100424","content":"unlock的时候已经保证了可见性","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1612100034,"ip_address":"","comment_id":276548,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1611997986","product_id":100061801,"comment_content":"看到有人提了这个问题：《鸟窝老师, 我没理解初版的goroutine在被唤醒后是怎么进行后续的加锁操作的? 能解释一下吗 难道是Lock()进入阻塞队列后,等重新唤醒时再次调用Lock()方法吗?? =.=》<br>那么我抛出我不同的一个疑问：<br>在线程被唤醒后，不用重新去cas lock ，那么如何保证该线程能够看到释放锁线程的修改？难道被信号量唤醒的线程在执行前会先load一次修改吗？","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514747,"discussion_content":"unlock的时候已经保证了可见性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612100034,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2006890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIhmCBvXm9Ht0qHn3RxwlfH2MAsCJZibDSdu98PQa405rPWmIc6DLz7zHJY1EhtlAeWwmvDJuWfvZw/132","nickname":"InfoQ_c52d919fc8a0","note":"","ucode":"D8DDD4C9FC46AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347111,"discussion_content":"unlock是冲刷写缓冲，一般要配合lock的load load屏障使用的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612154227,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":275801,"user_name":"李金狗","can_delete":false,"product_type":"c1","uid":1605237,"ip_address":"","ucode":"9A38CA646B06C3","user_header":"https://static001.geekbang.org/account/avatar/00/18/7e/75/3e6bdc4c.jpg","comment_is_top":false,"comment_ctime":1611671422,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611671422","product_id":100061801,"comment_content":"看了第四遍,希望可以彻底理解。","like_count":0},{"had_liked":false,"id":275614,"user_name":"校歌","can_delete":false,"product_type":"c1","uid":2054611,"ip_address":"","ucode":"CD257668BB1A33","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKBENQekdV3e9XwRQ5kpO9Y9d81sEMm52qcwJWbFbWbW2rniaTFYCChoR0ibZ0E3soQqod9rvfmBibmQ/132","comment_is_top":false,"comment_ctime":1611621020,"is_pvip":true,"replies":[{"id":"100029","content":"如果此时锁正好释放，新gorotine有机会获取到锁，和唤醒的goroutine一样竞争","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1611635363,"ip_address":"","comment_id":275614,"utype":1}],"discussion_count":4,"race_medal":1,"score":"1611621020","product_id":100061801,"comment_content":"老师，没太理解，为什么在“给新人机会”的版本中，添加了mutexWoken标志位，新起的goroutine就可能获取mutex？看Lock()中的实现不也是一个for循环吗？如果没有获取到锁在runtime.Semacquire(&amp;m.sema)这里不也是会阻塞或者挂起吗？（目前的理解是这样的）","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514417,"discussion_content":"如果此时锁正好释放，新gorotine有机会获取到锁，和唤醒的goroutine一样竞争","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611635363,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2054611,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKBENQekdV3e9XwRQ5kpO9Y9d81sEMm52qcwJWbFbWbW2rniaTFYCChoR0ibZ0E3soQqod9rvfmBibmQ/132","nickname":"校歌","note":"","ucode":"CD257668BB1A33","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345014,"discussion_content":"原文：for 循环是不断尝试获取锁，如果获取不到，就通过 runtime.Semacquire(&amp;m.sema) 休眠，休眠醒来之后 awoke 置为 true，尝试争抢锁。\n这里醒来是goroutine主动的，还是被其他goroutine唤醒的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611639577,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2054611,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKBENQekdV3e9XwRQ5kpO9Y9d81sEMm52qcwJWbFbWbW2rniaTFYCChoR0ibZ0E3soQqod9rvfmBibmQ/132","nickname":"校歌","note":"","ucode":"CD257668BB1A33","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345013,"discussion_content":"老师能简单介绍下这个方法runtime.Semacquire(&amp;m.sema)吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611639436,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2054611,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKBENQekdV3e9XwRQ5kpO9Y9d81sEMm52qcwJWbFbWbW2rniaTFYCChoR0ibZ0E3soQqod9rvfmBibmQ/132","nickname":"校歌","note":"","ucode":"CD257668BB1A33","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345011,"discussion_content":"您是说，runtime.Semacquire(&amp;m.sema)这个时刻吗？新起的goroutine，只在这一时刻，才会跟唤醒的goroutine有公平的竞争？如果没有竞争到锁，新的起的goroutine还是被添加到Waiter的队列中，也就只能在队列里排队等待调度了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611638957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":273374,"user_name":"先听","can_delete":false,"product_type":"c1","uid":1151409,"ip_address":"","ucode":"82D8DA7A2FEB4B","user_header":"https://static001.geekbang.org/account/avatar/00/11/91/b1/fb117c21.jpg","comment_is_top":false,"comment_ctime":1610559385,"is_pvip":false,"replies":[{"id":"99179","content":"谢谢","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1610723094,"ip_address":"","comment_id":273374,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1610559385","product_id":100061801,"comment_content":"光看叙述方式，就能感受到强烈的专业机智和友善","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513583,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610723094,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":272927,"user_name":"K菌无惨","can_delete":false,"product_type":"c1","uid":2194764,"ip_address":"","ucode":"97A532D588FD49","user_header":"","comment_is_top":false,"comment_ctime":1610356261,"is_pvip":false,"replies":[{"id":"98937","content":"唤醒之后自然就获得了锁，原因在于唤醒的lock加锁值依然大于等于1","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1610379342,"ip_address":"","comment_id":272927,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1610356261","product_id":100061801,"comment_content":"鸟窝老师, 我没理解初版的goroutine在被唤醒后是怎么进行后续的加锁操作的? 能解释一下吗 难道是Lock()进入阻塞队列后,等重新唤醒时再次调用Lock()方法吗?? =.=","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513430,"discussion_content":"唤醒之后自然就获得了锁，原因在于唤醒的lock加锁值依然大于等于1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610379342,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2194764,"avatar":"","nickname":"K菌无惨","note":"","ucode":"97A532D588FD49","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341345,"discussion_content":"哦哦 我悟到了 是我之前先看了后面几个版本的代码想复杂了 多谢鸟窝老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610380956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":271690,"user_name":"缺席你的过去","can_delete":false,"product_type":"c1","uid":1433853,"ip_address":"","ucode":"08E0452191B714","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/fd/011c5dad.jpg","comment_is_top":false,"comment_ctime":1609758569,"is_pvip":false,"replies":[{"id":"98550","content":"设置为1表示没有其他等待者抢夺锁，并且锁是释放状态，可以幸运获取到锁。加1表示加入到等待队列","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1609804933,"ip_address":"","comment_id":271690,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1609758569","product_id":100061801,"comment_content":"老师，初版的互斥锁那里，关于Lock方法我没有看明白。<br>key字段为0，标识没有协程获取到锁；为1表示锁被持有，没有等待者；为n，表示锁被持有，且有n-1个等待着。<br>在lock方法里，某个协程lock成功的话，其lock方法会将key设置为1，这里设置为1是为什么，不应该是加1吗。如果获取锁失败，会将key加1，这里又是什么意思呢","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513005,"discussion_content":"设置为1表示没有其他等待者抢夺锁，并且锁是释放状态，可以幸运获取到锁。加1表示加入到等待队列","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609804933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":270206,"user_name":"David","can_delete":false,"product_type":"c1","uid":1136236,"ip_address":"","ucode":"8277D3CE881053","user_header":"https://static001.geekbang.org/account/avatar/00/11/56/6c/042a2e41.jpg","comment_is_top":false,"comment_ctime":1608987913,"is_pvip":false,"replies":[{"id":"98086","content":"如果有等待者，新人不会获取到锁的","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1609135650,"ip_address":"","comment_id":270206,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1608987913","product_id":100061801,"comment_content":"老师，请教一个问题，在初始版本：semrelease(*int32)，这个函数是 handsoff 形式还是baring形式？从使用上来看，我认为是baring形式。那么就有一个疑问了，如果A goroutine 获取到了锁，这个时候B也来获取，获取失败，只是key进行的+1，然后进入的睡眠，当A 释放的时候，去唤醒B(B要去做做一些资源切换，结合M的操作，会耽误时间)，可是这个时候，正好有个新goroutine C 来了，立马去抢到了锁，这个时候B又获取锁失败，进入睡眠，这种情况下，就不会所谓的队列形式，而且新人在某些情况下 还是占了优势","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512554,"discussion_content":"如果有等待者，新人不会获取到锁的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609135650,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":269391,"user_name":"用心","can_delete":false,"product_type":"c1","uid":2271947,"ip_address":"","ucode":"6226478ED8A894","user_header":"https://static001.geekbang.org/account/avatar/00/22/aa/cb/fc64b0da.jpg","comment_is_top":false,"comment_ctime":1608630459,"is_pvip":false,"replies":[{"id":"97703","content":"在runtime&#47;sema.go文件中","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1608640860,"ip_address":"","comment_id":269391,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1608630459","product_id":100061801,"comment_content":"老师好：<br>semrelease()<br>semacquire()<br>这两个方法的 具体怎样实现的呢","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512258,"discussion_content":"在runtime/sema.go文件中","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608640860,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":267364,"user_name":"九零","can_delete":false,"product_type":"c1","uid":1363456,"ip_address":"","ucode":"24073A52348B66","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoV7kTQGEFG19UiaRuqsVcKEwYzAGtWsbBBL9rrF6xl4531qjfJT1UT7AgibT3Hwg2u8EHSS7KMkntg/132","comment_is_top":false,"comment_ctime":1607694994,"is_pvip":false,"replies":[{"id":"97257","content":"对，漏了，应该加上waiter++.👍🏻看到仔细","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1607920199,"ip_address":"","comment_id":267364,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1607694994","product_id":100061801,"comment_content":"老师，在你讲“给新人机会”那一节中最后的表格是不是有点错误<br>如果请求锁的goroutine是被唤醒的，在当前锁被持有的情况下，应该是<br>1. waiter++ （if条件 old&amp;mutexLocked != 0 成立）<br>2. 清除mutexWoken标志<br>3. 重新休眠，加入等待队列<br>是不是少了第一步啊，因为在unlock方法中唤醒一个等待的goroutine的时候waiter已经减1了","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511615,"discussion_content":"对，漏了，应该加上waiter++.👍🏻看到仔细","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607920199,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1191550,"avatar":"https://static001.geekbang.org/account/avatar/00/12/2e/7e/ebc28e10.jpg","nickname":"NULL","note":"","ucode":"2A323DD05352BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":537865,"discussion_content":"一年了，正文中还是错误的，其他文章也是，有错不改","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639230790,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":511615,"ip_address":""},"score":537865,"extra":""}]}]},{"had_liked":false,"id":265695,"user_name":"onmyway","can_delete":false,"product_type":"c1","uid":1067505,"ip_address":"","ucode":"452276A5B783AD","user_header":"https://static001.geekbang.org/account/avatar/00/10/49/f1/3d3b02fd.jpg","comment_is_top":false,"comment_ctime":1606985092,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606985092","product_id":100061801,"comment_content":"不明觉厉！！！","like_count":0},{"had_liked":false,"id":265667,"user_name":"王宣越","can_delete":false,"product_type":"c1","uid":2318366,"ip_address":"","ucode":"A2B0497AA503C8","user_header":"https://static001.geekbang.org/account/avatar/00/23/60/1e/7254f487.jpg","comment_is_top":false,"comment_ctime":1606976529,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606976529","product_id":100061801,"comment_content":"支持的最大goroutine数量不应该是32-4=28  就是2的28次方-1个吗？不考虑符号位吗？","like_count":0},{"had_liked":false,"id":264260,"user_name":"Geek_f50ac4","can_delete":false,"product_type":"c1","uid":1651780,"ip_address":"","ucode":"3394ED1EC63AEB","user_header":"","comment_is_top":false,"comment_ctime":1606393633,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606393633","product_id":100061801,"comment_content":"32位的state int32, 3位标志, 1位符号位, 能支持的waiter数量 不是只有 2^28-1 吗?","like_count":0},{"had_liked":false,"id":262143,"user_name":"峪五","can_delete":false,"product_type":"c1","uid":1529249,"ip_address":"","ucode":"DCF2DC959D0CD7","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/a1/e77b9612.jpg","comment_is_top":false,"comment_ctime":1605622287,"is_pvip":false,"replies":[{"id":"95148","content":"直接放在这里会导致调用lock方法时lock不被内联","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1605673898,"ip_address":"","comment_id":262143,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1605622287","product_id":100061801,"comment_content":"func (m *Mutex) Lock() {     <br>   &#47;&#47; Fast path: 幸运之路，一下就获取到了锁    <br>    if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) {        <br>    return        }   <br>     &#47;&#47; Slow path：缓慢之路，尝试自旋竞争或饥饿状态下饥饿goroutine竞争      <br>  m.lockSlow()   <br> }<br>老师这个lockSlow怎么内联呀？内联是编译的时候将方法替换成代码吗？不是明白呀。直接把lockSlow方法的的代码全部替换放到这里会有什么问题吗？","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509702,"discussion_content":"直接放在这里会导致调用lock方法时lock不被内联","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605673898,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134761,"avatar":"https://static001.geekbang.org/account/avatar/00/11/50/a9/3f8c7418.jpg","nickname":"冰糕不冰","note":"","ucode":"B754FE464BA426","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":359336,"discussion_content":"lockSlow里有循环所以直接放到里面不会内联，单独提取一个方法就会内联对吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616163726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":260688,"user_name":"Hurt","can_delete":false,"product_type":"c1","uid":1050946,"ip_address":"","ucode":"DCE7428CCF08EF","user_header":"https://static001.geekbang.org/account/avatar/00/10/09/42/1f762b72.jpg","comment_is_top":false,"comment_ctime":1605083582,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605083582","product_id":100061801,"comment_content":"确实看不懂也不影响使用 但是努力去理解设计者的思想和实现 才能知其然知其所以然 感谢老师 打卡","like_count":0},{"had_liked":false,"id":259821,"user_name":"代码看不懂篮球打不好","can_delete":false,"product_type":"c1","uid":2197943,"ip_address":"","ucode":"7C5D1D36207F41","user_header":"","comment_is_top":false,"comment_ctime":1604846725,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604846725","product_id":100061801,"comment_content":"打卡打卡！","like_count":0},{"had_liked":false,"id":259408,"user_name":"蜉蝣","can_delete":false,"product_type":"c1","uid":1229070,"ip_address":"","ucode":"77CF92496855D4","user_header":"https://static001.geekbang.org/account/avatar/00/12/c1/0e/2b987d54.jpg","comment_is_top":false,"comment_ctime":1604719754,"is_pvip":false,"replies":[{"id":"94316","content":"对，最饥饿的先上","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1604735852,"ip_address":"","comment_id":259408,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1604719754","product_id":100061801,"comment_content":"老师，Mutex 饥饿模式下被唤醒的 goroutine 的会直接退出 for 循环：<br>```<br>if old&amp;mutexStarving != 0 {]<br>    atomic.AddInt32(&amp;m.state, delta)<br>    break<br>}<br>```<br>就是说，Mutex 处于饥饿模式的时候，不论饥饿的 goroutine 有多少个，Unlock 会唤醒的 goroutine 都只会有一个对吗？","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508932,"discussion_content":"对，最饥饿的先上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604735852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":259398,"user_name":"蜉蝣","can_delete":false,"product_type":"c1","uid":1229070,"ip_address":"","ucode":"77CF92496855D4","user_header":"https://static001.geekbang.org/account/avatar/00/12/c1/0e/2b987d54.jpg","comment_is_top":false,"comment_ctime":1604718277,"is_pvip":false,"replies":[{"id":"94318","content":"避免影响unlock唤醒机制","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1604737948,"ip_address":"","comment_id":259398,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1604718277","product_id":100061801,"comment_content":"老师，我不太懂这行代码：<br>```<br>if starving &amp;&amp; old&amp;mutexLocked != 0 {<br>    new |= mutexStarving<br>}<br>```<br>就是说，为什么要在有锁的时候才能标记“饥饿模式”？看上去就算无锁的时候标记饥饿模式也没什么影响。","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508927,"discussion_content":"避免影响unlock唤醒机制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604737948,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":259162,"user_name":"出卖灵魂的教练Kerry","can_delete":false,"product_type":"c1","uid":1807943,"ip_address":"","ucode":"8C64517DA556FE","user_header":"https://static001.geekbang.org/account/avatar/00/1b/96/47/93838ff7.jpg","comment_is_top":false,"comment_ctime":1604644438,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1604644438","product_id":100061801,"comment_content":"老师你好，之前看到协程互斥锁和c++&#47;java等互斥锁有不同？","like_count":0},{"had_liked":false,"id":258975,"user_name":"王景迁","can_delete":false,"product_type":"c1","uid":1360656,"ip_address":"","ucode":"4CD9A1179AE084","user_header":"https://static001.geekbang.org/account/avatar/00/14/c3/10/3f18e402.jpg","comment_is_top":false,"comment_ctime":1604589530,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604589530","product_id":100061801,"comment_content":"给新人机会里面，被唤醒的goroutine，遇到当前锁被持有的情况，需要waiter++。这一步在上面的图片里面少了。","like_count":0},{"had_liked":false,"id":258959,"user_name":"Jie","can_delete":false,"product_type":"c1","uid":1045078,"ip_address":"","ucode":"AB94041E548FEB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f2/56/c39046c0.jpg","comment_is_top":false,"comment_ctime":1604587643,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604587643","product_id":100061801,"comment_content":"一步步剖析源码实在太赞了，每篇都能细细品味好久","like_count":0},{"had_liked":false,"id":258429,"user_name":"Geek_05e2e4","can_delete":false,"product_type":"c1","uid":1601098,"ip_address":"","ucode":"240E31A2C93502","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJLQZzmZq5MIm602gibM9TzGcLea5SGR7iakKXhWZZMzQ4gz32g0HSjbM8xFOiaA82GXqpgibAnHMkMnQ/132","comment_is_top":false,"comment_ctime":1604423722,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604423722","product_id":100061801,"comment_content":"好难🤯","like_count":0},{"had_liked":false,"id":257404,"user_name":"SuperDai","can_delete":false,"product_type":"c1","uid":1289318,"ip_address":"","ucode":"0CA86D253754CA","user_header":"https://static001.geekbang.org/account/avatar/00/13/ac/66/a256008b.jpg","comment_is_top":false,"comment_ctime":1603959866,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603959866","product_id":100061801,"comment_content":"打卡! 看源码简直每次都是开卷有益呀！！！","like_count":0},{"had_liked":false,"id":256892,"user_name":"lacfo","can_delete":false,"product_type":"c1","uid":1014200,"ip_address":"","ucode":"F724032ABD431D","user_header":"","comment_is_top":false,"comment_ctime":1603778064,"is_pvip":false,"replies":[{"id":"93566","content":"释放锁的goroutine不必是锁的持有者","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1603845238,"ip_address":"","comment_id":256892,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1603778064","product_id":100061801,"comment_content":"老师好，我有1个关于第2.版的给新人机会的mutex的问题。在unlock中，您说或者别的goroutine已经加上了锁，就可以直接释放。我的问题是，如果我还没有释放，其它人是怎么拿到锁的呢？谢谢老师","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508156,"discussion_content":"释放锁的goroutine不必是锁的持有者","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603845238,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":256574,"user_name":"写点啥呢","can_delete":false,"product_type":"c1","uid":1065272,"ip_address":"","ucode":"C19032CF1C41BA","user_header":"https://static001.geekbang.org/account/avatar/00/10/41/38/4f89095b.jpg","comment_is_top":false,"comment_ctime":1603681472,"is_pvip":false,"replies":[{"id":"93488","content":"这里假定还没有其它giroutine获取到锁。<br>如果真的有goroutine获取到锁，那么第14行不成功，这个时候才读取state(第18行)","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1603759323,"ip_address":"","comment_id":256574,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1603681472","product_id":100061801,"comment_content":"请问老师，在“给新人机会”这版本mutex中的Unlock方法的第8行，为什么要用减掉mutextLocked标志位为old，而不是重新读取m.state呢？如果在这行之前还有其他goroutine创建并获得锁，感觉这里的状态判断就不对了。请老师指点一下","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508059,"discussion_content":"这里假定还没有其它giroutine获取到锁。\n如果真的有goroutine获取到锁，那么第14行不成功，这个时候才读取state(第18行)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603759323,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1065272,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/38/4f89095b.jpg","nickname":"写点啥呢","note":"","ucode":"C19032CF1C41BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318460,"discussion_content":"多谢老师，go的作者们真是对性能追求极致，多一次读取内存都能省就省😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603760543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":255982,"user_name":"pony","can_delete":false,"product_type":"c1","uid":1021530,"ip_address":"","ucode":"B72FA864CDD286","user_header":"https://static001.geekbang.org/account/avatar/00/0f/96/5a/846a09f7.jpg","comment_is_top":false,"comment_ctime":1603494681,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603494681","product_id":100061801,"comment_content":"自己设计互斥锁只能想到第一版，跟着老师看了源代码发展过程，才发现提高并发效率要考虑的因素好多，公平性、高效性之间的追求无极限。并发中队头阻塞感觉现在的mutex也是存在的","like_count":0},{"had_liked":false,"id":255880,"user_name":"myrfy","can_delete":false,"product_type":"c1","uid":1169401,"ip_address":"","ucode":"2814BAE5D70098","user_header":"","comment_is_top":false,"comment_ctime":1603449930,"is_pvip":false,"replies":[{"id":"93189","content":"建议看一下go内存模型。mutex有happen before保证","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1603451138,"ip_address":"","comment_id":255880,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1603449930","product_id":100061801,"comment_content":"老师，使用Mutex后就可以放心大胆的操作共享的结构体了吗？不是很清楚Go的Runtime在后面有没有其他的机制。<br><br>比如我有这样一个结构体<br><br>type Foo struct {<br>    mu sync.Mutex<br>    padding [64]uint64<br>    flag bool<br>}<br><br>结构体里的不同成员按顺序排列在内存中，两个协程运行在两个CPU核上，每个核的L1 Cache里分别加载了mu和flag两个变量对应的内存段。由于中间padding的存在，mu和flag不会落在同一个cacheline里<br><br>在执行mu.Lock()和mu.Unlock()的时候，由于使用了CAS操作，对应的CPU指令可以保证CPU1和CPU2的与mu有关的数据保持cache视图上的一致。但是当不同的协程获取到锁后，再操作位于其他Cacheline的flag变量时，是否会导致数据视图不一致？也就是，在操作mu时的内存读写屏障，感觉应该是不会影响到flag所处的地址的。<br><br>如果存在不一致，岂不是在获取锁之后，对所有其余字段的操作都有可能发生不一致的情况？后续所有的操作都应该是原子操作？但实际好像不是这样的。","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507860,"discussion_content":"建议看一下go内存模型。mutex有happen before保证","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603451138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":255528,"user_name":"全麦小面包","can_delete":false,"product_type":"c1","uid":1086413,"ip_address":"","ucode":"823C65BF366097","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/cd/dbafc7d1.jpg","comment_is_top":false,"comment_ctime":1603365889,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603365889","product_id":100061801,"comment_content":"就喜欢这样有历史厚度的文章。值得点赞，值得购买！","like_count":0},{"had_liked":false,"id":255233,"user_name":"大恒","can_delete":false,"product_type":"c1","uid":1330033,"ip_address":"","ucode":"B8E3E2273F74DB","user_header":"https://static001.geekbang.org/account/avatar/00/14/4b/71/591ae170.jpg","comment_is_top":false,"comment_ctime":1603287191,"is_pvip":true,"replies":[{"id":"93025","content":"go规范中位操作","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1603326303,"ip_address":"","comment_id":255233,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1603287191","product_id":100061801,"comment_content":"请问 new &amp;^= mutexWoken 怎么运算呢？第一次见两个操作符在一起","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507653,"discussion_content":"go规范中位操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603326303,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":255222,"user_name":"Money","can_delete":false,"product_type":"c1","uid":1120545,"ip_address":"","ucode":"F1CB378899309B","user_header":"https://static001.geekbang.org/account/avatar/00/11/19/21/e63b1eb1.jpg","comment_is_top":false,"comment_ctime":1603284776,"is_pvip":false,"replies":[{"id":"93022","content":"sema主要内部用来阻塞等待的队列","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1603320705,"ip_address":"","comment_id":255222,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1603284776","product_id":100061801,"comment_content":"老师，问下，第一版的为什么不直接使用计数器sema作为互斥锁，初始值为1？ <br><br>结构体如下<br>type Mutex struct { <br>      sema int32 &#47;&#47; 信号量专用，用以阻塞&#47;唤醒goroutine <br>}","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507648,"discussion_content":"sema主要内部用来阻塞等待的队列","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603320705,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":255059,"user_name":"Black🐯","can_delete":false,"product_type":"c1","uid":1593345,"ip_address":"","ucode":"9AD756BD5D1C4D","user_header":"https://static001.geekbang.org/account/avatar/00/18/50/01/128bdef2.jpg","comment_is_top":false,"comment_ctime":1603261170,"is_pvip":false,"replies":[{"id":"92995","content":"网上都是一些关注某个点的介绍。你可以学到哪个点就搜哪个点","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1603285999,"ip_address":"","comment_id":255059,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1603261170","product_id":100061801,"comment_content":"runtime.go 这个文件里的函数，老师有推荐的资料学习一下不","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507597,"discussion_content":"网上都是一些关注某个点的介绍。你可以学到哪个点就搜哪个点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603285999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":254700,"user_name":"Geek_3533e2","can_delete":false,"product_type":"c1","uid":1463552,"ip_address":"","ucode":"FC06CD05388324","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/HicgvkyMu8H6APOktflQBNrvyw80uHugX1unnsXNeoey3J2aTiaSib4T5icpsa1Gc3tDEQYMqxfDbgPAF0S2sV4sfQ/132","comment_is_top":false,"comment_ctime":1603171679,"is_pvip":false,"replies":[{"id":"92924","content":"没有唤醒的goroutine和它抢的话，它把自己&quot;伪装&quot;成唤醒的goroutine","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1603181190,"ip_address":"","comment_id":254700,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1603171679","product_id":100061801,"comment_content":"多给些机会中的Lock方法中，有一部分代码不是特别理解：<br>```<br>if old&amp;mutexLocked != 0 { &#47;&#47; 锁还没被释放<br>                if runtime_canSpin(iter) { &#47;&#47; 还可以自旋<br>                    if !awoke &amp;&amp; old&amp;mutexWoken == 0 &amp;&amp; old&gt;&gt;mutexWaiterShift != 0 &amp;&amp;<br>                        atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) {<br>                        awoke = true<br>                    }<br>                    runtime_doSpin()<br>                    iter++<br>                    continue &#47;&#47; 自旋，再次尝试请求锁<br>                }<br>                new = old + 1&lt;&lt;mutexWaiterShift<br>            }<br>```<br>请问老师，这里为什么要`awoke`设置成true，已经为什么要把old修改成old|mutexWoken呢？","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507491,"discussion_content":"没有唤醒的goroutine和它抢的话，它把自己&amp;quot;伪装&amp;quot;成唤醒的goroutine","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603181190,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":254450,"user_name":"Black🐯","can_delete":false,"product_type":"c1","uid":1593345,"ip_address":"","ucode":"9AD756BD5D1C4D","user_header":"https://static001.geekbang.org/account/avatar/00/18/50/01/128bdef2.jpg","comment_is_top":false,"comment_ctime":1603117158,"is_pvip":false,"replies":[{"id":"92858","content":"除了这个，unlock还还要负担唤醒等待者的责任，更复杂的，还需要处理饥饿状态的情况","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1603146431,"ip_address":"","comment_id":254450,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1603117158","product_id":100061801,"comment_content":"lock方法本身就是独占的，只有一个goroutine会持有锁，unlock方法理论上就不会竞争的情况，那么为什么要在unlock里做那么多状态检查？是考虑到前文说的，其他goroutine也可以在不持有mutex的情况下调用unlock方法？","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507402,"discussion_content":"除了这个，unlock还还要负担唤醒等待者的责任，更复杂的，还需要处理饥饿状态的情况","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603146431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":254370,"user_name":"Panda","can_delete":false,"product_type":"c1","uid":1095740,"ip_address":"","ucode":"911A200C7B18BE","user_header":"https://static001.geekbang.org/account/avatar/00/10/b8/3c/1a294619.jpg","comment_is_top":false,"comment_ctime":1603106488,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603106488","product_id":100061801,"comment_content":"Go 语言的进化 就像系统架构的进化    循序渐进 追求极致","like_count":0},{"had_liked":false,"id":254292,"user_name":"新味道","can_delete":false,"product_type":"c1","uid":2227527,"ip_address":"","ucode":"979E3574082CE7","user_header":"https://static001.geekbang.org/account/avatar/00/21/fd/47/499339d1.jpg","comment_is_top":false,"comment_ctime":1603096641,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603096641","product_id":100061801,"comment_content":"go的Mutex为何用到semaphore?","like_count":0},{"had_liked":false,"id":254252,"user_name":"linxs","can_delete":false,"product_type":"c1","uid":1006728,"ip_address":"","ucode":"0D860DF26FD150","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/88/9575e5d3.jpg","comment_is_top":false,"comment_ctime":1603092091,"is_pvip":true,"replies":[{"id":"92825","content":"看情况，饥饿状态下唤醒的gotoutine如果没抢到锁还是被放回的head","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1603094905,"ip_address":"","comment_id":254252,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1603092091","product_id":100061801,"comment_content":"runtime_Semrelease方法总是唤醒queue里面的第一个goroutine吗，该方法里面有个handoff字段，传true和false有什么区别呢？","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507334,"discussion_content":"看情况，饥饿状态下唤醒的gotoutine如果没抢到锁还是被放回的head","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603094905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":254168,"user_name":"Linuxer","can_delete":false,"product_type":"c1","uid":1153978,"ip_address":"","ucode":"272D9D8089C3D6","user_header":"https://static001.geekbang.org/account/avatar/00/11/9b/ba/333b59e5.jpg","comment_is_top":false,"comment_ctime":1603076021,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1603076021","product_id":100061801,"comment_content":"if old&amp;mutexLocked != 0 {                <br>      new = old + 1&lt;&lt;mutexWaiterShift &#47;&#47;等待者数量加一            <br>}<br>一直以为 +（加号运算符） 的优先级高于 &lt;&lt;（左移运算符）， 实际操作后才知道搞错了","like_count":0,"discussions":[{"author":{"id":1215879,"avatar":"https://static001.geekbang.org/account/avatar/00/12/8d/87/47d95f4a.jpg","nickname":"syuan","note":"","ucode":"D9BBC2ADAB5F2E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319873,"discussion_content":"好多语法语法书都说+号比<<优先级高，在这块纠结了好久，查了go语言规范，go中是<<优先级比+高。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604150932,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253885,"user_name":"君哥聊技术","can_delete":false,"product_type":"c1","uid":1325816,"ip_address":"","ucode":"2C9A22BCE4C79E","user_header":"https://static001.geekbang.org/account/avatar/00/14/3a/f8/c1a939e7.jpg","comment_is_top":false,"comment_ctime":1602932325,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602932325","product_id":100061801,"comment_content":"感觉更像是java AQS中的非公平锁，不过多了饥饿模式","like_count":0},{"had_liked":false,"id":253799,"user_name":"今天","can_delete":false,"product_type":"c1","uid":1532354,"ip_address":"","ucode":"F8577A2BABCD1F","user_header":"https://static001.geekbang.org/account/avatar/00/17/61/c2/94c1d4c9.jpg","comment_is_top":false,"comment_ctime":1602900624,"is_pvip":false,"replies":[{"id":"92731","content":"可能是2,3.....","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1602917183,"ip_address":"","comment_id":253799,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1602900624","product_id":100061801,"comment_content":"&#47;&#47; 保证成功在val上增加delta的值 func xadd(val *int32, delta int32) (new int32) { for { v := *val if cas(val, v, v+delta) { return v + delta } } panic(&quot;unreached&quot;) } &#47;&#47; 请求锁 func (m *Mutex) Lock() { if xadd(&amp;m.key, 1) == 1 { &#47;&#47;标识加1，如果等于1，成功获取到锁 return } semacquire(&amp;m.sema) &#47;&#47; 否则阻塞等待 }<br><br>初版这里，xadd里面是个for死循环。那么在Lock函数里面调用的话，如果xadd可以返回，值肯定是1，Lock函数也就返回了，那问题是Lock里面的semacquire怎么会被调用呢？没想明白请老师帮忙解答下","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507187,"discussion_content":"可能是2,3.....","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602917183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253744,"user_name":"风中花","can_delete":false,"product_type":"c1","uid":1085237,"ip_address":"","ucode":"067E0A1E116844","user_header":"https://static001.geekbang.org/account/avatar/00/10/8f/35/f1839bb2.jpg","comment_is_top":false,"comment_ctime":1602849868,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602849868","product_id":100061801,"comment_content":"有点费劲了！回头还的泡机杯茶 品","like_count":0},{"had_liked":false,"id":253736,"user_name":"飞机","can_delete":false,"product_type":"c1","uid":1585659,"ip_address":"","ucode":"D0CA3AE2B50686","user_header":"https://static001.geekbang.org/account/avatar/00/18/31/fb/e5918d39.jpg","comment_is_top":false,"comment_ctime":1602847105,"is_pvip":false,"replies":[{"id":"92668","content":"方法体在其他地方实现。现在的go也支持这种特性","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1602849953,"ip_address":"","comment_id":253736,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1602847105","product_id":100061801,"comment_content":"cas函数没有方法体，那么它是怎么判断true和false呢？","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507160,"discussion_content":"方法体在其他地方实现。现在的go也支持这种特性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602849953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253588,"user_name":"飞沉血","can_delete":false,"product_type":"c1","uid":2025780,"ip_address":"","ucode":"C3122210A5D79D","user_header":"https://static001.geekbang.org/account/avatar/00/1e/e9/34/2eb0c21a.jpg","comment_is_top":false,"comment_ctime":1602807990,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602807990","product_id":100061801,"comment_content":"打卡，打卡，早安","like_count":0},{"had_liked":false,"id":253535,"user_name":"www","can_delete":false,"product_type":"c1","uid":1898338,"ip_address":"","ucode":"ADC9BC655EA16C","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f7/62/947004d0.jpg","comment_is_top":false,"comment_ctime":1602769672,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602769672","product_id":100061801,"comment_content":"源代码注释写得挺详细，向大牛看齐，耐心很重要","like_count":0},{"had_liked":false,"id":253522,"user_name":"陈陈陈","can_delete":false,"product_type":"c1","uid":1617007,"ip_address":"","ucode":"8E50925CEEEF28","user_header":"https://static001.geekbang.org/account/avatar/00/18/ac/6f/c58c1f26.jpg","comment_is_top":false,"comment_ctime":1602763223,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602763223","product_id":100061801,"comment_content":"打卡，这节比前面的两节难懂点","like_count":0},{"had_liked":false,"id":253358,"user_name":"大力水手","can_delete":false,"product_type":"c1","uid":1367822,"ip_address":"","ucode":"D44F1ABFE4C5C8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erkCRjibSLNBsK2umhGU2dFy4KUKbZjf7WdibiaL2a0icqvLwC4QskLCCehSnQYLuJsrvT5uVjYSETtMQ/132","comment_is_top":false,"comment_ctime":1602709704,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602709704","product_id":100061801,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":253277,"user_name":"NevS","can_delete":false,"product_type":"c1","uid":1219535,"ip_address":"","ucode":"A6F5F9EC80FCBE","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/cf/52f7a2eb.jpg","comment_is_top":false,"comment_ctime":1602670689,"is_pvip":false,"replies":[{"id":"92535","content":"因为它在for循环中，old的值会改变，第18行 。其它goroutine可能又获取了锁 。","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1602675491,"ip_address":"","comment_id":253277,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1602670689","product_id":100061801,"comment_content":"老师，我有一个疑问。在第二版的mutex的Unlock()方法里面：<br>1、第3行【new := atomic.AddInt32(&amp;m.state, -mutexLocked) 】，此时的new已经减去了mutexLocked，去掉了锁被持有的标志位。<br>2、然后在第8行，将new赋值给了old。<br>3、最后在第10行中有【old&amp;(mutexLocked|mutexWoken) != 0】的判断，但是old已经在第3行里面减去了mutexLocked，为什么这里还需要判断mutexLocked，用【old&amp;(mutexWoken) != 0】应该就可以了吧？因为按照我的理解old的第0位bit应该是0，不可能是1了吧。","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507030,"discussion_content":"因为它在for循环中，old的值会改变，第18行 。其它goroutine可能又获取了锁 。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602675491,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2554951,"avatar":"https://static001.geekbang.org/account/avatar/00/26/fc/47/5fb0d905.jpg","nickname":"张健华","note":"","ucode":"577452129C885A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392384,"discussion_content":"unlock时如果CompareAndSwapInt32失败，说明此时有其它goroutine又获取了锁，再进入下一次循环。这种情况其他goroutine是不是只能是新来的goroutine，不可能是被唤醒的goroutine，因为此时该Unlock线程还没执行唤醒操作，应该也不存在其他执行Unlock的线程。\n所以这里old&amp;(mutexLocked|mutexWoken)!= 0是不是可以改为old&amp;mutexLocked= ！0，因为old的mutexWoken位肯定为0。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630987242,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253192,"user_name":"光明","can_delete":false,"product_type":"c1","uid":1002252,"ip_address":"","ucode":"0A5E7CFD91A3CF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4b/0c/dab49a2b.jpg","comment_is_top":false,"comment_ctime":1602645538,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1602645538","product_id":100061801,"comment_content":"Mutex 的 state 是 int32。 <br><br>第1位 mutexLocked 表示是否为锁定状态<br>第2位 mutexWoken 表示锁是否处于唤醒<br>第3位 mutexStarving 表示是否饥饿<br><br>因此，32 - 3 = 29 位，也就是 2 ^ 29 个 goroutine，再加上内存限制考虑，感觉是够用的。","like_count":0},{"had_liked":false,"id":253171,"user_name":"CodeFish-Xiao","can_delete":false,"product_type":"c1","uid":2217807,"ip_address":"","ucode":"E0834E4560B0BE","user_header":"https://static001.geekbang.org/account/avatar/00/21/d7/4f/5059c43a.jpg","comment_is_top":false,"comment_ctime":1602641122,"is_pvip":true,"replies":[{"id":"92509","content":"继续，加油","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1602644580,"ip_address":"","comment_id":253171,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1602641122","product_id":100061801,"comment_content":"打卡<br><br>","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506993,"discussion_content":"继续，加油","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602644580,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}