{"id":475684,"title":"06 | 扩展：你的能力边界到底在哪里？","content":"<p>你好，我是朱涛。</p><p>Kotlin的扩展（Extension），主要分为两种语法：第一个是扩展函数，第二个是扩展属性。从语法上看，扩展看起来就像是我们从类的外部为它扩展了新的成员。</p><p>这在实际编程当中是非常有用的功能。我们可以来想象一个场景：我们想修改JDK当中的String，想在它的基础上增加一个方法“lastElement()”来获取末尾元素，如果使用Java，我们是无法通过常规手段实现的，因为我们没办法修改JDK的源代码。<strong>任何第三方提供的SDK，我们都无权修改。</strong></p><p>不过，借助Kotlin的扩展函数，我们就完全可以在语义层面，来为第三方SDK的类扩展新的成员方法和成员属性。不管是为JDK的String增加新的成员方法，还是为Android SDK的View增加新成员属性，我们都可以实现。</p><p>Kotlin的这个“扩展”功能看起来很神奇，它会不会很难学？其实不然，它的语法非常简洁。今天这节课，我们就一起来学习下Kotlin当中的扩展。通过研究它的原理，来探索它的能力边界，并在理解和掌握核心知识点之后，去思考它的实战应用场景。</p><h2>什么是扩展函数和扩展属性？</h2><p>扩展函数，就是从类的外部扩展出来的一个函数，这个函数看起来就像是类的成员函数一样。这里，我们就以JDK当中的String为例，来看看如何通过Kotlin的扩展特性，为它新增一个lastElement()方法。</p><!-- [[[read_end]]] --><pre><code class=\"language-plain\">// Ext.kt\npackage com.boycoder.chapter06\n\n/*\n ①    ②      ③            ④\n ↓     ↓       ↓            ↓      */\nfun String.lastElement(): Char? {\n    //    ⑤\n    //    ↓\n    if (this.isEmpty()) {\n        return null\n    }\n\n    return this[length - 1]\n}\n\n// 使用扩展函数\nfun main() {\n    val msg = \"Hello Wolrd\"\n    // lastElement就像String的成员方法一样可以直接调用\n    val last = msg.lastElement() // last = d\n}\n</code></pre><p>我们先是定义了一个String的扩展函数“lastElement()”，然后在main函数当中调用了这个函数。并且，这个扩展函数是直接定义在Kotlin文件里的，而不是定义在某个类当中的。这种扩展函数，我们称之为“<strong>顶层扩展</strong>”，这么叫它是因为它并没有嵌套在任何的类当中，它自身就在最外层。</p><p>现在，我们依次来看看上面的五处注释。</p><ul>\n<li>注释①，<code>fun</code>关键字，代表我们要定义一个函数。也就是说，不管是定义普通Kotlin函数，还是定义扩展函数，我们都需要fun关键字。</li>\n<li>注释②，“<code>String.</code>”，代表我们的扩展函数是为String这个类定义的。在Kotlin当中，它有一个名字，叫做接收者（Receiver），也就是扩展函数的接收方。</li>\n<li>注释③，<code>lastElement()</code>，是我们定义的扩展函数的名称。</li>\n<li>注释④，“<code>Char?</code>”，代表扩展函数的返回值是可能为空的Char类型。</li>\n<li>注释⑤，“<code>this.</code>”，代表“具体的String对象”，当我们调用 <code>msg.lastElement()</code> 的时候，this就代表了msg。</li>\n</ul><p>需要注意的是，<strong>在整个扩展函数的方法体当中，this都是可以省略的。</strong>这一点，Kotlin和Java是一样的，this代表当前作用域，它可写可不写。</p><p>另外，如果你足够细心的话，你会发现如果去掉注释②处的“<code>String.</code>”，这段代码就会变成一个普通的函数定义：</p><pre><code class=\"language-plain\">fun lastElement(): Char? {}\n\nfun String.lastElement(): Char? {}\n// 普通函数与扩展函数之间的差别\n</code></pre><p>换句话说，就是如果我们在普通函数的名称前面加上一个“接收者类型”，比如“<code>String.</code>”，Kotlin的“普通函数”就变成了“扩展函数”。</p><p>可见，Kotlin扩展语法设计得非常巧妙，只要你记住了普通函数的语法，那么，只需要再记住一点点细微的区别，你就能记住扩展函数的语法。而通过这个细微的语法差异，你也可以体会到，所谓的扩展函数，就是多了个“扩展接收者”的函数。</p><h3>扩展函数的实现原理</h3><p>在<a href=\"https://time.geekbang.org/column/article/473529\">第3讲</a>中，我们学习了如何研究Kotlin的原理，也就是通过Java字节码来做反编译。那么在这里，我们就以刚才写的lastElement()为例，一起来看看它反编译后的Java代码是什么样的。</p><pre><code class=\"language-java\">public final class ExtKt {\n   // ①\n   public static final Character lastElement(String $this) {\n      CharSequence var1 = (CharSequence)$this;\n      if (var1.length() == 0) {\n        return null\n      }\n\n      return  var1.charAt(var1.length() - 1);\n   }\n}\n\npublic static final void main() {\n  String msg = \"Hello Wolrd\";\n  //                        ②\n  //                        ↓\n  Character last = ExtKt.lastElement(msg);\n}\n</code></pre><p>以上代码有两个地方需要注意，我分别用两个注释标记出来了。</p><p>通过第一个注释，我们可以看到，原本定义在String类型上面的扩展函数lastElement()，变成了一个<strong>普通的静态方法</strong>。另外，之前定义的扩展函数lastElement()是没有参数的，但反编译后的Java代码中，lastElement(String $this) <strong>多了一个String类型的参数</strong>。</p><p>还有第二个注释，这是扩展函数的调用处，原本msg.lastElement()的地方，变成了ExtKt.lastElement(msg)。这说明，<strong>Kotlin编写的扩展函数调用代码，最终会变成静态方法的调用</strong>。</p><p>看到这里，也许你一下就能反应过来：Kotlin的扩展函数只是从表面上将lastElement()变成String的成员，但它实际上并没有修改String这个类的源代码，lastElement()也并没有真正变成String的成员方法。</p><p>也就是说，<strong>由于JVM不理解Kotlin的扩展语法，所以Kotlin编译器会将扩展函数转换成对应的静态方法，而扩展函数调用处的代码也会被转换成静态方法的调用。</strong></p><p>而如果我们将上面的ExtKt修改成StringUtils，它就变成了典型的Java工具类。</p><pre><code class=\"language-java\">public final class StringUtils {\n   public static final Character lastElement(String $this) {\n     // 省略\n   }\n}\n\npublic static final void main() {\n  Character last = StringUtils.lastElement(msg);\n}\n</code></pre><h3>如何理解扩展属性？</h3><p>在学习了Kotlin的扩展函数以后，扩展属性就很好理解了。扩展函数，是在类的外部为它定义一个<strong>新的成员方法</strong>；而扩展属性，则是在类的外部为它定义一个<strong>新的成员属性</strong>。</p><p>那么，在研究了扩展的实现原理后，我们知道，我们从外部定义的成员方法和属性，都只是语法层面的，并没有实际修改那个类的源代码。</p><p>还是以lastElement为例，在之前的案例当中，我们是通过扩展函数来实现的，这次我们以扩展属性的方式来实现。扩展函数的定义对比普通函数，其实就只是多了一个“接收者类型”。类似的，扩展属性，也就是在普通属性定义的时候多加一个“接收者类型”即可。</p><pre><code class=\"language-plain\">// 接收者类型\n//     ↓\nval String.lastElement: Char?\n    get() = if (isEmpty()) {\n            null\n        } else {\n            get(length - 1)\n        }\n\nfun main() {\n    val msg = \"Hello Wolrd\"\n    // lastElement就像String的成员属性一样可以直接调用\n    val last = msg.lastElement // last = d\n}\n</code></pre><p>在这段的代码中，我们为String类型扩展了一个新的成员属性“lastElement”。然后在main函数当中，我们直接通过“msg.lastElement”方式使用了这个扩展属性，就好像它是一个成员一样。而如果你将以上的代码进行反编译，你会发现它反编译后的Java代码几乎和我们前面扩展函数的一模一样。</p><p>为了让你看得更加清晰，我们用一张图来描述它们之间的关系。</p><p><img src=\"https://static001.geekbang.org/resource/image/2a/ed/2a38487b61ec06e437c1425b2a69ffed.png?wh=1920x752\" alt=\"图片\"></p><p>上面的两个箭头，说明了扩展函数与扩展属性，它们最终会被Kotlin编译器转换成静态方法；下面两个箭头，说明了扩展函数和扩展属性的调用代码，最终会被Kotlin编译器转换成静态方法的调用。</p><p>所以也就是说，Kotlin的扩展表面上看起来是为一个类扩展了新的成员，但是<strong>本质上，它还是静态方法</strong>。而且，不管是扩展函数还是扩展属性，它本质上都会变成一个静态的方法。那么，到底什么时候该用扩展函数，什么时候该用扩展属性呢？</p><p>其实，我们只需要看扩展在语义上更适合作为函数还是属性就够了。比如这里的lastElement，它更适合作为一个扩展属性。这样设计的话，在语义上，lastElement就像是String类当中的属性一样，它代表了字符串里的最后一个字符。</p><h2>扩展的能力边界</h2><p>在理解了扩展的使用与原理后，我们再来探讨一下扩展的能力边界：扩展能做什么，不能做什么。Kotlin的扩展看起来很神奇，但它并不是无所不能的，通过探索它的能力边界，我们就能对它有一个更加深入的认识。</p><h3><strong>扩展能做什么？</strong></h3><p>我们先从“扩展能做什么”说起。</p><p>当我们想要从外部为一个类扩展一些方法和属性的时候，我们就可以通过扩展来实现了。<strong>在Kotlin当中，几乎所有的类都可以被扩展</strong>，包括普通类、单例类、密封类、枚举类、伴生对象，甚至还包括第三方提供的Java类。唯有匿名内部类，由于它本身不存在名称，我们无法指定“接收者类型”，所以不能被扩展，当然了，它也没必要被扩展。</p><p>可以说，Kotlin扩展的应用范围还是非常广的。它最主要的用途，就是<strong>用来取代Java当中的各种工具类</strong>，比如StringUtils、DateUtils等等。</p><p>所有Java工具类能做的事情，Kotlin扩展函数都可以做，并且可以做得更好。扩展函数的优势在于，开发工具可以在编写代码的时候智能提示。</p><p><img src=\"https://static001.geekbang.org/resource/image/23/9c/239e540b768560c6cd119b1bb9e1eb9c.gif?wh=1210x682\" alt=\"图片\"></p><h3><strong>扩展不能做什么？</strong></h3><p>我们再聊聊扩展不能做什么。</p><p>Kotlin的扩展，由于它本质上并没有修改接收类型的源代码，所以它的行为是无法与“类成员”完全一致的。那么它对比普通的类成员，就会有以下几个限制。</p><p><strong>第一个限制</strong>，Kotlin扩展不是真正的类成员，因此它无法被它的子类重写。举个例子，我们定义一个这样的Person类，并且分别为它扩展了一个isAdult属性和 walk()方法：</p><pre><code class=\"language-plain\">open class Person {\n    var name: String = \"\"\n    var age: Int = 0\n}\n\nval Person.isAdult: Boolean\n    get() = age &gt;= 18\n\nfun Person.walk() {\n    println(\"walk\")\n}\n</code></pre><p>由于Person类有open关键字修饰，所以我们可以继承这个Person类。不过，当我们尝试去重写它的成员时，会发现isAdult和walk()是无法被重写的，因为它们压根就不属于Person这个类。这个很好理解，让我们看下一个。</p><p><strong>第二个限制</strong>，扩展属性无法存储状态。就如前面代码当中的isAdult属性一般，它的值是由age这个成员属性决定的，它本身没有状态，也无法存储状态。这一点，和我们在<a href=\"https://time.geekbang.org/column/article/473349\">第2讲</a>学习的“接口成员属性”一样，背后的根本原因，还是因为它们都是静态方法。</p><p><strong>第三个限制</strong>，扩展的访问作用域仅限于两个地方。第一，定义处的成员；第二，接收者类型的公开成员。我们以前面的代码为例：</p><pre><code class=\"language-plain\">// Ext.kt\npackage com.boycoder.chapter06\n\n// ①\nprivate val msg: String = \"\"\n\nfun String.lastElement(): Char? {\n    if (this.isEmpty()) {\n        //       ②\n        //       ↓\n        println(msg)\n        return null\n    }\n\n    //            ③\n    //            ↓\n    return this[length - 1]\n}\n</code></pre><p>这段代码一共有三处注释，我们一个个看：</p><ul>\n<li>在注释①的地方，我们在Ext这个Kotlin文件里定义了一个私有的变量msg。</li>\n<li>由于lastElement()与msg是定义在同一个文件当中的，因此，在注释②处我们可以直接访问msg，即使它是私有的。</li>\n<li>最后，是注释③，由于length是String类的公开属性，因此我们可以在扩展函数当中直接访问它。对应的，如果length是String的private、protected成员，那我们将无法在扩展函数当中访问它。归根结底，还是因为扩展函数并非真正的类成员。</li>\n</ul><p>看到这里，也许你会冒出一个有趣的想法：<strong>如果将扩展定义在某个类的内部，它能够访问这个类的私有属性吗？</strong></p><p>让我们来试试看：</p><pre><code class=\"language-plain\">open class Person {\n    var name: String = \"\"\n    var age: Int = 0\n}\n\nclass Helper {\n    private fun walkOnFoot() {\n        println(\"用脚走路\")\n    }\n    val Person.isAdult: Boolean\n        get() = age &gt;= 18\n\n    fun Person.walk() {\n        // 调用了Helper的私有方法\n        walkOnFoot()\n    }\n\n    fun test() {\n        val person = Person()\n        // 仅可以在Helper类当中使用此扩展\n        person.walk()\n    }\n}\n</code></pre><p>我们创建了一个Helper类，它内部有一个私有的成员方法，同时，我们在这个类的内部定义了一个扩展属性和一个扩展函数。可以看到，我们在扩展函数walk()方法当中，能直接调用Helper类的私有成员方法walkOnFoot()，这体现了类的内部定义扩展的优势。</p><p>但是与此同时，这种方式定义的扩展也存在一个劣势，那就是无法在Helper类的外部作为扩展被调用。如果你将上面的代码反编译成Java，你会发现，我们定义的内部扩展，最终都变成了Helper类的普通成员函数和成员属性。</p><p>所以，针对扩展的第三个限制来说：</p><ul>\n<li>如果扩展是<strong>顶层的扩展</strong>，那么扩展的访问域仅限于该Kotlin文件当中的所有成员，以及被扩展类型的公开成员，这种方式定义的扩展是可以被全局使用的。</li>\n<li>如果扩展是<strong>被定义在某个类当中</strong>的，那么该扩展的访问域仅限于该类当中的所有成员，以及被扩展类型的公开成员，这种方式定义的扩展仅能在该类当中使用。</li>\n</ul><h2>实战与思考</h2><p>到这里，我们就了解了Kotlin的扩展，包括扩展函数、扩展属性以及扩展的实现原理，同时我们也在了解它原理的基础上分析了它的能力边界。</p><p>不过，即使在学习完上面所有的知识点后，你也许还是不太清楚Kotlin扩展的实际使用场景。所以下面，我再带你来看两个案例，这两个工业界的实际案例，可以完美地向你展示Kotlin扩展的两个核心使用场景。你可以通过学习这两种思路，将其运用在实际的工作当中。</p><p>第一个案例，是来自Kotlin标准库当中的源代码。我们先看看在Kotlin当中，<a href=\"https://github.com/JetBrains/kotlin/blob/master/core/builtins/native/kotlin/String.kt\">String.kt</a>的源代码是什么样的：</p><pre><code class=\"language-plain\">// String.kt\npublic class String : Comparable&lt;String&gt;, CharSequence {\n    companion object {}\n\n    public operator fun plus(other: Any?): String\n\n    public override val length: Int\n\n    public override fun get(index: Int): Char\n\n    public override fun subSequence(startIndex: Int, endIndex: Int): CharSequence\n\n    public override fun compareTo(other: String): Int\n}\n</code></pre><p>你一定会很惊讶，Kotlin里面的String类竟然只有不到十行代码。那么，String类的那些字符操作的方法到哪里去了？比如，String.trim()、String.lowercase()它们定义在什么地方？</p><p>实际上，String相关的操作方法全都放到了<a href=\"https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/text/Strings.kt\">Strings.kt</a>当中去了。而这些字符操作方法全部都是以扩展函数的方式定义的：</p><pre><code class=\"language-plain\">// Strings.kt 部分代码\n\npublic fun CharSequence.trim(): CharSequence = trim(Char::isWhitespace)\n\npublic expect fun String.lowercase(): String\n</code></pre><p>那么，Kotlin官方能不能将“字符操作方法”放到String类当中合并到一起呢？源代码是Kotlin官方写的，他们当然能将所有的代码都合并到一个类当中去，形成一个几千行的String类，但他们却没有这么做。这是为啥呢？</p><p>这就是Kotlin扩展的<strong>第一个典型使用场景：</strong><a href=\"https://zh.wikipedia.org/wiki/%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB\">关注点分离</a>。所谓关注点分离，就是将我们程序的逻辑划分成不同的部分，每一个部分，都只关注自己那部分的职责。以上面的String类为例，<a href=\"https://github.com/JetBrains/kotlin/blob/master/core/builtins/native/kotlin/String.kt\">String.kt</a>这个类，只关注String的核心逻辑；而<a href=\"https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/text/Strings.kt\">Strings.kt</a>则只关注String的操作符逻辑。</p><p>需要注意的是，只有借助Kotlin的扩展，我们才能实现这样的关注点分离设计。如果你去看Java的String类，你会发现它的源代码有三千多行。这是因为，Java的String核心属性跟它的操作方法全都混合在了一起。</p><p>第二个代码案例，是我工作当中用到的一段Android扩展函数代码：</p><pre><code class=\"language-plain\">inline fun &lt;reified T : ViewGroup.LayoutParams&gt; View.updateLayoutParams(block: T.() -&gt; Unit) {\n    val params = layoutParams as T\n    block(params)\n    layoutParams = params\n}\n\nfun View.updateMargin(left: Int? = null, top: Int? = null, right: Int? = null, bottom: Int? = null) {\n    (layoutParams as? ViewGroup.MarginLayoutParams)?.let { param -&gt;\n        updateLayoutParams&lt;ViewGroup.MarginLayoutParams&gt; {\n            left?.let {\n                marginStart = left\n            }\n\n            right?.let {\n                marginEnd = right\n            }\n\n            top?.let {\n                topMargin = top\n            }\n\n            bottom?.let {\n                bottomMargin = bottom\n            }\n        }\n    }\n}\n</code></pre><p>上面的代码定义了两个扩展函数，updateLayoutParams()、updateMargin()，后者的方法体当中用到了前者。通过updateMargin()这个扩展函数，可以大大简化Android当中的margin更新。</p><pre><code class=\"language-plain\">view.updateMargin(top = 100, bottom = 100)\n</code></pre><p>而如果不借助扩展函数，我们将不得不写一堆的模板代码：</p><pre><code class=\"language-plain\">val params = view.layoutParams\nif (params is ViewGroup.MarginLayoutParams) {\n    params.marginTop = 100\n    params.marginBottom = 100\n    view.layoutParams = params\n}\n</code></pre><p>可以看到，借助扩展函数，我们不仅提升了代码的可读性，还提升了编码效率，而这种效率可以说是<strong>成倍</strong>的提升：借助扩展函数，我们只需要写一行代码，IntelliJ还会智能提示，帮我们补全代码；不借助扩展函数的话，我们需要写5行代码，这样的代码模式不仅枯燥繁琐，IntelliJ也无法智能提示，也更容易出错。</p><p>我们来小结一下，Kotlin扩展主要有两个核心使用场景。</p><ul>\n<li><strong>主动使用扩展，通过它来优化软件架构。</strong></li>\n</ul><p>对复杂的类进行职责划分，关注点分离。让类的核心尽量简单易懂，而让类的功能性属性与方法以扩展的形式存在于类的外部。比如我们的<a href=\"https://github.com/JetBrains/kotlin/blob/master/core/builtins/native/kotlin/String.kt\">String.kt</a>与<a href=\"https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/text/Strings.kt\">Strings.kt</a>。</p><ul>\n<li><strong>被动使用扩展，提升可读性与开发效率。</strong></li>\n</ul><p>当我们无法修改外部的SDK时，对于重复的代码模式，我们将其以扩展的方式封装起来，提供给对应的接收者类型，比如view.updateMargin()。</p><h2>小结</h2><p>好，让我们来做个简单的总结吧。</p><ul>\n<li>Kotlin的扩展，从<strong>语法角度</strong>来看，分为扩展函数和扩展属性。定义扩展的方式，只是比普通函数、属性多了一个“扩展接收者”而已。</li>\n<li>从<strong>作用域角度</strong>来看，分为顶层扩展和类内扩展。</li>\n<li>从<strong>本质</strong>上来看，扩展函数和扩展属性，它们都是Java静态方法，与Java当中的工具类别无二致。对比Java工具类，扩展最大的优势就在于，IDE可以为我们提供代码补全功能。</li>\n<li>从<strong>能力</strong>的角度来看，Kotlin扩展一共有三个限制，分别是：扩展无法被重写；扩展属性无法存储状态；扩展的作用域有限，无法访问私有成员。</li>\n<li>从<strong>使用场景</strong>的角度来看，Kotlin扩展主要有两个使用场景，分别是：关注点分离，优化代码架构；消灭模板代码，提高可读性和开发效率。</li>\n</ul><p>最后在这里，我还想和你分享一下我在学Kotlin扩展的思考过程，希望这种思考的方式可以给你带来一些启发。</p><p>刚开始，我学习扩展的时候，脑子里其实是一片混乱的，就像下面这张图一样：扩展的每一个知识点都是散乱的。</p><p>这时候，我们就要将这些知识点做一个分类整理，同时，在学习扩展语法的时候，还要与前面的普通函数、普通属性的语法进行关联记忆。这样一来，我们零散的知识点就连接到一起，形成体系化的知识面。</p><p><img src=\"https://static001.geekbang.org/resource/image/3d/5c/3d0715ee9ba1461bcee1bea99de8e25c.jpg?wh=1920x1080\" alt=\"图片\"></p><p>当我们的知识形成一个体系之后，记忆起来就很容易了，这样，一个简单的<strong>浅层知识结构</strong>就形成了。</p><p><img src=\"https://static001.geekbang.org/resource/image/5b/ac/5b2f0b9560d9198a9166f5e9016c83ac.jpg?wh=1920x1080\" alt=\"图片\"></p><p>接着，在这个基础上，我们再进行深度的思考，去探索扩展的底层原理，还有它的能力边界，从而形成一个更加<strong>深层次的知识结构</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/3e/18/3e42099e82472869f87e33e9202c1218.jpg?wh=1999x1273\" alt=\"\"></p><p>到目前为止，这些都是理论层面的一些知识，我们还需要进一步探索Kotlin扩展的实际应用场景。这时候，就会发现它的两个主要使用场景，一个是<strong>主动的</strong>，<strong>一个是被动的</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/b4/10/b4a3ce7c3e0b2228161faa4769618a10.jpg?wh=1999x1333\" alt=\"\"></p><p>其实，学习就是一个不断向下挖掘探索的过程。学习Kotlin是这样，学习其他计算机知识也是这样，甚至学习其他领域的知识也是这个道理。</p><h2>思考题</h2><p>在这节课中的所有案例中，我们的“扩展接收者”都是不为空的类型。但实际上，Kotlin的扩展是允许我们为“可为空的类型”进行扩展的。比如说：</p><pre><code class=\"language-plain\">// 不为空的接收者类型\n//     ↓\nfun String.lastElement(): Char? {}\n\n// 可为空的接收者类型\n//     ↓\nfun String?.lastElement(): Char? {}\n</code></pre><p>那么，请问这两种扩展有什么不同？欢迎在评论区分享你的思路，我们下节课再见。</p>","comments":[{"had_liked":false,"id":329766,"user_name":"神秘嘉Bin","can_delete":false,"product_type":"c1","uid":2879116,"ip_address":"","ucode":"6045F09320E5F3","user_header":"https://static001.geekbang.org/account/avatar/00/2b/ee/8c/06f3aef0.jpg","comment_is_top":false,"comment_ctime":1641531065,"is_pvip":false,"replies":[{"id":"120157","content":"哈哈，挺住啊","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641607317,"ip_address":"","comment_id":329766,"utype":1}],"discussion_count":1,"race_medal":0,"score":"57476105913","product_id":100103401,"comment_content":"更新完之后可能已经被开除了，每天都更新多好","like_count":13,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544615,"discussion_content":"哈哈，挺住啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641607317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338107,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1647305631,"is_pvip":false,"replies":[{"id":"123655","content":"很好的答案！推荐大家看看。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1647407798,"ip_address":"","comment_id":338107,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23122142111","product_id":100103401,"comment_content":"扩展本质是静态函数+固定第一个参数，nullable的扩展，就是第一个参数为nullable，这和一个参数是否为空的作用类似，一方面可以接受更广的参数类型，另外一方面在扩展函数内部需要处理为空的情况。这样做是否合适就取决于应用场景了，多数情况还是不要为空为好，代码更简洁，但是在处理网络调用和兼容java的代码等特殊情况下，有的时候不得不处理为空的情况，那就扩展nullable类型。","like_count":5,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556518,"discussion_content":"很好的答案！推荐大家看看。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647407798,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329756,"user_name":"xiaomengjie","can_delete":false,"product_type":"c1","uid":1136848,"ip_address":"","ucode":"4FC7A90B9DFA09","user_header":"https://static001.geekbang.org/account/avatar/00/11/58/d0/749a57e2.jpg","comment_is_top":false,"comment_ctime":1641526531,"is_pvip":false,"replies":[{"id":"120159","content":"赞~分析的不错。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641607376,"ip_address":"","comment_id":329756,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23116363011","product_id":100103401,"comment_content":"1、调用<br>fun String.lastElement(): Char? {}：只能是不可null的String才能调用<br>fun String?.lastElement(): Char? {}：可null String和不可null String都能调用<br>2、实现<br>fun String.lastElement(): Char? {}：返回值为null，只有length == 0<br>fun String?.lastElement(): Char? {}：返回值为null，this == null 或者 length == 0","like_count":5,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544617,"discussion_content":"赞~分析的不错。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641607376,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330008,"user_name":"魏全运","can_delete":false,"product_type":"c1","uid":1090798,"ip_address":"","ucode":"3FED702C724E2A","user_header":"https://static001.geekbang.org/account/avatar/00/10/a4/ee/cffd8ee6.jpg","comment_is_top":false,"comment_ctime":1641727486,"is_pvip":false,"replies":[{"id":"120250","content":"不错~","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641791438,"ip_address":"","comment_id":330008,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18821596670","product_id":100103401,"comment_content":"接受者可空的扩展在遇到空对象调用时不会抛异常，并且允许可空对象调用。","like_count":4,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544964,"discussion_content":"不错~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641791438,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":349485,"user_name":"Sc","can_delete":false,"product_type":"c1","uid":1328986,"ip_address":"","ucode":"E167F9BDDD7760","user_header":"https://static001.geekbang.org/account/avatar/00/14/47/5a/8ae70207.jpg","comment_is_top":false,"comment_ctime":1655990305,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10245924897","product_id":100103401,"comment_content":"很像IOS的 category","like_count":2},{"had_liked":false,"id":331168,"user_name":"郑峰","can_delete":false,"product_type":"c1","uid":1112517,"ip_address":"","ucode":"4D4C0C020E507C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/c5/95b97dfa.jpg","comment_is_top":false,"comment_ctime":1642471678,"is_pvip":false,"replies":[{"id":"120990","content":"不错~","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1642478932,"ip_address":"","comment_id":331168,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10232406270","product_id":100103401,"comment_content":"Note that extensions can be defined with a nullable receiver type. These extensions can be called on an object variable even if its value is null, and they can check for this == null inside the body.<br><br>This way, you can call lastElement() in Kotlin without checking for null, as the check happens inside the extension function.","like_count":2,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546957,"discussion_content":"不错~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642478932,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":356949,"user_name":"昵称C","can_delete":false,"product_type":"c1","uid":1234963,"ip_address":"北京","ucode":"1BB2D537942DC2","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/13/082013bc.jpg","comment_is_top":false,"comment_ctime":1662716857,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5957684153","product_id":100103401,"comment_content":"牛。我看过最好的 Kotlin 课程。大佬的学习方法论很好。","like_count":1},{"had_liked":false,"id":344024,"user_name":"〆WingChing℡ご","can_delete":false,"product_type":"c1","uid":1473139,"ip_address":"","ucode":"EC61CCE1CA7583","user_header":"https://static001.geekbang.org/account/avatar/00/16/7a/73/49cbb7f7.jpg","comment_is_top":false,"comment_ctime":1651197973,"is_pvip":false,"replies":[{"id":"125628","content":"Kotlin跟Swift已经非常接近了。哪个好哪个坏，其实更多的是先入为主，看惯了Swift可能会觉得Kotlin有点怪，反之亦然。Kotlin的语法设计，跟它适配JVM其实没太大关系的。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1651245004,"ip_address":"","comment_id":344024,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5946165269","product_id":100103401,"comment_content":"和 Swift语法相比，感觉上kotlin不是很好理解，语法有点怪异，是不是kt基于jvm要适配java的原因啊","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568871,"discussion_content":"Kotlin跟Swift已经非常接近了。哪个好哪个坏，其实更多的是先入为主，看惯了Swift可能会觉得Kotlin有点怪，反之亦然。Kotlin的语法设计，跟它适配JVM其实没太大关系的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651245004,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343519,"user_name":"尋道","can_delete":false,"product_type":"c1","uid":1163979,"ip_address":"","ucode":"089DCC2ABDCD25","user_header":"https://static001.geekbang.org/account/avatar/00/11/c2/cb/99f8d9fc.jpg","comment_is_top":false,"comment_ctime":1650888690,"is_pvip":false,"replies":[{"id":"125644","content":"没错~","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1651246653,"ip_address":"","comment_id":343519,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5945855986","product_id":100103401,"comment_content":"区别就是接收参数是否可以为空，有 ？参数可空，可处理的范围更广","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568894,"discussion_content":"没错~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651246653,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329799,"user_name":"Emmm","can_delete":false,"product_type":"c1","uid":2883853,"ip_address":"","ucode":"D0F82DD41E5CF0","user_header":"https://static001.geekbang.org/account/avatar/00/2c/01/0d/94f46a96.jpg","comment_is_top":false,"comment_ctime":1641543482,"is_pvip":true,"replies":[{"id":"120154","content":"枚举类是可以扩展的，但并不一定有广泛的应用场景。<br><br>enum class Human {<br>    MAN,<br>    WOMAN<br>}<br><br>val Human.count: Int<br>    get() = Human.values().size","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641607241,"ip_address":"","comment_id":329799,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5936510778","product_id":100103401,"comment_content":"hello，大佬，可以给一下枚举类的扩展吗","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544612,"discussion_content":"枚举类是可以扩展的，但并不一定有广泛的应用场景。\n\nenum class Human {\n    MAN,\n    WOMAN\n}\n\nval Human.count: Int\n    get() = Human.values().size","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641607241,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":2883853,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/01/0d/94f46a96.jpg","nickname":"Emmm","note":"","ucode":"D0F82DD41E5CF0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":544624,"discussion_content":"inline fun &lt;reified T : Enum&lt;*&gt;&gt; Class&lt;T&gt;.getValue(value: String): T? {\n    var resType: T? = null\n    when (this) {\n        Enum1::class.java -&gt; {\n            Enum1.values().forEach {\n                if (it.type == value) {\n                    resType = it as T\n                    return@forEach\n                }\n            }\n        }\n        //省略其他枚举类\n        else -&gt; resType = null\n    }\n    return resType\n}\n其实昨天想要的是这个模板，发现给Enum做扩展不太可能，所以就换成了泛型来约束，扩展Class","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1641609132,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":544612,"ip_address":""},"score":544624,"extra":""},{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":2883853,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/01/0d/94f46a96.jpg","nickname":"Emmm","note":"","ucode":"D0F82DD41E5CF0","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":544756,"discussion_content":"我的读者真实卧虎藏龙啊！期待你更多的分享。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1641696588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":544624,"ip_address":""},"score":544756,"extra":""}]}]},{"had_liked":false,"id":329751,"user_name":"追梦","can_delete":false,"product_type":"c1","uid":2178691,"ip_address":"","ucode":"D6FFBDB4B3750B","user_header":"https://static001.geekbang.org/account/avatar/00/21/3e/83/bb4a5ae5.jpg","comment_is_top":false,"comment_ctime":1641525420,"is_pvip":false,"replies":[{"id":"120158","content":"感谢你的鼓励，我们一起加油~","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641607338,"ip_address":"","comment_id":329751,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5936492716","product_id":100103401,"comment_content":"写的太好了，急不可待的想看下面的内容，催更，催更～～","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544616,"discussion_content":"感谢你的鼓励，我们一起加油~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641607339,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360919,"user_name":"熊妈饭团","can_delete":false,"product_type":"c1","uid":1340649,"ip_address":"美国","ucode":"039315572165E9","user_header":"https://static001.geekbang.org/account/avatar/00/14/74/e9/b74ea2b2.jpg","comment_is_top":false,"comment_ctime":1666975956,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1666975956","product_id":100103401,"comment_content":"不得不说，Andriod 那段扩展函数函数代码应该很经典，奈何有点难读懂。","like_count":0},{"had_liked":false,"id":357176,"user_name":"jim","can_delete":false,"product_type":"c1","uid":1491946,"ip_address":"北京","ucode":"C12DB0F2B570F6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Urc67zDC8R6dh9U1ZFTF36icXewM1seehvOUYUs4hyWSsFzS5WQc2RcrE1Mzs8qtgib5SM5wFrVh22QcQd0JUUBw/132","comment_is_top":false,"comment_ctime":1663037866,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663037866","product_id":100103401,"comment_content":"老师，有没有插件可以查看类的扩展方法？？？","like_count":0},{"had_liked":false,"id":339152,"user_name":"张春亮","can_delete":false,"product_type":"c1","uid":1045303,"ip_address":"","ucode":"3921D2A256B2C9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f3/37/15baf151.jpg","comment_is_top":false,"comment_ctime":1647941796,"is_pvip":false,"replies":[{"id":"123999","content":"是的，那么它们各自的使用场景呢？","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1648029604,"ip_address":"","comment_id":339152,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1647941796","product_id":100103401,"comment_content":"不为空的接收者类型 = 调用的String不可为null<br>可为空的接收者类型 = 调用的String可为null","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557945,"discussion_content":"是的，那么它们各自的使用场景呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648029604,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339150,"user_name":"张春亮","can_delete":false,"product_type":"c1","uid":1045303,"ip_address":"","ucode":"3921D2A256B2C9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f3/37/15baf151.jpg","comment_is_top":false,"comment_ctime":1647941397,"is_pvip":false,"replies":[{"id":"123997","content":"没错","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1648029476,"ip_address":"","comment_id":339150,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1647941397","product_id":100103401,"comment_content":"public final class StringEx {<br>   @Nullable<br>   public final Character lastElement(@NotNull String $this$lastElement) {<br>      Intrinsics.checkNotNullParameter($this$lastElement, &quot;$this$lastElement&quot;);<br>      CharSequence var2 = (CharSequence)$this$lastElement;<br>      return var2.length() == 0 ? null : $this$lastElement.charAt($this$lastElement.length() - 1);<br>   }<br><br>   public final void main() {<br>      String msg = &quot;Hello Wolrd&quot;;<br>      this.lastElement(msg);<br>   }<br>}<br>类内扩展的话反编译之后并不是静态函数","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557943,"discussion_content":"没错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648029476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2988477,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/99/bd/47918534.jpg","nickname":"π_π","note":"","ucode":"AD44386682AEFD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587311,"discussion_content":"怪不得，看的时候就有疑惑了，为什么静态方法可以访问非静态属性呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662973493,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330665,"user_name":"Geek_88bbcf","can_delete":false,"product_type":"c1","uid":2880445,"ip_address":"","ucode":"6E73B054EFE7DA","user_header":"","comment_is_top":false,"comment_ctime":1642088129,"is_pvip":false,"replies":[{"id":"120605","content":"T.() -&gt; Unit是带接受者的函数类型，看看下节课的内容你就懂了哈。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1642133493,"ip_address":"","comment_id":330665,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1642088129","product_id":100103401,"comment_content":"inline fun View.updateLayoutParams(block: T.() -&gt; Unit) {<br>    val params = layoutParams as T<br>    &#47;&#47;不理解1<br>    block(params) <br>    layoutParams = params<br>}<br><br>有个不理解的地方，注释标出来了。这个方法的参数中，block函数不是无参的吗？为什么“不理解1”这个地方可通过block(params)传参呢？烦请解惑~谢谢","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546031,"discussion_content":"T.() -&gt; Unit是带接受者的函数类型，看看下节课的内容你就懂了哈。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1642133493,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":559870,"discussion_content":"T.() -&gt; Unit 这和扩展很像","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649012437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":546031,"ip_address":""},"score":559870,"extra":""}]}]},{"had_liked":false,"id":330109,"user_name":"女孩子家家","can_delete":false,"product_type":"c1","uid":2883845,"ip_address":"","ucode":"F8EDCF8C01430D","user_header":"https://static001.geekbang.org/account/avatar/00/2c/01/05/b70b8ea1.jpg","comment_is_top":false,"comment_ctime":1641800673,"is_pvip":false,"replies":[{"id":"120309","content":"你可以多仔细体会体会，也可以看看其他同学的答案。这个问题我会在后面解释的。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641871077,"ip_address":"","comment_id":330109,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1641800673","product_id":100103401,"comment_content":"这个可为空类型的扩展使用环境是什么样子的?<br>声明可空的类型调用函数不是需要添加 ? 嘛,<br><br>var str:String?=null<br><br>str?.g()<br><br>fun String.g() = this","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545186,"discussion_content":"你可以多仔细体会体会，也可以看看其他同学的答案。这个问题我会在后面解释的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641871077,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329818,"user_name":"Gavin","can_delete":false,"product_type":"c1","uid":2879648,"ip_address":"","ucode":"881EA1DE7A33B8","user_header":"https://static001.geekbang.org/account/avatar/00/2b/f0/a0/43168e73.jpg","comment_is_top":false,"comment_ctime":1641549176,"is_pvip":false,"replies":[{"id":"120155","content":"赞~","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641607257,"ip_address":"","comment_id":329818,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1641549176","product_id":100103401,"comment_content":"fun String.lastElement(): Char? {} <br>会主动校验数据的非空，如果为空会throw exception<br>fun String?.lastElement(): Char? {} <br>不会校验数据是否为空","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544613,"discussion_content":"赞~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641607257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329777,"user_name":"jim","can_delete":false,"product_type":"c1","uid":1491946,"ip_address":"","ucode":"C12DB0F2B570F6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Urc67zDC8R6dh9U1ZFTF36icXewM1seehvOUYUs4hyWSsFzS5WQc2RcrE1Mzs8qtgib5SM5wFrVh22QcQd0JUUBw/132","comment_is_top":false,"comment_ctime":1641535662,"is_pvip":false,"replies":[{"id":"120152","content":"666","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1641606945,"ip_address":"","comment_id":329777,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1641535662","product_id":100103401,"comment_content":"催更，更新太慢了~~~","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544610,"discussion_content":"666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641606945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}