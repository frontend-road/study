{"id":718074,"title":"19｜BabyAGI：根据气候变化自动制定鲜花存储策略","content":"<p>你好，我是黄佳，欢迎来到LangChain实战课！</p><p>在上节课中，我们深入探讨了如何利用CAMEL框架制定出一个高效的鲜花营销方案。然而，LangChain目前是将基于CAMEL框架的代理定义为Simulation Agents（模拟代理）。这种代理在模拟环境中进行角色扮演，试图模拟特定场景或行为，而不是在真实世界中完成具体的任务。</p><p>随着ChatGPT的崭露头角，我们迎来了一种新型的代理——Autonomous Agents（自治代理或自主代理）。这些代理的设计初衷就是能够独立地执行任务，并持续地追求长期目标。在LangChain的代理、工具和记忆这些组件的支持下，<strong>它们能够在无需外部干预的情况下自主运行，这在真实世界的应用中具有巨大的价值。</strong></p><p>目前，GitHub上已有好几个备受关注的“网红”项目，如AutoGPT、BabyAGI和HuggingGPT，它们都代表了自治代理的初步尝试。尽管这些代理仍处于实验阶段，但潜力十分巨大。它们都是基于LangChain框架构建的。通过LangChain，你可以在这些开源项目中轻松地切换和测试多种LLM、使用多种向量存储作为记忆，以及充分利用LangChain的丰富工具集。</p><!-- [[[read_end]]] --><p>今天的这节课，我就带着你看一看这些项目，同时也通过LangChain完成一个 BabyAGI 的实现。</p><h2>AutoGPT</h2><p>Auto-GPT 是由Toran Bruce Richards创建的一个开源的自主AI代理，基于OpenAI的GPT-4语言模型。它的主要功能是<strong>自动链接多个任务</strong>，以实现用户设定的大目标。与传统的聊天机器人（如ChatGPT）不同，用户只需提供一个提示或一组自然语言指令，Auto-GPT 就会通过自动化多步提示过程，将目标分解为子任务，以达到其目标。</p><p><img src=\"https://static001.geekbang.org/resource/image/85/bc/8527f131880785688eac48b10f7e5bbc.png?wh=800x533\" alt=\"\" title=\"图片来源网络\"></p><p>Auto-GPT一出世，就受到了广泛的宣传和追捧，Star数量半年飙升到了150K。</p><p><strong>为什么Auto-GPT吸引了这么多眼球？</strong></p><p>因为与ChatGPT相比，它能够与互联网集成，提供实时数据访问。Auto-GPT 将活动分解为子任务，自我提示（而不是像ChatGPT 那样需要用户多次提示才能把复杂任务完善地完成），并重复该过程，直到达到所提供的目标。</p><p>技术上，Auto-GPT 使用短期记忆管理来保存上下文；同时Auto-GPT 是多模态的，可以处理文本和图像作为输入。</p><p>从具体应用上说，Auto-GPT可以用于各种任务，例如生成文本、执行特定操作和进行网络搜索等。它还可以作为研究助手，帮助用户进行科学研究、市场研究、内容创建、销售线索生成、业务计划创建、产品评论、播客大纲制定等。</p><p>当然，Auto-GPT并不完善，作为一个实验性质的项目，它还存在诸多挑战，比如它的运行成本可能很高，而且它可能会分心或陷入循环。技术上，它的缺陷是没有长期记忆。</p><p>但是，作为一个开源项目，它的优势在于，它展示出了AI的边界和自主行动能力，凸显出了自主代理的潜力，也从实践上验证了人类正朝向人工普通智能（AGI）迈进。<strong>理论上说，更成熟的</strong> <strong>Auto-GPT</strong> <strong>版本可以启动与其他自主代理进行交互过程，实现AI代理之间的对话。</strong></p><p>Auto-GPT 在GitHub上的社区非常活跃，开发者可以分享他们使用Auto-GPT的进展和想法。Auto-GPT 还有一个Hackathon活动，鼓励开发者提交他们的代理进行基准测试和比较。</p><h2>Baby AGI</h2><p>BabyAGI是由中岛洋平（Yohei Nakajima）于2023年3月28日开发的自主任务驱动AI系统。核心在于，它可以根据设定的目标生成、组织、确定优先级以及执行任务。它也使用OpenAI的GPT-4语言模型来理解和创建任务，利用Pinecone向量搜索来存储和检索特定任务的结果，提供执行任务的上下文，并采用LangChain框架进行决策。</p><p>BabyAGI尝试使用预定义的目标进行自我驱动，自动化个人任务管理。它不仅可以自动生成和执行任务，而且还可以根据完成的任务结果生成新任务，并且可以实时确定任务的优先级。</p><p>与传统的AI工具（如ChatGPT）不同，BabyAGI不仅仅是解释查询和提供响应，而且能够根据目标生成任务列表，连续执行它们，并根据先前任务的输出适应性地创建更多任务。</p><p>和Auto-GPT一样，该系统发布后广受关注，也被某些人誉为<strong>完全自主人工智能的起点</strong>。</p><p>在BabyAGI中，你向系统提出一个目标之后，它将不断优先考虑需要实现或完成的任务，以实现该目标。具体来说，系统将形成任务列表，从任务列表中拉出优先级最高的第一个任务，使用 OpenAI API 根据上下文将任务发送到执行代理并完成任务，一旦这些任务完成，它们就会被存储在内存（或者Pinecone这类向量数据库）中，然后，根据目标和上一个任务的结果创建新任务并确定优先级。</p><p>整个过程如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/07/6c/07cbca8cfff33ffa231830eff145556c.png?wh=680x475\" alt=\"\" title=\"图片来源网络\"></p><p>在这个过程中，驱动任务的是三个不同作用的代理。分别是执行代理execution_agent，任务创建代理task_creation_agent，以及优先级设置代理prioritization_agent。</p><ul>\n<li><strong>执行代理</strong>，是系统的核心，利用OpenAI的API来处理任务。这个代理的实现函数有两个参数，目标和任务，用于向 OpenAI 的 API 发送提示，并以字符串形式返回任务结果。</li>\n<li><strong>任务创建代理</strong>，通过OpenAI的API根据当前对象和先前任务的结果创建新任务。这个代理的实现函数有四个参数，目标、上一个任务的结果、任务描述和当前任务列表。这个代理会向 OpenAI 的 API 发送一条提示，该 API 将以字符串形式返回新任务列表。然后，该函数将以字典列表的形式返回这些新任务，其中每个字典都包含任务的名称。</li>\n<li><strong>优先级设置代理</strong>，负责任务列表的排序和优先级，仍然是通过调用OpenAI 的 API 来重新确定任务列表的优先级。这个代理的实现函数有一个参数，即当前任务的 ID。这个代理会向 OpenAI 的 API 发送提示，并返回已重新优先排序为编号列表的新任务列表。</li>\n</ul><p>等一下，我就用这个BabyAGI的框架来带着你开发一个能够根据气候变化自动制定鲜花存储策略的AI智能代理。</p><h2>HuggingGPT</h2><p>在Yongliang Shen的论文《HuggingGPT: Solving AI Tasks with ChatGPT and its Friends in Hugging Face》中，介绍了HuggingGPT的系统。HuggingGPT的工作流程包括四个阶段。</p><ol>\n<li>任务规划：LLM（例如ChatGPT）解析用户请求，生成任务列表，并确定任务之间的执行顺序和资源依赖关系。</li>\n<li>模型选择：LLM根据Hugging Face上的专家模型描述，为任务分配适当的模型。</li>\n<li>任务执行：整合各个任务端点上的专家模型，执行分配的任务。</li>\n<li>响应生成：LLM整合专家的推断结果，生成工作流摘要，并给用户提供最终的响应。</li>\n</ol><p>HuggingGPT的设计，使其能够根据用户请求自动生成计划，并使用外部模型，从而整合多模态感知能力，并处理多个复杂的AI任务。此外，这种流程还允许HuggingGPT持续从任务特定的专家模型中吸收能力，从而实现可增长和可扩展的AI能力。</p><p><img src=\"https://static001.geekbang.org/resource/image/7e/36/7ec5769743e7ddf58883ca74385cbd36.png?wh=1467x1453\" alt=\"\" title=\"图片来源论文\"></p><p>文章还提到，HuggingGPT的优势在于，<strong>它能够使用不同的模型来执行特定的任务</strong>，如图像分类、对象检测、图像描述等。例如，它使用 OpenCV 的 OpenPose 模型来分析图像中小朋友的姿势，并使用其他模型生成新图像和描述。</p><p>不难看出，尽管实现过程各有特点，但这些自主类的AI代理应用的基本思想和流程还是很类似的。关键是利用LLM的推理能力生成任务，确定任务优先级，然后执行任务，实现目标。</p><h2>根据气候变化自动制定鲜花存储策略</h2><p>下面，我们就解析一下 LangChain 中 BabyAGI 的具体实现。这里的 “BabyAGI” 是一个简化版的实现，其核心功能是自动创建、优先级排序和执行任务。</p><p>首先，我们导入相关的库。</p><pre><code class=\"language-plain\"># 设置API Key\nimport os\nos.environ[\"OPENAI_API_KEY\"] = 'Your OpenAI API Key\n\n# 导入所需的库和模块\nfrom collections import deque\nfrom typing import Dict, List, Optional, Any\nfrom langchain.chains import LLMChain\nfrom langchain.prompts import PromptTemplate\nfrom langchain.embeddings import OpenAIEmbeddings\nfrom langchain.llms import BaseLLM, OpenAI\nfrom langchain.vectorstores.base import VectorStore\nfrom pydantic import BaseModel, Field\nfrom langchain.chains.base import Chain\nfrom langchain.vectorstores import FAISS\nimport faiss\nfrom langchain.docstore import InMemoryDocstore\n</code></pre><p>然后，我们初始化OpenAIEmbedding作为嵌入模型，并使用Faiss作为向量数据库存储任务信息。</p><pre><code class=\"language-plain\"># 定义嵌入模型\nembeddings_model = OpenAIEmbeddings()\n# 初始化向量存储\nembedding_size = 1536\nindex = faiss.IndexFlatL2(embedding_size)\nvectorstore = FAISS(embeddings_model.embed_query, index, InMemoryDocstore({}), {})\n</code></pre><p>下面是定义任务生成链，基于给定的条件，这个链可以创建新任务。例如，它可以根据最后一个完成的任务的结果来生成新任务。</p><pre><code class=\"language-plain\"># 任务生成链\nclass TaskCreationChain(LLMChain):\n&nbsp; &nbsp; \"\"\"负责生成任务的链\"\"\"\n&nbsp; &nbsp; @classmethod\n&nbsp; &nbsp; def from_llm(cls, llm: BaseLLM, verbose: bool = True) -&gt; LLMChain:\n&nbsp; &nbsp; &nbsp; &nbsp; \"\"\"从LLM获取响应解析器\"\"\"\n&nbsp; &nbsp; &nbsp; &nbsp; task_creation_template = (\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"You are a task creation AI that uses the result of an execution agent\"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \" to create new tasks with the following objective: {objective},\"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \" The last completed task has the result: {result}.\"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \" This result was based on this task description: {task_description}.\"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \" These are incomplete tasks: {incomplete_tasks}.\"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \" Based on the result, create new tasks to be completed\"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \" by the AI system that do not overlap with incomplete tasks.\"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \" Return the tasks as an array.\"\n&nbsp; &nbsp; &nbsp; &nbsp; )\n&nbsp; &nbsp; &nbsp; &nbsp; prompt = PromptTemplate(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; template=task_creation_template,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_variables=[\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"result\",\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"task_description\",\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"incomplete_tasks\",\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"objective\",\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ],\n&nbsp; &nbsp; &nbsp; &nbsp; )\n&nbsp; &nbsp; &nbsp; &nbsp; return cls(prompt=prompt, llm=llm, verbose=verbose)\n</code></pre><p>下面是定义任务优先级链，这个链负责重新排序任务的优先级。给定一个任务列表，它会返回一个新的按优先级排序的任务列表。</p><pre><code class=\"language-plain\"># 任务优先级链\nclass TaskPrioritizationChain(LLMChain):\n&nbsp; &nbsp; \"\"\"负责任务优先级排序的链\"\"\"\n&nbsp; &nbsp; @classmethod\n&nbsp; &nbsp; def from_llm(cls, llm: BaseLLM, verbose: bool = True) -&gt; LLMChain:\n&nbsp; &nbsp; &nbsp; &nbsp; \"\"\"从LLM获取响应解析器\"\"\"\n&nbsp; &nbsp; &nbsp; &nbsp; task_prioritization_template = (\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"You are a task prioritization AI tasked with cleaning the formatting of and reprioritizing\"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \" the following tasks: {task_names}.\"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \" Consider the ultimate objective of your team: {objective}.\"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \" Do not remove any tasks. Return the result as a numbered list, like:\"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \" #. First task\"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \" #. Second task\"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \" Start the task list with number {next_task_id}.\"\n&nbsp; &nbsp; &nbsp; &nbsp; )\n&nbsp; &nbsp; &nbsp; &nbsp; prompt = PromptTemplate(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; template=task_prioritization_template,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_variables=[\"task_names\", \"next_task_id\", \"objective\"],\n&nbsp; &nbsp; &nbsp; &nbsp; )\n&nbsp; &nbsp; &nbsp; &nbsp; return cls(prompt=prompt, llm=llm, verbose=verbose)\n</code></pre><p>下面是定义任务执行链，这个链负责执行具体的任务，并返回结果。</p><pre><code class=\"language-plain\"># 任务执行链\nclass ExecutionChain(LLMChain):\n&nbsp; &nbsp; \"\"\"负责执行任务的链\"\"\"\n\n&nbsp; &nbsp; @classmethod\n&nbsp; &nbsp; def from_llm(cls, llm: BaseLLM, verbose: bool = True) -&gt; LLMChain:\n&nbsp; &nbsp; &nbsp; &nbsp; \"\"\"从LLM获取响应解析器\"\"\"\n&nbsp; &nbsp; &nbsp; &nbsp; execution_template = (\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"You are an AI who performs one task based on the following objective: {objective}.\"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \" Take into account these previously completed tasks: {context}.\"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \" Your task: {task}.\"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \" Response:\"\n&nbsp; &nbsp; &nbsp; &nbsp; )\n&nbsp; &nbsp; &nbsp; &nbsp; prompt = PromptTemplate(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; template=execution_template,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_variables=[\"objective\", \"context\", \"task\"],\n&nbsp; &nbsp; &nbsp; &nbsp; )\n&nbsp; &nbsp; &nbsp; &nbsp; return cls(prompt=prompt, llm=llm, verbose=verbose)\n</code></pre><p>之后，我们定义一系列功能函数，实现 get_next_task、prioritize_tasks、_get_top_tasks 以及 execute_task 等具体功能。</p><pre><code class=\"language-plain\">def get_next_task(\n&nbsp; &nbsp; task_creation_chain: LLMChain,\n&nbsp; &nbsp; result: Dict,\n&nbsp; &nbsp; task_description: str,\n&nbsp; &nbsp; task_list: List[str],\n&nbsp; &nbsp; objective: str,\n) -&gt; List[Dict]:\n&nbsp; &nbsp; \"\"\"Get the next task.\"\"\"\n&nbsp; &nbsp; incomplete_tasks = \", \".join(task_list)\n&nbsp; &nbsp; response = task_creation_chain.run(\n&nbsp; &nbsp; &nbsp; &nbsp; result=result,\n&nbsp; &nbsp; &nbsp; &nbsp; task_description=task_description,\n&nbsp; &nbsp; &nbsp; &nbsp; incomplete_tasks=incomplete_tasks,\n&nbsp; &nbsp; &nbsp; &nbsp; objective=objective,\n&nbsp; &nbsp; )\n&nbsp; &nbsp; new_tasks = response.split(\"\\n\")\n&nbsp; &nbsp; return [{\"task_name\": task_name} for task_name in new_tasks if task_name.strip()]\n\n\n\ndef prioritize_tasks(\n&nbsp; &nbsp; task_prioritization_chain: LLMChain,\n&nbsp; &nbsp; this_task_id: int,\n&nbsp; &nbsp; task_list: List[Dict],\n&nbsp; &nbsp; objective: str,\n) -&gt; List[Dict]:\n&nbsp; &nbsp; \"\"\"Prioritize tasks.\"\"\"\n&nbsp; &nbsp; task_names = [t[\"task_name\"] for t in task_list]\n&nbsp; &nbsp; next_task_id = int(this_task_id) + 1\n&nbsp; &nbsp; response = task_prioritization_chain.run(\n&nbsp; &nbsp; &nbsp; &nbsp; task_names=task_names, next_task_id=next_task_id, objective=objective\n&nbsp; &nbsp; )\n&nbsp; &nbsp; new_tasks = response.split(\"\\n\")\n&nbsp; &nbsp; prioritized_task_list = []\n&nbsp; &nbsp; for task_string in new_tasks:\n&nbsp; &nbsp; &nbsp; &nbsp; if not task_string.strip():\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue\n&nbsp; &nbsp; &nbsp; &nbsp; task_parts = task_string.strip().split(\".\", 1)\n&nbsp; &nbsp; &nbsp; &nbsp; if len(task_parts) == 2:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; task_id = task_parts[0].strip()\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; task_name = task_parts[1].strip()\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prioritized_task_list.append({\"task_id\": task_id, \"task_name\": task_name})\n&nbsp; &nbsp; return prioritized_task_list\n\n\n\ndef _get_top_tasks(vectorstore, query: str, k: int) -&gt; List[str]:\n&nbsp; &nbsp; \"\"\"Get the top k tasks based on the query.\"\"\"\n&nbsp; &nbsp; results = vectorstore.similarity_search_with_score(query, k=k)\n&nbsp; &nbsp; if not results:\n&nbsp; &nbsp; &nbsp; &nbsp; return []\n&nbsp; &nbsp; sorted_results, _ = zip(*sorted(results, key=lambda x: x[1], reverse=True))\n&nbsp; &nbsp; return [str(item.metadata[\"task\"]) for item in sorted_results]\n\n\n\ndef execute_task(\n&nbsp; &nbsp; vectorstore, execution_chain: LLMChain, objective: str, task: str, k: int = 5\n) -&gt; str:\n&nbsp; &nbsp; \"\"\"Execute a task.\"\"\"\n&nbsp; &nbsp; context = _get_top_tasks(vectorstore, query=objective, k=k)\n&nbsp; &nbsp; return execution_chain.run(objective=objective, context=context, task=task)\n</code></pre><p>然后，我们定义BabyAGI，这是主类，它控制整个系统的运行流程，包括添加任务、输出任务列表、执行任务等。</p><pre><code class=\"language-plain\"># BabyAGI 主类\nclass BabyAGI(Chain, BaseModel):\n&nbsp; &nbsp; \"\"\"BabyAGI代理的控制器模型\"\"\"\n\n&nbsp; &nbsp; task_list: deque = Field(default_factory=deque)\n&nbsp; &nbsp; task_creation_chain: TaskCreationChain = Field(...)\n&nbsp; &nbsp; task_prioritization_chain: TaskPrioritizationChain = Field(...)\n&nbsp; &nbsp; execution_chain: ExecutionChain = Field(...)\n&nbsp; &nbsp; task_id_counter: int = Field(1)\n&nbsp; &nbsp; vectorstore: VectorStore = Field(init=False)\n&nbsp; &nbsp; max_iterations: Optional[int] = None\n\n&nbsp; &nbsp; class Config:\n&nbsp; &nbsp; &nbsp; &nbsp; \"\"\"Configuration for this pydantic object.\"\"\"\n\n&nbsp; &nbsp; &nbsp; &nbsp; arbitrary_types_allowed = True\n\n&nbsp; &nbsp; def add_task(self, task: Dict):\n&nbsp; &nbsp; &nbsp; &nbsp; self.task_list.append(task)\n\n&nbsp; &nbsp; def print_task_list(self):\n&nbsp; &nbsp; &nbsp; &nbsp; print(\"\\033[95m\\033[1m\" + \"\\n*****TASK LIST*****\\n\" + \"\\033[0m\\033[0m\")\n&nbsp; &nbsp; &nbsp; &nbsp; for t in self.task_list:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print(str(t[\"task_id\"]) + \": \" + t[\"task_name\"])\n\n&nbsp; &nbsp; def print_next_task(self, task: Dict):\n&nbsp; &nbsp; &nbsp; &nbsp; print(\"\\033[92m\\033[1m\" + \"\\n*****NEXT TASK*****\\n\" + \"\\033[0m\\033[0m\")\n&nbsp; &nbsp; &nbsp; &nbsp; print(str(task[\"task_id\"]) + \": \" + task[\"task_name\"])\n\n&nbsp; &nbsp; def print_task_result(self, result: str):\n&nbsp; &nbsp; &nbsp; &nbsp; print(\"\\033[93m\\033[1m\" + \"\\n*****TASK RESULT*****\\n\" + \"\\033[0m\\033[0m\")\n&nbsp; &nbsp; &nbsp; &nbsp; print(result)\n\n&nbsp; &nbsp; @property\n&nbsp; &nbsp; def input_keys(self) -&gt; List[str]:\n&nbsp; &nbsp; &nbsp; &nbsp; return [\"objective\"]\n\n&nbsp; &nbsp; @property\n&nbsp; &nbsp; def output_keys(self) -&gt; List[str]:\n&nbsp; &nbsp; &nbsp; &nbsp; return []\n\n&nbsp; &nbsp; def _call(self, inputs: Dict[str, Any]) -&gt; Dict[str, Any]:\n&nbsp; &nbsp; &nbsp; &nbsp; \"\"\"Run the agent.\"\"\"\n&nbsp; &nbsp; &nbsp; &nbsp; objective = inputs[\"objective\"]\n&nbsp; &nbsp; &nbsp; &nbsp; first_task = inputs.get(\"first_task\", \"Make a todo list\")\n&nbsp; &nbsp; &nbsp; &nbsp; self.add_task({\"task_id\": 1, \"task_name\": first_task})\n&nbsp; &nbsp; &nbsp; &nbsp; num_iters = 0\n&nbsp; &nbsp; &nbsp; &nbsp; while True:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if self.task_list:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; self.print_task_list()\n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Step 1: Pull the first task\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; task = self.task_list.popleft()\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; self.print_next_task(task)\n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Step 2: Execute the task\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = execute_task(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; self.vectorstore, self.execution_chain, objective, task[\"task_name\"]\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; )\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this_task_id = int(task[\"task_id\"])\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; self.print_task_result(result)\n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Step 3: Store the result in Pinecone\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result_id = f\"result_{task['task_id']}_{num_iters}\"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; self.vectorstore.add_texts(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; texts=[result],\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; metadatas=[{\"task\": task[\"task_name\"]}],\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ids=[result_id],\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; )\n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Step 4: Create new tasks and reprioritize task list\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_tasks = get_next_task(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; self.task_creation_chain,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; task[\"task_name\"],\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [t[\"task_name\"] for t in self.task_list],\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; objective,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; )\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for new_task in new_tasks:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; self.task_id_counter += 1\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_task.update({\"task_id\": self.task_id_counter})\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; self.add_task(new_task)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; self.task_list = deque(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prioritize_tasks(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; self.task_prioritization_chain,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this_task_id,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list(self.task_list),\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; objective,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; )\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; )\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_iters += 1\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if self.max_iterations is not None and num_iters == self.max_iterations:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"\\033[91m\\033[1m\" + \"\\n*****TASK ENDING*****\\n\" + \"\\033[0m\\033[0m\"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; )\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break\n&nbsp; &nbsp; &nbsp; &nbsp; return {}\n\n&nbsp; &nbsp; @classmethod\n&nbsp; &nbsp; def from_llm(\n&nbsp; &nbsp; &nbsp; &nbsp; cls, llm: BaseLLM, vectorstore: VectorStore, verbose: bool = False, **kwargs\n&nbsp; &nbsp; ) -&gt; \"BabyAGI\":\n&nbsp; &nbsp; &nbsp; &nbsp; \"\"\"Initialize the BabyAGI Controller.\"\"\"\n&nbsp; &nbsp; &nbsp; &nbsp; task_creation_chain = TaskCreationChain.from_llm(llm, verbose=verbose)\n&nbsp; &nbsp; &nbsp; &nbsp; task_prioritization_chain = TaskPrioritizationChain.from_llm(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; llm, verbose=verbose\n&nbsp; &nbsp; &nbsp; &nbsp; )\n&nbsp; &nbsp; &nbsp; &nbsp; execution_chain = ExecutionChain.from_llm(llm, verbose=verbose)\n&nbsp; &nbsp; &nbsp; &nbsp; return cls(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; task_creation_chain=task_creation_chain,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; task_prioritization_chain=task_prioritization_chain,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; execution_chain=execution_chain,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vectorstore=vectorstore,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; **kwargs,\n&nbsp; &nbsp; &nbsp; &nbsp; )\n</code></pre><p>主执行部分，这是代码的入口点，定义了一个目标（分析北京市今天的气候情况，并提出鲜花储存策略），然后初始化并运行BabyAGI。</p><pre><code class=\"language-plain\"># 主执行部分\nif __name__ == \"__main__\":\n&nbsp; &nbsp; OBJECTIVE = \"分析一下北京市今天的气候情况，写出鲜花储存策略。\"\n&nbsp; &nbsp; llm = OpenAI(temperature=0)\n&nbsp; &nbsp; verbose = False\n&nbsp; &nbsp; max_iterations: Optional[int] = 6\n&nbsp; &nbsp; baby_agi = BabyAGI.from_llm(llm=llm, vectorstore=vectorstore, \n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; verbose=verbose, \n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_iterations=max_iterations)\n&nbsp; &nbsp; baby_agi({\"objective\": OBJECTIVE})\n</code></pre><p>运行这个程序之后，产生了下面的结果。</p><pre><code class=\"language-plain\">'''*****TASK LIST*****\n\n1: Make a todo list\n\n*****NEXT TASK*****\n\n1: Make a todo list\n\n*****TASK RESULT*****\n\n\n\n\n\n1. Gather data on current weather conditions in Beijing, including temperature, humidity, wind speed, and precipitation.\n\n2. Analyze the data to determine the best storage strategy for flowers.\n\n3. Research the optimal temperature, humidity, and other environmental conditions for flower storage.\n\n4. Develop a plan for storing flowers in Beijing based on the data and research.\n\n5. Implement the plan and monitor the flowers for any changes in condition.\n\n6. Make adjustments to the plan as needed.\n\n*****TASK LIST*****\n\n2: Identify the most suitable materials for flower storage in Beijing.\n3: Investigate the effects of temperature, humidity, and other environmental factors on flower storage.\n4: Research the best methods for preserving flowers in Beijing.\n5: Develop a plan for storing flowers in Beijing that takes into account the data and research.\n6: Monitor the flowers for any changes in condition and make adjustments to the plan as needed.\n7: Analyze the current climate conditions in Beijing and write out a strategy for flower storage.\n8: Create a report summarizing the findings and recommendations for flower storage in Beijing.\n\n*****NEXT TASK*****\n\n2: Identify the most suitable materials for flower storage in Beijing.\n\n*****TASK RESULT*****\n\n\n\n\n\nIn order to store flowers in Beijing, it is important to consider the current weather conditions. Today, the temperature in Beijing is around 18°C with a humidity of around 70%. This means that the air is relatively dry and cool, making it suitable for storing flowers.\n\nThe best materials for flower storage in Beijing would be materials that are breathable and moisture-resistant. Examples of suitable materials include paper, cardboard, and fabric. These materials will help to keep the flowers fresh and prevent them from wilting. Additionally, it is important to keep the flowers away from direct sunlight and heat sources, as this can cause them to dry out quickly.\n\n*****TASK LIST*****\n\n3: Analyze the current climate conditions in Beijing and write out a strategy for flower storage.\n4: Investigate the effects of temperature, humidity, and other environmental factors on flower storage in Beijing.\n5: Research the best methods for preserving flowers in Beijing.\n6: Develop a plan for storing flowers in Beijing that takes into account the data and research.\n7: Monitor the flowers for any changes in condition and make adjustments to the plan as needed.\n8: Create a report summarizing the findings and recommendations for flower storage in Beijing, and provide suggestions for improvement.\n\n*****NEXT TASK*****\n\n3: Analyze the current climate conditions in Beijing and write out a strategy for flower storage.\n\n*****TASK RESULT*****\n\n\n\n\n\nBased on the current climate conditions in Beijing, the best strategy for flower storage is to keep the flowers in a cool, dry place. This means avoiding direct sunlight and keeping the flowers away from any sources of heat. Additionally, it is important to keep the flowers away from any sources of moisture, such as humidifiers or air conditioners. The flowers should also be kept away from any sources of strong odors, such as perfumes or cleaning products. Finally, it is important to keep the flowers away from any sources of pests, such as insects or rodents. To ensure the flowers remain in optimal condition, it is important to regularly check the temperature and humidity levels in the storage area.\n\n*****TASK LIST*****\n\n4: Monitor the flowers for any changes in condition and make adjustments to the plan as needed.\n1: Analyze the impact of different types of flowers on flower storage in Beijing.\n2: Compare the effectiveness of different flower storage strategies in Beijing.\n3: Investigate the effects of temperature, humidity, and other environmental factors on flower storage in Beijing.\n5: Research the best methods for preserving flowers in Beijing.\n6: Develop a plan for storing flowers in Beijing that takes into account the data and research.\n7: Investigate the effects of different storage materials on flower preservation in Beijing.\n8: Develop a system for monitoring the condition of flowers in storage in Beijing.\n9: Create a checklist for flower storage in Beijing that can be used to ensure optimal conditions.\n10: Identify potential risks associated with flower storage in Beijing and develop strategies to mitigate them.\n11: Create a report summarizing the findings and recommendations for flower storage in Beijing, and provide suggestions for improvement.\n\n*****NEXT TASK*****\n\n4: Monitor the flowers for any changes in condition and make adjustments to the plan as needed.\n\n*****TASK RESULT*****\n\n\n\n\n\nI will monitor the flowers for any changes in condition and make adjustments to the plan as needed. This includes checking for signs of wilting, discoloration, or other signs of deterioration. I will also monitor the temperature and humidity levels in the storage area to ensure that the flowers are kept in optimal conditions. If necessary, I will adjust the storage plan to ensure that the flowers remain in good condition. Additionally, I will keep track of the expiration date of the flowers and adjust the storage plan accordingly.\n\n*****TASK LIST*****\n\n5: Analyze the current climate conditions in Beijing and how they affect flower storage.\n6: Investigate the effects of different storage containers on flower preservation in Beijing.\n7: Develop a system for tracking the condition of flowers in storage in Beijing.\n8: Identify potential pests and diseases that could affect flower storage in Beijing and develop strategies to prevent them.\n9: Create a report summarizing the findings and recommendations for flower storage in Beijing, and provide suggestions for improvement.\n10: Develop a plan for storing flowers in Beijing that takes into account the data and research.\n11: Compare the cost-effectiveness of different flower storage strategies in Beijing.\n12: Research the best methods for preserving flowers in Beijing in different seasons.\n13: Investigate the effects of temperature, humidity, and other environmental factors on flower storage in Beijing.\n14: Investigate the effects of different storage materials on flower preservation in Beijing.\n15: Analyze the impact of different types of flowers on flower storage in Beijing.\n16: Compare the effectiveness of different flower storage strategies in Beijing.\n17: Create a checklist for flower storage in Beijing that can be used to ensure optimal conditions.\n18: Identify potential risks associated with flower storage in\n\n*****NEXT TASK*****\n\n5: Analyze the current climate conditions in Beijing and how they affect flower storage.\n\n*****TASK RESULT*****\n\n\n\n\n\nBased on the current climate conditions in Beijing, the most suitable materials for flower storage would be materials that are breathable and moisture-resistant. This would include materials such as burlap, cotton, and linen. Additionally, it is important to ensure that the flowers are stored in a cool, dry place, away from direct sunlight. Furthermore, it is important to monitor the flowers for any changes in condition and make adjustments to the plan as needed. Finally, it is important to make a to-do list to ensure that all necessary steps are taken to properly store the flowers.\n\n*****TASK LIST*****\n\n6: Develop a plan for storing flowers in Beijing that takes into account the local climate conditions.\n1: Investigate the effects of different storage containers on flower preservation in Beijing.\n2: Investigate the effects of different storage materials on flower preservation in Beijing in different seasons.\n3: Analyze the impact of different types of flowers on flower storage in Beijing.\n4: Compare the cost-effectiveness of different flower storage strategies in Beijing.\n5: Research the best methods for preserving flowers in Beijing in different weather conditions.\n7: Develop a system for tracking the condition of flowers in storage in Beijing.\n8: Identify potential pests and diseases that could affect flower storage in Beijing and develop strategies to prevent them.\n9: Create a report summarizing the findings and recommendations for flower storage in Beijing, and provide suggestions for improvement.\n10: Create a checklist for flower storage in Beijing that can be used to ensure optimal conditions.\n11: Identify potential risks associated with flower storage in Beijing.\n\n*****NEXT TASK*****\n\n6: Develop a plan for storing flowers in Beijing that takes into account the local climate conditions.\n\n*****TASK RESULT*****\nBased on the previously completed tasks, I have developed a plan for storing flowers in Beijing that takes into account the local climate conditions. \n\nFirst, I will analyze the current climate conditions in Beijing, including temperature, humidity, and air quality. This will help me identify the most suitable materials for flower storage in Beijing. \n\nSecond, I will create a to-do list of tasks that need to be completed in order to properly store the flowers. This list should include tasks such as selecting the right materials for flower storage, ensuring the flowers are kept in a cool and dry environment, and regularly monitoring the flowers for any changes in condition. \n\nThird, I will develop a strategy for flower storage that takes into account the local climate conditions. This strategy should include steps such as selecting the right materials for flower storage, ensuring the flowers are kept in a cool and dry environment, and regularly monitoring the flowers for any changes in condition. \n\nFinally, I will monitor the flowers for any changes in condition and make adjustments to the plan as needed. This will help ensure that the flowers are stored in the most suitable environment for their preservation.\n\n*****TASK ENDING*****'''\n</code></pre><p>从结构上看，内容以循环方式进行组织，首先是 TASK LIST（任务列表），接着是 NEXT TASK（下一个任务），然后是 TASK RESULT（任务结果）。</p><p>每个任务结果似乎都是基于前一个任务的输出。随着自主代理思考的逐步深入，子任务的重点从获取当前的天气数据，到确定最佳的花朵储存策略，再到对策略的实际执行和调整。</p><p>6 轮循环之后，在任务的最终结果部分提供了具体的步骤和策略，以确保花朵在最佳的条件下储存。至于这个策略有多大用途，就仁者见仁智者见智了吧。</p><h2>总结时刻</h2><p>模拟代理主要关注模拟特定环境中的行为，而自主代理则更加关注独立性、自适应性和长期的任务执行。</p><p>本节课中我们介绍的 Auto-GPT、BabyAGI 以及 HuggingGPT，它们作为自主代理（Autonomous Agents）的代表，旨在创建更加普适和强大的算法，这些算法能够处理各种任务，并在没有明确编程指令的情况下自我改进。</p><p>这些自主代理的特点，我列表总结如下，供你参考。</p><p><img src=\"https://static001.geekbang.org/resource/image/56/d1/56d4bdbcaec0deba243a4d7cf6eb71d1.jpg?wh=1482x666\" alt=\"\"></p><p>未来，这种自主代理将在企业运营的任务分配、项目管理和资源调度等环节中起到至关重要的作用。想象一下，随着人工智能技术的飞速发展，会有众多的自主趋动型的应用程序被开发出来，优化任务管理，AI 将涵盖从项目开始到结束的整个过程，确保每个任务都得到有效的监控和组织。</p><h2>思考题</h2><ol>\n<li>请你阅读 <a href=\"https://github.com/Significant-Gravitas/AutoGPT\">AutoGPT</a> 的细节，并构造自己的AI代理。</li>\n<li>请你阅读 <a href=\"https://arxiv.org/pdf/2303.17580.pdf\">HuggingGPT</a> 的细节，并构造自己的AI代理。</li>\n</ol><p>期待在留言区看到你的分享，如果觉得内容对你有帮助，也欢迎分享给有需要的朋友！最后如果你学有余力，可以进一步学习下面的延伸阅读。</p><h2>延伸阅读</h2><ol>\n<li>GitHub 项目 <a href=\"https://github.com/Significant-Gravitas/AutoGPT\">AutoGPT</a> <a href=\"https://autogpt.net/\">官网</a></li>\n<li>GitHub 项目 <a href=\"https://github.com/yoheinakajima/babyagi\">BabyAGI</a> <a href=\"https://yoheinakajima.com/task-driven-autonomous-agent-utilizing-gpt-4-pinecone-and-langchain-for-diverse-applications/\">官网</a></li>\n<li>论文 <a href=\"https://arxiv.org/pdf/2303.17580.pdf\">HuggingGPT: Solving AI Tasks with ChatGPT and its Friends in Hugging Face</a> <a href=\"https://huggingface.co/spaces/microsoft/HuggingGPT\">官网</a></li>\n</ol>","comments":[{"had_liked":false,"id":385156,"user_name":"不吃苦瓜","can_delete":false,"product_type":"c1","uid":3623296,"ip_address":"美国","ucode":"7C8D2994D0A722","user_header":"https://static001.geekbang.org/account/avatar/00/37/49/80/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1702216775,"is_pvip":false,"replies":[{"id":140410,"content":"感谢你的喜欢。这个Credit应该送给论文的作者和LangChain。","user_name":"作者回复","user_name_real":"编辑","uid":1809833,"ctime":1702311776,"ip_address":"瑞士","comment_id":385156,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100617601,"comment_content":"单从这babyAGI的DEMO就决定了这个课值不值，太赞了，写的太好了","like_count":4,"discussions":[{"author":{"id":1809833,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/a9/4602808f.jpg","nickname":"黄佳","note":"","ucode":"8EC41D2EAB0E3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633564,"discussion_content":"感谢你的喜欢。这个Credit应该送给论文的作者和LangChain。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702311777,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"瑞士","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386309,"user_name":"AAT天宇","can_delete":false,"product_type":"c1","uid":1030684,"ip_address":"浙江","ucode":"492DB37E0A4E8F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/1c/9255261b.jpg","comment_is_top":false,"comment_ctime":1704523757,"is_pvip":false,"replies":[{"id":140908,"content":"当然，将自主代理与CAMEL框架结合起来，可以为解决复杂的、多学科问题以及增强长期记忆能力创造强大的组合。值得一试。","user_name":"作者回复","user_name_real":"编辑","uid":1809833,"ctime":1705066030,"ip_address":"瑞士","comment_id":386309,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100617601,"comment_content":"如果将自主代理和Camel结合呢？\n\n通过自主代理的方式，解决长期记忆的问题，将自主代理的示例编程领域专家；\n通过Camel代理的方式，完成多校色，多领域认知和复杂任务的解决问题；","like_count":2,"discussions":[{"author":{"id":1809833,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/a9/4602808f.jpg","nickname":"黄佳","note":"","ucode":"8EC41D2EAB0E3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635712,"discussion_content":"当然，将自主代理与CAMEL框架结合起来，可以为解决复杂的、多学科问题以及增强长期记忆能力创造强大的组合。值得一试。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705066031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"瑞士","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":382696,"user_name":"陈东","can_delete":false,"product_type":"c1","uid":2213995,"ip_address":"广西","ucode":"FCDE6D237CC621","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Ge7uhlEVxicQT73YuomDPrVKI8UmhqxKWrhtO5GMNlFjrHWfd3HAjgaSribR4Pzorw8yalYGYqJI4VPvUyPzicSKg/132","comment_is_top":false,"comment_ctime":1697814699,"is_pvip":true,"replies":[{"id":139436,"content":"从目前项目需求的角度来讲，LangChain在企业应用较多的地方还是通过企业内部的文档资料，开发RAG文档系统，用于资料检索。目前有很多这方面的项目，研究型的，以及企业希望实际部署的。\n从纯AI应用角度，我看到有合作的初创公司在开发基于LLM的个人助理。从产品设计的角度，发布的App会比单纯使用ChatGPT更方遍，比如说可以根据你手机内的图片自动记账，自动添加行程表什么的。\n很多可能性。同学也可以多参与一些AI的峰会，交流会。看看大家都在用AI和大模型做什么。我也是管中窥豹。只知一二。\n有更多的想法，看到好的AI应用，请随时分享。其它同学也可以多分享。","user_name":"作者回复","user_name_real":"作者","uid":1809833,"ctime":1698132411,"ip_address":"瑞士","comment_id":382696,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100617601,"comment_content":"hugging和大模型在老师的企业工作实践产生的什么作用？和大家分享吗？学习了还找不到技术点的抓手。","like_count":2,"discussions":[{"author":{"id":1809833,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/a9/4602808f.jpg","nickname":"黄佳","note":"","ucode":"8EC41D2EAB0E3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630134,"discussion_content":"从目前项目需求的角度来讲，LangChain在企业应用较多的地方还是通过企业内部的文档资料，开发RAG文档系统，用于资料检索。目前有很多这方面的项目，研究型的，以及企业希望实际部署的。\n从纯AI应用角度，我看到有合作的初创公司在开发基于LLM的个人助理。从产品设计的角度，发布的App会比单纯使用ChatGPT更方遍，比如说可以根据你手机内的图片自动记账，自动添加行程表什么的。\n很多可能性。同学也可以多参与一些AI的峰会，交流会。看看大家都在用AI和大模型做什么。我也是管中窥豹。只知一二。\n有更多的想法，看到好的AI应用，请随时分享。其它同学也可以多分享。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1698132411,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"瑞士","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384617,"user_name":"Liberalism","can_delete":false,"product_type":"c1","uid":1233947,"ip_address":"北京","ucode":"BD0A293B928668","user_header":"https://static001.geekbang.org/account/avatar/00/12/d4/1b/6444e933.jpg","comment_is_top":false,"comment_ctime":1701244486,"is_pvip":false,"replies":[{"id":140919,"content":"我的意思就是通过Agent来自动自发地进行项目管理、流程管理、工单分配等等。智能化。自主。你的看法呢？有咩有具体业务场景咱们讨论讨论。","user_name":"作者回复","user_name_real":"编辑","uid":1809833,"ctime":1705069637,"ip_address":"瑞士","comment_id":384617,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100617601,"comment_content":"老师您好，在结尾处您有提到 AI 在未来项目管理领域有很大的想象空间，方便细讲一下吗？","like_count":1,"discussions":[{"author":{"id":1809833,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/a9/4602808f.jpg","nickname":"黄佳","note":"","ucode":"8EC41D2EAB0E3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635725,"discussion_content":"我的意思就是通过Agent来自动自发地进行项目管理、流程管理、工单分配等等。智能化。自主。你的看法呢？有咩有具体业务场景咱们讨论讨论。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705069637,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"瑞士","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383929,"user_name":"鲸鱼","can_delete":false,"product_type":"c1","uid":1052643,"ip_address":"北京","ucode":"71437C1C601040","user_header":"https://static001.geekbang.org/account/avatar/00/10/0f/e3/c49aa508.jpg","comment_is_top":false,"comment_ctime":1699953634,"is_pvip":false,"replies":[{"id":140085,"content":"可以，换吧。我也经常遇到错误，我就换一个。毕竟这就是个Demo。","user_name":"作者回复","user_name_real":"编辑","uid":1809833,"ctime":1699978024,"ip_address":"瑞士","comment_id":383929,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100617601,"comment_content":"老师，vectorstore可以换成其他的吗？比如Chroma？faiss这个库安装遇到问题了，上网搜了一圈，运行时总是遇到各种问题，一直跑不起来","like_count":1,"discussions":[{"author":{"id":1809833,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/a9/4602808f.jpg","nickname":"黄佳","note":"","ucode":"8EC41D2EAB0E3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631802,"discussion_content":"可以，换吧。我也经常遇到错误，我就换一个。毕竟这就是个Demo。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699978024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"瑞士","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2041021,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/24/bd/4f6cca90.jpg","nickname":"Leo","note":"","ucode":"A6D89F617B70BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":646203,"discussion_content":"pip install faiss-cpu或者pip install faiss-gpu试试？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1717554035,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"美国","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":382742,"user_name":"陈东","can_delete":false,"product_type":"c1","uid":2213995,"ip_address":"广西","ucode":"FCDE6D237CC621","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Ge7uhlEVxicQT73YuomDPrVKI8UmhqxKWrhtO5GMNlFjrHWfd3HAjgaSribR4Pzorw8yalYGYqJI4VPvUyPzicSKg/132","comment_is_top":false,"comment_ctime":1697956755,"is_pvip":true,"replies":[{"id":139434,"content":"生产系统的话，同学可以考虑把API通过Dockers打包，部署到云平台。供外界调用。比如我们在外面常常会用AWS部署一个服务。","user_name":"作者回复","user_name_real":"编辑","uid":1809833,"ctime":1698132102,"ip_address":"瑞士","comment_id":382742,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100617601,"comment_content":"练习以上代码自己部署本地，还是使用云平台合适，老师平时生产时使用什么设备生产，我想练习到生产一起使用，请老师可以推荐吗？谢谢。","like_count":1,"discussions":[{"author":{"id":1809833,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/a9/4602808f.jpg","nickname":"黄佳","note":"","ucode":"8EC41D2EAB0E3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630132,"discussion_content":"生产系统的话，同学可以考虑把API通过Dockers打包，部署到云平台。供外界调用。比如我们在外面常常会用AWS部署一个服务。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698132102,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"瑞士","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":382850,"user_name":"曙光","can_delete":false,"product_type":"c1","uid":3716551,"ip_address":"浙江","ucode":"5D1CBFDFA229A2","user_header":"https://static001.geekbang.org/account/avatar/00/38/b5/c7/ed1dcbed.jpg","comment_is_top":false,"comment_ctime":1698118996,"is_pvip":false,"replies":[{"id":139462,"content":"我这边跑着没啥问题呀\nlangchain                 0.0.305\nlangchain-experimental    0.0.23\n同学你的版本是啥？\n这里的BaseModel不是LangChain哈，是pydantic数据模型\npydantic                  1.10.12\n同学检查一下","user_name":"作者回复","user_name_real":"编辑","uid":1809833,"ctime":1698154430,"ip_address":"瑞士","comment_id":382850,"utype":1}],"discussion_count":8,"race_medal":0,"score":2,"product_id":100617601,"comment_content":"老师，运行代码的时候报这个错误，Chain, BaseModel他们共同基类是哪个呀？\nTraceback (most recent call last):\n  File &quot;D:\\py_dev\\langchain19\\BabyAGI_CN.py&quot;, line 160, in &lt;module&gt;\n    class BabyAGI(Chain, BaseModel):\nTypeError: metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases\n","like_count":0,"discussions":[{"author":{"id":1024164,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a0/a4/b060c723.jpg","nickname":"阿斯蒂芬","note":"","ucode":"61D5E3BDA4EBC5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630252,"discussion_content":"我也遇到了这个问题，查了下 pydantic 是 2.4.2，看了下pydantic官网，有2.x 和 1.10 两种，将 pydantic 换成跟老师一样的后，代码可以正常运行了","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1698218010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1809833,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/a9/4602808f.jpg","nickname":"黄佳","note":"","ucode":"8EC41D2EAB0E3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1024164,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a0/a4/b060c723.jpg","nickname":"阿斯蒂芬","note":"","ucode":"61D5E3BDA4EBC5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630350,"discussion_content":"谢谢同学的分享！！！有你真好🤏","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1698331713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":630252,"ip_address":"瑞士","group_id":0},"score":630350,"extra":""}]},{"author":{"id":2909770,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/66/4a/a5ecf67a.jpg","nickname":"在路上1619","note":"","ucode":"A2F828C18FBCD4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645968,"discussion_content":"幸好过来看看，我也遇到这个问题了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1717059259,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3883506,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/IaqbNXDfdKdm10dLDcwvnNZPxDF5iab2oktPtYhWXQ8DjnVorgnv0CmQxPsNdv7yJyM7ZSucYgPDCbg6TADgoAw/132","nickname":"Geek_e47e7b","note":"","ucode":"E4F192C2479467","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":643516,"discussion_content":"是的，需要使用pydantic 1.10.12的版本才行","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1714384537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3874907,"avatar":"","nickname":"Geek_06aecc","note":"","ucode":"A7938C828F1E40","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":643172,"discussion_content":"确实是版本兼容的问题。我用了2.x也跑不了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1714103911,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":false,\"user_type\":0,\"source\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1809833,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/a9/4602808f.jpg","nickname":"黄佳","note":"","ucode":"8EC41D2EAB0E3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630183,"discussion_content":"我这边跑着没啥问题呀\nlangchain                 0.0.305\nlangchain-experimental    0.0.23\n同学你的版本是啥？\n这里的BaseModel不是LangChain哈，是pydantic数据模型\npydantic                  1.10.12\n同学检查一下","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1698154430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"瑞士","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":3799942,"avatar":"https://static001.geekbang.org/account/avatar/00/39/fb/86/ede0e5f3.jpg","nickname":"Oswald","note":"","ucode":"0E0D78F35A3DE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1809833,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/a9/4602808f.jpg","nickname":"黄佳","note":"","ucode":"8EC41D2EAB0E3C","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":641551,"discussion_content":"为啥会出现这个问题呀？pydantic和 langchain版本都是正确的，是跟faiss有关吗？我的是faiss1.8.0cpu版。Retrying langchain.embeddings.openai.embed_with_retry.&lt;locals&gt;._embed_with_retry in 4.0 seconds as it raised APIError: Invalid response object from API: &#39;{&#34;detail&#34;:[{&#34;type&#34;:&#34;string_type&#34;,&#34;loc&#34;:[&#34;body&#34;,&#34;input&#34;,0],&#34;msg&#34;:&#34;Input should be a valid string&#34;,&#34;input&#34;:[17620,98871,15120,17297,70090,23530,37271,36827,9554,30320,242,20022,247,40474,13828,113,3922,62543,20834,165,110,250,45951,109,161,61857,25359,29857,244,40198,98,1811],&#34;url&#34;:&#34;https://errors.pydantic.dev/2.5/v/string_type&#34;}]}&#39; (HTTP response code was 422).\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1712754785,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":630183,"ip_address":"江西","group_id":0},"score":641551,"extra":""},{"author":{"id":3799942,"avatar":"https://static001.geekbang.org/account/avatar/00/39/fb/86/ede0e5f3.jpg","nickname":"Oswald","note":"","ucode":"0E0D78F35A3DE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1809833,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/a9/4602808f.jpg","nickname":"黄佳","note":"","ucode":"8EC41D2EAB0E3C","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":641553,"discussion_content":"我知道了，这个是我使用本地模型chatglm出现的错误，github上`https://github.com/abetlen/llama-cpp-python/issues/187`  llama大模型有时也会出现这个错误，好像是一个api的bug，用openai的api似乎就没有问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1712755311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":630183,"ip_address":"江西","group_id":0},"score":641553,"extra":""}]}]},{"had_liked":false,"id":394056,"user_name":"yanyu-xin","can_delete":false,"product_type":"c1","uid":1899757,"ip_address":"中国香港","ucode":"3AA389F9E4C236","user_header":"","comment_is_top":false,"comment_ctime":1725680028,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100617601,"comment_content":"用国产大模型代替 OpenAI ，调试很久，才终于成功！太难啦。\n\n###1  出现Chain, BaseModel 共同基类错误。按留言安装 pydantic 1.10.12 \n\n###2  替换模型：\n# 旧代码1： \nembeddings_model = OpenAIEmbeddings()\n# 新代码1：（用百川模型）\nfrom langchain_community.embeddings import BaichuanTextEmbeddings \nembeddings_model = BaichuanTextEmbeddings(baichuan_api_key=&quot; sk-KEY&quot;)  #此用你的百川智能API KEY 代替\n# 旧代码2：\nllm = OpenAI(temperature=0)\n# 新代码2：（用阿里模型）\nllm = ChatOpenAI(\n        api_key=&quot;sk-KYE&quot;,   # 此用您的阿里 DASHSCOPE_API_KEY替换\n        base_url=&quot;https:&#47;&#47;dashscope.aliyuncs.com&#47;compatible-mode&#47;v1&quot;, \n        model_name=&quot;qwen-turbo&quot;)\n\n###3  更新导入路径\n# 旧代码3：\nfrom langchain.embeddings import OpenAIEmbeddings\nfrom langchain.llms import BaseLLM, OpenAI\nfrom langchain.vectorstores import FAISS\nfrom langchain.docstore import InMemoryDocstore\n# 新代码3：\nfrom langchain_community.embeddings import OpenAIEmbeddings  \nfrom langchain_community.llms import BaseLLM, OpenAI  \nfrom langchain_community.vectorstores import FAISS  \nfrom langchain_community.docstore.in_memory import InMemoryDocstore  \n\n###4  发生异常: AssertionError 。\nexception: no description：  results = vectorstore.similarity_search_with_score(query, k=k)\n查找 FAISS 文档，并采用其代码类似例子调试，发现 vectorstore 调用 FAISS 时，index 是不能随意设置的，修改如下：\n# 旧代码4：\nembedding_size = 1536\n# 新代码4：\nembedding_size = 1024\n\n###5  出现不定期的代码错误，在  # Step 2: Execute the task  中 发生异常: ValueError\ninvalid literal for int() with base 10: &#39;#&#39; ， this_task_id = int(task[&quot;task_id&quot;]) \n这个错误在代码前2轮循环中是不会产生的，但在第3轮循环产生。检查代码，task字典中的 task_id  值是‘#’ 号，不是数字，但是这是模型自动生成。而模型的生成是很魔幻的，如何是好？\n检查任务优先级模块，核查提示词，发现要求的生成的例子是：#. First task   ，  #. Second task  格式的。将 # 改为数字，一举成功！\n# 旧代码5\n&quot; #. First task&quot;\n&quot; #. Second task&quot;\n# 新代码5\n&quot; 1. First task&quot;\n&quot; 2. Second task&quot;","like_count":2},{"had_liked":false,"id":393054,"user_name":"chenyang","can_delete":false,"product_type":"c1","uid":3692736,"ip_address":"上海","ucode":"3E56A8A605C619","user_header":"https://static001.geekbang.org/account/avatar/00/38/58/c0/d1d488b0.jpg","comment_is_top":false,"comment_ctime":1722613954,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100617601,"comment_content":"老师，请问task1执行时，怎么获得北京当前的天气状况的呀？ 这里没看到用到search相关的tools呀","like_count":0},{"had_liked":false,"id":392720,"user_name":"张申傲","can_delete":false,"product_type":"c1","uid":1182372,"ip_address":"北京","ucode":"22D46BC529BA8A","user_header":"https://static001.geekbang.org/account/avatar/00/12/0a/a4/828a431f.jpg","comment_is_top":false,"comment_ctime":1721618960,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":2,"score":2,"product_id":100617601,"comment_content":"第19讲打卡~","like_count":0}]}