{"id":772007,"title":"10｜资源和脚本异常指标：监听资源和脚本状态，收集异常数据","content":"<p>你好，我是三桥。</p><p>前两节课，我们学习了读取网页指标和封装接口状态的方法，同时通过实战把有效信息转化为数据指标模型，并且封装到了前端全链路SDK里面。</p><p>今天，我们继续设计另一个数据指标：前端资源状态。</p><h2>前端资源是用户体验的重要资产</h2><p>曾经有一个前端项目我印象特别深刻，主要是做H5营销活动的前端工程。</p><p>我评估完这个前端工程后，发现两个有趣的问题。</p><p>首先，这个项目是基于Vue技术栈实现的，src目录下有超过200个目录，每个目录就是一个独立的营销活动。目录内不仅包含了JavaScript代码和CSS代码，还包括图片和视频。</p><p>第二，使用本地和生产环境打包后运行项目发现，每个活动页面加载的前端JavaScript文件超过300个，而且每个页面加载时间接近5秒以上。</p><p>我就好奇，难道这个项目一直没有用户反馈加载慢的问题吗？我认为肯定有的。那为什么没有前端同学去优化这个项目呢？我猜，要么是能力有限，要么是改造工程量大。</p><p>像这种前端项目，不影响业务使用和用户体验倒还好，但如果因为加载速度慢导致用户留存率低，那真的只能怪前端同学了。</p><p>类似加载超过300个JavaScript文件这样的问题，其实是由于前端工程的打包工具没处理好，导致所有目录的JS逻辑都被打包进来了，并且是一次性统一加载的。</p><!-- [[[read_end]]] --><p>我从这个项目总结出一个结论，那就是前端资源是Web应用在用户体验上的重要资产，如果我们不能提前发现请求资源的问题，迟早都会影响我们的用户，甚至产品的体验。</p><p>那问题来了，在前端全链路的解决方案中，我们应该重点关注前端哪些资源的哪些问题呢？</p><p>我认为有3个地方需要重点监听资源的状态，监听前端资源下载状态、记录前端资源加载耗时以及监听前端脚本异常报错。</p><h2>怎样全局监听前端资源状态</h2><p>我阅读过不少前端工程项目代码，其中有不少还是会使用 <code>onerror</code> 来捕获图片下载失败事件，然后执行 <code>onerror</code> 函数。下面就是一段使用 <code>onerror</code> 事件的示例代码。</p><pre><code class=\"language-xml\">&lt;html&gt;\n\t&lt;img&nbsp;\n\t\tid=\"errorImage\"\n\t\tsrc=\"https://static001.geekbang.org/resource/image/66/b1/66c84d9eff5102e8a79c81fbc4b061b1.jpg\"&nbsp;\n\t/&gt;\n\t&lt;script&gt;\n\t\tconst img = document.getElementById('errorImage')\n\t\timg.onerror = function() {\n\t\t\t// 在这里处理当图片下载或渲染异常时的逻辑\n\t\t}\n\t&lt;/script&gt;\n&lt;/html&gt;\n</code></pre><p>事实上，一个前端工程项目里不止一张图片，不可能对每张图片都实现一遍 <code>onerror</code> 事件，所以上述的实现方案并不能直接应用在项目中。</p><p>正确的做法是绑定全局 <code>error</code> 事件来监听资源加载情况。例如可以通过下面这种代码格式来初始化 <code>error</code> 事件。</p><pre><code class=\"language-javascript\">window.addEventListener('error', handlerError, true)\n</code></pre><p>需要注意的是，上述代码的 <code>error</code> 事件是全局的，也就是说它能监听到前端页面运行时报错的事件，包括 <code>&lt;script&gt;</code> 和 <code>&lt;link&gt;</code> 引入的JavaScript和CSS文件。我们统一监听的，是JS和CSS文件、图片以及音视频等最基本的前端资源。</p><p>具体实现的逻辑如下代码。</p><pre><code class=\"language-javascript\">window.addEventListener('error', (event) =&gt; {\n  let target = event.target || event.srcElement;\n  let isResTarget = isResourceTarget(target as HTMLElement);\n  if (isResTarget) {\n\t// 处理全链路关注的前端资源\n    saveResourceError(event)\n&nbsp; }\n})\n</code></pre><p>从上述代码可以看到一个新的函数 <code>isResourceTarget</code> ，它是一个元素过滤器，可以筛选前端页面重点关注的资源文件。具体的实现逻辑参考如下代码。</p><pre><code class=\"language-javascript\">export const isResourceTarget = (target: HTMLElement) =&gt;\n&nbsp; target instanceof HTMLScriptElement ||\n&nbsp; target instanceof HTMLLinkElement ||\n&nbsp; target instanceof HTMLImageElement ||\n&nbsp; target instanceof HTMLVideoElement ||\n&nbsp; target instanceof HTMLAudioElement\n</code></pre><p>当然了， <code>isResourceTarget</code> 函数只判断匹配了脚本、链接、图片、音频和视频这5种常见的元素资源。如果需要监控更多的前端资源，你可以根据项目的实际情况扩展该函数。</p><p>第二个函数是 <code>saveResourceError</code> 。在匹配到错误的资源类型后，这个函数会把匹配到的内容转换成全链路需要的信息，并存储到 <code>resources</code> 数组内。具体的实现逻辑代码参考如下。</p><pre><code class=\"language-javascript\">public saveError(event: ErrorEvent) {\n&nbsp; const target = event.target || event.srcElement;\n&nbsp; \n  const nodeName = (target as HTMLElement).nodeName\n&nbsp; \n  const url = (target as HTMLElement).getAttribute('src') || (target as HTMLElement).getAttribute('href')\n&nbsp; \n  const dataId = hashCode(`${nodeName}${event.message}${url}`)\n\n&nbsp; const traceDataResource: TraceDataResource = {\n&nbsp; &nbsp; dataId,\n&nbsp; &nbsp; name: 'resource-load-error',\n&nbsp; &nbsp; level: TraceDataSeverity.Error,\n&nbsp; &nbsp; message: event.message,\n&nbsp; &nbsp; time: getTimestamp(),\n&nbsp; &nbsp; type: TraceDataTypes.RESOURCE\n&nbsp; }\n&nbsp; this.resources.push(traceDataResource)\n}\n</code></pre><p>有点细心的前端同学会发现在上述代码里有2个有趣的地方。</p><p>第一地方是 <code>dataId</code> 的生成。我们希望通过一些关键的信息组合，再配合 <code>hashCode</code> 的算法，得出一串字符串。</p><p>为什么是这样的算法逻辑呢？我们试想想，如果 <code>nodeName</code> 、 <code>message</code> 以及 <code>url</code> 三个字段值都相同，那最终的 <code>dataId</code> 一定是相同的。假设在某个时间，全链路监控发现了大量相同的 <code>dataId</code> ，那我们就有理由相信前端应用出现了一些共性的问题，例如某一张图一直加载失败。</p><p>第二个地方是我用了 <code>this.resources.push</code> 存储一份错误的资源信息。为什么是存储而不是直接发起上报请求呢？因为如果出现大量的资源访问异常，那么 <code>error</code> 事件就会捕获到大量的错误资源，如果我们的实现是立刻发起一次上报行为，那么就有可能发生洪水般的请求，影响用户体验。</p><p>总得来说，我们实现全链路的目标就是把有问题的资源收集回来。</p><h2>是否可以发现加载慢的资源？</h2><p>在前端工程项目里，JavaScript是负责页面功能和交互的，CSS是负责页面布局的。这两种资源加载速度的快慢，都会影响到用户访问前端页面的首屏加载速度。</p><p>另外，有些前端项目经过长期的需求迭代后，JavaScript文件的数量越来越多，体积会越来越大，同样也会让用户访问页面的加载时间更长。</p><p>那怎样做才能获取到前端资源的加载耗时呢？</p><p>在Web技术标准里，<code>PerformanceObserver</code> 对象是一个性能监测对象，可以生成一个观察者回调函数，然后使用  <code>observe()</code>  方法监视实体对象为 <code>resource</code> 的资源，并调用该观察者的回调函数。</p><p>好了，我们现在就通过 <code>PerformanceObserver</code> 对象实现前端资源加载速度的实时监听。</p><p>由于我们的全链路SDK是基于Class类封装，所以首先需要在SDK的代码基础上增加 <code>PerformanceObserver</code> 观察者对象，具体实现代码逻辑如下。</p><pre><code class=\"language-typescript\">export class BaseTrace implements BaseTraceInterface {\n\n  public observer = null\n\n  public constructor(options: TraceOptions) {\n    // 忽略其它业务逻辑\n    \n    this.observer = new PerformanceObserver((list, observer) =&gt; {\n      list.getEntries().forEach((entry) =&gt; {\n        if (entry.entryType === 'resource') {\n          this.handleObserverResource(entry as PerformanceResourceTiming)\n        }\n      });\n    });\n  }\n}\n</code></pre><p>在上述代码里，我们在BaseTrace类的构造函数中创建了观察者函数，并在回调函数内判断。如果当前实体资源是resource类型，那就要进入 <code>handleObserverResource</code> 函数处理逻辑。</p><p>接着说说 <code>handleObserverResource</code> 函数内部。首先是通过实体资源对象的duration属性值判断耗时时长。我们设定了每个资源加载时长超过1秒时，就会上报全链路监控。具体的实现逻辑如下代码。</p><pre><code class=\"language-typescript\">export class BaseTrace implements BaseTraceInterface {\n  \n  public resources: TraceDataResource[] = []\n  public observer = null\n\n  public handleObserverResource(entry: PerformanceResourceTiming) {\n    if (entry.entryType === 'resource') {\n      let level = TraceDataSeverity.Info\n      if (entry.duration &gt; 1000 &amp;&amp; entry.duration &lt; 1500) {\n        level = TraceDataSeverity.Warning\n      } else  if (entry.duration &gt; 1500) {\n        level = TraceDataSeverity.Error\n      }\n      entry.duration &gt; 1000 &amp;&amp; this.resources.push({\n        url: entry.name,\n        name: `${entry.entryType}-duration-${entry.initiatorType}`,\n        type: TraceDataTypes.PERF,\n        level,\n        message: `duration:${Math.round(entry.duration)}`,\n        time: getTimestamp(),\n        dataId: hashCode(`${entry.entryType}-${entry.name}`),\n      })\n    }\n  }\n}\n</code></pre><p>我们是通过 <code>entry.duration</code> 属性值得到的时间，以1000毫秒至1500毫秒之间和超过1500毫秒两种情况来判断资源性能问题的严重级别。如果命中了我们预设的性能问题，就把相关实体资源记录到 <code>resources</code> 属性内。</p><p>最后，在SDK初始化后，再调用 <code>observe()</code> 来触发resource资源的监控事件。具体的实现代码如下。</p><pre><code class=\"language-typescript\">export class BaseTrace implements BaseTraceInterface {\n\n&nbsp; public observer = null\n\n&nbsp; public constructor(options: TraceOptions) {\n&nbsp; &nbsp; // 忽略其它业务逻辑\n&nbsp; }\n\n  public static init(options: TraceOptions): BaseTrace {\n    const traceSdk = new BaseTrace(options)\n    \n    traceSdk.observer.observe({\n      entryTypes: [\"resource\"],\n    });\n    \n    // 忽略部分逻辑\n    window.traceSdk = traceSdk\n    return traceSdk\n  }\n}\n</code></pre><p>就这样，我们完整地实现了监听耗时较长的前端资源的逻辑。</p><p>实际上，前端资源加载速度的快慢，在网页指标里的FCP和LCP里都能够体现出来。但这里的实现方案，就是细化FCP和LCP里面的资源加载部分的时间细节，通过资源加载时间，我们能很轻松地判断FCP和LCP优化的方向。</p><p>我们再次强调一点，在前端全链路的监控维度里，JavaScript和CSS是用户体验最重要的核心资源，必须重点关注它们的加载成功率和性能。</p><h2>如何有效监听脚本异常</h2><p>只要学过前端技术的同学都知道，JavaScript是一门弱类型的语言，无论我们把代码写得如何完美，都肯定存在着运行报错的问题。</p><p>那么，在前端全链路的设计里，应该如何把脚本错误和全链路结合起来呢？我们以前面课程已实现的代码作为基础进行适配改造。</p><p>首先，我们在全局监听 <code>error</code> 事件的直接调用 <code>saveError</code> 函数，不再判断是否前端资源。例如下面代码。</p><pre><code class=\"language-javascript\">public onGlobalError() {\n  const _t = this\n&nbsp; window.addEventListener('error', (event) =&gt; {\n&nbsp; &nbsp; _t.saveError(event)\n&nbsp; })\n}\n</code></pre><p>接着，把是否前端资源的判断逻辑放在 <code>saveError</code> 函数内。</p><pre><code class=\"language-javascript\">public saveError(event: ErrorEvent) {\n  const target = event.target || event.srcElement;\n  const isResTarget = isResourceTarget(target as HTMLElement);\n  const nodeName = (target as HTMLElement).nodeName\n\n  if (!isResTarget) {\n    const traceData: TraceTypeData = {\n      dataId: 0,\n      name: 'script-error',\n      level: TraceDataSeverity.Error,\n      message: event.message,\n      time: getTimestamp(),\n      type: TraceDataTypes.JAVASCRIPT,\n      stack: event.error.stack\n    }\n    this.resources.push(traceData)\n  } else {\n    const url = (target as HTMLElement).getAttribute('src') || (target as HTMLElement).getAttribute('href')\n    const traceData: TraceTypeData = {\n      dataId: hashCode(`${nodeName}${event.message}${url}`),\n      name: 'resource-load-error',\n      level: TraceDataSeverity.Warning,\n      message: event.message,\n      time: getTimestamp(),\n      type: TraceDataTypes.RESOURCE,\n      stack: null\n    }\n    this.resources.push(traceData)\n  }\n}\n</code></pre><p>为什么我们要把 <code>isResourceTarget</code> 的判断放在 <code>saveError</code> 内呢？主要原因有2个。第一，无论资源加载失败还是脚本失败，都会触发全局 <code>error</code> 事件。第二，由于我们已经设计好全链路的数据结构，所以无论是哪种错误，数据字段和内容几乎没有差异。</p><p>因此， <code>saveError</code> 函数是可以当作一个通用error信息存储器。</p><p>好了，经过 <code>isResTarget</code> 字段判断是否为前端资源后，我们就可以再创建一份错误信息对象。</p><p>由于本节课我们只重点学习前端资源和脚本错误两种错误事件，所以，对于链路日志中的 <code>name</code> 、 <code>level</code> 、 <code>type</code> 三个字段，我会根据实际的情况采用不同的值。例如，如果当前是前端资源， <code>name</code> 就用 <code>resource-load-error</code> 固定值， <code>level</code> 就使用警告 <code>Warning</code> ， <code>type</code> 属性采用资源 <code>RESOURCE</code>   。</p><h3>Vue的特殊性</h3><p>另外，现在很多前端项目都是基于Vue技术栈构建的，除了JavaScript的全局error事件，Vue框架也提供了Vue组件内部异常捕获的全局事件errorHandler。</p><p>errorHandler事件官方的定义是，为应用内抛出的未捕获错误指定一个全局处理函数。也就是说，Vue应用组件内如果出行运行时错误的逻辑，又没做捕获处理，那么就会触发errorHandler事件。</p><p>所以，当我们使用Vue这类框架做项目时，为了确保覆盖更完整的业务链路和错误问题，还需要在该事件下记录全链路的相关日志。参考代码如下。</p><pre><code class=\"language-javascript\">app.config.errorHandler = (err, instance, info) =&gt; {\n&nbsp; // 处理错误，例如：报告给一个服务\n&nbsp; const dataId = hashCode(`${err.name}${event.message}${url}`)&nbsp;&nbsp;\n&nbsp; const traceTypeData = {\n&nbsp; &nbsp; dataId,\n&nbsp; &nbsp; name: 'Vue-error',\n&nbsp; &nbsp; level: TraceDataSeverity.Warning,\n&nbsp; &nbsp; message: `${event.toString()}(${info})`,\n&nbsp; &nbsp; time: getTimestamp(),\n&nbsp; &nbsp; type: TraceDataTypes.VUE,\n&nbsp; &nbsp; stack: err.stack\n&nbsp; }\n}\n</code></pre><h2>总结</h2><p>前端资源是Web应用的重要资产，因为有了它们，Web才能给用户提供完整的Web功能。</p><p>在前端全链路的监控范围里，全链路应该重点关心有3种资源类的通用问题。它们分别是资源文件加载状态、资源响应时长以及脚本运行时报错。</p><p>当然了，这3种事件都是最常见的问题，在实际项目中，还不止这些。例如用户上传图片是否成功？音视频是否能播放？页面表单能否按正常流程提交等等。</p><p>前端页面的每一步交互动作，都会给用户带来最真实的感受。把最基础的前端资源加载的稳定性、资源的加载速度以及业务逻辑的兼容性做到极致，是每一个前端同学需要提高的技能。</p><p>下节课，我们会学习另外一种特殊日志，行为日志。</p><h2>思考题</h2><p>在这节课中，我们一共学习了监听三种通用性问题的实现方法。那么除了这些通用问题，不妨思考一下，在你负责的前端项目里，还有哪些需要我们重点关注的资源类问题？</p><p>欢迎你在留言区和我交流。如果觉得有所收获，也可以把课程分享给更多的朋友一起学习。我们下节课见！</p>","neighbors":{"left":{"article_title":"09｜接口指标：监听接口状态，收集页面接口异常数据","id":771719},"right":{"article_title":"11｜用户行为指标：如何有效监听用户交互行为？","id":772186}},"comments":[{"had_liked":false,"id":392577,"user_name":"苏果果","can_delete":false,"product_type":"c1","uid":2852467,"ip_address":"北京","ucode":"12A62ED032F345","user_header":"https://static001.geekbang.org/account/avatar/00/2b/86/73/5190bbde.jpg","comment_is_top":true,"comment_ctime":1721270734,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100759401,"comment_content":"完整源码入口：\nhttps:&#47;&#47;github.com&#47;sankyutang&#47;fontend-trace-geekbang-course","like_count":0},{"had_liked":false,"id":390432,"user_name":"特伦酥","can_delete":false,"product_type":"c1","uid":2882267,"ip_address":"浙江","ucode":"4D9F000D504F83","user_header":"https://static001.geekbang.org/account/avatar/00/2b/fa/db/8c1fc63b.jpg","comment_is_top":false,"comment_ctime":1715326976,"is_pvip":false,"replies":[{"id":142582,"content":"代码已发布。链接如下：\nhttps:&#47;&#47;github.com&#47;sankyutang&#47;fontend-trace-geekbang-course","user_name":"作者回复","user_name_real":"作者","uid":1327155,"ctime":1720406232,"ip_address":"广东","comment_id":390432,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100759401,"comment_content":"请问老师，课程中的示例代码仓库在哪里呢？","like_count":1,"discussions":[{"author":{"id":1327155,"avatar":"https://static001.geekbang.org/account/avatar/00/14/40/33/11e434ba.jpg","nickname":"三橋sankyu 🐩","note":"","ucode":"2129405EA8D3D7","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":647662,"discussion_content":"代码已发布。链接如下：\nhttps://github.com/sankyutang/fontend-trace-geekbang-course","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1720406232,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":390617,"user_name":"向东是大海","can_delete":false,"product_type":"c1","uid":2046992,"ip_address":"广东","ucode":"A9FE1049D0D144","user_header":"https://static001.geekbang.org/account/avatar/00/1f/3c/10/61efe672.jpg","comment_is_top":false,"comment_ctime":1715779083,"is_pvip":false,"replies":[{"id":142666,"content":"是自定义的。合并三个字段内容并转码，目的是准确生成同一个问题都能生成相同dataId。\ndataId生成逻辑算法并非唯一。dataId是用于确认同一个问题，例如100个用户访问读取个人信息接口，如果接口出现异常，那么100个用户100次请求，dataId是相同的。","user_name":"作者回复","user_name_real":"编辑","uid":1327155,"ctime":1721205162,"ip_address":"广东","comment_id":390617,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100759401,"comment_content":"老师，const dataId = hashCode(`${err.name}${event.message}${url}`) 。这里的 hashCode() 是自定义函数吗？是怎么的算法？","like_count":0,"discussions":[{"author":{"id":1327155,"avatar":"https://static001.geekbang.org/account/avatar/00/14/40/33/11e434ba.jpg","nickname":"三橋sankyu 🐩","note":"","ucode":"2129405EA8D3D7","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":648202,"discussion_content":"是自定义的。合并三个字段内容并转码，目的是准确生成同一个问题都能生成相同dataId。\ndataId生成逻辑算法并非唯一。dataId是用于确认同一个问题，例如100个用户访问读取个人信息接口，如果接口出现异常，那么100个用户100次请求，dataId是相同的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1721205163,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]}]}