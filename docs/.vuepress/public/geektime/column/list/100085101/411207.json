{"id":411207,"title":"10 | 为什么 100% 的测试覆盖率是可以做到的？","content":"<p>你好，我是郑晔！</p><p>上一讲我们谈到了测试覆盖率，讲了如何在实际的项目中利用测试覆盖率发现没有覆盖到的代码。最后，我们留下了一个问题：测试覆盖率应该设置成多少？我给出的答案是 100%，但这显然是一个令很多人崩溃的答案。别急，这一讲我们就来说说怎样向着 100%的测试覆盖率迈进。</p><p>很多人对测试覆盖率的反对几乎是本能的，核心原因就是测试覆盖率是一个数字。我在《10x 程序员工作法》中曾经说过，<a href=\"https://time.geekbang.org/column/article/76929\">要尽可能地把自己的工作数字化</a>。本来这是一件好事，但是，很多管理者就会倾向于把它变成一个 KPI（Key Performance Indicator，关键绩效指标）。KPI 常常是上下级博弈的地方，上级希望高一点，下级希望低一点。所以，从本质上说，很多人对测试覆盖率的反对，首先是源于对 KPI 本能的恐惧。</p><p>抛开这种本能的恐惧，我们先来分析一下，如果我们想得到更高质量的代码，测试肯定是越多越好。那多到什么程度算最多呢？答案肯定是 100%。如果把测试覆盖率设置成 100%，就没有那么多扯皮的地方了。比如，你设成了 80%，肯定有人问为啥不设置成 85%；当你设置成 85%的时候，就会有人问为啥不是 90%，而且他们的理由肯定是一样的：测试覆盖率越高越好。那我设置成 100%，肯定不会有人再问为啥不设置成更高的。</p><!-- [[[read_end]]] --><p>现在你知道了，我们把覆盖率设置成 100% 这应该是极限的标准了。接下来，要回答的一个问题就是，怎么把覆盖率做成 100%。</p><h2>向 100% 迈进</h2><p>首先，我们需要明确的一点是，我们用测试覆盖的代码主要是我们自己编写的代码。为什么要强调这一点呢？因为很多时候，我们会涉及使用第三方程序库，而第三方程序库的功能不应该由我们来验证。比如  Jackson 将对象转换为 JSON 是否转得正确，其实我们是不关心的，这是 Jackson 这个程序库要来保证的。</p><p>之所以要先强调这一点，因为在很多人编写的代码中，自己编写的业务代码和第三方程序库的代码常常是混杂在一起的。我们工作的重点是，<strong>保证自己编写的代码 100% 测试覆盖。</strong>这意味着什么呢？</p><p><strong>首先，让自己可控的代码有完全的测试保证，其次，如果有第三方的代码影响到测试覆盖，我们应该把第三方的代码和我们的代码隔离开。</strong></p><p>我知道，很多人已经准备强调 100%的测试覆盖是如何困难了。其实，不知道你有没有注意，我们在实战环节中，已经完成了一次 100%的测试覆盖。你可以去看看实战环节的构建脚本，其中用到的测试覆盖率工具就是 JaCoCo，而覆盖率的要求就是 100%，也就是 1.0。问题是我们是怎么做到的呢？</p><p>我们不妨一起回想一下，在做好了整体的设计之后，我们每实现一个具体的功能，都考虑了测试的场景，测试用例和代码是同步在实现。最后通过测试覆盖率检查，找出没有覆盖到的代码。对于一些不方便测试的第三方程序库代码，我们进行了隔离，而且要求隔离是非常薄的一层。这样，就保证了我们所有编写业务代码都能够很好地得到测试覆盖。</p><p>说起来并不复杂，但你或许会说，这是因为我们只实现了基本的功能，代码复杂度比较低，如果是实现了更为复杂的功能，是不是就没办法覆盖了呢？</p><p>我们在前面的内容中说过，要想写好测试，一个关键点是要有良好的软件设计，而且代码本身要尽可能地消除坏味道。到这里你就清楚了，<strong>其实程序员写测试不单单是写测试，同时，也是在发现自己代码中的不足，无论是设计上，还是代码本身。</strong></p><p>所以说，即便是再复杂的功能，通过软件设计和良好的编码，也可以落实到一个一个小代码块上。这里的重点是小，代码能否写短小，这是一个程序员编码基本功的问题。</p><p>你让我给一个长达几百上千的代码去写测试，我也很难做到 100%覆盖，因为代码写得太复杂了，我们理解起来很吃力，为它写测试当然也很吃力。所以，我们会把讨论先集中在一个新项目该如何写测试上。如果一个程序员不能够在干干净净的代码库上写好代码，你就很难指望他在面对一个遗留代码库时能够写好代码。</p><p>不知道你注意到了没有，我们说在实战中达成 100%测试覆盖时，还有一个工作习惯，就是测试和代码同步写。为什么要这么做呢？因为没有人愿意补测试，无论这个代码是你写的还是别人写的。</p><p>这也就是为什么要把测试放在自动化过程中，这样，我们每完成一个任务，就要确保编写了相应的测试。而且，我前面也强调过，任务的关键是小，比如，小到半个小时就可以提交一次，这样，你写测试的负担相对来说是小的。小事相比大事更容易坚持，这是符合人性的做法。</p><p>你现在已经知道了，一个新项目想要达到 100%的测试覆盖，<strong>首先，要有可测试的设计，要能够编写整洁的代码；其次，测试和代码同步写。</strong></p><h2>测不到的代码</h2><p>关于 100%测试覆盖率，很多人有一个误区：100%覆盖了，是不是就意味着代码没问题了？答案是否定的。即便我们有了 100%的测试覆盖，还是会有你想不到的场景出现。100%的覆盖只是保证我们已经写的代码没有场景遗漏，不会有异常场景没有处理，不会有分支条件没有考虑到，仅此而已。</p><p>100%的测试覆盖只是程序员做好了本职工作，保证了在这个环节内没有出错。而软件整体质量是一个系统性的工程，首先要保证我们尽可能多地考虑到了各种测试场景，这是我们在<a href=\"https://time.geekbang.org/column/article/405774\">第 3 讲</a>中讨论的内容。</p><p>对程序员来说，通过把测试覆盖率设置 100%，我们就有了一个查缺补漏的机会。一旦发现有些缺漏很难补上怎么办？就像我们在实战环节中见到的那样，模拟 Jackson 的异常成本过高，我们就会采用隔离的方式，将不好测试的地方隔离开来，形成一个封装层。实际上，我们是在用软件设计的方式在解决问题。</p><p>理解了达成 100%测试覆盖的基础之后，我还必须再强调一下。第一点是前面提到的封装层，这一层一定要非常薄。很多情况下，可能就是直接的方法调用。如果有复杂的逻辑，比如在防腐层代码中有对象之间的转换，我们都可以把转换的逻辑拿出来，单独地去写测试，因为这个转换逻辑多半是可以测试的。100%的测试覆盖率我们不是说说而已，而是要坚持做到能覆盖的尽量去覆盖。</p><p>另外还有一点，隔离出来的代码怎么办呢？我们要在测试覆盖的检查中将它们排除，具体的做法就是在构建文件中，把这个文件标记为不需要测试覆盖。</p><pre><code>coverage {\n  excludeClasses = [\n        &quot;com.github.dreamhead.todo.util.Jsons&quot;\n  ]\n}\n</code></pre><p>在我的项目中，我会要求这里只能有那个薄薄的封装层。有些初次接触项目的人，常常会把这里理解成项目中有我不想测的代码，却还要保证 100%测试覆盖，这里就是一种妥协。绝对不是这个意思！所以，一方面，我们要在团队中强调这个纪律，另一方面，我们也要经常性地做代码评审，保证这个用来隔离封装层的地方不会遭到滥用。</p><p>100%虽然要求很高，但要想做到，首先是理念上的认同，然后，我们就可以想各种办法去做到。在实际的项目中，<strong>很多人先从理念去否定，认为不可能做到，只要有一点困难就放弃，这其实才是 100%测试覆盖率难以达成的最主要原因。</strong></p><h2>总结时刻</h2><p>今天我们延续了上一讲测试覆盖率的话题，讨论了在一个新项目中，测试覆盖率应该设置成多少，我给出的答案就是 100%。</p><p>100%的测试覆盖率会遭到很多人的反对，但这种反对首先是对 KPI 行为的一种本能恐惧。在真实项目中，大家都认同的观点是测试覆盖率越高越好，最高的覆盖率肯定是 100%。</p><p>我们强调的 100%测试覆盖，主要指的是对自己编写的代码 100%测试覆盖。这就意味着，我们一方面要保证自己的代码完全可控，另一方面，对于影响到测试覆盖的第三方代码要进行隔离。要想做到100%的测试覆盖，技术上说，要有可测试的设计以及编写整洁的代码，实践上看，要测试和代码同步产出。</p><p>100%的测试覆盖并不是说代码没有问题了，而应该是程序员对自己编写代码的一种质量保证，它是一个帮助我们查缺补漏的过程。</p><p>对于无法测试到第三方代码，要用一个薄薄的隔离层将代码隔离出去，在构建脚本中将隔离层排除在外。有一点需要注意的是，排除脚本千万别被滥用了。</p><p>如果今天的内容你只能记住一件事，那请记住：<strong>100%的测试覆盖率是程序员编写高质量代码的保证。</strong></p><h2>思考题</h2><p>今天我们讲了如何达到 100%的测试覆盖，你在实际工作中遇到过哪些难以测试的情况呢？期待在留言区看到你的想法。</p>","neighbors":{"left":{"article_title":"09 | 测试覆盖率：如何找出没有测试到的代码？","id":410429},"right":{"article_title":"11 | 集成测试：单元测试可以解决所有问题吗？","id":412079}},"comments":[{"had_liked":false,"id":309453,"user_name":"码农Kevin亮","can_delete":false,"product_type":"c1","uid":1116630,"ip_address":"","ucode":"D34562461CA0A1","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/d6/5f366427.jpg","comment_is_top":false,"comment_ctime":1630142863,"is_pvip":false,"replies":[{"id":"112079","content":"首先，我在《代码之丑》里讲过，setter是不应该存在的，getter的使用也需要谨慎。其次，getter需要确认是真getter，还是有逻辑的，有逻辑的是需要覆盖的。最后，getter可以不写，不仅是不写测试，甚至是不写代码，Java程序可以使用Lombok这个程序库，只用Annotation，没有代码就不用纠结是否覆盖了。<br><br>解决了你前面的问题，后面的就不是问题了。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1630155975,"ip_address":"","comment_id":309453,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18810012047","product_id":100085101,"comment_content":"请教老师，我正好遇到这么一个现实问题：<br>getter&#47;setter我理解是不需要测的，如果为了达到100%覆盖的目标，意味着需要单独把充血实体类拆成贫血实体与业务操作两个类。是这样么？","like_count":5,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525878,"discussion_content":"首先，我在《代码之丑》里讲过，setter是不应该存在的，getter的使用也需要谨慎。其次，getter需要确认是真getter，还是有逻辑的，有逻辑的是需要覆盖的。最后，getter可以不写，不仅是不写测试，甚至是不写代码，Java程序可以使用Lombok这个程序库，只用Annotation，没有代码就不用纠结是否覆盖了。\n\n解决了你前面的问题，后面的就不是问题了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1630155975,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308996,"user_name":"davix","can_delete":false,"product_type":"c1","uid":1074465,"ip_address":"","ucode":"CBFB39BAD7938B","user_header":"https://static001.geekbang.org/account/avatar/00/10/65/21/101a7075.jpg","comment_is_top":false,"comment_ctime":1629884075,"is_pvip":false,"replies":[{"id":"111851","content":"往前看，这也是我为什么要先讲做好设计，做好单元测试的原因，有了这些基础，才是 100%覆盖。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1629903008,"ip_address":"","comment_id":308996,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14514785963","product_id":100085101,"comment_content":"請問100%覆蓋會不會導致過度測試導致難以重構？","like_count":4,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525707,"discussion_content":"往前看，这也是我为什么要先讲做好设计，做好单元测试的原因，有了这些基础，才是 100%覆盖。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629903008,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311006,"user_name":"sylan215","can_delete":false,"product_type":"c1","uid":1019029,"ip_address":"","ucode":"5A2CF31BC69F40","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/95/4544d905.jpg","comment_is_top":false,"comment_ctime":1631014397,"is_pvip":false,"replies":[{"id":"112715","content":"很好的总结","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1631058993,"ip_address":"","comment_id":311006,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10220948989","product_id":100085101,"comment_content":"我们说的代码覆盖率的要求，是针对自己写的代码，如果有第三方代码的引用，一定要做好封装和隔离。<br><br>「补测试」几乎是不可能的，所以再次强调，一定要测试和代码一起写。<br><br>不管是第三方代码隔离，还是自己代码的可测性，都要去我们要做好设计，可测试的设计。<br><br>代码覆盖率是一种质量保证的手段，可以帮我们从代码角度来查漏补缺，覆盖率高并不代表代码没问题。","like_count":2,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526431,"discussion_content":"很好的总结","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631058993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":309592,"user_name":"码农Kevin亮","can_delete":false,"product_type":"c1","uid":1116630,"ip_address":"","ucode":"D34562461CA0A1","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/d6/5f366427.jpg","comment_is_top":false,"comment_ctime":1630244250,"is_pvip":false,"replies":[{"id":"112180","content":"在 lombok.config 里有这么一段代码：<br>lombok.addLombokGeneratedAnnotation = true<br><br>","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1630334308,"ip_address":"","comment_id":309592,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10220178842","product_id":100085101,"comment_content":"接前面的提问。我实践过，即使是用lombok，在覆盖率统计里也是有行数统计出来的。不知道是不是我不会设置呢。所以假如lombok并不能使得覆盖率扫描避开这些代码，那老师对于把充血模型单独拆出一个贫血实体然后排除扫描的方式，来满足100%覆盖率的作法有何评价呢？","like_count":3,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525927,"discussion_content":"在 lombok.config 里有这么一段代码：\nlombok.addLombokGeneratedAnnotation = true\n\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1630334308,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":309203,"user_name":"coyang","can_delete":false,"product_type":"c1","uid":1024805,"ip_address":"","ucode":"563687E0F6A441","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a3/25/5da16c25.jpg","comment_is_top":false,"comment_ctime":1629984662,"is_pvip":true,"replies":[{"id":"111924","content":"死循环，把逻辑部分挪出来，单独测试。把循环的地方单独隔离出来，排除在覆盖率之外。<br><br>static 函数，要是没有任何字段，只是纯逻辑，就可以直接测试，就像一个程序库去测试。要是有复杂的关联，还是最好先考虑改造吧，把依赖解开，改造成一个正常的函数再做测试。这类似于遗留系统，后面我会提到，遗留系统改造主要是分离和隔离。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1630022232,"ip_address":"","comment_id":309203,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10219919254","product_id":100085101,"comment_content":"老师好，我遇到以下两种不好测试的情况：<br>1.死循环的逻辑<br>2.static函数<br><br>以上两种情况怎么保证覆盖率100%呢？","like_count":3,"discussions":[{"author":{"id":2735468,"avatar":"https://static001.geekbang.org/account/avatar/00/29/bd/6c/a988846d.jpg","nickname":"asusual","note":"","ucode":"AF9AA546D3794F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390719,"discussion_content":"个人经验是\n1.死循环当作外部函数隔离，死循环内部方法提取为可测试的方法\n2.static函数也是可以用单元测试来覆盖的。或者你是想表达使用外部static工具类，也可以当作外部函数隔离。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1629988169,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525783,"discussion_content":"死循环，把逻辑部分挪出来，单独测试。把循环的地方单独隔离出来，排除在覆盖率之外。\n\nstatic 函数，要是没有任何字段，只是纯逻辑，就可以直接测试，就像一个程序库去测试。要是有复杂的关联，还是最好先考虑改造吧，把依赖解开，改造成一个正常的函数再做测试。这类似于遗留系统，后面我会提到，遗留系统改造主要是分离和隔离。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1630022232,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308866,"user_name":"大碗","can_delete":false,"product_type":"c1","uid":1027207,"ip_address":"","ucode":"F9CDC0C5BE48AC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ac/87/8ed5880a.jpg","comment_is_top":false,"comment_ctime":1629847759,"is_pvip":false,"replies":[{"id":"111825","content":"我指的就是你没法控制的代码。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1629869382,"ip_address":"","comment_id":308866,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10219782351","product_id":100085101,"comment_content":"请问老师对“第三方代码”的界定为是不是自己编写的代码，第一种常见的是非公司的类库，比如Jackson，这种好理解。第二种是服务A调用服务B的api.jar，第三种两个人编写服务A的两个模块C，D，编写C的人调用了别人D的方法，后面两种也属于调用第三方代码么? ","like_count":3,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525650,"discussion_content":"我指的就是你没法控制的代码。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1629869382,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332025,"user_name":"微笑","can_delete":false,"product_type":"c1","uid":1685222,"ip_address":"","ucode":"C5EE55E23D2C57","user_header":"https://static001.geekbang.org/account/avatar/00/19/b6/e6/db12908c.jpg","comment_is_top":false,"comment_ctime":1642989248,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5937956544","product_id":100085101,"comment_content":"1. 先估时的时候拆分到函数级别和小时级别。<br>2. 保证一个函数只干一件事。<br>3. 先写测试用例。<br>4. 写关键测试和必要测试。<br>5. 拆分的很细的时候，很多代码已经足够简单，简单到你写测试都感觉是重复劳动，然后会导致敷衍。<br>6. 写代码时单元测试不好写，代表代码已经有问题，这是应该重构写的代码。如果尽量保持单一职责，就会很简单。<br>7. 如果一个方法足够简单，不需要测试，当然有充足的时间无所谓。我们需要的时在该方法内部变得复杂一点的时候写测试用例。这样避免过度设计","like_count":2},{"had_liked":false,"id":312151,"user_name":"北风一叶","can_delete":false,"product_type":"c1","uid":1087302,"ip_address":"","ucode":"30310E66341D2A","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/46/fe1f21d8.jpg","comment_is_top":false,"comment_ctime":1631667242,"is_pvip":false,"replies":[{"id":"113136","content":"有了目标，剩下就是前进的动力了","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1631712366,"ip_address":"","comment_id":312151,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5926634538","product_id":100085101,"comment_content":"追求100%的 测试覆盖率","like_count":1,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526881,"discussion_content":"有了目标，剩下就是前进的动力了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631712366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":309191,"user_name":"asusual","can_delete":false,"product_type":"c1","uid":2735468,"ip_address":"","ucode":"AF9AA546D3794F","user_header":"https://static001.geekbang.org/account/avatar/00/29/bd/6c/a988846d.jpg","comment_is_top":false,"comment_ctime":1629979886,"is_pvip":false,"replies":[{"id":"111925","content":"TDD 比较容易 100%","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1630022254,"ip_address":"","comment_id":309191,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5924947182","product_id":100085101,"comment_content":"TDD写出来的代码一般情况覆盖率都是100%","like_count":2,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525776,"discussion_content":"TDD 比较容易 100%","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630022254,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":309069,"user_name":"davix","can_delete":false,"product_type":"c1","uid":1074465,"ip_address":"","ucode":"CBFB39BAD7938B","user_header":"https://static001.geekbang.org/account/avatar/00/10/65/21/101a7075.jpg","comment_is_top":false,"comment_ctime":1629932249,"is_pvip":false,"replies":[{"id":"111882","content":"不会","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1629940313,"ip_address":"","comment_id":309069,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5924899545","product_id":100085101,"comment_content":"請問mock中用verify 的多少影響覆蓋率嗎","like_count":1,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525732,"discussion_content":"不会","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629940313,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308924,"user_name":"Gojustforfun","can_delete":false,"product_type":"c1","uid":1187021,"ip_address":"","ucode":"7513A40F27344F","user_header":"https://static001.geekbang.org/account/avatar/00/12/1c/cd/8d552516.jpg","comment_is_top":false,"comment_ctime":1629862742,"is_pvip":true,"replies":[{"id":"111846","content":"我没有做区分，能 commit 和能 push 对我来说是一回事，就是一次提交，一个完整任务的完成。push 才是终点，重点是把自己的代码是和别人的代码合在一起，否则，合并的工作量会增大。","user_name":"作者回复","user_name_real":"郑晔","uid":"1258861","ctime":1629898501,"ip_address":"","comment_id":308924,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5924830038","product_id":100085101,"comment_content":"“我前面也强调过，任务的关键是小，比如，小到半个小时就可以提交一次，这样，你写测试的负担相对来说是小的”，请问这里的“提交”指的是git commit(提交到本地库)还是git push（提交到远程库）。<br><br>我个人的理解是git commit，完成某个功能的最后一个子任务后，将该功能的多个git commit合并再git push合并后的commit。不知这样做是否可以？有什么问题？还需要注意什么？谢谢","like_count":2,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525683,"discussion_content":"我没有做区分，能 commit 和能 push 对我来说是一回事，就是一次提交，一个完整任务的完成。push 才是终点，重点是把自己的代码是和别人的代码合在一起，否则，合并的工作量会增大。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629898501,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1947974,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/b9/46/604b3dcf.jpg","nickname":"蓝色海洋","note":"","ucode":"C1BF85D9E5C881","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580406,"discussion_content":"老师太牛了，commit和push做成一回事，太难达到了啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658146654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1898023,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/f6/27/c27599ae.jpg","nickname":"术子米德","note":"","ucode":"382EA7E2AF0B56","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390570,"discussion_content":"Git Commit+Push，触发AutoUT之类测试，多个C&amp;P一起发个MR","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629895294,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":348194,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1654835895,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654835895","product_id":100085101,"comment_content":"100% 的测试覆盖率是程序员编写高质量代码的保证。--记下来","like_count":1},{"had_liked":false,"id":322928,"user_name":"松松","can_delete":false,"product_type":"c1","uid":1337030,"ip_address":"","ucode":"EB2A80CF7BCA4B","user_header":"https://static001.geekbang.org/account/avatar/00/14/66/c6/d779dfb6.jpg","comment_is_top":false,"comment_ctime":1637660644,"is_pvip":false,"replies":[{"id":"117238","content":"站在功能测试的角度有随机，站在单元的角度没有随机，可以把随机生成封装到一个单独的模块里。","user_name":"作者回复","user_name_real":"编辑","uid":"1258861","ctime":1637675644,"ip_address":"","comment_id":322928,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1637660644","product_id":100085101,"comment_content":"老师您好，请问一下对于用到随机数的场景，应该怎么去进行设计，能更方便达成测试的目的呢？举例来说游戏有一些随机掉落的场景。","like_count":0,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532737,"discussion_content":"站在功能测试的角度有随机，站在单元的角度没有随机，可以把随机生成封装到一个单独的模块里。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637675644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321094,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1636677892,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636677892","product_id":100085101,"comment_content":"读完后有了测试覆盖率100%的信心","like_count":1}]}