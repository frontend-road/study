{"id":518965,"title":"21｜混合应用：如何从零开始集成React Native？","content":"<p>你好，我是蒋宏伟。</p><p>从今天开始，我们将进入 React Native 基础设施建设篇的学习。我也特地邀请了多年以来和我一起做 58RN 基建的两位老搭档：58RN Android 负责人况众文和58RN iOS 负责人朴惠姝一起来讲解。</p><p>在基础设施建设篇中，众文老师、惠姝老师会和我一起为你详细介绍怎么搭建 React Native 混合应用、怎么创建新架构的自定义组件，以及怎么自研热更新平台，又怎么进行性能优化。</p><p>无论你是 FE、Android 还是 iOS，相信基建篇的内容都能让你大有收获，甚至帮助你在公司中晋级。好了，下面我们正式开启基建篇的学习。</p><hr><p>你好，我是况众文，是 58RN 负责Android 端的同学。接下来基础设施建设篇中移动端相关的几讲，将由我和我的同事，负责iOS 端的同学朴惠姝一起来讲解。</p><p>这几讲是《混合应用：如何从零开始集成 React Native？》、《自定义组件：如何满足业务的个性化需求？》，以及《客户端优化：如何把性能提升到极致？》。在这三讲中，我们将结合自己在 React Native 开发的实际经验，以及真实的业务案例，和你一起循序渐进地走入混合开发的世界。</p><p>而且，我们这几讲将使用 React Native 最新框架来讲解，你也可以借此了解 Fabric、TurboModules、CodeGen、JSI、Hermes 等新概念。</p><!-- [[[read_end]]] --><p>但在正式开始讲解怎么做混合开发之前，想先用一些篇幅，简单跟你介绍一下什么是混合应用与混合开发，以及我们什么时候需要用到混合开发。</p><h2>App 混合开发指的是什么？</h2><p>App 混合开发，指的是<strong>一个 App 部分功能用 Native 构建，部分功能用跨端框架构建</strong>。目前比较流行的跨端框架有 H5、React Native、Flutter、布局动态化等。当然我们这门课主要是围绕着React Native来进行讲解。</p><p><img src=\"https://static001.geekbang.org/resource/image/be/24/bed77cfbc69b490ae759a3166fb88b24.png?wh=1854x594\" alt=\"\"></p><p>以 Native 与 React Native 混合开发为例，在同一个 App 中，通常存在以下几种形态：</p><p><img src=\"https://static001.geekbang.org/resource/image/db/fc/db3e0383979b499652d6dfef81a051fc.jpg?wh=1755x818\" alt=\"图片\"></p><p>那么，Native 与 React Native 混合开发一般会用在哪儿呢？</p><p>首先是一些大型App中，比如美团、携程、京东、58等。这些大型 App 一般都非常复杂，整个框架需要包含模块化、组件化、插件化、跨端等能力。相比纯 React Native 工程，大型App的实际业务开发还需要考虑如何在已有原生项目中引入 React Native，作为原生框架的扩展能力。比如，部分业务可能对开发效率、多端一致性、动态更新能力有较强要求，就可以使用 React Native 来实现。</p><p>除了大型 App 外，如果你要对已上线的项目引入 React Native 也需要使用混合模式。因为原生改造成 React Native 并不是那么简单的事情，毕竟开发语言、页面管理、模块管理完全是另一套东西，而且一些原生页面，如启动页、首页等，出于性能考虑，大都还是会选择原生来实现。</p><p>当然一些新开发的轻量级 App，建议你选择纯 React Native 模式。因为新开发的 App 没有技术债，可以从0到1享受 React Native 跨端的优势，比如项目最关心的开发成本。</p><p>那么混合开发又有什么优点呢？简单说有这几点：</p><ul>\n<li>开发效率高，一套代码可以在 Android、iOS 上运行；</li>\n<li>更新部署方便，无须依赖应用市场发版，迭代更新速度快；</li>\n<li>具备动态更新能力，特别是国内 App，以 Android 为例，受限于 Google Play，无法使用 Android App bundle，而插件化框架又存在稳定性问题。而业务快速迭代、Bug 响应速度都对动态更新能力有强烈的需求。</li>\n</ul><p>但混合开发也不是万能的，它也有一些缺点，你要特别注意：</p><ul>\n<li><strong>性能不佳</strong>。H5 渲染链路长；React Native 依托于 JS bridge 交互 （指旧版，最新架构使用 JSI）；虽然 Flutter 绘制流程直接使用 Skia，但依赖于原生的能力仍需异步交互；</li>\n<li><strong>兼容性差</strong>。Android、iOS 各版本都存在各种兼容性问题，特别是 Android 碎片化严重；</li>\n<li><strong>问题排查成本高</strong>。跨端框架一般涉及 Native、FE、Server，中间做了大量的桥接转换，排查链路比纯 Native 长；</li>\n<li><strong>动态化能力受限</strong>。相比纯原生的插件化，跨端框架动态更新的业务如果涉及 Native 部分的组件更新，需要依赖 App 发版。</li>\n</ul><p>现在一般大型 App 都是多套跨端框架并存的，比如 H5 + React Native + 布局动态化，或 H5 + Flutter，具体选型主要以业务场景、包大小、性能、运行内存、动态更新能力为标准进行。但这一讲我们会从 React Native视角带你一步步构建混合应用。</p><p>在React Native的混合开发中，我们需要关注下面这几个主要问题和流程：</p><ul>\n<li>如何从 0～1 进行环境配置；</li>\n<li>通用的 React Native 载体页如何设计，需要包含哪些能力；</li>\n<li>如何调试打包发布；</li>\n<li>遇到混合开发的 bug 如何进行排查与修复。</li>\n</ul><p>这些问题和流程，我们将从 Android &amp; iOS 两端逐步讲解。</p><h2>环境配置</h2><p>我们先从 Native 环境配置开始，先看看如何在 Android 端进行混合工程下的 React Native 环境配置。</p><h3>Android</h3><h4>第一步：创建本地工程</h4><p>我们使用 Android Studio 创建一个新的 App 项目，如果你已经有了本地项目，可以跳过此步骤。填写完项目名称、包名、项目本地路径后，点击 “Finish” 按钮。你可以把这个项目名称取名为 “GeekTimeRNAndroid”。</p><p><img src=\"https://static001.geekbang.org/resource/image/00/78/00693ac394ea2b67f8b99913fc51fd78.jpg?wh=1792x1338\" alt=\"图片\"></p><p>创建好的工程目录如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/7f/da/7fe5fe8662cce3e513ed0b89e2aa78da.jpg?wh=954x902\" alt=\"图片\"></p><h4>第二步：添加依赖</h4><p>创建好本地工程后，我们就要给它添加依赖。其实，React Native官方对集成到现有的原生应用提供了相应的<a href=\"https://reactnative.cn/docs/integration-with-existing-apps\">文档</a>，你可以看看。</p><p>文档提示，我们需要“创建一个空目录用于存放 React Native 项目，然后在其中创建一个 /android 子目录，把你现有的 Android 项目拷贝到 /android 子目录中”。</p><p>当然，官方提供的方式是非常不错的，它更偏向于 React Native 的工程管理模式。而我们在实际开发中，特别是已经上线的项目里面，React Native 功能和其他业务功能一样，一般会被当成原生工程的子模块来管理，所以我们这边选择<strong>偏向混合工程管理方式</strong>来集成。</p><p>这里，给你画了一张几种模式的对比图，你可以看看：</p><p><img src=\"https://static001.geekbang.org/resource/image/13/af/13e5c0527c254bc75a48ffb031ea36af.png?wh=766x1218\" alt=\"图片\"></p><p>对比官方模式，我们采用混合工程模式，是基于以下几点考虑的：</p><ul>\n<li>可以不侵入现有工程结构，React Native 模块会作为现有工程的一部分进行组织管理。</li>\n<li>不会影响代码仓库管理，不用把Android、iOS 放在同一代码仓库下进行管理。</li>\n<li>混合模式方便我们进行组件功能复用，你可以将 React Native 模块独立成组件，提供给其他 App 平台使用。</li>\n</ul><p>那么，基于混合工程模式集成 React Native 模块需要哪些依赖项呢？我们结合<a href=\"https://reactnative.cn/docs/integration-with-existing-apps\">文档</a>来看下，主要是：</p><ul>\n<li><strong>react-native</strong>：React Native 的核心框架；</li>\n<li><strong>JavaScript 引擎</strong>：可选 JSC、Hermes，用于执行 JavaScript。<br>\n接下来，我们参考文档进行如下操作：</li>\n</ul><pre><code class=\"language-plain\"># 切换到刚刚新建好的工程目录\ncd /Users/kuangzhongwen/Desktop/project/GeekTimeRNAndroid\n\n# 执行添加 react-native 命令，yarn 或 npm 都可以\nyarn add react-native\n</code></pre><p>执行 yarn add react-native 命令后，默认会安装最新版本的 React Native 包。</p><p>因为我们这个专栏主要是围绕 React Native 新架构讲解的，所以这边我们选择 React Native 0.68.0-rc3 版本。因此，我们指定 0.68.0-rc3 这个版本，执行如下命令：(<a href=\"https://github.com/facebook/react-native/tags\">这里</a>可查看 react-native 版本)：</p><pre><code class=\"language-plain\">yarn add react-native@0.68.0-rc3\n</code></pre><p>执行以上命令成功之后，我们会发现 GeekTimeRNAndroid 工程下多了一个 node_modules 目录，里面不仅有 react-native 框架，还有 JavaScript 引擎编译好的产物，包括 aar 和 pom 依赖文件。接下来，我们可以参考官方提供的方式，将 node_modules 目录配置为 repository，然后在工程中引入相关依赖。</p><p>不过，这种方式并不太推荐，其实我们只需要 react-native 和 JavaScript 引擎这两个产物就可以了。获取这两个产物后，在 Android 自己进行二次封装，然后发布到公司的远程仓库，就不用忍受一大堆无用的文件存放在项目中了 （虽然可以用 git ignore 忽略）。</p><p>目前node_modules 目录里有这几个内容：</p><ol>\n<li>\n<p>…/GeekTimeRNAndroid/node_modules/react-native（本地安装好的 node_module 中的 react-native 框架编译产物）：<br>\n<img src=\"https://static001.geekbang.org/resource/image/07/95/07fc4f77e3e9beef92d3bbd3a5b51e95.png?wh=904x1008\" alt=\"图片\"></p>\n</li>\n<li>\n<p>…/GeekTimeRNAndroid/node_modules/JavaScriptc-android（本地安装好的 node_module 中的 JSC 引擎编译产物）：<br>\n<img src=\"https://static001.geekbang.org/resource/image/94/a5/943210c6d1ea945e04eb736ca0826ba5.png?wh=792x996\" alt=\"图片\"></p>\n</li>\n<li>\n<p>…/GeekTimeRNAndroid/node_modules/hermes-engine（本地安装好的 node_module 中的 Hermes 引擎编译产物）：<br>\n<img src=\"https://static001.geekbang.org/resource/image/yy/1f/yy5e3402386d417d0ebe39de48f8fa1f.png?wh=708x480\" alt=\"图片\"></p>\n</li>\n</ol><p>其中只有 react-native 框架是必需的，而具体选择 JSC 引擎还是 Hermes 引擎，你可以参考以下几个点：</p><ul>\n<li>在启动性能上，Hermes 比 JSC 更快。Hermes 采用的是 AOT 提前编译的方案，它支持字节码文件，相比于 JSC，Hermes 不用先将 JavaScript 文本编译为字节码，节约了编译字节码的耗时，自然启动性能更好。</li>\n<li>在运行性能上，JSC 比 Herems 更快。JSC 使用的是 JIT 即时编译方案，该方案支持动态缓存热点代码，因此运行性能上更快。</li>\n</ul><p>但整体而言，由于 Hermes 引擎是专门为移动端定制的，<a href=\"https://www.callstack.com/blog/hermes-performance-on-ios\">在引擎大小、启动速度、运行内存、通信性能等方面都优于 JSC</a>。如果你的是新项目，没有历史负担，建议你直接使用 Hermes 引擎。如果是之前已使用 JSC 引擎上线的项目，可以往 Hermes 引擎进行升级。</p><p>接下来，我们来给 GeekTimeRNAndroid 工程添加 react native 相关的依赖，包括：</p><ol>\n<li>react-native.arr 文件；</li>\n<li>react-native.aar 依赖的第三方库；</li>\n<li>JavaScript 引擎 aar 文件。</li>\n</ol><p>首先我们先来添加 react-native.arr 文件。我们将 …/GeekTimeRNAndroid/node_modules/react-native/ 目录下的 react-native-0.68.0-rc.3.aar 拷贝放置到 GeekTimeRNAndroid/libs 目录。注意，Android 引入本地 aar 文件需要在工程根目录 build.gradle 添加 flatDir 配置：</p><pre><code class=\"language-plain\">allprojects {\n    repositories {\n        google()\n        jcenter()\n        // 添加 flatDir 配置\n        flatDir {\n            dirs 'libs'\n        }\n    }\n}\n</code></pre><p>然后在 GeekTimeRNAndroid/app 模块下的 build.gradle 添加依赖：</p><pre><code class=\"language-plain\">implementation(name:'react-native-0.68.0-rc.3', ext:'aar')\n</code></pre><p>接着，我们再将 …/GeekTimeRNAndroid/node_modules/react-native/ 目录下的 react-native-0.68.0-rc.3.pom 中的依赖库，按照 android gradle 依赖的方式进行添加，这些依赖主要是 react-native aar 本身远程依赖的第三方库。添加好的 app build.gradle 如下：</p><pre><code class=\"language-plain\">dependencies {\n    implementation(name:'react-native-0.68.0-rc.3', ext:'aar')\n    \n    implementation 'com.facebook.infer.annotation:infer-annotation:0.18.0'\n    implementation 'javax.inject:javax.inject:1'\n    implementation 'androidx.appcompat:appcompat:1.0.2'\n    implementation 'com.facebook.fresco:imagepipeline-okhttp3:2.5.0'\n    implementation 'com.facebook.fresco:fresco:2.5.0'\n    implementation 'com.facebook.soloader:soloader:0.10.3'\n    implementation 'com.google.code.findbugs:jsr305:3.0.2'\n    implementation 'com.squareup.okhttp3:okhttp:4.9.2'\n    implementation 'com.squareup.okhttp3:okhttp-urlconnection:4.9.2'\n    implementation 'com.squareup.okio:okio:2.9.0'\n}\n</code></pre><p>最后，我们添加下 JavaScript 引擎 aar 就可以了。这边我们使用 JSC 引擎 (Hermes 引擎则是将 …/GeekTimeRNAndroid/node_modules/hermes-engine 下的 hermes-cppruntime-release.aar &amp; hermes-release.aar 拷贝到 libs 目录，并在 build.gradle 中添加依赖)。<br>\nJSC aar 位于 …/GeekTimeRNAndroid/node_modules/jsc-android 目录下，主要是 jsc 的 so 动态库，将 android-jsc-r250230.aar 拷贝到 GeekTimeRNAndroid/libs 目录：</p><p><img src=\"https://static001.geekbang.org/resource/image/e7/82/e718eaea509be293b4070e343a478282.png?wh=654x276\" alt=\"图片\"></p><p>完整的 GeekTimeRNAndroid/app/build.gradle 依赖配置如下：</p><pre><code class=\"language-plain\">dependencies {\n    implementation(name:'react-native-0.68.0-rc.3', ext:'aar')\n    implementation(name:'android-jsc-r250230', ext:'aar')\n\n    implementation 'com.facebook.infer.annotation:infer-annotation:0.18.0'\n    implementation 'javax.inject:javax.inject:1'\n    implementation 'androidx.appcompat:appcompat:1.0.2'\n    implementation 'com.facebook.fresco:imagepipeline-okhttp3:2.5.0'\n    implementation 'com.facebook.fresco:fresco:2.5.0'\n    implementation 'com.facebook.soloader:soloader:0.10.3'\n    implementation 'com.google.code.findbugs:jsr305:3.0.2'\n    implementation 'com.squareup.okhttp3:okhttp:4.9.2'\n    implementation 'com.squareup.okhttp3:okhttp-urlconnection:4.9.2'\n    implementation 'com.squareup.okio:okio:2.9.0'\n}\n</code></pre><p>到这里，React Native 相关的依赖配置已经完成，这时候你可以将 GeekTimeRNAndroid/node_modules 删除了。</p><h4>第三步：配置权限</h4><p>配置好相关的依赖库后，我们需要来添加下权限和清单配置。这个很简单，我们只需要在 GeekTimeRNAndroid/app 的 AndroidManifest.xml 清单文件中声明网络权限就好了：</p><pre><code class=\"language-plain\">&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;\n</code></pre><p>不过，如果你还需要访问开发者菜单界面，就需要在 AndroidManifest.xml 中声明：</p><pre><code class=\"language-plain\">&lt;activity android:name=\"com.facebook.react.devsupport.DevSettingsActivity\" /&gt;\n</code></pre><p>至此，Android 混合工程中的 React Native 环境配置就已经完成了。接下来我们再看看，如何在 iOS 中进行 React Native 环境配置。</p><h3>iOS</h3><h4>第一步：创建本地工程</h4><p>首先，我们需要跟着 React Native 官方文档，在本地创建一个对应版本的 React Native 工程，这里我们假设项目需要 0.68.1 版本：</p><pre><code class=\"language-plain\"># 首先安装 react-native-cli, 否则无法使用 react-native 命令\nsudo npm install -g react-native-cli\n\n# projectName 为工程名称\nreact-native init projectName --version 0.68.1\n</code></pre><p>创建好后，我们再打开工程，在工程 node_modules/react-native/template/ 目录下执行 npm install，然后进入 /ios/ 目录下执行 pod install，结束后再打开 react native workspace 工程：</p><p><img src=\"https://static001.geekbang.org/resource/image/c3/48/c3288c994c5a9d63e4a92c79452de648.png?wh=1568x1344\" alt=\"图片\"></p><p>这就是iOS中创建一个新的工程，接入React Native功能的方案。那我们如何在已有的iOS工程中接入React Native呢？其实也比较简单。</p><p>首先，你需要将以下三个React Native源码引入到iOS工程中，这三个源码分别为Libraries、React，以及React Common：</p><p><img src=\"https://static001.geekbang.org/resource/image/04/f9/04aa50941fyy62c76cd48de5585a1cf9.png?wh=241x419\" alt=\"图片\"></p><p>然后你将这三个部分作为React Native功能模块，直接参考官方提供的podspec（三个不同模块的podspec请参考<a href=\"https://github.com/facebook/react-native\">https://github.com/facebook/react-native</a>），并结合自己工程，选择合理的接入方案，集成到iOS工程中就可以了：</p><p><img src=\"https://static001.geekbang.org/resource/image/8a/f6/8a278d85112d0b0c9d721b6d5369d0f6.png?wh=304x100\" alt=\"图片\"></p><h4>第二步：添加iOS端依赖的库</h4><p>接下来，我们需要修改Podfile，来引用其他依赖的第三方库，包括DoubleConverison、glog、RCT_Folly、libevent，等等。podspec配置文件则直接使用官方提供的文件：</p><p><img src=\"https://static001.geekbang.org/resource/image/a6/33/a62d416f3497493d23b2605dc32b4133.png?wh=1268x274\" alt=\"图片\"></p><p>之后，我们再执行pod install并构建工程文件xcworkspace，并打开工程文件，进行编译就可以了。</p><p>对比两端的操作，你可以看到，Android 与 iOS 中 React Native 混合应用的工程组织结构是一样的。与 React Native 新项目不同，在已有 Android 和 iOS 项目中接入 React Native，都是把 React Native 当成子模块进行引入的。</p><p>不过，环境配置流程中，Android 侧重于依赖 React Native 的框架 aar，以及 JavaScript 引擎 aar，而 iOS 则是使用源码方式集成 React Native 相关的依赖库。两方的核心都是依赖 React Native 框架、JavaScript 引擎，以及框架本身依赖的其他库。</p><h2>载体页设计</h2><p>搭建好工程环境配置后，我们就要来设计一个 React Native 载体页了。载体页是加载渲染 React Native 的容器，在 Android 中为 Activity/Fragment，在 iOS 中为 ViewController。</p><p>按照官方的<a href=\"https://reactnative.cn/docs/integration-with-existing-apps\">文档</a>，一个简单的载体页只需要初始化、加载渲染、生命周期管理、组件注册能力即可。以 Android 为例，搭建一个 Activity，构建 ReactRootView，初始化 ReactInstanceManager 就可以加载本地的 bundle 文件了。你可以按照官方文档，快速搭建一个 React Native 载体页试试。</p><p>但在实际开发中，我们使用 React Native，除了看中它跨平台的优势外，还需要它的热更新能力。并且，为了进行Bug调试和分析，需要具备错误处理、上报能力，以及复杂业务中，Native & JavaScript 通信还需要提供通信能力。甚至，根据业务需求，还需要提供一些通用内置组件、组件注册能力，等等。</p><p>所以<strong>一个可用于商业上线的载体页</strong>，需要提供初始化、加载渲染 React Native 页面、热更新、缓存管理、生命周期管理、Native & JavaScript 通信、错误处理、错误上报、内置基础组件、组件注册等能力。所以接下来，我们就基于此来进行载体页的整体设计。</p><h3>载体页整体设计</h3><p>这里，直接根据上述要求设计好了一个载体页，你先整体看一看：</p><p><img src=\"https://static001.geekbang.org/resource/image/53/79/53d89b657d6532f86563c19e7a7a0e79.jpg?wh=1482x1116\" alt=\"图片\"></p><p>你可以看到，一个完整的载体页设计，应该包含下面几个部分：</p><ul>\n<li><strong>UI 结构</strong>：在混合开发中，React Native 大部分以独立页面存在，载体页可以包含通用标题栏和 React Native 容器。当然也可以直接暴露容器视图，由使用方动态进行添加；</li>\n<li><strong>对外能力</strong>：包含生命周期管理、Native 与 JavaScript 通信能力、内置的基础业务组件、组件注册能力、异常回调、错误上报等，同时还需要提供热更新、加载 bundle 的能力；</li>\n<li><strong>热更新</strong>：请求远程服务器获取对应 bundle 是否有最新版本。有最新版本则下载并进行缓存，无最新版本则使用缓存进行加载 (无缓存则先下载)，其中包含预加载、异步更新等业务策略提升加载性能。</li>\n<li><strong>缓存管理</strong>：通常 bundle 包随着业务体量增加，体积会越来越大。针对这种情况，我们的常用策略是拆包、按需加载，bundle 包在传输过程中会进行 zip 压缩、加密，下载成功后进行解压、校验。每个 bundle 文件都有对应的 id、版本号、content hash；</li>\n<li><strong>bundle 加载</strong>：JavaScript 引擎读取 bundle 文件，常用引擎包括 JSC、Hermes；</li>\n<li><strong>React Native 运行环境</strong>：整个 React Native 运行环境包含负责渲染的 RootView，框架内置核心组件、业务定制组件，执行脚本的 JavaScript 引擎，负责 Native 与 JavaScript 交互的 bridge/JSI。</li>\n</ul><h3>如何初始化载体页？</h3><p>讲完了载体页设计后，我们来看看如何对载体页进行初始化。这里我们说的初始化，除了自身业务封装的初始化外，核心还是 React Native 框架本身的初始化。接下来我们依然分成 Android、iOS 两端来分析。</p><h4>Android</h4><p>我们来看下 Android 端的初始化。不过为了方便后续代码的讲解，需要先带你了解下 React Native Android 中几个常用类的作用：</p><ul>\n<li><strong>ReactContext</strong>：继承于 ContextWrapper，是 React Native 应用的上下文，管理着 CatalystInstance 以及三大线程 （UIThread、NativeModulesThread、JSThread）；</li>\n<li><strong>ReactInstanceManager</strong>：总的管理类，管理 ReactPackage、ReactContext、ReactRootView、控制生命周期，同时还可以设置 JavaScript 引擎；</li>\n<li><strong>ReactRootView</strong>：React Native 渲染的原生容器，继承于 FrameLayout；</li>\n<li><strong>CatalystInstance</strong>：Java 层、C++ 层、JavaScript 层通信的总管理类，管理着 Java 层、JavaScript 层 Module 映射表与回调，是三端通信的桥梁。实现类为 CatalystInstanceImpl，支持向 JavaScript 注入全局变量、动态加载脚本文件、获取 NativeModules &amp; JSModules；</li>\n<li><strong>JavaScriptModule</strong>：JS Module，负责 JavaScript 到 Java 的映射调用格式声明，由CatalystInstance 统一管理；</li>\n<li><strong>NativeModule</strong>：Java Module，负责 Java 到 JavaScript 的映射调用格式声明，由CatalystInstance 统一管理；</li>\n<li><strong>UIManager</strong>: 处理 UI 的渲染，JavaScript 层通过 C++ 层把创建 View 的请求发送给 Java 层的UIManagerModule。</li>\n</ul><p>初始化的核心是通过 ReactInstanceManagerBuilder 构建 ReactInstanceManager，<a href=\"https://reactnative.cn/docs/integration-with-existing-apps\">官方</a>提供了对 ReactInstanceManager 的构建说明。我们直接来看一段 Demo：</p><pre><code class=\"language-plain\">ReactInstanceManagerBuilder builder = ReactInstanceManager.builder();\n// 设置 application 上下文\nbuilder.setApplication((Application) context.getApplicationContext());\n\n// 添加包，一个 package 由多个组件构成，上述代码中的 MainReactPackage 是 RN 内置的 package \nbuilder.addPackage(new MainReactPackage());\n\n// JS 异常回调处理实现，在这个实现中我们可以打印 JS 异常日志，上报错误\nbuilder.setRedBoxHandler(mRedBoxHandler); \n\n// native module 异常回调处理实现，在这个实现中我们可以打印 native module 异常日志，上报错误\nbuilder.setNativeModuleCallExceptionHandler(mNativeModuleExceptionHandler);\n\n// JS bundle 中主入口的文件名，demo 中 \"index\" 表示入口文件名为 index.js\nbuilder.setJSMainModulePath(\"index\");\n\n// 是否开启 dev 模式\nbuilder.setUseDeveloperSupport(true);\n\n// 设置创建时机\nbuilder.setInitialLifecycleState(LifecycleState.BEFORE_CREATE); \n\n// 设置 JS 引擎，如果想使用 Hermes 引擎，可以这样设置，需要引入 Hermes 相关的 so 库\n// builder.setJavaScriptExecutorFactory(new HermesExecutorFactory());\n\nReactInstanceManager reactInstanceManager = builder.build();\n</code></pre><p>然后我们要获取 ReactContext，ReactContext 在后续加载渲染过程中会用到：</p><pre><code class=\"language-plain\">reactInstanceManager.addReactInstanceEventListener(new ReactInstanceManager.ReactInstanceEventListener() {\n    @Override\n    public void onReactContextInitialized(ReactContext reactContext) {\n       mReactContext = reactContext;\n    }\n});\n</code></pre><p>至此，Android 端的初始化工作就完成了，接着我们来看下 iOS 端的初始化逻辑。</p><h4>iOS</h4><p>iOS 端初始化载体页比较简单，只需要下面几个步骤。</p><p>首先，我们要创建一个 Bridge。在 React Native 中，通过 Bridge 实现了 JavaScript 与原生框架之间的通信，调用 React Native 提供的 API ，就相当于通过 Bridge 调用原生的API。因此，我们需要创建一个 Bridge，与载体页一对一绑定。</p><pre><code class=\"language-plain\">&nbsp;RCTBridge *carrierBridge = [[RCTBridge alloc] initWithDelegate:self \n                                               launchOptions:nil];\n</code></pre><p>接下来，我们需要创建一个 RCTRootView，用于展示 React Native 视图的组件RCTRootView，在 JavaScript 代码中 render() 部分的 UI 组件均会渲染到该 View 中，创建方式如下：</p><pre><code class=\"language-plain\">&nbsp;RCTRootView *rctView = [[RCTRootView alloc] initWithBridge:bridge \n                                             moduleName:moduleName \n                                             initialProperties:nil];\n [self.view addSubview:rctView];\n</code></pre><p>到此， iOS 端初始化准备过程就完成了。你看，确实比较简单吧？</p><p>那么接下来，我们就需要获取 React Native 代码包，也就是 JS Bundle 资源。那么我们要怎么动态下载 JS Bundle资源呢？</p><p>我们可以采用热更新策略，动态下载 JS bundle 资源。每个不同的 JS bundle包都有它自己的标识 id，我们可以根据该 id 从服务器中获取该 JS bundle 资源对应的最新版本号，以及最新资源下载地址。</p><p>在获取 JS Bundle 的最新版本号后，如果用户之前浏览过当前 React Native 页面，还存在缓存，那么我们就可以检测缓存版本号是否与最新版本号相同。如果是相同的，就不需要重复下载了；如果不相同，那你还要根据最新资源下载地址，下载最新的资源包，并缓存到本地。</p><p>要是用户之前并没有浏览过当前 React Native 页面，或者缓存已被清空，你可以直接根据最新资源下载地址，下载最新的资源包，并缓存到本地。</p><p>你可以看一下这张整体流程图加深理解：</p><p><img src=\"https://static001.geekbang.org/resource/image/24/49/24560021a3f881746b0b2d76aa71bb49.jpg?wh=1052x874\" alt=\"图片\"></p><h3>加载渲染</h3><p>通过以上步骤，我们就能创建好载体页并成功下载 JS bundle了，那么现在就可以准备开始执行 JavaScript 代码并渲染 React Native 页面了。我们先来看下 Android 端是如何加载 JS bundle 文件的。</p><h4>加载JS bundle（Android）</h4><p>Android 端通过 ReactContext 获取 CatalystInstance 对象，CatalystInstance 实现类为 CatalystInstanceImp。CatalystInstanceImpl 有一个非 public 方法 loadScriptFromFile()，我们通过这个方法就可以动态加载本地的 bundle 文件了。不过，由于 loadScriptFromFile() 为非 public，所以需要反射获取调用：</p><pre><code class=\"language-plain\">CatalystInstance catalystInstance = mReactContext.getCatalystInstance();\nMethod loadScripFromFileMethod = CatalystInstanceImpl.class.getDeclaredMethod(\"loadScriptFromFile\", String.class, String.class, boolean.class);\nloadScripFromFileMethod.setAccessible(true);\n// fileName 和 sourceURL 传入本地缓存的 bundle 路径，loadSynchronously 为是否同步加载\nloadScripFromFileMethod.invoke(catalystInstance, fileName, sourceURL, loadSynchronously);\n</code></pre><p>接着，我们再调用 ReactRootView startReactApplication 就可以开始加载渲染 React Native 页面了。这里要注意，startReactApplication() 中的参数 moduleName 必须对应 “index.js” 中的 “AppRegistry.registerComponent()” 的第一个参数：</p><pre><code class=\"language-plain\">reactRootView.startReactApplication(reactInstanceManager, moduleName, launchOption);\n</code></pre><p>我们还可以使用 catalystInstance.setGlobalVariable() 设置全局变量。设置好后，JavaScript 运行时可获取到这些全局变量了：</p><pre><code class=\"language-plain\">catalystInstance.setGlobalVariable(\"xxx\", xxx)\n</code></pre><p>到这里，Android 端动态加载 bundle 就讲完了，我们继续来看 iOS 加载 bundle 的流程。</p><h4>加载JS bundle（iOS）</h4><p>其实，iOS 端可以在包下载完成后初始化 Bridge（注： Bridge 在源码中是 JS Bridge 或者 JSI 的统称）。Bridge初始化后，我们就可以开始加载下载好的 JavaScript 包了。</p><p>整体的流程是这样的：</p><ul>\n<li>在初始化Bridge时，在 setup 的过程中，首先会调用 bridge 的代理方法 (NSURL *)sourceURLForBridge : (RCTBridge *)bridge 方法，指定获取 JS bundle 的路径：</li>\n</ul><pre><code class=\"language-plain\">&nbsp;-(NSURL *)sourceURLForBridge:(RCTBridge *)bridge{\n    NSString *bundlePath = [self getCurrentBundlePath:bundleid];\n    return bundlePath;\n}\n</code></pre><ul>\n<li>确定 URL 之后，bridge 会调用 start 方法，开始加载 JS bundle 并调用以下方法：</li>\n</ul><pre><code class=\"language-plain\">&nbsp;[self loadSource:^(NSError *error, RCTSource *source) {\n&nbsp; &nbsp; if (error) {\n&nbsp; &nbsp; &nbsp; [weakSelf handleError:error];\n&nbsp; &nbsp; }\n    ...\n ]\n</code></pre><ul>\n<li>接下来会调用 bridge 的代理方法，我们可以在该方法中手动注入一些业务参数：</li>\n</ul><pre><code class=\"language-plain\">- (void)loadSourceForBridge:(RCTBridge *)bridge\n&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; onProgress:(RCTSourceLoadProgressBlock)onProgress\n&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; onComplete:(RCTSourceLoadBlock)loadCallback{\n  [RCTJavaScriptLoader loadBundleAtURL:bridge.bundleURL onProgress:onProgress onComplete:^(NSError *error, RCTSource *source) {\n      //手动注入一些业务参数\n     &nbsp;NSString *string = \";this.__xxx___ = 'yyy';\"\n      NSData *stringData = [string dataUsingEncoding:NSUTF8StringEncoding];\n      \n      NSMutableData *newData = [NSMutableData dataWithData:stringData];\n      [newData appendData:source.data];\n      \n      //生成新的Source去加载\n      RCTSource * newSource = [RCTJavaScriptLoader getNewRCTSourceURL:source.url data:newData];\n&nbsp; &nbsp; &nbsp; loadCallback(error,newSource);\n  }];\n}\n</code></pre><p>之后，bridge 会负责执行该 newSource，执行 JavaScript 代码并渲染出页面。</p><h2>React Native 问题排查与框架 Bug 修复</h2><p>React Native 涉及 Native、FE、Server 三端，中间经过 JavaScript 环境、Server 数据、Native 环境的转换，如果出现了问题，排查链路很长。</p><p>而且，React Native 框架的不同版本在 Android、iOS 端都存在兼容性 bug，特别是用于混合工程时这个问题会更加明显。因为，React Native 的许多设计都是以纯 React Native 工程为出发点的，混合工程中随着业务越来越复杂，内存占用、兼容问题、多线程问题都会暴露出来。</p><p>接下来，我们就来看下在 Android、iOS 端分别要怎么进行 React Native 问题排查与框架 Bug 修复。</p><h3>Android 问题排查与框架 bug 修复</h3><p>我们的问题排查思路很简单：只要有足够多的日志，就能帮我们足够快地定位问题。</p><p>所以我们首先要<strong>添加日志输出</strong>。我们可以通过 ReactInstanceManagerBuilder 获取 JavaScript、native 运行错误：</p><pre><code class=\"language-plain\">ReactInstanceManagerBuilder builder = ReactInstanceManager.builder();\nbuilder.setApplication((Application) context.getApplicationContext())\n       .setRedBoxHandler(mExceptionHandler)\n       .setNativeModuleCallExceptionHandler(mExceptionHandler);\n        \nprivate static class ExceptionHandler implements NativeModuleCallExceptionHandler, RedBoxHandler {\n\n  @Override\n  public void handleException(Exception e) {\n    // 处理 Native 异常\n  }\n\n  @Override\n  public void handleRedbox(String s, StackFrame[] stackFrames, ErrorType errorType) {\n    // 处理 JS 异常\n  }\n  \n  @Override\n  public boolean isReportEnabled() {\n    return false;\n  }\n  \n  @Override\n  public void reportRedbox(Context context, String s, StackFrame[] stackFrames, String s1, ReportCompletedListener reportCompletedListener) {\n  }\n}\n</code></pre><p>接着，用 AOP 切片的方式拦截 ReactNative JavaMethodWrapper 调用，并使用 AspectJ 在编译期对 ReactNative 框架字节码进行插桩：</p><pre><code class=\"language-plain\">@Aspect\npublic class NativeModuleMethodInvokeAspect extends BaseAspect&lt;INativeModuleMethodInvokePointcut&gt; {\n\n    // 对 JavaMethodWrapper.invoke 方法调用进行插桩\n    @Around(\"execution (* com.facebook.react.bridge.JavaMethodWrapper.invoke(..))\")\n    public Object invokeNativeModuleMethod(ProceedingJoinPoint joinPoint) throws Throwable {\n        INativeModuleMethodInvokePointcut pointcut = getPointcut();\n        if(pointcut == null){\n            return joinPoint.proceed(joinPoint.getArgs());\n        }\n        return pointcut.pointcut(joinPoint);\n    }\n}\n</code></pre><p>下面这段代码是针对 Native Module 的调用做代码插桩，捕获 JavaScript 调用 Native Module 的异常：</p><pre><code>public class ModuleMethodInvokePointcut implements INativeModuleMethodInvokePointcut {\n    @Override\n    public Object pointcut(ProceedingJoinPoint proceedingJoinPoint) {\n        Object object;\n        Object target = proceedingJoinPoint.getTarget();\n        try {\n            object = proceedingJoinPoint.proceed();\n        } catch (Throwable throwable) {\n            // 异常时，通过 target 反射获取对应的 module 名称和方法\n            throwable.printStackTrace();\n            return null;\n        }\n        return object;\n    }\n}\n</code></pre><p>然后我们就可以通过下面这两个命令查看 React Native 运行日志了：</p><pre><code class=\"language-plain\">adb logcat | grep React\n</code></pre><p>最后，如果有异常日志就会上报到后台，日志信息会包含系统、机型、运行环境，以及业务标识等。有了异常日志给我们提供的这些信息，你就可以通过线下、线上手段，快速排查 React Native 相关的 bug 了。</p><p>那么接下来，我们对React Native框架的Bug进行修复呢？</p><p>在 Android 混合工程中，React Native 是以 aar 方式引入的。所以建议你对它进行包装，自行发布 aar 管理。不过源码编译方式复杂，你可以通过编译期插桩的方式对 React Native aar 进行插桩，来修复 bug。</p><p>常用的插桩方式包括 ASM、Javasist、AspectJ 这几种。我们通常可以用 AspectJ 匹配具体类的具体方法进行插桩，实现 bug 修复。选择 AspectJ 的原因是，通常我们只需要对 React Native 的一些异常方法做切片，并不需要修改里面的逻辑，它足以满足我们修改 React Native 框架问题的需要。并且， AspectJ 在易用性、可读性上比 ASM、Javasist 都更优。</p><p>以上就是 Android 端进行 React Native 的问题排查与框架 Bug 修复的常用手段，接下来我们再看看 iOS 端的。</p><h3>iOS 问题排查</h3><p>在iOS中，如果 React Native 页面在加载过程中或者运行过程中出现了异常，我们可以统一通过 typedef void (^RCTFatalHandler)(NSError *error); 来进行拦截。</p><p>首先我们要对原生的 RCTFatalHandler 中 error 参数进行改造，让 error 中带上 bridge 信息。具体改造代码如下：</p><pre><code class=\"language-plain\">- (void)error{\n    //改造error中带有bridge\n   &nbsp;NSError *newError = [self getWBErrorBridge:error];\n&nbsp; &nbsp; RCTFatal(newError);\n}\n\n//error信息里带上Bridge\n- (NSError *)getWBErrorBridge:(NSError *)error{\n&nbsp; &nbsp; NSMutableDictionary *errorDic = [NSMutableDictionary dictionaryWithDictionary:error.userInfo];\n&nbsp; &nbsp; [errorDic setObject:self-&gt;_parentBridge forKey:@\"ErrorBridgeTag\"];\n&nbsp; &nbsp; NSError *newErr = [[NSError alloc]initWithDomain:error.domain code:error.code userInfo:errorDic];\n&nbsp; &nbsp; return newErr;\n}\n</code></pre><p>出现异常后，我们要从 Error 中获取 bridge ，并找出发生异常的载体页信息，获取对应的 JS Bundle 的 ID ，以确定到底哪一个页面出现了异常：</p><pre><code class=\"language-plain\">&nbsp;RCTSetFatalHandler(^(NSError *error) {\n&nbsp; &nbsp; dispatch_async(dispatch_get_main_queue(), ^{\n        RNViewController *rnVC = nil;\n        RCTBridge *bridge = (RCTBridge *)error.userInfo[@\"ErrorBridgeTag\"];\n        if (bridge) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;carrierVC = (RNViewController *)bridge.delegate;\n&nbsp; &nbsp; &nbsp; &nbsp; }\n        NSString *descriptions = error.localizedDescription;\n        NSLog(@\"error --- %@ --- %@\", rnVC.rnModel.bundleID, descriptions);\n    }\n}\n</code></pre><p>这样，我们就可以在拦截异常后，对页面进行展示错误页面、自动修复、清空异常的 JS bundle 缓存等一系列操作了。</p><h2>总结</h2><p>今天的这一讲，我们系统地讲解了混合开发的全流程。你可以根据官方文档快速搭建起 React Native 混合工程。我们这一讲是在官方教程的基础上，结合真实项目中的实战开发经验，从环境搭建、载体页设计、调试打包发布、问题排查与框架 Bug 修复几个方面来进行讲解的。这里我们再简单复习下几个重要知识点。</p><p>关于纯 React Native 工程和混合工程分别在哪些场景使用，我们在接入 React Native 时如何进行选择的问题，核心还是在于<strong>项目有没有历史包袱</strong>。</p><p>如果是一个新的项目，需要做到快速提效，并且不需要复杂的架构，这个时候你可以选择纯 React Native 模式。如果是已上线项目来接入 React Native，架构复杂，或者需要将 React Native 当成一种基础能力提供给其他业务/App 使用，就需要使用混合模式。</p><p>遇到问题时如何快速排查定位，是我们实际开发过程中经常遇到的问题。由于 React Native 的链路比较长、涉及客户端、前端、后端，且 React Native 框架输出的日志不够多，排查问题比较困难。这个时候我们可以通过捕获 React Native 运行异常、在 React Native 框架内加入足够的日志，帮助我们来快速定位问题。</p><p>其实混合开发并没有那么难，只要理解了以上的一些关键点，就足以让你应对日常的 React Native 混合开发需求了。</p><h2>作业</h2><ol>\n<li>设计一个简单的载体页，包含初始化、加载本地 bundle 文件、异常处理逻辑。</li>\n</ol><p>欢迎在评论区分享你的想法和经验，我们下一讲再见。</p>","neighbors":{"left":{"article_title":"20｜Sentry：线上错误与性能监控怎么处理？","id":518009},"right":{"article_title":"22｜自定义组件：如何满足业务的个性化需求？","id":519819}},"comments":[{"had_liked":false,"id":363520,"user_name":"Yolo七夜","can_delete":false,"product_type":"c1","uid":1040071,"ip_address":"北京","ucode":"7CB74C0A1DF785","user_header":"https://static001.geekbang.org/account/avatar/00/0f/de/c7/26485903.jpg","comment_is_top":false,"comment_ctime":1669779492,"is_pvip":false,"replies":[{"id":133192,"content":"没见过同时用的，一般考虑到体积只会选一个。","user_name":"作者回复","user_name_real":"编辑","uid":1088541,"ctime":1672900516,"ip_address":"北京","comment_id":363520,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100110101,"comment_content":"RN 可以与 flutter直接混编吗？","like_count":0,"discussions":[{"author":{"id":1088541,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/1d/f0f10198.jpg","nickname":"蒋宏伟","note":"","ucode":"02226CABD5ECE7","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598543,"discussion_content":"没见过同时用的，一般考虑到体积只会选一个。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672900516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1040071,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/de/c7/26485903.jpg","nickname":"Yolo七夜","note":"","ucode":"7CB74C0A1DF785","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598549,"discussion_content":"好的，多谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672901734,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"湖南","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346919,"user_name":"飘逸跑酷","can_delete":false,"product_type":"c1","uid":2071511,"ip_address":"","ucode":"FD6CBBF5456FE1","user_header":"https://static001.geekbang.org/account/avatar/00/1f/9b/d7/13d8bf91.jpg","comment_is_top":false,"comment_ctime":1653537542,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100110101,"comment_content":"来波源码，参照一下","like_count":9},{"had_liked":false,"id":345876,"user_name":"下一刻。","can_delete":false,"product_type":"c1","uid":1161123,"ip_address":"","ucode":"8D2C7CF81FF8F9","user_header":"https://thirdqq.qlogo.cn/qqapp/101423631/0FD57A9C0C5BFBDA3DA69AE26B3514FB/100","comment_is_top":false,"comment_ctime":1652671888,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100110101,"comment_content":"iOS 期望可以讲解一下，类似Android arr的混合模式。把iOS RN部分打包成framework。","like_count":6},{"had_liked":false,"id":368363,"user_name":"黑马有点白986","can_delete":false,"product_type":"c1","uid":1169341,"ip_address":"北京","ucode":"C24216CBD5D7CC","user_header":"https://static001.geekbang.org/account/avatar/00/11/d7/bd/50d98f9e.jpg","comment_is_top":false,"comment_ctime":1676256536,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100110101,"comment_content":"Android 端动态加载 bundle 就讲完了,按照你的文档来，根本跑不通呀，能不能给个demo","like_count":2},{"had_liked":false,"id":362693,"user_name":"Geek_585b44","can_delete":false,"product_type":"c1","uid":2895564,"ip_address":"广东","ucode":"3D79002A362D4D","user_header":"","comment_is_top":false,"comment_ctime":1668757049,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100110101,"comment_content":"没看懂iOS是怎么集成RN的，没有demo吗","like_count":2},{"had_liked":false,"id":345877,"user_name":"下一刻。","can_delete":false,"product_type":"c1","uid":1161123,"ip_address":"","ucode":"8D2C7CF81FF8F9","user_header":"https://thirdqq.qlogo.cn/qqapp/101423631/0FD57A9C0C5BFBDA3DA69AE26B3514FB/100","comment_is_top":false,"comment_ctime":1652671974,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100110101,"comment_content":"安卓使用arr混合模式后，可以抛弃node_modules，那么如果项目中使用到一些原生第三方库，应该如何处理呢？","like_count":2,"discussions":[{"author":{"id":2414909,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL2kSl1ghNbibPj2icenYMSgdzRicE9wVYlia2KM2HfT4MjIPzPSFE7VMWf1KtLmqXnJhLDlvtRWCYBfg/132","nickname":"Geek_bae193","note":"","ucode":"CA0203A3D98331","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572329,"discussion_content":"对于第三方库，可以单独建module托管，发布aar。如果直接依赖或link，那么RN作为通用模块或SDK发布会会缺失类。\n\n当然，如果你只是在一个工程中使用RN，可以使用node_modules托管一起打包","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652710323,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":372623,"user_name":"大神博士","can_delete":false,"product_type":"c1","uid":1195144,"ip_address":"上海","ucode":"8C4318095949F0","user_header":"https://static001.geekbang.org/account/avatar/00/12/3c/88/6bef27d6.jpg","comment_is_top":false,"comment_ctime":1681356657,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100110101,"comment_content":"podspec 参考哪啊，大哥，不能就直接给个 github 项目首页的地址吧","like_count":1},{"had_liked":false,"id":350606,"user_name":"Geek_4a10b1","can_delete":false,"product_type":"c1","uid":2885799,"ip_address":"","ucode":"4E5DE55035E5D9","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTISicpsLbj7rPDKW5HpUVExAT3ljKKVHvMSgFm3hWzZBSFiaHNteUuuicEdySFopjL0U4FQJb7PxkBicQ/132","comment_is_top":false,"comment_ctime":1657034218,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100110101,"comment_content":"关于混合开发的环境集成这块儿有个问题咨询下，如果Android项目集成新版本架构，我看官网介绍需要依赖nodemodule里的react-native-gradle-plugin，nodemodule都被删了的话，这一步你们是怎么处理呢？另外如果要用TuboModule和Fabric，需要生成各种c++文件使用NDK进行编译，采用混合开发这种集成方式的话这一步又要怎么处理呢？","like_count":1,"discussions":[{"author":{"id":2728381,"avatar":"https://static001.geekbang.org/account/avatar/00/29/a1/bd/c34fbd5d.jpg","nickname":"六七一十三","note":"","ucode":"072D8083BEB836","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":626156,"discussion_content":"+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1692603380,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":348422,"user_name":"Sunny","can_delete":false,"product_type":"c1","uid":1667101,"ip_address":"","ucode":"EED137B5B96EA3","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/1d/c59e0b59.jpg","comment_is_top":false,"comment_ctime":1655096699,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100110101,"comment_content":"请问下，纯RN的客户端如何配置热更新？如果能具体些，非常感谢！期望是搭配23章CDN方案实现","like_count":1,"discussions":[{"author":{"id":1582241,"avatar":"https://static001.geekbang.org/account/avatar/00/18/24/a1/00ccc77f.jpg","nickname":"Xe","note":"","ucode":"DE2F87B5E9E3A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":594132,"discussion_content":"解决了吗？解决了分享一下😜","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1668824203,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346220,"user_name":"小怪兽","can_delete":false,"product_type":"c1","uid":1822766,"ip_address":"","ucode":"9ADCC89022A9BD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIdLUtkvdNcLalw2PUxJaXY7Giacj4ZnGSPPTJkauHpoSG1jurGxxFXXf5zV52r1oRLzOuEBdmdGEA/132","comment_is_top":false,"comment_ctime":1652926143,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100110101,"comment_content":"不用添加react.gradle脚本吗","like_count":1,"discussions":[{"author":{"id":1161123,"avatar":"https://thirdqq.qlogo.cn/qqapp/101423631/0FD57A9C0C5BFBDA3DA69AE26B3514FB/100","nickname":"下一刻。","note":"","ucode":"8D2C7CF81FF8F9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572880,"discussion_content":"react.gradle脚本主要是打包RN Bundle产物，混合开发一般单独写脚本做打包这一步","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653027642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386614,"user_name":"Print JQK°","can_delete":false,"product_type":"c1","uid":2093678,"ip_address":"天津","ucode":"68C42D72FBF5F3","user_header":"https://static001.geekbang.org/account/avatar/00/1f/f2/6e/6f621806.jpg","comment_is_top":false,"comment_ctime":1705224025,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100110101,"comment_content":"来波源码，参考一下","like_count":0},{"had_liked":false,"id":372721,"user_name":"大神博士","can_delete":false,"product_type":"c1","uid":1195144,"ip_address":"上海","ucode":"8C4318095949F0","user_header":"https://static001.geekbang.org/account/avatar/00/12/3c/88/6bef27d6.jpg","comment_is_top":false,"comment_ctime":1681469491,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100110101,"comment_content":"我用 swift 集成了一下，开发阶段热更新也没有问题，但是如果有报错，iOS 就崩溃了，这是怎么回事？\n&#39;-[hybridnative.AppDelegate window]: unrecognized selector sent to instance","like_count":0},{"had_liked":false,"id":369135,"user_name":"王小东","can_delete":false,"product_type":"c1","uid":1513037,"ip_address":"安徽","ucode":"C56ABDC10B01E4","user_header":"https://static001.geekbang.org/account/avatar/00/17/16/4d/a2f34fe1.jpg","comment_is_top":false,"comment_ctime":1677138290,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100110101,"comment_content":"新手小白提问，这种搭建的是线上运行环境吧 如何搭建方便调试的开发环境呢","like_count":0},{"had_liked":false,"id":354916,"user_name":"songyq","can_delete":false,"product_type":"c1","uid":2427725,"ip_address":"美国","ucode":"0A95EBA8D2F16A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLib4GiaK4KB3UvnnzIkMAD4QzKBAkOzdntPwsb8RX1xjHYgr2w0GLWhmoPdwy3iby3zOHbeTBR2DgRQ/132","comment_is_top":false,"comment_ctime":1660879272,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100110101,"comment_content":" RCTSetFatalHandler(^(NSError *error) {\n    dispatch_async(dispatch_get_main_queue(), ^{\n        RNViewController *rnVC = nil;\n        RCTBridge *bridge = (RCTBridge *)error.userInfo[@&quot;ErrorBridgeTag&quot;];\n        if (bridge) {\n           carrierVC = (RNViewController *)bridge.delegate;\n        }\n        NSString *descriptions = error.localizedDescription;\n        NSLog(@&quot;error --- %@ --- %@&quot;, rnVC.rnModel.bundleID, descriptions);\n    }\n}\n指出一处错误\ncarrierVC 名称错误了，应该是rnVC","like_count":0},{"had_liked":false,"id":354915,"user_name":"songyq","can_delete":false,"product_type":"c1","uid":2427725,"ip_address":"美国","ucode":"0A95EBA8D2F16A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLib4GiaK4KB3UvnnzIkMAD4QzKBAkOzdntPwsb8RX1xjHYgr2w0GLWhmoPdwy3iby3zOHbeTBR2DgRQ/132","comment_is_top":false,"comment_ctime":1660879150,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100110101,"comment_content":"RNViewController *rnVC = nil; RCTBridge *bridge = (RCTBridge *)error.userInfo[@&quot;ErrorBridgeTag&quot;]; if (bridge) { carrierVC = (RNViewController *)bridge.delegate; } NSString *des","like_count":0},{"had_liked":false,"id":351734,"user_name":"Geek_444dfb","can_delete":false,"product_type":"c1","uid":2998678,"ip_address":"","ucode":"4782E3AE0086DD","user_header":"","comment_is_top":false,"comment_ctime":1658136073,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100110101,"comment_content":"大佬，有没有精简的demo呢，希望能来一份😁","like_count":0},{"had_liked":false,"id":351331,"user_name":"赱叉月月鳥","can_delete":false,"product_type":"c1","uid":1119301,"ip_address":"","ucode":"DC1B908AF9E0EF","user_header":"https://static001.geekbang.org/account/avatar/00/11/14/45/788e2e12.jpg","comment_is_top":false,"comment_ctime":1657706935,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100110101,"comment_content":"这里没看懂：然后你将这三个部分作为 React Native 功能模块，直接参考官方提供的 podspec","like_count":0},{"had_liked":false,"id":348554,"user_name":"长林啊","can_delete":false,"product_type":"c1","uid":1707743,"ip_address":"","ucode":"B75CB4919FF25A","user_header":"https://static001.geekbang.org/account/avatar/00/1a/0e/df/a64b3146.jpg","comment_is_top":false,"comment_ctime":1655193420,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":1,"score":3,"product_id":100110101,"comment_content":"老师，如何使用 RN 构建一个多路由视图的RN SDK呢？\n","like_count":0}]}