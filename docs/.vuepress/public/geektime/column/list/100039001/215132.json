{"id":215132,"title":"61 | 策略模式（下）：如何实现一个支持给不同大小文件排序的小程序？","content":"<p>上一节课，我们主要介绍了策略模式的原理和实现，以及如何利用策略模式来移除if-else或者switch-case分支判断逻辑。今天，我们结合“给文件排序”这样一个具体的例子，来详细讲一讲策略模式的设计意图和应用场景。</p><p>除此之外，在今天的讲解中，我还会通过一步一步地分析、重构，给你展示一个设计模式是如何“创造”出来的。通过今天的学习，你会发现，<strong>设计原则和思想其实比设计模式更加普适和重要，掌握了代码的设计原则和思想，我们甚至可以自己创造出来新的设计模式</strong>。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>问题与解决思路</h2><p>假设有这样一个需求，希望写一个小程序，实现对一个文件进行排序的功能。文件中只包含整型数，并且，相邻的数字通过逗号来区隔。如果由你来编写这样一个小程序，你会如何来实现呢？你可以把它当作面试题，先自己思考一下，再来看我下面的讲解。</p><p>你可能会说，这不是很简单嘛，只需要将文件中的内容读取出来，并且通过逗号分割成一个一个的数字，放到内存数组中，然后编写某种排序算法（比如快排），或者直接使用编程语言提供的排序函数，对数组进行排序，最后再将数组中的数据写入文件就可以了。</p><p>但是，如果文件很大呢？比如有10GB大小，因为内存有限（比如只有8GB大小），我们没办法一次性加载文件中的所有数据到内存中，这个时候，我们就要利用外部排序算法（具体怎么做，可以参看我的另一个专栏《数据结构与算法之美》中的“排序”相关章节）了。</p><!-- [[[read_end]]] --><p>如果文件更大，比如有100GB大小，我们为了利用CPU多核的优势，可以在外部排序的基础之上进行优化，加入多线程并发排序的功能，这就有点类似“单机版”的MapReduce。</p><p>如果文件非常大，比如有1TB大小，即便是单机多线程排序，这也算很慢了。这个时候，我们可以使用真正的MapReduce框架，利用多机的处理能力，提高排序的效率。</p><h2>代码实现与分析</h2><p>解决思路讲完了，不难理解。接下来，我们看一下，如何将解决思路翻译成代码实现。</p><p>我先用最简单直接的方式将它实现出来。具体代码我贴在下面了，你可以先看一下。因为我们是在讲设计模式，不是讲算法，所以，在下面的代码实现中，我只给出了跟设计模式相关的骨架代码，并没有给出每种排序算法的具体代码实现。感兴趣的话，你可以自行实现一下。</p><pre><code>public class Sorter {\n  private static final long GB = 1000 * 1000 * 1000;\n\n  public void sortFile(String filePath) {\n    // 省略校验逻辑\n    File file = new File(filePath);\n    long fileSize = file.length();\n    if (fileSize &lt; 6 * GB) { // [0, 6GB)\n      quickSort(filePath);\n    } else if (fileSize &lt; 10 * GB) { // [6GB, 10GB)\n      externalSort(filePath);\n    } else if (fileSize &lt; 100 * GB) { // [10GB, 100GB)\n      concurrentExternalSort(filePath);\n    } else { // [100GB, ~)\n      mapreduceSort(filePath);\n    }\n  }\n\n  private void quickSort(String filePath) {\n    // 快速排序\n  }\n\n  private void externalSort(String filePath) {\n    // 外部排序\n  }\n\n  private void concurrentExternalSort(String filePath) {\n    // 多线程外部排序\n  }\n\n  private void mapreduceSort(String filePath) {\n    // 利用MapReduce多机排序\n  }\n}\n\npublic class SortingTool {\n  public static void main(String[] args) {\n    Sorter sorter = new Sorter();\n    sorter.sortFile(args[0]);\n  }\n}\n</code></pre><p>在“编码规范”那一部分我们讲过，函数的行数不能过多，最好不要超过一屏的大小。所以，为了避免sortFile()函数过长，我们把每种排序算法从sortFile()函数中抽离出来，拆分成4个独立的排序函数。</p><p>如果只是开发一个简单的工具，那上面的代码实现就足够了。毕竟，代码不多，后续修改、扩展的需求也不多，怎么写都不会导致代码不可维护。但是，如果我们是在开发一个大型项目，排序文件只是其中的一个功能模块，那我们就要在代码设计、代码质量上下点儿功夫了。只有每个小的功能模块都写好，整个项目的代码才能不差。</p><p>在刚刚的代码中，我们并没有给出每种排序算法的代码实现。实际上，如果自己实现一下的话，你会发现，每种排序算法的实现逻辑都比较复杂，代码行数都比较多。所有排序算法的代码实现都堆在Sorter一个类中，这就会导致这个类的代码很多。而在“编码规范”那一部分中，我们也讲到，一个类的代码太多也会影响到可读性、可维护性。除此之外，所有的排序算法都设计成Sorter的私有函数，也会影响代码的可复用性。</p><h2>代码优化与重构</h2><p>只要掌握了我们之前讲过的设计原则和思想，针对上面的问题，即便我们想不到该用什么设计模式来重构，也应该能知道该如何解决，那就是将Sorter类中的某些代码拆分出来，独立成职责更加单一的小类。实际上，拆分是应对类或者函数代码过多、应对代码复杂性的一个常用手段。按照这个解决思路，我们对代码进行重构。重构之后的代码如下所示：</p><pre><code>public interface ISortAlg {\n  void sort(String filePath);\n}\n\npublic class QuickSort implements ISortAlg {\n  @Override\n  public void sort(String filePath) {\n    //...\n  }\n}\n\npublic class ExternalSort implements ISortAlg {\n  @Override\n  public void sort(String filePath) {\n    //...\n  }\n}\n\npublic class ConcurrentExternalSort implements ISortAlg {\n  @Override\n  public void sort(String filePath) {\n    //...\n  }\n}\n\npublic class MapReduceSort implements ISortAlg {\n  @Override\n  public void sort(String filePath) {\n    //...\n  }\n}\n\npublic class Sorter {\n  private static final long GB = 1000 * 1000 * 1000;\n\n  public void sortFile(String filePath) {\n    // 省略校验逻辑\n    File file = new File(filePath);\n    long fileSize = file.length();\n    ISortAlg sortAlg;\n    if (fileSize &lt; 6 * GB) { // [0, 6GB)\n      sortAlg = new QuickSort();\n    } else if (fileSize &lt; 10 * GB) { // [6GB, 10GB)\n      sortAlg = new ExternalSort();\n    } else if (fileSize &lt; 100 * GB) { // [10GB, 100GB)\n      sortAlg = new ConcurrentExternalSort();\n    } else { // [100GB, ~)\n      sortAlg = new MapReduceSort();\n    }\n    sortAlg.sort(filePath);\n  }\n}\n</code></pre><p>经过拆分之后，每个类的代码都不会太多，每个类的逻辑都不会太复杂，代码的可读性、可维护性提高了。除此之外，我们将排序算法设计成独立的类，跟具体的业务逻辑（代码中的if-else那部分逻辑）解耦，也让排序算法能够复用。这一步实际上就是策略模式的第一步，也就是将策略的定义分离出来。</p><p>实际上，上面的代码还可以继续优化。每种排序类都是无状态的，我们没必要在每次使用的时候，都重新创建一个新的对象。所以，我们可以使用工厂模式对对象的创建进行封装。按照这个思路，我们对代码进行重构。重构之后的代码如下所示：</p><pre><code>public class SortAlgFactory {\n  private static final Map&lt;String, ISortAlg&gt; algs = new HashMap&lt;&gt;();\n\n  static {\n    algs.put(&quot;QuickSort&quot;, new QuickSort());\n    algs.put(&quot;ExternalSort&quot;, new ExternalSort());\n    algs.put(&quot;ConcurrentExternalSort&quot;, new ConcurrentExternalSort());\n    algs.put(&quot;MapReduceSort&quot;, new MapReduceSort());\n  }\n\n  public static ISortAlg getSortAlg(String type) {\n    if (type == null || type.isEmpty()) {\n      throw new IllegalArgumentException(&quot;type should not be empty.&quot;);\n    }\n    return algs.get(type);\n  }\n}\n\npublic class Sorter {\n  private static final long GB = 1000 * 1000 * 1000;\n\n  public void sortFile(String filePath) {\n    // 省略校验逻辑\n    File file = new File(filePath);\n    long fileSize = file.length();\n    ISortAlg sortAlg;\n    if (fileSize &lt; 6 * GB) { // [0, 6GB)\n      sortAlg = SortAlgFactory.getSortAlg(&quot;QuickSort&quot;);\n    } else if (fileSize &lt; 10 * GB) { // [6GB, 10GB)\n      sortAlg = SortAlgFactory.getSortAlg(&quot;ExternalSort&quot;);\n    } else if (fileSize &lt; 100 * GB) { // [10GB, 100GB)\n      sortAlg = SortAlgFactory.getSortAlg(&quot;ConcurrentExternalSort&quot;);\n    } else { // [100GB, ~)\n      sortAlg = SortAlgFactory.getSortAlg(&quot;MapReduceSort&quot;);\n    }\n    sortAlg.sort(filePath);\n  }\n}\n</code></pre><p>经过上面两次重构之后，现在的代码实际上已经符合策略模式的代码结构了。我们通过策略模式将策略的定义、创建、使用解耦，让每一部分都不至于太复杂。不过，Sorter类中的sortFile()函数还是有一堆if-else逻辑。这里的if-else逻辑分支不多、也不复杂，这样写完全没问题。但如果你特别想将if-else分支判断移除掉，那也是有办法的。我直接给出代码，你一看就能明白。实际上，这也是基于查表法来解决的，其中的“algs”就是“表”。</p><pre><code>public class Sorter {\n  private static final long GB = 1000 * 1000 * 1000;\n  private static final List&lt;AlgRange&gt; algs = new ArrayList&lt;&gt;();\n  static {\n    algs.add(new AlgRange(0, 6*GB, SortAlgFactory.getSortAlg(&quot;QuickSort&quot;)));\n    algs.add(new AlgRange(6*GB, 10*GB, SortAlgFactory.getSortAlg(&quot;ExternalSort&quot;)));\n    algs.add(new AlgRange(10*GB, 100*GB, SortAlgFactory.getSortAlg(&quot;ConcurrentExternalSort&quot;)));\n    algs.add(new AlgRange(100*GB, Long.MAX_VALUE, SortAlgFactory.getSortAlg(&quot;MapReduceSort&quot;)));\n  }\n\n  public void sortFile(String filePath) {\n    // 省略校验逻辑\n    File file = new File(filePath);\n    long fileSize = file.length();\n    ISortAlg sortAlg = null;\n    for (AlgRange algRange : algs) {\n      if (algRange.inRange(fileSize)) {\n        sortAlg = algRange.getAlg();\n        break;\n      }\n    }\n    sortAlg.sort(filePath);\n  }\n\n  private static class AlgRange {\n    private long start;\n    private long end;\n    private ISortAlg alg;\n\n    public AlgRange(long start, long end, ISortAlg alg) {\n      this.start = start;\n      this.end = end;\n      this.alg = alg;\n    }\n\n    public ISortAlg getAlg() {\n      return alg;\n    }\n\n    public boolean inRange(long size) {\n      return size &gt;= start &amp;&amp; size &lt; end;\n    }\n  }\n}\n</code></pre><p>现在的代码实现就更加优美了。我们把可变的部分隔离到了策略工厂类和Sorter类中的静态代码段中。当要添加一个新的排序算法时，我们只需要修改策略工厂类和Sort类中的静态代码段，其他代码都不需要修改，这样就将代码改动最小化、集中化了。</p><p>你可能会说，即便这样，当我们添加新的排序算法的时候，还是需要修改代码，并不完全符合开闭原则。有什么办法让我们完全满足开闭原则呢？</p><p>对于Java语言来说，我们可以通过反射来避免对策略工厂类的修改。具体是这么做的：我们通过一个配置文件或者自定义的annotation来标注都有哪些策略类；策略工厂类读取配置文件或者搜索被annotation标注的策略类，然后通过反射动态地加载这些策略类、创建策略对象；当我们新添加一个策略的时候，只需要将这个新添加的策略类添加到配置文件或者用annotation标注即可。还记得上一节课的课堂讨论题吗？我们也可以用这种方法来解决。</p><p>对于Sorter来说，我们可以通过同样的方法来避免修改。我们通过将文件大小区间和算法之间的对应关系放到配置文件中。当添加新的排序算法时，我们只需要改动配置文件即可，不需要改动代码。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>一提到if-else分支判断，有人就觉得它是烂代码。如果if-else分支判断不复杂、代码不多，这并没有任何问题，毕竟if-else分支判断几乎是所有编程语言都会提供的语法，存在即有理由。遵循KISS原则，怎么简单怎么来，就是最好的设计。非得用策略模式，搞出n多类，反倒是一种过度设计。</p><p>一提到策略模式，有人就觉得，它的作用是避免if-else分支判断逻辑。实际上，这种认识是很片面的。策略模式主要的作用还是解耦策略的定义、创建和使用，控制代码的复杂度，让每个部分都不至于过于复杂、代码量过多。除此之外，对于复杂代码来说，策略模式还能让其满足开闭原则，添加新策略的时候，最小化、集中化代码改动，减少引入bug的风险。</p><p>实际上，设计原则和思想比设计模式更加普适和重要。掌握了代码的设计原则和思想，我们能更清楚的了解，为什么要用某种设计模式，就能更恰到好处地应用设计模式。</p><h2>课堂讨论</h2><ol>\n<li>在过去的项目开发中，你有没有用过策略模式，都是为了解决什么问题才使用的？</li>\n<li>你可以说一说，在什么情况下，我们才有必要去掉代码中的if-else或者switch-case分支逻辑呢？</li>\n</ol><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>","neighbors":{"left":{"article_title":"60 | 策略模式（上）：如何避免冗长的if-else/switch分支判断代码？","id":214014},"right":{"article_title":"62 | 职责链模式（上）：如何实现可灵活扩展算法的敏感信息过滤框架？","id":216278}},"comments":[{"had_liked":false,"id":193461,"user_name":"吴小智","can_delete":false,"product_type":"c1","uid":1310798,"ip_address":"","ucode":"C7C9F58B5C9F7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","comment_is_top":false,"comment_ctime":1584894448,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"821923647984","product_id":100039001,"comment_content":"&quot;设计原则和思想比设计模式更加普适和重要&quot;，被这句话一下子点醒了。可以这样说，设计原则和思想是更高层次的理论和指导原则，设计模式只是这些理论和指导原则下，根据经验和场景，总结出来的编程范式。","like_count":192,"discussions":[{"author":{"id":2190078,"avatar":"https://static001.geekbang.org/account/avatar/00/21/6a/fe/3ac6392c.jpg","nickname":"Mr.K","note":"","ucode":"601ECA7C36AAE4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":354335,"discussion_content":"设计原则和思想更像内功心法，设计模式就是武功招式，招式是领会心法而生，不会心法，只会套用招式，注定无法成为一代武林大师。","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1615277488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2225926,"avatar":"","nickname":"Geek_eaff30","note":"","ucode":"751D26C18D13C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2190078,"avatar":"https://static001.geekbang.org/account/avatar/00/21/6a/fe/3ac6392c.jpg","nickname":"Mr.K","note":"","ucode":"601ECA7C36AAE4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372421,"discussion_content":"生动形象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620312837,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":354335,"ip_address":""},"score":372421,"extra":""}]},{"author":{"id":2612274,"avatar":"https://static001.geekbang.org/account/avatar/00/27/dc/32/8b1c20a9.jpg","nickname":"升国旗","note":"","ucode":"5140BE3BB11165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374224,"discussion_content":"道与术","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1621067965,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1598564,"avatar":"https://static001.geekbang.org/account/avatar/00/18/64/64/865c1eb4.jpg","nickname":"劳码识途","note":"","ucode":"7AEF4D9407F097","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310241,"discussion_content":"所以前面的文章才是精华，后面的文章是经验","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1601703792,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1587803,"avatar":"https://static001.geekbang.org/account/avatar/00/18/3a/5b/ce1724ca.jpg","nickname":"undefined","note":"","ucode":"867405CA5A9FB7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212537,"discussion_content":"设计原则和思想更加底层，会更贴切些。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1584976343,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1721895,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/46/27/eb318d12.jpg","nickname":"Geek_4b6813","note":"","ucode":"ED10C17BE368B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358242,"discussion_content":"简单的说就是编码的集锦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615951436,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":201802,"user_name":"岁月","can_delete":false,"product_type":"c1","uid":1337598,"ip_address":"","ucode":"29A2A2BC3C4FE4","user_header":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","comment_is_top":false,"comment_ctime":1585839029,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"297938582453","product_id":100039001,"comment_content":"看到这里我感觉好多设计模式都很类似, 都是先针对接口编程, 然后再加个查表法😂","like_count":70,"discussions":[{"author":{"id":2823635,"avatar":"","nickname":"Geek_e3cfbe","note":"","ucode":"63F918C5DF6DB8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580497,"discussion_content":"多态是面向对象3特性中最关键的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1658217691,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1324863,"avatar":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","nickname":"KK","note":"","ucode":"FFC31A3FE3A285","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569070,"discussion_content":"形似神不似。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651311357,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1144725,"avatar":"https://static001.geekbang.org/account/avatar/00/11/77/95/9d32e68c.jpg","nickname":"风絮1994","note":"","ucode":"FEB562DECA5E77","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408331,"discussion_content":"+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635228956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2475056,"avatar":"https://static001.geekbang.org/account/avatar/00/25/c4/30/711b03e5.jpg","nickname":"Geek_Candice","note":"","ucode":"0F2CBCF624F905","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393901,"discussion_content":"+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631631471,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1239663,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ea/6f/09de5f65.jpg","nickname":"小帅","note":"","ucode":"4129A7E9427FFC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385404,"discussion_content":"我也觉得","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627029460,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384986,"discussion_content":"可不是么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626842578,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":193548,"user_name":"业余爱好者","can_delete":false,"product_type":"c1","uid":1482915,"ip_address":"","ucode":"A890935A982988","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","comment_is_top":false,"comment_ctime":1584926013,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"177678585149","product_id":100039001,"comment_content":"策略集合的信息也可以定义成枚举，可以放在数据库，可以放kv配置中心，等等。都是一样的道理。<br><br>策略模式是对策略的定义，创建和使用解藕。定义和创建的过程与业务逻辑关系不大，写在一起会影响可读性。<br><br>创建型模式是对创建和使用的解藕。<br><br>做什么和怎么做是应该解藕的，使用者并不关心具体的细节。<br><br>在业务逻辑中，与业务逻辑不大的代码应该放在外部。就像mvc的三层架构是业界的最佳实践。在service层调用dao层，而不是直接jdbc,因为如何操作数据库是个复杂的过程，却又与业务逻辑无关，所以单独抽出一层，代码结构变得更加清晰。<br><br>声明式编程很火。它就是把使用和内部实现原理解藕。java,spring的各种注解，声明式事务等等。使用者一个注解解决所有问题，无需关心底层。<br><br>业务逻辑无关的放在一起影响可读性，即使自己过一段时间看自己的代码也会迷惑。写代码要有用户思维，不光是提供的api满足kiss原则，内部的实现也是一样。能放在外面单位代码尽量怎么放在外面。只要能表达逻辑即可。","like_count":41},{"had_liked":false,"id":193648,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1584940967,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"96074221479","product_id":100039001,"comment_content":"1.为了让调度的代码更优雅时使用。（就调度策略的代码而言，可读性高。理解结构后，阅读的心智负担低，因为调度的原理已经抽象成了共同的type查表，无需逐行检阅分支判断。像一些与持久数据相关的策略，有时为了兼容老数据或则平滑过度，无法全采用type查表，这时就需要结合if来 实现。所以采用if会让我误以为是这种场景，进而逐行检阅）。<br><br>2.感觉问反了，应该是什么场景下采用ifelse和witch。毕竟这两个的场景少些。答案是，在逻辑不复杂又不好用卫语句时采用。能用卫语句就不要ifelse。因为个人而言，看到retuern或conti能很明确跳出逻辑，else脑袋得转一下，当然这可能是个人习惯影响。但ifelse还是只在逻辑简单，没啥嵌套（一个函数内部不宜嵌套过多），且语义符合的场景用好些。<br><br>3.原则和思想毕竟是指导核心，是地图和尺子，自然是最重要的。但是不等于设计模式就比其不重要了。硬要说的话，我认为两个其实一样重要。设计模式是场景的积累，拉近了普通人与天才的差距，对我这种菜鸡来说可能比设计原则还重要。毕竟从设计原则到设计模式的出现，需要丰富经验，扎实知识和妙手偶得。如果没有设计模式的铺垫，普通人拿着设计模式的知识点要一路走上高质量代码的层级，实属不易。","like_count":23,"discussions":[{"author":{"id":1294908,"avatar":"https://static001.geekbang.org/account/avatar/00/13/c2/3c/a82d4ed0.jpg","nickname":"杜威","note":"","ucode":"CF49380E27467F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573623,"discussion_content":"设计模式确实很重要，是工具。但是什么场景下，用什么工具，工具如何改造更贴合场景，这个就见仁见智了。这也是高手和初学者的差距了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1653552487,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1294908,"avatar":"https://static001.geekbang.org/account/avatar/00/13/c2/3c/a82d4ed0.jpg","nickname":"杜威","note":"","ucode":"CF49380E27467F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573622,"discussion_content":"很有意思的理解。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1653552390,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1965699,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/fe/83/df562574.jpg","nickname":"慎独明强","note":"","ucode":"DC2F7F2C0C8F60","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305858,"discussion_content":"大佬，拆单的策略模式，我现在还记得。通过工厂类去维护和缓存。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600095648,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":194279,"user_name":"空白昵称","can_delete":false,"product_type":"c1","uid":1433815,"ip_address":"","ucode":"91F50CA25102AB","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/d7/744bd8c3.jpg","comment_is_top":false,"comment_ctime":1585045194,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"40239750858","product_id":100039001,"comment_content":"很早前使用了类似策略模式的代码做了一个从各种渠道上传下载文件。（当时大学毕业，没看过策略模式，但是学过C++的多态）其实也就是基于接口而非实现编程思想。<br><br>if-else使用，如果判断较少，且未来几乎不会有新需求要再加一个else时，保持if-else即可。其他的都可以使用策略模式。不过本节demo的实例，使用range来匹配，目前看是没问题。但是如果需求变化，需要增加一个根据数据特征的动态分配排序算法，那么这里实现就麻烦了。所以需要根据具体需求来看使用什么模式... <br><br>","like_count":10},{"had_liked":false,"id":193566,"user_name":"Jackey","can_delete":false,"product_type":"c1","uid":1063751,"ip_address":"","ucode":"125DE81993FEDD","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/47/f6c772a1.jpg","comment_is_top":false,"comment_ctime":1584928059,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"35944666427","product_id":100039001,"comment_content":"想想以前都没用过策略模式，一会到公司看看我的if-else有没有必要优化","like_count":9,"discussions":[{"author":{"id":2853072,"avatar":"","nickname":"小杰同学","note":"","ucode":"C6FC59D58F772C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577605,"discussion_content":"能跑就别动原则","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1656228178,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2913982,"avatar":"","nickname":"Geek_c566cd","note":"","ucode":"AC7514CB685EFE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552080,"discussion_content":"老代码能跑就别动","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1645278482,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384987,"discussion_content":"没有必要","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626842799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2283490,"avatar":"https://static001.geekbang.org/account/avatar/00/22/d7/e2/5e5cc8f3.jpg","nickname":"Molyt","note":"","ucode":"9CCF7A18B2C547","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":410359,"discussion_content":"哈哈哈，还是你秀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635673984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":384987,"ip_address":""},"score":410359,"extra":""}]}]},{"had_liked":false,"id":194073,"user_name":"iamjohnnyzhuang","can_delete":false,"product_type":"c1","uid":1015327,"ip_address":"","ucode":"E694C1828907F6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/1f/b1d458a9.jpg","comment_is_top":false,"comment_ctime":1585021197,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27354824973","product_id":100039001,"comment_content":"策略模式平时开发用的比较多，主要目的还是解耦策略的定义和使用。在Java中，比较喜欢用枚举策略模式。可以定义一个枚举类，提供静态方法根据传入的Type动态返回对应的枚举类。然后在枚举类中定义执行策略的抽象方法，这样迫使每个枚举都得去实现。对于策略不是非常复杂的情况下，这样可以集中管理这一批策略，新增策略的时候也只要在这个枚举类中添加。但是如果策略很复杂会导致这个类非常庞大，还是用传统的方法不同类对应不同逻辑更加优雅。总之，遵循KISS原则，怎么简单怎么来；同时尽量遵循开闭原则，添加策略的时候尽量少去改动代码。其实对于什么时候去掉IF&#47;ELSE这个问题原理也是一样的。","like_count":6},{"had_liked":false,"id":193562,"user_name":"攻城拔寨","can_delete":false,"product_type":"c1","uid":1053934,"ip_address":"","ucode":"CBC37183DAB6B2","user_header":"https://static001.geekbang.org/account/avatar/00/10/14/ee/d72a8222.jpg","comment_is_top":false,"comment_ctime":1584927665,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27354731441","product_id":100039001,"comment_content":"1. 奖励系统，奖励用户不同奖励是通过后台配置，从多个奖励中选择一种或者多种。<br>后端代码根据不同的奖励类型找到对应的奖励策略类，执行对应的代码。<br>2. 我觉得在 if-else 每个分支代码比较多的时候就应该拆分了。但是拆分不一定就能通过设计模式拆分，很多时候把分支逻辑抽成另一个方法就就够了，代码简洁，方便维护。<br>我相当同意老师 “设计原则和思想比设计模式更加普适和重要。” 这句话。","like_count":6},{"had_liked":false,"id":277650,"user_name":"刘大人","can_delete":false,"product_type":"c1","uid":1577210,"ip_address":"","ucode":"F66AE613E80398","user_header":"https://static001.geekbang.org/account/avatar/00/18/10/fa/d977627e.jpg","comment_is_top":false,"comment_ctime":1612507454,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23087343934","product_id":100039001,"comment_content":"问：在什么情况下，我们才有必要去掉代码中的 if-else 或者 switch-case 分支逻辑呢？<br>答：自己看不下去的时候","like_count":6},{"had_liked":false,"id":193795,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1419276,"ip_address":"","ucode":"FAACCA4E6D481F","user_header":"https://static001.geekbang.org/account/avatar/00/15/a8/0c/82ba8ef9.jpg","comment_is_top":false,"comment_ctime":1584965187,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23059801667","product_id":100039001,"comment_content":"1，最近在做规则引擎，前端用户通过页面设置出业务执行的流程图，而流程图中包含数据源节点、条件判断节点、业务分发节点、业务事件执行节点。每一种节点执行的业务校验规则都不同，这个时候适合策略模式。使用策略模式的好处是：以后随着业务的发展很有可能出现其他类型的节点，所以这个时候采用策略模式非常合适，易扩展易维护。另外在整个流程流转的规则上采用了模板方法。<br>2，当出现比较多的等值匹配的时候，这个时候使用switch case 更合适，结构清晰，可读性强，其他则使用if-else，当然if-else也可以进行等值比较。","like_count":5},{"had_liked":false,"id":193551,"user_name":"王飞洋","can_delete":false,"product_type":"c1","uid":1049345,"ip_address":"","ucode":"8FE8FE8C8CD4F1","user_header":"https://static001.geekbang.org/account/avatar/00/10/03/01/62b32acf.jpg","comment_is_top":false,"comment_ctime":1584926210,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"23059762690","product_id":100039001,"comment_content":"GB = 1024 * 1024 * 1024吧","like_count":5,"discussions":[{"author":{"id":1235937,"avatar":"https://static001.geekbang.org/account/avatar/00/12/db/e1/526653ab.jpg","nickname":"秋雨无痕","note":"","ucode":"8BBF69A208B342","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220461,"discussion_content":"Mac/Linux 1K=1000. Windows  1KB=1024 有两种表示法","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1585879373,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1049345,"avatar":"https://static001.geekbang.org/account/avatar/00/10/03/01/62b32acf.jpg","nickname":"王飞洋","note":"","ucode":"8FE8FE8C8CD4F1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1235937,"avatar":"https://static001.geekbang.org/account/avatar/00/12/db/e1/526653ab.jpg","nickname":"秋雨无痕","note":"","ucode":"8BBF69A208B342","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":224378,"discussion_content":"学习了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586300926,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":220461,"ip_address":""},"score":224378,"extra":""}]},{"author":{"id":1312332,"avatar":"https://static001.geekbang.org/account/avatar/00/14/06/4c/89ceb570.jpg","nickname":"火凤凰","note":"","ucode":"DB99D1EA222DC5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":272981,"discussion_content":"https://blog.csdn.net/qq_24520119/article/details/90381476","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590386398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1110252,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f0/ec/5e147cbf.jpg","nickname":"花指令","note":"","ucode":"E0C92F7AAC2585","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217638,"discussion_content":"不排除是老师写错的可能，但我觉得更大的可能是，跟随硬盘内存等存储硬件的厂家出厂的容量表达方式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585575106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1009422,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/0e/c77ad9b1.jpg","nickname":"eason2017","note":"","ucode":"E070BA624FA490","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215754,"discussion_content":"哈哈，赞同。但不是重点，头脑清醒~~赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585379408,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":277042,"user_name":"极客海","can_delete":false,"product_type":"c1","uid":1400927,"ip_address":"","ucode":"F0037CF1DBDA66","user_header":"https://static001.geekbang.org/account/avatar/00/15/60/5f/59ee0ca2.jpg","comment_is_top":false,"comment_ctime":1612246183,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18792115367","product_id":100039001,"comment_content":"&quot;设计原则和思想比设计模式更加普适和重要&quot;，被这句话一下子点醒了。","like_count":5},{"had_liked":false,"id":193537,"user_name":"徐同学呀","can_delete":false,"product_type":"c1","uid":1252813,"ip_address":"","ucode":"03383EE820514D","user_header":"https://static001.geekbang.org/account/avatar/00/13/1d/cd/3819726f.jpg","comment_is_top":false,"comment_ctime":1584924749,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18764793933","product_id":100039001,"comment_content":"最近在做公司的告警模块，对接收方式用了策略模式，以前也不知道这就是策略模式，只是觉得模块和思想解藕了。<br>还有接收方式的选择策略和升级策略都用了策略模式。<br><br>非要去掉if-else，我觉得如果分支不多，简单，以后可扩展性不强可以不去掉。否则就换成map缓存策略对象或者class。找到if-else条件和策略的对应关系。","like_count":5},{"had_liked":false,"id":223973,"user_name":"Geek_East","can_delete":false,"product_type":"c1","uid":1589947,"ip_address":"","ucode":"A1A7CBF9B8FB2D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXKSvfaeicog2Ficx4W3pNeA1KRLOS7iaFy2uoxCDoYpGkGnP6KPGecKia6Dr3MtCkNGpHxAzmTMd0LA/132","comment_is_top":false,"comment_ctime":1591247382,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"14476149270","product_id":100039001,"comment_content":"策略模式不仅仅是去除几个if-else，起到k-v store作用这么简单:<br>1. 开闭原则: 行为类封装每个具体实现，如果想要添加，直接再添加一个行为类就行，不会对已经存在的行为类造成影响，提高了水平方向上的可拓展性。<br>2. 依赖反转: 行为类是通过接口来传递的，能够实现业务逻辑和算法逻辑的解耦。算法层的拓展并不会影响业务层的拓展，提高了垂直方向上的可拓展性。<br>3. 组合大于继承: 继承就复用的粒度来说，是整个父类。如果将接口组合在类中，代码复用的粒度从父类降到了自定义大小和自定义类型(属性或者行为)，提高了代码复用的灵活性, 能够在开发新类的时候，最大程度的从已有的代码库中汲取养分。当然有个前提，code split得优秀。","like_count":4},{"had_liked":false,"id":193592,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1584931428,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14469833316","product_id":100039001,"comment_content":"在什么情况下，我们才有必要去掉代码中的 if-else 或者 switch-case 分支逻辑呢？<br><br>根据KISS原则, 默认我们不会主动去优化if-else&#47;switch-case. <br>只有当if-else严重影响代码可读性与可维护性, 才考虑使用策略模式+工厂方法模式优化分支逻辑.","like_count":3},{"had_liked":false,"id":193502,"user_name":"黄林晴","can_delete":false,"product_type":"c1","uid":1362631,"ip_address":"","ucode":"B15C38AECDA88F","user_header":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","comment_is_top":false,"comment_ctime":1584921655,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14469823543","product_id":100039001,"comment_content":"设计原则和思想比设计模式更加普适和重要，就像掌握算法思想比死扣每种算法的实现更重要！<br>虽说实践是检验真理的唯一标准，但没有理论何来实践呢","like_count":3},{"had_liked":false,"id":213937,"user_name":"面向百度编程","can_delete":false,"product_type":"c1","uid":1732780,"ip_address":"","ucode":"8FE04A019D71D1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","comment_is_top":false,"comment_ctime":1588593139,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10178527731","product_id":100039001,"comment_content":"将业务层层封装，暴露最少的方法，获得最有用的事物，复杂度从来不能被消除，只能被转移，学到了，我以为用个context类维护策略最好，却没有考虑对于客户端来说不够透明，不够知道最少，然后我只暴露一个类型，既符合迪米特法则，又符合封装，还符合利于扩展维护，将业务封装到类中，进行处理，实在是高，大话设计模式都没您讲的好","like_count":2},{"had_liked":false,"id":193937,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1584998795,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"10174933387","product_id":100039001,"comment_content":"思考题1：很久没写工程代码，但接触的科研算法对比性能时一般采用策略模式。通过输入不同的参数调用不同的算法。<br>思考题2：通过策略模式的学习，可以看出实现简单的话一开始是不用使用策略模式的。if else中实现的逻辑都差不多，就是差不多都是干一件事（上节课例子中的购物，本节的文件排序）短的 if else相对易读，代码好理解。使用了策略模式要小心过度设计和影响了代码易读性。（对于不熟悉的项目刚看到或许会懵逼或者不好调试）","like_count":2},{"had_liked":false,"id":193488,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1584918620,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10174853212","product_id":100039001,"comment_content":"1、用过策略模式。我们在自研的rpc框架中为了灵活的设置线程数量（类似于netty里面的策略模式，默认情况下线程数量为CPU两倍，也可以指定）。<br>2、在每个if else里面的代码都有相似功能，可以抽取出来。","like_count":2},{"had_liked":false,"id":193455,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1584893939,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10174828531","product_id":100039001,"comment_content":"1:随处可见，比如根据不同的配置选择不同的分配或者负载均衡策略。<br>2:策略可预期的经常变更或者选择策略的条件判定方式比较复杂时可以考虑不使用if else 方式实现，反过来则if else 没什么毛病","like_count":2},{"had_liked":false,"id":324377,"user_name":"Z宇锤锤","can_delete":false,"product_type":"c1","uid":2188142,"ip_address":"","ucode":"7DB36E986A7A51","user_header":"https://static001.geekbang.org/account/avatar/00/21/63/6e/6b971571.jpg","comment_is_top":false,"comment_ctime":1638409120,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5933376416","product_id":100039001,"comment_content":"计算器，加减乘除四种方法的策略","like_count":1},{"had_liked":false,"id":277617,"user_name":"迈克糖","can_delete":false,"product_type":"c1","uid":1749228,"ip_address":"","ucode":"A55D3DB2B20C4B","user_header":"https://static001.geekbang.org/account/avatar/00/1a/b0/ec/78be126d.jpg","comment_is_top":false,"comment_ctime":1612493368,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5907460664","product_id":100039001,"comment_content":"代码逻辑毕竟是服务于业务，我们要向省掉繁琐的逻辑判断，首选要在源头想想业务逻辑有没有必要这么麻烦。","like_count":1},{"had_liked":false,"id":260813,"user_name":"未来小娃","can_delete":false,"product_type":"c1","uid":1047329,"ip_address":"","ucode":"477D166EBB6B70","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/21/d017438c.jpg","comment_is_top":false,"comment_ctime":1605112276,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5900079572","product_id":100039001,"comment_content":"方法总比问题多，任何方法都需要放在具体的场景分析，设计模式是一个工具箱，当你需要的时候拿出来使用即可。但是前提需要有这方面的意识，知道什么是好的，什么是更好的，什么是最好的，解决办法就很清晰了","like_count":1},{"had_liked":false,"id":241426,"user_name":"kaixiao7","can_delete":false,"product_type":"c1","uid":1242577,"ip_address":"","ucode":"505EC4AFB5E656","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/d1/cc6f82eb.jpg","comment_is_top":false,"comment_ctime":1597290357,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5892257653","product_id":100039001,"comment_content":"在工厂模式那一讲中，配置文件解析的例子也是用了工厂+策略的模式。策略定义是各种Parser，策略创建是工厂类，策略使用是运行时动态确定的方式。那么是不是工厂模式和策略模式（运行时动态确定）经常搭配使用呢？","like_count":1},{"had_liked":false,"id":194296,"user_name":"徐旭","can_delete":false,"product_type":"c1","uid":1814806,"ip_address":"","ucode":"1D3091D15373E5","user_header":"https://static001.geekbang.org/account/avatar/00/1b/b1/16/dd11930c.jpg","comment_is_top":false,"comment_ctime":1585046931,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880014227","product_id":100039001,"comment_content":"要是不知道为什么，也是读不懂精心设计的代码","like_count":1},{"had_liked":false,"id":194045,"user_name":"君哥聊技术","can_delete":false,"product_type":"c1","uid":1325816,"ip_address":"","ucode":"2C9A22BCE4C79E","user_header":"https://static001.geekbang.org/account/avatar/00/14/3a/f8/c1a939e7.jpg","comment_is_top":false,"comment_ctime":1585018461,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879985757","product_id":100039001,"comment_content":"1.策略模式的使用还是挺多的，比如贷款系统中，业务系统需要查询不同渠道的征信报告，但是各渠道查询方式是不一样的，就用策略模式做了处理，客户端传入渠道编号来获取查询的渠道策略实现征信查询<br>2.if-else或switch中每个分支的实现业务上是由共性的，可以抽象出来，这样可以用策略模式来取代分支。但是没有必要所有的都去掉<br><br>注解方式的策略模式没有用过，动手实现了一下，同时总结了这2节内容：https:&#47;&#47;blog.csdn.net&#47;zjj2006&#47;article&#47;details&#47;105064557","like_count":1},{"had_liked":false,"id":193876,"user_name":"jaryoung","can_delete":false,"product_type":"c1","uid":1077406,"ip_address":"","ucode":"6E72D107DB7E51","user_header":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","comment_is_top":false,"comment_ctime":1584976459,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879943755","product_id":100039001,"comment_content":"在过去的项目开发中，你有没有用过策略模式，都是为了解决什么问题才使用的？<br>答：业务类型过多，未来还可能继续扩展<br>你可以说一说，在什么情况下，我们才有必要去掉代码中的 if-else 或者 switch-case 分支逻辑呢？<br>答：业务逻辑过于复杂（大部分都是条件判断），后期需求不断来。","like_count":1},{"had_liked":false,"id":193811,"user_name":"潇潇雨歇","can_delete":false,"product_type":"c1","uid":1251429,"ip_address":"","ucode":"4BD52BF0F0A084","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/65/35361f02.jpg","comment_is_top":false,"comment_ctime":1584969314,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5879936610","product_id":100039001,"comment_content":"设计原则和思想是道","like_count":1,"discussions":[{"author":{"id":1283461,"avatar":"https://static001.geekbang.org/account/avatar/00/13/95/85/15cd21c2.jpg","nickname":"杨锋","note":"","ucode":"85A7828A538FB0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285824,"discussion_content":"同层调用是指什么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592963148,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":193610,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1584933455,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879900751","product_id":100039001,"comment_content":"1.在之前,有一个用户拥有不同的用户组,对不同的用户组拥有这不同的处理逻辑,这就是一种策略模式,通过用户中的不同用户组名,来获取不同的用户组实例,执行其中的处理方式<br>2.如果对于判断逻辑中,需要执行的逻辑较为复杂,可以抽取出相同的接口的话,就使用策略模式,将其抽取出接口,并利用策略工厂进行获取策略实例,从而执行对应处理<br>","like_count":1},{"had_liked":false,"id":354946,"user_name":"英雄","can_delete":false,"product_type":"c1","uid":1546612,"ip_address":"四川","ucode":"D1033C83C6CDE9","user_header":"https://static001.geekbang.org/account/avatar/00/17/99/74/0203bf17.jpg","comment_is_top":false,"comment_ctime":1660900331,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660900331","product_id":100039001,"comment_content":"修改配置档来替换修改策略工厂。、、、修改配置档不也是修改吗","like_count":0},{"had_liked":false,"id":347637,"user_name":"Geek_7e0e83","can_delete":false,"product_type":"c1","uid":2142423,"ip_address":"","ucode":"554DEE2AAAE33C","user_header":"","comment_is_top":false,"comment_ctime":1654243305,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654243305","product_id":100039001,"comment_content":"1.有用过 是为了解决代码复用的问题。多个不同修改的场景，在入参的转化都是一致的，在响应的输出也是一致的。这个时候可以通过策略模式，将具体的修改业务逻辑封装在策略中。修改的调用方，只需要指定对应的修改类型。就可以调用具体的修改流程的方法，比如是修改邮箱、还是修改手机号等的操作。<br><br>2。我觉得在需要动态时运行来进行选择的代码，才有必要去掉if else ，这种场景下可能性的增加或者删除都会比较频繁。那么如果是具体的确定的业务场景中，对于某些情况分支的代码流程的分支选择，就可以使用if else 它和当前方法的业务逻辑依赖性会较强。","like_count":0},{"had_liked":false,"id":341767,"user_name":"terryking","can_delete":false,"product_type":"c1","uid":1012371,"ip_address":"","ucode":"39433F06D6BEF6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/72/93/46895883.jpg","comment_is_top":false,"comment_ctime":1649826703,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649826703","product_id":100039001,"comment_content":"最后面把if改成for循环的方式也可以看做是责任链模式的变形，谁能处理谁处理","like_count":0},{"had_liked":false,"id":341180,"user_name":"易飞","can_delete":false,"product_type":"c1","uid":2630424,"ip_address":"","ucode":"32AC28754237F7","user_header":"https://static001.geekbang.org/account/avatar/00/28/23/18/4284361f.jpg","comment_is_top":false,"comment_ctime":1649406177,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649406177","product_id":100039001,"comment_content":"这里有一个问题，用工厂模式封装对象的创建，那每次调用工厂类的时候还得创建工厂类的对象把？那这个封装还有必要吗？","like_count":0},{"had_liked":false,"id":339933,"user_name":"夏天","can_delete":false,"product_type":"c1","uid":1285986,"ip_address":"","ucode":"F29D56F9265751","user_header":"https://static001.geekbang.org/account/avatar/00/13/9f/62/960eecc3.jpg","comment_is_top":false,"comment_ctime":1648470196,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648470196","product_id":100039001,"comment_content":"处理不同通知类型的发送通知，使用了策略模式。当if-else 比较多影响了代码的可读性，或者 if-else 分支可能会增加时应该是用策略模式。","like_count":0},{"had_liked":false,"id":338267,"user_name":"肥low","can_delete":false,"product_type":"c1","uid":1043480,"ip_address":"","ucode":"A158AFAAB8C742","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/18/bf7254d3.jpg","comment_is_top":false,"comment_ctime":1647399715,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647399715","product_id":100039001,"comment_content":"第一个问题 经常用到，只要是多个算法比较独立，互不影响，而且后续迭代可能还会新增的可能才会用到策略<br>第二个问题 至于后续不怎么迭代，而且很少的策略的时候我觉得if else完全可以的","like_count":0},{"had_liked":false,"id":335060,"user_name":"Geek_c566cd","can_delete":false,"product_type":"c1","uid":2913982,"ip_address":"","ucode":"AC7514CB685EFE","user_header":"","comment_is_top":false,"comment_ctime":1645279171,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645279171","product_id":100039001,"comment_content":"策略对象可以使用ApplicationContext获取吗? 不使用工厂","like_count":0},{"had_liked":false,"id":327882,"user_name":"张金魁","can_delete":false,"product_type":"c1","uid":1013317,"ip_address":"","ucode":"40343172910342","user_header":"https://static001.geekbang.org/account/avatar/00/0f/76/45/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1640338350,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640338350","product_id":100039001,"comment_content":"不同模块和计费系统打交道，套路都类似，使用了策略模式来完成。","like_count":0},{"had_liked":false,"id":318793,"user_name":"千锤百炼领悟之极限","can_delete":false,"product_type":"c1","uid":1744257,"ip_address":"","ucode":"224B5CF2101716","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9d/81/d748b7eb.jpg","comment_is_top":false,"comment_ctime":1635425632,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635425632","product_id":100039001,"comment_content":"当if else 分支很多，影响代码的可读性，或者需要经常修改这部分判断时，就应该去掉if else分支判断。<br>改成接口调用，把处理逻辑拆分成小的类，实现这个接口。","like_count":0},{"had_liked":false,"id":318279,"user_name":"风絮1994","can_delete":false,"product_type":"c1","uid":1144725,"ip_address":"","ucode":"FEB562DECA5E77","user_header":"https://static001.geekbang.org/account/avatar/00/11/77/95/9d32e68c.jpg","comment_is_top":false,"comment_ctime":1635229082,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635229082","product_id":100039001,"comment_content":"我觉得代码解耦很多时候跟人类分工一样，分工会提高专业化和效率，但也会增加复杂度，要根据项目的规模具体对待","like_count":0},{"had_liked":false,"id":316697,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1634517900,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634517900","product_id":100039001,"comment_content":"思考：<br>我觉得是否需要用策略模式替换if-else，有以下两点考虑，<br>1.if-else 分支过多（比如超过10个），并且分支中的代码比较复杂，这样整个if-else代码放在一起，可能显得很臃肿。<br>所以，某些场景其实if-else也是很ok的，比如分支并不多，三两个。或者分支很多，但是每个分支的代码很简单就一两行，那就没必要再设计过多类，反倒影响可读性。","like_count":0},{"had_liked":false,"id":316260,"user_name":"Jiantao","can_delete":false,"product_type":"c1","uid":1163504,"ip_address":"","ucode":"444580EC5EF109","user_header":"https://static001.geekbang.org/account/avatar/00/11/c0/f0/1aabc056.jpg","comment_is_top":false,"comment_ctime":1634227092,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634227092","product_id":100039001,"comment_content":"设计原则和思想是更高层次的理论和指导原则，设计模式只是这些理论和指导原则下，根据经验和场景，总结出来的编程范式。","like_count":0},{"had_liked":false,"id":310732,"user_name":"一夕秋雨","can_delete":false,"product_type":"c1","uid":1240328,"ip_address":"","ucode":"34903AFA57FA27","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/08/ebaa6e88.jpg","comment_is_top":false,"comment_ctime":1630887974,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630887974","product_id":100039001,"comment_content":"当if-else的分支较多或者后续经常需要扩展的时候，我们应该将if-else转换成策略模式，方便扩展。","like_count":0},{"had_liked":false,"id":310394,"user_name":"土豆鸡块_o0","can_delete":false,"product_type":"c1","uid":1131629,"ip_address":"","ucode":"1003C0074B722E","user_header":"https://static001.geekbang.org/account/avatar/00/11/44/6d/10a6cc99.jpg","comment_is_top":false,"comment_ctime":1630638834,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630638834","product_id":100039001,"comment_content":"1. 框架预留公共（抽象）接口<br>2. 用户根据接口实现类<br>3. 用户把类注册到配置文件中<br>4. 在工厂方法中，解析配置文件，利用反射把类加载map中<br>5. 最后根据mapID调用不同的类","like_count":0},{"had_liked":false,"id":305685,"user_name":"张清宇","can_delete":false,"product_type":"c1","uid":1228366,"ip_address":"","ucode":"7CA5AE9CB57ABB","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/4e/9b40b1bd.jpg","comment_is_top":false,"comment_ctime":1628120332,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1628120332","product_id":100039001,"comment_content":"如何彻底消除分支判断？<br><br>硬编码方式（容器）：<br>要么 Map，根据 key 获取（查表法）；要么 List，遍历根据条件获取。<br><br>动态方式（配置文件或注解）：<br>通过一个配置文件或者自定义的 annotation 来标注都有哪些策略类；策略工厂类读取配置文件或者搜索被 annotation 标注的策略类，然后通过反射动态地加载这些策略类、创建策略对象；当新添加一个策略的时候，只需要将这个新添加的策略类添加到配置文件或者用 annotation 标注即可。","like_count":0},{"had_liked":false,"id":297176,"user_name":"omega","can_delete":false,"product_type":"c1","uid":2421889,"ip_address":"","ucode":"BAEFC62975DC53","user_header":"https://static001.geekbang.org/account/avatar/00/24/f4/81/7a3eaa9b.jpg","comment_is_top":false,"comment_ctime":1623343191,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1623343191","product_id":100039001,"comment_content":"既然是策略类，那么理所应当实现同一个接口，为什么还需要用注解来判断这是一个策略类，而不是直接基于接口呢","like_count":0},{"had_liked":false,"id":294928,"user_name":"云淡风轻","can_delete":false,"product_type":"c1","uid":1121817,"ip_address":"","ucode":"D6903A0FCEBC58","user_header":"https://static001.geekbang.org/account/avatar/00/11/1e/19/a235f31d.jpg","comment_is_top":false,"comment_ctime":1622153425,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622153425","product_id":100039001,"comment_content":"web程序中的servlet就是策略模式，通过注解或配置文件，指明URL使用的servlet。","like_count":0},{"had_liked":false,"id":290079,"user_name":"昵称C","can_delete":false,"product_type":"c1","uid":1234963,"ip_address":"","ucode":"1BB2D537942DC2","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/13/082013bc.jpg","comment_is_top":false,"comment_ctime":1619350432,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619350432","product_id":100039001,"comment_content":"1. 策略模式使用：<br>机器人项目中用到过基础策略模式，比如不同的机器人设备有多种定位的方式，根据不同的机器人类型标志走不通的定位策略、<br>2.同时满足下面两个条件时<br>   2.1分支条件大于2个<br>   2.2每个分支逻辑都不是简单的赋值或return逻辑，而是单独一种算法或者一套业务流程","like_count":0},{"had_liked":false,"id":287940,"user_name":"工藤新一","can_delete":false,"product_type":"c1","uid":1754668,"ip_address":"","ucode":"F2AFB6F6A42FAA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLeXjFHy8wGyrDnm6ib7hjZNjocUHarn0XFc8zLc061Ax99bFmrLN9yAxicklpcjKFx2gHqUKWQ3MRw/132","comment_is_top":false,"comment_ctime":1618226785,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618226785","product_id":100039001,"comment_content":"谢谢老师","like_count":0},{"had_liked":false,"id":280889,"user_name":"...？","can_delete":false,"product_type":"c1","uid":1590038,"ip_address":"","ucode":"8CB8669180F9D8","user_header":"https://static001.geekbang.org/account/avatar/00/18/43/16/d18be4c5.jpg","comment_is_top":false,"comment_ctime":1614439743,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1614439743","product_id":100039001,"comment_content":"对接不同厂商时，每个厂商的操作细节不同但都实现相同的接口，根据不同厂商标识去枚举类中找厂商标识对应不同的实现类，再从ApplicationContext容器中获取实现类的bean，去执行操作。","like_count":0},{"had_liked":false,"id":279329,"user_name":"I LOVE DM","can_delete":false,"product_type":"c1","uid":2006342,"ip_address":"","ucode":"6EA297D5A0E4C8","user_header":"https://static001.geekbang.org/account/avatar/00/1e/9d/46/ce8f7a26.jpg","comment_is_top":false,"comment_ctime":1613722360,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613722360","product_id":100039001,"comment_content":"讨论1：数据结构相同，内容不同数据处理。<br>讨论2：分支逻辑复杂且分支数量不可控制。","like_count":0},{"had_liked":false,"id":273871,"user_name":"以芢","can_delete":false,"product_type":"c1","uid":1600994,"ip_address":"","ucode":"ABA00BD8F2C17D","user_header":"https://static001.geekbang.org/account/avatar/00/18/6d/e2/5bf3c7c7.jpg","comment_is_top":false,"comment_ctime":1610702156,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610702156","product_id":100039001,"comment_content":"我做到一个业务，多策略寻源 有很多种寻源的方式，寻源的流程节点上有重复的逻辑<br>就做了一个策略模式<br>1. 抽象XXHandler接口，并实现公共逻辑到BaseHandler<br>2. 继承BaseHandler 实现每个寻源操作不一样的逻辑<br>3. 基于Component自定义注解放到每一个策略的Handler中，携带type<br>4. 调用的时候使用工具类，通过ApplicationContext用byType获取实现，然后匹配type。","like_count":0},{"had_liked":false,"id":271147,"user_name":"晴朗","can_delete":false,"product_type":"c1","uid":1146869,"ip_address":"","ucode":"713D67C7D4E36A","user_header":"https://static001.geekbang.org/account/avatar/00/11/7f/f5/72dcb9df.jpg","comment_is_top":false,"comment_ctime":1609416351,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609416351","product_id":100039001,"comment_content":"&quot;设计原则和思想比设计模式更加普适和重要&quot;，设计原则和思想是“道”，设计模式是“术”","like_count":0},{"had_liked":false,"id":270530,"user_name":"David","can_delete":false,"product_type":"c1","uid":1021825,"ip_address":"","ucode":"22CBBC13FC97A9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/97/81/e1eaf621.jpg","comment_is_top":false,"comment_ctime":1609151476,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1609151476","product_id":100039001,"comment_content":"策略模式我经常使用。对接不同媒体的API 实现的功能一直，但是每家的实现不一致。使用Spring工厂+策略模式实现。在策略类里获取Spring工厂里接口的所有实现类，注入Map&lt;媒体类型，Handler&gt;。使用的时候直接通过媒体类型获取策略类，完成功能。","like_count":0},{"had_liked":false,"id":268227,"user_name":"JRich","can_delete":false,"product_type":"c1","uid":1114901,"ip_address":"","ucode":"66AE9D61533960","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/15/293a185d.jpg","comment_is_top":false,"comment_ctime":1608106856,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608106856","product_id":100039001,"comment_content":"老师，模板模式也可以用策略模式替换吧。模板模式的子类可以用策略接口实现类替换，模板的骨架代码可以使用组合替换。模板模式的缺点是如果模板类流程发生变化，则模板类和子类都需要修改都要修改，没有策略模式灵活。而策略模式会存在策略实现类代码执行流程重复问题，这个具体该怎么取舍呢？","like_count":0},{"had_liked":false,"id":268079,"user_name":"徐飞","can_delete":false,"product_type":"c1","uid":1070154,"ip_address":"","ucode":"C4A0B6D45338E1","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/4a/d8c7cacb.jpg","comment_is_top":false,"comment_ctime":1608045492,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608045492","product_id":100039001,"comment_content":"SPI可以不用改代码，直接引JAR就可以","like_count":0},{"had_liked":false,"id":267707,"user_name":"淤白","can_delete":false,"product_type":"c1","uid":1206503,"ip_address":"","ucode":"D1E65DC40DAF68","user_header":"https://static001.geekbang.org/account/avatar/00/12/68/e7/ee47d0e2.jpg","comment_is_top":false,"comment_ctime":1607881971,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607881971","product_id":100039001,"comment_content":"打卡：用Java实现了文中的案例。（相比起配置文件，准备再实现一版注解声明的代码，可以作为一种积累~）","like_count":0},{"had_liked":false,"id":267076,"user_name":"大毛","can_delete":false,"product_type":"c1","uid":1899599,"ip_address":"","ucode":"93B18287F06706","user_header":"https://static001.geekbang.org/account/avatar/00/1c/fc/4f/0a452c94.jpg","comment_is_top":false,"comment_ctime":1607590329,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1607590329","product_id":100039001,"comment_content":"你会发现，策略模式避免了冗长的if...else判断，但是它依然需要这段逻辑选取一个合适的策略。<br>想起之前的留言，大致的意思是逻辑的复杂度是不可削减的，但是可以用过各种设计原则和设计模式来解耦。在我看来，这种解耦对计算机执行代码的性能没有什么影响，但是对人阅读代码至关重要。<br>想到了开篇词中阐述的思想：算法对计算机友好，设计模式对人类友好。就忽然很好奇，争哥下一个专栏会是什么。","like_count":0},{"had_liked":false,"id":263628,"user_name":"Laughing","can_delete":false,"product_type":"c1","uid":1002134,"ip_address":"","ucode":"F68F1E000CA800","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/96/99466a06.jpg","comment_is_top":false,"comment_ctime":1606201567,"is_pvip":false,"replies":[{"id":"96088","content":"嗯嗯 ������","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606700701,"ip_address":"","comment_id":263628,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1606201567","product_id":100039001,"comment_content":"在之前项目中，有个缓存的实现开始直接使用的redis来实现的，后来使用内存缓存替换，这样一来我使用了策略模式根据缓存key的类型，自动选择策略进行缓存。","like_count":0,"discussions":[{"author":{"id":1739390,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/8a/7e/bfe37c46.jpg","nickname":"飞鱼","note":"","ucode":"95109E8F7DBE39","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386561,"discussion_content":"根据业务规则，划分子流程，按步骤把互相独立的子流程分解。先在本类中抽出来私有方法，再创建一个新的类，把刚刚那个私有方法复制到这个新的类中，然后把新类中这个新方法的访问限制符修改为public。这样逐步替换。如果实在这种方式优化之后，代码还是多的话，那就应该优化业务流程了.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627638035,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1129309,"avatar":"https://static001.geekbang.org/account/avatar/00/11/3b/5d/15c4817a.jpg","nickname":"xxxxL","note":"","ucode":"F84BB5ACD1241E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305372,"discussion_content":"这么说这个service类就有好多个方法了，看看能不能把一部分方法单独定义一个类出来呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599897999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263468,"user_name":"一万小时","can_delete":false,"product_type":"c1","uid":1297927,"ip_address":"","ucode":"D2D443595BB1ED","user_header":"","comment_is_top":false,"comment_ctime":1606139970,"is_pvip":false,"replies":[{"id":"96096","content":"目的不同","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606700761,"ip_address":"","comment_id":263468,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1606139970","product_id":100039001,"comment_content":"策略模式看着像是个工厂模式","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510207,"discussion_content":"目的不同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253156,"user_name":"Gopher","can_delete":false,"product_type":"c1","uid":1206229,"ip_address":"","ucode":"3C1F9012BB486D","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/d5/1b26b725.jpg","comment_is_top":false,"comment_ctime":1602638236,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602638236","product_id":100039001,"comment_content":"1、在一次交易校验的业务中使用过策略模式，每种交易触发不同的校验规则，用的时候 没有意识到是策略模式<br>2、如果分支少，切固定就没必要用策略模式了<br><br>发现平时也代码也用到了设计模式里的思想，但是并不知道具体是什么设计模式  哈哈 说明掌握思想更重要","like_count":0},{"had_liked":false,"id":251873,"user_name":"罗樱罂","can_delete":false,"product_type":"c1","uid":2045997,"ip_address":"","ucode":"9072E79E625ED1","user_header":"https://static001.geekbang.org/account/avatar/00/1f/38/2d/f3c6493e.jpg","comment_is_top":false,"comment_ctime":1601943512,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601943512","product_id":100039001,"comment_content":"请问一下，有人理解strategy 和template的区别吗？有点没看出来，感觉他们也挺像的。","like_count":0},{"had_liked":false,"id":239593,"user_name":"一木一米","can_delete":false,"product_type":"c1","uid":1471725,"ip_address":"","ucode":"CAE39B2836E137","user_header":"https://static001.geekbang.org/account/avatar/00/16/74/ed/02771d6d.jpg","comment_is_top":false,"comment_ctime":1596593023,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596593023","product_id":100039001,"comment_content":"看了这节课，才知道上节课的讨论题目，我想到的是利用类前缀，或map来映射类型和策略类，同样是用反射，怎么就没有想到用 annotation 呢？还是 annotation 优雅，改动量最小甚至不修改。看来设计这方面实践不多，有待提高啊！","like_count":0},{"had_liked":false,"id":234205,"user_name":"杜","can_delete":false,"product_type":"c1","uid":1236070,"ip_address":"","ucode":"E372639657C9AB","user_header":"https://static001.geekbang.org/account/avatar/00/12/dc/66/5861451b.jpg","comment_is_top":false,"comment_ctime":1594619622,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594619622","product_id":100039001,"comment_content":"课堂讨论2：如果ifelse修改频繁，经常加入新的条件 或者项目中有多处重复的ifelse，就有必要去掉代码中的 if-else","like_count":0},{"had_liked":false,"id":233114,"user_name":"maybe","can_delete":false,"product_type":"c1","uid":1475528,"ip_address":"","ucode":"93D160F617E750","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/c8/5ce842f6.jpg","comment_is_top":false,"comment_ctime":1594219605,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1594219605","product_id":100039001,"comment_content":"1、真正去设计实践策略模式没有过，只用过面向接口编程，多态特性。<br>2、一般情况下都不会有很复杂的分支处理，如果分支处理都比较简单，且没有明显的可定义为策略的点，保持原来即可，符合kiss原则，不要过度设计，牵强使用策略模式","like_count":0},{"had_liked":false,"id":232226,"user_name":"Fitch Kuma","can_delete":false,"product_type":"c1","uid":1318028,"ip_address":"","ucode":"9783C3D4873020","user_header":"https://static001.geekbang.org/account/avatar/00/14/1c/8c/3af20a8e.jpg","comment_is_top":false,"comment_ctime":1593930260,"is_pvip":false,"replies":[{"id":"85753","content":"嗯，用多态来实现的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1593994317,"ip_address":"","comment_id":232226,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1593930260","product_id":100039001,"comment_content":"对查表法来避免if-else很有感触，之前设计Jenkins pipeline是就是用Map来存放不同的component部署到不同server的映射关系的. 感觉策略模式的本质就是多态？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500572,"discussion_content":"嗯，用多态来实现的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593994317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222209,"user_name":"Sunrise","can_delete":false,"product_type":"c1","uid":1739817,"ip_address":"","ucode":"417AEE308CB6A7","user_header":"https://static001.geekbang.org/account/avatar/00/1a/8c/29/e4fcbbf3.jpg","comment_is_top":false,"comment_ctime":1590717032,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1590717032","product_id":100039001,"comment_content":"大家好，请问。策略模式和模板模式有什么区别？感觉 扩展出来的模板实现 也可以看作一个个 的策略。而策略模式也就是通过延时子类实现来处理不同的逻辑。","like_count":0,"discussions":[{"author":{"id":2104830,"avatar":"https://static001.geekbang.org/account/avatar/00/20/1d/fe/44cc6861.jpg","nickname":"My Roar","note":"","ucode":"D5F6B1980F0C3C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337332,"discussion_content":"你说到了他们的共同点，就是通过继承来延迟实现。但策略模式你可以理解为多个具体的实现里面选一种，更侧重动态地选择；而模板模式强调的是父类本身已经实现好了基本的骨架，只是把其中一步或几步交给子类去实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608877029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1237399,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e1/97/fec494f2.jpg","nickname":"大大。","note":"","ucode":"A6716E46264AC4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292249,"discussion_content":"接口和继承都可以实现多态，简单使用都一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595154687,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221733,"user_name":"木又寸","can_delete":false,"product_type":"c1","uid":1036656,"ip_address":"","ucode":"2CE5EEE74A8DD2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d1/70/5c644be9.jpg","comment_is_top":false,"comment_ctime":1590578257,"is_pvip":false,"replies":[{"id":"86785","content":"只保留满减、返现、立减等子策略，子子策略放到子策略中，不单独抽离出来实现，这样可以吗？","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1594903741,"ip_address":"","comment_id":221733,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590578257","product_id":100039001,"comment_content":"策略类膨胀的情况，小争哥有没一些最佳实践可以分享？<br><br>业务实现上，可能一个父级策略下有多个子策略（譬如促销活动有满减&#47;返现&#47;立减等，满减规则下又有几种复杂的优惠策略），这时候把所有满减规则塞进一个策略类，有些偏离我们的初衷；将子策略拆分为独立的策略，策略类的数目又会急剧膨胀。<br><br>如何取舍？或者能否混合其他模式来适应这种场景？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496549,"discussion_content":"只保留满减、返现、立减等子策略，子子策略放到子策略中，不单独抽离出来实现，这样可以吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594903741,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221617,"user_name":"worthto","can_delete":false,"product_type":"c1","uid":1387712,"ip_address":"","ucode":"41D7ABBBD2E7FF","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/N6yjnrLnMW4XVSkBr3f0N3F962l35b5j0kib9VSlAqqbf6iaoCPicL1WnJ9KjgT4egQ7A2G0Zx3OayaK4yuoZrUVA/132","comment_is_top":false,"comment_ctime":1590550138,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590550138","product_id":100039001,"comment_content":"策略模式是面向对象设计很好的案例。对需求进行如下的抽象定义： 策略模块、策略的选择模块、策略的创建模块。","like_count":0},{"had_liked":false,"id":221458,"user_name":"新世界","can_delete":false,"product_type":"c1","uid":1079495,"ip_address":"","ucode":"4473DC1505F158","user_header":"https://static001.geekbang.org/account/avatar/00/10/78/c7/083a3a0b.jpg","comment_is_top":false,"comment_ctime":1590502710,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590502710","product_id":100039001,"comment_content":"mybatis加载哪些mapper就是添加注解@mapper，或者通过自定义扫描路径，比如@mapperScan注解指定扫描路径，相当于动态确定加载哪些mapper文件，动态加载","like_count":0},{"had_liked":false,"id":221453,"user_name":"新世界","can_delete":false,"product_type":"c1","uid":1079495,"ip_address":"","ucode":"4473DC1505F158","user_header":"https://static001.geekbang.org/account/avatar/00/10/78/c7/083a3a0b.jpg","comment_is_top":false,"comment_ctime":1590501867,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590501867","product_id":100039001,"comment_content":"静态块能改用枚举，也是天然单例","like_count":0},{"had_liked":false,"id":219266,"user_name":"凯玲","can_delete":false,"product_type":"c1","uid":1246373,"ip_address":"","ucode":"CF152D36B8EC70","user_header":"https://static001.geekbang.org/account/avatar/00/13/04/a5/a12612e4.jpg","comment_is_top":false,"comment_ctime":1589979387,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1589979387","product_id":100039001,"comment_content":"最近在做Android启动优化，其实这种静态初始化对客户端的性能是不友好的。","like_count":0},{"had_liked":false,"id":216172,"user_name":"落尘kira","can_delete":false,"product_type":"c1","uid":1092169,"ip_address":"","ucode":"D203B519E43F85","user_header":"https://static001.geekbang.org/account/avatar/00/10/aa/49/51790edb.jpg","comment_is_top":false,"comment_ctime":1589199364,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589199364","product_id":100039001,"comment_content":"场景：根据不同情况给用户分别发送短信、邮件、推送等等功能<br>实现：借用Reactor的事件机制，可以同时应用 工厂+策略+观察者+模板 实现一个高解耦的模块","like_count":0},{"had_liked":false,"id":212924,"user_name":"永旭","can_delete":false,"product_type":"c1","uid":1068819,"ip_address":"","ucode":"C9C74BE32C8F46","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/13/5197f8d2.jpg","comment_is_top":false,"comment_ctime":1588238661,"is_pvip":false,"replies":[{"id":"86631","content":"你可以简单理解为：只有函数，没有属性。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1594785782,"ip_address":"","comment_id":212924,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1588238661","product_id":100039001,"comment_content":"哪位了解无状态的类是什么意思 ?","like_count":0,"discussions":[{"author":{"id":1698072,"avatar":"https://static001.geekbang.org/account/avatar/00/19/e9/18/d047ff86.jpg","nickname":"假如年少有为","note":"","ucode":"781E9DF18B95C5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":98529,"discussion_content":"个人感觉抽取一个公共的父类存放公共属性和方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577169428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":210262,"user_name":"PHP是世界上最好的需要","can_delete":false,"product_type":"c1","uid":1655326,"ip_address":"","ucode":"EE23A54B831D17","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIma3PJUyqDEQKt40nEh3Jt840af6hKnuK8k8dIscm43EUzJwLvynbxRnvO9Ivibv7KssUSqoBdY1w/132","comment_is_top":false,"comment_ctime":1587709421,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587709421","product_id":100039001,"comment_content":"但是终究会有一个地方来if else ","like_count":0},{"had_liked":false,"id":208413,"user_name":"好饿早知道送外卖了","can_delete":false,"product_type":"c1","uid":1132304,"ip_address":"","ucode":"AED22DB5BF8FC7","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/10/2d673601.jpg","comment_is_top":false,"comment_ctime":1587353358,"is_pvip":false,"discussion_count":0,"race_medal":2,"score":"1587353358","product_id":100039001,"comment_content":"前端程序员，有些页面的不同状态会有些许差异，可能是按钮，可能是文案，可能是行为，可能是各种各样的细节。这个时候就可以用策略模式，针对每种状态对展示以及行为进行特殊控制。实际上，是把许多个ifesle合并成了一个，也符合KISS原则。","like_count":0},{"had_liked":false,"id":207989,"user_name":"Saber","can_delete":false,"product_type":"c1","uid":1028924,"ip_address":"","ucode":"CAB1C0314BAAA9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b3/3c/81a3a00c.jpg","comment_is_top":false,"comment_ctime":1587228024,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587228024","product_id":100039001,"comment_content":"复杂的if else该怎么应用策略模式呢","like_count":0},{"had_liked":false,"id":205601,"user_name":"hanazawakana","can_delete":false,"product_type":"c1","uid":1251721,"ip_address":"","ucode":"E0F6FACBFE7D15","user_header":"https://static001.geekbang.org/account/avatar/00/13/19/89/20488013.jpg","comment_is_top":false,"comment_ctime":1586681689,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586681689","product_id":100039001,"comment_content":"解决if else还可以使用工厂方法模式","like_count":0},{"had_liked":false,"id":204955,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1586500226,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586500226","product_id":100039001,"comment_content":"以前不了解设计模式 和面向对象 所以基本上没怎么遇到过 就算遇到过也没怎么遇到 但是现在就晓得了<br>第二问最重要的一点就是if else或者switch case分支会不停的变大变得很大的时候就需要考虑去除if else分支了","like_count":0},{"had_liked":false,"id":203381,"user_name":"ub8","can_delete":false,"product_type":"c1","uid":1481811,"ip_address":"","ucode":"0D937C3EAEB781","user_header":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","comment_is_top":false,"comment_ctime":1586181924,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586181924","product_id":100039001,"comment_content":"策略模式：解耦了 策略的定义 ， 创建 ，和使用；","like_count":0},{"had_liked":false,"id":203063,"user_name":"makermade","can_delete":false,"product_type":"c1","uid":1133194,"ip_address":"","ucode":"03386B90CB8F20","user_header":"https://static001.geekbang.org/account/avatar/00/11/4a/8a/c1069412.jpg","comment_is_top":false,"comment_ctime":1586134688,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586134688","product_id":100039001,"comment_content":"目前用的最熟的一个设计模式。对于Java开发，结合spring的话，策略工厂类也可以省略掉。第二个问题: 当策略处理逻辑比较独立，并且在未来可能存在新的处理策略时，就可以改造if else","like_count":0},{"had_liked":false,"id":202897,"user_name":"秋风画扇","can_delete":false,"product_type":"c1","uid":1132356,"ip_address":"","ucode":"5BCBC1422C51EC","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/44/964aa665.jpg","comment_is_top":false,"comment_ctime":1586081320,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586081320","product_id":100039001,"comment_content":"代码中有大量if-else判断逻辑，有需要提供扩展点。考虑到“开闭原则”这里需要用到策略模式了。<br><br>少量的if-else不需要扩展是可以接受的，实际上看起来也更清晰。","like_count":0},{"had_liked":false,"id":200190,"user_name":"Geek_bb8d16","can_delete":false,"product_type":"c1","uid":1735740,"ip_address":"","ucode":"964BD4DB3D9653","user_header":"","comment_is_top":false,"comment_ctime":1585555212,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585555212","product_id":100039001,"comment_content":"订单系统中各种order handler，比如更新订单状态","like_count":0},{"had_liked":false,"id":200137,"user_name":"不能忍的地精","can_delete":false,"product_type":"c1","uid":1754913,"ip_address":"","ucode":"66A921C0BC8102","user_header":"","comment_is_top":false,"comment_ctime":1585549185,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585549185","product_id":100039001,"comment_content":"1 使用过策略模式,告警的时候,有钉钉告警和REST协议告警,采用策略模式,基于接口编程<br>2. 当if...else超过一屏时候可以考虑去掉","like_count":0},{"had_liked":false,"id":199650,"user_name":"HYM","can_delete":false,"product_type":"c1","uid":1054178,"ip_address":"","ucode":"4E82D9A285DAFF","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/e2/c21553c4.jpg","comment_is_top":false,"comment_ctime":1585493185,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585493185","product_id":100039001,"comment_content":"1. 项目中采用策略模式基本都是用来替换if-else的<br>2.当分支过多或者每个分支对应的处理逻辑都很复杂时，就需要重构了","like_count":0},{"had_liked":false,"id":198261,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1585439580,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585439580","product_id":100039001,"comment_content":"有个疑问：不同的无状态策略从性能和可读性来说，是定义为静态方法好还是创建一个个的实例好呢？<br>创建一个个的实例是因为多态的原因吗？语法上不支持静态方法？","like_count":0},{"had_liked":false,"id":196660,"user_name":"change","can_delete":false,"product_type":"c1","uid":1110876,"ip_address":"","ucode":"D78B4B3752B6FE","user_header":"https://static001.geekbang.org/account/avatar/00/10/f3/5c/8704e784.jpg","comment_is_top":false,"comment_ctime":1585300698,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1585300698","product_id":100039001,"comment_content":"后端开发一般利用Spring IoC容器来创建和管理Bean,即可以IoC容器自动创建策略类,也就做到新的策略类的自动创建.另外,通过自定义注解在具体策略类上标注业务类型,这样可以实现根据不同类型进行不同处理的场景,避免使用if&#47;else.","like_count":0},{"had_liked":false,"id":196059,"user_name":"筱乐乐哦","can_delete":false,"product_type":"c1","uid":1307611,"ip_address":"","ucode":"AE92539F0419C3","user_header":"https://static001.geekbang.org/account/avatar/00/13/f3/db/5b7a8fd8.jpg","comment_is_top":false,"comment_ctime":1585232907,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585232907","product_id":100039001,"comment_content":"结合springIoc容器可以很好的实现策略模式,每次这是需要实现固定的接口就行，方便","like_count":0},{"had_liked":false,"id":195055,"user_name":"往事随风，顺其自然","can_delete":false,"product_type":"c1","uid":1235692,"ip_address":"","ucode":"F266EC6B143E38","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/ec/779c1a78.jpg","comment_is_top":false,"comment_ctime":1585131808,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585131808","product_id":100039001,"comment_content":"很多设计模式是人为划分，到底哪种好，也没有定论，只有适合现有业务才是最合适的吧","like_count":0},{"had_liked":false,"id":194801,"user_name":"未命名","can_delete":false,"product_type":"c1","uid":1178114,"ip_address":"","ucode":"414CAE9E927CD3","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/02/7e70ada0.jpg","comment_is_top":false,"comment_ctime":1585107143,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585107143","product_id":100039001,"comment_content":"打卡，主要还是看设计思想，一般不同业务场景下细节不尽相同。","like_count":0},{"had_liked":false,"id":193840,"user_name":"刘大明","can_delete":false,"product_type":"c1","uid":1035081,"ip_address":"","ucode":"83C063FBD9BF2B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cb/49/0b9ffc8e.jpg","comment_is_top":false,"comment_ctime":1584972491,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584972491","product_id":100039001,"comment_content":"之前用策略模式做过通过解析统一入参里面的某一个类型来决定实现一个什么样的业务逻辑。当业务类型越来越多的时候，if条件分支也越来越多的时候，如果不做调整，实际上就违反了开闭原则，代码结构越来越乱。","like_count":0},{"had_liked":false,"id":193804,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1018370,"ip_address":"","ucode":"7A488CC6FE15E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","comment_is_top":false,"comment_ctime":1584968329,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584968329","product_id":100039001,"comment_content":"打卡 今日学习使用策略模式实现支持不同大小的文件排序，收获如下：<br>从文章中给出简单的需求，需求分析，写出最小原型，基于设计原则和利用策略模式经过三个版本的迭代，最终写出一个比较好的代码模型。通过该案例，对之前学习过的设计原则、编码规范以及策略模式有了一个很好的理解。完成案例后，算是对之前课程中有关“非业务系统需求分析与设计”作了一个简单的复习。同时深深体会到“设计原则和思想其实比设计模式更加普适和重要，掌握了代码的设计原则和思想，我们甚至可以自己创造出来新的设计模式。”这句话。在第四个版本中分别通过读取配置文件和扫描指定包路径下标注自定义的注解的类来避免策略工厂类的修改，为此还简单的去看了一下Spring中对于包扫描的逻辑实现，算是收获多多。在过去的项目中自己没有使用过策略模式，不过在现在项目开发中看到很多前人留下的代码中有策略模式的使用，刚开始不理解这么用的好处在哪里。学习后，知道了使用策略模式将不同的策略算法分别封装，使其独立。当然我自己也觉得有些地方是过度设计了，可读性很差。我觉得在项目中如果if-else 或 switch 分支逻辑不复杂，可读性和可维护性还算可行，后期需求变大也不大，不需要引入策略模式这类手段来引入复杂度。尽量保持KISS原则。当后期需求演变越来越复杂，再通过重构手段来引入策略模式来解决此类if-else 分支过多的问题。","like_count":0},{"had_liked":false,"id":193549,"user_name":"，","can_delete":false,"product_type":"c1","uid":1701867,"ip_address":"","ucode":"A5543C8DFEB198","user_header":"https://static001.geekbang.org/account/avatar/00/19/f7/eb/e7127bb8.jpg","comment_is_top":false,"comment_ctime":1584926126,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584926126","product_id":100039001,"comment_content":"课后题:<br>1.项目中需要对接不同位置上的摄像头,门口的,走廊的,大厅的,我分别为他们创建不同的Bean(多例模式,相同的类型不同的对象-doorCamera,corridorCamera,hallCamera,),但是他们有着同样的生命周期,比如建立连接,开始回调,收集扫描到的数据等等,于是我用模板方法模式对他们进行创建,实现相同行为api的复用,同时可以以摄像头为单位进行扩展,之后我在调用api时发现需要写很多if-else来判断调用的是哪个摄像头的api,于是将这些if-else下沉一层,通过传参和查表的方式来判断调用的是哪个摄像头的api,此处用到策略模式","like_count":0},{"had_liked":false,"id":193532,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1584924223,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584924223","product_id":100039001,"comment_content":"1.根据不同的配置策略选择不同的预处理、意图识别等；<br>2.if else如果过多或者if else里面的实现过于复杂就有必要去优化。","like_count":0},{"had_liked":false,"id":193523,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1584923547,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1584923547","product_id":100039001,"comment_content":"最后的实现产生了一个疑问:如果排序算法很多，这里的for循环中的if条件可能到最后一个算法才满足，那时间复杂度就是o(n),有没有优化办法呢","like_count":0,"discussions":[{"author":{"id":1385377,"avatar":"https://static001.geekbang.org/account/avatar/00/15/23/a1/b08f3ee7.jpg","nickname":"何妨","note":"","ucode":"EC3983BFF7992A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212001,"discussion_content":"换map,自己写个算法映射一下 filesize 到对应 key。 感觉也没有必要，这里循环也就最多 10 几次，影响不大吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584924565,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1336475,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","nickname":"J.Smile","note":"","ucode":"C4D98DFDBF7584","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1385377,"avatar":"https://static001.geekbang.org/account/avatar/00/15/23/a1/b08f3ee7.jpg","nickname":"何妨","note":"","ucode":"EC3983BFF7992A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212002,"discussion_content":"如果for迭代的是一个List<Future>这样的列表，每次迭代如果结果未返回则会阻塞。在这种场景下，能直接找到最关心的那个结果是很有必要的，避免可能出现的阻塞耗时。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584924879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":212001,"ip_address":""},"score":212002,"extra":""}]}]},{"had_liked":false,"id":193517,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1584922854,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1584922854","product_id":100039001,"comment_content":"在if else比较臃肿的时候可以考虑优化，还有如果可预见到未来会添加更多的else分支来支撑业务也可以考虑来优化。反之如果if else就几个也比较稳定，未来扩展机会不多，可以考虑不优化，避免过度设计。","like_count":0},{"had_liked":false,"id":193501,"user_name":"Rayjun","can_delete":false,"product_type":"c1","uid":1002514,"ip_address":"","ucode":"61A3D1A3D03569","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4c/12/f0c145d4.jpg","comment_is_top":false,"comment_ctime":1584921604,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584921604","product_id":100039001,"comment_content":"只有当这些分支会频繁变动的时候才需要考虑消除吧","like_count":0},{"had_liked":false,"id":193498,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1274787,"ip_address":"","ucode":"C233DF1D224EC1","user_header":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","comment_is_top":false,"comment_ctime":1584920997,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584920997","product_id":100039001,"comment_content":"1、产品大类不同，产品的处理逻辑各自不同，而且各自的处理逻辑老长老长，当时5种类型，调用了5个私有方法，每个私有方法都有150行左右，这个类的代码都有3000+了，针对此情况，我就用了类似查表法的策略模式； <br>2、if-else分支多，分支内的处理逻辑复杂，具有复用价值，后面还会不断增加不同分支的逻辑时就有必要去掉代码的分支逻辑，采用策略模式了","like_count":0},{"had_liked":false,"id":193489,"user_name":"宁锟","can_delete":false,"product_type":"c1","uid":1249781,"ip_address":"","ucode":"815FC9A9EBB109","user_header":"https://static001.geekbang.org/account/avatar/00/13/11/f5/039f003d.jpg","comment_is_top":false,"comment_ctime":1584918952,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584918952","product_id":100039001,"comment_content":"用到策略模式的地方有很多，比如图片裁剪支持不同的比例，android各种layout的布局规则，日志记录的不同方式，购物付款类型","like_count":0},{"had_liked":false,"id":193483,"user_name":"那个谁","can_delete":false,"product_type":"c1","uid":1118325,"ip_address":"","ucode":"43214CAE7062E7","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/75/ff76024c.jpg","comment_is_top":false,"comment_ctime":1584916443,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584916443","product_id":100039001,"comment_content":"讨论一：推荐排序的不同算法看做是各种不同的排序策略，配置中心选择一种；<br>讨论二：主要有两点，分支结构里的具体策略繁杂宏大，以及可预见的未来会有各种不同的策略需要调整","like_count":0}]}