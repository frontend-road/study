{"id":303,"title":"31 | 编程范式游记（2）- 泛型编程","content":"<p>你好，我是陈皓，网名左耳朵耗子。</p><p>在上节课，我从C语言开始说起，聊了聊面向过程式的编程范式，相信从代码的角度你对这类型的语言已经有了一些理解。作为一门高级语言，C语言绝对是编程语言历史发展中的一个重要里程碑，但随着认知的升级，面向过程的C语言已经无法满足更高层次的编程的需要。于是，C++出现了。</p><h1>C++语言</h1><p>1980年，AT&amp;T贝尔实验室的<strong>Bjarne Stroustrup</strong>创建的C++语言横空出世，它既可以全面兼容C语言，又巧妙揉合了一些面向对象的编程理念。现在来看，不得不佩服Stroustrup的魄力。在这里，我也向你推荐一本书，书名是《C++语言的设计和演化》。</p><p>这本书系统介绍了C++诞生的背景以及初衷，书的作者就是<a href=\"https://book.douban.com/author/362072/\">Stroustrup</a>本人，所以你可以非常详细地从语言创建者的角度了解他的设计思路和创新之旅。当然，就是在今天，C++这门语言也还有很多争议，这里我不细说。如果你感兴趣的话，可以看看我几年前在酷壳上发表的文章《<a href=\"https://coolshell.cn/articles/7992.html\">C++的坑真的多吗？</a>》。</p><p>从语言角度来说，实际上早期C++的许多工作是对C的强化和净化，并把完全兼容C作为强制性要求（这也是C++复杂晦涩的原因，这点Java就干得比C++彻底得多）。在C89、C99这两个C语言的标准中，有许多改进都是从C++中引进的。</p><!-- [[[read_end]]] --><p>可见，C++对C语言的贡献非常之大。是的，因为C++很大程度就是用来解决C语言中的各种问题和各种不方便的。比如：</p><ul>\n<li>\n<p>用引用来解决指针的问题。</p>\n</li>\n<li>\n<p>用namespace来解决名字空间冲突的问题。</p>\n</li>\n<li>\n<p>通过try-catch来解决检查返回值编程的问题。</p>\n</li>\n<li>\n<p>用class来解决对象的创建、复制、销毁的问题，从而可以达到在结构体嵌套时可以深度复制的内存安全问题。</p>\n</li>\n<li>\n<p>通过重载操作符来达到操作上的泛型。（比如，消除<a href=\"https://time.geekbang.org/column/article/301\">《01 | 编程范式游记：起源》</a>中提到的比较函数<code>cmpFn</code>，再比如用<code>&gt;&gt;</code>操作符消除<code>printf()</code>的数据类型不够泛型的问题。）</p>\n</li>\n<li>\n<p>通过模板template和虚函数的多态以及运行时识别来达到更高层次的泛型和多态。</p>\n</li>\n<li>\n<p>用RAII、智能指针的方式，解决了C语言中因为需要释放资源而出现的那些非常ugly也很容易出错的代码的问题。</p>\n</li>\n<li>\n<p>用STL解决了C语言中算法和数据结构的N多种坑。</p>\n</li>\n</ul><h1>C++泛型编程</h1><p>C++是支持编程范式最多的一门语言，它虽然解决了很多C语言的问题，但我个人觉得它最大的意义是解决了C语言泛型编程的问题。因为，我们可以看到一些C++的标准规格说明书里，有一半以上都在说明STL的标准规格应该是什么样的，这说明泛型编程是C++重点中的重点。</p><p>理想情况下，算法应是和数据结构以及类型无关的，各种特殊的数据类型理应做好自己分内的工作，算法只关心一个标准的实现。<strong>而对于泛型的抽象，我们需要回答的问题是，如果我们的数据类型符合通用算法，那么对数据类型的最小需求又是什么呢？</strong></p><p>我们来看看C++是如何有效解决程序泛型问题的，我认为有三点。</p><p><strong>第一，它通过类的方式来解决</strong>。</p><ul>\n<li>类里面会有构造函数、析构函数表示这个类的分配和释放。</li>\n<li>还有它的拷贝构造函数，表示了对内存的复制。</li>\n<li>还有重载操作符，像我们要去比较大于、等于、不等于。</li>\n</ul><p>这样可以让一个用户自定义的数据类型和内建的那些数据类型就很一致了。</p><p><strong>第二，通过模板达到类型和算法的妥协</strong>。</p><ul>\n<li>模板有点像DSL，模板的特化会根据使用者的类型在编译时期生成那个模板的代码。</li>\n<li>模板可以通过一个虚拟类型来做类型绑定，这样不会导致类型转换时的问题。</li>\n</ul><p>模板很好地取代了C时代宏定义带来的问题。</p><p><strong>第三，通过虚函数和运行时类型识别</strong>。</p><ul>\n<li>虚函数带来的多态在语义上可以支持“同一类”的类型泛型。</li>\n<li>运行时类型识别技术可以做到在泛型时对具体类型的特殊处理。</li>\n</ul><p>这样一来，就可以写出基于抽象接口的泛型。</p><p>拥有了这些C++引入的技术，我们就可以做到C语言很难做到的泛型编程了。</p><p>正如前面说过的，一个良好的泛型编程需要解决如下几个泛型编程的问题：</p><ol>\n<li>算法的泛型；</li>\n<li>类型的泛型；</li>\n<li>数据结构（数据容器）的泛型。</li>\n</ol><h2>C++泛型编程的示例 - Search函数</h2><p>就像前面的<code>search()</code>函数，里面的 <code>for(int i=0; i&lt;len; i++)</code> 这样的遍历方式，只能适用于<strong>顺序型的数据结构</strong>的方式迭代，如：array、set、queue、list和link等。并不适用于<strong>非顺序型的数据结构</strong>。</p><p>如哈希表hash table，二叉树binary tree、图graph等这样数据不是按顺序存放的数据结构（数据容器）。所以，如果找不到一种<strong>泛型的数据结构的操作方式（如遍历、查找、增加、删除、修改……）</strong>，那么，任何的算法或是程序都不可能做到真正意义上的泛型。</p><p>除了<code>search()</code>函数的“遍历操作”之外，还有search函数的返回值，是一个整型的索引下标。这个整型的下标对于“顺序型的数据结构”是没有问题的，但是对于“非顺序的数据结构”，在语义上都存在问题。</p><p>比如，如果我要在一个hash table中查找一个key，返回什么呢？一定不是返回“索引下标”，因为在hash table这样的数据结构中，数据的存放位置不是顺序的，而且还会因为容量不够的问题被重新hash后改变，所以返回数组下标是没有意义的。</p><p>对此，我们要把这个事做得泛型和通用一些。如果找到，返回找到的这个元素的一个指针（地址）会更靠谱一些。</p><p>所以，为了解决泛型的问题，我们需要动用以下几个C++的技术。</p><ol>\n<li>\n<p>使用模板技术来抽象类型，这样可以写出类型无关的数据结构（数据容器）。</p>\n</li>\n<li>\n<p>使用一个迭代器来遍历或是操作数据结构内的元素。</p>\n</li>\n</ol><p>我们来看一下C++版的<code>search()</code>函数是什么样的。</p><p>先重温一下C语言版的代码：</p><pre><code class=\"language-c\">int search(void* a, size_t size, void* target, \n\tsize_t elem_size, int(*cmpFn)(void*, void*) )\n{\n\tfor(int i=0; i&lt;size; i++) {\n\t\tif ( cmpFn (a + elem_size * i, target) == 0 ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n</code></pre><p>我们再来看一下C++泛型版的代码：</p><pre><code class=\"language-c++\">template&lt;typename T, typename Iter&gt;\nIter search(Iter pStart, Iter pEnd, T target) \n{\n\tfor(Iter p = pStart; p != pEnd; p++) {\n\t\tif ( *p == target ) \n\t\t\treturn p;\n\t}\n\treturn NULL;\n}\n</code></pre><p>在C++的泛型版本中，我们可以看到：</p><ul>\n<li>\n<p>使用<code>typename T</code>抽象了数据结构中存储数据的类型。</p>\n</li>\n<li>\n<p>使用<code>typename Iter</code>，这是不同的数据结构需要自己实现的“迭代器”，这样也就抽象掉了不同类型的数据结构。</p>\n</li>\n<li>\n<p>然后，我们对数据容器的遍历使用了<code>Iter</code>中的<code>++</code>方法，这是数据容器需要重载的操作符，这样通过操作符重载也就泛型掉了遍历。</p>\n</li>\n<li>\n<p>在函数的入参上使用了<code>pStart</code>和<code>pEnd</code>来表示遍历的起止。</p>\n</li>\n<li>\n<p>使用<code>*Iter</code>来取得这个“指针”的内容。这也是通过重载 <code>*</code> 取值操作符来达到的泛型。</p>\n</li>\n</ul><p>当然，你可能会问，为什么我们不用标准接口<code>Iter.Next()</code>取代<code>++</code>， 用<code>Iter.GetValue()</code>来取代<code>*</code>，而是通过重载操作符？其实这样做是为了兼容原有C语言的编程习惯。</p><p>说明一下，所谓的<code>Iter</code>，在实际代码中，就是像<code>vector&lt;int&gt;::iterator</code>或<code>map&lt;int, string&gt;::iterator</code>这样的东西。这是由相应的数据容器来实现和提供的。</p><p>注：下面是C++ STL中的<code>find()</code>函数的代码。</p><pre><code class=\"language-c++\">template&lt;class InputIterator, class T&gt;\n  InputIterator find (InputIterator first, InputIterator last, const T&amp; val)\n{\n  while (first!=last) {\n    if (*first==val) return first;\n    ++first;\n  }\n  return last;\n}\n</code></pre><h2>C++泛型编程示例 - Sum 函数</h2><p>也许你觉得到这一步，我们的泛型设计就完成了。其实，还远远不够。<code>search</code>函数只是一个开始，我们还有很多别的算法会让问题变得更为复杂。</p><p>我们再来看一个<code>sum()</code>函数。</p><p>先看C语言版：</p><pre><code class=\"language-c\">long sum(int *a, size_t size) {\n\tlong result = 0;\n\tfor(int i=0; i&lt;size; i++) {\n\t\tresult += a[i];\n\t}\n\treturn result;\n}\n</code></pre><p>再看一下C++泛型的版本：</p><pre><code class=\"language-c++\">template&lt;typename T, typename Iter&gt;\nT sum(Iter pStart, Iter pEnd) {\n\tT result = 0;\n\tfor(Iter p=pStart; p!=pEnd; p++) {\n\t\tresult += *p;\n\t}\n\treturn result;\t\n}\n</code></pre><p>你看到了什么样的问题？这个代码中最大的问题就是 <code>T result = 0;</code> 这条语句：</p><ul>\n<li>那个<code>0</code>假设了类型是<code>int</code>；</li>\n<li>那个<code>T</code>假设了Iter中出来的类型是<code>T</code>。</li>\n</ul><p>这样的假设是有问题的，如果类型不一样，就会导致转型的问题，这会带来非常buggy的代码。那么，我们怎么解决呢？</p><h2>C++泛型编程的重要技术 - 迭代器</h2><p>我们知道<code>Iter</code>在实际调用者那会是一个具体的像<code>vector&lt;int&gt;::iterator</code>这样的东西。在这个声明中，<code>int</code>已经被传入<code>Iter</code>中了。所以，定义<code>result</code>的<code>T</code>应该可以从<code>Iter</code>中来。这样就可以保证类型是一样的，而且不会有被转型的问题。</p><p>所以，我们需要精心地实现一个“迭代器”。下面是一个“精简版”的迭代器（我没有把C++ STL代码里的迭代器列出来，是因为代码太多太复杂，我这里只是为了说明问题）。</p><pre><code class=\"language-c++\">template &lt;class T&gt;\nclass container {\npublic:\n\tclass iterator {\n\tpublic:\n\t\ttypedef iterator self_type;\n\t\ttypedef T   value_type;\n\t\ttypedef T*  pointer;\n\t\ttypedef T&amp; \treference;\n\n\t\treference operator*();\n\t\tpointer operator-&gt;();\n\t\tbool operator==(const self_type&amp; rhs)；\n\t\tbool operator!=(const self_type&amp; rhs)；\n\t\tself_type operator++() { self_type i = *this; ptr_++; return i; }\n\t\tself_type operator++(int junk) { ptr_++; return *this; }\n\t\t...\n\t\t...\n\tprivate:\n\t\tpointer _ptr;\n\t};\n\n\titerator begin();\n\titerator end();\n\t...\n\t...\n};\n</code></pre><p>上面的代码是我写的一个迭代器（这个迭代器在语义上是没有问题的），我没有把所有的代码列出来，而把它的一些基本思路列了出来。这里我说明一下几个关键点。</p><ul>\n<li>\n<p>首先，一个迭代器需要和一个容器在一起，因为里面是对这个容器的具体的代码实现。</p>\n</li>\n<li>\n<p>它需要重载一些操作符，比如：取值操作<code>*</code>、成员操作<code>-&gt;</code>、比较操作<code>==</code>和<code>!=</code>，还有遍历操作<code>++</code>，等等。</p>\n</li>\n<li>\n<p>然后，还要<code>typedef</code>一些类型，比如<code>value_type</code>，告诉我们容器内的数据的实际类型是什么样子。</p>\n</li>\n<li>\n<p>还有一些，如<code>begin()</code>和<code>end()</code>的基本操作。</p>\n</li>\n<li>\n<p>我们还可以看到其中有一个<code>pointer _ptr</code>的内部指针来指向当前的数据（注意，<code>pointer</code>就是 <code>T*</code>）。</p>\n</li>\n</ul><p>好了，有了这个迭代器后，我们还要解决<code>T result = 0</code>后面的这个<code>0</code>的问题。这个事，算法没有办法搞定，最好由用户传入。于是出现了下面最终泛型的<code>sum()</code>版函数。</p><pre><code class=\"language-c++\">template &lt;class Iter&gt;\ntypename Iter::value_type\nsum(Iter start, Iter end, T init) {\n\ttypename Iter::value_type result = init;\n\twhile (start != end) {\n\t\tresult = result + *start;\n\t\tstart++;\n\t}\n\treturn result;\n}\n</code></pre><p>我们可以看到<code>typename Iter::value_type result = init</code>这条语句是关键。我们解决了所有的问题。</p><p>我们使用如下：</p><pre><code class=\"language-c++\">container&lt;int&gt; c;\ncontainer&lt;int&gt;::iterator it = c.begin();\nsum(c.begin(), c.end(), 0);\n</code></pre><p>这就是整个STL的泛型方法，其中包括：</p><ul>\n<li>泛型的数据容器；</li>\n<li>泛型数据容器的迭代器；</li>\n<li>然后泛型的算法就很容易写了。</li>\n</ul><h1>需要更多的抽象</h1><h2>更为复杂的需求</h2><p>但是，还能不能做到更为泛型呢？比如：如果我们有这样的一个数据结构Employee，里面有vacation就是休假多少天，以及工资。</p><pre><code class=\"language-c++\">struct Employee {\n\tstring name;\n\tstring id;\n\tint vacation;\n\tdouble salary；\n};\n</code></pre><p>现在我想计算员工的总薪水，或是总休假天数。</p><pre><code class=\"language-c++\">vector&lt;Employee&gt; staff;\n//total salary or total vacation days?\nsum(staff.begin(), staff.end(), 0);\n</code></pre><p>我们的<code>sum</code>完全不知道怎么搞了，因为要累加的是<code>Employee</code>类中的不同字段，即便我们的Employee中重载了<code>+</code>操作，也不知道要加哪个字段。</p><p>另外，我们可能还会有：求平均值average，求最小值min，求最大值max，求中位数mean等等。你会发现，算法写出来基本上都是一样的，只是其中的“累加”操作变成了另外一个操作。就这个例子而言，我想计算员工薪水里面最高的，和休假最少的，或者我想计算全部员工的总共休假多少天。那么面对这么多的需求，我们是否可以泛型一些呢？怎样解决这些问题呢？</p><h2>更高维度的抽象</h2><p>要解决这个问题，我希望我的这个算法只管遍历，具体要干什么，那是业务逻辑，由外面的调用方来定义我就好了，和我无关。这样一来，代码的重用度就更高了。</p><p>下面是一个抽象度更高的版本，这个版本再叫<code>sum</code>就不太合适了。这个版本应该是<code>reduce</code>——用于把一个数组reduce成一个值。</p><pre><code class=\"language-c++\">template&lt;class Iter, class T, class Op&gt;\nT reduce (Iter start, Iter end, T init, Op op) {\n\tT result = init;\n\twhile ( start != end ) {\n\t\tresult = op( result, *start );\n\t\tstart++;\n\t}\n\treturn result;\n}\n\n</code></pre><p>上面的代码中，我们需要传一个函数进来。在STL中，它是个函数对象，我们还是这套算法，但是result不是像前面那样去加，是把整个迭代器值给你一个operation，然后由它来做。我把这个方法又拿出去了，所以就会变成这个样子。</p><p>在C++ STL中，与我的这个reduce函数对应的函数名叫 <code>accumulate()</code>，其实际代码有两个版本。</p><p>第一个版本就是下面的版本，只不过是用<code>for</code>语句而不是<code>while</code>。</p><pre><code class=\"language-c++\">template&lt;class InputIt, class T&gt;\nT accumulate(InputIt first, InputIt last, T init)\n{\n    for (; first != last; ++first) {\n        init = init + *first;\n    }\n    return init;\n}\n</code></pre><p>第二个版本，更为抽象，因为需要传入一个“二元操作函数”——<code>BinaryOperation op</code>来做accumulate。accumulate的语义比sum更抽象了。</p><pre><code class=\"language-c++\">template&lt;class InputIt, class T, class BinaryOperation&gt;\nT accumulate(InputIt first, InputIt last, T init, \n             BinaryOperation op)\n{\n    for (; first != last; ++first) {\n        init = op(init, *first);\n    }\n    return init;\n}\n</code></pre><p>来看看我们在使用中是什么样子的：</p><pre><code class=\"language-c++\">double sum_salaries = \n  reduce( staff.begin(), staff.end(), 0.0,\n\t\t  [](double s, Employee e)\n\t\t    {return s + e.salary;}  );\n\ndouble max_salary =\n  reduce( staff.begin(), staff.end(), 0.0,\n\t\t  [](double s, Employee e)\n\t\t    {return s &gt; e.salary? s: e.salary; } );\n</code></pre><p>注意：我这里用了C++的lambda表达式。</p><p>你可以很清楚地看到，reduce这个函数就更通用了，具体要干什么样的事情呢？放在匿名函数里面，它会定义我，我只做一个reduce。更抽象地来说，我就把一个数组，一个集合，变成一个值。怎么变成一个值呢？由这个函数来决定。</p><h3>Reduce 函数</h3><p>我们来看看如何使用reduce和其它函数完成一个更为复杂的功能。</p><p>下面这个示例中，我先定义了一个函数对象<code>counter</code>。这个函数对象需要一个<code>Cond</code>的函数对象，它是个条件判断函数，如果满足条件，则加1，否则加0。</p><pre><code class=\"language-c++\">template&lt;class T, class Cond&gt;\nstruct counter {\n\tsize_t operator()(size_t c, T t) const {\n\t\treturn c + (Cond(t) ? 1 : 0);\n\t}\n};\n</code></pre><p>然后，我用上面的<code>counter</code>函数对象和<code>reduce</code>函数共同来打造一个<code>counter_if</code>算法（当条件满足的时候我就记个数，也就是统计满足某个条件的个数），我们可以看到，就是一行代码的事。</p><pre><code class=\"language-c++\">template&lt;class Iter, class Cond&gt;\nsize_t count_if(Iter begin, Iter end, Cond c){\n\treturn reduce(begin, end, 0, \n\t\t\t\t  counter&lt;Iter::value_type, Cond&gt;(c));\n}\n</code></pre><p>至于是什么样的条件，这个属于业务逻辑，不是我的流程控制，所以，这应该交给使用方。</p><p>于是，当我需要统计薪资超过1万元的员工的数量时，一行代码就完成了。</p><pre><code class=\"language-c++\">size_t cnt = count_if(staff.begin(), staff.end(), \n\t\t\t\t\t[](Employee e){ return e.salary &gt; 10000; });\n</code></pre><p>Reduce时可以只对结构体中的某些值做Reduce，比如说只对 <code>salary&gt;10000</code> 的人做，只选出这个里面的值，它用Reduce就可以达到这步，只要传不同的方式给它，你就可以又造出一个新的东西出来。</p><p>说着说着，就到了函数式编程。函数式编程里面，我们可以用很多的像reduce这样的函数来完成更多的像STL里面的<code>count_if()</code>这样有具体意义的函数。关于函数式编程，我们会在后面继续具体聊。</p><h1>小结</h1><p>在这篇文章中，我们聊到C++语言是如何通过泛型来解决C语言遇到的问题，其实这里面主要就是泛型编程和函数式编程的基本方法相关的细节，虽然解决编程语言中类型带来的问题可能有多种方式，不一定就是C++这种方式。</p><p>而我之所以从C/C++开始，目的只是因为C/C++都是比较偏底层的编程语言。从底层的原理上，我们可以更透彻地了解，从C到C++的演进这一过程中带来的编程方式的变化。这可以让你看到，在静态类型语言方面解决泛型编程的一些技术和方法，从而感受到其中的奥妙和原理。</p><p><strong>因为形式是多样的，但是原理是相通的，所以，这个过程会非常有助于你更深刻地了解后面会谈到的更多的编程范式</strong>。</p><p>以下是《编程范式游记》系列文章的目录，方便你了解这一系列内容的全貌。</p><ul>\n<li><a href=\"https://time.geekbang.org/column/article/301\">01 | 编程范式游记：起源</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/303\">02 | 编程范式游记：泛型编程</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2017\">03 | 编程范式游记：类型系统和泛型的本质</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2711\">04 | 编程范式游记：函数式编程</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2723\">05 | 编程范式游记：修饰器模式</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2729\">06 | 编程范式游记：面向对象编程</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2741\">07 | 编程范式游记：基于原型的编程范式</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2748\">08 | 编程范式游记：Go 语言的委托模式</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2751\">09 | 编程范式游记：编程的本质</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2752\">10 | 编程范式游记：逻辑编程范式</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/2754\">11 | 编程范式游记：程序世界里的编程范式</a></li>\n</ul>","comments":[{"had_liked":false,"id":3099,"user_name":"okokabcd","can_delete":false,"product_type":"c1","uid":1013735,"ip_address":"","ucode":"93EC813007F6ED","user_header":"","comment_is_top":false,"comment_ctime":1518541604,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"297871285028","product_id":100002201,"comment_content":"版本一：<br>电影(男主，女主) {<br>        男主杀死了女主<br>}<br><br>版本二：<br>电影(男主，女主，情节(A,B){A爱上了B}){<br>        情节(男主，女主)<br>}","like_count":70,"discussions":[{"author":{"id":1358206,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b9/7e/732c5672.jpg","nickname":"Seaworth","note":"","ucode":"EBB7DF0519B4C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367054,"discussion_content":"形象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618241028,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":5540,"user_name":"昵称","can_delete":false,"product_type":"c1","uid":1025680,"ip_address":"","ucode":"FD6A58AB271E5D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a6/90/5295fce8.jpg","comment_is_top":false,"comment_ctime":1523495006,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"74537939038","product_id":100002201,"comment_content":"《STL源码解析》，《inside c++model》，记得当时啃这两本时经常要感叹怎么设计的这么精妙，了解内部实现方式后，在使用的时候也更加心里有底","like_count":18},{"had_liked":false,"id":2021,"user_name":"闫飞","can_delete":false,"product_type":"c1","uid":1013162,"ip_address":"","ucode":"30C782D30108D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/aa/21275b9d.jpg","comment_is_top":false,"comment_ctime":1515540510,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"65940049950","product_id":100002201,"comment_content":"泛型技术是静态系统所独有的特性，本质上我觉得还是为了兼顾执行效率和编程灵活性，实现零成本抽象这一刀尖上跳舞的巨大挑战。<br><br>较新的语言标准还提炼了很多基础设施，比如大量使用SFINAE并泛化之,提供enable if, constexpr if, 乃至自动类型推断和concept check，和Java那边的套路是完全不一样的。<br><br>可以说不深入理解泛型技术基本，就不能很好理解现代的C++了。","like_count":16},{"had_liked":false,"id":143657,"user_name":"Geek_e5dad7","can_delete":false,"product_type":"c1","uid":1692807,"ip_address":"","ucode":"FEF4854FE2759D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKPT2nsSXGMFqhHWNJmXbLTOwJI9vAPQFFd1bCR6xd8hthUqUnETQicJ6ZFtXwO5s1yuHPK0FetugQ/132","comment_is_top":false,"comment_ctime":1571752675,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"48816392931","product_id":100002201,"comment_content":"看到大家都说看的很享受，但是我真的看不懂😭","like_count":12,"discussions":[{"author":{"id":1209969,"avatar":"https://static001.geekbang.org/account/avatar/00/12/76/71/ff2e9eca.jpg","nickname":"天空的颜色","note":"","ucode":"59BF0FE715FBAD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78878,"discussion_content":"同不懂，看来我是个假的程序员","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576029394,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104692,"user_name":"edisonhuang","can_delete":false,"product_type":"c1","uid":1530167,"ip_address":"","ucode":"BB2F639A779F96","user_header":"https://static001.geekbang.org/account/avatar/00/17/59/37/bd2de0a4.jpg","comment_is_top":false,"comment_ctime":1560819039,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35920557407","product_id":100002201,"comment_content":"C++通过范型消除了C语言中很多易出bug的代码，实现代码重用。其中关键在于：算法的泛型；类型的泛型；数据结构（数据容器）的泛型。<br>C++通过类，在构造和析构函数中做资源的申请释放，通过引用解决了用指针来取值的问题。通过操作符的重载让算法代码忽略具体类型，可以有统一的表达。通过类似迭代器的范型容器来统一不同数据结构的统一算法表达。<br>通过抽象算法中函数的操作，用函数式编程的方式，实现算法的泛型。<br>总之，通过不同粒度的抽象，而让代码重用更容易，bug更少，更好维护和扩展","like_count":9},{"had_liked":false,"id":11227,"user_name":"知知知了","can_delete":false,"product_type":"c1","uid":1144609,"ip_address":"","ucode":"7C5BFA221D8AA3","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/yKHmnxSV4K1JqQ8wXeC5Sj9cJiba2iabicm9ibaDQaLtlXZzKXruH9RI4hgDlJ2P0LxYXKknpibfGTFvcK3vAwXPGWA/132","comment_is_top":false,"comment_ctime":1527951814,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"27297755590","product_id":100002201,"comment_content":"counter结构体有点问题，调了半天。 如果刚上大学能看到耗子书的文章就好了，看谭浩强学的c和c++真浪费生命，编程还沦为了二流，唉","like_count":7,"discussions":[{"author":{"id":1166111,"avatar":"https://static001.geekbang.org/account/avatar/00/11/cb/1f/d12f34de.jpg","nickname":"Sheldon","note":"","ucode":"26855852330DC7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348736,"discussion_content":"笑了，谭浩强确实害人无数。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612695670,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":2028,"user_name":"Join","can_delete":false,"product_type":"c1","uid":1014873,"ip_address":"","ucode":"20F51EFFD8FEDE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7c/59/dc9bbb21.jpg","comment_is_top":false,"comment_ctime":1515558609,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27285362385","product_id":100002201,"comment_content":"读起来真是太享受了，感觉之前看的那些STL知识被瞬间点燃了，以前思考并未达到这样的深度，能做到将技术和业务逻辑分离开的代码真是太通用了，现在回去再读一遍STL源码解析会更有体会","like_count":7},{"had_liked":false,"id":2005,"user_name":"郑杰","can_delete":false,"product_type":"c1","uid":1014917,"ip_address":"","ucode":"789EAB2A08EBEF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7c/85/8b221758.jpg","comment_is_top":false,"comment_ctime":1515462215,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"22990298695","product_id":100002201,"comment_content":"可以讲讲java的类型擦除原理吗","like_count":6},{"had_liked":false,"id":101529,"user_name":"karas","can_delete":false,"product_type":"c1","uid":1349594,"ip_address":"","ucode":"836873D0D9973B","user_header":"https://static001.geekbang.org/account/avatar/00/14/97/da/ae765e15.jpg","comment_is_top":false,"comment_ctime":1559846083,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18739715267","product_id":100002201,"comment_content":"实在不怎么懂cpp，对标Java说一点。感觉cpp做到通用操作最重要的是操作符重载，比如上面的累加的实现主要就是靠++重载定义next（），*重载定义怎么取对象的值，+重载定义累加的逻辑。对标Java，Java没有操作符重载，他主要依赖接口去规约必要的通用操作。比如一般容器会实现iterator接口，涉及到排序则要求&lt;T extends Comparator&gt;类型参数。凭直觉来讲，操作符可能更加灵活一点。<br>另外最后介绍的函数参数，应该算是Java里的匿名类吧，当然j8也可以用lambda了，不过我倒觉得这和泛型无关吧，算是函数式的概念。","like_count":5},{"had_liked":false,"id":63305,"user_name":"CH_G318","can_delete":false,"product_type":"c1","uid":1159143,"ip_address":"","ucode":"F336B2434E4A5E","user_header":"https://static001.geekbang.org/account/avatar/00/11/af/e7/20a44d14.jpg","comment_is_top":false,"comment_ctime":1548319880,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18728189064","product_id":100002201,"comment_content":"有些代码跑不通，总是报错，现在修改成下面的样子了：<br>template&lt;class T, class Cond&gt;<br>struct counter {<br>    Cond cond;  &#47;&#47; 添加一个变量<br>    size_t operator()(size_t c, T t) {<br>        return c + (cond(t) ? 1 : 0);   &#47;&#47; 使用变量进行判断<br>    }<br>};<br><br><br>template&lt;class Iter, class Cond&gt;<br>size_t count_if(Iter begin, Iter end, Cond c) {<br>    auto op = counter&lt;typename Iter::value_type, Cond&gt;{c};   &#47;&#47; 初始化counter结构体<br>    return reduce(begin, end, size_t(0), op);<br>}<br>","like_count":4,"discussions":[{"author":{"id":2066703,"avatar":"","nickname":"刘适","note":"","ucode":"19F17B6EE92B7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337321,"discussion_content":"我也是对此处产生疑惑，手头没有电脑，无法验证原文写法的正确性。\n\n但是基本思想是，funtor本身是个类型，不能直接调用，所以需要实例对象，除非是静态成员函数，但能否将重载运算符声明成静态我并不知晓。\n\n接着产生第二个问题，实例出来的对象如何初始化，这里利用更改过后的counter是聚合类型(aggregate type) ，所以可以使用花括号进行list initialization初始化，但如果可以显式地定义一个构造函数，感觉更清晰一些。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1608873397,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":10988,"user_name":"saiyn","can_delete":false,"product_type":"c1","uid":1135770,"ip_address":"","ucode":"99D61992C3FF7D","user_header":"https://static001.geekbang.org/account/avatar/00/11/54/9a/5d8c349e.jpg","comment_is_top":false,"comment_ctime":1527777349,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18707646533","product_id":100002201,"comment_content":"从c到c++的发展过程，让我深刻理解了迭代器是个什么鬼，感谢耗子叔","like_count":5},{"had_liked":false,"id":101347,"user_name":"桃子妈妈","can_delete":false,"product_type":"c1","uid":1141504,"ip_address":"","ucode":"16E7D2FBAE452F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/yy4cUibeUfPHPkXXZQnQwjXY7m5rXY5ib6a7pC1vkupj1icibF305N4pJSdqw0fO1ibvyfKCQ7HWggLhwiaNbbRPBsKg/132","comment_is_top":false,"comment_ctime":1559786316,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14444688204","product_id":100002201,"comment_content":"大神就是把复杂的知识简单化的讲解出来，好厉害","like_count":4},{"had_liked":false,"id":9364,"user_name":"夏洛克的救赎","can_delete":false,"product_type":"c1","uid":1021334,"ip_address":"","ucode":"44453DD27A3216","user_header":"https://static001.geekbang.org/account/avatar/00/0f/95/96/0020bd67.jpg","comment_is_top":false,"comment_ctime":1526821959,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14411723847","product_id":100002201,"comment_content":"如何理解aop","like_count":3},{"had_liked":false,"id":2003,"user_name":"云学","can_delete":false,"product_type":"c1","uid":1027233,"ip_address":"","ucode":"366AE90BA06356","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ac/a1/43d83698.jpg","comment_is_top":false,"comment_ctime":1515462146,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14400364034","product_id":100002201,"comment_content":"恰巧不久前实现过迭代器，所以读起来非常享受","like_count":3},{"had_liked":false,"id":234631,"user_name":"流云","can_delete":false,"product_type":"c1","uid":1784826,"ip_address":"","ucode":"C6CA4811B6182D","user_header":"https://static001.geekbang.org/account/avatar/00/1b/3b/fa/abe4d7c9.jpg","comment_is_top":false,"comment_ctime":1594738408,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10184673000","product_id":100002201,"comment_content":"汇编语言算是无类型语言，C语言引入了类型系统，C++ 又扩展了泛型编程，类型往底层反映了内存布局与管理策略，往上层抽象出算法的通用性，通过类型系统把这几种语言的理解推进了一大步，感谢左耳朵。<br><br>下面为counter 新增了一个私有成员变量和一个构造函数，解决编译错误问题：<br>template&lt;class T, class Cond&gt;<br>class counter<br>{<br>private:<br>    Cond cond;<br><br>public:<br>    counter(Cond c):cond(c) { }<br><br>    size_t operator()(size_t c, T t) const {<br>        return c + (cond(t) ? 1 : 0);<br>    }<br>};","like_count":2,"discussions":[{"author":{"id":1249491,"avatar":"https://static001.geekbang.org/account/avatar/00/13/10/d3/cb011861.jpg","nickname":"张志强","note":"","ucode":"C9D4301CA62DBE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343261,"discussion_content":"可以分享下完整代码的repo吗？刚开始学习C++，想跟着您学习一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610975909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37441,"user_name":"caohuan","can_delete":false,"product_type":"c1","uid":1256428,"ip_address":"","ucode":"4B092E33F3DF1E","user_header":"https://static001.geekbang.org/account/avatar/00/13/2b/ec/af6d0b10.jpg","comment_is_top":false,"comment_ctime":1541586730,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10131521322","product_id":100002201,"comment_content":"耗子哥 一步步的抽象过程，让我想到了C#和java都是面向对象语言，都有抽象的说法，比如 类为对象的抽象，接口为 类的抽象，有了抽象的思维，会让实现变得友好，逻辑也清晰，耗子哥的专栏也是这样的设计思想。","like_count":2},{"had_liked":false,"id":3176,"user_name":"上上签","can_delete":false,"product_type":"c1","uid":1040094,"ip_address":"","ucode":"EF5FDA736CA6E1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/de/de/a2899b93.jpg","comment_is_top":false,"comment_ctime":1518620931,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10108555523","product_id":100002201,"comment_content":"认真仔细学习，才觉得真是很不错的，不白付费。","like_count":2},{"had_liked":false,"id":2061,"user_name":"JK.Ryan","can_delete":false,"product_type":"c1","uid":1014467,"ip_address":"","ucode":"D1E533F3DEC481","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/c3/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1515679749,"is_pvip":false,"replies":[{"id":"405","content":"后面会有的","user_name":"作者回复","comment_id":2061,"uid":"1001269","ip_address":"","utype":1,"ctime":1515731678,"user_name_real":"左耳朵"}],"discussion_count":1,"race_medal":0,"score":"10105614341","product_id":100002201,"comment_content":"写的很赞👍🏾，感觉也可以顺带讲一下Go的接口，对比多语言可以更加突出“范式”：）","like_count":2,"discussions":[{"author":{"id":1001269,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/35/89726f5f.jpg","nickname":"左耳朵","note":"","ucode":"8A4741D677702E","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":415630,"discussion_content":"后面会有的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1515731678,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":2004,"user_name":"郑杰","can_delete":false,"product_type":"c1","uid":1014917,"ip_address":"","ucode":"789EAB2A08EBEF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7c/85/8b221758.jpg","comment_is_top":false,"comment_ctime":1515462164,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10105396756","product_id":100002201,"comment_content":"c++的模板特化跟Java的类型擦除应该做的是一类事情吧？","like_count":2},{"had_liked":false,"id":233716,"user_name":"Marvichov","can_delete":false,"product_type":"c1","uid":1111835,"ip_address":"","ucode":"7482099415C41C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f7/1b/db7a0edc.jpg","comment_is_top":false,"comment_ctime":1594402734,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5889370030","product_id":100002201,"comment_content":"Rust可以对generic type做Trait (类似java的interface）类型检测 (相当于把C++ concept具象化了):<br>```<br>&#47;&#47; where clause is borrowed from swift, personally, I think it&#39;s great for readability<br>fn some_function&lt;T, U&gt;(t: T, u: U) -&gt; i32 where T: Display + Clone, U: Clone + Debug {...}<br>```<br>总体感觉rust的interface oriented programming是C++ generic的升级，完全可以替代以继承","like_count":1},{"had_liked":false,"id":200491,"user_name":"even","can_delete":false,"product_type":"c1","uid":1249431,"ip_address":"","ucode":"C976CFB2A0EBBF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Cwkic25ndkExxY3HvVjAaYKVzFRicv2X6TE2sjdqTBBmqeh7X8crIQe3SHPichvcayOCqI3PJ88yVuMNlD8VvkE3A/132","comment_is_top":false,"comment_ctime":1585612837,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880580133","product_id":100002201,"comment_content":"之前看了跟着侯捷《STL源码剖析》用的SGI STL 2.9版本实现了一遍容器相关的代码，其实基本都理解了泛型编程的思路，再在这里看了耗子哥的讲解，简直是一种享受，有种融汇贯通的感觉，大神果然是大神！","like_count":1},{"had_liked":false,"id":100803,"user_name":"不记年","can_delete":false,"product_type":"c1","uid":1045945,"ip_address":"","ucode":"287E40C68356DC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/b9/888fe350.jpg","comment_is_top":false,"comment_ctime":1559641861,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5854609157","product_id":100002201,"comment_content":"将泛型做到极致的算法我觉得就是一些方法调用的集合，并且调用的方法完全隐藏类型的实现，也就是说从算法内部完全获得不到传入参数的信息。这些方法调用所体现的语义与算法的名字是等价的。","like_count":1},{"had_liked":false,"id":99489,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1559227406,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"5854194702","product_id":100002201,"comment_content":"曾经啃过 C++ Prime，也翻过 Thinking in C++，不过一直没有使用 C++ 写过真实的业务实现代码，所以始终处于 C++ 菜鸟的境地。<br><br>从这篇文章中，终于知道 C++ 的出现，并不是简单的增加了所谓“面向对象”的特性，而是在很大程度上采用泛型编程来解决 C 语言在工程实现上面临的一些问题。<br><br>我个人比较偏好 C# 或者 Ruby 一类的语言，相对来说，这两种语言更贴近与业务逻辑，对于底层的依赖不多，但是感觉在某种意义上也实现了“泛型编程”范式，不知道这样理解是否正确。<br><br>另外，对于电影的那则留言，版本三似乎可以是：<br><br>电影(人物1, 人物2, 群演, 情节(A,B)){<br>  情节(人物1, 人物2, 群演)<br>}<br><br>主要区别在于情节是可以通过函数调用传递过来，由拍电影的人决定采用什么样的情节。","like_count":1},{"had_liked":false,"id":8397,"user_name":"favorlm","can_delete":false,"product_type":"c1","uid":1120997,"ip_address":"","ucode":"CFD52127AA6E1D","user_header":"https://static001.geekbang.org/account/avatar/00/11/1a/e5/6899701e.jpg","comment_is_top":false,"comment_ctime":1526176427,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5821143723","product_id":100002201,"comment_content":"可能真的需要五年，我如果现在可以懂，就是一年顶五年吗。","like_count":1,"discussions":[{"author":{"id":2444183,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/ZrPfqw4AbHd2F4VzplicZiaoicjjZG1kEQIart7LKLMVhe4fhMNSRdcV3JxP3nmITHdIV0tGYGOadUMHxwVt2uPzg/132","nickname":"云飘","note":"","ucode":"FAF20E3CAA70DF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394339,"discussion_content":"你现在的理解和五年后的理解肯定不一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631845694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":3495,"user_name":"郁","can_delete":false,"product_type":"c1","uid":1058787,"ip_address":"","ucode":"905D8D5FA60172","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/ynEtBO8iayrGrbbekL9g8CJ7Mnl1u2Dom2Bt4XNPNZyTJ5woicYTewvxwTEhEyQ2UEBszRLEj5TkJxicaEb5rW0Cw/132","comment_is_top":false,"comment_ctime":1519750326,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5814717622","product_id":100002201,"comment_content":"好久没看到谈编程范式的文章了，回忆起当初看《多范式编程》那本书，还是看本文更有感触","like_count":1},{"had_liked":false,"id":2129,"user_name":"Sdylan","can_delete":false,"product_type":"c1","uid":1008503,"ip_address":"","ucode":"4589D0D0FA9275","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/77/423345ab.jpg","comment_is_top":false,"comment_ctime":1516001981,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5810969277","product_id":100002201,"comment_content":"看到抽象这层的时候，脑子里面碰触出来的知识点是sicp上的。","like_count":1},{"had_liked":false,"id":2040,"user_name":"草戊","can_delete":false,"product_type":"c1","uid":1044202,"ip_address":"","ucode":"F1B0CB0A4FA762","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/ea/c8136dfd.jpg","comment_is_top":false,"comment_ctime":1515600196,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5810567492","product_id":100002201,"comment_content":"从java8才开始学习lambda，学习函数式编程的东西，觉得用起来很爽，原来在c++早就有了。","like_count":1},{"had_liked":false,"id":2031,"user_name":"Wilson_qqs","can_delete":false,"product_type":"c1","uid":1044241,"ip_address":"","ucode":"53169919DD5A84","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ef/11/dd71f70f.jpg","comment_is_top":false,"comment_ctime":1515563725,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5810531021","product_id":100002201,"comment_content":"第一次购买付费知识内容，果断的跟着耗子哥了","like_count":1},{"had_liked":false,"id":2007,"user_name":"恩言","can_delete":false,"product_type":"c1","uid":1026855,"ip_address":"","ucode":"79771A313B9CCC","user_header":"","comment_is_top":false,"comment_ctime":1515466259,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5810433555","product_id":100002201,"comment_content":"有一点点领悟了，期待下一篇","like_count":1},{"had_liked":false,"id":282704,"user_name":"云师兄","can_delete":false,"product_type":"c1","uid":1205777,"ip_address":"","ucode":"EB19F80070FE23","user_header":"https://static001.geekbang.org/account/avatar/00/12/66/11/f7408e3e.jpg","comment_is_top":false,"comment_ctime":1615369115,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615369115","product_id":100002201,"comment_content":"从低维的耦合泛型到高纬的解耦泛型，泛型之路简直是无限光彩！","like_count":0},{"had_liked":false,"id":275780,"user_name":"栗子","can_delete":false,"product_type":"c1","uid":2246899,"ip_address":"","ucode":"B8B50693EB24C0","user_header":"https://static001.geekbang.org/account/avatar/00/22/48/f3/6414dea8.jpg","comment_is_top":false,"comment_ctime":1611665474,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611665474","product_id":100002201,"comment_content":"还是没有看懂泛型的本质。对应到golang，有interface，有func类型，这些是不是就是泛型的一种，那到底什么是泛型呢？","like_count":0},{"had_liked":false,"id":269533,"user_name":"dingtingli","can_delete":false,"product_type":"c1","uid":1014522,"ip_address":"","ucode":"13725160E4713F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/fa/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1608693406,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608693406","product_id":100002201,"comment_content":"终于搞明白迭代器的用处。","like_count":0},{"had_liked":false,"id":229596,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1593070342,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1593070342","product_id":100002201,"comment_content":"没有想到 C++ 与我同龄。<br><br>我的 C++ 一直没有长进，大概就是因为没有学会模板 template 的用法，以及没有学过 STL。<br><br>在以前的印象里面，C++ 将面向对象的编程范式实现的很好。从这篇文章来看，C++ 主要还是通过泛型解决 C 语言在编写业务代码时遇到的问题，面向对象似乎并不是重点（所谓面向对象，似乎也主要是针对业务代码而言的）。<br><br>看代码的时候，能够想起来很久以前看过的 C++ Prime，可惜的是没有在实际项目中操练过，以后估计也不会有太多机会。","like_count":0},{"had_liked":false,"id":225224,"user_name":"几度嘟嘟","can_delete":false,"product_type":"c1","uid":1524256,"ip_address":"","ucode":"54DEE1C7252D09","user_header":"https://static001.geekbang.org/account/avatar/00/17/42/20/d195a6db.jpg","comment_is_top":false,"comment_ctime":1591686789,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591686789","product_id":100002201,"comment_content":"请问大佬们泛型和抽象是什么关系呢？","like_count":0},{"had_liked":false,"id":222911,"user_name":"一墨","can_delete":false,"product_type":"c1","uid":2009734,"ip_address":"","ucode":"2EFB72EEC69FE2","user_header":"","comment_is_top":false,"comment_ctime":1590957467,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590957467","product_id":100002201,"comment_content":"纵然已经使用C&#47;C++10年有余, 看到这么清晰的解释, 恍然之间感叹解释者和C++的牛逼. 圈粉皓哥","like_count":0},{"had_liked":false,"id":218863,"user_name":"天草二十六","can_delete":false,"product_type":"c1","uid":1360712,"ip_address":"","ucode":"3165EE3007527B","user_header":"https://static001.geekbang.org/account/avatar/00/14/c3/48/3a739da6.jpg","comment_is_top":false,"comment_ctime":1589888154,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589888154","product_id":100002201,"comment_content":"久违的C plus plus","like_count":0},{"had_liked":false,"id":211715,"user_name":"Edward Lee","can_delete":false,"product_type":"c1","uid":1228518,"ip_address":"","ucode":"156223F1D7E94A","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/e6/7808520d.jpg","comment_is_top":false,"comment_ctime":1587998541,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587998541","product_id":100002201,"comment_content":"看似简单的一个功能函数，从可以用到好用，包含了很多细节和思考","like_count":0},{"had_liked":false,"id":200469,"user_name":"chris","can_delete":false,"product_type":"c1","uid":1109640,"ip_address":"","ucode":"6663E3E09457E3","user_header":"https://static001.geekbang.org/account/avatar/00/10/ee/88/a890b41e.jpg","comment_is_top":false,"comment_ctime":1585592797,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585592797","product_id":100002201,"comment_content":"轻描淡写之间就把复杂的内容讲通透了，大师就是大师！","like_count":0},{"had_liked":false,"id":183068,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1582947616,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582947616","product_id":100002201,"comment_content":"水平不够，看的萌萌懂懂。<br>看着看着其他都没记住，就只意识到，由于数据类型的缘故导致程序的可复用性不高，为了程序的高复用性会导致程序的复杂度急剧上升，为了解决这些问题于是各种语言各显神通C++用泛型的方式来解决，底层代码逻辑只关注算法不关注数据类型和数据结构，把算法逻辑和业务逻辑隔离，是程序抽象层级更高根据通用性。通用的算法应该是具有通用性的，这样对人是更友好的，可以少做重复的事情，提高程序的编辑效率。","like_count":0},{"had_liked":false,"id":179585,"user_name":"奔跑的码仔","can_delete":false,"product_type":"c1","uid":1609871,"ip_address":"","ucode":"AB3B02B07B8B8C","user_header":"https://static001.geekbang.org/account/avatar/00/18/90/8f/9c691a5f.jpg","comment_is_top":false,"comment_ctime":1582034802,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582034802","product_id":100002201,"comment_content":"1.虚函数定义接口，具体类实现该虚函数。用户通过一致的接口完成不同具体类（数据类型）的统一处理（算法）。<br>2.其实，Linux内核设备驱动模型就是根据这一思想实现的，本质上该模型很好的实现了不同具体设备的泛化。<br>3.不管是面向对象编程范式还是Linux内核设备驱动模型，其都实现了不同形式泛化，但，根本都是为了隔离复杂度，简化编程模型。","like_count":0},{"had_liked":false,"id":167185,"user_name":"slark","can_delete":false,"product_type":"c1","uid":1143574,"ip_address":"","ucode":"7E8DE962AA23A7","user_header":"https://static001.geekbang.org/account/avatar/00/11/73/16/595b0342.jpg","comment_is_top":false,"comment_ctime":1577709743,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577709743","product_id":100002201,"comment_content":"C++的范型编程可以说是STL的基础，在前面看过一些，只大概看得懂没有很透彻。到后面看了书多了才知道是范型，是迭代器，是模板。<br>晦涩的代码隐藏了复杂而强大的抽象能力。<br>通过C++的介绍了解要实现这些功能有哪些途径。期待看其他语言会如何能比较简便地实现这些功能。","like_count":0},{"had_liked":false,"id":151264,"user_name":"xdargs","can_delete":false,"product_type":"c1","uid":1063740,"ip_address":"","ucode":"EB8326D3A72DE5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoH9Mlw0kLK0p39vhQpdvkbQP5TX96DB9HMJ1POaTVDpMZg4rjlO3WCAqiaWWMc77ffS3vTo8qWdXA/132","comment_is_top":false,"comment_ctime":1573692726,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1573692726","product_id":100002201,"comment_content":"看代码段，自己对C++里（）重载的应用还要再看下。上礼拜翻译学习97件事里应用函数式编程原理，正好提到函数式编程提升引用透明性的优点","like_count":0},{"had_liked":false,"id":112975,"user_name":"Vance","can_delete":false,"product_type":"c1","uid":1174028,"ip_address":"","ucode":"D9659824312D87","user_header":"https://static001.geekbang.org/account/avatar/00/11/ea/0c/d79ae60d.jpg","comment_is_top":false,"comment_ctime":1562858456,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562858456","product_id":100002201,"comment_content":"学校学过 C 和 C++，后来又还给老师了。。","like_count":0},{"had_liked":false,"id":50827,"user_name":"pain","can_delete":false,"product_type":"c1","uid":1330371,"ip_address":"","ucode":"F75D75EA23D311","user_header":"https://static001.geekbang.org/account/avatar/00/14/4c/c3/398bacb8.jpg","comment_is_top":false,"comment_ctime":1545051131,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545051131","product_id":100002201,"comment_content":"我是半路出家的, 来了发现都看不太懂, 烦恼","like_count":0},{"had_liked":false,"id":15518,"user_name":"宋桓公","can_delete":false,"product_type":"c1","uid":1151948,"ip_address":"","ucode":"04235C2B87AB0E","user_header":"https://static001.geekbang.org/account/avatar/00/11/93/cc/dfe92ee1.jpg","comment_is_top":false,"comment_ctime":1531266847,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1531266847","product_id":100002201,"comment_content":"看了长长的舒口气，终于有点明白了。<br>从c++确实太棒了，迭代器，符号重载，感觉自己又进步一点点，棒棒棒","like_count":0},{"had_liked":false,"id":13520,"user_name":"leon","can_delete":false,"product_type":"c1","uid":1026007,"ip_address":"","ucode":"E79AA801B0D574","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a7/d7/bb0c418a.jpg","comment_is_top":false,"comment_ctime":1529720464,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1529720464","product_id":100002201,"comment_content":"绝对干货","like_count":0},{"had_liked":false,"id":9306,"user_name":"dylan","can_delete":false,"product_type":"c1","uid":1053737,"ip_address":"","ucode":"8A7F72C64F13CA","user_header":"https://static001.geekbang.org/account/avatar/00/10/14/29/58e2ca3a.jpg","comment_is_top":false,"comment_ctime":1526777701,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1526777701","product_id":100002201,"comment_content":"最终泛型 sum 函数貌似缺少相关代码，希望补全～","like_count":0}]}