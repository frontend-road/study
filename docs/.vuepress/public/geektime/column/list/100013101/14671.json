{"id":14671,"title":"12 | 使用函数的正确姿势","content":"<p>在前几期文章中，我们分了几次，把Go语言自身提供的，所有集合类的数据类型都讲了一遍，额外还讲了标准库的<code>container</code>包中的几个类型。</p><p>在几乎所有主流的编程语言中，集合类的数据类型都是最常用和最重要的。我希望通过这几次的讨论，能让你对它们的运用更上一层楼。</p><p>从今天开始，我会开始向你介绍使用Go语言进行模块化编程时，必须了解的知识，这包括几个重要的数据类型以及一些模块化编程的技巧。首先我们需要了解的是Go语言的函数以及函数类型。</p><hr></hr><h3>前导内容：函数是一等的公民</h3><p>在Go语言中，函数可是一等的（first-class）公民，函数类型也是一等的数据类型。这是什么意思呢？</p><p>简单来说，这意味着函数不但可以用于封装代码、分割功能、解耦逻辑，还可以化身为普通的值，在其他函数间传递、赋予变量、做类型判断和转换等等，就像切片和字典的值那样。</p><p>而更深层次的含义就是：函数值可以由此成为能够被随意传播的独立逻辑组件（或者说功能模块）。</p><p>对于函数类型来说，它是一种对一组输入、输出进行模板化的重要工具，它比接口类型更加轻巧、灵活，它的值也借此变成了可被热替换的逻辑组件。比如，我在demo26.go文件中是这样写的：</p><pre><code>package main\n\nimport &quot;fmt&quot;\n\ntype Printer func(contents string) (n int, err error)\n\nfunc printToStd(contents string) (bytesNum int, err error) {\n\treturn fmt.Println(contents)\n}\n\nfunc main() {\n\tvar p Printer\n\tp = printToStd\n\tp(&quot;something&quot;)\n}\n</code></pre><!-- [[[read_end]]] --><p>这里，我先声明了一个函数类型，名叫<code>Printer</code>。</p><p>注意这里的写法，在类型声明的名称右边的是<code>func</code>关键字，我们由此就可知道这是一个函数类型的声明。</p><p>在<code>func</code>右边的就是这个函数类型的参数列表和结果列表。其中，参数列表必须由圆括号包裹，而只要结果列表中只有一个结果声明，并且没有为它命名，我们就可以省略掉外围的圆括号。</p><p>书写函数签名的方式与函数声明的是一致的。只是紧挨在参数列表左边的不是函数名称，而是关键字<code>func</code>。这里函数名称和<code>func</code>互换了一下位置而已。</p><blockquote>\n<p><span class=\"reference\">函数的签名其实就是函数的参数列表和结果列表的统称，它定义了可用来鉴别不同函数的那些特征，同时也定义了我们与函数交互的方式。</span></p>\n</blockquote><p>注意，各个参数和结果的名称不能算作函数签名的一部分，甚至对于结果声明来说，没有名称都可以。</p><p>只要两个函数的参数列表和结果列表中的元素顺序及其类型是一致的，我们就可以说它们是一样的函数，或者说是实现了同一个函数类型的函数。</p><p>严格来说，函数的名称也不能算作函数签名的一部分，它只是我们在调用函数时，需要给定的标识符而已。</p><p>我在下面声明的函数<code>printToStd</code>的签名与<code>Printer</code>的是一致的，因此前者是后者的一个实现，即使它们的名称以及有的结果名称是不同的。</p><p>通过<code>main</code>函数中的代码，我们就可以证实这两者的关系了，我顺利地把<code>printToStd</code>函数赋给了<code>Printer</code>类型的变量<code>p</code>，并且成功地调用了它。</p><p>总之，“函数是一等的公民”是函数式编程（functional programming）的重要特征。Go语言在语言层面支持了函数式编程。我们下面的问题就与此有关。</p><p><strong>今天的问题是：怎样编写高阶函数？</strong></p><p>先来说说什么是高阶函数？简单地说，高阶函数可以满足下面的两个条件：</p><p><strong>1. 接受其他的函数作为参数传入；</strong><br>\n<strong>2. 把其他的函数作为结果返回。</strong></p><p>只要满足了其中任意一个特点，我们就可以说这个函数是一个高阶函数。高阶函数也是函数式编程中的重要概念和特征。</p><p>具体的问题是，我想通过编写<code>calculate</code>函数来实现两个整数间的加减乘除运算，但是希望两个整数和具体的操作都由该函数的调用方给出，那么，这样一个函数应该怎样编写呢。</p><p><strong>典型回答</strong></p><p>首先，我们来声明一个名叫<code>operate</code>的函数类型，它有两个参数和一个结果，都是<code>int</code>类型的。</p><pre><code>type operate func(x, y int) int\n</code></pre><p>然后，我们编写<code>calculate</code>函数的签名部分。这个函数除了需要两个<code>int</code>类型的参数之外，还应该有一个<code>operate</code>类型的参数。</p><p>该函数的结果应该有两个，一个是<code>int</code>类型的，代表真正的操作结果，另一个应该是<code>error</code>类型的，因为如果那个<code>operate</code>类型的参数值为<code>nil</code>，那么就应该直接返回一个错误。</p><blockquote>\n<p><span class=\"reference\">顺便说一下，函数类型属于引用类型，它的值可以为<code>nil</code>，而这种类型的零值恰恰就是<code>nil</code>。</span></p>\n</blockquote><pre><code>func calculate(x int, y int, op operate) (int, error) {\n\tif op == nil {\n\t\treturn 0, errors.New(&quot;invalid operation&quot;)\n\t}\n\treturn op(x, y), nil\n}\n</code></pre><p><code>calculate</code>函数实现起来就很简单了。我们需要先用卫述语句检查一下参数，如果<code>operate</code>类型的参数<code>op</code>为<code>nil</code>，那么就直接返回<code>0</code>和一个代表了具体错误的<code>error</code>类型值。</p><blockquote>\n<p><span class=\"reference\">卫述语句是指被用来检查关键的先决条件的合法性，并在检查未通过的情况下立即终止当前代码块执行的语句。在Go语言中，if 语句常被作为卫述语句。</span></p>\n</blockquote><p>如果检查无误，那么就调用<code>op</code>并把那两个操作数传给它，最后返回<code>op</code>返回的结果和代表没有错误发生的<code>nil</code>。</p><p><strong>问题解析</strong></p><p>其实只要你搞懂了“函数是一等的公民”这句话背后的含义，这道题就会很简单。我在上面已经讲过了，希望你已经清楚了。我在上一个例子中展示了其中一点，即：把函数作为一个普通的值赋给一个变量。</p><p>在这道题中，我问的其实是怎样实现另一点，即：让函数在其他函数间传递。</p><p>在答案中，<code>calculate</code>函数的其中一个参数是<code>operate</code>类型的，而且后者就是一个函数类型。在调用<code>calculate</code>函数的时候，我们需要传入一个<code>operate</code>类型的函数值。这个函数值应该怎么写？</p><p>只要它的签名与<code>operate</code>类型的签名一致，并且实现得当就可以了。我们可以像上一个例子那样先声明好一个函数，再把它赋给一个变量，也可以直接编写一个实现了<code>operate</code>类型的匿名函数。</p><pre><code>op := func(x, y int) int {\n\treturn x + y\n}\n</code></pre><p><code>calculate</code>函数就是一个高阶函数。但是我们说高阶函数的特点有两个，而该函数只展示了其中<strong>一个特点，即：接受其他的函数作为参数传入。</strong></p><p><strong>那另一个特点，把其他的函数作为结果返回。</strong>这又是怎么玩的呢？你可以看看我在demo27.go文件中声明的函数类型<code>calculateFunc</code>和函数<code>genCalculator</code>。其中，<code>genCalculator</code>函数的唯一结果的类型就是<code>calculateFunc</code>。</p><p>这里先给出使用它们的代码。</p><pre><code>x, y = 56, 78\nadd := genCalculator(op)\nresult, err = add(x, y)\nfmt.Printf(&quot;The result: %d (error: %v)\\n&quot;, result, err)\n</code></pre><p>你可以自己写出<code>calculateFunc</code>类型和<code>genCalculator</code>函数的实现吗？你可以动手试一试</p><p><strong>知识扩展</strong></p><p><strong>问题1：如何实现闭包？</strong></p><p>闭包又是什么？你可以想象一下，在一个函数中存在对外来标识符的引用。所谓的外来标识符，既不代表当前函数的任何参数或结果，也不是函数内部声明的，它是直接从外边拿过来的。</p><p>还有个专门的术语称呼它，叫自由变量，可见它代表的肯定是个变量。实际上，如果它是个常量，那也就形成不了闭包了，因为常量是不可变的程序实体，而闭包体现的却是由“不确定”变为“确定”的一个过程。</p><p>我们说的这个函数（以下简称闭包函数）就是因为引用了自由变量，而呈现出了一种“不确定”的状态，也叫“开放”状态。</p><p>也就是说，它的内部逻辑并不是完整的，有一部分逻辑需要这个自由变量参与完成，而后者到底代表了什么在闭包函数被定义的时候却是未知的。</p><p>即使对于像Go语言这种静态类型的编程语言而言，我们在定义闭包函数的时候最多也只能知道自由变量的类型。</p><p>在我们刚刚提到的<code>genCalculator</code>函数内部，实际上就实现了一个闭包，而<code>genCalculator</code>函数也是一个高阶函数。</p><pre><code>func genCalculator(op operate) calculateFunc {\n\treturn func(x int, y int) (int, error) {\n\t\tif op == nil {\n\t\t\treturn 0, errors.New(&quot;invalid operation&quot;)\n\t\t}\n\t\treturn op(x, y), nil\n\t}\n}\n</code></pre><p><code>genCalculator</code>函数只做了一件事，那就是定义一个匿名的、<code>calculateFunc</code>类型的函数并把它作为结果值返回。</p><p>而这个匿名的函数就是一个闭包函数。它里面使用的变量<code>op</code>既不代表它的任何参数或结果也不是它自己声明的，而是定义它的<code>genCalculator</code>函数的参数，所以是一个自由变量。</p><p>这个自由变量究竟代表了什么，这一点并不是在定义这个闭包函数的时候确定的，而是在<code>genCalculator</code>函数被调用的时候确定的。</p><p>只有给定了该函数的参数<code>op</code>，我们才能知道它返回给我们的闭包函数可以用于什么运算。</p><p>看到<code>if op == nil {</code>那一行了吗？Go语言编译器读到这里时会试图去寻找<code>op</code>所代表的东西，它会发现<code>op</code>代表的是<code>genCalculator</code>函数的参数，然后，它会把这两者联系起来。这时可以说，自由变量<code>op</code>被“捕获”了。</p><p>当程序运行到这里的时候，<code>op</code>就是那个参数值了。如此一来，这个闭包函数的状态就由“不确定”变为了“确定”，或者说转到了“闭合”状态，至此也就真正地形成了一个闭包。</p><p>看出来了吗？我们在用高阶函数实现闭包。这也是高阶函数的一大功用。</p><p><img src=\"https://static001.geekbang.org/resource/image/61/08/61f3689a0023e83407ccae081cdd8108.png?wh=1658*818\" alt=\"\"></p><p>（高阶函数与闭包）</p><p>那么，实现闭包的意义又在哪里呢？表面上看，我们只是延迟实现了一部分程序逻辑或功能而已，但实际上，我们是在动态地生成那部分程序逻辑。</p><p>我们可以借此在程序运行的过程中，根据需要生成功能不同的函数，继而影响后续的程序行为。这与GoF设计模式中的“模板方法”模式有着异曲同工之妙，不是吗？</p><p><strong>问题2：传入函数的那些参数值后来怎么样了？</strong></p><p>让我们把目光再次聚焦到函数本身。我们先看一个示例。</p><pre><code>package main\n\nimport &quot;fmt&quot;\n\nfunc main() {\n\tarray1 := [3]string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}\n\tfmt.Printf(&quot;The array: %v\\n&quot;, array1)\n\tarray2 := modifyArray(array1)\n\tfmt.Printf(&quot;The modified array: %v\\n&quot;, array2)\n\tfmt.Printf(&quot;The original array: %v\\n&quot;, array1)\n}\n\nfunc modifyArray(a [3]string) [3]string {\n\ta[1] = &quot;x&quot;\n\treturn a\n}\n</code></pre><p>这个命令源码文件（也就是demo28.go）在运行之后会输出什么？这是我常出的一道考题。</p><p>我在<code>main</code>函数中声明了一个数组<code>array1</code>，然后把它传给了函数<code>modify</code>，<code>modify</code>对参数值稍作修改后将其作为结果值返回。<code>main</code>函数中的代码拿到这个结果之后打印了它（即<code>array2</code>），以及原来的数组<code>array1</code>。关键问题是，原数组会因<code>modify</code>函数对参数值的修改而改变吗？</p><p>答案是：原数组不会改变。为什么呢？原因是，所有传给函数的参数值都会被复制，函数在其内部使用的并不是参数值的原值，而是它的副本。</p><p>由于数组是值类型，所以每一次复制都会拷贝它，以及它的所有元素值。我在<code>modify</code>函数中修改的只是原数组的副本而已，并不会对原数组造成任何影响。</p><p>注意，对于引用类型，比如：切片、字典、通道，像上面那样复制它们的值，只会拷贝它们本身而已，并不会拷贝它们引用的底层数据。也就是说，这时只是浅表复制，而不是深层复制。</p><p>以切片值为例，如此复制的时候，只是拷贝了它指向底层数组中某一个元素的指针，以及它的长度值和容量值，而它的底层数组并不会被拷贝。</p><p>另外还要注意，就算我们传入函数的是一个值类型的参数值，但如果这个参数值中的某个元素是引用类型的，那么我们仍然要小心。</p><p>比如：</p><pre><code>complexArray1 := [3][]string{\n\t[]string{&quot;d&quot;, &quot;e&quot;, &quot;f&quot;},\n\t[]string{&quot;g&quot;, &quot;h&quot;, &quot;i&quot;},\n\t[]string{&quot;j&quot;, &quot;k&quot;, &quot;l&quot;},\n}\n</code></pre><p>变量<code>complexArray1</code>是<code>[3][]string</code>类型的，也就是说，虽然它是一个数组，但是其中的每个元素又都是一个切片。这样一个值被传入函数的话，函数中对该参数值的修改会影响到<code>complexArray1</code>本身吗？我想，这可以留作今天的思考题。</p><p><strong>总结</strong></p><p>我们今天主要聚焦于函数的使用手法。在Go语言中，函数可是一等的（first-class）公民。它既可以被独立声明，也可以被作为普通的值来传递或赋予变量。除此之外，我们还可以在其他函数的内部声明匿名函数并把它直接赋给变量。</p><p>你需要记住Go语言是怎样鉴别一个函数的，函数的签名在这里起到了至关重要的作用。</p><p>函数是Go语言支持函数式编程的主要体现。我们可以通过“把函数传给函数”以及“让函数返回函数”来编写高阶函数，也可以用高阶函数来实现闭包，并以此做到部分程序逻辑的动态生成。</p><p>我们在最后还说了一下关于函数传参的一个注意事项，这很重要，可能会关系到程序的稳定和安全。</p><p>一个相关的原则是：既不要把你程序的细节暴露给外界，也尽量不要让外界的变动影响到你的程序。你可以想想这个原则在这里可以起到怎样的指导作用。</p><p><strong>思考题</strong></p><p>今天我给你留下两道思考题。</p><ol>\n<li><code>complexArray1</code>被传入函数的话，这个函数中对该参数值的修改会影响到它的原值吗？</li>\n<li>函数真正拿到的参数值其实只是它们的副本，那么函数返回给调用方的结果值也会被复制吗？</li>\n</ol><p><a href=\"https://github.com/hyper0x/Golang_Puzzlers\">戳此查看Go语言专栏文章配套详细代码。</a></p><p></p>","neighbors":{"left":{"article_title":"11 | 通道的高级玩法","id":14664},"right":{"article_title":"13 | 结构体及其方法的使用法门","id":18035}},"comments":[{"had_liked":false,"id":23289,"user_name":"深白色","can_delete":false,"product_type":"c1","uid":1123171,"ip_address":"","ucode":"C4B26AB70D8A6D","user_header":"https://static001.geekbang.org/account/avatar/00/11/23/63/4fb6fee0.jpg","comment_is_top":false,"comment_ctime":1536277922,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"370903465378","product_id":100013101,"comment_content":"1.分2种情况，若是修改数组中的切片的某个元素，会影响原数组。若是修改数组的某个元素即a[1]=[]string{&quot;x&quot;}就不会影响原数组。谨记Go中都是浅拷贝，值类型和引用类型的区别<br>2.当函数返回指针类型时不会发生拷贝。当函数返回非指针类型并把结果赋值给其它变量肯定会发生拷贝","like_count":86,"discussions":[{"author":{"id":1351215,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/AyccJq7eg6w3aCn7AxpicdplGhhY2xYOJLd9q2Xcjqxdbb6HO7rU4p37oxCjUnrcydpQVjNgcIhxOLKsI4w2KWQ/132","nickname":"Iflei","note":"","ucode":"812264ADE9CB33","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":76320,"discussion_content":"返回和传参都是要发生拷贝的，指针不也是拷贝的指针变量本身吗，只是没拷贝指针指向的内存数据而已。所以说白了，都会发生值拷贝。","likes_number":21,"is_delete":false,"is_hidden":false,"ctime":1575815485,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1301249,"avatar":"https://static001.geekbang.org/account/avatar/00/13/db/01/d0461b56.jpg","nickname":"李静","note":"","ucode":"A552B816750ECE","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":210785,"discussion_content":"是的，都会发生拷贝，只不过是浅拷贝","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584772597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1260026,"avatar":"https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg","nickname":"安排","note":"","ucode":"F78CFA9624CAEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":129747,"discussion_content":"都是值拷贝","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578734724,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131907,"user_name":"Geek_牛逼的人","can_delete":false,"product_type":"c1","uid":1372129,"ip_address":"","ucode":"0DCE0E4A85311E","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83erOXuR5pJ3zmoyMVRMXTqdYpUnROAnWMXzY8nrs9sderDaEJuSwGGcJTic3quibx9v9xaWDe6oGoyMA/132","comment_is_top":false,"comment_ctime":1567960068,"is_pvip":true,"replies":[{"id":"50625","content":"对的。","user_name":"作者回复","comment_id":131907,"uid":"1026643","ip_address":"","utype":1,"ctime":1568095382,"user_name_real":"郝林"}],"discussion_count":3,"race_medal":0,"score":"285035801604","product_id":100013101,"comment_content":"1.如果是进行一层修改，即数组的某个完整元素进行修改（指针变化），那么原有数组不变；如果进行二层修改，即数组中某个元素切片内的某个元素再进行修改(指针未改变)，那么原有数据也会跟着改变，传参可以理解是浅copy，参数本身的指针是不同，但是元素指针相同，对元素指针所指向目的的操作会影响传参过程中的原始数据；<br>2.一般来说应该是复制的，传参和返回应该是一个对称的过程，本身对这一片内存数据的操作只发生在函数内部，脱离函数就应该脱离这块内存区域","like_count":67,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466675,"discussion_content":"对的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568095382,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2459197,"avatar":"","nickname":"Geek_d09d28","note":"","ucode":"ED7F8E191AD47A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372119,"discussion_content":"如果返回函数内部值类型变量的指针，该指针指向的内存会从函数栈逃逸到堆，对吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620198717,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1351076,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","nickname":"lesserror","note":"","ucode":"25A54D1165FCF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2459197,"avatar":"","nickname":"Geek_d09d28","note":"","ucode":"ED7F8E191AD47A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386476,"discussion_content":"这个问题最后的答案是什么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627608428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":372119,"ip_address":""},"score":386476,"extra":""}]}]},{"had_liked":false,"id":226999,"user_name":"小强","can_delete":false,"product_type":"c1","uid":1149004,"ip_address":"","ucode":"CC3D3A9E5D9A42","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/4c/2c3d2c7d.jpg","comment_is_top":false,"comment_ctime":1592265283,"is_pvip":false,"replies":[{"id":"83656","content":"闭包就像样板代码和模版类型一样，其中先写了一部分代码，并确定了一部分功能。然后，当接到我们输入的参数值之后，它就可以确定另外一部分功能了。或许你可以把闭包看成填空题的题干。<br><br>闭包的存在意思有三：<br><br>1. 提高某个功能的灵活性，可以让使用方提供一部分功能的实现。但却可以控制这一部分的大小。<br>2. 提供动态替换某个功能的部分实现的可能性。这里的关键在于动态。<br>3. 使得代码动态替换的粒度缩小到函数级别。相比之下，模版类型的动态替换粒度是实例级别的。","user_name":"作者回复","comment_id":226999,"uid":"1026643","ip_address":"","utype":1,"ctime":1592294035,"user_name_real":"郝林"}],"discussion_count":3,"race_medal":0,"score":"91786578499","product_id":100013101,"comment_content":"表示看不懂闭包存在的意义，没有例子说明为啥要这玩意","like_count":21,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498450,"discussion_content":"闭包就像样板代码和模版类型一样，其中先写了一部分代码，并确定了一部分功能。然后，当接到我们输入的参数值之后，它就可以确定另外一部分功能了。或许你可以把闭包看成填空题的题干。\n\n闭包的存在意思有三：\n\n1. 提高某个功能的灵活性，可以让使用方提供一部分功能的实现。但却可以控制这一部分的大小。\n2. 提供动态替换某个功能的部分实现的可能性。这里的关键在于动态。\n3. 使得代码动态替换的粒度缩小到函数级别。相比之下，模版类型的动态替换粒度是实例级别的。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1592294035,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1000237,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/43/2d/af86d73f.jpg","nickname":"enjoylearning","note":"","ucode":"DCAF8538DEA277","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590574,"discussion_content":"日志管理，权限检验，接口认证都可以用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665898731,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018685,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/3d/0c3a2fd4.jpg","nickname":"偶尔复活下","note":"","ucode":"18B1D525CD50D3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380050,"discussion_content":"python的装饰器，了解一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624317484,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":23338,"user_name":"melon","can_delete":false,"product_type":"c1","uid":1023773,"ip_address":"","ucode":"7A80C20EBCAAA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9f/1d/ec173090.jpg","comment_is_top":false,"comment_ctime":1536288904,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"53075896456","product_id":100013101,"comment_content":"感觉go里通常写的函数的定义本质上就是一种语法糖形式，比如<br>func test(int)int {<br>\t...<br>}<br>其实质就相当于定义了一个名为test，类型为func(int)int的变量，并给这个变量赋了值为{...}的初值，老师这样理解对吧。","like_count":12,"discussions":[{"author":{"id":1231587,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ca/e3/7e860739.jpg","nickname":"一介农夫","note":"","ucode":"FBDEE48436A542","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5977,"discussion_content":"定义跟声明是不一样的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1566559809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1231587,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ca/e3/7e860739.jpg","nickname":"一介农夫","note":"","ucode":"FBDEE48436A542","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5976,"discussion_content":"定义跟声明是不一样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566559808,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":27384,"user_name":"yandongxiao","can_delete":false,"product_type":"c1","uid":1017700,"ip_address":"","ucode":"D397F4DB0109C8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/64/3882d90d.jpg","comment_is_top":false,"comment_ctime":1537881396,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"35897619764","product_id":100013101,"comment_content":"go语法的一致性很完美。<br><br>[]int{}, map[int]int{} struct{}{} 它们都是由type + literal的形式构成。<br>所以，func (x, y int) int {} 也是function type + function literal的形式。<br>上面的表达式返回已声明并初始化的变量。所以foo := func (x, y int) int {} 就构成了所谓的匿名变量。<br>func Foo(x, y int) int{} 更像是给定义的函数常量，因为Foo不能再被赋予其它值了。<br><br>既然是一等公民，可以声明为变量，那么变量之间就可以比较。","like_count":8,"discussions":[{"author":{"id":1198381,"avatar":"https://static001.geekbang.org/account/avatar/00/12/49/2d/4268ffb7.jpg","nickname":"louis","note":"","ucode":"C8A80284518FF4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553992,"discussion_content":"说的很好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646181786,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1105161,"avatar":"https://static001.geekbang.org/account/avatar/00/10/dd/09/feca820a.jpg","nickname":"helloworld","note":"","ucode":"1EECCA0F43E278","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298608,"discussion_content":"最后一句，函数之间怎么比较？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597341670,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2719667,"avatar":"https://static001.geekbang.org/account/avatar/00/29/7f/b3/e50ec43e.jpg","nickname":"查理安","note":"","ucode":"D9432FE5E2C1AF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1105161,"avatar":"https://static001.geekbang.org/account/avatar/00/10/dd/09/feca820a.jpg","nickname":"helloworld","note":"","ucode":"1EECCA0F43E278","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":410352,"discussion_content":"比较参数和返回值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635670692,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":298608,"ip_address":""},"score":410352,"extra":""},{"author":{"id":1198381,"avatar":"https://static001.geekbang.org/account/avatar/00/12/49/2d/4268ffb7.jpg","nickname":"louis","note":"","ucode":"C8A80284518FF4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2719667,"avatar":"https://static001.geekbang.org/account/avatar/00/29/7f/b3/e50ec43e.jpg","nickname":"查理安","note":"","ucode":"D9432FE5E2C1AF","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":553993,"discussion_content":"签名相同的函数比较是相等的，否则不等","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646181844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":410352,"ip_address":""},"score":553993,"extra":""}]}]},{"had_liked":false,"id":23533,"user_name":"数据小冰","can_delete":false,"product_type":"c1","uid":1136987,"ip_address":"","ucode":"931008A76F3B58","user_header":"https://static001.geekbang.org/account/avatar/00/11/59/5b/dc8ed037.jpg","comment_is_top":false,"comment_ctime":1536469096,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"27306272872","product_id":100013101,"comment_content":"闭包这里为啥不能这样实现呢<br>func  genCalculator(op  operate) calculateFunc{<br>    return  op<br>}","like_count":6,"discussions":[{"author":{"id":1198929,"avatar":"https://static001.geekbang.org/account/avatar/00/12/4b/51/8b0a0f95.jpg","nickname":"熹超","note":"","ucode":"2D162A4AD8D5D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":791,"discussion_content":"这里想引入一个error的变量吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1562060910,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1336951,"avatar":"https://static001.geekbang.org/account/avatar/00/14/66/77/194ba21d.jpg","nickname":"lzh","note":"","ucode":"C3D83DF4230109","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":359151,"discussion_content":"go是强类型语言……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616123345,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1038372,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d8/24/499e7c99.jpg","nickname":"Ckiwis","note":"","ucode":"E59B57FF70650B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":321714,"discussion_content":"看老师代码，calculateFunc 和operate的type 定义是不一样的，calculateFunc多了个error返回，所以不能直接返回op ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604625666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1236766,"avatar":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","nickname":"传说中的成大大","note":"","ucode":"103543D6E706BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":201733,"discussion_content":"我觉得 修改一下calclateFunc的定义 不要err返回值 但是这样写的话我觉得没得必要再用闭包了吧 直接op调用不就行了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583832490,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":28273,"user_name":"TimLiu","can_delete":false,"product_type":"c1","uid":1001911,"ip_address":"","ucode":"CA7BF9E8A432A1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/b7/5bc10d13.jpg","comment_is_top":false,"comment_ctime":1538038447,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18717907631","product_id":100013101,"comment_content":"针对第一个问题，做了下实验，发现如果改变数组中的元素时是不会改变源数组的，当改变数组中的切片中的元素时是会改变源数组的，我猜是因为切片改变元素时底层数组会改变，所以源数组也跟着改变<br><br>package main<br><br>import &quot;fmt&quot;<br><br>func main() {<br>\tcomplexArray1 := [3][]string{<br>\t\t[]string{&quot;d&quot;, &quot;e&quot;, &quot;f&quot;},<br>\t\t[]string{&quot;g&quot;, &quot;h&quot;, &quot;i&quot;},<br>\t\t[]string{&quot;j&quot;, &quot;k&quot;, &quot;l&quot;},<br>\t}<br><br>\tfmt.Printf(&quot;The array: %v\\n&quot;, complexArray1)<br>\tarray2 := modifyArray(complexArray1)<br>\tfmt.Printf(&quot;The modified array: %v\\n&quot;, array2)<br>\tfmt.Printf(&quot;The original array: %v\\n&quot;, complexArray1)<br>\tarray3 := modifyArray1(complexArray1)<br>\tfmt.Printf(&quot;The modified array: %v\\n&quot;, array3)<br>\tfmt.Printf(&quot;The original array: %v\\n&quot;, complexArray1)<br>}<br><br>func modifyArray(a [3][]string) [3][]string {<br>\ta[1] = []string{&quot;d&quot;, &quot;e&quot;, &quot;p&quot;}<br>\treturn a<br>}<br><br>func modifyArray1(a [3][]string) [3][]string {<br>\ta[1][1] = &quot;v&quot;<br>\treturn a<br>}<br>","like_count":4},{"had_liked":false,"id":23409,"user_name":"RyuGou","can_delete":false,"product_type":"c1","uid":1200793,"ip_address":"","ucode":"8D424CB6005DD7","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/99/4a7f2fc9.jpg","comment_is_top":false,"comment_ctime":1536335742,"is_pvip":false,"replies":[{"id":"8486","content":"因为数组的每个元素也会被复制，你这样赋值只会改变数组副本中的一个元素值而已。你直接改其中的切片的元素值就会影响到外边了。","user_name":"作者回复","comment_id":23409,"uid":"1026643","ip_address":"","utype":1,"ctime":1536385916,"user_name_real":"郝林"}],"discussion_count":1,"race_medal":0,"score":"18716204926","product_id":100013101,"comment_content":"第一道题，显然是不会造成原来内容的修改呀<br>package main<br><br>import &quot;fmt&quot;<br><br>func main(){<br>\tcomplexArray := [3][]string{<br>\t\t[]string{&quot;d&quot;, &quot;s&quot;, &quot;f&quot;},<br>\t\t[]string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;},<br>\t\t[]string{&quot;e&quot;, &quot;g&quot;, &quot;h&quot;},<br>\t}<br>\ttryTest(complexArray)<br>\tfmt.Println(complexArray)<br>}<br><br><br>func tryTest(array [3][]string){<br>\tarray[1] = []string{&quot;1&quot;, &quot;2&quot;, &quot;3&quot;}<br>\treturn<br>}<br>输出：<br>[[d s f] [a b c] [e g h]]","like_count":4,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423551,"discussion_content":"因为数组的每个元素也会被复制，你这样赋值只会改变数组副本中的一个元素值而已。你直接改其中的切片的元素值就会影响到外边了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1536385916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164445,"user_name":"lixiaofeng","can_delete":false,"product_type":"c1","uid":1100200,"ip_address":"","ucode":"0D6710D95B6FFB","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/a8/98507423.jpg","comment_is_top":false,"comment_ctime":1576993840,"is_pvip":false,"replies":[{"id":"62469","content":"嗯，总结得挺好的。严格来说不能算是化身，因为函数本来就是值。另外我鸡蛋里挑个骨头，是“高阶函数”。：）","user_name":"作者回复","comment_id":164445,"uid":"1026643","ip_address":"","utype":1,"ctime":1577010935,"user_name_real":"郝林"}],"discussion_count":1,"race_medal":0,"score":"14461895728","product_id":100013101,"comment_content":"总结<br>函数不仅能够封装代码，分割功能，解耦逻辑；还可以化身为普通的值，在函数之间传递，赋予变量，判断转换等<br>函数值可以成为能够被随意传播的独立逻辑组件（功能模块）<br>只要两个函数的参数列表和结果列表元素顺序及类型是一致的，我们就说他们是一样的函数（实现了相同函数类型的函数）<br>函数类型是引用类型<br>高姐函数： 把函数作为参数值传递 或者 函数的返回值是一个函数","like_count":3,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478771,"discussion_content":"嗯，总结得挺好的。严格来说不能算是化身，因为函数本来就是值。另外我鸡蛋里挑个骨头，是“高阶函数”。：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577010935,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122743,"user_name":"🐶","can_delete":false,"product_type":"c1","uid":1459980,"ip_address":"","ucode":"D9E46DDB64BA77","user_header":"https://static001.geekbang.org/account/avatar/00/16/47/0c/f2f0245e.jpg","comment_is_top":false,"comment_ctime":1565510802,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14450412690","product_id":100013101,"comment_content":"深白色说的很对！作为切片的话，将会影响原数组，毕竟我们知道切片的数据是通过指向地址取值，而函数进行对原数组修改，只是先拷贝一份，然后再修改，根本修改不到原数组。<br>函数返回指针类型，的确不会发生拷贝，但是也是将指针值拷贝了，再返回，所以其实深究，还是有拷贝在里面的，若是返回非指针类型的结果，一定会发生拷贝。<br>go没有引用传递，只有值传递，所以基本上都是值拷贝。","like_count":3},{"had_liked":false,"id":23334,"user_name":"兔子高","can_delete":false,"product_type":"c1","uid":1213534,"ip_address":"","ucode":"4F710AD87D3B21","user_header":"https://static001.geekbang.org/account/avatar/00/12/84/5e/79568644.jpg","comment_is_top":false,"comment_ctime":1536287750,"is_pvip":false,"replies":[{"id":"8488","content":"Go的泛型几年后才会推出，现在没必要讲啊。","user_name":"作者回复","comment_id":23334,"uid":"1026643","ip_address":"","utype":1,"ctime":1536386096,"user_name_real":"郝林"}],"discussion_count":1,"race_medal":0,"score":"14421189638","product_id":100013101,"comment_content":"哈喽老师你好，我学go的反射是学的最乱的，反射可以拿到您好好讲一讲吗？然后最近看到了go新出的法案里说go 2.0会出泛型有考虑讲一下go的泛型吗？","like_count":3,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":423520,"discussion_content":"Go的泛型几年后才会推出，现在没必要讲啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1536386096,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":51033,"user_name":"hiyanxu","can_delete":false,"product_type":"c1","uid":1221750,"ip_address":"","ucode":"FA46A318154812","user_header":"https://static001.geekbang.org/account/avatar/00/12/a4/76/585dc6b3.jpg","comment_is_top":false,"comment_ctime":1545102222,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10135036814","product_id":100013101,"comment_content":"老师好，我想问一下，函数类型也是引用类型吧。<br>因为我测试看当将一个函数类型的值作为参数传入的时候，参数外和参数内函数值的地址是一样的","like_count":2},{"had_liked":false,"id":23470,"user_name":"王腾飞","can_delete":false,"product_type":"c1","uid":1035111,"ip_address":"","ucode":"6D4F81620470E2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cb/67/5a3f9ae8.jpg","comment_is_top":false,"comment_ctime":1536394809,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10126329401","product_id":100013101,"comment_content":"关于闭包，函数内修改外部变量会有什么效果呢？假设一个高阶函数返回了两个闭包函数，其中一个函数修改了外部变量的值，那这个变化会传递到另一个函数中吗？","like_count":2,"discussions":[{"author":{"id":1019568,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8e/b0/ef201991.jpg","nickname":"CcczzZ","note":"","ucode":"5F46DA5053D2BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":109529,"discussion_content":"理解了下面这个规则就能回答问题了。\n变量作为函数参数的情况，区分变量的类型，是值类型（数组，普通变量，结构体等），还是引用类型（切片，map）。\n\n值类型作为函数参数是传递的副本，在函数内修改变量并不为影响外层变量；\n而引用类型作为函数参数传递的是指针，在函数内部对值做了修改，原值都是会被修改。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577700057,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1447220,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLia2EwyyEVs3tWRnMlqaAG7R7HvlW4vGvxthKsicgsCEeXO1qL7mMy6GAzgdkSKcH3c70Qa2hY3JLw/132","nickname":"沐夜星光","note":"","ucode":"22F699E237B179","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":266502,"discussion_content":"问题是，自由变量不是函数参数呀。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589524030,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":277512,"user_name":"曾泽浩","can_delete":false,"product_type":"c1","uid":1104601,"ip_address":"","ucode":"A7E5CF9E1571A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/da/d9/f051962f.jpg","comment_is_top":false,"comment_ctime":1612438775,"is_pvip":false,"replies":[{"id":"100847","content":"Java官方不是说Lambda就相当于闭包吗？","user_name":"作者回复","comment_id":277512,"uid":"1026643","ip_address":"","utype":1,"ctime":1612676757,"user_name_real":"郝林"}],"discussion_count":1,"race_medal":0,"score":"5907406071","product_id":100013101,"comment_content":"闭包函数跟Java中的lambda表达式是同个意思吗？","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515076,"discussion_content":"Java官方不是说Lambda就相当于闭包吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612676757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":260364,"user_name":"甜质粥","can_delete":false,"product_type":"c1","uid":2153136,"ip_address":"","ucode":"696E929660A124","user_header":"https://static001.geekbang.org/account/avatar/00/20/da/b0/a2425eca.jpg","comment_is_top":false,"comment_ctime":1604992626,"is_pvip":false,"replies":[{"id":"94550","content":"在很多编程语言里都这么叫啊，这已经是一个约定俗成的中文称呼了。","user_name":"作者回复","comment_id":260364,"uid":"1026643","ip_address":"","utype":1,"ctime":1605004394,"user_name_real":"郝林"}],"discussion_count":1,"race_medal":0,"score":"5899959922","product_id":100013101,"comment_content":"老师，您把first class翻译成了“一等公民”，让人更加误解了，不如直接就称呼为first class，比如这个：https:&#47;&#47;golangbot.com&#47;first-class-functions&#47;","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509177,"discussion_content":"在很多编程语言里都这么叫啊，这已经是一个约定俗成的中文称呼了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605004394,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":69008,"user_name":"Yayu","can_delete":false,"product_type":"c1","uid":1058015,"ip_address":"","ucode":"5E7842458D8229","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/df/645f8087.jpg","comment_is_top":false,"comment_ctime":1550644368,"is_pvip":false,"replies":[{"id":"25262","content":"把检查代码封装到结构体的方法中，或者统一到某一个检查专用的程序实体中。","user_name":"作者回复","comment_id":69008,"uid":"1026643","ip_address":"","utype":1,"ctime":1551184309,"user_name_real":"郝林"}],"discussion_count":1,"race_medal":0,"score":"5845611664","product_id":100013101,"comment_content":"请教老师一个关于控制算法相关的内容。本文中提及的卫述语句，经常会在诸如参数检查的时候使用，如果我业务逻辑代码模块中有很多函数，每个函数的参数是个名为 xxrRequest 的结构体，那么我就要在每个函数里写大段大段的卫戍语句。有什么可行的办法可以优化这种写法吗？","like_count":1,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":439910,"discussion_content":"把检查代码封装到结构体的方法中，或者统一到某一个检查专用的程序实体中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551184309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":23290,"user_name":"benben","can_delete":false,"product_type":"c1","uid":1222193,"ip_address":"","ucode":"A861DEB5A88AA2","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/mWicFKgbjL299CQPEhoFdSLGvibCiaXeZo2EjV1hDLicPxicyRTWCODxeYwq8eBgxU6zUuU6rrIw3d7hGwFmRflicibHA/132","comment_is_top":false,"comment_ctime":1536277925,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5831245221","product_id":100013101,"comment_content":"第一个问题应该会受影响，因为数组元素是切片<br>第二问题我想应该是复制的","like_count":1},{"had_liked":false,"id":23287,"user_name":"benben","can_delete":false,"product_type":"c1","uid":1222193,"ip_address":"","ucode":"A861DEB5A88AA2","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/mWicFKgbjL299CQPEhoFdSLGvibCiaXeZo2EjV1hDLicPxicyRTWCODxeYwq8eBgxU6zUuU6rrIw3d7hGwFmRflicibHA/132","comment_is_top":false,"comment_ctime":1536277712,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5831245008","product_id":100013101,"comment_content":"第一个问题应该会受影响，因为切片是引用类型的<br>第二个问题我想是复制的","like_count":1},{"had_liked":false,"id":359787,"user_name":"enjoylearning","can_delete":false,"product_type":"c1","uid":1000237,"ip_address":"北京","ucode":"DCAF8538DEA277","user_header":"https://static001.geekbang.org/account/avatar/00/0f/43/2d/af86d73f.jpg","comment_is_top":false,"comment_ctime":1665898671,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665898671","product_id":100013101,"comment_content":"闭包用于记录日志和权限检验，可以大大优化","like_count":0},{"had_liked":false,"id":328370,"user_name":"Ilovek8s","can_delete":false,"product_type":"c1","uid":1542450,"ip_address":"","ucode":"64DF0F7D0CF0B0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/a8PMLmCTCBa40j7JIy3d8LsdbW5hne7lkk9KOGQuiaeVk4cn06KWwlP3ic69BsQLpNFtRTjRdUM2ySDBAv1MOFfA/132","comment_is_top":false,"comment_ctime":1640693832,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640693832","product_id":100013101,"comment_content":"思考题的使用代码运算之后发现，一旦修改某个数据中的值，源数据也改，目标数据也改了。","like_count":0},{"had_liked":false,"id":327145,"user_name":"Geek_4becf0","can_delete":false,"product_type":"c1","uid":2444747,"ip_address":"","ucode":"6A96BA0C4B3B64","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIWjdabiaIH7VxjUng9qpJssODr4b7icib0EJsuGhib7Nls1eBnUrEDAPfXXlsL5OjjfwXH84RuWyCn5w/132","comment_is_top":false,"comment_ctime":1639960169,"is_pvip":true,"replies":[{"id":"119016","content":"自由变量肯定会被复制到堆上一份，因为它发生逃逸了（跨函数引用问题）。","user_name":"作者回复","user_name_real":"编辑","uid":"1026643","ctime":1639985125,"ip_address":"","comment_id":327145,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1639960169","product_id":100013101,"comment_content":"老师请问 闭包所引用的自由变量，在确定后，也发生了拷贝吧，就是闭包外的函数调用完成，释放内存会把参数释放掉，但闭包引用了该参数，所以需要拷贝一份？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540191,"discussion_content":"自由变量肯定会被复制到堆上一份，因为它发生逃逸了（跨函数引用问题）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639985125,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":326831,"user_name":"非洲铜","can_delete":false,"product_type":"c1","uid":1122120,"ip_address":"","ucode":"FD57F4EB741033","user_header":"https://static001.geekbang.org/account/avatar/00/11/1f/48/4bf434ef.jpg","comment_is_top":false,"comment_ctime":1639713634,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639713634","product_id":100013101,"comment_content":"只要两个函数的参数列表和结果列表中的元素顺序及其类型是一致的，我们就可以说它们是一样的函数，或者说是实现了同一个函数类型的函数。<br><br>感觉这句话不够严谨，不能说他们是一样的函数，应该说是属于同一个函数类型，或者说同一个函数类型的两个实现。","like_count":0},{"had_liked":false,"id":288735,"user_name":"Darricklin","can_delete":false,"product_type":"c1","uid":1531572,"ip_address":"","ucode":"149C383DB03136","user_header":"https://static001.geekbang.org/account/avatar/00/17/5e/b4/2e8bcd53.jpg","comment_is_top":false,"comment_ctime":1618646869,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618646869","product_id":100013101,"comment_content":"这个闭包讲的很通透，和python的装饰器原理一致的。","like_count":0},{"had_liked":false,"id":268611,"user_name":"王木杉","can_delete":false,"product_type":"c1","uid":1628501,"ip_address":"","ucode":"712288EE2A3F4B","user_header":"https://static001.geekbang.org/account/avatar/00/18/d9/55/bd65c4df.jpg","comment_is_top":false,"comment_ctime":1608273165,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608273165","product_id":100013101,"comment_content":"咨询下闭包的原理，是否需要在堆里保存闭包中的自由变量的信息。编译阶段是否知道，分配堆或栈上面。--gcflags=&quot;-m &quot; 可否给个逃逸分析的事例。","like_count":0},{"had_liked":false,"id":257377,"user_name":"Terence孫","can_delete":false,"product_type":"c1","uid":1157674,"ip_address":"","ucode":"8C3A89C18A2182","user_header":"https://static001.geekbang.org/account/avatar/00/11/aa/2a/ce7c487d.jpg","comment_is_top":false,"comment_ctime":1603951311,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603951311","product_id":100013101,"comment_content":"老师对于知识理解很深刻，只是表述上可能不是很容易理解，不过耐心吃透后，你会发现这是道和术的区别","like_count":0},{"had_liked":false,"id":253425,"user_name":"苏格拉没底","can_delete":false,"product_type":"c1","uid":1476300,"ip_address":"","ucode":"282B56405AE1B9","user_header":"https://static001.geekbang.org/account/avatar/00/16/86/cc/d63bb0f2.jpg","comment_is_top":false,"comment_ctime":1602734323,"is_pvip":false,"replies":[{"id":"92569","content":"看清楚啊，genCalculator 函数会 return 一个函数，这个函数的签名是 func(x int, y int) (int, error) ，符合 calculateFunc 的定义：<br><br>type calculateFunc func(x int, y int) (int, error)<br><br>那个 return 语句“return op(x, y), nil” 是 genCalculator 函数里边的匿名函数 func(x int, y int) (int, error) 中的语句。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1602741319,"ip_address":"","comment_id":253425,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1602734323","product_id":100013101,"comment_content":"郝老师，请教一下：<br><br>func genCalculator(op operate) calculateFunc {<br>  return func(x int, y int) (int, error) {<br>    if op == nil {<br>      return 0, errors.New(&quot;invalid operation&quot;)<br>    }<br>    return op(x, y), nil<br>  }<br>}<br>这个高阶函数返回的是calculateFunc这个函数类型，但return返回的是：return x,nil 这个与定义的返回不相符呀？但还跑成功了，这是为什么？<br>","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507067,"discussion_content":"看清楚啊，genCalculator 函数会 return 一个函数，这个函数的签名是 func(x int, y int) (int, error) ，符合 calculateFunc 的定义：\n\ntype calculateFunc func(x int, y int) (int, error)\n\n那个 return 语句“return op(x, y), nil” 是 genCalculator 函数里边的匿名函数 func(x int, y int) (int, error) 中的语句。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602741319,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":237723,"user_name":"fmouse","can_delete":false,"product_type":"c1","uid":1202325,"ip_address":"","ucode":"9A8858CFFAB858","user_header":"https://static001.geekbang.org/account/avatar/00/12/58/95/640b6465.jpg","comment_is_top":false,"comment_ctime":1595936005,"is_pvip":false,"replies":[{"id":"87864","content":"这个需要具体情况具体分析啊，你可以来段代码，我给你说一下。<br><br>一个原则是：只要指针类的变量跨函数了，就会被分派到堆上；值类的变量跨函数会被拷贝。<br><br>我没明白你说的“这个变量会不会被覆盖”的意思。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1595995462,"ip_address":"","comment_id":237723,"utype":1}],"discussion_count":3,"race_medal":2,"score":"1595936005","product_id":100013101,"comment_content":"老师，能不能讲下闭包的调用栈，还有内部函数中引用外部变量，这个内部函数作为参数传到其他函数中时，这个变量会不会被覆盖，底层堆和栈又是怎么样的。","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502517,"discussion_content":"这个需要具体情况具体分析啊，你可以来段代码，我给你说一下。\n\n一个原则是：只要指针类的变量跨函数了，就会被分派到堆上；值类的变量跨函数会被拷贝。\n\n我没明白你说的“这个变量会不会被覆盖”的意思。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595995462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1202325,"avatar":"https://static001.geekbang.org/account/avatar/00/12/58/95/640b6465.jpg","nickname":"fmouse","note":"","ucode":"9A8858CFFAB858","race_medal":2,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294867,"discussion_content":"第一个问题，findPtr函数里面的Callers没看明白，自己也不确定，然后动手测试了下。\n第二个问题，如果在_m函数里面又声明了一个ptr变量，会被赋值吗，对原来的ptr有没有影响。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596018598,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1202325,"avatar":"https://static001.geekbang.org/account/avatar/00/12/58/95/640b6465.jpg","nickname":"fmouse","note":"","ucode":"9A8858CFFAB858","race_medal":2,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294864,"discussion_content":"var (\n    findPtr = func() uintptr {\n        var pc [1]uintptr\n        n := runtime.Callers(4, pc[:])\n        if n != 1 {\n            panic(&#34;failed to find function pointer&#34;)\n        }\n        return pc[0]\n    }\n    pc_lookup   = make(map[uintptr]int8, 17)\n    mark_lookup [16]func(uint, func())\n)\n\nfunc init() {\n    setEntries := func(f func(uint, func()), v int8) {\n        var ptr uintptr\n        f(0, func() {\n            ptr = findPtr()\n        })\n        pc_lookup[ptr] = v\n        if v >= 0 {\n            mark_lookup[v] = f\n        }\n    }\n    setEntries(github_com_jtolds_gls_markS, -0x1)\n    setEntries(github_com_jtolds_gls_mark0, 0x0)\n    setEntries(github_com_jtolds_gls_mark1, 0x1)\n    setEntries(github_com_jtolds_gls_mark2, 0x2)\n    setEntries(github_com_jtolds_gls_mark3, 0x3)\n    setEntries(github_com_jtolds_gls_mark4, 0x4)\n    setEntries(github_com_jtolds_gls_mark5, 0x5)\n    setEntries(github_com_jtolds_gls_mark6, 0x6)\n    setEntries(github_com_jtolds_gls_mark7, 0x7)\n    setEntries(github_com_jtolds_gls_mark8, 0x8)\n    setEntries(github_com_jtolds_gls_mark9, 0x9)\n    setEntries(github_com_jtolds_gls_markA, 0xa)\n    setEntries(github_com_jtolds_gls_markB, 0xb)\n    setEntries(github_com_jtolds_gls_markC, 0xc)\n    setEntries(github_com_jtolds_gls_markD, 0xd)\n    setEntries(github_com_jtolds_gls_markE, 0xe)\n    setEntries(github_com_jtolds_gls_markF, 0xf)\n}\n\n//go:noinline\nfunc github_com_jtolds_gls_markS(tag uint, cb func()) { _m(tag, cb) }\n\n//go:noinline\nfunc github_com_jtolds_gls_mark0(tag uint, cb func()) { _m(tag, cb) }\n\nfunc _m(tag_remainder uint, cb func()) {\n    if tag_remainder == 0 {\n        cb()\n    } else {\n        mark_lookup[tag_remainder&amp;0xf](tag_remainder>>bitWidth, cb)\n    }\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596018174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":201338,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1217554,"ip_address":"","ucode":"C5A540BC5A60B9","user_header":"https://static001.geekbang.org/account/avatar/00/12/94/12/15558f28.jpg","comment_is_top":false,"comment_ctime":1585753174,"is_pvip":false,"replies":[{"id":"75604","content":"基础概念都差不多，只是各个语言的实现方式不同而已。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1585990449,"ip_address":"","comment_id":201338,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585753174","product_id":100013101,"comment_content":"其实go函数的闭包就是c＋＋里的lambda表达式，而高阶函数里的参数其实就是被lambda捕获的变量，只是c＋＋里可以指定是值捕获还是引用捕获","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490304,"discussion_content":"基础概念都差不多，只是各个语言的实现方式不同而已。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585990449,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":189876,"user_name":"Cyril","can_delete":false,"product_type":"c1","uid":1024693,"ip_address":"","ucode":"29FFFAC32F911B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a2/b5/4dc0c109.jpg","comment_is_top":false,"comment_ctime":1584579233,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584579233","product_id":100013101,"comment_content":"go没有深拷贝，函数是一等公民","like_count":0},{"had_liked":false,"id":186382,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1583832290,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583832290","product_id":100013101,"comment_content":"那实际上 引用类型的传递其实也是一个浅拷贝  它自身和他指向底层的某个元素的指针 长度已经容量","like_count":0},{"had_liked":false,"id":186381,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1583832221,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583832221","product_id":100013101,"comment_content":"关于第1问 运行了demon28过后发现 关于complexArray1 因为是数组 它肯定是拷贝 但是又由于底层是切片是引用类型(切片、字典、通道) 所以会拷贝他们本身但是不会拷贝他们底层的数组 但是切片拷贝的指向底层数组某个元素的指针 长度和容量  所以 如果修改了具体某个切片元素的某一个值 比如a[1][1]这种就会修改 如果是没有修改切片的内容 则不会影响","like_count":0},{"had_liked":false,"id":186354,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1583829549,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583829549","product_id":100013101,"comment_content":"今天关于函数的总结<br>1. go语言是支持函数式编程的 所以函数也可以成为一个类型<br>   所以只要两个函数的函数签名相同 那么他们就是一个类型的函数 <br>   所谓的函数签名 就是函数的参数列表 结果列表(返回值列表)<br>2. 高阶函数和闭包<br>   所谓闭包就是一个函数体内部引用了一个外部的变量<br>   高阶函数和函数式编程的特点就是 支持函数作为参数或者返回值<br>3. 参数传递过程中值传递和引用传递的问题<br>   我记得前面讲过 到底是值传递还是引用传递取决于参数的实际类型<br>思考题<br>1. 切片 引用类型 而且传递的时候传递了底层数组的某个元素的指针 长度 和容量 所以如果要修改了参数 则肯定会修改<br>2. 肯定也是复制  不然cpp也不会出现臭名昭昭的 临时对象问题","like_count":0},{"had_liked":false,"id":155902,"user_name":"疯琴","can_delete":false,"product_type":"c1","uid":1099379,"ip_address":"","ucode":"82ACAA4A27753D","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/73/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1574776703,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574776703","product_id":100013101,"comment_content":"闭包讲得太牛B了，毕生看过最透彻的讲解。","like_count":0},{"had_liked":false,"id":131620,"user_name":"panda199393","can_delete":false,"product_type":"c1","uid":1621850,"ip_address":"","ucode":"C09797AE30157C","user_header":"","comment_is_top":false,"comment_ctime":1567826450,"is_pvip":false,"replies":[{"id":"50355","content":"差不多，都属于闭包。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1567915401,"ip_address":"","comment_id":131620,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567826450","product_id":100013101,"comment_content":"看到genCalculator那块的时候刚我想到了python里面的decorator，也是将某个函数作为参数，套到定义好的模板函数里","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466542,"discussion_content":"差不多，都属于闭包。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567915401,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":96428,"user_name":"窝窝头","can_delete":false,"product_type":"c1","uid":1063866,"ip_address":"","ucode":"5C2635ED6484F8","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/ba/3b30dcde.jpg","comment_is_top":false,"comment_ctime":1558420580,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1558420580","product_id":100013101,"comment_content":"1.如果修改complexArray1里面的元素不影响原值，如果对元素里面的元素进行修改会影响原值<br>2.函数返回给调用方的结果值如果是指针不会拷贝，如果非指针应该会拷贝","like_count":0},{"had_liked":false,"id":75803,"user_name":"Aliliin","can_delete":false,"product_type":"c1","uid":1025239,"ip_address":"","ucode":"61F9A09BB6650F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a4/d7/5d2bfaa7.jpg","comment_is_top":false,"comment_ctime":1552472750,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552472750","product_id":100013101,"comment_content":"改变数组中切片的某个元素的话, 原来的数组值会影响原值 .代码如下<br><br>func TestComplexAreray(t *testing.T) {<br><br>\tcomplexArray := [3][]string{<br>\t\t[]string{&quot;d&quot;, &quot;e&quot;, &quot;f&quot;},<br>\t\t[]string{&quot;g&quot;, &quot;h&quot;, &quot;i&quot;},<br>\t\t[]string{&quot;j&quot;, &quot;k&quot;, &quot;l&quot;},<br>\t}<br>\tComplexAreray(complexArray)<br>\tt.Log(complexArray)<br>}<br><br>func ComplexAreray(array [3][]string) {<br>\tfor _, v := range array {<br>\t\tv[0] = &quot;aaa&quot;<br>\t}<br>\treturn<br>}<br>‘<br>输出为 : [[aaa e f] [aaa h i] [aaa k l]]","like_count":0},{"had_liked":false,"id":75801,"user_name":"Aliliin","can_delete":false,"product_type":"c1","uid":1025239,"ip_address":"","ucode":"61F9A09BB6650F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a4/d7/5d2bfaa7.jpg","comment_is_top":false,"comment_ctime":1552471971,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552471971","product_id":100013101,"comment_content":"genCalculator 的实现如下<br><br>type operate func(x, y int) int<br>type calculator func(x, y int) (int, error)<br><br>func genCalculator(op operate) calculator {<br>    return func(x, y int) (int, error) {<br>        if op == nil {<br>            return 0, errors.New(&quot;Invalid operation&quot;)<br>        }<br>        return op(x, y), nil<br>    }<br><br>}<br>func TestFunc(t *testing.T) {<br>    op := func(x, y int) int {<br>        return x + y<br>    }<br>    add := genCalculator(op)<br>    x, y := 56, 78<br>    result, err := add(x, y)<br>    fmt.Printf(&quot;The result: %d (error: %v)\\n&quot;, result, err)<br>}","like_count":0},{"had_liked":false,"id":75389,"user_name":"轻装渐行","can_delete":false,"product_type":"c1","uid":1200094,"ip_address":"","ucode":"A7AEE8CB2C0853","user_header":"https://static001.geekbang.org/account/avatar/00/12/4f/de/b4ca75e0.jpg","comment_is_top":false,"comment_ctime":1552388471,"is_pvip":false,"replies":[{"id":"28887","content":"你可以看一下标准库中的testing包。后面会讲到这个。","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1553399971,"ip_address":"","comment_id":75389,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1552388471","product_id":100013101,"comment_content":"老师好，请问下，Go一般用什么框架做单元测试呢？","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":442878,"discussion_content":"你可以看一下标准库中的testing包。后面会讲到这个。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553399971,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":60346,"user_name":"yann [扬] :曹同学","can_delete":false,"product_type":"c1","uid":1199315,"ip_address":"","ucode":"C449253263E796","user_header":"https://static001.geekbang.org/account/avatar/00/12/4c/d3/365fe5a1.jpg","comment_is_top":false,"comment_ctime":1547460057,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547460057","product_id":100013101,"comment_content":"以前看好像没图呢,惊喜","like_count":0},{"had_liked":false,"id":53101,"user_name":"虢國技醬","can_delete":false,"product_type":"c1","uid":1056807,"ip_address":"","ucode":"5A192262AA037E","user_header":"https://static001.geekbang.org/account/avatar/00/10/20/27/a6932fbe.jpg","comment_is_top":false,"comment_ctime":1545584219,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545584219","product_id":100013101,"comment_content":"打卡<br>1问题：对于切片、映射map、通道channel这三中引用类型，无论藏得多深，他们都是浅拷贝，即只拷贝了指向底层存储内存的指针<br>2问题：对于返回的结果，也是要区分对待值类型和引用类型","like_count":0},{"had_liked":false,"id":52755,"user_name":"虢國技醬","can_delete":false,"product_type":"c1","uid":1056807,"ip_address":"","ucode":"5A192262AA037E","user_header":"https://static001.geekbang.org/account/avatar/00/10/20/27/a6932fbe.jpg","comment_is_top":false,"comment_ctime":1545496876,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545496876","product_id":100013101,"comment_content":"打卡干货👊","like_count":0},{"had_liked":false,"id":28675,"user_name":"任性😀","can_delete":false,"product_type":"c1","uid":1209711,"ip_address":"","ucode":"F80DB5E6896105","user_header":"https://static001.geekbang.org/account/avatar/00/12/75/6f/8a6e0a14.jpg","comment_is_top":false,"comment_ctime":1538125192,"is_pvip":false,"replies":[{"id":"10646","content":"第二个问题是，从函数返回的结果值会被复制吗？比如你传出去一个数组，它还会是函数中的那个数组吗？","user_name":"作者回复","user_name_real":"郝林","uid":"1026643","ctime":1538452382,"ip_address":"","comment_id":28675,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1538125192","product_id":100013101,"comment_content":"1：第一个问题，如果修改了引用类型的值会受影响<br>2: 没有看懂","like_count":0,"discussions":[{"author":{"id":1026643,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/53/768aec0a.jpg","nickname":"郝林","note":"","ucode":"F66BA62BA56FFA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425345,"discussion_content":"第二个问题是，从函数返回的结果值会被复制吗？比如你传出去一个数组，它还会是函数中的那个数组吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538452382,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":27778,"user_name":"小杰控","can_delete":false,"product_type":"c1","uid":1152822,"ip_address":"","ucode":"0E5AA624F5CD52","user_header":"https://static001.geekbang.org/account/avatar/00/11/97/36/ee863508.jpg","comment_is_top":false,"comment_ctime":1537942625,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1537942625","product_id":100013101,"comment_content":"我对于问题一的理解在这段代码里：<br>func modifyArray(arr [3][]string) [3][]string {<br>        arr[1] = []string{&quot;x&quot;, &quot;x&quot;, &quot;x&quot;}<br>        return arr<br>}<br><br>func modifyArray2(arr [3][]string) [3][]string {<br>        arr[1][1] = &quot;x&quot;<br>        return arr<br>}<br><br>func main() {<br>        complexArray1 := [3][]string{<br>                []string{&quot;d&quot;, &quot;e&quot;, &quot;f&quot;},<br>                []string{&quot;g&quot;, &quot;h&quot;, &quot;i&quot;},<br>                []string{&quot;j&quot;, &quot;k&quot;, &quot;l&quot;},<br>        }<br><br>        fmt.Printf(&quot;The array: %v\\n&quot;, complexArray1)<br>        &#47;&#47; array2 := modifyArray(complexArray1)<br>        array2 := modifyArray2(complexArray1)<br>        fmt.Printf(&quot;The modified array: %v\\n&quot;, array2)<br>        fmt.Printf(&quot;The original array: %v\\n&quot;, complexArray1)<br>}","like_count":0},{"had_liked":false,"id":26717,"user_name":"xiwi","can_delete":false,"product_type":"c1","uid":1113179,"ip_address":"","ucode":"49F9C1DAFF6ABA","user_header":"https://static001.geekbang.org/account/avatar/00/10/fc/5b/53613c55.jpg","comment_is_top":false,"comment_ctime":1537746364,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1537746364","product_id":100013101,"comment_content":"老师，func genCalculator(op operate) calculateFunc{<br>    ...<br>}<br><br>这个在编译的时候会提示calculateFunc 未定义呢！<br>我将这个函数改成了<br>func genCalculator(op operate) func(x, y int) (int, error){<br>    ...<br>}<br>这样就没问题！","like_count":0,"discussions":[{"author":{"id":1018685,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/3d/0c3a2fd4.jpg","nickname":"偶尔复活下","note":"","ucode":"18B1D525CD50D3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380051,"discussion_content":"需要自己定义","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624318144,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":25581,"user_name":"小强","can_delete":false,"product_type":"c1","uid":1149004,"ip_address":"","ucode":"CC3D3A9E5D9A42","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/4c/2c3d2c7d.jpg","comment_is_top":false,"comment_ctime":1537368145,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1537368145","product_id":100013101,"comment_content":"为什么go的函数设计这么复杂，太头大了！","like_count":0},{"had_liked":false,"id":24305,"user_name":"成都福哥","can_delete":false,"product_type":"c1","uid":1034285,"ip_address":"","ucode":"0D3C2E5FE17E6B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c8/2d/3dd499a9.jpg","comment_is_top":false,"comment_ctime":1536895031,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1536895031","product_id":100013101,"comment_content":"函数执行完，栈空间就回收了。返回值应该是通过寄存器或者是调用者栈空间的地址来存储的。<br>从这角度做个猜想，应该是要复制出来的吧。","like_count":0},{"had_liked":false,"id":23991,"user_name":"金阳","can_delete":false,"product_type":"c1","uid":1057331,"ip_address":"","ucode":"5DA949C5970F24","user_header":"https://static001.geekbang.org/account/avatar/00/10/22/33/6b9a7719.jpg","comment_is_top":false,"comment_ctime":1536742546,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1536742546","product_id":100013101,"comment_content":"func printToStd(content string) (bytesNum int, err error)<br>返回值是(bytesNum int, err error)<br>为什么 返回fmt.println(content)不报错","like_count":0,"discussions":[{"author":{"id":1019568,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8e/b0/ef201991.jpg","nickname":"CcczzZ","note":"","ucode":"5F46DA5053D2BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":109480,"discussion_content":"看一下fmt.println()函数定义，调用的时候本来就返回了两个值。\n\nfunc Println(a ...interface{}) (n int, err error) {\n\treturn Fprintln(os.Stdout, a...)\n}","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577697005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":23564,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1118976,"ip_address":"","ucode":"35F4FFAC4A4B15","user_header":"https://static001.geekbang.org/account/avatar/00/11/13/00/a4a2065f.jpg","comment_is_top":false,"comment_ctime":1536496331,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1536496331","product_id":100013101,"comment_content":"第一个是会的，数组是值类型，被传入函数时会进行深层复制，但是他的每一个元素类型是切片，既引用，所以复制的也就是引用，改变某个切片中的某个元素的内容，进而影响了愿数组。","like_count":0},{"had_liked":false,"id":23487,"user_name":"T、","can_delete":false,"product_type":"c1","uid":1214090,"ip_address":"","ucode":"11713A25556241","user_header":"https://static001.geekbang.org/account/avatar/00/12/86/8a/cb3b4b0f.jpg","comment_is_top":false,"comment_ctime":1536408911,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1536408911","product_id":100013101,"comment_content":"不错哦","like_count":0},{"had_liked":false,"id":23288,"user_name":"benben","can_delete":false,"product_type":"c1","uid":1222193,"ip_address":"","ucode":"A861DEB5A88AA2","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/mWicFKgbjL299CQPEhoFdSLGvibCiaXeZo2EjV1hDLicPxicyRTWCODxeYwq8eBgxU6zUuU6rrIw3d7hGwFmRflicibHA/132","comment_is_top":false,"comment_ctime":1536277869,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1536277869","product_id":100013101,"comment_content":"第一个问题应该会受影响，因为数组元素是切片<br>第二问题我想应该是复制的","like_count":0},{"had_liked":false,"id":23283,"user_name":"@XP","can_delete":false,"product_type":"c1","uid":1136671,"ip_address":"","ucode":"D8D93A044F989C","user_header":"https://static001.geekbang.org/account/avatar/00/11/58/1f/9dc4d475.jpg","comment_is_top":false,"comment_ctime":1536274645,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1536274645","product_id":100013101,"comment_content":"第一个问题：分为2中情况，1.数组的操作不影响原值 2.切片的操作会影响原值。<br>第二个问题：是它的副本，不是原则，从引用地址可以看出来","like_count":0}]}