{"id":91569,"title":"24 | CompletableFuture：异步编程没那么难","content":"<p>前面我们不止一次提到，用多线程优化性能，其实不过就是将串行操作变成并行操作。如果仔细观察，你还会发现在串行转换成并行的过程中，一定会涉及到异步化，例如下面的示例代码，现在是串行的，为了提升性能，我们得把它们并行化，那具体实施起来该怎么做呢？</p><pre><code>//以下两个方法都是耗时操作\ndoBizA();\ndoBizB();\n</code></pre><p>还是挺简单的，就像下面代码中这样，创建两个子线程去执行就可以了。你会发现下面的并行方案，主线程无需等待doBizA()和doBizB()的执行结果，也就是说doBizA()和doBizB()两个操作已经被异步化了。</p><pre><code>new Thread(()-&gt;doBizA())\n  .start();\nnew Thread(()-&gt;doBizB())\n  .start();  \n</code></pre><p><strong>异步化</strong>，是并行方案得以实施的基础，更深入地讲其实就是：<strong>利用多线程优化性能这个核心方案得以实施的基础</strong>。看到这里，相信你应该就能理解异步编程最近几年为什么会大火了，因为优化性能是互联网大厂的一个核心需求啊。Java在1.8版本提供了CompletableFuture来支持异步编程，CompletableFuture有可能是你见过的最复杂的工具类了，不过功能也着实让人感到震撼。</p><h2>CompletableFuture的核心优势</h2><p>为了领略CompletableFuture异步编程的优势，这里我们用CompletableFuture重新实现前面曾提及的烧水泡茶程序。首先还是需要先完成分工方案，在下面的程序中，我们分了3个任务：任务1负责洗水壶、烧开水，任务2负责洗茶壶、洗茶杯和拿茶叶，任务3负责泡茶。其中任务3要等待任务1和任务2都完成后才能开始。这个分工如下图所示。</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/b3/78/b33f823a4124c1220d8bd6d91b877e78.png?wh=1142*623\" alt=\"\"></p><center><span class=\"reference\">烧水泡茶分工方案</span></center><p>下面是代码实现，你先略过runAsync()、supplyAsync()、thenCombine()这些不太熟悉的方法，从大局上看，你会发现：</p><ol>\n<li>无需手工维护线程，没有繁琐的手工维护线程的工作，给任务分配线程的工作也不需要我们关注；</li>\n<li>语义更清晰，例如 <code>f3 = f1.thenCombine(f2, ()-&gt;{})</code> 能够清晰地表述“任务3要等待任务1和任务2都完成后才能开始”；</li>\n<li>代码更简练并且专注于业务逻辑，几乎所有代码都是业务逻辑相关的。</li>\n</ol><pre><code>//任务1：洗水壶-&gt;烧开水\nCompletableFuture&lt;Void&gt; f1 = \n  CompletableFuture.runAsync(()-&gt;{\n  System.out.println(&quot;T1:洗水壶...&quot;);\n  sleep(1, TimeUnit.SECONDS);\n\n  System.out.println(&quot;T1:烧开水...&quot;);\n  sleep(15, TimeUnit.SECONDS);\n});\n//任务2：洗茶壶-&gt;洗茶杯-&gt;拿茶叶\nCompletableFuture&lt;String&gt; f2 = \n  CompletableFuture.supplyAsync(()-&gt;{\n  System.out.println(&quot;T2:洗茶壶...&quot;);\n  sleep(1, TimeUnit.SECONDS);\n\n  System.out.println(&quot;T2:洗茶杯...&quot;);\n  sleep(2, TimeUnit.SECONDS);\n\n  System.out.println(&quot;T2:拿茶叶...&quot;);\n  sleep(1, TimeUnit.SECONDS);\n  return &quot;龙井&quot;;\n});\n//任务3：任务1和任务2完成后执行：泡茶\nCompletableFuture&lt;String&gt; f3 = \n  f1.thenCombine(f2, (__, tf)-&gt;{\n    System.out.println(&quot;T1:拿到茶叶:&quot; + tf);\n    System.out.println(&quot;T1:泡茶...&quot;);\n    return &quot;上茶:&quot; + tf;\n  });\n//等待任务3执行结果\nSystem.out.println(f3.join());\n\nvoid sleep(int t, TimeUnit u) {\n  try {\n    u.sleep(t);\n  }catch(InterruptedException e){}\n}\n// 一次执行结果：\nT1:洗水壶...\nT2:洗茶壶...\nT1:烧开水...\nT2:洗茶杯...\nT2:拿茶叶...\nT1:拿到茶叶:龙井\nT1:泡茶...\n上茶:龙井\n</code></pre><p>领略CompletableFuture异步编程的优势之后，下面我们详细介绍CompletableFuture的使用，首先是如何创建CompletableFuture对象。</p><h2>创建CompletableFuture对象</h2><p>创建CompletableFuture对象主要靠下面代码中展示的这4个静态方法，我们先看前两个。在烧水泡茶的例子中，我们已经使用了<code>runAsync(Runnable runnable)</code>和<code>supplyAsync(Supplier&lt;U&gt; supplier)</code>，它们之间的区别是：Runnable 接口的run()方法没有返回值，而Supplier接口的get()方法是有返回值的。</p><p>前两个方法和后两个方法的区别在于：后两个方法可以指定线程池参数。</p><p>默认情况下CompletableFuture会使用公共的ForkJoinPool线程池，这个线程池默认创建的线程数是CPU的核数（也可以通过JVM option:-Djava.util.concurrent.ForkJoinPool.common.parallelism来设置ForkJoinPool线程池的线程数）。如果所有CompletableFuture共享一个线程池，那么一旦有任务执行一些很慢的I/O操作，就会导致线程池中所有线程都阻塞在I/O操作上，从而造成线程饥饿，进而影响整个系统的性能。所以，强烈建议你要<strong>根据不同的业务类型创建不同的线程池，以避免互相干扰</strong>。</p><pre><code>//使用默认线程池\nstatic CompletableFuture&lt;Void&gt; \n  runAsync(Runnable runnable)\nstatic &lt;U&gt; CompletableFuture&lt;U&gt; \n  supplyAsync(Supplier&lt;U&gt; supplier)\n//可以指定线程池  \nstatic CompletableFuture&lt;Void&gt; \n  runAsync(Runnable runnable, Executor executor)\nstatic &lt;U&gt; CompletableFuture&lt;U&gt; \n  supplyAsync(Supplier&lt;U&gt; supplier, Executor executor)  \n</code></pre><p>创建完CompletableFuture对象之后，会自动地异步执行runnable.run()方法或者supplier.get()方法，对于一个异步操作，你需要关注两个问题：一个是异步操作什么时候结束，另一个是如何获取异步操作的执行结果。因为CompletableFuture类实现了Future接口，所以这两个问题你都可以通过Future接口来解决。另外，CompletableFuture类还实现了CompletionStage接口，这个接口内容实在是太丰富了，在1.8版本里有40个方法，这些方法我们该如何理解呢？</p><h2>如何理解CompletionStage接口</h2><p>我觉得，你可以站在分工的角度类比一下工作流。任务是有时序关系的，比如有<strong>串行关系、并行关系、汇聚关系</strong>等。这样说可能有点抽象，这里还举前面烧水泡茶的例子，其中洗水壶和烧开水就是串行关系，洗水壶、烧开水和洗茶壶、洗茶杯这两组任务之间就是并行关系，而烧开水、拿茶叶和泡茶就是汇聚关系。</p><p><img src=\"https://static001.geekbang.org/resource/image/e1/9f/e18181998b82718da811ce5807f0ad9f.png?wh=1142*153\" alt=\"\"></p><center><span class=\"reference\">串行关系</span></center><p><img src=\"https://static001.geekbang.org/resource/image/ea/d2/ea8e1a41a02b0104b421c58b25343bd2.png?wh=1142*313\" alt=\"\"></p><center><span class=\"reference\">并行关系</span></center><p><img src=\"https://static001.geekbang.org/resource/image/3f/3b/3f1a5421333dd6d5c278ffd5299dc33b.png?wh=1142*272\" alt=\"\"></p><center><span class=\"reference\">汇聚关系</span></center><p>CompletionStage接口可以清晰地描述任务之间的这种时序关系，例如前面提到的 <code>f3 = f1.thenCombine(f2, ()-&gt;{})</code> 描述的就是一种汇聚关系。烧水泡茶程序中的汇聚关系是一种 AND 聚合关系，这里的AND指的是所有依赖的任务（烧开水和拿茶叶）都完成后才开始执行当前任务（泡茶）。既然有AND聚合关系，那就一定还有OR聚合关系，所谓OR指的是依赖的任务只要有一个完成就可以执行当前任务。</p><p>在编程领域，还有一个绕不过去的山头，那就是异常处理，CompletionStage接口也可以方便地描述异常处理。</p><p>下面我们就来一一介绍，CompletionStage接口如何描述串行关系、AND聚合关系、OR聚合关系以及异常处理。</p><h3>1. 描述串行关系</h3><p>CompletionStage接口里面描述串行关系，主要是thenApply、thenAccept、thenRun和thenCompose这四个系列的接口。</p><p>thenApply系列函数里参数fn的类型是接口Function&lt;T, R&gt;，这个接口里与CompletionStage相关的方法是 <code>R apply(T t)</code>，这个方法既能接收参数也支持返回值，所以thenApply系列方法返回的是<code>CompletionStage&lt;R&gt;</code>。</p><p>而thenAccept系列方法里参数consumer的类型是接口<code>Consumer&lt;T&gt;</code>，这个接口里与CompletionStage相关的方法是 <code>void accept(T t)</code>，这个方法虽然支持参数，但却不支持回值，所以thenAccept系列方法返回的是<code>CompletionStage&lt;Void&gt;</code>。</p><p>thenRun系列方法里action的参数是Runnable，所以action既不能接收参数也不支持返回值，所以thenRun系列方法返回的也是<code>CompletionStage&lt;Void&gt;</code>。</p><p>这些方法里面Async代表的是异步执行fn、consumer或者action。其中，需要你注意的是thenCompose系列方法，这个系列的方法会新创建出一个子流程，最终结果和thenApply系列是相同的。</p><pre><code>CompletionStage&lt;R&gt; thenApply(fn);\nCompletionStage&lt;R&gt; thenApplyAsync(fn);\nCompletionStage&lt;Void&gt; thenAccept(consumer);\nCompletionStage&lt;Void&gt; thenAcceptAsync(consumer);\nCompletionStage&lt;Void&gt; thenRun(action);\nCompletionStage&lt;Void&gt; thenRunAsync(action);\nCompletionStage&lt;R&gt; thenCompose(fn);\nCompletionStage&lt;R&gt; thenComposeAsync(fn);\n</code></pre><p>通过下面的示例代码，你可以看一下thenApply()方法是如何使用的。首先通过supplyAsync()启动一个异步流程，之后是两个串行操作，整体看起来还是挺简单的。不过，虽然这是一个异步流程，但任务①②③却是串行执行的，②依赖①的执行结果，③依赖②的执行结果。</p><pre><code>CompletableFuture&lt;String&gt; f0 = \n  CompletableFuture.supplyAsync(\n    () -&gt; &quot;Hello World&quot;)      //①\n  .thenApply(s -&gt; s + &quot; QQ&quot;)  //②\n  .thenApply(String::toUpperCase);//③\n\nSystem.out.println(f0.join());\n//输出结果\nHELLO WORLD QQ\n</code></pre><h3>2. 描述AND汇聚关系</h3><p>CompletionStage接口里面描述AND汇聚关系，主要是thenCombine、thenAcceptBoth和runAfterBoth系列的接口，这些接口的区别也是源自fn、consumer、action这三个核心参数不同。它们的使用你可以参考上面烧水泡茶的实现程序，这里就不赘述了。</p><pre><code>CompletionStage&lt;R&gt; thenCombine(other, fn);\nCompletionStage&lt;R&gt; thenCombineAsync(other, fn);\nCompletionStage&lt;Void&gt; thenAcceptBoth(other, consumer);\nCompletionStage&lt;Void&gt; thenAcceptBothAsync(other, consumer);\nCompletionStage&lt;Void&gt; runAfterBoth(other, action);\nCompletionStage&lt;Void&gt; runAfterBothAsync(other, action);\n</code></pre><h3>3. 描述OR汇聚关系</h3><p>CompletionStage接口里面描述OR汇聚关系，主要是applyToEither、acceptEither和runAfterEither系列的接口，这些接口的区别也是源自fn、consumer、action这三个核心参数不同。</p><pre><code>CompletionStage applyToEither(other, fn);\nCompletionStage applyToEitherAsync(other, fn);\nCompletionStage acceptEither(other, consumer);\nCompletionStage acceptEitherAsync(other, consumer);\nCompletionStage runAfterEither(other, action);\nCompletionStage runAfterEitherAsync(other, action);\n</code></pre><p>下面的示例代码展示了如何使用applyToEither()方法来描述一个OR汇聚关系。</p><pre><code>CompletableFuture&lt;String&gt; f1 = \n  CompletableFuture.supplyAsync(()-&gt;{\n    int t = getRandom(5, 10);\n    sleep(t, TimeUnit.SECONDS);\n    return String.valueOf(t);\n});\n\nCompletableFuture&lt;String&gt; f2 = \n  CompletableFuture.supplyAsync(()-&gt;{\n    int t = getRandom(5, 10);\n    sleep(t, TimeUnit.SECONDS);\n    return String.valueOf(t);\n});\n\nCompletableFuture&lt;String&gt; f3 = \n  f1.applyToEither(f2,s -&gt; s);\n\nSystem.out.println(f3.join());\n</code></pre><h3>4. 异常处理</h3><p>虽然上面我们提到的fn、consumer、action它们的核心方法都<strong>不允许抛出可检查异常，但是却无法限制它们抛出运行时异常</strong>，例如下面的代码，执行 <code>7/0</code> 就会出现除零错误这个运行时异常。非异步编程里面，我们可以使用try{}catch{}来捕获并处理异常，那在异步编程里面，异常该如何处理呢？</p><pre><code>CompletableFuture&lt;Integer&gt; \n  f0 = CompletableFuture.\n    .supplyAsync(()-&gt;(7/0))\n    .thenApply(r-&gt;r*10);\nSystem.out.println(f0.join());\n</code></pre><p>CompletionStage接口给我们提供的方案非常简单，比try{}catch{}还要简单，下面是相关的方法，使用这些方法进行异常处理和串行操作是一样的，都支持链式编程方式。</p><pre><code>CompletionStage exceptionally(fn);\nCompletionStage&lt;R&gt; whenComplete(consumer);\nCompletionStage&lt;R&gt; whenCompleteAsync(consumer);\nCompletionStage&lt;R&gt; handle(fn);\nCompletionStage&lt;R&gt; handleAsync(fn);\n</code></pre><p>下面的示例代码展示了如何使用exceptionally()方法来处理异常，exceptionally()的使用非常类似于try{}catch{}中的catch{}，但是由于支持链式编程方式，所以相对更简单。既然有try{}catch{}，那就一定还有try{}finally{}，whenComplete()和handle()系列方法就类似于try{}finally{}中的finally{}，无论是否发生异常都会执行whenComplete()中的回调函数consumer和handle()中的回调函数fn。whenComplete()和handle()的区别在于whenComplete()不支持返回结果，而handle()是支持返回结果的。</p><pre><code>CompletableFuture&lt;Integer&gt; \n  f0 = CompletableFuture\n    .supplyAsync(()-&gt;(7/0))\n    .thenApply(r-&gt;r*10)\n    .exceptionally(e-&gt;0);\nSystem.out.println(f0.join());\n</code></pre><h2>总结</h2><p>曾经一提到异步编程，大家脑海里都会随之浮现回调函数，例如在JavaScript里面异步问题基本上都是靠回调函数来解决的，回调函数在处理异常以及复杂的异步任务关系时往往力不从心，对此业界还发明了个名词：<strong>回调地狱</strong>（Callback Hell）。应该说在前些年，异步编程还是声名狼藉的。</p><p>不过最近几年，伴随着<a href=\"http://reactivex.io/intro.html\">ReactiveX</a>的发展（Java语言的实现版本是RxJava），回调地狱已经被完美解决了，异步编程已经慢慢开始成熟，Java语言也开始官方支持异步编程：在1.8版本提供了CompletableFuture，在Java 9版本则提供了更加完备的Flow API，异步编程目前已经完全工业化。因此，学好异步编程还是很有必要的。</p><p>CompletableFuture已经能够满足简单的异步编程需求，如果你对异步编程感兴趣，可以重点关注RxJava这个项目，利用RxJava，即便在Java 1.6版本也能享受异步编程的乐趣。</p><h2>课后思考</h2><p>创建采购订单的时候，需要校验一些规则，例如最大金额是和采购员级别相关的。有同学利用CompletableFuture实现了这个校验的功能，逻辑很简单，首先是从数据库中把相关规则查出来，然后执行规则校验。你觉得他的实现是否有问题呢？</p><pre><code>//采购订单\nPurchersOrder po;\nCompletableFuture&lt;Boolean&gt; cf = \n  CompletableFuture.supplyAsync(()-&gt;{\n    //在数据库中查询规则\n    return findRuleByJdbc();\n  }).thenApply(r -&gt; {\n    //规则校验\n    return check(po, r);\n});\nBoolean isOk = cf.join();\n</code></pre><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p>","neighbors":{"left":{"article_title":"23 | Future：如何用多线程实现最优的“烧水泡茶”程序？","id":91292},"right":{"article_title":"25 | CompletionService：如何批量执行异步任务？","id":92245}},"comments":[{"had_liked":false,"id":88816,"user_name":"J.M.Liu","can_delete":false,"product_type":"c1","uid":1200037,"ip_address":"","ucode":"B2CB84B8E923A6","user_header":"https://static001.geekbang.org/account/avatar/00/12/4f/a5/71358d7b.jpg","comment_is_top":false,"comment_ctime":1556007566,"is_pvip":false,"replies":[{"id":"31821","content":"思考题考虑的很全面👍<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556028627,"ip_address":"","comment_id":88816,"utype":1}],"discussion_count":1,"race_medal":0,"score":"555606788750","product_id":100023901,"comment_content":"思考题：<br>1.没有进行异常处理，<br>2.要指定专门的线程池做数据库查询<br>3.如果检查和查询都比较耗时，那么应该像之前的对账系统一样，采用生产者和消费者模式，让上一次的检查和下一次的查询并行起来。<br><br>另外，老师把javadoc里那一堆那一堆方法进行了分类，分成串行、并行、AND聚合、OR聚合，简直太棒了，一下子就把这些方法纳入到一个完整的结构体系里了。简直棒","like_count":130,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447910,"discussion_content":"思考题考虑的很全面👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556028627,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":88761,"user_name":"袁阳","can_delete":false,"product_type":"c1","uid":1329594,"ip_address":"","ucode":"B397F760CDC53A","user_header":"https://static001.geekbang.org/account/avatar/00/14/49/ba/02742d56.jpg","comment_is_top":false,"comment_ctime":1555994471,"is_pvip":false,"replies":[{"id":"31822","content":"👍👍<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556028704,"ip_address":"","comment_id":88761,"utype":1}],"discussion_count":7,"race_medal":0,"score":"474002397031","product_id":100023901,"comment_content":"思考题:<br>1，读数据库属于io操作，应该放在单独线程池，避免线程饥饿<br>2，异常未处理","like_count":111,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447891,"discussion_content":"👍👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556028704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181650,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","nickname":"惘 闻","note":"","ucode":"C5909F034BF072","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296814,"discussion_content":"为什么io操作要用线程池啊？普通多线程不可以吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596673295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1306315,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ee/cb/4bd24e0f.jpg","nickname":"官人","note":"","ucode":"ECEF55B08E252B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1181650,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","nickname":"惘 闻","note":"","ucode":"C5909F034BF072","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384381,"discussion_content":"因为不指定线程池 会使用forkjoin线程 io操作可能会长时阻塞 ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1626531845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":296814,"ip_address":""},"score":384381,"extra":""},{"author":{"id":1134574,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4f/ee/bd08cfab.jpg","nickname":"一魄","note":"","ucode":"71541125D4AA5A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1306315,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ee/cb/4bd24e0f.jpg","nickname":"官人","note":"","ucode":"ECEF55B08E252B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391569,"discussion_content":"答非所问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630515921,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":384381,"ip_address":""},"score":391569,"extra":""},{"author":{"id":2029015,"avatar":"","nickname":"小钢炮","note":"","ucode":"676C4CCF3CCD0D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1134574,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4f/ee/bd08cfab.jpg","nickname":"一魄","note":"","ucode":"71541125D4AA5A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":405420,"discussion_content":"我觉得人家说的很好啊。CompletableFuture默认会使用公共的ForkJoinPool，由于IO操作可能会长时间阻塞，如果其他业务也使用公共的ForkJoinPool，不就有可能线程都在忙着IO么。建议不要使用公共的，要指定线程池：static CompletableFuture supplyAsync(Supplier supplier, Executor executor)","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1634564634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":391569,"ip_address":""},"score":405420,"extra":""}]}]},{"had_liked":false,"id":88642,"user_name":"密码123456","can_delete":false,"product_type":"c1","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1555978491,"is_pvip":false,"replies":[{"id":"31817","content":"这个简单场景没必要用","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556028348,"ip_address":"","comment_id":88642,"utype":1}],"discussion_count":5,"race_medal":0,"score":"186239572219","product_id":100023901,"comment_content":"我在想一个问题，明明是串行过程，直接写就可以了。为什么还要用异步去实现串行？","like_count":44,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447853,"discussion_content":"这个简单场景没必要用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556028348,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1493907,"avatar":"https://static001.geekbang.org/account/avatar/00/16/cb/93/4adea49a.jpg","nickname":"努力努力再努力","note":"","ucode":"0C6EEA28FCE8C7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572977,"discussion_content":"异步串行的真正场景，我认为是执行分支逻辑时，需要并行，每个并行内又是串行","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1653111874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299253,"discussion_content":"同感","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1597629606,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1186089,"avatar":"https://static001.geekbang.org/account/avatar/00/12/19/29/4a8214b7.jpg","nickname":"Bug Killer","note":"","ucode":"2741A206F504E1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392184,"discussion_content":"同感，觉得没必要","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630893088,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066928,"avatar":"https://static001.geekbang.org/account/avatar/00/10/47/b0/a9b77a1e.jpg","nickname":"冬风向左吹","note":"","ucode":"376C45C5134F93","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":218816,"discussion_content":"哈哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585703578,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89223,"user_name":"发条橙子 。","can_delete":false,"product_type":"c1","uid":1259218,"ip_address":"","ucode":"ED076F4534FFED","user_header":"https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg","comment_is_top":false,"comment_ctime":1556111306,"is_pvip":false,"replies":[{"id":"31968","content":"我觉得可以优先使用CompletableFuture，当然前提是你的jdk是1.8","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556117606,"ip_address":"","comment_id":89223,"utype":1}],"discussion_count":2,"race_medal":0,"score":"181944737738","product_id":100023901,"comment_content":"老师 ，我有个疑问。 completableFuture 中各种关系（并行、串行、聚合），实际上就覆盖了各种需求场景。 例如 ： 线程A 等待 线程B 或者 线程C 等待 线程A和B 。<br><br>我们之前讲的并发包里面 countdownLatch , 或者 threadPoolExecutor 和future  就是来解决这些关系场景的 ， 那有了 completableFuture 这个类 ，是不是以后有需求都优先考虑用 completableFuture ？感觉这个类就可以解决前面所讲的类的问题了","like_count":43,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448062,"discussion_content":"我觉得可以优先使用CompletableFuture，当然前提是你的jdk是1.8","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556117606,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2649276,"avatar":"https://static001.geekbang.org/account/avatar/00/28/6c/bc/f751786b.jpg","nickname":"Leo","note":"","ucode":"CEBAD9CDCFC2A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580355,"discussion_content":"countdownLatch是JUC下针对并发下的情况使用的某种工具，跟CompletableFuture用处其实不一致；threadPoolExecutor 底层其实也就是多线程和CompletableFuture用处很像；","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658126022,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":88927,"user_name":"青莲","can_delete":false,"product_type":"c1","uid":1181787,"ip_address":"","ucode":"6BA5D5D47DE38E","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/5b/2a342424.jpg","comment_is_top":false,"comment_ctime":1556028220,"is_pvip":true,"replies":[{"id":"31838","content":"👍👍<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556031150,"ip_address":"","comment_id":88927,"utype":1}],"discussion_count":1,"race_medal":0,"score":"96045308732","product_id":100023901,"comment_content":"1.查数据库属于io操作，用定制线程池<br>2.查出来的结果做为下一步处理的条件，若结果为空呢，没有对应处理<br>3.缺少异常处理机制","like_count":22,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447949,"discussion_content":"👍👍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556031150,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90371,"user_name":"笃行之","can_delete":false,"product_type":"c1","uid":1140311,"ip_address":"","ucode":"F76B5C6D17765E","user_header":"https://static001.geekbang.org/account/avatar/00/11/66/57/e3bd54bd.jpg","comment_is_top":false,"comment_ctime":1556501880,"is_pvip":false,"replies":[{"id":"32401","content":"有关系，如果系统就一个线程池，里面的线程都阻塞在io上，那么系统其他的任务都需要等待。如果其他任务有自己的线程池，就没有问题。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556519490,"ip_address":"","comment_id":90371,"utype":1}],"discussion_count":2,"race_medal":0,"score":"70275978616","product_id":100023901,"comment_content":"”如果所有 CompletableFuture 共享一个线程池，那么一旦有任务执行一些很慢的 I&#47;O 操作，就会导致线程池中所有线程都阻塞在 I&#47;O 操作上，从而造成线程饥饿，进而影响整个系统的性能。”老师，阻塞在io上和是不是在一个线程池没关系吧？","like_count":16,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448497,"discussion_content":"有关系，如果系统就一个线程池，里面的线程都阻塞在io上，那么系统其他的任务都需要等待。如果其他任务有自己的线程池，就没有问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556519490,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1095857,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","nickname":"梦倚栏杆","note":"","ucode":"BDEB97F2822445","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77694,"discussion_content":"所以理解起来这是一个概率问题，\n方案1:大家共享一个池子，在一个池子里排队，等待处理。\n方案2:大家根据自己的情况组团，每个团队创建一个线程池，每个团队里各自排队。\n方案1和方案2的区别就是方案1里抢到线程的任务各种各样，很有可能很不幸全部是耗时的，方案2是每个团队都会有一个任务抢到执行线程， 更小概率抢到线程的任务全部都是耗时的\n但是方案2没有一个全局的视角来把控线程的个数，可能会导致频繁上下文切换，可能也会慢","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1575934483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":88825,"user_name":"J.M.Liu","can_delete":false,"product_type":"c1","uid":1200037,"ip_address":"","ucode":"B2CB84B8E923A6","user_header":"https://static001.geekbang.org/account/avatar/00/12/4f/a5/71358d7b.jpg","comment_is_top":false,"comment_ctime":1556008668,"is_pvip":false,"replies":[{"id":"31819","content":"后面有介绍<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556028539,"ip_address":"","comment_id":88825,"utype":1}],"discussion_count":1,"race_medal":0,"score":"53095616220","product_id":100023901,"comment_content":"我觉得既然都讲到CompletableFuture了，老师是不是有必要不一章ForkJoinPool呀？毕竟，ForkJoinPool和ThreadPoolExecutor还是有很多不一样的。谢谢老师","like_count":12,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447913,"discussion_content":"后面有介绍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556028539,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89141,"user_name":"henry","can_delete":false,"product_type":"c1","uid":1075941,"ip_address":"","ucode":"0ACD12F363F8DE","user_header":"http://thirdqq.qlogo.cn/qqapp/101418266/D6DD8CB1004D442B48914656340277F3/100","comment_is_top":false,"comment_ctime":1556090322,"is_pvip":false,"replies":[{"id":"31965","content":"有个地方需要注意：runAsync和supplyAsync都是静态方法。<br>线程池设置的太小了，这是个IO密集型的任务<br>thenApply里面的runAsync我觉得好像是没有必要，增加了复杂的了。<br><br>如果thenApply里面需要异步，可以用thenApplyAsync","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556117495,"ip_address":"","comment_id":89141,"utype":1}],"discussion_count":4,"race_medal":0,"score":"44505763282","product_id":100023901,"comment_content":"老师我现在有个任务，和您的例子有相似的地方，是从一个库里查询多张表的数据同步到另外一个库，就有双重for循环，最外层用与多张表的遍历，内层的for循环用于批量读取某一张表的数据，因为数据量可能在几万条，我想分批次读出来再同步到另一个数据库，昨天写的时候用的是futuretask,今天正好看到老师的文章就改成了CompletableFuture，还没有用异常处理的，后面我还要看看怎么加上异常处理的。其它的不知道我用的对不对，请老师看看：<br>   &#47;&#47; 初始化异步工具类，分别异步执行2个任务<br>        CompletableFuture&lt;List&lt;PBSEnergyData&gt;&gt; asyncAquirePBSEnergyData = new CompletableFuture();<br>        CompletableFuture&lt;List&lt;AXEEnergyData&gt;&gt; asyncSaveAxeEnergyData = new CompletableFuture();<br>        &#47;&#47; 初始化两个线程池， 分别用于2个任务 ，1个任务一个线程池，互不干扰<br>        Executor aquirePBSEnergyDataExecutor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());<br>        Executor saveAxeEnergyDataExecutor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());<br>        queryUtils.getTableNames().forEach(tableName -&gt; {<br>            int pageSize = queryUtils.getPageSize();<br>            &#47;&#47;查询该表有多少条数据，每${pageSize}条一次<br>            int count = pbsEnergyService.getCount(tableName);<br>            &#47;&#47;总页数<br>            int pages = count &#47; pageSize;<br>            int pageNum = 0;<br>            final int pageNo = pageNum;<br>            for(pageNum = 0; pageNum &lt;= pages; pageNum++){<br>                &#47;&#47; 异步获取PBS数据库的数据并返回结果<br>                asyncAquirePBSEnergyData<br>                        .supplyAsync(() -&gt; {<br>                    查询数据库<br>                    return pbsEnergyDatas;<br>                },aquirePBSEnergyDataExecutor)<br>                        &#47;&#47; 任务2任务1，任务1返回的结果<br>                        .thenApply(pbsEnergyDatas -&gt; asyncSaveAxeEnergyData.runAsync(()-&gt;{<br>                    List&lt;AXEEnergyData&gt; axeEnergyDatas = pbsEnergyDatas.stream().map(pbsEnergyData -&gt; {<br>                   \t &#47;&#47;进行类型转换<br>                    }).collect(Collectors.toList());<br>                    &#47;&#47;批量保存<br>                },saveAxeEnergyDataExecutor));<br>            }<br>        });<br>全部贴上去，超过字符数了，只能请老师凑合看了 :(","like_count":10,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448033,"discussion_content":"有个地方需要注意：runAsync和supplyAsync都是静态方法。\n线程池设置的太小了，这是个IO密集型的任务\nthenApply里面的runAsync我觉得好像是没有必要，增加了复杂的了。\n\n如果thenApply里面需要异步，可以用thenApplyAsync","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556117495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1049017,"avatar":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","nickname":"学习学个屁","note":"","ucode":"DF2D61E6FB2FCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572338,"discussion_content":"这个场景就没必要用  CompletableFuture 这个了吧，线程池就可以，一页数据一个线程，另外控制好异常以及事务。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1652711645,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1878896,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/ab/70/336b8ec1.jpg","nickname":"杀入禁区的勒布朗","note":"","ucode":"AF89E123F075DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1049017,"avatar":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","nickname":"学习学个屁","note":"","ucode":"DF2D61E6FB2FCE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575776,"discussion_content":"CompletableFuture也是线程池，我觉得用这个挺好的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655104776,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":572338,"ip_address":""},"score":575776,"extra":""},{"author":{"id":1049017,"avatar":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","nickname":"学习学个屁","note":"","ucode":"DF2D61E6FB2FCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1878896,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/ab/70/336b8ec1.jpg","nickname":"杀入禁区的勒布朗","note":"","ucode":"AF89E123F075DC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576341,"discussion_content":"这个底层也是线程池，这个适合异步+获取结果再进行其他异步逻辑处理这种场景，分页使用这个感觉不是很适合。但也能用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655451277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":575776,"ip_address":""},"score":576341,"extra":""}]}]},{"had_liked":false,"id":88856,"user_name":"Chocolate","can_delete":false,"product_type":"c1","uid":1013822,"ip_address":"","ucode":"242CF0E3C10E97","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/3e/c39d86f1.jpg","comment_is_top":false,"comment_ctime":1556013894,"is_pvip":false,"replies":[{"id":"31818","content":"是的，复杂场景就能体现出优势了<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556028511,"ip_address":"","comment_id":88856,"utype":1}],"discussion_count":4,"race_medal":0,"score":"40210719558","product_id":100023901,"comment_content":"回答「密码123456」：CompletableFuture 在执行的过程中可以不阻塞主线程，支持 runAsync、anyOf、allOf 等操作，等某个时间点需要异步执行的结果时再阻塞获取。","like_count":9,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447927,"discussion_content":"是的，复杂场景就能体现出优势了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556028511,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1878896,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/ab/70/336b8ec1.jpg","nickname":"杀入禁区的勒布朗","note":"","ucode":"AF89E123F075DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575777,"discussion_content":"使用FutureTask，不调用get方法也不会阻塞主线程，每条理解这个点是指的什么优势","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655104933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53021,"discussion_content":"方法如果在主线程调用，不就阻塞了吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574124698,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1217874,"avatar":"https://static001.geekbang.org/account/avatar/00/12/95/52/ad190682.jpg","nickname":"Mr wind","note":"","ucode":"484F02D1962239","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":138144,"discussion_content":"调用join的时候才会阻塞，你需要返回结果的时候，就去调用join，如果任务没执行完，阻塞等待结果，执行完的话会直接获得结果。可以翻翻前面老师讲的第一部分","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1579225821,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53021,"ip_address":""},"score":138144,"extra":""}]}]},{"had_liked":false,"id":164948,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1577115403,"is_pvip":false,"replies":[{"id":"62982","content":"用过，配合lambda效果很好","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1577189217,"ip_address":"","comment_id":164948,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31641886475","product_id":100023901,"comment_content":"CompletableFuture从来没玩过，老师在工作&#47;实践中有使用过这个类吗？","like_count":7,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478964,"discussion_content":"用过，配合lambda效果很好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577189217,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93491,"user_name":"佑儿","can_delete":false,"product_type":"c1","uid":1226196,"ip_address":"","ucode":"0629888E7A5E16","user_header":"https://static001.geekbang.org/account/avatar/00/12/b5/d4/3bd5b77b.jpg","comment_is_top":false,"comment_ctime":1557480211,"is_pvip":false,"replies":[{"id":"33506","content":"不是在调用方法的线程中执行的，这样是不是更容易理解","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1557643774,"ip_address":"","comment_id":93491,"utype":1}],"discussion_count":2,"race_medal":0,"score":"31622251283","product_id":100023901,"comment_content":"带有asyn的方法是异步执行，这里的异步是不在当前线程中执行？  比较困惑","like_count":7,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449656,"discussion_content":"不是在调用方法的线程中执行的，这样是不是更容易理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557643774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1579698,"avatar":"","nickname":"wangwe","note":"","ucode":"24F9574044565D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213854,"discussion_content":"在另一个新的线程执行，可以通过日志中的线程ID看出来","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585127856,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159715,"user_name":"圆滚滚","can_delete":false,"product_type":"c1","uid":1351012,"ip_address":"","ucode":"E4D81822A87D50","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/64/272dc1b7.jpg","comment_is_top":false,"comment_ctime":1575735537,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"27345539313","product_id":100023901,"comment_content":"老师，我看demo都是combine2个的，聚合多个的话怎么处理","like_count":6,"discussions":[{"author":{"id":1361746,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c7/52/c5adf218.jpg","nickname":"喜欢地球的阿培同学","note":"","ucode":"5F97037585F857","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":119350,"discussion_content":"allOf()，或者anyOf()","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1578227569,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89126,"user_name":"LW","can_delete":false,"product_type":"c1","uid":1325297,"ip_address":"","ucode":"89820332658E98","user_header":"https://static001.geekbang.org/account/avatar/00/14/38/f1/996a070d.jpg","comment_is_top":false,"comment_ctime":1556085049,"is_pvip":false,"replies":[{"id":"31952","content":"这个线程池在高并发场景里性能更高一些，后面会有介绍<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556113286,"ip_address":"","comment_id":89126,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23030921529","product_id":100023901,"comment_content":"老师，为什么CompletableFuture中默认使用ForkJoinPool这个线程池呢？它为什么不用其他线程池？","like_count":5,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448027,"discussion_content":"这个线程池在高并发场景里性能更高一些，后面会有介绍\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556113286,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":88911,"user_name":"易儿易","can_delete":false,"product_type":"c1","uid":1242864,"ip_address":"","ucode":"B15D1031CA841E","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqLcWH3mSPmhjrs1aGL4b3TqI7xDqWWibM4nYFrRlp0z7FNSWaJz0mqovrgIA7ibmrPt8zRScSfRaqQ/132","comment_is_top":false,"comment_ctime":1556026358,"is_pvip":false,"replies":[{"id":"31972","content":"你也可以理解成给第一个子任务追加了一个类似“回调方法”。回调不也是在第一个任务执行完才回调吗？所以也是串行的。都是一回事，你怎么理解起来顺手就怎么理解就可以了。","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556117807,"ip_address":"","comment_id":88911,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23030862838","product_id":100023901,"comment_content":"老师我有一个问题：在描述串行关系时，为什么参数没有other？这让我觉得并不是在描述两个子任务的串行关系，而是给第一个子任务追加了一个类似“回调方法”fn等……而并行关系和汇聚关系则很明确的出现了other……","like_count":5,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447941,"discussion_content":"你也可以理解成给第一个子任务追加了一个类似“回调方法”。回调不也是在第一个任务执行完才回调吗？所以也是串行的。都是一回事，你怎么理解起来顺手就怎么理解就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556117807,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208852,"user_name":"Geek_0359eb","can_delete":false,"product_type":"c1","uid":1583272,"ip_address":"","ucode":"BED4E390D5972B","user_header":"https://static001.geekbang.org/account/avatar/00/18/28/a8/eaa810af.jpg","comment_is_top":false,"comment_ctime":1587451428,"is_pvip":false,"replies":[{"id":"78101","content":"多线程并行，没办法抛出异常","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1587476955,"ip_address":"","comment_id":208852,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14472353316","product_id":100023901,"comment_content":"老师您好，想问下主线程怎么捕获到多线程中抛出的异常，捕获后再抛出自定义异常呢？","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492647,"discussion_content":"多线程并行，没办法抛出异常","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587476955,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":88657,"user_name":"罗洲","can_delete":false,"product_type":"c1","uid":1263417,"ip_address":"","ucode":"68133E38A25C17","user_header":"https://static001.geekbang.org/account/avatar/00/13/47/39/0ce1aa62.jpg","comment_is_top":false,"comment_ctime":1555980064,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14440881952","product_id":100023901,"comment_content":"我觉得课后思考题中，既然是先查规则再校验，这本来就是一个串行化的动作，为什么要异步呢？用异步的意义在哪？","like_count":3},{"had_liked":false,"id":291885,"user_name":"_立斌","can_delete":false,"product_type":"c1","uid":1562851,"ip_address":"","ucode":"D081ED845C25C2","user_header":"https://static001.geekbang.org/account/avatar/00/17/d8/e3/99f330b8.jpg","comment_is_top":false,"comment_ctime":1620571009,"is_pvip":false,"replies":[{"id":"106835","content":"这种场景，还是搞成同步吧，要不就把任务搞成纯计算的，目前我没见到兼顾性能和易用性的方案","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1621942577,"ip_address":"","comment_id":291885,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10210505601","product_id":100023901,"comment_content":"老师好，想请问一下，如果一个事务里开了多个异步任务，如果其中一个任务抛出异常了，其他任务应该全部回滚，这样的异常如何捕获并处理呢？业界有最佳实践吗？谢谢老师","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519593,"discussion_content":"这种场景，还是搞成同步吧，要不就把任务搞成纯计算的，目前我没见到兼顾性能和易用性的方案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621942577,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1562851,"avatar":"https://static001.geekbang.org/account/avatar/00/17/d8/e3/99f330b8.jpg","nickname":"_立斌","note":"","ucode":"D081ED845C25C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376053,"discussion_content":"明白了，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621943924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183442,"user_name":"楼下小黑哥","can_delete":false,"product_type":"c1","uid":1014680,"ip_address":"","ucode":"453B099B0EE52E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7b/98/8f1aecf4.jpg","comment_is_top":false,"comment_ctime":1583040248,"is_pvip":false,"replies":[{"id":"71262","content":"都是这么过来的😂","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1583234780,"ip_address":"","comment_id":183442,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10172974840","product_id":100023901,"comment_content":"看了几篇 CompletableFuture 的文章，也写过测试 dmeo。不过 CompletableFuture API 太多了，看的迷迷糊糊的。老师这么分类，瞬间清除了，感谢！<br>嘿嘿，学到一招，分类归纳。","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485690,"discussion_content":"都是这么过来的😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583234780,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153674,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1574296066,"is_pvip":false,"replies":[{"id":"59052","content":"可以，实际情况不会只提交一个慢的任务","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1574300841,"ip_address":"","comment_id":153674,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10164230658","product_id":100023901,"comment_content":"如果所有 CompletableFuture 共享一个线程池，那么一旦有任务执行一些很慢的 I&#47;O 操作，就会导致线程池中所有线程都阻塞在 I&#47;O 操作上<br><br><br>这个是不是有问题？因为线程池有多个线程，如果只有一个阻塞，那么其他的线程也是可以的吧","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475244,"discussion_content":"可以，实际情况不会只提交一个慢的任务","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574300841,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135912,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","nickname":"黑色毛衣","note":"","ucode":"FF7E235F91BA5C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55940,"discussion_content":"明白了，老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574415083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124053,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1565797644,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10155732236","product_id":100023901,"comment_content":"问题：为什么在 CompletableFuture.supplyAsync() 方法中返回 Supplier 对象时，打印当前线程的名称是 main 线程？（同步执行？）<br><br>发现一个“有趣”的现象：<br>如果在 supplyAsync() 方法中调用的 lazySupplier() 方法返回 Supplier，惰性求值，在 thenApply() 方法中调用 Supplier.get() 方法触发真正的耗时操作。<br>每次执行，总有 CompletableFuture.supplyAsync() 是在 main 线程中执行的。<br>自己的观察，总是前面 2 个在 main 线程中执行。<br><br>如果 lazySupplier() 方法返回 String，在 supplyAsync() 就触发真正耗时操作，这时结果跟期望一样，都是异步执行。<br>想不明白为什么 supplyAsync + Supplier 惰性求值，就退化成同步执行了。<br><br>谢谢老师！！<br><br><br>代码和执行结果如下所示：<br>public static void main(String[] args) {<br>  ExecutorService executor = Executors.newFixedThreadPool(3);<br>  List&lt;CompletableFuture&lt;String&gt;&gt; list = new ArrayList&lt;&gt;(3);<br>  for (int i = 0; i &lt; 3; i++) {<br>    CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; lazySupplier(), executor)<br>      .thenApply(stringSupplier -&gt; {<br>        System.out.println(&quot;+++ thenApply:&quot; + Thread.currentThread().getName() + &quot; +++&quot;);<br>        String s = stringSupplier.get();<br>        return s + &quot;, hi&quot;;<br>      });<br>    System.out.println(&quot;+++ list.add(future:&quot; + i + &quot;); +++&quot;);<br>    list.add(future);<br>  }<br><br>  for (CompletableFuture&lt;String&gt; future : list) {<br>    String exportList = future.join();<br>    System.out.println(exportList);<br>  }<br><br>  executor.shutdown();<br>}<br><br>private static Supplier&lt;String&gt; lazySupplier() {<br>  return () -&gt; {<br>    long l = System.currentTimeMillis()&#47;1000;<br>    String name = Thread.currentThread().getName();<br>    System.out.println(name + &quot;，执行惰性求值，开始：&quot; + l);<br>    try {<br>      Thread.sleep(10000);<br>    } catch (InterruptedException ignored) {<br>    }<br>    System.out.println(name + &quot;，执行惰性求值，结束：&quot; + System.currentTimeMillis()&#47;1000);<br>    return l + &quot;&quot;;<br>  };<br>}<br><br>执行结果：<br>+++ thenApply:main +++<br>main, 执行惰性求值，开始：1565796415<br>main, 执行惰性求值，结束：1565796425<br>+++ list.add(future:0); +++<br>+++ thenApply:main +++<br>main, 执行惰性求值，开始：1565796425<br>main, 执行惰性求值，结束：1565796435<br>+++ list.add(future:1); +++<br>+++ list.add(future:2); +++<br>1565796415, hi<br>1565796425, hi<br>+++ thenApply:pool-1-thread-3 +++<br>pool-1-thread-3, 执行惰性求值，开始：1565796435<br>pool-1-thread-3, 执行惰性求值，结束：1565796445<br>1565796435, hi","like_count":2},{"had_liked":false,"id":89323,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1556154445,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10146089037","product_id":100023901,"comment_content":"1.我只是感觉到异常没处理<br><br>2.没考虑到io动作需要定制线程去处理<br><br>java异步编程看起来很有意思……","like_count":2},{"had_liked":false,"id":309869,"user_name":"学习","can_delete":false,"product_type":"c1","uid":1437425,"ip_address":"","ucode":"CDFB71E0D1508B","user_header":"https://static001.geekbang.org/account/avatar/00/15/ee/f1/16545faf.jpg","comment_is_top":false,"comment_ctime":1630377284,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5925344580","product_id":100023901,"comment_content":"使用了CF这个异步编程，但是却是报错，这个如何处理啊<br>java.lang.IllegalStateException: No thread-bound request found: Are you referring to request attributes outside of an actual web request, or processing a request outside of the originally receiving thread? If you are actually operating within a web request and still receive this message, your code is probably running outside of DispatcherServlet: In this case, use RequestContextListener or RequestContextFilter to expose the current request.","like_count":1},{"had_liked":false,"id":228213,"user_name":"子豪sirius","can_delete":false,"product_type":"c1","uid":1117023,"ip_address":"","ucode":"E8D08D2D33E785","user_header":"https://static001.geekbang.org/account/avatar/00/11/0b/5f/2cc4060c.jpg","comment_is_top":false,"comment_ctime":1592614943,"is_pvip":true,"replies":[{"id":"84698","content":"互相借鉴😄","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1593003243,"ip_address":"","comment_id":228213,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5887582239","product_id":100023901,"comment_content":"我是先学了javascript的ES6的，发现CompletableFuture的使用方法跟Promise很相似，应该是不同语言的相互影响吧","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498958,"discussion_content":"互相借鉴😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593003243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":88675,"user_name":"linqw","can_delete":false,"product_type":"c1","uid":1134138,"ip_address":"","ucode":"09DCFE98C54DD8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","comment_is_top":false,"comment_ctime":1555981642,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5850948938","product_id":100023901,"comment_content":"课后习题，规则校验依赖于数据库中的规则，如果规则不是共用的，直接放在一个内部，如果规则是共用，可以在主线程进行规则获取，异步校验规则。thenApply会重新创建一个CompletableFuture<br>PurchersOrder po;<br>CompletableFuture&lt;Boolean&gt; cf = <br>  CompletableFuture.supplyAsync(()-&gt;{<br>    &#47;&#47; 在数据库中查询规则<br>    r = findRuleByJdbc();<br>    &#47;&#47; 规则校验<br>    return check(po, r);<br>  });<br>Boolean isOk = cf.join();<br>CompletableFuture的写法和rxjava的使用很类似，一个结果作为下一个的参数，链式操作等","like_count":1},{"had_liked":false,"id":88665,"user_name":"zhangtnty","can_delete":false,"product_type":"c1","uid":1180553,"ip_address":"","ucode":"3C9A14BD7CF432","user_header":"https://static001.geekbang.org/account/avatar/00/12/03/89/e1621a01.jpg","comment_is_top":false,"comment_ctime":1555980683,"is_pvip":false,"replies":[{"id":"31824","content":"代码也有问题<br>","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556028844,"ip_address":"","comment_id":88665,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5850947979","product_id":100023901,"comment_content":"王老师好，单看文中题目的代码是没问题的，读数和校验串行化了, 不考虑效率是没问题的。如果要提升效率最好并行化, 读数和校验利用队列方式效率更高。","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447859,"discussion_content":"代码也有问题\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556028844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351300,"user_name":"林辉","can_delete":false,"product_type":"c1","uid":1134926,"ip_address":"","ucode":"8DE10DE620F0D2","user_header":"https://static001.geekbang.org/account/avatar/00/11/51/4e/4baa613c.jpg","comment_is_top":false,"comment_ctime":1657683210,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1657683210","product_id":100023901,"comment_content":"如果开始并不知道几个任务，需要每次根据数据动态分配N个异步任务，这种该如何写了？","like_count":0},{"had_liked":false,"id":349829,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1656375417,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1656375417","product_id":100023901,"comment_content":"两个下划线那个是什么语法? 请教下","like_count":0},{"had_liked":false,"id":349491,"user_name":"浮石沉木","can_delete":false,"product_type":"c1","uid":2223167,"ip_address":"","ucode":"D585768321B84A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/mQddXC7nRiaKHTwdficicTB3bH0q5ic5UoSab51Omic7eyLBz0SNcvbLpQnNib7zP1yJFm7xxx4ia81iahfibRVnbTwHmhw/132","comment_is_top":false,"comment_ctime":1655994689,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655994689","product_id":100023901,"comment_content":"如果所有 CompletableFuture 共享一个线程池，那么一旦有任务执行一些很慢的 I&#47;O 操作，就会导致线程池中所有线程都阻塞在 I&#47;O 操作上，从而造成线程饥饿，进而影响整个系统的性能。老师这句话我还是理解不了，如果IO我用另外的线程池去做，里边有若干线程，此时一个线程阻塞了，其他的正常工作的IO线程也会受其影响吗，这个影响会不会太大了？","like_count":0},{"had_liked":false,"id":345952,"user_name":"学习学个屁","can_delete":false,"product_type":"c1","uid":1049017,"ip_address":"","ucode":"DF2D61E6FB2FCE","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","comment_is_top":false,"comment_ctime":1652711869,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652711869","product_id":100023901,"comment_content":"问题答案：<br>1 异常处理<br>2 查询外面线程去做<br>3 指定专门的线程池，以及线程名，后面便于查询问题<br><br>CompletableFuture 这个使用场景最好是一个任务需要上一个任务的结果，这种场景最适合。<br>其他异步操作还是用Future，用CompletableFuture有点大才效用了。","like_count":0},{"had_liked":false,"id":335393,"user_name":"木子李","can_delete":false,"product_type":"c1","uid":1694965,"ip_address":"","ucode":"815BAC4C950949","user_header":"https://static001.geekbang.org/account/avatar/00/19/dc/f5/806bd1ff.jpg","comment_is_top":false,"comment_ctime":1645501559,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1645501559","product_id":100023901,"comment_content":"项目上有个保存功能，我想用CompletableFuture改成多线程，具体需求是线程A：校验数据，线程B：校验合同模板：线程C：执行保存。具体代码如下：<br>User user = UserUtil.getUser();<br>ExecutorService executorService = Executors.newFixedThreadPool(3);<br>CompletableFuture&lt;Rest&gt; checkRest = CompletableFuture.supplyAsync(() -&gt; this.checkSoHeadInfo(soHeadFormDTO), executorService);<br>CompletableFuture&lt;Rest&gt; checkSceneRest = CompletableFuture.supplyAsync(() -&gt; this.checkSceneInfo(soHeadFormDTO), executorService);<br>CompletableFuture&lt;Rest&gt; saveRest = checkRest.thenCombine(checkSceneRest, (s1, s2) -&gt; {<br>    &#47;&#47; 校验失败，返回错误信息<br>    if (s1.getReturnCode() != 0) {<br>        return s1;<br>    }<br>    &#47;&#47; 校验失败，返回错误信息<br>    if (s2.getReturnCode() != 0) {<br>        return s2;<br>    }<br>    &#47;&#47; 执行保存<br>    save();<br>}<br>现在存在一个问题，主线程能根据工具类 UserUtil.getUser(); 获取到 user，但是在子线程中，却获取不到，会抛出空指针。<br>请问老师还有各位大佬，能帮忙分析下什么原因吗，谢谢<br>","like_count":0,"discussions":[{"author":{"id":1600341,"avatar":"https://static001.geekbang.org/account/avatar/00/18/6b/55/2b0f219b.jpg","nickname":"Geek_42f729","note":"","ucode":"76CFFF9DEDDF96","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556383,"discussion_content":"猜想：UserUtil如果是使用ThreadLocal存储user，那么子线程获取的值就为null；","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647336224,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":305682,"user_name":"Geek_Black","can_delete":false,"product_type":"c1","uid":2583432,"ip_address":"","ucode":"8CFB324D281FC5","user_header":"https://static001.geekbang.org/account/avatar/00/27/6b/88/6315d04c.jpg","comment_is_top":false,"comment_ctime":1628118022,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628118022","product_id":100023901,"comment_content":"烧水泡茶 3个线程池  需要保证里面线程安全吗","like_count":0},{"had_liked":false,"id":297343,"user_name":"jiaobuchongจุ๊บ","can_delete":false,"product_type":"c1","uid":1118938,"ip_address":"","ucode":"0AEE4E579DC3A2","user_header":"https://static001.geekbang.org/account/avatar/00/11/12/da/a3ea305f.jpg","comment_is_top":false,"comment_ctime":1623470039,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623470039","product_id":100023901,"comment_content":"异步编程，还有一个 reactor core","like_count":0},{"had_liked":false,"id":295333,"user_name":"xieyue","can_delete":false,"product_type":"c1","uid":1831599,"ip_address":"","ucode":"D792F5C5F3F2EA","user_header":"https://static001.geekbang.org/account/avatar/00/1b/f2/af/4f5f6d1e.jpg","comment_is_top":false,"comment_ctime":1622372146,"is_pvip":false,"replies":[{"id":"107965","content":"<br>PPT","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1623409871,"ip_address":"","comment_id":295333,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1622372146","product_id":100023901,"comment_content":"文章中使用的绘图工具是什么呀，感觉挺好的，想学习一下","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521038,"discussion_content":"\nPPT","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623409871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":292205,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1620720999,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620720999","product_id":100023901,"comment_content":"DB链接资源宝贵，不建议使用多线程链接DB查询。应该单独一个线程查询出来，然后资源共享","like_count":0},{"had_liked":false,"id":287300,"user_name":"24","can_delete":false,"product_type":"c1","uid":1189580,"ip_address":"","ucode":"F09DF49B6254E8","user_header":"https://static001.geekbang.org/account/avatar/00/12/26/cc/719aec6d.jpg","comment_is_top":false,"comment_ctime":1617872450,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617872450","product_id":100023901,"comment_content":"&#47;&#47;任务3：任务1和任务2完成后执行：泡茶<br>CompletableFuture f3 = f1.thenCombine(f2, (__, tf)-&gt;{ <br>System.out.println(&quot;T1:拿到茶叶:&quot; + tf); <br>System.out.println(&quot;T1:泡茶...&quot;); <br>return &quot;上茶:&quot; + tf; });<br>(__, tf)这里 __ 是 T1 的结果， tf 应该是 T2 的结果，sout 中应该是 T2 拿到茶叶吧","like_count":0},{"had_liked":false,"id":283998,"user_name":"张申傲","can_delete":false,"product_type":"c1","uid":1182372,"ip_address":"","ucode":"22D46BC529BA8A","user_header":"https://static001.geekbang.org/account/avatar/00/12/0a/a4/828a431f.jpg","comment_is_top":false,"comment_ctime":1616033702,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1616033702","product_id":100023901,"comment_content":"公司的项目中，经常利用 CompletableFuture 进行大规模批量查询，首先将入参进行 partition，然后使用 CompletableFuture 进行异步并发查询，最后用 join 聚合查询结果，本质上就是 fork-join 模式。","like_count":0},{"had_liked":false,"id":283574,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1096397,"ip_address":"","ucode":"14C0858C413E00","user_header":"https://static001.geekbang.org/account/avatar/00/10/ba/cd/1f91aa44.jpg","comment_is_top":false,"comment_ctime":1615821783,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615821783","product_id":100023901,"comment_content":"CompletableFuture是否可以实现工作流类似功能，根据前一个任务结果，判断是否继续下一个任务","like_count":0},{"had_liked":false,"id":278182,"user_name":"旅途","can_delete":false,"product_type":"c1","uid":1212902,"ip_address":"","ucode":"5022477E8E9441","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/e6/6cafed37.jpg","comment_is_top":false,"comment_ctime":1612791731,"is_pvip":false,"replies":[{"id":"101056","content":"没有问题，只是写多了难以理解。就像非结构化程序设计也没问题一样，这是个工程问题","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1612868639,"ip_address":"","comment_id":278182,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1612791731","product_id":100023901,"comment_content":"老师 问一下关于回调地狱的问题 ,回调和正常面向过程调用不都是嵌套方法吗，为什么回调会有问题","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515306,"discussion_content":"没有问题，只是写多了难以理解。就像非结构化程序设计也没问题一样，这是个工程问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612868639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":278041,"user_name":"夏目🐳","can_delete":false,"product_type":"c1","uid":1101227,"ip_address":"","ucode":"4ED932E1F66F76","user_header":"https://static001.geekbang.org/account/avatar/00/10/cd/ab/1c3dc64b.jpg","comment_is_top":false,"comment_ctime":1612714826,"is_pvip":false,"replies":[{"id":"100949","content":"我也搞不定😂","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1612780972,"ip_address":"","comment_id":278041,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1612714826","product_id":100023901,"comment_content":"老师可以讲下flowAPI吗，工作中任务调度用的比较多～","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515262,"discussion_content":"我也搞不定😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612780972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":275225,"user_name":"喃寻","can_delete":false,"product_type":"c1","uid":1565085,"ip_address":"","ucode":"E31B3660726671","user_header":"https://static001.geekbang.org/account/avatar/00/17/e1/9d/3ec0adec.jpg","comment_is_top":false,"comment_ctime":1611397764,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1611397764","product_id":100023901,"comment_content":"1.没有处理异常<br>2.这部分数据库查询需要指定线程池","like_count":0},{"had_liked":false,"id":274919,"user_name":"沫非","can_delete":false,"product_type":"c1","uid":1237305,"ip_address":"","ucode":"2D95C7FDCBEFD5","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/39/86b611b8.jpg","comment_is_top":false,"comment_ctime":1611218093,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611218093","product_id":100023901,"comment_content":"学完这个才感觉学习RxJava的重要性，之前看的云里雾里就放弃了使用，要拿起来了","like_count":0},{"had_liked":false,"id":272366,"user_name":"prepared","can_delete":false,"product_type":"c1","uid":1194853,"ip_address":"","ucode":"00E54A5C7CDCBE","user_header":"https://static001.geekbang.org/account/avatar/00/12/3b/65/3a4fc8cf.jpg","comment_is_top":false,"comment_ctime":1610069793,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610069793","product_id":100023901,"comment_content":"线程数=cpu核数，这里不对，应该是（cpu核数-1）<br>查看 ForkJoinPool源码 makeCommonPool 方法<br>parallelism = Runtime.getRuntime().availableProcessors() - 1<br><br>","like_count":0},{"had_liked":false,"id":265464,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1606905613,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606905613","product_id":100023901,"comment_content":"今天在公司的库里看到了使用competablefuture还是有点小激动的","like_count":0},{"had_liked":false,"id":238892,"user_name":"杨春鹏","can_delete":false,"product_type":"c1","uid":1172056,"ip_address":"","ucode":"518F38232F97B5","user_header":"https://static001.geekbang.org/account/avatar/00/11/e2/58/8c8897c8.jpg","comment_is_top":false,"comment_ctime":1596358245,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1596358245","product_id":100023901,"comment_content":"老师，我现在的场景是3个人任务是并行处理，等待3个任务都执行成功，然后执行第4个任务，这个如何使用串行和汇聚来实现呢。汇聚貌似只适用2个任务并行处理","like_count":0,"discussions":[{"author":{"id":1282819,"avatar":"","nickname":"尼糯米","note":"","ucode":"04D1B63F3801AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308391,"discussion_content":"CompletableFuture cf1 = CompletableFuture.runAsync(action, executor);\nCompletableFuture cf2 = CompletableFuture.runAsync(action, executor);\nCompletableFuture cf3 = CompletableFuture.runAsync(action, executor);\nCompletableFuture.allOf(cf1, cf2, cf3).thenRun(action)","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1600936673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":227937,"user_name":"Chenj847","can_delete":false,"product_type":"c1","uid":1178468,"ip_address":"","ucode":"9F0FAF9E2CB8EB","user_header":"https://static001.geekbang.org/account/avatar/00/11/fb/64/53f68bdb.jpg","comment_is_top":false,"comment_ctime":1592528609,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592528609","product_id":100023901,"comment_content":"老师您好，如果是jdk1.8异步调用使用自定义线程池，但是又需要得到返回结果，如果使用get相当于又阻塞了，有没有合适的解决方案","like_count":0},{"had_liked":false,"id":202997,"user_name":"女巫在寒江","can_delete":false,"product_type":"c1","uid":1013180,"ip_address":"","ucode":"B3707072224C1C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/bc/664bbdf7.jpg","comment_is_top":false,"comment_ctime":1586100144,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1586100144","product_id":100023901,"comment_content":"从本课提到的内容来检查问题：<br>1. 没有对任务进行分类 去查询数据库是个IO比较慢的操作，可能阻塞线程池<br>2. 没有进行异常处理<br>3.查出来的规则为空时，没有相应处理","like_count":0},{"had_liked":false,"id":199497,"user_name":"孟令超","can_delete":false,"product_type":"c1","uid":1433609,"ip_address":"","ucode":"37916911C0F9D9","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/09/eb3da11d.jpg","comment_is_top":false,"comment_ctime":1585490226,"is_pvip":false,"replies":[{"id":"76114","content":"建议自己撸一遍，这样的收获是不一样的","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1586257504,"ip_address":"","comment_id":199497,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585490226","product_id":100023901,"comment_content":"老师课程代码能公开下吗","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489840,"discussion_content":"建议自己撸一遍，这样的收获是不一样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586257504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190983,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1584715765,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584715765","product_id":100023901,"comment_content":"温故而知新，每次看都觉得比上一次清晰很多","like_count":0},{"had_liked":false,"id":187644,"user_name":"wking","can_delete":false,"product_type":"c1","uid":1294634,"ip_address":"","ucode":"47D52E4280D1E6","user_header":"https://static001.geekbang.org/account/avatar/00/13/c1/2a/e7102065.jpg","comment_is_top":false,"comment_ctime":1584180693,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584180693","product_id":100023901,"comment_content":"老师，请问一下，读数据库操作为什么要放在线程池里面？","like_count":0},{"had_liked":false,"id":182724,"user_name":"阿拉丁灯","can_delete":false,"product_type":"c1","uid":1277094,"ip_address":"","ucode":"59664187E74917","user_header":"https://static001.geekbang.org/account/avatar/00/13/7c/a6/93a0f6f8.jpg","comment_is_top":false,"comment_ctime":1582856089,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"1582856089","product_id":100023901,"comment_content":"&#47;&#47;任务3：任务1和任务2完成后执行：泡茶CompletableFuture f3 = f1.thenCombine(f2, (__, tf)-&gt;{ System.out.println(&quot;T1:拿到茶叶:&quot; + tf); System.out.println(&quot;T1:泡茶...&quot;); return &quot;上茶:&quot; + tf; });<br>请问f2的返回值‘龙井’为啥传给了tf，而不是__这个变量呢？","like_count":0,"discussions":[{"author":{"id":1189580,"avatar":"https://static001.geekbang.org/account/avatar/00/12/26/cc/719aec6d.jpg","nickname":"24","note":"","ucode":"F09DF49B6254E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365736,"discussion_content":"我觉得是老师写错了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617872514,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1613123,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9d/43/bf628743.jpg","nickname":"Cyber","note":"","ucode":"A7842494F57D0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296008,"discussion_content":"CompletableFuture<String> f3 = f1.thenCombine(f2, (t1, tf)->{      t1:f1的返回值，tf:f2的返回值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596425716,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1613123,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9d/43/bf628743.jpg","nickname":"Cyber","note":"","ucode":"A7842494F57D0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296007,"discussion_content":"public class CompletableFutureDemo {\n\t\n\tpublic static void main(String[] args) {\n//\t\t// 任务1：洗水壶->烧开水\n//\t\tCompletableFuture<Void> f1 = CompletableFuture.runAsync(() -> {\n//\t\t\tSystem.out.println(&#34;T1:洗水壶...&#34;);\n//\t\t\tsleep(1, TimeUnit.SECONDS);\n//\n//\t\t\tSystem.out.println(&#34;T1:烧开水...&#34;);\n//\t\t\tsleep(15, TimeUnit.SECONDS);\n//\t\t});\n\t\t\n\t\tCompletableFuture<String> f1 = CompletableFuture.supplyAsync(() -> {\n\t\t\tSystem.out.println(&#34;T1:洗水壶...&#34;);\n\t\t\tsleep(1, TimeUnit.SECONDS);\n\n\t\t\tSystem.out.println(&#34;T1:烧开水...&#34;);\n\t\t\tsleep(10, TimeUnit.SECONDS);\n\t\t\t\n\t\t\treturn &#34;fsds&#34;;\n\t\t});\n\n\t\t// 任务2：洗茶壶->洗茶杯->拿茶叶\n\t\tCompletableFuture<String> f2 = CompletableFuture.supplyAsync(() -> {\n\t\t\tSystem.out.println(&#34;T2:洗茶壶...&#34;);\n\t\t\tsleep(1, TimeUnit.SECONDS);\n\n\t\t\tSystem.out.println(&#34;T2:洗茶杯...&#34;);\n\t\t\tsleep(2, TimeUnit.SECONDS);\n\n\t\t\tSystem.out.println(&#34;T2:拿茶叶...&#34;);\n\t\t\tsleep(1, TimeUnit.SECONDS);\n\t\t\treturn &#34;龙井&#34;;\n\t\t});\n\t\t\n\t\t//任务3：任务1和任务2完成后执行：泡茶    用下划线表示不用的参数  t1:f1的返回值，tf代表f2的返回值\n\t\tCompletableFuture<String> f3 = f1.thenCombine(f2, (t1, tf)->{\n\t\t\t\n\t\t\tSystem.out.println(&#34;t1:&#34; + t1);\n\t\t    System.out.println(&#34;T1:拿到茶叶:&#34; + tf);\n\t\t    System.out.println(&#34;T1:泡茶...&#34;);\n\t\t    return &#34;上茶:&#34; + tf;\n\t\t  });\n\t\t\n\t\t//等待任务3执行结果\n\t\tSystem.out.println(f3.join());\n\t}\n\n\t\n\t\n\t\n\t\n\t\n\n\tstatic void sleep(int t, TimeUnit u) {\n\t\ttry {\n\t\t\tu.sleep(t);\n\t\t} catch (InterruptedException e) {\n\t\t}\n\t}\n\n}\n\n\nT1:洗水壶...\nT2:洗茶壶...\nT2:洗茶杯...\nT1:烧开水...\nT2:拿茶叶...\nt1:fsds\nT1:拿到茶叶:龙井\nT1:泡茶...\n上茶:龙井","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596425673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1613123,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9d/43/bf628743.jpg","nickname":"Cyber","note":"","ucode":"A7842494F57D0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296005,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596424989,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162677,"user_name":"江楠大盗","can_delete":false,"product_type":"c1","uid":1241197,"ip_address":"","ucode":"D242C5EF70C176","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo5vic8QksE4b8ricXxKrEWJyOX9pwiadhk3kvHYoLXoKRTWvbFCxibFTbExNQWDG4nvNfpic9t1umibKww/132","comment_is_top":false,"comment_ctime":1576576718,"is_pvip":true,"replies":[{"id":"62404","content":"目前的上下文，我也理解不了😂","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1576910658,"ip_address":"","comment_id":162677,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1576576718","product_id":100023901,"comment_content":"王老师好，其他地方看到说异步 IO 主要是为了控制线程数量，请问怎么理解？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478123,"discussion_content":"目前的上下文，我也理解不了😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576910658,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135877,"user_name":"Sharry","can_delete":false,"product_type":"c1","uid":1239293,"ip_address":"","ucode":"045DDB864659F6","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/fd/035f4c94.jpg","comment_is_top":false,"comment_ctime":1569291768,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569291768","product_id":100023901,"comment_content":"是的, RxJava 已经是 Android 开发者必不可少的一个库了","like_count":0},{"had_liked":false,"id":133468,"user_name":"静水流深","can_delete":false,"product_type":"c1","uid":1339724,"ip_address":"","ucode":"644F05EFBD2E7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/4c/2cefec07.jpg","comment_is_top":false,"comment_ctime":1568589511,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568589511","product_id":100023901,"comment_content":"both-&gt;and,either-&gt;or","like_count":0},{"had_liked":false,"id":131338,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1567727977,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567727977","product_id":100023901,"comment_content":"想要用好还是要看看源码实现","like_count":0},{"had_liked":false,"id":129323,"user_name":"Mr.zhang","can_delete":false,"product_type":"c1","uid":1503968,"ip_address":"","ucode":"52BEF6493C3444","user_header":"https://static001.geekbang.org/account/avatar/00/16/f2/e0/9577744e.jpg","comment_is_top":false,"comment_ctime":1567088345,"is_pvip":false,"replies":[{"id":"48175","content":"Java里的lambda表达式","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1567127748,"ip_address":"","comment_id":129323,"utype":1}],"discussion_count":6,"race_medal":0,"score":"1567088345","product_id":100023901,"comment_content":"老师您好，我想请问一下：(__, tf)-&gt;{ }，这是一种什么用法呢？括号中的__是什么意思呢？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465400,"discussion_content":"Java里的lambda表达式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567127748,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1503968,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f2/e0/9577744e.jpg","nickname":"Mr.zhang","note":"","ucode":"52BEF6493C3444","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6817,"discussion_content":"整体我知道是一个lambda表达式，我对其中的双下划线参数比较好奇，我debug出来之后是个空字符串，我把双下划线替换成：aa，bb之类的，运行是并没有什么区别。那我应该怎么理解这个双下划线参数呢？是把它当做与aa,bb此类同样的参数变量名吗？谢谢老师","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567128966,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1217874,"avatar":"https://static001.geekbang.org/account/avatar/00/12/95/52/ad190682.jpg","nickname":"Mr wind","note":"","ucode":"484F02D1962239","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1503968,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f2/e0/9577744e.jpg","nickname":"Mr.zhang","note":"","ucode":"52BEF6493C3444","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":138156,"discussion_content":"可以当成一样的，因为它只是你起的一个变量名，jvm会自己做类型推断","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1579226182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":6817,"ip_address":""},"score":138156,"extra":""},{"author":{"id":1579698,"avatar":"","nickname":"wangwe","note":"","ucode":"24F9574044565D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1503968,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f2/e0/9577744e.jpg","nickname":"Mr.zhang","note":"","ucode":"52BEF6493C3444","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213850,"discussion_content":"我猜是因为这个变量没有用到，不知道起什么名字合适，所以写了两个下划线。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1585127744,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":6817,"ip_address":""},"score":213850,"extra":""},{"author":{"id":1189580,"avatar":"https://static001.geekbang.org/account/avatar/00/12/26/cc/719aec6d.jpg","nickname":"24","note":"","ucode":"F09DF49B6254E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1579698,"avatar":"","nickname":"wangwe","note":"","ucode":"24F9574044565D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365737,"discussion_content":"我觉得是 T1 的返回是 Void 类型，这个变量用 __ 表示比较显著","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1617872756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":213850,"ip_address":""},"score":365737,"extra":""}]},{"author":{"id":1529210,"avatar":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","nickname":"freesocean","note":"","ucode":"CAD4C80CF569D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577823,"discussion_content":"试了下，java变量命名允许以下划线，字母，$开头，这里其实就是个变量名，只是变量返回值为空，用__表示不可用参数，可读性好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656375938,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123928,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1565782296,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1565782296","product_id":100023901,"comment_content":"老师，您好！<br>请教一下，如何 combine 多个 CompletableFuture，并且获取合并之后的结果呀？<br>除了下面的实现，不知道还有没有更优雅的实现方式呢？<br>谢谢老师！<br><br>----<br><br>public static void main(String[] args) {<br>  CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; {<br>    sleep(5000);<br>    return &quot;Hello&quot;;<br>  });<br>  CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; {<br>    sleep(8000);<br>    return &quot;Beautiful&quot;;<br>  });<br>  CompletableFuture&lt;String&gt; future3 = CompletableFuture.supplyAsync(() -&gt; {<br>    sleep(1000);<br>    return &quot;World&quot;;<br>  });<br><br>  &#47;&#47; CompletableFuture&lt;Void&gt; combinedFuture = CompletableFuture.allOf(future1, future2, future3);<br><br>  &#47;&#47; 方式一<br>  String combine = future1.thenCombine(future2, (s1, s2) -&gt; s1 + &quot;,&quot; + s2)<br>                          .thenCombine(future3, (s1, s2) -&gt; s1 + &quot;,&quot; + s2)<br>                          .exceptionally(throwable -&gt; &quot;&quot;)<br>                          .join();<br>  System.out.println(combine);<br><br>  &#47;&#47; 方式二<br>  List&lt;CompletableFuture&lt;String&gt;&gt; list = new ArrayList&lt;&gt;(3);<br>  list.add(future1);<br>  list.add(future2);<br>  list.add(future3);<br><br>  StringBuilder sb = new StringBuilder();<br>  for (CompletableFuture&lt;String&gt; future : list) {<br>    if (sb.length() &gt; 0) {<br>      sb.append(&quot;,&quot;);<br>    }<br>    sb.append(future.join());<br>  }<br>  System.out.println(sb.toString());<br>}","like_count":0,"discussions":[{"author":{"id":1351012,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/64/272dc1b7.jpg","nickname":"圆滚滚","note":"","ucode":"E4D81822A87D50","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":75625,"discussion_content":"这个流程和想要达到的还是不一致","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575735444,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1351012,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/64/272dc1b7.jpg","nickname":"圆滚滚","note":"","ucode":"E4D81822A87D50","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":75624,"discussion_content":"想知道","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575735408,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115021,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1563454861,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563454861","product_id":100023901,"comment_content":"老师，您好！<br>文中提到：thenCompose 系列方法会新创建出一个子流程，最终结果和 thenApply 系列是相同的。<br><br>thenCompose 和 thenApply 最终执行效果一样，在实际使用中有什么区别，或者说创建子流程，这么设计的目的是啥？<br><br>谢谢老师！！","like_count":0},{"had_liked":false,"id":95859,"user_name":"大卫","can_delete":false,"product_type":"c1","uid":1019127,"ip_address":"","ucode":"D861709E483793","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/f7/a4de6f64.jpg","comment_is_top":false,"comment_ctime":1558234615,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558234615","product_id":100023901,"comment_content":"王老师，您好。<br>目前业务场景我觉得适合用completablefuture，一个详情页，动态接口，会调用多个上游接口做聚合，部分接口之间有依赖。<br>这些上游分别是不同业务线的，比如搜索、推荐、会员、用户、其他等。<br>问题1:您建议是每个业务线都是要建立独立的线程池？还是说几个业务线一个线程池?  <br>问题2:这种一般是要按io密集型设置cpu大小吧，cpu核数 *（1-0.9），参考网上的0.9阻塞系数，合适么? <br>问题3:每个业务独立线程池，同一个jvm中会不会线程数量太大了，有什么额外影响吗?<br><br>谢谢","like_count":0},{"had_liked":false,"id":94688,"user_name":"xuery","can_delete":false,"product_type":"c1","uid":1027584,"ip_address":"","ucode":"F461B61BE06131","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/00/025f37e7.jpg","comment_is_top":false,"comment_ctime":1557882344,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1557882344","product_id":100023901,"comment_content":"Completable使用注意事项：1.不同的业务场景最好指定单独的线程池，避免相互影响<br>2.记得考虑异常处理<br>","like_count":0},{"had_liked":false,"id":90664,"user_name":"Sunqc","can_delete":false,"product_type":"c1","uid":1473717,"ip_address":"","ucode":"2C54659635403F","user_header":"https://static001.geekbang.org/account/avatar/00/16/7c/b5/4a7a2bd4.jpg","comment_is_top":false,"comment_ctime":1556604226,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556604226","product_id":100023901,"comment_content":"评论区那个从多张表查数据然后验证保存到一张表。分页每次次读1000条数据的话<br>1.采用线程池+future，每次提交的任务结果保存到一个队列里，然后执行任务取队列结果执行保存；或者不采用队列<br>2.采用completionservice<br>3.就是这节的主题completionfuture<br><br>老师，您看重点前两个方案可行吗，compelerion处理批量操作，会不会大材小用的感觉啊哈哈<br>这个线程池里线程数多大才合适呢","like_count":0},{"had_liked":false,"id":90290,"user_name":"aroll","can_delete":false,"product_type":"c1","uid":1023524,"ip_address":"","ucode":"3A1A1267C88CC3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9e/24/0d6a7987.jpg","comment_is_top":false,"comment_ctime":1556467267,"is_pvip":false,"replies":[{"id":"32350","content":"找到原因就好","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556498572,"ip_address":"","comment_id":90290,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556467267","product_id":100023901,"comment_content":"嗯对，我以log的打印为准了，log打印结束并不代表主线程已经结束了，还是有个时间差，这个时候子线程还会运行一段时间，感谢老师","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448455,"discussion_content":"找到原因就好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556498572,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89963,"user_name":"aroll","can_delete":false,"product_type":"c1","uid":1023524,"ip_address":"","ucode":"3A1A1267C88CC3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9e/24/0d6a7987.jpg","comment_is_top":false,"comment_ctime":1556350136,"is_pvip":false,"replies":[{"id":"32330","content":"我把sleep部分去掉，for改成while true，主线程结束，子线程还是能结束的。是不是log的锅？","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556463208,"ip_address":"","comment_id":89963,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556350136","product_id":100023901,"comment_content":"是的，启动前设置成守护线程了，就像这样<br>public static void main(String[] args){<br>    Thread thread = new Thread(new Runnable() {<br>        @Override<br>        public void run() {<br>             for(int i=0;i&lt;10;i++){<br>                 try {<br>                     Thread.sleep(1);<br>                 } catch (InterruptedException e) {<br>                     e.printStackTrace();<br>                 }<br>                 log.info(&quot;子线程执行任务&quot;+i);<br>             }<br>        }<br>    });<br>    thread.setDaemon(true);<br>    thread.start();<br>    for (int j=0;j&lt;3;j++){<br>        log.info(&quot;主线程执行任务&quot;+j);<br>    }<br>    log.info(&quot;运行结束&quot;);<br>}<br>    如果把sleep部分去掉，即使设成守护线程，主线程结束后子线程仍不会结束","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448339,"discussion_content":"我把sleep部分去掉，for改成while true，主线程结束，子线程还是能结束的。是不是log的锅？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556463208,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89731,"user_name":"aroll","can_delete":false,"product_type":"c1","uid":1023524,"ip_address":"","ucode":"3A1A1267C88CC3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9e/24/0d6a7987.jpg","comment_is_top":false,"comment_ctime":1556251168,"is_pvip":false,"replies":[{"id":"32183","content":"启动之前设置成守护线程了？","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556280844,"ip_address":"","comment_id":89731,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556251168","product_id":100023901,"comment_content":"老师想请教您一个问题，我创建了一个用户线程然后将它设置为守护线程，为什么主线程结束时，它没有结束，需要在它的执行逻辑里调用sleep才会当主线程结束时结束。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448240,"discussion_content":"启动之前设置成守护线程了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556280844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89324,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1556154697,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556154697","product_id":100023901,"comment_content":"很喜欢这个专栏!<br><br>但是，老师说 教好学生，饿死师傅。 我……😭😭😭","like_count":0},{"had_liked":false,"id":88922,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1556027286,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556027286","product_id":100023901,"comment_content":"我认为思考题的问题是返回值不统一，结果是布尔值，但串行的第一步返回值不确定。","like_count":0},{"had_liked":false,"id":88897,"user_name":"曾轼麟","can_delete":false,"product_type":"c1","uid":1451391,"ip_address":"","ucode":"D418371AC11270","user_header":"https://static001.geekbang.org/account/avatar/00/16/25/7f/473d5a77.jpg","comment_is_top":false,"comment_ctime":1556023190,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556023190","product_id":100023901,"comment_content":"check和findrule应该要并行执行才对","like_count":0},{"had_liked":false,"id":88743,"user_name":"ZOU志伟","can_delete":false,"product_type":"c1","uid":1029179,"ip_address":"","ucode":"439779871CC992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b4/3b/a1f7e3a4.jpg","comment_is_top":false,"comment_ctime":1555989055,"is_pvip":false,"replies":[{"id":"31823","content":"java8 lambda","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556028752,"ip_address":"","comment_id":88743,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555989055","product_id":100023901,"comment_content":"想知道()-&gt;是什么用法？哪里有介绍","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447888,"discussion_content":"java8 lambda","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556028752,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":88691,"user_name":"walkingonair","can_delete":false,"product_type":"c1","uid":1444748,"ip_address":"","ucode":"0C8BEE064ABF8B","user_header":"https://static001.geekbang.org/account/avatar/00/16/0b/8c/db1ee0a2.jpg","comment_is_top":false,"comment_ctime":1555982969,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555982969","product_id":100023901,"comment_content":"之前讲理论理解的不够透彻，印象也不深刻，现在讲到具体实现，渐入佳境，感谢老师！","like_count":0},{"had_liked":false,"id":88676,"user_name":"undifined","can_delete":false,"product_type":"c1","uid":1068920,"ip_address":"","ucode":"449CB4CD2DC089","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/78/c3d8ecb0.jpg","comment_is_top":false,"comment_ctime":1555981658,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555981658","product_id":100023901,"comment_content":"课后题只找到一个问题：PurchersOrder po没有初始化，而这个对象在异步线程中是 final 的，老师还有其他的问题吗","like_count":0},{"had_liked":false,"id":88674,"user_name":"周治慧","can_delete":false,"product_type":"c1","uid":1335293,"ip_address":"","ucode":"7D56C4E66BEE17","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKR3ibELhjgVicCNShZCBwvaDxibnzibggG4wUzVkS2mkDxUBZyIs87nDEdJ7PiahJBVoZcuhQ84RxAziag/132","comment_is_top":false,"comment_ctime":1555981423,"is_pvip":false,"replies":[{"id":"31992","content":"火眼金睛👍","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1556156614,"ip_address":"","comment_id":88674,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555981423","product_id":100023901,"comment_content":"在第3快描述or聚合的时候，第二个f1应该是f2。关于思考题，在进行数据校验时依赖查询规则的查询结果是个串行操作，但是需要对异常进行处理","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447862,"discussion_content":"火眼金睛👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556156614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":88664,"user_name":"永联","can_delete":false,"product_type":"c1","uid":1255535,"ip_address":"","ucode":"6E3A0598ECBB09","user_header":"https://static001.geekbang.org/account/avatar/00/13/28/6f/8d12534a.jpg","comment_is_top":false,"comment_ctime":1555980640,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555980640","product_id":100023901,"comment_content":"既然是异步执行，也就是被别的线程执行，订单po 的可视性不能保证。","like_count":0},{"had_liked":false,"id":88646,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1555978588,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555978588","product_id":100023901,"comment_content":"打卡！","like_count":0},{"had_liked":false,"id":88644,"user_name":"Alvin","can_delete":false,"product_type":"c1","uid":1310234,"ip_address":"","ucode":"DB22A2AD2D4F40","user_header":"","comment_is_top":false,"comment_ctime":1555978567,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555978567","product_id":100023901,"comment_content":"没处理异常","like_count":0},{"had_liked":false,"id":88633,"user_name":"ack","can_delete":false,"product_type":"c1","uid":1440912,"ip_address":"","ucode":"69CA1233EEA8E2","user_header":"https://static001.geekbang.org/account/avatar/00/15/fc/90/c9df0459.jpg","comment_is_top":false,"comment_ctime":1555977179,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555977179","product_id":100023901,"comment_content":"在数据库中查询规则 和  规则校验是串行关系。而规则查询没有<br>传入参数说明这个规则是通用的，上面的方法采用的是串行查询的<br>方式，那么每次都要查询一次这个通用的规则，我的理解是改成如下：<br><br>PurchersOrder po;<br><br>CompletableFuture&lt;Rule&gt; f1 = <br>\tCompletableFuture.supplyAsync(()-&gt;{<br>\t\t&#47;&#47; 在数据库中查询规则<br>\t\treturn findRuleByJdbc();<br>\t });<br> <br>CompletableFuture&lt;Boolean&gt; f2 = <br>\tCompletableFuture.supplyAsync(()-&gt;{<br>\t\t&#47;&#47; 在数据库中查询规则<br>\t\treturn check(po, f1.join());<br>\t });<br> <br>Boolean isOk = f2.join();<br>","like_count":0},{"had_liked":false,"id":88612,"user_name":"SMTCode","can_delete":false,"product_type":"c1","uid":1109038,"ip_address":"","ucode":"0D837A753E4FAB","user_header":"https://static001.geekbang.org/account/avatar/00/10/ec/2e/49d13bd2.jpg","comment_is_top":false,"comment_ctime":1555961609,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1555961609","product_id":100023901,"comment_content":"这个例子中不应该使用串行关系的thenApply，应该使用AND汇聚关系的thenCombine吧？","like_count":0}]}