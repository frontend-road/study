{"id":252107,"title":"21 | 知识串讲（上）：带你开发一个书店应用","content":"<p>你好，我是Chrono。</p><p>到今天为止，课程里的C++知识就全部讲完了。前面我们总共学习了四大模块，我再带你做一个简略的回顾。</p><p>在“概论”单元，我带你从宏观的层面上重新认识了C++，讲了它的四个生命周期和五个编程范式，分别介绍了在编码阶段、预处理阶段、编译阶段，C++能够做哪些事情，接着又重点说了在C++里，运用哪些特性才能更好地实践面向对象编程。</p><p>在“语言特性”单元，我们一起研究了自动类型推导、常量、智能指针、异常、函数式编程这五个特性。这些特性是“现代”C++区别于“传统”C++的关键，掌握了它们，你就能够写出清晰、易读、安全的代码。</p><p>在“标准库”单元，我介绍了字符串、容器、算法和并发。它们是C++标准库中最核心的部分，也是现代C++和泛型编程的最佳应用和范例。学会了标准库，你才能说是真正理解了C++。</p><p>在“技能进阶”单元，我为你挑选出了一些第三方工具，包括序列化、网络通信、脚本语言和性能分析，它们很好地补充完善了C++语言和标准库，免去了我们“自己造轮子”的麻烦，让我们把精力集中在实现业务逻辑上。</p><p>除了上面的这“十八般武艺”，我还谈了谈能够帮你更好地运用C++的设计模式和设计原则，介绍了几个比较重要、常用的模式，希望你在今后的实际开发工作中，能够有意识地写出灵活、可扩展的代码。</p><!-- [[[read_end]]] --><p>这么回顾下来，内容还真是不少啊。</p><p>为了让你更好地把这些知识融会贯通，接下来我会再用两节课的时间，从需求、设计，到开发编码、编译运行，再加上一些我自己的实用小技巧，详细讲解一个C++程序的实际开发过程，把知识点都串联起来。</p><p>虽然说是“串讲”，但是你只要学过了前面的内容，就可以跟着我做出这个书店程序。不过，我担心有些知识点你可能忘记了，所以，涉及到具体的知识点时，我会给你标注出是在哪一节，你可以随时回去复习一下。</p><h2>项目设计</h2><p>那么，该用个什么样的例子来串讲C++的这些知识点呢？</p><p>说实话，找出一个合适的例子真的很难。因为大多数C++实际项目都很大、很底层，还有各种依赖或者内部库，不好直接学习研究。</p><p>所以我再三考虑，决定借鉴一下  <em>C++ Primer</em> 里的书店例子，修改一下它的需求，然后完全重新开发，作为我们这个课程的综合示例。</p><p>先介绍一下咱们这个书店程序。简单来说，就是销售记录管理，从多个渠道把书号、销售册数、销售额都汇总起来，做个统计分析，再把数据定期上报到后台。</p><p><em>C++ Primer</em>  里的书店程序是本地运行的，为了演示课程里讲到的的C++特性，我把它改成了网络版。不过，拓扑结构并不复杂，我画了张图，你可以看一下。</p><p><img src=\"https://static001.geekbang.org/resource/image/62/97/62632ba7426af7731902c83724504097.png?wh=3306*2825\" alt=\"\"></p><p>项目的前期需求就算是定下来了，接着就要开始做设计了，这就要用到设计模式和设计原则的知识了（<a href=\"https://time.geekbang.org/column/article/248880\">第19讲</a>、<a href=\"https://time.geekbang.org/column/article/248883\">第20讲</a>）。</p><p>不过这个系统还是比较简单的，不需要用什么复杂的分析手段，就能够得出设计，主要应用的是单一职责原则、接口隔离原则和包装外观模式。这里我也画了一个UML图，可以帮助你理解程序的架构。</p><p><img src=\"https://static001.geekbang.org/resource/image/f0/ef/f08637cf6b49316c230d058cb2a9f5ef.jpg?wh=792*525\" alt=\"\"></p><p>下面我就对照这个UML类图，结合开发思路和源码，仔细说一下具体的C++开发，完整的源码都放在了<a href=\"https://github.com/chronolaw/cpp_study/tree/master/section5\">GitHub</a>上，课下可以仔细地看一下。</p><h2>核心头文件</h2><p>首先要说的是我写C++项目的一个习惯，定义核心头文件：<strong>cpplang.hpp</strong>。它集中了C++标准头和语言相关的定义，被用于其他所有的源文件。</p><p>注意，在写它的时候，最好要有文件头注释（<a href=\"https://time.geekbang.org/column/article/233689\">第2讲</a>），而且要有“Include guard”（<a href=\"https://time.geekbang.org/column/article/233711\">第3讲</a>），就像下面这样：</p><pre><code>// Copyright (c) 2020 by Chrono\n\n#ifndef _CPP_LANG_HPP        // Include guard\n#define _CPP_LANG_HPP        // Include guard\n\n#include &lt;cassert&gt;           // C++标准头文件\n...\n\n#endif  //_CPP_LANG_HPP\n</code></pre><p>在核心头文件里，我们还可以利用预处理编程，使用宏定义、条件编译来屏蔽操作系统、语言版本的差异，增强程序的兼容性。</p><p>比如，这里我就检查了C++的版本号，然后定义了简化版的“deprecated”和“static_assert”：</p><pre><code>// must be C++11 or later\n#if __cplusplus &lt; 201103\n#   error &quot;C++ is too old&quot;\n#endif  // __cplusplus &lt; 201103\n\n// [[deprecated]]\n#if __cplusplus &gt;= 201402\n#   define  CPP_DEPRECATED [[deprecated]]\n#else\n#   define  CPP_DEPRECATED [[gnu::deprecated]]\n#endif  // __cplusplus &gt;= 201402\n\n// static_assert\n#if __cpp_static_assert &gt;= 201411\n#   define STATIC_ASSERT(x) static_assert(x)\n#else\n#   define STATIC_ASSERT(x) static_assert(x, #x)\n#endif\n</code></pre><h2>自旋锁</h2><p>有了核心头文件之后，我们的C++程序就有了一个很好的起点，就可以考虑引入多线程，提高吞吐量，减少阻塞。</p><p>在多线程里保护数据一般要用到互斥量（Mutex），但它的代价太高，所以我设计了一个自旋锁，它使用了原子变量，所以成本低，效率高（<a href=\"https://time.geekbang.org/column/article/245259\">第14讲</a>）。</p><p>自旋锁被封装为一个SpinLock类，所以就要遵循一些C++里常用的面向对象的设计准则（<a href=\"https://time.geekbang.org/column/article/235301\">第5讲</a>、<a href=\"https://time.geekbang.org/column/article/248880\">第19讲</a>），比如用final禁止继承、用default/delete显式标记构造/析构函数、成员变量初始化、类型别名，等等，你可以看看代码：</p><pre><code>class SpinLock final                        // 自旋锁类\n{\npublic:\n    using this_type   = SpinLock;          // 类型别名\n    using atomic_type = std::atomic_flag;\npublic:\n    SpinLock() = default;                 // 默认构造函数\n   ~SpinLock() = default;\n\n    SpinLock(const this_type&amp;) = delete;  // 禁止拷贝\n    SpinLock&amp; operator=(const this_type&amp;) = delete;\nprivate:\n    atomic_type m_lock {false};            // 成员变量初始化\n};\n</code></pre><p>在编写成员函数的时候，为了尽量高效，需要给函数都加上noexcept修饰，表示绝不会抛出异常（<a href=\"https://time.geekbang.org/column/article/240292\">第9讲</a>）：</p><pre><code>public:\n  void lock() noexcept              // 自旋锁定，绝不抛出异常\n  {\n    for(;;) {                      // 无限循环\n      if (!m_lock.test_and_set()) { // 原子变量的TAS操作\n          return;                  // TAS成功则锁定\n      }\n      std::this_thread::yield();   // TAS失败则让出线程\n    }\n  }\n\n  void unlock() noexcept           // 解除自旋锁定，绝不抛出异常\n  {\n    m_lock.clear();\n  }\n</code></pre><p>为了保证异常安全，在任何时候都不会死锁，还需要利用RAII技术再编写一个LockGuard类。它在构造时锁定，在析构时解锁，这两个函数也应该用noexcept来优化：</p><pre><code>class SpinLockGuard final                      // 自旋锁RAII类，自动解锁\n{\npublic:\n    using this_type      = SpinLockGuard;      // 类型别名\n    using spin_lock_type = SpinLock;\npublic:\n    SpinLockGuard(const this_type&amp;) = delete;  // 禁止拷贝\n    SpinLockGuard&amp; operator=(const this_type&amp;) = delete;\npublic:\n    SpinLockGuard(spin_lock_type&amp; lock) noexcept\n        : m_lock(lock)\n    {\n        m_lock.lock();\n    }\n\n   ~SpinLockGuard() noexcept\n   {\n       m_lock.unlock();\n   }\nprivate:\n    spin_lock_type&amp; m_lock;\n};\n</code></pre><p>这样自旋锁就完成了，有了它就可以在多线程应用里保护共享的数据，避免数据竞争。</p><h2>网络通信</h2><p>自旋锁比较简单，但多线程只是书店程序的基本特性，它的核心关键词是“网络”，所以下面就来看看服务里的“重头”部分：网络通信。</p><p>正如我之前说的，在现代C++里，应当避免直接使用原生Socket来编写网络通信程序（<a href=\"https://time.geekbang.org/column/article/245900\">第16讲</a>）。这里我选择ZMQ作为底层通信库，它不仅方便易用，而且能够保证消息不丢失、完整可靠地送达目的地。</p><p>程序里使用ZmqContext类来封装底层接口（包装外观），它是一个模板类，整数模板参数用来指定线程数，在编译阶段就固定了ZMQ的多线程处理能力。</p><p>对于ZMQ必需的运行环境变量（单件），我使用了一个小技巧：<strong>以静态成员函数来代替静态成员变量</strong>。这样就绕过了C++的语言限制，不必在实现文件“*.cpp”里再写一遍变量定义，全部的代码都可以集中在hpp头文件里：</p><pre><code>template&lt;int thread_num = 1&gt;        // 使用整数模板参数来指定线程数\nclass ZmqContext final\n{\npublic:\n    static                          // 静态成员函数代替静态成员变量\n    zmq_context_type&amp; context()\n    {\n        static zmq_context_type ctx(thread_num);\n        return ctx;\n    }\n};\n</code></pre><p>然后，我们要实现两个静态工厂函数，创建收发数据的Socket对象。</p><p>这里要注意，如果你看zmq.hpp的源码，就会发现，它的内部实际上是使用了异常来处理错误的。所以，这里我们不能在函数后面加上noexcept修饰，同时也就意味着，在使用ZMQ的时候，必须要考虑异常处理。</p><pre><code>public: \n  static\n  zmq_socket_type recv_sock(int hwm = 1000)    // 创建接收Socket\n  {\n    zmq_socket_type sock(context(), ZMQ_PULL); // 可能抛出异常\n    \n    sock.setsockopt(ZMQ_RCVHWM, hwm);\n\n    return sock;\n  }\n\n  static\n  zmq_socket_type send_sock(int hwm = 1000)   // 创建发送Socket\n  {\n    zmq_socket_type sock(context(), ZMQ_PUSH); // 可能抛出异常\n\n    sock.setsockopt(ZMQ_SNDHWM, hwm);\n\n    return sock;\n  }\n</code></pre><p>现在，有了ZmqContext类，书店程序的网络基础也就搭建出来了，后面就可以用它来收发数据了。</p><h2>配置文件解析</h2><p>接下来，我要说的是解析配置文件的类Config。</p><p>大多数程序都会用到配置文件来保存运行时的各种参数，常见的格式有INI、XML、JSON，等等。但我通常会选择把Lua嵌入C++，用Lua脚本写配置文件（<a href=\"https://time.geekbang.org/column/article/242603\">第17讲</a>）。</p><p>这么做的好处在哪里呢？</p><p>Lua是一个完备的编程语言，所以写起来就非常自由灵活，比如添加任意的注释，数字可以写成“m × n”的运算形式。而INI、XML这些配置格式只是纯粹的数据，很难做到这样，很多时候需要在程序里做一些转换工作。</p><p>另外，在Lua脚本里，我们还能基于Lua环境写一些函数，校验数据的有效性，或者采集系统信息，实现动态配置。</p><p>总而言之，就是把Lua当作一个“可编程的配置语言”，让配置“活起来”。</p><p>给你看一下配置文件的代码吧，里面包含了几个简单的值，配置了服务器的地址、时间间隔、缓冲区大小等信息：</p><pre><code>config = {\n\n    -- should be same as client\n    -- you could change it to ipc\n    zmq_ipc_addr = &quot;tcp://127.0.0.1:5555&quot;,\n\n    -- see http_study's lua code\n    http_addr = &quot;http://localhost/cpp_study?token=cpp@2020&quot;,\n\n    time_interval = 5,  -- seconds\n\n    max_buf_size = 4 * 1024,\n}\n</code></pre><p>Config类使用shared_ptr来管理Lua虚拟机（<a href=\"https://time.geekbang.org/column/article/245905\">第17讲</a>），因为封装在类里，所以，你要注意类型别名和成员变量初始化的用法（<a href=\"https://time.geekbang.org/column/article/235301\">第5讲</a>）：</p><pre><code>class Config final                  // 封装读取Lua配置文件\n{\npublic:\n    using vm_type      = std::shared_ptr&lt;lua_State&gt;;   // 类型别名\n    using value_type   = luabridge::LuaRef;\npublic:\n    Config() noexcept               // 构造函数\n    {\n        assert(m_vm);\n        luaL_openlibs(m_vm.get());  // 打开Lua基本库\n    }\n   ~Config() = default;             // 默认析构函数\nprivate:\n    vm_type     m_vm                 // 类型别名定义Lua虚拟机\n      {luaL_newstate(), lua_close};  // 成员变量初始化\n};\n</code></pre><p>加载Lua脚本的时候还要注意一点，外部的脚本有可能会写错，导致Lua解析失败。但因为这个问题极少出现，而且一出现就很严重，没有配置就无法走后续的流程，所以非常适合用异常来处理（<a href=\"https://time.geekbang.org/column/article/240292\">第9讲</a>）。</p><p>load()函数不会改变虚拟机成员变量，所以应该用const修饰，是一个常函数：</p><pre><code>public:\n  void load(string_view_type filename) const  // 解析配置文件\n  {\n    auto status = luaL_dofile(m_vm.get(), filename.c_str());\n\n    if (status != 0) {                       // 出错就抛出异常\n        throw std::runtime_error(&quot;failed to parse config&quot;);\n    }\n  }\n</code></pre><p>为了访问Lua配置文件里的值，我决定采用“key1.key2”这样简单的两级形式，有点像INI的小节，这也正好对应Lua里的表结构。</p><p>想要解析出字符串里的前后两个key，可以使用正则表达式（<a href=\"https://time.geekbang.org/column/article/242603\">第11讲</a>），然后再去查询Lua表。</p><p>因为构造正则表达式的成本很高，所以我把正则对象都定义为成员变量，而不是函数里的局部变量。</p><p>正则的匹配结果（m_what）是“临时”的，不会影响常量性，所以要给它加上mutable修饰。</p><pre><code>private:\n  const   regex_type  m_reg {R&quot;(^(\\w+)\\.(\\w+)$)&quot;};\n  mutable match_type  m_what;              // 注意是mutable\n</code></pre><p>在C++正则库的帮助下，处理字符串就太轻松了，拿到两个key，再调用LuaBridge就可以获得Lua脚本里的配置项。</p><p>不过，为了进一步简化客户代码，我把get()函数改成了模板函数，显式转换成int、string等C++标准类型，可读性、可维护性会更好。</p><pre><code>public:\n  template&lt;typename T&gt;                    // 转换配置值的类型\n  T get(string_view_type key) const      // const常函数\n  {\n    if (!std::regex_match(key, m_what, m_reg)) {  // 正则匹配\n        throw std::runtime_error(&quot;config key error&quot;);// 格式错误抛异常\n    }\n\n    auto w1 = m_what[1].str();            // 取出两个key\n    auto w2 = m_what[2].str();\n\n    auto v = getGlobal(                  // 获取Lua表\n                m_vm.get(), w1.c_str());\n\n    return LuaRef_cast&lt;T&gt;(v[w2]);        // 取表里的值，再做类型转换\n  }\n</code></pre><p>到这里呢，Config类也就完成了，可以轻松解析Lua格式的配置文件。</p><h2>小结</h2><p>今天，我用一个书店程序作为例子，把前面的知识点都串联起来，应用到了这个“半真实”的项目里，完成了UML类图里的外围部分。你也可以把刚才说的核心头文件、自旋锁、Lua配置文件这些用法放到自己的实际项目里去试试。</p><p>简单小结一下今天的内容：</p><ol>\n<li>在项目起始阶段，应该认真做需求分析，然后应用设计模式和设计原则，得出灵活、可扩展的面向对象系统；</li>\n<li>C++项目里最好要有一个核心头文件（cpplang.hpp），集中定义所有标准头和语言特性，规范源文件里的C++使用方式；</li>\n<li>使用原子变量（atomic）可以实现自旋锁，比互斥量的成本要低，更高效；</li>\n<li>使用ZMQ可以简化网络通信，但要注意它使用了异常来处理错误；</li>\n<li>使用Lua脚本作为配置文件的好处很多，是“可编程的配置文件”；</li>\n<li>在编写代码时要理解、用好C++特性，恰当地使用final、default、const等关键字，让代码更安全、更可读，有利于将来的维护。</li>\n</ol><p>今天，我们分析了需求，设计出了架构，开发了一些工具类，但还没有涉及业务逻辑代码，下节课，我会带你看看容器、算法、线程，还有lambda表达式的实践应用，看看它们是怎么服务于具体业务的。</p><h2>课下作业</h2><p>最后是课下作业时间，给你留一个思考题：你能说出，程序里是怎么应用设计模式和设计原则的吗？</p><p>欢迎你在留言区写下你的思考和答案，如果觉得今天的内容对你有所帮助，也欢迎分享给你的朋友。我们下节课见。</p><p><img src=\"https://static001.geekbang.org/resource/image/9b/e9/9b2d2c8285643a9202d822639fffe8e9.png?wh=3000*2795\" alt=\"\"></p>","neighbors":{"left":{"article_title":"20 | 设计模式（下）：C++是怎么应用设计模式的？","id":248883},"right":{"article_title":"22 | 知识串讲（下）：带你开发一个书店应用","id":252118}},"comments":[{"had_liked":false,"id":229745,"user_name":"yadandan","can_delete":false,"product_type":"c1","uid":1015510,"ip_address":"","ucode":"E81B3151E34D13","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ0ZckW8sqfW8lyWuge29zK8cQ6nY57SQqpwicPEOibicbgOLDX554xHa6OafsSeojRNy5V3wvbTibG6g/132","comment_is_top":false,"comment_ctime":1593136427,"is_pvip":false,"replies":[{"id":"84769","content":"C++要求静态成员变量必须在cpp文件里定义实现，头文件里只是声明。<br><br>而在静态成员函数里声明静态变量，再以函数返回值的形式来使用，就不需要在cpp里重复写一遍，只要在头文件里写就行了。<br><br>课程的示例代码就是这样的，你也可以自己模仿着试一下，用静态成员函数代替静态成员变量。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1593138414,"ip_address":"","comment_id":229745,"utype":1}],"discussion_count":3,"race_medal":0,"score":"57427711275","product_id":100051801,"comment_content":"老师您好，“这样就绕过了 C++ 的语言限制，不必在实现文件“*.cpp”里再写一遍变量定义，全部的代码都可以集中在 hpp 头文件里”，这句话怎么理解，能举个例子吗？","like_count":13,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499623,"discussion_content":"C++要求静态成员变量必须在cpp文件里定义实现，头文件里只是声明。\n\n而在静态成员函数里声明静态变量，再以函数返回值的形式来使用，就不需要在cpp里重复写一遍，只要在头文件里写就行了。\n\n课程的示例代码就是这样的，你也可以自己模仿着试一下，用静态成员函数代替静态成员变量。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1593138414,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1421242,"avatar":"https://static001.geekbang.org/account/avatar/00/15/af/ba/62fac9e1.jpg","nickname":"羽曦","note":"","ucode":"9767ECB4F8F201","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":564461,"discussion_content":"C++要求静态成员变量必须在cpp文件里定义实现，头文件里只是声明。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1650250479,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015510,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ0ZckW8sqfW8lyWuge29zK8cQ6nY57SQqpwicPEOibicbgOLDX554xHa6OafsSeojRNy5V3wvbTibG6g/132","nickname":"yadandan","note":"","ucode":"E81B3151E34D13","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287777,"discussion_content":"谢谢老师耐心解答！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593531965,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":228997,"user_name":"reverse","can_delete":false,"product_type":"c1","uid":1240138,"ip_address":"","ucode":"0B546E540DF096","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/4a/40a2ba79.jpg","comment_is_top":false,"comment_ctime":1592877286,"is_pvip":false,"replies":[{"id":"84432","content":"uml其实并不难，也没有必要完全学通学精，本质上就是个画图。<br><br>先学会最基本的类图、时序图，其他的可以在实践中慢慢学。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1592878539,"ip_address":"","comment_id":228997,"utype":1}],"discussion_count":2,"race_medal":0,"score":"44542550246","product_id":100051801,"comment_content":"关于UML图 想学的同学可以看一下《UML大象》","like_count":10,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499290,"discussion_content":"uml其实并不难，也没有必要完全学通学精，本质上就是个画图。\n\n先学会最基本的类图、时序图，其他的可以在实践中慢慢学。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1592878539,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1240138,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ec/4a/40a2ba79.jpg","nickname":"reverse","note":"","ucode":"0B546E540DF096","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285609,"discussion_content":"活学活用最重要， 如果有同学想深入学习 ，可以大致上看一下主要的部分，就像老师说的那样（￣ー￣）ノ~~マ☆’.・.・:★嗯哼","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1592892052,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229482,"user_name":"K. D.","can_delete":false,"product_type":"c1","uid":1914230,"ip_address":"","ucode":"7A1EC6B64D1EAF","user_header":"https://static001.geekbang.org/account/avatar/00/1d/35/76/951b0daf.jpg","comment_is_top":false,"comment_ctime":1593010786,"is_pvip":false,"replies":[{"id":"84726","content":"你理解的很对，两者的区别就在这里，自旋锁的好处是不会让出cpu，busy waiting，这在小等待时的代价就比较低，可以充分利用cpu。而mutex会让线程sleep，暂时让出cpu给其他线程，这就有点浪费。<br><br>具体该用哪个还是要看应用场景，在这里我用自旋锁只是为了演示atomic的用法。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1593047574,"ip_address":"","comment_id":229482,"utype":1}],"discussion_count":3,"race_medal":0,"score":"27362814562","product_id":100051801,"comment_content":"老师你好，我上网查了一下spin lock（自旋锁）和mutex（互斥锁）的区别，自旋锁是会让线程busy waiting，而互斥锁则是让线程sleep，从cpu的占用角度，是否sleep是更好的？busy waiting感觉更加cpu intensive。","like_count":7,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499500,"discussion_content":"你理解的很对，两者的区别就在这里，自旋锁的好处是不会让出cpu，busy waiting，这在小等待时的代价就比较低，可以充分利用cpu。而mutex会让线程sleep，暂时让出cpu给其他线程，这就有点浪费。\n\n具体该用哪个还是要看应用场景，在这里我用自旋锁只是为了演示atomic的用法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593047574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1628867,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIicr82CnrdEjibibAvyeKRQHszSzIAqoCWxN0kqC442XcjEae6S9j6NDtKLpg4Da4CUQQeUFUicWqiaDw/132","nickname":"有学识的兔子","note":"","ucode":"D1D654B1562FC9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286156,"discussion_content":"对自旋锁和互斥锁，我也有类似的疑问。\n我觉得除了上述因素外，还得把系统的线程调度程序考虑进来，虽然自旋锁会使得线程为了锁不停地轮询，但当该线程的被调度程序分配时间片耗尽时，调度程序会切换该线程，不至于cpu只为该线程工作而阻塞其他线程的工作。因此，出现这种情况，带来的负面影响是有限的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1593076599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2417723,"avatar":"https://static001.geekbang.org/account/avatar/00/24/e4/3b/f1b9d6bf.jpg","nickname":"蔡俊贤","note":"","ucode":"A856D094E3F4A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1628867,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIicr82CnrdEjibibAvyeKRQHszSzIAqoCWxN0kqC442XcjEae6S9j6NDtKLpg4Da4CUQQeUFUicWqiaDw/132","nickname":"有学识的兔子","note":"","ucode":"D1D654B1562FC9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388212,"discussion_content":"并发数量高且等待时间长的时候自旋锁对cpu的消耗就比较可观了，一个线程的时间片到了就切换到其他线程去自旋，总的来看一大堆线程都在自旋，其他任务的计算资源就会受到挤兑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628656505,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":286156,"ip_address":""},"score":388212,"extra":""}]}]},{"had_liked":false,"id":228958,"user_name":"泡泡龙","can_delete":false,"product_type":"c1","uid":1208655,"ip_address":"","ucode":"8D43010FA3DC2C","user_header":"https://static001.geekbang.org/account/avatar/00/12/71/4f/bce0d5bc.jpg","comment_is_top":false,"comment_ctime":1592870098,"is_pvip":true,"replies":[{"id":"84412","content":"<br>1.这个就是基本的需求分析了，简单来说，就是提取出需求里的名词和动词，转化成相应的类，比如销售记录、配置文件、锁、XX主循环。<br><br>2.UML图有很多种，这里用到的是类图，表示的是类之间的关系，需要理解UML的基本语言要素，比如聚合、联系等，然后可以随便选一个类作为起点，像爬虫一样，沿着关系链接去看它相关的类，逐步去理解这些类是如何配合工作的。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1592873899,"ip_address":"","comment_id":228958,"utype":1}],"discussion_count":1,"race_medal":2,"score":"5887837394","product_id":100051801,"comment_content":"老师能否说说需求到UML图的过程，是怎么把需求提到UML的。还有就是给一张UML图，应该怎么看？","like_count":1,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499275,"discussion_content":"\n1.这个就是基本的需求分析了，简单来说，就是提取出需求里的名词和动词，转化成相应的类，比如销售记录、配置文件、锁、XX主循环。\n\n2.UML图有很多种，这里用到的是类图，表示的是类之间的关系，需要理解UML的基本语言要素，比如聚合、联系等，然后可以随便选一个类作为起点，像爬虫一样，沿着关系链接去看它相关的类，逐步去理解这些类是如何配合工作的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592873899,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":356453,"user_name":"我是一只小小鸟","can_delete":false,"product_type":"c1","uid":1339366,"ip_address":"北京","ucode":"13348E2AC10F06","user_header":"https://static001.geekbang.org/account/avatar/00/14/6f/e6/357e80e9.jpg","comment_is_top":false,"comment_ctime":1662339582,"is_pvip":true,"replies":[{"id":"129770","content":"其实这个和hpp没有必然关系，用.h + .cpp也会有同样的问题，只要类设计合理，用好设计模式，不要出现面条类，一两千行的源文件也是可以接受的，如果再大就要考虑重构了。","user_name":"作者回复","user_name_real":"编辑","uid":"1181974","ctime":1662346625,"ip_address":"北京","comment_id":356453,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1662339582","product_id":100051801,"comment_content":"老师，您好，有个问题请教下，只使用.hpp，如果函数接口比较多，易读性怎么保证。到时候一个hpp文件，会不会出现1000+","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586571,"discussion_content":"其实这个和hpp没有必然关系，用.h + .cpp也会有同样的问题，只要类设计合理，用好设计模式，不要出现面条类，一两千行的源文件也是可以接受的，如果再大就要考虑重构了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662346625,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307391,"user_name":"Geek_6427cc","can_delete":false,"product_type":"c1","uid":2687340,"ip_address":"","ucode":"E068345365B611","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI6bWC6dlUWtJBNHX12ZQ7a7Jp6iamGECic0oLzzlo2QqKmorwbGcsKaZbCDLdm4R9ProCcVX79sx4Q/132","comment_is_top":false,"comment_ctime":1629079816,"is_pvip":false,"replies":[{"id":"111310","content":"LuaRef_cast是lua bridge自己的类型转换函数，把lua数据转换C++数据。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1629091732,"ip_address":"","comment_id":307391,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1629079816","product_id":100051801,"comment_content":"老师您好，get模板函数的返回值不是很懂，不明白LuaRef_cast是什么，类型转换不是只有那四个方法吗","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525136,"discussion_content":"LuaRef_cast是lua bridge自己的类型转换函数，把lua数据转换C++数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629091732,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2687340,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI6bWC6dlUWtJBNHX12ZQ7a7Jp6iamGECic0oLzzlo2QqKmorwbGcsKaZbCDLdm4R9ProCcVX79sx4Q/132","nickname":"Geek_6427cc","note":"","ucode":"E068345365B611","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390369,"discussion_content":"好的谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629804203,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":291653,"user_name":"Geek_8866d4","can_delete":false,"product_type":"c1","uid":2435064,"ip_address":"","ucode":"34EAED72C2FAD0","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/ia5NFICdEuzaQ8Vib0depvkB6UmxPBFib51aClSJYfCIa7tn2nXauddwxDvbxYuQ9UeRGVICLfTtDJysnDJ5EfQcg/132","comment_is_top":false,"comment_ctime":1620400407,"is_pvip":false,"replies":[{"id":"105630","content":"我测试了一下，没有重现你说的这个问题，是不是使用的标准不对，编译时加上-std=c++14再试试。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1620435690,"ip_address":"","comment_id":291653,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1620400407","product_id":100051801,"comment_content":"&#47;home&#47;wuchaochao&#47;c++&#47;cpp_study&#47;section5&#47;client.cpp:36:20: error: non-local lambda expression cannot have a capture-default<br>   36 | auto make_sales = [=](const auto&amp; id, auto s, auto r)<br>老师 ，我在编译您的源码的时候报错<br>","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519533,"discussion_content":"我测试了一下，没有重现你说的这个问题，是不是使用的标准不对，编译时加上-std=c++14再试试。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620435690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2435064,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/ia5NFICdEuzaQ8Vib0depvkB6UmxPBFib51aClSJYfCIa7tn2nXauddwxDvbxYuQ9UeRGVICLfTtDJysnDJ5EfQcg/132","nickname":"Geek_8866d4","note":"","ucode":"34EAED72C2FAD0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372840,"discussion_content":"下面找不到库的问题解决了，是因为没有进行upgrade，安装您的方式编译srv.cpp文件年能够成功的运行，但是上面的问题还是存在","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620474729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2435064,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/ia5NFICdEuzaQ8Vib0depvkB6UmxPBFib51aClSJYfCIa7tn2nXauddwxDvbxYuQ9UeRGVICLfTtDJysnDJ5EfQcg/132","nickname":"Geek_8866d4","note":"","ucode":"34EAED72C2FAD0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372821,"discussion_content":"罗老师，我这个编译的时候出现了各种奇怪的问题，我在section5中make由CMakeList.txt生成的makefile文件的时候，出现了ollect2: error: ld returned 1 exit status\nmake[2]: *** [CMakeFiles/srv.dir/build.make:84：srv] 错误 1\nmake[2]: 离开目录“/home/wuchaochao/c++/cpp_study/section5”\nmake[1]: *** [CMakeFiles/Makefile2:107：CMakeFiles/srv.dir/all] 错误 2\nmake[1]: 离开目录“/home/wuchaochao/c++/cpp_study/section5”\nmake: *** [Makefile:118：all] 错误 2\n这样的错误\n我修改了你的CMakeList.txt文件，增加了编译的路径add_compile_options(-std=c++14 -I../common -I../common/include -I/usr/local/include/luajit-2.1 -lluajit-5.1 -ldl -lzmq -lpthread -lcpr -lcurl)如果不手动制定库的路径会报错，找不到头文件\n后面报错之后，我单独安装您注解上的方式编译了srv.cpp这个文件，编译没有问题，但是运行就报错了\nerror while loading shared libraries: libcpr.so.1: cannot open shared object file: No such file or directory\n告诉我缺少libcpr.so.1这库文件，但是我已经安装给出的安装方式安装了cpr这个库，现在不知道该怎么解决","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620470434,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":256927,"user_name":"大熊🐻","can_delete":false,"product_type":"c1","uid":1622742,"ip_address":"","ucode":"06E0E4082C5985","user_header":"https://static001.geekbang.org/account/avatar/00/18/c2/d6/d3d7371b.jpg","comment_is_top":false,"comment_ctime":1603785937,"is_pvip":false,"replies":[{"id":"93549","content":"我觉得可能是编译器的问题，试着用高版本的gcc，或者在打好包的docker环境里试试。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1603839055,"ip_address":"","comment_id":256927,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1603785937","product_id":100051801,"comment_content":"成员变量初始化<br>const regex_type m_reg {R&quot;(^(\\w+)\\.(\\w+)$)&quot;};<br>运行时一直报错 <br>regex_error: The parser did not consume the entire regular expression.","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508167,"discussion_content":"我觉得可能是编译器的问题，试着用高版本的gcc，或者在打好包的docker环境里试试。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603839055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":237628,"user_name":"锦鲤","can_delete":false,"product_type":"c1","uid":1343717,"ip_address":"","ucode":"B9F1495E39F00A","user_header":"https://static001.geekbang.org/account/avatar/00/14/80/e5/251d89b5.jpg","comment_is_top":false,"comment_ctime":1595905253,"is_pvip":false,"replies":[{"id":"87798","content":"应该指的是call_once吧。<br><br>不是这样用的，这里利用的是RAII技术，每次到这里都会构造一个guard对象，来获取锁再自动释放锁，如果用call_once就错了。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1595913682,"ip_address":"","comment_id":237628,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1595905253","product_id":100051801,"comment_content":"SpinLockGuard 的实例化是否要用到前面章节里面讲到的make_once表示只会实例化一次？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502486,"discussion_content":"应该指的是call_once吧。\n\n不是这样用的，这里利用的是RAII技术，每次到这里都会构造一个guard对象，来获取锁再自动释放锁，如果用call_once就错了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595913682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":236290,"user_name":"Geek_hope","can_delete":false,"product_type":"c1","uid":2052423,"ip_address":"","ucode":"8B30F9D92CF0A4","user_header":"","comment_is_top":false,"comment_ctime":1595385960,"is_pvip":false,"replies":[{"id":"87321","content":"try_lock只是尝试锁定，不会阻塞，而lock是阻塞直至锁定，两个的使用场景不同。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1595396226,"ip_address":"","comment_id":236290,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1595385960","product_id":100051801,"comment_content":"老师您好，请问SpinLock 类里面还有一个 try_lock 呢？不是lock 成员函数已经锁定了吗？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502016,"discussion_content":"try_lock只是尝试锁定，不会阻塞，而lock是阻塞直至锁定，两个的使用场景不同。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595396226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235273,"user_name":"henry","can_delete":false,"product_type":"c1","uid":1019455,"ip_address":"","ucode":"D2744C559ADFD0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/3f/1f529b26.jpg","comment_is_top":false,"comment_ctime":1594957075,"is_pvip":true,"replies":[{"id":"86878","content":"是的，都看zmq.hpp的源码了，很认真啊。<br><br>有了右值和转移构造，在C++里返回对象确实省了很多力气。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1594962264,"ip_address":"","comment_id":235273,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1594957075","product_id":100051801,"comment_content":"老师您好！ZmqContext 类中的两个工厂方法 recv_sock,send_sock, 返回值是zmq::socket_t的对象，里面的临时对象sock析构时不用担心zmq_close 关闭了_handle，是因为zmq::socket_t实现了移动构造函数，临时对象sock的_handle别转移了，自己的_handle已经是null_ptr了对吧。<br>要是我自己实现这个代码的话，估计还是会用智能指针的方式。时刻注意构造和析构细节感觉挺麻烦的。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501669,"discussion_content":"是的，都看zmq.hpp的源码了，很认真啊。\n\n有了右值和转移构造，在C++里返回对象确实省了很多力气。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594962264,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1019455,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8e/3f/1f529b26.jpg","nickname":"henry","note":"","ucode":"D2744C559ADFD0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291827,"discussion_content":"好的，谢谢！\n右值引用，转移构造，转移赋值，这些概念还得多理解理解，要不然用到这方面的时候总觉得不踏实。擦汗！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594963103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":231337,"user_name":"Ryan24G","can_delete":false,"product_type":"c1","uid":1631292,"ip_address":"","ucode":"EA1E134C18DA80","user_header":"https://static001.geekbang.org/account/avatar/00/18/e4/3c/dfcb86df.jpg","comment_is_top":false,"comment_ctime":1593654068,"is_pvip":true,"replies":[{"id":"85418","content":"这个也算是我C++开发的一个习惯了，统一的头文件定义，用起来比较省事。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1593655656,"ip_address":"","comment_id":231337,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1593654068","product_id":100051801,"comment_content":"突然蹦出个 .hpp 文件出来了....","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500266,"discussion_content":"这个也算是我C++开发的一个习惯了，统一的头文件定义，用起来比较省事。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593655656,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229685,"user_name":"heylypp","can_delete":false,"product_type":"c1","uid":1994958,"ip_address":"","ucode":"CBD72BA764ACA1","user_header":"https://static001.geekbang.org/account/avatar/00/1e/70/ce/168b803b.jpg","comment_is_top":false,"comment_ctime":1593097940,"is_pvip":false,"replies":[{"id":"84760","content":"在gcc编译的时候手工指定一下luajit的路径吧，参考源码里的注释。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1593127442,"ip_address":"","comment_id":229685,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1593097940","product_id":100051801,"comment_content":"老师您好，在编译您仓库里的section5时，出现如下报错（使用的是openresty&#47;luajit2，并将路径写入&#47;etc&#47;profile），不知如何解决<br> fatal error: luajit.h: No such file or directory<br> #include &lt;luajit.h&gt;<br>","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499591,"discussion_content":"在gcc编译的时候手工指定一下luajit的路径吧，参考源码里的注释。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593127442,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229632,"user_name":"有学识的兔子","can_delete":false,"product_type":"c1","uid":1628867,"ip_address":"","ucode":"D1D654B1562FC9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIicr82CnrdEjibibAvyeKRQHszSzIAqoCWxN0kqC442XcjEae6S9j6NDtKLpg4Da4CUQQeUFUicWqiaDw/132","comment_is_top":false,"comment_ctime":1593079085,"is_pvip":false,"replies":[{"id":"84746","content":"设计也要掌握一个度，大型、长期项目就要多做设计，小型项目、迭代型的短期项目就可以适当简化，在成本与架构之间找到折中。<br><br>但项目一般到中后期，都免不了越做越大，所以就要及时重构优化设计，否则就会积累很多技术债。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1593086062,"ip_address":"","comment_id":229632,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1593079085","product_id":100051801,"comment_content":"在分析需求，基于一些设计原则SOLID和面向对象的思想等，把需求抽象成各种独立模块，基于此运行语言特性和设计模式，使得保证代码可读性和可扩展性。<br>个人觉得前期程序不用过度设计，必要的模块划分结合继承组合以及语言特性的方式，即可完成前期原型开发。","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499573,"discussion_content":"设计也要掌握一个度，大型、长期项目就要多做设计，小型项目、迭代型的短期项目就可以适当简化，在成本与架构之间找到折中。\n\n但项目一般到中后期，都免不了越做越大，所以就要及时重构优化设计，否则就会积累很多技术债。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593086062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}