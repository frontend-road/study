{"id":240292,"title":"09 | exception：怎样才能用好异常？","content":"<p>你好，我是Chrono。</p><p>上节课，我建议尽量不用裸指针、new和delete，因为它们很危险，容易导致严重错误。这就引出了一个问题，如何正确且优雅地处理运行时的错误。</p><p>实际上，想要达成这个目标，还真不是件简单的事情。</p><p>程序在运行的时候不可能“一帆风顺”，总会遇到这样那样的内外部故障，而我们写程序的人就要尽量考虑周全，准备各种“预案”，让程序即使遇到问题也能够妥善处理，保证“健壮性”。</p><p>C++处理错误的标准方案是“异常”（exception）。虽然它已经在Java、C#、Python等语言中得到了广泛的认可和应用，但在C++里却存在诸多争议。</p><p>你也可能在其他地方听到过一种说法：“<strong>现代C++里应该使用异常</strong>。”但这之后呢？应该怎么去用异常呢？</p><p>所以，今天我就和你好好聊聊“异常那些事”，说一说为什么要有异常，该怎么用好异常，有哪些要注意的地方。</p><h2>为什么要有异常？</h2><p>很多人认为，C++里的“异常”非常可怕，一旦发生异常就是“了不得的大事”，这其实是因为没有理解异常的真正含义。</p><p>实际上，你可以按照它的字面意思，把它理解成“<strong>异于正常</strong>”，就是正常流程之外发生的一些特殊情况、严重错误。一旦遇到这样的错误，程序就会跳出正常流程，甚至很难继续执行下去。</p><!-- [[[read_end]]] --><p>归根到底，<strong>异常只是C++为了处理错误而提出的一种解决方案，当然也不会是唯一的一种</strong>。</p><p>在C++之前，处理异常的基本手段是“错误码”。函数执行后，需要检查返回值或者全局的errno，看是否正常，如果出错了，就执行另外一段代码处理错误：</p><pre><code>int n = read_data(fd, ...);    // 读取数据\n\nif (n == 0) {\n  ...                    // 返回值不太对，适当处理\n}\n\nif (errno == EAGAIN) {\n  ...                    // 适当处理错误\n}\n</code></pre><p>这种做法很直观，但也有一个问题，那就是<strong>正常的业务逻辑代码与错误处理代码混在了一起</strong>，看起来很乱，你的思维要在两个本来不相关的流程里来回跳转。而且，有的时候，错误处理的逻辑要比正常业务逻辑复杂、麻烦得多，看了半天，你可能都会忘了它当初到底要干什么了，容易引起新的错误。（你可以对比一下预处理代码与C++代码混在一起的情景。）</p><p>错误码还有另一个更大的问题：<strong>它是可以被忽略的</strong>。也就是说，你完全可以不处理错误，“假装”程序运行正常，继续跑后面的代码，这就可能导致严重的安全隐患。（可能是无意的，因为你确实不知道发生了什么错误。）</p><p>“没有对比就没有伤害”，现在你就应该明白了，作为一种新的错误处理方式，异常就是针对错误码的缺陷而设计的，它有三个特点。</p><ol>\n<li>\n<p><strong>异常的处理流程是完全独立的</strong>，throw抛出异常后就可以不用管了，错误处理代码都集中在专门的catch块里。这样就彻底分离了业务逻辑与错误逻辑，看起来更清楚。</p>\n</li>\n<li>\n<p><strong>异常是绝对不能被忽略的，必须被处理</strong>。如果你有意或者无意不写catch捕获异常，那么它会一直向上传播出去，直至找到一个能够处理的catch块。如果实在没有，那就会导致程序立即停止运行，明白地提示你发生了错误，而不会“坚持带病工作”。</p>\n</li>\n<li>\n<p><strong>异常可以用在错误码无法使用的场合</strong>，这也算是C++的“私人原因”。因为它比C语言多了构造/析构函数、操作符重载等新特性，有的函数根本就没有返回值，或者返回值无法表示错误，而全局的errno实在是“太不优雅”了，与C++的理念不符，所以也必须使用异常来报告错误。</p>\n</li>\n</ol><p>记住这三个关键点，是在C++里用好异常的基础，它们能够帮助你在本质上理解异常的各种用法。</p><h2>异常的用法和使用方式</h2><p>C++里异常的用法想必你已经知道了：<strong>用try把可能发生异常的代码“包”起来，然后编写catch块捕获异常并处理</strong>。</p><p>刚才的错误码例子改用异常，就会变得非常干净清晰：</p><pre><code>try\n{\n  int n = read_data(fd, ...);    // 读取数据，可能抛出异常\n  \n  ...                         // do some right thing\n}\ncatch(...)\n{\n    ...                       // 集中处理各种错误情况\n}\n</code></pre><p>基本的try-catch谁都会写，那么，怎样才能用好异常呢？</p><p>首先你要知道，C++里对异常的定义非常宽松，任何类型都可以用throw抛出，也就是说，你可以直接把错误码（int）、或者错误消息（char*、string）抛出，catch也能接住，然后处理。</p><p>但我建议你最好不要“图省事”，因为C++已经为处理异常设计了一个配套的异常类型体系，定义在标准库的&lt;stdexcept&gt;头文件里。</p><p>下面我画了个简单的示意图，你可以看一下。</p><p><img src=\"https://static001.geekbang.org/resource/image/8b/67/8ba78367ce53d54a393a8963bb62e867.jpg?wh=3612*2031\" alt=\"\"></p><p>标准异常的继承体系有点复杂，最上面是基类exception，下面是几个基本的异常类型，比如bad_alloc、bad_cast、runtime_error、logic_error，再往下还有更细致的错误类型，像runtime_error就有range_error、overflow_error，等等。</p><p>我在<a href=\"https://time.geekbang.org/column/article/235301\">第5节课</a>讲过，如果继承深度超过三层，就说明有点“过度设计”，很明显现在就有这种趋势了。所以，我建议你最好选择上面的第一层或者第二层的某个类型作为基类，不要再加深层次。</p><p>比如说，你可以从runtime_error派生出自己的异常类：</p><pre><code>class my_exception : public std::runtime_error\n{\npublic:\n    using this_type     = my_exception;        // 给自己起个别名\n    using super_type    = std::runtime_error;  // 给父类也起个别名\npublic:\n    my_exception(const char* msg):            // 构造函数\n        super_type(msg)                      // 别名也可以用于构造\n    {}  \n\n    my_exception() = default;                // 默认构造函数\n   ~my_exception() = default;                // 默认析构函数\nprivate:\n    int code = 0;                            // 其他的内部私有数据\n};\n</code></pre><p>在抛出异常的时候，我建议你最好不要直接用throw关键字，而是要封装成一个函数，这和不要直接用new、delete关键字是类似的道理——<strong>通过引入一个“中间层”来获得更多的可读性、安全性和灵活性</strong>。</p><p>抛异常的函数不会有返回值，所以应该用<a href=\"https://time.geekbang.org/column/article/235295\">第4节课</a>里的“属性”做编译阶段优化：</p><pre><code>[[noreturn]]                      // 属性标签\nvoid raise(const char* msg)      // 函数封装throw，没有返回值\n{\n    throw my_exception(msg);     // 抛出异常，也可以有更多的逻辑\n}\n</code></pre><p>使用catch捕获异常的时候也要注意，C++允许编写多个catch块，捕获不同的异常，再分别处理。但是，<strong>异常只能按照catch块在代码里的顺序依次匹配，而不会去找最佳匹配</strong>。</p><p>这个特性导致实际开发的时候有点麻烦，特别是当异常类型体系比较复杂的时候，有可能会因为写错了顺序，进入你本不想进的catch块。所以，<strong>我建议你最好只用一个catch块，绕过这个“坑”</strong>。</p><p>写catch块就像是写一个标准函数，所以入口参数也应当使用“const &amp;”的形式，避免对象拷贝的代价：</p><pre><code>try\n{\n    raise(&quot;error occured&quot;);     // 函数封装throw，抛出异常\n}\ncatch(const exception&amp; e)      // const &amp;捕获异常，可以用基类\n{\n    cout &lt;&lt; e.what() &lt;&lt; endl;  // what()是exception的虚函数\n}\n</code></pre><p>关于try-catch，还有一个很有用的形式：<strong>function-try。</strong>我一直都觉得非常奇怪的是，这个形式如此得简单清晰，早在C++98的时候就已经出现了，但知道的人却非常少。</p><p>所谓function-try，就是把整个函数体视为一个大try块，而catch块放在后面，与函数体同级并列，给你看个示例：</p><pre><code>void some_function()\ntry                          // 函数名之后直接写try块\n{\n    ...\n}\ncatch(...)                   // catch块与函数体同级并列\n{\n    ...\n}\n</code></pre><p>这样做的好处很明显，不仅能够捕获函数执行过程中所有可能产生的异常，而且少了一级缩进层次，处理逻辑更清晰，我也建议你多用。</p><h2>谨慎使用异常</h2><p>掌握了异常和它的处理方式，下面我结合我自己的经验，和你讨论一下应该在什么时候使用异常来处理错误。</p><p>目前的C++世界里有三种使用异常的方式（或者说是观点）。</p><p>第一种，是绝不使用异常，就像是C语言那样，只用传统的错误码来检查错误。</p><p>选择禁止异常的原因当然有很多，有的也很合理，但我觉得这就等于浪费了异常机制，对于改善代码质量没有帮助，属于“<strong>因噎废食</strong>”。</p><p>第二种则与第一种相反，主张全面采用异常，所有的错误都用异常的形式来处理。</p><p>但你要知道，异常也是有成本的。</p><p>异常的抛出和处理需要特别的栈展开（stack unwind）操作，如果异常出现的位置很深，但又没有被及时处理，或者频繁地抛出异常，就会对运行性能产生很大的影响。这个时候，程序全忙着去处理异常了，正常逻辑反而被搁置。</p><p>这种观点我认为是“<strong>暴饮暴食</strong>”，也不可取。</p><p>所以，第三种方式就是两者的折中：区分“非”错误、“轻微”错误和“严重”错误，谨慎使用异常。我认为这应该算是“<strong>均衡饮食</strong>”。</p><p>具体来说，就是要仔细分析程序中可能发生的各种错误情况，按严重程度划分出等级，把握好“度”。</p><p>对于正常的返回值，或者不太严重、可以重试/恢复的错误，我建议你不使用异常，把它们归到正常的流程里。</p><p>比如说字符串未找到（不是错误）、数据格式不对（轻微错误）、数据库正忙（可重试错误），这样的错误比较轻微，而且在业务逻辑里会经常出现，如果你用异常处理，就会“小题大做”，影响性能。</p><p>剩下的那些中级、高级错误也不是都必须用异常，你还要再做分析，尽量降低引入异常的成本。</p><p>我自己总结了几个应当使用异常的判断准则：</p><ol>\n<li>不允许被忽略的错误；</li>\n<li>极少数情况下才会发生的错误；</li>\n<li>严重影响正常流程，很难恢复到正常状态的错误；</li>\n<li>无法本地处理，必须“穿透”调用栈，传递到上层才能被处理的错误。</li>\n</ol><p>规则听起来可能有点不好理解，我给你举几个例子。</p><p>比如说构造函数，如果内部初始化失败，无法创建，那后面的逻辑也就进行不下去了，所以这里就可以用异常来处理。</p><p>再比如，读写文件，通常文件系统很少会出错，总会成功，如果用错误码来处理不存在、权限错误等，就显得太啰嗦，这时也应该使用异常。</p><p>相反的例子就是socket通信。因为网络链路的不稳定因素太多，收发数据失败简直是“家常便饭”。虽然出错的后果很严重，但它出现的频率太高了，使用异常会增加很多的处理成本，为了性能考虑，还是检查错误码重试比较好。</p><h2>保证不抛出异常</h2><p>看到这里，你是不是觉得异常是把“双刃剑”呢？优点缺点都有，难以取舍。</p><p>有没有什么办法既能享受异常的好处，又不用承担异常的成本呢？</p><p>还真有这样的“好事”，毕竟，写C++程序追求的就是性能，所以，C++标准就又提出了一个新的编译阶段指令：<strong>noexcept</strong>，但它也有一点局限，不是“万能药”。</p><p>noexcept专门用来修饰函数，告诉编译器：这个函数不会抛出异常。编译器看到noexcept，就得到了一个“保证”，就可以对函数做优化，不去加那些栈展开的额外代码，消除异常处理的成本。</p><p>和const一样，noexcept要放在函数后面：</p><pre><code>void func_noexcept() noexcept            // 声明绝不会抛出异常\n{\n    cout &lt;&lt; &quot;noexcept&quot; &lt;&lt; endl;\n}\n</code></pre><p>不过你要注意，noexcept只是做出了一个“不可靠的承诺”，不是“强保证”，编译器无法彻底检查它的行为，标记为noexcept的函数也有可能抛出异常：</p><pre><code>void func_maybe_noexcept() noexcept          // 声明绝不会抛出异常\n{\n    throw &quot;Oh My God&quot;;                    // 但也可以抛出异常\n}\n</code></pre><p>noexcept的真正意思是：“我对外承诺不抛出异常，我也不想处理异常，如果真的有异常发生，请让我死得干脆点，直接崩溃（crash、core dump）。”</p><p>所以，你也不要一股脑地给所有函数都加上noexcept修饰，毕竟，你无法预测内部调用的那些函数是否会抛出异常。</p><h2>小结</h2><p>今天的话题是错误处理和异常，因为它实在太大了，想要快速说清、说透实在是“不可能的任务”，我们可以在课后继续讨论。</p><p>异常也与上一讲的智能指针密切相关，如果你决定使用异常，为了确保出现异常的时候资源会正确释放，就必须禁用裸指针，改成智能指针，用RAII来管理内存。</p><p>由于异常出现和处理的时机都不好确定，当前的C++也没有在语言层面提出更好的机制，所以，你还要在编码阶段写好文档和注释，说清楚哪些函数、什么情况下会抛出什么样的异常，应如何处理，加上一些“软约束”。</p><p>再简单小结一下今天的内容：</p><ol>\n<li>异常是针对错误码的缺陷而设计的，它不能被忽略，而且可以“穿透”调用栈，逐层传播到其他地方去处理；</li>\n<li>使用try-catch机制处理异常，能够分离正常流程与错误处理流程，让代码更清晰；</li>\n<li>throw可以抛出任何类型作为异常，但最好使用标准库里定义的exception类；</li>\n<li>完全用或不用异常处理错误都不可取，而是应该合理分析，适度使用，降低异常的成本；</li>\n<li>关键字noexcept标记函数不抛出异常，可以让编译器做更好的优化。</li>\n</ol><h2>课下作业</h2><p>最后是课下作业时间，给你留两个思考题：</p><ol>\n<li>结合自己的实际情况，谈一下使用异常有什么好处和坏处。</li>\n<li>你觉得用好异常还有哪些要注意的地方？</li>\n</ol><p>欢迎你在留言区写下你的思考和答案，如果觉得今天的内容对你有所帮助，也欢迎分享给你的朋友，我们下节课见。</p><p><img src=\"https://static001.geekbang.org/resource/image/96/6e/96a9e2f3c794a3b24df1a49e1ce8c16e.jpg?wh=1300*2033\" alt=\"\"></p>","comments":[{"had_liked":false,"id":221311,"user_name":"lckfa李钊","can_delete":false,"product_type":"c1","uid":1356899,"ip_address":"","ucode":"AD13D205104AA6","user_header":"https://static001.geekbang.org/account/avatar/00/14/b4/63/84960032.jpg","comment_is_top":false,"comment_ctime":1590470154,"is_pvip":false,"replies":[{"id":"81621","content":"非常好的经验，noexcept(false)这个显式声明对人很友好。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1590470454,"ip_address":"","comment_id":221311,"utype":1}],"discussion_count":1,"race_medal":0,"score":"151914325514","product_id":100051801,"comment_content":"初识编程时，对异常处理的误解还是挺大的，可能是因为异常处理总是在教材的最后几页，觉得很难，然后就草草的误解了。之前有一份工作领导特意提到了正确地进行异常处理。后来认真学了下，接触到C++11后，才真正用起来。<br>异常的好处是不言自明的，加强程序的健壮性，避免大量if else形式的代码处理。坏处也是有的，比如某个函数是否抛异常，写的人不好确定，要关注具体逻辑；而用这个函数的人也不确定，可能还需要借助注释来说明这个函数会抛出了怎样的异常。而抛异常就要try 和catch处理，不处理程序就会崩溃，接口的“客户”可能会不乐意处理。<br>用异常时，我更多的将某个函数声明为 noexcept ,比如构造函数，而明确要抛异常的函数则声明为noexcept(false)。<br>而在代码里处处使用 try catch也是不明智的，需要根据具体的场景和业务来辨别。而有一点是需要特别注意的避免在catch里写真实的业务代码，不应该在里写改变整个程序的流程的代码。如果程序崩溃了，就让它崩溃吧。<br>","like_count":36,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496419,"discussion_content":"非常好的经验，noexcept(false)这个显式声明对人很友好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590470454,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225006,"user_name":"Coder Wu","can_delete":false,"product_type":"c1","uid":1206017,"ip_address":"","ucode":"096CDF1804ED75","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/01/1497fe0a.jpg","comment_is_top":false,"comment_ctime":1591613770,"is_pvip":false,"replies":[{"id":"82872","content":"我的观点和你恰恰相反，库最好还是用错误码的方式，不要把异常抛给外面处理，通俗点说就是eat your own dog food。<br><br>因为外界不了解库的工作机制，也不知道怎么处理异常才好，或者可能根本就不知道你会抛异常，这样的话库用起来就不是太安全。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591664883,"ip_address":"","comment_id":225006,"utype":1}],"discussion_count":4,"race_medal":0,"score":"61721155914","product_id":100051801,"comment_content":"个人感觉如果是封装功能库给其他人使用，可以考虑用异常，能方便传递错误信息给外部。如果是写业务逻辑的话，只是涉及到自身功能的错误，还是多用错误码的方式，并且配合日志，方便后续问题的跟踪。","like_count":15,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497690,"discussion_content":"我的观点和你恰恰相反，库最好还是用错误码的方式，不要把异常抛给外面处理，通俗点说就是eat your own dog food。\n\n因为外界不了解库的工作机制，也不知道怎么处理异常才好，或者可能根本就不知道你会抛异常，这样的话库用起来就不是太安全。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1591664883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1994088,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/6d/68/e40b3300.jpg","nickname":"Bluebuger","note":"","ucode":"946EE346371D8A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286038,"discussion_content":"我也觉得老师的方式更好。库内抛出错误码，这样配和文档后，反而更让使用者更清晰发生了什么。后续要怎么处理可以由业务逻辑自己决定","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1593018043,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1994848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/TXAUcbHlPbyEibtUB2STNgmOb6oQdO8nKuA9nnhuI76Ccv2U5Vgxfp8YxvGeKQP8k47ULBwVGglH4DibOzH8Qfeg/132","nickname":"IAmLinGe","note":"","ucode":"9DCDA0FA5CF2B0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286519,"discussion_content":"你的库如果会有异常，你要把异常在库里面catch住，然后自己根据catch住的异常，返回错误码给用户，可以看看市场上的sdk，都是报错误码，没有抛异常的，至于你说的boost，那是基础开发库啊，你开发用的呀。并不是直接提供给客户的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1593204601,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1206017,"avatar":"https://static001.geekbang.org/account/avatar/00/12/67/01/1497fe0a.jpg","nickname":"Coder Wu","note":"","ucode":"096CDF1804ED75","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281237,"discussion_content":"哈哈 这样吗，不过的确是碰到这样的问题，之前用boost的asio很奇怪的就抛了异常，程序core的有点措手不及。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591698294,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221550,"user_name":"范闲","can_delete":false,"product_type":"c1","uid":1073125,"ip_address":"","ucode":"F21FD7DF6BA53C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","comment_is_top":false,"comment_ctime":1590538550,"is_pvip":false,"replies":[{"id":"81685","content":"很不错的经验分享。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1590540520,"ip_address":"","comment_id":221550,"utype":1}],"discussion_count":4,"race_medal":0,"score":"53130146102","product_id":100051801,"comment_content":"异常是个很重要的东西。<br>涉及磁盘操作的最好使用异常+调用栈，<br>涉及业务逻辑的最好利用日志+调用栈，<br>涉及指针和内存分配的还是用日志+调用栈吧，这种coredump一般是内存泄露和内存不够引起的。","like_count":13,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496491,"discussion_content":"很不错的经验分享。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590540520,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1012912,"avatar":"","nickname":"gigglesun","note":"","ucode":"7AE6C7DCE06063","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382061,"discussion_content":"调用栈具体是说用gdb debug?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625393388,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1154146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9c/62/f625b2bb.jpg","nickname":"酸葡萄","note":"","ucode":"9D059C4FB327C0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283896,"discussion_content":"为什么呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592392573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1073125,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","nickname":"范闲","note":"","ucode":"F21FD7DF6BA53C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1154146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9c/62/f625b2bb.jpg","nickname":"酸葡萄","note":"","ucode":"9D059C4FB327C0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295411,"discussion_content":"这个是为了清晰的记录异常，可以让你更容易的定位到问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596186057,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":283896,"ip_address":""},"score":295411,"extra":""}]}]},{"had_liked":false,"id":240434,"user_name":"_smile滴水C","can_delete":false,"product_type":"c1","uid":1151967,"ip_address":"","ucode":"DA7474D8931C62","user_header":"https://static001.geekbang.org/account/avatar/00/11/93/df/5500fc5b.jpg","comment_is_top":false,"comment_ctime":1596914302,"is_pvip":false,"replies":[{"id":"88820","content":"虽然都是try，但两者的用法差距很大，不能直接照搬Python的用法。<br><br>C++里的try就是捕获异常，而在C++里数组越界不一定会引发异常，可能正常也可能直接crash，try只能捕获可控的异常，不是万能的。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1597021367,"ip_address":"","comment_id":240434,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14481816190","product_id":100051801,"comment_content":"老师我使用过python的try，能跳过数组越界错误，假设是用户代码，跳过并无大碍，避免直接崩溃，C++的try有跟python类似的用法吗？","like_count":4,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503443,"discussion_content":"虽然都是try，但两者的用法差距很大，不能直接照搬Python的用法。\n\nC++里的try就是捕获异常，而在C++里数组越界不一定会引发异常，可能正常也可能直接crash，try只能捕获可控的异常，不是万能的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597021367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221257,"user_name":"泰伦卢","can_delete":false,"product_type":"c1","uid":1141994,"ip_address":"","ucode":"FEA6B43C8D4FF9","user_header":"https://static001.geekbang.org/account/avatar/00/11/6c/ea/e03fec22.jpg","comment_is_top":false,"comment_ctime":1590456765,"is_pvip":true,"replies":[{"id":"81598","content":"说的很好，异常是个好东西，但用不好也会有负面影响，需要了解它的特性后再结合自己的实际情况。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1590458914,"ip_address":"","comment_id":221257,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14475358653","product_id":100051801,"comment_content":"禁用异常典型的有google和美国国防部或者移动端，google是因为历史包袱，以前编译器对异常支持的不太好，所以都使用的错误码方式，近些年来沿用了之前得方式，不好两种错误处理方式都穿插到代码里，国防部是因为异常处理在catch异常时候程序运行速度受影响，移动端主要是因为异常处理的程序体积会大20-30%，而我们真的那么在意程序体积吗，我们普通人使用异常简直不能再香，只是用之前需要搞明白异常处理的各种注意事项","like_count":3,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496404,"discussion_content":"说的很好，异常是个好东西，但用不好也会有负面影响，需要了解它的特性后再结合自己的实际情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590458914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224082,"user_name":"xGdl","can_delete":false,"product_type":"c1","uid":2004988,"ip_address":"","ucode":"5ADD896F62A2B8","user_header":"https://static001.geekbang.org/account/avatar/00/1e/97/fc/0ca13c5c.jpg","comment_is_top":false,"comment_ctime":1591269589,"is_pvip":false,"replies":[{"id":"82553","content":"我觉得function-try的形式更清晰，可以自己写写试试。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1591324286,"ip_address":"","comment_id":224082,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10181204181","product_id":100051801,"comment_content":"两try-catch当函数体还是挺丑的吧","like_count":2,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497357,"discussion_content":"我觉得function-try的形式更清晰，可以自己写写试试。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591324286,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221208,"user_name":"reverse","can_delete":false,"product_type":"c1","uid":1240138,"ip_address":"","ucode":"0B546E540DF096","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/4a/40a2ba79.jpg","comment_is_top":false,"comment_ctime":1590432004,"is_pvip":false,"replies":[{"id":"81579","content":"很有价值的经验，错误处理是写程序时很重要的一块，但有的时候会不太注重，异常可以强制我们去处理错误。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1590454226,"ip_address":"","comment_id":221208,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10180366596","product_id":100051801,"comment_content":"老师，在下说一下我在工作写代码三四年的时间内的一些感受 ，在下主要用的是nodejs java  ， node这块我觉得在es6之后可以结合promise async 函数 再配合try catch 写出简洁的的函数，java 要求的比较严格  ，它的编译器会强制要求你加上 try catch 尤其是对 io操作 来说 ，实际上node的io操作也需要如此，综上所述，偏向于业务逻辑的错误码需要自己合理的定义范围自己意义，涉及到硬件磁盘的需要强制性的捕获异常，设计大于编程，函数规格大于功能本身","like_count":2,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496385,"discussion_content":"很有价值的经验，错误处理是写程序时很重要的一块，但有的时候会不太注重，异常可以强制我们去处理错误。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590454226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":252859,"user_name":"Stephen","can_delete":false,"product_type":"c1","uid":1165201,"ip_address":"","ucode":"0D49223E6CB7B1","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ7mAt63VrbLZPHpeZxSc4IlBYswQSnaAB5wGePaGFDehgiaNfIxI1SJ5yIHIlmVk8hsw0RaoaSCPA/132","comment_is_top":false,"comment_ctime":1602503463,"is_pvip":false,"replies":[{"id":"92451","content":"因为有了一个中间层，也就加上了一层额外的控制，可以在这里定制抛出异常的逻辑，避免外界随意使用异常，比如统一抛出std::exception，而不是int、string，所以就会安全一些。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1602590322,"ip_address":"","comment_id":252859,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5897470759","product_id":100051801,"comment_content":"老师,&quot;通过引入一个“中间层”来获得更多的可读性、安全性和灵活性&quot;这句话中可读性和灵活性我可以理解,这是函数比较容易理解的特性,安全性怎么讲呢?请老师不惜赐教","like_count":1,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506901,"discussion_content":"因为有了一个中间层，也就加上了一层额外的控制，可以在这里定制抛出异常的逻辑，避免外界随意使用异常，比如统一抛出std::exception，而不是int、string，所以就会安全一些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602590322,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":228550,"user_name":"禾众","can_delete":false,"product_type":"c1","uid":1105469,"ip_address":"","ucode":"C37D2965ECA3A3","user_header":"https://static001.geekbang.org/account/avatar/00/10/de/3d/b74ee1af.jpg","comment_is_top":false,"comment_ctime":1592732945,"is_pvip":false,"replies":[{"id":"84263","content":"noexcept其实可以理解为对编译器的指示，让编译器不做异常处理，从而可以优化。<br><br>所以只有确认需要优化的才加，其他的都不用加。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1592740251,"ip_address":"","comment_id":228550,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5887700241","product_id":100051801,"comment_content":"老师如果代码中没有写过异常处理逻辑，那么类的构造析构函数还有必要写noexcept吗？如果也需要的话，代码中到处都要加noexcept就太累赘了。","like_count":1,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499072,"discussion_content":"noexcept其实可以理解为对编译器的指示，让编译器不做异常处理，从而可以优化。\n\n所以只有确认需要优化的才加，其他的都不用加。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592740251,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":313605,"discussion_content":"noexcept是明确指示编译器做优化，不写编译器就会按照自己的策略去优化，可能也不可能做优化。至于如何确定，跟业务有关，你觉得很重要，频繁调用影响性能就加noexcept。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603075168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1165201,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ7mAt63VrbLZPHpeZxSc4IlBYswQSnaAB5wGePaGFDehgiaNfIxI1SJ5yIHIlmVk8hsw0RaoaSCPA/132","nickname":"Stephen","note":"","ucode":"0D49223E6CB7B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311907,"discussion_content":"老师,我们正常不写noexcept的函数不也会进行优化吗?如何确定一个函数需要优化,能举个例子吗?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602517777,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221428,"user_name":"EncodedStar","can_delete":false,"product_type":"c1","uid":1504234,"ip_address":"","ucode":"03958CA7DDD6AE","user_header":"https://static001.geekbang.org/account/avatar/00/16/f3/ea/2b2adda5.jpg","comment_is_top":false,"comment_ctime":1590497466,"is_pvip":false,"replies":[{"id":"81690","content":"说是是“吞掉”所有异常吗，如果是这样就是异常的使用方式不对，没有正确处理异常。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1590540639,"ip_address":"","comment_id":221428,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5885464762","product_id":100051801,"comment_content":"异常不要乱用，乱用容易把bug隐藏起来，出现假象，让你看起来程序跑的很稳定。","like_count":1,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496451,"discussion_content":"说是是“吞掉”所有异常吗，如果是这样就是异常的使用方式不对，没有正确处理异常。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590540639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351449,"user_name":"游子","can_delete":false,"product_type":"c1","uid":1449109,"ip_address":"","ucode":"61E889178E7DF7","user_header":"https://static001.geekbang.org/account/avatar/00/16/1c/95/d25d96d7.jpg","comment_is_top":false,"comment_ctime":1657797067,"is_pvip":true,"replies":[{"id":"127834","content":"应该是异常类型不匹配吧，检查一下抛出的类型对不对。","user_name":"作者回复","user_name_real":"编辑","uid":"1181974","ctime":1657849270,"ip_address":"","comment_id":351449,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1657797067","product_id":100051801,"comment_content":"请问一下罗老师，在try代码块中主动throw一个异常，用catch(const exception&amp;)捕获不到，用catch(...)可以捕获到，是什么原因呢？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580046,"discussion_content":"应该是异常类型不匹配吧，检查一下抛出的类型对不对。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657849270,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":349662,"user_name":"张杨","can_delete":false,"product_type":"c1","uid":2484687,"ip_address":"","ucode":"D7027F304DDA7B","user_header":"https://static001.geekbang.org/account/avatar/00/25/e9/cf/c345a5ac.jpg","comment_is_top":false,"comment_ctime":1656212435,"is_pvip":true,"replies":[{"id":"127269","content":"错误码容易理解，好处理，一旦形成了规模，异常就很难加进去。","user_name":"作者回复","user_name_real":"编辑","uid":"1181974","ctime":1656300001,"ip_address":"","comment_id":349662,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1656212435","product_id":100051801,"comment_content":"目前而言，公司的大框架一直在用错误码进行处理","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577695,"discussion_content":"错误码容易理解，好处理，一旦形成了规模，异常就很难加进去。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656300001,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345855,"user_name":"辣个少年","can_delete":false,"product_type":"c1","uid":2156983,"ip_address":"","ucode":"862B742CBD20F8","user_header":"https://static001.geekbang.org/account/avatar/00/20/e9/b7/8445f7de.jpg","comment_is_top":false,"comment_ctime":1652635855,"is_pvip":false,"replies":[{"id":"126206","content":"我记得最早异常是用goto实现的吧，后来还有用long_jump什么的，不过现在的编译器实现的肯定很复杂了，没再关注过，感兴趣可以自己找一下。","user_name":"作者回复","user_name_real":"编辑","uid":"1181974","ctime":1652661978,"ip_address":"","comment_id":345855,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1652635855","product_id":100051801,"comment_content":"实现机制可以展开讲讲吗","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572207,"discussion_content":"我记得最早异常是用goto实现的吧，后来还有用long_jump什么的，不过现在的编译器实现的肯定很复杂了，没再关注过，感兴趣可以自己找一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652661979,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":228276,"user_name":"Eglinux","can_delete":false,"product_type":"c1","uid":1187353,"ip_address":"","ucode":"4AAB9940789442","user_header":"https://static001.geekbang.org/account/avatar/00/12/1e/19/17245c59.jpg","comment_is_top":false,"comment_ctime":1592631140,"is_pvip":false,"replies":[{"id":"84187","content":"这个就是调用父类的构造函数，只是被改名成super_type了。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1592646860,"ip_address":"","comment_id":228276,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1592631140","product_id":100051801,"comment_content":"class my_exception : public std::runtime_error<br>{<br>public:<br>    using this_type     = my_exception;<br>    using super_type    = std::runtime_error;<br>public:<br>    my_exception(const char* msg):<br>        super_type(msg)<br>    {}<br><br>    my_exception() = default;<br>   ~my_exception() = default;<br>private:<br>    int code = 0;<br>};<br><br>请问老师，这一句是什么语法？没看懂<br>my_exception(const char* msg):<br>        super_type(msg)<br>    {}<br><br>列表初始化吗？但是 super_type 不是成员变量呀","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498980,"discussion_content":"这个就是调用父类的构造函数，只是被改名成super_type了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592646860,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1994848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/TXAUcbHlPbyEibtUB2STNgmOb6oQdO8nKuA9nnhuI76Ccv2U5Vgxfp8YxvGeKQP8k47ULBwVGglH4DibOzH8Qfeg/132","nickname":"IAmLinGe","note":"","ucode":"9DCDA0FA5CF2B0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286520,"discussion_content":"子类初始化父类必须使用这种方法，你的写法是错误的，构造的时候先构造父类再构造子类，使用初始化列表初始化父类，是先于子类构造之前构造父类。而你的写法，是尝试在构造子类之后去构造父类，父类在构造的时候使用默认构造，也就是说进入花括号之后父类已经使用默认构造函数构造完毕，这个时候你又尝试构造父类，肯定错误，可以自己敲代码试试。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593205056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1187353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/1e/19/17245c59.jpg","nickname":"Eglinux","note":"","ucode":"4AAB9940789442","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1994848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/TXAUcbHlPbyEibtUB2STNgmOb6oQdO8nKuA9nnhuI76Ccv2U5Vgxfp8YxvGeKQP8k47ULBwVGglH4DibOzH8Qfeg/132","nickname":"IAmLinGe","note":"","ucode":"9DCDA0FA5CF2B0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290732,"discussion_content":"看懂了，非常感谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594594931,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":286520,"ip_address":""},"score":290732,"extra":""}]},{"author":{"id":1187353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/1e/19/17245c59.jpg","nickname":"Eglinux","note":"","ucode":"4AAB9940789442","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284811,"discussion_content":"这是新语法吗？构造函数后跟冒号，我一直以为是列表初始化的语法，如果是调用父类的构造，我感觉要这样写 \nmy_exception(const char* msg) {\n        super_type(msg)\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592647269,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222751,"user_name":"silverhawk","can_delete":false,"product_type":"c1","uid":1018649,"ip_address":"","ucode":"BFBC8AF32868DA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8b/19/a15d060d.jpg","comment_is_top":false,"comment_ctime":1590905146,"is_pvip":false,"replies":[{"id":"82142","content":"go只有简单的了解，没有深入用过。<br><br>C++对错误处理没有强制要求，你可以自由选择处理的方式，所以也要同时承受自由的代价，就是语言不会帮助你包办一切。","user_name":"作者回复","user_name_real":"罗剑锋","uid":"1181974","ctime":1590918897,"ip_address":"","comment_id":222751,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1590905146","product_id":100051801,"comment_content":"之前有在网络连接时候用try catch，其实导致了不必要的overhead. 另外不知道笔者用过Golang没，对漫天飞舞的err ！=nil怎么看，函数默认都可以返回错误与信息两者，然后层层处理，这个虽然繁琐，但是是不是也少了不少坑而且性能更佳？","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496902,"discussion_content":"go只有简单的了解，没有深入用过。\n\nC++对错误处理没有强制要求，你可以自由选择处理的方式，所以也要同时承受自由的代价，就是语言不会帮助你包办一切。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590918897,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1994848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/TXAUcbHlPbyEibtUB2STNgmOb6oQdO8nKuA9nnhuI76Ccv2U5Vgxfp8YxvGeKQP8k47ULBwVGglH4DibOzH8Qfeg/132","nickname":"IAmLinGe","note":"","ucode":"9DCDA0FA5CF2B0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286521,"discussion_content":"err ！= nil 其实就是错误码的形式！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593205220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221260,"user_name":"java2c++","can_delete":false,"product_type":"c1","uid":1460660,"ip_address":"","ucode":"C4F8C3D7B1A910","user_header":"","comment_is_top":false,"comment_ctime":1590457426,"is_pvip":false,"replies":[{"id":"81608","content":"<br>1.异常有个问题就是没有调用栈信息，Boost里好像有个trace_back，搭配起来就好了。<br><br>2.用异常来处理转换字符串好像有点大材小用了，我个人觉得这样做不是太好。","user_name":"作者回复","user_name_real":"chrono","uid":"1181974","ctime":1590461404,"ip_address":"","comment_id":221260,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590457426","product_id":100051801,"comment_content":"用途1:捕获到异常后可以记录到日志文件中，很容易找到出问题的地方以及出问题的原因，比coredump分析容易多了。用途2:代码分支处理，一个经典的案例就是入参需要string转int，可以转换就走正常逻辑，不可以转换出现异常就直接返回错误原因给上游","like_count":0,"discussions":[{"author":{"id":1181974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/09/16/1161017c.jpg","nickname":"罗剑锋","note":"","ucode":"95678C988F24AB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496406,"discussion_content":"\n1.异常有个问题就是没有调用栈信息，Boost里好像有个trace_back，搭配起来就好了。\n\n2.用异常来处理转换字符串好像有点大材小用了，我个人觉得这样做不是太好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590461404,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}