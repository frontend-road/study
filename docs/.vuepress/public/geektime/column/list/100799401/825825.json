{"id":825825,"title":"40｜MySQL 8.0 Clone 插件的应用和内部原理","content":"<p>你好，我是俊达。</p><p>前面我讲过，搭建一个备库，有一个核心的步骤是同步源库的初始状态。逻辑备份（比如使用mysqldump）和物理备份（比如使用xtrabackup）都可以用来初始化备库。MySQL 8.0中，还引入了Clone插件，也可以用来初始化一个备库。有了Clone插件，搭建备库会变得更加简单。MySQL MGR（Group Replication）也会使用Clone插件来初始化成员的数据。此外，还可以将整个数据库克隆到本地的一个目录中，这相当于是给数据库做了一个全量备份。</p><p>这一讲中，我们就来聊一聊Clone插件的一些用法，以及Clone插件的内部原理。</p><h2>Clone插件介绍</h2><p>MySQL 8.0.17版本引入了clone插件。使用Clone插件可以对本地或远程的mysql实例进行克隆操作。Clone插件会拷贝InnoDB存储引擎表，克隆得到的是数据库的一个一致的快照，可以使用这个快照数据来启动新的数据库实例。Clone插件还会记录数据库的Binlog位点，可以将克隆得到的实例作为源实例的备库。</p><p>Clone插件支持本地克隆和远程克隆这两种模式。本地克隆将数据存放在源数据库所在主机上。远程克隆涉及到两个实例，提供数据的实例称为捐赠者（Donor），接收数据的实例称为接收者（Recipient）。捐赠者将整个数据库通过MySQL网络协议发送给接收者，接收者将数据存放到数据目录。</p><!-- [[[read_end]]] --><p>你要先安装Clone插件，才能使用克隆的功能。我们可以在配置文件中配置。</p><pre><code class=\"language-plain\">[mysqld]\nplugin-load-add=mysql_clone.so\n</code></pre><p>也可以使用install plugin命令安装插件。</p><pre><code class=\"language-plain\">mysql&gt; install plugin clone soname 'mysql_clone.so';\n</code></pre><p>使用show plugins命令或到plugins表查看插件状态。</p><pre><code class=\"language-plain\">mysql&gt; SELECT PLUGIN_NAME, PLUGIN_STATUS \n    FROM INFORMATION_SCHEMA.PLUGINS\n    WHERE PLUGIN_NAME = 'clone';\n\n+-------------+---------------+\n| PLUGIN_NAME | PLUGIN_STATUS |\n+-------------+---------------+\n| clone       | ACTIVE        |\n+-------------+---------------+\n</code></pre><p>使用uninstall plugin命令卸载插件。</p><pre><code class=\"language-plain\">mysql&gt; uninstall plugin clone;\nQuery OK, 0 rows affected (0.19 sec)\n</code></pre><h2>本地Clone</h2><p>本地Clone得到的数据文件和源实例存放在同一台主机上。</p><p>下面这个是官方文档中本地克隆的一个示意图。</p><p><img src=\"https://static001.geekbang.org/resource/image/6d/50/6d08e4b802b4bce1d5bcf104f227a850.png?wh=907x648\" alt=\"图片\"></p><p>执行clone命令的账号需要有backup_admin权限。</p><pre><code class=\"language-plain\">GRANT BACKUP_ADMIN ON *.* TO 'clone_user';\n</code></pre><p>使用clone local命令发起本地克隆，命令中要指定克隆数据的存放路径，使用绝对路径。路径的最后一层是克隆数据的顶层目录，这个目录不能存在，Clone命令会自己创建这个目录，否则会报错“database exists”。路径中的其它目录需要先创建好，比如下面例子中的/data/clone目录。</p><pre><code class=\"language-plain\">CLONE LOCAL DATA DIRECTORY  '/data/clone/mysql02_backup';\n</code></pre><p>运行MySQL的操作系统账号需要有相应路径的读写权限，不然clone命令会报错。</p><pre><code class=\"language-plain\">ERROR 1006 (HY000): Can't create database '/data/clone/mysql02_backup/' (errno: 13 - Permission denied)\n</code></pre><p>Clone操作不能并行执行，同一个时间内， 一个数据库中最多只能运行一个克隆进程。</p><pre><code class=\"language-plain\">ERROR 3634 (HY000): Too many concurrent clone operations. Maximum allowed - 1.\n</code></pre><h3>查看clone状态</h3><p>你可以到performance_schema.clone_status表，查看最新一次clone操作的状态。</p><pre><code class=\"language-plain\">mysql&gt; select * from performance_schema.clone_status\\G\n*************************** 1. row ***************************\n             ID: 1\n            PID: 55\n          STATE: Completed\n     BEGIN_TIME: 2023-08-22 15:11:26.581\n       END_TIME: 2023-08-22 15:11:36.646\n         SOURCE: LOCAL INSTANCE\n    DESTINATION: /data/clone/mysql02_backup/\n       ERROR_NO: 0\n  ERROR_MESSAGE:\n    BINLOG_FILE:\nBINLOG_POSITION: 0\n  GTID_EXECUTED:\n1 row in set (0.00 sec)\n</code></pre><h3>使用Clone的数据启动实例</h3><p>Clone得到的文件，是原实例的一个一致性的快照，可以使用这些文件来启动mysql实例。可手动创建一个配置文件，将datadir指向clone路径，就可以启动mysql实例。</p><pre><code class=\"language-plain\">##/data/clone/my.cnf\n[mysqld]\nport=3333\ndatadir=/data/clone/mysql02_backup\n...\n</code></pre><pre><code class=\"language-plain\">mysqld_safe --defaults-file=/data/clone/my.cnf &amp;\n</code></pre><p>实例启动后，可以看到，gtid_executed和Clone时，源库的gtid_executed一致。</p><pre><code class=\"language-plain\">mysql&gt; show master status\\G\n*************************** 1. row ***************************\n             File: binlog.000001\n         Position: 157\n     Binlog_Do_DB:\n Binlog_Ignore_DB:\nExecuted_Gtid_Set: b094c003-8cfa-11ef-bf79-fab81f64ee00:1-2302\n</code></pre><p>需要注意的是，Clone操作只会克隆InnoDB存储引擎的表，以及MySQL的系统表。如果有MyISAM表，需要用其他方法来备份。</p><p>使用Xtrabackup备份的数据库，在恢复时，还需要先Prepare后，才能启动。但是使用Clone插件备份出来的数据库，可以直接启动。</p><h2>远程Clone</h2><p>远程Clone将整个数据库从捐赠者（Donor）复制到接受者（Recipient）。接受者实例原先的数据会被清理掉。</p><p>下面这个是官方文档中，远程Clone的示意图。</p><p><img src=\"https://static001.geekbang.org/resource/image/8b/10/8b5ebe4fa145yy92e12d6f8c5aaffd10.png?wh=966x602\" alt=\"图片\"></p><p>使用clone instance命令发起远程克隆。</p><pre><code class=\"language-plain\">CLONE INSTANCE FROM 'user'@'host':port\nIDENTIFIED BY 'password'\n[DATA DIRECTORY [=] 'clone_dir']\n[REQUIRE [NO] SSL];\n</code></pre><p>容易看出命令中几个参数的含义。</p><ul>\n<li>user：登录捐赠者实例的用户名。</li>\n<li>host：捐赠者实例的主机名或IP。</li>\n<li>port：捐赠者实例的端口。</li>\n<li>password：捐赠者实例的密码。</li>\n<li>clone_dir：不指定clone_dir时，会清空接受者实例的datadir目录，并将数据放到datadir目录中。如果指定了data directory，则该路径需要不存在，mysql服务需要有目录权限。</li>\n<li>REQUIRE [NO] SSL：指定传输数据是否使用加密协议。</li>\n</ul><h3>远程clone前置条件</h3><p>使用远程clone需要满足几点前置条件。</p><ul>\n<li>\n<p>账号权限，捐赠者的账号需要有backup_admin权限。接受者的账号需要clone_admin权限。clone_admin权限包含backup_admin权限和shutdown权限。</p>\n</li>\n<li>\n<p>捐赠者和接受者的版本需要保持一致。不仅大版本要一样，小版本也要一样。可使用show variables命令查看版本。</p>\n</li>\n</ul><pre><code class=\"language-plain\">mysql&gt; SHOW VARIABLES LIKE 'version';\n+---------------+--------+\n| Variable_name | Value  |\n+---------------+--------+\n| version       | 8.0.32 |\n+---------------+--------+\n</code></pre><ul>\n<li>\n<p>捐赠者和接受者的运行平台和操作系统需要一致。</p>\n</li>\n<li>\n<p>捐赠者和接受者都需要安装Clone插件。</p>\n</li>\n<li>\n<p>捐赠者和接受者字符集需要一样（character_set_server，collation_server）。</p>\n</li>\n<li>\n<p>捐赠者和接受者的参数innodb_page_size，innodb_data_file_path需要一样。</p>\n</li>\n<li>\n<p>接受者上，参数clone_valid_donor_list需要包含捐赠者的地址。</p>\n</li>\n<li>\n<p>默认情况下，远程clone会在完成数据克隆后，重启接受者实例。需要有控制进程（如mysqld_safe脚本、systemctl等）来拉起接受者实例。如果缺少控制进程，则接受者实例关闭后，无法自动启动，会报下面这样的错误。</p>\n</li>\n</ul><pre><code class=\"language-plain\">ERROR 3707 (HY000): Restart server failed (mysqld is not managed by supervisor process).\n</code></pre><h3>远程clone操作步骤</h3><p>接下来演示远程Clone操作的基本步骤。</p><h4>1. 在捐赠者实例上创建相关账号并授权</h4><pre><code class=\"language-plain\">mysql&gt; CREATE USER 'donor'@'%' IDENTIFIED BY 'password';\nmysql&gt; GRANT BACKUP_ADMIN on *.* to 'donor'@'%';\n</code></pre><h4>2. 在接受者实例上创建账号并授权</h4><pre><code class=\"language-plain\">CREATE USER 'recipient'@'%' IDENTIFIED BY 'password';\nGRANT CLONE_ADMIN on *.* to 'recipient'@'%';\n</code></pre><h4>3. 登录接受者实例，发起clone操作</h4><pre><code class=\"language-plain\">CLONE INSTANCE FROM 'donor'@'host':port\nIDENTIFIED BY 'password';\n</code></pre><p>clone完成后，会自动重启接受者实例。</p><h2>Clone插件的一些限制</h2><ul>\n<li>\n<p>8.0.27版本之前，clone时，捐赠者和接受者都不允许进行DDL。从8.0.27版本开始，捐赠者默认可以进行DDL，可以由参数clone_block_ddl进行控制。clone_block_ddl设置为ON时，clone运行时，DDL会被阻塞。</p>\n</li>\n<li>\n<p>一次只能clone一个实例。</p>\n</li>\n<li>\n<p>clone插件不会复制mysql参数。clone时，不会将捐赠者实例的参数复制到接受者实例。</p>\n</li>\n<li>\n<p>clone插件不会复制binlog。</p>\n</li>\n<li>\n<p>clone插件只复制存储在innodb存储引擎中的数据。不会复制myisam、csv等其他存储引擎的数据。</p>\n</li>\n<li>\n<p>不支持通过mysql router连接到捐赠者实例。</p>\n</li>\n<li>\n<p>本地Clone操作不支持复制使用了绝对路径的通用表空间。</p>\n</li>\n</ul><h2>Clone插件实现</h2><p>最后我们来看一下Clone插件是怎么实现数据克隆的。</p><p><img src=\"https://static001.geekbang.org/resource/image/3c/57/3c90c00846fb65ce50b5b70646b9a657.jpg?wh=1310x543\" alt=\"图片\"></p><p>参考上面这个图，数据库克隆主要分为几个阶段。</p><ol>\n<li>初始阶段（Init）</li>\n</ol><p>在初始阶段，会开启页面跟踪（Page Tracking）。开启页面跟踪后，会将发生过数据修改的页面的编号记录下来。页面的修改可分为两个阶段：首先在内存中修改，也就是先修改InnoDB Buffer Pool里的缓存的页面；然后被修改的页面会在一定的时机写回到数据文件。页面跟踪机制会在页面持久化的时候记录页面的编号（页面的表空间ID和Page ID）。</p><ol start=\"2\">\n<li>文件复制阶段（File Copy）</li>\n</ol><p>在这一阶段，Clone插件会复制所有InnoDB文件。文件复制完成后，开启InnoDB Redo归档，关闭页面跟踪。</p><ol start=\"3\">\n<li>页面复制阶段（Page Copy）</li>\n</ol><p>在这一阶段，会将文件复制过程中跟踪到的页面复制出来。也就是在文件复制过程中，发生过修改的页面，会在页面复制阶段拷贝到克隆数据库中。</p><p>页面复制完成后，停止Redo归档。将当时的lsn号记录为clone lsn，这也是clone出来的数据库的lsn号。这里还会记录实例当前的复制位点，包括binlog位点和gitd_executed信息，gtid_executed会存储到mysql.gtid_executed表。</p><ol start=\"4\">\n<li>Redo复制阶段（Redo Copy）</li>\n</ol><p>在这一阶段，要处理归档出来的Redo日志，将Redo日志应用到克隆数据库中。应用完归档日志后，克隆出来的数据库文件可以直接用来启动一个数据库实例。</p><h3>如何保证克隆数据的一致性？</h3><p>Clone插件如何保证最终得到的数据的一致性呢？假设clone开始的时候checkpoint lsn为ckpt_0，clone文件复制结束的时候checkpoint lsn为ckpt_1。</p><ol>\n<li>\n<p>首先在clone开始时（clone start lsn），先开启了页面跟踪。开启页面跟踪后，在这个时间点之后写入文件的页面编号都会被记录下来。</p>\n</li>\n<li>\n<p>文件复制阶段会将所有已经完成持久化的数据复制出来。这一步保证ckpt_0之前修改的数据都被复制出来。</p>\n</li>\n<li>\n<p>文件复制过程中，数据库文件会持续更新。由于开启了页面跟踪，数据文件中更新过的页面编号都会被记录下来。关闭页面跟踪时数据库checkpoint为ckpt_1，那么ckpt_0和ckpt_1之间修改的页面，都会被记录下来，这些页面会在页面复制阶段拷贝到克隆数据库中。</p>\n</li>\n<li>\n<p>文件复制完成后、关闭页面跟踪前，会先开启Redo归档。Redo归档会将日志序列号在当前checkpoint lsn（不超过ckpt_1）之后的redo日志都复制到归档REDO文件中。由于Redo归档是在关闭页面跟踪前开启的，所以能保证ckpt_1之后的Redo日志都会被复制到归档的Redo文件中。</p>\n</li>\n<li>\n<p>页面复制结束时，可能会有部分页面的数据修改还没有刷新到磁盘。这些页面修改的日志序列号都在ckpt_1之后。而ckpt_1之后的Redo日志都拷贝到归档的Redo文件中了，将归档的Redo日志应用到克隆数据库后，就可以将数据库恢复到一个一致的时间点（clone lsn)，也就是停止Redo归档时的那一刻。</p>\n</li>\n</ol><h2>总结</h2><p>有了Clone插件后，给数据库添加一个备库就变得更简单了，你可以不依赖第三方备份工具，直接初始化备库的数据。你还可以基于本地Clone来实现数据库的物理备份，相比于Xtrabackup，Clone插件是MySQL官方提供的，使用也比较方便。需要注意的是，Clone插件只支持InnoDB存储引擎。</p><h2>思考题</h2><p>你需要将一个Clone出来的数据库，作为备库，加入到原先的复制架构中。如果使用GTID Auto Positon，那么Clone的数据库启动时，会根据mysql.gtid_executed表的记录，正确地设置gtid_executed变量，因此可以直接建立复制关系。但如果使用了基于位点的复制，你应该从哪个Binlog位点开启复制呢？这个Binlog位点信息是存储在哪个地方的？</p><p>期待你的思考，欢迎在留言区中与我交流。如果今天的课程让你有所收获，也欢迎转发给有需要的朋友。我们下节课再见。</p>","comments":[{"had_liked":false,"id":396322,"user_name":"范特西","can_delete":false,"product_type":"c1","uid":2642712,"ip_address":"浙江","ucode":"1905108C050D6E","user_header":"https://static001.geekbang.org/account/avatar/00/28/53/18/de532447.jpg","comment_is_top":false,"comment_ctime":1733973434,"is_pvip":false,"replies":[{"id":143867,"content":"是的，performance_schema.clone_status 表里可以查到Clone完成时对应的Binlog位点。\n\nCREATE TABLE `clone_status` (\n  `ID` int DEFAULT NULL,\n  `PID` int DEFAULT NULL,\n  `STATE` char(16) DEFAULT NULL,\n  `BEGIN_TIME` timestamp(3) NULL DEFAULT NULL,\n  `END_TIME` timestamp(3) NULL DEFAULT NULL,\n  `SOURCE` varchar(512) DEFAULT NULL,\n  `DESTINATION` varchar(512) DEFAULT NULL,\n  `ERROR_NO` int DEFAULT NULL,\n  `ERROR_MESSAGE` varchar(512) DEFAULT NULL,\n  `BINLOG_FILE` varchar(512) DEFAULT NULL,\n  `BINLOG_POSITION` bigint DEFAULT NULL,\n  `GTID_EXECUTED` varchar(4096) DEFAULT NULL\n) ENGINE=PERFORMANCE_SCHEMA DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci","user_name":"作者回复","user_name_real":"编辑","uid":3898827,"ctime":1733983198,"ip_address":"浙江","comment_id":396322,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100799401,"comment_content":"课后问题，我觉得应该查看：select * from performance_schema.clone_status 表","like_count":0,"discussions":[{"author":{"id":3898827,"avatar":"https://static001.geekbang.org/account/avatar/00/3b/7d/cb/fa3dae58.jpg","nickname":"俊达","note":"","ucode":"F79BF9651AD086","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":655011,"discussion_content":"是的，performance_schema.clone_status 表里可以查到Clone完成时对应的Binlog位点。\n\nCREATE TABLE `clone_status` (\n  `ID` int DEFAULT NULL,\n  `PID` int DEFAULT NULL,\n  `STATE` char(16) DEFAULT NULL,\n  `BEGIN_TIME` timestamp(3) NULL DEFAULT NULL,\n  `END_TIME` timestamp(3) NULL DEFAULT NULL,\n  `SOURCE` varchar(512) DEFAULT NULL,\n  `DESTINATION` varchar(512) DEFAULT NULL,\n  `ERROR_NO` int DEFAULT NULL,\n  `ERROR_MESSAGE` varchar(512) DEFAULT NULL,\n  `BINLOG_FILE` varchar(512) DEFAULT NULL,\n  `BINLOG_POSITION` bigint DEFAULT NULL,\n  `GTID_EXECUTED` varchar(4096) DEFAULT NULL\n) ENGINE=PERFORMANCE_SCHEMA DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1733983198,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":396243,"user_name":"ls","can_delete":false,"product_type":"c1","uid":1001037,"ip_address":"中国台湾","ucode":"C18E208B1DFDA7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/46/4d/161f3779.jpg","comment_is_top":false,"comment_ctime":1733736700,"is_pvip":true,"replies":[{"id":143853,"content":"slave_master_info表记录了备库读取主库binlog的位点。","user_name":"作者回复","user_name_real":"编辑","uid":3898827,"ctime":1733882038,"ip_address":"浙江","comment_id":396243,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100799401,"comment_content":"mysql.slave_master_info 表是不是有 Binlog 文件和位点信息？","like_count":0,"discussions":[{"author":{"id":3898827,"avatar":"https://static001.geekbang.org/account/avatar/00/3b/7d/cb/fa3dae58.jpg","nickname":"俊达","note":"","ucode":"F79BF9651AD086","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":654960,"discussion_content":"slave_master_info表记录了备库读取主库binlog的位点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1733882038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]}]}