{"id":111482,"title":"39 | Staffjoy安全认证架构和SSO","content":"<ul>\n<li>\n<p>代码：<a href=\"https://gitee.com/geektime-geekbang/staffjoy\">https://gitee.com/geektime-geekbang/staffjoy</a></p>\n</li>\n<li>\n<p>课件：<a href=\"https://pan.baidu.com/s/1Q7eP3yZ1Vm8J2nhle5RzTQ\">https://pan.baidu.com/s/1Q7eP3yZ1Vm8J2nhle5RzTQ</a> 提取码: 1aeh</p>\n</li>\n</ul>","comments":[{"had_liked":false,"id":150949,"user_name":"DDs moving castle","can_delete":false,"product_type":"c3","uid":1066684,"ip_address":"","ucode":"08CA816F665E39","user_header":"https://static001.geekbang.org/account/avatar/00/10/46/bc/463cca3f.jpg","comment_is_top":false,"comment_ctime":1573633778,"is_pvip":false,"replies":[{"id":58257,"content":"第一个问题，我的建议是遵循业界规范或最佳实践流程，因为这些流程已经经过行业安全专家论证，也经过工业界踩坑才总结沉淀下来，你没必要重造轮子，如果你绕开，虽然能省事，但是难免留下风险漏洞。\n\n第二个问题，OAuth2只是一种代理授权(delegated authorization)协议，严格不是身份认证协议，fusionauth的推荐的做法，已经不是纯OAuth2协议，而是一种基于JWT的OIDC(openid connect)协议的变体，OIDC是在OAuth2的基础上增加身份认证层。官方的OIDC也不推荐access token同时用作身份认证，而是有单独的identity token(常用JWT)。fusionauth推荐的做法，可以认为是OIDC的一种变体，对于第一方应用(都是一个企业自己开发的应用)，应该是可行的，如果涉及第三方，则需要考虑严格的OIDC协议。\n\n关于OAuth2和OIDC协议，建议读一下OAuth2 in Action这本书，对协议流程细节，背后原理有详细解释。http:&#47;&#47;product.dangdang.com&#47;27851751.html\n\n","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1573736052,"ip_address":"","comment_id":150949,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100031401,"comment_content":"多谢波波老师的讲解和推荐，fusionauth针对不同应用场景的登录认证流程我看了，真的很细致了，话说您是怎么找到了，我之前也看过fusionauth，但只找到了类似API文档的部分，厉害。\n\n我说的除了在Auth Service维护集中状态，还维护每个应用的登录状态，其实是从原来公司在单体应用时引入的开源CAS单点登录的思路来的，fusionauth的文章中和这篇的思路是一样的。\n标题：(RECOMMENDED) OAuth 2 authorization code grant using sessions\nhttps:&#47;&#47;fusionauth.io&#47;articles&#47;logins&#47;spa&#47;oauth-authorization-code-grant-sessions\n但这种方式的弊端是，SPA在登录时需要跳转到Auth Service的登录页面，由于公司的SPA登录页风格要统一，而且单页应用跳来跳去感觉体验不是很好，虽然硬着头皮做了，但想优化一下。\n不知道上面链接这种方式，波波老师什么看法？？\n\n另外，我在看fusionauth的登录流程中发现，他们推荐一种将OAuth2的JWT格式的accessToken、引用类型的refreshToken放在cookie中返回给客户浏览器的做法，之后将JWT格式的accessToken当做登录凭证的做法，这种做法确实可以实现，从中可以获取到user信息，但我对于是否应该将OAuth的accessToken用于认证持否定态度，或者说最好不要。我从之前找到的一篇ORY的FAQ中看到了和我类似的观点：\nhttps:&#47;&#47;www.ory.sh&#47;docs&#47;next&#47;hydra&#47;faq#should-i-use-oauth2-tokens-for-authentication\n网上也有人使用accessToken认证的凭证，也有单独颁发认证凭证再在服务器端与accessToken关联的。请问波波老师对于使用OAuth的accessToken做登录认证是什么看法？？","like_count":6,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474321,"discussion_content":"第一个问题，我的建议是遵循业界规范或最佳实践流程，因为这些流程已经经过行业安全专家论证，也经过工业界踩坑才总结沉淀下来，你没必要重造轮子，如果你绕开，虽然能省事，但是难免留下风险漏洞。\n\n第二个问题，OAuth2只是一种代理授权(delegated authorization)协议，严格不是身份认证协议，fusionauth的推荐的做法，已经不是纯OAuth2协议，而是一种基于JWT的OIDC(openid connect)协议的变体，OIDC是在OAuth2的基础上增加身份认证层。官方的OIDC也不推荐access token同时用作身份认证，而是有单独的identity token(常用JWT)。fusionauth推荐的做法，可以认为是OIDC的一种变体，对于第一方应用(都是一个企业自己开发的应用)，应该是可行的，如果涉及第三方，则需要考虑严格的OIDC协议。\n\n关于OAuth2和OIDC协议，建议读一下OAuth2 in Action这本书，对协议流程细节，背后原理有详细解释。http://product.dangdang.com/27851751.html\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573736052,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150219,"user_name":"DDs moving castle","can_delete":false,"product_type":"c3","uid":1066684,"ip_address":"","ucode":"08CA816F665E39","user_header":"https://static001.geekbang.org/account/avatar/00/10/46/bc/463cca3f.jpg","comment_is_top":false,"comment_ctime":1573479962,"is_pvip":false,"replies":[{"id":57900,"content":"我目前经历的两家公司，一家是旅游网携程，另外一家是拍拍贷金融，这两家都是基于令牌的集中状态式认证，集中状态好处是严格安全而且可以集中吊销。一般到这个体量的公司，Auth Service的高可用是必须要做到的。\n\n除了集中状态认证，目前业界比较流行的就是基于JWT的无状态认证(这个其实也有状态，只是状态被编码在JWT令牌里头)。你讲的既可以集中服务器认证，也可以在集中服务器不可用时，进行本地local认证方式，我暂时还没有经验。\n\n针对不同应用场景(传统Web&#47;单页SPA&#47;无线)的登录认证流程，这里有一个最全面的链接，里头的流程图很细致，供参考研究：\nhttps:&#47;&#47;fusionauth.io&#47;articles&#47;logins&#47;types-of-logins-authentication-workflows\n\n\n","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1573560074,"ip_address":"","comment_id":150219,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100031401,"comment_content":"波波老师，我们公司是做金融相关系统的，还是想考虑有状态的认证架构，而且不想只在Auth Service认证服务这里维护一个集中状态，因为这样如果Auth Service不可用，整个系统无论登录和校验登录状态都做不了了，会导致整个系统不可用，所以除了Auth Service认证服务维护登录状态，在通过Auth Service单点登录后的应用系统微服务也想维护个登录状态，感觉这样只会在单点登录时和Auth Service有交互，其它校验登录状态时在自己应用内部查找登录状态即可，请问如果在微服务架构中要实现这样的有状态架构，有什么项目或者案例可以参考吗？？\n\n另外Auth Service考虑使用OAuth2实现，对于第一方应用想使用password模式，但感觉实现SSO有点麻烦，因为浏览器不会直接与OAuth2服务交互，无法种下OAuth2服务的cookie；\n对于第三方想使用授权码模式，但现在前后端分离的架构下，前端要实现授权码模式的多次重定向且登录页面与应用系统风格统一又比较难；\n请教波波老师有什么建议或者资料案例、架构设计推荐吗？？\n多谢。","like_count":4,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474096,"discussion_content":"我目前经历的两家公司，一家是旅游网携程，另外一家是拍拍贷金融，这两家都是基于令牌的集中状态式认证，集中状态好处是严格安全而且可以集中吊销。一般到这个体量的公司，Auth Service的高可用是必须要做到的。\n\n除了集中状态认证，目前业界比较流行的就是基于JWT的无状态认证(这个其实也有状态，只是状态被编码在JWT令牌里头)。你讲的既可以集中服务器认证，也可以在集中服务器不可用时，进行本地local认证方式，我暂时还没有经验。\n\n针对不同应用场景(传统Web/单页SPA/无线)的登录认证流程，这里有一个最全面的链接，里头的流程图很细致，供参考研究：\nhttps://fusionauth.io/articles/logins/types-of-logins-authentication-workflows\n\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573560074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134673,"user_name":"海罗沃德","can_delete":false,"product_type":"c3","uid":1165364,"ip_address":"","ucode":"8704F1D6980FA0","user_header":"https://static001.geekbang.org/account/avatar/00/11/c8/34/fb871b2c.jpg","comment_is_top":false,"comment_ctime":1568890259,"is_pvip":false,"replies":[{"id":51819,"content":"可以简单搞个算法，如果JWT临近过期(比如过期前10分钟）客户还有不断操作，可以自动刷新令牌，自动延长一个周期。","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1568983200,"ip_address":"","comment_id":134673,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100031401,"comment_content":"用户如果登陆后操作了一段时间，JWT过期了但是用户并没有结束使用，要如何实现不需要重新登陆就能更新JWT令牌？","like_count":3,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467857,"discussion_content":"可以简单搞个算法，如果JWT临近过期(比如过期前10分钟）客户还有不断操作，可以自动刷新令牌，自动延长一个周期。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568983200,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245180,"user_name":"飞鹤Plus","can_delete":false,"product_type":"c3","uid":1091239,"ip_address":"","ucode":"DBD24A951BA18E","user_header":"https://static001.geekbang.org/account/avatar/00/10/a6/a7/86c32422.jpg","comment_is_top":false,"comment_ctime":1598857447,"is_pvip":false,"replies":[{"id":90193,"content":"token可以是无意义随机字符串，比如uuid，你在数据库里头只要建立用户名和token的映射关系就可以，后续可以通过用户找到token，或者通过token找到用户名，这样就可以了。","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1598882987,"ip_address":"","comment_id":245180,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100031401,"comment_content":"波波老师，我们项目是spring cloud开发的，权限使用的是jwt+spring security，走的是用户名密码模式；现在有个对接统一权限的需求，我们把统一权限和用户同步到业务系统，统一权限认证，如果成功了返回ticket。我们得到了ticket，可以确认登陆成功了，请问如何在知道用户名的情况下生成Token？密码是未知的。\n\n有没有方法，可以通过用户名生成Token。期待波波老师的回复。","like_count":1,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504807,"discussion_content":"token可以是无意义随机字符串，比如uuid，你在数据库里头只要建立用户名和token的映射关系就可以，后续可以通过用户找到token，或者通过token找到用户名，这样就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598882987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1091239,"avatar":"https://static001.geekbang.org/account/avatar/00/10/a6/a7/86c32422.jpg","nickname":"飞鹤Plus","note":"","ucode":"DBD24A951BA18E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336746,"discussion_content":"波波老师，您的意思是做token映射，前提是需要存储token的方式，然后映射用户与token。但我们项目已成熟，token是不保存的。架构是通过JHipster搭建的spring cloud微服务，包括了gateway、uaa、user等服务，通过用户名密码获取token，验证token的底层逻辑；感觉在现有用户名密码获取token的模式下，扩展用户名与token映射，感觉无从下手。\n\n请问有没有兼容用户名密码模式下，验证token接口，又可以通过用户名获取token的扩展方案或思路。目前我们给一个默认密码，但现在需要对密码进行修改，不能使用这种模式了。\n\n\n另外，我们在项目中验证OAuth2授权码模式时，在授权服务器通过login.html，输入用户名密码 请求/login接口获取code的时候，debug发现到不了AuthorizationEndpoint类的&#34;/oauth/authorize”，走了UserDetails loadUserByUsername 这些方法，但没发现错误，排查时，通过抓包工具也看不到有异常。请求，不走&#34;/oauth/authorize”，这块如何排查原因。\n请求链接：http://localhost:9999/oauth/authorize?response_type=code&amp;client_id=web_app&amp;redirect_uri=http://localhost:8082/memberSystem/member/list","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608691531,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":234929,"user_name":"边际革命","can_delete":false,"product_type":"c3","uid":1124665,"ip_address":"","ucode":"EC15C0AE4D487A","user_header":"https://static001.geekbang.org/account/avatar/00/11/29/39/be9d2e88.jpg","comment_is_top":false,"comment_ctime":1594827883,"is_pvip":false,"replies":[{"id":86961,"content":"www服务完全可以做成前后分离，之所以没有做，是因为这个项目是原版Staffjoy(也就是golang版)的一个简化克隆版，保留了原版的设计。\n\n后面我会开发一个完全前后分离的电商应用，欢迎关注。","user_name":"作者回复","user_name_real":"杨波","uid":1030344,"ctime":1595004083,"ip_address":"","comment_id":234929,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100031401,"comment_content":"www服务为什么不是前后端分离的呢，app和myaccount为什么是前后端分离的？","like_count":0,"discussions":[{"author":{"id":1030344,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b8/c8/c94d38a7.jpg","nickname":"杨波","note":"","ucode":"FA3418BB703BCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501551,"discussion_content":"www服务完全可以做成前后分离，之所以没有做，是因为这个项目是原版Staffjoy(也就是golang版)的一个简化克隆版，保留了原版的设计。\n\n后面我会开发一个完全前后分离的电商应用，欢迎关注。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595004083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":388035,"user_name":"Geek_3100bd","can_delete":false,"product_type":"c3","uid":2860083,"ip_address":"广东","ucode":"3616C167C32559","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqjK4a3amPeGBnicFgVEnZyF0z2AcKYpjHyqTujBMf7dul0CTK5MFVsfmICaksVwMiaHU76nY7ia1dnA/132","comment_is_top":false,"comment_ctime":1709197832,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100031401,"comment_content":"老师，用户登录注册操作直接请求authservice服务吗？，不需要经过网关吗，如果直接请求authservice服务，那么有人恶意攻击，或者限流熔断这块是在authserivce单独做吗","like_count":0},{"had_liked":false,"id":363313,"user_name":"GVCIC028","can_delete":false,"product_type":"c3","uid":3026521,"ip_address":"北京","ucode":"1354FE4F8A82FD","user_header":"","comment_is_top":false,"comment_ctime":1669525314,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100031401,"comment_content":"老师，JWT为什么是前端WWW WEB MVC APP生成的? 这个WWW 服务调用后端的Account API还需要相互间做认证吗？另外faraday 调用Account API 服务，还需要进行服务间调用的校验吗？","like_count":0}]}