{"id":94479,"title":"19 | 线程的创建：如何执行一个新子项目？","content":"<p>上一节，我们了解了进程创建的整个过程，今天我们来看线程创建的过程。</p><p>我们前面已经写过多线程编程的程序了，你应该都知道创建一个线程调用的是pthread_create，可你知道它背后的机制吗？</p><h2>用户态创建线程</h2><p>你可能会问，咱们之前不是讲过了吗？无论是进程还是线程，在内核里面都是任务，管起来不是都一样吗？但是问题来了，如果两个完全一样，那为什么咱们前两节写的程序差别那么大？如果不一样，那怎么在内核里面加以区分呢？</p><p>其实，线程不是一个完全由内核实现的机制，它是由内核态和用户态合作完成的。pthread_create不是一个系统调用，是Glibc库的一个函数，所以我们还要去Glibc里面去找线索。</p><p>果然，我们在nptl/pthread_create.c里面找到了这个函数。这里的参数我们应该比较熟悉了。</p><pre><code>int __pthread_create_2_1 (pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg)\n{\n......\n}\nversioned_symbol (libpthread, __pthread_create_2_1, pthread_create, GLIBC_2_1);\n</code></pre><p>下面我们依次来看这个函数做了些啥。</p><p>首先处理的是线程的属性参数。例如前面写程序的时候，我们设置的线程栈大小。如果没有传入线程属性，就取默认值。</p><pre><code>const struct pthread_attr *iattr = (struct pthread_attr *) attr;\nstruct pthread_attr default_attr;\nif (iattr == NULL)\n{\n  ......\n  iattr = &amp;default_attr;\n}\n</code></pre><p>接下来，就像在内核里一样，每一个进程或者线程都有一个task_struct结构，在用户态也有一个用于维护线程的结构，就是这个pthread结构。</p><!-- [[[read_end]]] --><pre><code>struct pthread *pd = NULL;\n</code></pre><p>凡是涉及函数的调用，都要使用到栈。每个线程也有自己的栈。那接下来就是创建线程栈了。</p><pre><code>int err = ALLOCATE_STACK (iattr, &amp;pd);\n</code></pre><p>ALLOCATE_STACK是一个宏，我们找到它的定义之后，发现它其实就是一个函数。只是，这个函数有些复杂，所以我这里把主要的代码列一下。</p><pre><code># define ALLOCATE_STACK(attr, pd) allocate_stack (attr, pd, &amp;stackaddr)\n\n\nstatic int\nallocate_stack (const struct pthread_attr *attr, struct pthread **pdp,\n                ALLOCATE_STACK_PARMS)\n{\n  struct pthread *pd;\n  size_t size;\n  size_t pagesize_m1 = __getpagesize () - 1;\n......\n  size = attr-&gt;stacksize;\n......\n  /* Allocate some anonymous memory.  If possible use the cache.  */\n  size_t guardsize;\n  void *mem;\n  const int prot = (PROT_READ | PROT_WRITE\n                   | ((GL(dl_stack_flags) &amp; PF_X) ? PROT_EXEC : 0));\n  /* Adjust the stack size for alignment.  */\n  size &amp;= ~__static_tls_align_m1;\n  /* Make sure the size of the stack is enough for the guard and\n  eventually the thread descriptor.  */\n  guardsize = (attr-&gt;guardsize + pagesize_m1) &amp; ~pagesize_m1;\n  size += guardsize;\n  pd = get_cached_stack (&amp;size, &amp;mem);\n  if (pd == NULL)\n  {\n    /* If a guard page is required, avoid committing memory by first\n    allocate with PROT_NONE and then reserve with required permission\n    excluding the guard page.  */\n\tmem = __mmap (NULL, size, (guardsize == 0) ? prot : PROT_NONE,\n\t\t\tMAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0);\n    /* Place the thread descriptor at the end of the stack.  */\n#if TLS_TCB_AT_TP\n    pd = (struct pthread *) ((char *) mem + size) - 1;\n#elif TLS_DTV_AT_TP\n    pd = (struct pthread *) ((((uintptr_t) mem + size - __static_tls_size) &amp; ~__static_tls_align_m1) - TLS_PRE_TCB_SIZE);\n#endif\n    /* Now mprotect the required region excluding the guard area. */\n    char *guard = guard_position (mem, size, guardsize, pd, pagesize_m1);\n    setup_stack_prot (mem, size, guard, guardsize, prot);\n    pd-&gt;stackblock = mem;\n    pd-&gt;stackblock_size = size;\n    pd-&gt;guardsize = guardsize;\n    pd-&gt;specific[0] = pd-&gt;specific_1stblock;\n    /* And add to the list of stacks in use.  */\n    stack_list_add (&amp;pd-&gt;list, &amp;stack_used);\n  }\n  \n  *pdp = pd;\n  void *stacktop;\n# if TLS_TCB_AT_TP\n  /* The stack begins before the TCB and the static TLS block.  */\n  stacktop = ((char *) (pd + 1) - __static_tls_size);\n# elif TLS_DTV_AT_TP\n  stacktop = (char *) (pd - 1);\n# endif\n  *stack = stacktop;\n...... \n}\n</code></pre><p>我们来看一下，allocate_stack主要做了以下这些事情：</p><ul>\n<li>\n<p>如果你在线程属性里面设置过栈的大小，需要你把设置的值拿出来；</p>\n</li>\n<li>\n<p>为了防止栈的访问越界，在栈的末尾会有一块空间guardsize，一旦访问到这里就错误了；</p>\n</li>\n<li>\n<p>其实线程栈是在进程的堆里面创建的。如果一个进程不断地创建和删除线程，我们不可能不断地去申请和清除线程栈使用的内存块，这样就需要有一个缓存。get_cached_stack就是根据计算出来的size大小，看一看已经有的缓存中，有没有已经能够满足条件的；</p>\n</li>\n<li>\n<p>如果缓存里面没有，就需要调用__mmap创建一块新的，系统调用那一节我们讲过，如果要在堆里面malloc一块内存，比较大的话，用__mmap；</p>\n</li>\n<li>\n<p>线程栈也是自顶向下生长的，还记得每个线程要有一个pthread结构，这个结构也是放在栈的空间里面的。在栈底的位置，其实是地址最高位；</p>\n</li>\n<li>\n<p>计算出guard内存的位置，调用setup_stack_prot设置这块内存的是受保护的；</p>\n</li>\n<li>\n<p>接下来，开始填充pthread这个结构里面的成员变量stackblock、stackblock_size、guardsize、specific。这里的specific是用于存放Thread Specific Data的，也即属于线程的全局变量；</p>\n</li>\n<li>\n<p>将这个线程栈放到stack_used链表中，其实管理线程栈总共有两个链表，一个是stack_used，也就是这个栈正被使用；另一个是stack_cache，就是上面说的，一旦线程结束，先缓存起来，不释放，等有其他的线程创建的时候，给其他的线程用。</p>\n</li>\n</ul><p>搞定了用户态栈的问题，其实用户态的事情基本搞定了一半。</p><h2>内核态创建任务</h2><p>接下来，我们接着pthread_create看。其实有了用户态的栈，接着需要解决的就是用户态的程序从哪里开始运行的问题。</p><pre><code>pd-&gt;start_routine = start_routine;\npd-&gt;arg = arg;\npd-&gt;schedpolicy = self-&gt;schedpolicy;\npd-&gt;schedparam = self-&gt;schedparam;\n/* Pass the descriptor to the caller.  */\n*newthread = (pthread_t) pd;\natomic_increment (&amp;__nptl_nthreads);\nretval = create_thread (pd, iattr, &amp;stopped_start, STACK_VARIABLES_ARGS, &amp;thread_ran);\n</code></pre><p>start_routine就是咱们给线程的函数，start_routine，start_routine的参数arg，以及调度策略都要赋值给pthread。</p><p>接下来__nptl_nthreads加一，说明又多了一个线程。</p><p>真正创建线程的是调用create_thread函数，这个函数定义如下：</p><pre><code>static int\ncreate_thread (struct pthread *pd, const struct pthread_attr *attr,\nbool *stopped_start, STACK_VARIABLES_PARMS, bool *thread_ran)\n{\n  const int clone_flags = (CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SYSVSEM | CLONE_SIGHAND | CLONE_THREAD | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | 0);\n  ARCH_CLONE (&amp;start_thread, STACK_VARIABLES_ARGS, clone_flags, pd, &amp;pd-&gt;tid, tp, &amp;pd-&gt;tid)；\n  /* It's started now, so if we fail below, we'll have to cancel it\nand let it clean itself up.  */\n  *thread_ran = true;\n}\n</code></pre><p>这里面有很长的clone_flags，这些咱们原来一直没注意，不过接下来的过程，我们要特别的关注一下这些标志位。</p><p>然后就是ARCH_CLONE，其实调用的是__clone。看到这里，你应该就有感觉了，马上就要到系统调用了。</p><pre><code># define ARCH_CLONE __clone\n\n\n/* The userland implementation is:\n   int clone (int (*fn)(void *arg), void *child_stack, int flags, void *arg),\n   the kernel entry is:\n   int clone (long flags, void *child_stack).\n\n\n   The parameters are passed in register and on the stack from userland:\n   rdi: fn\n   rsi: child_stack\n   rdx: flags\n   rcx: arg\n   r8d: TID field in parent\n   r9d: thread pointer\n%esp+8: TID field in child\n\n\n   The kernel expects:\n   rax: system call number\n   rdi: flags\n   rsi: child_stack\n   rdx: TID field in parent\n   r10: TID field in child\n   r8:  thread pointer  */\n \n        .text\nENTRY (__clone)\n        movq    $-EINVAL,%rax\n......\n        /* Insert the argument onto the new stack.  */\n        subq    $16,%rsi\n        movq    %rcx,8(%rsi)\n\n\n        /* Save the function pointer.  It will be popped off in the\n           child in the ebx frobbing below.  */\n        movq    %rdi,0(%rsi)\n\n\n        /* Do the system call.  */\n        movq    %rdx, %rdi\n        movq    %r8, %rdx\n        movq    %r9, %r8\n        mov     8(%rsp), %R10_LP\n        movl    $SYS_ify(clone),%eax\n......\n        syscall\n......\nPSEUDO_END (__clone)\n</code></pre><p>如果对于汇编不太熟悉也没关系，你可以重点看上面的注释。</p><p>我们能看到最后调用了syscall，这一点clone和我们原来熟悉的其他系统调用几乎是一致的。但是，也有少许不一样的地方。</p><p>如果在进程的主线程里面调用其他系统调用，当前用户态的栈是指向整个进程的栈，栈顶指针也是指向进程的栈，指令指针也是指向进程的主线程的代码。此时此刻执行到这里，调用clone的时候，用户态的栈、栈顶指针、指令指针和其他系统调用一样，都是指向主线程的。</p><p>但是对于线程来说，这些都要变。因为我们希望当clone这个系统调用成功的时候，除了内核里面有这个线程对应的task_struct，当系统调用返回到用户态的时候，用户态的栈应该是线程的栈，栈顶指针应该指向线程的栈，指令指针应该指向线程将要执行的那个函数。</p><p>所以这些都需要我们自己做，将线程要执行的函数的参数和指令的位置都压到栈里面，当从内核返回，从栈里弹出来的时候，就从这个函数开始，带着这些参数执行下去。</p><p>接下来我们就要进入内核了。内核里面对于clone系统调用的定义是这样的：</p><pre><code>SYSCALL_DEFINE5(clone, unsigned long, clone_flags, unsigned long, newsp,\n\t\t int __user *, parent_tidptr,\n\t\t int __user *, child_tidptr,\n\t\t unsigned long, tls)\n{\n\treturn _do_fork(clone_flags, newsp, 0, parent_tidptr, child_tidptr, tls);\n}\n</code></pre><p>看到这里，发现了熟悉的面孔_do_fork，是不是轻松了一些？上一节我们已经沿着它的逻辑过了一遍了。这里我们重点关注几个区别。</p><p>第一个是上面<strong>复杂的标志位设定</strong>，我们来看都影响了什么。</p><p>对于copy_files，原来是调用dup_fd复制一个files_struct的，现在因为CLONE_FILES标识位变成将原来的files_struct引用计数加一。</p><pre><code>static int copy_files(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct files_struct *oldf, *newf;\n\toldf = current-&gt;files;\n\tif (clone_flags &amp; CLONE_FILES) {\n\t\tatomic_inc(&amp;oldf-&gt;count);\n\t\tgoto out;\n\t}\n\tnewf = dup_fd(oldf, &amp;error);\n\ttsk-&gt;files = newf;\nout:\n\treturn error;\n}\n</code></pre><p>对于copy_fs，原来是调用copy_fs_struct复制一个fs_struct，现在因为CLONE_FS标识位变成将原来的fs_struct的用户数加一。</p><pre><code>static int copy_fs(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct fs_struct *fs = current-&gt;fs;\n\tif (clone_flags &amp; CLONE_FS) {\n\t\tfs-&gt;users++;\n\t\treturn 0;\n\t}\n\ttsk-&gt;fs = copy_fs_struct(fs);\n\treturn 0;\n}\n</code></pre><p>对于copy_sighand，原来是创建一个新的sighand_struct，现在因为CLONE_SIGHAND标识位变成将原来的sighand_struct引用计数加一。</p><pre><code>static int copy_sighand(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct sighand_struct *sig;\n\n\n\tif (clone_flags &amp; CLONE_SIGHAND) {\n\t\tatomic_inc(&amp;current-&gt;sighand-&gt;count);\n\t\treturn 0;\n\t}\n\tsig = kmem_cache_alloc(sighand_cachep, GFP_KERNEL);\n\tatomic_set(&amp;sig-&gt;count, 1);\n\tmemcpy(sig-&gt;action, current-&gt;sighand-&gt;action, sizeof(sig-&gt;action));\n\treturn 0;\n}\n</code></pre><p>对于copy_signal，原来是创建一个新的signal_struct，现在因为CLONE_THREAD直接返回了。</p><pre><code>static int copy_signal(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct signal_struct *sig;\n\tif (clone_flags &amp; CLONE_THREAD)\n\t\treturn 0;\n\tsig = kmem_cache_zalloc(signal_cachep, GFP_KERNEL);\n\ttsk-&gt;signal = sig;\n    init_sigpending(&amp;sig-&gt;shared_pending);\n......\n}\n</code></pre><p>对于copy_mm，原来是调用dup_mm复制一个mm_struct，现在因为CLONE_VM标识位而直接指向了原来的mm_struct。</p><pre><code>static int copy_mm(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct mm_struct *mm, *oldmm;\n\toldmm = current-&gt;mm;\n\tif (clone_flags &amp; CLONE_VM) {\n\t\tmmget(oldmm);\n\t\tmm = oldmm;\n\t\tgoto good_mm;\n\t}\n\tmm = dup_mm(tsk);\ngood_mm:\n\ttsk-&gt;mm = mm;\n\ttsk-&gt;active_mm = mm;\n\treturn 0;\n}\n</code></pre><p>第二个就是<strong>对于亲缘关系的影响</strong>，毕竟我们要识别多个线程是不是属于一个进程。</p><pre><code>p-&gt;pid = pid_nr(pid);\nif (clone_flags &amp; CLONE_THREAD) {\n\tp-&gt;exit_signal = -1;\n\tp-&gt;group_leader = current-&gt;group_leader;\n\tp-&gt;tgid = current-&gt;tgid;\n} else {\n\tif (clone_flags &amp; CLONE_PARENT)\n\t\tp-&gt;exit_signal = current-&gt;group_leader-&gt;exit_signal;\n\telse\n\t\tp-&gt;exit_signal = (clone_flags &amp; CSIGNAL);\n\tp-&gt;group_leader = p;\n\tp-&gt;tgid = p-&gt;pid;\n}\n\t/* CLONE_PARENT re-uses the old parent */\nif (clone_flags &amp; (CLONE_PARENT|CLONE_THREAD)) {\n\tp-&gt;real_parent = current-&gt;real_parent;\n\tp-&gt;parent_exec_id = current-&gt;parent_exec_id;\n} else {\n\tp-&gt;real_parent = current;\n\tp-&gt;parent_exec_id = current-&gt;self_exec_id;\n}\n</code></pre><p>从上面的代码可以看出，使用了CLONE_THREAD标识位之后，使得亲缘关系有了一定的变化。</p><ul>\n<li>\n<p>如果是新进程，那这个进程的group_leader就是它自己，tgid是它自己的pid，这就完全重打锣鼓另开张了，自己是线程组的头。如果是新线程，group_leader是当前进程的，group_leader，tgid是当前进程的tgid，也就是当前进程的pid，这个时候还是拜原来进程为老大。</p>\n</li>\n<li>\n<p>如果是新进程，新进程的real_parent是当前的进程，在进程树里面又见一辈人；如果是新线程，线程的real_parent是当前的进程的real_parent，其实是平辈的。</p>\n</li>\n</ul><p>第三，<strong>对于信号的处理</strong>，如何保证发给进程的信号虽然可以被一个线程处理，但是影响范围应该是整个进程的。例如，kill一个进程，则所有线程都要被干掉。如果一个信号是发给一个线程的pthread_kill，则应该只有线程能够收到。</p><p>在copy_process的主流程里面，无论是创建进程还是线程，都会初始化struct sigpending pending，也就是每个task_struct，都会有这样一个成员变量。这就是一个信号列表。如果这个task_struct是一个线程，这里面的信号就是发给这个线程的；如果这个task_struct是一个进程，这里面的信号是发给主线程的。</p><pre><code>init_sigpending(&amp;p-&gt;pending);\n</code></pre><p>另外，上面copy_signal的时候，我们可以看到，在创建进程的过程中，会初始化signal_struct里面的struct sigpending shared_pending。但是，在创建线程的过程中，连signal_struct都共享了。也就是说，整个进程里的所有线程共享一个shared_pending，这也是一个信号列表，是发给整个进程的，哪个线程处理都一样。</p><pre><code>init_sigpending(&amp;sig-&gt;shared_pending);\n</code></pre><p>至此，clone在内核的调用完毕，要返回系统调用，回到用户态。</p><h2>用户态执行线程</h2><p>根据__clone的第一个参数，回到用户态也不是直接运行我们指定的那个函数，而是一个通用的start_thread，这是所有线程在用户态的统一入口。</p><pre><code>#define START_THREAD_DEFN \\\n  static int __attribute__ ((noreturn)) start_thread (void *arg)\n\n\nSTART_THREAD_DEFN\n{\n    struct pthread *pd = START_THREAD_SELF;\n    /* Run the code the user provided.  */\n    THREAD_SETMEM (pd, result, pd-&gt;start_routine (pd-&gt;arg));\n    /* Call destructors for the thread_local TLS variables.  */\n    /* Run the destructor for the thread-local data.  */\n    __nptl_deallocate_tsd ();\n    if (__glibc_unlikely (atomic_decrement_and_test (&amp;__nptl_nthreads)))\n        /* This was the last thread.  */\n        exit (0);\n    __free_tcb (pd);\n    __exit_thread ();\n}\n</code></pre><p>在start_thread入口函数中，才真正的调用用户提供的函数，在用户的函数执行完毕之后，会释放这个线程相关的数据。例如，线程本地数据thread_local variables，线程数目也减一。如果这是最后一个线程了，就直接退出进程，另外__free_tcb用于释放pthread。</p><pre><code>void\ninternal_function\n__free_tcb (struct pthread *pd)\n{\n  ......\n  __deallocate_stack (pd);\n}\n\n\nvoid\ninternal_function\n__deallocate_stack (struct pthread *pd)\n{\n  /* Remove the thread from the list of threads with user defined\n     stacks.  */\n  stack_list_del (&amp;pd-&gt;list);\n  /* Not much to do.  Just free the mmap()ed memory.  Note that we do\n     not reset the 'used' flag in the 'tid' field.  This is done by\n     the kernel.  If no thread has been created yet this field is\n     still zero.  */\n  if (__glibc_likely (! pd-&gt;user_stack))\n    (void) queue_stack (pd);\n}\n</code></pre><p>__free_tcb会调用__deallocate_stack来释放整个线程栈，这个线程栈要从当前使用线程栈的列表stack_used中拿下来，放到缓存的线程栈列表stack_cache中。</p><p>好了，整个线程的生命周期到这里就结束了。</p><h2>总结时刻</h2><p>线程的调用过程解析完毕了，我画了一个图总结一下。这个图对比了创建进程和创建线程在用户态和内核态的不同。</p><p>创建进程的话，调用的系统调用是fork，在copy_process函数里面，会将五大结构files_struct、fs_struct、sighand_struct、signal_struct、mm_struct都复制一遍，从此父进程和子进程各用各的数据结构。而创建线程的话，调用的是系统调用clone，在copy_process函数里面， 五大结构仅仅是引用计数加一，也即线程共享进程的数据结构。</p><p><img src=\"https://static001.geekbang.org/resource/image/14/4b/14635b1613d04df9f217c3508ae8524b.jpeg?wh=3134*3212\" alt=\"\"></p><h2>课堂练习</h2><p>你知道如果查看一个进程的线程以及线程栈的使用情况吗？请找一下相关的命令和API，尝试一下。</p><p>欢迎留言和我分享你的疑惑和见解，也欢迎你收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习、进步。</p><p><img src=\"https://static001.geekbang.org/resource/image/8c/37/8c0a95fa07a8b9a1abfd394479bdd637.jpg?wh=1110*659\" alt=\"\"></p>","neighbors":{"left":{"article_title":"18 | 进程的创建：如何发起一个新项目？","id":94064},"right":{"article_title":"20 | 内存管理（上）：为客户保密，规划进程内存空间布局","id":94926}},"comments":[{"had_liked":false,"id":93351,"user_name":"Milittle","can_delete":false,"product_type":"c1","uid":1045455,"ip_address":"","ucode":"80E566639A8ABB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f3/cf/851dab01.jpg","comment_is_top":false,"comment_ctime":1557455278,"is_pvip":true,"discussion_count":5,"race_medal":0,"score":"186241049006","product_id":100024701,"comment_content":"刘老师，您好，您可以把文档中给出的代码文件定位给出来么，一般在对应看源码的时候，很难定位到老师给的代码点的对应源码文件，谢谢老师~老师讲的真的让我把多年的零散知识可以连贯起来，然后理解的更加透彻，但是也会有不太理解的地方，再次感谢。这个课很值得~。<br>总结以下进程和线程的异同点：<br>1. 进程有独立的内存空间，比如代码段，数据段。线程则是共享进程的内存空间。<br>2. 在创建新进程的时候，会将父进程的所有五大数据结构复制新的，形成自己新的内存空间数据，而在创建新线程的时候，则是引用进程的五大数据结构数据，但是线程会有自己的私有（局部）数据，执行栈空间。<br>3. 进程和线程其实在cpu看来都是task_struct结构的一个封装，执行不同task即可，而且在cpu看来就是在执行这些task时候遵循对应的调度策略以及上下文资源切换定义，包括寄存器地址切换，内核栈切换，指令指针寄存器的地址切换。所以对于cpu而言，进程和线程是没有区别的。<br>4. 进程创建的时候直接使用系统调用fork，进行系统调用的链路走，从而进入到_do_fork去创建task，而线程创建在调用_do_fork之前，还需要维护pthread这个数据结构的信息，初始化用户态栈信息。<br>自己就能意识到这几点，如果有理解不到位，或者不全面的地方，还请老师给予指点，谢谢老师。","like_count":44,"discussions":[{"author":{"id":2257606,"avatar":"https://static001.geekbang.org/account/avatar/00/22/72/c6/b1333e52.jpg","nickname":"开发内功修炼","note":"","ucode":"B3490A597BED1F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586728,"discussion_content":"创建进程线程的主要代码都在 kernel/fork.c 这个文件中呢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1662463181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2647122,"avatar":"https://static001.geekbang.org/account/avatar/00/28/64/52/e4536e9c.jpg","nickname":"涛子","note":"","ucode":"8B9830B2B3C6FD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582138,"discussion_content":"老师能不能提供一些参考资料，线程创建这块有不理解的百度也基本搜不出来太多相关，吃力","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1659255572,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江"},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1336951,"avatar":"https://static001.geekbang.org/account/avatar/00/14/66/77/194ba21d.jpg","nickname":"lzh","note":"","ucode":"C3D83DF4230109","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2647122,"avatar":"https://static001.geekbang.org/account/avatar/00/28/64/52/e4536e9c.jpg","nickname":"涛子","note":"","ucode":"8B9830B2B3C6FD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589553,"discussion_content":"我一般都是用科学上网搜，百度只能搜出来培训班广告","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665113080,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":582138,"ip_address":"广东"},"score":589553,"extra":""}]},{"author":{"id":1256821,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2d/75/e7c29de4.jpg","nickname":"wkq2786130","note":"","ucode":"0F3A9DF9928C67","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591324,"discussion_content":"代码链接 https://github.com/torvalds/linux/blob/v6.0/kernel/fork.c \n代码比较新，和老师的有些不一样，可以把linux代码的tag选成5.0 4.0就和老师的代码一样了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666501705,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1131300,"avatar":"https://static001.geekbang.org/account/avatar/00/11/43/24/3f9f7c70.jpg","nickname":"zixuan","note":"","ucode":"C72920DD05B074","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588111,"discussion_content":"可以再补充下创建完线程后是如何&#34;返回&#34;到线程的用户代码里执行的，线程创建者又是如何返回继续执行的.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663557514,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94480,"user_name":"why","can_delete":false,"product_type":"c1","uid":1012937,"ip_address":"","ucode":"C9E796E53F6F5E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/74/c9/d3439ca4.jpg","comment_is_top":false,"comment_ctime":1557821593,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"113226971289","product_id":100024701,"comment_content":"- 线程的创建<br>- 线程是由内核态和用户态合作完成的, pthread_create 是 Glibc 库的一个函数<br>- pthread_create 中<br>1. 设置线程属性参数, 如线程栈大小<br>2. 创建用户态维护线程的结构, pthread<br>3. 创建线程栈 allocate_stack<br>    - 取栈的大小, 在栈末尾加 guardsize<br>    - 在进程堆中创建线程栈(先尝试调用 get_cached_stack 从缓存回收的线程栈中取用)<br>    - 若无缓存线程栈, 调用 `__mmap` 创建<br>    - 将 pthread 指向栈空间中<br>    - 计算 guard 内存位置, 并设置保护<br>    - 填充 pthread 内容, 其中 specific 存放属于线程的全局变量<br>    - 线程栈放入 stack_used 链表中(另外 stack_cache 链表记录回收缓存的线程栈)<br>4. 设置运行函数, 参数到 pthread 中<br>5. 调用 create_thread 创建线程<br>    - 设置 clone_flags 标志位, 调用 `__clone`<br>    - clone 系统调用返回时, 应该要返回到新线程上下文中, 因此 `__clone` 将参数和指令位置压入栈中, 返回时从该函数开始执行<br>6. 内核调用 `__do_fork` <br>    - 在 copy_process 复制 task_struct 过程中, 五大数据结构不复制, 直接引用进程的<br>    - 亲缘关系设置: group_leader 和 tgid 是当前进程; real_parent 与当前进程一样<br>    - 信号处理: 数据结构共享, 处理一样<br>7. 返回用户态, 先运行 start_thread 同样函数<br>    - 在 start_thread 中调用用户的函数, 运行完释放相关数据<br>    - 如果是最后一个线程直接退出<br>    - 或调用 `__free_tcb` 释放 pthread 以及线程栈, 从 stack_used 移到 stack_cache 中","like_count":27,"discussions":[{"author":{"id":2028811,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f5/0b/73628618.jpg","nickname":"兔嘟嘟","note":"","ucode":"5A9042B4C7670C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390410,"discussion_content":"换了个人可还行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629817922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1440772,"avatar":"https://static001.geekbang.org/account/avatar/00/15/fc/04/d83a555e.jpg","nickname":"Kevin⚡️Zhou","note":"","ucode":"C0FC2673705212","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":25356,"discussion_content":"请问是哪五大数据结构啊\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570509352,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2350246,"avatar":"https://static001.geekbang.org/account/avatar/00/23/dc/a6/6c2728b9.jpg","nickname":"乔克叔叔","note":"","ucode":"31F524DC1E1498","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1440772,"avatar":"https://static001.geekbang.org/account/avatar/00/15/fc/04/d83a555e.jpg","nickname":"Kevin⚡️Zhou","note":"","ucode":"C0FC2673705212","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572469,"discussion_content":"redis五大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652798429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":25356,"ip_address":""},"score":572469,"extra":""}]}]},{"had_liked":false,"id":119489,"user_name":"jacy","can_delete":false,"product_type":"c1","uid":1103456,"ip_address":"","ucode":"0022A8759DDCE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/60/f21b2164.jpg","comment_is_top":false,"comment_ctime":1564618895,"is_pvip":false,"replies":[{"id":"46381","content":"赞","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1566297817,"ip_address":"","comment_id":119489,"utype":1}],"discussion_count":1,"race_medal":1,"score":"108938801295","product_id":100024701,"comment_content":"pstree -apl pid看进程树<br>pstack pid 看栈","like_count":26,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460925,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566297817,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94482,"user_name":"why","can_delete":false,"product_type":"c1","uid":1012937,"ip_address":"","ucode":"C9E796E53F6F5E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/74/c9/d3439ca4.jpg","comment_is_top":false,"comment_ctime":1557822038,"is_pvip":false,"replies":[{"id":"33887","content":"不共享，进了内核都是单独的任务了","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1557899627,"ip_address":"","comment_id":94482,"utype":1}],"discussion_count":2,"race_medal":0,"score":"61687364182","product_id":100024701,"comment_content":"老师, 多线程的内核栈是共享的吗, 会不会出现问题?","like_count":15,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450077,"discussion_content":"不共享，进了内核都是单独的任务了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557899627,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2458966,"avatar":"https://static001.geekbang.org/account/avatar/00/25/85/56/6fe64e92.jpg","nickname":"明天","note":"","ucode":"3E8070C4C8FCD0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365094,"discussion_content":"可不可以理解线程是内核任务管理的单位，0到4G的管理空间也是针对线程而言","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617708337,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99299,"user_name":"humor","can_delete":false,"product_type":"c1","uid":1181867,"ip_address":"","ucode":"9B48C4C7BEC92C","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/ab/caec7bca.jpg","comment_is_top":false,"comment_ctime":1559187845,"is_pvip":false,"replies":[{"id":"49233","content":"不会，这个进程的task_struct就代表这个线程","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567604927,"ip_address":"","comment_id":99299,"utype":1}],"discussion_count":2,"race_medal":0,"score":"35918926213","product_id":100024701,"comment_content":"老师之前说过进程默认会有一个主线程，意思是在创建进程的时候也会同时创建一个线程吗？","like_count":9,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452053,"discussion_content":"不会，这个进程的task_struct就代表这个线程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567604927,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135151,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/vTku9cFYPh2T8DSImQoPRLxgSibcVgCRYqMcEYibexxLkfn9IKhUSAasZ7QoB72SDWym31niah2y00ibRWdHibibib1wQ/132","nickname":"Regina","note":"","ucode":"2256559FB9A8D7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6562,"discussion_content":"我也想问这个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566973999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93300,"user_name":"徐凯","can_delete":false,"product_type":"c1","uid":1244991,"ip_address":"","ucode":"12F82BA3649CD5","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/3f/bbb8a88c.jpg","comment_is_top":false,"comment_ctime":1557451023,"is_pvip":false,"replies":[{"id":"49400","content":"内核没有线程池的概念，把线程弄一个池子，是业务层做的。这里只是内核栈的复用。","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567656216,"ip_address":"","comment_id":93300,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27327254799","product_id":100024701,"comment_content":"&quot;将这个线程栈放到 stack_used 链表中，其实管理线程栈总共有两个链表，一个是 stack_used，也就是这个栈正被使用；另一个是 stack_cache，就是上面说的，一旦线程结束，先缓存起来，不释放，等有其他的线程创建的时候，给其他的线程用。&quot;  这一段是线程池的意思么 如果是的话  既然内部已经有这个设计 我们有时候还要在程序中自己去设计一个呢？","like_count":6,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449570,"discussion_content":"内核没有线程池的概念，把线程弄一个池子，是业务层做的。这里只是内核栈的复用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567656216,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":226560,"user_name":"蹦哒","can_delete":false,"product_type":"c1","uid":1458931,"ip_address":"","ucode":"56591A657DE7C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epcs6PibsP9vEXv4EibUw3bhQPUK04zRTOvfrvF08TwM67xPb1LBh2uRENHQwo2VqYfC5GhJmM7icxHA/132","comment_is_top":false,"comment_ctime":1592141366,"is_pvip":false,"replies":[{"id":"83452","content":"是的","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1592185734,"ip_address":"","comment_id":226560,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18772010550","product_id":100024701,"comment_content":"老师、同学们，不知道如下认识是否正确呢：<br>1.原来线程存在的价值是复用进程的部分内存（引用五大结构），又是一个享元模式（Flyweight Design Pattern）的体现<br>2.线程函数局部变量在用户态的线程栈中（是在进程的堆里面创建的），独立的内存块，所以多线程之间无需考虑共享数据问题；而进程的全局变量，由于多线程是共享了进程数据，再加上各个线程在内核中是独立的task被调度系统调度，随时会被抢占并且访问同一个全局变量，所以多线程之间需要做共享数据保护","like_count":5,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498285,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592185734,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160494,"user_name":"neohope","can_delete":false,"product_type":"c1","uid":1043475,"ip_address":"","ucode":"C0268F6E7E2B6E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","comment_is_top":false,"comment_ctime":1575963895,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18755833079","product_id":100024701,"comment_content":"关于clone_flags标志位的含义，可以参考一下这里http:&#47;&#47;man7.org&#47;linux&#47;man-pages&#47;man2&#47;clone.2.html<br><br>If CLONE_THREAD is set, the child is placed in the same thread group as the calling process.<br>When a clone call is made without specifying CLONE_THREAD, then the resulting thread is placed in a new thread group whose TGID is the same as the thread&#39;s TID.  This thread is the leader of the new thread group.<br><br>If CLONE_PARENT is set, then the parent of the new child (as returned by getppid(2)) will be the same as that of the calling process.<br>If CLONE_PARENT is not set, then (as with fork(2)) the child&#39;s parent is the calling process.","like_count":4},{"had_liked":false,"id":193345,"user_name":"Geek_b8928e","can_delete":false,"product_type":"c1","uid":1926597,"ip_address":"","ucode":"96E4ABE3F2F145","user_header":"","comment_is_top":false,"comment_ctime":1584890610,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14469792498","product_id":100024701,"comment_content":"创建进程的话，调用的系统调用是 fork，在 copy_process 函数里面，会将五大结构 files_struct、fs_struct、sighand_struct、signal_struct、mm_struct 都复制一遍，从此父进程和子进程各用各的数据结构。而创建线程的话，调用的是系统调用 clone，在 copy_process 函数里面， 五大结构仅仅是引用计数加一，也即线程共享进程的数据结构。","like_count":3},{"had_liked":false,"id":140279,"user_name":"garlic","can_delete":false,"product_type":"c1","uid":1019579,"ip_address":"","ucode":"FEB147EDB5774E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/bb/c039dc11.jpg","comment_is_top":false,"comment_ctime":1570869621,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"14455771509","product_id":100024701,"comment_content":"进程线程查看命令：ps，top，pidstat，pstree<br>函数栈查看打印命令：<br> pstack<br>jstack (java)<br>gdb (C&#47;C++&#47;go)<br>kill -SIGQUIT [pid] (go)<br><br>相关API:<br><br>C:<br>glibc backtrace<br>Boost stacktrace<br>libunwind<br><br>Java:<br>getStackTrace;<br><br>go:<br>panic<br>debug.PrintStack<br>pprof.Lookup(&quot;goroutine&quot;).WriteTo<br>runtime.Stack<br><br>python<br>traceback objects<br>StackSummary Objects<br> 笔记链接 https:&#47;&#47;garlicspace.com&#47;?p=1678&amp;preview=true<br>","like_count":3},{"had_liked":false,"id":308053,"user_name":"兔嘟嘟","can_delete":false,"product_type":"c1","uid":2028811,"ip_address":"","ucode":"5A9042B4C7670C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f5/0b/73628618.jpg","comment_is_top":false,"comment_ctime":1629369281,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10219303873","product_id":100024701,"comment_content":"老师您好，我想请问一下可以这样理解主线程和进程的关系吗：<br>主线程和进程是绑定的，在内核体现为一个task，在用户态则是进程的运行主线，所以其实没有独立的主线程的概念。<br>主线程的线程栈就是进程栈，主线程没有pthread，所有的属性都是进程的属性。<br>因为主线程其实不是独立的，所以主线程结束时，也就是进程结束时。","like_count":2},{"had_liked":false,"id":241913,"user_name":"相逢是缘","can_delete":false,"product_type":"c1","uid":1060730,"ip_address":"","ucode":"CB299F53A95654","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg","comment_is_top":false,"comment_ctime":1597497885,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10187432477","product_id":100024701,"comment_content":"1、pthread_create 不是一个系统调用，是 Glibc 库的一个函数<br>2、在内核里一样，每一个进程或者线程都有一个 task_struct 结构，线程在用户态也有一个用于维护线程的结构，就是这个 pthread 结构<br>3、创建线程栈<br>----用户态int err = ALLOCATE_STACK (iattr, &amp;pd);<br>---程属性里面设置过栈的大小，需要你把设置的值拿出来<br>---为了防止栈的访问越界，在栈的末尾会有一块空间 guardsize<br>---其实线程栈是在进程的堆里面创建的get_cached_stack <br>---如果缓存里面没有，就需要调用 __mmap 创建一块新的<br>---线程栈也是自顶向下生长的，还记得每个线程要有一个 pthread 结构，这个结构也是放在栈的空间里面的。在栈底的位置，其实是地址最高位。<br>---计算出 guard 内存的位置，调用 setup_stack_prot 设置这块内存的是受保护的<br>---开始填充 pthread 这个结构里面的成员变量 stackblock、stackblock_size、guardsize、specific。<br>---将这个线程栈放到 stack_used 链表中，使用完之后放到stack_cache中<br>---其实有了用户态的栈，接着需要解决的就是用户态的程序从哪里开始运行的问题<br>pd-&gt;start_routine = start_routine;<br>pd-&gt;arg = arg;<br>pd-&gt;schedpolicy = self-&gt;schedpolicy;<br>pd-&gt;schedparam = self-&gt;schedparam;<br>&#47;* Pass the descriptor to the caller.  *&#47;<br>*newthread = (pthread_t) pd;<br>atomic_increment (&amp;__nptl_nthreads);<br>retval = create_thread (pd, iattr, &amp;stopped_start, STACK_VARIABLES_ARGS, &amp;thread_ran);<br>start_routine 就是咱们给线程的函数，start_routine，start_routine 的参数 arg，以及调度策略都要赋值给 pthread<br><br>----内核态<br>--系统调用__clone<br>将线程要执行的函数的参数和指令的位置都压到栈里面，当从内核返回，从栈里弹出来的时候，就从这个函数开始<br>--在 copy_process 复制 task_struct 过程中, files、fs、sighand、mm、五大数据结构不复制, 直接引用进程的<br>--亲缘关系：新进程group_leader就是自己，tgid就是他的pid，real_parent 是当前的进程。新线程group_leader是当前进程的，tgid是当前进程的tgid，real_parent 是当前集成的real_parent；<br>--信号处理：共享信号<br><br>4、用户态执行线程<br>--所有的线程统一的入口start_thread<br>--用户的函数执行完毕之后，会释放这个线程相关的数据<br>a、线程数目也减一，如果这是最后一个线程了，就直接退出进程<br>b、_free_tcb 用于释放 pthread，__free_tcb 会调用 __deallocate_stack 来释放整个线程栈，放到缓存的线程栈列表 stack_cache 中；","like_count":2},{"had_liked":false,"id":137164,"user_name":"kdb_reboot","can_delete":false,"product_type":"c1","uid":1003594,"ip_address":"","ucode":"4C56FCA563FCA3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/50/4a/04fef27f.jpg","comment_is_top":false,"comment_ctime":1569638233,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10159572825","product_id":100024701,"comment_content":"三刷: 感觉应该讲清楚这一点,&quot;角色划分&quot;<br>内核态是用来管理的,用户态是提供给用户用的<br>这才有了为什么要两个模式来回切换, 以及,真正调度,是内核态来做的,而用户态执行是用户态自己做,这才有了单独的线程栈<br>内存模型也很重要<br><br>另外想请教个问题:从上下文来理解, 所以说,主线程的栈是用整个用户空间的栈?子线程的栈在进程的堆里面?","like_count":2},{"had_liked":false,"id":93206,"user_name":"lfn","can_delete":false,"product_type":"c1","uid":1026593,"ip_address":"","ucode":"2E1558C6A12A89","user_header":"https://static001.geekbang.org/account/avatar/00/0f/aa/21/6c3ba9af.jpg","comment_is_top":false,"comment_ctime":1557422110,"is_pvip":false,"replies":[{"id":"49403","content":"是的","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567656554,"ip_address":"","comment_id":93206,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10147356702","product_id":100024701,"comment_content":"所以，线程局部变量其实是存储在每个线程自己的用户栈里咯？","like_count":2,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449526,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567656554,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":335543,"user_name":"Geek_4c6cb8","can_delete":false,"product_type":"c1","uid":1666952,"ip_address":"","ucode":"4EF13DAF850937","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/LBOHwXq4wliccC1HUPEghTOkWsnVR5zOmSQsias4O6obKJb2tOEpqoiaPE9mGibTlrrnGeMC5m4fp1fY234k4p9PgA/132","comment_is_top":false,"comment_ctime":1645580923,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"5940548219","product_id":100024701,"comment_content":"老师您好，同一个进程的不同线程，内核栈都是相同的吗","like_count":1,"discussions":[{"author":{"id":1336951,"avatar":"https://static001.geekbang.org/account/avatar/00/14/66/77/194ba21d.jpg","nickname":"lzh","note":"","ucode":"C3D83DF4230109","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589554,"discussion_content":"应该不一样，拿进程的主线程来说，主线程的内核栈保存的是主线程那一堆函数调用链，子线程那堆函数调用链和主线程不一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665113404,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134213,"user_name":"空格","can_delete":false,"product_type":"c1","uid":1299182,"ip_address":"","ucode":"D8ABDE722821F0","user_header":"https://static001.geekbang.org/account/avatar/00/13/d2/ee/1ec46e78.jpg","comment_is_top":false,"comment_ctime":1568776264,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5863743560","product_id":100024701,"comment_content":"不知道我的理解对不对？线程fork后内核态会创建task_struct，之后还是会尝试wakeup_preempt_entity，然后之后接受调度，调度成功后才会在用户态执行start_thread方法？不知道我这个理解对不对？","like_count":1},{"had_liked":false,"id":95700,"user_name":"nora","can_delete":false,"product_type":"c1","uid":1206539,"ip_address":"","ucode":"3A3EABF27D0261","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/0b/780b0aac.jpg","comment_is_top":false,"comment_ctime":1558145616,"is_pvip":false,"replies":[{"id":"49305","content":"赞，加油","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567610919,"ip_address":"","comment_id":95700,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5853112912","product_id":100024701,"comment_content":"之前总是认为线程和进程都占用了内核的taskstruct 认为实际上线程进程没啥区别，这篇文章真是醍醐灌顶啊，谢谢老师。","like_count":1,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450562,"discussion_content":"赞，加油","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567610919,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":350104,"user_name":"浅陌","can_delete":false,"product_type":"c1","uid":2031603,"ip_address":"","ucode":"1C80224154E747","user_header":"https://static001.geekbang.org/account/avatar/00/1e/ff/f3/de2233f5.jpg","comment_is_top":false,"comment_ctime":1656574092,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1656574092","product_id":100024701,"comment_content":"请问这个线程是内核态还是用户态的呀，用户态线程与内核态线程多对多是怎么实现的呀","like_count":0},{"had_liked":false,"id":348877,"user_name":"小鳄鱼","can_delete":false,"product_type":"c1","uid":1178888,"ip_address":"","ucode":"9C30CAFB41A263","user_header":"https://static001.geekbang.org/account/avatar/00/11/fd/08/c039f840.jpg","comment_is_top":false,"comment_ctime":1655480406,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655480406","product_id":100024701,"comment_content":"老师，可否讲一下线程模型？还有LWP是如何支持用户线程","like_count":0},{"had_liked":false,"id":344362,"user_name":"Samaritan.","can_delete":false,"product_type":"c1","uid":2523660,"ip_address":"","ucode":"A3730B90313C26","user_header":"https://static001.geekbang.org/account/avatar/00/26/82/0c/cc106ab1.jpg","comment_is_top":false,"comment_ctime":1651490757,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651490757","product_id":100024701,"comment_content":"老师每一讲的图真的是太用心了，以前有很多模糊的地方，看着图非常容易理解","like_count":0},{"had_liked":false,"id":329546,"user_name":"四有青年","can_delete":false,"product_type":"c1","uid":2004350,"ip_address":"","ucode":"121A7C613E6C32","user_header":"https://static001.geekbang.org/account/avatar/00/1e/95/7e/1057f77a.jpg","comment_is_top":false,"comment_ctime":1641394527,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641394527","product_id":100024701,"comment_content":"这篇文章就很好解释了进程和线程区别这一常见面试题了。以前只是背答案，知其然而不知其所以然，现在就串联起来了～","like_count":0},{"had_liked":false,"id":200730,"user_name":"honnkyou","can_delete":false,"product_type":"c1","uid":1026608,"ip_address":"","ucode":"FD5EC4120EE803","user_header":"https://static001.geekbang.org/account/avatar/00/0f/aa/30/acc91f01.jpg","comment_is_top":false,"comment_ctime":1585644079,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1585644079","product_id":100024701,"comment_content":"在 start_thread 入口函数中，才真正的调用用户提供的函数，<br>是指pd-&gt;start_routine吗？","like_count":0,"discussions":[{"author":{"id":1066409,"avatar":"https://static001.geekbang.org/account/avatar/00/10/45/a9/3d48d6a2.jpg","nickname":"Lorry","note":"","ucode":"BD4754D0F1D786","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388293,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628684752,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184789,"user_name":"小橙子","can_delete":false,"product_type":"c1","uid":1244724,"ip_address":"","ucode":"7E3DD87C3DE6F9","user_header":"https://static001.geekbang.org/account/avatar/00/12/fe/34/67c1ed1e.jpg","comment_is_top":false,"comment_ctime":1583404074,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583404074","product_id":100024701,"comment_content":"在 copy_process 的主流程里面，无论是创建进程还是线程，都会初始化 struct sigpending pending，也就是每个 task_struct，都会有这样一个成员变量。<br><br>但是文中给的实例 创建线程因为有clone_thread 这个flag，就直接返回了，并没有调用nit_sigpending(&amp;p-&gt;pending);","like_count":0},{"had_liked":false,"id":171480,"user_name":"周佳","can_delete":false,"product_type":"c1","uid":1245735,"ip_address":"","ucode":"BBD2D15E37FF6E","user_header":"https://static001.geekbang.org/account/avatar/00/13/02/27/226f3c4a.jpg","comment_is_top":false,"comment_ctime":1578928773,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578928773","product_id":100024701,"comment_content":"老师好，这里线程创建后的调度是否是和进程创建后的调度一样的逻辑呢？","like_count":0},{"had_liked":false,"id":127884,"user_name":"tuyu","can_delete":false,"product_type":"c1","uid":1448863,"ip_address":"","ucode":"B235325B541408","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/BIRpwViaN51yynIeFonD7QRlwDCVtKibrG956NTxzEqibOZZVjhMMgibOPmd3VicfYxpknZsic1oJq8KicZvXkmmiajuQg/132","comment_is_top":false,"comment_ctime":1566804356,"is_pvip":false,"replies":[{"id":"48772","content":"在容器那一节会讲的，clone有个特殊的参数操作namespace。其实clone和fork底层调用的是差不多的","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567495603,"ip_address":"","comment_id":127884,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566804356","product_id":100024701,"comment_content":"老师, 我最近在看k8s专栏, docker的原理是使用clone的namespace参数, 所以容器的创建, 实际上是线程的创建吗","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464692,"discussion_content":"在容器那一节会讲的，clone有个特殊的参数操作namespace。其实clone和fork底层调用的是差不多的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567495603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126537,"user_name":"kdb_reboot","can_delete":false,"product_type":"c1","uid":1003594,"ip_address":"","ucode":"4C56FCA563FCA3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/50/4a/04fef27f.jpg","comment_is_top":false,"comment_ctime":1566402796,"is_pvip":false,"replies":[{"id":"48794","content":"会关注这个专栏的","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567497360,"ip_address":"","comment_id":126537,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566402796","product_id":100024701,"comment_content":"老师你终于出现了；还是之前那个问题，我现在进度比较慢，只把进程管理子系统看完了，看了一个多月，看了鸟哥私房菜 apue ulk lkd 内核代码 libc 还有你的专栏。因为进度太慢了 我的问题是后面老师还会关注这个专栏吗，或者有什么方法可以一起讨论或者联系到老师？ 比如微信群或者邮箱？我做驱动开发，我感觉你的专栏完全就是为我而写的；）","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464041,"discussion_content":"会关注这个专栏的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567497360,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118667,"user_name":"kdb_reboot","can_delete":false,"product_type":"c1","uid":1003594,"ip_address":"","ucode":"4C56FCA563FCA3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/50/4a/04fef27f.jpg","comment_is_top":false,"comment_ctime":1564410191,"is_pvip":false,"replies":[{"id":"46393","content":"跟着系统调用，比较容易理解","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1566298207,"ip_address":"","comment_id":118667,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1564410191","product_id":100024701,"comment_content":"跟到这一篇了,前面几篇概念感觉都是为最后这两篇作铺垫","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460515,"discussion_content":"跟着系统调用，比较容易理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566298207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":111655,"user_name":"windcaller","can_delete":false,"product_type":"c1","uid":1514157,"ip_address":"","ucode":"1CA3E849805770","user_header":"https://static001.geekbang.org/account/avatar/00/17/1a/ad/faf1bf19.jpg","comment_is_top":false,"comment_ctime":1562578509,"is_pvip":false,"replies":[{"id":"46736","content":"赞","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1566387425,"ip_address":"","comment_id":111655,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562578509","product_id":100024701,"comment_content":"pstack<br>ulimit -a","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457404,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566387425,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105087,"user_name":"youyui","can_delete":false,"product_type":"c1","uid":1501890,"ip_address":"","ucode":"4CBD130E31CAEA","user_header":"https://static001.geekbang.org/account/avatar/00/16/ea/c2/445977ea.jpg","comment_is_top":false,"comment_ctime":1560913780,"is_pvip":false,"replies":[{"id":"49016","content":"fork的时候","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567579775,"ip_address":"","comment_id":105087,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560913780","product_id":100024701,"comment_content":"线程要进行上下文切换应该有各自的内核栈吧，那内核栈在哪里创建的？","like_count":1,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454557,"discussion_content":"fork的时候","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567579775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94529,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1557834419,"is_pvip":false,"replies":[{"id":"33886","content":"约定","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1557899605,"ip_address":"","comment_id":94529,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557834419","product_id":100024701,"comment_content":"请问一下老师为什么栈的结构是栈底是高地址栈顶是低地址呢，为什么不是反过来的呢？","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450097,"discussion_content":"约定","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557899605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94025,"user_name":"六月星空2011","can_delete":false,"product_type":"c1","uid":1067228,"ip_address":"","ucode":"D47D5C8AA8B701","user_header":"https://static001.geekbang.org/account/avatar/00/10/48/dc/fef6ed17.jpg","comment_is_top":false,"comment_ctime":1557708144,"is_pvip":false,"replies":[{"id":"49376","content":"内核的数据结构是复用的","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567651843,"ip_address":"","comment_id":94025,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557708144","product_id":100024701,"comment_content":"这里应该说的是线程栈的内存空间不释放，后续创建线程的时候直接复用内存空间，而不是线程池的概念。","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449875,"discussion_content":"内核的数据结构是复用的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567651843,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93640,"user_name":"W.jyao","can_delete":false,"product_type":"c1","uid":1422582,"ip_address":"","ucode":"C57B3A78B6A795","user_header":"https://static001.geekbang.org/account/avatar/00/15/b4/f6/735673f7.jpg","comment_is_top":false,"comment_ctime":1557542499,"is_pvip":false,"replies":[{"id":"49395","content":"后面会讲信号的，信号会挂在一个数据结构上，所有的线程都能访问到的","user_name":"作者回复","user_name_real":"刘超@网易云","uid":"1001590","ctime":1567654496,"ip_address":"","comment_id":93640,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557542499","product_id":100024701,"comment_content":"问一下，如果一个信号是进程共享，比如说kill，那么是主线程会收到这个信号还是这个进程的任意一个线程都有可能收到？麻烦老师解答下","like_count":0,"discussions":[{"author":{"id":1001590,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/76/0c7d4d23.jpg","nickname":"刘超","note":"","ucode":"196BF3F499E8FE","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449714,"discussion_content":"后面会讲信号的，信号会挂在一个数据结构上，所有的线程都能访问到的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567654496,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93577,"user_name":"安排","can_delete":false,"product_type":"c1","uid":1260026,"ip_address":"","ucode":"F78CFA9624CAEF","user_header":"https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg","comment_is_top":false,"comment_ctime":1557503712,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557503712","product_id":100024701,"comment_content":"在proc目录下有每个进程的目录，进程的目录下又包含这个进程下每个线程的目录，进入线程目录中即可查看每个线程的详细信息，这是在命令行通过proc文件系统查看的情况。   pthread库应该也提供了api，用来获取每个线程的信息，暂时还没有去查。","like_count":0}]}