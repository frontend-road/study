{"id":207456,"title":"53 | 组合模式：如何设计实现支持递归遍历的文件系统目录树结构？","content":"<p>结构型设计模式就快要讲完了，还剩下两个不那么常用的：组合模式和享元模式。今天，我们来讲一下<strong>组合模式</strong>（Composite Design Pattern）。</p><p>组合模式跟我们之前讲的面向对象设计中的“组合关系（通过组合来组装两个类）”，完全是两码事。这里讲的“组合模式”，主要是用来处理树形结构数据。这里的“数据”，你可以简单理解为一组对象集合，待会我们会详细讲解。</p><p>正因为其应用场景的特殊性，数据必须能表示成树形结构，这也导致了这种模式在实际的项目开发中并不那么常用。但是，一旦数据满足树形结构，应用这种模式就能发挥很大的作用，能让代码变得非常简洁。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>组合模式的原理与实现</h2><p>在GoF的《设计模式》一书中，组合模式是这样定义的：</p><blockquote>\n<p>Compose objects into tree structure to represent part-whole hierarchies.Composite lets client treat individual objects and compositions of objects uniformly.</p>\n</blockquote><p>翻译成中文就是：将一组对象组织（Compose）成树形结构，以表示一种“部分-整体”的层次结构。组合让客户端（在很多设计模式书籍中，“客户端”代指代码的使用者。）可以统一单个对象和组合对象的处理逻辑。</p><!-- [[[read_end]]] --><p>接下来，对于组合模式，我举个例子来给你解释一下。</p><p>假设我们有这样一个需求：设计一个类来表示文件系统中的目录，能方便地实现下面这些功能：</p><ul>\n<li>动态地添加、删除某个目录下的子目录或文件；</li>\n<li>统计指定目录下的文件个数；</li>\n<li>统计指定目录下的文件总大小。</li>\n</ul><p>我这里给出了这个类的骨架代码，如下所示。其中的核心逻辑并未实现，你可以试着自己去补充完整，再来看我的讲解。在下面的代码实现中，我们把文件和目录统一用FileSystemNode类来表示，并且通过isFile属性来区分。</p><pre><code>public class FileSystemNode {\n  private String path;\n  private boolean isFile;\n  private List&lt;FileSystemNode&gt; subNodes = new ArrayList&lt;&gt;();\n\n  public FileSystemNode(String path, boolean isFile) {\n    this.path = path;\n    this.isFile = isFile;\n  }\n\n  public int countNumOfFiles() {\n    // TODO:...\n  }\n\n  public long countSizeOfFiles() {\n    // TODO:...\n  }\n\n  public String getPath() {\n    return path;\n  }\n\n  public void addSubNode(FileSystemNode fileOrDir) {\n    subNodes.add(fileOrDir);\n  }\n\n  public void removeSubNode(FileSystemNode fileOrDir) {\n    int size = subNodes.size();\n    int i = 0;\n    for (; i &lt; size; ++i) {\n      if (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) {\n        break;\n      }\n    }\n    if (i &lt; size) {\n      subNodes.remove(i);\n    }\n  }\n}\n</code></pre><p>实际上，如果你看过我的《数据结构与算法之美》专栏，想要补全其中的countNumOfFiles()和countSizeOfFiles()这两个函数，并不是件难事，实际上这就是树上的递归遍历算法。对于文件，我们直接返回文件的个数（返回1）或大小。对于目录，我们遍历目录中每个子目录或者文件，递归计算它们的个数或大小，然后求和，就是这个目录下的文件个数和文件大小。</p><p>我把两个函数的代码实现贴在下面了，你可以对照着看一下。</p><pre><code>  public int countNumOfFiles() {\n    if (isFile) {\n      return 1;\n    }\n    int numOfFiles = 0;\n    for (FileSystemNode fileOrDir : subNodes) {\n      numOfFiles += fileOrDir.countNumOfFiles();\n    }\n    return numOfFiles;\n  }\n\n  public long countSizeOfFiles() {\n    if (isFile) {\n      File file = new File(path);\n      if (!file.exists()) return 0;\n      return file.length();\n    }\n    long sizeofFiles = 0;\n    for (FileSystemNode fileOrDir : subNodes) {\n      sizeofFiles += fileOrDir.countSizeOfFiles();\n    }\n    return sizeofFiles;\n  }\n</code></pre><p>单纯从功能实现角度来说，上面的代码没有问题，已经实现了我们想要的功能。但是，如果我们开发的是一个大型系统，从扩展性（文件或目录可能会对应不同的操作）、业务建模（文件和目录从业务上是两个概念）、代码的可读性（文件和目录区分对待更加符合人们对业务的认知）的角度来说，我们最好对文件和目录进行区分设计，定义为File和Directory两个类。</p><p>按照这个设计思路，我们对代码进行重构。重构之后的代码如下所示：</p><pre><code>public abstract class FileSystemNode {\n  protected String path;\n\n  public FileSystemNode(String path) {\n    this.path = path;\n  }\n\n  public abstract int countNumOfFiles();\n  public abstract long countSizeOfFiles();\n\n  public String getPath() {\n    return path;\n  }\n}\n\npublic class File extends FileSystemNode {\n  public File(String path) {\n    super(path);\n  }\n\n  @Override\n  public int countNumOfFiles() {\n    return 1;\n  }\n\n  @Override\n  public long countSizeOfFiles() {\n    java.io.File file = new java.io.File(path);\n    if (!file.exists()) return 0;\n    return file.length();\n  }\n}\n\npublic class Directory extends FileSystemNode {\n  private List&lt;FileSystemNode&gt; subNodes = new ArrayList&lt;&gt;();\n\n  public Directory(String path) {\n    super(path);\n  }\n\n  @Override\n  public int countNumOfFiles() {\n    int numOfFiles = 0;\n    for (FileSystemNode fileOrDir : subNodes) {\n      numOfFiles += fileOrDir.countNumOfFiles();\n    }\n    return numOfFiles;\n  }\n\n  @Override\n  public long countSizeOfFiles() {\n    long sizeofFiles = 0;\n    for (FileSystemNode fileOrDir : subNodes) {\n      sizeofFiles += fileOrDir.countSizeOfFiles();\n    }\n    return sizeofFiles;\n  }\n\n  public void addSubNode(FileSystemNode fileOrDir) {\n    subNodes.add(fileOrDir);\n  }\n\n  public void removeSubNode(FileSystemNode fileOrDir) {\n    int size = subNodes.size();\n    int i = 0;\n    for (; i &lt; size; ++i) {\n      if (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) {\n        break;\n      }\n    }\n    if (i &lt; size) {\n      subNodes.remove(i);\n    }\n  }\n}\n</code></pre><p>文件和目录类都设计好了，我们来看，如何用它们来表示一个文件系统中的目录树结构。具体的代码示例如下所示：</p><pre><code>public class Demo {\n  public static void main(String[] args) {\n    /**\n     * /\n     * /wz/\n     * /wz/a.txt\n     * /wz/b.txt\n     * /wz/movies/\n     * /wz/movies/c.avi\n     * /xzg/\n     * /xzg/docs/\n     * /xzg/docs/d.txt\n     */\n    Directory fileSystemTree = new Directory(&quot;/&quot;);\n    Directory node_wz = new Directory(&quot;/wz/&quot;);\n    Directory node_xzg = new Directory(&quot;/xzg/&quot;);\n    fileSystemTree.addSubNode(node_wz);\n    fileSystemTree.addSubNode(node_xzg);\n\n    File node_wz_a = new File(&quot;/wz/a.txt&quot;);\n    File node_wz_b = new File(&quot;/wz/b.txt&quot;);\n    Directory node_wz_movies = new Directory(&quot;/wz/movies/&quot;);\n    node_wz.addSubNode(node_wz_a);\n    node_wz.addSubNode(node_wz_b);\n    node_wz.addSubNode(node_wz_movies);\n\n    File node_wz_movies_c = new File(&quot;/wz/movies/c.avi&quot;);\n    node_wz_movies.addSubNode(node_wz_movies_c);\n\n    Directory node_xzg_docs = new Directory(&quot;/xzg/docs/&quot;);\n    node_xzg.addSubNode(node_xzg_docs);\n\n    File node_xzg_docs_d = new File(&quot;/xzg/docs/d.txt&quot;);\n    node_xzg_docs.addSubNode(node_xzg_docs_d);\n\n    System.out.println(&quot;/ files num:&quot; + fileSystemTree.countNumOfFiles());\n    System.out.println(&quot;/wz/ files num:&quot; + node_wz.countNumOfFiles());\n  }\n}\n</code></pre><p>我们对照着这个例子，再重新看一下组合模式的定义：“将一组对象（文件和目录）组织成树形结构，以表示一种‘部分-整体’的层次结构（目录与子目录的嵌套结构）。组合模式让客户端可以统一单个对象（文件）和组合对象（目录）的处理逻辑（递归遍历）。”</p><p>实际上，刚才讲的这种组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现。</p><h2>组合模式的应用场景举例</h2><p>刚刚我们讲了文件系统的例子，对于组合模式，我这里再举一个例子。搞懂了这两个例子，你基本上就算掌握了组合模式。在实际的项目中，遇到类似的可以表示成树形结构的业务场景，你只要“照葫芦画瓢”去设计就可以了。</p><p>假设我们在开发一个OA系统（办公自动化系统）。公司的组织结构包含部门和员工两种数据类型。其中，部门又可以包含子部门和员工。在数据库中的表结构如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/5b/8b/5b19dc0c296f728328794eab1f16a38b.jpg?wh=1863*1023\" alt=\"\"></p><p>我们希望在内存中构建整个公司的人员架构图（部门、子部门、员工的隶属关系），并且提供接口计算出部门的薪资成本（隶属于这个部门的所有员工的薪资和）。</p><p>部门包含子部门和员工，这是一种嵌套结构，可以表示成树这种数据结构。计算每个部门的薪资开支这样一个需求，也可以通过在树上的遍历算法来实现。所以，从这个角度来看，这个应用场景可以使用组合模式来设计和实现。</p><p>这个例子的代码结构跟上一个例子的很相似，代码实现我直接贴在了下面，你可以对比着看一下。其中，HumanResource是部门类（Department）和员工类（Employee）抽象出来的父类，为的是能统一薪资的处理逻辑。Demo中的代码负责从数据库中读取数据并在内存中构建组织架构图。</p><pre><code>public abstract class HumanResource {\n  protected long id;\n  protected double salary;\n\n  public HumanResource(long id) {\n    this.id = id;\n  }\n\n  public long getId() {\n    return id;\n  }\n\n  public abstract double calculateSalary();\n}\n\npublic class Employee extends HumanResource {\n  public Employee(long id, double salary) {\n    super(id);\n    this.salary = salary;\n  }\n\n  @Override\n  public double calculateSalary() {\n    return salary;\n  }\n}\n\npublic class Department extends HumanResource {\n  private List&lt;HumanResource&gt; subNodes = new ArrayList&lt;&gt;();\n\n  public Department(long id) {\n    super(id);\n  }\n\n  @Override\n  public double calculateSalary() {\n    double totalSalary = 0;\n    for (HumanResource hr : subNodes) {\n      totalSalary += hr.calculateSalary();\n    }\n    this.salary = totalSalary;\n    return totalSalary;\n  }\n\n  public void addSubNode(HumanResource hr) {\n    subNodes.add(hr);\n  }\n}\n\n// 构建组织架构的代码\npublic class Demo {\n  private static final long ORGANIZATION_ROOT_ID = 1001;\n  private DepartmentRepo departmentRepo; // 依赖注入\n  private EmployeeRepo employeeRepo; // 依赖注入\n\n  public void buildOrganization() {\n    Department rootDepartment = new Department(ORGANIZATION_ROOT_ID);\n    buildOrganization(rootDepartment);\n  }\n\n  private void buildOrganization(Department department) {\n    List&lt;Long&gt; subDepartmentIds = departmentRepo.getSubDepartmentIds(department.getId());\n    for (Long subDepartmentId : subDepartmentIds) {\n      Department subDepartment = new Department(subDepartmentId);\n      department.addSubNode(subDepartment);\n      buildOrganization(subDepartment);\n    }\n    List&lt;Long&gt; employeeIds = employeeRepo.getDepartmentEmployeeIds(department.getId());\n    for (Long employeeId : employeeIds) {\n      double salary = employeeRepo.getEmployeeSalary(employeeId);\n      department.addSubNode(new Employee(employeeId, salary));\n    }\n  }\n}\n</code></pre><p>我们再拿组合模式的定义跟这个例子对照一下：“将一组对象（员工和部门）组织成树形结构，以表示一种‘部分-整体’的层次结构（部门与子部门的嵌套结构）。组合模式让客户端可以统一单个对象（员工）和组合对象（部门）的处理逻辑（递归遍历）。”</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现。</p><p>组合模式，将一组对象组织成树形结构，将单个对象和组合对象都看做树中的节点，以统一处理逻辑，并且它利用树形结构的特点，递归地处理每个子树，依次简化代码实现。使用组合模式的前提在于，你的业务场景必须能够表示成树形结构。所以，组合模式的应用场景也比较局限，它并不是一种很常用的设计模式。</p><h2>课堂讨论</h2><p>在文件系统那个例子中，countNumOfFiles()和countSizeOfFiles()这两个函数实现的效率并不高，因为每次调用它们的时候，都要重新遍历一遍子树。有没有什么办法可以提高这两个函数的执行效率呢（注意：文件系统还会涉及频繁的删除、添加文件操作，也就是对应Directory类中的addSubNode()和removeSubNode()函数）？</p><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>","comments":[{"had_liked":false,"id":185015,"user_name":"下雨天","can_delete":false,"product_type":"c1","uid":1008315,"ip_address":"","ucode":"816B3792ECC50A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/62/bb/323a3133.jpg","comment_is_top":false,"comment_ctime":1583465971,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"534159410675","product_id":100039001,"comment_content":"课堂讨论：<br>实质是&quot;递归代码要警惕重复计算&quot;问题！可以用散列表存储每个(path,size)，通过路径直接返回对应的size,删除或者添加的时候，维护这个size即可。<br><br>参看争哥《数据结构与算法之美》第十讲：为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算，这样就能避免刚讲的问题了。","like_count":125,"discussions":[{"author":{"id":1050335,"avatar":"https://static001.geekbang.org/account/avatar/00/10/06/df/60126ff3.jpg","nickname":"0bug","note":"","ucode":"CADCC882F31784","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":236261,"discussion_content":"只修改当前路径key的size不行，要同步修改所有父类路径key的size","likes_number":17,"is_delete":false,"is_hidden":false,"ctime":1587084846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1244950,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ff/16/b0ab9a73.jpg","nickname":"luffy","note":"","ucode":"702034E116A99F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351174,"discussion_content":"如果文件系统有数十亿的文件，散列表保存还合适吗","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1614171939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1227840,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/40/2279cfb5.jpg","nickname":"大力水手Jerry","note":"","ucode":"E4A6C71E275DB5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338439,"discussion_content":"0bug说的对，但每次进行增删文件操作就同步修改所有祖先节点的size，成本更大，因为老师特意说了“频繁的删除、添加文件操作”。另外避免重复计算的前提是在同一个递归过程中，这里树的深度优先递归遍历并不涉及重复计算，因此这个思路几乎完全不可行。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1609291463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1058015,"avatar":"https://static001.geekbang.org/account/avatar/00/10/24/df/645f8087.jpg","nickname":"Yayu","note":"","ucode":"5E7842458D8229","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1227840,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/40/2279cfb5.jpg","nickname":"大力水手Jerry","note":"","ucode":"E4A6C71E275DB5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374538,"discussion_content":"Jerry 老师有什么可行的方案吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621238170,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":338439,"ip_address":""},"score":374538,"extra":""}]},{"author":{"id":2699218,"avatar":"","nickname":"Geek_279849","note":"","ucode":"FC6A3514FC955C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556777,"discussion_content":"哈希表放哪呢？树类中？每个节点保存所有节点的size？浪费太多空间了吧。加个size字段和父节点，更省空间。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647507703,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1311125,"avatar":"https://static001.geekbang.org/account/avatar/00/14/01/95/fd09e8a8.jpg","nickname":"布拉姆","note":"","ucode":"479FF27D73BCAD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391995,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630751838,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1053390,"avatar":"https://static001.geekbang.org/account/avatar/00/10/12/ce/a8c8b5e8.jpg","nickname":"Jason","note":"","ucode":"ABB3F1A63E102A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":218864,"discussion_content":"这个答案，我认为是标准的答案。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585707978,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184263,"user_name":"八戒","can_delete":false,"product_type":"c1","uid":1113109,"ip_address":"","ucode":"15774D7D5F1E53","user_header":"https://static001.geekbang.org/account/avatar/00/10/fc/15/a1f83883.jpg","comment_is_top":false,"comment_ctime":1583280249,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"250691383417","product_id":100039001,"comment_content":"课堂讨论<br>可以把计算文件数量和大小的逻辑抽出来，定义两个成员变量文件大小和文件数量；<br>在每次addSubNode()和removeSubNode()的时候去调用计算逻辑，更新文件大小和文件数量；<br>这样在调用countNumOfFiles和countSizeOfFiles的时候直接返回我们的成员变量就好了；<br>当然如果这么做的话，那countNumOfFiles和countSizeOfFiles这两个方法的名字也不合适了，应该叫numOfFiles和sizeOfFiles","like_count":57},{"had_liked":false,"id":195210,"user_name":"业余爱好者","can_delete":false,"product_type":"c1","uid":1482915,"ip_address":"","ucode":"A890935A982988","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","comment_is_top":false,"comment_ctime":1585146763,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"190563707787","product_id":100039001,"comment_content":"tomcat的多层容器也是使用了组合模式。只需要调用最外层容器Server的init方法，整个程序就起来了。客户端只需要处理最外层的容器，就把整个系统拎起来了。<br><br>组合模式使用了树形的数据结构以及递归算法，这里也可以看出知识的相通性（算法和设计模式）。想到这方面的另外一个例子就是责任链模式，责任链模式就是使用了数据结构中的链表和递归算法。","like_count":45},{"had_liked":false,"id":184286,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1583283779,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"104662498883","product_id":100039001,"comment_content":"把计算逻辑放在addSubNode和removeSubNode里面","like_count":25},{"had_liked":false,"id":184265,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1583280382,"is_pvip":true,"discussion_count":5,"race_medal":0,"score":"66007789822","product_id":100039001,"comment_content":"我想的一个思路是：每个节点新增一个field：parent，父链接指向它的上层节点，同时增加字段numOfFiles，sizeOfFiles。对于File节点：numOfFiles=1， sizeOfFiles=它自己的大小。对于Directory节点，是其子节点的和。删除、增加subnode时，只需要从下向上遍历一个节点的parent link，修改numOfFiles和sizeOfFiles。这样的话删除、新增subnode修改值的复杂度为树的深度，查询返回numOfFiles和sizeOfFiles复杂度为O(1)。","like_count":16,"discussions":[{"author":{"id":1250922,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIzGGthScz54sECZJKX3lgyjCATkgrvSt5N3eOsYB34jibCr3SkAX88QaZ5IVmME9Ec7VdkQGwRSPw/132","nickname":"哈哈哈","note":"","ucode":"8AC20A1C9C7DF8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302751,"discussion_content":"你这样设计，目前添加、删除操作并不是O(1), 而且O(tree_height)","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599020808,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":195998,"discussion_content":"只要树的层次不是特别的变态,文件增删不是超级频繁,我觉得这是一个办法.","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583326470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1415619,"avatar":"https://static001.geekbang.org/account/avatar/00/15/99/c3/e4f408d4.jpg","nickname":"陌兮","note":"","ucode":"00CE47CAECD5CD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573889,"discussion_content":"这个方案比前几个都要靠谱的多","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653711125,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2234620,"avatar":"https://static001.geekbang.org/account/avatar/00/22/18/fc/4f92ee4e.jpg","nickname":"江南一笑","note":"","ucode":"E38938A1178827","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344227,"discussion_content":"可以的！ 前提是： 修改的次数小于查询的次数。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611360646,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1228518,"avatar":"https://static001.geekbang.org/account/avatar/00/12/be/e6/7808520d.jpg","nickname":"Edward Lee","note":"","ucode":"156223F1D7E94A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260510,"discussion_content":"优秀，我们想到一块去了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588865466,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184351,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1583296858,"is_pvip":true,"discussion_count":4,"race_medal":0,"score":"61712839002","product_id":100039001,"comment_content":"真的是没有最适合，只有更适合<br>实际工作中碰到过一个场景需要抽象出条件和表达式来解决的。一个表达式可以拥有N个子表达式以及条件，这个表达式还有一个属性and、or来决定所有子表达式&#47;条件是全部成立还是只要有一个成立，这个表达式就成立。<br>当时做的时候真是各种绕，这种场景真的非常适合组合模式，能大大简化代码的实现难度，提高可读、可维护性","like_count":15,"discussions":[{"author":{"id":1088710,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/c6/05a6798f.jpg","nickname":"苗","note":"","ucode":"5ECCC6C855E541","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212653,"discussion_content":"解释器模式好像更合适。有开源的表达式引擎https://nutzam.com/core/el/overview.html","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584987603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1193385,"avatar":"https://static001.geekbang.org/account/avatar/00/12/35/a9/e2a0ad48.jpg","nickname":"懒散","note":"","ucode":"6FC704ABE5A9E1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284829,"discussion_content":"我觉得自由拼接sql where条件的功能也可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592654860,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1474954,"avatar":"https://static001.geekbang.org/account/avatar/00/16/81/8a/15a96a64.jpg","nickname":"Gatsby","note":"","ucode":"5DBFDA12556BDB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1193385,"avatar":"https://static001.geekbang.org/account/avatar/00/12/35/a9/e2a0ad48.jpg","nickname":"懒散","note":"","ucode":"6FC704ABE5A9E1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379609,"discussion_content":"+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624010804,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":284829,"ip_address":""},"score":379609,"extra":""}]},{"author":{"id":1318540,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1e/8c/450fe5cb.jpg","nickname":"花儿少年","note":"","ucode":"CFE4F64243673B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212139,"discussion_content":"我们也有这个场景，很像是流程引擎","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584939359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187787,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1584241727,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"53123849279","product_id":100039001,"comment_content":"设计模式_53:<br># 作业<br>可以做文件数和文件大小的缓存，更新缓存时要考虑实时性与性能的平衡。<br><br># 感想<br>今天的内容，联想到Linux“一切皆文件”的设计思想。<br>好像天然就觉得应该这样做，但是，还能怎么做呢？<br><br>还能。。。把Directory和File设计成不想关的两个类，这样又有什么问题呢？<br>不过是Directory维护两个List(file&#47;directory),维护两套方法，add&#47;removeFile,add&#47;removeDirectory。。。这当然没有以前简洁，但也没有特别复杂吧。。。<br><br>后面又想到，如果File还分很多类型: TxtFile&#47;ImageFile&#47;ExeFile&#47;...,Directory(这里是广义的集合)也可以有多种: LinearDirectory&#47;GridDirectory&#47;CircleDirectory&#47;...<br><br>这样会不会导致处理逻辑的爆炸，你会说：当然不会啊，所有的类型最终会抽象为File和Directory两种类型啊！<br><br>既然都抽象了，何不彻底一点，把File和Directory也抽象为一种类型:<br>Everything is a File.","like_count":13},{"had_liked":false,"id":184849,"user_name":"webmin","can_delete":false,"product_type":"c1","uid":1047014,"ip_address":"","ucode":"98B0CA882454E8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/e6/47742988.jpg","comment_is_top":false,"comment_ctime":1583417991,"is_pvip":true,"discussion_count":4,"race_medal":0,"score":"23058254471","product_id":100039001,"comment_content":"&#47;&#47;每一级目录保存本级目录中的文件数和文件Size，Count时递归统计所有子目录<br>public class Directory extends FileSystemNode {<br>    private List&lt;FileSystemNode&gt; subNodes = new ArrayList&lt;&gt;();<br>    private Map&lt;String,FileSystemNode&gt; subDirectory = new HashMap&lt;&gt;();<br>    private int _numOfFiles = 0;<br>    private long _sizeofFiles = 0;<br><br>    public Directory(String path) {<br>        super(path);<br>    }<br><br>    @Override<br>    public int countNumOfFiles() {<br>        int numOfFiles = 0;<br>        for (FileSystemNode fileOrDir : subDirectory.values()) {<br>            numOfFiles += fileOrDir.countNumOfFiles();<br>        }<br>        return numOfFiles + _numOfFiles;<br>    }<br><br>    @Override<br>    public long countSizeOfFiles() {<br>        long sizeofFiles = 0;<br>        for (FileSystemNode fileOrDir : subDirectory.values()) {<br>            sizeofFiles += fileOrDir.countSizeOfFiles();<br>        }<br>        return sizeofFiles + _sizeofFiles;<br>    }<br><br>    public void addSubNode(FileSystemNode fileOrDir) {<br>        if(fileOrDir instanceof Directory) {<br>            subDirectory.put(fileOrDir.getPath(),fileOrDir);<br>        } else {<br>            _numOfFiles++;<br>            _sizeofFiles += fileOrDir.countSizeOfFiles();<br>            subNodes.add(fileOrDir);<br>        }<br>    }<br><br>    public void removeSubNode(FileSystemNode fileOrDir) {<br>        if(fileOrDir instanceof Directory) {<br>            subDirectory.remove(fileOrDir.getPath());<br>            return;<br>        }<br>        int size = subNodes.size();<br>        int i = 0;<br>        for (; i &lt; size; ++i) {<br>            if (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) {<br>                break;<br>            }<br>        }<br>        if (i &lt; size) {<br>            subNodes.remove(i);<br>            _numOfFiles--;<br>            _sizeofFiles -= fileOrDir.countSizeOfFiles();<br>        }<br>    }<br>}","like_count":6},{"had_liked":false,"id":184468,"user_name":"唐朝农民","can_delete":false,"product_type":"c1","uid":1133947,"ip_address":"","ucode":"6F8F43C6652225","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIaOAxRlZjFkGfRBn420LuAcyWkMrpq5iafGdqthX5icJPjql0ibZOAdafaqbfvw4ZpVzDmsaYglVXDw/132","comment_is_top":false,"comment_ctime":1583322984,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"23058159464","product_id":100039001,"comment_content":"那个算薪资的在实际生产中也不回这么用吧，虽然使用设计模式提高代码的可扩展性，但是需要循环，递归调用数据仓储层，如果员工一多肯定造成很大的性能影响，这也是我经常纠结的地方，有个时候为了减少访问数据库的次数，而不得不放弃更优雅的代码，请问这种情况该怎么破？","like_count":6,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500474,"discussion_content":"一般没有facade吧，如果有的话，应该是在controller层之上的吧，而不是在service层之上吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594388155,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186723,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1583911783,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18763780967","product_id":100039001,"comment_content":"1.查询多而修改少的话那么我们可以维持三个属性,分别是数量 大小 父节点,那么在修改的时候,先递归向下的修改,修改到底(例如删除的情况),并且依次返回修改的大小和数量,在递归向上的时候,依次修改父类的数量和大小,直到没有父类,这样无论查询那一个,都能快速查找到<br>2.修改多而查询少的情况,则简单些,只需要定义两个属性,数量和大小,查找的时候,递归统计所有的子目录这个信息即可","like_count":5},{"had_liked":false,"id":185260,"user_name":"相逢是缘","can_delete":false,"product_type":"c1","uid":1060730,"ip_address":"","ucode":"CB299F53A95654","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg","comment_is_top":false,"comment_ctime":1583548049,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18763417233","product_id":100039001,"comment_content":"一、定义（理解）：<br>将一组对象组织（Compose）成树形结构，以表示一种“部分 - 整体”的层次结构。组合让客户端（在很多设计模式书籍中，“客户端”代指代码的使用者。）可以统一单个对象和组合对象的处理逻辑。<br> 对业务场景的一种数据结构和算法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现。<br>二、使用场景：<br>业务场景必须能够表示成树形结构。<br>三、实现方式：<br>  组合模式，将一组对象组织成树形结构，将单个对象和组合对象都看做树中的节点，以统一处理逻辑，并且它利用树形结构的特点，递归地处理每个子树，依次简化代码实现。（在这里一般可以抽象出一个抽象类，叶子节点和中间节点（根节点）继承与抽象类，对中间节点（根节点）处理就是递归的调用）","like_count":5},{"had_liked":false,"id":184307,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1583286662,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"14468188550","product_id":100039001,"comment_content":"Directory中缓存子节点数量和大小的信息，每次addSubNode和removeSubNode时，失效缓存的节点数量和大小的信息，这样每次查询的时候，如果缓存的信息有效，那么就直接返回，反之就遍历一遍，有点类似于数据库和cache数据同步的cache-aside方式，另外如果file本身大小如果有变化，也要有办法去失效Directory中的缓存信息，这就需要实现新的接口通知机制。","like_count":4},{"had_liked":false,"id":225134,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1591665035,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10181599627","product_id":100039001,"comment_content":"尝试将方法动态返回改为静态返回变量，<br>然后在添加数据时动态更新变量值。<br>思想：<br>1，是用空间换时间，占用了两个成员变量，但是返回时无需计算<br>2，是把部分操作打散到每一步去，从而减少返回数量的数值。（有点像是，数据结构之美中讲过的，集合在边长时，数据迁移的操作描述）<br><br>但是，其实还是存在问题。文件数量是用变量写死的，而不是由方法动态统计。则会存在数据不一致的问题。例如并发问题。再或者，通过程序外删除文件后，就无法保证返回值的正确性。<br><br>我还有一种折衷的解决方案，也类似于成员变量控制。就是——【引入缓存概念】。<br>获取文件数量时，把文件数量存入缓存，更新或者删除文件时，再清空缓存。同样，也可以手动清空或者定期清空。<br>在文件未做更新操作时，获取文件数量，直接从缓存中获取即可，在做文件插入或者更新操作后，将缓存清空。<br>这种情况，如果额外人为手动删除了文件，也可以手动清空缓存来使得下一次重新计算文件数量，也可以手动定期清空，以保证大部分时候，返回的文件数量都正确。<br><br>其实并不算一个新方法，只是对动态获取的一种改良。<br>但是适用场景有限，只适用于读频率，大幅度高于写频率的场景。毕竟缓存的思想嘛。<br>另一方面是，未命中缓存的查询性能会很差。<br><br>引入缓存的概念，需要考虑的因素太多。是否有点，，，得不偿失？或者还有没有更佳的方式？","like_count":2},{"had_liked":false,"id":185537,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1583623235,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10173557827","product_id":100039001,"comment_content":"最近项目中用DAG来编排各种能力，代码上也用了类似于组合模式的做法","like_count":2},{"had_liked":false,"id":184417,"user_name":"Wh1","can_delete":false,"product_type":"c1","uid":1282715,"ip_address":"","ucode":"6D28506B99A285","user_header":"https://static001.geekbang.org/account/avatar/00/13/92/9b/65f98192.jpg","comment_is_top":false,"comment_ctime":1583311268,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10173245860","product_id":100039001,"comment_content":"重构之后的FileSystemNode的子类Directory中的递归方法 countNumOfFiles() 是不是少了结束判断语句？","like_count":2},{"had_liked":false,"id":184303,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1583286287,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10173220879","product_id":100039001,"comment_content":"组合模式与其说是设计模式,不如说是数据结构与算法的抽象. <br>就像小野二郎只做寿司一样, 组合模式专注于树形结构中单一对象(叶子节点)与组合对象(树节点)的递归遍历.","like_count":2},{"had_liked":false,"id":184259,"user_name":"小兵","can_delete":false,"product_type":"c1","uid":1261674,"ip_address":"","ucode":"AA3BA727C25179","user_header":"https://static001.geekbang.org/account/avatar/00/13/40/6a/ab1cf396.jpg","comment_is_top":false,"comment_ctime":1583279029,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10173213621","product_id":100039001,"comment_content":"课堂讨论首先想到了使用缓存，对于一个文件系统来说，文件的数量应当远高于文件夹的数量，可以在文件夹类增加一个成员变量，维护该层级下的文件数量，遍历的时候只需要遍历文件夹就可以了。","like_count":2},{"had_liked":false,"id":214997,"user_name":"Edward Lee","can_delete":false,"product_type":"c1","uid":1228518,"ip_address":"","ucode":"156223F1D7E94A","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/e6/7808520d.jpg","comment_is_top":false,"comment_ctime":1588865414,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5883832710","product_id":100039001,"comment_content":"增加 parent 引用及 filesCount &#47; filesSizeCount 加锁的变量，当调用 addSubNoe &#47; removeSubNode 的时候联级更新所有 parent 的 filesCount &#47; filesSizeCount 变量。<br><br>addSubNoe &#47; removeSubNode 时间复杂度为 O(k) k 是目录结构的最大深度<br>而 countNums &#47; countSize 的时间复杂度为 O(1)<br><br>相比之前的通过后序遍历所有节点计算效率应该有非常大的提升了","like_count":2,"discussions":[{"author":{"id":1058015,"avatar":"https://static001.geekbang.org/account/avatar/00/10/24/df/645f8087.jpg","nickname":"Yayu","note":"","ucode":"5E7842458D8229","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374536,"discussion_content":"将查询的压力转给了更新","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621238076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":194322,"user_name":"Q罗","can_delete":false,"product_type":"c1","uid":1792098,"ip_address":"","ucode":"E797378F4DA1F4","user_header":"https://static001.geekbang.org/account/avatar/00/1b/58/62/346dd248.jpg","comment_is_top":false,"comment_ctime":1585050108,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880017404","product_id":100039001,"comment_content":"组合模式讲解清晰到位～","like_count":1},{"had_liked":false,"id":185995,"user_name":"悠游","can_delete":false,"product_type":"c1","uid":1222834,"ip_address":"","ucode":"4FDDDDF29AE3F0","user_header":"https://static001.geekbang.org/account/avatar/00/12/a8/b2/998448ca.jpg","comment_is_top":false,"comment_ctime":1583739968,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5878707264","product_id":100039001,"comment_content":"将countNumOfFiles() 和 countSizeOfFiles()的结果保存为临时变量，初始化的时候生成，待后期add和delete的时候，进行修改（会涉及到整条路径），以后获取结果的时候直接从临时变量中获取<br><br>使用方式适合写多读少的场景。","like_count":1,"discussions":[{"author":{"id":1702886,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fb/e6/1b9edb91.jpg","nickname":"练习生","note":"","ucode":"60203A2AA0EA36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":359412,"discussion_content":"每次节点变更，都要重新维护这条路径上的所有节点的临时变量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616169828,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1702886,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fb/e6/1b9edb91.jpg","nickname":"练习生","note":"","ucode":"60203A2AA0EA36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":359411,"discussion_content":"不应该是读多写少的场景吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616169777,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184521,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1018370,"ip_address":"","ucode":"7A488CC6FE15E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","comment_is_top":false,"comment_ctime":1583332941,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5878300237","product_id":100039001,"comment_content":"打卡 今日学习组合模式，收获如下：<br>1. 对该模式有一个基本的认识<br>2. 该模式在开发中使用的场景并不多。可以使用该模式的业务场景需要满足业务域能够形成树形结构<br>3. 该模式是运用面向对象的思想来处理符合树形结构的业务场景，使得用户处理业务需求转化到处理整颗树或者数的一部分。","like_count":1},{"had_liked":false,"id":184332,"user_name":"Algo","can_delete":false,"product_type":"c1","uid":1119682,"ip_address":"","ucode":"D7B6D147F793E8","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/c2/cd8052c8.jpg","comment_is_top":false,"comment_ctime":1583291847,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5878259143","product_id":100039001,"comment_content":"给每个目录进行分片，当要增加目录&#47;文件或删除目录&#47;文件时，根据分片找到对应的部分，然后增加或删除，且更新该分片的文件个数。总数是根据各分片进行汇总的数字。。。。","like_count":1},{"had_liked":false,"id":184326,"user_name":"陆老师","can_delete":false,"product_type":"c1","uid":1203293,"ip_address":"","ucode":"0EA27C4755FF4A","user_header":"https://static001.geekbang.org/account/avatar/00/12/5c/5d/974b033f.jpg","comment_is_top":false,"comment_ctime":1583290692,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5878257988","product_id":100039001,"comment_content":"可以加入fileSize，和fileCount字段，并用volatile修饰。文件的增删改操作，重新计算并赋值两个成员变量。其他线程读取到的数值也是最新的数值。","like_count":1},{"had_liked":false,"id":184324,"user_name":"，","can_delete":false,"product_type":"c1","uid":1701867,"ip_address":"","ucode":"A5543C8DFEB198","user_header":"https://static001.geekbang.org/account/avatar/00/19/f7/eb/e7127bb8.jpg","comment_is_top":false,"comment_ctime":1583290324,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5878257620","product_id":100039001,"comment_content":"课后题:<br>这种方案应该多用于在服务启动时,从数据库&#47;配置文件取出数据,按照格式缓存起来,外部调用的时候直接从缓存中去取,可以添加变量size,维护在各个节点下面,在add&#47;remove时同时更新缓存和数据库(ps:这种数据一般很少变化吧?)","like_count":1},{"had_liked":false,"id":184308,"user_name":"Jackey","can_delete":false,"product_type":"c1","uid":1063751,"ip_address":"","ucode":"125DE81993FEDD","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/47/f6c772a1.jpg","comment_is_top":false,"comment_ctime":1583286719,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5878254015","product_id":100039001,"comment_content":"目录结构中存储这两项数据是否可行？每次新增或删除文件时就更新父节点的数据。这样的话就需要在结构体中增加一个“父指针”。","like_count":1},{"had_liked":false,"id":334831,"user_name":"Marco","can_delete":false,"product_type":"c1","uid":1397516,"ip_address":"","ucode":"796A4B9D1DE55D","user_header":"https://static001.geekbang.org/account/avatar/00/15/53/0c/b4907516.jpg","comment_is_top":false,"comment_ctime":1645149819,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645149819","product_id":100039001,"comment_content":"感觉组合模式从更宏观的角度看也是做了适配，将两个不同的类能放到一起进行工作。不过定义并不重要，重要的是灵活应用。","like_count":0},{"had_liked":false,"id":329488,"user_name":"山鬼谣","can_delete":false,"product_type":"c1","uid":1543162,"ip_address":"","ucode":"E25F498B85A01B","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/fa/103e6900.jpg","comment_is_top":false,"comment_ctime":1641369316,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641369316","product_id":100039001,"comment_content":"看完之后，感觉这个不像是一种模式，当然作者在文中也指出来了。<br>组合模式关键代码应该就是在嵌套对象中：<br>...<br>private List subNodes = new ArrayList&lt;&gt;();<br>...<br>public void addSubNode(HumanResource hr) { subNodes.add(hr); }<br>...<br>就这些片段来组装树形结构。<br>","like_count":0},{"had_liked":false,"id":320614,"user_name":"MrVito","can_delete":false,"product_type":"c1","uid":1252169,"ip_address":"","ucode":"716FF6F8871706","user_header":"https://static001.geekbang.org/account/avatar/00/13/1b/49/ddefc656.jpg","comment_is_top":false,"comment_ctime":1636421547,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636421547","product_id":100039001,"comment_content":"总结一下：组合模式，单一节点处理到树状结构递归处理，处理具有相同功能。<br>问题：其实涉及频繁操作导致数量重新计算，一般都会先想到用缓存存储处理，用hashmap可以，用父节点存储可以，都是使用内存先进行存储，有操作再去修改。但是考虑到如果节点成千上万，hashmap就会很占用存储空间，这就是典型的空间换取时间。 问题是为了提高执行效率，那只能增加空间的复杂度。","like_count":0},{"had_liked":false,"id":319600,"user_name":"zero","can_delete":false,"product_type":"c1","uid":1105848,"ip_address":"","ucode":"4FD99E108B1A31","user_header":"https://static001.geekbang.org/account/avatar/00/10/df/b8/1af6667e.jpg","comment_is_top":false,"comment_ctime":1635862708,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635862708","product_id":100039001,"comment_content":"示例代码中的 removeSubNode() 函数只能删除一级目录，fileSystemTree 对象没法删除二级目录 `&#47;wz&#47;movies&#47;`","like_count":0},{"had_liked":false,"id":315811,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1634007735,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634007735","product_id":100039001,"comment_content":"课后思考：<br>1.计算文件数量和大小效率不高，想到可以给Directory增加两个表示文件数量和大小的属性count,size<br>来进行缓存，这样计算两者的方法逻辑也要修改，如果有值就直接返回，如果没有就计算，并保存在属性中，这样下次就不用重复遍历子树。但是因为有频繁的插入和删除，每次删除或插入节点，该节点对应的所有父节点的属性值保存的数量就失效了，需要向上遍历，更新父节点的属性值，显然不符合当前假设的场景：频繁的插入删除。在这种场景下，缓存会频繁失效。<br><br>2.如果树的层级不是很深，文件数量不是很多，每次遍历还OK，如果树层级很深，文件数量很大，此时每次计算会很耗时，此时可以借鉴MySQL InnoDB中的自适应hash算法，以path为索引建立hash映射，这样对于频繁访问的目录就避免遍历，至于删除和插入时，可以对hash映射进行更新，如果删除或插入的是path的子节点，则更新对于的数量。","like_count":0},{"had_liked":false,"id":306421,"user_name":"乔帆 Kayla","can_delete":false,"product_type":"c1","uid":1883514,"ip_address":"","ucode":"81944832230BC4","user_header":"https://static001.geekbang.org/account/avatar/00/1c/bd/7a/37df606b.jpg","comment_is_top":false,"comment_ctime":1628557095,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628557095","product_id":100039001,"comment_content":"效率不高，每次调用，都要重新遍历一遍子树：可以使用 hashmap ，调用countNumOfFiles() 和 countSizeOfFiles()的时候，先找两个 hashmap 中有没有对应path的子节点，有的话直接取出，没有的话再去递归，递归返回的结果再存到对应的 hashmap；<br>频繁的删除、添加：可以使用支持快速删除和添加的数据结构（链表、跳表、红黑树等）去构建哈希表; Java可以用LinkedHashMap。","like_count":0},{"had_liked":false,"id":304653,"user_name":"爱上我们的微笑","can_delete":false,"product_type":"c1","uid":1459863,"ip_address":"","ucode":"40CDB7AB0991CE","user_header":"https://static001.geekbang.org/account/avatar/00/16/46/97/ddd4b05f.jpg","comment_is_top":false,"comment_ctime":1627538281,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627538281","product_id":100039001,"comment_content":"设置三层（n)目录缓存标准，动态更新缓存变化","like_count":0},{"had_liked":false,"id":304622,"user_name":"茶没喝完","can_delete":false,"product_type":"c1","uid":1644104,"ip_address":"","ucode":"D72D88C42A1258","user_header":"https://static001.geekbang.org/account/avatar/00/19/16/48/09493874.jpg","comment_is_top":false,"comment_ctime":1627524935,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627524935","product_id":100039001,"comment_content":"mybatis 解析mapper.xml时，ifNode WhereNode MixedNode。。。。等等标签也是用了组合模式来将每个&lt;select,update,insert,delete&gt;标签封装成树形，通过遍历树来解析sql","like_count":0},{"had_liked":false,"id":298748,"user_name":"Amon Tin","can_delete":false,"product_type":"c1","uid":2618193,"ip_address":"","ucode":"25391BEEB6A719","user_header":"https://static001.geekbang.org/account/avatar/00/27/f3/51/c8eb2d0c.jpg","comment_is_top":false,"comment_ctime":1624287044,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1624287044","product_id":100039001,"comment_content":"如果业务上有关联的两个结构A和B满足A=A*m+B*n的套娃关系，其中m和n分别表示A和B的出现次数，那么就可以对A和B抽出一个父类C，将关系改为A=C*(m+n)，这样就可以通过遍历C来实现对A的遍历，屏蔽了遍历过程中对每一层套娃的A和B的处理逻辑。<br>在文件和目录的例子中，目录是A，文件是B，抽象出了FileNode替换了所有套娃的A和B，最终变成了遍历以某个目录A为根节点的树。<br>在员工和部门的例子中，部门是A，员工是B，抽象出了人力资源替换了所有套娃的部门和员工，最终变成了遍历以某个部门A为根节点的树。","like_count":0},{"had_liked":false,"id":298456,"user_name":"嫉妒的耗子","can_delete":false,"product_type":"c1","uid":1098437,"ip_address":"","ucode":"5C200028E57B75","user_header":"https://static001.geekbang.org/account/avatar/00/10/c2/c5/ec5a3283.jpg","comment_is_top":false,"comment_ctime":1624114824,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624114824","product_id":100039001,"comment_content":"这节的内容在Android 里面 就是view和ViewGroup的关系，值得细细品味 ","like_count":0},{"had_liked":false,"id":294098,"user_name":"阿文","can_delete":false,"product_type":"c1","uid":1467219,"ip_address":"","ucode":"B53454CA52BD7E","user_header":"https://static001.geekbang.org/account/avatar/00/16/63/53/b4590ccc.jpg","comment_is_top":false,"comment_ctime":1621759620,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621759620","product_id":100039001,"comment_content":"增加一个全局的计算时间，Dir中增加两个属性sizeofFiles记住计算结果，calTime记住当前计算时间<br>public long countSizeOfFiles() {<br>  if (this.calTime == globalCalTime) return this.sizeofFiles;<br>  long sizeofFiles = 0;<br>  for (FileSystemNode fileOrDir : subNodes) {<br>    sizeofFiles += fileOrDir.countSizeOfFiles();<br>  }<br>  this.sizeofFiles = sizeofFiles;<br><br>  return sizeofFiles;<br>}<br><br>这样就不用基本只计算一次了","like_count":0},{"had_liked":false,"id":287321,"user_name":"郑大钱","can_delete":false,"product_type":"c1","uid":1503067,"ip_address":"","ucode":"114CF48056880E","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/5b/ff28088f.jpg","comment_is_top":false,"comment_ctime":1617881862,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617881862","product_id":100039001,"comment_content":"写作就是将网状的世界，用树状的结构，表现成线性的文字。<br>组合模式就是树化的过程。","like_count":0},{"had_liked":false,"id":286630,"user_name":"壹","can_delete":false,"product_type":"c1","uid":1023272,"ip_address":"","ucode":"335D34216066E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9d/28/bcaf070d.jpg","comment_is_top":false,"comment_ctime":1617438802,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617438802","product_id":100039001,"comment_content":"看到不少同学说在addnode和removenode中计算size。实际项目中，为节点类添加size属性保存计算过的结果。当添加或删除节点时将size设置为null来表示无效，下一次访问size时重新计算。这样会是比较高效的做法吧。","like_count":0},{"had_liked":false,"id":276885,"user_name":"刘大人","can_delete":false,"product_type":"c1","uid":1577210,"ip_address":"","ucode":"F66AE613E80398","user_header":"https://static001.geekbang.org/account/avatar/00/18/10/fa/d977627e.jpg","comment_is_top":false,"comment_ctime":1612166889,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612166889","product_id":100039001,"comment_content":"计算树形组织架构时，加个code 一级为001 二级为001001，三级为001001001 以此类推，人员中也存储这个code，计算时，sql中 like 目标的code， like &quot;","like_count":1},{"had_liked":false,"id":275727,"user_name":"Ryan24G","can_delete":false,"product_type":"c1","uid":1631292,"ip_address":"","ucode":"EA1E134C18DA80","user_header":"https://static001.geekbang.org/account/avatar/00/18/e4/3c/dfcb86df.jpg","comment_is_top":false,"comment_ctime":1611653180,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1611653180","product_id":100039001,"comment_content":"删除函数，可以删掉一整个目录，及其包含的所有文件吗？怎么感觉只能删除传进去的这个单目录而已。","like_count":0},{"had_liked":false,"id":274318,"user_name":"王川","can_delete":false,"product_type":"c1","uid":1944895,"ip_address":"","ucode":"AED1548E793EB3","user_header":"https://static001.geekbang.org/account/avatar/00/1d/ad/3f/b5eabecf.jpg","comment_is_top":false,"comment_ctime":1610963726,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610963726","product_id":100039001,"comment_content":"作为一个只会js的小前端看这个有些吃力了","like_count":0},{"had_liked":false,"id":272221,"user_name":"江南一笑","can_delete":false,"product_type":"c1","uid":2234620,"ip_address":"","ucode":"E38938A1178827","user_header":"https://static001.geekbang.org/account/avatar/00/22/18/fc/4f92ee4e.jpg","comment_is_top":false,"comment_ctime":1609992919,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609992919","product_id":100039001,"comment_content":"增加一个成员变量 parentNode ,  如果这个节点的size有变化，就去递归的更新父节点的size。","like_count":0},{"had_liked":false,"id":262792,"user_name":"Laughing","can_delete":false,"product_type":"c1","uid":1002134,"ip_address":"","ucode":"F68F1E000CA800","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/96/99466a06.jpg","comment_is_top":false,"comment_ctime":1605843330,"is_pvip":false,"replies":[{"id":"96120","content":"嗯嗯 说的没错","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606700923,"ip_address":"","comment_id":262792,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605843330","product_id":100039001,"comment_content":"把子数抽象成一类对象，并且增加数量等属性，这样就避免了多次的迭代。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478804,"discussion_content":"这个不在专栏内容之内呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580122466,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":252642,"user_name":"Gopher","can_delete":false,"product_type":"c1","uid":1206229,"ip_address":"","ucode":"3C1F9012BB486D","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/d5/1b26b725.jpg","comment_is_top":false,"comment_ctime":1602415388,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602415388","product_id":100039001,"comment_content":"这个妙就妙在递归的时候，部分 - 整体 都实现了自己的方法，递归的时候执行的不同类型的不同逻辑","like_count":0},{"had_liked":false,"id":238742,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1596278701,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596278701","product_id":100039001,"comment_content":"将中间结果用一个哈希表缓存起来","like_count":0},{"had_liked":false,"id":237970,"user_name":"reid","can_delete":false,"product_type":"c1","uid":1387837,"ip_address":"","ucode":"BB7DB14A4A97E8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/FydBiarFhvwAxkA2fL3IpEPWyumicHClKOAD1Y5Y7anvOTBYTxz5lxCIxx9ibE52QYtruHmrtXyMxa9KlnXaTibSuw/132","comment_is_top":false,"comment_ctime":1596016648,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596016648","product_id":100039001,"comment_content":"感觉这样会在递归中调用DAO层， 性能不会太好， 有什么更好的办法优化性能呢？","like_count":0},{"had_liked":false,"id":235053,"user_name":"hughieyu","can_delete":false,"product_type":"c1","uid":1206690,"ip_address":"","ucode":"FC1A64B2BAB784","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/a2/c30ac459.jpg","comment_is_top":false,"comment_ctime":1594879145,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594879145","product_id":100039001,"comment_content":"典型的还有对象的toJson()，一个对象也可以理解为一棵树","like_count":0},{"had_liked":false,"id":234344,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1594650731,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594650731","product_id":100039001,"comment_content":"常用的邀请人功能，邀请关系是树形结构，可以套用了","like_count":0},{"had_liked":false,"id":233455,"user_name":"xmeng","can_delete":false,"product_type":"c1","uid":1731543,"ip_address":"","ucode":"C0CA2182BA3B4B","user_header":"https://static001.geekbang.org/account/avatar/00/1a/6b/d7/8872624a.jpg","comment_is_top":false,"comment_ctime":1594338361,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1594338361","product_id":100039001,"comment_content":"一、定义（理解）：<br>将一组对象组织（Compose）成树形结构，以表示一种“部分 - 整体”的层次结构。组合让客户端（在很多设计模式书籍中，“客户端”代指代码的使用者。）可以统一单个对象和组合对象的处理逻辑。<br> 对业务场景的一种数据结构和算法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现。<br>二、使用场景：<br>业务场景必须能够表示成树形结构。<br>三、实现方式：<br>  组合模式，将一组对象组织成树形结构，将单个对象和组合对象都看做树中的节点，以统一处理逻辑，并且它利用树形结构的特点，递归地处理每个子树，依次简化代码实现。（在这里一般可以抽象出一个抽象类，叶子节点和中间节点（根节点）继承与抽象类，对中间节点（根节点）处理就是递归的调用）","like_count":0},{"had_liked":false,"id":233230,"user_name":"被过去推开","can_delete":false,"product_type":"c1","uid":1276690,"ip_address":"","ucode":"8B4F34FE93FD5B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Cib5umA0W17N9pichI08pnrXAExdbyh7AVzH4nEhD6KN3FXuELk4LJJuqUPPD7xmIy9nq5Hjbgnzic7sVZG5BKiaUQ/132","comment_is_top":false,"comment_ctime":1594265429,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594265429","product_id":100039001,"comment_content":"最近也在Java里面处理树形结构，父类和子类结构基本一致，这样子才能无差别对待它们。","like_count":0},{"had_liked":false,"id":232203,"user_name":"maybe","can_delete":false,"product_type":"c1","uid":1475528,"ip_address":"","ucode":"93D160F617E750","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/c8/5ce842f6.jpg","comment_is_top":false,"comment_ctime":1593918386,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1593918386","product_id":100039001,"comment_content":"组合模式，通过把一组对象组成树行结构，把一个对象和组合对象看作是树上的节点，可以统一处理。业务通过递归方式遍历树形结构完成。与其说是一种设计模式，不如说是一种具体场景的数据结构和算法的抽象。利用递归，谨防重复计算问题。通过利用缓存结果来防止重复计算，提升效率","like_count":0},{"had_liked":false,"id":226380,"user_name":"蹦哒","can_delete":false,"product_type":"c1","uid":1458931,"ip_address":"","ucode":"56591A657DE7C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epcs6PibsP9vEXv4EibUw3bhQPUK04zRTOvfrvF08TwM67xPb1LBh2uRENHQwo2VqYfC5GhJmM7icxHA/132","comment_is_top":false,"comment_ctime":1592056927,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592056927","product_id":100039001,"comment_content":"不知道如下理解是否正确：<br>组合模式可以看成是“面向接口而非实现编程”的一种实现；<br>组合模式可以看成是某种特殊形式的桥接模式，使用方（Demo）相当于是抽象类库，node相当于是实现","like_count":0},{"had_liked":false,"id":211176,"user_name":"面向百度编程","can_delete":false,"product_type":"c1","uid":1732780,"ip_address":"","ucode":"8FE04A019D71D1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","comment_is_top":false,"comment_ctime":1587910071,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587910071","product_id":100039001,"comment_content":"加个缓存","like_count":0},{"had_liked":false,"id":207848,"user_name":"墨鱼","can_delete":false,"product_type":"c1","uid":1022720,"ip_address":"","ucode":"8FB5E4DCB8A024","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/00/654be3f7.jpg","comment_is_top":false,"comment_ctime":1587197048,"is_pvip":false,"replies":[{"id":"86634","content":"你想叫它啥就叫它啥，反正道理你懂就行","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1594786002,"ip_address":"","comment_id":207848,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1587197048","product_id":100039001,"comment_content":"组合模式： 当数据结构呈现树状，可以使用递归处理每一处节点的数据。<br><br>感觉名字有点迷惑，应该叫做树状模式","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492261,"discussion_content":"你想叫它啥就叫它啥，反正道理你懂就行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594786002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":194834,"user_name":"cugphoenix","can_delete":false,"product_type":"c1","uid":1474356,"ip_address":"","ucode":"80101AF04C00D3","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI3F4IdQuDZrhN8ThibP85eCiaSWTYpTrcC6QB9EoAkw3IIj6otMibb1CgrS1uzITAnJmGLXQ2tgIkAQ/132","comment_is_top":false,"comment_ctime":1585108685,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585108685","product_id":100039001,"comment_content":"从文件系统的角度来说，组合模式讲的就是不要把文件和目录用同一个类表示，而是要抽象出一个通用的父类，文件和目录分别继承来实现。","like_count":0},{"had_liked":false,"id":191459,"user_name":"空白昵称","can_delete":false,"product_type":"c1","uid":1433815,"ip_address":"","ucode":"91F50CA25102AB","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/d7/744bd8c3.jpg","comment_is_top":false,"comment_ctime":1584774932,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584774932","product_id":100039001,"comment_content":"第一种方式是对每个文件（注意不是目录）缓存其大小。这样每次递归就可以方便返回，而不用从文件头读取。<br>第二种方式采用散列表，存储path和对应的size。当删除或添加文件的时候，从文件散列表删除相关path以及size。这样每次获取大小就很快了。<br><br>组合模式很适合能转化成树形结构的场景。比如星系，再比如世界、国家、省、市、县、镇、村... ","like_count":0}]}