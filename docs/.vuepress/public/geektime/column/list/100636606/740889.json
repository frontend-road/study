{"id":740889,"title":"第 14 章 服务配置管理(1)","content":"<blockquote>\n<p><strong>本章内容</strong></p>\n<ul>\n<li>Spring Cloud Config 的基本用法</li>\n<li>Spring Cloud Config 的实现原理</li>\n<li>几种常用的配置中心</li>\n</ul>\n</blockquote>\n<p>在一个复杂系统中，一定会存在大量的配置，特别是这个系统由大量微服务构成时，问题会更加严重，因为这些配置可能散落在各处，管理起来非常麻烦。Spring Cloud 既然是大量优秀实践的沉淀，自然也注意到了这个问题，为我们提供了一套比较成熟的解决方案。例如，在上一章介绍 Netflix OSS 时就提到了分布式配置中心 Archaius。本章中，让我们看看如何在 Spring Cloud Config 的帮助下解决微服务的配置管理难题。</p>\n<h2 id=\"nav_point_218\">14.1　使用 Spring Cloud Config 实现配置管理</h2>\n<p>在 Spring Cloud 的常用功能中，与服务发现同等重要的应该就是服务配置管理了。本节中我们就来一起了解一下配置该如何管理，Spring Cloud 提供了哪些便于配置管理的组件，这些组件又能如何保护我们的配置项。</p>\n<h3 id=\"nav_point_219\">14.1.1　为何需要配置中心</h3>\n<p>“早期的系统并不复杂，开发运维也比较简单粗暴，开发者们没有太多配置的概念，所有东西硬编码一下，如果需要针对新环境做些调整，那就在代码里改改，重新打个包发上去。”如果有人是这么告诉你的，那要么他是个几十年前的“古董”程序员，完全不接触新技术，要么就是他根本不懂软件开发与运维。</p>\n<p>在 Java 系统中，可以通过 <code>-D</code> 在命令行中传入系统参数，哪怕是启动 Tomcat 这样的容器，也能在代码里轻松获取 <code>-D</code> 传入的系统参数。像数据库连接池配置这样的内容，随着环境的变化一定会变，我们可以将数据源配置在容器里，然后以 JNDI（Java Naming and Directory Interface，Java 命名和目录接口）的方式获取数据源。所以说在 Java 系统里不缺配置的手段，只是配置起来简单一些或者复杂一些而已。</p><!-- [[[read_end]]] -->\n<p>但对大部分开发者来说，更熟悉的方式应该是将需要变动的内容作为配置项抽象出来，随后将其写在一个或几个配置文件里，遇到不同的环境就选择加载不同的配置文件。通常相关功能会沉淀到开发框架里，由框架来提供这些基础的能力，开发者自己并不需要太操心。如果是个单体应用，只有一个大集群，用这个方式来管理配置还好；但到了微服务的时代，一个分布式系统涉及几十个、上百个甚至上千个微服务，每个微服务还有多个实例，这么多配置文件的管理就变成了难题，就算用 Puppet 集中管理勉强可以过得去，但新问题又接踵而至。</p>\n<p>修改配置文件后，很多情况下需要重启应用才能让配置生效；但我们又希望配置变更能快速生效——不要重启就能生效，而且能快速应用到整个集群，这就需要配置变更推送。例如，用 Zookeeper 来管理配置，客户端监听某个节点的变化，在配置变更时 Zookeeper 能主动将变更推送过来，客户端在收到变更信息后再做对应的处理。</p>\n<p>此外，在一些应用场景中，配置项的变更还不能只是简单地把值改了。谁能修改配置需要有统一的权限管理，而改变配置这个动作本身也需要留下痕迹，可供追踪审计。再进一步，有些配置项涉及敏感信息，这些敏感信息需要按照指定的加密算法进行加密保存。诸如此类的附加功能，在金融等领域还是比较常见的。这种情况下，普通的配置文件很难满足我们的业务要求，有个专门的配置中心会更加方便。</p>\n<p>综合上述情况，目前我们经常使用的配置方法有如下几种：<strong>环境变量</strong>、<strong>系统参数</strong>、<strong>配置文件</strong>和<strong>配置中心</strong>。在当下的微服务系统中，使用配置中心的方式往往是更合适的选择。</p>\n<h3 id=\"nav_point_220\">14.1.2　基于 Spring Cloud Config Server 的配置中心</h3>\n<p>Spring Cloud Config 是 Spring Cloud 中专门用来提供配置管理解决方案的组件，同时提供了服务端与客户端的支持。在服务端方面，它提供了 Spring Cloud Config Server 作为配置中心（14.1.3 节会讲 Spring Cloud Config Client），只需一个 <code>@EnableConfigServer</code> 注解就能开启，通过 <code>HTTP</code> 接口向客户端提供配置信息，可以实现应用、Profile 和标签的多重组合，而且其背后支持多种不同的存储后端，具体如表 14-1 所示。</p>\n<p><strong>表 14-1　Spring Cloud Config Server 支持的常用存储后端</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>存储后端</p></th>\n<th><p>说明</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>Git</p></td>\n<td><p>默认的后端存储方式，既能支持本地 Git 仓库，也可以支持 SSH 和 HTTPS 等方式</p></td>\n</tr>\n<tr>\n<td><p>JDBC</p></td>\n<td><p>在关系型数据库中存储配置，在 Spring JDBC 的支持下，通过几张表就能实现配置的管理了</p></td>\n</tr>\n<tr>\n<td><p>Redis</p></td>\n<td><p>在 Redis 中存储配置，使用的数据结构是 Redis 的散列表，其背后的各种操作是通过 Spring Data Redis 来实现的</p></td>\n</tr>\n<tr>\n<td><p>文件系统</p></td>\n<td><p>直接在某个本地目录中存储配置，适合在简单的场景中，例如本地测试</p></td>\n</tr>\n<tr>\n<td><p>Vault</p></td>\n<td><p>当存储的内容为敏感信息时，可以考虑将其存储在 HashiCorp Vault 中</p></td>\n</tr>\n</tbody>\n</table>\n<p>接下来，让我们通过实际的例子来看看 Spring Cloud Config Server 的具体使用方式，以及如何通过它来提供配置管理服务，在例子中我们会使用目前比较基础的 Git 来存储配置。</p>\n<blockquote>\n<p><strong>需求描述</strong>　奶茶店时不时要搞一些促销活动，例如全单打折，不同的门店还可以有不同的折扣。这种需求当然可以通过在数据库里增加一张活动折扣表来实现，但我们是不是也可以把折扣视为一种配置呢？不如先搞个配置中心，把这些“配置项”集中管理起来吧！</p>\n</blockquote>\n<ol>\n<li><p><strong>搭建基于 Git 的配置中心服务</strong></p>\n<p>我们可以通过 Spring Initializr 来生成独立的 Spring Cloud Config Server 项目，只需勾选 Config Server（Spring Cloud Config）一项依赖就行了，其他信息根据自己的情况填写即可。假设我们项目的 ArtifactId 为 config-server，我们可以在主程序 <code>ConfigServerApplication</code> 上加上 <code>@EnableConfigServer</code> 注解，就像代码示例 14-1 那样。<span class=\"comment-number\">1</span></p>\n<blockquote>\n<p><strong>代码示例 14-1</strong>　增加了 Spring Cloud Config Server 注解的类</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootApplication\n@EnableConfigServer\npublic class ConfigServerApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ConfigServerApplication.class, args);\n    }\n}</code></pre>\n<p>随后，在配置文件中做些调整，类似代码示例 14-2。我们指定了 Spring 应用名，HTTP 服务监听 <code>8888</code> 端口，最重要的是指定了 Git 服务的 URI 地址，此处使用了 <code>file://</code> 本地目录，大家也可以用 <code>ssh://</code> 或者 <code>https://</code> 等前缀指定不同的地址。</p>\n<blockquote>\n<p><strong>代码示例 14-2</strong>　配置中心服务对应的 <code>application.properties</code> 文件</p>\n</blockquote>\n<pre class=\"code-rows\"><code>spring.application.name=config-server\n\nserver.port=8888\nspring.cloud.config.server.git.uri=file://$/Codes/configs</code></pre>\n<p>在启动服务前，需要先初始化一下本地的 Git 仓库，如果你用的是远程仓库，可以设置对应的 URI 和登录信息。<code>$</code> 是一个系统变量，会解析为当前运行用户的用户目录，在 Linux 或 macOS 这样的系统里，类似 <code>~</code> 指代的目录。在这个目录中用 <code>git</code> 命令初始化仓库，再添加一个配置文件提交即可：</p>\n<pre class=\"code-rows\"><code>▸ mkdir -p ~/Codes/configs\n▸ cd ~/Codes/configs\n▸ git init .\n▸ echo \"binarytea.discount=100\" &gt; application.properties\n▸ git add application.properties\n▸ git commit -m \"add a default discount.\"</code></pre>\n<p>如果是 Windows 系统，可能会缺少一些命令，我们可以自己创建一个目录，用 Git for Windows 或者 Tortoise Git 等工具完成初始化，随后编辑 <code>application.properties</code> 文件再提交。</p>\n<p>一切准备就绪之后，运行 <code>ConfigServerApplication</code> 类启动程序，我们就获得了一个基于 Git 后端存储、监听 <code>8888</code> 端口的 Spring Cloud Config Server。在浏览器中访问 http://localhost:8888/application/ default/ 可以看到类似图 14-1 的输出，这是 JSON 格式的，后续我们会看到如何获取 YAML 和 Properties 格式的配置项。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00795.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 14-1　在浏览器中访问默认的配置项</strong></p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>配置的获取方式</strong></p>\n<p>Spring Cloud Config Server 对外提供了一系列 <code>REST</code> 接口，方便大家获取指定应用的参数，过程中需要传递三个重要参数：</p>\n<ul>\n<li>应用名，每个应用的参数都是分开存储的，这个名字就是各自的 <code>spring.application.name</code>；</li>\n<li>Profile，同一应用不同 Profile 的配置也是分开的，可以对默认的配置进行覆盖；</li>\n<li>标签（label），这是 Git 的标签，之前默认是 <code>master</code>，现在改成了 <code>main</code>，如果找不到 <code>main</code> 分支，则会降级使用 <code>master</code> 分支。</li>\n</ul>\n<p>配置中心对外提供的都是 <code>GET</code> 接口，资源的 URI 组成非常灵活，有很多种方式，具体如表 14-2 所示。如果使用 Spring Cloud Config Client 来获取配置，我们根本就不用操心这些 URI 具体怎么用。但如果是自己要用，那还是需要了解一下。</p>\n<p><strong>表 14-2　获取配置的 HTTP 资源 URI</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>URI</th><th>资源格式</th><th>说明</th></tr><tr><td><code>/{ 应用名 }/[/{ 标签 }]</code></td><td>JSON</td><td>最后那部分 <code>/{ 标签 }</code> 是可选的</td></tr><tr><td><code>/{ 应用名 }-.yml</code></td><td>YAML</td><td>各项都是必需的，就算没有 Profile，也得写一个</td></tr><tr><td><code>/{ 应用名 }-.properties</code></td><td>Properties</td><td>同上</td></tr><tr><td><code>/{ 标签 }/{ 应用名 }-.yml</code></td><td>YAML</td><td>各项都是必需的，就算没有标签，也得写一个</td></tr><tr><td><code>/{ 标签 }/{ 应用名 }-.properties</code></td><td>Properties</td><td>同上</td></tr></table>\n\n<p>我们在 4.3.2 节里介绍了 Spring Boot 项目配置文件的相关细节，在 Spring Cloud Config Server 使用的本地目录或者 Git 里，存储配置的方式也是类似的，用 <code>{ 应用名 }.properties</code> 或 <code>{ 应用名 }-.properties</code> 的文件来保存配置（<code>.yml</code> 文件的命名方式也是类似的）。各应用间公共的配置被存在名为 <code>application</code> 的应用下，也就是放在 <code>application.properties</code> 或 <code>application-.properties</code> 里。</p>\n<p>不同文件里的配置，在获取时会按照下面的优先级排列，<code>{ 应用名 }-.properties</code> 的优先级最高。这里用的是 <code>.properties</code> 后缀，<code>.yml</code> 也是一样的：</p>\n<p>(1) <code>{ 应用名 }-.properties</code></p>\n<p>(2) <code>{ 应用名 }.properties</code></p>\n<p>(3) <code>application-.properties</code></p>\n<p>(4) <code>application.properties</code></p>\n<p>为了帮助大家更好地理解配置的获取方式，让我们通过二进制奶茶店的例子来做个演示。</p>\n<blockquote>\n<p><strong>需求描述</strong>　二进制奶茶店会新开一些分店，在正式开业前期，这些店有的会暂不对外开放，有的会缩短营业时间，例如，新店试营业期间只在 9:00~19:30 营业，还能给些折扣。这些配置原先放在 <code>application.properties</code> 里，现在请考虑将它们挪到配置中心里。</p>\n</blockquote>\n<p>需求中提到的营业时间其实就是之前的 <code>binarytea.ready</code> 和 <code>binarytea.open-hours</code> 这两个参数：</p>\n<pre class=\"code-rows\"><code>binarytea.ready=true\nbinarytea.open-hours=8:30-22:00</code></pre>\n<p>我们在 <code>~/Codes/configs</code> 目录中分别编辑 <code>application.properties</code>、<code>binarytea.properties</code> 和 <code>binarytea-trial.properties</code> 三个文件并提交至 Git 仓库，它们分别代表了应用程序配置的公共默认配置、BinaryTea 项目的默认 Profile 配置和 <code>trial</code> 试营业 Profile 配置。三个配置文件的内容请见代码示例 14-3。</p>\n<blockquote>\n<p><strong>代码示例 14-3</strong>　包含了门店营业时间的几个配置文件</p>\n</blockquote>\n<pre class=\"code-rows\"><code># application.properties\nbinarytea.ready=false\nbinarytea.open-hours=8:30-22:00\nbinarytea.discount=100\n\n# binarytea.properties\nbinarytea.ready=true\nbinarytea.open-hours=9:00-21:00\n\n# binarytea-trial.properties\nbinarytea.open-hours=9:30-19:30\nbinarytea.discount=80</code></pre>\n<p>我们可以用 curl 命令来访问配置中心，先获取 BinaryTea 项目的默认配置。命令类似下面这样，其中的 <code>-default</code> 是随便写的，不存在的 Profile 会加载默认的内容，<code>order.discount</code> 是从 <code>application.properties</code> 获取的，而另两个则是从 <code>binarytea.properties</code> 获取的：</p>\n<pre class=\"code-rows\"><code>▸ curl http://localhost:8888/binarytea-default.yml\nbinarytea:\n  ready: 'true'\n  open-hours: 9:00-21:00\n  discount: '100'</code></pre>\n<p>上面演示的是获取 YAML 格式的内容，接下来换成 Properties，我们来获取试营业的配置。其中的 <code>order.discount</code> 和 <code>binarytea.open-hours</code> 是从 <code>binarytea-trial.properties</code> 获取的，<code>binarytea.ready</code> 则是从 <code>binarytea.properties</code> 获取的。</p>\n<pre class=\"code-rows\"><code>▸ curl http://localhost:8888/binarytea-trial.properties\nbinarytea.ready: true\nbinarytea.open-hours: 9:30-19:30\nbinarytea.discount: 80</code></pre>\n<p>Spring Cloud Config Server 本质上也是一个服务。既然是服务，那一样也可以注册到服务的注册中心里，然后通过注册中心实现配置服务的发现。使用上一章介绍的方法，就能轻松地完成注册，稍后我们会在 14.1.3 中看到如何从注册中心找到配置中心。此外，既然是 HTTP 服务，那我们也可以用 Spring Security 来对这些 URL 进行必要的防护。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>加密保护配置项</strong></p>\n<p>类似我们示例中的配置项都是可以明文保存、即使泄露了也不会造成太大影响的内容；但是有些配置却属于敏感信息，以明文的形式保存在配置文件里不安全，这类配置包括但不限于账户、密码等信息。试想一下，我们把生产数据库的用户名和密码保存在配置文件里，而这些配置文件又被提交到了 Git 上，随后有权访问该仓库的人就都看到了这些密码，后果不堪设想。</p>\n<p>作为配置中心，Spring Cloud Config Server 当然不会对这么常见的问题视而不见。它提供了配置项加密功能：可以加密存储我们的配置项，在返回前进行解密；也可以直接为客户端提供密文配置项，让客户端自行解密。但考虑到让客户端解密需要将解密用到的密钥分发出去，建议还是选择前者。</p>\n<p>要加密配置项，第一步自然是配置加密用的密钥，Spring Cloud Config Server 同时支持对称和非对称加密算法，两种加密的配置方式稍有不同。对称密钥的配置相对简单，只需要一个 <code>encrypt.key</code> 配置项就能搞定。例如，在 <code>application.properties</code> 中增加如下配置：</p>\n<pre class=\"code-rows\"><code>encrypt.key=binarytea</code></pre>\n<p>在运行 Spring Cloud Config Server 程序后，通过 <code>/encrypt</code> 和 <code>/decrypt</code> 这两个 URL 可以进行简单的加解密。用 curl 命令来做个演示，大概就是下面这样：</p>\n<pre class=\"code-rows\"><code>▸ curl http://localhost:8888/encrypt/status\n{\"status\":\"OK\"}\n\n▸ curl http://localhost:8888/encrypt -s -d password\n0e796a32ff53ad9d994c43cea5ebc7f9dd45e242a4144d21420a21474f9d0770\n\n▸ curl http://localhost:8888/decrypt -s -d 0e796a32ff53ad9d994c43cea5ebc7f9dd45e242a4144d21420a21474f9d0770\npassword</code></pre>\n<p>如果后续在配置仓库中要保存加密后的密文，可以在值前增加 <code></code> 前缀，例如：</p>\n<pre class=\"code-rows\"><code>password=0e796a32ff53ad9d994c43cea5ebc7f9dd45e242a4144d21420a21474f9d0770</code></pre>\n<p>如果觉得直接在工程的 <code>application.properties</code> 文件中写入秘钥明文 <code>encrypt.key</code> 不保险，也可以选择把它放在 <code>ENCRYPT_KEY</code> 环境变量里——但两者本质上是一样的。可以根据实际情况选择，毕竟总有一个地方要配置秘钥明文，而这个秘钥你有时还不得不给别人，因为他们可能要自己加密些东西。这时，选用非对称加密算法也许更合适，但它的配置就会复杂一些，涉及不少配置项，具体如表 14-3 所示。</p>\n<p><strong>表 14-3　非对称加密涉及的配置项</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>配置项</th><th>说明</th></tr><tr><td><code>encrypt.key-store.location</code></td><td>密钥库文件的位置，可以是 CLASSPATH</td></tr><tr><td><code>encrypt.key-store.password</code></td><td>密钥库文件的密码，也就是打开密钥库的密码</td></tr><tr><td><code>encrypt.key-store.alias</code></td><td>密钥对的别名</td></tr><tr><td><code>encrypt.key-store.type</code></td><td>密钥库文件的类型，例如 JKS 和 PKCS12</td></tr><tr><td><code>encrypt.key-store.secret</code></td><td>获取特定别名密钥的密码</td></tr></table>\n\n<p>我们可以通过 JDK 自带的 keytool 工具来生成非对称密钥对，并将它保存到 JKS 文件里。keytool 的命令行格式大致如下：</p>\n<pre class=\"code-rows\"><code>keytool -genkeypair -alias 别名 -keyalg 算法 -keysize 长度 \\\n        -keystore 文件名 -storepass 密钥库密码 -keypass 密钥密码</code></pre>\n<p>例如，我们可以用下面的命令来生成一对 2048 位的 RSA 密钥对，保存到 server.jks 里。输入命令后，会有些交互的提示，补充一些信息。演示的两个密码都是 <code>binarytea</code>，可以考虑用一样的，但在生产中请谨慎设置：</p>\n<pre class=\"code-rows\"><code>▸ keytool -genkeypair -alias binarytea -keyalg RSA -keysize 2048 \\\n           -keystore server.jks -storepass binarytea -keypass binarytea</code></pre>\n<p>密钥对中的公钥会被用来加密明文，私钥则用来解密。可以考虑将公钥分发给大家，让大家分别加密自己的敏感配置，而在 Spring Cloud Config Server 的服务端部署私钥，对这几台服务器做加固即可。</p>\n<p>假设我们将 server.jks 文件放在工程的 src/resources 目录里，也就是将它放在 CLASSPATH 中，在 <code>application.properties</code> 中注释掉对称密钥的配置，再做下面这样的配置：</p>\n<pre class=\"code-rows\"><code># 对称加密用的密钥\n# encrypt.key=binarytea\n\n# 非对称加密用的密钥库\nencrypt.key-store.location=classpath:/server.jks\nencrypt.key-store.password=binarytea\nencrypt.key-store.alias=binarytea\nencrypt.key-store.type=jks</code></pre>\n<p>重新运行我们的配置服务器，同样使用 curl 命令来加密 <code>password</code> 字符串，效果大概是下面这样的：</p>\n<pre class=\"code-rows\"><code>▸ curl http://localhost:8888/encrypt/status\n{\"status\":\"OK\"}\n\n▸ curl http://localhost:8888/encrypt -s -d password\nAQB/duN0R8Dbsi6VrNOOnoAW1x/ge/0Y/b7P0WqRt/CsYNItRNl68Tu4ah/6Cfzx5KJaIlYi41XriBHbuI8xMELU5KpYjYY3YLbUx/\n90XMAj96hQwiieqF6uC4suiJuzlQU6hs29BI78LCVeMps6mT0VcqkDfB+bBvy7mrpzh7NdVElmz3rq3ZhlH7hjN9A3qoWcuNKXkCeA\nHghakIRnBWrCFBJEsrwt4sOomIkKg29Ej7+rscv4EhxKMnCFB+Gb0wmmQ4wwQoOi0+uO+UnDyar71+vhhpxyi1hxIp8VFC/A5s/\nLqTKkdv/MvzRXTSXm1eqWXgUn5DUXBP3Dm5z2E3riG8q6cY6gPhzV9wS73Y549vQs758p1qyE2cRRM+hOKZo=\n\n▸ curl http://localhost:8888/decrypt -s -d AQB/duN0R8Dbsi6VrNOOnoAW1x/ge/0Y/b7P0WqRt/CsYNItRNl68Tu4ah/\n6Cfzx5KJaIlYi41XriBHbuI8xMELU5KpYjYY3YLbUx/90XMAj96hQwiieqF6uC4suiJuzlQU6hs29BI78LCVeMps6mT0VcqkDfB+bBvy\n7mrpzh7NdVElmz3rq3ZhlH7hjN9A3qoWcuNKXkCeAHghakIRnBWrCFBJEsrwt4sOomIkKg29Ej7+rscv4EhxKMnCFB+Gb0wmmQ4wwQo\nOi0+uO+UnDyar71+vhhpxyi1hxIp8VFC/A5s/LqTKkdv/MvzRXTSXm1eqWXgUn5DUXBP3Dm5z2E3riG8q6cY6gPhzV9wS73Y549vQs\n758p1qyE2cRRM+hOKZo=\npassword</code></pre>\n<p>我们可以看到密文的样式与对称的方式差别很大。</p>\n<p>回到我们之前的 BinaryTea 工程里，<code>application.properties</code> 文件中配置过 <code>spring.security.user.password</code> 和 <code>jwt.secret</code>，这就属于需要保护的敏感信息，再加上 <code>spring.security.user.name</code>，我们可以将它们搬到 Git 里的 <code>binarytea.properties</code> 文件中。假设用的是上面的对称密钥 <code>encrypt.key=binarytea</code>，那现在这个文件的内容大概会是下面这样的：</p>\n<pre class=\"code-rows\"><code>binarytea.ready=true\nbinarytea.open-hours=9:00-21:00\nspring.security.user.name=binarytea\nspring.security.user.password=0e687280ab9ba90be5ba59d28280b502d2b4169355e6be78a997cbd7b6043f24\njwt.secret=e6492d2828b20f613de2b006d216d90666d84172a0fd856e615902c0e9ff8f775488d8c6e1dc5771295981\nc5f84cfad8c8ca94aacbc62790ebd4c3589f4921ef36c6f37d812e3adab903200971a5ae2ba213004fdb19ec2334eb6fb241b98d2\n0d126fd8fff03cb0dbb23ea0e593ab89c</code></pre>\n<p>这里需要特别说明的是 <code>jwt.secret</code> 的明文加密，如果使用 curl 命令会稍有不同。由于其中有 <code>=</code>，可以通过 <code>Content-Type: text/plain</code> 头指定请求的内容格式，用 <code>--data-raw</code> 来提供内容：</p>\n<pre class=\"code-rows\"><code>▸ curl http://localhost:8888/encrypt -H \"Content-Type: text/plain\" -s --data-raw gR6cytlUlgMfVh08nLFZf8h\nMk4mdJDX5rWBVlsCbKvRlWcLwNRU6+rIPcLx21x191kJgP8udtoZuHt5yUDWtgg==\n\ne6492d2828b20f613de2b006d216d90666d84172a0fd856e615902c0e9ff8f775488d8c6e1dc5771295981c5f84cfad8c8ca94aac\nbc62790ebd4c3589f4921ef36c6f37d812e3adab903200971a5ae2ba213004fdb19ec2334eb6fb241b98d20d126fd8fff03cb0dbb\n23ea0e593ab89c</code></pre>\n<p>最后，我们可以用 curl 命令或者浏览器再来确认一下，加密保存的信息是否可以正常读取，例如加载 BinaryTea 工程的 YAML 格式配置：</p>\n<pre class=\"code-rows\"><code>▸ curl http://localhost:8888/binarytea-default.yml\nbinarytea:\n  ready: 'true'\n  open-hours: 9:00-21:00\n  discount: '100'\nspring:\n  security:\n    user:\n      name: binarytea\n      password: showmethemoney\njwt:\n  secret: gR6cytlUlgMfVh08nLFZf8hMk4mdJDX5rWBVlsCbKvRlWcLwNRU6+rIPcLx21x191kJgP8udtoZuHt5yUDWtgg==</code></pre>\n<blockquote>\n<p><strong>茶歇时间：加解密绕不开的 JCE</strong></p>\n<p>在处理加解密相关的问题时，多少总会遇到一些与 JCE（Java Cryptography Extension）相关的问题。很多文章都会告诉你，默认安装的 JDK 里需要打些补丁才能使用更高位数的密钥，所以需要从 Oracle 的网站上下载 JDK 对应版本的“Java Cryptography Extension（JCE）Unlimited Strength Jurisdiction Policy Files”，例如，用于 JDK 6 的 jce_policy-6.zip。解压后将 local_policy.jar 和 US_export_policy.jar 文件复制到 $JAVA_HOME/jre/lib/security 目录，以便开启对应的支持。</p>\n<p>那大家有没有想过，为什么要多做这么一个步骤，为什么 Java 9 之后又不需要了呢？这还得从美国限制加密相关技术和设备出口的法律说起。自 1992 年起，美国就有相关的限制，例如，只有在北美才能使用支持 1024 或更大位数 RSA 公钥的软件，更有甚者，要求软件厂商必须在软件里添加“密钥恢复”后门，才能出口。但这些限制到了 2000 年后逐步放宽了，根据 JDK-8170157<span class=\"comment-number\">2</span> 的描述，从 6u181、7u171 和 8u161 版本后，JDK 6、JDK 7 和 JDK 8 都不再需要额外覆盖 JCE 文件，当然 JDK 9 以后的也是如此。</p>\n<p>在这些新版本的 JDK 里，可以通过调整安全参数 <code>crypto.policy</code> 的值来改变默认策略，例如将其设置为 <code>unlimited</code>，就是支持高强度密钥。设置方法如下：<code>Security.setProperty(\"crypto.policy\", \"unlimited\");</code>。当然，新版本默认使用的就是 <code>unlimited</code>，所以我们在前面的例子里没有执行任何操作。如果遇到了老版本的 JDK，那不要忘了更换 JCE 文件。</p>\n</blockquote>\n</li>\n</ol>\n\n\n<h3 id=\"nav_point_221\">14.1.3　通过 Spring Cloud Config Client 访问配置</h3>\n<p>聊完了 Spring Cloud Config Server，接下来就该聊客户端了。原先配置在客户端的 <code>application.properties</code> 里的大部分配置都能挪到配置中心里集中管理，怎么让我们的程序从配置中心获取配置呢？</p>\n<p>首先，不管我们使用何种方式，都需要先在 pom.xml 中引入所需的依赖 <code>spring-cloud-starter-config</code>：</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<p>其次，要让客户端连接到 Spring Cloud Config Server，以便能够获取想要的配置信息。这时有两种方式：第一种是直接配置目标服务端地址；第二种是使用服务发现，从注册中心找到目标服务端地址。下面让我们分别看看这两种方式。</p>\n<ol>\n<li><p><strong>直连 Spring Cloud Config Server</strong></p>\n<p>为了告诉 Spring 去配置中心加载配置，Spring Boot 2.4<span class=\"comment-number\">3</span> 前后有两种不同的方式，现在的默认方式是使用 <code>spring.config.import</code>，格式是这样的 <span class=\"comment-number\">4</span>：</p>\n<pre class=\"code-rows\"><code>spring.config.import=[optional:]configserver:[服务端地址]</code></pre>\n<p>因为目前选择的是直连的方式，而 <code>spring.cloud.config.uri</code> 的默认值是 <code>http://localhost:8888</code>，所以这段配置默认会去连接这个地址上的 Spring Cloud Config Server。<code>optional:</code> 前缀则是告诉我们的程序如果连不上配置中心就用自己的本地配置；如果去掉这个前缀，连不上就直接报错，启动失败。目前我们用的配置中心就是这个地址，所以下面的这些配置效果都是一样的（都不带 <code>optional:</code> 的话也是对等的），推荐直接用第二种方式。</p>\n<pre class=\"code-rows\"><code># 方式1：用默认地址\nspring.config.import=optional:configserver:\n\n# 方式2：明确写出地址\nspring.config.import=optional:configserver:http://localhost:8888\n\n# 方式3：配置spring.cloud.config.uri\nspring.cloud.config.uri=http://localhost:8888\nspring.config.import=optional:configserver:</code></pre>\n<p>在连上配置中心后，Spring Cloud Config Client 会根据当前配置的应用名来加载配置，也就是使用 <code>spring.application.name</code> 配置，默认值是 <code>application</code>，像我们的配置文件里就把这个配置为 <code>binarytea</code>，所以会去加载对应的配置。</p>\n<p>如果你还在使用 Spring Boot 2.4 以前的版本，或者对 <code>bootstrap.properties</code> 或 <code>bootstrap.yml</code> 文件情有独钟，也可以继续使用 Bootstrap 方式。最简单的方法是在 pom.xml 中增加一个依赖，其中有一个标记类 <code>Marker</code>，Spring Cloud 在 CLASSPATH 中发现它时就会重新启动对 Bootstrap 的支持：</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<p>如果要深入探究的话，可以看看 <code>ConditionalOnBootstrapEnabled.OnBootstrapEnabledCondition</code> 这个条件类，它继承自 <code>AnyNestedCondition</code>，也就是其中包含的任意条件成立则整个条件判断成立。<code>OnBootstrapEnabledCondition</code> 中有三个判断：</p>\n<ul>\n<li>CLASSPATH 中存在 <code>org.springframework.cloud.bootstrap.marker.Marker</code>；</li>\n<li>存在 <code>spring.config.use-legacy-processing</code> 属性，且不为 <code>false</code>；</li>\n<li>存在 <code>spring.cloud.bootstrap.enabled</code> 属性，且不为 <code>false</code>。</li>\n</ul>\n<p>关于后两个判断里用到的属性，必须配置在环境变量、Java 系统属性或者命令行参数里，不能放在配置文件里。原因也很简单，它就是专门用来启用 Bootstrap 阶段的，这个阶段通常用来导入配置，特别是远程的配置，在此之前还没有读取配置文件，又怎么能加载到呢？</p>\n<p>说到 Bootstrap，Spring Cloud 的 Bootstrap 其实也就是多加载了一些配置类，打开 spring-cloud-context 的 <code>META-INF/spring.factories</code> 文件，可以看到类似下面的内容，其中描述了要加载的配置类。</p>\n<pre class=\"code-rows\"><code># Spring Cloud Bootstrap components\norg.springframework.cloud.bootstrap.BootstrapConfiguration=\\\norg.springframework.cloud.bootstrap.config.PropertySourceBootstrapConfiguration,\\\norg.springframework.cloud.bootstrap.encrypt.EncryptionBootstrapConfiguration,\\\norg.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration,\\\norg.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration</code></pre>\n<p>这时，可以在 <code>bootstrap.properties</code> 文件中配置应用名和 Spring Cloud Config Server 的信息，就像代码示例 14-4<span class=\"comment-number\">5</span> 那样。这时请记得去掉 <code>application.properties</code> 里的 <code>spring.config.import</code>。</p>\n<blockquote>\n<p><strong>代码示例 14-4</strong>　BinaryTea 工程中新增的 <code>bootstrap.properties</code> 文件</p>\n</blockquote>\n<pre class=\"code-rows\"><code>spring.application.name=binarytea\nspring.cloud.config.uri=http://localhost:8888</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>通过服务发现找到 Spring Cloud Config Server</strong></p>\n<p>假设我们的 Spring Cloud Config Server 程序使用 <code>config-server</code> 作为应用名注册到了 Zookeeper 上，那我们该怎么通过基于 Zookeeper 的服务发现机制来找到它呢？</p>\n<p>当然，第一步肯定是在项目中引入服务发现的依赖，例如之前一直在用的 <code>spring-cloud-starter-zookeeper-discovery</code>。第二步就是配置服务的注册中心地址，这里我们用的是 Zookeeper，所以就要配置 Zookeeper 的连接信息。最后一步是告诉 Spring Cloud Config Client，通过服务注册中心去发现配置中心。</p>\n<p>具体的配置代码如代码示例 14-5<span class=\"comment-number\">6</span> 所示，其中最重要的是 <code>spring.cloud.config.discovery.enabled</code> 开启了相关支持，它默认是 <code>false</code>；然后通过 <code>spring.cloud.config.discovery.service-id</code> 给出了 Spring Cloud Config Server 对应的服务名，它的默认值是 <code>configserver</code>，为了演示，我们故意在当中加了个 <code>-</code> 做区别。</p>\n<blockquote>\n<p><strong>代码示例 14-5</strong>　BinaryTea 工程中与发现配置中心有关的 <code>application.properties</code> 配置片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>spring.application.name=binarytea\n\nspring.cloud.zookeeper.connect-string=localhost:2181\n\nspring.config.import=configserver:\nspring.cloud.config.discovery.enabled=true\nspring.cloud.config.discovery.service-id=config-server</code></pre>\n<p>上面是目前推荐的使用 <code>spring.config.import</code> 的方式，如果想用传统的 Bootstrap 方式也是可以的。先用前文介绍的方法开启 Bootstrap 方式支持，随后将代码示例 14-5 中的配置去掉 <code>spring.config.import</code>，剩下的内容搬到 <code>bootstrap.properties</code> 中。</p>\n<blockquote>\n<p><strong>请注意</strong>　由于在 Bootstrap 阶段一些 Bean 已经声明过了，例如 <code>zookeeperDiscoveryProperties</code>，在后续正常启动阶段再次声明同 ID 的 Bean 时会抛出 <code>BeanDefinitionOverrideException</code> 异常。如果遇到类似的问题，可以根据错误提示信息，在 <code>bootstrap.properties</code> 文件中增加如下配置，开启 Bean 定义覆盖，这个配置从 Spring Boot 2.1 开始默认为 <code>false</code>：</p>\n<pre class=\"code-rows\"><code>spring.main.allow-bean-definition-overriding=true</code></pre>\n</blockquote>\n<p>除了上面提到的配置，Spring Cloud Config Client 还有一些其他配置，例如超时设置，表 14-4 中罗列了几个常用的配置。</p>\n<p><strong>表 14-4　Spring Cloud Config Client 的常用配置</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>配置项</th><th>默认值</th><th>说明</th></tr><tr><td><code>spring.cloud.config.enabled</code></td><td><code>true</code></td><td>是否开启 Spring Cloud Config 支持</td></tr><tr><td><code>spring.cloud.config.uri</code></td><td>http://localhost:8888</td><td>Spring Cloud Config Server 地址</td></tr><tr><td><code>spring.cloud.config.fail-fast</code></td><td><code>false</code></td><td>无法从服务端获取配置就快速失败</td></tr><tr><td><code>spring.cloud.config.username</code></td><td></td><td>用于 HTTP Basic 认证的用户名</td></tr><tr><td><code>spring.cloud.config.password</code></td><td></td><td>用于 HTTP Basic 认证的密码</td></tr><tr><td><code>spring.cloud.config.request-read-timeout</code></td><td><code>185000</code></td><td>读取配置时的超时时间，单位为毫秒</td></tr><tr><td><code>spring.cloud.config.request-connect-timeout</code></td><td><code>10000</code></td><td>连接的超时时间，单位为毫秒</td></tr><tr><td><code>spring.cloud.config.discovery.enabled</code></td><td><code>false</code></td><td>是否通过服务注册中心发现配置服务</td></tr><tr><td><code>spring.cloud.config.discovery.service-id</code></td><td><code>configserver</code></td><td>Spring Cloud Config Server 的服务名</td></tr></table>\n\n</li>\n</ol>\n\n\n\n\n","neighbors":{"left":{"article_title":"第 13 章 服务注册与发现(2)","id":740888},"right":{"article_title":"第 14 章 服务配置管理(2)","id":740890}},"comments":[]}