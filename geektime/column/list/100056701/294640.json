{"id":294640,"title":"24 | 替换策略：缓存满了怎么办？","content":"<p>你好，我是蒋德钧。</p><p>Redis缓存使用内存来保存数据，避免业务应用从后端数据库中读取数据，可以提升应用的响应速度。那么，如果我们把所有要访问的数据都放入缓存，是不是一个很好的设计选择呢？其实，这样做的性价比反而不高。</p><p>举个例子吧。MySQL中有1TB的数据，如果我们使用Redis把这1TB的数据都缓存起来，虽然应用都能在内存中访问数据了，但是，这样配置并不合理，因为性价比很低。一方面，1TB内存的价格大约是3.5万元，而1TB磁盘的价格大约是1000元。另一方面，数据访问都是有局部性的，也就是我们通常所说的“八二原理”，80%的请求实际只访问了20%的数据。所以，用1TB的内存做缓存，并没有必要。</p><p>为了保证较高的性价比，缓存的空间容量必然要小于后端数据库的数据总量。不过，内存大小毕竟有限，随着要缓存的数据量越来越大，有限的缓存空间不可避免地会被写满。此时，该怎么办呢？</p><p>解决这个问题就涉及到缓存系统的一个重要机制，即<strong>缓存数据的淘汰机制</strong>。简单来说，数据淘汰机制包括两步：第一，根据一定的策略，筛选出对应用访问来说“不重要”的数据；第二，将这些数据从缓存中删除，为新来的数据腾出空间，</p><p>这节课上，我就来和你聊聊缓存满了之后的数据淘汰机制。通常，我们也把它叫作缓存替换机制，同时还会讲到一系列选择淘汰数据的具体策略。了解了数据淘汰机制和相应策略，我们才可以选择合理的Redis配置，提高缓存命中率，提升应用的访问性能。</p><!-- [[[read_end]]] --><p>不过，在学习淘汰策略之前，我们首先要知道设置缓存容量的依据和方法。毕竟，在实际使用缓存时，我们需要决定用多大的空间来缓存数据。</p><h2>设置多大的缓存容量合适？</h2><p>缓存容量设置得是否合理，会直接影响到使用缓存的性价比。我们通常希望以最小的代价去获得最大的收益，所以，把昂贵的内存资源用在关键地方就非常重要了。</p><p>就像我刚才说的，实际应用中的数据访问是具有局部性的。下面有一张图，图里有红、蓝两条线，显示了不同比例数据贡献的访问量情况。蓝线代表了“八二原理”表示的数据局部性，而红线则表示在当前应用负载下，数据局部性的变化。</p><p>我们先看看蓝线。它表示的就是“八二原理”，有20%的数据贡献了80%的访问了，而剩余的数据虽然体量很大，但只贡献了20%的访问量。这80%的数据在访问量上就形成了一条长长的尾巴，我们也称为“长尾效应”。</p><p><img src=\"https://static001.geekbang.org/resource/image/98/e4/986ed247a4353524f387f0bbf76586e4.jpg?wh=2639*2081\" alt=\"\"></p><p>所以，如果按照“八二原理”来设置缓存空间容量，也就是把缓存空间容量设置为总数据量的20%的话，就有可能拦截到80%的访问。</p><p>为什么说是“有可能”呢？这是因为，“八二原理”是对大量实际应用的数据访问情况做了统计后，得出的一个统计学意义上的数据量和访问量的比例。具体到某一个应用来说，数据访问的规律会和具体的业务场景有关。对于最常被访问的20%的数据来说，它们贡献的访问量，既有可能超过80%，也有可能不到80%。</p><p>我们再通过一个电商商品的场景，来说明下“有可能”这件事儿。一方面，在商品促销时，热门商品的信息可能只占到总商品数据信息量的5%，而这些商品信息承载的可能是超过90%的访问请求。这时，我们只要缓存这5%的数据，就能获得很好的性能收益。另一方面，如果业务应用要对所有商品信息进行查询统计，这时候，即使按照“八二原理”缓存了20%的商品数据，也不能获得很好的访问性能，因为80%的数据仍然需要从后端数据库中获取。</p><p>接下来，我们再看看数据访问局部性示意图中的红线。近年来，有些研究人员专门对互联网应用（例如视频播放网站）中，用户请求访问内容的分布情况做过分析，得到了这张图中的红线。</p><p>在这条红线上，80%的数据贡献的访问量，超过了传统的长尾效应中80%数据能贡献的访问量。原因在于，用户的个性化需求越来越多，在一个业务应用中，不同用户访问的内容可能差别很大，所以，用户请求的数据和它们贡献的访问量比例，不再具备长尾效应中的“八二原理”分布特征了。也就是说，20%的数据可能贡献不了80%的访问，而剩余的80%数据反而贡献了更多的访问量，我们称之为重尾效应。</p><p>正是因为20%的数据不一定能贡献80%的访问量，我们不能简单地按照“总数据量的20%”来设置缓存最大空间容量。在实践过程中，我看到过的缓存容量占总数据量的比例，从5%到40%的都有。这个容量规划不能一概而论，是需要结合<strong>应用数据实际访问特征</strong>和<strong>成本开销</strong>来综合考虑的。</p><p>这其实也是我一直在和你分享的经验，系统的设计选择是一个权衡的过程：大容量缓存是能带来性能加速的收益，但是成本也会更高，而小容量缓存不一定就起不到加速访问的效果。一般来说，<strong>我会建议把缓存容量设置为总数据量的15%到30%，兼顾访问性能和内存空间开销</strong>。</p><p>对于Redis来说，一旦确定了缓存最大容量，比如4GB，你就可以使用下面这个命令来设定缓存的大小了：</p><pre><code>CONFIG SET maxmemory 4gb\n</code></pre><p>不过，<strong>缓存被写满是不可避免的</strong>。即使你精挑细选，确定了缓存容量，还是要面对缓存写满时的替换操作。缓存替换需要解决两个问题：决定淘汰哪些数据，如何处理那些被淘汰的数据。</p><p>接下来，我们就来学习下，Redis中的数据淘汰策略。</p><h2>Redis缓存有哪些淘汰策略？</h2><p>Redis 4.0之前一共实现了6种内存淘汰策略，在4.0之后，又增加了2种策略。我们可以按照是否会进行数据淘汰把它们分成两类：</p><ul>\n<li>不进行数据淘汰的策略，只有noeviction这一种。</li>\n<li>会进行淘汰的7种其他策略。</li>\n</ul><p>会进行淘汰的7种策略，我们可以再进一步根据淘汰候选数据集的范围把它们分成两类：</p><ul>\n<li>在设置了过期时间的数据中进行淘汰，包括volatile-random、volatile-ttl、volatile-lru、volatile-lfu（Redis  4.0后新增）四种。</li>\n<li>在所有数据范围内进行淘汰，包括allkeys-lru、allkeys-random、allkeys-lfu（Redis 4.0后新增）三种。</li>\n</ul><p>我把这8种策略的分类，画到了一张图里：</p><p><img src=\"https://static001.geekbang.org/resource/image/04/f6/04bdd13b760016ec3b30f4b02e133df6.jpg?wh=1757*765\" alt=\"\"></p><p>下面我就来具体解释下各个策略。</p><p>默认情况下，Redis在使用的内存空间超过maxmemory值时，并不会淘汰数据，也就是设定的<strong>noeviction策略</strong>。对应到Redis缓存，也就是指，一旦缓存被写满了，再有写请求来时，Redis不再提供服务，而是直接返回错误。Redis用作缓存时，实际的数据集通常都是大于缓存容量的，总会有新的数据要写入缓存，这个策略本身不淘汰数据，也就不会腾出新的缓存空间，我们不把它用在Redis缓存中。</p><p>我们再分析下volatile-random、volatile-ttl、volatile-lru和volatile-lfu这四种淘汰策略。它们筛选的候选数据范围，被限制在已经设置了过期时间的键值对上。也正因为此，即使缓存没有写满，这些数据如果过期了，也会被删除。</p><p>例如，我们使用EXPIRE命令对一批键值对设置了过期时间后，无论是这些键值对的过期时间是快到了，还是Redis的内存使用量达到了maxmemory阈值，Redis都会进一步按照volatile-ttl、volatile-random、volatile-lru、volatile-lfu这四种策略的具体筛选规则进行淘汰。</p><ul>\n<li>volatile-ttl在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除。</li>\n<li>volatile-random就像它的名称一样，在设置了过期时间的键值对中，进行随机删除。</li>\n<li>volatile-lru会使用LRU算法筛选设置了过期时间的键值对。</li>\n<li>volatile-lfu会使用LFU算法选择设置了过期时间的键值对。</li>\n</ul><p>可以看到，volatile-ttl和volatile-random筛选规则比较简单，而volatile-lru因为涉及了LRU算法，所以我会在分析allkeys-lru策略时再详细解释。volatile-lfu使用了LFU算法，我会在第27讲中具体解释，现在你只需要知道，它是在LRU算法的基础上，同时考虑了数据的访问时效性和数据的访问次数，可以看作是对淘汰策略的优化。</p><p>相对于volatile-ttl、volatile-random、volatile-lru、volatile-lfu这四种策略淘汰的是设置了过期时间的数据，allkeys-lru、allkeys-random、allkeys-lfu这三种淘汰策略的备选淘汰数据范围，就扩大到了所有键值对，无论这些键值对是否设置了过期时间。它们筛选数据进行淘汰的规则是：</p><ul>\n<li>allkeys-random策略，从所有键值对中随机选择并删除数据；</li>\n<li>allkeys-lru策略，使用LRU算法在所有数据中进行筛选。</li>\n<li>allkeys-lfu策略，使用LFU算法在所有数据中进行筛选。</li>\n</ul><p>这也就是说，如果一个键值对被删除策略选中了，即使它的过期时间还没到，也需要被删除。当然，如果它的过期时间到了但未被策略选中，同样也会被删除。</p><p>接下来，我们就看看volatile-lru和allkeys-lru策略都用到的LRU算法吧。LRU算法工作机制并不复杂，我们一起学习下。</p><p>LRU算法的全称是Least Recently Used，从名字上就可以看出，这是按照最近最少使用的原则来筛选数据，最不常用的数据会被筛选出来，而最近频繁使用的数据会留在缓存中。</p><p>那具体是怎么筛选的呢？LRU会把所有的数据组织成一个链表，链表的头和尾分别表示MRU端和LRU端，分别代表最近最常使用的数据和最近最不常用的数据。我们看一个例子。</p><p><img src=\"https://static001.geekbang.org/resource/image/02/y5/0201f85c84203300ae4085c60e955yy5.jpg?wh=1702*1678\" alt=\"\"></p><p>我们现在有数据6、3、9、20、5。如果数据20和3被先后访问，它们都会从现有的链表位置移到MRU端，而链表中在它们之前的数据则相应地往后移一位。因为，LRU算法选择删除数据时，都是从LRU端开始，所以把刚刚被访问的数据移到MRU端，就可以让它们尽可能地留在缓存中。</p><p>如果有一个新数据15要被写入缓存，但此时已经没有缓存空间了，也就是链表没有空余位置了，那么，LRU算法做两件事：</p><ol>\n<li>数据15是刚被访问的，所以它会被放到MRU端；</li>\n<li>算法把LRU端的数据5从缓存中删除，相应的链表中就没有数据5的记录了。</li>\n</ol><p>其实，LRU算法背后的想法非常朴素：它认为刚刚被访问的数据，肯定还会被再次访问，所以就把它放在MRU端；长久不访问的数据，肯定就不会再被访问了，所以就让它逐渐后移到LRU端，在缓存满时，就优先删除它。</p><p>不过，LRU算法在实际实现时，需要用链表管理所有的缓存数据，这会<strong>带来额外的空间开销</strong>。而且，当有数据被访问时，需要在链表上把该数据移动到MRU端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低Redis缓存性能。</p><p>所以，在Redis中，LRU算法被做了简化，以减轻数据淘汰对缓存性能的影响。具体来说，Redis默认会记录每个数据的最近一次访问的时间戳（由键值对数据结构RedisObject中的lru字段记录）。然后，Redis在决定淘汰的数据时，第一次会随机选出N个数据，把它们作为一个候选集合。接下来，Redis会比较这N个数据的lru字段，把lru字段值最小的数据从缓存中淘汰出去。</p><p>Redis提供了一个配置参数maxmemory-samples，这个参数就是Redis选出的数据个数N。例如，我们执行如下命令，可以让Redis选出100个数据作为候选数据集：</p><pre><code>CONFIG SET maxmemory-samples 100\n</code></pre><p>当需要再次淘汰数据时，Redis需要挑选数据进入第一次淘汰时创建的候选集合。这儿的挑选标准是：<strong>能进入候选集合的数据的lru字段值必须小于候选集合中最小的lru值</strong>。当有新数据进入候选数据集后，如果候选数据集中的数据个数达到了maxmemory-samples，Redis就把候选数据集中lru字段值最小的数据淘汰出去。</p><p>这样一来，Redis缓存不用为所有的数据维护一个大链表，也不用在每次数据访问时都移动链表项，提升了缓存的性能。</p><p>好了，到这里，我们就学完了除了使用LFU算法以外的5种缓存淘汰策略，我再给你三个使用建议。</p><ul>\n<li><strong>优先使用allkeys-lru策略</strong>。这样，可以充分利用LRU这一经典缓存算法的优势，把最近最常访问的数据留在缓存中，提升应用的访问性能。如果你的业务数据中有明显的冷热数据区分，我建议你使用allkeys-lru策略。</li>\n<li>如果业务应用中的数据访问频率相差不大，没有明显的冷热数据区分，建议使用allkeys-random策略，随机选择淘汰的数据就行。</li>\n<li><strong>如果你的业务中有置顶的需求</strong>，比如置顶新闻、置顶视频，那么，可以使用volatile-lru策略，同时不给这些置顶数据设置过期时间。这样一来，这些需要置顶的数据一直不会被删除，而其他数据会在过期时根据LRU规则进行筛选。</li>\n</ul><p>一旦被淘汰的数据被选定后，Redis怎么处理这些数据呢？这就要说到缓存替换时的具体操作了。</p><h2>如何处理被淘汰的数据？</h2><p>一般来说，一旦被淘汰的数据选定后，如果这个数据是干净数据，那么我们就直接删除；如果这个数据是脏数据，我们需要把它写回数据库，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/95/5e/953e48912yy9515abf9db588d447cc5e.jpg?wh=2024*1154\" alt=\"\"></p><p>那怎么判断一个数据到底是干净的还是脏的呢？</p><p>干净数据和脏数据的区别就在于，和最初从后端数据库里读取时的值相比，有没有被修改过。干净数据一直没有被修改，所以后端数据库里的数据也是最新值。在替换时，它可以被直接删除。</p><p>而脏数据就是曾经被修改过的，已经和后端数据库中保存的数据不一致了。此时，如果不把脏数据写回到数据库中，这个数据的最新值就丢失了，就会影响应用的正常使用。</p><p>这么一来，缓存替换既腾出了缓存空间，用来缓存新的数据，同时，将脏数据写回数据库，也保证了最新数据不会丢失。</p><p>不过，对于Redis来说，它决定了被淘汰的数据后，会把它们删除。即使淘汰的数据是脏数据，Redis也不会把它们写回数据库。所以，我们在使用Redis缓存时，如果数据被修改了，需要在数据修改时就将它写回数据库。否则，这个脏数据被淘汰时，会被Redis删除，而数据库里也没有最新的数据了。</p><h2>小结</h2><p>在这节课上，我围绕着“缓存满了该怎么办”这一问题，向你介绍了缓存替换时的数据淘汰策略，以及被淘汰数据的处理方法。</p><p>Redis 4.0版本以后一共提供了8种数据淘汰策略，从淘汰数据的候选集范围来看，我们有两种候选范围：一种是所有数据都是候选集，一种是设置了过期时间的数据是候选集。另外，无论是面向哪种候选数据集进行淘汰数据选择，我们都有三种策略，分别是随机选择，根据LRU算法选择，以及根据LFU算法选择。当然，当面向设置了过期时间的数据集选择淘汰数据时，我们还可以根据数据离过期时间的远近来决定。</p><p>一般来说，缓存系统对于选定的被淘汰数据，会根据其是干净数据还是脏数据，选择直接删除还是写回数据库。但是，在Redis中，被淘汰数据无论干净与否都会被删除，所以，这是我们在使用Redis缓存时要特别注意的：当数据修改成为脏数据时，需要在数据库中也把数据修改过来。</p><p>选择哪种缓存策略是值得我们多加琢磨的，它在筛选数据方面是否能筛选出可能被再次访问的数据，直接决定了缓存效率的高与低。</p><p>很简单的一个对比，如果我们使用随机策略，刚筛选出来的要被删除的数据可能正好又被访问了，此时应用就只能花费几毫秒从数据库中读取数据了。而如果使用LRU策略，被筛选出来的数据往往是经过时间验证了，如果在一段时间内一直没有访问，本身被再次访问的概率也很低了。</p><p>所以，我给你的建议是，先根据是否有始终会被频繁访问的数据（例如置顶消息），来选择淘汰数据的候选集，也就是决定是针对所有数据进行淘汰，还是针对设置了过期时间的数据进行淘汰。候选数据集范围选定后，建议优先使用LRU算法，也就是，allkeys-lru或volatile-lru策略。</p><p>当然，设置缓存容量的大小也很重要，我的建议是：结合实际应用的数据总量、热数据的体量，以及成本预算，把缓存空间大小设置在总数据量的15%到30%这个区间就可以。</p><h2>每课一问</h2><p>按照惯例，我给你提一个小问题。这节课，我向你介绍了Redis缓存在应对脏数据时，需要在数据修改的同时，也把它写回数据库，针对我们上节课介绍的缓存读写模式：只读缓存，以及读写缓存中的两种写回策略，请你思考下，Redis缓存对应哪一种或哪几种模式？</p><p>欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得今天的内容对你有所帮助，也欢迎你分享给你的朋友或/同事。我们下节课见。</p>","comments":[{"had_liked":false,"id":252682,"user_name":"Kaito","can_delete":false,"product_type":"c1","uid":1020042,"ip_address":"","ucode":"79775FA35A95F2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","comment_is_top":false,"comment_ctime":1602432211,"is_pvip":true,"discussion_count":34,"race_medal":0,"score":"1066754321619","product_id":100056701,"comment_content":"Redis在用作缓存时，使用只读缓存或读写缓存的哪种模式？<br><br>1、只读缓存模式：每次修改直接写入后端数据库，如果Redis缓存不命中，则什么都不用操作，如果Redis缓存命中，则删除缓存中的数据，待下次读取时从后端数据库中加载最新值到缓存中。<br><br>2、读写缓存模式+同步直写策略：由于Redis在淘汰数据时，直接在内部删除键值对，外部无法介入处理脏数据写回数据库，所以使用Redis作读写缓存时，只能采用同步直写策略，修改缓存的同时也要写入到后端数据库中，从而保证修改操作不被丢失。但这种方案在并发场景下会导致数据库和缓存的不一致，需要在特定业务场景下或者配合分布式锁使用。<br><br>当一个系统引入缓存时，需要面临最大的问题就是，如何保证缓存和后端数据库的一致性问题，最常见的3个解决方案分别是Cache Aside、Read&#47;Write Throught和Write Back缓存更新策略。<br><br>1、Cache Aside策略：就是文章所讲的只读缓存模式。读操作命中缓存直接返回，否则从后端数据库加载到缓存再返回。写操作直接更新数据库，然后删除缓存。这种策略的优点是一切以后端数据库为准，可以保证缓存和数据库的一致性。缺点是写操作会让缓存失效，再次读取时需要从数据库中加载。这种策略是我们在开发软件时最常用的，在使用Memcached或Redis时一般都采用这种方案。<br><br>2、Read&#47;Write Throught策略：应用层读写只需要操作缓存，不需要关心后端数据库。应用层在操作缓存时，缓存层会自动从数据库中加载或写回到数据库中，这种策略的优点是，对于应用层的使用非常友好，只需要操作缓存即可，缺点是需要缓存层支持和后端数据库的联动。<br><br>3、Write Back策略：类似于文章所讲的读写缓存模式+异步写回策略。写操作只写缓存，比较简单。而读操作如果命中缓存则直接返回，否则需要从数据库中加载到缓存中，在加载之前，如果缓存已满，则先把需要淘汰的缓存数据写回到后端数据库中，再把对应的数据放入到缓存中。这种策略的优点是，写操作飞快（只写缓存），缺点是如果数据还未来得及写入后端数据库，系统发生异常会导致缓存和数据库的不一致。这种策略经常使用在操作系统Page Cache中，或者应对大量写操作的数据库引擎中。<br><br>除了以上提到的缓存和数据库的更新策略之外，还有一个问题就是操作缓存或数据库发生异常时如何处理？例如缓存操作成功，数据库操作失败，或者反过来，还是有可能会产生不一致的情况。<br><br>比较简单的解决方案是，根据业务设计好更新缓存和数据库的先后顺序来降低影响，或者给缓存设置较短的有效期来降低不一致的时间。如果需要严格保证缓存和数据库的一致性，即保证两者操作的原子性，这就涉及到分布式事务问题了，常见的解决方案就是我们经常听到的两阶段提交（2PC）、三阶段提交（3PC）、TCC、消息队列等方式来保证了，方案也会比较复杂，一般用在对于一致性要求较高的业务场景中。","like_count":249,"discussions":[{"author":{"id":2172420,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/r2nR7Zkl5RP7LobsNKJ6wmmtyXrh4alNSAOldx1y1PSeFB1J2I14HE4I0BCgicPhubIOibPZAENzEpHEWTFjMNqg/132","nickname":"董董","note":"","ucode":"C222E275545158","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325583,"discussion_content":"读写缓存模式+异步写回策略有点类似于mysql的change buffer","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1605357724,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1966533,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/01/c5/b48d25da.jpg","nickname":"cake","note":"","ucode":"55A7FC6CC1204C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2172420,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/r2nR7Zkl5RP7LobsNKJ6wmmtyXrh4alNSAOldx1y1PSeFB1J2I14HE4I0BCgicPhubIOibPZAENzEpHEWTFjMNqg/132","nickname":"董董","note":"","ucode":"C222E275545158","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388612,"discussion_content":"有关系吗？难道最贴切的不是 cache写回策略嘛？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628847710,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":325583,"ip_address":""},"score":388612,"extra":""}]},{"author":{"id":1073125,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","nickname":"范闲","note":"","ucode":"F21FD7DF6BA53C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":314447,"discussion_content":"Cache Side算是用的最多的了。业务逻辑可以直接实现，其他的需要魔改缓存系统或者更改设计方案，引入更高的复杂度。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1603157676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1284672,"avatar":"https://static001.geekbang.org/account/avatar/00/13/9a/40/b746dc09.jpg","nickname":"twogozi","note":"","ucode":"C272B0745EF514","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389736,"discussion_content":"如果把操作数据库和缓存放在一个数据库事务中，操作数据库成功，操作缓存失败时，数据库事务回滚不也可以保证数据一致性吗？","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1629419037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1675882,"avatar":"https://static001.geekbang.org/account/avatar/00/19/92/6a/dd37a054.jpg","nickname":"张y .","note":"","ucode":"85918469492F4C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1284672,"avatar":"https://static001.geekbang.org/account/avatar/00/13/9a/40/b746dc09.jpg","nickname":"twogozi","note":"","ucode":"C272B0745EF514","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411451,"discussion_content":"+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635932770,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":389736,"ip_address":""},"score":411451,"extra":""},{"author":{"id":1054201,"avatar":"https://static001.geekbang.org/account/avatar/00/10/15/f9/0b14785a.jpg","nickname":"三三","note":"","ucode":"4A76933C29BDA1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1284672,"avatar":"https://static001.geekbang.org/account/avatar/00/13/9a/40/b746dc09.jpg","nickname":"twogozi","note":"","ucode":"C272B0745EF514","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550599,"discussion_content":"缓存写成功后网络超时数据库事务回滚了呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644634536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":389736,"ip_address":""},"score":550599,"extra":""},{"author":{"id":1295418,"avatar":"https://static001.geekbang.org/account/avatar/00/13/c4/3a/cf0715e2.jpg","nickname":"超👀","note":"","ucode":"0E76CA7EE00D9F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1284672,"avatar":"https://static001.geekbang.org/account/avatar/00/13/9a/40/b746dc09.jpg","nickname":"twogozi","note":"","ucode":"C272B0745EF514","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570632,"discussion_content":"如果缓存更新100ms, 数据库会夯住, 抱团一起挂掉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651841414,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":389736,"ip_address":""},"score":570632,"extra":""}]},{"author":{"id":1344535,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqOn7k48KXia5rf0eXpzv2EGtqGibz3eNb8QnL8X72uia0g1rBwzXef4dV2JEdz3r4bu9GC1FLIeic4UA/132","nickname":"Lee","note":"","ucode":"6B8D59A0B1A1A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545825,"discussion_content":"Cache Aside策略，对于并发场景，第一个命中的写请求会修改缓存，但是修改前，其他读请求读到的还是旧值，是吧？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1642060904,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1194858,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3b/6a/80d9c545.jpg","nickname":"RD","note":"","ucode":"E3947B6E1681AD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1344535,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqOn7k48KXia5rf0eXpzv2EGtqGibz3eNb8QnL8X72uia0g1rBwzXef4dV2JEdz3r4bu9GC1FLIeic4UA/132","nickname":"Lee","note":"","ucode":"6B8D59A0B1A1A9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589512,"discussion_content":"你可以这样想，修改前，不就是还没改，还没改不就等于缓存值是新的哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665054848,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":545825,"ip_address":"北京"},"score":589512,"extra":""}]},{"author":{"id":1238707,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e6/b3/a3ae518f.jpg","nickname":"别看我","note":"","ucode":"8F6F014DEB4F7D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311690,"discussion_content":"受益匪浅👍","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602463297,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3190922,"avatar":"","nickname":"Geek_590385","note":"","ucode":"BE5BDD9180FA0E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591112,"discussion_content":"牛牛","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666281253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江西"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1194858,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3b/6a/80d9c545.jpg","nickname":"RD","note":"","ucode":"E3947B6E1681AD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589513,"discussion_content":"话说，读写直写的情况下，为了保证并发下的隔离性，使用分布式锁。为了保证原子性，需要加分布式事务。这个性能是不是急剧下降啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665054985,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2984369,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/89/b1/6444e86b.jpg","nickname":"JLOMG","note":"","ucode":"17EB1366167299","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585032,"discussion_content":"只读模式和读写模式，是redis自带的功能模块还是需要开发自己实现的逻辑封装呢？看文章像是自己配置即可，怎么配置也没有啊\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661303060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1415619,"avatar":"https://static001.geekbang.org/account/avatar/00/15/99/c3/e4f408d4.jpg","nickname":"陌兮","note":"","ucode":"00CE47CAECD5CD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553603,"discussion_content":"mark!","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645975987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1640978,"avatar":"https://static001.geekbang.org/account/avatar/00/19/0a/12/f8b988b8.jpg","nickname":"Kyle(","note":"","ucode":"0C14C4C086CAA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374974,"discussion_content":"Hi Kaito\n请教一个问题\n请问异步写回的这个缓存已满怎么判断？缓存满了不就已经执行清除工作了吗？这时候如何写回呢？还是说事先定一个阈值？每次去加载的时候看下超过阈值没有？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621426037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1722506,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJGLmN0Fooy93ia0cwWdvkr3AxciaLiapQSlYd77C6Wy6jcMuzMZKVk4dA70t8QYJmx9PF3NubicjJWuw/132","nickname":"Fisherman","note":"","ucode":"0BB07359C44FC6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367155,"discussion_content":"是 write though 而不是 write thought","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618279776,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1024294,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","nickname":"null","note":"","ucode":"F9039EFED6B55D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1722506,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJGLmN0Fooy93ia0cwWdvkr3AxciaLiapQSlYd77C6Wy6jcMuzMZKVk4dA70t8QYJmx9PF3NubicjJWuw/132","nickname":"Fisherman","note":"","ucode":"0BB07359C44FC6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376590,"discussion_content":"直写，是不是老师文章提到的：读写缓存+同步写？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622203315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":367155,"ip_address":""},"score":376590,"extra":""}]},{"author":{"id":1566642,"avatar":"https://static001.geekbang.org/account/avatar/00/17/e7/b2/4cb8356a.jpg","nickname":"小甲鱼","note":"","ucode":"DDF8A3A4976681","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352275,"discussion_content":"我感觉如果要保证数据一致性的话，可以考虑引入MQ，更新缓存后，可以发MQ，下游去接收，修改数据库。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614670927,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":2340338,"avatar":"https://static001.geekbang.org/account/avatar/00/23/b5/f2/58afc1d4.jpg","nickname":"刘小辉","note":"","ucode":"E1D77D8B56F3A5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1566642,"avatar":"https://static001.geekbang.org/account/avatar/00/17/e7/b2/4cb8356a.jpg","nickname":"小甲鱼","note":"","ucode":"DDF8A3A4976681","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368567,"discussion_content":"多个线程更新了同一条数据、都发送到MQ、无法保证顺序、也会不一致。 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618752918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":352275,"ip_address":""},"score":368567,"extra":""},{"author":{"id":2526420,"avatar":"https://static001.geekbang.org/account/avatar/00/26/8c/d4/c228fe2c.jpg","nickname":"高欧叶尼兹","note":"","ucode":"1974C9151DBFB7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2340338,"avatar":"https://static001.geekbang.org/account/avatar/00/23/b5/f2/58afc1d4.jpg","nickname":"刘小辉","note":"","ucode":"E1D77D8B56F3A5","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":379561,"discussion_content":"加时间戳，类似tcp的解决方案应该能保序","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1623981793,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":368567,"ip_address":""},"score":379561,"extra":""},{"author":{"id":1592279,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","nickname":"William Ning","note":"","ucode":"4DB8D05E69E5F3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2526420,"avatar":"https://static001.geekbang.org/account/avatar/00/26/8c/d4/c228fe2c.jpg","nickname":"高欧叶尼兹","note":"","ucode":"1974C9151DBFB7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586399,"discussion_content":"还有时钟问题，如果发生跳跃，还是会存在问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662184418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":379561,"ip_address":"浙江"},"score":586399,"extra":""}]},{"author":{"id":2109120,"avatar":"","nickname":"Geek_c12f80","note":"","ucode":"D5ADE29F16866B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325661,"discussion_content":"volatile-ttl淘汰策略，是只要筛选出过期的数据淘汰就行了吗？还是需要根据过期时间排序，过期时间最久的淘汰掉？如果排序，也是类似lru随机选择候选集范围内排序吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605399558,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1336009,"avatar":"https://static001.geekbang.org/account/avatar/00/14/62/c9/7da27891.jpg","nickname":"DKSky","note":"","ucode":"69371A81033949","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312992,"discussion_content":"Hi Kaito\n请教一个问题，（读写缓存模式+同步直写策略，这种方案在并发场景下会导致数据库和缓存的不一致）这种场景可以举个例子吗?我没太想明白是怎么出现的不一致。谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602904125,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1336009,"avatar":"https://static001.geekbang.org/account/avatar/00/14/62/c9/7da27891.jpg","nickname":"DKSky","note":"","ucode":"69371A81033949","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":313008,"discussion_content":"看下一篇我的留言，有详细写到。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1602908391,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":312992,"ip_address":""},"score":313008,"extra":""},{"author":{"id":1640978,"avatar":"https://static001.geekbang.org/account/avatar/00/19/0a/12/f8b988b8.jpg","nickname":"Kyle(","note":"","ucode":"0C14C4C086CAA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":374936,"discussion_content":"好家伙，让我搞不清谁是专栏作者了，给你点赞哈哈！","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1621415933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":313008,"ip_address":""},"score":374936,"extra":""}]},{"author":{"id":1324307,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoU91kd8RZO5hg2w9cpnL4yTcfemDFJH3GfiaNRgOe7nQyQF7xBDc5Yq2Aue5KuHaEGOCMM9RUkUpQ/132","nickname":"上神梵修","note":"","ucode":"77A5BED0911A87","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312785,"discussion_content":"请教个问题：如果设置过期淘汰机制（如 volital-lru） 如果redis内存达到maxmemory   淘汰的候选数据 会包含未过期的数据吗？ 如果没有过期数据 是直接oom吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602817553,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":6,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1324307,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoU91kd8RZO5hg2w9cpnL4yTcfemDFJH3GfiaNRgOe7nQyQF7xBDc5Yq2Aue5KuHaEGOCMM9RUkUpQ/132","nickname":"上神梵修","note":"","ucode":"77A5BED0911A87","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312810,"discussion_content":"1、不会。2、Redis会返回拒绝写入错误，不会OOM。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1602823969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":312785,"ip_address":""},"score":312810,"extra":""},{"author":{"id":1324307,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoU91kd8RZO5hg2w9cpnL4yTcfemDFJH3GfiaNRgOe7nQyQF7xBDc5Yq2Aue5KuHaEGOCMM9RUkUpQ/132","nickname":"上神梵修","note":"","ucode":"77A5BED0911A87","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":313493,"discussion_content":"感谢\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603068511,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":312810,"ip_address":""},"score":313493,"extra":""},{"author":{"id":2109120,"avatar":"","nickname":"Geek_c12f80","note":"","ucode":"D5ADE29F16866B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1324307,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoU91kd8RZO5hg2w9cpnL4yTcfemDFJH3GfiaNRgOe7nQyQF7xBDc5Yq2Aue5KuHaEGOCMM9RUkUpQ/132","nickname":"上神梵修","note":"","ucode":"77A5BED0911A87","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325660,"discussion_content":"这个问题，老师回答，内存不够，volatile也可能淘汰未过期数据，到底哪个对呢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605399483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":312785,"ip_address":""},"score":325660,"extra":""}]}]},{"had_liked":false,"id":259005,"user_name":"Mr.蜜","can_delete":false,"product_type":"c1","uid":1035257,"ip_address":"","ucode":"C911B81198B3F5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cb/f9/75d08ccf.jpg","comment_is_top":false,"comment_ctime":1604594902,"is_pvip":false,"replies":[{"id":"98019","content":"谢谢指出版本上的差别，赞仔细认真！","user_name":"作者回复","comment_id":259005,"uid":"1609687","ip_address":"","utype":1,"ctime":1609081987,"user_name_real":"蒋德钧"}],"discussion_count":1,"race_medal":0,"score":"555655376086","product_id":100056701,"comment_content":"我发现一个问题，在淘汰策略上，我的记忆中，他一直是默认volatile-lru，而且在百度上搜索，大多数也都是默认volatile-lru。而我在前几周也看到与你有相同的说法，默认是noeviction，所以我查看了多个版本的配置文件，从中了解到，在redis3.0之前，默认是volatile-lru；在redis3.0之后（包括3.0），默认淘汰策略则是noeviction。所以这个地方需要强调一下。","like_count":130,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508809,"discussion_content":"谢谢指出版本上的差别，赞仔细认真！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609081987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":252917,"user_name":"humor","can_delete":false,"product_type":"c1","uid":1181867,"ip_address":"","ucode":"9B48C4C7BEC92C","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/ab/caec7bca.jpg","comment_is_top":false,"comment_ctime":1602514227,"is_pvip":false,"replies":[{"id":"92425","content":"在实际运行时，每次往候选集中插入的数据可能不止一个，而在淘汰数据时，也是会根据使用内存量超过maxmemory的情况，来决定要淘汰的数据量，所以可能也不止一个数据被淘汰。候选集的作用是先把符合条件（lru值小）的数据准备好。候选集本身是会按照lru值大小排序的，等待要淘汰时，会根据要淘汰的量，从候选集中淘汰数据。所以，并不是刚进入候选集就立马就淘汰了。准备候选集和淘汰数据实际是两个解耦的逻辑操作。","user_name":"作者回复","comment_id":252917,"uid":"1609687","ip_address":"","utype":1,"ctime":1602553809,"user_name_real":"蒋德钧"}],"discussion_count":7,"race_medal":0,"score":"173401206067","product_id":100056701,"comment_content":"能进入候选集合的数据的 lru 字段值必须小于候选集合中最小的 lru 值。<br>感觉这句话有问题，如果能进入候选集合的数据的lru字段值都小于候选集合中的最小的lru值的话，每次淘汰的肯定是刚进入候选集合的这条数据啊，这样这条被选择进行候选集合的数据就没有必要再进入候选集合了啊，直接删除就可以了吧","like_count":41,"discussions":[{"author":{"id":1016575,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/82/ff/00e7614e.jpg","nickname":"robyy","note":"","ucode":"773337C9942A7F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350587,"discussion_content":"第一批入选候选集：5，6，7，8，淘汰5剩下6，7，8，第二次入选新增1，2，3（1，2，3，6，7，8），但可能要淘汰1个或4个，入选和需要淘汰的个数不是必须一样的","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1613927262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506915,"discussion_content":"在实际运行时，每次往候选集中插入的数据可能不止一个，而在淘汰数据时，也是会根据使用内存量超过maxmemory的情况，来决定要淘汰的数据量，所以可能也不止一个数据被淘汰。候选集的作用是先把符合条件（lru值小）的数据准备好。候选集本身是会按照lru值大小排序的，等待要淘汰时，会根据要淘汰的量，从候选集中淘汰数据。所以，并不是刚进入候选集就立马就淘汰了。准备候选集和淘汰数据实际是两个解耦的逻辑操作。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602553809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1464234,"avatar":"https://static001.geekbang.org/account/avatar/00/16/57/aa/2e4f996f.jpg","nickname":"Stanleyzhu","note":"","ucode":"6846FBBEF2C933","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560525,"discussion_content":"时间戳为判断条件的话。越后面修改得数据值就越大。那么问题来了。假如刚开始所谓的时间戳为（1-10），随机选择（3  5  7）进去候选集合，集合最大个数为3.\n第一次删除最小的3，剩下（5  7）\n第二次进去候选集合（1  2  4 5  7），删除1 2 4剩下（5 7）\n\n这里按照规则（小于最小lru的才能进候选集合），那么后面就没有数据能进集合了，因为新的数据时间戳都比第一次全部集合最大的10还大。那这个规则是不生效了？\n\n是我理解有问题还是讲的这个点不对？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649380729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2115387,"avatar":"https://static001.geekbang.org/account/avatar/00/20/47/3b/70198ceb.jpg","nickname":"Aibo","note":"","ucode":"2CE3E77BD2D014","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550799,"discussion_content":"主要不是节省时间，使用集合筛选的方式其实就是用时间换空间","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644734940,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2026838,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/ed/56/4ab914f7.jpg","nickname":"幻","note":"","ucode":"E10667B64E097F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548251,"discussion_content":"我也表示疑惑，原来我不是一个人","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643100379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2041396,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/26/34/891dd45b.jpg","nickname":"宙斯","note":"","ucode":"80DF36BAD298AD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341620,"discussion_content":"我也有些疑惑，按照这么理解那淘汰的肯定是刚选进候选集合中的元素？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610463200,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2110772,"avatar":"","nickname":"dfuru","note":"","ucode":"0222FADA093D95","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318150,"discussion_content":"在候选数据集中的链表中淘汰，虽然链表短了，仍然只有一个链表。高并发时，对链表加锁，仍然影响性能吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603666092,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":252740,"user_name":"不正经、绅士","can_delete":false,"product_type":"c1","uid":1348004,"ip_address":"","ucode":"564A664338A4DF","user_header":"https://static001.geekbang.org/account/avatar/00/14/91/a4/a4af0d30.jpg","comment_is_top":false,"comment_ctime":1602472452,"is_pvip":false,"replies":[{"id":"92416","content":"是有这种可能的，第一次进入候选集合的数据是随机选取的，数据的lru值可能大可能小。第二次及后续再进入候选集的数据的lru值需要小于候选集中的最小lru值。<br><br>同时，候选集的实现是一个链表，数据是按照lru值排序的，链表头是lru值最大的，链表尾是lru值最小的。当第二次及后续进入候选集的数据lru更小，但是候选集中已经没有空位置时，候选集链表头的数据会被移出候选集，把位置空出来，给新进入的数据。这样的话，这个被移出的数据就不会作为被淘汰的候选数据了。","user_name":"作者回复","comment_id":252740,"uid":"1609687","ip_address":"","utype":1,"ctime":1602545719,"user_name_real":"蒋德钧"}],"discussion_count":4,"race_medal":0,"score":"83206851076","product_id":100056701,"comment_content":"能进入候选集合的数据的 lru 字段值必须小于候选集合中最小的 lru 值。<br>这里有个疑问，请教老师，这样第二次及后续进入的备选淘汰集合中的数据lru都小于第一次的，淘汰的也是lru最小的，那第一次进入淘汰集合的数据这样不就不会被选中淘汰了呢","like_count":20,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506857,"discussion_content":"是有这种可能的，第一次进入候选集合的数据是随机选取的，数据的lru值可能大可能小。第二次及后续再进入候选集的数据的lru值需要小于候选集中的最小lru值。\n\n同时，候选集的实现是一个链表，数据是按照lru值排序的，链表头是lru值最大的，链表尾是lru值最小的。当第二次及后续进入候选集的数据lru更小，但是候选集中已经没有空位置时，候选集链表头的数据会被移出候选集，把位置空出来，给新进入的数据。这样的话，这个被移出的数据就不会作为被淘汰的候选数据了。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1602545719,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2548016,"avatar":"https://static001.geekbang.org/account/avatar/00/26/e1/30/56151c95.jpg","nickname":"徐大雷","note":"","ucode":"4D6F0D4C58CE93","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":576951,"discussion_content":"老师，我有个疑问我看源码是候选集合是一个数组，而每次都会选择maxmemory_samples数量的数据，然后根据是否时间最小插入候选集合数组中，感觉跟老师说的候选集合是链表不太一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655862922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":506857,"ip_address":""},"score":576951,"extra":""}]},{"author":{"id":1035064,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cb/38/4c9cfdf4.jpg","nickname":"谢小路","note":"","ucode":"C9FE2EB10DC105","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311838,"discussion_content":"N个值是随机选的。下次触发淘汰的时候，数据不一定是这些，在新的集合里就有可能淘汰掉","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602499905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1623409,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c5/71/f7c43b49.jpg","nickname":"风向北吹","note":"","ucode":"2FD0BC5159E1C1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311973,"discussion_content":"淘汰LRU最小的，每次只能淘汰一个数据吗？第二次及后续再进入候选集的触发条件，是有新数据插入吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602554046,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":266336,"user_name":"有生之年","can_delete":false,"product_type":"c1","uid":1020719,"ip_address":"","ucode":"B713335DE9D37F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/93/2f/1e193dcc.jpg","comment_is_top":false,"comment_ctime":1607304892,"is_pvip":false,"replies":[{"id":"97658","content":"因为allkeys是在所有的键值对中进行筛选淘汰，所以，如果redis做存储，相应的数据应该是不希望被淘汰的（除非应用自己删除），此时用allkeys就不合适了。<br><br>一般不建议一个Redis实例同时做缓存和做存储，可以分开用不同实例。","user_name":"作者回复","comment_id":266336,"uid":"1609687","ip_address":"","utype":1,"ctime":1608597304,"user_name_real":"蒋德钧"}],"discussion_count":1,"race_medal":0,"score":"66031814332","product_id":100056701,"comment_content":"老师，您好，如果redis既做缓存，又作存储使用，是不是就不能设置allkeys相关的配置了","like_count":15,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511216,"discussion_content":"因为allkeys是在所有的键值对中进行筛选淘汰，所以，如果redis做存储，相应的数据应该是不希望被淘汰的（除非应用自己删除），此时用allkeys就不合适了。\n\n一般不建议一个Redis实例同时做缓存和做存储，可以分开用不同实例。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608597304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":264454,"user_name":"好好学习","can_delete":false,"product_type":"c1","uid":1762191,"ip_address":"","ucode":"9D44D9530D9A1D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/e3/8f/77b5a753.jpg","comment_is_top":false,"comment_ctime":1606470051,"is_pvip":false,"replies":[{"id":"97917","content":"使用volatile-lru策略的同时给置顶数据不设置过期时间，就是为了把置顶数据和非置顶数据区分开来。对置顶数据不设置过期时间，就不会被volatile-lru淘汰，可以一直置顶。而其他非置顶数据可以正常被volatile-lru淘汰掉。<br><br>如果用allkeys的策略，就无法区分置顶和非置顶数据了，都是用统一的策略了。","user_name":"作者回复","comment_id":264454,"uid":"1609687","ip_address":"","utype":1,"ctime":1608993151,"user_name_real":"蒋德钧"}],"discussion_count":1,"race_medal":0,"score":"57441044899","product_id":100056701,"comment_content":"老师好, 这里是不是有些矛盾呢?<br><br>文中说&quot;如果业务中有置顶的需求，比如置顶新闻、置顶视频，可以使用 volatile-lru 策略，同时不给这些置顶数据设置过期时间。&quot;<br><br> volatile-lru  不是只针对设置了过期时间的key才会生效吗? 这里又说不给这些数据设置过期时间.. ","like_count":13,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510570,"discussion_content":"使用volatile-lru策略的同时给置顶数据不设置过期时间，就是为了把置顶数据和非置顶数据区分开来。对置顶数据不设置过期时间，就不会被volatile-lru淘汰，可以一直置顶。而其他非置顶数据可以正常被volatile-lru淘汰掉。\n\n如果用allkeys的策略，就无法区分置顶和非置顶数据了，都是用统一的策略了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608993151,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":258122,"user_name":"沈寅","can_delete":false,"product_type":"c1","uid":1321582,"ip_address":"","ucode":"03ACA766AC6FD5","user_header":"https://static001.geekbang.org/account/avatar/00/14/2a/6e/fb980b6b.jpg","comment_is_top":false,"comment_ctime":1604305857,"is_pvip":false,"replies":[{"id":"94185","content":"有可能会被删除的。<br><br>volatile-*策略是从设置了过期时间的key中进行淘汰，如果内存不够了，即使key的过期时间还未到，也可能按照策略被选出来淘汰掉。","user_name":"作者回复","comment_id":258122,"uid":"1609687","ip_address":"","utype":1,"ctime":1604561715,"user_name_real":"蒋德钧"}],"discussion_count":9,"race_medal":0,"score":"40259011521","product_id":100056701,"comment_content":"volatile-开头的策略 ，如果一个key还未过期，有可能被删除吗？","like_count":10,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508558,"discussion_content":"有可能会被删除的。\n\nvolatile-*策略是从设置了过期时间的key中进行淘汰，如果内存不够了，即使key的过期时间还未到，也可能按照策略被选出来淘汰掉。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604561715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2308075,"avatar":"","nickname":"Geek_89e362","note":"","ucode":"E596C2CFE1CFAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348344,"discussion_content":"with any of the above policies, Redis will return an error on write  operations, when there are no suitable keys for eviction.  如果不存在符合条件的key 就会报错","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1612518499,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1780797,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/2c/3d/0bd58aa4.jpg","nickname":"Em","note":"","ucode":"32012A5C603C8A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2308075,"avatar":"","nickname":"Geek_89e362","note":"","ucode":"E596C2CFE1CFAF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577812,"discussion_content":"返回写失败","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656347599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":348344,"ip_address":""},"score":577812,"extra":""}]},{"author":{"id":2109120,"avatar":"","nickname":"Geek_c12f80","note":"","ucode":"D5ADE29F16866B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325659,"discussion_content":"这个问题，课代表Kaito回复说，就算内存不够，未过期数据也不会淘汰，会抛出oom，到底哪个是对的？！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605399270,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2109120,"avatar":"","nickname":"Geek_c12f80","note":"","ucode":"D5ADE29F16866B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374801,"discussion_content":"老哥，我啥时这么说过，你别坑我。。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1621351912,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":325659,"ip_address":""},"score":374801,"extra":""},{"author":{"id":2870609,"avatar":"","nickname":"Geek_81fd93","note":"","ucode":"010A1ACF8E7F40","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":541021,"discussion_content":"哈哈哈哈哈哈","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1640233963,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":374801,"ip_address":""},"score":541021,"extra":""},{"author":{"id":1780797,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/2c/3d/0bd58aa4.jpg","nickname":"Em","note":"","ucode":"32012A5C603C8A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2109120,"avatar":"","nickname":"Geek_c12f80","note":"","ucode":"D5ADE29F16866B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577811,"discussion_content":"人家没说oom, 说的是会拒绝访问, 传话也不传个全的?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656347562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":325659,"ip_address":""},"score":577811,"extra":""}]},{"author":{"id":2109120,"avatar":"","nickname":"Geek_c12f80","note":"","ucode":"D5ADE29F16866B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325654,"discussion_content":"再进一步确认下，如果内存使用没有达到maxmemory，volatile开头的淘汰策略是不会淘汰未过期数据吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605398578,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2109120,"avatar":"","nickname":"Geek_c12f80","note":"","ucode":"D5ADE29F16866B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374802,"discussion_content":"没超过maxmemory，肯定不淘汰啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621351934,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":325654,"ip_address":""},"score":374802,"extra":""}]}]},{"had_liked":false,"id":252713,"user_name":"yeek","can_delete":false,"product_type":"c1","uid":1020629,"ip_address":"","ucode":"A1C71023113CB9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/d5/699384a0.jpg","comment_is_top":false,"comment_ctime":1602464190,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27372267966","product_id":100056701,"comment_content":"记录几个问题：<br><br>1. 淘汰对当前请求的延迟问题；<br>2. 淘汰数据的上限是多少？仅满足当前set所需的内存空间么？<br>3. 如果随机多次依然不存在比候选队列中最小lru还小的数据，且内存空间还需要继续释放，是否有执行时间上限？","like_count":6},{"had_liked":false,"id":253202,"user_name":"Watson","can_delete":false,"product_type":"c1","uid":1113122,"ip_address":"","ucode":"85299D36007161","user_header":"https://static001.geekbang.org/account/avatar/00/10/fc/22/4b84b7d7.jpg","comment_is_top":false,"comment_ctime":1602648728,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"14487550616","product_id":100056701,"comment_content":"原文：如果候选数据集中的数据个数达到了 maxmemory-samples，Redis 就把候选数据集中 lru 字段值最小的数据淘汰出去。<br><br>请教老师，是否存在maxmemory-samples 没达到个数，但是redis内存满了的情况，如果存在这种情况，redis淘汰机制没有启动的时候，redis内存满了，会发生什么神奇之旅呢？","like_count":3,"discussions":[{"author":{"id":2136414,"avatar":"https://static001.geekbang.org/account/avatar/00/20/99/5e/33481a74.jpg","nickname":"Lemon","note":"","ucode":"E52BB361B69825","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312870,"discussion_content":"同问，但也想再问一下：如果随机候选的数据都是最旧的数据（lru值都很小），那么是不是意味着后续“候选集合”已经无法添加内容了？因为此时“候选集合”中的lru值都很小，没办法凑到 maxmemory-samples 的个数。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602839708,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1365206,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d4/d6/1d4543ac.jpg","nickname":"云海","note":"","ucode":"0C6CA0BE58EA21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2136414,"avatar":"https://static001.geekbang.org/account/avatar/00/20/99/5e/33481a74.jpg","nickname":"Lemon","note":"","ucode":"E52BB361B69825","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330668,"discussion_content":"文章的表述应该是有歧义的，我看了源码，描述的是随机抽样选出【最多N个数据】，只要数据比【待淘汰数据池 evictionPoolEntry】中的【任意一条】数据的 lru 小，则将该数据填充至 【待淘汰数据池】；Keys with idle time smaller than one of the current keys are added.  可以查看这篇文章：https://zxiaofan.blog.csdn.net/article/details/110357096","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1606663676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":312870,"ip_address":""},"score":330668,"extra":""},{"author":{"id":2314790,"avatar":"","nickname":"Geek_9a62f5","note":"","ucode":"F1D5410CE20FE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1365206,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d4/d6/1d4543ac.jpg","nickname":"云海","note":"","ucode":"0C6CA0BE58EA21","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374799,"discussion_content":"我看过了这篇文章，但仍然存在一个疑问。\n当redis的内存中没有比【待淘汰数据池】中的数据的lru小的数据时redis如何处理？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1621350418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":330668,"ip_address":""},"score":374799,"extra":""}]}]},{"had_liked":false,"id":289199,"user_name":"学而不思则罔","can_delete":false,"product_type":"c1","uid":1091673,"ip_address":"","ucode":"3EAF4C37386F0E","user_header":"https://static001.geekbang.org/account/avatar/00/10/a8/59/e5a7762e.jpg","comment_is_top":false,"comment_ctime":1618913511,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10208848103","product_id":100056701,"comment_content":"缓存淘汰这里有个疑问，做分布式锁的lock_key一般都会带上expire，这个时候lock_key如果被淘汰了不是会导致锁失效吗？","like_count":2,"discussions":[{"author":{"id":1014665,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/89/34f2cbcc.jpg","nickname":"杨宇","note":"","ucode":"EB74DF6E269F03","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388314,"discussion_content":"这是到了危急时刻吧，只能丢车保帅","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628691899,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":252794,"user_name":"小喵喵","can_delete":false,"product_type":"c1","uid":1062444,"ip_address":"","ucode":"FDBBB2A59DB8B6","user_header":"https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg","comment_is_top":false,"comment_ctime":1602489416,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"10192424008","product_id":100056701,"comment_content":"请教下老师：<br>1、volatile-ttl这个全称是啥？<br>2、干净数据是缓存里面的数据和数据库里面是一致的，既然一致，为什么要删除呢？<br>3、脏数据为什么要写回到数据库呢？难道是先更新cache，然后去更新数据库吗？","like_count":2,"discussions":[{"author":{"id":1035064,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cb/38/4c9cfdf4.jpg","nickname":"谢小路","note":"","ucode":"C9FE2EB10DC105","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311836,"discussion_content":"1. ttl 命令表示生成时间，对设置过期时间的 key 的操作，所以 volatile-ttl 策略表示就是根据过期时间策略进行淘汰。\n\n2. 这个删除的前提是这个数据需要被淘汰了，redis 内存放不下了，删除掉\n\n3. redis 用作缓存，最需要解决的问题是 redis 和 数据库中数据一致性的问题，脏数据，也就不一致。缓存又分只读缓存和读写缓存。读写缓存时先读 redis，发现没有，那就操作数据库，再把数据库中查询到的数据写入 redis，下次操作就直接更新 redis。同时写入数据库，保证数据一致。更新 redis 和 操作数据不是原子的动作，有可能操作 redis 结束了，但操作数据没写入成功，那就有脏数据，现在淘汰策略要删除这个数据，可不得确保写入数据库，维护一致性嘛。\n","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1602498944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1388092,"avatar":"https://static001.geekbang.org/account/avatar/00/15/2e/3c/eae43616.jpg","nickname":"sid","note":"","ucode":"3D1F9169A19D29","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312250,"discussion_content":"ttl = time to live","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602640746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1116608,"avatar":"https://static001.geekbang.org/account/avatar/00/11/09/c0/3119a4f6.jpg","nickname":"黄栋","note":"","ucode":"6BB8EC43EB87A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311829,"discussion_content":"脏数据怎么回写数据库?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602496079,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1675882,"avatar":"https://static001.geekbang.org/account/avatar/00/19/92/6a/dd37a054.jpg","nickname":"张y .","note":"","ucode":"85918469492F4C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1116608,"avatar":"https://static001.geekbang.org/account/avatar/00/11/09/c0/3119a4f6.jpg","nickname":"黄栋","note":"","ucode":"6BB8EC43EB87A9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411464,"discussion_content":"Redis实现不了，异步写回策略Redis根本实现不了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635933742,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":311829,"ip_address":""},"score":411464,"extra":""}]}]},{"had_liked":false,"id":327596,"user_name":"树心","can_delete":false,"product_type":"c1","uid":1589523,"ip_address":"","ucode":"6C329F0FF798B9","user_header":"https://static001.geekbang.org/account/avatar/00/18/41/13/ab14ad25.jpg","comment_is_top":false,"comment_ctime":1640184850,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"5935152146","product_id":100056701,"comment_content":"<br>缓存前两节课第23和24节比较简单，只要认真读就能理解。就是概念比较多，初学会觉得有点绕。<br>redis可以支持只读缓存和读写缓存。作为读写缓存时，只能支持同步直写策略（如果要支持异步写回需要修改redis）。<br>哪种模式取决于应用方的设计。","like_count":1},{"had_liked":false,"id":307204,"user_name":"宙斯","can_delete":false,"product_type":"c1","uid":2041396,"ip_address":"","ucode":"80DF36BAD298AD","user_header":"https://static001.geekbang.org/account/avatar/00/1f/26/34/891dd45b.jpg","comment_is_top":false,"comment_ctime":1628933554,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5923900850","product_id":100056701,"comment_content":"redis lru在数据淘汰时存在每次都会选择时间戳最小的元素放在待淘汰集合中，这个比较感觉挺耗时，为什么还采用这种方式呢？","like_count":1},{"had_liked":false,"id":288535,"user_name":"而立斋","can_delete":false,"product_type":"c1","uid":1087258,"ip_address":"","ucode":"5FED6E9E148195","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/1a/389eab84.jpg","comment_is_top":false,"comment_ctime":1618533145,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5913500441","product_id":100056701,"comment_content":"有几个问题记录一下:<br>0，重尾没咋理解<br>1，第一次随机是为了节省时间，也是按需淘汰lru最小的数据<br>2，100个数据lru是会变化的，而且每次进入到这100个数中的数据也都是lru较小的，而不是最小的，这样的话lru的最近最少未使用是不是也可以理解为是相对意义上的lru了<br>3，每次较小lru数据进去100个数，如果100个数已经满了，那再进去就直接被淘汰，进不进还有啥意义？","like_count":1},{"had_liked":false,"id":356611,"user_name":"Geek_c4e8a7","can_delete":false,"product_type":"c1","uid":2718664,"ip_address":"广东","ucode":"B8B7F6C3D77360","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/BD5O3DV5ZDuL8tGIVicPB99tLjE1MyKoudWjI0OGhUCTPYQ4KWpgC7BmbFwBJ7lK8nMaSicWDbtUYBBsfLpZwXjQ/132","comment_is_top":false,"comment_ctime":1662449271,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662449271","product_id":100056701,"comment_content":"之前面试只知道7种内存淘汰策略 但不知道怎么用 受教了","like_count":0},{"had_liked":false,"id":355105,"user_name":"贺子","can_delete":false,"product_type":"c1","uid":2076283,"ip_address":"北京","ucode":"A64DC9D9CF7CCD","user_header":"https://static001.geekbang.org/account/avatar/00/1f/ae/7b/47200692.jpg","comment_is_top":false,"comment_ctime":1661084026,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661084026","product_id":100056701,"comment_content":"老师好，redis的lru算法经过优化后，是不是会导致不准确吧，因为第一次是随机选择n个key，所以可能会第一次选择的不合适，导致后面选择的也不合适，但是好像实例运行一段时间就会越来越准确，对吧？，再一个问题如果是volit-lru的话，那么他是一开始就维护一个集合？还是当第一次需要淘汰数据的时候才开始维护这个集合呢？","like_count":0},{"had_liked":false,"id":353569,"user_name":"Jackson","can_delete":false,"product_type":"c1","uid":2739544,"ip_address":"广东","ucode":"0012FFEA2B4620","user_header":"https://static001.geekbang.org/account/avatar/00/29/cd/58/06a8ce36.jpg","comment_is_top":false,"comment_ctime":1659575916,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1659575916","product_id":100056701,"comment_content":"LFU呢老师","like_count":0,"discussions":[{"author":{"id":1225224,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","nickname":"尔冬橙","note":"","ucode":"0B013A49BC18DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584982,"discussion_content":"后面会讲","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661255796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"湖南"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":350616,"user_name":"卡尔","can_delete":false,"product_type":"c1","uid":2887573,"ip_address":"","ucode":"B3F5506B938986","user_header":"https://static001.geekbang.org/account/avatar/00/2c/0f/95/275d534e.jpg","comment_is_top":false,"comment_ctime":1657046412,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1657046412","product_id":100056701,"comment_content":"我有个问题，前面有讲到，redis使用内存过多，会导致系统触发swap机制。那这个redis内存淘汰是会同步发生的吗<br>","like_count":0},{"had_liked":false,"id":329850,"user_name":"EveryDayIsNew","can_delete":false,"product_type":"c1","uid":1316926,"ip_address":"","ucode":"776B81EF6830FA","user_header":"https://static001.geekbang.org/account/avatar/00/14/18/3e/f8632713.jpg","comment_is_top":false,"comment_ctime":1641594906,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641594906","product_id":100056701,"comment_content":"老师好，问下1.这个内存满了，6.0版本，不采用默认不淘汰策略的话，是否需要设置上面的其他七种策略，有什么最佳实践吗？ 2.这个内存满了，开启淘汰策略的话，这个淘汰效率如何呢，跟默认的惰性删除和定时淘汰关系是什么呢","like_count":0},{"had_liked":false,"id":307787,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1629255952,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629255952","product_id":100056701,"comment_content":"是只读缓存还是读写缓存取决于实际应用中的使用方式,没有什么固定之说","like_count":0},{"had_liked":false,"id":302057,"user_name":"梦缘","can_delete":false,"product_type":"c1","uid":1433672,"ip_address":"","ucode":"318FD8C01023F7","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/48/81d420d4.jpg","comment_is_top":false,"comment_ctime":1626057676,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626057676","product_id":100056701,"comment_content":"在读写缓存-异步写回策略中，如何检测到数据要被删除的时机去执行写回后端数据库呢？？","like_count":0},{"had_liked":false,"id":299895,"user_name":"Just Do IT","can_delete":false,"product_type":"c1","uid":1192724,"ip_address":"","ucode":"1EAD92510FA7BE","user_header":"https://static001.geekbang.org/account/avatar/00/12/33/14/78104f1f.jpg","comment_is_top":false,"comment_ctime":1624895748,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624895748","product_id":100056701,"comment_content":"感觉这句话有问题，如果是这样很容易出现极端情况，比如随机选出N个数据，lru是所有数据中最小的n个数据，这样的话，在进行第二次选择的时候，redis的数据的lru都比第一次选出的数据大，也就是无法进入候选集合，只有等第一次后院集合全部淘汰了才行！<br><br><br>Redis 在决定淘汰的数据时，第一次会随机选出 N 个数据，把它们作为一个候选集合。接下来，Redis 会比较这 N 个数据的 lru 字段，把 lru 字段值最小的数据从缓存中淘汰出去。","like_count":0},{"had_liked":false,"id":295926,"user_name":"悟空聊架构","can_delete":false,"product_type":"c1","uid":1123163,"ip_address":"","ucode":"C2F482A0CF8AF1","user_header":"https://static001.geekbang.org/account/avatar/00/11/23/5b/983408b9.jpg","comment_is_top":false,"comment_ctime":1622646639,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1622646639","product_id":100056701,"comment_content":"看到这里：比如置顶新闻、置顶视频，那么，可以使用 volatile-lru 策略，同时不给这些置顶数据设置过期时间。<br>我也有这个疑惑，评论区进行了解答：对置顶数据不设置过期时间，就不会被volatile-lru淘汰，可以一直置顶。而其他非置顶数据可以正常被volatile-lru淘汰掉。","like_count":0},{"had_liked":false,"id":293511,"user_name":"Geek_263062","can_delete":false,"product_type":"c1","uid":1295599,"ip_address":"","ucode":"B6721FA1309F0F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epW36dbuLUOFlqDqjIte11mtWWRxG8npdDLnDYtcWhFUxd56LcFhaobcIs5GC34RcnvS5Vy9Lv2JA/132","comment_is_top":false,"comment_ctime":1621414006,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621414006","product_id":100056701,"comment_content":"“如果一个键值对被删除策略选中了，即使它的过期时间还没到，也需要被删除。当然，如果它的过期时间到了但未被策略选中，同样也会被删除。”后半句，是除了noeviction不论选择哪种删除策略，过期健都会被删除吗？","like_count":0},{"had_liked":false,"id":293361,"user_name":"Geek_9a62f5","can_delete":false,"product_type":"c1","uid":2314790,"ip_address":"","ucode":"F1D5410CE20FE8","user_header":"","comment_is_top":false,"comment_ctime":1621350664,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621350664","product_id":100056701,"comment_content":"老师，在设置为LRU的淘汰策略时，当redis内存中没有比【待淘汰数据池】中的数据的lru小时，redis如何淘汰数据呢？<br>是否会直接淘汰最小的数据，知道将【待淘汰数据池】中的数据全部淘汰，然后重新随机选择&lt;=maxmemory-samples的数据数据放入【待淘汰数据池】进行新一轮LRU的操作？","like_count":0},{"had_liked":false,"id":293244,"user_name":"阿水","can_delete":false,"product_type":"c1","uid":2598202,"ip_address":"","ucode":"C73D28EF3F33EB","user_header":"","comment_is_top":false,"comment_ctime":1621303259,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621303259","product_id":100056701,"comment_content":"在设置最大缓存空间的时候,使用CONFIG SET maxmemory 4gb 设置最大缓存空间是4gb，这里有一个疑问，在设置最大缓存空间的时候，我是怎么知道最大缓存空间最大可以设置成多大呢？例如:CONFIG SET maxmemory 20gb或者100gb呢 这样的设置是不是就没有意义了；我怎么查看我可以设置的最大缓存空间","like_count":0},{"had_liked":false,"id":291644,"user_name":"机智的小俊俊","can_delete":false,"product_type":"c1","uid":1342429,"ip_address":"","ucode":"16DFBC3A9E60AD","user_header":"https://static001.geekbang.org/account/avatar/00/14/7b/dd/f33a0855.jpg","comment_is_top":false,"comment_ctime":1620397386,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1620397386","product_id":100056701,"comment_content":"LRU是最近最久未使用算法吧","like_count":0},{"had_liked":false,"id":290335,"user_name":"吃饭睡觉打酱油","can_delete":false,"product_type":"c1","uid":1071668,"ip_address":"","ucode":"95EC98C2B5045B","user_header":"https://static001.geekbang.org/account/avatar/00/10/5a/34/4cbadca6.jpg","comment_is_top":false,"comment_ctime":1619507930,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1619507930","product_id":100056701,"comment_content":"volatile-lfu 使用了 LFU 算法，我会在第 27 讲中具体解释，现在你只需要知道，它是在 LRU 算法的基础上，同时考虑了数据的访问时效性和数据的访问次数，可以看作是对淘汰策略的优化。<br>----LFU是在LRU的基础上对淘汰策略的优化？这个没说反么？","like_count":0,"discussions":[{"author":{"id":1014665,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/89/34f2cbcc.jpg","nickname":"杨宇","note":"","ucode":"EB74DF6E269F03","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388313,"discussion_content":"没说反。LRU可能导致这种情况：一名学生最近一次考了100分（之前都是80分），结果把本次考了99分但之前都是100分的学生淘汰了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628691806,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":290301,"user_name":"油菜花","can_delete":false,"product_type":"c1","uid":1238478,"ip_address":"","ucode":"E9901BBD9952B7","user_header":"https://static001.geekbang.org/account/avatar/00/12/e5/ce/2978a69a.jpg","comment_is_top":false,"comment_ctime":1619491576,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1619491576","product_id":100056701,"comment_content":"缓存满了，进行策略删除的时候，会不会影响redis的性能呢？","like_count":0,"discussions":[{"author":{"id":1296255,"avatar":"https://static001.geekbang.org/account/avatar/00/13/c7/7f/5d975908.jpg","nickname":"杨","note":"","ucode":"B434931741D0CE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534827,"discussion_content":"有可能的，如果有大量数据同一时间过期会阻塞主线程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638283872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":285641,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1616935818,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1616935818","product_id":100056701,"comment_content":"大概 20 年前，有老师说以后的计算机内存会超过 1 GB，游戏可以完全在内存中运行，美好的未来。现在手机的内存已经超过 8 GB 了，但是游戏和应用也膨胀了。<br><br>如果不差钱，当然是大量采用 SSD 加内存。<br><br>考虑性价比，根据业务需要，结合“二八原则”和“重尾原则”，缓存设置为总数据量的 15% 到 30%。<br><br>替换策略讲的比较简单，只概述了 LRU 算法，LFU 应该是 Latest Frequent Used ？期待课代表给科普一下。<br><br>另外，Redis 其实不管脏数据写回数据库的事情。<br><br>替换策略的选择一般来说是 volatile-lru、allkeys-lru、allkeys-random，前两个没什么问题，但第三个为什么不是 volatile-random？<br><br>对于课后题，Redis 缓存对应 只读缓存 模式。<br><br>看了课后老师的回复，才注意到置顶数据的 volatile-lru 策略 + 不设置过期时间的巧妙用法。<br><br>之前好像提到，最好是给所有的缓存数据都设置过期时间。","like_count":0},{"had_liked":false,"id":284818,"user_name":"守望者","can_delete":false,"product_type":"c1","uid":1623487,"ip_address":"","ucode":"DEE375A5F2D57A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/sPORo6cN3GSVxjHj9nqSAPn7KG4wtSTqNUommjNndpf8qd7bHKHquuldXZfxD5nF1ldy4LeoAQNwSsOgcmWG9w/132","comment_is_top":false,"comment_ctime":1616485904,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616485904","product_id":100056701,"comment_content":"这节课的内容与第20课说的空间碎片自动清理好像都可以缓解内存空间满的问题吧?除了这两个我还能想到的有: 删除key空间释放，过期key删除，好像还有swap机制。这些机制和策略之间的联系是怎样的呢?","like_count":0},{"had_liked":false,"id":284285,"user_name":"芋头","can_delete":false,"product_type":"c1","uid":1227492,"ip_address":"","ucode":"A9C875548E4EE5","user_header":"https://static001.geekbang.org/account/avatar/00/12/ba/e4/6df89add.jpg","comment_is_top":false,"comment_ctime":1616150033,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616150033","product_id":100056701,"comment_content":"总结一下：最新版本有八种缓存淘汰策略，<br>volatile-lru、volatile-random volatile-flu volatile-ttl <br>allkeys-lru allkeys-random all keys-fly<br>还有一种是不淘汰<br><br><br>","like_count":0},{"had_liked":false,"id":282427,"user_name":"Vivian","can_delete":false,"product_type":"c1","uid":2366473,"ip_address":"","ucode":"1901ACEA677BA7","user_header":"https://static001.geekbang.org/account/avatar/00/24/1c/09/bc1a01cc.jpg","comment_is_top":false,"comment_ctime":1615249876,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615249876","product_id":100056701,"comment_content":"被淘汰的数据是指从内存中删除么？但是磁盘里的文件还存在，还是真的就删除了，没有了这个数据。","like_count":0},{"had_liked":false,"id":261528,"user_name":"Geek_c12f80","can_delete":false,"product_type":"c1","uid":2109120,"ip_address":"","ucode":"D5ADE29F16866B","user_header":"","comment_is_top":false,"comment_ctime":1605399061,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605399061","product_id":100056701,"comment_content":"再进一步确认下，如果内存使用没有达到maxmemory，volatile开头的淘汰策略会淘汰未过期数据吗？<br>volatile-ttl淘汰策略，是只要筛选出过期的数据淘汰就行了吗？还是需要根据过期时间排序，过期时间最久的淘汰掉？如果排序，也是类似lru随机选择候选集范围内排序吗？","like_count":0},{"had_liked":false,"id":257303,"user_name":"Geek_c12f80","can_delete":false,"product_type":"c1","uid":2109120,"ip_address":"","ucode":"D5ADE29F16866B","user_header":"","comment_is_top":false,"comment_ctime":1603934039,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1603934039","product_id":100056701,"comment_content":"如果采用volatile的淘汰策略，设置了过期时间，但是没有到过期时间的数据，会被淘汰吗？？","like_count":0,"discussions":[{"author":{"id":1675882,"avatar":"https://static001.geekbang.org/account/avatar/00/19/92/6a/dd37a054.jpg","nickname":"张y .","note":"","ucode":"85918469492F4C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411465,"discussion_content":"不会","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635933861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1840097,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJq1QledRhFicNMRYDJ1ibCveUqlrtIYhDCvAicOmmnia3GPrjjepDZhibXMJ0iabTsibVC2KMZtoIG4A9icg/132","nickname":"xuwen_chen","note":"","ucode":"03C766DEA69DF1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376050,"discussion_content":"会的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621942238,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1035257,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cb/f9/75d08ccf.jpg","nickname":"Mr.蜜","note":"","ucode":"C911B81198B3F5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":321608,"discussion_content":"没有设置过期时间的数据，不会淘汰。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604594659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":254607,"user_name":"范闲","can_delete":false,"product_type":"c1","uid":1073125,"ip_address":"","ucode":"F21FD7DF6BA53C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","comment_is_top":false,"comment_ctime":1603157560,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603157560","product_id":100056701,"comment_content":"1.经常用的写法就是旁路缓存。redis有直接返回，redis无请求数据库，然后再写回redis","like_count":0},{"had_liked":false,"id":253688,"user_name":"Geek_6d8c98","can_delete":false,"product_type":"c1","uid":2193932,"ip_address":"","ucode":"9CCDA0F83C066B","user_header":"","comment_is_top":false,"comment_ctime":1602833144,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602833144","product_id":100056701,"comment_content":"老师，触发淘汰策略后，redis每次会淘汰几个key呢。会不会一直有数据插入就一直触发淘汰策略啊？","like_count":0},{"had_liked":false,"id":253166,"user_name":"小氘","can_delete":false,"product_type":"c1","uid":1622109,"ip_address":"","ucode":"DA55B9A02D9EE0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erPMtAfnQdpx1yOZQ2ic7icqUs3tvibEjUXQMUXKiaakyuIho6k6vmdl46nrdWjXIjPIRg9Pmco00tR5w/132","comment_is_top":false,"comment_ctime":1602639949,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602639949","product_id":100056701,"comment_content":"课后思考题：Redis缓存对应只读缓存和读写缓存的同步直写。","like_count":0},{"had_liked":false,"id":253000,"user_name":"叶子。","can_delete":false,"product_type":"c1","uid":1393004,"ip_address":"","ucode":"3EF2CC36F0D09A","user_header":"https://static001.geekbang.org/account/avatar/00/15/41/6c/687c5dfb.jpg","comment_is_top":false,"comment_ctime":1602558566,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1602558566","product_id":100056701,"comment_content":"老师能帮我看看这个问题吗<br>数据淘汰是为了防止操作系统swap吗？我理解就像是JVM的-XMX设置了maxmemory之后是不是就不会发生swap了？因为swap之前说是发生在分配内存小于实际使用内存，而设置了maxmemory之后，当出现内存不足就发生了淘汰了，也就不会发生swap了？<br>","like_count":0,"discussions":[{"author":{"id":1296255,"avatar":"https://static001.geekbang.org/account/avatar/00/13/c7/7f/5d975908.jpg","nickname":"杨","note":"","ucode":"B434931741D0CE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534829,"discussion_content":"如果设置了内存限制不会swap，直接爆oom了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638284041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1022411,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/99/cb/8964faab.jpg","nickname":"-只是小小配角_","note":"","ucode":"EFC1CD54A23F39","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349156,"discussion_content":"个人理解：swap是操作系统的事情，如果Redis服务器上同时运行了其他服务，并且占用大量内存，操作系统在swap时，可能会把Redis的内存页写入到虚拟内存中","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612938656,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":252939,"user_name":"xueyuan","can_delete":false,"product_type":"c1","uid":1128121,"ip_address":"","ucode":"3DE20A723EBAFE","user_header":"https://static001.geekbang.org/account/avatar/00/11/36/b9/3b28f67c.jpg","comment_is_top":false,"comment_ctime":1602520184,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602520184","product_id":100056701,"comment_content":"读写模式的异步回写需要所有写请求都先在缓存中处理。等到这些增改的数据要被从缓存中淘汰出来时，缓存将它们写回后端数据库;这个redis做不到。<br><br>redis可以支持读写模式的同步回写和只读模式","like_count":0}]}