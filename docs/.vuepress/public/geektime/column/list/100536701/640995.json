{"id":640995,"title":"05｜实现完整的IoC容器：构建工厂体系并添加容器事件","content":"<p>你好，我是郭屹。</p><p>前面我们已经实现了IoC的核心部分，骨架已经有了，那怎么让这个IoC丰满起来呢？这就需要实现更多的功能，让我们的IoC更加完备。所以这节课我们将通过建立BeanFactory体系，添加容器事件等一系列操作，进一步完善IoC的功能。</p><h2>实现一个完整的IoC容器</h2><p>为了让我们的MiniSpring更加专业一点，也更像Spring一点，我们将实现3个功能点。</p><ol>\n<li>进一步增强扩展性，新增4个接口。</li>\n</ol><ul>\n<li>ListableBeanFactory</li>\n<li>ConfigurableBeanFactory</li>\n<li>ConfigurableListableBeanFactory</li>\n<li>EnvironmentCapable</li>\n</ul><ol start=\"2\">\n<li>实现DefaultListableBeanFactory，该类就是Spring IoC的引擎。</li>\n<li>改造ApplicationContext。</li>\n</ol><p>下面我们就一条条来看。</p><h3>增强扩展性</h3><p>首先我们来增强BeanFactory的扩展性，使它具有不同的特性。</p><p>我们以前定义的AutowireCapableBeanFactory就是在通用的BeanFactory的基础上添加了Autowired注解特性。比如可以将Factory内部管理的Bean作为一个集合来对待，获取Bean的数量，得到所有Bean的名字，按照某个类型获取Bean列表等等。这个特性就定义在ListableBeanFactory中。</p><!-- [[[read_end]]] --><pre><code class=\"language-java\">public interface ListableBeanFactory extends BeanFactory {\n&nbsp; &nbsp; boolean containsBeanDefinition(String beanName);\n&nbsp; &nbsp; int getBeanDefinitionCount();\n&nbsp; &nbsp; String[] getBeanDefinitionNames();\n&nbsp; &nbsp; String[] getBeanNamesForType(Class&lt;?&gt; type);\n&nbsp; &nbsp; &lt;T&gt; Map&lt;String, T&gt; getBeansOfType(Class&lt;T&gt; type) throws BeansException;\n}\n</code></pre><p>我们还可以将维护Bean之间的依赖关系以及支持Bean处理器也看作一个独立的特性，这个特性定义在ConfigurableBeanFactory接口中。</p><pre><code class=\"language-java\">public interface ConfigurableBeanFactory extends&nbsp;\nBeanFactory,SingletonBeanRegistry {\n&nbsp; &nbsp; String SCOPE_SINGLETON = \"singleton\";\n&nbsp; &nbsp; String SCOPE_PROTOTYPE = \"prototype\";\n&nbsp; &nbsp; void addBeanPostProcessor(BeanPostProcessor beanPostProcessor);\n&nbsp; &nbsp; int getBeanPostProcessorCount();\n&nbsp; &nbsp; void registerDependentBean(String beanName, String dependentBeanName);\n&nbsp; &nbsp; String[] getDependentBeans(String beanName);\n&nbsp; &nbsp; String[] getDependenciesForBean(String beanName);\n}\n</code></pre><p>然后还可以集成，用一个ConfigurableListableBeanFactory接口把AutowireCapableBeanFactory、ListableBeanFactory和ConfigurableBeanFactory合并在一起。</p><pre><code class=\"language-java\">package com.minis.beans.factory.config;\nimport com.minis.beans.factory.ListableBeanFactory;\npublic interface ConfigurableListableBeanFactory&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; extends ListableBeanFactory, AutowireCapableBeanFactory,&nbsp;\nConfigurableBeanFactory {\n}\n</code></pre><p>由上述接口定义的方法可以看出，这些接口都给通用的BeanFactory与BeanDefinition新增了众多处理方法，用来增强各种特性。</p><p>在Java语言的设计中，一个Interface代表的是一种特性或者能力，我们把这些特性或能力一个个抽取出来，各自独立互不干扰。如果一个具体的类，想具备某些特性或者能力，就去实现这些interface，随意组合。这是一种良好的设计原则，叫<strong>interface segregation</strong>（接口隔离原则）。这条原则在Spring框架中用得很多，你可以注意一下。</p><p>由于ConfigurableListableBeanFactory继承了AutowireCapableBeanFactory，所以我们需要调整之前定义的AutowireCapableBeanFactory，由class改为interface。</p><pre><code class=\"language-java\">public interface AutowireCapableBeanFactory&nbsp; extends BeanFactory{\n&nbsp; &nbsp; int AUTOWIRE_NO = 0;\n&nbsp; &nbsp; int AUTOWIRE_BY_NAME = 1;\n&nbsp; &nbsp; int AUTOWIRE_BY_TYPE = 2;\n&nbsp; &nbsp; Object applyBeanPostProcessorsBeforeInitialization(Object existingBean,&nbsp;\nString beanName) throws BeansException;\n&nbsp; &nbsp; Object applyBeanPostProcessorsAfterInitialization(Object existingBean,&nbsp;\nString beanName) throws BeansException;\n}\n</code></pre><p>新增抽象类AbstractAutowireCapableBeanFactory替代原有的实现类。</p><pre><code class=\"language-java\">public abstract class AbstractAutowireCapableBeanFactory&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extends AbstractBeanFactory implements&nbsp;\nAutowireCapableBeanFactory{\n&nbsp; &nbsp; private final List&lt;BeanPostProcessor&gt; beanPostProcessors = new&nbsp;\nArrayList&lt;BeanPostProcessor&gt;();\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; public void addBeanPostProcessor(BeanPostProcessor beanPostProcessor) {\n&nbsp; &nbsp; &nbsp; &nbsp; this.beanPostProcessors.remove(beanPostProcessor);\n&nbsp; &nbsp; &nbsp; &nbsp; this.beanPostProcessors.add(beanPostProcessor);\n&nbsp; &nbsp; }\n&nbsp; &nbsp; public int getBeanPostProcessorCount() {\n&nbsp; &nbsp; &nbsp; &nbsp; return this.beanPostProcessors.size();\n&nbsp; &nbsp; }\n&nbsp; &nbsp; public List&lt;BeanPostProcessor&gt; getBeanPostProcessors() {\n&nbsp; &nbsp; &nbsp; &nbsp; return this.beanPostProcessors;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; public Object applyBeanPostProcessorsBeforeInitialization(Object&nbsp;\nexistingBean, String beanName)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throws BeansException {\n&nbsp; &nbsp; &nbsp; &nbsp; Object result = existingBean;\n&nbsp; &nbsp; &nbsp; &nbsp; for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; beanProcessor.setBeanFactory(this);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = beanProcessor.postProcessBeforeInitialization(result,&nbsp;\nbeanName);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (result == null) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return result;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; return result;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; public Object applyBeanPostProcessorsAfterInitialization(Object&nbsp;\nexistingBean, String beanName)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throws BeansException {\n&nbsp; &nbsp; &nbsp; &nbsp; Object result = existingBean;\n&nbsp; &nbsp; &nbsp; &nbsp; for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = beanProcessor.postProcessAfterInitialization(result,&nbsp;\nbeanName);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (result == null) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return result;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; return result;\n&nbsp; &nbsp; }&nbsp; &nbsp;\n}\n</code></pre><p>上述代码与之前的实现类一致，在此不多赘述。</p><h3>环境</h3><p>除了扩充BeanFactory体系，我们还打算给容器增加一些环境因素，使一些容器整体所需要的属性有个地方存储访问。</p><p>在core目录下新建env目录，增加PropertyResolver.java、EnvironmentCapable.java、Environment.java三个接口类。EnvironmentCapable主要用于获取Environment实例，Environment则继承PropertyResoulver接口，用于获取属性。所有的ApplicationContext都实现了Environment接口。</p><p>Environment.java 接口</p><pre><code class=\"language-java\">public interface Environment extends PropertyResolver {\n&nbsp; &nbsp; String[] getActiveProfiles();\n&nbsp; &nbsp; String[] getDefaultProfiles();\n&nbsp; &nbsp; boolean acceptsProfiles(String... profiles);\n}\n</code></pre><p>EnvironmentCapable.java 接口</p><pre><code class=\"language-java\">public interface EnvironmentCapable {\n&nbsp; &nbsp; Environment getEnvironment();\n}\n</code></pre><p>PropertyResolver.java 接口</p><pre><code class=\"language-java\">public interface PropertyResolver {\n&nbsp; &nbsp; boolean containsProperty(String key);\n&nbsp; &nbsp; String getProperty(String key);\n&nbsp; &nbsp; String getProperty(String key, String defaultValue);\n&nbsp; &nbsp; &lt;T&gt; T getProperty(String key, Class&lt;T&gt; targetType);\n&nbsp; &nbsp; &lt;T&gt; T getProperty(String key, Class&lt;T&gt; targetType, T defaultValue);\n&nbsp; &nbsp; &lt;T&gt; Class&lt;T&gt; getPropertyAsClass(String key, Class&lt;T&gt; targetType);\n&nbsp; &nbsp; String getRequiredProperty(String key) throws IllegalStateException;\n&nbsp; &nbsp; &lt;T&gt; T getRequiredProperty(String key, Class&lt;T&gt; targetType) throws&nbsp;\nIllegalStateException;\n&nbsp; &nbsp; String resolvePlaceholders(String text);\n&nbsp; &nbsp; String resolveRequiredPlaceholders(String text) throws&nbsp;\nIllegalArgumentException;\n}\n</code></pre><h3>IoC引擎</h3><p>接下来我们看看IoC引擎——DefaultListableBeanFactory的实现。</p><pre><code class=\"language-java\">public class DefaultListableBeanFactory extends&nbsp;\nAbstractAutowireCapableBeanFactory&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; implements ConfigurableListableBeanFactory{\n&nbsp; &nbsp; public int getBeanDefinitionCount() {\n&nbsp; &nbsp; &nbsp; &nbsp; return this.beanDefinitionMap.size();\n&nbsp; &nbsp; }\n&nbsp; &nbsp; public String[] getBeanDefinitionNames() {\n&nbsp; &nbsp; &nbsp; &nbsp; return (String[]) this.beanDefinitionNames.toArray();\n&nbsp; &nbsp; }\n&nbsp; &nbsp; public String[] getBeanNamesForType(Class&lt;?&gt; type) {\n&nbsp; &nbsp; &nbsp; &nbsp; List&lt;String&gt; result = new ArrayList&lt;&gt;();\n&nbsp; &nbsp; &nbsp; &nbsp; for (String beanName : this.beanDefinitionNames) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; boolean matchFound = false;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BeanDefinition mbd = this.getBeanDefinition(beanName);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Class&lt;?&gt; classToMatch = mbd.getClass();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (type.isAssignableFrom(classToMatch)) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchFound = true;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchFound = false;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (matchFound) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result.add(beanName);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; return (String[]) result.toArray();\n&nbsp; &nbsp; }\n&nbsp; &nbsp; @SuppressWarnings(\"unchecked\")\n&nbsp; &nbsp; @Override\n&nbsp; &nbsp; public &lt;T&gt; Map&lt;String, T&gt; getBeansOfType(Class&lt;T&gt; type) throws BeansException\n{\n&nbsp; &nbsp; &nbsp; &nbsp; String[] beanNames = getBeanNamesForType(type);\n&nbsp; &nbsp; &nbsp; &nbsp; Map&lt;String, T&gt; result = new LinkedHashMap&lt;&gt;(beanNames.length);\n&nbsp; &nbsp; &nbsp; &nbsp; for (String beanName : beanNames) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object beanInstance = getBean(beanName);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result.put(beanName, (T) beanInstance);\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; return result;\n&nbsp; &nbsp; }\n}\n\n</code></pre><p>从上述代码中，似乎看不出这个类是如何成为IoC引擎的，因为它的实现都是很简单地获取各种属性的方法。它成为引擎的秘诀在于<strong>它继承了其他BeanFactory类来实现Bean的创建管理功能</strong>。从代码可以看出它继承了AbstractAutowireCapableBeanFactory并实现了 ConfigurableListableBeanFactory接口。</p><p>参看Spring框架的这一部分，整个继承体系图。</p><p><img src=\"https://static001.geekbang.org/resource/image/b9/c1/b9dc766efc3425a77fbb3d87c5dc7ec1.png?wh=1119x578\" alt=\"图片\" title=\"图源自网络\"></p><p>可以看出，我们的MiniSpring跟Spring框架设计得几乎是一模一样。当然，这是我们有意为之，我们手写MiniSpring就是为了深入理解Spring。</p><p>当ClassPathXmlApplicationContext这个Spring核心启动类运行时，注入了DefaultListableBeanFactory，为整个Spring框架做了默认实现，这样就完成了框架内部的逻辑闭环。</p><h3>事件</h3><p>接着我们来完善事件的发布与监听，包括ApplicationEvent、ApplicationListener、ApplicationEventPublisher以及ContextRefreshEvent，事件一经发布就能让监听者监听到。</p><p>ApplicationEvent</p><pre><code class=\"language-java\">public class ApplicationEvent extends EventObject {\n&nbsp; &nbsp; private static final long serialVersionUID = 1L;\n&nbsp; &nbsp; protected String msg = null;\n&nbsp; &nbsp; public ApplicationEvent(Object arg0) {\n&nbsp; &nbsp; &nbsp; &nbsp; super(arg0);\n&nbsp; &nbsp; &nbsp; &nbsp; this.msg = arg0.toString();\n&nbsp; &nbsp; }\n}\n</code></pre><p>ApplicationListener</p><pre><code class=\"language-java\">public class ApplicationListener implements EventListener {\n&nbsp; &nbsp; void onApplicationEvent(ApplicationEvent event) {\n&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(event.toString());\n&nbsp; &nbsp; }\n}\n</code></pre><p>ContextRefreshEvent</p><pre><code class=\"language-java\">public class ContextRefreshEvent extends ApplicationEvent{\n&nbsp; &nbsp; private static final long serialVersionUID = 1L;\n&nbsp; &nbsp; public ContextRefreshEvent(Object arg0) {\n&nbsp; &nbsp; &nbsp; &nbsp; super(arg0);\n&nbsp; &nbsp; }\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; public String toString() {\n&nbsp; &nbsp; &nbsp; &nbsp; return this.msg;\n&nbsp; &nbsp; }\n}\n</code></pre><p>ApplicationEventPublisher</p><pre><code class=\"language-java\">public interface ApplicationEventPublisher {\n&nbsp; &nbsp; void publishEvent(ApplicationEvent event);\n&nbsp; &nbsp; void addApplicationListener(ApplicationListener listener);\n}\n</code></pre><p>可以看出，框架的EventPublisher，本质是对JDK事件类的封装。接口已经定义好了，接下来我们实现一个最简单的事件发布者SimpleApplicationEventPublisher。</p><pre><code class=\"language-java\">public class SimpleApplicationEventPublisher implements&nbsp;\nApplicationEventPublisher{\n&nbsp; &nbsp; List&lt;ApplicationListener&gt; listeners = new ArrayList&lt;&gt;();\n&nbsp; &nbsp; @Override\n&nbsp; &nbsp; public void publishEvent(ApplicationEvent event) {\n&nbsp; &nbsp; &nbsp; &nbsp; for (ApplicationListener listener : listeners) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; listener.onApplicationEvent(event);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n&nbsp; &nbsp; @Override\n&nbsp; &nbsp; public void addApplicationListener(ApplicationListener listener) {\n&nbsp; &nbsp; &nbsp; &nbsp; this.listeners.add(listener);\n&nbsp; &nbsp; }\n}\n</code></pre><p>这个事件发布监听机制就可以为后面ApplicationContext的使用服务了。</p><h2>完整的ApplicationContext</h2><p>最后，我们来完善ApplicationContext，并把它作为公共接口，所有的上下文都实现自</p><p>ApplicationContext，支持上下文环境和事件发布。</p><pre><code class=\"language-java\">public interface ApplicationContext\n&nbsp; &nbsp; &nbsp; &nbsp; extends EnvironmentCapable, ListableBeanFactory, ConfigurableBeanFactory,&nbsp;\nApplicationEventPublisher{\n}\n</code></pre><p>我们计划做4件事。</p><ol>\n<li>抽取ApplicationContext接口，实现更多有关上下文的内容。</li>\n<li>支持事件的发布与监听。</li>\n<li>新增AbstractApplicationContext，规范刷新上下文refresh方法的步骤规范，且将每一步骤进行抽象，提供默认实现类，同时支持自定义。</li>\n<li>完成刷新之后发布事件。</li>\n</ol><p>首先我们来增加ApplicationContext接口的内容，丰富它的功能。</p><pre><code class=\"language-java\">public interface ApplicationContext&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; extends EnvironmentCapable, ListableBeanFactory,&nbsp;\nConfigurableBeanFactory, ApplicationEventPublisher{\n&nbsp; &nbsp; String getApplicationName();\n&nbsp; &nbsp; long getStartupDate();\n&nbsp; &nbsp; ConfigurableListableBeanFactory getBeanFactory() throws&nbsp;\nIllegalStateException;\n&nbsp; &nbsp; void setEnvironment(Environment environment);\n&nbsp; &nbsp; Environment getEnvironment();\n&nbsp; &nbsp; void addBeanFactoryPostProcessor(BeanFactoryPostProcessor postProcessor);\n&nbsp; &nbsp; void refresh() throws BeansException, IllegalStateException;\n&nbsp; &nbsp; void close();\n&nbsp; &nbsp; boolean isActive();\n}\n</code></pre><p>还是按照以前的模式，先定义接口，然后用一个抽象类搭建框架，最后提供一个具体实现类进行默认实现。Spring的这个interface-abstract-class模式是值得我们学习的，它极大地增强了框架的扩展性。</p><p>我们重点看看AbstractApplicationContext的实现。因为现在我们只做到了从XML里读取配置，用来获取应用的上下文信息，但实际Spring框架里不只支持这一种方式。但无论哪种方式，究其本质都是对应用上下文的处理，所以我们来抽象ApplicationContext的公共部分。</p><pre><code class=\"language-java\">public abstract class AbstractApplicationContext implements ApplicationContext{\n&nbsp; &nbsp; private Environment environment;\n&nbsp; &nbsp; private final List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors = new&nbsp;\nArrayList&lt;&gt;();\n&nbsp; &nbsp; private long startupDate;\n&nbsp; &nbsp; private final AtomicBoolean active = new AtomicBoolean();\n&nbsp; &nbsp; private final AtomicBoolean closed = new AtomicBoolean();\n&nbsp; &nbsp; private ApplicationEventPublisher applicationEventPublisher;\n&nbsp; &nbsp; @Override\n&nbsp; &nbsp; public Object getBean(String beanName) throws BeansException {\n&nbsp; &nbsp; &nbsp; &nbsp; return getBeanFactory().getBean(beanName);\n&nbsp; &nbsp; }\n&nbsp; &nbsp; public List&lt;BeanFactoryPostProcessor&gt; getBeanFactoryPostProcessors() {\n&nbsp; &nbsp; &nbsp; &nbsp; return this.beanFactoryPostProcessors;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; public void refresh() throws BeansException, IllegalStateException {\n&nbsp; &nbsp; &nbsp; &nbsp; postProcessBeanFactory(getBeanFactory());\n&nbsp; &nbsp; &nbsp; &nbsp; registerBeanPostProcessors(getBeanFactory());\n&nbsp; &nbsp; &nbsp; &nbsp; initApplicationEventPublisher();\n&nbsp; &nbsp; &nbsp; &nbsp; onRefresh();\n&nbsp; &nbsp; &nbsp; &nbsp; registerListeners();\n&nbsp; &nbsp; &nbsp; &nbsp; finishRefresh();\n&nbsp; &nbsp; }\n&nbsp; &nbsp; abstract void registerListeners();\n&nbsp; &nbsp; abstract void initApplicationEventPublisher();\n&nbsp; &nbsp; abstract void postProcessBeanFactory(ConfigurableListableBeanFactory&nbsp;\nbeanFactory);\n&nbsp; &nbsp; abstract void registerBeanPostProcessors(ConfigurableListableBeanFactory&nbsp;\nbeanFactory);\n&nbsp; &nbsp; abstract void onRefresh();\n&nbsp; &nbsp; abstract void finishRefresh();\n&nbsp; &nbsp; @Override\n&nbsp; &nbsp; public String getApplicationName() {\n&nbsp; &nbsp; &nbsp; &nbsp; return \"\";\n&nbsp; &nbsp; }\n&nbsp; &nbsp; @Override\n&nbsp; &nbsp; public long getStartupDate() {\n&nbsp; &nbsp; &nbsp; &nbsp; return this.startupDate;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; @Override\n&nbsp; &nbsp; public abstract ConfigurableListableBeanFactory getBeanFactory() throws&nbsp;\nIllegalStateException;\n&nbsp; &nbsp; @Override\n&nbsp; &nbsp; public void addBeanFactoryPostProcessor(BeanFactoryPostProcessor&nbsp;\npostProcessor) {\n&nbsp; &nbsp; &nbsp; &nbsp; this.beanFactoryPostProcessors.add(postProcessor);\n&nbsp; &nbsp; }\n&nbsp; &nbsp; @Override\n&nbsp; &nbsp; public void close() {\n&nbsp; &nbsp; }\n&nbsp; &nbsp; @Override\n&nbsp; &nbsp; public boolean isActive(){\n&nbsp; &nbsp; &nbsp; &nbsp; return true;\n&nbsp; &nbsp; }\n    //省略包装beanfactory的方法\n}\n</code></pre><p>上面这段代码的核心是refresh()方法的定义，而这个方法又由下面这几个步骤组成。</p><pre><code class=\"language-java\">    abstract void registerListeners();\n    abstract void initApplicationEventPublisher();\n    abstract void postProcessBeanFactory(ConfigurableListableBeanFactory \nbeanFactory);\n    abstract void registerBeanPostProcessors(ConfigurableListableBeanFactory \nbeanFactory);\n    abstract void onRefresh();\n    abstract void finishRefresh();\n</code></pre><p>看名字就比较容易理解，首先是注册监听者，接下来初始化事件发布者，随后处理Bean以及对Bean的状态进行一些操作，最后是将初始化完毕的Bean进行应用上下文刷新以及完成刷新后进行自定义操作。因为这些方法都有abstract修饰，允许把这些步骤交给用户自定义处理，因此极大地增强了扩展性。</p><p>我们现在已经拥有了一个ClassPathXmlApplicationContext，我们以这个类为例，看看如何实现上面的几个步骤。ClassPathXmlApplicationContext代码改造如下：</p><pre><code class=\"language-java\">public class ClassPathXmlApplicationContext extends AbstractApplicationContext{\n&nbsp; &nbsp; DefaultListableBeanFactory beanFactory;\n&nbsp; &nbsp; private final List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors = new&nbsp;\nArrayList&lt;&gt;();\n&nbsp; &nbsp; public ClassPathXmlApplicationContext(String fileName) {\n&nbsp; &nbsp; &nbsp; &nbsp; this(fileName, true);\n&nbsp; &nbsp; }\n&nbsp; &nbsp; public ClassPathXmlApplicationContext(String fileName, boolean isRefresh) {\n&nbsp; &nbsp; &nbsp; &nbsp; Resource resource = new ClassPathXmlResource(fileName);\n&nbsp; &nbsp; &nbsp; &nbsp; DefaultListableBeanFactory beanFactory = new&nbsp;\nDefaultListableBeanFactory();\n&nbsp; &nbsp; &nbsp; &nbsp; XmlBeanDefinitionReader reader = new&nbsp;\nXmlBeanDefinitionReader(beanFactory);\n&nbsp; &nbsp; &nbsp; &nbsp; reader.loadBeanDefinitions(resource);\n&nbsp; &nbsp; &nbsp; &nbsp; this.beanFactory = beanFactory;\n&nbsp; &nbsp; &nbsp; &nbsp; if (isRefresh) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; refresh();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp;}\n&nbsp; &nbsp; }\n&nbsp; &nbsp; @Override\n&nbsp; &nbsp; void registerListeners() {\n&nbsp; &nbsp; &nbsp; &nbsp; ApplicationListener listener = new ApplicationListener();\n&nbsp; &nbsp; &nbsp; &nbsp; this.getApplicationEventPublisher().addApplicationListener(listener);\n&nbsp; &nbsp; }\n&nbsp; &nbsp; @Override\n&nbsp; &nbsp; void initApplicationEventPublisher() {\n&nbsp; &nbsp; &nbsp; &nbsp; ApplicationEventPublisher aep = new SimpleApplicationEventPublisher();\n&nbsp; &nbsp; &nbsp; &nbsp; this.setApplicationEventPublisher(aep);\n&nbsp; &nbsp; }\n&nbsp; &nbsp; @Override\n&nbsp; &nbsp; void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n&nbsp; &nbsp; }\n&nbsp; &nbsp; @Override\n&nbsp; &nbsp; public void publishEvent(ApplicationEvent event) {\n&nbsp; &nbsp; &nbsp; &nbsp; this.getApplicationEventPublisher().publishEvent(event);\n&nbsp; &nbsp; }\n&nbsp; &nbsp; @Override\n&nbsp; &nbsp; public void addApplicationListener(ApplicationListener listener) {\n&nbsp; &nbsp; &nbsp; &nbsp; this.getApplicationEventPublisher().addApplicationListener(listener);\n&nbsp; &nbsp; }\n&nbsp; &nbsp; public void addBeanFactoryPostProcessor(BeanFactoryPostProcessor&nbsp;\npostProcessor) {\n&nbsp; &nbsp; &nbsp; &nbsp; this.beanFactoryPostProcessors.add(postProcessor);\n&nbsp; &nbsp; }\n&nbsp; &nbsp; @Override\n&nbsp; &nbsp; void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory)&nbsp;\n{\n&nbsp; &nbsp; &nbsp; &nbsp; this.beanFactory.addBeanPostProcessor(new&nbsp;\nAutowiredAnnotationBeanPostProcessor());\n&nbsp; &nbsp; }\n&nbsp; &nbsp; @Override\n&nbsp; &nbsp; void onRefresh() {\n&nbsp; &nbsp; &nbsp; &nbsp; this.beanFactory.refresh();\n&nbsp; &nbsp; }\n&nbsp; &nbsp; @Override\n&nbsp; &nbsp; public ConfigurableListableBeanFactory getBeanFactory() throws&nbsp;\nIllegalStateException {\n&nbsp; &nbsp; &nbsp; &nbsp; return this.beanFactory;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; @Override\n&nbsp; &nbsp; void finishRefresh() {\n&nbsp; &nbsp; &nbsp; &nbsp; publishEvent(new ContextRefreshEvent(\"Context Refreshed...\"));\n&nbsp; &nbsp; }\n}\n</code></pre><p>上述代码分别实现了几个抽象方法，就很高效地把ClassPathXmlApplicationContext类融入到了ApplicationContext框架里了。Spring的这个设计模式值得我们学习，采用抽象类的方式来解耦，为用户提供了极大的扩展性的便利，这也是Spring框架强大的原因之一。Spring能集成MyBatis、MySQL、Redis等框架，少不了设计模式在背后支持。</p><p>至此，我们的IoC容器就完成了，它很简单，但是这个容器麻雀虽小五脏俱全，关键是为我们深入理解Spring框架提供了很好的解剖样本。</p><p><img src=\"https://static001.geekbang.org/resource/image/8d/a1/8d7cbd21555d7676c9d75c05f66d23a1.jpg?wh=2822x1890\" alt=\"\"></p><h2>小结</h2><p>经过这节课的学习，我们初步构造了一个完整的IoC容器，目前它的功能包括4项。</p><ol>\n<li>识别配置文件中的Bean定义，创建Bean，并放入容器中进行管理。</li>\n<li>支持配置方式或者注解方式进行Bean的依赖注入。</li>\n<li>构建了BeanFactory体系。</li>\n<li>容器应用上下文和事件发布。<br>\n对照Spring框架，上述几点就是Spring IoC的核心。通过这个容器，我们构建应用程序的时候，将业务逻辑封装在Bean中，把对Bean的创建管理交给框架，即所谓的“控制反转”，应用程序与框架程序互动，共同运行完整程序。</li>\n</ol><p>实现这些概念和特性的手段和具体代码，我们都有意模仿了Spring，它们的结构和名字都是一样的，所以你回头阅读Spring框架本身代码的时候，会觉得很熟悉，学习曲线平滑。我们沿着大师的脚步往前走，不断参照大师的作品，吸收大师的养分培育自己，让我们的MiniSpring一步步成长为一棵大树。</p><p>完整源代码参见 <a href=\"https://github.com/YaleGuo/minis\">https://github.com/YaleGuo/minis</a></p><h2>课后题</h2><p>学完这节课，我也给你留一道思考题。我们的容器以单例模式管理所有的Bean，那么怎么应对多线程环境？欢迎你在留言区与我交流讨论，也欢迎你把这节课分享给需要的朋友，我们下节课见！</p>","comments":[{"had_liked":false,"id":375581,"user_name":"KernelStone","can_delete":false,"product_type":"c1","uid":2736140,"ip_address":"广东","ucode":"B75C0100AD52B8","user_header":"https://static001.geekbang.org/account/avatar/00/29/c0/0c/f726d4d0.jpg","comment_is_top":false,"comment_ctime":1685690414,"is_pvip":false,"replies":[{"id":137093,"content":"你这个总结真好！","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1685706686,"ip_address":"澳大利亚","comment_id":375581,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"这一小结其实新增的内容不算多！只是对之前已有的代码进行结构调整。在项目中对DefaultListableBeanFactory生成UML结构图，再进行从上到下的梳理，这样会舒服一些。\n\n0、【接口】BF，Bean工厂\n1、【接口】SingletonBeanRegistry，单例Bean仓库\n2、DefaultSingletonBeanRegistry，单例Bean仓库默认实现。提供了 1 注册列表 2 单例容器 3 依赖注入管理信息（两个Map，应该是依赖 &amp; 被依赖）\n3、【接口】BeanDefinitionRegistry【接口】ListableBF，这两个对照看差异。前者强调对BeanDefinition进行操作，后者强调是对List集合进行操作。\n4、【接口】ConfigurableBF，Bean处理器（add &amp; get，没有apply），以及管理依赖信息。\n5、【接口】AutowireCapableBF，提供自动装配选项（No、byName、byType），并在初始化前后应用（apply）Bean处理器。\n6、【集成接口】ConfigurableListableBF，无内容。\n7、【抽象类】AbstractBF，主要是refresh()，invokeInitMethod()，createBean()，构造器注入和属性注入。\n8、AbstractAutowireCapableBF，提供成员List&lt;BeanPostProcessor&gt;！也因此它可以通过该成员进行更多的bean处理器操作，即add、get、apply在此有了具体实现。\n9、DefaultListableBF，其实没有啥，打开一看只Override了【接口】ListableBF中的4个方法，其余是默认继承。（即沿着类结构往上一堆，上面也说过了）\n\n因此，这节课真没什么新东西，不过梳理这个新的工厂体系，倒是很麻烦。。","like_count":8,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":620015,"discussion_content":"你这个总结真好！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1685706686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371070,"user_name":"马儿","can_delete":false,"product_type":"c1","uid":2247080,"ip_address":"四川","ucode":"542E23D7B6AB01","user_header":"","comment_is_top":false,"comment_ctime":1679504780,"is_pvip":false,"replies":[{"id":135392,"content":"你很用心。\n1，是重复了。\n2，程序最后变成了BeanPostProcessor接口，你接着看。\n3，后面有个beanfatory的继承关系图，你可以看看。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679570032,"ip_address":"澳大利亚","comment_id":371070,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"请教老师一下,\n1.ClassPathXmlApplicationContext和AbstractApplicationContext都有beanFactoryPostProcessors属性，是不是重复了呢？感觉直接复用父类的这个属性和相关方法也是可以的。\n2.AbstractAutowireCapableBeanFactory这个类中的beanPostProcessors属性写死了是AutowiredAnnotationBeanPostProcessor，不符合面向接口编程的风格。另外由于没有面向BeanPostProcessor导致DefaultListableBeanFactory需要再实现一遍 SingletonBeanRegistry\n3.AbstractBeanFactory实现了BeanFactory又写了两个抽象方法applyBeanPostProcessorsBeforeInitialization和applyBeanPostProcessorAfterInitialization，这里为什么不直接实现AutowireCapableBeanFactory呢？","like_count":3,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":610461,"discussion_content":"你很用心。\n1，是重复了。\n2，程序最后变成了BeanPostProcessor接口，你接着看。\n3，后面有个beanfatory的继承关系图，你可以看看。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679570032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":2247080,"avatar":"","nickname":"马儿","note":"","ucode":"542E23D7B6AB01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":610491,"discussion_content":"老师，第三个问题这里我还是不太明白。AbstractBeanFactory需要Bean处理器的能力可以直接实现AutowireCapableBeanFactory接口，并且他是抽象类，也不需要自己来具体实现这个接口，只需要交给子类就可以了。这里还在自己的方法列表里维护两个和AutowireCapableBeanFactory接口一致的方法的目的是什么呢？这样是不是将Bean处理器的能力耦合到了AbstractBeanFactory中。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1679578706,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":610461,"ip_address":"四川","group_id":0},"score":610491,"extra":""},{"author":{"id":1006025,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/c9/f44cb7f3.jpg","nickname":"爪哇夜未眠","note":"","ucode":"BBEB80EB670770","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2247080,"avatar":"","nickname":"马儿","note":"","ucode":"542E23D7B6AB01","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":620026,"discussion_content":"我觉得你说的有道理，让AbstractBeanFactory直接实现AutowireCapableBeanFactory接口也没什么问题，这样AbstractAutowireCapableBeanFactory 继承AbstractBeanFactory不需要声明实现AutowireCapableBeanFactory了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1685718514,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":610491,"ip_address":"北京","group_id":0},"score":620026,"extra":""}]}]},{"had_liked":false,"id":372186,"user_name":"CSY.","can_delete":false,"product_type":"c1","uid":2616736,"ip_address":"河南","ucode":"0D0C668597ED0C","user_header":"https://static001.geekbang.org/account/avatar/00/27/ed/a0/53b36d89.jpg","comment_is_top":false,"comment_ctime":1680831570,"is_pvip":false,"replies":[{"id":135842,"content":"并没有特别的理由，就是参考的Spring的做法。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1680863186,"ip_address":"澳大利亚","comment_id":372186,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"老师我有个问题\nConfigurableBeanFactory 中的 dependentBeanMap 等几个方法为什么要使用同级继承在DefaultSingletonBeanRegistry实现，而不在AbstractBeanFactory等中实现？","like_count":1,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612717,"discussion_content":"并没有特别的理由，就是参考的Spring的做法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680863186,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371945,"user_name":"啊良梓是我","can_delete":false,"product_type":"c1","uid":1655117,"ip_address":"广东","ucode":"E42FC1A60D331C","user_header":"https://static001.geekbang.org/account/avatar/00/19/41/4d/f6d6d13a.jpg","comment_is_top":false,"comment_ctime":1680535802,"is_pvip":false,"replies":[{"id":135771,"content":"你再仔细看代码，这个class代表的是哪个？","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1680587669,"ip_address":"澳大利亚","comment_id":371945,"utype":1}],"discussion_count":7,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"BeanDefinition mbd = this.getBeanDefinition(beanName); Class classToMatch = mbd.getClass();\n这里为什么是拿BeanDefinition的Class的?这样子没意义吧?或者我漏掉什么了?\n前面存储Bean class 是 BeanDefinition的BeanName 才对.","like_count":1,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612279,"discussion_content":"你再仔细看代码，这个class代表的是哪个？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680587669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":3573969,"avatar":"","nickname":"Geek_77792b","note":"","ucode":"C5B0F7F271531E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":621934,"discussion_content":"这个 classToMatch 就是 BeanDefinition 的class呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1687784043,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":612279,"ip_address":"浙江","group_id":0},"score":621934,"extra":""}]},{"author":{"id":1285431,"avatar":"https://static001.geekbang.org/account/avatar/00/13/9d/37/b2b73806.jpg","nickname":"沧海","note":"","ucode":"8ED876B8DE5CEE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":614661,"discussion_content":"我也觉得这里获取bean class有问题，老师的实现获取的是BeanDefinition的class了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1681864210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2342711,"avatar":"https://static001.geekbang.org/account/avatar/00/23/bf/37/10f71592.jpg","nickname":"开车疾如风","note":"","ucode":"84B17E8FC5B0DF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1285431,"avatar":"https://static001.geekbang.org/account/avatar/00/13/9d/37/b2b73806.jpg","nickname":"沧海","note":"","ucode":"8ED876B8DE5CEE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":618737,"discussion_content":"是的，包括前面的章节，在这里都是错的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1684491086,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":614661,"ip_address":"广东","group_id":0},"score":618737,"extra":""}]},{"author":{"id":3684313,"avatar":"","nickname":"Geek_f7230c","note":"","ucode":"A0FF2CE8514905","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":624897,"discussion_content":"就是错的啊，呵呵","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1691039881,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2459923,"avatar":"https://static001.geekbang.org/account/avatar/00/25/89/13/0d3c5008.jpg","nickname":"最好不过","note":"","ucode":"C7DBCD08402DF8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":629585,"discussion_content":"就是错的，前面也有这个问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1697364037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2440080,"avatar":"https://static001.geekbang.org/account/avatar/00/25/3b/90/791d0f5e.jpg","nickname":"可亲","note":"","ucode":"3511AFEEF541E1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612536,"discussion_content":"不对吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680773410,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"山西","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371514,"user_name":"Geek_513706","can_delete":false,"product_type":"c1","uid":2918634,"ip_address":"内蒙古","ucode":"27DAA0B4F4C35D","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/dRrXbUnH82RRrHUSbocrgrIyyLah1Ip1ooDT5sdibn6RhmOMsD9piaiaFwsvU1T7jwU3hF6MHib7ibxqiapBVDoicsOng/132","comment_is_top":false,"comment_ctime":1680003562,"is_pvip":false,"replies":[{"id":135579,"content":"这个建议已经接纳了，后面的文稿都带上了。完整代码要看Github上的。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1680087411,"ip_address":"澳大利亚","comment_id":371514,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"老师，想提个建议，以后添加代码的时候能不能把添加到哪个包里面说清楚","like_count":1,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":611439,"discussion_content":"这个建议已经接纳了，后面的文稿都带上了。完整代码要看Github上的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680087411,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371246,"user_name":"风轻扬","can_delete":false,"product_type":"c1","uid":1542987,"ip_address":"北京","ucode":"DB972F2DF059C4","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/15ab499a.jpg","comment_is_top":false,"comment_ctime":1679671983,"is_pvip":false,"replies":[{"id":135446,"content":"实现BeanFActory接口的原因是为了对外提供同样的API。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679740254,"ip_address":"澳大利亚","comment_id":371246,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"思考题：Spring的bean作用域默认是单例的，就是我们的DefaultSingletonBeanRegistry类中持有的那个那个singletons的ConcurrentHashMap，每次获取bean之前，都会先从这个单例map中获取，获取不到才创建。\n如果是多线程场景，有竞态条件存在的情况下，可以考虑将bean的作用域改为Prototype类型，对于Prototype类型的bean，Spring会为每次get请求都新建bean，所以每个请求获取到的bean是不一样的，这样就没有并发问题了\n除了这两种作用域，还有另外四种作用域，我没怎么接触过，看了一下官方文档了解了一下。\n文档地址：https:&#47;&#47;docs.spring.io&#47;spring-framework&#47;docs&#47;5.3.27-SNAPSHOT&#47;reference&#47;html&#47;core.html#beans-factory-scopes\n遇到Spring的问题，可以多看看他们的文档，比搜索引擎强多了，写的很清晰\n另外，我有一个问题，请教一下老师，ClassPathXmlApplicationContext为啥要实现BeanFactory？感觉他们两个不是一个体系里的吧，一个是上下文，一个是bean工厂","like_count":1,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":610752,"discussion_content":"实现BeanFActory接口的原因是为了对外提供同样的API。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679740255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":388008,"user_name":"Geek_03c08d","can_delete":false,"product_type":"c1","uid":2994456,"ip_address":"广东","ucode":"50ADD8DCA09C0D","user_header":"","comment_is_top":false,"comment_ctime":1709128014,"is_pvip":false,"replies":[{"id":141334,"content":"应该说是MiniSpring没有用到，写在这里，是为了软件的完整性。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1709630214,"ip_address":"澳大利亚","comment_id":388008,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"BeanPostProcessor 接口 的 setFactory好像没有什么用","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":638491,"discussion_content":"应该说是MiniSpring没有用到，写在这里，是为了软件的完整性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1709630214,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":388005,"user_name":"Geek_03c08d","can_delete":false,"product_type":"c1","uid":2994456,"ip_address":"广东","ucode":"50ADD8DCA09C0D","user_header":"","comment_is_top":false,"comment_ctime":1709126924,"is_pvip":false,"replies":[{"id":141333,"content":"其实各种写法都可以，我这么做，主要是跟Spring本身保持一致。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1709630150,"ip_address":"澳大利亚","comment_id":388005,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"希望老师回答\n1. AbstractAutowireCapableBeanFactory 为什么不加一个继承AutowireCapableBeanFactory,这样就不用写抽象方法了\n2. AbstractAutowireCapableBeanFactory 为什么是抽象的? 好像所有的功能都实现了","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":638490,"discussion_content":"其实各种写法都可以，我这么做，主要是跟Spring本身保持一致。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1709630150,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386740,"user_name":"Cornicione.","can_delete":false,"product_type":"c1","uid":3810611,"ip_address":"美国","ucode":"1627FC25FD41E6","user_header":"https://static001.geekbang.org/account/avatar/00/3a/25/33/b98d15ac.jpg","comment_is_top":false,"comment_ctime":1705459197,"is_pvip":false,"replies":[{"id":141008,"content":"刚才又从github上拿下来跑了一下，是没有问题的","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1705548338,"ip_address":"澳大利亚","comment_id":386740,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"ide一直提示DefaultListableBeanFactory没有实现ConfigurableBeanFactory的部分methods。看了github上的代码也是一样的问题。github上的源码ioc5真的是可以运行的吗？","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636061,"discussion_content":"刚才又从github上拿下来跑了一下，是没有问题的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705548338,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":375408,"user_name":"Geek_7jwpfc","can_delete":false,"product_type":"c1","uid":1318633,"ip_address":"中国香港","ucode":"CBCEA76E9EF33B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJhxtIyXX4icMNAq5zEvchKYS3q7fwZXA3h7yV80iaibCRXniaLW95OnPC8PM2h5Ja5ibpkJ1VJowicqKZA/132","comment_is_top":false,"comment_ctime":1685440004,"is_pvip":false,"replies":[{"id":137033,"content":"看一下DefaultSingletonBeanRegistry ","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1685497037,"ip_address":"澳大利亚","comment_id":375408,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"ConfigurableBeanFactory定义了getDependentBeans()方法;\nConfigurableBeanFactory的实现类是DefaultListableBeanFactory，但是\nDefaultListableBeanFactory没有实现getDependentBeans()方法，居然没有报错！\n要是极客时间能发图，我肯定发一个图上来！\n我到底错哪儿了！","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":619783,"discussion_content":"看一下DefaultSingletonBeanRegistry ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1685497037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":375401,"user_name":"Geek_7jwpfc","can_delete":false,"product_type":"c1","uid":1318633,"ip_address":"中国香港","ucode":"CBCEA76E9EF33B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJhxtIyXX4icMNAq5zEvchKYS3q7fwZXA3h7yV80iaibCRXniaLW95OnPC8PM2h5Ja5ibpkJ1VJowicqKZA/132","comment_is_top":false,"comment_ctime":1685439488,"is_pvip":false,"replies":[{"id":137042,"content":"public class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory \n\t\t\t\t\timplements ConfigurableListableBeanFactory\n\n你按照这个继承体系一层层往上找","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1685518331,"ip_address":"澳大利亚","comment_id":375401,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"原谅我实在没有看明白\nConfigurableBeanFactory接口, 有一个方法getDependentBeans();\nDefaultListableBeanFactory是它的实现类，大师并没有实现getDependentBeans这个方法，表示看的很懵b\n","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":619824,"discussion_content":"public class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory \n\t\t\t\t\timplements ConfigurableListableBeanFactory\n\n你按照这个继承体系一层层往上找","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1685518331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":373370,"user_name":"梦幻之梦想","can_delete":false,"product_type":"c1","uid":1281681,"ip_address":"陕西","ucode":"A182661D200DE5","user_header":"https://static001.geekbang.org/account/avatar/00/13/8e/91/f1bb1d06.jpg","comment_is_top":false,"comment_ctime":1682430587,"is_pvip":false,"replies":[{"id":136384,"content":"AbstractBeanFactory中继承下来的。你看一下Github上的全代码。","user_name":"作者回复","user_name_real":"作者","uid":1864890,"ctime":1682509641,"ip_address":"澳大利亚","comment_id":373370,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"我想问下DefaultListableBeanFactory中的beanDefinitionMap是怎么来的","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":615943,"discussion_content":"AbstractBeanFactory中继承下来的。你看一下Github上的全代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1682509641,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1281681,"avatar":"https://static001.geekbang.org/account/avatar/00/13/8e/91/f1bb1d06.jpg","nickname":"梦幻之梦想","note":"","ucode":"A182661D200DE5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":620214,"discussion_content":"好的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1685954836,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"陕西","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371950,"user_name":"啊良梓是我","can_delete":false,"product_type":"c1","uid":1655117,"ip_address":"广东","ucode":"E42FC1A60D331C","user_header":"https://static001.geekbang.org/account/avatar/00/19/41/4d/f6d6d13a.jpg","comment_is_top":false,"comment_ctime":1680536695,"is_pvip":false,"replies":[{"id":135773,"content":"你这么做也是可以的，不过就是重新加载了类。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1680587703,"ip_address":"澳大利亚","comment_id":371950,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"String className = beanDefinition.getClassName();\n            Class&lt;?&gt; aClass = null;\n            try {\n                aClass = Class.forName(className);\n            } catch (ClassNotFoundException e) {\n                throw new RuntimeException(e);\n            }\n\n应该是这样子获取BeanDefinition定义的Bean类型才对?","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612281,"discussion_content":"你这么做也是可以的，不过就是重新加载了类。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680587703,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371923,"user_name":"啊良梓是我","can_delete":false,"product_type":"c1","uid":1655117,"ip_address":"广东","ucode":"E42FC1A60D331C","user_header":"https://static001.geekbang.org/account/avatar/00/19/41/4d/f6d6d13a.jpg","comment_is_top":false,"comment_ctime":1680522722,"is_pvip":false,"replies":[{"id":135702,"content":"从github上下载完整代码","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1680558371,"ip_address":"澳大利亚","comment_id":371923,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"\npackage com.minis.beans.factory.config;\nimport com.minis.beans.factory.ListableBeanFactory;\npublic interface ConfigurableListableBeanFactory \n        extends ListableBeanFactory, AutowireCapableBeanFactory, \nConfigurableBeanFactory {\n}\n\n这里是伪代码？ AutowireCapableBeanFactory按照流程下来，这里是一个Class的来哦。。。怎么可以用interface继承他的呢","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612172,"discussion_content":"从github上下载完整代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680558371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1006025,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/c9/f44cb7f3.jpg","nickname":"爪哇夜未眠","note":"","ucode":"BBEB80EB670770","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":620027,"discussion_content":"这一章里，AutowireCapableBeanFactory变成interface了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1685719325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371907,"user_name":"宋健","can_delete":false,"product_type":"c1","uid":1283082,"ip_address":"广东","ucode":"7DD1CAB40440C3","user_header":"https://static001.geekbang.org/account/avatar/00/13/94/0a/7f7c9b25.jpg","comment_is_top":false,"comment_ctime":1680512221,"is_pvip":false,"replies":[{"id":135705,"content":"1. 你看时序，先有容器的启动，然后才到加载各个bean.。 这里的postprocessbeanfactory就是一个节点，让程序员在容器启动后可以进行自己的处理。\n2. 可以的，你可以自己增加对bean的额外修饰代码进行后期处理。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1680558827,"ip_address":"澳大利亚","comment_id":371907,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"老师好，我想问几个小问题：\n1. 请问postProcessBeanFactory这个抽象方法的作用是什么呢？\n2.  我是不是可以在 registerBeanPostProcessors 中添加自己额外自定义的 BeanPostProcessor 来实现其他的注解解释器？","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612175,"discussion_content":"1. 你看时序，先有容器的启动，然后才到加载各个bean.。 这里的postprocessbeanfactory就是一个节点，让程序员在容器启动后可以进行自己的处理。\n2. 可以的，你可以自己增加对bean的额外修饰代码进行后期处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680558827,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371831,"user_name":"Geek_83a70c","can_delete":false,"product_type":"c1","uid":3582233,"ip_address":"广东","ucode":"685404059D397A","user_header":"","comment_is_top":false,"comment_ctime":1680405956,"is_pvip":false,"replies":[{"id":135657,"content":"它们都是beanfactory啊，只是有不同的特性，它们本身构成一个工厂体系。接口隔离不是指这个地方，是说实现一个类，需要什么能力，就加一个什么接口，互相隔开，独立使用。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1680500530,"ip_address":"澳大利亚","comment_id":371831,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"老师好，为什么ListableBeanFactory和ConfigurableBeanFactory、AutowiredCapableBeanFactory都要继承beanFacotry()接口，如果按照接口隔离思想，不是越隔离越好吗？例如以上3个接口根本其实无需涉及beanFactory中的getBean()这个最主要的方法","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612044,"discussion_content":"它们都是beanfactory啊，只是有不同的特性，它们本身构成一个工厂体系。接口隔离不是指这个地方，是说实现一个类，需要什么能力，就加一个什么接口，互相隔开，独立使用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680500530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371021,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1679466626,"is_pvip":false,"replies":[{"id":135348,"content":"ApplicationEvent实现Serializable接口，按照约定，要有这个serialVersionUID.\n我说的“设计模式”，并不一定指23种之一，那23种只是GoF书中列出的而已，设计模式就是一种解决问题的固定方案，我们在编程中都要自己用心提取设计模式。\n不同的目录结构都可以的，能找到就行。\n扩展性有不同程度，单独提炼出接口，然后给了默认实现，有源码就可以改，如果提供了注入机制，也可以通过配置进行扩展。后面MVC有例子。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1679482262,"ip_address":"澳大利亚","comment_id":371021,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"请教老师几个问题：\nQ1：ApplicationEvent 类中定义的“serialVersionUID = 1L”有什么用？如果有用，为什么有的类没有定义serialVersionUID？(对于serialVersionUID，以前好像有一篇博客讲过，但一直没在意过，没有用过，好像也没有什么问题)\nQ2：文中提到的“设计模式”属于23种设计模式吗？\n文中提到“Spring 的这个设计模式值得我们学习，采用抽象类的方式来解耦，为用户提供了极大的扩展性的便利”，这里提到的“设计模式”，应该不是常说的23种设计模式吧。\nQ3：beans.xml文件必须放在Resource目录下面吗？老师的工程，Resource目录与src目录是平级，但我以前建的工程，resource目录在src&#47;main目录下面,main下面有两个目录，java和resource，这两个平级。 这两种目录结构都可以吗？\nQ4：系统有自己缺省的处理类，系统启动过程也是固定的。用户怎么利用扩展性？比如，用户想修改或增加某个功能，怎么实现？","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":610260,"discussion_content":"ApplicationEvent实现Serializable接口，按照约定，要有这个serialVersionUID.\n我说的“设计模式”，并不一定指23种之一，那23种只是GoF书中列出的而已，设计模式就是一种解决问题的固定方案，我们在编程中都要自己用心提取设计模式。\n不同的目录结构都可以的，能找到就行。\n扩展性有不同程度，单独提炼出接口，然后给了默认实现，有源码就可以改，如果提供了注入机制，也可以通过配置进行扩展。后面MVC有例子。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679482262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":392461,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"安徽","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1721026001,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"终于把 ioc 章节撸完了一版（ https:&#47;&#47;github.com&#47;LeoDemon&#47;mini-spring&#47;tree&#47;ioc ），请教老师一个问题：\n\n为什么 AbstractBeanFactory 中的 beanDefinitionMap 定义成并发容器（ConcurrentHashMap），而 beanDefinitionNames 和 earlySingletonObject 用的又是普通容器？另外，按理说如果有并发风险，那么 AbstractBeanFactory#getBean 方法应该使用 synchronized 之类关键词修饰才行呀。谢谢老师。","like_count":0},{"had_liked":false,"id":389725,"user_name":"Geek_99cd2f","can_delete":false,"product_type":"c1","uid":3864721,"ip_address":"湖北","ucode":"E4FB8296DA17E3","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIJzTTCtibjCPYQE3voz3sukJ79ibtHnRticRUqyIqhnp24Yfk9ztZ2cZ1VqA6wceCnsCppl7YVbgH0w/132","comment_is_top":false,"comment_ctime":1713326108,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"git上的IOC5的第70行 Class&lt;?&gt;clz = bd.getClass();写错了应该是 Class&lt;?&gt;clz = obj.getClass()；","like_count":0},{"had_liked":false,"id":386741,"user_name":"Cornicione.","can_delete":false,"product_type":"c1","uid":3810611,"ip_address":"美国","ucode":"1627FC25FD41E6","user_header":"https://static001.geekbang.org/account/avatar/00/3a/25/33/b98d15ac.jpg","comment_is_top":false,"comment_ctime":1705459881,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"这一节的DefaultSingletonBeanRegistry也要同步修改，不然会出现未能impements的报错","like_count":0},{"had_liked":false,"id":378919,"user_name":"美芳","can_delete":false,"product_type":"c1","uid":1215203,"ip_address":"","ucode":"B0C1FB3D852C4E","user_header":"https://static001.geekbang.org/account/avatar/00/12/8a/e3/be7a46db.jpg","comment_is_top":false,"comment_ctime":1690972717,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":4,"product_id":100536701,"comment_content":"请问下有能跑通的git代码吗？我都不知道错哪里了，一直报空指针","like_count":0,"discussions":[{"author":{"id":3835913,"avatar":"","nickname":"Geek_c9c9e1","note":"","ucode":"F02C41200C1011","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":638071,"discussion_content":"我如果没有猜错的话 你应该是有一个之前的错误没改  你可以看看文章3的评论区","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1709199145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}