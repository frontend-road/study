{"id":77830,"title":"48 | B+树：MySQL数据库索引是如何实现的？","content":"<p>作为一个软件开发工程师，你对数据库肯定再熟悉不过了。作为主流的数据存储系统，它在我们的业务开发中，有着举足轻重的地位。在工作中，为了加速数据库中数据的查找速度，我们常用的处理思路是，对表中数据创建索引。那你是否思考过，<strong><span class=\"orange\">数据库索引是如何实现的呢？底层使用的是什么数据结构和算法呢？</span></strong></p><h2>算法解析</h2><p>思考的过程比结论更重要。跟着我学习了这么多节课，很多同学已经意识到这一点，比如Jerry银银同学。我感到很开心。所以，今天的讲解，我会尽量还原这个解决方案的思考过程，让你知其然，并且知其所以然。</p><h3>1.解决问题的前提是定义清楚问题</h3><p>如何定义清楚问题呢？除了对问题进行详细的调研，还有一个办法，那就是，通过<strong>对一些模糊的需求进行假设，来限定<strong><strong>要</strong></strong>解决的问题的范围</strong>。</p><p>如果你对数据库的操作非常了解，针对我们现在这个问题，你就能把索引的需求定义得非常清楚。但是，对于大部分软件工程师来说，我们可能只了解一小部分常用的SQL语句，所以，这里我们假设要解决的问题，只包含这样两个常用的需求：</p><ul>\n<li>\n<p>根据某个值查找数据，比如select * from user where id=1234；</p>\n</li>\n<li>\n<p>根据区间值来查找某些数据，比如select * from user where id &gt; 1234 and id &lt; 2345。</p>\n</li>\n</ul><!-- [[[read_end]]] --><p>除了这些功能性需求之外，这种问题往往还会涉及一些非功能性需求，比如安全、性能、用户体验等等。限于专栏要讨论的主要是数据结构和算法，对于非功能性需求，我们着重考虑<strong>性能方面</strong>的需求。性能方面的需求，我们主要考察时间和空间两方面，也就是<strong>执行效率和存储空间</strong>。</p><p>在执行效率方面，我们希望通过索引，查询数据的效率尽可能地高；在存储空间方面，我们希望索引不要消耗太多的内存空间。</p><h3>2.尝试用学过的数据结构解决这个问题</h3><p>问题的需求大致定义清楚了，我们现在回想一下，能否利用已经学习过的数据结构解决这个问题呢？支持快速查询、插入等操作的动态数据结构，我们已经学习过散列表、平衡二叉查找树、跳表。</p><p>我们先来看<strong>散列表</strong>。散列表的查询性能很好，时间复杂度是O(1)。但是，散列表不能支持按照区间快速查找数据。所以，散列表不能满足我们的需求。</p><p>我们再来看<strong>平衡二叉查找树</strong>。尽管平衡二叉查找树查询的性能也很高，时间复杂度是O(logn)。而且，对树进行中序遍历，我们还可以得到一个从小到大有序的数据序列，但这仍然不足以支持按照区间快速查找数据。</p><p>我们再来看<strong>跳表</strong>。跳表是在链表之上加上多层索引构成的。它支持快速地插入、查找、删除数据，对应的时间复杂度是O(logn)。并且，跳表也支持按照区间快速地查找数据。我们只需要定位到区间起点值对应在链表中的结点，然后从这个结点开始，顺序遍历链表，直到区间终点对应的结点为止，这期间遍历得到的数据就是满足区间值的数据。</p><p><img src=\"https://static001.geekbang.org/resource/image/49/65/492206afe5e2fef9f683c7cff83afa65.jpg?wh=1142*663\" alt=\"\"></p><p>这样看来，跳表是可以解决这个问题。实际上，数据库索引所用到的数据结构跟跳表非常相似，叫作B+树。不过，它是通过二叉查找树演化过来的，而非跳表。为了给你还原发明B+树的整个思考过程，所以，接下来，我还要从二叉查找树讲起，看它是如何一步一步被改造成B+树的。</p><h3>3.改造二叉查找树来解决这个问题</h3><p>为了让二叉查找树支持按照区间来查找数据，我们可以对它进行这样的改造：树中的节点并不存储数据本身，而是只是作为索引。除此之外，我们把每个叶子节点串在一条链表上，链表中的数据是从小到大有序的。经过改造之后的二叉树，就像图中这样，看起来是不是很像跳表呢？</p><p><img src=\"https://static001.geekbang.org/resource/image/25/f4/25700c1dc28ce094eed3ffac394531f4.jpg?wh=1142*738\" alt=\"\"></p><p>改造之后，如果我们要求某个区间的数据。我们只需要拿区间的起始值，在树中进行查找，当查找到某个叶子节点之后，我们再顺着链表往后遍历，直到链表中的结点数据值大于区间的终止值为止。所有遍历到的数据，就是符合区间值的所有数据。</p><p><img src=\"https://static001.geekbang.org/resource/image/1c/cc/1cf179c03c702a6ef5b9336f5b1eaecc.jpg?wh=1142*699\" alt=\"\"></p><p>但是，我们要为几千万、上亿的数据构建索引，如果将索引存储在内存中，尽管内存访问的速度非常快，查询的效率非常高，但是，占用的内存会非常多。</p><p>比如，我们给一亿个数据构建二叉查找树索引，那索引中会包含大约1亿个节点，每个节点假设占用16个字节，那就需要大约1GB的内存空间。给一张表建立索引，我们需要1GB的内存空间。如果我们要给10张表建立索引，那对内存的需求是无法满足的。如何解决这个索引占用太多内存的问题呢？</p><p>我们可以借助时间换空间的思路，把索引存储在硬盘中，而非内存中。我们都知道，硬盘是一个非常慢速的存储设备。通常内存的访问速度是纳秒级别的，而磁盘访问的速度是毫秒级别的。读取同样大小的数据，从磁盘中读取花费的时间，是从内存中读取所花费时间的上万倍，甚至几十万倍。</p><p>这种将索引存储在硬盘中的方案，尽管减少了内存消耗，但是在数据查找的过程中，需要读取磁盘中的索引，因此数据查询效率就相应降低很多。</p><p>二叉查找树，经过改造之后，支持区间查找的功能就实现了。不过，为了节省内存，如果把树存储在硬盘中，那么每个节点的读取（或者访问），都对应一次磁盘IO操作。树的高度就等于每次查询数据时磁盘IO操作的次数。</p><p>我们前面讲到，比起内存读写操作，磁盘IO操作非常耗时，所以我们优化的重点就是尽量减少磁盘IO操作，也就是，尽量降低树的高度。那如何降低树的高度呢？</p><p>我们来看下，如果我们把索引构建成m叉树，高度是不是比二叉树要小呢？如图所示，给16个数据构建二叉树索引，树的高度是4，查找一个数据，就需要4个磁盘IO操作（如果根节点存储在内存中，其他节点存储在磁盘中），如果对16个数据构建五叉树索引，那高度只有2，查找一个数据，对应只需要2次磁盘操作。如果m叉树中的m是100，那对一亿个数据构建索引，树的高度也只是3，最多只要3次磁盘IO就能获取到数据。磁盘IO变少了，查找数据的效率也就提高了。</p><p><img src=\"https://static001.geekbang.org/resource/image/69/59/69d4c48c1257dcb7dd6077d961b86259.jpg?wh=1142*611\" alt=\"\"><img src=\"https://static001.geekbang.org/resource/image/76/cc/769687f57190a826a8f6f82793491ccc.jpg?wh=1142*527\" alt=\"\"></p><p>如果我们将m叉树实现B+树索引，用代码实现出来，就是下面这个样子（假设我们给int类型的数据库字段添加索引，所以代码中的keywords是int类型的）：</p><pre><code>/**\n * 这是B+树非叶子节点的定义。\n *\n * 假设keywords=[3, 5, 8, 10]\n * 4个键值将数据分为5个区间：(-INF,3), [3,5), [5,8), [8,10), [10,INF)\n * 5个区间分别对应：children[0]...children[4]\n *\n * m值是事先计算得到的，计算的依据是让所有信息的大小正好等于页的大小：\n * PAGE_SIZE = (m-1)*4[keywordss大小]+m*8[children大小]\n */\npublic class BPlusTreeNode {\n  public static int m = 5; // 5叉树\n  public int[] keywords = new int[m-1]; // 键值，用来划分数据区间\n  public BPlusTreeNode[] children = new BPlusTreeNode[m];//保存子节点指针\n}\n\n/**\n * 这是B+树中叶子节点的定义。\n *\n * B+树中的叶子节点跟内部节点是不一样的,\n * 叶子节点存储的是值，而非区间。\n * 这个定义里，每个叶子节点存储3个数据行的键值及地址信息。\n *\n * k值是事先计算得到的，计算的依据是让所有信息的大小正好等于页的大小：\n * PAGE_SIZE = k*4[keyw..大小]+k*8[dataAd..大小]+8[prev大小]+8[next大小]\n */\npublic class BPlusTreeLeafNode {\n  public static int k = 3;\n  public int[] keywords = new int[k]; // 数据的键值\n  public long[] dataAddress = new long[k]; // 数据地址\n\n  public BPlusTreeLeafNode prev; // 这个结点在链表中的前驱结点\n  public BPlusTreeLeafNode next; // 这个结点在链表中的后继结点\n}\n</code></pre><p>我稍微解释一下这段代码。</p><p>对于相同个数的数据构建m叉树索引，m叉树中的m越大，那树的高度就越小，那m叉树中的m是不是越大越好呢？到底多大才最合适呢？</p><p>不管是内存中的数据，还是磁盘中的数据，操作系统都是按页（一页大小通常是4KB，这个值可以通过getconfig PAGE_SIZE命令查看）来读取的，一次会读一页的数据。如果要读取的数据量超过一页的大小，就会触发多次IO操作。所以，我们在选择m大小的时候，要尽量让每个节点的大小等于一个页的大小。读取一个节点，只需要一次磁盘IO操作。</p><p><img src=\"https://static001.geekbang.org/resource/image/ea/30/ea4472fd7bb7fa948532c8c8ba334430.jpg?wh=1142*886\" alt=\"\"></p><p>尽管索引可以提高数据库的查询效率，但是，作为一名开发工程师，你应该也知道，索引有利也有弊，它也会让写入数据的效率下降。这是为什么呢？</p><p>数据的写入过程，会涉及索引的更新，这是索引导致写入变慢的主要原因。</p><p>对于一个B+树来说，m值是根据页的大小事先计算好的，也就是说，每个节点最多只能有m个子节点。在往数据库中写入数据的过程中，这样就有可能使索引中某些节点的子节点个数超过m，这个节点的大小超过了一个页的大小，读取这样一个节点，就会导致多次磁盘IO操作。我们该如何解决这个问题呢？</p><p>实际上，处理思路并不复杂。我们只需要将这个节点分裂成两个节点。但是，节点分裂之后，其上层父节点的子节点个数就有可能超过m个。不过这也没关系，我们可以用同样的方法，将父节点也分裂成两个节点。这种级联反应会从下往上，一直影响到根节点。这个分裂过程，你可以结合着下面这个图一块看，会更容易理解（图中的B+树是一个三叉树。我们限定叶子节点中，数据的个数超过2个就分裂节点；非叶子节点中，子节点的个数超过3个就分裂节点）。</p><p><img src=\"https://static001.geekbang.org/resource/image/18/e0/1800bc80e1e05b32a042ff6873e6c2e0.jpg?wh=1142*856\" alt=\"\"></p><p>正是因为要时刻保证B+树索引是一个m叉树，所以，索引的存在会导致数据库写入的速度降低。实际上，不光写入数据会变慢，删除数据也会变慢。这是为什么呢？</p><p>我们在删除某个数据的时候，也要对应地更新索引节点。这个处理思路有点类似跳表中删除数据的处理思路。频繁的数据删除，就会导致某些节点中，子节点的个数变得非常少，长此以往，如果每个节点的子节点都比较少，势必会影响索引的效率。</p><p>我们可以设置一个阈值。在B+树中，这个阈值等于m/2。如果某个节点的子节点个数小于m/2，我们就将它跟相邻的兄弟节点合并。不过，合并之后节点的子节点个数有可能会超过m。针对这种情况，我们可以借助插入数据时候的处理方法，再分裂节点。</p><p>文字描述不是很直观，我举了一个删除操作的例子，你可以对比着看下（图中的B+树是一个五叉树。我们限定叶子节点中，数据的个数少于2个就合并节点；非叶子节点中，子节点的个数少于3个就合并节点。）。</p><p><img src=\"https://static001.geekbang.org/resource/image/17/18/1730e34450dad29f062e76536622c918.jpg?wh=1142*856\" alt=\"\"></p><p>数据库索引以及B+树的由来，到此就讲完了。你有没有发现，B+树的结构和操作，跟跳表非常类似。理论上讲，对跳表稍加改造，也可以替代B+树，作为数据库的索引实现的。</p><p>B+树发明于1972年，跳表发明于1989年，我们可以大胆猜想下，跳表的作者有可能就是受了B+树的启发，才发明出跳表来的。不过，这个也无从考证了。</p><h2>总结引申</h2><p>今天，我们讲解了数据库索引实现，依赖的底层数据结构，B+树。它通过存储在磁盘的多叉树结构，做到了时间、空间的平衡，既保证了执行效率，又节省了内存。</p><p>前面的讲解中，为了一步一步详细地给你介绍B+树的由来，内容看起来比较零散。为了方便你掌握和记忆，我这里再总结一下B+树的特点：</p><ul>\n<li>\n<p>每个节点中子节点的个数不能超过m，也不能小于m/2；</p>\n</li>\n<li>\n<p>根节点的子节点个数可以不超过m/2，这是一个例外；</p>\n</li>\n<li>\n<p>m叉树只存储索引，并不真正存储数据，这个有点儿类似跳表；</p>\n</li>\n<li>\n<p>通过链表将叶子节点串联在一起，这样可以方便按区间查找；</p>\n</li>\n<li>\n<p>一般情况，根节点会被存储在内存中，其他节点存储在磁盘中。</p>\n</li>\n</ul><p>除了B+树，你可能还听说过B树、B-树，我这里简单提一下。实际上，B-树就是B树，英文翻译都是B-Tree，这里的“-”并不是相对B+树中的“+”，而只是一个连接符。这个很容易误解，所以我强调下。</p><p>而B树实际上是低级版的B+树，或者说B+树是B树的改进版。B树跟B+树的不同点主要集中在这几个地方：</p><ul>\n<li>\n<p>B+树中的节点不存储数据，只是索引，而B树中的节点存储数据；</p>\n</li>\n<li>\n<p>B树中的叶子节点并不需要链表来串联。</p>\n</li>\n</ul><p>也就是说，B树只是一个每个节点的子节点个数不能小于m/2的m叉树。</p><h2>课后思考</h2><ol>\n<li>\n<p>B+树中，将叶子节点串起来的链表，是单链表还是双向链表？为什么？</p>\n</li>\n<li>\n<p>我们对平衡二叉查找树进行改造，将叶子节点串在链表中，就支持了按照区间来查找数据。我们在<a href=\"https://time.geekbang.org/column/article/64858\">散列表（下）</a>讲到，散列表也经常跟链表一块使用，如果我们把散列表中的结点，也用链表串起来，能否支持按照区间查找数据呢？</p>\n</li>\n</ol><p>欢迎留言和我分享，也欢迎点击“<span class=\"orange\">请朋友读</span>”，把今天的内容分享给你的好友，和他一起讨论、学习。</p>","neighbors":{"left":{"article_title":"47 | 向量空间：如何实现一个简单的音乐推荐系统？","id":77457},"right":{"article_title":"49 | 搜索：如何用A*搜索算法实现游戏中的寻路功能？","id":78175}},"comments":[{"had_liked":false,"id":61100,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1547620338,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"1526261010418","product_id":100017301,"comment_content":"听专栏，听到了自己的名字，不敢相信，看了文稿，确实是自己。真是受宠若惊！","like_count":356,"discussions":[{"author":{"id":1393323,"avatar":"https://static001.geekbang.org/account/avatar/00/15/42/ab/75fb1cd6.jpg","nickname":"Tim","note":"","ucode":"A3ECD9832D630D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4904,"discussion_content":"大佬，我一直看到你的名字","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1565826291,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1310798,"avatar":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","nickname":"吴小智","note":"","ucode":"C7C9F58B5C9F7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":27410,"discussion_content":"真大佬了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1570638965,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1231623,"avatar":"https://static001.geekbang.org/account/avatar/00/12/cb/07/482b7155.jpg","nickname":"牛玉富","note":"","ucode":"DD962676F8FAF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544844,"discussion_content":"Jerry666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641731366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1481811,"avatar":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","nickname":"ub8","note":"","ucode":"0D937C3EAEB781","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372595,"discussion_content":"头顶带光","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620389108,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1798979,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/73/43/ae139b1f.jpg","nickname":"博","note":"","ucode":"F7CA69FF5D09BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":178526,"discussion_content":"印象中好像第一次看到，我不看评论，，，这不老师极力推荐的人才，膜拜了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582170579,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":62075,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1547902754,"is_pvip":false,"replies":[{"id":"24178","content":"👍","user_name":"作者回复","comment_id":62075,"uid":"1190123","ip_address":"","utype":1,"ctime":1550479877,"user_name_real":"gg"}],"discussion_count":22,"race_medal":0,"score":"1058109857570","product_id":100017301,"comment_content":"个人觉得B+tree理解起来真不难，抓住几个要点就可以了：<br>1. 理解二叉查找树<br>2. 理解二叉查找树会出现不平衡的问题（红黑树理解了，对于平衡性这个关键点就理解了）<br>3. 磁盘IO访问太耗时<br>4. 当然，链表知识跑不了 —— 别小瞧这个简单的数据结构，它是链式结构之母<br>5. 最后，要知道典型的应用场景：数据库的索引结构的设计<br><br>还记得，在学生时代，不好好学数据结构的我，当看到这个高大尚的名词“B+tree”时，我心里无比惊慌：这东西貌似不简单。^_^   那时，也有着王争老师说的这种情况：B-tree，这是B减树；肯定还有个正常的B树；B+tree，这是B加树；然后在我的脑海里面，想当然地认为，它们之间有着这样的大小关系：B-tree &lt; B tree &lt; B+tree  <br>----------<br>对于思考题，@老杨 大哥的回答我觉得很到位了。 我只做一下补充：<br>第一题： 对于B+tree叶子节点，是用双向链表还是用单链表，得从具体的场景思考。我想，大部分同学在开发中遇到的数据库查询，都遇到过升序或降序问题，即类似这样的sql: select name,age, ... from where uid &gt; startValue and uid &lt; endValue order by uid asc(或者desc)，此时，数据底层实现有两种做法：<br>1）保证查出来的数据就是用户想要的顺序<br>2）不保证查出来的数据的有序性，查出来之后再排序<br>以上两种方案，不加思考，肯定选第一种，因为第二种做法浪费了时间（如果选用内存排序，还是考虑数据的量级）。那如何能保证查询出来的数据就是有序的呢？单链表肯定做不到，只能从头往后遍历，再想想，只能选择双向链表了。此时，可能有的同学又问了：双向链表，多出来了一倍的指针，不是会多占用空间嘛？  答案是肯定的。可是，我们再细想下，数据库索引本身都已经在磁盘中了，对于磁盘来说，这点空间已经微不足道了，用这点空间换来时间肯定划算呀。顺便提一下：在实际工程应用中，双向链表应用的场景非常广泛，毕竟能大量减少链表的遍历时间<br><br>第二题：<br>答案是「肯定的」。如同@老杨 大哥说的，JDK中的LinkedHashMap为了能做到保持节点的顺序（插入顺序或者访问顺序），就是用双向链表将节点串起来的。 其实，王争老师在《散列表(下）》那一堂课中就已经深入讲解了LinkedHashMap，如果理解了那篇，这个问题应该不难。<br>-------<br>最后，我发现王争老师布置的这些课后思考题，都涉及到了之前学到的内容，不知道是有意还是无意的，嘻嘻！<br><br>这节的思考题花了蛮多时间进行思考，才能给出以上答案，希望王争老师帮看看是否有不对的地方，谢谢！<br><br><br>","like_count":247,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437086,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550479877,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2057513,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/65/29/8c0fe011.jpg","nickname":"Fire","note":"","ucode":"8D3E102E690443","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325472,"discussion_content":"第一题，单链表可以保证asc，但是无法desc，而双链表既可以asc又可以desc。\n第二题，LinkedHashMap 其实保证不了按区间排序（LinkedHashMap 只是保存放入的先后次序，并不能保证大小的顺序关系）。想要按区间排序，需要额外对散列表中的节点再加一层双向链表的关系，用来维护节点的大小关系。但是此时的插入操作的时间复杂度会比较高。每次插入一个元素，需要遍历并比较现有的节点，找到合适的位置来建立链表关系，时间复杂度为O(n)。","likes_number":12,"is_delete":false,"is_hidden":false,"ctime":1605326095,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1225395,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b2/b3/798a4bb2.jpg","nickname":"帽子丨影","note":"","ucode":"2B34892A2DE83E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78033,"discussion_content":"第二题答案不一定是肯定的吧？我觉得这个取决于我们的散列函数，如果我们的散列函数计算出来的散列值无意义的话，也就无法按区间来读取数据啊","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1575969684,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1798068,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/6f/b4/d465acef.jpg","nickname":"啊噗！","note":"","ucode":"C911E772E1E800","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1225395,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b2/b3/798a4bb2.jpg","nickname":"帽子丨影","note":"","ucode":"2B34892A2DE83E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":179948,"discussion_content":"我也觉得 这个散链表里用链表串联起来的顺序性是时间插入的顺序 并不是数据本身的顺序","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1582264976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":78033,"ip_address":""},"score":179948,"extra":""},{"author":{"id":1899599,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/fc/4f/0a452c94.jpg","nickname":"大毛","note":"","ucode":"93B18287F06706","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1798068,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/6f/b4/d465acef.jpg","nickname":"啊噗！","note":"","ucode":"C911E772E1E800","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":235245,"discussion_content":"你这个想法是错的，哈希表+链表实际上是用一份数据维护了两个表：哈希表和链表。\n对于哈希表来说，主要用来查找数据；对与链表来说，主要用来输出有序数据。注意，这里说的有序数据主要是数据在链表中是有序的，而不是在哈希表中有序。\n在进行查找数据的时候，我们使用散列表查找，因为散列表的查找更加快速，在进行范围性的数据查找的时候，我们可以通过散列表查找到数据的起始点，然后再通过这个起始点的链表依次向后查找即可。（因为链表是有序的，所以对于查询范围数据来说，直接使用链表更加快速）","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1587031691,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":179948,"ip_address":""},"score":235245,"extra":""},{"author":{"id":1006635,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5c/2b/8b771383.jpg","nickname":"默默","note":"","ucode":"AF798B9D327F24","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1899599,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/fc/4f/0a452c94.jpg","nickname":"大毛","note":"","ucode":"93B18287F06706","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":269941,"discussion_content":"针对查找和删除，O(1)时间复杂度都没问题。对于插入的时间复杂度呢？为了保证链表顺序性，只能从表头开始查找吧，这样的话时间复杂度就是O(n)。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589967131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":235245,"ip_address":""},"score":269941,"extra":""}]},{"author":{"id":1598699,"avatar":"","nickname":"Geek_12cb85","note":"","ucode":"D1E757C5846DC3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293597,"discussion_content":"我觉得第二个问题有待商榷，如果是实现这种按时间的插入，这种机制是可行的。但实现真正意义上的区间查询会碰到：1.如果区间的左右起始值不在哈希表中，如何定位双向链表的起始位置？2.添加一个新的数据，如何定位到对应的双向链表位置。如果只是遍历双向链表解决，复杂度还是O(n)","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1595593829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2760780,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKghO4kJwQ5ccuBA2Yox1WlZmq0JUICpNAsgYlOHX0wHGv48xVRKSvF9a6Eic5l2UOjFjnvTnsibibiaw/132","nickname":"Geek_94045a","note":"","ucode":"B8F23BA9D1411B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532081,"discussion_content":"老哥我看你有地中海的趋势啊，算法差不多研究研究就行了，担心你头发 哈哈","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1637508969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2199757,"avatar":"https://static001.geekbang.org/account/avatar/00/21/90/cd/748d4f81.jpg","nickname":"G-dragon","note":"","ucode":"0C9E73DB0DF729","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":321912,"discussion_content":"第二题，LinkedHashMap只是保存放入的先后次序，并不能保证大小的顺序关系。所以不能实现按区间查找","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1604650102,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2057513,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/65/29/8c0fe011.jpg","nickname":"Fire","note":"","ucode":"8D3E102E690443","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":2199757,"avatar":"https://static001.geekbang.org/account/avatar/00/21/90/cd/748d4f81.jpg","nickname":"G-dragon","note":"","ucode":"0C9E73DB0DF729","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325470,"discussion_content":"我也是这样觉得，LinkedHashMap 保证不了按区间排序。想要按区间排序，需要额外对散列表中的节点再加一层链表的关系，用来维护节点的大小关系。但是此时的插入操作的时间复杂度会比较高。每次插入一个元素，需要遍历比较现有的节点，找到合适的位置插入，时间复杂度为O(n)。查找区间和删除元素的时间复杂度为O(1)。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605325963,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":321912,"ip_address":""},"score":325470,"extra":""}]},{"author":{"id":1062864,"avatar":"https://static001.geekbang.org/account/avatar/00/10/37/d0/26975fba.jpg","nickname":"aof","note":"","ucode":"5815D63C4926BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271830,"discussion_content":"应该是单链表可以保证asc，但是无法desc，而双链表既可以asc又可以desc","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590199730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2057513,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/65/29/8c0fe011.jpg","nickname":"Fire","note":"","ucode":"8D3E102E690443","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":1062864,"avatar":"https://static001.geekbang.org/account/avatar/00/10/37/d0/26975fba.jpg","nickname":"aof","note":"","ucode":"5815D63C4926BC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325469,"discussion_content":"我也是这样觉得，但是不知道对不对。可惜这门课，老师没有对课后问题做解答，只留大家自己思考了。还有第二题，LinkedHashMap 其实保证不了按区间排序（LinkedHashMap 只是保存放入的先后次序，并不能保证大小的顺序关系），需要额外对散列表中的节点再加一层链表的关系，用来维护节点的大小关系。但是此时的插入操作的时间复杂度会比较高。每次插入一个元素，需要遍历比较现有的节点，找到合适的位置插入，时间复杂度为O(n)。查找区间和删除元素的时间复杂度为O(1)。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605325876,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":271830,"ip_address":""},"score":325469,"extra":""}]},{"author":{"id":1944561,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJx6YiaEictwmdCYibD0icNpSvgLkFXtbu1I4ER9icqXMkBMibtfvTNhEm1B1fuU1e4ico3nrCO20HwyncKA/132","nickname":"Geek_26794c","note":"","ucode":"BBF0B71B49472F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554270,"discussion_content":"但是我提一个问题，如果在数据库中使用两个字段进行排序的时候，不一定会生效，有些时候需要对单个字段建立相反数，从而保证多字段排序能生效","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646293353,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1099368,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c6/68/818e81fe.jpg","nickname":"Howard","note":"","ucode":"36878E30809676","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":359960,"discussion_content":"你一大男人 还嘻嘻   我模拟个场景在笑笑😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616332834,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2080899,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/c0/83/ca1c44d5.jpg","nickname":"west","note":"","ucode":"B42BF349E55900","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312836,"discussion_content":"第一题你说数据底层实现是你说的第一种情况，是说数据在磁盘存储的时候就有序了吗？如果有序的话，它是按照表中哪个字段排序的。在查询数据库的时候，不是可以指定排序的字段吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602830041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2326134,"avatar":"https://static001.geekbang.org/account/avatar/00/23/7e/76/368394bf.jpg","nickname":"哦","note":"","ucode":"C776659DED9D79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2080899,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/c0/83/ca1c44d5.jpg","nickname":"west","note":"","ucode":"B42BF349E55900","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338466,"discussion_content":"不是数据有序，是索引有序。如果指定的排序字段被建立了索引，那么通过索引树就可以保证查询出来的数据就是有序的，这个时候查出来的数据不用排序。如果是非索引字段，那么根据聚簇索引树查出来的数据就得在sort buffer中进行排序在返回给client。所以需要排序的本质就是查出来的数据是无序的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609296891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":312836,"ip_address":""},"score":338466,"extra":""}]},{"author":{"id":1245430,"avatar":"https://static001.geekbang.org/account/avatar/00/13/00/f6/f6cf138c.jpg","nickname":"Kermit Sun","note":"","ucode":"9B0560FB228629","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302506,"discussion_content":"第一题用双向链表还有一个原因 是因为插入数据的时候要维护这个链表，所以必须是双向的，如果单向链表的话，想在链表中插入一个节点，成本会非常高","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598940420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1246664,"avatar":"https://static001.geekbang.org/account/avatar/00/13/05/c8/2f849dfb.jpg","nickname":"山顶的洞","note":"","ucode":"D3E9E928A3FA62","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":230421,"discussion_content":"银哥牛中牛","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586743989,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":90320,"discussion_content":"LinkedHashMap ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576768628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1053532,"avatar":"","nickname":"亮灯","note":"","ucode":"C06505ED58A0E5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51131,"discussion_content":"引用：&#34;B-tree，这是B减树；肯定还有个正常的B树；&#34;  B- 就是B树","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573815436,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":60966,"user_name":"城","can_delete":false,"product_type":"c1","uid":1035315,"ip_address":"","ucode":"32C4FCE1944000","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cc/33/19f150d9.jpg","comment_is_top":false,"comment_ctime":1547599598,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"340850015982","product_id":100017301,"comment_content":"1.链表是双向链表，用以支持前后遍历<br>2.散列表的节点用链表串起来，并不能实现范围查询，因为散列表本身无序，而B+树是基于二叉查找树演变而成，是有序的","like_count":78},{"had_liked":false,"id":61348,"user_name":"老杨同志","can_delete":false,"product_type":"c1","uid":1246199,"ip_address":"","ucode":"3F334F0CFD3DE6","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/f7/3a493bec.jpg","comment_is_top":false,"comment_ctime":1547684742,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"327965199238","product_id":100017301,"comment_content":"问题一，双向链表，方便asc和desc。<br>问题二，可以支持区间查询。java中linkedHashMap就是链表链表+HashMap的组合，用于实现缓存的lru算法比较方便，不过要支持区间查询需要在插入时维持链表的有序性，复杂度O(n).效率比跳表和b+tree差","like_count":77,"discussions":[{"author":{"id":1254530,"avatar":"https://static001.geekbang.org/account/avatar/00/13/24/82/b5808a60.jpg","nickname":"李冲","note":"","ucode":"C8C12308B0FDDA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":13851,"discussion_content":"老杨可是丁奇老师课程里面的常客和高手，一直都有很好的互动。双链表还有个主要好处，O(1)删除叶子结点","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1568708997,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1269873,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/71/895ee6cf.jpg","nickname":"分清云淡","note":"","ucode":"7045AE6BF72D31","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":126830,"discussion_content":"老杨简直是极客时间的劳模读者","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1578541636,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2057513,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/65/29/8c0fe011.jpg","nickname":"Fire","note":"","ucode":"8D3E102E690443","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325474,"discussion_content":"老杨同志说的不太全面。\n第一题，单链表可以保证asc，但是无法desc，而双链表既可以asc又可以desc。\n第二题，LinkedHashMap 其实保证不了按区间排序（LinkedHashMap 只是保存放入的先后次序，并不能保证大小的顺序关系）。想要按区间排序，需要额外对散列表中的节点再加一层双向链表的关系，用来维护节点的大小关系。但是此时的插入操作的时间复杂度会比较高。每次插入一个元素，需要遍历并比较现有的节点，找到合适的位置来建立链表关系，时间复杂度为O(n)。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1605326203,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2058852,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/6a/64/3d4fccf8.jpg","nickname":"Z_Z","note":"","ucode":"654BE3F3C7DBA4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2057513,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/65/29/8c0fe011.jpg","nickname":"Fire","note":"","ucode":"8D3E102E690443","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":571844,"discussion_content":"我觉得你才讲清楚了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652428405,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":325474,"ip_address":""},"score":571844,"extra":""}]},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309288,"discussion_content":"哈哈哈 老杨同志好眼熟的飘过","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601253893,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2249227,"avatar":"https://static001.geekbang.org/account/avatar/00/22/52/0b/50bf0f05.jpg","nickname":"橙子橙","note":"","ucode":"CD51367A14D955","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325620,"discussion_content":"mysql45...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605365477,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":309288,"ip_address":""},"score":325620,"extra":""}]},{"author":{"id":1246199,"avatar":"https://static001.geekbang.org/account/avatar/00/13/03/f7/3a493bec.jpg","nickname":"老杨同志","note":"","ucode":"3F334F0CFD3DE6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":32552,"discussion_content":"二刷竟然有人提到我，呵呵。丁奇老师的课，我也二刷了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571046687,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":63158,"user_name":"feifei","can_delete":false,"product_type":"c1","uid":1105431,"ip_address":"","ucode":"B1F8AE3AD82C51","user_header":"https://static001.geekbang.org/account/avatar/00/10/de/17/75e2b624.jpg","comment_is_top":false,"comment_ctime":1548291505,"is_pvip":false,"replies":[{"id":"22476","content":"我懂你的意思。具体我没研究过。我觉得可以直接存到文件里。节点在文件里的位置表示指针。我瞎猜的：）等我研究研究再说：）","user_name":"作者回复","comment_id":63158,"uid":"1190123","ip_address":"","utype":1,"ctime":1548405026,"user_name_real":"gg"}],"discussion_count":8,"race_medal":0,"score":"173346983345","product_id":100017301,"comment_content":"老师，看了你的讲解，对于B+树的原理，我基本理解了，我又找了b+树的代码实现，也搞懂怎么回事了，当我看懂了，这个B+树的实现了之后，我就有个问题，这个B+树该如何保存到磁盘中呢？我搜索了好多，也没有找到相关的一个代码，你有这相关的资料吗？这种数据一般是如何保存的？谢谢","like_count":40,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437485,"discussion_content":"我懂你的意思。具体我没研究过。我觉得可以直接存到文件里。节点在文件里的位置表示指针。我瞎猜的：）等我研究研究再说：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548405026,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1004349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/3d/1189e48a.jpg","nickname":"微思","note":"","ucode":"853C48AA183A7B","race_medal":4,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":119295,"discussion_content":"寻根究底……好问题啊！","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1578225707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1615539,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI6LXcIqb5K48nia8d4zmdsD1M9AZeyXoGrLzX5xvqfN0fqXOsYKUWLbZvZ8TtJCXWmYbCkCXg93dQ/132","nickname":"漏脚脖","note":"","ucode":"214AE52EC201E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1004349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/3d/1189e48a.jpg","nickname":"微思","note":"","ucode":"853C48AA183A7B","race_medal":4,"user_type":1,"is_pvip":true},"discussion":{"id":182955,"discussion_content":"从隔壁丁老师跳过来的？哈哈哈","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1582463819,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":119295,"ip_address":""},"score":182955,"extra":""}]},{"author":{"id":2732243,"avatar":"https://static001.geekbang.org/account/avatar/00/29/b0/d3/200e82ff.jpg","nickname":"功夫熊猫","note":"","ucode":"D124F4FA4E816F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581863,"discussion_content":"感觉可以看看sqlite，mysql之类的源码分析吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659028967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1308880,"avatar":"https://static001.geekbang.org/account/avatar/00/13/f8/d0/ecc68a4f.jpg","nickname":"🐻🔫🐸","note":"","ucode":"40BABFD9D358BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307790,"discussion_content":"我当时也想过，到底这些数据结构想要进行磁盘固化，到底应该怎么存？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600760389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2071332,"avatar":"","nickname":"Geek_2bb354","note":"","ucode":"79DE924BA274F0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294575,"discussion_content":"隔壁老丁 隔壁老王 有意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595930201,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1092218,"avatar":"https://static001.geekbang.org/account/avatar/00/10/aa/7a/ae8c247d.jpg","nickname":"指尖以东","note":"","ucode":"1DEE134FE92FD0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":273395,"discussion_content":"我觉得用文件，比如rocketmq就参考了mysql的文件设计，有数据文件，索引文件，偏移量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590454510,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1092218,"avatar":"https://static001.geekbang.org/account/avatar/00/10/aa/7a/ae8c247d.jpg","nickname":"指尖以东","note":"","ucode":"1DEE134FE92FD0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309289,"discussion_content":"rocketmq是类似参考mysql，其实还是主要跟kafka做的对比，一个稀疏矩阵一个密集矩阵，针对于kafka无法快速定位消息，以及1000topic以上的并发写会产生抖动的问题，做了很多优化。。。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1601254001,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":273395,"ip_address":""},"score":309289,"extra":""}]}]},{"had_liked":false,"id":75723,"user_name":"hnbc","can_delete":false,"product_type":"c1","uid":1389070,"ip_address":"","ucode":"F6C28A7B7E98F6","user_header":"https://wx.qlogo.cn/mmopen/vi_32/icVicpGetZfB4tJVH5N9vA0JJkhRmw0TNAMUmRoKO2219S0up6IHmo2dPXAxWu9pm49YlAz0oYZLWcu9yXqIgMZA/132","comment_is_top":false,"comment_ctime":1552457537,"is_pvip":false,"replies":[{"id":"27710","content":"这...第一层索引节点可以放到内存里的，这样就3次了：）","user_name":"作者回复","comment_id":75723,"uid":"1190123","ip_address":"","utype":1,"ctime":1552531703,"user_name_real":"gg"}],"discussion_count":5,"race_medal":0,"score":"104631672641","product_id":100017301,"comment_content":"老师，我想问一下100叉树为什么是3次io操作，不应该是4次吗，100的4次方是1亿","like_count":25,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443002,"discussion_content":"这...第一层索引节点可以放到内存里的，这样就3次了：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552531703,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316151,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/37/6df423d7.jpg","nickname":"王亮平","note":"","ucode":"DFAA70518E7431","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271858,"discussion_content":"查了很久该怎么算m叉树每层节点数，还以为自己算法错了😂，原来有前提条件！","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1590206275,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":90369,"discussion_content":"em  我也有这疑问，原来不止头结点，第一层也在内存。。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576768972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1344077,"avatar":"https://static001.geekbang.org/account/avatar/00/14/82/4d/ed67c248.jpg","nickname":"鹅的天牙(Dain) 🐜","note":"","ucode":"EEBE207853E07A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305306,"discussion_content":"同样的疑问，一样怀疑自己算错了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599871657,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1972505,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/19/19/d82e24fb.jpg","nickname":"李润东","note":"","ucode":"65CFEA3C8B27C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":267817,"discussion_content":"但是100*100^3 = 1亿啊... 最后一层有100个叶子节点...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589694225,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":68179,"user_name":"Felix Envy","can_delete":false,"product_type":"c1","uid":1200085,"ip_address":"","ucode":"24E0F2165AD108","user_header":"https://static001.geekbang.org/account/avatar/00/12/4f/d5/e23dc965.jpg","comment_is_top":false,"comment_ctime":1550454481,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"104629669585","product_id":100017301,"comment_content":"看到留言里很多同学都说第二题答案是肯定的，有点不同意。<br>如果区间边界值在在散列表中没有命中，那么就无法定位区间的起始节点。<br>如有错误望指出～","like_count":24,"discussions":[{"author":{"id":1498155,"avatar":"https://static001.geekbang.org/account/avatar/00/16/dc/2b/b16aa5b6.jpg","nickname":"intelliYY","note":"","ucode":"375B28CE130CBE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":85745,"discussion_content":"定位还是没问题的，从头节点往后遍历，只不过成了最原始的方式，效率极低","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576571464,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2027011,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/ee/03/50b5e0d5.jpg","nickname":"hph","note":"","ucode":"83EF84001C3BA9","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369202,"discussion_content":"我也觉得不可行，条件是 a>10 and a<20 如果没有任何一行数据的a=10 和 20，也就是都没有命中，就直接懵逼了，只能从头或者从尾进行遍历，那根本就没法用\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618973217,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":69222,"user_name":"Harry陈祥","can_delete":false,"product_type":"c1","uid":1016584,"ip_address":"","ucode":"EC44D97731116D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/83/08/91caf5c1.jpg","comment_is_top":false,"comment_ctime":1550679167,"is_pvip":false,"replies":[{"id":"24602","content":"b+树主要是用在外部存储上，为了减少磁盘IO次数。<br>跳表比较适合内存存储。<br>实际上，两者本质的设计思想是雷同的，性能差距还是要具体看应用场景，无法从时间复杂度这么宽泛的度量标准来度量了。","user_name":"作者回复","comment_id":69222,"uid":"1190123","ip_address":"","utype":1,"ctime":1550716027,"user_name_real":"gg"}],"discussion_count":2,"race_medal":0,"score":"74565123199","product_id":100017301,"comment_content":"您好。有次面试，面试官直接问我，什么数据结构可以做到O(logn)的范围查询？ 当时没有想到填表，想到了B+树，而且数据库索引确实也是用的B+树。<br>那么问题来了，跳表和B+树在实现难度和性能上有什么区别，在数据量很大的情况下，表现性能如何，为什么redis选跳表？ 谢谢老师","like_count":18,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":440008,"discussion_content":"b+树主要是用在外部存储上，为了减少磁盘IO次数。\n跳表比较适合内存存储。\n实际上，两者本质的设计思想是雷同的，性能差距还是要具体看应用场景，无法从时间复杂度这么宽泛的度量标准来度量了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550716027,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2760780,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKghO4kJwQ5ccuBA2Yox1WlZmq0JUICpNAsgYlOHX0wHGv48xVRKSvF9a6Eic5l2UOjFjnvTnsibibiaw/132","nickname":"Geek_94045a","note":"","ucode":"B8F23BA9D1411B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532090,"discussion_content":"两种都不慢 基本都是对数级别的   实现难度感觉跳表可能代码略少一些，但是难度实现难度级别都差不多，难度就是动态节点分合那块的逻辑  跳表感觉比B+更好，毕竟后发明出来的东西肯定更先进，因为他站在巨人的肩膀上哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637510038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79748,"user_name":"Flash","can_delete":false,"product_type":"c1","uid":1236163,"ip_address":"","ucode":"E285075C9E0B02","user_header":"https://static001.geekbang.org/account/avatar/00/12/dc/c3/e4ba51d5.jpg","comment_is_top":false,"comment_ctime":1553530378,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"65978039818","product_id":100017301,"comment_content":"对于第二题，觉得Jerry银银的答案有问题，可能会误导其他人。希望老师能指正一下，我觉得用链表将散列表节点串起来，不能支持按区间查找。因为散列表的节点是无序的，除非先遍历把散列表的节点放到数组中，进行排序，再用LinkedHashMap遍历存储，这样链表中串的节点才是有序的，直接用链表串散列表节点，是不支持按区间查找的。","like_count":15,"discussions":[{"author":{"id":1652836,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epKJlW7sqts2ZbPuhMbseTAdvHWnrc4ficAeSZyKibkvn6qyxflPrkKKU3mH6XCNmYvDg11tB6y0pxg/132","nickname":"pc","note":"","ucode":"1AD538B9A900B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285570,"discussion_content":"他只是又按顺序维护了一个双向链表而已，相当于每个节点多了两个指针","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1592882504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2223379,"avatar":"https://static001.geekbang.org/account/avatar/00/21/ed/13/5c75a98b.jpg","nickname":"乌呼啦呼","note":"","ucode":"D6B407EB222410","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578687,"discussion_content":"后面备注指的是（插入顺序或者访问顺序）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656945055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2760780,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKghO4kJwQ5ccuBA2Yox1WlZmq0JUICpNAsgYlOHX0wHGv48xVRKSvF9a6Eic5l2UOjFjnvTnsibibiaw/132","nickname":"Geek_94045a","note":"","ucode":"B8F23BA9D1411B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532086,"discussion_content":"银银是按着老杨说的 老杨说的是没错的，hashmap可以干这事，只不过新增的时候时间复杂度是n  因为不存在的key是无法定位的，只能遍历底层链表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637509707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1393673,"avatar":"https://static001.geekbang.org/account/avatar/00/15/44/09/ba2c2470.jpg","nickname":"Mr.Qu","note":"","ucode":"BFE1B89F22C039","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336558,"discussion_content":"这个有序是讲的插入顺序吧，并不是大小排序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608625196,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1254530,"avatar":"https://static001.geekbang.org/account/avatar/00/13/24/82/b5808a60.jpg","nickname":"李冲","note":"","ucode":"C8C12308B0FDDA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":13838,"discussion_content":"hashmap+list确实是可以满足区间要求，只是效率不高O（N），达不到对数级别\n\n你可能理解的不完整，可以看这个练手的lru实现\nhttps://github.com/lichongsw/algorithm/blob/master/lru.go","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568708259,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1798068,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/6f/b4/d465acef.jpg","nickname":"啊噗！","note":"","ucode":"C911E772E1E800","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1254530,"avatar":"https://static001.geekbang.org/account/avatar/00/13/24/82/b5808a60.jpg","nickname":"李冲","note":"","ucode":"C8C12308B0FDDA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":179955,"discussion_content":"不是吧 LRU那个也是按照的插入的时间或者访问顺序来做的啊 也不是数据本身的顺序","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582265421,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":13838,"ip_address":""},"score":179955,"extra":""}]}]},{"had_liked":false,"id":113633,"user_name":"复兴","can_delete":false,"product_type":"c1","uid":1363230,"ip_address":"","ucode":"C172A87873001A","user_header":"https://static001.geekbang.org/account/avatar/00/14/cd/1e/692c3313.jpg","comment_is_top":false,"comment_ctime":1563099170,"is_pvip":false,"discussion_count":9,"race_medal":0,"score":"48807739426","product_id":100017301,"comment_content":"innodb的聚簇索引，不是将数据存储在叶子节点上嘛，这里又说叶子节点不存储数据。","like_count":12,"discussions":[{"author":{"id":1037208,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d3/98/60d13550.jpg","nickname":"Bryan","note":"","ucode":"BA9D6A278609F3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":202107,"discussion_content":"老师的意思应该是 B 树的所有节点都存数据，而 B+ 只有叶子结点存数据，其他只存索引","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1583860301,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1587200,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJt7HQg3dFGVSTZ1bhIMP8tsiaIeERI05Ky1b7PBOEFmmqmnEtcHTenkfWRBVyQMZtAHvlydeJR46g/132","nickname":"鑫","note":"","ucode":"0A4AC6836AEA50","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":194793,"discussion_content":"老师讲的类似非聚集索引","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1583242900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1111271,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f4/e7/91b29c6a.jpg","nickname":"尔与吾靡之","note":"","ucode":"A2671C81A596F5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1587200,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJt7HQg3dFGVSTZ1bhIMP8tsiaIeERI05Ky1b7PBOEFmmqmnEtcHTenkfWRBVyQMZtAHvlydeJR46g/132","nickname":"鑫","note":"","ucode":"0A4AC6836AEA50","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220695,"discussion_content":"讲的是5.5前对MySIAM的B+","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585917688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":194793,"ip_address":""},"score":220695,"extra":""}]},{"author":{"id":1387712,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N6yjnrLnMW4XVSkBr3f0N3F962l35b5j0kib9VSlAqqbf6iaoCPicL1WnJ9KjgT4egQ7A2G0Zx3OayaK4yuoZrUVA/132","nickname":"worthto","note":"","ucode":"41D7ABBBD2E7FF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":248627,"discussion_content":"  首选，B+树的叶子节点存储的是具体的索引数据，相对于非叶子节点来说，他存储的是索引数据的具体值，而非叶子节点，存储的是索引的范围，也就是其子树数据的范围。\n  其次，B+树的叶子节点存储的是是索引数据，相对于数据库的数据来说，B+树叶子节点仅仅存放了索引数据，而非全部数据，如果想获取全部数据。非聚餐索引想要获取全部数据，数据库内部需要先通过索引查询到用户所查询数据的id，然后再通过聚餐索引查询到用户所需要的数据。\n  最后，以上文本手工码字，如有不正确的地方，请多多包涵。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587882416,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1336475,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","nickname":"J.Smile","note":"","ucode":"C4D98DFDBF7584","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1387712,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N6yjnrLnMW4XVSkBr3f0N3F962l35b5j0kib9VSlAqqbf6iaoCPicL1WnJ9KjgT4egQ7A2G0Zx3OayaK4yuoZrUVA/132","nickname":"worthto","note":"","ucode":"41D7ABBBD2E7FF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":255655,"discussion_content":"不对哦，《Mysql实战45讲》提到，“InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的“，又提到“主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引”。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588420059,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":248627,"ip_address":""},"score":255655,"extra":""},{"author":{"id":1387712,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N6yjnrLnMW4XVSkBr3f0N3F962l35b5j0kib9VSlAqqbf6iaoCPicL1WnJ9KjgT4egQ7A2G0Zx3OayaK4yuoZrUVA/132","nickname":"worthto","note":"","ucode":"41D7ABBBD2E7FF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1336475,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","nickname":"J.Smile","note":"","ucode":"C4D98DFDBF7584","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269682,"discussion_content":"主键索引的叶子结点有所有数据，而辅助索引的叶子结点，仅有索引数据，建议联系一下覆盖索引理解这些概念\n","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1589937720,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":255655,"ip_address":""},"score":269682,"extra":""},{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1387712,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N6yjnrLnMW4XVSkBr3f0N3F962l35b5j0kib9VSlAqqbf6iaoCPicL1WnJ9KjgT4egQ7A2G0Zx3OayaK4yuoZrUVA/132","nickname":"worthto","note":"","ucode":"41D7ABBBD2E7FF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331740,"discussion_content":"你这个没有回答他的问题。我的理解是，数据和数据不一样。B+树的叶子节点存储数据（包含指针，指向硬盘，故也是实际数据），非叶子节点存储数据范围即索引。innodb的聚簇索引把上述过程简化，叶子节点之间存储表的行数据，相当于把指针去掉了。因mysql innodb的聚簇索引文件，实际就是数据文件本身。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1606965508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":248627,"ip_address":""},"score":331740,"extra":""}]}]},{"had_liked":false,"id":91363,"user_name":"朱东旭","can_delete":false,"product_type":"c1","uid":1242338,"ip_address":"","ucode":"C48DD620A63868","user_header":"https://static001.geekbang.org/account/avatar/00/12/f4/e2/dbc4a5f2.jpg","comment_is_top":false,"comment_ctime":1557016484,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"48801656740","product_id":100017301,"comment_content":"这里讲的仅仅是单列索引，实际项目中组合索引使用应该比单列索引多，组合索引版的B+树是如何实现的，这个重要的知识点似乎被遗漏了。","like_count":11,"discussions":[{"author":{"id":1242338,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f4/e2/dbc4a5f2.jpg","nickname":"朱东旭","note":"","ucode":"C48DD620A63868","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":109240,"discussion_content":"mysql实战45讲的04，05节讲了联合索引结构，与这节完美搭配。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577676352,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2027011,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/ee/03/50b5e0d5.jpg","nickname":"hph","note":"","ucode":"83EF84001C3BA9","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369204,"discussion_content":"这里主要讲数据结构而不是 索引吧  哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618973352,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331742,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606965635,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":62119,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1547943827,"is_pvip":false,"replies":[{"id":"23155","content":"1. 是的<br>2. 有关系的，就是用多少位表示一个存储地址","user_name":"作者回复","comment_id":62119,"uid":"1190123","ip_address":"","utype":1,"ctime":1549179625,"user_name_real":"gg"}],"discussion_count":3,"race_medal":0,"score":"44497616787","product_id":100017301,"comment_content":"请问：<br>第一段代码，第9行：<br>PAGE_SIZE = (m-1)*4[keywordss 大小]+m*8[children 大小]<br>1，这个8指的是引用（指针）占的内存大小吗？<br>2，引用大小是怎么计算的？和机器是多少位的有什么关系吗？<br>望争哥回复，谢谢！","like_count":10,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437107,"discussion_content":"1. 是的\n2. 有关系的，就是用多少位表示一个存储地址","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549179625,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1177869,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f9/0d/8569f89a.jpg","nickname":"whiplash","note":"","ucode":"885324412FE9D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371513,"discussion_content":"32位操作系统，引用占4个字节。64位系统引用占用8字节，但是可以用JVM参数进行指针压缩，使引用栈占32位。具体可以看这篇文章：https://www.cnblogs.com/rickiyang/p/14206724.html","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619798570,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1442605,"avatar":"https://static001.geekbang.org/account/avatar/00/16/03/2d/404627dc.jpg","nickname":"Anryg Zhun","note":"","ucode":"76DF8560BA9D14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":270615,"discussion_content":"印象中一般系统的指针不都是32位对齐吗 占4个字节 为什么这里是8 意思有两个指针（引用）？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590029781,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":78213,"user_name":"嗯嗯","can_delete":false,"product_type":"c1","uid":1400407,"ip_address":"","ucode":"6A96950ABFA8CA","user_header":"https://static001.geekbang.org/account/avatar/00/15/5e/57/fb18c46a.jpg","comment_is_top":false,"comment_ctime":1553094512,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27322898288","product_id":100017301,"comment_content":"对作者说的那个m云里雾里","like_count":6},{"had_liked":false,"id":109521,"user_name":"mrlay","can_delete":false,"product_type":"c1","uid":1041640,"ip_address":"","ucode":"385A1954ED3317","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e4/e8/a1703783.jpg","comment_is_top":false,"comment_ctime":1562049727,"is_pvip":false,"replies":[{"id":"39742","content":"兄弟对自己要求太高了，你要是学操作系统，还得把操作系统实现一个啊；）","user_name":"作者回复","comment_id":109521,"uid":"1190123","ip_address":"","utype":1,"ctime":1562112336,"user_name_real":"王争"}],"discussion_count":4,"race_medal":0,"score":"23036886207","product_id":100017301,"comment_content":"维持b+树的特性的策略有了，但是如何实现这个策略 以及一些其他问题解决的策略的实现 我有些发怵的感觉，大家一般都是怎么过来的呢？","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456449,"discussion_content":"兄弟对自己要求太高了，你要是学操作系统，还得把操作系统实现一个啊；）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562112336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309291,"discussion_content":"了解下原理即可，感兴趣就深究，不感兴趣就学别的。。没有人做到全才的，你在自己的领域拔尖即可。。。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1601254117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331746,"discussion_content":"赞。和mrlay思路一样，我看B+操作过程这么复杂，想要实现的话，拆分节点也是个难点。看来还是walle兄思路对。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606966289,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":309291,"ip_address":""},"score":331746,"extra":""}]},{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331747,"discussion_content":"我也跟mrlay兄思路一样。幸好两位讨论指点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606966328,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64629,"user_name":"唯她命","can_delete":false,"product_type":"c1","uid":1240398,"ip_address":"","ucode":"8F687E8D306840","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/4e/ef406442.jpg","comment_is_top":false,"comment_ctime":1548838020,"is_pvip":false,"replies":[{"id":"24279","content":"好像不是吧","user_name":"作者回复","comment_id":64629,"uid":"1190123","ip_address":"","utype":1,"ctime":1550541588,"user_name_real":"gg"}],"discussion_count":2,"race_medal":0,"score":"23023674500","product_id":100017301,"comment_content":"老师，现在觉得 你画的图 都是B树  而不是B+树","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438109,"discussion_content":"好像不是吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550541588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2419502,"avatar":"https://static001.geekbang.org/account/avatar/00/24/eb/2e/90fea784.jpg","nickname":"柒","note":"","ucode":"D41241629321A1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583783,"discussion_content":"画的确实是B树","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660378831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64625,"user_name":"唯她命","can_delete":false,"product_type":"c1","uid":1240398,"ip_address":"","ucode":"8F687E8D306840","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/4e/ef406442.jpg","comment_is_top":false,"comment_ctime":1548837311,"is_pvip":false,"replies":[{"id":"24280","content":"咱不要太教科书化啊。理解思想最重要啊。我觉得我讲的没问题啊。","user_name":"作者回复","comment_id":64625,"uid":"1190123","ip_address":"","utype":1,"ctime":1550541647,"user_name_real":"gg"}],"discussion_count":1,"race_medal":0,"score":"23023673791","product_id":100017301,"comment_content":"老师   网上查到的资料  说有k个子树的中间节点包含有k个元素（B树中是k-1个元素） <br>和你讲的不同 ","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438107,"discussion_content":"咱不要太教科书化啊。理解思想最重要啊。我觉得我讲的没问题啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550541647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":61213,"user_name":"有朋自远方来","can_delete":false,"product_type":"c1","uid":1083600,"ip_address":"","ucode":"23A12829DEB119","user_header":"https://static001.geekbang.org/account/avatar/00/10/88/d0/6e75f766.jpg","comment_is_top":false,"comment_ctime":1547638962,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18727508146","product_id":100017301,"comment_content":"1.利用磁盘预读功能2.主簇索引<br>觉得这两点也很重要。","like_count":4},{"had_liked":false,"id":60958,"user_name":"茴香根","can_delete":false,"product_type":"c1","uid":1316111,"ip_address":"","ucode":"B91C00B72077F1","user_header":"https://static001.geekbang.org/account/avatar/00/14/15/0f/954be2db.jpg","comment_is_top":false,"comment_ctime":1547598627,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18727467811","product_id":100017301,"comment_content":"好开心，终于搞清楚经常见到的b+树结构了。从这一节看到对于大数据情况下，m的大小对查询速度有重要影响。如在一些一些特定场合是否可以通过增大内存页和磁盘页大小来进一步提升查询效率。对于思考题中hash做索引，我认为是可行的，但每次更新索引时，如果新进入的节点索引需要插入到相应的位置，要保持叶子链表的有序。","like_count":4},{"had_liked":false,"id":179387,"user_name":"发霉的宅大人","can_delete":false,"product_type":"c1","uid":1738243,"ip_address":"","ucode":"6757E30FE5E48D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/03/95004954.jpg","comment_is_top":false,"comment_ctime":1581994798,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"14466896686","product_id":100017301,"comment_content":"思考题<br>第一题：看需求，如果需要用到链表反序遍历就用双向<br>第二题：可以，前提是散列表对应的那些链表子节点，除了“拉链hnext”之外另外构成的双向链表一定要是有序的。<br>虽然我们的散列表的hash值储存无序，但是范围查找的时候，我们就从hash表的第一个去查，然后两个指针分别往前往后遍历直至找到范围边界值。<br>时间复杂度是0（N），运气差我们刚好是头结点，另一个指针就要遍历到链表尾，总共循环N次。","like_count":3,"discussions":[{"author":{"id":1442605,"avatar":"https://static001.geekbang.org/account/avatar/00/16/03/2d/404627dc.jpg","nickname":"Anryg Zhun","note":"","ucode":"76DF8560BA9D14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":270641,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590031750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1321934,"avatar":"https://static001.geekbang.org/account/avatar/00/14/2b/ce/15a82b5c.jpg","nickname":"高学义","note":"","ucode":"4B1AA896B567B2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":209701,"discussion_content":"理解的很好，赞一个！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584666636,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153849,"user_name":"小喵喵","can_delete":false,"product_type":"c1","uid":1062444,"ip_address":"","ucode":"FDBBB2A59DB8B6","user_header":"https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg","comment_is_top":false,"comment_ctime":1574317797,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14459219685","product_id":100017301,"comment_content":"理论上讲，对跳表稍加改造，也可以替代 B+ 树，作为数据库的索引实现的。<br>关于这个，我简单说下我的理解：1.跳表的原始链表也都采用双向链表存储。2.跳表的层数是动态增加(减少)。增加(减少)对应B+数中的节点的分裂(合并)。不知道我的理解对不对，或者还有那些那些考虑到的，请老师指点下。","like_count":3,"discussions":[{"author":{"id":1737886,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/84/9e/d4c0e2c4.jpg","nickname":"Broadm","note":"","ucode":"BEA06300731AE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374063,"discussion_content":"跳表和B+数,最大的区别是,跳表的层数完全是随机的, 这不适合索引IO,会导致查询性能不稳定","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1620983902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":86140,"user_name":"H.L.","can_delete":false,"product_type":"c1","uid":1207529,"ip_address":"","ucode":"125D13548A0CA5","user_header":"https://static001.geekbang.org/account/avatar/00/12/6c/e9/377a3b09.jpg","comment_is_top":false,"comment_ctime":1555313520,"is_pvip":false,"replies":[{"id":"30976","content":"叶子节点存对象 对象包含key和data","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1555372327,"ip_address":"","comment_id":86140,"utype":1}],"discussion_count":3,"race_medal":0,"score":"14440215408","product_id":100017301,"comment_content":"叶子节点的数据是如何存储的？比如mysql的b+树，key放在一堆，data放在一堆？","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446895,"discussion_content":"叶子节点存对象 对象包含key和data","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555372327,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331797,"discussion_content":"赞。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606980691,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309294,"discussion_content":"1、非叶子结点是 存储的是索引，key + 指针，一页固定X KB，key跟指针大小决定，索引块存储多少数据，决定几层的树存储多少数据\n2、叶子结点，非聚簇索引，存储的是key + 主键;聚簇索引存储的是key + 数据。\n3、如果使用非聚簇索引，但是没有覆盖到要求的数据，一般都要回表一次，读取主键索引获取整行的数据，所以主键索引最快，其次，使用非聚簇索引又不用回表。即非聚簇索引包含你要的数据\n推荐看下 隔壁丁奇老师的 mysql课程。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601254487,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":61606,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1547734147,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"14432636035","product_id":100017301,"comment_content":"先回答思考题：<br>1. 双向链表，为了支持在O(logn)时间复杂度删除节点<br>2.支持按区间查找数据。那么问题来了，为什么mysql索引不采用散列表+双向链表的数据结果来实现呢？","like_count":3,"discussions":[{"author":{"id":1442605,"avatar":"https://static001.geekbang.org/account/avatar/00/16/03/2d/404627dc.jpg","nickname":"Anryg Zhun","note":"","ucode":"76DF8560BA9D14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":270635,"discussion_content":"可以保证key有序 只是时间复杂度就高了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590031413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1615539,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI6LXcIqb5K48nia8d4zmdsD1M9AZeyXoGrLzX5xvqfN0fqXOsYKUWLbZvZ8TtJCXWmYbCkCXg93dQ/132","nickname":"漏脚脖","note":"","ucode":"214AE52EC201E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":182970,"discussion_content":"我觉得双链表插入一个节点排序的话是O(N)吧，而b+树插入一个节点O(logN)就可以保证顺序了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582464189,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1644104,"avatar":"https://static001.geekbang.org/account/avatar/00/19/16/48/09493874.jpg","nickname":"茶没喝完","note":"","ucode":"D72D88C42A1258","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54416,"discussion_content":"我的觉得 散列+链表 只能保存插入的顺序，并不能保证是大小顺序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574298775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1250907,"avatar":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","nickname":"Monday","note":"","ucode":"77B9BACC783598","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1644104,"avatar":"https://static001.geekbang.org/account/avatar/00/19/16/48/09493874.jpg","nickname":"茶没喝完","note":"","ucode":"D72D88C42A1258","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54640,"discussion_content":"链表可以是插入顺序也可以是大小顺序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574307041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":54416,"ip_address":""},"score":54640,"extra":""}]},{"author":{"id":1599044,"avatar":"https://static001.geekbang.org/account/avatar/00/18/66/44/81539d64.jpg","nickname":"v","note":"","ucode":"DA3B754608EDD8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2021,"discussion_content":"散列 怎么排序啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563181927,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1250907,"avatar":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","nickname":"Monday","note":"","ucode":"77B9BACC783598","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1599044,"avatar":"https://static001.geekbang.org/account/avatar/00/18/66/44/81539d64.jpg","nickname":"v","note":"","ucode":"DA3B754608EDD8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3329,"discussion_content":"双向链表支持o(n)的排序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564398366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2021,"ip_address":""},"score":3329,"extra":""},{"author":{"id":1798068,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/6f/b4/d465acef.jpg","nickname":"啊噗！","note":"","ucode":"C911E772E1E800","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1250907,"avatar":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","nickname":"Monday","note":"","ucode":"77B9BACC783598","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":179958,"discussion_content":"是啊 那也是需要排序啊 在不排序之前 怎么支持按区间查找？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582265549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3329,"ip_address":""},"score":179958,"extra":""}]}]},{"had_liked":false,"id":60956,"user_name":"yaya","can_delete":false,"product_type":"c1","uid":1233856,"ip_address":"","ucode":"8C7FAC8F828BA4","user_header":"https://static001.geekbang.org/account/avatar/00/12/d3/c0/d38daa2d.jpg","comment_is_top":false,"comment_ctime":1547598553,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14432500441","product_id":100017301,"comment_content":"1从图上来看，b+叶结点串起来的是双向链表<br>2不可以，因为散列表的是被mod后的，查询区间依然需要遍历所有结点<br>以前学b+树的时候，完全不知道它为什么这样设计，感觉很奇怪，今天才明白是为了提供区间查询，优化操作次数。","like_count":3},{"had_liked":false,"id":64551,"user_name":"唯她命","can_delete":false,"product_type":"c1","uid":1240398,"ip_address":"","ucode":"8F687E8D306840","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/4e/ef406442.jpg","comment_is_top":false,"comment_ctime":1548819070,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10138753662","product_id":100017301,"comment_content":"应该是每个结点至少有[ceil(m &#47; 2)]个孩子  而不是m &#47; 2","like_count":2},{"had_liked":false,"id":64377,"user_name":"田伟 คิดถึง","can_delete":false,"product_type":"c1","uid":1280941,"ip_address":"","ucode":"401C8EB3748A34","user_header":"https://static001.geekbang.org/account/avatar/00/13/8b/ad/6325c4c4.jpg","comment_is_top":false,"comment_ctime":1548758996,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10138693588","product_id":100017301,"comment_content":"B+树和跳表很像，都是双向链表+索引的结构，数据都放在最下边，利用二分查找进行有序数列查找，区别是啥？我猜想主要区别在索引：<br>1.高度：同数量级的数据，跳表索引的高度会很高，IO读取次数多，影响查询性能<br>2.页空间浪费：mysql默认页空间16K,跳表默认一个节点只存一个数，其他空间都浪费了","like_count":2},{"had_liked":false,"id":61114,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1547621989,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10137556581","product_id":100017301,"comment_content":"思考题<br>第二问: 肯定是不行的 因为hash标结点内的链表数据并不一定有序 并不能保证一定能进行范围查找要支持范围查找必定要有序 不然也不可能基于平衡二叉树来构建B+树<br><br>第一问:  我觉得是双向链表 支持 数据库 查询时 类似 id &lt; 1000这种查询操作<br> ","like_count":2},{"had_liked":false,"id":60961,"user_name":"五岳寻仙","can_delete":false,"product_type":"c1","uid":1247467,"ip_address":"","ucode":"88A46A4E1832CE","user_header":"https://static001.geekbang.org/account/avatar/00/13/08/eb/594e9e6c.jpg","comment_is_top":false,"comment_ctime":1547598780,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10137533372","product_id":100017301,"comment_content":"课后思考题1<br>我觉得应该是双链表。对于区间查找，我们既需要支持大于某个值的查找(向右遍历)，也需要支持小于某个值的查找(向左遍历)。<br><br>思考题2<br>我觉得不可以。因为散列表结点存储的数据是无序的。","like_count":2},{"had_liked":false,"id":270671,"user_name":"Jahng","can_delete":false,"product_type":"c1","uid":1325514,"ip_address":"","ucode":"5D5789EAAC4739","user_header":"https://static001.geekbang.org/account/avatar/00/14/39/ca/4a07bfd8.jpg","comment_is_top":false,"comment_ctime":1609211920,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5904179216","product_id":100017301,"comment_content":"针对问题一，很多人说是因为asc和desc排序，所以要用双链表，但是个人觉得，应该是查询条件有 &gt;100,&lt;100和区间，如果单链表，无法满足三种情况","like_count":1},{"had_liked":false,"id":233976,"user_name":"星辰大海","can_delete":false,"product_type":"c1","uid":1350567,"ip_address":"","ucode":"503090B6D2BBCE","user_header":"https://static001.geekbang.org/account/avatar/00/14/9b/a7/e360afbb.jpg","comment_is_top":false,"comment_ctime":1594541983,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5889509279","product_id":100017301,"comment_content":"老师的课我看了一半了，都很用心，应该是极客时间最好的课了。<br>不过这一节似乎有处小问题，图中父结点的值应该是与子节点的第一个值相等的。因为父节点不存储记录，只存储索引。","like_count":1},{"had_liked":false,"id":226179,"user_name":"肖臧","can_delete":false,"product_type":"c1","uid":1047733,"ip_address":"","ucode":"4FAC9FF54DD6A0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fc/b5/ac717737.jpg","comment_is_top":false,"comment_ctime":1591972485,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5886939781","product_id":100017301,"comment_content":"getconf PAGE_SIZE和getconf PAGESIZE","like_count":1},{"had_liked":false,"id":182242,"user_name":"程序员班吉","can_delete":false,"product_type":"c1","uid":1478098,"ip_address":"","ucode":"BD48CF7649609A","user_header":"https://static001.geekbang.org/account/avatar/00/16/8d/d2/8a6be8d8.jpg","comment_is_top":false,"comment_ctime":1582732224,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5877699520","product_id":100017301,"comment_content":"如果m叉树只存储索引，不存储数据，那真正的数据是通过什么数据结构存储起来的","like_count":1},{"had_liked":false,"id":182107,"user_name":"Lywane","can_delete":false,"product_type":"c1","uid":1446512,"ip_address":"","ucode":"2B0027AA069CE9","user_header":"https://static001.geekbang.org/account/avatar/00/16/12/70/10faf04b.jpg","comment_is_top":false,"comment_ctime":1582710424,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5877677720","product_id":100017301,"comment_content":"1、尽量让每个节点的大小等于一个页的大小，节点的大小是指什么？<br>2、m 值是根据页的大小事先计算好的，老师能讲讲这个计算过程吗，","like_count":1,"discussions":[{"author":{"id":1139455,"avatar":"https://static001.geekbang.org/account/avatar/00/11/62/ff/f71034e9.jpg","nickname":"悟空WuKong","note":"","ucode":"49AFD2B048C1BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213762,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585119483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175829,"user_name":"注定非凡","can_delete":false,"product_type":"c1","uid":1113597,"ip_address":"","ucode":"80673056E131B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","comment_is_top":false,"comment_ctime":1580864246,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5875831542","product_id":100017301,"comment_content":"若对数据库的操作非常了解，就能把索引的需求定义得非常清楚。但是大部分情况是我们只了解一小部分常用的 SQL 语句。<br>所以假设要解决的问题，只包含这样两个常用的需求：<br><br>根据某个值查找，如 select * from user where id=1234；<br>根据区间值查找，如 select * from user where id &gt; 1234 and id &lt; 2345。<br>除了这些功能性需求之外，这种问题往往还会涉及一些非功能性需求，如安全、性能、用户体验等等<br><br>数据库索引所用到的数据结构跟跳表非常相似，叫作 B+ 树。但它是通过二叉查找树演化过来的，而非跳表。<br>3. 改造二叉查找树来解决这个问题<br>为了让二叉查找树支持按照区间来查找数据，对它进行改造：<br><br><br>1，树中的节点并不存储数据本身，而是只是作为索引。<br>2，除此之外，把每个叶子节点串在一条链表上，链表中的数据是从小到大有序的。<br><br>改造之后，若要求某个区间的数据。只需要拿区间的起始值，在树中进行查找，当查找到某个叶子节点之后，我们再顺着链表往后遍历，直到链表中的结点数据值大于区间的终止值为止。所有遍历到的数据，就是符合区间值的所有数据。<br>如给一亿个数据构建二叉查找树索引，索引中会包含大约 1 亿个节点，每个节点假设占用 16 个字节，那就需要大约 1GB 的内存空间。<br><br>如何解决这个索引占用太多内存的问题？<br><br>1，借助时间换空间的思路，把索引存储在硬盘中，而非内存中<br>    尽管减少了内存消耗，但通常内存的访问速度是纳秒级别的，而磁盘访问的速度是毫秒级别的，因此数据查询效率就相应降低很多，所以不适用<br><br>2，把二叉查找树存储在硬盘中，那么每个节点的读取（或者访问），都对应一次磁盘 IO 操作<br>    所以：树的高度就等于每次查询数据时磁盘 IO 操作的次数<br>    所以：优化的重点就是尽量减少磁盘 IO 操作，也就是，尽量降低树的高度<br>那如何降低树的高度？如果把索引构建成 m 叉树，高度是否比二叉树要小？<br>\t* <br>若给 16 个数据构建二叉树索引，树的高度是 4，查找一个数据，就需要 4 个磁盘 IO 操作（如果根节点存储在内存中，其他结点存储在磁盘中），<br>\t* <br>若对 16 个数据构建五叉树索引，那高度只有 2，查找一个数据，对应只需要 2 次磁盘操作。<br>\t* <br>如果 m 叉树中的 m 是 100，那对一亿个数据构建索引，树的高度也只是 3，最多只要 3 次磁盘 IO 就能获取到数据。磁盘 IO 变少了，查找数据的效率也就提高了。<br><br><br>对于相同个数的数据构建 m 叉树索引，m 叉树中的 m 越大，那树的高度就越小<br>那 m 叉树中的 m 是不是越大越好？到底多大才最合适？<br>\t* <br>不管是内存中的数据，还是磁盘中的数据，操作系统都是按页（一页大小通常是 4KB，这个值可以通过 getconfig PAGE_SIZE 命令查看）来读取的，一次会读一页的数据<br>\t* <br>如果要读取的数据量超过一页的大小，就会触发多次 IO 操作。<br><br><br>所以，在选择 m 大小的时候，要尽量让每个节点的大小等于一个页的大小。读取一个节点，只需要一次磁盘 IO 操作。<br><br>索引有利也有弊，可以提高数据库的查询效率,它也会让写入数据的效率下降,数据的写入过程，涉及索引的更新，这是索引导致写入变慢的主要原因<br>\t* <br>对于一个 B+ 树，m 值是根据页的大小事先计算好的，即每个节点最多只能有 m 个子节点<br>\t* <br>往数据库中写入数据的过程中，可能使索引中某些节点的子节点个数超过 m，这个节点的大小超过了一个页的大小，读取这样的节点会导致多次磁盘 IO 操作<br><br><br>该如何解决这个问题？<br>\t* <br>只需要将这个节点分裂成两个节点<br>\t* <br>但是，节点分裂之后，其上层父节点的子节点个数就有可能超过 m 个，则同样将父节点也分裂成两个节点。<br>\t* <br>这种级联反应会从下往上，一直影响到根节点。<br><br><br><br>正是因为要时刻保证 B+ 树索引是一个 m 叉树，所以，索引的存在会导致数据库写入的速度降低。<br>实际上不光写入数据会变慢，删除数据也会变慢。这是为什么呢？<br>\t* <br>在删除某个数据的时候，也要对应的更新索引节点。<br>\t* <br>这个处理思路有点类似跳表中删除数据的处理思路。<br>\t* <br>频繁的数据删除，就会导致某些结点中，子节点的个数变得非常少，长此以往，如果每个节点的子节点都比较少，势必会影响索引的效率。<br><br><br>如何解决这个问题？<br>\t* <br>我们可以设置一个阈值。<br>\t* <br>在 B+ 树中，这个阈值等于 m&#47;2。如果某个节点的子节点个数小于 m&#47;2，我们就将它跟相邻的兄弟节点合并。<br>\t* <br>不过，合并之后结点的子节点个数有可能会超过 m。针对这种情况，可以借助插入数据时候的处理方法，再分裂节点。<br>","like_count":1},{"had_liked":false,"id":159021,"user_name":"Geek_67ccd5","can_delete":false,"product_type":"c1","uid":1564443,"ip_address":"","ucode":"A47E60E36E4EEC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/pMWn0BhzNeo4XFOdjbgJPP3xopv2g5wtqOzFyVPnuo7wls8nWcxWeQdbTBpnib2GWmzy1f2AI2ibzWX5hWnc455w/132","comment_is_top":false,"comment_ctime":1575516047,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5870483343","product_id":100017301,"comment_content":"是getconf PAGE_SIZE<br>哈哈哈","like_count":1,"discussions":[{"author":{"id":1018494,"avatar":"","nickname":"whhbbq","note":"","ucode":"4A93F3E375CB44","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":167662,"discussion_content":"正解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581516117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142680,"user_name":"汪大强","can_delete":false,"product_type":"c1","uid":1334700,"ip_address":"","ucode":"614F5453646EF2","user_header":"https://static001.geekbang.org/account/avatar/00/14/5d/ac/cf27249f.jpg","comment_is_top":false,"comment_ctime":1571455344,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5866422640","product_id":100017301,"comment_content":"“如果 m 叉树中的 m 是 100，那对一亿个数据构建索引，树的高度也只是 3“<br>树的高度应该是4<br><br>","like_count":1},{"had_liked":false,"id":139450,"user_name":"吴小智","can_delete":false,"product_type":"c1","uid":1310798,"ip_address":"","ucode":"C7C9F58B5C9F7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","comment_is_top":false,"comment_ctime":1570638953,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5865606249","product_id":100017301,"comment_content":"来温习了，依然收获满满。","like_count":1},{"had_liked":false,"id":96951,"user_name":"w 🍍","can_delete":false,"product_type":"c1","uid":1228290,"ip_address":"","ucode":"F2386C971EC58B","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/02/43202976.jpg","comment_is_top":false,"comment_ctime":1558546736,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5853514032","product_id":100017301,"comment_content":"示例代码如何从非叶子结点到叶子结点呢.","like_count":1},{"had_liked":false,"id":78793,"user_name":"one","can_delete":false,"product_type":"c1","uid":1234736,"ip_address":"","ucode":"297FF7940E7C06","user_header":"","comment_is_top":false,"comment_ctime":1553241175,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5848208471","product_id":100017301,"comment_content":"老师，B+tree落盘有写好的代码吗，网上对落盘并没有讲的很清楚，望讲解一下B+tree落盘问题。","like_count":1},{"had_liked":false,"id":63801,"user_name":"睡痴儿😑","can_delete":false,"product_type":"c1","uid":1187204,"ip_address":"","ucode":"750EF858EF2042","user_header":"https://static001.geekbang.org/account/avatar/00/12/1d/84/d0ec0064.jpg","comment_is_top":false,"comment_ctime":1548510271,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5843477567","product_id":100017301,"comment_content":"那块b+树添加的部分如果是二叉树，且限定条件是节点的子节点都是两个的话，会出现最顶层有两个节点的情况啊","like_count":1},{"had_liked":false,"id":60985,"user_name":"一道阳光","can_delete":false,"product_type":"c1","uid":1239557,"ip_address":"","ucode":"F35207CCCEC6E2","user_header":"https://static001.geekbang.org/account/avatar/00/12/ea/05/c0d8014d.jpg","comment_is_top":false,"comment_ctime":1547601081,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5842568377","product_id":100017301,"comment_content":"我觉得是双向链表，sql语句中有按照从大到小进行排序，当使用索引进行排序时，如果是单向链表，还要把数据取出来放入内存中排序，效率降低，如果排序的数据较多，内存不够，还会借助外部文件通过归并排序进行排序，效率很低。不知道说的对不对。","like_count":1},{"had_liked":false,"id":60949,"user_name":"K战神","can_delete":false,"product_type":"c1","uid":1139367,"ip_address":"","ucode":"527E6BB26BB766","user_header":"https://static001.geekbang.org/account/avatar/00/11/62/a7/3e6fee86.jpg","comment_is_top":false,"comment_ctime":1547597970,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5842565266","product_id":100017301,"comment_content":"打卡","like_count":1},{"had_liked":false,"id":354422,"user_name":"柒","can_delete":false,"product_type":"c1","uid":2419502,"ip_address":"上海","ucode":"D41241629321A1","user_header":"https://static001.geekbang.org/account/avatar/00/24/eb/2e/90fea784.jpg","comment_is_top":false,"comment_ctime":1660378907,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660378907","product_id":100017301,"comment_content":"图里面确实画的又像B树，又像B+树。 B+树还有一个特点：所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素","like_count":0},{"had_liked":false,"id":345874,"user_name":"苏成","can_delete":false,"product_type":"c1","uid":2668694,"ip_address":"","ucode":"80A8E7B243DD73","user_header":"https://static001.geekbang.org/account/avatar/00/28/b8/96/716ba431.jpg","comment_is_top":false,"comment_ctime":1652671563,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1652671563","product_id":100017301,"comment_content":"B+树<br><br>1. 需求<br>   - 功能需求：值查找，区间查找<br>   - 性能需求：快速，占用的空间小<br>2. 从二叉树到B+树<br>   - 支持区间查找（参考跳表）：节点不存储数据存索引，叶子节点是双向链表（desc,asc）<br>   - 索引存在硬盘：索引太多，存储空间不够<br>   - IO次数等于树高度（降低树高）：m叉树<br>   - m的大小等于OS的页大小<br>   - 节点分裂：保证m叉树插入效率<br>   - 节点合并：阈值m&#47;2，保证删除","like_count":0},{"had_liked":false,"id":332113,"user_name":"君君","can_delete":false,"product_type":"c1","uid":2475333,"ip_address":"","ucode":"F80150E68EB5FA","user_header":"https://static001.geekbang.org/account/avatar/00/25/c5/45/78fa500c.jpg","comment_is_top":false,"comment_ctime":1643025601,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643025601","product_id":100017301,"comment_content":"看评论都能学到很多啊🤔","like_count":0},{"had_liked":false,"id":322967,"user_name":"DonaldCen","can_delete":false,"product_type":"c1","uid":1372609,"ip_address":"","ucode":"5DA0A28613E9AD","user_header":"https://static001.geekbang.org/account/avatar/00/14/f1/c1/f9bfcd08.jpg","comment_is_top":false,"comment_ctime":1637672743,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1637672743","product_id":100017301,"comment_content":"有点好奇，想知道联合索引  根节点，叶子节点以及层高这些和普通索引的异同","like_count":0},{"had_liked":false,"id":322634,"user_name":"Geek_94045a","can_delete":false,"product_type":"c1","uid":2760780,"ip_address":"","ucode":"B8F23BA9D1411B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKghO4kJwQ5ccuBA2Yox1WlZmq0JUICpNAsgYlOHX0wHGv48xVRKSvF9a6Eic5l2UOjFjnvTnsibibiaw/132","comment_is_top":false,"comment_ctime":1637510287,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637510287","product_id":100017301,"comment_content":"我咋感觉如果跳表早发明出来就没有以上这些结构（红黑树或B+树等等）什么事了呢","like_count":0},{"had_liked":false,"id":321826,"user_name":"长期规划","can_delete":false,"product_type":"c1","uid":1019332,"ip_address":"","ucode":"5EF65E9115834B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","comment_is_top":false,"comment_ctime":1637055623,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637055623","product_id":100017301,"comment_content":"老师，我想问下，对于m=3的B+树，应该是可以用于内存数据的增删改查，以及范围查找的，这样的话，就跟跳表差不多了。但实际中这样用得比较少，是有什么原因吗","like_count":0},{"had_liked":false,"id":311350,"user_name":"大明猩","can_delete":false,"product_type":"c1","uid":1494622,"ip_address":"","ucode":"61D330B42AE3C4","user_header":"https://static001.geekbang.org/account/avatar/00/16/ce/5e/b103d538.jpg","comment_is_top":false,"comment_ctime":1631181863,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1631181863","product_id":100017301,"comment_content":"网上好多说为什么用B+而不用跳表的，个人看法：单纯就是因为跳表比B+出现的晚吧，感觉跳表是能满足B+的条件的。时间复杂度什么的都差不多，空间复杂度、磁盘访问可能区别，但是这些应该可以进行优化吧，单纯看这两种的数据结构其实是相近的，可能数据量特别大的时候跳表建的层会比较多，但是应该可以优化吧","like_count":0},{"had_liked":false,"id":305573,"user_name":"William Ning","can_delete":false,"product_type":"c1","uid":1592279,"ip_address":"","ucode":"4DB8D05E69E5F3","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","comment_is_top":false,"comment_ctime":1628054268,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1628054268","product_id":100017301,"comment_content":"跳跃列表由威廉·普发明。[2]发明者对跳跃列表的评价是：“跳跃列表是在很多应用中有可能替代平衡树而作为实现方法的一种数据结构。跳跃列表的算法有同平衡树一样的渐进的预期时间边界，并且更简单、更快速和使用更少的空间。”<br><br>--- https:&#47;&#47;zh.wikipedia.org&#47;wiki&#47;跳跃列表<br>--- https:&#47;&#47;en.wikipedia.org&#47;wiki&#47;Skip_list","like_count":0},{"had_liked":false,"id":300971,"user_name":"夕林语","can_delete":false,"product_type":"c1","uid":1264180,"ip_address":"","ucode":"B57681D0C73E1B","user_header":"https://static001.geekbang.org/account/avatar/00/13/4a/34/1faac99b.jpg","comment_is_top":false,"comment_ctime":1625472583,"is_pvip":false,"discussion_count":0,"race_medal":2,"score":"1625472583","product_id":100017301,"comment_content":"课后思考：<br>1.双向链表，为了支持排序；<br>2.也可以支持按照区间来查找数据，Java中的LinkedHashMap就是可以保证数据存入顺序而定义的数据结构","like_count":0},{"had_liked":false,"id":297620,"user_name":"逆境风起","can_delete":false,"product_type":"c1","uid":1513978,"ip_address":"","ucode":"4036413080B595","user_header":"https://static001.geekbang.org/account/avatar/00/17/19/fa/592af782.jpg","comment_is_top":false,"comment_ctime":1623673886,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623673886","product_id":100017301,"comment_content":"老师您好，最近在动手实现B+树，遇到一些问题想请教老师：<br>1、文中对B+树的介绍是以 m-阶B+树为例的；而代码实现中区分了B+树非叶子节点的阶 m 和叶子结点的阶 k 。在实际的数据库中，为了更好地保证一次磁盘  I&#47;O 恰好读取一块，理论上应该将 m 和 k 分别设置，但是文中没有对这一点进行介绍。对这个问题我查了一些资料，网上大都以 m 阶B+树为例进行介绍的，所以请问老师在实际的数据库B+树实现中，究竟是以哪种方式实现的？<br>2、文中对B+树介绍未说明是否允许重复键值，如果允许重复键值，B+树的定义和相关算法有哪些变化呢？<br>谢谢老师解答！","like_count":0},{"had_liked":false,"id":295150,"user_name":"vv_test","can_delete":false,"product_type":"c1","uid":1685884,"ip_address":"","ucode":"1D164B2F034E2B","user_header":"https://static001.geekbang.org/account/avatar/00/19/b9/7c/afe6f1eb.jpg","comment_is_top":false,"comment_ctime":1622273381,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622273381","product_id":100017301,"comment_content":"第二题是可以的，只是维持这个有序链表会比较耗时吧，假如现在已经插入了1235，那么现在要插入4，他得遍历链表的位置。但是根据跳表那章思路，假如数据是整数，我们可以优化一下，先试着找一下散列表与相邻的整数是不是存在，不存在再试着再小的数字。某种条件下了都不满足再遍历链表。","like_count":0},{"had_liked":false,"id":293019,"user_name":"Geek_656d5d","can_delete":false,"product_type":"c1","uid":1739154,"ip_address":"","ucode":"2310D7F17B580B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ7zxh7QCGhNErT3smLWN5syiabJvkuqoneGeRqPtw5CA1jSdLX7VhiczLXpibEyqO7yFvQg9BE7UUrA/132","comment_is_top":false,"comment_ctime":1621157008,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621157008","product_id":100017301,"comment_content":"mysql为什么不用跳表呢？","like_count":0},{"had_liked":false,"id":292742,"user_name":"🍭","can_delete":false,"product_type":"c1","uid":2260986,"ip_address":"","ucode":"A515C1C5DC0E13","user_header":"https://static001.geekbang.org/account/avatar/00/22/7f/fa/b244f3a3.jpg","comment_is_top":false,"comment_ctime":1620958592,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620958592","product_id":100017301,"comment_content":"B+树设计：<br>1、减少磁盘IO。<br>2、减少树的深度。<br>3、n叉树。<br>4、为了节省内存，如果把树存储在硬盘中，那么每个节点的读取（或者访问），都对应一次磁盘 IO 操作。树的高度就等于每次查询数据时磁盘 IO 操作的次数。<br>","like_count":0},{"had_liked":false,"id":289038,"user_name":"高鹏0409","can_delete":false,"product_type":"c1","uid":1928337,"ip_address":"","ucode":"1833CA764B6A46","user_header":"https://static001.geekbang.org/account/avatar/00/1d/6c/91/8268a753.jpg","comment_is_top":false,"comment_ctime":1618825220,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618825220","product_id":100017301,"comment_content":"MySQL innodb的数据存储：<br>1. 非叶子节点，一个page能装几个key，就是几叉树。<br>2. 叶子节点page能装几条数据就装几条数据。<br>innodb的一个page=16k","like_count":0},{"had_liked":false,"id":278753,"user_name":"骑着驴读着书的谢小夕","can_delete":false,"product_type":"c1","uid":1625340,"ip_address":"","ucode":"56F0A469B630A2","user_header":"https://static001.geekbang.org/account/avatar/00/18/cc/fc/92646317.jpg","comment_is_top":false,"comment_ctime":1613295200,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613295200","product_id":100017301,"comment_content":"B+ 树就是跳跃表和234 树的改进版； <br><br>B 树就是 仿234 树","like_count":0},{"had_liked":false,"id":272471,"user_name":"Story","can_delete":false,"product_type":"c1","uid":1238865,"ip_address":"","ucode":"433F18FA8E28F3","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/51/9a357c5b.jpg","comment_is_top":false,"comment_ctime":1610095795,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610095795","product_id":100017301,"comment_content":"总感觉少了点什么东西，代码实现不来，是不是BPlusTreeNode中应该有BPlusTreeLeafNode的这个引用，不然查询从BPlusTreeLeafNode这个双向链表的开始遍历吗。","like_count":0},{"had_liked":false,"id":266987,"user_name":"万历十五年","can_delete":false,"product_type":"c1","uid":1122150,"ip_address":"","ucode":"3D8CF5DF847AE8","user_header":"https://static001.geekbang.org/account/avatar/00/11/1f/66/59e0647a.jpg","comment_is_top":false,"comment_ctime":1607564004,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607564004","product_id":100017301,"comment_content":"对于问题二：数据库表的索引用散列表和双向链表来实现，通过散列表实现查找，添加和删除单个元素，时间复杂度O(1),。对于区间查找，如果散列表命中,则时间复杂度O(1)，如果不命中，再通过链表顺序查找，则时间复杂度O(n)。内存使用，假设每个索引字段平均10字节，对应的散列表和链表指针各4个字节，则每个索引需要22字节，表有500万条目，则需要110M字节，考虑散列表装载因子0.75，则需要150MB。","like_count":0},{"had_liked":false,"id":261575,"user_name":"Geek_0496ff","can_delete":false,"product_type":"c1","uid":2319064,"ip_address":"","ucode":"3745DBDFA5C8E6","user_header":"","comment_is_top":false,"comment_ctime":1605427354,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605427354","product_id":100017301,"comment_content":"mysql没有用跳表的数据结构作为索引结构，八卦地猜测下了原因，Monty Widenius 在1990年开始想弄一个东西叫 mysql 1996年发布第一个版本。而跳表的数据结构是William Pugh在1990年发明的。时间不够哈哈哈，时间都是百度的，不知道准不准","like_count":0},{"had_liked":false,"id":261340,"user_name":"Fire","can_delete":false,"product_type":"c1","uid":2057513,"ip_address":"","ucode":"8D3E102E690443","user_header":"https://static001.geekbang.org/account/avatar/00/1f/65/29/8c0fe011.jpg","comment_is_top":false,"comment_ctime":1605276899,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1605276899","product_id":100017301,"comment_content":"文中提到“理论上讲，对跳表稍加改造，也可以替代 B+ 树，作为数据库的索引实现的。”<br>很好奇，要怎么改造呢？？","like_count":0},{"had_liked":false,"id":245067,"user_name":"xdargs","can_delete":false,"product_type":"c1","uid":1063740,"ip_address":"","ucode":"EB8326D3A72DE5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoH9Mlw0kLK0p39vhQpdvkbQP5TX96DB9HMJ1POaTVDpMZg4rjlO3WCAqiaWWMc77ffS3vTo8qWdXA/132","comment_is_top":false,"comment_ctime":1598802607,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1598802607","product_id":100017301,"comment_content":"&quot;如果 m 叉树中的 m 是 100，那对一亿个数据构建索引，树的高度也只是 3，最多只要 3 次磁盘 IO 就能获取到数据。&quot;<br><br>完全二叉树，高度logn，此处m叉树，则高度(即层数-1)为：logm(n)<br>n为一亿(10^8)，则高度为 log100(10^8) = 4，3是怎么来的？<br>找了评论，老师解释是第一层(除了根节点外)也放到内存，所以其他的就只要3次<br>不过跟5叉树对比一下看，高度是不是应该还是3","like_count":0},{"had_liked":false,"id":239791,"user_name":"ONENESS2019","can_delete":false,"product_type":"c1","uid":1501620,"ip_address":"","ucode":"F8CCF2118B29D7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/UyjYSHTkMsqodhBJlbzL01Y3tRklSQzleSRbWvwZcYdTdGiczJEJT8dbTfrmcTFicEhMIEaSaeN4zCjNP1WUG2fg/132","comment_is_top":false,"comment_ctime":1596642413,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596642413","product_id":100017301,"comment_content":"当m为100时，为一亿个数据建立索引，B+树的高度为4，而不是3。文章有误，请修正。","like_count":0},{"had_liked":false,"id":233523,"user_name":"Geek_ac7784","can_delete":false,"product_type":"c1","uid":1981613,"ip_address":"","ucode":"62F0E5E6D6F4BA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/8Dj4ugujXwY24G8pcpgDFGiciarXetG3ItQ4M9mSQMLyRdRRXEXXJVfib48mGUQAu87QcvImwyJIVJlEFeEguV44w/132","comment_is_top":false,"comment_ctime":1594347093,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594347093","product_id":100017301,"comment_content":"问几个问题：<br>1. 索引节点和叶子节点是不同的数据结构。索引节点都是指向索引节点，那最后一层索引是如何指向叶子节点的？<br>2. 叶子节点也是放在硬盘种的把？<br><br>思考题：1. 双向链表好，jerry银银说的对，考虑到查询并排序问题<br>2. 散列表和链表串起来用，理论上可以，但是细节上，还需要处理大区间问题:查询(6, 50)，可能真实的数据只有30，31.计算6的哈希可能根本不存在需要一次向后6，7，8，9，。。一直到30才能命中。<br>","like_count":0},{"had_liked":false,"id":228211,"user_name":"厉害了我的国","can_delete":false,"product_type":"c1","uid":1052191,"ip_address":"","ucode":"CD0A54A1B998AA","user_header":"https://static001.geekbang.org/account/avatar/00/10/0e/1f/d0472177.jpg","comment_is_top":false,"comment_ctime":1592614696,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592614696","product_id":100017301,"comment_content":"哈希表和红黑树都不适合做索引，理解！但是跳表为什么不合适，或者说跳表怎么改进才合适？麻烦老师解答一下","like_count":0},{"had_liked":false,"id":227825,"user_name":"Geek","can_delete":false,"product_type":"c1","uid":1881153,"ip_address":"","ucode":"740790D3686F8E","user_header":"https://static001.geekbang.org/account/avatar/00/1c/b4/41/82ac102c.jpg","comment_is_top":false,"comment_ctime":1592489327,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1592489327","product_id":100017301,"comment_content":"老师不考虑内存占用的话为什么不使用跳表作为索引数据结构呢","like_count":0,"discussions":[{"author":{"id":1244845,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fe/ad/7fa85a7d.jpg","nickname":"放飞心情","note":"","ucode":"75A2192D91D86C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390161,"discussion_content":"个人猜测，老师说的跳表出来太晚了 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629694160,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":226308,"user_name":"worthto","can_delete":false,"product_type":"c1","uid":1387712,"ip_address":"","ucode":"41D7ABBBD2E7FF","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/N6yjnrLnMW4XVSkBr3f0N3F962l35b5j0kib9VSlAqqbf6iaoCPicL1WnJ9KjgT4egQ7A2G0Zx3OayaK4yuoZrUVA/132","comment_is_top":false,"comment_ctime":1592032207,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592032207","product_id":100017301,"comment_content":"多叉树有点类似于数据的分桶，递归分桶，然后把各个桶按照一定的逻辑链接起来方便后续的数据查找。","like_count":0},{"had_liked":false,"id":224482,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1591415777,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591415777","product_id":100017301,"comment_content":"思考题：<br>1. 叶子节点的链表是双向链表，双向链表即可以支持向前搜索，也可以支持向后搜索，如果查找的范围是小于某个数时，在找到对应的叶子结点后，再通过双向链表向前搜索来找出所有满足条件的节点。<br>2. 如果把散列表中的结点按照存贮值的大小顺序用双向链表串起来，可以支持按区间查找，在哈希表中先定位区间的起点，然后在双向链表中依次向前遍历，直到找到区间的终点，遍历经过的所有节点即为区间范围内的所有节点。","like_count":0},{"had_liked":false,"id":224142,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1591284390,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1591284390","product_id":100017301,"comment_content":"递增数据生成b+树和随机数据生成b+树的性能一样吗","like_count":0,"discussions":[{"author":{"id":1244845,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fe/ad/7fa85a7d.jpg","nickname":"放飞心情","note":"","ucode":"75A2192D91D86C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390160,"discussion_content":"时间复杂度一样，根据节点比较。如果仅仅是完全连续递增可以直接使用数组，或者类似数组的持久化方案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629694124,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217114,"user_name":"Matzoh","can_delete":false,"product_type":"c1","uid":1367546,"ip_address":"","ucode":"E92D6035230CDE","user_header":"https://static001.geekbang.org/account/avatar/00/14/dd/fa/6108000a.jpg","comment_is_top":false,"comment_ctime":1589421951,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1589421951","product_id":100017301,"comment_content":"如果只有bin log，那么会存在事务提交后，binlog还没来得及写入就崩溃的情况；<br>如果有redo log，因为更新的数据是先写到redo log，再后续由redo log更新到磁盘，所以不存在redo log来不及写入；<br>如果redo log prepare时崩溃，则bin log没有数据，我们可以正常回滚；<br>如果redo log prepare并且bin log写入成功后崩溃，我们则认定为数据有效。<br><br>老师，我这样理解对吗？","like_count":0,"discussions":[{"author":{"id":1244845,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fe/ad/7fa85a7d.jpg","nickname":"放飞心情","note":"","ucode":"75A2192D91D86C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390159,"discussion_content":"小哥，来错片场了。上面你的写的那个关于mysql事务提交的说法我在极客mysql 45讲里面看到过，是这么个意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629694047,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215329,"user_name":"社会你强哥","can_delete":false,"product_type":"c1","uid":1243570,"ip_address":"","ucode":"325B9005588D9B","user_header":"https://static001.geekbang.org/account/avatar/00/12/f9/b2/2ed800b4.jpg","comment_is_top":false,"comment_ctime":1588954211,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588954211","product_id":100017301,"comment_content":"1.  如何在B+树中插入和删除数据不太懂，希望说得详细一些，或者有代码。<br>2. 每次更新了索引，也要储存到硬盘中去么？","like_count":0},{"had_liked":false,"id":212770,"user_name":"黄宸","can_delete":false,"product_type":"c1","uid":1799585,"ip_address":"","ucode":"C346F5604B8724","user_header":"","comment_is_top":false,"comment_ctime":1588208887,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588208887","product_id":100017301,"comment_content":"看了索引的数据结构突然想到叶子节点用链表存储，不会存在对CPU缓存不友好吗？可以讲解下吗？","like_count":0},{"had_liked":false,"id":212394,"user_name":"Hesher","can_delete":false,"product_type":"c1","uid":1026832,"ip_address":"","ucode":"99AB8B1704CB7E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ab/10/b812ff3e.jpg","comment_is_top":false,"comment_ctime":1588116455,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588116455","product_id":100017301,"comment_content":"第一题，双向链表，升序和降序都可以实现。<br>第二题，可以实现，但每次插入更新删除需要遍历链表以维护顺序，时间复杂度O（n），实际上没有了散列表的优势。","like_count":0},{"had_liked":false,"id":212088,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1588059401,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588059401","product_id":100017301,"comment_content":"1. 双向链表 因为它还是有可能往前遍历的 比如 9 10 11通过索引最后落到了11结点上 但是我们其实结点是10<br>2. 我觉得可以的 把数据按一定的大小(比如100)进行区分 比如索引1 后面的链表就串联的是1~100之间的数据 依次类推 最后就可以通过hash算法求出起始结点所在区间 然后找起走就行了","like_count":0},{"had_liked":false,"id":210830,"user_name":"爬行的蜗牛","can_delete":false,"product_type":"c1","uid":1033956,"ip_address":"","ucode":"6623B62DE63CE9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/QD6bf8hkS5dHrabdW7M7Oo9An1Oo3QSxqoySJMDh7GTraxFRX77VZ2HZ13x3R4EVYddIGXicRRDAc7V9z5cLDlA/132","comment_is_top":false,"comment_ctime":1587830800,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1587830800","product_id":100017301,"comment_content":"王争老师：<br>文中有以下描述：<br>“B+树中的结点不存储数据，只是索引， 而B 树中的结点存储数据 ”<br>我看到其他专栏里表述的是：<br>“B+ 树中 非叶子结点仅仅保存索引， 不保存数据， 所有的数据存储在叶子节点；<br>B树中非叶子和叶子结点既保存索引又保存数据。”<br>请问是那种描述更准确些呢","like_count":0,"discussions":[{"author":{"id":1442605,"avatar":"https://static001.geekbang.org/account/avatar/00/16/03/2d/404627dc.jpg","nickname":"Anryg Zhun","note":"","ucode":"76DF8560BA9D14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":270706,"discussion_content":"这两个观点是一个意思啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590040592,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1336475,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","nickname":"J.Smile","note":"","ucode":"C4D98DFDBF7584","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":255657,"discussion_content":"是的，刚才《Mysql实战45讲》提到，“InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的“，又提到“主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引”。---我觉都应该是理解的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588420274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207608,"user_name":"prader26","can_delete":false,"product_type":"c1","uid":1433707,"ip_address":"","ucode":"5EFFFC374ADECE","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/6b/f61d7466.jpg","comment_is_top":false,"comment_ctime":1587117582,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587117582","product_id":100017301,"comment_content":"数据库中的b+树索引结构，和跳表类似。因为索引量比较大，所以索引一般放在硬盘上。<br>因为，为了b+树的树形结构，所以数据添加和删除会会对硬盘进行io操作，所以索引会降低数据的添加和删除速度。","like_count":0},{"had_liked":false,"id":203249,"user_name":"Joker","can_delete":false,"product_type":"c1","uid":1156592,"ip_address":"","ucode":"126AF848001A1E","user_header":"https://static001.geekbang.org/account/avatar/00/11/a5/f0/8648c464.jpg","comment_is_top":false,"comment_ctime":1586160711,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586160711","product_id":100017301,"comment_content":"感觉这m叉的平衡规则就是从2-3 树的演变规则来的。","like_count":0},{"had_liked":false,"id":203221,"user_name":"Joker","can_delete":false,"product_type":"c1","uid":1156592,"ip_address":"","ucode":"126AF848001A1E","user_header":"https://static001.geekbang.org/account/avatar/00/11/a5/f0/8648c464.jpg","comment_is_top":false,"comment_ctime":1586157734,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586157734","product_id":100017301,"comment_content":"1 是否使用单、双向链表，我觉得是需求决定的，如果说有倒序的功能的话，双向链表是更加合适的，但是如果没有功能需求的话，用单向链表是节省空间的。<br>2 不支持，如果是平衡的查找树的话，倒是可以试一试，因为本身树就有有序性这个性质，所以用链表连接起来是可以满足区间查找的。但是散列表没有这个性质，因为散列函数的一个非常重要的设计思想就是尽量让每次数据都是『平均+随机』分布在数组的不同的位置上","like_count":0},{"had_liked":false,"id":195988,"user_name":"墟","can_delete":false,"product_type":"c1","uid":1519087,"ip_address":"","ucode":"5E33E9FE51CE88","user_header":"https://static001.geekbang.org/account/avatar/00/17/2d/ef/2f18b76f.jpg","comment_is_top":false,"comment_ctime":1585227949,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585227949","product_id":100017301,"comment_content":"真的，我是通过本专栏第一次看懂b+ tree","like_count":0},{"had_liked":false,"id":192756,"user_name":"Evan","can_delete":false,"product_type":"c1","uid":1344281,"ip_address":"","ucode":"B877ABD0CF4661","user_header":"https://static001.geekbang.org/account/avatar/00/14/83/19/0a3fe8c1.jpg","comment_is_top":false,"comment_ctime":1584871515,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1584871515","product_id":100017301,"comment_content":"B+ 树  使用肯定双向链表，主要为上下关联查找数据，用于后期排序等<br>散列表 + 链表串 ，能实现区间查询。<br><br>B+树和B-树的区别：叶子节点没有双向链表关系， B-树的叶子节点有数据，B+树的叶子节点是没有数据","like_count":0},{"had_liked":false,"id":187856,"user_name":"姜川","can_delete":false,"product_type":"c1","uid":1684311,"ip_address":"","ucode":"0F8A349623EAB5","user_header":"https://static001.geekbang.org/account/avatar/00/19/b3/57/2d92cf9a.jpg","comment_is_top":false,"comment_ctime":1584260593,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584260593","product_id":100017301,"comment_content":"这个具体多少个节点是不是还是受限制于4K的大小","like_count":0},{"had_liked":false,"id":186538,"user_name":"Bryan","can_delete":false,"product_type":"c1","uid":1037208,"ip_address":"","ucode":"BA9D6A278609F3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d3/98/60d13550.jpg","comment_is_top":false,"comment_ctime":1583860451,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1583860451","product_id":100017301,"comment_content":"老师我想问一下，如果非叶子节点的数据大小是计算好的 PAGE_SIZE，那么到了取出叶子节点的一步，因为相比于非叶子结点多了数据，所以是不是取出的数据大小要远远大于一个 PAGE_SIZE 呢","like_count":0},{"had_liked":false,"id":177361,"user_name":"晚风·和煦","can_delete":false,"product_type":"c1","uid":1236047,"ip_address":"","ucode":"0B1DB8F437A4B2","user_header":"","comment_is_top":false,"comment_ctime":1581357795,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1581357795","product_id":100017301,"comment_content":"如何提高查询速度？<br>加索引<br>加了索引就快了？<br>面试中第二个问题该怎么回答好呢😂<br><br>","like_count":0,"discussions":[{"author":{"id":1325514,"avatar":"https://static001.geekbang.org/account/avatar/00/14/39/ca/4a07bfd8.jpg","nickname":"Jahng","note":"","ucode":"5D5789EAAC4739","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338202,"discussion_content":"和书的索引一样道理。如果要查找标题包含“数据结构”关键词的文章，没有索引的话，整本书每一篇文章都要翻，如果有了索引，只看索引就能定位到对应文章","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609212395,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176370,"user_name":"一路向北","can_delete":false,"product_type":"c1","uid":1050287,"ip_address":"","ucode":"19322F21C0235B","user_header":"https://static001.geekbang.org/account/avatar/00/10/06/af/f7e562fb.jpg","comment_is_top":false,"comment_ctime":1581044967,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1581044967","product_id":100017301,"comment_content":"老师讲课，平时贴的代码有 github 可以学习吗，老师你的github  地址多少啊","like_count":0,"discussions":[{"author":{"id":1139455,"avatar":"https://static001.geekbang.org/account/avatar/00/11/62/ff/f71034e9.jpg","nickname":"悟空WuKong","note":"","ucode":"49AFD2B048C1BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213764,"discussion_content":"https://github.com/wangzheng0822/algo ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585119544,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168855,"user_name":"梦想的优惠券","can_delete":false,"product_type":"c1","uid":1257418,"ip_address":"","ucode":"D3B44F6C618CA7","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/ca/cbce6e94.jpg","comment_is_top":false,"comment_ctime":1578200668,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1578200668","product_id":100017301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":153715,"user_name":"茶没喝完","can_delete":false,"product_type":"c1","uid":1644104,"ip_address":"","ucode":"D72D88C42A1258","user_header":"https://static001.geekbang.org/account/avatar/00/19/16/48/09493874.jpg","comment_is_top":false,"comment_ctime":1574298977,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574298977","product_id":100017301,"comment_content":"感谢老师！","like_count":0},{"had_liked":false,"id":148200,"user_name":"阿信","can_delete":false,"product_type":"c1","uid":1389604,"ip_address":"","ucode":"50616ED68A5B40","user_header":"https://static001.geekbang.org/account/avatar/00/15/34/24/34ca1d23.jpg","comment_is_top":false,"comment_ctime":1572957757,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572957757","product_id":100017301,"comment_content":"可以范围查找，维护链表有序，散列表存储数据地址就行","like_count":0},{"had_liked":false,"id":146867,"user_name":"aof","can_delete":false,"product_type":"c1","uid":1062864,"ip_address":"","ucode":"5815D63C4926BC","user_header":"https://static001.geekbang.org/account/avatar/00/10/37/d0/26975fba.jpg","comment_is_top":false,"comment_ctime":1572681554,"is_pvip":false,"replies":[{"id":"56798","content":"你可以看下极客时间多mysql专栏","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1572823679,"ip_address":"","comment_id":146867,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1572681554","product_id":100017301,"comment_content":"对于这样的查询语句&quot;select * from table where user_id &lt; 1000&quot;, 是如何在叶子节点上进行遍历的？是找到1000之后往前遍历，还是从开始遍历到1000？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473038,"discussion_content":"你可以看下极客时间多mysql专栏","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572823679,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1307110,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKq0aBhhSXg7qiaWQH81zmjAYPXwoiaJEoMOxwXZF7d2iazMyQCeYpT7DJmxy2Iny7qq3RRr0UjOnO5A/132","nickname":"xiaoma2008","note":"","ucode":"EA59E52B15F5C0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220007,"discussion_content":"假设user_id是主键，下面是执行步骤：\n1. 从root节点开始往下搜索，找到对应的页\n2. 因为页节点之间通过双向链表进行连接，所以可以很容易的知道之前的节点\n3. 依次遍历所有的页直到第一个页就结束\n\n令：\n实际上，数据库里的b+tree中的leaf node中的key，保存的都是磁盘页的id(pageId)，根据pageId，可以计算到物理磁盘的offset+limit，然后把该页加载到buffer pool(就是1个cache)中，每个页一般按顺序有N个槽位(slot)，查找最大的user_id的时候，使用二分查找。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585830932,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144395,"user_name":"shinee_x_X","can_delete":false,"product_type":"c1","uid":1605962,"ip_address":"","ucode":"98529C77B052AC","user_header":"https://static001.geekbang.org/account/avatar/00/18/81/4a/dcc563fb.jpg","comment_is_top":false,"comment_ctime":1571910694,"is_pvip":false,"replies":[{"id":"56464","content":"孩子结点的地址会存储在结点中的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1572487688,"ip_address":"","comment_id":144395,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571910694","product_id":100017301,"comment_content":"很想问问老师mysql的索引和数据是怎么存储的，因为是一页页拿数据的，一页就是一个节点，那只拿一页数据的话，一个节点的孩子节点地址是怎么得到的","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471918,"discussion_content":"孩子结点的地址会存储在结点中的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572487688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141744,"user_name":"lmdcx","can_delete":false,"product_type":"c1","uid":1334409,"ip_address":"","ucode":"F2CDD0091ADFD7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIjRETqRjvLESLDZkNTjIiaSibtNYBaS1o8WMUicOFn3ycF3Mgh6LRJibqSBjVBjiaO2ibW0gHkafATb21A/132","comment_is_top":false,"comment_ctime":1571217169,"is_pvip":false,"replies":[{"id":"54886","content":"😁","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1571359160,"ip_address":"","comment_id":141744,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571217169","product_id":100017301,"comment_content":"&quot;理论上讲,对跳表稍加改造,也可以替代 B 树,作为数据库的索引实现的&quot;<br>隔壁的林晓斌说了：数据库技术发展到今天，跳表、LSM 树等数据结构也被用于引擎设计中","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470869,"discussion_content":"😁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571359160,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140818,"user_name":"老衲爱清扬","can_delete":false,"product_type":"c1","uid":1468308,"ip_address":"","ucode":"B920F55BD00E3B","user_header":"https://static001.geekbang.org/account/avatar/00/16/67/94/1c72edcd.jpg","comment_is_top":false,"comment_ctime":1571052990,"is_pvip":false,"replies":[{"id":"54518","content":"16kb从何而来呢？","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1571093845,"ip_address":"","comment_id":140818,"utype":1}],"discussion_count":5,"race_medal":0,"score":"1571052990","product_id":100017301,"comment_content":"王老师，请问B+树每个节点的大小是16KB，不是4KB的吧","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470574,"discussion_content":"16kb从何而来呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571093845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1802917,"avatar":"","nickname":"Geek_8d985d","note":"","ucode":"FBD32B64E1883B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220660,"discussion_content":"是因为操作系统的内存页大小是16kb吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585913316,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1269166,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5d/ae/95855c5a.jpg","nickname":"HI.元先森","note":"","ucode":"64CAAEF1699003","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212085,"discussion_content":"1.解答16kb的大小：mysql中使用的是B+树作为索引，另外mysql中的page大小默认是16k，索引page的大小也是一样。\n2.问题：innodb page的大小16k和操作系统的page4k不一样，那么这时是一次io读写，是按照哪个来计算？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584932497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1307110,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKq0aBhhSXg7qiaWQH81zmjAYPXwoiaJEoMOxwXZF7d2iazMyQCeYpT7DJmxy2Iny7qq3RRr0UjOnO5A/132","nickname":"xiaoma2008","note":"","ucode":"EA59E52B15F5C0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1269166,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5d/ae/95855c5a.jpg","nickname":"HI.元先森","note":"","ucode":"64CAAEF1699003","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220014,"discussion_content":"肯定按照你设置的page大小，调用一次文件系统呀，类似这样：\nbyte[] load(int pageId, int pageSize) {\n    file.seek(pageId);\n    byte[] data = new byte[pageSize];\n    file.read(data);\n    return data;\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585831140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":212085,"ip_address":""},"score":220014,"extra":""}]},{"author":{"id":1357623,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJmBKrLvqOIXDDbj3ocEIJzqsQx2e5VLDBSX6LmofYtprWwKaVAmHUqU2z3mjREHX8n9eLLiavlPg/132","nickname":"wg1993","note":"","ucode":"D5112FEFDB1DF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":39215,"discussion_content":"文件系统最小存储单元&#34;块&#34;4K，InnoDB引擎最小存储单元&#34;页&#34;16K","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571906266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135375,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1569141162,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569141162","product_id":100017301,"comment_content":"1 双向链表，方便降序排列<br>2 可以","like_count":0},{"had_liked":false,"id":130633,"user_name":"zqing","can_delete":false,"product_type":"c1","uid":1106603,"ip_address":"","ucode":"2EF31AE75DA0A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/e2/ab/430c24df.jpg","comment_is_top":false,"comment_ctime":1567497879,"is_pvip":false,"replies":[{"id":"49799","content":"我写的挺清楚的啊  你再仔细读一遍啊","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1567724223,"ip_address":"","comment_id":130633,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1567497879","product_id":100017301,"comment_content":"不管是内存中的数据，还是磁盘中的数据，操作系统都是按页（一页大小通常是 4KB，这个值可以通过 getconfig PAGE_SIZE 命令查看）来读取的，一次会读一页的数据。如果要读取的数据量超过一页的大小，就会触发多次 IO 操作。所以，我们在选择 m 大小的时候，要尽量让每个节点的大小等于一个页的大小。读取一个节点，只需要一次磁盘 IO 操作。——-一个节点超过一个pagesize 为啥会触发多次IO操作？这个是不是写的有问题？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466041,"discussion_content":"我写的挺清楚的啊  你再仔细读一遍啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567724223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1106603,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e2/ab/430c24df.jpg","nickname":"zqing","note":"","ucode":"2EF31AE75DA0A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8116,"discussion_content":"操作系统不会每次只下发一个pagesize 的io ！老师可以用blktrace和iosnoop跟踪下，绝对不是这样的！选择一个pagesize 大小作为m大小，应该是这样构建出的b+tree能够满足大数据量的性能要求吧？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567783531,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124264,"user_name":"兰鑫","can_delete":false,"product_type":"c1","uid":1138640,"ip_address":"","ucode":"31F9E9D9DC0341","user_header":"https://static001.geekbang.org/account/avatar/00/11/5f/d0/616045b5.jpg","comment_is_top":false,"comment_ctime":1565847578,"is_pvip":false,"replies":[{"id":"45681","content":"改造后跟改造前的例子没关系的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1565907211,"ip_address":"","comment_id":124264,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565847578","product_id":100017301,"comment_content":"二叉查找树改造成支持区间查找的过程，即叶子节点通过链表链接，这样就支持区间查找了。关于这个点，我很好奇文章中的示例，改造之后根节点是27，这个27是怎么选出来的呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463089,"discussion_content":"改造后跟改造前的例子没关系的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565907211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121156,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1565067537,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565067537","product_id":100017301,"comment_content":"思考题2<br>理论上讲散列表+有序链表也可以维护一个快速查询单个数值和区间的数据结构，但是插入会非常慢，无法像查找树那样快速定位到插入的位置。","like_count":0},{"had_liked":false,"id":121154,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1565067312,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565067312","product_id":100017301,"comment_content":"思考题1<br>B+树的数据节点需要双向链表，这样删除，插入一个节点的时候，才能高效更新。","like_count":0},{"had_liked":false,"id":118465,"user_name":"乘坐Tornado的线程魔法师","can_delete":false,"product_type":"c1","uid":1132661,"ip_address":"","ucode":"C4C9915866E769","user_header":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","comment_is_top":false,"comment_ctime":1564370313,"is_pvip":false,"replies":[{"id":"43665","content":"是通用公式。那行公式前面有解释，4个结点会分成5个区。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1564529899,"ip_address":"","comment_id":118465,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1564370313","product_id":100017301,"comment_content":"关于非叶子节点和叶子节点的公式。老师可否再给予下指点。感谢！<br>PAGE_SIZE = (m-1)*4[keywords 大小]+m*8[children 大小]<br>为什么 第一个系数是m-1而不是m? 这个公式是某个特定例子的公式还是通用公式？<br><br>PAGE_SIZE = k*4[keywords 大小]+k*8[dataAddresses 大小]+8[prev 大小]+8[next 大小]<br>prev大小是值得，链表中前一个节点的数据占用空间大小嘛？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460419,"discussion_content":"是通用公式。那行公式前面有解释，4个结点会分成5个区。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564529899,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1232601,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ce/d9/e6c2e0d1.jpg","nickname":"零启拾落","note":"","ucode":"58EA1063A9F383","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291616,"discussion_content":"这个[]是用来解释的意思吗？还是表示数组？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594888364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1132661,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","nickname":"乘坐Tornado的线程魔法师","note":"","ucode":"C4C9915866E769","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1232601,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ce/d9/e6c2e0d1.jpg","nickname":"零启拾落","note":"","ucode":"58EA1063A9F383","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":313091,"discussion_content":"中括号里面的内容是用来解释的意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602936130,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":291616,"ip_address":""},"score":313091,"extra":""}]},{"author":{"id":1543162,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8b/fa/103e6900.jpg","nickname":"山鬼谣","note":"","ucode":"E25F498B85A01B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290166,"discussion_content":"对这个公式我也有疑问，公式里面的8是哪来的？4我理解为int为4个字节，8我就理解不了了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594364858,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118462,"user_name":"乘坐Tornado的线程魔法师","can_delete":false,"product_type":"c1","uid":1132661,"ip_address":"","ucode":"C4C9915866E769","user_header":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","comment_is_top":false,"comment_ctime":1564369389,"is_pvip":false,"replies":[{"id":"43666","content":"为啥呢？没看懂你为啥说是小于2呀","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1564529936,"ip_address":"","comment_id":118462,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1564369389","product_id":100017301,"comment_content":"最后一张图中，&quot;非叶子节点中，子节点小于3个就合并”。根据B+树的特点，每个节点中子节点的个数不能小于m &#47; 2 (5 &#47; 2 = 2)。那么这句话是否应该改成“非叶子节点中，子节点小于2个就合并”？请老师指正","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460418,"discussion_content":"为啥呢？没看懂你为啥说是小于2呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564529936,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108044,"user_name":"JasonZ","can_delete":false,"product_type":"c1","uid":1104818,"ip_address":"","ucode":"992193AE44C39C","user_header":"https://static001.geekbang.org/account/avatar/00/10/db/b2/29b4f22b.jpg","comment_is_top":false,"comment_ctime":1561652341,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561652341","product_id":100017301,"comment_content":"b+树的插入和删除的时间复杂度是多少？","like_count":0},{"had_liked":false,"id":107322,"user_name":"康斯坦丁","can_delete":false,"product_type":"c1","uid":1368096,"ip_address":"","ucode":"C130E800E8D5C9","user_header":"https://static001.geekbang.org/account/avatar/00/14/e0/20/003190c1.jpg","comment_is_top":false,"comment_ctime":1561514473,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561514473","product_id":100017301,"comment_content":"1 双向链表， 因为需要至少正向排序和逆向排序。<br>2 不行，因为散列表时无序的<br><br>更正一下第2题: LinkedHashMap 是有序的.","like_count":0},{"had_liked":false,"id":99668,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1559275526,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559275526","product_id":100017301,"comment_content":"@城 的回答感觉更靠谱些~~。另，之前讲跳表那一节，讲到索引的动态更新，个人感觉跳表索引的更新和B+树的节点分裂、节点合并的道理是一样的","like_count":0},{"had_liked":false,"id":97103,"user_name":"Scorpio","can_delete":false,"product_type":"c1","uid":1310855,"ip_address":"","ucode":"CB8672DA73FA88","user_header":"https://static001.geekbang.org/account/avatar/00/14/00/87/bcd6fb00.jpg","comment_is_top":false,"comment_ctime":1558589735,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558589735","product_id":100017301,"comment_content":"嘻嘻,自己也动手用java实现了一棵b+树","like_count":0},{"had_liked":false,"id":89235,"user_name":"你好呀","can_delete":false,"product_type":"c1","uid":1049361,"ip_address":"","ucode":"2E97656410BACA","user_header":"https://static001.geekbang.org/account/avatar/00/10/03/11/f58c6278.jpg","comment_is_top":false,"comment_ctime":1556113400,"is_pvip":false,"replies":[{"id":"31987","content":"问题有点笼统 有点大了","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1556149334,"ip_address":"","comment_id":89235,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556113400","product_id":100017301,"comment_content":"oracle的btree索引有时候不去位图索引  是btree需要的io次数比位图多吗？  位图又是如何优化的？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448065,"discussion_content":"问题有点笼统 有点大了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1556149334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":87528,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1555633018,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555633018","product_id":100017301,"comment_content":"1.select * from student where  height&lt;180<br>也就是小于的情况，这时候只能反向遍历链表<br>2.不可以。hash函数过的值可能随机的，与原来的要查的值不等同","like_count":0},{"had_liked":false,"id":82236,"user_name":"涛涛","can_delete":false,"product_type":"c1","uid":1180810,"ip_address":"","ucode":"747C4B1F20A2D3","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/8a/ff94bd60.jpg","comment_is_top":false,"comment_ctime":1554167386,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554167386","product_id":100017301,"comment_content":"节点分裂那个地方 节点10怎么还重复了？","like_count":0},{"had_liked":false,"id":73493,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1551917645,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551917645","product_id":100017301,"comment_content":"理解了，厉害👍","like_count":0},{"had_liked":false,"id":73154,"user_name":"黑白尤文","can_delete":false,"product_type":"c1","uid":1152644,"ip_address":"","ucode":"95B9F73AA0F20D","user_header":"https://static001.geekbang.org/account/avatar/00/11/96/84/d4ba322f.jpg","comment_is_top":false,"comment_ctime":1551832809,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551832809","product_id":100017301,"comment_content":"平衡二叉树另一个不适合的原因是层级太高，用磁盘存储是这尤其是个问题","like_count":0},{"had_liked":false,"id":72595,"user_name":"Kermit Sun","can_delete":false,"product_type":"c1","uid":1245430,"ip_address":"","ucode":"9B0560FB228629","user_header":"https://static001.geekbang.org/account/avatar/00/13/00/f6/f6cf138c.jpg","comment_is_top":false,"comment_ctime":1551674943,"is_pvip":false,"replies":[{"id":"26802","content":"模糊查找可能就不大适合了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551925242,"ip_address":"","comment_id":72595,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551674943","product_id":100017301,"comment_content":"问一个问题，具体节点的key是如何计算出来的呢？如果like模糊查询字段a，左边精确，右边模糊，是否能够使用btree？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441647,"discussion_content":"模糊查找可能就不大适合了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551925242,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":69128,"user_name":".&#47;+-@YOU","can_delete":false,"product_type":"c1","uid":1248827,"ip_address":"","ucode":"14CCC17DDFFDB6","user_header":"https://static001.geekbang.org/account/avatar/00/13/0e/3b/42288ae6.jpg","comment_is_top":false,"comment_ctime":1550666457,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550666457","product_id":100017301,"comment_content":"第一题最好是用双链表，当然单链表也可以。只是麻烦点，因为有序，所以单链表+栈，也可以实现倒序","like_count":0},{"had_liked":false,"id":63710,"user_name":"睡痴儿😑","can_delete":false,"product_type":"c1","uid":1187204,"ip_address":"","ucode":"750EF858EF2042","user_header":"https://static001.geekbang.org/account/avatar/00/12/1d/84/d0ec0064.jpg","comment_is_top":false,"comment_ctime":1548471897,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548471897","product_id":100017301,"comment_content":"双向链表，这样方便查询。<br>也可以","like_count":0},{"had_liked":false,"id":62992,"user_name":"呆梨","can_delete":false,"product_type":"c1","uid":1069474,"ip_address":"","ucode":"7D4B961DE1EE8B","user_header":"https://static001.geekbang.org/account/avatar/00/10/51/a2/4fc7df75.jpg","comment_is_top":false,"comment_ctime":1548222827,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548222827","product_id":100017301,"comment_content":"打卡，老师从二叉查找树讲到了b树的由来，感觉以后再也不会忘记b树了，讲的很好","like_count":0},{"had_liked":false,"id":62610,"user_name":"伟忠","can_delete":false,"product_type":"c1","uid":1112089,"ip_address":"","ucode":"FE77CF20ED6065","user_header":"https://static001.geekbang.org/account/avatar/00/10/f8/19/05a2695f.jpg","comment_is_top":false,"comment_ctime":1548119923,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548119923","product_id":100017301,"comment_content":"1，双向链表，需要支持大于，小于各种区间查询模式<br>2，可以，但维护索引，删除数据时间复杂度变高了，哈希只能精确定位，不支持区间查找。","like_count":0},{"had_liked":false,"id":62312,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1548030895,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1548030895","product_id":100017301,"comment_content":"思考题1:双向链表，为了支持增序和降序<br>思考题2:可以支持范围查询，但需要保证跳表的数据有序<br><br>mysql数据库的索引一直是重点，这篇文章值得多读","like_count":0},{"had_liked":false,"id":61997,"user_name":"zixuan","can_delete":false,"product_type":"c1","uid":1131300,"ip_address":"","ucode":"C72920DD05B074","user_header":"https://static001.geekbang.org/account/avatar/00/11/43/24/3f9f7c70.jpg","comment_is_top":false,"comment_ctime":1547875781,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547875781","product_id":100017301,"comment_content":"可以思考下B+树为什么不用考虑平衡的问题","like_count":0},{"had_liked":false,"id":61718,"user_name":"zixuan","can_delete":false,"product_type":"c1","uid":1131300,"ip_address":"","ucode":"C72920DD05B074","user_header":"https://static001.geekbang.org/account/avatar/00/11/43/24/3f9f7c70.jpg","comment_is_top":false,"comment_ctime":1547781521,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547781521","product_id":100017301,"comment_content":"散列表上将所有key串起来做范围查询理论上也是可以的，但链表需要维护有序，远不如B+高效，例如考虑插入新数据的场景.","like_count":0},{"had_liked":false,"id":61631,"user_name":"赵永赫","can_delete":false,"product_type":"c1","uid":1351110,"ip_address":"","ucode":"00BA85DC072A5D","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/c6/3cf5b67d.jpg","comment_is_top":false,"comment_ctime":1547738926,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547738926","product_id":100017301,"comment_content":"我就是想知道总结帝姜威咋这么久都没出现了。。。","like_count":0},{"had_liked":false,"id":61563,"user_name":"纯洁的憎恶","can_delete":false,"product_type":"c1","uid":1130512,"ip_address":"","ucode":"5E9757DE6F45DF","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/10/b6bf3c3c.jpg","comment_is_top":false,"comment_ctime":1547723875,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1547723875","product_id":100017301,"comment_content":"平衡二叉树改造成B+树，首先要扩充叶节点，因为所有数据必须都在叶节点出现，然后把叶节点包含所有数据且按顺序链接起来。如此，B+树与跳表几乎一样，除了索引节点的连接次序与结构存在差异，但都以O（logn）的时间复杂度找到某个元素（叶节点），所以从功能逻辑上来看是完全一样的。<br><br>但工程上需要考虑更多。用二叉查找树存储索引，放在内存里空间不足，放在磁盘里访问速度大打折扣。如果采用磁盘存储的策略，就要思考如何减少磁盘访问频次，以提高效率。每次查询操作访问节点个数为二叉查找树的高度，所以降低树的高度可以明显减少磁盘访问频次。于是可以改用多叉树代替二叉树。<br>更进一步，在操作系统执行磁盘访问操作时，是以页为单位的。因此m叉树索引的m一方面要足够大，以降低索引树的高度，另一方面不能超过一页的数据存储量，否则还是会增加访问磁盘的频次。但为了防止B+树的子节点数量普遍减少，造成性能退化，需要给子节点数量设置下限，如m&#47;2。<br><br>1.链表是双向链表，用以支持前后遍历<br>2.虽然散列表的元素不像B+的叶节点天然有序。因为后者得益于查找树结构，叶节点“从左到右”自然有序，散列表并无这种天然属性。但是树形结构及其有序性是人为动态维护的，我们也可以刻意将散列表中的元素有序连接起来，并动态维持。为了提高查找、插入、删除的效率，可以使用平衡二叉树、跳表、红黑树来代替链表（我记得散列表那节课讲过）。所以把散列表元素有序链接起来是可以支持区间查找的。这样做虽然可能比B+树获得更快的单个元素查询速度（O（1）），但是融合了两种复杂数据结构（散列表+跳表或树）维护成本估计要更高。","like_count":0},{"had_liked":false,"id":61542,"user_name":"谭小谭","can_delete":false,"product_type":"c1","uid":1298631,"ip_address":"","ucode":"C7928BEDFF4EDC","user_header":"https://static001.geekbang.org/account/avatar/00/13/d0/c7/62de0458.jpg","comment_is_top":false,"comment_ctime":1547719236,"is_pvip":false,"replies":[{"id":"23158","content":"数据是存储在叶子节点指向的磁盘地址的。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1549179904,"ip_address":"","comment_id":61542,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1547719236","product_id":100017301,"comment_content":"老师，你说的 B+ 树的节点只存储索引，而 mysql 的 InnoDB中的索引又是采用 B+ 树来实现的，这里该怎么理解节点只存储索引呢，感觉要绕进去了啊。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436906,"discussion_content":"数据是存储在叶子节点指向的磁盘地址的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549179904,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":61527,"user_name":"Yakmoz","can_delete":false,"product_type":"c1","uid":1257502,"ip_address":"","ucode":"1FA18A711457A0","user_header":"https://static001.geekbang.org/account/avatar/00/13/30/1e/0b05530d.jpg","comment_is_top":false,"comment_ctime":1547714171,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547714171","product_id":100017301,"comment_content":"线段树也可以用于范围查找，etcd3中的watch就是用的这种数据结构","like_count":0},{"had_liked":false,"id":61525,"user_name":"风光","can_delete":false,"product_type":"c1","uid":1139441,"ip_address":"","ucode":"59B417675A2AEF","user_header":"https://static001.geekbang.org/account/avatar/00/11/62/f1/05fe8d01.jpg","comment_is_top":false,"comment_ctime":1547714040,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1547714040","product_id":100017301,"comment_content":"有点地方一直没明白，还希望作者或者各位解惑，B+树节点的内部结构是什么样子的，是key-value吗，文章上的图中的一些数字是否就是代表一个键值对","like_count":0},{"had_liked":false,"id":61474,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1547705333,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547705333","product_id":100017301,"comment_content":"散列表和双向链表适合存储于内存中的小数据，不适合磁盘中的大数据。<br><br>LRU 算法是结合散列表和双向链表实现的，它的特点是 O(1) 的读取速度，并保证节点在链表中按照时间顺利排列。但它一般适用于数据量不大的存储。<br><br>如果数据量过大，为了减少散列冲突，需要设置一定的负载因子，也就需要更多额外的存储空间。比如说 10 GB 数据可能需要 15 GB 的存储空间。<br><br>散列表缓存不友好，如果区间查询，每个数据都会有 IO，如果在磁盘中，时间消耗上很不乐观。<br><br>在散列表（中）一节提到，散列表的扩容，如果要实现 O(1) 的均摊复杂度，需要一块更大的新存储空间来逐一搬迁数据。<br><br>综合来看，大量级数据用散列表并没有什么优势。<br><br>个人观点，不正确的地方还望争哥指正~","like_count":0},{"had_liked":false,"id":61446,"user_name":"zzz","can_delete":false,"product_type":"c1","uid":1046791,"ip_address":"","ucode":"091A0D95EE5E3C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/07/ee1bbd42.jpg","comment_is_top":false,"comment_ctime":1547700164,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547700164","product_id":100017301,"comment_content":"1、双向链表；单向的至少不方便支持小于等于这样的范围查找了。<br>2、不能，散列表是无序的，链表链接没有用途。","like_count":0},{"had_liked":false,"id":61408,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1547692387,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547692387","product_id":100017301,"comment_content":"王老师：NOsql 是如何建立索引的呢？也是类似B+ 树这种结构不~","like_count":0},{"had_liked":false,"id":61260,"user_name":"莫弹弹","can_delete":false,"product_type":"c1","uid":1239978,"ip_address":"","ucode":"60A25C709A665F","user_header":"https://static001.geekbang.org/account/avatar/00/12/eb/aa/db213a66.jpg","comment_is_top":false,"comment_ctime":1547647525,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547647525","product_id":100017301,"comment_content":"1 MySQL里的b+树链表应该是单向链表，基于猜测，因为磁盘碟子只能按照一个方向读取数据，就算是双向链表它也不能反转一圈读取上一个数据。<br>基于常识，数据库分页查数据的时候，limit 1000，20 它也是先查1020条再放弃1000条，也就是说它无法精确找到第1000个数据，以此推理节点位置无法像数组那样精确计算。<br>2 hash+链表实现索引是不科学的……因为hash算出来的值跟原数据大小没有关系，非要实现区间查找只能再开个空间保存有序链表指针，（java 的linkedHashMap 就是这样的做法吧），这样还不如直接存进数组里快的多","like_count":0},{"had_liked":false,"id":61257,"user_name":"往事随风，顺其自然","can_delete":false,"product_type":"c1","uid":1235692,"ip_address":"","ucode":"F266EC6B143E38","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/ec/779c1a78.jpg","comment_is_top":false,"comment_ctime":1547646938,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547646938","product_id":100017301,"comment_content":"数据分裂后，子节点数据怎么添加到父节点中，图中表示的","like_count":0},{"had_liked":false,"id":61256,"user_name":"Geek_41dcba","can_delete":false,"product_type":"c1","uid":1089626,"ip_address":"","ucode":"22F9180FBD74F5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/wjK0unDiaUMZYGsl43dovmLWZS6WvDzpespydKfOQHDU55QPZQZvfKKYk4ZaITibGc3wwC3vqTTudWficcPhEia0Xw/132","comment_is_top":false,"comment_ctime":1547646902,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1547646902","product_id":100017301,"comment_content":"前两天刚有点涉及到数据库底层的一些数据结构，课程就出现了，嗯，缘分在那里。。。。<br><br>第一个问题我觉得是双向链表<br>1.对B+树进行删除节点时，如果是单链表，在定位到删除节点后是找不到前节点的，除非尝试重新去找前一个节点<br>2.对索引进行反向范围遍历时单向不能满足要求<br>3.B+树添加的时候单向可以满足要求<br>另一个我的设想是，既然数据库B+树索引是基于页大小的，那是不是意味着一串叶子节点就是放在一个数组中，只需要加减1就可以得到前后的索引节点呢？这样好像构建链表的空间都省了。<br><br>第二个问题<br>我想到的只能是基于插入时间顺序的链表，而不是带排序属性的链表，什么地方会有这样的需求是我任意选择一个点就能够知道在我前面的是谁在我后面的是谁？<br><br>不对的地方还请老师指点！","like_count":0},{"had_liked":false,"id":61158,"user_name":"猫头鹰爱拿铁","can_delete":false,"product_type":"c1","uid":1105958,"ip_address":"","ucode":"24266B58968428","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/26/4942a09e.jpg","comment_is_top":false,"comment_ctime":1547629395,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1547629395","product_id":100017301,"comment_content":"思考题：<br>1.b+树中如果要删除某个数据节点，那么需要双向链表的形式便于删除。否则还得找到该节点的前驱节点。这个很麻烦（得到这个数据节点上级节点的索引k，然后找到这个索引节点对应的k-1子节点.如果这个节点为上级节点的第一个和最后一个还得再级联地找到上上级节点，依此类推）<br>2.可以。这个数据节点在两条链里。一个是散列表里的拉链，另一个是在按照数据大小建立双向链表里。通过散列查找区间起始值和末值，然后在双向链表里遍历这段区间的数据节点。删除和插入时间复杂度变为O(n)。要考虑双向链表的添加和删除。查找时间复杂度为O(1)","like_count":0},{"had_liked":false,"id":61130,"user_name":"Geek_41d472","can_delete":false,"product_type":"c1","uid":1247965,"ip_address":"","ucode":"DEC2B6329460CF","user_header":"https://static001.geekbang.org/account/avatar/00/13/0a/dd/88fa7b52.jpg","comment_is_top":false,"comment_ctime":1547624839,"is_pvip":false,"replies":[{"id":"23152","content":"同学要求太多了😄 毕竟专栏内容涉及有侧重点，也不可能什么面面俱到啊 请理解啊 兄弟！","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1549179436,"ip_address":"","comment_id":61130,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1547624839","product_id":100017301,"comment_content":"以前看高性能mysql的时候就讲了B+树，不过没讲这么仔细，一直没搞清楚某些时候插入数据会导致节点分裂，今天算是搞明白了。原以为这章节会把B+的增强改查某个节点的代码实现写出来，还是有点小失望，哈哈，如果有老师能讲下就更完美了","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436753,"discussion_content":"同学要求太多了😄 毕竟专栏内容涉及有侧重点，也不可能什么面面俱到啊 请理解啊 兄弟！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549179436,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":61110,"user_name":"在路上","can_delete":false,"product_type":"c1","uid":1205712,"ip_address":"","ucode":"18337C6DD5E618","user_header":"https://static001.geekbang.org/account/avatar/00/12/65/d0/b5b00bc2.jpg","comment_is_top":false,"comment_ctime":1547621608,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547621608","product_id":100017301,"comment_content":"题1：B+ 树中，将叶子节点串起来的链表要使用双向链表，当去区间查询时只给了单个边界，比如&lt;v或者&gt;v查询时，单向链表是不能满足要求的。<br>题2：散列表+链表可以实现区间查找数据，数据量小时还可以，数据量大时性能会很差，散列表可以快速查找但是没有顺序，借助于链表保证顺序性，每次新增时时间复杂度是O(n)，所以如果数据量很大插入耗时会让人难以接受。","like_count":0},{"had_liked":false,"id":61053,"user_name":"一川","can_delete":false,"product_type":"c1","uid":1125790,"ip_address":"","ucode":"0E34B99FD1D42E","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/9e/f41bee94.jpg","comment_is_top":false,"comment_ctime":1547609059,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547609059","product_id":100017301,"comment_content":"秒懂B+树","like_count":0},{"had_liked":false,"id":60952,"user_name":"陈道恒","can_delete":false,"product_type":"c1","uid":1189021,"ip_address":"","ucode":"07A0695DEFA270","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/9d/ba45ff4a.jpg","comment_is_top":false,"comment_ctime":1547598135,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547598135","product_id":100017301,"comment_content":"思考题：1、使用的是双向链表，因为要支持大于，也要支持小于两个范围的查找。<br>2、不可以，因为hashMap的就是为了打撒数据，避免冲突。所以对于每个key都要计算一次hash，hash之后就不是一个连续的范围值了，没法按顺序构建链表。第一次回答老师问题，不知道理解的对不对，望指正。","like_count":0}]}